<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用机器学习与遗传算法解决二十一点问题 | 极客快訊</title><meta property="og:title" content="使用机器学习与遗传算法解决二十一点问题 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/77ef79812c4e4890962cd8535fc13c2b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/8ef9c24.html><link rel=canonical href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/8ef9c24.html><meta property="article:published_time" content="2020-10-29T20:46:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:33+08:00"><meta name=Keywords content><meta name=description content="使用机器学习与遗传算法解决二十一点问题"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E6%B8%B8%E6%88%8F/8ef9c24.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用机器学习与遗传算法解决二十一点问题</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E6%B8%B8%E6%88%8F.html>游戏</a></span></div><div class=post-content><div><p>机器学习的一大优点是有很多不同的方法来解决问题。神经网络非常适合在数据中寻找模式，从而产生令人印象深刻的预测能力。强化学习使用基于奖励的概念，随着时间的推移而改进。还有一种方法叫做遗传算法。</p><p>遗传算法（GA）利用进化的原理来解决问题。它的工作原理是使用一组潜在的解决方案来解决一个问题，反复选择和培育最成功的候选方案，直到最终解决方案在几代之后出现。</p><p>为了证明这种方法的有效性，我们将用它来解决一个复杂的问题 - 创建一个玩赌场游戏Blackjack（也称为“二十一点”）的策略。</p><p>本例中的“策略”一词指的是涵盖所有情况的玩家行为指南。我们的目标是找到一种尽可能最佳的策略，从而最大限度地提高奖金。</p><p><strong>关于“Winning”策略</strong></p><p>当然，在现实中没有二十一点的制胜策略——规则设置，坐庄的总是有优势的。如果你玩的时间足够长，你就会赔钱。</p><p>知道这一点，最好的策略就是将损失降至最低。使用这样的策略可以让玩家在希望获得短期好运的同时尽可能地扩大资金。这是二十一点唯一的盈利方式。</p><p>你可以想象，二十一点已经被数学家和计算机科学家研究了很长一段时间。早在20世纪60年代，一位名叫Edward O. Thorp的数学家撰写了一本名为《<em>Beat the Dealer》</em>的书，书中列出了显示最优“基本”策略的图表。</p><p>最优策略看起来像这样：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/77ef79812c4e4890962cd8535fc13c2b><p class=pgc-img-caption>二十一点的最优策略</p></div><p>这三张表代表了玩二十一点的完整策略。</p><p>左边的高桌是hard hands（硬手牌），右上方的桌子是soft hands（软手牌），右下方的桌子是pairs（成对的）。</p><p>如果你不熟悉二十一点，软手牌指的是<strong>A</strong>可以做为1或11，总牌值不超过21。一对是不言自明的，硬手牌基本上是得到的全部的牌，归结为一个总的牌值。</p><p>三张表顶部的列是针对庄家up card（闲家会发两张牌面牌）的，这会影响策略。请注意，up card列不包括Jack（J），Queen（Q）或King（K）。那是因为那些牌都计为10，所以它们都与Ten（“T”）组合在一起以简化表格。</p><p>要使用这些表格，玩家首先要确定他们是否有一对，软牌或硬牌，然后使用相应的行来查看相应的表，并使用相应的列来查看相应的庄家up card。</p><p><strong>符号</strong></p><p>H 拿牌(Hit)</p><p>S 停牌(Stand)</p><p>D 双倍下注(Double)</p><p>P 分牌(Split)</p><p>知道这类问题的最优解实际上非常有帮助。将遗传算法的结果与已知的解决方案进行比较将证明该技术的有效性。</p><p>最后，在我们继续之前还有一件事需要解决，那就是不确定性。这意味着如果相同的GA代码连续运行两次，将返回两个不同的结果。遗传算法由于其固有的随机性而发生了这种情况。软件以这种方式运行是不寻常的，但是在这种情况下，这只是方法的一部分。</p><p><strong>遗传算法如何工作</strong></p><p>遗传算法很有趣，因为它们很容易理解：你从一群（最初是完全随机的）潜在解决方案开始，然后让进化自己去寻找一个解。</p><p>通过比较候选解决方案来推动这一进化过程。每个候选者都有一个合适得分，表明它有多好。对于所有候选者，该分数每代计算一次，并且可用于将它们相互比较。</p><p>在二十一点策略的情况下，合适得分非常简单：如果您使用策略玩N组二十一点，你在玩的时候有多少钱？（由于庄家的优势，所有策略都会亏钱，这意味着所有合适得分都是负面的。策略的较高合适得分只意味着它可能比其他策略损失的钱越少。）</p><p>一旦创建了有效的fitness函数，使用GA时的下一个决定是如何进行选择。</p><p>有许多不同的选择技术来控制选择在多大程度上是由合适得分与随机性驱动选择的。一种简单的方法称为Tournament Selection，它通过从群体中挑选N个随机候选者并使用具有最佳合适得分的候选者来工作。它简单而有效。</p><p>一旦选择了两个父母，他们就会被交叉组成一个孩子。这与正常的有性生殖一样 ——来自父母双方的遗传物质相结合。因为父母的选择是基于健康的考虑，所以目标是从父母双方身上传递成功的元素。</p><p>当然，在这种情况下，“遗传物质”仅仅是每种策略所具有的三张表中的340个单元格。通过从两个父母之一中选择相应的细胞来填充孩子中的细胞。通常情况下，交叉与相对合适得分成比例，因此如果父母的健康得分明显更好，则父母最终可能比其他父母贡献更多的表格边框。</p><p>最后，就像在自然界一样，拥有多样性非常重要。太少或太均匀的群体总是比更大和更多样化的群体表现更差。遗传多样性很重要，因为如果你没有足够的东西，很容易陷入被称为局部最小值的东西，这基本上是一种比任何类似的替代方案表现更好的解决方案，但是不如其他解决方案明显不同于它。</p><p>为了避免这个问题，遗传算法有时会使用突变（引入全新的遗传物质）来促进遗传多样性，尽管较大的初始种群也有帮助。</p><p><strong>使用GA的结果</strong></p><p>关于GA的一个很酷的事情就是看着他们发展出一个解决方案。第一代充满了完全随机的解决方案。这是第0代（第一代，随机代）中750名候选者的最佳解决方案（基于合适的评分）：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/b79b72bd12544157b1b06ca228c76f60><p class=pgc-img-caption>从第0代随机生成的候选项</p></div><p>如你所见，这完全是随机的。到了第12代，一些事情开始成形：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/4ec84e73eb574b759dfe7893d05e342b><p class=pgc-img-caption></p></div><p>只有12代经验，最成功的策略是那些坚持20、19、18甚至17的策略。这部分策略首先发展起来，因为这种情况经常发生，而且结果相当明确。基本概念首先由GAs开发，详细信息将在后面几代中介绍。</p><p>该策略的另一个特性暗示最好能够控制在11和10。根据最佳策略，那些应该主要是Double-Down（双倍下注），所以看到那么多的黄色是很让人兴奋地。</p><p>成对和软手牌之所以能发展到最后，因为这些牌很少发生。例如，一个玩家只有6%的机率是一对牌。</p><p>到了第33代，事情开始变得清晰：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/167e26b054f64029a0a424b0da3705bf><p class=pgc-img-caption></p></div><p>到第100代，左侧的硬手牌完全稳定——一代一代都没有变化。软手牌和成对表变得更加精致：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/7360b2efc5f04576bd0688ad891f720b><p class=pgc-img-caption></p></div><p>最后几代用于改进策略。在这个阶段，一代又一代的变化要小得多，因为这实际上只是计算出最小细节的过程。</p><p>最后，在第237代找到的最佳解决方案：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/f37605ed50544da7af7290e66bba4152><p class=pgc-img-caption></p></div><p>正如您所看到的，最终结果与最优解决方案并不完全相同，但它非常非常接近。特别是硬手牌几乎完全正确。软手牌和成对表有几个不匹配的单元格，但这可能是因为那些手牌类型的发生远远少于硬手牌。</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/088bce7a25a34523b0f229976ecd650b><p class=pgc-img-caption></p></div><p>在结果方面，以每手5美元的价格制定5万手的最优策略将导致损失176040美元。使用计算机生成的策略将导致损失176538美元，超过50万手的差异为498美元。</p><p><strong>组合意义</strong></p><p>尽管最终策略令人印象深刻，但我们需要通过考虑问题的范围来将其置于环境中。二十一点的最优策略是通过填充每个340个表格单元格（分布在三个表格中）来表示每个持有/庄家up card组合的最佳选择——包括stand、hit、double-down或split。</p><p>在组合方面，有4¹⁰⁰种可能的配对策略，3⁸⁰种可能的软手牌策略，以及3¹⁶⁰种可能的硬手牌策略，对于二十一点总共5 x 10¹⁷⁴种可能的策略：</p><p>4¹⁰⁰x 3⁸⁰x 3¹⁶⁰= 5 x 10¹⁷⁴可能的二十一点策略</p><p>在这种情况下，遗传算法找到一个接近最佳的解决方案的解决方案空间5 x 10¹⁷⁴可能的答案。在普通电脑上运行，​​大约需要75分钟。在此期间，评估了大约178,000个策略。</p><p><strong>测试Fitness（合适度）</strong></p><p>遗传算法基本上由fitness函数驱动。如果没有一种比较候选者的好方法，进化过程就无法发挥作用。</p><p>fitness函数的想法很简单。即使我们可能不知道问题的最佳解决方案，我们也有办法相互衡量潜在的解决方案。fitness函数反映了传递给它的候选者的相对fitness水平，因此得分可以有效地用于选择。</p><p>为了找到二十一点策略，fitness函数很简单——它是一个函数，在使用一定数量的牌之后返回预期的最终收益。</p><p>但是多少手才能够呢？</p><p>事实证明，您需要通过策略来确定其品质。由于一副牌的固有随机性，需要玩很多牌，以便随机性在候选者之间平衡。</p><p>当我们的GA接近最终解决方案时，这一点尤为重要。在早期阶段，如果合适得分不准确，则不是问题，因为不良候选者和优秀候选者之间的差异通常非常大，并且收敛到最终的解决方案继续没有问题。</p><p>然而，一旦GA进入下一代，被比较的候选策略将只有很小的差异，因此从fitness函数获得准确的预期收益是很重要的。</p><p>幸运的是，找到所需的正确手数非常简单。使用单个策略，运行多个测试，产生一组合适得分。相同策略在不同运行之间的差异将揭示出有多少可变性，而可变性在一定程度上是由测试的手的数量所驱动的。玩的越多，变化越小。</p><p>通过测量一组分数的标准差我们可以知道N次测试中，整个集合的变异性有多大。但是当我们在每个测试中使用不同的手数进行实验时，我们不能比较标准差，原因如下：</p><p>标准偏差按比例缩放到基础数据。我们无法将合适得分（或其标准偏差）与使用不同手数的测试进行比较，因为较高数量的手牌会导致合适得分相应增加。</p><p>简单来说：利用策略获胜的机率为34%。如果你的手牌数为25,000手而不是50,000手，你最终会有不同的总数。这就是为什么你不能简单地比较不同测试条件导致的合适得分的原因。如果无法比较原始值，则无法比较标准偏差。</p><p>我们通过将标准偏差除以每个测试值的平均合适得分（即所玩的手数）来解决这个问题。这就得到了所谓的变异系数，它可以与其他测试值进行比较，而不考虑手牌的数量。</p><p>这里的图表展示了当我们玩更多牌时可变性如何缩小：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/28c0bf4d5b7b475f93e7a709c4aafcb1><p class=pgc-img-caption></p></div><p>图表中有一些观察结果。首先，仅用5,000或10,000手测试是不够的。同样的策略在这些水平上的合适得分将有大幅波动。事实上，看起来至少10万手是合理的，因为这是变异性开始变平的点。</p><p>我们可以每次测试运行500,000或更多手吗？当然。它减少了可变性并提高了fitness函数的准确性。事实上，500,000手牌的变异系数为0.0229，远远高于100,000手牌的0.0494。但这种改善肯定是收益递减的情况：测试数量必须增加5倍才能获得一半的变化。</p><p>鉴于这些发现，战略的fitness函数需要使用以下规则（在现实世界的赌场中常见）至少玩10万次二十一点：</p><ul><li>使用4副牌在一起</li><li>庄家必须拿牌，直到他们达到17（软或硬）</li><li>你可以双倍下注分牌</li><li>没有保险（如果庄家牌面朝上的牌是A，玩家可以买保险，也就是相当于原赌注一半的额外赌金）</li><li><strong>Blackjack</strong>（<strong>A牌和一张花牌或10点牌</strong>）需要支付1.5倍</li></ul><p><strong>遗传算法配置</strong></p><p>使用GA的一个不寻常的方面是它有很多需要配置的设置。可以为运行配置以下项：</p><ul><li>总体规模</li><li>选择方法</li><li>突变率和影响</li><li>终止条件</li></ul><p>改变这些会得到不同的结果。确定这些设置的值的最佳方法就是进行试验。</p><p><strong>总体规模</strong></p><p>以下是不同总体规模的每代平均候选者合适度状况图表：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/0f274aa8a87343d2a0b8150f6b31d1dd><p class=pgc-img-caption></p></div><p>图中的X轴为代数（最大值为200），Y轴是每代的平均合适得分。当我们到达下一代时，前几代并未显示出强调差异。</p><p>沿着图表顶部的平白线是已知的最佳基线策略的合适得分。</p><p>首先要注意的是，两个最小的群体（分别只有100和250个候选者，以蓝色和橙色显示）在所有大小中表现最差。</p><p>这些小群体缺乏遗传多样性导致最终合适得分较差，以及寻找解决方案的过程较慢。显然，拥有足够大的候选者来确保遗传多样性非常重要。</p><p>另一方面，400、550、700、850和1000的候选者之间没有太多差异。</p><p>这与选择要测试的手数相似 - 如果选择的值太小，则测试不准确，但一旦超过某个水平，差异就会很小。</p><p><strong>选择方法</strong></p><p>寻找交叉的良好候选者的过程称为选择，并且有许多方法可以做到这一点。Tournament selection已经涵盖。以下是另外两种方法：</p><p>一种以候选者的合适得分来选择候选者的比例。该选择方法的问题之一是有时某些候选者将具有很小的合适得分，以至于他们从未被选中。另外，有几个候选者的合适得分远远高于其他候选者，那么他们的选择可能不成比例，这会降低遗传多样性。</p><p>另一种解决方案是使用排名选择，其通过按合适度对候选者进行排序，然后给予最差候选者1分，然后为2，依此类推，一直到最佳候选者，得分等于总体规模。</p><p>这是一个使用各种选择方法比较每代平均合适度的图表：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/1e49bfad514147559f407a62a3801563><p class=pgc-img-caption></p></div><p>正如你所看到的，Tournament selection的选择非常迅速地集中在最优解决方案上 ——实际上，Tournament selection的规模越大，平均合适得分提高的速度就越快。这是有道理的，因为如果你选择7个随机候选者并且使用最好的候选者，质量会比只选择2个候选者要高得多。</p><p>尽管它最初的进步是最快的，但最终的结果却是最差的，Tourney 7 最终产生最坏的结果，这是有道理的，因为虽然一个高的Tourney规模导致快速改善，但它也将基因库限制到最好，遗传的多样性损失了，从长远来看，它的表现并不好。</p><p>表现最佳的是Tourney 2，Tourney 3和Tourney 4。</p><p><strong>Elitism</strong></p><p>遗传算法中还有另一个称为Elitism的概念。这个想法是，在建立新一代时，首先按照合适度对总体进行排序，然后将一定比例的最佳候选者直接传递给下一代，而不做任何改动。完成后，正常交叉开始。</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/4d8b79189c594e71b96dbd2a4d8351dd><p class=pgc-img-caption></p></div><p>此图表显示了四种不同Elitism率的影响（仅限后代，以显示详细信息）。虽然E=0％看起来好一些，但实际上E=15％才是最合理的。</p><p>这个图表有一点令人惊讶 ——Elitism越高，解决趋同问题的速度就越慢。你可能会认为故意把每一代中最优秀的包括进来会加快速度，但实际上，看起来使用交叉的候选者会带来最好的结果，而且也是最快的。</p><p><strong>突变</strong></p><p>保持遗传多样性很重要，突变是引入这种多样性的一种简单方法。</p><p>与突变有关的因素有两个：突变发生的频率，以及突变发生时的影响程度。</p><p>一突变率控制新创建的候选基因发生突变的频率。突变是在创造之后通过交叉完成的。</p><p>根据随机改变的细胞百分比，突变影响控制了候选细胞的突变量。所有三个表（硬手牌，软手牌和成对的）都以相同的百分比变异。</p><p>从10％的固定影响率开始，以下是不同变异率的影响：</p><div class=pgc-img><img alt=使用机器学习与遗传算法解决二十一点问题 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/d02984dc0dbb415abd72ee6f9da68749><p class=pgc-img-caption></p></div><p>很明显，突变对这个问题没有帮助——受突变影响的候选者越多，结果就越糟。因此，不需要尝试不同的突变影响值 —— 0％的突变率显然是这个问题的最佳选择。</p><p><strong>终止条件</strong></p><p>知道何时退出遗传算法可能很棘手。有些情况下需要固定数量的代，但是对于这个问题，解决方案是寻找停滞——换句话说，遗传算法在检测到候选者不再改进时停止。</p><p>用于该测试的条件是如果连续25代的总体最佳策略（或一代的平均分数）没有改善，则该过程终止并且将该点发现的最佳结果用作最终解决方案。</p><p><strong>总结</strong></p><p>遗传算法是解决复杂问题的有力技术，它们具有易于理解的优点。对于由于组合因素导致的巨大解空间问题，它们非常有效。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'机器','学习','遗传'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>