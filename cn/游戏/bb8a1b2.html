<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>十年架构师经验总结：分布式事务解决方案 | 极客快訊</title><meta property="og:title" content="十年架构师经验总结：分布式事务解决方案 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="http://p1.pstatp.com/large/dfic-imagehandler/a79a5fb9-2cc2-48f2-8279-7046f785c9f5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/bb8a1b2.html><link rel=canonical href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/bb8a1b2.html><meta property="article:published_time" content="2020-10-29T20:46:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:29+08:00"><meta name=Keywords content><meta name=description content="十年架构师经验总结：分布式事务解决方案"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E6%B8%B8%E6%88%8F/bb8a1b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>十年架构师经验总结：分布式事务解决方案</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E6%B8%B8%E6%88%8F.html>游戏</a></span></div><div class=post-content><div><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/dfic-imagehandler/a79a5fb9-2cc2-48f2-8279-7046f785c9f5><p class=pgc-img-caption></p></div><p>分布式事务的实现主要有以下 5 种方案：</p><ul><li>XA 方案</li><li>TCC 方案</li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><p><strong>两阶段提交方案/XA方案</strong></p><p>所谓的 XA 方案，即：两阶段提交，有一个 <strong>事务管理器</strong> 的概念，负责协调多个数据库（资源管理器）的事务，事务管理器先问问各个数据库你准备好了吗？如果每个数据库都回复 ok，那么就正式提交事务，在各个数据库上执行操作；如果任何其中一个数据库回答不 ok，那么就回滚事务。</p><p>这种分布式事务方案，比较适合单块应用里，跨多个库的分布式事务，而且因为严重依赖于数据库层面来搞定复杂的事务，效率很低，绝对不适合高并发的场景。如果要玩儿，那么基于 Spring + JTA 就可以搞定，自己随便搜个 demo 看看就知道了。</p><p>这个方案，我们很少用，一般来说 <strong>某个系统内部如果出现跨多个库</strong> 的这么一个操作，是 <strong>不合规</strong> 的。我可以给大家介绍一下， 现在微服务，一个大的系统分成几十个甚至几百个服务。一般来说，我们的规定和规范，是要求 <strong>每个服务只能操作自己对应的一个数据库</strong> 。</p><p>如果你要操作别的服务对应的库，不允许直连别的服务的库，违反微服务架构的规范，你随便交叉胡乱访问，几百个服务的话，全体乱套，这样的一套服务是没法管理的，没法治理的，可能会出现数据被别人改错，自己的库被别人写挂等情况。</p><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/dfic-imagehandler/66307553-b9bb-41c4-91ec-5b1c251f5563><p class=pgc-img-caption></p></div><p>如果你要操作别人的服务的库，你必须是通过 <strong>调用别的服务的接口</strong> 来实现，绝对不允许交叉访问别人的数据库。</p><p class=ql-align-center></p><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p9.pstatp.com/large/pgc-image/33c18fa36901495a95dc63a5725ae7d3><p class=pgc-img-caption></p></div><p class=ql-align-center>​</p><p><strong>TCC 方案</strong></p><p>TCC 的全称是： Try 、 Confirm 、 Cancel 。</p><ul><li>Try 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行 <strong>锁定或者预留</strong> 。</li><li>Confirm 阶段：这个阶段说的是在各个服务中 <strong>执行实际的操作</strong> 。</li><li>Cancel 阶段：如果任何一个服务的业务方法执行出错，那么这里就需要 <strong>进行补偿</strong> ，就是执行已经执行成功的业务逻辑的回滚操作。（把那些执行成功的回滚）</li></ul><p>这种方案说实话几乎很少人使用，我们用的也比较少，但是也有使用的场景。因为这个 <strong>事务回滚</strong> 实际上是 <strong>严重依赖于你自己写代码来回滚和补偿</strong> 了，会造成补偿代码巨大，非常之恶心。</p><p>比如说我们，一般来说跟 <strong>钱</strong> 相关的，跟钱打交道的， <strong>支付</strong> 、 <strong>交易</strong> 相关的场景，我们会用 TCC，严格保证分布式事务要么全部成功，要么全部自动回滚，严格保证资金的正确性，保证在资金上不会出现问题。</p><p>而且最好是你的各个业务执行的时间都比较短。</p><p>但是说实话，一般尽量别这么搞，自己手写回滚逻辑，或者是补偿逻辑，实在太恶心了，那个业务代码是很难维护的。</p><p class=ql-align-center></p><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/ad0ad055c86c4ad99af2dd11af5e21a1><p class=pgc-img-caption></p></div><p class=ql-align-center>​</p><p><strong>本地消息表</strong></p><p>本地消息表其实是国外的 ebay 搞出来的这么一套思想。</p><p>这个大概意思是这样的：</p><ol><li>A 系统在自己本地一个事务里操作同时，插入一条数据到消息表；</li><li>接着 A 系统将这个消息发送到 MQ 中去；</li><li>B 系统接收到消息之后，在一个事务里，往自己本地消息表里插入一条数据，同时执行其他的业务操作，如果这个消息已经被处理过了，那么此时这个事务会回滚，这样 <strong>保证不会重复处理消息</strong> ；</li><li>B 系统执行成功之后，就会更新自己本地消息表的状态以及 A 系统消息表的状态；</li><li>如果 B 系统处理失败了，那么就不会更新消息表状态，那么此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中去，让 B 再次处理；</li><li>这个方案保证了最终一致性，哪怕 B 事务失败了，但是 A 会不断重发消息，直到 B 那边成功为止。</li></ol><p>这个方案说实话最大的问题就在于 <strong>严重依赖于数据库的消息表来管理事务</strong> 啥的，如果是高并发场景咋办呢？咋扩展呢？所以一般确实很少用。</p><p class=ql-align-center></p><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/05234c6d20c340eaabe5060e4f4ec236><p class=pgc-img-caption></p></div><p class=ql-align-center>​</p><p><strong>可靠消息最终一致性方案</strong></p><p>这个的意思，就是干脆不要用本地的消息表了，直接基于 MQ 来实现事务。比如阿里的 RocketMQ 就支持消息事务。</p><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/dfic-imagehandler/93f1ef67-e8d4-435a-9032-8fd069fbae84><p class=pgc-img-caption></p></div><p>大概的意思就是：</p><ol><li>A 系统先发送一个 prepared 消息到 mq，如果这个 prepared 消息发送失败那么就直接取消操作别执行了；</li><li>如果这个消息发送成功过了，那么接着执行本地事务，如果成功就告诉 mq 发送确认消息，如果失败就告诉 mq 回滚消息；</li><li>如果发送了确认消息，那么此时 B 系统会接收到确认消息，然后执行本地的事务；</li><li>mq 会自动 <strong>定时轮询</strong> 所有 prepared 消息回调你的接口，问你，这个消息是不是本地事务处理失败了，所有没发送确认的消息，是继续重试还是回滚？一般来说这里你就可以查下数据库看之前本地事务是否执行，如果回滚了，那么这里也回滚吧。这个就是避免可能本地事务执行成功了，而确认消息却发送失败了。</li><li>这个方案里，要是系统 B 的事务失败了咋办？重试咯，自动不断重试直到成功，如果实在是不行，要么就是针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，想办法通知系统 A 也回滚；或者是发送报警由人工来手工回滚和补偿。</li><li>这个还是比较合适的，目前国内互联网公司大都是这么玩儿的，要不你举用 RocketMQ 支持的，要不你就自己基于类似 ActiveMQ？RabbitMQ？自己封装一套类似的逻辑出来，总之思路就是这样子的。</li></ol><p class=ql-align-center></p><div class=pgc-img><img alt=十年架构师经验总结：分布式事务解决方案 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/355770f1d66949f6b0a1a25b065ae182><p class=pgc-img-caption></p></div><p class=ql-align-center>​</p><p><strong>最大努力通知方案</strong></p><p>这个方案的大致意思就是：</p><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的 <strong>最大努力通知服务</strong> ，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入个内存队列也可以，接着调用系统 B 的接口；</li><li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B，反复 N 次，最后还是不行就放弃。</li></ol><div class=tt-column-card data-content='{"thumb_url":"http://p2.pstatp.com/large/pgc-image/155695727411129d5805e67","title":"Java高并发分布式技术系列精选课","author_description":"IT技术分享","price":59.9,"share_price":0,"sold":24,"column_id":"6687030895418802440","distribution_user_id":6797553566,"new_thumb_url":"http://sf3-ttcdn-tos.pstatp.com/img/pgc-image/155695727411129d5805e67"}'><p class=column-placeholder></p></div><p><strong>需要的Java架构师方面的资料可以关注之后私信哈，回复“资料”领取免费架构视频资料，记得要点赞转发噢！！！</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'架构','师经验','总结'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>