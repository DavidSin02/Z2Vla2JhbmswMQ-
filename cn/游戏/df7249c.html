<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>分布式事务 -- 最佳实践方案汇总 -- 看这1篇就够了 | 极客快訊</title><meta property="og:title" content="分布式事务 -- 最佳实践方案汇总 -- 看这1篇就够了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="http://p3.pstatp.com/large/pgc-image/b8521c43d5c24aed917d60ef4d5aa249"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e6%b8%b8%e6%88%8f/df7249c.html><link rel=canonical href=https://geekbank.cf/tw/%e6%b8%b8%e6%88%8f/df7249c.html><meta property="article:published_time" content="2020-10-29T20:46:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:46:29+08:00"><meta name=Keywords content><meta name=description content="分布式事务 -- 最佳实践方案汇总 -- 看这1篇就够了"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E6%B8%B8%E6%88%8F/df7249c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>分布式事务 -- 最佳实践方案汇总 -- 看这1篇就够了</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E6%B8%B8%E6%88%8F.html>游戏</a></span></div><div class=post-content><div><p class=ql-align-justify>说到分布式事务，就会谈到那个经典的”账号转账”问题：2个账号，分布处于2个不同的DB，对应2个不同的系统A,B。A要扣钱，B要加钱，如何保证原子性？</p><p class=ql-align-justify><strong>传统方案 -- 2PC</strong></p><p class=ql-align-justify>（1）2PC的理论层面：</p><p class=ql-align-justify>2pc涉及到2个阶段，3个操作：</p><p class=ql-align-justify>阶段1：“准备提交”。事务协调者向所有参与者发起prepare，所有参与者回答yes/no。</p><p class=ql-align-justify>阶段2：“正式提交”。如果所有参与者都回答yes，则向所有参与者发起commit；否则，向所有参与者发起rollback。</p><p class=ql-align-justify>因此，要实现2pc，所有参与者，都得实现3个接口：prepare/commit/rollback。</p><p class=ql-align-justify>（2）2PC的实现层面</p><p class=ql-align-justify>对应的实现层面，也就是XA协议，通常的数据库都实现了这个协议。</p><p class=ql-align-justify>有一个Atomikos开源库，提供了2PC的实现方案。有兴趣的可以去看一下如何使用。</p><p class=ql-align-justify>（3）2PC的问题</p><p class=ql-align-justify>问题1：阶段2，事务协调者挂了，则所有参与者接受不到commit/rollback指令，将处于“悬而不决”状态</p><p class=ql-align-justify>问题2：阶段2，其中一个参与者超时或者出错，那其他参与者，是commit，还是rollback呢？ 也不能确定</p><p class=ql-align-justify>为了解决2pc的问题，又引入3pc。3pc有类似的挂了如何解决的问题，因此还是没能彻底解决问题，此处就不详述了。</p><p class=ql-align-justify>问题3：2PC的实现，目前主要是用在数据库层面（数据库实现了XA协议）。但目前，大家基本都是微服务架构，不会直接在2个业务DB之间搞一致性，而是想如何在2个服务上面实现一致性。</p><p class=ql-align-justify>正因为2PC有上面诸多问题和不便，实践中一般很少使用，而是采用下面将要讲的各种方案。</p><p class=ql-align-justify><strong>最终一致性</strong></p><p class=ql-align-justify>一般的思路都是通过消息中间件来实现“最终一致性”：A系统扣钱，然后发条消息给中间件，B系统接收此消息，进行加钱。</p><p class=ql-align-justify>但这里面有个问题：A是先update DB，后发送消息呢？ 还是先发送消息，后update DB？</p><p class=ql-align-justify>假设先update DB成功，发送消息网络失败，重发又失败，怎么办？</p><p class=ql-align-justify>假设先发送消息成功，update DB失败。消息已经发出去了，又不能撤回，怎么办？</p><p class=ql-align-justify>所以，这里下个结论： 只要发送消息和update DB这2个操作不是原子的，无论谁先谁后，都是有问题的。</p><p class=ql-align-justify>那这个问题怎么解决呢？？</p><h1 class=ql-align-justify><strong>错误的方案0</strong></h1><p class=ql-align-justify>有人可能想到了，我可以把“发送消息”这个网络调用和update DB放在同1个事务里面，如果发送消息失败，update DB自动回滚。这样不就保证2个操作的原子性了吗？</p><p class=ql-align-justify>这个方案看似正确，其实是错误的，原因有2：</p><p class=ql-align-justify>（1）网络的2将军问题：发送消息失败，发送方并不知道是消息中间件真的没有收到消息呢？还是消息已经收到了，只是返回response的时候失败了？</p><p class=ql-align-justify>如果是已经收到消息了，而发送端认为没有收到，执行update db的回滚操作。则会导致A账号的钱没有扣，B账号的钱却加了。</p><p class=ql-align-justify>（2）把网络调用放在DB事务里面，可能会因为网络的延时，导致DB长事务。严重的，会block整个DB。这个风险很大。</p><p class=ql-align-justify>基于以上分析，我们知道，这个方案其实是错误的！</p><p class=ql-align-justify><strong>方案1 -- 最终一致性（业务方自己实现）</strong></p><p class=ql-align-justify>假设消息中间件没有提供“事务消息”功能，比如你用的是Kafka。那如何解决这个问题呢？</p><p class=ql-align-justify>解决方案如下：</p><p class=ql-align-justify>（1）Producer端准备1张消息表，把update DB和insert message这2个操作，放在一个DB事务里面。</p><p class=ql-align-justify>（2）准备一个后台程序，源源不断的把消息表中的message传送给消息中间件。失败了，不断重试重传。允许消息重复，但消息不会丢，顺序也不会打乱。</p><p class=ql-align-justify>（3）Consumer端准备一个判重表。处理过的消息，记在判重表里面。实现业务的幂等。但这里又涉及一个原子性问题：如果保证消息消费 + insert message到判重表这2个操作的原子性？</p><p class=ql-align-justify>消费成功，但insert判重表失败，怎么办？关于这个，在Kafka的源码分析系列，第1篇， exactly once问题的时候，有过讨论。</p><p class=ql-align-justify>通过上面3步，我们基本就解决了这里update db和发送网络消息这2个操作的原子性问题。</p><p class=ql-align-justify>但这个方案的一个缺点就是：需要设计DB消息表，同时还需要一个后台任务，不断扫描本地消息。导致消息的处理和业务逻辑耦合额外增加业务方的负担。</p><h1 class=ql-align-justify><strong>方案2 -- 最终一致性（RocketMQ 事务消息）</strong></h1><p class=ql-align-justify>为了能解决该问题，同时又不和业务耦合，RocketMQ提出了“事务消息”的概念。</p><p class=ql-align-justify>具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段。</p><p class=ql-align-justify>具体来说，上面的2个步骤，被分解成3个步骤：</p><p class=ql-align-justify>(1) 发送Prepared消息</p><p class=ql-align-justify>(2) update DB</p><p class=ql-align-justify>(3) 根据update DB结果成功或失败，Confirm或者取消Prepared消息。</p><p class=ql-align-justify>可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？</p><p class=ql-align-justify>总结：对比方案2和方案1，RocketMQ最大的改变，其实就是把“扫描消息表”这个事情，不让业务方做，而是消息中间件帮着做了。</p><p class=ql-align-justify>至于消息表，其实还是没有省掉。因为消息中间件要询问发送方，事物是否执行成功，还是需要一个“变相的本地消息表”，记录事物执行状态。</p><p class=ql-align-justify><strong>人工介入</strong></p><p class=ql-align-justify>可能有人又要说了，无论方案1，还是方案2，发送端把消息成功放入了队列，但消费端消费失败怎么办？</p><p class=ql-align-justify>消费失败了，重试，还一直失败怎么办？是不是要自动回滚整个流程？</p><p class=ql-align-justify>答案是人工介入。从工程实践角度讲，这种整个流程自动回滚的代价是非常巨大的，不但实现复杂，还会引入新的问题。比如自动回滚失败，又怎么处理？</p><p class=ql-align-justify>对应这种极低概率的case，采取人工处理，会比实现一个高复杂的自动化回滚系统，更加可靠，也更加简单。</p><p class=ql-align-justify><strong>方案3：TCC</strong></p><p class=ql-align-justify>为了解决SOA系统中的分布式事务问题，支付宝提出了TCC。2PC通常都是在跨库的DB层面，而TCC本质就是一个应用层面的2PC。</p><p class=ql-align-justify>同样，TCC中，每个参与者需要3个操作：Try/Confirm/Cancel，也是2个阶段。</p><p class=ql-align-justify>阶段1：”资源预留/资源检查“，也就是事务协调者调用所有参与者的Try操作</p><p class=ql-align-justify>阶段2：“一起提交”。如果所有的Try成功，一起执行Confirm。否则，所有的执行Cancel.</p><p class=ql-align-justify><strong>TCC是如何解决2PC的问题呢？</strong></p><p class=ql-align-justify>关键：Try阶段成功之后，Confirm如果失败(不管是协调者挂了，还是某个参与者超时），不断重试！！</p><p class=ql-align-justify>同样，Cancel失败了，也是不断重试。这就要求Confirm/Cancel都必须是幂等操作。</p><p class=ql-align-justify>下面以1个转账case为例，来说明TCC的过程：</p><p class=ql-align-justify>有3个账号A, B, C，通过SOA提供的转账服务操作。A, B同时分别要向C转30, 50元，最后C的账号+80，A, B各减30, 50。</p><p class=ql-align-justify>阶段1：A账号锁定30，B账号锁定50，检查C账号的合法性（比如C账号是否违法被冻结，C账号是否已注销。。。）。</p><p class=ql-align-justify>所以，对应的“扣钱”的Try操作就是”锁定”，对应的“加钱”的Try操作就是检查账号合法性</p><p class=ql-align-justify>阶段2：A, B, C都Try成功，执行Confirm。即A, B减钱，C加钱。如果任意一个失败，不断重试！</p><p class=ql-align-justify>从上面的案例可以看出，Try操作主要是为了“保证业务操作的前置条件都得到满足”，然后在Confirm阶段，因为前置条件都满足了，所以可以不断重试保证成功。</p><p class=ql-align-justify><strong>方案4：事务状态表 + 调用方重试 + 接收方幂等 （同步 + 异步）</strong></p><p class=ql-align-justify>同样以上面的转账为例：调用方调系统A扣钱，系统B加钱，如何保证2个同时成功？</p><p class=ql-align-justify>调用方维护1张事务状态表（或者说事务日志，日志流水），每次调用之前，落盘1条事务流水，生成1个全局的事务ID。表结构大致如下：</p><div class=pgc-img><img alt="分布式事务 -- 最佳实践方案汇总 -- 看这1篇就够了" onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/b8521c43d5c24aed917d60ef4d5aa249><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>初始状态是Init，每调用成功1个系统更新1次状态（这里就2个系统），最后所有系统调用成功，状态更新为Success。</p><p class=ql-align-justify>当然，你也可以不保存中间状态，简单一点，你也可以只设置2个状态：Init/Success，或者说begin/end。</p><p class=ql-align-justify>然后有个后台任务，发现某条流水，在过了某个时间之后(假设1次事务执行成功通常最多花费30s)，状态仍然是Init，那就说明这条流水有问题。就重新调用系统A，系统B，保证这条流水的最终状态是Success。当然，系统A, 系统B根据这个全局的事务ID，做幂等，所以重复调用也没关系。</p><p class=ql-align-justify>这就是通过同步调用 + 后台任务异步补偿，最终保证系统一致性。</p><p class=ql-align-justify>补充说明：</p><p class=ql-align-justify>（1）如果后台任务重试多次，仍然不能成功，那要为状态表加1个Error状态，要人工介入干预了。</p><p class=ql-align-justify>（2）对于调用方的同步调用，如果部分成功，此时给客户端返回什么呢？</p><p class=ql-align-justify>答案是不确定，或者说暂时未知。你只能告诉用户，该笔转账超时，稍后再来确认。</p><p class=ql-align-justify>（3）对于同步调用，调用方调用A，或者B失败的时候，可以重试3次。重试3次还不成功，放弃操作。再交由后台任务后续处理。</p><div class=pgc-img><img alt="分布式事务 -- 最佳实践方案汇总 -- 看这1篇就够了" onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/e8330109318d49c39c6981c3fe539f8e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>方案4的扩展：状态机 + 对账</strong></p><p class=ql-align-justify>把方案4扩展一下，岂止事务有状态，系统中的各种数据对象都有状态，或者说都有各自完整的生命周期。</p><p class=ql-align-justify><strong>这种完整的生命周期，天生就具有校验功能！！！我们可以很好的利用这个特性，来实行系统的一致性。</strong></p><p class=ql-align-justify><strong>一旦我们发现系统中的某个数据对象，过了一个限定时间，生命周期仍然没有走完，仍然处在某个中间状态，那就说明系统不一致了，可以执行某种操作。</strong></p><p class=ql-align-justify>举个电商系统的订单的例子：一张订单，从“已支付”，到“下发给仓库”，到“出仓完成”。假定从“已支付”到“下发给仓库”，最多用1个小时；从“下发给仓库”到“出仓完成”，最多用8个小时。</p><p class=ql-align-justify>那意味着：只要我发现1个订单的状态，过了1个小时之后，还是“已支付”，我就认为订单下发没有成功，我就重新下发，也就是上面所说的“重试”；</p><p class=ql-align-justify>同样，只要我发现订单过了8个小时，还未出仓，我这个时候可能就会发报警出来，是不是仓库的作业系统出了问题。。。诸如此类。</p><p class=ql-align-justify>更复杂一点：订单有状态，库存系统的库存也有状态，优惠系统的优惠券也有状态，根据业务规则，这些状态之间进行比对，就能发现系统某个地方不一致，做相应的补偿行为。</p><p class=ql-align-justify>上面说的“最终一致性”和TCC、状态机+对账，都是比较“完美”的方案，能完全保证数据的一致性。</p><p class=ql-align-justify>但是呢，最终一致性这个方案是异步的；</p><p class=ql-align-justify>TCC需要2个阶段，性能损耗大；</p><p class=ql-align-justify>事务状态表，或者状态机，每次要记事务流水，要更新状态，性能也有损耗。</p><p class=ql-align-justify>如果我需要1个同步的方案，可以立马得到结果，同时又要有很高的性能，支持高并发，那怎么处理呢？</p><p class=ql-align-justify><strong>方案5：妥协方案 -- 弱一致性 + 基于状态的补偿</strong></p><p class=ql-align-justify>举个典型场景：</p><p class=ql-align-justify>电商网站的下单，扣库存。订单系统有订单的DB，订单的服务；库存系统有库存的DB，库存的服务。 如何保证下单 + 扣库存，2个的原子性呢？</p><p class=ql-align-justify>如果用上面的最终一致性方案，因为是异步的，库存扣减不及时，会导致超卖，因此最终一致性的方案不可行；</p><p class=ql-align-justify>如果用TCC的方案，性能可能又达不到。</p><p class=ql-align-justify>这里，就采用了一种弱一致的方案，什么意思呢？</p><p class=ql-align-justify>对于该需求，有1个关键特性：对于电商的购物来讲，允许少卖，但不能超卖。你有100件东西，卖给99个人，有1件没有卖出去，这个可以接受；但是卖给了101个人，其中1个人拿不到货，平台违约，这个就不能接受。</p><p class=ql-align-justify>而该处就利用了这个特性，具体是这么做的：</p><p class=ql-align-justify>先扣库存，再提交订单。</p><p class=ql-align-justify>（1）扣库存失败，不提交订单了，直接返回失败，调用方重试（此处可能会多扣库存）</p><p class=ql-align-justify>（2）扣库存成功，提交订单失败，返回失败，调用方重试（此处可能会多扣库存）</p><p class=ql-align-justify>（3）扣库存成功，提交订单成功，返回成功。</p><p class=ql-align-justify><strong>反过来，你先提交订单，后扣库存，也是按照类似的这个思路。</strong></p><p class=ql-align-justify><strong>最终，只要保证1点：库存可以多扣，不能少扣！！！</strong></p><p class=ql-align-justify>但是，库存多扣了，这个数据不一致，怎么补偿呢？</p><p class=ql-align-justify>库存每扣1次，都会生成1条流水记录。这条记录的初始状态是“占用”，等订单支付成功之后，会把状态改成“释放”。</p><p class=ql-align-justify>对于那些过了很长时间，一直是占用，而不释放的库存。要么是因为前面多扣造成的，要么是因为用户下了单，但不支付。</p><p class=ql-align-justify>通过比对，库存系统的“占用又没有释放的库存流水“与订单系统的未支付的订单，我们就可以回收掉这些库存，同时把对应的订单取消掉。（就类似12306网站一样，过多长时间，你不支付，订单就取消了，库存释放）</p><p class=ql-align-justify><strong>方案6： 妥协方案 -- 重试 + 回滚 + 监控报警 + 人工修复</strong></p><p class=ql-align-justify>对于方案5，我们是基于订单的状态 + 库存流水的状态，做补偿（或者说叫对账）。</p><p class=ql-align-justify>如果业务很复杂，状态的维护也很复杂。方案5呢，就是1种更加妥协而简单的办法。</p><p class=ql-align-justify>提交订单不是失败了嘛！</p><p class=ql-align-justify>先重试！</p><p class=ql-align-justify>重试还不成功，回滚库存的扣减！</p><p class=ql-align-justify>回滚也失败，发报警出来，人工干预修复！</p><p class=ql-align-justify>总之，根据业务逻辑，通过重试3次，或者回滚的办法，尽最大限度，保证一致。实在不一致，就发报警，让人工干预。只要日志流水记录的完整，人工肯定可以修复！ （<strong>通常只要业务逻辑本身没问题，重试、回滚之后，还失败的概率会比较低，所以这种办法虽然丑陋，但蛮实用</strong>）</p><p class=ql-align-justify><strong>后话</strong></p><p class=ql-align-justify>其他的，诸如状态机驱动、1PC之类的办法，只是说法不一，个人认为本质上都是方案4/方案5的做法。</p><p class=ql-align-justify><strong>总结</strong></p><p class=ql-align-justify>在上文中，总结了实践中比较靠谱的6种方法：2种最终一致性的方案，2种妥协办法，2种基于状态 + 重试的方法（TCC，状态机 + 重试 + 幂等）。</p><p class=ql-align-justify>实现层面，妥协的办法肯定最容易，TCC最复杂。</p><p>读完本文，对小伙伴们的学习和工作有没有帮助呢？有帮助的话请关注小编，小编会为你每天分享有趣的学习干货哦~~</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'--','事务','实践'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>