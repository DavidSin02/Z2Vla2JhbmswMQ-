<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二) | 极客快訊</title><meta property="og:title" content="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/df3eeb6df38b48c981b302942a267991"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/00fd3a9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/00fd3a9.html><meta property="article:published_time" content="2020-10-29T20:56:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:56:28+08:00"><meta name=Keywords content><meta name=description content="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/00fd3a9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><h1><strong>一、linearPolar()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void linearPolar(InputArray src,  OutputArray dst, Point2f center,  double maxRadius,  int flags);</pre><p><strong>2、函数功能</strong></p><p>将一幅图像映射到极座标空间中。</p><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图像，即输入图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，与原图像有一样的尺寸与类型；</li></ul><ul><li>第三个参数，Point2f center，变换的中心座标；</li></ul><ul><li>第四个参数，double maxRadius，逆向变换中的最大变径；</li></ul><ul><li>第五个参数，int flags，插值方法的组合。</li></ul><p>Note:该函数不支持就地操作。</p><h1><strong>二、logPolar()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void logPolar(InputArray src,  OutputArray dst, Point2f center,  double M,  int flags);</pre><p><strong>2、函数功能</strong></p><p>将图像映射到半极座标空间；</p><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图像，即输入图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，与原图像具有相同的尺寸和类型；</li></ul><ul><li>第三个参数，Point2f center，转换的中心座标，其中输出的精度是最大的；</li></ul><ul><li>第四个参数，double M，图像幅度的比例参数，决定了用多大的边界圆的半径进行转换；</li></ul><ul><li>第五个参数，int flags，插值方法与映射模式的组合；</li></ul><p>Note:该函数不支持就地操作。</p><h1><strong>三、warpPolar()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void warpPolar(InputArray src,  OutputArray dst,  Size dsize, Point2f center,  double maxRadius,  int flags);</pre><p><strong>2、函数功能</strong></p><p class=ql-align-center>将一幅图像映射到极座标或者半极座标空间中；</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/df3eeb6df38b48c981b302942a267991><p class=pgc-img-caption>极座标的映射参考</p></div><p class=ql-align-center>具体应用的公式如下：</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e0c887082474263aea5abb13a772294><p class=pgc-img-caption>极座标映射</p></div><p class=ql-align-center>其中，</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46dd9dc112214655b8be564beafb8974><p class=pgc-img-caption>极座标映射</p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/943efd2f06e34671831e66239acb40d5><p class=pgc-img-caption>极座标映射</p></div><p><strong>极座标映射与半极座标映射的比较：</strong></p><p>warpPolar函数的映射模式可以是极座标映射，也可以是半极座标映射，通过flags参数来进行指定映射的模式！系统默认的模式是极座标映射模式。半极座标映射用来模仿人类的中心视觉，在视觉聚焦的地方可以看的很清晰，非聚焦的地方会比较模糊，通过弱化聚焦以外的区域，来简化图像，方便对图像进行处理。</p><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图像，即输入图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，与原图像具有相同的类型；</li></ul><ul><li>第三个参数，Size dsize，目标图像的尺寸，根据这个参数来设计目标图像的大小；</li></ul><ul><li>第四个参数，Point2f center，图像进行变换的中心座标；</li></ul><ul><li>第五个参数，double maxRadius，要进行变换的边界圆的半径，决定了图像逆向幅度的大小；</li></ul><ul><li>第六个参数，int flags，插值的方式与极座标变换的模式的组合；</li></ul><ul><li>极座标变换的模式有以下几种：</li></ul><p>(1)极座标变换(WARP_POLAR_LINEAR)</p><p>(2)半极座标变换(WARP_POLAR_LOG)</p><p>(3)对图像进行逆向映射(WARP_INVERSE_MAP)</p><p>Note:</p><p>(1)该函数不支持就地操作；</p><p>(2)为了计算角的大小和角度，内部采用了cartToPolar函数，测量角度在0到360之间，精度约为0.3度；</p><p>(3)在实现过程中，该函数使用了remap函数，因为当前的实现限制，图像的大小应小于32767x32767。</p><p><strong>综合实例</strong></p><p>对于linearPolar()函数与logPolar()以及warpPolar()函数的使用</p><pre>#include &lt;opencv2/imgproc.hpp&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;iostream&gt;using namespace cv;int main(int argc, char** argv){ // 半极座标转换图像 Mat log_polar_img,  // 极座标转换图像 lin_polar_img,  // 逆半极座标转换图像 recovered_log_polar, // 逆极座标转换图像 recovered_lin_polar_img;   // 创建窗体 namedWindow("Linear-Polar", WINDOW_AUTOSIZE); namedWindow("Log-Polar", WINDOW_AUTOSIZE); namedWindow("Recovered Linear-Polar", WINDOW_AUTOSIZE); namedWindow("Recovered Log-Polar", WINDOW_AUTOSIZE); // 移动窗口的显示位置 moveWindow("Linear-Polar", 20, 20); moveWindow("Log-Polar", 700, 20); moveWindow("Recovered Linear-Polar", 20, 350); moveWindow("Recovered Log-Polar", 700, 350); // INTER_LINEAR 线性插值 // WARP_FILL_OUTLIERS 填充所有目标图像像素。 // 如果其中一些对应于源图像中的异常值， // 则将其设置为零。 int flags = INTER_LINEAR +  WARP_FILL_OUTLIERS; // 加载图像 Mat src = imread("lena.png");  if (src.empty())  { printf("image error!"); return 0; }  // 原图像的中心座标 Point2f center((float)src.cols / 2,  (float)src.rows / 2); // 最大的半径 double maxRadius = 0.7*min(center.y, center.x); // direct transform // linear Polar warpPolar(src,  lin_polar_img,  Size(),  center,  maxRadius,  flags);  // semilog Polar warpPolar(src,  log_polar_img,  Size(),  center,  maxRadius,  flags + WARP_POLAR_LOG);   // inverse transform warpPolar(lin_polar_img,  recovered_lin_polar_img,  src.size(),  center,  maxRadius,  flags + WARP_INVERSE_MAP); // inverse transform warpPolar(log_polar_img,  recovered_log_polar,  src.size(),  center,  maxRadius,  flags + WARP_POLAR_LOG + WARP_INVERSE_MAP);  // 从极座标系到直角座标系 Mat dst; if (flags &amp; WARP_POLAR_LOG) dst = log_polar_img; else dst = lin_polar_img; //get a point from the polar image int rho = cvRound(dst.cols * 0.75); int phi = cvRound(dst.rows / 2.0); double angleRad, magnitude; double Kangle = dst.rows / CV_2PI; angleRad = phi / Kangle; if (flags &amp; WARP_POLAR_LOG) { double Klog = dst.cols / std::log(maxRadius); magnitude = std::exp(rho / Klog); } else { double Klin = dst.cols / maxRadius; magnitude = rho / Klin; } // 极座标的点转换为直角座标的点 int x = cvRound(center.x + magnitude * cos(angleRad)); int y = cvRound(center.y + magnitude * sin(angleRad)); drawMarker(src, Point(x, y), Scalar(0, 255, 0)); drawMarker(dst, Point(rho, phi), Scalar(0, 255, 0)); imshow("Src image", src); imshow("Log-Polar", log_polar_img); imshow("Linear-Polar", lin_polar_img); imshow("Recovered Linear-Polar", recovered_lin_polar_img); imshow("Recovered Log-Polar", recovered_log_polar); waitKey(0); return 0;}</pre><p class=ql-align-center><br></p><p class=ql-align-center><strong>实验结果：</strong></p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a4103f97671442cf826e84eeb4c39ec8><p class=pgc-img-caption>原图</p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3040f61c7bb4ee9b4854b9ceeecb4f3><p class=pgc-img-caption>极座标变换(左)与半极座标变换(右)</p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9374ecb95e7a4a82bb843cd8de28a992><p class=pgc-img-caption>逆极座标变换(左)与逆半极座标变换(右)</p></div><p class=ql-align-center><br></p><h1><strong>四、resize()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void resize(InputArray src,  OutputArray dst, Size dsize,  double fx = 0,  double fy = 0, int interpolation =  INTER_LINEAR);</pre><p><strong>2、函数功能</strong></p><p>对图像的尺寸进行调整，使其缩小或放大为指定的大小；</p><p>Note:</p><p>(1)如果没有考虑目标图像(dst)初始化的大小和类型，则目标图像的大小和类型由原图像(src)，dsize,fx,fy等参数决定，例如：</p><pre>// 指定fx,fy的值，//由函数自动计算目标图像的大小resize(src, dst,  Size(), 0.5, 0.5,  interpolation);</pre><p>(2)预先创建dst图像的大小与类型，例如：</p><pre>// 创建一个800x600的8位单通道的图像Mat dst(800, 600, CV_8UC1); resize(src, dst, dst.size(), 0, 0, interpolation);</pre><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图，即输入图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，其类型与原图像一致，尺寸可以进行自定义设置，或者通过参数src.size(),fx,fy等参数自动计算出来；</li></ul><ul><li>第三个参数，Size dsize，目标图像的尺寸；</li></ul><ul><li class=ql-align-center>如果dsize等于0，则dsize用以下的公式计算：</li></ul><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/06d915d2f90943968ebf96eb5fa50fd6><p class=pgc-img-caption>dsize</p></div><p>需要满足dsize或者fx,fy都不为0；</p><ul><li>第四个参数，double fx = 0,</li></ul><p class=ql-align-center>fx，水平方向的尺寸因子，如果fx=0，则通过下面的公式计算fx：</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ec0710c707841d795bd90bf422846df><p class=pgc-img-caption>fx</p></div><ul><li>第五个参数，double fy = 0，</li></ul><p class=ql-align-center>fy,垂直方向的尺寸因子，如果fy=0，则通过下面的公式计算fy:</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed3a9d35329745e7ba8a5ab8d5c095a5><p class=pgc-img-caption>fy</p></div><ul><li>第六个参数，int interpolation =INTER_LINEAR，默认的插值方式位线性插值；</li></ul><p class=ql-align-center><br></p><p class=ql-align-center>常见的插值方式：</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03037e24c7a04db9be5187d3c52a0bde><p class=pgc-img-caption>常见的插值方式</p></div><p class=ql-align-center><br></p><h1><strong>五、remap()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void remap(InputArray src,  OutputArray dst, InputArray map1,  InputArray map2, int interpolation,  int borderMode = BORDER_CONSTANT, const Scalar&amp; borderValue = Scalar());</pre><p><strong>2、函数功能</strong></p><p>对图像进行几何变换；</p><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图像，即输入图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，图像的尺寸的大小与map1相同，图像的类型与原图像一致；</li></ul><ul><li>第三个参数，InputArray map1， (x，y)点或仅x值的第一个映射，其类型为CV_16SC2、CV_32FC1或CV_32FC2；有关将浮点表示形式转换为固定点以提高速度的详细信息，可以看我上一节所讲的convertMaps函数；</li></ul><ul><li>第四个参数，InputArray map2，y值的第二个映射，其类型分别为CV_16UC1、CV_32FC1或None(如果map1为(x，y)点，则为空映射)；</li></ul><ul><li>第五个参数，int interpolation，插值的方法，这个函数不支持INTER_AREA插值；</li></ul><ul><li>第六个参数，int borderMode = BORDER_CONSTANT，边界模式；当边界模式为BORDER_TRANSPARENT时，源图像中的“异常值”的像素在目标图像中不会被函数修改；</li></ul><ul><li>第七个参数，const Scalar& borderValue = Scalar()， 在常量边界情况下使用的边值；默认情况下，它是0。</li></ul><h1><strong>六、warpAffine()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void warpAffine(InputArray src,  OutputArray dst, InputArray M,  Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar&amp; borderValue = Scalar());</pre><p><strong>2、函数功能</strong></p><p>用指定的卷积核对图像进行仿射变换；</p><p class=ql-align-center>当flag为WARP_INVERSE_MAP时，使用的公式如下：</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f6d621646b640199bd6d3977ec48ce5><p class=pgc-img-caption>指定的卷积矩阵</p></div><p>否则，使用invertAffineTransform函数先进性逆仿射变换，然后用上面的公式代替M；并且该函数不支持就地操作！</p><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图像，即输入图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，与原图像具有同样的尺寸与类型；</li></ul><ul><li>第三个参数，InputArray M，2 x 3的变换矩阵；</li></ul><ul><li>第四个参数，Size dsize，目标的图像的尺寸大小，根据这个参数来指定目标图像的大小；</li></ul><ul><li>第五个参数，int flags = INTER_LINEAR，插值的方法，以及可选择的WARP_INVERSE_MAP（使用这个方式，则M是逆仿射变换）；</li></ul><ul><li>第六个参数，int borderMode = BORDER_CONSTANT，边界模式，当边界模式为BORDER_TRANSPARENT时，源图像中的“异常值”的像素在目标图像中不会被函数修改；</li></ul><ul><li>第七个参数，const Scalar& borderValue = Scalar()， 在常量边界情况下使用的边值；默认情况下，它是0。</li></ul><h1><strong>七、warpPerspective()函数</strong></h1><p><strong>1、函数原型</strong></p><pre>void warpPerspective(InputArray src,  OutputArray dst, InputArray M,  Size dsize, int flags = INTER_LINEAR, int borderMode = BORDER_CONSTANT, const Scalar&amp; borderValue = Scalar());</pre><p><strong>2、函数功能</strong></p><p>用指定的卷积核对图像进行透视变换；</p><p class=ql-align-center>当flags设置为WARP_INVERSE_MAP时，使用以下的卷积对图像进行透视变换，</p><div class=pgc-img><img alt="【图像处理】OpenCV系列十八 --- 几何图像变换函数详解(二)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/224a84bd880242d5a0a3c7749043115b><p class=pgc-img-caption>透视变换</p></div><p>否则，先使用逆变换进行转置，然后用上面的公式代替M，并且此函数不支持就地操作；</p><p><strong>3、参数详解</strong></p><ul><li>第一个参数，InputArray src，原图，即目标图像；</li></ul><ul><li>第二个参数，OutputArray dst，目标图像，与原图具有同样的尺寸和类型；</li></ul><ul><li>第三个参数，InputArray M，3 x 3的转换矩阵；</li></ul><ul><li>第四个参数，Size dsize，目标图像的大小，根据这个参数来设计目标图像的大小；</li></ul><ul><li>第五个参数，int flags = INTER_LINEAR，将常用的插值方法(INTER_LINEAR、 INTER_NEAREST)与可选标志（WARP_INVERSE_MAP）进行组合，如果与可选标志结合的话，将M设置为逆变换(dst --> src);</li></ul><ul><li>第六个参数，int borderMode = BORDER_CONSTANT，边界模式(BORDER_CONSTANT、BORDER_REPLICATE)；</li></ul><ul><li>第七个参数，const Scalar& borderValue = Scalar()， 在常量边界情况下使用的边值；默认情况下，它是0。</li></ul><p>我是奕双，现在已经毕业将近两年了，从大学开始学编程，期间学习了C需要编程，C++需要编程，Win32编程，MFC编程，毕业之后进入一家图像处理相关领域的公司，掌握了用OpenCV对图像进行处理，如果大家对相关领域感兴趣的话，可以关注我，我这边会为大家进行解答哦！如果大家需要相关学习资料的话，可以私聊我哦！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'图像','处理','OpenCV'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>