<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linuxå†…æ ¸å­¦ä¹ 014â€”â€”è¿›ç¨‹è°ƒåº¦(ä¸‰) | æå®¢å¿«è¨Š</title><meta property="og:title" content="Linuxå†…æ ¸å­¦ä¹ 014â€”â€”è¿›ç¨‹è°ƒåº¦(ä¸‰) - æå®¢å¿«è¨Š"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/955a771b-0d01-4f97-8b1f-8575d578bd06"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><meta property="article:published_time" content="2020-11-14T20:53:31+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:31+08:00"><meta name=Keywords content><meta name=description content="Linuxå†…æ ¸å­¦ä¹ 014â€”â€”è¿›ç¨‹è°ƒåº¦(ä¸‰)"><meta name=author content="æå®¢å¿«è¨Š"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/0a7b85a7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>ğŸ¤“ æå®¢å¿«è®¯ Geek Bank</a></h1><p class=description>ä¸ºä½ å¸¦æ¥æœ€å…¨çš„ç§‘æŠ€çŸ¥è¯† ğŸ§¡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>çŒœä½ å–œæ­¡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=ç§‘æŠ€>ç§‘æŠ€</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=éŠæˆ²>éŠæˆ²</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=ç§‘å­¸>ç§‘å­¸</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linuxå†…æ ¸å­¦ä¹ 014â€”â€”è¿›ç¨‹è°ƒåº¦(ä¸‰)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>ç§‘å­¦</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Linuxå†…æ ¸å­¦ä¹ 014â€”â€”è¿›ç¨‹è°ƒåº¦(ä¸‰) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/955a771b-0d01-4f97-8b1f-8575d578bd06><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>Linuxè°ƒåº¦ç®—æ³•</h1><p>åœ¨Linuxä¸­ï¼Œè°ƒåº¦å™¨æ˜¯ä»¥æ¨¡å—æ–¹å¼æä¾›çš„ï¼Œè¿™æ ·å¯ä»¥å…è®¸ä¸åŒç±»å‹çš„è¿›ç¨‹æœ‰é’ˆå¯¹æ€§åœ°é€‰æ‹©è°ƒåº¦ç®—æ³•ã€‚è¿™ç§æ¨¡å—åŒ–ç»“æ„ç§°ä¸ºè°ƒåº¦å™¨ç±»ï¼Œå…¶å…è®¸å¤šç§ä¸åŒçš„å¯åŠ¨æ€æ·»åŠ çš„è°ƒåº¦ç®—æ³•å¹¶å­˜ï¼Œè°ƒåº¦å±äºè‡ªå·±èŒƒç•´çš„è¿›ç¨‹ã€‚æ¯ä¸ªè°ƒåº¦å™¨æœ‰ä¸€ä¸ªä¼˜å…ˆçº§ï¼ŒåŸºç¡€è°ƒåº¦å™¨ä¼šä¾ä¼˜å…ˆçº§éå†è°ƒåº¦ç±»ï¼Œæ‹¥æœ‰æœ€é«˜ä¼˜å…ˆçº§çš„è°ƒåº¦å™¨ç±»é€‰æ‹©å°†è¦æ‰§è¡Œçš„ç¨‹åºã€‚</p><p>CFSå°±æ˜¯ä¸€ä¸ªè°ƒåº¦å™¨ç±»ï¼Œåœ¨Linuxä¸­ç§°ä¸ºSCHED_NORMALï¼Œå…¶å…·ä½“å®šä¹‰åœ¨Linux2.6.34/kernel/sched_fair.cä¸­ã€‚</p><p>CFSçš„ç†å¿µå¾ˆç®€å•ï¼šè¿›ç¨‹è°ƒåº¦çš„æ•ˆæœåº”å¦‚åŒç³»ç»Ÿå…·å¤‡ä¸€ä¸ªç†æƒ³ä¸­çš„å®Œç¾å¤šä»»åŠ¡å¤„ç†å™¨ã€‚å³æ¯ä¸ªè¿›ç¨‹å¯è·å¾—1/nçš„å¤„ç†å™¨æ—¶é—´(nä¸ºå¯è¿è¡Œçš„è¿›ç¨‹æ•°é‡)ã€‚ä½†æ˜¯ï¼Œç”±äºè°ƒåº¦æ—¶è¿›ç¨‹æŠ¢å çš„å¼€é”€ï¼Œæ¯”å¦‚ï¼šè¿›ç¨‹æ¢å…¥ã€è¿›ç¨‹æ¢å‡ºã€ç¼“å­˜å½±å“ç­‰ï¼Œç†æƒ³æ¨¡å‹æ˜¯æ— æ³•å®ç°çš„ã€‚å› æ­¤ï¼ŒCFSå……åˆ†è€ƒè™‘äº†é¢å¤–å¼€é”€ï¼Œç¡®ä¿äº†ç³»ç»Ÿæ€§èƒ½ä¸å—å½±å“ã€‚CFSçš„åšæ³•æ˜¯ï¼šå…è®¸æ¯ä¸ªè¿›ç¨‹è¿è¡Œä¸€æ®µæ—¶é—´ï¼Œå¾ªç¯è½®è½¬ï¼Œé€‰æ‹©è¿è¡Œæœ€å°‘çš„è¿›ç¨‹ä½œä¸ºä¸‹ä¸€ä¸ªè¿è¡Œè¿›ç¨‹ï¼Œè€Œä¸æ˜¯åˆ†é…æ¯ä¸ªè¿›ç¨‹ä»¥æ—¶é—´ç‰‡ã€‚niceå€¼åœ¨CFSä¸­è¢«ä½œä¸ºè¿›ç¨‹è·å¾—å¤„ç†å™¨è¿è¡Œæ¯”å¾—æƒé‡(é«˜niceå€¼ï¼Œä½ä¼˜å…ˆçº§ï¼Œä½å¤„ç†å™¨ä½¿ç”¨æƒé‡)ã€‚å½“å¯è¿è¡Œè¿›ç¨‹æ•°é‡è¿‡å¤šæ—¶ï¼Œå®ƒä»¬å„è‡ªæ‰€è·å¾—çš„å¤„ç†å™¨ä½¿ç”¨æ¯”å’Œæ—¶é—´ç‰‡éƒ½è¶‹äº0ï¼ŒCFSä¸ºæ­¤è®¾ç«‹äº†æœ€å°ç²’åº¦ï¼Œé»˜è®¤å€¼ä¸º1msã€‚</p><p>æ€»ç»“ï¼šä»»ä½•è¿›ç¨‹æ‰€è·å¾—çš„å¤„ç†å™¨æ—¶é—´æ˜¯ç”±å®ƒè‡ªå·±å’Œå…¶ä»–æ‰€æœ‰å¯è¿è¡Œè¿›ç¨‹niceå€¼çš„ç›¸å¯¹æ¯”ä¾‹å†³å®šçš„ã€‚</p><h1 class=pgc-h-arrow-right>Linuxè°ƒåº¦çš„å®ç°</h1><p>CFSå…·ä½“å®ç°ä½äºkernel/schde_fair.cï¼Œå…¶ä¸­éœ€è¦é‡ç‚¹å…³æ³¨çš„æ˜¯å››ä¸ªç»„æˆéƒ¨åˆ†ï¼š</p><ol start=1><li>æ—¶é—´è®°è´¦</li><li>è¿›ç¨‹é€‰æ‹©</li><li>è°ƒåº¦å™¨å…¥å£</li><li>ç¡çœ å’Œå”¤é†’</li></ol><h1 class=pgc-h-arrow-right>æ—¶é—´è®°è´¦</h1><p>æ˜¾ç„¶ï¼Œæ‰€æœ‰çš„è°ƒåº¦å™¨éƒ½å¿…é¡»è®°å½•è¿›ç¨‹çš„è¿è¡Œæ—¶é—´ã€‚CFSä¸­ä½¿ç”¨ä¸€ä¸ªç»“æ„ä½“sched_entityæ¥è®°å½•è¿›ç¨‹è¿è¡Œä¿¡æ¯ï¼Œå…¶å®šä¹‰åœ¨Linux2.6.34/include/linux/sched.h#L1090ï¼š</p><pre><code>/* * CFS stats for a schedulable entity (task, task-group etc) * * Current field usage histogram: * *     4 se-&gt;block_start *     4 se-&gt;run_node *     4 se-&gt;sleep_start *     6 se-&gt;load.weight */struct sched_entity {    struct load_weight  load;       /* for load-balancing */    struct rb_node      run_node;    struct list_head    group_node;    unsigned int        on_rq;    u64         exec_start;    u64         sum_exec_runtime;    u64         vruntime;    u64         prev_sum_exec_runtime;    u64         last_wakeup;    u64         avg_overlap;    u64         nr_migrations;    u64         start_runtime;    u64         avg_wakeup;#ifdef CONFIG_SCHEDSTATS    u64         wait_start;    u64         wait_max;    u64         wait_count;    u64         wait_sum;    u64         iowait_count;    u64         iowait_sum;    u64         sleep_start;    u64         sleep_max;    s64         sum_sleep_runtime;    u64         block_start;    u64         block_max;    u64         exec_max;    u64         slice_max;    u64         nr_migrations_cold;    u64         nr_failed_migrations_affine;    u64         nr_failed_migrations_running;    u64         nr_failed_migrations_hot;    u64         nr_forced_migrations;    u64         nr_wakeups;    u64         nr_wakeups_sync;    u64         nr_wakeups_migrate;    u64         nr_wakeups_local;    u64         nr_wakeups_remote;    u64         nr_wakeups_affine;    u64         nr_wakeups_affine_attempts;    u64         nr_wakeups_passive;    u64         nr_wakeups_idle;#endif#ifdef CONFIG_FAIR_GROUP_SCHED    struct sched_entity *parent;    /* rq on which this entity is (to be) queued: */    struct cfs_rq       *cfs_rq;    /* rq "owned" by this entity/group: */    struct cfs_rq       *my_q;#endif};</code></pre><p>ä¸‹åŠéƒ¨åˆ†çš„æˆå‘˜å˜é‡éœ€è¦è®¾ç½®äº†CONFIG_SCHEDSTATSå’ŒCONFIG_FAIR_GROUP_SCHEDæ—¶æ‰ä¼šå¯ç”¨ï¼Œé‡ç‚¹å…³æ³¨å‰åŠéƒ¨åˆ†å³å¯ã€‚</p><p>è°ƒåº¦å™¨å®ä½“ç»“æ„æ˜¯ä½œä¸ºä¸€ä¸ªåä¸ºseçš„æˆå‘˜å˜é‡ï¼ŒåµŒå…¥åœ¨è¿›ç¨‹æè¿°ç¬¦struct task_structä¸­çš„ã€‚</p><div class=pgc-img><img alt=Linuxå†…æ ¸å­¦ä¹ 014â€”â€”è¿›ç¨‹è°ƒåº¦(ä¸‰) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ddbf236434348f2bad9b0d6e701eb41><p class=pgc-img-caption></p></div><p>2019-02-10_203619.png</p><p><strong>è™šæ‹Ÿå®æ—¶</strong></p><p>sched_entityä¸­çš„u64 vruntimeæˆå‘˜è®°å½•è¿›ç¨‹çš„è™šæ‹Ÿè¿è¡Œæ—¶é—´ï¼Œå•ä½ä¸ºnsã€‚CFSä½¿ç”¨vruntimeå˜é‡æ¥è®°å½•ä¸€ä¸ªç¨‹åºè¿è¡Œäº†å¤šä¹…ä»¥åŠè¿˜èƒ½è¿è¡Œå¤šä¹…ï¼Œå®šä¹‰åœ¨Linux2.6.34/kernel/sched_fair.c#L518çš„å‡½æ•°update_currå®ç°äº†è¯¥è®°è´¦åŠŸèƒ½ï¼š</p><pre><code>static void update_curr(struct cfs_rq *cfs_rq){    struct sched_entity *curr = cfs_rq-&gt;curr;    u64 now = rq_of(cfs_rq)-&gt;clock;    unsigned long delta_exec;    if (unlikely(!curr))        return;    /*     * Get the amount of time the current task was running     * since the last time we changed load (this cannot     * overflow on 32 bits):     */    delta_exec = (unsigned long)(now - curr-&gt;exec_start);    if (!delta_exec)        return;    __update_curr(cfs_rq, curr, delta_exec);    curr-&gt;exec_start = now;    if (entity_is_task(curr)) {        struct task_struct *curtask = task_of(curr);        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);        cpuacct_charge(curtask, delta_exec);        account_group_exec_runtime(curtask, delta_exec);    }}</code></pre><p>update_curr()è®¡ç®—äº†å½“å‰è¿›ç¨‹çš„æ‰§è¡Œæ—¶é—´ï¼Œå¹¶å°†å…¶å­˜æ”¾åœ¨å˜é‡delta_execæ€»ï¼Œç„¶åå°†ä¸è¿è¡Œæ—¶é—´ä¼ é€’ç»™__update_curr()ï¼Œç”±å…¶æ ¹æ®å½“å‰å¯è¿è¡Œè¿›ç¨‹æ€»æ•°å¯¹è¿è¡Œæ—¶é—´è¿›è¡ŒåŠ æƒè®¡ç®—ï¼Œæœ€ç»ˆå°†æƒé‡å€¼ä¸å½“å‰è¿›ç¨‹çš„vruntimeç›¸åŠ ã€‚</p><p>æ³¨ï¼š__update_curr()å‡½æ•°å®šä¹‰åœ¨update_curr()å‡½æ•°ä¸Šæ–¹</p><pre><code>/* * Update the current task's runtime statistics. Skip current tasks that * are not in our scheduling class. */static inline void__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,          unsigned long delta_exec){    unsigned long delta_exec_weighted;    schedstat_set(curr-&gt;exec_max, max((u64)delta_exec, curr-&gt;exec_max));    curr-&gt;sum_exec_runtime += delta_exec;    schedstat_add(cfs_rq, exec_clock, delta_exec);    delta_exec_weighted = calc_delta_fair(delta_exec, curr);    curr-&gt;vruntime += delta_exec_weighted;    update_min_vruntime(cfs_rq);}</code></pre><p>update_curr()æ˜¯ç”±ç³»ç»Ÿå®šæ—¶å™¨å‘¨æœŸæ€§è°ƒç”¨çš„ï¼Œå› æ­¤vruntimeå¯ä»¥å‡†ç¡®åœ°æµ‹é‡ç»™å®šè¿›ç¨‹çš„è¿è¡Œæ—¶é—´ï¼Œä¸”å¯ä»¥çŸ¥é“ä¸‹ä¸€é¢è¿è¡Œçš„è¿›ç¨‹ã€‚</p><h1 class=pgc-h-arrow-right>è¿›ç¨‹é€‰æ‹©</h1><p>CFSéœ€è¦é€‰æ‹©ä¸‹ä¸€ä¸ªè¿›ç¨‹è¿è¡Œæ—¶ï¼Œå®ƒä¼šæŒ‘é€‰ä¸€ä¸ªå…·æœ‰æœ€å°vruntimeçš„è¿›ç¨‹ã€‚CFSä½¿ç”¨äº†çº¢é»‘æ ‘æ¥ç»„ç»‡å¯è¿è¡Œè¿›ç¨‹é˜Ÿåˆ—ï¼Œå…³äºçº¢é»‘æ ‘å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« ã€‚çº¢é»‘æ ‘æ˜¯ä¸€ä¸ªè‡ªå¹³è¡¡äºŒå‰æœç´¢æ ‘ï¼Œä»¥æ ‘èŠ‚ç‚¹å½¢å¼å­˜å‚¨æ•°æ®ï¼Œè¿™äº›æ•°æ®å¯¹åº”ä¸€ä¸ªé”®å€¼ï¼Œå¯é€šè¿‡é”®å€¼å¿«é€Ÿæ£€ç´¢èŠ‚ç‚¹ä¸Šçš„æ•°æ®ã€‚</p><p>å‡è®¾å­˜åœ¨ä¸€ä¸ªçº¢é»‘æ ‘å­˜å‚¨äº†ç³»ç»Ÿä¸­æ‰€æœ‰çš„å¯è¿è¡Œè¿›ç¨‹ï¼Œå…¶ä¸­çš„èŠ‚ç‚¹é”®å€¼ä¸ºå¯è¿è¡Œè¿›ç¨‹çš„è™šæ‹Ÿè¿è¡Œæ—¶é—´ã€‚CFSé€‰æ‹©vruntimeæœ€å°çš„ï¼Œå³æ ‘ä¸­æœ€å·¦ä¾§çš„å¶å­èŠ‚ç‚¹ï¼Œå¯ä»¥ä»æ ‘çš„æ ¹èŠ‚ç‚¹ä¸€ç›´æ²¿å·¦ä¾§å­èŠ‚ç‚¹å‘ä¸‹æ‰¾ç›´åˆ°å¶å­èŠ‚ç‚¹ã€‚å®ç°è¯¥è¿‡ç¨‹çš„å‡½æ•°ä¸º__pick_next_entity()ï¼Œå…¶å®šä¹‰åœ¨Linux2.6.34/source/kernel/sched_fair.c#L377ã€‚</p><pre><code>static struct sched_entity *__pick_next_entity(struct cfs_rq *cfs_rq){    struct rb_node *left = cfs_rq-&gt;rb_leftmost;    if (!left)        return NULL;    return rb_entry(left, struct sched_entity, run_node);}</code></pre><p>æ³¨ï¼šå…¶å®__pick_next_entity()å‡½æ•°æœ¬èº«å¹¶ä¸ä¼šéå†æ ‘æ‰¾åˆ°æœ€å·¦å­èŠ‚ç‚¹ï¼Œå› ä¸ºè¯¥å€¼å·²ç»ç¼“å­˜åœ¨rb_leftmostä¸­äº†ã€‚</p><p><strong>åŠ å…¥è¿›ç¨‹</strong></p><p>CFSå…ˆrbtree(çº¢é»‘æ ‘)ä¸­åŠ å…¥å¯æ‰§è¡Œè¿›ç¨‹å‘ç”Ÿåœ¨è¿›ç¨‹å˜ä¸ºå¯æ‰§è¡ŒçŠ¶æ€æˆ–è€…æ˜¯é€šè¿‡fork()è°ƒç”¨ç¬¬ä¸€æ¬¡åˆ›å»ºè¿›ç¨‹æ˜¯ï¼Œenqueue_entity()å‡½æ•°å®ç°äº†è¯¥è¿‡ç¨‹ï¼š</p><pre><code>static voidenqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags){    /*     * Update the normalized vruntime before updating min_vruntime     * through callig update_curr().     */    if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATE))        se-&gt;vruntime += cfs_rq-&gt;min_vruntime;    /*     * Update run-time statistics of the 'current'.     */    update_curr(cfs_rq);    account_entity_enqueue(cfs_rq, se);    if (flags &amp; ENQUEUE_WAKEUP) {        place_entity(cfs_rq, se, 0);        enqueue_sleeper(cfs_rq, se);    }    update_stats_enqueue(cfs_rq, se);    check_spread(cfs_rq, se);    if (se != cfs_rq-&gt;curr)        __enqueue_entity(cfs_rq, se);}</code></pre><p>è¯¥å‡½æ•°æ›´æ–°è¿è¡Œæ—¶é—´å’Œå…¶ä»–ä¸€äº›ç»Ÿè®¡æ•°æ®ï¼Œç„¶åè°ƒç”¨__enqueue_entity()è¿›è¡Œæ’å…¥æ“ä½œï¼š</p><pre><code>/* * Enqueue an entity into the rb-tree: */static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){    struct rb_node **link = &amp;cfs_rq-&gt;tasks_timeline.rb_node;    struct rb_node *parent = NULL;    struct sched_entity *entry;    s64 key = entity_key(cfs_rq, se);    int leftmost = 1;    /*     * Find the right place in the rbtree:     */    while (*link) {        parent = *link;        entry = rb_entry(parent, struct sched_entity, run_node);        /*         * We dont care about collisions. Nodes with         * the same key stay together.         */        if (key &lt; entity_key(cfs_rq, entry)) {            link = &amp;parent-&gt;rb_left;        } else {            link = &amp;parent-&gt;rb_right;            leftmost = 0;        }    }    /*     * Maintain a cache of leftmost tree entries (it is frequently     * used):     */    if (leftmost)        cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_node;    rb_link_node(&amp;se-&gt;run_node, parent, link);    rb_insert_color(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);}</code></pre><p><strong>åˆ é™¤è¿›ç¨‹</strong></p><p>åˆ é™¤è¿›ç¨‹å‘ç”Ÿåœ¨è¿›ç¨‹å µå¡æˆ–è€…ç»ˆæ­¢æ—¶ï¼š</p><pre><code>static voiddequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep){    /*     * Update run-time statistics of the 'current'.     */    update_curr(cfs_rq);    update_stats_dequeue(cfs_rq, se);    if (sleep) {#ifdef CONFIG_SCHEDSTATS        if (entity_is_task(se)) {            struct task_struct *tsk = task_of(se);            if (tsk-&gt;state &amp; TASK_INTERRUPTIBLE)                se-&gt;sleep_start = rq_of(cfs_rq)-&gt;clock;            if (tsk-&gt;state &amp; TASK_UNINTERRUPTIBLE)                se-&gt;block_start = rq_of(cfs_rq)-&gt;clock;        }#endif    }    clear_buddies(cfs_rq, se);    if (se != cfs_rq-&gt;curr)        __dequeue_entity(cfs_rq, se);    account_entity_dequeue(cfs_rq, se);    update_min_vruntime(cfs_rq);    /*     * Normalize the entity after updating the min_vruntime because the     * update can refer to the -&gt;curr item and we need to reflect this     * movement in our normalized position.     */    if (!sleep)        se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;}</code></pre><p>å®é™…åˆ é™¤å·¥ä½œç”±__dequeue_entity()å®Œæˆã€‚</p><pre><code>static void __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){    if (cfs_rq-&gt;rb_leftmost == &amp;se-&gt;run_node) {        struct rb_node *next_node;        next_node = rb_next(&amp;se-&gt;run_node);        cfs_rq-&gt;rb_leftmost = next_node;    }    rb_erase(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);}</code></pre><h1 class=pgc-h-arrow-right>è°ƒåº¦å™¨å…¥å£</h1><p>è°ƒåº¦å™¨å…¥å£æ—¶å‡½æ•°schedule()ï¼Œè¯¥å‡½æ•°å®šä¹‰åœ¨Linux2.6.34/kernel/sched.c#L3698ä¸­ã€‚schedule()æ—¶å†…æ¶åŒ–å…¶ä»–éƒ¨åˆ†è°ƒç”¨è¿›ç¨‹è°ƒåº¦å™¨çš„å…¥å£ï¼Œå…¶é€šå¸¸å’Œä¸€ä¸ªå…·ä½“çš„è°ƒåº¦ç±»ç›¸å…³è”ã€‚</p><pre><code>/* * schedule() is the main scheduler function. */asmlinkage void __sched schedule(void){    struct task_struct *prev, *next;    unsigned long *switch_count;    struct rq *rq;    int cpu;need_resched:    preempt_disable();    cpu = smp_processor_id();    rq = cpu_rq(cpu);    rcu_sched_qs(cpu);    prev = rq-&gt;curr;    switch_count = &amp;prev-&gt;nivcsw;    release_kernel_lock(prev);need_resched_nonpreemptible:    schedule_debug(prev);    if (sched_feat(HRTICK))        hrtick_clear(rq);    raw_spin_lock_irq(&amp;rq-&gt;lock);    update_rq_clock(rq);    clear_tsk_need_resched(prev);    if (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) {        if (unlikely(signal_pending_state(prev-&gt;state, prev)))            prev-&gt;state = TASK_RUNNING;        else            deactivate_task(rq, prev, 1);        switch_count = &amp;prev-&gt;nvcsw;    }    pre_schedule(rq, prev);    if (unlikely(!rq-&gt;nr_running))        idle_balance(cpu, rq);    put_prev_task(rq, prev);    next = pick_next_task(rq);    if (likely(prev != next)) {        sched_info_switch(prev, next);        perf_event_task_sched_out(prev, next);        rq-&gt;nr_switches++;        rq-&gt;curr = next;        ++*switch_count;        context_switch(rq, prev, next); /* unlocks the rq */        /*         * the context switch might have flipped the stack from under         * us, hence refresh the local variables.         */        cpu = smp_processor_id();        rq = cpu_rq(cpu);    } else        raw_spin_unlock_irq(&amp;rq-&gt;lock);    post_schedule(rq);    if (unlikely(reacquire_kernel_lock(current) &lt; 0)) {        prev = rq-&gt;curr;        switch_count = &amp;prev-&gt;nivcsw;        goto need_resched_nonpreemptible;    }    preempt_enable_no_resched();    if (need_resched())        goto need_resched;}</code></pre><h1 class=pgc-h-arrow-right>ç¡çœ å’Œå”¤é†’</h1><p>ç¡çœ (è¢«é˜»å¡)çš„è¿›ç¨‹æ— æ³•æ‰§è¡Œï¼ŒåŸå› æ˜¯å…¶åœ¨ç­‰å¾…ä¸€äº›æ—¶é—´å‘ç”Ÿï¼Œæ¯”å¦‚ï¼šæ–‡ä»¶I/Oï¼Œç½‘ç»œè¯·æ±‚ç­‰ã€‚ä¼‘çœ ä¸­çš„è¿›ç¨‹æœ‰ä¸¤ä¸ªç›¸å…³çš„è¿›ç¨‹çŠ¶æ€ï¼šTASK_INTERRUPTIBLEå’ŒTASK_UNINTERRUPTIBLEã€‚åŒºåˆ«åœ¨äºå¤„äºTASK_UNINTERRUPTIBLEçš„è¿›ç¨‹ä¼šå¿½ç•¥ä¿¡å·ï¼Œè€Œå¤„äºTASK_INTERRUPTIBLEçš„è¿›ç¨‹ä¼šè¢«ä¿¡å·å”¤é†’å¹¶å“åº”ä¿¡å·ã€‚æ­¤å¤–ï¼Œä¸¤ç§çŠ¶æ€çš„è¿›ç¨‹éƒ½ä½äºä¸€ä¸ªç­‰å¾…é˜Ÿåˆ—ä¸Šç­‰å¾…äº‹ä»¶å‘ç”Ÿï¼Œä¸èƒ½è¿è¡Œã€‚</p><p><strong>å”¤é†’</strong></p><p>å”¤é†’é€šè¿‡wake_up()å‡½æ•°å®Œæˆï¼Œå®ƒä¼šå”¤é†’æŒ‡å®šçš„ç­‰å¾…é˜Ÿåˆ—ä¸Šçš„æ‰€æœ‰è¿›ç¨‹ã€‚</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','æ ¸å­¦ä¹ ','014'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=æœç´¢>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>ğŸ”</button></form></section><section class=widget><h3 class=widget-title>æœ€æ–°æ–‡ç«  âš¡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>å…¶ä»–</h3><ul class=widget-list><li><a href=TOS.html>ä½¿ç”¨æ¢æ¬¾</a></li><li><a href=CommentPolicy.html>ç•™è¨€æ”¿ç­–</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>è¯çµ¡æˆ‘å€‘</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>æå®¢å¿«è¨Š</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>