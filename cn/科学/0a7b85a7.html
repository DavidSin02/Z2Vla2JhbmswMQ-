<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux内核学习014——进程调度(三) | 极客快訊</title><meta property="og:title" content="Linux内核学习014——进程调度(三) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/955a771b-0d01-4f97-8b1f-8575d578bd06"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/0a7b85a7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/0a7b85a7.html><meta property="article:published_time" content="2020-11-14T20:53:31+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:31+08:00"><meta name=Keywords content><meta name=description content="Linux内核学习014——进程调度(三)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/0a7b85a7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux内核学习014——进程调度(三)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Linux内核学习014——进程调度(三) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/955a771b-0d01-4f97-8b1f-8575d578bd06><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>Linux调度算法</h1><p>在Linux中，调度器是以模块方式提供的，这样可以允许不同类型的进程有针对性地选择调度算法。这种模块化结构称为调度器类，其允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器有一个优先级，基础调度器会依优先级遍历调度类，拥有最高优先级的调度器类选择将要执行的程序。</p><p>CFS就是一个调度器类，在Linux中称为SCHED_NORMAL，其具体定义在Linux2.6.34/kernel/sched_fair.c中。</p><p>CFS的理念很简单：进程调度的效果应如同系统具备一个理想中的完美多任务处理器。即每个进程可获得1/n的处理器时间(n为可运行的进程数量)。但是，由于调度时进程抢占的开销，比如：进程换入、进程换出、缓存影响等，理想模型是无法实现的。因此，CFS充分考虑了额外开销，确保了系统性能不受影响。CFS的做法是：允许每个进程运行一段时间，循环轮转，选择运行最少的进程作为下一个运行进程，而不是分配每个进程以时间片。nice值在CFS中被作为进程获得处理器运行比得权重(高nice值，低优先级，低处理器使用权重)。当可运行进程数量过多时，它们各自所获得的处理器使用比和时间片都趋于0，CFS为此设立了最小粒度，默认值为1ms。</p><p>总结：任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值的相对比例决定的。</p><h1 class=pgc-h-arrow-right>Linux调度的实现</h1><p>CFS具体实现位于kernel/schde_fair.c，其中需要重点关注的是四个组成部分：</p><ol start=1><li>时间记账</li><li>进程选择</li><li>调度器入口</li><li>睡眠和唤醒</li></ol><h1 class=pgc-h-arrow-right>时间记账</h1><p>显然，所有的调度器都必须记录进程的运行时间。CFS中使用一个结构体sched_entity来记录进程运行信息，其定义在Linux2.6.34/include/linux/sched.h#L1090：</p><pre><code>/* * CFS stats for a schedulable entity (task, task-group etc) * * Current field usage histogram: * *     4 se-&gt;block_start *     4 se-&gt;run_node *     4 se-&gt;sleep_start *     6 se-&gt;load.weight */struct sched_entity {    struct load_weight  load;       /* for load-balancing */    struct rb_node      run_node;    struct list_head    group_node;    unsigned int        on_rq;    u64         exec_start;    u64         sum_exec_runtime;    u64         vruntime;    u64         prev_sum_exec_runtime;    u64         last_wakeup;    u64         avg_overlap;    u64         nr_migrations;    u64         start_runtime;    u64         avg_wakeup;#ifdef CONFIG_SCHEDSTATS    u64         wait_start;    u64         wait_max;    u64         wait_count;    u64         wait_sum;    u64         iowait_count;    u64         iowait_sum;    u64         sleep_start;    u64         sleep_max;    s64         sum_sleep_runtime;    u64         block_start;    u64         block_max;    u64         exec_max;    u64         slice_max;    u64         nr_migrations_cold;    u64         nr_failed_migrations_affine;    u64         nr_failed_migrations_running;    u64         nr_failed_migrations_hot;    u64         nr_forced_migrations;    u64         nr_wakeups;    u64         nr_wakeups_sync;    u64         nr_wakeups_migrate;    u64         nr_wakeups_local;    u64         nr_wakeups_remote;    u64         nr_wakeups_affine;    u64         nr_wakeups_affine_attempts;    u64         nr_wakeups_passive;    u64         nr_wakeups_idle;#endif#ifdef CONFIG_FAIR_GROUP_SCHED    struct sched_entity *parent;    /* rq on which this entity is (to be) queued: */    struct cfs_rq       *cfs_rq;    /* rq "owned" by this entity/group: */    struct cfs_rq       *my_q;#endif};</code></pre><p>下半部分的成员变量需要设置了CONFIG_SCHEDSTATS和CONFIG_FAIR_GROUP_SCHED时才会启用，重点关注前半部分即可。</p><p>调度器实体结构是作为一个名为se的成员变量，嵌入在进程描述符struct task_struct中的。</p><div class=pgc-img><img alt=Linux内核学习014——进程调度(三) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ddbf236434348f2bad9b0d6e701eb41><p class=pgc-img-caption></p></div><p>2019-02-10_203619.png</p><p><strong>虚拟实时</strong></p><p>sched_entity中的u64 vruntime成员记录进程的虚拟运行时间，单位为ns。CFS使用vruntime变量来记录一个程序运行了多久以及还能运行多久，定义在Linux2.6.34/kernel/sched_fair.c#L518的函数update_curr实现了该记账功能：</p><pre><code>static void update_curr(struct cfs_rq *cfs_rq){    struct sched_entity *curr = cfs_rq-&gt;curr;    u64 now = rq_of(cfs_rq)-&gt;clock;    unsigned long delta_exec;    if (unlikely(!curr))        return;    /*     * Get the amount of time the current task was running     * since the last time we changed load (this cannot     * overflow on 32 bits):     */    delta_exec = (unsigned long)(now - curr-&gt;exec_start);    if (!delta_exec)        return;    __update_curr(cfs_rq, curr, delta_exec);    curr-&gt;exec_start = now;    if (entity_is_task(curr)) {        struct task_struct *curtask = task_of(curr);        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);        cpuacct_charge(curtask, delta_exec);        account_group_exec_runtime(curtask, delta_exec);    }}</code></pre><p>update_curr()计算了当前进程的执行时间，并将其存放在变量delta_exec总，然后将与运行时间传递给__update_curr()，由其根据当前可运行进程总数对运行时间进行加权计算，最终将权重值与当前进程的vruntime相加。</p><p>注：__update_curr()函数定义在update_curr()函数上方</p><pre><code>/* * Update the current task's runtime statistics. Skip current tasks that * are not in our scheduling class. */static inline void__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,          unsigned long delta_exec){    unsigned long delta_exec_weighted;    schedstat_set(curr-&gt;exec_max, max((u64)delta_exec, curr-&gt;exec_max));    curr-&gt;sum_exec_runtime += delta_exec;    schedstat_add(cfs_rq, exec_clock, delta_exec);    delta_exec_weighted = calc_delta_fair(delta_exec, curr);    curr-&gt;vruntime += delta_exec_weighted;    update_min_vruntime(cfs_rq);}</code></pre><p>update_curr()是由系统定时器周期性调用的，因此vruntime可以准确地测量给定进程的运行时间，且可以知道下一额运行的进程。</p><h1 class=pgc-h-arrow-right>进程选择</h1><p>CFS需要选择下一个进程运行时，它会挑选一个具有最小vruntime的进程。CFS使用了红黑树来组织可运行进程队列，关于红黑树可以参考这篇文章。红黑树是一个自平衡二叉搜索树，以树节点形式存储数据，这些数据对应一个键值，可通过键值快速检索节点上的数据。</p><p>假设存在一个红黑树存储了系统中所有的可运行进程，其中的节点键值为可运行进程的虚拟运行时间。CFS选择vruntime最小的，即树中最左侧的叶子节点，可以从树的根节点一直沿左侧子节点向下找直到叶子节点。实现该过程的函数为__pick_next_entity()，其定义在Linux2.6.34/source/kernel/sched_fair.c#L377。</p><pre><code>static struct sched_entity *__pick_next_entity(struct cfs_rq *cfs_rq){    struct rb_node *left = cfs_rq-&gt;rb_leftmost;    if (!left)        return NULL;    return rb_entry(left, struct sched_entity, run_node);}</code></pre><p>注：其实__pick_next_entity()函数本身并不会遍历树找到最左子节点，因为该值已经缓存在rb_leftmost中了。</p><p><strong>加入进程</strong></p><p>CFS先rbtree(红黑树)中加入可执行进程发生在进程变为可执行状态或者是通过fork()调用第一次创建进程是，enqueue_entity()函数实现了该过程：</p><pre><code>static voidenqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags){    /*     * Update the normalized vruntime before updating min_vruntime     * through callig update_curr().     */    if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATE))        se-&gt;vruntime += cfs_rq-&gt;min_vruntime;    /*     * Update run-time statistics of the 'current'.     */    update_curr(cfs_rq);    account_entity_enqueue(cfs_rq, se);    if (flags &amp; ENQUEUE_WAKEUP) {        place_entity(cfs_rq, se, 0);        enqueue_sleeper(cfs_rq, se);    }    update_stats_enqueue(cfs_rq, se);    check_spread(cfs_rq, se);    if (se != cfs_rq-&gt;curr)        __enqueue_entity(cfs_rq, se);}</code></pre><p>该函数更新运行时间和其他一些统计数据，然后调用__enqueue_entity()进行插入操作：</p><pre><code>/* * Enqueue an entity into the rb-tree: */static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){    struct rb_node **link = &amp;cfs_rq-&gt;tasks_timeline.rb_node;    struct rb_node *parent = NULL;    struct sched_entity *entry;    s64 key = entity_key(cfs_rq, se);    int leftmost = 1;    /*     * Find the right place in the rbtree:     */    while (*link) {        parent = *link;        entry = rb_entry(parent, struct sched_entity, run_node);        /*         * We dont care about collisions. Nodes with         * the same key stay together.         */        if (key &lt; entity_key(cfs_rq, entry)) {            link = &amp;parent-&gt;rb_left;        } else {            link = &amp;parent-&gt;rb_right;            leftmost = 0;        }    }    /*     * Maintain a cache of leftmost tree entries (it is frequently     * used):     */    if (leftmost)        cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_node;    rb_link_node(&amp;se-&gt;run_node, parent, link);    rb_insert_color(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);}</code></pre><p><strong>删除进程</strong></p><p>删除进程发生在进程堵塞或者终止时：</p><pre><code>static voiddequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep){    /*     * Update run-time statistics of the 'current'.     */    update_curr(cfs_rq);    update_stats_dequeue(cfs_rq, se);    if (sleep) {#ifdef CONFIG_SCHEDSTATS        if (entity_is_task(se)) {            struct task_struct *tsk = task_of(se);            if (tsk-&gt;state &amp; TASK_INTERRUPTIBLE)                se-&gt;sleep_start = rq_of(cfs_rq)-&gt;clock;            if (tsk-&gt;state &amp; TASK_UNINTERRUPTIBLE)                se-&gt;block_start = rq_of(cfs_rq)-&gt;clock;        }#endif    }    clear_buddies(cfs_rq, se);    if (se != cfs_rq-&gt;curr)        __dequeue_entity(cfs_rq, se);    account_entity_dequeue(cfs_rq, se);    update_min_vruntime(cfs_rq);    /*     * Normalize the entity after updating the min_vruntime because the     * update can refer to the -&gt;curr item and we need to reflect this     * movement in our normalized position.     */    if (!sleep)        se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;}</code></pre><p>实际删除工作由__dequeue_entity()完成。</p><pre><code>static void __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){    if (cfs_rq-&gt;rb_leftmost == &amp;se-&gt;run_node) {        struct rb_node *next_node;        next_node = rb_next(&amp;se-&gt;run_node);        cfs_rq-&gt;rb_leftmost = next_node;    }    rb_erase(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);}</code></pre><h1 class=pgc-h-arrow-right>调度器入口</h1><p>调度器入口时函数schedule()，该函数定义在Linux2.6.34/kernel/sched.c#L3698中。schedule()时内恶化其他部分调用进程调度器的入口，其通常和一个具体的调度类相关联。</p><pre><code>/* * schedule() is the main scheduler function. */asmlinkage void __sched schedule(void){    struct task_struct *prev, *next;    unsigned long *switch_count;    struct rq *rq;    int cpu;need_resched:    preempt_disable();    cpu = smp_processor_id();    rq = cpu_rq(cpu);    rcu_sched_qs(cpu);    prev = rq-&gt;curr;    switch_count = &amp;prev-&gt;nivcsw;    release_kernel_lock(prev);need_resched_nonpreemptible:    schedule_debug(prev);    if (sched_feat(HRTICK))        hrtick_clear(rq);    raw_spin_lock_irq(&amp;rq-&gt;lock);    update_rq_clock(rq);    clear_tsk_need_resched(prev);    if (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) {        if (unlikely(signal_pending_state(prev-&gt;state, prev)))            prev-&gt;state = TASK_RUNNING;        else            deactivate_task(rq, prev, 1);        switch_count = &amp;prev-&gt;nvcsw;    }    pre_schedule(rq, prev);    if (unlikely(!rq-&gt;nr_running))        idle_balance(cpu, rq);    put_prev_task(rq, prev);    next = pick_next_task(rq);    if (likely(prev != next)) {        sched_info_switch(prev, next);        perf_event_task_sched_out(prev, next);        rq-&gt;nr_switches++;        rq-&gt;curr = next;        ++*switch_count;        context_switch(rq, prev, next); /* unlocks the rq */        /*         * the context switch might have flipped the stack from under         * us, hence refresh the local variables.         */        cpu = smp_processor_id();        rq = cpu_rq(cpu);    } else        raw_spin_unlock_irq(&amp;rq-&gt;lock);    post_schedule(rq);    if (unlikely(reacquire_kernel_lock(current) &lt; 0)) {        prev = rq-&gt;curr;        switch_count = &amp;prev-&gt;nivcsw;        goto need_resched_nonpreemptible;    }    preempt_enable_no_resched();    if (need_resched())        goto need_resched;}</code></pre><h1 class=pgc-h-arrow-right>睡眠和唤醒</h1><p>睡眠(被阻塞)的进程无法执行，原因是其在等待一些时间发生，比如：文件I/O，网络请求等。休眠中的进程有两个相关的进程状态：TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE。区别在于处于TASK_UNINTERRUPTIBLE的进程会忽略信号，而处于TASK_INTERRUPTIBLE的进程会被信号唤醒并响应信号。此外，两种状态的进程都位于一个等待队列上等待事件发生，不能运行。</p><p><strong>唤醒</strong></p><p>唤醒通过wake_up()函数完成，它会唤醒指定的等待队列上的所有进程。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','核学习','014'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>