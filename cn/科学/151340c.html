<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>聚类算法的评估指标 | 极客快訊</title><meta property="og:title" content="聚类算法的评估指标 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/974fc865eb49412c93803c49542098c5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/151340c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/151340c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/151340c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/151340c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/151340c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/151340c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/151340c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/151340c.html><meta property="article:published_time" content="2020-10-29T20:55:19+08:00"><meta property="article:modified_time" content="2020-10-29T20:55:19+08:00"><meta name=Keywords content><meta name=description content="聚类算法的评估指标"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/151340c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>聚类算法的评估指标</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>在学习聚类算法得时候并没有涉及到评估指标，主要原因是聚类算法属于非监督学习，并不像分类算法那样可以使用训练集或测试集中得数据计算准确率、召回率等。那么如何评估聚类算法得好坏呢？好的聚类算法,一般要求类簇具有：</p><ul><li>高的类内 (intra-cluster) 相似度</li><li>低的类间 (inter-cluster) 相似度</li></ul><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/974fc865eb49412c93803c49542098c5><p class=pgc-img-caption></p></div><p>对于聚类算法大致可分为 2类度量标准：</p><ul><li>内部评估的方法：通过一个单一的量化得分来评估算法好坏；该类型的方法</li><li>外部评估的方法：通过将聚类结果与已经有“ground truth”分类进行对比。要么通过人类进行手动评估，要么通过一些指标在特定的应用场景中进行聚类用法的评估。不过该方法是有问题的，如果真的有了label，那么还需要聚类干嘛，而且实际应用中，往往都没label；另一方面，这些label只反映了数据集的一个可能的划分方法，它并不能告诉你存在一个不同的更好的聚类算法。</li></ul><h2 class=pgc-h-arrow-right>内部评价指标</h2><p>当一个聚类结果是基于数据聚类自身进行评估的，这一类叫做内部评估方法。如果某个聚类算法聚类的结果是类间相似性低，类内相似性高，那么内部评估方法会给予较高的分数评价。不过内部评价方法的缺点是：</p><ul><li>那些高分的算法不一定可以适用于高效的信息检索应用场景；</li><li>这些评估方法对某些算法有倾向性，如k-means聚类都是基于点之间的距离进行优化的，而那些基于距离的内部评估方法就会过度的赞誉这些生成的聚类结果。</li></ul><p>这些内部评估方法可以基于特定场景判定一个算法要优于另一个，不过这并不表示前一个算法得到的结果比后一个结果更有意义。这里的意义是假设这种结构事实上存在于数据集中的，如果一个数据集包含了完全不同的数据结构，或者采用的评价方法完全和算法不搭，比如k-means只能用于凸集数据集上，许多评估指标也是预先假设凸集数据集。在一个非凸数据集上不论是使用k-means还是使用假设凸集的评价方法，都是徒劳的。</p><h3 class=pgc-h-arrow-right>SSE(和方差)</h3><p>该统计参数计算的是拟合数据和原始数据对应点的误差的平方和，计算公式如下：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/695e23b41e3646708be802e7be18edb1><p class=pgc-img-caption></p></div><p>SSE越接近于0，说明模型选择和拟合更好，数据预测也越成功。</p><pre><code>#断崖碎石图选取最优K值import pandas as pd  from sklearn.cluster import KMeans  import matplotlib.pyplot as plt  '利用SSE选择k'  SSE = []  # 存放每次结果的误差平方和  for k in range(1,9):      estimator = KMeans(n_clusters=k)  # 构造聚类器      estimator.fit(df[['calories','sodium','alcohol','cost']])      SSE.append(estimator.inertia_)  N = range(1,9)  plt.xlabel('k')  plt.ylabel('SSE')  plt.plot(N,SSE,'o-')  plt.show()</code></pre><h3 class=pgc-h-arrow-right>轮廓系数 Silhouette Coefficient</h3><p>轮廓系数适用于实际类别信息未知的情况。对於单个样本，设a是与它同类别中其他样本的平均距离，b是与它距离最近不同类别中样本的平均距离，其轮廓系数为：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7a80e57f2aaa47ec875944301e1b3078><p class=pgc-img-caption></p></div><p>对于一个样本集合，它的轮廓系数是所有样本轮廓系数的平均值。轮廓系数的取值范围是[-1,1]，同类别样本距离越相近不同类别样本距离越远，分数越高。缺点：不适合基高密度的聚类算法DBSCAN。</p><pre><code>from sklearn import metricsfrom sklearn.metrics import pairwise_distancesfrom sklearn import datasetsdataset = datasets.load_iris()X = dataset.datay = dataset.target import numpy as npfrom sklearn.cluster import KMeanskmeans_model = KMeans(n_clusters=3, random_state=1).fit(X)labels = kmeans_model.labels_metrics.silhouette_score(X, labels, metric='euclidean')</code></pre><h3 class=pgc-h-arrow-right>Calinski-Harabaz Index</h3><p>在真实的分群label不知道的情况下，Calinski-Harabasz可以作为评估模型的一个指标。Calinski-Harabasz指标通过计算类中各点与类中心的距离平方和来度量类内的紧密度，通过计算各类中心点与数据集中心点距离平方和来度量数据集的分离度，CH指标由分离度与紧密度的比值得到。从而，CH越大代表着类自身越紧密，类与类之间越分散，即更优的聚类结果。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5649351531e64a8d9134c12e5859a785><p class=pgc-img-caption></p></div><p>其中m为训练样本数，k是类别个数，是类别之间协方差矩阵，是类别内部数据协方差矩阵，为矩阵的迹。也就是说，类别内部数据的协方差越小越好，类别之间的协方差越大越好，这样的Calinski-Harabasz分数会高。同时，数值越小可以理解为：组间协方差很小，组与组之间界限不明显。</p><p>优点</p><ul><li>当 cluster （簇）密集且分离较好时，分数更高，这与一个标准的 cluster（簇）有关。</li><li>得分计算很快与轮廓系数的对比，最大的优势：快！相差几百倍！毫秒级。</li></ul><p>缺点</p><ul><li>凸的簇的 Calinski-Harabaz index（Calinski-Harabaz 指数）通常高于其他类型的 cluster（簇），例如通过 DBSCAN 获得的基于密度的 cluster（簇）。所以不适合基于密度的聚类算法，DBSCAN。</li></ul><pre><code>import numpy as npfrom sklearn.cluster import KMeanskmeans_model = KMeans(n_clusters=3, random_state=1).fit(X)labels = kmeans_model.labels_print(metrics.calinski_harabaz_score(X, labels))</code></pre><h3 class=pgc-h-arrow-right>Compactness(紧密性)(CP)</h3><p>CP计算每一个类各点到聚类中心的平均距离CP越低意味着类内聚类距离越近。著名的 K-Means 聚类算法就是基于此思想提出的。缺点：没有考虑类间效果。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f311c147c6f4e86b8f095f0d3df484c><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76897601a2a74a62a31aeaf345517d09><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>Separation(间隔性)(SP)</h3><p>SP计算各聚类中心两两之间平均距离，SP越高意味类间聚类距离越远。缺点：没有考虑类内效果。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4b89f2933f474ec3920ad257ef06e0c9><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>Davies-Bouldin Index(戴维森堡丁指数)(分类适确性指标)(DB)(DBI)</h3><p>DB计算任意两类别的类内距离平均距离(CP)之和除以两聚类中心距离求最大值。DB越小意味着类内距离越小同时类间距离越大。该指标的计算公式：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f2e0ac18afd546f0ae9b8caae1a7efa6><p class=pgc-img-caption></p></div><p>其中n是类别个数，是第i个类别的中心，是类别i中所有的点到中心的平均距离；</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29516586eb3b45219fc2f817792ff977><p class=pgc-img-caption></p></div><p>中心点和之间的距离。算法生成的聚类结果越是朝着类内距离最小（类内相似性最大）和类间距离最大（类间相似性最小）变化，那么Davies-Bouldin指数就会越小。缺点：因使用欧式距离所以对于环状分布聚类评测很差。</p><pre><code>from sklearn import datasets from sklearn.cluster import KMeans from sklearn.metrics import davies_bouldin_score from sklearn.datasets.samples_generator import make_blobs   # loading the dataset X, y_true = make_blobs(n_samples=300, centers=4,                         cluster_std=0.50, random_state=0)   # K-Means kmeans = KMeans(n_clusters=4, random_state=1).fit(X)   # we store the cluster labels labels = kmeans.labels_   print(davies_bouldin_score(X, labels))</code></pre><h3 class=pgc-h-arrow-right>Dunn Validity Index (邓恩指数)(DVI)</h3><p>DVI计算任意两个簇元素的最短距离(类间)除以任意簇中的最大距离(类内)。DVI越大意味着类间距离越大同时类内距离越小。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e162ac534ab8457caf3fe440e4020b35><p class=pgc-img-caption></p></div><p>其中</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aca308de3896466f87ddeedd8a1224f9><p class=pgc-img-caption></p></div><p>表示类别,之间的距离；</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dae00df915084d0b90da00fccf1f5896><p class=pgc-img-caption></p></div><p>表示类别内部的类内距离：</p><ul><li>类间距离 可以是任意的距离测度，例如两个类别的中心点的距离；</li><li>类内距离 可以以不同的方法去测量，例如类别kk中任意两点之间距离的最大值。</li></ul><p>因为内部评估方法是搜寻类内相似最大，类间相似最小，所以算法生成的聚类结果的Dunn指数越高，那么该算法就越好。缺点：对离散点的聚类测评很高、对环状分布测评效果差。</p><pre><code>import pandas as pd from sklearn import datasets from jqmcvi import base  # loading the dataset X = datasets.load_iris() df = pd.DataFrame(X.data)  # K-Means from sklearn import cluster k_means = cluster.KMeans(n_clusters=3) k_means.fit(df) #K-means training y_pred = k_means.predict(df)  # We store the K-means results in a dataframe pred = pd.DataFrame(y_pred) pred.columns = ['Type']  # we merge this dataframe with df prediction = pd.concat([df, pred], axis = 1)  # We store the clusters clus0 = prediction.loc[prediction.Species == 0] clus1 = prediction.loc[prediction.Species == 1] clus2 = prediction.loc[prediction.Species == 2] cluster_list = [clus0.values, clus1.values, clus2.values]  print(base.dunn(cluster_list))</code></pre><h2 class=pgc-h-arrow-right>外部评价指标</h2><p>在外部评估方法中，聚类结果是通过使用没被用来做训练集的数据进行评估。例如已知样本点的类别信息和一些外部的基准。这些基准包含了一些预先分类好的数据，比如由人基于某些场景先生成一些带label的数据，因此这些基准可以看成是金标准。这些评估方法是为了测量聚类结果与提供的基准数据之间的相似性。然而这种方法也被质疑不适用真实数据。</p><h3 class=pgc-h-arrow-right>纯度（Purity）</h3><p>纯度（Purity）是一种简单而透明的评估手段，为了计算纯度（Purity），我们把每个簇中最多的类作为这个簇所代表的类，然后计算正确分配的类的数量，然后除以N。形式化表达如下：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aac77419b5c146fa80014a56b059f7a9><p class=pgc-img-caption></p></div><p>其中：</p><ul><li>是聚类的集合，表示第k个聚类的集合。</li><li>是文档集合，表示第J个文档。</li><li>表示文档总数。</li></ul><p>上述过程即给每个聚类簇分配一个类别,且这个类别的样本在该簇中出现的次数最多，然后计算所有 K 个聚类簇的这个次数之和再归一化即为最终值。Purity值在0～1之间 ,越接近1表示聚类结果越好。</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/987802f704084001923b067d465dd110><p class=pgc-img-caption></p></div><p>如图认为x代表一类文档，o代表一类文档，方框代表一类文档。如上图的purity = ( 3+ 4 + 5) / 17 = 0.71，其中第一类正确的有5个，第二个4个，第三个3个，总文档数17。</p><p>当簇的数量很多的时候，容易达到较高的纯度——特别是，如果每个文档都被分到独立的一个簇中，那么计算得到的纯度就会是1。因此，不能简单用纯度来衡量聚类质量与聚类数量之间的关系。另外Purity无法用于权衡聚类质量与簇个数之间的关系。</p><pre><code>def purity(result, label):    # 计算纯度     total_num = len(label)    cluster_counter = collections.Counter(result)    original_counter = collections.Counter(label)     t = []    for k in cluster_counter:        p_k = []        for j in original_counter:            count = 0            for i in range(len(result)):                if result[i] == k and label[i] == j: # 求交集                    count += 1            p_k.append(count)        temp_t = max(p_k)        t.append(temp_t)        return sum(t)/total_num</code></pre><h3 class=pgc-h-arrow-right>标准化互信息（NMI）</h3><p>互信息（Normalized Mutual Information）是用来衡量两个数据分布的吻合程度。也是一有用的信息度量，它是指两个事件集合之间的相关性。互信息越大，词条和类别的相关程度也越大。NMI (Normalized Mutual Information) 即归一化互信息：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8e23f38df6e64d4ebe79dac805a7dbff><p class=pgc-img-caption></p></div><p>其中,表示互信息(Mutual Information),为熵，当 log 取 2 为底时，单位为 bit，取 e 为底时单位为 nat。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/85915b1408da44468872826d22ee64d2><p class=pgc-img-caption></p></div><p>其中,</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ac97965cbf904783913f091dd97fcbcc><p class=pgc-img-caption></p></div><p>可以分别看作样本 (document) 属于聚类簇, 属于类别, 同时属于的概率。第二个等价式子则是由概率的极大似然估计推导而来。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/000ad65d90614002834e617910532598><p class=pgc-img-caption></p></div><p>互信息</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/392f18bc892d4665ac917563d53d4f2b><p class=pgc-img-caption></p></div><p>表示给定类簇信息的前提条件下,类别信息的增加量，或者说其不确定度的减少量。直观地，互信息还可以写出如下形式：</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9591eedf93c04456a929703ea9a33a46><p class=pgc-img-caption></p></div><p>互信息的最小值为 0, 当类簇相对于类别只是随机的, 也就是说两者独立的情况下,对于未带来任何有用的信息.如果得到的与关系越密切, 那么</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/392f18bc892d4665ac917563d53d4f2b><p class=pgc-img-caption></p></div><p>值越大。如果完整重现了, 此时互信息最大：</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0897c1c9a5c74d298fa7ce8eab92c2b8><p class=pgc-img-caption></p></div><p>当K=N时,即类簇数和样本个数相等，MI 也能达到最大值。所以 MI 也存在和纯度类似的问题,即它并不对簇数目较大的聚类结果进行惩罚,因此也不能在其他条件一样的情况下,对簇数目越小越好的这种期望进行形式化。NMI 则可以解决上述问题,因为熵会随着簇的数目的增长而增大。当K=N时,</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4e1f9aa5e03649bf89e2db9a033b237f><p class=pgc-img-caption></p></div><p>会达到其最大值</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b71cf5f5031f495397c42a83b5c244d4><p class=pgc-img-caption></p></div><p>, 此时就能保证 NMI 的值较低。之所以采用</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ca039ced56642ecb20e3023dc16035a><p class=pgc-img-caption></p></div><p>作为分母是因为它是</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a6370f13fb7b412b85951247a65da5bd><p class=pgc-img-caption></p></div><p>的紧上界, 因此可以保证</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a1af69075914fdab8272e7c03ef82cf><p class=pgc-img-caption></p></div><p>。</p><p>示例：</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f8299166da74bd89fee18f7410e975b><p class=pgc-img-caption></p></div><p>gnd 是 ground truth 的意思，grps 表示聚类后的 groups. 问题：计算序列 gnd 和 grps 的 NMI.</p><p>先计算联合概率分布</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c565d4d56f5f49b38ac37f0fb50eb587><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe39cbb1acfe44a0bc21f1ef938027aa><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>计算边际分布</h4><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/eebdc776756d45dba9365086a6fb2aa1><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da3182c2fbca408d830a56c2e3b75673><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>计算熵和互信息</h4><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1f22ac42f16542089d67a5ed510742dd><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a7cd7ead58ba43059a14de9de3af41af><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/02d7d8a0744b45b2bb36b6729a3f9b34><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bf820c60ae67452995f93c9666b91952><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>计算 NMI</h4><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b6eedbe17b345d7aa3ef27b6196e946><p class=pgc-img-caption></p></div><p>代码实现：</p><pre><code>def NMI(result, label):    # 标准化互信息     total_num = len(label)    cluster_counter = collections.Counter(result)    original_counter = collections.Counter(label)        # 计算互信息量    MI = 0    eps = 1.4e-45 # 取一个很小的值来避免log 0        for k in cluster_counter:        for j in original_counter:            count = 0            for i in range(len(result)):                if result[i] == k and label[i] == j:                    count += 1            p_k = 1.0*cluster_counter[k] / total_num            p_j = 1.0*original_counter[j] / total_num            p_kj = 1.0*count / total_num            MI += p_kj * math.log(p_kj /(p_k * p_j) + eps, 2)        # 标准化互信息量    H_k = 0    for k in cluster_counter:        H_k -= (1.0*cluster_counter[k] / total_num) * math.log(1.0*cluster_counter[k] / total_num+eps, 2)    H_j = 0    for j in original_counter:        H_j -= (1.0*original_counter[j] / total_num) * math.log(1.0*original_counter[j] / total_num+eps, 2)            return 2.0 * MI / (H_k + H_j)</code></pre><p>sklearn中自带的方法：</p><pre><code>from sklearn.metrics.cluster import normalized_mutual_info_scoreprint(normalized_mutual_info_score([0, 0, 1, 1], [0, 0, 1, 1]))</code></pre><h3 class=pgc-h-arrow-right>调整互信息AMI（ Adjusted mutual information）</h3><p>已知聚类标签与真实标签，互信息（mutual information）能够测度两种标签排列之间的相关性，同时忽略标签中的排列。有两种不同版本的互信息以供选择，一种是Normalized Mutual Information（NMI）,一种是Adjusted Mutual Information（AMI）。</p><p>假设U与V是对N个样本标签的分配情况，则两种分布的熵（熵表示的是不确定程度）分别为：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9e6318f8f849458cad909ca99b8b76a1><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc0a7adb051342bdb37f62785c8c0890><p class=pgc-img-caption></p></div><p>其中：</p><ul><li>是从U中随机选取的对象到类的概率</li><li>从V中随机选取的对象到类的概率</li></ul><p>U与V之间的互信息（MI）定义为：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a97ec086ea8d49c0809043462e1061b7><p class=pgc-img-caption></p></div><p>其中</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a08d4705b6a46ef8c857804bf39bf66><p class=pgc-img-caption></p></div><p>是随机选择的对象落入两个类的概率和。</p><p>调整互信息（Adjusted mutual information）定义为：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b582a68d940c483a93c74c8acd0b6d32><p class=pgc-img-caption></p></div><p>MI的期望可以用以下公式来计算。在这个方程式中，</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1c7219bc212419cac98106dd9c34fbc><p class=pgc-img-caption></p></div><p>为元素的数量，</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fc84b7cb13b045e6b314550fe5749e65><p class=pgc-img-caption></p></div><p>为元素的数量：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/22ef359b090f4aff8faf58e1b16f9b76><p class=pgc-img-caption></p></div><p>利用基于互信息的方法来衡量聚类效果需要实际类别信息，MI与NMI取值范围为[0,1]，AMI取值范围为[-1,1]，它们都是值越大意味着聚类结果与真实情况越吻合。</p><p>优点</p><ul><li>随机（统一）标签分配的AMI评分接近0）</li><li>有界范围 [0, 1]: 接近 0 的值表示两个主要独立的标签分配，而接近 1 的值表示重要的一致性。此外，正好 0 的值表示 purely（纯粹） 独立标签分配，正好为 1 的 AMI 表示两个标签分配相等（有或者没有 permutation）。</li><li>对簇的结构没有作出任何假设: 可以用于比较聚类算法</li></ul><p>缺点：</p><ul><li>与 inertia 相反， MI-based measures 需要了解 ground truth classes，而在实践中几乎不可用，或者需要人工标注或手动分配（如在监督学习环境中）。然而，基于 MI-based measures （基于 MI 的测量方式）也可用于纯无人监控的设置，作为可用于聚类模型选择的 Consensus Index （共识索引）的构建块。</li><li>NMI 和 MI 没有调整机会。</li></ul><pre><code>from sklearn import metricslabels_true = [0, 0, 0, 1, 1, 1]labels_pred = [0, 0, 1, 1, 2, 2] print(metrics.adjusted_mutual_info_score(labels_true, labels_pred))</code></pre><h3 class=pgc-h-arrow-right>Rand index兰德指数</h3><p>兰德指数 (Rand index, RI), 将聚类看成是一系列的决策过程,即对文档集上所有N(N-1)/2个文档 (documents) 对进行决策。当且仅当两篇文档相似时,我们将它们归入同一簇中。</p><p>Positive:</p><ul><li>TP 将两篇相似文档归入一个簇 (同 – 同)</li><li>TN 将两篇不相似的文档归入不同的簇 (不同 – 不同)</li></ul><p>Negative:</p><ul><li>FP 将两篇不相似的文档归入同一簇 (不同 – 同)</li><li>FN 将两篇相似的文档归入不同簇 (同- 不同) (worse)</li></ul><p>RI 则是计算「正确决策」的比率(精确率, accuracy)：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34dbc26b0e184315af2b20e9085cf47b><p class=pgc-img-caption></p></div><p>RI取值范围为[0,1]，值越大意味着聚类结果与真实情况越吻合。</p><pre><code>def contingency_table(result, label):        total_num = len(label)        TP = TN = FP = FN = 0    for i in range(total_num):        for j in range(i + 1, total_num):            if label[i] == label[j] and result[i] == result[j]:                TP += 1            elif label[i] != label[j] and result[i] != result[j]:                TN += 1            elif label[i] != label[j] and result[i] == result[j]:                FP += 1            elif label[i] == label[j] and result[i] != result[j]:                FN += 1    return (TP, TN, FP, FN) def rand_index(result, label):    TP, TN, FP, FN = contingency_table(result, label)    return 1.0*(TP + TN)/(TP + FP + FN + TN)</code></pre><h3 class=pgc-h-arrow-right>调整兰德系数 （Adjusted Rand index）</h3><p>对于随机结果，RI并不能保证分数接近零。为了实现“在聚类结果随机产生的情况下，指标应该接近零”，调整兰德系数（Adjusted rand index）被提出，它具有更高的区分度：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/80a7a7e394744693af625b0c47dec4a8><p class=pgc-img-caption></p></div><p>ARI取值范围为[-1,1]，值越大意味着聚类结果与真实情况越吻合。从广义的角度来讲，ARI衡量的是两个数据分布的吻合程度。</p><p>优点：</p><ul><li>对任意数量的聚类中心和样本数，随机聚类的ARI都非常接近于0</li><li>取值在［－1，1］之间，负数代表结果不好，越接近于1越好</li><li>对簇的结构不需作出任何假设：可以用于比较聚类算法。</li></ul><p>缺点：</p><ul><li>与 inertia 相反，ARI 需要 ground truth classes 的相关知识，ARI需要真实标签，而在实践中几乎不可用，或者需要人工标注者手动分配（如在监督学习环境中）。然而，ARI 还可以在 purely unsupervised setting （纯粹无监督的设置中）作为可用于 聚类模型选择（TODO）的共识索引的构建块。</li></ul><pre><code>from sklearn import metricslabels_true = [0, 0, 0, 1, 1, 1]labels_pred = [0, 0, 1, 1, 2, 2] print(metrics.adjusted_rand_score(labels_true, labels_pred)) </code></pre><h3 class=pgc-h-arrow-right>F值方法</h3><p>这是基于上述RI方法衍生出的一个方法，我们可以 FN 罚更多,通过取</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c636f91eecb4e318bc8e9169ae25583><p class=pgc-img-caption></p></div><p>中的大于 1, 此时实际上也相当于赋予召回率更大的权重：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c942314f8ee4417998b76c83704a12eb><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/85880e86df6b4076b400d35d59771536><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5d0a382231b34ac79ba79132c780e8df><p class=pgc-img-caption></p></div><p>RI方法有个特点就是把准确率和召回率看得同等重要，事实上有时候我们可能需要某一特性更多一点，这时候就适合F值方法。</p><pre><code>def precision(result, label):    TP, TN, FP, FN = contingency_table(result, label)    return 1.0*TP/(TP + FP) def recall(result, label):    TP, TN, FP, FN = contingency_table(result, label)    return 1.0*TP/(TP + FN) def F_measure(result, label, beta=1):    prec = precision(result, label)    r = recall(result, label)    return (beta*beta + 1) * prec * r/(beta*beta * prec + r)</code></pre><h3 class=pgc-h-arrow-right>Fowlkes-Mallows scores</h3><p>Fowlkes-Mallows Scores（FMI） FMI是成对的precision（精度）和recall（召回）的几何平均数。取值范围为 [0,1]，越接近1越好。定义为：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/019fd12cc2d140df8b44897144e2e640><p class=pgc-img-caption></p></div><p>代码实现：</p><pre><code>from sklearn import metricslabels_true = [0, 0, 0, 1, 1, 1]labels_pred = [0, 0, 1, 1, 2, 2] print(metrics.fowlkes_mallows_score(labels_true, labels_pred))</code></pre><h3 class=pgc-h-arrow-right>调和平均V-measure</h3><p>说V-measure之前要先介绍两个指标：</p><ul><li>同质性（homogeneity）：每个群集只包含单个类的成员。</li><li>完整性（completeness）：给定类的所有成员都分配给同一个群集。</li></ul><p>同质性和完整性分数基于以下公式得出：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a7201a4ae7345d1b0854cb0258b2385><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0176cfcebbd4435aa589446937bb129e><p class=pgc-img-caption></p></div><p>其中</p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e3c8736d2de841b08603ce1251400e6b><p class=pgc-img-caption></p></div><p>是给定给定簇赋值的类的条件熵，由以下公式求得：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8d1f4eb5a0e24d71bfb84a8c70d66af4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f2c5d8b636a2403c9fa1c07072812ef2><p class=pgc-img-caption></p></div><p>是类熵，公式为：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30f6bd01a19a4a22ae31f49426159d99><p class=pgc-img-caption></p></div><p>其中，n是样本总数，和分别属于类c和类k的样本数，而是从类c划分到类k的样本数量。条件熵H(K|C)和类熵H(K)，根据以上公式对称求得。</p><p>V-measure是同质性homogeneity和完整性completeness的调和平均数，V-measure取值范围为 [0,1]，越大越好，但当样本量较小或聚类数据较多的情况，推荐使用AMI和ARI。公式：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5badc6805b2a4931809bdfe9e76595b3><p class=pgc-img-caption></p></div><p>代码实现：</p><pre><code>from sklearn import metricslabels_true = [0, 0, 0, 1, 1, 1]labels_pred = [0, 0, 1, 1, 2, 2] print(metrics.homogeneity_score(labels_true, labels_pred))print(metrics.completeness_score(labels_true, labels_pred))print(metrics.v_measure_score(labels_true, labels_pred))</code></pre><p>优点：</p><ul><li>分数明确：从0到1反应出最差到最优的表现；</li><li>解释直观：差的调和平均数可以在同质性和完整性方面做定性的分析；</li><li>对簇结构不作假设：可以比较两种聚类算法如k均值算法和谱聚类算法的结果。</li></ul><p>缺点：</p><ul><li>以前引入的度量在随机标记方面没有规范化，这意味着，根据样本数，集群和先验知识，完全随机标签并不总是产生相同的完整性和均匀性的值，所得调和平均值V-measure也不相同。特别是，随机标记不会产生零分，特别是当簇的数量很大时。</li><li>当样本数大于一千，聚类数小于10时，可以安全地忽略该问题。对于较小的样本量或更大数量的集群，使用经过调整的指数（如调整兰德指数）更为安全。</li><li>这些指标要求的先验知识，在实践中几乎不可用或需要手动分配的人作注解者（如在监督学习环境中）。</li></ul><h3 class=pgc-h-arrow-right>Jaccard 指数</h3><p>该指数用于量化两个数据集之间的相似性，该值得范围为0-1.其中越大表明两个数据集越相似：</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30f82c197b1346b19e465a2dd96ea614><p class=pgc-img-caption></p></div><p>该指数和近年来的IOU计算方法一致</p><h3 class=pgc-h-arrow-right>Dice 指数</h3><p>该指数是基于jaccard指数上将TP的权重置为2倍。</p><p></p><div class=pgc-img><img alt=聚类算法的评估指标 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/02a0e2527a624098afca475f3aa04592><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'聚类','评估','指标'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E5%AD%A6/19ab3a8.html alt=聚类评估指标总结 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5701491d73914e70b0bfda6987923d9a style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E5%AD%A6/19ab3a8.html title=聚类评估指标总结>聚类评估指标总结</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>