<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基于Nodejs打造Web架构中间层 | 极客快訊</title><meta property="og:title" content="基于Nodejs打造Web架构中间层 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/81f72e5d40db415d94bc7a8e7a9f82fb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/1c484af5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1c484af5.html><meta property="article:published_time" content="2020-11-14T20:57:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:57:17+08:00"><meta name=Keywords content><meta name=description content="基于Nodejs打造Web架构中间层"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/1c484af5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基于Nodejs打造Web架构中间层</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>前言</strong></h1><p style=text-align:start>Node.js自2009年诞生以来，发展速度相当惊人，目前各种开发框架层出不穷，国内外各大公司都在使用，如国内的阿里的淘宝、天猫、阿里云、蚂蚁金服，腾讯视频、携程、百度、网易、苏宁、京东、爱奇艺、去哪儿、有赞、贝壳找房等等好多企业都在使用，大部分企业把Node.js作为中间层去应用，今天和大家简单说说关于基于Nodejs打造Web架构中间层的一些知识。</p><h1 class=pgc-h-arrow-right><strong>一、中间层与中间件</strong></h1><h1 class=pgc-h-arrow-right><strong>1、什么是中间层</strong></h1><p style=text-align:start>中间层（Middle Tier）也称作应用程序服务器层或应用服务层，是用户接口或 Web 客户端与数据库之间的逻辑层。典型情况下 Web 服务器位于该层，业务对象在此实例化。中间层是生成并操作接收信息的业务规则和函数的集合。它们通过业务规则（可以频繁更改）完成该任务，并由此被封装到在物理上与应用程序程序逻辑本身相独立的组件中。</p><h1 class=pgc-h-arrow-right><strong>1.1 Node作为中间层模式</strong></h1><p style=text-align:start>以Node作为中间层，当客户端打开一个网站时，先请求到node服务器这一层，通过node服务器转发请求到后端的服务器，获取数据，然后返给node的模板引擎，根据视图模板渲染好模板字符串页面，再返回给客户端，直接展示页面，如图：</p><div class=pgc-img><img alt=基于Nodejs打造Web架构中间层 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81f72e5d40db415d94bc7a8e7a9f82fb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>1.2 负载均衡器-Nginx</strong></h1><p style=text-align:start>Nginx是一个高性能的WEB服务器和反向代理服务器，最常用的软件负载均衡器。</p><p style=text-align:start>当访问量比较大时，频繁的请求，会给服务带来很大压力，通过负载均衡、分流，减轻服务器的压力；另一方面，网站部署在多台服务器，当某台服务器故障的时候，可以马上切换到其它服务器，还能保证网站能正常访问，这就是负载均衡的优势。</p><div class=pgc-img><img alt=基于Nodejs打造Web架构中间层 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7bca338f8f07446bba97166fdf8effb2><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、什么是中间件</strong></h1><h1 class=pgc-h-arrow-right><strong>2.1 中间件概念</strong></h1><p style=text-align:start>中间件(MiddleWare)是一种独立的系统软件服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源，中间件位于客户机服务器的操作系统之上，管理计算资源和网络通信。从这个意义上可以用一个等式来表示中间件：中间件=平台+通信，这也就限定了只有用于分布式系统中才能叫中间件，同时也把它与支撑软件和实用软件区分开来。</p><p style=text-align:start>在NodeJS中，中间件主要是指封装所有Http请求细节处理的方法。一次Http请求通常包含很多工作，如记录日志、ip过滤、查询字符串、请求体解析、Cookie处理、权限验证、参数验证、异常处理等，但对于Web应用而言，并不希望接触到这么多细节性的处理，因此引入中间件来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。中间件可以理解为一个对用户请求进行过滤和预处理的东西，它一般不会直接对客户端进行相应，而是将处理之后的结果传递下去。简单来说就是实现某种功能的函数。</p><p style=text-align:start>Express是一个自身功能极简，完全是路由和中间件构成一个web开发框架：从本质上来说，一个Express应用就是在调用各种中间件，中间件机制如图所示：</p><div class=pgc-img><img alt=基于Nodejs打造Web架构中间层 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f52e6175e419404e869fc5d1b9dec2f5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2.2 中间件机制核心实现</strong></h1><p style=text-align:start>中间件是从Http请求发起到响应结束过程中的处理方法，通常需要对请求和响应进行处理，因此一个基本的中间件的形式如下：</p><p style=text-align:start>`const middleware = (req, res, next) => {</p><p style=text-align:start>// TODO</p><p style=text-align:start>next()</p><p style=text-align:start>}`</p><h1 class=pgc-h-arrow-right><strong>二、中间层的意义</strong></h1><p style=text-align:start>Node.js是一个Javascript运行环境。Node.js 使用事件驱动， 非阻塞I/O 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。Node.js是单进程、单线程运行机制，通过事件轮询（event loop）来实现并发操作，而且性能很好。</p><p style=text-align:start>Node.js最大的改良架构就是"增加了中间层"，前后端分离，使用Node.js来做‘BBF(backend of frontend)’在传统后端加入了Node.js这一层，通过此有两点好处，前端接管了view层，后端渲染也开始全部由前端掌控，另一个就是接口层增加了一层。在前后端分离的天然选择下，Node.js中间层可以承担更多的责任。</p><h1 class=pgc-h-arrow-right><strong>1、Node.js中间层可做的工作</strong></h1><ul><li>代理：在开发环境下，我们可以利用代理来，解决最常见的跨域问题；在线上环境下，我们可以利用代理，转发请求到多个服务端。</li><li>缓存：缓存其实是更靠近前端的需求，用户的动作触发数据的更新，Node.js中间层可以直接处理一部分缓存需求。</li><li>限流：Node.js中间层，可以针对接口或者路由做响应的限流。</li><li>日志：相比其他服务端语言，Node.js中间层的日志记录，能更方便快捷的定位问题（是在浏览器端还是服务端）。</li><li>监控：擅长高并发的请求处理，做监控也是合适的选项。</li><li>鉴权：有一个中间层去鉴权，也是一种单一职责的实现。</li><li>路由：前端更需要掌握页面路由的权限和逻辑。</li><li>服务端渲染：Node.js中间层的解决方案更灵活，比如SSR、模板直出、利用一些JS库做预渲染等等。</li></ul><h1 class=pgc-h-arrow-right><strong>2、Node.js中间层带来的好处</strong></h1><ul><li>通过PC Web自己的中间层，可以按照业务定制化接口，扩大前端展现的能力和范围；</li><li>中间层接口由使用接口的前端工程师开发，对展现和接口的功能更加熟悉，避免了以前的工作模式中接口方跟各方的需求对接、沟通、联调时间，这样使得项目的推进更加顺利，项目迭代会更快；</li><li>中间层使用NodeJS，开发语言是JavaScript，跟现在前端工程师的工作语言一样，减少了学习成本；</li><li>中间层接口的开发由前端工程师同时负责开发，既节省了人力成本，同时又提高了前端开发人员的技术能力，使得前端工程师向全栈工程师迈进。</li></ul><h1 class=pgc-h-arrow-right><strong>3、Node.js中间层的优势</strong></h1><ul><li>功能分离，减轻板块负担;</li><li>跨系统、跨终端均可重用页面数据校验、逻辑代码，无需因为新系统、终端的接入而重写校验；</li><li>只在中间件中做一次数据校验，避免了前端做数据校验的同时后端也要做校验的重复，在有效保证数据的有效性的同时降低了团队整体的工作量；</li><li>处理数据逻辑，解放了前端既要做页面渲染又要写复杂的逻辑，使得页面开发人员专注于页面渲染，不仅使得分工更为明确，项目协作效率更高，更重要的是快速响应页面使得页面加载更快，用户体验更好，避免了浏览器长时间显示空白页面的不友好体验，真正的前后端分离。</li></ul><h1 class=pgc-h-arrow-right><strong>三、中间层的实现</strong></h1><p style=text-align:start>前面写了很多理论方面的知识，接下来自己手动来简单实现Node.js基于Koa框架实现的中间层。</p><h1 class=pgc-h-arrow-right><strong>1、后端提供的接口</strong></h1><p style=text-align:start>先了解一下后端提供的一个接口，根据前端页面输入不同账号信息，后端接口会返回不同的值，如图：</p><div class=pgc-img><img alt=基于Nodejs打造Web架构中间层 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/19fe65b5f7704bf998b43436eafd5cf8><p class=pgc-img-caption></p></div><p>这段PHP代码是根据前端传给不同的用户名和密码状态返回不同的状态码。</p><h1 class=pgc-h-arrow-right><strong>2、搭建前端页面</strong></h1><p style=text-align:start>前端页面用了ejs模板引擎采用服务端渲染方式来进行。前端页面主要有三个代码的文件，app.js，admin.js，admin.ejs。</p><h1 class=pgc-h-arrow-right><strong>2.1 项目代码结构</strong></h1><div class=pgc-img><img alt=基于Nodejs打造Web架构中间层 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aca06c919ca8420397fbce742d449824><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2.2 项目代码展示</strong></h1><p style=text-align:start>1、是app.js代码</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Koa = require('koa');</p><p style=text-align:start>// 路由</p><p style=text-align:start>const Router = require('koa-router');</p><p style=text-align:start>// 模板引擎</p><p style=text-align:start>const ejs = require('koa-ejs');</p><p style=text-align:start>// 数据解析</p><p style=text-align:start>const body = require('koa-bodyparser');</p><p style=text-align:start>// 处理静态文件</p><p style=text-align:start>const static = require("koa-static");</p><p style=text-align:start>const path = require('path');</p><p style=text-align:start>const app = new Koa();</p><p style=text-align:start>ejs(app,{</p><p>root:path.resolve(__dirname,"template"),</p><p>layout:false,</p><p>viewExt:"ejs",</p><p>cache:false,</p><p>debug:false</p><p style=text-align:start>})</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>app.use(body());</p><p style=text-align:start>router.get("/",ctx => {</p><p>ctx.body = '主页';</p><p style=text-align:start>})</p><p style=text-align:start>router.use("/admin",require("./router/admin"));</p><p style=text-align:start>app.use(static('./static'));</p><p style=text-align:start>app.use(router.routes());</p><p style=text-align:start>app.listen(3000);`</p></blockquote><p style=text-align:start>2、登录页面文件，用ejs模板引擎来处理</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`&lt;!DOCTYPE html></p><p style=text-align:start>&lt;html lang="en"></p><p style=text-align:start>&lt;head></p><p>&lt;meta charset="UTF-8"></p><p>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"></p><p>&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"></p><p>&lt;title>我是管理页面&lt;/title></p><p>&lt;script src="../../js/jquery.min.js">&lt;/script></p><p style=text-align:start>&lt;/head></p><p style=text-align:start>&lt;body></p><p>&lt;p>用户：&lt;input type="text">&lt;/p></p><p>&lt;p>密码：&lt;input type="password">&lt;/p></p><p>&lt;button>提交&lt;/button></p><p>&lt;script></p><p>$(function(){</p><p>$('button').click(function(){</p><p>var username = $(':text').val();</p><p>var password = $(':password').val();</p><p>$.ajax({</p><p>url:'/admin/login',</p><p>method:'post',</p><p>data:{</p><p>username,</p><p>password</p><p>},</p><p>success(data){</p><p>console.log(data);</p><p>}</p><p>})</p><p>})</p><p>})</p><p>&lt;/script></p><p style=text-align:start>&lt;/body></p><p style=text-align:start>&lt;/html>`</p></blockquote><h1 class=pgc-h-arrow-right><strong>3、代码逐步实现逻辑</strong></h1><p style=text-align:start>1、使用上面的登录页代码，然后admin.js页面代码如下</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Router = require('koa-router');</p><p style=text-align:start>const querystring = require('querystring');</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>router.get('/',async ctx=>{</p><p>await ctx.render('admin/admin')</p><p style=text-align:start>})</p><p style=text-align:start>router.post("/login",async ctx => {</p><p>const { username,password } = ctx.request.body;</p><p>console.log(username,password);</p><p style=text-align:start>})</p><p style=text-align:start>module.exports = router.routes();`</p></blockquote><p style=text-align:start>此时登录页面输入用户名和密码点击提交时会输出结构如下代码：</p><blockquote class=pgc-blockquote-abstract><p>``^CedzdeMacBook-Pro-5:0323 edz$ nodemon app.js</p><p>[nodemon] 2.0.2</p><p>[nodemon] to restart at any time, enter rs<br></p><p>[nodemon] watching dir(s): <em>.</em></p><p>[nodemon] watching extensions: js,mjs,json</p><p>[nodemon] starting node app.js<br></p><p>admin 123456 //后端拿到了前端传给的数据``</p></blockquote><p style=text-align:start>此时传过的数据后端会拿他与数据库作比对，进行处理，而Node.js只充当中介作用，不做数据的处理。</p><p style=text-align:start>2、我们接着看，把要的数据传个服务端，使用axios发送数据到服务端，其中里面用到了数据格式的转换：</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Router = require('koa-router');</p><p style=text-align:start>const querystring = require('querystring');</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>router.get('/',async ctx=>{</p><p>await ctx.render('admin/admin')</p><p style=text-align:start>})</p><p style=text-align:start>//此处为中间层，起到中介作用，会把数据发给后端接口</p><p style=text-align:start>router.post("/login",async ctx => {</p><p>const { username,password } = ctx.request.body;</p><p>//console.log(username,password);</p><p>//要数据传给服务端，使用axios发送数据到服务端</p><p>const {data} = await axios({</p><p>url:'http://localhost/login/check.php',</p><p>method:'post',</p><p>data:{</p><p>username,</p><p>password</p><p>},</p><p>// username=admin&password=123456查询字符串</p><p>//数据格式转换，前端是个JSON数据格式，后端拿到的是表单数据</p><p>transformRequest:[</p><p>data =>{</p><p>return querystring.stringify(data)</p><p>}</p><p>]</p><p>})</p><p style=text-align:start>})</p><p style=text-align:start>module.exports = router.routes();`</p></blockquote><p style=text-align:start>此时登录页面输入用户名和不同的密码和空密码时点击提交时会输出结构如下代码：</p><blockquote class=pgc-blockquote-abstract><p>``^CedzdeMacBook-Pro-5:0323 edz$ nodemon app.js</p><p>[nodemon] 2.0.2</p><p>[nodemon] to restart at any time, enter rs<br></p><p>[nodemon] watching dir(s): <em>.</em></p><p>[nodemon] watching extensions: js,mjs,json</p><p>[nodemon] starting node app.js<br></p><p>{ code:1 }</p><p>{ code:0 }</p><p>{ code:3 }``</p></blockquote><p style=text-align:start>3、这时我们把后端传回的接口数据在进行重新包装一下，添加如下代码：</p><p style=text-align:start>`// 重新包装</p><pre><code>if(data.code !== 1){    // return中断条件    return ctx.body = {        code:401,        message:'未经授权'    }}// 前端自己定义的提示语 ，后端专注逻辑开发，不用在和前端定义接口ctx.body = {   code:200,   message:'校验成功'}`</code></pre><p style=text-align:start>这时页面会返回经过前端包装的提示语，如图所示：</p><div class=pgc-img><img alt=基于Nodejs打造Web架构中间层 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7b0f6e683e5141229ebde908717b6d0e><p class=pgc-img-caption></p></div><p style=text-align:start>总的处理路由的admin.js代码文件如下：</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Router = require('koa-router');</p><p style=text-align:start>const axios = require('axios');</p><p style=text-align:start>const querystring = require('querystring');</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>router.get('/',async ctx=>{</p><p>await ctx.render('admin/admin')</p><p style=text-align:start>})</p><p style=text-align:start>//此处为中间层，起到中介作用，会把数据发给后端接口</p><p style=text-align:start>router.post("/login",async ctx => {</p><p>const { username,password } = ctx.request.body;</p><p>//console.log(username,password);</p><p>//要数据传给服务端，使用axios发送数据到服务端</p><p>const {data} = await axios({</p><p>url:'http://localhost/login/check.php', //后端提供的一个接口文件</p><p>method:'post',</p><p>data:{</p><p>username,</p><p>password</p><p>},</p><p>// username=admin&password=123456查询字符串</p><p>//数据格式转换，前端是个JSON数据格式，后端拿到的是表单数据</p><p>transformRequest:[</p><p>data =>{</p><p>return querystring.stringify(data)</p><p>}</p><p>]</p><p>})</p><p>// 重新包装</p><p>// console.log(data);</p><p>if(data.code !== 1){</p><p>// return中断条件</p><p>return ctx.body = {</p><p>code:401,</p><p>message:'未经授权'</p><p>}</p><p>}</p><p>// 前端自己定义的提示语 ，后端专注逻辑开发，不用在和前端定义接口</p><p>ctx.body = {</p><p>code:200,</p><p>message:'校验成功'</p><p>}</p><p style=text-align:start>})</p><p style=text-align:start>module.exports = router.routes();`</p><p style=text-align:start>服务端不要暴露太多给用户信息，不用提示用户名正确或者密码错误，防止被别人猜，前端根据后端提供的状态码重新定义输出提示内容，对用户来说特别的友好，不论后端给前端什么样的接口内容，前端都可以包装接口，所以后端只要返回给前端数据就可以了，接口的定义前端自己可以进行包装。</p></blockquote><h1 class=pgc-h-arrow-right><strong>四、总结</strong></h1><p style=text-align:start>中间层已经为越来越多的大公司所应用，进入中间层后，前端能做的事情越来越多，将触角伸向了服务器，除了前后端分离外，还能做redis缓存，负载均衡策略。另一方面，不止是Node.js能做中间层，PHP也可以，因为Node.js是用js写的，Node.js的生态很成熟，对于前端人员来说，比较容易上手。</p><p style=text-align:start>Web端的开发团队是需求链中的最上游、数据链的下游，很多产品功能都受限于业务接口，中间层提供了一种可能，让我们Web前端开发工作有了自己的接口开发能力可以对接最原始数据，既减少了前端开发中的局限性，也让前端团队在开发过程中有了更多的想象力，能更好的根据业务需要快速开展项目。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Nodejs','Web','架构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>