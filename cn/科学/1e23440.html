<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数学建模三剑客MSN | CSDN博文精选 | 极客快訊</title><meta property="og:title" content="数学建模三剑客MSN | CSDN博文精选 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RllTHQJ5wplDWH"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/1e23440.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/1e23440.html><meta property="article:published_time" content="2020-10-29T21:02:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:02:27+08:00"><meta name=Keywords content><meta name=description content="数学建模三剑客MSN | CSDN博文精选"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/1e23440.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数学建模三剑客MSN | CSDN博文精选</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>作者 | 天元浪子</p><p>来源 | CSDN博文精选</p><p><strong class=highlight-text toutiao-origin=span>(*点击阅读原文，查看作者更多精彩文章）</strong></p><p><strong class=highlight-text toutiao-origin=span>1.前言</strong></p><p><strong class=highlight-text toutiao-origin=span>2.三剑客之Numpy</strong></p><p><strong>2.1 数组对象</strong></p><p>2.1.1 数据类型</p><p>2.1.2 创建数组</p><p>2.1.3 构造复杂数组</p><p>2.1.3.1 重复数组: tile</p><p>2.1.3.2 重复元素: repeat</p><p>2.1.3.3 一维数组网格化: meshgrid</p><p>2.1.3.4 指定范围和分割方式的网格化: mgrid</p><p>2.1.4 数组的属性</p><p>2.1.5 改变数组维度</p><p>2.1.6 索引和切片</p><p>2.1.7 数组合并</p><p>2.1.8 数组拆分</p><p>2.1.9 数组运算</p><p>2.1.10 数组方法和常用函数</p><p><strong>2.2 矩阵对象</strong></p><p>2.2.1 创建矩阵</p><p>2.2.2 矩阵的特有属性</p><p>2.2.3 矩阵乘法</p><p><strong>2.3 线性代数模块</strong></p><p>2.3.1 计算逆矩阵</p><p>2.3.2 计算行列式</p><p>2.3.3 计算特征值和特征向量</p><p>2.3.4 求解线性方程组</p><p><strong class=highlight-text toutiao-origin=span>3.三剑客之Matplotlib</strong></p><p><strong>3.1 pylot介绍</strong></p><p>3.1.1 中文显示问题的解决方案</p><p>3.1.2 绘制最简单的图形</p><p>3.1.3 设置标题、座标轴名称、座标轴范围</p><p>3.1.4 设置点和线的样式、宽度、颜色</p><p>3.1.5 文本标注和图例</p><p><strong>3.2 绘制多轴图</strong></p><p><strong>3.3 常用绘图类型</strong></p><p>3.3.1 直方图</p><p>3.3.2 散点图</p><p>3.3.3 梯形图、柱状图、填充图</p><p>3.3.4 对数座标</p><p>3.3.5极座标绘图</p><p><strong>3.4 2D绘图</strong></p><p>3.4.1 等值线图</p><p>3.4.2 二维数据的平面色彩显示</p><p><strong>3.5 3D绘图</strong></p><p><strong class=highlight-text toutiao-origin=span>4.三剑客之Scipy</strong></p><p><strong>4.1 插值</strong></p><p>4.1.1 一维插值</p><p>4.1.2 二维插值</p><p><strong>4.2 拟合</strong></p><p>4.2.1 使用numpy.polyfit拟合</p><p>4.2.2 使用scipy.optimize.optimize.curve_fit拟合</p><p><strong>4.3 求解非线性方程（组）</strong></p><p><strong>4.4 数值积分</strong></p><p>4.4.1 经典微分法</p><p>4.4.2 使用定积分求解函数</p><p><strong>4.5 图像处理</strong></p><p><strong class=highlight-text toutiao-origin=span>5.后记</strong></p><p><strong class=highlight-text toutiao-origin=span>1.前言</strong></p><p>不管是不是巴萨的球迷，只要你喜欢足球，就一定听说过梅西(Messi)、苏亚雷斯(Suarez)和内马尔(Neymar)这个MSN组合。在众多的数学建模辅助工具中，也有一个犀利无比的MSN组合，他们就是python麾下大名鼎鼎的 Matplotlib + Scipy + Numpy三剑客。</p><p>本文是我整理的MSN学习笔记，有些理解可能比较肤浅，甚至是错误的。如果因此误导了某位看官，在工作中造成重大失误或损失，我顶多只能赔偿一顿饭——还得是我们楼下的十元盒饭。特此声明。</p><p>文中代码均从我的这台时不时出点问题、闹个情绪的Yoga 3 pro上覆制而来，这意味着所有的代码均可在下面的运行环境中顺利运行：</p><blockquote class=pgc-blockquote-abstract toutiao-origin=blockquote><div><div><p>pyhton 2.7.8</p><p>numpy 1.11.1</p><p>scipy 0.16.1</p><p>matplotlib 1.5.1</p></div></div></blockquote><p><strong class=highlight-text toutiao-origin=span>2.三剑客之Numpy</strong></p><p>numpy是一个开源的python科学计算库，包含了很多实用的数学函数，涵盖线性代数、傅里叶变换和随机数生成等功能。最初的numpy其实是scipy的一部分，后来才从scipy中分离出来。</p><p>numpy不是python的标准库，需要单独安装。假定你的运行环境已经安装了python包管理工具pip，numpy的安装就非常简单：</p><pre><div><p>pip install numpy</p></div></pre><p><strong class=highlight-text toutiao-origin=span>2.1 数组对象</strong></p><p>ndarray是多维数组对象，也是numpy最核心的对象。在numpy中，数组的维度(dimensions)叫做轴(axes)，轴的个数叫做秩(rank)。通常，一个numpy数组的所有元素都是同一种类型的数据，而这些数据的存储和数组的形式无关。</p><p>下面的例子，创建了一个三维的数组（在导入numpy时，一般都简写成np）。</p><pre><div><p>import numpy as np</p><p>a = np.array([[1,2,3],[4,5,6],[7,8,9]])</p></div></pre><p><strong>2.1.1 数据类型</strong></p><p>numpy支持的数据类型主要有布尔型(bool)、整型(integrate)、浮点型(float)和复数型(complex)，每一种数据类型根据占用内存的字节数又分为多个不同的子类型。常见的数据类型见下表。</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTHQJ5wplDWH><p><strong>2.1.2 创建数组</strong></p><p>通常，我们用np.array创建数组。如果仅仅是创建一维数组，也可以使用np.arange或者np.linspace的方法。np.zeros、np.ones、np.eye则可以构造特殊的数据。np.random.randint和np.random.random则可以构造随机数数组。</p><pre><div><p>&gt;&gt;&gt; np.array([[1,2,3],[4,5,6]]) # 默认元素类型为int32</p><p>array([[1, 2, 3],</p><p>[4, 5, 6]])</p><p>&gt;&gt;&gt; np.array([[1,2,3],[4,5,6]], dtype=np.int8) # 指定元素类型为int8</p><p>array([[1, 2, 3],</p><p>[4, 5, 6]], dtype=int8)</p><p>&gt;&gt;&gt; np.arange(5) # 默认元素类型为int32</p><p>array([0, 1, 2, 3, 4])</p><p>&gt;&gt;&gt; np.arange(3,8, dtype=np.int8) # 指定元素类型为int8</p><p>array([3, 4, 5, 6, 7], dtype=int8)</p><p>&gt;&gt;&gt; np.arange(12).reshape(3,4) # 改变shape</p><p>array([[ 0, 1, 2, 3],</p><p>[ 4, 5, 6, 7],</p><p>[ 8, 9, 10, 11]])</p><p>&gt;&gt;&gt; np.linspace(1,2,5) # 从1到2生成5个浮点数</p><p>array([ 1. , 1.25, 1.5 , 1.75, 2. ])</p><p>&gt;&gt;&gt; np.zeros((2,3)) # 全0数组</p><p>array([[ 0., 0., 0.],</p><p>[ 0., 0., 0.]])</p><p>&gt;&gt;&gt; np.ones((2,3)) # 全1数组</p><p>array([[ 1., 1., 1.],</p><p>[ 1., 1., 1.]])</p><p>&gt;&gt;&gt; np.eye(3) # 主对角线元素为1其他元素为0</p><p>array([[ 1., 0., 0.],</p><p>[ 0., 1., 0.],</p><p>[ 0., 0., 1.]])</p><p>&gt;&gt;&gt; np.random.random((2,3)) # 生成[0,1)之间的随机浮点数</p><p>array([[ 0.84731148, 0.8222318 , 0.85799278],</p><p>[ 0.59371558, 0.92330741, 0.04518351]])</p><p>&gt;&gt;&gt; np.random.randint(0,10,(3,2)) # 生成[0,10)之间的随机整数</p><p>array([[2, 4],</p><p>[8, 3],</p><p>[8, 5]])</p></div></pre><p><strong>2.1.3 构造复杂数组</strong></p><p>很多时候，我们需要从简单的数据结构，构造出复杂的数组。例如，用一维的数据生成二维格点。</p><p>2.1.3.1 重复数组: tile</p><pre><div><p>&gt;&gt;&gt; a = np.arange(5)</p><p>&gt;&gt;&gt; a</p><p>array([0, 1, 2, 3, 4])</p><p>&gt;&gt;&gt; np.tile(a, 2)</p><p>array([0, 1, 2, 3, 4, 0, 1, 2, 3, 4])</p><p>&gt;&gt;&gt; np.tile(a, (3,2))</p><p>array([[0, 1, 2, 3, 4, 0, 1, 2, 3, 4],</p><p>[0, 1, 2, 3, 4, 0, 1, 2, 3, 4],</p><p>[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]])</p></div></pre><p>2.1.3.2 重复元素: repeat</p><pre><div><p>&gt;&gt;&gt; a = np.arange(5)</p><p>&gt;&gt;&gt; a</p><p>array([0, 1, 2, 3, 4])</p><p>&gt;&gt;&gt; a.repeat(2)</p><p>array([0, 0, 1, 1, 2, 2, 3, 3, 4, 4])</p></div></pre><p>2.1.3.3 一维数组网格化: meshgrid</p><pre><div><p>&gt;&gt;&gt; a = np.arange(5)</p><p>&gt;&gt;&gt; b = np.arange(5,10)</p><p>&gt;&gt;&gt; np.meshgrid(a,b)</p><p>[array([[0, 1, 2, 3, 4],</p><p>[0, 1, 2, 3, 4],</p><p>[0, 1, 2, 3, 4],</p><p>[0, 1, 2, 3, 4],</p><p>[0, 1, 2, 3, 4]]), array([[5, 5, 5, 5, 5],</p><p>[6, 6, 6, 6, 6],</p><p>[7, 7, 7, 7, 7],</p><p>[8, 8, 8, 8, 8],</p><p>[9, 9, 9, 9, 9]])]</p><p>&gt;&gt;&gt; </p></div></pre><p>2.1.3.4 指定范围和分割方式的网格化: mgrid</p><pre><div><p>&gt;&gt;&gt; np.mgrid[0:1:2j, 1:2:3j]</p><p>array([[[ 0. , 0. , 0. ],</p><p>[ 1. , 1. , 1. ]],</p><p>[[ 1. , 1.5, 2. ],</p><p>[ 1. , 1.5, 2. ]]])</p><p>&gt;&gt;&gt; np.mgrid[0:1:0.3, 1:2:0.4]</p><p>array([[[ 0. , 0. , 0. ],</p><p>[ 0.3, 0.3, 0.3],</p><p>[ 0.6, 0.6, 0.6],</p><p>[ 0.9, 0.9, 0.9]],</p><p>[[ 1. , 1.4, 1.8],</p><p>[ 1. , 1.4, 1.8],</p><p>[ 1. , 1.4, 1.8],</p><p>[ 1. , 1.4, 1.8]]])</p></div></pre><p>上面的例子中用到了虚数。构造虚数的方法如下：</p><pre><div><p>&gt;&gt;&gt; complex(2,5)</p><p>(2+5j)</p></div></pre><p><strong>2.1.4 数组的属性</strong></p><p>numpy的数组对象除了一些常规的属性外，也有几个类似转置、扁平迭代器等看起来更像是方法的属性。扁平迭代器也许是遍历多维数组的一个简明方法，下面的代码给出了一个例子。</p><pre><div><p>&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])</p><p>&gt;&gt;&gt; a.dtype # 数组元素的数据类型</p><p>dtype('int32')</p><p>&gt;&gt;&gt; a.dtype.itemsize # 数组元素占据的内存字节数</p><p>4</p><p>&gt;&gt;&gt; a.itemsize # 数组元素占据的内存字节数</p><p>4</p><p>&gt;&gt;&gt; a.shape # 数组的维度</p><p>(2, 3)</p><p>&gt;&gt;&gt; a.size # 数组元素个数</p><p>6</p><p>&gt;&gt;&gt; a.T # 数组行变列，类似于transpose</p><p>array([[1, 4],</p><p>[2, 5],</p><p>[3, 6]])</p><p>&gt;&gt;&gt; a.flat # 返回一个扁平迭代器，用于遍历多维数组</p><p>&lt;numpy.flatiter object at 0x037188F0&gt;</p><p>&gt;&gt;&gt; for item in a.flat:</p><p>print item</p></div></pre><p><strong>2.1.5 改变数组维度</strong></p><p>numpy数组的存储顺序和数组的维度是不相干的，因此改变数组的维度是非常便捷的操作，除resize外，这一类操作不会改变所操作的数组本身的存储顺序。</p><pre><div><p>&gt;&gt;&gt; a = np.array([[1,2,3],[4,5,6]])</p><p>&gt;&gt;&gt; a.shape # 查看数组维度</p><p>(2, 3)</p><p>&gt;&gt;&gt; a.reshape(3,2) # 返回3行2列的数组</p><p>array([[1, 2],</p><p>[3, 4],</p><p>[5, 6]])</p><p>&gt;&gt;&gt; a.ravel # 返回一维数组</p><p>array([1, 2, 3, 4, 5, 6])</p><p>&gt;&gt;&gt; a.transpose # 行变列（类似于矩阵转置）</p><p>array([[1, 4],</p><p>[2, 5],</p><p>[3, 6]])</p><p>&gt;&gt;&gt; a.resize((3,2)) # 类似于reshape，但会改变所操作的数组</p><p>&gt;&gt;&gt; a</p><p>array([[1, 2],</p><p>[3, 4],</p><p>[5, 6]])</p></div></pre><p><strong>2.1.6 索引和切片</strong></p><p>对于一维数组的索引和切片，numpy和python的list一样，甚至更灵活。</p><pre><div><p>a = np.arange(9)</p><p>&gt;&gt;&gt; a[-1] # 最后一个元素</p><p>8</p><p>&gt;&gt;&gt; a[2:5] # 返回第2到第5个元素</p><p>array([2, 3, 4])</p><p>&gt;&gt;&gt; a[:7:3] # 返回第0到第7个元素，步长为3</p><p>array([0, 3, 6])</p><p>&gt;&gt;&gt; a[::-1] # 返回逆序的数组</p><p>array([8, 7, 6, 5, 4, 3, 2, 1, 0])</p></div></pre><p>假设有一栋2层楼，每层楼内的房间都是3排4列，那我们可以用一个三维数组来保存每个房间的居住人数（当然，也可以是房间面积等其他数值信息）。</p><pre><div><p>&gt;&gt;&gt; a = np.arange(24).reshape(2,3,4) # 2层3排4列</p><p>&gt;&gt;&gt; a</p><p>array([[[ 0, 1, 2, 3],</p><p>[ 4, 5, 6, 7],</p><p>[ 8, 9, 10, 11]],</p><p>[[12, 13, 14, 15],</p><p>[16, 17, 18, 19],</p><p>[20, 21, 22, 23]]])</p><p>&gt;&gt;&gt; a[1][2][3] # 虽然可以这样</p><p>23</p><p>&gt;&gt;&gt; a[1,2,3] # 但这才是规范的用法</p><p>23</p><p>&gt;&gt;&gt; a[:,0,0] # 所有楼层的第1排第1列</p><p>array([ 0, 12])</p><p>&gt;&gt;&gt; a[0,:,:] # 1楼的所有房间，等价与a[0]或a[0,...]</p><p>array([[ 0, 1, 2, 3],</p><p>[ 4, 5, 6, 7],</p><p>[ 8, 9, 10, 11]])</p><p>&gt;&gt;&gt; a[:,:,1:3] # 所有楼层所有排的第2到4列</p><p>array([[[ 1, 2],</p><p>[ 5, 6],</p><p>[ 9, 10]],</p><p>[[13, 14],</p><p>[17, 18],</p><p>[21, 22]]])</p><p>&gt;&gt;&gt; a[1,:,-1] # 2层每一排的最后一个房间</p><p>array([15, 19, 23])</p></div></pre><p><strong>2.1.7 数组合并</strong></p><p>数组合并除了下面介绍的水平合并、垂直合并、深度合并外，还有行合并、列合并，以及concatenate等方式。假如你比我还懒，那就只了解前三种方法吧，足够用了。</p><pre><div><p>&gt;&gt;&gt; a = np.arange(9).reshape(3,3)</p><p>&gt;&gt;&gt; b = np.arange(9,18).reshape(3,3)</p><p>&gt;&gt;&gt; a</p><p>array([[0, 1, 2],</p><p>[3, 4, 5],</p><p>[6, 7, 8]])</p><p>&gt;&gt;&gt; b</p><p>array([[ 9, 10, 11],</p><p>[12, 13, 14],</p><p>[15, 16, 17]])</p><p>&gt;&gt;&gt; np.hstack((a,b)) # 水平合并</p><p>array([[ 0, 1, 2, 9, 10, 11],</p><p>[ 3, 4, 5, 12, 13, 14],</p><p>[ 6, 7, 8, 15, 16, 17]])</p><p>&gt;&gt;&gt; np.vstack((a,b)) # 垂直合并</p><p>array([[ 0, 1, 2],</p><p>[ 3, 4, 5],</p><p>[ 6, 7, 8],</p><p>[ 9, 10, 11],</p><p>[12, 13, 14],</p><p>[15, 16, 17]])</p><p>&gt;&gt;&gt; np.dstack((a,b)) # 深度合并</p><p>array([[[ 0, 9],</p><p>[ 1, 10],</p><p>[ 2, 11]],</p><p>[[ 3, 12],</p><p>[ 4, 13],</p><p>[ 5, 14]],</p><p>[[ 6, 15],</p><p>[ 7, 16],</p><p>[ 8, 17]]])</p></div></pre><p><strong>2.1.8 数组拆分</strong></p><p>拆分是合并的逆过程，概念是一样的，但稍微有一点不同：</p><pre><div><p>&gt;&gt;&gt; a = np.arange(9).reshape(3,3)</p><p>&gt;&gt;&gt; np.hsplit(a, 3) # 水平拆分，返回list</p><p>[array([[0],</p><p>[3],</p><p>[6]]), array([[1],</p><p>[4],</p><p>[7]]), array([[2],</p><p>[5],</p><p>[8]])]</p><p>&gt;&gt;&gt; np.vsplit(a, 3) # 垂直拆分，返回list</p><p>[array([[0, 1, 2]]), array([[3, 4, 5]]), array([[6, 7, 8]])]</p><p>&gt;&gt;&gt; a = np.arange(27).reshape(3,3,3)</p><p>&gt;&gt;&gt; np.dsplit(a, 3) # 深度拆分，返回list</p><p>[array([[[ 0],</p><p>[ 3],</p><p>[ 6]],</p><p>[[ 9],</p><p>[12],</p><p>[15]],</p><p>[[18],</p><p>[21],</p><p>[24]]]), array([[[ 1],</p><p>[ 4],</p><p>[ 7]],</p><p>[[10],</p><p>[13],</p><p>[16]],</p><p>[[19],</p><p>[22],</p><p>[25]]]), array([[[ 2],</p><p>[ 5],</p><p>[ 8]],</p><p>[[11],</p><p>[14],</p><p>[17]],</p><p>[[20],</p><p>[23],</p><p>[26]]])]</p></div></pre><p><strong>2.1.9 数组运算</strong></p><p>数组和常数的四则运算，是数组的每一个元素分别和常数运算；数组和数组的四则运算则是两个数组对应元素的运算（两个数组有相同的shape，否则抛出异常）。</p><pre><div><p>&gt;&gt;&gt; a = np.arange(4, dtype=np.float32).reshape(2,2)</p><p>&gt;&gt;&gt; b = np.arange(4, 8, dtype=np.float32).reshape(2,2)</p><p>&gt;&gt;&gt; a+2 # 数组和常数可以进行四则运算</p><p>array([[ 2., 3.],</p><p>[ 4., 5.]], dtype=float32)</p><p>&gt;&gt;&gt; a/b # 数组和数组可以进行四则运算</p><p>array([[ 0. , 0.2 ],</p><p>[ 0.33333334, 0.42857143]], dtype=float32) </p><p>&gt;&gt;&gt; a == b # 最神奇的是，数组可以判断对应元素是否相等</p><p>array([[False, False],</p><p>[False, False]], dtype=bool)</p><p>&gt;&gt;&gt; (a == b).all # 判断数组是否相等</p><p>False</p></div></pre><p>特别提示：如果想对数组内符合特定条件的元素做特殊处理，下面的代码也许有用。</p><pre><div><p>&gt;&gt;&gt; a = np.arange(6).reshape((2,3))</p><p>&gt;&gt;&gt; a</p><p>array([[0, 1, 2],</p><p>[3, 4, 5]])</p><p>&gt;&gt;&gt; (a&gt;2)&amp;(a&lt;=4)</p><p>array([[False, False, False],</p><p>[ True, True, False]], dtype=bool)</p><p>&gt;&gt;&gt; a[(a&gt;2)&amp;(a&lt;=4)]</p><p>array([3, 4])</p><p>&gt;&gt;&gt; a[(a&gt;2)&amp;((a&lt;=4))] += 10</p><p>&gt;&gt;&gt; a</p><p>array([[ 0, 1, 2],</p><p>[13, 14, 5]])</p></div></pre><p><strong>2.1.10 数组方法和常用函数</strong></p><p>数组对象本身提供了计算算数平均值、求最大最小值等内置方法，numpy也提供了很多实用的函数。为了缩减篇幅，下面的代码仅以一维数组为例，展示了这些方法和函数用法。事实上，大多数情况下这些方法和函数对于多维数组同样有效，只有少数例外，比如compress函数。</p><pre><div><p>&gt;&gt;&gt; a = np.array([3,2,4])</p><p>&gt;&gt;&gt; a.sum # 所有元素的和</p><p>9</p><p>&gt;&gt;&gt; a.prod # 所有元素的乘积</p><p>24</p><p>&gt;&gt;&gt; a.mean # 所有元素的算数平均值</p><p>3.0</p><p>&gt;&gt;&gt; a.max # 所有元素的最大值</p><p>4</p><p>&gt;&gt;&gt; a.min # 所有元素的最小值</p><p>2</p><p>&gt;&gt;&gt; a.clip(3,4) # 小于3的元素替换为3，大于4的元素替换为4</p><p>array([3, 3, 4])</p><p>&gt;&gt;&gt; a.compress(a&gt;2) # 返回大于2的元素组成的数组</p><p>array([3, 4])</p><p>&gt;&gt;&gt; a.tolist # 返回python的list</p><p>[3, 2, 4]</p><p>&gt;&gt;&gt; a.var # 计算方差（元素与均值之差的平方的均值）</p><p>0.66666666666666663</p><p>&gt;&gt;&gt; a.std # 计算标准差（方差的算术平方根）</p><p>0.81649658092772603</p><p>&gt;&gt;&gt; a.ptp # 返回数组的最大值和最小值之差</p><p>2</p><p>&gt;&gt;&gt; a.argmin # 返回最小值在扁平数组中的索引</p><p>1</p><p>&gt;&gt;&gt; a.argmax # 返回最大值在扁平数组中的索引</p><p>2</p><p>&gt;&gt;&gt; np.where(a == 2) # 返回所有值为2的元素的索引</p><p>(array([1]),)</p><p>&gt;&gt;&gt; np.diff(a) # 返回相邻元素的差</p><p>array([-1, 2])</p><p>&gt;&gt;&gt; np.log(a) # 返回对数数组</p><p>array([ 1.09861229, 0.69314718, 1.38629436])</p><p>&gt;&gt;&gt; np.exp(a) # 返回指数数组</p><p>array([ 20.08553692, 7.3890561 , 54.59815003])</p><p>&gt;&gt;&gt; np.sqrt(a) # 返回开方数组</p><p>array([ 1.73205081, 1.41421356, 2. ])</p><p>&gt;&gt;&gt; np.msort(a) # 数组排序</p><p>array([2, 3, 4])</p><p>&gt;&gt;&gt; a = np.array([1,4,7])</p><p>&gt;&gt;&gt; b = np.array([8,5,2])</p><p>&gt;&gt;&gt; np.maximum(a, b) # 返回多个数组中对应位置元素的最大值数组</p><p>array([8, 5, 7])</p><p>&gt;&gt;&gt; np.minimum(a, b) # 返回多个数组中对应位置元素的最小值数组</p><p>array([1, 4, 2])</p><p>&gt;&gt;&gt; np.true_divide(a, b) # 对整数实现真正的数学除法运算</p><p>array([ 0.125, 0.8 , 3.5 ])</p></div></pre><p><strong class=highlight-text toutiao-origin=span>2.2 矩阵对象</strong></p><p>matrix是矩阵对象，继承自ndarray类型，因此含有ndarray的所有数据属性和方法。不过，当你把矩阵对象当数组操作时，需要注意以下几点：</p><p>matrix对象总是二维的，即使是展平（ravel函数）操作或是成员选择，返回值也是二维的。</p><p>matrix对象和ndarray对象混合的运算总是返回matrix对象。</p><p><strong>2.2.1 创建矩阵</strong></p><p>matrix对象可以使用一个Matlab风格的字符串来创建（以空格分隔列，以分号分隔行的字符串），也可以用数组来创建。</p><pre><div><p>&gt;&gt;&gt; np.mat('1 4 7; 2 5 8; 3 6 9')</p><p>matrix([[1, 4, 7],</p><p>[2, 5, 8],</p><p>[3, 6, 9]])</p><p>&gt;&gt;&gt; np.mat(np.arange(1,10).reshape(3,3))</p><p>matrix([[1, 2, 3],</p><p>[4, 5, 6],</p><p>[7, 8, 9]])</p></div></pre><p><strong>2.2.2 矩阵的特有属性</strong></p><p>矩阵有几个特有的属性使得计算更加容易，这些属性有：</p><pre><div><p>&gt;&gt;&gt; m = np.mat(np.arange(1,10).reshape(3,3))</p><p>&gt;&gt;&gt; m</p><p>matrix([[1, 2, 3],</p><p>[4, 5, 6],</p><p>[7, 8, 9]])</p><p>&gt;&gt;&gt; m.T # 返回自身的转置</p><p>matrix([[1, 4, 7],</p><p>[2, 5, 8],</p><p>[3, 6, 9]])</p><p>&gt;&gt;&gt; m.H # 返回自身的共轭转置</p><p>matrix([[1, 4, 7],</p><p>[2, 5, 8],</p><p>[3, 6, 9]])</p><p>&gt;&gt;&gt; m.I # 返回自身的逆矩阵</p><p>matrix([[ -4.50359963e+15, 9.00719925e+15, -4.50359963e+15],</p><p>[ 9.00719925e+15, -1.80143985e+16, 9.00719925e+15],</p><p>[ -4.50359963e+15, 9.00719925e+15, -4.50359963e+15]])</p><p>&gt;&gt;&gt; m.A # 返回自身数据的二维数组的一个视图</p><p>array([[1, 2, 3],</p><p>[4, 5, 6],</p><p>[7, 8, 9]])</p></div></pre><p><strong>2.2.3 矩阵乘法</strong></p><p>对ndarray对象而言，星号是按元素相乘，dot函数则当作矩阵相乘。对于matrix对象来说，星号和dot函数都是矩阵相乘。特别的，对于一维数组，dot函数实现的是向量点乘（结果是标量），但星号实现的却不是差乘。</p><pre><div><p>&gt;&gt;&gt; a = np.array([1,2,3])</p><p>&gt;&gt;&gt; b = np.array([4,5,6])</p><p>&gt;&gt;&gt; a*b # 一维数组，元素相乘</p><p>array([ 4, 10, 18])</p><p>&gt;&gt;&gt; np.dot(a,b) # 一维数组，元素相乘再求和</p><p>32</p><p>&gt;&gt;&gt; a = np.array([[1,2],[3,4]])</p><p>&gt;&gt;&gt; b = np.array([[5,6],[7,8]])</p><p>&gt;&gt;&gt; a*b # 多维数组，元素相乘</p><p>array([[ 5, 12],</p><p>[21, 32]])</p><p>&gt;&gt;&gt; np.dot(a,b) # 多维数组，实现的是矩阵相乘</p><p>array([[19, 22],</p><p>[43, 50]])</p><p>&gt;&gt;&gt; m = np.mat(a)</p><p>&gt;&gt;&gt; n = np.mat(b)</p><p>&gt;&gt;&gt; np.dot(m,n) # 矩阵相乘</p><p>matrix([[19, 22],</p><p>[43, 50]])</p><p>&gt;&gt;&gt; m*n # 矩阵相乘</p><p>matrix([[19, 22],</p><p>[43, 50]])</p></div></pre><p><strong class=highlight-text toutiao-origin=span>2.3 线性代数模块</strong></p><p>numpy.linalg 是numpy的线性代数模块，可以用来解决逆矩阵、特征值、线性方程组以及行列式等问题。</p><p><strong>2.3.1 计算逆矩阵</strong></p><p>尽管matrix对象本身有逆矩阵的属性，但用numpy.linalg模块求解矩阵的逆，也是非常简单的。</p><pre><div><p>m = np.mat('0 1 2; 1 0 3; 4 -3 8')</p><p>mi = np.linalg.inv(m) # mi即为m的逆矩阵。何以证明？</p><p>m * mi # 矩阵与其逆矩阵相乘，结果为单位矩阵</p><p>matrix([[ 1., 0., 0.],</p><p>[ 0., 1., 0.],</p><p>[ 0., 0., 1.]])</p></div></pre><p><strong>2.3.2 计算行列式</strong></p><p>如何计算行列式，我早已经不记得了，但手工计算行列式的痛苦，我依然记忆犹新。现在好了，你在手机上都可以用numpy轻松搞定（前提是你的手机上安装了python + numpy）。</p><pre><div><p>m = np.mat('0 1 2; 1 0 3; 4 -3 8')</p><p>np.linalg.det(m) # 什么？这就成了？</p><p>2.0</p></div></pre><p><strong>2.3.3 计算特征值和特征向量</strong></p><p>截至目前，我的工作和特征值、特征向量还有没任何关联。记录这一节，纯粹是为了我女儿，她正在读数学专业。</p><pre><div><p>m = np.mat('0 1 2; 1 0 3; 4 -3 8')</p><p>&gt;&gt;&gt; np.linalg.eigvals(m) # 计算特征值</p><p>array([ 7.96850246, -0.48548592, 0.51698346])</p><p>&gt;&gt;&gt; np.linalg.eig(m) # 返回特征值及其对应特征向量的元组</p><p>(array([ 7.96850246, -0.48548592, 0.51698346]), matrix([[ 0.26955165, 0.90772191, -0.74373492],</p><p>[ 0.36874217, 0.24316331, -0.65468206],</p><p>[ 0.88959042, -0.34192476, 0.13509171]]))</p></div></pre><p><strong>2.3.4 求解线性方程组</strong></p><p>有线性方程组如下：</p><blockquote><div><div><p>x - 2y + z = 0</p><p>2y -8z = 8</p><p>-4x + 5y + 9z = -9</p></div></div></blockquote><p>求解过程如下：</p><pre><div><p>&gt;&gt;&gt; A = np.mat('1 -2 1; 0 2 -8; -4 5 9')</p><p>&gt;&gt;&gt; b = np.array([0, 8, -9])</p><p>&gt;&gt;&gt; np.linalg.solve(A, b)</p><p>array([ 29., 16., 3.]) # x = 29, y = 16, z = 3</p></div></pre><p><strong class=highlight-text toutiao-origin=span>3.三剑客之Matplotlib</strong></p><p>matplotlib 是python最著名的绘图库，它提供了一整套和Matlab相似的命令API，十分适合交互式地进行制图。而且也可以方便地将它作为绘图控件，嵌入GUI应用程序中。matplotlib 可以绘制多种形式的图形包括普通的线图，直方图，饼图，散点图以及误差线图等；可以比较方便的定制图形的各种属性比如图线的类型，颜色，粗细，字体的大小等；它能够很好地支持一部分 TeX 排版命令，可以比较美观地显示图形中的数学公式。</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTHQvCCi8xqM><p><strong class=highlight-text toutiao-origin=span>3.1 pylot介绍</strong></p><p>Matplotlib 包含了几十个不同的模块， 如 matlab、mathtext、finance、dates 等，而 pylot 则是我们最常用的绘图模块，这也是本文介绍的重点。</p><p><strong>3.1.1 中文显示问题的解决方案</strong></p><p>有很多方法可以解决此问题，但下面的方法恐怕是最简单的解决方案了（我只在windows平台上测试过，其他平台请看官自测）。如果想了解更多，也可以参考我N年前的一篇博文：matplotlib显示中文的解决方案（http://xufive.blog.163.com/blog/static/172326168201063111370141/）</p><pre><div><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; plt.rcParams['font.sans-serif'] = ['FangSong'] # 指定默认字体</p><p>&gt;&gt;&gt; plt.rcParams['axes.unicode_minus'] = False # 解决保存图像时'-'显示为方块的问题</p></div></pre><p><strong>3.1.2 绘制最简单的图形</strong></p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; x = np.arange(0, 2*np.pi, 0.01)</p><p>&gt;&gt;&gt; y = np.sin(x)</p><p>&gt;&gt;&gt; plt.plot(x, y)</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTHRPHFHLY7E><p><strong>3.1.3 设置标题、座标轴名称、座标轴范围</strong></p><p>如果你在python的shell中运行下面的代码，而shell的默认编码又不是utf-8的话，中文可能仍然会显示为乱码。你可以尝试着把 u’正弦曲线’ 写成 ‘正弦曲线’.decode(‘gbk’)或者’正弦曲线’.decode(‘utf-8’)</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; from pylab import mpl</p><p>&gt;&gt;&gt; mpl.rcParams['font.sans-serif'] = ['FangSong']</p><p>&gt;&gt;&gt; mpl.rcParams['axes.unicode_minus'] = False</p><p>&gt;&gt;&gt; x = np.arange(0, 2*np.pi, 0.01)</p><p>&gt;&gt;&gt; y = np.sin(x)</p><p>&gt;&gt;&gt; plt.plot(x, y)</p><p>&gt;&gt;&gt; plt.title(u'正弦曲线', fontdict={'size':20}) # 设置标题</p><p>&gt;&gt;&gt; plt.xlabel(u'弧度', fontdict={'size':16}) # 显示横轴名称</p><p>&gt;&gt;&gt; plt.ylabel(u'正弦值', fontdict={'size':16}) # 显示纵轴名称</p><p>&gt;&gt;&gt; plt.axis([-0.1*np.pi, 2.1*np.pi, -1.1, 1.1]) # 设置座标轴范围</p><p>&gt;&gt;&gt; plt.axis('equal') # xy轴等比例保持</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTHRoJFpqABp><p><strong>3.1.4 设置点和线的样式、宽度、颜色</strong></p><p>plt.plot函数的调用形式如下：</p><pre><div><p>plot(x, y, color='green', linestyle='dashed', linewidth=1, marker='o', markerfacecolor='blue', markersize=6)</p><p>plot(x, y, c='g', ls='--', lw=1, marker='o', mfc='blue', ms=6)</p></div></pre><p>color指定线的颜色，可简写为“c”。颜色的选项为：</p><ul><li><p>蓝色：‘b’ (blue)</p></li><li><p>绿色：‘g’ (green)</p></li><li><p>红色：‘r’ (red)</p></li><li><p>墨绿：‘c’ (cyan)</p></li><li><p>洋红：‘m’ (magenta)</p></li><li><p>黄色：‘y’ (yellow)</p></li><li><p>黑色：‘k’ (black)</p></li><li><p>白色：‘w’ (white)</p></li><li><p>灰度表示：e.g. 0.75 ([0,1]内任意浮点数)</p></li><li><p>RGB表示法：e.g. ‘#2F4F4F’ 或 (0.18, 0.31, 0.31)</p></li></ul><p>linestyle指定线型，可简写为“ls”。线型的选项为：</p><ul><li><p>实线：‘-’ (solid line)</p></li><li><p>虚线：‘–’ (dashed line)</p></li><li><p>虚点线：‘-.’ (dash-dot line)</p></li><li><p>点线：‘:’ (dotted line)</p></li><li><p>无：'‘或’ ‘或’None’</p></li></ul><p>linewidth指定线宽，可简写为“lw”。</p><p>marker描述数据点的形状</p><ul><li><p>点线：‘.’</p></li><li><p>点线：‘o’</p></li><li><p>加号：'+</p></li><li><p>叉号：‘x’</p></li><li><p>上三角：‘^’</p></li><li><p>上三角：‘v’</p></li></ul><p>markerfacecolor指定数据点标记的表面颜色，可 简写为“ mfc”。</p><p>markersize指定数据点标记的大小，可 简写为“ ms”。</p><p><strong>3.1.5 文本标注和图例</strong></p><p>我们分别使用不同的线型、颜色来绘制以10、e、2为基的一组幂函数曲线，演示文本标注和图例的使用。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; from pylab import mpl</p><p>&gt;&gt;&gt; mpl.rcParams['font.sans-serif'] = ['FangSong']</p><p>&gt;&gt;&gt; mpl.rcParams['axes.unicode_minus'] = False</p><p>&gt;&gt;&gt; x = np.linspace(-4, 4, 200)</p><p>&gt;&gt;&gt; f1 = np.power(10, x)</p><p>&gt;&gt;&gt; f2 = np.power(np.e, x)</p><p>&gt;&gt;&gt; f3 = np.power(2, x)</p><p>&gt;&gt;&gt; plt.plot(x, f1, 'r', ls='-', linewidth=2, label='$10^x$')</p><p>&gt;&gt;&gt; plt.plot(x, f2, 'b', ls='--', linewidth=2, label='$e^x$')</p><p>&gt;&gt;&gt; plt.plot(x, f3, 'g', ls=':', linewidth=2, label='$2^x$')</p><p>&gt;&gt;&gt; plt.axis([-4, 4, -0.5, 8])</p><p>&gt;&gt;&gt; plt.text(1, 7.5, r'$10^x$', fontsize=16)</p><p>&gt;&gt;&gt; plt.text(2.2, 7.5, r'$e^x$', fontsize=16)</p><p>&gt;&gt;&gt; plt.text(3.2, 7.5, r'$2^x$', fontsize=16)</p><p>&gt;&gt;&gt; plt.title('幂函数曲线', fontsize=16)</p><p>&gt;&gt;&gt; plt.legend(loc='upper left')</p><p>&gt;&gt;&gt; plt.show</p></div></pre><p>在绘制图例时，loc用于指定图例的位置，可用的选项有：</p><ul><li><p>best</p></li><li><p>upper right</p></li><li><p>upper left</p></li><li><p>lower left</p></li><li><p>lower right</p></li></ul><p><strong class=highlight-text toutiao-origin=span>3.2 绘制多轴图</strong></p><p>在介绍如何将多幅子图绘制在同一画板的同时，顺便演示如何绘制直线和矩形。我们可以使用subplot函数快速绘制有多个轴的图表。subplot函数的调用形式如下：</p><pre><div><p>subplot(numRows, numCols, plotNum)</p></div></pre><p>subplot将整个绘图区域等分为numRows行 * numCols列个子区域，然后按照从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域的编号为1。如果numRows，numCols和plotNum这三个数都小于10的话，可以把它们缩写为一个整数，例如subplot(323)和subplot(3,2,3)是相同的。subplot在plotNum指定的区域中创建一个轴对象。如果新创建的轴和之前创建的轴重叠的话，之前的轴将被删除。</p><pre><div><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; plt.subplot(221) # 两行两列的第1个位置</p><p>&gt;&gt;&gt; plt.axis([-1, 2, -1, 2])</p><p>&gt;&gt;&gt; plt.axhline(y=0.5, color='b')</p><p>&gt;&gt;&gt; plt.axhline(y=0.5, xmin=0.25, xmax=0.75, color='r')</p><p>&gt;&gt;&gt; plt.subplot(222) # 两行两列的第2个位置</p><p>&gt;&gt;&gt; plt.axis([-1, 2, -1, 2])</p><p>&gt;&gt;&gt; plt.axvline(x=0, ymin=0, linewidth=4, color='r')</p><p>&gt;&gt;&gt; plt.axvline(x=1.0, ymin=-0.5, ymax=0.5, linewidth=4, color='g')</p><p>&gt;&gt;&gt; plt.subplot(212) # 两行一列的第2个位置</p><p>&gt;&gt;&gt; plt.axis([-1, 2, -1, 2])</p><p>&gt;&gt;&gt; plt.axvspan(1.25, 1.55, facecolor='g', alpha=0.5)</p><p>&gt;&gt;&gt; plt.axhspan(0.25, 0.75, facecolor='0.5', alpha=0.5)</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTI212B1X4ns><p><strong class=highlight-text toutiao-origin=span>3.3 常用绘图类型</strong></p><p><strong>3.3.1 直方图</strong></p><p>用numpy随机生成一个符合正态分布的数据集，统计分段区域内数据的个数。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; data = np.random.normal(5.0, 3.0, 1000)</p><p>&gt;&gt;&gt; plt.hist(data)</p><p>&gt;&gt;&gt; bins = np.arange(-5, 16, 1)</p><p>&gt;&gt;&gt; plt.hist(data, bins) # 使用自定义的分段区域</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTI2i2LpMSz1><p class=pgc-img-caption><strong>3.3.2 散点图</strong></p><p>使用plot绘图时，如果指定样式参数为仅绘制数据点（linestyle=‘None’），那么所绘制的就是一幅散列图。这种方法所绘制的点无法单独指定数据点的颜色和大小，而使用scatter绘制散列图就可以指定每个点的颜色和大小。</p><p>plt.scatter函数的调用形式如下：</p><pre><div><p>scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, verts=None, edgecolors=None, hold=None, data=None, **kwargs)</p></div></pre><p>scatter的前两个参数是数组，分别指定每个点的X轴和Y轴的座标。s参数指定点的大 小，值和点的面积成正比，它可以是一个数，指定所有点的大小，也可以是数组，分别对每个点指定大小。c参数指定每个点的颜色，可以是数值或数组。这里使用一维数组为每个点指定了一个数值。通过颜色映射表，每个数值都会与一个颜色相对应。默认的颜色映射表中蓝色与最小值对应，红色与最大值对应。当c参数是形状为(N,3)或(N,4)的二维数组时，则直接表示每个点的RGB颜色。marker参数设置点的形状，可以是个表示形状的字符串，也可以是表示多边形的两个元素的元组，第一个元素表示多边形的边数，第二个元素表示多边形的样式，取值范围为0、1、2、3。0表示多边形，1表示星形，2表示放射形，3表示忽略边数而显示为圆形。alpha参数设置点的透明度。facecolors参数为“none”时，表示散列点没有填充色。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; x = np.random.rand(50)</p><p>&gt;&gt;&gt; y = np.random.rand(50)</p><p>&gt;&gt;&gt; area = np.pi * (15 * np.random.rand(50))**2</p><p>&gt;&gt;&gt; color = 2 * np.pi * np.random.rand(50)</p><p>&gt;&gt;&gt; plt.scatter(x, y, s=area, c=color, alpha=0.5, cmap=plt.cm.hsv)</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTI3C5ImAQHx><p class=pgc-img-caption><strong>3.3.3 梯形图、柱状图、填充图</strong></p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; n = np.array([0,1,2,3,4,5])</p><p>&gt;&gt;&gt; x = np.linspace(-0.75, 1., 100)</p><p>&gt;&gt;&gt; plt.subplot(131)</p><p>&gt;&gt;&gt; plt.step(n, n**2, lw=2)</p><p>&gt;&gt;&gt; plt.subplot(132)</p><p>&gt;&gt;&gt; plt.bar(n, n**2, align="center", width=0.5, alpha=0.5)</p><p>&gt;&gt;&gt; plt.subplot(133)</p><p>&gt;&gt;&gt; plt.fill_between(x, x**2, x**3, color="green", alpha=0.5)</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTI3WBISN8q3><p><strong>3.3.4 对数座标</strong></p><p>plot所绘制图表的X-Y轴座标都是算术座标。绘制对数座标图的函数有三个：semilogx、semilogy和loglog,它们分别绘制X轴为对数座标、Y轴为对数座标以及两个轴都为对数座标时的图表。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; x = np.linspace(0, 3, 100)</p><p>&gt;&gt;&gt; y = np.power(2, np.power(2,x))</p><p>&gt;&gt;&gt; plt.subplot(121)</p><p>&gt;&gt;&gt; plt.semilogy(x, y , '-r')</p><p>&gt;&gt;&gt; plt.subplot(122)</p><p>&gt;&gt;&gt; plt.plot(x,y, '--g')</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTI3zBoRMmJo><p class=pgc-img-caption><strong>3.3.5极座标绘图</strong></p><p>极座标系是和笛卡尔(X-Y)座标系完全不同的座标系，极座标系中的点由一个夹角和一段相对中心点的距离来表示。polar(theta, r, **kwargs)可以直接创建极座标子图并在其中绘制曲线。也可以使用程序中调用subplot创建子图时通过设 polar参数为True,创建一个极座标子图，然后调用plot在极座标子图中绘图。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; theta = np.arange(0, 2*np.pi, 0.02)</p><p>&gt;&gt;&gt; plt.polar(theta, 1.4*np.cos(5*theta), "--", linewidth=2)</p><p>&gt;&gt;&gt; plt.polar(theta, 1.8*np.cos(4*theta), linewidth=2)</p><p>&gt;&gt;&gt; plt.rgrids(np.arange(0.5, 2, 0.5), angle=45)</p><p>&gt;&gt;&gt; plt.thetagrids([0, 45])thetagridlabel objects&gt;)</p><p>&gt;&gt;&gt; plt.show</p><p>&gt;&gt;&gt; </p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTIhLff3OSm><p><strong class=highlight-text toutiao-origin=span>3.4 2D绘图</strong></p><p><strong>3.4.1 等值线图</strong></p><p>所谓等值线，是指由函数值相等的各点连成的平滑曲线。等值线可以直观地表示二元函数值的变化趋势，例如等值线密集的地方表示函数值在此处的变化较大。matplotlib中可以使用contour和contourf描绘等值线，它们的区别是：contourf所得到的是带填充效果的等值线。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; y, x = np.ogrid[-2:2:200j, -3:3:300j]</p><p>&gt;&gt;&gt; z = x * np.exp( - x**2 - y**2)</p><p>&gt;&gt;&gt; extent = [np.min(x), np.max(x), np.min(y), np.max(y)]</p><p>&gt;&gt;&gt; plt.subplot(121)</p><p>&gt;&gt;&gt; cs = plt.contour(z, 10, extent=extent)</p><p>&gt;&gt;&gt; plt.clabel(cs)</p><p>&lt;a list of 8 text.Text objects&gt;</p><p>&gt;&gt;&gt; plt.subplot(122)</p><p>&gt;&gt;&gt; plt.contourf(x.reshape(-1), y.reshape(-1), z, 20)</p><p>&gt;&gt;&gt; plt.show</p></div></pre><p>为了更淸楚地区分X轴和Y轴，这里让它们的取值范围和等分次数均不相同.这样得 到的数组z的形状为(200, 300),它的第0轴对应Y轴、第1轴对应X轴。</p><p>调用contour绘制数组z的等值线图，第二个参数为10,表示将整个函数的取值范围等分为10个区间,即显示的等值线图中将有9条等值线。可以使用extent参数指定等值线图的X轴和Y轴的数据范围。</p><p>contour所返回的是一个QuadContourSet对象， 将它传递给clabel，为其中的等值线标上对应的值。</p><p>调用contourf,绘制将取值范围等分为20份、带填充效果的等值线图。这里演示了另外一种设置X、Y轴取值范围的方法，它的前两个参数分别是计算数组z时所使用的X轴和Y轴上的取样点,这两个数组必须是一维的。</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RllTIi91wkR2mx><p><strong>3.4.2 二维数据的平面色彩显示</strong></p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; data=np.clip(np.random.randn(5,5),-1,1)</p><p>&gt;&gt;&gt; plt.subplot(221)</p><p>&gt;&gt;&gt; plt.imshow(data)</p><p>&gt;&gt;&gt; plt.subplot(222)</p><p>&gt;&gt;&gt; plt.imshow(data,cmap=plt.cm.cool)</p><p>&gt;&gt;&gt; plt.subplot(223)</p><p>&gt;&gt;&gt; plt.imshow(data,cmap=plt.cm.hot)</p><p>&gt;&gt;&gt; plt.colorbar</p><p>&gt;&gt;&gt; plt.subplot(224)</p><p>&gt;&gt;&gt; im = plt.imshow(data,cmap=plt.cm.winter)</p><p>&gt;&gt;&gt; plt.colorbar(im, cmap=plt.cm.winter, ticks=[-1,0,1])</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RllTIiV4V2ShvX><p class=pgc-img-caption><strong class=highlight-text toutiao-origin=span>3.5 3D绘图</strong></p><p>虽然matplotlib主要专注于绘图，并且主要是二维的图形，但是它也有一些不同的扩展，能让我们在地理图上绘图，让我们把Excel和3D图表结合起来。在matplotlib的世界里，这些扩展叫做工具包（toolkits）。工具包是一些关注在某个话题（如3D绘图）的特定函数的集合。</p><p>比较流行的工具包有Basemap、GTK 工具、Excel工具、Natgrid、AxesGrid和mplot3d。</p><p>mpl_toolkits.mplot3工具包提供了一些基本的3D绘图功能，其支持的图表类型包括散点图（scatter）、曲面图（surf）、线图（line）和网格图（mesh）。虽然mplot3d不是一个最好的3D图形绘制库，但是它是伴随着matplotlib产生的，因此我们对其接口已经很熟悉了。</p><p>下面是一个使用plot_surface绘制3d曲面图的例子。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; import mpl_toolkits.mplot3d</p><p>&gt;&gt;&gt; x, y = np.mgrid[-2:2:50j,-2:2:50j]</p><p>&gt;&gt;&gt; z = x*np.exp(-x**2-y**2)</p><p>&gt;&gt;&gt; ax = plt.subplot(111,projection='3d')</p><p>&gt;&gt;&gt; ax.plot_surface(x,y,z,rstride=2,cstride=1,cmap=plt.cm.coolwarm,alpha=0.8)</p><p>&gt;&gt;&gt; ax.set_xlabel('x')</p><p>&gt;&gt;&gt; ax.set_ylabel('y')</p><p>&gt;&gt;&gt; ax.set_zlabel('z')</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTIiqGzuCNSB><p><strong class=highlight-text toutiao-origin=span>4.三剑客之Scipy</strong></p><p>前面已经说过，最初的numpy其实是scipy的一部分，后来才从scipy中分离出来。scipy函数库在numpy库的基础上增加了众多的数学、科学以及工程计算中常用的库函数。例如线性代数、常微分方程数值求解、信号处理、图像处理、稀疏矩阵等等。由于其涉及的领域众多，我之于scipy，就像盲人摸大象，只能是摸到哪儿算哪儿。</p><p><strong class=highlight-text toutiao-origin=span>4.1 插值</strong></p><p>数据插值是数据处理过程中经常用到的技术，常用的插值有一维插值、二维插值、高阶插值等，常见的算法有线性插值、B样条插值、临近插值等。</p><p><strong>4.1.1 一维插值</strong></p><p>一维插值最常用的算法是线型插值和三阶样条插值，此外还有前点插值、后点插值、临近点插值、零阶插值（等同于前点插值）、一阶插值（等同于线性插值）、五阶插值等。下面的例子对以上8中插值方法进行了比较。</p><pre><div><p>import numpy as np</p><p>from scipy import interpolate</p><p>import matplotlib.pyplot as plt</p><p>plt.rcParams['font.sans-serif'] = ['FangSong']</p><p>plt.rcParams['axes.unicode_minus'] = False</p><p>x = np.linspace(0,10,11)</p><p>y = np.exp(-x/3.0)</p><p>x_new = np.linspace(0,10,100) # 期望在0-10之间变成100个数据点</p><p>f1 = interpolate.interp1d(x, y, kind='linear')</p><p>f2 = interpolate.interp1d(x, y, kind='nearest')</p><p>f3 = interpolate.interp1d(x, y, kind='zero')</p><p>f4 = interpolate.interp1d(x, y, kind='slinear')</p><p>f5 = interpolate.interp1d(x, y, kind='cubic')</p><p>f6 = interpolate.interp1d(x, y, kind='quadratic')</p><p>f7 = interpolate.interp1d(x, y, kind='previous')</p><p>f8 = interpolate.interp1d(x, y, kind='next')</p><p>plt.figure('Demo', facecolor='#eaeaea')</p><p>plt.subplot(221)</p><p>plt.plot(x, y, "o", label=u"原始数据")</p><p>plt.plot(x_new, f2(x_new), label=u"临近点插值")</p><p>plt.plot(x_new, f7(x_new), label=u"前点插值")</p><p>plt.plot(x_new, f8(x_new), label=u"后点线性插值")</p><p>plt.legend</p><p>plt.subplot(222)</p><p>plt.plot(x, y, "o", label=u"原始数据")</p><p>plt.plot(x_new, f1(x_new), label=u"线性插值")</p><p>plt.plot(x_new, f3(x_new), label=u"零阶样条插值")</p><p>plt.plot(x_new, f4(x_new), label=u"一阶样条插值")</p><p>plt.legend</p><p>plt.subplot(223)</p><p>plt.plot(x, y, "o", label=u"原始数据")</p><p>plt.plot(x_new, f1(x_new), label=u"线性插值")</p><p>plt.plot(x_new, f5(x_new), label=u"三阶样条插值")</p><p>plt.legend</p><p>plt.subplot(224)</p><p>plt.plot(x, y, "o", label=u"原始数据")</p><p>plt.plot(x_new, f1(x_new), label=u"线性插值")</p><p>plt.plot(x_new, f6(x_new), label=u"五阶样条插值")</p><p>plt.legend</p><p>plt.show</p></div></pre><p>不同的插值方法画在一起，对比之下效果会比较明显：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTIjC2NGXhrz><p><strong>4.1.2 二维插值</strong></p><p>二维数据，通常总是对应着一个网格，比如，经纬度网格。如果插值对象只有一个二维数组，那么我们可以用数组的行列号来构造网格。</p><pre><div><p>import numpy as np</p><p>from scipy import interpolate</p><p>import matplotlib.pyplot as plt</p><p>plt.rcParams['font.sans-serif'] = ['FangSong']</p><p>plt.rcParams['axes.unicode_minus'] = False</p><p>y, x = np.mgrid[-2:2:20j,-3:3:30j] # 30x20 = 600</p><p>z = x*np.exp(-x**2-y**2)</p><p>y_new, x_new = np.mgrid[-2:2:80j,-3:3:120j] # 120x80 = 9600</p><p>f1 = interpolate.interp2d(x[0,:], y[:,0], z, kind='linear') # 线性插值</p><p>f2 = interpolate.interp2d(x[0,:], y[:,0], z, kind='cubic') # 三阶样条</p><p>f3 = interpolate.interp2d(x[0,:], y[:,0], z, kind='quintic') # 五阶样条</p><p>z1 = f1(x_new[0,:], y_new[:,0])</p><p>z2 = f2(x_new[0,:], y_new[:,0])</p><p>z3 = f3(x_new[0,:], y_new[:,0])</p><p>plt.subplot(221)</p><p>plt.pcolor(x, y, z, cmap=plt.cm.hsv)</p><p>plt.colorbar</p><p>plt.axis('equal')</p><p>plt.subplot(222)</p><p>plt.pcolor(x_new, y_new, z1, cmap=plt.cm.hsv)</p><p>plt.colorbar</p><p>plt.axis('equal')</p><p>plt.subplot(223)</p><p>plt.pcolor(x_new, y_new, z2, cmap=plt.cm.hsv)</p><p>plt.colorbar</p><p>plt.axis('equal')</p><p>plt.subplot(224)</p><p>plt.pcolor(x_new, y_new, z3, cmap=plt.cm.hsv)</p><p>plt.colorbar</p><p>plt.axis('equal')</p><p>plt.show</p></div></pre><p>原始数据、线型插值数据、三阶插值数据、五阶插值数据的效果对比如下：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTJQ7HewGvbX><p><strong class=highlight-text toutiao-origin=span>4.2 拟合</strong></p><p>在工作中，我们常常需要在图中描绘某些实际数据观察的同时，使用一个曲线来拟合这些实际数据。所谓拟合，就是找出符合数据变化趋势的曲线方程，进而对变化趋势做出预测。</p><p><strong>4.2.1 使用numpy.polyfit拟合</strong></p><p>numpy.polyfit 实现了最小二乘法，其功能是返回指定次数的多项式参数，这组参数使得多项式和样本数据的误差为最小。下面的代码，虚拟了谷神星的一段观测数据，籍此使用最小二乘法实现多项式拟合，进而推测出谷神星未来的运行轨迹。最后和虚拟的运行轨道方程比较。</p><pre><div><p># coding: utf-8</p><p>import numpy as np</p><p>import matplotlib.pyplot as plt</p><p>plt.rcParams['font.sans-serif'] = ['FangSong']</p><p>plt.rcParams['axes.unicode_minus'] = False</p><p>def f(t):</p><p>"""谷神星虚拟的运行轨道方程。我们假装不知道，仅用来验证预测结果是否准确"""</p><p>t = t/7.5 -1</p><p>return ((t**2-1)**3 + 0.5)*np.sin(2*t)</p><p>t = np.linspace(0, 20, 201) # 用于绘制实际的运行轨迹线</p><p>_x = np.linspace(0, 15, 16) # 观测数据时间序列</p><p>_y = f(_x) # 观测数据位置序列</p><p>x = np.linspace(15, 20, 6) # 待预测的时间序列</p><p>loss_list = list</p><p>for i in range(2,16): # 从2次到15次多项式，逐一计算误差</p><p>args = np.polyfit(_x, _y, i) # 用最小二乘法找到最佳的一组系数</p><p>g = np.poly1d(args) # 用这组系数生成方程g(x)</p><p>loss = np.sum(np.square(g(_x)-_y)) # 计算i次多项式拟合的误差</p><p>loss_list.append(loss)</p><p>print(i, loss)</p><p>k = loss_list.index(min(loss_list))+2</p><p>args = np.polyfit(_x, _y, k)</p><p>g = np.poly1d(args)</p><p>plt.figure('demo', facecolor='#eaeaea')</p><p>plt.plot(_x, _y, c='r', ls='', marker='o', label=u'观测数据')</p><p>plt.plot(_x, g(_x), c='b', ls='-', label=u'%d次多项式拟合，误差%0.8f'%(k, loss_list[k-2]))</p><p>plt.plot(x, g(x), c='r', ls=':', label=u'预测轨迹')</p><p>plt.plot(t, f(t), c='#60f0f0', ls='--', label=u'实际运行轨迹')</p><p>plt.legend(loc='lower left')</p><p>plt.show</p></div></pre><p>将虚拟的运行轨道、虚拟的观测数据、拟合曲线、预测曲线绘制在一起，效果如下：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTJQXCgAe2Jf><p><strong>4.2.2 使用scipy.optimize.optimize.curve_fit拟合</strong></p><p>不管曲线实际是什么样的，多项式拟合总是以一个有限次的多项式去逼近数据样本。还有一种拟合，就是我们知道曲线的标准方程，但有些系数或参数不确定，这样的拟合，也是要找到最佳系数或参数。scipy提供的拟合，需要先确定带参数的曲线方程，然后由scipy求解方程，返回曲线参数。</p><pre><div><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; import matplotlib.pyplot as plt</p><p>&gt;&gt;&gt; from scipy import optimize</p><p>&gt;&gt;&gt; x = np.arange(1,13,1)</p><p>&gt;&gt;&gt; y = np.array([17,19,21,28,33,38,37,37,31,23,19,18 ])</p><p>&gt;&gt;&gt; plt.plot(x, y)</p><p>[&lt;matplotlib.lines.Line2D object at 0x04799D10&gt;]</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTJQr5E6c71x><p>可以看出，曲线近似正弦函数。构建函数y=asin(xpi/6+b)+c，使用scipy的optimize.curve_fit函数求出a、b、c的值：</p><pre><div><p>&gt;&gt;&gt; def <strong class=highlight-text toutiao-origin=span>fmax</strong><strong class=highlight-text toutiao-origin=span>(x,a,b,c)</strong>:</p><p>return a*np.sin(x*np.pi/6+b)+c</p><p>&gt;&gt;&gt; fita, fitb = optimize.curve_fit(fmax, x, y, [1,1,1])</p><p>&gt;&gt;&gt; print fita</p><p>[ 10.93254951 -1.9496096 26.75 ]</p><p>&gt;&gt;&gt; xn = np.arange(1,13,0.1)</p><p>&gt;&gt;&gt; plt.plot(x, y)</p><p>[&lt;matplotlib.lines.Line2D object at 0x04B160B0&gt;]</p><p>&gt;&gt;&gt; plt.plot(xn, fmax(xn, fita[0],fita[1],fita[2]))</p><p>[&lt;matplotlib.lines.Line2D object at 0x04B16510&gt;]</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RllTJRGCF3DkUM><p><strong class=highlight-text toutiao-origin=span>4.3 求解非线性方程（组）</strong></p><p>在数学建模中，需要对一些稀奇古怪的方程（组）求解，Matlab自然是首选，但Matlab不是免费的，scipy则为我们提供了免费的午餐！scipy.optimize库中的fsolve函数可以用来对非线性方程（组）进行求解。它的基本调用形式如下：</p><pre><div><p>fsolve(func, x0)</p></div></pre><p>func(x)是计算方程组误差的函数，它的参数x是一个矢量，表示方程组的各个未知数的一组可能解，func返回将x代入方程组之后得到的误差；x0为未知数矢量的初始值。</p><p>我们先来求解一个简单的方程：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTJRS3vZlGKm><pre><div><p>&gt;&gt;&gt; from scipy.optimize import fsolve</p><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; def <strong class=highlight-text toutiao-origin=span>f</strong><strong class=highlight-text toutiao-origin=span>(A)</strong>:</p><p>x = float(A[0])</p><p>return [np.sin(x) - np.cos(x) - 0.2]</p><p>&gt;&gt;&gt; result = fsolve(f, [1])</p><p>array([ 0.92729522])</p><p>&gt;&gt;&gt; print result</p><p>[0.92729522]</p><p>&gt;&gt;&gt; print f(result)</p><p>[2.7977428707082197e-09]</p></div></pre><p>哈哈，易如反掌！再来一个方程组：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTKAnFK57CEs><pre><div><p>4x2−2sin(yz)=0 4x^2 - 2\sin(yz) = 04x </p><p>2</p><p>−2sin(yz)=0</p><p>5y+3=0 5y + 3 = 05y+3=0</p><p>yz−1.5=0 yz - 1.5 = 0yz−1.5=0</p><p>&gt;&gt;&gt; from scipy.optimize import fsolve</p><p>&gt;&gt;&gt; import numpy as np</p><p>&gt;&gt;&gt; def <strong class=highlight-text toutiao-origin=span>f</strong><strong class=highlight-text toutiao-origin=span>(A)</strong>:</p><p>x = float(A[0])</p><p>y = float(A[1])</p><p>z = float(A[2])</p><p>return [4*x*x - 2*np.sin(y*z), 5*y + 3, y*z - 1.5]</p><p>&gt;&gt;&gt; result = fsolve(f, [1, 1, 1])</p><p>&gt;&gt;&gt; print result</p><p>[-0.70622057 -0.6 -2.5 ]</p><p>&gt;&gt;&gt; print f(result)</p><p>[-9.1260332624187868e-14, 0.0, 5.329070518200751e-15]</p></div></pre><p>4.4 数值积分</p><p>数值积分是对定积分的数值求解，例如可以利用数值积分计算某个形状的面积。我们知道，半径为1的圆的方程可写成：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RllTKC3BFBsGou><p>下面让我们来考虑一下如何计算半径为1的半圆的面积，根据圆的面积公式，其面积应该等于PI/2。单位半圆曲线可以用下面的函数表示：</p><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RllTKCO2QknLlO><p>我们先定义一个计算根据x计算y的函数：</p><pre><div><p>&gt;&gt;&gt; def <strong class=highlight-text toutiao-origin=span>half_circle</strong><strong class=highlight-text toutiao-origin=span>(x)</strong>:</p><p>return (1-x**2)**0.5</p></div></pre><p><strong>4.4.1 经典微分法</strong></p><p>下面的程序使用经典的分小矩形计算面积总和的方式，计算出单位半圆的面积：</p><pre><div><p>&gt;&gt;&gt; N = 10000</p><p>&gt;&gt;&gt; x = np.linspace(-1, 1, N)</p><p>&gt;&gt;&gt; dx = 2.0/N</p><p>&gt;&gt;&gt; y = half_circle(x)</p><p>&gt;&gt;&gt; dx * np.sum(y[:-1] + y[1:]) # 面积的两倍</p><p>3.1412751679988937</p></div></pre><p><strong>4.4.2 使用定积分求解函数</strong></p><p>如果我们调用scipy.integrate库中的quad函数的话，将会得到非常精确的结果：</p><pre><div><p>&gt;&gt;&gt; from scipy import integrate</p><p>&gt;&gt;&gt; pi_half, err = integrate.quad(half_circle, -1, 1)</p><p>&gt;&gt;&gt; pi_half*2</p><p>3.1415926535897984</p></div></pre><p><strong class=highlight-text toutiao-origin=strong>4.5 图像处理</strong></p><p>在scipy.misc模块中，有一个函数可以载入Lena图像——这副图像是被用作图像处理的经典示范图像。我只是简单展示一下在该图像上的几个操作。</p><ol><li><p>载入Lena图像，并显示灰度图像</p></li><li><p>应用中值滤波扫描信号的每一个数据点，并替换为相邻数据点的中值</p></li><li><p>旋转图像</p></li><li><p>应用Prewitt滤波器（基于图像强度的梯度计算）</p></li></ol><pre><div><p>&gt;&gt;&gt; from scipy import misc</p><p>&gt;&gt;&gt; from scipy import ndimage</p><p>&gt;&gt;&gt; img = misc.lena.astype(np.float32)</p><p>&gt;&gt;&gt; plt.subplot(221)</p><p>&gt;&gt;&gt; plt.title('Original Image')</p><p>&gt;&gt;&gt; plt.imshow(img, cmap=plt.cm.gray)</p><p>&gt;&gt;&gt; plt.subplot(222)</p><p>&gt;&gt;&gt; plt.title('Median Filter')</p><p>&gt;&gt;&gt; filtered = ndimage.median_filter(img, size=(42,42))</p><p>&gt;&gt;&gt; plt.imshow(filtered, cmap=plt.cm.gray)</p><p>&gt;&gt;&gt; plt.subplot(223)</p><p>&gt;&gt;&gt; plt.title('Rotated')</p><p>&gt;&gt;&gt; rotated = ndimage.rotate(img, 90)</p><p>&gt;&gt;&gt; plt.imshow(rotated, cmap=plt.cm.gray)</p><p>&gt;&gt;&gt; plt.subplot(224)</p><p>&gt;&gt;&gt; plt.title('Prewitt Filter')</p><p>&gt;&gt;&gt; filtered = ndimage.prewitt(img)</p><p>&gt;&gt;&gt; plt.imshow(filtered, cmap=plt.cm.gray)</p><p>&gt;&gt;&gt; plt.show</p></div></pre><img alt="数学建模三剑客MSN | CSDN博文精选" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RllTKCiC7wUvIp><p><strong class=highlight-text toutiao-origin=span>5.后记</strong></p><p>这篇博文自2016年9月初动笔，断断续续写了5个多月。延宕这么久，除了自身懒惰的原因外，主要是因为MSN这个主题涉及的内容太过繁杂，又极其晦涩，无论怎么努力，总怕挂一漏万、贻笑大方。</p><p>现在好了，终于写完了。倘若哪位看官发现了谬误，请自行修改，顺便通知我一声；若因此文受益而想约饭、约酒，请发邮件至：xufive@gmail.com</p><p><strong class=highlight-text toutiao-origin=span>技术的道路一个人走着极为艰难？</strong></p><p><strong class=highlight-text toutiao-origin=span>一身的本领得不施展？</strong></p><p><strong class=highlight-text toutiao-origin=span>优质的文章得不到曝光？</strong></p><p><em>（*本文为AI科技大本营转载文</em><em>章，转载请联系原作者）</em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数学','三剑客','MSN'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>