<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>力扣 1519——子数中标签相同的节点数 | 极客快訊</title><meta property="og:title" content="力扣 1519——子数中标签相同的节点数 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/78a5fac2213f451a89b610084a5458b8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/2a8b0ba.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/2a8b0ba.html><meta property="article:published_time" content="2020-10-29T21:02:05+08:00"><meta property="article:modified_time" content="2020-10-29T21:02:05+08:00"><meta name=Keywords content><meta name=description content="力扣 1519——子数中标签相同的节点数"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/2a8b0ba.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>力扣 1519——子数中标签相同的节点数</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>本题主要在于对树这种数据结构的考察，以及深度优先遍历的使用，优化时可以采取空间换时间的策略。</p><h1 class=pgc-h-arrow-right>原题</h1><p>给你一棵树（即，一个连通的无环无向图），这棵树由编号从 0 到 n - 1 的 n 个节点组成，且恰好有 n - 1 条 edges 。树的根节点为节点 0 ，树上的每一个节点都有一个标签，也就是字符串 labels 中的一个小写字符（编号为 i 的 节点的标签就是 labels[i] ）</p><p>边数组 edges 以 edges[i] = [ai, bi] 的形式给出，该格式表示节点 ai 和 bi 之间存在一条边。</p><p>返回一个大小为 n 的数组，其中 ans[i] 表示第 i 个节点的子树中与节点 i 标签相同的节点数。</p><p>树 T 中的子树是由 T 中的某个节点及其所有后代节点组成的树。</p><p>示例 1：</p><div class=pgc-img><img alt="力扣 1519——子数中标签相同的节点数" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/78a5fac2213f451a89b610084a5458b8><p class=pgc-img-caption></p></div><pre><code>输入：n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], labels = "abaedcd"输出：[2,1,1,1,1,1,1]解释：节点 0 的标签为 'a' ，以 'a' 为根节点的子树中，节点 2 的标签也是 'a' ，因此答案为 2 。注意树中的每个节点都是这棵子树的一部分。节点 1 的标签为 'b' ，节点 1 的子树包含节点 1、4 和 5，但是节点 4、5 的标签与节点 1 不同，故而答案为 1（即，该节点本身）。</code></pre><p>示例 2：</p><div class=pgc-img><img alt="力扣 1519——子数中标签相同的节点数" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8465bec7f54d47d4b0b515bc1b6152bd><p class=pgc-img-caption></p></div><pre><code>输入：n = 4, edges = [[0,1],[1,2],[0,3]], labels = "bbbb"输出：[4,2,1,1]解释：节点 2 的子树中只有节点 2 ，所以答案为 1 。节点 3 的子树中只有节点 3 ，所以答案为 1 。节点 1 的子树中包含节点 1 和 2 ，标签都是 'b' ，因此答案为 2 。节点 0 的子树中包含节点 0、1、2 和 3，标签都是 'b'，因此答案为 4 。</code></pre><p>示例 3 ：</p><div class=pgc-img><img alt="力扣 1519——子数中标签相同的节点数" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/33b42c280eed46e781248a28e16d3eec><p class=pgc-img-caption></p></div><pre><code>输入：n = 5, edges = [[0,1],[0,2],[1,3],[0,4]], labels = "aabab"输出：[3,2,1,1,1]</code></pre><p>示例 4：</p><pre><code>输入：n = 6, edges = [[0,1],[0,2],[1,3],[3,4],[4,5]], labels = "cbabaa"输出：[1,2,1,1,2,1]</code></pre><p>示例 5：</p><pre><code>输入：n = 7, edges = [[0,1],[1,2],[2,3],[3,4],[4,5],[5,6]], labels = "aaabaaa"输出：[6,5,4,1,3,2,1]</code></pre><p>提示：</p><ul><li>1 &lt;= n &lt;= 10^5</li><li>edges.length == n - 1</li><li>edges[i].length == 2</li><li>0 &lt;= ai, bi &lt; n</li><li>ai != bi</li><li>labels.length == n</li><li>labels 仅由小写英文字母组成</li></ul><p>原题 url：https://leetcode-cn.com/problems/number-of-nodes-in-the-sub-tree-with-the-same-label</p><h1 class=pgc-h-arrow-right>解题</h1><h1 class=pgc-h-arrow-right>首次尝试</h1><p>这道题是要让我们计算：在子树中，和当前节点字符相同的节点个数。</p><p>那么我们就必然需要构建树中各个节点的关系，那么就需要记录父子节点的关系，因为是普通的树，一个节点的子节点可能有多个，因此我用LinkedList&lt;Integer>[] tree这样一个数组进行存储，其中tree[i]代表节点 i 的所有子节点。</p><p>至于求相同节点的个数，我想着可以从根节点 0 开始逐个遍历，先获取其第一层子节点，再根据第一层子节点逐个获取，可以采用广度优先遍历的形式。</p><p>让我们看看代码：</p><pre><code>class Solution {    public int[] countSubTrees(int n, int[][] edges, String labels) {        // 构造树        LinkedList&lt;Integer&gt;[] tree = new LinkedList[n];        for (int[] edge : edges) {            // edge[0]的子节点            LinkedList&lt;Integer&gt; child = tree[edge[0]];            if (child == null) {                child = new LinkedList&lt;&gt;();                tree[edge[0]] = child;            }            // 增加子节点            child.add(edge[1]);        }        // 结果        int[] result = new int[n];        // 遍历并计算        for (int i = 0; i &lt; n; i++) {            // 需要遍历的字符            char cur = labels.charAt(i);            // 该节点的子树中与该字符相同的节点数            int curCount = 0;            // 广度优先遍历            LinkedList&lt;Integer&gt; searchList = new LinkedList&lt;&gt;();            searchList.add(i);            while(!searchList.isEmpty()) {                int index = searchList.removeFirst();                if (cur == labels.charAt(index)) {                    curCount++;                }                // 找出该节点的子树                if (tree[index] == null) {                    continue;                }                searchList.addAll(tree[index]);            }            result[i] = curCount;        }        return result;    }}</code></pre><p>提交之后，发现有错误。错误的情况是：</p><pre><code>输入：4[[0,2],[0,3],[1,2]]"aeed"输出：[1,2,1,1]预期：[1,1,2,1]</code></pre><p>根据这样输入，我构造出的树是：</p><pre><code>1   0 \ / \  2   3</code></pre><p>但根据预期结果反推出来的树是：</p><pre><code>    0   / \  2   3 /1</code></pre><p>那么输入中最后给出的[1,2]就不是从父节点指向子节点，也就是输入中给出的边关联的节点顺序，是任意的。</p><p>那我们的树究竟该如何构造呢？</p><h1 class=pgc-h-arrow-right>双向记录构造树</h1><p>既然我们在构造树的时候，无法直接得出父子关系，那么就将对应两个节点同时记录另一个节点。</p><p>根据题目中给出的条件：树的根节点为节点 0。这样我们在遍历的时候，就从 0 开始，只要 0 关联的节点，一定是 0 的子节点。将这些节点进行标记，这样再递归访问接下来的节点时，如果是标记过的，则说明是父节点，这样就可以明确父子节点关系了。</p><p>至于遍历的时候，因为这次我们是不知道父子节点关系的，所以无法直接采用广度优先遍历，换成深度优先遍历。</p><p>让我们看看代码：</p><pre><code>class Solution {    // 总节点数    int n;    // 树    Map&lt;Integer, LinkedList&lt;Integer&gt;&gt; tree;    // 字符串    String labels;    // 最终结果    int[] result;    public int[] countSubTrees(int n, int[][] edges, String labels) {        this.n = n;        this.labels = labels;        result = new int[n];        LinkedList&lt;Integer&gt; list;        // 双向构造树的关系        tree = new HashMap&lt;&gt;(n / 4 * 3 + 1);        for (int[] edge : edges) {            // 添加映射关系            list = tree.computeIfAbsent(edge[0], k -&gt; new LinkedList&lt;&gt;());            list.add(edge[1]);            list = tree.computeIfAbsent(edge[1], k -&gt; new LinkedList&lt;&gt;());            list.add(edge[0]);        }        // 深度优先搜索        dfs(0);        return result;    }    public int[] dfs(int index) {        // 当前子树中，所有字符的个数        int[] charArray = new int[26];        // 开始计算，标志该节点已经计算过        result[index] = 1;        // 获得其关联的节点        List&lt;Integer&gt; nodes = tree.get(index);        // 遍历        for (int node : nodes) {            // 如果该节点已经访问过            if (result[node] &gt; 0) {                continue;            }            // 递归遍历子节点            int[] array = dfs(node);            for (int i = 0; i &lt; 26; i++) {                charArray[i] += array[i];            }        }        // 将当前节点的值计算一下        charArray[labels.charAt(index) - 'a'] += 1;        result[index] = charArray[labels.charAt(index) - 'a'];        return charArray;    }}</code></pre><p>提交OK，执行用时136ms，超过36.71%，内存消耗104.5MB，超过91.38%。</p><p>时间复杂度上，应该是要研究dfs方法中的两个for循环，外层肯定是每个节点都遍历一遍，内层还需要遍历26个英文字母，也就是O(n)。</p><p>空间复杂度上，最大的应该就是存储节点映射关系的tree了，里面实际上就是 2n 个节点（因为每条边对应的两个节点都会互相存一次对方），因此也就是O(n)。</p><p>虽然过了，但执行速度很慢，可以进一步优化。</p><h1 class=pgc-h-arrow-right>用空间换时间</h1><p>针对我上面的解法，其中tree我是用的Map，虽然其get方法理论上是O(n)，但毕竟涉及 hash，可以优化成数组。</p><p>至于每次取节点对应的字符所用的charAt方法，具体其实是：</p><pre><code>    public char charAt(int index) {        if ((index &lt; 0) || (index &gt;= value.length)) {            throw new StringIndexOutOfBoundsException(index);        }        return value[index];    }</code></pre><p>每次都会检查一次 index，其实这完全是可以省略的，因此可以提前构造好每个位置对应的值，也用一个数组存储。</p><p>让我们看看新的代码：</p><pre><code>class Solution {    // 总节点数    int n;    // 树    LinkedList&lt;Integer&gt;[] tree;    // 每个节点的值（用数字表示）    int[] nodeValueArray;    // 最终结果    int[] result;    public int[] countSubTrees(int n, int[][] edges, String labels) {        this.n = n;        nodeValueArray = new int[n];        result = new int[n];        // 双向构造树的关系        tree = new LinkedList[n];        for (int i = 0; i &lt; n; i++) {            tree[i] = new LinkedList&lt;&gt;();        }        for (int[] edge : edges) {            // 添加映射关系            tree[edge[0]].add(edge[1]);            tree[edge[1]].add(edge[0]);        }        // 生成节点的值        for (int i = 0; i &lt; n; i++) {            nodeValueArray[i] = labels.charAt(i) - 'a';        }        // 深度优先搜索        dfs(0);        return result;    }    public int[] dfs(int index) {        // 当前子树中，所有字符的个数        int[] charArray = new int[26];        // 开始计算，标志该节点已经计算过        result[index] = 1;        // 获得其关联的节点        List&lt;Integer&gt; nodes = tree[index];        // 遍历        for (int node : nodes) {            // 如果该节点已经访问过            if (result[node] &gt; 0) {                continue;            }            // 递归遍历子节点            int[] array = dfs(node);            for (int i = 0; i &lt; 26; i++) {                charArray[i] += array[i];            }        }        // 将当前节点的值计算一下        charArray[nodeValueArray[index]] += 1;        result[index] = charArray[nodeValueArray[index]];        return charArray;    }}</code></pre><p>提交之后，执行用时是96ms，内存消耗是402.2MB。看来优化的效果并不明显。</p><h1 class=pgc-h-arrow-right>研究一下目前最优解法</h1><p>这个解法真的是巧妙，执行用时20ms，超过了100%，内存消耗76.3MB，超过了100%。</p><p>我在代码中增加了注释，方便大家理解。但这样的写法，研究一下是能够看懂，但让我想估计是永远不可能想出来，可以让大家也一起学习和借鉴：</p><pre><code>public class Solution {  static class Next {    Next next;    Node node;    Next(Next next, Node node) {      this.next = next;      this.node = node;    }  }  static class Node {    /**     * 当前节点的index     */    final int index;    /**     * 当前节点对应的字符值（减去'a'）     */    final int ci;    /**     * 所有关联的节点     */    Next children;    /**     * 该节点的父节点     */    Node parent;    /**     * 子树中和该节点含有相同字符的节点总个数     */    int result;    /**     * 是否还在队列中，可以理解为是否已访问过     */    boolean inQueue;    public Node(int index, int ci) {      this.index = index;      this.ci = ci;      this.result = 1;    }    /**     * 从后往前，找到当前节点没有访问过的第一个子节点     */    Node popChild() {      for (; ; ) {        // 当前节点的所有关联节点        Next n = this.children;        // 如果没有，说明子节点都遍历完了        if (n == null) {          return null;        }        // 从后往前移除关联节点        this.children = n.next;        // 返回第一个没有访问过的节点        if (!n.node.inQueue) {          return n.node;        }      }    }    /**     * 访问了该节点     */    Node enqueue(Node[] cnodes) {      // 该节点标记为访问过      this.inQueue = true;      // 记录该节点的父节点      this.parent = cnodes[ci];      // 那么现在该字符值对应的最高节点，就是当前节点。      // 这样如果之后也遇到相同字符的子节点，就可以为子节点赋值其父节点，也就是上面一行是有效的      cnodes[ci] = this;      return this;    }    /**     * 退出该节点     */    void dequeue(Node[] cnodes, int[] res) {      // 之后会访问该节点的兄弟节点，因此父节点需要重新设置      cnodes[ci] = this.parent;      // 设置当前节点的值      res[index] = this.result;      // 父节点也可以进行累加      if (this.parent != null) {        this.parent.result += this.result;      }    }    void link(Node x) {      // this节点和x节点，互相绑定      this.children = new Next(this.children, x);      x.children = new Next(x.children, this);    }  }  public int[] countSubTrees(int n, int[][] edges, String labels) {    // 构造树    Node[] nodes = new Node[n];    // 每个节点对应的字符    for (int i = 0; i &lt; n; i++) {      nodes[i] = new Node(i, labels.charAt(i) - 'a');    }    // 通过边的关系，将节点互相绑定    for (int[] es : edges) {      nodes[es[0]].link(nodes[es[1]]);    }    // 最终的结果    int[] res = new int[n];    // 当前访问的节点下标    int sz = 0;    // 26个小写英文字母对应的节点数组    Node[] cnodes = new Node[26];    // 下面三行可以合并成这一行：    // Node node = nodes[sz++] = nodes[0].enqueue(cnodes);    nodes[sz] = nodes[0].enqueue(cnodes);    // 当前访问的节点    Node node = nodes[sz];    // 因为当前节点已经访问过，自然下标需要+1    sz++;    for (; ; ) {      // 从后往前，找到当前节点没有访问过的第一个子节点      Node child = node.popChild();      // 如果已经全部访问过了      if (child == null) {        // 开始计算        node.dequeue(cnodes, res);        if (--sz == 0) {          break;        }        // 回溯到父节点        node = nodes[sz - 1];      } else {        // 保证了相邻节点一定是父子节点        node = nodes[sz++] = child.enqueue(cnodes);      }    }    return res;  }}</code></pre><h1 class=pgc-h-arrow-right>总结</h1><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。本题主要在于对树这种数据结构的考察，以及深度优先遍历的使用，优化时可以采取空间换时间的策略。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p>https://death00.github.io/</p><p>公众号：健程之道</p><p><br></p><div class=pgc-img><img alt="力扣 1519——子数中标签相同的节点数" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a6429e9f0946456d9a73ec2009f3fe32><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt="力扣 1519——子数中标签相同的节点数" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/35fe6c11a72246e18a5ebe7c94b31e2c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'力扣','1519','子数'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>