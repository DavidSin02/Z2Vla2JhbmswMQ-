<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>老生常谈的内存问题你还是再来看看吧 | 极客快訊</title><meta property="og:title" content="老生常谈的内存问题你还是再来看看吧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/95b6a9a43785468fb3b24d2617951bf7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/44160f37.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/44160f37.html><meta property="article:published_time" content="2020-11-14T20:53:57+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:57+08:00"><meta name=Keywords content><meta name=description content="老生常谈的内存问题你还是再来看看吧"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/44160f37.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>老生常谈的内存问题你还是再来看看吧</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><blockquote><p><strong>私信我或关注微信号：狮范儿，回复：学习，获取免费学习资源包。</strong></p></blockquote><p><em>1</em></p><p>我们为什么要优化内存</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/95b6a9a43785468fb3b24d2617951bf7><p class=pgc-img-caption></p></div><p>在 Android 中我们写的 .java 文件，最终会编译成 .class 文件, class 又由类装载器加载后，在 JVM 中会形成一份描述 class 结构的元信息对象，通过该元信息对象可以知道 class 的结构信息 (构造函数、属性、方法)等。</p><p>JVM 会把描述类的数据从 class 文件加载到内存，Java 有一个很好的管理内存的机制，垃圾回收机制 GC 。</p><p>为什么 Java 都给我们提供了垃圾回收机制，程序有时还会导致内存泄漏，内存溢出 OOM，甚至导致程序 Crash 。接下来我们就对实际开发中出现的这些内存问题，来进行优化。</p><p><em>2</em></p><p>Java 虚拟机</p><p class=ql-align-justify><br></p><p>我们先来大概了解一下 Java 虚拟机里面运行时的数据区域有哪些。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/921a50916b5647ddbc213d6c8b54a64b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>线程独占区</strong></p><p><strong>程序计数器</strong></p><ul><li class=ql-align-justify>相当于一个执行代码的指示器，用来确认下一行执行的地址</li><li class=ql-align-justify>每个线程都有一个</li><li class=ql-align-justify>没有 OOM 的区</li></ul><p><strong>虚拟机栈</strong></p><ul><li class=ql-align-justify>我们平时说的栈就是这块区域</li><li class=ql-align-justify>java 虚拟机规范中定义了 OutOfMemeory , stackoverflow 异常</li></ul><p><strong>本地方法栈</strong></p><ul><li class=ql-align-justify>java 虚拟机规范中定义了 OutOfMemory ，stackoverflow 异常</li></ul><p><strong>注意</strong></p><ul><li class=ql-align-justify>在 hotspotVM 中把虚拟机栈和本地方法栈合为了一个栈区</li></ul><p><strong>线程共享区</strong></p><p><strong>方法区</strong></p><ul><li class=ql-align-justify>ClassLoader 加载类信息</li><li class=ql-align-justify>常量、静态变量</li><li class=ql-align-justify>编译后的代码</li><li class=ql-align-justify>会出现 OOM</li><li class=ql-align-justify>运行时常量池</li><li class="ql-align-justify ql-indent-1">public static final</li><li class="ql-align-justify ql-indent-1">符号引用类、接口全名、方法名</li></ul><p><strong>java 堆 (本次需要优化的地方)</strong></p><ul><li class=ql-align-justify>虚拟机能管理的最大的一块内存 GC 主战场</li><li class=ql-align-justify>会出现 OOM</li><li class=ql-align-justify>对象实例</li><li class=ql-align-justify>数据的内容</li></ul><p><em>3</em></p><p>JAVA GC 如何确定内存回收</p><p class=ql-align-justify><br></p><p>随着程序的运行，内存中的实例对象、变量等占据的内存越来越多，如果不及时进行回收，会降低程序运行效率，甚至引发系统异常。</p><p>目前虚拟机基本都是采用可达性分析算法，为什么不采用引用计数算法呢？下面就说说引用计数法是如果统计所有对象的引用计数的，再对比可达性分析算法是如何解决引用计数算法的不足。下面就来看下这 2 个算法：</p><p><strong>引用计数算法</strong></p><p>每个对象有一个引用计数器，当对象被引用一次则计数器加一，当对象引用一次失效一次则计数器减一，对于计数器为 0 的时候就意味着是垃圾了，可以被 GC 回收。</p><p>下面通过一段代码来实际看下</p><pre>public class GCTest { private Object instace = null; public static void onGCtest() { //step 1 GCTest gcTest1 = new GCTest(); //step 2 GCTest gcTest2 = new GCTest(); //step 3 gcTest1.instace = gcTest2; //step 4 gcTest2.instace = gcTest1; //step 5 gcTest1 = null; //step 6 gcTest2 = null; } public static void main(String[] arg) { onGCtest(); }}</pre><p>分析代码</p><pre>//step 1 gcTest1 引用 + 1 = 1//step 2 gcTest2 引用 + 1 = 1//step 3 gcTest1 引用 + 1 = 2//step 4 gcTest2 引用 + 1 = 2//step 5 gcTest1 引用 - 1 = 1//step 6 gcTest2 引用 - 1 = 1</pre><p>很明显现在 2 个对象都不能用了都为 null 了，但是 GC 确不能回收它们，因为它们本身的引用计数不为 0 。不能满足被回收的条件，尽管调用 System.gc() 也还是不能得到回收, 这就造成了 内存泄漏 。当然，现在虚拟机基本上都不采用此方式。</p><p><strong>可达性分析算法</strong></p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/49cff1bab43b4b029723f9d52d1f4b6b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>从 GC Roots 作为起点开始搜索，那么整个连通图中额对象边都是活对象，对于 GC Roots 无法到达的对象便成了垃圾回收的对象，随时可能被 GC 回收。</p><p><strong>可以作为 GC Roots 的对象</strong></p><ul><li class=ql-align-justify>虚拟机栈正在运行使用的引用</li><li class=ql-align-justify>静态属性 常量</li><li class=ql-align-justify>JNI 引用的对象</li></ul><p>GC 是需要 2 次扫描才回收对象，所以我们可以使用 finalize 去救活丢失的引用</p><p>@Override</p><p>protected void finalize() throws Throwable {</p><p>super.finalize();</p><p>instace = this;</p><p>}</p><p><strong>到了这里，相信大家已经能够弄明白这 2 个算法的区别了吧？反正对于对象之间循环引用的情况，引用计数算法无法回收这 2 个对象，而可达性是从 GC Roots 开始搜索，所以能够正确的回收。</strong></p><p><strong>不同引用类型的回收状态</strong></p><p><strong>强引用</strong></p><pre>Object strongReference = new Object()</pre><p>如果一个对象具有强引用，那垃圾回收器绝不会回收它，当内存空间不足， Java 虚拟机宁愿抛出 OOM 错误，使程序异常 Crash ,也不会靠随意回收具有强引用的对象来解决内存不足的问题.如果强引用对象不再使用时，需要弱化从而使 GC 能够回收，需要：</p><pre>strongReference = null; //等 GC 来回收</pre><p>还有一种情况，如果：</p><p>public void onStrongReference(){</p><p>Object strongReference = new Object()</p><p>}</p><p>在 onStrongReference() 内部有一个强引用，这个引用保存在 java 栈 中，而真正的引用内容 （Object）保存在 java 堆中。当这个方法运行完成后，就会退出方法栈，则引用对象的引用数为 0 ，这个对象会被回收。</p><p>但是如果 mStrongReference 引用是全局时，就需要在不用这个对象时赋值为 null ,因为 强引用 不会被 GC 回收。</p><p><strong>软引用 (SoftReference)</strong></p><p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存，只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收， java 虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/988e68428d6a46db9ec92ebd4dfec843><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>注意: 软引用对象是在 jvm 内存不够的时候才会被回收，我们调用 System.gc() 方法只是起通知作用， JVM 什么时候扫描回收对象是 JVM 自己的状态决定的。就算扫描到了 str 这个对象也不会回收，只有内存不足才会回收。</p><p><strong>弱引用 (WeakReference)</strong></p><p>弱引用与软引用的区别在于: 只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e84492935954e3981607752273b090e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>可见 weakReference 对象的生命周期基本由 GC 决定，一旦 GC 线程发现了弱引用就标记下来，第二次扫描到就直接回收了。</p><p>注意这里的 referenceQueuee 是装的被回收的对象。</p><p><strong>虚引用 (PhantomReference)</strong></p><pre> @Test public void onPhantomReference()throws InterruptedException{ String str = new String("123456"); ReferenceQueue queue = new ReferenceQueue(); // 创建虚引用，要求必须与一个引用队列关联 PhantomReference pr = new PhantomReference(str, queue); System.out.println("PhantomReference:" + pr.get()); System.out.printf("ReferenceQueue:" + queue.poll()); }</pre><p>虚引用顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于: 虚引用必须和引用队列 (ReferenceQueue) 联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p><p><strong>总结</strong></p><p>引用类型调用方式GC是否内存泄漏强引用直接调用不回收是软引用.get()视内存情况回收否弱引用.get()回收不可能虚引用null任何时候都可能被回收，相当于没有引用一样否</p><p><em>4</em></p><p>分析内存常用工具</p><p>工具很多，掌握原理方法，工具随意挑选使用。</p><ul><li class=ql-align-justify>top/procrank</li><li class=ql-align-justify>meinfo</li><li class=ql-align-justify>Procstats</li><li class=ql-align-justify>DDMS</li><li class=ql-align-justify>MAT</li><li class=ql-align-justify>Finder - Activity</li><li class=ql-align-justify>LeakCanary</li><li class=ql-align-justify>LeakInspector</li></ul><p><em>5</em></p><p>内存泄露</p><p class=ql-align-justify><br></p><p>产生的原因: 一个长生命周期的对象持有一个短生命周期对象的引用，通俗点讲就是该回收的对象，因为引用问题没有被回收，最终会产生 OOM。</p><p><strong>下面我们来利用 Profile 来检查项目是否有内存泄漏</strong></p><p>怎么利用 profile 来查看项目中是否有内存泄漏</p><p>1. 在 AS 中项目以 profile 运行</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a926242dca6e4c0cab955ece7eeb6de0><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>2.在 MEMORY 界面中选择要分析的一段内存，右键 export</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f15ed99d32374774baad73b684563959><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>Allocations: 动态分配对象个数</p><p>Deallocation: 解除分配的对象个数</p><p>Total count: 对象的总数</p><p>Shalow Size: 对象本身占用的内存大小</p><p>Retained Size: GC 回收能收走的内存大小</p><p>3. 转换 profile 文件格式</p><p>将 export 导出的 dprof 文件转换为 Mat 的 dprof 文件</p><p>cd /d 进入到 Android sdk/platform-tools/hprof-conv.exe</p><pre>//转换命令 hprof-conv -z src desD:\Android\AndroidDeveloper-sdk\android-sdk-windows\platform-tools&gt;hprof-conv -z D:\temp_\temp_6.hprof D:\temp_\memory6.hprod</pre><p>4. 下载 Mat 工具</p><p><em>https://www.eclipse.org/mat/downloads.php</em></p><p>5. 打开 MemoryAnalyzer.exe 点击左上角 File 菜单中的 Open Heap Dump</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb9faeb0af954249b71c7b8e17227692><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>6. 查看内存泄漏中的 GC Roots 强引用</p><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/28b5ea127fc946e892ea3028eb476c79><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p>这里我们得知是一个 ilsLoginListener 引用了 LoginView,我们来看下代码最后怎么解决的。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45ec2cd1606f42dca02a6b93ac79a2dc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>代码中我们找到了 LoginView 这个类，发现是一个单例中的回调引起的内存泄漏，下面怎么解决勒，请看第七小点。</p><p><strong>2种解决单例中的内存泄漏</strong></p><p>a. 将引用置为 null</p><pre>/** * 销毁监听 */public void unRemoveRegisterListener(){ mMessageController.unBindListener();}public void unBindListener(){ if (listener != null){ listener = null; }}</pre><p>b. 使用弱引用</p><pre>//将监听器放入弱引用中WeakReference&lt;IBinderServiceListener&gt; listenerWeakReference = new WeakReference&lt;&gt;(listener);//从弱引用中取出回调listenerWeakReference.get()；</pre><p>通过第七小点就能完美的解决单例中回调引起的内存泄漏。</p><p><strong>Android 中常见的内存泄漏经典案例及解决方法</strong></p><p><strong>单例</strong></p><p>示例 :</p><pre>public class AppManager { private static AppManager sInstance; private CallBack mCallBack; private Context mContext; private AppManager(Context context) { this.mContext = context; } public static AppManager getInstance(Context context) { if (sInstance == null) { sInstance = new AppManager(context); } return sInstance; } public void addCallBack(CallBack call){ mCallBack = call； }}</pre><p class=ql-align-justify>1. 通过上面的单列，如果 context 传入的是 Activity , Service 的 this，那么就会导致内存泄漏。</p><p class=ql-align-justify>以 Activity 为例，当 Activity 调用 getInstance 传入 this ，那么 sInstance 就会持有 Activity 的引用，当 Activity 需要关闭的时候需要 回收的时候，发现 sInstance 还持有 没有用的 Activity 引用，导致 Activity 无法被 GC 回收，就会造成内存泄漏</p><p class=ql-align-justify>2. addCallBack(CallBack call) 这样写看起来是没有毛病的。但是当这样调用在看一下勒。</p><pre>//在 Activity 中实现单例的回调AppManager.getInstance(getAppcationContext()).addCallBack(new CallBack(){ @Override public void onStart(){ }})；</pre><p class=ql-align-justify>这里的 new CallBack() 匿名内部类 默认持有外部的引用，造成 CallBack 释放不了，那么怎么解决了，请看下面解决方法。</p><p class=ql-align-justify><strong>解决方法:</strong></p><p class=ql-align-justify>1. getInstance(Context context) context 都传入 Appcation 级别的 Context,或者实在是需要传入 Activity 的引用就用 WeakReference 这种形式。</p><p class=ql-align-justify>2. 匿名内部类建议大家单独写一个文件或者</p><pre>public void addCallBack(CallBack call){ WeakReference&lt;CallBack&gt; mCallBack= new WeakReference&lt;CallBack&gt;(call)； }</pre><p><strong>Handler</strong></p><p>示例:</p><p>//在 Activity 中实现 Handler</p><p>class MyHandler extends Handler{</p><p>private Activity m;</p><p>public MyHandler(Activity activity){</p><p>m=activity;</p><p>}</p><p>// class.....</p><p>}</p><p>这里的 MyHandler 持有 activity 的引用，当 Activity 销毁的时候，导致 GC 不会回收造成 内存泄漏。</p><p>解决方法:</p><p>1.使用静态内部类 + 弱引用</p><p>2.在 Activity onDestoty() 中处理 removeCallbacksAndMessages()</p><p>@Override</p><p>protected void onDestroy() {</p><p>super.onDestroy();</p><p>if(null != handler){</p><p>handler.removeCallbacksAndMessages(null);</p><p>handler = null;</p><p>}</p><p>}</p><p><strong>静态变量</strong></p><p>示例:</p><pre>public class MainActivity extends AppCompatActivity { private static Police sPolice; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (sPolice != null) { sPolice = new Police(this); } }}class Police { public Police(Activity activity) { }}</pre><p>这里 Police 持有 activity 的引用，会造成 activity 得不到释放，导致内存泄漏。</p><p>解决方法:</p><pre>//1. sPolice 在 onDestory（）中 sPolice = null;//2. 在 Police 构造函数中 将强引用 to 弱引用；</pre><p><strong>非静态内部类</strong></p><p>参考 第二点 Handler 的处理方式</p><p><strong>匿名内部类</strong></p><p>示例:</p><p>public class MainActivity extends AppCompatActivity {</p><p>@Override</p><p>protected void onCreate(Bundle savedInstanceState) {</p><p>super.onCreate(savedInstanceState);</p><p>setContentView(R.layout.activity_main);</p><p>new Thread(){</p><p>@Override</p><p>public void run() {</p><p>super.run();</p><p>}</p><p>};</p><p>}</p><p>}</p><p>很多初学者都会像上面这样新建线程和异步任务，殊不知这样的写法非常地不友好，这种方式新建的子线程Thread和AsyncTask都是匿名内部类对象，默认就隐式的持有外部Activity的引用，导致Activity内存泄露。</p><p>解决方法:</p><pre>//静态内部类 + 弱引用//单独写一个文件 + onDestory = null;</pre><p><strong>未取消注册或回调</strong></p><p>示例:</p><pre>public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); registerReceiver(mReceiver, new IntentFilter()); } private BroadcastReceiver mReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO ------ } };}</pre><p>在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用Retrofit + RxJava注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。</p><p>解决方法:</p><pre>//Activity 中实现 onDestory（）反注册广播得到释放 @Override protected void onDestroy() { super.onDestroy(); this.unregisterReceiver(mReceiver); }</pre><p><strong>定时任务</strong></p><p>示例:</p><pre>public class MainActivity extends AppCompatActivity { /**模拟计数*/ private int mCount = 1; private Timer mTimer; private TimerTask mTimerTask; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); mTimer.schedule(mTimerTask, 1000, 1000); } private void init() { mTimer = new Timer(); mTimerTask = new TimerTask() { @Override public void run() { MainActivity.this.runOnUiThread(new Runnable() { @Override public void run() { addCount(); } }); } }; } private void addCount() { mCount += 1; }}</pre><p>当我们Activity销毁的时，有可能Timer还在继续等待执行TimerTask，它持有Activity 的引用不能被 GC 回收，因此当我们 Activity 销毁的时候要立即cancel掉Timer和TimerTask，以避免发生内存泄漏。</p><p>解决方法:</p><pre>//当 Activity 关闭的时候，停止一切正在进行中的定时任务，避免造成内存泄漏。 private void stopTimer() { if (mTimer != null) { mTimer.cancel(); mTimer = null; } if (mTimerTask != null) { mTimerTask.cancel(); mTimerTask = null; } } @Override protected void onDestroy() { super.onDestroy(); stopTimer(); }</pre><p><strong>资源未关闭</strong></p><p>示例:</p><p>ArrayList,HashMap,IO,File,SqLite,Cursor 等资源用完一定要记得 clear remove 等关闭一系列对资源的操作。</p><p>解决方法:</p><p>用完即刻销毁</p><p><strong>属性动画</strong></p><p>示例:</p><pre>动画同样是一个耗时任务，比如在 Activity 中启动了属性动画 (ObjectAnimator) ，但是在销毁的时候，没有调用 cancle 方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用 Activity ，这就造成 Activity 无法正常释放。因此同样要在Activity 销毁的时候 cancel 掉属性动画，避免发生内存泄漏。</pre><p>解决方法:</p><pre>@Overrideprotected void onDestroy() { super.onDestroy(); //当关闭 Activity 的时候记得关闭动画的操作 mAnimator.cancel();}</pre><p><em>6</em></p><p>内存抖动</p><p class=ql-align-justify><br></p><p><strong>什么是内存抖动</strong></p><p>内存频繁的分配与回收,(分配速度大于回收速度时) 最终产生 OOM 。</p><p><strong>也许下面的录屏更能解释什么是内存抖动</strong></p><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a830a5b3e6d44fa497a09b720cb8e34f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p>可以看出当我点击了一下 Button 内存就频繁的创建并回收（注意看垃圾桶）。</p><p><strong>那么我们找出代码中具体那一块出现问题了勒，请看下面一段录屏</strong></p><pre>mButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { imPrettySureSortingIsFree(); } });/** * 排序后打印二维数组，一行行打印 */ public void imPrettySureSortingIsFree() { int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for (int i = 0; i &lt; lotsOfInts.length; i++) { for (int j = 0; j &lt; lotsOfInts[i].length; j++) { lotsOfInts[i][j] = randomGenerator.nextInt(); } } for (int i = 0; i &lt; lotsOfInts.length; i++) { String rowAsStr = ""; //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) { rowAsStr += sorted[j]; if (j &lt; (lotsOfInts[i].length - 1)) { rowAsStr += ", "; } } Log.i("ricky", "Row " + i + ": " + rowAsStr); } }</pre><div class=pgc-img><img alt=老生常谈的内存问题你还是再来看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cb6f0fe696e4ffaa387fa97a7a9a24b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>最后我们之后是 onClick 中的 imPrettySureSortingIsFree() 函数里面的 rowAsStr += sorted[j]; 字符串拼接造成的 内存抖动 ，因为每次拼接一个 String 都会申请一块新的堆内存，那么怎么解决这个频繁开辟内存的问题了。</p><p>其实在 Java 中有 2 个更好的 API 对 String 的操作很友好，相信应该有人猜到了吧。没错就是将 此处的 String 换成 StringBuffer 或者 StringBuilder，就能很完美的解决字符串拼接造成的内存抖动问题。</p><p>修改后</p><pre>/** * 打印二维数组，一行行打印 */public void imPrettySureSortingIsFree() { int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for(int i = 0; i &lt; lotsOfInts.length; i++) { for (int j = 0; j &lt; lotsOfInts[i].length; j++) { lotsOfInts[i][j] = randomGenerator.nextInt(); } } // 使用StringBuilder完成输出，我们只需要创建一个字符串即可， 不需要浪费过多的内存 StringBuilder sb = new StringBuilder(); String rowAsStr = ""; for(int i = 0; i &lt; lotsOfInts.length; i++) { // 清除上一行 sb.delete(0, rowAsStr.length()); //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) { sb.append(sorted[j]); if(j &lt; (lotsOfInts[i].length - 1)){ sb.append(", "); } } rowAsStr = sb.toString(); Log.i("jason", "Row " + i + ": " + rowAsStr); }}</pre><p>注意: 实际开发中如果在 LogCat 中发现有这些 Log 说明也发生了 内存抖动 (Log 中出现 concurrent copying GC freed ....)</p><p><em>7</em></p><p>总结</p><p class=ql-align-justify><br></p><p>只要养成这样的习惯，至少可以避免 90 % 以上不会造成内存异常</p><p><strong>1. 数据类型: 不要使用比需求更占用空间的基本数据类型</strong></p><p><strong>2. 循环尽量用 foreach ,少用 iterator, 自动装箱也尽量少用</strong></p><p><strong>3. 数据结构与算法的解度处理 (数组，链表，栈树，树，图)</strong></p><p>数据量千级以内可以使用 Sparse 数组 (Key为整数)，ArrayMap (Key 为对象) 虽然性能不如 HashMap ，但节约内存。</p><p><strong>4. 枚举优化</strong></p><p class=ql-align-justify>缺点:</p><p class=ql-align-justify>每一个枚举值都是一个单例对象,在使用它时会增加额外的内存消耗,所以枚举相比与 Integer 和 String 会占用更多的内存.</p><p class=ql-align-justify>较多的使用 Enum 会增加 DEX 文件的大小,会造成运行时更多的 IO 开销,使我们的应用需要更多的空间</p><p class=ql-align-justify>特别是分 Dex 多的大型 APP，枚举的初始化很容易导致 ANR.</p><p class=ql-align-justify>优化后的代码:可以直接限定传入的参数个数:</p><pre>public class SHAPE { public static final int TYPE_0=0; public static final int TYPE_1=1; public static final int TYPE_2=2; public static final int TYPE_3=3; @IntDef(flag=true,value={TYPE_0,TYPE_1,TYPE_2,TYPE_3}) @Target({ElementType.PARAMETER,ElementType.METHOD,ElementType.FIELD}) @Retention(RetentionPolicy.SOURCE) public @interface Model{ } private @Model int value=TYPE_0; public void setShape(@Model int value){ this.value=value; } @Model public int getShape(){ return this.value; }}</pre><p class=ql-align-justify><br></p><p><strong>5. static , static final 的问题</strong></p><p>基本数据类型的成员，可以全写成 static final</p><p>static 会由编译器调用 clinit 方法进行初始化</p><p>static final 不需要进行初始化工作，打包在 dex 文件中可以直接调用，并不会在类初始化申请内存</p><p><strong>6. 字符串的拼接尽量少用 +=</strong></p><p><strong>7. 重复申请内存问题</strong></p><p>同一个方法多次调用，如递归函数 ，回调函数中 new 对象</p><p>不要在 onMeause() onLayout() ,onDraw() 中去刷新UI（requestLayout）</p><p><strong>8. 避免 GC 回收将来要重新使用的对象 (内存设计模式对象池 + LRU 算法)</strong></p><p><strong>9. Activity 组件泄漏</strong></p><ul><li class=ql-align-justify>如果开启的线程需要传入参数，用弱引接收可解决问题</li><li class=ql-align-justify>handler 记得清除 removeCallbacksAndMessages(null)</li><li class=ql-align-justify>非业务需要不要把 activity 的上下文做参数传递，可以传递 application 的上下文</li><li class=ql-align-justify>非静态内部类和匿名内部内会持有 activity 引用（静态内部类 或者 单独写文件）</li><li class=ql-align-justify>单例模式中回调持有 activity 引用（弱引用）</li><li class=ql-align-justify>handler.postDelayed() 问题</li></ul><p><strong>10. Service 耗时操作尽量使用 IntentService,而不是 Service</strong></p><p>来源网络，侵权联系删除</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'常谈','内存','问题'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>