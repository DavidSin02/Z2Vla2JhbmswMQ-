<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 | 极客快訊</title><meta property="og:title" content="机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/76d31ab63a7249a5abaeec98d8891354"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/5199ece.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/5199ece.html><meta property="article:published_time" content="2020-10-29T20:55:38+08:00"><meta property="article:modified_time" content="2020-10-29T20:55:38+08:00"><meta name=Keywords content><meta name=description content="机器学习总结（算法）：聚类、决策树、能量模型、LSTM等"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/5199ece.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>机器学习总结（算法）：聚类、决策树、能量模型、LSTM等</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76d31ab63a7249a5abaeec98d8891354><p class=pgc-img-caption></p></div><h1>聚类</h1><p><strong>K最近邻（KNN）</strong></p><p>KNN找到k个最近邻，利用它们的标签进行预测。例如，下面的黑点应该通过简单多数投票被分类为蓝色。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a88db14084941e6946859ed6d4db59b><p class=pgc-img-caption></p></div><p>有不同的指标来衡量距离。最常见的是欧氏距离(L2)。其他指标还包括曼哈顿距离、余弦距离、文本编辑距离、距离相关性等(更多的指标可以在scikit中找到)。通常，如果我们在进行预测时增加k的数量，则偏差会增加，而方差降低。</p><p><strong>K均值聚类</strong></p><p>K-均值聚类使用以下算法将数据点分组为K个聚类：</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5fd27ad8b8674e44b6c73be91c79795a><p class=pgc-img-caption></p></div><p>对质心进行重新估计，对数据点进行重新聚类。这个过程不断地重复，直到收敛为止。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57217d5fda0d42bfa5f731da21b13b03><p class=pgc-img-caption></p></div><p><strong>凸性</strong></p><p>K均值聚类的成本函数为</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4cdded96b97d494abd4329b65455554e><p class=pgc-img-caption></p></div><p>其中cᵢ是数据点i的聚类分配，而μⱼ是聚类j的质心。K-均值聚类算法在步骤中改进了cᵢ和μⱼ。因此，成本单调下降。但是，成本函数是非凸的。因此，该算法保证仅达到局部最优。不同的随机种子可能会导致不同的聚类。但是，通过对质心的初始猜测进行合理的随机初始化，可以产生高质量的结果。</p><p>我们还可以使用不同的随机种子重复该过程，并在选择最佳模型时使用相应的质心的总欧几里德距离。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e5a49c20a04843058a726e708d597f10><p class=pgc-img-caption></p></div><p><strong>K值</strong></p><p>那么K在K均值聚类中的合适值是多少呢?如果我们在样本中有N个数据点，如果我们使用N个聚类，我们可以训练模型为零成本。但这不是我们想要的。</p><p><em>K</em>的选择可以由明确的目标确定。例如，我们要制造尺码为XS，S，M，L和XL的T恤。因此<em>K</em>为5。我们可以研究成本下降的速度。我们可以在拐点处停下来，成本的进一步下降将有少得多的回报。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/49cd7582884245c487700e53fb8e566c><p class=pgc-img-caption></p></div><p>我们还可以监视训练数据集和验证数据集之间的误差差距。如果验证训练数据集中的误差趋于平坦或增大，则不应进一步增大<em>K。</em></p><p><strong>K-median聚类</strong></p><p>使用中位数，而不是均值聚类避免outliners。 我们还使用L1来测量距离和成本，以减少outliners的影响。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/35265ba1d4864a6d84dd76ec17f7598e><p class=pgc-img-caption></p></div><p><strong>K-均值++聚类</strong></p><p>在K-均值聚类中，我们不是一开始就随机初始化K个质心，而是一次随机选择一个质心。对于下一个质心，我们仍然随机地选择它，但是我们更倾向于选择离前一个平均值更远的数据点。这是算法</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5617fb4ea274d8ea3c72839efbfb270><p class=pgc-img-caption></p></div><p><strong>二分K均值(bisecting k-means)</strong></p><p>我们将每个聚类分成两个，但仅提交一个可以最大程度降低成本的聚类。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2516769bb7d14f939d16b9135a717dbd><p class=pgc-img-caption></p></div><p><strong>高斯混合模型（GMM）</strong></p><p>高斯混合模型是一种概率模型，它假设所有数据点都是从高斯分布的混合中生成的。</p><p>对于K＝ 2，我们将具有2个高斯分布G 1＝（μ1，σ2）和G 2＝（μ2，σ2）。我们从参数μ和σ的随机初始化开始，然后计算数据点可能属于哪个聚类的概率。然后，我们根据该概率重新计算每个高斯分布的参数μ和σ。将数据点重新拟合到不同的聚类，并再次重新计算高斯参数。迭代一直持续到解收敛为止。让我们使用EM算法来详细说明此方法。</p><p><strong>期望最大化（EM）算法（GMM）</strong></p><p>EM算法在执行期望估计(E-step)和最大化(M-step)之间交替进行。E-step计算</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/486f7015213c49a6b20857f030320cc4><p class=pgc-img-caption></p></div><p>概率p是使用高斯分布，通过使用相应聚类的xᵢ与μ之间的距离来计算的。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/672e1a8b0ca249979638f18555761a27><p class=pgc-img-caption></p></div><p>我们可以比较xᵢ的q（aᵢ）和q（bᵢ）并选择它应该属于哪个聚类。在所有计算之后，将训练数据分配给a或b。这称为hard assignment。然后，我们根据其拥有的数据点为每个聚类重新计算μ和σ。但是，这并不是GMM所做的。我们没有为一个聚类分配数据点，而是跟踪概率q（aᵢ）和q（bᵢ），即即数据点i是否属于a或b的概率。一般而言，我们计算聚类分配的概率分布而不是点估计。这称为soft assignment。我们将使用此分布作为权重，以求xᵢ在计算相应聚类的μ和σ中有多大影响。例如，聚类A的平均值是权重等于q（aᵢ）的所有数据点的加权平均值。概率模型通常具有更平滑的成本函数和较小的曲率。这使得训练更稳定。通过不将xᵢ确定地分配给一个聚类，我们允许训练更快地收敛。这是GMM的算法。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc6398f1d2c44e688cf446b600da0e60><p class=pgc-img-caption></p></div><p>以下是适用于任何混合模型（非高斯模型）的EM算法。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/69b35640c4914c80bd1c651687749928><p class=pgc-img-caption></p></div><p>对于GMM，假定聚类j的数据分布p（xᵢ|θⱼ）是高斯分布。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6deea61ac151442791b6cffd716f32e1><p class=pgc-img-caption></p></div><p>为了模拟随机变量的分布，我们可以收集样本来拟合GMM。相应的模型将比简单的高斯模型更加复杂，并且仍然是密集的(只需要很少的模型参数)。这就是为什么它在分布建模中很受欢迎，特别是对于多模态变量。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d149c020c03f4df7a3d32dcffef621ad><p class=pgc-img-caption></p></div><p><strong>自组织映射（SOM）</strong></p><p>SOM为高密度输入提供了一种低维表示。例如，我们希望计算39种索引颜色来表示图像的RGB值。我们从39个节点开始，每个节点由一个与输入维数相同的权向量表示(dim=3)。因此，对于每个节点，它都持有一个RGB值。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1f54089aa6d54dcebb2a4c3c1685b741><p class=pgc-img-caption></p></div><p>直观地，我们随机初始化所有节点。 然后我们遍历训练数据集中的所有数据点（图像的每个像素）。 我们将节点closet定位到当前数据点RGB值。 我们将当前节点及其相邻的RGB值更新为该RGB值。当我们遍历训练数据时，节点的值会发生变化，更能代表训练数据中图像像素的颜色。这里是一个概述</p><ul><li>我们从图像中随机采样一个数据点（一个像素）。</li><li>我们使用L2距离找到权重与输入接近的节点。</li><li>我们更新周围节点的权重以使其更接近输入。但是随着我们远离中心，变化下降。</li><li>我们采样下一个数据点并重复迭代。</li><li>最终，每个节点中的权重代表索引颜色的RGB值。</li></ul><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/54a15cee16d14f94ab212d134ba9fb5a><p class=pgc-img-caption></p></div><p>我们使用学习率来控制变化，并且该变化将随着距离的增加而减少，并且随着时间的推移也会减少。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a20d882626914ce6884604f96997f2bc><p class=pgc-img-caption></p></div><p>基于密度的聚类（DBSCAN）</p><p>K均值聚类无法发现流形。基于密度的聚类将相邻的高密度点连接在一起形成一个聚类。直观地说，我们逐渐向聚类添加邻近的点。这种方法允许结构在发现相邻以及流形时缓慢增长。如下所示，DBSCAN可以发现K均值无法发现的U形结构。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7fbc304411484402a1b9f7d13bd36f4e><p class=pgc-img-caption></p></div><p>若半径r内有m个可达点，则数据点为core点。core点(深绿色)与相邻的core点(浅绿色)连接形成聚类。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1ceff107bb12411d9679eeed70d78b59><p class=pgc-img-caption></p></div><p>如果我们有很多数据点，那么计算一个数据点到另一个数据点的距离就很耗时。而是将数据点划分为多个区域。我们仅连接位于相同或相邻区域中的点。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f5b50acb4fb42d1bbdf95d064d32d18><p class=pgc-img-caption></p></div><p><strong>基于密度的层次聚类</strong></p><p>基于密度的聚类最困难的部分是确定半径<em>r</em>。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d674321650d64e999f4be59fcffa851b><p class=pgc-img-caption></p></div><p>我们可以使用自上而下的层次结构方法将大型聚类分解为多个子聚类。因此，我们可以从大的r开始，然后在分解层次结构中的聚类时逐渐减小它。</p><p><strong>层次聚类</strong></p><p>还有许多其他的层次聚类方法，包括自顶向下或自下而上。这些是算法</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8d9fb2b5968045fd8b547b13472effcb><p class=pgc-img-caption></p></div><p><strong>集成聚类（UB聚类）</strong></p><p>集成聚类使用不同的随机种子运行m次K均值以生成m个模型。如果大多数模型都同意两个点应属于同一类，则可以确保它们属于同一类。集成聚类从没有聚类开始，</p><ul><li>如果两个点应该在一起，但是没有任何聚类分配，我们将为它们创建一个新的聚类。</li><li>如果分配了其中一个而没有分配另一个，我们将未分配的放到已分配的聚类中。</li><li>如果将它们分配给不同的聚类，我们会将两个聚类合并在一起。</li></ul><p><strong>Canopy聚类</strong></p><p>聚类是昂贵的。我们可以先应用Canopy聚类来形成某种形式的聚类，然后再使用更昂贵的方法来改进它。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/acbc50982faf4cad83eab33c60d314b9><p class=pgc-img-caption></p></div><h1>TF-IDF</h1><p>TF-IDF对搜索查询中文档的相关性进行评分。为了避免搜索词被利用，如果搜索词在文档中普遍存在，则得分会下降。因此，如果这个词不常见，它的得分会更高。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9fae05bc71104acd8baf2274c8e59bba><p class=pgc-img-caption></p></div><h1>决策树</h1><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29f1b4c7397348bfa6329464bb3720f3><p class=pgc-img-caption></p></div><p>从技术上讲，我们将在每个决策树桩上将输入分解到两个空间</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06674a965472475699fc6e193bf710ce><p class=pgc-img-caption></p></div><p>决策树也称为分类和回归树(CART)。决策树易于解释，易于准备数据，推理速度快。由于采用贪心法选择决策残差，且分支条件简单，模型可能精度不高，方差较大。过度拟合也是决策树中的一个常见问题。</p><p>为了进行回归，我们在特定阈值处拆分了特定特征的数据。我们通过蛮力尝试不同的特征和阈值组合，并选择最贪婪地减少L2误差的特征和阈值。树叶处的预测将是该分支中剩余数据点的平均值或中位数。</p><p>在分类决策树中，我们可以使用不同的标准来选择决策树桩。例如，我们可以计算分类误差，基尼系数或熵（稍后详细说明）。树预测将是分支数据集的多数表决。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4916e5a7763a4695a0d9a2f2fa71b261><p class=pgc-img-caption></p></div><p>在选择决策树桩之前，我们可以创建一个散点图矩阵来发现属性之间的相关性，从而使我们对如何拆分树有一些见解。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e6a7f536e62d457c9fa0c169f911d0b4><p class=pgc-img-caption></p></div><p><strong>基尼系数</strong></p><p>如果我们知道90％的数据属于第i类，其余的10％属于第j类，则可以使用相同的比率对标签进行随机猜测。实际上，我们可以做得很好。基尼系数（Gini index）衡量了我们使用这种方案做出预测的可能性有多大。如果数据很可能预测，则基尼系数会很低。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c905eb5adda46a38124a8849e1d461e><p class=pgc-img-caption></p></div><p>例，假设一班有60名学生。其中40名是男性，其中22名稍后进入engineering school，而20名女学生中有8名进入engineering school。加权基尼系数为</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/35d34ee2090a4cd0957264859549c419><p class=pgc-img-caption></p></div><p>要选择决策树桩，我们选择权重最低的基尼系数。如果来自每个分支的数据属于同一类，则基尼系数等于零。</p><p><strong>信息增益</strong></p><p>我们可以选择信息增益最高的决策树桩。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76cc5eb4f8e34a7894c20deacef4660d><p class=pgc-img-caption></p></div><p>换句话说，我们希望分支后的条件熵最小</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03a8d9e7fe354bfbb2e2f70745a062a0><p class=pgc-img-caption></p></div><p>在分支之后，我们希望熵最小。</p><p>例如，我们要预测是否要打网球。如果选择有风（true or false）作为决策树桩，则以下是信息增益的计算。首先，考虑有风，我们计算熵。然后我们计算一下，如果不刮风。然后，我们将它们组合为条件熵H（Y | X）。然后信息增益计算为：</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27685f3816d3488db18b10020ba97d30><p class=pgc-img-caption></p></div><p>这是每个步骤的详细计算</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bb55861961cc4741923d590b92983c41><p class=pgc-img-caption></p></div><p>然后，我们继续其他可能的树桩，并贪婪地选择具有最高值的树桩。</p><p><strong>减少方差</strong></p><p>减少方差可在连续空间中工作。它测量拆分之前和之后的方差。我们想选择方差减少最大的决策树桩。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc1ae77937d7463eb8e4e0bfbea09bb7><p class=pgc-img-caption></p></div><p><strong>剪枝</strong></p><p>在叶子节点包含红色或蓝色点之前，以下数据点将至少占用4级的决策树桩。在前三个拆分中，每个分支将包含相等数量的红点和蓝点。在此示例中，直到达到第四级，我们都看不到任何进展。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae1e55b2b2e94bd4bc6a459d4e9a93b7><p class=pgc-img-caption></p></div><p>为避免此问题，我们可以使树更深，并使用pruning。</p><p><strong>过度拟合</strong></p><p>对于分类问题，我们拆分树，直到每个分支的数据点属于同一类，或它们的输入属性都相同，直到我们无法进一步区分。由于数据中的噪声，这种方法很容易使机器学习模型过拟合。如前所述，我们可以在构建树后prune它。如果测试数据的验证性能得到改善，我们将从叶子到根部删除决策树桩。</p><p>其他方法包括</p><ul><li>对树的深度有严格的上限。</li><li>如果数据点数降至阈值以下，则停止进一步拆分。</li><li>要求每个叶节点具有最少数量的数据点。</li><li>设置叶节点的最大数量。</li></ul><p><strong>卡方检验</strong></p><p>我们还可以通过卡方检验来验证决策树桩是否具有统计学意义。我们可以使用卡方来度量其父代和子代之间数据分布的差异。我们评估差异是否主要是偶然的。在一定的置信水平(比如95%)，如果我们认为分布的差异可能是偶然发生的，我们应该去掉树桩。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/983d25516c7c41f38b3cc08984f8fc7c><p class=pgc-img-caption></p></div><p>例</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bc238e4798dd40d88eac4024b4607dba><p class=pgc-img-caption></p></div><p>如果卡方小于阈值T，则将删除决策树桩，因为数据分布的差异在统计上并不显著。在查找对应置信度的值T时，我们经常参考表格或卡方分布计算器。</p><p>我们还可以在选择决策树桩时使用卡方值。我们将选择价值最高的一个。</p><p><strong>弱学习者</strong></p><p>在机器学习（ML）中，我们可以构建一个弱学习器（复杂度较低的模型）以避免过度拟合。对于决策树，我们可以限制树的深度和输入特征的数量，以降低模型的复杂性。然而，这些学习者很可能带有偏见。在机器学习（ML）中，我们可以将模型捆绑在一起进行预测。如果他们是独立训练的，那么训练后的模型之间的相关性很小，他们就不太可能犯同样的错误。简单的多数表决可以消除错误并创建强有力的预测。</p><p><strong>集成方法</strong></p><p>有许多方法可以创建不同的训练模型实例。我们可以使用不同的算法、不同的种子和配置，以及在不同迭代中保存的不同模型来构建这些模型。注意避免强相关性，我们可以使用简单多数投票来解决分类问题。对于回归问题，我们可以计算平均值、加权平均值或中位数值来进行预测。</p><p><strong>Stacking</strong></p><p>在stacking中，我们在第一轮中使用多种机器学习（ML）方法进行预测。然后，我们将这些预测作为输入提供给另一个模型，以进行最终决策。</p><p><strong>Bagging</strong></p><p><strong>Bootstrapping</strong>是随机抽样和替换的通用技术。我们从数据集中选择数据，但是，可以再次选择（替换）选取的数据。即，我们一次又一次地从同一组数据中选择数据。</p><p><strong>Bagging</strong> <strong>(Bootstrap aggregated) </strong>仅将这种技术应用于通过随机采样和替换来收集数据点。采样的数据点可以重复。如果此样本数据集的大小与原始训练数据集的大小相同，我们应该期望原始数据集中只有63.2％的数据会出现在此样本数据集中。</p><p>Bagging降低了训练模型之间的相关性，因为现在输入的样本并不相同。如果我们还降低了树的深度，也可以避免过度拟合。通过使用不同采样数据集训练的捆绑模型，我们可以期望在进行预测时具有更强大的aggregated模型。</p><p>例如，我们可以有B个bootstrap数据集，每个数据集包含n个数据点。每个bootstrap均从大小为n的原始数据集中进行替换。建立B模型后，我们可以使用它们进行B独立预测。我们的最终答案可以是这些答案的中位数。</p><p><strong>随机森林</strong></p><p>随着bootstrap数据集数量的增加，由于许多数据集确实高度相关，因此集成树的性能达到了平稳状态。随机森林使用上面提到的bagging以及其他技巧。每个模型仅使用部分特征进行训练。每个模型只使用一个特征子集进行训练。如果数据有K个特征，我们将随机选择其中的平方根(K)。所以在训练一个模型之前，我们随机地预选一个特征子集并用这个特征子集训练模型。这进一步降低了模型的相关性，不同的模型会找到不同的方法来确定类。将其与bagging相结合，可提高集成方法的准确性。</p><p><strong>Boosting</strong></p><p>建立第一个模型时，我们从训练集中统一采样数据。但是对于下一次迭代，我们将更频繁地对具有错误预测的数据点进行采样。在更好地关注我们所缺乏的地方之后，第二种模式应该在那些领域表现得更好。经过k次迭代后，便建立了k个模型。在每次迭代中，我们都会跟踪每个模型的准确性，并以此来计算权重。在推理过程中，我们使用这些权重来计算使用这些模型进行预测的加权平均值。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/391a871417a9491a911e4b002fa56598><p class=pgc-img-caption></p></div><p><strong>AdaBoost</strong></p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/555dd30f25b0415f9fb105e774a6a7fe><p class=pgc-img-caption></p></div><p>通常，对于任何分类错误的数据，我们为下一次迭代设置更大的采样权重。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/724965d5425641b698c1559f398f4fdb><p class=pgc-img-caption></p></div><p>AdaBoost训练误差的上限是</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bef208dc23584d79bdbbd398c4f628f6><p class=pgc-img-caption></p></div><p>虽然我们可能在每一步都学到一个弱学习者，但是如果我们学习了足够多的机器学习模型，误差就会显著减少。</p><p><strong>基于梯度的模型</strong></p><p>在AdaBoost中，我们从表现不佳的数据点中学习。在基于梯度的模型中，我们对预测中的误差进行建模。</p><p>假设我们有一个训练数据集y = [f(100)， f(200)，…，f(800)]，用于输入100，…到800。我们想要建立一个f的模型，我们的第一个模型是使用y的平均值来建立简单的f模型，这是一个好的开始，但并不准确。接下来，我们计算预测中的残差(误差)，并用另一个模型对其进行建模。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8c3f82f1d5074bafa160eaad38ccc2a6><p class=pgc-img-caption></p></div><p>我们将继续从残差中构建简单模型，而我们的预测将所有模型结果相加。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da3f9ee4a3b14c5488a1b3c38bca2efb><p class=pgc-img-caption></p></div><p>简而言之，第一个模型输出y的平均值。第二个模型预测第一个模型的残差。第三个模型预测了第二个模型的残差。</p><p>我们将让您查看图中的解释</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eed51f7ef86b4657bd961af17894f1d0><p class=pgc-img-caption></p></div><p>这里有一种可能的方法可以建立一个回归树，在树桩条件为x>500的情况下对左边的残差进行建模。在这个模型中，当x>500时，它返回22，否则返回-13。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6a85b940d7514f3ca83d4b6b604a9c86><p class=pgc-img-caption></p></div><p>但还有其他的可能性。我们不是为残差建立模型，而是只为残差的sign建立模型。这有点奇怪，但是当我们建立足够多的残差模型时，它得到了与我们之前的例子类似的结果。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dde9171e263c40f89c6f854719d3f621><p class=pgc-img-caption></p></div><p>这些解之间有什么区别，为什么我们将这些方法称为基于梯度的方法呢？如果我们将这些基于梯度的模型与梯度下降进行比较，则它们看起来相似。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ad4683584bec4fe590f35edd5c2c17a0><p class=pgc-img-caption></p></div><p>如下所示，我们可以从L2或L1损失函数开始。如果我们采用这些损失函数的导数，则这些成本函数的梯度只是我们在先前示例中用于对残差进行建模的项的负数。对于L2损失，等效值为残差。对于L1损失，等效值是残差的sign。因此，我们的方法只是相应选定成本函数的负梯度。这就是为什么将其称为基于梯度的原因。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5c4f66f9772e403d9838fa699dbd4469><p class=pgc-img-caption></p></div><p>因此，我们可以将基于梯度的方法的概念扩展到其他成本函数，例如Huber损失。通用算法为：</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/921df640ee9147c68ba18a9503712ace><p class=pgc-img-caption></p></div><p><strong>局部集束搜索（Local beam search）</strong></p><p>搜索空间就像围棋游戏一样巨大。在局部集束搜索中，我们仅探索最有前途的搜索。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/270a5650d47a474ba23714e8fae39f5b><p class=pgc-img-caption></p></div><p><strong>回归树</strong></p><p>除了分类，我们还可以使用决策树将模型分解为sub-cases，并使用回归模型求解每个叶节点。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/056e4be666d9417aaf6e3587fbeff40c><p class=pgc-img-caption></p></div><h1>监督和无监督机器学习</h1><p>监督学习在给定输入（y = f（x））的情况下预测标签时建立模型f。训练数据集包含输入和标签（xᵢ，yᵢ）对。从概念上讲，监督学习是对P（y | x）的研究。无监督学习可以找到训练数据的模式和趋势，没有标签，我们可以将其归纳为分布P（x）的研究。在K均值聚类中，我们用K近似P（x）质心。无监督学习包括聚类，矩阵分解和序列模型。根据此分类，这里有不同的算法。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2769dbc76064c42b2682a2721c1fe12><p class=pgc-img-caption></p></div><p>在HMM中，我们对内部状态感兴趣。例如，在语音识别中，我们的观察是音频，内部状态是相应的单词。通常，此训练数据集不提供音频的字幕，因此可以归类为无监督学习。但是，监督学习和非监督学习之间的界限可能是模糊的，并且通常不是很重要。</p><h1>半监督机器学习</h1><p>在某些情况下，我们可以收集大量的培训数据，但是我们只有有限的预算来标注其中的一小部分。半监督学习使用这一小组标签来标记那些没有标记的。这里有两种不同的可能性。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7b1454000d6747bd8c88bb2b2bac9426><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8b18f749c59d4d0994d4bc265ca4f7e9><p class=pgc-img-caption></p></div><h1>模型复杂度</h1><p>当我们增加机器学习模型复杂度时，我们可能会面临过度拟合的风险，例如，GMM中的高斯模型数量，HMM中的隐藏状态数量或矩阵分解中的秩等，随着模型复杂度的增加，训练误差会减小。但是，当我们使用验证数据集验证机器学习模型时，我们将意识到验证误差会增加。在深度学习（DL）中，我们经常需要大量数据。因此，其数据集通常很大，我们经常将一部分数据专用于验证。</p><p><strong>AIC和BIC</strong></p><p>与DL问题相比，在ML中，我们收集的数据量可能少得多。 如果我们有足够的数据，则可以使用专用的验证数据集。 否则，我们可以使用rotated hold-out数据集（交叉验证）或从完整数据集（bootstrap）中随机选择验证数据。 我们可以使用这些数据来选择适当的模型复杂性，从而获得最佳性能。 为了降低复杂度，我们在成本函数中添加了正则惩罚项。 以下是两种可能的正则化。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/771b6fbe768847629d7fbc3d008d727d><p class=pgc-img-caption></p></div><p>在此公式化中，仅当成本下降大于模型参数增加的数量时，才应增加模型复杂度。 在BIC中，我们还将K乘以lnN。</p><h1>能量模型</h1><p>利用能量函数E（x），将x的概率分布定义为</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ce335f78cdc34ddfa69e9e5b6cf18739><p class=pgc-img-caption></p></div><p>在这样的模型中，高能量E（x）导致状态x的可能性很小。 我们对能量函数建模，该函数使训练数据集的P（x）最大化。 我们称Z为配分函数。 基本上，它对0到1之间的概率分布进行归一化。它对x的所有可能配置的指数函数求和。 对于具有许多状态的系统，计算Z并不容易。 通常使用近似值来解决这些问题。 接下来，让我们讨论如何对能量函数进行建模和定义。</p><p><strong>玻尔兹曼机</strong></p><p>为了提高能量模型的表示能力，我们将不可见变量（下方蓝色的隐藏单元）添加到Boltzmann机器中。白色节点是可见单元。它们代表训练数据集中的数据样本，观察到的状态或特征。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3891f377fc664de488296831f6ee53c9><p class=pgc-img-caption></p></div><p>隐藏单元是不可见的，代表我们可见单元的潜在因子。每个单元都处于二元状态<em>sᵢ∈</em> {0,1}之一<em>。</em>单元通过边缘Wᵢⱼ与其他单元完全连接。Wᵢⱼ的值表示两个节点是如何关联的。如果节点sᵢ和sⱼ正相关，我们希望Wᵢⱼ> 0。 如果它们负相关，我们希望Wᵢⱼ&lt;0。 如果有独立的，Wᵢⱼ应为零。 从概念上讲，我们希望根据其他单元及其相关性来on/off一个单元。 玻尔兹曼机的能量函数E（X）和概率分布P（X）定义为：</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a08a0fe6190a4c9c8d71cd97e533b665><p class=pgc-img-caption></p></div><p>它以线性形式表示节点和连接的能量</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/61e6ddbccd8c43158ac661f41b58180a><p class=pgc-img-caption></p></div><p>节点是on还是off取决于其连接节点的值</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00e43ccdff0741609b7f6abd8550c358><p class=pgc-img-caption></p></div><p>通过用数据训练模型，我们为训练数据集建立了能量最低的Wᵢⱼ和bᵢ值。</p><p>从某些角度看，玻尔兹曼机训练W来提取可见单元的潜在因子。 但是，玻尔兹曼机器彼此完全互连，很难训练。</p><p><strong>受限玻尔兹曼机（RBM）</strong></p><p>RBM从输入v(the observable)中提取潜在特征h。可见单元之间没有相互联系，隐藏单元也一样。它有更多的限制，但模型比玻尔兹曼机简单得多，也更容易训练。构型(v, h)的能量E(v, h)等于</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b028739789924aa091975f985c1059b0><p class=pgc-img-caption></p></div><p>为了训练模型，我们优化了训练数据的最大对数似然度（log p（v））。该目标函数（关于wᵢⱼ）的梯度等于</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3abe77e019f6470eb964374560150411><p class=pgc-img-caption></p></div><p>我们将在此梯度上使用梯度下降以稍后更新<em>wᵢⱼ</em>。</p><p>要计算下面的第一项</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/022e8520519b4cd4932cf42968a0cc26><p class=pgc-img-caption></p></div><p>v只是训练数据集中的样本。然后，我们使用以下公式计算隐藏节点j的概率分布p（hⱼ| v）。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9f2b600ed4ef4b87aacf25b623a6fa2c><p class=pgc-img-caption></p></div><p>第二项是通过Gibbs采样计算的。 我们使用梯度下降来更新模型参数wᵢⱼ</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6bf28163c24748a8aa9ce1fc83c5a874><p class=pgc-img-caption></p></div><p>第二项使用当前模型对v和h进行采样以计算期望值。即我们需要知道p（v，h | w）。分析上很难找到它。但是我们可以使用Gibbs采样估计这种期望。</p><p>Gibbs采样的一般思想是，对于联合概率p（X =x₁，x²，x₂，…，xᵢ，…），我们固定除一个参数xᵢ之外的所有X值。在某些问题中，当我们除了一个外固定其余参数，（p，…，xᵢ，...） 可能很容易建模。我们从该分布中抽取一个值，并将xᵢ设置为该采样值。然后，我们选择另一个参数，然后再次固定其余参数。我们重复该过程很多次，并且每次获得X样本。</p><p>如下所示，我们将采样的X绘制为红色点。每个X仅更改X =（x₁，x²，x₃，…，xᵢ，…）中的一个值。如图所示，采样数据将类似于联合概率p（x₁，x²，x₃，…）！</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f0a093ff3fa54117b83235bcc0352a0d><p class=pgc-img-caption></p></div><p><strong>对比散度</strong></p><p>因此，我们将结合吉布斯采样的概念和梯度下降法来训练RBM。这叫做对比散度。在RBM中，我们使用RBM模型对h和v进行交替采样。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6327f51b0f4846b09f507eef645f0d47><p class=pgc-img-caption></p></div><p>首先，我们从v的任意值开始，然后我们可以计算每个隐藏节点的概率</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/97d9f6c49f7c4aaebb49d29c55d98e1c><p class=pgc-img-caption></p></div><p>然后我们对隐藏节点的值进行采样，形成h。在第二步中，我们再次使用采样的h对v进行采样</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b0365c76f4544b8b88fbf7a84e322820><p class=pgc-img-caption></p></div><p>即使我们之做了几次，也可以在RBM中生成良好的模型参数。RBM的确切算法与所描述的略有不同。以下是训练中的算法</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ca87e4021f846708aef30c0aa127c65><p class=pgc-img-caption></p></div><p>训练模型参数中使用的公式为：</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/49fbb49d8b7e4f5a962f92b3687f3c77><p class=pgc-img-caption></p></div><p>其中<em>k</em>是迭代的第<em>k</em>次。</p><p><strong>自由能</strong></p><p>能量模型中另一个经常提到的是下面的自由能<em>F</em></p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a433949bdaa74ec0a1645bbf2aa96b2b><p class=pgc-img-caption></p></div><p>对数似然的梯度可以以自由能的形式表示</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4302a0f7b5a248a5bb984d62e5b09875><p class=pgc-img-caption></p></div><p>简而言之，可以使我们可以通过构建能量模型（通过模型参数）来最大程度地提高对数似然性。</p><h1>卷积神经网络（CNN）</h1><p>我们在每一层中使用k×k卷积来提取特征图。通过使用stride或max-pooling，我们逐渐减小了空间维度。因为CNN有很多好的资源，所以这里的描述非常简短。想知道更多细节，可参考<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6618443533286113805/?group_id=6618443533286113805" target=_blank>理解神经网络</a>和<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6659707508891845128/?group_id=6659707508891845128" target=_blank>卷积神经网络概述及示例教程</a>。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3ba55085bfb24fc7ba871a1bc369e1cc><p class=pgc-img-caption></p></div><h1>LSTM和GRU</h1><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e16a01b29f464eeca91f956e8669c15a><p class=pgc-img-caption></p></div><p>LSTM包含一系列LSTM单元。单元t在时间t负责处理输入数据x t，并且每个单元在上一个时间步都连接到LSTM单元。每个单元具有内部单元状态c t并输出隐藏状态ht。LSTM使用三个门来控制信息流。它们是forget gate，input gate和output gate。它们在图中以符号⊗表示。每个门的形式为</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1a87ed1a0d754e408eb856c2dcbd835e><p class=pgc-img-caption></p></div><p>在分别将它们与Wx和Wh相乘之后（每个门具有不同的Wx和Wh），在当前数据输入和先前的隐藏状态上应用S型函数。每个门通过与门控制执行分段乘法来控制可以传递哪些信息。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/868104ff365943f89dbce0ee21ce7fb4><p class=pgc-img-caption></p></div><p>简而言之，forget gate会忘记来自前一个内部单元状态的部分信息。input gate控制将处理输入的哪一部分和先前的隐藏状态来创建单元状态。output gate控制内部单元状态ct的哪一部分将作为隐藏状态ht输出。</p><p>在每个时间步，我们都需要创建一个单元状态。通过忘记旧单元状态的一部分以及来自当前输入和先前隐藏的附加信息来进行计算，所有这些都由下面的相应门控制。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3e608940bd2d496c8a28e9c65ce85054><p class=pgc-img-caption></p></div><p>然后，我们输出由输出门控制的新单元状态</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/522fe9279cae407a9f7202713fb4b8c6><p class=pgc-img-caption></p></div><p>GRU是RSTM（递归神经网络）的LSTM的替代方案。与LSTM相比，GRU不会维持单元状态C，使用2个门而不是3个门。在每个时间步，我们都基于先前的隐藏状态和当前输入来计算隐藏状态。</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a4539d9b8d2e44b7bf37f277a96833d3><p class=pgc-img-caption></p></div><h1>最后</h1><p>以下是机器学习（ML） /深度学习（ DL）项目的典型流程</p><div class=pgc-img><img alt=机器学习总结（算法）：聚类、决策树、能量模型、LSTM等 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b1eeaeb12dca4e3e8af039cbdecc1cf9><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'机器','学习','总结'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/a55cbbea.html alt=机器学习总结（基础）：偏差和方差、iid、分布 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a9681e5f716547e288303eae292c5b3e style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/a55cbbea.html title=机器学习总结（基础）：偏差和方差、iid、分布>机器学习总结（基础）：偏差和方差、iid、分布</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/59b3843e.html alt=机器学习总结（基础）：指数分布、矩匹配、矩阵分解等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84c47890a2c44654997e63bd5cdf0c72 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/59b3843e.html title=机器学习总结（基础）：指数分布、矩匹配、矩阵分解等>机器学习总结（基础）：指数分布、矩匹配、矩阵分解等</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>