<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>傅里叶变换算法 | 极客快訊</title><meta property="og:title" content="傅里叶变换算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/800bbf2cf19348638b4c613ebeeb438f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/557c2aa3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/557c2aa3.html><meta property="article:published_time" content="2020-11-14T20:58:34+08:00"><meta property="article:modified_time" content="2020-11-14T20:58:34+08:00"><meta name=Keywords content><meta name=description content="傅里叶变换算法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/557c2aa3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>傅里叶变换算法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>首先我们来总体了解下傅里叶变换，让各位对其有个总体大概的印象，也顺便看看傅里叶变换所涉及到的公式，究竟有多复杂：<br>以下就是傅里叶变换的4种变体<br><strong>连续傅里叶变换</strong><br>一般情况下，若“傅里叶变换”一词不加任何限定语，则指的是“连续傅里叶变换”。连续傅里叶变换将平方可积的函数f（t）表示成复指数函数的积分或级数形式。</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/800bbf2cf19348638b4c613ebeeb438f><p class=pgc-img-caption></p></div><p>这是将频率域的函数F(ω)表示为时间域的函数f（t）的积分形式。</p><p>连续傅里叶变换的逆变换 (inverse Fourier transform)为：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e9f63720a3e141389b815f49074641ba><p class=pgc-img-caption></p></div><p>即将时间域的函数f（t）表示为频率域的函数F(ω)的积分。</p><p>一般可称函数f（t）为原函数，而称函数F(ω)为傅里叶变换的像函数，原函数和像函数构成一个傅里叶变换对（transform pair）。</p><p>除此之外，还有其它型式的变换对，以下两种型式亦常被使用。在通信或是信号处理方面，常以</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0f87ba8184a04af2939dab833ef3c7a6><p class=pgc-img-caption></p></div><p>来代换，而形成新的变换对:</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f4abfb5db3d14e53aba5702d7d276c0d><p class=pgc-img-caption></p></div><p>或者是因系数重分配而得到新的变换对：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2de3bd975c544d738af32505276e6ed0><p class=pgc-img-caption></p></div><p>一种对连续傅里叶变换的推广称为分数傅里叶变换（Fractional Fourier Transform）。分数傅里叶变换(fractional Fourier transform,FRFT)指的就是傅里叶变换(Fourier transform,FT)的广义化。</p><p>分数傅里叶变换的物理意义即做傅里叶变换 a 次，其中 a 不一定要为整数；而做了分数傅里叶变换之后，信号或输入函数便会出现在介于时域(time domain)与频域(frequency domain)之间的分数域(fractional domain)。</p><p>当f（t）为偶函数（或奇函数）时，其正弦（或余弦）分量将消亡，而可以称这时的变换为余弦变换（cosine transform）或正弦变换（sine transform）.</p><p>另一个值得注意的性质是，当f（t）为纯实函数时，F(−ω) = F*(ω)成立.</p><p><strong>傅里叶级数</strong></p><p><br></p><p>连续形式的傅里叶变换其实是傅里叶级数 (Fourier series)的推广，因为积分其实是一种极限形式的求和算子而已。对于周期函数，其傅里叶级数是存在的：</p><p><br></p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d0e380d795e849c790afb96a6cb61339><p class=pgc-img-caption></p></div><p>其中Fn为复幅度。对于实值函数，函数的傅里叶级数可以写成：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/599938e412e04a299bb06124feec307f><p class=pgc-img-caption></p></div><p>其中an和bn是实频率分量的幅度。</p><p>离散时域傅里叶变换<br>离散傅里叶变换是离散时间傅里叶变换（DTFT）的特例（有时作为后者的近似）。DTFT在时域上离散，在频域上则是周期的。DTFT可以被看作是傅里叶级数的逆变换。</p><p><strong>离散傅里叶变换</strong></p><p><br></p><p>离散傅里叶变换（DFT），是连续傅里叶变换在时域和频域上都离散的形式，将时域信号的采样变换为在离散时间傅里叶变换（DTFT）频域的采样。在形式上，变换两端（时域和频域上）的序列是有限长的，而实际上这两组序列都应当被认为是离散周期信号的主值序列。即使对有限长的离散信号作DFT，也应当将其看作经过周期延拓成为周期信号再作变换。在实际应用中通常采用快速傅里叶变换以高效计算DFT。</p><p><br></p><p>为了在科学计算和数字信号处理等领域使用计算机进行傅里叶变换，必须将函数xn定义在离散点而非连续域内，且须满足有限性或周期性条件。这种情况下，使用离散傅里叶变换（DFT），将函数xn表示为下面的求和形式：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/08ef9d003efc40d3bf8510e12036ecd5><p class=pgc-img-caption></p></div><p>其中Xk是傅里叶幅度。直接使用这个公式计算的计算复杂度为O（n*n），而快速傅里叶变换（FFT）可以将复杂度改进为O（n*lgn）。（后面会具体阐述FFT是如何将复杂度降为O（n*lgn）的。）计算复杂度的降低以及数字电路计算能力的发展使得DFT成为在信号处理领域十分实用且重要的方法。</p><p>下面，比较下上述傅立叶变换的4种变体，</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/31ff496053d54fa3ae64033d578df0e0><p class=pgc-img-caption></p></div><p>如上，容易发现：函数在时（频）域的离散对应于其像函数在频（时）域的周期性。反之连续则意味着在对应域的信号的非周期性。也就是说，时间上的离散性对应着频率上的周期性。同时，注意，离散时间傅里叶变换，时间离散，频率不离散，它在频域依然是连续的。</p><p>如果，读到此，你不甚明白，大没关系，不必纠结于以上4种变体，继续往下看，你自会豁然开朗。（有什么问题，也恳请提出，或者批评指正）</p><p>ok， 本文，接下来，由傅里叶变换入手，后重点阐述离散傅里叶变换、快速傅里叶算法，到最后彻底实现FFT算法，全篇力求通俗易懂、阅读顺畅，教你彻底理解傅里叶变换算法。由于傅里叶变换，也称傅立叶变换，下文所称为傅立叶变换，同一个变换，不同叫法，读者不必感到奇怪。</p><p><br></p><p><strong>第一部分、DFT</strong></p><p><br></p><p><strong>第一章、傅立叶变换的由来</strong><br>要理解傅立叶变换，先得知道傅立叶变换是怎么变换的，当然，也需要一定的高等数学基础，最基本的是级数变换，其中傅立叶级数变换是傅立叶变换的基础公式。<br><br>一、傅立叶变换的提出</p><p><br></p><p>傅立叶是一位法国数学家和物理学家，原名是Jean Baptiste Joseph Fourier(1768-1830), Fourier于1807年在法国科学学会上发表了一篇论文，论文里描述运用正弦曲线来描述温度分布，论文里有个在当时具有争议性的决断：任何连续周期信号都可以由一组适当的正弦曲线组合而成。</p><p>当时审查这个论文拉格朗日坚决反对此论文的发表，而后在近50年的时间里，拉格朗日坚持认为傅立叶的方法无法表示带有棱角的信号，如在方波中出现非连续变化斜率。直到拉格朗日死后15年这个论文才被发表出来。<br>谁是对的呢？拉格朗日是对的：正弦曲线无法组合成一个带有棱角的信号。但是，我们可以用正弦曲线来非常逼近地表示它，逼近到两种表示方法不存在能量差别，基于此，傅立叶是对的。</p><p>为什么我们要用正弦曲线来代替原来的曲线呢？如我们也还可以用方波或三角波来代替呀，分解信号的方法是无穷多的，但分解信号的目的是为了更加简单地处理原来的信号。<br>用正余弦来表示原信号会更加简单，因为正余弦拥有原信号所不具有的性质：正弦曲线保真度。一个正余弦曲线信号输入后，输出的仍是正余弦曲线，只有幅度和相位可能发生变化，但是频率和波的形状仍是一样的。且只有正余弦曲线才拥有这样的性质，正因如此我们才不用方波或三角波来表示。</p><p>二、傅立叶变换分类<br>根据原信号的不同类型，我们可以把傅立叶变换分为四种类别：<br>1、非周期性连续信号 傅立叶变换（Fourier Transform）<br>2、周期性连续信号 傅立叶级数(Fourier Series)<br>3、非周期性离散信号 离散时域傅立叶变换（Discrete Time Fourier Transform）<br>4、周期性离散信号 离散傅立叶变换(Discrete Fourier Transform)<br>下图是四种原信号图例（从上到下，依次是FT，FS，DTFT，DFT）：</p><p></p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be7f8382e1b144f784c26ff94bd9ef60><p class=pgc-img-caption></p></div><p>这四种傅立叶变换都是针对正无穷大和负无穷大的信号，即信号的的长度是无穷大的，我们知道这对于计算机处理来说是不可能的，那么有没有针对长度有限的傅立叶变换呢？没有。因为正余弦波被定义成从负无穷小到正无穷大，我们无法把一个长度无限的信号组合成长度有限的信号。<br>面对这种困难，方法是：把长度有限的信号表示成长度无限的信号。如，可以把信号无限地从左右进行延伸，延伸的部分用零来表示，这样，这个信号就可以被看成是非周期性离散信号，我们可以用到离散时域傅立叶变换（DTFT）的方法。也可以把信号用复制的方法进行延伸，这样信号就变成了周期性离散信号，这时我们就可以用离散傅立叶变换方法（DFT）进行变换。本章我们要讲的是离散信号，对于连续信号我们不作讨论，因为计算机只能处理离散的数值信号，我们的最终目的是运用计算机来处理信号的。<br><br>但是对于非周期性的信号，我们需要用无穷多不同频率的正弦曲线来表示，这对于计算机来说是不可能实现的。所以对于离散信号的变换只有离散傅立叶变换（DFT）才能被适用，对于计算机来说只有离散的和有限长度的数据才能被处理，对于其它的变换类型只有在数学演算中才能用到，在计算机面前我们只能用DFT方法，后面我们要理解的也正是DFT方法。<br>这里要理解的是我们使用周期性的信号目的是为了能够用数学方法来解决问题，至于考虑周期性信号是从哪里得到或怎样得到是无意义的。<br><br>每种傅立叶变换都分成实数和复数两种方法，对于实数方法是最好理解的，但是复数方法就相对复杂许多了，需要懂得有关复数的理论知识，不过，如果理解了实数离散傅立叶变换(real DFT)，再去理解复数傅立叶变换就更容易了，所以我们先把复数的傅立叶变换放到一边去，先来理解实数傅立叶变换，在后面我们会先讲讲关于复数的基本理论，然后在理解了实数傅立叶变换的基础上再来理解复数傅立叶变换。<br><br>还有，这里我们所要说的变换(transform)虽然是数学意义上的变换，但跟函数变换是不同的，函数变换是符合一一映射准则的，对于离散数字信号处理（DSP），有许多的变换：傅立叶变换、拉普拉斯变换、Z变换、希尔伯特变换、离散余弦变换等，这些都扩展了函数变换的定义，允许输入和输出有多种的值，简单地说变换就是把一堆的数据变成另一堆的数据的方法。<br><br>三、一个关于实数离散傅立叶变换(Real DFT)的例子</p><p>先来看一个变换实例，下图是一个原始信号图像：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ecc14e9dc79479ba0e3f651ebbe7a75><p class=pgc-img-caption></p></div><p>这个信号的长度是16，于是可以把这个信号分解9个余弦波和9个正弦波（一个长度为N的信号可以分解成N/2+1个正余弦信号，这是为什么呢？结合下面的18个正余弦图,我想从计算机处理精度上就不难理解，一个长度为N的信号，最多只能有N/2+1个不同频率，再多的频率就超过了计算机所能所处理的精度范围），如下图：</p><p>9个余弦信号：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee4785e1e48f417086d3c4c6cd56847d><p class=pgc-img-caption></p></div><p>9个正弦信号：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a0892aa17a044509d9d8a870b3b2b2f><p class=pgc-img-caption></p></div><p>把以上所有信号相加即可得到原始信号，至于是怎么分别变换出9种不同频率信号的，我们先不急，先看看对于以上的变换结果，在程序中又是该怎么表示的，我们可以看看下面这个示例图：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/da971c95a292444aac2221360a4e2f7c><p class=pgc-img-caption></p></div><p><br>上图中左边表示时域中的信号，右边是频域信号表示方法，从左向右，-->，表示正向转换(Forward DFT)，从右向左，&lt;--，表示逆向转换(Inverse DFT)，用小写x[]表示信号在每个时间点上的幅度值数组, 用大写X[]表示每种频率的副度值数组（即时间x-->频率X）, 因为有N/2+1种频率，所以该数组长度为N/2+1，X[]数组又分两种，一种是表示余弦波的不同频率幅度值：Re X[]，另一种是表示正弦波的不同频率幅度值：Im X[]，Re是实数(Real)的意思，Im是虚数(Imagine)的意思，采用复数的表示方法把正余弦波组合起来进行表示，但这里我们不考虑复数的其它作用，只记住是一种组合方法而已，目的是为了便于表达（在后面我们会知道，复数形式的傅立叶变换长度是N，而不是N/2+1）。如此，再回过头去，看上面的正余弦各9种频率的变化，相信，问题不大了。</p><p></p><p><strong>第二章、实数形式离散傅立叶变换（Real DFT）</strong></p><p><br></p><p>上一章，我们看到了一个实数形式离散傅立叶变换的例子，通过这个例子能够让我们先对傅立叶变换有一个较为形象的感性认识，现在就让我们来看看实数形式离散傅立叶变换的正向和逆向是怎么进行变换的。在此，我们先来看一下频率的多种表示方法。<br><br>一、 频域中关于频率的四种表示方法<br><br>1、序号表示方法，根据时域中信号的样本数取0 ~ N/2，用这种方法在程序中使用起来可以更直接地取得每种频率的幅度值，因为频率值跟数组的序号是一一对应的: X[k]，取值范围是0 ~ N/2；<br>2、分数表示方法，根据时域中信号的样本数的比例值取0 ~ 0.5: X[ƒ]，ƒ = k/N，取值范围是0 ~ 1/2；<br>3、用弧度值来表示，把ƒ乘以一个2π得到一个弧度值，这种表示方法叫做自然频率(natural frequency)：X[ω]，ω = 2πƒ = 2πk/N，取值范围是0 ~ π；<br>4、以赫兹(Hz)为单位来表示，这个一般是应用于一些特殊应用，如取样率为10 kHz表示每秒有10,000个样本数：取值范围是0到取样率的一半。<br><br>二、 DFT基本函数<br><br>ck[i] = cos(2πki/N)<br>sk[i] = sin(2πki/N)<br>其中k表示每个正余弦波的频率，如为2表示在0到N长度中存在两个完整的周期，10即有10个周期，如下图：</p><p><br></p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da11c97a4e7c4654ae6f2b1ef4e9d097><p class=pgc-img-caption></p></div><p>上图中至于每个波的振幅(amplitude)值(Re X[k],Im X[k])是怎么算出来的,这个是DFT的核心，也是最难理解的部分，我们先来看看如何把分解出来的正余弦波合成原始信号(Inverse DFT)。<br><br>三、 合成运算方法(Real Inverse DFT)<br><br>DFT合成等式（合成原始时间信号，频率-->时间，逆向变换）：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c900e35ab13a41468739355909a1708f><p class=pgc-img-caption></p></div><p>如果有学过傅立叶级数，对这个等式就会有似曾相识的感觉，不错！这个等式跟傅立叶级数是非常相似的：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a6b8c86cff04d718c86bf7de5b97a27><p class=pgc-img-caption></p></div><p>当然，差别是肯定是存在的，因为这两个等式是在两个不同条件下运用的，至于怎么证明DFT合成公式，这个我想需要非常强的高等数学理论知识了，这是研究数学的人的工作，对于普通应用者就不需要如此的追根究底了，但是傅立叶级数是好理解的，我们起码可以从傅立叶级数公式中看出DFT合成公式的合理性。<br>_ _<br>DFT合成等式中的Im X[k]和Re X[k]跟之前提到的Im X[k]和Re X[k]是不一样的，下面是转换方法（关于此公式的解释，见下文）:</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6df2370462a445828954ead8d3690690><p class=pgc-img-caption></p></div><p></p><p>但k等于0和N/2时,实数部分的计算要用下面的等式:</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d7757f316384af99acab8c0215b48d9><p class=pgc-img-caption></p></div><p></p><p>上面四个式中的N是时域中点的总数，k是从0到N/2的序号。<br>为什么要这样进行转换呢？这个可以从频谱密度(spectral density)得到理解，如下图就是个频谱图：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e4cf997ddefc4512a8a162b53dc6ff86><p class=pgc-img-caption></p></div><p><br>这是一个频谱图，横座标表示频率大小，纵座标表示振幅大小，原始信号长度为N（这里是32），经DFT转换后得到的17个频率的频谱，频谱密度表示每单位带宽中为多大的振幅，那么带宽是怎么计算出来的呢？看上图，除了头尾两个，其余点的所占的宽度是2/N，这个宽度便是每个点的带宽，头尾两个点的带宽是1/N,而Im X[k]和Re X[k]表示的是频谱密度，即每一个单位带宽的振幅大小，但</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6a221f40931e480483507991f0be3fc8><p class=pgc-img-caption></p></div><p>表示2/N（或1/N）带宽的振幅大小，所以</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6a221f40931e480483507991f0be3fc8><p class=pgc-img-caption></p></div><p>分别应当是Im X[k]和Re X[k]的2/N（或1/N）。<br><br>频谱密度就象物理中物质密度，原始信号中的每一个点就象是一个混合物，这个混合物是由不同密度的物质组成的，混合物中含有的每种物质的质量是一样的，除了最大和最小两个密度的物质外，这样我们只要把每种物质的密度加起来就可以得到该混合物的密度了，又该混合物的质量是单位质量，所以得到的密度值跟该混合物的质量值是一样的。<br><br>至于为什么虚数部分是负数，这是为了跟复数DFT保持一致，这个我们将在后面会知道这是数学计算上的需要（Im X[k]在计算时就已经加上了一个负号（稍后，由下文，便可知），</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/992f73254f594f5d98b5c4fedbdde922><p class=pgc-img-caption></p></div><p>再加上负号，结果便是正的，等于没有变化）。<br><br>如果已经得到了DFT结果，这时要进行逆转换，即合成原始信号，则可按如下步骤进行转换：<br>1、先根据上面四个式子计算得出</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6a221f40931e480483507991f0be3fc8><p class=pgc-img-caption></p></div><p>的值；<br>2、再根据DFT合成等式得到原始信号数据。<br><br>四、 分解运算方法（DFT）<br><br>有三种完全不同的方法进行DFT：一种方法是通过联立方程进行求解, 从代数的角度看，要从N个已知值求N个未知值，需要N个联立方程，且N个联立方程必须是线性独立的，但这是这种方法计算量非常的大且极其复杂，所以很少被采用；第二种方法是利用信号的相关性（correlation）进行计算，这个是我们后面将要介绍的方法；第三种方法是快速傅立叶变换（FFT），这是一个非常具有创造性和革命性的的方法，因为它大大提高了运算速度，使得傅立叶变换能够在计算机中被广泛应用，但这种算法是根据复数形式的傅立叶变换来实现的，它把N个点的信号分解成长度为N的频域，这个跟我们现在所进行的实域DFT变换不一样，而且这种方法也较难理解，这里我们先不去理解，等先理解了复数DFT后，再来看一下FFT。有一点很重要，那就是这三种方法所得的变换结果是一样的，经过实践证明，当频域长度为32时，利用相关性方法进行计算效率最好，否则FFT算法效率较高。现在就让我们来看一下相关性算法。<br><br>利用第一种方法、信号的相关性(correlation)可以从噪声背景中检测出已知的信号，我们也可以利用这个方法检测信号波中是否含有某个频率的信号波：把一个待检测信号波乘以另一个信号波，得到一个新的信号波，再把这个新的信号波所有的点进行相加，从相加的结果就可以判断出这两个信号的相似程度。如下图：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ba670d64a7746dc9fc0b5ab95bd5988><p class=pgc-img-caption></p></div><p>上面a和 b两个图是待检测信号波，图a很明显可以看出是个3个周期的正弦信号波，图b的信号波则看不出是否含有正弦或余弦信号，图c和d都是个3个周期的正弦信号波，图e和f分别是a、b两图跟c、d两图相乘后的结果，图e所有点的平均值是0.5，说明信号a含有振幅为1的正弦信号c，但图f所有点的平均值是0，则说明信号b不含有信号d。这个就是通过信号相关性来检测是否含有某个信号的方法。<br><br>第二种方法：相应地，我也可以通过把输入信号和每一种频率的正余弦信号进行相乘（关联操作），从而得到原始信号与每种频率的关联程度（即总和大小），这个结果便是我们所要的傅立叶变换结果，下面两个等式便是我们所要的计算方法：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a75fb0249e345e1a0aeced4e4c0d501><p class=pgc-img-caption></p></div><p>第二个式子中加了个负号，是为了保持复数形式的一致，前面我们知道在计算</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/992f73254f594f5d98b5c4fedbdde922><p class=pgc-img-caption></p></div><p>时又加了个负号，所以这只是个形式的问题，并没有实际意义，你也可以把负号去掉，并在计算</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/992f73254f594f5d98b5c4fedbdde922><p class=pgc-img-caption></p></div><p>时也不加负号。</p><p>这里有一点必须明白一个正交的概念：两个函数相乘，如果结果中的每个点的总和为0，则可认为这两个函数为正交函数。要确保关联性算法是正确的，则必须使得跟原始信号相乘的信号的函数形式是正交的，我们知道所有的正弦或余弦函数是正交的，这一点我们可以通过简单的高数知识就可以证明它，所以我们可以通过关联的方法把原始信号分离出正余弦信号。当然，其它的正交函数也是存在的，如：方波、三角波等形式的脉冲信号，所以原始信号也可被分解成这些信号，但这只是说可以这样做，却是没有用的。</p><p><br>到此为止，我们对傅立叶变换便有了感性的认识了吧。但要记住，这只是在实域上的离散傅立叶变换，其中虽然也用到了复数的形式，但那只是个替代的形式，并无实际意义，现实中一般使用的是复数形式的离散傅立叶变换，且快速傅立叶变换是根据复数离散傅立叶变换来设计算法的。请继续关注本公号，后续我们会在理解实域离散傅立叶变换的基础上来理解复数形式的离散傅立叶变换。</p><p><strong>第三章、复数</strong></p><p>复数扩展了我们一般所能理解的数的概念，复数包含了实数和虚数两部分，利用复数的形式可以把由两个变量表示的表达式变成由一个变量(复变量)来表达，使得处理起来更加自然和方便。<br>我们知道傅立叶变换的结果是由两部分组成的，使用复数形式可以缩短变换表达式，使得我们可以单独处理一个变量（这个在后面的描述中我们就可以更加确切地知道），而且快速傅立叶变换正是基于复数形式的，所以几乎所有描述的傅立叶变换形式都是复数的形式。<br>但是复数的概念超过了我们日常生活中所能理解的概念，要理解复数是较难的，所以我们在理解复数傅立叶变换之前，先来专门复习一下有关复数的知识，这对后面的理解非常重要。<br><br>一、 复数的提出<br><br>在此，先让我们看一个物理实验：把一个球从某点向上抛出，然后根据初速度和时间来计算球所在高度，这个方法可以根据下面的式子计算得出：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/45e21321273e41d6adc353bfcdc8d1d9><p class=pgc-img-caption></p></div><p>其中h表示高度，g表示重力加速度(9.8m/s2)，v表示初速度，t表示时间。现在反过来，假如知道了高度，要求计算到这个高度所需要的时间，这时我们又可以通过下式来计算：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a86fe467e6f94b688ee1d1ad5f44d827><p class=pgc-img-caption></p></div><p></p><p>（多谢JERRY_PRI提出：</p><p>1、根据公式h=-(gt2/2)+Vt（gt后面的2表示t的平方），我们可以讨论最终情况，也就是说小球运动到最高点时，v=gt，所以，可以得到t=sqt(2h/g)<br>且在您给的公式中，根号下为1-(2h)/g，化成分数形式为(g-2h)/g，g和h不能直接做加减运算。</p><p>2、g是重力加速度，单位是m/s2，h的单位是m，他们两个相减的话在物理上没有意义，而且使用您给的那个公式反向回去的话推出的是h=-(gt2/2)+gt啊（gt后面的2表示t的平方）。</p><p>3、直接推到可以得出t=v/g±sqt((v2-2hg)/g2)（v和g后面的2都表示平方），那么也就是说当v2&lt;2hg时会产生复数，但是如果从实际的v2是不可能小于2hg的，所以我感觉复数不能从实际出发去推到，只能从抽象的角度说明一下。</p><p>）<br>经过计算我们可以知道，当高度是3米时，有两个时间点到达该高度：球向上运动时的时间是0.38秒，球向下运动时的时间是1.62秒。但是如果高度等于10时，结果又是什么呢？根据上面的式子可以发现存在对负数进行开平方运算，我们知道这肯定是不现实的。<br>第一次使用这个不一般的式子的人是意大利数学家Girolamo Cardano（1501-1576），两个世纪后，德国伟大数学家Carl Friedrich Gause（1777-1855）提出了复数的概念，为后来的应用铺平了道路，他对复数进行这样表示：复数由实数（real）和虚数(imaginary)两部分组成，虚数中的根号负1用i来表示（在这里我们用j来表示，因为i在电力学中表示电流的意思）。<br><br>我们可以把横座标表示成实数，纵座标表示成虚数，则座标中的每个点的向量就可以用复数来表示，如下图：<br></p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/007ed52f52e8472c841d389369d8cbcb><p class=pgc-img-caption></p></div><p><br>上图中的ABC三个向量可以表示成如下的式子：<br><br>A = 2 + 6j<br>B = -4 – 1.5j<br>C = 3 – 7j<br><br>这样子来表达方便之处在于运用一个符号就能把两个原来难以联系起来的数组合起来了，不方便的是我们要分辨哪个是实数和哪个是虚数，我们一般是用Re( )和Im( )来表示实数和虚数两部分，如：<br><br>Re A = 2 Im A = 6<br>Re B = -4 Im B = -1.5<br>Re C = 3 Im C = -7<br><br>复数之间也可以进行加减乘除运算：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60380731281641d6b7fdc45513bfe006><p class=pgc-img-caption></p></div><p><br><br>这里有个特殊的地方是j2等于-1，上面第四个式子的计算方法是把分子和分母同时乘以c – dj，这样就可消去分母中的j了。<br><br>复数也符合代数运算中的交换律、结合律、分配律：<br><br>A B = B A<br>(A + B) + C = A + (B + C)<br>A(B + C) = AB + AC<br><br><br>二、 复数的极座标表示形式<br><br>前面提到的是运用直角座标来表示复数，其实更为普遍应用的是极座标的表示方法，如下图：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ce7fa6449004934847711ecd0d694cd><p class=pgc-img-caption></p></div><p><br>上图中的M即是数量积(magnitude)，表示从原点到座标点的距离，θ是相位角(phase angle)，表示从X轴正方向到某个向量的夹角，下面四个式子是计算方法：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0e0d6b52ecd34b4496ab0cbff027d4f8><p class=pgc-img-caption></p></div><p><br>我们还可以通过下面的式子进行极座标到直角座标的转换：<br><br>a + jb = M (cosθ + j sinθ)</p><p>上面这个等式中左边是直角座标表达式，右边是极座标表达式。<br><br>还有一个更为重要的等式——欧拉等式（欧拉，瑞士的著名数学家，Leonhard Euler，1707-1783）：<br>ejx = cos x + j sin x<br><br>这个等式可以从下面的级数变换中得到证明：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ac5994bee7849f180002359dd34aed5><p class=pgc-img-caption></p></div><p>上面中右边的两个式子分别是cos(x)和sin(x)的泰勒(Taylor)级数。<br></p><p>这样子我们又可以把复数的表达式表示成指数的形式了：<br><br>a + jb = M ejθ （这便是复数的两个表达式）<br><br>指数形式是数字信号处理中数学方法的支柱，也许是因为用指数形式进行复数的乘除运算极为简单的缘故吧：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8e166ba28b3146899f67621462706b97><p class=pgc-img-caption></p></div><p></p><p>三、复数是数学分析中的一个工具<br><br>为什么要使用复数呢？其实它只是个工具而已，就如钉子和锤子的关系，复数就象那锤子，作为一种使用的工具。我们把要解决的问题表达成复数的形式（因为有些问题用复数的形式进行运算更加方便），然后对复数进行运算，最后再转换回来得到我们所需要的结果。<br><br>有两种方法使用复数，一种是用复数进行简单的替换，如前面所说的向量表达式方法和前一节中我们所讨论的实域DFT，另一种是更高级的方法：数学等价(mathematical equivalence)，复数形式的傅立叶变换用的便是数学等价的方法，但在这里我们先不讨论这种方法，这里我们先来看一下用复数进行替换中的问题。<br><br>用复数进行替换的基本思想是：把所要分析的物理问题转换成复数的形式，其中只是简单地添加一个复数的符号j，当返回到原来的物理问题时，则只是把符号j去掉就可以了。<br><br>有一点要明白的是并不是所有问题都可以用复数来表示，必须看用复数进行分析是否适用，有个例子可以看出用复数来替换原来问题的表达方式明显是谬误的：假设一箱的苹果是5美元，一箱的桔子是10美元，于是我们把它表示成 5 + 10j，有一个星期你买了6箱苹果和2箱桔子，我们又把它表示成6 + 2j，最后计算总共花的钱是(5 + 10j)(6 + 2j) = 10 + 70j，结果是买苹果花了10美元的，买桔子花了70美元，这样的结果明显是错了，所以复数的形式不适合运用于对这种问题的解决。<br><br>四、用复数来表示正余弦函数表达式<br><br>对于象M cos (ωt + φ)和A cos(ωt ) + B sin(ωt )表达式，用复数来表示，可以变得非常简洁，对于直角座标形式可以按如下形式进行转换：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7128b58167af47959f7bf6f98054caba><p class=pgc-img-caption></p></div><p><br>上式中余弦幅值A经变换生成a，正弦幅值B的相反数经变换生成b：A &lt;=> a，B&lt;=> -b，但要注意的是，这不是个等式，只是个替换形式而已。<br><br>对于极座标形式可以按如下形式进行转换：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a97b54db40644c238f1087578c43b5c7><p class=pgc-img-caption></p></div><p><br><br>上式中，M &lt;=> M，θ&lt;=>φ。<br>这里虚数部分采用负数的形式主要是为了跟复数傅立叶变换表达式保持一致，对于这种替换的方法来表示正余弦，符号的变换没有什么好处，但替换时总会被改变掉符号以跟更高级的等价变换保持形式上的一致。<br><br>在离散信号处理中，运用复数形式来表示正余弦波是个常用的技术，这是因为利用复数进行各种运算得到的结果跟原来的正余弦运算结果是一致的，但是，我们要小心使用复数操作，如加、减、乘、除，有些操作是不能用的，如两个正弦信号相加，采用复数形式进行相加，得到的结果跟替换前的直接相加的结果是一样的，但是如果两个正弦信号相乘，则采用复数形式来相乘结果是不一样的。幸运的是，我们已严格定义了正余弦复数形式的运算操作条件：<br>1、参加运算的所有正余弦的频率必须是一样的；<br>2、运算操作必须是线性的，如两个正弦信号可以进行相加减，但不能进行乘除，象信号的放大、衰减、高低通滤波等系统都是线性的，象平方、缩短、取限等则不是线性的。要记住的是卷积和傅立叶分析也只有线性操作才可以进行。<br><br>下图是一个相量变换(我们把正弦或余弦波变成复数的形式称为相量变换，Phasor transform)的例子，一个连续信号波经过一个线性处理系统生成另一个信号波，从计算过程我们可以看出采用复数的形式使得计算变化十分的简洁：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8865f5b439d646f6b7a1cbdad75ecfa7><p class=pgc-img-caption></p></div><p><br>在第二章中我们描述的实数形式傅立叶变换也是一种替换形式的复数变换，但要注意的是那还不是复数傅立叶变换，只是一种代替方式而已。下一章、即，第四章，我们就会知道复数傅立叶变换是一种更高级的变换，而不是这种简单的替换形式。</p><p></p><p><strong>第四章、复数形式离散傅立叶变换</strong></p><p>复数形式的离散傅立叶变换非常巧妙地运用了复数的方法，使得傅立叶变换变换更加自然和简洁，它并不是只是简单地运用替换的方法来运用复数，而是完全从复数的角度来分析问题，这一点跟实数DFT是完全不一样的。<br><br>一、 把正余弦函数表示成复数的形式</p><p>通过欧拉等式可以把正余弦函数表示成复数的形式：<br><br>cos( x ) = 1/2 e j(-x) + 1/2 ejx<br>sin( x ) = j (1/2 e j(-x) - 1/2 ejx)</p><p>从这个等式可以看出，如果把正余弦函数表示成复数后，它们变成了由正负频率组成的正余弦波，相反地，一个由正负频率组成的正余弦波，可以通过复数的形式来表示。<br><br>我们知道，在实数傅立叶变换中，它的频谱是0 ~ π(0 ~ N/2),但无法表示-π~ 0的频谱，可以预见，如果把正余弦表示成复数形式，则能够把负频率包含进来。<br><br>二、 把变换前后的变量都看成复数的形式<br><br>复数形式傅立叶变换把原始信号x[n]当成是一个用复数来表示的信号，其中实数部分表示原始信号值，虚数部分为0，变换结果X[k]也是个复数的形式，但这里的虚数部分是有值的。<br>在这里要用复数的观点来看原始信号，是理解复数形式傅立叶变换的关键（如果有学过复变函数则可能更好理解，即把x[n]看成是一个复数变量，然后象对待实数那样对这个复数变量进行相同的变换）。<br><br>三、 对复数进行相关性算法（正向傅立叶变换）<br><br>从实数傅立叶变换中可以知道，我们可以通过原始信号乘以一个正交函数形式的信号，然后进行求总和，最后就能得到这个原始信号所包含的正交函数信号的分量。</p><p>现在我们的原始信号变成了复数，我们要得到的当然是复数的信号分量，我们是不是可以把它乘以一个复数形式的正交函数呢？答案是肯定的，正余弦函数都是正交函数，变成如下形式的复数后，仍旧还是正交函数（这个从正交函数的定义可以很容易得到证明）：</p><p>cos x + j sin x, cos x – j sin x，……<br><br>这里我们采用上面的第二个式子进行相关性求和，为什么用第二个式子呢?，我们在后面会知道，正弦函数在虚数中变换后得到的是负的正弦函数，这里我们再加上一个负号，使得最后的得到的是正的正弦波，根据这个于是我们很容易就可以得到了复数形式的DFT正向变换等式：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b8ea215fb6347d0826e86ccff791b85><p class=pgc-img-caption></p></div><p><br>这个式子很容易可以得到欧拉变换式子：<br></p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a5794a32ccc41a385efb45a79d8683c><p class=pgc-img-caption></p></div><p><br><br>其实我们是为了表达上的方便才用到欧拉变换式，在解决问题时我们还是较多地用到正余弦表达式。<br><br>对于上面的等式，我们要清楚如下几个方面（也是区别于实数DFT的地方）：<br>1、X[k]、x[n]都是复数，但x[n]的虚数部分都是由0组成的，实数部分表示原始信号；<br>2、k的取值范围是0 ~ N-1 (也可以表达成0 ~ 2π)，其中0 ~ N/2（或0 ~ π）是正频部分，</p><p>N/2 ~ N-1（π~ 2π）是负频部分，由于正余弦函数的对称性，所以我们把 –π~ 0表示成π~ 2π，这是出于计算上方便的考虑。<br>3、其中的j是一个不可分离的组成部分，就象一个等式中的变量一样，不能随便去掉，去掉之后意义就完全不一样了，但我们知道在实数DFT中，j只是个符号而已，把j去掉，整个等式的意义不变；<br>4、下图是个连续信号的频谱，但离散频谱也是与此类似的，所以不影响我们对问题的分析：</p><div class=pgc-img><img alt=傅里叶变换算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f29c838de274caebbcc28f2e824d625><p class=pgc-img-caption></p></div><p></p><p><br>上面的频谱图把负频率放到了左边，是为了迎合我们的思维习惯，但在实际实</p><p>现中我们一般是把它移到正的频谱后面的。</p><p>从上图可以看出，时域中的正余弦波（用来组成原始信号的正余弦波）在复数DFT的频谱中被分成了正、负频率的两个组成部分，基于此等式中前面的比例系数是1/N（或1/2π），而不是2/N，这是因为现在把频谱延伸到了2π,但把正负两个频率相加即又得到了2/N,又还原到了实数DFT的形式，这个在后面的描述中可以更清楚地看到。</p><p>由于复数DFT生成的是一个完整的频谱，原始信号中的每一个点都是由正、负两个频率组合而成的，所以频谱中每一个点的带宽是一样的，都是1/N，相对实数DFT，两端带宽比其它点的带宽少了一半；复数DFT的频谱特征具有周期性：-N/2 ~ 0与N/2 ~ N-1是一样的，实域频谱呈偶对称性（表示余弦波频谱），虚域频谱呈奇对称性（表示正弦波频谱）。<br></p><p>四、 逆向傅立叶变换<br><br>假设我们已经得到了复数形式的频谱X[k]，现在要把它还原到复数形式的原始信号x[n]，当然应该是把X[k]乘以一个复数，然后再进行求和，最后得到原始信号x[n]，这个跟X[k]相乘的复数首先让我们想到的应该是上面进行相关性计算的复数：</p><p>cos(2πkn/N) – j si(2πkn/N)，<br><br>但其中的负号其实是为了使得进行逆向傅立叶变换时把正弦函数变为正的符号，因为虚数j的运算特殊性，使得原来应该是正的正弦函数变为了负的正弦函数（我们从后面的推导会看到这一点），所以这里的负号只是为了纠正符号的作用，在进行逆向DFT时，我们可以把负号去掉，于是我们便得到了这样的逆向DFT变换等式：</p><p>x[n] = X[k] (cos(2πkn/N) + j sin(2πkn/N))</p><p>我们现在来分析这个式子，会发现这个式其实跟实数傅立叶变换是可以得到一样结果的。我们先把X[k]变换一下：</p><p>X[k] = Re X[k] + j Im X[k]</p><p>这样我们就可以对x[n]再次进行变换，如：</p><p>x[n] = (Re X[k] + j Im X[k]) (cos(2πkn/N) + j sin(2πkn/N))</p><p>= ( Re X[k] cos(2πkn/N) + j Im X[k] cos(2πkn/N) +j Re X[k] sin(2πkn/N) - Im X[k] sin(2πkn/N) )</p><p>= ( Re X[k] （cos(2πkn/N) + j sin(2πkn/N)） + ---------------------(1)</p><p>Im X[k] （ - sin(2πkn/N) + j cos(2πkn/N))） ---------------------(2)</p><p></p><p>这时我们就把原来的等式分成了两个部分，第一个部分是跟实域中的频谱相乘，第二个部分是跟虚域中的频谱相乘，根据频谱图我们可以知道，Re X[k]是个偶对称的变量，Im X[k]是个奇对称的变量，即</p><p>Re X[k] = Re X[- k]<br>Im X[k] = - Im X[-k]</p><p>但k的范围是0 ~ N-1，0~N/2表示正频率，N/2~N-1表示负频率，为了表达方便我们把N/2~N-1用-k来表示，这样在从0到N-1的求和过程中对于(1)和(2)式分别有N/2对的k和-k的和，对于（1）式有：</p><p>Re X[k] (cos(2πkn/N) + j sin(2πkn/N)) + Re X[- k] (cos( - 2πkn/N) + j sin( -2πkn/N))</p><p>根据偶对称性和三角函数的性质，把上式化简得到：<br><br>Re X[k] (cos(2πkn/N) + j sin(2πkn/N)) + Re X[ k] (cos( 2πkn/N) - j sin( 2πkn/N))</p><p>这个式子最后的结果是：</p><p>2 Re X[ k] cos(2πkn/N)。<br><br>再考虑到求Re X[ k]等式中有个比例系数1/N，把1/N乘以2，这样的结果不就是跟实数DFT中的式子一样了吗？<br><br>对于(2)式，用同样的方法，我们也可以得到这样的结果：</p><p>-2 Im X[k] sin(2πkn/N)</p><p>注意上式前面多了个负符号，这是由于虚数变换的特殊性造成的，当然我们肯定不能把负符号的正弦函数跟余弦来相加，还好，我们前面是用cos(2πkn/N) – j sin(2πkn/N)进行相关性计算，得到的Im X[k]中有个负的符号，这样最后的结果中正弦函数就没有负的符号了，这就是为什么在进行相关性计算时虚数部分要用到负符号的原因（我觉得这也许是复数形式DFT美中不足的地方，让人有一种拼凑的感觉）。<br><br>从上面的分析中可以看出，实数傅立叶变换跟复数傅立叶变换，在进行逆变换时得到的结果是一样的，只不过是殊途同归吧。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'傅里叶','变换','算法'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>