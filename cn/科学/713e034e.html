<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>《操作系统原理》实验一：进程调度 | 极客快訊</title><meta property="og:title" content="《操作系统原理》实验一：进程调度 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/ab086232c51f49b3a24e3ade7c99d9ce"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/713e034e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/713e034e.html><meta property="article:published_time" content="2020-11-14T20:51:44+08:00"><meta property="article:modified_time" content="2020-11-14T20:51:44+08:00"><meta name=Keywords content><meta name=description content="《操作系统原理》实验一：进程调度"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/713e034e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>《操作系统原理》实验一：进程调度</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>操作系统原理实验—进程调度实验报告</p><p>一、目的与要求</p><p>（1）进程是操作系统最重要的概念之一，进程调度是操作系统内核的重要功能，本实验选用XX语言编写了一个进程调度模拟程序，使用优先级或时间的轮转法实现进程调度。本实验可加深对进程调度算法的理解。</p><p>（2）按照实验题目要求独立地、正确地完成实验内容（编写、调试算法程序，提交程序清单及相关实验数据与运行结果，完成个人实验报告）。</p><p>（3）2020年6月5日以前提交本次实验报告（含实验所有电子文档和纸质报告，实验相关文件打包以 学号-姓名-实验1.rar 为名命名，实验报名以 学号-姓名-实验1为文件名，由学习委员以班为单位统一打包提交）。</p><p>2 实验内容或题目</p><p>（1）设计有5个或5个以上进程并发执行的模拟调度程序，每个程序由一个PCB表示。</p><p>（2）模拟调度程序可任选两种调度算法之一实现，也可实验两个或两个以上调度算法。</p><p>（3）程序执行中应能在屏幕上显示出各进程的状态变化，以便于观察调度的整个过程。</p><p>（4）本次实验内容（项目）的详细说明以及要求请参见实验指导书。</p><p><br></p><p>3 实验步骤与源程序</p><p>1. 算法原理</p><p>时间片轮转调度算法</p><p>1) 时间片轮转算法的思想是，让队列中运行的每个进程都可以得到平等的运行时间片，然后对队列进行循环直到所有进程执行完毕。</p><p>2) 对于时间片大小的选取是十分重要的，既不能太大，如果太大的话会导致短进程无法作业运行，如果时间片太小的话效率又会减小很多。所以对于时间片来讲要根据进程的大小选择合理的时间片</p><p>3) 进程的切换机制体现出了时间片轮转算法的特点。若一个进程在时间片还没结束时就已完成，就将它从队列中移除。若一个进程在时间片结束时还没运行完成，等待下次运行。</p><p>4) 本次实验的时间片轮转算法采用c语言对算法进行模拟，采用的时间片为3直到系统需要的时间片都小于0结束</p><p>优先级调度算法</p><p>1） 由于时间的轮转算法，无法对进程的紧急情况进行区分。因此又提出了优先级调度算法，从而解决进程优先级的问题。</p><p>2） 进程优先级的确定同样重要，进程优先级可以分为静态优先级和动态优先部，静优先级是在通程创建里初期就被确定的值，此后不再更改。动态优先级指进程在创建时被赋子一个初值，此后其值会所进程的推进或等待时间的增加而改变。</p><p>3） 本次实验的优先级调度算法采用C语言对算法进行模拟，优先级选择初始化随机数据1-5，当need满足的时候将进程优先级设置为-100。</p><p>2. 程序流程图</p><p><br></p><p>时间片轮转算法执行流程图：</p><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ab086232c51f49b3a24e3ade7c99d9ce><p class=pgc-img-caption></p></div><p>优先级调度算法执行流程图：</p><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7ff23161294349c298dc261d936a14d7><p class=pgc-img-caption></p></div><p><br></p><p>3. 程序代码及注释</p><p>/**</p><p>时间的轮转算法！！！</p><p>*/</p><p><br></p><p>#include &lt;stdio.h></p><p>#include &lt;conio.h></p><p>#include &lt;stdlib.h></p><p>#include &lt;time.h></p><p><br></p><p>#define spand 3//设置时间片长度为3</p><p><br></p><p>typedef struct pcd</p><p>{</p><p>int id;//进程ID</p><p>int span;//运行进程的时间片数</p><p>int used;//已用的时间片数</p><p>int need;//进程需要运行的时间</p><p>char status;//进程状态</p><p>struct PCB *next;</p><p>} PCB;</p><p><br></p><p>PCB *head,p[5],t[5];</p><p><br></p><p>//打印</p><p>void print()</p><p>{</p><p>int i,temp;</p><p>printf("---------------------------------\n");</p><p>printf("ID \t span\tused\tneed\tstatus\n");</p><p><br></p><p>for(i=0; i &lt; 5; i++)</p><p>{</p><p>printf("%d\t%d\t%d\t%d\t%c\n",p[i].id,p[i].span,p[i].used,p[i].need,p[i].status);</p><p>}</p><p><br></p><p>}</p><p><br></p><p>//初始化进程队列</p><p>void inputprocess()</p><p>{</p><p>int i;</p><p>srand(time(0));//为随机数产生种子；</p><p><br></p><p>for(i = 0; i &lt; 5; i++)</p><p>{</p><p>p[i].id = i + 1;</p><p>p[i].span= 3;</p><p>p[i].used=0;</p><p>p[i].need=5+rand()%6;//为总的时间片产生5-10的整数</p><p>p[i].status='J';</p><p>}</p><p><br></p><p>head = p;</p><p>printf("开始进程的状态：\n");</p><p>print();//打印进程状态</p><p><br></p><p>}</p><p><br></p><p>//时间的轮转算法</p><p>void runprocess()</p><p>{</p><p><br></p><p>int i=0;</p><p><br></p><p>while(p[0].need > 0 ||p[1].need > 0||p[2].need > 0||p[3].need > 0||p[4].need > 0)//当需求有一个未被满足时进程继续执行</p><p>{</p><p><br></p><p>p[i%5].used += 3;</p><p>p[i%5].need -= 3;</p><p>p[i%5].status = 'R';</p><p>if(p[i%5].need &lt;= 0)//如果进程已被满足调用下一个进程</p><p>{</p><p>p[i%5].status='F';</p><p>i++;</p><p><br></p><p>}</p><p>else if(p[i%5].need &lt;= 0 && p[(i%5)+1].need &lt;= 0)//如果连续两个进程已被满足调用下一个进程</p><p>{</p><p>p[i%5].status='F';</p><p>i++;</p><p>}</p><p>else if(p[i%5].need &lt;= 0 && p[(i%5)+1].need &lt;= 0 && p[(i%5)+2].need &lt;= 0)//如果连续三个进程已被满足调用下一个进程</p><p>{</p><p>p[i%5].status='F';</p><p>i++;</p><p>}</p><p>else if(p[i%5].need &lt;= 0 && p[(i%5)+1].need &lt;= 0 && p[(i%5)+2].need &lt;= 0 && p[(i%5)+3].need &lt;= 0)////如果连续三个进程已被满足调用下一个进程</p><p>{</p><p>p[i%5].status='F';</p><p>i++;</p><p>}</p><p>print();//打印进程状态</p><p>if(p[i%5].status=='R')//如果本次进程执行完毕将程序由运行状态置为就绪状态</p><p>{</p><p>p[i%5].status = 'J';</p><p>}</p><p>i++;</p><p><br></p><p>}</p><p><br></p><p>}</p><p><br></p><p>int main(void)</p><p>{</p><p>inputprocess();</p><p>runprocess();</p><p><br></p><p>return 0;</p><p>}</p><p><br></p><p>/**</p><p>优先级调度算法</p><p>*/</p><p><br></p><p>#include &lt;stdio.h></p><p>#include &lt;conio.h></p><p>#include &lt;stdlib.h></p><p><br></p><p>typedef struct pcd</p><p>{</p><p>int id;//进程ID</p><p>int prior;//进程优先级</p><p>int used;//已使用时间</p><p>int need;//还需时间</p><p>char status;//进程状态</p><p>} PCB;</p><p><br></p><p>PCB *head,p[5],a[5];</p><p><br></p><p>//将每次进程调度的结果打印在屏幕上</p><p>void print()</p><p>{</p><p>int i,temp;</p><p>printf("---------------------------------\n");</p><p>printf("ID \t prior\tused\tneed\tstatus\n");</p><p><br></p><p>for(i=0; i &lt; 5; i++)</p><p>{</p><p>printf("%d\t%d\t%d\t%d\t%c\n",p[i].id,p[i].prior,p[i].used,p[i].need,p[i].status);</p><p>}</p><p><br></p><p>}</p><p><br></p><p>//根据进程的优先级进行排序为下一次进程调度做准备</p><p>void sort()</p><p>{</p><p>int i,j;</p><p>//PCB temp;</p><p><br></p><p>for(i=0; i &lt; 5; i++)</p><p>{</p><p>for(j = 0; j &lt;4-i;j++)</p><p>{</p><p>if(p[j].prior &lt;p[j+1].prior)</p><p>{</p><p>PCB temp = p[j];</p><p>p[j] = p[j+1];</p><p>p[j+1] = temp;</p><p><br></p><p>}</p><p><br></p><p>}</p><p>}</p><p>}</p><p><br></p><p>//初始化进程队列</p><p>void inputprocess()</p><p>{</p><p>int i;</p><p><br></p><p>for(i = 0; i &lt; 5; i++)</p><p>{</p><p>p[i].id = i + 1;</p><p>p[i].prior = rand()%5+1;//随机生成1-5的整数</p><p>p[i].used = 0;</p><p>p[i].need = 5+rand()%6;//为总的时间片产生5-10的整数</p><p>p[i].status = 'W';</p><p><br></p><p>}</p><p><br></p><p>sort();//按优先级排序</p><p>head = p;</p><p>printf("开始进程的状态：\n");</p><p>print();//打印进程状态</p><p><br></p><p>}</p><p><br></p><p>//按最高优先级调度进程队列</p><p>void runprocess()</p><p>{</p><p>PCB *p1 = NULL;</p><p><br></p><p>do{</p><p><br></p><p>p1 = head;</p><p>head = p+1;</p><p><br></p><p>printf("***%d***%d***\n",p1->prior,head->prior);</p><p><br></p><p>while((p1->need > 0)&&(p1->prior >= head->prior))//如果p1的需求数大于0并且 当前进程的优先级大于等于它下面一个进程的优先级</p><p>{</p><p>p1->need--;</p><p>p1->prior--;</p><p>p1->used++;</p><p>p1->status='R';</p><p>print();</p><p>}</p><p><br></p><p>if(p1->need == 0)//如果当前进程的需求为0时将优先级置为-100说明该进程运行完毕</p><p>{</p><p>p1->prior = -100;</p><p>p1->status = 'F';</p><p>}</p><p>else//否则将该进程置为等待状态为下一次运行做准备</p><p>{</p><p>p1->status='W';</p><p>}</p><p>sort();</p><p>head = p;</p><p>}</p><p>while(head->prior != -100);</p><p>print();//显示最后各个进程的状态</p><p><br></p><p>printf("--------------------------\n");</p><p>printf("所有进程全部完成！！！");</p><p>}</p><p><br></p><p>int main()</p><p>{</p><p>inputprocess();//调用初始化进程自定义函数</p><p>runprocess();//调用调度程序的函数</p><p>return(1);</p><p>}</p><p><br></p><p>4 测试数据与实验结果（可以抓图粘贴）</p><p>1. 时间的轮转算法测试数据及结果：</p><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b5d158e1876540199b2a51858654ee73><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/db36c5b4e3d643e8bb3ede3a78dc507e><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1cd0ff29bb7493f87bf6cf96561c548><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3c4ff2cbe85b46bd8ef00cffa600a3ee><p class=pgc-img-caption></p></div><p><br></p><p>直到全部need小于等于0时所有进程运行完成</p><p><br></p><p>2.优先级调度算法测试数据及结果：</p><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7a8aab9ae1b949949f912ac6e36e77f1><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=《操作系统原理》实验一：进程调度 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/107700b6b5c34e96801cd4ae81a6d7ee><p class=pgc-img-caption></p></div><p><br></p><p>5 结果分析与实验体会</p><p>本次实验使用了时间片轮转算法与优先级调度算法并用C语言进行算法进程模拟。使我对C语言编写有了更加深刻的理解，同时对两个算法的原理也有了更加深刻的理解。使我以后对操作系统的调度算法能够运用的更加熟练。</p><p>6.分析与思考</p><p>1、逻辑时间片该如何实现?</p><p>答:系统将所有的就绪进程按先来先服务算法的原则，排成- 一个队列，每次调度时，系队列首进程，并让其执行一一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序根据这个请求停止该进程的运行，将它送到就绪队列的末尾，再把处理机分给就绪队列中</p><p>新的队首进程，同时让它也执行一一个时间片。</p><p>2、如果不使用指针操作，是否也可以使用数组实现进程就绪队列的组织?</p><p>答:可以</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'系统','实验','进程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>