<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>力扣1514——概率最大的路径 | 极客快訊</title><meta property="og:title" content="力扣1514——概率最大的路径 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5b3a5789ae2f47f89971a60551cc5128"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/78ab404.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/78ab404.html><meta property="article:published_time" content="2020-10-29T20:56:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:56:28+08:00"><meta name=Keywords content><meta name=description content="力扣1514——概率最大的路径"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/78ab404.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>力扣1514——概率最大的路径</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>本题主要和图的遍历求解最短路径相关，可以用 Dijkstra 或者 Bellman-Ford 算法进行解决。</p><h1 class=pgc-h-arrow-right>原题</h1><p>给你一个由 n 个节点（下标从 0 开始）组成的无向加权图，该图由一个描述边的列表组成，其中 edges[i] = [a, b] 表示连接节点 a 和 b 的一条无向边，且该边遍历成功的概率为 succProb[i] 。</p><p>指定两个节点分别作为起点 start 和终点 end ，请你找出从起点到终点成功概率最大的路径，并返回其成功概率。</p><p>如果不存在从 start 到 end 的路径，请 返回 0 。只要答案与标准答案的误差不超过 1e-5 ，就会被视作正确答案。</p><p>示例 1：</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b3a5789ae2f47f89971a60551cc5128><p class=pgc-img-caption></p></div><pre><code>输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2输出：0.25000解释：从起点到终点有两条路径，其中一条的成功概率为 0.2 ，而另一条为 0.5 * 0.5 = 0.25</code></pre><p>示例 2：</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5bd4088dab6743bf9bc34832848b47bf><p class=pgc-img-caption></p></div><pre><code>输入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2输出：0.30000</code></pre><p>示例 3：</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e808bd20f85b47d391fdf998cc4483ce><p class=pgc-img-caption></p></div><pre><code>输入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2输出：0.00000解释：节点 0 和 节点 2 之间不存在路径</code></pre><p>提示：</p><ul><li>2 &lt;= n &lt;= 10^4</li><li>0 &lt;= start, end &lt; n</li><li>start != end</li><li>0 &lt;= a, b &lt; n</li><li>a != b</li><li>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</li><li>0 &lt;= succProb[i] &lt;= 1</li><li>每两个节点之间最多有一条边</li></ul><h1 class=pgc-h-arrow-right>解题</h1><h1 class=pgc-h-arrow-right>首次尝试</h1><p>原本，我想利用树的深度优先搜索遍历，加上一定程度的剪枝（就是排除已经遍历过的节点），完成这道题目，代码如下：</p><pre><code>class Solution {    /**     * key为起始点，value为所有相连的点     */    Map&lt;Integer, Set&lt;Integer&gt;&gt; map;    /**     * key为"点A_点B"(A &lt; B)，value为对应的概率     */    Map&lt;String, Double&gt; probMap;    double maxProb = -1;    int end;    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {        map = new HashMap&lt;&gt;(n * 4 / 3 + 1);        probMap = new HashMap&lt;&gt;(succProb.length * 4 / 3 + 1);        this.end = end;        // 构造每个点的相连关系        for (int i = 0; i &lt; edges.length; i++) {            int[] edge = edges[i];            Set&lt;Integer&gt; set = map.computeIfAbsent(edge[0], k -&gt; new HashSet&lt;&gt;());            set.add(edge[1]);            set = map.computeIfAbsent(edge[1], k -&gt; new HashSet&lt;&gt;());            set.add(edge[0]);            String key = edge[0] &lt; edge[1] ? (edge[0] + "_" + edge[1]) : (edge[1] + "_" + edge[0]);            probMap.put(key, succProb[i]);        }        boolean[] visited = new boolean[n];        dp(start, 1, visited);        return maxProb == -1 ? 0 : maxProb;    }    public void dp(int index, double prob, boolean[] visited) {        // 已到终点        if (index == end) {            maxProb = prob &gt; maxProb ? prob : maxProb;            return;        }        // 获取当前点可以到达的所有点        Set&lt;Integer&gt; set = map.get(index);        // 如果当前点到达不了其余点        if (set == null) {            return;        }        // 标记当前点已访问        visited[index] = true;        // 遍历相邻的点        for (int next : set) {            if (visited[next]) {                continue;            }            String key = index &lt; next ? (index + "_" + next) : (next + "_" + index);                        // 访问下一个点            dp(next, prob * probMap.get(key), visited);        }        // 退出，将该点标记为未访问        visited[index] = false;    }}</code></pre><p>但很可惜，超时了。我想了一下，应该是因为没有借用之前已经计算出来的结果，因此比较浪费时间。</p><p>其时间复杂度取决于边的数量，假设边的数量是 m ，则时间复杂度为O(m^2)。</p><p>而边 m 与点 n 的关系，m 最小是 0（也就是点之间没有线），最大是 (n - 1) * n / 2，每个点之间都有连线。</p><p>因此可以预见，这样的算法效率确实很差。</p><h1 class=pgc-h-arrow-right>Dijkstra 算法</h1><h1 class=pgc-h-arrow-right>定义概览</h1><p>Dijkstra (迪杰斯特拉)算法是典型的单源最短路径算法，用于计算一个节点到其他所有节点的最短路径。主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。</p><p>注意该算法要求图中不存在负权边。</p><h1 class=pgc-h-arrow-right>算法思想</h1><p>设 G=(V,E) 是一个带权有向图，把图中顶点集合 V 分成两组：</p><p>第一组为已求出最短路径的顶点集合（用 S 表示，初始时 S 中只有一个源点，以后每求得一条最短路径 , 就将加入到集合 S 中，直到全部顶点都加入到 S 中，算法就结束了）。</p><p>第二组为其余未确定最短路径的顶点集合（用 U 表示），按最短路径长度的递增次序依次把第二组的顶点加入 S 中。</p><p>在加入的过程中，总保持从源点 v 到 S 中各顶点的最短路径长度不大于从源点 v 到 U 中任何顶点的最短路径长度。</p><p>此外，每个顶点对应一个距离，S 中的顶点的距离就是从 v 到此顶点的最短路径长度。U 中的顶点的距离，是从 v 到此顶点只包括 S 中的顶点为中间顶点的当前最短路径长度。</p><h1 class=pgc-h-arrow-right>算法步骤</h1><ol start=1><li>初始时，S 只包含源点，即 S ＝{v}，v 的距离为0。U 包含除 v 外的其他顶点，即: U ={其余顶点}，若 v 与 U 中顶点 u 有边，则正常有权值，若u不是v的出边邻接点，则权值为∞。</li><li>从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。</li><li>以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。</li><li>重复步骤b和c直到所有顶点都包含在S中。</li></ol><p>执行动画过程如下图</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee6b41c1e6244534b608e52efb071632><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>本题解法</h1><pre><code>class Solution {    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {        // records[i]代表点i相邻的所有点，以及其概率        List&lt;List&lt;Record&gt;&gt; allRecords = new ArrayList&lt;&gt;(n + 1);        for (int i = 0; i &lt; n + 1; i++) {            allRecords.add(new LinkedList&lt;&gt;());        }        // 构造每个点的相连关系        for (int i = 0; i &lt; edges.length; i++) {            int[] edge = edges[i];            List&lt;Record&gt; records = allRecords.get(edge[0]);            records.add(new Record(edge[1], succProb[i]));            records = allRecords.get(edge[1]);            records.add(new Record(edge[0], succProb[i]));        }        // 利用广度优先搜索，进行遍历        // 借用优先队列，保证优先遍历当前概率高的        PriorityQueue&lt;Record&gt; queue = new PriorityQueue&lt;&gt;();        // 记录从start到每一个点的概率        double[] result = new double[n];        // 从start开始遍历        queue.offer(new Record(start, 1));        result[start] = 1;        // 开始        while (!queue.isEmpty()) {            // 当前节点            Record record = queue.poll();            int node = record.node;            double prob = record.prob;            // 获取当前点所能达到的其他节点            List&lt;Record&gt; otherNodes = allRecords.get(node);            // 遍历其余节点            for (Record next : otherNodes) {                int nextNode = next.node;                double nextProb = prob * next.prob;                // 如果当前计算出的概率，小于等于之前计算的概率                if (nextProb &lt;= result[nextNode]) {                    // 那么就没有必要继续算了，直接用之前的即可                    continue;                }                // 更新概率                result[nextNode] = nextProb;                // 如果已到结尾或者当前的概率已经比到end的小                if (nextNode == end || nextProb &lt; result[end]) {                    // 那么也没有必要继续了                    continue;                }                // 添加节点                queue.offer(new Record(nextNode, nextProb));            }        }        return result[end];    }    class Record implements Comparable&lt;Record&gt; {        int node;        double prob;        public Record(int node, double prob) {            this.node = node;            this.prob = prob;        }        @Override        public int compareTo(Record other) {            if (other == null) {                return -1;            }            if (this.prob == other.prob) {                return this.node - other.node;            }            return this.prob - other.prob &gt; 0 ? -1 : 1;        }    }}</code></pre><p>提交OK，执行用时超过了69%的 java 提交记录，看来还有值得优化的地方。</p><p>假设边的数量为 m ，点的数量为 n ，则时间复杂度为O(n + m + nlogn)。</p><h1 class=pgc-h-arrow-right>Bellman-Ford 算法</h1><p>之前有说到 Dijkstra 算法要求不能有负权边，而这个 Bellman-Ford 算法是支持的。</p><h1 class=pgc-h-arrow-right>算法步骤</h1><ol start=1><li>创建源顶点 v 到图中所有顶点的距离的集合 distSet，为图中的所有顶点指定一个距离值，初始均为 Infinite，源顶点距离为 0；</li><li>计算最短路径，执行 V - 1 次遍历；对于图中的每条边：如果起点 u 的距离 d 加上边的权值 w 小于终点 v 的距离 d，则更新终点 v 的距离值 d；</li><li>检测图中是否有负权边形成了环，遍历图中的所有边，计算 u 至 v 的距离，如果对于 v 存在更小的距离，则说明存在环；</li></ol><p>例如，下面的有向图 G 中包含 5 个顶点和 8 条边。假设源点 为 A。初始化 distSet 所有距离为 INFI，源点 A 为 0。</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d72280c1217b40a29220771adc0f78cd><p class=pgc-img-caption></p></div><p>由于图中有 5 个顶点，按照步骤 1 需要遍历 4 次，第一次遍历的结果如下。</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dd8dd027e6d946fa9466ee8281ffe3c0><p class=pgc-img-caption></p></div><p>第二次遍历的结果如下。</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/72bd754e8863432194caba5990e62464><p class=pgc-img-caption></p></div><p>以此类推可以得出完全遍历的结果。</p><h1 class=pgc-h-arrow-right>本题解法</h1><pre><code>class Solution {  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {    // 记录结果    double[] result = new double[n];    // 起点    result[start] = 1;    // 从start点出发，先更新直接与start点相连的点的概率，然后逐步更新，直到不需要更新为止    while (true) {      // 是否有过变动      boolean changed = false;      // 遍历所有边      for (int j = 0; j &lt; edges.length; j++) {        int[] edge = edges[j];        // 如果从当前点edge[0]出发，到edge[1]的概率，大于之前记录的结果        if (result[edge[0]] * succProb[j] &gt; result[edge[1]]) {          // 则更新          result[edge[1]] = result[edges[j][0]] * succProb[j];          changed = true;        }        // 因为是无向图,所以再反向遍历        if (result[edge[1]] * succProb[j] &gt; result[edge[0]]) {          result[edge[0]] = result[edge[1]] * succProb[j];          changed = true;        }      }      // 一遍未修改则表示图已遍历完成      if (!changed) {        break;      }    }    return result[end];  }}</code></pre><p>提交OK，执行用时超过了95%的 java 提交记录。</p><p>其时间假设边的数量为 m ，点的数量为 n ，则时间复杂度为O(mn)。</p><h1 class=pgc-h-arrow-right>总结</h1><p>以上就是这道题目我的解答过程了，不知道大家是否理解了。本题主要和图的遍历求解最短路径相关，可以用 Dijkstra 或者 Bellman-Ford 算法进行解决。</p><p>有兴趣的话可以访问我的博客或者关注我的公众号、头条号，说不定会有意外的惊喜。</p><p>https://death00.github.io/</p><p>公众号：健程之道</p><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03169d2510f2499da433d9b20ea9a3d8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=力扣1514——概率最大的路径 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bea144449ad344a7874a2a083341874c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'力扣','1514','路径'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>