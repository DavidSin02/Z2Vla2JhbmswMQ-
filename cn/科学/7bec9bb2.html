<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>通俗易懂的拓扑排序「图文」 | 极客快訊</title><meta property="og:title" content="通俗易懂的拓扑排序「图文」 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/4c8d0986-fbca-49d1-b29a-16f631325786"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/7bec9bb2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/7bec9bb2.html><meta property="article:published_time" content="2020-11-14T20:53:13+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:13+08:00"><meta name=Keywords content><meta name=description content="通俗易懂的拓扑排序「图文」"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/7bec9bb2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>通俗易懂的拓扑排序「图文」</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><p><strong>目录</strong></p><ul><li>介绍</li><li>拓扑排序算法分析</li><li>拓扑排序代码实现</li></ul><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/4c8d0986-fbca-49d1-b29a-16f631325786></div><h1><strong>介绍</strong></h1><p><strong>拓扑排序</strong>，很多人都可能<strong>听说但是不了解</strong>的一种算法。或许很多人只知道它是图论的一种排序，至于干什么的不清楚。又或许很多人可能还会认为它是一种啥排序。而实质上<strong>它是对有向图的顶点排成一个线性序列</strong>。</p><p>至于定义，百科上是这么说的：</p><blockquote><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个偏序得到该集合上的一个全序，这个<strong>操作称之为拓扑排序</strong>。</p></blockquote><p><strong>为什么会有拓扑排序？拓扑排序有何作用？</strong></p><p>举个例子，学习java系列的教程</p><p><strong>代号科目学前需掌握</strong></p><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb591b7272024275b34596097a243050></div><p>就比如学习java系类(部分)从java基础，到jsp/servlet，到ssm，到springboot，springcloud等是个循序渐进且有依赖的过程。在jsp学习要首先掌握java基础和html基础。学习框架要掌握jsp/servlet和jdbc之类才行。那么，这个学习过程即构成一个拓扑序列。当然<strong>这个序列也不唯一</strong>，<strong>你可以对不关联的学科随意选择顺序(比如html和java可以随便先开始哪一个。)</strong></p><p>那上述序列可以简单表示为：</p><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/33303713d1c245eb9bbbf251b2ada24d></div><blockquote><p>其中五种均为可以选择的学习方案，对课程安排可以有参考作用，当然，五个都是拓扑序列。只是选择的策略不同！</p></blockquote><p><strong>一些其他注意：</strong></p><blockquote><p><strong>DGA</strong>：有向无环图</p><p>AOV网：数据在顶点 可以理解为面向对象</p><p>AOE网：数据在边上，可以理解为面向过程！</p></blockquote><p>而我们通俗一点的说法，就是按照某种规则将这个图的顶点取出来，这些顶点<strong>能够表示什么或者有什么联系</strong>。</p><p><strong>规则</strong>：</p><ul><li>图中每个顶点只出现一次。</li><li>A在B前面，则不存在B在A前面的路径。(不能成环！！！！)</li><li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—>B—>C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li></ul><h1><strong>拓扑排序算法分析</strong></h1><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64671aa2209b42ee8f70b06046190e74></div><p><strong>正常步骤为(方法不一定唯一)</strong>：</p><ul><li>从DGA图中找到一个没有前驱的顶点输出。(可以遍历，也可以用优先队列维护)</li><li>删除以这个点为起点的边。(它的指向的边删除，为了找到下个没有前驱的顶点)</li><li><strong>重复上述</strong>，直到最后一个顶点被输出。<strong>如果还有顶点未被输出，则说明有环！</strong></li></ul><p>对于上图的简单序列，可以简单描述步骤为：</p><ul><li>1：删除1或2输出</li></ul><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7f4dd7b884a44f1aa7660f59beb4fa9></div><ul><li><br></li><li>2：删除2或3以及对应边</li></ul><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7632fd13226c470cb791b3384d5aa4ab></div><ul><li><br></li><li>3：删除3或者4以及对应边</li></ul><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c5b83dba1094fb6b0e45db1b30089e3></div><ul><li><br></li><li>3：重复以上规则步骤</li></ul><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/543b18a71bc040548eb992a99c1fb6cc></div><ul><li><br></li></ul><p>这样就完成一次拓扑排序，得到一个<strong>拓扑序列</strong>，但是这个序列<strong>并不唯一</strong>！从过程中也看到有很多选择方案，具体得到结果看你算法的设计了。但只要满足即是拓扑排序序列。</p><p>另外观察 1 2 4 3 6 5 7 9这个序列满足我们所说的有关系的节点指向的在前面，被指向的在后面。如果完全没关系那不一定前后(例如1,2)</p><h1><strong>拓扑排序代码实现</strong></h1><p>对于拓扑排序，如何用代码实现呢？对于拓扑排序，虽然在上面详细介绍了思路和流程，也很<strong>通俗易懂</strong>。但是实际上代码的实现还是很需要斟酌的，如何在<strong>空间和时间上</strong>能够得到较好的平衡且取得较好的效率？</p><p>首先要考虑存储。对于节点，首先他有联通点这么多属性。遇到稀疏矩阵还是用邻接表比较好。因为一个节点的指向节点较少，用邻接矩阵较浪费资源。</p><blockquote><p>另外，如果是1，2，3，4，5，6这样的序列求拓扑排序，我们可以考虑用数组，但是如果遇到1，2，88，9999类似数据，可以考虑用map中转一下。那么，</p></blockquote><p>我们<strong>具体的代码思想</strong>为：</p><ul><li>新建<strong>node类</strong>，包含节点数值和它的指向(这里直接用list集合替代链表了)</li><li>一个数组包含node(这里默认编号较集中)。初始化，<strong>添加每个节点指向的时候同时被指的节点入度+1</strong>！(A—>C)那么C的入度+1；</li><li><strong>扫描一遍所有node</strong>。将所有入度为0的点加入一个栈(队列)。</li><li>当栈(队列)不空的时候，<strong>抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且node指向的所有元素入度减一。<strong>如果某个点的入度被减为0，那么就将它加入栈(队列)</strong>。</li><li>重复上述操作，直到栈为空。</li></ul><p>这里主要是利用<strong>栈或者队列储存入度只为0</strong>的节点，只需要初次扫描表将入度为0的放入栈(队列)中。</p><ul><li>这里你或许会问为什么。</li><li>因为<strong>节点之间是有相关性的</strong>，一个节点若想入度为零，那么它的父节点(指向节点)肯定在它为0前入度为0，拆除关联箭头。从父节点角度，它的这次拆除联系，可能导致被指向的入读为0，也可能不为0(还有其他节点指向儿子)</li></ul><p>至于具体demo：</p><p>package 图论;</p><p>import java.util.ArrayDeque;</p><p>import java.util.ArrayList;</p><p>import java.util.List;</p><p>import java.util.Queue;</p><p>import java.util.Stack;</p><p>public class tuopu {</p><p>static class node</p><p>{</p><p>int value;</p><p>List&lt;Integer> next;</p><p>public node(int value) {</p><p>this.value=value;</p><p>next=new ArrayList&lt;Integer>();</p><p>}</p><p>public void setnext(List&lt;Integer>list) {</p><p>this.next=list;</p><p>}</p><p>}</p><p>public static void main(String[] args) {</p><p>// TODO Auto-generated method stub</p><p>node []nodes=new node[9];//储存节点</p><p>int a[]=new int[9];//储存入度</p><p>List&lt;Integer>list[]=new ArrayList[10];//临时空间，为了存储指向的集合</p><p>for(int i=1;i&lt;9;i++)</p><p>{</p><p>nodes[i]=new node(i);</p><p>list[i]=new ArrayList&lt;Integer>();</p><p>}</p><p>initmap(nodes,list,a);</p><p>//主要流程</p><p>//Queue&lt;node>q1=new ArrayDeque&lt;node>();</p><p>Stack&lt;node>s1=new Stack&lt;node>();</p><p>for(int i=1;i&lt;9;i++)</p><p>{</p><p>//System.out.print(nodes[i].next.size()+" 55 ");</p><p>//System.out.println(a[i]);</p><p>if(a[i]==0) {s1.add(nodes[i]);}</p><p>}</p><p>while(!s1.isEmpty())</p><p>{</p><p>node n1=s1.pop();//抛出输出</p><p>System.out.print(n1.value+" ");</p><p>List&lt;Integer>next=n1.next;</p><p>for(int i=0;i&lt;next.size();i++)</p><p>{</p><p>a[next.get(i)]--;//入度减一</p><p>if(a[next.get(i)]==0)//如果入度为0</p><p>{</p><p>s1.add(nodes[next.get(i)]);</p><p>}</p><p>}</p><p>}</p><p>}</p><p>private static void initmap(node[] nodes, List&lt;Integer>[] list, int[] a) {</p><p>list[1].add(3);</p><p>nodes[1].setnext(list[1]);</p><p>a[3]++;</p><p>list[2].add(4);list[2].add(6);</p><p>nodes[2].setnext(list[2]);</p><p>a[4]++;a[6]++;</p><p>list[3].add(5);</p><p>nodes[3].setnext(list[3]);</p><p>a[5]++;</p><p>list[4].add(5);list[4].add(6);</p><p>nodes[4].setnext(list[4]);</p><p>a[5]++;a[6]++;</p><p>list[5].add(7);</p><p>nodes[5].setnext(list[5]);</p><p>a[7]++;</p><p>list[6].add(8);</p><p>nodes[6].setnext(list[6]);</p><p>a[8]++;</p><p>list[7].add(8);</p><p>nodes[7].setnext(list[7]);</p><p>a[8]++;</p><p>}</p><p>}</p><p>输出结果</p><blockquote><p>2 4 6 1 3 5 7 8</p></blockquote><div class=pgc-img><img alt=通俗易懂的拓扑排序「图文」 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/413bc2121dbc4128825c4e4c316ccaed></div><p>当然，上面说过用栈和队列都可以！如果使用队列就会得到1 2 3 4 5 6 7 8的拓扑序列</p><p>至于图的构造，因为没有条件可能效率并不高，算法也可能不太完美，如有优化错误还请大佬指正！</p><p>另外，还请各位大佬动动小手 <strong>点赞、关注、转发</strong> 一波啊！谢谢</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'拓扑','图文','通俗易懂'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>