<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>在数据传输过程中的CRC 算法的简单说明 | 极客快訊</title><meta property="og:title" content="在数据传输过程中的CRC 算法的简单说明 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/20b135a5-23ea-4f80-82c4-f5c8e793a748"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/81b4c00c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/81b4c00c.html><meta property="article:published_time" content="2020-11-14T20:50:52+08:00"><meta property="article:modified_time" content="2020-11-14T20:50:52+08:00"><meta name=Keywords content><meta name=description content="在数据传输过程中的CRC 算法的简单说明"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/81b4c00c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>在数据传输过程中的CRC 算法的简单说明</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><div class=pgc-img><img alt="在数据传输过程中的CRC 算法的简单说明" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/20b135a5-23ea-4f80-82c4-f5c8e793a748><p class=pgc-img-caption></p></div><p>CRC校验（循环冗余校验）是数据通讯中最常采用的校验方式。在嵌入式软件开发中，经常要用到CRC 算法对各种数据进行校验。因此，掌握基本的CRC算法应是嵌入式程序员的基本技能。可是，我认识的嵌入式程序员中能真正掌握CRC算法的人却很少，平常在项目中见到的CRC的代码多数都是<span>那种</span>效率非常低下的实现方式。</p><p><strong>从奇偶校验说起</strong></p><p>所谓通讯过程的校验是指在通讯数据后加上一些附加信息，通过这些附加信息来判断接收到的数据是否和发送出的数据相同。比如说RS232串行通讯可以设置奇偶校验位，所谓奇偶校验就是在发送的每一个字节后都加上一位，使得每个字节中1的个数为奇数个或偶数个。比如我们要发送的字节是0x1a，二进制表示为0001 1010。</p><p>采用奇校验，则在数据后补上个0，数据变为0001 1010 0，数据中1的个数为奇数个（3个）</p><p>采用偶校验，则在数据后补上个1，数据变为0001 1010 1，数据中1的个数为偶数个（4个）</p><p>接收方通过计算数据中1个数是否满足奇偶性来确定数据是否有错。</p><p>奇偶校验的缺点也很明显，首先，它对错误的检测概率大约只有50%。也就是只有一半的错误它能够检测出来。另外，每传输一个字节都要附加一位校验位，对传输效率的影响很大。因此，在高速数据通讯中很少采用奇偶校验。奇偶校验优点也很明显，它很简单，因此可以用硬件来实现，这样可以减少软件的负担。因此，奇偶校验也被广泛的应用着。</p><p>奇偶校验就先介绍到这来，之所以从奇偶校验说起，是因为这种校验方式最简单，而且后面将会知道奇偶校验其实就是CRC 校验的一种(CRC-1)。</p><p><strong>累加和校验</strong></p><p>另一种常见的校验方式是累加和校验。所谓累加和校验实现方式有很多种，最常用的一种是在一次通讯数据包的最后加入一个字节的校验数据。这个字节内容为前面数据包中全部数据的忽略进位的按字节累加和。比如下面的例子：</p><p>我们要传输的信息为： 6、23、4</p><p>加上校验和后的数据包：6、23、4、33</p><p>这里 33 为前三个字节的校验和。接收方收到全部数据后对前三个数据进行同样的累加计算，如果累加和与最后一个字节相同的话就认为传输的数据没有错误。</p><p>累加和校验由于实现起来非常简单，也被广泛的采用。但是这种校验方式的检错能力也比较一般，对於单字节的校验和大概有1/256 的概率将原本是错误的通讯数据误判为正确数据。之所以这里介绍这种校验，是因为CRC校验在传输数据的形式上与累加和校验是相同的，都可以表示为：通讯数据 校验字节（也可能是多个字节）</p><p><strong>初识 CRC 算法</strong></p><p>CRC 算法的基本思想是将传输的数据当做一个位数很长的数。将这个数除以另一个数。得到的余数作为校验数据附加到原数据后面。还以上面例子中的数据为例：</p><p>6、23、4 可以看做一个2进制数： 0000011000010111 00000010</p><p>假如被除数选9，二进制表示为：1001</p><p>则除法运算可以表示为：</p><div class=pgc-img><img alt="在数据传输过程中的CRC 算法的简单说明" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a84130f1b6f64d9e8cacb68d876ba8fe><p class=pgc-img-caption></p></div><p>可以看到，最后的余数为1。如果我们将这个余数作为校验和的话，传输的数据则是：6、23、4、1</p><p>CRC 算法和这个过程有点类似，不过采用的不是上面例子中的通常的这种除法。在CRC算法中，将二进制数据流作为多项式的系数，然后进行的是多项式的乘除法。还是举个例子吧。</p><p>比如说我们有两个二进制数，分别为：1101 和1011。</p><p>1101 与如下的多项式相联系：1x<sup>3</sup>+1x<sup>2</sup>+0x<sup>1</sup>+1x<sup>0</sup>=x<sup>3</sup>+x<sup>2</sup>+x<sup>0</sup></p><p>1011与如下的多项式相联系：1x<sup>3</sup>+0x<sup>2</sup>+1x<sup>1</sup>+1x<sup>0</sup>=x<sup>3</sup>+x<sup>1</sup>+x<sup>0</sup></p><p>两个多项式的乘法：(x<sup>3</sup>+x<sup>2</sup>+x<sup>0</sup>)(x<sup>3</sup>+x<sup>1</sup>+x<sup>0</sup>)=x<sup>6</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>+x<sup>3</sup>+x<sup>3</sup>+x<sup>2</sup>+x<sup>1</sup>+x<sup>0</sup></p><p>得到结果后，合并同类项时采用模2运算。也就是说乘除法采用正常的多项式乘除法，而加减法都采用模2运算。所谓模2运算就是结果除以2后取余数。比如3 mod 2 = 1。因此，上面最终得到的多项式为：x<sup>6</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>+x<sup>2</sup>+x<sup>1</sup>+x<sup>0</sup>，对应的二进制数:111111</p><p>加减法采用模2运算后其实就成了一种运算了，就是我们通常所说的异或运算：</p><p class=ql-align-center>0+0=0</p><p class=ql-align-center>0+1=1</p><p class=ql-align-center>1+0=1</p><p class=ql-align-center>1+1=0</p><p class=ql-align-center>0-0=0</p><p class=ql-align-center>1-0=1</p><p class=ql-align-center>0-1=1</p><p class=ql-align-center>1-1=0</p><p>上面说了半天多项式，其实就算是不引入多项式乘除法的概念也可以说明这些运算的特殊之处。只不过几乎所有讲解 CRC 算法的文献中都会提到多项式，因此这里也简单的写了一点基本的概念。不过总用这种多项式表示也很罗嗦，下面的讲解中将尽量采用更简洁的写法。</p><p>除法运算与上面给出的乘法概念类似，还是遇到加减的地方都用异或运算来代替。下面是一个例子：</p><p>要传输的数据为：1101011011</p><p>除数设为：10011</p><p>在计算前先将原始数据后面填上4个0：11010110110000，之所以要补0，后面再做解释。</p><div class=pgc-img><img alt="在数据传输过程中的CRC 算法的简单说明" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1809f359f274031ae16aca699c4c63c><p class=pgc-img-caption></p></div><p>从这个例子可以看出，采用了模2的加减法后，不需要考虑借位的问题，所以除法变简单了。最后得到的余数就是CRC 校验字。为了进行CRC运算，也就是这种特殊的除法运算，必须要指定个被除数，在CRC算法中，这个被除数有一个专有名称叫做“生成多项式”。生成多项式的选取是个很有难度的问题，如果选的不好，那么检出错误的概率就会低很多。好在这个问题已经被专家们研究了很长一段时间了，对于我们这些使用者来说，只要把现成的成果拿来用就行了。</p><p>最常用的几种生成多项式如下：</p><p>CRC8=X<sup>8</sup>+X<sup>5</sup>+X<sup>4</sup>+X<sup>0</sup></p><p>CRC-CCITT=X<sup>16</sup>+X<sup>12</sup>+X<sup>5</sup>+X<sup>0</sup></p><p>CRC16=X<sup>16</sup>+X<sup>15</sup>+X<sup>2</sup>+X<sup>0</sup></p><p>CRC12=X<sup>12</sup>+X<sup>11</sup>+X<sup>3</sup>+X<sup>2</sup>+X<sup>0</sup></p><p>CRC32=X<sup>32</sup>+X<sup>26</sup>+X<sup>23</sup>+X<sup>22</sup>+X<sup>16</sup>+X<sup>12</sup>+X<sup>11</sup>+X<sup>10</sup>+X<sup>8</sup>+X<sup>7</sup>+X<sup>5</sup>+X<sup>4</sup>+X<sup>2</sup>+X<sup>1</sup>+X<sup>0</sup></p><p>有一点要特别注意，文献中提到的生成多项式经常会说到多项式的位宽（Width，简记为W），这个位宽不是多项式对应的二进制数的位数，而是位数减1。比如CRC8中用到的位宽为8的生成多项式，其实对应得二进制数有九位：100110001。另外一点，多项式表示和二进制表示都很繁琐，交流起来不方便，因此，文献中多用16进制简写法来表示，因为生成多项式的最高位肯定为1，最高位的位置由位宽可知，故在简记式中，将最高的1统一去掉了，如CRC32的生成多项式简记为04C11DB7实际上表示的是104C11DB7。当然，这样简记除了方便外，在编程计算时也有它的用处。</p><p>对于上面的例子，位宽为4（W=4），按照CRC算法的要求，计算前要在原始数据后填上W个0，也就是4个0。</p><p>位宽W=1的生成多项式(CRC1)有两种，分别是X<sup>1</sup>和X<sup>1</sup>+X<sup>0</sup>，读者可以自己证明10 对应的就是奇偶校验中的奇校验，而11对应则是偶校验。因此，写到这里我们知道了奇偶校验其实就是CRC校验的一种特例，这也是我要以奇偶校验作为开篇介绍的原因了。</p><p><strong>CRC算法的编程实现</strong></p><p>说了这么多总算到了核心部分了。从前面的介绍我们知道CRC校验核心就是实现无借位的除法运算。下面还是通过一个例子来说明如何实现CRC校验。</p><p>假设我们的生成多项式为：100110001（简记为0x31），也就是CRC-8</p><p>则计算步骤如下：</p><p>（1） 将CRC寄存器（8-bits，比生成多项式少1bit）赋初值0</p><p>（2） 在待传输信息流后面加入8个0</p><p>（3） While (数据未处理完)</p><p>（4） Begin</p><p>（5） If (CRC寄存器首位是1)</p><p>（6） reg = reg XOR 0x31</p><p>（7） CRC寄存器左移一位，读入一个新的数据于CRC寄存器的0 bit的位置。</p><p>（8） End</p><p>（9） CRC寄存器就是我们所要求的余数。</p><p>实际上，真正的CRC 计算通常与上面描述的还有些出入。这是因为这种最基本的CRC除法有个很明显的缺陷，就是数据流的开头添加一些0并不影响最后校验字的结果。这个问题很让人恼火啊，因此真正应用的CRC 算法基本都在原始的CRC算法的基础上做了些小的改动。</p><p>所谓的改动，也就是增加了两个概念，第一个是“余数初始值”，第二个是“结果异或值”。</p><p>所谓的“余数初始值”就是在计算CRC值的开始，给CRC寄存器一个初始值。“结果异或值”是在其余计算完成后将CRC寄存器的值在与这个值进行一下异或操作作为最后的校验值。</p><div class=pgc-img><img alt="在数据传输过程中的CRC 算法的简单说明" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e6d60c33f4284d989db23664549cbee0><p class=pgc-img-caption></p></div><p>加入这些变形后，常见的算法描述形式就成了这个样子了：</p><p>（1） 设置CRC寄存器，并给其赋值为“余数初始值”。</p><p>（2） 将数据的第一个8-bit字符与CRC寄存器进行异或，并把结果存入CRC寄存器。</p><p>（3） CRC寄存器向右移一位，MSB补零，移出并检查LSB。</p><p>（4） 如果LSB为0，重复第三步；若LSB为1，CRC寄存器与0x31相异或。</p><p>（5） 重复第3与第4步直到8次移位全部完成。此时一个8-bit数据处理完毕。</p><p>（6） 重复第2至第5步直到所有数据全部处理完成。</p><p>（7） 最终CRC寄存器的内容与“结果异或值”进行或非操作后即为CRC值。</p><p>而网上的代码.h.c文件很多，可以试一下。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','传输','过程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/674e4c8e.html alt=数据传输过程详解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/0907a2193228482d84471d6aeeb3fc90 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/674e4c8e.html title=数据传输过程详解>数据传输过程详解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>