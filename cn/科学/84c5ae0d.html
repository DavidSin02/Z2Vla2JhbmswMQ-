<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Dijkstra算法详细(单源最短路径算法) | 极客快訊</title><meta property="og:title" content="Dijkstra算法详细(单源最短路径算法) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/1d545f68-8ae2-41d1-892c-a9bdeb18835e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/84c5ae0d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/84c5ae0d.html><meta property="article:published_time" content="2020-11-14T20:53:57+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:57+08:00"><meta name=Keywords content><meta name=description content="Dijkstra算法详细(单源最短路径算法)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/84c5ae0d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Dijkstra算法详细(单源最短路径算法)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p><strong>介绍</strong></p><p>对于 dijkstra 算法，很多人可能感觉熟悉而又陌生，可能大部分人比较了解 bfs和dfs ，而对dijkstra和floyd算法可能知道大概是图论中的某个算法，但是可能不清楚其中的作用和原理，又或许，你曾经感觉它很难，那么，这个时候正适合你重新认识它。</p><p>Dijkstra能是干啥的？</p><div class=pgc-img><img alt=Dijkstra算法详细(单源最短路径算法) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/1d545f68-8ae2-41d1-892c-a9bdeb18835e><p class=pgc-img-caption></p></div><p>Dijkstra是用来求单源最短路径的</p><p>就拿上图来说，假如直到的路径和长度已知，那么可以使用 dijkstra 算法计算 <strong>南京到图中所有节点的最短距离。</strong></p><p>单源什么意思？</p><ul><li>从一个顶点出发，Dijkstra算法只能求一个顶点到其他点的最短距离而不能任意两点。</li></ul><p>和 bfs 求的最短路径有什么区别？</p><ul><li>bfs 求的与其说是路径，不如说是 <strong>次数</strong> 。因为bfs他是按照队列一次一次进行加入相邻的点，而两点之间没有权值或者权值相等(代价相同)。处理的更多是偏向迷宫类的这种都是只能走邻居(不排除特例)。</li></ul><p>Dijkstra在处理具体实例的应用还是很多的，因为具体的问题其实带权更多一些。</p><p>比如一个城市有多个乡镇，乡镇可能有道路，也可能没有，整个乡镇联通，如果想计算每个乡镇到ａ镇的最短路径，那么Dijkstra就派上了用场。</p><p><strong>算法分析</strong></p><p>对于一个算法，首先要理解它的 <strong>运行流程</strong> 。</p><p>对于一个Dijkstra算法而言，前提是它的前提条件和环境：</p><ul><li>一个连通图，若干节点，节点可能有数值，但是 路径 一定有 权值 。并且路径 <strong>不能为负</strong> 。否则Dijkstra就不适用。</li></ul><p>Dijkstra的核心思想是贪心算法的思想。不懂贪心？</p><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。</p><p>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。</p><p>对于贪心算法，在很多情况都能用到。下面举几个不恰当的例子！</p><p>打个比方，吃自助餐，目标是吃回本，那么胃有限那么每次都仅最贵的吃。</p><p>上学时，麻麻说只能带5个苹果，你想带最多，那么选五个苹果你每次都选最大的那个五次下来你就选的最重的那个。</p><p>不难发现上面的 策略 <strong>虽然没有很强的理论数学依据</strong> ，或者不太好说明。但是 <strong>事实规律就是那样</strong> ，并且对于贪心问题大部分都需要 <strong>排序</strong> ,还可能会遇到类排序。并且一个物体可能有多个属性，不同问题需要按照不同属性进行排序，操作。</p><p>那么我们的 Dijkstra 是如何贪心的呢？对于一个点，求图中所有点的最短路径，如果没有正确的方法胡乱想确实很难算出来，并且如果暴力匹配复杂度呈指数级上升不适合解决实际问题。</p><p>那么我们该怎么想呢？</p><p><strong>Dijkstra算法的前提：</strong></p><ol start=1><li>首先，Dijkstra处理的是带正权值的 有权图 ，那么，就需要一个 <strong>二维数组</strong> （如果空间大用list数组）存储各个点到达( 边 )的权值大小。 <strong>(邻接矩阵或者邻接表存储)</strong></li><li>其次，还需要一个 <strong>boolean数组</strong> 判断那些点已经确定最短长度，那些点没有确定。 <strong>int数组</strong> 记录距离( <strong>在算法执行过程可能被多次更新</strong> )。</li><li>需要 <strong>优先队列</strong> 加入 <strong>已经确定点的周围点</strong> 。每次抛出确定最短路径的那个并且确定最短，直到所有点路径确定最短为止。</li></ol><p><strong>简单的概括流程为：</strong></p><ul><li>一般从选定点开始抛入优先队列。（路径一般为0）， boolean数组 标记0的位置(最短为0) , 然后0 周围连通的点 抛入优先队列中（可能是node类），并把各个点的距离记录到对应数组内( 如果小于就更新，大于就不动，初始第一次是无穷肯定会更新 )，第一次就结束了</li><li>从队列中抛出 距离最近 的那个点 B （ <strong>第一次就是0周围邻居</strong> ）。这个点距离一定是最近的（所有权值都是正的，点的距离只能越来越长。）标记这个点为 true ， <strong>并且将这个点的邻居加入队列</strong> (下一次确定的最短点在前面未确定和这个点邻居中产生),并更新通过 B 点计算各个位置的长度，如果小於则更新！<br></li><li>重复二的操作，直到所有点都确定。<br></li></ul><p><strong>算法实现</strong></p><pre>package 图论;import java.util.ArrayDeque;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;import java.util.Scanner;public class dijkstra { static class node { int x; //节点编号 int lenth;//长度 public node(int x,int lenth) { this.x=x; this.lenth=lenth; } } public static void main(String[] args) {  int[][] map = new int[6][6];//记录权值，顺便记录链接情况，可以考虑附加邻接表 initmap(map);//初始化 boolean bool[]=new boolean[6];//判断是否已经确定 int len[]=new int[6];//长度 for(int i=0;i&lt;6;i++) { len[i]=Integer.MAX_VALUE; } Queue&lt;node&gt;q1=new PriorityQueue&lt;node&gt;(com); len[0]=0;//从0这个点开始 q1.add(new node(0, 0)); int count=0;//计算执行了几次dijkstra while (!q1.isEmpty()) { node t1=q1.poll(); int index=t1.x;//节点编号 int length=t1.lenth;//节点当前点距离 bool[index]=true;//抛出的点确定 count++;//其实执行了6次就可以确定就不需要继续执行了 这句可有可无，有了减少计算次数 for(int i=0;i&lt;map[index].length;i++) { if(map[index][i]&gt;0&amp;&amp;!bool[i]) { node node=new node(i, length+map[index][i]); if(len[i]&gt;node.lenth)//需要更新节点的时候更新节点并加入队列 { len[i]=node.lenth; q1.add(node); } } } }  for(int i=0;i&lt;6;i++) { System.out.println(len[i]); } } static Comparator&lt;node&gt;com=new Comparator&lt;node&gt;() { public int compare(node o1, node o2) { return o1.lenth-o2.lenth; } }; private static void initmap(int[][] map) { map[0][1]=2;map[0][2]=3;map[0][3]=6; map[1][0]=2;map[1][4]=4;map[1][5]=6; map[2][0]=3;map[2][3]=2; map[3][0]=6;map[3][2]=2;map[3][4]=1;map[3][5]=3; map[4][1]=4;map[4][3]=1; map[5][1]=6;map[5][3]=3;  }}</pre><p>执行结果：</p><div class=pgc-img><img alt=Dijkstra算法详细(单源最短路径算法) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7b5304a015d84ca38b2d19bb518bf448><p class=pgc-img-caption></p></div><p>当然，dijkstra算法比较灵活，实现方式也可能有点区别，但是思想是不变的：一个贪心思路。dijkstra执行一次就能够确定一个点，所以只需要执行点的总和次数即可完成整个算法。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'算法','Dijkstra','详细'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>