<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>掌握算法-图论-深度优先搜索的应用-无向图和双连通性 | 极客快訊</title><meta property="og:title" content="掌握算法-图论-深度优先搜索的应用-无向图和双连通性 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d282a5920a22456b96fa252333159b6f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/8f7064d3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/8f7064d3.html><meta property="article:published_time" content="2020-11-14T20:53:57+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:57+08:00"><meta name=Keywords content><meta name=description content="掌握算法-图论-深度优先搜索的应用-无向图和双连通性"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/8f7064d3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>掌握算法-图论-深度优先搜索的应用-无向图和双连通性</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>深度优先搜索（depth-first search）是对先序遍历（preorder traversal）的推广。我们从某个顶点v开始处理v，然后递归的便利所有与v邻接的顶点。如果这种过程是对一棵树进行，那么该树所有的顶点都将被系统地访问到。如果我们对任意的图行驶该过程，为了避免圈，我们需要小心仔细。为此，当我们访问一个顶点v的时候，由于我们已经到了该点处，因此可以标记该点是访问过的，并且对于尚未标记的所有邻接顶点递归调用深度优先搜索。</p><p>这里我们假设，对于无向图，每条边（v，w)在邻接表里出现两次，一次是（v，w)，另一次是（w，v）。下图是一个深度优先搜索的通用风格模板。</p><pre><code>void Dfs(Vertex V){    Visited[V] = True;    for each W adjancent to V        if(!Visited[W])            Dfs(W)}</code></pre><h1 class=pgc-h-arrow-right>无向图</h1><p>无向图是连通的，当且仅当从任一节点开始的深度优先搜索访问到每一个节点。如果我们处理的图不是连通的，那么我们可以找出所有的连通分支并将我们的算法依次应用于每个分支。</p><div class=pgc-img><img alt=掌握算法-图论-深度优先搜索的应用-无向图和双连通性 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d282a5920a22456b96fa252333159b6f><p class=pgc-img-caption>一个无向图</p></div><p>设我们从上图A开始作为深度优先搜索的一个例子。</p><p>此时标记A为访问过的并递归调用Dfs(B)。</p><p>Dfs(B)标记B为访问过的并递归调用Dfs(C)。</p><p>Dfs(C)标记C为访问过的并递归调用Dfs(D)。</p><p>Dfs(D)遇到A和B，但是这两个节点都已经访问过了，因此没有递归调用可以进行。</p><p>Dfs(D）也看到C是临接的顶点，但C也访问过了，因此在这里也没有递归调用进行，</p><p>于是Dfs(D)返回到Dfs(C)。</p><p>Dfs(C)看到B是邻接点，忽略它，并发现以前没看见过的顶点E也是邻接点，因此调用Dfs(E)。</p><p>Dfs(E)将E作为标记，忽略A和C，并返回到Dfs(C)。</p><p>Dfs(C)返回到Dfs(B)。Dfs(B)忽略A和D并返回。Dfs(A)忽略D和E返回。</p><hr><p>现在我们以图形来描述<strong>深度优先生成树（depth-first spanning tree）</strong>的步骤。该树的根是A，是第一个被访问到的顶点。图中的每一条边（v，w都出现在树上。我们当我们处理（v，w)时，发现w是未被标记的，或当我们处理（w，v)时发现v是未标记的，那么我们就用树的一条边表示它。如果当我们处理（v，w)时发现w已被标记，并且当我们处理（w，v）时发现v也已有标记，那么我们就画一条虚线，并称之为<strong>背向边（back edge)</strong>，表示这条边实际上不是树的一部分。</p><div class=pgc-img><img alt=掌握算法-图论-深度优先搜索的应用-无向图和双连通性 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4359d58fb28f41df86f925df730a5e10><p class=pgc-img-caption></p></div><p>树将模拟我们执行的遍历。只使用树的边对该树的先序编号告诉我们这些顶点被标记的顺序。</p><p>如果图不是连通的，那么处理所有节点（和边）则需要多次调用Dfs，每次都生成一棵树，整个集合就是<strong>深度优先生成森林（depth-first spanning forest）。</strong></p><h1 class=pgc-h-arrow-right>双连通性</h1><p>如果一个连通的无向图中的任一顶点删除之后，剩下的图仍然连通，那么这样的无向连通图就称为<strong>双连通的（biconnected）。</strong>之前的图就是双连通的。如果例中的节点是计算机，边是链路，那么若有任何一台计算机故障不能运行，则网络邮件并不受影响，当然，与这台计算机有关的邮件除外。类似地，如果一个公共运输系统是双连通的，那么，若某个站点被破坏，则用户总可以选择另外的旅行路径。</p><p>如果一个图不是双连通的，那么将其删除后图将不再连通的那些顶点叫做<strong>割点（articulation point）。</strong>这些节点在许多应用中是很重要的。下图就不是双连通的：顶点C和D是割点。</p><div class=pgc-img><img alt=掌握算法-图论-深度优先搜索的应用-无向图和双连通性 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d42b426c289d42cb91a4df27c0ae5d07><p class=pgc-img-caption></p></div><p>深度优先搜索提供一种找出连通图中的所有割点的线性时间算法。</p><p>首先，在图中任一顶点开始，执行深度优先搜索并在顶点被访问时给它们编号。对于每一个顶点v我们称其为先序编号Num(v)。然后，对于<strong>深度优先搜索生成树</strong>上的每一个顶点v，计算编号最低的顶点，我们称之为Low(v）--- 从点v开始，通过树的零条或多条边且可能还有一条背向边而（以该序）达到。</p><div class=pgc-img><img alt=掌握算法-图论-深度优先搜索的应用-无向图和双连通性 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2091996ed8e44dcb9c62079215d38f40><p class=pgc-img-caption>上图的深度优先树，节点标有Num和Low</p></div><p>从A，B，C开始的可达到的最低边号定点为1（A），因为他们能够通过树的边D，然后在由一条背向边回到A。我们可以通过对该深度优先生成树执行一次后续遍历有效的算出Low。根据low的定义可知Low(v)是：</p><ul><li>Num(v)</li><li>所有背向边（v，w)中的最低Num(w)</li><li>树的所有边（v，w)中的最低Low(w)</li></ul><p>中的最小者。</p><p>剩下要做的就是利用这些信息找出所有的割点。根是割点当且仅当它有多于一个的儿子，因为如果他有两个儿子，那么删除根则使得节点不连通而分布在不同的子树上；如果根只有一个儿子，那么除去该根只不过是断离该根。对于任何顶点v，它是割点当且仅当它有某个儿子w使得Low(w)>= Num(v)。需要注意的是这个条件在根处总是满足的了因此需要特别的测试。</p><p>当我们考察算法确定的割点。D有一个儿子E，且Low(E)>=Num(D)，二者都是4。因此，对E来说只有一种方法到达D上面的任何一点，那就是要通过D。类似的C也是一个割点，因为Low(G)>=Num(C)。</p><div class=pgc-img><img alt=掌握算法-图论-深度优先搜索的应用-无向图和双连通性 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d00e494796e34211ac09aa22720e1869><p class=pgc-img-caption>在C开始深度优先搜索所得到的深度优先树</p></div><p>伪代码如下：</p><p>为使程序简单，这里这数组Visited[], Num[], Low[]和Parent[]为全局变量。我们还有一个全局变量叫做Counter，为给先序遍历变好Num[]赋值。</p><hr><p>对顶点的Num赋值</p><pre><code>void AssignNum(Vertex V){    Vertex W;    Num[V] = Counter++;    Visited[V] = True;    for each W adjancent to V        if(!Visited[W]){            Parent[W] = V;            AssignNum(W);        }}</code></pre><p><br></p><hr><p><br></p><p>计算Low并检验是否是割点的伪代码</p><pre><code>void AssignNum(Vertex V){    Vertex W;    Num[V] = Counter++;    Visited[V] = True;    for each W adjancent to V        if(!Visited[W]){            Parent[W] = V;            AssignNum(W);        }}void AssignLow(Vertex V){    Vertex W;    Low[V] = Num[V];    for each W adjancent to V    {        if(Num[W] &gt; Num[V]){            AssignLow(W);            if(Low[W] &gt;= Num[V]){                printf("%v is an articulation point\n");            }            Low[V] = Min(Low[V], LOW[W]]);        }    }    else{        if(Parent[V] != W){            Low[V] = Min(Low[v], Num[W]);        }    }}</code></pre><p><br></p><hr><p>对上面两个的结合</p><pre><code>void FindArt(Vertex V){    Vertex W;    Visited[V] = True;    Low[V] = Num[V] = Counter++;    for(each W adjancent to V)    {        if(!Visited[W]){            Parent[W] = V;            FindArt(W);            if(Low[W] &gt;= Num[V])                printf("%v is an articulation point\n");            Low[V] = Min(Low[V], LOW[W]);            }        else{            if(Parent[V] != W){                LOW[V] = Min(LOW[V], Num[W]);            }        }    }}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'通性','图论','优先'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>