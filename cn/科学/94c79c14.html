<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>【干货】组播原理协议讲解 | 极客快訊</title><meta property="og:title" content="【干货】组播原理协议讲解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/03aad469d26c472baa30711f1cef191c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/94c79c14.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/94c79c14.html><meta property="article:published_time" content="2020-11-14T20:56:31+08:00"><meta property="article:modified_time" content="2020-11-14T20:56:31+08:00"><meta name=Keywords content><meta name=description content="【干货】组播原理协议讲解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/94c79c14.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>【干货】组播原理协议讲解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p><strong>第一章 概述</strong></p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03aad469d26c472baa30711f1cef191c><p class=pgc-img-caption></p></div><p>单播是相互感兴趣的主机双方进行通信的方式，主机不能接收对其不感兴趣的其它主机发送的信息，属于点对点通信。</p><p>广播是主机向子网内所有主机发送信息，子网内所有主机都能收到来自某台主机的广播信息，属于点对所有点的通信。</p><p>组播则介于两者之间，是主机向一组主机发送信息，存在于某个组的所有主机都可以接收到信息，属于点对多点通信。</p><p>下边用张图表示这三种方式的数据传输：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9df3781f069541a6ac1bbaef224e5e21><p class=pgc-img-caption></p></div><p>（图来源CSDN，作者：枫飘瞬间）</p><p><br></p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b230e0abef0649e7864e0c757745aee0><p class=pgc-img-caption></p></div><p><strong>第二章 二层组播基础概念</strong></p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03aad469d26c472baa30711f1cef191c><p class=pgc-img-caption></p></div><p>在前面的介绍中，我们讨论了用多播的方式解决新型流媒体业务的好处，在该部分中，我们结合一个实际的网络给出一些多播的基础概念， 掌握这些基础概念是深入掌握多播技术的前提。</p><p><strong>2.1 网络实例</strong></p><p>有下面一个网络需求：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9b401ff35c342d2b52d99fbbb781599><p class=pgc-img-caption></p></div><p>在图中，媒体流服务器通过以太网交换机LSWA ，跟核心路由器 GSRA 连接起来，并启动流媒体进程，不断的以多播 IP 地址 224.10.10.10 发送媒体流。 GSRA 和 GSRB 之间采用以太网连接起来， GSRB 通过以太网交换机 LSWB 连接了许多终端，其中两台终端需要媒体流服务器播放的媒体流。</p><p>下面我们仔细分析每一个步骤，在分析的过程中引入并介绍一些基础的组播概念。</p><p><br></p><p><strong>2.2 组播 MAC地址和组播 IP 地址</strong></p><p>在前面的介绍中，我们提到了媒体流服务器不断的以多播 IP 地址 224.10.10.10 发送媒体流， 224.10.10.10 这个 IP 地址就是一个多播 IP 地址。按照 IP 协议规定，位于224.0.0.1—239.255.255.255 范围内的 IP 地址都是多播地址。所谓多播地址，实际上是一个逻辑的概念，在网络上，没有一个计算机的 IP 地址是一个多播 IP 地址，多播 IP 地址仅仅代表了一个逻辑的组，加入该组的终端设备可以以该组所在的多播地址为目的 IP 地址来发送数据，这时候，发送的数据不是针对某个具体主机的， 而是针对一组机器，想接收这个多播数据流的计算机，只要倾听接收到的每个数据报，判断该数据报的目的 IP 地址是不是组播组的 IP 地址即可。若是，则接收，否则丢弃。</p><p>为了更好的理解组播 IP 地址的概念，我们举一个例子，如下面的网络图所示：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/df835cc71305494f8c77c8ba8fa65047><p class=pgc-img-caption></p></div><p>主机A（最左边的一台计算机）不断的以组播IP地址 224.10.10.10 送数据，这时候主机B（中间计算机）想接收组播组 224.10.10.10 的数据，于是它就会监听每个收到的数据报，判断该数据报目的 IP 地址是不是 224.10.10.10，如果不是则丢弃，如果是则接收下来送到上层处理。</p><p>这里牵涉到了一个问题：主机 B 的哪个模块判断接收到的数据报是不是组播数据报，并且是不是针对组 224.10.10.10 的数据报？答案是主机 B 的 IP 模块。我们看一下一台计算机接收数据的过程：</p><p>1、数据链路层把接收到的数据帧剥掉链路层头后送给 IP 层（至于数据链路层怎样接收数据帧，在后面会详细探讨） ；</p><p>2、IP 模块维护一张接收列表（该列表是 IP 地址组成的结合） ，每当接收到一个数据报（链路层送上来的） 后， 便把数据报的目的 IP 地址提取出来， 然后跟接收列表中的 每个 IP地址比较，如果有一项匹配，则接收该数据，并向上层传送，否则丢弃；</p><p>3、如果一台主机想加入一个多播组（加入与否由上层应用决定） ，比如你想看网络电视频道， 这时候你需要启动一个应用程序， 并告诉该应用程序网络电视频道的组播 IP 地址，该应用程序就会向 IP 模块注册，请求加入组播组。 IP 模块于是在自己维护的接收列表里添加一项（ 同时也告诉数据链路层自己加入了一个组播组，并附带上组播组地址 ），添加的这项就是组播组的组播 IP 地址。这样每当接收到目的地址是该组播 IP 地址的数据报的时候，IP 模块就接收下来，并向上层传送。</p><p>4、如果一台主机想退出组播组，比如你终止了电视频道接收程序，于是该程序在退出的时候会告诉 IP 模块，自己不再接收组播组的数据，并告诉 IP 模块组播组的组拨 IP 地址，于是 IP 模块就把该组播地址从接收列表中删除，这样以后如果再接收到该组播组的数据报的话，因为接收列表里没有匹配的项目，所以 IP 模块就丢弃该数据报。</p><p>经过上面的分析可以看出，问题的关键在于 IP 模块维护的接收列表。通常情况下（主机没有加入任何组播组） ，该列表里只有两项，即主机自己的 IP 地址和广播 IP 地址（255.255.255.255 ），这样主机只能接收针对自己的数据报和广播数据报。</p><p>细心的读者可以看出一个问题，就是数据链路层如何接收组播数据帧呢？原来，数据链路层的接收过程跟IP层原理一致，即数据链路层也有自己的接收列表（不过该列表的内容不是IP地址，而是MAC地址），每当 IP 模块收到上层应用的加入组播组的请求之后， IP模块就会向数据链路层通告（上面提到过） ，通告的时候携带了组播组的 IP 地址，于是数据链路层就会把 IP 地址进行适当的变换，变换的结果就是一个组播 MAC 地址，于是数据链路层把这个组播 MAC 地址插入自己的接收列表里面，以后每当有数据帧到来的时候，数据链路层就会把数据正的目的 MAC 地址跟接收列表里的每项内容进行比较， 遇到任何匹配的一项就接收下来，并向 IP 层传送。</p><p>这样又引出了两个问题： 数据链路层如何区分单播 MAC 地址跟组播 MAC 地址？数据链路层做一个 IP 地址跟组播 MAC 地址的影射，这个影射是怎样的？</p><p>首先解释第一个，一般情况下，单播 MAC 地址的最高字节的最低比特为 0，而组播MAC 地址的最高字节的最低比特为 1，如下所示：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2a6bd982376140d6bb2c245c004ded27><p class=pgc-img-caption></p></div><p>这样数据链路层就可以根据该比特判断收到的数据帧是不是一个组播数据帧。下图是第二个问题的答案：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/505d470b9e2449efb8ec79d852264924><p class=pgc-img-caption></p></div><p>从可以看出，MAC地址跟 IP 地址的低 23 比特是对应的， 比如 IP 模块告诉数据链路层软件 ，自己加入了一个组播组224.10.10.10 ， 则数据链路层形成一个MAC地址01--00--5E--0A--0A--0A （取组播 IP 地址低 23 位，高位为上面介绍的规则），并加入接收地址列表中。</p><p>到此为止，我们分析了网络层和数据链路层对组播的处理过程，为了更加深理解，我们举一个实际中的例子，还是同样的网络拓扑：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d58a403b45ce41a49f2ab8dd0ba407e5><p class=pgc-img-caption></p></div><p>假设图中从左到右计算机依次叫做 PCA ，PCB， PCC，并假设 PCA 上运行媒体流服务器发送程序，以组播地址 224.10.10.10 来不停的发送电视频道数据流。</p><p>开始的时候，PCB和PCC都没有接收该数据流， 于是在 PCB，PCC 的数据链路层和网络层的接收列表中都没有针对 224.10.10.10 组播地址的接收项， 从而当数据链路层接收到一个数据帧，该该数据帧的目的 MAC 地址是 01--00--5E--0A--0A--0A 的时候，因为接收列表中没有该地址， 所以在数据链路层就被丢弃（到这里，读者应该能体会到， 组播数据在数据链路层就可以被隔离， 而广播数据则必须到达网络层才能判断出是否需要丢弃， 这也是使用组播而不使用广播的最大好处） 。</p><p>这时候，假设 PCB 计算机的一个用户想收看网络电视频道了，于是该用户启动一个程序（比如， WINDOWS 平台下的 WMPLAYER ），并告诉该程序接收 224.10.10.10 组播组的数据流。于是发生下列事情：</p><p>1、该应用程序通过操作系统调用接口（ API 函数）告诉该 PC 机的 IP 模块，自己想接收224.10.10.10 组播组的数据（也就是说要加入组播组 224.10.10.10）；</p><p>2、IP 模块接收到该加入请求后， 便把组播组地址 224.10.10.10 加入自己的接收列表中，同时向数据链路层发送一个请求， 告诉数据链路层自己想接收 224.10.10.10 组对应的数据流；</p><p>3。数据链路层接收到 IP 模块的这个请求后，根据组播 MAC 地址跟组播 IP 地址的影射规则，把组播 IP 地址 224.10.10.10 影射成组播 MAC 地址 01--00--5E--0A--0A--0A ，然后加入自己的接收列表，到此动作完成 。</p><p>完成上述动作后， PCB 就可以接收组播组 224.10.10.10 的数据流了。如果这时候用户不想继续看网络电视了 （比如用户关闭应用程序） ，则应用程序在退出的时候会通知网络层，自己退出组播组 224.10.10.10 了，于是网络层会把自己的接收列表中 224.10.10.10 项删除，并通知数据链路层删除相应的列表项目。</p><p>到此为止，我们对组播 IP 地址跟组播 MAC 地址做了个详细的介绍，并详细分析了各个协议模块怎么处理组播数据的。</p><p><strong>2.3 二层组播协议</strong></p><p>在上面介绍的几个例子中，我们使用了以太网交换机连接许多主机终端，并假设以太网交换机按照广播的形式发送组播数据， 即以太网交换机每当接收到一个组播数据报， 就向所有的端口上转发（除去接收端口） 。如下所示：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ebf2368810514955afaae1ef36aeb10d><p class=pgc-img-caption></p></div><p>还是原来的命名规则， 计算机从左到右依次为 PCA，PCB，PCC。这样当交换机从PCA所在端口接收到 PCA 发出的组播数据帧后， 就向 PCB，PCC 所在端口转发。 这时候假设 PCB在接收组播数据流， 而 PCC 没有接收组播数据流， 于是 PCC 就可能接收到一些多余的数据（虽然这些数据在数据链路层就被隔离掉了，但毕竟不是理想的做法） 。</p><p>理想的做法是，交换机只向需要组播数据的端口设备转发组播数据流，比如PCB需要数据，则仅仅向PCB 转发。回忆我们以前讲解以太网技术的时候，曾经讲解了交换机的转发过程，交换机是根据内部的一张CAM表来做出转发决定的， 我们可以从概念上理解CAM表是这样构成的： { 目的 MAC 地址，出口集合 } ，在单播情况下，交换机根据数据帧的目的MAC 地址查找 CAM 表，找到一个出口（在单播情况下，出口集合中只有一个元素） ，然后把这个数据帧从该出口转发出去。</p><p>交换机上的这个 CAM 表同样适用于组播的情况，这时候，目的 MAC 地址就是一个组播 MAC 地址（其特点和形成过程严格按照前面介绍的规则） ，而出口集合就可能不是一个元素了，可能是多个元素的集合。还是假设上面的例子，假设开始的时候只有 PCB 接收数据，则交换机创建一个转发项（01--00--5E--0A--0A--0A ， {B} ）（假设 PCB 连接交换机的 B端口），并按照该转发项转发组播数据流，这样 PCC 就不能收到无用的数据流了。</p><p>这时候假设 PCC 也加入了组播组 224.10.10.10，于是交换机修改自己的转发表，把转发项（ 01--00--5E--0A--0A--0A ，{B} ）修改成 （01--00--5E--0A--0A--0A ，{B ，C} ）（假设 PCC连接交换机的 C 端口），这样每当交换机从 PCA 接收到一个数据帧，就根据这个转发项，复制成两份，一份给 PCB，一份给 PCC。</p><p>大家对交换机上的组播转发项已经很清楚了，这时候又一个问题出现了：交换机根据什么创建组播转发项， 并对组播转发项的出口集合做出修改？回忆单播的情况下， 交换机是根据学习来获得单播转发表的，在组播情况下，学习能否奏效？</p><p>其实在组播情况下， 学习是不行的， 因为在单播情况下的学习， 是针对数据帧的源 MAC地址进行的，而组播 MAC 地址不可能出现在数据帧的源 MAC 地址位置上（组播 MAC 地址出现的唯一位置就是数据帧的目的 MAC 地址），所以根本无法学习。这时候我们必须想一些其他办法来解决该问题，这些办法就是二层组播协议。</p><p>第一种办法，也是最容易理解的办法就是 GMRP（通用组播注册协议） ，该协议需要计算机的网卡的配合。 该协议这样运行， 每当计算机加入一个多播组的时候， 计算机同时给交换机发送一条 GMRP 加入消息，该消息携带的内容之一就是计算机加入的组播组的 MAC地址。这样交换机会根据不同的情况而采取不同的动作：</p><p>1、如果交换机上没有创建针对该组播 MAC 地址的转发项，则创建一个转发项，把出口集合初始化为连接发出请求的计算机的端口，以后就根据这个转发项进行数据转发；</p><p>2、如果交换机上已经有了针对该组的转发项， 则交换机仅仅把连接发出 GMRP 加入请求的计算机端口加入转发项的出口列表里面即可。</p><p>这种方式简单明了，容易理解，但需要计算机网卡驱动程序的支持，目前来说，很少网卡能有这种能力，所以应用不是很广泛。</p><p>另外一种应用很广泛的协议是 IGMP 窥探，这种协议是建立在 IGMP 协议上的，在介绍这种协议之前，我们先介绍一下 IGMP 协议。</p><p>所谓 IGMP ，即 INTERNET 组管理协议，是用于主机跟路由器之间交互的一种协议，为了说明这种协议出现的背景，请参考下面的图示：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6520fc6cd1e049ed9b406bccdf0a85ce><p class=pgc-img-caption></p></div><p>一般情况下，路由器是不转发组播数据流的，即路由器假设自己的本地网络上不存在组播数据流的接收端， 这样的假设是符合实际情况的。 在图中， 媒体流不停的发送电视频道数据， 这些数据被路由器阻隔， 所以到达不了本地网络。 假设本地网络上有一台计算机想接收该媒体服务器发出的数据流， 这时候该计算机必须告诉路由器自己的需求， 这样路由器才能把组播数据流引入本地网络。计算机告诉路由器使用的这种协议就是 IGMP 协议。</p><p>IGMP 协议第一版主要有两种消息： 主机加入消息和成员查询消息， 这两种消息分别从主机和路由器发出。其中， 主机加入消息是计算机用来告诉路由器， 自己想加入某个组播组的，而成员查询消息是路由器发出，用来查询网络上是否还有某个组播组的成员的。以上图为例，分析一下 IGMP 协议的运行过程：</p><p>1、本地网络上的一台主机加入了一个多播组G，于是该主机发出一个 IGMP 加入消息给路由器，告诉路由器自己想加入组播组G，于是路由器开始从上游引入组播组G的数据到本地网络；</p><p>2。路由器转发组播组 G 的数据一段时间后， 会发出一个查询消息，看网络上是否还存在组播组 G 的成员（因为有可能刚才加入的那台主机已经退出组播组了） ，加入组播组的成员要重新发布 IGMP 加入消息来作为成员查询消息的响应， 如果没有组播组的成员了， 路由器将收不到响应， 这时候路由器将再次进行查询尝试， 如果还没有主机应答， 路由器就认为网络上已经没有针对组播组 G 的主机了，于是停止转发组播组 G 的数据；</p><p>3。路由器发出组播组成员查询消息后，只要收到一台主机的响应，则路由器就必须继续转发组播组 G 的数据，不能因为网络上接收端的数目少而停止发送。</p><p>这样 IGMP 协议就很清楚了，我们来看一下 IGMP 窥探协议是怎样工作的。</p><p>IGMP 窥探是这样的，交换机分析每个接收到的组播数据帧（ IGMP 加入消息是以组播方式发送的） ，看该数据正是否是一个 IGMP 加入消息，如果是，则从该消息中就可以判断出发出该消息的主机想加入的组播组，根据该组播组的 IP 地址形成组播 MAC 地址，并把接收到该消息的端口加入出口列表，这样一个组播转发项就创建完成了。</p><p>完成之后，交换机把刚才拦截的 IGMP 消息再不加改变的转发出去。这样不停的窥探，交换机就可以掌握网络上的组播成员情况， 并反映在自己内部的组播转发表里， 以后就根据创建的组播转发表来进行数据的转发。</p><p>IGMP 窥探存在一个严重的问题， 就是交换机必须分析每个组播数据帧， 判断该数据帧是否是 IGMP 加入消息， 如果是，则进行进一步分析，否则转发。 这样对一些低性能的交换机来说， 是一项很繁重的任务， 所以该协议不适合低端交换机， 而适合一些核心层的骨干交</p><p>换机。</p><p><br></p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b230e0abef0649e7864e0c757745aee0><p class=pgc-img-caption></p></div><p><strong>第三章 三层组播基础概念</strong></p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03aad469d26c472baa30711f1cef191c><p class=pgc-img-caption></p></div><p>在前面部分的介绍中，我们集中在了对二层组播基础概念的介绍上，在本章中，我们引入一些三层组播的基础概念，在这些概念的基础上，简单介绍目前流行的组播路由协议（注意跟二层组播协议的区分） 原理及应用场合， 使读者对这些协议有个大致的了解，并为以后详细学习这些组播路由协议打下基础。</p><p><strong>3.1 组播转发项，组播树和RPF检查</strong></p><p>为了引入这些概念，我们首先看一个实际的网络图：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a91b1caaa2643c08e5281731b019238><p class=pgc-img-caption></p></div><p>在该图中，路由器 MR1 连接了一台多播数据源，该数据源不停的播放多播数据，MR2和 MR3 连接的本地网络都有数据接收端， MR4 的本地网络没有数据接收端。这样 MR1 在转发多播源数据的时候，就只需向 MR2 和 MR3 转发即可，没有必要再转发给 MR4 。这样我们可以通过在路由器 MR1 上创建三层转发项来完成， 三层转发项可以是这样的结构：（S，IIF ，G， {S0，S1， ...} ），其中S是组播数据源的 IP地址， IIF 是到达组播源 S 所使用的接口，即在单播方式下，路由器如果要给组播源 S 发送数据，则通过 IIF 接口发送，而 G 则是组播组地址， {S0 ， S1，。。。 } 是一个出口集合。这个转发项的含义很明确，就是当路由器接收到一个数据报后，把这个数据报的源 IP 地址和目的 IP 地址（该目的 IP 地址是一个组播地址） 读出来， 跟转发项匹配， 如果有一个转发项的源地址跟组播组地址相同，则把这个数据报向出口集合中所有的接口转发 （需要注意的是， 在把数据包发送出去之前， 还需要进行一个 RPF 检查，只有通过了才转发，否则丢弃） 。</p><p>网络上所有路由器的三层组播转发项串接起来，就构成了一棵组播转发树，比如，在下面的图形中，MR1 的组播转发项为（S，E0，G，{S0，S1} ）（其中S0，S1 连接MR2和MR3路由器），MR2组播转发项为（S，S0，G，{E0} ），MR3 组播转发项为（ S，S0，G，{E0} ），这样就构成下面的树状结构（以红色线条标出） ：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/25983617a3134a679c4d07ed3934687f><p class=pgc-img-caption></p></div><p>可以看出，这棵树是以数据源为根的，所以叫做源组播树（还有一种组播树叫共享组播树，后面介绍） 。组播数据就是沿着这棵树向下流动的。</p><p>在介绍了组播转发项和组播树之后， 我们看一个在三层组播中的一个非常重要的概念：RPF（反向路径转发）检查。为了解释RPF检查提出的原因，请参考下面的示例：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/606df30563244f2cbba45ddc98a26b71><p class=pgc-img-caption></p></div><p>在这个简单的网络结构中，流媒体服务器不断的发送出组播数据流，这样跟流媒体服务器连接到同一个以太网交换机上的两个路由器就都会接收并转发该组播数据流。 于是一个问题出现了：路由器 MR 会从两个接口 S0， S1 上分别收到相同的组播数据流，这个时候MR 选取哪个组播数据流并进行转发呢？如果 MR 把两个组播数据流都进行转发， 肯定是不合适的，假设组播数据流是一个电视频道，这样必然引起图象的重复出现，严重影响画面。</p><p>于是我们可以这样选择： 选择一个组播流，该组播流从组播源到路由器经过的路径最短。比如在上面的网络中，我们让路由器 MR 选择从接口 S0 进入的组播流，因为 S0 直接连接了组播数据源，而 S1 的组播数据源则经过了另外一台路由器。然而路由器怎样知道从哪个接口进入的数据流是最近的呢？答案是查找单播路由表。</p><p>到此为止，大家对 RPF 检查的背景一定有印象了，下面我们给出 RPF 检查的定义： 支持组播的路由器每当接收到一个组播数据报，首先把组播数据报的源 IP 地址提取出来，然后根据这个源 IP 地址查自己的单播路由表，查找的结果是一个接口，如果该接口跟接收到报文的接口相同， 则根据多播转发表来转发该组播数据报， 如果不相同， 则丢弃该组播数据报。</p><p>RPF 检查是三层组播中一个最重要的特性，正是它的存在，才把组播转发表和单播转发表结合了起来，在进行组播数据转发的时候，把单播转发表作为参考依据。而且 RPF 检查确保了到达的数据流不会重复， 也确保了到达的数据流对网络的影响最小 （因为数据流是通过最短的路径过来的） 。</p><p><br></p><p><strong>3.2 组播路由协议</strong></p><p>在上面我们介绍了组播转发表的概念，组播路由器在进行组播数据的转发的时候，就是依该转发表为基础来进行数据转发的， 需要注意的是， 在进行组播数据转发的时候， 还需要做一个重要的动作： RPF 检查。</p><p>现在的一个问题是：组播路由器上用于组播数据转发的组播转发项是如何建立起来的？答案是组播路由协议。</p><p>跟单播路由协议一样，组播路由协议用于建立路由器上用于组播数据转发的组播转发项。目前常用的组播路由协议有 DVMRP ， PIM-DM ， PIM-SM 等。在介绍这些协议之前，首先引入两个概念：剪枝和嫁接。</p><p>考虑下面的图形：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d8f0db34160e4fe58e201c59472012f5><p class=pgc-img-caption></p></div><p>组播路由器 MR 从接口S0，S1 上分别接收到组播数据，然而经过 RPF 检查后，S1上接收到的组播数据被丢弃了， 因为在单播路由表中通往流媒体服务器的接口是 S0。但是 RPF检查是发生在MR上的，连接 MR S1接口的路由器（假设为RT1）却不知道 MR 不需要从自己那里接收数据流，因而一直不停的把数据流发给 MR 。这样不但浪费链路带宽资源，而且浪费 MR 的系统资源，因为 MR 路由器必须做 RPF 检查。因此，一个有效的办法就是让RT1 停止从该接口上转发组播数据流， 这可以通过一个特殊的消息 — 剪枝来解决， 具体过程是这样的：</p><p>当 MR 路由器从接口 S1 接收到组播数据报后， 马上进行 RPF 检查，如果失败，则 MR路由器丢弃接收到的组播数据报，并通过 S1 接口给上游路由器（在这里就是 RT1）发送一个剪枝消息，告诉上游路由器停止转发该组的数据。这样当 RT1 接收到这个请求后，就不再从该接口转发数据流。 RT1 是通过修改自己内部的多播转发表来做到这一点的， 回忆一下多播转发表的结构， RT1 路由器仅仅在多播转发表的出口集合中把相应接口删除即可。</p><p>了解了剪枝消息后，嫁接消息就很简单了，它跟剪枝消息刚好相反，是用来通知上游路由器，让上游路由器把组播数据转发给自己，比如，在上面的图形中， MR 路由器的接口S0 由于某种原因 DOWN 掉了，这时候 MR 路由器会通过 S1 接口给上游路由器发送一个嫁接消息， 接收到该嫁接消息后， RT1 路由器回重新发组播数据流给 MR 路由器 （通过在多播转发表中把连接 MR 路由器的接口加入出口集合来实现），这样在 MR 上会通过 S1 接收到组播数据流，这时候 MR 上进行 RPF 检查就不会失败了，因为 S0接口 DOWN 掉，通往媒体流服务器的单播路由项会自动的切换到 S1 接口上（通过动态路由协议完成） 。</p><p>其实，组播路由协议可以理解为剪枝和嫁接消息的集合，任何组播路由协议都是由这两个消息作为基础的，只不过不同的路由协议发出该消息的时机不同罢了。</p><p>上面介绍的时候，提到了 RPF 检查，并提到， RPF 检查需要路由器的单播路由表，这个说法严格来说其实是不正确的， 因为要分两种情况： 对于某些协议（比如 PIM-DM ，PIM-SM等），这些协议在进行 RPF 检查的时候直接使用路由器用于转发单播数据的路由表， 即这些协议信任路由器的单播路由协议，这种多播协议叫做协议无关多播协议（也就是 PIM 的由来，即 Protocol Independ Multicast Protocol ），还有一些协议，比如DVMRP等，它们在进行RPF检查的时候，是根据自己建立的一个单播路由表进行的， 所有这些多播路由协议至少有两部分构成：一部分用於单播路由表的建立（该单播路由表跟路由器用来转发单播数据的路由表不同，它仅仅用于 RPF 检查），另外一部分用于组播路由表的建立。比如 DVMRP ，它实际上集成了一个 RIP 模块，使用该 RIP 模块来建立用于 RPF 检查的单播路由表。</p><p>下面我们看一下 PIM 协议， PIM （协议无关多播路由协议）分为 DM （密集模式）和SM（稀疏模式），密集模式往往用于一些企业网等网络带宽资源比较丰富的场合下，而稀疏模式则用于网络带宽比较紧张的大型网络中，比如 INTERNET ，下面我们结合一个网络拓扑图形来分析这两种协议的本质不同：</p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cb0a82ae3e94b6f8eb43f7e2bcbb024><p class=pgc-img-caption></p></div><p>假设多播路由器 MR1 和 MR2 运行的是 PIM-DM 协议，这样每当 MR1 接收到媒体流服务器发送过来的组播数据后，它就会通过串口 S0 发送给 MR2，而不管MR2 需要不需要这些组播数据流。当MR2 不需要组播数据流的时候，MR2会通过一个剪枝消息通知MR1，让 MR1 停止发送组播数据流，这样 MR1 接收到 MR2 的剪枝消息后，会暂停发送组播数据流，一段时间后（该时间一般是 3 分钟，但可以配置） ，如果在这段时间内没再次接收到MR2 发送过来的剪枝消息，则重新开始发送数据流。所以，如果 MR2 不想接收 MR1 发送过来的组播数据流的话， 则必须不停的周期性的发送剪枝消息该 MR1 ，即不停的 “阻止 ”MR1给自己发送组播数据流。</p><p>如果 MR1 和 MR2 运行的是PIM-SM 协议，则情况就完全两样了，这时候，MR1 总是假设MR2不需要组播数据流，于是根本不给 MR2 发送从媒体流服务器接收到的数据流，这时候如果 MR2 想接收媒体流服务器发送的数据流的话，必须通过一个嫁接消息告诉MR1，自己想接收组播数据流了， MR1 才开始给 MR2 发送组播数据流，不过一段时间后（该时间可以配置），如果没有再次接收到来自 MR2 的嫁接消息，则停止发送组播数据流。所以，如果 MR2 想持续不断的接收媒体流服务器发送过来的数据流，则必须不停的周期性的给MR1 发送嫁接消息，也就是说，不停的向 MR1“索取 ”组播数据流。</p><p>理解上面“阻止 ”和“索取 ”的含义，是理解DM和SM区别的关键。</p><p>其实，PIM-DM 和PIM-SM的区别还有一个重要的方面，就是 PIM-DM 一开始就使用源组播树转发数据，而 PIM-SM 开始的时候使用共享的组播树发送组播数据，如果组播数据量到了一定程度， 则转换为源组播树来完成组播数据的转发。</p><p>共享组播树是这样的，即整个网络选择一个中心点，组播流数据首先发送到该共享的中心点（ RP）上，然后由 RP 完成数据的转发。默认情况下， RP 是不转发组播数据流的，所以如果一个路由器想接收组播数据流，则必须向共享中心点注册，这样当 RP 接收到你注册的组播组的数据后，才向注册路由器转发。</p><p><strong>下面我们以一个简单的拓扑图说明注册的过程：</strong></p><div class=pgc-img><img alt=【干货】组播原理协议讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bec3e2136ba643ba8f714be678dead5b><p class=pgc-img-caption></p></div><p>图中，RP即整个网络的共享中心点，这样假设 MR2 想接收来自媒体流服务器的组播数据流，则必须首先向 RP 注册（假设所有路由器都是运行 PIM-SM 协议）。下面说明 MR2的注册过程：</p><p>1、MR2创建组播转发项（ *，G，S0， {E0} ）（假设媒体流服务器在组播组G内转发数据， MR2 通过 E0 接口连接本地网络），并通过S0接口向 MR1 发送一个嫁接消息，该嫁接消息中包含了RP的IP 地址；</p><p>2、MR1 接收到 MR2 发送过来的嫁接消息后，如果存在关于（ * ，G）的转发项，则仅仅把 S0 接口加入转发项的出口列表即可，否则 MR1 首先创建转发项（ *， G，S1，{S0} ），并通过 S1 接口向 RP 路由器发送嫁接消息；</p><p>3、如果 RP 路由器上存在组播转发项（ *， G），则仅仅把出口 S0 加入出口列表，如果不存在该转发项，则创建转发项（ * ，G，E0，{S0} ），这样当接收到媒体流服务器发送过来的组播数据流后，就根据该转发项进行转发 （这里需要提出的是，如果路由器接收到一个组播数据报， 然而自己组播转发表内没有关于该组播数据报的转发项的话， 丢弃收到的组播数据报）。</p><p>在上面的过程中，所有转发项的源都是以 *代替， * 代表任何组播数据源，即创建该组播转发项的路由器对组播数据源的具体位置不关心。那么这时候就存在一个问题： 组播路由器是根据什么来进行组播数据的RPF检查的呢？原来，PIM-SM 协议的路由器在进行RPF检查的时候，不是采用组播数据报的源 IP 地址，而是根据 RP 路由器的 IP 地址来进行的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'干货','组播','协议'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>