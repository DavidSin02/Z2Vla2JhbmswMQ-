<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>支持向量机（第四章） | 极客快訊</title><meta property="og:title" content="支持向量机（第四章） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/153914838549618d2616eb5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9816751.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9816751.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/9816751.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9816751.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9816751.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/9816751.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/9816751.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9816751.html><meta property="article:published_time" content="2020-10-29T20:56:37+08:00"><meta property="article:modified_time" content="2020-10-29T20:56:37+08:00"><meta name=Keywords content><meta name=description content="支持向量机（第四章）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/9816751.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>支持向量机（第四章）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><h1>第四章 解最优化问题</h1><p>译/吴天晖</p><p>按语：请多批评。</p><h1>拉格朗日乘</h1><p>意大利-法国数学家<strong>Giuseppe Lodovico Lagrangia，也就是大家知道的JosephLouis Lagrange，他发明了一个策略来寻找一个有等式约束的函数的局部最大值和最小值。这个方法叫拉格朗日乘。</strong></p><h1>拉格朗日乘数法</h1><p>拉格朗日注意到当我们求如下最优化问题时：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153914838549618d2616eb5><p class=pgc-img-caption></p></div><p>找到<em>f</em>的最小值也就是找到一个同一方向的梯度点同时符合条件<em>g。可以写成，当：</em></p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148385566602d9e7395><p class=pgc-img-caption></p></div><p>所以我们想要找到<em>f</em>在约束<em>g</em>下的最小值，也就是要求出：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148378587b69b3e2ca9><p class=pgc-img-caption></p></div><p>这里，常数<em>a</em>称为拉格朗日乘子<em>。</em></p><p>简化这个方法，我们发现如果我们定义一个方程<em>(x, a)=f(x)- ag(x)</em>，这时他们的梯度是<em>(x, a)=</em> <em>f(x)-</em> <em>ag(x)</em>。之后，<em>(x, a)=0</em>的解就是我们找到这个最小值<em>。</em></p><p>拉格朗日乘数法能总结为以下三步：</p><p>1．通过每一个带乘子的约束条件来构造拉格朗日函数</p><p>2．给出拉格朗日函数的梯度</p><p>3．解函数<em>(x, a)=0</em></p><h1>SVM 拉格朗日问题</h1><p>我们看到上一章介绍的SVM优化问题是：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483788081e8e0200b0><p class=pgc-img-caption></p></div><p>让我们回到这个问题。我们有一个需求最小值的目标函数：</p><p>和约束条件函数m:</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483789564f03dff72f><p class=pgc-img-caption></p></div><p>我们得出拉格朗日函数：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483792116c080496e8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483794573dfe432ffc><p class=pgc-img-caption></p></div><p>注意在这里我们给每一个约束函数配了一个拉格朗日乘子<em>ai</em>。</p><p>我们可以尝试去求<em>(w,b, a)=</em>0,但是这个问题仅能在用例少的情况下能分析求出（Tyson Smith,2004）。所以我们不得不用对偶原理重写这个问题。</p><p>要解答这个原问题，我们需要去解下面的拉格朗日问题：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483795883e6daafe9a><p class=pgc-img-caption></p></div><p>有意思的是我们在这里要得到w和b的最小时值同时要得到a的最大值。</p><p><strong><em>提示：</em></strong><em>你可能注意到拉格朗日乘数法是用来解决带等式约束的问题的，但在这儿我们用它来处理不等式约束，用这个方法来处理不等式约束，还需要附加一些条件（KKT条件）。我们之后将介绍这些条件。</em></p><h1>乌尔夫对偶问题</h1><p>拉格朗日问题有一个不等式约束<em>m</em>（<em>m</em>是指训练用例），他的典型解法是用对偶形。对偶原理告诉我们一个优化问题可以看成是两个透视图。第一个是原问题，我们关心的优化问题，另一个是对偶问题，一个求最大值的问题。有意思的是对偶问题中的最大值常常小于或等同于原问题的最小值（我们说它提供一个降低解原问题难度的方法）。</p><p>在我们这里，我们试着去解决一个凸优化问题，和仿射约束下的斯莱德条件（Gretton,2016）, 斯莱德定理告诉我们强对偶问题成立。意思是对偶问题中的求最大值等价于原问题中的求最小值。求对偶问题也就是求原问题，但是更简单。</p><p>重新列出拉格朗日函数：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483798714a9de75246><p class=pgc-img-caption></p></div><p>这个拉格朗日原问题是：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539152172373d557cd5c3a><p class=pgc-img-caption></p></div><p>求这个最小值问题演化为在的偏导数中求<em>w</em>和<em>b</em>。</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148380025dc6c20f3ee><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148380133813d1a05fa><p class=pgc-img-caption></p></div><p>从第一个式子中，我们发现：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153914838031196084da742><p class=pgc-img-caption></p></div><p>让我们用下面的值代替<em>w</em>：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148380588909f3d5fa6><p class=pgc-img-caption></p></div><p>我们成功的去掉了<em>w</em>,但是b还是留在了式子的最后部分：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483808049bdec8f73c><p class=pgc-img-caption></p></div><p>我们注意到</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148380880022bcc4526><p class=pgc-img-caption></p></div><p>意味着</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148381683a60f85c7be><p class=pgc-img-caption></p></div><p>，因此上式的最后部分等于0,于是我们可以写成：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153914838188696f6d39f4f><p class=pgc-img-caption></p></div><p>这就是乌尔夫拉格朗日对偶函数。</p><p>优化问题至此就被称为乌尔夫对偶问题：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148382097a01c207c6a><p class=pgc-img-caption></p></div><p>通常乌尔夫对偶拉格朗日问题会强制梯度等于0。理论上，我们需增加约束</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1539148382211d2dcf96f81><p class=pgc-img-caption></p></div><p>和</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148382286384c15a89e><p class=pgc-img-caption></p></div><p>。然而，我们仅仅增加后面的项。就是我们增加约束</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391522198417135205ec7><p class=pgc-img-caption></p></div><p>因为它能在函数中去掉<em>b。</em></p><p>无论如何，我们可以在没有约束</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483823322e1655f6f6><p class=pgc-img-caption></p></div><p>下来解决问题。</p><p>基于乌尔夫对偶的拉格朗日问题的优势是目标函数<em>W</em>现在仅仅只依赖拉格朗日乘子。并且，这个公式将帮我们在下一节里用Python来解决问题而且当我们之后学习核方式时也非常有用。</p><h1>Karush-Kuhn-Tucker 条件</h1><p>因为我们要解决不等式约束，有一个附加条件：解决方法中必须满足Karush-Kuhn-Tucker (KKT)条件。</p><p>KKT条件首先需要的条件是能解优化问题的最值。进而，这个问题要满足一些规则条件。幸运的是，规则条件中有一个叫斯莱特条件，我们可以看到它能支持SVMs。因为我们的原问题是要试着去解决一个凸问题，KKT条件能充分满足求原问题和对偶问题的最值，他们是零对偶间隙。</p><p>总之，如果一个解法满足KKT条件，我们可以认为它是最优的解法。</p><p>这个KKT条件是：</p><p>稳定条件：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391522885733f698a549a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539152297817823fde5e91><p class=pgc-img-caption></p></div><p>原可行条件：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148382457317b19b7ae><p class=pgc-img-caption></p></div><p>对偶可行条件：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148382568deda773aa0><p class=pgc-img-caption></p></div><p>互补松驰条件：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148382678c5b09c3a86><p class=pgc-img-caption></p></div><p><strong><em>提示：</em></strong><em>……解决支持向量机的问题等价于寻找一个KKT条件。</em></p><p>到此我们找到了所有的必要条件。让我们来一点一点实践吧。</p><h1>稳定条件</h1><p>这个稳定条件告诉我们被选点必须是一个驻点。它是一个函数递增或递减的停止点。如果没有约束，稳定条件下的驻点就是目标函数梯度为0的点。如果我们有约束，我们将把梯度用在拉格朗日函数上。</p><h1>原可行条件</h1><p>盯着这个条件，你应该看出来这就是原问题的约束。它要使我们必须求出这个函数在约束下的最小值。</p><h1>对偶可行条件</h1><p>同样，这个条件代表的是对偶问题的约束。</p><h1>互补松驰条件</h1><p>从互补松驰条件中，我们可以看到</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148382850406ce80568><p class=pgc-img-caption></p></div><p>或</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148382965ba5054bf29><p class=pgc-img-caption></p></div><p>。</p><p>支持向量是一个正拉格朗日乘子的示例。它们是约束</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153914838305436bfb500e0><p class=pgc-img-caption></p></div><p>其中之一。（我们看见这个约束</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153915242407489a7627b34><p class=pgc-img-caption></p></div><p>是可用的）。</p><p><strong><em>技巧：</em></strong>从互补松驰条件中，我们看到支持向量是正拉格朗日乘子的示例。</p><h1>我们如何使用这个乘子？</h1><p>当我们解乌尔夫对偶问题时，我们得到一个向量<em>a</em>包含所有的拉格朗日乘子。可是，当我们首先提到原问题时，我们的目标是寻找<strong><em>w</em></strong>和<em>b</em>。让我们看我们怎样去从拉格朗日乘子中提取这些数值。</p><h1>计算w</h1><p>计算w是相当简单的，从梯度</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483831228c856d3f4c><p class=pgc-img-caption></p></div><p>得到公式：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539152473654cee15efe10><p class=pgc-img-caption></p></div><p>。</p><h1>计算b</h1><p>一量我们已知w,我们可以从原问题的约束中计算<em>b</em>：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153915249863361fa29e259><p class=pgc-img-caption></p></div><p>事实上，这个约束一直是正确的，因为这新的公式是与原问题等价的一种变形。它说明这些临近超平面的点将被一个函数限制在1内（这个值1是我们选的用来让我们决定如何去变形W）：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1539148383202b7870b9283><p class=pgc-img-caption></p></div><p>到这里，我们知道所有的其他变量,求<em>b</em>就变得很容易开始了。我们在等式两边都乘以<em>yi</em>，又因为</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148383238b8b72bb145><p class=pgc-img-caption></p></div><p>，我们得到：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153914838336320578d9337><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483834266c995f5716><p class=pgc-img-caption></p></div><p>然而，在文献模式识别与机器学习（<em>Pattern Recognition and Machine Learning </em>(Bishop, 2006)）中，我们用提供的支持向量的平均值来代替随机支持向量xi是更稳健的方法：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483835275d52af6ccc><p class=pgc-img-caption></p></div><p>这里S是支量向量的个数。</p><p>其他作者，像(Cristianini & Shawe-Taylor, 2000) 和(Ng),用另一个公式：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539148383654540760b452><p class=pgc-img-caption></p></div><p>它们都主要是取最近的正支持向量和最近的负支持向量的平均值。最后的公式最初是统计学习理论（<em>Statistical Learning Theory </em>(Vapnik V. N., 1998)）用来定义最优超平面的。</p><h1>假设函数</h1><p>SVMs用与感知器得到的相同的假设函数。分类示例点xi 函数：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148383753df0d4fe1db><p class=pgc-img-caption></p></div><p>当我们使用对偶公式，它可以仅用支持向量计算：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483838952aed0e2dee><p class=pgc-img-caption></p></div><h1>用QP方法来处理SVMs</h1><p>QP方法是一个用来处理二次型编程问题的程序。在接下来的例子中，我们将wgket用一个叫CVXOPT的Python包。</p><p>这个软件包提供一个方法来解决类似下面的二次型问题：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483840440d814a05b0><p class=pgc-img-caption></p></div><p>这看起来不像我们的优化问题，所以我们将要去改写它，让它能用这个软件包来处理。</p><p>首先，我们注意到乌尔夫对偶优化问题中，我们要去最小化<em>a，所以我们可以改写二次型问题，用a来代替x，看来会让两个问题的关系近一些。</em></p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148384153f42cfb3a00><p class=pgc-img-caption></p></div><p>这里的</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483842277c015c2026><p class=pgc-img-caption></p></div><p>符号代表分量式不等式。意思是矩阵Gλ的每一行都必须满足不等关系。</p><p>我们来改变乌尔夫对偶问题。首先，我们转化最大值问题：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483844611022232ad8><p class=pgc-img-caption></p></div><p>乘以-1转化成最小值问题。</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539152544181c7c2d60faf><p class=pgc-img-caption></p></div><p>然后我们让向量</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1539148384707b86c0c743d><p class=pgc-img-caption></p></div><p>和</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148384827da377f0904><p class=pgc-img-caption></p></div><p>及克莱姆矩阵K都与向量xi作点积运算：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15391483850260fcc202991><p class=pgc-img-caption></p></div><p>我们用它们构造一个向量化的乌尔夫对偶问题，</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539148385096be5b285b0d><p class=pgc-img-caption></p></div><p>表示y的外积。</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391483852543616a74d43><p class=pgc-img-caption></p></div><p>我们现在可以求用CVXOP qp函数求出P，q，G，h，A和b等等所有参数的值。如代码表24所示。</p><pre>代码表24# See Appendix A for more information about the dataset from succinctly.datasets import get_dataset, linearly_separable as lsimport cvxopt.solvers X, y = get_dataset(ls.get_training_examples) m = X.shape[0] # Gram matrix - The matrix of all possible inner products of X. K = np.array([np.dot(X[i], X[j]) for j in range(m) for i in range(m)]).reshape((m, m)) P = cvxopt.matrix(np.outer(y, y) * K) q = cvxopt.matrix(-1 * np.ones(m)) # Equality constraints A = cvxopt.matrix(y, (1, m)) b = cvxopt.matrix(0.0) # Inequality constraints G = cvxopt.matrix(np.diag(-1 * np.ones(m))) h = cvxopt.matrix(np.zeros(m)) # Solve the problem solution = cvxopt.solvers.qp(P, q, G, h, A, b) # Lagrange multipliers multipliers = np.ravel(solution['x']) # Support vectors have positive multipliers. has_positive_multiplier = multipliers &gt; 1e-7 sv_multipliers = multipliers[has_positive_multiplier] support_vectors = X[has_positive_multiplier] support_vectors_y = y[has_positive_multiplier]</pre><p>代码表24初始化所有要求的参数并且将其传给qp方法，它会给我们一个结果。这个结果包含很多无素，但是我们只关心x，它在我们这里相当于就是拉格朗日乘子。</p><p>当我看到上面，我们可以用拉格朗日乘子重算w：</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391525834465875f43a21><p class=pgc-img-caption></p></div><p>。代码表25显示计算w的函数代码。</p><pre>代码表25def compute_w(multipliers, X, y):  return np.sum(multipliers[i] * y[i] * X[i]  for i in range(len(y))) </pre><p>因为拉格朗日乘子对于非支持向量的结果近似为零，所以我们只用支持向量数据来计算w，见代码表26。</p><pre>代码表26w = compute_w(multipliers, X, y) w_from_sv=compute_w(sv_multipliers, support_vectors, support_vectors_y) print(w) # [0.44444446 1.11111114] print(w_from_sv) # [0.44444453 1.11111128] </pre><p>当我们用均值方法计算b时：</p><pre>代码表27def compute_b(w, X, y):  return np.sum([y[i] - np.dot(w, X[i])  for i in range(len(X))])/len(X)代码表28b = compute_b(w, support_vectors, support_vectors_y) # -9.666668268506335 </pre><p>当我们将结果用图32来表示时，我们发现这个超平面就是最优超平面。与感知器不同，SVM总能得到相同的结果。</p><div class=pgc-img><img alt=支持向量机（第四章） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15391529761156a144762b6><p class=pgc-img-caption>图32: 用CVXOPT求出超平面</p></div><p>我们介绍的这种SVM被称为硬边界SVM。它面对非线性可分的数据不能工作。有几个时髦的支持向量机的方法。在下一章我们将介绍另一种被称为软边界SVM的方法，它能够在有非线性可分的异常据数据下工作。</p><h1>小结</h1><p>w的范式的最小值是一个凸优化问题，它可以用拉格朗日乘数法解决。当我们有更多的这类问题时，我喜欢用凸优化包，它可以帮我们做这些艰苦的工作。</p><p>我们发现原优化问题可以用拉格朗日函数来改写成，谢谢对偶规则，我们可以将拉格朗日问题转成乌尔夫对偶问题。我们还用了CVXOPT包来求解乌尔夫对偶。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'向量','第四章','支持'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>