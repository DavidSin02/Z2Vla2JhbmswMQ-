<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Frida之文件操作 | 极客快訊</title><meta property="og:title" content="Frida之文件操作 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2ebe58a30dd547fa9d48c448f2114294"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/9a91fac3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/9a91fac3.html><meta property="article:published_time" content="2020-10-29T21:13:10+08:00"><meta property="article:modified_time" content="2020-10-29T21:13:10+08:00"><meta name=Keywords content><meta name=description content="Frida之文件操作"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/9a91fac3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Frida之文件操作</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>在前面的文章中介绍了数据库的操作，这篇文章主要介绍文件的操作。</p><p style=text-align:start>当你在使用程序的时候，可以动态修改程序的文件操作，其实是很恐怖的，比如，本来是往文件中写入100元钱，但是经过动态修改后变成了0元，据此可以脑洞大开一下。 @[toc]</p><h1 class=pgc-h-arrow-right>基础概念</h1><h1 class=pgc-h-arrow-right>Linux下文件描述符</h1><p style=text-align:start>一个Linux进程启动后，会在内核空间创建一个PCB进程控制块，PCB是一个进程的私有财产。这个PCB中有一个已打开文件描述符表，记录着所有该进程打开的文件描述符以及对应的file结构体地址。</p><p style=text-align:start>默认情况下，启动一个Linux进程后，会打开三个文件，分别是标准输入、标准输出、标准错误分别使用了0、1 、2号文件描述符。</p><p>当该进程使用函数open打开一个新的文件时，一般会在内核空间申请一个file结构体，并且把3号文件描述符对应的file指针指向file结构体。</p><div class=pgc-img><img alt=Frida之文件操作 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2ebe58a30dd547fa9d48c448f2114294><p class=pgc-img-caption></p></div><p>v-node table entry是虚拟文件系统对应的文件节点，i-node是磁盘文件系统对应的文件节点。通过这两个节点就能找到最终的磁盘文件。 举个例子：</p><pre><code>#include &lt;unistd.h&gt;#include &lt;fcntl.h&gt;#include &lt;stdio.h&gt;int main(int argc,char *argv[]){   int fd = open("./1.c",O_RDWR);   printf("fd=%d\n",fd);}</code></pre><p style=text-align:start>程序运行结果是: fd=3</p><p style=text-align:start>每一个进程只有一个process table entry，一般情况下默认使用 fd 0、fd1、fd2，新打开的文件1.c将使用fd 3，后续的文件描述符的值以此类推。</p><p><strong>文件描述符含义</strong>0标准输入1标准输出2标准错误输出</p><h1 class=pgc-h-arrow-right>JavaScript Promise对象</h1><p style=text-align:start>ECMAscript 6 原生提供了 Promise 对象。Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p><pre><code>var myFirstPromise = new Promise(function(resolve, reject){    //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)    //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.    setTimeout(function(){        resolve("欢迎关注我的微信公众号:无情剑客!"); //代码正常执行！    }, 250);});myFirstPromise.then(function(successMessage){    //successMessage的值是上面调用resolve(...)方法传入的值.    //successMessage参数不一定非要是字符串类型，这里只是举个例子    document.write("Yay! " + successMessage);});</code></pre><p style=text-align:start>Promise简化了对error的处理，上面的代码我们也可以这样写：</p><pre><code>promise.then(onFulfilled).catch(onRejected)</code></pre><p style=text-align:start>更多Promise的内容，后续会专门介绍。</p><h1 class=pgc-h-arrow-right>Android Activity生命周期</h1><p>为了在 Activity 生命周期的各个阶段之间导航转换，Activity 类提供六个核心回调：onCreate()、onStart()、onResume()、onPause()、onStop() 和 onDestroy()。当 Activity 进入新状态时，系统会调用其中每个回调。</p><div class=pgc-img><img alt=Frida之文件操作 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cfcef8ce50c041eb83ed6af3de6c4d86><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>文件和流</h1><h1 class=pgc-h-arrow-right>文件File</h1><ul><li>new File(filePath, mode): open or create the file at filePath with the mode string specifying how it should be opened. For example "wb" to open the file for writing in binary mode (this is the same format as fopen() from the C standard library).</li><li>write(data): synchronously write data to the file, where data is either a string or a buffer as returned by NativePointer#readByteArray</li><li>flush(): flush any buffered data to the underlying file</li><li>close(): close the file. You should call this function when you’re done with the file unless you are fine with this happening when the object is garbage-collected or the script is unloaded. 举个例子，hook Activity的onResume函数，当回调onResume函数的时候，先通过File操作向'/data/data/com.lingpao.lpcf622b/files/chat/test.txt'这个文件中写入'hello world'，最后调用系统的onResume回调。这里只是举例，实际情况可能需要保存一些重要的数据或者修改一些重要的数据。</li></ul><pre><code>import frida,sysdef on_message(message, data):    if message['type'] == 'send':        print(" {0}".format(message['payload']))    else:        print(message)passsession = frida.get_usb_device().attach("com.lingpao.lpcf622b")jscode = """if(Java.available){    Java.perform(function(){          var Activity = Java.use('android.app.Activity');         Activity.onResume.implementation = function () {                send('onResume() got called! ');                var file = new File('/data/data/com.lingpao.lpcf622b/files/chat/test.txt', 'wb');                file.write('hello world');                file.flush();                file.close();                this.onResume();         };    });}"""script = session.create_script(jscode)script.on("message", on_message)print(' Start attach')script.load()sys.stdin.read()</code></pre><h1 class=pgc-h-arrow-right>输入流InputStream</h1><p style=text-align:start>All methods are fully <strong>asynchronous</strong> and return <strong>Promise</strong> objects.</p><ul><li>close(): close the stream, releasing resources related to it. Once the stream is closed, all other operations will fail. Closing a stream multiple times is allowed and will not result in an error.</li><li>read(size): read up to size bytes from the stream. The returned Promise receives an ArrayBuffer up to size bytes long. End of stream is signalled through an empty buffer.</li><li>readAll(size): keep reading from the stream until exactly size bytes have been consumed. The returned Promise receives an <strong>ArrayBuffer</strong> that is exactly size bytes long. Premature error or end of stream results in the Promise getting rejected with an error, where the Error object has a partialData property containing the incomplete data.</li></ul><p style=text-align:start>在类Unix系统中，获取输入流的方式:</p><ul><li>new UnixInputStream(fd[, options]): create a new InputStream from the specified file descriptor fd. You may also supply an options object with autoClose set to true to make the stream close the underlying file descriptor when the stream is released, either through close() or future garbage-collection.</li></ul><p style=text-align:start>在Windwos平台下，获取输入流的方式:</p><ul><li>new Win32InputStream(handle[, options]): create a new InputStream from the specified handle, which is a Windows HANDLE value. You may also supply an options object with autoClose set to true to make the stream close the underlying handle when the stream is released, either through close() or future garbage-collection.</li></ul><p style=text-align:start>Android是基于Linux系统的，所以属于类Unix系统，具体代码示例，在前面的文章中对Intercepter进行了介绍，这里对open函数进行替换，对打开的文件读取输入流。</p><pre><code>var openPtr = Module.getExportByName(null, 'open');var open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);Interceptor.replace(openPtr, new NativeCallback(function (pathPtr, flags) {  var path = pathPtr.readUtf8String();  console.log('Opening "' + path + '"');  var fd = open(pathPtr, flags); if (fd &gt; 0){    var input = new UnixInputStream(fd);    var promise = input.read(1000);    promise.then(function(result){      console.log(' burning'+hexdump(result,{lenght:1000}));    }).catch(function(error){      console.log(' fail:'+error);    }); }  console.log('Got fd: ' + fd);  return fd;}, 'int', ['pointer', 'int']));</code></pre><p>运行结果如下。</p><div class=pgc-img><img alt=Frida之文件操作 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4e216cde8804b18b908b54a65a16e87><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>输出流OutputStream</h1><p style=text-align:start>All methods are fully <strong>asynchronous</strong> and return <strong>Promise</strong> objects.</p><ul><li>close(): close the stream, releasing resources related to it. Once the stream is closed, all other operations will fail. Closing a stream multiple times is allowed and will not result in an error.</li><li>write(data): try to write data to the stream. The data value is either an ArrayBuffer or an array of integers between 0 and 255. The returned Promise receives a Number specifying how many bytes of data were written to the stream.</li><li>writeAll(data): keep writing to the stream until all of data has been written. The data value is either an ArrayBuffer or an array of integers between 0 and 255. Premature error or end of stream results in an error, where the Error object has a partialSize property specifying how many bytes of data were written to the stream before the error occurred.</li><li>writeMemoryRegion(address, size): try to write size bytes to the stream, reading them from address, which is a NativePointer. The returned Promise receives a Number specifying how many bytes of data were written to the stream.</li></ul><p style=text-align:start>在类Unix系统中，获取输出流的方式:</p><ul><li>new UnixOutputStream(fd[, options]): create a new OutputStream from the specified file descriptor fd. You may also supply an options object with autoClose set to true to make the stream close the underlying file descriptor when the stream is released, either through close() or future garbage-collection.</li></ul><p style=text-align:start>在Windwos平台下，获取输出流的方式:</p><ul><li>new Win32OutputStream(handle[, options]): create a new OutputStream from the specified handle, which is a Windows HANDLE value. You may also supply an options object with autoClose set to true to make the stream close the underlying handle when the stream is released, either through close() or future garbage-collection.</li></ul><p style=text-align:start>具体使用，可参考InputStream的使用。</p><h1 class=pgc-h-arrow-right>输入输出流</h1><p style=text-align:start>输入和输出都是相对的。高中物理讲过火车上的人，以车做参考系，人是静止的，但是如果以树做参考系人是运动的，那末输入输出的参考系是什么？</p><p style=text-align:start>内存。往内存中写就是输入，从内存中向文件中写就是输出。</p><h1 class=pgc-h-arrow-right>写在最后</h1><p style=text-align:start>预告一下，下篇Frida的文章说网络，网络的本质其实还是文件。</p><h1 class=pgc-h-arrow-right>公众号</h1><p style=text-align:start>更多Frida相关的内容，欢饮关注我的微信公众号:无情剑客。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Frida','文件','操作'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>