<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>线性代数：矩阵基本运算 | 极客快訊</title><meta property="og:title" content="线性代数：矩阵基本运算 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/00f970aeafc149f583ff33103d6389e5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/aff234cf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/aff234cf.html><meta property="article:published_time" content="2020-11-14T20:52:19+08:00"><meta property="article:modified_time" content="2020-11-14T20:52:19+08:00"><meta name=Keywords content><meta name=description content="线性代数：矩阵基本运算"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/aff234cf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>线性代数：矩阵基本运算</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>在本文中，我们将介绍矩阵的大部分基本运算，依次是矩阵的加减法、矩阵的标量乘法、矩阵与矩阵的乘法、求转置矩阵，以及深入了解矩阵的行列式运算。本文将不会涉及逆矩阵、矩阵的秩等概念，将来再探讨它们。</p><h2 class=pgc-h-arrow-right>矩阵的加减法</h2><p>矩阵的 <strong>加法</strong> 与 <strong>减法</strong> 运算将接收两个矩阵作为输入，并输出一个新的矩阵。矩阵的加法和减法都是在分量级别上进行的，因此要进行加减的矩阵必须有着相同的维数。</p><p>为了避免重复编写加减法的代码，我们先创建一个可以接收运算函数的方法，这个方法将对两个矩阵的分量分别执行传入的某种运算。然后在加法、减法或者其它运算中直接调用它就行了：</p><pre><code>class Matrix {  // ...  componentWiseOperation(func, { rows }) {    const newRows = rows.map((row, i) =&gt;      row.map((element, j) =&gt; func(this.rows[i][j], element))    )    return new Matrix(...newRows)  }  add(other) {    return this.componentWiseOperation((a, b) =&gt; a + b, other)  }  subtract(other) {    return this.componentWiseOperation((a, b) =&gt; a - b, other)  }}const one = new Matrix(  [1, 2],  [3, 4])const other = new Matrix(  [5, 6],  [7, 8])console.log(one.add(other))// Matrix { rows: [ [ 6, 8 ], [ 10, 12 ] ] }console.log(other.subtract(one))// Matrix { rows: [ [ 4, 4 ], [ 4, 4 ] ] }复制代码</code></pre><h2 class=pgc-h-arrow-right>矩阵的标量乘法</h2><p>矩阵的标量乘法与向量的缩放类似，就是将矩阵中的每个元素都乘上标量：</p><pre><code>class Matrix {  // ...  scaleBy(number) {    const newRows = this.rows.map(row =&gt;      row.map(element =&gt; element * number)    )    return new Matrix(...newRows)  }}const matrix = new Matrix(  [2, 3],  [4, 5])console.log(matrix.scaleBy(2))// Matrix { rows: [ [ 4, 6 ], [ 8, 10 ] ] }复制代码</code></pre><h2 class=pgc-h-arrow-right>矩阵乘法</h2><p>当 <strong>A</strong> 、 <strong>B</strong> 两个矩阵的维数是 <strong>兼容</strong> 的时候，就能对这两个矩阵进行矩阵乘法。所谓维数兼容，指的是 <strong>A</strong> 的列数与 <strong>B</strong> 的行数相同。矩阵的乘积 <strong>AB</strong> 是通过对 <strong>A</strong> 的每一行与矩阵 <strong>B</strong> 的每一列计算点积得到：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00f970aeafc149f583ff33103d6389e5><p class=pgc-img-caption></p></div><pre><code>class Matrix {  // ...  multiply(other) {    if (this.rows[0].length !== other.rows.length) {      throw new Error('The number of columns of this matrix is not equal to the number of rows of the given matrix.')    }    const columns = other.columns()    const newRows = this.rows.map(row =&gt;       columns.map(column =&gt; sum(row.map((element, i) =&gt; element * column[i])))    )    return new Matrix(...newRows)  }}const one = new Matrix(  [3, -4],  [0, -3],  [6, -2],  [-1, 1])const other = new Matrix(  [3,  2, -4],  [4, -3,  5])console.log(one.multiply(other))// Matrix {//   rows://    [ [ -7, 18, -32 ],//      [ -12, 9, -15 ],//      [ 10, 18, -34 ],//      [ 1, -5, 9 ] ]}复制代码</code></pre><p>我们可以把矩阵乘法 <strong>AB</strong> 视为先后应用 <strong>A</strong> 和 <strong>B</strong> 两个线性变换矩阵。为了更好地理解这种概念，可以看一看我们的linear-algebra-demo。</p><p>下图中黄色的部分就是对红色方块应用线性变换 <strong>C</strong> 的结果。而线性变换 <strong>C</strong> 就是矩阵乘法 <strong>AB</strong> 的结果，其中 <strong>A</strong> 是做相对于 y 轴进行反射的变换矩阵， <strong>B</strong> 是做剪切变换的矩阵。</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8de6b045ed94e9296c0b25171d5ff31><p class=pgc-img-caption></p></div><p>如果在矩阵乘法中调换 <strong>A</strong> 和 <strong>B</strong> 的顺序，我们会得到一个不同的结果，因为相当于先应用了 <strong>B</strong> 的剪切变换，再应用 <strong>A</strong> 的反射变换：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/81a0781fb25a4efe91d58bd948e320f4><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>转置</h2><p>转置矩阵 由公式 定义。换句话说，我们通过关于矩阵的对角线对其进行翻转来得到转置矩阵。需要注意的是，矩阵对角线上的元素不受转置运算影响。</p><pre><code>class Matrix {  // ...  transpose() {    return new Matrix(...this.columns())  }}const matrix = new Matrix(  [0,  1,  2],  [3,  4,  5],  [6,  7,  8],  [9, 10, 11])console.log(matrix.transpose())// Matrix {//   rows: [//     [ 0, 3, 6, 9 ],//     [ 1, 4, 7, 10 ],//     [ 2, 5, 8, 11 ]//   ]// }复制代码</code></pre><h2 class=pgc-h-arrow-right>行列式运算</h2><p>矩阵的 <strong>行列式</strong> 运算将计算矩阵中的所有系数，最后输出一个数字。准确地说，行列式可以描述一个由矩阵行构成的向量的相对几何指标（比如在欧式空间中的有向面积、体积等空间概念）。更准确地说，矩阵 <strong>A</strong> 的行列式相当于告诉你由 <strong>A</strong> 的行定义的方块的体积。 矩阵的行列式运算如下所示：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/422ba23fda7743f8b297f4c5740a2a22><p class=pgc-img-caption></p></div><p>矩阵的行列式运算如下所示：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7584d234233f4a44a5a393466fa44eb3><p class=pgc-img-caption></p></div><p>我们的方法可以计算任意大小矩阵（只要其行列的数量相同）的行列式：</p><pre><code>class Matrix {  // ...  determinant() {    if (this.rows.length !== this.rows[0].length) {      throw new Error('Only matrices with the same number of rows and columns are supported.')    }    if (this.rows.length === 2) {      return this.rows[0][0] * this.rows[1][1] - this.rows[0][1] * this.rows[1][0]    }    const parts = this.rows[0].map((coef, index) =&gt; {      const matrixRows = this.rows.slice(1).map(row =&gt; [ ...row.slice(0, index), ...row.slice(index + 1)])      const matrix = new Matrix(...matrixRows)      const result = coef * matrix.determinant()      return index % 2 === 0 ? result : -result    })    return sum(parts)  }}const matrix2 = new Matrix(  [ 0, 3],  [-2, 1])console.log(matrix2.determinant())// 6const matrix3 = new Matrix(  [2, -3,  1],  [2,  0, -1],  [1,  4,  5])console.log(matrix3.determinant())// 49const matrix4 = new Matrix(  [3, 0, 2, -1],  [1, 2, 0, -2],  [4, 0, 6, -3],  [5, 0, 2,  0])console.log(matrix4.determinant())// 20复制代码</code></pre><p>行列式可以告诉我们变换时对象被拉伸的程度。因此我们可以将其视为线性变换改变面积的因子。为了更好地理解这个概念，请参考linear-algebra-demo：</p><p>在下图中，我们可以看到对红色的 <strong>1×1</strong> 方形进行线性变换后得到了一个 <strong>3×2</strong> 的长方形，面积从 <strong>1</strong> 变为了 <strong>6</strong> ，这个数字与线性变换矩阵的行列式值相同。</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5e60274b656f45cb9cddecb36607ac31><p class=pgc-img-caption></p></div><p>如果我们应用一个剪切变换，可以看到方形会变成一个面积不变的平行四边形。因此，剪切变换矩阵的行列式值等于 1：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6a52355ea064461db2a917a5ef11b4df><p class=pgc-img-caption></p></div><p>如果行列式的值是 <strong>负数</strong> ，则说明应用线性变换后，空间被反转了。比如在下图中，我们可以看到变换前 在 的左边，而变换后 在 的右边。</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d9de00463564145ad899136d37e5018><p class=pgc-img-caption></p></div><p>如果变换的行列式为 <strong>0</strong> ，则表示它会将所有空间都压缩到一条线或一个点上。也就是说，计算一个给定矩阵的行列式是否为 0，可以判断这个矩阵对应的线性变换是否会将对象压缩到更小的维度去。</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab4dac1eb7d04c31af92da11b4e7632f><p class=pgc-img-caption></p></div><p>在三维空间里，行列式可以告诉你体积缩放了多少：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e23c83153f644cc98ee81a625ec1bfe><p class=pgc-img-caption></p></div><p>变换行列式等于 0，意味着原来的空间会被完全压缩成体积为 0 的空间。如前文所说，如果在 2 维空间中变换的行列式为 0，则意味着变换的结果将空间压缩成了一条线或一个点；而在 3 维空间中变换的行列式为 0 意味着一个物体会被压扁成一个平面，如下图所示：</p><div class=pgc-img><img alt=线性代数：矩阵基本运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3943ad4c38664193b07790669a83a4bc><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'线性','代数','矩阵'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E5%AD%A6/32c82740.html alt=线性代数中的矩阵知识点总结 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a11c28c982e64d9bba928409333e6426 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E5%AD%A6/32c82740.html title=线性代数中的矩阵知识点总结>线性代数中的矩阵知识点总结</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>