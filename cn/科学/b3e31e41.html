<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>彻底理解回溯法的精要 | 极客快訊</title><meta property="og:title" content="彻底理解回溯法的精要 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/b3e31e41.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/b3e31e41.html><meta property="article:published_time" content="2020-11-14T20:53:57+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:57+08:00"><meta name=Keywords content><meta name=description content="彻底理解回溯法的精要"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/b3e31e41.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>彻底理解回溯法的精要</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>目录</p><ul><li>问题分析使用什么方法？什么是回溯法？怎么使用回溯法？回溯法的具体实施回溯法的延伸</li></ul><p>给定一个没有重复数字的序列，返回其所有可能的全排列。<br>示例:</p><pre><code>Copy输入: [1,2,3]输出:[  [1,2,3],  [1,3,2],  [2,1,3],  [2,3,1],  [3,1,2],  [3,2,1]]</code></pre><h2 class=pgc-h-arrow-right>问题分析#</h2><h3 class=pgc-h-arrow-right>使用什么方法？#</h3><p>全排列很明显使用回溯法来进行解答</p><h3 class=pgc-h-arrow-right>什么是回溯法？#</h3><blockquote><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p></blockquote><h3 class=pgc-h-arrow-right>怎么使用回溯法？#</h3><p>运用回溯法解题的关键要素有以下三点：</p><ol start=1><li>针对给定的问题，定义问题的解空间；</li><li>确定易于搜索的解空间结构；</li><li>以<strong>深度优先方式</strong>搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。<strong>什么是深度优先搜索？#</strong>深度优先搜索（缩写DFS）有点类似广度优先搜索，也是对一个连通图进行遍历的算法。它的思想是从一个顶点V0开始，沿着一条路一直走到底，如果发现不能到达目标解，那就返回到上一个节点，然后从另一条路开始走到底，这种尽量往深处走的概念即是深度优先的概念。</li></ol><h4 class=pgc-h-arrow-right>代码模板是什么样子的？#</h4><pre><code>Copyvoid BackTrace(int t) {    if(t&gt;n)        Output(x);    else    for(int i = f (n, t); i &lt;= g (n, t); i++ ) {        x[t] = h(i);        if(Constraint(t) &amp;&amp; Bound (t))        BackTrace(t+1);    }}</code></pre><p>其中，t表示递归深度，即当前扩展结点在解空间树中的深度；n用来控制递归深度，即解空间树的高度。当t>n时，算法已搜索到一个叶子结点，此时由函数Output(x)对得到的可行解x进行记录或输出处理</p><p>用 f(n, t)和 g(n, t)分别表示在当前扩展结点处未搜索过的子树的起始编号和终止编号；h(i)表示在当前扩展结点处x[t]的第i个可选值；函数Constraint(t)和 Bound(t)分别表示当前扩展结点处的约束函数和限界函数。若函数Constraint(t)的返回值为真，则表示当前扩展结点处x[1:t]的取值满足问题的约束条件；否则不满足问题的约束条件。若函数Bound(t)的返回值为真，则表示在当前扩展结点处x[1:t]的取值尚未使目标函数越界，还需由BackTrace(t+1)对其相应的子树做进一步地搜索；否则，在当前扩展结点处x[1:t]的取值已使目标函数越界，可剪去相应的子树。</p><h3 class=pgc-h-arrow-right>回溯法的具体实施#</h3><pre><code>Copyclass Solution {    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {      //LeetCode代码模板      }}</code></pre><h4 class=pgc-h-arrow-right>step 1 定义问题的解空间#</h4><h5 class=pgc-h-arrow-right>什么是解空间？</h5><blockquote><p>应用回溯法求解问题时，首先应明确定义问题的解空间，该解空间应至少包含问题的一个最优解。例如，对于有n种物品的 0-1 揹包问题，其解空间由长度为n的 0-1 向量组成，该解空间包含了对变量的所有可能的0-1 赋值。当n=3时，其解空间是{ (0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0), (1, 0, 1), (1, 1, 0), (1, 1, 1) }<br>在定义了问题的解空间后，还需要将解空间有效地组织起来，使得回溯法能方便地搜索整个解空间，通常将解空间组织成树或图的形式。例如，对于n= 3的0-1 揹包问题，其解空间可以用一棵完全二叉树表示，从树根到叶子结点的任意一条路径可表示解空间中的一个元素，如从根结点A到结点J的路径对应于解空间中的一个元素(1, 0, 1)。</p></blockquote><h5 class=pgc-h-arrow-right>定义本题的解空间</h5><p>全排列问题，因为输入数组的长度为n = nums.length，解空间就是一个森林：</p><blockquote><p>这里需要一个森林的图<br>假设n=4且nums[]={1,2,3,4}则解空间应该是<br>第一层：1 2 3 4<br>第二层：12 13 14 /21 23 24/31 32 34<br>第三层：123 124/132 134/213 214/231 234/241 243/312 314/.....<br>第四层：略</p></blockquote><h5 class=pgc-h-arrow-right>确定易于搜索的解空间结构</h5><blockquote><p>解空间主要对应的是子集树和排列树，依据题意进行选择。（根据题意画个图，就知道了）</p></blockquote><p>什么是子集树？？？</p><blockquote><p>子集树是一个数学学科词汇，属于函数类，当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间称为子集树。<br>当所给问题是从n个元素的集合S中找出S满足某种性质的子集时，相应的解空间称为子集树。例如：n个物品的0-1揹包问题所相应的解空间是一棵子集树，这类子集树通常有2^n个叶结点，其结点总数为(2^(n+1))-1。遍历子集树的算法通常需O(2^n)计算时间。</p></blockquote><p>什么是排列树？？</p><blockquote><p>当所给问题是确定n个元素满足某种性质的排列时，相应的解空间树称为排列树。排列树通常有n!个叶子节点。因此遍历排列树需要O(n!)的计算时间。</p></blockquote><p>上面已经确定，要将解空间构建成子集树的形式</p><h4 class=pgc-h-arrow-right>step 2 回溯法的精髓#</h4><h5 class=pgc-h-arrow-right>回溯的精髓</h5><p><strong>退回原状态</strong><br>如何回退是回溯的精髓，什么时候回退<br>就本题而言，第一躺全排列应该是1->2->3->4 ,当走到最后一步4之后，应该回退一步到1->2->3因为3只有一个分支4，再回退一步到1->2，然后满足了约束函数可以进行下一步1->2->4;<br>对于本题，回退到方法在于，标记未被访问的数组下标，回退则重制标记<br>因此可以使用一个visited[]数组，数组的长度为nums.length，被访问则对应的下标标记为true，否则标记为false；</p><h4 class=pgc-h-arrow-right>step 3 回溯函数的设计#</h4><p>void BackTrace(int t)只传递一个参数的话显然是无法满足本题的，因为本题包含了一下5个需要传递的参数：</p><ol start=1><li>visited[] 数组；</li><li>t 递归深度；</li><li>List&lt;List&lt;Integer>> output 保存所有解的大容器</li><li>List&lt;Integer> save 保存解的小容器</li><li>nums[]原始数据</li></ol><p>因此，BackTrace应设计为：</p><pre><code>Copypublic static void BackTrace( List&lt;Integer&gt; save, List&lt;List&lt;Integer&gt;&gt; out, boolean visited[], int nums[]) {        if (save.size() == nums.length) {            out.add(new ArrayList&lt;&gt;(save));            return;        } else            for (int i = 0; i &lt; nums.length; i++) {                if (visited[i]) continue;                visited[i] = true;                save.add(nums[i]);                BackTrace( save, out, visited, nums);                save.remove(save.size() - 1);                visited[i] = false;            }    }</code></pre><p>怎么写出这段代码需要结合前面的内容反复的思考 =-= 我想了好久才理清楚回溯的思路</p><h3 class=pgc-h-arrow-right>回溯法的延伸#</h3><p><strong>子集问题</strong><br>题目：</p><blockquote><p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。<br>说明：解集不能包含重复的子集。<br>示例：<br>输入: nums = [1,2,3] 输出: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ]<br>从上题中我们可以得出结论，这仍然是一道需要使用回溯法的题目。</p></blockquote><h4 class=pgc-h-arrow-right>解空间与解空间结构#</h4><p>很明显这是一个子集数的解空间结构</p><blockquote><p>假设n=3且nums[]={1,2,3}则解空间应该是<br>第一层：1 2 3<br>第二层：12 13/21 23/31 32<br>第三层：123 132/213 231/312 321/</p></blockquote><h4 class=pgc-h-arrow-right>关键性问题#</h4><ol start=1><li>通过什么方法回退？</li><li>约束条件是什么？</li><li>去除重复对象</li></ol><h5 class=pgc-h-arrow-right>检测重复</h5><p>检测重复首先想到的会是哈希表HashMap.因此每一次添加都应该在添加之前查找，如果找到重复则不存入；</p><h5 class=pgc-h-arrow-right>约束条件是什么</h5><p>约束条件应该还是当遍历到最后一个元素时退出？</p><h5 class=pgc-h-arrow-right>通过什么方法回退？</h5><p>由于集合的特殊性。不需要回退；</p><h4 class=pgc-h-arrow-right>函数的设计：#</h4><pre><code>Copypublic static void BackTrack(int t,int[] nums, List&lt;List&lt;Integer&gt;&gt; out, List&lt;Integer&gt; save) {        out.add(new ArrayList&lt;&gt;(save));        for (int i = t; i &lt; nums.length; i++) {            save.add(nums[i]);            BackTrack(i+1,nums, out, save);            save.remove(save.size()-1);        }    } </code></pre><p>作者：Nikura44</p><p>出处：https://www.cnblogs.com/samanian/p/12194520.html</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'彻底','精要','回溯'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>