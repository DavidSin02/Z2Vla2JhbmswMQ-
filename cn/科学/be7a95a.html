<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 | 极客快訊</title><meta property="og:title" content="机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/098e7c3fc26e4c148cd535acf6e21f94"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/be7a95a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/be7a95a.html><meta property="article:published_time" content="2020-10-29T20:56:37+08:00"><meta property="article:modified_time" content="2020-10-29T20:56:37+08:00"><meta name=Keywords content><meta name=description content="机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/be7a95a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>SVM概述</h1><p>支持向量机(SVM)是一种有监督的分类算法，并且它绝大部分处理的也是二分类问题，先通过一系列图片了解几个关于SVM的概念。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/098e7c3fc26e4c148cd535acf6e21f94><p class=pgc-img-caption></p></div><p>上图中有橙色点和蓝色点分别代表两类标签，如果想要将其分类，需要怎么做呢？可能有的伙伴会想到上一篇文章讲到的逻辑回归拟合决策边界，这肯定是一种不错的方法，本文所讲的SVM也是可以解决这种分类问题的；既然都是分类算法，所以通过一个例子可以比对出二者的相同点和不同点。</p><h1 class=pgc-h-arrow-right>超平面</h1><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0bebd7cab35e4f5ca0e2b7679f1c95f6><p class=pgc-img-caption></p></div><p>可以看到，这里给出了两种划分方式，就图中实线而言，在逻辑回归中可以称作决策边界，而在SVM中它被称为超平面(hyperplane)。</p><p>上面例子中数据点都分布在二维平面上，所以此时超平面就为一条直线。如果给出的数据集是三、四、... 、N维呢？此时超平面对应的维度就是二、三、...、N-1维的，下图展示了数据集多维时的超平面。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0406111ff74e4bcd87587b979cf43c53><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>最大间隔</h1><p>对于这个例子，可以将其准确分类的超平面可能有多个，其中具有最大间隔(两条虚线之间的距离)的超平面就是SVM要找的最优解，这个最优解对应两侧虚线所穿过的样本点，就是“支持向量(support vector)”,支持向量到超平面的距离被称为间隔(margin)，如下图绘制标识。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c324ed062baf44c7a81912c5de04f894><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>公式推导</h1><h1 class=pgc-h-arrow-right>超平面方程</h1><p>我们利用SVM算法建模最后想要从众多超平面中求解具有最大间隔的超平面，所以这也是一个最优化问题。</p><p>这里需要了解一下最优化问题的两个基本因素：</p><ul class=ul-list><li>目标函数：你希望什么东西的什么指标达到最好。</li><li>优化对象：你希望改变哪些因素使目标函数达到最优。 在线性SVM算法中，目标函数就是“间隔”，优化对象则是“超平面”。</li></ul><p>所以首先需要推导“超平面”的方程，二维空间内“超平面”的公式也就是直线方程，如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/81210d9fc1794452acae4ea928e0328f><p class=pgc-img-caption></p></div><p>这里将x变成x1，y变成x2的操作是为了将其向量化。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de455f16343f414c84a9b51be2767ae9><p class=pgc-img-caption></p></div><p>最后将其整理成：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5880a4b27e1a434197976285d5843bcc><p class=pgc-img-caption></p></div><p>一般的向量为列向量，所以这里对$\omega$进行了转置，并且$\omega$向量与我们所设直线是相互垂直的，只需要假定直线斜率a为一个常数，绘图即可证明，其中$\omega$控制着直线的方向，b则控制着直线的位置，所以直线方程中需要改变$\omega$和b使目标函数达到最优。</p><h1 class=pgc-h-arrow-right>间隔公式</h1><p>“间隔”就是图中点到“超平面”的距离，公式如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/660c03f30ede4593a41dd8518cbff380><p class=pgc-img-caption></p></div><p>其中d代表间隔，$||\omega||$代表的是$\omega$的二范数(模)，即对所有元素的平方和开平方。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc096ef1d8ed420cb5e661444e362f0a><p class=pgc-img-caption></p></div><p>建模的目标就是为了找到最大间隔，其中最大间隔W=2d，只要W越大，则代表该模型分类的效果越好，最后也就变成了求解d最大化的问题。</p><h1 class=pgc-h-arrow-right>约束条件</h1><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b549b4a3c1de4daeb352e4cb6b160f55><p class=pgc-img-caption></p></div><p>针对上述我们所建分类器，当我们输入数据给分类器时，它会返回一个类别标签，这里先规定蓝色为负样本(-1)、红色为正样本(+1)，我们可以得到一组公式，如果超平面能够准确对图中样本点分类，则可得到以下公式：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cde06375176846a688c6f6e7985e1d19><p class=pgc-img-caption></p></div><p>上述公式可归化成：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d705dacf21554c6895742868b2558645><p class=pgc-img-caption></p></div><blockquote><p>s.t.表示"subject to"即服从某种条件</p></blockquote><p>这里再回顾一下上面的最大间隔方程，求最大间隔的思想可以概括为求<strong>最小的</strong>点到超平面的几何距离的<strong>最大化</strong>。最小是为了分类时不同类别都能够得到准确分类，距离最大化则是为了获取”最大间隔“，以达到对分类器调优，公式如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a43217808ae4cab93ee4f1297475369><p class=pgc-img-caption></p></div><p>如果我们希望最优的超平面的间隔的几何距离为$\gamma$,即所有样本点到超平面的几何距离至少为$\gamma$，所以下面公式一定成立。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/da50d7d6b96542528e5b639b25211610><p class=pgc-img-caption></p></div><p>这里$\gamma$将其设定为1。可以这么想，不论我们$\gamma$设定的是几，将等式两边同时除以$\gamma$，$\omega$和b的系数缩小了$\gamma$倍，但超平面是不动的，系数是可以同比例缩放的，可以类比直线方程。 固定$\gamma$之后，可以得到以下公式。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ad85e3aadab44e029dfebad271ceb48f><p class=pgc-img-caption></p></div><p>这里对$\omega$做了一定处理，最大化$\frac{1}{||\omega||}$和最小化$\frac{1}{2}||\omega||^2$是等价的，这样做是为了在进行最优化时对目标函数求导方便，对最优解没有影响。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ac64e7eed49420f9a90ef3a0717a4cc><p class=pgc-img-caption></p></div><p>其中第一个公式为我们的目标函数，第二公式也就是这个最优化问题中的约束条件，由于$min\frac{1}{2}||\omega||^2$是一个凸函数，所以这个问题是凸优化问题。</p><h1 class=pgc-h-arrow-right>求解最优化问题</h1><h1 class=pgc-h-arrow-right>最优化问题分类</h1><p>最优化问题一般可分为两大类：无约束优化问题和约束优化问题，而约束优化问题又可分为含等式约束优化问题和含不等式约束优化问题。</p><ul class=ul-list><li>对于无约束优化问题，可以对函数求导，然后令其为零，从候选值中选取最优值，并加以验证；若函数为凸函数，则可以保证是最优解。随机梯度下降和批量梯度下降就是无约束优化方法。</li><li>对于含等式约束优化问题，常用的方法是利用拉格朗日乘子法将其转化为无约束优化问题求解。具体为将约束条件和函数写成一个函数，称为拉格朗日函数，系数为拉格朗日乘子；通过拉格朗日函数对各个变量求导，令其为零，从候选值中选取最优值，并加以验证。</li><li>对于含不等式约束优化问题，主要通过KKT条件将其转化成无约束优化问题求解。具体为通过构建拉格朗日函数，在一些条件下求出最优值的必要条件，这个条件就是KKT条件。</li></ul><blockquote><p>A的必要条件就是A可以推出的结论</p></blockquote><p>对于我们所构造出的最优化问题明显是属于含不等式约束优化问题，关于拉格朗日函数的概念不过多介绍，下面介绍拉格朗日乘子法，并通过拉格朗日乘子法引出对偶问题和KKT条件。</p><h1 class=pgc-h-arrow-right>拉格朗日乘子法</h1><p>拉格朗日乘子法的思想就是通过引入拉格朗日乘子，将有d个变量和k个约束条件的最优化问题转化为d+k个变量的无约束优化问题求解。</p><p>这里感兴趣的伙伴可以搜一下大佬的博客或者西瓜书上都有详细介绍，真是后悔高数课上没有仔细听这部分。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d855d89a93964caf96c0209a1420ea86><p class=pgc-img-caption></p></div><p>通过引入拉格朗日乘子$\lambda$可以将上述的最优化问题转化成下面形式：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7bbdc038625d4ae88b1e6b4123ea0ed3><p class=pgc-img-caption></p></div><p>其中需要注意的是$\lambda>=0$,$1-y_i(\omega^Tx_i+b)=0$,通过拉格朗日函数我们可以将上述公式转化为： ![](https://imgkr.cn-bj.ufileos.com/e173f775-5680-4a4b-a383-c9d3da743e07.png) 有的伙伴这里可能会不理解，为什么是拉格朗日函数最大值的最小化，下图介绍了原因。 ![](https://imgkr.cn-bj.ufileos.com/8efbe616-5baa-4f98-8ccf-508857c6d6e1.png) 很明显当$1-y_i(\omega^Tx_i+b)0$时，目标函数取值为正无穷是没有意义的，而当$1-y_i(\omega^Tx_i+b)&lt;=0$时,两者则是等价的。</p><h1 class=pgc-h-arrow-right>对偶问题</h1><p>利用对偶性可以将上述原问题转化成对偶问题，如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ecfa8aa871414b0d8dc2115ec473cc2b><p class=pgc-img-caption></p></div><p>这个过程的主要操作就是将min和max互掉位置，并且二者之间有一个性质，即前者>=后者，这就好比在高个子人群中挑一个身高较矮的要高于在矮个子人群中挑一个身高较高的。默认情况下二者是呈弱对偶关系的，但在此目标函数和约束条件下是呈强对偶关系(等价关系)的。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0c507e1057d644d18ab262347c3fc991><p class=pgc-img-caption></p></div><p>在转化成对偶问题之后，我们可以先求$min_\omega,bL(\omega,b,\lambda)$,分别令函数$L(\omega,b,\lambda)$对$\omega,b$求偏导，并使其等于0。</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/389eb43b62134614baca0983d4f0c35d><p class=pgc-img-caption></p></div><p>在将上述两个式子带入至构建的拉格朗日函数中，可得：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44aeb394816849cbb3c525f1dd5ef4f3><p class=pgc-img-caption></p></div><p>最后整理一下得出我们推导过后最终的优化问题，如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/db66604b4a1d4ee79957a41bccde5e4e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>KKT条件</h1><p>假设有这样一个含不等式约束的优化问题：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2c30bf4da412434ba2c5919d7f26ac50><p class=pgc-img-caption></p></div><p>如果想利用KKT条件处理此优化问题，需要利用拉格朗日乘子法将不等式约束、等式约束和目标函数合并写成一个式子，如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/77a6b43e0d5c4c37903a8b3cad369d77><p class=pgc-img-caption></p></div><p>KKT条件就是说取到的最优值必须满足以下条件：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8b60a1af75144eea981cd0fb12e6f366><p class=pgc-img-caption></p></div><p>当原问题与对偶问题呈强对称关系是此问题满足KKT条件的充分必要条件，所以本文最优化问题满足的条件如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1fdb3dcd599e43948738d16bc2d9026c><p class=pgc-img-caption></p></div><p>根据这些条件，我们可以得出只有在样本点为支持向量(样本点处于虚线上)时，$\lambda$可以取任意值，而其他位置的样本点$\lambda$一定为0。这就和逻辑回归有不同之处了，逻辑回归在拟合决策边界时，所有样本都会有影响，而SVM有作用的主要是边界线附近的样本。</p><p>因为我们所设超平面方程为$f(x)=\omega^Tx+b$，所以我们求得原始最优化问题的解为$\omega^、b^$，在L对$\omega$求导时得到了$\omega^$的解，而对于$b^$,求解过程如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ba338df255e345ac8d6aa32c15b46fa3><p class=pgc-img-caption></p></div><p>这里需要注意的点是设定$(x_k,y_k)$是支持向量，所以$y_k=+1或y_k=-1$,$(y_k)^2=1$就可以消去。最终获取到的最优超平面方程如下：</p><div class=pgc-img><img alt=机器学习笔记(九)——手撕支持向量机SVM之间隔、对偶、KKT推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5391e0484d774a739d11bfa3c6f1251d><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>总结</h1><ul class=ul-list><li>介绍了超平面与最大间隔的概念。</li><li>在二维空间内推导超平面方程并介绍间隔公式。</li><li>推导该优化问题的约束条件。</li><li>介绍了最优化问题的分类及对应解决思想。</li><li>通过拉格朗日乘子法引出对偶问题。</li><li>在对偶问题的基础上讲解KKT条件。</li><li>博主还是个菜鸟，欢迎指出文中出现的问题。</li></ul><p>本文不包含代码，着重于公式推导，对于手写代码比较重要的部分应该在于公式推导，只有了解每一步骤的思想及由来，才能更好的进行编程，下篇文章将会介绍一个简化版的序列最小化(SMO)算法，欢迎关注、感谢阅读。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'机器','学习','笔记'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=机器学习笔记(七)——初识逻辑回归、不同方法推导梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/dc2af9c9.html title=机器学习笔记(七)——初识逻辑回归、不同方法推导梯度公式>机器学习笔记(七)——初识逻辑回归、不同方法推导梯度公式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>