<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 | 极客快訊</title><meta property="og:title" content="算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/153813499336220138bde4e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/c553c38e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/c553c38e.html><meta property="article:published_time" content="2020-11-14T20:53:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:56+08:00"><meta name=Keywords content><meta name=description content="算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/c553c38e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><div><p>如下图（左）所求，有若干个顶点需要全部连通，两个顶点之间的连通都有一定的权值（边值），如何连接可以使其边值求各达到最小？</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153813499336220138bde4e><p class=pgc-img-caption></p></div><p>这其实就是一个构造最小生成树的问题。</p><h1><strong>1 构造最小生成树的Kruskal算法</strong></h1><p>设G=（V，E）是无向连通带权图，V={1，2，…，n}，表示顶点，E表示边集；</p><p>设最小生成树T=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图T=（V，{}），基中V表示顶点，TE表示最小生成树的边集。Kruskal算法将这n个顶点看成是n个孤立的连通分支。它首先将所有的边按权值从小到大排序，然后只要 T 中选中的边数不到n−1，就做如下的贪心选择：</p><p>在边集E中选取权值最小的边（i，j），其中i、j表示边的顶点序号，如果将边（i，j）加入边集TE中不产生回路（圈），则将边（i，j）加入边集TE中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边（i，j）从集合E中删去。继续上面的贪心选择，直到T中所有顶点都在同一个连通分支上为止。此时，选取到的n−1条边恰好构成G的一棵最小生成树T。</p><p>那么，怎样判断加入某条边后图T会不会出现回路呢？</p><p>该算法对于手工计算十分方便，因为用肉眼可以很容易看到挑选哪些边能够避免构成回路（避圈法），但使用计算机程序来实现时，还需要一种机制来进行判断。Kruskal算法用了一个非常聪明的方法，就是运用集合避圈：如果所选择加入的边的起点和终点都在最小生成树T的集合中，那么就可以断定一定会形成回路（圈）。其实就是我们前面提到的“避圈法”：边的两个结点不能属于同一集合。</p><p>算法步骤：</p><p>① 初始化。将图G的边集E中的所有边按权值从小到大排序，边集TE={ }，把每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。</p><p>② 在E中寻找权值最小的边（i，j）。</p><p>③ 如果顶点 i 和 j 位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并（序号→集合号、让集合号取相同值）。</p><p>④ 将边（i，j）从集合E中删去，即E=E−{（i，j）}。</p><p>⑤ 如果选取边数小于n−1，转②；否则，算法结束，生成最小生成树T。</p><h1><strong>2 完美图解</strong></h1><p>设G =（V，E）是无向连通带权图，如图98所示。</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153784868605192e1231b7a><p class=pgc-img-caption></p></div><p>（1）初始化</p><p>将图G的边集E中的所有边按权值从小到大排序，如图2-99所示。</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378487155497ff3daa238><p class=pgc-img-caption></p></div><p>边集初始化为空集，TE={ }，把每个结点都初始化为一个孤立的分支，即一个顶点对应一个集合，集合号为该结点的序号，如图2-100所示↑。</p><p>（2）找最小</p><p>在E中寻找权值最小的边e1（2，7），边值为1。</p><p>（3）合并</p><p>结点2和结点7的集合号（顶点序号）不同，即属于两个不同连通分支，则将边（2，7）加入边集TE，执行合并操作（将两个连通分支所有结点合并为一个集合）；假设把小的集合号赋值给大的集合号，那么7号结点的集合号也改为2，如图2-101所示。</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378619935077e379f4057><p class=pgc-img-caption></p></div><p>（4）找最小</p><p>在E中寻找权值最小的边e2（4，5），边值为3。</p><p>（5）合并</p><p>结点4和结点5集合号不同，即属于两个不同连通分支，则将边（4，5）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么5号结点的集合号也改为4，如图2-102所示↑。</p><p>（6）找最小</p><p>在E中寻找权值最小的边e3（3，7），边值为4。</p><p>（7）合并</p><p>结点3和结点7集合号不同，即属于两个不同连通分支，则将边（3，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么3号结点的集合号也改为2，如图2-103所示。</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1537848892670be1d75de3b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15378620845318939bef9c1><p class=pgc-img-caption></p></div><p>（8）找最小</p><p>在E中寻找权值最小的边e4（4，7），边值为9。</p><p>（9）合并</p><p>结点4和结点7集合号不同，即属于两个不同连通分支，则将边（4，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么4、5号结点的集合号都改为2，如图2-104所示↑。</p><p>（10）找最小</p><p>在E中寻找权值最小的边e5（3，4），边值为15。</p><p>（11）合并</p><p>结点3和结点4集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（12）找最小</p><p>在E中寻找权值最小的边e6（5，7），边值为16。</p><p>（13）合并</p><p>结点5和结点7集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（14）找最小</p><p>在E中寻找权值最小的边e7（5，6），边值为17。</p><p>（15）合并</p><p>结点5和结点6集合号不同，即属于两个不同连通分支，则将边（5，6）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么6号结点的集合号都改为2，如图2-105所示。</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378490178792735dfcd91><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378621230693c1c20dafb><p class=pgc-img-caption></p></div><p>（16）找最小</p><p>在E中寻找权值最小的边e8（2，3），边值为20。</p><p>（17）合并</p><p>结点2和结点3集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（18）找最小</p><p>在E中寻找权值最小的边e9（1，2），边值为23。</p><p>（19）合并</p><p>结点1和结点2集合号不同，即属于两个不同连通分支，则将边（1，2）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么2、3、4、5、6、7号结点的集合号都改为1，如图2-106所示↑。</p><p>（20）选中的各边和所有的顶点就是最小生成树，各边权值之和就是最小生成树的代价。</p><p>从上图可以看到，所有连通的图都只有一个相同的集合号，以此做为判断标准，避免构成回路。</p><h1><strong>3 代码</strong></h1><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153786399083961960937aa><p class=pgc-img-caption></p></div><pre>输入结点数n和边数m：7 12输入结点序号u、v和边值w：1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25</pre><p>输出</p><pre>输出排序后的结点序号u、v和边值w：2 - 7：14 - 5：33 - 7：44 - 7：93 - 4：155 - 7：165 - 6：172 - 3：201 - 2：236 - 7：251 - 6：281 - 7：36选中的各边的两个结点序号和其边值：2 - 7：14 - 5：33 - 7：44 - 7：95 - 6：171 - 2：23点连通成树后边值求和后的最小值：57</pre><h1><strong>4 算法复杂度分析</strong></h1><p>（1）时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为e*loge，算法的时间复杂度为O(e*loge)。而合并集合需要n−1次合并，每次为O(n)，合并集合的时间复杂度为O(n2)。</p><p>（2）空间复杂度：算法所需要的辅助空间包含集合号数组 nodeset[n]，则算法的空间复杂度是O(n)。</p><h1><strong>5 算法优化拓展</strong></h1><p>该算法合并集合的时间复杂度为O(n2)，我们可以用并查集的思想优化，使合并集合的时间复杂度降为O(e*logn)，优化后的程序做如下修改：</p><div class=pgc-img><img alt=算法｜构造最小生成树（全部点连通边值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1537865990116b26b0fe12d><p class=pgc-img-caption></p></div><h1><strong>6 Kruskal算法与Prim算法的比较</strong></h1><p>（1）从算法的思想可以看出，如果图G中的边数较小时，可以采用Kruskal算法，因为Kruskal算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适用于稀疏图，而Prim算法适用于稠密图。</p><p>（2）从时间上讲，Prim算法的时间复杂度为O(n2)，Kruskal算法的时间复杂度为O(eloge)。</p><p>（3）从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V−U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。</p><p>附代码1</p><pre>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;	// ① 数据结构int nodeset[N];				//集合号（顶点序号）数组int n, m;struct Edge {				//边的存储结构(两个顶点和一个权值)	int u;	int v;	int w;}e[N*N];	// ② 初始化void Init(int n){	for(int i = 1; i &lt;= n; i++)		nodeset[i] = i;		//每个结点赋值一个集合号（顶点序号）}	// ③ 定义优先级，按边值进行升序排序bool comp(Edge x, Edge y){	return x.w &lt; y.w;		}	// ④ 合并集合int Merge(int a, int b){ int p = nodeset[a];	//p为a结点的集合号（顶点序号） int q = nodeset[b];	//q为b结点的集合号（顶点序号） if(p==q) 		 return 0;			//集合号相同，什么也不做，返回 for(int i=1;i&lt;=n;i++)	//检查所有结点，把集合号是q的全部改为p { if(nodeset[i]==q) nodeset[i] = p;	//a的集合号赋值给b集合号 } return 1;}int Kruskal(int n){	int ans = 0;	for(int i=0;i&lt;m;i++)		if(Merge(e[i].u, e[i].v)) //如果执行了合并		{			ans += e[i].w;			n--;			cout&lt;&lt;e[i].u&lt;&lt;" - "&lt;&lt;e[i].v&lt;&lt;"："&lt;&lt;e[i].w&lt;&lt;endl;			if(n==1)				return ans;		}		return 0;}int main(){	cout &lt;&lt;"输入结点数n和边数m："&lt;&lt;endl;	cin &gt;&gt; n &gt;&gt; m;	Init(n);	cout &lt;&lt;"输入结点序号u、v和边值w："&lt;&lt;endl;	for(int i=0;i&lt;m;i++)		cin &gt;&gt; e[i].u&gt;&gt; e[i].v &gt;&gt;e[i].w;	sort(e, e+m, comp);		//三个参数：待排序数组的首地址、尾地址，排序方式	cout &lt;&lt;"输出排序后的结点序号u、v和边值w："&lt;&lt;endl;	for(int j=0;j&lt;m;j++)		cout&lt;&lt;e[j].u&lt;&lt;" - "&lt;&lt;e[j].v&lt;&lt;"："&lt;&lt;e[j].w&lt;&lt;endl;	cout&lt;&lt;"选中的各边的两个结点序号和其边值："&lt;&lt;endl;	int ans = Kruskal(n);	cout &lt;&lt; "点连通成树后边值求和后的最小值：" &lt;&lt; ans &lt;&lt; endl;	system("pause");	return 0;}</pre><p>附代码2</p><pre>int Find(int x)				//找祖宗{	if(x != nodeset[x])		nodeset[x] = Find(nodeset[x]);//把当前结点到其祖宗路径上的所有结点的集合号改为祖宗集合号	return nodeset[x];		//返回其祖宗的集合号}int Merge(int a, int b)		//两结点合并集合号{	int p = Find(a);		//找a的集合号	int q = Find(b);		//找b的集合号	if(p==q) return 0;	if(p &gt; q)		nodeset[p] = q;		//小的集合号赋值给大的集合号	else		nodeset[q] = p;	return 1;}</pre><p>－End－</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'算法','最小','构造'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>