<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux高性能服务器编程之高级I/O函数详解（含实例代码） | 极客快訊</title><meta property="og:title" content="Linux高性能服务器编程之高级I/O函数详解（含实例代码） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/a2cc0f57fdec4d4bae7110590a705e39"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/ca430d03.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/ca430d03.html><meta property="article:published_time" content="2020-10-29T21:13:10+08:00"><meta property="article:modified_time" content="2020-10-29T21:13:10+08:00"><meta name=Keywords content><meta name=description content="Linux高性能服务器编程之高级I/O函数详解（含实例代码）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/ca430d03.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux高性能服务器编程之高级I/O函数详解（含实例代码）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p><strong>一、重定向dup和dup2函数</strong></p><pre><code>#include &lt;unistd.h&gt;int dup(int file_descriptor);int dup2(int file_descriptor_one, int file_descriptor_two);</code></pre><ul><li>dup创建一个新的文件描述符， 此描述符和原有的file_descriptor指向相同的文件、管道或者网络连接。</li><li>dup返回的文件描述符总是取系统当前可用的最小整数值。</li></ul><p>dup2函数通过使用参数file_descriptor_two指定新描述符数值，如果file_descriptor_two已经打开，则先关闭。若file_descriptor_one = file_descriptor_two，而不关闭。</p><p>两者调用失败均返回-1, 并设置errno。</p><pre><code>//利用dup模拟实现一个基本的CGI服务器#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;assert.h&gt; int main(int argc, char **argv){	if (argc ！= 3) {	     fprintf(stderr, "Usage: %s id port\n", basename(argv[0]));	     return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]);		struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr);		int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);		int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1);		ret = listen(sock, 5);	assert(ret != -1);		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);	int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if (connfd &lt; 0) {		printf("error: %s\n", strerror(errno));	}	else {		close(STDOUT_FILENO); //关闭标准输出		dup(connfd);          //重定向1到connfd，这样服务器的标准输出内容会直接发送到客户端socket，这就是CGI的基本原理				printf("abc. close stdout_fileno test... dup to client\n"); //printf会直接输出会发送到客户端				close(connfd);	}		close(sock);		return 0;}</code></pre><p><strong>注：需要C/C++ Linux高级服务器架构师学习资料私信“资料”（资料包括C/C++，Linux，golang技术，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，TCP/IP，协程，DPDK，ffmpeg等），免费分享</strong></p><div class=pgc-img><img alt=Linux高性能服务器编程之高级I/O函数详解（含实例代码） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a2cc0f57fdec4d4bae7110590a705e39><p class=pgc-img-caption></p></div><p><strong>二、分散读readv和集中写writev函数</strong></p><p>readv将数据从文件描述符读到分散的内存块中，即分散读。</p><p>writev将多块分散的内存一并写入文件描述符中，即集中写。</p><pre><code>#include &lt;sys/uio.h&gt;ssize_t readv(int fd, const struct iovec *vector, int count);ssize_t writev(int fd, const struct iovec *vector, int count);</code></pre><p>fd参数是被操作的文件描述符。</p><p>vector参数是iovec结构体：</p><pre><code>#include &lt;sys/uio.h&gt;struct iovec{    void *iov_base;  //指向一个缓冲区，这个缓冲区是存放readv所接收的数据或是writev将要发送的数据    size_t iov_len;  //接收的长度以及实际写入的长度};</code></pre><p>count参数是vector数组的长度，即有多少块内存数据需要从fd读出或写到fd。</p><p>两者调用成功是返回读出/写入fd的字节数，失败返回-1,并设置errno。类似于简化版的recvmsg和sendmsg。</p><p>以下简陋的模拟WEB服务器，采用集中写的方式。省略了HTTP请求的接收及解析， 直接将目标文件作为第3个参数传递给服务端程序，客户端telnet到服务端即可获得该文件。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt; #define BUFFER_SIZE 1024 //定义两种HTTP状态码和状态信息static const char *status_line[2] = {"200 OK", "500 Internal server error"};  int main(int argc, char **argv){	if(argc != 4) {		fprintf(stderr, "Usage: %s ip port filename\n", basename(argv[0]));		return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]);	const char *file_name = argv[3];    //将目标文件作为程序的第三个参数传入		struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr);		int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);	printf("create socket success\n");		int reuse = 1;	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));		int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1);	fprintf(stderr, "bind address success\n");		ret = listen(sock, 5);	assert(ret != -1);	fprintf(stderr, "listen success\n");		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);		fprintf(stderr, "start accept...\n");		int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if(connfd &lt; 0) {		printf("error: %s\n", strerror(errno));	}	else {		char header_buf[BUFFER_SIZE];             //用于保存HTTP应答的状态行、头部字段和一个空的缓冲区		memset(header_buf, '\0', BUFFER_SIZE);				char *file_buf = NULL;                    //用于存放目标文件内容的缓存		struct stat file_stat;                    //用于获取目标文件的属性		bool valid = true;                        //目标文件是否有效		int len = 0;                              //记录header_buf当前已使用的字节空间				if(stat(file_name, &amp;file_stat) &lt; 0) {     //目标文件不存在			valid = false;		}		else {			if(S_ISDIR(file_stat.st_mode)) {  //目标文件是目录				valid = false;			}			else if (file_stat.st_mode &amp; S_IROTH) {               //当前用户是否有读权限，相对于目标文件				int fd = open(file_name, O_RDONLY);				file_buf = new char[file_stat.st_size + 1];				memset(file_buf, '\0', file_stat.st_size + 1);								fprintf(stderr, "reading %s file...", file_name);								if (read(fd, file_buf, file_stat.st_size) &lt; 0) {						valid = false;				}			}			else {				valid = false;			}		}		 		if (valid) {   //目标文件有效				ret = snprintf(header_buf, BUFFER_SIZE-1,								"%s %s\r\n",								"HTTP/1.1", status_line[0]);												len += ret;				ret = snprintf(header_buf+len, BUFFER_SIZE-1-len,								"content-Length: %ld\r\n",								file_stat.st_size);												len += ret;				ret = snprintf(header_buf+len, BUFFER_SIZE-1-len,								"%s", "\r\n");				                                //将header_buf和file_buf的内容一并写出								struct iovec iv[2];				iv[0].iov_base = header_buf;				iv[0].iov_len = strlen(header_buf);				iv[1].iov_base = file_buf;				iv[1].iov_len = file_stat.st_size;								fprintf(stderr, "read %s success\nsending %s file to client...\n", file_name, file_name);								ret = writev(connfd, iv, 2);   //集中写						}		else {     //目标文件无效			ret = snprintf(header_buf, BUFFER_SIZE-1,							"%s %s\r\n",							"HTTP/1.1", status_line[1]);						len += ret;			ret = snprintf(header_buf+len, BUFFER_SIZE-1-len,							"%s", "\r\n");						fprintf(stderr, "read %s failed\nsending error message to client...\n", file_name);							send(connfd, header_buf, strlen(header_buf), 0);		}				close(connfd);				if (file_buf != NULL) {			delete[] file_buf;			file_buf = NULL;		}	}		close(sock);			return 0;}</code></pre><p><strong>三、sendfile函数</strong></p><p>sendfile在两个文件描术符之间直接传递数据，完全在内核中操作，从而避免了内核缓冲区到用户缓冲区的拷贝，因此效率很高，称为零拷贝。</p><pre><code>#include &lt;sys/sendfile.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></pre><p>out_fd参数是待写入内容的文件描述符。</p><p>in_fd参数是待读出内容的文件描述符。</p><p>offset参数指定从读入文件流的哪个位置开始读，如果为空，则从文件流的默认起始位置读入。</p><p>count参数指定传输的字节数。</p><p>调用成功时返回传输的字节数，失败则为-1，并设置errno</p><p>注： man手册指出，in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd必须是一个socket。可见，sendfile专为网络传输文件而生。</p><pre><code>//用sendfile函数传输文件#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;fcntl.h&gt;  int main(int argc, char **argv){	if (argc &lt;= 3) {		fprintf(stderr, "Usage: %s ip port filename\n", basename(argv[0]));		return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]);	const char *file_name = argv[3];		int filefd = open(file_name, O_RDONLY);	assert(filefd &gt; 0);		struct stat stat_buf;	fstat(filefd, &amp;stat_buf);		struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr);		int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);		int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1);		ret = listen(sock, 5);	assert(ret != -1);		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);		int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if (connfd &lt; 0) {		fprintf(stderr, "errno is: %s\n", strerror(errno));	}	else {		sendfile(connfd, filefd, NULL, stat_buf.st_size);		close(connfd);	}		close(sock);			return 0;}</code></pre><p><strong>splice函数</strong></p><p>splice用于在两个文件描述符之间移动数据， 也是零拷贝。</p><pre><code>#include &lt;fcntl.h&gt;ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);</code></pre><p>fd_in参数是待输入描述符。如果它是一个管道文件描述符，则off_in必须设置为NULL；否则off_in表示从输入数据流的何处开始读取，此时若为NULL，则从输入数据流的当前偏移位置读入。</p><p>fd_out/off_out与上述相同，不过是用于输出。</p><p>len参数指定移动数据的长度。</p><p>flags参数则控制数据如何移动：</p><ul><li>SPLICE_F_NONBLOCK：非阻塞的splice 操作，但实际效果还会受文件描述符本身的阻塞状态的影响。</li><li>SPLICE_F_MORE：给内核一个提示：后续的 splice 系统调用将会有更多的数据传。</li><li>SPLICE_F_MOVE：如果合适的话，按整页内存移动数据。这只是给内核的一个提示。不过，因为它的实现存在BUG，所以自内核2.6.21后，它实际上没有任何效果。</li></ul><p>注意：使用splice时， fd_in和fd_out中必须至少有一个是管道文件描述符。</p><p>调用成功时返回移动的字节数量；它可能返回0,表示没有数据需要移动，这通常发生在从管道中读数据时而该管道没有被写入的时候。</p><p>失败时返回-1，并设置errno。</p><p style=text-align:center>splice函数可能产生的errno及其含义</p><div class=pgc-img><img alt=Linux高性能服务器编程之高级I/O函数详解（含实例代码） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5cb636f55ca24d9ebd51fc59329a6fce><p class=pgc-img-caption></p></div><p>下面代码：通过splice将客户端的内容读入到管道中， 再从管道中读出到客户端，从而实现高效简单的回显服务。整个过程未执行recv/send，因此也未涉及用户空间到内核空间的数据拷贝。</p><pre><code>//使用splice实现的回显服务器#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;  int main(int argc, char **argv){ 	if (argc &lt;= 2) {		printf("usage: %s ip port\n", basename(argv[0]));		return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]); 	struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr); 	int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);		int reuse = 1;	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse)); 	int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1); 	ret = listen(sock, 5);	assert(ret != -1);		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);		int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if (connfd &lt; 0) {		printf("errno is: %s\n", strerror(errno));	}	else {		int pipefd[2];						ret = pipe(pipefd);  //创建管道		assert(ret != -1);		                //将connfd上的客户端数据定向到管道中		ret = splice(connfd, NULL, pipefd[1], NULL,						32768, SPLICE_F_MORE | SPLICE_F_MOVE);		assert(ret != -1);		                //将管道的输出定向到connfd上		ret = splice(pipefd[0], NULL, connfd, NULL,						32768, SPLICE_F_MORE | SPLICE_F_MOVE);		assert(ret != -1);								close(connfd);	} 		close(sock);    	return 0;}</code></pre><p><strong>tee函数</strong></p><p>tee在两个管道文件描述之间复制数据，也是零拷贝操作。</p><pre><code>#include &lt;fcntl.h&gt;ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);</code></pre><p>它的参数与splice相同，但fd_in和fd_out都必须是管道文件描述符，调用成功时返回复制的字节数。返回0表示没有复制任务数据。失败时返回-1，并设置errno。</p><p>用tee和splice实现从标准输入到终端和文件的程序：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt; int main(int argc, char **argv){	if (argc != 2) {		fprintf(stderr, "Usage: %s &lt;file&gt;\n", argv[0]);		return 1;	}		uid_t uid = getuid();	uid_t euid = geteuid();	printf("userid: %d, effective userid: %d\n", uid, euid);		int filefd = open(argv[1], O_CREAT | O_WRONLY | O_TRUNC, 0666);	assert(filefd &gt; 0);		int pipefd_stdout[2];	int ret = pipe(pipefd_stdout);	assert(ret != -1);		int pipefd_file[2];	ret = pipe(pipefd_file);	assert(ret != -1);	        //将标准输入的内容输出到管道	ret = splice(STDOUT_FILENO, NULL, pipefd_stdout[1], NULL,					32768, SPLICE_F_MORE | SPLICE_F_MOVE);	assert(ret != -1);	        //将管道pipefd_stdout的输出复制到管理pipefd_file的输入端	ret = tee(pipefd_stdout[0], pipefd_file[1],				32768, SPLICE_F_NONBLOCK);	assert(ret != -1);	        //将管道pipefd_file的输出定向到文件描述符filefd上，写入文件	ret = splice(pipefd_file[0], NULL, filefd, NULL,					32768, SPLICE_F_MORE | SPLICE_F_MOVE);	assert(ret != -1);	        //将管道pipefd_stdout的输出定向到标准出， 其内容和写入文件的内容一致	ret = splice(pipefd_stdout[0], NULL, STDOUT_FILENO, NULL,					32768, SPLICE_F_MORE | SPLICE_F_MOVE);	assert(ret != -1);		close(filefd);	close(pipefd_file[0]);	close(pipefd_file[1]);	close(pipefd_stdout[0]);	close(pipefd_stdout[1]);		return 0;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','服务器','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>