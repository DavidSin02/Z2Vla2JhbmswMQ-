<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu | 极客快訊</title><meta property="og:title" content="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d9a5ff954d45460fa5bb43d259dd388e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/cb9490d5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/cb9490d5.html><meta property="article:published_time" content="2020-10-29T21:13:00+08:00"><meta property="article:modified_time" content="2020-10-29T21:13:00+08:00"><meta name=Keywords content><meta name=description content="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/cb9490d5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p><strong>一、支持向量机（SVM: support vector machine）</strong></p><p>support vector machine (SVM): a support vector machine is supervised machine learning model that uses classification algorithms for two-group classification problems. After giving an SVM model sets of labeled training data for each category, they’re able to categorize new text.</p><p>支持向量机是一种使用分类算法解决二分类问题的监督学习模型。</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d9a5ff954d45460fa5bb43d259dd388e></div><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9720d4607ce44300874672354a4f6cba></div><p>上图中不同颜色的点表示不同的类型（class)，找到一个平面使得两类support vector支持向量之间的距离(margin)最大。之间的距离通过计算后得</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0d23244c76404e97a9514781b17385b8></div><p>，分类问题就变成了一个求解</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d8b876faba264de7983633b503dd7778></div><p>最大值的过程，即求解</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f7d0a14f09dc4bedb36c954c6b18bdc9></div><p>的最小值的过程。具体理论计算网上找找会有很多写得很全面的文章。理论我就不多赘述啦。下面还是直接来代码比较实际一点。希望看完对大家有些帮助。</p><p>上面图片中用直线就可以将这些点划分两个区域了，但在实际很多情况下，只是 线性划分并不能将这两个不同颜色的类别划分开来。如下右图，这种无法用线性划分的，我们应该可以用一条封闭的曲线将两个类别划分开来。接下来本文会用代码针对线性和非线性的情况分别进行划分。</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f12f51aab80e4da7a3008e88a8c46d92></div><p><strong>二、支持向量机处理线性关系问题：‍</strong></p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c673ab8e8eb14fe9b6054109aaa5dbd1></div><p>关注公众号查看，体验更佳哦～</p><ul><li><br></li></ul><p>%matplotlib inline</p><p>import numpy as np</p><p>import matplotlib.pyplot as plt</p><p>from scipy import stats</p><p># use Seaborn plotting defaults</p><p>import seaborn as sns; sns.set()</p><p>from sklearn.datasets.samples_generator import make_blobs</p><p>X, y = make_blobs(n_samples=[10,20,30], centers=[[0,0],[1,1],[2,2]], random_state=0, cluster_std=0.30)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fbd4b28e04b845fc89b98ef84ccd49ed></div><ul><li><br></li></ul><p>X, y = make_blobs(n_samples=50, centers=2,random_state=0, cluster_std=0.60)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/33632f7b9ff14ff5bb3c40f973b626f3></div><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ca5603eaf0c84dc4a4a650cfbc783696></div><p><strong>sklearn.datasets.samples_generator.Make_blobs</strong></p><p>(n_sample=100,n_features=2,*,centers=None,cluster_std=1.0,random_state=None,renturn_centers=False,...)‍</p><p><strong>Make_blobs: </strong>generate isotropic Gaussian blobs for clustering。生成各向同性的高斯斑点用来进行聚类。</p><p><strong>N_samples</strong>: int,optional(default=2)</p><p>N_samples为数组时，则序列中的每个元素表示每个簇(cluster)的样本数。此时对应的center里面也需要写出每个簇(cluster)中心点的座标。比如在N_sample=[10,20,30]的时候，表示有三个簇(cluster)，他们每个簇点的个数分别为10个，20个和30个，此时在对应的centers参数中就要设置这三个簇(cluster)的中心座标，这里设置为centers=[[0,0],[1,1],[2,2]]，那么三个中心点（x,y）对应的座标分别为（0，0），（1，1），（2，2），在上面的图中分别用红，橙，黄颜色的点来表示。</p><p>n_samples为整数时，表示一共有多少个散点，那么这些点在所有的集群之间平均分布，n_sample=50,而centers=2，那么这50个点在两个中心之间平均分布，每个中心所在的cluster的点的个数为50/2=25。</p><p><strong>Centers</strong>: int or array of shape[n_center, n_features],optional</p><p>产生的中心点的数量，或者固定的中心点的位置座标。</p><p>如果N_samples是整数但是又没有定义centers的个数，那么自定义为3个centers。</p><p>如果n_samples是矩阵的形式，那么centers必须为设置为空值（None)或者和n_sample长度一样的矩阵。</p><p><strong>random_state</strong>: int, randomstate instance, default=None</p><p>这个参数在之前文章里面讲过的，要让你的随机的结果复现，就需要设置一个这个的参数。</p><p><strong>Return_centers</strong>:bool,optional(default=False)</p><p>该参数为True时，make_blobs的返回值中会返回每个集群的中心点。</p><p><strong>Cluster_std</strong>: floot or sequence of floats, optional(default=1.0)</p><p>The standard deviation of the clusters. 集群的标准差，标准差越小，数据越集中于自己的中心点。</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3883f14109824324bdae5dd8ed74ae4c></div><p><strong>Make_blobs 返回的值：</strong></p><p><strong>X</strong>: array of shape [n_samples, n_features]</p><p>The generated samples.产生的点的x,y座标。</p><p><strong>Y</strong>: array of shape[n_samples]</p><p>The integer labels for cluster membership of each sample.产生的每个点的标签，红颜色和黄颜色各一个标签，对应的值非0即1。如果有多个标签，假设有n个，那么这个y值的取值为[0,1...n-1]。</p><p><strong>Centers </strong>: array , shape[n_centers,n_feature]</p><p>The centers of each cluster. Only returned if return_center=True。每个簇（cluster)中心点（centers)的座标，只有make_blobs里面的return_centers参数设置为True时才会返回Centers的座标。Random_state取不同值时，中心点的座标也会随着不同，所以有时候为了让结果复现，也就是产生的中心点的座标与上一次使用make_blobs function产生的一样，这里最好设置一下random_state。</p><ul><li><br></li></ul><p>from sklearn.datasets.samples_generator import make_blobs</p><p>X, y,C = make_blobs(n_samples=50, centers=2, random_state=0, cluster_std = 0.30, return_centers =True)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc2dd62e8ea0402e8f67d103c0b77756></div><p>在这个例子中要将这两个cluster分开来，可以直接do by hand，</p><ul><li><br></li></ul><p>xfit = np.linspace(-1, 3.5)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><p>plt.plot([0.6], [2.1], 'x', color='red', markeredgewidth=2, markersize=10)</p><p>for m, b in [(1, 0.65), (0.5, 1.6), (-0.2, 2.9)]:</p><p>plt.plot(xfit, m * xfit + b, '-k')</p><p>plt.xlim(-1, 3.5)</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/244efb84941e45dbae1066334b9e0b36></div><p><strong>Numpy.linspace</strong></p><p>(start,stop,num=50,endpoint=True,retstep=False,dtype=None,axis=0)‍</p><p><strong>numpy.linspace() </strong>返回区间在[start,stop]，间隔均匀的num个数据点，</p><p><strong>Start</strong>:array_like, the starting value of the sequence.区间的左端点。</p><p><strong>Stop</strong>: array_like the end value of the sequence.区间的右端点。</p><p><strong>Num</strong>: 在[start,stop]区间内产生的点（sample)的个数，自定义为50个。</p><p>Matplotlib.pyplot.scatter 画散点。</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6e3d4eaa885040808ba63424065b9f36></div><p><strong>Matplotlib.pyplot.plot</strong>(scalex=True,scaley=Ture,**kwargs)‍</p><p><strong>Fmt</strong>=’[marker][line][color]’</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/708505ae452243789a1bb38a65215ab3></div><p>可以看到要将两组数据用直线分开可以有很多不同的直线，上图中画了三条直线，均可以将这两个(cluster)完全分开，这三条直线的（斜率，截距）分别为（1，0.65），（0.5，1.6）和（-0.2，2.9）这些直线的宽度都是零，我们可以给这些直线画一个给定宽度的margin，使灰色区域的边界正好接触到最近的cluster中的点。</p><ul><li><br></li></ul><p>xfit = np.linspace(-1, 3.5)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><p>for m, b, d in [(1, 0.65, 0.33), (0.5, 1.6, 0.55), (-0.2, 2.9, 0.2)]:</p><p>yfit = m * xfit + b</p><p>plt.plot(xfit, yfit, '-k')</p><p>plt.fill_between(xfit, yfit - d, yfit + d, edgecolor='none', color='#AAAAAA',</p><p>alpha=0.4)</p><p>plt.xlim(-1, 3.5);</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23c58659870c4a25a29eac2f74777ba8></div><p>那么这三条直线中，哪条直线是最优的解呢？我们希望对于新加入的点，仍能能有较好的划分能力，在三条直线中，斜率为1或-0.2的两条直线容易把新加入的点划分到另一方区域内。</p><p>比如对于图中红色的x,斜率为-0.2的那条直线容易把它划分到黄颜色点的簇(cluster)中,而对于其他新加入的点，如果新加入的点的横座标(x)超过三条直线交叉点的横座标，此时很容易被斜率为1的直线将属于红色的簇（cluster)的点划分到黄色的cluster中，由此看来，只有中间那条线具有很好的容错能力，与它平行的两条灰色区域边界所围成的区域比其他两条直线拥有更大的margin。</p><p>在支持向量机(support vector machines)中，这条能够使灰色区域拥有最大margin的直线（上图可以看到最中间这条直线的灰色部分宽度最宽）就会被选择成为我们的最优模型。由此，支持向量机（support vector machines)可以看作是这种最大化margin时的estimator(中文叫算子)的一个例子。</p><p>下面我们使用scikit-learn的support vector classifier（SVC） 在上面那些数据上来训练一个SVM 模型。为了避免过于拟合或拟合不够充分，会在求解</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46dca08bb2c94d81b2467f8c2cf2c77d></div><p>最小值的过程种引入惩罚参数C。</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/31c7d215a28247e59d132eea8d16abd9></div><p>C>0称为惩罚参数，C值越大，容许的误差越小，C值过大时，容易出现过拟合，过小则出现欠拟合。在这个例子中，对于两个簇(cluster)，可以明显区分边界时，我们要求这个边界非常地有原则，泾渭分明，也就是边界very hard，此时可以把C设置为一个非常大的值。</p><ul><li><br></li></ul><p>from sklearn.svm import SVC # "Support vector classifier"</p><p>model = SVC(kernel='linear', C=1E10)</p><p>model.fit(X, y)</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/95eb47c6f690408498c666775693a8a1></div><p><strong>sklearn.svm.SVC</strong></p><p>(*, C=1.0, kernel='rbf', degree=3, gamma='scale', coef0=0.0, shrinking=True, probability=False, tol=0.001, cache_size=200, class_weight=None, verbose=False, max_iter=-1, decision_function_shape='ovr', break_ties=False, random_state=None)‍</p><p><strong>SVC:</strong>support Vector Classification.</p><p><strong>C</strong>:float, default=1.0 C为刚刚提及的惩罚参数，这里为满足划分地边界非常清晰，所以给C取值为C=1E10。</p><p><strong>Kernel</strong>{'linear','poly','rbf','sigmoid','precomputed'},default='rbf'。</p><p>Specifies the kernel type to be used in the algorithm.</p><p>对于输入空间中的非线性分类问题，可以通过非线性变换将它转化为某个维特征空间中的线性分类问题，在高维特征空间中学习线性支持向量机。 由于在线性支持向量机学习的对偶问题里，目标函数核分类决策函数都只涉及实例核实例之间的内积，所以不需要显式地指定非线性变换，而是用<strong>核函数</strong>替换当中的内积。目前这里还是线性划分，所以kernel=’linear’,关于非线性的，下面待会儿会讲到。</p><p>Kernel函数的选择可以参考下面这个连接：</p><p>http://crsouza.com/2010/03/17/kernel-functions-for-machine-learning-applications/</p><p><strong>Degree</strong>:int,default=3</p><p>这个参数仅适用于polynomial kernel多项式的维度，一次函数，二次函数，三次函数等，对于其他kernel，这个参数不适用。</p><p><strong>Coef0</strong>:float, default=0.0</p><p>kernel function 中的独立项，仅对 kernel = 'poly'或 'sigmoid'时才有用。</p><p><strong>gamma{‘scale’, ‘auto’} or float, default=’scale’</strong></p><p>Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.</p><p>gamma这个参数是否具体存在要看你使用的是什么样的核函数（kernel）,在kernel参数的介绍中那个链接里面可以发现有些kernel里面是含有gamma这个参数的。</p><p>以Gaussian Kernel为例子做个简短的说明：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3654645b0b004b2496cffdc3ce9b1df5></div><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d2da392665b94a738a19c26657394d92></div><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8f6c90fcd474d85b49d364f922a4691></div><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/48cb6c0f1bcc4c95a2e55be92e2b10b6></div><p>图中</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfb3efd4759e4d219896d624fda890ff></div><p>值越大，高斯分布越扁平，对于所有的X更为雨露均沾，</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/33797db68d0f4505b7c1e5766660d302></div><p>（gamma）值越小，那么这个模型它就不能提取到数据里面更为复杂的部分，也是更具有特征性的那些部分，因为向量机的影响范围包含了整个训练集。与此同时，对於单一的training example，它的影响范围越广，它的训练和预测的速度也会慢下来。</p><p>如果gamma值非常大，支持向量的影响范围的半径（radius of the area of the influence)将会只包括支持向量本身，这时防止过拟合而设立的C值起到的作用就会变得很小。</p><p>Gamma 和C的取值也需要自己trade-off 一下，下图为在不同的gamma和C取值下，模型对两个cluster的分类情况。</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a5443c6721d846e9a8e44f495967e475></div><p>sklearn.svm.<strong>SVC</strong>(gamma=)里面，如果gamma='scale'(default)，那么在计算时，gamma的值为1/（n_features*X.var())。如果 gamma='auto'，计算时gamma的值为1/n_features。</p><p>为了更好地可视化，下面定义一种快速的function用来画SVM的决策边界（decision boundaries）.</p><ul><li><br></li></ul><p>def plot_svc_decision_function(model, ax=None, plot_support=True):</p><p>'''Plot the decision function for a two-dimensional SVC'''</p><p>if ax is None:</p><p>ax = plt.gca()</p><p>xlim = ax.get_xlim()</p><p>ylim = ax.get_ylim()</p><p># create grid to evaluate model</p><p>x = np.linspace(xlim[0], xlim[1], 30)</p><p>y = np.linspace(ylim[0], ylim[1], 30)</p><p>Y, X = np.meshgrid(y, x)</p><p>xy = np.vstack([X.ravel(), Y.ravel()]).T</p><p>P = model.decision_function(xy).reshape(X.shape)</p><p># plot decision boundary and margins</p><p>ax.contour(X, Y, P, colors='k',</p><p>levels=[-1, 0, 1], alpha=0.5,</p><p>linestyles=['--', '-', '--'])</p><p># plot support vectors</p><p>if plot_support:</p><p>ax.scatter(model.support_vectors_[:, 0],</p><p>model.support_vectors_[:, 1],</p><p>s=300, linewidth=1, facecolors='none');</p><p>ax.set_xlim(xlim)</p><p>ax.set_ylim(ylim)</p><p>Matplotlib.pyplot.gca: get the current Axes instance on the current figure matching the given keyword arguments, or create one。</p><ul><li><br></li></ul><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><p>plot_svc_decision_function(model)</p><p>画出如下图：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/908de0a0223c4f908d99f6c829974963></div><p>上图可以看出得到的分割线使得这两群点中间的margin最大。有些点正好在直线上面。在Scikit-Learn中，那些正好在边界的点组成了我们的support vector，并且存储在support_vectors_attribute中：</p><ul><li><br></li></ul><p>model.support_vectors_</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4e36e3d7686848808c0d13fdbaea1321></div><p>对于非线性关系，可以通过定义多项式和高斯基本函数，将数据投影到高维度空间，由此可以使用线性classifier拟合非线性关系。</p><p><strong>三、支持向量机处理非线性关系问题</strong></p><ul><li><br></li></ul><p>from sklearn.datasets.samples_generator import make_circles</p><p>X, y = make_circles(100, factor=.1, noise=.1)</p><p>clf = SVC(kernel='linear').fit(X, y)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><p>plot_svc_decision_function(clf, plot_support=False)</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/204b12f2acb04c5ead48f099c3765697></div><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8d0831dfe82f4a38b0b7df3eac12f0f2></div><p><strong>Sklearn.datasets.make_circles</strong></p><p>(n_sample=100,*,shuffle=True,noise=None,random_state=None,factor=0.8)‍</p><p><strong>Make_circles</strong>用来在二维平面上产生一个大的circle，该circle里面包含一个小一点的circle.</p><p><strong>N_samples</strong>: 如果为偶数，外圈和内圈点的数量一样多；如果为奇数，内圈比外圈多一个点。</p><p><strong>Factor</strong>:0&lt;double&lt;1(default=.8)</p><p>Scale factor between inner and outer circle.</p><p>在其他情况不变时，Factor 设为不同值的图如下：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b172b94d731347e4a34ba3d3598cb837></div><p><strong>Noise</strong>: double or None (default=None)</p><p>Standard deviation of Gaussian noise added to the data.</p><p>在其他参数不变的情况下，noise设为不同值时的图像如下：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4987536e8a54090b2313fe260dbd5bd></div><p>由上面一系列图片可以看到，使用线性（直线）去划分非线性（中间一个圈，外面一个圈）的数据得到的结果并不理想，在二维平面上使用线性的可能永远无法将这两类点分开，那我们如何将这些点投影到更高维度才足以使用线性分开呢。举个简单的投影例子，我们可以使用计算一个集中在中间的 radial basis function。</p><blockquote><p>radial basis function: a radial basis function(RBF) is a real-valued function whose value depends only on the distance between the input and some fixed point, either the origin. --wiki</p></blockquote><p>对于在有限维度向量空间中线性不可分的样本，我们将其映射到更高维度的向量空间里，再通过间隔最大化的方式，学习得到支持向量机，就是非线性 SVM。</p><p>我们用 x 表示原来的样本点，用</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/77a1c27a2d0548bf889082715fc14f3b></div><p>表示 x 映射到特征新的特征空间后到新向量。那么分割超平面可以表示为：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9daa3bde79e04381ae3e033a13a8de92></div><p>。</p><p>对于非线性 SVM 的对偶问题就变成了，在三维空间，仅使用一个平面就能将其很好地分类：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/66ad69c0903045768aa363b63390e1b6></div><ul><li><br></li></ul><p>r = np.exp(-(X ** 2).sum(1))</p><p>然后你可以使用下面的代码查看：</p><ul><li><br></li></ul><p>from mpl_toolkits import mplot3d</p><p>def plot_3D(elev=30, azim=30, X=X, y=y):</p><p>ax = plt.subplot(projection='3d')</p><p>ax.scatter3D(X[:, 0], X[:, 1], r, c=y, s=50, cmap='autumn')</p><p>ax.view_init(elev=elev, azim=azim)</p><p>ax.set_xlabel('x')</p><p>ax.set_ylabel('y')</p><p>ax.set_zlabel('r')</p><p>interact(plot_3D, elev=[-90,30, 90], azip=(-180, 180), X=fixed(X), y=fixed(y));</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6d5f5d3c5b8b47dd9cd7d6b68dba5b8e></div><p>也可以自己计算一个z座标，然后画一个三维的，比如刚刚讲的把上面的二维散点投影到三维，我们可以给一个z轴，使这些散点的z轴的值与二维图像上的散点到原座标（0，0）的距离呈正关系，这里我们定义：</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37daa440b8a347d9a5027ea4d99f1d11></div><p>X为上面那些散点的x,y座标，下面代码使用上式生成z座标。</p><ul><li><br></li></ul><p>import pandas as pd</p><p>df=pd.DataFrame(data=X,columns={'x','y'})</p><p>df['z']=(df['x']**2+df['y']**2)**0.5</p><p>然后使用plotly画三维图像（记得先在anaconda prompt里面安装：pip install plotly）：</p><ul><li><br></li></ul><p>import plotly</p><p>import plotly.graph_objs as go</p><p>plotly.offline.init_notebook_mode()</p><p>trace=[go.Scatter3d(x=df['x'].tolist(),y=df['y'].tolist(),z=df['z'].tolist(),</p><p>mode='markers',marker=dict(size=6,color=y,colorscale='Viridis'))]</p><p>fig=go.Figure(data=trace)</p><p>fig.show()</p><p>color=y中y就是之前画的100个二维散点的时候给他们的分类标签，0或1值，这里对不同的类用不同的颜色区别。那么这个从x,y得到z的过程就是一个核函数的功能。</p><p>录了一个小小的video，小伙伴们感受一下将二维投影到三维后的效果：</p><p>上图可以看到投影之后我们很好地将这两类不同颜色地点分开来，只需要在中间插入一个平面（比如说z=0.5）就可以很easy地将两类分开。</p><p>如果我们这个投影project的basic function没有选择好，那么这个分离的效果可能就不那么明显了。</p><p>比如下面这种情况就需要用polynomial kernel来mapping（映射）</p><p>插入一个video：</p><p>每对点的前后转换过程叫做内核转换。</p><p>这种策略存在潜在的问题，投影N个点到N维，会随着N的增大使得运算量相当庞大，有一种过程可以替代掉这种一对一的映射，把它叫做kernel trick, 比如上面讲的</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e3ccfcb04105491db1718d2ed350eccf></div><p>公式，SVM里面内置了这样的kernel trick, 这也是SVM强有力的原因之一。</p><p>下面看看如何使用SVM的内置kernel trick，其中kernel='rbf'。</p><ul><li><br></li></ul><p>clf = SVC(kernel='rbf', C=1E6)</p><p>clf.fit(X, y)</p><ul><li><br></li></ul><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><p>plot_svc_decision_function(clf)</p><p>plt.scatter(clf.support_vectors_[:, 0], clf.support_vectors_[:, 1],</p><p>s=300, lw=1, facecolors='none')</p><p>Kernel='rbf'中的rbf：radial basic function，使用方式和其他的model一样，大致形式都是model.fit(X,y)。</p><p>SVC.fit(self,X,y[,sample_weight]): fit the SVM model according to the given training data.</p><p>通过使用这种kernelized 的SVM模型，学习到了非线性决策边界，得到的下图很完美地区分了这两组非线性关系的点。</p><p><strong></strong></p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b8a66fd31147458c81b915f4aa124fd8></div><p><strong>四、关于软边界</strong></p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b80c293d5f084079b4ec674f1783d3af></div><p>左图为硬边界，右图为软边界，软就是模糊，不清楚的意思。硬边界有明显的界限，而软边界里面，就会有部分互相参杂，那么互相参杂多少，这个容错的范围多大，也是由参数来确定的。</p><p>刚刚提及的都是边界很清晰的，可以将两类划分，有时候，这两种不同颜色的散点的边界并没有那么清晰，允许一部分点互相掺杂。比如当你碰到下面的这种情况时：</p><ul><li><br></li></ul><p>X, y = make_blobs(n_samples=100, centers=2,random_state=0, cluster_std=1.2)</p><p>plt.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49394ba7bd9244a597a00e7b8cd4ef84></div><p>通过mak_blobs人为产生了如上图的数据，下面用SVC线性划分这两个类别，因为边界不是很清晰，所以这里控制惩罚程度的C的值，不会像最初那样设置得很大，而这个容错的范围也由C的值确定，下面是SVM里面C分别为10和0.1的结果的图像：</p><ul><li><br></li></ul><p>X, y = make_blobs(n_samples=100, centers=2,random_state=0, cluster_std=0.8)</p><p>fig, ax = plt.subplots(1, 2, figsize=(16, 6))</p><p>fig.subplots_adjust(left=0.0625, right=0.95, wspace=0.1)</p><p>for axi, C in zip(ax, [10.0, 0.1]):</p><p>model = SVC(kernel='linear', C=C).fit(X, y)</p><p>axi.scatter(X[:, 0], X[:, 1], c=y, s=50, cmap='autumn')</p><p>plot_svc_decision_function(model, axi)</p><p>axi.scatter(model.support_vectors_[:, 0],</p><p>model.support_vectors_[:, 1],</p><p>s=300, lw=1, facecolors='none');</p><p>axi.set_title('C = {0:.1f}'.format(C), size=14)</p><div class=pgc-img><img alt="支持向量机SVM(Support Vector Machine) Ⅰ原创 Yu" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d29a47448b8c4c7caaca569b9d12949f></div><p>C=0.1有部分点进入了两个cluster的support vector之间，而当C=10的时候没有。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SVM','Support','Vector'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>