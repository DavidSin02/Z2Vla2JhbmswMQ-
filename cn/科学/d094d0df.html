<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「核心考点」2021计算机数据结构 | 极客快訊</title><meta property="og:title" content="「核心考点」2021计算机数据结构 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a74aa8f2773c4678a8b062119d763973"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/d094d0df.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d094d0df.html><meta property="article:published_time" content="2020-11-14T20:53:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:56+08:00"><meta name=Keywords content><meta name=description content="「核心考点」2021计算机数据结构"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/d094d0df.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「核心考点」2021计算机数据结构</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p><span style="background-color:#f3f5f9;--tt-darkmode-bgcolor: #BDBEC1">摘要：考研各项科目中，专业课的重要性不言而喻。与公共课相比，专业课的难度往往更大一些，出题会更深入、更全面，更考察考生的水平和能力。所以复习千万不能掉以轻心，即便本科已经有了不错的基础，也有可能因为研究方向的细化，而面临着全新陌生的考研复习内容，有必要及早开始。今天了解一下计算机考研专业课的核心考点。</span></p><div class=pgc-img><img alt=「核心考点」2021计算机数据结构 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a74aa8f2773c4678a8b062119d763973><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>　　一、队列和栈结构的概念理解</h1><hr><p>　　栈是仅限制在表的一端进行插入和删除运算的线性表，称插入、删除这一端为栈顶。表中无元素时为空栈。栈的修改是按后进先出的原则进行的。通常栈有顺序栈和链栈两种存储结构。</p><p>　　队列是一种运算受限的线性表，插入在表的一端进行，而删除在表的另一端进行，允许删除的一端称为队头，允许插入的一端称为队尾，队列的操作原则是先进先出的。队列也有顺序存储和链式存储两种存储结构。</p><h1 class=pgc-h-arrow-right><strong>　　二、线性表中单链表相关算法设计与实现</strong></h1><hr><p>　　一些基础但又重要的单链表相关算法，如：</p><p>　　1.打印单链表，voidPrintList(Listlist)；使用一个指针遍历所有链表节点。</p><p>　　2.两个升序链表，打印tarList中的相应元素，这些元素的序号由SeqList指定，voidPrintLots(ListtarList，ListseqList)；使用两个指针分别遍历两个链表，每次取出序列链表的一个序号后，根据该序号，到达目标链表指定节点。</p><p>　　3.两个升序链表的交集，ListIntersect(Listl1，Listl2)。</p><p>　　4.两个升序链表的并集，ListJoin(Listl1，Listl2)。</p><p>　　5.单链表就地置逆，voidReverse(Listl)；使用三个指针表示前驱，当前和后继节点，每次将当前节点的Next指向前驱节点，然后向后遍历直到链表末尾。</p><h1 class=pgc-h-arrow-right><strong>　　三、二叉树的遍历</strong></h1><hr><p>　　遍历的过程就是把非线性结构的二叉树中的结点排成一个线性序列的过程。</p><p>　　二叉树遍历方法可分为两大类，一类是“宽度优先”法，即从根结点开始，由上到下，从左往右一层一层的遍历；另一类是“深度优先法”，即一棵子树一棵子树的遍历。</p><h1 class=pgc-h-arrow-right><strong>　　四、带权图的最短路径算法及应用</strong></h1><hr><p>　　迪杰斯特拉(Dijkstra)算法求单源最短路径，算法思想：</p><p>　　设S为最短距离已确定的顶点集(看作红点集)，V-S是最短距离尚未确定的顶点集(看作蓝点集)。</p><p>　　1.初始化：初始化时，只有源点s的最短距离是已知的(SD(s)=0)，故红点集S={s}，蓝点集为空。</p><p>　　2.重复以下工作，按路径长度递增次序产生各顶点最短路径，在当前蓝点集中选择一个最短距离最小的蓝点来扩充红点集，以保证算法按路径长度递增的次序产生各顶点的最短路径。</p><p>　　当蓝点集中仅剩下最短距离为∞的蓝点，或者所有蓝点已扩充到红点集时，s到所有顶点的最短路径就求出来了。</p><p>　　注意：①若从源点到蓝点的路径不存在，则可假设该蓝点的最短路径是一条长度为无穷大的虚拟路径。②从源点s到终点v的最短路径简称为v的最短路径；s到v的最短路径长度简称为v的最短距离，并记为SD(v)。</p><h1 class=pgc-h-arrow-right><strong>　　五、堆排序</strong></h1><hr><p>　　大根堆的定义：完全二叉树，任一非叶子结点都大于等于它的孩子，也就是说根结点是最大的。而且显然大根堆的任一棵子树也是大根堆。</p><p>　　堆排序的基本思想：记录区的分为无序区和有序区前后两部分；用无序区的数建大根堆，得到的根(最大的数)和无序区的最后一个数交换，也就是将该根归入有序区的最前端；如此重复下去，直至有序区扩展至整个记录区。</p><p>　　具体操作可按下面步骤实现：</p><p>　　1.建大根堆。</p><p>　　2.交换根和无序区最后一个数。</p><p>　　3.重建大根堆，因为交换只是使根改变了，所以左右子树依然分别是大根堆。</p><p>　　4.比较根，左子树的根和右子树的根，如果根最大，则无须再作调整，树已经是大根堆了；如果左子树的根最大，交换它与根，再递归调整左子树；如果右子树的根最大，交换它与根，再递归调整右子数。</p><p>　　5.递归调整到叶子的时候，树就是大根堆了。</p><h1 class=pgc-h-arrow-right><strong>　　六、各类排序算法的特点及比较</strong></h1><hr><p>　　几种主要的排序算法：冒泡排序、选择排序、插入排序、快速排序、归并排序、Shell排序、堆排序等。</p><p>　　冒泡排序算法思想：将待排序的元素看作是竖着排列的“气泡”，较小的元素比较轻，从而要往上浮。在冒泡排序算法中我们要对这个“气泡”序列处理若干遍。</p><p>　　所谓一遍处理，就是自底向上检查一遍这个序列，并时刻注意两个相邻的元素的顺序是否正确。如果发现两个相邻元素的顺序不对，即“轻”的元素在下面，就交换它们的位置。</p><p>　　选择排序算法思想：选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。</p><p>　　插入排序算法思想：经过i-1遍处理后，L[1..i-1]己排好序。第i遍处理仅将L[i]插入L[1..i-1]的适当位置，使得L[1..i]又是排好序的序列。</p><p>　　快速排序算法思想：快速排序的基本思想是基于分治策略的。</p><p>　　对于输入的子序列L[p..r]，如果规模足够小则直接进行排序，否则分三步处理：1.分解(Divide)：将输入的序列L[p..r]划分成两个非空子序列L[p..q]和L[q+1..r]，使L[p..q]中任一元素的值不大于L[q+1..r]中任一元素的值。2.递归求解(Conquer)：通过递归调用快速排序算法分别对L[p..q]和L[q+1..r]进行排序。3.合并(Merge)：由于对分解出的两个子序列的排序是就地进行的，所以在L[p..q]和L[q+1..r]都排好序后不需要执行任何计算L[p..r]就已排好序。</p><p>　　归并排序算法思想：分而治之(divide-conquer)。</p><p>　　每个递归过程涉及三个步骤：1.分解，把待排序的n个元素的序列分解成两个子序列，每个子序列包括n/2个元素。2.治理，对每个子序列分别调用归并排序MergeSort，进行递归操作。3.合并，合并两个排好序的子序列，生成排序结果。</p><p>　　Shell排序算法思想：算法先将要排序的一组数按某个增量d分成若干组，每组中记录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。</p><p>　　堆排序算法思想：用大根堆排序的基本思想：1.先将初始文件R[1..n]建成一个大根堆，此堆为初始的无序区。2.再将关键字最大的记录R1和无序区的最后一个记录R[n]交换，由此得到新的无序区R[1..n-1]和有序区R[n]，且满足R[1..n-1].keys≤R[n].key。3.由于交换后新的根R[1]可能违反堆性质，故应将当前无序区R[1..n-1]调整为堆。</p><h1 class=pgc-h-arrow-right><strong>　　七、二叉树及其遍历</strong></h1><hr><p>　　从二叉树结构的整体看，二叉树可以分为根结点，左子树和右子树三部分，只要遍历了这三部分，就算遍历了二叉树。设D表示根结点，L表示左子树，R表示右子树，则DLR的组合共有6种，即DLR，DRL，LDR，LRD，RDL，RLD。</p><p>　　若限定先左后右，则只有DLR，LDR，LRD三种，分别称为先(前)序法(先根次序法)，中序法(中根次序法，对称法)，后序法(后根次序法)。三种遍历的递归算法如下：</p><p>　　1.先序法(DLR)</p><p>　　若二叉树为空，则空操作，否则：访问根结点—>先序遍历左子树—>先序遍历右子树。</p><p>　　2.中序法(LDR)</p><p>　　若二叉树为空，则空操作，否则：中序遍历左子树—>访问根结点—>中序遍历右子树。</p><p>　　3.后序法(LRD)</p><p>　　若二叉树为空，则空操作，否则：后序遍历左子树—>后序遍历右子树—>访问根结点。</p><h1 class=pgc-h-arrow-right><strong>　　八、完全二叉树中有关结点个数计算</strong></h1><hr><p>　　完全二叉树的定义：深度为k，有n个结点的二叉树当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时，称为完全二叉树。</p><p>　　完全二叉树的叶子数为(n+1)/2取下整。</p><h1 class=pgc-h-arrow-right><strong>　　九、森林与二叉树之间的转换以及转换过程中结点之间的关系</strong></h1><hr><p>　　将一棵树转换为二叉树的方法是：</p><p>　　1.树中所有相邻兄弟之间加一条连线。</p><p>　　2.对树中的每个结点，只保留其与第一个孩子结点之间的连线，删去其与其它孩子结点之间的连线。</p><p>　　3.以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。</p><p>　　森林转换为二叉树的方法如下：</p><p>　　1.将森林中的每棵树转换成相应的二叉树。</p><p>　　2.第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树根结点的右孩子，当所有二叉树连在一起后，所得到的二叉树就是由森林转换得到的二叉树。</p><p>　　树和森林都可以转换为二叉树，二者的不同是：树转换成的二叉树，其根结点必然无右孩子，而森林转换后的二叉树，其根结点有右孩子。将一棵二叉树还原为树或森林，具体方法如下：</p><p>　　1.若某结点是其双亲的左孩子，则把该结点的右孩子、右孩子的右孩子、……都与该结点的双亲结点用线连起来。</p><p>　　2.删掉原二叉树中所有双亲结点与右孩子结点的连线。3.整理由1、2两步所得到的树或森林，使之结构层次分明。</p><h1 class=pgc-h-arrow-right><strong>　　十、对无向连通图特性的理解</strong></h1><hr><p>　　无向图的每条边，在顶点计算度的过程中，都要两次参与计算(与边两关联的2个顶点)，因此所有顶点的度之和为偶数。</p><p>　　具有n个顶点的无向连通图，其边数大于或等于n-1。</p><p>　　在无向连通图中，所有顶点的度数都有可能大于1。</p><h1 class=pgc-h-arrow-right><strong>　　十一、对m阶B树定义的理解</strong></h1><hr><p>　　一棵m阶的B树满足下列条件：</p><p>　　1.每个结点至多有m棵子树。</p><p>　　2.除根结点外，其它每个分支至少有m/2棵子树。</p><p>　　3.根结点至少有两棵子树(除非B树只有一个结点)。</p><p>　　4.所有叶结点在同一层上。B树的叶结点可以看成一种外部结点，不包含任何信息。</p><p>　　5.有j个孩子的非叶结点恰好有j-1个关键码，关键码按递增次序排列。结点中包含的信息为∶(p0，k1，p1，k2，p2，…，kj-1，pj-1)，其中，ki为关键码。</p><p>　　以上就是计算机考研专业课的核心考点梳理，希望对要考计算机的同学有所帮助，提升复习效率。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'考点','2021','计算机'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>