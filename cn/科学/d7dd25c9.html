<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基础渲染系列（一）图形学的基石——矩阵 | 极客快訊</title><meta property="og:title" content="基础渲染系列（一）图形学的基石——矩阵 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a9bc08327dbf4f0e921768dab663ef7b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/d7dd25c9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/d7dd25c9.html><meta property="article:published_time" content="2020-11-14T20:52:19+08:00"><meta property="article:modified_time" content="2020-11-14T20:52:19+08:00"><meta name=Keywords content><meta name=description content="基础渲染系列（一）图形学的基石——矩阵"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/d7dd25c9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基础渲染系列（一）图形学的基石——矩阵</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>本文重点内容：</p><p>1、创建一个立方体构建的Grid网格</p><p>2、支持缩放、位移、旋转</p><p>3、变换矩阵</p><p>4、创建简单的相机投影</p><blockquote class=js_blockquote_wrap><p>译注：从原创作者博客转为公众号文章非常复杂，我需要先将原文翻译一遍，然后在公众号再排版一遍。公众号编辑十分不方便，尤其是原作者的代码风格、图片格式、数学公式、动图、视频、引用Tips等等都需要二次导入和格式转换。加上原作者每篇的内容非常长，编辑起来非常耗时，非常累。</p><p><br></p><p>另外，我对比了一下使用源码引用和截图在公众号的阅读体验，觉得截图的体验要好于源码引用。截图既能保留原作者源码风格，又能在手机上有良好的阅读体验。</p><p><br></p><p>代码的黄色部分，是指在原有代码基础上变化的部分，完整源码会在后台通过回复关键字获取。</p></blockquote><p><br></p><p>这是基础渲染课程系列的第一部分，主要涵盖变换矩阵相关的内容。如果你还不清楚Mesh是什么或者怎么工作的，可以转到Mesh Basics 相关的章节去了解（译注：Mesh Basics系列皆已经翻译完毕，但与本系列主题关联不大，讲完4个渲染系列之后，再放出来）。这个系列会讲，这些Mesh是如何最终变成一个像素呈现在显示器上的。</p><p><br></p><p>该示例使用Unity5.3.1（译注：实测2018.4版本没有问题）。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a9bc08327dbf4f0e921768dab663ef7b><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>1 空间可视化</h1><p>你已经知道什么是Mesh网格以及如何在场景中对其进行定位了。但是这种定位实际上是如何完成的呢？着色器如何知道在哪里绘制？当然，我们可以仅依靠Unity的transform组件和着色器来完成所有工作，但是如果你想获得完全控制权，那么了解实际发生的底层原理则至关重要。</p><p><br></p><p>为了完全理解此过程，最好创建自己的实现。移动，旋转和缩放网格是通过操纵其顶点的位置来完成的。这属于空间上的变换，因此要在实际中看到它，我们必须使空间可见。可以通过创建用“点”组成的3D网格来实现。点可以是任何预制件。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eebc0d1fdc64588bac5c4a9fa0f19e3><p class=pgc-img-caption></p></div><p><br></p><p>创建一个点，实际上就是实例化预制件，确定其座标并为其赋予独特的颜色。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23a8199aeef04a36b9127eb3e57e9ab1><p class=pgc-img-caption></p></div><p><br></p><p>网格最明显的形状是一个立方体，所以让我们开始吧。我们将其以原点为中心，因此变换（尤其是旋转和缩放）相对于网格立方体的中点。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c8fd0f725b249b882961d7230191715><p class=pgc-img-caption></p></div><p>我将使用默认的立方体作为预制对象，将其缩放为一半大小，以便在它们之间留出空间。</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/979144746ebe4ceda8195f10f14ba0ba><p class=pgc-img-caption></p></div><p>（缩小立方体预置）</p><p><br></p><p>创建一个网格对象，添加我们的组件，并连接预制件。进入播放模式时，将会以我们对象的本地原点为中心出现方格。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/640bb8e270e14d7ebc2273399a2fa4ac><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/30d3fa9c4c784a089676cb3446b123f8><p class=pgc-img-caption></p></div><p>（Transformations Grid）</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>2 Transformations</p><p>理想情况下，我们应该能够对Grid应用任意数量的转换。 以及各种不同类型的转换，但为了和Unity的理解一致，将只限制在位置，旋转和缩放上。</p><p><br></p><p>如果我们为每个Transform创建一个组件类型，就可以按照所需的任何顺序和数量将它们添加到Grid对象中。 而且，尽管每个Transform的细节都不同，但它们都需要一种方法将自己应用于空间点。</p><p><br></p><p>让我们为所有的Transform组件创建一个可以继承的基类。 它是一个抽象类，这意味着它不能直接使用。 给它一个抽象的Apply方法，具体的转换组件将使用它来完成其工作。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb1dd4bda322489e83309d94488cc3cf><p class=pgc-img-caption></p></div><p><br></p><p>将此类组件添加到网格对象后，就必须以某种方式检索它们，以便将其应用于所有网格点。我们将使用通用List来存储对这些组件的引用。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bd7587340fb1485293e805f6252ac276><p class=pgc-img-caption></p></div><p>现在我们可以添加一个Update方法来检索Transform，然后遍历整个网格并转换所有点。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/047f1f58911c4b9d8ff4673d9755aa66><p class=pgc-img-caption></p></div><blockquote class=js_blockquote_wrap><p>为什么要在Update获取组件？</p><p>这样就可以在保持播放模式的同时使用Transform组件，并立即看到结果。</p></blockquote><p><br></p><blockquote class=js_blockquote_wrap><p>为什么使用List而不是数组？</p><p>GetComponents方法的最直接的版本只是返回一个包含请求类型的所有组件的数组。 这意味着每次调用都会创建一个新数组，在本例中是每次Update。 替代版本具有列表参数。 这样做的好处是它将把组件放到列表中，而不是创建一个新的数组。</p><p>但在我看来，这不是一个关键的优化，但是当你需要经常获取组件时，使用list是个好习惯。</p></blockquote><p><br></p><p>通过获取原始座标，然后应用每个变换来完成每个点的变换。 但不能依靠每个点的实际位置，因为已经对它们进行了变换，并且我们不想在每个帧上累积变换。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c9bf0ce016f141f3b7edf98b57222def><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>2.1 转换</p><p>我们的第一个具体组成部分是Transform，这是最简单的。因此，创建一个扩展了Transformation的新组件，并将其位置用作局部偏移。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ebd1fb185c39454c9d49a361eb547ad5><p class=pgc-img-caption></p></div><p><br></p><p>现在，编译器将报错说没有提供Apply的具体版本，所以我们给它一个吧。只需将所需位置添加到原始点即可。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f98cbad5382e4cafb12305256d2d5456><p class=pgc-img-caption></p></div><p><br></p><p>现在，你可以将位置转换组件添加到我们的网格对象中。这让我们可以移动“点”，而无需移动实际的网格对象。我们所有的转换都发生在对象的局部空间中。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bc1dec8b4ed84942b0d0acf420ffd7ad><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c17d7615a9234e579445e312a4727218><p class=pgc-img-caption></p></div><p>（变换位置）</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>2.2 缩放</p><p>接下来是缩放转换。它与位置处理方式几乎相同，只是比例分量被乘而不是被添加到原始点。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/13e7043fc7e845a18ad31e9c1b070cef><p class=pgc-img-caption></p></div><p><br></p><p>也把该组件添加到我们的网格对象中。现在我们也可以缩放网格。请注意，我们仅调整网格点的位置，因此缩放不会更改其可视化效果的大小。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a28d6e08c02f417488422fa181c0312d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3adb34a51cc1471a9e86034a2fb9e710><p class=pgc-img-caption></p></div><p>（调整缩放）</p><p><br></p><p>一次操作中尝试执行定位和缩放。 你会发现比例尺也会影响位置。 发生这种情况是因为我们首先重新定位空间，然后对其进行缩放。但Unity的transform组件是反过来实现的，所以，我们也应该调整下脚本执行的顺序，这可以通过重新排序组件来完成。 通过每个组件右上角齿轮图标下的弹出菜单移动它们。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fa3d65a11e8447c3b173a5f1a60a398f><p class=pgc-img-caption></p></div><p>（修改组件顺序）</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>2.3 旋转</p><p>第三种变换类型是旋转。比前两个要困难一些。我们从一个新组件开始，该组件将返回没有变化的点。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed76898e37db4d66a1f7eae422ab5dfb><p class=pgc-img-caption></p></div><p><br></p><p>那么旋转该如何实现呢？ 它需要限制自己绕单个轴（Z轴）旋转。 围绕该轴旋转点就像旋转一个轮子。 由于Unity使用左手座标系，因此在Z轴正方向观看时，正向旋转会使车轮逆时针旋转。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ef8e59caee5f4c9e83e45edbd746b559><p class=pgc-img-caption></p></div><p>（绕着Z轴的2D旋转）</p><p><br></p><p>一个点旋转时会发生什么变化呢？ 最简单的考虑点位于半径为一个单位的圆（单位圆）上的点。 最直接的点对应于X和Y轴。 如果将这些点旋转90°，则总是以0、1或-1结束。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01c53b8287fd4d3cb1044e651db583c4><p class=pgc-img-caption></p></div><p>（将（1,0）和（0,1）分别旋转90和180度）</p><p><br></p><p>第一步之后，点（1,0）变为（0,1）。 下一步将其设置为（−1,0）。 然后是（0，-1），最后回到（1,0）。</p><p><br></p><p>如果我们从点（0,1）开始，则与之前的序列相比，我们仅领先一步。</p><p><br></p><p>我们从（0,1）到（−1,0）到（0，−1）到（1,0）再返回。 因此，我们的点的座标经历了循环0、1、0，-1。 他们只是有不同的起点而已。</p><p><br></p><p>如果改为以45°增量旋转怎么办？ 这将产生位于XY平面对角线上的点。 由于到原点的距离没有变化，因此我们必须以（±√½，±√½）形式的座标结束。 这将我们的周期扩展为0，√½，1，√½，0，-√½，-1，-√½。 如果不断减小步长，则最终会出现正弦波。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a520931500fa44e9bdfde9f7c7db34a5><p class=pgc-img-caption></p></div><p>（正弦和余弦）</p><p><br></p><p>在我们例子里，从（1,0）开始，正弦波与y座标匹配。 余弦与x座标匹配。 这意味着我们可以将（1,0）重新定义为（cos z，sin z）（cosz，sinz）。 同样，我们可以将（0,1）替换为（-sin z，cos z）（-sinz，cosz）。</p><p><br></p><p>因此，我们首先计算围绕Z轴所需旋转的正弦和余弦。提供以度为单位的角度，但是正弦和余弦使用弧度，因此必须进行转换。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/67127194b3aa4a84a3a6c99adc064b51><p class=pgc-img-caption></p></div><p><br></p><blockquote class=js_blockquote_wrap><p>什么是弧度？</p><p>像度数一样，它们可以用作旋转的量度。 使用单位圆时，弧度与您沿其圆周行进的距离匹配。 由于圆周的长度等于圆半径的2π倍，因此1个弧度等于π/ 180度。</p><p>在这里你还可以看到π的定义。 它是圆的周长与其直径之比。</p></blockquote><p><br></p><p>很高兴我们找到了一种旋转（1,0）和（0,1）的方法，但是旋转任意点呢？ 好吧，这两点定义了X和Y轴。 我们可以将任何2D点（x，y）分解为 xX + yY。 没有任何旋转，它等于x（1,0）+ y（0,1），实际上的确是（x，y）。 但是当旋转时，我们现在可以使用x（cos Z，sin Z）+ y（-sin Z，cos Z）并得到正确旋转的点。 你可以将其视为缩放点，使其落在单位圆上，旋转然后再缩小。 压缩成一个座标对，它变成（xcosZ-ysinZ，xsinZ + ycosZ）。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ace2cc6cb1f4705888a53ecb156d214><p class=pgc-img-caption></p></div><p><br></p><p>将旋转组件添加到网格，并将其作为中间转换。 这意味着我们首先缩放，然后旋转，最后重新定位，这也是Unity的Transform组件所做的。 当然，目前仅支持围绕Z旋转。 稍后我们将处理其他两个轴。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b92ace1f904d4957aae241a97aca039e><p class=pgc-img-caption></p></div><p>（所有的三个转换效果）</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>3 完全体的旋转</p><p>现在，我们只能绕Z轴旋转。 为了提供与Unity变换组件相同的旋转支持，我们还必须启用围绕X和Y轴的旋转。 孤立地绕这些轴旋转的实现就类似于绕Z旋转，但同时绕多个轴旋转则变得更加复杂。 为了解决这个问题，我们可以使用更好的方法来写下旋转数学。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.1 矩阵</p><p>从现在开始，我们将垂直而不是水平地写入点的座标。用</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e4f8c2488ce4c6682180964319eab1d><p class=pgc-img-caption></p></div><p><br></p><p>的写法代替（x,y）。同样的使用</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6ede33addfd44b68c928e7f10770918><p class=pgc-img-caption></p></div><p><br></p><p>代替（xcosZ−ysinZ,xsinZ+ycosZ）。这样阅读更加容易一些。请注意，x和y因子最终排列在垂直列中，表示一个2D乘法。 实际上，我们执行的乘法是</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/75cf51c8c6444b328372550338bdf390><p class=pgc-img-caption></p></div><p>，</p><p><br></p><p>这是矩阵乘法。2 x 2矩阵的第一列表示X轴，第二列表示Y轴。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d508c8b01edb49b7ae736c2bd702092f><p class=pgc-img-caption></p></div><p>（用2D的矩阵定义X和Y轴）</p><p><br></p><p>通常，将两个矩阵相乘时，在第一个矩阵中逐行，在第二个矩阵中逐列。 结果矩阵中的每个项是一行的项总和乘以一列的相应项之和。 这意味着第一矩阵的行和第二矩阵的列必须具有相同数量的元素。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b1e99430eb2d42e38537b24d46c7d48f><p class=pgc-img-caption></p></div><p>（2个2X2的矩阵相乘）</p><p><br></p><p>结果矩阵的第一行包含行1×列1，行1×列2，依此类推。 第二行包含第2行×第1列，第2行×第2列，依此类推。 因此，它具有与第一矩阵相同的行数和与第二矩阵相同的列数。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.2 3D旋转矩阵</p><p>到目前为止，我们有一个2 x 2矩阵，可用于绕Z轴旋转2D点。</p><p>但我们实际上使用的是3D点。所以我们尝试乘法</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57c40d2b84f94bdbb92a87f1e2e17eab><p class=pgc-img-caption></p></div><p>，</p><p>因为矩阵的行和列长度不匹配。所以我们必须把我们的旋转矩阵增加到3乘3，以包含第三维空间。如果我们用零来填充它会发生什么？</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/268717ab6b8d4d2dbc0c9812896ce8b3><p class=pgc-img-caption></p></div><p>结果的X和Y分量是正常的，但Z分量始终为零。 那是不对的。 为了保持Z不变，我们必须在旋转矩阵的右下角插入1。 这么做才是对的，因为第三列表示Z轴，即</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f97c51a47dc1499b84e1971c5d36e602><p class=pgc-img-caption></p></div><p>。</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7b1fc0892c9d49338666502231dd9e65><p class=pgc-img-caption></p></div><p><br></p><p>如果我们一次对所有三个维度都使用此技巧，那么最终将得到一个矩阵，其对角线为1，其他任何地方为0。 这被称为单位矩阵，因为它不会改变与之相乘的关系。 它就像一个过滤器，使所有内容保持不变。</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/945d5ae06d634b4d8c12f208bcd4f1c3><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.3 为X和Y做矩阵旋转</p><p>使用我们找到的绕Z轴旋转的相同方式，我们可以得出绕Y轴旋转的矩阵。首先，X轴从</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37e199bf9c8f415a9e0ef61b8d47f2bb><p class=pgc-img-caption></p></div><p><br></p><p>开始，逆时针旋转90°后，变为</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a49d55846cb24e839258b4c816e93e17><p class=pgc-img-caption></p></div><p>。</p><p><br></p><p>这意味着旋转的X轴可以用</p><p><br></p><p>来表示。Z轴在其后方相距90°，因此为</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cb2a381268ae4cb4b79167a21f3ddac6><p class=pgc-img-caption></p></div><p>。</p><p><br></p><p>Y轴保持不变，从而完成了旋转矩阵。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c26c0e91750452f8f1866a8116725ab><p class=pgc-img-caption></p></div><p><br></p><p>最后旋转矩阵使X保持不变，并以类似方式调整Y和Z。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/974effbf722f4aee904d3a69cba690fa><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.4 统一旋转矩阵</p><p>我们的三个旋转矩阵每个绕单个轴旋转。 为了将它们结合起来，我们必须一个接一个地应用。 让我们先绕Z旋转，然后绕Y旋转，最后绕X旋转。但其实我们可以这样做：首先将Z旋转应用于我们的点，然后将Y旋转应用于结果，然后将X旋转应用于该结果。</p><p><br></p><p>同样我们也可以将旋转矩阵彼此相乘。这将产生一个新的旋转矩阵，该矩阵将立即应用所有三个旋转。让我们展示下Y×Z。</p><p><br></p><p>结果矩阵的第一项是</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0c7e0ba2874b428faff10117a0dfbd9a><p class=pgc-img-caption></p></div><p>。</p><p>整个矩阵需要大量的乘法运算，但是许多部分最终都为0，可以丢弃。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48d2ff0b2cc44f00b43f9b23113a971a><p class=pgc-img-caption></p></div><p><br></p><p>现在再来展示X × (Y × Z) ，这会得到我们最终要的矩阵。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47323a2722494dddb2548820eff916d3><p class=pgc-img-caption></p></div><blockquote class=js_blockquote_wrap><p>乘法顺序重要吗？</p><p>X乘以 X×（Y×Z）=（X×Y）×Z的顺序无关紧要。 你最终得到一个不同的中间步骤，但最终结果却相同。 但是，在此方程式中对矩阵重新排序确实会改变旋转顺序，会产生不同的结果。 因此X×Y×Z≠Z×Y×X 在这方面，矩阵乘法不同於单数乘法。</p><p>Unity的实际轮换顺序为ZXY。</p></blockquote><p>现在我们有了这个矩阵，可以看到如何构建旋转结果的X，Y和Z轴。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71135a1dbc264710bbce07135d74dc4d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e53bf221853e45c9919508830bc9f836><p class=pgc-img-caption></p></div><p><br></p><p>（3个轴任意旋转）</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>4 矩阵转换</p><p>如果我们可以能够将三个旋转方向组合到一个矩阵中，是否还可以将缩放，旋转和重新定位也组合到一个矩阵中？如果我们可以将缩放和重新定位表示为矩阵乘法，那么答案是肯定的。</p><p><br></p><p>缩放矩阵很容易构造。取单位矩阵并缩放其分量。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aa00ff4a0d334a7e9d53293729d70e74><p class=pgc-img-caption></p></div><p><br></p><p>但是我们如何支持重新定位呢？ 这不是对三个轴的重新定义，而是一个偏移量。 因此，我们无法用现在拥有的3 x 3矩阵表示它。 我们需要另外一列来包含偏移量。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6433fbf674aa4779898dd2c5ea01c18b><p class=pgc-img-caption></p></div><p><br></p><p>但是，这是无效的，因为矩阵的行长已变为4。因此，我们需要在点上添加第四个组件。 当此分量与偏移量相乘时，它应该为1。我们想要保留该1值，因此可以在进一步的矩阵乘法中使用它。 这会导致一个4×4矩阵和一个4D点。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ef148337e95747078ae459defaef7472><p class=pgc-img-caption></p></div><p><br></p><p>因此，我们必须使用4 x 4转换矩阵。 这意味着缩放和旋转矩阵会获得额外的行和列，其中右下角的数字为0，而数字为1。 我们所有的点都得到第四座标，该座标始终为1。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>4.1 齐次座标</p><p>我们可以理解第四个座标吗？它代表什么有用的东西呢？我们现在知道给它赋予值1可以实现点的重新定位。如果其值为0，则偏移量将被忽略，但缩放和旋转仍会发生。</p><p><br></p><p>可以缩放和旋转但不能移动的东西。那不是点，而是向量，代表一个方向。</p><p>所以</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/12e76e8ec24341b59cd7b704625981b6><p class=pgc-img-caption></p></div><p>代表一个点，而</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c8f293a7f6144924b746a5ec015c9761><p class=pgc-img-caption></p></div><p>表示向量。这概念很有用，因为这意味着我们可以使用相同的矩阵来变换位置，法线和切线。</p><p><br></p><p>如果当第四个座标得到的值不是0或1时会发生什么呢？ 好吧，不应该有这种情况发生。 或实际上，它没有区别。 我们现在正在使用齐次座标。 这个想法是，空间中的每个点都可以用无限数量的座标集表示。 最直接的形式使用1作为第四座标。 通过将整个集合乘以任意数字，可以找到所有其他选择。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/683e54d33d0b488a8c18cdc024501b6b><p class=pgc-img-caption></p></div><p><br></p><p>因此，要获得欧几里得点（实际的3D点），请将每个座标除以第四个座标，然后将其丢弃。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b2f966de81e4388b5aa1a4132ad7b43><p class=pgc-img-caption></p></div><p><br></p><p>当然，当第四个座标为0时，这是行不通的。这些点被定义为无限远。这就是为什么它是表现为方向的。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>4.2 使用矩阵</p><p>我们可以使用Unity的Matrix4x4结构执行矩阵乘法。从现在开始，我们将使用它来执行转换，而不是之前的方法。</p><p><br></p><p>将一个抽象的只读属性添加到Transformation中以检索转换矩阵。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3a050338b8d44dbbfb4821ea3d48d1c><p class=pgc-img-caption></p></div><p><br></p><p>它的Apply方法不再需要抽象。将仅获取矩阵并执行乘法。</p><p><br></p><p>请注意，Matrix4x4.MultiplyPoint具有3D矢量参数。 假定缺少的第四座标为1。它还负责从齐次座标转换回欧几里得座标的工作。 如果是要乘以一个方向而不是一个点，则可以使用Matrix4x4.MultiplyVector。</p><p><br></p><p>现在，具体的转换类必须将其Apply方法更改为Matrix属性。 首先是PositionTransformation。Matrix4x4.SetRow方法提供了一种方便的方式来填充矩阵。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ea424f113de54b56b1a26603ca45424f><p class=pgc-img-caption></p></div><p><br></p><p>接下来是ScaleTransformation。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c5a68d9cfd334cc39e8858dbd736b0cd><p class=pgc-img-caption></p></div><p>对于RotationTransformation，逐列设置矩阵会更方便，因为这与我们现有的代码匹配。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f48aaed477c2448c9333ef563ce18dd7><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>4.3 组合矩阵</p><p>现在，让我们将这些Transform矩阵合并为一个矩阵。将一个Transform矩阵字段添加到TransformationGrid。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c07f0413bdac47fabbe5c69624decfef><p class=pgc-img-caption></p></div><p><br></p><p>我们将在每次Update时更新此转换矩阵。这需要先获取第一个矩阵，然后将其与所有其他矩阵相乘。确保它们以正确的顺序相乘。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f190540f6d8345208feb73637ec719f0><p class=pgc-img-caption></p></div><p>现在，网格不再调用Apply，而是自己执行矩阵乘法。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c491156c281b4381a8208adf54ac869a><p class=pgc-img-caption></p></div><p><br></p><p>这种新方法效率更高，因为我们曾经分别为每个点创建每个Transform矩阵，然后分别应用它们。 现在，我们一次创建一个统一的转换矩阵，并将其重新用于每个点。Unity使用相同的技巧把每个对象层次结构简化为一个Transform矩阵。</p><p><br></p><p>对我们而言，我们可以使其变得更加高效。 所有变换矩阵都具有相同的底行[0 0 0 1]。 知道了这一点，我们就可以忽略该行，而跳过0的计算和最后的转换除法。Matrix4x4.MultiplyPoint4x3方法就是这么做的。 但是，我们不会使用该方法，因为有一些有用的转换会改变底部的行。</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>5 投影矩阵</p><p>到目前为止，我们一直在将点从3D中的一个位置转换为3D空间中的另一个位置。但是这些点最终如何在2D显示器上绘制呢？这需要从3D空间转换为2D空间。我们可以为此创建一个Transform矩阵！</p><p><br></p><p>对相机投影进行新的具体转换。从单位矩阵开始。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed4ce337195847be94be9c6a911b0e22><p class=pgc-img-caption></p></div><p>将其添加为最终转换。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b63c6c2bc0b46dc91da0621d53b7b2b><p class=pgc-img-caption></p></div><p>（相机投影最终结果）</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>5.1 正交相机</p><p>从3D到2D的最直接方法是简单地放弃一个维度。这会将3D空间折叠成一个平面。该平面就像画布一样，用于渲染场景。让我们放弃Z维度试试，看看会发生什么。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2d3eecb2b654ed884ce023927cde147><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36ae7a207e9042c18deb37f8d27f32b4><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cba7887e1de9411c9ee3f32cadb8e504><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/10514af244f7449ea41e357486e01640><p class=pgc-img-caption></p></div><p>（正交投影）</p><p><br></p><p>实际上，网格变为2D了。但你仍然可以缩放，旋转和重新放置所有内容，之后会将其投影到XY平面上。这是基本的正交摄影机投影。</p><p><br></p><p>我们的原始相机位于原点，并朝正Z方向看。 那我们可以移动它并旋转它吗？ 是的，事实上我们已经可以做到了这一点。 移动相机与向相反方向移动世界具有相同的视觉效果。 旋转和缩放也是如此。 因此，尽管有点尴尬，但我们可以使用现有的转换来移动相机。Unity使用矩阵求逆来做同样的事情。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><h2 class=pgc-h-arrow-right>5.2 透视摄像机</h2><p>正交摄影机很好，但不能像我们看到的那样显示世界。 为此，我们需要一个透视相机。 由于视角的原因，距离较远的事物对我们来说显得较小。 我们可以根据点与相机的距离缩放比例来重现此效果。</p><p><br></p><p>将所有内容除以Z座标。 我们可以用矩阵乘法吗？ 是的，通过将单位矩阵的底部行更改为[0,0,1,0]。 这将使结果的第四个座标等于原始Z座标。 从齐次座标转换为欧几里得座标，然后进行所需的划分。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/43db1c64808e4da9b3ea83d9201eea91><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/887bb71b0ece49b4aaa3e14f26e315d3><p class=pgc-img-caption></p></div><p><br></p><p>正交投影的最大区别是点不会直接向下移动到投影平面。 相反，它们会朝着相机的位置（原点）移动，直到撞到切面。 当然，这仅适用于摄像机前面的点。 相机后面的点会被错误地投影。 由于现在我们不会丢弃这些点，因此先通过重新定位确保所有内容都位于相机的前面。 如果不缩放或旋转网格，则5的距离就足够了，否则你可能需要更多。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/79b9bfb07e734e8eaa7028d82a7add22><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/556952a087a7405ca7a0bb2245ad6718><p class=pgc-img-caption></p></div><p>（透视投影）</p><p><br></p><p>原点和投影平面之间的距离也会影响投影。 它的作用就像照相机的焦距。 焦距的越大，视野就越小。 现在，我们使用的焦距为1，可产生90°的视野。 让它可以配置。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1bfc3faf2c034339b51ffd0fd5c8b64d><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b323201faf1d4027aad9ee1a5eed2956><p class=pgc-img-caption></p></div><p>（焦距）</p><p><br></p><p>由于更大的焦距意味着我们正在放大，有效地增加了终点的比例，因此我们可以采用这种方式进行支持。当我们折叠Z尺寸时，不需要缩放该尺寸。</p><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f97eb1df2c5d4edfac4de87b077d5175><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/51d360537c3b4df3a8204e9e450621ef><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e5d34a8f89e0401aac75d6d82a6d0ac6><p class=pgc-img-caption></p></div><p><br></p><p>我们现在有一个非常简单的透视相机。 如果要完全模仿Unity的相机投影，我们还必须处理近距和远距平面。 这将需要投影到立方体而不是平面中，因此深度信息需要保留下来。 再有就是要关心视图纵横比。 另外，Unity的相机朝负Z方向看，还需要取反一些数字。 你可以将所有内容合并到投影矩阵中。 大家可以自己尝试构建。</p><p><br></p><p>那么，这一章节的意义何在？ 我们很少需要自己构造矩阵，并且绝对不需要构造投影矩阵。 其实最主要是你已经能了解它们的背后发生了什么。 矩阵并不可怕，它们只是将点和向量从一个空间转换到另一个空间。 而且你现在也已经知道了，这就很好了，因为一旦我们开始编写自己的着色器时，你会再次遇到矩阵。</p><p><br></p><p>我们将在第2部分“着色器基础知识”中进行此操作。</p><p><br></p><p>本系列会在Unity社区、知乎、个人公众号：<strong>壹种念头 </strong>进行连载发布。公众号会首发，欢迎关注。</p><div class=pgc-img><img alt=基础渲染系列（一）图形学的基石——矩阵 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f35f1c9b4fb4703ad8b7a1317e2b5aa><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'基础','图形学','矩阵'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>