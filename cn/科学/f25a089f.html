<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>操作系统应该提供怎样的进程来创建及控制接口？ | 极客快訊</title><meta property="og:title" content="操作系统应该提供怎样的进程来创建及控制接口？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d1715b22f89c45a7ad0ac34bbb176a8c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/f25a089f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f25a089f.html><meta property="article:published_time" content="2020-10-29T21:13:10+08:00"><meta property="article:modified_time" content="2020-10-29T21:13:10+08:00"><meta name=Keywords content><meta name=description content="操作系统应该提供怎样的进程来创建及控制接口？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/f25a089f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>操作系统应该提供怎样的进程来创建及控制接口？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><p>本章将讨论UNIX系统中的进程创建。UNIX系统采用了一种非常有趣的创建新进程的方式，即通过一对系统调用：fork()和exec()。进程还可以通过第三个系统调用wait()，来等待其创建的子进程执行完成。本章将详细介绍这些接口，通过一些简单的例子来激发兴趣。</p><blockquote><p><strong>关键问题：如何创建并控制进程</strong>　</p><p>操作系统应该提供怎样的进程来创建及控制接口？如何设计这些接口才能既方便又实用？</p></blockquote><h2 class=pgc-h-arrow-right>5.1　fork()系统调用</h2><p>系统调用fork()用于创建新进程[C63]。但要小心，这可能是你使用过的最奇怪的接口[1]。具体来说，你可以运行一个程序，代码如图5.1所示。仔细看这段代码，建议亲自键入并运行！</p><pre><code>1    #include &lt;stdio.h&gt;2    #include &lt;stdlib.h&gt;3    #include &lt;unistd.h&gt;45    int6    main(int argc, char *argv[])7    {8        printf("hello world (pid:%d)\n", (int) getpid());9        int rc = fork();10       if (rc &lt; 0) {        // fork failed; exit11           fprintf(stderr, "fork failed\n");12           exit(1);13       } else if (rc == 0) { // child (new process)14           printf("hello, I am child (pid:%d)\n", (int) getpid());15       } else {             // parent goes down this path (main)16           printf("hello, I am parent of %d (pid:%d)\n",17                   rc, (int) getpid());18       }19       return 0;20   }</code></pre><p>图5.1　调用fork()（p1.c）</p><p>运行这段程序（p1.c），将看到如下输出：</p><pre><code>prompt&gt; ./p1hello world (pid:29146)hello, I am parent of 29147 (pid:29146) hello, I am child (pid:29147)prompt&gt;</code></pre><p>让我们更详细地理解一下p1.c到底发生了什么。当它刚开始运行时，进程输出一条hello world信息，以及自己的进程描述符（process identifier，PID）。该进程的PID是29146。在UNIX系统中，如果要操作某个进程（如终止进程），就要通过PID来指明。到目前为止，一切正常。</p><p>紧接着有趣的事情发生了。进程调用了fork()系统调用，这是操作系统提供的创建新进程的方法。新创建的进程几乎与调用进程完全一样，对操作系统来说，这时看起来有两个完全一样的p1程序在运行，并都从fork()系统调用中返回。新创建的进程称为子进程（child），原来的进程称为父进程（parent）。子进程不会从main()函数开始执行（因此hello world信息只输出了一次），而是直接从fork()系统调用返回，就好像是它自己调用了fork()。</p><p>你可能已经注意到，子进程并不是完全拷贝了父进程。具体来说，虽然它拥有自己的地址空间（即拥有自己的私有内存）、寄存器、程序计数器等，但是它从fork()返回的值是不同的。父进程获得的返回值是新创建子进程的PID，而子进程获得的返回值是0。这个差别非常重要，因为这样就很容易编写代码处理两种不同的情况（像上面那样）。　　</p><p>你可能还会注意到，它的输出不是确定的（deterministic）。子进程被创建后，我们就需要关心系统中的两个活动进程了：子进程和父进程。假设我们在单个CPU的系统上运行（简单起见），那么子进程或父进程在此时都有可能运行。在上面的例子中，父进程先运行并输出信息。在其他情况下，子进程可能先运行，会有下面的输出结果：</p><pre><code>prompt&gt; ./p1hello world (pid:29146) hello, I am child (pid:29147)hello, I am parent of 29147 (pid:29146) prompt&gt;</code></pre><p>CPU调度程序（scheduler）决定了某个时刻哪个进程被执行，我们稍后将详细介绍这部分内容。由于CPU调度程序非常复杂，所以我们不能假设哪个进程会先运行。事实表明，这种不确定性（non-determinism）会导致一些很有趣的问题，特别是在多线程程序（multi-threaded program）中。在本书第2部分中学习并发（concurrency）时，我们会看到许多不确定性。</p><h2 class=pgc-h-arrow-right>5.2　wait()系统调用</h2><p>到目前为止，我们没有做太多事情：只是创建了一个子进程，打印了一些信息并退出。事实表明，有时候父进程需要等待子进程执行完毕，这很有用。这项任务由wait()系统调用（或者更完整的兄弟接口waitpid()）。图5.2展示了更多细节。</p><pre><code>1 #include &lt;stdio.h&gt;2 #include &lt;stdlib.h&gt;3 #include &lt;unistd.h&gt;4 #include &lt;sys/wait.h&gt;56    int7    main(int argc, char *argv[])8    {9        printf("hello world (pid:%d)\n", (int) getpid());10       int rc = fork();11       if (rc &lt; 0) {        // fork failed; exit12           fprintf(stderr, "fork failed\n");13           exit(1);14       } else if (rc == 0) { // child (new process)15           printf("hello, I am child (pid:%d)\n", (int) getpid());16       } else {    // parent goes down this path (main)17           int wc = wait(NULL);18           printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",19                   rc, wc, (int) getpid());20       }21       return 0;22   }</code></pre><p>图5.2　调用fork()和wait()（p2.c）</p><p>在p2.c的例子中，父进程调用wait()，延迟自己的执行，直到子进程执行完毕。当子进程结束时，wait()才返回父进程。</p><p>上面的代码增加了wait()调用，因此输出结果也变得确定了。这是为什么呢？想想看。</p><p>（等你想想看……好了）</p><p>下面是输出结果：</p><pre><code>prompt&gt; ./p2hello world (pid:29266) hello, I am child (pid:29267)hello, I am parent of 29267 (wc:29267) (pid:29266) prompt&gt;</code></pre><p>通过这段代码，现在我们知道子进程总是先输出结果。为什么知道？好吧，它可能只是碰巧先运行，像以前一样，因此先于父进程输出结果。但是，如果父进程碰巧先运行，它会马上调用wait()。该系统调用会在子进程运行结束后才返回[2]。因此，即使父进程先运行，它也会礼貌地等待子进程运行完毕，然后wait()返回，接着父进程才输出自己的信息。</p><h2 class=pgc-h-arrow-right>5.3　最后是exec()系统调用</h2><p>最后是exec()系统调用，它也是创建进程API的一个重要部分[3]。这个系统调用可以让子进程执行与父进程不同的程序。例如，在p2.c中调用fork()，这只是在你想运行相同程序的拷贝时有用。但时，我们常常想运行不同的程序，exec()正好做这样的事（见图5.3）。</p><pre><code>prompt&gt; ./p3hello world (pid:29383) hello, I am child (pid:29384)      29     107   1030 p3.chello, I am parent of 29384 (wc:29384) (pid:29383) prompt&gt;1    #include &lt;stdio.h&gt;2    #include &lt;stdlib.h&gt;3    #include &lt;unistd.h&gt;4    #include &lt;string.h&gt;5    #include &lt;sys/wait.h&gt;67    int8    main(int argc, char *argv[])9    {10       printf("hello world (pid:%d)\n", (int) getpid());11       int rc = fork();12       if (rc &lt; 0) {        // fork failed; exit13           fprintf(stderr, "fork failed\n");14           exit(1);15       } else if (rc == 0) { // child (new process)16           printf("hello, I am child (pid:%d)\n", (int) getpid());17           char *myargs[3];18           myargs[0] = strdup("wc");   // program: "wc" (word count)19           myargs[1] = strdup("p3.c"); // argument: file to count20           myargs[2] = NULL;          // marks end of array21           execvp(myargs[0], myargs); // runs word count22           printf("this shouldn't print out");23       } else {    // parent goes down this path (main)24           int wc = wait(NULL);25           printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",26                   rc, wc, (int) getpid());27       }28       return 0;29   }</code></pre><p>图5.3　调用fork()、wait()和exec()（p3.c）</p><p>在这个例子中，子进程调用execvp()来运行字符计数程序wc。实际上，它针对源代码文件p3.c运行wc，从而告诉我们该文件有多少行、多少单词，以及多少字节。</p><p>fork()系统调用很奇怪，它的伙伴exec()也不一般。给定可执行程序的名称（如wc）及需要的参数（如p3.c）后，exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码段（以及静态数据），堆、栈及其他内存空间也会被重新初始化。然后操作系统就执行该程序，将参数通过argv传递给该进程。因此，它并没有创建新进程，而是直接将当前运行的程序（以前的p3）替换为不同的运行程序（wc）。子进程执行exec()之后，几乎就像p3.c从未运行过一样。对exec()的成功调用永远不会返回。</p><h2 class=pgc-h-arrow-right>5.4　为什么这样设计API</h2><p>当然，你的心中可能有一个大大的问号：为什么设计如此奇怪的接口，来完成简单的、创建新进程的任务？好吧，事实证明，这种分离fork()及exec()的做法在构建UNIX shell的时候非常有用，因为这给了shell在fork之后exec之前运行代码的机会，这些代码可以在运行新程序前改变环境，从而让一系列有趣的功能很容易实现。</p><blockquote><p><strong>提示：重要的是做对事（LAMPSON定律）</strong>　</p><p>Lampson在他的著名论文《Hints for Computer Systems Design》[L83]中曾经说过：“做对事（Get it right）。抽象和简化都不能替代做对事。”有时你必须做正确的事，当你这样做时，总是好过其他方案。有许多方式来设计创建进程的API，但fork()和exec()的组合既简单又极其强大。因此UNIX的设计师们做对了。因为Lampson经常“做对事”，所以我们就以他来命名这条定律。</p></blockquote><p>shell也是一个用户程序[4]，它首先显示一个提示符（prompt），然后等待用户输入。你可以向它输入一个命令（一个可执行程序的名称及需要的参数），大多数情况下，shell可以在文件系统中找到这个可执行程序，调用fork()创建新进程，并调用exec()的某个变体来执行这个可执行程序，调用wait()等待该命令完成。子进程执行结束后，shell从wait()返回并再次输出一个提示符，等待用户输入下一条命令。</p><p>fork()和exec()的分离，让shell可以方便地实现很多有用的功能。比如：</p><pre><code>prompt&gt; wc p3.c &gt; newfile.txt</code></pre><p>在上面的例子中，wc的输出结果被重定向（redirect）到文件newfile.txt中（通过newfile.txt之前的大于号来指明重定向）。shell实现结果重定向的方式也很简单，当完成子进程的创建后，shell在调用exec()之前先关闭了标准输出（standard output），打开了文件newfile.txt。这样，即将运行的程序wc的输出结果就被发送到该文件，而不是打印在屏幕上。</p><p>图5.4展示了这样做的一个程序。重定向的工作原理，是基于对操作系统管理文件描述符方式的假设。具体来说，UNIX系统从0开始寻找可以使用的文件描述符。在这个例子中，STDOUT_FILENO将成为第一个可用的文件描述符，因此在open()被调用时，得到赋值。然后子进程向标准输出文件描述符的写入（例如通过printf()这样的函数），都会被透明地转向新打开的文件，而不是屏幕。</p><p>下面是运行p4.c的结果：</p><pre><code>prompt&gt; ./p4prompt&gt; cat p4.output      32     109    846 p4.cprompt&gt;1    #include &lt;stdio.h&gt;2    #include &lt;stdlib.h&gt;3    #include &lt;unistd.h&gt;4    #include &lt;string.h&gt;5    #include &lt;fcntl.h&gt;6    #include &lt;sys/wait.h&gt;78    int9    main(int argc, char *argv[])10   {11       int rc = fork();12       if (rc &lt; 0) {    // fork failed; exit13           fprintf(stderr, "fork failed\n");14           exit(1);15       } else if (rc == 0) { // child: redirect standard output to a file16           close(STDOUT_FILENO);17           open("./p4.output", O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);1819           // now exec "wc"...20           char *myargs[3];21           myargs[0] = strdup("wc");       // program: "wc" (word count)22           myargs[1] = strdup("p4.c");      // argument: file to count23           myargs[2] = NULL;               // marks end of array24           execvp(myargs[0], myargs);     // runs word count25       } else {                           // parent goes down this path (main)26           int wc = wait(NULL);27       }28       return 0;29   }</code></pre><p>图5.4　之前所有的工作加上重定向（p4.c）</p><p>关于这个输出，你（至少）会注意到两个有趣的地方。首先，当运行p4程序后，好像什么也没有发生。shell只是打印了命令提示符，等待用户的下一个命令。但事实并非如此，p4确实调用了fork来创建新的子进程，之后调用execvp()来执行wc。屏幕上没有看到输出，是由于结果被重定向到文件p4.output。其次，当用cat命令打印输出文件时，能看到运行wc的所有预期输出。很酷吧？</p><p>UNIX管道也是用类似的方式实现的，但用的是pipe()系统调用。在这种情况下，一个进程的输出被链接到了一个内核管道（pipe）上（队列），另一个进程的输入也被连接到了同一个管道上。因此，前一个进程的输出无缝地作为后一个进程的输入，许多命令可以用这种方式串联在一起，共同完成某项任务。比如通过将grep、wc命令用管道连接可以完成从一个文件中查找某个词，并统计其出现次数的功能：grep -o foo file | wc -l。</p><p>最后，我们刚才只是从较高的层面上简单介绍了进程API，关于这些系统调用的细节，还有更多需要学习和理解。例如，在本书第 3 部分介绍文件系统时，我们会学习更多关于文件描述符的知识。现在，知道fork()和exec()组合在创建和操作进程时非常强大就足够了。</p><blockquote><p><strong>补充：RTFM——阅读man手册</strong>　</p><p>很多时候，本书提到某个系统调用或库函数时，会建议阅读man手册。man手册是UNIX系统中最原生的文档，要知道它的出现甚至早于网络（Web）。</p><p>花时间阅读man手册是系统程序员成长的必经之路。手册里有许多有用的隐藏彩蛋。尤其是你正在使用的shell（如tcsh或bash），以及程序中需要使用的系统调用（以便了解返回值和异常情况）。</p><p>最后，阅读man手册可以避免尴尬。当你询问同事某个fork细节时，他可能会回复：“RTFM”。这是他在有礼貌地督促你阅读man手册（Read the Man）。RTFM中的F只是为这个短语增加了一点色彩……</p></blockquote><h2 class=pgc-h-arrow-right>5.5　其他API</h2><p>除了上面提到的fork()、exec()和wait()之外，在UNIX中还有其他许多与进程交互的方式。比如可以通过kill()系统调用向进程发送信号（signal），包括要求进程睡眠、终止或其他有用的指令。实际上，整个信号子系统提供了一套丰富的向进程传递外部事件的途径，包括接受和执行这些信号。</p><p>此外还有许多非常有用的命令行工具。比如通过ps命令来查看当前在运行的进程，阅读man手册来了解ps命令所接受的参数。工具top也很有用，它展示当前系统中进程消耗CPU或其他资源的情况。有趣的是，你常常会发现top命令自己就是最占用资源的，它或许有一点自大狂。此外还有许多CPU检测工具，让你方便快速地了解系统负载。比如，我们总是让MenuMeters（来自Raging Menace公司）运行在Mac计算机的工具栏上，这样就能随时了解当前的CPU利用率。一般来说，对现状了解得越多越好。</p><h2 class=pgc-h-arrow-right>5.6　小结</h2><p>本章介绍了在UNIX系统中创建进程需要的API：fork()、exec()和wait()。更多的细节可以阅读Stevens和Rago的著作 [SR05]，尤其是关于进程控制、进程关系及信号的章节。其中的智慧让人受益良多。</p><p>本文摘自《操作系统导论》</p><div class=pgc-img><img alt=操作系统应该提供怎样的进程来创建及控制接口？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d1715b22f89c45a7ad0ac34bbb176a8c><p class=pgc-img-caption></p></div><p>本书围绕3个主题元素展开讲解：虚拟化（virtualization）、并发（concurrency）和持久性（persistence）。对于这些概念的讨论，最终延伸到讨论操作系统所做的大多数重要事情。希望你在这个过程中体会到一些乐趣。学习新事物很有趣，对吧？</p><p>每个主要概念在若干章节中加以阐释，其中大部分章节都提出了一个特定的问题，然后展示了解决它的方法。这些章节很简短，尝试（尽可能地）引用作为这些想法真正来源的源材料。我们写这本书的目的之一就是厘清操作系统的发展脉络，因为我们认为这有助于学生更清楚地理解过去是什么、现在是什么、将来会是什么。在这种情况下，了解香肠的制作方法几乎与了解香肠的优点一样重要。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'系统','应该','怎样'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>