<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>时序分析与预测完全指南 | 极客快訊</title><meta property="og:title" content="时序分析与预测完全指南 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RZDC2FSBoz7Nc6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%a6/f8595f1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%a6/f8595f1.html><meta property="article:published_time" content="2020-10-29T21:02:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:02:27+08:00"><meta name=Keywords content><meta name=description content="时序分析与预测完全指南"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E5%AD%A6/f8595f1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>时序分析与预测完全指南</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E5%AD%A6.html>科学</a></span></div><div class=post-content><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2FSBoz7Nc6><p>无论我们是想预测金融市场的趋势还是用电量，时间都是我们模型中必须考虑的一个重要因素。例如，预测一天中什么时候会出现用电高峰是很有趣的，可以以此为依据调整电价或发电量。</p><p>输入时间序列。时间序列只是按时间顺序排列的一系列数据点。在时间序列中，时间往往是独立变量，其目标通常是预测未来。</p><p>然而，在处理时间序列时，还有一些其他因素会发挥作用。</p><p>它是静止的吗？</p><p>有季节性吗？</p><p>目标变量是否自相关？</p><p>在这篇文章中，我将介绍时间序列的不同特征，以及我们如何对它们进行建模才能获得准确的预测。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2FmCTHI4HC><p>预测未来是困难的</p><p><strong>自相关</strong></p><p>通俗地说，自相关是观测值之间的相似度，它是观测值之间时间滞后的函数。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2G180rPCRy><p>自相关示例</p><p>上面是一个自相关的例子。仔细观察，你会发现第一个值和第 24 个值具有很高的自相关性。同样，第 12 个值和第 36 个观测值也高度相关。这意味着我们将在每 24 个时间单位中找到一个非常相似的值。</p><p>注意，这个图看起来像正弦函数。这是季节性的征兆，你可以通过在上面的图中找到 24 小时的周期来找到它的价值。</p><p><strong>季节性</strong></p><p>季节性是指周期性波动。例如，白天的用电量高，晚上的用电量低，或者圣诞节期间的在线销售额增加，节后销售再次放缓。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2GEBX3ZTTc><p>季节性示例</p><p>如你所见，每天都有明显的季节性。每天晚上，你都会看到一个高峰，最低点出现在每天的开始和结束。</p><p>记住，如果季节性是满足正弦函数的，它也可以从自相关图中推导出来。简单地看一下周期，它给出了季节的长度。</p><p><strong>平稳性</strong></p><p>平稳性是时间序列的一个重要特征。如果时间序列的统计性质不随时间变化，则称其为平稳的。换句话说，它有不变的均值和方差，协方差不随时间变化。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2GSG44bF01><p>平稳过程示例</p><p>再看上面的图，我们看到上面的过程是平稳的，平均值和方差不会随时间变化。</p><p>通常，股票价格不是一个平稳的过程，因为我们可能会看到一个增长的趋势，或者，其波动性可能会随着时间的推移而增加（这意味着方差正在变化）。</p><p>理想情况下，我们需要一个用于建模的固定时间序列。当然，不是所有的都是平稳的，但是我们可以通过做不同的变换，使它们保持平稳。</p><p><strong>如何测试过程是否平稳</strong></p><p>你可能已经注意到在上图的标题「Dickey-Fuller」。这是我们用来确定时间序列是否稳定的统计测试。</p><p>在不讨论 Dickey-Fuller 测试的技术特性的情况下，它检测了单位根是否存在空假设。</p><p>如果是，则 P>0，并且过程不是平稳的。</p><p>否则，p=0，无效假设被拒绝，过程被认为是平稳的。</p><p>例如，下面的过程不是平稳的。请注意为什么平均值不随时间变化。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC2divFxXQj><p>非平稳过程示例</p><p><strong>时间序列建模</strong></p><p>有很多方法可以模拟时间序列来进行预测。在此，我将介绍：</p><ul><li><p>移动平均</p></li><li><p>指数平滑</p></li><li><p>ARIMA</p></li></ul><p><strong>移动平均</strong></p><p>移动平均模型可能是最简单的时间序列建模方法。这个模型简单来说就是，下一个值是所有过去值的平均值。</p><p>虽然很简单，但是这个模型的效果可能好到出乎意料，它代表了一个好的起点。</p><p>否则，移动平均值可用于识别数据中有趣的趋势。我们可以定义一个窗口来应用移动平均模型来平滑时间序列，并突出不同的趋势。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC2e14Oof853><p>24 小时窗口上的移动平均值示例</p><p>在上面的图中，我们将移动平均模型应用于一个 24 小时窗口。绿线平滑了时间序列，我们可以看到 24 小时内有 2 个峰值。</p><p>当然，窗口越长，趋势就越平滑。下面是一个较小窗口上移动平均值的示例。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC2eF4PWwy6v><p>12 小时窗口上的移动平均值示例</p><p><strong>指数平滑</strong></p><p>指数平滑使用与移动平均相似的逻辑，但这次，对每个观测值分配了不同的递减权重。换言之，离现在的时间距离越远，观察结果的重要性就越低。</p><p>在数学上，指数平滑表示为：</p><p>指数平滑表达式</p><p>这里，alpha 是一个平滑因子，它的值介于 0 和 1 之间。它决定了之前观测值的权重下降的速度。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2elJ9Rhydq><p>指数平滑示例</p><p>在上面的图中，深蓝色线表示时间序列的指数平滑，平滑系数为 0.3，而橙色线表示平滑系数为 0.05。</p><p>如你所见，平滑因子越小，时间序列就越平滑。这是有意义的，因为当平滑因子接近 0 时，我们接近移动平均模型。</p><p><strong>双指数平滑</strong></p><p>当时间序列中存在趋势时，使用双指数平滑。在这种情况下，我们使用这种技术，它只是指数平滑的两次递归使用。</p><p>数学公式为：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2oFIxpwe2j><p>双指数平滑表达式</p><p>这里，beta 是趋势平滑因子，它的值介于 0 和 1 之间。</p><p>下面，你可以看到 alpha 和 beta 的不同值如何影响时间序列的形状。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC2oY5lJXGIO><p>双指数平滑示例</p><p><strong>三指数平滑</strong></p><p>该方法通过添加季节平滑因子来扩展双指数平滑。当然，如果你注意到时间序列中的季节性，这很有用。</p><p>在数学上，三指数平滑表示为：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC2okDwkUDkw><p>三指数平滑表达式</p><p>其中 gamma 是季节平滑因子，L 是季节长度。</p><p><strong>季节性差分自回归滑动平均模型（SARIMA）</strong></p><p>SARIMA 实际上是简单模型的组合，可以生成一个复杂的模型，该模型可以模拟具有非平稳特性和季节性的时间序列。</p><p>首先，我们得到了自回归模型 AR(p)。这基本上是时间序列对自身的回归。在这里，我们假设当前值依赖于它以前的值，并且有一定的滞后。它采用一个表示最大滞后的参数 p。为了找到它，我们查看了部分自相关图，在此之后大部分滞后并不显著。</p><p>在下面的例子中，p 的值是 4。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC2ow2zkClQ><p>部分自相关图示例</p><p>然后，我们添加移动平均模型 MA(q)。这需要一个参数 q，它代表自相关图上那些滞后不显著的最大滞后。</p><p>下图中，q 为 4。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC2pBBc3OZYk><p>自相关图示例</p><p>之后，我们添加整合顺序 I(d)。参数 d 表示使序列平稳所需的差异数。</p><p>最后，我们添加最后一部分：季节性 S(P, D, Q, s)，其中 S 只是季节的长度。此外，这里要求参数 P 和 Q 与 p 和 q 相同，但用于季节部分。最后，D 是季节整合的顺序，表示从系列中删除季节性所需的差异数量。</p><p>综合起来，我们得到了 SARIMA(p, d, q)(P, D, Q, s) 模型。</p><p>要注意的是：在用 SARIMA 建模之前，我们必须对时间序列进行转换，以消除季节性和任何非平稳行为。</p><p>这是一个很好的理论！让我们在第一个项目中应用上面讨论的技术。</p><p>我们将想办法预测一家公司的股票价格。现在，预测股票价格几乎是不可能的。然而，这仍然是一个有趣的练习，它将是一个很好的来实践我们所学到知识的方法。</p><p><strong>项目 1：股票价格预测</strong></p><p>我们将利用 New Germany Fund（GF）的历史股价来预测未来五个交易日的收盘价。</p><p>你可以在这里获取数据集和资料。</p><p>像往常一样，我强烈推荐你动手编码！启动你的笔记本，我们开始吧！</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC306INJrN4e><p>你绝不会因为这个项目而发财</p><p><strong>导入数据</strong></p><blockquote><p>import numpy as np</p><p>import pandas as pd</p><p>import matplotlib.pyplot as plt</p><p>import seaborn as sns</p><p>sns.set</p><br><p>from sklearn.metrics import r2_score, median_absolute_error, mean_absolute_error</p><p>from sklearn.metrics import median_absolute_error, mean_squared_error, mean_squared_log_error</p><br><p>from scipy.optimize import minimize</p><p>import statsmodels.tsa.api as smt</p><p>import statsmodels.api as sm</p><br><p>from tqdm import tqdm_notebook</p><br><p>from itertools import product</p><br><p>def mean_absolute_percentage_error(y_true, y_pred):</p><p>return np.mean(np.abs((y_true - y_pred) / y_true)) * 100</p><br><p>import warnings</p><p>warnings.filterwarnings('ignore')</p><br><p>%matplotlib inline</p><br><p>DATAPATH = 'data/stock_prices_sample.csv'</p><br><p>data = pd.read_csv(DATAPATH, index_col=['DATE'], parse_dates=['DATE'])</p><p>data.head(10)</p></blockquote><p>首先，我们导入一些库，这些库将在整个分析过程中都会用到。此外，我们用平均百分比误差（MAPE）作为我们的误差度量。</p><p>然后，我们导入数据集，排在前十的是：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC30S5Qv884d><p>数据集的前 10 个条目</p><p>正如你所看到的，我们有一些关于 New Germany Fund (GF) 不同股票的数据。此外，我们还有一个关于当天信息的数据，但我们只需要当天结束（EOD）时的股票信息。</p><p><strong>数据清洗</strong></p><blockquote><p>data = data[data.TICKER != 'GEF']</p><p>data = data[data.TYPE != 'Intraday']</p><br><p>drop_cols = ['SPLIT_RATIO', 'EX_DIVIDEND', 'ADJ_FACTOR', 'ADJ_VOLUME', 'ADJ_CLOSE', 'ADJ_LOW', 'ADJ_HIGH', 'ADJ_OPEN', 'VOLUME', 'FREQUENCY', 'TYPE', 'FIGI']</p><br><p>data.drop(drop_cols, axis=1, inplace=True)</p><br><p>data.head</p></blockquote><p>首先，我们删除不需要的条目。</p><p>然后，我们删除不需要的列，因为我们只想关注股票的收盘价。</p><p>如果预览数据集，则应该看到的是：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC30l691ucpQ><p>清洗后的数据集</p><p>令人惊叹！我们准备好进行探索性数据分析了！</p><p><strong>探索性数据分析（EDA）</strong></p><blockquote><p># Plot closing price</p><br><br><p>plt.figure(figsize=(17, 8))</p><p>plt.plot(data.CLOSE)</p><p>plt.title('Closing price of New Germany Fund Inc (GF)')</p><p>plt.ylabel('Closing price ($)')</p><p>plt.xlabel('Trading day')</p><p>plt.grid(False)</p><p>plt.show</p></blockquote><p>我们绘制数据集整个时间段的收盘价。</p><p>你将会得到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC30xAJ86Ort><p>New Germany Fund （GF）收盘价</p><p>很明显，你看到的不是一个平稳的过程，很难判断是否有某种季节性。</p><p><strong>移动平均</strong></p><p>让我们使用移动平均模型来平滑我们的时间序列。为此，我们将使用一个辅助函数，该函数将在指定的时间窗口上运行移动平均模型，并绘制结果平滑曲线：</p><blockquote><p>def plot_moving_average(series, window, plot_intervals=False, scale=1.96):</p><br><p>rolling_mean = series.rolling(window=window).mean</p><br><p>plt.figure(figsize=(17,8))</p><p>plt.title('Moving average\n window size = {}'.format(window))</p><p>plt.plot(rolling_mean, 'g', label='Rolling mean trend')</p><br><p>#Plot confidence intervals for smoothed values</p><p>if plot_intervals:</p><p>mae = mean_absolute_error(series[window:], rolling_mean[window:])</p><p>deviation = np.std(series[window:] - rolling_mean[window:])</p><p>lower_bound = rolling_mean - (mae + scale * deviation)</p><p>upper_bound = rolling_mean + (mae + scale * deviation)</p><p>plt.plot(upper_bound, 'r--', label='Upper bound / Lower bound')</p><p>plt.plot(lower_bound, 'r--')</p><br><p>plt.plot(series[window:], label='Actual values')</p><p>plt.legend(loc='best')</p><p>plt.grid(True)</p><br><p>#Smooth by the previous 5 days (by week)</p><p>plot_moving_average(data.CLOSE, 5)</p><br><p>#Smooth by the previous month (30 days)</p><p>plot_moving_average(data.CLOSE, 30)</p><br><p>#Smooth by previous quarter (90 days)</p><p>plot_moving_average(data.CLOSE, 90, plot_intervals=True)</p></blockquote><p>使用5天的时间窗口，我们得到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RZDC31ACkUHgJ2><p>上一个交易周的平滑曲线</p><p>如你所见，我们几乎看不到趋势，因为它太接近实际曲线。让我们看看上个月和上个季度的平滑处理结果。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC3DCBSlltqp><p>上个月（30 天前）的平滑曲线</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC3DO9NP1VIu><p>按上一季度（90 天）平滑</p><p>现在更容易发现趋势。请注意，30 天和 90 天的趋势图在末尾显示一条向下的曲线。这意味着股票可能在接下来的几天内会下跌。</p><p><strong>指数平滑</strong></p><p>现在，让我们用指数平滑来看看它是否能获得更好的趋势。</p><blockquote><p>def exponential_smoothing(series, alpha):</p><br><p>result = [series[0]] # first value is same as series</p><p>for n in range(1, len(series)):</p><p>result.append(alpha * series[n] + (1 - alpha) * result[n-1])</p><p>return result</p><br><p>def plot_exponential_smoothing(series, alphas):</p><br><p>plt.figure(figsize=(17, 8))</p><p>for alpha in alphas:</p><p>plt.plot(exponential_smoothing(series, alpha), label="Alpha {}".format(alpha))</p><p>plt.plot(series.values, "c", label = "Actual")</p><p>plt.legend(loc="best")</p><p>plt.axis('tight')</p><p>plt.title("Exponential Smoothing")</p><p>plt.grid(True);</p><br><p>plot_exponential_smoothing(data.CLOSE, [0.05, 0.3])</p></blockquote><p>这里，我们使用 0.05 和 0.3 作为平滑因子的值。当然你也可以尝试其他值，看看结果如何。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3DeAxDT12a><p>指数平滑</p><p>如您所见，alpha 值 0.05 平滑了曲线，同时剔除了大部分向上和向下的趋势。</p><p>现在，让我们使用双指数平滑。</p><p><strong>双指数平滑</strong></p><blockquote><p>def double_exponential_smoothing(series, alpha, beta):</p><br><p>result = [series[0]]</p><p>for n in range(1, len(series)+1):</p><p>if n == 1:</p><p>level, trend = series[0], series[1] - series[0]</p><p>if n >= len(series): # forecasting</p><p>value = result[-1]</p><p>else:</p><p>value = series[n]</p><p>last_level, level = level, alpha * value + (1 - alpha) * (level + trend)</p><p>trend = beta * (level - last_level) + (1 - beta) * trend</p><p>result.append(level + trend)</p><p>return result</p><br><p>def plot_double_exponential_smoothing(series, alphas, betas):</p><br><p>plt.figure(figsize=(17, 8))</p><p>for alpha in alphas:</p><p>for beta in betas:</p><p>plt.plot(double_exponential_smoothing(series, alpha, beta), label="Alpha {}, beta {}".format(alpha, beta))</p><p>plt.plot(series.values, label = "Actual")</p><p>plt.legend(loc="best")</p><p>plt.axis('tight')</p><p>plt.title("Double Exponential Smoothing")</p><p>plt.grid(True)</p><br><p>plot_double_exponential_smoothing(data.CLOSE, alphas=[0.9, 0.02], betas=[0.9, 0.02])</p></blockquote><p>你将得到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3Dp9MToSHI><p>双指数平滑</p><p>同样，用不同的 α 和 β 组合进行实验，以获得更好的曲线。</p><p><strong>建模</strong></p><p>如前所述，我们必须将序列转换为一个平稳的过程，以便对其进行建模。因此，让我们应用 Dickey-Fuller 测试来看看它是否是一个平稳的过程：</p><blockquote><p>def tsplot(y, lags=None, figsize=(12, 7), syle='bmh'):</p><br><p>if not isinstance(y, pd.Series):</p><p>y = pd.Series(y)</p><br><p>with plt.style.context(style='bmh'):</p><p>fig = plt.figure(figsize=figsize)</p><p>layout = (2,2)</p><p>ts_ax = plt.subplot2grid(layout, (0,0), colspan=2)</p><p>acf_ax = plt.subplot2grid(layout, (1,0))</p><p>pacf_ax = plt.subplot2grid(layout, (1,1))</p><br><p>y.plot(ax=ts_ax)</p><p>p_value = sm.tsa.stattools.adfuller(y)[1]</p><p>ts_ax.set_title('Time Series Analysis Plots\n Dickey-Fuller: p={0:.5f}'.format(p_value))</p><p>smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)</p><p>smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)</p><p>plt.tight_layout</p><br><p>tsplot(data.CLOSE, lags=30)</p><br><p># Take the first difference to remove to make the process stationary</p><p>data_diff = data.CLOSE - data.CLOSE.shift(1)</p><br><p>tsplot(data_diff[1:], lags=30)</p></blockquote><p>你将看到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3E0HDKpG5Y><p>通过 DickeyFuller 测试，时间序列是非平稳的。另外，从自相关图来看，我们发现它似乎没有明显的季节性。</p><p>因此，为了消除高度自相关并使过程稳定，让我们取第一个差异（代码块中的第 23 行）。我们简单地用一天的滞后时间减去时间序列，得到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3JzumcYdY><p>令人惊叹的！我们的序列现在是平稳的，可以开始建模了！</p><p><strong>SARIMA</strong></p><blockquote><p>#Set initial values and some bounds</p><p>ps = range(0, 5)</p><p>d = 1</p><p>qs = range(0, 5)</p><p>Ps = range(0, 5)</p><p>D = 1</p><p>Qs = range(0, 5)</p><p>s = 5</p><br><p>#Create a list with all possible combinations of parameters</p><p>parameters = product(ps, qs, Ps, Qs)</p><p>parameters_list = list(parameters)</p><p>len(parameters_list)</p><br><p># Train many SARIMA models to find the best set of parameters</p><p>def optimize_SARIMA(parameters_list, d, D, s):</p><p>"""</p><p>Return dataframe with parameters and corresponding AIC</p><br><p>parameters_list - list with (p, q, P, Q) tuples</p><p>d - integration order</p><p>D - seasonal integration order</p><p>s - length of season</p><p>"""</p><br><p>results =</p><p>best_aic = float('inf')</p><br><p>for param in tqdm_notebook(parameters_list):</p><p>try: model = sm.tsa.statespace.SARIMAX(data.CLOSE, order=(param[0], d, param[1]),</p><p>seasonal_order=(param[2], D, param[3], s)).fit(disp=-1)</p><p>except:</p><p>continue</p><br><p>aic = model.aic</p><br><p>#Save best model, AIC and parameters</p><p>if aic</p><p>best_model = model</p><p>best_aic = aic</p><p>best_param = param</p><p>results.append([param, model.aic])</p><br><p>result_table = pd.DataFrame(results)</p><p>result_table.columns = ['parameters', 'aic']</p><p>#Sort in ascending order, lower AIC is better</p><p>result_table = result_table.sort_values(by='aic', ascending=True).reset_index(drop=True)</p><br><p>return result_table</p><br><p>result_table = optimize_SARIMA(parameters_list, d, D, s)</p><br><p>#Set parameters that give the lowest AIC (Akaike Information Criteria)</p><p>p, q, P, Q = result_table.parameters[0]</p><br><p>best_model = sm.tsa.statespace.SARIMAX(data.CLOSE, order=(p, d, q),</p><p>seasonal_order=(P, D, Q, s)).fit(disp=-1)</p><br><p>print(best_model.summary)</p></blockquote><p>现在，对于 SARIMA，我们首先定义一些参数值的范围，以生成 p, q, d, P, Q, D, s 的所有可能组合的列表。</p><p>现在，在上面的代码单元中，我们有 625 种不同的组合！我们将尝试每种组合，并训练 SARIMA，以便找到性能最佳的模型。这可能需要一些时间，具体多长时间取决于计算机的处理能力。</p><p>完成后，我们将输出最佳模型的摘要，你将看到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3KG5iLuEEh><p>令人惊叹！最后，我们预测未来五个交易日的收盘价，并评估模型的 MAPE。</p><p>在这种情况下，有一个 0.79% 的 MAPE，这是非常好的！</p><p><strong>将预测价格与实际数据进行比较</strong></p><blockquote><p># Make a dataframe containing actual and predicted prices</p><p>comparison = pd.DataFrame({'actual': [18.93, 19.23, 19.08, 19.17, 19.11, 19.12],</p><p>'predicted': [18.96, 18.97, 18.96, 18.92, 18.94, 18.92]},</p><p>index = pd.date_range(start='2018-06-05', periods=6,))</p><br><p>#Plot predicted vs actual price</p><br><p>plt.figure(figsize=(17, 8))</p><p>plt.plot(comparison.actual)</p><p>plt.plot(comparison.predicted)</p><p>plt.title('Predicted closing price of New Germany Fund Inc (GF)')</p><p>plt.ylabel('Closing price ($)')</p><p>plt.xlabel('Trading day')</p><p>plt.legend(loc='best')</p><p>plt.grid(False)</p><p>plt.show</p></blockquote><p>现在，为了将我们的预测与实际数据进行比较，我们从雅虎财务（YahooFinance）获取财务数据并创建一个数据框架。</p><p>然后，我们绘出曲线，看看我们与实际收盘价的差距有多大：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3KT2yJQATU><p>预计值和实际收盘价比较</p><p>我们的预测似乎有点偏离。事实上，预测价格很平稳，这意味着我们的模型可能表现不佳。</p><p>当然，这不是因为我们的程序，而是因为预测股票价格基本上是不可能的。</p><p>从第一个项目开始，我们学习了在使用 SARIMA 建模之前平滑时间序列的整个过程。</p><p>现在，让我们介绍一下 Facebook 的 Prophet。它是一个在 python 和 r 中都可用的预测工具。该工具帮助生成高质量的预测。</p><p>让我们看看如何在第二个项目中使用它！</p><p><strong>项目2-使用 Prophet 预测空气质量</strong></p><p>标题说明了一切：我们将使用 Prophet 来帮助我们预测空气质量！</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3KfCyCT9g7><p><strong>导入数据</strong></p><blockquote><p>import warnings</p><p>warnings.filterwarnings('ignore')</p><br><p>import numpy as np</p><p>import pandas as pd</p><p>from scipy import stats</p><p>import statsmodels.api as sm</p><p>import matplotlib.pyplot as plt</p><br><p>%matplotlib inline</p><br><p>DATAPATH = 'data/AirQualityUCI.csv'</p><br><p>data = pd.read_csv(DATAPATH, sep=';')</p><p>data.head</p></blockquote><p>打印出前五行：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3Ks4JiB91e><p>如你所见，数据集包含有关不同气体浓度的信息。每天隔一个小时记录一次。</p><p>如果更深入地研究数据集，会发现有许多值 -200 的实例。当然，负浓度是没有意义的，所以我们需要在建模前清洗数据。</p><p><strong>数据清洗与特征工程</strong></p><blockquote><p># Make dates actual dates</p><p>data['Date'] = pd.to_datetime(data['Date'])</p><br><p># Convert measurements to floats</p><p>for col in data.iloc[:,2:].columns:</p><p>if data[col].dtypes == object:</p><p>data[col] = data[col].str.replace(',', '.').astype('float')</p><br><p># Compute the average considering only the positive values</p><p>def positive_average(num):</p><p>return num[num > -200].mean</p><br><p># Aggregate data</p><p>daily_data = data.drop('Time', axis=1).groupby('Date').apply(positive_average)</p><br><p># Drop columns with more than 8 NaN</p><p>daily_data = daily_data.iloc[:,(daily_data.isna().sum()</p><br><p># Remove rows containing NaN values</p><p>daily_data = daily_data.dropna()</p><br><p># Aggregate data by week</p><p>weekly_data = daily_data.resample('W').mean()</p><br><p># Plot the weekly concentration of each gas</p><p>def plot_data(col):</p><p>plt.figure(figsize=(17, 8))</p><p>plt.plot(weekly_data[col])</p><p>plt.xlabel('Time')</p><p>plt.ylabel(col)</p><p>plt.grid(False)</p><p>plt.show</p><br><p>for col in weekly_data.columns:</p><p>plot_data(col)</p></blockquote><p>在这里，我们首先分析日期列，将其转换为日期类型。</p><p>然后，我们把所有的测量值转换成浮点数。</p><p>之后，我们用每天的平均值来汇总数据。</p><p>我们还有一些需要删除的 NAN。</p><p>最后，我们按周汇总数据，这将提供一个更平滑的分析趋势。</p><p>我们可以画出每种化学物质浓度的趋势。这里，我们展示了 NOx。</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RZDC3Sc8XMRthq><p>NOx 浓度</p><p>氮氧化物是非常有害的，因为它们会形成烟雾和酸雨，同时也会形成细颗粒和臭氧。这些都会对健康产生不利影响，因此氮氧化物的浓度是空气质量的一个关键特征。</p><p><strong>建模</strong></p><blockquote><p># Drop irrelevant columns</p><p>cols_to_drop = ['PT08.S1(CO)', 'C6H6(GT)', 'PT08.S2(NMHC)', 'PT08.S4(NO2)', 'PT08.S5(O3)', 'T', 'RH', 'AH']</p><br><p>weekly_data = weekly_data.drop(cols_to_drop, axis=1)</p><br><p># Import Prophet</p><p>from fbprophet import Prophet</p><p>import logging</p><br><p>logging.getLogger.setLevel(logging.ERROR)</p><br><p># Change the column names according to Prophet's guidelines</p><p>df = weekly_data.reset_index</p><p>df.columns = ['ds', 'y']</p><p>df.head</p><br><p># Split into a train/test set</p><p>prediction_size = 30</p><p>train_df = df[:-prediction_size]</p><br><p># Initialize and train a model</p><p>m = Prophet</p><p>m.fit(train_df)</p><br><p># Make predictions</p><p>future = m.make_future_dataframe(periods=prediction_size)</p><p>forecast = m.predict(future)</p><p>forecast.head</p><br><p># Plot forecast</p><p>m.plot(forecast)</p><br><p># Plot forecast's components</p><p>m.plot_components(forecast)</p><br><p># Evaluate the model</p><p>def make_comparison_dataframe(historical, forecast):</p><p>return forecast.set_index('ds')[['yhat', 'yhat_lower', 'yhat_upper']].join(historical.set_index('ds'))</p><br><p>cmp_df = make_comparison_dataframe(df, forecast)</p><p>cmp_df.head</p><br><p>def calculate_forecast_errors(df, prediction_size):</p><br><p>df = df.copy</p><br><p>df['e'] = df['y'] - df['yhat']</p><p>df['p'] = 100 * df['e'] / df['y']</p><br><p>predicted_part = df[-prediction_size:]</p><br><p>error_mean = lambda error_name: np.mean(np.abs(predicted_part[error_name]))</p><br><p>return {'MAPE': error_mean('p'), 'MAE': error_mean('e')}</p><br><p>for err_name, err_value in calculate_forecast_errors(cmp_df, prediction_size).items:</p><p>print(err_name, err_value)</p><br><p># Plot forecast with upper and lower bounds</p><p>plt.figure(figsize=(17, 8))</p><p>plt.plot(cmp_df['yhat'])</p><p>plt.plot(cmp_df['yhat_lower'])</p><p>plt.plot(cmp_df['yhat_upper'])</p><p>plt.plot(cmp_df['y'])</p><p>plt.xlabel('Time')</p><p>plt.ylabel('Average Weekly NOx Concentration')</p><p>plt.grid(False)</p><p>plt.show</p></blockquote><p>我们将只关注氮氧化物浓度。因此，我们删除所有其他不相关的列。</p><p>然后，我们导入 Prophet。</p><p>Prophet 要求日期列命名为 ds，特征列命名为 y，因此我们进行了适当的更改。</p><p>此时，我们的数据如下：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3StG3ciKx5><p>然后，我们定义一个训练集。为此，我们将保留最后 30 个条目进行预测和验证。</p><p>之后，我们简单地初始化 Prophet，将模型与数据匹配，并进行预测！</p><p>你会看到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RZDC3T6uCvFGj><p>这里，yhat 代表预测值，yhat_lower 和 yhat_upper 分别代表预测值的下限和上限。</p><p>Prophet 让你可以轻松绘制预测图，我们得到：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC3TK27Rr0FR><p>NOx 浓度预测</p><p>如你所见，Prophet 只是用一条直线来预测未来的 NOx 浓度。</p><p>然后，我们检查时间序列是否具有某些有趣的特性，例如季节性：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC3TWxWyPdU><p>在这里，Prophet 没有发现季节性的趋势。</p><p>通过计算模型的平均绝对百分误差（MAPE）和平均绝对误差（MAE）来评估模型的性能，我们发现 MAPE 为 13.86%，MAE 为 109.32，这还不错！记住，我们根本没有对模型进行微调。</p><p>最后，我们只需绘制预测的上限和下限：</p><img alt=时序分析与预测完全指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RZDC3ZZ6w3ptCJ><p>每周 NOx 平均浓度预测</p><p>恭喜你达到目的！这篇文章很长，但内容丰富。你学会了如何强有力地分析和建模时间序列，并将你的知识应用到两个不同的项目中。我希望你觉得这篇文章有用。</p><p>via：https://towardsdatascience.com/the-complete-guide-to-time-series-analysis-and-forecasting-70d476bfe775</p><p>雷锋网雷锋网雷锋网</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'时序','预测','指南'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>