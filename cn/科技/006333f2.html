<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一篇文让你彻底了解java多线程并发 | 极客快訊</title><meta property="og:title" content="一篇文让你彻底了解java多线程并发 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fbdb8be32a094b448c052c5058d1d2f2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/006333f2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/006333f2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/006333f2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/006333f2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/006333f2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/006333f2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/006333f2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/006333f2.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="一篇文让你彻底了解java多线程并发"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/006333f2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一篇文让你彻底了解java多线程并发</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1><strong>前言：</strong></h1><p>如果对什么是线程、什么是进程仍存有疑惑，请先Google之，因为这两个概念不在本文的范围之内。</p><p>用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。</p><p>很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。</p><h1><strong>引：</strong></h1><p>用多线程只有一个目的，那就是更好的利用cpu的资源，因为所有的多线程代码都可以用单线程来实现。说这个话其实只有一半对，因为反应“多角色”的程序代码，最起码每个角色要给他一个线程吧，否则连实际场景都无法模拟，当然也没法说能用单线程来实现：比如最常见的“生产者，消费者模型”。</p><p>很多人都对其中的一些概念不够明确，如同步、并发等等，让我们先建立一个数据字典，以免产生误会。</p><ul><li>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</li><li>并行与并发：并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li></ul><blockquote><p><strong>由幅原因，文末有答案和解析</strong></p></blockquote><p><strong>如下图是我整理的一篇大纲，分享给大家</strong></p><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fbdb8be32a094b448c052c5058d1d2f2><p class=pgc-img-caption></p></div><h1><strong>正文</strong></h1><h1><strong>一</strong></h1><ul><li>java线程实现/创建方式</li><li><strong>4种线程池（解析）</strong></li><li>线程生命周期（状态）</li><li>终止线程4种方式</li></ul><p><strong>4种线程池解析：</strong></p><p>Java 里面线程池的顶级接口是 Executor，但是严格意义上讲 Executor 并不是一个线程池，而</p><p>只是一个执行线程的工具。真正的线程池接口是 ExecutorService。如图：</p><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9627f478a6b4f308d31644844c5b669><p class=pgc-img-caption></p></div><p><strong>1、newCachedThreadPool</strong></p><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行</p><p>很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 execute 将重用以前构造</p><p>的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并</p><p>从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资</p><p>源</p><p><strong>2、newFixedThreadPool</strong></p><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大</p><p>多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，</p><p>则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何</p><p>线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之</p><p>前，池中的线程将一直存在</p><p><strong>3、newScheduledThreadPool</strong></p><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p><blockquote><p>ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(3);</p><p>scheduledThreadPool.schedule(newRunnable(){</p><p>@Override</p><p>public void run() {</p><p>System.out.println("延迟三秒");</p><p>}</p><p>}, 3, TimeUnit.SECONDS);</p><p>scheduledThreadPool.scheduleAtFixedRate(newRunnable(){</p><p>@Override</p><p>public void run() {</p><p>System.out.println("延迟 1 秒后每三秒执行一次");</p><p>}</p><p>},1,3,TimeUnit.SECONDS)</p></blockquote><p><strong>4、newSingleThreadExecutor</strong></p><p>Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程）,这个线程</p><p>池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！</p><blockquote><p>更多解析</p></blockquote><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9e03e4a3729a440980a909bccf8e86b3><p class=pgc-img-caption></p></div><h1><strong>二</strong></h1><ul><li>sleep与wait区别</li><li>start与run区别</li><li><strong>Java后台线程(解析）</strong></li></ul><p><strong>Java后台线程(解析）</strong></p><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f86b64a0461e4b16a2a05096302b04e7><p class=pgc-img-caption></p></div><p><strong>1. </strong>定义：守护线程--也称“服务线程”，他是后台线程，它有一个特性，即为用户线程 提供 公</p><p>共服务，在没有用户线程可服务时会自动离开。</p><p><strong>2.</strong> 优先级：守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。</p><p><strong>3. </strong>设置：通过 setDaemon(true)来设置线程为“守护线程”；将一个用户线程设置为守护线程</p><p>的方式是在 线程对象创建 之前 用线程对象的 setDaemon 方法。</p><p><strong>4</strong>. 在 Daemon 线程中产生的新线程也是 Daemon 的。</p><p><strong>5</strong>. 线程则是 JVM 级别的，以 Tomcat 为例，如果你在 Web 应用中启动一个线程，这个线程的</p><p>生命周期并不会和 Web 应用程序保持同步。也就是说，即使你停止了 Web 应用，这个线程</p><p>依旧是活跃的。</p><p><strong>6</strong>. example: 垃圾回收线程就是一个经典的守护线程，当我们的程序中不再有任何运行的Thread,</p><p>程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是 JVM 上仅剩的线</p><p>程时，垃圾回收线程会自动离开。它始终在低级别的状态中运行，用于实时监控和管理系统</p><p>中的可回收资源。</p><p><strong>7</strong>. 生命周期：守护进程（Daemon）是运行在后台的一种特殊进程。它独立于控制终端并且周</p><p>期性地执行某种任务或等待处理某些发生的事件。也就是说守护线程不依赖于终端，但是依</p><p>赖于系统，与系统“同生共死”。当 JVM 中所有的线程都是守护线程的时候，JVM 就可以退</p><p>出了；如果还有一个或以上的非守护线程则 JVM 不会退出。</p><h1><strong>三</strong></h1><p><strong>java锁</strong></p><p><strong>因为文章篇幅原因，文章资料都整理在一个文档里面了，需要的朋友可以私信"多线程”获取哟</strong></p><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc34a22ea0eb4d9faa75dcc4bba7b74a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9ea306d569a34ccf9e5f4a5588b1f884><p class=pgc-img-caption></p></div><h1><strong>四</strong></h1><ul><li>线程基本方法</li><li>线程上下文切换</li><li>同步锁与死锁</li><li>线程池原理</li><li>java阻塞队列原理</li><li>CyclicBarrier、CountDownLatch、Semaphore 的用法</li><li>volatile 关键字的作用（变量可见性、禁止重排序）</li></ul><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14333a1d18274c27b807cf225f74990b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/321dc6d48803478b823a910c6ce756b4><p class=pgc-img-caption></p></div><h1><strong>五</strong></h1><ul><li>如何在两个线程之间共享数据</li><li>ThreadLocal 作用（线程本地存储）</li><li>synchronized 和 ReentrantLock 的区别</li><li>ConcurrentHashMap 并发</li><li>Java 中用到的线程调度</li></ul><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ad1aa4c7b3b4ea1a45a5fbc14a01a42><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6481da2980a94800bdbead3807cbdb89><p class=pgc-img-caption></p></div><h1><strong>六</strong></h1><ul><li>进程调度算法</li><li>什么是CAS（比较并交换-乐观锁机制-锁自旋）</li><li><strong>什么是 AQS（抽象的队列同步器）【解析】</strong></li></ul><p><strong>什么是 AQS（抽象的队列同步器）【解析】</strong></p><p>AbstractQueuedSynchronizer 类如其名，抽象的队列式的同步器，AQS 定义了一套多线程访问</p><p>共享资源的同步器框架，许多同步类实现都依赖于它，如常用的</p><p>ReentrantLock/Semaphore/CountDownLatch。</p><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9e34eb5b7e545c0b9a0f7b63125620a><p class=pgc-img-caption></p></div><blockquote><p>它维护了一个 volatile int state（代表共享资源）和一个 FIFO 线程等待队列（多线程争用资源被</p><p>阻塞时会进入此队列）。这里 volatile 是核心关键词，具体 volatile 的语义，在此不述。state 的</p><p>访问方式有三种:</p></blockquote><ul><li>getState()</li><li>setState()</li><li>compareAndSetState()</li></ul><p><strong>AQS 定义两种资源共享方式</strong></p><p>Exclusive 独占资源-ReentrantLock</p><p><strong>Exclusive（独占，只有一个线程能执行，如 ReentrantLock）</strong></p><p>Share 共享资源-Semaphore/CountDownLatch</p><p><strong>Share（共享，多个线程可同时执行，如 Semaphore/CountDownLatch）。</strong></p><blockquote><p>AQS 只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现，AQS 这里只定义了一个</p><p>接口，具体资源的获取交由自定义同步器去实现了（通过 state 的 get/set/CAS)之所以没有定义成</p><p>abstract ，是 因 为独 占模 式 下 只 用实现 tryAcquire-tryRelease ，而 共享 模 式 下 只用 实 现</p><p>tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模</p><p>式下的接口。不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实</p><p>现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/</p><p>唤醒出队等），AQS 已经在顶层实现好了。自定义同步器实现时主要实现以下几种方法：</p></blockquote><ol start=1><li>isHeldExclusively()：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li><li>tryAcquire(int)：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li><li>tryRelease(int)：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li><li>tryAcquireShared(int)：共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余</li><li>可用资源；正数表示成功，且有剩余资源。</li><li>tryReleaseShared(int)：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回</li><li>true，否则返回 false。</li></ol><p><strong>同步器的实现是 ABS 核心（state 资源状态计数）（未解析）</strong></p><p><strong>ReentrantReadWriteLock 实现独占和共享两种方式</strong></p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 tryAcquiretryRelease、tryAcquireShared-tryReleaseShared 中的一种即可。但 AQS 也支持自定义同步器</p><p>同时实现独占和共享两种方式，如 ReentrantReadWriteLock。</p><p><strong>更多解析</strong></p><div class=pgc-img><img alt=一篇文让你彻底了解java多线程并发 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f48147a415664750a6ed8de62b604b53><p class=pgc-img-caption></p></div><h1><strong>最后</strong></h1><p>关注小编+转发文章+私信<strong>【多线程】</strong>获取这个PDF资料！谢谢！</p><p>还有更多资料包含Spring，MyBatis，Netty源码分析，高并发、高性能、分布式、微服务架构的原理，JVM性能优化这些成为架构师必备的知识体系。相信对于已经工作和遇到技术瓶颈的码友，在这里会有你需要的内容。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'文让','彻底','了解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>