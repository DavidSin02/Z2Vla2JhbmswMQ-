<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>WebSocket硬核入门：徒手撸WebSocket服务器 | 极客快訊</title><meta property="og:title" content="WebSocket硬核入门：徒手撸WebSocket服务器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/076eaa5654164ae495c20d74874a4100"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/011549b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="WebSocket硬核入门：徒手撸WebSocket服务器"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/011549b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>WebSocket硬核入门：徒手撸WebSocket服务器</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文原题“Node.js - 200 多行代码实现 Websocket 协议”，为了提升内容品质，有较大修订。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1、引言</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">最近正在研究 WebSocket 相关的知识，想着如何能自己实现 WebSocket 协议。到网上搜罗了一番资料后用 Node.js 实现了一个WebSocket协议服务器，倒也没有想象中那么复杂，除去注释语句和 console 语句后，大约 200 行代码左右。</span></p><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/076eaa5654164ae495c20d74874a4100><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文分享了自已开发一个WebSocket服务端实现过程中需要的知识储备，以及具体的代码实现含义等，非常适合想在短时间内对WebSocket协议从入门到精通的Web端即时通讯开发者阅读。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如果你想要写一个WebSocket 服务器，首先需要读懂对应的网络协议 RFC6455，不过这对于一般人来说有些 “晦涩”，英文且不说，还得咬文嚼字理解 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">网络编程</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 含义。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">好在 WebSocket 技术出现比较早，所以早就有人翻译了完整的 RFC6455中文版，网上也有很多针对该协议的剖析文章，很多文章里还有现成的实现代码可以参考，所以说实现一个简单的 WebSocket 服务并非难事。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文更偏向实战（in action），会从知识储备、具体代码分析以及注意事项角度去讲解如何用 Node.js 实现一个简单的 WebSocket 服务，至于 WebSocket 概念、定义、解释和用途等基础知识不会涉及，因为这些知识在本文所列的参考文章中轻松找到。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">友情提示：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文对应的源码，请从文末“11、代码下载”一节下载</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">之</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">学习交流：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">- 开源IM框架源码：https://github.com/JackJiang2011/MobileIMSDK</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（本文同步发布于：http://www.52im.net/thread-3175-1-1.html）</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2、关于作者</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">作者网名：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">JSCON简时空</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">作者微博：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">https://weibo.com/271111536</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">博客地址：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">https://segmentfault.com/u/jscon</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Github主页：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">https://boycgit.github.io/</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3、基本常识</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在学习本文内容之前，我认为很有必要简单了解一下Web端即时通讯技术的“过去”和“现在”，因为新时代的开发者（没有经历过短轮询、长轮询、Comet技术的这波人），很难理解WebSocket对于Web端的即时通讯技术来说，意味着什么。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所谓“忆苦思甜”，了解了Web端即时通讯技术的过去，方知WebSocket这种技术的珍贵。。。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3.1 旧时代的Web端即时通讯技术</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">自从Web端即时通讯的概念提出后，“实时”性便成为了Web开发者们津津乐道的话题。实时化的Web应用，凭借其响应迅速、无需刷新、节省网络流量的特性，不仅让开发者们眼前一亮，更是为用户带来绝佳的网络体验。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">但很多开发者可能并不清楚，旧时代的Web端“实时”通信，主要基于 Ajax的拉取和Comet的推送。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">大家都知道Ajax，这是一种借助浏览器端JavaScript实现的异步无刷新请求功能：要客户端按需向服务器发出请求，并异步获取来自服务器的响应，然后按照逻辑更新当前页面的相应内容。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">但是这仅仅是拉取啊，这并不是真正的“实时”：缺少服务器端的自动推送！</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">因此，我们不得不使用另一种略复杂的技术 Comet，只有当这两者配合起来，这个Web应用才勉强算是个“实时”的Web端应用！</span></p><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/829528f2b3864f0a923a317c3be4bdbe><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">▲ Ajax和Comet技术原理（图片引用自《Web端即时通讯技术盘点》）</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3.2 WebSocket协议出现</span></h1><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/29df5fb17f7f4642a6f81fc7df2c6877><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">随着HTML5标准的出现，WebSocket技术横空出世，随着HTML5标准的广泛普及，越来越多的现代浏览器开始全面支持WebSocket技术了。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">至于WebSocket，我想大家或多或少都听说过。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket是一种全新的协议。它将TCP的Socket（套接字）应用在了web page上，从而使通信双方建立起一个保持在活动状态连接通道，并且属于全双工（双方同时进行双向通信）。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">事实是：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket协议是借用HTTP协议的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">101 switch protocol</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 来达到协议转换的，从HTTP协议切换成WebSocket通信协议。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">再简单点来说，它就好像将 Ajax 和 Comet 技术的特点结合到了一起，只不过性能要高并且使用起来要方便的多（方便当然是之指在客户端方面了）。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4、WebSocket知识储备</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如果要自己写一个 WebSocket 服务，主要有两个难点：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">熟练掌握 WebSocket 的协议，这个需要多读现有的解读类文章（下面会给出参考文章）；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">操作二进制数据流，在 Node.js 中需要对 Buffer 这个类稍微熟悉些。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">同时还需要具备两个基础知识点：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">网络编程中使用 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">大端</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">字节</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">序 </span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">表示大于一字节的数据，称之为 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">网络字节序</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> （不晓得大小端的，推荐阅读《史上最通俗大小端字节序详解》）；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">了解最高有效位（MSB， Most Significant Bit），不太清楚的，可以参考《LSB最低有效位和MSB最高有效位》。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">具体的做法如下，推荐先阅读以下几篇参考文章：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《学习WebSocket协议—从顶层到底层的实现原理（修订版）》：作者本身就用Node.js实现过一遍，知识点讲解挺透彻，适合优先阅读；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《WebSocket详解（一）：初步认识WebSocket技术》：是一系列的文章，从浅入深，配有丰富的图文；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《WebSocket从入门到精通，半小时就够！》：全文以Q&A形式组织，要点都解读到了，还涉及了建立连接、交换数据、帧格式及网络安全等；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《MDN - Writing WebSocket servers》：MDN 官方教程，读一遍没啥坏处。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">然后开始写代码。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在实现过程中的大部分代码可以从下面几篇文章中找到并借鉴（copy）：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">nodejs 实现：简化版本的从这儿借鉴过来的；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">学习WebSocket协议—从顶层到底层的实现原理（修订版）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">阅读完上面的文章，你会有发现一个共同点，就是在实现 WebSockets 过程中，最最核心的部分就是 解析 或者 生成 Frame（帧）。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">就是下面这结构：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0cb38d90b384313ae5792447bd57232><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">▲ 截图来自《rfc6455 - Base Framing Protocol》</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">想要理解 frame 各个字段的含义，可参考《WebSocket详解（三）：深入WebSocket通信协议细节》，文中作者绘制了一副图来解释这个 frame 结构。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而在代码层面，frame 的解析或生成可以在 RocketEngine - parser 或者 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">_processBuffer</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 中找到。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在完成上面几个方面的知识储备之后，而且大多有现成的代码，所以自己边抄边写一个 Websocket 服务端实现并不算太难。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">对于 WebSocket 初学者，请务必阅读以上参考文章，对 Websocket 协议有大概的了解之后再继续本文剩下部分的阅读，否则很有可能会觉得我写得云里雾里，不知所云。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">5、实战效果预览</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本次的实现代码可以从文末“11、代码下载”章节下载到：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（请从原文链接下载：http://www.52im.net/thread-3175-1-1.html）</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">下载后本地运行即可，执行：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">node index.js</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">运行成功后，将会在 http://127.0.0.1:3000 创建服务。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">运行服务之后，打开控制台就能看到效果：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">动图中浏览器 console 所执行的 js 代码步骤如下：</span></strong></p><p style=text-align:start><em><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）先建立连接：</span></strong></em></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var ws = new WebSocket("ws://127.0.0.1:3000");</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.onmessage = function(evt) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">console.log( "Received Message: "+ evt.data);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">};</span></span></p></blockquote><p style=text-align:start><em><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）然后发送消息：</span></strong></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（注意一定要在建立连接之后再执行该语句，否则发不出消息的）</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.send('hello world');</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">从效果可见，我们已经实现 WebSocket 最基本的通讯功能了。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">接下来我们详细看一下具体实现的细节。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">6、代码解读1：调用所写的 WebSocket 类</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">站在使用者的角度，假设我们已经完成 WebSocket 类了，那么应该怎么使用？</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">客户端通过 HTTP Upgrade 请求，即 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">101 Switching Protocol </span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">到 HTTP 服务器，然后由服务器进行协议转换。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在 Node.js 中我们通过 http.createServer 获取 http.server 实例，然后监听 upgrade 事件，在处理这个事件。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如下面的代码所示：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// HTTP服务器部分</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var server = http.createServer(function(req, res) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">res.end('websocket test\r\n');</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// Upgrade请求处理</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">server.on('upgrade', function(req, socket, upgradeHead){</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 初始化 ws</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var ws = new WebSocket(req, socket, upgradeHead);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// ... ws 监听 data、error 的逻辑等</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这里监听 upgrade 事件的回调函数中第二个参数 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 是 net.Socket实例，这个类是 TCP 或 UNIX Socket 的抽象，同时一个 net.Socket 也是一个 duplex stream，所以它能被读或写，并且它也是一个 EventEmitter。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我们就利用这个 socket 对象上进行 Websocket 类实例的初始化工作；</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">7、代码解读2：构造函数</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所以不难理解 Websocket 的构造函数就是下面这个样子：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">class WebSocket extends EventEmitter {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">constructor(req, socket, upgradeHead){</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">super(); // 调用 EventEmitter 构造函数</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 1. 构造响应头 resHeaders 部分</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 2. 监听 socket 的 data 事件，以及 error 事件</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 3. 初始化成员属性</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">注意：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我们需要继承内置的 EventEmitter ，这样生成的实例才能监听、绑定事件。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Node.js 采用事件驱动、异步编程，天生就是为了网络服务而设计的，继承 EventEmitter 就能享受到非阻塞模式的 IO 处理。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这里特别讲一下其中 响应头的构造 和 事件监听 部分。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">7.1 返回响应头（Response Header）</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根据协议规范，我们能写出</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">响应</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">头的内容：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）将 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）通过 SHA1 计算出摘要，并转成 base64 字符串。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">具体代码如下：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var resKey = hashWebSocketKey(req.headers['sec-websocket-key']);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 构造响应头</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var resHeaders = [</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'HTTP/1.1 101 Switching Protocols',</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'Upgrade: websocket',</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'Connection: Upgrade',</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'Sec-WebSocket-Accept: '+ resKey</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">]</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">.concat('', '')</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">.join('\r\n');</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">socket.write(resHeaders);</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">当执行 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket.write(resHeaders);</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 到后就和客户端建立起 WebSocket 连接了，剩下去就是数据的处理。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">7.2 监听事件</span></h1><p style=text-align:start><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 就是 TCP 协议的抽象，直接在上面监听已有的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">data</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 事件和 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">close</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 事件这两个事件。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">还有其他事件，比如 error、end 等，详细参考 net.Socket 文档。</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">socket.on('data', data => {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.buffer = Buffer.concat([this.buffer, data]);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">while(this._processBuffer()) {} // 循环处理返回的 data 数据</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">socket.on('close', had_error => {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">if(!this.closed) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.emit('close', 1006);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.closed = true;</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p></blockquote><p style=text-align:start><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">close</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 的事件逻辑比较简单，比较重要的是 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">data</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 的事件监听部分。核心就是 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">this._processBuffer()</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 这个方法，用于处理客户端传送过来的数据（即 Frame 数据）。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">注意：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">该方法是放在 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">while</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 循环语句里，处理好边界情况，防止死循环。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8、代码解读3：Frame 帧数据的处理</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket 客户端、服务端通信的最小单位是帧（frame），由1个或多个帧组成一条完整的消息（message）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这 this._processBuffer() 部分代码逻辑就是用来解析帧数据的，所以它是实现 WebSocket 代码的关键；（该方法里面用到了大量的位操作符以及 Buffer 类的操作）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">帧数据结构详细定义可参考 RFC6455 5.2节（英文不好的话，去下载中文翻译版《WebSocket标准协议手册（稀缺中文版+英文原版）》），上面罗列的参考文章都有详细的解读，我在这儿也不啰嗦讲细节了，直接看代码比听我用文字讲要好。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这里就其中两个细节需要铺垫一下，方便更好地理解代码。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8.1 操作码（Opcode）</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Opcode 即 操作代码，Opcode 的值决定了应该如何解析后续的数据载荷（data payload）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根据 Opcode 我们可以大致将数据帧分成两大类：数据帧 和 控制帧。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">数据帧，目前只有 3 种，对应的 opcode 是：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x0：数据延续帧</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x1：utf-8文本</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x2：二进制数据；</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x3 - 0x7：目前保留，用于后续定义的非控制帧。</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">控制帧，除了上述 3 种数据帧之外，剩下的都是控制帧：</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x8：表示连接断开</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x9：表示 ping 操作</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0xA：表示 pong 操作</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0xB - 0xF：目前保留，用于后续定义的控制帧</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在代码里，我们会先从帧数据中提取操作码：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var opcode = byte1 & 0x0f; //截取第一个字节的后 4 位，即 opcode 码</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">然后根据协议获取到真正的数据载荷（data payload），然后将这两部分传给 _handleFrame 方法：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this._handleFrame(opcode, payload); // 处理操作码</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8.2 分片（Fragment）</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本节代码对应的标准文档：5.4 - Fragmentation（英文不好的话，去下载中文翻译版《WebSocket标准协议手册（稀缺中文版+英文原版）》）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">一旦 WebSocket 客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。理论上来说，每个帧（Frame）的大小是没有限制的。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">对于大块的数据，WebSocket 协议建议对数据进行分片（Fragment）操作。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">分片的意义主要是两方面：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）主要目的是允许当消息开始但不必缓冲该消息时发送一个未知大小的消息。如果消息不能被分片，那么端点将不得不缓冲整个消息以便在首字节发生之前统计出它的长度。对于分片，服务器或中间件可以选择一个合适大小的缓冲，当缓冲满时，再写一个片段到网络；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）另一方面分片传输也能更高效地利用多路复用提高带宽利用率，一个逻辑通道上的一个大消息独占输出通道是不可取的，因此多路复用需要可以分割消息为更小的分段来更好的共享输出通道。参考文档《I/O多路复用（multiplexing）是什么？》。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket 协议提供的分片方法，是将原本一个大的帧拆分成数个小的帧。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">下面是把一个大的Frame分片的图示：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7073e27315174cf58cbf645cf92fc171><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">由图可知，第一个分片的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">FIN</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 为 0，Opcode 为非0值（0x1 或 0x2），最后一个分片的FIN为1，Opcode为 0。中间分片的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">FIN</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 和 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">opcode</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 二者均为 0。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根据 FIN 的值来判断，是否已经收到消息的最后一个数据帧：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）FIN=1 表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）FIN=0，则接收方还需要继续监听接收其余的数据帧。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">opcode在数据交换的场景下，表示的是数据的类型：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）0x01 表示文本，永远是 utf8 编码的；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）0x02 表示二进制；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）0x00 比较特殊，表示 延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">代码里，我们需要检测 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">FIN</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 的值，如果为 0 说明有分片，需要记录第一个 FIN 为 0 时的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">opcode</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 值，缓存到 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">this.frameOpcode</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 属性中，将载荷缓存到 this.frames 属性中。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8.3 发送数据帧</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">上面讲的都是接收并解析来自客户端的数据帧，当我们想给客户端发送数据帧的时候，也得按协议来。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这部分操作相当于是上述 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">_processBuffer</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 方法的逆向操作，在代码里我们使用 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">encodeMessage</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 方法（为了简单起见，我们发送给客户端的数据没有经过掩码处理）将发送的数据分装成数据帧的格式，然后调用 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket.write</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 方法发送给客户端。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如下所示：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">_doSend(opcode, payload) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 1. 考虑数据分片</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.socket.write(</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">encodeMessage(count > 0 ? OPCODES.CONTINUE : opcode, payload)</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">); //编码后直接通过socket发送</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">为了考虑分片场景，特意设置 MAX_FRAME_SIZE 来对每次发送的数据长度做截断做分片：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// ...</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var len = Buffer.byteLength(payload);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 分片的距离逻辑</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var count = 0;</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 这里可以针对 payload 的长度做分片</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">while(len > MAX_FRAME_SIZE) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var framePayload = payload.slice(0, MAX_FRAME_SIZE);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">payload = payload.slice(MAX_FRAME_SIZE);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.socket.write(</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">encodeMessage(</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">count > 0 ? OPCODES.CONTINUE : opcode,</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">framePayload,</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">false</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">)</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">); //编码后直接通过socket发送</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">count++;</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">len = Buffer.byteLength(payload);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// ...</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">至此已经实现 WebSocket 协议的关键部分，所组装起来的代码就能和客户端建立 WebSocket 连接并进行数据交互了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9、有关WebSocket的常见疑问</span></h1><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9.1 字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 怎么来的？</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这个标志性字符串是专门标示 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 协议的 UUID；UUID 是长度为 16-byte（128-bit）的ID，一般以形如</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">的字符串作为 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">URN</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（Uniform Resource Name，统一资源名称）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">UUID 可以移步到《UUID原理》和 RFC 4122 获取更多知识。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">为啥选择这个字符串？</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在WebSocket标准协议文档的第七页已经有明确的说明了：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/754559c44da14d879029c8d60b4fd59c><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（英文不好的话，见中文翻译版《WebSocket标准协议手册（稀缺中文版+英文原版）》）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">之所以选用这个 UUID ，主要该 ID 极大不太可能被其他不了解 WebSocket 协议的网络终端所使用。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我也不晓得该怎么翻译。总之，就说这个 ID 就相当于 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 协议的 “身份证号” 了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9.2 Websocket 和 HTTP 什么关系？</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">HTTP、WebSocket 等应用层协议，都是基于 TCP 协议来传输数据的，我们可以把这些高级协议理解成对 TCP 的封装。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">既然大家都使用 TCP 协议，那么大家的连接和断开，都要遵循 TCP 协议中的三次握手和四次握手 ，只是在连接之后发送的内容不同，或者是断开的时间不同。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">对于 WebSocket 来说，它必须依赖 HTTP 协议进行一次握手 ，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">更详细的解释，可以移步：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">《WebSocket详解（四）：刨根问底HTTP与WebSocket的关系(上篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">《WebSocket详解（五）：刨根问底HTTP与WebSocket的关系(下篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">《WebSocket详解（六）：刨根问底WebSocket与Socket的关系》</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9.3 浏览器中 Websocket 会自动分片么？</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">答案是：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">看具体浏览器的实现。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket是一个 message based 的协议，它可以自动将数据分片，并且自动将分片的数据组装。每个 message 可以是一个或多个分片。message 不记录长度，分片才记录长度。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根据协议 websocket 协议中帧长度上限为 2^63 byte（为 8388608 TB），可以认为没有限制，很明显按协议的最大上限来传输数据是不靠谱的。所以在实际使用中 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">websocket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 消息长度限制取决于具体的实现。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">关于这方面，找了两篇参考文章：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）《WebSocket需要像TCP Socket那样进行逻辑数据包的分包与合包吗?》：WebSocket是一个message-based的协议，它可以自动将数据分片，并且自动将分片的数据组装；；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）《websocket长文本问题？》：这里给出了长文本 ws 传输实践总结。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在文章《WebSocket探秘》中，作者就做了一个实验，作者发送 27378 个字节，结果被迫分包了；如果是大数据量，就会被socket自动分包发送。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而经过我本人试验，发现 Chrome 浏览器（版本 68.0.3440.106 - 64bit）会针对 131072（=2^17）bytes 大小进行自动分包。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我是通过以下测试代码验证：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var ws = new WebSocket("ws://127.0.0.1:3000");</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.onmessage = function(evt) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">console.log( "Received Message: "+ evt.data);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">};</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var myArray = new ArrayBuffer(131072 * 2 + 1);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.send(myArray);</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">服务端日志：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">server detect fragment, sizeof payload: 131072</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">server detect fragment, sizeof payload: 131072</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">receive data: 2 262145</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">客户端日志：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">Received Message: good job</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">截图如下：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入门：徒手撸WebSocket服务器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/abedfb7c3b0c4c55b55695a03449375c><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而以同样的方式去测试一些自己机器上的浏览器：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）Firefox（62.0，64bit）；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）safari (11.1.2 - 13605.3.8)；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）IE 11。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">这些客户端上的 WebSocket 几乎没有大小的分片（随着数据量增大，发送会减缓，但并没有发现分片现象）。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">10、本文小结</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">从刚开始决定阅读 WebSocket 协议，到自己使用 Node.js 实现一套简单的 WebSocket 协议，到这篇文章的产出，前后耗费大约 1 个月时间（拖延症。。。）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">感谢文中所提及的参考文献所给予的帮助，让我实现过程中事半功倍。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">之所以能够使用较少的代码实现 WebSocket，是因为 Node.js 体系本身了很好的基础，比如其所提供的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">EventEmitter</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 类自带事件循环，http 模块让你直接使用封装好的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 对象，我们只要按照 WebSocket 协议实现 Frame（帧）的解析和组装即可。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在实现一遍 WebSocket 协议后，就能较为深刻地理解以下知识点（一切都是那么自然而然）：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）Websocket 是一种应用层协议，是为了提供 Web 应用程序和服务端</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">全双工通信</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而专门制定的；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）WebSocket 和 HTTP </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">都是基于 TCP 协议实现的</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）WebSocket和 HTTP 的唯一关联就是 HTTP 服务器需要发送一个 “</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Upgrade</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">” 请求，即 101 Switching Protocol 到 HTTP 服务器，然后由服务器进行协议转换。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）WebSocket使用 HTTP 来建立连接，但是定义了一系列新的 header 域，这些域在 HTTP 中并不会使用；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">5）WebSocket 可以和 HTTP Server </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">共享同一 port</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">6）WebSocket 的 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">数据帧有序</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">...</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文仅仅是协议的简单实现，对于 WebSocket 的其实还有很多事情可以做（比如支持 命名空间、流式 API 等），有兴趣的可以参考业界流行的 WebSocket 仓库，去练习锻造一个健壮的 WebSocket 工具库轮子。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">比如下面这些：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）socketio/socket.io：43.5k star，不多说，业界权威龙头老大。（不过这实际上不是一个 WebSocket 库，而是一个实时 pub/sub 框架。简单地说，Socket.IO 只是包含 WebSocket 功能的一个框架，如果要使用该库作为 server 端的服务，则 client 也必须使用该库，因为它不是标准的 WebSocket 协议，而是基于 WebSocket 再包装的消息通信协议）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）websockets/ws：9k star，强大易用的 websocket 服务端、客户端实现，还有提供很多强大的特性</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）uNetworking/uWebSockets：9.5k star，小巧高性能的 WebSocket实现，C++ 写的，想更多了解 WebSocket 的底层实现，该库是不错的案例。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）theturtle32/WebSocket-Node：2.3k star，大部分使用 JavaScript，性能关键部分使用 C++ node-gyp 实现的库。其所列的 测试用例 有挺好的参考价值。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">11、代码下载</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（因无法上传源码附件，如有需要，请从此链接下载：http://www.52im.net/thread-3175-1-1.html）</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">12、参考资料</span></h1><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[1]《新手入门贴：史上最全Web端即时通讯技术原理详解》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[2]《Web端即时通讯技术盘点：短轮询、Comet、Websocket、SSE》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[3]《SSE技术详解：一种全新的HTML5服务器推送事件技术》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[4]《Comet技术详解：基于HTTP长连接的Web端实时通信技术》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[5]《新手快速入门：WebSocket简明教程》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[6]《WebSocket详解（一）：初步认识WebSocket技术》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[7]《WebSocket详解（二）：技术原理、代码演示和应用案例》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[8]《WebSocket详解（三）：深入WebSocket通信协议细节》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[9]《WebSocket详解（四）：刨根问底HTTP与WebSocket的关系(上篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[10]《WebSocket详解（五）：刨根问底HTTP与WebSocket的关系(下篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[11]《WebSocket详解（六）：刨根问底WebSocket与Socket的关系》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[12]《Web端即时通讯技术的发展与WebSocket、Socket.io的技术实践》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[13]《使用WebSocket和SSE技术实现Web端消息推送》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[14]《详解Web端通信方式的演进：从Ajax、JSONP 到 SSE、Websocket》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[15]《MobileIMSDK-Web的网络层框架为何使用的是Socket.io而不是Netty？》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[16]《理论联系实际：从零理解WebSocket的通信原理、协议格式、安全性》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[17]《微信小程序中如何使用WebSocket实现长连接(含完整源码)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[18]《八问WebSocket协议：为你快速解答WebSocket热门疑问》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[19]《Web端即时通讯实践干货：如何让你的WebSocket断网重连更快速？》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[20]《WebSocket从入门到精通，半小时就够！》</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文已同步发布在“即时通讯技术圈”公众号。</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（同步发布链接：</span>http://www.52im.net/thread-3175-1-1.html<span style="color:#404040;--tt-darkmode-color: #A3A3A3">）</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'WebSocket','硬核','入门'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>