<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>模板方法模式，看JDK和Spring是如何优雅复用代码的 | 极客快訊</title><meta property="og:title" content="模板方法模式，看JDK和Spring是如何优雅复用代码的 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e9326cdf61814b6b96f535ed06981f24"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/02e75145.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="模板方法模式，看JDK和Spring是如何优雅复用代码的"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/02e75145.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>模板方法模式，看JDK和Spring是如何优雅复用代码的</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e9326cdf61814b6b96f535ed06981f24><p class=pgc-img-caption></p></div><p>Keeper导读：不管是我们学习并发编程中的 AQS，还是看 Spring 的源码，肯定都会遇到模板方法模式，它简直太常见了。</p><h1 class=pgc-h-arrow-right>前言</h1><p>模板，顾名思义，它是一个固定化、标准化的东西。</p><p>模板方法模式是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。</p><h1 class=pgc-h-arrow-right>场景问题</h1><p>程序员不愿多扯，上来先干两行代码</p><p>网上模板方法的场景示例特别多，个人感觉还是《Head First 设计模式》中的例子比较好。</p><p>假设我们是一家饮品店的师傅，起码需要以下两个手艺</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c20010887dfe44f1abfcc41fb8ef8b54><p class=pgc-img-caption></p></div><p>真简单哈，这么看，步骤大同小异，我的第一反应就是写个业务接口，不同的饮品实现其中的方法就行，像这样</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a58aee8b98e46cbb231875c58d2210a><p class=pgc-img-caption></p></div><p>画完类图，猛地发现，第一步和第三步没什么差别，而且做饮品是个流程式的工作，我希望使用时，直接调用一个方法，就去执行对应的制作步骤。</p><p>灵机一动，不用接口了，用一个抽象父类，把步骤方法放在一个大的流程方法 makingDrinks() 中，且第一步和第三步，完全一样，没必要在子类实现，改进如下</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8e5cd9ca95664878b041aa8799749aa2><p class=pgc-img-caption></p></div><p>再看下我们的设计，感觉还不错，现在用同一个 makingDrinks() 方法来处理咖啡和茶的制作，而且我们不希望子类覆盖这个方法，所以可以申明为 final，不同的制作步骤，我们希望子类来提供，必须在父类申明为抽象方法，而第一步和第三步我们不希望子类重写，所以我们声明为非抽象方法</p><pre><code>public abstract class Drinks {    void boilWater() {        System.out.println("将水煮沸");    }    abstract void brew();    void pourInCup() {        System.out.println("倒入杯子");    }    abstract void addCondiments();        public final void makingDrinks() {        //热水        boilWater();        //冲泡        brew();        //倒进杯子        pourInCup();        //加料        addCondiments();    }}</code></pre><p>接着，我们分别处理咖啡和茶，这两个类只需要继承父类，重写其中的抽象方法即可（实现各自的冲泡和添加调料）</p><pre><code>public class Tea extends Drinks {    @Override    void brew() {        System.out.println("冲茶叶");    }    @Override    void addCondiments() {        System.out.println("加柠檬片");    }}</code></pre><pre><code>public class Coffee extends Drinks {    @Override    void brew() {        System.out.println("冲咖啡粉");    }    @Override    void addCondiments() {        System.out.println("加奶加糖");    }}</code></pre><p>现在可以上岗了，试着制作下咖啡和茶吧</p><pre><code>public static void main(String[] args) {    Drinks coffee = new Coffee();    coffee.makingDrinks();    System.out.println();    Drinks tea = new Tea();    tea.makingDrinks();}</code></pre><p>好嘞，又学会一个设计模式，这就是模板方法模式，我们的 makingDrinks() 就是模板方法。我们可以看到相同的步骤 boilWater() 和 pourInCup() 只在父类中进行即可，不同的步骤放在子类实现。</p><h1 class=pgc-h-arrow-right>认识模板方法</h1><p>在阎宏博士的《JAVA与模式》一书中开头是这样描述模板方法（Template Method）模式的：</p><blockquote><p>模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p></blockquote><p>写代码的一个很重要的思考点就是“变与不变”，程序中哪些功能是可变的，哪些功能是不变的，我们可以把不变的部分抽象出来，进行公共的实现，把变化的部分分离出来，用接口来封装隔离，或用抽象类约束子类行为。模板方法就很好的体现了这一点。</p><p>模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</p><p>模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术，我们再看下类图</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7cf50ba0b51b4356887db970fda8120a><p class=pgc-img-caption></p></div><p>模板方法模式就是用来创建一个算法的模板，这个模板就是方法，该方法将算法定义成一组步骤，其中的任意步骤都可能是抽象的，由子类负责实现。这样可以确保算法的结构保持不变，同时由子类提供部分实现。</p><p>再回顾下我们制作咖啡和茶的例子，有些顾客要不希望咖啡加糖或者不希望茶里加柠檬，我们要改造下模板方法，在加相应的调料之前，问下顾客</p><pre><code>public abstract class Drinks {    void boilWater() {        System.out.println("将水煮沸");    }    abstract void brew();    void pourInCup() {        System.out.println("倒入杯子");    }    abstract void addCondiments();    public final void makingDrinks() {        boilWater();        brew();        pourInCup();        //如果顾客需要，才加料        if (customerLike()) {            addCondiments();        }    }    //定义一个空的缺省方法，只返回 true    boolean customerLike() {        return true;    }}</code></pre><p>如上，我们加了一个逻辑判断，逻辑判断的方法时一个只返回 true 的方法，这个方法我们叫做 钩子方法。</p><blockquote><p>钩子：在模板方法的父类中，我们可以定义一个方法，它默认不做任何事，子类可以视情况要不要覆盖它，该方法称为“钩子”。</p></blockquote><p>钩子方法一般是空的或者有默认实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。而要不要挂钩，又由子类去决定。</p><p>是不是很有用呢，我们再看下咖啡的制作</p><pre><code>public class Coffee extends Drinks {    @Override    void brew() {        System.out.println("冲咖啡粉");    }    @Override    void addCondiments() {        System.out.println("加奶加糖");    }  //覆盖了钩子，提供了自己的询问功能，让用户输入是否需要加料    boolean customerLike() {        String answer = getUserInput();        if (answer.toLowerCase().startsWith("y")) {            return true;        } else {            return false;        }    }    //处理用户的输入    private String getUserInput() {        String answer = null;        System.out.println("您想要加奶加糖吗？输入 YES 或 NO");        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));        try {            answer = reader.readLine();        } catch (IOException e) {            e.printStackTrace();        }        if (answer == null) {            return "no";        }        return answer;    }}</code></pre><p>接着再去测试下代码，看看结果吧。</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/479362bb34734a7bb74a2e8ac665f52d><p class=pgc-img-caption></p></div><p>我想你应该知道钩子的好处了吧，它可以作为条件控制，影响抽象类中的算法流程，当然也可以什么都不做。</p><p>模板方法有很多种实现，有时看起来可能不是我们所谓的“中规中矩”的设计。接下来我们看下 JDK 和 Spring 中是怎么使用模板方法的。</p><h1 class=pgc-h-arrow-right>JDK 中的模板方法</h1><p>我们写代码经常会用到 comparable 比较器来对数组对象进行排序，我们都会实现它的 compareTo() 方法，之后就可以通过 Collections.sort() 或者 Arrays.sort() 方法进行排序了。</p><p>具体的实现类就不写了(可以去 github：starfish-learning 上看我的代码)，看下使用</p><pre><code>@Overridepublic int compareTo(Object o) {    Coffee coffee = (Coffee) o;    if(this.price &lt; (coffee.price)){        return -1;    }else if(this.price == coffee.price){        return 0;    }else{        return 1;    }}</code></pre><pre><code>public static void main(String[] args) {  Coffee[] coffees = {new Coffee("星冰乐",38),                      new Coffee("拿铁",32),                      new Coffee("摩卡",35)};   Arrays.sort(coffees);  for (Coffee coffee1 : coffees) {    System.out.println(coffee1);  }}</code></pre><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d214692222b4bf087da710d78236d2e><p class=pgc-img-caption></p></div><p>你可能会说，这个看着不像我们常规的模板方法，是的。我们看下比较器实现的步骤</p><ol start=1><li>构建对象数组</li><li>通过 Arrays.sort 方法对数组排序，传参为 Comparable 接口的实例</li><li>比较时候会调用我们的实现类的 compareTo() 方法</li><li>将排好序的数组设置进原数组中，排序完成</li></ol><p>一脸懵逼，这个实现竟然也是模板方法。</p><p>这个模式的重点在于提供了一个固定算法框架，并让子类实现某些步骤，虽然使用继承是标准的实现方式，但通过回调来实现，也不能说这就不是模板方法。</p><p>其实并发编程中最常见，也是面试必问的 AQS 就是一个典型的模板方法。</p><h1 class=pgc-h-arrow-right>Spring 中的模板方法</h1><p>Spring 中的设计模式太多了，而且大部分扩展功能都可以看到模板方式模式的影子。</p><p>我们看下 IOC 容器初始化时中的模板方法，不管是 XML 还是注解的方式，对于核心容器启动流程都是一致的。</p><p>AbstractApplicationContext 的 refresh 方法实现了 IOC 容器启动的主要逻辑。</p><p>一个 refresh() 方法包含了好多其他步骤方法，像不像我们说的 模板方法，getBeanFactory() 、refreshBeanFactory() 是子类必须实现的抽象方法，postProcessBeanFactory() 是钩子方法。</p><pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader      implements ConfigurableApplicationContext { @Override public void refresh() throws BeansException, IllegalStateException {  synchronized (this.startupShutdownMonitor) {   prepareRefresh();   ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();   prepareBeanFactory(beanFactory);            postProcessBeanFactory(beanFactory);            invokeBeanFactoryPostProcessors(beanFactory);            registerBeanPostProcessors(beanFactory);            initMessageSource();            initApplicationEventMulticaster();            onRefresh();            registerListeners();            finishBeanFactoryInitialization(beanFactory);            finishRefresh();  } }    // 两个抽象方法    @Override public abstract ConfigurableListableBeanFactory getBeanFactory() throws   IllegalStateException;         protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;        //钩子方法    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } }</code></pre><p>打开你的 IDEA，我们会发现常用的 ClassPathXmlApplicationContext 和 AnnotationConfigApplicationContext 启动入口，都是它的实现类（子类的子类的子类的...）。</p><p>AbstractApplicationContext的一个子类 AbstractRefreshableWebApplicationContext 中有钩子方法 onRefresh()的实现：</p><pre><code>public abstract class AbstractRefreshableWebApplicationContext extends …… {    /**  * Initialize the theme capability.  */ @Override protected void onRefresh() {  this.themeSource = UiApplicationContextUtils.initThemeSource(this); }}</code></pre><p>看下大概的类图：</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何优雅复用代码的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/111c2466c16b4a54b89d41f79ca1e5a4><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>小总结</h1><p>优点：1、封装不变的部分，扩展可变的部分。2、提取公共代码，便于维护。3、行为由父类控制，子类实现。</p><p>缺点：每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p>使用场景：1、有多个子类共有的方法，且逻辑相同。2、重要的、复杂的方法，可以考虑作为模板方法。</p><p>注意事项：为防止恶意操作，一般模板方法都加上 final 关键词。</p><h1 class=pgc-h-arrow-right>参考：</h1><p>《Head First 设计模式》、《研磨设计模式》</p><p>https://sourcemaking.com/design_patterns/template_method</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JDK','Spring','优雅'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>