<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>CSS元素选择器是怎样运作的？ | 极客快訊</title><meta property="og:title" content="CSS元素选择器是怎样运作的？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/78af7e85c1ad4bdb9f246a299c805beb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0311d0b8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0311d0b8.html><meta property="article:published_time" content="2020-10-29T21:09:59+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:59+08:00"><meta name=Keywords content><meta name=description content="CSS元素选择器是怎样运作的？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0311d0b8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>CSS元素选择器是怎样运作的？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=CSS元素选择器是怎样运作的？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/78af7e85c1ad4bdb9f246a299c805beb><p class=pgc-img-caption></p></div><p style=text-align:start>来源:微信公众号:前端先锋</p><p>作者:疯狂的技术宅</p><p>出处:https://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&mid=2247494653&idx=1&sn=7fde154e105ae345326a1caf6d490eee</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在前端工程师的日常工作中，使用 CSS 元素选择器是稀松平常的事；无论你是编写一般的 CSS 还是需要经过编译的 SASS，SCSS，LESS等，最终都被编译成一行一行的 CSS 样式属性，最终交给浏览器解析并套用。但是你想过没有这是如何实现的呢？</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器渲染</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我们先看一下浏览器的渲染步骤：</span></p><div class=pgc-img><img alt=CSS元素选择器是怎样运作的？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b34bef6af1e5449ab5bd139d3c299c31><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">CSS 在被浏览器加载后，会被解析成 CSSOM 树，并尝试与 Dom 叠加成渲染树，随后进行计算位置、渲染等步骤。这样看来，CSS 属性套用的关键就在于如何从 CSS 转化成 CSSOM 树，以及怎么把 CSSOM 套用到 DOM 上去。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">CSSOM树</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">当我们写下一组 CSS 样式时，例如：</span></p><pre><code>#id .class h4 + p {   ...}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器在解析它时，你可能会认为 CSS 会按照由左到右的依序找出 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">＃id</span> > <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.class</span> > <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">h4</span> > <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">p</span> ，最后套用，但实际上 <strong>浏览器解析 CSS 的顺序是由右到左</strong> 的 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">p</span> > <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">h4</span> > <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.class</span> > <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">＃id</span> 。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">很违背直觉对吧？但如果考虑到性能问题，从右到左的解析会比从左到右强很多。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">假设这有这样的 HTML：</span></p><pre><code>&lt;div id="div1"&gt;    &lt;div class="a"&gt;        &lt;div class="b"&gt;            ...        &lt;/div&gt;        &lt;div class="c"&gt;            &lt;div class="d"&gt;                ...            &lt;/div&gt;            &lt;div class="e"&gt;                ...            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;div class="f"&gt;        &lt;div class="c"&gt;            &lt;div class="d"&gt;                ...            &lt;/div&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">以及这边五条 CSS 样式规则：</span></p><pre><code>#div1 .c .d {}.f .c .d {}.a .c .e {}#div1 .f {}.c .d {}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">让我们模拟一下，如果把 CSS 从左到右解析，将会生成类似这样的 CSSOM 树：</span></p><div class=pgc-img><img alt=CSS元素选择器是怎样运作的？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d979d9b2f7848fe83090f5d8755b0da><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">通过 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">&lt;div class =“ d”></span> 中的 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.d</span> 来思考，这样的 CSSOM 树在套用样式时，必须对 <strong>所有</strong> 的样式规则进行检查，以确认样式规则是否会影响到 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.d</span> ，到最后才能确定可能会影响到 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.d</span> 的样式规则有这三条：</p><ul><li><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">＃div1 .c .d</span></li><li><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.f .c .d</span></li><li><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.c .d</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">以此类推，每个 DOM 树上的元素，都必须便利所有的样式规则，才可以取得个别的样式，这样会造成大量冗余的计算，进而严重影响性能。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">反过来，如果将前面的 CSS 由右到左进行解析，CSSOM 树则可能会如下：</span></p><div class=pgc-img><img alt=CSS元素选择器是怎样运作的？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f00b265f8c18446cba703f627a8d78fc><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">和前面的例子一样，从 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">&lt;div class =“ d”></span> 中 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.d</span> 的角度来看，由于会被样式规则影响到的目标元素，已经全都集中在第一层了，所以就不用再去便利整个 CSSOM 树了，甚至只需要检查 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.d</span> 以下的子属性变量是否符合实际 DOM 结构，再将所有符合的样式规则重新取回，便能完成 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.d</span> 对元素的样式规则套用。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">从右到左的解析顺序能够将所有共享的规则路径收拢在一起，当浏览器进行属性比对时，就不用再便利整个 CSSOM 树，大大的减少了无效的比对计算。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">也可以换个方式思考：在 HTML 的结构中，一个元素可以有无数个子元素，但只能有一个父元素，由子找父（由下往上）搜寻绝对是比较快的。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">套用样式</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">将 CSSOM 树解析出来之后就能够和 DOM 结合了吗？如果真的有这么简单就太好了。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">除了开发者定义好的 CSS </span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">档外</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">，还有几个地方可能会定义样式规则，影响画面的渲染：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">HTML 的 inline style 设置</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器预设值（就是 CSS reset/normalize 要覆盖掉的东西）</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器的使用者偏好设定</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器负责处理 CSS 的部分，会</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">吧</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">前面所有的东西以及 CSS 文件定义的样式规则分别整理成单独的样式规则组（CSS 规则集），内容记载了样式规则、目标属性等信息。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">目标属性</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">为了提升后面的计算效率，浏览器的 CSS 处理内核会按照样式规则组中个别规则的目标属性将其分组存放；一共分为以下四组</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">idRules</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">classRules</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">tagNameRules</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">universalRules</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">这样在取用时，可以依据目标元素是否存在这个属性，快速筛出可能会套用的样式。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">套用规则</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最后是套用规则。浏览器会遵循以下顺序和样式规则权重套用所有的样式规则：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器的预设值</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">浏览器的使用者偏好设定</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">开发者定义的 CSS</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">inline style</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">加上 !important 的样式属性</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">你可能会好奇：为什么 inline style 和开发者定义的 CSS 会被另外处理？</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我们可以回顾一下浏览器渲染的步骤，由于 inline style 存在于 DOM 元素中，只能在 CSS 套用到 DOM 上时才会接触到，事前无法将两者结合。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">CSS 效率</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">实际上浏览器在这里已经完成了优化机制；浏览器会自动将状态一致的元素做样式快照。状态一致就是要满足以下几个条件：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">没有设定 ID</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">tag 及 class 必须完全一致</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">没有设定 style 属性</span></li><li><span style="color:#444;--tt-darkmode-color: #A2A2A2"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">〜 + </span></span><span style="color:#bc6060;--tt-darkmode-color: #BC6060"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">:first-child</span></span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">由于上面的条件，以及前面讨论到的 CSS 运算过程，编写 CSS 时也有几个地方可以稍微留心一下：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">由于样式规则的目标属性会分组存放，id 选择器效率非常高，所以是不能与其他条件混用的。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">不要写过深的 CSS 样式规则</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">能不用 inline style 就不要用，除了难以维护外，由于是存在于 DOM 树上，无法预先与其他样式合并计算，所以效率也会大打折扣</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">如果能够注意到这类典型的小细节，CSS 效率自然也可以大幅提升。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">认识了 CSS 选择器之后，你一定会很好奇，JavaScript 的元素选择器又是怎么回事呢？这个问题可以参考 jQuery 的源码(https://github.com/jquery/jquery/blob/master/src/selector.js#L157)，它是由左到右的解析，至为什么为什么不一样，其实在文中也有答案，就留给你思考挖掘吧。</span></p><p>来源:微信公众号:前端先锋</p><p>作者:疯狂的技术宅</p><p>出处:https://mp.weixin.qq.com/s?__biz=MzI3NzIzMDY0NA==&mid=2247494653&idx=1&sn=7fde154e105ae345326a1caf6d490eee</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'CSS','选择器','怎样'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>