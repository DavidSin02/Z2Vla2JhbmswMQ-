<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一篇文章搞懂Python面向对象之继承 | 极客快訊</title><meta property="og:title" content="一篇文章搞懂Python面向对象之继承 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/040363228a6a40b3bef7e33dd6eae446"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/059e950.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><meta property="article:published_time" content="2020-10-29T20:45:52+08:00"><meta property="article:modified_time" content="2020-10-29T20:45:52+08:00"><meta name=Keywords content><meta name=description content="一篇文章搞懂Python面向对象之继承"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/059e950.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一篇文章搞懂Python面向对象之继承</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=Editable-styled><strong>继承</strong></h2><p>　　定义：继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类</p><p>　　PS：Python中类的继承分为：单继承和多继承</p><pre><code>class ParentClass1: #定义父类    passclass ParentClass2: #定义父类    passclass SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass    passclass SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类    pass</code></pre><p><strong>查看继承</strong></p><pre><code>&gt;&gt;&gt; SubClass1.__bases__ #__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类(&lt;class '__main__.ParentClass1'&gt;,)&gt;&gt;&gt; SubClass2.__bases__(&lt;class '__main__.ParentClass1'&gt;, &lt;class '__main__.ParentClass2'&gt;)</code></pre><p>提示：如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法（如__str__）的实现。</p><pre><code>&gt;&gt;&gt; ParentClass1.__bases__(&lt;class 'object'&gt;,)&gt;&gt;&gt; ParentClass2.__bases__(&lt;class 'object'&gt;,)</code></pre><p><strong>继承与抽象</strong></p><ul><li>抽象即抽取类似或者说比较像的部分。</li><li>抽象分成两个层次：</li><li>将奥巴马和梅西这俩对象比较像的部分抽取成类；</li><li>将人，猪，狗这三个类比较像的部分抽取成父类。</li></ul><p>抽象最主要的作用是划分类别（可以隔离关注点，降低复杂度）</p><div class=pgc-img><img alt=一篇文章搞懂Python面向对象之继承 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/040363228a6a40b3bef7e33dd6eae446><p class=pgc-img-caption></p></div><p><strong>继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。</strong></p><p>抽象只是分析和设计的过程中，一个动作或者说一种技巧，通过抽象可以得到类</p><div class=pgc-img><img alt=一篇文章搞懂Python面向对象之继承 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/8839745dfe974f0bba19154347b0cefa><p class=pgc-img-caption></p></div><p><strong>继承与重用性</strong></p><p>使用继承来解决代码重用的例子</p><pre><code>==========================第一部分例如　　猫可以：喵喵叫、吃、喝、拉、撒　　狗可以：汪汪叫、吃、喝、拉、撒如果我们要分别为猫和狗创建一个类，那么就需要为 猫 和 狗 实现他们所有的功能，伪代码如下： #猫和狗有大量相同的内容class 猫：    def 喵喵叫(self):        print '喵喵叫'    def 吃(self):        # do something    def 喝(self):        # do something    def 拉(self):        # do something    def 撒(self):        # do somethingclass 狗：    def 汪汪叫(self):        print '汪汪叫'    def 吃(self):        # do something    def 喝(self):        # do something    def 拉(self):        # do something    def 撒(self):        # do something==========================第二部分上述代码不难看出，吃、喝、拉、撒是猫和狗都具有的功能，而我们却分别的猫和狗的类中编写了两次。如果使用 继承 的思想，如下实现：　　动物：吃、喝、拉、撒　　   猫：喵喵叫（猫继承动物的功能）　　   狗：汪汪叫（狗继承动物的功能）伪代码如下：class 动物:    def 吃(self):        # do something    def 喝(self):        # do something    def 拉(self):        # do something    def 撒(self):        # do something# 在类后面括号中写入另外一个类名，表示当前类继承另外一个类class 猫(动物)：    def 喵喵叫(self):        print '喵喵叫'        # 在类后面括号中写入另外一个类名，表示当前类继承另外一个类class 狗(动物)：    def 汪汪叫(self):        print '汪汪叫'==========================第三部分#继承的代码实现class Animal:    def eat(self):        print("%s 吃 " %self.name)    def drink(self):        print ("%s 喝 " %self.name)    def shit(self):        print ("%s 拉 " %self.name)    def pee(self):        print ("%s 撒 " %self.name)class Cat(Animal):    def __init__(self, name):        self.name = name        self.breed = '猫'    def cry(self):        print('喵喵叫')class Dog(Animal):    def __init__(self, name):        self.name = name        self.breed='狗'    def cry(self):        print('汪汪叫')# ######### 执行 #########c1 = Cat('小白家的小黑猫')c1.eat()c2 = Cat('小黑的小白猫')c2.drink()d1 = Dog('胖子家的小瘦狗')d1.eat()使用继承来重用代码比较好的例子</code></pre><p><strong>在开发程序的过程中，如果定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时</strong></p><p><strong>我们不可能从头开始写一个类B，这就用到了类的继承的概念。</strong></p><p><strong>通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用</strong></p><pre><code>class Animal:    '''    人和狗都是动物，所以创造一个Animal基类    '''    def __init__(self, name, aggressivity, life_value):        self.name = name  # 人和狗都有自己的暱称;        self.aggressivity = aggressivity  # 人和狗都有自己的攻击力;        self.life_value = life_value  # 人和狗都有自己的生命值;    def eat(self):        print('%s is eating'%self.name)class Dog(Animal):    passclass Person(Animal):    passkum= Person('kum',10,1000)ha2 = Dog('二愣子',50,1000)kum.eat()ha2.eat()</code></pre><p>提示：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大省了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大.</p><p><strong>派生</strong></p><p>当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。</p><pre><code>class Animal:    '''    人和狗都是动物，所以创造一个Animal基类    '''    def __init__(self, name, aggressivity, life_value):        self.name = name  # 人和狗都有自己的暱称;        self.aggressivity = aggressivity  # 人和狗都有自己的攻击力;        self.life_value = life_value  # 人和狗都有自己的生命值;    def eat(self):        print('%s is eating'%self.name)class Dog(Animal):    '''    狗类，继承Animal类    '''    def bite(self, people):        '''        派生：狗有咬人的技能        :param people:        '''        people.life_value -= self.aggressivityclass Person(Animal):    '''    人类，继承Animal    '''    def attack(self, dog):        '''        派生：人有攻击的技能        :param dog:        '''        dog.life_value -= self.aggressivitykum= Person('kum',10,1000)ha2 = Dog('二愣子',50,1000)print(ha2.life_value)print(kum.attack(ha2))print(ha2.life_value)</code></pre><p>注意：像ha2.life_value之类的属性引用，会先从实例中找life_value然后去类中找，然后再去父类中找...直到最顶级的父类。</p><p>　　在子类中，新建的重名的函数属性，在编辑函数内功能的时候，有可能需要重用父类中重名的那个函数功能，应该是用调用普通函数的方式，即：类名.func()，此时就与调用普通函数无异了，因此即便是self参数也要为其传值.</p><p>　　在python3中，子类执行父类的方法也可以直接用super方法.</p><p><strong>super</strong></p><pre><code>class A:    def hahaha(self):        print('A')class B(A):    def hahaha(self):        super().hahaha()        #super(B,self).hahaha()        #A.hahaha(self)        print('B')a = A()b = B()b.hahaha()super(B,b).hahaha()</code></pre><p><br></p><pre><code>class Animal:    '''    人和狗都是动物，所以创造一个Animal基类    '''    def __init__(self, name, aggressivity, life_value):        self.name = name  # 人和狗都有自己的暱称;        self.aggressivity = aggressivity  # 人和狗都有自己的攻击力;        self.life_value = life_value  # 人和狗都有自己的生命值;    def eat(self):        print('%s is eating'%self.name)class Dog(Animal):    '''    狗类，继承Animal类    '''    def __init__(self,name,breed,aggressivity,life_value):        super().__init__(name, aggressivity, life_value) #执行父类Animal的init方法        self.breed = breed  #派生出了新的属性    def bite(self, people):        '''        派生出了新的技能：狗有咬人的技能        :param people:        '''        people.life_value -= self.aggressivity    def eat(self):        # Animal.eat(self)        #super().eat()        print('from Dog')class Person(Animal):    '''    人类，继承Animal    '''    def __init__(self,name,aggressivity, life_value,money):        #Animal.__init__(self, name, aggressivity, life_value)        #super(Person, self).__init__(name, aggressivity, life_value)        super().__init__(name,aggressivity, life_value)  #执行父类的init方法        self.money = money   #派生出了新的属性    def attack(self, dog):        '''        派生出了新的技能：人有攻击的技能        :param dog:        '''        dog.life_value -= self.aggressivity    def eat(self):        #super().eat()        Animal.eat(self)        print('from Person')kum = Person('kum',10,1000,600)ha2 = Dog('二愣子','哈士奇',10,1000)print(kum.name)print(ha2.name)kum.eat()</code></pre><p><strong>通过继承建立了派生类与基类之间的关系，它是一种'是'的关系，比如白马是马，人是动物。</strong></p><p><strong>当类之间有很多相同的功能，提取这些共同的功能做成基类，用继承比较好，比如教授是老师</strong></p><pre><code>&gt;&gt;&gt; class Teacher:...     def __init__(self,name,gender):...         self.name=name...         self.gender=gender...     def teach(self):...         print('teaching')... &gt;&gt;&gt; &gt;&gt;&gt; class Professor(Teacher):...     pass... &gt;&gt;&gt; p1=Professor('kum','run')&gt;&gt;&gt; p1.teach()teaching</code></pre><h3 class=Editable-styled><strong>抽象类与接口类</strong></h3><h3 class=Editable-styled><strong>接口类</strong></h3><p>　　继承有两种用途：</p><p>　　一：继承基类的方法，并且做出自己的改变或者扩展（代码重用）</p><p>　　二：声明某个子类兼容于某基类，定义一个接口类Interface，接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能</p><pre><code>class Alipay:    '''    支付宝支付    '''    def pay(self,money):        print('支付宝支付了%s元'%money)class Applepay:    '''    apple pay支付    '''    def pay(self,money):        print('apple pay支付了%s元'%money)def pay(payment,money):    '''    支付函数，总体负责支付    对应支付的对象和要支付的金额    '''    payment.pay(money)p = Alipay()pay(p,200)</code></pre><p><strong>开发中容易出现的问题</strong></p><pre><code>class Alipay:    '''    支付宝支付    '''    def pay(self,money):        print('支付宝支付了%s元'%money)class Applepay:    '''    apple pay支付    '''    def pay(self,money):        print('apple pay支付了%s元'%money)class Wechatpay:    def fuqian(self,money):        '''        实现了pay的功能，但是名字不一样        '''        print('微信支付了%s元'%money)def pay(payment,money):    '''    支付函数，总体负责支付    对应支付的对象和要支付的金额    '''    payment.pay(money)p = Wechatpay()pay(p,200)   #执行会报错</code></pre><p><strong>接口初成：手动报异常：NotImplementedError来解决开发中遇到的问题</strong></p><pre><code>class Payment:    def pay(self):        raise NotImplementedErrorclass Wechatpay(Payment):    def fuqian(self,money):        print('微信支付了%s元'%money)p = Wechatpay()  #这里不报错pay(p,200)      #这里报错了</code></pre><p><strong>借用abc模块来实现接口</strong></p><pre><code>from abc import ABCMeta,abstractmethodclass Payment(metaclass=ABCMeta):    @abstractmethod    def pay(self,money):        passclass Wechatpay(Payment):    def fuqian(self,money):        print('微信支付了%s元'%money)p = Wechatpay() #不调就报错了</code></pre><p>实践中，继承的第一种含义意义并不很大，甚至常常是有害的。因为它使得子类与基类出现强耦合。</p><p>　　继承的第二种含义非常重要。它又叫“接口继承”。 　　接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。</p><p>　　归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。</p><p><strong>依赖倒置原则</strong> 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程</p><p>为什么用接口</p><p>接口提取了一群类共同的函数，可以把接口当做一个函数的集合。</p><p>然后让子类去实现接口中的函数。</p><p>这么做的意义在于归一化，什么叫归一化，就是只要是基于同一个接口实现的类，那么所有的这些类产生的对象在使用时，从用法上来说都一样。</p><p>归一化，让使用者无需关心对象的类是什么，只需要的知道这些对象都具备某些功能就可以了，这极大地降低了使用者的使用难度。</p><p>比如：我们定义一个动物接口，接口里定义了有跑、吃、呼吸等接口函数，这样老鼠的类去实现了该接口，松鼠的类也去实现了该接口，由二者分别产生一只老鼠和一只松鼠送到你面前，即便是你分别不到底哪只是什么鼠你肯定知道他俩都会跑，都会吃，都能呼吸。</p><p>再比如：我们有一个汽车接口，里面定义了汽车所有的功能，然后由本田汽车的类，奥迪汽车的类，大众汽车的类，他们都实现了汽车接口，这样就好办了，大家只需要学会了怎么开汽车，那么无论是本田，还是奥迪，还是大众我们都会开了，开的时候根本无需关心我开的是哪一类车，操作手法（函数调用）都一样</p><p><strong>抽象类</strong></p><p><strong>什么是抽象类</strong></p><p>与java一样，python也有抽象类的概念但是同样需要借助模块实现，<strong>抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化</strong></p><p><strong>为什么要有抽象类</strong></p><p>如果说<strong>类是从</strong>一堆<strong>对象</strong>中抽取相同的内容而来的，那么<strong>抽象类</strong>就<strong>是从</strong>一堆<strong>类</strong>中抽取相同的内容而来的，内容包括数据属性和函数属性。</p><p>　 比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西。</p><p>从设计角度去看，如果类是从现实对象抽象而来的，那么抽象类就是基于类抽象而来的。</p><p>　 从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案</p><p><strong>在python中实现抽象类</strong></p><pre><code>#一切皆文件import abc #利用abc模块实现抽象类class All_file(metaclass=abc.ABCMeta):    all_type='file'    @abc.abstractmethod #定义抽象方法，无需实现功能    def read(self):        '子类必须定义读功能'        pass    @abc.abstractmethod #定义抽象方法，无需实现功能    def write(self):        '子类必须定义写功能'        pass# class Txt(All_file):#     pass## t1=Txt() #报错,子类没有定义抽象方法class Txt(All_file): #子类继承抽象类，但是必须定义read和write方法    def read(self):        print('文本数据的读取方法')    def write(self):        print('文本数据的读取方法')class Sata(All_file): #子类继承抽象类，但是必须定义read和write方法    def read(self):        print('硬盘数据的读取方法')    def write(self):        print('硬盘数据的读取方法')class Process(All_file): #子类继承抽象类，但是必须定义read和write方法    def read(self):        print('进程数据的读取方法')    def write(self):        print('进程数据的读取方法')wenbenwenjian=Txt()yingpanwenjian=Sata()jinchengwenjian=Process()#这样大家都是被归一化了,也就是一切皆文件的思想wenbenwenjian.read()yingpanwenjian.write()jinchengwenjian.read()print(wenbenwenjian.all_type)print(yingpanwenjian.all_type)print(jinchengwenjian.all_type)</code></pre><h3 class=Editable-styled><strong>抽象类与接口类</strong></h3><p>　　抽象类的本质还是类，指的是一组类的相似性，包括数据属性（如all_type）和函数属性（如read、write），而接口只强调函数属性的相似性。</p><p><strong>　　抽象类是一个介于类和接口直接的一个概念，同时具备类和接口的部分特性，可以用来实现归一化设计</strong></p><p>python中，并没有接口类这种东西，即便不通过专门的模块定义接口，也应该有一些基本的概念。</p><h3 class=Editable-styled><strong>多继承问题</strong></h3><p>　　在继承抽象类的过程中，应该尽量避免多继承； 　　而在继承接口的时候，反而鼓励你来多继承接口</p><p><strong>接口隔离原则</strong> 使用多个专门的接口，而不使用单一的总接口。即客户端不应该依赖那些不需要的接口。</p><h3 class=Editable-styled><strong>方法的实现</strong></h3><p>　　在抽象类中，我们可以对一些抽象方法做出基础实现； 　　而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现</p><h2 class=Editable-styled><strong>PS:钻石继承</strong></h2><h3 class=Editable-styled><strong>　　继承顺序</strong></h3><div class=pgc-img><img alt=一篇文章搞懂Python面向对象之继承 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c2183ac6155847a89de38341f1de10c2><p class=pgc-img-caption></p></div><pre><code>class A(object):    def test(self):        print('from A')class B(A):    def test(self):        print('from B')class C(A):    def test(self):        print('from C')class D(B):    def test(self):        print('from D')class E(C):    def test(self):        print('from E')class F(D,E):    # def test(self):    #     print('from F')    passf1=F()f1.test()print(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性#新式类继承顺序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A#经典类继承顺序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C#python3中统一都是新式类#pyhon2中才分新式类与经典类</code></pre><h3 class=Editable-styled><strong>继承原理</strong></h3><p>　　python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如</p><pre><code>&gt;&gt;&gt; F.mro() #等同于F.__mro__[&lt;class '__main__.F'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</code></pre><p>为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。</p><p>　　而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:</p><p>　　1.子类会先于父类被检查</p><p>　　2.多个父类会根据它们在列表中的顺序被检查</p><p>　　3.如果对下一个类存在两个合法的选择,选择第一个父类</p><p><strong>小结</strong></p><p><strong>继承作用</strong></p><p>减少代码的重用 提高代码可读性 规范编程模式</p><p><strong>继承中的名词</strong></p><p>抽象：抽象即抽取类似或者说比较像的部分。是一个从具体到抽象的过程。 继承：子类继承了父类的方法和属性 派生：子类在父类方法和属性的基础上产生了新的方法和属性</p><p><strong>抽象类与接口类</strong></p><p><strong>1.多继承问题</strong></p><p><strong>在继承抽象类的过程中，我们应该尽量避免多继承；</strong></p><p><strong>而在继承接口的时候，我们反而鼓励你来多继承接口</strong></p><p><strong>2.方法的实现</strong></p><p><strong>在抽象类中，我们可以对一些抽象方法做出基础实现；</strong></p><p><strong>而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现</strong></p><p><strong>钻石继承</strong></p><p>新式类：广度优先 经典类：深度优先</p><p><a class=tteditor-forum data-concern-id=6213177300943374850 data-id=1610484374233096 data-name=Python data-uid>#Python#</a><a class=tteditor-forum data-concern-id=1644255406355470 data-id=1644255406355470 data-name=Python入门推荐 data-uid>#Python入门推荐#</a><a class=tteditor-forum data-concern-id=6213176896532777473 data-id=1610484249379918 data-name=面向对象程序编程 data-uid>#面向对象程序编程#</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'搞懂','Python','对象'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>