<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MySQL5.7事务提交过程以及无损复制源码解析-爱可生 | 极客快訊</title><meta property="og:title" content="MySQL5.7事务提交过程以及无损复制源码解析-爱可生 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f166615b238b45c3b2ad8b0877ec6845"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05bb30f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05bb30f.html><meta property="article:published_time" content="2020-10-29T20:50:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:41+08:00"><meta name=Keywords content><meta name=description content="MySQL5.7事务提交过程以及无损复制源码解析-爱可生"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/05bb30f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MySQL5.7事务提交过程以及无损复制源码解析-爱可生</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>大家都知道在mysql中，在事务真正commit之前，会将事务的binlog日志写入到binlog 文件中，在mysql的5.7版本中，提供了所谓的无损复制的功能，该功能作用--就是在主库的事务对其他的会话线程可见之前，就将该事务的日志同步到从库，保证了事务可以安全地无丢失地复制到从库。</p><p>下面我们从源码来分析mysql的事务提交以及事务在何时将binlog复制到从库的。</p><p>MYSQL_BIN_LOG::ordered_commit，这个是事务在binlog阶段提交的核心函数，通过该函数，实现了事务日志写入binlog文件，以及触发dump线程将binlog发送到slave，在最后的步骤，将事务设置为提交状态。</p><p>我们来分析MYSQL_BIN_LOG::ordered_commit这个函数的核心过程，该函数位于binlog.cc文件中。</p><ol start=1><li><strong>源码解析</strong></li></ol><p>MYSQL_BIN_LOG::ordered_commit，这个函数，核心步骤如下：</p><p><br></p><h2 class=pgc-h-arrow-right>1.1 <strong>第一步骤：flush</strong></h2><p>Stage#1: flushing transactions to binary log:</p><p>步骤1 ：将事务的日志写入binlog文件的buffer中，函数如下：</p><p>process_flush_stage_queue(&total_bytes,&do_rotate, &wait_queue);</p><p><br></p><p>从5.6开始，mysql引入了group commit 的概念，这样可以避免每个事务提交都会锁定一次binlog.另外，还有一个用处，就是mysql的5.7的基于logical_clock的并行复制。在一个组里面（其实是一个队列），这一组队列的头事务是相同的，因此这一组事务的last_committed（上一组的最后一个提交的事务）的事务也是同一个。我们都知道，last_committed相同的事务，是可以在从库并行relay（重演）的。该函数process_flush_stage_queue的作用，就是将commit队列中的线程一个一个的取出，然后执行子函数 flush_thread_caches(head);循环的代码如下：将各自线程中的binlog cache写入到binlog中。</p><p>/* Flush thread caches to binary log. */</p><p>for (THD *head= first_seen ; head ; head = head->next_to_commit)</p><p>{</p><p>std::pair&lt;int,my_off_t>result= flush_thread_caches(head);</p><p>total_bytes+= result.second;</p><p>if(flush_error == 1)</p><p>flush_error= result.first;</p><p>#ifndef DBUG_OFF</p><p>no_flushes++;</p><p>#endif</p><p>}</p><p><br></p><h2 class=pgc-h-arrow-right>1.2 <strong>第二步骤SYNC to disk</strong></h2><p>Stage#2: Syncing binary log file to disk</p><p>第二步：将binlog file中cache的部分写入disk.但这个步骤参数sync_binlog起决定性的作用。</p><p>我们来看看源码，除了这些还有哪些细节步骤，听完源码分析之后，你应该有新的收获与理解。</p><p>在执行真正的将binlog写到磁盘之前，会进行一个等待，函数如下：</p><p>stage_manager.wait_count_or_timeout(opt_binlog_group_commit_sync_no_delay_count,</p><p>opt_binlog_group_commit_sync_delay,</p><p>Stage_manager::SYNC_STAGE);</p><p>等待的时间由mysql参数文件中的binlog_group_commit_sync_delay，binlog_group_commit_sync_no_delay_count 这两参数共同决定，第一个表示该事务组提交之前总共等待累积到多少个事务，第二个参数则表示该事务组总共等待多长时间后进行提交，任何一个条件满足则进行后续操作。因为有这个等待，可以让更多事务的binlog通过一次写binlog文件磁盘来完成提交，从而获得更高的吞吐量。</p><p><br></p><p>接下来，就是执行sync_binlog_file，该函数会用到mysql参数文件中sync_binlog参数的值，如果为0，则不进行写磁盘操作，由操作系统决定什么时候刷盘，如果为1，则强制进行写磁盘操作。</p><p><br></p><p>再接下来，执行update_binlog_end_pos函数，用来更新binlog文件的最后的位置binlog_end_pos，该binlog_end_pos是一个全局的变量。在执行更新该位置之前，先得找到最后一个提交事务的线程（因为是group commit,多个事务排队提交的机制）。因为已经将要提交事务的线程组成了一个链表，通过从头到尾找，可以找到最后一个线程。代码如下：</p><p><br></p><p>if(update_binlog_end_pos_after_sync)</p><p>{</p><p>THD*tmp_thd= final_queue;</p><p><br></p><p>while(tmp_thd->next_to_commit != NULL)</p><p>tmp_thd= tmp_thd->next_to_commit;</p><p><br></p><p>update_binlog_end_pos(tmp_thd->get_trans_pos());</p><p>}</p><p><br></p><p>接下来，我们来看一下这个函数update_binlog_end_pos，这个函数很简单，传入一个pos,然后将其赋值给全局变量binlog_end_pos，接下来就是最核心的一行代码，signal_update()，发送binlog更新的信号，因此从主库同步binlog到从库的dump线程，会接收到这个binlog已有更新的信号，然后启动dump binlog的流程。</p><p>函数update_binlog_end_pos的完整代码如下。</p><p>void update_binlog_end_pos(my_off_tpos)</p><p>{</p><p>lock_binlog_end_pos();</p><p>if (pos >binlog_end_pos)</p><p>binlog_end_pos= pos;</p><p>signal_update();</p><p>unlock_binlog_end_pos();</p><p>}</p><h2 class=pgc-h-arrow-right>1.3 <strong>semisync</strong></h2><p>通过上面的步骤介绍，我们看到，在binlog文件的最新位置更新的时候，就已经通过signal_update函数发送信号给binlog的dump线程，该线程就可以将事务的binlog同步到从库，从库接收到日志之后，就可以relay日志，实现了主从同步。因此，再次重复说明一下，按照上面的解释，在事务真正提交完成之前就开始发送了binlog已经更新的信号，dump线程收到信号，即可以进行binlog的同步。而semisync的作用是什么呢？</p><p><br></p><p>实际上，有没有semisync机制，上面介绍的mysql的有关事务提交中关于binlog的流程都是一样的，semisync的作用，只是主从之间的一个确认过程，主库等待从库返回相关位置的binlog已经同步到从库的确认，（而实际实现则是等待dump线程给用户会话线程一个回复），没有得到确认之前（或者等待时间达到timeout），事务提交则在该函数（步骤）上等待直至获得返回。具体执行binlog已经同步到某个位置的的确认函数为repl_semi_report_binlog_sync，函数如下：</p><p>intrepl_semi_report_binlog_sync(Binlog_storage_param *param,</p><p>constchar *log_file,</p><p>my_off_t log_pos)</p><p>{</p><p>if(rpl_semi_sync_master_wait_point == WAIT_AFTER_SYNC)</p><p>returnrepl_semisync.commitTrx(log_file, log_pos);</p><p>return 0;</p><p>}</p><p>通过观察上述函数，我们可以看到有个rpl_semi_sync_master_wait_point变量与WAIT_AFTER_SYNC比较，如果不相等，则直接返回，直接返回则表示不需要在此时此刻确认binlog是否已经同步，而这个变量的取值来自于半同步参数semi_sync_master_wait_point的初始设置，我们可以设置为after_sync与after_commit。这两个参数含义的区别是：after_sync是在将binlog sync到disk之后（具体是否真正sync由参数sync_binlog的值决定）进行日志同步确认，而after_commit是将事务完成在innodb里面提交之后再进行binlog的同步确认。两者确认的时间点不同，after_sync要早于after_commit.</p><p><br></p><p>接下来，我们来看repl_semisync.commitTrx 这个函数，这个函数有两个传入参数，一个是binlog文件，一个binlog文件的位移。我们来看这个函数的含义吧。算了，还是直接用源码的注释来解释吧。</p><div class=pgc-img><img alt=MySQL5.7事务提交过程以及无损复制源码解析-爱可生 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f166615b238b45c3b2ad8b0877ec6845><p class=pgc-img-caption></p></div><p>上面的注释说得相当清楚，就是该commiTRX函数会等待binlog-dump返回已经同步到该位置的报告，如果还没有同步到该位置，则继续等待，直到超时返回。</p><p><br></p><p>当会话线程收到该函数的返回时，事务的提交过程继续往下走，直至在innodb真正提交。</p><p><br></p><p><strong>总结</strong></p><p>通过上述对mysql的事务提交过程中的前段分析，应该可以了解semi-sync的同步机制与异步机制的区别，semi-sync的主从同步机制与异步机制在同步的处理方式上无任何区别，唯一的区别就是semi-sync在事务提交中段（假如设置为after_sync）或者提交后的阶段（after_commit）, 有一个验证该事务涉及的binlog是否已经同步到从库，而这个同步验证，会拉长整个事务的提交时间，因为事务提交在数据库中几乎是串行（如果按group commit为一个单位，就算是完全地串行），是影响mysql吞吐量的关键点，当这个关键点被拉长，所以对全局的影响就被放大。虽然仅仅多了这么一个确认的动作，但当主库处于semi-sync的同步状态与异步状态的吞吐量相比，相差了好几倍。上述解释就是其真正的原因。</p><div class=pgc-img><img alt=MySQL5.7事务提交过程以及无损复制源码解析-爱可生 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2f67b60e5c8b4325bc9682afe1a0053d><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'MySQL5.7','事务','过程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>