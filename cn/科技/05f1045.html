<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>怎样深入理解堆和栈 | 极客快訊</title><meta property="og:title" content="怎样深入理解堆和栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05f1045.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="怎样深入理解堆和栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/05f1045.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>怎样深入理解堆和栈</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1 class=ql-align-justify>来源：微信公众号【cpp软件架构狮】</h1><p class=ql-align-justify>文章的标题看起来，确实有一点老生常谈的感觉，堆栈的文章多如牛毛。你先别急着关闭页面，接着往下看，这篇文章会带各位更加<strong>深入的理解堆和栈。</strong></p><p class=ql-align-justify><strong></strong>对于大多数新手来说， “堆栈” 却不是一个很清晰的概念。堆栈是同一个东西？是数据结构，还是内存分配方式？</p><p class=ql-align-justify><strong>堆栈：一种数据结构，一个在程序运行时用于存放的地方”，相信这可能是很多初学者共同的认识，这也是大部分教科书对“堆栈”的解释。</strong></p><p class=ql-align-justify><strong></strong>很显然，用这么简单的概括来解释“堆栈”是不合适的。要深刻认识堆和栈的概念与区别，还必须从如下两方面说起：</p><ul><li class=ql-align-justify><strong>数据结构的堆和栈</strong></li><li class=ql-align-justify><strong>内存分配方式的堆和栈</strong></li></ul><p>这是第一步</p><p>第二步再<strong>深入系统实现方式理解堆和栈。</strong></p><p><strong>第一步</strong></p><p><strong>数据结构的堆和栈</strong></p><p class=ql-align-justify>在数据结构中，栈是一种可以实现“先进后出”（或者称为“后进先出”）的存储结构。假设给定栈 S=（a<sub>0</sub>，a<sub>1</sub>，…，a<sub>n-1</sub>），则称 a<sub>0</sub>为栈底，a<sub>n-1</sub> 为栈顶。进栈则按照 a<sub>0</sub>，a<sub>1</sub>，…，a<sub>n-1</sub> 的顺序进行进栈；而出栈的顺序则需要反过来，按照“后存放的先取，先存放的后取”的原则进行，则 a<sub>n-1</sub> 先退出栈，然后 a<sub>n-2</sub> 才能够退出，最后再退出 a<sub>0</sub>。</p><p class=ql-align-justify>在实际编程中，可以通过两种方式来实现：</p><ul><li class=ql-align-justify>使用数组的形式来实现栈，这种栈也称为静态栈；</li><li class=ql-align-justify>使用链表的形式来实现栈，这种栈也称为动态栈。</li></ul><p class=ql-align-justify>相对于栈的“先进后出”特性，堆则是一种经过排序的树形数据结构，常用来实现优先队列等。假设有一个集合 K={k<sub>0</sub>，k<sub>1</sub>，…，k<sub>n-1</sub>}，把它的所有元素按完全二叉树的顺序存放在一个数组中，并且满足：</p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>则称这个集合 K 为最小堆（或者最大堆）。</p><p class=ql-align-justify>由此可见，堆是一种特殊的完全二叉树。其中，节点是从左到右填满的，并且最后一层的树叶都在最左边（即如果一个节点没有左儿子，那么它一定没有右儿子）；每个节点的值都小于（或者都大于）其子节点的值。</p><p class=ql-align-justify>内存分配中的堆和栈</p><p class=ql-align-justify>在 C 语言中，内存分配方式不外乎有如下三种形式：</p><ol><li class=ql-align-justify>从静态存储区域分配：它是由编译器自动分配和释放的，即内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，直到整个程序运行结束时才被释放，如全局变量与 static 变量。</li><li class=ql-align-justify>在栈上分配：它同样也是由编译器自动分配和释放的，即在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将被自动释放。需要注意的是，栈内存分配运算内置于处理器的指令集中，它的运行效率一般很高，但是分配的内存容量有限。</li><li class=ql-align-justify>从堆上分配：也被称为动态内存分配，它是由程序员手动完成申请和释放的。即程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完之后再由程序员自己负责使用内存释放函数（如 free 函数）来释放内存。也就是说，动态内存的整个生存期是由程序员自己决定的，使用非常灵活。需要注意的是，如果在堆上分配了内存空间，就必须及时释放它，否则将会导致运行的程序出现内存泄漏等错误。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify>由此可见，内存分配的堆栈与数据结构中所阐述的堆栈有着本质的区别，这一点千万不要混淆。同样，在内存分配中的堆和栈也存在着很大的区别，也不要混淆这两者的概念。</p><p class=ql-align-justify>内存分配中的栈与堆主要存在如下区别。</p><p><strong>1) 分配与释放方式</strong></p><p class=ql-align-justify>栈内存是由编译器自动分配与释放的，它有两种分配方式：静态分配和动态分配。</p><ul><li class=ql-align-justify>静态分配是由编译器自动完成的，如局部变量的分配（即在一个函数中声明一个 int 类型的变量i时，编译器就会自动开辟一块内存以存放变量 i）。与此同时，其生存周期也只在函数的运行过程中，在运行后就释放，并不可以再次访问。</li><li class=ql-align-justify>动态分配由 alloca 函数进行分配，但是栈的动态分配与堆是不同的，它的动态分配是由编译器进行释放，无需任何手工实现。值得注意的是，虽然用 alloca 函数可以实现栈内存的动态分配，但 alloca 函数的可移植性很差，而且在没有传统堆栈的机器上很难实现。因此，不宜使用于广泛移植的程序中。当然，完全可以使用 C99 中的变长数组来替代 alloca 函数。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>而堆内存则不相同，它完全是由程序员手动申请与释放的，程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完再由程序员自己负责使用内存释放函数（如 free 函数）释放内存，如下面的代码所示：</p><ul><li><br></li></ul><pre>/*分配堆内存*/char *p1 = (char *)malloc(4);… …/*释放堆内存*/free(p1);p1=NULL;</pre><p class=ql-align-justify>对栈内存的自动释放而言，虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果一旦忘记了释放堆内存，那么将会造成内存泄漏，导致程序出现致命的潜在错误。</p><p><strong>2) 分配的碎片问题</strong></p><p class=ql-align-justify>对堆来说，频繁分配和释放（malloc / free）不同大小的堆空间势必会造成内存空间的不连续，从而造成大量碎片，导致程序效率降低；而对栈来讲，则不会存在这个问题。</p><p><strong>3) 分配的效率</strong></p><p class=ql-align-justify>大家都知道，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，例如，分配专门的寄存器存放栈的地址，压栈出栈都有专门的执行指令，这就决定了栈的效率比较高。一般而言，只要栈的剩余空间大于所申请空间，系统就将为程序提供内存，否则将报异常提示栈溢出。</p><p class=ql-align-justify>而堆则不同，它是由 C/C++ 函数库提供的，它的机制也相当复杂。例如，为了分配一块堆内存，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。而对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确释放本内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中。很显然，堆的分配效率比栈要低得多。</p><p><strong>4) 申请的大小限制</strong></p><p class=ql-align-justify>由于操作系统是用链表来存储空闲内存地址（内存区域不连续）的，同时链表的遍历方向是由低地址向高地址进行的。因此，堆内存的申请大小受限于计算机系统中有效的虚拟内存。</p><p class=ql-align-justify>而栈则不同，它是一块连续的内存区域，<strong>其地址的增长方向是向下进行的，向内存地址减小的方向增长</strong>。由此可见，栈顶的地址和栈的最大容量一般都是由系统预先规定好的，如果申请的空间超过栈的剩余空间时，将会提示溢出错误。由此可见，相对于堆，能够从栈中获得的空间相对较小。</p><p><strong>5) 存储的内容</strong></p><p class=ql-align-justify>对栈而言，一般用于存放函数的参数与局部变量等。例如，在函数调用时，第一个进栈的是（主函数中的）调用处的下一条指令（即函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，<strong>在大多数 C 编译器中，参数是由右往左入栈的，最后是函数中的局部变量（注意 static 变量是不入栈的）</strong>。</p><p class=ql-align-justify><strong>对堆而言，具体存储内容由程序员根据需要决定存储数据。</strong></p><p class=ql-align-justify>最后介绍一下 C 语言中各类型变量的存储位置和作用域。</p><ul><li class=ql-align-justify>全局变量。从静态存储区域分配，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用。与此同时，如果程序是由多个源文件构成的，那么全局变量只要在一个文件中定义，就可以在其他所有的文件中使用，但必须在其他文件中通过使用extern关键字来声明该全局变量。</li><li class=ql-align-justify>全局静态变量。从静态存储区域分配，其生命周期也是与整个程序同在的，从程序开始到结束一直起作用。但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用。</li><li class=ql-align-justify>局部变量。从栈上分配，其作用域只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的生命周期也只是和该函数同在。</li><li class=ql-align-justify>局部静态变量。从静态存储区域分配，其在第一次初始化后就一直存在直到程序结束，该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>第二步</strong></p><p class=ql-align-justify>数据结构的堆栈也没有特别深奥难以理解，所以暂且略过。so最值得去讲的是<strong>内存分配方式的堆栈，以x86为例。</strong></p><p class=ql-align-justify>栈寄存器和栈操作</p><ol><li class=ql-align-justify><strong>与栈相关的寄存器有两个：esp和ebp。</strong></li></ol><ul><li class=ql-align-justify><br></li></ul><pre class=ql-align-justify>esp，栈指针，指向栈顶ebp，基址指针，指向栈底</pre><ol><li class=ql-align-justify><strong>栈操作</strong></li></ol><p class=ql-align-justify><strong>push 进栈</strong></p><p class=ql-align-justify>栈顶指针减少4个字节（栈是由高地址向低地址增长的），例如<strong> pushl %eax</strong>相当于：</p><ul><li><br></li></ul><pre>subl $4, %espmovl %eax, (%esp)</pre><p class=ql-align-justify><strong>pop 出栈</strong></p><p class=ql-align-justify>栈顶地址增加4个字节，例如，popl %eax相当于：</p><ul><li><br></li></ul><pre> movl (%esp), %eax add $4, %esp </pre><p class=ql-align-justify><strong>3.call</strong></p><p class=ql-align-justify>eip，程序计数器，总是指向下一条指令的位置。在进行函数调用时，会执行call指令，将eip中内容指向对应函数的位置。call具体执行过程如下：</p><p class=ql-align-justify>首先将eip的值压如栈顶，然后将eip执行被调用函数的入口地址。具体指令如下：</p><pre class=ql-align-justify></pre><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre> pushl %eip movl 0x12345, %eip 4.ret</pre><ol><li class=ql-align-justify>弹出原来保存在栈顶的原eip中的值，放入eip。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify>函数的栈框架</p><p class=ql-align-justify>每一个函数都会维持一个栈。栈框架会包裹函数执行体。如下图所示：</p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/17d0414b5d894b6ab6a24f8f2766f219><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>分析demo</strong></p><p class=ql-align-justify><strong>源码：</strong></p><ul><li><br></li></ul><pre>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void p1(char c){ printf(%c\n",c);}int p2(int x,int y){ return x + y;} int main(){ char c = 'a'; int x,y,z; x = 1; y = 2; p1(c); z = p2(x,y); printf("%d = %d + %d\n",z,x,y);}</pre><p class=ql-align-justify><strong>反汇编后</strong>：</p><ul><li><br></li></ul><pre>.LC0: .string "%c\n" .textp1: pushl %ebp movl %esp, %ebp subl $12, %esp movl 8(%ebp), %eax movb %al, -4(%ebp) movsbl -4(%ebp),%eax movl %eax, 4(%esp) movl $.LC0, (%esp) call printf leave retp2: pushl %ebp movl %esp, %ebp movl 12(%ebp), %eax addl 8(%ebp), %eax popl %ebp ret.LC1: .string "%d = %d + %d\n" .textmain: pushl %ebp movl %esp, %ebp subl $32, %esp movb $97, -13(%ebp) movl $1, -12(%ebp) movl $2, -8(%ebp) movsbl -13(%ebp),%eax movl %eax, (%esp) call p1 movl -8(%ebp), %eax movl %eax, 4(%esp) movl -12(%ebp), %eax movl %eax, (%esp) call p2 movl %eax, -4(%ebp) movl -8(%ebp), %eax movl %eax, 12(%esp) movl -12(%ebp), %eax movl %eax, 8(%esp) movl -4(%ebp), %eax movl %eax, 4(%esp) movl $.LC1, (%esp) call printf leave ret</pre><p class=ql-align-justify><strong>接下来我们分析下栈的过程</strong></p><ul><li><br></li></ul><pre>pushl %ebpmovl %esp, %ebp</pre><p class=ql-align-justify>以上两条指令属于函数调用框架，作用就是为main函数建议一个新的空的栈。</p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c74906e6a80494ea841600f69688bb9><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>subl $32, %espmovb $97, -13(%ebp)movl $1, -12(%ebp)movl $2, -8(%ebp)</pre><p class=ql-align-justify>第一条指令的目的是在栈中开辟32字节的空间，存储局部变量。编译器会事先扫描函数中局部变量个数和大小，预分配给一个空间，供存储局部变量和参数调用。</p><p class=ql-align-justify>剩下三条指令为将局部变量压栈。</p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b7846e12ffc74c3190be3d2c6a0994ab><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>movsbl -13(%ebp),%eaxmovl %eax, (%esp)</pre><p class=ql-align-justify>将参数c=‘a’压栈</p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>call p1</pre><p class=ql-align-justify>相当于：</p><ul><li><br></li></ul><pre> pushl %eip movl p1, %eip</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebebd9b556af457f8d4d0f963817fd1e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>pushl %ebpmovl %esp, %ebpsubl $12, %esp</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4be6625a29554c5eb3c8e81d5dd75ab6><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>movl 8(%ebp), %eaxmovb %al, -4(%ebp)movsbl -4(%ebp),%eaxmovl %eax, 4(%esp)movl $.LC0, (%esp)</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>call printfleaveret</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1f7365bb9a248cab24924f0ba08011d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>movl -8(%ebp), %eaxmovl %eax, 4(%esp)movl -12(%ebp), %eaxmovl %eax, (%esp)</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎样深入理解堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1437bf4d681c4afdb333291d75c8be94><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>进入p2函数，过程和p1函数调用过程相似。以上就是函数调用栈的过程。</p><p class=ql-align-justify><strong>堆的深入理解</strong></p><p class=ql-align-justify>栈上的数据在函数返回时就会被释放掉，所以无法将数据传至函数外部，而全局变量没有办法动态地产生，只能在编译的时候定义，在这种情况下，堆是唯一地选择。malloc是C语言申请堆空间的函数，但是它是怎么实现的那？</p><p class=ql-align-justify>其实可以直接让操作系统的内核来管理进程的内存，但是每次申请内存都要经过系统调用，如果操作频繁会导致效率很低，程序性能降低。比较好的做法是程序向操作系统申请一块适当的堆空间，然后由程序的运行库根据算法管理堆空间的分配，当堆空间不够的时候再向操作系统申请堆空间。linux下提供两种堆空间分配方式：<strong>一个是brk（）系统调用，另外一个是mmap（）。</strong></p><ul><li><br></li></ul><pre>int brk (void *end_data_segment)</pre><p class=ql-align-justify>brk()的作用实际上就是设置进程数据段的结束地址，她可以扩大或者缩小数据段。</p><ul><li><br></li></ul><pre>void mmap（void *start, size_t length, int port, int flags, int fd, off_t offset）</pre><p class=ql-align-justify>mmap的前两个参数分别指定需要申请的空间的起始地址和长度，如果其实地址设为0，那么操作系统会挑选合适的起始地址。port/flags这两个参数用于设置申请的空间的权限（可读，可写，可执行）以及映射类型（文件类型，匿名空间等），最后两个参数用于文件映射是指定文件的描述符和文件偏移。用mmap实现的malloc函数：</p><ul><li><br></li></ul><pre>void *malloc(size_t nbytes){ void *ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0 , 0); if (ret == MAP_FAILED) return 0; return ret;}</pre><p class=ql-align-justify><strong>mmap（）的作用是向操作系统申请一段虚拟空间，当这块虚拟空间可以映射到某个文件（也就是这个系统调用的最初的作用），当他不将地址空间映射到某个文件时，我们又称这块空间为匿名空间。</strong></p><p class=ql-align-justify>glibc的malloc 函数是这样处理用户的空间请求的：对于小于128KB的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间返回，对于大于128KB的请求来说，它会使用mmap（）函数为它分配一块匿名空间，然后再这个匿名空间中为用户分配空间。（所以问一个很常见的问题，malloc申请的内存，进程结束以后还会不会存在？ 答案是不存在）</p><p><strong>堆分配算法</strong></p><p><strong>1、空闲链表法</strong></p><p>空闲链表的方法是把堆中各个空闲的快按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找到合适大小的快并且将它拆分，当用户释放空间时将它合并到空闲链表中。</p><p class=ql-align-justify><strong>2、位图</strong></p><p class=ql-align-justify><strong></strong>核心思想就是将整个堆划分为大量的块，每个块大小相同。当用户请求内存的时候总是分配整个块的空间给用户。第一个块我们称为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。</p><p><strong>优点：速度快，稳定性好，容易管理。</strong></p><p><strong>缺点：容易产生碎片，浪费空间。</strong></p><p class=ql-align-justify><strong>3、对象池</strong></p><p class=ql-align-justify>如果实际上在一些场合，被分配对象的大小是固定的几个值，我们可以采用对象池的方法。对象池思想就是，如果每一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求只要找到一个空闲的小块就可以了。</p><p class=ql-align-justify><strong>实际上很多应用中，堆的分配算法往往是采取多种算法复合而成的，对于glibc来说，小于64字节的采用对象池的方法，对于大于512字节的采用最佳适配算法，对于64字节和512字节之间的采取最佳折中策略；对于大于128kb的申请，它会直接使用mmap向操作系统申请空间。</strong></p><p class=ql-align-justify><strong>总结</strong></p><p class=ql-align-justify>这篇文章花了我8个小时的时间，真的不容易。从基本到深入，从堆到栈。从数据结构到内存分配方式。要想吃透还得在工作中加以实践。</p><p class=ql-align-justify><strong>END</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'怎样','深入','理解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>