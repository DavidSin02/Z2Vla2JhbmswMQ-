<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>软考自查：数据结构与算法基础（内容有点多！！！） | 极客快訊</title><meta property="og:title" content="软考自查：数据结构与算法基础（内容有点多！！！） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/60f8235323314304b4dac050f8cb1e7d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/062bbe77.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/062bbe77.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="软考自查：数据结构与算法基础（内容有点多！！！）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/062bbe77.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>软考自查：数据结构与算法基础（内容有点多！！！）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>数据结构与算法基础</h1><h1>内容提要</h1><ul><li>数组与矩阵</li><li><strong>线性表</strong></li><li>广义表</li><li><strong>树与二叉树</strong></li><li>图</li><li><strong>排序与查找</strong></li><li><strong>算法基础及常见的算法</strong></li></ul><hr><h1>数组</h1><ol><li><strong>数组类型</strong>：存储地址计算</li><li><strong>一维数组a[n]</strong>：a[i]的存储地址为：a+i*len</li><li><strong>二维数组a[m][n]</strong>：</li></ol><ul><li>a[i][j]的存储地址（按行存储）为：a+(i*n+j)*len</li><li>a[i][j]的存储地址（按列存储）为：a+(j*n+i)*len</li></ul><h1>稀疏矩阵</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/60f8235323314304b4dac050f8cb1e7d><p class=pgc-img-caption></p></div><p><strong>例题</strong></p><blockquote><p>设有如下所示的三角矩阵A[0..8,1..8]，将该三角矩阵的非零元素（即行下标不小于列下标的所有元素）按行优先压缩存储在数组M[1..m]中，则元素A[i,j](0&lt;=i，j&lt;=i)存储在数组M的（A）中。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcf36d806e734bc494a0398d003d24a9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b3a36dd70d5c4cec8b691236500db2b0><p class=pgc-img-caption></p></div><h1>数据结构的定义</h1><p><strong>1.数据结构的概念</strong></p><p><strong>2.数据逻辑结构</strong></p><p><strong>线性结构</strong></p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6abcd3d59bff48f9bd284856c25f193a><p class=pgc-img-caption></p></div><p><strong>非线性结构</strong>（树形结构：无环路，图：有环路）</p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d48a7e2ce9044de8a4d99c784fa4c37e><p class=pgc-img-caption></p></div><hr><h1>线性表的定义</h1><p><strong>1、线性表的概念</strong></p><p>（a1,a2,...,a3)</p><p><strong>2、线性表常见的两种存储结构</strong></p><p><strong>顺序存储结构</strong>（顺序表）</p><p><strong>链式存储结构</strong>（链表）</p><h1>线性表</h1><p><strong>顺序表</strong></p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6a4513bc4e1145ecbb3a6151f6fcf5b2><p class=pgc-img-caption></p></div><p><strong>链表</strong></p><ul><li>单链表</li><li>循环链表</li><li>双向链表</li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9613851769943f7b12dec026fd5efb4><p class=pgc-img-caption></p></div><h1>链表的基本操作</h1><ul><li>单链表删除结点</li><li>单链表插入结点</li><li>双向链表删除结点</li><li>双向链表插入结点</li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/210035a60b0c48c5850c5dec52f455f2><p class=pgc-img-caption></p></div><h1>线性表-顺序存储与链式存储对比</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d0f355a739b4ab7aae1fe1143294538><p class=pgc-img-caption></p></div><h1>线性表-队列与栈</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fca9f69fd2184407a78fc43b92d2528d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c43455b2b594cf8b38b5ee98f24fd4b><p class=pgc-img-caption></p></div><p><strong>例题</strong></p><blockquote><p>输出受限的双端队列是指元素可以从队列的两端输入，但只能从队列的一端输出，如下图所示，若有e1,e2,e3,e4依次进入输出受限的双端队列，则得不到输出序列（D）</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cbc9a70beecd401c99f8c75554f7030d><p class=pgc-img-caption></p></div><p>A:e4,e3,e2,e1</p><p>B:e4,e2,e1.e3</p><p>C:e4,e3,e1,e2</p><p>D:e4,e2,e3,e1</p><h1>广义表</h1><p><strong>广义表是n个表元素组成的有限序列,是线性表的推广。</strong></p><p><strong>通常用递归的形式进行定义，记做:LS (a0，a1，....，an)。</strong></p><pre>注:其中LS是表名，ai是表元素，它可以是表(称做子表),也可以是数据元素(称为原子)。其中n是广义表的长度(也就是最外层包含的元素个数),n=0的广义表为空表;而递归定义的重数就是广义表的深度,直观地说，就是定义中所含括号的重数(原子的深度为0，空表的深度为1)。</pre><p><strong>基本运算:取表头head(Ls)和取表尾tail(Ls)。</strong></p><pre>若有:LS1=(a,(b,c),(d,e))head(LS1)=atail(LS1)=((b,c)，(d,e))</pre><blockquote><p>例1,有广义表LS1=(a,(b,c),(d,e)),则其长度为?深度为?</p><p><strong>答案：长度为3，深度为2.</strong></p><p>例2,有广义表LS1= (a,(b,c)，(d,e))),要将其中的b字母取出,操作就为?</p><p><strong>答案：head（head（tail（LS1）））</strong></p></blockquote><hr><h1>树与二叉树</h1><ul><li><strong>结点的度</strong></li><li>树的度</li><li>叶子结点</li><li>分支结点</li><li>内部结点</li><li>父结点</li><li>子结点</li><li>兄弟结点</li><li>层次</li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5473ed15ff094029b085de09a1978887><p class=pgc-img-caption></p></div><h1>树与二叉树</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4764d8542d1745a2b18dd93be64bf66e><p class=pgc-img-caption></p></div><p><strong>二叉树的重要特性:</strong></p><ol><li>在二叉树的第i层上最多有<strong>2^i-1个结点(i>=1);</strong></li><li>深度为k的二叉树最多有<strong>2k -1个结点(k>=1);</strong></li><li>对任何棵二叉树,如果其<strong>叶子结点数为n0,度为2的结点数为n2</strong> ,则<strong>n0=n2+1。</strong></li><li>如果对一棵有n个结点的完全二叉树的结点按层序编号(<strong>从第1层到log2nJ+1层</strong>，每层从左到右)，则对任一<strong>结点i(1&lt;=i&lt;=n)</strong>，有:</li></ol><ul><li><strong>*如果i=1</strong>,则结点<strong>i无父结点</strong>，是二叉树的根;如果<strong>i>1</strong> ,则父结点是【i<strong>/2】;</strong></li><li><strong>*如果2i>n,</strong>则结点为<strong>i叶子结点</strong>，无左子结点;否则，其左子结点是结点<strong>2i;</strong></li><li><strong>*如果2i+1>n,</strong>则结点<strong>无右子叶点</strong>，否则,其右子结点是结点<strong>2i+1</strong>。</li></ul><h1>树与二叉树遍历</h1><ol><li><strong>前序遍历 12457836</strong></li><li><strong>中序遍历 42785136</strong></li><li>后序遍历 <strong>48752631</strong></li><li>层次遍历 <strong>12345678</strong></li></ol><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b4a0cce753b84669a6c1e17c4e4c8c1b><p class=pgc-img-caption></p></div><h1>树与二叉树-反向构造二叉树</h1><p><strong>由前序序列为ABHFDECG；中序序列为HBEDFAGC构造二叉树。</strong></p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ce914ab6cd744d648d64c72f6f1d2692><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4493b4e84264fc79a24958422272f69><p class=pgc-img-caption></p></div><h1>树与二叉树-树转二叉树</h1><ul><li><strong>孩子结点-左子树结点</strong></li><li><strong>兄弟结点-右孩子结点</strong></li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56f44bf4201a478fa7b9d3eb27c5fe0a><p class=pgc-img-caption></p></div><h1>树与二叉树-查找二叉树</h1><ul><li><strong>二叉排序树</strong></li><li><strong>左孩子小于根</strong></li><li>右孩子大于根</li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e1a5d3fc78544f295fee5038514c129><p class=pgc-img-caption></p></div><blockquote><p><strong>插入结点:</strong></p><p><strong>①若该键值结点已存在,则不再插入，如: 48;</strong></p><p><strong>②若查找二叉树为空树,则以新结点为查找叉树;</strong></p><p><strong>③将要插入结点键值与插入后父结点键值比较,就能确定新结点是父结点的左子结点，还是右子结点。</strong></p><p><strong>删除结点:</strong></p><p><strong>①若待删除结点是叶子结点，则直接删除;</strong></p><p><strong>②若待删除结点只有一个子结点,则将这个子结点与待删除结点的父结点直接连接，如: 56 ;</strong></p><p><strong>③若待删除的结点p有两个子结点,则在其左子树上,用中序遍历寻找关键值最大的结点s ,用结点s的值代替结点p的值,然后删除节点s ,节点s必属于上述①，②情况之一,如89。</strong></p></blockquote><h1>树与二叉树-最优二叉树（哈夫曼树）</h1><p>（在多媒体的压缩方式经常使用：无损压缩）</p><p><strong>需要了解的基本概念：</strong></p><ul><li><strong>树的路径长度</strong></li><li><strong>权</strong></li><li><strong>带权路径长度</strong></li><li><strong>树的带权路径长度(树的代价）</strong></li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d0eaba756124424826343591db454ec><p class=pgc-img-caption></p></div><blockquote><p>例题：假如有一组权值5，29，7，8，14，23，3，11请尝试构造哈夫曼树。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b0bf63f34b0a4133bd83315339034b87><p class=pgc-img-caption></p></div><h1>树与二叉树-线索二叉树</h1><ul><li><strong>为什么要有线索二叉树</strong></li><li><strong>线索二叉树的概念</strong></li><li><strong>线索二叉树的表示</strong></li><li><strong>如何将二叉树转化为线索二叉树</strong></li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/786ae42a54cb4bd38796c8da0579a4ee><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d21b3c43235549f6aee3d25939093c91><p class=pgc-img-caption></p></div><h1>树与二叉树-平衡二叉树</h1><ul><li><strong>平衡二叉树的提出原因</strong></li><li><strong>平衡二叉树的定义</strong>（</li><li>任意结点的左右子树深度相差不超过1</li><li>每结点的平衡度只能为-1、0或1）</li><li><strong>平衡树的建立过程</strong></li><li><strong>动态调平衡问题</strong></li></ul><blockquote><p>例题：对数列{1，5，7，9，8，39，73，88}构造序列二叉树，可以构造出多颗形式不同的排序二叉树。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5bbd46b322e54f4284da7f63772873d2><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2dc9af3aeb8f4112a4a2434fa4657632><p class=pgc-img-caption></p></div><hr><h1>图-基本概念</h1><p><strong>完全图</strong></p><ul><li><strong>在无向图中，若每对顶点之间都有一条边相连，则称该图为完全图（complete graph）</strong></li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2fb7a6a2835f4b7aa96a4a31066e053b><p class=pgc-img-caption></p></div><ul><li><strong>在有向图中，若每对顶点之间都有两条有向边相互连接，则称该图为完全图。</strong></li></ul><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d8c25efc7884b2c81567e1844147f2b><p class=pgc-img-caption></p></div><h1>图的存储-邻接矩阵</h1><blockquote><p><strong>用一个n阶方阵R来存放图中各结点的关联信息，其矩阵元素Rij定义为：</strong></p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5adf339e3a5b43ccb534f6a631a29675><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37f86cedd2a84b2089c907f64eba8ac3><p class=pgc-img-caption></p></div><h1>图的存储-邻接表</h1><p><strong>首先把每个顶点的邻接顶点用链表示出来，然后用一个一维数组来顺序存储上面每个链表的头指针。</strong></p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/add1850f965342c6bc84be83d8adaf8d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/31ba1cd5db504f3d8b77ec02d6438c15><p class=pgc-img-caption></p></div><h1>图-图的遍历</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fdc4e8e5531a4aa6a00e3eeba622e9dc><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eed172fc070b4eec85b241dd44c9ec54><p class=pgc-img-caption></p></div><h1>图-拓扑排序</h1><p><strong>我们把用有向边表示活动之间开始的先后关系。这种有向图称为用顶点表示活动网络，简称AOV网络</strong></p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4fa983a693f240af961eb4760e9a23c7><p class=pgc-img-caption></p></div><p><strong>上图的拓扑序列有：02143567，01243657，02143657，01243567</strong></p><hr><h1>图的最小生成树-普里姆算法</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c653ff5471c426795d4f316010dc461><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fbdd247c443e4386b1f68b367bcf2d70><p class=pgc-img-caption></p></div><h1>算法基础-算法的特性</h1><ul><li>有穷性：<strong>执行有穷步之后结束</strong></li><li>确定性：<strong>算法中每一条指令都必须有确切的含义，不能含糊不清。</strong></li><li><strong>输入</strong>（>=0)</li><li><strong>输出</strong> (>=1)</li><li>有效性：算法的每个步骤都能有效执行并能得到确定的结果。<strong>例如a=0,b/a就无效。</strong></li></ul><h1>算法基础-算法的复杂度</h1><p><strong>时间复杂度：</strong></p><blockquote><p><strong>是指程序运行从开始到结束所需要的时间。通常分析时间复杂度的方法是从算法中选取一种对于所研究的问题来说是基本运算的操作,以该操作重复执行的次数作为算法的时间度量。一般来说,算法中原操作重复执行的次数是规模n的某个函数T(n)。由于许多情况下要精确计算T(n)是困难的，因此引入了渐进时间复杂度在数量上估计一个算法的执行时间。其定义如下:</strong></p></blockquote><pre>如果存在两个常数c和m ,对于所有的n ,当n&gt;=m时有f(n)&lt;=cg(n) ,则有f(n)=O(g(n))。也就是说,随着n的增大,f(n)渐进地不大于g(n)。例如，一个程序的实际执行时间为T(n)=3n^3+2n^2+n ,则T(n)=O(n^3). 常见的对算法执行所需时间的度量:O(1)&lt;0(log2n)&lt;O(n)&lt;O(nlog2n)&lt;O(n^2)&lt;O(n^3)&lt;0(2^n)</pre><p><strong>空间复杂度:</strong></p><blockquote><p><strong>是指对一个算法在运行过程中临时占用存储空间大小的度量。-个算法的空间复杂度只考虑在运行过程中为局部变量分配的存储空间的大小。</strong></p></blockquote><hr><h1>查找-顺序查找</h1><p><strong>顺序查找的思路：将待查找的关键字为key的元素从头到尾与表中元素进行比较，如果中间存在关键字为key的元素，则返回成功；否则，则查找失败。</strong></p><p>查找成功时，顺序查找的平均查找长度为（等概率情况下）:</p><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b7bf137a2b454063a932812c79013114><p class=pgc-img-caption></p></div><h1>查找-二分查找</h1><p><strong>二分法查找的基本思想是</strong>:(<strong>设R[low,..,high]</strong>是当前的查找区)</p><p>(1)确定该区间的中点位置:<strong>mid=[(low+high)/2];</strong></p><p>(2)将待查的<strong>k值与R[mid].key</strong>比较,若相等,则查找成功并返回此位置，否则需确定新的查找区间,继续二分查找,具体方法如下。</p><pre>●若R[mid].key&gt; k,则由表的有序性可知R[mid,..,n].key均大于k,因此若表中存在关键字等于k的结点,则该结点必定是在位置mid左边的子表R[low，...,mid- 1]中。因此,新的查找区间是左子表R[low，..,high],其中high=mid-1。●若R[mid].key&lt;k ,则要查找的k必在mid的右子表R[mid+1...,high]中,即新的查找区间是右子表R[low,..,high],其中low=mid+1。●若R[mid].key=k,则查找成功,算法结束。</pre><p>(3)下一-次查找是针对新的查找区间进行,重复步骤(1)和(2)。</p><p>(4)在查找过程中，<strong>low逐步增加,而high逐步减少。如果high&lt;low</strong> ,则查找失败,算法结束。</p><p><strong>例题：</strong></p><blockquote><p>请给出在含有12个元素的有序表{1，4，10，16，17，18，23，29，33，40，50，51}中二分查找关键字17的过程。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/980a21ec5571445cbcbe73cb32d8045b><p class=pgc-img-caption></p></div><h1>查找-折半查找</h1><p>折半查找在查找成功时关键字的比较次数最多为<strong>[log2n]=1次。</strong></p><p>折半查找的时间复杂度为<strong>O（log2n）。</strong></p><h1>查找-散列表</h1><blockquote><p><strong>散列表查找的基本思想是:已知关键字集合U,最大关键字为m,设计一个函数Hash,它以关键字为自变量,关键字的存储地址为因变量，将关键字映射到一个有限的、地址连续的区间T[0..n-1](n&lt;&lt;m)中,这个区间就称为散列表,散列查找中使用的转换函数称为散列函数。</strong></p></blockquote><h1>查找-散列表冲突的解决方法</h1><blockquote><p><strong>开放定址法是指当构造散列表发生冲突时,使用某种探测手段，产生-个探测的散列地址序列,并且逐个查找此地址中是否存储了数据元素,如果没有,则称该散列地址开放,并将关键字存入,否则继续查找下-个地址。只要散列表足够大,总能找到空的散列地址将数据元素存入。</strong></p></blockquote><ul><li><strong>线性探测法</strong></li><li><strong>伪随机数法</strong></li></ul><blockquote><p>例:记录关键码为(3，8, 12, 17,9),取m=10(存储空间为10),p=5,散列函数h =key%p。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5511d910d7404dd1925da6a773f5995e><p class=pgc-img-caption></p></div><hr><h1>排序</h1><p><strong>1、排序的概念</strong></p><ul><li><strong>稳定与不稳定排序</strong></li><li><strong>内排序与外排序</strong></li></ul><p><strong>2、排序方法分类</strong></p><ul><li><strong>插入类排序</strong></li><li>（直接插入排序</li><li>希尔排序）</li><li><strong>交换类排序</strong></li><li>（冒泡排序</li><li>快速排序）</li><li><strong>选择类排序</strong></li><li>（简单选择排序</li><li>推排序）</li><li><strong>归并排序</strong></li><li><strong>基数排序</strong></li></ul><h1>排序-直接插入排序</h1><blockquote><p><strong>直接插入排序：即当插入第i个记录，R1，R2，...，Ri-1均已排好序，因此，将第i个记录Ri依次与Ri-1，...，R2 ，R1进行比较，找到合适的位置插入。它简单明了，但速度很慢</strong>。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2fea34ce108f4fbf9227472f65364959><p class=pgc-img-caption></p></div><h1>排序-希尔排序</h1><blockquote><p><strong>希尔(Shell)排序:先取-个小于n的整数d1作为第-个增量,把文件的全部记录分成d1个组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序;然后,取第二个增量d2 &lt;d1,重复上述的分组和排序,直至所取的增量dt=1(dt&lt;dt-1&lt;O&lt;d2&lt;d1) ,即所有记录放在同组中进行直接插入排序为止。该方法实质上是一种分组插入方法。</strong></p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/eafbbfda0aa3413da2f576080e1c8222><p class=pgc-img-caption></p></div><h1>排序-直接选择排序</h1><blockquote><p><strong>直接选择排序的过程是，首先在所有记录中选出排序码最小的记录，把它与第一个记录交换，然后在其余的记录内选出排序码最小的记录，与第二个记录交换......依次类推，直到所有记录排完为止。</strong></p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/370e192da68c43e5958db540827db0e2><p class=pgc-img-caption></p></div><h1>排序-推排序的概念</h1><p>（最复杂的一种）</p><blockquote><p><strong>设有n个元素的序列{K1，K2，...，Kn}，</strong>当且仅当满足下述关系之一时，称之为推。</p><p><strong>（1）</strong>ki&lt;=k2i且ki&lt;=k2i+1;</p><p><strong>（2）</strong>ki>=k2i且ki>=k2i+1;</p><p>其中<strong>(1)</strong>称为<strong>小顶堆，（2）</strong>称为<strong>大顶堆</strong></p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6cdd0405ff1e4f8c9c91bcc08602e02f><p class=pgc-img-caption></p></div><h1>排序-堆排序</h1><blockquote><p><strong>堆排序的基本思想为:先将序列建立堆,然后输出堆顶元素,再将剩下的序列建立堆,然后再输出堆顶元素,依此类推,直到所有元素均输出为止,此时元素输出的序列就是一个有序序列。</strong></p></blockquote><p><strong>堆排序的算法步骤如下(以大顶堆为例):</strong></p><pre>(1)初始时将顺序表R[1..n]中元素建立为一个大顶堆,堆顶位于R[1]待序区为R[1..n].(2)循环执行步骤3 ~步骤4 ,共n-1次。(3)假设为第次运行,则待序区为R[1..n-i+1],将堆顶元素R[1]与待序区尾元素R[n-i+1]交换,此时顶点元素被输出,新的待序区为R[1..n-i]。(4)待序区对应的堆已经被破坏,将之重新调整为大顶堆。</pre><p><strong>例题：</strong></p><blockquote><p>假设有数组A={1，3，4，5，7，2，6，8，0}，初建推过程如下：</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f7fa0dc10c4d404b98eff3223f49eb5d><p class=pgc-img-caption></p></div><p><strong>例题</strong></p><blockquote><p>将顺序表R{80，60，16，50，45，10，15，30，40，20}进行堆排序。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6206d4d565cc47c986c573e457424692><p class=pgc-img-caption></p></div><h1>排序-冒泡排序</h1><blockquote><p><strong>冒泡排序的基本思想是，通过相邻元素之间的比较和交换，将排序码较小的元素逐渐从底部移向顶部。由于整个排序的过程就像水底下的气泡一样逐渐向上冒，因此称为冒泡算</strong>法。</p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45c25080f9e24aaf8af5336134e6c0ae><p class=pgc-img-caption></p></div><h1>排序-快速排序</h1><blockquote><p><strong>快速排序采用的是分治法,其基本思想是将原问题分解成若干个规模更小但结构与原问题相似的子问题。通过递归地解决这些子问题,然后再将这些子问题的解组合成原问题的解。</strong></p></blockquote><p><strong>快速排序通常包括两个步骤:</strong></p><pre>第一步，在待排序的n个记录中任取一个记录,以该记录的排序码为准,将所有记录都分成两组,第1组都小于该数,第2组都大于该数,如图所示。第二步，采用相同的方法对左、右两组分别进行排序,直到所有记录都排到相应的位置为止。 </pre><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c2c37d9965d46d68d20d3b8ddef748b><p class=pgc-img-caption></p></div><h1>排序-归并排序</h1><blockquote><p><strong>归并也称为合并,是将两个或两个以上的有序子表合并成-个新的有序表。若将两个有序表合并成个有序表,则称为二路合并。合并的过程是:比较A[i]和A[j]的排序码大小,若A[i]的排序码小于等于A[j]的排序码,则将第一个有序表中的元素A[i]复制到R[k]中,并令i和k分别加1;如此循环下去,直到其中一个有序表比较和复制完，然后再将另一个有序表的剩余元素复制到R中。</strong></p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/971f493ac75946c1b47f6bc58d0a9f9c><p class=pgc-img-caption></p></div><h1>排序-基数排序</h1><blockquote><p><strong>基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。基数排序不是基于关键字比较的排序方法，它适合于元素很多而关键字较少的序列。基数的选择和关键字的分解是根据关键字的类型来决定的，例如关键字是十进制数，则按个位、十位来分解。</strong></p></blockquote><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6aa2f3317ebc43579a3b038919fdd397><p class=pgc-img-caption></p></div><h1>排序</h1><div class=pgc-img><img alt=软考自查：数据结构与算法基础（内容有点多！！！） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ff116dd6797a47cbb3098fdfd2d07cd3><p class=pgc-img-caption></p></div><blockquote><p><strong>更多软考自查在我的主页“文章”中可以查看！！！</strong></p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'软考','数据','结构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>