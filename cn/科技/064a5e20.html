<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>菜鸟攻略（初学者玩转多态与接口） | 极客快訊</title><meta property="og:title" content="菜鸟攻略（初学者玩转多态与接口） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/3e6500019eb9d4b4a4ed"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/064a5e20.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/064a5e20.html><meta property="article:published_time" content="2020-11-14T21:08:07+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:07+08:00"><meta name=Keywords content><meta name=description content="菜鸟攻略（初学者玩转多态与接口）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/064a5e20.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>菜鸟攻略（初学者玩转多态与接口）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>1 <strong>抽象类</strong></h1><p>为什么使用抽象类</p><p>1：定义Dog类</p><p>有颜色属性和叫的方法</p><p>2：定义Bird类</p><p>有颜色属性和叫的方法</p><p>3：定义其父类Animal</p><p>1：抽取共性颜色属性和叫的方法</p><p>1：颜色的属性可以使用默认初始化值。</p><p>2：叫的方法在父类中如何定义？</p><p>1：狗是旺旺</p><p>2：鸟是叽叽喳喳</p><p>3：可以将父类的方法定义为狗叫让鸟继承父类重写叫的方法</p><p>1：鸟怎么确定是否要重写父类方法。</p><p>2：不重写，编译和运行都没有问题，只是执行鸟叫的方法就会出现狗叫</p><p>4：父类的方法很难确定。</p><table><tbody><tr class=firstRow><td><p><strong>class</strong> Animal {</p><p>String color;</p><p><strong>void</strong> shout(){</p><p>//如何定义呢?是旺旺还是叽叽喳喳?</p><p>}</p><p>}</p><p><strong>class</strong> Dog <strong>extends</strong> Animal {</p><p><strong>void</strong> shout() {</p><p>System.out.println("旺旺");</p><p>}</p><p>}</p><p><strong>class</strong> Bird <strong>extends</strong> Animal {</p><p><strong>void</strong> shout() {</p><p>System.out.println("叽叽喳喳");</p><p>}</p><p>}</p></td></tr></tbody></table><p>2：使用abstract</p><p>4：抽象类</p><p>1：当描述一个类的时候，如果不能确定功能函数如何定义，那么该类就可以定义为抽象类，功能函数应该描述为抽象函数。</p><p>5：抽象类的实现方式</p><p>1：定义animal类</p><p>1：定义叫的方法，无法确定方法体，不写方法体</p><p>1：public void shout (); 编译失败</p><p>2：根据提示在shout的方法加入abstract修饰</p><p>1：编译失败，有新的提示</p><p>3：根据提示将类加入abstract修饰</p><p>1：编译通过</p><table><tbody><tr class=firstRow><td><p><strong>abstract</strong><strong>class</strong> Animal {</p><p>String color;</p><p><strong>abstract</strong><strong>void</strong> shout();</p><p>}</p><p><strong>class</strong> Dog <strong>extends</strong> Animal {</p><p><strong>void</strong> shout() {</p><p>System.out.println("旺旺");</p><p>}</p><p>}</p><p><strong>class</strong> Bird <strong>extends</strong> Animal {</p><p><strong>void</strong> shout() {</p><p>System.out.println("叽叽喳喳");</p><p>}</p><p>}</p></td></tr></tbody></table><p>6：抽象类的特点</p><p>1：有抽象函数的类，该类一定是抽象类。</p><p>2：抽象类中不一定要有抽象函数。</p><p>3：抽象类不能使用new创建对象</p><p>1：创建对象，使用对象的功能，抽象类的方法，没有方法体。</p><p>4：抽象类主要为了提高代码的复用性，让子类继承来使用。</p><p>5：编译器强制子类实现抽象类父类的未实现的方法。</p><p>1：可以不实现，前提是子类的也要声明为抽象的。</p><p>7：抽象的优点</p><p>1：提高代码复用性</p><p>2：强制子类实现父类中没有实现的功能</p><p>2：提高代码的扩展性，便于后期的代码维护</p><p>8：抽象类不能创建对象，那么抽象类中是否有构造函数？</p><p>1：抽象类中一定有构造函数。主要为了初始化抽象类中的属性。通常由子类实现。</p><p>9：final和abstract是否可以同时修饰一个类？</p><p>一定不能同时修饰。</p><table><tbody><tr class=firstRow><td><p><strong>abstract</strong><strong>class</strong> Animal {</p><p>String name;</p><p>// 抽象类可以有构造函数</p><p>Animal() {</p><p>}</p><p>Animal(String name) {</p><p><strong>this</strong>.name = name;</p><p>}</p><p><strong>abstract</strong><strong>void</strong> shout();</p><p>}</p><p><strong>class</strong> Dog <strong>extends</strong> Animal {</p><p>Dog() {</p><p>}</p><p>Dog(String name) {</p><p><strong>super</strong>(name);</p><p>}</p><p><strong>void</strong> shout() {</p><p>System.out.println("旺旺");</p><p>}</p><p>}</p><p><strong>class</strong> Demo3 {</p><p><strong>public</strong><strong>static</strong><strong>void</strong> main(String[] args) {</p><p>// 抽象类不能创建对象</p><p>// Animal a=new Animal();</p><p>Dog d = <strong>new</strong> Dog("旺财");</p><p>System.out.println();</p><p>}</p><p>}</p></td></tr></tbody></table><p>2：抽象练习</p><p>1：定义抽象类MyShape（图形）</p><p>1：定义抽象方法获取图形的长度和面积</p><p>2：定义子类Rect继承父类MyShape</p><p>1：定义自身特有的长和宽（成员变量） width height;</p><p>2：实现父类未实现的函数。</p><p>3：定义子类 Circle实现父类MyShape</p><p>1：定义自身特有的半径和圆周率（使用常量）</p><p>2：实现父类为实现的方法。</p><table><tbody><tr class=firstRow><td><p>/*</p><p>}</p><p>2：抽象练习</p><p>1：定义抽象类MyShape（图形）</p><p>1：定义抽象方法获取图形的长度和面积</p><p>2：定义子类Rect继承父类MyShape</p><p>1：定义自身特有的长和宽（成员变量） width height;</p><p>2：实现父类未实现的函数。</p><p>3：定义子类 Circle实现父类MyShape</p><p>1：定义自身特有的半径和圆周率（使用常量）</p><p>2：实现父类为实现的方法。</p><p>*/</p><p><strong>abstract</strong><strong>class</strong> MyShape {</p><p><strong>abstract</strong><strong>double</strong> getLen();</p><p><strong>abstract</strong><strong>double</strong> getArea();</p><p>}</p><p><strong>class</strong> Rect <strong>extends</strong> MyShape {</p><p><strong>double</strong>width;</p><p><strong>double</strong>height;</p><p>Rect() {</p><p>}</p><p>Rect(<strong>double</strong> width, <strong>double</strong> height) {</p><p><strong>this</strong>.width = width;</p><p><strong>this</strong>.height = height;</p><p>}</p><p><strong>double</strong> getLen() {</p><p><strong>return</strong> 2 * (width + height);</p><p>}</p><p><strong>double</strong> getArea() {</p><p><strong>return</strong>width * height;</p><p>}</p><p>}</p><p><strong>class</strong> Circle <strong>extends</strong> MyShape {</p><p><strong>double</strong>r;</p><p><strong>public</strong><strong>static</strong><strong>final</strong><strong>double</strong>PI = 3.14;</p><p>Circle() {</p><p>}</p><p>Circle(<strong>double</strong> r) {</p><p><strong>this</strong>.r = r;</p><p>}</p><p><strong>double</strong> getLen() {</p><p><strong>return</strong> 2 * PI * r;</p><p>}</p><p><strong>double</strong> getArea() {</p><p><strong>return</strong>PI * r * r;</p><p>}</p><p>}</p><p><strong>class</strong> Demo4 {</p><p><strong>public</strong><strong>static</strong><strong>void</strong> main(String[] args) {</p><p>Rect r = <strong>new</strong> Rect(5, 5);</p><p>System.out.println(r.getLen());</p><p>System.out.println(r.getArea());</p><p>System.out.println();</p><p>Circle c = <strong>new</strong> Circle(5);</p><p>System.out.println(c.getLen());</p><p>System.out.println(c.getArea());</p><p>}</p><p>}</p></td></tr></tbody></table><p>1.1 <strong>抽象类注意细节</strong></p><p>抽象类可以没有抽象方法（java.awt.*的类就是这样子操作的）。</p><p>抽象类可以继承普通类与抽象类。</p><p>抽象类不能直接使用类名创建实例，但是有构造方法，构造方法是让子类进行初始化。</p><p>抽象类一定有构造方法。</p><p>abstract与其他修饰符的关系:</p><p><strong>final</strong>与abstract不能共存:</p><p>final:它的作用 修饰类代表不可以继承 修饰方法不可重写</p><p>abstract修饰类就是用来被继承的，修饰方法就是用来被重写的。</p><p><strong>static</strong> static修饰的方法可以用类名调用，</p><p>对于abstract修饰的方法没有具体的方法实现，所有不能直接调用，</p><p>也就是说不可以与static共存。</p><p><strong>private</strong></p><p>private修饰的只能在本类中使用，</p><p>abstract方法是用来被子类进行重写的，有矛盾</p><p>所有不能共存.</p><p>练习：使用抽象类计算一个矩形与圆形的面积。</p><h1>2 <strong>值交换</strong></h1><p>案例： 定义交换数值的功能函数，基本类型数据, 数组,实例对象, String。</p><p><strong>基本数据类型交换</strong></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/3e6500019eb9d4b4a4ed></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e63000339a686926987></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e66000141b0786f0682></p><p><strong>数组类型交换</strong></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e6300033a59c75e8670></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3e6300033a6210223dc5></p><p><strong>结果：交换值成功。</strong></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e6300033b6274edc7b6></p><p>原因分析：操作的是同一个数组对象。</p><p><strong>对象的值交换：</strong></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e5f00034499339ee4f1></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e6100033e97807d56b6></p><p>结果：交换值成功。</p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/3e650001a17785448599></p><p></p><p><strong>字符串的值交换:</strong></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3e6000030bd2b88a1846></p><p><strong>交换值失败。</strong></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e66000144c03a6ee66e></p><p class=标题_1><strong>接口</strong></p><p class=标题_2><strong>接口的概述</strong></p><p class=正文><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3e62000334c589ed399c></p><p class=正文>接口(interface)：usb接口，主要是使用来拓展笔记本的功能，那么在java中的接口主要是使用来拓展定义类的功能，可以弥补java中单继承的缺点。</p><p class=正文>接口的定义格式：</p><p class=正文>接口的体验</p><p class=正文>注意：可以通过javap命令查看.</p><p class=正文>接口中的所有属性 默认的修饰符是 public static final。</p><p class=正文>接口中的所有方法 默认的修饰符是 public abstract。</p><p class=正文>疑惑：干嘛不在PencilWithEraser添加remove功能函数，而要通过接口？</p><p class=正文><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3e6300033fe2079a0b28></p><p class=标题_2><strong>接口的特点</strong></p><p class=正文>类实现接口可以通过implements实现，实现接口的时候必须把接口中的所有方法实现,一个类可以实现多个接口。</p><p class=正文>接口中定义的所有的属性默认是public static final的，即静态常量既然是常量，那么定义的时候必须赋值。</p><p class=正文>接口中定义的方法不能有方法体。接口中定义的方法默认添加public abstract</p><p class=正文>有抽象函数的不一定是抽象类，也可以是接口类。</p><p class=正文>由于接口中的方法默认都是抽象的，所以不能被实例化。</p><p class=正文>对于接口而言，可以使用子类来实现接口中未被实现的功能函数。</p><p class=正文>如果实现类中要访问接口中的成员，不能使用super关键字。因为两者之间没有显示的继承关系，况且接口中的成员成员属性是静态的。可以使用接口名直接访问。</p><p class=正文>接口没有构造方法。</p><p class=正文><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3e650001a51175b536c2></p><p class=标题_2><strong>接口与类、接口之间的关系</strong></p><p class=正文>1. 大家之前都知道类与类之间的关系继承，那么接口与类之间又是怎样子的关系呢？<strong>接口与类之间是实现关系</strong>。非抽象类实现接口时，必须把接口里面的所有方法实现。类实现接口用关键字implments，类与接口之间是可以多实现的(即一个类可以实现多个接口)。</p><p class=正文>分析：</p><p class=正文>原本铅笔没有涂改功能的，但是一旦实现了Eraser接口做了实现，那么就具备了涂改功能，那么接口的作用则是拓展功能。</p><p class=正文><strong>2. 接口与接口之间的关系式继承</strong>。</p><p class=正文>接口与接口之间的关系是继承，接口可以多继承接口.</p><p class=标题_1><strong>多态</strong></p><p class=标题_2><strong>多态的概述</strong></p><p class=正文>1：什么是多态</p><p class=正文>一个对象的多种状态</p><p class=正文>（老师）（员工）（儿子）</p><p class=正文>教师 a =老钟;</p><p class=正文>员工 b= 老钟;</p><p class=正文>2：多态体现</p><p class=正文>1：Father类</p><p class=正文>1：非静态成员变量x</p><p class=正文>2：静态成员变量y</p><p class=正文>3：非静态方法eat,方法体输出父类信息</p><p class=正文>4：静态方法speak();方法体输出父类信息</p><p class=正文>2：Son类</p><p class=正文>1：非静态成员变量x</p><p class=正文>2：静态成员变量y</p><p class=正文>3：非静态方法eat，方法体输出子类信息</p><p class=正文>4：静态方法speak();方法体输出子类信息</p><p class=正文>3：Son类继承父类</p><p class=正文>1：创建Father f=new Son();</p><p class=正文>1：这就是父类引用指向了子类对象。</p><p class=正文>2：问f.x=?（非静态）</p><p class=正文>3：问f.y=?（静态）</p><p class=正文>4：问f.eat()输出的是子类还是父类信息？（非静态）</p><p class=正文>5：问f.speak()输出的是子类还是父类信息？（静态）</p><p class=正文>4：总结</p><p class=正文>1：当父类和子类具有相同的非静态成员变量，那么在多态下访问的是父类的成员变量</p><p class=正文>2：当父类和子类具有相同的静态成员变量，那么在多态下访问的是父类的静态成员变量</p><p class=正文>所以：父类和子类有相同的成员变量，多态下访问的是父类的成员变量。</p><p class=正文>3：当父类和子类具有相同的非静态方法（就是子类重写父类方法），多态下访问的是子类的成员方法。</p><p class=正文>4：当父类和子类具有相同的静态方法（就是子类重写父类静态方法），多态下访问的是父类的静态方法。</p><p class=正文>2：多态体现</p><p class=正文>1：父类引用变量指向了子类的对象</p><p class=正文>2：父类引用也可以接受自己的子类对象</p><p class=正文>3：多态前提</p><p class=正文>1：类与类之间有关系，继承或者实现</p><p class=正文>4：多态弊端</p><p class=正文>1：提高扩展性，但是只能使用父类引用指向父类成员。</p><p class=正文>5：多态特点</p><p class=正文>非静态</p><p class=正文>1：编译时期，参考引用型变量所属的类是否有调用的方法，如果有编译通过。没有编译失败</p><p class=正文>2：运行时期，参考对象所属类中是否有调用的方法。</p><p class=正文>3：总之成员函数在多态调用时，编译看左边，运行看右边。</p><p class=正文>在多态中，成员变量的特点，无论编译和运行参考左边（引用型变量所属的类）。</p><p class=正文>在多态中，静态成员函数特点，无论编译和运行都参考左边</p><p class=正文>6：多态练习</p><p class=正文>1：多态可以作为形参，接受范围更广的对象，避免函数重载过度使用。</p><p class=正文>1：定义功能，根据输出任何图形的面积和周长。</p><p class=正文>1：定义抽象类abstract MyShape</p><p class=正文>1：定义抽象方法public abstract double getArea();</p><p class=正文>2：定义抽象方法public abstract double getLen();</p><p class=正文>2：定义Rect类继承MyShape</p><p class=正文>1：定义长和宽成员变量，double width height;</p><p class=正文>2：无参构造，有参构造。</p><p class=正文>3：实现父类方法。</p><p class=正文>3：定义Cricle类继承MyShape</p><p class=正文>1：定义半径成员变量，和PI常量</p><p class=正文>2：无参构造，有参构造</p><p class=正文>3：实现父类方法。</p><p class=正文>4：定义静态方法计算任意图形的面积和周长</p><p class=正文>1：未知内容参与运算，不能确定用户传入何种图形，使用多态。</p><p class=正文>1：形参定义为 MyShape my</p><p class=正文>2：调用计算面积方法，和计算周长方法。并打印</p><p class=正文>2：使用多态特性，子类重写了父类非静态方法，会执行子类的方法。</p><p class=正文>2：多态可以作为返回值类型。</p><p class=正文>获取任意一辆车对象</p><p class=正文>1：定义汽车类，有名字和颜色，提供有参和无参构造，有运行的行为。</p><p class=正文>2：定义Bmw类，继承Car类，提供无参构造和有参构造（super父类构造），重写父类运行行为。</p><p class=正文>3：定义Benz类，继承Car类，提供无参构造和有参构造（super父类构造），重写父类运行行为。</p><p class=正文>4：定义Bsj类，继承Car类，提供无参构造和有参构造（super父类构造），重写父类运行行为。</p><p class=正文>5：定义静态方法，汽车工厂，随机生产汽车。使用多态定义方法返回值类型。</p><p class=正文>1：使用(int)Math.round(Math.random()*2); 生成0-2之间随机数。</p><p class=正文>2：使用if else 判断，指定，0,1,2 new 不同汽车 并返回。</p><p class=正文>6：调用该方法，发现多态的好处。</p><p class=正文>3：抽象类和接口都可以作为多态中的父类引用类型。</p><p class=正文>1：sun Arrays</p><p class=正文>6：多态之类型转型</p><p class=正文>1：案例定义Father类</p><p class=正文>1：定义method1和method2方法</p><p class=正文>2：定义Son类继承Father类</p><p class=正文>1：定义method1（重写父类method1）和method2方法</p><p class=正文>3：创建Father f=new Son();</p><p class=正文>1： f.method1() 调用的子类或者父类？</p><p class=正文>2： f.method2() 编译和运行是否通过？</p><p class=正文>3： f.method3() 编译和运行是否通过？（编译报错）</p><p class=正文>4：如何在多态下，使用父类引用调用子类特有方法。</p><p class=正文>1：基本类型转换：</p><p class=正文>1：自动：小->大</p><p class=正文>2：强制：大->小</p><p class=正文>2：类类型转换</p><p class=正文>前提：继承，必须有关系</p><p class=正文>1：自动：子类转父类</p><p class=正文>2：强转：父类转子类</p><p class=正文>3：类型转换</p><p class=正文>1：Son s=(Son)f</p><p class=正文>2：s.method3();</p><p class=正文>5：案例：</p><p class=正文>1：定义Animal类颜色成员变量，无参构造，有参构造，run方法</p><p class=正文>2：定义Dog类，继承Animal,定义无参构造，有参构造（使用super调用父类有参构造），Dog的特有方法ProtectHome</p><p class=正文>3：定义Fish类，继承Animal，定义无参构造，有参构造（使用super调用父类有参构造），Fish特有方法swim</p><p class=正文>4：定义Bird类，继承Animal，定义无参构造，有参构造（使用super调用父类有参构造），Bird特有方法fly</p><p class=正文>5：使用多态，Animal a=new Dog();</p><p class=正文>6：调用Dog的特有方法，ProtectHome</p><p class=正文>1：类类型转换，Dog d=(Dog)a;</p><p class=正文>2：d.protectHome</p><p class=正文>7：非多态</p><p class=正文>1：Animal a=new Animal();</p><p class=正文>2：类类型转换</p><p class=正文>Dog d=(Dog)a;</p><p class=正文>d.protectHome();</p><p class=正文>3：编译通过，运行出现异常</p><p class=正文>1：ClassCastException</p><p class=正文>8：多态例外</p><p class=正文>1：Animal a=new Dog();</p><p class=正文>2：类类型转换</p><p class=正文>1：Fish f=(Fish)a;</p><p class=正文>2：f.fish();</p><p class=正文>3：编译通过，运行异常</p><p class=正文>1：ClassCastException</p><p class=正文>4：虽然是多态，但是鸟不能转为狗，狗不能转为鱼，他们之间没有关系。</p><p class=正文>6：案例2</p><p class=正文>1：定义一功能，接收用户传入动物，根据用于传入的具体动物，执行该动物特有的方法</p><p class=正文>2：使用多态，方法形参，不能确定用户传入的是那种动物</p><p class=正文>3：使用instanceof 关键字，判断具体是何种动物，</p><p class=正文>4：类转换，执行该动物的特有方法。</p><p><strong>爆浆笔记</strong><br></p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e61000344f46062636d></p><p class=pgc-img-caption>单例设计模式的需求</p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3e6600014a1a20c1ee5c></p><p class=pgc-img-caption>静态数据的内存图</p><p><img alt=菜鸟攻略（初学者玩转多态与接口） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3e60000311bb33c5e2f9></p><p class=pgc-img-caption>线程安全问题</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'初学者','转多态','攻略'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>