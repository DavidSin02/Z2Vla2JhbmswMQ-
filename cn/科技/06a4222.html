<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SpringMVC4.2.4中文文档 第一部分 | 极客快訊</title><meta property="og:title" content="SpringMVC4.2.4中文文档 第一部分 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/509d000374a90e7c97cf"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/06a4222.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><meta property="article:published_time" content="2020-10-29T20:54:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:54:48+08:00"><meta name=Keywords content><meta name=description content="SpringMVC4.2.4中文文档 第一部分"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/06a4222.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SpringMVC4.2.4中文文档 第一部分</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt="SpringMVC4.2.4中文文档 第一部分" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/509d000374a90e7c97cf></p><p>1.1</p><p>1.2</p><p>1.3</p><p>2.1</p><p>2.1.1</p><p>2.1.2</p><p>2.2</p><p>2.2.1</p><p>2.2.2</p><p>2.2.3</p><p>2.3</p><p>2.3.1</p><p>2.3.2</p><p>2.3.3</p><p>2.3.4</p><p>2.3.5</p><p>2.4</p><p>2.4.1</p><p>2.5</p><p>2.5.1</p><p>2.5.2</p><p>2.5.3</p><p>2.5.4</p><p>2.6</p><p>Table of Contents</p><p>Part I: 目录与翻译注记(Table of contents andNotes)Introduction</p><p>目录</p><p>翻译注记</p><p>Part II: 文档内容(Documentation contents)Spring Web MVC框架简介</p><p>Spring Web MVC的新特性</p><p>允许其他MVC实现</p><p>DispatcherServlet</p><p>WebApplicationContext中特殊的Bean类型</p><p>默认的DispatcherServlet配置</p><p>DispatcherServlet的处理流程</p><p>控制器的实现</p><p>使用@Controller注解定义一个控制器</p><p>使用@RequestMapping注解映射请求路径</p><p>定义@RequestMapping注解的处理方法</p><p>异步请求的处理</p><p>对控制器测试</p><p>处理器映射</p><p>使用HandlerInterceptor拦截请求</p><p>视图解析</p><p>使用ViewResolver接口解析视图</p><p>视图链</p><p>视图重定向</p><p>内容协商解析器ContentNegotiatingViewResolver</p><p>使用闪存属性FlashAttributes</p><p>1</p><p>2.7</p><p>2.7.1</p><p>2.7.2</p><p>2.8</p><p>2.8.1</p><p>2.8.2</p><p>2.8.3</p><p>2.8.4</p><p>2.8.5</p><p>2.9</p><p>2.9.1</p><p>2.9.2</p><p>2.9.3</p><p>2.10</p><p>2.10.1</p><p>2.10.2</p><p>2.10.3</p><p>2.10.4</p><p>2.10.5</p><p>2.11</p><p>2.11.1</p><p>2.11.2</p><p>2.11.3</p><p>2.11.4</p><p>2.11.5</p><p>2.12</p><p>2.13</p><p>2.13.1</p><p>2.13.2</p><p>2.13.3</p><p>2.14</p><p>2.14.1</p><p>2.14.2</p><p>2.14.3</p><p>URI构造</p><p>为控制器和方法指定URI</p><p>在视图中为控制器和方法指定URI</p><p>地区信息</p><p>获取时区信息</p><p>Accept请求头解析器AcceptHeaderLocaleResolver</p><p>Cookie解析器CookieLocaleResolver</p><p>Session解析器SessionLocaleResolver</p><p>地区更改拦截器LocaleChangeInterceptor</p><p>主题 themes</p><p>关于主题：概览</p><p>定义主题</p><p>主题解析器</p><p>Spring的multipart（文件上传）支持</p><p>概述</p><p>使用MultipartResolver与Commons FileUpload传输文件</p><p>Servlet 3.0下的MultipartResolver</p><p>处理表单中的文件上传</p><p>处理客户端发起的文件上传请求</p><p>异常处理</p><p>处理器异常解析器HandlerExceptionHandler</p><p>@ExceptionHandler注解</p><p>处理一般的Spring MVC异常</p><p>使用@ResponseStatus注解业务异常</p><p>Servlet默认容器错误页面的定制化</p><p>Web安全</p><p>"约定优于配置"的支持</p><p>控制器类名-处理器映射ControllerClassNameHandlerMapping</p><p>模型ModelMap(ModelAndView)</p><p>视图-请求与视图名的映射</p><p>HTTP缓存支持</p><p>HTTP请求头Cache-Control</p><p>对静态资源的HTTP缓存支持</p><p>在控制器中设置Cache-Control、ETag和Last-Modified响应头</p><p>2</p><p>2.14.4</p><p>2.15</p><p>2.16</p><p>2.16.1</p><p>2.16.2</p><p>2.16.3</p><p>2.16.4</p><p>2.16.5</p><p>2.16.6</p><p>2.16.7</p><p>2.16.8</p><p>2.16.9</p><p>2.16.10</p><p>2.16.11</p><p>2.16.12</p><p>2.16.13</p><p>2.16.14</p><p>弱ETag</p><p>基于代码的Servlet容器初始化</p><p>配置Spring MVC</p><p>启用MVC Java编程配置或MVC命名空间</p><p>默认配置的定制化</p><p>转换与格式化</p><p>验证</p><p>拦截器</p><p>内容协商</p><p>视图控制器</p><p>视图解析器</p><p>资源的服务</p><p>回到默认的Servlet来进行资源服务</p><p>路径匹配</p><p>消息转换器</p><p>使用MVC Java编程进行高级定制</p><p>使用MVC命名空间进行高级定制</p><p>3</p><p>Spring MVC 4.2.4.RELEASE 中文文档</p><p>本项目翻译的是Spring MVC官方4.2.4.RELEASE版本的文档，包含原文档第21章SpringMVC部分的全部内容。译文尽力于准确传达原意，其次兼顾译文的流畅自然。至于风格和质感，则仍在努力。希望它能为读者带来查阅、学习的价值，自己时不时翻之，仍有收获。</p><p>目前多数章节的翻译已完成，剩余部分章节仍在进行。文档仍在维护状态，主要还有译文细</p><p>化、术语定义、翻译规范、内容、主页修缮、自动化部署等工作可做，issues这里有一些有意思的idea。翻译过程中遇到值得探讨的翻译问题、取舍及最终解决方案，读者可见翻译注记。</p><p>本翻译初始只是自我学习需要，逐渐完善后才有坚持完成的执念。陈丹青在《木心谈木心》</p><p>的后记中，讲到他犹豫于出版木心先生这本私房话的心境。为本译文做推广、宣传伊始，我</p><p>也开始面对我的读者，读之，感觉真挚感动。不敢自比木心，我在我的风中等消息。</p><p>&amp;mdash;&amp;mdash;2016年6月28 交房租日，8月28日 完成自动化部署后补稿</p><p>中文文档地址</p><p>主站：mvc.linesh.tw（速度和稳定性更好，样式也与原文档一致）国外Gitbook原站</p><p>原文地址</p><p>Spring MVC 4.2.4.RELEASE Documentation</p><p>其他相关翻译项目</p><p>Introduction</p><p>4</p><p>为了对目前Spring MVC部分文档翻译现状有个大致的了解，可以"Spring MVC 中文 文档 翻译"作为关键词，浏览其在google和baidu上前6页的搜索结果。其中以下项目值得留意，前两个均或完全或部分地翻译了Spring MVC部的内容，可供参考；后面三个项目未涉及SpringMVC部分的翻译。</p><p>项目 作者项目</p><p>Github 描述</p><p>Spring框架参考文档</p><p>一个团队 Github</p><p>该项目规模较大、参与人数较多。翻译内容是Spring 4.1.3.RELEASE版本全部文档，其中MVC部分的文档也翻译了一大半。其项目主页保留了与原生Spring文档较一致的样式，很不错</p><p>SpringFramework2.5翻译计</p><p>划</p><p>满江红机构 -感谢dsliu在gitbook上给我提供此版译本链接。译本是整个MVC 2.5.2版的全部文档，其中MVC的部分同样齐全</p><p>SpringFramework4.x参考文</p><p>档</p><p>waylau Github 翻译了Spring文档的简介、新特性和容器IOC部分</p><p>SpringFramework4.x中文翻</p><p>译</p><p>sunrh Github 翻译了Spring文档的简介、新特性和容器IOC部分</p><p>Spring 中文文档3.1 wizardforcel -</p><p>主页已标记废弃的项目。楼主BIO是专注单身二十年，言语间竟有一种大学宿友不是说我的宿友的即视感</p><p>友情链接</p><p>这个译本我在国内的多个站点均发表过一篇相同的推广文章，如OSC/CSDN/Iteye/博客园/掘金/v2ex/segmentfault/Githuber等。除了交付的译文本身外，还聊瞎扯了一些其他的东西。同时，关于这个翻译文档的创始、管理及自动化部署等方面，我也已将其总结成为文章。此二</p><p>篇文章是对这个项目的完整记录，均发布在我的博客上，有兴趣的读者可以前往阅读。后来</p><p>我又做了一些主页样式上的迁移、自动化了一些构建前文档预处理的工作，还有一些代码的</p><p>重构。这部分未做记录，但代码和部署构架方面我十分满意，其精华在 package.json 和构建</p><p>脚本中。</p><p>Spring MVC官方文档翻译稿发布我是如何进行Spring MVC文档翻译项目的环境搭建、项目管理及自动化构建工作的</p><p>联系方式</p><p>Introduction</p><p>5</p><p>阅读过程中的任何想法、建议、吐槽、强迫症不给译者狂点100个赞就浑身不舒服、觉得赞、觉得不赞，无论关于翻译、技术、样式等，对我来说很有意义啊我这文风竟有一种安妮宝贝</p><p>般的性冷淡感！你可以通过以下的方式联系作者我：</p><p>来Github点赞 被消费一个 在Gitbook讨论里 给我留言给这个项目提 issue给这个项目提 pull request邮箱：linesh.simpcity@gmail.com</p><p>LicenseMIT License</p><p>贡献者 Contributor感谢那些让这个项目变得更好的人们。</p><p>吕立青 Sun SongWang 易枭寒 xcatliu</p><p>Introduction</p><p>6</p><p>目录</p><p>Spring Web MVC框架简介Spring Web MVC的新特性允许其他MVC实现</p><p>DispatcherServletWebApplicationContext中特殊的Bean类型默认的DispatcherServlet配置DispatcherServlet的处理流程</p><p>控制器的实现</p><p>使用@Controller注解定义一个控制器使用@RequestMapping注解映射请求路径定义@RequestMapping注解的处理方法异步请求的处理</p><p>对控制器测试</p><p>处理器映射</p><p>使用HandlerInterceptor拦截请求视图解析</p><p>使用ViewResolver接口解析视图视图链</p><p>视图重定向</p><p>内容协商解析器ContentNegotiatingViewResolver使用闪存属性FlashAttributesURI构造</p><p>为控制器和方法指定URI在视图中为控制器和方法指定URI</p><p>地区信息</p><p>获取时区信息</p><p>Accept请求头解析器AcceptHeaderLocaleResolverCookie解析器CookieLocaleResolverSession解析器SessionLocaleResolver地区更改拦截器LocaleChangeInterceptor</p><p>主题 themes关于主题：概览</p><p>定义主题</p><p>主题解析器</p><p>Spring的multipart（文件上传）支持概述</p><p>目录</p><p>7</p><p>使用MultipartResolver与Commons FileUpload传输文件Servlet 3.0下的MultipartResolver处理表单中的文件上传</p><p>处理客户端发起的文件上传请求</p><p>异常处理</p><p>处理器异常解析器HandlerExceptionHandler@ExceptionHandler注解处理一般的Spring MVC异常使用@ResponseStatus注解业务异常Servlet默认容器错误页面的定制化</p><p>Web安全"约定优于配置"的支持</p><p>控制器类名-处理器映射ControllerClassNameHandlerMapping模型ModelMap(ModelAndView)视图-请求与视图名的映射</p><p>HTTP缓存支持HTTP请求头Cache-Control对静态资源的HTTP缓存支持在控制器中设置Cache-Control、ETag和Last-Modified响应头弱ETag</p><p>基于代码的Servlet容器初始化配置Spring MVC</p><p>启用MVC Java编程配置或MVC命名空间默认配置的定制化</p><p>转换与格式化</p><p>验证</p><p>拦截器</p><p>内容协商</p><p>视图控制器</p><p>视图解析器</p><p>资源的服务</p><p>回到默认的Servlet来进行资源服务路径匹配</p><p>消息转换器</p><p>使用MVC Java编程进行高级定制使用MVC命名空间进行高级定制</p><p>目录</p><p>8</p><p>外延丰富/有业务含义的术语翻译：直译、保留原文、词汇表</p><p>一些术语难翻的点可能有以下各个方面，比如：</p><p>具有宽泛的外延/内涵/比喻义/象征义/指代义（比如request/response，有时指一个HTTP层面的请求，有时指一个应用层级的请求，有时又特指一个请求对象，有时又具体到特</p><p>定类型 HttpServletRequest 请求对象中的内容或请求头等，又比如mapping，可以动词映射，也可以是名词什么什么映射，有时它还可以省略映射的目标或源对象)具有相对自治、完整的业务含义（比如scope、action、bean、flashmap、multipart、session/conversation等），而该业务领域在中文技术世界又尚无对应词汇</p><p>目前大致的处理方式是：</p><p>对于其外延义尚可翻（只是中文语意承载量仍然不足）的单词，采用 直译+词汇表 的翻译。词汇表即是鼠标划过停留时，会显示额外的提示信息，在提示里更详细地解释这个</p><p>词在英文中的完整含义）</p><p>对于业务含义较完备，且深刻体现在代码或命名中实在没法翻的单词，采用 保留原文+词汇表 的方式翻译</p><p>未决翻译</p><p>locales：本地化？地区？multipart：多部分（这是中文）？多路？flashmap：我彻底地慌了。不知道怎么翻好，可能需要查一下TCP/IP这一块的名词，看看有没有什么专业字词能够体现、概括的</p><p>TODOLIST翻译怎么样算好？具体到技术翻译这个上下文，全部照翻为好？谁都能意识到要适当变</p><p>通，可变通的度是多少？如果要求的是字字都有对应译，还要符合中文风格，那此种翻</p><p>译岂非只在寻求一个可能存在的"解"而失去任何可能的发挥？如果要求的是信达的同时可以体现风格，强调内在和谐胜于字句适配，那么风格的适当与否评价标准又在哪里？译</p><p>者和作者的关系是怎样的？</p><p>翻译注记</p><p>9</p><p>21.1 Spring Web MVC框架简介Spring的模型-视图-控制器（MVC）框架是围绕一个 DispatcherServlet 来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。处理器是你的应用中注解</p><p>了 @Controller 和 @RequestMapping 的类和方法，Spring为处理器方法提供了极其多样灵活的配置。Spring 3.0以后提供了 @Controller 注解机制、 @PathVariable 注解以及一些其他的特性，你可以使用它们来进行RESTful web站点和应用的开发。</p><p>"对扩展开放"是Spring Web MVC框架一个重要的设计原则，而对于Spring的整个完整框架来说，其设计原则则是"对扩展开放，对修改闭合"。</p><p>Spring Web MVC核心类库中的一些方法被定义为 final 方法。作为开发人员，你不能覆写这些方法以定制其行为。当然，不是说绝对不行，但请记住这条原则，绝大多数情</p><p>况下不是好的实践。</p><p>关于该原则的详细解释，你可以参考Seth Ladd等人所着的"深入解析Spring Web MVC与Web Flow"一书。相关信息在第117页，"设计初探（A Look At Design）"一节。或者，你可以参考：</p><p>Bob Martin所写的"开闭原则（The Open-Closed Principle）"（PDF）</p><p>你无法增强Spring MVC中的 final 方法，比如 AbstractController.setSynchronizeOnSession() 方法等。请参考10.6.1 理解AOP代理一节，其中解释了AOP代理的相关知识，论述了为什么你不能对 final 方法进行增强。</p><p>在Spring Web MVC中，你可以使用任何对象来作为命令对象或表单返回对象，而无须实现一个框架相关的接口或基类。Spring的数据绑定非常灵活：比如，它会把数据类型不匹配当成可由应用自行处理的运行时验证错误，而非系统错误。你可能会为了避免非法的类型转换在表</p><p>单对象中使用字符串来存储数据，但无类型的字符串无法描述业务数据的真正含义，并且你</p><p>还需要把它们转换成对应的业务对象类型。有了Spring的验证机制，意味着你再也不需这么做了，并且直接将业务对象绑定到表单对象上通常是更好的选择。</p><p>Spring的视图解析也是设计得异常灵活。控制器一般负责准备一个 Map 模型、填充数据、返回一个合适的视图名等，同时它也可以直接将数据写到响应流中。视图名的解析高度灵活，</p><p>支持多种配置，包括通过文件扩展名、 Accept 内容头、bean、配置文件等的配置，甚至你还可以自己实现一个视图解析器 ViewResolver 。模型（MVC中的M，model）其实是一个 Map 类型的接口，彻底地把数据从视图技术中抽象分离了出来。你可以与基于模板的渲染</p><p>技术直接整合，如JSP、Velocity和Freemarker等，或者你还可以直接生成XML、JSON、Atom以及其他多种类型的内容。 Map 模型会简单地被转换成合适的格式，比如JSP的请求属性（attribute），一个Velocity模板的模型等。</p><p>Spring Web MVC框架简介</p><p>10</p><p>Spring Web MVC框架简介</p><p>11</p><p>21.1.1 Spring Web MVC的新特性Spring Web Flow</p><p>Spring Web Flow (SWF) 意在成为web应用中的页面流(page flow)管理中最好的解决方案。</p><p>SWF在Servlet环境和Portlet环境下集成了现有的框架，如Spring MVC和JSF等。如果你的业务流程有一个贯穿始终的模型，而非单纯分立的请求，那么SWF可能是适合你的解决方案。</p><p>SWF允许你将逻辑上的页面流抽取成独立可复用的模块，这对于构建一个web应用的多个模块是有益的。that guide the user through controlled navigations that drive businessprocesses.</p><p>关于SWF的更多信息，请访问Spring Web Flow的官网。</p><p>Spring的web模块支持许多web相关的特性：</p><p>清晰的职责分离。每个角色&amp;mdash;&amp;mdash;控制器，验证器，命令对象，表单对象，模型对象， DispatcherServlet ，处理器映射，视图解析器，等等许多&amp;mdash;&amp;mdash;的工作，都可以由相应的对象来完成。</p><p>强大、直观的框架和应用bean的配置。这种配置能力包括能够从不同的上下文中进行简单的引用，比如在web控制器中引用业务对象、验证器等。强大的适配能力、非侵入性和灵活性。Spring MVC支持你定义任意的控制器方法签名，在特定的场景下你还可以添加适合的注解（比</p><p>如 @RequestParam 、 @RequestHeader 、 @PathVariable 等）</p><p>可复用的业务代码，使你远离重复代码。你可以使用已有的业务对象作为命令对象或表</p><p>单对象，而不需让它们去继承一个框架提供的什么基类。</p><p>可定制的数据绑定和验证。类型不匹配仅被认为是应用级别的验证错误，错误值、本地</p><p>化日期、数字绑定等会被保存。你不需要再在表单对象使用全String字段，然后再手动将它们转换成业务对象。</p><p>可定制的处理器映射和视图解析。处理器映射和视图解析策略从简单的基于URL配置，到精细专用的解析策略，Spring全都支持。在这一点上，Spring比一些依赖于特定技术的web框架要更加灵活。灵活的模型传递。Spring使用一个名称/值对的Map来做模型，这使得模型很容易集成、传递给任何类型的视图技术。</p><p>可定制的本地化信息、时区和主题解析。支持用/不用Spring标签库的JSP技术，支持JSTL，支持无需额外配置的Velocity模板，等等。;一个简单但功能强大的JSP标签库，通常称为Spring标签库，它提供了诸如数据绑定、主题支持等一些特性的支持。这些定制的标签为标记（markup）你的代码提供了最大程度</p><p>Spring Web MVC的新特性</p><p>12</p><p>的灵活性。关于标签库描述符（descriptor）的更多信息，请参考附录第42章 Spring JSP标签库</p><p>一个Spring 2.0开始引入的JSP表单标签库。它让你在JSP页面中编写表单简单许多。关于标签库描述符（descriptor）的更多信息，请参考附录 第43章 Spring表单的JSP标签库新增生命周期仅绑定到当前HTTP请求或HTTP会话的Bean类型。严格来说，这不是Spring MVC自身的特性，而是Spring MVC使用的上下文容器 WebApplicationContext 所提供的特性。这些bean的scope在6.5.4 请求、会话及全局会话scope一节有详细描述。</p><p>Spring Web MVC的新特性</p><p>13</p><p>21.1.2 允许其他MVC实现有些项目可能更倾向于使用非Spring的MVC框架。 许多团队希望仍然使用现有的技术栈，比如JSF等，这样他们掌握的技能和工具依然能发挥作用。</p><p>如果你确实不想使用Spring的Web MVC，但又希望能从Spring提供的一些解决方案中受益，那么将你所使用的框架和Spring进行集成也很容易。只需要在 ContextLoaderListener 中启动一个Spring的根应用上下文（root application context），然后你就可以在任何action对象中通过其 ServletContext 属性（或通过Spring对应的helper方法）取得。不需要任何侵入性的插件，因此不需要复杂的集成。从应用层的视角来看，你只是将Spring当成依赖库使用，并且将它的根应用上下文实例作为应用进入点。</p><p>即使不用Spring的Web MVC框架，你配置的其他Spring的bean和服务也都能很方便地取得。在这种场景下，Spring与其他web框架的使用不冲突。Spring只是在许多问题上提出了其他纯web MVC框架未曾提出过的解决方案，比如bean的配置、数据存取、事务处理等，仅此而已。因此，如果你只是想使用Spring的一部分特性来增强你的应用，比如Spring提供的JDBC/Hibernate事务抽象等，那么你可以将Spring作为一个中间层和/或数据存取层来使用。</p><p>允许其他MVC实现</p><p>14</p><p>21.2 DispatcherServletSpring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器， DispatcherServlet ，能做的比这更多。它与Spring IoC容器做到了无缝集成，这意味着，Spring提供的任何特性，在Spring MVC中你都可以使用。</p><p>下图展示了Spring Web MVC的 DispatcherServlet 处理请求的工作流。熟悉设计模式的朋友会发现， DispatcherServlet 应用的其实就是一个"前端控制器"的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。</p><p>DispatcherServlet 其实就是个 Servlet （它继承自 HttpServlet 基类），同样也需要在你</p><p>web应用的 web.xml 配置文件下声明。你需要在 web.xml 文件中把你希望 DispatcherServlet 处理的请求映射到对应的URL上去。这就是标准的Java EE Servlet配置；下面的代码就展示了对 DispatcherServlet 和路径映射的声明：</p><p>DispatcherServlet</p><p>15</p><p>&lt;web-app> &lt;servlet> &lt;servlet-name>example&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet></p><p>&lt;servlet-mapping> &lt;servlet-name>example&lt;/servlet-name> &lt;url-pattern>/example/*&lt;/url-pattern> &lt;/servlet-mapping>&lt;/web-app></p><p>In the preceding example, all requests starting with /example will be handled by the DispatcherServlet instance named example. In a Servlet 3.0+ environment, you alsohave the option of configuring the Servlet container programmatically. Below is the codebased equivalent of the above web.xml example:</p><p>在上面的例子中，所有路径以 /example 开头的请求都会被名字</p><p>为 example 的 DispatcherServlet 处理。在Servlet 3.0+的环境下，你还可以用编程的方式配置Servlet容器。下面是一段这种基于代码配置的例子，它与上面定义的 web.xml 配置文件是等效的。</p><p>public class MyWebApplicationInitializer implements WebApplicationInitializer {</p><p>@Override public void onStartup(ServletContext container) { ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping("/example/*"); }</p><p>}</p><p>WebApplicationInitializer 是Spring MVC提供的一个接口，它会查找你所有基于代码的配置，并应用它们来初始化Servlet 3版本以上的web容器。它有一个抽象的实现 AbstractDispatcherServletInitializer ，用以简化 DispatcherServlet 的注册工作：你只需</p><p>要指定其servlet映射（mapping）即可。若想了解更多细节，可以参考基于代码的Servlet容器初始化一节。</p><p>上面只是配置Spring Web MVC的第一步，接下来你需要配置其他的一些bean（除了 DispatcherServlet 以外的其他bean），它们也会被Spring Web MVC框架使用到。</p><p>DispatcherServlet</p><p>16</p><p>在6.15 应用上下文ApplicationContext的其他作用)一节中我们聊到，Spring中的 ApplicationContext 实例是可以有范围（scope）的。在Spring MVC中，每个 DispatcherServlet 都持有一个自己的上下文对象 WebApplicationContext ，它又继承了根</p><p>（root） WebApplicationContext 对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。</p><p>DispatcherServlet 的初始化过程中，Spring MVC会在你web应用的 WEB-INF 目录下查找一个名为[servlet-name]-servlet.xml的配置文件，并创建其中所定义的bean。如果在全局上下文中存在相同名字的bean，则它们将被新定义的同名bean覆盖。</p><p>看看下面这个 DispatcherServlet 的Servlet配置（定义于web.xml文件中）：</p><p>DispatcherServlet</p><p>17</p><p>&lt;web-app> &lt;servlet> &lt;servlet-name>golfing&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>golfing&lt;/servlet-name> &lt;url-pattern>/golfing/*&lt;/url-pattern> &lt;/servlet-mapping>&lt;/web-app></p><p>有了以上的Servlet配置文件，你还需要在应用中的 /WEB-INF/ 路径下创建一个 golfing-servlet.xml 文件，在该文件中定义所有Spring MVC相关的组件（比如bean等）。你可以通过servlet初始化参数为这个配置文件指定其他的路径（见下面的例子）：</p><p>当你的应用中只需要一个 DispatcherServlet 时，只配置一个根context对象也是可行的。</p><p>要配置一个唯一的根context对象，可以通过在servlet初始化参数中配置一个空的contextConfigLocation来做到，如下所示：</p><p>DispatcherServlet</p><p>18</p><p>&lt;web-app> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>/WEB-INF/root-context.xml&lt;/param-value> &lt;/context-param> &lt;servlet> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/servlet-mapping> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener>&lt;/web-app></p><p>WebApplicationContext 继承自 ApplicationContext ，它提供了一些web应用经常需要用到的特性。它与普通的 ApplicationContext 不同的地方在于，它支持主题的解析（详见21.9 主题Themes一小节），并且知道它关联到的是哪个servlet（它持有一个该 ServletContext 的引用）。 WebApplicationContext 被绑定在 ServletContext 中。如果需要获取它，你可以通</p><p>过 RequestContextUtils 工具类中的静态方法来拿到这个web应用的上下文 WebApplicationContext 。</p><p>DispatcherServlet</p><p>19</p><p>21.2.1 WebApplicationContext中特殊的bean类型Spring的 DispatcherServlet 使用了特殊的bean来处理请求、渲染视图等，这些特定的bean是Spring MVC框架的一部分。如果你想指定使用哪个特定的bean，你可以在web应用上下文 WebApplicationContext 中简单地配置它们。当然这只是可选的，Spring MVC维护了一个默认的bean列表，如果你没有进行特别的配置，框架将会使用默认的bean。下一小节会介绍更多的细节，这里，我们将先快速地看一下， DispatcherServlet 都依赖于哪些特殊的bean来进行它的初始化。</p><p>bean的类型 作用</p><p>HandlerMapping</p><p>处理器映射。它会根据某些规则将进入容器的请求映射到具体的处理器以及一系列前处理器和后处理器（即处理器拦截器）上。具体的规则视 HandlerMapping 类的实现不同而有所不同。其最常用的一个实现支持你在控制器上添加注解，配置请求路径。当然，也存在其他的实现。</p><p>HandlerAdapter</p><p>处理器适配器。拿到请求所对应的处理器后，适配器将负责去调用该处理器，这使得 DispatcherServlet 无需关心具体的调用细节。比方说，要调用的是一个基于注解配置的控制器，那么调用前还需要从许多注解中解析出一些相应的信息。因此， HandlerAdapter 的主要任务就是对 DispatcherServlet 屏蔽这些具体的细节。</p><p>HandlerExceptionResolver 处理器异常解析器。它负责将捕获的异常映射到不同的视图上去，此外还支持更复杂的异常处理代码。</p><p>ViewResolver 视图解析器。它负责将一个代表逻辑视图名的字符串（String）映射到实际的视图类型 View 上。</p><p>LocaleResolver & LocaleContextResolver</p><p>地区解析器 和 地区上下文解析器。它们负责解析客户端所在的地区信息甚至时区信息，为国际化的视图定制提供了支持。</p><p>ThemeResolver 主题解析器。它负责解析你web应用中可用的主题，比如，提供一些个性化定制的布局等。</p><p>MultipartResolver 解析multi-part的传输请求，比如支持通过HTML表单进行的文件上传等。</p><p>FlashMapManager FlashMap管理器。它能够存储并取回两次请求之间的 FlashMap 对象。后者可用于在请求之间传递数据，通常是在请求重定向的情境下使用。</p><p>WebApplicationContext中特殊的Bean类型</p><p>20</p><p>21.2.2 默认的DispatcherServlet配置上一小节讲到， DispatcherServlet 维护了一个列表，其中保存了其所依赖的所有bean的默认实现。这个列表保存在包 org.springframework.web.servlet 下</p><p>的 DispatcherServlet.properties 文件中。</p><p>这些特殊的bean都有一些基本的默认行为。或早或晚，你可能需要对它们提供的一些默认配置进行定制。比如说，通常你需要配置 InternalResourceViewResolver 类提供的 prefix 属</p><p>性，使其指向视图文件所在的目录。 这里需要理解的一个事情是，一旦你在web应用上下文 WebApplicationContext 中配置了某个特殊bean以后（比如 InternalResourceViewResolver ），实际上你也覆写了该bean的默认实现。比方说，如果你配置了 InternalResourceViewResolver ，那么框架就不会再使用bean ViewResolver 的默认实现。</p><p>在21.16节 Spring MVC的配置中，我们介绍了其他配置Spring MVC的方式，比如通过Java编程配置或者通过MVC XML命名空间进行配置。它们为配置一个Spring MVC应用提供了简易的开始方式，也不需要你对框架实现细节有太多了解。当然，无论你选用何种方式开始配</p><p>置，本节所介绍的一些概念都是基础且普适的，它们对你后续的学习都应有所助益。</p><p>默认的DispatcherServlet配置</p><p>21</p><p>21.2.3 DispatcherServlet的处理流程配置好 DispatcherServlet 以后，开始有请求会经过这个 DispatcherServlet 。此</p><p>时， DispatcherServlet 会依照以下的次序对请求进行处理：</p><p>首先，搜索应用的上下文对象 WebApplicationContext 并把它作为一个属性（attribute）绑定到该请求上，以便控制器和其他组件能够使用它。属性的键名默认</p><p>为 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</p><p>将地区（locale）解析器绑定到请求上，以便其他组件在处理请求（渲染视图、准备数据等）时可以获取区域相关的信息。如果你的应用不需要解析区域相关的信息，忽略它即</p><p>可</p><p>将主题（theme）解析器绑定到请求上，以便其他组件（比如视图等）能够了解要渲染哪个主题文件。同样，如果你不需要使用主题相关的特性，忽略它即可</p><p>如果你配置了multipart文件处理器，那么框架将查找该文件是不是multipart（分为多个部分连续上传）的。若是，则将该请求包装成一个 MultipartHttpServletRequest 对象，以</p><p>便处理链中的其他组件对它做进一步的处理。关于Spring对multipart文件传输处理的支持，读者可以参考21.10 Spring的multipart（文件上传）支持一小节为该请求查找一个合适的处理器。如果可以找到对应的处理器，则与该处理器关联的整</p><p>条执行链（前处理器、后处理器、控制器等）都会被执行，以完成相应模型的准备或视</p><p>图的渲染</p><p>如果处理器返回的是一个模型（model），那么框架将渲染相应的视图。若没有返回任何模型（可能是因为前后的处理器出于某些原因拦截了请求等，比如，安全问题），则框</p><p>架不会渲染任何视图，此时认为对请求的处理可能已经由处理链完成了</p><p>如果在处理请求的过程中抛出了异常，那么上下文 WebApplicationContext 对象中所定义的异</p><p>常处理器将会负责捕获这些异常。通过配置你自己的异常处理器，你可以定制自己处理异常</p><p>的方式。</p><p>Spring的 DispatcherServlet 也允许处理器返回一个Servlet API规范中定义的 最后修改时间戳（last-modification-date） 值。决定请求最后修改时间的方式很直接： DispatcherServlet 会先查找合适的处理器映射来找到请求对应的处理器，然后检测它是否实现了 LastModified 接口。若是，则调用接口的 long getLastModified(request) 方法，并将该返回值返回给客户端。</p><p>你可以定制 DispatcherServlet 的配置，具体的做法，是在 web.xml 文件中，Servlet的声明元素上添加一些Servlet的初始化参数（通过 init-param 元素）。该元素可选的参数列表如下：</p><p>DispatcherServlet的处理流程</p><p>22</p><p>可选参数 解释</p><p>contextClass 任意实现了 WebApplicationContext 接口的类。这个类会初始化该servlet所需要用到的上下文对象。默认情况下，框架会使用一个 XmlWebApplicationContext 对象。</p><p>contextConfigLocation</p><p>一个指定了上下文配置文件路径的字符串，该值会被传入给 contextClass 所指定的上下文实例对象。该字符串内可以包含多个字符串，字符串之间以逗号分隔，以此支持你进行多个上下文的配置。在多个上下文中重复定义的bean，以最后加载的bean定义为准</p><p>namespace WebApplicationContext 的命名空间。默认是 [servlet-name]-servlet</p><p>DispatcherServlet的处理流程</p><p>23</p><p>21.3 控制器(Controller)的实现...Spring implements a controller in a very abstract way, which enables you to create awide variety of controllers.</p><p>控制器作为应用程序逻辑的处理入口，它会负责去调用你已经实现的一些服务。通常，一个</p><p>控制器会接收并解析用户的请求，然后把它转换成一个模型交给视图，由视图渲染出页面最</p><p>终呈现给用户。Spring对控制器的定义非常宽松，这意味着你在实现控制器时非常自由。</p><p>Spring 2.5以后引入了基于注解的编程模型，你可以在你的控制器实现上添加 @RequestMapping 、 @RequestParam 、 @ModelAttribute 等注解。注解特性既支持基于</p><p>Servlet的MVC，也可支持基于Portlet的MVC。通过此种方式实现的控制器既无需继承某个特定的基类，也无需实现某些特定的接口。而且，它通常也不会直接依赖于Servlet或Portlet的API来进行编程，不过你仍然可以很容易地获取Servlet或Portlet相关的变量、特性和设施等。</p><p>在Spring项目的官方Github上你可以找到许多项目，它们对本节所述以后的注解支持提供了进一步增强，比如说MvcShowcase，MvcAjax，MvcBasic，PetClinic，PetCare等。</p><p>@Controllerpublic class HelloWorldController {</p><p>@RequestMapping("/helloWorld") public String helloWorld(Model model) { model.addAttribute("message", "Hello World!"); return "helloWorld"; }}</p><p>你可以看到， @Controller 注解和 @RequestMapping 注解支持多样的方法名和方法签名。在上</p><p>面这个例子中，方法接受一个 Model 类型的参数并返回一个字符串 String 类型的视图名。但</p><p>事实上，方法所支持的参数和返回值有非常多的选择，这个我们在本小节的后面部分会提</p><p>及。 @Controller 和 @RequestMapping 及其他的一些注解，共同构成了Spring MVC框架的基本实现。本节将详细地介绍这些注解，以及它们在一个Servlet环境下最常被使用到的一些场景。</p><p>控制器的实现</p><p>24</p><p>21.3.1 使用@Controller注解定义一个控制器[Original] The @Controller annotation indicates that a particular class serves the roleof a controller. Spring does not require you to extend any controller base class orreference the Servlet API. However, you can still reference Servlet-specific features ifyou need to.</p><p>@Controller 注解表明了一个类是作为控制器的角色而存在的。Spring不要求你去继承任何控制器基类，也不要求你去实现Servlet的那套API。当然，如果你需要的话也可以去使用任何与Servlet相关的特性和设施。</p><p>[Original] The @Controller annotation acts as a stereotype for the annotated class,indicating its role. The dispatcher scans such annotated classes for mapped methodsand detects @RequestMapping annotations (see the next section).</p><p>@Controller 注解可以认为是被标注类的原型（stereotype），表明了这个类所承担的角色。分派器（ DispatcherServlet ）会扫描所有注解了 @Controller 的类，检测其中通</p><p>过 @RequestMapping 注解配置的方法（详见下一小节）。</p><p>[Original] You can define annotated controller beans explicitly, using a standard Springbean definition in the dispatcher's context. However, the @Controller stereotype alsoallows for autodetection, aligned with Spring general support for detecting componentclasses in the classpath and auto-registering bean definitions for them.</p><p>当然，你也可以不使用 @Controller 注解而显式地去定义被注解的bean，这点通过标准的Spring bean的定义方式，在dispather的上下文属性下配置即可做到。但是 @Controller 原型是可以被框架自动检测的，Spring支持classpath路径下组件类的自动检测，以及对已定义bean的自动注册。</p><p>[Original] To enable autodetection of such annotated controllers, you add componentscanning to your configuration. Use the spring-context schema as shown in thefollowing XML snippet:</p><p>你需要在配置中加入组件扫描的配置代码来开启框架对注解控制器的自动检测。请使用下面</p><p>XML代码所示的spring-context schema：</p><p>使用@Controller注解定义一个控制器</p><p>25</p><p>&lt;?xml version="1.0" encoding="UTF-8"?>&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"></p><p>&lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/></p><p>&lt;!-- ... --></p><p>&lt;/beans></p><p>使用@Controller注解定义一个控制器</p><p>26</p><p>21.3.2 使用@RequestMapping注解映射请求路径</p><p>你可以使用 @RequestMapping 注解来将请求URL，如 /appointments 等，映射到整个类上或某个特定的处理器方法上。一般来说，类级别的注解负责将一个特定（或符合某种模式）的请</p><p>求路径映射到一个控制器上，同时通过方法级别的注解来细化映射，即根据特定的HTTP请求方法（"GET""POST"方法等）、HTTP请求中是否携带特定参数等条件，将请求映射到匹配的方法上。</p><p>下面这段代码示例来自Petcare，它展示了在Spring MVC中如何在控制器上使用 @RequestMapping 注解：</p><p>使用@RequestMapping注解映射请求路径</p><p>27</p><p>@Controller@RequestMapping("/appointments")public class AppointmentsController {</p><p>private final AppointmentBook appointmentBook;</p><p>@Autowired public AppointmentsController(AppointmentBook appointmentBook) { this.appointmentBook = appointmentBook; }</p><p>@RequestMapping(method = RequestMethod.GET) public Map&lt;String, Appointment> get() { return appointmentBook.getAppointmentsForToday(); }</p><p>@RequestMapping(path = "/{day}", method = RequestMethod.GET) public Map&lt;String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) { return appointmentBook.getAppointmentsForDay(day); }</p><p>@RequestMapping(path = "/new", method = RequestMethod.GET) public AppointmentForm getNewForm() { return new AppointmentForm(); }</p><p>@RequestMapping(method = RequestMethod.POST) public String add(@Valid AppointmentForm appointment, BindingResult result) { if (result.hasErrors()) { return "appointments/new"; } appointmentBook.addAppointment(appointment); return "redirect:/appointments"; }}</p><p>在上面的示例中，许多地方都使用到了 @RequestMapping 注解。第一次使用点是作用于类级别</p><p>的，它指示了所有 /appointments 开头的路径都会被映射到控制器下。 get() 方法上</p><p>的 @RequestMapping 注解对请求路径进行了进一步细化：它仅接受GET方法的请求。这样，一个请求路径为 /appointments 、HTTP方法为GET的请求，将会最终进入到这个方法被处理。 add() 方法也做了类似的细化，而 getNewForm() 方法则同时注解了能够接受的请求的</p><p>HTTP方法和路径。这种情况下，一个路径为 appointments/new 、HTTP方法为GET的请求将会被这个方法所处理。</p><p>getForDay() 方法则展示了使用 @RequestMapping 注解的另一个技巧：URI模板。（关于URI模板，请见下小节）</p><p>使用@RequestMapping注解映射请求路径</p><p>28</p><p>类级别的 @RequestMapping 注解并不是必须的。不配置的话则所有的路径都是绝对路径，而非</p><p>相对路径。以下的代码示例来自PetClinic，它展示了一个具有多个处理器方法的控制器：</p><p>@Controllerpublic class ClinicController {</p><p>private final Clinic clinic;</p><p>@Autowired public ClinicController(Clinic clinic) { this.clinic = clinic; }</p><p>@RequestMapping("/") public void welcomeHandler() { }</p><p>@RequestMapping("/vets") public ModelMap vetsHandler() { return new ModelMap(this.clinic.getVets()); }}</p><p>以上代码没有指定请求必须是GET方法还是PUT/POST或其他方法， @RequestMapping 注解默认会映射所有的HTTP请求方法。如果仅想接收某种请求方法，请在注解中指定之 @RequestMapping(method=GET) 以缩小范围。</p><p>@Controller和面向切面（AOP）代理有时，我们希望在运行时使用AOP代理来装饰控制器，比如当你直接在控制器上使用 @Transactional 注解时。这种情况下，我们推荐使用类级别（在控制器上使用）的代理方</p><p>式。这一般是代理控制器的默认做法。如果控制器必须实现一些接口，而该接口又不支持</p><p>Spring Context的回调（比如 InitializingBean , *Aware 等接口），那要配置类级别的代理就必须手动配置了。比如，原来的配置文件 &lt;tx:annotation-driven/> 需要显式配置</p><p>为 &lt;tx:annotation-driven proxy-target-class="true"/> 。</p><p>Spring MVC 3.1中新增支持@RequestMapping的一些类</p><p>They are recommended for use and even required to take advantage of new features inSpring MVC 3.1 and going forward.</p><p>使用@RequestMapping注解映射请求路径</p><p>29</p><p>Spring 3.1中新增了一组类用以增强 @RequestMapping ，分别是 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter 。我们推荐你用一用。有</p><p>部分Spring MVC 3.1之后新增的特性，这两个注解甚至是必须的。在MVC命名空间和MVCJava编程配置方式下，这组类及其新特性默认是开启的。但若你使用其他配置方式，则该特性必须手动配置才能使用。本小节将简要介绍一下，新类相比之前的一些重要变化。</p><p>在Spring 3.1之前，框架会在两个不同的阶段分别检查类级别和方法级别的请求映射&amp;mdash;&amp;mdash;首先， DefaultAnnotationHanlderMapping 会先在类级别上选中一个控制器，然后再通</p><p>过 AnnotationMethodHandlerAdapter 定位到具体要调用的方法。</p><p>[Original] With the new support classes in Spring 3.1, the RequestMappingHandlerMapping is the only place where a decision is made about whichmethod should process the request. Think of controller methods as a collection ofunique endpoints with mappings for each method derived from type and method-level @RequestMapping information.</p><p>现在有了Spring 3.1后引入的这组新类， RequestMappingHandlerMapping 成为了这两个决策实际发生的唯一一个地方。你可以把控制器中的一系列处理方法当成是一系列独立的服务节</p><p>点，每个从类级别和方法级别的 @RequestMapping 注解中获取到足够请求1路径映射信息。</p><p>[Original] This enables some new possibilities. For once a HandlerInterceptor or a HandlerExceptionResolver can now expect the Object-based handler to be a HandlerMethod , which allows them to examine the exact method, its parameters andassociated annotations. The processing for a URL no longer needs to be split acrossdifferent controllers.</p><p>这种新的处理方式带来了新的可能性。之前</p><p>的 HandlerInterceptor 或 HandlerExceptionResolver 现在可以确定拿到的这个处理器肯定是一</p><p>个 HandlerMethod 类型，因此它能够精确地了解这个方法的所有信息，包括它的参数、应用于</p><p>其上的注解等。这样，内部对于一个URL的处理流程再也不需要分隔到不同的控制器里面去执行了。</p><p>[Original] There are also several things no longer possible: [Original] Select a controllerfirst with a SimpleUrlHandlerMapping or BeanNameUrlHandlerMapping and then narrow themethod based on @RequestMapping annotations. [Original] Rely on method names as afall-back mechanism to disambiguate between two @RequestMapping methods that don'thave an explicit path mapping URL path but otherwise match equally, e.g. by HTTPmethod. In the new support classes @RequestMapping methods have to be mappeduniquely. [Original] * Have a single default method (without an explicit path mapping)with which requests are processed if no other controller method matches moreconcretely. In the new support classes if a matching method is not found a 404 error israised.</p><p>同时，也有其他的一些变化，比如有些事情就没法这么玩儿了：</p><p>使用@RequestMapping注解映射请求路径</p><p>30</p><p>先通过 SimpleUrlHandlerMapping 或 BeanNameUrlHandlerMapping 来拿到负责处理请求的控</p><p>制器，然后通过 @RequestMapping 注解配置的信息来定位到具体的处理方法；</p><p>依靠方法名称来作为选择处理方法的标准。比如说，两个注解了 @RequestMapping 的方法</p><p>除了方法名称拥有完全相同的URL映射和HTTP请求方法。在新版本下， @RequestMapping 注解的方法必须具有唯一的请求映射；</p><p>定义一个默认方法（即没有声明路径映射），在请求路径无法被映射到控制器下更精确</p><p>的方法上去时，为该请求提供默认处理。在新版本中，如果无法为一个请求找到合适的</p><p>处理方法，那么一个404错误将被抛出；</p><p>[Original] The above features are still supported with the existing support classes.However to take advantage of new Spring MVC 3.1 features you'll need to use the newsupport classes.</p><p>如果使用原来的类，以上的功能还是可以做到。但是，如果要享受Spring MVC 3.1版本带来的方便特性，你就需要去使用新的类。</p><p>[Original] ## URI Template Patterns</p><p>URI模板[Original] URI templates can be used for convenient access to selected parts of a URLin a @RequestMapping method.</p><p>URI模板可以为快速访问 @RequestMapping 中指定的URL的一个特定的部分提供很大的便利。</p><p>[Original] A URI Template is a URI-like string, containing one or more variable names.When you substitute values for these variables, the template becomes a URI. Theproposed RFC for URI Templates defines how a URI is parameterized. For example,the URI Template http://www.example.com/users/{userId} contains the variable userId.Assigning the value fred to the variable yields http://www.example.com/users/fred .</p><p>URI模板是一个类似于URI的字符串，只不过其中包含了一个或多个的变量名。当你使用实际的值去填充这些变量名的时候，模板就退化成了一个URI。在URI模板的RFC提议中定义了一个URI是如何进行参数化的。比如说，一个这个URI模板 http://www.example.com/users/{userId} 就包含了一个变量名userId。将值fred赋给这个变量名后，它就变成了一个URI： http://www.example.com/users/fred 。</p><p>[Original] In Spring MVC you can use the @PathVariable annotation on a methodargument to bind it to the value of a URI template variable:</p><p>在Spring MVC中你可以在方法参数上使用 @PathVariable 注解，将其与URI模板中的参数绑定起来：</p><p>使用@RequestMapping注解映射请求路径</p><p>31</p><p>@RequestMapping(path="/owners/{ownerId}", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) { Owner owner = ownerService.findOwner(ownerId); model.addAttribute("owner", owner); return "displayOwner";}</p><p>[Original] The URI Template " /owners/{ownerId} " specifies the variable name ownerId . When the controller handles this request, the value of ownerId is set to thevalue found in the appropriate part of the URI. For example, when a request comes infor /owners/fred , the value of ownerId is fred .</p><p>URI模板" /owners/{ownerId} "指定了一个变量，名为 ownerId 。当控制器处理这个请求的时候， ownerId 的值就会被URI模板中对应部分的值所填充。比如说，如果请求的URI是 /owners/fred ，此时变量 ownerId 的值就是 fred . `</p><p>为了处理 @PathVariables 注解，Spring MVC必须通过变量名来找到URI模板中相对应的变量。你可以在注解中直接声明：</p><p>@RequestMapping(path="/owners/{ownerId}}", method=RequestMethod.GET)public String findOwner(@PathVariable("ownerId") String theOwner, Model model) { // 具体的方法代码…}</p><p>或者，如果URI模板中的变量名与方法的参数名是相同的，则你可以不必再指定一次。只要你在编译的时候留下debug信息，Spring MVC就可以自动匹配URL模板中与方法参数名相同的变量名。</p><p>@RequestMapping(path="/owners/{ownerId}", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) { // 具体的方法代码…}</p><p>[Original] A method can have any number of @PathVariable annotations:</p><p>一个方法可以拥有任意数量的 @PathVariable 注解：</p><p>@RequestMapping(path="/owners/{ownerId}/pets/{petId}", method=RequestMethod.GET)public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) { Owner owner = ownerService.findOwner(ownerId); Pet pet = owner.getPet(petId); model.addAttribute("pet", pet); return "displayPet";}</p><p>使用@RequestMapping注解映射请求路径</p><p>32</p><p>[Original] When a @PathVariable annotation is used on a Map&lt;String, String> argument, the map is populated with all URI template variables.</p><p>当 @PathVariable 注解被应用于 Map&lt;String, String> 类型的参数上时，框架会使用所有URI模板变量来填充这个map。</p><p>[Original] A URI template can be assembled from type and path level@RequestMapping annotations. As a result the findPet() method can be invokedwith a URL such as /owners/42/pets/21 .</p><p>URI模板可以从类级别和方法级别的 @RequestMapping 注解获取数据。因此，像这样的 findPet() 方法可以被类似于 /owners/42/pets/21 这样的URL路由并调用到：</p><p>_@Controller_@RequestMapping("/owners/{ownerId}")public class RelativePathUriTemplateController {</p><p>@RequestMapping("/pets/{petId}") public void findPet(_@PathVariable_ String ownerId, _@PathVariable_ String petId, Model model) { // 方法实现体这里忽略 }</p><p>}</p><p>[Original] A @PathVariable argument can be of any simple type such as int, long, Date,etc. Spring automatically converts to the appropriate type or throws a TypeMismatchException if it fails to do so. You can also register support for parsingadditional data types. See the section called "Method Parameters And TypeConversion" and the section called "Customizing WebDataBinder initialization".</p><p>@PathVariable 可以被应用于所有 简单类型 的参数上，比如int、long、Date等类型。Spring会自动地帮你把参数转化成合适的类型，如果转换失败，就抛出一</p><p>个 TypeMismatchException 。如果你需要处理其他数据类型的转换，也可以注册自己的类。若</p><p>需要更详细的信息可以参考"方法参数与类型转换"一节和"定制WebDataBinder初始化过程"一节</p><p>带正则表达式的URI模板[Original] Sometimes you need more precision in defining URI template variables.Consider the URL "/spring-web/spring-web-3.0.5.jar" . How do you break it down intomultiple parts?</p><p>使用@RequestMapping注解映射请求路径</p><p>33</p><p>有时候你可能需要更准确地描述一个URI模板的变量，比如说这个URL： "/spring-web/spring-web-3.0.5.jar 。你要怎么把它分解成几个有意义的部分呢？</p><p>[Original] The @RequestMapping annotation supports the use of regular expressions inURI template variables. The syntax is {varName:regex} where the first part defines thevariable name and the second - the regular expression.For example:</p><p>@RequestMapping 注解支持你在URI模板变量中使用正则表达式。语法是 {varName:regex} ，其中第一部分定义了变量名，第二部分就是你所要应用的正则表达式。比如下面的代码样</p><p>例：</p><p>@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{extension:\\.[a-z]+}") public void handle(@PathVariable String version, @PathVariable String extension) { // 代码部分省略... }}</p><p>Path Patterns（不好翻，容易掉韵味）[Original] In addition to URI templates, the @RequestMapping annotation also supportsAnt-style path patterns (for example, /myPath/*.do ). A combination of URI templatevariables and Ant-style globs is also supported (e.g. /owners/*/pets/{petId} ).</p><p>除了URI模板外， @RequestMapping 注解还支持Ant风格的路径模式（如 /myPath/*.do 等）。不仅如此，还可以把URI模板变量和Ant风格的glob组合起来使用（比如 /owners/*/pets/{petId} 这样的用法等）。</p><p>路径样式的匹配(Path Pattern Comparison)[Original] When a URL matches multiple patterns, a sort is used to find the mostspecific match.</p><p>当一个URL同时匹配多个模板（pattern）时，我们将需要一个算法来决定其中最匹配的一个。</p><p>[Original] A pattern with a lower count of URI variables and wild cards is consideredmore specific. For example /hotels/{hotel}/* has 1 URI variable and 1 wild card andis considered more specific than /hotels/{hotel}/** which as 1 URI variable and 2wild cards.</p><p>使用@RequestMapping注解映射请求路径</p><p>34</p><p>URI模板变量的数目和通配符数量的总和最少的那个路径模板更准确。举个例子， /hotels/{hotel}/* 这个路径拥有一个URI变量和一个通配符，而 /hotels/{hotel}/** 这个路径则拥有一个URI变量和两个通配符，因此，我们认为前者是更准确的路径模板。</p><p>[Original] If two patterns have the same count, the one that is longer is considered morespecific. For example /foo/bar* is longer and considered more specific than /foo/* .</p><p>如果两个模板的URI模板数量和通配符数量总和一致，则路径更长的那个模板更准确。举个例子， /foo/bar* 就被认为比 /foo/* 更准确，因为前者的路径更长。</p><p>[Original] When two patterns have the same count and length, the pattern with fewerwild cards is considered more specific. For example /hotels/{hotel} is more specificthan /hotels/* .</p><p>如果两个模板的数量和长度均一致，则那个具有更少通配符的模板是更加准确的。比</p><p>如， /hotels/{hotel} 就比 /hotels/* 更精确。</p><p>[Original] There are also some additional special rules:</p><p>除此之外，还有一些其他的规则：</p><p>[Original] The default mapping pattern `/* is less specific than any other pattern.For example /api/{a}/{b}/{c}` is more specific.</p><p>[Original] A prefix pattern such as `/public/* is less specific than any other patternthat doesn't contain double wildcards. For example /public/path3/{a}/{b}/{c}` is morespecific.</p><p>默认的通配模式 /** 比其他所有的模式都更"不准确"。比方说， /api/{a}/{b}/{c} 就比默认的通配模式 /** 要更准确</p><p>前缀通配（比如 /public/** )被认为比其他任何不包括双通配符的模式更不准确。比如说， /public/path3/{a}/{b}/{c} 就比 /public/** 更准确</p><p>[Original] For the full details see AntPatternComparator in AntPathMatcher . Note thatthe PathMatcher can be customized (see Section 21.16.11, "Path Matching" in thesection on configuring Spring MVC).</p><p>更多的细节请参考这两个类： AntPatternComparator 和 AntPathMatcher 。值得一提的是，</p><p>PathMatcher类是可以配置的（见"配置Spring MVC"一节中的21.16.11 路径的匹配一节)。</p><p>带占位符的路径模式（path patterns）</p><p>使用@RequestMapping注解映射请求路径</p><p>35</p><p>[Original] Patterns in @RequestMapping annotations support ${…} placeholders againstlocal properties and/or system properties and environment variables. This may beuseful in cases where the path a controller is mapped to may need to be customizedthrough configuration. For more information on placeholders, see the javadocs of the PropertyPlaceholderConfigurer class.</p><p>@RequestMapping 注解支持在路径中使用占位符，以取得一些本地配置、系统配置、环境变量</p><p>等。这个特性有时很有用，比如说控制器的映射路径需要通过配置来定制的场景。如果想了</p><p>解更多关于占位符的信息，可以参考 PropertyPlaceholderConfigurer 这个类的文档。</p><p>Suffix Pattern Matching</p><p>后缀模式匹配</p><p>[Original] By default Spring MVC performs ".*" suffix pattern matching so that acontroller mapped to /person is also implicitly mapped to /person.* . This makes iteasy to request different representations of a resource through the URL path (e.g. /person.pdf , /person.xml ).</p><p>Spring MVC默认采用 ".*" 的后缀模式匹配来进行路径匹配，因此，一个映射到 /person 路径的控制器也会隐式地被映射到 /person.* 。这使得通过URL来请求同一资源文件的不同格式变得更简单（比如 /person.pdf ， /person.xml ）。</p><p>[Original] Suffix pattern matching can be turned off or restricted to a set of pathextensions explicitly registered for content negotiation purposes. This is generallyrecommended to minimize ambiguity with common request mappings such as /person/{id} where a dot might not represent a file extension, e.g. /person/joe@email.com vs /person/joe@email.com.json) . Furthermore as explained inthe note below suffix pattern matching as well as content negotiation may be used insome circumstances to attempt malicious attacks and there are good reasons to restrictthem meaningfully.</p><p>你可以关闭默认的后缀模式匹配，或者显式地将路径后缀限定到一些特定格式上for contentnegotiation purpose。我们推荐这样做，这样可以减少映射请求时可以带来的一些二义性，比如请求以下路径 /person/{id} 时，路径中的点号后面带的可能不是描述内容格式，比</p><p>如 /person/joe@email.com vs /person/joe@email.com.json 。而且正如下面马上要提到的，后缀模式通配以及内容协商有时可能会被黑客用来进行攻击，因此，对后缀通配进行有意义的</p><p>限定是有好处的。</p><p>使用@RequestMapping注解映射请求路径</p><p>36</p><p>[Original] See Section 21.16.11, "Path Matching" for suffix pattern matchingconfiguration and also Section 21.16.6, "Content Negotiation" for content negotiationconfiguration.</p><p>关于后缀模式匹配的配置问题，可以参考第21.16.11小节 "路径匹配"；关于内容协商的配置问题，可以参考第21.16.6小节 "内容协商"的内容。</p><p>后缀模式匹配与RFD[Original] Reflected file download (RFD) attack was first described in a paper byTrustwave in 2014. The attack is similar to XSS in that it relies on input (e.g. queryparameter, URI variable) being reflected in the response. However instead of insertingJavaScript into HTML, an RFD attack relies on the browser switching to perform adownload and treating the response as an executable script if double-clicked based onthe file extension (e.g. .bat, .cmd).</p><p>RFD(Reflected file download)攻击最先是2014年在Trustwave的一篇论文中被提出的。它与XSS攻击有些相似，因为这种攻击方式也依赖于某些特征，即需要你的输入（比如查询参数，URI变量等）等也在输出（response）中以某种形式出现。不同的是，RFD攻击并不是通过在HTML中写入JavaScript代码进行，而是依赖于浏览器来跳转到下载页面，并把特定格式（比如.bat，.cmd等）的response当成是可执行脚本，双击它就会执行。</p><p>[Original] In Spring MVC @ResponseBody and ResponseEntity methods are at riskbecause they can render different content types which clients can request including viaURL path extensions. Note however that neither disabling suffix pattern matching nordisabling the use of path extensions for content negotiation purposes alone areeffective at preventing RFD attacks.</p><p>Spring MVC的 @ResponseBody 和 ResponseEntity 方法是有风险的，因为它们会根据客户的请求&amp;mdash;&amp;mdash;包括URL的路径后缀，来渲染不同的内容类型。因此，禁用后缀模式匹配或者禁用仅为内容协商开启的路径文件后缀名携带，都是防范RFD攻击的有效方式。</p><p>[Original] For comprehensive protection against RFD, prior to rendering the responsebody Spring MVC adds a Content-Disposition:inline;filename=f.txt header tosuggest a fixed and safe download file filename. This is done only if the URL pathcontains a file extension that is neither whitelisted nor explicitly registered for contentnegotiation purposes. However it may potentially have side effects when URLs aretyped directly into a browser.</p><p>若要开启对RFD更高级的保护模式，可以在Spring MVC渲染开始请求正文之前，在请求头中增加一行配置 Content-Disposition:inline;filename=f.txt ，指定固定的下载文件的文件名。</p><p>这仅在URL路径中包含了一个文件符合以下特征的拓展名时适用：该扩展名既不在信任列表</p><p>使用@RequestMapping注解映射请求路径</p><p>37</p><p>（白名单）中，也没有被显式地被注册于内容协商时使用。并且这种做法还可以有一些副作</p><p>用，比如，当URL是通过浏览器手动输入的时候。</p><p>[Original] Many common path extensions are whitelisted by default. Furthermore RESTAPI calls are typically not meant to be used as URLs directly in browsers. Neverthelessapplications that use custom HttpMessageConverter implementations can explicitlyregister file extensions for content negotiation and the Content-Disposition header willnot be added for such extensions. See Section 21.16.6, "Content Negotiation".</p><p>很多常用的路径文件后缀默认是被信任的。另外，REST的API一般是不应该直接用做URL的。不过，你可以自己定制 HttpMessageConverter 的实现，然后显式地注册用于内容协商的文</p><p>件类型，这种情形下Content-Disposition头将不会被加入到请求头中。详见第21.16.6节中"内容协商"的内容。</p><p>[Original] This was originally introduced as part of work for CVE-2015-5211. Below areadditional recommendations from the report:</p><p>Encode rather than escape JSON responses. This is also an OWASP XSSrecommendation. For an example of how to do that with Spring see spring-jackson-owasp.Configure suffix pattern matching to be turned off or restricted to explicitlyregistered suffixes only.Configure content negotiation with the properties "useJaf" and"ignoreUnknownPathExtensions" set to false which would result in a 406 responsefor URLs with unknown extensions. Note however that this may not be an option ifURLs are naturally expected to have a dot towards the end.Add X-Content-Type-Options: nosniff header to responses. Spring Security 4does this by default.</p><p>感觉这节的翻译质量还有限，需要继续了解XSS攻击和RFD攻击的细节再翻。</p><p>矩阵变量</p><p>[Original] The URI specification RFC 3986 defines the possibility of including name-value pairs within path segments. There is no specific term used in the spec. Thegeneral "URI path parameters" could be applied although the more unique "MatrixURIs", originating from an old post by Tim Berners-Lee, is also frequently used andfairly well known. Within Spring MVC these are referred to as matrix variables.</p><p>原来的URI规范RFC 3986中允许在路径段落中携带键值对，但规范没有明确给这样的键值对定义术语。有人叫"URI路径参数"，也有叫"矩阵URI"的。后者是Tim Berners-Lee首先在其博客中提到的术语，被使用得要更加频繁一些，知名度也更高些。而在Spring MVC中，我们称</p><p>使用@RequestMapping注解映射请求路径</p><p>38</p><p>这样的键值对为矩阵变量。</p><p>[Original] Matrix variables can appear in any path segment, each matrix variableseparated with a ";" (semicolon). For example: "/cars;color=red;year=2012" . Multiplevalues may be either "," (comma) separated "color=red,green,blue" or the variablename may be repeated "color=red;color=green;color=blue" .</p><p>矩阵变量可以在任何路径段落中出现，每对矩阵变量之间使用一个分号";"隔开。比如这样的URI： "/cars;color=red;year=2012" 。多个值可以用逗号隔开 "color=red,green,blue" ，或者重复变量名多次 "color=red;color=green;color=blue" 。</p><p>[Original] If a URL is expected to contain matrix variables, the request mapping patternmust represent them with a URI template. This ensures the request can be matchedcorrectly regardless of whether matrix variables are present or not and in what orderthey are provided.</p><p>如果一个URL有可能需要包含矩阵变量，那么在请求路径的映射配置上就需要使用URI模板来体现这一点。这样才能确保请求可以被正确地映射，而不管矩阵变量在URI中是否出现、出现的次序是怎样等。</p><p>[Original] Below is an example of extracting the matrix variable "q":</p><p>下面是一个例子，展示了我们如何从矩阵变量中获取到变量"q"的值：</p><p>// GET /pets/42;q=11;r=22</p><p>@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET)public void findPet(@PathVariable String petId, @MatrixVariable int q) {</p><p>// petId == 42 // q == 11</p><p>}</p><p>[Original] Since all path segments may contain matrix variables, in some cases youneed to be more specific to identify where the variable is expected to be:</p><p>由于任意路径段落中都可以含有矩阵变量，在某些场景下，你需要用更精确的信息来指定一</p><p>个矩阵变量的位置：</p><p>使用@RequestMapping注解映射请求路径</p><p>39</p><p>// GET /owners/42;q=11/pets/21;q=22</p><p>@RequestMapping(path = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)public void findPet( @MatrixVariable(name="q", pathVar="ownerId") int q1, @MatrixVariable(name="q", pathVar="petId") int q2) {</p><p>// q1 == 11 // q2 == 22</p><p>}</p><p>[Original] A matrix variable may be defined as optional and a default value specified:</p><p>你也可以声明一个矩阵变量不是必须出现的，并给它赋一个默认值：</p><p>// GET /pets/42</p><p>@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET)public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {</p><p>// q == 1</p><p>}</p><p>[Original] All matrix variables may be obtained in a Map:</p><p>也可以通过一个Map来存储所有的矩阵变量：</p><p>// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</p><p>@RequestMapping(path = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)public void findPet( @MatrixVariable Map&lt;String, String> matrixVars, @MatrixVariable(pathVar="petId") Map&lt;String, String> petMatrixVars) {</p><p>// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23] // petMatrixVars: ["q" : 11, "s" : 23]</p><p>}</p><p>[Original] Note that to enable the use of matrix variables, you must set the removeSemicolonContent property of RequestMappingHandlerMapping to false . Bydefault it is set to true .</p><p>如果要允许矩阵变量的使用，你必须把 RequestMappingHandlerMapping 类</p><p>的 removeSemicolonContent 属性设置为 false 。该值默认是 true 的。</p><p>使用@RequestMapping注解映射请求路径</p><p>40</p><p>[Original] The MVC Java config and the MVC namespace both provide options forenabling the use of matrix variables.</p><p>MVC的Java编程配置和命名空间配置都提供了启用矩阵变量的方式。</p><p>[Original] If you are using Java config, The Advanced Customizations with MVC JavaConfig section describes how the RequestMappingHandlerMapping can be customized.</p><p>如果你是使用Java编程的方式，"MVC Java高级定制化配置"一节描述了如何对 RequestMappingHandlerMapping 进行定制。</p><p>[Original] In the MVC namespace, the &lt;mvc:annotation-driven> element has an enable-matrix-variables attribute that should be set to true . By default it is set to false .</p><p>而使用MVC的命名空间配置时，你可以把 &lt;mvc:annotation-driven> 元素下的 enable-matrix-variables 属性设置为 true 。该值默认情况下是配置为 false 的。</p><p>&lt;?xml version="1.0" encoding="UTF-8"?>&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"></p><p>&lt;mvc:annotation-driven enable-matrix-variables="true"/></p><p>&lt;/beans></p><p>可消费的媒体类型</p><p>[Original] You can narrow the primary mapping by specifying a list of consumable mediatypes. The request will be matched only if the Content-Type request header matchesthe specified media type. For example:</p><p>你可以指定一组可消费的媒体类型，缩小映射的范围。这样只有当请求头中 Content-Type 的值与指定可消费的媒体类型中有相同的时候，请求才会被匹配。比如下面这个例子：</p><p>使用@RequestMapping注解映射请求路径</p><p>41</p><p>@Controller@RequestMapping(path = "/pets", method = RequestMethod.POST, consumes="application/json")public void addPet(@RequestBody Pet pet, Model model) { // 方法实现省略}</p><p>[Original] Consumable media type expressions can also be negated as in !text/plain tomatch to all requests other than those with Content-Type of text/plain. Also considerusing constants provided in MediaType such as APPLICATION_JSON_VALUE and APPLICATION_JSON_UTF8_VALUE .</p><p>指定可消费媒体类型的表达式中还可以使用否定，比如，可以使用 !text/plain 来匹配所有请求头 Content-Type 中不含 text/plain 的请求。同时，在 MediaType 类中还定义了一些常量，比如 APPLICATION_JSON_VALUE 、 APPLICATION_JSON_UTF8_VALUE 等，推荐更多地使用它们。</p><p>[Original] The consumes condition is supported on the type and on the method level.Unlike most other conditions, when used at the type level, method-level consumabletypes override rather than extend type-level consumable types.</p><p>consumes 属性提供的是方法级的类型支持。与其他属性不同，当在类型级使用时，方法级的消费类型将覆盖类型级的配置，而非继承关系。</p><p>可生产的媒体类型</p><p>[Original] You can narrow the primary mapping by specifying a list of producible mediatypes. The request will be matched only if the Accept request header matches one ofthese values. Furthermore, use of the produces condition ensures the actual contenttype used to generate the response respects the media types specified in the producescondition. For example:</p><p>你可以指定一组可生产的媒体类型，缩小映射的范围。这样只有当请求头中 Accept 的值与指定可生产的媒体类型中有相同的时候，请求才会被匹配。而且，使用 produces 条件可以确保用于生成响应（response）的内容与指定的可生产的媒体类型是相同的。举个例子：</p><p>@Controller@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)@ResponseBodypublic Pet getPet(@PathVariable String petId, Model model) { // 方法实现省略}</p><p>使用@RequestMapping注解映射请求路径</p><p>42</p><p>[Original] Be aware that the media type specified in the produces condition can alsooptionally specify a character set. For example, in the code snippet above we specifythe same media type than the default one configured in MappingJackson2HttpMessageConverter , including the UTF-8 charset.</p><p>要注意的是，通过 condition 条件指定的媒体类型也可以指定字符集。比如在上面的小段代码中，我们还是覆写了 MappingJackson2HttpMessageConverter 类中默认配置的媒体类</p><p>型，同时，还指定了使用 UTF-8 的字符集。</p><p>[Original] Just like with consumes, producible media type expressions can be negatedas in !text/plain to match to all requests other than those with an Accept header value oftext/plain. Also consider using constants provided in MediaType such as APPLICATION_JSON_VALUE and APPLICATION_JSON_UTF8_VALUE .</p><p>与 consumes 条件类似，可生产的媒体类型表达式也可以使用否定。比如，可以使用!text/plain 来匹配所有请求头 Accept 中不含 text/plain 的请求。同时，在 MediaType 类中还定义了一些常量，比如 APPLICATION_JSON_VALUE 、 APPLICATION_JSON_UTF8_VALUE 等，推荐更多地</p><p>使用它们。</p><p>[Original] The produces condition is supported on the type and on the method level.Unlike most other conditions, when used at the type level, method-level producibletypes override rather than extend type-level producible types.</p><p>produces 属性提供的是方法级的类型支持。与其他属性不同，当在类型级使用时，方法级的消费类型将覆盖类型级的配置，而非继承关系。</p><p>请求参数与请求头的值</p><p>[Original] You can narrow request matching through request parameter conditions suchas "myParam" , "!myParam" , or "myParam=myValue" . The first two test for requestparameter presence/absence and the third for a specific parameter value. Here is anexample with a request parameter value condition:</p><p>你可以筛选请求参数的条件来缩小请求匹配范围，比</p><p>如 "myParam" 、 "!myParam" 及 "myParam=myValue" 等。前两个条件用于筛选存在/不存在某些请求参数的请求，第三个条件筛选具有特定参数值的请求。下面有个例子，展示了如何使用</p><p>请求参数值的筛选条件：</p><p>使用@RequestMapping注解映射请求路径</p><p>43</p><p>@Controller@RequestMapping("/owners/{ownerId}")public class RelativePathUriTemplateController {</p><p>@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET, params="myParam=myValue") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) { // 实际实现省略 }</p><p>}</p><p>[Original] The same can be done to test for request header presence/absence or tomatch based on a specific request header value:</p><p>同样，你可以用相同的条件来筛选请求头的出现与否，或者筛选出一个具有特定值的请求</p><p>头：</p><p>@Controller@RequestMapping("/owners/{ownerId}")public class RelativePathUriTemplateController {</p><p>@RequestMapping(path = "/pets", method = RequestMethod.GET, headers="myHeader=myValue") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) { // 方法体实现省略 }</p><p>}</p><p>[Original] Although you can match to Content-Type and Accept header values usingmedia type wild cards (for example "content-type=text/*" will match to "text/plain" and"text/html"), it is recommended to use the consumes and produces conditionsrespectively instead. They are intended specifically for that purpose.</p><p>尽管，你可以使用媒体类型的通配符（比如 "content-type=text/*"）来匹配请求头Content-Type和 Accept的值，但我们更推荐独立使用 consumes和 produces条件来筛选各自的请求。因为它们就是专门为区分这两种不同的场景而生的。</p><p>使用@RequestMapping注解映射请求路径</p><p>44</p><p>21.3.3 定义@RequestMapping注解的处理方法(handler method)使用 @RequestMapping 注解的处理方法可以拥有非常灵活的方法签名，它支持的方法参数及返</p><p>回值类型将在接下来的小节讲述。大多数参数都可以任意的次序出现，除了唯一的一个例</p><p>外： BindingResult 参数。这在下节也会详细描述。</p><p>Spring 3.1中新增了一些类，用以增强注解了 @RequestMapping 的处理方法，分别是 RequestMappingHandlerMapping 类和 RequestMappingHandlerAdapter 类。我们鼓励使用</p><p>这组新的类，如果要使用Spring 3.1及以后版本的新特性，这组类甚至是必须使用的。这些增强类在MVC的命名空间配置和MVC的Java编程方式配置中都是默认开启的，如果不是使用这两种方法，那么就需要显式地配置。</p><p>支持的方法参数类型</p><p>下面列出所有支持的方法参数类型：</p><p>请求或响应对象（Servlet API）。可以是任何具体的请求或响应类型的对象，比如， ServletRequest 或 HttpServletRequest 对象等。</p><p>HttpSession 类型的会话对象（Servlet API）。使用该类型的参数将要求这样一个session的存在，因此这样的参数永不为 null 。</p><p>存取session可能不是线程安全的，特别是在一个Servlet的运行环境中。如果应用可能有多个请求同时并发存取一个session场景，请考虑将RequestMappingHandlerAdapter类中的"synchronizeOnSession"标志设置为"true"。</p><p>org.springframework.web.context.request.WebRequest 或 org.springframework.web.context</p><p>.request.NativeWebRequest 。允许存取一般的请求参数和请求/会话范围的属性（attribute），同时无需绑定使用Servlet/Portlet的API当前请求的地区信息 java.util.Locale ，由已配置的最相关的地区解析器解析得到。在</p><p>MVC的环境下，就是应用中配置的 LocaleResolver 或 LocaleContextResolver 与当前请求绑定的时区信息 java.util.TimeZone （java 6以上的版本）/ java.time.ZoneId （java 8），由 LocaleContextResolver 解析得到用于存取请求正文的 java.io.InputStream 或 java.io.Reader 。该对象与通过Servlet API拿到的输入流/Reader是一样的用于生成响应正文的 java.io.OutputStream 或 java.io.Writer 。该对象与通过ServletAPI拿到的输出流/Writer是一样的 org.springframework.http.HttpMethod 。可以拿到HTTP请求方法包装了当前被认证用户信息的 java.security.Principal</p><p>定义@RequestMapping注解的处理方法</p><p>45</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SpringMVC4.2','文档','中文'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>