<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>包教包会！看了这篇你就会手写RPC框架了 | 极客快訊</title><meta property="og:title" content="包教包会！看了这篇你就会手写RPC框架了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/55d9c37ea69242bb9e645344cd879609"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="包教包会！看了这篇你就会手写RPC框架了"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0740d28d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>包教包会！看了这篇你就会手写RPC框架了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>本文作者：东方雨倾<br>本文链接：https://www.cnblogs.com/itoak/p/13370031.html</p></blockquote><h1 class=pgc-h-arrow-right><strong>一、学习本文你能学到什么？</strong></h1><ul><li>RPC的概念及运作流程</li><li>RPC协议及RPC框架的概念</li><li>Netty的基本使用</li><li>Java序列化及反序列化技术</li><li>Zookeeper的基本使用（注册中心）</li><li>自定义注解实现特殊业务逻辑</li><li>Java的动态代理</li><li>自定义Spring Boot Starter</li></ul><p style=text-align:start>这里只是列出了你能从RPC框架源码中能学到的东西，本文并不会每个知识点都点到，主要讲述如何手写一个RPC框架，更多细节需要读者阅读源码，文章的下方会提供源码链接哦。</p><h1 class=pgc-h-arrow-right><strong>二、RPC基础知识</strong></h1><h1 class=pgc-h-arrow-right><strong>2.1 RPC是什么？</strong></h1><p style=text-align:start>Remote Procedure Call（RPC）：远程过程调用。</p><blockquote><p>过程是什么？过程就是业务处理、计算任务，更直白理解，就是程序。（像调用本地方法一样调用远程的过程。）</p></blockquote><p style=text-align:start>RPC采用Client-Server结构，通过Request-Response消息模式实现。</p><h1 class=pgc-h-arrow-right><strong>2.2 RPC的流程</strong></h1><div class=pgc-img><img alt=包教包会！看了这篇你就会手写RPC框架了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/55d9c37ea69242bb9e645344cd879609><p class=pgc-img-caption></p></div><ul><li>客户端处理过程中调用Client stub（就像调用本地方法一样），传递参数；</li><li>Client stub将参数编组为消息，然后通过系统调用向服务端发送消息；</li><li>客户端本地操作系统将消息从客户端机器发送到服务端机器；</li><li>服务端操作系统将接收到的数据包传递给Server stub;</li><li>Server stub解组消息为参数；</li><li>Server stub再调用服务端的过程，过程执行结果以反方向的相同步骤响应给客户端。</li></ul><h1 class=pgc-h-arrow-right><strong>2.3 RPC流程中需要处理的问题</strong></h1><ul><li>Client stub、Server stub的开发；</li><li>参数如何编组为消息，以及解组消息；</li><li>消息如何发送；</li><li>过程结果如何表示、异常情况如何处理；</li><li>如何实现安全的访问控制。</li></ul><h1 class=pgc-h-arrow-right><strong>2.4 RPC协议是什么？</strong></h1><p style=text-align:start>RPC调用过程中需要将参数编组为消息进行发送，接收方需要解组消息为参数，过程处理结果同样需要经编组、解组。消息由哪些部分构成及消息的表示形式就构成了消息协议。</p><p style=text-align:start><strong>RPC调用过程中采用的消息协议称为RPC协议</strong></p><blockquote><p>RPC协议规定请求、响应消息的格式</p><p>在TCP（网络传输控制协议）上可选用或自定义消息协议来完成RPC消息交互</p><p>我们可以选用通用的标准协议（如：http、https），也也可根据自身的需要定义自己的消息协议。</p></blockquote><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right><strong>2.5 RPC框架是什么？</strong></h1><p style=text-align:start>封装好参数编组、消息解组、底层网络通信的RPC程序开发框架，带来的便捷是可以直接在其基础上只需要专注于过程代码编写。</p><p style=text-align:start>Java领域：</p><ul><li>传统的webservice框架：Apache CXF、Apache Axis2、Java自带的JAX-WS等。webservice框架大多基于标准的SOAP协议。</li><li>新兴的微服务框架：Dubbo、spring cloud、Apache Thrift等。</li></ul><h1 class=pgc-h-arrow-right><strong>三、手写RPC</strong></h1><h1 class=pgc-h-arrow-right><strong>3.1 目标</strong></h1><p style=text-align:start>我们将会写一个简易的RPC框架，暂且叫它leisure-rpc-spring-boot-starter，通过在项目中引入该starter，并简单的配置一下，项目即拥有提供远程服务的能力。</p><p style=text-align:start>编写自定义注解@Service，被它注解的类将会提供远程服务。</p><p style=text-align:start>编写自定义注解@InjectService，使用它可注入远程服务。</p><h1 class=pgc-h-arrow-right><strong>3.2 项目整体结构</strong></h1><div class=pgc-img><img alt=包教包会！看了这篇你就会手写RPC框架了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/747182abb8da4394b1b197c9d7b7d3e2><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3.3 客户端编写</strong></h1><h1 class=pgc-h-arrow-right><strong>3.3.1 客户端需要做什么？</strong></h1><p style=text-align:start>客户端想要调用远程服务，必须具备<strong>服务发现</strong>的能力；在知道有哪些服务过后，还必须有<strong>服务代理</strong>来执行服务调用；客户端想要与服务端通信，必须要有相同的<strong>消息协议</strong>；客户端想要调用远程服务，那么必须具备网络请求的能力，即<strong>网络层</strong>功能。</p><p style=text-align:start>当然，这是客户端所需的最基本的能力，其实还可以扩展的能力，例如负载均衡。</p><h1 class=pgc-h-arrow-right><strong>3.3.2 具体实现</strong></h1><p style=text-align:start>我们先看看客户端的代码结构：</p><div class=pgc-img><img alt=包教包会！看了这篇你就会手写RPC框架了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a4fa227f9f5460aa20360b0aab5b3f0><p class=pgc-img-caption></p></div><p style=text-align:start>基于面向接口编程的理念，不同角色都实现了定义了相应规范的接口。这里面我们没有发现消息协议相关内容，那是因为服务端也需要消息协议，因此抽离了出来，放在公共层。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.1 服务发现者</strong></h1><pre><code>/*** 服务发现抽象类，定义服务发现规范** @author 东方雨倾* @since 1.0.0*/public interface ServiceDiscoverer {   List&lt;Service&gt; getServices(String name);}/*** Zookeeper服务发现者，定义以Zookeeper为注册中心的服务发现细则** @author 东方雨倾* @since 1.0.0*/public class ZookeeperServiceDiscoverer implements ServiceDiscoverer {   private ZkClient zkClient;   public ZookeeperServiceDiscoverer(String zkAddress) {       zkClient = new ZkClient(zkAddress);       zkClient.setZkSerializer(new ZookeeperSerializer());  }   /**    * 使用Zookeeper客户端，通过服务名获取服务列表    * 服务名格式：接口全路径    *    * @param name 服务名    * @return 服务列表    */   @Override   public List&lt;Service&gt; getServices(String name) {       String servicePath = LeisureConstant.ZK_SERVICE_PATH +LeisureConstant.PATH_DELIMITER + name + "/service";       List&lt;String&gt; children = zkClient.getChildren(servicePath);       return Optional.ofNullable(children).orElse(new ArrayList&lt;&gt;()).stream().map(str -&gt; {           String deCh = null;           try {               deCh = URLDecoder.decode(str, LeisureConstant.UTF_8);          } catch (UnsupportedEncodingException e) {               e.printStackTrace();          }           return JSON.parseObject(deCh, Service.class);      }).collect(Collectors.toList());  }}</code></pre><p style=text-align:start>服务发现者使用Zookeeper来实现，通过ZkClient我们很容易发现已经注册在ZK上的服务。当然我们也可以使用其他组件作为注册中心，例如Redis。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.2 网络客户端</strong></h1><pre><code>/*** 网络请求客户端，定义网络请求规范** @author 东方雨倾* @since 1.0.0*/public interface NetClient {   byte[] sendRequest(byte[] data, Service service) throws InterruptedException;}/*** Netty网络请求客户端，定义通过Netty实现网络请求的细则。** @author 东方雨倾* @since 1.0.0*/public class NettyNetClient implements NetClient {   private static Logger logger = LoggerFactory.getLogger(NettyNetClient.class);   /**    * 发送请求    *    * @param data   请求数据    * @param service 服务信息    * @return 响应数据    * @throws InterruptedException 异常    */   @Override   public byte[] sendRequest(byte[] data, Service service) throwsInterruptedException {       String[] addInfoArray = service.getAddress().split(":");       String serverAddress = addInfoArray[0];       String serverPort = addInfoArray[1];       SendHandler sendHandler = new SendHandler(data);       byte[] respData;       // 配置客户端       EventLoopGroup group = new NioEventLoopGroup();       try {           Bootstrap b = new Bootstrap();           b.group(group).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true)                  .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                       @Override                       public void initChannel(SocketChannel ch) {                           ChannelPipeline p = ch.pipeline();                           p.addLast(sendHandler);                      }                  });           // 启动客户端连接           b.connect(serverAddress, Integer.parseInt(serverPort)).sync();           respData = (byte[]) sendHandler.rspData();           logger.info("SendRequest get reply: {}", respData);      } finally {           // 释放线程组资源           group.shutdownGracefully();      }       return respData;  }}/*** 发送处理类，定义Netty入站处理细则** @author 东方雨倾* @since 1.0.0*/public class SendHandler extends ChannelInboundHandlerAdapter {   private static Logger logger = LoggerFactory.getLogger(SendHandler.class);   private CountDownLatch cdl;   private Object readMsg = null;   private byte[] data;   public SendHandler(byte[] data) {       cdl = new CountDownLatch(1);       this.data = data;  }   /**    * 当连接服务端成功后，发送请求数据    *    * @param ctx 通道上下文    */   @Override   public void channelActive(ChannelHandlerContext ctx) {       logger.info("Successful connection to server：{}", ctx);       ByteBuf reqBuf = Unpooled.buffer(data.length);       reqBuf.writeBytes(data);       logger.info("Client sends message：{}", reqBuf);       ctx.writeAndFlush(reqBuf);  }   /**    * 读取数据，数据读取完毕释放CD锁    *    * @param ctx 上下文    * @param msg ByteBuf    */   @Override   public void channelRead(ChannelHandlerContext ctx, Object msg) {       logger.info("Client reads message: {}", msg);       ByteBuf msgBuf = (ByteBuf) msg;       byte[] resp = new byte[msgBuf.readableBytes()];       msgBuf.readBytes(resp);       readMsg = resp;       cdl.countDown();  }   /**    * 等待读取数据完成    *    * @return 响应数据    * @throws InterruptedException 异常    */   public Object rspData() throws InterruptedException {       cdl.await();       return readMsg;  }   @Override   public void channelReadComplete(ChannelHandlerContext ctx) {       ctx.flush();  }   @Override   public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {       // Close the connection when an exception is raised.       cause.printStackTrace();       logger.error("Exception occurred：{}", cause.getMessage());       ctx.close();  }}</code></pre><p style=text-align:start>在这里我们使用Netty来实现网络请求客户端，当然也可以使用Mina。网络请求客户端能连接远程服务端，并将编组好的请求数据发送给服务端，待服务端处理好后，又将服务端的响应数据返回给客户端。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.3 服务代理</strong></h1><pre><code>/*** 客户端代理工厂：用于创建远程服务代理类* 封装编组请求、请求发送、编组响应等操作。** @author 东方雨倾* @since 1.0.0*/public class ClientProxyFactory {   private ServiceDiscoverer serviceDiscoverer;   private Map&lt;String, MessageProtocol&gt; supportMessageProtocols;   private NetClient netClient;   private Map&lt;Class&lt;?&gt;, Object&gt; objectCache = new HashMap&lt;&gt;();   /**    * 通过Java动态代理获取服务代理类    *    * @param clazz 被代理类Class    * @param &lt;T&gt;   泛型    * @return 服务代理类    */   @SuppressWarnings("unchecked")   public &lt;T&gt; T getProxy(Class&lt;T&gt; clazz) {       return (T) this.objectCache.computeIfAbsent(clazz,               cls -&gt; newProxyInstance(cls.getClassLoader(), new Class&lt;?&gt;[]{cls}, newClientInvocationHandler(cls)));  }   // getter setter ...   /**    * 客户端服务代理类invoke函数细节实现    */   private class ClientInvocationHandler implements InvocationHandler {       private Class&lt;?&gt; clazz;       private Random random = new Random();       public ClientInvocationHandler(Class&lt;?&gt; clazz) {           super();           this.clazz = clazz;      }       @Override       public Object invoke(Object proxy, Method method, Object[] args) throwsException {           if (method.getName().equals("toString")) {               return proxy.getClass().toString();          }           if (method.getName().equals("hashCode")) {               return 0;          }           // 1、获得服务信息           String serviceName = this.clazz.getName();           List&lt;Service&gt; services = serviceDiscoverer.getServices(serviceName);           if (services == null || services.isEmpty()) {               throw new LeisureException("No provider available!");          }           // 随机选择一个服务提供者（软负载均衡）           Service service = services.get(random.nextInt(services.size()));           // 2、构造request对象           LeisureRequest req = new LeisureRequest();           req.setServiceName(service.getName());           req.setMethod(method.getName());           req.setParameterTypes(method.getParameterTypes());           req.setParameters(args);           // 3、协议层编组           // 获得该方法对应的协议           MessageProtocol protocol =supportMessageProtocols.get(service.getProtocol());           // 编组请求           byte[] data = protocol.marshallingRequest(req);           // 4、调用网络层发送请求           byte[] repData = netClient.sendRequest(data, service);           // 5解组响应消息           LeisureResponse rsp = protocol.unmarshallingResponse(repData);           // 6、结果处理           if (rsp.getException() != null) {               throw rsp.getException();          }           return rsp.getReturnValue();      }  }}</code></pre><p style=text-align:start>服务代理类由客户端代理工厂类产生，代理方式是基于Java的动态代理。在处理类ClientInvocationHandler的invoke函数中，定义了一系列的操作，包括获取服务、选择服务提供者、构造请求对象、编组请求对象、网络请求客户端发送请求、解组响应消息、异常处理等。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.4 消息协议</strong></h1><pre><code>/*** 消息协议，定义编组请求、解组请求、编组响应、解组响应规范** @author 东方雨倾* @since 1.0.0*/public interface MessageProtocol {   /**    * 编组请求    *    * @param req 请求信息    * @return 请求字节数组    * @throws Exception 编组请求异常    */   byte[] marshallingRequest(LeisureRequest req) throws Exception;   /**    * 解组请求    *    * @param data 请求字节数组    * @return 请求信息    * @throws Exception 解组请求异常    */   LeisureRequest unmarshallingRequest(byte[] data) throws Exception;   /**    * 编组响应    *    * @param rsp 响应信息    * @return 响应字节数组    * @throws Exception 编组响应异常    */   byte[] marshallingResponse(LeisureResponse rsp) throws Exception;   /**    * 解组响应    *    * @param data 响应字节数组    * @return 响应信息    * @throws Exception 解组响应异常    */   LeisureResponse unmarshallingResponse(byte[] data) throws Exception;}/*** Java序列化消息协议** @author 东方雨倾* @since 1.0.0*/public class JavaSerializeMessageProtocol implements MessageProtocol {   private byte[] serialize(Object obj) throws Exception {       ByteArrayOutputStream bout = new ByteArrayOutputStream();       ObjectOutputStream out = new ObjectOutputStream(bout);       out.writeObject(obj);       return bout.toByteArray();  }   @Override   public byte[] marshallingRequest(LeisureRequest req) throws Exception {       return this.serialize(req);  }   @Override   public LeisureRequest unmarshallingRequest(byte[] data) throws Exception {       ObjectInputStream in = new ObjectInputStream(newByteArrayInputStream(data));       return (LeisureRequest) in.readObject();  }   @Override   public byte[] marshallingResponse(LeisureResponse rsp) throws Exception {       return this.serialize(rsp);  }   @Override   public LeisureResponse unmarshallingResponse(byte[] data) throws Exception {       ObjectInputStream in = new ObjectInputStream(newByteArrayInputStream(data));       return (LeisureResponse) in.readObject();  }}</code></pre><p style=text-align:start>消息协议主要是定义了客户端如何<strong>编组请求</strong>、<strong>解组响应</strong>，服务端如何<strong>解组请求</strong>、<strong>编组响应</strong>这四个操作规范。本文提供了Java序列化与反序列化的实现，感兴趣的读者可以基于其他序列化技术实现其他消息协议（偷偷说一句：Java的序列化性能很不理想）。</p><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right><strong>3.4 服务端编写</strong></h1><h1 class=pgc-h-arrow-right><strong>3.4.1 服务端需要做什么？</strong></h1><p style=text-align:start>首先，服务端要提供远程服务，必须具备<strong>服务注册及暴露</strong>的能力；在这之后，还需要开启<strong>网络服务</strong>，供客户端连接。有些项目可能既是服务提供者，又是服务消费者，那什么时候开启服务，什么时候注入服务呢？这里我们引入一个<strong>RPC处理者</strong>的概念，由它来帮我们开启服务，以及注入服务。</p><h1 class=pgc-h-arrow-right><strong>3.4.3 具体实现</strong></h1><p style=text-align:start>先看看服务端的代码结构：</p><div class=pgc-img><img alt=包教包会！看了这篇你就会手写RPC框架了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6df64a1fc70b447da611d69af84df99c><p class=pgc-img-caption></p></div><p style=text-align:start>服务端做的事情也很简单，注册服务并暴露服务，然后开启网络服务；如果服务端也是消费者，则注入远程服务。</p><p style=text-align:start>服务注册和服务注入依赖两个自定义注解来实现：</p><ul><li>@Service：注册服务</li><li>@InjectService：注入服务</li></ul><p style=text-align:start>下面是他们的实现代码：</p><pre><code>/*** 被该注解标记的服务可提供远程RPC访问的能力** @author 东方雨倾* @since 1.0.0*/@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Service {   String value() default "";}/*** 该注解用于注入远程服务** @author 东方雨倾* @since 1.0.0*/@Target({ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface InjectService {}</code></pre><h1 class=pgc-h-arrow-right><strong>3.4.3.1 服务注册(暴露)</strong></h1><pre><code>/*** 服务注册器，定义服务注册规范** @author 东方雨倾* @since 1.0.0*/public interface ServiceRegister {   void register(ServiceObject so) throws Exception;   ServiceObject getServiceObject(String name) throws Exception;}/*** 默认服务注册器** @author 东方雨倾* @since 1.0.0*/public class DefaultServiceRegister implements ServiceRegister {   private Map&lt;String, ServiceObject&gt; serviceMap = new HashMap&lt;&gt;();   protected String protocol;   protected Integer port;   @Override   public void register(ServiceObject so) throws Exception {       if (so == null) {           throw new IllegalArgumentException("Parameter cannot be empty.");      }       this.serviceMap.put(so.getName(), so);  }   @Override   public ServiceObject getServiceObject(String name) {       return this.serviceMap.get(name);  }}/*** Zookeeper服务注册器，提供服务注册、服务暴露的能力** @author 东方雨倾* @since 1.0.0*/public class ZookeeperExportServiceRegister extends DefaultServiceRegisterimplements ServiceRegister {   /**    * Zk客户端    */   private ZkClient client;   public ZookeeperExportServiceRegister(String zkAddress, Integer port, Stringprotocol) {       client = new ZkClient(zkAddress);       client.setZkSerializer(new ZookeeperSerializer());       this.port = port;       this.protocol = protocol;  }   /**    * 服务注册    *    * @param so 服务持有者    * @throws Exception 注册异常    */   @Override   public void register(ServiceObject so) throws Exception {       super.register(so);       Service service = new Service();       String host = InetAddress.getLocalHost().getHostAddress();       String address = host + ":" + port;       service.setAddress(address);       service.setName(so.getClazz().getName());       service.setProtocol(protocol);       this.exportService(service);  }   /**    * 服务暴露    *    * @param serviceResource 需要暴露的服务信息    */   private void exportService(Service serviceResource) {       String serviceName = serviceResource.getName();       String uri = JSON.toJSONString(serviceResource);       try {           uri = URLEncoder.encode(uri, UTF_8);      } catch (UnsupportedEncodingException e) {           e.printStackTrace();      }       String servicePath = ZK_SERVICE_PATH + PATH_DELIMITER + serviceName +"/service";       if (!client.exists(servicePath)) {           client.createPersistent(servicePath, true);      }       String uriPath = servicePath + PATH_DELIMITER + uri;       if (client.exists(uriPath)) {           client.delete(uriPath);      }       client.createEphemeral(uriPath);  }}</code></pre><p style=text-align:start>这个过程其实没啥好说的，就是将指定ServiceObject对象序列化后保存到ZK上，供客户端发现。同时会将服务对象缓存起来，在客户端调用服务时，通过缓存的ServiceObject对象反射指定服务，调用方法。</p><h1 class=pgc-h-arrow-right><strong>3.4.3.2 网络服务</strong></h1><pre><code>/*** RPC服务端抽象类** @author 东方雨倾* @since 1.0.0*/public abstract class RpcServer {   /**    * 服务端口    */   protected int port;   /**    * 服务协议    */   protected String protocol;   /**    * 请求处理者    */   protected RequestHandler handler;   public RpcServer(int port, String protocol, RequestHandler handler) {       super();       this.port = port;       this.protocol = protocol;       this.handler = handler;  }   /**    * 开启服务    */   public abstract void start();   /**    * 停止服务    */   public abstract void stop();// getter setter ...}/*** Netty RPC服务端，提供Netty网络服务开启、关闭的能力** @author 东方雨倾* @since 1.0.0*/public class NettyRpcServer extends RpcServer {   private static Logger logger = LoggerFactory.getLogger(NettyRpcServer.class);   private Channel channel;   public NettyRpcServer(int port, String protocol, RequestHandler handler) {       super(port, protocol, handler);  }   @Override   public void start() {       // 配置服务器       EventLoopGroup bossGroup = new NioEventLoopGroup(1);       EventLoopGroup workerGroup = new NioEventLoopGroup();       try {           ServerBootstrap b = new ServerBootstrap();           b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 100)                  .handler(new LoggingHandler(LogLevel.INFO)).childHandler(newChannelInitializer&lt;SocketChannel&gt;() {               @Override               public void initChannel(SocketChannel ch) {                   ChannelPipeline p = ch.pipeline();                   p.addLast(new ChannelRequestHandler());              }          });           // 启动服务           ChannelFuture f = b.bind(port).sync();           logger.info("Server started successfully.");           channel = f.channel();           // 等待服务通道关闭           f.channel().closeFuture().sync();      } catch (Exception e) {           e.printStackTrace();      } finally {           // 释放线程组资源           bossGroup.shutdownGracefully();           workerGroup.shutdownGracefully();      }  }   @Override   public void stop() {       this.channel.close();  }   private class ChannelRequestHandler extends ChannelInboundHandlerAdapter {       @Override       public void channelActive(ChannelHandlerContext ctx) {           logger.info("Channel active：{}", ctx);      }       @Override       public void channelRead(ChannelHandlerContext ctx, Object msg) throwsException {           logger.info("The server receives a message: {}", msg);           ByteBuf msgBuf = (ByteBuf) msg;           byte[] req = new byte[msgBuf.readableBytes()];           msgBuf.readBytes(req);           byte[] res = handler.handleRequest(req);           logger.info("Send response：{}", msg);           ByteBuf respBuf = Unpooled.buffer(res.length);           respBuf.writeBytes(res);           ctx.write(respBuf);      }       @Override       public void channelReadComplete(ChannelHandlerContext ctx) {           ctx.flush();      }       @Override       public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {           // Close the connection when an exception is raised.           cause.printStackTrace();           logger.error("Exception occurred：{}", cause.getMessage());           ctx.close();      }  }}/*** 请求处理者，提供解组请求、编组响应等操作** @author 东方雨倾* @since 1.0.0*/public class RequestHandler {   private MessageProtocol protocol;   private ServiceRegister serviceRegister;   public RequestHandler(MessageProtocol protocol, ServiceRegister serviceRegister) {       super();       this.protocol = protocol;       this.serviceRegister = serviceRegister;  }   public byte[] handleRequest(byte[] data) throws Exception {       // 1、解组消息       LeisureRequest req = this.protocol.unmarshallingRequest(data);       // 2、查找服务对象       ServiceObject so = this.serviceRegister.getServiceObject(req.getServiceName());       LeisureResponse rsp = null;       if (so == null) {           rsp = new LeisureResponse(LeisureStatus.NOT_FOUND);      } else {           // 3、反射调用对应的过程方法           try {               Method m = so.getClazz().getMethod(req.getMethod(),req.getParameterTypes());               Object returnValue = m.invoke(so.getObj(), req.getParameters());               rsp = new LeisureResponse(LeisureStatus.SUCCESS);               rsp.setReturnValue(returnValue);          } catch (NoSuchMethodException | SecurityException | IllegalAccessException |IllegalArgumentException                   | InvocationTargetException e) {               rsp = new LeisureResponse(LeisureStatus.ERROR);               rsp.setException(e);          }      }       // 4、编组响应消息       return this.protocol.marshallingResponse(rsp);  }// getter setter ...}</code></pre><p style=text-align:start>网络服务定义了启动服务的细则，以及如何处理客户端发来的请求。</p><h1 class=pgc-h-arrow-right><strong>3.4.3.3 RPC处理者</strong></h1><pre><code>/*** RPC处理者，支持服务启动暴露、自动注入Service** @author 东方雨倾* @since 1.0.0*/public class DefaultRpcProcessor implementsApplicationListener&lt;ContextRefreshedEvent&gt; {   @Resource   private ClientProxyFactory clientProxyFactory;   @Resource   private ServiceRegister serviceRegister;   @Resource   private RpcServer rpcServer;   @Override   public void onApplicationEvent(ContextRefreshedEvent event) {       if (Objects.isNull(event.getApplicationContext().getParent())) {           ApplicationContext context = event.getApplicationContext();           // 开启服务           startServer(context);           // 注入Service           injectService(context);      }  }   private void startServer(ApplicationContext context) {       Map&lt;String, Object&gt; beans = context.getBeansWithAnnotation(Service.class);       if (beans.size() != 0) {           boolean startServerFlag = true;           for (Object obj : beans.values()) {               try {                   Class&lt;?&gt; clazz = obj.getClass();                   Class&lt;?&gt;[] interfaces = clazz.getInterfaces();                   ServiceObject so;                   if (interfaces.length != 1) {                       Service service = clazz.getAnnotation(Service.class);                       String value = service.value();                       if (value.equals("")) {                           startServerFlag = false;                           throw new UnsupportedOperationException("The exposed interface is not specific with '" + obj.getClass().getName() + "'");                      }                       so = new ServiceObject(value, Class.forName(value), obj);                  } else {                       Class&lt;?&gt; superClass = interfaces[0];                       so = new ServiceObject(superClass.getName(), superClass, obj);                  }                   serviceRegister.register(so);              } catch (Exception e) {                   e.printStackTrace();              }          }           if (startServerFlag) {               rpcServer.start();          }      }  }   private void injectService(ApplicationContext context) {       String[] names = context.getBeanDefinitionNames();       for (String name : names) {           Class&lt;?&gt; clazz = context.getType(name);           if (Objects.isNull(clazz)) continue;           Field[] fields = clazz.getDeclaredFields();           for (Field field : fields) {               InjectService injectLeisure = field.getAnnotation(InjectService.class);               if (Objects.isNull(injectLeisure)) continue;               Class&lt;?&gt; fieldClass = field.getType();               Object object = context.getBean(name);               field.setAccessible(true);               try {                   field.set(object, clientProxyFactory.getProxy(fieldClass));              } catch (IllegalAccessException e) {                   e.printStackTrace();              }          }      }  }}</code></pre><p style=text-align:start>DefaultRpcProcessor实现了ApplicationListener，并监听了ContextRefreshedEvent事件，其效果就是在Spring启动完毕过后会收到一个事件通知，基于这个机制，就可以在这里开启服务，以及注入服务。因为一切已经准备就绪了，所需要的资源都是OK的。</p><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right><strong>四、使用RPC框架</strong></h1><p style=text-align:start>框架一个很重要的特性就是要使用简单，使用该框架只需要一个条件和四个步骤即可。</p><h1 class=pgc-h-arrow-right><strong>4.1 一个条件</strong></h1><p style=text-align:start>需要准备一个Zookeeper作为注册中心，单节点即可。</p><h1 class=pgc-h-arrow-right><strong>4.2 步骤一</strong></h1><p style=text-align:start>引入Maven依赖：</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;wang.leisure&lt;/groupId&gt;   &lt;artifactId&gt;leisure-rpc-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p>不知道如何获得依赖的读者，请在源码下载后，进入项目目录下（pom.xml文件所在位置），执行 mvn install命令，即可在本地仓库生成maven依赖。</p></blockquote><h1 class=pgc-h-arrow-right><strong>4.3 步骤二</strong></h1><p style=text-align:start>在你的项目配置文件（application.properties）中配置注册中心地址，例如：</p><pre><code>leisure.rpc.register-address=192.168.199.241:2181</code></pre><h1 class=pgc-h-arrow-right><strong>4.4 步骤三</strong></h1><p style=text-align:start>将你的远程服务使用@Service注解，例如：</p><pre><code>import wang.leisure.rpc.annotation.Service;@Servicepublic class UserServiceImpl implements UserService {   @Override   public ApiResult&lt;User&gt; getUser(Long id) {       User user = getFromDbOrCache(id);       return ApiResult.success(user);  }   private User getFromDbOrCache(Long id) {       return new User(id, "东方雨倾", 1, "https://leisure.wang");  }}</code></pre><h1 class=pgc-h-arrow-right><strong>4.5 步骤四</strong></h1><p style=text-align:start>使用注解@InjectService注入远程服务，例如：</p><pre><code>@RestController@RequestMapping("/index/")public class IndexController {   @InjectService   private UserService userService;   /**    * 获取用户信息    * http://localhost:8080/index/getUser?id=1    *    * @param id 用户id    * @return 用户信息    */   @GetMapping("getUser")   public ApiResult&lt;User&gt; getUser(Long id) {       return userService.getUser(id);  }}</code></pre><h1 class=pgc-h-arrow-right><strong>五、源码下载</strong></h1><p style=text-align:start>框架源码：<u>https://github.com/OakWang/leisure-rpc-spring-boot-starter.git</u></p><p style=text-align:start>示例源码：<u>https://github.com/OakWang/leisure-rpc-example.git</u></p><h1 class=pgc-h-arrow-right><strong>六、总结</strong></h1><p>希望读者能够真正动手去试一试，只有实践了才能知道里面的运作逻辑。笔者也是花了两个星期才把代码跟文章整理好，并不是因为这个东西难，而是因为没时间，苦逼的程序猿</p><p>如果文章对你有帮助，希望多多支持。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'包教','包会','这篇'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>