<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SynchronousQueue 同步队列入门使用&源码详解 | 极客快訊</title><meta property="og:title" content="SynchronousQueue 同步队列入门使用&源码详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/07f82832.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><meta property="article:published_time" content="2020-11-14T21:06:28+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:28+08:00"><meta name=Keywords content><meta name=description content="SynchronousQueue 同步队列入门使用&源码详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/07f82832.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SynchronousQueue 同步队列入门使用&源码详解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong><span style="color:#3e3e3e;--tt-darkmode-color: #A3A3A3">SynchronousQueue</span></strong></h1><div class=pgc-img><img alt="SynchronousQueue 同步队列入门使用&源码详解" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f><p class=pgc-img-caption></p></div><p><span style="color:#999;--tt-darkmode-color: #999999">思维导图</span></p><h1 class=pgc-h-arrow-right><strong>是什么</strong></h1><p>SynchronousQueue 是这样一种阻塞队列，其中每个 put 必须等待一个 take，反之亦然。</p><p>简而言之：线程安全，阻塞。</p><h1 class=pgc-h-arrow-right><strong>入门案例</strong></h1><p>我们定义两个线程，一个负责写入，一个负责读取。</p><pre><code>import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * @author 老马啸西风 * @since 1.0.0 */public class SynchronousQueueDemo {    public static void main(String[] args) {        SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;();        new Writer(queue).start();        new Reader(queue).start();    }    private static class Writer extends Thread {        SynchronousQueue&lt;Integer&gt; queue;        public Writer(SynchronousQueue&lt;Integer&gt; queue) {            this.queue = queue;        }        @Override        public void run() {            for (int i = 0; i &lt; 5; i++) {                System.out.println("开始设置第 " + i + " 个元素");                try {                    TimeUnit.SECONDS.sleep(2);                    queue.put(i);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    /**     * 消息读取者     */    private static class Reader extends Thread {        SynchronousQueue&lt;Integer&gt; queue;        public Reader(SynchronousQueue&lt;Integer&gt; queue) {            this.queue = queue;        }        @Override        public void run() {            while (true) {                try {                    System.out.println("读取信息: " + queue.take() + "\n");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><p>对应的日志信息如下：</p><pre><code>开始设置第 0 个元素开始设置第 1 个元素读取信息: 0开始设置第 2 个元素读取信息: 1开始设置第 3 个元素读取信息: 2开始设置第 4 个元素读取信息: 3读取信息: 4</code></pre><p>可以看到当元素被设置之后，就会被立刻读取。这个在实际使用过程中还是非常便利的，比轮训优雅多了。</p><h1 class=pgc-h-arrow-right><strong>源码分析</strong></h1><h1 class=pgc-h-arrow-right><strong>类定义</strong></h1><pre><code>public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;    implements BlockingQueue&lt;E&gt;, java.io.Serializable {    // 转换类实现，也是最核心的一个属性。    // 后面会详细讲解        private transient volatile Transferer&lt;E&gt; transferer;}</code></pre><p>实现了阻塞队列接口，继承自 AbstractQueue 抽象队列。</p><p>实际上对应的 put/take 方法，经过 transfer 的封装之后，都变得非常简单。</p><p>我们本文的核心在于对 Transferer 的解析。</p><h1 class=pgc-h-arrow-right><strong>构造器</strong></h1><p>SynchronousQueue 也是支持是否为公平锁模式的。</p><p>默认为非公平模式。</p><p>是否公平取决于使用的 Transfer 实现子类。</p><pre><code>public SynchronousQueue() {    this(false);}public SynchronousQueue(boolean fair) {    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();}</code></pre><h1 class=pgc-h-arrow-right><strong>put 方法</strong></h1><pre><code>/** * Adds the specified element to this queue, waiting if necessary for * another thread to receive it. */public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    if (transferer.transfer(e, false, 0) == null) {        Thread.interrupted();        throw new InterruptedException();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>take 方法</strong></h1><pre><code>/** * Retrieves and removes the head of this queue, waiting if necessary * for another thread to insert it. */public E take() throws InterruptedException {    E e = transferer.transfer(null, false, 0);    if (e != null)        return e;    Thread.interrupted();    throw new InterruptedException();}</code></pre><h1 class=pgc-h-arrow-right><strong>算法笔记</strong></h1><p>下面是源码中的一部分算法笔记，不会出现在文档中。</p><p>此类实现W. N. Scherer III和M. L. Scott所着的“不带条件同步的并发对象的无阻塞”中描述的双堆栈和双队列算法的扩展。</p><p>第十八届年度大会 （2004年10月，分布式计算）（另请参见 http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/dals.html ）。</p><p>（Lifo）堆栈用于非公平模式，（Fifo）队列用于公平模式。</p><p>两者的性能通常相似。</p><p><strong>Fifo通常在竞争下支持更高的吞吐量，但是Lifo在常见应用程序中保持更高的线程局部性</strong>。</p><p>双队列（和类似的堆栈）是在任何给定时间保存“数据”（由put操作提供的项，或“请求”）的插槽，表示 take 操作，或者为空。</p><p>对 <span style="color:#e96900;--tt-darkmode-color: #E96900"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">fulfill</span></span> 的调用（即，从保存数据的队列中请求元素的调用，反之亦然）使互补节点出队。</p><div class=pgc-img><img alt="SynchronousQueue 同步队列入门使用&源码详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dfc14e8447194971a091db0b7532f7ae><p class=pgc-img-caption></p></div><p><span style="color:#999;--tt-darkmode-color: #999999">互补节点</span></p><p>这些队列最有趣的功能是，任何操作都可以弄清楚队列所处的模式，并且无需锁就可以采取相应的措施。</p><p>队列和堆栈都扩展了抽象类Transferer，它们定义了执行放置或取出操作的单个方法。</p><p>将它们统一为一个方法，因为在双重数据结构中，放置和取出操作是对称的，因此几乎所有代码都可以合并。</p><p>最终的传输方法长远来看，但比分解成几乎重复的部分要容易得多。</p><p>队列和堆栈数据结构在概念上有很多相似之处，但具体细节很少。</p><p>为简单起见，它们保持不同，以便以后可以分别发展。</p><p>此处的算法与上述论文中的版本不同，在于扩展了它们以用于同步队列以及处理取消。</p><p>主要区别包括：</p><ol start=1><li>原始算法使用带位标记的指针，但此处的算法使用节点中的模式位，从而导致了许多进一步的调整。</li><li>SynchronousQueues必须阻塞等待实现的线程。</li><li>支持通过超时和中断进行取消，包括从列表中清除已取消的节点/线程，以避免垃圾保留和内存耗尽。</li></ol><p>阻塞主要使用LockSupport park/unpark 来完成，除了看起来像是首先要实现的下一个要暂存的节点外，它还会旋转一点（仅在多处理器上）。</p><p>在非常繁忙的同步队列上，旋转可以大大提高吞吐量。</p><p>在不那么忙碌的队列上，自旋的量很小，不足以引起注意。</p><p>在队列和堆栈中以不同的方式进行清理。</p><p>对于队列，我们几乎总是可以在取消节点后的 O(1) 时间内立即删除该节点（进行模数重试以进行一致性检查）。</p><p>但是，如果可能将其固定为当前尾巴，则必须等待直到随后的一些取消。</p><p>对于堆栈，我们需要潜在的 O(n) 遍历，以确保可以删除节点，但这可以与其他访问堆栈的线程同时运行。</p><p>尽管垃圾回收会处理大多数会使非阻塞算法复杂化的节点回收问题，但还是要小心“忘记”对数据，其他节点和可能被阻塞线程长期保留的线程的引用。</p><p><strong>如果设置为null会与主要算法冲突，则可以通过将节点的链接更改为现在指向节点本身来完成。</strong></p><p>ps: 这是一个不错的技巧。</p><p>对于Stack节点，这不会发生太多（因为阻塞的线程不会挂在旧的头部指针上），但是必须积极地忘记Queue节点中的引用，以防止自到达以来任何节点都曾引用的所有内容都可以访问。</p><h1 class=pgc-h-arrow-right><strong>内部变量</strong></h1><p>有几个关于内核数等的相关变量。</p><pre><code>/** ** 内核数，用于自旋锁控制。** 单核是不能自旋的。**** @author 老马啸西风*/static final int NCPUS = Runtime.getRuntime().availableProcessors();/** * 最大的自旋次数，如果是单核，不进行自旋。 * 如果是多核，最多旋转 32 次。 */static final int maxTimedSpins = (NCPUS &lt; 2) ? 0 : 32;/** * 在阻塞未定时的等待之前旋转的次数。 * 此值大于定时值，因为非定时等待旋转得更快，因为他们不需要每次旋转都检查时间。 */static final int maxUntimedSpins = maxTimedSpins * 16;/** * 旋转秒级比使用定时停泊更快的纳秒数。  * 粗略的估计就足够了。 */static final long spinForTimeoutThreshold = 1000L;</code></pre><h1 class=pgc-h-arrow-right><strong>Transferer</strong></h1><h1 class=pgc-h-arrow-right><strong>接口定义</strong></h1><p>一个非常简单的方法。</p><pre><code>abstract static class Transferer&lt;E&gt; {    abstract E transfer(E e, boolean timed, long nanos);}</code></pre><p>这里就像算法笔记中说的，使用了队列（FIFO） 和 堆栈（FILO）</p><div class=pgc-img><img alt="SynchronousQueue 同步队列入门使用&源码详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2983104c9993471ab898265885cb4779><p class=pgc-img-caption></p></div><p><span style="color:#999;--tt-darkmode-color: #999999">阻塞队列</span></p><h1 class=pgc-h-arrow-right><strong>基于队列</strong></h1><pre><code>/*** * 这扩展了Scherer-Scott双队列算法，其不同之处在于，通过使用节点内的模式而不是标记的指针来实现。** 该算法比堆栈的算法更简单，因为实现者节点，并且匹配是通过CAS将QNode.item字段从非null转换为null（用于放置）或反之亦然（用于take）来完成的。* * @author 老马啸西风* */static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; {    /** 头结点 */    transient volatile QNode head;    /** 尾节点 */    transient volatile QNode tail;    /**     * 对已取消节点的引用，该节点可能尚未取消与队列的链接，因为它是取消时最后插入的节点。     */    transient volatile QNode cleanMe;    TransferQueue() {        QNode h = new QNode(null, false); // initialize to dummy node.        head = h;        tail = h;    }    /**     * 尝试以 cas nh 作为新元素； 如果成功，请取消链接旧头的下一个节点，以免造成垃圾遗留。     */    void advanceHead(QNode h, QNode nh) {        if (h == head &amp;&amp;            UNSAFE.compareAndSwapObject(this, headOffset, h, nh))            h.next = h; // forget old next    }    /**     * T尝试设置 nt 作为新的尾巴元素     */    void advanceTail(QNode t, QNode nt) {        if (tail == t)            UNSAFE.compareAndSwapObject(this, tailOffset, t, nt);    }    /**     * 尝试 CAS 设置 cleanMe 元素     */    boolean casCleanMe(QNode cmp, QNode val) {        return cleanMe == cmp &amp;&amp;            UNSAFE.compareAndSwapObject(this, cleanMeOffset, cmp, val);    }    // Unsafe 相关属性    // 这个很多并发类中都有，基本是固定的。    private static final sun.misc.Unsafe UNSAFE;    private static final long headOffset;    private static final long tailOffset;    private static final long cleanMeOffset;    static {        try {            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; k = TransferQueue.class;            headOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("head"));            tailOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("tail"));            cleanMeOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("cleanMe"));        } catch (Exception e) {            throw new Error(e);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>节点定义</strong></h1><pre><code>/** Node class for TransferQueue. */static final class QNode {    volatile QNode next;          // next node in queue    volatile Object item;         // CAS'ed to or from null    volatile Thread waiter;       // to control park/unpark    final boolean isData;    QNode(Object item, boolean isData) {        this.item = item;        this.isData = isData;    }    // 基于 CAS 的设置方法    boolean casNext(QNode cmp, QNode val) {        return next == cmp &amp;&amp;            UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);    }    boolean casItem(Object cmp, Object val) {        return item == cmp &amp;&amp;            UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);    }    /**     * 尝试通过 CAS 取消元素的引用     */    void tryCancel(Object cmp) {        UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);    }    // 判断是否已经取消    boolean isCancelled() {        return item == this;    }    /**     * 下一个指针指向当前类，说明什么？     * 说明节点已经不再队列中     */    boolean isOffList() {        return next == this;    }    // Unsafe 的相关实现    private static final sun.misc.Unsafe UNSAFE;    private static final long itemOffset;    private static final long nextOffset;    static {        try {            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; k = QNode.class;            itemOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("item"));            nextOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("next"));        } catch (Exception e) {            throw new Error(e);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>transfer 核心方法</strong></h1><p>基本算法是循环尝试执行以下两个操作之一：</p><ol start=1><li>如果队列明显为空或持有相同模式的节点，请尝试将节点添加到等待队列中，等待被实现（或取消）并返回匹配项。</li><li>如果队列显然包含等待项，并且此调用是互补模式，请尝试通过对等待节点的CAS'ing item字段进行出队并使其出队，然后返回匹配项来实现。</li></ol><p>在每种情况下，一路检查并尝试帮助其他停滞/缓慢的线程推进头和尾。</p><p>循环以空检查开始，以防止看到未初始化的头或尾值。</p><p>这在当前的 SynchronousQueue 中永远不会发生，但是如果调用者持有对传输者的非易失性/最终引用（non-volatile/final），则可能会发生这种情况。</p><p>无论如何，这里的检查是因为将空检查放在循环的顶部，通常比隐式散布（implicitly interspersed）检查要快。</p><pre><code>/** * 放入或者获取一个元素 * @author 老马啸西风 */@SuppressWarnings("unchecked")E transfer(E e, boolean timed, long nanos) {    QNode s = null; // constructed/reused as needed    boolean isData = (e != null);    for (;;) {        QNode t = tail;        QNode h = head;        // 元素未初始化完成，自旋。        if (t == null || h == null)                    continue;                             // 如果为空，或者持有相同模式的节点        if (h == t || t.isData == isData) {             QNode tn = t.next;            // 元素被其他线程修改，重来            if (t != tail)                                 continue;            // 尝试节点加入到 tail                if (tn != null) {                            advanceTail(t, tn);                continue;            }            // 时间不等人，直接返回 null            if (timed &amp;&amp; nanos &lt;= 0)                    return null;            // 设置新元素失败，重来            if (s == null)                s = new QNode(e, isData);            if (!t.casNext(null, s))                        continue;            // 添加到尾部等待            advanceTail(t, s);                        // 旋转/阻塞，直到满足节点s为止。            Object x = awaitFulfill(s, e, timed, nanos);            // 等待被取消，清空元素，并且返回 null            if (x == s) {                   clean(t, s);                return null;            }            // 元素已经不再队列中了，            if (!s.isOffList()) {           // not already unlinked                // 设置 s 为新的头结点                advanceHead(t, s);                    if (x != null)              // and forget fields                    s.item = s;                s.waiter = null;            }            return (x != null) ? (E)x : e;        } else {                   // 互补模式 complementary-mode             // 这里就是上面说的第二种算法模式                                 QNode m = h.next;                          // 已经被其他线程修改，重来            if (t != tail || m == null || h != head)                continue;                   // inconsistent read            Object x = m.item;            // 元素 CAS 失败，执行出队，进行重试。            if (isData == (x != null) ||    // m already fulfilled                x == m ||                   // m cancelled                !m.casItem(x, e)) {         // lost CAS                advanceHead(h, m);          // dequeue and retry                continue;            }            // 成功设置            advanceHead(h, m);              // successfully fulfilled            LockSupport.unpark(m.waiter);            return (x != null) ? (E)x : e;        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>awaitFulfill 等待直到节点满足条件</strong></h1><pre><code>/** * 旋转/阻止，直到满足节点s为止。 * * @param s the waiting node * @param e the comparison value for checking match * @param timed true if timed wait * @param nanos timeout value * @return matched item, or s if cancelled * @author 老马啸西风 */Object awaitFulfill(QNode s, E e, boolean timed, long nanos) {    /* Same idea as TransferStack.awaitFulfill */    // deadline 是第一生产力    // 我们设置一个超时时间，避免一直等待下去。    final long deadline = timed ? System.nanoTime() + nanos : 0L;    // 这 3 目运算符用的人脑袋疼。    Thread w = Thread.currentThread();    int spins = ((head.next == s) ?                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);    for (;;) {        // 如果当前线程被打断，尝试取消。        if (w.isInterrupted())            s.tryCancel(e);        Object x = s.item;        // 如果 s.item 与 e 不等，直接返回 x        if (x != e)            return x;        if (timed) {            // 计算超时时间，超时之后尝试取消。            nanos = deadline - System.nanoTime();            if (nanos &lt;= 0L) {                s.tryCancel(e);                continue;            }        }        // 更新自旋次数        if (spins &gt; 0)            --spins;        // 如果 waiter 为 null,设置为当前线程。            else if (s.waiter == null)            s.waiter = w;        else if (!timed)            // 通过 LockSupport 进行 park，区别只是是否有超时时间。            LockSupport.park(this);        else if (nanos &gt; spinForTimeoutThreshold)            LockSupport.parkNanos(this, nanos);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>clean 清空操作</strong></h1><p>在任何给定时间，列表中的一个节点都不能删除-最后插入的节点。</p><p>为了解决这个问题，如果我们不能删除s，我们将其前身保存为 <span style="color:#e96900;--tt-darkmode-color: #E96900"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">cleanMe</span></span>，首先删除之前保存的版本。</p><p>可以始终删除节点s或先前保存的节点中的至少一个，因此该操作始终终止。</p><pre><code>/** * 使用原始的前任pred摆脱已取消的节点s。 * @author 老马啸西风 */void clean(QNode pred, QNode s) {    // 清空 waiter 信息    s.waiter = null;     while (pred.next == s) { //如果已取消链接，请提早返回        QNode h = head;        QNode hn = h.next;           //设置已取消的第一个节点为head        if (hn != null &amp;&amp; hn.isCancelled()) {            advanceHead(h, hn);            continue;        }        // 保证一致性读        QNode t = tail;      // Ensure consistent read for tail        // 为空，直接返回        if (t == h)            return;        // 不一致，重试            QNode tn = t.next;        if (t != tail)            continue;        // 尝试设置 tail 信息            if (tn != null) {            advanceTail(t, tn);            continue;        }        // 如果 s 节点不是尾巴节点，尝试进行 unsplice        if (s != t) {                  QNode sn = s.next;            if (sn == s || pred.casNext(s, sn))                return;        }        QNode dp = cleanMe;        //尝试取消链接先前取消的节点        if (dp != null) {                QNode d = dp.next;            QNode dn;            if (d == null ||               // d is gone or                d == dp ||                 // d is off list or                !d.isCancelled() ||        // d not cancelled or                (d != t &amp;&amp;                 // d not tail and                 (dn = d.next) != null &amp;&amp;  //   has successor                 dn != d &amp;&amp;                //   that is on list                 dp.casNext(d, dn)))       // d unspliced                // 通过 CAS 清空 dp                casCleanMe(dp, null);            // s 已经保存在信息中，直接返回                if (dp == pred)                return;              } else if (casCleanMe(null, pred))            return;          // Postpone cleaning s    }}</code></pre><h1 class=pgc-h-arrow-right><strong>基于堆栈</strong></h1><p>还有基于 stack 的实现。</p><p>不过思想都是类似的，此处为了阅读体验不再展开。</p><p>感兴趣的小伙伴点击 {阅读原文}，获取完整的阅读体验。</p><h1 class=pgc-h-arrow-right><strong>小结</strong></h1><p>阻塞队列大家族的成员共计 5 位，SynchronousQueue 是其中非常优秀的一份子。</p><p>工作学习中希望可以活学活用，提升工作效率，写出更加优异的代码。</p><p>希望本文对你有帮助，如果有其他想法的话，也可以评论区和大家分享哦。</p><p>各位<strong>极客</strong>的点赞收藏转发，是老马持续写作的最大动力！</p><p><br></p><div class=pgc-img><img alt="SynchronousQueue 同步队列入门使用&源码详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c55bbaef2e734c6cb952cc9b39ccc7d0><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SynchronousQueue','源码','详解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>