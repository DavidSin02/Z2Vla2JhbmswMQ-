<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>夯实基础：详解static关键字和5类场景应用 | 极客快訊</title><meta property="og:title" content="夯实基础：详解static关键字和5类场景应用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/816c141db0db494ea126b8f8579eb953"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/09e2d788.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/09e2d788.html><meta property="article:published_time" content="2020-11-14T20:59:55+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:55+08:00"><meta name=Keywords content><meta name=description content="夯实基础：详解static关键字和5类场景应用"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/09e2d788.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>夯实基础：详解static关键字和5类场景应用</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>导语</h1><p>在Java语言中，static表示“静态”的意思，使用场景可以用来修饰成员变量和成员方法，当然也可以是静态代码块。<strong>static的主要作用在于创建独立于具体对象的域变量或者方法。</strong>本文主要来去讲解一下static的来龙去脉，以后再也不用担心static问题了。</p><div class=pgc-img><img alt=夯实基础：详解static关键字和5类场景应用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/816c141db0db494ea126b8f8579eb953><p class=pgc-img-caption></p></div><h1 class=ql-align-justify><strong>static要解决的问题</strong></h1><p class=ql-align-justify>我们知道，当我们通过new关键字去创建对象的时候，那么数据的存储空间才会被分配，类中的成员方法才能被对象所使用。但是呢有两种特殊的情况：1、我们通过new关键字创建的对象共享同一个资源，而不是说每个对象都拥有自己的数据，或者说根本就不需要去创建对象，这个资源和对象之间是没有关系的。2、希望某个方法不与包含它的类的任何对象联系在一起。总结下来就是说：<strong>即使没有创建对象，也能使用属性和调用方法</strong>，static目的就是在于解决这个问题。</p><p class=ql-align-justify><strong>注意实例成员和类成员区别</strong></p><p class=ql-align-justify>简单的说，实例成员：每次创建对象，都会为每个对象分配成员内存空间，实例成员是属于实例对象的，<strong>在内存中，创建几次对象，就有几份成员变量</strong>。</p><p class=ql-align-justify>类成员（静态成员）：静态成员由于不属于任何实例对象，是属于类的，所以在内存中只会有一份，在类的加载过程中，JVM为静态成员分配一次内存空间。</p><h1 class=ql-align-justify><strong>应用格式</strong></h1><p class=ql-align-justify>修饰变量：static 数据类型 变量名</p><p class=ql-align-justify>修饰方法：【访问权限修饰符】 static 方法返回值 方法名(参数列表)</p><h1 class=ql-align-justify><strong>特点</strong></h1><p class=ql-align-justify>static可以修饰变量，方法</p><p class=ql-align-justify>被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。</p><p class=ql-align-justify>在类被加载的时候，就会去加载被static修饰的部分。</p><p class=ql-align-justify>被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</p><h1 class=ql-align-justify>static的五种场景用法</h1><div class=pgc-img><img alt=夯实基础：详解static关键字和5类场景应用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/493d6086-d9d8-49d5-a96b-754925df5b6b><p class=pgc-img-caption></p></div><p>在我们平时的使用当中，static最常用的功能就是修饰类的属性和方法，让他们成为类的成员属性和方法（俗称<strong>静态成员</strong>），我们通常将用static修饰的成员称为类成员或者静态成员，这句话挺起来都点奇怪，其实这是相对于对象的属性和方法来说的。请看下面的例子：（未避免程序太过臃肿，暂时不管访问控制）</p><pre>public class Person { String name; int age;  public String toString() { return "Name:" + name + ", Age:" + age; }  public static void main(String[] args) { Person p1 = new Person(); p1.name = "zhangsan"; p1.age = 10; Person p2 = new Person(); p2.name = "lisi"; p2.age = 12; System.out.println(p1); System.out.println(p2); } /**Output * Name:zhangsan, Age:10 * Name:lisi, Age:12 *///~}</pre><p>上面的代码我们很熟悉，根据Person构造出的每一个对象都是独立存在的，保存有自己独立的成员变量，相互不会影响，他们在内存中的示意如下:</p><div class=pgc-img><img alt=夯实基础：详解static关键字和5类场景应用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/48e315929da4488cbbdfefcaf8e04765><p class=pgc-img-caption></p></div><p>从上图中可以看出，p1和p2两个变量引用的对象分别存储在内存中堆区域的不同地址中，所以他们之间相互不会干扰。但其实，在这当中，我们省略了一些重要信息，相信大家也都会想到，对象的成员属性都在这了，由每个对象自己保存，那么他们的方法呢？实际上，不论一个类创建了几个对象，他们的方法都是一样的：</p><div class=pgc-img><img alt=夯实基础：详解static关键字和5类场景应用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b5bf1495ba87460595784fc7743c184c><p class=pgc-img-caption></p></div><p>从上面的图中我们可以看到，两个Person对象的方法实际上只是指向了同一个方法定义。这个方法定义是位于内存中的一块不变区域（由jvm划分），我们暂称它为静态存储区。这一块存储区不仅存放了方法的定义，实际上从更大的角度而言，它存放的是各种类的定义，当我们通过new来生成对象时，会根据这里定义的类的定义去创建对象。多个对象仅会对应同一个方法，这里有一个让我们充分信服的理由，那就是不管多少的对象，他们的方法总是相同的，尽管最后的输出会有所不同，但是方法总是会按照我们预想的结果去操作，即不同的对象去调用同一个方法，结果会不尽相同。</p><p>我们知道，static关键字可以修饰成员变量和方法，来让它们变成类的所属，而不是对象的所属，比如我们将Person的age属性用static进行修饰，结果会是什么样呢？请看下面的例子：</p><pre>public class Person { String name; static int age;  /* 其余代码不变... */ /**Output * Name:zhangsan, Age:12 * Name:lisi, Age:12 *///~}</pre><p>我们发现，结果发生了一点变化，在给p2的age属性赋值时，干扰了p1的age属性，这是为什么呢？我们还是来看他们在内存中的示意：</p><div class=pgc-img><img alt=夯实基础：详解static关键字和5类场景应用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/498e135aa6194b3f919678adbed39c22><p class=pgc-img-caption></p></div><p>我们发现，给age属性加了<strong>static</strong>关键字之后，Person对象就不再拥有age属性了，age属性会统一交给Person类去管理，即多个Person对象只会对应一个age属性，一个对象如果对age属性做了改变，其他的对象都会受到影响。我们看到此时的age和toString()方法一样，都是交由类去管理。</p><p>虽然我们看到static可以让对象共享属性，但是实际中我们很少这么用，也不推荐这么使用。因为这样会让该属性变得难以控制，因为它在任何地方都有可能被改变。如果我们想共享属性，一般我们会采用其他的办法：</p><pre>public class Person { private static int count = 0; int id; String name; int age;  public Person() { id = ++count; }  public String toString() { return "Id:" + id + ", Name:" + name + ", Age:" + age; }  public static void main(String[] args) { Person p1 = new Person(); p1.name = "zhangsan"; p1.age = 10; Person p2 = new Person(); p2.name = "lisi"; p2.age = 12; System.out.println(p1); System.out.println(p2); } /**Output * Id:1, Name:zhangsan, Age:10 * Id:2, Name:lisi, Age:12 *///~}</pre><p>上面的代码起到了给Person的对象创建一个唯一id以及记录总数的作用，其中count由static修饰，是Person类的成员属性，每次创建一个Person对象，就会使该属性自加1然后赋给对象的id属性，这样，count属性记录了创建Person对象的总数，由于count使用了private修饰，所以从类外面无法随意改变。</p><p><strong>2.修饰成员方法</strong></p><p>static的另一个作用，就是修饰成员方法。相比于修饰成员属性，修饰成员方法对于数据的存储上面并没有多大的变化，因为我们从上面可以看出，方法本来就是存放在类的定义当中的。static修饰成员方法最大的作用，就是可以使用"<strong>类名.方法名</strong>"的方式操作方法，避免了先要new出对象的繁琐和资源消耗，我们可能会经常在帮助类中看到它的使用：</p><pre>public class PrintHelper { public static void print(Object o){ System.out.println(o); }  public static void main(String[] args) { PrintHelper.print("Hello world"); }}</pre><p>上面便是一个例子（现在还不太实用），但是我们可以看到它的作用，使得static修饰的方法成为类的方法，使用时通过“<strong>类名.方法名</strong>”的方式就可以方便的使用了，相当于定义了一个全局的函数（只要导入该类所在的包即可）。不过它也有使用的局限，一个static修饰的类中，不能使用非static修饰的成员变量和方法，这很好理解，因为static修饰的方法是属于类的，如果去直接使用对象的成员变量，它会不知所措（不知该使用哪一个对象的属性）。</p><p><strong>3.静态块</strong></p><p>在说明static关键字的第三个用法时，我们有必要重新梳理一下一个对象的初始化过程。以下面的代码为例：</p><pre>package com.dotgua.study;class Book{ public Book(String msg) { System.out.println(msg); }}public class Person { Book book1 = new Book("book1成员变量初始化"); static Book book2 = new Book("static成员book2成员变量初始化");  public Person(String msg) { System.out.println(msg); }  Book book3 = new Book("book3成员变量初始化"); static Book book4 = new Book("static成员book4成员变量初始化");  public static void main(String[] args) { Person p1 = new Person("p1初始化"); } /**Output * static成员book2成员变量初始化 * static成员book4成员变量初始化 * book1成员变量初始化 * book3成员变量初始化 * p1初始化 *///~}</pre><p>上面的例子中，Person类中组合了四个Book成员变量，两个是普通成员，两个是static修饰的类成员。我们可以看到，当我们new一个Person对象时，static修饰的成员变量首先被初始化，随后是普通成员，最后调用Person类的构造方法完成初始化。也就是说，在创建对象时，static修饰的成员会首先被初始化，而且我们还可以看到，如果有多个static修饰的成员，那么会按照他们的先后位置进行初始化。</p><p>实际上，static修饰的成员的初始化可以更早的进行，请看下面的例子：</p><pre>class Book{ public Book(String msg) { System.out.println(msg); }}public class Person { Book book1 = new Book("book1成员变量初始化"); static Book book2 = new Book("static成员book2成员变量初始化");  public Person(String msg) { System.out.println(msg); }  Book book3 = new Book("book3成员变量初始化"); static Book book4 = new Book("static成员book4成员变量初始化");  public static void funStatic() { System.out.println("static修饰的funStatic方法"); }  public static void main(String[] args) { Person.funStatic(); System.out.println("****************"); Person p1 = new Person("p1初始化"); } /**Output * static成员book2成员变量初始化 * static成员book4成员变量初始化 * static修饰的funStatic方法 * *************** * book1成员变量初始化 * book3成员变量初始化 * p1初始化 *///~}</pre><p>在上面的例子中我们可以发现两个有意思的地方，第一个是当我们没有创建对象，而是通过类去调用类方法时，尽管该方法没有使用到任何的类成员，类成员还是在方法调用之前就初始化了，这说明，当我们第一次去使用一个类时，就会触发该类的成员初始化。第二个是当我们使用了类方法，完成类的成员的初始化后，再new该类的对象时，static修饰的类成员没有再次初始化，这说明，static修饰的类成员，在程序运行过程中，只需要初始化一次即可，不会进行多次的初始化。</p><p>回顾了对象的初始化以后，我们再来看static的第三个作用就非常简单了，那就是当我们初始化static修饰的成员时，可以将他们统一放在一个以static开始，用花括号包裹起来的块状语句中：</p><pre>class Book{ public Book(String msg) { System.out.println(msg); }}public class Person { Book book1 = new Book("book1成员变量初始化"); static Book book2;  static { book2 = new Book("static成员book2成员变量初始化"); book4 = new Book("static成员book4成员变量初始化"); }  public Person(String msg) { System.out.println(msg); }  Book book3 = new Book("book3成员变量初始化"); static Book book4;  public static void funStatic() { System.out.println("static修饰的funStatic方法"); }  public static void main(String[] args) { Person.funStatic(); System.out.println("****************"); Person p1 = new Person("p1初始化"); } /**Output * static成员book2成员变量初始化 * static成员book4成员变量初始化 * static修饰的funStatic方法 * *************** * book1成员变量初始化 * book3成员变量初始化 * p1初始化 *///~}</pre><p>我们将上一个例子稍微做了一下修改，可以看到，结果没有二致。</p><p><strong>4.静态导包</strong></p><p>相比于上面的三种用途，第四种用途可能了解的人就比较少了，但是实际上它很简单，而且在调用类方法时会更方便。以上面的“PrintHelper”的例子为例，做一下稍微的变化，即可使用静态导包带给我们的方便：</p><pre>/* PrintHelper.java文件 */package com.dotgua.study;public class PrintHelper { public static void print(Object o){ System.out.println(o); }}/* App.java文件 */import static com.dotgua.study.PrintHelper.*;public class App { public static void main( String[] args ) { print("Hello World!"); } /**Output * Hello World! *///~}</pre><p>上面的代码来自于两个java文件，其中的PrintHelper很简单，包含了一个用于打印的static方法。而在App.java文件中，我们首先将PrintHelper类导入，这里在导入时，我们使用了static关键字，而且在引入类的最后还加上了<strong>“.*”</strong>，它的作用就是将PrintHelper类中的所有类方法直接导入。不同于非static导入，采用static导入包后，在不与当前类的方法名冲突的情况下，无需使用“<strong>类名.方法名</strong>”的方法去调用类方法了，直接可以采用"<strong>方法名</strong>"去调用类方法，就好像是该类自己的方法一样使用即可。</p><h1>5.<strong>静态内部类</strong></h1><p>在定义内部类的时候，可以在其前面加上一个权限修饰符static，此时这个内部类就变为了静态内部类。</p><p>实际应用中写静态方法时，可static块初始化单例对象，且只希望在调用getInstance方法时初始化单例对象，要怎么写呢？单例模式实现时，因为饿汗式写法性能不太好，所以基于静态内部类实现优化的单例模式如下：</p><pre>public class Singleton { //使用静态内部类初始化对象 private static class SingletonHolder{ private static volatile Singleton instance = new Singleton();  } private Singleton (){}  public static Singleton getInstance() {  return SingletonHolder.instance;  }  public static void otherMothed(){ System.out.println("调用单例的其他方法时不会创建对象.") }  public static void main(String [] args){ //Singleton.otherMothed(); Singleton.getInstance(); }}</pre><p>当然，你可以有其它形式的静态内部类的使用需求。</p><p><strong>6.总结</strong></p><p>static是java中非常重要的一个关键字，而且它的用法也很丰富，主要有四种用法：</p><ol><li>用来修饰成员变量，将其变为类的成员，从而实现所有对象对于该成员的共享；</li><li>用来修饰成员方法，将其变为类方法，可以直接使用<strong>“类名.方法名”</strong>的方式调用，常用于工具类；</li><li>静态块用法，将多个类成员放在一起初始化，使得程序更加规整，其中理解对象的初始化过程非常关键；</li><li>静态导包用法，将类的方法直接导入到当前类中，从而直接使用<strong>“方法名”</strong>即可调用类方法，更加方便。</li><li>静态内部类的使用。</li></ol><div class=pgc-img><img alt=夯实基础：详解static关键字和5类场景应用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9220c7d93d94d68a386ad128a1b986e><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'夯实','基础','详解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>