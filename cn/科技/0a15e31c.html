<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一个C语言经典编写的经典小游戏，带注释和解析 | 极客快訊</title><meta property="og:title" content="一个C语言经典编写的经典小游戏，带注释和解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0a15e31c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0a15e31c.html><meta property="article:published_time" content="2020-11-14T20:59:47+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:47+08:00"><meta name=Keywords content><meta name=description content="一个C语言经典编写的经典小游戏，带注释和解析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0a15e31c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一个C语言经典编写的经典小游戏，带注释和解析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h2>问题描述</h2><p>一个农夫在河边带了一只狼、一只羊和一颗白菜，他需要把这三样东西用船带到河的对岸。然而，这艘船只能容下农夫本人和另外一样东西。如果农夫不在场的话，狼会吃掉羊，羊也会吃掉白菜。请编程为农夫解决这个过河问题。</p><h2>问题分析</h2><p>根据问题描述可知，该问题涉及的对象较多，而且运算步骤也较为复杂，因此，在使用C语言实现时，首先需要将具体问题数字化。</p><p>由于整个过程的实现需要多步，而不同步骤中各个事物所处的位置不同，因此可以定义一个二维数组或者结构体来表不四个对象狼（wolf）、羊（goat）、白菜（cabbage）和农夫（farmer）。对于东岸和西岸，可以用east和west表示，也可以用0和1来表示， 以保证在程序设计中的简便性。</p><p>题目要求给出四种事物的过河步骤，没有对先后顺序进行约束，这就需要给各个事物依次进行编号，然后依次试探，若试探成功，再进行下一步试探。因此，解决该问题可以使用循环或者递归算法，以避免随机盲目运算而且保证每种情况都可以试探到。</p><p>题目要求求出农夫带一只羊，一条狼和一颗白菜过河的所有办法，所以依次成功返回运算结果后，需要继续运算，直至求出所有结果，即给出农夫不同的过河方案。</p><h2>算法设计</h2><p>本程序使用递归算法，定义二维数组int a[N][4]存储每一步中各个事物所处的位置。二维数组的一维下标表示当前进行的步骤，第二维下标可能的取值为0〜3，在这里规定它与四种事物的具体对应关系为：0——狼、1——羊、2——白菜、3——农夫。接着再将东岸和西岸数字化，用0表示东岸，1表示西岸，该信息存储在二维数组的对应元素中。</p><p>定义Step变量表示渡河的步骤，则成功渡河之后，a数组中的存储状态为:</p><p>a[Step][0] 1</p><p>a[Step][1] 1</p><p>a[Step][2] 1</p><p>a[Step][3] 1</p><p>因为成功渡河后，狼、羊、白菜和农夫都在河的西岸，因此有：</p><p>a[Step][0]+a[Step][1]+a[Step][2]+a[Step][3]=4</p><p>题目中要求狼和羊、羊和白菜不能在一起，因此若有下述情况出现：</p><p>a[Step][1]!=a[Step][3] && (a[Step][2]==a[Step][1] || a[Step][0]=a[Step][1])</p><p>则发生错误，应返回操作。</p><p>在程序实现时，除了定义a数组来存储每一步中各个对象所处的位置以外，再定义一维数组b[N]来存储每一步中农夫是如何过河的。</p><p>程序中实现递归操作部分的核心代码为：</p><pre>for(i=-1; i&lt;=2; i++){ b[Step]=i; memcpy(a[Step+1], a[Step], 16); /*复制上一步状态，进行下一步移动*/ a[Step+1][3]=1-a[Step+1][3]; /*农夫过去或者回来*/ if(i == -1) { search(Step+1); /*进行第一步*/ } else if(a[Step][i] == a[Step][3]) /*若该物与农夫同岸，带回*/ { a[Step+1][i]=a[Step+1][3]; /*带回该物*/ search(Step+1); /*进行下一步*/ }}</pre><p>每次循环从-1到2依次代表农夫渡河时为一人、带狼、带羊、带白菜通过，利用语句“b[Step] = i”分别记录每一步中农夫的渡河方式，语句“a[Step+1][i] = a[Step+1][3]”是利用赋值方式使该对象与农夫一同到对岸或者回到本岸。若渡河成功，则依次输出渡河方式。“i&lt;=2”为递归操作的界限，若i=2时仍无符合条件的方式，则渡河失败。</p><p>上面代码表示若当前步骤能使各值均为1，则渡河成功，输出结果，进入回归步骤。若当前步骤与以前的步骤相同，则返回操作，代码如下：</p><pre>if(memcmp(a[i],a[Step],16) == 0){ return 0;}</pre><p>若羊和农夫不在一块而狼和羊或者羊和白菜在一块，则返回操作，判断代码如下：</p><pre>if(a[Step][1]!=a[Step][3] &amp;&amp; (a[Step][2] == a[Step][1] || a[Step][0] == a[Step][1])){ return 0;}</pre><p>下面是完整的代码：</p><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#define N 15int a[N][4];int b[N];char *name[]={ " ", "and wolf", "and goat", "and cabbage"};int search(int Step){ int i; /*若该种步骤能使各值均为1，则输出结果，进入回归步骤*/ if(a[Step][0]+a[Step][1]+a[Step][2]+a[Step][3] == 4) {  for(i=0; i&lt;=Step; i++) /*能够依次输出不同的方案*/ { printf("east: "); if(a[i][0] == 0) printf("wolf "); if(a[i][1] == 0) printf("goat "); if(a[i][2] == 0) printf("cabbage "); if(a[i][3] == 0) printf("farmer "); if(a[i][0] &amp;&amp; a[i][1] &amp;&amp; a[i][2] &amp;&amp; a[i][3]) printf("none"); printf(" "); printf("west: "); if(a[i][0] == 1) printf("wolf "); if(a[i][1] == 1) printf("goat "); if(a[i][2] == 1) printf("cabbage "); if(a[i][3] == 1) printf("farmer "); if(!(a[i][0] || a[i][1] || a[i][2] || a[i][3])) printf("none"); printf("\n\n\n"); if(i&lt;Step) printf(" the %d time\n",i+1); if(i&gt;0 &amp;&amp; i&lt;Step) { if(a[i][3] == 0) /*农夫在本岸*/ { printf(" -----&gt; farmer "); printf("%s\n", name[b[i] + 1]); } else /*农夫在对岸*/ { printf(" &lt;----- farmer "); printf("%s\n", name[b[i] + 1]); } } } printf("\n\n\n\n"); return 0; } for(i=0; i&lt;Step; i++) { if(memcmp(a[i],a[Step],16) == 0) /*若该步与以前步骤相同，取消操作*/ { return 0; } } /*若羊和农夫不在一块而狼和羊或者羊和白菜在一块，则取消操作*/ if(a[Step][1]!=a[Step][3] &amp;&amp; (a[Step][2] == a[Step][1] || a[Step][0] == a[Step][1])) { return 0; } /*递归，从带第一种动物开始依次向下循环，同时限定递归的界限*/ for(i=-1; i&lt;=2; i++) { b[Step]=i; memcpy(a[Step+1], a[Step], 16); /*复制上一步状态，进行下一步移动*/ a[Step+1][3]=1-a[Step+1][3]; /*农夫过去或者回来*/ if(i == -1) { search(Step+1); /*进行第一步*/ } else if(a[Step][i] == a[Step][3]) /*若该物与农夫同岸，带回*/ { a[Step+1][i]=a[Step+1][3]; /*带回该物*/ search(Step+1); /*进行下一步*/ } } return 0;}int main(){ printf("\n\n 农夫过河问题，解决方案如下：\n\n\n"); search(0); return 0;}</pre><p>运行结果：</p><pre> 农夫过河问题，解决方案如下：east: wolf goat cabbage farmer west: none the 1 timeeast: wolf cabbage west: goat farmer  the 2 time &lt;----- farmer east: wolf cabbage farmer west: goat  the 3 time -----&gt; farmer and wolfeast: cabbage west: wolf goat farmer  the 4 time &lt;----- farmer and goateast: goat cabbage farmer west: wolf  the 5 time -----&gt; farmer and cabbageeast: goat west: wolf cabbage farmer  the 6 time &lt;----- farmer east: goat farmer west: wolf cabbage  the 7 time -----&gt; farmer and goateast: none west: wolf goat cabbage farmer east: wolf goat cabbage farmer west: none the 1 timeeast: wolf cabbage west: goat farmer  the 2 time &lt;----- farmer east: wolf cabbage farmer west: goat  the 3 time -----&gt; farmer and cabbageeast: wolf west: goat cabbage farmer  the 4 time &lt;----- farmer and goateast: wolf goat farmer west: cabbage  the 5 time -----&gt; farmer and wolfeast: goat west: wolf cabbage farmer  the 6 time &lt;----- farmer east: goat farmer west: wolf cabbage  the 7 time -----&gt; farmer and goateast: none west: wolf goat cabbage farmer </pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'经典','一个','语言'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>