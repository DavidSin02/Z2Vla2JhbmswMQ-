<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>浅谈消息队列及常见的消息中间件 | 极客快訊</title><meta property="og:title" content="浅谈消息队列及常见的消息中间件 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/99348ece13f64ce49f498270b88717c4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0dc00e68.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc00e68.html><meta property="article:published_time" content="2020-11-14T21:01:46+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:46+08:00"><meta name=Keywords content><meta name=description content="浅谈消息队列及常见的消息中间件"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0dc00e68.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>浅谈消息队列及常见的消息中间件</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>精品专栏</p><ul><li><a class=pgc-link href="https://www.toutiao.com/i6634273268289241604/?group_id=6634273268289241604" target=_blank>《GitHub：中文详细注释的开源项目》</a></li></ul><blockquote><p>摘要: 原创出处 https://juejin.im/post/5b41fe36e51d45191252e79e 「零壹技术栈」欢迎转载，保留摘要，谢谢！</p></blockquote><ul><li>前言</li><li>正文</li><li class=ql-indent-1>1. 消息队列概述</li><li class=ql-indent-1>2. 消息队列的特点</li><li class=ql-indent-1>3. 消息队列的传递服务模型</li><li class=ql-indent-1>4. 消息队列的的传输模式</li><li class=ql-indent-1>5. 消息队列应用场景</li><li class=ql-indent-1>6. 消息队列的推拉模型</li><li class=ql-indent-1>7. 消息队列技术对比</li><li>小结</li></ul><hr><h1><strong>前言</strong></h1><p><strong>消息队列</strong> 已经逐渐成为企业应用系统 <strong>内部通信</strong> 的核心手段。它具有 <strong>低耦合</strong>、<strong>可靠投递</strong>、<strong>广播</strong>、<strong>流量控制</strong>、<strong>最终一致性</strong> 等一系列功能。</p><p>当前使用较多的 <strong>消息队列</strong> 有 RabbitMQ、RocketMQ、ActiveMQ、Kafka、ZeroMQ、MetaMQ 等，而部分 <strong>数据库</strong> 如 Redis、MySQL 以及 phxsql 也可实现消息队列的功能。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99348ece13f64ce49f498270b88717c4><p class=pgc-img-caption></p></div><p>img</p><h1><strong>正文</strong></h1><p><strong>1. 消息队列概述</strong></p><p><strong>消息队列</strong> 是指利用 <strong>高效可靠</strong> 的 <strong>消息传递机制</strong> 进行与平台无关的 <strong>数据交流</strong>，并基于 <strong>数据通信</strong> 来进行分布式系统的集成。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a829b3a539534d98b8977c96d28f2841><p class=pgc-img-caption></p></div><p>img</p><p>通过提供 <strong>消息传递</strong> 和 <strong>消息排队</strong> 模型，它可以在 <strong>分布式环境</strong> 下提供 <strong>应用解耦</strong>、<strong>弹性伸缩</strong>、<strong>冗余存储</strong>、<strong>流量削峰</strong>、<strong>异步通信</strong>、<strong>数据同步</strong> 等等功能，其作为 <strong>分布式系统架构</strong> 中的一个重要组件，有着举足轻重的地位。</p><p><strong>2. 消息队列的特点</strong></p><p><strong>2.1. 采用异步处理模式</strong></p><p><strong>消息发送者</strong> 可以发送一个消息而无须等待响应。<strong>消息发送者</strong> 将消息发送到一条 <strong>虚拟的通道</strong>（<strong>主题</strong> 或 <strong>队列</strong>）上，<strong>消息接收者</strong> 则 <strong>订阅</strong> 或是 <strong>监听</strong> 该通道。一条信息可能最终转发给 <strong>一个或多个</strong> 消息接收者，这些接收者都无需对 <strong>消息发送者</strong> 做出 <strong>同步回应</strong>。整个过程都是 <strong>异步的</strong>。</p><p><strong>2.2. 应用系统之间解耦合</strong></p><p>主要体现在如下两点：</p><ol><li>发送者和接受者不必了解对方、只需要 <strong>确认消息</strong>；</li><li>发送者和接受者 <strong>不必同时在线</strong>。</li></ol><p>比如在线交易系统为了保证数据的 <strong>最终一致</strong>，在 <strong>支付系统</strong> 处理完成后会把 <strong>支付结果</strong> 放到 <strong>消息中间件</strong> 里，通知 <strong>订单系统</strong> 修改 <strong>订单支付状态</strong>。两个系统是通过消息中间件解耦的。</p><p><strong>3. 消息队列的传递服务模型</strong></p><p>消息队列的 <strong>传递服务模型</strong> 如下图所示：</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bc07d9e2eb79486499896d4d3da5ed9b><p class=pgc-img-caption></p></div><p>img</p><p><strong>4. 消息队列的的传输模式</strong></p><p><strong>4.1. 点对点模型</strong></p><p><strong>点对点模型</strong> 用于 <strong>消息生产者</strong> 和 <strong>消息消费者</strong> 之间 <strong>点到点</strong> 的通信。消息生产者将消息发送到由某个名字标识的特定消费者。这个名字实际上对于消费服务中的一个 <strong>队列</strong>（Queue），在消息传递给消费者之前它被 <strong>存储</strong> 在这个队列中。<strong>队列消息</strong> 可以放在 <strong>内存</strong> 中也可以 <strong>持久化</strong>，以保证在消息服务出现故障时仍然能够传递消息。</p><p>传统的点对点消息中间件通常由 <strong>消息队列服务</strong>、<strong>消息传递服务</strong>、<strong>消息队列</strong> 和 <strong>消息应用程序接口</strong> API 组成，其典型的结构如下图所示。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/51c0f404ccde49a7a1a6b995ca6c688e><p class=pgc-img-caption></p></div><p>img</p><p><strong>特点：</strong></p><ol><li>每个消息只用一个消费者；</li><li>发送者和接受者没有时间依赖；</li><li>接受者确认消息接受和处理成功。</li></ol><p><strong>示意图如下所示：</strong></p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c0865195c0af46eca05126d9b138f28a><p class=pgc-img-caption></p></div><p>img</p><p><strong>4.2. 发布/订阅模型（Pub/Sub）</strong></p><p><strong>发布者/订阅者</strong> 模型支持向一个特定的 <strong>消息主题</strong> 生产消息。0 或 <strong>多个订阅者</strong> 可能对接收来自 <strong>特定消息主题</strong> 的消息感兴趣。</p><p>在这种模型下，发布者和订阅者彼此不知道对方，就好比是匿名公告板。这种模式被概况为：多个消费者可以获得消息，在 <strong>发布者</strong> 和 <strong>订阅者</strong> 之间存在 <strong>时间依赖性</strong>。发布者需要建立一个 <strong>订阅</strong>（subscription），以便能够消费者订阅。<strong>订阅者</strong> 必须保持 <strong>持续的活动状态</strong> 并 <strong>接收消息</strong>。</p><p>在这种情况下，在订阅者 <strong>未连接时</strong>，发布的消息将在订阅者 <strong>重新连接</strong> 时 <strong>重新发布</strong>，如下图所示：</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a502c3505d584d11b025a37664e675ce><p class=pgc-img-caption></p></div><p>img</p><p><strong>特性：</strong></p><ol><li>每个消息可以有多个订阅者；</li><li>客户端只有订阅后才能接收到消息；</li><li>持久订阅和非持久订阅。</li></ol><blockquote><p>注意：</p></blockquote><ul><li>发布者和订阅者有时间依赖：接受者和发布者只有建立订阅关系才能收到消息；</li><li>持久订阅：订阅关系建立后，消息就不会消失，不管订阅者是否都在线；</li><li>非持久订阅：订阅者为了接受消息，必须一直在线。 当只有一个订阅者时约等于点对点模式</li></ul><p><strong>5. 消息队列应用场景</strong></p><p>当你需要使用 <strong>消息队列</strong> 时，首先需要考虑它的必要性。可以使用消息队列的场景有很多，最常用的几种，是做 <strong>应用程序松耦合</strong>、<strong>异步处理模式</strong>、<strong>发布与订阅</strong>、<strong>最终一致性</strong>、<strong>错峰流控</strong> 和 <strong>日志缓冲</strong> 等。反之，如果需要 <strong>强一致性</strong>，关注业务逻辑的处理结果，则使用 RPC 显得更为合适。</p><p><strong>5.1. 异步处理</strong></p><p><strong>非核心</strong> 流程 <strong>异步化</strong>，减少系统 <strong>响应时间</strong>，提高 <strong>吞吐量</strong>。例如：<strong>短信通知</strong>、<strong>终端状态推送</strong>、App <strong>推送</strong>、<strong>用户注册</strong>等。</p><p><strong>消息队列</strong> 一般都内置了 <strong>高效的通信机制</strong>，因此也可以用於单纯的消息通讯，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p><p><strong>应用案例</strong></p><p>网站用户注册，注册成功后会过一会发送邮件确认或者短息。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/87c1acdb869c4ec6a84ccdd15c46f171><p class=pgc-img-caption></p></div><p>img</p><p><strong>5.2. 系统解耦</strong></p><ul><li>系统之间不是 <strong>强耦合的</strong>，<strong>消息接受者</strong> 可以随意增加，而不需要修改 <strong>消息发送者的代码</strong>。<strong>消息发送者</strong> 的成功不依赖 <strong>消息接受者</strong>（比如：有些银行接口不稳定，但调用方并不需要依赖这些接口）。</li><li><strong>不强依赖</strong> 于非本系统的核心流程，对于 <strong>非核心流程</strong>，可以放到消息队列中让 <strong>消息消费者</strong> 去按需消费，而 <strong>不影响核心主流程</strong>。</li></ul><p><strong>5.3. 最终一致性</strong></p><p><strong>最终一致性</strong> 不是 <strong>消息队列</strong> 的必备特性，但确实可以依靠 <strong>消息队列</strong> 来做 <strong>最终一致性</strong> 的事情。</p><ul><li><strong>先写消息再操作</strong>，确保操作完成后再修改消息状态。<strong>定时任务补偿机制</strong> 实现消息 <strong>可靠发送接收</strong>、业务操作的可靠执行，要注意 <strong>消息重复</strong> 与 <strong>幂等设计</strong>。</li><li>所有不保证 100% <strong>不丢消息</strong> 的消息队列，理论上无法实现 <strong>最终一致性</strong>。</li></ul><blockquote><p>像 Kafka 一类的设计，在设计层面上就有 <strong>丢消息</strong> 的可能（比如 <strong>定时刷盘</strong>，如果掉电就会丢消息）。哪怕只丢千分之一的消息，业务也必须用其他的手段来保证结果正确。</p></blockquote><p><strong>5.4. 广播</strong></p><p><strong>生产者/消费者</strong> 模式，只需要关心消息是否 <strong>送达队列</strong>，至于谁希望订阅和需要消费，是 <strong>下游</strong> 的事情，无疑极大地减少了开发和联调的工作量。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c71bbd5d542494fbce993e8b43517f5><p class=pgc-img-caption></p></div><p>img</p><p><strong>5.5. 流量削峰和流控</strong></p><p>当 <strong>上下游系统</strong> 处理能力存在差距的时候，利用 <strong>消息队列</strong> 做一个通用的 <strong>“漏斗”</strong>，进行 <strong>限流控制</strong>。在下游有能力处理的时候，再进行分发。</p><blockquote><p>举个例子：用户在支付系统成功结账后，订单系统会通过短信系统向用户推送扣费通知。 <strong>短信系统</strong> 可能由于 <strong>短板效应</strong>，速度卡在 <strong>网关</strong> 上（每秒几百次请求），跟 <strong>前端的并发量</strong> 不是一个数量级。 于是，就造成 <strong>支付系统</strong> 和 <strong>短信系统</strong> 的处理能力出现差异化。</p></blockquote><p>然而用户晚上个半分钟左右收到短信，一般是不会有太大问题的。如果没有消息队列，两个系统之间通过 <strong>协商</strong>、<strong>滑动窗口</strong> 等复杂的方案也不是说不能实现。但 <strong>系统复杂性</strong> 指数级增长，势必在 <strong>上游</strong> 或者 <strong>下游</strong> 做 <strong>存储</strong>，并且要处理 <strong>定时</strong>、<strong>拥塞</strong> 等一系列问题。而且每当有 <strong>处理能力有差距</strong> 的时候，都需要 <strong>单独</strong> 开发一套逻辑来维护这套逻辑。</p><p>所以，利用中间系统转储两个系统的通信内容，并在下游系统有能力处理这些消息的时候，再处理这些消息，是一套相对较通用的方式。</p><p><strong>应用案例</strong></p><ol><li>把消息队列当成可靠的 <strong>消息暂存地</strong>，进行一定程度的 <strong>消息堆积</strong>；</li><li>定时进行消息投递，比如模拟 <strong>用户秒杀</strong> 访问，进行 <strong>系统性能压测</strong>。</li></ol><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9af3d656701d44c19b6cd7ec7d074891><p class=pgc-img-caption></p></div><p>img</p><p><strong>5.6. 日志处理</strong></p><p>将消息队列用在 <strong>日志处理</strong> 中，比如 Kafka 的应用，解决 <strong>海量日志</strong> 传输和缓冲的问题。</p><p><strong>应用案例</strong></p><p>把日志进行集中收集，用于计算 PV、<strong>用户行为分析</strong> 等等。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8d597a7aa4f1424bbdc4bd5978bd1750><p class=pgc-img-caption></p></div><p>img</p><p><strong>5.7. 消息通讯</strong></p><p>消息队列一般都内置了 <strong>高效的通信机制</strong>，因此也可以用於单纯的 <strong>消息通讯</strong>，比如实现 <strong>点对点消息队列</strong> 或者 <strong>聊天室</strong> 等。</p><p><strong>6. 消息队列的推拉模型</strong></p><p><strong>6.1. Push推消息模型</strong></p><p><strong>消息生产者</strong> 将消息发送给 <strong>消息队列</strong>，<strong>消息队列</strong> 又将消息推给 <strong>消息消费者</strong>。</p><p><strong>6.2. Pull拉消息模型</strong></p><p><strong>消费者</strong> 请求 <strong>消息队列</strong> 接受消息，<strong>消息生产者</strong> 从 <strong>消息队列</strong> 中拉该消息。</p><p><strong>6.3. 两种类型的区别</strong></p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0e21f6a58bb6468d8bd955c76cd04357><p class=pgc-img-caption></p></div><p>img</p><p><strong>7. 消息队列技术对比</strong></p><p>本部分主要介绍四种常用的消息队列（ActiveMQ / RabbitMQ / RocketMQ / Kafka）的主要特性、优点、缺点。</p><p><strong>7.1. ActiveMQ</strong></p><p>ActiveMQ 是由 Apache 出品，ActiveMQ 是一个完全支持JMS1.1 和 J2EE 1.4 规范的 JMS Provider 实现。它非常快速，支持 <strong>多种语言的客户端</strong> 和 <strong>协议</strong>，而且可以非常容易的嵌入到企业的应用环境中，并有许多高级功能。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a7c73d2164c4150ad6084baeff4f3ab><p class=pgc-img-caption></p></div><p>img</p><p><strong>(a) 主要特性</strong></p><ol><li><strong>服从JMS规范</strong>：JMS 规范提供了良好的标准和保证，包括：<strong>同步</strong> 或 <strong>异步</strong> 的消息分发，一次和仅一次的消息分发，<strong>消息接收</strong> 和 <strong>订阅</strong> 等等。遵从 JMS 规范的好处在于，不论使用什么 JMS 实现提供者，这些基础特性都是可用的；</li><li><strong>连接灵活性</strong>：ActiveMQ 提供了广泛的 <strong>连接协议</strong>，支持的协议有：HTTP/S，IP <strong>多播</strong>，SSL，TCP，UDP 等等。对众多协议的支持让 ActiveMQ 拥有了很好的灵活性；</li><li><strong>支持的协议种类多</strong>：OpenWire、STOMP、REST、XMPP、AMQP；</li><li><strong>持久化插件和安全插件</strong>：ActiveMQ 提供了 <strong>多种持久化</strong> 选择。而且，ActiveMQ 的安全性也可以完全依据用户需求进行 <strong>自定义鉴权</strong> 和 <strong>授权</strong>；</li><li><strong>支持的客户端语言种类多</strong>：除了 Java 之外，还有：C/C++，.NET，Perl，PHP，Python，Ruby；</li><li><strong>代理集群</strong>：多个 ActiveMQ <strong>代理</strong> 可以组成一个 <strong>集群</strong> 来提供服务；</li><li><strong>异常简单的管理</strong>：ActiveMQ 是以开发者思维被设计的。所以，它并不需要专门的管理员，因为它提供了简单又使用的管理特性。有很多中方法可以 <strong>监控</strong> ActiveMQ 不同层面的数据，包括使用在 JConsole 或者在 ActiveMQ 的 Web Console 中使用 JMX。通过处理 JMX 的告警消息，通过使用 <strong>命令行脚本</strong>，甚至可以通过监控各种类型的 <strong>日志</strong>。</li></ol><p><strong>(b) 部署环境</strong></p><p>ActiveMQ 可以运行在 Java 语言所支持的平台之上。使用 ActiveMQ 需要：</p><ul><li>Java JDK</li><li>ActiveMQ 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li><strong>跨平台</strong> (JAVA 编写与平台无关，ActiveMQ 几乎可以运行在任何的 JVM 上)；</li><li>可以用 JDBC：可以将 <strong>数据持久化</strong> 到数据库。虽然使用 JDBC 会降低 ActiveMQ 的性能，但是数据库一直都是开发人员最熟悉的存储介质；</li><li>支持 JMS 规范：支持 JMS 规范提供的 <strong>统一接口</strong>;</li><li>支持 <strong>自动重连</strong> 和 <strong>错误重试机制</strong>；</li><li>有安全机制：支持基于 shiro，jaas 等多种 <strong>安全配置机制</strong>，可以对 Queue/Topic 进行 <strong>认证和授权</strong>；</li><li>监控完善：拥有完善的 <strong>监控</strong>，包括 Web Console，JMX，Shell 命令行，Jolokia 的 RESTful API；</li><li>界面友善：提供的 Web Console 可以满足大部分情况，还有很多 <strong>第三方的组件</strong> 可以使用，比如 hawtio；</li></ol><p><strong>(d) 缺点</strong></p><ol><li>社区活跃度不及 RabbitMQ 高；</li><li>根据其他用户反馈，会出莫名其妙的问题，会 <strong>丢失消息</strong>；</li><li>目前重心放到 activemq 6.0 产品 Apollo，对 5.x 的维护较少；</li><li>不适合用于 <strong>上千个队列</strong> 的应用场景；</li></ol><p><strong>7.2. RabbitMQ</strong></p><p>RabbitMQ 于 2007 年发布，是一个在 AMQP (<strong>高级消息队列协议</strong>)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/55303cbd6c024f50aae6194841a409f2><p class=pgc-img-caption></p></div><p>img</p><p><strong>(a) 主要特性</strong></p><ol><li><strong>可靠性</strong>：提供了多种技术可以让你在 <strong>性能</strong> 和 <strong>可靠性</strong> 之间进行 <strong>权衡</strong>。这些技术包括 <strong>持久性机制</strong>、<strong>投递确认</strong>、<strong>发布者证实</strong> 和 <strong>高可用性机制</strong>；</li><li><strong>灵活的路由</strong>：消息在到达队列前是通过 <strong>交换机</strong> 进行 <strong>路由</strong> 的。RabbitMQ 为典型的路由逻辑提供了 <strong>多种内置交换机</strong> 类型。如果你有更复杂的路由需求，可以将这些交换机组合起来使用，你甚至可以实现自己的交换机类型，并且当做 RabbitMQ 的 <strong>插件</strong> 来使用；</li><li><strong>消息集群</strong>：在相同局域网中的多个 RabbitMQ 服务器可以 <strong>聚合</strong> 在一起，作为一个独立的逻辑代理来使用；</li><li><strong>队列高可用</strong>：队列可以在集群中的机器上 <strong>进行镜像</strong>，以确保在硬件问题下还保证 <strong>消息安全</strong>；</li><li><strong>支持多种协议</strong>：支持 <strong>多种消息队列协议</strong>；</li><li><strong>支持多种语言</strong>：用 Erlang 语言编写，支持只要是你能想到的 <strong>所有编程语言</strong>；</li><li><strong>管理界面</strong>： RabbitMQ 有一个易用的 <strong>用户界面</strong>，使得用户可以 <strong>监控</strong> 和 <strong>管理</strong> 消息 Broker 的许多方面；</li><li><strong>跟踪机制</strong>：如果 <strong>消息异常</strong>，RabbitMQ 提供消息跟踪机制，使用者可以找出发生了什么；</li><li><strong>插件机制</strong>：提供了许多 <strong>插件</strong>，来从多方面进行扩展，也可以编写自己的插件。</li></ol><p><strong>(b) 部署环境</strong></p><p>RabbitMQ 可以运行在 Erlang 语言所支持的平台之上，包括 Solaris，BSD，Linux，MacOSX，TRU64，Windows 等。使用 RabbitMQ 需要：</p><ul><li>ErLang 语言包</li><li>RabbitMQ 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li>由于 Erlang 语言的特性，消息队列性能较好，支持 <strong>高并发</strong>；</li><li>健壮、稳定、易用、<strong>跨平台</strong>、支持 <strong>多种语言</strong>、文档齐全；</li><li>有消息 <strong>确认机制</strong> 和 <strong>持久化机制</strong>，可靠性高；</li><li>高度可定制的 <strong>路由</strong>；</li><li><strong>管理界面</strong> 较丰富，在互联网公司也有较大规模的应用，社区活跃度高。</li></ol><p><strong>(d) 缺点</strong></p><ol><li>尽管结合 Erlang 语言本身的并发优势，性能较好，但是不利于做 <strong>二次开发和维护</strong>；</li><li>实现了 <strong>代理架构</strong>，意味着消息在发送到客户端之前可以在 <strong>中央节点</strong> 上排队。此特性使得 RabbitMQ 易于使用和部署，但是使得其 <strong>运行速度较慢</strong>，因为中央节点 <strong>增加了延迟</strong>，<strong>消息封装后</strong> 也比较大；</li><li>需要学习 <strong>比较复杂</strong> 的 <strong>接口和协议</strong>，学习和维护成本较高。</li></ol><p><strong>7.3. RocketMQ</strong></p><p>RocketMQ 出自 <strong>阿里</strong> 的开源产品，用 Java 语言实现，在设计时参考了 Kafka，并做出了自己的一些改进，<strong>消息可靠性上</strong> 比 Kafka 更好。RocketMQ 在阿里内部被广泛应用在 <strong>订单</strong>，<strong>交易</strong>，<strong>充值</strong>，<strong>流计算</strong>，<strong>消息推送</strong>，<strong>日志流式处理</strong>，binglog <strong>分发</strong> 等场景。</p><p><strong>(a) 主要特性</strong></p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b13b0202837e41438f1565fc6baa6882><p class=pgc-img-caption></p></div><p>img</p><ol><li>基于 <strong>队列模型</strong>：具有 <strong>高性能</strong>、<strong>高可靠</strong>、<strong>高实时</strong>、<strong>分布式</strong> 等特点；</li><li>Producer、Consumer、<strong>队列</strong> 都支持 <strong>分布式</strong>；</li><li>Producer 向一些队列轮流发送消息，<strong>队列集合</strong> 称为 Topic。Consumer 如果做 <strong>广播消费</strong>，则一个 Consumer 实例消费这个 Topic 对应的 <strong>所有队列</strong>；如果做 <strong>集群消费</strong>，则 <strong>多个</strong> Consumer 实例 <strong>平均消费</strong> 这个 Topic 对应的队列集合；</li><li>能够保证 <strong>严格的消息顺序</strong>；</li><li>提供丰富的 <strong>消息拉取模式</strong>；</li><li>高效的订阅者 <strong>水平扩展</strong>能力；</li><li><strong>实时</strong> 的 <strong>消息订阅机制</strong>；</li><li>亿级 <strong>消息堆积</strong> 能力；</li><li>较少的外部依赖。</li></ol><p><strong>(b) 部署环境</strong></p><p>RocketMQ 可以运行在 Java 语言所支持的平台之上。使用 RocketMQ 需要：</p><ul><li>Java JDK</li><li>安装 git、Maven</li><li>RocketMQ 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li><strong>单机</strong> 支持 1 万以上 <strong>持久化队列</strong>；</li><li>RocketMQ 的所有消息都是 <strong>持久化的</strong>，先写入系统 PAGECACHE，然后 <strong>刷盘</strong>，可以保证 <strong>内存</strong> 与 <strong>磁盘</strong> 都有一份数据，而 <strong>访问</strong> 时，直接 <strong>从内存读取</strong>。</li><li>模型简单，接口易用（JMS 的接口很多场合并不太实用）；</li><li><strong>性能非常好</strong>，可以允许 <strong>大量堆积消息</strong> 在 Broker 中；</li><li>支持 <strong>多种消费模式</strong>，包括 <strong>集群消费</strong>、<strong>广播消费</strong>等；</li><li>各个环节 <strong>分布式扩展设计</strong>，支持 <strong>主从</strong> 和 <strong>高可用</strong>；</li><li>开发度较活跃，版本更新很快。</li></ol><p><strong>(d) 缺点</strong></p><ol><li>支持的 <strong>客户端语言</strong> 不多，目前是 Java 及 C++，其中 C++ 还不成熟；</li><li>RocketMQ 社区关注度及成熟度也不及前两者；</li><li>没有 Web 管理界面，提供了一个 CLI (命令行界面) 管理工具带来 <strong>查询</strong>、<strong>管理</strong> 和 <strong>诊断各种问题</strong>；</li><li>没有在 MQ 核心里实现 JMS 等接口；</li></ol><p><strong>7.4. Kafka</strong></p><p>Apache Kafka 是一个 <strong>分布式消息发布订阅</strong> 系统。它最初由 LinkedIn 公司基于独特的设计实现为一个 <strong>分布式的日志提交系统</strong> (a distributed commit log)，之后成为 Apache 项目的一部分。Kafka <strong>性能高效</strong>、<strong>可扩展良好</strong> 并且 <strong>可持久化</strong>。它的 <strong>分区特性</strong>，<strong>可复制</strong> 和 <strong>可容错</strong> 都是其不错的特性。</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6b643555fa81421ba3d879f607be81f4><p class=pgc-img-caption></p></div><p>img</p><p><strong>(a) 主要特性</strong></p><ol><li><strong>快速持久化</strong>：可以在 O(1) 的系统开销下进行 <strong>消息持久化</strong>；</li><li><strong>高吞吐</strong>：在一台普通的服务器上既可以达到 10W/s 的 <strong>吞吐速率</strong>；</li><li><strong>完全的分布式系统</strong>：Broker、Producer 和 Consumer 都原生自动支持 <strong>分布式</strong>，自动实现 <strong>负载均衡</strong>；</li><li>支持 <strong>同步</strong> 和 <strong>异步</strong> 复制两种 <strong>高可用机制</strong>；</li><li>支持 <strong>数据批量发送</strong> 和 <strong>拉取</strong>；</li><li><strong>零拷贝技术(zero-copy)</strong>：减少 IO 操作步骤，提高 <strong>系统吞吐量</strong>；</li><li><strong>数据迁移</strong>、<strong>扩容</strong> 对用户透明；</li><li><strong>无需停机</strong> 即可扩展机器；</li><li><strong>其他特性</strong>：丰富的 <strong>消息拉取模型</strong>、高效 <strong>订阅者水平扩展</strong>、实时的 <strong>消息订阅</strong>、亿级的 <strong>消息堆积能力</strong>、定期删除机制；</li></ol><p><strong>(b) 部署环境</strong></p><p>使用 Kafka 需要：</p><ul><li>Java JDK</li><li>Kafka 安装包</li></ul><p><strong>(c) 优点</strong></p><ol><li><strong>客户端语言丰富</strong>：支持 Java、.Net、PHP、Ruby、Python、Go 等多种语言；</li><li><strong>高性能</strong>：单机写入 TPS 约在 100 万条/秒，消息大小 10 个字节；</li><li>提供 <strong>完全分布式架构</strong>，并有 replica 机制，拥有较高的 <strong>可用性</strong> 和 <strong>可靠性</strong>，理论上支持 <strong>消息无限堆积</strong>；</li><li>支持批量操作；</li><li><strong>消费者</strong> 采用 Pull 方式获取消息。<strong>消息有序</strong>，<strong>通过控制</strong> 能够保证所有消息被消费且仅被消费 <strong>一次</strong>；</li><li>有优秀的第三方 Kafka Web 管理界面 Kafka-Manager；</li><li>在 <strong>日志领域</strong> 比较成熟，被多家公司和多个开源项目使用。</li></ol><p><strong>(d) 缺点</strong></p><ol><li>Kafka 单机超过 64 个 <strong>队列/分区</strong> 时，Load 时会发生明显的飙高现象。<strong>队列</strong> 越多，<strong>负载</strong> 越高，发送消息 <strong>响应时间变长</strong>；</li><li>使用 <strong>短轮询方式</strong>，<strong>实时性</strong> 取决于 <strong>轮询间隔时间</strong>；</li><li>消费失败 <strong>不支持重试</strong>；</li><li>支持 <strong>消息顺序</strong>，但是 <strong>一台代理宕机</strong> 后，就会产生 <strong>消息乱序</strong>；</li><li>社区更新较慢。</li></ol><p><strong>7.5. 几种消息队列对比</strong></p><p>这里列举了上述四种消息队列的差异对比：</p><div class=pgc-img><img alt=浅谈消息队列及常见的消息中间件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fec5d46cb0d44334accd6a6a7f0b939f><p class=pgc-img-caption></p></div><p>img</p><p>Kafka 在于 <strong>分布式架构</strong>，RabbitMQ 基于 AMQP <strong>协议</strong> 来实现，RocketMQ 的思路来源于 Kafka，改成了 <strong>主从结构</strong>，在 <strong>事务性</strong> 和 <strong>可靠性</strong> 方面做了优化。广泛来说，<strong>电商</strong>、<strong>金融</strong> 等对 <strong>事务一致性</strong> 要求很高的，可以考虑 RabbitMQ 和 RocketMQ，对 <strong>性能要求高</strong> 的可考虑 Kafka。</p><h1><strong>小结</strong></h1><p>本文介绍了消息队列的特点，消息队列的 <strong>传递服务模型</strong>，消息的 <strong>传输方式</strong>，消息的 <strong>推拉模式</strong>。然后介绍了 ActiveMQ，RabbitMQ，RocketMQ 和 Kafka 几种常见的消息队列，阐述了 <strong>各种消息队列</strong> 的 <strong>主要特点</strong> 和 <strong>优缺点</strong>。通过本文，对于消息队列及相关技术选型，相信你会有了更深入的理解和认识。更多细节和原理性的东西，还需在实践中见真知！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'浅谈','队列','及常见'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/bd67ae90.html alt=浅谈消息队列用途及常见的消息中间件的区别 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b0acb1aef6b4fe792b1fbd6a18d26f4 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/bd67ae90.html title=浅谈消息队列用途及常见的消息中间件的区别>浅谈消息队列用途及常见的消息中间件的区别</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>