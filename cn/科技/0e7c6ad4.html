<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>CC++语言15｜类的继承和派生实现代码重用、扩充 | 极客快訊</title><meta property="og:title" content="CC++语言15｜类的继承和派生实现代码重用、扩充 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/4983def52247451589ab482f2921c1aa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0e7c6ad4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e7c6ad4.html><meta property="article:published_time" content="2020-11-14T21:01:00+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:00+08:00"><meta name=Keywords content><meta name=description content="CC++语言15｜类的继承和派生实现代码重用、扩充"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0e7c6ad4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>CC++语言15｜类的继承和派生实现代码重用、扩充</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>在C++中，继承是一个对象自动获取其父对象的所有属性和行为的过程。通过继承，您可以重用，扩展或修改在其他类中定义的属性和行为。通过继承，可以实现函数重写以及多态。</p><p>在C++中，继承另一个类的成员的类称为派生类，其成员被继承的类称为基类。 派生类是基类的子类。</p><p>继承代表了 <strong>is a</strong> 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。</p><pre>C++最强大的功能之一就是派生类的使用。通过其类提供类和对象的更一般的属性和行为，通过派生类来逐步特殊化、具体化，体现出一种层次化的关系。既能达到代码重用，还可添加成员或重写成员函数。继承一般有三种形式1) 实现继承：派生类使用基类的属性和方法而无需额外编码；2) 可视继承：子窗体使用父窗体的外观和实现代码；3) 接口继承：仅使用属性和方法，实现滞后到子类实现；</pre><p>如C++的输入输出流类就能会很地体现这种继承和派生的层次关系：</p><div class=pgc-img><img alt=C\C++语言15｜类的继承和派生实现代码重用、扩充 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4983def52247451589ab482f2921c1aa><p class=pgc-img-caption></p></div><p>定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p><pre>class derived-class: access-specifier base-class</pre><p>其中，访问修饰符 access-specifier可以是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。</p><p>实例：</p><pre>#include &lt;iostream&gt;using namespace std;// 基类class Shape{public:	void setWidth(int w)	{		width = w;	}	void setHeight(int h)	{		height = h;	}protected:	int width;	int height;};// 派生类class Rectangle: public Shape{public:	int getArea()	{		return (width * height);	}};int main(void){	Rectangle Rect;	Rect.setWidth(5);	Rect.setHeight(7);	// 输出对象的面积	cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;	system("pause");	return 0;}//输出：Total area: 35</pre><h1>1 访问控制和继承</h1><p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p><p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p><div class=pgc-img><img alt=C\C++语言15｜类的继承和派生实现代码重用、扩充 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/887a926919b44cc0a0670b28452b0117><p class=pgc-img-caption></p></div><h1><strong>2 派生类不能继承的函数成员</strong></h1><p>一个派生类继承了所有的基类方法，但下列情况除外：</p><ul><li>基类的构造函数、析构函数和拷贝构造函数。</li><li>基类的重载运算符。</li><li>基类的友元函数。</li></ul><p>用派生的方法定义一个派生类时，派生类对象中的基类部分必须在构造函数的初始化列表中调用基类的构造函数完成，如：</p><blockquote><p>#include &lt;iostream.h></p><p>#include &lt;string.h></p><p>//代码清单12-11　派生类定义实例car派生taxi</p><p>class car {</p><p>char no[10];</p><p>char owner[10];</p><p>char type[20];</p><p>public:</p><p>car(char *s1, char *s2, char *s3)</p><p>{</p><p>strcpy(no, s1);</p><p>strcpy(owner, s2);</p><p>strcpy(type, s3);</p><p>}</p><p>void modifyNo(char *s) {strcpy(no, s); }</p><p>void modifyOwner(char *s) {strcpy(owner, s); }</p><p>const char *getNo() const { return no; }</p><p>const char *getOwner() const {return owner; }</p><p>const char *getType() const { return type; }</p><p>};</p><p>class taxi : public car {</p><p>int seat;</p><p>double price;</p><p>public:</p><p>taxi(char *s1, char *s2, char *s3, int s, double p):car(s1,s2,s3)</p><p>{seat = s; price = p; }</p><p>double operator() (int start, int end)</p><p>{ return price *(end-start); }</p><p>int getSeat() const {return seat; }</p><p>double getPrice() const { return price; }</p><p>};</p><p>int main()</p><p>{</p><p>car car1("沪A01100", "张三","法拉利");</p><p>taxi taxi1("沪B01100", "李四", "桑塔纳", 5, 2.5);</p><p>cout &lt;&lt; car1.getNo() &lt;&lt;""&lt;&lt; car1.getOwner() &lt;&lt;""&lt;&lt; car1.getType() &lt;&lt; endl;</p><p>cout &lt;&lt; taxi1.getNo() &lt;&lt;""&lt;&lt; taxi1.getOwner() &lt;&lt;""&lt;&lt; taxi1.getType() &lt;&lt; endl;</p><p>cout &lt;&lt; taxi1(1000, 1005) &lt;&lt; endl;</p><p>cin.get();</p><p>return 0;</p><p>}</p><p>/*</p><p>沪A01100张三法拉利</p><p>沪B01100李四桑塔纳</p><p>12.5</p><p>/*</p></blockquote><h1><strong>3 继承类型</strong></h1><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p><p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p><p>3.1 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p><p>3.2 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</p><p>3.3 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</p><h1><strong>4 多继承</strong></h1><p>一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数，称为多继承。多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p><p>C++ 类可以从多个类继承成员，语法如下：</p><pre>class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…{&lt;派生类类体&gt;};</pre><p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例：</p><pre>#include &lt;iostream&gt;using namespace std;// 基类 Shapeclass Shape {public:	void setWidth(int w)	{		width = w;	}	void setHeight(int h)	{		height = h;	}protected:	int width;	int height;};// 基类 PaintCostclass PaintCost {public:	int getCost(int area)	{		return area * 70;	}};// 派生类class Rectangle: public Shape, public PaintCost{public:	int getArea()	{ 		return (width * height); 	}};int main(void){	Rectangle Rect;	int area;		Rect.setWidth(5);	Rect.setHeight(7);		area = Rect.getArea();		// 输出对象的面积	cout &lt;&lt; "Total area: " &lt;&lt; Rect.getArea() &lt;&lt; endl;		// 输出总花费	cout &lt;&lt; "Total paint cost: $" &lt;&lt; Rect.getCost(area) &lt;&lt; endl;	system("pause");	return 0;}/*Total area: 35Total paint cost: $2450/*</pre><p>－End－</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'C++','语言','15'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>