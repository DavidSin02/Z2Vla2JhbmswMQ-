<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>采用简易的环形延时队列处理秒级定时任务的解决方案 | 极客快訊</title><meta property="og:title" content="采用简易的环形延时队列处理秒级定时任务的解决方案 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/434a00018b202e79d0b7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0e9dfab4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0e9dfab4.html><meta property="article:published_time" content="2020-10-29T21:09:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:58+08:00"><meta name=Keywords content><meta name=description content="采用简易的环形延时队列处理秒级定时任务的解决方案"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0e9dfab4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>采用简易的环形延时队列处理秒级定时任务的解决方案</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>业务背景</h1><p>在稍微复杂点业务系统中，不可避免会碰到做定时任务的需求，比如淘宝的交易超时自动关闭订单、超时自动确认收货等等。对于一些定时作业比较多的系统，通常都会搭建专门的调度平台来管理，通过创建定时器来周期性执行任务。如刚才所说的场景，我们可以给订单创建一个专门的任务来处理交易状态，每秒轮询一次订单表，找出那些符合超时条件的订单然后标记状态。这是最简单粗暴的做法，但明显也很low，自己都下不去手写这样的代码，所有必须要找个更好的方案。</p><p>回到真实项目中的场景，系统中某个活动上线后要给目标用户发送短信通知，这些通知需要按时间点批量发送。虽然已经基于quartz.net给系统搭建了任务调度平台，但着实不想用上述方案来实现。在网上各种搜索和思考，找到一篇文章让我眼前一亮，稍加分析发现里面的思路完全符合现在的场景，于是决定在自己项目中实现出来。</p><h1>原理分析</h1><p>这种方案的核心就是构造一种数据结构，称之为环形队列，但实际上还是一个数组，加上对它的循环遍历，达到一种环状的假象。然后再配合定时器，就可以实现按需延时的效果。上面提到的文章中也介绍了实现思路，这里我采用我的理解再更加详细的解释一下。</p><p>我们先为这个数组分配一个固定大小的空间，比如60，每个数组的元素用来存放任务的集合。然后开启一个定时器每隔一秒来扫描这个数组，扫完一圈刚好是一分钟。如果提前设置好任务被扫描的圈数（CycleNum）和在数组中的位置（Slot），在刚好扫到数组的Slot位置时，集合里那些CycleNum为0的任务就是达到触发条件的任务，拉出来做业务操作然后移除掉，其他的把圈数减掉一次，然后留到下次继续扫描，这样就实现了延时的效果。原理如下图所示：</p><p><img alt=采用简易的环形延时队列处理秒级定时任务的解决方案 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/434a00018b202e79d0b7></p><p>可以看出中间的重点是计算出每个任务所在的位置以及需要循环的圈数。假设当前时间为15:20:08，当前扫描位置是2，我的任务要在15:22:35这个时刻触发，也就是147秒后。那么我需要循环的圈数就是147/60=2圈，需要被扫描的位置就是(147+2)%60=29的地方。计算好任务的座标后塞到数组中属于它的位置，然后静静等待被消费就好啦。</p><h1>代码实现</h1><p>光讲原理不上代码怎么能行呢，根据上面的思路，下面一步步在.net平台下实现出来。</p><p>先做一些基础封装。</p><p>首先构造任务参数的基类，用来记录任务的位置信息和定义业务回调方法：</p><blockquote><p>public class DelayQueueParam</p><p>{</p><p>internal int Slot { get; set; }</p><p>internal int CycleNum { get; set; }</p><p>public Action&lt;object> Callback { get; set; }</p><p>}</p></blockquote><p>接下来是核心地方。再构造队列的泛型类，真实类型必须派生自上面的基类，用来扩展一些业务字段方便消费时使用。队列的主要属性有当前位置指针以及数组容器，主要的操作有插入、移除和消费。插入任务时需要传入执行时间，用来计算这个任务的座标。</p><blockquote><p>public class DelayQueue&lt;T> where T : DelayQueueParam</p><p>{</p><p>private List&lt;T>[] queue;</p><p>private int currentIndex = 1;</p><p>public DelayQueue(int length)</p><p>{</p><p>queue = new List&lt;T>[length];</p><p>}</p><p>public void Insert(T item, DateTime time)</p><p>{</p><p>//根据消费时间计算消息应该放入的位置</p><p>var second = (int)(time - DateTime.Now).TotalSeconds;</p><p>item.CycleNum = second / queue.Length;</p><p>item.Slot = (second + currentIndex) % queue.Length;</p><p>//加入到延时队列中</p><p>if (queue[item.Slot] == null)</p><p>{</p><p>queue[item.Slot] = new List&lt;T>();</p><p>}</p><p>queue[item.Slot].Add(item);</p><p>}</p><p>public void Remove(T item)</p><p>{</p><p>if (queue[item.Slot] != null)</p><p>{</p><p>queue[item.Slot].Remove(item);</p><p>}</p><p>}</p><p>public void Read()</p><p>{</p><p>if (queue.Length >= currentIndex)</p><p>{</p><p>var list = queue[currentIndex - 1];</p><p>if (list != null)</p><p>{</p><p>List&lt;T> target = new List&lt;T>();</p><p>foreach (var item in list)</p><p>{</p><p>if (item.CycleNum == 0)</p><p>{</p><p>//在本轮命中，用单独线程去执行业务操作</p><p>Task.Run(()=> { item.Callback(item); });</p><p>target.Add(item);</p><p>}</p><p>else</p><p>{</p><p>//等下一轮</p><p>item.CycleNum--;</p><p>System.Diagnostics.Debug.WriteLine($"@@@@@索引：{item.Slot}，剩余：{item.CycleNum}");</p><p>}</p><p>}</p><p>//把已过期的移除掉</p><p>foreach (var item in target)</p><p>{</p><p>list.Remove(item);</p><p>}</p><p>}</p><p>currentIndex++;</p><p>//下一遍从头开始</p><p>if (currentIndex > queue.Length)</p><p>{</p><p>currentIndex = 1;</p><p>}</p><p>}</p><p>}</p><p>}</p></blockquote><p>接下来是使用方法。</p><p>创建一个管理队列实例的静态类，里面封装对队列的操作：</p><blockquote><p>public static class NotifyPlanManager</p><p>{</p><p>private static DelayQueue&lt;NotifyPlan> _queue = new DelayQueue&lt;NotifyPlan>(60);</p><p>public static void Insert(NotifyPlan plan, DateTime time)</p><p>{</p><p>_queue.Insert(plan, time);</p><p>}</p><p>public static void Read()</p><p>{</p><p>_queue.Read();</p><p>}</p><p>}</p></blockquote><p>构建我们的实际业务参数类，派生自DelayQueueParam：</p><blockquote><p>public class NotifyPlan : DelayQueueParam</p><p>{</p><p>public Guid CamId { get; set; }</p><p>public int PreviousTotal { get; set; }</p><p>public int Amount { get; set; }</p><p>}</p></blockquote><p>生产端往队列中插入数据：</p><blockquote><p>Action&lt;object> callback = (result) =></p><p>{</p><p>var np = result as NotifyPlan;</p><p>//这里做自己的业务操作</p><p>//举个例子：</p><p>Debug.WriteLine($"活动ID：{np.CamId}，已发送数量：{np.PreviousTotal}，本次发送数量：{np.Amount}");</p><p>};</p><p>NotifyPlanManager.Insert(new NotifyPlan</p><p>{</p><p>Amount = set.MainAmount,</p><p>CamId = camId,</p><p>PreviousTotal = 0,</p><p>Callback = callback</p><p>}, smsTemplate.SendDate);</p></blockquote><p>再创建一个每秒执行一次的定时器用做消费端，我这里使用的是FluentScheduler，核心代码：</p><blockquote><p>internal class NotifyPlanJob : IJob</p><p>{</p><p>/// &lt;summary></p><p>/// 执行计划</p><p>/// &lt;/summary></p><p>public void Execute()</p><p>{</p><p>NotifyPlanManager.Read();</p><p>}</p><p>}</p><p>internal class JobFactory : Registry</p><p>{</p><p>public JobFactory()</p><p>{</p><p>//每秒运行一次</p><p>Schedule&lt;NotifyPlanJob >().ToRunEvery(1).Seconds();</p><p>}</p><p>}</p><p>JobManager.Initialize(new JobFactory());</p></blockquote><p>然后开启调试运行，打开本机的系统时间面板，对着时间看输出结果。亲测有效。</p><h1>总结</h1><p>这种方案的好处是避免了频繁地扫描数据库和不必要的业务操作，另外也很方便控制时间精度。带来的问题是如果web服务异常或重启可能会发生任务丢失的情况，我目前的处理方法是在数据库中标记任务状态，服务启动时把状态为“排队中”的任务重新加载到队列中等待消费。</p><p>以上方案在单机环境测试没问题，多节点情况下暂时没有深究。若有设计实现上的缺陷，欢迎讨论与指正，要是有更好的方案，那就当抛砖引玉，再好不过了~</p><p>文章作者：hoho 文章出处：http://www.cnblogs.com/hohoa/</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'采用','简易','环形'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>