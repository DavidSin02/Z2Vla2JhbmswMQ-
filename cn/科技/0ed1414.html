<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Polkadot系列｜混合共识详解 | 极客快訊</title><meta property="og:title" content="Polkadot系列｜混合共识详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/b57708f29a8443e5ad439539d0a26fb7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0ed1414.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0ed1414.html><meta property="article:published_time" content="2020-10-29T20:50:35+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:35+08:00"><meta name=Keywords content><meta name=description content="Polkadot系列｜混合共识详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0ed1414.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Polkadot系列｜混合共识详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong><br>Polkadot共识主要有三种</strong></p><p><strong>NPOS, BABE, GRANDPA</strong></p><p>接下来我们对这三种共识进行逐一的解释</p><p><strong>NPOS</strong></p><p><strong>什么是NPOS共识</strong></p><p>在Polkadot 中，中继链上的验证者需要分配到各个平行链，为它们提供区块链验证能力，是 Polkadot 共享安全性的一部分，因此中继链的验证者对于整个Polkadot多链系统的安全性至关重要。</p><p>如何公平安全地选举出中继链上的验证者也就成了保障整个系统共享安全性的第一步，是不可或缺的一步。</p><p>NPOS( Nominated Proof of Stake)共识算法就是用来选举出能让系统更安全，更高效的验证者集合的。和传统意义上的POS共识相比，NPOS算法结合了Polkadot链自身架构的一些特点，进行相应的优化。</p><p>下面看看NPOS是如何进行工作的。</p><p>在说明NPOS之前，我们需要先回顾一下Polkadot中重要的两种角色。</p><p>▲ 验证人</p><p>中继链的全节点，中继链会在验证人池中通过随机分组把验证人指定给不同的平行链。验证人会接受来自收集人打包的区块并进行有效性验证，然后结合共识算法对收集人提交的区块进行确认。</p><p>▲ 提名人</p><p>Polkadot中数字货币DOT的持有人，它会选择自己所信任的验证人进行DOT质押，然后分享验证人的收益。</p><p><strong>Polkadot的选举模型</strong>是建立在这两种角色基础上的。要成为验证人，必须先成为验证人候选人参加选举的过程，而这个选举过程中的“选民”就是提名人。</p><p>在Polkadot的设计中，提名人数量在理论是可以不设置上限的，如果能够让更多的提名者参与到投票阶段，那么参与到选举的资金量也就越大，整个系统就更加的安全；而对于验证者来说，为了区块链的性能，不能太多（所有节点都能作为验证者的话，那就是比特币采用的模式了），验证者的数量由系统确定的固定值，这一点来说和POS共识是一致的。</p><p><strong>选举模型</strong></p><p>为了明确选举问题，Polkadot中将选举验证者集合的问题抽象为一个数学的选举问题：</p><p>▲ <strong>问题：</strong>m 个选民对 n 个候选者的情况下，选出最终的 t 为当选者</p><p>（注：提名人可以有任意个，验证者是有限个）</p><p>问题的描述很简单，但是如何做到让系统更安全，会有不同的策略。Polkadot的设计哲学中，认为选举策略需要满足下面的“三大原则”：</p><p><strong>Balance:</strong> 验证者在出块时候的比重相同，因此该策略在Stake分配需要尽量平均，保证网络的安全；</p><p><strong>Support: </strong>该策略需要让尽可能多的 Stake 资金参与进来。因为提名者只负责选投哪些候选者，但是对于的 Stake具体分配给多少到哪个验证者是没有决定权的，这部分是NPOS算法通过计算来决定的。这也是NPOS和普通的POS共识中很大的不同之处；</p><p><strong>Fair representation: </strong>Stake 多的提名者选投的验证人更可能出现在验证者集合中。</p><p>基于上述的问题和要求，可以将该问题转化为下面的数学模型：<br></p><ul><li>输入：给定，其中是Nominator集合，是Validator候选者集合，是边的集合，表示提名者投了候选者一票。同时给定向量 ,表示各个提名者各自的Stake数量，是选出的最终验证者集合的大小。</li><li>输出：给定解，其中是最终选定的Validator，大小为， 是提名者分配多少 Stake 到最终的Validator。</li><li>限制条件：</li><li>Balance: 给定，能够给出一个 ，使得最小</li><li>Support: 给定，能够给出一个 ，使得最大</li></ul><p>Fair representation: proportional justified representation(PJR)规则</p><ul><li>任意一个 ,都不会存在一个提名者的子集，导致出现下面的情况：</li></ul><div class=pgc-img><img alt=Polkadot系列｜混合共识详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b57708f29a8443e5ad439539d0a26fb7><p class=pgc-img-caption></p></div><p>用较为通俗的话来说就是不允许出现：存在某些中的提名者的stake 超过了总的staking的的比重，并且他们支持的人选有交集的超过个，但是他们支持的Validator的数量入选却没有超过个。</p><p>上述的问题在数学上就是一个最优化问题，很可惜这个选举在数学上已经被证明是 NP完全问题，并不能在多项式时间内给出最优解。</p><p>所以Polkadot给出了自己的一套解决方案，来绕过这个难解问题。</p><p><strong>NPOS流程</strong></p><p>上述推导的数学模型中，由于是NP完全问题，也就是说给出最优解的计算时间复杂度是无法确定在多项式时间内的。</p><p>Polkadot给出了一个相对来说可行的方案。</p><p>不追求最优解，达到相对最优即可NP完全问题中给出可行解是很困难的，但是验证已有解是简单的，能在多项式时间内完全。所以验证可行解的部分放在链上进行。</p><p><strong>▲ 完整的流程如下：</strong></p><div class=pgc-img><img alt=Polkadot系列｜混合共识详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/58cc71ee4f3a4680a7ded023160b5755><p class=pgc-img-caption></p></div><p>在提名者给出自己的投票之后，每一个候选者都可以给出自己对于上述选举问题的一个可行解。</p><p>在上述这些可行解的集合中，利用链上的方案比较方案，按照之前的“三大原则”来比较这些方案，选取其中最优的方案最为最后验证人选举结果，这样就完成了一轮选举。</p><p><br></p><p><strong>BABE</strong></p><p>BABE的全称是Blind Assignment for Blockchain Extension，BABE是一个用来出块的引擎，类似于Ourobros Praos，一种PoS的协议。BABE算法是基于slots的。</p><p>在Polkadot中每一个slot差不多6秒长的时间。</p><p>每个slot时间段中BABE会选出一个leader来出块。</p><p>BABE中leader的选举是通过一个随机函数（VRF）来实现的，在每个slot阶段，每一个节点会通过运算VRF函数来获得一个数值，如果这个数值小于网络中预先规定好的阈值，那么节点就会认为自己就是这个时间段的leader，于是节点就开始出块了。</p><p>值得注意的是在上述的过程中，由于VRF函数是随机生成数字的，所以可能造成在某一slot中没有leader或者有多个节点算出自己的VRF值小于阈值进而产生多个leader的情况。我们依次分析两种情况：</p><p>当没有leader产生时，Polkadot就规定按照顺序来决定谁是leader，这个顺序是预先确定好的。</p><p>当出现多个leader的时候，Polkadot允许多个节点都提交区块，而最终区块的确认则由GRANDPA来决定。</p><p><br></p><p><strong>GRANDPA</strong></p><p>GRANDPA则是用来做区块确认的，在文章的第二部分我们有提到BABE将会对Polkadot的交易进行出块，那么这些出块最终就是由GRANDPA来确定的。</p><p>像其他PBFT的衍生算法一样，GRANDPA的时间复杂度也是<em><strong>O(n²)</strong></em>。但是Polkadot之所以采用GRANDPA是因为GRANDPA并不是每次只确认一个区块，它每一次都会确定好几个区块来做确认。</p><ul><li style=text-align:right;list-style-position:inside><br></li><li style=text-align:right;list-style-position:inside><br></li><li style=text-align:right;list-style-position:inside><br></li></ul><pre><code>Idle (24 peers), best: #664257 (0x706c…76b7), finalized #664253 (0xe4ab…4d2a)Imported #664258 (0xee71…6321)Idle (24 peers), best: #664258 (0xee71…6321), finalized #664256 (0x809a…a5d8)</code></pre><p>上面是Polkadot测试网络的一段日志，可以看到一次确认区块高度从664253到了664256，所以GRANDPA一次性确认了三个区块。这样的话跟一次性只确认一个相比，GRANDPA的效率要比其他PBFT的衍生算法要高出很多。</p><p><strong>▲ </strong>下面介绍一下<strong>GRANDPA的具体流程</strong>：</p><p>1. 一个主节点广播之前一轮确认后的区块高度；</p><p>2. 等待网络延迟以后，每个节点都广播他们认为的可以被确认的最高的区块（pre-vote）；</p><p>3. 每个节点对步骤2接受到的区块集进行计算，算出他们认为的能够被确认的最高区块，并且将结果广播出去(pre-commit)；</p><p>4. 当节点接收到足够的pre-commit的消息能够确认区块后就会形成commit的消息，一般认为大于2/3就可以被确认了。</p><p>上述就是GRANDPA确认区块的主要流程。</p><p>我们需要担心的是在步骤2的pre-vote过程中可能会有作恶的节点投票了两个区块并且广播出去，这样的话就有可能产生链的分叉行为。</p><p>Polkadot为了防止这种情况的发生使用了一个叫做<strong>Account Safety</strong>的方式。</p><p>如果当网络中出现了要分叉的commit信息时，Polkadot的节点会马上采取Account Safety的机制。每个节点都会询问其他节点他们所看到的pre-vote的情况，节点都会回复他们收到的信息，这样就很容易检查到有哪些恶意节点投了两个区块。最后这些被抓到的作恶节点将会被踢出共识网络，永远不能进入。</p><p>让我们回到BABE，通过结合BABE和GRANDPA我们可以看到在出块的时候Polkadot采用BABE出块，此时节点之间只要发送一次块信息即可，这样的话时间复杂度仅仅是<em><strong>O(n)</strong></em>，在出块之后节点之间再采用GRANDPA进行块确认，此时由于确认阶段节点之间要通过二次确认来保证确认块结果的一致性，时间复杂度是<em><strong>O(n²)</strong></em>，不过由于是多个块一次性进行确认，所以两者结合的混合共识是非常高效的，比普通的PBFT共识要高效很多。</p><p><br></p><p><strong>结语</strong></p><p>上面三种就是我们向大家介绍的Polkadot的共识算法，可以看到NPOS主要是为了选取Polkadot的共识节点，BABE和GRANDPA通过混合来高效的进行区块链的出块和确认。</p><p>这样的混合共识比传统的PBFT共识速度更快，并且在速度更快的基础上并没有丢失掉安全性。将出块和确认区块两个阶段分开并且使用不同的算法是在区块链共识中值得学习的地方。</p><p>通过这三种算法，Polkadot可以说在一定程度上高效的实现了Polkadot上区块链的共识算法。</p><p><br></p><p>参考文献：</p><p>[1] Ouroboros Praos: An adaptively-secure, semi-synchronous proof-of-stake blockchain Bernardo David , Peter Gaˇzi , Aggelos Kiayias November 14, 2017</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Polkadot','共识','详解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>