<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基于异常的猎杀行动——自保护触发自杀 | 极客快訊</title><meta property="og:title" content="基于异常的猎杀行动——自保护触发自杀 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/02304faf-c13a-4a5c-8140-936c459a313f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f7e8d99.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f7e8d99.html><meta property="article:published_time" content="2020-11-14T21:02:39+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:39+08:00"><meta name=Keywords content><meta name=description content="基于异常的猎杀行动——自保护触发自杀"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0f7e8d99.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基于异常的猎杀行动——自保护触发自杀</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=基于异常的猎杀行动——自保护触发自杀 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/02304faf-c13a-4a5c-8140-936c459a313f><p class=pgc-img-caption></p></div><p></p><h1 class=pgc-h-arrow-right>0、引言</h1><p>这次分析的问题 ，非常又意思，一款软件的自保护机制触发了，抛出了一次异常，在异常链的处理中做了点简单的检测，命中则再次触发一次异常，即异常中嵌套异常，然而最具有挑战意思的事情是如何找到案发第一现场，屋漏偏逢连夜雨，Windbg提供的常用命令集体罢工，增添了分析的趣味性。做一次侦探，从dmp的蛛丝马迹中找到案发第一现场，分析问题的根本原因，便是此文的来由。</p><p>涉及到以下知识点：</p><p>1、命令失效时，如何手动在dmp中找到关键调用，关键数据；</p><p>2、如何手动重构栈帧，复原调用栈；</p><p>3、用户态异常分发的优先级及路径；</p><p>4、32位下，OS从内核分发至用户态时做的关键动作，64位下又有何区别；</p><p>5、嵌套的异常如何找到案发第一现场；</p><p></p><h1 class=pgc-h-arrow-right>1、背景</h1><p>周末闲居在家，老友发来求助信息，说是玩游戏玩的好好的，突然崩溃了，作为软件开发的他自然想探寻下crash的原因罗，通过Everything搜索了下电脑上的*.dmp，找到了本次游戏崩溃产生的dmp文件。题外话，游戏一般都会在crash时保存下dmp，并发送至后台处理，这里能找到也就不奇怪了。然后便祭出神器——Windbg开始分析，但由于各种原因诸如MiniDump，没有PDB，栈回溯失败，Windbg的很多自动化命令失效等等原因，没有分析各所以然出来，遂抛给了我，请我助其一臂之力，看看到底是啥子原因。分析之余，觉得挺有意思，撰文以分享之。</p><p></p><h1 class=pgc-h-arrow-right>2、分析过程</h1><p>2.1 step1：看一下异常记录，如下，为了规避哪款游戏，这里隐藏着与游戏相关的信息，包括游戏的各个模块名，代之以GameModule,GameExe这样的名字；</p><pre><code>0:023&gt; .exr -1ExceptionAddress: 013e50c1 (GameExe+0x000050c1)   ExceptionCode: c0000005 (Access violation)  ExceptionFlags: 00000000NumberParameters: 2   Parameter[0]: 00000001   Parameter[1]: 00000000Attempt to write to address 00000000</code></pre><p>常规的异常，往空指针里写数据了；</p><p>2.2 step2：再看下异常上下文，如下：</p><pre><code>0:023&gt; .ecxreax=000001e7 ebx=7755d418 ecx=7f1d0720 edx=00000000 esi=00000000 edi=0b369ee8eip=013e50c1 esp=0ea8e600 ebp=0ea8e644 iopl=0         nv up ei pl nz ac pe nccs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00010216GameExe+0x50c1:013e50c1 a300000000      mov     dword ptr ds:[00000000h],eax ds:002b:00000000=????????</code></pre><p>与上边异常记录给的信息也是吻合的，但这条反汇编代码非常的奇怪，居然是硬编码好了的往0x00000000地址中写数据，这到底是在干嘛？看下附近的反汇编代码吧，看看在干什么，如下：</p><pre><code>0:023&gt; u 013e5090  l20GameExe+0x5090:013e5090 8b442404        mov     eax,dword ptr [esp+4]013e5094 8b00            mov     eax,dword ptr [eax]013e5096 813803000080    cmp     dword ptr [eax],80000003h013e509c 752a            jne     GameExe+0x50c8 (013e50c8)013e509e 68982d4e01      push    offset GameExe+0x102d98 (014e2d98)013e50a3 6a00            push    0013e50a5 68982d4e01      push    offset GameExe+0x102d98 (014e2d98)013e50aa 68982d4e01      push    offset GameExe+0x102d98 (014e2d98)013e50af 688c2e4e01      push    offset GameExe+0x102e8c (014e2e8c)013e50b4 e8e7e00300      call    GameExe+0x431a0 (014231a0)013e50b9 83c414          add     esp,14h013e50bc e8cfe00300      call    GameExe+0x43190 (01423190)013e50c1 a300000000      mov     dword ptr ds:[00000000h],eax013e50c6 ebfe            jmp     GameExe+0x50c6 (013e50c6)013e50c8 33c0            xor     eax,eax013e50ca c20400          ret     4</code></pre><p>从上边反汇编出来的代码来看，有意思的还不仅仅是这一行代码，紧接着的下一行代码也是非常奇怪，死循环，在原地打转。越来越有趣了，简单分析下这段代码的功能：</p><p>首先，这个函数没有自己独立的栈帧，[esp+4]取出的便是第一个参数，而这个函数也只有一个参数，ret 4可以说明；当然这里边没有用到ecx，edx之类的寄存器，所以就排除了寄存器传参的可能性；</p><p>接着，80000003h这个数字有着特殊的含义的，正如C0000005h代表的是 EXCEPTION_ACCESS_VIOLATION，80000003h代表的是 EXCEPTION_BREAKPOINT;</p><pre><code>节选自WinBase.h和WinNT.h#define STATUS_ACCESS_VIOLATION          ((DWORD)0xC0000005L)#define STATUS_BREAKPOINT                ((DWORD)0x80000003L)  #define EXCEPTION_ACCESS_VIOLATION       STATUS_ACCESS_VIOLATION#define EXCEPTION_BREAKPOINT             STATUS_BREAKPOINT</code></pre><p>这就更增加了问题的有趣性，显然这里是在判断当前异常是不是EXCEPTION_BREAKPOINT，不是的话直接返回0，什么也不干；否则的话则调用其他函数处理，然后再次触发写0x00000000地址，再次嵌套触发异常，触发自杀；我的第一反应是：游戏在做反调试的事情吗？但立马又否定了这个想法，原因很简单——如果当前进程处于调试状态，EXCEPTION_BREAKPOINT异常压根不会派遣给进程，调试器就给处理掉了。当然，我们也可以看下，进程是否被调试，如下：</p><pre><code>0:023&gt; !pebPEB at 00889000    InheritedAddressSpace:    No    ReadImageFileExecOptions: No    BeingDebugged:            No    ImageBaseAddress:         013e0000    Ldr                       7755fbe0+0x068 NtGlobalFlag     : 0</code></pre><p>这些证据都或多或少的证实着，当前的游戏进程没有被调试。[后边会专门写文章讲解异常是如何被CPU发现并转交给OS，OS又是如何确认是内核异常还是用户态异常，如果是用户态异常，OS又是如何分发给用户态进程的。]。先不着急回答这些问题，看下栈回溯，看看程序的执行路径；</p><p>2.3 step3：栈回溯，如下：</p><pre><code>0:023&gt; k# ChildEBP RetAddr  WARNING: Stack unwind information not available. Following frames may be wrong.00 0ea8e644 774af15a GameExe+0x50c101 0ea8e6d8 774c088f ntdll!RtlDispatchException+0x7c02 0ea8e6d8 0f688051 ntdll!KiUserExceptionDispatcher+0xf03 0ea8eb9c 0f652ee8 libcef+0x19805104 0ea8f0e8 116521a8 libcef+0x162ee805 0ea8f264 116529ba libcef+0x21621a806 0ea8f2bc 1167c36c libcef+0x21629ba07 0ea8f2c8 11636600 libcef+0x218c36c08 0ea8f4e0 11650bb1 libcef+0x214660009 0ea8f524 11b4b196 libcef+0x2160bb10a 0ea8f538 0f692ab5 libcef+0x265b1960b 0ea8f594 0f65f0ef libcef+0x1a2ab50c 0ea8f6d8 0f65eae3 libcef+0x16f0ef0d 0ea8f758 0f6943b7 libcef+0x16eae30e 0ea8f77c 0f65ee20 libcef+0x1a43b70f 0ea8f7ac 0f65eddd libcef+0x16ee2010 0ea8f7d4 0f67a94b libcef+0x16eddd11 0ea8f7dc 0f67ad9a libcef+0x18a94b12 0ea8f814 0f65d2e2 libcef+0x18ad9a13 0ea8f830 76da62c4 libcef+0x16d2e214 0ea8f844 774b0f79 kernel32!BaseThreadInitThunk+0x2415 0ea8f88c 774b0f44 ntdll!__RtlUserThreadStart+0x2f16 0ea8f89c 00000000 ntdll!_RtlUserThreadStart+0x1b</code></pre><p>由于没有符号，当然也肯定不会有罗，所以回溯出来的栈可读性差，但不要紧，做逆向分析，不也这样的嘛。但这个栈不正常，这里还没有进入SEH的分发，而是在VEH就被拦截掉了；VHE的全称是Vectored Exception Handling，向量化异常处理，这个与SEH不太一样，且只能用在Ring3，是进程级别的，不像SEH是线程级别的，异常在分发时，先遍历VEH链，处理了则不会继续往后传递，没处理则继续后遍历，分发异常；我为什么说当前处于VEH呢？很简单，因为没有看见SEH的特征处理函数，哪怕是相关联的一点点函数调用的影子都没有，为了打消你的疑虑，我们来逆向分析下ntdll!RtlDispatchException的关键部分，这个函数很大，我们就看看774af15a返回地址附近的代码。</p><p>2.4 step4：逆向分析关键API的关键部分，如下：</p><pre><code>0:023&gt; u 774af13fntdll!RtlDispatchException+0x61:774af13f 7411            je      ntdll!RtlDispatchException+0x74 (774af152)774af141 e89137fcff      call    ntdll!RtlGuardIsValidStackPointer (774728d7)774af146 85c0            test    eax,eax774af148 0f8468010000    je      ntdll!RtlDispatchException+0x1d8 (774af2b6)774af14e 8b542410        mov     edx,dword ptr [esp+10h]774af152 53              push    ebx774af153 8bce            mov     ecx,esi774af155 e8f7610000      call    ntdll!RtlpCallVectoredHandlers (774b5351)774af15a 84c0            test    al,al774af15c 0f851c010000    jne     ntdll!RtlDispatchException+0x1a0 (774af27e)...省略774af22a e8b13a0200      call    ntdll!RtlpExecuteHandlerForException (774d2ce0)</code></pre><p>会判断RtlpCallVectoredHandlers()的返回值，如果是0的话，则调用RtlpExecuteHandlerForException()，那么0是啥意思呢？且看下边的定义，返回0意味着继续分发异常，也就是RtlpExecuteHandlerForException()中做的勒，即遍历SEH链进行异常的分发，暂且按下不表。</p><pre><code>节选自excpt.h#define EXCEPTION_EXECUTE_HANDLER       1#define EXCEPTION_CONTINUE_SEARCH       0#define EXCEPTION_CONTINUE_EXECUTION    -1</code></pre><p>回过头来看看上边游戏做的事情，如果不是EXCEPTION_BREAKPOINT则让异常继续分发，不做任何特殊处理，如果是EXCEPTION_BREAKPOINT的话，则没有接下来的事情了。简单分析下RtlpCallVectoredHandlers()即可知道OS是如何管理VEH的了，如下：</p><pre><code>0:023&gt; u ntdll!RtlpCallVectoredHandlers l30ntdll!RtlpCallVectoredHandlers:774b5351 8bff            mov     edi,edi774b5353 55              push    ebp774b5354 8bec            mov     ebp,esp774b5356 83ec30          sub     esp,30h774b5359 a1d4425677      mov     eax,dword ptr [ntdll!__security_cookie (775642d4)]774b535e 33c5            xor     eax,ebp774b5360 8945fc          mov     dword ptr [ebp-4],eax774b5363 8b4508          mov     eax,dword ptr [ebp+8]774b5366 53              push    ebx774b5367 56              push    esi774b5368 8bf1            mov     esi,ecx774b536a 6bd80c          imul    ebx,eax,0Ch774b536d 648b0d30000000  mov     ecx,dword ptr fs:[30h]774b5374 894df0          mov     dword ptr [ebp-10h],ecx774b5377 8d4802          lea     ecx,[eax+2]774b537a 33c0            xor     eax,eax774b537c 8955ec          mov     dword ptr [ebp-14h],edx774b537f 8b55f0          mov     edx,dword ptr [ebp-10h]774b5382 40              inc     eax774b5383 d3e0            shl     eax,cl774b5385 81c318d45577    add     ebx,offset ntdll!LdrpVectorHandlerList (7755d418)774b538b 57              push    edi774b538c 8975e0          mov     dword ptr [ebp-20h],esi774b538f 854228          test    dword ptr [edx+28h],eax774b5392 8b55ec          mov     edx,dword ptr [ebp-14h]774b5395 c645fb00        mov     byte ptr [ebp-5],0774b5399 894dd8          mov     dword ptr [ebp-28h],ecx774b539c 0f85cbaf0300    jne     ntdll!RtlpCallVectoredHandlers+0x3b01c (774f036d)774b53a2 8b4dfc          mov     ecx,dword ptr [ebp-4]774b53a5 8a45fb          mov     al,byte ptr [ebp-5]774b53a8 33cd            xor     ecx,ebp774b53aa 5f              pop     edi774b53ab 5e              pop     esi774b53ac 5b              pop     ebx774b53ad e88eb10000      call    ntdll!__security_check_cookie (774c0540)774b53b2 8be5            mov     esp,ebp774b53b4 5d              pop     ebp774b53b5 c20400          ret     4</code></pre><p>即通过ntdll!LdrpVectorHandlerList这个链表来管理每个Handler， AddVectoredExceptionHandler、 RemoveVectoredExceptionHandler分别往这个链表里增删项。https://docs.microsoft.com/en-us/windows/win32/debug/vectored-exception-handling</p><p>2.5 step5：寻找案发第一现场——分析起因</p><p>到目前为止，我们看见的所有的异常上下文，包括栈回溯，都是第二案发现场了，是”mov dword ptr ds:[00000000h],eax”这条指令触发的，它并不是最直接导致这次crash的罪魁祸首，顶多算个背锅的，自杀的罪名被他坐实了。按理说，如果嵌套了一次异常，那.cxr后执行k进行回溯的话，栈上应该有两个ntdll!KiUserExceptionDispatcher才对，我们看下现实的情况是怎样的：</p><pre><code>0:023&gt; .cxr;k# ChildEBP RetAddr  00 0ea8cd98 76f41d80 ntdll!NtWaitForMultipleObjects+0xc01 0ea8cf2c 76f41c78 kernelbase!WaitForMultipleObjectsEx+0xf002 0ea8cf48 71021997 kernelbase!WaitForMultipleObjects+0x18WARNING: Stack unwind information not available. Following frames may be wrong.03 0ea8dfdc 71021179 GameCrashdmp+0x199704 0ea8dfe4 774edff0 GameCrashdmp+0x117905 0ea8f88c 774b0f44 ntdll!__RtlUserThreadStart+0x3d0a606 0ea8f89c 00000000 ntdll!_RtlUserThreadStart+0x1b</code></pre><p>what？？？这是啥，居然一个ntdll!KiUserExceptionDispatcher都没有，刚刚上边.ecxr之后的k看栈回溯不是还有一个ntdll!KiUserExceptionDispatcher的吗？怎么现在一个都没有了？这当然是Windbg在栈回溯时除了问题了，而且也经常会出问题，这也怪不得他，原因有很多，我们没有符号，dmp也是Minidump类型的，有的也是FPO的，它回溯起来肯定会有问题的。现在就有两个问题需要解决了，第一：上边出现的这个ntdll!KiUserExceptionDispatcher是第一案发现场还是。。。</p><p>第二：如果是第一案发现场，那第二案发现场的ntdll!KiUserExceptionDispatcher如何找出来；</p><p>我们再用下Windbg提供的其他两个很厉害的命令来找ntdll!KiUserExceptionDispatcher，看看能不能揪出来，如下:</p><pre><code>0:023&gt; !ddstackRange: 0ea89000-&gt;0ea900000x0ea8cd90    0x664c17e5    nvwgf2um+005817e50x0ea8ce1c    0x76f4627c    kernelbase!CreateProcessW+0000002c0x0ea8e004    0x774c2330    ntdll!_except_handler4_common+000000800x0ea8e1c8    0x01426886    GameExe+000468860x0ea8e244    0x7755d418    ntdll!LdrpVectorHandlerList+000000000x0ea8e274    0x01426886    GameExe+000468860x0ea8e400    0x013e50c1    GameExe+000050c10x0ea8e490    0x013e50c1    GameExe+000050c10x0ea8e5dc    0x014d5818    GameExe+000f58180x0ea8e5f4    0x014e2d98    GameExe+00102d980x0ea8e638    0x013e5090    GameExe+000050900x0ea8e648    0x774af15a    ntdll!RtlDispatchException+0000007c0x0ea8e768    0x1165331a    libcef+0216331a0x0ea8e814    0x1165331a    libcef+0216331a0x0ea8e980    0x0f688051    libcef+001980510x0ea8eb04    0x77185bd9    ucrtbase!&lt;lambda_54dcfcba6f8e0c549fa430f4d53fb7dd&gt;::operator()+000000330x0ea8eb64    0x0f65390b    libcef+0016390b0x0ea8ec54    0x5deb11c8    AudioSes+000011c80x0ea8f0f8    0x0f653f19    libcef+00163f190x0ea8f158    0x11636410    libcef+021464100x0ea8f2e8    0x116362c5    libcef+021462c50x0ea8f340    0x10cc84df    libcef+017d84df0x0ea8f3b0    0x10cc9c91    libcef+017d9c910x0ea8f528    0x11b4b196    libcef+0265b1960x0ea8f54c    0x0f3e3702    ffmpeg+002237020x0ea8f564    0x0f692aca    libcef+001a2aca0x0ea8f574    0x0f3e3702    ffmpeg+002237020x0ea8f57c    0x1165095c    libcef+0216095c0x0ea8f5b4    0x0f3e1bd3    ffmpeg+00221bd30x0ea8f724    0x0f3e3702    ffmpeg+002237020x0ea8f794    0x0f363c33    ffmpeg+001a3c330x0ea8f850    0x664c22d5    nvwgf2um+005822d50x0ea8f898    0x774d2ec5    ntdll!FinalExceptionHandlerPad37+000000000:023&gt; !findstack ntdll!KiUserExceptionDispatc*rScanning thread 004</code></pre><p>很遗憾，这些命令集体哑火，啥帮助也没有，我们要开始靠自己的双手来掘金了，使用dps来做，输出的太多了，简单整理下如下所示：</p><div class=pgc-img><img alt=基于异常的猎杀行动——自保护触发自杀 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a2931a662e8b44a1b05a6b0c1b7ac894><p class=pgc-img-caption></p></div><p>果然不出所料，找出来了。根据栈的递减原理，我们可以推断，第一案发现场的ntdll!KiUserExceptionDispatcher应该是0x0ea8e6dc这个，下一步就是还原到案发第一现场了，如下操作：</p><pre><code>KiUserExceptionDispatcher( PEXCEPTION_RECORD pExcptRec, CONTEXT * pContext )0:023&gt; dd 0ea8e6dc0ea8e6dc  774c088f 0ea8e6f0 0ea8e740 0ea8e6f00ea8e6ec  0ea8e740 80000003 00000000 000000000ea8e6fc  0f688051 00000001 00000000 000000000ea8e70c  00000000 00000000 00000000 000000000ea8e71c  00000000 00000000 00000000 000000000ea8e72c  00000000 00000000 00000000 000000000ea8e73c  00000000 0001007f 00000000 000000000ea8e74c  00000000 00000000 00000000 00000000</code></pre><p>这里需要说明下，32位的程序，OS在从内核将异常分发至用户态时，会伪造两个参数，并且通过用户态栈传递，而对于64位的程序，则有差别，是通过寄存器传递的参数，而非通过栈，这个后边分析dmp时详解；好了，有了KiUserExceptionDispatcher的原型，又有了传递给他的两个参数，那么下一步就开始复原案发现场吧。</p><pre><code>0:023&gt; .exr 0ea8e6f0ExceptionAddress: 0f688051 (libcef+0x00198051)   ExceptionCode: 80000003 (Break instruction exception)  ExceptionFlags: 00000000NumberParameters: 1   Parameter[0]: 000000000:023&gt; .cxr 0ea8e740eax=0ea8ec00 ebx=0ea8f1a8 ecx=00000000 edx=000003d1 esi=0ea8f1b4 edi=000003d1eip=0f688051 esp=0ea8eba0 ebp=0ea8f0e8 iopl=0         nv up ei pl zr na pe nccs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000246libcef+0x198051:0f688051 ??              ???</code></pre><p>看到这些数据，我悬着的心落下来了，毕竟看到这个就已然证明了之前的推测都是正确的。简单分析下，异常记录中记录下来的异常Code是80000003，以为了游戏自身触发了一个int 3的断点，这于之前那里分析的逻辑也是对的上的，异常上下文则直接恢复出了游戏执行int 3时的执行状态；可以的是，dmp时这块内存没有被保存下来，导致现在看不了反汇编，不过也不要紧了，这里的指令一定是int 3；</p><p>这里的指令看不了，但还是可以看下程序执行到这里的执行路径，看下调用栈吧，如下：</p><pre><code>0:023&gt; kf#   Memory  ChildEBP RetAddr  WARNING: Stack unwind information not available. Following frames may be wrong.00           0ea8eb9c 0f652ee8 libcef+0x19805101       54c 0ea8f0e8 116521a8 libcef+0x162ee802       17c 0ea8f264 116529ba libcef+0x21621a803        58 0ea8f2bc 1167c36c libcef+0x21629ba04         c 0ea8f2c8 11636600 libcef+0x218c36c05       218 0ea8f4e0 11650bb1 libcef+0x214660006        44 0ea8f524 11b4b196 libcef+0x2160bb107        14 0ea8f538 0f692ab5 libcef+0x265b19608        5c 0ea8f594 0f65f0ef libcef+0x1a2ab509       144 0ea8f6d8 0f65eae3 libcef+0x16f0ef0a        80 0ea8f758 0f6943b7 libcef+0x16eae30b        24 0ea8f77c 0f65ee20 libcef+0x1a43b70c        30 0ea8f7ac 0f65eddd libcef+0x16ee200d        28 0ea8f7d4 0f67a94b libcef+0x16eddd0e         8 0ea8f7dc 0f67ad9a libcef+0x18a94b0f        38 0ea8f814 0f65d2e2 libcef+0x18ad9a10        1c 0ea8f830 76da62c4 libcef+0x16d2e211        14 0ea8f844 774b0f79 kernel32!BaseThreadInitThunk+0x2412        48 0ea8f88c 774b0f44 ntdll!__RtlUserThreadStart+0x2f13        10 0ea8f89c 00000000 ntdll!_RtlUserThreadStart+0x1b0:023&gt; ?54cEvaluate expression: 1356 = 0000054c</code></pre><p>栈有些不太对劲，表现为01#栈帧太大了；用了这么多字节，先来看看这里存储的数据有没有什么特别的；找到的字符串，如下所示：</p><pre><code>0:023&gt; da 0ea8ecdc+8 l100000ea8ece4  "[0812/210050:FATAL:core_audio_ut"0ea8ed04  "il_win.cc(292)] Check failed: de"0ea8ed24  "vice_enumerator. .Backtrace:..ce"0ea8ed44  "f_time_to_timet [0x0F6889A7+8270"0ea8ed64  "31]..cef_time_to_timet [0x0F652D"0ea8ed84  "17+606727]..TerminateProcessWith"0ea8eda4  "outDump [0x116521A8+10745848]..T"0ea8edc4  "erminateProcessWithoutDump [0x11"0ea8ede4  "6529BA+10747914]..TerminateProce"0ea8ee04  "ssWithoutDump [0x1167C36C+109183"0ea8ee24  "32]..TerminateProcessWithoutDump"0ea8ee44  " [0x11636600+10632272]..Terminat"0ea8ee64  "eProcessWithoutDump [0x11650BB1+"0ea8ee84  "10740225]..TerminateProcessWitho"0ea8eea4  "utDump [0x11B4B196+15960038]..Ge"0ea8eec4  "tHandleVerifier [0x0F692AB5+469]"0ea8eee4  "..cef_time_to_timet [0x0F65F0EF+"0ea8ef04  "656863]..cef_time_to_timet [0x0F"0ea8ef24  "65EAE3+655315]..GetHandleVerifie"0ea8ef44  "r [0x0F6943B7+6871]..cef_time_to"0ea8ef64  "_timet [0x0F65EE20+656144]..cef_"0ea8ef84  "time_to_timet [0x0F65EDDD+656077"0ea8efa4  "]..cef_time_to_timet [0x0F67A94B"0ea8efc4  "+769595]..cef_time_to_timet [0x0"0ea8efe4  "F67AD9A+770698]..cef_time_to_tim"0ea8f004  "et [0x0F65D2E2+649170]..BaseThre"0ea8f024  "adInitThunk [0x76DA62C4+36]..Rtl"0ea8f044  "SubscribeWnfStateChangeNotificat"0ea8f064  "ion [0x774B0F79+1081]..RtlSubscr"0ea8f084  "ibeWnfStateChangeNotification [0"0ea8f0a4  "x774B0F44+1028].."</code></pre><p>整理之后如下所示：</p><div class=pgc-img><img alt=基于异常的猎杀行动——自保护触发自杀 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dd914f0c237e4783862b7d10ddab00eb><p class=pgc-img-caption></p></div><p>原理是一大推字符串占据可这块内存，但这着实不是什么好习惯；现在来解释下，为何游戏进程自己就执行了一个int 3；根据提示的字符串文本可推测：</p><p>libcef.dll中检测到一个FATAL错误，具体的错误就是跟audio相关的校验失败了，由于Check failed，且libcef还认为这是个FATAL——致命类型的错误，就直接执行int 3 触发断点了；话又说回来，这种死法确实不优雅也不高明。libcef的具体信息如下：</p><pre><code>0:023&gt; lmvm libcefBrowse full module liststart    end        module name0f4f0000 129bd000   libcef   T (no symbols)               Loaded symbol image file: libcef.dll    Image path: c:xxxxlibcef.dll    Image name: libcef.dll    Browse all global symbols  functions  data    Timestamp:        Wed Jan 30 12:17:12 2019 (5c512548)    CheckSum:         0348AAFD    ImageSize:        034CD000    File version:     2.1432.2186.0    Product version:  2.1432.2186.0    File flags:       0 (Mask 17)    File OS:          4 Unknown Win32    File type:        2.0 Dll    File date:        00000000.00000000    Translations:     0000.04b0 0000.04e4 0409.04b0 0409.04e4    Information from resource tables:</code></pre><p>没啥有用的信息，我有看了看我本地有没有这个dll，结果还真有，印象笔记里就有用他；原来是大佬google家的，失敬失敬。</p><div class=pgc-img><img alt=基于异常的猎杀行动——自保护触发自杀 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab4ca36465d544abb0cf24fdfe098e84><p class=pgc-img-caption></p></div><p>2.6 step6：最后的战役——手动重构战；</p><p>现在想看下整个程序从第一次异常触发到异常的分发过程再到程序的最后一条指令的整个栈回溯，该怎么办呢？当然是栈重构了。 重构的思路是什么？需要怎么做呢？重构做要做的核心工作便是修复受损的栈帧，那如何找到那些栈帧是受损的呢？靠猜测，当然不是瞎猜，综合现有的证据。我们回到当前线程的初始上下文环境，然后栈回溯下看看；</p><pre><code>0:023&gt; .cxr;kfResetting default scope#   Memory  ChildEBP RetAddr  00           0ea8cd98 76f41d80 ntdll!NtWaitForMultipleObjects+0xc01       194 0ea8cf2c 76f41c78 kernelbase!WaitForMultipleObjectsEx+0xf002        1c 0ea8cf48 71021997 kernelbase!WaitForMultipleObjects+0x18WARNING: Stack unwind information not available. Following frames may be wrong.03      1094 0ea8dfdc 71021179 GameCrashDmp+0x199704         8 0ea8dfe4 774edff0 GameCrashDmp+0x117905      18a8 0ea8f88c 774b0f44 ntdll!__RtlUserThreadStart+0x3d0a606        10 0ea8f89c 00000000 ntdll!_RtlUserThreadStart+0x1b</code></pre><p>根据上边的信息可知，03#和05#栈帧有问题，我们逐一进行查看；</p><p>先看03#的数据:</p><div class=pgc-img><img alt=基于异常的猎杀行动——自保护触发自杀 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7aa09f224c964ebca2945ab947a2968c><p class=pgc-img-caption></p></div><p>再看05#帧的数据:</p><pre><code>0:023&gt; dd 0ea8dfe40ea8dfe4  0ea8f88c 774edff0 0ea8e014 774c2a200ea8dff4  0ea8f88c 00000000 fffffffe 0ea8e02c0ea8e004  774c2330 00000000 00000000 000000000ea8e014  0ea8e150 0ea8e1a0 77548760 000000010ea8e024  77548750 00000047 0ea8e04c 774c67700ea8e034  775642d4 774c0540 0ea8e150 0ea8f87c0ea8e044  0ea8e1a0 0ea8e0dc 0ea8e070 774d2d420ea8e054  0ea8e150 0ea8f87c 0ea8e1a0 0ea8e0dc</code></pre><p>如上所示，这个栈帧明显有问题了，我们试着这样改一下，看看效果如何：</p><pre><code>0:023&gt; ed 0ea8dfe4  0ea8dfe4+80:023&gt; kf#   Memory  ChildEBP RetAddr  00           0ea8cd98 76f41d80 ntdll!NtWaitForMultipleObjects+0xc01       194 0ea8cf2c 76f41c78 kernelbase!WaitForMultipleObjectsEx+0xf002        1c 0ea8cf48 71021997 kernelbase!WaitForMultipleObjects+0x1803      1094 0ea8dfdc 71021179 GameCrashdmp+0x199704         8 0ea8dfe4 774edff0 GameCrashdmp+0x117905         8 0ea8dfec 774c2a20 ntdll!__RtlUserThreadStart+0x3d0a606        14 0ea8e000 774c2330 ntdll!_EH4_CallFilterFunc+0x1207        2c 0ea8e02c 774c6770 ntdll!_except_handler4_common+0x8008        20 0ea8e04c 774d2d42 ntdll!_except_handler4+0x2009        24 0ea8e070 774d2d14 ntdll!ExecuteHandler2+0x260a        c8 0ea8e138 774c088f ntdll!ExecuteHandler+0x240b         0 0ea8e138 013e50c1 ntdll!KiUserExceptionDispatcher+0xf        ;第二次异常分发0c       50c 0ea8e644 774af15a GameExe+0x50c1                             ;案发第二现场0d        94 0ea8e6d8 774c088f ntdll!RtlDispatchException+0x7c0e         0 0ea8e6d8 0f688051 ntdll!KiUserExceptionDispatcher+0xf        ;第一次异常分发0f       4c4 0ea8eb9c 0f652ee8 libcef+0x198051                            ;案发第一现场10       54c 0ea8f0e8 116521a8 libcef+0x162ee811       17c 0ea8f264 116529ba libcef+0x21621a812        58 0ea8f2bc 1167c36c libcef+0x21629ba13         c 0ea8f2c8 11636600 libcef+0x218c36c14       218 0ea8f4e0 11650bb1 libcef+0x214660015        44 0ea8f524 11b4b196 libcef+0x2160bb116        14 0ea8f538 0f692ab5 libcef+0x265b19617        5c 0ea8f594 0f65f0ef libcef+0x1a2ab518       144 0ea8f6d8 0f65eae3 libcef+0x16f0ef19        80 0ea8f758 0f6943b7 libcef+0x16eae31a        24 0ea8f77c 0f65ee20 libcef+0x1a43b71b        30 0ea8f7ac 0f65eddd libcef+0x16ee201c        28 0ea8f7d4 0f67a94b libcef+0x16eddd1d         8 0ea8f7dc 0f67ad9a libcef+0x18a94b1e        38 0ea8f814 0f65d2e2 libcef+0x18ad9a1f        1c 0ea8f830 76da62c4 libcef+0x16d2e220        14 0ea8f844 774b0f79 kernel32!BaseThreadInitThunk+0x2421        48 0ea8f88c 774b0f44 ntdll!__RtlUserThreadStart+0x2f22        10 0ea8f89c 00000000 ntdll!_RtlUserThreadStart+0x1b</code></pre><p>完美，这个栈回溯要好得多，程序的执行脉络很清晰了；</p><p></p><h1 class=pgc-h-arrow-right>3、总结</h1><p>本文从异常入手，通过各种分析，辨识出第一次案发现场，第二次案发现场，并逆向分析了关键的异常分发函数，简要介绍了VEH，接着根据搜索到的数据猜测除了程序为何触发int 3进行自杀的动作；最后通过手动重构，恢复出程序执行到死亡的整个执行流程；</p><p>本文由<strong>void *</strong>原创发布<br>转载，请参考转载声明，注明出处： https://www.anquanke.com/post/id/209035</p><div class=tt-column-card data-content='{"url":"","content":"","thumb_url":"http://p10.pstatp.com/large/pgc-image/47e2f4b3dc7d4e349073a3b4be67210a","title":"web安全深度解析","author_description":"安界","price":299,"share_price":119.6,"sold":0,"column_id":"6844049146677035267","new_thumb_url":"http://sf3-ttcdn-tos.pstatp.com/img/pgc-image/47e2f4b3dc7d4e349073a3b4be67210a"}'><p class=column-placeholder></p></div><p>我是安仔，一名刚入职网络安全圈的网安萌新，欢迎关注我，跟我一起成长； 欢迎大家私信回复【入群】，加入安界网大咖交流群，跟我一起交流讨论。</p><p style=text-align:start>小白入行网络安全、混迹安全行业找大咖，以及更多成长干货资料，欢迎关注#安界网人才培养计划#、#网络安全在我身边#、@安界人才培养计划</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异常','猎杀','行动'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>