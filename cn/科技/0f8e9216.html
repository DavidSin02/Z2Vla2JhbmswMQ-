<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>写个日志请求切面，前后端甩锅更方便 | 极客快訊</title><meta property="og:title" content="写个日志请求切面，前后端甩锅更方便 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/9ee016d0-a9b0-43a8-95a8-2d6d7b5e7e21"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f8e9216.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8e9216.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="写个日志请求切面，前后端甩锅更方便"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0f8e9216.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>写个日志请求切面，前后端甩锅更方便</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><ul><li><strong><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6742300535308698126/?group_id=6742300535308698126" rel="noopener noreferrer" target=_blank>秋招Java面试大纲：Java+并发+spring+数据库+Redis+JVM+Netty等</a></strong><br></li><li><strong><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6752861414169248260/?group_id=6752861414169248260" rel="noopener noreferrer" target=_blank>阿里一线架构师分享的技术图谱，进阶加薪全靠它</a></strong><br></li><li><strong><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6751939760798843406/?group_id=6751939760798843406" rel="noopener noreferrer" target=_blank>Spring全家桶笔记：Spring+Spring Boot+Spring Cloud+Spring MVC</a></strong><br></li><li><strong><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6799229488912663052/?group_id=6799229488912663052" rel="noopener noreferrer" target=_blank>最新出炉，头条三面技术四面HR，看我如何一步一步攻克面试官？</a></strong><br></li></ul><h1 class=pgc-h-arrow-right>写在前面</h1><p>本篇文章是实战性的，对于切面的原理不会讲解，只会简单介绍一下切面的知识点</p><div class=pgc-img><img alt=写个日志请求切面，前后端甩锅更方便 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/9ee016d0-a9b0-43a8-95a8-2d6d7b5e7e21><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>切面介绍</h1><p>面向切面编程是一种编程范式，它作为OOP面向对象编程的一种补充，用于处理系统中分布于各个模块的横切关注点，比如<strong>事务管理</strong>、<strong>权限控制</strong>、<strong>缓存控制</strong>、<strong>日志打印</strong>等等。 AOP把软件的功能模块分为两个部分：核心关注点和横切关注点。业务处理的主要功能为核心关注点，而非核心、需要拓展的功能为横切关注点。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点进行分离，使用切面有以下好处：</p><ul><li>集中处理某一关注点/横切逻辑</li><li>可以很方便的添加/删除关注点</li><li>侵入性少，增强代码可读性及可维护性 因此当想打印请求日志时很容易想到切面，对控制层代码0侵入</li></ul><h1 class=pgc-h-arrow-right>切面的使用【基于注解】</h1><ul><li>@Aspect => 声明该类为一个注解类</li></ul><p><strong>切点注解：</strong></p><ul><li>@Pointcut => 定义一个切点，可以简化代码</li></ul><p><strong>通知注解：</strong></p><ul><li>@Before => 在切点之前执行代码</li><li>@After => 在切点之后执行代码</li><li>@AfterReturning => 切点返回内容后执行代码，可以对切点的返回值进行封装</li><li>@AfterThrowing => 切点抛出异常后执行</li><li>@Around => 环绕，在切点前后执行代码</li></ul><h1 class=pgc-h-arrow-right>动手写一个请求日志切面</h1><ul><li>使用@Pointcut定义切点</li></ul><pre><code>@Pointcut("execution(* your_package.controller..*(..))")public void requestServer() {}</code></pre><p>@Pointcut定义了一个切点，因为是请求日志切边，因此切点定义的是Controller包下的所有类下的方法。定义切点以后在通知注解中直接使用requestServer方法名就可以了</p><ul><li>使用@Before再切点前执行</li></ul><pre><code>@Before("requestServer()")public void doBefore(JoinPoint joinPoint) {    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request = attributes.getRequest();    LOGGER.info("===============================Start========================");    LOGGER.info("IP                 : {}", request.getRemoteAddr());    LOGGER.info("URL                : {}", request.getRequestURL().toString());    LOGGER.info("HTTP Method        : {}", request.getMethod());    LOGGER.info("Class Method       : {}.{}", joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());}</code></pre><p>在进入Controller方法前，打印出调用方IP、请求URL、HTTP请求类型、调用的方法名</p><ul><li>使用@Around打印进入控制层的入参</li></ul><pre><code>@Around("requestServer()")public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {    long start = System.currentTimeMillis();    Object result = proceedingJoinPoint.proceed();    LOGGER.info("Request Params       : {}", getRequestParams(proceedingJoinPoint));    LOGGER.info("Result               : {}", result);    LOGGER.info("Time Cost            : {} ms", System.currentTimeMillis() - start);    return result;}</code></pre><p>通过 @PathVariable以及@RequestParam注解传递的参数无法打印出参数名，因此需要手动拼接一下参数名，同时对文件对象进行了特殊处理，只需获取文件名即可</p><p>打印了入参、结果以及耗时</p><ul><li>getRquestParams方法</li></ul><pre><code>private Map&lt;String, Object&gt; getRequestParams(ProceedingJoinPoint proceedingJoinPoint) {     Map&lt;String, Object&gt; requestParams = new HashMap&lt;&gt;();      //参数名     String[] paramNames = ((MethodSignature)proceedingJoinPoint.getSignature()).getParameterNames();     //参数值     Object[] paramValues = proceedingJoinPoint.getArgs();     for (int i = 0; i &lt; paramNames.length; i++) {         Object value = paramValues[i];         //如果是文件对象         if (value instanceof MultipartFile) {             MultipartFile file = (MultipartFile) value;             value = file.getOriginalFilename();  //获取文件名         }         requestParams.put(paramNames[i], value);     }     return requestParams; }</code></pre><p>通过 @PathVariable以及@RequestParam注解传递的参数无法打印出参数名，因此需要手动拼接一下参数名，同时对文件对象进行了特殊处理，只需获取文件名即可</p><ul><li>@After方法调用后执行</li></ul><pre><code>@After("requestServer()")public void doAfter(JoinPoint joinPoint) {    LOGGER.info("===============================End========================");}</code></pre><p>没有业务逻辑只是打印了End</p><ul><li>完整切面代码</li></ul><pre><code>@Component@Aspectpublic class RequestLogAspect {    private final static Logger LOGGER = LoggerFactory.getLogger(RequestLogAspect.class);    @Pointcut("execution(* your_package.controller..*(..))")    public void requestServer() {    }    @Before("requestServer()")    public void doBefore(JoinPoint joinPoint) {        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        LOGGER.info("===============================Start========================");        LOGGER.info("IP                 : {}", request.getRemoteAddr());        LOGGER.info("URL                : {}", request.getRequestURL().toString());        LOGGER.info("HTTP Method        : {}", request.getMethod());        LOGGER.info("Class Method       : {}.{}", joinPoint.getSignature().getDeclaringTypeName(),  joinPoint.getSignature().getName());    }    @Around("requestServer()")    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        long start = System.currentTimeMillis();        Object result = proceedingJoinPoint.proceed();        LOGGER.info("Request Params     : {}", getRequestParams(proceedingJoinPoint));        LOGGER.info("Result               : {}", result);        LOGGER.info("Time Cost            : {} ms", System.currentTimeMillis() - start);        return result;    }    @After("requestServer()")    public void doAfter(JoinPoint joinPoint) {        LOGGER.info("===============================End========================");    }    /**     * 获取入参     * @param proceedingJoinPoint     *     * @return     * */    private Map&lt;String, Object&gt; getRequestParams(ProceedingJoinPoint proceedingJoinPoint) {        Map&lt;String, Object&gt; requestParams = new HashMap&lt;&gt;();        //参数名        String[] paramNames = ((MethodSignature)proceedingJoinPoint.getSignature()).getParameterNames();        //参数值        Object[] paramValues = proceedingJoinPoint.getArgs();        for (int i = 0; i &lt; paramNames.length; i++) {            Object value = paramValues[i];            //如果是文件对象            if (value instanceof MultipartFile) {                MultipartFile file = (MultipartFile) value;                value = file.getOriginalFilename();  //获取文件名            }            requestParams.put(paramNames[i], value);        }        return requestParams;    }}</code></pre><h1 class=pgc-h-arrow-right>高并发下请求日志切面</h1><p>写完以后对自己的代码很满意，但是想着可能还有完善的地方就和朋友交流了一下。emmmm</p><div class=pgc-img><img alt=写个日志请求切面，前后端甩锅更方便 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/afebcebb0d30444e9368ac34e7871f83><p class=pgc-img-caption></p></div><p><br></p><p>果然还有继续优化的地方 每个信息都打印一行，在高并发请求下确实会出现请求之间打印日志串行的问题，因为测试阶段请求数量较少没有出现串行的情况，果然生产环境才是第一发展力，能够遇到更多bug，写更健壮的代码 解决日志串行的问题只要将多行打印信息合并为一行就可以了，因此构造一个对象</p><ul><li>RequestInfo.java</li></ul><pre><code>@Datapublic class RequestInfo {    private String ip;    private String url;    private String httpMethod;    private String classMethod;    private Object requestParams;    private Object result;    private Long timeCost;}</code></pre><ul><li>环绕通知方法体</li></ul><pre><code>@Around("requestServer()")public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {    long start = System.currentTimeMillis();    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request = attributes.getRequest();    Object result = proceedingJoinPoint.proceed();    RequestInfo requestInfo = new RequestInfo();            requestInfo.setIp(request.getRemoteAddr());    requestInfo.setUrl(request.getRequestURL().toString());    requestInfo.setHttpMethod(request.getMethod());    requestInfo.setClassMethod(String.format("%s.%s", proceedingJoinPoint.getSignature().getDeclaringTypeName(),            proceedingJoinPoint.getSignature().getName()));    requestInfo.setRequestParams(getRequestParamsByProceedingJoinPoint(proceedingJoinPoint));    requestInfo.setResult(result);    requestInfo.setTimeCost(System.currentTimeMillis() - start);    LOGGER.info("Request Info      : {}", JSON.toJSONString(requestInfo));    return result;}</code></pre><p>将url、http request这些信息组装成RequestInfo对象，再序列化打印对象 打印<strong>序列化</strong>对象结果而不是直接打印对象是因为序列化有更直观、更清晰，同时可以借助在线解析工具对结果进行解析</p><div class=pgc-img><img alt=写个日志请求切面，前后端甩锅更方便 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3c44ec4834b54e19b05548c8c0ac4123><p class=pgc-img-caption></p></div><p>是不是还不错<br>在解决高并发下请求串行问题的同时添加了对<strong>异常请求信息的打印</strong>，通过使用 @AfterThrowing注解对抛出异常的方法进行处理</p><ul><li>RequestErrorInfo.java</li></ul><pre><code>@Datapublic class RequestErrorInfo {    private String ip;    private String url;    private String httpMethod;    private String classMethod;    private Object requestParams;    private RuntimeException exception;}</code></pre><ul><li>异常通知环绕体</li></ul><pre><code>@AfterThrowing(pointcut = "requestServer()", throwing = "e")public void doAfterThrow(JoinPoint joinPoint, RuntimeException e) {    ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    HttpServletRequest request = attributes.getRequest();    RequestErrorInfo requestErrorInfo = new RequestErrorInfo();    requestErrorInfo.setIp(request.getRemoteAddr());    requestErrorInfo.setUrl(request.getRequestURL().toString());    requestErrorInfo.setHttpMethod(request.getMethod());    requestErrorInfo.setClassMethod(String.format("%s.%s", joinPoint.getSignature().getDeclaringTypeName(),            joinPoint.getSignature().getName()));    requestErrorInfo.setRequestParams(getRequestParamsByJoinPoint(joinPoint));    requestErrorInfo.setException(e);    LOGGER.info("Error Request Info      : {}", JSON.toJSONString(requestErrorInfo));}</code></pre><p>对于异常，耗时是没有意义的，因此不统计耗时，而是添加了异常的打印</p><p>最后放一下完整日志请求切面代码：</p><pre><code>@Component@Aspectpublic class RequestLogAspect {    private final static Logger LOGGER = LoggerFactory.getLogger(RequestLogAspect.class);    @Pointcut("execution(* your_package.controller..*(..))")    public void requestServer() {    }    @Around("requestServer()")    public Object doAround(ProceedingJoinPoint proceedingJoinPoint) throws Throwable {        long start = System.currentTimeMillis();        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        Object result = proceedingJoinPoint.proceed();        RequestInfo requestInfo = new RequestInfo();                requestInfo.setIp(request.getRemoteAddr());        requestInfo.setUrl(request.getRequestURL().toString());        requestInfo.setHttpMethod(request.getMethod());        requestInfo.setClassMethod(String.format("%s.%s", proceedingJoinPoint.getSignature().getDeclaringTypeName(),                proceedingJoinPoint.getSignature().getName()));        requestInfo.setRequestParams(getRequestParamsByProceedingJoinPoint(proceedingJoinPoint));        requestInfo.setResult(result);        requestInfo.setTimeCost(System.currentTimeMillis() - start);        LOGGER.info("Request Info      : {}", JSON.toJSONString(requestInfo));        return result;    }    @AfterThrowing(pointcut = "requestServer()", throwing = "e")    public void doAfterThrow(JoinPoint joinPoint, RuntimeException e) {        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();        HttpServletRequest request = attributes.getRequest();        RequestErrorInfo requestErrorInfo = new RequestErrorInfo();        requestErrorInfo.setIp(request.getRemoteAddr());        requestErrorInfo.setUrl(request.getRequestURL().toString());        requestErrorInfo.setHttpMethod(request.getMethod());        requestErrorInfo.setClassMethod(String.format("%s.%s", joinPoint.getSignature().getDeclaringTypeName(),                joinPoint.getSignature().getName()));        requestErrorInfo.setRequestParams(getRequestParamsByJoinPoint(joinPoint));        requestErrorInfo.setException(e);        LOGGER.info("Error Request Info      : {}", JSON.toJSONString(requestErrorInfo));    }    /**     * 获取入参     * @param proceedingJoinPoint     *     * @return     * */    private Map&lt;String, Object&gt; getRequestParamsByProceedingJoinPoint(ProceedingJoinPoint proceedingJoinPoint) {        //参数名        String[] paramNames = ((MethodSignature)proceedingJoinPoint.getSignature()).getParameterNames();        //参数值        Object[] paramValues = proceedingJoinPoint.getArgs();        return buildRequestParam(paramNames, paramValues);    }    private Map&lt;String, Object&gt; getRequestParamsByJoinPoint(JoinPoint joinPoint) {        //参数名        String[] paramNames = ((MethodSignature)joinPoint.getSignature()).getParameterNames();        //参数值        Object[] paramValues = joinPoint.getArgs();        return buildRequestParam(paramNames, paramValues);    }    private Map&lt;String, Object&gt; buildRequestParam(String[] paramNames, Object[] paramValues) {        Map&lt;String, Object&gt; requestParams = new HashMap&lt;&gt;();        for (int i = 0; i &lt; paramNames.length; i++) {            Object value = paramValues[i];            //如果是文件对象            if (value instanceof MultipartFile) {                MultipartFile file = (MultipartFile) value;                value = file.getOriginalFilename();  //获取文件名            }            requestParams.put(paramNames[i], value);        }        return requestParams;    }    @Data    public class RequestInfo {        private String ip;        private String url;        private String httpMethod;        private String classMethod;        private Object requestParams;        private Object result;        private Long timeCost;    }    @Data    public class RequestErrorInfo {        private String ip;        private String url;        private String httpMethod;        private String classMethod;        private Object requestParams;        private RuntimeException exception;    }}</code></pre><p>赶紧给你们的应用加上吧【如果没加的话】，没有日志的话，总怀疑上层出错，但是却拿不出证据</p><blockquote><p>作者：何甜甜在吗<br>原文链接：https://juejin.im/post/5e69d5b5e51d45183840b351</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'写个','日志','请求'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>