<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>空间检索-Geohash算法实现原理 | 极客快訊</title><meta property="og:title" content="空间检索-Geohash算法实现原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/499b081f160049b49fd0cdc2d53d35aa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0fa8bcd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fa8bcd.html><meta property="article:published_time" content="2020-10-29T21:08:06+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:06+08:00"><meta name=Keywords content><meta name=description content="空间检索-Geohash算法实现原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/0fa8bcd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>空间检索-Geohash算法实现原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>前言</strong></h1><p>目前空间索引的实现有 R树和其变种GIST树、四叉树、网格索引等。 网格索引不再多提，使用普通的hash表存储地点和风格之间的映射来实现。今天要介绍的GeoHash算法实现的空间索引，虽然是以B树实现，但我认为它也借用网格索引的一部分思想。</p><h1 class=pgc-h-arrow-right><strong>GeoHash</strong></h1><h1 class=pgc-h-arrow-right><strong>原理</strong></h1><p style=text-align:start>GeoHash 算法的原理说起来是很简单的，如下图：</p><p><br></p><div class=pgc-img><img alt=空间检索-Geohash算法实现原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/499b081f160049b49fd0cdc2d53d35aa><p class=pgc-img-caption></p></div><ol start=1><li>从横向上将整个方形纸分为左右两份，左侧部分为标记为 0， 右侧部分标记为 1；</li><li>再将红点所在的部分划分为左右两块，再对红点位置做同样的标识，最后得出红点在横向上的标识为 10;</li><li>在纵向上对方形纸做同样的划分，左侧标识为0，右侧标识为 1，得出红点位置在纵向上的标识为 01;</li><li>将横向标识和纵向标识合并，规则为 纵向在奇数位，横向在偶数位 (也可纵横相反，但要在整个系统内保持一致)，得出红点在方形纸上的标识为 1001;</li></ol><p style=text-align:start>只标记一个方格显得看不出什么规律，如果我们把这些都空格都标识后会发现 <strong class=highlight-text>被划分在角落里的四个方格会有同样的前缀</strong>，如下图所示。</p><p><br></p><div class=pgc-img><img alt=空间检索-Geohash算法实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b6655070bf7c42eeaed4b3dfbea02943><p class=pgc-img-caption></p></div><p>同样的前缀意味着可以使用 B树 索引查找有相同前缀的点作为附近的点，GeoHash 算法便是这些同样的前缀上面做文章。</p><h1 class=pgc-h-arrow-right><strong>墨卡托投影</strong></h1><blockquote><p><em>墨卡托投影，是正轴等角圆柱投影。由荷兰地图学家墨卡托(G.Mercator)于1569年创立。假想一个与地轴方向一致的圆柱切或割于地球，按等角条件，将经纬网投影到圆柱面上，将圆柱面展为平面后，即得本投影。墨卡托投影在切圆柱投影与割圆柱投影中，最早也是最常用的是切圆柱投影。</em><br></p></blockquote><p>墨卡托投影简单地说，就是可以 把整个地球平面作为一个正方形来处理，当然地球平面不是严格的正方形，此投影在两极附近的点会有误差，本文专注于原理，纠偏就不多提了（我也不懂，逃）。</p><h1 class=pgc-h-arrow-right><strong>实现</strong></h1><p style=text-align:start>按照墨卡托投影的平面，我们可以按照上面划分方格纸的方式来将整个地球表面划分为各个小方格。</p><p style=text-align:start>如(116.276349, 40.040875)这个点的经度划分：</p><ol start=1><li>经度在 [-180,0) 范围内的标识为0，经度范围在 [0, 180) 度的标识为 1;</li><li>继续划分，经度范围在 [0,90) 的标识为 0，经度范围在 [90,180) 的标识为 1;</li><li>这样，我们划分 20 次，方格的精度（见文末对照表）已达到 2m，得到经度的标识二进制串为11010010101011110111;</li><li>对纬度同样划分，得到纬度的标识二进制串为10111000111100100111;</li><li>我们对它组合，得到40位的二进制串11011 01110 00010 01110 11100 10111 01001 11111;</li><li>我们将这个二进制串使用 base32编码（原理同base64，可以见我的另一篇文章：WEB开发中的字符集和编码，位编码映射表见下），得到 GeoHash 编码为 3OCO4XJ7;</li></ol><p style=text-align:start>那么GeoHash编码前缀为 3OCO4XJ7的地理点就是离 (116.276349, 40.040875)两米内的点。如果我们把地理位置点和其GeoHash编码存入数据库的话，我们要查找 附近两米点的点，只需要限定条件 geo_code like '3OCO4XJ7%'就行了;</p><h1 class=pgc-h-arrow-right><strong>边界点问题</strong></h1><p style=text-align:start>可是最简版的 GeoHash 还有一个弱点，如下图：</p><p><br></p><div class=pgc-img><img alt=空间检索-Geohash算法实现原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b7dbe5188cc44d41ab3753168a785b6f><p class=pgc-img-caption></p></div><p>如果每个方格的精度为 2km，那么我们直接按照前缀查询红点附近 2km 的点是查找不到离它很近的黑点的。</p><p style=text-align:start>要解决这个问题，我们就需要所其周边八个方格也考虑上，将自身方格和周边八个方格内的点都遍历一次，再返回符合要求的点。那么如何知道周边方格的前缀呢？</p><p style=text-align:start>仔细观察相邻方格，我们会发现两个小方格会在 经度或纬度的<strong class=highlight-text>二进制码上相差1</strong>；我们通过 GeoHash 码反向解析出二进制码后，将其经度或纬度（或两者）的二进制码加一，再次组合为 GeoHash 码。</p><h1 class=pgc-h-arrow-right><strong>Redis的GEO函数</strong></h1><h1 class=pgc-h-arrow-right><strong>问题</strong></h1><p style=text-align:start>我们常见的需求是查找 n米 范围内的点，那么 n米 与 GeoHash 码位数之间的映射如何实现呢？由于 GeoHash 码是由5位二进制码组成，每少一位，精度就会损失 2e(5/2)。</p><p style=text-align:start>方法当然有的，我们将二进制GeoHash码直接索引就可以，但很长的索引长度会导致 B树 索引查询效率会迅速下降。</p><h1 class=pgc-h-arrow-right><strong>方案</strong></h1><p style=text-align:start>于是我们接着寻找解决方案，既然使用 base32 转换为 32进制码 会不好控制精度，保持二进制又导致索引长度过长，那么进制位数和索引长度有没有一个平衡呢？</p><p style=text-align:start>另外 Redis 的 sorted set 支持 64位 的 double 类型的 score，我们把二进制的 GeoHash 码转为十进制放入 Redis 的 sorted set 中，不是可以实现 log(n)的查询效率了么。</p><p style=text-align:start>说实话第一次看到 Redis 的 GEO 系列函数的时候我的内心是崩溃的，原来自己感觉极其良好的设计早已被人实现了（虽然这种情况经常出现）。。。</p><p style=text-align:start>当然不能就这么算了，于是我使用PHP造了一遍轮子。。。</p><p style=text-align:start>主要步骤如下：</p><h1 class=pgc-h-arrow-right><strong>代码实现</strong></h1><p style=text-align:start>实现中我将 GeoHash 的最大精度设置为26位，此时它的距离精度为 0.3m。当然我们也可以充分利用 Redis 的 sorted set 的 score，设置精度为 32 位，刚好使用它的 double 类型。</p><p style=text-align:start>放上GitHub源码地址：空间索引-GeoHash</p><h1 class=pgc-h-arrow-right><strong>数据入库：</strong></h1><p style=text-align:start>将经纬度通过 GeoHash 算法获取到二进制 GeoHash 码，并将其转成十进制作为这个点的 score 存入 Redis 的 sorted set;</p><pre><code>// GeoHash核心方法 传入float类型的度数和其对应的范围，经度和纬度公用方法public function getBits($loc, $range, $level = self::LEVEL_MAX) {    $bits = '';    for ($i = 0; $i &lt; $level; $i++) {        $mid = ($range['min'] + $range['max']) / 2;        if ($loc &lt; $mid) {            $bits .= '0';            $range = ['min' =&gt; $range['min'], 'max' =&gt; $mid];        } else {            $bits .= '1';            $range = ['min' =&gt; $mid, 'max' =&gt; $range['max']];        }    }    return $bits;}     </code></pre><p>另外 php 的 bindec($bin_str) 方法能快速把二进制字符串转为十进制数字。</p><h1 class=pgc-h-arrow-right><strong>根据查询范围半径获取精度</strong></h1><p style=text-align:start>上文说过，精度是由地图的划分次数决定的，划分次数多了，范围就小了，查询的出的数据就不全；划分次数少了，范围就会大了，我们对数据过滤时就会有过多的损耗。</p><pre><code>private function getLevel($range_meter){    $level = 0;    $global = self::MERCATOR_LENGTH;    while ($global &gt; $range_meter) {        $global /= 2;        $level++;    }    return $level;}   </code></pre><p>上面代码的思想来自redis geo函数源码，真的很巧妙。</p><p style=text-align:start>在墨卡托投影下，地球的表面可以作为一个正方形来看，它的边是地球周长中最长的一个。而学过初中地理的我们知道：“地球是一个两极稍扁，赤道略鼓的球体”，那么它最长的一个周长就是赤道周长了，于是我们得知墨卡托投影的长边为 2*PI*R=40075452.74M;</p><p style=text-align:start>于是我们拿正方形的一个边来不停地进行二次划分，直到划分后的结果刚好比范围半径长，那么它构成的一个方块，便是我们需要的方格。</p><h1 class=pgc-h-arrow-right><strong>数据查询</strong></h1><p style=text-align:start>数据查询时，我们需要获取中间方块的最小 score 值和其范围，最小 score 值很简单，直接将二进制位不足52位的在后面补0。</p><p style=text-align:start>此外，为了避免边界点问题，我们还需要把周围八个方格的 score 值范围也获取到。</p><p style=text-align:start>我们在划分地图时，每多划分一次，会添加经度和纬度两个二进制位，在精度最高时，那么每一个方格的最大值和最小值之间差1。由此，我们通过下面的方法获取到一个方格的最大和最小 score 值之差。</p><pre><code>private function getLevelRange($level) {    $range = pow(2, 2 * (self::LEVEL_MAX - $level));    return $range;}</code></pre><h1 class=pgc-h-arrow-right><strong>小结</strong></h1><p style=text-align:start>花费了十多个小时，总算将 GeoHash 完全整体了一遍，完全理解 GeoHash 并没有想像中的那么简单。除了 GeoHash，四叉树和R树据说查询效率会更高，有时间再研究一下。</p><p style=text-align:start>如果您觉得本文对您有帮助，可以点击下面的 <strong>推荐</strong> 支持一下我。博客一直在更新，欢迎 <strong>关注</strong> 。</p><p style=text-align:start>参考：</p><p style=text-align:start><strong>GeoHash核心原理解析</strong></p><p style=text-align:start><strong>Redis GEO 源码注释</strong></p><p style=text-align:start>GeoHash位数精度对照表（wiki百科）：</p><p><br></p><div class=pgc-img><img alt=空间检索-Geohash算法实现原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/32695d4c2e1041e9898484f745b92445><p class=pgc-img-caption></p></div><p>base32 编码映射表：</p><p><br></p><div class=pgc-img><img alt=空间检索-Geohash算法实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c4239b674b24b2ab88cf8352f09d4f7><p class=pgc-img-caption></p></div><p><strong>喜欢这篇文章可以关注我 私信 “资料” 即可获得更多学习视频和资料：</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'空间','检索','Geohash'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>