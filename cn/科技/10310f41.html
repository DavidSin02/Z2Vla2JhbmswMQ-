<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「干货」常用排序算法总结，必收藏系列 | 极客快訊</title><meta property="og:title" content="「干货」常用排序算法总结，必收藏系列 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d8acebd059bd4f4bba84851e32fa7ce7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/10310f41.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="「干货」常用排序算法总结，必收藏系列"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/10310f41.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「干货」常用排序算法总结，必收藏系列</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify><br></p><p class=ql-align-justify>我们通常所说的排序算法往往指的是<strong>内部排序算法</strong>，即数据记录在内存中进行排序。</p><p class=ql-align-justify><strong>排序算法大体可分为两种：</strong></p><p class=ql-align-justify>一种是<strong>比较排序</strong>，时间复杂度O(nlogn) ~ O(n^2)，主要有：<strong>冒泡排序</strong>，<strong>选择排序</strong>，<strong>插入排序</strong>，<strong>归并排序</strong>，<strong>堆排序</strong>，<strong>快速排序</strong>等。</p><p class=ql-align-justify>另一种是<strong>非比较排序</strong>，时间复杂度可以达到O(n)，主要有：<strong>计数排序</strong>，<strong>基数排序</strong>，<strong>桶排序</strong>等。</p><p>这里我们来探讨一下常用的比较排序算法，非比较排序算法将在下一篇文章中介绍。下表给出了常见比较排序算法的性能：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d8acebd059bd4f4bba84851e32fa7ce7><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>有一点我们很容易忽略的是<strong>排序算法的稳定性</strong>(腾讯校招2016笔试题曾考过)。</p><p>排序算法稳定性的简单形式化定义为：<strong>如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的。</strong></p><p>通俗地讲就是保证排序前后两个相等的数的相对顺序不变。</p><p>对于不稳定的排序算法，只要举出一个实例，即可说明它的不稳定性；而对于稳定的排序算法，必须对算法进行分析从而得到稳定的特性。</p><p>需要注意的是，排序算法是否为稳定的是由具体算法决定的，不稳定的算法在某种条件下可以变为稳定的算法，而稳定的算法在某种条件下也可以变为不稳定的算法。</p><p>例如，对于冒泡排序，原本是稳定的排序算法，如果将记录交换的条件改成A[i] >= A[i + 1]，则两个相等的记录就会交换位置，从而变成不稳定的排序算法。</p><p>其次，说一下排序算法稳定性的好处。<strong>排序算法如果是稳定的，那么从一个键上排序，然后再从另一个键上排序，前一个键排序的结果可以为后一个键排序所用。</strong></p><p>基数排序就是这样，先按低位排序，逐次按高位排序，低位排序后元素的顺序在高位也相同时是不会改变的。</p><p class=ql-align-justify><strong>冒泡排序(Bubble Sort)</strong></p><p>冒泡排序是一种极其简单的排序算法，也是我所学的第一个排序算法。</p><p>它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。</p><p>这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端</p><p><strong>冒泡排序算法的运作如下：</strong></p><ol><li class=ql-align-justify>比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</li><li class=ql-align-justify>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li class=ql-align-justify>针对所有的元素重复以上的步骤，除了最后一个。</li><li class=ql-align-justify>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p><p><strong>冒泡排序的代码如下：</strong></p><p class=ql-align-justify><br></p><blockquote><br>#include &lt;stdio.h>// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- 如果能在内部循环第一次运行时,使用一个旗标来表示有无需要交换的可能,可以把最优时间复杂度降低到O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void BubbleSort(int A[], int n){ for (int j = 0; j &lt; n - 1; j++) // 每次最大元素就像气泡一样"浮"到数组的最后 { for (int i = 0; i &lt; n - 1 - j; i++) // 依次比较相邻的两个元素,使较大的那个向后移 { if (A[i] > A[i + 1]) // 如果条件改成A[i] >= A[i + 1],则变为不稳定的排序算法 { Swap(A, i, i + 1); } } }}int main(){ int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 从小到大冒泡排序 int n = sizeof(A) / sizeof(int); BubbleSort(A, n); printf("冒泡排序结果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p class=ql-align-justify><br></p><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行冒泡排序的实现过程如下</p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0fdd1e20765f439da20559c592ea5ee0><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>使用冒泡排序为一列数字进行排序的过程如右图所示：</p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5268d10422d94a8da8c297482636f406><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>尽管冒泡排序是最容易了解和实现的排序算法之一，但它对于少数元素之外的数列排序是很没有效率的。</p><p>冒泡排序的改进：<strong>鸡尾酒排序</strong></p><p>鸡尾酒排序，也叫<strong>定向冒泡排序</strong>，是冒泡排序的一种改进。</p><p>此算法与冒泡排序的不同处在于<strong>从低到高然后从高到低</strong>，而冒泡排序则仅从低到高去比较序列里的每个元素。他可以得到比冒泡排序稍微好一点的效能。</p><p>鸡尾酒排序的代码如下：</p><blockquote><br>#include &lt;stdio.h>// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- 如果序列在一开始已经大部分排序过的话,会接近O(n)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 稳定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void CocktailSort(int A[], int n){ int left = 0; // 初始化边界 int right = n - 1; while (left &lt; right) { for (int i = left; i &lt; right; i++) // 前半轮,将最大元素放到后面 { if (A[i] > A[i + 1]) { Swap(A, i, i + 1); } } right--; for (int i = right; i > left; i--) // 后半轮,将最小元素放到前面 { if (A[i - 1] > A[i]) { Swap(A, i - 1, i); } } left++; }}int main(){ int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 从小到大定向冒泡排序 int n = sizeof(A) / sizeof(int); CocktailSort(A, n); printf("鸡尾酒排序结果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p>使用鸡尾酒排序为一列数字进行排序的过程如右图所示：　　</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/93824d00c1ed4761b5a3ec05db744870><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>以序列(2,3,4,5,1)为例，鸡尾酒排序只需要访问一次序列就可以完成排序，但如果使用冒泡排序则需要四次。</p><p>但是在乱数序列的状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p><p class=ql-align-justify><strong>选择排序(Selection Sort)</strong></p><p>选择排序也是一种简单直观的排序算法。</p><p>它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。</p><p>以此类推，直到所有元素均排序完毕。</p><p>注意选择排序与冒泡排序的区别：</p><p>冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；</p><p>而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。</p><p><strong>选择排序的代码如下：</strong></p><blockquote><br>#include &lt;stdio.h>// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(n^2)// 最优时间复杂度 ---- O(n^2)// 平均时间复杂度 ---- O(n^2)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void SelectionSort(int A[], int n){ for (int i = 0; i &lt; n - 1; i++) // i为已排序序列的末尾 { int min = i; for (int j = i + 1; j &lt; n; j++) // 未排序序列 { if (A[j] &lt; A[min]) // 找出未排序序列中的最小值 { min = j; } } if (min != i) { Swap(A, min, i); // 放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法 } }}int main(){ int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 从小到大选择排序 int n = sizeof(A) / sizeof(int); SelectionSort(A, n); printf("选择排序结果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p class=ql-align-justify><br></p><p>上述代码对序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }进行选择排序的实现过程如右图：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/41a25e8610d54e97b2098f32f6a7a9c8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>使用选择排序为一列数字进行排序的宏观过程：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46c1b40376c04e7d80ccb333dea14850><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>选择排序是不稳定的排序算法，不稳定发生在最小元素与A[i]交换的时刻。</strong></p><p>比如序列：{ 5, 8, 5, 2, 9 }，一次选择的最小元素是2，然后把2和第一个5进行交换，从而改变了两个元素5的相对次序。</p><p class=ql-align-justify><strong>插入排序(Insertion Sort)</strong></p><p>插入排序是一种简单直观的排序算法。它的工作原理非常类似于我们抓扑克牌</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c313af7062b540e3a9429eb2ffdae892><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>对于未排序数据(右手抓到的牌)，在已排序序列(左手已经排好序的手牌)中从后向前扫描，找到相应位置并插入。</p><p>插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p><strong>具体算法描述如下：</strong></p><ol><li class=ql-align-justify>从第一个元素开始，该元素可以认为已经被排序</li><li class=ql-align-justify>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li class=ql-align-justify>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li class=ql-align-justify>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li class=ql-align-justify>将新元素插入到该位置后</li><li class=ql-align-justify>重复步骤2~5</li></ol><p class=ql-align-justify><br></p><p><strong>插入排序的代码如下：</strong></p><p>#include &lt;stdio.h></p><p class=ql-align-justify><br></p><p>// 分类 ------------- 内部比较排序</p><p>// 数据结构 ---------- 数组</p><p>// 最差时间复杂度 ---- 最坏情况为输入序列是降序排列的,此时时间复杂度O(n^2)</p><p>// 最优时间复杂度 ---- 最好情况为输入序列是升序排列的,此时时间复杂度O(n)</p><p>// 平均时间复杂度 ---- O(n^2)</p><p>// 所需辅助空间 ------ O(1)</p><p>// 稳定性 ------------ 稳定</p><p class=ql-align-justify><br></p><p>void InsertionSort(int A[], int n)</p><p>{</p><p>for (int i = 1; i &lt; n; i++) // 类似抓扑克牌排序</p><p>{</p><p>int get = A[i]; // 右手抓到一张扑克牌</p><p>int j = i - 1; // 拿在左手上的牌总是排序好的</p><p>while (j >= 0 && A[j] > get) // 将抓到的牌与手牌从右向左进行比较</p><p>{</p><p>A[j + 1] = A[j]; // 如果该手牌比抓到的牌大，就将其右移</p><p>j--;</p><p>}</p><p>A[j + 1] = get; // 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边(相等元素的相对次序未变，所以插入排序是稳定的)</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>int main()</p><p>{</p><p>int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 从小到大插入排序</p><p>int n = sizeof(A) / sizeof(int);</p><p>InsertionSort(A, n);</p><p>printf("插入排序结果：");</p><p>for (int i = 0; i &lt; n; i++)</p><p>{</p><p>printf("%d ", A[i]);</p><p>}</p><p>printf("\n");</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行插入排序的实现过程如下</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75a32ddb72e34f32b9a95401c40c2d3a><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>使用插入排序为一列数字进行排序的宏观过程：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e326d515da8c4438a858fce540eb2a2d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>插入排序不适合对于数据量比较大的排序应用。</p><p>但是，如果需要排序的数据量很小，比如量级小于千，那么插入排序还是一个不错的选择。</p><p>插入排序在工业级库中也有着广泛的应用，在STL的sort算法和stdlib的qsort算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。</p><p class=ql-align-justify><strong>插入排序的改进：二分插入排序</strong></p><p>对于插入排序，如果比较操作的代价比交换操作大的话，可以采用<strong>二分查找法</strong>来减少比较操作的次数，我们称为<strong>二分插入排序</strong>，代码如下：</p><p>#include &lt;stdio.h></p><p class=ql-align-justify><br></p><p>// 分类 -------------- 内部比较排序</p><p>// 数据结构 ---------- 数组</p><p>// 最差时间复杂度 ---- O(n^2)</p><p>// 最优时间复杂度 ---- O(nlogn)</p><p>// 平均时间复杂度 ---- O(n^2)</p><p>// 所需辅助空间 ------ O(1)</p><p>// 稳定性 ------------ 稳定</p><p class=ql-align-justify><br></p><p>void InsertionSortDichotomy(int A[], int n)</p><p>{</p><p>for (int i = 1; i &lt; n; i++)</p><p>{</p><p>int get = A[i]; // 右手抓到一张扑克牌</p><p>int left = 0; // 拿在左手上的牌总是排序好的，所以可以用二分法</p><p>int right = i - 1; // 手牌左右边界进行初始化</p><p>while (left &lt;= right) // 采用二分法定位新牌的位置</p><p>{</p><p>int mid = (left + right) / 2;</p><p>if (A[mid] > get)</p><p>right = mid - 1;</p><p>else</p><p>left = mid + 1;</p><p>}</p><p>for (int j = i - 1; j >= left; j--) // 将欲插入新牌位置右边的牌整体向右移动一个单位</p><p>{</p><p>A[j + 1] = A[j];</p><p>}</p><p>A[left] = get; // 将抓到的牌插入手牌</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>int main()</p><p>{</p><p>int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大二分插入排序</p><p>int n = sizeof(A) / sizeof(int);</p><p>InsertionSortDichotomy(A, n);</p><p>printf("二分插入排序结果：");</p><p>for (int i = 0; i &lt; n; i++)</p><p>{</p><p>printf("%d ", A[i]);</p><p>}</p><p>printf("\n");</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p>当n较大时，二分插入排序的比较次数比直接插入排序的最差情况好得多，但比直接插入排序的最好情况要差，所当以元素初始序列已经接近升序时，直接插入排序比二分插入排序比较次数少。</p><p>二分插入排序元素移动次数与直接插入排序相同，依赖于元素初始序列。</p><p class=ql-align-justify><strong>插入排序的更高效改进：希尔排序(Shell Sort)</strong></p><p>希尔排序，也叫<strong>递减增量排序</strong>，是插入排序的一种更高效的改进版本。希尔排序是<strong>不稳定</strong>的排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li class=ql-align-justify>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li class=ql-align-justify>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。</p><p>然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p><p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。</p><p>而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p><p><strong>希尔排序的代码如下：</strong></p><blockquote><br>#include &lt;stdio.h> // 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- 根据步长序列的不同而不同。已知最好的为O(n(logn)^2)// 最优时间复杂度 ---- O(n)// 平均时间复杂度 ---- 根据步长序列的不同而不同。// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定void ShellSort(int A[], int n){ int h = 0; while (h &lt;= n) // 生成初始增量 { h = 3 * h + 1; } while (h >= 1) { for (int i = h; i &lt; n; i++) { int j = i - h; int get = A[i]; while (j >= 0 && A[j] > get) { A[j + h] = A[j]; j = j - h; } A[j + h] = get; } h = (h - 1) / 3; // 递减增量 }}int main(){ int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 从小到大希尔排序 int n = sizeof(A) / sizeof(int); ShellSort(A, n); printf("希尔排序结果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p class=ql-align-justify><br></p><p>以23, 10, 4, 1的步长序列进行希尔排序：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ed4244826984b2ab6089c333d188841><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>希尔排序是不稳定的排序算法，</strong>虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱</p><p>比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2时分成两个子序列 { 3, 10, 7, 8, 20 } 和 { 5, 8, 2, 1, 6 } ，未排序之前第二个子序列中的8在前面，现在对两个子序列进行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，两个8的相对次序发生了改变。</p><p class=ql-align-justify><strong>归并排序(Merge Sort)</strong></p><p>归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。</p><p>归并排序的实现分为<strong>递归实现</strong>与<strong>非递归(迭代)实现</strong>。</p><p>递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。</p><p>非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。</p><p>归并排序算法主要依赖归并(Merge)操作。</p><p>归并操作指的是将两个已经排序的序列合并成一个序列的操作。</p><p><strong>归并操作</strong>步骤如下：</p><ol><li class=ql-align-justify><strong>申请空间</strong>，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列</li><li class=ql-align-justify>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li class=ql-align-justify>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置</li><li class=ql-align-justify>重复步骤3直到某一指针到达序列尾</li><li class=ql-align-justify>将另一序列剩下的所有元素直接复制到合并序列尾</li></ol><p><strong>归并排序的代码如下：</strong></p><p>#include &lt;stdio.h></p><p>#include &lt;limits.h></p><p class=ql-align-justify><br></p><p>// 分类 -------------- 内部比较排序</p><p>// 数据结构 ---------- 数组</p><p>// 最差时间复杂度 ---- O(nlogn)</p><p>// 最优时间复杂度 ---- O(nlogn)</p><p>// 平均时间复杂度 ---- O(nlogn)</p><p>// 所需辅助空间 ------ O(n)</p><p>// 稳定性 ------------ 稳定</p><p class=ql-align-justify><br></p><p>void Merge(int A[], int left, int mid, int right)// 合并两个已排好序的数组A[left...mid]和A[mid+1...right]</p><p>{</p><p>int len = right - left + 1;</p><p>int *temp = new int[len]; // 辅助空间O(n)</p><p>int index = 0;</p><p>int i = left; // 前一数组的起始元素</p><p>int j = mid + 1; // 后一数组的起始元素</p><p>while (i &lt;= mid && j &lt;= right)</p><p>{</p><p>temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 带等号保证归并排序的稳定性</p><p>}</p><p>while (i &lt;= mid)</p><p>{</p><p>temp[index++] = A[i++];</p><p>}</p><p>while (j &lt;= right)</p><p>{</p><p>temp[index++] = A[j++];</p><p>}</p><p>for (int k = 0; k &lt; len; k++)</p><p>{</p><p>A[left++] = temp[k];</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>void MergeSortRecursion(int A[], int left, int right) // 递归实现的归并排序(自顶向下)</p><p>{</p><p>if (left == right) // 当待排序的序列长度为1时，递归开始回溯，进行merge操作</p><p>return;</p><p>int mid = (left + right) / 2;</p><p>MergeSortRecursion(A, left, mid);</p><p>MergeSortRecursion(A, mid + 1, right);</p><p>Merge(A, left, mid, right);</p><p>}</p><p class=ql-align-justify><br></p><p>void MergeSortIteration(int A[], int len) // 非递归(迭代)实现的归并排序(自底向上)</p><p>{</p><p>int left, mid, right;// 子数组索引,前一个为A[left...mid]，后一个子数组为A[mid+1...right]</p><p>for (int i = 1; i &lt; len; i *= 2) // 子数组的大小i初始为1，每轮翻倍</p><p>{</p><p>left = 0;</p><p>while (left + i &lt; len) // 后一个子数组存在(需要归并)</p><p>{</p><p>mid = left + i - 1;</p><p>right = mid + i &lt; len ? mid + i : len - 1;// 后一个子数组大小可能不够</p><p>Merge(A, left, mid, right);</p><p>left = right + 1; // 前一个子数组索引向后移动</p><p>}</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>int main()</p><p>{</p><p>int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 从小到大归并排序</p><p>int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };</p><p>int n1 = sizeof(A1) / sizeof(int);</p><p>int n2 = sizeof(A2) / sizeof(int);</p><p>MergeSortRecursion(A1, 0, n1 - 1); // 递归实现</p><p>MergeSortIteration(A2, n2); // 非递归实现</p><p>printf("递归实现的归并排序结果：");</p><p>for (int i = 0; i &lt; n1; i++)</p><p>{</p><p>printf("%d ", A1[i]);</p><p>}</p><p>printf("\n");</p><p>printf("非递归实现的归并排序结果：");</p><p>for (int i = 0; i &lt; n2; i++)</p><p>{</p><p>printf("%d ", A2[i]);</p><p>}</p><p>printf("\n");</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p class=ql-align-justify><br></p><p>上述代码对序列{ 6, 5, 3, 1, 8, 7, 2, 4 }进行归并排序的实例如下</p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/73af8399de8643e1a70673f9764f66b5><p class=pgc-img-caption></p></div><p>使用归并排序为一列数字进行排序的宏观过程：</p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2d57d8004084d46a2718c3408ec5c64><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>归并排序除了可以对数组进行排序，还可以高效的求出数组小和（即单调和）以及数组中的逆序对。</p><p class=ql-align-justify><strong>堆排序(Heap Sort)</strong></p><p>堆排序是指利用堆这种数据结构所设计的一种选择排序算法。</p><p>堆是一种近似完全二叉树的结构（通常堆是通过一维数组来实现的），并满足性质：以最大堆（也叫大根堆、大顶堆）为例，其中父结点的值总是大于它的孩子节点。</p><p>我们可以很容易的<strong>定义堆排序的过程：</strong></p><ol><li class=ql-align-justify>由输入的无序数组构造一个最大堆，作为初始的无序区</li><li class=ql-align-justify>把堆顶元素（最大值）和堆尾元素互换</li><li class=ql-align-justify>把堆（无序区）的尺寸缩小1，并调用heapify(A, 0)从新的堆顶元素开始进行堆调整</li><li class=ql-align-justify>重复步骤2，直到堆的尺寸为1</li></ol><p><strong>堆排序的代码如下：</strong></p><blockquote><br>#include &lt;stdio.h>// 分类 -------------- 内部比较排序// 数据结构 ---------- 数组// 最差时间复杂度 ---- O(nlogn)// 最优时间复杂度 ---- O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ O(1)// 稳定性 ------------ 不稳定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void Heapify(int A[], int i, int size) // 从A[i]向下进行堆调整{ int left_child = 2 * i + 1; // 左孩子索引 int right_child = 2 * i + 2; // 右孩子索引 int max = i; // 选出当前结点与其左右孩子三者之中的最大值 if (left_child &lt; size && A[left_child] > A[max]) max = left_child; if (right_child &lt; size && A[right_child] > A[max]) max = right_child; if (max != i) { Swap(A, i, max); // 把当前结点和它的最大(直接)子节点进行交换 Heapify(A, max, size); // 递归调用，继续从当前结点向下进行堆调整 }}</blockquote><p>堆排序算法的演示：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5efff4a72bec48b08b2f56f7150e0c54><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>动画中在排序过程之前简单的表现了创建堆的过程以及堆的逻辑结构。</p><p><strong>堆排序是不稳定的排序算法，不稳定发生在堆顶元素与A[i]交换的时刻。</strong></p><p>比如序列：{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序。</p><p class=ql-align-justify><strong>快速排序(Quick Sort)</strong></p><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序n个元素要O(nlogn)次比较。</p><p>在最坏状况下则需要O(n^2)次比较，但这种状况并不常见。</p><p>事实上，快速排序通常明显比其他O(nlogn)算法更快，因为它的内部循环可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为：</p><ol><li class=ql-align-justify>从序列中挑出一个元素，作为”基准”(pivot).</li><li class=ql-align-justify>把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。</li><li class=ql-align-justify>对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。</li></ol><p><strong>快速排序的代码如下：</strong></p><blockquote><br>#include &lt;stdio.h>// 分类 ------------ 内部比较排序// 数据结构 --------- 数组// 最差时间复杂度 ---- 每次选取的基准都是最大（或最小）的元素，导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)// 最优时间复杂度 ---- 每次选取的基准都是中位数，这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)// 平均时间复杂度 ---- O(nlogn)// 所需辅助空间 ------ 主要是递归造成的栈空间的使用(用来保存left和right等局部变量)，取决于递归树的深度，一般为O(logn)，最差为O(n) // 稳定性 ---------- 不稳定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}int Partition(int A[], int left, int right) // 划分函数{ int pivot = A[right]; // 这里每次都选择最后一个元素作为基准 int tail = left - 1; // tail为小于基准的子数组最后一个元素的索引 for (int i = left; i &lt; right; i++) // 遍历基准以外的其他元素 { if (A[i] &lt;= pivot) // 把小于等于基准的元素放到前一个子数组末尾 { Swap(A, ++tail, i); } } Swap(A, tail + 1, right); // 最后把基准放到前一个子数组的后边，剩下的子数组既是大于基准的子数组 // 该操作很有可能把后面元素的稳定性打乱，所以快速排序是不稳定的排序算法 return tail + 1; // 返回基准的索引}void QuickSort(int A[], int left, int right){ if (left >= right) return; int pivot_index = Partition(A, left, right); // 基准的索引 QuickSort(A, left, pivot_index - 1); QuickSort(A, pivot_index + 1, right);}int main(){ int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 从小到大快速排序 int n = sizeof(A) / sizeof(int); QuickSort(A, 0, n - 1); printf("快速排序结果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p>使用快速排序法对一列数字进行排序的过程：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「干货」常用排序算法总结，必收藏系列 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bbffa9936df9481e921301d5b2edd592><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>快速排序是不稳定的排序算法，不稳定发生在基准元素与A[tail+1]交换的时刻。</strong></p><p>比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序。</p><blockquote>Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？</blockquote><p>答：这是考虑到排序算法的稳定性。</p><p>对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；</p><p>而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。</p><p>需要更多学习笔记干货的小伙伴、欢迎关注公众号<strong>【老九学堂】</strong>（づ￣3￣）づ╭❤～</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'干货','总结','排序'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>