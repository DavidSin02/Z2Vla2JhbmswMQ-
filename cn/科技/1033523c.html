<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>利用树莓派学习arm汇编 第一章 | 极客快訊</title><meta property="og:title" content="利用树莓派学习arm汇编 第一章 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ba7eb45486af45c994e78f630c048b37"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1033523c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1033523c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1033523c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1033523c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1033523c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1033523c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1033523c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1033523c.html><meta property="article:published_time" content="2020-11-14T21:04:32+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:32+08:00"><meta name=Keywords content><meta name=description content="利用树莓派学习arm汇编 第一章"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1033523c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>利用树莓派学习arm汇编 第一章</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="利用树莓派学习arm汇编 第一章" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba7eb45486af45c994e78f630c048b37><p class=pgc-img-caption></p></div><p>在我看来，学习一门高级编程语言比学习一门特定体系结构的汇编更有用，但是我很想学习ARM汇编程序只是为了好玩，因为我知道一些386汇编语言。这个想法不是想成为大师，而是想了解下面发生了什么。</p><h1>ARM简介</h1><p>下面的解释不会力求面面俱到的讲述arm的体系结构，我会尽量精简讲解其中实用的部分。</p><p>ARM是一种32位体系结构，具有一个简单的目标：灵活性。尽管这对集成商非常有用（因为他们在设计硬件时有很大的自由度），但对于必须应对ARM硬件差异的系统开发人员来说却不是那么好。因此，在本文中，我将假设一切都在运行Raspbian的Raspberry Pi Model B上完成。</p><p>有些部分将是ARM通用的，而有些将是Raspberry Pi专用的。 我不会区分。 ARM网站上有很多文档可查！</p><h1>开始写汇编</h1><p>汇编语言只是二进制代码之上的一个薄语法层。</p><p>二进制代码是计算机可以运行的，它由以二进制表示形式编码的指令组成（此类编码已在ARM手册中记录）。您可以编写二进制代码编码指令，但这会很麻烦（除了与Linux本身相关的其他一些技术，我们现在可以很高兴地忽略它们）。</p><p>由于计算机无法运行汇编程序，因此我们必须从中获取二进制代码。 我们使用一种称为汇编器的工具将汇编器代码汇编成可以运行的二进制代码。</p><p>在本课程中我们使用gnu assembler，这个工具是gnu project中的其中一个，有时又被称为gas.</p><p>只需打开vim，nano或emacs之类的编辑器即可。 我们的汇编语言文件（称为源文件）将带有后缀.s。 我不知道为什么是.s，但这是通常的惯例。</p><h1>第一个程序</h1><p>从一个简单的程序开始，这个程序只有返回值，在其中不做任何事。</p><pre>/* -- first.s *//* This is a comment */.global main /* 'main' is our entry point and must be global */main: /* This is main */mov r0, #2 /* Put a 2 inside the register r0 */bx lr /* Return from main */</pre><p>创建一个文件，将上述内容保存其中，然后开始编译，命令如下：<br>$ as -o first.o first.s<br>上述命令执行完后将会创建一个first.o的文件，下面我们将这个文件链接成为可执行文件<br>$ gcc -o first first.o<br>如果上述步骤执行顺利，你将得到一个first的文件，这个就是你的程序，下面来执行吧。<br>$ ./first<br>它应该不会有任何反应，的确，有点小失望，但是这个程序是执行了的，让我们看一下它的返回值</p><pre>$ ./first ; echo $?2</pre><p>太棒了，返回值2并非偶然，这是由于汇编代码中的＃2引起的。<br>由于运行汇编器和链接器很快会变得很无聊，因此建议您使用以下Makefile文件或类似的文件。</p><pre># Makefileall: first first: first.o gcc -o $@ $+ first.o : first.s as -o $@ $&lt; clean: rm -vf first *.o</pre><h1>OK,让我们来解释一下吧</h1><p>我们作弊只是为了使事情变得容易一些。 我们在汇编器中编写了一个C main函数，它仅返回2;。 这样，我们的程序就更容易了，因为C运行时为我们处理了程序的初始化和终止。 我将一直使用这种方法。<br>让我们回顾一下最小汇编文件的每一行。</p><pre>/* -- first.s *//* This is a comment */</pre><p>这些是评论。 注释包含在/ 和 /中。 使用它们来记录您的汇编器，因为它们会被忽略。 通常，不要将/ 和 /嵌套在/ *内，因为它不起作用。</p><pre>.global main /* 'main' is our entry point and must be global */</pre><p>这是GNU汇编程序的指令。 指令告诉GNU汇编器做一些特别的事情。 它们以点号（。）开头，后跟指令名称和一些参数。 在这种情况下，我们说main是一个全局名称。 这是必需的，因为C运行时将调用main。 如果不是全局的，则C运行时将无法调用它，并且链接阶段将失败。</p><pre>main: /* This is main */</pre><p>GNU汇编程序中不是指令的每一行都将始终像label：指令。 我们可以省略label：和指令（忽略空行和空行）。 仅带有标签：的行将该标签应用于下一行（您可以通过这种方式将多个标签引用相同的内容）。 指令部分是ARM汇编语言本身。 在这种情况下，由于没有指令，我们只是在定义main。</p><pre>mov r0, #2 /* Put a 2 inside the register r0 */</pre><p>在行的开头，空格被忽略，但是缩进在视觉上暗示该指令属于主要功能。<br>这是mov指令，表示移动。 我们将值2移至寄存器r0。 在下一章中，我们将了解有关寄存器的更多信息，现在不用担心。 是的，语法很尴尬，因为目的地实际上在左边。 在ARM语法中，它始终在左侧，因此我们说的是将r0寄存到立即数2之类的操作。在下一章中，我们将了解ARM中立即数的含义，不用担心。<br>总而言之，该指令将2放入寄存器r0中（这实际上会覆盖此时的r0寄存器）。</p><pre>bx lr /* Return from main */</pre><p>该指令bx表示分支和交换。 在这一点上，我们实际上并不关心交换部分。 分支意味着我们将改变指令执行的流程。 ARM处理器一个接一个地依次运行指令，因此在上述动作之后，该bx将被运行（此顺序执行并非特定于ARM，而是在几乎所有架构中都会发生）。 分支指令用于更改此隐式顺序执行。 在这种情况下，我们跳转到lr寄存器说的内容。 我们现在不在乎lr包含什么。 足以理解该指令只是离开了主要功能，从而有效地结束了我们的程序。<br>main的结果是程序的错误代码，并且在离开函数时必须将结果存储在寄存器r0中，因此我们main执行的mov指令实际上将错误代码设置为2。</p><p>以上就是本节的内容。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'树莓','学习','arm'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>