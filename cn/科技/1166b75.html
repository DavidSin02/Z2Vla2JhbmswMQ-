<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>异步代码的进化之路：回调，Promise，async/await | 极客快訊</title><meta property="og:title" content="异步代码的进化之路：回调，Promise，async/await - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/470800027f460ef29831"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1166b75.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="异步代码的进化之路：回调，Promise，async/await"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1166b75.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>异步代码的进化之路：回调，Promise，async/await</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>书接上篇。我们已经介绍了事件循环和Job Queue的机制，现在分享的是原文的后半部分——异步代码的发展历程，并比较三种异步模式的优缺点，希望大家看完能够收获新知识～</p><p><img alt=异步代码的进化之路：回调，Promise，async/await onerror=errorimg.call(this); src=https://p3.pstatp.com/large/470800027f460ef29831></p><p>（图片来自网络）</p><p><strong>回调</strong></p><p>你已经知道，回调是目前为止在JavaScript程序中表达和管理异步的最常用的方式。实际上，回调是JavaScript语言中最基本的异步模式。无数的JS程序，甚至是非常复杂的程序，都是基于回调编写的，除了回调并没有用到其他的异步基础。</p><p>不过回调并不完美。许多开发人员都在尝试寻找更好的异步模式。但是，如果你不理解底层的实际情况，就不可能有效地使用任何抽象。</p><p>在接下来的章节中，我们将深入探讨这些抽象概念，以说明为什么更复杂的异步模式(将在后续文章中讨论)是必要的，甚至是推荐的。</p><p>嵌套回调</p><p>看看下面这段代码</p><blockquote><pre>listen('click', function (e){ setTimeout(function(){ ajax('https://api.example.com/endpoint', function (text){ if (text == "hello") { doSomething(); } else if (text == "world") { doSomethingElse(); } }); }, 500);});</pre></blockquote><p>我们已经将三个函数的嵌套成了一条链，每一环都表示异步序列中的一个步骤。</p><p>这种代码通常被称为“回调地狱”。但是“回调地狱”实际上与缩进/缩进几乎没有任何关系。这是一个更深层次的问题。</p><p>首先，我们在等待“click”事件，然后等待计时器触发，然后等待Ajax响应返回，此时可能会再次出现。</p><p>乍一看，这段代码似乎可以自然地将它的异步映射为连续的步骤:</p><blockquote><pre>listen('click', function (e) { // ..});</pre></blockquote><p>然后我们有:</p><blockquote><pre>setTimeout(function(){ // ..}, 500);</pre></blockquote><p>然后我们有:</p><blockquote><pre>ajax('https://api.example.com/endpoint', function (text){ // ..});</pre></blockquote><p>最后：</p><blockquote><pre>if (text == "hello") { doSomething();}else if (text == "world") { doSomethingElse();}</pre></blockquote><p>因此，这样一种顺序的方式来表达您的异步代码似乎更自然，不是吗？一定有这样的方法，对吧？</p><p>Promise</p><p>看看下面这段代码:</p><blockquote><pre>var x = 1;var y = 2;console.log(x + y);</pre></blockquote><p>这段代码非常简单：它对x和y的值进行求和，并将其打印到控制台。但是，如果x或y的值缺失了，还有待确定呢？比如，我们需要从服务器检索x和y的值，然后才能在表达式中使用它们。假设我们有一个函数loadX和loadY ，分别从服务器加载x和y的值。然后，想象一下，我们有一个函数sum，一旦它们都被加载了，它就将x和y的值相加。 它可能是这样的(很难看，不是吗)</p><blockquote><pre>function sum(getX, getY, callback) { var x, y; getX(function(result) { x = result; if (y !== undefined) { callback(x + y); } }); getY(function(result) { y = result; if (x !== undefined) { callback(x + y); } });}// A sync or async function that retrieves the value of `x`function fetchX() { // ..}// A sync or async function that retrieves the value of `y`function fetchY() { // ..}sum(fetchX, fetchY, function(result) { console.log(result);});</pre></blockquote><p>这里有一些非常重要的东西——在这个片段中，我们将x和y作为<strong>未来</strong>的值，并表示了一个操作sum(…)(从外部看)，它并不关心x和y当前可不可用。</p><p>当然，这种粗糙的基于调用的方法还有很多值得期待的。这只是迈向理解未来值的好处的第一步，而不用担心时间的问题。</p><p>Promise 值</p><p>让我们简要地看看我们如何用Promise来表达x+y的例子:</p><blockquote><pre>function sum(xPromise, yPromise) { // `Promise.all([ .. ])` takes an array of promises, // and returns a new promise that waits on them // all to finish return Promise.all([xPromise, yPromise]) // when that promise is resolved, let's take the // received `X` and `Y` values and add them together. .then(function(values){ // `values` is an array of the messages from the // previously resolved promises return values[0] + values[1]; } );}// `fetchX()` and `fetchY()` return promises for// their respective values, which may be ready// *now* or *later*.sum(fetchX(), fetchY())// we get a promise back for the sum of those// two numbers.// now we chain-call `then(...)` to wait for the// resolution of that returned promise..then(function(sum){ console.log(sum);});</pre></blockquote><p>在这段代码中有两层Promise。</p><p>fetchX()和fetchY()被直接调用，它们返回的值(Promise！)被传递给sum(...)。这些Promise所代表的潜在值可能在现在或者将来准备好，但是无论如何，每个Promise都将其行为规范化为相同的。我们以一种独立于时间的方式来解释x和y的值。它们在一段时间内，是未来值。</p><p>第二层是sum(...) 创建(通过Promise.all([ ... ]))和返回的promise，我们通过调用 then(...)来等待它完成。当sum(...)操作完成，我们的未来值，即求和结果已经准备好了，我们可以打印出来。我们隐藏了在sum(...) 中等待x和y 未来值的逻辑。</p><p><strong>注意</strong>：在sum(…)内部，Promise.all([ … ])调用创建了一个promise（它等待promiseX和promiseY 完成），链式调用.then(...)来创建另一个promise，返回的values[0]+ values[1]会立即决议（返回相加的结果）。因此，我们在sum(...)调用后加上的then(...)——在代码段的最后——实际上是在第二个promise的返回后执行，而不是第一个创建的Promise.all([ ... ])。还有，虽然我们还没有在第二个then(...)后面继续添加then，它也创造了另一个promise，我们可以选择观察/使用它。本章后面的内容将在后面详细解释。 使用Promise，then(...) 的调用实际上可以有两个方法，第一个是完成(如上所示)，第二个是拒绝:</p><blockquote><pre>sum(fetchX(), fetchY()).then( // fullfillment handler function(sum) { console.log( sum ); }, // rejection handler function(err) { console.error( err ); // bummer! });</pre></blockquote><p>如果在得到x或y的时候出现了问题，或者在添加的过程中出现了一些失败，那么可以sum(…)返回的promise将被拒绝，传递给then(...)的第二个回调错误处理程序，它将收到来自promise拒绝的值。 因为Promises 封装了依赖于时间的状态——等待内在值的实现或拒绝——从外部来看，Promises 本身是时间独立的，因此可以以可预测的方式组合，而不考虑底层的时间和结果。</p><p>而且，一旦一个Promise得到决议，它就会永远保持这种状态——在那个时候它就变成了一个不可改变的值——然后就可以在必要的时候多次被观察。</p><p>实际上你可以链式Promise非常有用：</p><blockquote><pre>function delay(time) { return new Promise(function(resolve, reject){ setTimeout(resolve, time); });}delay(1000).then(function(){ console.log("after 1000ms"); return delay(2000);}).then(function(){ console.log("after another 2000ms");}).then(function(){ console.log("step 4 (next Job)"); return delay(5000);})// ...</pre></blockquote><p>调用delay(2000)创造一个在2000ms完成的Promise，然后我们从第一个then(…)完成回调中返回，导致第二个then(...)的promise再等待2000ms执行。</p><p><strong>注意</strong>： 因为Promise 一旦决议，从外部就不可改变了，所以现在可以安全地将这个值传递给任何一方，因为它知道它不能被意外或恶意地修改。对于观察该promise的多方来说，这一点尤其正确。任意一方不可能影响另一方观察到的决议结果。不变性可能听起来像是一个学术话题，但它实际上是Promise 设计最基本和最重要的方面之一，不应该被随意地忽略。</p><p>如何辨别<strong>Promise</strong>？</p><p>关于Promises的一个重要细节是确定是否某些值是真正的Promise。换句话说，它的值会像一个Promise吗?</p><p>我们知道Promises是由new Promise(…)语法构造的，你可能会认为 p instanceof Promise 是一个充分的检查。好吧，不完全是。</p><p>主要是因为你可以从另一个浏览器窗口(例如iframe)获得一个 Promise的值，它有自己独立的Promise类，不同于当前窗口或框架中的一个，因此该检查将无法识别Promise实例。</p><p>而且，一个库或框架可以选择发布它自己的Promise，而不是使用ES6原生的Promise实现。事实上，你很可能会在没有任何Promise的老式浏览器中使用第三方的 Promise。</p><p>吞掉异常</p><p>如果在创建Promise的任何时候，或者在对其决议的观察中，抛出了一个JavaScript异常错误，比如“TypeError”或“ReferenceError”，那么这个异常就会被捕获，它将迫使这个Promise被拒绝。</p><p>例如:</p><blockquote><pre>var p = new Promise(function(resolve, reject){ foo.bar(); // `foo` is not defined, so error! resolve(374); // never gets here :(});p.then( function fulfilled(){ // never gets here :( }, function rejected(err){ // `err` will be a `TypeError` exception object // from the `foo.bar()` line. });</pre></blockquote><p>但是如果一个Promise完成了，却在观察结果时(在 then(…) 注册回调)发生了JS异常会怎样呢？即使这个错误不会被丢失，你可能会对它们处理的方式感到惊讶。除非你进一步挖掘：</p><blockquote><pre>var p = new Promise( function(resolve,reject){ resolve(374);});p.then(function fulfilled(message){ foo.bar(); console.log(message); // never reached}, function rejected(err){ // never reached });</pre></blockquote><p>它看起来像“foo . bar()”真的是被吞没了。其实并不是。不过，一些更深层次的问题出现了，我们没能监听到。“p.then(…)调用本身会返回另一个promise，而这个promise将会被TypeError异常所拒绝。</p><p><strong>处理未捕获异常</strong></p><p>还有其他“更好”的方法。 常见的一个建议是应该给Promise增加一个done(…)，用于标志Promise链的结束。done(…)不会创建并返回一个Promise，所以传递到done(…)的回调显然不会把问题报告给一个不存在的链式Promise。 在未捕获错误的情况下，会按照你期望的方式处理:在done(..)中的拒绝处理函数中如果有任何异常，该异常将被抛出为一个全局未捕获的错误（通常在开发人员控制台能看到）：</p><blockquote><pre>var p = Promise.resolve(374);p.then(function fulfilled(msg){ // numbers don't have string functions, // so will throw an error console.log(msg.toLowerCase());}).done(null, function() { // If an exception is caused here, it will be thrown globally});</pre></blockquote><p><strong>在ES8里 Async/await会发生什么</strong></p><p>JavaScript ES8引入了async/await，使得Promise更容易使用。我们将简要介绍async/await提供的可能性，以及如何利用它们来编写异步代码。 因此，让我们看看async/await如何工作。</p><p>使用async函数声明来定义一个异步函数。这样的函数返回一个AsyncFunction对象，AsyncFunction对象代表了执行代码的异步函数，AsyncFunction包含在该函数中。 当调用async函数时，它返回一个Promise 。当async函数返回一个值时，这不是一个Promise 。而是会自动创建一个Promise ，它将使用函数的返回值来决议。当async 函数抛出异常时，Promise 将使用抛出的值来拒绝。 一个async 函数可以包含一个await表达式，该表达式暂停执行该函数，并等待传递给它的Promise被决议，然后恢复async函数的执行并返回决议值。 你可以把JavaScript的Promise看作是Java的Future或c#的任务。</p><blockquote><p>async/await 的目的是简化使用Promise的行为。 让我们看一下下面的例子:</p></blockquote><blockquote><pre>// Just a standard JavaScript functionfunction getNumber1() { return Promise.resolve('374');}// This function does the same as getNumber1async function getNumber2() { return 374;}</pre></blockquote><p>同样，抛出异常的函数等价于返回已被拒绝的promise的函数:</p><blockquote><pre>function f1() { return Promise.reject('Some error');}async function f2() { throw 'Some error';}</pre></blockquote><p>await关键字只能在async 函数中使用，并允许您同步等待一个Promise。如果我们在async 函数之外使用Promise，我们仍然需要使用then回调：</p><blockquote><pre>async function loadData() { // `rp` is a request-promise function. var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // Currently, both requests are fired, concurrently and // now we'll have to wait for them to finish var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;}// Since, we're not in an `async function` anymore// we have to use `then`.loadData().then(() =&gt; console.log('Done'));</pre></blockquote><p>你还可以使用“async函数表达式”来定义async函数。一个async函数表达式非常类似，它的语法和async函数声明差不多。async函数表达式和async函数声明之间的主要区别是函数名，它可以在async函数表达式中省略，以创建匿名函数。一个async函数表达式可以作为一个IIFE(立即执行函数表达式)来使用，当IIFE被定义完就会运行。 它看起来像这样：</p><blockquote><pre>var loadData = async function() { // `rp` is a request-promise function. var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // Currently, both requests are fired, concurrently and // now we'll have to wait for them to finish var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;}</pre></blockquote><p>更重要的是，在所有主流浏览器中都支持async/await:</p><p>如果这个兼容性不是你想要的，那么也有几个JS的转换器，比如Babel和TypeScript</p><p>在一天结束的时候，重要的是不要盲目地选择“最新”的方法来编写异步代码。理解异步JavaScript的内部原理是很重要的，了解它为什么如此重要，并深入理解您选择的方法的内部原理。每种方法都有利有弊。</p><p>编写高度可维护的、健壮的异步代码的5个技巧</p><p>1. <strong>干净的代码:</strong> 使用async/await允许您编写更少的代码。每次使用async/await你能跳过一些不必要的步骤：写.then，创建一个匿名函数来处理响应，在该回调中命名响应变量，比如：</p><blockquote><pre>// `rp` is a request-promise function.rp(‘https://api.example.com/endpoint1').then(function(data) { // …});</pre></blockquote><p>对比：</p><blockquote><pre>// `rp` is a request-promise function.var response = await rp(‘https://api.example.com/endpoint1');</pre></blockquote><p>2. <strong>错误处理:</strong> Async/await 使得可以使用相同的代码结构来处理同步和异步错误—著名的try / catch声明。让我们看看用Promise如何实现：</p><blockquote><pre>function loadData() { try { // Catches synchronous errors. getJSON().then(function(response) { var parsed = JSON.parse(response); console.log(parsed); }).catch(function(e) { // Catches asynchronous errors console.log(e); }); } catch(e) { console.log(e); }}</pre></blockquote><p>对比：</p><blockquote><pre>async function loadData() { try { var data = JSON.parse(await getJSON()); console.log(data); } catch(e) { console.log(e); }}</pre></blockquote><p>3. <strong>条件语句：</strong>用async/await编写条件代码要简单得多：</p><blockquote><pre>function loadData() { return getJSON() .then(function(response) { if (response.needsAnotherRequest) { return makeAnotherRequest(response) .then(function(anotherResponse) { console.log(anotherResponse) return anotherResponse }) } else { console.log(response) return response } })}</pre></blockquote><p>对比:</p><blockquote><pre>async function loadData() { var response = await getJSON(); if (response.needsAnotherRequest) { var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse } else { console.log(response); return response; }}</pre></blockquote><p>4. <strong>堆栈帧：</strong>与async/await不同的是，从一个Promise链返回的错误堆栈没有给出错误发生的位置。如下:</p><blockquote><pre>function loadData() { return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; { throw new Error("boom"); })}loadData() .catch(function(e) { console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)});</pre></blockquote><p>对比:</p><blockquote><pre>async function loadData() { await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error("boom");}loadData() .catch(function(e) { console.log(err); // output // Error: boom at loadData (index.js:7:9)});</pre></blockquote><p>5. <strong>调试：</strong> 如果你使用了Promise，你知道调试它们是一场噩梦。例如，如果在一个.then中设置了断点。然后，阻塞并使用诸如 “stop-over”之类的调试快捷方式，调试器将不会移动到下一个.then，因为它仅对同步代码提供该功能。通过async/await，您可以逐步调试await调用，就像它们是正常的同步函数一样。 不仅对于应用程序本身，对于那些<strong>库</strong>来说，写<strong>异步的JavaScript代码也很重要</strong>。</p><p>例如, SessionStack库记录Web应用程序／网站中的所有内容：所有DOM更改、用户交互、JavaScript异常、堆栈跟踪、失败的网络请求和调试消息。 这一切都必须发生在你的生产环境中，而不影响任何用户体验。我们需要对代码进行大量优化，并尽可能使其异步，这样我们就可以增加被事件循环处理的事件的数量。 而且不仅是库！当您在SessionStack中重播一个用户会话时，我们必须在问题发生时在您的用户的浏览器中呈现所有发生的事情，我们必须重现整个状态，允许您在会话时间轴上来回跳转。为了使这成为可能，我们大量使用了JavaScript提供的异步功能。</p><p>有一个免费的计划可以让你开始免费使用。</p><p><img alt=异步代码的进化之路：回调，Promise，async/await onerror=errorimg.call(this); src=https://p3.pstatp.com/large/470800027f4508cb6e3d></p><p>免责声明：转载自网络 不用于商业宣传 版权归原作者所有 侵权删</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异步','代码','进化'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>