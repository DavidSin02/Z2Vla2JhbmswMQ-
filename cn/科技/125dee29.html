<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SQL Server中的事务与锁 | 极客快訊</title><meta property="og:title" content="SQL Server中的事务与锁 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/125dee29.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="SQL Server中的事务与锁"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/125dee29.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SQL Server中的事务与锁</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>了解事务和锁</strong></h1><p>事务：保持逻辑数据一致性与可恢复性，必不可少的利器。</p><p>锁：多用户访问同一数据库资源时，对访问的先后次序权限管理的一种机制，没有他事务或许将会一塌糊涂，不能保证数据的安全正确读写。</p><p>死锁：是数据库性能的重量级杀手之一，而死锁却是不同事务之间抢占数据资源造成的。</p><p>不懂的听上去，挺神奇的，懂的感觉我在扯淡，下面带你好好领略下他们的风采，嗅查下他们的狂骚。。</p><h1><strong>先说事务--概念，分类</strong></h1><p>用华仔无间道中的一句来给你诠释下：去不了终点，回到原点。</p><p>举例说明：</p><p>在一个事务中，你写啦2条sql语句，一条是修改订单表状态,一条是修改库存表库存-1 。 如果在修改订单表状态的时候出错，事务能够回滚，数据将恢复到没修改之前的数据状态，下面的修改库存也就不执行，这样确保你关系逻辑的一致，安全。。</p><p>事务就是这个样子，倔脾气，要么全部执行，要么全部不执行，回到原数据状态。</p><p>书面解释：事务具有原子性，一致性，隔离性，持久性。</p><ul><li>原子性：事务必须是一个自动工作的单元，要么全部执行，要么全部不执行。</li><li>一致性：事务结束的时候，所有的内部数据都是正确的。</li><li>隔离性：并发多个事务时，各个事务不干涉内部数据，处理的都是另外一个事务处理之前或之后的数据。</li><li>持久性：事务提交之后，数据是永久性的，不可再回滚。</li></ul><p>然而在SQL Server中事务被分为3类常见的事务：</p><ul><li>自动提交事务：是SQL Server默认的一种事务模式，每条Sql语句都被看成一个事务进行处理，你应该没有见过，一条Update 修改2个字段的语句，只修该了1个字段而另外一个字段没有修改。。</li><li>显式事务：T-sql标明，由Begin Transaction开启事务开始，由Commit Transaction 提交事务、Rollback Transaction 回滚事务结束。</li><li>隐式事务：使用Set IMPLICIT_TRANSACTIONS ON 将将隐式事务模式打开，不用Begin Transaction开启事务，当一个事务结束，这个模式会自动启用下一个事务，只用Commit Transaction 提交事务、Rollback Transaction 回滚事务即可。</li></ul><h1><strong>显式事务的应用</strong></h1><p>常用语句就四个。</p><ul><li>Begin Transaction：标记事务开始。</li><li>Commit Transaction：事务已经成功执行，数据已经处理妥当。</li><li>Rollback Transaction：数据处理过程中出错，回滚到没有处理之前的数据状态，或回滚到事务内部的保存点。</li><li>Save Transaction：事务内部设置的保存点，就是事务可以不全部回滚，只回滚到这里，保证事务内部不出错的前提下。</li></ul><p>上面的都是心法，下面的给你来个招式，要看仔细啦。</p><p>---开启事务</p><p>begin tran</p><p>--错误扑捉机制，看好啦，这里也有的。并且可以嵌套。</p><p>begin try</p><p>--语句正确</p><p>insert into lives (Eat,Play,Numb) values ('猪肉','足球',1)</p><p>--Numb为int类型，出错</p><p>insert into lives (Eat,Play,Numb) values ('猪肉','足球','abc')</p><p>--语句正确</p><p>insert into lives (Eat,Play,Numb) values ('狗肉','篮球',2)</p><p>end try</p><p>begin catch</p><p>select Error_number() as ErrorNumber, --错误代码</p><p>Error_severity() as ErrorSeverity, --错误严重级别，级别小于10 try catch 捕获不到</p><p>Error_state() as ErrorState , --错误状态码</p><p>Error_Procedure() as ErrorProcedure , --出现错误的存储过程或触发器的名称。</p><p>Error_line() as ErrorLine, --发生错误的行号</p><p>Error_message() as ErrorMessage --错误的具体信息</p><p>if(@@trancount>0) --全局变量@@trancount，事务开启此值+1，他用来判断是有开启事务</p><p>rollback tran ---由于出错，这里回滚到开始，第一条语句也没有插入成功。</p><p>end catch</p><p>if(@@trancount>0)</p><p>commit tran --如果成功Lives表中，将会有3条数据。</p><p>--表本身为空表，ID ,Numb为int 类型，其它为nvarchar类型</p><p>select * from lives</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9><p class=pgc-img-caption></p></div><p>---开启事务</p><p>begin tran</p><p>--错误扑捉机制，看好啦，这里也有的。并且可以嵌套。</p><p>begin try</p><p>--语句正确</p><p>insert into lives (Eat,Play,Numb) values ('猪肉','足球',1)</p><p>--加入保存点</p><p>save tran pigOneIn</p><p>--Numb为int类型，出错</p><p>insert into lives (Eat,Play,Numb) values ('猪肉','足球',2)</p><p>--语句正确</p><p>insert into lives (Eat,Play,Numb) values ('狗肉','篮球',3)</p><p>end try</p><p>begin catch</p><p>select Error_number() as ErrorNumber, --错误代码</p><p>Error_severity() as ErrorSeverity, --错误严重级别，级别小于10 try catch 捕获不到</p><p>Error_state() as ErrorState , --错误状态码</p><p>Error_Procedure() as ErrorProcedure , --出现错误的存储过程或触发器的名称。</p><p>Error_line() as ErrorLine, --发生错误的行号</p><p>Error_message() as ErrorMessage --错误的具体信息</p><p>if(@@trancount>0) --全局变量@@trancount，事务开启此值+1，他用来判断是有开启事务</p><p>rollback tran ---由于出错，这里回滚事务到原点，第一条语句也没有插入成功。</p><p>end catch</p><p>if(@@trancount>0)</p><p>rollback tran pigOneIn --如果成功Lives表中，将会有3条数据。</p><p>--表本身为空表，ID ,Numb为int 类型，其它为nvarchar类型</p><h1>select * from lives</h1><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153379415948547425472da><p class=pgc-img-caption></p></div><h1><strong>使用set xact_abort</strong></h1><p>设置 xact_abort on/off , 指定是否回滚当前事务，为on时如果当前sql出错，回滚整个事务，为off时如果sql出错回滚当前sql语句，其它语句照常运行读写数据库。</p><p>需要注意的时：xact_abort只对运行时出现的错误有用，如果sql语句存在编译时错误，那么他就失灵啦。</p><p>delete lives --清空数据</p><p>set xact_abort off</p><p>begin tran</p><p>--语句正确</p><p>insert into lives (Eat,Play,Numb) values ('猪肉','足球',1)</p><p>--Numb为int类型，出错,如果1234..那个大数据换成'132dsaf' xact_abort将失效</p><p>insert into lives (Eat,Play,Numb) values ('猪肉','足球',12345646879783213)</p><p>--语句正确</p><p>insert into lives (Eat,Play,Numb) values ('狗肉','篮球',3)</p><p>commit tran</p><p>select * from lives</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1533794202281fbf2d366f7><p class=pgc-img-caption></p></div><p>为on时，结果集为空，因为运行是数据过大溢出出错，回滚整个事务。</p><h1><strong>事务把死锁给整出来啦</strong></h1><p>跟着做：打开两个查询窗口，把下面的语句，分别放入2个查询窗口，在5秒内运行2个事务模块。</p><p>begin tran</p><p>update lives set play='羽毛球'</p><p>waitfor delay '0:0:5'</p><p>update dbo.Earth set Animal='老虎'</p><p>commit tran</p><p>-------------------------------------------</p><p>begin tran</p><p>update Earth set Animal='老虎'</p><p>waitfor delay '0:0:5' --等待5秒执行下面的语句</p><p>update lives set play='羽毛球'</p><p>commit tran</p><p>select * from lives</p><p>select * from Earth</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1533794264181e181aa5bcc><p class=pgc-img-caption></p></div><h1><strong>并发事务成败皆归于锁——锁定</strong></h1><p>在多用户都用事务同时访问同一个数据资源的情况下，就会造成以下几种数据错误。</p><ul><li>更新丢失：多个用户同时对一个数据资源进行更新，必定会产生被覆盖的数据，造成数据读写异常。</li><li>不可重复读：如果一个用户在一个事务中多次读取一条数据，而另外一个用户则同时更新啦这条数据，造成第一个用户多次读取数据不一致。</li><li>脏读：第一个事务读取第二个事务正在更新的数据表，如果第二个事务还没有更新完成，那么第一个事务读取的数据将是一半为更新过的，一半还没更新过的数据，这样的数据毫无意义。</li><li>幻读：第一个事务读取一个结果集后，第二个事务，对这个结果集经行增删操作，然而第一个事务中再次对这个结果集进行查询时，数据发现丢失或新增。</li></ul><p>然而锁定，就是为解决这些问题所生的，他的存在使得一个事务对他自己的数据块进行操作的时候，而另外一个事务则不能插足这些数据块。这就是所谓的锁定。</p><p>锁定从数据库系统的角度大致可以分为6种：</p><ul><li>共享锁（S）：还可以叫他读锁。可以并发读取数据，但不能修改数据。也就是说当数据资源上存在共享锁的时候，所有的事务都不能对这个资源进行修改，直到数据读取完成，共享锁释放。</li><li>排它锁（X）：还可以叫他独占锁、写锁。就是如果你对数据资源进行增删改操作时，不允许其它任何事务操作这块资源，直到排它锁被释放，防止同时对同一资源进行多重操作。</li><li>更新锁（U）：防止出现死锁的锁模式，两个事务对一个数据资源进行先读取在修改的情况下，使用共享锁和排它锁有时会出现死锁现象，而使用更新锁则可以避免死锁的出现。资源的更新锁一次只能分配给一个事务，如果需要对资源进行修改，更新锁会变成排他锁，否则变为共享锁。</li><li>意向锁：SQL Server需要在层次结构中的底层资源上（如行，列）获取共享锁，排它锁，更新锁。例如表级放置了意向共享锁，就表示事务要对表的页或行上使用共享锁。在表的某一行上上放置意向锁，可以防止其它事务获取其它不兼容的的锁。意向锁可以提高性能，因为数据引擎不需要检测资源的每一列每一行，就能判断是否可以获取到该资源的兼容锁。意向锁包括三种类型：意向共享锁（IS），意向排他锁（IX），意向排他共享锁（SIX）。</li><li>架构锁：防止修改表结构时，并发访问的锁。</li><li>大容量更新锁：允许多个线程将大容量数据并发的插入到同一个表中，在加载的同时，不允许其它进程访问该表。</li></ul><p>这些锁之间的相互兼容性，也就是，是否可以同时存在。</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533794288687f304432caf><p class=pgc-img-caption></p></div><h1><strong>死锁</strong></h1><p>什么是死锁，为什么会产生死锁。我用 “事务把死锁给整出来啦” 标题下的两个事务产生的死锁来解释应该会更加生动形象点。</p><p>例子是这样的：</p><p>第一个事务（称为A）：先更新lives表 --->>停顿5秒---->>更新earth表</p><p>第二个事务（称为B）：先更新earth表--->>停顿5秒---->>更新lives表</p><p>先执行事务A----5秒之内---执行事务B，出现死锁现象。</p><p>过程是这样子的：</p><ol><li>A更新lives表，请求lives的排他锁，成功。</li><li>B更新earth表，请求earth的排他锁，成功。</li><li>5秒过后</li><li>A更新earth，请求earth的排它锁，由于B占用着earth的排它锁，等待。</li><li>B更新lives，请求lives的排它锁，由于A占用着lives的排它锁，等待。</li></ol><p>这样相互等待对方释放资源，造成资源读写拥挤堵塞的情况，就被称为死锁现象，也叫做阻塞。而为什么会产生，上例就列举出来啦。</p><p>然而数据库并没有出现无限等待的情况，是因为数据库搜索引擎会定期检测这种状况，一旦发现有情况，立马选择一个事务作为牺牲品。牺牲的事务，将会回滚数据。有点像两个人在过独木桥，两个无脑的人都走在啦独木桥中间，如果不落水，必定要有一个人给退回来。这种相互等待的过程，是一种耗时耗资源的现象，所以能避则避。</p><p>哪个人会被退回来，作为牺牲品，这个我们是可以控制的。控制语法：</p><p>set deadlock_priority &lt;级别></p><p>死锁处理的优先级别为 low&lt;normal&lt;high，不指定的情况下默认为normal，牺牲品为随机。如果指定，牺牲品为级别低的。</p><p>还可以使用数字来处理标识级别：-10到-5为low，-5为normal，-5到10为high。</p><h1><strong>减少死锁的发生，提高数据库性能</strong></h1><p>死锁耗时耗资源，然而在大型数据库中，高并发带来的死锁是不可避免的，所以我们只能让其变的更少。</p><ol><li>按照同一顺序访问数据库资源，上述例子就不会发生死锁啦</li><li>保持是事务的简短，尽量不要让一个事务处理过于复杂的读写操作。事务过于复杂，占用资源会增多，处理时间增长，容易与其它事务冲突，提升死锁概率。</li><li>尽量不要在事务中要求用户响应，比如修改新增数据之后在完成整个事务的提交，这样延长事务占用资源的时间，也会提升死锁概率。</li><li>尽量减少数据库的并发量。</li><li>尽可能使用分区表，分区视图，把数据放置在不同的磁盘和文件组中，分散访问保存在不同分区的数据，减少因为表中放置锁而造成的其它事务长时间等待。</li><li>避免占用时间很长并且关系表复杂的数据操作。</li><li>使用较低的隔离级别，使用较低的隔离级别比使用较高的隔离级别持有共享锁的时间更短。这样就减少了锁争用。</li></ol><p>可参考：http://msdn.microsoft.com/zh-cn/library/ms191242(v=sql.105).aspx</p><p>查看锁活动情况：</p><p>--查看锁活动情况</p><p>select * from sys.dm_tran_locks</p><p>--查看事务活动情况</p><p>dbcc opentran</p><p>可参考：http://msdn.microsoft.com/zh-cn/library/ms190345.aspx</p><h1><strong>为事务设置隔离级别</strong></h1><p>所谓事物隔离级别，就是并发事务对同一资源的读取深度层次。分为5种。</p><ul><li>read uncommitted：这个隔离级别最低啦，可以读取到一个事务正在处理的数据，但事务还未提交，这种级别的读取叫做脏读。</li><li>read committed：这个级别是默认选项，不能脏读，不能读取事务正在处理没有提交的数据，但能修改。</li><li>repeatable read：不能读取事务正在处理的数据，也不能修改事务处理数据前的数据。</li><li>snapshot：指定事务在开始的时候，就获得了已经提交数据的快照，因此当前事务只能看到事务开始之前对数据所做的修改。</li><li>serializable：最高事务隔离级别，只能看到事务处理之前的数据。</li></ul><p>--语法</p><p>set tran isolation level &lt;级别></p><p><strong>read uncommitted隔离级别的例子：</strong></p><p>begin tran</p><p>set deadlock_priority low</p><p>update Earth set Animal='老虎'</p><p>waitfor delay '0:0:5' --等待5秒执行下面的语句</p><p>rollback tran</p><p>开另外一个查询窗口执行下面语句</p><p>set tran isolation level read uncommitted</p><p>select * from Earth --读取的数据为正在修改的数据 ，脏读</p><p>waitfor delay '0:0:5' --5秒之后数据已经回滚</p><p>select * from Earth --回滚之后的数据</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153379431394532ce5b823c><p class=pgc-img-caption></p></div><p><strong>read committed隔离级别的例子：</strong></p><p>begin tran</p><p>update Earth set Animal='老虎'</p><p>waitfor delay '0:0:10' --等待5秒执行下面的语句</p><p>rollback tran</p><p>set tran isolation level read committed</p><p>select * from Earth ---获取不到老虎，不能脏读</p><p>update Earth set Animal='猴子1' --可以修改</p><p>waitfor delay '0:0:10' --10秒之后上一个事务已经回滚</p><p>select * from Earth --修改之后的数据，而不是猴子</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533794314350f9650334f4><p class=pgc-img-caption></p></div><p>剩下的几个级别，不一一列举啦，自己理解吧。</p><h1><strong>设置锁超时时间</strong></h1><p>发生死锁的时候，数据库引擎会自动检测死锁，解决问题，然而这样子是很被动，只能在发生死锁后，等待处理。</p><p>然而我们也可以主动出击，设置锁超时时间，一旦资源被锁定阻塞，超过设置的锁定时间，阻塞语句自动取消，释放资源，报1222错误。</p><p>好东西一般都具有两面性，调优的同时，也有他的不足之处，那就是一旦超过时间，语句取消，释放资源，但是当前报错事务，不会回滚，会造成数据错误，你需要在程序中捕获1222错误，用程序处理当前事务的逻辑，使数据正确。</p><p>--查看超时时间,默认为-1</p><p>select <strong>@@lock_timeout</strong></p><p>--设置超时时间</p><p>set lock_timeout <strong>0</strong> --为0时，即为一旦发现资源锁定，立即报错，不在等待，当前事务不回滚，设置时间需谨慎处理后事啊，你hold不住的。</p><p>查看与杀死锁和进程</p><div class=pgc-img><img alt="SQL Server中的事务与锁" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533794314016b26bb36b0b><p class=pgc-img-caption></p></div><p>--检测死锁</p><p>--如果发生死锁了，我们怎么去检测具体发生死锁的是哪条SQL语句或存储过程？</p><p>--这时我们可以使用以下存储过程来检测，就可以查出引起死锁的进程和SQL语句。SQL Server自带的系统存储过程sp_who和sp_lock也可以用来查找阻塞和死锁, 但没有这里介绍的方法好用。</p><p>use master</p><p>go</p><p>create procedure sp_who_lock</p><p>as</p><p>begin</p><p>declare @spid int,@bl int,</p><p>@intTransactionCountOnEntry int,</p><p>@intRowcount int,</p><p>@intCountProperties int,</p><p>@intCounter int</p><p>create table #tmp_lock_who (</p><p>id int identity(<strong>1</strong>,<strong>1</strong>),</p><p>spid smallint,</p><p>bl smallint)</p><p>IF <strong>@@ERROR</strong>&lt;><strong>0</strong> RETURN <strong>@@ERROR</strong></p><p>insert into #tmp_lock_who(spid,bl) select <strong>0</strong> ,blocked</p><p>from (select * from sysprocesses where blocked><strong>0</strong> ) a</p><p>where not exists(select * from (select * from sysprocesses where blocked><strong>0</strong> ) b</p><p>where a.blocked=spid)</p><p>union select spid,blocked from sysprocesses where blocked><strong>0</strong></p><p>IF <strong>@@ERROR</strong>&lt;><strong>0</strong> RETURN <strong>@@ERROR</strong></p><p>-- 找到临时表的记录数</p><p>select @intCountProperties = Count(*),@intCounter = <strong>1</strong></p><p>from #tmp_lock_who</p><p>IF <strong>@@ERROR</strong>&lt;><strong>0</strong> RETURN <strong>@@ERROR</strong></p><p>if @intCountProperties=<strong>0</strong></p><p>select '现在没有阻塞和死锁信息' as message</p><p>-- 循环开始</p><p>while @intCounter &lt;= @intCountProperties</p><p>begin</p><p>-- 取第一条记录</p><p>select @spid = spid,@bl = bl</p><p>from #tmp_lock_who where Id = @intCounter</p><p>begin</p><p>if @spid =<strong>0</strong></p><p>select '引起数据库死锁的是: '+ CAST(@bl AS VARCHAR(<strong>10</strong>)) + '进程号,其执行的SQL语法如下'</p><p>else</p><p>select '进程号SPID：'+ CAST(@spid AS VARCHAR(<strong>10</strong>))+ '被' + '进程号SPID：'+ CAST(@bl AS VARCHAR(<strong>10</strong>)) +'阻塞,其当前进程执行的SQL语法如下'</p><p>DBCC INPUTBUFFER (@bl )</p><p>end</p><p>-- 循环指针下移</p><p>set @intCounter = @intCounter + <strong>1</strong></p><p>end</p><p>drop table #tmp_lock_who</p><p>return <strong>0</strong></p><p>end</p><p>--杀死锁和进程</p><p>--如何去手动的杀死进程和锁？最简单的办法，重新启动服务。但是这里要介绍一个存储过程，通过显式的调用，可以杀死进程和锁。</p><p>use master</p><p>go</p><p>if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[p_killspid]') and OBJECTPROPERTY(id, N'IsProcedure') = <strong>1</strong>)</p><p>drop procedure [dbo].[p_killspid]</p><p>GO</p><p>create proc p_killspid</p><p>@dbname varchar(<strong>200</strong>) --要关闭进程的数据库名</p><p>as</p><p>declare @sql nvarchar(<strong>500</strong>)</p><p>declare @spid nvarchar(<strong>20</strong>)</p><p>declare #tb cursor for</p><p>select spid=cast(spid as varchar(<strong>20</strong>)) from master..sysprocesses where dbid=db_id(@dbname)</p><p>open #tb</p><p>fetch next from #tb into @spid</p><p>while <strong>@@fetch_status</strong>=<strong>0</strong></p><p>begin</p><p>exec('kill '+@spid)</p><p>fetch next from #tb into @spid</p><p>end</p><p>close #tb</p><p>deallocate #tb</p><p>go</p><p>--用法</p><p>exec p_killspid 'newdbpy'</p><p>--查看锁信息</p><p>--如何查看系统中所有锁的详细信息？在企业管理管理器中，我们可以看到一些进程和锁的信息，这里介绍另外一种方法。</p><p>--查看锁信息</p><p>create table #t(req_spid int,obj_name sysname)</p><p>declare @s nvarchar(<strong>4000</strong>)</p><p>,@rid int,@dbname sysname,@id int,@objname sysname</p><p>declare tb cursor for</p><p>select distinct req_spid,dbname=db_name(rsc_dbid),rsc_objid</p><p>from master..syslockinfo where rsc_type in(<strong>4</strong>,<strong>5</strong>)</p><p>open tb</p><p>fetch next from tb into @rid,@dbname,@id</p><p>while <strong>@@fetch_status</strong>=<strong>0</strong></p><p>begin</p><p>set @s='select @objname=name from ['+@dbname+']..sysobjects where id=@id'</p><p>exec sp_executesql @s,N'@objname sysname out,@id int',@objname out,@id</p><p>insert into #t values(@rid,@objname)</p><p>fetch next from tb into @rid,@dbname,@id</p><p>end</p><p>close tb</p><p>deallocate tb</p><p>select 进程id=a.req_spid</p><p>,数据库=db_name(rsc_dbid)</p><p>,类型=case rsc_type when <strong>1</strong> then 'NULL 资源（未使用）'</p><p>when <strong>2</strong> then '数据库'</p><p>when <strong>3</strong> then '文件'</p><p>when <strong>4</strong> then '索引'</p><p>when <strong>5</strong> then '表'</p><p>when <strong>6</strong> then '页'</p><p>when <strong>7</strong> then '键'</p><p>when <strong>8</strong> then '扩展盘区'</p><p>when <strong>9</strong> then 'RID（行 ID)'</p><p>when <strong>10</strong> then '应用程序'</p><p>end</p><p>,对象id=rsc_objid</p><p>,对象名=b.obj_name</p><p>,rsc_indid</p><p>from master..syslockinfo a left join #t b on a.req_spid=b.req_spid</p><p>go</p><p>drop table #t</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SQL','Server','事务与锁'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>