<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 压缩算法哪家强 | 极客快訊</title><meta property="og:title" content="Java 压缩算法哪家强 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/649441a963e5442397dd58994f8d3f31"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/154be17c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/154be17c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/154be17c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/154be17c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/154be17c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/154be17c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/154be17c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/154be17c.html><meta property="article:published_time" content="2020-11-14T21:01:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:37+08:00"><meta name=Keywords content><meta name=description content="Java 压缩算法哪家强"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/154be17c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 压缩算法哪家强</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>本文将会对常用的几个压缩算法的性能作一下比较。结果表明，某些算法在极端苛刻的CPU限制下仍能正常工作。</p><p class=ql-align-justify><strong>文中进行比较的算有：</strong></p><ul><li class=ql-align-justify>JDK GZIP ——这是一个压缩比高的慢速算法，压缩后的数据适合长期使用。JDK中的java.util.zip.GZIPInputStream / GZIPOutputStream便是这个算法的实现。</li><li class=ql-align-justify>JDK deflate ——这是JDK中的又一个算法（zip文件用的就是这一算法）。它与gzip的不同之处在于，你可以指定算法的压缩级别，这样你可以在压缩时间和输出文件大小上进行平衡。可选的级别有0（不压缩），以及1(快速压缩)到9（慢速压缩）。它的实现是java.util.zip.DeflaterOutputStream / InflaterInputStream。</li><li class=ql-align-justify>LZ4压缩算法的Java实现——这是本文介绍的算法中压缩速度最快的一个，与最快速的deflate相比，它的压缩的结果要略微差一点。如果想搞清楚它的工作原理，我建议你读一下这篇文章。它是基于友好的Apache 2.0许可证发布的。</li><li class=ql-align-justify>Snappy——这是Google开发的一个非常流行的压缩算法，它旨在提供速度与压缩比都相对较优的压缩算法。我用来测试的是这个实现。它也是遵循Apache 2.0许可证发布的。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>压缩测试</strong></p><p class=ql-align-justify>要找出哪些既适合进行数据压缩测试又存在于大多数Java开发人员的电脑中（我可不希望你为了运行这个测试还得个几百兆的文件）的文件也着实费了我不少工夫。最后我想到，大多数人应该都会在本地安装有JDK的文档。因此我决定将javadoc的目录整个合并成一个文件——拼接所有文件。这个通过tar命令可以很容易完成，但并非所有人都是Linux用户，因此我写了个程序来生成这个文件：</p><blockquote>public class InputGenerator { private static final String JAVADOC_PATH = "your_path_to_JDK/docs"; public static final File FILE_PATH = new File( "your_output_file_path" ); static { try { if ( !FILE_PATH.exists() ) makeJavadocFile(); } catch (IOException e) { e.printStackTrace(); } } private static void makeJavadocFile() throws IOException { try( OutputStream os = new BufferedOutputStream( new FileOutputStream( FILE_PATH ), 65536 ) ) { appendDir(os, new File( JAVADOC_PATH )); } System.out.println( "Javadoc file created" ); } private static void appendDir( final OutputStream os, final File root ) throws IOException { for ( File f : root.listFiles() ) { if ( f.isDirectory() ) appendDir( os, f ); else Files.copy(f.toPath(), os); } }}</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>在我的机器上整个文件的大小是354,509,602字节（338MB）。</p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>测试</strong></p><p class=ql-align-justify>一开始我想把整个文件读进内存里，然后再进行压缩。不过结果表明这么做的话即便是4G的机器上也很容易把堆内存空间耗尽。</p><p class=ql-align-justify>于是我决定使用操作系统的文件缓存。这里我们用的测试框架是JMH。这个文件在预热阶段会被操作系统加载到缓存中（在预热阶段会先压缩两次）。我会将内容压缩到ByteArrayOutputStream流中（我知道这并不是最快的方法，但是对于各个测试而言它的性能是比较稳定的，并且不需要花费时间将压缩后的数据写入到磁盘里），因此还需要一些内存空间来存储这个输出结果。</p><p class=ql-align-justify>下面是测试类的基类。所有的测试不同的地方都只在于压缩的输出流的实现不同，因此可以复用这个测试基类，只需从StreamFactory实现中生成一个流就好了：</p><blockquote>@OutputTimeUnit(TimeUnit.MILLISECONDS)@State(Scope.Thread)@Fork(1)@Warmup(iterations = 2)@Measurement(iterations = 3)@BenchmarkMode(Mode.SingleShotTime)public class TestParent { protected Path m_inputFile; @Setup public void setup() { m_inputFile = InputGenerator.FILE_PATH.toPath(); } interface StreamFactory { public OutputStream getStream( final OutputStream underlyingStream ) throws IOException; } public int baseBenchmark( final StreamFactory factory ) throws IOException { try ( ByteArrayOutputStream bos = new ByteArrayOutputStream((int) m_inputFile.toFile().length()); OutputStream os = factory.getStream( bos ) ) { Files.copy(m_inputFile, os); os.flush(); return bos.size(); } }}</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>这些测试用例都非常相似（在文末有它们的源代码），这里只列出了其中的一个例子——JDK deflate的测试类；</p><blockquote>public class JdkDeflateTest extends TestParent { @Param({"1", "2", "3", "4", "5", "6", "7", "8", "9"}) public int m_lvl; @Benchmark public int deflate() throws IOException { return baseBenchmark(new StreamFactory() { @Override public OutputStream getStream(OutputStream underlyingStream) throws IOException { final Deflater deflater = new Deflater( m_lvl, true ); return new DeflaterOutputStream( underlyingStream, deflater, 512 ); } }); }}</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>测试结果</strong></p><p class=ql-align-justify><strong>输出文件的大小</strong></p><p class=ql-align-justify>首先我们来看下输出文件的大小：</p><p class=ql-align-justify>||实现||文件大小（字节）|| ||GZIP||64，200，201|| ||Snappy (normal)||138,250,196|| ||Snappy (framed)|| 101,470,113|| ||LZ4 (fast)|| 98,316,501|| ||LZ4 (high) ||82,076,909|| ||Deflate (lvl=1) ||78,369,711|| ||Deflate (lvl=2) ||75,261,711|| ||Deflate (lvl=3) ||73,240,781|| ||Deflate (lvl=4) ||68,090,059|| ||Deflate (lvl=5) ||65,699,810|| ||Deflate (lvl=6) ||64,200,191|| ||Deflate (lvl=7) ||64,013,638|| ||Deflate (lvl=8) ||63,845,758|| ||Deflate (lvl=9) ||63,839,200||</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 压缩算法哪家强" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/649441a963e5442397dd58994f8d3f31><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>可以看出文件的大小相差悬殊（从60Mb到131Mb）。我们再来看下不同的压缩方法需要的时间是多少。</p><p class=ql-align-justify>压缩时间</p><p class=ql-align-justify>||实现||压缩时间(ms)|| ||Snappy.framedOutput ||2264.700|| ||Snappy.normalOutput ||2201.120|| ||Lz4.testFastNative ||1056.326|| ||Lz4.testFastUnsafe ||1346.835|| ||Lz4.testFastSafe ||1917.929|| ||Lz4.testHighNative ||7489.958|| ||Lz4.testHighUnsafe ||10306.973|| ||Lz4.testHighSafe ||14413.622|| ||deflate (lvl=1) ||4522.644|| ||deflate (lvl=2) ||4726.477|| ||deflate (lvl=3) ||5081.934|| ||deflate (lvl=4) ||6739.450|| ||deflate (lvl=5) ||7896.572|| ||deflate (lvl=6) ||9783.701|| ||deflate (lvl=7) ||10731.761|| ||deflate (lvl=8) ||14760.361|| ||deflate (lvl=9) ||14878.364|| ||GZIP ||10351.887||</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 压缩算法哪家强" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8951d6a3d6f94bbbbaea1cf0f8fb551b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p class=ql-align-justify>我们再将压缩时间和文件大小合并到一个表中来统计下算法的吞吐量，看看能得出什么结论。</p><p class=ql-align-justify>吞吐量及效率</p><p class=ql-align-justify>||实现||时间（ms）||未压缩文件大小||吞吐量（Mb/秒）||压缩后文件大小(Mb)|| ||Snappy.normalOutput ||2201.12 ||338 ||153.5581885586 ||131.8454742432|| ||Snappy.framedOutput ||2264.7 ||338 ||149.2471409017 ||96.7693328857|| ||Lz4.testFastNative ||1056.326 ||338 ||319.9769768045 ||93.7557220459|| ||Lz4.testFastSafe ||1917.929 ||338 ||176.2317583185 ||93.7557220459|| ||Lz4.testFastUnsafe ||1346.835 ||338 ||250.9587291688 ||93.7557220459|| ||Lz4.testHighNative ||7489.958 ||338 ||45.1270888301 ||78.2680511475|| ||Lz4.testHighSafe ||14413.622 ||338 ||23.4500391366 ||78.2680511475|| ||Lz4.testHighUnsafe ||10306.973 ||338 ||32.7933332124 ||78.2680511475|| ||deflate (lvl=1) ||4522.644 ||338 ||74.7350443679 ||74.7394561768|| ||deflate (lvl=2) ||4726.477 ||338 ||71.5120374012 ||71.7735290527|| ||deflate (lvl=3) ||5081.934 ||338 ||66.5101120951 ||69.8471069336|| ||deflate (lvl=4) ||6739.45 ||338 ||50.1524605124 ||64.9452209473|| ||deflate (lvl=5) ||7896.572 ||338 ||42.8033835442 ||62.6564025879|| ||deflate (lvl=6) ||9783.701 ||338 ||34.5472536415 ||61.2258911133|| ||deflate (lvl=7) ||10731.761 ||338 ||31.4952969974 ||61.0446929932|| ||deflate (lvl=8) ||14760.361 ||338 ||22.8991689295 ||60.8825683594|| ||deflate (lvl=9) ||14878.364 ||338 ||22.7175514727 ||60.8730316162|| ||GZIP ||10351.887 ||338 ||32.651051929 ||61.2258911133||</p><div class=pgc-img><img alt="Java 压缩算法哪家强" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ef5d54ae5b5f4ce9b6649e2783c8cbd3><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>可以看到，其中大多数实现的效率是非常低的：在Xeon E5-2650处理器上，高级别的deflate大约是23Ｍb/秒，即使是GZIP也就只有33Mb/秒，这大概很难令人满意。同时，最快的defalte算法大概能到75Mb/秒,Snappy是150Mb/秒，而LZ4(快速，JNI实现)能达到难以置信的320Mb/秒!</p><p class=ql-align-justify>从表中可以清晰地看出目前有两种实现比较处于劣势：Snappy要慢于LZ4(快速压缩)，并且压缩后的文件要更大。相反，LZ4（高压缩比）要慢于级别1到4的deflate，而输出文件的大小即便和级别1的deflate相比也要大上不少。</p><p class=ql-align-justify>因此如果需要进行“实时压缩”的话我肯定会在LZ4(快速)的JNI实现或者是级别1的deflate中进行选择。当然如果你的公司不允许使用第三方库的话你也只能使用deflate了。你还要综合考虑有多少空闲的CPU资源以及压缩后的数据要存储到哪里。比方说，如果你要将压缩后的数据存储到HDD的话，那么上述100Mb/秒的性能对你而言是毫无帮助的（假设你的文件足够大的话）——HDD的速度会成为瓶颈。同样的文件如果输出到SSD硬盘的话——即便是LZ4在它面前也显得太慢了。如果你是要先压缩数据再发送到网络上的话，最好选择LZ4，因为deflate75Mb/秒的压缩性能跟网络125Mb/秒的吞吐量相比真是小巫见大巫了（当然，我知道网络流量还有包头，不过即使算上了它这个差距也是相当可观的）。</p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>总结</strong></p><p class=ql-align-justify>如果你认为数据压缩非常慢的话，可以考虑下LZ4（快速）实现，它进行文本压缩能达到大约320Mb/秒的速度——这样的压缩速度对大多数应用而言应该都感知不到。</p><p class=ql-align-justify>如果你受限于无法使用第三方库或者只希望有一个稍微好一点的压缩方案的话，可以考虑下使用JDK deflate(lvl=1)进行编解码——同样的文件它的压缩速度能达到75Mb/秒。</p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>想要压缩测试源代码的可以私信我获取</strong></p><h1 class=ql-align-justify><strong>私信我：“资料”，还可免费领取更多学习资料</strong></h1><div class=pgc-img><img alt="Java 压缩算法哪家强" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed343a37c48740ebbe72797d27f47eb3><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="Java 压缩算法哪家强" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6303af21f6ef4fe78917986fe5be6b62><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','压缩','哪家'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>