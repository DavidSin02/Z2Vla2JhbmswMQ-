<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一定能看懂的RocketMQ事务消息源码介绍(干货) | 极客快訊</title><meta property="og:title" content="一定能看懂的RocketMQ事务消息源码介绍(干货) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9893da5524c1439f8a11cb24322c57a9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15b0178.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><meta property="article:published_time" content="2020-10-29T20:50:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:42+08:00"><meta name=Keywords content><meta name=description content="一定能看懂的RocketMQ事务消息源码介绍(干货)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/15b0178.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一定能看懂的RocketMQ事务消息源码介绍(干货)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>前言</strong></h1><p>得益于MQ削峰填谷，系统解耦，操作异步等功能特性，在互联网行业，可以说有分布式服务的地方，MQ都往往不会缺席。由阿里自研的RocketMQ更是经历了多年的双十一高并发挑战，其中4.3.0版本推出了事务消息的新特性，本文对RocketMQ 4.5.0版本事务消息相关的源码跟踪介绍，通过阅读读者可以知道：</p><ul><li>事务消息解决什么样的问题</li><li>事务消息的实现原理及其设计亮点</li></ul><div class=pgc-img><img alt=一定能看懂的RocketMQ事务消息源码介绍(干货) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9893da5524c1439f8a11cb24322c57a9><p class=pgc-img-caption>RocketMQ</p></div><h1><strong>解决什么问题</strong></h1><p>假设我所在的系统现在有这样一个场景：</p><p>本地开启数据库事务进行扣款操作，成功后发送MQ消息给库存中心进行发货。</p><p>有人会想到开启mybatis事务实现，把本地事务和MQ消息放在一起不就行了吗？如果MQ发送成功，就提交事务，发送失败就回滚事务，整套操作一气呵成。</p><pre>transaction{ 扣款(); boolean success = 发送MQ();	if(success){ commit(); }else{ rollBack(); }}</pre><p>看似没什么问题，但是<strong>网络是不可靠</strong>的。假设MQ返回过来的响应因为网络原因迟迟没有收到，所以在面对不确定的MQ返回结果只好进行回滚。但是MQ 服务器又确实是收到了这条消息的，只是给客户端的响应丢失了，所以导致的结果就是扣款失败，成功发货。</p><div class=pgc-img><img alt=一定能看懂的RocketMQ事务消息源码介绍(干货) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e038ea88e9648df9dbeb07dbf872fdb><p class=pgc-img-caption></p></div><p>既然MQ消息的发送不能和本地事务写在一起，那如何来保证其整体具有原子性的需求呢？答案就是今天我们介绍的主角：<strong>事务消息</strong>。</p><h1><strong>概览</strong></h1><div class=pgc-img><img alt=一定能看懂的RocketMQ事务消息源码介绍(干货) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a59f4ec00334086aa34d4af730812c9><p class=pgc-img-caption></p></div><p>总体而言RocketMQ事务消息分为两条主线</p><ol><li><strong>定时任务发送流程</strong>：发送half message(半消息)，执行本地事务，发送事务执行结果</li><li><strong>定时任务回查流程</strong>：MQ服务器回查本地事务，发送事务执行结果</li></ol><p>因此本文也通过这两条主线对源码进行分析</p><h1><strong>源码分析</strong></h1><p><strong>半消息发送流程</strong></p><p><strong>本地应用(client)</strong></p><p>在本地应用发送事务消息的核心类是TransactionMQProducer，该类通过继承DefaultMQProducer来复用大部分发送消息相关的逻辑，这个类的代码量非常少只有100来行，下面是这个类的sendMessageTransaction方法</p><pre>@Overridepublic TransactionSendResult sendMessageInTransaction(final Message msg, final Object arg) throws MQClientException { if (null == this.transactionListener) { throw new MQClientException("TransactionListener is null", null); } return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);}</pre><p>这个方法做了两件事，</p><ol><li>检查transactionListener是否存在</li><li>调用父类执行事务消息发送</li></ol><p>TransactionListener在事务消息流程中起到至关重要的作用，一起看看这个接口</p><pre>public interface TransactionListener { /** * When send transactional prepare(half) message succeed, this method will be invoked to execute local transaction. * * @param msg Half(prepare) message * @param arg Custom business parameter * @return Transaction state */ LocalTransactionState executeLocalTransaction(final Message msg, final Object arg); /** * When no response to prepare(half) message. broker will send check message to check the transaction status, and this * method will be invoked to get local transaction status. * * @param msg Check message * @return Transaction state */ LocalTransactionState checkLocalTransaction(final MessageExt msg);}</pre><p>接口注释说的很明白，配合上面的概览图来看就是，executeLocalTransaction方法对应的就是<strong>执行本地事务</strong>操作，checkLocalTransaction对应的就是<strong>回查本地事务</strong>操作。下面是DefaultMQProducer类的sendMessageInTransaction方法源码</p><pre>public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter localTransactionExecuter, final Object arg) throws MQClientException { ... SendResult sendResult = null; MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true"); MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup()); 						... sendResult = this.send(msg); 						... switch (sendResult.getSendStatus()) { case SEND_OK: { 		... localTransactionState = transactionListener.executeLocalTransaction(msg, arg); ... break; case FLUSH_DISK_TIMEOUT: case FLUSH_SLAVE_TIMEOUT: case SLAVE_NOT_AVAILABLE: localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE; break; default: break; } 						... this.endTransaction(sendResult, localTransactionState, localException);								...}</pre><p>为了使源码的逻辑更加直观，笔者精简了核心代码。sendMessageInTransaction方法主要做了以下事情</p><ol><li>给消息打上事务消息相关的标记，用于MQ服务端区分普通消息和事务消息</li><li>发送半消息(half message)</li><li>发送成功则由transactionListener执行本地事务</li><li>执行endTransaction方法，如果<strong>半消息发送失败</strong>或<strong>本地事务执行失败</strong>告诉服务端是删除半消息，<strong>半消息发送成功</strong>且<strong>本地事务执行成功</strong>则告诉服务端生效半消息。</li></ol><p>发送半消息流程，Client端代码到这里差不多就结束了，接下来看看RocketMQ Server端是如何处理的</p><p><strong>RocketMQ Server</strong></p><p>Server在接收到消息过后会进行一些领域对象的转化和是否支持事务消息的权限校验，对理解事务消息用处不大，此处就省略对旁枝末节的介绍了。下面是TransactionalMessageBridge类处理half message的源码</p><pre>public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner) { return store.putMessage(parseHalfMessageInner(messageInner));}private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) { MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic()); MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msgInner.getQueueId())); msgInner.setSysFlag( MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE)); msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic()); msgInner.setQueueId(0); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); return msgInner;}</pre><p>这两个方法主要做了以下事情：</p><pre>public class Message implements Serializable { private static final long serialVersionUID = 8445773977080406428L; private String topic; private int flag; private Map&lt;String, String&gt; properties; private byte[] body; private String transactionId;}</pre><ol><li>将消息的topic，queueId放进消息体自身的map里进行缓存</li><li>将消息的topic 设置为“RMQ_SYS_TRANS_OP_HALF_TOPIC”，queueId设置为0</li><li>将消息写入磁盘持久化</li></ol><p>可以看到所有的事务半消息都会被放进同一个topic的同一个queue里面，通过对topic的区分，从而避免了半消息被consumer给消费到</p><p>Server将半消息持久化后然后会发送结果给我们本地的应用程序。到了这里Server端对半消息的处理就结束了，紧接着的是定时任务的登场。</p><p><strong>定时任务回查流程</strong></p><p><strong>RocketMQ Server</strong></p><p>定时任务是一个叫TransactionalMessageService类的线程，下面是该类的check方法</p><pre>@Overridepublic void check(long transactionTimeout, int transactionCheckMax, AbstractTransactionalMessageCheckListener listener) { ... if (!putBackHalfMsgQueue(msgExt, i)) { continue; } listener.resolveHalfMsg(msgExt); } 									...}</pre><p>check方法非常长，省略的代码大致都是对半消息进行过滤(如超过72小时的事务消息，就被算作过期)，只保留符合条件的半消息对其进行回查。</p><p>其中很有意思的是putBackHalfMsgQueue方法，因为每次把半消息从磁盘拉到内存里进行处理都会对其属性进行改变(例如TRANSACTION_CHECK_TIMES，这是是否丢弃事务消息的关键信息)，所以在发送回查消息之前需要对半消息再次放进磁盘。RocketMQ采取的方法是基于最新的物理偏移量<strong>重新写入</strong>，而不是对原有的半消息进行<strong>修改</strong>，其中的目的就是RocketMQ的存储设计采用顺序写，如果去修改消息 ，无法做到高性能。</p><p>下面是resolveHalfMsg方法，主要就是开启一个线程然后发送check消息。</p><pre>public void resolveHalfMsg(final MessageExt msgExt) { executorService.execute(new Runnable() { @Override public void run() { try { sendCheckMessage(msgExt); } catch (Exception e) { LOGGER.error("Send check message error!", e); } } });}</pre><p><strong>本地应用(client)</strong></p><p>下面是DefaultMQProducerImpl的checkTransactionState方法，是本地应用对回查消息的处理逻辑</p><pre>@Overridepublic void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) { Runnable request = new Runnable() { ... @Override public void run() { ... TransactionListener transactionListener = getCheckListener(); ... localTransactionState = transactionListener.checkLocalTransaction(message); ...  this.processTransactionState( localTransactionState, group, exception);  }  private void processTransactionState( ... DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark, 3000); ... } }; this.checkExecutor.submit(request);}</pre><p>精简代码逻辑后可以清晰的看到</p><ul><li>开启一个线程来执行回查的逻辑</li><li>通过执行transactionListener的checkLocalTransaction方法来获取本地事务执行的结果</li></ul><p><strong>RocketMQ Server</strong></p><p>RocketMQ 服务器在收到Client发过来的Commit消息后会</p><p>读出半消息——>恢复topic等原消息体的信息——>和普通消息一样再次写入磁盘——>删除之前的半消息</p><p>如果是Rollback消息则直接删除之前的半消息</p><p>到此，整条RocketMQ 事务消息的调用链就结束了</p><h1><strong>思考</strong></h1><p><strong>1. 分布式事务等于事务消息吗？</strong></p><p>两者并没有关系，事务消息仅仅保证本地事务和MQ消息发送形成整体的原子性，而投递到MQ服务器后，消费者是否能一定消费成功是无法保证的。</p><p><strong>2. 源码设计上有什么亮点吗？</strong></p><p>通过对整条链路源码的学习理解发现还是有不少亮点的</p><ul><li>server端回查消息的发送，client端回查消息逻辑的处理，client端commit/rollback消息的提交都是用了异步进行，可以说能异步的地方都用了异步，通过异步+重试的方式保证了在分布式环境中即使短暂的网络状况不良好，也不会影响整体逻辑。</li><li>引入TransactionListener，真正做到了开闭原则以及依赖倒置原则，面向接口编程。整体扩展性做得非常好，使用者只需要编写自己的Listener就可以做到事务消息的发送，非常方便</li><li>TransactionMQProducer通过继承DefaultMQProducer极大地复用了关于发送消息相关的逻辑</li></ul><p><strong>3. 源码设计上有什么不足吗？</strong></p><p>RocketMQ作为一款极其成功的消息中间件，要发现不足不是那么容易了，笔者谈几点看法</p><ul><li>sendMessageIntransaction等事务相关的方法被划分在了DefaultMQProducer里面，从内聚的角度来说这是跟事务相关的发送消息方法应该被划分在TransactionMQProducer。</li><li>所有topic的半消息都会写在topic为RMQ_SYS_TRANS_OP_HALF_TOPIC的半消息队列里，并且每条半消息，在整个链路里会被写多次，如果并发很大且大部分消息都是事务消息的话，可靠性会存在问题。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'RocketMQ','事务','源码'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>