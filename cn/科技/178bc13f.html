<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C语言指针难吗？纸老虎而已，纯干货讲解 | 极客快訊</title><meta property="og:title" content="C语言指针难吗？纸老虎而已，纯干货讲解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/71b50f2a7c1141a2ac44a24efb4a84ff"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="C语言指针难吗？纸老虎而已，纯干货讲解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/178bc13f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C语言指针难吗？纸老虎而已，纯干货讲解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>指针对于C来说太重要。然而，想要全面理解指针，除了要对C语言有熟练的掌握外，还要有计算机硬件以及操作系统等方方面面的基本知识。所以本文尽可能的通过一篇文章完全讲解指针。</p><p><strong>为什么需要指针？</strong></p><p>指针解决了一些编程中基本的问题。</p><p><strong>第一，</strong>指针的使用使得不同区域的代码可以轻易的共享内存数据。当然小伙伴们也可以通过数据的复制达到相同的效果，但是这样往往效率不太好。<br>因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。<br>但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。</p><p><strong>第二，</strong>指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。</p><p><strong>第三，</strong>有些操作必须使用指针。如操作申请的堆内存。<br>还有：C语言中的一切函数调用中，值传递都是“按值传递”的。<br>如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。</p><p><br><strong>计算机是如何从内存中进行取指的？</strong></p><p>计算机的总线可以分为3种：数据总线，地址总线和控制总线。这里不对控制总线进行描述。数据总线用于进行数据信息传送。数据总线的位数一般与CPU的字长一致。一般而言，数据总线的位数跟当前机器int值的长度相等。例如在16位机器上，int的长度是16bit，32位机器则是32bit。这个计算机一条指令最多能够读取或者存取的数据长度。大于这个值，计算机将进行多次访问。这也就是我们说的64位机器进行64位数据运算的效率比32位要高的原因，因为32位机要进行两次取指和运行，而64位机却只需要一次！</p><p><br>地址总线专门用于寻址，CPU通过该地址进行数据的访问，然后把处于该地址处的数据通过数据总线进行传送，传送的长度就是数据总线的位数。地址总线的位数决定了CPU可直接寻址的内存空间大小，比如CPU总线长32位，其最大的直接寻址空间长232KB，也就是4G。这也就是我们常说的32位CPU最大支持的内存上限为4G（当然，实际上支持不到这个值，因为一部分寻址空间会被映射到外部的一些IO设备和虚拟内存上。现在通过一些新的技术，可以使32位机支持4G以上内存，但这个不在这里的讨论范围内）。</p><p>一般而言，计算机的地址总线和数据总线的宽度是一样的，我们说32位的CPU，数据总线和地址总线的宽度都是32位。</p><p><br><strong>计算机访问某个数据的时候，首先要通过地址总线传送数据存储或者读取的位置，然后在通过数据总线传送需要存储或者读取的数据。一般地，int整型的位数等于数据总线的宽度，指针的位数等于地址总线的宽度。</strong></p><p></p><p><strong>计算机的基本访问单元</strong></p><p>学过C语言的人都知道，C语言的基本数据类型中，就属char的位数最小，是8位。我们可以认为计算机以8位，即1个字节为基本访问单元。小于一个字节的数据，必须通过位操作来进行访问。</p><p><strong>内存访问方式</strong></p><p>如图1所示，<strong>计算机在进行数据访问的时候，是以字节为基本单元进行访问的</strong>，所以可以认为，计算每次都是从第p个字节开始访问的。访问的长度将由编译器根据实际类型进行计算，这在后面将会进行讲述。</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71b50f2a7c1141a2ac44a24efb4a84ff><p class=pgc-img-caption></p></div><p>内存访问方式</p><p>想要了解更多，就去翻阅计算机组成原理和编译原理吧。</p><p><strong>sizeof关键字</strong></p><p><strong>sizeof关键字是编译器用来计算某些类型的数据的长度的，以字节为基本单位。例如：</strong></p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li></ul><pre>sizeof(char)=1; sizeof(int)=4;</pre><p><br><strong>sizeof(Type)的值是在编译的时候就计算出来了的，可以认为这是一个常量！</strong></p><p><strong>指针是什么？</strong></p><p>我们知道：C语言中的数组是指一类类型，数组具体区分为 int 类型数组，double类型数组,char数组 等等。<br>同样指针这个概念也泛指一类数据类型，int指针类型，double指针类型，char指针类型等等。</p><p>通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符：char ch = 'a'。</p><p>我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。<br>而为了保存一个数据在内存中的地址，我们就需要指针变量。</p><p>因此：指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ed9b2cf6c914598889d355dbdb2bb32><p class=pgc-img-caption></p></div><p><strong>在我个人的理解中，可以将指针理解成int整型，只不过它存放的数据是内存地址，而不是普通数据，我们通过这个地址值进行数据的访问，假设它的是p，意思就是该数据存放位置为内存的第p个字节。</strong></p><p><br><strong>当然，我们不能像对int类型的数据那样进行各种加减乘除操作，这是编译器不允许的，因为这样错是非常危险的！</strong></p><p><br>图2就是对指针的描述，<strong>指针的值是数据存放地址，因此，我们说，指针指向数据的存放位置。</strong></p><p></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0b19f92aeed745e994f673b4239831f1><p class=pgc-img-caption></p></div><p><strong>指针的长度<br></strong><br>我们使用这样的方式来定义一个指针：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>Type *p;</pre><p><br>我们说<strong>p是指向type类型的指针</strong>，type可以是任意类型，除了可以是char,short, int, long等基本类型外，还可以是指针类型，例如int *, int **, 或者更多级的指针，也可是是结构体，类或者函数等。于是，我们说：</p><p>int * 是指向int类型的指针；</p><p>int **，也即(int *) *，是指向int *类型的指针，也就是指向指针的指针；</p><p>int ***，也即(int **) *，是指向int**类型的指针，也就是指向指针的指针的指针；</p><p>…我想你应该懂了</p><p>struct xxx *，是指向struct xxx类型的指针；</p><p>其实，说这么多，只是希望大家在看到指针的时候，不要被int ***这样的东西吓到，就像前面说的，指针就是指向某种类型的指针，我们只看最后一个*号，前面的只不过是type类型罢了。</p><p>细心一点的人应该发现了，在“什么是指针”这一小节当中，已经表明了：<strong>指针的长度跟CPU的位数相等</strong>，大部分的CPU是32位的，因此我们说，<strong>指针的长度是32bit，也就是4个字节！</strong>注意：任意指针的长度都是4个字节，不管是什么指针！（当然64位机自己去测一下，应该是8个字节吧。。。）</p><p>于是：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>Type *p;</pre><p>izeof(p)的值是4，Type可以是任意类型，char,int, long, struct, class, int **…</p><p><strong>以后大家看到什么sizeof(char*), sizeof(int *)，sizeof(xxx *)，不要理会，统统写4，只要是指针，长度就是4个字节，绝对不要被type类型迷惑！</strong></p><p><strong>为什么程序中的数据会有自己的地址？</strong></p><p>弄清这个问题我们需要从操作系统的角度去认知内存。</p><p>电脑维修师傅眼中的内存是这样的：内存在物理上是由一组DRAM芯片组成的。</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/518ea251e5954ee8afa909b73a6cb30c><p class=pgc-img-caption></p></div><p>而作为一个程序员，我们不需要了解内存的物理结构，操作系统将RAM等硬件和软件结合起来，给程序员提供的一种对内存使用的抽象。<br>这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作和使用真实存在的物理存储器。<br>所有的虚拟地址形成的集合就是虚拟地址空间。</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b994759f32dc41cbbf915e3ac1cb76b4><p class=pgc-img-caption></p></div><p>在程序员眼中的内存应该是下面这样的。</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f0532fef3c4427ebe6e7d01323d575f><p class=pgc-img-caption></p></div><p>也就是说，内存是一个很大的，线性的字节数组（平坦寻址）。每一个字节都是固定的大小，由8个二进制位组成。<br>最关键的是，每一个字节都有一个唯一的编号,编号从0开始，一直到最后一个字节。<br>如上图中，这是一个256M的内存，他一共有256x1024x1024 = 268435456个字节，那么它的地址范围就是 0 ~268435455 。</p><p>由于内存中的每一个字节都有一个唯一的编号。<br>因此，在程序中使用的变量，常量，甚至数函数等数据，当他们被载入到内存中后，都有自己唯一的一个编号，这个编号就是这个数据的地址。<br>指针就是这样形成的。</p><p><strong>下面用代码说明</strong></p><pre>#include &lt;stdio.h&gt;int main(void){ char ch = 'a'; int num = 97; printf("ch 的地址:%p",&amp;ch); //ch 的地址:0028FF47 printf("num的地址:%p",&amp;num); //num的地址:0028FF40 return 0;}</pre><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5a42bf835dac4b29bec2cf8a9954ea83><p class=pgc-img-caption></p></div><p>指针的值实质是内存单元（即字节）的编号，所以指针单独从数值上看，也是整数，他们一般用16进制表示。<br>指针的值（虚拟地址值）使用一个机器字的大小来存储。<br>也就是说,对于一个机器字为w位的电脑而言,它的虚拟地址空间是0~2w － 1 ,程序最多能访问2w个字节。<br>这就是为什么xp这种32位系统最大支持4GB内存的原因了。</p><p>我们可以大致画出变量ch和num在内存模型中的存储。（假设 char占1个字节，int占4字节）</p><p></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a17e2b0d5c474818af3594a0ed7d7d36><p class=pgc-img-caption></p></div><p><strong>变量和内存</strong></p><p>为了简单起见，这里就用上面例子中的 int num = 97 这个局部变量来分析变量在内存中的存储模型。</p><p></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b25209de6f24c8f8808213e33beeaf8><p class=pgc-img-caption></p></div><p>已知：num的类型是int，占用了4个字节的内存空间，其值是97，地址是0028FF40。我们从以下几个方面去分析。</p><p><strong>1、内存的数据</strong></p><p>内存的数据就是变量的值对应的二进制，一切都是二进制。<br>97的二进制是 : 00000000 00000000 00000000 0110000 , 但使用的小端模式存储时，低位数据存放在低地址，所以图中画的时候是倒过来的。</p><p><strong>2、内存数据的类型</strong></p><p>内存的数据类型决定了这个数据占用的字节数，以及计算机将如何解释这些字节。<br>num的类型是int，因此将被解释为 一个整数。</p><p><strong>3、内存数据的名称</strong></p><p>内存的名称就是变量名。实质上，内存数据都是以地址来标识的，根本没有内存的名称这个说法，这只是高级语言提供的抽象机制 ，方便我们操作内存数据。<br>而且在C语言中，并不是所有的内存数据都有名称，例如使用malloc申请的堆内存就没有。</p><p><strong>4、内存数据的地址</strong></p><p>如果一个类型占用的字节数大于1，则其变量的地址就是地址值最小的那个字节的地址。<br>因此num的地址是 0028FF40。内存的地址用于标识这个内存块。</p><p><strong>5、内存数据的生命周期</strong></p><p>num是main函数中的局部变量，因此当main函数被启动时，它被分配于栈内存上，当main执行结束时，消亡。</p><p>如果一个数据一直占用着他的内存，那么我们就说他是“活着的”，如果他占用的内存被回收了，则这个数据就“消亡了”。<br>C语言中的程序数据会按照他们定义的位置，数据的种类，修饰的关键字等因素，决定他们的生命周期特性。<br>实质上我们程序使用的内存会被逻辑上划分为：栈区，堆区，静态数据区，方法区。<br>不同的区域的数据有不同的生命周期。</p><p><br>无论以后计算机硬件如何发展，内存容量都是有限的，因此清楚理解程序中每一个程序数据的生命周期是非常重要的。</p><p><br><strong>指针运算</strong></p><p>N多的面试会考这种东西了：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li></ul><pre>Type *p; p++;</pre><p>然后问你p的值变化了多少。</p><p>其实，也可以认为这是在考编译器的基本知识。因此p<strong>的值并不像表面看到的+1那么简单，编译器实际上对p进行的是加sizeof(Type)的操作。</strong></p><p>看一个一段代码的测试结果：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4b4cbcdda7924d04b0af5dc9e22a5f78><p class=pgc-img-caption></p></div><p>这里注释掉char一行的原因是因为cout&lt;&lt;(char*)会被当成字符串输出，而不是char的地址）</p><p>执行结果：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/adb9dcb5991f4d079bec14487cedfe32><p class=pgc-img-caption></p></div><p>观察结果，可以看出，他们的增长结果分别是：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>2（sizeof(short)） 4（sizeof(int)） 4（sizeof(long)） 8（sizeof(long long)） 4（sizeof(float)） 8（sizeof(double)） 12（sizeof(long double)）</pre><p><br>喏，增加的值是不是sizeof(Type)呢？别的什么struct，class之类的，就不验证你，有兴趣的自己去验证。</p><p>我们再对这样的一段代码进行汇编，查看编译器是如何进行指针的加法操作的：</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/79808f1372ae4080ab8cf9e98d5e4291><p class=pgc-img-caption></p></div><p>汇编结果：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e5212fe881c54afe8f73c8360b0cd727><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/843b4594602b4c17a90462a76545e346><p class=pgc-img-caption></p></div><p>注意看注释部分的结果，我们看到，piv的值显示加了4（sizeof(int)），然后又加了16（4*sizeof(int)）。</p><p><br><strong>指针变量和指向关系</strong></p><p>用来保存指针的变量，就是指针变量。<br>如果指针变量p1保存了变量 num的地址，则就说：p1指向了变量num，也可以说p1指向了num所在的内存块 ，这种指向关系，在图中一般用 箭头表示。</p><p></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/347f8fe613dc462cb6b6f2fea7acdb2e><p class=pgc-img-caption></p></div><p>上图中，指针变量p1指向了num所在的内存块 ，即从地址0028FF40开始的4个byte 的内存块。</p><p><strong>定义指针变量</strong></p><p>C语言中，定义变量时，在变量名前写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。</p><p>引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。</p><pre>int a ; //int类型变量 aint *a ; //int* 变量aint arr[3]; //arr是包含3个int元素的数组int (* arr )[3]; //arr是一个指向包含3个int元素的数组的指针变量//-----------------各种类型的指针------------------------------int* p_int; //指向int类型变量的指针 double* p_double; //指向idouble类型变量的指针 struct Student *p_struct; //结构体类型的指针int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 int(*p_arr)[3]; //指向含有3个int元素的数组的指针 int** p_pointer; //指向 一个整形变量指针的指针</pre><p><strong>指针的2个重要属性</strong></p><p>指针也是一种数据，指针变量也是一种变量，因此指针 这种数据也符合前面变量和内存主题中的特性。<br>这里要强调2个属性：指针的类型，指针的值。</p><pre>int main(void){ int num = 97; int *p1 = # char* p2 = (char*)(&amp;num); printf("%d",*p1); //输出 97 putchar(*p2); //输出 a return 0;}</pre><p>指针的值：很好理解，如上面的num 变量 ，其地址的值就是0028FF40 ，因此 p1的值就是0028FF40。<br>数据的地址用于在内存中定位和标识这个数据，因为任何2个内存不重叠的不同数据的地址都是不同的。</p><p>指针的类型：指针的类型决定了这个指针指向的内存的字节数并如何解释这些字节信息。<br>一般指针变量的类型要和它指向的数据的类型匹配。</p><p>由于num的地址是0028FF40，因此 p1 和 p2 的值都是0028FF40</p><p>*p1 : 将从地址0028FF40 开始解析，因为p1是int类型指针，int占4字节，因此向后连续取4个字节，并将这4个字节的二进制数据解析为一个整数 97。</p><p>*p2 : 将从地址0028FF40 开始解析，因为p2是char类型指针，char占1字节，因此向后连续取1个字节，并将这1个字节的二进制数据解析为一个字符，即'a'。</p><p>同样的地址，因为指针的类型不同，对它指向的内存的解释就不同，得到的就是不同的数据。</p><p><strong>取地址</strong></p><p>既然有了指针变量，那就得让他保存其它变量的地址，使用& 运算符取得一个变量的地址。</p><pre>int add(int a , int b){ return a + b;}int main(void){ int num = 97; float score = 10.00F; int arr[3] = {1,2,3}; //----------------------- int* p_num = # float* p_score = &amp;score; int (*p_arr)[3] = &amp;arr; int (*fp_add)(int ,int ) = add; //p_add是指向函数add的函数指针 return 0;}</pre><p>特殊的情况，他们并不一定需要使用&取地址：</p><ul class=list-paddingleft-2><li>数组名的值就是这个数组的第一个元素的地址。</li><li>函数名的值就是这个函数的地址。</li><li>字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。</li></ul><pre>int add(int a , int b){ return a + b;}int main(void){ int arr[3] = {1,2,3}; //----------------------- int* p_first = arr; int (*fp_add)(int ,int ) = add; const char* msg = "Hello world"; return 0;}</pre><p><strong>解地址</strong></p><p>我们需要一个数据的指针变量干什么？<br>当然使用通过它来操作（读/写）它指向的数据啦。<br>对一个指针解地址，就可以取到这个内存数据，解地址的写法，就是在指针的前面加一个*号。</p><p>解指针的实质是：从指针指向的内存块中取出这个内存数据。</p><pre>int main(void){ int age = 19; int*p_age = &amp;age; *p_age = 20; //通过指针修改指向的内存数据 printf("age = %d",*p_age); //通过指针读取指向的内存数据 printf("age = %d",age); return 0;}</pre><p><strong>指针之间的赋值</strong></p><p>指针赋值和int变量赋值一样，就是将地址的值拷贝给另外一个。<br>指针之间的赋值是一种浅拷贝，是在多个编程单元之间共享内存数据的高效的方法。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>int* p1 = &amp; num;int* p3 = p1;//通过指针 p1 、 p3 都可以对内存数据 num 进行读写，如果2个函数分别使用了p1 和p3，那么这2个函数就共享了数据num。</pre><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fce8cedb9f384a35b812ed10cc3f54f5><p class=pgc-img-caption></p></div><p><strong>空指针（NULL指针）</strong></p><p>NULL是C语言标准定义的一个值，这个值其实就是0，只不过为了使得看起来更加具有意义，才定义了这样的一个宏，中文的意思是空，表明不指向任何东西。你懂得。不过在此不讨论空和零的区别。<br>在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是((void*)0)，就像前面说的指针可以理解成特殊的int，它总是有值的，p=NULL，其实就是p的值等于0。对于不多数机器而言，0地址是不能直接访问的，设置为0，就表示该指针哪里都没指向。而在C++中，NULL实质是0。</p><p>换种说法：任何程序数据都不会存储在地址为0的内存块中，它是被操作系统预留的内存块。<br><strong>下面代码摘自 stdlib.h</strong></p><pre>#ifdef __cplusplus #define NULL 0#else #define NULL ((void *)0)#endif</pre><p>当然，就机器内部而言，NULL指针的实际值可能与此不同，这种情况下，编译器将负责零值和内部值之间的翻译转换。</p><p>NULL指针的概念非常有用，它给了你一种方法，表示某个特定的指针目前并未指向任何东西。例如，一个用于在某个数组中查找某个特定值的函数可能返回一个指向查找到的数组元素的指针。如果没找到，则返回一个NULL指针。</p><p>在内存的动态分配上，NULL的意义非同凡响，我们使用它来避免内存被多次释放，造成经常性的段错误（segmentation fault）。一般，<strong>在free或者delete掉动态分配的内存后，都应该立即把指针置空，避免出现所以的悬挂指针，致使出现各种内存错误！</strong>例如：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cda94aa607442aa94415e40e34743b4><p class=pgc-img-caption></p></div><p>free函数是不会也不可能把p置空的。像下面这样的代码就会出现内存段错误：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/880e821635b4479082f58afe589a1afa><p class=pgc-img-caption></p></div><p>因为，第一次free操作之后，p指向的内存已经释放了，但是p的值还没有变化，free函数改不了这个值，再free一次的时候，p指向的内存区域已经被释放了，这个地址已经变成了非法地址，这个操作将导致段错误的发生（此时，p指向的区域刚好又被分配出去了，但是这种概率非常低，而且对这样一块内存区域进行操作是非常危险的！）<br>但是下面这段代码就不会出现这样的问题：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4a17dfa6e57e4e239aa2f50003dbb777><p class=pgc-img-caption></p></div><p>因为p的值编程了NULL，free函数检测到p为NULL，会直接返回，而不会发生错误。</p><p><strong>这里顺便告诉大家一个内存释放的小窍门，可以有效的避免因为忘记对指针进行置空而出现各种内存问题。这个方法就是自定义一个内存释放函数，但是传入的参数不知指针，而是指针的地址，在这个函数里面置空，如下：<br></strong><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/616563388e7742e09deb7caeb17dd5db><p class=pgc-img-caption></p></div><p>结果：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bd5050c746140a5847198cb292433c0><p class=pgc-img-caption></p></div><p>my_free调用了之后，p的值就变成了0（NULL），调用多少次free都不会报错了！</p><p><strong>另外一个方式也非常有效，那就是定义FREE宏，在宏里面对他进行置空。例如<br></strong><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfb3c4184f1f4d1ebf9e091ca505ae0c><p class=pgc-img-caption></p></div><p>执行结果同上面一样，不会报段错误：</p><p></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf765a15bc4a4a0e85f4751a437b1fca><p class=pgc-img-caption></p></div><p>（关于内存的动态分配，这是个比较复杂的话题，有机会再专门开辟一章给各位讲述一下吧，写个帖子还是很花费时间和精力的，呵呵，写过的童鞋应该都很清楚，所以顺便插一句，转帖可以，请注明出处，毕竟，大家都是本着共享的精神来讨论问题的，写的好坏都没有向你所要什么，请尊重每个人的劳动成果。）</p><p>指向空，或者说不指向任何东西。<br><strong>坏指针</strong></p><p>指针变量的值是NULL，或者未知的地址值，或者是当前应用程序不可访问的地址值，这样的指针就是坏指针。<br>不能对他们做解指针操作，否则程序会出现运行时错误，导致程序意外终止。</p><p>任何一个指针变量在做解地址操作前，都必须保证它指向的是有效的，可用的内存块，否则就会出错。<br>坏指针是造成C语言Bug的最频繁的原因之一。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>下面的代码就是错误的示例。void opp(){ int*p = NULL; *p = 10; //Oops! 不能对NULL解地址}void foo(){ int*p; *p = 10; //Oops! 不能对一个未知的地址解地址}void bar(){ int*p = (int*)1000; *p =10; //Oops! 不能对一个可能不属于本程序的内存的地址的指针解地址}</pre><p><br><strong>void*类型指针</strong></p><p>由于void是空类型，因此void*类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址。<br>如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对void*类型的指针做解指针操作。</p><p><br>虽然从字面上看，void的意思是空，但是void指针的意思，可不是空指针的意思，空指针指的是上面所说的NULL指针。</p><p><br><strong>void指针实际上的意思是指向任意类型的指针</strong>。任意类型的指针都可以直接赋给void指针，而不需要进行强制转换。</p><p>例如：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>Type a, *p=&amp;a;（Type等于char, int, struct, int *…）void *pv;pv=p;</pre><p><br>就像前面说的，void指针的好处，就在于，任意的指针都可以直接赋值给它，这在某些场合非常有用，因此有些操作对于任意指针都是相同的。void指针最常用于内存管理。最典型的，也是大家最熟知的，就是标准库的free函数。它的原型如下：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre> void free(void*ptr);</pre><p><br>free函数的参数可以是任意指针，没有谁见过free参数里面的指针需要强壮为void*的吧？</p><p>malloc, calloc,realloc这些函数的返回值也是void指针，因为内存分配，实际上只需要知道分配的大小，然后返回新分配内存的地址就可以了，指针的值就是地址，返回的不管是何种指针，其实结果都是一样的，因为所有的指针长度其实都是32位的（32位机器），它的值就是内存的地址，指针类型只是给编译器看的，目的是让编译器在编译的时候能够正确的设置指针的值（参见指针运算章节）。如果malloc函数设置成下面这样的原型，完全没有问题。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>char*malloc(size_t sz);</pre><p><br>实际上设置成</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>Type*malloc(size_t sz);</pre><p><br>也是完全正确的，使用void指针的原因，实际上就像前面说的，void指针意思是任意指针，这样设计更加严谨一些，也更符合我们的直观理解。如果对前面我说的指针概念理解的童鞋，肯定明白这一点。</p><p><strong>结构体和指针</strong></p><p>结构体指针有特殊的语法：-> 符号</p><p>如果p是一个结构体指针，则可以使用 p ->【成员】 的方法访问结构体的成员</p><pre>typedef struct{ char name[31]; int age; float score;}Student;int main(void){ Student stu = {"Bob" , 19, 98.0}; Student*ps = &amp;stu; ps-&gt;age = 20; ps-&gt;score = 99.0; printf("name:%s age:%d",ps-&gt;name,ps-&gt;age); return 0;}</pre><p><strong>数组和指针</strong></p><p>1、数组名作为右值的时候，就是第一个元素的地址。</p><pre>int main(void){ int arr[3] = {1,2,3}; int*p_first = arr; printf("%d",*p_first); //1 return 0;}</pre><p>2、指向数组元素的指针 支持 递增 递减 运算。<br>（实质上所有指针都支持递增递减 运算 ，但只有在数组中使用才是有意义的）</p><pre>int main(void){ int arr[3] = {1,2,3}; int*p = arr; for(;p!=arr+3;p++){ printf("%d",*p); } return 0;}</pre><p>3、p= p+1 意思是，让p指向原来指向的内存块的下一个相邻的相同类型的内存块。</p><p>同一个数组中，元素的指针之间可以做减法运算，此时，指针之差等于下标之差。</p><p>4、p[n] == *(p+n)</p><p>p[n][m] == *( *(p+n)+ m )</p><p>5、当对数组名使用sizeof时，返回的是整个数组占用的内存字节数。当把数组名赋值给一个指针后，再对指针使用sizeof运算符，返回的是指针的大小。</p><p>这就是为什么将一个数组传递给一个函数时，需要另外用一个参数传递数组元素个数的原因了。</p><pre>int main(void){ int arr[3] = {1,2,3}; int*p = arr; printf("sizeof(arr)=%d",sizeof(arr)); //sizeof(arr)=12 printf("sizeof(p)=%d",sizeof(p)); //sizeof(p)=4 return 0;}</pre><p><br><strong>函数和指针</strong></p><p><strong>函数的参数和指针</strong></p><p>C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。<br>这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。</p><pre>void change(int a){ a++; //在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。}int main(void){ int age = 19; change(age); printf("age = %d",age); // age = 19 return 0;}</pre><p><br>有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的。<br>但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。</p><p>传递变量的指针可以轻松解决上述问题。</p><pre>void change(int* pa){ (*pa)++; //因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时， //会直接去内存中找到age这个数据，然后把它增1。}int main(void){ int age = 19; change(&amp;age); printf("age = %d",age); // age = 20 return 0;}</pre><p>再来一个老生常谈的，用函数交换2个变量的值的例子：</p><pre>#include&lt;stdio.h&gt;void swap_bad(int a,int b);void swap_ok(int*pa,int*pb);int main(){ int a = 5; int b = 3; swap_bad(a,b); //Can`t swap; swap_ok(&amp;a,&amp;b); //OK return 0;}//错误的写法void swap_bad(int a,int b){ int t; t=a; a=b; b=t;}//正确的写法：通过指针void swap_ok(int*pa,int*pb){ int t; t=*pa; *pa=*pb; *pb=t;}</pre><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e8464e2a9194b8bb2a4235e5ab17120><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/19ce4cf5c8dd40f6bb1020d589e9a1fe><p class=pgc-img-caption></p></div><p>有的时候，我们通过指针传递数据给函数不是为了在函数中改变他指向的对象。<br>相反，我们防止这个目标数据被改变。传递指针只是为了避免拷贝大型数据。</p><p>考虑一个结构体类型Student。我们通过show函数输出Student变量的数据。</p><pre>typedef struct{ char name[31]; int age; float score;}Student;//打印Student变量信息void show(const Student * ps){ printf("name:%s , age:%d , score:%.2f",ps-&gt;name,ps-&gt;age,ps-&gt;score); }</pre><p><br>我们只是在show函数中取读Student变量的信息，而不会去修改它，为了防止意外修改，我们使用了常量指针去约束。<br>另外我们为什么要使用指针而不是直接传递Student变量呢？</p><p>从定义的结构看出，Student变量的大小至少是39个字节，那么通过函数直接传递变量，实参赋值数据给形参需要拷贝至少39个字节的数据，极不高效。<br>而传递变量的指针却快很多，因为在同一个平台下，无论什么类型的指针大小都是固定的：X86指针4字节，X64指针8字节，远远比一个Student结构体变量小。</p><p><strong>函数的指针</strong><br>跟普通的变量一样，每一个函数都是有其地址的，我们通过跳转到这个地址执行代码来进行函数调用，只是，跟取普通数据不同的在于，函数有参数和返回值，在进行函数调用的时候，首先需要将参数压入栈中，调用完成后又需要将参数压入栈中。既然函数也是通过地址来进行访问的，那它也可以使用指针来指向，事实上，每一个函数名都是一个指针，不过它是指针常量和指针常量，它的值是不能改的，指向的值也不能改。</p><p>（关于常量指针和指针常量什么的，有时间在专门开辟一章来说明const这个东东吧，也是很有讲头的一个东东。。。）</p><p>函数指针一般用来干什么呢？<strong>函数指针最常用的场合就是回调函数。</strong>回调函数，顾名思义，就是某个函数会在适当的时候被别人调用。当期望你调用的函数能够使用你的某些方式去操作的时候，回调函数就很有用，比如，你期望某个排序函数在比较的时候，能够使用你定义的比较方法去比较。</p><p>有过较深入的C编程经验的人应该都接触过。C的标准库中就有使用，例如在strlib.h头文件的qsort函数，它的原型为：</p><p>void qsort(void*__base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void*));</p><p>其中int(*_compar)(const void *, const void *)就是回调函数，这个函数用于qsort函数用于数据的比较。下面，我会举一个例子，来描述qsort函数的工作原理。</p><p>一般，我们使用下面这样的方式来定义函数指针：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre> typedef int(*compare)(const void *x, const void *y);</pre><p><br>这个时候，compare就是参数为const void *, const void *类型，返回值是int类型的函数。例如：</p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d61e04771cb9463dae763649bf2cf96c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5bbc1191f8224351b033f2dde51e565a><p class=pgc-img-caption></p></div><p>用typedef来定义的好处，就是可以使用一个简短的名称来表示一种类型，而不需要总是使用很长的代码来，这样不仅使得代码更加简洁易读，更是避免了代码敲写容易出错的问题。<strong>强烈推荐各位在定义结构体，指针（尤其是函数指针）等比较复杂的结构时，使用typedef来定义。</strong></p><p>每一个函数本身也是一种程序数据，一个函数包含了多条执行语句，它被编译后，实质上是多条机器指令的合集。<br>在程序载入到内存后，函数的机器指令存放在一个特定的逻辑区域：代码区。<br>既然是存放在内存中，那么函数也是有自己的指针的。</p><p>C语言中，函数名作为右值时，就是这个函数的指针。</p><pre>void echo(const char *msg){ printf("%s",msg);}int main(void){ void(*p)(const char*) = echo; //函数指针变量指向echo这个函数 p("Hello "); //通过函数的指针p调用函数，等价于echo("Hello ") echo("World"); return 0;}</pre><p><br><strong>const和指针</strong><br>const到底修饰谁？谁才是不变的？</p><p>如果const 后面是一个类型，则跳过最近的原子类型，修饰后面的数据。<br>（原子类型是不可再分割的类型，如int, short , char，以及typedef包装后的类型）</p><p>如果const后面就是一个数据，则直接修饰这个数据。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>int main(){ int a = 1; int const *p1 = &amp;a; //const后面是*p1，实质是数据a，则修饰*p1，通过p1不能修改a的值 const int*p2 = &amp;a; //const后面是int类型，则跳过int ，修饰*p2， 效果同上 int* const p3 = NULL; //const后面是数据p3。也就是指针p3本身是const . const int* const p4 = &amp;a; // 通过p4不能改变a 的值，同时p4本身也是 const int const* const p5 = &amp;a; //效果同上 return 0;} typedef int* pint_t; //将 int* 类型 包装为 pint_t,则pint_t 现在是一个完整的原子类型int main(){ int a = 1; const pint_t p1 = &amp;a; //同样，const跳过类型pint_t，修饰p1，指针p1本身是const pint_t const p2 = &amp;a; //const 直接修饰p，同上 return 0;}</pre><pre></pre><p><strong>深拷贝和浅拷贝</strong></p><p>如果2个程序单元（例如2个函数）是通过拷贝他们所共享的数据的指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。<br>如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互不受影响，则叫做深拷贝。</p><p></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6f18aa0da264dc8ac0c50f0d2900e10><p class=pgc-img-caption></p></div><p><strong>附加知识</strong></p><p>指针和引用这个2个名词的区别。他们本质上来说是同样的东西。<br>指针常用在C语言中，而引用，则用于诸如Java，C#等 在语言层面封装了对指针的直接操作的编程语言中。</p><p>大端模式和小端模式</p><p>1) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。个人PC常用，Intel X86处理器是小端模式。</p><p>2) B i g-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</p><p>采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。<br>有些机器同时支持大端和小端模式,通过配置来设定实际的端模式。</p><p>假如 short类型占用2个字节，且存储的地址为0x30。</p><p>short a = 1;</p><p>如下图：</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0abba064faaf407e9fd0bd9c5f6fbd71><p class=pgc-img-caption></p></div><pre>//测试机器使用的是否为小端模式。是，则返回true，否则返回false//这个方法判别的依据就是：C语言中一个对象的地址就是这个对象占用的字节中，地址值最小的那个字节的地址。bool isSmallIndain(){ unsigned int val = 'A'; unsigned char* p = (unsigned char*)&amp;val; //C/C++：对于多字节数据，取地址是取的数据对象的第一个字节的地址，也就是数据的低地址 return *p == 'A';}</pre><p><br></p><p>相关推荐</p><p><br></p><div class=pgc-img><img alt=C语言指针难吗？纸老虎而已，纯干货讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ec4b1eeb81f419a8bd3a3a96ce88005><p class=pgc-img-caption></p></div><p>《C语言深度解剖（第3版）》由作者结合自身多年嵌入式C语言开发经验和平时讲解C语言的心得体会整理而成，其中有很多作者独特的见解或看法。由于并不是从头到尾讲解C语言的基础知识，所以该书并不适用于C语言零基础的读者，其内容要比一般的C语言图书深得多、细致得多，其中有很多问题是各大公司的面试或笔试题。第3版中新增加了部分C语言知识点的内容。</p><p>《C语言深度解剖（第3版）》适合广大计算机系学生、初级程序员参考学习，也适合计算机系教师、中高级程序员参考使用。</p><p><strong>作者简介</strong></p><p>陈正冲，湖南沅江人，毕业于中国科学技术大学。具有丰富的嵌入式软件开发与管理经验，对于软件工程方法论和研发管理有深刻理解。每年都多次举行软件工程技术和研发管理方面培训，讲课深入、透彻、幽默，深受各方好评。目前主要从事研发管理工作。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'语言','指针','纯干货'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>