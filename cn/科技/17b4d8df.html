<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>HashMap数据结构与工作原理源码分析 | 极客快訊</title><meta property="og:title" content="HashMap数据结构与工作原理源码分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8ea640e8042c44c48174b9797067ede3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/17b4d8df.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b4d8df.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="HashMap数据结构与工作原理源码分析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/17b4d8df.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>HashMap数据结构与工作原理源码分析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><ul><li>HashMap的数据结构</li><li>HashMap的put 和get 方法源码分析</li><li>HashMap的重新哈希的机制</li><li>JDK1.8 之后为什么要调整HashMap的数据结构</li></ul><h2 class=pgc-h-arrow-right>HashMap的数据结构</h2><p>在编程领域，当涉及到数据存储，都离不开数据结构，HashMap 作为K,V形式存储的数据结构，通过看它的源码，我们不难发现，它是通过数组和链表来实现，在JDK1.8 之后假如加入红黑树组合，所以现在HashMap 的数据结构是数据+链表+红黑树</p><p>HashMap实际是一种“数组+链表”数据结构。在put操作中，通过内部定义算法寻止找到数组下标，将数据直接放入此数组元素中，若通过算法得到的该数组元素已经有了元素（俗称hash冲突，链表结构出现的实际意义也就是为了解决hash冲突的问题）。将会把这个数组元素上的链表进行遍历，将新的数据放到链表末尾</p><p>为了验证数据结构的正确性，接下来我们将通过源码分析来验证</p><p></p><div class=pgc-img><img alt=HashMap数据结构与工作原理源码分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ea640e8042c44c48174b9797067ede3><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=HashMap数据结构与工作原理源码分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c24e9453c2474bf8afd3cca886a20708><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=HashMap数据结构与工作原理源码分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/522cc0efd1634b918a6ae0110311b8eb><p class=pgc-img-caption></p></div><p>我们可以看到有Node元素的数据，同时node是一个链式结构</p><p><strong>HashMap 的初始化方式有三种</strong></p><pre><code>HashMap();//构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。HashMap(int initialCapacity);//构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMapHashMap(int initialCapacity, float loadFactor);//构造一个带指定初始容量和加载因子的空 HashMapHashMap(Map&lt;? extendsK,? extendsV&gt; m); //构造一个映射关系与指定 Map 相同的 HashMap</code></pre><h2 class=pgc-h-arrow-right>HashMap 的put 和get 方法源码分析</h2><p><br></p><p><strong>put 方法</strong></p><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent  该参数表示是否覆盖原来的值  * @param evict  这里没有实际意义,LinkHashMap尾部插入才有意义 . * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // //定义变量tab是将要操作的Node数组引用，p表示tab上的某Node节点，n为tab的长度，i为tab的下标    if ((tab = table) == null || (n = tab.length) == 0)  //判断当table为null或者tab的长度为0时，即table尚未初始化，此时通过resize()方法得到初始化的table        n = (tab = resize()).length;     if ((p = tab[i = (n - 1) &amp; hash]) == null)    //此处通过（n - 1） &amp; hash 计算出的值作为tab的下标i，并另p表示tab[i]，也就是该链表第一个节点的位置。并判断p是否为null。        tab[i] = newNode(hash, key, value, null); //当p为null时，表明tab[i]上没有任何元素，那么接下来就new第一个Node节点，调用newNode方法返回新节点赋值给tab[i]。    else {//p不为null的情况，有三种情况：p为链表节点；p为红黑树节点；p是链表节点但长度为临界长度TREEIFY_THRESHOLD，再插入任何元素就要变成红黑树了        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))//HashMap中判断key相同的条件是key的hash相同，并且符合equals方法。这里判断了p.key是否和插入的key相等，如果相等，则将p的引用赋给e, HashMap中已经存在了key，于是插入操作就不需要了，只要把原来的value覆盖就可以了            e = p;//这里为什么要把p赋值给e，而不是直接覆盖原值呢？答案很简单，现在我们只判断了第一个节点，后面还可能出现key相同，所以需要在最后一并处理。        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);       //现在开始了第一种情况，p是红黑树节点，那么肯定插入后仍然是红黑树节点，所以我们直接强制转型p后调用TreeNode.putTreeVal方法，返回的引用赋给e, 这里怎么不遍历tree看看有没有key相同的节点呢？其实，putTreeVal内部进行了遍历，存在相同hash时返回被覆盖的TreeNode，否则返回null。 else { //接下里就是p为链表节点的情形，也就是上述说的另外两类情况：插入后还是链表/插入后转红黑树。另外，上行转型代码也说明了TreeNode是Node的一个子类。            for (int binCount = 0; ; ++binCount) {//我们需要一个计数器来计算当前链表的元素个数，并遍历链表，binCount就是这个计数器                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);//遍历过程中当发现p.next为null时，说明链表到头了，直接在p的后面插入新的链表节点，即把新节点的引用赋给p.next，插入操作就完成了。注意此时e赋给p。最后一个参数为新节点的next，这里传入null，保证了新节点继续为该链表的末端                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);  //插入成功后，要判断是否需要转换为红黑树，因为插入后链表长度加1，而binCount并不包含新节点，所以判断时要将临界阈值减1。当新长度满足转换条件时，调用treeifyBin方法，将该链表转换为红黑树。                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;//在遍历链表的过程中，我之前提到了，有可能遍历到与插入的key相同的节点，此时只要将这个节点引用赋值给e，最后通过e去把新的value覆盖掉就可以了。老样子判断当前遍历的节点的key是否相同。                p = e;            }        }        if (e != null) { // existing mapping for key// 针对已经存在key的情况做处理            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;//前面提到，onlyIfAbsent表示存在key相同时不做覆盖处理，这里作为判断条件，可以看出当onlyIfAbsent为false或者oldValue为null时，进行覆盖操作。 //覆盖操作，将原节点e上的value设置为插入的新value。            afterNodeAccess(e); 　//这个函数在hashmap中没有任何操作，是个空函数，他存在主要是为了linkedHashMap的一些后续处理工作。            return oldValue;        }    }    ++modCount; 　 //收尾工作，值得一提的是，对key相同而覆盖oldValue的情况，在前面已经return，不会执行这里，所以那一类情况不算数据结构变化，并不改变modCount值。    if (++size &gt; threshold)// 同理，覆盖oldValue时显然没有新元素添加，除此之外都新增了一个元素，这里++size并与threshold判断是否达到了扩容标准        resize();//当HashMap中存在的node节点大于threshold时，hashmap进行扩容。    afterNodeInsertion(evict); 　//这里与前面的afterNodeAccess同理，是用于linkedHashMap的尾部操作，HashMap中并无实际意义。    return null;}</code></pre><p></p><p class=pgc-end-literature>HashMap根据 (n - 1) & hash 求出了元素在node数组的下标，主要分三个阶段：计算hashcode、高位运算和取模运算。</p><p class=pgc-end-literature>key.hashCode()计算出key的哈希值，然后将哈希值h右移16位，再与原来的h做异或^运算。正好是int类型32位对半。将高16位和低16位的信息"融合"到一起，也称为"扰动函数"。这样才能保证hash值所有位的数值特征都保存下来而没有遗漏，从而使映射结果尽可能的松散。</p><p class=pgc-end-literature>取模运算，HashMap数组下标的计算方式 tab[(n - 1) & hash]，n 是数组的长度。其实该算法的结果和模运算的结果是相同的。对CPU来说，位运算是最快的动作，除法和求余数（模运算）是最慢的动作。当n是2的N次幂的时候。Hash%n == （n-1）& hash。这就是为什么HashMap 的容量建议是 2的幂次方。hash 算法的目的是为了让hash值均匀的分布在数组中，当容量只不是2的幂次方时，会发现，有时候会形成长链，影响读写的性能</p><p class=pgc-end-literature>如果Map中已有数据的容量达到了初始容量的 75%，那么散列表就会扩容，而扩容将会重新将所有的数据重新散列，性能损失严重，所以，我们可以必须要大于我们预计数据量的 1.34 倍。</p><p><strong>get 方法分析</strong></p><p>讲完put方法，get方法其实很容易理解</p><pre><code>public V get(Object key) {    Node&lt;K,V&gt; e;    return (e = getNode(hash(key), key)) == null ? null : e.value;}/** * Implements Map.get and related methods * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {	//根据输入的hash值，可以直接计算出对应的下标（n - 1）&amp; hash        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))//判断第一个存在的节点的key是否和查询的key相等。如果相等，直接返回该节点。            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)//当这个table节点上存储的是红黑树结构时，在根节点first上调用getTreeNode方法，在内部遍历红黑树节点，查看是否有匹配的TreeNode                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))    //当这个table节点上存储的是链表结构时，同样的方式去判断key是否相同。  		return e;            } while ((e = e.next) != null);        }    }    return null;}</code></pre><p><br></p><h2 class=pgc-h-arrow-right>HashedMap的重新扩容机制</h2><p>首先我们明白，resize重新扩容就是建立一个比原来更大的数组来存储。</p><p>直接上代码</p><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;// 上面的代码很简单，总结来说，1、当HashMap初始化时指定数据大小为16，阈值为16 * loadFactor（负载因子）   2、将数组的大小扩大为原来2倍，阈值设置为数组大小乘以 负载因子。    @SuppressWarnings({"rawtypes","unchecked"})     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {// 遍历原来的数组            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null; // 将oldTab[j]=null只是清除旧表的引用                if (e.next == null)		// 当前存储桶只有一个元素的时候，直接hash赋值到新的数组上即可                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)		// 如果该存储桶里面存的是红黑树, 则拆分树                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order		// 以下代码主要将一个链表拆为两个链表lo,hi                    Node&lt;K,V&gt; loHead = null, loTail = null;	// lo链表的头节点和尾节点                    Node&lt;K,V&gt; hiHead = null, hiTail = null;	//  hi链表的头节点和尾节点                    Node&lt;K,V&gt; next;                    do {// 遍历当前当前存储桶的链表                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) {	// (e.hash &amp; oldCap) == 0 作为链表拆为的条件，为什么以该条件作为链表拆分条件，下文再详解                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);	// 链表拆分之后，将lo链表赋给 newTab[j],将hi链表赋给newTab[j+oldCap], 到这里你应该会有三个疑惑，1、(e.hash &amp; oldCap) == 0为什么以这个条件作为链表拆分条件，2、lo，hi链表为什么分别以j 和 j+oldCap作为下标               if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}</code></pre><p>对于链表拆分，我们以下面这个图可能更好理解点</p><p><strong></strong></p><div class=pgc-img><img alt=HashMap数据结构与工作原理源码分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1923b2bcb56c4da6b80bd83068e46424><p class=pgc-img-caption></p></div><p><strong>(e.hash & oldCap) == 0 j 以及 j+oldCap</strong></p><ol start=1><li>oldCap一定是2的整数次幂, 这里假设是2^m</li><li>newCap是oldCap的两倍, 则会是2^(m+1)</li><li>hash对数组大小取模(n - 1) & hash 其实就是取hash的低m位</li></ol><p>(16-1) & hash 自然就是取hash值的低4位,我们假设它为 abcd.以此类推, 当我们将oldCap扩大两倍后, 新的index的位置就变成了 (32-1) & hash, 其实就是取 hash值的低5位. 那么对于同一个Node, 低5位的值无外乎下面两种情况。</p><pre><code>0abcd1abcd</code></pre><p>其中, 0abcd与原来的index值一致, 而1abcd = 0abcd + 10000 = 0abcd + oldCap故虽然数组大小扩大了一倍，但是同一个key在新旧table中对应的index却存在一定联系： 要么一致，要么相差一个 oldCap。</p><p>而新旧index是否一致就体现在hash值的第4位(我们把最低为称作第0位), 怎么拿到这一位的值呢, 只要:</p><pre><code>hash &amp; 0000 0000 0000 0000 0000 0000 0001 0000</code></pre><p>上式就等效于</p><pre><code>hash &amp; oldCap</code></pre><p><strong>故得出结论:</strong></p><p>如果 (e.hash & oldCap) == 0 则该节点在新表的下标位置与旧表一致都为 j<br>如果 (e.hash & oldCap) == 1 则该节点在新表的下标位置 j + oldCap</p><ol start=1><li>resize发生在table初始化, 或者table中的节点数超过threshold值的时候, threshold的值一般为负载因子乘以容量大小.</li><li>每次扩容都会新建一个table, 新建的table的大小为原大小的2倍.</li><li>扩容时,会将原table中的节点re-hash到新的table中, 但节点在新旧table中的位置存在一定联系: 要么下标相同, 要么相差一个oldCap(原table的大小).</li></ol><h2 class=pgc-h-arrow-right>JDK1.8 之后为什么要调整HashMap的数据结构</h2><p>红黑树调整Hashap的优点</p><ol start=1><li>· 添加时，当桶中链表个数超过 8 时会转换成红黑树；</li><li>删除、扩容时，如果桶中结构为红黑树，并且树中元素个数太少的话，会进行修剪或者直接还原成链表结构；</li><li>查找时即使哈希函数不优，大量元素集中在一个桶中，由于有红黑树结构，性能也不会差</li></ol><p>参考</p><p>https://segmentfault.com/a/1190000015812438</p><p>https://blog.csdn.net/hao134838/article/details/77653679</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'HashMap','数据','结构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>