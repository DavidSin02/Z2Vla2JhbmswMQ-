<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何在 Go 中写出高效的单元测试 | 极客快訊</title><meta property="og:title" content="如何在 Go 中写出高效的单元测试 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ed1aef2573fe45c582af69ef44638521"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/190ae162.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/190ae162.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/190ae162.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/190ae162.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/190ae162.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/190ae162.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/190ae162.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/190ae162.html><meta property="article:published_time" content="2020-11-14T20:59:18+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:18+08:00"><meta name=Keywords content><meta name=description content="如何在 Go 中写出高效的单元测试"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/190ae162.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何在 Go 中写出高效的单元测试</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="如何在 Go 中写出高效的单元测试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed1aef2573fe45c582af69ef44638521><p class=pgc-img-caption></p></div><p>本周在团队做了一次关于 Go 单元测试的分享，分享题目为《Testing in Go-how to write efficient unit test》。</p><h2 class=pgc-h-arrow-right>内容大纲</h2><ul><li>单元测试的重要性</li><li>Go 单元测试基础知识</li><li>表格测试和 HTTP 测试</li><li>其它测试框架</li><li>其它 Mock 库</li><li>与 Docker 集成</li></ul><h2 class=pgc-h-arrow-right>单测的重要性</h2><ul><li>能够尽早的发现 bug</li><li>方便 debugging</li><li>方便代码重构</li><li>提升代码质量</li><li>使整个过程敏捷</li></ul><p>讲这部分的目的是为了让团队达成共识---<strong>单测很重要，我们必须要做好单元测试</strong>。</p><p><br></p><h2 class=pgc-h-arrow-right>Go 单测基础知识</h2><h3 class=pgc-h-arrow-right>基本规则</h3><ul><li>通常我们的单元测试代码都放在以 <strong>_test.go</strong> 结尾的文件中，该文件一般和目标代码放在同一个 package 中。</li><li>测试的方法以为 <strong>Test</strong> 开头，并且拥有唯一一个 <strong>*Testing.T </strong>的参数<strong>。</strong></li></ul><h3 class=pgc-h-arrow-right>go test 使用</h3><ul><li>go test 测试当前包</li><li>go test some/pkg 测试一个特定的包</li><li>go test some/pkg/... 递归测试一个特定包下面的所有包</li><li>go test -v some/pkg -run ^TestSum$ 测试特定包下面的特定方法</li><li>go test -cover 查看单测覆盖率</li><li>go test -count=1 忽略缓存运行单测，注意如果以递归方式（./...）测试的时候，默认会使用 cache</li></ul><h3 class=pgc-h-arrow-right>表格测试</h3><ul><li>使用匿名结构体批量构建自己的测试 case</li><li>采用子测试的方式让测试输出更友好</li></ul><pre><code>func TestIsIPV4WithTable(t *testing.T) {	testCases := []struct {		IP    string		valid bool	}{		{"", false},		{"192.168.0", false},		{"192.168.x.1", false},		{"192.168.0.1.1", false},		{"127.0.0.1", true},		{"192.168.0.1", true},		{"255.255.255.255", true},		{"120.52.148.118", true},	}	for _, tc := range testCases {		t.Run(tc.IP, func(t *testing.T) {			if IsIPV4(tc.IP) != tc.valid {				t.Errorf("IsIPV4(%s) should be %v", tc.IP, tc.valid)			}		})	}}</code></pre><h3 class=pgc-h-arrow-right>HTTP 测试</h3><ul><li>使用 httptest.NewRecorder 来测试 HTTP Handler 而不需要真正进行 HTTP 监听</li><li>可以使用 errorReader 来提高测试覆盖率</li></ul><pre><code>type errorReader struct{}func (errorReader) Read(p []byte) (n int, err error) {	return 0, errors.New("mock body error")}func TestLoginHandler(t *testing.T) {	testCases := []struct {		Name string		Code int		Body interface{}	}{		{"ok", 200, `{"code":"a@example.com", "password":"password"}`},		{"read body error", 500, new(errorReader)},		{"invalid format", 400, `{"code":1, "password":"password"}`},		{"invalid code", 400, `{"code":"a@example.com1", "password":"password"}`},		{"invalid password", 400, `{"code":"a@example.com", "password":"password1"}`},	}	for _, tc := range testCases {		t.Run(tc.Name, func(t *testing.T) {			var body io.Reader			if stringBody, ok := tc.Body.(string); ok {				body = strings.NewReader(stringBody)			} else {				body = tc.Body.(io.Reader)			}			req := httptest.NewRequest("POST", "http://example.com/foo", body)			w := httptest.NewRecorder()			LoginHandler(w, req)			resp := w.Result()			if resp.StatusCode != tc.Code {				t.Errorf("response code is invalid, expect=%d but got=%d",					tc.Code, resp.StatusCode)			}		})	}}</code></pre><p><br></p><p><strong>Go 单测基础知识</strong>这部分的内容主要是向大家讲解 Go 官方单测库 testing 以及命令行 go test 的使用。</p><p><br></p><p>可以看到官方自带的库已经足够好用， 不仅带有 subtest 还有 httptest 的相关内容，对于中小型的项目而言使用官方的 testing 库足够。</p><p><br></p><h2 class=pgc-h-arrow-right>其它测试框架</h2><p><br></p><p>虽然官方 testing 库足够优秀，但在一些较大项目上，它还是有很多需要完善的地方，如：</p><ul><li>断言不够友好，需要通过大量 if</li><li>持续集成不够，每次都要手动跑测试</li><li>BDD 无支持</li><li>测试 case 的文档自动化不够</li></ul><p>所以我这里介绍了三种测试框架，针对以上几点都有一定的改进。</p><p><br></p><h3 class=pgc-h-arrow-right>Testify</h3><ul><li>和 go test 无缝集成，直接使用该命令运行</li><li>支持断言，写法更简便</li><li>支持 mocking</li><li>https://github.com/stretchr/testify （10k+ 关注）</li></ul><pre><code>func TestIsIPV4WithTestify(t *testing.T) {	assertion := assert.New(t)	assertion.False(IsIPV4(""))	assertion.False(IsIPV4("192.168.0"))	assertion.False(IsIPV4("192.168.x.1"))	assertion.False(IsIPV4("192.168.0.1.1"))	assertion.True(IsIPV4("127.0.0.1"))	assertion.True(IsIPV4("192.168.0.1"))	assertion.True(IsIPV4("255.255.255.255"))	assertion.True(IsIPV4("120.52.148.118"))}</code></pre><p><br></p><h3 class=pgc-h-arrow-right>GoConvey</h3><ul><li>https://github.com/smartystreets/goconvey （5k+ 关注）</li><li>支持 BDD</li><li>能够使用 go test 来运行测试</li><li>能够通过浏览器查看测试结果</li><li>自动加载更新</li></ul><pre><code>func TestIsIPV4WithGoconvey(t *testing.T) {	Convey("ip.IsIPV4()", t, func() {		Convey("should be invalid", func() {			Convey("empty string", func() {				So(IsIPV4(""), ShouldEqual, false)			})			Convey("with less length", func() {				So(IsIPV4("192.0.1"), ShouldEqual, false)			})			Convey("with more length", func() {				So(IsIPV4("192.168.1.0.1"), ShouldEqual, false)			})			Convey("with invalid character", func() {				So(IsIPV4("192.168.x.1"), ShouldEqual, false)			})		})		Convey("should be valid", func() {			Convey("loopback address", func() {				So(IsIPV4("127.0.0.1"), ShouldEqual, true)			})			Convey("extranet address", func() {				So(IsIPV4("120.52.148.118"), ShouldEqual, true)			})		})	})}</code></pre><p><br></p><h3 class=pgc-h-arrow-right>GinkGo</h3><ul><li>https://github.com/onsi/ginkgo （4K+ 关注）</li><li>也是一个 BDD 测试框架</li><li>能够使用 go test</li><li>有自己的断言库 Gomega</li><li>也支持自动加载更新</li></ul><pre><code>var _ = Describe("Ip", func() {	Describe("IsIPV4()", func() {		// fore content level prepare		BeforeEach(func() {			// prepare data before every case		})		AfterEach(func() {			// clear data after every case		})		Context("should be invalid", func() {			It("empty string", func() {				Expect(IsIPV4("")).To(Equal(false))			})			It("with less length", func() {				Expect(IsIPV4("192.0.1")).To(Equal(false))			})			It("with more length", func() {				Expect(IsIPV4("192.168.1.0.1")).To(Equal(false))			})			It("with invalid character", func() {				Expect(IsIPV4("192.168.x.1")).To(Equal(false))			})		})		Context("should be valid", func() {			It("loopback address", func() {				Expect(IsIPV4("127.0.0.1")).To(Equal(true))			})			It("extranet address", func() {				Expect(IsIPV4("120.52.148.118")).To(Equal(true))			})		})	})})func TestGinkgotesting(t *testing.T) {	RegisterFailHandler(Fail)	RunSpecs(t, "Ginkgotesting Suite")}</code></pre><h2 class=pgc-h-arrow-right>其它 Mock 库</h2><p><br></p><p>到目前为止我们已经掌握了 Go 官方库 testing 和其它常见的测试框架的用法，能够方便我们编写和运行常规的单元测试。</p><p><br></p><p>但我们的系统往往比较复杂，依赖很多服务和基础组建，比如一个 Web 服务往往依赖 MySQL、Redis 等，这里主要讲解采用模拟（mock-屏蔽掉这些服务的实际调用）的方式来测试我们的代码逻辑。</p><p><br></p><h3 class=pgc-h-arrow-right>GoMock</h3><ul><li>https://github.com/golang/mock （4k+ 关注）</li><li>golang 官方推出的 mock 库</li><li>针对接口进行 mock</li><li>支持 mock 和 stub</li><li>采用 mockgen 生成代码</li></ul><pre><code>func TestPostIndexWithGoMock(t *testing.T) {	ctrl := gomock.NewController(t)	defer ctrl.Finish()	Convey("PostController.Index", t, func() {		Convey("should be 200", func() {			posts := []*post.PostModel{				{1, "title", "body"},				{2, "title2", "body2"},			}			m := NewMockPostService(ctrl)			m.				EXPECT().				List().				Return(posts, nil)			handler := post.PostController{				PostService: m,			}			req := httptest.NewRequest("GET", "http://example.com/foo", nil)			w := httptest.NewRecorder()			handler.Index(w, req)			So(w.Result().StatusCode, ShouldEqual, 200)		})		Convey("should be 500", func() {			m := NewMockPostService(ctrl)			m.				EXPECT().				List().				Return(nil, errors.New("list post with error"))			handler := post.PostController{				PostService: m,			}			req := httptest.NewRequest("GET", "http://example.com/foo", nil)			w := httptest.NewRecorder()			handler.Index(w, req)			So(w.Result().StatusCode, ShouldEqual, 500)		})	})}</code></pre><p><br></p><h3 class=pgc-h-arrow-right>HTTPMock</h3><ul><li>https://github.com/jarcoal/httpmock （1K 关注）</li><li>针对 HTTP Request 来进行 mocking</li><li>能够自定义任意的 HTTP Response</li><li>截止 HTTP Request 直接返回自定义的 Response</li><li>给予正则匹配</li></ul><pre><code>func TestPostClientFetch(t *testing.T) {	httpmock.Activate()	defer httpmock.DeactivateAndReset()	postFetchURL := "https://api.mybiz.com/posts"	client := &amp;PostClient{		Client: &amp;http.Client{			Transport: httpmock.DefaultTransport,		},	}	Convey("PostClient.Fetch", t, func() {		Convey("without error", func() {			httpmock.RegisterResponder("GET", postFetchURL,				httpmock.NewStringResponder(200, `[{"id": 1, "title": "title", "body": "body"}]`))			items, err := client.Fetch(postFetchURL, 1)			So(len(items), ShouldEqual, 1)			So(err, ShouldEqual, nil)		})		Convey("with error", func() {			Convey("response data invalid", func() {				httpmock.RegisterResponder("GET", postFetchURL,					httpmock.NewStringResponder(200, `[{"id": "213"}]`))				items, err := client.Fetch(postFetchURL, 1)				So(items, ShouldBeEmpty)				So(err, ShouldNotBeNil)			})			Convey("without error", func() {				httpmock.RegisterResponder("GET", postFetchURL,					httpmock.NewStringResponder(500, `some error`))				items, err := client.Fetch(postFetchURL, 1)				So(items, ShouldBeEmpty)				So(err.Error(), ShouldContainSubstring, "some error")			})		})	})}</code></pre><p><br></p><h3 class=pgc-h-arrow-right>SQLMock</h3><ul><li>https://github.com/DATA-DOG/go-sqlmock （2k+ 关注）</li><li>针对 database/sql 的所有接口进行 mock</li><li>基于正则表达式进行匹配</li><li>支持 查询、更新、事务等mock</li></ul><pre><code>func TestPostDaoList(t *testing.T) {	db, mock, err := sqlmock.New()	if err != nil {		t.Fatalf("an error '%s' was not expected when opening a stub database connection", err)	}	defer db.Close()	Convey("PostDao.Fetch", t, func() {		dao := post.NewPostDao(db)		Convey("should be successful", func() {			rows := sqlmock.NewRows([]string{"id", "title", "body"}).				AddRow(1, "post 1", "hello").				AddRow(2, "post 2", "world")			mock.ExpectQuery("^SELECT (.+) FROM posts$").				WithArgs().WillReturnRows(rows)			items, err := dao.List()			So(items, ShouldHaveLength, 2)			So(err, ShouldBeNil)		})		Convey("should be failed", func() {			mock.ExpectQuery("^SELECT (.+) FROM posts$").				WillReturnError(fmt.Errorf("list post error"))			items, err := dao.List()			So(items, ShouldBeNil)			So(err.Error(), ShouldContainSubstring, "list post error")		})	})}</code></pre><h2 class=pgc-h-arrow-right>与 Docker 集成</h2><p>虽然我们可以采用 Mock 的方式屏蔽掉某些服务，但是还是存在某些服务比较复杂，很难 mock（如 MongoDB） ，而且有时我们确实想和依赖的服务做某些集成测试。</p><p><br></p><p>此时我们可以用 Docker 来快速构建我们的测试依赖环境，并且用完即释放、非常高效，下面就是一个包含 MongoDB 的 Dockerfile：</p><pre><code>FROM ubuntu:16.04RUN apt-get update &amp;&amp; apt-get install -y libssl1.0.0 libssl-dev gccRUN mkdir -p /data/db /opt/go/ /opt/gopathCOPY mongodb/bin/* /usr/local/bin/ADD go /opt/goRUN cp /opt/go/bin/* /usr/local/bin/ENV GOROOT=/opt/go GOPATH=/opt/gopathWORKDIR /wsCMD mongod --fork --logpath /var/log/mongodb.log &amp;&amp; GOPROXY=off go test -mod=vendor ./...</code></pre><h2 class=pgc-h-arrow-right>总结</h2><p>本次分享主要从单元测试的重要性入手，依次讲解了官方库 testing、社区测试框架（Testify、GoConvey、GinkGo）、Mock 相关技术、Docker 集成的内容，总结如下：</p><ul><li>单元测试应该是一个团队共识</li><li>单元测试并不难</li><li>使用 Mock 能够使我们单元测试高效</li><li>应该面向接口编程，方便做 mock （gomock）</li><li>官方库足够优秀，包含表格测试、http 测试相关内容</li><li>社区有很多优秀测试框架，能够让我们更好的实践 BDD或者TDD</li><li>Docker 能够适用于更复杂的测试场景</li></ul><h2 class=pgc-h-arrow-right>参考</h2><ul><li>https://github.com/songjiayang/gotesting</li><li>https://golang.org/pkg/testing</li><li>https://golang.org/pkg/cmd/go/internal/test</li><li>https://golang.org/pkg/testing/#hdr-Subtests_and_Sub_benchmarks</li><li>https://golang.org/pkg/net/http/httptest</li><li>https://github.com/stretchr/testify</li><li>https://github.com/onsi/ginkgo</li><li>https://en.wikipedia.org/wiki/Behavior-driven_development</li><li>https://github.com/onsi/gomega</li><li>https://github.com/smartystreets/goconvey</li><li>https://github.com/golang/mock</li><li>https://github.com/jarcoal/httpmock</li><li>https://github.com/DATA-DOG/go-sqlmock</li></ul><p>作者：_why先生</p><p>原文链接:【<strong>http://dwz.date/b2v3</strong>】。文章转载请联系作者</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Go','中写','单元'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>