<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 后台开发面试题分享八 | 极客快訊</title><meta property="og:title" content="Java 后台开发面试题分享八 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1bab896f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1bab896f.html><meta property="article:published_time" content="2020-11-14T21:05:50+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:50+08:00"><meta name=Keywords content><meta name=description content="Java 后台开发面试题分享八"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1bab896f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 后台开发面试题分享八</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>请问 select(1) 和 select(*) 有什么区别</strong></h1><ul><li><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">selelct 常量 from ...</span> 对应所有行，返回的永远只有一个值，即<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">常量</span>。所以正常只会用来判断是否有还是没有，比如 exists 子句。</li><li><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select * from …</span> 是返回所有行的所有列。 性能上的差异，关键看 from 和 where 子句，比如说 where 条件中可以使用索引，那显然 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select 1 from …</span> 的性能比 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select * from …</span> 好。</li></ul><hr><h1 class=pgc-h-arrow-right><strong>说一下 count(1) 和 count(*) 的区别</strong></h1><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(*)</span> 包括了所有的列，相当于行数，在统计结果的时候，不会忽略为 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">NULL</span> 的值。</p><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(1)</span> 包括了忽略所有列，用 1 代表代码行，在统计结果的时候，不会忽略为 NULL 的值。</p><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(列名)</span> 只包括列名那一列，在统计结果的时候，会忽略列值为空的计数，即某个字段值为 NULL 时，不统计。这里的空不是指空字符串或者 0，而是表示 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">null</span>。</p><p>执行效率上：</p><ul><li>列名为主键，<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(列名)</span> 会比 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(1)</span> 快；</li><li>列名不为主键，<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(1)</span> 会比 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(列名)</span> 快；</li><li>如果表多个列并且没有主键，则 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(1)</span> 的执行效率优于 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">count(*)</span>；</li><li>如果有主键，则 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select count(主键)</span> 的执行效率是最优的；</li><li>如果表只有一个字段，则 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select count(*)</span> 最优。</li></ul><hr><h1 class=pgc-h-arrow-right><strong>说一下 B-Tree 索引</strong></h1><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 能加快数据的访问速度，因为存储引擎不再需要进行全表扫描来获取数据，数据分布在各个节点之中。</p><p>在 MySQL 中不同存储引擎使用 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 索引的方式不尽相同，同样会影响数据库的性能，比如 MyISAM 引擎使用一种“前缀压缩”的技术，这样可以索引更小，并且 MyISAM 索引是通过索引到具体物理地址找到数据行的。而 InnoDB 引擎则在索引中保留了未压缩的值，InnoDB 是通过主键值来索引到数据行的。这两种方式各有优缺点。</p><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 索引之所以能够加快数据访问速度，主要是因为存储引擎在访问要查找的数据时不需要进行全表扫描。它是从 B-Tree 的根节点开始的，根节点的槽保存着指向子节点的指针，存储引擎会跟随这些指针，然后通过查看节点页中的值从而找到正确指针，这个指针定义了其子节点中值得上限和下限。最终结果为存储引擎没有查找到期望的值，或者成功到达叶子页。</p><h1 class=pgc-h-arrow-right><strong>查询类型可以使用 B-Tree 索引</strong></h1><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 索引在根据完整键值、键范围或者键前缀查找时性能比较好，这些只有在使用索引的最左前缀时有效（最左索引可能是 MySQL 的特列）。下面这几种类型查询使用前面说的索引是很有用的：</p><p>1、匹配全值，一个全键值匹配索引中所有列的指定值，也就是根据索引列的值来匹配。</p><p>2、匹配最左前缀，只根据索引最左列值查找。</p><p>3、匹配某一列的前缀，即根据索引列的值的前缀查找，这种情况只能使用到索引第一列的情景。</p><p>4、匹配值区间，即根据索引某一列值范围查找，也只能是索引列第一列。</p><p>5、匹配一部分精确值，一部分范围值，比如我索引有两列 A、B，可以根据 A 列的精确值，B 列的范围值进行查询。</p><p>6、仅索引查询。<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 索引支持仅索引查询，这种情况只会访问本身，而不会访问行存储。</p><p>因为树的节点是有序排列的，因此可以用来根据（查找值）查找和 order by 查询（有序方式查找值）。通常来说，如果一个 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 可以通过某种特定方式查找某一行，它也可以按相同条件对行进行排序。所以索引对满足上面列出查找类型的 order by 子句很有帮助。</p><h1 class=pgc-h-arrow-right><strong>B-Tree 的一些限制</strong></h1><p>1、不满足最左索引的查找是没有用的，比如索引是 A 、B 列，但是查询条件是 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">where B = "b"</span>。</p><p>2、不能跳过索引中的列，比如索引还是 A 、B 列，但是查询条件是 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">A = "a" and C ="c"</span> 这种明显是不行的。</p><p>3、存储引擎无法对第一个范围查找右侧的列访问进行优化。比如索引列是 A、B、C 三列，而查询是 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select * from table where A = "a" and B like "b" and C = "c"</span>，这种情况下索引访问只会访问前两列，因为 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">like</span> 也是一个范围查询。</p><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 索引作为最常用的索引类型，它通过以有序方式对数据进行排序运行，这样 MySQL 就可以利用诸如 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">order by</span>、<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">group by</span> 这样查询语句。因为数据是已经排好序的，<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">B-Tree</span> 索引可以将数据关联存储在一起。最后就是，索引本身实际上保存了数据值副本，因此某些情况下只通过索引就能满足查询结果。</p><hr><h1 class=pgc-h-arrow-right><strong>JDBC API 的 PreparedStatement 相比 Statement 的好处</strong></h1><p>大多数时候都使用 PreparedStatement 代替 Statement。</p><p>1、PreparedStatement 是预编译的，比 Statement 速度快；</p><p>2、PreparedStatement 代码的可读性和可维护性更好。虽然用 PreparedStatement 来代替 Statement 会使代码多出几行，但这样的代码无论从可读性还是可维护性上来说，都比直接用 Statement 的代码高很多档次：</p><pre><code>// Statementstmt.executeUpdate(&#34;insert into tb_name (col1,col2,col2,col4) values (&#39;&#34;+var1+&#34;&#39;,&#39;&#34;+var2+&#34;&#39;,&#34;+var3+&#34;,&#39;&#34;+var4+&#34;&#39;)&#34;);// preparedStatementperstmt = con.prepareStatement(&#34;insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)&#34;);perstmt.setString(1,var1);perstmt.setString(2,var2);perstmt.setString(3,var3);perstmt.setString(4,var4);perstmt.executeUpdate();</code></pre><p>3、安全性。PreparedStatement 可以防止 SQL 注入攻击，而 Statement 却不能。比如说：</p><pre><code>String sql = &#34;select * from tb_name where name= &#39;&#34;+varname+&#34;&#39; and passwd=&#39;&#34;+varpasswd+&#34;&#39;&#34;;// 如果把 [&#39; or &#39;1&#39; = &#39;1] 作为 varpasswd 传入进来，用户名 xx，看看会成为什么?select * from tb_name where name = &#39;xx&#39; and passwd = &#39;&#39; or &#39;1&#39; = &#39;1&#39;;// 因为 &#39;1&#39;=&#39;1&#39; 肯定成立，所以可以任何通过验证，更有甚者：// 把 [&#39;;drop table tb_name;] 作为 varpasswd 传入进来，则：select * from tb_name where name = &#39;随意&#39; and passwd = &#39;&#39;;drop table tb_name;// 有些数据库是不会成功的，但也有很多数据库就可以使这些语句得到执行。// 而如果使用预编译语句传入的任何内容就不会和原来的语句发生任何匹配的关系，// 只要全使用预编译语句就用不着对传入的数据做任何过虑。// 而如果使用普通的 statement，有可能要对 drop 等做费尽心机的判断和过虑。</code></pre><hr><h1 class=pgc-h-arrow-right><strong>JDBC API 中的 execute，executeQuery，executeUpdate 的区别是什么？</strong></h1><p>Statement 的 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">execute(String query)</span> 方法用来执行任意的 SQL 查询，如果查询的结果是一个 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">ResultSet</span>，这个方法就返回 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">true</span>。如果结果不是 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">ResultSet</span>，比如 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">insert</span> 或者 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">update</span> 查询，它就会返回 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">false</span>。可以通过它的 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">getResultSet</span> 方法来获取 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">ResultSet</span>，或者通过 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">getUpdateCount()</span> 方法来获取更新的记录条数。</p><p>Statement 的 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">executeQuery(String query)</span> 接口用来执行 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">select</span> 查询，并且返回 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">ResultSet</span>。即使查询不到记录返回的 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">ResultSet</span> 也不会为 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">null</span>。通常使用 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">executeQuery</span> 来执行查询语句，这样的话如果传进来的是 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">insert</span> 或者 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">update</span> 语句的话，它会抛出错误信息为 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">executeQuery method can not be used for update</span> 的 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">java.util.SQLException</span>。</p><p>Statement 的 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">executeUpdate(String query)</span> 方法用来执行 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">insert</span> 或者 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">update/delete</span> DML 语句，或者什么也不返回 DDL 语句。返回值是 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">int</span> 类型，如果是 DML 语句的话，它就是更新的条数，如果是 DDL 的话，就返回 0。</p><p>只有不确定是什么语句的时候才应该使用 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">execute()</span> 方法，否则应该使用 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">executeQuery</span> 或者 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">executeUpdate</span> 方法。</p><hr><h1 class=pgc-h-arrow-right><strong>JavaScript 中的 `==` 和 `===` 的不同</strong></h1><p><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">==</span> 只比较值，<span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">===</span> 比较值和数据类型。</p><hr><h1 class=pgc-h-arrow-right><strong>AJAX 的优缺点都有什么？</strong></h1><p>优点：</p><p>1）页面无刷新，用户的体验非常好。</p><p>2）使用异步方式与服务器通信，具有更加迅速的响应能力。</p><p>3）可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，AJAX 的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。</p><p>4）基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。</p><p>缺点：</p><p>1）不支持浏览器 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">back</span> 按钮。</p><p>2）安全问题，AJAX 暴露了与服务器交互的细节。</p><p>3）对搜索引擎的支持比较弱。</p><p>4）破坏了程序的异常机制。</p><p>5）不容易调试。</p><hr><h1 class=pgc-h-arrow-right><strong>请简要说明 `String.valueOf` 和 `(String)` 以及 `toString` 的区别</strong></h1><ul><li><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">(String)</span> 强制类型转换，要注意的是类型必须能转成 String 类型。</li><li><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">toString</span> 字符串类型转换，要注意，必须保证 object 不是 null 值，否则将抛出 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">NullPointerException</span> 异常。</li><li><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">String.valueof()</span> 当转入的变量为 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">null</span> 时，不会报错。</li></ul><hr><h1 class=pgc-h-arrow-right><strong>反射机制的优缺点？</strong></h1><p>静态编译 - 在编译时确定类型、绑定对象即通过。</p><p>动态编译 - 在运行时确定类型、绑定对象。动态编译最大限度发挥了 Java 的灵活性，体现了多态的应用，有以降低类之间的藕合性。</p><p><strong>优点：</strong> 可以实现动态创建对象和编译，体现出很大的灵活性，特别是在 J2EE 的开发中，它的灵活性就表现的十分明显。</p><p><strong>缺点：</strong> 对性能有影响。使用反射基本上是一种解释操作，可以告诉 JVM，希望做什么并且它满足对应的要求。这类操作总是慢于只直接执行相同的操作。</p><hr><h1 class=pgc-h-arrow-right><strong>什么是 JDBC 连接，在 Java 中如何创建一个 JDBC 连接？</strong></h1><p>JDBC 的全称是 Java DataBase Connection，也就是 Java 数据库连接，可以用它来操作<strong>关系型数据库</strong>。JDBC 接口及相关类在 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">java.sql</span> 包和 <span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">javax.sql</span> 包里。可以用它来连接数据库，执行 SQL 查询，存储过程，并处理返回的结果。</p><p>创建 JDBC 连接：</p><p>1、加载 JDBC 驱动程序。</p><p>2、提供 JDBC 连接的 URL。</p><p>3、创建数据库的连接。</p><p>4、创建一个 Statement。</p><p>5、执行 SQL 语句。</p><p>6、处理结果。</p><p>7、关闭 JDBC 对象。</p><blockquote class=pgc-blockquote-abstract><p>想了解更多，欢迎关注我的微信公众号：Renda_Zhang</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','发面','试题'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>