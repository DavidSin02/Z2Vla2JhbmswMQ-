<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Mysql知识总结 | 极客快訊</title><meta property="og:title" content="Mysql知识总结 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/53ea00052344dfa26d44"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e03b0ea.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e03b0ea.html><meta property="article:published_time" content="2020-10-29T21:09:08+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:08+08:00"><meta name=Keywords content><meta name=description content="Mysql知识总结"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1e03b0ea.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Mysql知识总结</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/53ea00052344dfa26d44></p><p class=pgc-img-caption>广东IT优就业</p><p><strong>mysql 登录命令：</strong></p><p>mysql -uroot -pbank 这句话的意思是用root用户登录，密码是bank。</p><p>mysql -uroot -p bank 这句话的意思是用root用户登录，bank是进入后切换到bank这个数据库，此时按下回车会提示输入密码。进入后不用use bank 来切换到bank数据库，自动就是bank数据库。</p><p>mysql -uroot -pbank &lt;=等价于=> mysql -u root -pbank 也就是说-uroot 等价于 -u root 。不论中间是否有空格隔开都一样。代表用root这个用户进行登录。</p><p><strong>查看当前时间：</strong></p><p>mysql> select now() from dual;</p><p>+---------------------+</p><p>| now() |</p><p>+---------------------+</p><p>| 2017-10-25 22:05:38 |</p><p>+---------------------+</p><p>1 row in set (0.03 sec)</p><p>mysql> select now();</p><p>+---------------------+</p><p>| now() |</p><p>+---------------------+</p><p>| 2017-10-25 22:05:47 |</p><p>+---------------------+</p><p>1 row in set (0.00 sec)</p><p>之所以要使用from dual是为了兼容oracle数据库，如果只是MySQL的话，可以省略from dual；因为某些数据库服务器规定查询语句中必须包含from字句，并在其中至少指明一个表名。</p><p><strong>MySQL字符型数据</strong></p><p>字符型数据分为定长或者变长两类，不同点在于固定长度的字符串使用空格向右填充，以保证占用同样的字节数；变长字符串不需要向右填充，并且所有字节数可变。当定义一个字符串类型时，必须要指定能存放的字符串最大长度。例如，需要存储最大不超过20个字节的字符串，可以用下列方式：</p><p>char(20) /* fixed-length */</p><p>varchar(20) /* variable-length */</p><p>char最大可以设置为255个字节，varchar则可以最多保存65535个字节。要存储比65535更长的字符串则要使用文本类型了。</p><p><strong>文本数据</strong></p><p>如果需要存储的数据超过64KB（varchar的上限），就需要使用文本类型。</p><p>文本类型　　　　　　　　　　最大能存储的字节数（B）</p><p>tinytext　　　　　　　　　　　　　　255</p><p>text　　　　　　　　　　　　　　 65535</p><p>mediumtext　　　　　　　　　　 16777215</p><p>longtext　　　　　　　　　　　　4294967295</p><p>观察可以发现，其实是用规律的，255 = 2^8 -1 ; 65535 = 2^16 -1 ; 16777215 = 2^24 -1 ; 4294967295 = 2^32 -1 ;</p><p>注意事项：</p><p>1.如果被装载到文本列中的数据超出了该类型的最大长度，数据会被截断。</p><p>2.在向文本列装载数据时，不会消除数据的尾部空格。而char类型会。</p><p>3.使用文本列进行排序、分组的时候，只会使用前1024个字符</p><p>4.这些不同的文本类型只是针对MySQL，sql Server对于大的字符型数据只提供text类型，而db2和oracle使用的数据类型是Clob。</p><p>5.现在MySQL允许varchar列最大容纳65535个字节了（在MysQL4中为255个字符），也就是和text一样大了，所以一般情况不会用到tinytext、text了，超过65535用mediumtext或者longtext；少于65535则使用varchar。</p><p>6.Oracle中，char能容纳2000个字节，varchar2能容纳4000个，sql Server中char和varchar都能容纳8000个字节。</p><p><strong>MySQL中的浮点数</strong></p><p>浮点数是用来表示实数的一种方法，它用 M(尾数) * B( 基数)的E(指数）次方来表示实数，相对于定点数来说，在长度一定的情况下，具有表示数据范围大的特点。但同时也存在误差问题。 浮点数有多种实现方法，计算机中浮点数的实现大都遵从 IEEE754 标准，IEEE754 规定了单精度浮点数和双精度浮点数两种规格：</p><p>单精度浮点数用4字节（32bit）表示浮点数，格式是： 1位符号位 8位表示指数 23位表示尾数</p><p>双精度浮点数用8字节（64bit）表示浮点数，格式是： 1位符号位 11位表示指数 52位表示尾数</p><p>IEEE754标准还对尾数的格式做了规范：d.dddddd...，小数点左面只有1位且不能为零，计算机内部是二进制，因此，尾数小数点左面部分总是1。显然，这个1可以省去，以提高尾数的精度。</p><p>下图是IEEE754的浮点数标准图：</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/53ee0000ba30e4170471></p><p class=pgc-img-caption>广东IT优就业</p><p>由上图可知，单精度浮点数的尾数虽然只有23位，但是由于第一位一定是1，所以其实是用24bit表示的；</p><p>双精度浮点数的尾数虽然只有52位，但是由于第一位一定是1，所以其实是用53bit表示的；</p><p>IEEE754标准中，一个规格化32位的浮点数x的真值表示为：</p><p><strong>　　　　x=(−1)S×(1.M)×2^e</strong></p><p><strong>　　　　e=E−127</strong></p><p>其中尾数域表示的值是1.M。因为规格化的浮点数的尾数域最左位总是1，故这一位不予存储，而认为隐藏在小数点的左边。</p><p>8 位的阶码<strong>e</strong>指数为可以表达 0 到 255 之间的 256 个指数值。但是，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，单精度数的偏差值为 127；偏差的引入使得对於单精度数，实际可以表达的指数值的范围就变成 -127（0 - 偏差值127） 到 128 （255 - 偏差值127）之间（包含两端）。在本文中，最小指数和最大指数分别用 emin 和 emax 来表达。实际的指数值 -127（保存为全0）以及 +128（保存为全 1）保留用作特殊值的处理。</p><p>（1）最大正数</p><p>单精度浮点数最大正数值的符号位S=0，阶码E=254，指数e=254-127=127，尾数M=111 1111 1111 1111 1111 1111，其机器码为：0 11111110 111 1111 1111 1111 1111 1111。</p><p>那么最大正数值:</p><p>PosMax=(−1)S×1.M×2^e=+(1.11111111111111111111111)×2^127 ≈ <strong>3.402823e+38</strong></p><p>（2）最小正数 最小正数符号位S=0，阶码E=1，指数e=1-127=-126，尾数M=0，其机器码为0 00000001 000 0000 0000 0000 0000 0000。 那么最小正数为：</p><p>PosMin=(−1)S×1.M×2e=+(1.0)×2−126 ≈ <strong>1.175494e−38</strong></p><p>当使用浮点类型时，可以指定其精度（小数点左边右边所允许的数字总位数）和有效位（小数点右边所允许的数字位数）。比如float（5,2）代表的是小数点左边3位，小数点右边2位。因此，如果添加11.275会被四舍五入到11.28。最大支持添加的数字是999.99，当添加比999.99大的数字的时候，就会报错。</p><p>注意，float也可以声明为unsigned类型，但是这声明只会禁止列中存放负数，并没有改变该列存储数据的范围。</p><p><strong>MySQL中的整数类型</strong></p><p>类型　　　　　　带符号的范围　　　　　　　　无符号的范围</p><p>tinyint　　　　　　-128~127　　　　　　　　　　0~255</p><p>smallint　　　　 -32768~32767　　　　　　　　0~65535</p><p>mediumint　　　-8388608~8388607　　　　　　0~16777215</p><p>int 　　　　　　-2147483648~2147483647　　 0~4294967295</p><p>bigint　　　　-9223372036854755808　　　　0~18446744073709551615</p><p>~ 9223372036854755807</p><p>当使用tinyint时，分配1字节；使用smallint时，分配2字节；使用mediumint时，分配3字节；使用int时，分配4字节；使用bigint，分配8字节。</p><p>选择类型时，只需要确保能够容纳预期的最大数字即可，这样可以避免不必要的浪费。</p><p><strong>MySQL的时间类型</strong></p><p>类型　　　　　　默认格式　　　　　　　　允许的值</p><p>date　　　　　　YYYY-MM-DD　　　　　　 1000-01-01~9999-12-31</p><p>datetime　　　　YYYY-MM-DD HH:MI:SS　　1000-01-01~9999-12-31 23:59:59</p><p>timestamp　　　 YYYY-MM-DD HH:MI:SS　　 1000-01-01~9999-12-31 23:59:59</p><p>year　　　　　　YYYY　　　　　　　　　　 1901~2155</p><p>time　　　　　　HHH:MI:SS　　　　　　　　-838:59:59~838:59:59</p><p>如上表，如果需要向默认格式为YYYY-MM-DD的日期列插入日期2017年1月23日，必须使用字符串'2017-01-23'。</p><p>timestamp类型和datetime类型一样（包括了年月日 时分秒），但是Mysql服务器可以支持在向表中添加或者修改数据行时，自动为timestamp类型列产生当前的日期和时间。</p><p><strong>GMT和UTC时间</strong></p><p>GMT时间就是著名的格林威治标准时间，其他所有地区都可以使用与GMT的差距的小时数来表示，比如GMT +8代表中国北京的时间。</p><p>UTC时间是克服了GMT时间的一些缺陷后，用原子钟提供的时间，比GMT更加准一些，其实还是以格林威治作为标准的。北京的时间可以表示为UTC +8</p><p>简单地理解他俩，GMT旧一些，不太准；UTC新一些，用的技术更加高级，更加准。其他区别可以忽略不计。</p><p>现在计算机中都用了更加准确的utc时间，所以MySQL中可以使用utc_timestamp()来获取。</p><p>mysql> select utc_timestamp();</p><p>+---------------------+</p><p>| utc_timestamp() |</p><p>+---------------------+</p><p>| 2017-10-26 02:42:02 |</p><p>+---------------------+</p><p>1 row in set (0.02 sec)</p><p>可以看到返回的格式是YYYY-MM-DD HH:MI:SS。Sql Server可以用getutcdate（）函数获取。</p><p><strong>查看全局时区和会话时区</strong></p><p>mysql> SELECT @@global.time_zone,@@session.time_zone;</p><p>+--------------------+---------------------+</p><p>| @@global.time_zone | @@session.time_zone |</p><p>+--------------------+---------------------+</p><p>| SYSTEM | SYSTEM |</p><p>+--------------------+---------------------+</p><p>1 row in set (0.00 sec)</p><p>可以看到，结果值为system，这表示服务器根据数据库所在地使用相应的时区设置。</p><p>假如你坐在中国，远程一台纽约的mysql服务器，可以通过执行下面的指令暂时改变当前会话的时区设置：</p><p>SET time_zone = '+08:00'；</p><p>mysql> select @@global.time_zone,@@session.time_zone;</p><p>+--------------------+---------------------+</p><p>| @@global.time_zone | @@session.time_zone |</p><p>+--------------------+---------------------+</p><p>| SYSTEM　　　　　 |　　　　 +08:00　　　 |</p><p>+--------------------+---------------------+</p><p>1 row in set (0.00 sec)</p><p>此时会话中显示的所有日期都符合北京时间。</p><p>如果需要向datetime或者timestamp列中添加一条2017年1月23日下午15:00的数据，可以使用下列的字符串：</p><p>‘2017-01-23 15:00:00’</p><p>'2017/01/23 15,00,00'</p><p>'2017,01,23 15,00,00'</p><p>'20170123150000'</p><p>以上的字符串都可以产生日期，但是会比较死板，必须要有固定的格式，缺一不可。</p><p><strong>产生日期的函数</strong></p><p><strong></strong>如果你现在手上的数据不是像上边一样的格式，而是其他类型的字符串，比如‘September 17, 2008’ 或者'September 2008 , 17' 等等更加随意的排列方式，那么怎么办呢，要不要一个一个转化成上边的那种格式呢，显然，MySQL也考虑到了这种情况，所以提供了一个str_to_date（）函数，可以将这种类型的数据不用修改成上边那种格式就能直接插入到数据库中。是不是很方便呢，来看看怎么用的。</p><p><strong>UPDATE TABLE1</strong></p><p><strong>　　SET birth_date = STR_TO_DATE('September 17 , 2008' , '%M %d , %Y')</strong></p><p><strong>　　WHERE cust_id = 9999;</strong></p><p><strong>　　或者</strong></p><p><strong>　　UPDATE TABLE1</strong></p><p><strong>　　SET birth_date = STR_TO_DATE('September 2008 , 17' , '%M %Y , %d')</strong></p><p><strong>　　WHERE cust_id = 9999;</strong></p><p>这样就可以插入到数据库了,当然，此时在数据库中保存的格式就变成　<strong>2008-09-17 00:00:00 </strong>这种格式的了.</p><p>用这个str_to_date()函数的时候，需要查阅下边的表，来知道%M 代表什么？%Y代表什么？ 就像C语言中%d代表整数，%f代表浮点数一样，多用就自然记住了。</p><p>日期格式表</p><p><strong>格式部件 　　　　　　　　　　 描述</strong></p><p>%M　　　　　　　　　　 月名称（January,February,March.....）</p><p>%m　　　　　　　　　　 月序号(01 ~ 12)</p><p>%d　　　　　　　　　　 日序号（01 ~ 31）</p><p>%j　　　　　　　　　　 日在一年中的序号（001 ~ 366）</p><p>%W　　　　　　　　　　星期名称（Sunday , Monday,Tuesday....）</p><p>%Y　　　　　　　　　　 4位数表示的年份（2011，2012 , 2013.....）</p><p>%y　　　　　　　　　　 两位数代表的年份（11,12,13......）</p><p>%H　　　　　　　　　　 小时（00 ~ 23）</p><p>%h　　　　　　　　　　 小时（01 ~ 12）</p><p>%p　　　　　　　　　　 A.M. 或者 P.M.</p><p>%i　　　　　　　　　　 分钟(00 ~ 59 )</p><p>%s　　　　　　　　　　 秒钟(00 ~ 59 )</p><p>%f 　　　　　　　　　　 微秒(000000 ~ 999999 ）</p><p>注意：</p><p>1.str_to_date()函数将根据格式字符串的内容自动决定返回datetime，date 或者 time 类性值。举例来说，如果格式字符串只包含%H %i或者 %s，那么将返回time值。</p><p>2.Oracle数据库，to_date()函数和mysql的str_to_date()函数具有同样的功能。</p><p>3.可以使用select current_date()返回当前date，使用select current_time()返回当前time，使用select current_timestamp()返回当前timestamp/datetime。</p><p><strong>操作时间数据的几个函数</strong></p><p><strong>1.date_add()函数</strong></p><p><strong>　　 2.last_day()函数</strong></p><p><strong>　　 3.convert_tz()函数</strong></p><p><strong>　　 4.dayname()函数</strong></p><p><strong>　　 5.extract()函数</strong></p><p><strong>　　 6.datediff()函数</strong></p><p><strong>　　下面依次来看一下这几个函数。</strong></p><p><strong>1.date_add()函数</strong></p><p><strong>　　</strong>MySQL的date_add()函数可以为指定的日期增加任意一段时间间隔（如天、月、年），并产生另外一个日期。</p><p>#在现在的时间基础上添加5天。</p><p>mysql><strong> select date_add(current_timestamp(),interval 5 day);</strong></p><p>+----------------------------------------------+</p><p>| date_add(current_timestamp(),interval 5 day) |</p><p>+----------------------------------------------+</p><p>| <strong>2017-10-31 11:58:00</strong> |</p><p>+----------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>#在现在的时间的基础上增加3小时25分钟0秒</p><p>mysql> <strong>select date_add(current_timestamp(),interval '3:25:00' hour_second);</strong></p><p>+--------------------------------------------------------------+</p><p>| date_add(current_timestamp(),interval '3:25:00' hour_second) |</p><p>+--------------------------------------------------------------+</p><p>| <strong>2017-10-26 15:23:53</strong> |</p><p>+--------------------------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>#在现在的时间的基础上增加了1年12月</p><p>mysql><strong> select date_add(current_timestamp(),interval '1-12' year_month);</strong></p><p>+----------------------------------------------------------+</p><p>| date_add(current_timestamp(),interval '1-12' year_month) |</p><p>+----------------------------------------------------------+</p><p>| <strong>2019-10-26 11:59:23</strong> |</p><p>+----------------------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>#在现在的时间基础上增加5分钟10秒</p><p>mysql> <strong>select date_add(current_timestamp(),interval '5:10' minute_second);</strong></p><p>+-------------------------------------------------------------+</p><p>| date_add(current_timestamp(),interval '5:10' minute_second) |</p><p>+-------------------------------------------------------------+</p><p>|<strong> 2017-10-26 12:07:59</strong> |</p><p>+-------------------------------------------------------------+</p><p>1 row in set (0.02 sec)</p><p><strong>常用的时间间隔类型表</strong></p><p><strong>间隔名称　　　　　　　　　　　　描述</strong></p><p>second　　　　　　　　　　　　　秒数</p><p>minute　　　　　　　　　　　　　分钟数</p><p>hour　　　　　　　　　　　　　　小时数</p><p>day　　　　　　　　　　　　　　 天数</p><p>month　　　　　　　　　　　　　 月份数</p><p>year　　　　　　　　　　　　　　年份</p><p>minute_second　　　　　　　　 分钟数和秒数，中间用“：”隔开</p><p>hour_second 　　　　　　　　　 小时数、分钟数、秒数，中间用“：”隔开</p><p>year_month 　　　　　　　　　　 年份和月份，中间用“-”隔开</p><p><strong>2.last_day()函数</strong></p><p>要获取当前时刻的月底是哪一天，可以使用last_day（）函数，这个函数的作用就是简单地返回传入的日期的月末日期。</p><p>mysql><strong> select last_day(current_timestamp());</strong></p><p>+-------------------------------+</p><p>| last_day(current_timestamp()) |</p><p>+-------------------------------+</p><p>| <strong>2017-10-31</strong> |</p><p>+-------------------------------+</p><p>1 row in set (0.00 sec)</p><p>可以像上边一样传入datetime类型的值，也可以传入date的类型值，都一样会返回date类型的值。</p><p><strong>3.convert_tz()函数</strong></p><p>该函数能够将某个时区的datetime类型的值转化为另外一个时区的对应时间。在Oracle中，这个函数叫new_time()函数。</p><p>mysql><strong> select convert_tz('2014-09-28','US/Eastern','UTC');</strong></p><p>+---------------------------------------------+</p><p>| convert_tz('2014-09-28','US/Eastern','UTC') |</p><p>+---------------------------------------------+</p><p>| <strong>NULL</strong> |</p><p>+---------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>可以看到此时的返回值为null，是因为我的电脑上没有安装mysql的时区数据，就是说，系统现在不认识US/Eastern 这个地区，UTC地区也不认识。所以返回了一个空值。</p><p><strong>4.dayname()函数</strong></p><p>dayname()函数可以直接返回传入的日期那天是星期几。</p><p>mysql> <strong>select dayname('2008-09-18');</strong></p><p>+-----------------------+</p><p>| dayname('2008-09-18') |</p><p>+-----------------------+</p><p>| <strong>Thursday</strong> |</p><p>+-----------------------+</p><p>1 row in set (0.00 sec)</p><p>比如上面的例子中，返回了2008年9月18日那天，是星期四。</p><p>除了dayname，还有<strong>monthname</strong>()函数，同理可以返回传入日期代表的月份的名称。比如下面的例子：</p><p>mysql><strong> select monthname('2008-09-18');</strong></p><p>+-------------------------+</p><p>| monthname('2008-09-18') |</p><p>+-------------------------+</p><p>| <strong>September</strong> |</p><p>+-------------------------+</p><p>1 row in set (0.00 sec)</p><p>很简单就能理解，不多说了。</p><p><strong>5.extract()函数</strong></p><p>该函数用于从日期或者时间中提取出某一部分内容。</p><p>mysql> <strong>select extract(hour_second from '2008-09-18 22:19:05');</strong></p><p>+-------------------------------------------------+</p><p>| extract(hour_second from '2008-09-18 22:19:05') |</p><p>+-------------------------------------------------+</p><p>| <strong>221905</strong> |</p><p>+-------------------------------------------------+</p><p>1 row in set (0.02 sec)</p><p>mysql> <strong>select extract(year_month from '2008-09-18 22:19:05');</strong></p><p>+------------------------------------------------+</p><p>| extract(year_month from '2008-09-18 22:19:05') |</p><p>+------------------------------------------------+</p><p>| <strong>200809</strong> |</p><p>+------------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>mysql><strong> select extract(minute from '2008-09-18 22:19:05');</strong></p><p>+--------------------------------------------+</p><p>| extract(minute from '2008-09-18 22:19:05') |</p><p>+--------------------------------------------+</p><p>| <strong>19</strong> |</p><p>+--------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p><strong>6.datediff()函数</strong></p><p>该函数用于传入两个时间，求出他们之间的时间间隔。</p><p>比如</p><p>mysql> <strong>select datediff('2009-08-28','2009-08-24');</strong></p><p>+-------------------------------------+</p><p>| datediff('2009-08-28','2009-08-24') |</p><p>+-------------------------------------+</p><p>| <strong>4</strong> |</p><p>+-------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>可以看到该日期不包含最后一天，即24,25,26,27.不过，也有可能是25,26,27,28，总之是包含其中一天，不包含两天。</p><p>注意点：</p><p>datediff函数会忽略参数中的时间值，就算我把前一个日期设置为一天的最后一秒，后一个日期设置为一天的第一秒，也不会影响计算结果。</p><p>比如：</p><p>mysql><strong> select datediff('2009-08-28 23:59:59','2009-08-24 00:00:01');</strong></p><p>+-------------------------------------------------------+</p><p>| datediff('2009-08-28 23:59:59','2009-08-24 00:00:01') |</p><p>+-------------------------------------------------------+</p><p>| <strong>4</strong> |</p><p>+-------------------------------------------------------+</p><p>1 row in set (0.00 sec)</p><p>可以发现，该函数并没有关注时间，而是选择直接忽略了。</p><p>假如交换一下第一个参数和第二个参数的话，就会发现日期的值变成了负数。</p><p><strong>MySQL的查询语句</strong></p><p><strong>1.select子句</strong></p><p>query字句表</p><p>字句名称　　　　　　　　　　使用目的</p><p>select　　　　　　　　　　 确定结果集中应该包含哪些列</p><p>from　　　　　　　　　　 指明所要提取数据的表，以及这些表示如何连接的</p><p>where　　　　　　　　　　 过滤掉不需要的数据</p><p>group by　　　　　　　　　用于对具有相同列值的行进行分组</p><p>having　　　　　　　　　　过滤掉不需要的组</p><p>order by　　　　　　　　　 按一个或多个列，对最后结构集中的行进行排序</p><p>从最简单的例子开始：</p><p>（1）选择一个 表中所有的数据</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ec000432f473b8639e></p><p class=pgc-img-caption>广东IT优就业</p><p>（2）选择其中的某一列或者多列</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53f100004d0887413837></p><p class=pgc-img-caption>广东IT优就业</p><p>如果数据库限制了只能返回from字句后面各个表所包含的列，就显得相当乏味了。幸运的是，我们可以在select字句中加上一些“调料”，例如</p><p>1.字符，比如数字或字符串</p><p>2.表达式，比如transaction.amount*-1</p><p>3.调用内建函数，比如round（transaction.amount,2）;</p><p>4.用户自定义的函数调用。</p><p>（4）展示对于刚才的Department表，在查询中添加一些调料，比如使用自定义的列名、字符、表达式、内建函数调用：</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ed0003c6e6fd273bba></p><p class=pgc-img-caption>广东IT优就业</p><p>(5)调用更多的内建函数</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/53f000009159bff1d315></p><p class=pgc-img-caption>广东IT优就业</p><p>可以看到三个内建函数分别返回不同的值，version代表的是数据库版本，user代表的是当前登录的用户名称，database代表的是现在正在使用的数据库的名称。</p><p><strong>现在先在department表中先插入一个同名的公寓，插入语句和插入后结果如下：</strong></p><p><strong><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ef0000b8e731b239af></strong></p><p class=pgc-img-caption>广东IT优就业</p><p>（6）去除重复的行</p><p>如果此时只选择name列的话，会有四个值，但是有两个Loans重复的，我需要独一无二的，重复值不论出现多少次，我都只取一次，那么就需要使用到<strong>distinct</strong>关键字了。</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53f200003ca8e27c0321></p><p class=pgc-img-caption>广东IT优就业</p><p>注意此处使用的distinct，添加这个关键词对小数据量没啥影响，但是如果数据量大了之后，性能影响较大。原因是要产生无重复的结果集需要首先对数据排序，这对于大的结果集来说是相当耗时的。因此不要为了确保去除重复行而随意地使用distinct，而是应该先了解所使用的数据是否可能包含重复行，以减少对distinct的不必要的使用。</p><p><strong>2.from子句</strong></p><p>from子句定义了查询中所使用的表，以及连接这些表的方式。</p><p>当使用术语“表”时，往往想到的是实实在在存在的表格，就像上面的Department表。其实from子句后边不仅仅可以跟这种实体表（用create table创建），还可以从临时表（子查询返回的表）以及虚拟表（使用create view 子句所创建的视图）中返回数据。</p><p>（1）从子查询返回的表中查询数据</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ee0000ba337be2b028></p><p class=pgc-img-caption>广东IT优就业</p><p>上图中会先执行括号中的select，然后会在内存中生成一个虚的表，这个虚的表叫d。然后再执行外层的select，从这个虚的表中选择相应的dept_id列和name列。</p><p>假如这个虚拟表在选择的时候给一个别名的话，外层也就只能通过这个别名来选择。比如：</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ee0000ba35fae1dde9></p><p class=pgc-img-caption>广东IT优就业</p><p>可以看到，内部选择的时候，给dept_id出了个别名，叫做id，给name出了一个别名，叫做department_name。外层再选择的时候，就得通过这个新的别名去虚表d中选择了。</p><p>(2)从视图中返回数据</p><p>下面先定义一个查询Department表的视图，在Department表的基础上多了一列当前操作时候的时间，并将dept_id重命名为id，将name重命名为department_name。</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ed0003c6e7fab5a04c></p><p class=pgc-img-caption>广东IT优就业</p><p>然后从这个视图返回所有的数据：</p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ec000432f8b64ba56a></p><p class=pgc-img-caption>广东IT优就业</p><p>可以发现，从视图选择数据成功了。</p><p><strong>3. where子句</strong></p><p>现在假如我有一个员工表，主要有4个字段，emp_id（员工id）、fname(姓）、lname（名字）、start_date（入职时间）。</p><p>让我们一起解决一些问题：</p><p>（1）如何获得员工id为99号的员工的所有信息？</p><p>（2）如何获得id 大于等于20，小于等于40的员工信息？（请用两种不同方式分别实现）</p><p>（3）如何获得11,45,99,124号员工的信息？（用两种方式实现）</p><p>（4）如何获得除了11,45,99,124号员工外，其他员工的信息？（用两种方式实现）</p><p>（5）如何获得入职时间在2011年10月1日前的，并且姓 ‘李’的所有员工？（用三种方式实现）</p><p>（6）如何获取所有emp_id的末尾为1的所有记录，比如emp_id为1,11,21,31.。。。101，121，。。。1001，1011，。。。。。（用三种方式来实现）</p><p>（7）如何获取101,111,121,131,141,151,161,171,181,191这几个员工的记录？（分别用通配和正则来实现）</p><p>上面的这些问题基本涵盖了where语句中的所有知识点，大家可以先试试看，按照题目的描述和括号中的条件来实现。</p><p>思考后，再查看下面的答案。</p><p>答案：</p><p>（1）<strong>select * from employee where emp_id = 99;</strong></p><p>（2）<strong>select * from employee where emp_id between 20 and 40;</strong></p><p><strong>　　　　 select * from employee where emp_id >=20 and emp_id &lt;=40;</strong></p><p>（3）<strong>select * from employee where emp_id = 11 or emp_id = 45 or emp_id = 99 or emp_id = 124;</strong></p><p><strong>　　　　 select * from employee where emp_id in (11,45,99,124);</strong></p><p>（4）<strong>select * from employee where emp_id !=11 and emp_id !=45 and emp_id != 99 and emp_id !=124;</strong></p><p><strong>　　　　 select * from employee where emp_id not in (11,45,99,124);</strong></p><p>（5）<strong>select * from employee where start_date&lt;'2011-10-01' and fname = '李';</strong></p><p><strong>　　　　 select * from (select * from employee where fname = '李' ) d where d.start_date &lt; '2011-10-01';</strong></p><p><strong>　　　　 select * from employee where emp_id in (select emp_id from employee where fname = '李' ) and start_date &lt; '2011-10-01';</strong></p><p>（6）<strong>select * from employee where emp_id like '%1';</strong></p><p><strong>　　　　 select * from employee where emp_id regexp '.*1$';</strong></p><p><strong>　　　　 select * from employee where right(emp_id,1) = 1;</strong></p><p>（7）<strong>select * from employee where emp_id like '1_1;'</strong></p><p><strong>　　　　 select * from employee where emp_id regexp '1.1';</strong></p><p><img alt=Mysql知识总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/53ee0000bb190529f5f9></p><p class=pgc-img-caption>广东IT优就业</p><p>希望广州IT培训老师上述分享的内容对大家有所帮助。</p><p>出处：https://www.cnblogs.com/lukairui/p/7735050.html</p><p>更多IT精彩推荐：</p><p>人人都要学的IT小技巧：http://xue.ujiuye.com/zt/renrenxue/</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Mysql','知识','总结'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>