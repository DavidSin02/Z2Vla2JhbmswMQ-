<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构｜图的邻接表与深度、广度优先搜索 | 极客快訊</title><meta property="og:title" content="数据结构｜图的邻接表与深度、广度优先搜索 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e93433412f4f4d1baa9d2a433397a8c7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><meta property="article:published_time" content="2020-11-14T20:59:14+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:14+08:00"><meta name=Keywords content><meta name=description content="数据结构｜图的邻接表与深度、广度优先搜索"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1e37989b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构｜图的邻接表与深度、广度优先搜索</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>线性存储元素时，元素的关系也同时确定了。而非线性数据结构就不同了，需要同时考虑存储数据元素和数据元素的关系。</p><blockquote class=pgc-blockquote-abstract><p>由于图的结构比较复杂，任意两个顶点之间都可能存在联系，因此无法以数据元素在存储区中的物理位置来表示元素之间的关系，即图没有顺序存储结构，但可以借助二维表来表示元素之间的关系，一般称为邻接矩阵。另一方面，由于图的任意两个顶点间都可能存在关系，因此，用链式存储表示图是很自然的事，其中有代表性的链式存储结构称为邻接表（Adjacency List）。</p></blockquote><p>在邻接表中，对图中每个顶点vi建立一个单链表，把与vi相邻接的顶点放在这个链表中。邻接表中每个单链表的第一个结点存放有关顶点的信息， 把这一结点看成链表的表头，其余结点存放有关边的信息。这样邻接表便由两部分组成：表头结点表和边表。</p><div class=pgc-img><img alt=数据结构｜图的邻接表与深度、广度优先搜索 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e93433412f4f4d1baa9d2a433397a8c7><p class=pgc-img-caption></p></div><p>如上图的邻接表和逆邻接表：</p><div class=pgc-img><img alt=数据结构｜图的邻接表与深度、广度优先搜索 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f15b8706df644efb92909b64c346f993><p class=pgc-img-caption></p></div><p>需要注意的是，图的邻接表表示并不唯一，这是因为在每个顶点对应的单链表中，各边结点的链接次序可以是任意的，取决于邻接表的算法以及边的输入次序。</p><p>用邻接表表示图一般可以描述为：</p><pre><code>typedef struct ArcNode{			// 单链表中的结点的类型	int  adjvex;				// 该边指向的顶点在顺序表中的位置	struct ArcNode  *next;		// 下一条边  //OtherInfo info;  // 和边相关的信息，如权值}ArcNode;typedef struct VNode{			// 顶点类型	int  data;					// 顶点中的数据信息	ArcNode  *firstarc;			// 指向单链表，即指向第一条边}VNode;</code></pre><blockquote class=pgc-blockquote-abstract><p>图的邻接存储：顶点表+n个链表（顶点元素及链接到相邻顶点的指针、下一个相邻点及指针……）；</p><p>有向图存储全部信息同时还需要一个逆邻接表；</p><p>带权图的邻接表则需要结点元素多一个权值域；</p></blockquote><p>图遍历背后的关键思想是在我们第一次访问每个顶点时对其进行标记（一般使用一个布尔数组），并跟踪我们尚未完全探索的内容（一般使用一个栈或队列结构）。尽管面包屑或解开的线被用来标记童话迷宫中参观过的地方，但我们将依赖布尔标志或枚举类型来进行。</p><p>每个顶点将以三种状态之一存在：</p><blockquote class=pgc-blockquote-abstract><p>未发现-顶点处于原始状态。</p><p>已发现-顶点已找到，但尚未检查其所有入射边。</p><p>已处理–访问所有关联边后的顶点。</p></blockquote><p>显然，一个顶点只有在我们发现它之后才能被处理，所以每个顶点的状态在遍历过程中从未发现到发现再到处理。</p><p>我们还必须维护一个包含我们已经发现但尚未完全处理的顶点的结构。最初，只有一个起始顶点被认为是被发现的。为了完全探索一个顶点v，我们必须计算每一条离开v的边。如果一条边转到一个未发现的顶点x，我们标记x 为“已发现”并将其添加到要做的工作列表中。我们要忽略处理过的顶点的边，因为进一步的探索不会告诉我们关于图的任何新的东西。我们还可以忽略到已发现但未处理的顶点的任何边，因为目标已位于要处理的顶点列表中。</p><p>BFS(Depth First Search--DFS)和DFS(Breadth First Search--BFS)结果的区别在于它们探索顶点的顺序。此顺序完全取决于用于存储已发现但未处理的顶点的容器数据结构。</p><p>Stack–通过将顶点存储在后进先出（last-in，first-out，LIFO）堆栈中，我们通过沿着路径一直前行、访问新邻居（如果有的话）和仅当我们被以前发现的顶点包围时才回退来探索新的顶点。因此，我们的探索很快偏离了起点，定义了深度优先搜索。</p><p>一旦发现一个顶点，它就被放置在栈（显式或隐式栈）中。由于我们按后入先出的顺序处理这些顶点，所以最新的顶点将首先展开，这些顶点正是最远离根的顶点。</p><p>队列-通过将顶点存储在先进先出（FIFO）队列中，我们首先探索最古老的未探索顶点。因此，我们的探索从起始顶点缓慢地向外辐射，定义了广度优先搜索。</p><p>一旦发现一个顶点，它就被放置在队列中。由于我们按先入先出的顺序处理这些顶点，所以最旧的顶点将首先展开，这些顶点正是最接近根的顶点。</p><p>深度优先搜索有一个简洁的递归实现，它消除了显式使用堆栈的需要。</p><p>我们需要能够对每个入口和出口分别采取行动。</p><p>深度优先搜索的另一个重要特性是它将无向图的边划分为两类：tree edges和back edges。tree edges发现新的顶点，并且是在parent关系中编码的顶点。back edges是那些其另一个端点是被展开顶点的ancestor的边，因此它们指向树中。</p><div class=pgc-img><img alt=数据结构｜图的邻接表与深度、广度优先搜索 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf52177e066746ce90f4a8b8e531867e><p class=pgc-img-caption></p></div><p><strong>1 深度优先遍历</strong></p><p>优先向深度探索，一直走到头才回头到路径的上一个相邻顶点，直到回溯到最开始顶点。</p><p>对于邻接点，先孩子…后上一辈的兄弟，后进先出（栈隐式或显式辅助）。</p><div class=pgc-img><img alt=数据结构｜图的邻接表与深度、广度优先搜索 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/536375e243aa402186bbd669033e8981><p class=pgc-img-caption></p></div><p>如上图的深度优先遍历的顺序：0 1 2 3 4 5 6 8 9 7。</p><p>如果使用递归，则相当于使用了一个隐式的栈数据结构（编译器对函数递归调用的压栈和回归的出栈操作）。</p><p>如果使用迭代法，则需要显式使用一个栈数据结构。</p><p><strong>2 广度优先遍历</strong></p><p>广度优先遍历，也就是从某一个顶点开始，优先访问全部的相邻顶点，按层次辐射，直到全部顶点访问完。</p><p>对于邻接点，先兄弟后孩子，先进先出（队列辅助）。</p><p>如上图使用广度优先遍历的顺序：0 1 3 2 4 5 6 7 8 9。</p><p>广度优先遍历需显式使用一个队列的数据结构。广度优先搜索是一种分层的搜索过程，不像深度优先遍历那样有往回退的情况。因此，广度优先遍历不能递归实现，可以使用先进先出的队列来实现。</p><blockquote class=pgc-blockquote-abstract><p>深度搜索与广度搜索的控制结构和产生系统很相似，唯一的区别在于对扩展节点选取上。由于其保留了所有的前继节点，所以在产生后继节点时可以去掉一部分重复的节点，从而提高了搜索效率。这两种算法每次都扩展一个节点的所有子节点，而不同的是，深度搜索下一次扩展的是本次扩展出来的子节点中的一个，而广度搜索扩展的则是本次扩展的节点的兄弟节点。也就是说，广度优先搜索会优先考虑最早被发现的顶点，也就是说离起点越近的顶点优先级越高。深度优先搜索会优先考虑最后被发现的顶点。</p><p>在20世纪50年代，广度优先搜索最早由Edward F. Moor在研究迷宫路径问题时发现，深度优先搜索在人工智能方面获得了广泛应用。</p><p>需要注意的是，广度优先搜索是以起始点为中心，一层一层向外层扩展遍历图的顶点，因此无法考虑到边的权值，只适合求边权值相等的图的单源最短路径。</p></blockquote><pre><code>// 图的邻接表存储，以及图的深度优先遍历(DST)和广度优先遍历（BST）#include "stdio.h"#include "malloc.h"#define MAX_VERTEX_NUM 10     // 表示创建和遍历的图的顶点数typedef struct ArcNode{       // 单链表中的结点的类型    int  adjvex;              // 该边指向的顶点在顺序表中的位置（下标）    struct ArcNode  *next;    // 下一条边    //OtherInfo info;         // 和边相关的信息，如权值}ArcNode;typedef struct VNode{         // 顶点类型    int  data;                // 顶点中的数据信息    ArcNode  *firstarc;       // 指向单链表，即指向第一条边}VNode;typedef struct QNode{    int data;                 // 链队列结点中的数据域    struct QNode *next;       // 链队列结点中的指针域}QNode , *QueuePtr;typedef struct{    QueuePtr front;           // 队头指针    QueuePtr rear;            // 队尾指针}LinkQueue;int visited[MAX_VERTEX_NUM]={0};/* 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   */void CreatGraph(int n, VNode G[]);int  FirstAdj(VNode G[],int v) ;        // 返回下标为v的顶点的第一邻接点在数组中的下标int  NextAdj(VNode G[],int v, int w);   // 返回下标为v的顶点的邻接点中下标为w的邻接点的下标void DFS(VNode G[],int v)    // 从下标为v的顶点开始DFS{    printf("%d ",G[v]);      // 访问当前顶点,打印出该顶点中的数据信息    visited[v] = 1;          // 将顶点v对应的访问标记置1    int w = FirstAdj(G,v);   // 找到顶点v的第一个邻接点，如果无邻接点，返回-1    while(w != -1){        if(visited[w] == 0)  // 该顶点未被访问            DFS(G,w);        // 递归地进行深度优先搜索        w = NextAdj(G,v,w);  // 找到顶点v的邻接点为w的下一个邻接点，如果无邻接点，返回-1    }}void Travel_DFS(VNode G[], int n)        // 非连能图各子图的DFS{    for(int i=0;i&lt;n;i++)        visited[i] = 0;      // 将标记数组初始化为0    for(i=0;i&lt;n;i++)        if(visited[i] == 0)  // 若有顶点未被访问，从该顶点开始继续深度优先搜索            DFS(G,i);}void initQueue(LinkQueue *q);void EnQueue(LinkQueue *q, int e);void DeQueue(LinkQueue *q, int *e);int emptyQ(LinkQueue q) ;void BFS(VNode G[],int v){    LinkQueue q;    initQueue(&amp;q);        printf("%d ",G[v]);         // 访问顶点v    visited[v] = 1;             // 将顶点v对应的访问标记置1    EnQueue(&amp;q,v);              // 顶点v入队列    while(!emptyQ(q))    {        DeQueue(&amp;q, &amp;v);        // 出队列，元素由v返回        int w = FirstAdj(G, v); // 找到顶点v的第一个邻接点，如果无邻接点，返回-1        while(w != -1)		    {            if(visited[w] == 0)             {                printf("%d ",G[w]);                EnQueue(&amp;q,w);   // 顶点w入队列                visited[w] = 1;            }            w = NextAdj(G, v, w);// 找到顶点v的下一个邻接点，如果无邻接点，返回-1        }    }}void Travel_BFS(VNode G[], int n){    int i;    for(i=0;i&lt;n;i++)        visited[i] = 0;          // 将标记数组初始化为0    for(i=0;i&lt;n;i++)          // 非连能图各子图的BFS        if(visited[i] == 0)      // 若有顶点未被访问，从该顶点开始继续广度优先搜索            BFS(G,i);}void resetVisitedTrace() {    int i;    for (i=0; i&lt;MAX_VERTEX_NUM; i++)     {        visited[i] = 0;    }}int main(){    VNode G[MAX_VERTEX_NUM];    CreatGraph(MAX_VERTEX_NUM,G);    printf("DFS trace is\n");    Travel_DFS(G,MAX_VERTEX_NUM);    resetVisitedTrace();    printf("\nBFS trace is\n");    Travel_BFS(G,MAX_VERTEX_NUM);    getchar();getchar();    return 0;}/* 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   DFS trace is0 1 2 3 4 5 6 8 9 7BFS trace is0 1 3 2 4 5 6 7 8 9data：0 1 2 3 4 5 6 7 8 91 3 -10 2 4 -11 3 4 -10 2 -11 2 -16 7 8 -15 8 9 -15 -15 6 -16 -1*/void CreatGraph(int n, VNode G[]){    int i,e;    ArcNode *p , *q;    printf("Input the information of the vertexes(%d) and edges\n",MAX_VERTEX_NUM);    printf("you can copy below data, then return:\n");    printf("0 1 2 3 4 5 6 7 8 9\n");    printf("1 3 -1 \n");    printf("0 2 4 -1 \n");    printf("1 3 4 -1 \n");    printf("0 2 -1 \n");    printf("1 2 -1 \n");    printf("6 7 8 -1 \n");    printf("5 8 9 -1 \n");    printf("5 -1 \n");    printf("5 6 -1 \n");    printf("6 -1 \n");    for(i=0;i&lt;n;i++)    {        scanf("%d",&amp;G[i]);        G[i].firstarc = NULL;                        // 初始化第一条边为空    }    printf("创建每个顶点的邻边：输入的值是邻边另一个顶点在数组中的下标，\n");    printf("当输入-1，表示该顶点依附的邻边创建完毕！\n");    for(i=0;i&lt;n;i++)    {        printf("Create the edges for the %dth vertex\n",i) ;        scanf("%d",&amp;e);        while(e!=-1){            p = (ArcNode *)malloc(sizeof(ArcNode)); // 创建一条边            p-&gt;next = NULL;            p-&gt;adjvex = e;            if(G[i].firstarc == NULL)                G[i].firstarc = p;                  // i结点的第一条边            else                q-&gt;next = p;                        // 下一条边            q = p;            scanf("%d",&amp;e);        }    }}int  FirstAdj(VNode G[],int v)         // 返回下标为v的顶点的第一邻接点在数组中的下标{    if(G[v].firstarc != NULL) {        return (G[v].firstarc)-&gt;adjvex;    }    return -1;}int  NextAdj(VNode G[],int v, int w){   // 返回下标为v的顶点的邻接中下标为w                                        // 的下一个邻接点在数组中的下标    ArcNode *p = G[v].firstarc;    while( p!= NULL){        if(p-&gt;adjvex == w &amp;&amp; p-&gt;next != NULL) {            return p-&gt;next-&gt;adjvex;        }         p = p-&gt;next;      }    return -1;}void initQueue(LinkQueue *q) // 初始化一个空队列{    q-&gt;front = q-&gt;rear = (QueuePtr)malloc(sizeof(QNode));                             // 创建一个头结点，队头队尾指针指向该结点    if(!q-&gt;front) return;    // 创建头结点失败    q-&gt;front-&gt;next = NULL;   // 头结点指针域置NULL}void EnQueue(LinkQueue *q, int e){    QueuePtr p;    p = (QueuePtr)malloc(sizeof(QNode)); // 创建一个队列元素结点    if(p==NULL)return;                   // 创建元素结点失败    p-&gt;data = e;             // 将数据e存放到队列结点的data域中    p-&gt;next = NULL;          // 指针域置NULL    q-&gt;rear -&gt;next = p;      // 从队尾插入结点    q-&gt;rear = p;             // 修改队尾指针}void DeQueue(LinkQueue *q, int *e){                            // 如果队列q不为空，删除q的队头元素，用e返回其值    QueuePtr p;    if(q-&gt;front == q-&gt;rear) return;      // 队列为空，返回    p = q-&gt;front-&gt;next;                  // p指向队列的第一个元素    *e = p-&gt;data;                        // 将队首元素的数据赋值给e返回    q-&gt;front-&gt;next = p-&gt;next;            // 删除头结点    if(q-&gt;rear == p) q-&gt;rear = q-&gt;front; // 如果此时队列为空，则修改队尾指针    free(p);}int emptyQ(LinkQueue q) {    if (q.rear == q.front) {        return 1;    }    return 0;}</code></pre><p>无论那种搜索，都是通过对一个线性表进行处理，只不过是先处理头部还是尾部的问题罢了。处理头部优先的时候，也就是先加入的先探索，就是广度优先了，因为，头部的都是兄弟节点；而尾部的则是深度优先，因为放入尾部的都是刚刚生产出来的节点，后加入的先探索——也就是所谓一条路走到死。 同理可以联想到启发式搜索。启发式搜索就是先以你自定义的优先级处理，然后再以广度为优先级处理。 所以，归根结底，所谓的搜索，就是一种定义了优先级的枚举。</p><p>回溯算法一般使用深度优先搜索策略，在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</p><p>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。分支限界法因为不回溯，所以只是找出满足约束条件的一个解，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进。</p><p>附：邻接表与邻接矩阵的DFS、BFS比较</p><div class=pgc-img><img alt=数据结构｜图的邻接表与深度、广度优先搜索 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b49cda1eddf64b7db87de5e2c8b1f54f><p class=pgc-img-caption></p></div><p>附DFS、BFS（邻接矩阵）代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int VertexType;       // 顶点类型应由用户定义typedef int EdgeType;         // 边上的权值类型应由用户定义#define MAXSIZE  15           // 存储空间初始分配量#define MAXEDGE  15#define MAXVEX   10#define INFINITY 65535/* 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   */int arc[MAXVEX][MAXVEX]={	{0,1,0,1,0,0,0,0,0,0},{1,0,1,0,1,0,0,0,0,0},	{0,1,0,1,1,0,0,0,0,0},{1,0,1,0,0,0,0,0,0,0},	{0,1,1,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,1,0},	{0,0,0,0,0,1,0,0,1,1},{0,0,0,0,1,0,0,0,0,0},	{0,0,0,0,0,1,1,0,0,0},{0,0,0,0,0,0,1,0,0,0}};typedef struct{    VertexType vexs[MAXVEX];         // 顶点表    EdgeType arc[MAXVEX][MAXVEX];    // 邻接矩阵，可看作边表    int numVertexes, numEdges;       // 图中当前的顶点数和边数 }MGraph;typedef struct             // 循环队列顺序存储结构{    int data[MAXSIZE];    int front;             // 头指针    int rear;              // 尾指针，若队列不空，指向队列尾元素的下一个位置}Queue;void CreateMGraph(MGraph *G){    int i,j;    G-&gt;numEdges=15;    G-&gt;numVertexes=10;	for(i=0; i&lt;G-&gt;numVertexes; i++)        // 建立顶点表		G-&gt;vexs[i] = i;    for (i = 0; i &lt; G-&gt;numVertexes; i++)   // 初始化图    {        for (int j = 0; j &lt; G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=arc[i][j];        }    }} bool visited[MAXVEX];         // 访问标志的数组void DFS(MGraph G, int i)     // 邻接矩阵的深度优先递归算法{    visited[i] = true;    printf("%d ", G.vexs[i]); // 打印顶点，也可以其它操作    for(int j=0; j&lt;G.numVertexes; j++)        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])             DFS(G, j);       // i = j不断压栈}void DFSTraverse(MGraph G)       // 邻接矩阵的深度遍历操作{    for(int i=0; i&lt;G.numVertexes; i++)        visited[i] = false;       // 初始所有顶点状态都是未访问过状态    for(i=0; i&lt;G.numVertexes;i++)         if(!visited[i])          // 对未访问过的顶点调用DFS，若是连通图，只会执行一次             DFS(G, i);}bool InitQueue(Queue *Q);         // 初始化一个空队列Qbool QueueEmpty(Queue Q);         // 入队bool EnQueue(Queue *Q,int e);     // 出队bool DeQueue(Queue *Q,int *e);    // 删除Q中队头元素，用e返回其值void BFS(MGraph G,int i) {    Queue Q;    InitQueue(&amp;Q);                      printf("%d ", G.vexs[i]);    visited[i]=true;            EnQueue(&amp;Q,i);             while(!QueueEmpty(Q))        {       DeQueue(&amp;Q,&amp;i);           for(int j=0;j&lt;G.numVertexes;j++)        {           if(G.arc[i][j] == 1                  &amp;&amp; !visited[j])           {              visited[j]=true;                     printf("%d ", G.vexs[j]);              EnQueue(&amp;Q,j);                     }        }    }}void BFSTraverse(MGraph G)        // 邻接矩阵的广度遍历算法{    for(int i=0; i&lt;G.numVertexes; i++)        visited[i] = false;    for(i=0; i&lt;G.numVertexes; i++)      // 对每一个顶点做循环    {        if (!visited[i])                // 若是未访问过就处理        {           BFS(G,i);        }    }}int main(void){        MGraph G;    CreateMGraph(&amp;G);        printf("\n1.深度优先遍历：");    DFSTraverse(G);        printf("\n2.广度优先遍历：");    BFSTraverse(G);    getchar();getchar();    return 0;}/*1.深度优先遍历：0 1 2 3 4 5 6 8 9 72.广度优先遍历：0 1 3 2 4 5 6 7 8 9 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   */bool InitQueue(Queue *Q)  // 初始化一个空队列Q{    Q-&gt;front=0;    Q-&gt;rear=0;    return  true;}bool QueueEmpty(Queue Q){     if(Q.front==Q.rear)    // 队列空的标志        return true;    else        return false;}bool EnQueue(Queue *Q,int e){    if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)   // 队列满的判断        return false;    Q-&gt;data[Q-&gt;rear]=e;                    // 将元素e赋值给队尾    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;           // rear指针向后移一位置，                                           // 若到最后则转到数组头部    return  true;}bool DeQueue(Queue *Q,int *e)           // 删除Q中队头元素，用e返回其值{    if (Q-&gt;front == Q-&gt;rear)            // 队列空的判断        return false;    *e=Q-&gt;data[Q-&gt;front];               // 将队头元素赋值给e    Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;      // front指针向后移一位置，                                        // 若到最后则转到数组头部    return  true;}</code></pre><p>-End-</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','接表'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>