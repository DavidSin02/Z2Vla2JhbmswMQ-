<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>常见的排序算法简介 | 极客快訊</title><meta property="og:title" content="常见的排序算法简介 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e77b20f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e77b20f.html><meta property="article:published_time" content="2020-11-14T21:04:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:21+08:00"><meta name=Keywords content><meta name=description content="常见的排序算法简介"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1e77b20f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>常见的排序算法简介</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>排序的稳定性</p><p>因为待排序的记录序列中可能存在两个或两个以上的关键字相等的记录， 排序结果可能会存在不唯一的情况。所以就有稳定与不稳定的定义。</p><p>假设ki=kj( 1 =&lt; i &lt;= n,1 =&lt; j &lt;= n, i != j)，且在排序前的序列中ri领先于rj。如果排序后ri仍领先于rj，则称所用的排序方法是稳定的;反之，若可能使得排序后的序列中rj领先于ri，则称所用的排序方法是不稳定的。</p><p>只要有一组关键字发生类似情况，就可认为此排序方法是不稳定的。</p><p>内排序和外排序</p><p>根据在排序过程中待排序记录是否全部放在内存中，排序分为内排序和外排序。</p><p>内排序是在排序整个过程中，待排序的所有记录全部被放置在内存中。</p><p>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行。</p><p>对内排序来说，排序算法的性能主要有3个影响因素：</p><p>1、时间性能</p><p>排序算法的时间开销是衡量其好坏的最重要的标志。</p><p>在内排序中，主要进行两种操作：比较和移动。</p><p>高效率的内排序算法应该具有尽可能少的关键字比较次数和尽可能少的记录移动次数。</p><p>2、辅助空间</p><p>评估算法的另一个主要标准是执行算法所需要的辅助存储空间。</p><p>辅助存储空间是除了存放待排序所占用的存储空间外，执行算法所需要的其他存储空间。</p><p>3、算法的复杂性</p><p>指算法本身的复杂性，过于复杂的算法也会影响排序的性能。</p><p>接下来本文介绍各种排序算法。</p><p>1. 冒泡排序Bubble Sort</p><p>冒泡排序是一种交换排序，它的基本思想是：</p><p>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。</p><p>算法复杂度分析：</p><p>使用优化后的冒泡排序，最好的情况下，仅需要n - 1次比较，时间复杂度为O(n);最坏情况下，需要n(n - 1)/2次比较和交换;</p><p>所以平均时间复杂度为O(n2)。</p><p>2. 简单选择排序Simple Selection Sort</p><p>选择排序的基本思想：</p><p>每一次遍历时选取关键字最小的记录作为有序序列的第i个记录。</p><p>算法复杂度分析</p><p>简单选择排序最大的特点就是交换移动数据次数少，但它的比较次数是和数组本身是否有序是无关的，即无论最好最差的情况，都要进行n(n-1)/2次比较;在最好的情况下，不需要进行交换，在最坏的情况下，进行n-1次交换。</p><p>所以平均时间复杂度为O(n2)。</p><p>3. 直接插入排序Straight Insertion Sort</p><p>直接插入排序的基本操作：</p><p>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录递增1的有序表。</p><p>插入排序是进行值移动，而是不值交换。所以在量较小的情况下插入排序性能要优于冒泡和简单选择排序。</p><p>算法复杂度分析：</p><p>在最好的情况下，只需进行比较n - 1次，无需进行移动;</p><p>在最坏的情况下，比较(n + 2)(n - 1)/2次，交换(n + 4)(n - 1)/2次。</p><p>所以平均时间复杂度O(n2)</p><p>4. 二分插入排序Binary Insert Sort</p><p>二分(折半)插入排序是一种在直接插入排序算法上进行小改动的排序算法。其与直接排序算法最大的区别在于查找插入位置时使用的是二分查找的方式，在速度上有一定提升。</p><p>算法复杂度分析：</p><p>插入每个记录需要O(log i)比较，最多移动i+1次，最少2次。最佳情况O(n log n)，最差和平均情况O(n^2)。</p><p>总排序码比较次数比直接插入排序的最差情况好得多，但比最好情况要差，所元素初始序列已经按排序码接近有序时，直接插入排序比二分插入排序比较次数少</p><p>5. 希尔排序Shell Sort</p><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了。</p><p>更好的理解方式</p><p>将数组列在一个表中并对行排序(用插入排序)。重复这过程，不过每次用更小的列来进行。最后整个表就只有一列了。</p><p>将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序(通过增加索引的步长，例如是用i += step_size而不是i++)。</p><p>比如第一次放在5列中对每行使用快速排序排序，第二次放在3列中，最后放在1列中。类比于步长从5到3再到1。</p><p>算法复杂度分析</p><p>希尔排序的算法复杂度和增量序列有关，只要最终步长为1任何步长序列都可以工作。可以参加希尔排序。</p><p>6. 堆排序Heap Sort</p><p>堆</p><p>堆是具有下列性质的完全二叉树：</p><p>每个节点的值都大于或等于其左右孩子节点的值，成为大顶堆;</p><p>每个节点的值都小于或等于其左右孩子节点的值，成为小顶堆;</p><p>完全二叉树性质</p><p>按完全二叉树的性质，该树可以被顺序存储在数组中，按不同的角标进行表示。</p><p>即：</p><p>Parent(i) = (i-1)/2，i 的父节点下标</p><p>Left(i) = 2i + 1，i 的左子节点下标</p><p>Right(i) = 2(i + 1)，i 的右子节点下标</p><p>基本思想</p><p>将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆定的根节点，将它移走(与堆数组末尾元素交换)，再将剩余n-1个序列重新构造成一个堆，这样就会得到第二大值，以此类推，就能得到一个有序序列了。</p><p>算法复杂度分析</p><p>在构建堆时，对每个非叶子节点来说，最多进行2次比较和互换操作，复杂度为O(n);</p><p>在进行排序时，第i次取堆顶记录重新建堆需要用O(log i )时间，并需要取n-1次，所以重建堆的时间为O(nlogn)。</p><p>所以堆排序的时间复杂度为O(nlogn)。</p><p>实现步骤：</p><p>最大堆调整(Max_Heapify)：从堆的倒数第一个非叶子节点作调整，使得子节点永远小于父节点。没有必要从叶子节点开始，叶子节点可以看作是已符合堆特点的节点。</p><p>创建最大堆(Build_Max_Heap)：将堆所有数据重新排序</p><p>堆排序(HeapSort)：移除位在第一个数据的根节点，并做最大堆调整。</p><p>7. 归并排序Merge Sort</p><p>概念：</p><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的典型应用。</p><p>它指的是将两个已经排序的序列合并成一个序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序 , 可用于内排序，也可以用于外排序。这里仅对内排序的两路归并方法进行讨论。</p><p>算法思路</p><p>把 n 个记录看成 n 个长度为 l 的有序子表</p><p>进行两两归并使记录关键字有序，得到 n/2 个长度为 2 的有序子表</p><p>重复第 2 步直到所有记录归并成一个长度为 n 的有序表为止。</p><p>算法复杂度分析：</p><p>在最后一步，需要依次遍历两个已排序的好的数组，此时的时间复杂度为O(n)。</p><p>同时又进行着二路归并，形成一颗完全二叉树，此时整个排序需要进行log2n次。</p><p>所以归并排序的时间复杂度为O(nlogn)。这是它的最好、最坏、平均的时间性能。</p><p>8. 快速排序Quick Sort</p><p>基本思想</p><p>通过一趟排序将待排序记录分割成独立的两部分，其中一部分记录的关键字均比另一部分小，则可分别对这两部分记录继续进行排序，直到整个序列有序。</p><p>复杂度分析</p><p>最好情况：partition每次划分的都很均匀，如果排序n个关键字，其递归树的深度就为floor(log2n)+ 1次，此时的复杂度为O(nlogn)。</p><p>如果是最坏情况，每次partition都只操作一个数字，该递归树即为一颗斜树，比较次数为n(n - 1)/2，时间复杂度为O(n2)。</p><p>平均复杂度为O(nlogn)。</p><p>9. 桶排序Bucket Sort</p><p>基本思想</p><p>工作的原理是将数组分到有限数量的桶里。每个桶再个别排序(有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序)。</p><p>步骤</p><p>设置一个定量的数组当作空桶子。</p><p>寻访序列，并且把项目一个一个放到对应的桶子去。</p><p>对每个不是空的桶子进行排序。</p><p>从不是空的桶子里把项目再放回原来的序列中。</p><p>算法复杂度</p><p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：</p><p>O(N)+O(M*(N/M)log(N/M))=O(N+N(logN-logM))=O(N+N*logN-N*logM)</p><p>可以看出，最好情况即当N=M时，每个桶只有一个数据时，能够达到O(N)。</p><p>10. 计数排序Count Sort</p><p>基本思想</p><p>计数排序是一种稳定的线性时间排序算法。</p><p>计数排序使用一个额外的数组C，其中C数组的第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。</p><p>步骤：</p><p>找出待排序的数组中最大和最小的元素</p><p>统计数组中每个值为i的元素出现的次数，存入数组 C 的第 i 项</p><p>对所有的计数累加(从C中的第一个元素开始，每一项和前一项相加)</p><p>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p><p>算法复杂度分析</p><p>当输入的元素是n个0到k之间的整数时，它的运行时间是Θ(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。</p><p>由于用来计数的数组C的长度取决于待排序数组中数据的范围(等于待排序数组的最大值与最小值的差加上1)，这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><p>西安尚学堂 http://www.xasxt.com/</p><p>Java零基础就业班</p><p>上课地址：陕西省西安市高新区科技二路西安软件园天泽大厦五楼</p><p>咨询电话：029-62258374 QQ 2145598324</p><p>招生对象：</p><p>1. 零计算机编程基础学</p><p>2. 对行业不满意人士</p><p>3. 跨专业编程爱好者</p><p>4. 在校大学生实训</p><p>Java零基础班，10年 Java 以上开发经验技术讲师、架构师、行业大牛，亲自纯面授课程，手把手教你写编程。</p><p>10月新班免费试听课程已就绪，7天免费听课，体验Java乐趣。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'常见','简介','排序'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>