<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>​mysql AB 复制技术(主从),晓桂科技分享mysql_04/06 | 极客快訊</title><meta property="og:title" content="​mysql AB 复制技术(主从),晓桂科技分享mysql_04/06 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><meta property="article:published_time" content="2020-10-29T21:09:57+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:57+08:00"><meta name=Keywords content><meta name=description content="​mysql AB 复制技术(主从),晓桂科技分享mysql_04/06"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/1f6b6fd4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>​mysql AB 复制技术(主从),晓桂科技分享mysql_04/06</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>下面继续分享没有生气了数据库1-6节课，之04</p><p>mysql AB 复制技术(主从)<br></p><p>MySQL支持单向、异步(async)复制，复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</p><p>同步复制需要使用ndbcluster(各集群节点都可读可写)或者drbd(网络raid)这些技术，或者是新版mysql的半同步复制</p><p>mysql主 - - > mysql从</p><p>master slave</p><p>把主上的二进制日志(bin-log)的内容传到从上的一个新的日志叫relay-bin-log</p><p>从上的 IO 线程 负责传输</p><p>从上的 SQL 线程 负责从服务器解析日志</p><p>复制的过程：</p><p>1，slave端的IO线程连上master端，请求</p><p>2，master端返回给slave端，bin log文件名和位置信息</p><p>3，IO线程把master端的bin log内容依次写到slave端relay bin log里，并把master端的bin-log文件名和位置记录到master.info里。</p><p>4，salve端的sql线程，检测到relay bin log中内容更新，就会解析relay log里更新的内容，并执行这些操作；也就是说salve执行和master一样的操作而达到数据同步的目的；</p><p>客户</p><p>｜</p><p>｜</p><p>web程序，游戏程序（c,php,java.......)</p><p>|</p><p>|</p><p>代理层 (mysqlproxy,amoeba)</p><p>|</p><p>|</p><p>mysql主 ----> mysql从</p><p>思考：</p><p>1，主要打开二进制日志，从要不要开二进制日志?</p><p>从mysql可开可不开，要看情况</p><p>2，主和从的读写情况怎么做？</p><p>从不能写，从只能读；主可读可写；</p><p>所以有些时候做主只写，从只读，也就是读写分离</p><p>3，我做了读写分离的一主一从的架构，请问我前端的程序(web,游戏,业务等)如何来访问数据库</p><p>如果装前端web（假设phpwind)，填写数据库的IP为主的IP，那么这种情况，</p><p>mysql从就完全变成了一个实时备份的服务器，所有的读写全在主上</p><p>所以要在前端程序和数据库之间加入代理层程序，也就是填写的数据库IP不是主的也不是从的，</p><p>而是代理的，由代理来负责把写操作给主，读操作给从</p><p>4，关於单点故障的问题,如果从挂掉了，怎么解决？如果主挂掉了，怎么解决?</p><p>从挂掉了，那么主就要负责读和写的所有操作，由代理层帮你实现操作的转换。从修好后，直接启动，然后就自动读写分离，还是代理层自动实现操作转换.</p><p>主挂掉了（假设挂掉一个小时)，那么写操作肯定需要有人来做，只能是mysql从服务器来负责读和写操作。主修好启动后，写操作可以再给回主，但是从在这一小时内写的操作如何给主?(这里就比较麻烦，后面讲双主架构再讨论)</p><p>关于另几种架构的探讨：</p><p>一主多从</p><p>－－> salve</p><p>master －－> salve</p><p>－－> salve</p><p>写 读</p><p>--适合于以读为主的业务，使用多个salve分担读的压力，但要注意的是这种架构，salve越多，那么master复制的压力就越大</p><p>------------------------------------------------</p><p>多主一从 --这种架构不支持</p><p>主A phpwind</p><p>从C</p><p>主B discuz</p><p>------------------------------------------------</p><p>双主架构 master A &lt;－－> master B</p><p>phpwind discuz</p><p>1，会循环复制吗？</p><p>他们不会循环复制，因为做复制时会指定ID值，并且不一致</p><p>2，两边真的能同时写相同的数据吗?</p><p>不可以</p><p>如下表所示：</p><p>时间点 master A master B</p><p>1 a＝1改为a=2</p><p>2 a=1改为a=3</p><p>3 a的改变复制过来,并解析,a会又改为2</p><p>4 b的改变复制过来并解析,a又会改为3</p><p>问题产生，数据不一致</p><p>3，两边可以写不同的数据吗？</p><p>可以</p><p>可以通过业务程序层，指定一些表的写操作全在一端，另一些表的写操作全在另一端，也就是说两边不会同时写相同的表（当然这是理想状态，因为业务复杂的话会有表的联结等情况）</p><p>然后通过指定mysql复制的参数，一部分表或库会从A复制到B，另外一部分表或库从B复制到A就可以避免上面的问题了</p><p>或者两个库，一个库master A来写，另一个库master B来写</p><p>数据切分</p><p>----------------------------</p><p>前面三个问题也说明了双主架构的第一种应用（就是两边写不关联的数据，互相复制)，双主架构的第二种应用就是解决一主一从架构里主挂掉了的问题。</p><p>看下面的分析</p><p>mysql主 mysql从</p><p>思考：</p><p>问题1:如果一主一从，主挂了，slave能不能写，如果能写，主修好启起来后，salve写的数据如何传回给主?</p><p>答案:主挂了，slave应该要写，否则论坛不能发贴，只能看贴；</p><p>主修好后（假设一小时)，slave写了这一小时的数据应该要想办法传回主才行。</p><p>方法一：DBA人为的把salve这一小时写的数据找出来再导入到主(如果很多表，一小时的操作也非常多，可以说几乎不可能找出这小时改变了啥）</p><p>方法二：使用类似rsync的同步方法,这是通过存储层来实现数据同步回去，但效果没有验证过，无法说明</p><p>方法三:DBA人为的把从这一小时改变的二进制日志（要确认slave打开二进制日志)给找出来然后应用到主上去</p><p>问题2:上面的方法无论哪一种都会有一个问题，就是把从写的一小时数据传回给主需要一定的时间</p><p>就是假设这一小时slave创建了一个aaa表，主mysql修好启动后，</p><p>如果主马上接管从的写功能，这时前端程序马上给了一个insert into aaa的插入操作，这样肯定会出问题，因为创建aaa表的操作还没有从slave那传回来,如何解决?</p><p>解决方法一:人为控制主现在不能写，等slave的数据传回来后再写；但这样的话，等待时间太长了</p><p>解决方法二:就是把一主一从的架构改成双主的架构（假设master A和master B)</p><p>master A ---> master B (平时主B只读，不写，只有到主A挂了，才会写)</p><p>挂一个小时</p><p>读写一个小时</p><p>修复后启动了</p><p>把读给A 写留给B</p><p>问题3:但是改成双主后，master B在master A挂掉的一小时内帮他写了数据，A修好启起来后，B的数据可以自动传回A；但是如果数据量大的话，这个传回也可能需要一定时间，如果正好在这个传回时间内也出现了问题2的情况，又如何解决?</p><p>解决方法一:人为控制主不能写，这样的话等待时间很短（因为是自动传回来，跟手动导回来速度快很多)，影响不大</p><p>解决方法二:就直接把master B 做为新的写服务器，master A启动后，也只是做为读服务器；除非等下一次B挂了，A会重新成为写服务器（当然这是在两台服务器性能相等的情况下)</p><p>总结:上面说明双主架构的两种应用</p><p>-------------------------------------------------－－－－－</p><p>master C</p><p>| |</p><p>环型架构 master A －－ master B</p><p>--不可行</p><p>------------------------------------------------------</p><p>－－ salve －－ salve</p><p>级联架构 master －－ salve －－ salve</p><p>－－ salve －－ salve</p><p>bin-log bin-log ?</p><p>为了解决一主多从的master的复制压力</p><p>可以把slave做为下一级从机的master</p><p>增加复制的级联层次，造成的延迟更长</p><p>所以这种架构并不是很推荐，一般会进行分拆集群</p><p>--------------------------------------------------</p><p>双主和级联合起来</p><p>master ----salve --slave</p><p>|</p><p>| －－ slave</p><p>master －－ salve －－ slave</p><p>－－ slave</p><p>------------------------------------------------------</p><p>优化原则:分</p><p>大型结构的数据量太大，要用到数据切分(水平，垂直)</p><p>mysqlproxy</p><p>amoeba</p><p>---------------------------------------------------------</p><p>AB复制前准备</p><p>把两台mysql启起来（要求两台数据一致)</p><p>/etc/hosts里都加上主机名和IP对应，</p><p>时间同步好</p><p>防火墙,selinux检查一下</p><p>yum配置</p><p>mysql AB复制开始搭建</p><p>1,主从数据必须要同步</p><p>2,主：要启用二进制日志</p><p>3,主和从都要设置 server-id值，并且两边要不一样</p><p>4,需要建立一个用来复制的用户，并授于相应权限</p><p>master －－ slave</p><p>2.2.2.128 2.2.2.129</p><p>用rpm版的mysql来做：</p><p>第一步；改配置文件</p><p>master,2.2.2.128 上添加2行</p><p>vim /etc/my.cnf</p><p>［mysqld] --在mysqld参数组下添加2行</p><p>log-bin=mysql-bin --指定二进制日志的名字</p><p>server-id=2 --指定id，id值任意</p><p>slave,2.2.2.129 上添加1行</p><p>vim /etc/my.cnf</p><p>[mysqld] --在mysqld参数组下添加1行</p><p>server-id=3 --指定id，id值任意，与主不一样</p><p>然后重启服务</p><p>master,2.2.2.128 上重启：</p><p>/etc/init.d/mysqld restart</p><p>slave,2.2.2.129 上重启：</p><p>/etc/init.d/mysqld restart</p><p>第二步：授权</p><p>在master上做授权,super和replication slave都是复制要用的权限</p><p>mysql> grant super,replication slave on *.* to 'slave1'@'2.2.2.129' identified by '123';</p><p>用户@从的ip，允许从的ip连接主</p><p>mysql> flush privileges;</p><p>在slave上最好使用刚才授权的用户是远程登录一下主去验证一下</p><p># mysql -u slave1 -h 2.2.2.128 -p</p><p>第三步：查看master的正在写的二进制文件名和位置</p><p>mysql> flush tables with read lock; --先加锁，防止两边数据不一致;如果业务还未上线，这个就没有必要了</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>mysql> show master status; --只有打开二进制日志，这句命令才有结果，表示当前数据库的二进制日志写到什么位置</p><p>+------------------+----------+--------------+------------------+</p><p>| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |</p><p>+------------------+----------+--------------+------------------+</p><p>| mysql-bin.000003 | 336 | | |</p><p>+------------------+----------+--------------+------------------+</p><p>二进制文件名 正在写入的位置</p><p>slave端的配置</p><p>mysql> slave stop; --如果没有启过slave，这一步也是非必要的</p><p>Query OK, 0 rows affected, 1 warning (0.00 sec)</p><p>mysql> stop slave; --mysql5.6</p><p>Query OK, 0 rows affected, 1 warning (0.00 sec)</p><p>mysql> show warnings;</p><p>+-------+------+--------------------------------+</p><p>| Level | Code | Message |</p><p>+-------+------+--------------------------------+</p><p>| Note | 1255 | Slave already has been stopped |</p><p>+-------+------+--------------------------------+</p><p>mysql> change master to</p><p>-> master_user='slave1',</p><p>-> master_password='123',</p><p>-> master_host='2.2.2.128', --主的IP</p><p>-> master_port=3306, --端口，如果为3307就要换成3307</p><p>-> master_log_file='mysql-bin.000003', --主上面查到的文件名</p><p>-> master_log_pos=336; --主上面查到的位置号</p><p>mysql > mysql -u slave1 -h 2.2.2.128 -p123</p><p>mysql> change master to master_user='slave1', master_password='123', master_host='2.2.2.128', master_port=3306, master_log_file='mysql-bin.000003', master_log_pos=336;</p><p>mysql> start slave;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>mysql> show slave status\G</p><p>*************************** 1. row ***************************</p><p>Slave_IO_State: Waiting for master to send event</p><p>Master_Host: 2.2.2.128</p><p>Master_User: li</p><p>Master_Port: 3306</p><p>Connect_Retry: 60</p><p>Master_Log_File: mysql-bin.000001</p><p>Read_Master_Log_Pos: 681</p><p>Relay_Log_File: mysql55-relay-bin.000002</p><p>Relay_Log_Pos: 253</p><p>Relay_Master_Log_File: mysql-bin.000001</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: Yes --这里两个YES，表示两个线程OK</p><p>Replicate_Do_DB:</p><p>Replicate_Ignore_DB:</p><p>Replicate_Do_Table:</p><p>Replicate_Ignore_Table:</p><p>Replicate_Wild_Do_Table:</p><p>Replicate_Wild_Ignore_Table:</p><p>Last_Errno: 0</p><p>Last_Error:</p><p>Skip_Counter: 0</p><p>Exec_Master_Log_Pos: 681</p><p>Relay_Log_Space: 411</p><p>Until_Condition: None</p><p>Until_Log_File:</p><p>Until_Log_Pos: 0</p><p>Master_SSL_Allowed: No</p><p>Master_SSL_CA_File:</p><p>Master_SSL_CA_Path:</p><p>Master_SSL_Cert:</p><p>Master_SSL_Cipher:</p><p>Master_SSL_Key:</p><p>Seconds_Behind_Master: 0</p><p>Master_SSL_Verify_Server_Cert: No</p><p>Last_IO_Errno: 0</p><p>Last_IO_Error:</p><p>Last_SQL_Errno: 0</p><p>Last_SQL_Error:</p><p>Replicate_Ignore_Server_Ids:</p><p>Master_Server_Id: 2</p><p>1 row in set (0.00 sec)</p><p>...................................</p><p>回到master端解锁：</p><p>mysql> unlock tables;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>进行测试：</p><p>1，先比较主，从的数据目录文件的不同</p><p># ls /var/lib/mysql/ --master</p><p>ibdata1 ib_logfile1 mysql-bin.000001 mysql-bin.000003 mysql.sock</p><p>ib_logfile0 mysql mysql-bin.000002 mysql-bin.index test</p><p># ls /var/lib/mysql/ --slave</p><p>ibdata1 ib_logfile1 mysql mysqld-relay-bin.000002 mysql.sock test</p><p>ib_logfile0 master.info mysqld-relay-bin.000001 mysqld-relay-bin.index relay-log.info</p><p># cat /var/lib/mysql/master.info</p><p># cat /var/lib/mysql/relay-log.info</p><p># mysqlbinlog /var/lib/mysql/mysqld-relay-bin.000002</p><p>验证2：只有master写，slave可以看到</p><p>slave写，master看不到</p><p>如果复制出现问题</p><p>（要模拟问题的话，在从上创建一个库，然后在主上也创建这个库，就会冲突，造成复制出现问题），</p><p>重做复制集群只需要重新在从上执行stop slave; change master to ...... ; start slave;</p><p>验证3：把从重启后，再上去查看状态，还是连接的，没什么影响</p><p>把主重启后，再去slave上去查看状态，发现重试时间为60秒，等60秒后又自动连接OK了</p><p>--如果想要改这个60秒的话，可以把从服务器上的master.info文件里的60直接改成30(rpm版测试有点问题)</p><p>------------------------------------------------------------</p><p>一主多从的做法</p><p>就是上面的步骤有几个从就做几次</p><p>-------------------------------------------------------------------</p><p>双主架构的做法：</p><p>在上面的slave机也打开二进制日志，反着做一遍就行，注意做的过程中，保证数据一致</p><p>做好的架构，只要两边不同时操作相同的数据，就不会出现复制不一致的问题；</p><p>或者是在业务程序层，将一部分的写操作定义到master A,另一部分的写操作定义到master B</p><p>-------------------------------------------------------------</p><p>级联架构</p><p>master -slave -slave</p><p>把中间的从也要打开二进制日志。但是它默认不把应用master的操作记录到自己的二进制日志。所以需要打开一个参数让它记录，才可以传给第三级的从</p><p># /usr/local/mysql/bin/mysqld --verbo --help |grep log-slave</p><p>--log-slave-updates Tells the slave to log the updates from the slave thread</p><p>--log-slave-updates is used.</p><p>log-slave-updates FALSE</p><p>--默认值为false，所以需要在配置文件里加上log-slave-updates=1，然后重启服务</p><p>所以打开中间从的配置文件</p><p># vim /usr/local/mysql/etc/my.cnf --加上下面两句，然后重启服务</p><p>log-bin=mid-slave</p><p>log-slave-updates=1</p><p>然后在中间从和第三级的从之间再做一次AB复制就可以了</p><p>我的结构图</p><p>master A slave B slave C</p><p>2.2.2.128 2.2.2.129 2.2.2.130</p><p>sever-id=2 server-id=3 server-id=4</p><p>log-bin=mysql-bin-128 log-bin=mysql-bin-129</p><p>log-slave-updates=1</p><p>bin-log relay-bin-log relay-bin-log</p><p>bin-log ------> relay-bin-log</p><p>打开log-slave-updates=1</p><p>让第一台传过来relay日志记录</p><p>到自己的二进制日志</p><p>bin-log -------> relay-bin-log</p><p>==============================================================</p><p>关于控制复制的库和表的相关参数讨论：</p><p>Replicate_Do_DB: --接受哪个库的复制</p><p>Replicate_Ignore_DB: --忽略哪个库的复制</p><p>Replicate_Do_Table: --接受哪个表的复制</p><p>Replicate_Ignore_Table: --忽略哪个表的复制</p><p>Replicate_Wild_Do_Table: --通配符表示复制哪些表</p><p>Replicate_Wild_Ignore_Table: --通配符表示忽略哪些表</p><p>实例说明：</p><p>master A slave B</p><p>1，先把两台做成ab复制的架构</p><p>2，在master a上创建aaa库及其里面的aaa表，bbb库及其里面的bbb表</p><p>那么slave b里也会复制产生这两张测试表</p><p>3，现在的业务需求是：</p><p>我在slave b上要求复制的为aaa库里所有表；bbb库及其所有表不要求复制过去</p><p>4，在slave b的my.cnf配置文件的[mysqld]参数组里加上</p><p>replicate_do_db=aaa --只接受aaa库的复制</p><p>replicate_ignore_db=bbb --忽略bbb库的复制</p><p>5，重启slave b，然后测试</p><p>测试结果为</p><p>在master a上操作：</p><p>use aaa;</p><p>insert into aaa values ....;</p><p>slave b上可以看到insert的记录 --OK</p><p>在master a 上操作：</p><p>use bbb;</p><p>insert into bbb values ....;</p><p>slave b上看不到insert的记录 --OK；但这里的操作还是会记录到slave b的relay-bin-log里</p><p>在master a上操作：</p><p>use bbb;</p><p>insert into aaa.aaa values ....;</p><p>slave b上却看不到insert的操作 --有问题</p><p>--原因是：它默认只会复制在aaa库下对它下面的表的操作；而别的库下对aaa库下表的操作会忽略</p><p>6，解决方法：</p><p>在slave b上把第4步做的两个参数换成下面两个</p><p>replicate_wild_do_table=aaa.%</p><p>replicate_wild_ignore_table=bbb.%</p><p>再把slave b重启；就不会出现刚才的问题了</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>搭建环境 两台虚拟机</p><p>master －－ slave</p><p>先安装mysql5.5之后的版本，因为这个版本之后才实现的半同步复制</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>MySQL的复制其实是异步操作，而不是同步，也就意味着允许主从之间的数据存在一</p><p>定的延迟，mysql当初这样设计的目的也是基于可用性的考虑，为了保证master</p><p>不受slave的影响，并且异步复制使得master处于一种性能最优的状态：</p><p>写完binlog后即可提交而不需要等待slave的操作完成。这样存在一个隐患，当你使用slave作为备份时，</p><p>如果master挂掉，那么会存在部分已提交的事务未能成功传输到slave的可能，这就意味着数据丢失！</p><p>所谓的半同步复制就是master每commit一个事务,要slave应用这个事物后回给master信号。这样master才能把事物成功commit。这样就保证了master-slave的数据绝对的一致（但是以牺牲master的性能为代价).但等待时间也是可以调整的。</p><p>mysql半同步复制等待时间超时后(默认时间为10秒)，会自动转换成异步复制</p><p>--下面的步骤用5.6.26版测试是一样的做法</p><p>（注意5.6.x版本默认以mysql@localhost登录的，你要-u root来指定以root@localhost登录就可以了)</p><p>搭建好 mysqlAB异步复制后</p><p>在master上安装这个插件</p><p>master> install plugin rpl_semi_sync_master soname 'semisync_master.so';</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>--删除插件的方法 mysql > uninstall plugin rpl_semi_sync_master;</p><p>master> show global variables like 'rpl_semi_sync%'; --安装OK后，主上会多几个参数</p><p>+------------------------------------+-------+</p><p>| Variable_name | Value |</p><p>+------------------------------------+-------+</p><p>| rpl_semi_sync_master_enabled | OFF | --是否启用master的半同步复制</p><p>| rpl_semi_sync_master_timeout | 10000 | --默认主等待从返回信息的超时间时间，10秒。</p><p>| rpl_semi_sync_master_trace_level | 32 | --监控</p><p>| rpl_semi_sync_master_wait_no_slave | ON | --是否允许每个事物的提交都要等待slave的信号.on为每一个事物都等待</p><p>+------------------------------------+-------+</p><p>在slave上安装插件</p><p>slave> install plugin rpl_semi_sync_slave soname 'semisync_slave.so';</p><p>Query OK, 0 rows affected (0.03 sec)</p><p>slave> show global variables like 'rpl_semi_sync%';</p><p>+---------------------------------+-------+</p><p>| Variable_name | Value |</p><p>+---------------------------------+-------+</p><p>| rpl_semi_sync_slave_enabled | OFF |</p><p>| rpl_semi_sync_slave_trace_level | 32 |</p><p>+---------------------------------+-------+</p><p>master上激活半同步复制</p><p>master> set global rpl_semi_sync_master_enabled =on;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>slave上激活半同步复制</p><p>slave> set global rpl_semi_sync_slave_enabled=on;</p><p>slave> stop slave IO_THREAD;</p><p>slave> start slave IO_THREAD;</p><p>在master查看状态</p><p>master > show global status like 'rpl_semi_sync%';</p><p>+--------------------------------------------+-------+</p><p>| Variable_name | Value |</p><p>+--------------------------------------------+-------+</p><p>| Rpl_semi_sync_master_clients | 1 | --有一个从服务器启用半同步复制</p><p>| Rpl_semi_sync_master_net_avg_wait_time | 0 | --master等待slave回复的平均等待时间。单位毫秒</p><p>| Rpl_semi_sync_master_net_wait_time | 0 | --master总的等待时间。单位毫秒</p><p>| Rpl_semi_sync_master_net_waits | 0 | --master等待slave回复的总的等待次数</p><p>| Rpl_semi_sync_master_no_times | 0 | --master关闭半同步复制的次数</p><p>| Rpl_semi_sync_master_no_tx | 0 | --master 等待超时的次数</p><p>| Rpl_semi_sync_master_status | ON | --标记master现在是否是半同步复制状态</p><p>| Rpl_semi_sync_master_timefunc_failures | 0 | --master调用时间（如gettimeofday())失败的次数</p><p>| Rpl_semi_sync_master_tx_avg_wait_time | 0 | --master花在每个事务上的平均等待时间</p><p>| Rpl_semi_sync_master_tx_wait_time | 0 | --master花在事物上总的等待时间</p><p>| Rpl_semi_sync_master_tx_waits | 0 | --master事物等待次数</p><p>| Rpl_semi_sync_master_wait_pos_backtraverse | 0 | --后来的先到了，而先来的还没有到的次数</p><p>| Rpl_semi_sync_master_wait_sessions | 0 | --当前有多少个session因为slave回复而造成等待</p><p>| Rpl_semi_sync_master_yes_tx | 0 | --标记slave是否在半同步状态</p><p>+--------------------------------------------+-------+</p><p>在slave上查看状态就只有下面一条信息</p><p>slave > show global status like 'rpl_semi_sync%';</p><p>+----------------------------+-------+</p><p>| Variable_name | Value |</p><p>+----------------------------+-------+</p><p>| Rpl_semi_sync_slave_status | ON |</p><p>+----------------------------+-------+</p><p>测试：</p><p>master > insert into a values (3);</p><p>Query OK, 1 row affected (0.01 sec)</p><p>master > show global status like 'rpl_semi_sync%_yes_tx';</p><p>+-----------------------------+-------+</p><p>| Variable_name | Value |</p><p>+-----------------------------+-------+</p><p>| Rpl_semi_sync_master_yes_tx | 1 | --表示这次事物成功从slave返回一次确认信号</p><p>+-----------------------------+-------+</p><p>模拟错误，把slave上的mysql停掉/etc/init.d/mysql56 stop</p><p>--再回到master上测试</p><p>master> insert into a values (4);</p><p>Query OK, 1 row affected (10.00 sec) --这次插入一个值需要等待10秒（默认的等待时间)</p><p>master> insert into a values (5);</p><p>Query OK, 1 row affected (0.01 sec) --现在自动转成了原来的异步模式（类似oracle DG里的最大性能模式)</p><p>再次把slave启动，看到半同步复制没启来，是异步模式</p><p>重新按下面的步骤把同步模式再启起来就可以了</p><p>slave> set global rpl_semi_sync_slave_enabled=on;</p><p>slave> stop slave IO_THREAD;</p><p>slave> start slave IO_THREAD;</p><p>slave启起来后，查看表，发现刚才slave关闭期间的那几条数据还是会自动复制过来，数据又回到一致</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>mysql的延时复制</p><p>异步或同步复制</p><p>A ----------> B</p><p>|</p><p>|-------> C</p><p>延时1天</p><p>假设在A上误删除一条数据，用二进制日志来恢复不太方便，因为日志里记录的是删除的操作，并没有记录这条数据具体是什么，所以你要在所有的日志里找到当初插入这条数据时的记录，这是很麻烦的。</p><p>也有别的方法，就是把误删除之前的备份在测试库上恢复，然后把数据找出来，并导回来</p><p>备份 改1 改2 删除</p><p>0 8 12 16</p><p>delete from emp where ename='zhangsan';</p><p>drop table emp;</p><p>误删除1张表,用二进制日志来恢复,不太好找相关的数据,因为这张表如果使用了好几年,数据操作太多;有延时复制的话,在C上导出这张表,导回A</p><p>误删除最近一段时间相关的数据,用二进制日志找到那个时间点,从那个时间点恢复到现在</p><p>mysql开源管理工具</p><p>maatkit --perl写的，老外常用</p><p># ls /share/soft/maatkit/</p><p>maatkit-7410[1].tar.gz maatkit-7540[1].tar.gz</p><p>maatkit-7486[1].tar.gz</p><p>--在mysql AB的slave上安装（只需要在slave上安装)</p><p># tar xf /share/soft/maatkit/maatkit-7540\[1\].tar.gz -C /usr/src/</p><p># cd /usr/src/maatkit-7540/</p><p>安装方法README文件里有写</p><p># perl Makefile.PL --如果不成功，需要安装perl有关的多个包，可以yum install perl*</p><p># make install</p><p>[root@li maatkit-7540]# ls bin/ --这些命令，就是各个管理工具</p><p>mk-archiver mk-purge-logs</p><p>mk-checksum-filter mk-query-advisor</p><p>mk-config-diff mk-query-digest</p><p>mk-deadlock-logger mk-query-profiler</p><p>mk-duplicate-key-checker mk-show-grants</p><p>mk-error-log mk-slave-delay</p><p>mk-fifo-split mk-slave-find</p><p>mk-find mk-slave-move</p><p>mk-heartbeat mk-slave-prefetch</p><p>mk-index-usage mk-slave-restart</p><p>mk-kill mk-table-checksum</p><p>mk-loadavg mk-table-sync</p><p>mk-log-player mk-table-usage</p><p>mk-merge-mqd-results mk-tcp-model</p><p>mk-parallel-dump mk-upgrade</p><p>mk-parallel-restore mk-variable-advisor</p><p>mk-profile-compact mk-visual-explain</p><p>--使用--help查看一个命令的使用方法</p><p># mk-slave-delay --help</p><p>mk-slave-delay starts and stops a slave server as needed to make it lag behind</p><p>the master. The SLAVE-HOST and MASTER-HOST use DSN syntax, and values are</p><p>copied from the SLAVE-HOST to the MASTER-HOST if omitted. For more details,</p><p>please use the --help option, or try 'perldoc /usr/bin/mk-slave-delay' for</p><p>complete documentation.</p><p># perldoc /usr/bin/mk-slave-delay --查看文档</p><p>或者直接man mk-slave-delay</p><p>--mysql AB(无论同步或异步)正在运行OK的情况下，使用下面的命令在slave上运行;做之间建议把时间同步一下</p><p># mk-slave-delay --defaults-file=/usr/local/mysql56/etc/my.cnf --delay=1m --interval=15s --user=root --password=123 --socket=/var/run/mysqld/mysql56.socket --quiet localhost &</p><p>--表示延时1分钟，才会应用SQL线程；这里是测试所以才使用很小的时间，实际情况可以调成1小时或2小时</p><p>测试：</p><p>在master上随便插入几条数据</p><p>然后在slave上发现没有马上同步过来</p><p>slave > show slave status\G; --查看状态会发现SQL线程状态为NO</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: NO</p><p>大概等1分钟，就会自动延时同步过来了；</p><p>--注意:日志已经传到slave的relay-bin log里了，但由SQL线程延时去解析</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>原理理解题</p><p>题1</p><p>mysql架构中,一主多从，双主，级联（多主一从和环型不支持)这三种的区别和优缺点</p><p>题2</p><p>如果现在一个小公司mysql数据库已经跑了一年，现在要搭建mysqlAB复制，你检查了主库后，发现它这一年都没有使用二进制日志，请问如何做复制？</p><p>1,先主库开二进制日志</p><p>2,备份主库，恢复到从库</p><p>3，做AB复制，指定从备份的position往后复制</p><p>题3</p><p>在实际的大数据量的数据库中，因为负载太高或者网络问题，现在造成复制时的数据延时，请问你如何做为DBA应该如何去处理？</p><p>架构扩展性</p><p>题4</p><p>如果一个lamp架构在深圳机房在运行，如何尽量无影响的把这个lamp迁移到惠州的机房</p><p>1，在惠州机房做一个lamp，mysql双主架构，web做rsync远程实时同步</p><p>2，把网站域名对应的IP地址A记录改成惠州的IP</p><p>3，当深圳机房服务器无连接时，就可以关闭深圳机房的服务器了</p><p>题5</p><p>做mysqlAB复制不能同读同写，如果有几个分公司，各分公司都有mysql数据库，要求，各地mysql数据同步，并且各地都能读能写。</p><p>ndbcluster</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'mysql','AB','主从'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>