<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>常见的七种加密算法以及实现 | 极客快訊</title><meta property="og:title" content="常见的七种加密算法以及实现 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4c8625eceeb7427ba545ea05ae7784fc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/21207e9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><meta property="article:published_time" content="2020-10-29T20:52:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:29+08:00"><meta name=Keywords content><meta name=description content="常见的七种加密算法以及实现"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/21207e9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>常见的七种加密算法以及实现</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=heading>前言</h1><p><strong>数字签名</strong>、<strong>信息加密</strong> 是前后端开发都经常需要使用到的技术，应用场景包括了用户登入、交易、信息通讯、oauth 等等，不同的应用场景也会需要使用到不同的签名加密算法，或者需要搭配不一样的 <strong>签名加密算法</strong> 来达到业务目标。这里简单的给大家介绍几种常见的签名加密算法和一些典型场景下的应用。</p><h1 class=heading>正文</h1><h2 class=heading>1. 数字签名</h2><p><strong>数字签名</strong>，简单来说就是通过提供 <strong>可鉴别</strong> 的 <strong>数字信息</strong> 验证 <strong>自身身份</strong> 的一种方式。一套 <strong>数字签名</strong> 通常定义两种 <strong>互补</strong> 的运算，一个用于 <strong>签名</strong>，另一个用于 <strong>验证</strong>。分别由 <strong>发送者</strong> 持有能够 <strong>代表自己身份</strong> 的 <strong>私钥</strong> (私钥不可泄露),由 <strong>接受者</strong> 持有与私钥对应的 <strong>公钥</strong> ，能够在 <strong>接受</strong> 到来自发送者信息时用于 <strong>验证</strong> 其身份。</p><div class=pgc-img><img alt=常见的七种加密算法以及实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c8625eceeb7427ba545ea05ae7784fc><p class=pgc-img-caption></p></div><blockquote><p><strong>注意</strong>：图中 <strong>加密过程</strong> 有别于 <strong>公钥加密</strong>，更多 介绍戳这里。<strong>签名</strong> 最根本的用途是要能够唯一 <strong>证明发送方的身份</strong>，防止 <strong>中间人攻击</strong>、CSRF <strong>跨域身份伪造</strong>。基于这一点在诸如 <strong>设备认证</strong>、<strong>用户认证</strong>、<strong>第三方认证</strong> 等认证体系中都会使用到 <strong>签名算法</strong> (彼此的实现方式可能会有差异)。</p></blockquote><h2 class=heading>2. 加密和解密</h2><h3 class=heading>2.1. 加密</h3><p><strong>数据加密</strong> 的基本过程，就是对原来为 <strong>明文</strong> 的文件或数据按 <strong>某种算法</strong> 进行处理，使其成为 <strong>不可读</strong> 的一段代码，通常称为 <strong>“密文”</strong>。通过这样的途径，来达到 <strong>保护数据</strong> 不被 <strong>非法人窃取</strong>、阅读的目的。</p><h3 class=heading>2.2. 解密</h3><p><strong>加密</strong> 的 <strong>逆过程</strong> 为 <strong>解密</strong>，即将该 <strong>编码信息</strong> 转化为其 <strong>原来数据</strong> 的过程。</p><h2 class=heading>3. 对称加密和非对称加密</h2><p>加密算法分 <strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密 <strong>密钥相同</strong>，非对称加密算法的加密密钥与解密 <strong>密钥不同</strong>，此外，还有一类 <strong>不需要密钥</strong> 的 <strong>散列算法</strong>。</p><blockquote><p>常见的 <strong>对称加密</strong> 算法主要有 DES、3DES、AES 等，常见的 <strong>非对称算法</strong> 主要有 RSA、DSA 等，<strong>散列算法</strong> 主要有 SHA-1、MD5 等。</p></blockquote><h3 class=heading>3.1. 对称加密</h3><p><strong>对称加密算法</strong> 是应用较早的加密算法，又称为 <strong>共享密钥加密算法</strong>。在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，<strong>发送</strong> 和 <strong>接收</strong> 双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。这就要求加密和解密方事先都必须知道加密的密钥。</p><div class=pgc-img><img alt=常见的七种加密算法以及实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30ca907198994721b43f457f42328f4b><p class=pgc-img-caption></p></div><ol start=1><li>数据加密过程：在对称加密算法中，<strong>数据发送方</strong> 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。</li><li>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</li></ol><h3 class=heading>3.2. 非对称加密</h3><p><strong>非对称加密算法</strong>，又称为 <strong>公开密钥加密算法</strong>。它需要两个密钥，一个称为 <strong>公开密钥</strong> (public key)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (private key)，即 <strong>私钥</strong>。</p><p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p><div class=pgc-img><img alt=常见的七种加密算法以及实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a59b76fd28214d379a6500a48c28a09c><p class=pgc-img-caption></p></div><ol start=1><li>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</li><li>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</li></ol><blockquote><p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p></blockquote><h2 class=heading>4. 常见的签名加密算法</h2><h3 class=heading>4.1. MD5算法</h3><p>MD5 用的是 <strong>哈希函数</strong>，它的典型应用是对一段信息产生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。严格来说，MD5 不是一种 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。无论是多长的输入，MD5 都会输出长度为 128bits 的一个串 (通常用 16 <strong>进制</strong> 表示为 32 个字符)。</p><pre><code>public static final byte[] computeMD5(byte[] content) {    try {        MessageDigest md5 = MessageDigest.getInstance("MD5");        return md5.digest(content);    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}</code></pre><h3 class=heading>4.2. SHA1算法</h3><p>SHA1 是和 MD5 一样流行的 <strong>消息摘要算法</strong>，然而 SHA1 比 MD5 的 <strong>安全性更强</strong>。对于长度小于 2 ^ 64 位的消息，SHA1 会产生一个 160 位的 <strong>消息摘要</strong>。基于 MD5、SHA1 的信息摘要特性以及 <strong>不可逆</strong> (一般而言)，可以被应用在检查 <strong>文件完整性</strong> 以及 <strong>数字签名</strong> 等场景。</p><pre><code>public static byte[] computeSHA1(byte[] content) {    try {        MessageDigest sha1 = MessageDigest.getInstance("SHA1");        return sha1.digest(content);    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}</code></pre><h3 class=heading>4.3. HMAC算法</h3><p>HMAC 是密钥相关的 <strong>哈希运算消息认证码</strong>（Hash-based Message Authentication Code），HMAC 运算利用 <strong>哈希算法</strong> (MD5、SHA1 等)，以 <strong>一个密钥</strong> 和 <strong>一个消息</strong> 为输入，生成一个 <strong>消息摘要</strong> 作为 <strong>输出</strong>。</p><p>HMAC <strong>发送方</strong> 和 <strong>接收方</strong> 都有的 key 进行计算，而没有这把 key 的第三方，则是 <strong>无法计算</strong> 出正确的 <strong>散列值</strong>的，这样就可以 <strong>防止数据被篡改</strong>。</p><pre><code>package net.pocrd.util;import net.pocrd.annotation.NotThreadSafe;import net.pocrd.define.ConstField;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Arrays;@NotThreadSafepublic class HMacHelper {    private static final Logger logger = LoggerFactory.getLogger(HMacHelper.class);    private Mac mac;    /**     * MAC算法可选以下多种算法     * HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512     */    private static final String KEY_MAC = "HmacMD5";    public HMacHelper(String key) {        try {            SecretKey secretKey = new SecretKeySpec(key.getBytes(ConstField.UTF8), KEY_MAC);            mac = Mac.getInstance(secretKey.getAlgorithm());            mac.init(secretKey);        } catch (Exception e) {            logger.error("create hmac helper failed.", e);        }    }    public byte[] sign(byte[] content) {        return mac.doFinal(content);    }        public boolean verify(byte[] signature, byte[] content) {        try {            byte[] result = mac.doFinal(content);            return Arrays.equals(signature, result);        } catch (Exception e) {            logger.error("verify sig failed.", e);        }        return false;    }}</code></pre><blockquote><p><strong>测试结论</strong>：HMAC 算法实例在 <strong>多线程环境</strong> 下是 <strong>不安全的</strong>。但是需要在 <strong>多线程访问</strong> 时，进行同步的辅助类，使用 ThreadLocal 为 <strong>每个线程缓存</strong> 一个实例可以避免进行锁操作。</p></blockquote><h3 class=heading>4.4. AES/DES/3DES算法</h3><p>AES、DES、3DES 都是 <strong>对称</strong> 的 <strong>块加密算法</strong>，<strong>加解密</strong> 的过程是 <strong>可逆的</strong>。常用的有 AES128、AES192、AES256 (默认安装的 JDK 尚不支持 AES256，需要安装对应的 jce 补丁进行升级 jce1.7，jce1.8)。</p><h4 class=heading>4.4.1. DES算法</h4><p>DES 加密算法是一种 <strong>分组密码</strong>，以 64 位为 <strong>分组对数据</strong> 加密，它的 <strong>密钥长度</strong> 是 56 位，<strong>加密解密</strong> 用 <strong>同一算法</strong>。</p><p>DES 加密算法是对 <strong>密钥</strong> 进行保密，而 <strong>公开算法</strong>，包括加密和解密算法。这样，只有掌握了和发送方 <strong>相同密钥</strong> 的人才能解读由 DES加密算法加密的密文数据。因此，破译 DES 加密算法实际上就是 <strong>搜索密钥的编码</strong>。对于 56 位长度的 <strong>密钥</strong> 来说，如果用 <strong>穷举法</strong> 来进行搜索的话，其运算次数为 2 ^ 56 次。</p><h4 class=heading>4.4.2. 3DES算法</h4><p>是基于 DES 的 <strong>对称算法</strong>，对 <strong>一块数据</strong> 用 <strong>三个不同的密钥</strong> 进行 <strong>三次加密</strong>，<strong>强度更高</strong>。</p><h4 class=heading>4.4.3. AES算法</h4><p>AES 加密算法是密码学中的 <strong>高级加密标准</strong>，该加密算法采用 <strong>对称分组密码体制</strong>，密钥长度的最少支持为 128 位、 192 位、256 位，分组长度 128 位，算法应易于各种硬件和软件实现。这种加密算法是美国联邦政府采用的 <strong>区块加密标准</strong>。</p><p>AES 本身就是为了取代 DES 的，AES 具有更好的 <strong>安全性</strong>、<strong>效率</strong> 和 <strong>灵活性</strong>。</p><pre><code>import net.pocrd.annotation.NotThreadSafe;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;@NotThreadSafepublic class AesHelper {    private SecretKeySpec keySpec;    private IvParameterSpec iv;    public AesHelper(byte[] aesKey, byte[] iv) {        if (aesKey == null || aesKey.length &lt; 16 || (iv != null &amp;&amp; iv.length &lt; 16)) {            throw new RuntimeException("错误的初始密钥");        }        if (iv == null) {            iv = Md5Util.compute(aesKey);        }        keySpec = new SecretKeySpec(aesKey, "AES");        this.iv = new IvParameterSpec(iv);    }    public AesHelper(byte[] aesKey) {        if (aesKey == null || aesKey.length &lt; 16) {            throw new RuntimeException("错误的初始密钥");        }        keySpec = new SecretKeySpec(aesKey, "AES");        this.iv = new IvParameterSpec(Md5Util.compute(aesKey));    }    public byte[] encrypt(byte[] data) {        byte[] result = null;        Cipher cipher = null;        try {            cipher = Cipher.getInstance("AES/CFB/NoPadding");            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);            result = cipher.doFinal(data);        } catch (Exception e) {            throw new RuntimeException(e);        }        return result;    }    public byte[] decrypt(byte[] secret) {        byte[] result = null;        Cipher cipher = null;        try {            cipher = Cipher.getInstance("AES/CFB/NoPadding");            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);            result = cipher.doFinal(secret);        } catch (Exception e) {            throw new RuntimeException(e);        }        return result;    }    public static byte[] randomKey(int size) {        byte[] result = null;        try {            KeyGenerator gen = KeyGenerator.getInstance("AES");            gen.init(size, new SecureRandom());            result = gen.generateKey().getEncoded();        } catch (Exception e) {            throw new RuntimeException(e);        }        return result;    }}</code></pre><h3 class=heading>4.5. RSA算法</h3><p>RSA 加密算法是目前最有影响力的 <strong>公钥加密算法</strong>，并且被普遍认为是目前 <strong>最优秀的公钥方案</strong> 之一。RSA 是第一个能同时用于 <strong>加密</strong> 和 <strong>数字签名</strong> 的算法，它能够 <strong>抵抗</strong> 到目前为止已知的 <strong>所有密码攻击</strong>，已被 ISO 推荐为公钥数据加密标准。</p><blockquote><p>RSA <strong>加密算法</strong> 基于一个十分简单的数论事实：将两个大 <strong>素数</strong> 相乘十分容易，但想要对其乘积进行 <strong>因式分解</strong> 却极其困难，因此可以将 <strong>乘积</strong> 公开作为 <strong>加密密钥</strong>。</p></blockquote><pre><code>import net.pocrd.annotation.NotThreadSafe;import org.bouncycastle.jce.provider.BouncyCastleProvider;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.KeyFactory;import java.security.Security;import java.security.Signature;import java.security.interfaces.RSAPrivateCrtKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;@NotThreadSafepublic class RsaHelper {    private static final Logger logger = LoggerFactory.getLogger(RsaHelper.class);    private RSAPublicKey publicKey;    private RSAPrivateCrtKey privateKey;    static {        Security.addProvider(new BouncyCastleProvider()); //使用bouncycastle作为加密算法实现    }    public RsaHelper(String publicKey, String privateKey) {        this(Base64Util.decode(publicKey), Base64Util.decode(privateKey));    }    public RsaHelper(byte[] publicKey, byte[] privateKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }            if (privateKey != null &amp;&amp; privateKey.length &gt; 0) {                this.privateKey = (RSAPrivateCrtKey)keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public RsaHelper(String publicKey) {        this(Base64Util.decode(publicKey));    }    public RsaHelper(byte[] publicKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] encrypt(byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        if (content == null) {            return null;        }        try {            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            int size = publicKey.getModulus().bitLength() / 8 - 11;            ByteArrayOutputStream baos = new ByteArrayOutputStream((content.length + size - 1) / size * (size + 11));            int left = 0;            for (int i = 0; i &lt; content.length; ) {                left = content.length - i;                if (left &gt; size) {                    cipher.update(content, i, size);                    i += size;                } else {                    cipher.update(content, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] decrypt(byte[] secret) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        if (secret == null) {            return null;        }        try {            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");            cipher.init(Cipher.DECRYPT_MODE, privateKey);            int size = privateKey.getModulus().bitLength() / 8;            ByteArrayOutputStream baos = new ByteArrayOutputStream((secret.length + size - 12) / (size - 11) * size);            int left = 0;            for (int i = 0; i &lt; secret.length; ) {                left = secret.length - i;                if (left &gt; size) {                    cipher.update(secret, i, size);                    i += size;                } else {                    cipher.update(secret, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            logger.error("rsa decrypt failed.", e);        }        return null;    }    public byte[] sign(byte[] content) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        if (content == null) {            return null;        }        try {            Signature signature = Signature.getInstance("SHA1WithRSA");            signature.initSign(privateKey);            signature.update(content);            return signature.sign();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public boolean verify(byte[] sign, byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        if (sign == null || content == null) {            return false;        }        try {            Signature signature = Signature.getInstance("SHA1WithRSA");            signature.initVerify(publicKey);            signature.update(content);            return signature.verify(sign);        } catch (Exception e) {            logger.error("rsa verify failed.", e);        }        return false;    }}</code></pre><h3 class=heading>4.6. ECC算法</h3><p>ECC 也是一种 <strong>非对称加密算法</strong>，主要优势是在某些情况下，它比其他的方法使用 <strong>更小的密钥</strong>，比如 RSA <strong>加密算法</strong>，提供 <strong>相当的或更高等级</strong> 的安全级别。不过一个缺点是 <strong>加密和解密操作</strong> 的实现比其他机制 <strong>时间长</strong> (相比 RSA 算法，该算法对 CPU 消耗严重)。</p><pre><code>import net.pocrd.annotation.NotThreadSafe;import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;import org.bouncycastle.jce.provider.BouncyCastleProvider;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.KeyFactory;import java.security.Security;import java.security.Signature;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;@NotThreadSafepublic class EccHelper {    private static final Logger logger = LoggerFactory.getLogger(EccHelper.class);    private static final int SIZE = 4096;    private BCECPublicKey  publicKey;    private BCECPrivateKey privateKey;    static {        Security.addProvider(new BouncyCastleProvider());    }    public EccHelper(String publicKey, String privateKey) {        this(Base64Util.decode(publicKey), Base64Util.decode(privateKey));    }    public EccHelper(byte[] publicKey, byte[] privateKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (BCECPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }            if (privateKey != null &amp;&amp; privateKey.length &gt; 0) {                this.privateKey = (BCECPrivateKey)keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey));            }        } catch (ClassCastException e) {            throw new RuntimeException("", e);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public EccHelper(String publicKey) {        this(Base64Util.decode(publicKey));    }    public EccHelper(byte[] publicKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (BCECPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] encrypt(byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        try {            Cipher cipher = Cipher.getInstance("ECIES", "BC");            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            int size = SIZE;            ByteArrayOutputStream baos = new ByteArrayOutputStream((content.length + size - 1) / size * (size + 45));            int left = 0;            for (int i = 0; i &lt; content.length; ) {                left = content.length - i;                if (left &gt; size) {                    cipher.update(content, i, size);                    i += size;                } else {                    cipher.update(content, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] decrypt(byte[] secret) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        try {            Cipher cipher = Cipher.getInstance("ECIES", "BC");            cipher.init(Cipher.DECRYPT_MODE, privateKey);            int size = SIZE + 45;            ByteArrayOutputStream baos = new ByteArrayOutputStream((secret.length + size + 44) / (size + 45) * size);            int left = 0;            for (int i = 0; i &lt; secret.length; ) {                left = secret.length - i;                if (left &gt; size) {                    cipher.update(secret, i, size);                    i += size;                } else {                    cipher.update(secret, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            logger.error("ecc decrypt failed.", e);        }        return null;    }    public byte[] sign(byte[] content) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        try {            Signature signature = Signature.getInstance("SHA1withECDSA", "BC");            signature.initSign(privateKey);            signature.update(content);            return signature.sign();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public boolean verify(byte[] sign, byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        try {            Signature signature = Signature.getInstance("SHA1withECDSA", "BC");            signature.initVerify(publicKey);            signature.update(content);            return signature.verify(sign);        } catch (Exception e) {            logger.error("ecc verify failed.", e);        }        return false;    }}</code></pre><h2 class=heading>5. 各种加密算法对比</h2><h3 class=heading>5.1. 散列算法比较</h3><p>名称 安全性 速度 SHA-1 高 慢 MD5 中 快</p><h3 class=heading>5.2. 对称加密算法比较</h3><p>名称 密钥名称 运行速度 安全性 资源消耗 DES 56位 较快 低 中 3DES 112位或168位 慢 中 高 AES 128、192、256位 快 高 低</p><h3 class=heading>5.3. 非对称加密算法比较</h3><p>名称 成熟度 安全性 运算速度 资源消耗 RSA 高 高 中 中 ECC 高 高 慢 高</p><h3 class=heading>5.4. 对称算法与非对称加密算法</h3><h4 class=heading>5.4.1. 对称算法</h4><ol start=1><li><strong>密钥管理</strong>：比较难，不适合互联网，一般用于内部系统</li><li><strong>安全性</strong>：中</li><li><strong>加密速度</strong>：快好 <strong>几个数量级</strong> (软件加解密速度至少快 100 倍，每秒可以加解密数 M <strong>比特</strong> 数据)，适合大数据量的加解密处理</li></ol><h4 class=heading>5.4.2. 非对称算法</h4><ol start=1><li><strong>密钥管理</strong>：密钥容易管理</li><li><strong>安全性</strong>：高</li><li><strong>加密速度</strong>：比较慢，适合 <strong>小数据量</strong> 加解密或数据签名</li></ol><h1 class=heading>小结</h1><p>本文介绍了 <strong>数字签名</strong>，<strong>加密和解密</strong>，<strong>对称加密和非对称加密</strong>，然后详细介绍了 MD5，SHA-1，HMAC，DES/AES，RSA 和 ECC 这几种加密算法和代码示例。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'加密算法','常见','七种'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>