<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>对比着学 Go 语言-基础：面向对象编程之接口 | 极客快訊</title><meta property="og:title" content="对比着学 Go 语言-基础：面向对象编程之接口 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2122bafb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2122bafb.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="对比着学 Go 语言-基础：面向对象编程之接口"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2122bafb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>对比着学 Go 语言-基础：面向对象编程之接口</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Go 语言的接口至关重要。在 Go 语言出现之前，接口主要作为不同组件之间的契约存在。对契约的实现是强制的，必须声明确实实现了该接口。</p><p>Go 接口的优势应对了侵入式接口导致的问题，它解决了需要提前规划接口的问题。接口设计的方面有 5 个部分：</p><ul><li>接口赋值</li><li>接口查询</li><li>类型查询</li><li>接口组合</li><li>Any 类型</li></ul><p>为了实现一个接口，需要从接口继承：</p><pre><code>interface IFoo {  void Bar();}class Foo implements IFoo { // Java 文法  // ...}class Foo : public IFoo{ // C++ 文法  // ...}IFoo* foo = new Foo</code></pre><p>即使另外有一个接口 IFoo2 实现了与 IFoo 完全一样的接口方法甚至名字也叫 IFoo 只不过位于不同的名字空间下，编译器也会认为上面的类 Foo 只实现了 IFoo 而没有实现 IFoo2 接口。</p><p>这类接口我们称为侵入式接口。侵入式的主要表现在于实现类需要明确声明自己实现了某个接口。这种强制型的接口继承是面向对象编程思想发展过程中一个被质疑的特性。</p><p>设想我们现在需要实现一个简单搜索引擎，它需要依赖两个模块儿，一个是哈希表，一个是HTML分析器。</p><p>基于模块设计的单向依赖原则，</p><p><br></p><pre><code>Read(buf []byte) (n int, err error)Write(buf []byte) (n int, err error)Seek(off int64, whence int) (pos int64, err error)Close() error</code></pre><p><br></p><p>在 Go 语言中，一个类只需要实现了接口要求的所有函数，就是这个类实现了该接口。</p><pre><code>type File struct { // ... }func (f *File) Read(buf []byte) (n int, err error)func (f *File) Write(buf []byte) (n int, err error)func (f *File) Seek(off int64, whence int) (pos int64, err error)func (f *File) Close() error</code></pre><p>这里定义了一个 File 类，并实现有 Read()、Write()、Seek()、Close() 等方法。</p><pre><code>type IFile interface {    Read(buf []byte) (n int, err error)    Write(buf []byte) (n int, err error)    Seek(off int64, whence int) (pos int64, err error)    Close() error}type IReader interface {  Read(buf []byte) (n int, err error)}type IWriter interface {  Write(buf []byte) (n int, err error)}type ICloser interface {  Close() error }</code></pre><p>尽管 File 类并没有从这些接口继承，甚至可以不知道这些接口的存在，但是 File 类实现了这些接口，可以进行赋值：</p><pre><code>var file1 IFile = new(File)var file2 IReader = new(File)var file3 IWriter = new(File)var file4 ICloser = new(File)</code></pre><p><br></p><p>Go 语言的非侵入式接口，</p><ul><li>Go 语言的标准库再也不需要绘制类库的继承树图。在 Go 中，类的继承树并无意义，只需要知道这个类实现了哪些方法，每个方法是啥含义。</li><li>实现类的时候，只需关心自己应该提供哪些方法，不用再纠结接口需要拆得多细才合理。接口由使用方按需定义，而不用事前规划。</li><li>不用为了实现一个接口而导入一个包</li></ul><h1 class=pgc-h-arrow-right>接口赋值</h1><p>接口赋值分为 2 种：</p><ul><li>将对象实例赋值给接口</li><li>将一个接口赋值给另一个接口</li></ul><p><strong>将对象实例赋值给接口</strong></p><p>这要求该对象实例实现了接口要求多所有方法，</p><pre><code>type Integer intfunc (a Integer) Less (b Integer) bool {     return a &lt; b}func (a *Integer) Add (b Integer) {     *a += b }</code></pre><p>相应地，定义接口 LessAdder, 如下：</p><pre><code>type LessAdder interface {     Less(b Integer) bool     Add(b Integer)}</code></pre><p>现在有个问题：假设我们定义一个 Integer 类型的对象实例，怎么将其赋值给 LessAdder 接口呢？应该用下面的语句 1，还是语句 2 呢？</p><pre><code>var a Integer = 1var b LessAdder = &a (1)var b LessAdder = a  (2)</code></pre><p>答案是应该用语句 1。原因在于，Go 语言可以根据下面的函数：</p><pre><code>func (a Integer) Less (b Integer) bool</code></pre><p>自动生成一个新的 Less () 方法：</p><pre><code>func (a *Integer) Less (b Integer) bool {     return (*a).Less(b) }</code></pre><p>这样，类型 *Integer 就既存在 Less() 方法，也存在 Add() 方法，满足 LessAdder 接口。而从另一个方面来说，根据</p><pre><code>func (a *Integer) Add (b Integer)</code></pre><p>这个函数无法自动生成以下这个成员方法:</p><pre><code>func (a Integer) Add (b Integer) {    (&a).Add(b) }</code></pre><p>因为 (&a).Add() 改变的只是函数参数 a, 对外部实际要操作的对象并无影响，这不符合用户的预期。所以，Go 语言不会自动为其生成该函数。因此，类型 Integer 只存在 Less() 方法，缺少 Add() 方法，不满足 LessAdder 接口，故此上面的语句 2 不能赋值。</p><p><br></p><p><strong>将一个接口赋值给另一个接口</strong></p><p>在 Go 语言中，只要两个接口拥有相同的方法列表，次序不同不要紧，那么它们就是等同的，可以相互赋值。</p><p>下面是第一个接口：</p><pre><code>package onetype ReadWriter interface {     Read(buf []byte) (n int, err error)     Write(buf []byte) (n int, err error)}</code></pre><p>第二个接口</p><pre><code>package twotype IStream interface {    Write(buf []byte) (n int, err error)    Read(buf []byte) (n int, err error)}</code></pre><p>这里定义了两个接口，一个叫 one.ReadWriter, 一个叫 two.Istream, 两者都定义了 Read()、Write() 方法，只是定义次序相反。</p><p>在 Go 语言中，这两个接口实际上并无区别，因为:</p><ul><li>任何实现了 one.ReadWriter 接口的类，均实现了 two.IStream</li><li>任何 one.ReadWriter 接口对象可赋值给 two.IStream, 反之亦然</li><li>在任何地方使用 one.ReadWriter 接口与使用 two.IStream 并无差异</li></ul><p>以下代码都可编译通过:</p><pre><code>var file1 two.IStream = new(File)var file2 one.ReadWriter = file1var file3 two.IStream = file2</code></pre><p>接口赋值并不要求两个接口等价。如果接口 A 的方法列表是接口 B 的方法列表的子集，那么接口 B 可以赋值给接口 A。</p><h1 class=pgc-h-arrow-right>接口查询</h1><pre><code>var file1 Writer = ...if file5, ok := file1.(two.IStream); ok {   ... }</code></pre><p>这个语句检查 file1 接口指向的对象实例是否实现了 two.IStream 接口，如果实现了，则执行特定的代码。</p><p>接口查询是否成功，要在运行期才能够确定。它不像接口赋值，编译器只需要通过静态类型检查即可判断赋值是否可行。Go 语言可以完全了解一个组件。</p><pre><code>var file1 Writer = ...if file6, ok := file1.(*File); ok {   ... }</code></pre><h1 class=pgc-h-arrow-right>类型查询</h1><p>在 Go 语言中，更加直接了当的查询对象实例的类型。</p><pre><code>var v1 interface{} = ...switch v := v1.(type) {  case int:  case string:  ...}</code></pre><p><br></p><pre><code>type Stringer interface {     String() string}func Println(args ...interface{}) {  for _, arg := range args {    switch v := v1.(type) {      case int: // 现在 v 的类型是 int      case string: // 现在 v 的类型是 string      default:        if v, ok := arg.(Stringer); ok {// 现在 v 的类型是 Stringer           val := v.String()           // ...        } else {          // ...        }    }  }  }    </code></pre><p>与此类似的是 Go 语言标准库中的 Println() 。它会更复杂，在内部采用穷举法，将每个类型转换为字符串进行打印。</p><p><br></p><h1 class=pgc-h-arrow-right>接口组合</h1><p>接口也可以进行组合。在标准库中有:</p><ul><li>io.Reader</li><li>io.Writer</li></ul><p>同时，在 io 包中，还存在一个接口 io.ReadWriter</p><pre><code>type ReadWriter interface {     Reader     Writer}</code></pre><p>这个接口组合了 Reader 和 Writer 两个接口。</p><p>等效的写法还有</p><pre><code>type ReadWriter interface {     Read(p []byte) (n int, err error)     Write(p []byte) (n int, err error)}</code></pre><h1 class=pgc-h-arrow-right>Any类型</h1><p>Go 语言中的 interface{} 看起来像是可以指向任何对象的 Any 类型，任何对象实例都满足空接口 interface{} 。</p><pre><code>var v1 interface{} = 1 // 将 int 类型赋值给 interface{}var v2 interface{} = &#34;abc&#34; // 将 string 类型赋值给 interface{}var v3 interface{} = &v2 // 将 *interface{} 类型赋值给 interface{}var v4 interface{} = struct{X int}{1}var v5 interface{} = &struct{X int}{1}</code></pre><p>当函数可以接受任意的对象实例时，可以把它声明为 interface{} 。</p><p>典型的例子就是 Printf(), Println()：</p><pre><code>func Printf(fmt string, args ...interface{})func Println(args ...interface{})...</code></pre><p>interface{} 刚开始是一无所知，但可以通过接口查询和类型查询逐步了解它。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'着学','Go','语言'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>