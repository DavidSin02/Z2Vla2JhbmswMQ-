<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>汇编语言常用指令大全 | 极客快訊</title><meta property="og:title" content="汇编语言常用指令大全 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f2cd27512af249c593b8c26673fb800f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22b4d76.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22b4d76.html><meta property="article:published_time" content="2020-10-29T21:00:26+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:26+08:00"><meta name=Keywords content><meta name=description content="汇编语言常用指令大全"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/22b4d76.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>汇编语言常用指令大全</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>MOV</strong> 指令为双操作数指令,两个操作数中必须有一个是寄存器.</p><p><br></p><p>MOV DST , SRC // Byte / Word</p><p>执行操作: dst = src</p><p>1.目的数可以是通用寄存器, 存储单元和段寄存器(但不允许用CS段寄存器).</p><p>2.立即数不能直接送段寄存器</p><p>3.不允许在两个存储单元直接传送数据</p><p>4.不允许在两个段寄存器间直接传送信息</p><p><strong>PUSH</strong> 入栈指令及<strong>POP</strong>出栈指令: 堆栈操作是以“后进先出”的方式进行数据操作.</p><p>PUSH SRC //Word</p><p>入栈的操作数除不允许用立即数外，可以为通用寄存器，段寄存器(全部)和存储器.</p><p>入栈时高位字节先入栈，低位字节后入栈.</p><p>POP DST //Word</p><p>出栈操作数除不允许用立即数和CS段寄存器外, 可以为通用寄存器,段寄存器和存储器.</p><p>执行POP SS指令后,堆栈区在存储区的位置要改变.</p><p>执行POP SP 指令后,栈顶的位置要改变.</p><p><strong>XCHG</strong>(eXCHanG)交换指令: 将两操作数值交换.</p><p>XCHG OPR1, OPR2 //Byte/Word</p><p>执行操作: Tmp=OPR1 OPR1=OPR2 OPR2=Tmp</p><p>1.必须有一个操作数是在寄存器中</p><p>2.不能与段寄存器交换数据</p><p>3.存储器与存储器之间不能交换数据.</p><p><strong>XLAT</strong>(TRANSLATE)换码指令: 把一种代码转换为另一种代码.</p><p>XLAT (OPR 可选) //Byte</p><p>执行操作: AL=(BX+AL)</p><p>指令执行时只使用预先已存入BX中的表格首地址,执行后,AL中内容则是所要转换的代码.</p><p><strong>LEA</strong>(Load Effective Address) 有效地址传送寄存器指令</p><p>LEA REG , SRC //指令把源操作数SRC的有效地址送到指定的寄存器中.</p><p>执行操作: REG = EAsrc</p><p>注: SRC只能是各种寻址方式的存储器操作数,REG只能是16位寄存器</p><p>MOV BX , OFFSET OPER_ONE 等价于 LEA BX , OPER_ONE</p><p>MOV SP , [BX] //将BX间接寻址的相继的二个存储单元的内容送入SP中</p><p>LEA SP , [BX] //将BX的内容作为存储器有效地址送入SP中</p><p><strong>LDS</strong>(Load DS with pointer)指针送寄存器和DS指令</p><p>LDS REG , SRC //常指定SI寄存器。</p><p>执行操作: REG=(SRC), DS=(SRC+2) //将SRC指出的前二个存储单元的内容送入指令中指定的寄存器中，后二个存储单元送入DS段寄存器中。</p><p><strong>LES</strong> (Load ES with pointer) 指针送寄存器和ES指令</p><p>LES REG , SRC //常指定DI寄存器</p><p>执行操作: REG=(SRC) , ES=(SRC+2) //与LDS大致相同,不同之处是将ES代替DS而已.</p><p><strong>LAHF </strong>( Load AH with Flags ) 标志位送AH指令</p><p>LAHF //将PSW寄存器中的低8位的状态标志(条件码)送入AH的相应位, SF送D7位, ZF送D6位......</p><p>执行操作: AH=PSW的低位字节。</p><p><strong>SAHF</strong> ( Store AH into Flags ) AH送标志寄存器指令</p><p>SAHF //将AH寄存器的相应位送到PSW寄存器的低8位的相应位, AH的D7位送SF, D6位送ZF......</p><p>执行操作: PSW的低位字节=AH。</p><p><strong>PUSHF</strong> ( PUSH the Flags) 标志进栈指令</p><p>PUSHF //将标志寄存器的值压入堆栈顶部, 同时栈指针SP值减2</p><p>执行操作: SP=SP-1,(SP)=PSW的高8位, SP=SP-1, (SP)=PSW的低8位</p><p><strong>POPF</strong> ( POP the Flags ) 标志出栈指令</p><p>POPF //与PUSHF相反, 从堆栈的顶部弹出两个字节送到PSW寄存器中, 同时堆栈指针值加2</p><p>执行操作: PSW低8位=(SP), SP=SP+1, PSW高8位=(SP) , SP=SP+1</p><p>输入输出指令(<strong>IN,OUT</strong>)：只限于使用累加器AX或AL与外部设备的端口传送信息.</p><p>IN (INput)输入指令：信息从I/O通过累加器传送到CPU</p><p>IN AL , PORT //直接的字节输入,PORT是外设端口编号(即端口地址),只能取 00H ~ 0FFH共256个端口地址.</p><p>IN AX , PORT //直接的字输入,AX存储连续两个端口地址PORT+1,PORT</p><p>IN AL , DX //间接的字节输入,端口地址范围可通过DX设置为0000H ~ 0FFFFH共65536个端口地址</p><p>IN AX , DX //间接的字输入</p><p>OUT( OUTput)输出指令 ：信息从CPU通过累加器传送到I/O</p><p>OUT PORT , AL //直接的字节输出,PORT规定与IN指令相同.</p><p>OUT PORT , AX</p><p>OUT DX , AL //间接的字节输出</p><p>OUT DX , AX</p><p>MOV AL,05H OUT 27H, AL //将字节05H传送到地址27H的端口</p><p><strong>ADD</strong>(ADD)加法指令</p><p>ADD DST , SRC //Byte/Word</p><p>执行操作: dst=dst+src</p><p>1.两个存储器操作数不能通过ADD指令直接相加, 即DST 和SRC必须有一个是通用寄存器操作数.</p><p>2.段寄存器不能作为SRC 和DST.</p><p>3.影响标志位Auxiliary Crray Flag ,Carry Flag, Overflow Flag, Parity Flag, Sign Flag 和Zero Flag ,如下所示：</p><p>CF 根据最高有效位是否有进(借)位设置的：有进(借)位时CF=1, 无进(借)位时CF=0.</p><p>OF 根据操作数的符号及其变化来设置的：若两个操作数的符号相同,而结果的符号与之相反时OF=1, 否则为0.</p><p>ZF 根据结果来设置：不等于0时ZF=0, 等于0时ZF=1</p><p>SF 根据结果的最高位来设置：最高位为0, 则SF=0.</p><p>AF 根据相加时D3是否向D4进(借)位来设置：有进(借)位时AF=1, 无进(借)位时AF=0</p><p>PF 根据结果的1的个数时否为奇数来设置：1的个数为奇数时PF=0, 为偶数时PF=1</p><p><strong>ADC</strong>( ADd with Carry)带进位加法指令</p><p>ADC DST , SRC //Byte/Word</p><p>执行操作: dst=dst+src+CF //与ADD不同之处是还要加上进位标志位的值.</p><p><strong>INC</strong> ( INCrement) 加1指令</p><p>INC OPR //Byte/Word</p><p>执行操作: OPR=OPR+1</p><p>1.OPR可以是寄存器和存储器操作数, 但不能是立即数和段寄存器</p><p>2.影响标志位OF,SF,ZF,PF 和AF,不影响CF.</p><p><strong>SUB</strong> ( SUBtract ) 不带借位的减法指令</p><p>SUB DST , SRC //Byte/Word</p><p>执行操作：dst=dst - src</p><p>1.DST和SRC寻址方式及规定与ADD相同.</p><p>2.影响全部标志位.(判断标志位参见ADD)</p><p><strong>SBB </strong>( SuBtract with Borrow) 带借位减法指令</p><p>SBB DST , SRC //Byte/Word</p><p>执行操作：dst= dst - src - CF</p><p><strong>DEC</strong> ( DECrement ) 减1指令</p><p>DEC OPR //Byte/Word</p><p>执行操作：OPR = OPR - 1 //除CF标志位, 其余标志位都受影响.</p><p><strong>NEG</strong> ( NEGate ) 求补指令</p><p>NEG OPR</p><p>执行操作：opr = 0- opr //将操作数按位求反后末位加1.</p><p><strong>CMP </strong>( CoMPare ) 比较指令</p><p>CMP OPR1 , OPR2</p><p>执行操作：OPR1 - OPR2 //与SUB指令一样执行运算, 但不保存结果.</p><p>比较情况 无符号数 有符号数</p><p>A=B ZF=1 ZF=1</p><p>A>B CF=0 && ZF=0 SF^OF=0 && ZF=0</p><p>A&lt;B CF=1 && ZF=0 SF^OF=1 && ZF=0</p><p>A>=B CF=0 || ZF=1 SF^OF=0 || ZF=1</p><p>A&lt;=B CF=1 || ZF=1 SF^OF=1 || ZF=1</p><p><strong>MUL</strong> ( unsigned MULtiple ) 无符号数乘法指令</p><p>MUL SRC //Byte/Word .</p><p>执行操作：Byte => AX= AL *src //字节运算时目的操作数用AL, 乘积放在AX中</p><p>Word => DX=AX *src //字运算时目的操作数用AX, DX存放乘积的高位字, AX放乘积的低位字</p><p>1.目的数必须是累加器 AX 或AL,指令中不需写出</p><p>2. 源操作数SRC可以是通用寄存器和各种寻址方式的存储器操作数, 而绝对不允许是立即数或段寄存器.</p><p><strong>IMUL</strong> (sIgned MULtiple) 有符号数乘法指令</p><p>IMUL SRC //与MUL指令相同,但必须是带符号数</p><p><strong>DIV </strong>( unsigned DIVide) 无符号数除法指令</p><p>DIV SRC //Byte/Word 其中: SRC的规定同乘法指令MUL</p><p>执行操作：Byte => AX / src //字节运算时目的操作数在AX中,结果的商在AL中 ,余数在AH中</p><p>Word=> DX,AX /src //字运算时目的操作数在DX高位字和AX低位字中,结果的商在AX中 ,余数在DX中</p><p>存储器操作数必须指明数据类型：BYTE PTR src 或 WORD PTR src</p><p><strong>IDIV </strong>(sIgned DIVied) 有符号数除法指令</p><p>IDIV SRC //Byte/Word 与DIV指令相同,但必须是带符号数</p><p><strong>CBW</strong> (Convert Byte to Word) 字节转换为字指令</p><p>CBW</p><p>执行操作: AL中的符号位(D7)扩展到8位AH中,若AL中的D7=0，则AH=00H,若AL中的D7=1,则AH=FFH.</p><p><strong>CWD</strong> (Convert Word to Double word) 字转换为双字指令</p><p>CWD</p><p>执行操作: AX中的符号位(D15)扩展到16位DX中,若AX中的D15=0，则DX=0000H,若AX中的D15=1,则DX=FFFFH</p><p>十进制调整指令</p><p>当计算机进行计算时,必须先把十进制数转换为二进制数,再进行二进制数运算,最后将结果又转换为十进制数输出.</p><p>在计算机中,可用4位二进制数表示一位十进制数,这种代码称为BCD ( Binary Coded Decimal ).</p><p>BCD码又称8421码,在PC机中,BCD码可用压缩的BCD码和非压缩的BCD码两种格式表示.</p><p>压缩的BCD码用4位二进制数表示一个十制数,整个十进数形式为一个顺序的以4位为一组的数串.</p><p>非压缩的BCD码以8位为一组表示一个十进制数,8位中的低4位表示8421的BCD码,而高4位则没有意义.</p><p>压缩的BCD码调整指令</p><p><strong>DAA</strong> (Decimal Adjust for Addition) 加法的十进制调整指令</p><p>DAA</p><p>执行操作:执行之前必须先执行ADD或ADC指令,加法指令必须把两个压缩的BCD码相加,并把结果存话在AL寄存器中.</p><p><strong>DAS</strong> (Decimal Adjust for Subtraction) 减法的十进制调整指令</p><p>DAS</p><p>执行操作:执行之前必须先执行SUB或SBB指令,减法指令必须把两个压缩的BCD码相减,并氢结果存放在AL寄存器中.</p><p>非压缩的BCD码调整指令</p><p><strong>AAA</strong> (ASCII Adjust for Addition) 加法的ASCII调整指令</p><p>AAA</p><p>执行操作:执行之前必须先执行ADD或ADC指令,加法指令必须把两个非压缩的BCD码相加,并把结果存话在AL寄存器中.</p><p><strong>AAS</strong> (ASCII Adjust for Subtraction) 减法的ASCII调整指令</p><p>AAS</p><p>执行操作:执行之前必须先执行SUB或SBB指令,减法指令必须把两个非压缩的BCD码相减,并氢结果存放在AL寄存器中.</p><p><strong>MOVS</strong> ( MOVe String) 串传送指令</p><p>MOVB //字节串传送 DF=0, SI = SI + 1 , DI = DI + 1 ；DF = 1 , SI = SI - 1 , DI = DI - 1</p><p>MOVW //字串传送 DF=0, SI = SI + 2 , DI = DI + 2 ；DF = 1 , SI = SI - 2 , DI = DI - 2</p><p>执行操作：[DI] = [SI] ,将位于DS段的由SI所指出的存储单元的字节或字传送到位于ES段的由DI 所指出的存储单元,再修改SI和DI, 从而指向下一个元素.</p><p>在执行该指令之前,必须预置SI和DI的初值,用STD或CLD设置DF值.</p><p>MOVS DST , SRC //同上,不常用,DST和SRC只是用来用类型检查,并不允许使用其它寻址方式来确定操作数.</p><p>1.目的串必须在附加段中,即必须是ES:[DI]</p><p>2.源串允许使用段跨越前缀来修饰,但偏移地址必须是[SI].</p><p><strong>STOS</strong> (STOre into String) 存入串指令</p><p>STOS DST</p><p>STOSB //存放字节串 ( DI ) = AL</p><p>STOSW //存放字串 ( DI ) = AX</p><p>执行品作：把AL或AX中的内容存放由DI指定的附加段的字节或字单元中,并根据DF值修改及数据类型修改DI的内容.</p><p>1.在执行该指令之前,必须把要存入的数据预先存入AX或AL中,必须预置DI的初值.</p><p>2.DI所指向的存储单元只能在附加段中,即必须是ES:[DI]</p><p><strong>LODS </strong>( LOaD from String ) 从串取指令</p><p>LODS SRC</p><p>LODSB //从字节串取 AL=(SI)</p><p>LODSW //从字串取 AX= (SI±1) (SI)</p><p>执行操作：把由SI指定的数据段中字节或字单元的内容送入AL或AX中,并根据DF值及数据类型修改SI的内容.</p><p>1.在执行该指令之前,要取的数据必须在存储器中预先定义(用DB或DW),必须预置SI的初值.</p><p>2.源串允许使用段超越前缀来改变数据存储的段区.</p><p><strong>REP</strong> (REPeat)重复操作前缀</p><p>REP String Primitive //其中:String Primitive可为MOVS,STOS或LODS指令</p><p>执行操作：使REP前缀后的串指令重复执行,每执行一次CX=CX-1,直至CX=0时退出REP.</p><p>方向标志设置</p><p><strong>CLD</strong> (CLear Direction flag) 清除方向标志指令</p><p>CLD</p><p>执行操作：令DF=0, 其后[SI],[DI]执行增量操作</p><p><strong>STD</strong> (SeT Direction flag) 设置方向标志指令</p><p>STD</p><p>执行操作：令DF=1, 其后[SI],[DI]执行减量操作</p><p><strong>CMPS</strong> (CoMPare String) 串比较指令</p><p>CMPS SRC , DST</p><p>CMPSB //字节串比较 (SI)-(DI)</p><p>CMPSW //字串比较 (SI+1)(SI) - (DI+1)(DI)</p><p>执行操作：把由SI指向的数据段中的一个字节或字与由DI指向的附加段中的一个字节或字相减,不保留结果,只根据结果置标志位.</p><p><strong>SCAS </strong>(SCAn String ) 串扫描指令</p><p>SCAS DST</p><p>SCASB</p><p>SCASW</p><p>执行操作：把AX或AL的内容与由DI指向的在附加段中的一个字节或字相减,不保留结果,根据结果置标志位.</p><p><strong>AND, OR , XOR</strong> 和 <strong>TEST</strong>都是双字节操作指令,操作数的寻址方式的规定与算术运算指令相同.</p><p><strong>NOT</strong>是单字节操作指令,不允许使用立即数.</p><p>逻辑运算均是按位进行操作,真值表如下:</p><p>AND (位与&) OR ( 位或| ) XOR ( 位异或^ )</p><p>1 & 1 = 1 1 | 1 = 1 1 ^ 1 = 0</p><p>1 & 0 = 0 1 | 0 = 1 1 ^ 0 = 1</p><p>0 & 1 = 0 0 | 1 = 1 0 ^ 1 = 1</p><p>0 & 0 = 0 0 | 0 = 0 0 ^ 0 = 0</p><p>A：逻辑运算指令</p><p><strong>AND</strong> (and) 逻辑与指令</p><p>AND DST , SRC //Byte/Word</p><p>执行操作：dst = dst & src</p><p>1.AND指令执行后,将使CF=0,OF=0,AF位无定义,指令执行结果影响SF,ZF和PF标志位.</p><p>2.AND指令典型用法A：用于屏蔽某些位,即使某些位为0.</p><p>屏蔽AL的高4位:即将高4位和0000B相与,低4位和1111B相与</p><p>MOV AL , 39H //AL= 0011 1001B[39H]</p><p>ADD AL , 0FH // AL= 0000 1001B[09H] 即0011 1001B[39H] & 0000 1111B[0FH] = 0000 1001B[09H]</p><p>3.AND指令典型用法B:取出某一位的值(见TEST)</p><p><strong>OR</strong> (or) 逻辑或指令</p><p>OR DST , SRC //Byte/Word</p><p>执行操作：dst = dst | src</p><p>1.OR指令执行后,将使CF=0, OF=0, AF位无定义,指令执行结果影响SF, ZF和PF标志位.</p><p>2.常用于将某些位置1.</p><p>将AL的第5位置1:</p><p>MOV AL , 4AH // AL=0100 1010B[4AH]</p><p>OR AL , 10H // AL=0101 1010B[5AH] 即0100 1010B[4AH] | 0001 0000B[10H] =0101 1010B [5AH]</p><p><strong>XOR</strong> (eXclusive OR) 逻辑异或指令</p><p>XOR DST , SRC //Byte/Word</p><p>执行操作：dst = dst ^ src</p><p>1.XOR指令常用于使某个操作数清零,同时使CF=0,清除进位标志.</p><p>2.XOR指令使某些位维持不变则与 '0' 相异或,若要使某些位取反则与 '1'相异或.</p><p>将AL的高4位维持不变,低4位取反：</p><p>MOV AL, B8H //AL=1011 1000B[B8H]</p><p>XOR AL, 0FH //AL=1011 0111B[B7H] 即1011 1000B[B8H] ^ 0000 1111[0FH]=1011 0111B[B7H]</p><p>测试某一个操作数是否与另一确定操作数相等：</p><p>XOR AX , 042EH</p><p>JZ .... //如果AX==042EH, 则ZF=TRUE(1), 执行JZ...</p><p><strong>NOT </strong>(not) 逻辑非指令</p><p>NOT OPR //Byte/Word</p><p>执行操作：opr = ~opr // ~ 01100101 [65H] =10011010 [9AH]</p><p>1.操作数不能使用立即数或段寄存器操作数,可使用通用寄存器和各种方式寻址的存储器操作数.</p><p>2.NOT指令不影响任何标志位。</p><p>将AL各位取反：</p><p>MOV AL,65H //AL=0110 0101B[65H]</p><p>NOT AL //AL=1001 1010B[9AH] 即 ~ 0110 0101B[65H]=1001 1010B[9AH]</p><p><strong>TEST</strong> (test) 指令</p><p>TEST OPR1 , OPR2 //Byte/Word</p><p>执行操作：opr1 & opr2</p><p>1.两个操作数相与的结果不保存,结果影响标志位PF,SF和ZF,使CF=0, OF=0,而AF位无定义.</p><p>2.TEST指令常用于在不改变原有的操作数的情况下,检测某一位或某几位的条件是否满足.只要令用来测试的操作数对应检测位为1,其余位为0,相与后判断零标志ZF值的真假.</p><p>检测某位是否为1：</p><p>令用来测试的操作数对应检测位为1,其余位为0,TEST指令后,若该位为1则 JNZ...</p><p>TEST AL , 0000 00001B //测试AL最低位是否为1:: 令用来测试的操作数对应检测位为1,其余位为0,执行TEST指令</p><p>JNZ THER //最低位若为1, 则ZF=FALSE(0), 执行JNZ THER, 否则执行下一条指令.</p><p>或者：先对操作数求反,令用来测试的操作数对应检测位为1,其余位为0,TEST指令后,若该位为1则JZ...</p><p>MOV DL , AL //将AL 传送到DL,主要是不要影响AL的值. 以下测试AL的b2位是否为1</p><p>NOT DL //先对操作数求反</p><p>TEST 0000 0100B //令用来测试的操作数对应检测位为1,其余位为0,执行TEST指令</p><p>JZ THER //若AL的b2位为1,则ZF=TRUE(1), 执行JZ THER</p><p>B：移位指令[所有的移位指令都影响标志位<strong>CF、OF、PF、SF</strong>和<strong>ZF、AF</strong>无定义.]</p><p>非循环逻辑移位：把操作数看成无符数来进行移位.</p><p><strong>SHL</strong> ( SHift logical Left )逻辑左移指令</p><p>SHL OPR , CNT //Byte/Word</p><p>执行操作：使OPR左移CNT位,并使最低CNT位为全0.</p><p>1.OPR操作数不能使用立即数或段寄存器操作数,可使用通用寄存器和各种方式寻址的存储器操作数.</p><p>2.移位次数由CNT决定.每次将OPR的最高位移出并移到CF,最低位补0.</p><p>MOV CL , 7 //若移位多次, 先预置移位次数CL</p><p>SHL DX , CL //CNT可取1或CL寄存器操作数</p><p><strong>SHR</strong> (SHift logical Right) 逻辑右移指令</p><p>SHR OPR , CNT //Byte/Word</p><p>同SHL,每次将OPR的最低位D0移出并移到CF.最高位补0.</p><p>非循环算术移位：将操作数看成有符号数来进行移位.</p><p><strong>SAL</strong> (Shift Arithmetic Left) 算术左移指令</p><p>SAL OPR , CNT //Byte/Word</p><p>SAL指令与SHL指令完全相同</p><p><strong>SAR</strong>(Shift Arithmetic Right) 算术右移指令</p><p>SAR OPR , CNT //Byte/Word</p><p>SAR指令每次移位时,将最高位移入次高位的同时最高位值不变,最低位D0移出并移到CF.</p><p>循环移位指令</p><p><strong>ROL</strong> ( ROtate Left) 循环左移指令</p><p>ROL OPR , CNT //Byte/Word</p><p>每次移位时,最高位移出并同时移到CF和最低位D0.</p><p><strong>ROR </strong>(ROtate Right)循环右移指令</p><p>ROR OPR,CNT //Byte/Word</p><p>每次移位时,最低位D0移出并同时移到CF和最高位.</p><p>带进位循环移位指令</p><p><strong>RCL</strong> (Rotate Left through Carry)带进位循环左移指令</p><p>RCL OPR,CNT //Byte/Word</p><p><strong>RCR </strong>(Rotate Right through Carry)带进位循环右移指令</p><p>RCR OPR ,CNT //Byte/Word</p><p>处理器控制指令</p><p><strong>CLC</strong> (CLear Carry) 进位位置0指令</p><p>CLC //执行操作后,CF=0</p><p><strong>CMC</strong> (CoMplement Carry) 进位位求反指令</p><p>CMC //执行操作后,CF=!CF</p><p><strong>STC </strong>(SeT Carry) 进位位置1指令</p><p>STC //执行操作后,CF=1</p><p><strong>NOP</strong> (No Operetion) 无操作指令</p><p>NOP //此指令不执行任何操作,其机器码占一个字节单元</p><p><strong>HLT </strong>(HaLT) 停机指令</p><p>HLT</p><p>执行操作后,使机器暂停工作,使处理器CPU处于停机状态,以等待一次外部中断到来,中断结束后,程序继续执行,CPU继续工作.</p><p><strong>JMP </strong>( JuMP ) 无条件转移指令</p><p>名称 格式 执行操作</p><p>段内直接短跳转 JMP SHORT OPR IP=IP+8 位偏移量</p><p>段内直接近转移 JMP NEAR PTR OPR IP=IP+16位偏移量</p><p>段内间接转移 JMP WORD PTR OPR IP=(EA)</p><p>段间直接转移 JMP FAR PTR OPR IP=OPR 偏移地址, CS=OPR 段地址</p><p>段间间接转移 JMP DWORD PTR OPR IP=(EA),CS=(EA+2)</p><p>1.无条件转移到指定的地址去执行从该地址开始的指令.</p><p>2.段内转移是指在同一代码段的范围内进行转移,只需改变IP寄存器内容.</p><p>3.段间转移则要转移到另一个代码段执行程序,此时要改变IP寄存器和CS段寄存器的内容.</p><p>条件转移指令：根据上一条指令所设置的条件码(标志位)来判断测试条件.</p><p>根据五个标志位：ZF、SF、OF、 PF、 CF的两种状态（0 FALSE或1 TRUE)产生10种测试条件.</p><p>Name Flag Flag == TRUE [1] Flag ==FALSE [ 0]</p><p>Zero Falg ZF <strong>JE/JZ</strong> OPR //结果为零转移<strong>JNE/JNZ</strong> OPR //结果不为零转移</p><p>Sign Falg SF <strong>JS</strong> OPR //结果为负转移<strong>JNS</strong> OPR //结果为正转移</p><p>Overflow Flag OF <strong>JO</strong> OPR //溢出转移<strong>JNO</strong> OPR //不溢出转移</p><p>Parity Flag PF <strong>JP/JPE</strong> OPR //结果为偶转移 <strong>JNP/JPO</strong> OPR //结果为奇转移</p><p>Carry Flag CF <strong>JC</strong> OPR //有进位转移 <strong>JNC</strong> OPR //无进位转移</p><p>两个数比较：</p><p>情况 指令 满足条件 指令 满足条件</p><p>A &lt; B <strong>JC</strong> CF==1 <strong>JL</strong> SF^OF==1 && ZF==0</p><p>A ≥ B <strong>JNC</strong> CF==0 <strong>JNL</strong> SF^OF==0 || ZF==1</p><p>A ≤ B <strong>JNA </strong>CF==1 || ZF==1 <strong>JLG</strong> SF^OF==1 || ZF==1</p><p>A > B <strong>JA </strong>CF==0 && ZF==0 <strong>JG</strong> SF^OF==0 && ZF==0</p><p>测试CX转移指令</p><p><strong>JCXZ </strong>OPR //CX==0时转移</p><p><strong>LOOP</strong>(LOOP)循环指令</p><p>LOOP OPR 测试条件：CX ≠ 0 //OPR在程序中实际是个标号</p><p>LOOPZ OPR 测试条件：ZF == 1 && CX ≠ 0</p><p>LOOPNZ OPR 测试条件：ZF == 0 && CX ≠ 0</p><p>执行操作: 先执行CX=CX-1,再检测上面的测试条件,如满足则IP=IP+符号扩展的D8,不满足则退出循环.</p><p>过程调用及返回指令</p><p><strong>CALL</strong> (CALL) 过程调用指令</p><p>CALL DST //DST在程序中实际是子程序标号</p><p>执行操作：先将过程的返回地址(即CALL的下一条指令的首地址)存入堆栈,然后转移到过程入口地址执行子程序.</p><p>调用方式 格式 断点保护入栈情况 过程入口地址</p><p>段内直接 CALL NEAR PTR PR1 (SP-1)(SP-2)←IP , CS不进栈 CS值保持不变,IP←DST</p><p>段内间接 CALL WORD PTR (EA) (SP-1)(SP-2)←IP , CS不进栈 CS值保持不变,IP←(EA)</p><p>段间直接 CALL FAR PTR PR1 (SP-1)(SP-2)←CS , (SP-3)(SP-4)←IP IP←DST偏移地址,CS←DST段地址</p><p>段间间接 CALL DWORD PTR (EA) (SP-1)(SP-2)←CS , (SP-3)(SP-4)←IP IP←(EA),CS←(EA+2)</p><p>注：为了表明是段内调用,可使用NEAR PTR属性操作符作说明.</p><p><strong>RET</strong>(RETurn)子程序返回指令</p><p>RET</p><p>RET EXP //带立即数返回</p><p>子程序返回指令RET放在子程序末尾,它使子程序在执行完全部任务后返回主程序继续执行被打断后的程序.返回地址在子程序调用时入栈保存的断点地址-IP或IP和CS.</p><div class=pgc-img><img alt=汇编语言常用指令大全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2cd27512af249c593b8c26673fb800f></div><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'编语','大全','指令'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>