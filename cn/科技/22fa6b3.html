<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>工业大数据：分析算法 | 极客快訊</title><meta property="og:title" content="工业大数据：分析算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/0fbd61d309e344efad19260bf524595f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22fa6b3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22fa6b3.html><meta property="article:published_time" content="2020-10-29T21:01:05+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:05+08:00"><meta name=Keywords content><meta name=description content="工业大数据：分析算法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/22fa6b3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>工业大数据：分析算法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一. 应用背景</p><p>大数据分析模型的研究可以分为3个层次，即描述分析(探索历史数据并描述发生了什么)、预测分析(未来的概率和趋势)和规范分析(对未来的决策给出建议)。工业大数据分析的理论和技术研究仍处于起步阶段，主要应用场景如下：</p><p>1. 预测性维护。</p><p>传统制造业面临核心设备的维护管理、故障诊断等问题，常规维修存在不确定性，紧急状况下故障处理的难度及压力都较大。实时监测、有效记录设备工况信息，通过大数据平台建模分析，能够有效地对设备运行状态进行评估，针对潜在的健康隐患给出对应的预警。基于全生命周期的数据挖掘，可以对工程机械设备的核心耗损性部件的剩余寿命进行预测，以便进行提前维护或者更换。</p><p>2. 工艺参数优化。</p><p>基于决策树等弱分类器的集成学习算法是解决工艺参数优化的常规手段，如GBDT，XGBoost，LightGBM等。另一个方向是深度强化学习(DRL，deep reinforcement learning)，DRL集成了深度学习的感知理解能力及强化学习的决策能力，是未来发展的趋势。</p><p>此外，产量预测、客户需求分析和服务类型识别等也是广泛存在的场景。</p><p>二. 预测性维护算法</p><p>系统中部署传感器，用于监控和收集系统运行的数据。预测性维护所需要的数据是时间序列数据，包括时间戳、在该时间戳所收集的传感器读数以及设备号。预测性维护的目的是，在时间“t”，使用截至到该时间的数据来预测设备在近期是否会发生故障。预测性维护可通过以下两种方法之一来实现：</p><p>(1). 回归方法：预测在下次故障发生之前的剩余时间，即剩余使用寿命(RUL)。</p><p>回归方法只提供一个布尔值答案，但可以使用较少的数据提供更高的准确性。</p><p>预测精度的衡量标准：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0fbd61d309e344efad19260bf524595f><p class=pgc-img-caption></p></div><p>使用均方根误差惩罚实际与预测的RUL之间Loss。也可以采用log的形式：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a731f40467144f6da566aba497ccfc06><p class=pgc-img-caption></p></div><p>模型选择：</p><p>基于scikit learn和H2O的回归算法都适用。如，scikit learn-Random Forest Regression、scikit learn-Linear Regression、scikit learn-Ridge、scikit learn-Lasso及H2O-Random Forest Regression、H2O-Gradient Boosting、H2O-Generalized Linear Modeling、H2O-Deep Learning等。</p><p>算法步骤：</p><p>1. 消除传感器噪声。</p><p>传感器读数通常会有噪声，往往采用自动编码器去除噪声，以主要维度表示数据。与PCA相似，AutoEncoder使用同一套数据集同时作为网络的输入和输出进行训练，其中网络中的参数比数据集中的维数少。由于噪声的维度比常规数据高得多，这种方式可以在一定程度上去噪。H2O引入相应模块：</p><pre><code>from h2o.estimators.deeplearning import H2OAutoEncoderEstimator</code></pre><p>2. 特征工程。</p><p>时间序列的特征大体上可以分成统计特征，拟合特征，周期性特征，分类特征等几大类。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2a512a54076a4da28c0ef60dce3154bb><p class=pgc-img-caption></p></div><p>统计特征：</p><p>已知的时间序列的最大值、最小值、自相关系数等各种各样的统计指标。</p><p>拟合特征：</p><p>基本想法是用一些简单的时间序列算法去拟合数据，然后使用拟合数据和真实数据来形成必要的特征。时间序列数据集读数是自相关的，“t”时刻的预测可能会受到“t”之前的某个时间窗口的影响。因此需要通过移动标准差、移动平均值、自回归、奇异值分解和深度学习等方法生成特征并进行特征组合。</p><p>移动平均算法：已知时间序列X n = [x 1 ,...,x n ]，可以使用一个窗口值w>=1得到一组光滑后的时间序列。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c92835d438074e4e98a6f65dd9103f43><p class=pgc-img-caption></p></div><p>实际值与光滑后所得到的值的差值SMA n -x n 就可以作为特征。</p><p>带权重的移动平均算法：计算平均值的时候将不同的点带上不同的数值。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7587831cc73c4874b65363cd46d4b374><p class=pgc-img-caption></p></div><p>指数移动平均算法：在已知时间序列的基础上进行加权操作，而权重的大小是呈指数衰减的。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ef59ba3b1ee7446e8ee9d68373a36dca><p class=pgc-img-caption></p></div><p>只需要构建一个加权求和，然后计算EWMA n -x n 就可以得到特征。</p><p>分类特征：</p><p>可以根据时间序列的走势，例如周期型、毛刺型、定时任务型来构造出时间序列的分类特征，用于时间序列形状的多分类问题。具有窗口大小的概率分布、移动熵及小波分析特征都很常见。在时间序列的分类特征里面，有一种特征叫做 <strong>值分布特征</strong> 。假设时间序列的值域在[0,1]之内，值分布特征计算出一个时间序列X n = [x 1 ,...,x n ]的取值在[0,0.1),[0.1,0.2),...,[0.9,1]这十个桶的个数，进一步得到它们落入这十个桶的概率是多少。这一类特征可以通过count函数生成。</p><p>3. 超参数优化。</p><p>超参数控制了算法的行为。优化以下超参数：epochs、distribution、activation和hidden layer size。可以在H2O文档中找到每个参数的详细说明并通过网格搜索(Grid Search)寻找最佳参数。</p><p>(2). 分类方法：预测在接下来的N步中是否有可能发生故障。</p><p>分类方法需要更多的数据，但可以提供有关何时发生故障的更多信息。这种方法不再提供剩余的生命周期数，而是要预测机器是否会在接下来的30个周期内故障。我们会将故障视为正(positive，P)，而无故障视为常态(normal，N)。</p><p>预测精度的衡量标准：</p><p>准确率描述了预测正确的测试用例数与所有测试用例数的比例。当数据集中同一类别数据量太多，发生类不平衡时，只考虑准确率将会产生误导(高准确率，但预测性能差)，精确率和召回率(检出率)可以避免这个问题。精确率指的是预测为正值且实际也是正值的样本数和所有被预测为正值的样本数之间的比例；召回率指的是预测为正值的样本数和应该被预测为正值的样本数之间的比例。另外，F1分数是衡量准确率的指标，计算F1分数时需要兼顾精确率和召回率。对于准确率、召回率、精确率和F1分数，它们的值越接近1越好。</p><p>模型选择：</p><p>深度学习分类模型。</p><p>算法步骤：</p><p>参考上述去噪、特征工程及超参数优化等方法。</p><p>三. 工艺参数优化算法</p><p>这里主要介绍集成学习算法及DRL算法。</p><p><strong>集成学习算法：</strong></p><p>(1). 集成学习。</p><p>集成学习分为两种，Boosting(↓Bias & Variance)和Bagging(↓Variance)。</p><p>1. Boosting给固定样本加权，串行地生成一系列“weak learners”，再学习样本及分类器的权重，通过“weak learners”组合构造一个“strong learner”。回归算法可以通过残差来实现：每一轮的训练集发生变化(标签变为了残差)，即下一个模型要基于新训练集进行学习，学习完毕后，将所有模型简单叠加，就得到了最终模型。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0c3e505af4e9466698d9ef7e09bff5f5><p class=pgc-img-caption></p></div><p>尽管近年来神经网络复兴并大为流行，boosting算法在训练样本量有限、所需训练时间较短、缺乏调参知识等场景依然有其不可或缺的优势。</p><p>2. Bagging随机有放回均匀取样构造n个训练集，并行训练k个模型(决策树、KNN等)。对于分类问题：由投票表决产生的分类结果；对于回归问题，由k个模型预测结果的均值作为最后预测的结果(所有模型的重要性相同)。例如，随机森林，Random Forest。</p><p>(2). Adaboost。</p><p>Adaptive Boosting, 自适应增强算法，通过训练多个弱分类器来组合得到一个强分类器，每次迭代会生成一棵 <strong>高Bias、低Variance</strong> 的树形弱分类器。每一轮的训练会更关注上一轮被分类器分错的样本，为其加大权重，具体做法是：1. 提高上一轮被错误分类的样本的权值，降低被正确分类的样本的权值；2. 线性加权求和。误差率小的基学习器拥有较大的权值，误差率大的基学习器拥有较小的权值。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/98ed7efd90264974906cad3fe639c5cf><p class=pgc-img-caption></p></div><p>sign内的符号决定了所预测的类，绝对值代表分类的确信度。</p><p>代码实现：</p><pre><code>def adaboost_clf(Y_train, X_train, Y_test, X_test, M=20, weak_clf=DecisionTreeClassifier(max_depth = 1)):    n_train, n_test = len(X_train), len(X_test)    # Initialize weights    w = np.ones(n_train) / n_train    pred_train, pred_test = [np.zeros(n_train), np.zeros(n_test)]    for i in range(M):        # Fit a classifier with the specific weights        weak_clf.fit(X_train, Y_train, sample_weight = w)        pred_train_i = weak_clf.predict(X_train)        pred_test_i = weak_clf.predict(X_test)        # Indicator function        miss = [int(x) for x in (pred_train_i != Y_train)]        print("weak_clf_%02d train acc: %.4f"         % (i + 1, 1 - sum(miss) / n_train))        # Error        err_m = np.dot(w, miss)        # Alpha        alpha_m = 0.5 * np.log((1 - err_m) / float(err_m))        # New weights        miss2 = [x if x==1 else -1 for x in miss] # -1 * y_i * G(x_i): 1 / -1        w = np.multiply(w, np.exp([float(x) * alpha_m for x in miss2]))        w = w / sum(w)        # Add to prediction        pred_train_i = [1 if x == 1 else -1 for x in pred_train_i]        pred_test_i = [1 if x == 1 else -1 for x in pred_test_i]        pred_train = pred_train + np.multiply(alpha_m, pred_train_i)        pred_test = pred_test + np.multiply(alpha_m, pred_test_i)    pred_train = (pred_train &gt; 0) * 1    pred_test = (pred_test &gt; 0) * 1    print("train accuracy: %.4f" % (sum(pred_train == Y_train) / n_train))    print("test accuracy: %.4f" % (sum(pred_test == Y_test) / n_test))</code></pre><p>(3). GBDT。</p><p>Gradient Boosting Decision Tree，梯度提升树，不同于Adaboost加大误分样本权重的策略，每一次的计算是都为了减少上一次的残差，进而在残差减少(负梯度)的方向上建立一个新的模型。无论是回归、二分类还是多分类问题(设定阈值)，GBDT中的决策树都是回归树(传统GBDT使用CART)，因为每次迭代要拟合的是 <strong>梯度值</strong> ，是连续值。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8aec8e0004c441608812fc8aefaa4ee9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d9653a4c11aa44b9950d20383535e436><p class=pgc-img-caption></p></div><p>模型一共训练M轮，每轮产生一个弱分类器</p><p>T ( x ; θ m )</p><p>。我们希望损失函数能够尽可能快的减小，沿着梯度方向下降。每轮迭代的时候，都去拟合损失函数在当前模型下的负梯度(残差的近似值)，整体上，作为回归问题，拟合一个回归树，进而发现多种有区分性的特征以及特征组合。</p><p>1. XGBoost。</p><p>全称是eXtreme Gradient Boosting，是GBDT的改进版，能自动利用cpu的多线程。作为一个树集成模型，XGBoost将K个树对应的叶节点的值求和进行预测。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dff1ee3dec7642b9914eb8bcabdecfc5><p class=pgc-img-caption></p></div><p>我们的目标是学习这K个树，因此，需要最小化带正则项的目标函数：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/61d36164f34e41629999e043102edd7f><p class=pgc-img-caption></p></div><p>在XGBoost里，每棵树(f k )是一个一个往里面加的：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d6d5cd238e84ef79486e0815776f134><p class=pgc-img-caption></p></div><p>每加一个都希望效果能提升，即目标函数(就是损失)的值下降，如果经过t轮训练我们做模型预测，之前的目标函数细化为：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2258498a502447909e31e4ce7d3995a0><p class=pgc-img-caption></p></div><p>除了损失函数是square loss的情形，还是比较复杂。因此，用泰勒展开(取前三项，二阶)近似原来的目标函数，这里就与GBDT不同了，GBDT利用梯度，即一阶导数来近似，精度显然会差一些。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8ec06e4087f94604b46626a6963ce313><p class=pgc-img-caption></p></div><p>其中，损失函数l可以是square或者logistic Loss，而第二部分Ω正则项(eg：L1和L2等)针对的是树的复杂度。XGBoost对于树的复杂度定义如下：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1495d6b77e6e40cc99ef4245e4eef0d8><p class=pgc-img-caption></p></div><p>我们来图解一下：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f65dba34858458f82ccafc5ccb48755><p class=pgc-img-caption></p></div><p>这里面，树的复杂度项包含两个部分，叶子节点个数T以及叶子节点得分L2正则化项w(L2平滑避免过拟合)。我们移除常量，定义为每个叶节点 j 上面样本集合I j = {i|q(x i ) = j}，并带入上述复杂度函数到正则项中，得到新的目标函数：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/57732a58d2a24186ad7809f2a0dd22f7><p class=pgc-img-caption></p></div><p>g是一阶导数，h是二阶导数，T是叶节点个数，w是叶节点的分数。目标包含了T个相互独立的单变量二次函数，化简为：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cb8d668e751e4a12825975c02bd7c2b2><p class=pgc-img-caption></p></div><p>求w j 最优解(求导=0)并带入目标函数，得到最终的目标函数：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d40dbb232d0144149ee6bb7f1fac4c4e><p class=pgc-img-caption></p></div><p>Obj表示在指定的树结构下，我们在目标上最多减多少，因此又叫结构分数(structure score)，越小代表树的结构越好。那么如何寻找出一个最优结构的树呢？XGBoost原始论文中给出了两种分裂节点的方法。</p><p>Exact Greedy贪心算法：枚举所有不同树结构的贪心法。</p><p>枚举所有可能的树结构是不可行的。可以使用贪心算法，从单个叶子开始不断增加分支(分割)，计算分割后左右两侧的导数和(提高效率)，再计算增益。评估候选分裂方式，寻找最优特征及对应的值：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f8684c6d2e140a798b9eecb29def5d6><p class=pgc-img-caption></p></div><p>引入新叶子的惩罚项，控制树的复杂度，同时也作为阈值(增益大于阈值才分裂)，起到了 <strong>预剪枝</strong> 的作用。论文中的算法：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc14f40911094dabab900dd3e173bf6a><p class=pgc-img-caption></p></div><p>但在连续特征上枚举所有可能的分割方案，计算损耗还是太大。为了更高效，XGBoost先使用 <strong>pre-sorted算法</strong> 对所有数据根据特征数值进行预排序，然后在每次分割时，按顺序访问数据并根据增益找到每个特征的最优分割点，最后找到最优特征及分割点，将数据分裂成左右两个子节点。</p><p>近似算法： 针对数据量太大的情况。</p><p>当数据无法完全加载进内存或是分布式的情况下，贪心算法就不是特别有效了。</p><p>近似算法根据特征分布的百分位数(weighted quantile sketch算法使候选切分点在数据上均匀分布)，提出候选切分点，然后将连续特征映射到被这些候选切分点切分成的"buckets"中，聚集统计值，基于统计值推荐分割点，找到最佳方案。该算法有两种形式：全局近似和局部近似，差别是，全局近似是在创建树的初始阶段提出所有候选切分点，所有的层都使用相同的proposal寻找切分点；局部近似在每个节点分裂之后重新提出候选切分点，这种改进对更深层的树更合适。近似算法的流程：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/515736db61fa40278ce936b2cfbf9a6e><p class=pgc-img-caption></p></div><p>此外，稀疏自适应分割策略也可以用于分裂节点：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f5e4d4163e4f49019259b37449da9f45><p class=pgc-img-caption></p></div><p>除了在目标函数中引入正则项，XGBoost还引入了 <strong>缩减(shrinkage)</strong> 和 <strong>列抽样(column subsampling)</strong> ，进一步防止过拟合。通过在每一步的boosting中引入缩减系数，降低每个树和叶子对结果的影响；列抽样是借鉴随机森林中的思想，有时甚至比行抽样效果更好，同时能够加速计算。</p><p>综上，基于贪心+二次最优化的策略，XGBoost算法流程可以总结为：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0f0f68e86a84303b2798294a2d3dd72><p class=pgc-img-caption></p></div><p>2. LightGBM。</p><p>LigthGBM由微软提供，也是对GBDT的高效实现，类似XGBoost，采用损失函数的负梯度作为当前决策树的残差近似值，去拟合新的决策树。LightGBM比XGBoost快，内存占用率低，准确率也有提升。</p><p>动机：</p><p>面对工业级海量的数据，传统的boosting算法需要对每一个特征都要扫描所有的样本点来选择最好的切分点，把整个训练数据装进内存会限制训练数据的大小，不装进内存，反复读写训练数据又非常耗时。</p><p>算法流程：</p><p>解决上述问题的直接方法就是减少特征量和数据量而且不影响精确度。LightGBM结合使用了以下两种算法：</p><p>1. <strong>GOSS</strong> (Gradient-based One-Side Sampling)： 基于梯度的单边采样，不使用所用的样本点来计算梯度，而是对样本进行采样来计算梯度。</p><p>GBDT不能应用AdaBoost的样本权重采样，但每个数据都有不同的梯度值，丢掉梯度小、被学习得很好的数据，有助于采样。为了避免这样做带来的精确度影响(数据分布改变了)，引入GOSS算法。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/25047a44fbf9490fabf52a1db0626e77><p class=pgc-img-caption></p></div><p>步骤：</p><p>根据样本点的梯度的绝对值对它们进行降序排序； --> 保留top a(大梯度数据的采样率为a)个数据实例作为数据子集A，即前a*100%的样本； --> 对于剩下的数据的实例随机选取比例为b(小梯度数据的采样率为b)的数据子集B，即b*(1-a)*100%个样本点； --> 将小梯度样本乘上权重系数(1-a)/b并与大梯度样本合并来计算信息增益，学习一个新的弱学习器； --> 不断重复之前的步骤直到达到规定的迭代次数或者收敛为止。</p><p>估计信息增益的公式如下：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b0ad7d92ab04c6bade07af6d8a7fd0c><p class=pgc-img-caption></p></div><p>当a=0时，GOSS算法退化为随机采样算法；当a=1时，GOSS算法变为采取整个样本的算法。算法在不改变数据分布的前提减少了计算量、保证了精度，同时增加了基学习器的多样性，提高了泛化能力。</p><p>2. <strong>EFB</strong> (Exclusive Feature Bundling)：互斥特征捆绑，不使用所有的特征来进行扫描获得最佳切分点，而是将某些特征捆绑在一起来降低特征的维度。</p><p>LightGBM不仅进行了数据采样，也进行了特征抽样，EFB将冲突比率(特征不互斥程度)较小的特征捆绑起来，使模型的训练速度进一步提升。将特征划分为更小的互斥绑定集群是一个NP-hard问题(图着色问题)，只能寻求允许小部分冲突的近似解。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/abc1a2777ebc4efc9d2c46a74a784a14><p class=pgc-img-caption></p></div><p>步骤：</p><p>构造一个图(Graph)，特征看作节点(node)，特征之间的冲突值(cos夹角)作为边(edge)的权值； -> 通过节点(特征)在图中的度(degree)来降序排序特征/更高效的实现算法是将特征按照非零值的个数进行排序； -> 遍历每个特征，并按阈值K(最大冲突数)合并特征，分配给具有小冲突的现有bundle或创建新bundle。</p><p>不同于XGBoost所使用的pre-sorted排序算法，LightGBM最后一步关于互斥特征的合并用到了直方图(Histogram)算法：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c7ddf4f08a549a29960db1b9dd3c91f><p class=pgc-img-caption></p></div><p>基本思想是把连续的特征值离散成k个整数，并构造宽度为k的直方图。遍历数据时，以离散化后的值为索引累积直方图统计量，遍历一次数据后，根据直方图的离散值，遍历寻找最优的分割点。使用bin放弃了数据的细节特征，相似的数据被划分到相同的桶中，差异就消失了，同时，bin相当于增加了正则化，数量越少惩罚越严重，欠拟合风险越高。但对决策树这样的弱学习器的正则化，抵消了离散化的分裂点对最终分割精度的影响，有效防止了过拟合。而且，由于离散化，模型效率上有很大提升。</p><p>决策树增长策略：</p><p>XGBoost采用的是Level-wise迭代方式，不加区分的一次分裂同一层的叶子，效率低下，可能产生不必要的叶结点。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8eb08b66da9642e2a326b40dc6ddfa61><p class=pgc-img-caption></p></div><p>LightGBM通过leaf-wise策略来生长树。每次从当前所有叶子中，找到分裂增益最大的一个叶子，然后分裂，如此循环。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d24df2c07d8e465a8031b2350dbd432c><p class=pgc-img-caption></p></div><p>相比Level-wise，在分裂次数相同的情况下，leaf-wise可以降低更多的误差，精度更好。但当样本量较小的时候，leaf-wise需要引入额外的参数 max_depth 来限制树的深度，避免过拟合。</p><p>此外LightGBm直接支持类别特征，支持特征并行和数据并行。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5d9cee7a44fc4680863ceae9ef6d06e1><p class=pgc-img-caption></p></div><p>3. CatBoost。</p><p>CatBoost(categorical boosting)是俄罗斯的搜索巨头Yandex在2017年开源的机器学习库。是一种能够很好地处理类别型特征的梯度提升算法。采用的策略在降低过拟合的同时保证所有数据集都可用于学习。</p><p>动机：</p><p>CatBoost算法的设计初衷是为了更好的处理GBDT特征中的categorical features。类别数较少的特征，一般利用one-hot编码方法将特征转为数值型用。另一种简单的方式是基于统计，用标签的平均值来表示特征并作为节点分裂的标准(Greedy Target-based Statistics)，但在训练和测试集数据结构和分布不同时，容易导致条件偏移问题，造成过拟合。</p><p>算法流程：</p><p>标准的改进Greedy TS的方式是添加先验分布项，这样可以减少噪声和低频率数据对于数据分布的影响。CatBoost给出了一种解决方案：</p><p>1. Ordered TS克服梯度偏差(prediction shift)；</p><p>在GBDT中，构建下一棵树包含两步，选择树的结构和设置叶子节点的值。基于当前模型中的相同的数据点，叶子节点的值都是被当做梯度或牛顿步长的近似值来计算，这样会造成有偏的点态梯度估计(梯度在特征空间的任何域中的分布与该域中梯度的真实分布相比发生了偏移)，导致过拟合。CatBoost和标准GDBT算法一样， <strong>第一阶段</strong> ，通过构建新树来拟合当前模型的梯度，但在每一步，依靠目前已经观察的样本集，对所有样本进行随机排序，在不同的梯度提升步中使用不同的排列，即使用独立的数据集，这样就得到了无偏估计的模型。两种模式的树结构：Ordered/Plain。基本预测器是无关决策树oblivious，将浮点型特征、统计值及one-hot编码的特征二值化并放入向量中，利用二值化的特征快速评分，计算模型的输出。由于整个层次上使用相同的分割标准，oblivious树是平衡的，不容易过拟合。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/db74cd1ab0834ec99b1e740466afdc48><p class=pgc-img-caption></p></div><p>Ordered模型在学习训练的过程中，对于每个样本，都单独构建一个利用该样本之前的样本点的梯度估计得到的模型，针对这些模型，估计该样本的梯度，然后利用新模型重新对样本打分。在算法中每步迭代 中，都在一个随机排列 的基础上构建树。 <strong>第二阶段</strong> ，在所有树结构都建立好的情况下，对两种模式均采用标准梯度增强程序计算最终模型的叶子节点值。</p><p>2. 样本的类别型特征转为数值型；</p><p>类别形变量需要使用随机排列，根据排在该样本之前的该类别标签取均值作为节点分裂标准，并加入优先级和优先级的权重系数。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a48f3c6162324245859e2ac50b4b6887><p class=pgc-img-caption></p></div><p>其中P是添加的先验项，a通常是大于0的权重系数。回归问题，一般先验项可取数据集标签的均值。对于二分类，先验项是正例的先验概率。</p><p>3. 特征组合；</p><p>特征组合可以得到一个新的强大的特征，但受制于特征数量，不可能考虑所有组合。当前树构造新的分割点时，CatBoost会采用贪婪的策略考虑组合。对于树的第一次分割，不考虑任何组合。后面的分割中将所有类别型特征之间的组合考虑进来，组合后的特征就会变成数值型的。对于数值型和类别型特征的组合：树选择的所有分割点都被视为具有两个值的类别型特征，并且组合方式和类别型特征一样。</p><p>(4). 提升树算法工业应用。</p><p>津南数字制造算法挑战赛——赛场一：原料企业工艺优化。</p><p>https://tianchi.aliyun.com/competition/entrance/231695/introduction?spm=5176.12281915.0.0.678010bdUCRYjV</p><p>季军方案：nlceyes</p><p>https://github.com/nlceyes/TianChi-JinNan</p><p>DRL算法：</p><p>(1). 组合优化。</p><p>运用深度强化学习求解组合优化问题是目前非常火热的一个研究方向，强化学习天生就是做序列决策用的，组合优化问题里边的序列决策问题完全也可以用强化学习来直接求解，其难点是怎么定义state, reward。比较经典的TSP(Traveling Salesman Problem旅行商问题)和VRP(Vehicle Routing Problem车辆路径问题)主要的思路是encoder + decoder。encoder有很多方法，graph embedding, attention, glimpse, multi-head等，decoder也同样。在工业领域，例如对于Job shop问题(加工车间调度问题)就是决定以什么顺序在机器上加工工件。阿里菜鸟物流人工智能部，使用深度强化学习方法求解一类新型三维装箱问题(将若干个长方体物体逐个放入一个箱子中并最小化能够容纳所有物品的箱子的表面积)，相对于已有的启发式算法，获得大约5%的效果提升。</p><p>1. Pointer Network：</p><p>Pointer Networks是一种seq2seq模型，由Google Brain和UC Berkeley联合发表。传统的seq2seq模型无法解决输出序列的词汇表会随着输入序列长度的改变而改变的问题。特定情况下，我们希望输出是输入集合的子集，而Ptr-net在seq2seq基础上引入attention机制并做了简化(传统attention计算权重后对encoder的state进行加权得到一个向量；Pointer Networks计算权重后选择概率最大的encoder state作为输出)，类似编程语言中的指针(每个指针对应输入序列的一个元素，可以直接操作输入序列而不需要特意设定输出词汇表)，克服了seq2seq模型中“输出严重依赖输入”的问题。网络对比如下：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a92cc2e46a57400d85d23f4b09c6746d><p class=pgc-img-caption></p></div><p>seq2seq：</p><p>seq2seq属于encoder-decoder结构的一种，以LSTM为基本单元，一个RNN作为encoder将输入序列压缩成指定长度的语义向量，另一个RNN作为decoder根据语义向量(只作为初始状态参与运算，与后面的运算无关)生成指定的序列，详细结构如下：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6a7dcfc61a2148bfaff3ce466c020ffd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8139c8a2f5c41729498435fa91d85f1><p class=pgc-img-caption></p></div><p>Attention Mechanism：</p><p>Attention Mechanism可以帮助模型对输入的X每个部分赋予不同的权重，抽取出更加关键及重要的信息，使模型做出更加准确的判断，同时不会对模型的计算和存储带来更大的开销 。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f18a0bc1f584320b820d7dd7df9d50f><p class=pgc-img-caption></p></div><p>没加入Attention机制时，Y1 = f(C)；Y2 = f(C,Y1)；Y3 = f(C,Y1,Y2)，各阶段的输出Yi用的都是同一个中间语义c表示，而C是由输入的每个元素经过Encoder编码产生的，即C = F(x1,x2,x3,x4)，输入序列中的任意单词对目标Yi的影响力是一样的。此外，Encoder不论接收多长的序列，最后输出都是一个中间语义向量C，语句很长时C的表达能力堪忧。引入Attention的Encoder-Decoder框架，每一个输出Yi用不同的中间向量Ci表示，反应每个输入元素不同的影响，即Y1 = f(C1)；Y2 = f(C2,Y1)；Y3 = f(C3,Y1,Y2)。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34fa4993c89f49ec95824f23b92f0daa><p class=pgc-img-caption></p></div><p>Ci定义为：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2e324d0e76864a9194efecba1098048d><p class=pgc-img-caption></p></div><p>其中L x 表示输入source长度，a ij 表示输出第i个元素时source输入序列中第j个元素的注意力分配系数，h j 是Source输入序列中第j个元素的语义编码。a ij 的概率分布值计算方法如下：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e2fa010bd74d40629d38881ea4672b64><p class=pgc-img-caption></p></div><p>在时刻i生成Yi，i-1时刻隐藏层节点的输出值H i-1 是已知的，计算H i-1 和Encoder的 <strong>每个</strong> 元素对应的RNN隐藏层节点状态h j 的相似性F(h j ,H i-1 )来获得“对齐”可能性。函数F可以采用向量点积、Cosine相似性或MLP网络，输出经过Softmax进行归一化就得到了注意力分配系数的概率分布值。综上，Attention机制的本质思想可以表示为：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dae23b32153d403996399cc27def28ce><p class=pgc-img-caption></p></div><p>将Source中的构成元素看作一系列&lt;Key,Value>数据对，Target中的某个元素看作Query，通过计算Query和各个Key的相似性得到每个Key的权重系数，再对Value进行加权求和，最终的得到Attention vector。</p><p>Self Attention：</p><p>又称Intra(内部) Attention。在机器翻译场景中，可以捕获同一个句子中单词之间的一些句法特征或者语义特征，更容易捕获句子中长距离的相互依赖的特征，同时增加计算的并行性。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ffdd657a88584a53bd58a9ea547d5492><p class=pgc-img-caption></p></div><p>在图像描述任务中，输入一张图片，AI系统输出一句描述，语义等价地描述图片所示内容。可以使用Encoder-Decoder框架来解决，Encoder输入一张图片，提取特征后，Decoder使用RNN或LSTM来输出自然语言句子。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ac6baf55d89749c89581006e3a8a6e26><p class=pgc-img-caption></p></div><p>这里引入Attention机制，输出某个实体单词时会将注意力聚焦在图片中相应的区域上，能显著提升系统输出效果。</p><p>Pointer Networks：</p><p>传统Attention机制的公式：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05ceefda51f04461aeaa06d2e78183f2><p class=pgc-img-caption></p></div><p>首先整合Encoder和Decoder的隐式状态，再学习分配给输入序列的权重系数a，最后加权求和得到vector来预测下一个输出。Ptr-net没有最后一个公式，直接将softmax结果当成输出，以指针的形式指向输入序列中最有可能是输出的元素。</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/08d42e955d164c419b48a6fe13b3a820><p class=pgc-img-caption></p></div><p>Ptr-net很适合用来直接复制输入序列中的某些元素给输出序列，本文提到的组合优化场景刚好符合。</p><p>应用实践：</p><p>https://github.com/higgsfield/np-hard-deep-reinforcement-learning</p><p>(2). 工艺参数推荐。</p><p>激光机工艺推荐、辅助波形调试、焚烧炉工艺优化等场景，需要逐台进行调试，现场调试技术复杂，有经验的技术人员的培养周期长。基于图嵌入的AI模型自动调参显著提升效率，节约成本。</p><p>1. GNN(图神经网络)：</p><div class=pgc-img><img alt=工业大数据：分析算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c449eb40fadb4de1bee42f16cc31569a><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'工业','大数据','算法'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>