<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>python3从零学习-5.3.3、十进制定点和浮点运算decimal | 极客快訊</title><meta property="og:title" content="python3从零学习-5.3.3、十进制定点和浮点运算decimal - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2346a233.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><meta property="article:published_time" content="2020-11-14T21:05:10+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:10+08:00"><meta name=Keywords content><meta name=description content="python3从零学习-5.3.3、十进制定点和浮点运算decimal"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2346a233.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>python3从零学习-5.3.3、十进制定点和浮点运算decimal</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>源码：</strong> Lib/decimal.py</p><hr><p>decimal 模块为快速正确舍入的十进制浮点运算提供支持。 它提供了 float 数据类型以外的几个优点：</p><ul><li>Decimal 类型的“设计是基于考虑人类习惯的浮点数模型，并且因此具有以下最高指导原则 —— 计算机必须提供与人们在学校所学习的算术相一致的算术。” —— 摘自 decimal 算术规范描述。</li><li>Decimal 数字的表示是精确的。 相比之下，1.1 和 2.2 这样则是不精确的二进制浮点数表示。 最终用户通常不希望 1.1 + 2.2 的结果会如采用二进制浮点数时那样显示为 3.3000000000000003。</li><li>精确性会延续到算术类操作中。 对于 decimal 浮点数，0.1 + 0.1 + 0.1 - 0.3 会精确地等于零。 而对于二进制浮点数，结果则为 5.5511151231257827e-017 。 虽然接近于零，但其中的误差将妨碍可靠的相等性检验，并且误差还会不断累积。 因此，decimal 更适合具有严格相等不变性要求的会计类应用。</li><li>decimal 模块包含了有效位的概念，使得 1.30 + 1.20 是 2.50 。 保留尾随零以表示有效位。 这是货币类应用的习惯表示法。 对于乘法，“教科书”方式使用被乘数中的所有数位。 例如， 1.3 * 1.2 给出 1.56 而 1.30 * 1.20 给出 1.5600 。</li><li>与基于硬件的二进制浮点数不同，decimal 模块具有用户可更改的精度（默认为28位），可以与给定问题所需的一样大：</li></ul><pre><code>&gt;&gt;&gt; from decimal import * &gt;&gt;&gt; getcontext().prec = 6 &gt;&gt;&gt; Decimal(1) / Decimal(7) Decimal(&#39;0.142857&#39;)&gt;&gt;&gt; getcontext().prec = 28 &gt;&gt;&gt; Decimal(1) / Decimal(7) Decimal(&#39;0.1428571428571428571428571429&#39;)</code></pre><ul><li>二进制和 decimal 浮点数都是根据已发布的标准实现的。 虽然内置浮点类型只公开其功能的一小部分，但 decimal 模块公开了标准的所有必需部分。 在需要时，程序员可以完全控制舍入和信号处理。 这包括通过使用异常来阻止任何不精确操作来强制执行精确算术的选项。</li><li>decimal 模块旨在支持“无偏差，精确无舍入的十进制算术（有时称为定点数算术）和有舍入的浮点数算术”。 —— 摘自 decimal 算术规范说明。</li></ul><p><strong>该模块的设计以三个概念为中心：decimal 数值，算术上下文和信号。</strong></p><p>decimal 数值是不可变对象。 它由符号，系数和指数位组成。 为了保持有效位，系数位不会截去末尾零。 decimal 数值也包括特殊值例如 Infinity ，-Infinity 和 NaN 。 该标准还区分 -0 和 +0 。</p><p>算术的上下文是指定精度、舍入规则、指数限制、指示操作结果的标志以及确定符号是否被视为异常的陷阱启用器的环境。 舍入选项包括 ROUND_CEILING 、 ROUND_DOWN 、 ROUND_FLOOR 、 ROUND_HALF_DOWN, ROUND_HALF_EVEN 、 ROUND_HALF_UP 、 ROUND_UP 以及 ROUND_05UP.</p><p>信号是在计算过程中出现的异常条件组。 根据应用程序的需要，信号可能会被忽略，被视为信息，或被视为异常。 十进制模块中的信号有：Clamped 、 InvalidOperation 、 DivisionByZero 、 Inexact 、 Rounded 、 Subnormal 、 Overflow 、 Underflow 以及 FloatOperation 。对于每个信号，都有一个标志和一个陷阱启动器。 遇到信号时，其标志设置为 1 ，然后，如果陷阱启用器设置为 1 ，则引发异常。 标志是粘性的，因此用户需要在监控计算之前重置它们。</p><h2 class=pgc-h-arrow-right>快速入门教程</h2><p>通常使用 decimal 的方式是先导入该模块，通过 getcontext() 查看当前上下文，并在必要时为精度、舍入或启用的陷阱设置新值:</p><pre><code>&gt;&gt;&gt; from decimal import *&gt;&gt;&gt; getcontext()Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])&gt;&gt;&gt; getcontext().prec = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Set a new precision</code></pre><p>可以基于整数、字符串、浮点数或元组构造 Decimal 实例。 基于整数或浮点数构造将执行该整数或浮点值的精确转换。 Decimal 数字包括特殊值例如 NaN 表示“非数字”，正的和负的 Infinity 和 -0</p><pre><code>&gt;&gt;&gt; getcontext().prec = 28&gt;&gt;&gt; Decimal(10)Decimal(&#39;10&#39;)&gt;&gt;&gt; Decimal(&#39;3.14&#39;)Decimal(&#39;3.14&#39;)&gt;&gt;&gt; Decimal(3.14)Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)&gt;&gt;&gt; Decimal((0, (3, 1, 4), -2))Decimal(&#39;3.14&#39;)&gt;&gt;&gt; Decimal(str(2.0 ** 0.5))Decimal(&#39;1.4142135623730951&#39;)&gt;&gt;&gt; Decimal(2) ** Decimal(&#39;0.5&#39;)Decimal(&#39;1.414213562373095048801688724&#39;)&gt;&gt;&gt; Decimal(&#39;NaN&#39;)Decimal(&#39;NaN&#39;)&gt;&gt;&gt; Decimal(&#39;-Infinity&#39;)Decimal(&#39;-Infinity&#39;)</code></pre><p>如果 FloatOperation 信号被捕获，构造函数中的小数和浮点数的意外混合或排序比较会引发异常</p><pre><code>&gt;&gt;&gt; c = getcontext()&gt;&gt;&gt; c.traps[FloatOperation] = True&gt;&gt;&gt; Decimal(3.14)Traceback (most recent call last):&nbsp; File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.5&#39;) &lt; 3.7Traceback (most recent call last):&nbsp; File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.5&#39;) == 3.5True</code></pre><p>3.3 新版功能.</p><p>新 Decimal 的重要性仅由输入的位数决定。 上下文精度和舍入仅在算术运算期间发挥作用。</p><pre><code>&gt;&gt;&gt; getcontext().prec = 6&gt;&gt;&gt; Decimal(&#39;3.0&#39;)Decimal(&#39;3.0&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;)Decimal(&#39;3.1415926535&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85987&#39;)&gt;&gt;&gt; getcontext().rounding = ROUND_UP&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85988&#39;)</code></pre><p>如果超出了 C 版本的内部限制，则构造一个 decimal 将引发 InvalidOperation</p><pre><code>&gt;&gt;&gt; Decimal(&#34;1e9999999999999999999&#34;)Traceback (most recent call last):&nbsp; File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;decimal.InvalidOperation: [&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</code></pre><p>在 3.3 版更改.</p><p>Decimal 数字能很好地与 Python 的其余部分交互。 以下是一个小小的 decimal 浮点数飞行马戏团：</p><pre><code>&gt;&gt;&gt; data = list(map(Decimal, &#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;.split()))&gt;&gt;&gt; max(data)Decimal(&#39;9.25&#39;)&gt;&gt;&gt; min(data)Decimal(&#39;0.03&#39;)&gt;&gt;&gt; sorted(data)[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]&gt;&gt;&gt; sum(data)Decimal(&#39;19.29&#39;)&gt;&gt;&gt; a,b,c = data[:3]&gt;&gt;&gt; str(a)&#39;1.34&#39;&gt;&gt;&gt; float(a)1.34&gt;&gt;&gt; round(a, 1)Decimal(&#39;1.3&#39;)&gt;&gt;&gt; int(a)1&gt;&gt;&gt; a * 5Decimal(&#39;6.70&#39;)&gt;&gt;&gt; a * bDecimal(&#39;2.5058&#39;)&gt;&gt;&gt; c % aDecimal(&#39;0.77&#39;)</code></pre><p>Decimal 也可以使用一些数学函数：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 28&gt;&gt;&gt; Decimal(2).sqrt()Decimal(&#39;1.414213562373095048801688724&#39;)&gt;&gt;&gt; Decimal(1).exp()Decimal(&#39;2.718281828459045235360287471&#39;)&gt;&gt;&gt; Decimal(&#39;10&#39;).ln()Decimal(&#39;2.302585092994045684017991455&#39;)&gt;&gt;&gt; Decimal(&#39;10&#39;).log10()Decimal(&#39;1&#39;)</code></pre><p>quantize() 方法将数字四舍五入为固定指数。 此方法对于将结果舍入到固定的位置的货币应用程序非常有用：</p><pre><code>&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;.01&#39;), rounding=ROUND_DOWN)Decimal(&#39;7.32&#39;)&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;1.&#39;), rounding=ROUND_UP)Decimal(&#39;8&#39;)</code></pre><p>如上所示，getcontext() 函数访问当前上下文并允许更改设置。 这种方法满足大多数应用程序的需求。</p><p>对于更高级的工作，使用 Context() 构造函数创建备用上下文可能很有用。 要使用备用活动，请使用 setcontext() 函数。</p><p>根据标准，decimal 模块提供了两个现成的标准上下文 BasicContext 和 ExtendedContext 。 前者对调试特别有用，因为许多陷阱都已启用：</p><pre><code>&gt;&gt;&gt; myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)&gt;&gt;&gt; setcontext(myothercontext)&gt;&gt;&gt; Decimal(1) / Decimal(7)Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)&gt;&gt;&gt; ExtendedContextContext(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capitals=1, clamp=0, flags=[], traps=[])&gt;&gt;&gt; setcontext(ExtendedContext)&gt;&gt;&gt; Decimal(1) / Decimal(7)Decimal(&#39;0.142857143&#39;)&gt;&gt;&gt; Decimal(42) / Decimal(0)Decimal(&#39;Infinity&#39;)&gt;&gt;&gt; setcontext(BasicContext)&gt;&gt;&gt; Decimal(42) / Decimal(0)Traceback (most recent call last):&nbsp; File &#34;&lt;pyshell#143&gt;&#34;, line 1, in -toplevel-&nbsp;&nbsp;&nbsp; Decimal(42) / Decimal(0)DivisionByZero: x / 0</code></pre><p>上下文还具有用于监视计算期间遇到的异常情况的信号标志。 标志保持设置直到明确清除，因此最好通过使用 clear_flags() 方法清除每组受监控计算之前的标志。:</p><pre><code>&gt;&gt;&gt; setcontext(ExtendedContext)&gt;&gt;&gt; getcontext().clear_flags()&gt;&gt;&gt; Decimal(355) / Decimal(113)Decimal(&#39;3.14159292&#39;)&gt;&gt;&gt; getcontext()Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</code></pre><p>flags 条目显示对 Pi 的有理逼近被舍入（超出上下文精度的数字被抛弃）并且结果是不精确的（一些丢弃的数字不为零）。</p><p>使用上下文的 traps 字段中的字典设置单个陷阱：</p><pre><code>&gt;&gt;&gt; setcontext(ExtendedContext)&gt;&gt;&gt; Decimal(1) / Decimal(0)Decimal(&#39;Infinity&#39;)&gt;&gt;&gt; getcontext().traps[DivisionByZero] = 1&gt;&gt;&gt; Decimal(1) / Decimal(0)Traceback (most recent call last):&nbsp; File &#34;&lt;pyshell#112&gt;&#34;, line 1, in -toplevel-&nbsp;&nbsp;&nbsp; Decimal(1) / Decimal(0)DivisionByZero: x / 0</code></pre><p>大多数程序仅在程序开始时调整当前上下文一次。 并且，在许多应用程序中，数据在循环内单个强制转换为 Decimal 。 通过创建上下文集和小数，程序的大部分操作数据与其他 Python 数字类型没有区别。</p><h2 class=pgc-h-arrow-right>Decimal 对象</h2><p>class decimal.<strong>Decimal</strong>(value="0", context=None)根据 value 构造一个新的 Decimal 对象。value 可以是整数，字符串，元组，float ，或另一个 Decimal 对象。 如果没有给出 value，则返回 Decimal('0')。 如果 value 是一个字符串，它应该在前导和尾随空格字符以及下划线被删除之后符合十进制数字字符串语法:</p><p>sign ::= '+' | '-'</p><p>digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'</p><p>indicator ::= 'e' | 'E'</p><p>digits ::= digit [digit]...</p><p>decimal-part ::= digits '.' [digits] | ['.']</p><p>digits exponent-part ::= indicator [sign]</p><p>digitsinfinity ::= 'Infinity' | 'Inf'</p><p>nan ::= 'NaN' [digits] | 'sNaN' [digits]</p><p>numeric-value ::= decimal-part [exponent-part] | infinity</p><p>numeric-string ::= [sign] numeric-value | [sign] nan</p><p>当上面出现 digit 时也允许其他十进制数码。 其中包括来自各种其他语言系统的十进制数码（例如阿拉伯-印地语和天城文的数码）以及全宽数码 '\uff10' 到 '\uff19'。如果 value 是一个 tuple ，它应该有三个组件，一个符号（ 0 表示正数或 1 表示负数），一个数字的 tuple 和整数指数。 例如， Decimal((0, (1, 4, 1, 4), -3)) 返回 Decimal('1.414')。如果 value 是 float ，则二进制浮点值无损地转换为其精确的十进制等效值。 此转换通常需要53位或更多位数的精度。 例如， Decimal(float('1.1')) 转换为``Decimal(‘1.100000000000000088817841970012523233890533447265625’)``。</p><p>context 精度不会影响存储的位数。 这完全由 value 中的位数决定。 例如，Decimal('3.00000') 记录所有五个零，即使上下文精度只有三。context 参数的目的是确定 value 是格式错误的字符串时该怎么做。 如果上下文陷阱 InvalidOperation，则引发异常；否则，构造函数返回一个新的 Decimal，其值为 NaN。构造完成后， Decimal 对象是不可变的。在 3.2 版更改: 现在允许构造函数的参数为 float 实例。在 3.3 版更改: float 参数在设置 FloatOperation 陷阱时引发异常。 默认情况下，陷阱已关闭。在 3.6 版更改: 允许下划线进行分组，就像代码中的整数和浮点文字一样。十进制浮点对象与其他内置数值类型共享许多属性，例如 float 和 int 。 所有常用的数学运算和特殊方法都适用。 同样，十进制对象可以复制、pickle、打印、用作字典键、用作集合元素、比较、排序和强制转换为另一种类型（例如 float 或 int ）。算术对十进制对象和算术对整数和浮点数有一些小的差别。 当余数运算符 % 应用于Decimal对象时，结果的符号是 被除数 的符号，而不是除数的符号:<strong>>>></strong> (-7) % 4 1<strong>>>></strong> Decimal(-7) % Decimal(4) Decimal('-3')整数除法运算符 // 的行为类似，返回真商的整数部分（截断为零）而不是它的向下取整，以便保留通常的标识 x == (x // y) * y + x % y:<strong>>>></strong> -7 // 4 -2<strong>>>></strong> Decimal(-7) // Decimal(4) Decimal('-1')% 和 // 运算符实现了 remainder 和 divide-integer 操作（分别），如规范中所述。十进制对象通常不能与浮点数或 fractions.Fraction 实例在算术运算中结合使用：例如,尝试将 Decimal 加到 float ，将引发 TypeError。 但是，可以使用 Python 的比较运算符来比较 Decimal 实例 x 和另一个数字 y 。 这样可以避免在对不同类型的数字进行相等比较时混淆结果。在 3.2 版更改: 现在完全支持 Decimal 实例和其他数字类型之间的混合类型比较。除了标准的数字属性，十进制浮点对象还有许多专门的方法：</p><p><strong>adjusted</strong>()</p><p>在移出系数最右边的数字之后返回调整后的指数，直到只剩下前导数字：Decimal('321e+5').adjusted() 返回 7 。 用于确定最高有效位相对于小数点的位置。<strong>as_integer_ratio</strong>()</p><p>返回一对 (n, d) 整数，表示给定的 Decimal 实例作为分数、最简形式项并带有正分母:<strong>>>></strong> Decimal('-3.14').as_integer_ratio() (-157, 50)转换是精确的。 在 Infinity 上引发 OverflowError ，在 NaN 上引起 ValueError 。3.6 新版功能.</p><p><strong>as_tuple</strong>()</p><p>返回一个 named tuple 表示的数字： DecimalTuple(sign, digits, exponent)。</p><p><strong>canonical</strong></p><p>()返回参数的规范编码。 目前，一个 Decimal 实例的编码始终是规范的，因此该操作返回其参数不变。<strong>compare</strong>(other, context=None)比较两个 Decimal 实例的值。 compare() 返回一个 Decimal 实例，如果任一操作数是 NaN ，那么结果是 NaNa <strong>or</strong> b <strong>is</strong> a NaN ==> Decimal('NaN') a &lt; b ==> Decimal('-1') a == b ==> Decimal('0') a > b ==> Decimal('1') <strong>compare_signal</strong>(other, context=None)</p><p>除了所有 NaN 信号之外，此操作与 compare() 方法相同。 也就是说，如果两个操作数都不是信令NaN，那么任何静默的 NaN 操作数都被视为信令NaN。<strong>compare_total</strong>(other, context=None)使用它们的抽象表示而不是它们的数值来比较两个操作数。 类似于 compare() 方法，但结果给出了一个总排序 Decimal 实例。 两个 Decimal 实例具有相同的数值但不同的表示形式在此排序中比较不相等：<strong>>>></strong> Decimal('12.0').compare_total(Decimal('12')) Decimal('-1')静默和发出信号的 NaN 也包括在总排序中。 这个函数的结果是 Decimal('0') 如果两个操作数具有相同的表示，或是 Decimal('-1') 如果第一个操作数的总顺序低于第二个操作数，或是 Decimal('1') 如果第一个操作数在总顺序中高于第二个操作数。 有关总排序的详细信息，请参阅规范。此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。<strong>compare_total_mag</strong>(other, context=None)比较两个操作数使用它们的抽象表示而不是它们的值，如 compare_total()，但忽略每个操作数的符号。 x.compare_total_mag(y) 相当于 x.copy_abs().compare_total(y.copy_abs())。此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。<strong>conjugate</strong>()只返回self，这种方法只符合 Decimal 规范。<strong>copy_abs</strong>()返回参数的绝对值。 此操作不受上下文影响并且是静默的：没有更改标志且不执行舍入。<strong>copy_negate</strong>()回到参数的否定。 此操作不受上下文影响并且是静默的：没有标志更改且不执行舍入。<strong>copy_sign</strong>(other, context=None)返回第一个操作数的副本，其符号设置为与第二个操作数的符号相同。 例如：<strong>>>></strong> Decimal('2.3').copy_sign(Decimal('-1.5')) Decimal('-2.3')此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。<strong>exp</strong>(context=None)返回给定数字的（自然）指数函数``e**x``的值。结果使用 ROUND_HALF_EVEN 舍入模式正确舍入。<strong>>>></strong> Decimal(1).exp() Decimal('2.718281828459045235360287471')<strong>>>></strong> Decimal(321).exp() Decimal('2.561702493119680037517373933E+139')<strong>from_float</strong>(f)将浮点数转换为十进制数的类方法。注意， Decimal.from_float(0.1) 与 Decimal(‘0.1’) 不同。 由于 0.1 在二进制浮点中不能精确表示，因此该值存储为最接近的可表示值，即 0x1.999999999999ap-4 。 十进制的等效值是`0.1000000000000000055511151231257827021181583404541015625`。<strong>注解</strong>从 Python 3.2 开始，Decimal 实例也可以直接从 float 构造。</p><pre><code>&gt;&gt;&gt; Decimal.from_float(0.1) Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)&gt;&gt;&gt; Decimal.from_float(float(&#39;nan&#39;)) Decimal(&#39;NaN&#39;)&gt;&gt;&gt; Decimal.from_float(float(&#39;inf&#39;)) Decimal(&#39;Infinity&#39;)&gt;&gt;&gt; Decimal.from_float(float(&#39;-inf&#39;)) Decimal(&#39;-Infinity&#39;)</code></pre><p>3.1 新版功能.</p><p><strong>fma</strong>(other, third, context=None)混合乘法加法。 返回 self*other+third ，中间乘积 self*other 没有四舍五入。<strong>>>></strong> Decimal(2).fma(3, 5) Decimal('11')<strong>is_canonical</strong>()如果参数是规范的，则为返回 True，否则为 False 。 目前，Decimal 实例总是规范的，所以这个操作总是返回 True 。<strong>is_finite</strong>()如果参数是一个有限的数，则返回为 True ；如果参数为无穷大或 NaN ，则返回为 False。<strong>is_infinite</strong>()如果参数为正负无穷大，则返回为 True ，否则为 False 。<strong>is_nan</strong>()如果参数为 NaN （无论是否静默），则返回为 True ，否则为 False 。<strong>is_normal</strong>(context=None)如果参数是一个有限正规数，返回 True，如果参数是0、次正规数、无穷大或是NaN，返回 False。<strong>is_qnan</strong>()如果参数为静默 NaN，返回 True，否则返回 False。<strong>is_signed</strong>()如果参数带有负号，则返回为 True，否则返回 False。注意，0 和 NaN 都可带有符号。<strong>is_snan</strong>()如果参数为显式 NaN，则返回 True，否则返回 False。<strong>is_subnormal</strong>(context=None)如果参数为次正规数，则返回 True，否则返回 False。<strong>is_zero</strong>()如果参数是0（正负皆可），则返回 True，否则返回 False。<strong>ln</strong>(context=None)返回操作数的自然对数（以 e 为底）。结果是使用 ROUND_HALF_EVEN 舍入模式正确四舍五入的。<strong>log10</strong>(context=None)返回操作数的以十为底的对数。结果是使用 ROUND_HALF_EVEN 舍入模式正确四舍五入的。<strong>logb</strong>(context=None)对于一个非零数，返回其运算数的调整后指数作为一个 Decimal 实例。 如果运算数为零将返回 Decimal('-Infinity') 并且产生 the DivisionByZero 标志。如果运算数是无限大则返回 Decimal('Infinity') 。<strong>logical_and</strong>(other, context=None)logical_and() 是需要两个 逻辑运算数 的逻辑运算（参考 逻辑操作数 ）。结果是按位输出的两运算数的 “和”。<strong>logical_invert</strong>(context=None)logical_invert() 是一个逻辑运算。 结果是按位的倒转的运算数。<strong>logical_or</strong>(other, context=None)logical_or() 是需要两个 logical operands 的逻辑运算（请参阅 逻辑操作数 ）。结果是两个运算数的按位的 or 。<strong>logical_xor</strong>(other, context=None)logical_xor() 是需要两个 逻辑运算数 的逻辑运算（参考 逻辑操作数 ）。结果是按位输出的两运算数的异或运算。<strong>max</strong>(other, context=None)像 max(self, other) 一样，除了在返回之前应用上下文舍入规则并且用信号通知或忽略 NaN 值（取决于上下文以及它们是发信号还是安静）。<strong>max_mag</strong>(other, context=None)与 max() 方法相似，但是操作数使用绝对值进行比较。<strong>min</strong>(other, context=None)像 min(self, other) 一样，除了在返回之前应用上下文舍入规则并且用信号通知或忽略 NaN 值（取决于上下文以及它们是发信号还是安静）。<strong>min_mag</strong>(other, context=None)与 min() 方法相似，但是操作数使用绝对值进行比较。<strong>next_minus</strong>(context=None)返回小于给定操作数的上下文中可表示的最大数字（或者当前线程的上下文中的可表示的最大数字如果没有给定上下文）。<strong>next_plus</strong>(context=None)返回大于给定操作数的上下文中可表示的最小数字（或者当前线程的上下文中的可表示的最小数字如果没有给定上下文）。<strong>next_toward</strong>(other, context=None)如果两运算数不相等，返回在第二个操作数的方向上最接近第一个操作数的数。如果两操作数数值上相等，返回将符号设置为与第二个运算数相同的第一个运算数的拷贝。<strong>normalize</strong>(context=None)通过去除尾随的零并将所有结果等于 Decimal('0') 的转化为 Decimal('0e0') 来标准化数字。用于为等效类的属性生成规范值。比如， Decimal('32.100') 和 Decimal('0.321000e+2') 都被标准化为相同的值 Decimal('32.1')。<strong>number_class</strong>(context=None)返回一个字符串描述运算数的 class 。返回值是以下十个字符串中的一个。</p><ul><li>"-Infinity" ，指示操作数为负无穷大。</li><li>"-Normal" ，指示该操作数是负正常数字。</li><li>"-Subnormal" ，指示该操作数是负的次正规数。</li><li>"-Zero" ，指示该操作数是负零。</li><li>"-Zero" ，指示该操作数是正零。</li><li>"+Subnormal" ，指示该操作数是正的次正规数。</li><li>"+Normal" ，指示该操作数是正的正规数。</li><li>"+Infinity" ，指示该运算数是正无穷。</li><li>"NaN" ，指示该运算数是沉寂的 NaN （非数字）。</li><li>"sNaN" ，指示该运算数是信号 NaN 。</li></ul><p><strong>quantize</strong>(exp, rounding=None, context=None)返回的值等于四舍五入的第一个运算数并且具有第二个操作数的指数。<strong>>>></strong> Decimal('1.41421356').quantize(Decimal('1.000')) Decimal('1.414')</p><p><br></p><p>与其他运算不同，如果量化运算后的系数长度大于精度，那么会发出一个 InvalidOperation 信号。这保证了除非有一个错误情况，量化指数恒等于右手运算数的指数。</p><p>与其他运算不同，量化永不信号下溢，即使结果不正常且不精确。</p><p>如果第二个运算数的指数大于第一个运算数的指数那或许需要四舍五入。在这种情况下，舍入模式由给定 rounding 参数决定，其余的由给定 context 参数决定；如果参数都未给定，使用当前线程上下文的舍入模式。</p><p>每当结果的指数大于 Emax 或小于 Etiny 就会返回错误。</p><p><strong>radix</strong>()返回 Decimal(10)，即 Decimal 类进行所有算术运算所用的数制（基数）。 这是为保持与规范描述的兼容性而加入的。<strong>remainder_near</strong>(other, context=None)返回 self 除以 other 的余数。 这与 self % other 的区别在于所选择的余数要使其绝对值最小化。 更准确地说，返回值为 self - n * other 其中 n 是最接近 self / other 的实际值的整数，并且如果两个整数与实际值的差相等则会选择其中的偶数。如果结果为零则其符号将为 self 的符号。</p><pre><code>&gt;&gt;&gt; Decimal(18).remainder_near(Decimal(10)) Decimal(&#39;-2&#39;)&gt;&gt;&gt; Decimal(25).remainder_near(Decimal(10)) Decimal(&#39;5&#39;)&gt;&gt;&gt; Decimal(35).remainder_near(Decimal(10)) Decimal(&#39;-5&#39;)</code></pre><p><strong>rotate</strong>(other, context=None)</p><p>返回对第一个操作数的数码按第二个操作数所指定的数量进行轮转的结果。 第二个操作数必须为 -precision 至 precision 精度范围内的整数。 第二个操作数的绝对值给出要轮转的位数。 如果第二个操作数为正值则向左轮转；否则向右轮转。 如有必要第一个操作数的系数会在左侧填充零以达到 precision 所指定的长度。 第一个操作数的符号和指数保持不变。<strong>same_quantum</strong>(other, context=None)检测自身与 other 是否具有相同的指数或是否均为 NaN。此操作不受上下文影响且静默：不更改任何标志且不执行舍入。 作为例外，如果无法准确转换第二个操作数，则C版本可能会引发InvalidOperation。<strong>scaleb</strong>(other, context=None)返回第一个操作数使用第二个操作数对指数进行调整的结果。 等价于返回第一个操作数乘以 10**other 的结果。 第二个操作数必须为整数。<strong>shift</strong>(other, context=None)返回第一个操作数的数码按第二个操作数所指定的数量进行移位的结果。 第二个操作数必须为 -precision 至 precision 范围内的整数。 第二个操作数的绝对值给出要移动的位数。 如果第二个操作数为正值则向左移位；否则向右移位。 移入系数的数码为零。 第一个操作数的符号和指数保持不变。<strong>sqrt</strong>(context=None)返回参数的平方根精确到完整精度。<strong>to_eng_string</strong>(context=None)转换为字符串，如果需要指数则会使用工程标注法。工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。例如，此方法会将 Decimal('123E+1') 转换为 Decimal('1.23E+3')。<strong>to_integral</strong>(rounding=None, context=None)与 to_integral_value() 方法相同。 保留 to_integral 名称是为了与旧版本兼容。<strong>to_integral_exact</strong>(rounding=None, context=None)舍入到最接近的整数，发出信号 Inexact 或者如果发生舍入则相应地发出信号 Rounded。 如果给出 rounding 形参则由其确定舍入模式，否则由给定的 context 来确定。 如果没有给定任何形参则会使用当前上下文的舍入模式。<strong>to_integral_value</strong>(rounding=None, context=None)舍入到最接近的整数而不发出 Inexact 或 Rounded 信号。 如果给出 rounding 则会应用其所指定的舍入模式；否则使用所提供的 context 或当前上下文的舍入方法。</p><h3 class=pgc-h-arrow-right>逻辑操作数</h3><p>logical_and(), logical_invert(), logical_or() 和 logical_xor() 方法期望其参数为 逻辑操作数。 逻辑操作数 是指数位与符号位均为零的 Decimal 实例，并且其数字位均为 0 或 1。</p><h2 class=pgc-h-arrow-right>Context 对象</h2><p>上下文是算术运算所在的环境。 它们管理精度、设置舍入规则、确定将哪些信号视为异常，并限制指数的范围。</p><p>每个线程都有自己的当前上下文，可使用 getcontext() 和 setcontext() 函数来读取或修改：</p><p>decimal.<strong>getcontext</strong>()返回活动线程的当前上下文。decimal.<strong>setcontext</strong>(c)将活动线程的当前上下文设为 c。你也可以使用 with 语句和 localcontext() 函数来临时改变活动上下文。decimal.<strong>localcontext</strong>(ctx=None)返回一个上下文管理器，它将在进入 with 语句时将活动线程的当前上下文设为 ctx 的一个副本并在退出 with 语句时恢复之前的上下文。 如果未指定上下文，则会使用当前上下文的一个副本。例如，以下代码会将当前 decimal 精度设为 42 位，执行一个运算，然后自动恢复之前的上下文:<strong>from</strong> <strong>decimal</strong> <strong>import</strong> localcontext</p><p><br></p><p><strong>with</strong> localcontext() <strong>as</strong> ctx:</p><p>ctx.prec = 42 # Perform a high precision calculation</p><p>s = calculate_something()</p><p>s = +s # Round the final result back to the default precision</p><p><br></p><p>新的上下文也可使用下述的 Context 构造器来创建。 此外，模块还提供了三种预设的上下文:</p><p>class decimal.<strong>BasicContext</strong>这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 ROUND_HALF_UP。 清除所有旗标。 启用所有陷阱（视为异常），但 Inexact, Rounded 和 Subnormal 除外。由于启用了许多陷阱，此上下文适用于进行调试。class decimal.<strong>ExtendedContext</strong>这是由通用十进制算术规范描述所定义的标准上下文。 精度设为九。 舍入设为 ROUND_HALF_EVEN。 清除所有旗标。 不启用任何陷阱（因此在计算期间不会引发异常）。由于禁用了陷阱，此上下文适用于希望结果值为 NaN 或 Infinity 而不是引发异常的应用。 这允许应用在出现当其他情况下会中止程序的条件时仍能完成运行。class decimal.<strong>DefaultContext</strong>此上下文被 Context 构造器用作新上下文的原型。 改变一个字段（例如精度）的效果将是改变 Context 构造器所创建的新上下文的默认值。此上下文最适用于多线程环境。 在线程开始前改变一个字段具有设置全系统默认值的效果。 不推荐在线程开始后改变字段，因为这会要求线程同步避免竞争条件。在单线程环境中，最好完全不使用此上下文。 而是简单地电显式创建上下文，具体如下所述。默认值为 prec=28, rounding=ROUND_HALF_EVEN，并为 Overflow, InvalidOperation 和 DivisionByZero 启用陷阱。在已提供的三种上下文之外，还可以使用 Context 构造器创建新的上下文。class decimal.<strong>Context</strong>(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None)创建一个新上下文。 如果某个字段未指定或为 None，则从 DefaultContext 拷贝默认值。 如果 flags 字段未指定或为 None，则清空所有旗标。prec 为一个 [1, MAX_PREC] 范围内的整数，用于设置该上下文中算术运算的精度。rounding 选项应为 Rounding Modes 小节中列出的常量之一。traps 和 flags 字段列出要设置的任何信号。 通常，新上下文应当只设置 traps 而让 flags 为空。Emin 和 Emax 字段给定指数所允许的外部上限。 Emin 必须在 [MIN_EMIN, 0] 范围内，Emax 在 [0, MAX_EMAX] 范围内。capitals 字段为 0 或 1 (默认值)。 如果设为 1，指数将附带打印大写的 E；其他情况则将使用小写的 e: Decimal('6.02e+23')。clamp 字段为 0 (默认值) 或 1。 如果设为 1，则 Decimal 实例的指数 e 的表示范围在此上下文中将严格限制为 Emin - prec + 1 &lt;= e &lt;= Emax - prec + 1。 如果 clamp 为 0 则将适用较弱的条件: Decimal 实例调整后的指数最大值为 Emax。 当 clamp 为 1 时，一个较大的普通数值将在可能的情况下减小其指数并为其系统添加相应数量的零，以便符合指数值限制；这可以保持数字值但会丢失有效末尾零的信息。 例如:>>><strong>>>></strong> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999') Decimal('1.23000E+999')</p><p><br></p><p>clamp 值为 1 时即允许与在 IEEE 754 中描述的固定宽度十进制交换格式相兼容。</p><p>Context 类定义了几种通用方法以及大量直接在给定上下文中进行算术运算的方法。 此外，对于上述的每种 Decimal 方法（不包括 adjusted() 和 as_tuple() 方法）都有一个相应的 Context 方法。 例如，对于一个 Context 的实例 C 和 Decimal 的实例 x，C.exp(x) 就等价于 x.exp(context=C)。 每个 Context 方法都接受一个 Python 整数（即 int 的实例）在任何接受 Decimal 的实例的地方使用。</p><p><strong>clear_flags</strong>()将所有旗标重置为 0。<strong>clear_traps</strong>()将所有陷阱重置为零 0。3.3 新版功能.<strong>copy</strong>()返回上下文的一个副本。<strong>copy_decimal</strong>(num)返回 Decimal 实例 num 的一个副本。<strong>create_decimal</strong>(num)基于 num 创建一个新 Decimal 实例但使用 self 作为上下文。 与 Decimal 构造器不同，该上下文的精度、舍入方法、旗标和陷阱会被应用于转换过程。此方法很有用处，因为常量往往被给予高于应用所需的精度。 另一个好处在于立即执行舍入可以消除超出当前精度的数位所导致的意外效果。 在下面的示例中，使用未舍入的输入意味着在总和中添加零会改变结果：<strong>>>></strong> getcontext().prec = 3 <strong>>>></strong> Decimal('3.4445') + Decimal('1.0023') Decimal('4.45')<strong>>>></strong> Decimal('3.4445') + Decimal(0) + Decimal('1.0023') Decimal('4.44')</p><p><br></p><p>此方法实现了 IBM 规格描述中的转换为数字操作。 如果参数为字符串，则不允许有开头或末尾的空格或下划线。</p><p><strong>create_decimal_from_float</strong>(f)基于浮点数 f 创建一个新的 Decimal 实例，但会使用 self 作为上下文来执行舍入。 与 Decimal.from_float() 类方法不同，上下文的精度、舍入方法、旗标和陷阱会应用到转换中。<strong>>>></strong> context = Context(prec=5, rounding=ROUND_DOWN) <strong>>>></strong> context.create_decimal_from_float(math.pi) Decimal('3.1415')<strong>>>></strong> context = Context(prec=5, traps=[Inexact]) <strong>>>></strong> context.create_decimal_from_float(math.pi) Traceback (most recent call last): ... decimal.Inexact: None3.1 新版功能.<strong>Etiny</strong>()返回一个等于 Emin - prec + 1 的值即次正规化结果中的最小指数值。 当发生向下溢出时，指数会设为 Etiny。<strong>Etop</strong>()返回一个等于 Emax - prec + 1 的值。使用 decimal 的通常方式是创建 Decimal 实例然后对其应用算术运算,这些运算发生在活动线程的当前上下文中。 一种替代方式则是使用上下文的方法在特定上下文中进行计算。 这些方法类似于 Decimal 类的方法，在此仅简单地重新列出。<strong>abs</strong>(x)返回 x 的绝对值。<strong>add</strong>(x, y)返回 x 与 y 的和。<strong>canonical</strong>(x)返回相同的 Decimal 对象 x。<strong>compare</strong>(x, y)对 x 与 y 进行数值比较。<strong>compare_signal</strong>(x, y)对两个操作数进行数值比较。<strong>compare_total</strong>(x, y)对两个操作数使用其抽象表示进行比较。<strong>compare_total_mag</strong>(x, y)对两个操作数使用其抽象表示进行比较，忽略符号。<strong>copy_abs</strong>(x)返回 x 的副本，符号设为 0。<strong>copy_negate</strong>(x)返回 x 的副本，符号取反。<strong>copy_sign</strong>(x, y)从 y 拷贝符号至 x。<strong>divide</strong>(x, y)返回 x 除以 y 的结果。<strong>divide_int</strong>(x, y)返回 x 除以 y 的结果，截短为整数。<strong>divmod</strong>(x, y)两个数字相除并返回结果的整数部分。<strong>exp</strong>(x)返回 e ** x。<strong>fma</strong>(x, y, z)返回 x 乘以 y 再加 z 的结果。<strong>is_canonical</strong>(x)如果 x 是规范的则返回 True；否则返回 False。<strong>is_finite</strong>(x)如果 x 为有限数则返回``True``；否则返回 False。<strong>is_infinite</strong>(x)如果 x 是无限的则返回 True；否则返回 False。<strong>is_nan</strong>(x)如果 x 是 qNaN 或 sNaN 则返回 True；否则返回 False。<strong>is_normal</strong>(x)如果 x 是正规数则返回 True；否则返回 False。<strong>is_qnan</strong>(x)如果 x 是静默 NaN 则返回 True；否则返回 False。<strong>is_signed</strong>(x)x 是负数则返回 True；否则返回 False。<strong>is_snan</strong>(x)如果 x 是显式 NaN 则返回 True；否则返回 False。<strong>is_subnormal</strong>(x)如果 x 是次标准数则返回 True；否则返回 False。<strong>is_zero</strong>(x)如果 x 为零则返回 True；否则返回 False。<strong>ln</strong>(x)返回 x 的自然对数（以 e 为底）。<strong>log10</strong>(x)返回 x 的以 10 为底的对数。<strong>logb</strong>(x)返回操作数的 MSD 等级的指数。<strong>logical_and</strong>(x, y)在操作数的每个数码间应用逻辑运算 and。<strong>logical_invert</strong>(x)反转 x 中的所有数位。<strong>logical_or</strong>(x, y)在操作数的每个数位间应用逻辑运算 or。<strong>logical_xor</strong>(x, y)在操作数的每个数位间应用逻辑运算 xor。<strong>max</strong>(x, y)对两个值执行数字比较并返回其中的最大值。<strong>max_mag</strong>(x, y)对两个值执行忽略正负号的数字比较。<strong>min</strong>(x, y)对两个值执行数字比较并返回其中的最小值。<strong>min_mag</strong>(x, y)对两个值执行忽略正负号的数字比较。<strong>minus</strong>(x)对应于 Python 中的单目取负运算符执行取负操作。<strong>multiply</strong>(x, y)返回 x 和 y 的积。<strong>next_minus</strong>(x)返回小于 x 的最大数字表示形式。<strong>next_plus</strong>(x)返回大于 x 的最小数字表示形式。<strong>next_toward</strong>(x, y)返回 x 趋向于 y 的最接近的数字。<strong>normalize</strong>(x)将 x 改写为最简形式。<strong>number_class</strong>(x)返回 x 的类的表示。<strong>plus</strong>(x)对应于 Python 中的单目前缀取正运算符执行取正操作。 此操作将应用上下文精度和舍入，因此它 不是 标识运算。<strong>power</strong>(x, y, modulo=None)返回 x 的 y 次方，如果给出了模数 modulo 则取其余数。如为两个参数则计算 x**y。 如果 x 为负值则 y 必须为整数。 除非 y 为整数且结果为有限值并可在 ‘precision’ 位内精确表示否则结果将是不精确的。 上下文的舍入模式将被使用。 结果在 Python 版中总是会被正确地舍入。在 3.3 版更改: C 模块计算 power() 时会使用已正确舍入的 exp() 和 ln() 函数。 结果是经过良好定义的，但仅限于“几乎总是正确地舍入”。带有三个参数时，计算 (x**y) % modulo。 对于三个参数的形式，参数将会应用以下限制：</p><blockquote><p>三个参数必须都是整数</p><p>y 必须是非负数</p><p>x 或 y 至少有一个不为零</p><p>modulo 必须不为零且至多有 ‘precision’ 位</p></blockquote><p>来自 Context.power(x, y, modulo) 的结果值等于使用无限精度计算 (x**y) % modulo 所得到的值，但其计算过程更高效。 结果的指数为零，无论 x, y 和 modulo 的指数是多少。 结果值总是完全精确的。</p><p><strong>quantize</strong>(x, y)返回的值等于 x (舍入后)，并且指数为 y。<strong>radix</strong>()恰好返回 10，因为这是 Decimal 对象 :)<strong>remainder</strong>(x, y)返回整除所得到的余数。结果的符号，如果不为零，则与原始除数的符号相同。<strong>remainder_near</strong>(x, y)返回 x - y * n，其中 n 为最接近 x / y 实际值的整数（如结果为 0 则其符号将与 x 的符号相同）。<strong>rotate</strong>(x, y)返回 x 翻转 y 次的副本。<strong>same_quantum</strong>(x, y)如果两个操作数具有相同的指数则返回 True。<strong>scaleb</strong>(x, y)返回第一个操作数对第二个值添加其指数后的结果。<strong>shift</strong>(x, y)返回 x 变换 y 次的副本。<strong>sqrt</strong>(x)非负数基于上下文精度的平方根。<strong>subtract</strong>(x, y)返回 x 和 y 的差。<strong>to_eng_string</strong>(x)转换为字符串，如果需要指数则会使用工程标注法。工程标注法的指数是 3 的倍数。 这会在十进制位的左边保留至多 3 个数码，并可能要求添加一至两个末尾零。<strong>to_integral_exact</strong>(x)舍入到一个整数。<strong>to_sci_string</strong>(x)使用科学计数法将一个数字转换为字符串。</p><h2 class=pgc-h-arrow-right>舍入模式</h2><p>decimal.<strong>ROUND_CEILING</strong>舍入方向 Infinity。decimal.<strong>ROUND_DOWN</strong>舍入方向为零。decimal.<strong>ROUND_FLOOR</strong>舍入方向为 -Infinity。decimal.<strong>ROUND_HALF_DOWN</strong>舍入到最接近的数，同样接近则舍入方向为零。decimal.<strong>ROUND_HALF_EVEN</strong>舍入到最接近的数，同样接近则舍入到最接近的偶数。decimal.<strong>ROUND_HALF_UP</strong>舍入到最接近的数，同样接近则舍入到零的反方向。decimal.<strong>ROUND_UP</strong>舍入到零的反方向。decimal.<strong>ROUND_05UP</strong>如果最后一位朝零的方向舍入后为 0 或 5 则舍入到零的反方向；否则舍入方向为零。</p><h2 class=pgc-h-arrow-right>信号</h2><p>信号代表在计算期间引发的条件。 每个信号对应于一个上下文旗标和一个上下文陷阱启用器。</p><p>上下文旗标将在遇到特定条件时被设定。 在完成计算之后，将为了获得信息而检测旗标（例如确定计算是否精确）。 在检测旗标后，请确保在开始下一次计算之前清除所有旗标。</p><p>如果为信号设定了上下文的陷阱启用器，则条件会导致特定的 Python 异常被引发。 举例来说，如果设定了 DivisionByZero 陷阱，则当遇到此条件时就将引发 DivisionByZero 异常。</p><p>class decimal.<strong>Clamped</strong></p><p>修改一个指数以符合表示限制。通常，限位将在一个指数超出上下文的 Emin 和 Emax 限制时发生。 在可能的情况下，会通过给系数添加零来将指数缩减至符合限制。class decimal.<strong>DecimalException</strong>其他信号的基类，并且也是 ArithmeticError 的一个子类。class decimal.<strong>DivisionByZero</strong>非无限数被零除的信号。可在除法、取余队法或对一个数求负数次幂时发生。 如果此信号未被陷阱捕获，则返回 Infinity 或 -Infinity 并且由对计算的输入来确定正负符号。class decimal.<strong>Inexact</strong>表明发生了舍入且结果是不精确的。有非零数位在舍入期间被丢弃的信号。 舍入结果将被返回。 此信号旗标或陷阱被用于检测结果不精确的情况。class decimal.<strong>InvalidOperation</strong>执行了一个无效的操作。表明请求了一个无意义的操作。 如未被陷阱捕获则返回 NaN。 可能的原因包括:Infinity - Infinity 0 * Infinity Infinity / Infinity x % 0 Infinity % x sqrt(-x) <strong>and</strong> x > 0 0 ** 0 x ** (non-integer) x ** Infinity</p><p><br></p><p>class decimal.<strong>Overflow</strong></p><p>数值的溢出。表明在发生舍入之后的指数大于 Emax。 如果未被陷阱捕获，则结果将取决于舍入模式，或者向下舍入为最大的可表示有限数，或者向上舍入为 Infinity。 无论哪种情况，都将引发 Inexact 和 Rounded 信号。class decimal.<strong>Rounded</strong>发生了舍入，但或许并没有信息丢失。一旦舍入丢弃了数位就会发出此信号；即使被丢弃的数位是零 (例如将 5.00 舍入为 5.0)。 如果未被陷阱捕获，则不经修改地返回结果。 此信号用于检测有效位数的丢弃。</p><p>class decimal.<strong>Subnormal</strong></p><p>在舍入之前指数低于 Emin。当操作结果是次标准数（即指数过小）时就会发出此信号。 如果未被陷阱捕获，则不经修改过返回结果。</p><p>class decimal.<strong>Underflow</strong></p><p>数字向下溢出导致结果舍入到零。当一个次标准数结果通过舍入转为零时就会发出此信号。 同时还将引发 Inexact 和 Subnormal 信号。</p><p>class decimal.<strong>FloatOperation</strong></p><p>为 float 和 Decimal 的混合启用更严格的语义。如果信号未被捕获（默认），则在 Decimal 构造器、create_decimal() 和所有比较运算中允许 float 和 Decimal 的混合。 转换和比较都是完全精确的。 发生的任何混合运算都将通过在上下文旗标中设置 FloatOperation 来静默地记录。 通过 from_float() 或 create_decimal_from_float() 进行显式转换则不会设置旗标。在其他情况下（即信号被捕获），则只静默执行相等性比较和显式转换。 所有其他混合运算都将引发 FloatOperation。以下表格总结了信号的层级结构:</p><pre><code>exceptions.ArithmeticError(exceptions.Exception)    DecimalException        Clamped        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)        Inexact            Overflow(Inexact, Rounded)            Underflow(Inexact, Rounded, Subnormal)        InvalidOperation        Rounded        Subnormal        FloatOperation(DecimalException, exceptions.TypeError)</code></pre><h2 class=pgc-h-arrow-right>浮点数说明</h2><h3 class=pgc-h-arrow-right>通过提升精度来缓解舍入误差</h3><p>使用十进制浮点数可以消除十进制表示错误（即能够完全精确地表示 0.1 这样的数）；然而，某些运算在非零数位超出给定的精度时仍然可能导致舍入错误。</p><p>舍入错误的影响可能因接近相互抵销的加减运算被放大从而导致损失有效位。 Knuth 提供了两个指导性示例，其中出现了精度不足的浮点算术舍入，导致加法的交换律和分配律被打破：</p><pre><code># Examples from Seminumerical Algorithms, Section 4.2.2.&gt;&gt;&gt; from decimal import Decimal, getcontext&gt;&gt;&gt; getcontext().prec = 8&gt;&gt;&gt; u, v, w = Decimal(11111113), Decimal(-11111111), Decimal(&#39;7.51111111&#39;)&gt;&gt;&gt; (u + v) + wDecimal(&#39;9.5111111&#39;)&gt;&gt;&gt; u + (v + w)Decimal(&#39;10&#39;)&gt;&gt;&gt; u, v, w = Decimal(20000), Decimal(-6), Decimal(&#39;6.0000003&#39;)&gt;&gt;&gt; (u*v) + (u*w)Decimal(&#39;0.01&#39;)&gt;&gt;&gt; u * (v+w)Decimal(&#39;0.0060000&#39;)</code></pre><p>decimal 模块则可以通过充分地扩展精度来避免有效位的丢失：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 20&gt;&gt;&gt; u, v, w = Decimal(11111113), Decimal(-11111111), Decimal(&#39;7.51111111&#39;)&gt;&gt;&gt; (u + v) + wDecimal(&#39;9.51111111&#39;)&gt;&gt;&gt; u + (v + w)Decimal(&#39;9.51111111&#39;)&gt;&gt;&gt;&gt;&gt;&gt; u, v, w = Decimal(20000), Decimal(-6), Decimal(&#39;6.0000003&#39;)&gt;&gt;&gt; (u*v) + (u*w)Decimal(&#39;0.0060000&#39;)&gt;&gt;&gt; u * (v+w)Decimal(&#39;0.0060000&#39;)</code></pre><h3 class=pgc-h-arrow-right>特殊的值</h3><p>decimal 模块的数字系统提供了一些特殊的值，包括 NaN, sNaN, -Infinity, Infinity 以及两种零值 +0 和 -0。</p><p>无穷大可以使用 Decimal('Infinity') 来构建。 它们也可以在不捕获 DivisionByZero 信号捕获时通过除以零来产生。 类似地，当不捕获 Overflow 信号时，也可以通过舍入到超出最大可表示数字限制的方式产生无穷大的结果。</p><p>无穷大是有符号的（仿射）并可用于算术运算，它们会被当作极其巨大的不确定数字来处理。 例如，无穷大加一个常量结果也将为无穷大。</p><p>某些不存在有效结果的运算将会返回 NaN，或者如果捕获了 InvalidOperation 信号则会引发一个异常。 例如，0/0 会返回 NaN 表示结果“不是一个数字”。 这样的 NaN 是静默产生的，并且在产生之后参与其它计算时总是会得到 NaN 的结果。 这种行为对于偶而缺少输入的各类计算都很有用处 — 它允许在将特定结果标记为无效的同时让计算继续运行。</p><p>另一种变体形式是 sNaN，它在每次运算后会发出信号而不是保持静默。 当对于无效结果需要中断计算进行特别处理时，这是一个很有用的返回值。</p><p>Python 中比较运算符的行为在涉及 NaN 时可能会令人有点惊讶。 相等性检测在操作数中有静默型或信号型 NaN 时总是会返回 False (即使是执行 Decimal('NaN')==Decimal('NaN'))，而不等性检测总是会返回 True。 当尝试使用 &lt;, &lt;=, > 或 >= 运算符中的任何一个来比较两个 Decimal 值时，如果运算数中有 NaN 则将引发 InvalidOperation 信号，如果此信号未被捕获则将返回 False。 请注意通用十进制算术规范并未规定直接比较行为；这些涉及 NaN 的比较规则来自于 IEEE 854 标准 (见第 5.7 节表 3)。 要确保严格符合标准，请改用 compare() 和 compare-signal() 方法。</p><p>有符号零值可以由向下溢出的运算产生。 它们保留符号是为了让运算结果能以更高的精度传递。 由于它们的大小为零，正零和负零会被视为相等，且它们的符号具有信息。</p><p>在这两个不相同但却相等的有符号零之外，还存在几种零的不同表示形式，它们的精度不同但值也都相等。 这需要一些时间来逐渐适应。 对于习惯了标准浮点表示形式的眼睛来说，以下运算返回等于零的值并不是显而易见的：</p><pre><code>&gt;&gt;&gt; 1 / Decimal(&#39;Infinity&#39;)Decimal(&#39;0E-1000026&#39;)</code></pre><h2 class=pgc-h-arrow-right>使用线程</h2><p>getcontext() 函数会为每个线程访问不同的 Context 对象。 具有单独线程上下文意味着线程可以修改上下文 (例如 getcontext().prec=10) 而不影响其他线程。</p><p>类似的 setcontext() 会为当前上下文的目标自动赋值。</p><p>如果在调用 setcontext() 之前调用了 getcontext()，则 getcontext() 将自动创建一个新的上下文在当前线程中使用。</p><p>新的上下文拷贝自一个名为 DefaultContext 的原型上下文。 要控制默认值以便每个线程在应用运行期间都使用相同的值，可以直接修改 DefaultContext 对象。 这应当在任何线程启动 之前 完成以使得调用 getcontext() 的线程之间不会产生竞争条件。 例如:</p><pre><code># Set applicationwide defaults for all threads about to be launchedDefaultContext.prec = 12DefaultContext.rounding = ROUND_DOWNDefaultContext.traps = ExtendedContext.traps.copy()DefaultContext.traps[InvalidOperation] = 1setcontext(DefaultContext)# Afterwards, the threads can be startedt1.start()t2.start()t3.start(). . .</code></pre><h2 class=pgc-h-arrow-right>例程</h2><p>以下是一些用作工具函数的例程，它们演示了使用 Decimal 类的各种方式:</p><pre><code>def moneyfmt(value, places=2, curr=&#39;&#39;, sep=&#39;,&#39;, dp=&#39;.&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos=&#39;&#39;, neg=&#39;-&#39;, trailneg=&#39;&#39;):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Convert Decimal to a money formatted string.&nbsp;&nbsp;&nbsp; places:&nbsp; required number of places after the decimal point&nbsp;&nbsp;&nbsp; curr:&nbsp;&nbsp;&nbsp; optional currency symbol before the sign (may be blank)&nbsp;&nbsp;&nbsp; sep:&nbsp;&nbsp;&nbsp;&nbsp; optional grouping separator (comma, period, space, or blank)&nbsp;&nbsp;&nbsp; dp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal point indicator (comma or period)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; only specify as blank when places is zero&nbsp;&nbsp;&nbsp; pos:&nbsp;&nbsp;&nbsp;&nbsp; optional sign for positive numbers: &#39;+&#39;, space or blank&nbsp;&nbsp;&nbsp; neg:&nbsp;&nbsp;&nbsp;&nbsp; optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank&nbsp;&nbsp;&nbsp; trailneg:optional trailing minus indicator:&nbsp; &#39;-&#39;, &#39;)&#39;, space or blank&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)&nbsp;&nbsp;&nbsp; &#39;-$1,234,567.89&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)&nbsp;&nbsp;&nbsp; &#39;1.234.568-&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)&nbsp;&nbsp;&nbsp; &#39;($1,234,567.89)&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)&nbsp;&nbsp;&nbsp; &#39;123 456 789.00&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)&nbsp;&nbsp;&nbsp; &#39;&lt;0.02&gt;&#39;&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; q = Decimal(10) ** -places&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 places --&gt; &#39;0.01&#39;&nbsp;&nbsp;&nbsp; sign, digits, exp = value.quantize(q).as_tuple()&nbsp;&nbsp;&nbsp; result = []&nbsp;&nbsp;&nbsp; digits = list(map(str, digits))&nbsp;&nbsp;&nbsp; build, next = result.append, digits.pop&nbsp;&nbsp;&nbsp; if sign:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(trailneg)&nbsp;&nbsp;&nbsp; for i in range(places):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(next() if digits else &#39;0&#39;)&nbsp;&nbsp;&nbsp; if places:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(dp)&nbsp;&nbsp;&nbsp; if not digits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(&#39;0&#39;)&nbsp;&nbsp;&nbsp; i = 0&nbsp;&nbsp;&nbsp; while digits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(next())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i == 3 and digits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(sep)&nbsp;&nbsp;&nbsp; build(curr)&nbsp;&nbsp;&nbsp; build(neg if sign else pos)&nbsp;&nbsp;&nbsp; return &#39;&#39;.join(reversed(result))def pi():&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Compute Pi to the current precision.&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(pi())&nbsp;&nbsp;&nbsp; 3.141592653589793238462643383&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp; # extra digits for intermediate steps&nbsp;&nbsp;&nbsp; three = Decimal(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # substitute &#34;three=3.0&#34; for regular floats&nbsp;&nbsp;&nbsp; lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, na = n+na, na+8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d, da = d+da, da+32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = (t * n) / d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += t&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # unary plus applies the new precisiondef exp(x):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Return e raised to the power of x.&nbsp; Result type matches input type.&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(Decimal(1)))&nbsp;&nbsp;&nbsp; 2.718281828459045235360287471&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(Decimal(2)))&nbsp;&nbsp;&nbsp; 7.389056098930650227230427461&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(2.0))&nbsp;&nbsp;&nbsp; 7.38905609893&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(2+0j))&nbsp;&nbsp;&nbsp; (7.38905609893+0j)&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp;&nbsp;&nbsp; i, lasts, s, fact, num = 0, 0, 1, 1, 1&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fact *= i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num *= x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += num / fact&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +sdef cos(x):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Return the cosine of x as measured in radians.&nbsp;&nbsp;&nbsp; The Taylor series approximation works best for a small value of x.&nbsp;&nbsp;&nbsp; For larger values, first compute x = x % (2 * pi).&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))&nbsp;&nbsp;&nbsp; 0.8775825618903727161162815826&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(cos(0.5))&nbsp;&nbsp;&nbsp; 0.87758256189&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(cos(0.5+0j))&nbsp;&nbsp;&nbsp; (0.87758256189+0j)&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp;&nbsp;&nbsp; i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fact *= i * (i-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num *= x * x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sign *= -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += num / fact * sign&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +sdef sin(x):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Return the sine of x as measured in radians.&nbsp;&nbsp;&nbsp; The Taylor series approximation works best for a small value of x.&nbsp;&nbsp;&nbsp; For larger values, first compute x = x % (2 * pi).&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))&nbsp;&nbsp;&nbsp; 0.4794255386042030002732879352&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(sin(0.5))&nbsp;&nbsp;&nbsp; 0.479425538604&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(sin(0.5+0j))&nbsp;&nbsp;&nbsp; (0.479425538604+0j)&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp;&nbsp;&nbsp; i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fact *= i * (i-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num *= x * x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sign *= -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += num / fact * sign&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +s</code></pre><h2 class=pgc-h-arrow-right>Decimal FAQ</h2><p>Q. 总是输入 decimal.Decimal('1234.5') 是否过于笨拙。 在使用交互解释器时有没有最小化输入量的方式？</p><p>A. 有些用户会将构造器简写为一个字母：</p><pre><code>&gt;&gt;&gt; D = decimal.Decimal&gt;&gt;&gt; D(&#39;1.23&#39;) + D(&#39;3.45&#39;)Decimal(&#39;4.68&#39;)</code></pre><p>Q. 在带有两个十进制位的定点数应用中，有些输入值具有许多位，需要被舍入。 另一些数则不应具有多余位，需要验证有效性。 这种情况应该用什么方法？</p><p>A. 用 quantize() 方法舍入到固定数量的十进制位。 如果设置了 Inexact 陷阱，它也适用于验证有效性：</p><pre><code>&gt;&gt;&gt; TWOPLACES = Decimal(10) ** -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # same as Decimal(&#39;0.01&#39;)&gt;&gt;&gt; # Round to two places&gt;&gt;&gt; Decimal(&#39;3.214&#39;).quantize(TWOPLACES)Decimal(&#39;3.21&#39;)&gt;&gt;&gt; # Validate that a number does not exceed two places&gt;&gt;&gt; Decimal(&#39;3.21&#39;).quantize(TWOPLACES, context=Context(traps=[Inexact]))Decimal(&#39;3.21&#39;)&gt;&gt;&gt; Decimal(&#39;3.214&#39;).quantize(TWOPLACES, context=Context(traps=[Inexact]))Traceback (most recent call last):&nbsp;&nbsp; ...Inexact: None</code></pre><p>Q. 当我使用两个有效位的输入时，我要如何在一个应用中保持有效位不变？</p><p>A. 某些运算例如与整数相加、相减和相乘将会自动保留固定的小数位数。 其他运算，例如相除和非整数相乘则将会改变小数位数，需要再加上 quantize() 处理步骤：</p><pre><code>&gt;&gt;&gt; a = Decimal(&#39;102.72&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initial fixed-point values&gt;&gt;&gt; b = Decimal(&#39;3.17&#39;)&gt;&gt;&gt; a + b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Addition preserves fixed-pointDecimal(&#39;105.89&#39;)&gt;&gt;&gt; a - bDecimal(&#39;99.55&#39;)&gt;&gt;&gt; a * 42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # So does integer multiplicationDecimal(&#39;4314.24&#39;)&gt;&gt;&gt; (a * b).quantize(TWOPLACES)&nbsp;&nbsp;&nbsp;&nbsp; # Must quantize non-integer multiplicationDecimal(&#39;325.62&#39;)&gt;&gt;&gt; (b / a).quantize(TWOPLACES)&nbsp;&nbsp;&nbsp;&nbsp; # And quantize divisionDecimal(&#39;0.03&#39;)</code></pre><p>在开发定点数应用时，更方便的做法是定义处理 quantize() 步骤的函数：</p><pre><code>&gt;&gt;&gt; def mul(x, y, fp=TWOPLACES):... &nbsp;&nbsp;&nbsp; return (x * y).quantize(fp)&gt;&gt;&gt; def div(x, y, fp=TWOPLACES):... &nbsp;&nbsp;&nbsp; return (x / y).quantize(fp)&gt;&gt;&gt; mul(a, b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Automatically preserve fixed-pointDecimal(&#39;325.62&#39;)&gt;&gt;&gt; div(b, a)Decimal(&#39;0.03&#39;)</code></pre><p>Q. 表示同一个值有许多方式。 数字 200, 200.000, 2E2 和 02E+4 的值都相同但有精度不同。 是否有办法将它们转换为一个可识别的规范值？</p><p>A. normalize() 方法可将所有相同的值映射为统一表示形式：</p><pre><code>&gt;&gt;&gt; values = map(Decimal, &#39;200 200.000 2E2 .02E+4&#39;.split())&gt;&gt;&gt; [v.normalize() for v in values][Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</code></pre><p>Q. 有些十进制值总是被打印为指数表示形式。 是否有办法得到一个非指数表示形式？</p><p>A. 对于某些值来说，指数表示形式是表示系数中有效位的唯一办法。 例如，将 5.0E+3 表示为 5000 可以让值保持恒定，但是无法显示原本的两位有效数字。</p><p>如果一个应用不必关心追踪有效位，则可以很容易地移除指数和末尾的零，丢弃有效位但让值保持不变：</p><pre><code>&gt;&gt;&gt; def remove_exponent(d):... &nbsp;&nbsp;&nbsp; return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()&gt;&gt;&gt; remove_exponent(Decimal(&#39;5E+3&#39;))Decimal(&#39;5000&#39;)</code></pre><p>Q. 是否有办法将一个普通浮点数转换为 Decimal？</p><p>A. 是的，任何二进制浮点数都可以精确地表示为 Decimal 值，但精确的转换可能需要比直觉设想更高的精度：</p><pre><code>&gt;&gt;&gt; Decimal(math.pi)Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</code></pre><p>Q. 在一个复杂的计算中，我怎样才能保证不会得到由精度不足和舍入异常所导致的虚假结果。</p><p>A. 使用 decimal 模块可以很容易地检测结果。 最好的做法是使用更高的精度和不同的舍入模式重新进行计算。 明显不同的结果表明存在精度不足、舍入模式问题、不符合条件的输入或是结果不稳定的算法。</p><p>Q. 我发现上下文精度的应用只针对运算结果而不针对输入。在混合使用不同精度的值时有什么需要注意的吗？</p><p>A. 是的。 原则上所有值都会被视为精确值，在这些值上进行的算术运算也是如此。 只有结果会被舍入。 对于输入来说其好处是“所输入即所得”。 而其缺点则是如果你忘记了输入没有被舍入，结果看起来可能会很奇怪：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 3&gt;&gt;&gt; Decimal(&#39;3.104&#39;) + Decimal(&#39;2.104&#39;)Decimal(&#39;5.21&#39;)&gt;&gt;&gt; Decimal(&#39;3.104&#39;) + Decimal(&#39;0.000&#39;) + Decimal(&#39;2.104&#39;)Decimal(&#39;5.20&#39;)</code></pre><p>解决办法是提高精度或使用单目加法运算对输入执行强制舍入：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 3&gt;&gt;&gt; +Decimal(&#39;1.23456789&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # unary plus triggers roundingDecimal(&#39;1.23&#39;)</code></pre><p>此外，还可以使用 Context.create_decimal() 方法在创建输入时执行舍入：</p><pre><code>&gt;&gt;&gt; Context(prec=5, rounding=ROUND_DOWN).create_decimal(&#39;1.2345678&#39;)Decimal(&#39;1.2345</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'python3','零学习','5.3'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/3e0ac5fa.html alt=python3从零学习-5.3.5、生成伪随机数random class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/3e0ac5fa.html title=python3从零学习-5.3.5、生成伪随机数random>python3从零学习-5.3.5、生成伪随机数random</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>