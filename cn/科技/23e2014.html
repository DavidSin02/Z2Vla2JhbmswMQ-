<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析 | 极客快訊</title><meta property="og:title" content="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6f70b8b7cd0f4dad93aced78cc14ffcf"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/23e2014.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/23e2014.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/23e2014.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/23e2014.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/23e2014.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/23e2014.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/23e2014.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/23e2014.html><meta property="article:published_time" content="2020-10-29T20:58:14+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:14+08:00"><meta name=Keywords content><meta name=description content="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/23e2014.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1 class=ql-align-center><strong>简介</strong></h1><hr><p class=ql-align-justify><strong><em>MachineLearning Yearning</em></strong>Sharing 是北京科技大学“机器学习研讨小组”旗下的文献翻译项目，其原文由Deep Learning.ai 公司的吴恩达博士进行撰写。本部分文献翻译工作旨在研讨小组内部交流，内容原创为吴恩达博士，学习小组成员只对文献内容进行翻译，对于翻译有误的部分，欢迎大家提出。欢迎大家一起努力学习、提高，共同进步！</p><blockquote><strong>【关注微信公众号：《人工智能前沿讲习班》，回复“MLY”，获取完整版PDF电子书】</strong></blockquote><h1 class=ql-align-center><strong>致谢</strong></h1><hr><p class=ql-align-justify>Deep Learning.ai公司</p><p class=ql-align-justify>吴恩达（原文撰稿人）</p><p class=ql-align-justify>陆顺（1-5章）</p><p class=ql-align-justify>梁爽（6-10章）</p><p class=ql-align-justify>郑烨（11-15章）</p><p class=ql-align-justify>吴晨瑶（16-20章）</p><p class=ql-align-justify>玉岩（21-25章）</p><p class=ql-align-justify>陈波昊（25-30章）</p><p class=ql-align-justify>翟昊（31-35章）</p><p class=ql-align-justify>高宏宇（36-40章）</p><p class=ql-align-justify>丁韩旭（41-45章）</p><p class=ql-align-justify>李汤睿（46-50章）</p><p class=ql-align-justify>马聪 （整体汇总）</p><p class=ql-align-justify>北京科技大学“机器学习研讨小组”</p><p class=ql-align-justify>人工智能前沿学生论坛（FrontierForum of Artificial Intelligence）</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6f70b8b7cd0f4dad93aced78cc14ffcf><p class=pgc-img-caption></p></div><h1 class=ql-align-center><strong>13、快速的建立你的初始系统并不断迭代</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：郑烨</p><p class=ql-align-justify>你想要完成一个新的垃圾短信过滤系统，你的团队提出了以下想法：</p><p class=ql-align-justify>收集大量的垃圾邮件作为建立训练数据。例如，故意将一些邮件地址暴露给已知的垃圾邮件发送源，以便自动获取它们发来的大量垃圾邮件。</p><p class=ql-align-justify>选择好的特征用于识别邮件内容。</p><p class=ql-align-justify>选择特征用于识别垃圾邮件的标题，来源等等</p><p class=ql-align-justify>即使我之前在这个问题上有着丰富的经验，我还是很难选择应该选择哪个想法，这对于小白来说当然更加使他们迷茫。</p><p class=ql-align-justify>所以不要想着一开始就设计一个完美的系统，而是快速的建立一个基础的系统，然后你将迅速找到你进一步改进的方向。</p><h1 class=ql-align-justify><strong>14、错误分析：回头看看你的验证集</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：郑烨</p><p class=ql-align-justify>当你使用你开发的猫咪分类app时，你发现一些狗狗被误分类为了猫咪，尤其是当那些狗长得和猫很像的时候！也就是说把狗误分类为猫是影响系统精度的一部分。</p><p class=ql-align-justify>此时团队中有成员提议将现有模型和别的第三方的狗的分类器进行结合来解决这种情况，但是整个调整可能需要一个月的时间，那你应该让他们这么做吗？</p><p class=ql-align-justify>在花费一个月时间之前，我建议你评估一下这么做会给系统带来多少准确率的提升，也就是评估一下对于狗的误分类情况到底多大程度的影响了性能。这样你可以更加合理的分配时间和设定努力的方向。</p><p class=ql-align-justify>具体而言，你可以：</p><p class=ql-align-justify>1、从验证集中得到100个当前系统分类错误的样本</p><p class=ql-align-justify>2、人工的检查这些样本，看一下有多少错误分类是将狗分类成了猫</p><p class=ql-align-justify>这个过程就叫做错误分析。如果你发现只有5%的误分类样本是狗，那么无论你怎么提升你的算法在狗这一类样本上的性能，你也最多只能避免这5%的错误。换句话说，你这么做最多只有5%的性能收益。因此，假设你的系统目前分类正确率为90%，那么这个提升只能最多把准确率提高到90.5%，但你却会为此付出一个月的宝贵时间。</p><p class=ql-align-justify>反之，如果你发现有50%的误分类都是来源于狗的样本，那么你就可以非常有把握的改进这一点来大大提升系统准确率。这将能够使得准确率最多从90%提升到95%。</p><p class=ql-align-justify>误差分析可以帮助你分析出哪个改进方向能够带来更多的性能提升。我见过很多工程师不愿意做误差分析，他们总是宁愿埋头钻进一个问题中努力解决它，而不是先评估一下是否值得花时间这么做，这恰好是一个很常见的错误。这会导致你的团队努力了很久却发现只带来了一点点的提升。</p><p class=ql-align-justify>手动的检查100张图片并花费不了你太长时间，却能大大节省你宝贵的研发时间。</p><p class=ql-align-justify>错误分析指的是查看你的算法在验证集上犯错误的具体情况，从而把握错误的原因。它可以帮助你以及启发你分析项目下一步的努力方向。</p><h1><strong>15、进行错误分析时并行的评估你的不同想法</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：郑烨</p><p class=ql-align-justify>你的团队会有很多改进猫咪分类检测系统的想法：</p><p class=ql-align-justify>解决把狗误分类为猫的问题；</p><p class=ql-align-justify>解决把一些大型猫科动物（如狮子、老虎）分类为猫咪的问题；</p><p class=ql-align-justify>提升在识别模糊图像时的性能等等</p><p class=ql-align-justify>你可以有效的并行分析这些想法。我通常会建立一个表格，通过进行对100个验证集样本进行错误分析时填写它。我还记下了关于一些具体样本的备注。为了说明这个过程，让我们看一下你用从一个小的验证集获取的四个样本生成的表格：</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d0c39f064cd84de9b9834eca7cfdfd91><p class=pgc-img-caption></p></div><p class=ql-align-justify>例如图片3即是将大猫分为了猫，也是属于模糊图片。</p><p class=ql-align-justify>当然你在设定好这个表格后进行人工查看样本的过程中也会发现一些新的错误类型，例如你会发现很多错误是各种照片app自带的滤镜导致的，那么你就可以在表格中新增加一个引起错误的类别。这同时也在启发你寻找下一步改进的方向。</p><p class=ql-align-justify>这样做的好一个不断迭代的过程，开始的时候不必要担心你想的初始错误类别不够全面，只需要在检查的过程中不断完善即可。</p><p class=ql-align-justify>假设你在100个验证集样本上进行了错误分析，结果如下：</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/28bfbcd111b94e899c0cfca619b48fb9><p class=pgc-img-caption></p></div><p class=ql-align-justify>你现在会清晰的认识到解决狗的误分类问题最多只能提升8%的准确率。而解决大猫误分类和图像模糊问题可以大大提升性能。因此，你应该优先集中精力与解决后两种类别的错误。如果你的团队有足够的人手，那么你可以并行的解决它们。</p><p class=ql-align-justify>错误分析不存在数学上的理论证明告诉你哪个是优先级最高的任务，你必须结合自身的期望进度来调整具体的工作方向。</p><h1 class=ql-align-center><strong>16、清理误标记的验证集和测试集样本</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：吴晨瑶</p><p class=ql-align-justify>在错误分析中，你可能注意到你的验证集中有一些样本是被错误标记的。我这里指的“误标记”是指这些图片在算法处理之前就已经被贴标人员错误标记了。即，样本(x,y)的类标签有一个不正确的值y。举个例子，可能有些图片不是猫却被错误标记成了含有猫，反之亦然。如果你怀疑错误标记的这一部分图像很重要，就加一个类别去跟踪这部分被误标记的样本：</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f416f36e062a49818093965eb07113bf><p class=pgc-img-caption></p></div><p class=ql-align-justify>你应该在你的验证集中纠正这些标记吗？别忘了验证集的作用是要帮助你快速评价你的算法，这样你就可以知道算法A和B哪个更好。如果验证集误标记的这一部分阻碍了你做出判断的能力，那么花时间去改正这些验证集中被误标记的标签就是值得的。</p><p class=ql-align-justify>举个例子，假设你的分类器的性能是：</p><ul><li class=ql-align-justify>验证集的总体精度…………………………………………….90%(10%总误差)</li><li class=ql-align-justify>误标记样本造成的误差…………………………………….0.6%(6%的验证集误差)</li><li class=ql-align-justify>其他因素造成的误差………………………………………..9.4%(94%的验证集误差)</li></ul><p class=ql-align-justify>这里，误标记造成的0.6%的误差可能与你可以改进的9.4%的误差相比不值一提。虽然手动改正验证集中的误标记图像没有坏处，但是这样不会起到关键性的作用：不知道你的系统总误差是10%还是9.4%没什么不好的。</p><p class=ql-align-justify>假设你继续改进你的猫分类器，然后达到了下述性能：</p><ul><li class=ql-align-justify>验证集的总体精度…………………………………..……….98%(2.0%总误差)</li><li class=ql-align-justify>误标记样本造成的误差…………………………………….0.6%(30%的验证集误差)</li><li class=ql-align-justify>其他因素造成的误差………………………………………..1.4%(70%的验证集误差)</li></ul><p class=ql-align-justify>30%的误差归因于误标记的验证集图像，这给你的准确性估计附加了显著误差。现在提升验证集标签的质量就变得值得了。处理误标记的样本有助于判断分类器的误差是更接近1.4%还是2% —— 一个显著的相对差异。</p><p class=ql-align-justify>开始容忍一些误标记的验证集/测试集很常见。只是在你的系统有所改进之后你会改变主意，因为系统的改进使得误标记样本部分造成的错误率相对于总误差集来说有所增长。</p><p class=ql-align-justify>最后一章解释了如何通过改进算法去改进错误类别，比如狗、大猫和模糊。在本章中你已经了解到你也可以使用误标记的类别—— 通过改进数据的标签。</p><p class=ql-align-justify>无论你采用哪种流程去改正验证集的标签，记住也要在测试集中采用同一流程，这样你的验证集和测试集才可以继续从同一分布中提取。将验证集和测试集一起改正可以避免我们在第六章中讨论过的问题。当你的团队优化验证集性能时，却只能发现他们一直在判断一个基于不同数据集的不同标准。</p><p class=ql-align-justify>如果你决定提升标签质量，要复核你的系统误分类和正确分类两个部分的样本标签。原始标签和你的学习算法在一个样本上同时出现错误也是有可能的。如果你只是改正了你的系统误分类的样本标签，你可能会把偏差引到你的评价中。如果你有1000个验证集样本，而且你的分类器有98%的精确性，检查20个误分类的样本要比检查980个正确分类的样本要容易。因为在实践中仅仅核实误分类的样本要更加容易，偏差确实会蔓延到一些验证集。如果你只对开发一个产品或应用感兴趣这个偏差是可以被接受的。但是如果你是计划在学术论文中使用这个结果或者需要测试集精度的完全无偏度量，这就会是一个问题。</p><h1 class=ql-align-center><strong>17、如果你有一个大验证集，分割成两个子集，只有一个是你查看的</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：吴晨瑶</p><p class=ql-align-justify>假设你有一个含5000个样本且错误率为20%的大验证集。因此，你的算法在误分类1000个左右的验证图像。因为手动检查1000个图像要花费很长的时间，所以我们可能会决定不要在错误分析中将他们全部用上。</p><p class=ql-align-justify>在这种情况下，我会明确地将验证集分割成两个子集，其中一个是你查看的，而另一个不是。你会迅速的过拟合你手动查看的部分。你可以使用非手动查看的这一部分去调整参数。</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/159c406ce1f447149281f065b389c445><p class=pgc-img-caption></p></div><p class=ql-align-justify>让我们继续上面我们的算法在误分类5000个验证集样本中的1000个的这个例子。假设在错误分析中我们想手动验证大概100个错误(错误的10%)。你应该随机选择验证集中的10%然后把它们放置在我们叫做<strong>眼球验证集</strong>的这个地方以提醒自己我们正在用我们的眼睛查看它们。(在一个语音识别的项目中，你会听音频剪辑。这种情况作为替代你可能会管这个集合叫耳朵验证集。)这个眼球验证集就这样有了500个样本，而且我们期待我们的算法会误分类100个。</p><p class=ql-align-justify>第二个验证集的子集我们称为<strong>黑箱验证集</strong>，它会含有剩下的4500个样本。你可以使用黑箱验证集，通过衡量他们的错误率来自动评价分类器。你也可以用它来选择算法或者调整超参数。然而，你应该避免用你的眼睛查看它们。我们用“黑箱”这个术语是因为我们只是要用这个子集的数据来得到分类器的“黑箱”评价。</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b41b739248064455acda75c43c6229ca><p class=pgc-img-caption></p></div><p class=ql-align-justify>为什么我们要明确地将验证集分成眼球和黑箱验证集呢？由于你将获得关于眼球验证集中样本的直觉，你将开始更快地过拟合眼球验证集。如果你发现眼球验证集的性能比黑箱验证集的性能要提升的更加迅速，那么你已经过拟合眼球验证集了。这种情况下，你可能需要丢弃它然后找到一个新的眼球验证集。这将通过把黑箱验证集的样本转移到眼球验证集中或者获得新的被标记的数据来得到。</p><p class=ql-align-justify>明确地将你的验证集分成眼球和黑箱验证集会让你发现，你手动分析错误的过程是什么时候导致你数据中眼球的部分过拟合的。</p><h1><strong>18、眼球和黑箱验证集应该要多大？</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：吴晨瑶</p><p class=ql-align-justify>你的眼球验证集需要足够大才能给你一个对算法主要错误类别的感受。如果你在进行的是一个人类做的更好的工作(比如在图片中识别猫)，这里是一些粗略准则：</p><ul><li class=ql-align-justify>当你的分类器产生了10个错误时，眼球验证集会被认为非常小。只有10个错误会让正确评估不同错误分类的影响变得十分困难。但是如果你只有非常少的样本而且不足以支持你将更多样本放入眼球验证集中的这种情况，这样总比没有好并且这会在项目优化中有所帮助。</li><li class=ql-align-justify>如果你的分类器在眼球验证样本中得到了20个左右的错误，你可以得到一个对主要误差来源的粗略感受。</li><li class=ql-align-justify>有大约50个样本的话，你会得到一个对主要误差来源的不错的感受。</li><li class=ql-align-justify>有大约100个样本的话，你会得到一个非常不错的对主要误差来源的感受。我曾见过有人甚至手动分析更多的错误——有时会有500个这么多。只要你有足够的数据，这样并没有什么坏处。</li></ul><p class=ql-align-justify>如果你的分类器有5%的错误率。为确保你在眼球验证集中有100个左右的误标记样本，眼球验证集得有大约2000个样本(因为0.05*2000 = 100)。你的分类器错误率越小，你的眼球验证集就需要越大，以得到足够大的错误集来分析。</p><p class=ql-align-justify>如果你在进行一个人类甚至都做不好的任务时，检测眼球验证集的训练就不会有什么帮助。因为我们很难理解为什么这个算法不能正确的将某个样本进行分类。这种情况下，你可以省略眼球验证集。我们将在之后的章节中来讨论这种问题的指导原则。</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b41b739248064455acda75c43c6229ca><p class=pgc-img-caption></p></div><p class=ql-align-justify>那黑箱验证集又如何呢？我们之前说1000-10000个左右的验证集很常见。换个更好的说法，尽管拥有更多的数据没有什么害处，一个拥有1000-10000个样本的黑箱验证集经常会提供足够的数据来调整超参数和选择模型。一个拥有100个样本的黑箱验证集会很小但是依然有用。</p><p class=ql-align-justify>如果你有一个小的验证集，那么你可能没有足够的数据来将验证集分成两个大到足够服务于各自目的的眼球验证集和黑箱验证集。相反，你的整个验证集可能会被用作眼球验证集—— 即，你要手动检测所有的验证集数据。</p><p class=ql-align-justify>在眼球验证集和黑箱验证集中，我认为眼球验证集更加重要(假定你正在解决的问题人类可以很好地处理而且检测样本会帮助你获得直觉)。如果你只有一个眼球验证集，你可以把误差分析，模型选择和超参数的调整都用这个集合来进行。只有一个眼球验证集的缺点是过拟合验证集的风险会更大。</p><p class=ql-align-justify>如果你可以获得足够的数据，眼球验证集的尺寸将主要取决于你有时间手动分析多少个样本。比如说，我几乎没有见过任何人手动分析了1000个以上的错误。</p><h1 class=ql-align-center><strong>19、重要结论：基本错误分析</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：吴晨瑶</p><ul><li class=ql-align-justify>如果你开始了一个新的项目，尤其是如果你在这个领域中还不是专家，很难正确猜测最有前途的方向。</li><li class=ql-align-justify>所以不要从设计和打造一个完美的系统开始。而是尽可能快地建造和训练一个基本的系统—— 可能就在几天之内。然后用错误分析来帮助你找到最有潜力的方向而且从这里开始迭代改进你的算法。</li><li class=ql-align-justify>通过人工检查约100个验证集样本进行误差分析，该算法对主要类别错误进行分析和计数。使用这些信息来划分致力于不同类型错误修复的优先顺序。</li><li class=ql-align-justify>考虑将验证集分成一个你将手动检测的眼球验证集和一个你将不会手动检测的黑箱验证集。如果眼球验证集展现出的性能优于黑箱验证集，那么你已经过拟合眼球验证集了，你应该考虑为它增添更多的数据。</li><li class=ql-align-justify>眼球验证集需要足够大以保证你的算法可以有足够多错误分类的样本来给你分析。一个拥有1000-10000个样本的黑箱验证集对很多应用来说都会是充足的。</li><li class=ql-align-justify>如果你的验证集按这种方式分割不够大的话，就用一个眼球验证集来手动进行错误分析、模型选择以及超参数调整。</li></ul><h1 class=ql-align-center><strong>20、偏差和方差：两大错误来源</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：吴晨瑶</p><p class=ql-align-justify>假设你的训练、验证和测试集全部来自同一分布。那么你应该总是要尝试得到更多的训练数据，因为只有这样才可以提高性能，对吗？</p><p class=ql-align-justify>虽然拥有更多的数据没什么坏处，但不幸的是它不会总是像你期望的那么有用。得到更多数据的工作可能是在浪费时间。所以，你如何决定什么时候去增加数据，什么时候不用这么麻烦呢？</p><p class=ql-align-justify>机器学习有两大主要错误来源：偏差和方差。理解它们会帮助你判断增加数据或采用其他策略来提升性能是否在很好地利用时间。</p><p class=ql-align-justify>假设你希望建一个有5%错误率的猫分类器。此时，你的训练集有15%的错误率，你的验证集有16%的错误率。这种情况，增加训练数据可能不会有太大帮助。你需要把注意力放在其他改变上。实际上，往你的训练集中增加更多样本只会让你的算法更难在训练集上有很好的效果。(在之后的章节中我们会解释原因)</p><p class=ql-align-justify>如果你的训练集错误率为15%(或者说85%的正确率)，但是你的目标是5%的错误率(95%的正确率)，那么首先要解决的问题是提升你的算法在训练集上的性能。你的验证/测试集的性能通常比训练集的性能要差。所以如果你的算法对见过的样本准确率为85%，就绝不可能对没见过的样本得到95%的准确率。</p><p class=ql-align-justify>假设和上面一样你的算法在验证集上有16%的错误率(84%准确率)。我们把16%的错误分成两个部分：</p><p class=ql-align-justify>算法在训练集上的错误率。在这个例子中是15%。我们非正式地将之看作算法的<strong>偏差</strong>。</p><ul><li class=ql-align-justify>这个算法在验证集 (或测试集)上的表现比在训练集上的要差多少。在这个例子中，验证集上的表现比训练集要差1%。我们非正式地将之看作算法的方差<sup>1</sup>。</li><li class=ql-align-justify>对学习算法的一些改变可以解决误差的第一个组成部分– 偏差 – 并提高其在训练集上的性能。一些算法的改变可以解决第二个组成部分– 方差 – 并帮助其更好地从训练集泛化到验证/测试集<sup>2</sup>。为选择更有潜力的改变，理解这两个错误成分中哪一个更紧迫更需要被解决是非常有用的。</li></ul><p class=ql-align-justify>培养关于偏差和方差的良好直觉可以帮助你选择对你的算法更有效的变化。</p><p class=ql-align-justify>1、统计学领域对偏差和方差有更正式的定义，这是我们无需担心的。大致上，偏差是当你有一个很大的训练集时你的算法的错误率。方差是在这个背景下，测试集相比训练集的表现要差多少。当你的误差度量是均方误差时，你可以写出指定这两个量的公式，并证明总误差＝偏差+方差。但是对我们来说目的是决定如何对一个机器学习问题作出改进，在这里给出的对偏差和方差不太正式的定义已经足够了。</p><p class=ql-align-justify>2、也有一些方法通过对系统结构作出巨大改变，可以同时减少偏差和方差。但是这些往往难以识别和实施。</p><h1 class=ql-align-center><strong>21、偏差和方差示例</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：玉岩</p><p class=ql-align-justify>考虑我们为猫分类的任务，一个“理想的”分类器（就像人类）有可能在这项任务中表现得非常出色。</p><p class=ql-align-justify>假设你的运算程序按照下面的设定运行：</p><ul><li class=ql-align-justify>训练误差=1%</li><li class=ql-align-justify>开发集误差=11%</li></ul><p class=ql-align-justify>它存在什么问题呢？采用前面章节的定义，我们估计偏差率为1%，方差为10%（=11%-1%）。因此，它具有<strong>高方差</strong>。虽然这个分类器具有很低的训练误差，但是它不能推广到设备端。这也叫做<strong>过拟合</strong>。</p><p class=ql-align-justify>现在，考虑下面这种情况：</p><ul><li class=ql-align-justify>训练误差=15%</li><li class=ql-align-justify>设备误差=16%</li></ul><p class=ql-align-justify>我们估计偏差率在15%，方差为1%。这个分类器拟合训练端的效果不好，会产生15%的误差，但是它在设备端的误差仅仅比训练误差高了一点点。这个分类器因此具有<strong>高偏差</strong>，但是低方差。我们称这种运算程序为<strong>欠拟合</strong>。</p><p class=ql-align-justify>现在，考虑这种：</p><ul><li class=ql-align-justify>训练误差=15%</li><li class=ql-align-justify>设备误差=30%</li></ul><p class=ql-align-justify>我们估计偏差率在15%，方差为15%。这个分类器具有<strong>高偏差和高方差</strong>：它在训练端表现不佳，因此具有高的偏差率，而它在设备端的表现甚至更差，因此它也具有高的方差。由于这种分类器同时具备过拟合和欠拟合的特点，所以过拟合/欠拟合术语很难用在它身上。</p><p class=ql-align-justify>最后，看看这个：</p><ul><li class=ql-align-justify>训练误差=0.5%</li><li class=ql-align-justify>设备误差=1%</li></ul><p class=ql-align-justify>这个分类器表现不错，因为它具有低偏差和低方差。达到了这么出色的表现真是可喜可贺！</p><h1 class=ql-align-center><strong>22、与最佳误差率对比</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：玉岩</p><p class=ql-align-justify>在我们对猫进行识别的例子中，“理想的”误差率——就是说，一个可以通过“最佳”分类器实现的误差率——几乎为0。一个看着图片的人几乎任何时候都能够识别出图片里是否有一只猫；因此，我们有理由希望机器也能做得这样出色。</p><p class=ql-align-justify>其他的问题更加困难。比方说，假设你正在建立一个语言识别系统，发现14%的声音文件有许多背景噪声或者太难以理解以至于甚至一个人都无法识别讲了些什么。这种情况下，甚至“最佳”语言识别系统都可能有14%的误差。</p><p class=ql-align-justify>假设在这个语言识别问题上，你的运算程序达到了：</p><ul><li class=ql-align-justify>训练误差=15%</li><li class=ql-align-justify>开发集误差=30%</li></ul><p class=ql-align-justify>训练端的表现已经和最佳误差率14%非常接近了。因此，偏差率或者训练端的表现方面并没有很大的提升空间。但是，这个算法不能推广到设备端；因此对因为方差而产生的误差的进步空间还很大。</p><p class=ql-align-justify>这个例子与前面章节提到的第三个例子很相似，在那个例子中训练误差也是15%而且设备误差也是30%。如果最佳误差率是~0%，那么一个15%的训练误差会给提升留出很大的空间。这也暗示我们使偏差率减小的变化可能会富有成效。但是如果最佳误差率是14%，那么相同的训练端表现告诉我们，分类器偏差率的提升空间很小。</p><p class=ql-align-justify>对于最佳误差率和0相差很多的问题，这里有一个对算法误差更加细化的分解。继续我们上面讲到的识别案例，总设备端误差30%可以被分解为下面这些（相似的分析也可以用于测试设备误差）：</p><ul><li class=ql-align-justify>最佳误差率（“无法避免的偏差”）：14%。假设我们认定，即使以或许世界上最好的语言识别系统，我们仍然会得到14%的误差。我们可以认为这是“不可避免的”一部分学习算法偏差。</li><li class=ql-align-justify>可避免偏差：1%。这被算作训练误差和最佳误差率之间的差别。</li><li class=ql-align-justify>方差：15%。设备误差和训练误差的差别。</li></ul><p class=ql-align-justify>把它和我们之前的定义联系起来，偏差率和可避免偏差有下面的关系：</p><p class=ql-align-justify>偏差率=最佳误差率（“不可避免偏差”）+可避免偏差</p><p class=ql-align-justify>“可避免偏差”反映了你的算法在训练端的表现比“最佳分类器”差了多少。</p><p class=ql-align-justify>方差的概念和之前的保持一致。理论上，我们总可以将方差减少到0通过大量的训练端的训练。因此，有足够多的数据，所有的方差都是“可避免的”，所以像“不可避免方差”这种东西是不存在的。</p><p class=ql-align-justify>再看一个例子，最佳误差率是14%，此外我们有：</p><ul><li class=ql-align-justify>训练误差=15%</li><li class=ql-align-justify>设备误差=16%</li></ul><p class=ql-align-justify>然而在前面的章节中，我们称它为高偏差率分类器，现在我们会说来自可避免偏差的误差为1%，来自方差的误差为1%。所以，这个算法已经做得不错了，可提升空间不大了。仅仅比最佳误差率多了2%。</p><p class=ql-align-justify>我们从这些例子中看到，知道最佳误差率对于引导我们下面的步骤很有帮助。在统计学中，最佳误差率也叫做<strong>贝叶斯误差率</strong>，或者贝叶斯率。</p><p class=ql-align-justify>我们怎么知道最佳误差率是多少呢？对于人类能够做得很好的任务，比如识别图片或者采集声音片段，你可以要求一个人提供分类结果，然后相比训练端检测人类分类的准确性。这能够提供一个最佳误差率的估计值。如果你正在研究一个即使人类都难以解决的任务（例如，预测哪部电影将被推荐，或者哪条广告将被展示给用户），最佳误差率很难被估计出来。</p><p class=ql-align-justify>在“与人类水平的表现对比”的部分（33章到35章），我将会更加细致地讨论对比一个学习算法的表现和人类水平的表现的过程。</p><p class=ql-align-justify>在前面几章，你学到了如何通过观测训练端和设备端的错误率估计可避免/不可避免偏差，以及方差。下一章将会讨论你能够如何在这种分析中使用你的洞察力来决定减少偏差和减少方差技术的优先次序。根据你的项目当前的问题是高（可避免的）偏差还是高的方差，你应当采用的技术是有很大区别的。继续读下去吧！</p><h1 class=ql-align-center><strong>23、定位偏差和方差</strong></h1><hr class=ql-align-justify><p class=ql-align-right>分享人：玉岩</p><p class=ql-align-justify>在这里，针对定位偏差方差的任务有一个最简单的公式：</p><ul><li class=ql-align-justify>如果你有高可避免偏差，增加你的模型大小（例如，通过添加层数或神经元来增加你的神经网络的大小）。</li><li class=ql-align-justify>如果你的方差高，添加数据到你的训练端。</li></ul><p class=ql-align-justify>如果你能够增加神经网络大小并无限制增加训练数据，算法很可能在很多学习问题上做得出色。</p><p class=ql-align-justify>在练习中，增加模型大小将最终导致你遇到计算问题，因为训练大的模型速度慢。你可能要竭尽所能去获得更多的训练数据。（即使在网上，猫的图片数量也是有限的）</p><p class=ql-align-justify>不同的模型结构——例如，不同的神经网络结构——对于你的问题会有不同数量的偏差率/方差。许多最近的深度学习研究发展了许多革新的模型结构。因此，如果你正在使用神经网络，学术文献会是你灵感的重要来源。Github上面还有许多很棒的开源的实现。但是尝试新结构的结果相比于简单形式的增加模型大小和添加数据会更难预测。</p><p class=ql-align-justify>增加模型大小通常会减少偏差率，但是它还会增加方差以及过拟合的风险。但是，这个过拟合的问题通常只会在你没有使用规范化的情况下出现。如果你的设计包含了良好的规范化方法，那么你能够安全的增加模型的尺寸而不会提高过拟合的风险。</p><p class=ql-align-justify>假设你正在应用深度学习，使用L2规范化或者中途退出，使用在设备端表现最好的规范化系数。如果你增加了模型大小，通常你的表现会不变或者提升；不会明显的变糟糕。唯一可能阻止你使用更大的模型的原因就是增加计算花销了。</p><h1>24、偏差率与方差的权衡</h1><hr><p class=ql-align-right>分享人：玉岩</p><p>你可能听说过“偏差率与方差的权衡”。在你能够在学习算法里进行的调整中，有一些能够减少偏差率误差但是需要以增加方差作为代价，反过来也是。这就在偏差率和方差之间创造了一个“权衡”。</p><p>比如，增加模型的大小——增加神经元/层数在一个神经网络中，或者添加输入特征——通常减少偏差率但是会增加方差。另一方面，增加规范化会增加偏差率但能减少方差。</p><p>在现代，我们经常能够得到大量的数据，并且能够使用非常大的神经网络（深度学习）。因此，权衡就比较少了，现在有更多的选择能够减少偏差率而不会损失方差，反过来也是。</p><p>例如，你通常可以增加神经网络的大小并调整规范化方法来减少偏差率而不会明显地增加方差。通过添加训练数据，你通常还能减少方差而不影响偏差率。</p><p>如果你为你的任务选择了一个非常合适的模型结构，你有可能会同时减少片利率和方差。选择这样一个模型是非常难的。</p><p>在接下来几章，我们讨论定位偏差率和方差的其它详细的技术。</p><h1>25、减少可避免偏差的技术</h1><hr><p class=ql-align-right>分享人：玉岩</p><p>如果你的学习算法被很高的可避免偏差所困扰，你可能要尝试下面这些技术：</p><ul><li><strong>增加模型大小</strong>（例如神经元/层数量）：这项技术减少偏差率，因为它允许你更好的适应训练端。如果你发现这会增加方差，那么使用规范化方法吧，这通常会消除方差的增长。</li><li><strong>基于对错误分析的洞察调整输入特征</strong>：你的错误分析启发你创造另外的特点，这些特点有助于算法消除特定种类错误。（我们会在之后的章节中讨论这个。）这些新特点能够同时帮助到偏差率和方差。理论上，添加更多的特征可能会增加方差；但是如果你发现这造成了问题，那就使用规范化方法，它通常会消除掉方差的增长。</li><li><strong>减少或消除规范化方法</strong>（L2规范化，L1规范化，中途退出）：这将减少可避免偏差率，但是会增加方差。</li><li><strong>调整模型结构</strong>（例如神经网络结构）目的是使其对于你的问题会更加合适：这项技术会同时影响偏差率和方差。</li></ul><p>一个不怎么有帮助的方法：</p><ul><li><strong>添加更多的训练数据</strong>：这项技术帮助解决方差问题，但它通常对偏差率没有显著影响。</li></ul><h1>26、在训练集上的误差分析</h1><hr><p class=ql-align-right>分享人：陈波昊</p><p>在验证或测试集上出色地进行实际应用前，我们必须保证我们的算法在训练集上有优异的表现。</p><p>除了前面描述的解决高偏置的技术之外，我有时也会在训练数据上进行误差分析。误差分析过程遵循的规范同在眼球验证集上进行的类似。当你的算法存在较高的偏差，或者说，算法并不适应训练集时，这是非常有用的。</p><p>例如，假设你正在为某些应用建立一个演讲识别系统，为此已经从志愿者处收集了大量的音频片段作为训练集。如果你的系统在训练集上工作得并不好，你或许会考虑听一些你的系统工作较差的音频片段，来理解导致训练误差的音频中存在的问题，并进行分类。就像验证集的误差分析一样，你可以以不同的类别统计这些错误。</p><div class=pgc-img><img alt="吴恩达《ML Yearning》｜基础的误差分析& 偏差、方差分析" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00c6fd979a8446e29e8eb31904bcc004><p class=pgc-img-caption></p></div><p>从这个例子中，你可能会发现算法尤其不擅长处理含有很多背景噪声的数据实例。因此，我们应该更关注一些对含有背景噪声的训练实例有更好适应性的处理方法。</p><p>你也可以进行二次确认。将音频片段转录，并将转录后相同内容的音频输入算法。如果经过这个过程后，背景噪声强烈到无论哪个人类都不能明白音频的内容，那么可能识别这些音频的任务对算法而言太过苛求了。我们将在稍后部分讨论将算法和人类表现进行比较的好处所在。</p><h1>27、关于减少方差的技术</h1><hr><p>分享人：陈波昊</p><p>如果你的学习算法有较高的方差，或许你可以尝试以下的方法：</p><ul><li><strong>添加更多的训练数据</strong>：只要有足够的算力和数据作为支撑，这个是最简单也最可靠的解决方法。</li><li><strong>正则化</strong>（L2正则化，L1正则化，丢失）：这种技术能够减少方差，但会增加偏差。</li><li><strong>添加早期停止</strong>（即：基于验证集上的误差，较早地停止梯度下降）：这种技术同样会减少方差并增加偏差。早期停止方法的表现非常像正则化方法，有些作者称其为正则化技术。</li><li><strong>选择特征来减少输入特征的数目或种类</strong>：这种技术可能有助于解决方差问题，但同样会增加偏差。在稍稍减少特征的输入时（比如从1000个特征减少到900个），这种技术对于减小方差的表现并不明显。在明显减少的情况下（比如从1000个减少到100个，十倍的差异），只要你没有排除太多有用的特征，就更有可能会产生显著的影响。在现代深度学习过程中，由于数据足够，这种技术逐渐不被采用。我们现在更倾向于给算法全部的特征，并让算法自己选择出哪些特征是有用的。但当我们的训练数据集太小，不能支持大量的训练时，选择特征这个方法就会非常有用。</li><li><strong>减小模型大小</strong>（如减小神经元个数或者网络层数）：谨慎使用这个方法。这个技术可以减少方差，同时可能会增加偏差。但是，我不建议使用这个方法减小方差。添加正则化可以给出更好的分类性能。减小模型大小的优点在于减小计算成本，因此可以提高模型的训练速度。如果提高训练速度非常有效，那么一定要考虑减小模型大小。但如果你的目标是减少方差，并且你也并不关心计算成本，则可以考虑引入正则化方法来替代该方法。</li></ul><p>以下附加两条策略，是在前面的章节中讨论偏差时提到的：</p><ul><li><strong>根据误差分析后的结论修改输入特征</strong>：误差分析可以促使你构造一些附加特征，从而帮助算法解决特殊类别的误差。这些新加入的特征可以同时解决偏差和方差的问题。在理论上，添加特征可能会增加方差；但当遇到这种情况下，使用正则化方法通常会消除方差的增加过程。</li><li><strong>修改模型的结构</strong>（如神经元网络的结构）：这种方法更适合你的问题：它可以同时改善偏差和方差。</li></ul><blockquote><p><strong>【关注微信公众号：《人工智能前沿讲习班》，回复“MLY”，获取完整版PDF电子书】</strong></p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'吴恩达','ML','Yearning'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E5%AD%A6/059e7a6.html alt="吴恩达 ML Yearning 关于学习曲线的分析&与人类级别的表现对比" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f6a60d9d13f84286a71f27b8edb150f1 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E5%AD%A6/059e7a6.html title="吴恩达 ML Yearning 关于学习曲线的分析&与人类级别的表现对比">吴恩达 ML Yearning 关于学习曲线的分析&与人类级别的表现对比</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>