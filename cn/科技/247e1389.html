<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用 Node.js 写一个代码生成器 | 极客快訊</title><meta property="og:title" content="使用 Node.js 写一个代码生成器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/2cba7942e6784844bac56d6b44752c5c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/247e1389.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><meta property="article:published_time" content="2020-11-14T20:55:22+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:22+08:00"><meta name=Keywords content><meta name=description content="使用 Node.js 写一个代码生成器"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/247e1389.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用 Node.js 写一个代码生成器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>使用 Node.js 写一个代码生成器</p><p>背景</p><p>第一次接触代码生成器用的是动软代码生成器，数据库设计好之后，一键生成后端 curd代码。之后也用过 CodeSmith , T4。目前市面上也有很多优秀的代码生成器，而且大部分都提供可视化界面操作。</p><p>自己写一个的原因是因为要集成到自己写的一个小工具中，而且使用 Node.js 这种动态脚本语言进行编写更加灵活。</p><p>原理</p><p>代码生成器的原理就是：数据 + 模板 => 文件。</p><p>数据一般为数据库的表字段结构。</p><p>模板的语法与使用的模板引擎有关。</p><p>使用模板引擎将数据和模板进行编译，编译后的内容输出到文件中就得到了一份代码文件。</p><p>功能</p><p>因为这个代码生成器是要集成到一个小工具 lazy-mock 内，这个工具的主要功能是启动一个 mock server 服务，包含curd功能，并且支持数据的持久化，文件变化的时候自动重启服务以最新的代码提供 api mock 服务。</p><p>代码生成器的功能就是根据配置的数据和模板，编译后将内容输出到指定的目录文件中。因为添加了新的文件，mock server 服务会自动重启。</p><p>还要支持模板的定制与开发，以及使用 CLI 安装模板。</p><p>可以开发前端项目的模板，直接将编译后的内容输出到前端项目的相关目录下，webpack 的热更新功能也会起作用。</p><p>模板引擎</p><p>模板引擎使用的是 nunjucks。</p><p>lazy-mock 使用的构建工具是 gulp，使用 gulp-nodemon 实现 mock-server 服务的自动重启。所以这里使用 gulp-nunjucks-render 配合 gulp 的构建流程。</p><p>代码生成</p><p>编写一个 gulp task ：</p><p><strong>const</strong> rename = require('gulp-rename') <strong>const</strong> nunjucksRender = require('gulp-nunjucks-render') <strong>const</strong> codeGenerate = require('./templates/generate') <strong>const</strong> ServerFullPath = require('./package.json').ServerFullPath; //mock -server项目的绝对路径 <strong>const</strong> FrontendFullPath = require('./package.json').FrontendFullPath; //前端项目的绝对路径 <strong>const</strong> nunjucksRenderConfig = { path: 'templates/server', envOptions: { tags: { blockStart: '&lt;%', blockEnd: '%>', variableStart: '&lt;$', variableEnd: '$>', commentStart: '&lt;#', commentEnd: '#>' }, }, ext: '.js', //以上是 nunjucks 的配置 ServerFullPath, FrontendFullPath } gulp.task('code', <strong>function</strong> () { require('events').EventEmitter.defaultMaxListeners = 0 <strong>return</strong> codeGenerate(gulp, nunjucksRender, rename, nunjucksRenderConfig) });</p><blockquote>代码具体结构细节可以打开 lazy-mock 进行参照</blockquote><p>为了支持模板的开发，以及更灵活的配置，我将代码生成的逻辑全都放在模板目录中。</p><p>templates 是存放模板以及数据配置的目录。结构如下：</p><div class=pgc-img><img alt="使用 Node.js 写一个代码生成器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cba7942e6784844bac56d6b44752c5c></div><p>只生成 lazy-mock 代码的模板中 ：</p><p>generate.js的内容如下：</p><p><strong>const</strong> path = require('path') <strong>const</strong> CodeGenerateConfig = require('./config').default; <strong>const</strong> Model = CodeGenerateConfig.model; module.exports = <strong>function</strong> <strong>generate</strong>(gulp, nunjucksRender, rename, nunjucksRenderConfig) { nunjucksRenderConfig.data = { model: CodeGenerateConfig.model, config: CodeGenerateConfig.config } <strong>const</strong> ServerProjectRootPath = nunjucksRenderConfig.ServerFullPath; //server <strong>const</strong> serverTemplatePath = 'templates/server/' gulp.src(`${serverTemplatePath}controller.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ControllerRelativePath)); gulp.src(`${serverTemplatePath}service.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Service.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ServiceRelativePath)); gulp.src(`${serverTemplatePath}model.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Model.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ModelRelativePath)); gulp.src(`${serverTemplatePath}db.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '_db.json')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.DBRelativePath)); <strong>return</strong> gulp.src(`${serverTemplatePath}route.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Route.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.RouteRelativePath)); }</p><p>类似：</p><p>gulp.src(`${serverTemplatePath}controller.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ControllerRelativePath));</p><p>表示使用 controller.njk 作为模板，nunjucksRenderConfig作为数据（模板内可以获取到 nunjucksRenderConfig 属性 data 上的数据）。编译后进行文件重命名，并保存到指定目录下。</p><p>model.js 的内容如下：</p><p><strong>var</strong> shortid = require('shortid') <strong>var</strong> Mock = require('mockjs') <strong>var</strong> Random = Mock.Random //必须包含字段id <strong>export</strong> <strong>default</strong> { name: "book", Name: "Book", properties: [ { key: "id", title: "id" }, { key: "name", title: "书名" }, { key: "author", title: "作者" }, { key: "press", title: "出版社" } ], buildMockData: <strong>function</strong> () {//不需要生成设为false <strong>let</strong> data = [] <strong>for</strong> (<strong>let</strong> i = 0; i &lt; 100; i++) { data.push({ id: shortid.generate(), name: Random.cword(5, 7), author: Random.cname(), press: Random.cword(5, 7) }) } <strong>return</strong> data } }</p><p>模板中使用最多的就是这个数据，也是生成新代码需要配置的地方，比如这里配置的是 book ，生成的就是关于 book 的curd 的 mock 服务。要生成别的，修改后执行生成命令即可。</p><p>buildMockData 函数的作用是生成 mock 服务需要的随机数据，在 db.njk 模板中会使用：</p><p>{ "&lt;$ model.name $>":&lt;% <strong>if</strong> model.buildMockData %>&lt;$ model.buildMockData()|dump|safe $>&lt;% <strong>else</strong> %>[]&lt;% endif %> }</p><blockquote>这也是 nunjucks 如何在模板中执行函数</blockquote><p>config.js 的内容如下：</p><p><strong>export</strong> <strong>default</strong> { //server RouteRelativePath: '/src/routes/', ControllerRelativePath: '/src/controllers/', ServiceRelativePath: '/src/services/', ModelRelativePath: '/src/models/', DBRelativePath: '/src/db/' }</p><p>配置相应的模板编译后保存的位置。</p><p>config/index.js 的内容如下：</p><p><strong>import</strong> model <strong>from</strong> './model'; <strong>import</strong> config <strong>from</strong> './config'; <strong>export</strong> <strong>default</strong> { model, config }</p><p>针对 lazy-mock 的代码生成的功能就已经完成了，要实现模板的定制直接修改模板文件即可，比如要修改 mock server 服务 api 的接口定义，直接修改 route.njk 文件：</p><p><strong>import</strong> KoaRouter <strong>from</strong> 'koa-router' <strong>import</strong> controllers <strong>from</strong> '../controllers/index.js' <strong>import</strong> PermissionCheck <strong>from</strong> '../middleware/PermissionCheck' <strong>const</strong> router = <strong>new</strong> KoaRouter() router .get('/&lt;$ model.name $>/paged', controllers.&lt;$model.name $>.get&lt;$ model.Name $>PagedList) .get('/&lt;$ model.name $>/:id', controllers.&lt;$ model.name $>.get&lt;$ model.Name $>) .del('/&lt;$ model.name $>/del', controllers.&lt;$ model.name $>.del&lt;$ model.Name $>) .del('/&lt;$ model.name $>/batchdel', controllers.&lt;$ model.name $>.del&lt;$ model.Name $>s) .post('/&lt;$ model.name $>/save', controllers.&lt;$ model.name $>.save&lt;$ model.Name $>) module.exports = router</p><p>模板开发与安装</p><p>不同的项目，代码结构是不一样的，每次直接修改模板文件会很麻烦。</p><p>需要提供这样的功能：针对不同的项目开发一套独立的模板，支持模板的安装。</p><p>代码生成的相关逻辑都在模板目录的文件中，模板开发没有什么规则限制，只要保证目录名为 templates，generate.js中导出generate函数即可。</p><p>模板的安装原理就是将模板目录中的文件全部覆盖掉即可。不过具体的安装分为本地安装与在线安装。</p><p>之前已经说了，这个代码生成器是集成在 lazy-mock 中的，我的做法是在初始化一个新 lazy-mock 项目的时候，指定使用相应的模板进行初始化，也就是安装相应的模板。</p><p>使用 Node.js 写了一个 CLI 工具 lazy-mock-cli，已发到 npm ，其功能包含下载指定的远程模板来初始化新的 lazy-mock 项目。代码参考（ copy ）了 vue-cli2。代码不难，说下某些关键点。</p><p>安装 CLI 工具：</p><p>npm install lazy-mock -g</p><p>使用模板初始化项目：</p><p>lazy-mock init d2-admin-pm my-project</p><blockquote>d2-admin-pm 是我为一个前端项目已经写好的一个模板。</blockquote><p>init 命令调用的是 lazy-mock-init.js 中的逻辑：</p><p><strong>#!/usr/bin/env node</strong> <strong>const</strong> download = require('download-git-repo') <strong>const</strong> program = require('commander') <strong>const</strong> ora = require('ora') <strong>const</strong> exists = require('fs').existsSync <strong>const</strong> rm = require('rimraf').sync <strong>const</strong> path = require('path') <strong>const</strong> chalk = require('chalk') <strong>const</strong> inquirer = require('inquirer') <strong>const</strong> home = require('user-home') <strong>const</strong> fse = require('fs-extra') <strong>const</strong> tildify = require('tildify') <strong>const</strong> cliSpinners = require('cli-spinners'); <strong>const</strong> logger = require('../lib/logger') <strong>const</strong> localPath = require('../lib/local-path') <strong>const</strong> isLocalPath = localPath.isLocalPath <strong>const</strong> getTemplatePath = localPath.getTemplatePath program.usage('&lt;template-name> [project-name]') .option('-c, --clone', 'use git clone') .option('--offline', 'use cached template') program.on('--help', () => { console.log(' Examples:') console.log() console.log(chalk.gray(' # create a new project with an official template')) console.log(' $ lazy-mock init d2-admin-pm my-project') console.log() console.log(chalk.gray(' # create a new project straight from a github template')) console.log(' $ vue init username/repo my-project') console.log() }) <strong>function</strong> <strong>help</strong>() { program.parse(process.argv) <strong>if</strong> (program.args.length &lt; 1) <strong>return</strong> program.help() } help() //模板 <strong>let</strong> template = program.args[0] //判断是否使用官方模板 <strong>const</strong> hasSlash = template.indexOf('/') > -1 //项目名称 <strong>const</strong> rawName = program.args[1] //在当前文件下创建 <strong>const</strong> inPlace = !rawName || rawName === '.' //项目名称 <strong>const</strong> name = inPlace ? path.relative('../', process.cwd()) : rawName //创建项目完整目标位置 <strong>const</strong> to = path.resolve(rawName || '.') <strong>const</strong> clone = program.clone || false //缓存位置 <strong>const</strong> serverTmp = path.join(home, '.lazy-mock', 'sever') <strong>const</strong> tmp = path.join(home, '.lazy-mock', 'templates', template.replace(/[\/:]/g, '-')) <strong>if</strong> (program.offline) { console.log(`> Use cached template at ${chalk.yellow(tildify(tmp))}`) template = tmp } //判断是否当前目录下初始化或者覆盖已有目录 <strong>if</strong> (inPlace || exists(to)) { inquirer.prompt([{ type: 'confirm', message: inPlace ? 'Generate project in current directory?' : 'Target directory exists. Continue?', name: 'ok' }]).then(answers => { <strong>if</strong> (answers.ok) { run() } }).catch(logger.fatal) } <strong>else</strong> { run() } <strong>function</strong> <strong>run</strong>() { //使用本地缓存 <strong>if</strong> (isLocalPath(template)) { <strong>const</strong> templatePath = getTemplatePath(template) <strong>if</strong> (exists(templatePath)) { generate(name, templatePath, to, err => { <strong>if</strong> (err) logger.fatal(err) console.log() logger.success('Generated "%s"', name) }) } <strong>else</strong> { logger.fatal('Local template "%s" not found.', template) } } <strong>else</strong> { <strong>if</strong> (!hasSlash) { //使用官方模板 <strong>const</strong> officialTemplate = 'lazy-mock-templates/' + template downloadAndGenerate(officialTemplate) } <strong>else</strong> { downloadAndGenerate(template) } } } <strong>function</strong> <strong>downloadAndGenerate</strong>(template) { downloadServer(() => { downloadTemplate(template) }) } <strong>function</strong> <strong>downloadServer</strong>(done) { <strong>const</strong> spinner = ora('downloading server') spinner.spinner = cliSpinners.bouncingBall spinner.start() <strong>if</strong> (exists(serverTmp)) rm(serverTmp) download('wjkang/lazy-mock', serverTmp, { clone }, err => { spinner.stop() <strong>if</strong> (err) logger.fatal('Failed to download server ' + template + ': ' + err.message.trim()) done() }) } <strong>function</strong> <strong>downloadTemplate</strong>(template) { <strong>const</strong> spinner = ora('downloading template') spinner.spinner = cliSpinners.bouncingBall spinner.start() <strong>if</strong> (exists(tmp)) rm(tmp) download(template, tmp, { clone }, err => { spinner.stop() <strong>if</strong> (err) logger.fatal('Failed to download template ' + template + ': ' + err.message.trim()) generate(name, tmp, to, err => { <strong>if</strong> (err) logger.fatal(err) console.log() logger.success('Generated "%s"', name) }) }) } <strong>function</strong> <strong>generate</strong>(name, src, dest, done) { <strong>try</strong> { fse.removeSync(path.join(serverTmp, 'templates')) <strong>const</strong> packageObj = fse.readJsonSync(path.join(serverTmp, 'package.json')) packageObj.name = name packageObj.author = "" packageObj.description = "" packageObj.ServerFullPath = path.join(dest) packageObj.FrontendFullPath = path.join(dest, "front-page") fse.writeJsonSync(path.join(serverTmp, 'package.json'), packageObj, { spaces: 2 }) fse.copySync(serverTmp, dest) fse.copySync(path.join(src, 'templates'), path.join(dest, 'templates')) } <strong>catch</strong> (err) { done(err) <strong>return</strong> } done() }</p><p>判断了是使用本地缓存的模板还是拉取最新的模板，拉取线上模板时是从官方仓库拉取还是从别的仓库拉取。</p><p>一些小问题</p><p>目前代码生成的相关数据并不是来源于数据库，而是在 model.js 中简单配置的，原因是我认为一个 mock server 不需要数据库，lazy-mock 确实如此。</p><p>但是如果写一个正儿八经的代码生成器，那肯定是需要根据已经设计好的数据库表来生成代码的。那么就需要连接数据库，读取数据表的字段信息，比如字段名称，字段类型，字段描述等。而不同关系型数据库，读取表字段信息的 sql 是不一样的，所以还要写一堆balabala的判断。可以使用现成的工具 sequelize-auto , 把它读取的 model 数据转成我们需要的格式即可。</p><p>生成前端项目代码的时候，会遇到这种情况：</p><p>某个目录结构是这样的：</p><div class=pgc-img><img alt="使用 Node.js 写一个代码生成器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27eb06ca18b24f87af5366de534841de></div><p>index.js 的内容：</p><p><strong>import</strong> layoutHeaderAside <strong>from</strong> '@/layout/header-aside' <strong>export</strong> <strong>default</strong> { "layoutHeaderAside": layoutHeaderAside, "menu": () => <strong>import</strong>(/* webpackChunkName: "menu" */'@/pages/sys/menu'), "route": () => <strong>import</strong>(/* webpackChunkName: "route" */'@/pages/sys/route'), "role": () => <strong>import</strong>(/* webpackChunkName: "role" */'@/pages/sys/role'), "user": () => <strong>import</strong>(/* webpackChunkName: "user" */'@/pages/sys/user'), "interface": () => <strong>import</strong>(/* webpackChunkName: "interface" */'@/pages/sys/interface') }</p><p>如果添加一个 book 就需要在这里加上"book": () => import(/* webpackChunkName: "book" */'@/pages/sys/book')</p><p>这一行内容也是可以通过配置模板来生成的，比如模板内容为：</p><p>"&lt;$ model.name $>": () => import(/* webpackChunkName: "&lt;$ model.name $>" */'@/pages&lt;$ model.module $>&lt;$ model.name $>')</p><p>但是生成的内容怎么加到index.js中呢？</p><p>第一种方法：复制粘贴</p><p>第二种方法：</p><p>这部分的模板为 routerMapComponent.njk ：</p><p>export default { "&lt;$ model.name $>": () => import(/* webpackChunkName: "&lt;$ model.name $>" */'@/pages&lt;$ model.module $>&lt;$ model.name $>') }</p><p>编译后文件保存到 routerMapComponents 目录下，比如 book.js</p><p>修改 index.js :</p><p><strong>const</strong> files = require.context('./', true, /\.js$/); <strong>import</strong> layoutHeaderAside <strong>from</strong> '@/layout/header-aside' <strong>let</strong> componentMaps = { "layoutHeaderAside": layoutHeaderAside, "menu": () => <strong>import</strong>(/* webpackChunkName: "menu" */'@/pages/sys/menu'), "route": () => <strong>import</strong>(/* webpackChunkName: "route" */'@/pages/sys/route'), "role": () => <strong>import</strong>(/* webpackChunkName: "role" */'@/pages/sys/role'), "user": () => <strong>import</strong>(/* webpackChunkName: "user" */'@/pages/sys/user'), "interface": () => <strong>import</strong>(/* webpackChunkName: "interface" */'@/pages/sys/interface'), } files.keys().forEach((key) => { <strong>if</strong> (key === './index.js') <strong>return</strong> Object.assign(componentMaps, files(key).default) }) <strong>export</strong> <strong>default</strong> componentMaps</p><blockquote>使用了 require.context</blockquote><p>我目前也是使用了这种方法</p><p>第三种方法：</p><p>开发模板的时候，做特殊处理，读取原有 index.js 的内容，按行进行分割，在数组的最后一个元素之前插入新生成的内容，注意逗号的处理，将新数组内容重新写入 index.js 中，注意换行。</p><p>打个广告</p><p>如果你想要快速的创建一个 mock-server，同时还支持数据的持久化，又不需要安装数据库，还支持代码生成器的模板开发，欢迎试试 lazy-mock 。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'生成器','Node','js'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>