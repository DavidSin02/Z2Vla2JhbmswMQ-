<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>(原创)Java的ReentrantLock(可重入锁)详解上篇 | 极客快訊</title><meta property="og:title" content="(原创)Java的ReentrantLock(可重入锁)详解上篇 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f6ffe7fa302246e8842caeeaae9fca86"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/24abe09b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24abe09b.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="(原创)Java的ReentrantLock(可重入锁)详解上篇"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/24abe09b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>(原创)Java的ReentrantLock(可重入锁)详解上篇</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Java并发包下的ReentrantLock(可重入锁)，实现了高并发下的加锁机制，原理是通过AQS(AbstractQueuedSynchronizer，抽象的队列同步器)中循环调用CAS(compareAndSet,原子性操作)操作来实现加锁，它的性能比较好是因为尽最大努力的避免了使线程进入内核态的阻塞状态，Java并发包下的很多锁功能，本质都是使用了AQS(AbstractQueuedSynchronizer，抽象的队列同步器)，该实现的作者是Doug Lea，ThreadPoolExecutor线程池也是这位外国大佬的杰作。</p><p>先看一下ReentrantLock(可重入锁)的类结构，如下图：</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f6ffe7fa302246e8842caeeaae9fca86><p class=pgc-img-caption>ReentrantLock(可重入锁)的类结构</p></div><p>ReentrantLock类包含三个内部类，分别是NonfairSync(非公平锁)，FairSync(公平锁)，Sync(同步器)，其中Sync(同步器)又继承了AbstractQueuedSynchronizer(AQS),本质也是由AQS实现了绝大部分的锁功能。</p><p>实例化创建公平锁和非公平锁，默认创建非公平锁。</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5de75dbf4170439e863581d5afb9d6e4><p class=pgc-img-caption>实例化创建公平锁和非公平锁</p></div><p>公平锁和非公平锁的差别在于：</p><p>公平锁：先请求锁的线程会优先获取到锁，原理是所有需要获得锁的线程都会进入到队列中，队列的特点是先进先出，先进入的请求线程会在头部，后进入的请求线程都会在队列的尾部。</p><p>非公平锁：则不会按照线程请求获得锁的先后顺序，会立马进行一次获取锁的请求操作。</p><p>在源码中体现在，公平锁会判断一下队列中是否已经存在等待获取锁的线程，如果存在，则把自己加入到队列的尾部。</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/117fa8d07c4b469c8d67c9763639e9c8><p class=pgc-img-caption>公平锁获取锁</p></div><p>非公平锁，不会判断队列中是否已经存在等待获取锁的线程，而是直接进行一次获取锁的操作。</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bc22fd34d3dc4c95bd0336636ff571b0><p class=pgc-img-caption>非公平锁获得锁</p></div><p>我们以公平锁的加锁操作，来看一下加锁的过程，进入lock.lock()方法，最终会调用如下这个方法。</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f0cb70d065654ea79a17aa2b6643ff5a><p class=pgc-img-caption>获取锁操作</p></div><p>这个方法中包含三个方法，分别是tryAcquire(),addWaiter(),acquireQueued(),每个方法的用途如下。</p><p>tryAcquire():尝试获取一次锁，如果获取锁失败，则会调用addWaiter()方法。在tryAcquire()方法中，先获取volatile变量修饰的state，该status就是多线程争抢的抽象锁，status等于0，代表锁没有被使用，status等于1或其他，则代表锁已经被一个线程占用。</p><pre><code>hasQueuedPredecessors()判断线程中是否存在等待获取锁的线程。compareAndSetState(0, acquires)将status的值更新为1，代表锁已经被占用。setExclusiveOwnerThread()将当前线程设置为独占此锁的线程。在else if的逻辑中，则是ReentrantLock(可重入锁)的逻辑体现，意是如果还是独占这个锁的线程进行了加锁操作，则status的值在加1，这样的话解锁也需要多次解锁。</code></pre><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aaaf596e8f564aa8ba624e8278d490b9><p class=pgc-img-caption>tryAcquire()方法</p></div><p>addWaiter():将自己包装成Node，然后添加到等待队列的尾部，加入队列成功后，则会调用acquireQueued()方法。</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/710fb16d3f974acc950a6a9f9dcf21be><p class=pgc-img-caption>addWaiter()方法</p></div><p>acquireQueued():在加入到队列中后仍进行尝试获取锁的操作，然后判断是否需要将该线程中断挂起。</p><pre><code>final Node p = node.predecessor()获取当前线程所在Node的的前置Node节点。p == head &amp;&amp; tryAcquire(arg)如果前置节点是head头节点，则进行一次获取锁的操作，头节点是一个空节点，head头节点后的第一个节点，代表同步队列中的第一个等待获取锁的线程，如果成功获取锁则返回，不需要中断此线程。shouldParkAfterFailedAcquire()如果上面获取锁失败后，判断是否需要中断此线程。parkAndCheckInterrupt()进行线程中断的实际操作。</code></pre><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72e32ef384c245d69cf49e7acbd34731><p class=pgc-img-caption>acquireQueued()方法</p></div><p>下面来重点看下一shouldParkAfterFailedAcquire()方法，参数为当前线程所属的Node，以及它的前置节点Node，Node中定义了如下几个waitStatus，</p><p>static final int CANCELLED = 1;//含义是该节点包含的线程已取消</p><p>static final int SIGNAL = -1;//含义是该节点包含的线程等待唤醒</p><p></p><p>static final int CONDITION = -2;//含义是该节点包含的线程等待条件唤醒</p><p>static final int PROPAGATE = -3;//这个是共享模式用到的状态，前三个是独占模式用到的，我们的ReentrantLock是独占锁，会用到上面的三个状态</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af9bb5d4795040aab1e8604c509815d3><p class=pgc-img-caption>shouldParkAfterFailedAcquire()方法</p></div><p>第一个if的含义是：如果前置节点的的waitStatus状态是SIGNAL，那么前置节点的线程在等待唤醒，所以当前节点的线程可以中断挂起，因为公平锁是顺序获得的，当前线程的前面已经有一个线程在等待唤醒了，所以可以把当前线程挂起。</p><p>第二个if的含义是：如果前置节点的的waitStatus状态是CANCELLED，那么需要在队列中移除该节点，因为该线程已经取消。</p><p>第三个else的含义是，把前置节点的waitStatus更新为SIGNAL，为什么会这样，因为我们的acquireQueued()方法是一个自旋的方法for (;;)，第二次循环时，就会判断出把当前线程中断，下面举例说明。</p><p>比如我们有两个线程A，B，第一个线程A已经获取到锁了，B在获取锁的时候肯定获取不到，则会把B包装成Node，然后加入到同步的等待队列中，此时队列中只有一个head头节点和线程B所在的Node节点，head头节点在初始化时，它的waitStatus等于0，在第一次循环时，把头节点的waitStatus更新为SIGNAL，也就是-1，第二次循环时，因为head节点额waitStatus等于-1，所以在第一个if时，直接返回了true，告诉我们可以把当前线程中断掉。</p><p>在parkAndCheckInterrupt()方法中，使用了LockSupport类的方法，将当前线程进行了中断操作，</p><div class=pgc-img><img alt=(原创)Java的ReentrantLock(可重入锁)详解上篇 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63921df4d1c444f5a5d57c5b287d1be4><p class=pgc-img-caption>线程中断的实际方法</p></div><p>非公平锁的加锁逻辑，只是会优先进行一次获取锁的逻辑，忽略掉队列中是否存在等待线程的判断，在获取不到锁时，进入队列以及后续在队列中获取锁的逻辑和公平锁一样。</p><p>以上就是加锁过程的实际调用逻辑，简单总结来说就是A,B,C三个并发线程，共同争夺抽象锁status，A优先获取到锁后，B，C按照调用顺序进入同步的等待队列，中断自己的线程，然后在队列中按照顺序等待获取锁。</p><p>这篇文章是ReentrantLock(可重入锁)详解上篇，主要对加锁的操作逻辑进行了说明，后续文章我将对ReentrantLock(可重入锁)解锁逻辑进行说明，同时对于ReentrantLock(可重入锁)的lock.newCondition()，也就是条件等待队列和ReentrantLock(可重入锁)同步等待队列是如何进行协同工作的进行说明。</p><p>后记：</p><p>看了几天的ReentrantLock(可重入锁)源码，终于对它的逻辑有了一些清晰的思路，如果该文章对你有用处，欢迎收藏转载。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'原创','Java','ReentrantLock'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/581a04b6.html alt=(原创)Java的ReentrantLock(可重入锁)下的Condition class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/dcc50577a6344f7c94cfba48ed89d04d style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/581a04b6.html title=(原创)Java的ReentrantLock(可重入锁)下的Condition>(原创)Java的ReentrantLock(可重入锁)下的Condition</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>