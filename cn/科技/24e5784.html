<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>每日算法LeetCode629：K个逆序对数组（难度系数3/5） | 极客快訊</title><meta property="og:title" content="每日算法LeetCode629：K个逆序对数组（难度系数3/5） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/fb47c286e5244183b4c67e109b306c0a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24e5784.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24e5784.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/24e5784.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24e5784.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24e5784.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/24e5784.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/24e5784.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/24e5784.html><meta property="article:published_time" content="2020-10-29T20:52:58+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:58+08:00"><meta name=Keywords content><meta name=description content="每日算法LeetCode629：K个逆序对数组（难度系数3/5）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/24e5784.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>每日算法LeetCode629：K个逆序对数组（难度系数3/5）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre>导读：算法哥今天继续开启leetcode hard模式，今天给大家准备了一道有趣的数学题，希望今天的分享会让大家对动态规划耳目一新。</pre><hr><h1>题目描述：</h1><p>给出两个整数 n 和 k，找出所有包含从 1 到 n 的数字的排列，且恰好拥有 k 个逆序对的不同的数组的个数。</p><p>逆序对的定义如下：对于数组的第i个和第 j个元素，如果满i &lt; j且 a[i] > a[j]，则其为一个逆序对；否则不是。</p><p>由于答案可能很大，只需要返回 答案 mod 10^9 + 7 的值。</p><p><strong>示例 1:</strong></p><pre>输入: n = 3, k = 0输出: 1解释: 只有数组 [1,2,3] 包含了从1到3的整数并且正好拥有 0 个逆序对。</pre><p><strong>示例 2:</strong></p><pre>输入: n = 3, k = 1输出: 2解释: 数组 [1,3,2] 和 [2,1,3] 都有 1 个逆序对。</pre><p><strong>说明:</strong></p><ol><li>n 的范围是 [1, 1000] 并且 k 的范围是 [0, 1000]。</li></ol><hr><h1>题目分析：</h1><p>咋一看，这题目不是个排列组合的数学题吗？没错，还真是！可是今天算法哥要分享一个利用动态规划的思想来解决这道题目的方法。啥？这也能动态规划！！！</p><hr><p>要动态规划，就必须设计好状态转移的方程式，首先我们<strong>定义一个二维数组f[i][j]表示用[1,2,3...i]这i个整数排列后有j个逆序对的数量。</strong>为啥要这么定义呢？继续往下看！</p><hr><p>定义好f[i][j]的状态后，我们就得思考怎么进行状态转移，<strong>假设你现在知道f[i - 1][j]了，也就是说你知道了用[1,2,3...i-1]前i - 1个数排列后有j个逆序对的数量是f[i-1][j]，此时，把整数i，直接放到前面用i-1个数排列后有j个逆序对的数组末尾，此时是不是还是j个逆序对，因为i是最大的，它放在最后，不会产生新的逆序对！这是不是就得到了用[1,2,3...i]前i个整数排列产生j个逆序对的一种方式？</strong>举个例子！</p><hr><p>f[3][1]=2，因为用[1,2,3]组成1个逆序对的排列有两种，[1,3,2]，[2,1,3]，现在我们在这两个排列的末尾都补上4，变成[1,3,2,4]，[2,1,3,4]，此时每个排列的逆序对还是1，因为添加的4是最大的，不会产生新的逆序对，此时是不是推导出了f[4][1]里的一种情形？那f[4][1]还有其他情形吗？肯定有，比如4不在排列的末尾！</p><div class=pgc-img><img alt=每日算法LeetCode629：K个逆序对数组（难度系数3/5） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb47c286e5244183b4c67e109b306c0a><p class=pgc-img-caption>f[3][1]推导f[4][1]</p></div><hr><p>f[3][0]=1，因为用[1,2,3]组成0个逆序对的排列只有一种，[1,2,3]，现在要推导出f[4][1]，怎么推导？直接把4放到2和3的中间，变成[1,2,4,3]是不是就推导出了f[4][1]的又一种情形？</p><div class=pgc-img><img alt=每日算法LeetCode629：K个逆序对数组（难度系数3/5） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71ad79b888a04003b2197f34cf16b7b0><p class=pgc-img-caption>f[3][0]推导f[4][1]</p></div><hr><p>那还有其他情形吗？没有了！聪明的读者发现规律了吗？</p><pre>f[4][1] = f[3][1] + f[3][0]同理，我们有：f[4][4] = f[3][4] + f[3][3] + f[3][2] + f[3][1] 为什么这里不加f[3][0] ?因为f[3][0]对应排列[1,2,3]此时把4插入到头部变成[4,1,2,3]逆序对也只有3个，不满足4个的要求！</pre><p>我们再抽象一点：</p><pre>f[i][j] = f[i-1][j] + f[i-1][j-1] + f[i-1][j-2]+......+f[i-1][0]，(i-1 &gt;= j)</pre><hr><pre>f[i][j] = f[i-1][j] + f[i-1][j-1] + f[i-1][j-2]+......+f[i-1][j-(i - 1)]，(i - 1 &lt; j)</pre><p>两个推导式合并</p><pre>f[i][j] = f[i-1][j] + f[i-1][j-1] + f[i-1][j-2]+......+f[i-1][max(0, j-(i - 1))]</pre><hr><p>到这里就结束了吗？如果忽略时间复杂度，确实可以结束了，因为f[i][j]可以转化成规模更小的f[i - 1][j],f[i - 1][j -1]...来推导，这正好是动态规划的思路，但是这么做的复杂度是O(n*k^2)的，怎么推导的请读者自己思考。下面将给出算法哥优化好的一个解法！</p><p>前面的推导式，我们把j用j+1替代！</p><pre>f[i][j+1] = f[i-1][j+1] + f[i-1][j] + f[i-1][j-1]+......+f[i-1][max(0, j+1-(i - 1))]</pre><hr><p>我们用后一个推导式减去前一个推导式得到：</p><pre>f[i][j+1] = f[i-1][j+1] + f[i][j] - (i - 1&lt;= j ? 1:0) * f[i-1][max(0, j + 1-(i - 1))]</pre><hr><p>把j + 1，用j替换得到：</p><pre>f[i][j] = f[i-1][j] + f[i][j-1] - (i &lt;= j ? 1:0) * f[i-1][max(0, j - i)] </pre><hr><p>到这里，最关键的状态转移方程终于出来了！</p><p>直接上源码：</p><div class=pgc-img><img alt=每日算法LeetCode629：K个逆序对数组（难度系数3/5） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4653451cd1f44425a89fcfc0205503cf><p class=pgc-img-caption>O(nk)</p></div><hr><h1>复杂度分析：</h1><p>f[i][j]里，i&lt;=1000, j&lt;=1000，结合代码看两层循环嵌套，所以复杂度是O(nk)的！轻松击败leetcode上98%的提交！</p><hr><h1>题目总结：</h1><p>这个题目有几个难点：</p><ol><li>用前i - 1个数的逆序对去推导前i个数的逆序对，发现这个规律是解决问题的关键；</li><li>发现规律后，将推导式做出进一步推导，得到一个简化的状态转移方程；</li><li>聪明的读者肯定发现算法哥的代码里数组只开了2维，因为每次推导的过程中只有当前这一个维度的数组，和前一个维度的数组在使用，所以可以用<strong>滚动数组</strong>的技巧来优化空间原先需要n维的数组变成来2维，这么做既减少空间，时间上也会有提升（因为数组小了，cpu cache命中率提高了）！</li></ol><p>坚持到这里，相信你肯定收获满满的，那就赶紧关注，转发，点赞吧！让算法哥有激情继续分享下去！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'LeetCode629','逆序','数组'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>