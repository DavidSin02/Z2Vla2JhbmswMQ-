<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>排序算法整合（冒泡，快速，希尔，拓扑，归并） | 极客快訊</title><meta property="og:title" content="排序算法整合（冒泡，快速，希尔，拓扑，归并） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RateqO55LCLXqj"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/257bd06a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/257bd06a.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="排序算法整合（冒泡，快速，希尔，拓扑，归并）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/257bd06a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>排序算法整合（冒泡，快速，希尔，拓扑，归并）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>本文链接：https://blog.csdn.net/onceing/article/details/99838520</strong></p><p><strong>冒泡排序介绍</strong></p><p>冒泡排序(Bubble Sort)，又被称为气泡排序或泡沫排序。</p><p>它是一种较简单的排序算法。它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！</p><p>冒泡排序图文说明</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RateqO55LCLXqj><pre><code>/*<br>* a -- 待排序的数组<br>* n -- 数组的长度<br>*/<br>public static void bubbleSort(int[] a, int n) {<br>int i,j;<br>for (i=n-1; i&gt;0; i--) {<br>// 将a[0...i]中最大的数据放在末尾<br>for (j=0; j&lt;i; j++) {<br>if (a[j] &gt; a[j+1]) {<br>// 交换a[j]和a[j+1]<br>int tmp = a[j];<br>a[j] = a[j+1];<br>a[j+1] = tmp;<br>}<br>}<br>}<br>}<br></code></pre><p><strong>运行：</strong></p><pre><code>int a = {20,40,<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">30</i>,10,60,50,70};<br>String aa = "冒泡排序";<br>bubbleSort(a,a.length);<br><br>System.out.print(aa);<br>for (int d : a) {<br>System.out.print(d+",");<br>}<br></code></pre><p><strong>快速排序介绍</strong></p><p>快速排序(Quick Sort)使用分治法策略。</p><p>它的基本思想是：选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p><strong>快速排序流程：</strong></p><p>从数列中挑出一个基准值。</p><p>将所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面(相同的数可以到任一边)；在这个分区退出之后，该基准就处于数列的中间位置。</p><p>递归地把"基准值前面的子数列"和"基准值后面的子数列"进行排序。</p><p>图文介绍</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RateqOPEDBqMCh><p>代码实现：</p><pre><code><ol><li><pre><code> /**<br>*<br>* 参数说明：<br>* a -- 待排序的数组<br>* l -- 数组的左边界(例如，从起始位置开始排序，则l=0)<br>* r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)<br>*/<br>public static void quickSort(int[] a, int l, int r) {<br><br>if (l &lt; r) {<br>int i,j,x;<br><br>i = l;<br>j = r;<br>x = a[i];<br>while (i &lt; j) {<br>while(i &lt; j &amp;&amp; a[j] &gt; x)<br>j--; // 从右向左找第一个小于x的数<br>if(i &lt; j)<br>a[i++] = a[j];<br>while(i &lt; j &amp;&amp; a[i] &lt; x)<br>i++; // 从左向右找第一个大于x的数<br>if(i &lt; j)<br>a[j--] = a[i];<br>}<br>a[i] = x;<br>quickSort(a, l, i-1); /* 递归调用 */<br>quickSort(a, i+1, r); /* 递归调用 */<br>}<br><br>}<br></code></pre></li></ol></code></pre><p>运行：</p><pre><code> String aa = "快速排序";<br>quickSort(a,0,a.length-1);<br><br><br><br>System.out.print(aa);<br>for (int d : a) {<br>System.out.print(d+",");<br>}<br></code></pre><p>直接插入排序介绍</p><p>直接插入排序(Straight Insertion Sort)的基本思想是：把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</p><p>直接插入排序图文说明</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RateqOe5WubcX4><p><strong>代码实现：</strong></p><pre><code> /**<br>* @param<br>* a -- 待排序的数组<br>* n -- 数组的长度<br>*/<br>public static void insertSort(int[] a, int n) {<br>int i, j, k;<br><br>for (i = 1; i &lt; n; i++) {<br><br>//为a[i]在前面的a[0...i-1]有序区间中找一个合适的位置<br>for (j = i - 1; j &gt;= 0; j--)<br>if (a[j] &lt; a[i])<br>break;<br><br>//如找到了一个合适的位置<br>if (j != i - 1) {<br>//将比a[i]大的数据向后移<br>int temp = a[i];<br>for (k = i - 1; k &gt; j; k--)<br>a[k + 1] = a[k];<br>//将a[i]放到正确位置上<br>a[k + 1] = temp;<br>}<br>}<br>}<br></code></pre><p>运行和冒泡一样。。。。。</p><p><strong>希尔排序：</strong></p><p>希尔(Shell)排序又称为缩小增量排序，它是一种插入排序。它是直接插入排序算法的一种威力加强版。该方法因DL．Shell于1959年提出而得名。</p><p><strong>希尔排序的基本思想是：</strong></p><p>把记录按步长 gap 分组，对每组记录采用直接插入排序方法进行排序。</p><p>随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。</p><p>我们来通过演示图，更深入的理解一下这个过程。</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RateqP65p6BXe4><p>在上面这幅图中：</p><p>初始时，有一个大小为 10 的无序序列。</p><p>在第一趟排序中，我们不妨设 gap1 = N / 2 = 5，即相隔距离为 5 的元素组成一组，可以分为 5 组。接下来，按照直接插入排序的方法对每个组进行排序。</p><p>在第二趟排序中，我们把上次的 gap 缩小一半，即 gap2 = gap1 / 2 = 2 (取整数)。这样每相隔距离为 2 的元素组成一组，可以分为 2 组。按照直接插入排序的方法对每个组进行排序。</p><p>在第三趟排序中，再次把 gap 缩小一半，即gap3 = gap2 / 2 = 1。这样相隔距离为 1 的元素组成一组，即只有一组。按照直接插入排序的方法对每个组进行排序。此时，排序已经结束。</p><p>需要注意一下的是，图中有两个相等数值的元素 5 和 5 。我们可以清楚的看到，在排序过程中，两个元素位置交换了。</p><p>所以，希尔排序是不稳定的算法。</p><p><strong>代码实现：</strong></p><pre><code>/**<br>* 希尔排序<br>* @param list<br>*/<br>public static void shellSort(int[] a) {<br>int gap = a.length / 2;<br><br>while (1 &lt;= gap) {<br>// 把距离为 gap 的元素编为一个组，扫描所有组<br>for (int i = gap; i &lt; a.length; i++) {<br>int j = 0;<br>int temp = a[i];<br><br>// 对距离为 gap 的元素组进行排序<br>for (j = i - gap; j &gt;= 0 &amp;&amp; temp &lt; a[j]; j = j - gap) {<br>a[j + gap] = a[j];<br>}<br>a[j + gap] = temp;<br>}<br><br>System.out.format("gap = %d:\t", gap);<br>printAll(a);<br>gap = gap / 2; // 减小增量<br>}<br>}<br>// 打印完整序列<br>public static void printAll(int[] a) {<br>for (int value : a) {<br>System.out.print(value + "\t");<br>}<br>System.out.println;<br>}<br></code></pre><p>运行参考冒泡、、、、、</p><p><strong>拓扑排序介绍</strong></p><p>拓扑排序(Topological Order)是指，将一个有向无环图(Directed Acyclic Graph简称DAG)进行排序进而得到一个有序的线性序列。</p><p>这样说，可能理解起来比较抽象。下面通过简单的例子进行说明！</p><p>例如，一个项目包括A、B、C、D四个子部分来完成，并且A依赖于B和D，C依赖于D。现在要制定一个计划，写出A、B、C、D的执行顺序。这时，就可以利用到拓扑排序，它就是用来确定事物发生的顺序的。</p><p>在拓扑排序中，如果存在一条从顶点A到顶点B的路径，那么在排序结果中B出现在A的后面。</p><p><strong>拓扑排序的算法图解</strong></p><p><strong>拓扑排序算法的基本步骤：</strong></p><p>1. 构造一个队列Q(queue) 和 拓扑排序的结果队列T(topological)；</p><p>2. 把所有没有依赖顶点的节点放入Q；</p><p>3. 当Q还有顶点的时候，执行下面步骤：</p><p>3.1 从Q中取出一个顶点n(将n从Q中删掉)，并放入T(将n加入到结果集中)；</p><p>3.2 对n每一个邻接点m(n是起点，m是终点)；</p><p>3.2.1 去掉边&lt;n,m>;</p><p>3.2.2 如果m没有依赖顶点，则把m放入Q;</p><p>注：顶点A没有依赖顶点，是指不存在以A为终点的边。</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RateqPJG45XE83><p>以上图为例，来对拓扑排序进行演示。</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RatetTbAsu6Wnr><p><strong>第1步：</strong><strong>将B和C加入到排序结果中。</strong></p><p>顶点B和顶点C都是没有依赖顶点，因此将C和C加入到结果集T中。假设ABCDEFG按顺序存储，因此先访问B，再访问C。访问B之后，去掉边&lt;B,A>和&lt;B,D>，并将A和D加入到队列Q中。同样的，去掉边&lt;C,F>和&lt;C,G>，并将F和G加入到Q中。</p><p>将B加入到排序结果中，然后去掉边&lt;B,A>和&lt;B,D>；此时，由于A和D没有依赖顶点，因此并将A和D加入到队列Q中。</p><p>将C加入到排序结果中，然后去掉边&lt;C,F>和&lt;C,G>；此时，由于F有依赖顶点D，G有依赖顶点A，因此不对F和G进行处理。</p><p><strong>第2步：</strong><strong>将A,D依次加入到排序结果中。</strong></p><p>第1步访问之后，A,D都是没有依赖顶点的，根据存储顺序，先访问A，然后访问D。访问之后，删除顶点A和顶点D的出边。</p><p><strong>第3步：</strong><strong>将E,F,G依次加入到排序结果中。</strong></p><p>因此访问顺序是：B -> C -> A -> D -> E -> F -> G</p><p>拓扑排序的代码说明</p><p>拓扑排序是对有向无向图的排序。下面以邻接表实现的有向图来对拓扑排序进行说明。</p><p>1. 基本定义</p><pre><code>public class ListDG {<br>// 邻接表中表对应的链表的顶点<br>private class ENode {<br>int ivex;<br>// 该边所指向的顶点的位置<br>ENode nextEdge;<br>// 指向下一条弧的指针<br>}<br><br>// 邻接表中表的顶点<br>private class VNode {<br>char data;<br>// 顶点信息<br>ENode firstEdge;<br>// 指向第一条依附该顶点的弧<br>};<br><br>private VNode mVexs;<br>// 顶点数组<br><br>...<br>}<br></code></pre><ol><li><p>ListDG是邻接表对应的结构体。mVexs则是保存顶点信息的一维数组。</p></li><li><p>VNode是邻接表顶点对应的结构体。data是顶点所包含的数据，而firstEdge是该顶点所包含链表的表头指针。</p></li><li><p>ENode是邻接表顶点所包含的链表的节点对应的结构体。ivex是该节点所对应的顶点在vexs中的索引，而nextEdge是指向下一个节点的。</p><br></li></ol><p>2. 拓扑排序</p><pre><code>/*<br>* 拓扑排序<br>*<br>* 返回值：<br>* -1 -- 失败(由于内存不足等原因导致)<br>* 0 -- 成功排序，并输入结果<br>* 1 -- 失败(该有向图是有环的)<br>*/<br>public int topologicalSort {<br>int index = 0;<br>int num = mVexs.size;<br>int ins;<br>// 入度数组<br>char tops;<br>// 拓扑排序结果数组，记录每个节点的排序后的序号。<br>Queue&lt;Integer&gt; queue;<br>// 辅组队列<br><br>ins = new int[num];<br>tops = new char[num];<br>queue = new LinkedList&lt;Integer&gt;;<br><br>// 统计每个顶点的入度数<br>for(int i = 0; i &lt; num; i++) {<br><br>ENode node = mVexs.get(i).firstEdge;<br>while (node != ) {<br>ins[node.ivex]++;<br>node = node.nextEdge;<br>}<br>}<br><br>// 将所有入度为0的顶点入队列<br>for(int i = 0; i &lt; num; i ++)<br>if(ins[i] == 0)<br>queue.offer(i);<br>// 入队列<br><br>while (!queue.isEmpty) {<br>// 队列非空<br>int j = queue.poll.intValue;<br>// 出队列。j是顶点的序号<br>tops[index++] = mVexs.get(j).data;<br>// 将该顶点添加到tops中，tops是排序结果<br>ENode node = mVexs.get(j).firstEdge;<br>// 获取以该顶点为起点的出边队列<br><br>// 将与"node"关联的节点的入度减1；<br>// 若减1之后，该节点的入度为0；则将该节点添加到队列中。<br>while(node != ) {<br>// 将节点(序号为node.ivex)的入度减1。<br>ins[node.ivex]--;<br>// 若节点的入度为0，则将其"入队列"<br>if( ins[node.ivex] == 0)<br>queue.offer(node.ivex);<br>// 入队列<br><br>node = node.nextEdge;<br>}<br>}<br><br>if(index != num) {<br>System.out.printf("Graph has a cycle\n");<br>return 1;<br>}<br><br>// 打印拓扑排序结果<br>System.out.printf("== TopSort: ");<br>for(int i = 0; i &lt; num; i ++)<br>System.out.printf("%c ", tops[i]);<br>System.out.printf("\n");<br><br>return 0;<br>}<br></code></pre><p><strong>说明：</strong></p><p>queue的作用就是用来存储没有依赖顶点的顶点。它与前面所说的Q相对应。</p><p>tops的作用就是用来存储排序结果。它与前面所说的T相对应。</p><p><strong>归并排序</strong></p><p>基本思想</p><p>归并排序（MERGE-SORT）是利用归并的思想实现的排序方法，该算法采用经典的分治（divide-and-conquer）策略（分治法将问题分(divide)成一些小的问题然后递归求解，而治(conquer)的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。</p><p>分而治之</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RatetTt76aeOSP><p>可以看到这种结构很像一棵完全二叉树，本文的归并排序我们采用递归去实现（也可采用迭代的方式去实现）。分阶段可以理解为就是递归拆分子序列的过程，递归深度为log2n。</p><p>合并相邻有序子序列</p><p>再来看看治阶段，我们需要将两个已经有序的子序列合并成一个有序序列，比如上图中的最后一次合并，要将[4,5,7,8]和[1,2,3,6]两个已经有序的子序列，合并为最终序列[1,2,3,4,5,6,7,8]，来看下实现步骤。</p><img alt=排序算法整合（冒泡，快速，希尔，拓扑，归并） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RatetWN6cDKgdy><p>代码实现</p><pre><code>package sortdemo;<br><br>import java.util.Arrays;<br><br>/**<br>* Created by chengxiao on 2016/12/8.<br>*/<br>public class MergeSort {<br>public static void main(String []args){<br>int arr = {9,8,7,6,5,4,3,2,1};<br>sort(arr);<br>System.out.println(Arrays.toString(arr));<br>}<br>public static void sort(int []arr){<br>int temp = new int[arr.length];<br>//在排序前，先建好一个长度等于原数组长度的临时数组，<br>//避免递归中频繁开辟空间<br>sort(arr,0,arr.length-1,temp);<br>}<br>private static void sort(int[] arr,int left,int right,int []temp){<br>if(left&lt;right){<br>int mid = (left+right)/2;<br>sort(arr,left,mid,temp);<br>//左边归并排序，使得左子序列有序<br>sort(arr,mid+1,right,temp);<br>//右边归并排序，使得右子序列有序<br>merge(arr,left,mid,right,temp);<br>//将两个有序子数组合并操作<br>}<br>}<br>private static void merge(int[] arr,int left,int mid,int right,int[] temp){<br>int i = left;//左序列指针<br>int j = mid+1;//右序列指针<br>int t = 0;//临时数组指针<br>while (i&lt;=mid &amp;&amp; j&lt;=right){<br>if(arr[i]&lt;=arr[j]){<br>temp[t++] = arr[i++];<br>}else {<br>temp[t++] = arr[j++];<br>}<br>}<br>while(i&lt;=mid){//将左边剩余元素填充进temp中<br>temp[t++] = arr[i++];<br>}<br>while(j&lt;=right){//将右序列剩余元素填充进temp中<br>temp[t++] = arr[j++];<br>}<br>t = 0;<br>//将temp中的元素全部拷贝到原数组中<br>while(left &lt;= right){<br>arr[left++] = temp[t++];<br>}<br>}<br>}<br></code></pre><p><strong>最后</strong></p><p>归并排序是稳定排序，它也是一种十分高效的排序，能利用完全二叉树特性的排序一般性能都不会太差。java中Arrays.sort采用了一种名为TimSort的排序算法，就是归并排序的优化版本。从上文的图中可看出，每次合并操作的平均时间复杂度为O(n)，而完全二叉树的深度为|log2n|。总的平均时间复杂度为O(nlogn)。而且，归并排序的最好，最坏，平均时间复杂度均为O(nlogn)。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'冒泡','希尔','拓扑'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>