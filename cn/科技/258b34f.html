<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「正点原子NANO STM32开发板资料连载」第十章 外部中断实验 | 极客快訊</title><meta property="og:title" content="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/258b34f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/258b34f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/258b34f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/258b34f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/258b34f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/258b34f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/258b34f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/258b34f.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/258b34f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「正点原子NANO STM32开发板资料连载」第十章 外部中断实验</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1）实验平台：ALIENTEK NANO STM32F411 V1开发板</strong></p><p><strong>2）摘自《正点原子STM32F4 开发指南（HAL 库版》关注官方微信号公众号，获取更多资料：正点原子</strong></p><div class=pgc-img><img alt="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption></p></div><p><strong>第十章 外部中断实验</strong></p><p>这一章，我们将向大家介绍如何使用 STM32F4 的外部输入中断。在前面几章的学习中，</p><p>我们掌握了 STM32F4 的 IO 口最基本的操作。本章我们将介绍如何将 STM32F4 的 IO 口作为外</p><p>部中断输入，在本章中，我们将以中断的方式，实现我们在第八章所实现的功能。本章分为如</p><p>下几个部分：</p><p>10.1 STM32F4 外部中断简介</p><p>10.2 硬件设计</p><p>10.3 软件设计</p><p>10.4 下载验证</p><p><strong>10.1 STM32F4 外部中断简介</strong></p><p>STM32F4 的 IO 口在第六章有详细介绍，而中断管理分组管理在前面也有详细的阐述。这</p><p>里我们将介绍 STM32F4 外部 IO 口的中断功能，通过中断的功能，达到第八章实验的效果，即：</p><p>通过板载的 4 个按键，控制板载的两个 LED 的亮灭以及蜂鸣器的发声。</p><p>这里我们首先 STM32F4 IO 口中断的一些基础概念。STM32F4 的每个 IO 都可以作为外部</p><p>中断的中断输入口，这点也是 STM32F4 的强大之处。STM32F4 的中断控制器支持 23 个外部中</p><p>断/事件请求。每个中断设有状态位，每个中断/事件都有独立的触发和屏蔽设置。STM32F4 的</p><p>23 个外部中断为：</p><p>线 0~15：对应外部 IO 口的输入中断。</p><p>线 16：连接到 PVD 输出。</p><p>线 17：连接到 RTC 闹钟事件。</p><p>线 18：连接到 USB OTG FS 唤醒事件。</p><p>线 21：连接到 RTC 入侵和时间戳事件。</p><p>线 22：连接到 RTC 唤醒事件。</p><p>从上面可以看出，STM32 供 IO 口使用的中断线只有 16 个，但是 STM32 的 IO 口却远远不</p><p>止 16 个，那么 STM32 是怎么把 16 个中断线和 IO 口一一对应起来的呢？于是 STM32 就这样</p><p>设计，GPIO 的管教 GPIOx.0~GPIOx.15(x=A,B,C,D,E，F,G)分别对应中断线 0~15。这样每个中</p><p>断线对应了最多 7 个 IO 口，以线 0 为例：它对应了 GPIOA.0、GPIOB.0、GPIOC.0、GPIOD.0、</p><p>GPIOE.0、GPIOF.0、GPIOG.0。而中断线每次只能连接到 1 个 IO 口上，这样就需要通过配置</p><p>来决定对应的中断线配置到哪个 GPIO 上了。下面我们看看 GPIO 跟中断线的映射关系图：</p><p><br></p><div class=pgc-img><img alt="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ea48952683054f13878f4b86aee55adf><p class=pgc-img-caption>图 10.1.1 GPIO 和中断线的映射关系图</p></div><p>GPIO 和中断线映射关系是在寄存器 SYSCFG_EXTICR1~ SYSCFG_EXTICR4 中配置的。</p><p>所以我们要配置外部中断，还需要打开 SYSCFG 时钟。</p><p>接下来我们来看看使用 HAL 库配置外部的一般步骤。HAL 中外部相关配置函数和定义在</p><p>文件 stm32f4xx_hal_exti.h 和 stm32f4xx_hal_exti.c 文件中。</p><p><strong>1）使能 IO 口时钟。</strong></p><p>首先，我们要使用 IO 口作为中断输入，所以我们要使能响应的 IO 口时钟，具体的操作方</p><p>法跟我们按键实验是一致的，这里就不做过多讲解。</p><p><strong>2）设置 IO 模式，触发条件，开启 SYSCFG 时钟，设置 IO 口与中断线的映射关系。</strong></p><p>该步骤如果我们使用标准库那么需要多个函数分部实现。而当我们使用 HAL 库的时候，</p><p>则都是在函数 HAL_GPIO_Init 中一次性完成的。例如我们要设置 PA0 链接中断线 0.，并且为上</p><p>升沿触发，代码为：</p><p>GPIO_InitTypeDef GPIO_Initure;</p><p>GPIO_Initure.Pin=GPIO_PIN_0;</p><p>//PA0</p><p>GPIO_Initure.Mode=GPIO_MODE_IT_RISING;</p><p>//上升沿触发</p><p>GPIO_Initure.Pull=GPIO_PULLDOWN;</p><p>//默认下拉</p><p>HAL_GPIO_Init(GPIOA,&GPIO_Initure);</p><p>当我们调用 HAL_GPIO_Init 设置 IO 的 Mode 值为 GPIO_MODE_IT_RSING（外部中断上</p><p>升 沿 触 发 ） ， GPIO_MODE_IT_FALLING （ 外 部 中 断 下 降 沿 触 发 ） 或 者</p><p>GPIO_MODE_IT_RISING_FALLING（外部中断双边沿触发）的时候，该函数内部会通过判断</p><p>Mode 的值来配置模式，并且设置 IO 口和中断线的映射关系。</p><p>因为我们这样初始的是 PA0，根据图 10.1.1 可知，调用该函数后中断线 0 会自动连接到 PA0。</p><p>如果某个时间，我们又同样的方式初始化了 PB0，那么 PA0 与中断线的链接将被清除，而直接</p><p>连接 PB0 到中断线 0。</p><p><strong>3）配置中断优先级（NVIC），并使能中断。</strong></p><p>我们设置好中断线和 GPIO 映射关系，然后又设置好了中断的触发模式等初始化参数。既</p><p>然是外部中断，涉及到中断我们当然还要设置 NVIC 中断优先级。这个在前面已经讲解过，这</p><p>里我们就接着上面的范例，设置中断线 0 的中断优先级并使能外部中断 0 的方法为：</p><p>HAL_NVIC_SetPriority(EXTI0_IRQn,2,2);</p><p>//抢占优先级为 2，子优先级为 2</p><p>HAL_NVIC_EnableIRQ(EXTI0_IRQn);</p><p>//使能中断线 0</p><p>上面这段代码相信大家都不陌生，我们在前面的串口实验的时候讲解过，这里不再讲解。</p><p><strong>4）编写中断服务函数。</strong></p><p>我们配置完中断优先级之后，接着要做的就是编写中断服务函数。中断服务函数的名字是</p><p>在 HAL 库中事先有定义的。这里需要说明一下，STM32F4 的 IO 口外部中断服务函数只有 7</p><p>个，分别为：</p><p>Void EXTI0_IRQHandler();</p><p>Void EXTI1_IRQHandler();</p><p>Void EXTI2_IRQHandler();</p><p>Void EXTI3_IRQHandler();</p><p>Void EXTI4_IRQHandler();</p><p>Void EXTI9_5_IRQHandler();</p><p>Void EXTI15_10_IRQHandler();</p><p>中断线 0-4 每个中断线对应一个中断函数，中断线 5~9 共用中断函数 EXTI9_5_IRQHandler，</p><p>中断线 10-15 共用中断函数 EXTI15_10_IRQHandler。一般情况下，我们可以把中断控制逻辑直</p><p>接编写在中断服务函数中，但是 HAL 库把中断处理过程进行了简单封装，请看下面步骤 5 讲</p><p>解。</p><p><strong>4） 编写中断处理回调函数 HAL_GPIO_EXTI_Callback</strong></p><p>在使用 HAL 库的时候，我们也可以使用标准库一样，在中断服务函数中编写控制逻辑。</p><p>但 是 HAL 库 为 了 用 户 使 用 方 便 ， 它 提 供 了 一 个 中 断 通 用 入 口 参 数</p><p>HAL_GPIO_EXTI_IRQHandler，在该函数内部直接调用回调函数 HAL_GPIO_EXTI_Callback。</p><p>我们可以看看 HAL_GPIO_EXTI_IRQHandler 函数定义：</p><p>Void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)</p><p>{</p><p>If(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin)!=RESET)</p><p>{</p><p>__HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);</p><p>HAL_GPIO_EXTI_Callback(GPIO_Pin);</p><p>}</p><p>}</p><p>该 函 数 实 现 的 作 用 非 常 简 单 ， 就 是 清 除 中 断 标 志 位 ， 然 后 调 用 回 调 函 数</p><p>HAL_GPIO_EXTI_Callback()实现控制逻辑。所以我们编写中断控制逻辑将跟串口实验类似，在</p><p>中断服务函数中直接调用外部中断共用处理函数 HAL_GPIO_EXTI_IRQHandler，然后在回调函</p><p>数 HAL_GPIO_EXTI_Callback 中通过判断中断是来自哪个 IO 口编写相应的中断服务控制逻辑。</p><p>讲到这里，相信大家对 STM32 的 IO 口外部中断已经有了一定的了解。下面我们再总结一下配</p><p>置 IO 口外部中断的一般步骤：</p><p>1）使能 IO 口时钟。</p><p>2）调用函数 HAL_GPIO_Init 设置 IO 口模式，触发条件，使能 SYSCFG 时钟以及设置 IO</p><p>口与中断线的映射关系。</p><p>3）配置中断优先级（NVIC），并使能中断。</p><p>4）在中断服务函数中调用外部中断共用入口函数 HAL_GPIO_EXTI_IRQHandler。</p><p>5）编写外部中断回调函数 HAL_GPIO_EXTI_Callback。</p><p>通过以上几个步骤的设置，我们就可以正常使用外部中断了。</p><p>本章，我们要实现同第八章差不多的功能，但是这里我们使用的是中断来检测按键，还是</p><p>KEY_UP 同时控制 DS0 和 DS1，按一次，他们的状态就翻转一次；KEY2 控制蜂鸣器，按一次</p><p>叫，再按一次停；KEY1 控制 DS1，按一次亮，再按一次灭；KEY0 控制 DS0，效果同 KEY1。</p><p><strong>10.2 硬件设计</strong></p><p>本实验用到的硬件资源和第八章实验的一模一样，不再多做介绍了。</p><p><strong>10.3 软件设计</strong></p><p>我们直接打开我们的光盘的实验 5 外部中断实验工程，可以看到相比上一个工程，我们的</p><p>HARDWARE 目录下面增加了 exti.c 文件，并且包含了头文件 exti.h。exti.c 文件代码如下：</p><p>//外部中断初始化</p><p>void EXTI_Init(void)</p><p>{</p><p>GPIO_InitTypeDef GPIO_Initure;</p><p>__HAL_RCC_GPIOA_CLK_ENABLE();</p><p>//开启 GPIOA 时钟</p><p>__HAL_RCC_GPIOC_CLK_ENABLE();</p><p>//开启 GPIOC 时钟</p><p>GPIO_Initure.Pin=GPIO_PIN_0;</p><p>//PA0</p><p>GPIO_Initure.Mode=GPIO_MODE_IT_RISING;</p><p>//上升沿触发</p><p>GPIO_Initure.Pull=GPIO_PULLDOWN;</p><p>HAL_GPIO_Init(GPIOA,&GPIO_Initure);</p><p>GPIO_Initure.Pin=GPIO_PIN_8|GPIO_PIN_9;</p><p>//PC8、PC9</p><p>GPIO_Initure.Mode=GPIO_MODE_IT_FALLING; //下降沿触发</p><p>GPIO_Initure.Pull=GPIO_PULLUP;</p><p>HAL_GPIO_Init(GPIOC,&GPIO_Initure);</p><p>GPIO_Initure.Pin=GPIO_PIN_2;</p><p>//PD2</p><p>HAL_GPIO_Init(GPIOD,&GPIO_Initure);</p><p>//中断线 0-PA0</p><p>HAL_NVIC_SetPriority(EXTI0_IRQn,2,2);</p><p>//抢占优先级为 2，子优先级为 2</p><p>HAL_NVIC_EnableIRQ(EXTI0_IRQn);</p><p>//使能中断线 0</p><p>//中断线 8、9-PC8、9</p><p>HAL_NVIC_SetPriority(EXTI9_5_IRQn,2,1); //抢占优先级为 2，子优先级为 1</p><p>HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);</p><p>//中断线 2-PD2</p><p>HAL_NVIC_SetPriority(EXTI2_IRQn,2,0);</p><p>//抢占优先级为 2，子优先级为 0</p><p>HAL_NVIC_EnableIRQ(EXTI2_IRQn);</p><p>//使能中断线 2</p><p>}</p><p>//中断服务函数</p><p>void EXTI0_IRQHandler(void)</p><p>{</p><p>HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0); //调用中断处理公用函数</p><p>}</p><p>void EXTI9_5_IRQHandler(void)</p><p>{</p><p>HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8); //调用中断处理公用函数</p><p>HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_9); //调用中断处理公用函数</p><p>}</p><p>void EXTI2_IRQHandler(void)</p><p>{</p><p>HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_2); //调用中断处理公用函数</p><p>}</p><p>//中断服务程序中需要做的事情</p><p>//在 HAL 库中所有的外部中断服务函数都会调用此函数</p><p>//GPIO_Pin:中断引脚号</p><p>void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)</p><p>{</p><p>delay_ms(10);</p><p>//消抖</p><p>switch(GPIO_Pin)</p><p>{</p><p>case GPIO_PIN_0:</p><p>if(WK_UP==1)</p><p>{</p><p>LED0=!LED0;</p><p>//控制 LED0,LED1 互斥点亮</p><p>LED1=!LED1;</p><p>}</p><p>break;</p><p>case GPIO_PIN_8:</p><p>if(KEY0==0)</p><p>//控制 LED0 翻转</p><p>{</p><p>LED0=!LED0;</p><p>}</p><p>break;</p><p>case GPIO_PIN_9:</p><p>if(KEY1==0)</p><p>{</p><p>LED1=!LED1;</p><p>//控制 LED1 翻转</p><p>}</p><p>break;</p><p>case GPIO_PIN_2:</p><p>if(KEY2==0)</p><p>{</p><p>BEEP=!BEEP;</p><p>//控制 BEEP</p><p>}</p><p>}</p><p>}</p><p>exit.c 文件总共包含 5 个函数。外部中断初始化函数 void EXTIX_Init 用来配置 IO 口外部中</p><p>断相关步骤并使能中断，另一个和函数 HAL_GPIO_EXTI_Callback 是外部中断共用回调函数，</p><p>用来处理所有外部中断真正的控制逻辑。其他 3 个都是中断服务函数。</p><p>void EXTI0_IRQHandler(void)是外部中断 0 的服务函数，负责 WK_UP 按键的中断检测；</p><p>void EXTI2_IRQHandler(void)是外部中断 2 的服务函数，负责 KEY2 按键的中断检测；</p><p>void EXTI9_5_IRQHandler(void)是外部中断 5~9 的服务函数，负责 KEY0 和 KEY1 按键的中断检测；</p><p>下面我们分别介绍这几个函数。</p><p>首先是外部中断初始化函数 void_EXTI_Init(void)，该函数内部主要是做了两件事情。首先</p><p>是调用 IO 口初始化函数 HAL_GPIO_Init 来初始化 IO 口，该函数的配置含义请看 10.1 小节中</p><p>关于 HAL_GOIO_Init 函数讲解。其次是设置中断优先级并使能中断线。</p><p>接下来我们看看外部中断服务函数，一共 3 个。所有的中断服务函数内部都只调用了同样</p><p>一个函数 HAL_GPIO_EXTI_IRQHandler，该函数是外部中断共用入口函数，函数内部会进行中</p><p>断标志位清零，并且调用中断处理共同回调函数 HAL_GPIO_EXTI_Callback。这在 10.1 小节我</p><p>们也有详细的讲解。</p><p>最后是外部中断回调函数 HAL_GPIO_EXTI_Callback，该函数用来编写真正的外部中断控</p><p>制逻辑。该函数有一个入口参数是 IO 口序号。我们我们在该函数内部，一般通过判断 IO 口序</p><p>号来确定中断是来自哪个 IO 口，也就是哪个中断线，然后编写相应的控制逻辑。所以在该函</p><p>数内部，我们通过 switch 语句判断 IO 口来源，例如是来自 GPIO_PIN_0，那么一定是来自 PA0，</p><p>因为中断线一次只能连接一个 IO 口，而四个 IO 口中序号为 0 的 IO 口只有 PA0，所以中断线 0</p><p>一定是连接 PA0，也就是外部中断由 PA0 触发。</p><p>接下来我们看看主函数，main 函数代码如下：</p><p>int main(void)</p><p>{</p><p>HAL_Init();</p><p>//初始化 HAL 库</p><p>Stm32_Clock_Init(96,4,2,4);</p><p>//设置时钟,96Mhz</p><p>delay_init(96);</p><p>//初始化延时函数</p><p>uart_init(115200);</p><p>//初始化串口 115200</p><p>LED_Init();</p><p>//初始化 LED</p><p>KEY_Init();</p><p>//初始化按键</p><p>BEEP_Init();</p><p>//初始化 BEEP</p><p>EXTI_Init();</p><p>//初始化外部中断</p><p>LED0=0;</p><p>//点亮 LED</p><p>while(1)</p><p>{</p><p>printf("OK\r\n");</p><p>//打印 OK 提示程序运行</p><p>delay_ms(1000);</p><p>//每隔 1s 打印一次</p><p>}</p><p>}</p><p>该部分代码非常简单，先进行各项初始化之后，在 while 死循环中不停的打印字符串到串</p><p>口。当有某个外部按键按下之后，会触发中断服务函数做出相应的反应。</p><p><strong>10.4 下载验证</strong></p><p>在编译成功之后，我们就可以下载代码到 NANO STM32F4 开发板上，实际验证一下我们</p><p>的程序是否正确。下载代码后，在串口调试助手里面可以看到如图 10.4.1 所示信息：</p><div class=pgc-img><img alt="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a9a74e4e2dd47969ebeaea326abae6b><p class=pgc-img-caption>图 10.4.1 串口收到的数据</p></div><p>从图 10.4.1 可以看出，程序已经在运行了，此时可以通过按下 KEY0、KEY1、KEY2 和</p><p>KEK_UP 来观察 DS0、DS1 以及蜂鸣器是否跟着按键的变化而变化。</p><p><strong>10.5 STM32CubeMX 配置外部中断</strong></p><p>本 小 节 我 们 将 会 大 家 用 STM32CubeMX 配 置 外 部 中 断 相 关 的 初 始 化 代 码 。 关 于</p><p>STM32CubeMX 的配置，本小节开始，我们对于每个实验只讲解实验相关关键配置部分，如果</p><p>大家不知道具体怎么进入相关界面，请仔细看看前面几个章节实验。</p><p>对于外部中断的配置，首先在 MCU 引脚配置图界面选择对应的 GPIO 设置其模式为外部</p><p>中断模式。这里以 PD2 为例，如下图 10.5.1 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b60f9fab66de44c79b8d2a0f1b01164b><p class=pgc-img-caption>图 10.5.1 PD2 引脚配置</p></div><p>使用同样的方法依次配置 PA0 和 PC8/PC9，然后我们打开依次点击 Configuration->GPIO</p><p>进入 GPIO 详细配置 Pin Configuration，界面会列车 4 个 IO 口的配置信息。我们选中 PA0，看</p><p>看此时 IO 口配置信息详情如下图 10.5.2 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2763cce279ce425182a8ce08854ff974><p class=pgc-img-caption>图 10.5.2 GPIO 配置详情界面</p></div><p>从上图界面可以看出，当我们配置 IO 口作为外部中断触发引脚之后，其详细配置界面便</p><p>只有三个选项。第一个选项 GPIO mode 用来设置外部中断触发方法，上升沿触发还是下降沿触</p><p>发还是双边沿触发。第二个选项 GPIO Pull-up/Pull-down 用来设置是默认上拉还是下拉。这两个</p><p>参数根据我们前面讲解的外部中断知识就很好理解了。这里我们除了设置 PA0 为上升沿触发默</p><p>认下拉外，其他 IO 口设置为下降沿触发默认上拉。</p><p>配置号 IO 口信息之后，接下来就需要配置 NVIC 中断优先级设置。依次点击 System</p><p>Core->NVIC，进入 NVIC 配置界面。在界面可以看到有三个外部中断线可配置，这是因为我们</p><p>前面开启了四个 IO 外部中断（对应 3 个外部中断线）。我们按照实验讲解，依次配置三个中</p><p>断线的 NVIV 即可，配置完成后如下图 10.5.3 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32开发板资料连载」第十章 外部中断实验" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e9c53c239ecc447597598fa2fab0c6e7><p class=pgc-img-caption>图 10.5.3 NVIC 配置界面</p></div><p>最后生成工程，为了篇幅考虑，这里我们就不再列车生成的关键代码。在 main.c 中生成的</p><p>函 数 MX_GPIO_Init 和 我 们 实 验 工 程 中 exti.c 文 件 中 的 函 数 EXTI_Init 内 容 一 致 ， 在</p><p>stm32f4xx_it.c 中生产了 4 个中断服务函数，在 exti.c 文件中的中断服务函数内容一致。当然，</p><p>回调函数 HAL_GPIO_EXTI_Callback 的内容软件是无法自动生成的，需要我们自己编写。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'正点','NANO','STM32'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>