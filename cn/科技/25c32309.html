<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「计算机组成原理」：常见的指令寻址方式 | 极客快訊</title><meta property="og:title" content="「计算机组成原理」：常见的指令寻址方式 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1dc0ee5b851b4062bec43075dc04a3ac"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/25c32309.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/25c32309.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/25c32309.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/25c32309.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/25c32309.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/25c32309.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/25c32309.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/25c32309.html><meta property="article:published_time" content="2020-11-14T21:06:06+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:06+08:00"><meta name=Keywords content><meta name=description content="「计算机组成原理」：常见的指令寻址方式"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/25c32309.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「计算机组成原理」：常见的指令寻址方式</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="background-color:#f3f5f9;--tt-darkmode-bgcolor: #BDBEC1">常见寻址方式操作数的寻址方式，就是CPU根据指令的操作数如何寻找真实的数据，或者真实的数据如何在指令 表示。</span></p><p>寻址方式是指寻找<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">指令</span></span>或者<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">操作数</span></span>的有效地址的方式。即确定本条指令的数据地址及下一条指令将要执行的指令地址的方法。 指令中的地址码字段并不代表操作数的真实地址，<strong>地址码中的字段，称为形式地址（A）</strong>。用形式地址结合寻址方式可以计算出<strong>操作数在存储系统中的真实地址，称为有效地址（EA）</strong>。 对于<strong>符号 （A）</strong>，整个内容表示的是<strong>地址为A的数值</strong>。而<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">A</span></span>可以是寄存器的标号，也可以是内存地址，所以（A）是对应的数值。例如<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = （A）</span></span>，可以表示为有效地址为<strong>地址为A的数值</strong>。</p><pre><code>这一部分可以用指针的知识理解，（A）相当于*A，而EA = （A）相当于，EA = *（*A）</code></pre><p>寻址方式分为指令寻址跟数据寻址<strong>两大类</strong>。<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">寻找下一条要执行的指令地址</span></span>，称为<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">指令寻址</span></span>。<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">寻找操作数的地址</span></span>称之为<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">数据寻址</span></span>。</p><h1 class=pgc-h-arrow-right><strong>指令寻址</strong></h1><ol start=1><li>顺序寻址 程序的指令序列在主存中顺序存放，程序执行的时候，从第一条指令开始，逐条取出并逐条执行。这种程序的顺序执行，称为顺序寻址方式。 为了达到顺序寻址的目的，<strong>CPU中必须有一个程序计数器（PC）</strong>.对指令的顺序号进行计数。PC中开始时存放的是程序的首地址，每执行一条指令，PC+1，用来指明下一条指令所在内存的地址，直到程序结束。这里一定注意，<strong>PC中存放的是下一条指令的地址</strong>。</li><li>跳跃寻址 当程序出现分支或者循环的时候，就会改变程序的执行顺序，此时对指令寻址采取跳跃寻址方式。。所谓跳跃，便是指下条指令的地址并不是通过PC的当前值来获取的，而是由指令本身给出，<strong>跳跃的处理方式是重新修改PC的内容，然后进入取指阶段（也就是说，下一条指令的地址仍由PC所给出，只不过它的值被修改了。）</strong></li></ol><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1dc0ee5b851b4062bec43075dc04a3ac><p class=pgc-img-caption></p></div><p><strong>数据寻址</strong><br>数据的寻址方式比较多样，其过程就是把操作数的形式地址，变换成操作数的有效地址的过程。通常数据寻址的指令格式如下：</p><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3adccf06337d44979de1897fd40f14d9><p class=pgc-img-caption></p></div><p>通常我们约定：<strong>指令字长 = 存储字长 = 机器字长</strong>。</p><p>根据操作数存放的不同位置，从而衍生出各种不同的寻址方式，往往不同的计算机有不同的寻址方式。而操作数，通常位于：</p><ul><li>包含在指令中</li><li>包含在CPU的某一寄存器中</li><li>包含在主存储器中</li><li>包含在I/O设备的端口中</li></ul><h1 class=pgc-h-arrow-right><strong>1. 隐含寻址</strong></h1><p>这种类型的指令，不是明显的给出操作数的地址，而是在指令中隐含着操作数的地址，显然单地址指令就是如此。（<strong>比如利用ACC作为第二操作数的地址，因此，累加器ACC对单地址指令格式来说是隐含地址</strong>）。</p><p>优点：利于缩短指令字长，可简化地址结构，<strong>是获取操作数最快的方式</strong></p><p>缺点：需要增加存储操作数的硬件或者隐含地址的硬件。</p><h1 class=pgc-h-arrow-right><strong>2. 立即寻址</strong></h1><p>种类型的指令，地址字段是操作数本身，因此，又称立即数寻址，数据采用补码的方式存放。 看下面的汇编代码,分号后面是注释：</p><pre><code>1.mov ax,2308H ;2308 -&gt;ax</code></pre><p>意思是将<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">2308H</span></span>这个地址移动到<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">ax</span></span>寄存器中，这样，给出的地址就是操作数本身。</p><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4fb7171408264a2b9361d390be74931f><p class=pgc-img-caption></p></div><ul><li><strong>优点：</strong>在取指令的时候，操作码跟操作数被同时取出，不必再次访存，提高了指令的执行速度。</li><li><strong>缺点：</strong>因操作数指令的一部分，因此不能被修改，而且对于定长指令格式，操作数大小还将受到长度的限制。</li></ul><p>所以，通常用于给定的某一寄存器或者主存单元赋值，或者用于提供某一常数。换成C++代码可以看成：</p><pre><code>1.int x = 100;2.const int j = 100;3.···</code></pre><h1 class=pgc-h-arrow-right><strong>3. 直接寻址</strong></h1><p>即地址码字段直接给出操作数所在的内存地址，即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = A</span></span>的情况。如下面的汇编指令：</p><pre><code>mov ax [200]; 将地址为200处的数据，存放到ax中</code></pre><p>这种行为就像程序中直接给出变量名：</p><pre><code>int y = x;</code></pre><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f58cb516ed51427598cf1b1c5ebefe82><p class=pgc-img-caption></p></div><p><strong>优点：</strong>简单，执行阶段值访问一次内存，因此在早期的计算机中，常常作为主要的寻址方式 缺点：A的位数决定了该指令操作数的寻址范围，并且操作数的地址不易被修改。</p><h1 class=pgc-h-arrow-right><strong>4. 间接寻址</strong></h1><p>间接寻址是相对直接寻址而言的，指令的地址字段不是操作数的真实地址，而是操作数的有效地址所在的存储单元的地址，听起来有点拗口，也就是操作数地址的地址，即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = (A)</span></span>，间接寻址可以是一次间接寻址也可以是多次间接寻址。如果还是有点不好理解，那么用下图来理解（用间接寻址的方式取出<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">788</span></span>这个数）：<br></p><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/272a5c3bacf54e748198f9565d92c32e><p class=pgc-img-caption></p></div><ul><li><strong>优点：</strong>明明可以一步到位，为什么还有多此一举？显然，这种方式可以扩大寻址范围，将小地址作为一个跳板，可以访问更多的地址空间，便于编程（子程序中的返回）。</li><li><strong>缺点：</strong>需要进行多次访存（一次的间接寻址就需要两次访存）。访问速度慢。</li></ul><h1 class=pgc-h-arrow-right><strong>5. 寄存器寻址</strong></h1><p>寄存器寻址是指的在指令中，直接给出操作数所在的寄存器编号，即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = Ri</span></span>。操作数在R的内部（类似于直接寻址）。 就像下面的汇编指令：</p><pre><code>mov ax,bx</code></pre><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2f799edf11fd4e4f8a6c29e9b28cd7a6><p class=pgc-img-caption></p></div><ul><li><strong>优点：</strong>指令执行时，不访问内存，只访问寄存器，指令字短，故执行速度快，支持向量/矩阵运算。</li><li><strong>缺点：</strong>寄存器的价格昂贵，且计算机内寄存器的数量有限。</li></ul><h1 class=pgc-h-arrow-right><strong>6. 寄存器间接寻址</strong></h1><p>类似于间接寻址，寄存器中给出的不是一个操作数，而是操作数所在的主存单元的地址，即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = Ri</span></span>。 用汇编指令表示为;</p><pre><code>mov ax,[bx]</code></pre><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d2621d9190ba491090b9d017793c893a><p class=pgc-img-caption></p></div><p>这种做法的主要特点就是，比间接寻址快，但是由于操作数在主存中，故仍需要访问内存，<strong>一般用于扩大寻址范围。</strong></p><h1 class=pgc-h-arrow-right><strong>7. 相对寻址</strong></h1><p>这种寻址方式的原理是基于程序的局部性原理。指令中的A，加上PC上的内容，作为操作数的地址。即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = （PC）+ A</span></span>。其中A是相对于当前地址的偏移量。可正可负。用补码表示。</p><p><strong>特点：</strong>A的位数决定操作数的寻址范围。操作数不固定，随着PC的变化而变化，并与指令地址总差一个固定值。便于程序浮动。被广泛用于转移指令（即jump指令）。 这里注意理解PC指令的作用。比如下面的句子：</p><pre><code>jump A</code></pre><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56f5397d8cba43deb7c3491caf4c9548><p class=pgc-img-caption></p></div><p>CPU从存储器中取一个字节，即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">（PC）+1 ->PC</span></span>.也就是说PC自增<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">1</span></span>.若此时，转移指令的地址为<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">X</span></span>，且占<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">2</span></span>个字节。那么取出该指令后，<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">PC</span></span>自增<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">2</span></span>，即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">（PC） = X + 2</span></span>。执行完这个指令后，跳到<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">X+2 + A</span></span>处继续执行。</p><h1 class=pgc-h-arrow-right><strong>8. 基址寻址（面向系统）</strong></h1><p>基址寻址，是将CPU中的基址寄存器<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">（BR）</span></span>的内容，加上指令格式中的形式地址<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">A</span></span>，从而形成有效地址。即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = A +（BR）</span></span>。<br></p><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/747de65aba274dea8c123c33de56f07c><p class=pgc-img-caption></p></div><p><strong>特点：</strong>可以扩大寻址范围（因为基址的位数可以设置为很长）。BR的内容可由操作系统或者管理程序确定。程序的执行期间，BR内容不变但是A的内容可变。有利于多道程序的设计。</p><h1 class=pgc-h-arrow-right><strong>9. 变址寻址（面向用户）</strong></h1><p>这种做法是，指定一个变址寄存器<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">IX</span></span>，有效地址等于<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">A</span></span>与寄存器IX的内容相加。即<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">EA = A +（IX）</span></span>。与上面的基址寻址的方法不同，<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">IX</span></span>的内容可以随要求填入，<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">IX</span></span>既可以用专用的寄存器，又可以用通用寄存器。用汇编指令可以表示为：</p><pre><code>mov ax,200[si]</code></pre><p>过程如图：<br></p><div class=pgc-img><img alt=「计算机组成原理」：常见的指令寻址方式 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3446be5333744172b43b7abc259d06fb><p class=pgc-img-caption></p></div><p>变址寻址是一种被广泛采用的寻址方式。最典型的应用就是将指令的地址码部分给出的地址A作为基准地址，而将变址寄存器中的内容作为修改量。在遇到需要频繁修改操作数地址的操作时，无需修改指令，只要修改变址寄存器中的编址值即可。</p><p>在编程中，可设<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">A</span></span>为数组首地址，不断修改寄存器的内容，便可以得到数组中的任一数据地址。特别适合编制循环程序。</p><h1 class=pgc-h-arrow-right><strong>10. 堆栈寻址</strong></h1><p>堆栈是存储器中按<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">LIFO</span></span>的方式管理的存储区，该存储区的读/写单元地址用一个特定的寄存器给出，该寄存器称为堆栈指针<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">（SP）</span></span>。堆栈分为硬堆栈跟软堆栈两种。 寄存器堆栈称为硬堆栈，从主存中划出一段区域称为软堆栈。</p><p>（这里注意<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">sp</span></span>一开始指向为空，所以在弹出的时候，先加<span style="color:#c7254e;--tt-darkmode-color: #CB2650"><span style="background-color:#f6f6f6;--tt-darkmode-bgcolor: #1B1B1B">1</span></span>，因为有数据的时候才可以弹出。）</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'计算机','组成','常见'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>