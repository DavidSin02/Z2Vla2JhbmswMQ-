<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 | 极客快訊</title><meta property="og:title" content="同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/2db72814-296a-4c27-84a1-f1d39a4dce94"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/26a84f61.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26a84f61.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="同事说并发很难，死磕Java并发？并发机制底层实现的三个原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/26a84f61.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>同事说并发很难，死磕Java并发？并发机制底层实现的三个原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>互联网时代，对开发的素养和技术要求也越来越高，在互联网公司的程序员们肯定也经常会听到“并发编程”。</p><p>如果你是一个优秀的程序员，并发编程是必须要熟练掌握的，但并发编程说简单也简单，说难也确实不容易。</p><p>这不，前两天一个同事向我诉苦，并发编程这么难，到底应该如何下手？</p><p>接下来我们就来聊聊并发编程。</p><p><br></p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/2db72814-296a-4c27-84a1-f1d39a4dce94><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>从原理开始</h1><p>首先学习下，Java整个并发编程的的本质，也就是它的底层实现原理。</p><p>相信大家在学习或工作中使用到Java多线程时，肯定都用过 synchnorized 和 volatile 。</p><p>这两个东西在Java并发编程中占据着主导地位。</p><p>在并发编程中有这样一句话：一切并发问题的根源都是由<strong>可见性、原子性、有序性</strong>导致的。</p><p>这里volatile 就是为了解决在多处理器开发中解决共享变量的可见性问题的。</p><p>昨天的文章里已经详情介绍了volatile，今天们简单介绍一下volatile有今生前缘。</p><h1 class=pgc-h-arrow-right>volatile的今生前缘</h1><p>Java语言规范中对 volatile的定义如下：</p><p>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p><p>这句话该怎么理解呢？ 别急，为了更好的理解这个概念，我们需要先来学习下与之相关的 CPU 概念。</p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/77c811aa-0e62-4cbb-9e0b-4e33a30e7087><p class=pgc-img-caption></p></div><p>volatile是如何来保证可见性的呢？ 当对volatile变量进行写操作时，jvm在多核处理器下会做两件事：</p><ul><li>将当前处理器缓存行的数据写回到系统内存</li><li>这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效</li></ul><p>为了弥补越来越快的CPU 与 内存 之间的速度差距，CPU引入了多级缓存（L1，L2，L3或其他）。</p><p>也就是说处理器是不直接与内存交互的，而是先将系统内存中的数据读到 CPU缓存后再进行操作，但是操作何时写到内存时不确定的。 这个时候就展现出 volatile 的强大了，JVM 实现了 当对 volatile 变量进行写操作时，JVM会向处理器发送一条Lock前缀的指令，将这个变量所在的CPU缓存行数据写到内存。</p><p>经过上面的步骤，虽然每次对 volatile 的写操作会立即写到内存，但是好像还缺了点什么？ 喜欢思考的你发现了？</p><p>是的，就算上面的步骤已经学会到主存，但是其他处理的缓存行还是旧的呀，依然会出并发的bug。 所以在多处理器下，为了保证各个处理器的缓存是一致的，就实现了缓存的一致性性协议。每个处理器通过嗅探在总线上传播的数据来检查自己的缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改时，就会将当前处理器的缓存的缓存行设置为无效。</p><p>这样就实现了 volatile 修饰的变量，在写操作时保证多处理器下的数据可见性。</p><h1 class=pgc-h-arrow-right>synchnorized的原理与应用</h1><p>synchnorized 是jdk1.5之前提供的唯一锁机制了。作为元老，你可能会称之为重量级锁，性能很差等等。其实在jdk1.6 对 synchnorized 做了各种优化之后，某些场景下已经不差了，也就是说性能不能在成为广受诟病的槽点了。 jdk1.6 为了减少获取锁和释放锁带来的性能消耗而引入了偏向锁、轻量级锁以及锁的存储结构和升级过程。</p><p>先来看下利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p><ul><li>·对于普通同步方法，锁是当前实例对象</li><li>对于静态同步方法，锁是当前类的Class对象</li><li>·对于同步方法块，锁是Synchonized括号里配置的对象</li></ul><p>这里对用法就不多做介绍了，总结一句话：就是要访问同步代码块，首先获取锁，退出或抛出异常必须释放锁，获取和释放都是JVM帮我们做的，下面一起来看下实现。</p><p>从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步。</p><p>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</p><h1 class=pgc-h-arrow-right>Java对象头</h1><p>synchronized用的锁是存在Java对象头里的, 在64位虚拟机下，Mark Word是64bit大小的，其存储结构如下所示：</p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c0a1d12bbf82486981a7cf84c98240dd><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>锁的升级与对比</h1><p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</p><p><strong>偏向锁</strong></p><p>HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p><p><strong>偏向锁撤销</strong></p><p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程</p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9686affe818b4d1fba464396b11e88b6><p class=pgc-img-caption></p></div><p>偏向锁在Java1.6 后 里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</p><h1 class=pgc-h-arrow-right>轻量级锁</h1><p><strong>轻量级锁加锁</strong></p><p>接下来很重要，敲黑板哦，加锁的过程很奇妙：</p><p>线程在执行同步代码块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Work 复制到锁记录中。 接下来线程会尝试使用CAS操作将对象头中的Mark Word替换为指向锁记录的指针。 如果成功则获取锁，失败则表示被占用，自旋重试。</p><p><strong>轻量级锁解锁</strong></p><p>轻量级锁解锁时，会使用原子性的CAS操作将栈帧中的 Mark Word替换回到对象头，如果成功则表示没有竞争。失败则表示存在竞争，锁膨胀为重量级锁。</p><p>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</p><p>经过上面的学习，我们知道了JVM底层几种锁的实现，那么锁能解决同步问题，必然会引入新的问题，那就是性能问题。 下面总结了几种锁的优缺点：</p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c5442960688473bbd1169d25ded0ff4><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>原子操作</h1><p>原子操作，听到这个概念你肯定会想到我们常说的原子性。是的，就是说一个操作的执行是不可打断的。现代处理器保证了在多核处理器中内存操作的原子性。</p><p>处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址，处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p><strong>1. 使用总线锁保证原子性</strong></p><p>如果多个处理器同时对共享变量进行读改写操作（i++就是经典的读改写操作），那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致。举个例子，如果i=1，我们进行两次i++操作，我们期望的结果是3，但是有可能结果是2。</p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/1c61de18-0c65-4c97-ae6a-2f9156a11bd9><p class=pgc-img-caption></p></div><p>原因参考上图，当多个处理器同时从各自的缓存里读取到i，进行加一操作，然后分别写入到内存。</p><p>所以想要保证原子性，就必须当一个处理器在读写共享变量时，另一个处理器不能操作缓存了该共享变量内存地址的缓存。</p><p>处理器使用总线锁就是来解决这个问题的。所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</p><p>通过对总线锁的学习，你肯定会问，使用总线锁后，同一时刻只有一个处理器可以访问共享内存，岂不是很浪费资源，其他处理器都得歇着，而我们仅仅只需要保证某一个共享变量的原子性，这是杀鸡用了牛刀呀！！！</p><p>别急，我们能想到的事情，现在处理器肯定都已经解决了。。。 接着往下看吧</p><p><strong>2. 使用缓存锁保证原子性</strong></p><p>这种方案，我们只需要同一时刻对某个内存地址的操作原子性即可。</p><p>“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效。</p><h1 class=pgc-h-arrow-right>Java如何实现原子操作</h1><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><p>使用循环CAS实现原子操作</p><p>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本</p><p>思路就是循环进行CAS操作直到成功为止。</p><p><strong>CAS实现原子操作的三大问题：</strong></p><ul><li><strong>ABA问题</strong></li><li><strong>循环时间长开销大</strong></li><li><strong>只能保证一个共享变量的原子操作</strong></li></ul><p><strong>使用锁机制实现原子操作</strong></p><p>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</p><h1 class=pgc-h-arrow-right>总结</h1><p>我们一起学习volatile、synchronized和原子操作的实现原理。Java中的大部分容器和框架都依赖于volatile和原子操作的实现原理，了解这些原理对我们进行并发编程会更有帮助</p><p><br></p><div class=pgc-img><img alt=同事说并发很难，死磕Java并发？并发机制底层实现的三个原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00cbcb3c676b4b7ab8d86b165b2829c2><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','发机','制底'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>