<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>VASP计算二维材料的载流子迁移率 | 极客快訊</title><meta property="og:title" content="VASP计算二维材料的载流子迁移率 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/Rg1fVtJ6yQaQsX"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/272a785.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/272a785.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/272a785.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/272a785.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/272a785.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/272a785.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/272a785.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/272a785.html><meta property="article:published_time" content="2020-10-29T20:50:36+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:36+08:00"><meta name=Keywords content><meta name=description content="VASP计算二维材料的载流子迁移率"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/272a785.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>VASP计算二维材料的载流子迁移率</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1、前言</strong></p><p><strong>载流子迁移率</strong>通常指半导体内部电子和空穴整体的运动快慢情况，是衡量半导体器件性能的重要物理量。2004年，石墨烯的成功剥离引起了研究人员对于二维材料性质探索的浓厚兴趣。石墨烯、黑磷等二维材料展现出的高载流子迁移率是其中的一个重要研究课题，科研人员在理论计算方面已经做了大量的工作。由于电子在运动过程中不仅受到外电场力的作用，还会不断的与晶格、杂质、缺陷等发生无规则的碰撞，<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">大大</i>增加了理论计算的难度。</p><p>目前<strong>计算载流子迁移率</strong>比较常用的理论是<strong>形变势理论</strong>和<strong>玻尔兹曼输运理论</strong>，前者没有考虑电子和声子(晶格振动)以及电子与电子之间的相互作用等因素，计算结果存在一定的误差，但笔者的计算结果与实验值在数量级上是吻合的；玻尔兹曼输运理论的一种计算考虑了电子-声子的相互作用，基于第一性原理计算和最大局域化Wannier函数插值方法，借助于Quantum-ESPRESSO和EPW软件可以完成载流子迁移率计算。缺点是计算量太大，一般的课题组很难承受起高昂的计算费用，另外EPW软件对于二维材料的计算存在部分问题，在其官方论坛也有讨论，计算过程在后续文章中会提到。</p><p>本文以形变势理论方法为基础，详细介绍了二维InSe的电子和空穴的有效质量与载流子迁移率的计算方法。</p><p><strong>2、理论基础</strong></p><p>基于Bardeen和Shockley[1]提出的形变势理论，二维材料载流子迁移率可以根据下式计算：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fVtJ6yQaQsX><p>其中，<em>m</em>∗是传输方向上的有效质量，<em>T</em>是温度，<em>k</em>B是玻尔兹曼常数。<em>E</em>1表示沿着传输方向上位于价带顶(VBM)的空穴或聚于导带底(CBM)的电子的形变势常数，由公式<em>E</em>1=Δ<em>E</em>/(Δ<em>l</em>/<em>l</em>0)确定，Δ<em>E</em>为在压缩或拉伸应变下CBM或VBM 的能量变化，<em>l</em>0是传输方向上的晶格常数，Δ<em>l</em>是<em>l</em>0的变形量。<em>m</em>d是载流子的平均有效质量，由<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">下面</i>公式定义。</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fVtb244TNUF><p><em>C</em>2D是均匀变形晶体的弹性模量，对于2D材料，弹性模量可以通过<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">下面</i>公式来计算，</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fVtm4bQFzR8><p>其中<em>E</em>是总能量，<em>S</em>0是优化后的面积。</p><p><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">下面</i>对公式中的单位(量纲)做一个简单换算，具体如下：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fVu4GvMBwBl><p>换算过程：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fVuODPFnffA><p><strong>3、计算与数据处理工具</strong></p><ul><li><p>VASP.5.4.4软件 可以手动控制优化晶格方向</p></li><li><p>OriginLab软件</p></li><li><p>Excel</p></li><li><p>Materials Studio软件</p></li><li><p>正格矢到倒格矢转化脚本，来源于小木虫(见<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">下面</i>链接)</p></li></ul><p><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">http</i>://muchong<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">.com</i>/bbs/viewthread.php?tid=7149817&fpage=1</p><pre><code>#! /usr/bin/python</code><code># This program reads in base vectors from a given file, calculates reciprocal vectors</code><code># then writes to outfile in different units</code><code># LinuxUsage: crecip.py infile outfile</code><code># Note: the infile must be in the form below:</code><code># inunit ang/bohr</code><code># _begin_vectors</code><code># 46.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">30</i>0000000 0.000000000 0.000000000</code><code># 0.000000000 40.500000000 0.000000000</code><code># 0.000000000 0.000000000 10.000000000</code><code># _end_vectors</code><code># </code><code># Note: LATTICE VECTORS ARE SPECIFIED IN ROWS !</code><code>def GetInUnit( incontent ):</code><code> inunit = ""</code><code> for line in incontent:</code><code> if line.find("inunit") == 0:</code><code> inunit = line.split[1]</code><code> break</code><code> return inunit</code><code>def GetVectors( incontent ):</code><code> indstart = 0</code><code> indend = 0</code><code> for s in incontent:</code><code> if s.find("_begin_vectors") != -1:</code><code> indstart = incontent.index(s)</code><code> else:</code><code> if s.find("_end_vectors") != -1:</code><code> indend = incontent.index(s)</code><code> result = </code><code> for i in range( indstart + 1, indend ):</code><code> line = incontent[i].split</code><code> result.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">app</i>end( [ float(line[0]), float(line[1]), float(line[2]) ] )</code><code> return result</code><code>def Ang2Bohr( LattVecAng ):</code><code> LattVecBohr = LattVecAng</code><code> for i in range(0,3):</code><code> for j in range(0,3):</code><code> LattVecBohr[i][j] = LattVecAng[i][j] * 1.8897261246</code><code> return LattVecBohr</code><code>def DotProduct( v1, v2 ):</code><code> dotproduct = 0.0</code><code> for i in range(0,3):</code><code> dotproduct = dotproduct + v1[i] * v2[i]</code><code> return dotproduct</code><code>def CrossProduct( v1, v2 ):</code><code> # v3 = v1 WILL LEAD TO WRONG RESULT</code><code> v3 = </code><code> v3.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">app</i>end( v1[1] * v2[2] - v1[2] * v2[1] )</code><code> v3.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">app</i>end( v1[2] * v2[0] - v1[0] * v2[2] )</code><code> v3.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">app</i>end( v1[0] * v2[1] - v1[1] * v2[0] )</code><code> return v3</code><code>def CalcRecVectors( lattvec ):</code><code> pi = 3.141592653589793</code><code> a1 = lattvec[0]</code><code> a2 = lattvec[1]</code><code> a3 = lattvec[2]</code><code> b1 = CrossProduct( a2, a3 )</code><code> b2 = CrossProduct( a3, a1 )</code><code> b3 = CrossProduct( a1, a2 )</code><code> volume = DotProduct( a1, CrossProduct( a2, a3 ) )</code><code> RecVec = [ b1, b2, b3 ]</code><code> # it follows the definition for b_j: a_i * b_j = 2pi * delta(i,j)</code><code> for i in range(0,3):</code><code> for j in range(0,3):</code><code> RecVec[i][j] = RecVec[i][j] * 2 * pi / volume</code><code> return RecVec </code><code>def main(argv = None): </code><code> argv = sys.argv</code><code> infilename = argv[1]</code><code> outfilename = argv[2] </code><code> pi = 3.141592653589793</code><code> bohr2ang = 0.5291772109253</code><code> ang2bohr = 1.889726124546 </code><code> infile = open(infilename,"r")</code><code> incontent = infile.readlines</code><code> infile.close </code><code> inunit = GetInUnit( incontent )</code><code> LattVectors = GetVectors( incontent )</code><code> # convert units from ang to bohr</code><code> if inunit == "ang":</code><code> LattVectors = Ang2Bohr( LattVectors ) </code><code> # calculate reciprocal vectors in 1/bohr</code><code> RecVectors = CalcRecVectors( LattVectors ) </code><code> # open outfile for output</code><code> ofile = open(outfilename,"w") </code><code> # output lattice vectors in bohr</code><code> ofile.write("lattice vectors in bohr:\n")</code><code> for vi in LattVectors:</code><code> ofile.write("%14.9f%14.9f%14.9f\n" % (vi[0], vi[1], vi[2]))</code><code> ofile.write("\n") </code><code> # output lattice vectors in ang</code><code> convfac = bohr2ang</code><code> ofile.write("lattice vectors in ang:\n")</code><code> for vi in LattVectors:</code><code> ofile.write("%14.9f%14.9f%14.9f\n" % (vi[0]*convfac, vi[1]*convfac, vi[2]*convfac))</code><code> ofile.write("\n") </code><code> # output reciprocal vectors in 1/bohr</code><code> ofile.write("reciprocal vectors in 1/bohr:\n")</code><code> for vi in RecVectors:</code><code> ofile.write("%14.9f%14.9f%14.9f\n" % (vi[0], vi[1], vi[2]))</code><code> ofile.write("\n") </code><code> # output reciprocal vectors in 1/ang</code><code> convfac = ang2bohr</code><code> ofile.write("reciprocal vectors in 1/ang:\n")</code><code> for vi in RecVectors:</code><code> ofile.write("%14.9f%14.9f%14.9f\n" % (vi[0]*convfac, vi[1]*convfac, vi[2]*convfac))</code><code> ofile.write("\n") </code><code> # output reciprocal vectors in 2pi/bohr</code><code> convfac = 1.0/(2.0*pi)</code><code> ofile.write("reciprocal vectors in 2pi/bohr:\n")</code><code> for vi in RecVectors:</code><code> ofile.write("%14.9f%14.9f%14.9f\n" % (vi[0]*convfac, vi[1]*convfac, vi[2]*convfac))</code><code> ofile.write("\n")</code><code> # output reciprocal vectors in 2pi/ang</code><code> convfac = ang2bohr/(2.0*pi)</code><code> ofile.write("reciprocal vectors in 2pi/ang:\n")</code><code> for vi in RecVectors:</code><code> ofile.write("%14.9f%14.9f%14.9f\n" % (vi[0]*convfac, vi[1]*convfac, vi[2]*convfac)) </code><code> # close</code><code> ofile.close </code><code> return 0</code><code>if __name__ == "__main__":</code><code> import sys</code><code> sys.exit(main)</code></pre><p><strong>4、二维InSe有效质量计算过程</strong></p><p><strong>4.1 建模</strong></p><p>由于计算过程中需要对二维InSe施加应变，但二维InSe原胞是六角结构，不容易施加应变。但是侯柱峰老师讲了对石墨烯原胞施加应变的方法，笔者认为虽然可行，但过于繁琐，故不采用此法。我们可以利用根号建模的方法讲六角结构InSe原胞变为方形结构的InSe超胞，然后施加应变可<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">大大</i>提高操作效率，但计算量的增加再可接受范围之内。<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">下面</i>给出关键的建模步骤，更多的根号建模部分可参考我的往期博客文章。</p><ul><li><p>切面并构建二维InSe原胞，同时调整晶格基矢，使其变为方形结构：</p></li></ul><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fW6jAkmkoCc><p><strong>4.2 结构优化</strong></p><p>INCAR</p><pre><code>SYSTEM = InSe </code><code>ISTART = 0 </code><code>NWRITE = 2 </code><code>PREC = Accurate</code><code>ENCUT = 500</code><code>GGA = PE </code><code>NSW = 200</code><code>ISIF = 3 </code><code>ISYM = 2 </code><code>IBRION = 2 </code><code>NELM = 80 </code><code>EDIFF = 1E-05 </code><code>EDIFFG = -0.01 </code><code>ALGO = Normal </code><code>LDIAG = .TRUE. </code><code>LREAL = .FALSE. </code><code>ISMEAR = 0 </code><code>SIGMA = 0.05 </code><code>ICHARG = 2</code><code>LWAVE = .FALSE. </code><code>LCHARG = .FALSE.</code><code>NPAR = 4</code></pre><p>KPOINTS</p><pre><code>Monkhorst Pack</code><code>0</code><code>Gamma</code><code>11 7 1</code><code>.0 .0 .0</code></pre><p>POSCAR</p><pre><code>Se In</code><code>1.000</code><code> 4.083622259999999 -0.000000000000001 0.000000000000000</code><code> 0.000000000000000 7.07<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">30</i>41233239241 0.000000000000000</code><code> 0.000000000000000 0.000000000000000 25.377516849029359</code><code>Se In</code><code>4 4</code><code>Direct</code><code>0.5000005000000000 0.1666665000000000 0.5271404971815050 !Se</code><code>0.0000004999999997 0.6666665000000004 0.5271404971815050 !Se</code><code>0.5000005000000000 0.1666665000000000 0.3152396685456632 !Se</code><code>0.0000004999999997 0.6666665000000004 0.3152396685456632 !Se</code><code>0.4999995000000003 0.8333335000000002 0.4767849697227853 !In</code><code>-0.0000005000000000 0.3333335000000000 0.4767849697227853 !In</code><code>0.4999995000000003 0.8333335000000002 0.3655951960043828 !In</code><code>-0.0000005000000000 0.3333335000000000 0.3655951960043828 !In</code></pre><p>OPTCELL</p><pre><code>100</code><code>010</code><code>000</code></pre><p>POTCAR</p><pre><code>cat Se/POTCAR In_d/POTCAR &gt; POTCAR</code></pre><p><strong>4.3 静态自洽</strong></p><p>INCAR</p><pre><code>SYSTEM = InSe </code><code>ISTART = 0 </code><code>NWRITE = 2 </code><code>PREC = Accurate</code><code>ENCUT = 500</code><code>GGA = PE </code><code>NSW = 0</code><code>ISIF = 2 </code><code>ISYM = 2 </code><code>IBRION = -1 </code><code>NELM = 80 </code><code>EDIFF = 1E-05 </code><code>EDIFFG = -0.01 </code><code>ALGO = Normal </code><code>LDIAG = .TRUE. </code><code>LREAL = .FALSE. </code><code>ISMEAR = 0 </code><code>SIGMA = 0.05 </code><code>ICHARG = 2</code><code>NPAR = 4</code></pre><p>KPOINTS</p><pre><code>Monkhorst Pack</code><code>0</code><code>Gamma</code><code>21 13 1</code><code>.0 .0 .0</code></pre><p>POSCAR</p><pre><code>cp CONTCAR scf/POSCAR</code></pre><p><strong>4.4 能带计算</strong></p><p>INCAR</p><pre><code>SYSTEM = InSe </code><code>ISTART = 1 </code><code>NWRITE = 2 </code><code>PREC = Accurate</code><code>ENCUT = 500</code><code>GGA = PE </code><code>NSW = 0</code><code>ISIF = 2 </code><code>ISYM = 2 </code><code>IBRION = -1 </code><code>NELM = 80 </code><code>EDIFF = 1E-05 </code><code>EDIFFG = -0.01 </code><code>ALGO = Normal </code><code>LDIAG = .TRUE. </code><code>LREAL = .FALSE. </code><code>ISMEAR = 0 </code><code>SIGMA = 0.05 </code><code>ICHARG = 2</code><code>LORBIT = 11</code><code>LWAVE = .FALSE. </code><code>LCHARG = .FALSE.</code><code>NPAR = 4</code></pre><p>KPOINTS</p><pre><code>k-points along high symmetry lines</code><code>80</code><code>Line-mode</code><code>Rec</code><code> 0 0.5 0 !Y</code><code> 0 0 0 !gamma</code><br><br><code> 0 0 0 !gamma</code><code> 0.5 0 0 !X</code><br><br><code> 0.5 0 0 !X</code><code> 0.5 0.5 0 !S</code><br><br><code> 0.5 0.5 0 !S</code><code> 0 0.5 0 !Y</code></pre><p><strong>4.5 有效质量计算(</strong>有效质量详细教程<strong>)</strong></p><p>计算说明：对于包含了晶格周期性的有效质量的表达式如下所示：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fW72AyoSHDv><p>在带入物理量进行有效质量计算时，涉及单位制问题。一般写输入文件时，长度单位为Å；而程序输出的能带结构中，能量单位为eV，计算起来比较繁琐。</p><p>原子单位制有两种，一种为Hartree原子单位制，另一种为Rydberg单位制。这两种单位制的区别在于，Hartree单位制下基本物理量简单，电子电荷和质量都为1；而Rydberg单位制下薛定谔方程简单，系数为1。Hartree单位制下，一个长度单位等于1Lbohr = 0.5292Å，一个能量单位1EHartree = 27.21eV，约化普朗克常数ℏ=1。这样有效质量表达式中的约化普朗克常数就没了。</p><ul><li><p><strong class=highlight-text toutiao-origin=span>根据原胞基矢和正倒格子基矢间对应关系，算出倒格子基矢：</strong></p></li></ul><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Rg1fW7CB1wXC0F><ul><li><p><strong class=highlight-text toutiao-origin=span>将VASP计算band时的k点座标(分数座标)转变为笛卡尔座标：</strong></p></li></ul><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fW7Q3gsuNuq><ul><li><p><strong class=highlight-text toutiao-origin=span>根据两点间的距离公式，计算出各K点之间的距离：</strong></p></li></ul><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fW7g8IRfy24><p><strong>4.6 求每个K点的位置值</strong></p><p>根据VASP计算能带时各高对称点间均匀撒点，求出每个点的位置值，第一个点设为0，本例中为80个点，在excel中进行操作。</p><p>因计算时均匀撒点80个，故有79个小间隔，对于|YΓ|来说，每个小间隔为0.002975210683544，故1-80个点的座标值都可算出，以此类推，后面的点的座标在前面点的基础上<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">加上</i>间隔即可(注意：在80个点结束处和81个点开始处的值是一样的，后面的点类似)。</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fWUb8zwWy4J><p><strong>4.7 画出价带顶和导带底的能带</strong></p><p>在origin中找出能带数据的价带顶(VBM)和导带底(CBM)的数据，把上面计算得到的K点路径做为X轴，VBM和CBM作为Y轴，在origin中画图如下：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fWUw5fyf6sc><p><strong>4.8 计算有效质量(以x方向电子的有效质量为例)</strong></p><p>首先换算能量单位，由eV换算为原子单位制下的能量CBM/27.21然后选取Γ-X方向上以Γ开始的4-8个点的数据画能带图，如下:</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fWVK7TvxioX><p>用y = a+bx+cx^2函数拟合，操作如下：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Rg1fWVjEcGUkUM><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fWW7bQs83p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fWva6ONnuLU><p>有效质量为1/2<em>C</em>，其中<em>C</em>=2.69188，算得有效质量为0.19 ，为电子沿<em>x</em>方向的质量。文献计算结果为0.19，符合一致。</p><p><strong>5、二维InSe载流子迁移率计算过程</strong></p><p>本文载流子迁移率的计算依据的是形变势理论，因此需要对二维InSe的<em>x</em>方向和<em>y</em>方向施加应变，施加应变的范围是-2%~2%。为了计算的准确性，计算过程中考虑了泊松效应，即对<em>x</em>轴施加应变时，固定<em>x</em>轴和<em>z</em>轴，优化<em>y</em>方向的晶格常数；对<em>y</em>轴施加应变时，固定<em>y</em>轴和<em>z</em>轴，优化<em>x</em>方向的晶格常数。</p><p><strong>5.1 准备输入文件</strong></p><p>首先建立mobility-x文件夹，然后在该文件夹下建立初始文件夹，命名为IS，其结构目录如下：</p><pre><code>$ tree mobility</code><code>mobility</code><code>├── IS</code><code>│ ├── 2_scf</code><code>│ │ ├── band</code><code>│ │ │ ├── INCAR</code><code>│ │ │ ├── KPOINTS</code><code>│ │ │ └── POTCAR</code><code>│ │ ├── INCAR</code><code>│ │ ├── KPOINTS</code><code>│ │ └── POTCAR</code><code>│ ├── INCAR</code><code>│ ├── KPOINTS</code><code>│ ├── OPTCELL</code><code>│ ├── pbs</code><code>│ ├── POSCAR</code><code>│ └── POTCAR</code><code>└── mobility.sh</code></pre><p><strong>说明：</strong></p><ul><li><p>pbs文件</p></li></ul><pre><code>#!/bin/bash</code><code>#PBS -N mobility</code><code>#PBS -l nodes=1:ppn=16</code><code>#PBS -m abe</code><code>#PBS -j n</code><code>##PBS -o job.log</code><code>##PBS -e job.err</code><code>#PBS -l walltime=120:00:00</code><code>cd $PBS_O_WORKDIR</code><code>date "+01 Today's date is: %D. The time execution %T" &gt;&gt; time.info</code><code>mpirun -np 16 /opt/soft/strainvasp5.4.4/vasp.5.4.4/build/std/vasp &gt; log</code><code>date "+02 Today's date is: %D. The time finish %T" &gt;&gt; time.info</code><code>cp ./CONTCAR ./2_scf/POSCAR</code><code>cd ./2_scf/</code><code>date "+01 Today's date is: %D. The time execution %T" &gt;&gt; time.info</code><code>mpirun /opt/soft/strainvasp5.4.4/vasp.5.4.4/build/std/vasp &gt; log</code><code>date "+02 Today's date is: %D. The time finish %T" &gt;&gt; time.info</code><code>cp ./CONTCAR ./band/POSCAR</code><code>cp ./WAVECAR ./band/</code><code>cd ./band/</code><code>date "+01 Today's date is: %D. The time execution %T" &gt;&gt; time.info</code><code>mpirun -np 16 /opt/soft/strainvasp5.4.4/vasp.5.4.4/build/std/vasp &gt; log</code><code>date "+02 Today's date is: %D. The time finish %T" &gt;&gt; time.info</code></pre><ul><li><p>OPTCELL文件</p></li></ul><p>X方向</p><pre><code>000</code><code>010</code><code>000</code></pre><p>Y方向</p><pre><code>100</code><code>000</code><code>000</code></pre><ul><li><p>自洽计算时INCAR文件中加入计算真空能级的命令</p></li></ul><pre><code>LVHAR = .TRUE.</code></pre><ul><li><p>mobility.sh文件</p></li></ul><pre><code>#!/bin/bash</code><code>#3 November, 2018</code><code>#To use it: bash mobility.sh</code><code>mkdir mobility-x</code><code>cd mobility-x</code><code>x=4.083622259999999 #"x" stands for the lattice constant in x direction</code><code>for i in $(seq 0.98 0.005 1.02) #"i" defines the range of strain</code><code>do</code><code>cp -r ../IS ./$i #"IS" stands for the origin file </code><code>sed -i "3s/$x/$(echo "$x*$i"|bc)/g" $i/POSCAR</code><code>cd $i</code><code>#qsub ./pbs</code><code>cd $OLDPWD</code><code>done</code><code>cd ../</code><code>mkdir mobility-y</code><code>cd mobility-y</code><code>y=7.07<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">30</i>41233239241 #"y" stands for the lattice constant in y direction</code><code>for j in $(seq 0.98 0.005 1.02) #"j" defines the range of strain</code><code>do</code><code>cp -r ../IS ./$j #"IS" stands for the origin file </code><code>sed -i "4s/$y/$(echo "$y*$j"|bc)/g" $j/POSCAR</code><code>cd $j</code><code>#qsub ./pbs</code><code>cd $OLDPWD</code><code>done</code></pre><p>Note：计算过程中需要根据自己的体系修改<em>x</em>和<em>y</em>方向的晶格常数值</p><p>其余文件与前面计算能带过程的输入文件相同，在mobility文件夹下输入bash mobility.sh文件即可完成全部计算。</p><p>6、数据处理(以<em>x</em>方向为例)</p><p>6.1 计算形变势常数<em>E</em>1</p><ul><li><p>以真空能级为参考，确定VBM和CBM的位置。思路是读取能带计算结果中的最高占据态VBM和最低非占据态CBM(未扣除费米能级)的结果，然后减去真空能级就可得到我们需要的结果。</p></li><li><p>对得到的数据以应变量为<em>x</em>轴(-0.02~0.02)，VBM和CBM为<em>y</em>轴画图，然后在origin中做线性拟合，即可得到形变势常数，最终结果如下：</p></li></ul><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fWvs8eXyypF><p>6.2 计算弹性模量<em>C</em>2D(以<em>x</em>方向为例)</p><ul><li><p>读取每个应变下的体系总能量，然后画图。</p></li><li><p>对其做二次函数拟合，然后带入<em>C</em>2D的计算公式，并对单位做换算后，得到的结果如下：</p></li></ul><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fWw32mEHkFH><p><strong>6.3 计算迁移率</strong></p><p>现已得到有效质量、形变势常数和弹性模量，依据载流子迁移率计算公式，并注意单位换算，即可得到载流子的迁移率具体数值。计算结果可参考我的JPCC文章(<em>J. Phys. Chem. C</em>2019, 123, 20, 12781-12790)，如下(点击放大看)：</p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Rg1fWwF3iSUkoR><p><strong>7、后记</strong></p><p>因时间关系，本文写作比较仓促，文中一些数据处理的细节没有详细给出，并且可能存在一些小的错误，欢迎大家阅读过程中积极指出，以便在后续更正过程中改正。另外，本文公式较多，但mathjax环境对公式编辑不是很友好，排版过程中公式很容易乱，故而部分公式以插图的形式放入了本文中，看起来版面搅乱，后续会想办法处理。</p><p>参考文献：</p><p>[1] Bardeen J, Shockley W. Deformation Potentials and Mobilities in Non-Polar Crystals[J]. Physical Review, 2008, 801:72-80.</p><p><strong>本文转载于贺勇个人博客，请大家多多<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-6">关注</i>他！</strong></p><p><strong>链接: </strong>https://yh-phys.github.io</p><p><strong>8、补充：三维材料迁移率计算(欢迎<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">留言</i>讨论)</strong></p><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rg1fWwUFLDLQAu><img alt=VASP计算二维材料的载流子迁移率 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rg1fXTa9TFICr1><p><strong>9、友情链接：</strong></p><p><strong class=highlight-text toutiao-origin=span>(1) 人大迁移率计算软件包(ReMoC)</strong></p><p>https://gitee<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">.com</i>/jigroupruc</p><p><strong class=highlight-text toutiao-origin=span>(2) The Calculation of Carrier Mobility for 2D Materials</strong></p><p><strong class=highlight-text toutiao-origin=span>https://chempeng.github.io/2017/09/01/The-Calculation-of-Carrier-Mobility/</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'VASP','计算二维','流子'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>