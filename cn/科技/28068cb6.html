<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>手把手教你 Netty 实现自定义协议 | 极客快訊</title><meta property="og:title" content="手把手教你 Netty 实现自定义协议 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/35a65c1e6e4b489d9b87fd6e169e8b66"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><meta property="article:published_time" content="2020-11-14T21:04:17+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:17+08:00"><meta name=Keywords content><meta name=description content="手把手教你 Netty 实现自定义协议"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/28068cb6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>手把手教你 Netty 实现自定义协议</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>点击上方 "程序员小乐"关注, 星标或置顶一起成长</p><p>每天凌晨00点00分, 第一时间与你相约</p><p><br></p><p>每日英文</p><p>It's so hard to tell someone how you really feel about them when you're too afraid of losing what you already have.</p><p>有时候，要坦白对某个人的感觉真的太难了，因为太害怕连现在这种关系都失去。</p><p><br></p><p>每日掏心话</p><p>我们不要去做一个单纯优秀的人，而是要去做一个不可替代的人。</p><p>来自：爱宝贝丶 | 责编：乐乐<br></p><p>链接：my.oschina.net/zhangxufeng/blog/3043768</p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt="手把手教你 Netty 实现自定义协议" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/35a65c1e6e4b489d9b87fd6e169e8b66></div></div></p><p>程序员小乐(ID:study_tech)第 829 次推文 图片来自百度</p><p><br></p><p>往日回顾：“微信遗嘱”功能开通，网友体验后发现...如果突然离世，你的QQ、支付宝等怎么办？</p><p><br></p><p>正文</p><p><br><br></p><p>关于协议，使用最为广泛的是HTTP协议，但是在一些服务交互领域，其使用则相对较少，主要原因有三方面：</p><p><br></p><ul class=list-paddingleft-2><li><p>HTTP协议会携带诸如header和cookie等信息，其本身对字节的利用率也较低，这使得HTTP协议比较臃肿，在承载相同信息的情况下，HTTP协议将需要发送更多的数据包；</p></li><li><p>HTTP协议是基于TCP的短连接，其在每次请求和响应的时候都需要进行三次握手和四次挥手，由于服务的交互设计一般都要求能够承载高并发的请求，因而HTTP协议这种频繁的握手和挥手动作会极大的影响服务之间交互的效率；</p></li><li><p>服务之间往往有一些根据其自身业务特性所独有的需求，而HTTP协议无法很好的服务于这些业务需求。</p></li></ul><p><br></p><p>基于上面的原因，一般的服务之间进行交互时都会使用自定义协议，常见的框架，诸如dubbo，kafka，zookeeper都实现了符合其自身业务需求的协议，本文主要讲解如何使用Netty实现一款自定义的协议。</p><p><br></p><p>1. 协议规定</p><p>所谓协议，其本质其实就是定义了一个将数据转换为字节，或者将字节转换为数据的一个规范。一款自定义协议，其一般包含两个部分：消息头和消息体。消息头的长度一般是固定的，或者说是可确定的，其定义了此次消息的一些公有信息，比如当前服务的版本，消息的sessionId，消息的类型等等；消息体则主要是此次消息所需要发送的内容，一般在消息头的最后一定的字节中保存了当前消息的消息体的长度。下面是我们为当前自定义协议所做的一些规定：</p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt="手把手教你 Netty 实现自定义协议" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e8c4ecfeb9842d9a4fa960360f7ae3b></div></div></p><p></p><p>上述协议定义中，我们除了定义常用的请求和响应消息类型以外，还定义了Ping和Pong消息。Ping和Pong消息的作用一般是，在服务处于闲置状态达到一定时长，比如2s时，客户端服务会向服务端发送一个Ping消息，则会返回一个Pong消息，这样才表示客户端与服务端的连接是完好的。如果服务端没有返回相应的消息，客户端就会关闭与服务端的连接或者是重新建立与服务端的连接。这样的优点在于可以防止突然会产生的客户端与服务端的大量交互。</p><p><br></p><p>2. 协议实现</p><p>通过上面的定义其实我们可以发现，所谓协议，就是定义了一个规范，基于这个规范，我们可以将消息转换为相应的字节流，然后经由TCP传输到目标服务，目标服务则也基于该规范将字节流转换为相应的消息，这样就达到了相互交流的目的。这里面最重要的主要是如何基于该规范将消息转换为字节流或者将字节流转换为消息。这一方面，Netty为我们提供了ByteToMessageDecoder和MessageToByteEncoder用于进行消息和字节流的相互转换。首先我们定义了如下消息实体：</p><p>public class Message {<br>private int magicNumber;<br>private byte mainVersion;<br>private byte subVersion;<br>private byte modifyVersion;<br>private String sessionId;<br><br>private MessageTypeEnum messageType;<br>private Map&lt;String, String> attachments = new HashMap&lt;>();<br>private String body;<br><br>public Map&lt;String, String> getAttachments() {<br>return Collections.unmodifiableMap(attachments);<br>}<br><br>public void setAttachments(Map&lt;String, String> attachments) {<br>this.attachments.clear();<br>if (null != attachments) {<br>this.attachments.putAll(attachments);<br>}<br>}<br><br>public void addAttachment(String key, String value) {<br>attachments.put(key, value);<br>}<br><br>// getter and setter...<br>}<br></p><p>上述消息中，我们将协议中所规定的各个字段都进行了定义，并且定义了一个标志消息类型的枚举MessageTypeEnum，如下是该枚举的源码：</p><p>public enum MessageTypeEnum {<br>REQUEST((byte)1), RESPONSE((byte)2), PING((byte)3), PONG((byte)4), EMPTY((byte)5);<br><br>private byte type;<br><br>MessageTypeEnum(byte type) {<br>this.type = type;<br>}<br><br>public int getType() {<br>return type;<br>}<br><br>public static MessageTypeEnum get(byte type) {<br>for (MessageTypeEnum value : values()) {<br>if (value.type == type) {<br>return value;<br>}<br>}<br><br>throw new RuntimeException("unsupported type: " + type);<br>}<br>}<br></p><p>上述主要是定义了描述自定义协议相关的实体属性，对于消息的编码，本质就是依据上述协议方式将消息实体转换为字节流，如下是转换字节流的代码：</p><p>public class MessageEncoder extends MessageToByteEncoder&lt;Message> {<br><br>@Override<br>protected void encode(ChannelHandlerContext ctx, Message message, ByteBuf out) {<br>// 这里会判断消息类型是不是EMPTY类型，如果是EMPTY类型，则表示当前消息不需要写入到管道中<br>if (message.getMessageType() != MessageTypeEnum.EMPTY) {<br>out.writeInt(Constants.MAGIC_NUMBER); // 写入当前的魔数<br>out.writeByte(Constants.MAIN_VERSION); // 写入当前的主版本号<br>out.writeByte(Constants.SUB_VERSION); // 写入当前的次版本号<br>out.writeByte(Constants.MODIFY_VERSION); // 写入当前的修订版本号<br>if (!StringUtils.hasText(message.getSessionId())) {<br>// 生成一个sessionId，并将其写入到字节序列中<br>String sessionId = SessionIdGenerator.generate();<br>message.setSessionId(sessionId);<br>out.writeCharSequence(sessionId, Charset.defaultCharset());<br>}<br><br>out.writeByte(message.getMessageType().getType()); // 写入当前消息的类型<br>out.writeShort(message.getAttachments().size()); // 写入当前消息的附加参数数量<br>message.getAttachments().forEach((key, value) -> {<br>Charset charset = Charset.defaultCharset();<br>out.writeInt(key.length()); // 写入键的长度<br>out.writeCharSequence(key, charset); // 写入键数据<br>out.writeInt(value.length()); // 希尔值的长度<br>out.writeCharSequence(value, charset); // 写入值数据<br>});<br><br>if (null == message.getBody()) {<br>out.writeInt(0); // 如果消息体为空，则写入0，表示消息体长度为0<br>} else {<br>out.writeInt(message.getBody().length());<br>out.writeCharSequence(message.getBody(), Charset.defaultCharset());<br>}<br>}<br>}<br>}<br></p><p>对于消息的解码，其过程与上面的消息编码方式基本一致，主要是基于协议所规定的将字节流数据转换为消息实体数据。如下是其转换过程：</p><p>public class MessageDecoder extends ByteToMessageDecoder {<br><br>@Override<br>protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object> out) throws Exception {<br>Message message = new Message();<br>message.setMagicNumber(byteBuf.readInt()); // 读取魔数<br>message.setMainVersion(byteBuf.readByte()); // 读取主版本号<br>message.setSubVersion(byteBuf.readByte()); // 读取次版本号<br>message.setModifyVersion(byteBuf.readByte()); // 读取修订版本号<br>CharSequence sessionId = byteBuf.readCharSequence(<br>Constants.SESSION_ID_LENGTH, Charset.defaultCharset()); // 读取sessionId<br>message.setSessionId((String)sessionId);<br><br>message.setMessageType(MessageTypeEnum.get(byteBuf.readByte())); // 读取当前的消息类型<br>short attachmentSize = byteBuf.readShort(); // 读取附件长度<br>for (short i = 0; i &lt; attachmentSize; i++) {<br>int keyLength = byteBuf.readInt(); // 读取键长度和数据<br>CharSequence key = byteBuf.readCharSequence(keyLength, Charset.defaultCharset());<br>int valueLength = byteBuf.readInt(); // 读取值长度和数据<br>CharSequence value = byteBuf.readCharSequence(valueLength, Charset.defaultCharset());<br>message.addAttachment(key.toString(), value.toString());<br>}<br><br>int bodyLength = byteBuf.readInt(); // 读取消息体长度和数据<br>CharSequence body = byteBuf.readCharSequence(bodyLength, Charset.defaultCharset());<br>message.setBody(body.toString());<br>out.add(message);<br>}<br>}<br></p><p>如此，我们自定义消息与字节流的相互转换工作已经完成。对于消息的处理，主要是要根据消息的不同类型，对消息进行相应的处理，比如对于request类型消息，要写入响应数据，对于ping消息，要写入pong消息作为回应。下面我们通过定义Netty handler的方式实现对消息的处理：</p><p>// 服务端消息处理器<br>public class ServerMessageHandler extends SimpleChannelInboundHandler&lt;Message> {<br><br>// 获取一个消息处理器工厂类实例<br>private MessageResolverFactory resolverFactory = MessageResolverFactory.getInstance();<br><br>@Override<br>protected void channelRead0(ChannelHandlerContext ctx, Message message) throws Exception {<br>Resolver resolver = resolverFactory.getMessageResolver(message); // 获取消息处理器<br>Message result = resolver.resolve(message); // 对消息进行处理并获取响应数据<br>ctx.writeAndFlush(result); // 将响应数据写入到处理器中<br>}<br><br>@Override<br>public void channelRegistered(ChannelHandlerContext ctx) throws Exception {<br>resolverFactory.registerResolver(new RequestMessageResolver()); // 注册request消息处理器<br>resolverFactory.registerResolver(new ResponseMessageResolver());// 注册response消息处理器<br>resolverFactory.registerResolver(new PingMessageResolver()); // 注册ping消息处理器<br>resolverFactory.registerResolver(new PongMessageResolver()); // 注册pong消息处理器<br>}<br>}<br>// 客户端消息处理器<br>public class ClientMessageHandler extends ServerMessageHandler {<br><br>// 创建一个线程，模拟用户发送消息<br>private ExecutorService executor = Executors.newSingleThreadExecutor();<br><br>@Override<br>public void channelActive(ChannelHandlerContext ctx) throws Exception {<br>// 对于客户端，在建立连接之后，在一个独立线程中模拟用户发送数据给服务端<br>executor.execute(new MessageSender(ctx));<br>}<br><br>/**<br>* 这里userEventTriggered()主要是在一些用户事件触发时被调用，这里我们定义的事件是进行心跳检测的<br>* ping和pong消息，当前触发器会在指定的触发器指定的时间返回内如果客户端没有被读取消息或者没有写入<br>* 消息到管道，则会触发当前方法<br>*/<br>@Override<br>public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {<br>if (evt instanceof IdleStateEvent) {<br>IdleStateEvent event = (IdleStateEvent) evt;<br>if (event.state() == IdleState.READER_IDLE) {<br>// 一定时间内，当前服务没有发生读取事件，也即没有消息发送到当前服务来时，<br>// 其会发送一个Ping消息到服务器，以等待其响应Pong消息<br>Message message = new Message();<br>message.setMessageType(MessageTypeEnum.PING);<br>ctx.writeAndFlush(message);<br>} else if (event.state() == IdleState.WRITER_IDLE) {<br>// 如果当前服务在指定时间内没有写入消息到管道，则关闭当前管道<br>ctx.close();<br>}<br>}<br>}<br><br>private static final class MessageSender implements Runnable {<br><br>private static final AtomicLong counter = new AtomicLong(1);<br>private volatile ChannelHandlerContext ctx;<br><br>public MessageSender(ChannelHandlerContext ctx) {<br>this.ctx = ctx;<br>}<br><br>@Override<br>public void run() {<br>try {<br>while (true) {<br>// 模拟随机发送消息的过程<br>TimeUnit.SECONDS.sleep(new Random().nextInt(3));<br>Message message = new Message();<br>message.setMessageType(MessageTypeEnum.REQUEST);<br>message.setBody("this is my " + counter.getAndIncrement() + " message.");<br>message.addAttachment("name", "xufeng");<br>ctx.writeAndFlush(message);<br>}<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>}<br></p><p>上述代码中，由于客户端和服务端需要处理的消息类型是完全一样的，因而客户端处理类继承了服务端处理类。但是对于客户端而言，其还需要定时向服务端发送心跳消息，用于检测客户端与服务器的连接是否健在，因而客户端还会实现userEventTriggered()方法，在该方法中定时向服务器发送心跳消息。userEventTriggered()方法主要是在客户端被闲置一定时间后，其会根据其读取或者写入消息的限制时长来选择性的触发读取或写入事件。</p><p>上述实现中，我们看到，对于具体类型消息的处理，我们是通过一个工厂类来获取对应的消息处理器，然后处理相应的消息，下面我们该工厂类的代码：</p><p>public final class MessageResolverFactory {<br><br>// 创建一个工厂类实例<br>private static final MessageResolverFactory resolverFactory = new MessageResolverFactory();<br>private static final List&lt;Resolver> resolvers = new CopyOnWriteArrayList&lt;>();<br><br>private MessageResolverFactory() {}<br><br>// 使用单例模式实例化当前工厂类实例<br>public static MessageResolverFactory getInstance() {<br>return resolverFactory;<br>}<br><br>public void registerResolver(Resolver resolver) {<br>resolvers.add(resolver);<br>}<br><br>// 根据解码后的消息，在工厂类处理器中查找可以处理当前消息的处理器<br>public Resolver getMessageResolver(Message message) {<br>for (Resolver resolver : resolvers) {<br>if (resolver.support(message)) {<br>return resolver;<br>}<br>}<br><br>throw new RuntimeException("cannot find resolver, message type: " + message.getMessageType());<br>}<br><br>}<br></p><p>上述工厂类比较简单，主要就是通过单例模式获取一个工厂类实例，然后提供一个根据具体消息来查找其对应的处理器的方法。下面我们来看看各个消息处理器的代码：</p><p>// request类型的消息<br>public class RequestMessageResolver implements Resolver {<br><br>private static final AtomicInteger counter = new AtomicInteger(1);<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.REQUEST;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到request消息之后，对消息进行处理，这里主要是将其打印出来<br>int index = counter.getAndIncrement();<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". receive request: " + message.getBody());<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". attachments: " + message.getAttachments());<br><br>// 处理完成后，生成一个响应消息返回<br>Message response = new Message();<br>response.setMessageType(MessageTypeEnum.RESPONSE);<br>response.setBody("nice to meet you too!");<br>response.addAttachment("name", "xufeng");<br>response.addAttachment("hometown", "wuhan");<br>return response;<br>}<br>}<br>// 响应消息处理器<br>public class ResponseMessageResolver implements Resolver {<br><br>private static final AtomicInteger counter = new AtomicInteger(1);<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.RESPONSE;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到对方服务的响应消息之后，对响应消息进行处理，这里主要是将其打印出来<br>int index = counter.getAndIncrement();<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". receive response: " + message.getBody());<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". attachments: " + message.getAttachments());<br><br>// 响应消息不需要向对方服务再发送响应，因而这里写入一个空消息<br>Message empty = new Message();<br>empty.setMessageType(MessageTypeEnum.EMPTY);<br>return empty;<br>}<br>}<br>// ping消息处理器<br>public class PingMessageResolver implements Resolver {<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.PING;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到ping消息后，返回一个pong消息返回<br>System.out.println("receive ping message: " + System.currentTimeMillis());<br>Message pong = new Message();<br>pong.setMessageType(MessageTypeEnum.PONG);<br>return pong;<br>}<br>}<br>// pong消息处理器<br>public class PongMessageResolver implements Resolver {<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.PONG;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到pong消息后，不需要进行处理，直接返回一个空的message<br>System.out.println("receive pong message: " + System.currentTimeMillis());<br>Message empty = new Message();<br>empty.setMessageType(MessageTypeEnum.EMPTY);<br>return empty;<br>}<br>}<br></p><p>如此，对于自定义协议的消息处理过程已经完成，下面则是使用用Netty实现的客户端与服务端代码：</p><p>// 服务端<br>public class Server {<br><br>public static void main(String[] args) {<br>EventLoopGroup bossGroup = new NioEventLoopGroup();<br>EventLoopGroup workerGroup = new NioEventLoopGroup();<br>try {<br>ServerBootstrap bootstrap = new ServerBootstrap();<br>bootstrap.group(bossGroup, workerGroup)<br>.channel(NioServerSocketChannel.class)<br>.option(ChannelOption.SO_BACKLOG, 1024)<br>.handler(new LoggingHandler(LogLevel.INFO))<br>.childHandler(new ChannelInitializer&lt;SocketChannel>() {<br>@Override<br>protected void initChannel(SocketChannel ch) throws Exception {<br>ChannelPipeline pipeline = ch.pipeline();<br>// 添加用于处理粘包和拆包问题的处理器<br>pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));<br>pipeline.addLast(new LengthFieldPrepender(4));<br>// 添加自定义协议消息的编码和解码处理器<br>pipeline.addLast(new MessageEncoder());<br>pipeline.addLast(new MessageDecoder());<br>// 添加具体的消息处理器<br>pipeline.addLast(new ServerMessageHandler());<br>}<br>});<br><br>ChannelFuture future = bootstrap.bind(8585).sync();<br>future.channel().closeFuture().sync();<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>} finally {<br>bossGroup.shutdownGracefully();<br>workerGroup.shutdownGracefully();<br>}<br>}<br>}<br>public class Client {<br>public static void main(String[] args) {<br>NioEventLoopGroup group = new NioEventLoopGroup();<br>Bootstrap bootstrap = new Bootstrap();<br>try {<br>bootstrap.group(group)<br>.channel(NioSocketChannel.class)<br>.option(ChannelOption.TCP_NODELAY, Boolean.TRUE)<br>.handler(new ChannelInitializer&lt;SocketChannel>() {<br>@Override<br>protected void initChannel(SocketChannel ch) throws Exception {<br>ChannelPipeline pipeline = ch.pipeline();<br>// 添加用于解决粘包和拆包问题的处理器<br>pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));<br>pipeline.addLast(new LengthFieldPrepender(4));<br>// 添加用于进行心跳检测的处理器<br>pipeline.addLast(new IdleStateHandler(1, 2, 0));<br>// 添加用于根据自定义协议将消息与字节流进行相互转换的处理器<br>pipeline.addLast(new MessageEncoder());<br>pipeline.addLast(new MessageDecoder());<br>// 添加客户端消息处理器<br>pipeline.addLast(new ClientMessageHandler());<br>}<br>});<br><br>ChannelFuture future = bootstrap.connect("127.0.0.1", 8585).sync();<br>future.channel().closeFuture().sync();<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>} finally {<br>group.shutdownGracefully();<br>}<br>}<br>}<br></p><p>运行上述代码之后，我们可以看到客户端和服务器分别打印了如下数据：</p><p>// 客户端<br>receive pong message: 1555123429356<br>[trx: d05024d2]1. receive response: nice to meet you too!<br>[trx: d05024d2]1. attachments: {hometown=wuhan, name=xufeng}<br>[trx: 66ee1438]2. receive response: nice to meet you too!<br>// 服务器<br>receive ping message: 1555123432279<br>[trx: f582444f]4. receive request: this is my 4 message.<br>[trx: f582444f]4. attachments: {name=xufeng}<br></p><p><br></p><p>3. 小结</p><p>本文首先将自定义协议与HTTP协议进行了对比，阐述了自定义协议的一些优点。然后定义了一份自定义协议，并且讲解了协议中各个字节的含义。最后通过Netty对自定义协议进行了实现，并且实现了基于自定义协议的心跳功能。</p><p><br></p><p>欢迎在留言区留下你的观点，一起讨论提高。如果今天的文章让你有新的启发，学习能力的提升上有新的认识，欢迎转发分享给更多人。</p><p><br></p><p>猜你还想看</p><p><br></p><p>阿里、腾讯、百度、华为、京东最新面试题汇集</p><p>Java之异常处理，看这篇就对了！<br></p><p>一个简单的例子带你理解HashMap<br></p><p>【整理】Spring 常用注解！千万不要错过！<br><br></p><p>关注订阅号「程序员小乐」，收看更多精彩内容<br>嘿，你在看吗？</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Netty','实现','义协议'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>