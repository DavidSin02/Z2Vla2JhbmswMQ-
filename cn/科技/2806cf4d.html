<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 | 极客快訊</title><meta property="og:title" content="嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2806cf4d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2806cf4d.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2806cf4d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>所有学嵌入式Linux系统的看过来了，以下内容是每一位想学习Linux嵌入式系统想要了解的内容，真的很想要分享给大家！</p><p>本文分享的内容主要如下几个方面：</p><p><strong>3.1 并发的原理</strong></p><p><strong>3.1.1 一个简单的例子</strong></p><p><strong>3.1.2 竞争条件</strong></p><p><strong>3.1.3 操作系统关注的问题</strong></p><p><strong>3.1.4 进程的交互</strong></p><p><strong>3.1.5 互斥的要求</strong></p><p><strong>3.2 信号量原理</strong></p><p><strong>3.2.1 互斥</strong></p><p><strong>3.3 生产者／消费者问题</strong></p><p><strong>3.4 读者-写者问题</strong></p><p><strong>3.3.1 读进程具有优先权</strong></p><p><strong>3.3.2 写进程具有优先权</strong></p><p><br></p><p>本章首先介绍并发的概念和多个并发进程的执行。我们发现，支持并发进程的基本需求是加强互斥的能力。也就是说，当一个进程被授予互斥的能力时，那么在其活动期间，它具有排斥所有其他进程的能。</p><p>本章通过两个经典的并发问题来说明并发的概念，并对本书中使用的各种方法进行比较。在本章开始</p><p>将介绍一个可运行的例子——生产者/消费者问题，读者-写者问题。</p><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.1 并发的原理</strong></p><p>在单处理器多道程序设计系统中，进程被交替执行，表现出一种并发执行的外部特征。即使不能实现真正的并行处理，并且即使在进程间来回切换需要一定的开销，交替执行在处理效率和程序构造上还是带来了重要的好处。</p><p>在单处理器的情况下，问题源于多道程序设计系统的一个基本特性：进程的相对执行速度不可预测，</p><p>它取决于其他进程的活动、操作系统处理中断的方式以及操作系统的调度策略。这就带来了下列困难：</p><p><strong> 全局资源的共享充满了危险</strong>。例如，如果两个进程都使用同一个全局变量，并且都对该变量执行读</p><p>写操作，那么不同的读写执行顺序是非常关键的。关于这个问题的例子将在下一小节中给出。</p><p><strong> 操作系统很难对分配资源进行最优化的管理</strong>。例如，进程 A 可能请求使用一个特定的 I/O 通道，并</p><p>获得控制权，但它在使用这个通道前被挂起了，操作系统仍然锁定这个通道，以防止其他进程使用，</p><p>这是难以令人满意的。此外，这还会导致死锁。</p><p><strong> 定位程序设计错误是非常困难的</strong>。这是因为结果通常是不确定的和不可再现的。</p><p>上述所有困难在多处理器系统中都有具体的表现，因为在这样的系统中进程执行的相对速度也是不可</p><p>预测的。一个多处理器系统还必须处理多个进程同时执行所引发的问题，从根本上来说，这些问题和单处</p><p>理器系统中的是相同的。这些问题随着讨论的深入将逐渐明了。</p><p><strong>3.1.1 一个简单的例子</strong></p><p>考虑下面的过程：</p><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d751bedf09641fea807277452262333><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7ab450c4c1b421fb555e4ed79a5e0d3><p class=pgc-img-caption></p></div><p>为理解如何解决与执行速度无关的问题，我们首先需要考虑进程间的交互方式。</p><p><strong>3.1.4 进程的交互</strong>．</p><p><strong>1 、进程中的资源争用</strong></p><p>当并发进程竞争使用同一个资源时，它们互相之间会发生冲突。我们可以把这种情况简单描述如下：</p><p>两个或更多的进程在它们的执行过程中需要访问一个资源，每个进程并不知道其他进程的存在，并且每个进程也不受其他进程的执行的影响。每个进程都不影响它所使用的资源的状态，这类资源包括 I/O 设备、存储器、处理器时间和时钟。</p><p>竞争进程间没有任何信息交换，但是一个进程的执行可能会影响到竞争进程的行为。特别是如果两个进程都期望访问同一个资源，操作系统把这个资源分配给一个进程，另一个就必须等待。因此，被拒绝访</p><p>问的进程速度就会变慢。一种极端情况是，被阻塞的进程永远不能访问这个资源，因此一直不能成功地终止。</p><p>竞争进程面临三个控制问题。首先是互斥的要求。假设两个或更多的进程需要访问一个不可共享的资</p><p>源，如打印机。在执行过程中，每个进程都给该 I/O 设备发命令，接收状态信息，发送数据和接收数据。</p><p>我们把这类资源称为临界资源，使用临界资源的那一部分代码称为程序的临界区。一次只允许有一个程序在临界区中，这一点是非常重要的。由于不清楚详细要求，我们不能仅仅依靠操作系统来理解和增强这个限制。例如在打印机的例子中，我们希望任何一个进程在打印整个文件时都拥有打印机的控制权，否则在打印结果中就会穿插着来自竞争资源的打印内容。</p><p>实施互斥产生了两个额外的控制问题。一个是 死锁。例如，考虑两个进程 Pl 和 P2，以及两个资源 Rl</p><p>和 R2，假设每个进程为执行部分功能都需要访问这两个资源，那么就有可能出现下列情况：操作系统把 Rl分配给 P2，把 R2 分配给 Pl，每个进程都在等待另一个资源，并且在获得其他资源并完成需要这两个资源的功能之前，谁都不会释放自己已经拥有的资源。这样，<strong>这两个进程就发生了死锁</strong>。</p><p><strong>另一个控制问题是 饥饿</strong>。假设有三个进程(P1、P2 和 P3)，每个进程都周期性地访问资源 R。考虑这种情况，Pl 拥有资源，P2 和 P3 都被延迟，等待这个资源。当 Pl 退出临界区时，P2 和 P3 都允许访问 R。假设操作系统把访问权授予 P3，并且在 P3 完成临界区之前 PI 又需要访问该临界区，如果在 P3 结束后操作系统又把访问权授予 Pl，并且接下来把访问权轮流授予 Pl 和 P3，那么即使没有死锁，P2 也可能无限期地被拒绝访问资源。</p><p>由于操作系统负责分配资源，竞争的控制不可避免地涉及到操作系统。此外，进程自身需要能够以某</p><p>种方式<strong>表达互斥</strong>的要求，如在使用资源前锁定资源，但任何一种解决方案都涉及到操作系统的某些支持，如提供锁机制。图 3．2 用抽象术语给出了互斥机制。假设有 n 个进程并发执行，每个进程包括(1)在某些资源 Ra 上操作的临界区，(2)不涉及访问资源 Ra 的额外代码。因为所有的进程都需要访问同一资源 Ra，因此保证在同一时刻只有一个进程在临界区是很重要的。为实现互斥，需要两个函数：entercritical 和exitcritical。每个函数的参数都是竞争使用的资源名，如果另外一个进程在临界区中，那么任何试图进入关于同一个资源的临界区的讲程都必须等待。</p><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/381fedbf4bb44152b8ceb99d0735ead3><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/37657c09b8534db89ea6d952f5fd7c6d><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f2be107a39dc4176814ecd0e27d9899a><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aa034028bb214bd8ad2dca81a95912fd><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ce09b92f9208463e8c52bbaaa5f5daf6><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ac9b17b632043c29e177b782c2a697f><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5fd453af09ce40398edbb810db02eaa7><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/250dcd0795914ae48e3f01faffb59eb7><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f0db36fb035c4694b41c6ae57b6456a6><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/671d2b66d6554e36a5ac8de79f09d242><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5af87aef4d4b485cb74aed6a3509b9e1><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d53675c631ed45f59e5d3a59121a8f1c><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74768c86a1274e30ac1fab79b3114b7c><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e96a050d9c44232b58e33001db890f2><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=嵌入式Linux编程——程序员小白不懂的进程、信号量、并发、互斥 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2a40455678274c27a03e7a482d400913><p class=pgc-img-caption></p></div><p><br></p><p><strong>本章总结</strong></p><p><strong class=highlight-text>现代操作系统的中心方案是多道程序设计、多处理和分布式处理，这些方案的基础以及操作系统设计</strong></p><p><strong class=highlight-text>技术的基础是并发。当多个进程并发执行时，不论是在多处理器系统的情况下，还是在单处理器多道程序系统中，都会产生解决冲突和合作的问题。</strong></p><p><strong class=highlight-text>并发进程可以按多种方式进行交互。互相之间不知道对方的进程可能需要竞争使用资源，如处理器时</strong></p><p><strong class=highlight-text>间或对 I／O 设备的访问。进程间由于共享访问一个公共对象，如主存中的一块空间或一个文件，可能间接知道对方，这类交互中产生的重要问题是互斥和死锁。</strong></p><p><strong class=highlight-text>互斥是指，对一组并发进程，一次只有一个进程能够访问一个给定的资源或执行一个给定的功能。互</strong></p><p><strong class=highlight-text>斥技术可以用于解决诸如资源争用之类的冲突，还可以用于进程间的同步，使得它们可以合作。后一种情况的一个例子是生产者／消费者模型，一个进程往缓冲区中放数据，另一个或更多的进程从缓冲区中取数据。</strong></p><p><strong class=highlight-text>支持互斥的第二种方法涉及到使用专门的机器指令，这种方法减少了开销；但由于使用了忙等待，因</strong></p><p><strong class=highlight-text>而仍然是低效的。</strong></p><p><strong class=highlight-text>支持互斥的另一种方法是在操作系统中提供功能，其中最常见的两种技术是信号量和消息机制。信号</strong></p><p><strong class=highlight-text>量用于在进程间发信号，并可以很容易地用于实施一个互斥规定。消息对实施互斥是很有用的，它还为进程间的通信提供了一种有效的方法。</strong></p><p><strong class=highlight-text>死锁是指一组争用系统资源或互相通信的进程被阻塞的现象。阻塞是永久的，除非操作系统采取某些</strong></p><p><strong class=highlight-text>非常的行动，如杀死一个或多个进程，或者强迫一个或多个进程沿原路返回。死锁可能涉及到可重用资源或可消费资源。可重用资源是指不会因为使用而被耗尽或毁灭的资源,如 I/O 通道或存储器区域。可消费资源是指当被一个进程获得时就毁灭了的资源，这类资源的例子有消息和 I/O 缓冲区中的信息。</strong></p><p><strong class=highlight-text>处理死锁通常有三种方法：预防、检测和避免。死锁预防通过确保死锁的一个必要条件不会满足，保</strong></p><p><strong class=highlight-text>证不会发生死锁。本章没有对检测和避免进行深入讨论。</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'互斥','Linux','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>