<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构与算法系列——栈 | 极客快訊</title><meta property="og:title" content="数据结构与算法系列——栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0d4a7d6b37a44c58a0ea25dcacf791fe"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2a4da90.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a4da90.html><meta property="article:published_time" content="2020-10-29T21:05:31+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:31+08:00"><meta name=Keywords content><meta name=description content="数据结构与算法系列——栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2a4da90.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构与算法系列——栈</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>什么是栈</strong></p><p>栈是一种运算受限制的线性表，只允许在表的一端进行插入和删除操作。这一端被称为栈顶，另一端被称为栈底。向一个栈中插入新数据叫做进栈、入栈或者压栈，是把新元素放到栈顶上边，使其成为新的栈顶元素；删除数据叫做出栈或者退栈，就是把栈顶的元素删掉，使其下边的元素称为新的栈顶元素。</p><p>举一个容易理解的例子，就是有一摞盘子，我们用的时候从上往下一个一个取，放的时候都是从下往上一个一个放，一般不从中间取或者放。这种先进后出，后进先出的数据结构就是栈。</p><p>这种操作受限的数据结构在什么情况下用呢，我们为什么不能用操作更为方便的数组或者链表呢。当某个数据只涉及在一端的插入和删除数据，并满足先进后出，后进先出的特点，我们就可以用栈这种数据结构，而数组和链表因为操作的灵活性，有时候会使一些数据不可控，更容易出现错误。</p><p><strong>栈的实现</strong></p><p>从功能上，我们是可以用数组和链表来实现栈，只要实现栈的入栈和出栈的操作，即从栈顶插入新的数据，从栈顶删除数据。用数组实现的栈叫做顺序栈，用链表实现的栈叫做链表栈。下边我们分别看一下用数组和链表实现栈的代码。这里用Java代码实现。</p><ul><li>数组实现</li></ul><pre>//基于数组实现的栈public class ArrayStack{ //数组 private String[] items; //栈的大小 private int length; //栈中元素的个数 private int count; public ArrayStack(int len){ items = new String[len]; length = len; count = 0; } //入栈 public boolean Push(String x){ //数组空间不足 if(count == length){ return false; } items[count] = x; count++; return true; } //出栈 public String Pop(){ //栈为空 if(count == 0){ return null; } String tem = items[count-1]; count--; return tem; }}</pre><ul><li>链表实现</li></ul><pre>//基于链表实现的栈public class ListNodeStack { private ListNode top; //进栈 public void Push(int val) { ListNode node = new ListNode(val, null); if (top == null) { top = node; } else { node.next = top; top = node; } } //出栈 public int Pop() { if (top == null) { return -1; } int val = top.val; top = top.next; return val; } //链表的结点 class ListNode { private int val; private ListNode next; public ListNode(int x, ListNode next) { val = x; this.next = next; } public int GetValue() { return val; } }}</pre><p>上边代码用数组实现的栈是一个固定大小的栈，当栈满了之后就没法办插入新的数据了，那么我们能不能用数组实现一个动态扩容的栈呢？前边我们将数组的时候说过，实现一个动态扩容的数组，是在数组满了的时候，我们重新创建一个大小为原来两倍的数组，然后把原来数组的数据拷贝到新的数组中，所以我们也可以用这个方法来实现一个动态扩容的栈。我们看一下代码实现。</p><pre>//基于数组实现的栈public class ArrayStack { //数组 private String[] items; //栈的大小 private int length; //栈中元素的个数 private int count; public ArrayStack(int len) { items = new String[len]; length = len; count = 0; } //入栈 public void Push(String x) { //数组空间不足 if (count == length) { DilatationArray(); } items[count] = x; count++; } //出栈 public String Pop() { //栈为空 if (count == 0) { return null; } String tem = items[count - 1]; count--; return tem; } //数组扩容 private void DilatationArray() { String[] newArray = new String[length * 2]; for (int i = 0; i &lt; length; i++) { newArray[i] = items[I]; } items = newArray; }}</pre><p><strong>栈的实际应用</strong></p><ol><li>在函数调用中的应用</li></ol><p>在Java的虚拟机中有一个内存区域被称为虚拟机栈。每个方法在执行的时候都会创建一个“栈帧”。用来存储局部变量表（包括参数）、操作栈、动态链接、方法出口等信息。每个方法从调用到结束就会有栈帧在虚拟机栈中入栈和出栈。</p><p>举一个简单的例子。</p><pre>public class AddClass{ public int Main(){ int a = 0; int b = 5; int c = 0; a = Add(2, 3); c = a + b; return c; } public int Add(int x, int y){ int sum = 0; sum = x + y; return sum; }}</pre><p>从代码中我们看到 Main 方法中首先声明了几个变量，然后调用了 Add 方法，然后经过一些运算，最后返回一个值。我们画图来更直观的看一下这个过程。</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d4a7d6b37a44c58a0ea25dcacf791fe><p class=pgc-img-caption></p></div><p>image.png</p><ol><li>在表达式求值中的应用</li></ol><p>编辑器的表达式求值的过程，就是用栈来实现的。我们举一个简单的四则运算的表达式的求值过程来看一下。例如：1+2*3-4/2。编辑器是怎么计算来得到最后的值呢。</p><p>这个求值过程，编辑器是用两个栈来实现的，一个保存数字的栈，一个保存运算符号的栈。我们从左向右遍历表达式，当遇到数字的时候把它压入数字栈，当遇到运算符号的时候，就与运算符栈的栈顶的运算符比较，如果比栈顶的运算符优先级高，就直接压入运算符栈，如果比栈顶的运算符优先级低或者相同，那么就从运算符栈取出栈顶运算符号，从数字栈中取出两个数字进行计算，然后把结果压入数字栈，然后继续比较，依次类推，知道最后。</p><p>我们为了更形象的理解，也用画图的方式来展示一下这个过程。</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c814d7045f494309835ecd4fcb2e4c47><p class=pgc-img-caption></p></div><p>image.png</p><ol><li>在各种前进后退操作中的应用</li></ol><p>我们在各中编辑器的撤销和恢复操作，浏览器中的前进和后退操作，都是用栈来实现的。</p><p>我们用两个栈 A 和 B，当我们执行操作的时候把我们的每一个操作依次压入 A 栈中，当我们执行后退的操作时，依次从 A 栈中取出，然后压入 B 栈中，当执行前进操作的时候，依次从 B 栈中取出，然后压入 A 栈中。</p><p>比如我们依次执行了 a，b，c 操作，我们依次把 a，b，c 压入 A 栈。如图</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1f1a71ed8224ccab1b31b26d84b3275><p class=pgc-img-caption></p></div><p>image.png</p><p>假如我们现在想要撤销 c 和 b 操作。那么它就是这样的。</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/355c3a791b5f4d808ba1eeb9d935e24f><p class=pgc-img-caption></p></div><p>image.png</p><p>假如我又想恢复操作 b</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/005b487de7e0432aa13d96780ec820ed><p class=pgc-img-caption></p></div><p>image.png</p><p>这个时候我继续执行新的操作 d，那么无论前进后退我们都无法再回到操作 c 了，所以我们应该清空 B 栈。</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/61beaf4ee1294fac9dcafb5fde1436e9><p class=pgc-img-caption></p></div><p><strong>image.png</strong></p><p>欢迎关注公众号：「努力给自己看」</p><div class=pgc-img><img alt=数据结构与算法系列——栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c6922c00979c47948c8814858e3af71b><p class=pgc-img-caption></p></div><p>公众号200x200</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','算法'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E5%AD%A6/ef6637be.html alt=数据结构与算法——最小生成树 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/36b27200eb7c41258d8210393c3e09bf style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E5%AD%A6/ef6637be.html title=数据结构与算法——最小生成树>数据结构与算法——最小生成树</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/c3e3bf2.html alt=数据结构与算法（5）栈 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/64b8a77987c34980862b62b33586c54e style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/c3e3bf2.html title=数据结构与算法（5）栈>数据结构与算法（5）栈</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>