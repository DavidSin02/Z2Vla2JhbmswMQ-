<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>ASP.NET Core中我们可以使用非常简单的方式，来使用响应压缩 | 极客快訊</title><meta property="og:title" content="ASP.NET Core中我们可以使用非常简单的方式，来使用响应压缩 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/7b9fcf79-6ed6-4933-8e57-61f4fa936d65"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><meta property="article:published_time" content="2020-11-14T21:01:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:37+08:00"><meta name=Keywords content><meta name=description content="ASP.NET Core中我们可以使用非常简单的方式，来使用响应压缩"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2c1045a1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>ASP.NET Core中我们可以使用非常简单的方式，来使用响应压缩</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="ASP.NET Core中我们可以使用非常简单的方式，来使用响应压缩" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/7b9fcf79-6ed6-4933-8e57-61f4fa936d65><p class=pgc-img-caption></p></div><p>介绍#</p><p>响应压缩技术是目前Web开发领域中比较常用的技术，在带宽资源受限的情况下，使用压缩技术是提升带宽负载的首选方案。我们熟悉的Web服务器，比如IIS、Tomcat、Nginx、Apache等都可以使用压缩技术，常用的压缩类型包括Brotli、Gzip、Deflate，它们对CSS、JavaScript、HTML、XML 和 JSON等类型的效果还是比较明显的，但是也存在一定的限制对于图片效果可能没那么好，因为图片本身就是压缩格式。其次，对于小于大约150-1000 字节的文件（具体取决于文件的内容和压缩的效率，压缩小文件的开销可能会产生比未压缩文件更大的压缩文件。在ASP.NET Core中我们可以使用非常简单的方式来使用响应压缩。</p><h3 class=pgc-h-arrow-right>使用方式#</h3><p>在ASP.NET Core中使用响应压缩的方式比较简单。首先，在ConfigureServices中添加services.AddResponseCompression注入响应压缩相关的设置，比如使用的压缩类型、压缩级别、压缩目标类型等。其次，在Configure添加app.UseResponseCompression拦截请求判断是否需要压缩,大致使用方式如下</p><pre><code>Copypublic class Startup{    public void ConfigureServices(IServiceCollection services)    {        services.AddResponseCompression();    }    public void Configure(IApplicationBuilder app, IHostingEnvironment env)    {        app.UseResponseCompression();    }}</code></pre><p>如果需要自定义一些配置的话还可以手动设置压缩相关</p><pre><code>Copypublic void ConfigureServices(IServiceCollection services){    services.AddResponseCompression(options =&gt;    {        //可以添加多种压缩类型，程序会根据级别自动获取最优方式        options.Providers.Add&lt;BrotliCompressionProvider&gt;();        options.Providers.Add&lt;GzipCompressionProvider&gt;();        //添加自定义压缩策略        options.Providers.Add&lt;MyCompressionProvider&gt;();        //针对指定的MimeType来使用压缩策略        options.MimeTypes =             ResponseCompressionDefaults.MimeTypes.Concat(                new[] { "application/json" });    });    //针对不同的压缩类型，设置对应的压缩级别    services.Configure&lt;GzipCompressionProviderOptions&gt;(options =&gt;     {        //使用最快的方式进行压缩，单不一定是压缩效果最好的方式        options.Level = CompressionLevel.Fastest;        //不进行压缩操作        //options.Level = CompressionLevel.NoCompression;        //即使需要耗费很长的时间，也要使用压缩效果最好的方式        //options.Level = CompressionLevel.Optimal;    });}</code></pre><p>关于响应压缩大致的工作方式就是，当发起Http请求的时候在Request Header中添加Accept-Encoding:gzip或者其他你想要的压缩类型，可以传递多个类型。服务端接收到请求获取Accept-Encoding判断是否支持该种类型的压缩方式，如果支持则压缩输出内容相关并且设置Content-Encoding为当前使用的压缩方式一起返回。客户端得到响应之后获取Content-Encoding判断服务端是否采用了压缩技术，并根据对应的值判断使用了哪种压缩类型，然后使用对应的解压算法得到原始数据。</p><h3 class=pgc-h-arrow-right>源码探究#</h3><p>通过上面的介绍，相信大家对ResponseCompression有了一定的了解，接下来我们通过查看源码的方式了解一下它大致的工作原理。</p><h4 class=pgc-h-arrow-right>AddResponseCompression#</h4><p>首先我们来查看注入相关的代码，具体代码承载在ResponseCompressionServicesExtensions扩展类中[点击查看源码]</p><pre><code>Copypublic static class ResponseCompressionServicesExtensions{    public static IServiceCollection AddResponseCompression(this IServiceCollection services)    {        services.TryAddSingleton&lt;IResponseCompressionProvider, ResponseCompressionProvider&gt;();        return services;    }    public static IServiceCollection AddResponseCompression(this IServiceCollection services, Action&lt;ResponseCompressionOptions&gt; configureOptions)    {        services.Configure(configureOptions);        services.TryAddSingleton&lt;IResponseCompressionProvider, ResponseCompressionProvider&gt;();        return services;    }}</code></pre><p>主要就是注入ResponseCompressionProvider和ResponseCompressionOptions,首先我们来看关于ResponseCompressionOptions[点击查看源码]</p><pre><code>Copypublic class ResponseCompressionOptions{    // 设置需要压缩的类型    public IEnumerable&lt;string&gt; MimeTypes { get; set; }    // 设置不需要压缩的类型    public IEnumerable&lt;string&gt; ExcludedMimeTypes { get; set; }    // 是否开启https支持    public bool EnableForHttps { get; set; } = false;    // 压缩类型集合    public CompressionProviderCollection Providers { get; } = new CompressionProviderCollection();}</code></pre><p>关于这个类就不做过多介绍了，比较简单。ResponseCompressionProvider是我们提供响应压缩算法的核心类，具体如何自动选用压缩算法都是由它提供的。这个类中的代码比较多，我们就不逐个方法讲解了，具体源码可自行查阅[点击查看源码]，首先我们先看ResponseCompressionProvider的构造函数</p><pre><code>Copypublic ResponseCompressionProvider(IServiceProvider services, IOptions&lt;ResponseCompressionOptions&gt; options){    var responseCompressionOptions = options.Value;    _providers = responseCompressionOptions.Providers.ToArray();    //如果没有设置压缩类型默认采用Br和Gzip压缩算法    if (_providers.Length == 0)    {        _providers = new ICompressionProvider[]        {            new CompressionProviderFactory(typeof(BrotliCompressionProvider)),            new CompressionProviderFactory(typeof(GzipCompressionProvider)),        };    }    //根据CompressionProviderFactory创建对应的压缩算法Provider比如GzipCompressionProvider    for (var i = 0; i &lt; _providers.Length; i++)    {        var factory = _providers[i] as CompressionProviderFactory;        if (factory != null)        {            _providers[i] = factory.CreateInstance(services);        }    }    //设置默认的压缩目标类型默认为text/plain、text/css、text/html、application/javascript、application/xml    //text/xml、application/json、text/json、application/was    var mimeTypes = responseCompressionOptions.MimeTypes;    if (mimeTypes == null || !mimeTypes.Any())    {        mimeTypes = ResponseCompressionDefaults.MimeTypes;    }   //将默认MimeType放入HashSet    _mimeTypes = new HashSet&lt;string&gt;(mimeTypes, StringComparer.OrdinalIgnoreCase);    _excludedMimeTypes = new HashSet&lt;string&gt;(        responseCompressionOptions.ExcludedMimeTypes ?? Enumerable.Empty&lt;string&gt;(),        StringComparer.OrdinalIgnoreCase    );    _enableForHttps = responseCompressionOptions.EnableForHttps;}</code></pre><p>其中BrotliCompressionProvider、GzipCompressionProvider是具体提供压缩方法的地方，咱们就看比较常用的Gzip的Provider的大致实现[点击查看源码]</p><pre><code>Copypublic class GzipCompressionProvider : ICompressionProvider{    public GzipCompressionProvider(IOptions&lt;GzipCompressionProviderOptions&gt; options)    {        Options = options.Value;    }    private GzipCompressionProviderOptions Options { get; }    // 对应的Encoding名称    public string EncodingName { get; } = "gzip";    public bool SupportsFlush =&gt; true;    // 核心代码就是这句 将原始的输出流转换为压缩的GZipStream    // 我们设置的Level压缩级别将决定压缩的性能和质量    public Stream CreateStream(Stream outputStream)        =&gt; new GZipStream(outputStream, Options.Level, leaveOpen: true);}</code></pre><p>关于ResponseCompressionProvider其他相关的方法咱们在讲解UseResponseCompression中间件的时候在具体看用到的方法，因为这个类是响应压缩的核心类，现在提前说了，到中间件使用的地方可能会忘记了。接下来我们就看UseResponseCompression的大致实现。</p><h4 class=pgc-h-arrow-right>UseResponseCompression#</h4><p>UseResponseCompression具体也就一个无参的扩展方法，也比较简单，因为配置和工作都由注入的地方完成了，所以我们直接查看中间件里的实现，找到中间件位置ResponseCompressionMiddleware[点击查看源码]</p><pre><code>Copypublic class ResponseCompressionMiddleware{    private readonly RequestDelegate _next;    private readonly IResponseCompressionProvider _provider;    public ResponseCompressionMiddleware(RequestDelegate next, IResponseCompressionProvider provider)    {        _next = next;        _provider = provider;    }    public async Task Invoke(HttpContext context)    {        //判断是否包含Accept-Encoding头信息，不包含直接大喊一声"抬走下一个"        if (!_provider.CheckRequestAcceptsCompression(context))        {            await _next(context);            return;        }        //获取原始输出Body        var originalBodyFeature = context.Features.Get&lt;IHttpResponseBodyFeature&gt;();        var originalCompressionFeature = context.Features.Get&lt;IHttpsCompressionFeature&gt;();        //初始化响应压缩Body        var compressionBody = new ResponseCompressionBody(context, _provider, originalBodyFeature);        //设置成压缩Body        context.Features.Set&lt;IHttpResponseBodyFeature&gt;(compressionBody);        context.Features.Set&lt;IHttpsCompressionFeature&gt;(compressionBody);        try        {            await _next(context);            await compressionBody.FinishCompressionAsync();        }        finally        {            //恢复原始Body            context.Features.Set(originalBodyFeature);            context.Features.Set(originalCompressionFeature);        }    }}</code></pre><p>这个中间件非常的简单，就是初始化了ResponseCompressionBody。看到这里你也许会好奇，并没有触发调用压缩相关的任何代码，ResponseCompressionBody也只是调用了FinishCompressionAsync都是和释放相关的，不要着急我们来看ResponseCompressionBody类的结构</p><pre><code>Copyinternal class ResponseCompressionBody : Stream, IHttpResponseBodyFeature, IHttpsCompressionFeature{}</code></pre><p>这个类实现了IHttpResponseBodyFeature，我们使用的Response.Body其实就是获取的HttpResponseBodyFeature.Stream属性。我们使用的Response.WriteAsync相关的方法，其实内部都是在调用PipeWriter进行写操作，而PipeWriter就是来自HttpResponseBodyFeature.Writer属性。可以大致概括为，输出相关的操作其核心都是在操作IHttpResponseBodyFeature。有兴趣的可以自行查阅HttpResponse相关的源码可以了解相关信息。所以我们的ResponseCompressionBody其实是重写了输出操作相关方法。也就是说，只要你调用了Response相关的Write或Body相关的，其实本质都是在操作IHttpResponseBodyFeature，由于我们开启了响应输出相关的中间件，所以会调用IHttpResponseBodyFeature的实现类ResponseCompressionBody相关的方法完成输出。和我们常规理解的还是有偏差的，一般情况下我们认为，其实只要针对输出的Stream做操作就可以了，但是响应压缩中间件竟然重写了输出相关的操作。 了解到这个之后，相信大家就没有太多疑问了。由于ResponseCompressionBody重写了输出相关的操作，代码相对也比较多，就不逐一粘贴出来了，我们只查看设计到响应压缩核心相关的代码，关于ResponseCompressionBody源码相关的细节有兴趣的可以自行查阅[点击查看源码]，输出的本质其实都是在调用Write方法，我们就来查看一下Write方法相关的实现</p><pre><code>Copypublic override void Write(byte[] buffer, int offset, int count){    //这是核心方法有关于压缩相关的输出都在这    OnWrite();    //_compressionStream初始化在OnWrite方法里    if (_compressionStream != null)    {        _compressionStream.Write(buffer, offset, count);        if (_autoFlush)        {            _compressionStream.Flush();        }    }    else    {        _innerStream.Write(buffer, offset, count);    }}</code></pre><p>通过上面的代码我们看到OnWrite方法是核心操作，我们直接查看OnWrite方法实现</p><pre><code>Copyprivate void OnWrite(){    if (!_compressionChecked)    {        _compressionChecked = true;        //判断是否满足执行压缩相关的逻辑        if (_provider.ShouldCompressResponse(_context))        {            //匹配Vary头信息对应的值            var varyValues = _context.Response.Headers.GetCommaSeparatedValues(HeaderNames.Vary);            var varyByAcceptEncoding = false;            //判断Vary的值是否为Accept-Encoding            for (var i = 0; i &lt; varyValues.Length; i++)            {                if (string.Equals(varyValues[i], HeaderNames.AcceptEncoding, StringComparison.OrdinalIgnoreCase))                {                    varyByAcceptEncoding = true;                    break;                }            }            if (!varyByAcceptEncoding)            {                _context.Response.Headers.Append(HeaderNames.Vary, HeaderNames.AcceptEncoding);            }            //获取最佳的ICompressionProvider即最佳的压缩方式            var compressionProvider = ResolveCompressionProvider();            if (compressionProvider != null)            {                //设置选定的压缩算法，放入Content-Encoding头的值里                //客户端可以通过Content-Encoding头信息判断服务端采用的哪种压缩算法                _context.Response.Headers.Append(HeaderNames.ContentEncoding, compressionProvider.EncodingName);                //进行压缩时，将 Content-MD5 删除该标头，因为正文内容已更改且哈希不再有效。                _context.Response.Headers.Remove(HeaderNames.ContentMD5);                 //进行压缩时，将 Content-Length 删除该标头，因为在对响应进行压缩时，正文内容会发生更改。                _context.Response.Headers.Remove(HeaderNames.ContentLength);                //返回压缩相关输出流                _compressionStream = compressionProvider.CreateStream(_innerStream);            }        }    }}private ICompressionProvider ResolveCompressionProvider(){    if (!_providerCreated)    {        _providerCreated = true;       //调用ResponseCompressionProvider的方法返回最合适的压缩算法        _compressionProvider = _provider.GetCompressionProvider(_context);    }    return _compressionProvider;}</code></pre><p>从上面的逻辑我们可以看到，在执行压缩相关逻辑之前需要判断是否满足执行压缩相关的方法ShouldCompressResponse，这个方法是ResponseCompressionProvider里的方法，这里就不再粘贴代码了，本来就是判断逻辑我直接整理出来大致就是一下几种情况</p><ul><li>如果请求是Https的情况下，是否设置了允许Https情况下压缩的设置，即ResponseCompressionOptions的EnableForHttps属性设置</li><li>Response.Head里不能包含Content-Range头信息</li><li>Response.Head里之前不能包含Content-Encoding头信息</li><li>Response.Head里之前必须要包含Content-Type头信息</li><li>返回的MimeType里不能包含配置的不需要压缩的类型，即ResponseCompressionOptions的ExcludedMimeTypes</li><li>返回的MimeType里需要包含配置的需要压缩的类型，即ResponseCompressionOptions的MimeTypes</li><li>如果不满足上面的两种情况，返回的MimeType里包含*/*也可以执行响应压缩<br>接下来我们查看ResponseCompressionProvider的GetCompressionProvider方法看它是如何确定返回哪一种压缩类型的</li></ul><pre><code>Copypublic virtual ICompressionProvider GetCompressionProvider(HttpContext context){    var accept = context.Request.Headers[HeaderNames.AcceptEncoding];    //判断请求头是否包含Accept-Encoding信心    if (StringValues.IsNullOrEmpty(accept))    {        Debug.Assert(false, "Duplicate check failed.");        return null;    }    //获取Accept-Encoding里的值，判断是否包含gzip、br、identity等，并返回匹配信息    if (!StringWithQualityHeaderValue.TryParseList(accept, out var encodings) || !encodings.Any())    {        return null;    }    //根据请求信息和设置信息计算匹配优先级    var candidates = new HashSet&lt;ProviderCandidate&gt;();    foreach (var encoding in encodings)    {        var encodingName = encoding.Value;        //Quality涉及到一个非常复杂的算法，有兴趣的可以自行查阅        var quality = encoding.Quality.GetValueOrDefault(1);        //quality需大于0        if (quality &lt; double.Epsilon)        {            continue;        }        //匹配请求头里encodingName和设置的providers压缩算法里EncodingName一致的算法        //从这里可以看出匹配的优先级和注册providers里的顺序也有关系        for (int i = 0; i &lt; _providers.Length; i++)        {            var provider = _providers[i];            if (StringSegment.Equals(provider.EncodingName, encodingName, StringComparison.OrdinalIgnoreCase))            {                candidates.Add(new ProviderCandidate(provider.EncodingName, quality, i, provider));            }        }        //如果请求头里EncodingName是*的情况则在所有注册的providers里进行匹配        if (StringSegment.Equals("*", encodingName, StringComparison.Ordinal))        {            for (int i = 0; i &lt; _providers.Length; i++)            {                var provider = _providers[i];                candidates.Add(new ProviderCandidate(provider.EncodingName, quality, i, provider));            }            break;        }        //如果请求头里EncodingName是identity的情况，则不对响应进行编码        if (StringSegment.Equals("identity", encodingName, StringComparison.OrdinalIgnoreCase))        {            candidates.Add(new ProviderCandidate(encodingName.Value, quality, priority: int.MaxValue, provider: null));        }    }    ICompressionProvider selectedProvider = null;    //如果匹配的只有一个则直接返回    if (candidates.Count &lt;= 1)    {        selectedProvider = candidates.FirstOrDefault().Provider;    }    else    {        //如果匹配到多个则按照Quality倒序和Priority正序的负责匹配第一个        selectedProvider = candidates            .OrderByDescending(x =&gt; x.Quality)            .ThenBy(x =&gt; x.Priority)            .First().Provider;    }    //如果没有匹配到selectedProvider或是identity的情况直接返回null    if (selectedProvider == null)    {        return null;    }    return selectedProvider;}</code></pre><p>通过以上的介绍我们可以大致了解到响应压缩的大致工作方式，简单总结一下</p><ul><li>首先设置压缩相关的算法类型或是压缩目标的MimeType</li><li>其次我们可以设置压缩级别，这将决定压缩的质量和压缩性能</li><li>通过响应压缩中间件，我们可以获取到一个优先级最高的压缩算法进行压缩，这种情况主要是针对多种压缩类型的情况。这个压缩算法与内部机制和注册压缩算法的顺序都有一定的关系，最终会选择权重最大的返回。</li><li>响应压缩中间件的核心工作类ResponseCompressionBody通过实现IHttpResponseBodyFeature，重写输出相关的方法实现对响应的压缩，不需要我们手动进行调用相关方法，而是替换掉默认的输出方式。只要设置了响应压缩，并且请求满足响应压缩，那么有调用输出的地方默认都是执行ResponseCompressionBody里压缩相关的方法，而不是拦截具体的输出进行统一处理。至于为什么这么做，目前我还没有理解到设计者真正的考虑。</li></ul><h3 class=pgc-h-arrow-right>总结#</h3><p>在查看相关代码之前，本来以为关于响应压缩相关的逻辑会非常的简单，看过了源码才知道是自己想的太简单了。其中和自己想法出入最大的莫过于在ResponseCompressionMiddleware中间件里，本以为是通过统一拦截输出流来进行压缩操作，没想到是对整体输出操作进行重写。因为在之前我们使用Asp.Net相关框架的时候是统一写Filter或者HttpModule进行处理的，所以存在思维定式。可能是Asp.Net Core设计者有更深层次的理解，可能是我理解的还不够彻底，不能够体会这样做的好处究竟是什么，如果你有更好的理解或者答案欢迎在评论区里留言解惑。</p><p><strong>最后，咱给小编：</strong></p><p><strong></strong></p><p><strong>1. 点赞+评论</strong></p><p><strong>2. 点头像关注，转发给有需要的朋友。</strong></p><p><strong></strong></p><p><strong>谢谢！！</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'ASP','NET','Core'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/bf86ceae.html alt="如何在ASP.NET Core中实现面向切面编程(AOP)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/287c0bf906ec4fd88f87bd726019bf06 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/bf86ceae.html title="如何在ASP.NET Core中实现面向切面编程(AOP)">如何在ASP.NET Core中实现面向切面编程(AOP)</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/23b34058.html alt="为ASP.NET Core开发中间件压缩功能提高系统性能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0e59ba59d6244b84844608d188600738 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/23b34058.html title="为ASP.NET Core开发中间件压缩功能提高系统性能">为ASP.NET Core开发中间件压缩功能提高系统性能</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/2eafc565.html alt="ASP.NET Core如何使用压缩中间件提高Web应用程序性能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2f7e2ee9a1f141b48f2b020e9b49f33a style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/2eafc565.html title="ASP.NET Core如何使用压缩中间件提高Web应用程序性能">ASP.NET Core如何使用压缩中间件提高Web应用程序性能</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>