<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>双缓存数据库双写一致性问题就应该这么解决 | 极客快訊</title><meta property="og:title" content="双缓存数据库双写一致性问题就应该这么解决 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/81b33f9e07154073959919f76479bf2a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c3dd604.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c3dd604.html><meta property="article:published_time" content="2020-11-14T21:04:03+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:03+08:00"><meta name=Keywords content><meta name=description content="双缓存数据库双写一致性问题就应该这么解决"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2c3dd604.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>双缓存数据库双写一致性问题就应该这么解决</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>什么是缓存</h1><p class=ql-align-justify>缓存存储，也是数据的冗余。</p><ul><li>数据库访问数据，磁盘IO，慢;</li><li>缓存里访问数据，存操作，快;</li><li>数据库里的热数据，可在缓存冗余一份;</li><li>先访问缓存，如果存在，能大大的提升访问速度，降低数据库压力;</li></ul><p class=ql-align-justify>这些，是缓存的核心读加速原理。</p><p class=ql-align-justify>但是，一旦没有缓存，或者一旦涉及写操作，流程会比没有缓存更加复杂，今天我们就来解决这个问题</p><h1>我们今天解决的问题</h1><ol><li>为什么数据库和缓存中的数据会不一致</li><li>不一致优化思路</li><li>如何保证数据库与缓存的一致性</li></ol><h1>我们的方式</h1><p><strong>一、假设先写数据库，再淘汰缓存</strong></p><div class=pgc-img><img alt=双缓存数据库双写一致性问题就应该这么解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81b33f9e07154073959919f76479bf2a><p class=pgc-img-caption></p></div><p>假设先写数据库，再淘汰缓存：第一步写数据库操作成功，第二步淘汰缓存失败，则会出现DB中是新数据，Cache中是旧数据，数据不一致【如上图：db中是新数据，cache中是旧数据】。</p><div class=pgc-img><img alt=双缓存数据库双写一致性问题就应该这么解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6f4db7488a7b42a8b3d3ea767490760d><p class=pgc-img-caption></p></div><p><strong>二、假设先淘汰缓存，再写数据库：</strong></p><p>第一步淘汰缓存成功，第二步写数据库失败，则只会引发一次Cache miss【如上图：cache中无数据，db中是旧数据】。</p><p>结论：先淘汰缓存，再写数据库。</p><p>引发大家热烈讨论的点是“先操作缓存，在写数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致”，这就是本文要讨论的主题。</p><h1>如何解决上面的问题</h1><p><strong>写流程</strong></p><p>（1）先淘汰cache</p><p>（2）再写db</p><p><strong>读流程</strong></p><p>（1）先读cache，如果数据命中hit则返回</p><p>（2）如果数据未命中miss则读db</p><p>（3）将db中读取出来的数据入缓存</p><p>什么情况下可能出现缓存和数据库中数据不一致呢？</p><div class=pgc-img><img alt=双缓存数据库双写一致性问题就应该这么解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27ae37a7add54d20aad3f348cc48c4e5><p class=pgc-img-caption></p></div><p>在分布式环境下，数据的读写都是并发的，上游有多个应用，通过一个服务的多个部署（为了保证可用性，一定是部署多份的），对同一个数据进行读写，在数据库层面并发的读写并不能保证完成顺序，也就是说后发出的读请求很可能先完成（读出脏数据）：</p><p>（a）发生了写请求A，A的第一步淘汰了cache（如上图中的1）</p><p>（b）A的第二步写数据库，发出修改请求（如上图中的2）</p><p>（c）发生了读请求B，B的第一步读取cache，发现cache中是空的（如上图中的步骤3）</p><p>（d）B的第二步读取数据库，发出读取请求，此时A的第二步写数据还没完成，读出了一个脏数据放入cache（如上图中的步骤4）</p><p>即在数据库层面，后发出的请求4比先发出的请求2先完成了，读出了脏数据，脏数据又入了缓存，缓存与数据库中的数据不一致出现了</p><h1>不一致优化思路</h1><p>能否做到先发出的请求一定先执行完成呢？常见的思路是“串行化”，今天将和大家一起探讨“串行化”这个点。</p><p>先一起细看一下，在一个服务中，并发的多个读写SQL一般是怎么执行的</p><div class=pgc-img><img alt=双缓存数据库双写一致性问题就应该这么解决 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c0bfc25ddee444618c578aeea511de1e><p class=pgc-img-caption></p></div><p>上图是一个service服务的上下游及服务内部详细展开，细节如下：</p><ol><li>service的上游是多个业务应用，上游发起请求对同一个数据并发的进行读写操作，上例中并发进行了一个uid=1的余额修改（写）操作与uid=1的余额查询（读）操作</li><li>service的下游是数据库DB，假设只读写一个DB</li><li>中间是服务层service，它又分为了这么几个部分</li></ol><p>提问：任务队列其实已经做了任务串行化的工作，能否保证任务不并发执行？</p><p>答：不行，因为</p><p>（1）1个服务有多个工作线程，串行弹出的任务会被并行执行</p><p>（2）1个服务有多个数据库连接，每个工作线程获取不同的数据库连接会在DB层面并发执行</p><p>提问：假设1个服务只有1条数据库连接，能否保证任务不并发执行？</p><p>答：不行，因为</p><p>（1）1个服务只有1条数据库连接，只能保证在一个服务器上的请求在数据库层面是串行执行的</p><p>（2）因为服务是分布式部署的，多个服务上的请求在数据库层面仍可能是并发执行的</p><p>提问：假设服务只部署一份，且1个服务只有1条连接，能否保证任务不并发执行？</p><p>答：可以，全局来看请求是串行执行的，吞吐量很低，并且服务无法保证可用性</p><p>完了，看似无望了，</p><blockquote><p>1）任务队列不能保证串行化</p><p>2）单服务多数据库连接不能保证串行化</p><p>3）多服务单数据库连接不能保证串行化</p><p>4）单服务单数据库连接可能保证串行化，但吞吐量级低，且不能保证服务的可用性，几乎不可行，那是否还有解？</p></blockquote><p>退一步想，其实不需要让全局的请求串行化，而只需要“让同一个数据的访问能串行化”就行。</p><p>在一个服务内，如何做到“让同一个数据的访问串行化”，只需要“让同一个数据的访问通过同一条DB连接执行”就行。</p><p>如何做到“让同一个数据的访问通过同一条DB连接执行”，只需要“在DB连接池层面稍微修改，按数据取连接即可”</p><p>获取DB连接的CPool.GetDBConnection()【返回任何一个可用DB连接】改CPool.GetDBConnection(longid)【返回id取模相关联的DB连接】</p><p>这个修改的好处是：</p><p>（1）简单，只需要修改DB连接池实现，以及DB连接获取处</p><p>（2）连接池的修改不需要关注业务，传入的id是什么含义连接池不关注，直接按照id取模返回DB连接即可</p><p>（3）可以适用多种业务场景，取用户数据业务传入user-id取连接，取订单数据业务传入order-id取连接即可</p><p>这样的话，就能够保证同一个数据例如uid在数据库层面的执行一定是串行的</p><p>稍等稍等，服务可是部署了很多份的，上述方案只能保证同一个数据在一个服务上的访问，在DB层面的执行是串行化的，实际上服务是分布式部署的，在全局范围内的访问仍是并行的，怎么解决呢？能不能做到同一个数据的访问一定落到同一个服务呢？</p><h1>能否做到同一个数据的访问落在同一个服务上？</h1><p>上面分析了服务层service的上下游及内部结构，再一起看一下应用层上下游及内部结构</p><div class=pgc-img><img alt=双缓存数据库双写一致性问题就应该这么解决 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/653e8346edb94e5399c2aac59f25d9cb><p class=pgc-img-caption></p></div><p>上图是一个业务应用的上下游及服务内部详细展开，细节如下：</p><p>（1）业务应用的上游不确定是啥，可能是直接是http请求，可能也是一个服务的上游调用</p><p>（2）业务应用的下游是多个服务service</p><p>（3）中间是业务应用，它又分为了这么几个部分</p><p>（3.1）最上层是任务队列【或许web-server例如tomcat帮你干了这个事情了】</p><p>（3.2）中间是工作线程【或许web-server的工作线程或者cgi工作线程帮你干了线程分派这个事情了】，每个工作线程完成实际的业务任务，典型的工作任务是通过服务连接池进行RPC调用</p><p>（3.3）最下层是服务连接池，所有的RPC调用都是通过服务连接池往下游服务去发包执行的</p><p>工作线程的典型工作流是这样的：</p><p>voidwork_thread_routine(){</p><p>Task t = TaskQueue.pop(); // 获取任务</p><p>// 任务逻辑处理，组成一个网络包packet，调用下游RPC接口</p><p>ServiceConnection c = CPool.GetServiceConnection(); // 从Service连接池获取一个Service连接</p><p>c.Send(packet); // 通过Service连接发送报文执行RPC请求</p><p>CPool.PutServiceConnection(c); // 将Service连接放回Service连接池</p><p>}</p><p>似曾相识吧？没错，只要对服务连接池进行少量改动：</p><p>获取Service连接的CPool.GetServiceConnection()【返回任何一个可用Service连接】改为</p><p>CPool.GetServiceConnection(longid)【返回id取模相关联的Service连接】</p><p>这样的话，就能够保证同一个数据例如uid的请求落到同一个服务Service上。</p><h1>总结</h1><p>由于数据库层面的读写并发，引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了），可能通过两个小的改动解决：</p><p>（1）修改服务Service连接池，id取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上</p><p>（2）修改数据库DB连接池，id取模选取DB连接，能够保证同一个数据的读写在数据库层面是串行的</p><h1>遗留问题</h1><p>提问：取模访问服务是否会影响服务的可用性？</p><p>答：不会，当有下游服务挂掉的时候，服务连接池能够检测到连接的可用性，取模时要把不可用的服务连接排除掉。</p><p>提问：取模访问服务与取模访问DB，是否会影响各连接上请求的负载均衡？</p><p>答：不会，只要数据访问id是均衡的，从全局来看，由id取模获取各连接的概率也是均等的，即负载是均衡的。</p><p class=ql-align-justify><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'双缓','存数','据库'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>