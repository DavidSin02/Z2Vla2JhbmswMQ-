<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP | 极客快訊</title><meta property="og:title" content="基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/8d8271ee45cc42eb92fd58530595664b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c7374b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c7374b.html><meta property="article:published_time" content="2020-10-29T20:50:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:42+08:00"><meta name=Keywords content><meta name=description content="基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2c7374b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>基于 Redis 分布式锁</h1><p>1. 获取锁的时候，使用 setnx（SETNX key val：当且仅当 key 不存在时，set 一个 key</p><p>为 val 的字符串，返回 1；若 key 存在，则什么都不做，返回 0）加锁，锁的 value</p><p>值为一个随机生成的 UUID，在释放锁的时候进行判断。并使用 expire 命令为锁添</p><p>加一个超时时间，超过该时间则自动释放锁。</p><p>2. 获取锁的时候调用 setnx，如果返回 0，则该锁正在被别人使用，返回 1 则成功获取</p><p>锁。 还设置一个获取的超时时间，若超过这个时间则放弃获取锁。</p><p>3. 释放锁的时候，通过 UUID 判断是不是该锁，若是该锁，则执行 delete 进行锁释放。</p><p><strong>分区分表</strong></p><p>分库分表有垂直切分和水平切分两种。</p><p><strong>垂直切分(按照功能模块)</strong></p><p>将表按照功能模块、关系密切程度划分出来，部署到不同的库上。例如，我们会建立定义数</p><p>据库 workDB、商品数据库 payDB、用户数据库 userDB、日志数据库 logDB 等，分别用于</p><p>存储项目数据定义表、商品定义表、用户数据表、日志数据表等。</p><p><br></p><div class=pgc-img><img alt="基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8d8271ee45cc42eb92fd58530595664b><p class=pgc-img-caption></p></div><p><strong>水平切分(按照规则划分存储)</strong></p><p>§ 当一个表中的数据量过大时，我们可以把该表的数据按照某种规则，例如 userID 散列，进行</p><p>划分，然后存储到多个结构相同的表，和不同的库上。</p><div class=pgc-img><img alt="基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a5fb5552ce9438c858d3587b145c021><p class=pgc-img-caption></p></div><p><strong>两阶段提交协议</strong></p><p>分布式事务是指会涉及到操作多个数据库的事务,在分布式系统中，各个节点之间在物理上相互独</p><p>立，通过网络进行沟通和协调。</p><p>XA 就是 X/Open DTP 定义的交易中间件与数据库之间的接口规范（即接口函数），交易中间件</p><p>用它来通知数据库事务的开始、结束以及提交、回滚等。 XA 接口函数由数据库厂商提供。</p><p>二阶段提交(Two-phaseCommit)是指，在计算机网络以及数据库领域内，为了使基于分布式系统</p><p>架构下的所有节点在进行事务提交时保持一致性而设计的一种算法(Algorithm)。通常，二阶段提</p><p>交也被称为是一种协议(Protocol))。在分布式系统中，每个节点虽然可以知晓自己的操作时成功</p><p>或者失败，却无法知道其他节点的操作的成功或失败。当一个事务跨越多个节点时，为了保持事</p><p>务的 ACID 特性，需要引入一个作为协调者的组件来统一掌控所有节点(称作参与者)的操作结果并</p><p>最终指示这些节点是否要把操作结果进行真正的提交(比如将更新后的数据写入磁盘等等)。因此，</p><p>二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者</p><p>的反馈情报决定各参与者是否要提交操作还是中止操作。</p><p><strong>准备阶段</strong></p><p>事务协调者(事务管理器)给每个参与者(资源管理器)发送 Prepare 消息，每个参与者要么直接返回</p><p>失败(如权限验证失败)，要么在本地执行事务，写本地的 redo 和 undo 日志，但不提交，到达一</p><p>种“万事俱备，只欠东风”的状态。</p><p><strong>提交阶段</strong></p><p>如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(Rollback)消息；否则，</p><p>发送提交(Commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过</p><p>程中使用的锁资源。(注意:必须在最后阶段释放锁资源)</p><p><strong>缺点</strong></p><p><strong>同步阻塞问题</strong></p><p>1、执行过程中，所有参与节点都是事务阻塞型的。</p><p><strong>单点故障</strong></p><p>2、由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。</p><p><strong>数据不一致（脑裂问题）</strong></p><p>3、在二阶段提交的阶段二中，当协调者向参与者发送 commit 请求之后，发生了局部网络异</p><p>常或者在发送 commit 请求过程中协调者发生了故障，导致只有一部分参与者接受到了</p><p>commit 请求。于是整个分布式系统便出现不数据不一不性的现象(脑裂现象)。</p><p><strong>二阶段无法解决的问题（数据状态不确定）</strong></p><p>4、协调者再发出 commit 消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那</p><p>么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道</p><p>事务是否被已经提交。</p><p><strong>三阶段提交协议</strong></p><p>三阶段提交（ Three-phase commit ） ， 也 叫 三 阶 段 提 交 协 议 （ Three-phase commit</p><p>protocol），是二阶段提交（2PC）的改进版本。</p><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p><p>1、引入超时机制。同时在协调者和参与者中都引入超时机制。</p><p>2、在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是</p><p>一致的。也就是说，除了引入超时机制之外，3PC 把 2PC 的准备阶段再次一分为二，这样三阶段</p><p><strong>CanCommit 阶段</strong></p><p>协调者向参与者发送 commit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。</p><p><strong>PreCommit 阶段</strong></p><p>协调者根据参与者的反应情况来决定是否可以继续进行，有以下两种可能。假如协调者从所有的</p><p>参与者获得的反馈都是 Yes 响应，那么就会执行事务的预执行假如有任何一个参与者向协调者发送</p><p>了 No 响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p><p><strong>doCommit 阶段</strong></p><p>该阶段进行真正的事务提交，主要包含 1.协调这发送提交请求 2.参与者提交事务 3.参与者响应反</p><p>馈（ 事务提交完之后，向协调者发送 Ack 响应。）4.协调者确定完成事务。</p><p><strong>柔性事务</strong></p><p>在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式</p><p>领域基于 CAP 理论以及 BASE 理论，有人就提出了 柔性事务 的概念。CAP（一致性、可用性、分</p><p>区容忍性）理论大家都理解很多次了，这里不再叙述。说一下 BASE 理论，它是在 CAP 理论的基</p><p>础之上的延伸。包括 基本可用（Basically Available）、柔性状态（Soft State）、最终一致性</p><p>（Eventual Consistency）。</p><p>通常所说的柔性事务分为：两阶段型、补偿型、异步确保型、最大努力通知型几种。</p><p><strong>两阶段型</strong></p><p>1、就是分布式事务两阶段提交，对应技术上的 XA、JTA/JTS。这是分布式环境下事务处理的</p><p>典型模式。</p><p><strong>补偿型</strong></p><p>2、TCC 型事务（Try/Confirm/Cancel）可以归为补偿型</p><p>WS-BusinessActivity 提供了一种基于补偿的 long-running 的事务处理模型。服务器 A 发起事务，</p><p>服务器 B 参与事务，服务器 A 的事务如果执行顺利，那么事务 A 就先行提交，如果事务 B 也执行</p><p>顺利，则事务 B 也提交，整个事务就算完成。但是如果事务 B 执行失败，事务 B 本身回滚，这时</p><p>事务 A 已经被提交，所以需要执行一个补偿操作，将已经提交的事务 A 执行的操作作反操作，恢</p><p>复到未执行前事务 A 的状态。这样的 SAGA 事务模型，是牺牲了一定的隔离性和一致性的，但是</p><p>提高了 long-running 事务的可用性。</p><p></p><div class=pgc-img><img alt="基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b03674c06764482db9ec919cba331bc0><p class=pgc-img-caption></p></div><p><br></p><p><strong>异步确保型</strong></p><p>3、通过将一系列同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步</p><p>阻塞操作的影响。</p><div class=pgc-img><img alt="基于 Redis 分布式锁：分区分表+两/三阶段提交协议+柔性事务+CAP" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d21fd543458745189a3f684c0af52d3d><p class=pgc-img-caption></p></div><p><br></p><p><strong>最大努力通知型（多次尝试）</strong></p><p>4、这是分布式事务中要求最低的一种, 也可以通过消息中间件实现, 与前面异步确保型操作不</p><p>同的一点是, 在消息由 MQ Server 投递到消费者之后, <strong>允许在达到最大重试次数之后正常</strong></p><p><strong>结束事务。</strong></p><p><strong>CAP</strong></p><p>CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability</p><p>（可用性）、Partition tolerance（分区容错性），三者不可得兼。</p><p><strong>一致性（C）：</strong></p><p>1. 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份</p><p>最新的数据副本）</p><p><strong>可用性（A）：</strong></p><p>2. 在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备</p><p>高可用性）</p><p><strong>分区容忍性（P）：</strong></p><p>3. 以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，</p><p>就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。</p><p></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Redis','式锁','分区'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>