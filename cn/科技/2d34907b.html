<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>CPU怎么保证内存访问冲突？一致性？ | 极客快訊</title><meta property="og:title" content="CPU怎么保证内存访问冲突？一致性？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4c55ba47086d4227ad11fa01d3129850"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2d34907b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2d34907b.html><meta property="article:published_time" content="2020-11-14T21:02:06+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:06+08:00"><meta name=Keywords content><meta name=description content="CPU怎么保证内存访问冲突？一致性？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2d34907b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>CPU怎么保证内存访问冲突？一致性？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>早期的CPU是通过提高主频来提升CPU的性能，但是随着频率“红利”越来越困难的情况下，厂商开始用多核来提高CPU的计算能力。多核是指一个CPU里有多个核心，在同一时间一个CPU能够同时运行多个线程，通过这样提高CPU的并发能力。</p><p><strong>内存一致性模型（memory consistency model）</strong>就是用来描述多线程对共享存储器的访问行为，在不同的内存一致性模型里，多线程对共享存储器的访问行为有非常大的差别。这些差别会严重影响程序的执行逻辑，甚至会造成软件逻辑问题。在后面的介绍中，我们将分析不同的一致性模型里，多线程的内存访问乱序问题。</p><p>目前有多种内存一致性模型：</p><ol><li>顺序存储模型（sequential consistency model）</li><li>完全存储定序（total store order）</li><li>部分存储定序（part store order）</li><li>宽松存储模型（relax memory order）</li></ol><h1>一致性模型的特性</h1><p>在后面我们会分析这几个一致性模型的特性</p><p>在分析之前，我们先定义一个基本的内存模型，以这个内存模型为基础进行分析</p><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c55ba47086d4227ad11fa01d3129850><p class=pgc-img-caption></p></div><p>上图是现代CPU的基本内存模型，CPU内部有多级缓存来提高CPU的load/store访问速度（<strong>因为对于CPU而言，主存的访问速度太慢了，上百个时钟周期的内存访问延迟会极大的降低CPU的使用效率，所以CPU内部往往使用多级缓存来提升内存访问效率</strong>。）</p><p>C1与C2是CPU的2个核心，这两个核心有私有缓存L1，以及共享缓存L2。最后一级存储器才是主存。后面的顺序一致性模型（SC）中，我们会以这个为基础进行描述（在完全存储定序、部分存储定序和宽松内存模型里会有所区别，后面会描述相关的部分）</p><p>为了简化描述的复杂性，在下面的内存一致性模型描述里，会先将缓存一致性（cache coherence）简单化，认为缓存一致性是完美的（假设多核cache间的数据同步与单核cache一样，没有cache引起的数据一致性问题），以减少描述的复杂性。</p><h1>顺序存储模型</h1><p><strong>顺序存储模型</strong>是最简单的存储模型，也称为强定序模型。CPU会按照代码来执行所有的load与store动作，即按照它们在程序的顺序流中出现的次序来执行。从主存储器和CPU的角度来看，load和store是顺序地对主存储器进行访问。</p><h1>下面分析这段代码的执行结果</h1><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7504d75443b64da8b2738ebf53dffeca><p class=pgc-img-caption></p></div><p>在顺序存储器模型里，MP（多核）会严格严格按照代码指令流来执行代码</p><p>所以上面代码在主存里的访问顺序是：</p><pre>S1 S2 L1 L2</pre><p>通过上面的访问顺序我们可以看出来，虽然C1与C2的指令虽然在不同的CORE上运行，但是C1发出来的访问指令是顺序的，同时C2的指令也是顺序的。虽然这两个线程跑在不同的CPU上，但是在顺序存储模型上，其访问行为与UP（单核）上是一致的。</p><p>我们最终看到r2的数据会是NEW，与期望的执行情况是一致的，所以在顺序存储模型上是不会出现内存访问乱序的情况</p><h1><strong>完全存储定序</strong></h1><p>为了提高CPU的性能，芯片设计人员在CPU中包含了一个存储缓存区（store buffer），它的作用是为store指令提供缓冲，使得CPU不用等待存储器的响应。所以对于写而言，只要store buffer里还有空间，写就只需要1个时钟周期（哪怕是ARM-A76的L1 cache，访问一次也需要3个cycles，所以store buffer的存在可以很好的减少写开销），但这也引入了一个访问乱序的问题。</p><p>首先我们需要对上面的基础内存模型做一些修改，表示这种新的内存模型</p><p>相比于以前的内存模型而言，store的时候数据会先被放到store buffer里面，然后再被写到L1 cache里。</p><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9a70b735eca431eaed45259a065f11b><p class=pgc-img-caption></p></div><p>首先我们思考单核上的两条指令：</p><pre>	S1：store flag= set	S2：load r1=data	S3：store b=set</pre><p>如果在顺序存储模型中，S1肯定会比S2先执行。但是如果在加入了store buffer之后，S1将指令放到了store buffer后会立刻返回，这个时候会立刻执行S2。S2是read指令，CPU必须等到数据读取到r1后才会继续执行。这样很可能S1的store flag=set指令还在store buffer上，而S2的load指令可能已经执行完（特别是data在cache上存在，而flag没在cache中的时候。这个时候CPU往往会先执行S2，这样可以减少等待时间）</p><p>这里就可以看出再加入了store buffer之后，内存一致性模型就发生了改变。</p><p>如果我们定义store buffer必须严格按照FIFO的次序将数据发送到主存（所谓的FIFO表示先进入store buffer的指令数据必须先于后面的指令数据写到存储器中），这样S3必须要在S1之后执行，CPU能够保证store指令的存储顺序，这种内存模型就叫做完全存储定序（TSO）。</p><p>我们继续看下面的一段代码</p><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/291f82d759684af7aca55c2691082aad><p class=pgc-img-caption></p></div><p>在SC模型里，C1与C2是严格按照顺序执行的</p><p>代码可能的执行顺序如下：</p><pre>	S1 S2 L1 L2	S1 L1 S2 L2	S1 L1 L2 S2	L1 L2 S1 S2	L1 S1 S2 L2	L1 S1 L2 S2</pre><p>由于SC会严格按照顺序进行，最终我们看到的结果是至少有一个CORE的r1值为NEW，或者都为NEW。</p><p>在TSO模型里，由于store buffer的存在，L1和S1的store指令会被先放到store buffer里面，然后CPU会继续执行后面的load指令。Store buffer中的数据可能还没有来得及往存储器中写，这个时候我们可能看到C1和C2的r1都为0的情况。</p><p>所以，我们可以看到，在store buffer被引入之后，内存一致性模型已经发生了变化（从SC模型变为了TSO模型），会出现store-load乱序的情况，这就造成了代码执行逻辑与我们预先设想不相同的情况。而且随着内存一致性模型越宽松（通过允许更多形式的乱序读写访问），这种情况会越剧烈，会给多线程编程带来很大的挑战。</p><h1><strong>部分存储定序</strong></h1><p>芯片设计人员并不满足TSO带来的性能提升，于是他们在TSO模型的基础上继续放宽内存访问限制，允许CPU以非FIFO来处理store buffer缓冲区中的指令。CPU只保证地址相关指令在store buffer中才会以FIFO的形式进行处理，而其他的则可以乱序处理，所以这被称为部分存储定序（PSO）。</p><p>那我们继续分析下面的代码</p><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7b3b655717fd4d8b843392631fe1cdfa><p class=pgc-img-caption></p></div><p>S1与S2是地址无关的store指令，cpu执行的时候都会将其推到store buffer中。如果这个时候flag在C1的cahe中存在，那么CPU会优先将S2的store执行完，然后等data缓存到C1的cache之后，再执行store data=NEW指令。</p><p>这个时候可能的执行顺序：</p><pre>S2 L1 L2 S1</pre><p>这样在C1将data设置为NEW之前，C2已经执行完，r2最终的结果会为0，而不是我们期望的NEW，这样PSO带来的store-store乱序将会对我们的代码逻辑造成致命影响。</p><p>从这里可以看到，store-store乱序的时候就会将我们的多线程代码完全击溃。所以在PSO内存模型的架构上编程的时候，要特别注意这些问题。</p><h1><strong>宽松内存模型</strong></h1><p>丧心病狂的芯片研发人员为了榨取更多的性能，在PSO的模型的基础上，更进一步的放宽了内存一致性模型，不仅允许store-load，store-store乱序。还进一步允许load-load，load-store乱序， 只要是地址无关的指令，在读写访问的时候都可以打乱所有load/store的顺序，这就是宽松内存模型（RMO）。</p><p>我们再看看上面分析过的代码</p><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39537950380f4ac08e3c1fee45ac5df3><p class=pgc-img-caption></p></div><p>在PSO模型里，由于S2可能会比S1先执行，从而会导致C2的r2寄存器获取到的data值为0。在RMO模型里，不仅会出现PSO的store-store乱序，C2本身执行指令的时候，由于L1与L2是地址无关的，所以L2可能先比L1执行，这样即使C1没有出现store-store乱序，C2本身的load-load乱序也会导致我们看到的r2为0。从上面的分析可以看出，RMO内存模型里乱序出现的可能性会非常大，这是一种乱序随可见的内存一致性模型。</p><h1><strong>内存屏障</strong></h1><p>芯片设计人员为了尽可能的榨取CPU的性能，引入了乱序的内存一致性模型，这些内存模型在多线程的情况下很可能引起软件逻辑问题。为了解决在有些一致性模型上可能出现的内存访问乱序问题，芯片设计人员提供给了内存屏障指令，用来解决这些问题。</p><p>内存屏障的最根本的作用就是提供一个机制，要求CPU在这个时候必须以顺序存储一致性模型的方式来处理load与store指令，这样才不会出现内存访问不一致的情况。</p><p>对于TSO和PSO模型，内存屏障只需要在store-load/store-store时需要（写内存屏障），最简单的一种方式就是内存屏障指令必须保证store buffer数据全部被清空的时候才继续往后面执行，这样就能保证其与SC模型的执行顺序一致。</p><p>而对于RMO，在PSO的基础上又引入了load-load与load-store乱序。RMO的读内存屏障就要保证前面的load指令必须先于后面的load/store指令先执行，不允许将其访问提前执行。</p><p>我们继续看下面的例子：</p><div class=pgc-img><img alt=CPU怎么保证内存访问冲突？一致性？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba24c85f91604845bcbe07b31351647f><p class=pgc-img-caption></p></div><p>例如C1执行S1与S2的时候，我们在S1与S2之间加上写屏障指令，要求C1按照顺序存储模型来进行store的执行，而在C2端的L1与L2之间加入读内存屏障，要求C2也按照顺序存储模型来进行load操作，这样就能够实现内存数据的一致性，从而解决乱序的问题。</p><p>ARM的很多微架构就是使用RMO模型，所以我们可以看到ARM提供的dmb内存指令有多个选项：</p><pre>	LD load-load/load-store	ST store-store/store-load	SY any-any</pre><p>这些选项就是用来应对不同情况下的乱序，让其回归到顺序一致性模型的执行顺序上去。</p><blockquote><p>本文修改自：http://www.wowotech.net/memory_management/456.html</p><p>本人公众号：技术原理君</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'CPU','怎么','保证'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>