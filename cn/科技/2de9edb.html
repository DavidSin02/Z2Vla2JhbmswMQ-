<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>关于使用机器学习识别 API 参考文档中的知识 | 极客快訊</title><meta property="og:title" content="关于使用机器学习识别 API 参考文档中的知识 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/692d89be84654efbbbb4b9f12387374c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2de9edb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2de9edb.html><meta property="article:published_time" content="2020-10-29T21:05:57+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:57+08:00"><meta name=Keywords content><meta name=description content="关于使用机器学习识别 API 参考文档中的知识"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2de9edb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>关于使用机器学习识别 API 参考文档中的知识</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/692d89be84654efbbbb4b9f12387374c><p class=pgc-img-caption></p></div><p style=text-align:start>引用：Fucci D, Mollaalizadehbahnemiri A, Maalej W, et al. On using machine learning to identify knowledge in API reference documentation[J]. foundations of software engineering, 2019: 109-119.</p><p style=text-align:start>摘要：使用 API 参考文档（如 JavaDoc）是软件开发的不可或缺的组成部分。先前的研究引入了分类法，该分类法划分了 12 种类型的 API 文档知识，包括有关 API 的功能，结构和质量的知识。我们研究了现代文本分类方法如何很好地自动识别包含特定知识类型的文档。 我们将传统的机器学习方法（k-NN 和 SVM）与在手动注释的 Java 文档、.NET API 文档上训练的深度学习方法进行了比较。当分别对知识类型进行分类（例如，多重二分类器）时，最佳 AUPRC 达到 87％。深度学习和 SVM 分类器看起来是互补的。对于四个知识类型（概念，控制，模式和非信息），SVM 明显优于深度学习，而对于其余的知识类型则是深度学习更准确。当一次考虑多种知识类型（即多标签分类）时，深度学习的表现优于简单基线方法和传统机器学习，MacroAUC 可达 79％。我们还使用在通用文本语料库和 StackOverflow 上预训练的 embeddings 对分类器进行了比较，但未观察到明显的改进。最后，为了评估分类器的普遍性，我们在另一个外部不可见的 Python 文档数据集中对它们进行了重新测试。功能，概念，目的，模式和指令的分类器似乎能够从 Java 文档和.NET 文档适用到 Python 文档。 我们讨论了结果以及它们如何为支持开发人员共享和访问 API 知识的工具开发提供信息。</p><p style=text-align:start><strong>1.</strong> 引言</p><p style=text-align:start>软件开发人员通过应用程序编程接口（APIs）来重用库和框架。他们通常依靠参考文档来确定哪些 API 元素与手头任务相关，或者如何实例化，配置和组合 API。与其他知识来源（例如教程和 Q＆A 门户）相比，像 JavaDoc 和 PyDoc 等参考文档被视为官方 API 技术文档。 它们提供有关 API 元素，组件，操作和结构的详细和基本信息。</p><p style=text-align:start>由于 API 文档可能长达数千页，访问其中的特定知识可能既繁琐又耗时。完成任务所需的信息可能散布在多个元素（例如类，方法和属性）的文档页面上。因此，开发人员尝试使用其他资源来满足他们的信息需求。例如，尽管 Java Development Kit（JDK）API 文档包含 7000 多个页面，但是截至 2019 年初，StackOverflow 上已经有超过 300 万个 Java 相关的帖子。</p><p style=text-align:start>在过去的十年中，软件工程研究人员研究了信息开发人员在咨询 API 文档时所需的信息。 一项研究重点是使信息需求与文档中可用的知识类型相匹配。Maalej 和 Robillard 通过开发 API 参考文档中找到的 12 种知识类型的经验验证分类法，朝着这个方向迈出了第一步。一个文档页面可以包含多种知识类型（图 1）。功能和指令是完成开发任务所需的特定知识类型，而信息类型仅包含无信息的样板文本。Maalej 和 Robillard 认为，他们的知识分类方式能够做到理解和改善文档质量和满足开发人员的信息需求。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a15fd6f71354afdbb078a6fa0c70d56><p class=pgc-img-caption></p></div><p style=text-align:start>研究团队研究了 API 参考文档中的特定的知识类型。 例如，Montperrus 等和 Seid 等研究了使用指令类型的知识以防止违反 API 使用限制。Robillard 和 Chhetri 在向开发人员推荐 API 时过滤掉了非信息类型的知识。目前所推崇的自动化方法都是基于语言特征工程或句法模式。</p><p style=text-align:start>这项工作调查了现代文本分类方法如何很好地自动识别 Maalej 和 Robillard 在 API 文档中建议的知识类型。基于 5574 个 Java 和.NET 的文档的数据集，我们训练、测试和比较了传统的机器学习方法（如 k-NN 和支持向量机 SVM）以及深度学习方法（如 LSTM 和 RNN）。 RNN 从通用文本的语义表示中学习特征。因此，我们研究了使用来自 StackOverflow 的软件开发专用语料库训练的神经网络对结果造成的影响。 最后，我们研究了从 Python 标准库获得的未知数据集的分类器的普遍使用性。</p><p style=text-align:start>本文做出了三点贡献。第一，我们为 API 文档提供了详细的分类基准。第二，当我们共享本研究的代码和数据时，几个表现最好的分类器（例如 AUPRC≥80％）已经具有关联性。第三，我们的发现和相关工作的讨论为研究人员，工具供应商和从业人员提供了有关机器学习如何帮助更好地组织，访问和共享 API 知识的见解。</p><p style=text-align:start><strong>2.</strong> 研究设置</p><p style=text-align:start><strong>2.1</strong> 研究问题和方法</p><p style=text-align:start>Maalej 和 Robillard 提出了一种经过实证验证的 12 种知识类型的分类法。表 1 列出了这些知识类型，它们代表了这项工作的基础。我们的主要目标是研究在没有附加特征工程或 NLP 技术的情况下，用于文本分类的简单机器学习如何识别这些知识类型。也就是说，我们的分类器使用一种或多种知识类型来标记文档。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76a9a27328e94f7c93d6a910aaa8b981><p class=pgc-img-caption></p></div><p style=text-align:start>本文研究了两种主要的文本分类方法。传统方法通常从训练集中某些关键词或短语的出现中学习。计算密集型方法（通常指深度学习）使用关键字的语义-即关键字的上下文。</p><p style=text-align:start>对于传统方法，我们研究了两种经常用于文本分类的算法：k-NN 和 SVM。对于深度学习，我们将 RNN 与 LSTM 层一起使用，这对于文本分类问题特别有效。</p><p style=text-align:start>本研究解决的任务是给 API 文档标记知识类型。由于文档可以包含多个知识类型，因此该任务被建模为一个多重二分类问题，包括针对每种知识类型独立训练一个二进制分类器。另一种方法是训练多标签分类器，例如一个会输出一组知识类型而不是单个知识类型的分类器。当回答以下研究问题时，我们将分析并展示两种方法的结果。</p><p style=text-align:start>RQ1：基于文本的分类器如何很好地识别 API 参考文档中的知识类型？ 特别是，深度学习能否优于传统方法？</p><p style=text-align:start>对于文本分类任务，RNN 的输入层通常由在大型的无标记文本语料库上训练的 embeddings 组成，以捕获丰富的语义特征。经过预训练的 embeddings 可以轻松地嵌入神经网络中。 但是，尽管这些嵌入节省了计算时间并很好地代表了常见的语言任务，但它们可能会丢失软件工程或特定于 API 的语义。这引出了我们的第二个研究问题。</p><p style=text-align:start>RQ2：与通用软件相比，特定于软件开发的文本嵌入是否可以改善分类结果？</p><p style=text-align:start>机器学习评估的一个常见问题是在某个数据集上训练的模型是否可以推广到其他数据集。原始数据集包括标准 Java 和.NET 库的文档。由于我们旨在评估以不同风格编写的 API 参考文档的方法的通用性，因此我们手动注释了从 PythonStandardLibrary 文档中采样的新数据集。我们用此数据集作为附加测试集来展示分类器的性能。</p><p style=text-align:start>RQ3：是否可以跨 API 归纳出基于知识类型的文档分类？</p><p style=text-align:start>我们使用 10％的数据集作为测试集，基于 10 倍交叉验证方式来评估模型。在比较各个知识类型分类器时，我们展示了精确召回曲线下的面积（AUPRC）。 精确召回曲线是一种用于评估二元分类的通用方法，可以通过在不同概率阈值处绘制精确度和召回值来获得。特别是，它们用于评估在不平衡数据集上训练的机器学习模型。 因此，无论特定阈值如何，AUPRC 都是性能的汇总度量。在比较多种知识类型的分类器时，0 们根据两种类型的指标（基于项目和基于标签）报告绩效。基于项目的度量标准是：a）Hamming Loss，即错误分类的标签与标签总数之比（最佳值为零）和 b）Subset Accuracy，即预测标签集与实际标签集之间完全匹配的百分比</p><p style=text-align:start>基于标签的指标是精度，召回率，F1 量度（公式 1）和 ROC 曲线下面积（AUC）。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e7b94690fd74835b2945dcb47a9c899><p class=pgc-img-caption></p></div><p style=text-align:start>ROC 曲线是通过在不同的概率阈值下针对误报率（FPR，公式 2）绘制召回图来创建的。 因此，AUC 不取决于特定阈值。 为了计算阳性，假阳性和假阴性的值，我们使用 0.5 作为概率阈值。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e90ef18c4a8f4c1b889cc73dcedc1a45><p class=pgc-img-caption></p></div><p style=text-align:start>基于标签的指标是宏平均的。宏平均将度量应用于每个预测标签的二分类，然后对结果取平均值——即标签对最终结果的贡献相等。相反，微平均首先汇总每个标签的各个指标成分（即阳性，假阳性，阴性和假阴性），然后将它们平均。 因此，微平均偏向多数类别，在评估不平衡数据集时应避免。 我们将分类器的结果与原始基线 MF1，MF2 和 RAND 进行比较。 前两个总是为每个文档分配第一个（分别对前两个而言）最频繁的标签，而后者则分配一个随机标签。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/87efc5396bc14905a733c4488b03bb40><p class=pgc-img-caption></p></div><p style=text-align:start><strong>2.2</strong> 研究数据</p><p style=text-align:start>我们使用 Maalej 和 Robillard 创建的 CaDO 数据集作为对 JDK 6 和.NET 4.0 API 参考文档的内容分析的结果。CaDO 包含 5,574 个观测值。数据集中包括 API 元素的名称（例如，类，方法或属性），其文档文本以及 12 个二进制数值，这些值指示相应知识类型的存在（或不存在）。表 2 总结了数据集的文本属性。</p><p style=text-align:start>大多数文档（90.5％）包含 12 种知识类型中的 1-5 种。我们使用 SCUMBLE 分数（∈[0，1]）报告不平衡程度。对于给定的标签，较高的 SCUMBLE 得分表示所有其他同时出现的标签的频率之间存在较大差异。通常，高分的数据集对于分类任务是有问题的。但是，对于较低的 SCUMBLE 得分的数据集，重采样可以减少不平衡性。 CaDO 数据集的平均 SCUMBLE 得分为 0.11。</p><p style=text-align:start>我们对数据集的 90％（即训练集）应用了随机欠采样和过采样。 我们没有对测试集（数据集的 10％）进行重新采样以避免采样偏差。</p><p style=text-align:start>为了进行重采样，我们删除了标签集中 30％的包含功能和非信息的文档，并复制了 50％的包含环境和质量的文档。阈值是根据 SCUMBLE 得分凭经验获得的。重新采样后，训练集和测试集分别包含 3876 和 430 个观测值。图 2 展示了重新采样后用于训练模型的数据集中的标签频率。</p><p style=text-align:start>我们从 Python 2.7 标准库中准备了一个由 100 个 API 文档页面（即模块，类型，属性和方法）组成的新 Python 数据集。我们选择 Python 标准库是因为其代码的组织方式与 Java 和.NET 不同。它广泛使用定义了功能，类和变量的模块。Python 编程范例比 Java 和.NET 更具功能性，而 Java 和.NET 则遵循面向对象的范例。Python 是动态类型的，其参考文档通常集中在功能上，而类型文档可嵌入到源代码中（例如，通过 Docstrings）。 最后，它的开发和文档由一个开源的非营利社区（Python 软件基金会）驱动，而 Java 和.NET 则归公司所有。我们遵循了 Maalej 和 Robillard 建议的抽样策略，即分层随机抽样。我们首先为每个基本模块创建了层次，然后从每个层次按其频率成比例地对 API 文档随机采样。</p><p style=text-align:start>两位习惯使用 Python 的软件工程专业博士生在每个文档中手动标记了知识类型。对于此任务，我们为他们提供了 Maalej 和 Robillard 的相同准则，并进行了少量修改，例如提供使用 Python 编程语言的示例。在标签集上的一致率为 14％，即在 100 个示例中，有 14 个被完全相同的知识类型集标记。总体协议率为 75％——即，在 1200 个标签（100 个示例 ×12 个标签）中，有 300 个存在冲突。其中两位作者解决了冲突并创建了最终数据集。图 3 显示了 Python 数据集中知识类型的分布。图 3 显示了 Python 数据集中知识类型的分布。功能性是最多数的标签。Python 代表了一个额外的测试集（即没有使用该数据集中的示例来训练分类器），我们没有对其进行重新采样以避免产生偏差的结果。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/25ed984312064ef09a72a371c1f478b7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bc620906a3c14ae0b541b77c91fd9c26><p class=pgc-img-caption></p></div><p style=text-align:start>对于这两个数据集，我们执行了几个简单的操作来清理和准备文本数据。我们对 API 文档文本进行了字母小写化，标记化和删除停用词。然后，我们将术语转换为 one-hot 向量并保留其顺序。对于我们基准测试中的深度学习分类器，我们基于四个大型语料库训练了 GloVe embeddings，结果总结于表 3。Common Crawl（CC）是预训练的 embeddings，于 2018 年 3 月下载。它包含 840B tokens 和一个 220 万词的词汇表。语料库包含从 Internet 爬取下来的高质量通用文本。但是，CC 语料库在 CaDO 数据集中缺少特定领域术语。因此，在 CCOTF 的 embeddings 中，对 CC 语料库中的缺失词进行了即时训练。最后，我们通过训练两个附加语料库（StackOverflow（SO）和 StackOverflow API（SOapi））上的 embeddings 来获得特定专业领域的表示形式的输入。前者包括 2000 万个帖子，而后者包括 400 万个标记为 java 或.net 的帖子。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/297da5c9486d466eb0e487716b3111d3><p class=pgc-img-caption></p></div><p style=text-align:start><strong>3.</strong> 分类器配置</p><p style=text-align:start><strong>3.1</strong> 传统机器学习</p><p style=text-align:start>我们为分类任务选择的机器学习方法是 SVM 和 k-NN，以及它们对多标签问题的适应版本，即 One-vs-Rest SVM（OvRSVM）和 Multi Label k-NN（ML-kNN）。我们使用从 CaDO 数据集中提取的 unigram 和 bigrams 作为输入特征，因为 n-gram 语言模型易于计算和使用。此外，它们还用于将机器学习和自然语言处理应用于软件工程环境的研究中。</p><p style=text-align:start><strong>3.2</strong> 含 LSTM 层的 RNN</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dc9e281909d04012b86ab1723d65feef><p class=pgc-img-caption></p></div><p style=text-align:start>图 4 显示了我们在这项工作中使用的架构。该网络由一个 LSTM 层，两个稠密层和一个输出层组成。LSTM 层中的单元数量与用于表示每个单词的向量的维度成比例。稠密层分别包含 128 和 64 个单元。输出层中的单元数是知识类型的数量（即 12 个单元）。LSTM 层的核心组件是一个存储单元，用于存储与网络中以前的分析步骤有关的信息。在训练的每个步骤中，网络都基于 a）新输入，b）RNN 其他隐藏层的前置状态以及 c）存储单元的当前状态来预测输出。门学会了如何修改存储单元以提高预测精度（参见图 5）。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6b1a0e92b8744a7780a617524897651d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6fbb0b8513e4b108eff33fe3b83cb1e><p class=pgc-img-caption></p></div><p style=text-align:start>遗忘单元在我们的网络中的作用是在新输入中更改与先前知识类型相关的信息时，以最佳方式丢弃这些信息。例如，当新输入中的知识类型为“指令”时，“忘记门”将删除与其他知识类型相关的信息。因此，当学习个别类型时，忘门减少了存储单元的歧义性。当前输入文档中与知识类型相关联的特征将移动到存储单元中。在存储单元中，输入门决定应存储哪些信息。例如，当前输入包含指令时，将使用输入门提取其特征并将其存储在存储单元中。 最后，输出门选择与指令类型相关的最重要的特征。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c56dc314cb347bb8fce8036c92fac6f><p class=pgc-img-caption></p></div><p style=text-align:start>由于具有相同长度的输入向量加快了构建 RNN 嵌入层的过程，因此我们将 300 作为最大向量长度，并用零填充较短的向量。因此，我们的输入层是一个 2D 矩阵，其中每一行都是一个 300 维单元（人工神经元）。输入层中的单元数取决于用于训练嵌入的语料库的词汇量。当将文档送入 RNN 时，与文档术语关联的单位将被激活。第一个隐藏层是 LSTM 单元，用于学习输入文档的文本特征。它适合于学习长期依赖性，例如在使用大型 API 参考文档文本的情况下。为了防止过拟合，我们对权重矩阵和偏差向量应用了一种丢弃技术。</p><p style=text-align:start>LSTM 层（即可以与知识类型相关联的一组特征）的输出经过两个完全连接的稠密层。稠密层提供了由 LSTM 层提取的特征的深入表示，并使网络能够了解其层次结构和组成特征。为了减轻由于要素从输出层的高维空间投影到低维空间而导致的特征损失，该模型将稠密层中的单元数从 128 个平滑地减少到 64 个。我们对稠密层使用 ReLU 激活功能，以防止过拟合。</p><p style=text-align:start>输出层使用 sigmoid 激活函数来预测知识类型。因此，输出层中的单位数就是模型学习的标签数。由于 sigmoid 函数的输出是一个介于 0 和 1 之间的概率值，因此该层中的每个神经元都会估算观察到某一个标记的概率。为了将预测概率二值化，我们根据不同的指标使用了不同的阈值。</p><p style=text-align:start><strong>4.</strong> 结果</p><p style=text-align:start><strong>4.1</strong> 知识类型识别</p><p style=text-align:start>单个知识类型。我们使用通用语料库训练了两个基于 RNN 的分类器，以获得输入层——RNNCC 和 RNNCCotf 的 embeddings。表 4 展示了我们对分类器的评估。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e21e329cb43c4c2598f01c70322843c1><p class=pgc-img-caption></p></div><p style=text-align:start>对于所有单个知识类型分类，RNN 和传统的机器学习方法比简单基线可提高 74％（平均 41％）。SVM 比 k-NN 表现更好。</p><p style=text-align:start>对功能，示例和环境类型进行分类时，深度学习在不同的概率阈值（AUPRC≥80％）上表现出了高精度和高召回率，优于传统机器学习方法。RNN 在指令，目的，参考，概念和控制类型方面产生了低于标准的结果（AUPRC&lt;50％）。 但是，仅对于后两种类型，最佳 SVM 优于最佳 RNN。对于质量，结构，样式和非信息类型的最佳分类器，其 AUPRC 介于 59％和 78％之间。同样在这种情况下，仅针对后两种类型，最佳机器学习方法（即 SVM）优于最佳 RNN 分类器。与机器学习相比，RNN 对八种知识类型进行了更好的分类。</p><p style=text-align:start>多种知识类型。第二步是将我们的任务视为多标签分类问题，而不是针对每种知识类型构建单独的分类器。我们将 RNN 分类器与相同的两个机器学习模型和两个简单的基线的多标签适应进行了比较（参见表 5）。ML-kNN 和 OvRSVM 的性能比基于项目的指标的基线更差，而 RNNs 的性能最佳。在最严格的指标上（即子集准确性），最佳的 RNN 比机器学习分类器提高了 11％。对于 MacroPrecision，MacroRecall 和 MacroF1，RNN 有 25％到 28％的改进。 从 MacroAUC 方面看，MF1 的性能要优于传统的机器学习，RNNs 的性能提高了 17％。</p><p style=text-align:start>回答 RQ1：可以自动识别三分之一的知识类型，并且效果良好（即 AUPRC≥80％）。与传统的机器学习方法相比，RNN 可以更准确地（> 10％）识别 12 种知识类型中的 8 种。在考虑多标签分类时，RNN 在基于项目和标签的指标方面优于传统的机器学习方法。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbe304d1cc5a499ab8c3ee54de507a7c><p class=pgc-img-caption></p></div><p style=text-align:start><strong>4.2</strong> 特定于软件开发的语料库</p><p style=text-align:start>单个知识类型。OneRNN 使用基于通用文本语料库（即 RNNCC）的免费可用的预训练 embeddings，而 RNNCCotf 使用相同的语料库且可以从 CaDO 数据集中即时学习缺失的单词。诸如 GloVe 之类的文本统计表示形式背后的假设是，文档的含义取决于其中出现的单词的含义。因此，RNNSO 和 RNNSOapi 在更接近 API 文档之一的域中使用语料库。如表 4 所示，在这些 RNN 中，最好的 RNN 的性能与普通 RNN 相似（∆AUPRC = 4％）。在功能，用途，控制和结构类型方面，差异最小（1%-2％）。但是，对于质量和环境，使用特定于软件开发的 embeddings 时性能会大幅下降（分别为 10％和 14％）。总体而言，鉴于获得语料库和计算 embeddings 的开销，这种改进相当有限。</p><p style=text-align:start>多种知识类型。表 5 显示，在考虑基于标签的指标（MacroAUC 除外）时，RNNCC 和 RNNCCotf 优于 RNNSO 和 RNNSOapi，而在考虑基于项目的指标时，其表现也类似。使用 StackOverflow 上的 Java 和.NET 相关帖子训练得到的 RNN 达到了最高的 MacroAUC（79％）。</p><p style=text-align:start>回答 RQ ２：使用特定于软件开发的 embeddings 的 RNN 与使用通用 embeddings 对单个知识类型进行分类的 RNN 相比，改善效果甚微。在考虑进行多标签学习时，除了 MacroAUC 之外，使用通用 embeddings 在基于项目和标签的指标上会产生更好的结果。</p><p style=text-align:start><strong>4.3</strong> 分类器普遍适用性</p><p style=text-align:start>单个知识类型。表 6 报告了 Python 测试集上各个基于 RNN 的分类器的性能。同样在这种情况下，没有任何简单的基准可以比传统的或深度学习方法更好。RNN 是 7 种知识类型的最佳分类器，而其余 5 种 SVM 则显示出了最佳结果。与 CaDO 设置一致，SVM 是概念，模式和非信息类型的最佳分类器。与 CaDO 设置相比，功能，概念和用途类型的分类器有些许性能的改进（∆ AUPRC = 8.3％）。</p><p style=text-align:start>在考虑指令，质量，控制，结构，示例和环境类型时，两个设置之间存在较大的绝对差异（∆ AUPRC = 33％），这表明这些知识类型取决于设置。平均而言，在 12 种知识类型上，Python 数据集的性能下降了约 16％。</p><p style=text-align:start>多种知识类型。表 7 列出了多标签分类任务的结果。对于基于项目的指标，我们的分类器相对于简单的基准而言表现较差或相当。分类器有较低的精度（最佳分类器为 SVM，40％）和召回率（最佳分类器为 RNNCCotf 和 RNNSOapi，26％）。 SVM 还获得了最佳的 F1（30％）。 RNNSOapi 有最高的 MacroAUC（64％）。</p><p style=text-align:start>回答 RQ ３：功能，概念，目的，模式和指令类型的分类器，似乎能够从 Java 和.NET 文档适用到 Python 文档。但是多种知识类型分类器的适用性有限。</p><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c96e9efd85747dca2805c5e2c0768a4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="关于使用机器学习识别 API 参考文档中的知识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d07da16b2d7e42debc54c9eb8d673102><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'关于','机器','学习识别'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>