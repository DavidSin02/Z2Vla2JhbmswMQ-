<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 | 极客快訊</title><meta property="og:title" content="java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/54d45b20ef6a4a3f960411db61474538"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2ea7884b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2ea7884b.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2ea7884b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>哈希是一种通过对数据进行压缩, 从而提高效率的一种解决方法，但由于哈希函数有限，数据增大等缘故，哈希冲突成为数据有效压缩的一个难题。本文主要介绍哈希冲突、解决方案，以及各种哈希冲突的解决策略上的优缺点。</p><h1 class=pgc-h-arrow-right>一、哈希表概述</h1><p>哈希表的哈希函数输入一个键，并向返回一个哈希表的索引。可能的键的集合很大，但是哈希函数值的集合只是表的大小。</p><p>哈希函数的其他用途包括密码系统、消息摘要系统、数字签名系统，为了使这些应用程序按预期工作，冲突的概率必须非常低，因此需要一个具有非常大的可能值集合的散列函数。</p><p>密码系统:给定用户密码，操作系统计算其散列，并将其与存储在文件中的该用户的散列进行比较。(不要让密码很容易被猜出散列到相同的值)。</p><p>消息摘要系统:给定重要消息，计算其散列，并将其与消息本身分开发布。希望检查消息有效性的读者也可以使用相同的算法计算其散列，并与发布的散列进行比较。(不要希望伪造消息很容易，仍然得到相同的散列)。</p><p>这些应用的流行哈希函数算法有:</p><ul><li>md5 : 2^128个值（找一个冲突键，需要哈希大约2 ^ 64个值）</li><li>sha-1：2160个值（找一个冲突键，需要大约280个值）</li></ul><h1 class=pgc-h-arrow-right>二、哈希冲突</h1><p>来看一个简单的实例吧，假设采用hash函数：H(K) = K mod M，插入这些值：217、701、19、30、145</p><pre><code>H(K) = 217 % 7 = 0H(K) = 701 % 7 = 1H(K) = 19 % 7 = 2H(K) = 30 % 7 = 2H(K) = 145 % 7 = 5</code></pre><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/54d45b20ef6a4a3f960411db61474538><p class=pgc-img-caption></p></div><p>上面实例很明显 19 和 30 就发生冲突了。</p><h1 class=pgc-h-arrow-right>三、冲突解决策略</h1><p>除非您要进行“完美的散列”，否则必须具有冲突解决策略，才能处理表中的冲突。同时，该策略必须允许查找，插入和删除正确运行的操作！</p><p>冲突解决技术可以分为两类：开散列方法( open hashing，也称为拉链法，separate chaining )和闭散列方法( closed hashing，也称为开地址方法，open addressing )。这两种方法的不同之处在于：开散列法把发生冲突的关键码存储在散列表主表之外，而闭散列法把发生冲突的关键码存储在表中另一个槽内。</p><p>下面介绍业内比较流行的hash冲突解决策略：</p><ul><li>线性探测(Linear probing)</li><li>双重哈希(Double hashing)</li><li>随机散列(Random hashing)</li><li>分离链接(Separate chaining)</li></ul><p>上面线性探测、双重哈希、随机散列都是闭散列法，而分离链接则是开散列法。</p><p><strong>1、线性探测(Linear probing)</strong>插入一个值</p><p>使用散列函数H（K）在大小为M的表中插入密钥K时：</p><ol start=1><li>设置 indx = H（K）</li><li>如果表位置indx已经包含密钥，则无需插入它。Over</li><li>否则，如果表位置indx为空，则在其中插入键。Over</li><li>其他碰撞。设置 indx =（indx + 1）mod M.</li><li>如果 indx == H（K），则表已满！就只能做哈希表的扩容了</li></ol><p>因此，线性探测基本上是在发生碰撞时对空槽进行线性搜索。</p><ul><li><strong>优点</strong>：易于实施；总是找到一个位置（如果有）；当表不是很满时，平均情况下的性能非常好。</li><li><strong>缺点</strong>：表的相邻插槽中会形成“集群”或“集群”键；当这些簇填满整个阵列的大部分时，性能会严重下降，因为探针序列执行的工作实际上是对大部分阵列的穷举搜索。</li></ul><p><strong>简单例子</strong></p><p>如哈希表大小M = 7, 哈希函数：H(K) = K mod M。插入这些值：701, 145, 217, 19, 13, 749</p><pre><code>H(K) = 701 % 7 = 1H(K) = 145 % 7 = 5H(K) = 217 % 7 = 0H(K) = 19 % 7 = 2H(K) = 13 % 7 = 1(冲突) --&gt; 2(已经有值) --&gt; 3(插入位置3)H(K) = 749 % 7 = 2(冲突) --&gt; 3(已经有值) --&gt; 4(插入位置4)</code></pre><p>可见，如果哈希表如果不是很大，随着数据插入，冲突也会组件发生，探针遍历次数将会逐渐变低，检索过程也就成为穷举。</p><p><strong>检索一个值</strong></p><p>如果使用线性探测将键插入表中，则线性探测将找到它们！</p><p>当使用散列函数 H（K）在大小为N的表中搜索键K时：</p><ol start=1><li>设置 indx = H（K）</li><li>如果表位置indx包含键，则返回FOUND。</li><li>否则，如果表位置 indx 为空，则返回NOT FOUND。</li><li>否则设置 indx =（indx + 1）modM。</li><li>如果 indx == H（K），则返回NOT FOUND。就只能做哈希表的扩容了</li></ol><p><strong>问题：如何从使用线性探测的表中删除键</strong>？</p><p>能否进行“延迟删除”，而只是将已删除密钥的插槽标记为空？</p><blockquote><p>很明显，在线性探测很难做到，如果把位置置为空，那么如果后面的值也是哈希冲突，线性探测插入，则再也无法遍历这些值了。</p></blockquote><p><strong>2、双重哈希(Double hashing)</strong></p><p>线性探测冲突解决方案会导致表中出现簇，因为如果两个键发生碰撞，则探测到的下一个位置对于这两个键都是相同的。</p><p>双重哈希的思想：使偏移到下一个探测到的位置取决于键值，因此对于不同的键可以不同。</p><p>需要引入第二个哈希函数 H 2（K），用作探测序列中的偏移量（将线性探测视为 H 2（K）== 1 的双重哈希）。</p><p>对于大小为 M 的哈希表，H 2（K）的值应在 1到M-1 的范围内；如果M为质数，则一个常见选择是 H2（K）= 1 +（（K / M）mod（M-1））。</p><p>然后，用于双哈希的插入算法为：</p><ol start=1><li>设置 indx = H（K）; offset = H 2（K）</li><li>如果表位置indx已经包含密钥，则无需插入它。Over</li><li>否则，如果表位置 indx 为空，则在其中插入键。Over</li><li>其他碰撞。设置 indx =（indx + offset）mod M.</li><li>如果 indx == H（K），则表已满！就只能做哈希表的扩容了</li></ol><p><strong>3、随机散列(Random hashing)</strong></p><p>与双重哈希一样，随机哈希通过使探测序列取决于密钥来避免聚类。</p><p>使用随机散列时，探测序列是由密钥播种的伪随机数生成器的输出生成的（可能与另一个种子组件一起使用，该组件对于每个键都是相同的，但是对于不同的表是不同的）。</p><p>然后，用于随机哈希的插入算法为：</p><ol start=1><li>创建以 K 为种子的 RNG。设置indx = RNG.next() mod M。</li><li>如果表位置 indx 已经包含密钥，则无需插入它。Over</li><li>否则，如果表位置 indx 为空，则在其中插入键。Over</li><li>其他碰撞。设置 indx = RNG.next() mod M.</li><li>如果已探测所有M个位置，则放弃。就只能做哈希表的扩容了。</li></ol><p>随机散列很容易分析，但是由于随机数生成的“费用”，它并不经常使用。双重哈希在实践中还是经常被使用。</p><p><strong>4、分离链接(Separate chaining)</strong></p><p>在具有哈希函数 H（K）的表中插入键K时</p><ol start=1><li>设置 indx = H（K）</li><li>将关键字插入到以 indx 为标题的链接列表中。（首先搜索列表，以避免重复。）</li></ol><p>在具有哈希函数H（K）的表中搜索键K时</p><ol start=1><li>设置 indx = H（K）</li><li>使用线性搜索在以 indx 为标题的链表中搜索关键字。</li></ol><p>使用哈希函数 H（K）删除表中的键K时</p><ol start=1><li>设置 indx = H（K）</li><li>删除链接列表中以 indx 为标题的键</li></ol><p>优点：随着条目数量的增加，平均案例性能保持良好。甚至超过M；删除比开放地址更容易实现。</p><p>缺点：需要动态数据，除数据外还需要存储指针，本地性较差，导致缓存性能较差。</p><p>很明显，Java7 的 HashMap 就是一种分裂链接的实现方式。</p><p><strong>分离链哈希分析</strong></p><p>请记住表的填充程度的负载系数度量：α = N / M。</p><p>其中M是表格的大小，并且 N 是表中已插入的键数。</p><p>通过单独的链接，可以使 α> 1 给定负载因子α，我们想知道在最佳，平均和最差情况下的时间成本。</p><p><strong>成功找到</strong></p><p>新键插入和查找失败（这些相同），最好的情况是O（1），最坏的情况是O（N）。让我们分析平均情况</p><p><strong>分裂链接的平均成本</strong></p><p>假设负载系数为 α = N / M 的表在M个链接列表中总共分配了N个项目（其中一些可能为空），因此每个链接列表的平均项目数为：</p><p>如果查找/插入失败，则必须穷举搜索表中的链表之一，并且表中链表的平均长度为α。因此，使用单独链接进行插入或不成功查找的比较平均次数为</p><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/88331bef5aa24a5885804a7e470a70f2><p class=pgc-img-caption></p></div><p>成功查找后，将搜索包含目标密钥的链接列表。除目标密钥外，该列表中平均还有（N-1）/ M个密钥；在找到目标之前，将平均搜索其中一半。因此，使用单独链接成功找到的比较平均次数为</p><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ba91253a91d457586ddc4e33a994fb8><p class=pgc-img-caption></p></div><p>当α&lt;1时，它们分别小于1和1.5。并且即使当α超过1时，它们仍然是O（1），与N无关。</p><h1 class=pgc-h-arrow-right>四、开散列方法 VS 闭散列方法</h1><p>如果将键保留为哈希表本身中的条目，则可以使用线性探测，双重和随机哈希... 这样做称为“开放式寻址”，也称为“封闭式哈希”。</p><p>另一个想法：哈希表中的条目只是指向链表（“链”）头部的指针；链接列表的元素包含键... 这称为“单独链接”，也称为“开放式哈希”。</p><p>通过单独的链接，冲突解决变得容易：只要在其链表中插入一个键，就可以将其插入（为此，可以使用比链表更高级的数据结构；但是正如我们将看到的，链表在一般情况下效果很好）。</p><p>让下面我们看一下这些策略的时间成本。</p><p><strong>开放式地址哈希分析</strong></p><p>分析哈希表“查找”或“插入”性能时，一个有用的参数是负载系数 α = N / M。</p><p>其中 M 是表格的大小，并且 N 是表中已插入的键数负载系数是表满度的一种度量。</p><p>给定负载因子 α ，我们想知道在最佳，平均和最差情况下的时间成本。</p><p><strong>成功找到</strong></p><p>对所有键，最好的情况是O（1），最坏的情况是O（N），新键插入和查找失败（这些相同），所以让我们分析平均情况。我们将给出随机哈希和线性探测的结果。实际上，双重哈希类似于随机哈希；</p><p><strong>平均不成功的查找/插入成本</strong></p><p>假定负载系数为α= N / M的表。考虑随机散列，因此聚类不是问题。每个探针位置是随机且独立生成的对于每个探针，找到空位置的可能性为（1-α）。查找空位置将停止查找或插入，这是一个伯努利过程，成功概率为（1-α）。该过程的预期一阶到达时间为 1 /（1-α）。所以：</p><p>使用随机哈希进行插入或不成功查找的探针的平均数量为</p><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fd991c82ebdd4eb8a363088d26fb4d5a><p class=pgc-img-caption></p></div><p>使用线性探测时，探头的位置不是独立的。团簇形成，当负载系数高时会导致较长的探针序列。可以证明，用于线性探测的插入或未成功发现的探针的平均数量约为</p><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d390dae61a4e498fb7ee96656a23425f><p class=pgc-img-caption></p></div><p>当 α 接近1时，这些平均案例时间成本很差，仅受M限制；但当 α 等于或小于7.75（与M无关）时，效果还不错（分别为4和8.5）</p><p><strong>平均成功查找成本</strong></p><p>假定负载系数为 α= N / M 的表。考虑随机散列，因此聚类不是问题。每个探针位置是随机且独立生成的。</p><p>对于表中的键，成功找到它所需的探针数等于将其插入表中时所采用的探针数。每个新密钥的插入都会增加负载系数，从0开始到α。</p><p>因此，通过随机散列成功发现的探测器的平均数量为</p><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92c8696f7bec458aba339e1b940e5fea><p class=pgc-img-caption></p></div><p>通过线性探测，会形成簇，从而导致更长的探针序列。可以证明，通过线性探测成功发现的平均探针数为</p><div class=pgc-img><img alt=java程序员注意：少有人知的哈希冲突解决策略，学到就是赚到 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/346196f5d0e64162bb0c1abe65af7242><p class=pgc-img-caption></p></div><p>当α接近1时，这些平均案例时间成本很差，仅受M限制；但当α等于或小于7.75时好（分别为1.8和2.5），与M无关。</p><h1 class=pgc-h-arrow-right>推荐阅读</h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6823372432800219659/?group_id=6823372432800219659" rel="noopener noreferrer" target=_blank>五一后:阿里春招总结,当初按这个准备面试,可能已经P7了</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6821118048791953931/?group_id=6821118048791953931" rel="noopener noreferrer" target=_blank>太狠了!京东T8架构师建议吃透这40W字消息队列文档,涨薪15K不是梦</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6820415333233328648/?group_id=6820415333233328648" rel="noopener noreferrer" target=_blank>RocketMQ全貌解析，阿里不愧是阿里</a><br><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6819896661725151752/?group_id=6819896661725151752" rel="noopener noreferrer" target=_blank>java开发必知必会的技能,没有系统掌握Kafka,你就缺少核心竞争力</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6818550260630028811/?group_id=6818550260630028811" rel="noopener noreferrer" target=_blank>2020还不会性能调优?啃下这20W字Java性能调优笔记,随便涨薪13K!</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'java','哈希','冲突'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>