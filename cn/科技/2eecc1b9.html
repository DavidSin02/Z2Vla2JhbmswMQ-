<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试再问ThreadLocal，别说你不会 | 极客快訊</title><meta property="og:title" content="面试再问ThreadLocal，别说你不会 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2eecc1b9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2eecc1b9.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="面试再问ThreadLocal，别说你不会"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2eecc1b9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试再问ThreadLocal，别说你不会</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre>作者：坚持就是胜利来源：https://juejin.im/post/5d427f306fb9a06b122f1b94</pre><p>ThreadLocal是什么</p><p>以前面试的时候问到ThreadLocal总是一脸懵逼，只知道有这个哥们，不了解他是用来做什么的，更不清楚他的原理了。表面上看他是和多线程，线程同步有关的一个工具类，但其实他与线程同步机制无关。<strong>线程同步机制是多个线程共享同一个变量，而ThreadLocal是为每个线程创建一个单独的变量副本，每个线程都可以改变自己的变量副本而不影响其它线程所对应的副本。</strong></p><p>官方API上是这样介绍的：该类提供了线程局部(thread-local)变量。这些变量不同于它们的普通对应物，因为访问某个变量（通过其 get 或 set 方法）的每个线程都有自己的局部变量，它独立于变量的初始化副本。ThreadLocal实例通常是类中的 private static 字段，它们希望将状态与某一个线程（例如，用户 ID 或事务 ID）相关联。</p><p>ThreadLocal的API</p><p>ThreadLocal定义了四个方法:</p><ul><li class=ql-align-justify>get():返回此线程局部变量当前副本中的值</li><li class=ql-align-justify>set(T value):将线程局部变量当前副本中的值设置为指定值</li><li class=ql-align-justify>initialValue():返回此线程局部变量当前副本中的初始值</li><li class=ql-align-justify>remove():移除此线程局部变量当前副本中的值</li></ul><p>ThreadLocal还有一个特别重要的静态内部类ThreadLocalMap，该类才是实现线程隔离机制的关键。get()、set()、remove()都是基于该内部类进行操作，ThreadLocalMap用键值对方式存储每个线程变量的副本，key为当前的ThreadLocal对象，value为对应线程的变量副本。</p><p>试想，每个线程都有自己的ThreadLocal对象，也就是都有自己的ThreadLocalMap，对自己的ThreadLocalMap操作，当然是互不影响的了，这就不存在线程安全问题了，所以ThreadLocal是以空间来交换安全性的解决思路。</p><p>使用实例</p><p>假设每个线程都需要一个计数值记录自己做某件事做了多少次，各线程运行时都需要改变自己的计数值而且相互不影响，那么ThreadLocal就是很好的选择，这里ThreadLocal里保存的当前线程的局部变量的副本就是这个计数值。</p><div class=pgc-img><img alt=面试再问ThreadLocal，别说你不会 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9><p class=pgc-img-caption></p></div><p>运行结果：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面试再问ThreadLocal，别说你不会 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f5d8c816ac745d79b1498d282713118><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>解决SimpleDateFormat的线程安全</p><p>我们知道SimpleDateFormat在多线程下是存在线程安全问题的，那么将SimpleDateFormat作为每个线程的局部变量的副本就是每个线程都拥有自己的SimpleDateFormat，就不存在线程安全问题了。</p><pre>public class SimpleDateFormatDemo { private static final String DATE_FORMAT = "yyyy-MM-dd HH:mm:ss"; private static ThreadLocal&lt;DateFormat&gt; threadLocal = new ThreadLocal&lt;&gt;(); /** * 获取线程的变量副本，如果不覆盖initialValue方法，第一次get将返回null,故需要创建一个DateFormat，放入threadLocal中 * @return */ public DateFormat getDateFormat() { DateFormat df = threadLocal.get(); if (df == null) { df = new SimpleDateFormat(DATE_FORMAT); threadLocal.set(df); } return df; } public static void main(String [] args) { SimpleDateFormatDemo formatDemo = new SimpleDateFormatDemo(); MyRunnable myRunnable1 = new MyRunnable(formatDemo); MyRunnable myRunnable2 = new MyRunnable(formatDemo); MyRunnable myRunnable3 = new MyRunnable(formatDemo); Thread thread1= new Thread(myRunnable1); Thread thread2= new Thread(myRunnable2); Thread thread3= new Thread(myRunnable3); thread1.start(); thread2.start(); thread3.start(); } public static class MyRunnable implements Runnable { private SimpleDateFormatDemo dateFormatDemo; public MyRunnable(SimpleDateFormatDemo dateFormatDemo) { this.dateFormatDemo = dateFormatDemo; } @Override public void run() { System.out.println(Thread.currentThread().getName()+" 当前时间："+dateFormatDemo.getDateFormat().format(new Date())); } }}</pre><p>运行结果：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面试再问ThreadLocal，别说你不会 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/90f6c6812e814deda1746c15fa813d26><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>源码分析</p><p>ThreadLocalMap</p><p>ThreadLocalMap内部是利用Entry来进行key-value的存储的。</p><pre>static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; { /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) { super(k); value = v; } }</pre><p>上面源码中key就是ThreadLocal，value就是值，Entry继承WeakReference，所以Entry对应key的引用（ThreadLocal实例）是一个弱引用。</p><p>set(ThreadLocal key, Object value)</p><div class=pgc-img><img alt=面试再问ThreadLocal，别说你不会 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2097cc9cda4b4494a3076655a39ab408><p class=pgc-img-caption></p></div><p>这个set操作和集合Map解决散列冲突的方法不同，集合Map采用的是链地址法，这里采用的是开放定址法（线性探测）。set()方法中的replaceStaleEntry()和cleanSomeSlots()，这两个方法可以清除掉key ==null的实例，防止内存泄漏。</p><p>getEntry()</p><pre>private Entry getEntry(ThreadLocal&lt;?&gt; key) { int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e); }</pre><p>由于采用了开放定址法，当前keu的散列值和元素在数组中的索引并不是一一对应的，首先取一个猜测数（key的散列值），如果所对应的key是我们要找的元素，那么直接返回，否则调用getEntryAfterMiss</p><pre>private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) { Entry[] tab = table; int len = tab.length; while (e != null) { ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; } return null; }</pre><p>这里一直在探测寻找下一个元素，知道找的元素的key是我们要找的。这里当key==null时，调用expungeStaleEntry有利于GC的回收，用于防止内存泄漏。</p><p>ThreadLocal为什么会内存泄漏</p><p>ThreadLocalMap的key为ThreadLocal实例，他是一个弱引用，我们知道弱引用有利于GC的回收，当key == null时，GC就会回收这部分空间，但value不一定能被回收，因为他和Current Thread之间还存在一个强引用的关系。由于这个强引用的关系，会导致value无法回收，如果线程对象不消除这个强引用的关系，就可能会出现OOM。有些时候，我们调用ThreadLocalMap的remove()方法进行显式处理。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面试再问ThreadLocal，别说你不会 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/286e781e7dc14ebeaa09414d519af46f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>总结</p><p>ThreadLocal不是用来解决共享变量的问题，也不是协调线程同步，他是为了方便各线程管理自己的状态而引用的一个机制。</p><p>每个ThreadLocal内部都有一个ThreadLocalMap,他保存的key是ThreadLocal的实例，他的值是当前线程的局部变量的副本的值。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','再问','ThreadLocal'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>