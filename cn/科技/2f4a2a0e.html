<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Canal探究 | 极客快訊</title><meta property="og:title" content="Canal探究 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/21195268939c4bf18e20ee9b7222c8f3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2f4a2a0e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f4a2a0e.html><meta property="article:published_time" content="2020-10-29T21:09:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:58+08:00"><meta name=Keywords content><meta name=description content="Canal探究"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2f4a2a0e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Canal探究</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal主要用途是基于 MySQL 数据库增量日志解析，提供增量数据订阅和消费。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">应用场景：</span></strong></h1><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">异构数据同步</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">数据库实时备份</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">业务cache刷新</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">原理</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal模拟成mysql slave向master发送dump请求，收到binlog数据进行解析</span></p><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/21195268939c4bf18e20ee9b7222c8f3><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">slave同步master原理：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">master将改变记录到二进制日志(binary log)中（这些记录叫做二进制日志事件，binary log events，可以通过show binlog events进行查看）</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">slave将binary log events拷贝到它的中继日志(relay log)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">slave重做中继日志中的事件，将改变反映它自己的数据</span></li></ul><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5cd58b9a986840daa97ba4e505c5e287><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">架构</span></strong></h1><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34ea9dba399347248bbf85d526f450b1><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">server代表一个canal运行实例，对应于一个jvm</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">instance对应一个数据队列，一个destination，相当于一个数据库实例变更的监听，1个server对应1-n个instance</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">instance模块：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">eventParser (数据源接入，模拟slave协议和master进行交互，协议解析)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">eventSink (Parser和Store</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">链接</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">器，进行数据过滤，加工，分发的工作)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">eventStore (数据存储)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">metaManager (增量订阅&消费信息管理器)</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">EventParser</span></strong></h1><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5858458cde1f47dc910d1bb836ae4f91><p class=pgc-img-caption></p></div><ol start=1><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Connection获取上一次解析成功的位置 (如果第一次启动，则获取初始指定的位置或者是当前数据库的binlog位点)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Connection建立链接，发送BINLOG_DUMP指令</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Mysql开始推送Binaly Log</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">接收到的Binaly Log的通过Binlog parser进行协议解析，补充一些特定信息</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">传递给EventSink模块进行数据存储，是一个阻塞操作，直到存储成功</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">存储成功后，定时记录Binaly Log位置</span></li></ol><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">EventSink</span></strong></h1><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84ea836792604f7e869c6ec5889f1ce9><p class=pgc-img-caption></p></div><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">数据过滤：支持通配符的过滤模式，表名，字段内容等</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">数据路由/分发：解决1:n (1个parser对应多个store的模式)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">数据</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">归并</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">：解决n:1 (多个parser对应1个store)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">数据加工：在进入store之前进行额外的处理，比如join</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">EventStore</span></strong></h1><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2d649fb46a6e4dac996b8229f1d94b3f><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Instance设计</span></strong></h1><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/98ad7f236c99455696717dd13f5cab6f><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">instance代表了一个实际运行的数据队列，包括了EventPaser,EventSink,EventStore等组件。抽象了CanalInstanceGenerator，主要是考虑配置的管理方式：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">manager方式：提供http方式，可以和公司内部web console/manager系统进行对接。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">spring方式：基于spring xml + properties进行定义，通过spring配置</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Spring配置</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">spring配置的原理是将整个配置抽象为两部分：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">xxxx-instance.xml (canal组件的配置定义，可以在多个instance配置中共享，在canal.properties中配置)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">xxxx.properties (每个instance通道都有各自一份定义，因为每个mysql的ip，帐号，密码等信息不会相同)</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">通过spring的PropertyPlaceholderConfigurer通过机制将其融合，生成一份instance实例对象，每个instance对应的组件都是相互独立的，互不影响</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">properties配置文件</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">properties配置分为两部分：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal.properties (系统根配置文件，配置destinations，注册IP，启动端口)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">instance.properties (instance级别的配置文件，每个instance一份，配置数据库信息，监听的表)</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal.properties介绍：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal配置主要分为两部分定义：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">instance列表定义 (列出当前server上有多少个instance，每个instance的加载方式是spring/manager等)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">common参数定义，比如可以将instance.properties的公用参数，抽取放置到这里，这样每个instance启动的时候就可以共享. 【instance.properties配置定义优先级高于canal.properties】</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal如何维护一份增量订阅&消费的关系信息：</span></strong></h1><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">解析位点 (parse模块会记录，上一次解析binlog到了什么位置，对应组件为：CanalLogPositionManager)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">消费位点 (canal server在接收了客户端的ack后，就会记录客户端提交的最后位点，对应的组件为：CanalMetaManager)</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">对应的两个位点组件，目前都有几种实现：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">memorymemory-instance.xml中使用，所有的组件(parser , sink , store)都选择了内存版模式，记录位点的都选择了memory模式，重启后又会回到初始位点进行解析速度最快，依赖最少(不需要zookeeper)场景：一般应用在quickstart，或者是出现问题后，进行数据分析的场景，不应该将其应用于生产环境</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">zookeeper</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">mixed</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">period：default-instance.xml中使用，集合了zookeeper+memory模式，store选择了内存模式，其余的parser/sink依赖的位点管理选择了持久化模式，目前持久化的方式主要是写入zookeeper，保证数据集群共享支持HA，可用于生产环境，集群化部署</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一份 instance.xml 中有一份或者多份 instance 定义，优先</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">以</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> destination 名字查找对应的 instance bean 定义，如果没有，则按默认的名字 “instance” 查找 instance 对象,例如 xxxx-instance.xml 中定义 id 分别为 instance-1, instance-2 的两个 bean. 这两个 bean 将为同名的 instance 提供自定义的 eventParser , evnetSink , evnetStore , metaManager，alarmHandler.如果没有自定义这些 bean, 就使用 id="instance" 的 bean 来配置 canal instance.</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一份 instance bean 定义，需要包含 eventParser , evnetSink , evnetStore , metaManager，alarmHandler 的5个模块定义，( alarmHandler 主要是一些报警机制处理，因为简单没展开，可扩展)</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">instance.xml设计初衷：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">允许进行自定义扩展，比如实现了基于数据库的位点管理后，可以自定义一份自己的instance.xml，整个canal设计中最大的灵活性在于此</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">HA模式配置</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal的ha分为两部分：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal server: 不同server上的instance要求同一时间只能有一个处于running，其他的处于standby状态，不然就是对mysql dump的重复请求。这里是instance/destination级别的负载均衡，而不是server</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal client: 为了保证有序性，一份instance同一时间只能由一个canal client进行get/ack/rollback操作，否则客户端接收无法保证有序。</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">整个HA机制的控制主要是依赖了zookeeper的几个特性，watcher和EPHEMERAL节点(和session生命周期绑定)</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Canal Server:</span></p><div class=pgc-img><img alt=Canal探究 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c239c402304c4b32911ff4be6a25157f><p class=pgc-img-caption></p></div><ol start=1><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal server要启动某个canal instance时都先向zookeeper进行一次尝试启动判断 (实现：创建EPHEMERAL节点，谁创建成功就允许谁启动)</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">创建zookeeper节点成功后，对应的canal server就启动对应的canal instance，没有创建成功的canal instance就会处于standby状态</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一旦zookeeper发现canal server A创建的节点消失后，立即通知其他的canal server再次进行步骤1的操作，重新选出一个canal server启动instance.</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal client每次进行connect时，会首先向zookeeper询问当前是谁启动了canal instance，然后和其建立链接，一旦链接不可用，会重新尝试connect.</span></li></ol><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Canal Client的方式和canal server方式类似，也是利用zookeeper的抢占EPHEMERAL节点的方式进行控制.</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal丢失数据的情况：</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">正常情况下，在canal server/client挂掉或切换的情况下不会丢失数据，因为zk会持久化server解析binlog及clinet消费数据的位置，重启时会重新读取。以下情况可能会丢失数据：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">zk保存的元数据被人为修改，如server解析binlog及clinet消费数据的位置</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">client使用get方法而非getWithoutAck，如果client消费数据时挂掉，server会认为这部分数据已经被消费而丢失</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">MySQL binlog非正常运维，比如binglog迁移、重命名、丢失等</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">切换MySQL源，比如原来基于M1实例，后来M1因为某种原因失效，那么Canal将数据源切换为M2，而且M1和M2可能binlog数据存在不一致</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Canal性能分析</span></strong></h1><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal处理数据流程为master-parse-sink-store-comsume，整个流程中都是单线程、串行、阻塞式的。如果批量insert、update、delete，都可能导致大量的binlog产生，也会加剧Master与slave之间数据同步的延迟。（写入频繁）。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">如果client消费的效能较低，比如每条event执行耗时很长。这会导致数据变更的消息ACK较慢，那么对于Canal而言也将阻塞sotre，没有有足够的空间存储新消息进而堵塞parse解析binlog。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Canal本身非常轻量级，主要性能开支就是在binlog解析，其转发、存储、提供消费者服务等都很简单。它本身不负责数据存储。原则上，canal解析效率几乎没有负载，canal的本身的延迟，取决于其与slave之间的网络IO。</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Canal导致重复消费</span></strong></h1><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Canal instance初始化时，根据“消费者的Cursor”来确定binlog的起始位置，但是Cursor在ZK中的保存是滞后的（间歇性刷新），所以Canal instance获得的起始position一定不会大于消费者真实</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">已见</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">的position。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Consumer端，因为某种原因的rollback，也可能导致一个batch内的所有消息重发，此时可能导致重复消费。</span></li></ul><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">因此Consumer端需要保持幂等，对于重复数据可以进行校验或者replace。对于非幂等操作，比如累加、计费，需要慎重。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">destination的消费问题</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一个destination无法被多个client直接并行消费，解决方案：</span></p><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">client收到消息以后转发到kafka或者MQ中，后继的其他Consumer只与kafka或者MQ接入</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一个Canal中使用多个destination，它们对应相同的MySQL源</span></li></ul><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">参考：</span></p><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">https://github.com/alibaba/canal/wiki/AdminGuide</span></p><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">https://www.bookstack.cn/read/canal-v1.1.4/10a3a22ce51cd92e.md</span></p><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">https://blog.csdn.net/guanfengliang1988/article/details/107357853</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">对于canal设计的一些思考</span></strong></h1><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">对于canal的高可用，通过zk保证server和client同一时间只能</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有</span><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">一个节点工作server能不能根据数据id进行分片读取，提高读取数据的性能，类似kafka的设计，应该是不能的。因为parser向master发起dump请求得到的是字节流，无法获取原始数据。那能不能一个parser对应多个sink再放入store。没必要，因为canal的性能瓶颈在canal与数据库的网络IO，解析及sink是很快的。客户端能不能多个节点同时工作，从一个destination消费数据。如果不保证数据成功消费及有序性是可以的。如果某一client消费数据失败，当前store的设计（环形结构保存数据）无法做到回滚。如果一个destination分多个队列由client消费，只能保证数据局部有序，同时设计复杂。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">当前store的数据保存在内存中，是否有必要持久化到文件类似于logstash的数据也是保存在内存中，官方文档说会支持，但没有也可以，因为持久化会影响整体性能，通过zk存储client的消费位置会保证数据至少被消费一次。</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">store保存的数据受到大小和条数的限制，当达到限制时，sink会堵塞parser，不会撑爆内存</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">canal与logstahs，kafka的一些比较</span></li></ul><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">对以后写公共组件的一些启示：</span></strong></h1><ul><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">支持多种配置方式如配置文件，http，并可动态生效</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">通过协调服务保证系统的高可用</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">暴露服务监控指标至prometheus</span></li><li><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">获取数据的方式：达到一定数量或时间</span></li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Canal','探究'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>