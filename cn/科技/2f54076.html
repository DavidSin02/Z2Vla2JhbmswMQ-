<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>HTML5拓扑图形组件设计之道 | 极客快訊</title><meta property="og:title" content="HTML5拓扑图形组件设计之道 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/224008a449aa4c439d97f0be777281eb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f54076.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f54076.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2f54076.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f54076.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f54076.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2f54076.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2f54076.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2f54076.html><meta property="article:published_time" content="2020-10-29T20:53:19+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:19+08:00"><meta name=Keywords content><meta name=description content="HTML5拓扑图形组件设计之道"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/2f54076.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>HTML5拓扑图形组件设计之道</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>HT for Web提供了涵盖通用组件、2D拓扑图形组件以及3D引擎的一站式解决方案，正如Hightopo官网所表达的我们希望提供：Everything you need to create cutting-edge 2D and 3D visualization. 这个愿景从功能上是个相当长的战线，从设计架构上也是极具挑战性的，其实HT团队是非常保守的，我们从不贪多图大，只做我们感觉自己能得更好，能给用户综合体验更佳的功能，在这样理念驱动下我们慢慢形成了这样的愿景，慢慢实现了几个有意义的里程碑，慢慢积累下了不少图形组件设计上的创新和经验，我不知道这个系列会写多少篇，也许永远也不会结束，也没有系统的提纲规划，想到什么就写什么，只希望文章能启发有兴趣的同学对图形组件设计更深的思考就足够了。</p><p>讨论前先设定话题的边界，HT是基于HTML5的图形组件库，因此文章的案例更多会涉及HTML和JavaScript语言，但并不局限于Web前端，设计思想上同样适用于任何GUI语言平台。完整的前端设计是需要考虑到后台加载并发等因素，但本系列更侧重于纯客户端图形组件，不涉及网络通讯部分的思考，例如最近阿里无线前端招聘让谈谈：讲讲输入完网址按下回车，到看到网页这个过程中发生了什么。这是个能讨论出很多方方面面，让你了解面试者的好话题，但这里讨论的话题会与以下关键字更为相关：企业应用、Single Page Application、重客户端交互、监控、MV*等。</p><p>如Linus大神所言：Talk is cheap, show me the code. 因此我选择在话题展开之前，先用HT来扩展定制几个应用案例，以便大家了解HT组件及其扩展设计思路。</p><div class=pgc-img><img alt=HTML5拓扑图形组件设计之道 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/224008a449aa4c439d97f0be777281eb><p class=pgc-img-caption></p></div><p>熟悉Flex的程序员应该都了解Tour de Flex这个包罗万象的大杂烩，其中的网络监控拓扑Network Monitor特别其动画切换效果一直给我很深印象，这里不可能有篇幅实现完整例子，我们仅尝试实现其展示CPU和MEM的界面部分。</p><div class=pgc-img><img alt=HTML5拓扑图形组件设计之道 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/969b2ba802b64d408ba1231a0320b36d><p class=pgc-img-caption></p></div><p>实现的最终效果如上图所示，模型数据就两个数值，一个代表CPU占用率，一个代表内存占用率，左侧通过HT的图形组件GraphView自定义了矢量图形展示，右上角自定义了属性页PropertyView的两单元格的Renderer，右下角两个Slider可拖动改变CPU和MEN值。</p><p>此例子麻雀虽小五脏俱全，三个部分分别采用三种方式实现了自定义组件，同时不同组件共享同一数据源，在呈现的基础上还支持桌面和移动端的Mouse和Touch的交互，还有不同终端屏幕的组件布局功能。</p><p>业务上需要在占用率小于40%时呈现律师，40%-70%时显示黄色，超过70%时呈现红色，因此定义了如下getColor的工具函数：</p><p>getColor = function(value) {</p><p>if (value &lt; 40)</p><p>return '#00A406';</p><p>if (value &lt; 70)</p><p>return '#FFCC00';</p><p>return '#A60000';</p><p>};</p><p>PropertyView上采用的最基础和原始的方式，通过Canvas画笔进行单元格的自定义绘制，在注册PropertyView时重载drawPropertyValue函数即可实现单元格自定义Renderer的绘制</p><p>drawFunc = function(g, value, x, y, w, h){</p><p>g.fillStyle = '#A1A1A3';</p><p>g.beginPath();</p><p>g.rect(x, y, w, h);</p><p>g.fill();</p><p>g.fillStyle = getColor(value);</p><p>g.beginPath();</p><p>g.rect(x, y, w * value / 100, h);</p><p>g.fill();</p><p>ht.Default.drawText(g, value + '%', '12px Arial', 'white', x, y, w, h, 'center');</p><p>};</p><p>propertyView.addProperties([</p><p>{</p><p>displayName: 'CPU',</p><p>drawPropertyValue: function(g, property, value, rowIndex, x, y, w, h, data, view) {</p><p>drawFunc(g, data.a('cpu'), x, y, w, h);</p><p>}</p><p>},</p><p>{</p><p>displayName: 'MEM',</p><p>drawPropertyValue: function(g, property, value, rowIndex, x, y, w, h, data, view) {</p><p>drawFunc(g, data.a('mem'), x, y, w, h);</p><p>}</p><p>}</p><p>]);</p><p>Slider拉条部分直接在HT封装的组件之上应用，因而无需接触到最底层的Canvas画笔绘制，仅需要在onValueChanged时更新leftBackgroud拉条左侧颜色即可，其实也可以通过重载Slider的getLeftBackground函数实现：</p><p>formPane.addRow(['CPU', {</p><p>slider: {</p><p>step: 1,</p><p>onValueChanged: function(){</p><p>var value = this.getValue();</p><p>node.a('cpu', value);</p><p>this.setLeftBackground(getColor(value));</p><p>},</p><p>value: node.a('cpu')</p><p>}</p><p>}], [50, 0.1]);</p><p>formPane.addRow(['MEM', {</p><p>slider: {</p><p>step: 1,</p><p>onValueChanged: function(){</p><p>var value = this.getValue();</p><p>node.a('mem', value);</p><p>this.setLeftBackground(getColor(value));</p><p>},</p><p>value: node.a('mem')</p><p>}</p><p>}], [50, 0.1]);</p><p>GraphView部分采用了《HT全矢量化的图形组件设计》文章介绍的HT自定义的矢量方式来实现图形效果，这种方式介于以上两种扩展方式之间，需要自定义绘制效果，但通过HT提供的矢量格式，用户可采用较为直观易读的JSON格式来描述图形，并通过数据绑定的方式实现模型数据与界面呈现的关联，避免如第一种自定义renderer的方式，即需要接触到底层绘制函数，同时业务逻辑代码与绘制代码混杂一起不易维护的问题。</p><p>ht.Default.setImage('server_image', {</p><p>width: 300,</p><p>height: 200,</p><p>comps: [</p><p>{</p><p>type: "roundRect",</p><p>rect: [3, 5, 291, 189],</p><p>background: "#E3E3E3",</p><p>gradient: "linear.northeast",</p><p>shadow: true</p><p>},</p><p>{</p><p>type: "text",</p><p>text: "CPU",</p><p>font: "16px Arial",</p><p>rect: [20, 45, 59, 41]</p><p>},</p><p>{</p><p>type: "text",</p><p>text: "MEM",</p><p>font: "16px Arial",</p><p>rect: [20, 108, 59, 41]</p><p>},</p><p>{</p><p>type: "rect",</p><p>rect: [82, 55, 145, 22],</p><p>background: "#A1A1A3"</p><p>},</p><p>{</p><p>type: "rect",</p><p>rect: {</p><p>func: function(data) {</p><p>return [82, 55, 145 * data.a('cpu') / 100, 22];</p><p>}</p><p>},</p><p>background: {</p><p>func: function(data) {</p><p>return getColor(data.a('cpu'));</p><p>}</p><p>}</p><p>},</p><p>{</p><p>type: "rect",</p><p>rect: [82, 117, 145, 22],</p><p>background: "#A1A1A3"</p><p>},</p><p>{</p><p>type: "rect",</p><p>rect: {</p><p>func: function(data) {</p><p>return [82, 117, 145 * data.a('mem') / 100, 22];</p><p>}</p><p>},</p><p>background: {</p><p>func: function(data) {</p><p>return getColor(data.a('mem'));</p><p>}</p><p>}</p><p>},</p><p>{</p><p>type: "text",</p><p>font: "16px Arial",</p><p>rect: [240, 49, 53, 31],</p><p>text: {</p><p>func: function(data) {</p><p>return data.a('cpu') + '%';</p><p>}</p><p>},</p><p>color: {</p><p>func: function(data) {</p><p>return getColor(data.a('cpu'));</p><p>}</p><p>}</p><p>},</p><p>{</p><p>type: "text",</p><p>font: "16px Arial",</p><p>rect: [240, 108, 47, 39],</p><p>text: {</p><p>func: function(data) {</p><p>return data.a('mem') + '%';</p><p>}</p><p>},</p><p>color: {</p><p>func: function(data) {</p><p>return getColor(data.a('mem'));</p><p>}</p><p>}</p><p>}</p><p>]</p><p>});</p><p>以上代码注册了名为server-image的图片，绑定了attr上的mem和cpu的两个属性，因此做完这些手脚架的基础工作后，应用人员只需要构建ht.Node对象，通过node.setImage('server-image')即可实现该图元在GraphView上呈现'server-image'描述的矢量效果，并且PropertyView、Slider和GraphView三个组件都通过node的attr上的cpu和mem来显示界面，这样当后台获取到采集的实时数据后，只需要更新到node的attr上的cpu和mem属性，则界面上的所有组件就会自定更新显示：</p><p>node = new ht.Node();</p><p>node.setName('SERVER');</p><p>node.setImage('server_image');</p><p>node.a({</p><p>cpu: 30,</p><p>mem: 70</p><p>});</p><p>dataModel.add(node);</p><p>当然实际应用中并不需要拉条改变CPU和MEN值，这些值一般通过后台采集实时自动更新仅作为呈现，但有了前端这些组件的一站式支持，我们不需要连接后台也可以很方便在客户端进行模拟测试，有了这样的机制我们就可以分离模块一步步测试，例如我们现在不需要连接服务器也可以测试矢量描述定义的是否正确，数值改变后绿黄红的业务颜色更新是否正确，各个组件的数据同步是否正常，Mouse和Touch交互是否能正常操作，界面在不同设备屏幕上显示是否正常等等，这些纯客户端组件的封装工作都做到位后，你就可以安心连接后台数据进行测试了。</p><div class=pgc-img><img alt=HTML5拓扑图形组件设计之道 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a8f683be83ac4ca5bc7aa82037f1de7c><p class=pgc-img-caption></p></div><p>见过太多客户出问题时只会说：界面显示不对。这样的问题描述完全无法定位根源，到底时后台数据库问题，网络通讯问题，解析数据问题，设置模型问题还是组件封装问题？这也是MVC/MVP/MVVM存在的另外一个层面的意义，MV*除了事件派发数据绑定外，能更好的进行呈现、模型和业务逻辑的分工切割进行独立测试的重要意义，就行TCP/IP七层协议的分类，每个协议层都应该确保正确实现自己的协定约定，并且每一层可进行独立的测试，这才是可维护可扩展的系统，因此对于HT客户遇到问题时，我们一般也是一层层的帮忙梳理找根源，如果矢量描述没问题呈现出错，那是HT组件库的问题，如果模拟到Node上的attr数据显示正确，那就去找找实际运行后台通信解析后的数据是否正确的设置到模型上，这样一步步的分析很容易就能定位到问题的根源。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'HTML5','拓扑','图形'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>