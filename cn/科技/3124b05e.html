<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征 | 极客快訊</title><meta property="og:title" content="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/468f04ac2bd54fc499c15258805d297b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3124b05e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3124b05e.html><meta property="article:published_time" content="2020-10-29T21:09:23+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:23+08:00"><meta name=Keywords content><meta name=description content="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3124b05e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>本文主要对opencv中图像的轮廓检测和轮廓特性进行了相关的介绍，基本涵盖了日常使用的一些轮廓方法，大家可以一起来了解了解~</p><hr><h1 class=pgc-h-arrow-right>目录</h1><p><strong>OpenCV 中的轮廓</strong></p><ul><li>寻找轮廓</li><li>绘制轮廓</li><li>轮廓层级</li></ul><p><strong>轮廓的特征</strong></p><ul><li>图像矩</li><li>轮廓面积</li><li>轮廓周长</li><li>外接矩形</li><li>最小外接圆</li><li>拟合椭圆</li><li>形状匹配</li><li>轮廓近似</li><li>凸包</li><li>凸面缺陷</li><li>点到轮廓距离</li></ul><h1 class=pgc-h-arrow-right>OpenCV 中的轮廓</h1><p>✏️问：什么是轮廓？</p><p>️答：轮廓是一系列相连的点组成的曲线，代表了物体的基本外形，相对于边缘，轮廓是连续的，边缘并不全部连续。</p><p>✏️问：如何寻找轮廓？</p><p>️答：寻找轮廓的操作一般用于二值化图，所以通常会使用阈值分割或Canny边缘检测先得到二值图</p><blockquote><p>PS：寻找轮廓是针对白色物体的，一定要保证物体是白色，而背景是黑色，不然很多人在寻找轮廓时会找到图片最外面的一个框。</p></blockquote><h1 class=pgc-h-arrow-right>寻找轮廓</h1><p>❣️调用 cv2.findContours() 函数:</p><pre><code>import cv2img = cv2.imread('handwriting.jpg')img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)# 寻找二值化图中的轮廓image, contours, hierarchy = cv2.findContours(    thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)print(len(contours))  # 结果应该为2</code></pre><ul><li>参数1：二值化原图</li><li>参数2：轮廓的查找方式，一般使用cv2.RETR_TREE，表示提取所有的轮廓并建立轮廓间的层级。</li><li>参数3：轮廓的近似方法。比如对于一条直线，我们可以存储该直线的所有像素点（cv2.CHAIN_APPOX_NONE），也可以只存储起点和终点。使用 cv2.CHAIN_APPROX_SIMPLE 就表示用尽可能少的像素点表示轮廓.</li></ul><h1 class=pgc-h-arrow-right>绘制轮廓</h1><p>❣️调用 cv2.drawContours() 函数：</p><pre><code>cv2.drawContours(img, contours, -1, (0,0,255),2)</code></pre><p>️其中参数2就是得到的contours，参数3表示要绘制哪一条轮廓，-1表示绘制所有轮廓，参数4是颜色（B/G/R通道，所以(0,0,255)表示红色），参数5是线宽.</p><p>️一般情况下，我们会首先获得要操作的轮廓，再进行轮廓绘制及分析：</p><pre><code>cnt = contours[1]cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2)</code></pre><h1 class=pgc-h-arrow-right>轮廓层级</h1><p><br></p><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/468f04ac2bd54fc499c15258805d297b><p class=pgc-img-caption>轮廓层级</p></div><p>图中总共有8条轮廓，2和2a分别表示外层和里层的轮廓，3和3a也是一样。从图中看得出来：</p><ul><li>轮廓0/1/2是最外层的轮廓，我们可以说它们处于同一轮廓等级：0级</li><li>轮廓2a是轮廓2的子轮廓，反过来说2是2a的父轮廓，轮廓2a算一个等级：1级</li><li>同样3是2a的子轮廓，轮廓3处于一个等级：2级</li><li>类似的，3a是3的子轮廓，等等…………</li></ul><p>️ OpenCV中轮廓等级的表示:如果我们打印出cv2.findContours()函数的返回值hierarchy，会发现它是一个包含4个值的数组：<strong>[Next, Previous, First Child, Parent]</strong></p><ul><li>Next: 与当前轮廓处于同一层级的下一条轮廓，没有为-1。</li><li>Previous: 与当前轮廓处于同一层级的上一条轮廓，没有为-1。</li><li>Firtst Child: 当前轮廓的第一条子轮廓，没有为-1。</li><li>Parent: 当前轮廓的父轮廓，没有为-1。</li></ul><p>️ 轮廓的四种寻找方式：</p><ul><li>RETR_LIST：所有轮廓属于同一层级</li><li>RETR_TREE: 完整建立轮廓的各属性</li><li>RETR_EXTERNAL: 只寻找最高层级的轮廓</li><li>RETR_CCOMP: 所有轮廓分2个层级，不是外界就是最里层</li></ul><p>✏️问：如何把下图的三个内圈填满灰色？</p><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1bd986d1a01f4844adc2e4c99c27a178><p class=pgc-img-caption>灰色填充</p></div><p>️代码如下：</p><pre><code>import cv2import numpy as npimg = cv2.imread('circle_ring.jpg')img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)_,th = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)# 寻找轮廓，使用cv2.RETR_CCOMP寻找内外轮廓image, contours, hierarch = cv2.findContours(th, cv2.RETR_CCOMP, 2)# 找到内层轮廓并填充# hierarchy的形状为(1,6,4)，使用np.squeeze压缩一维数据，变成(6,4)hierarchy = np.squeeze(hierarchy)for i in range(len(contours)):    # 存在父轮廓，说明是里层    if (hierarchy[i][3] != -1):        cv2.drawContours(img, contours, i, (180, 215, 215), -1)cv2.imwrite('result.jpg', img)</code></pre><h1 class=pgc-h-arrow-right>轮廓的特征</h1><ul><li>计算物体的周长、面积、质心、最小外接矩形等 ⛳️</li><li>OpenCV函数：cv2.contourArea(), cv2.arcLength(), cv2.approxPolyDP()等 ⛳️</li></ul><h1 class=pgc-h-arrow-right>图像矩</h1><ul><li>图像矩可以帮助我们计算图像的质心，面积等；</li><li>函数 cv2.moments() 会将计算得到的矩以字典形式返回。</li></ul><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b3ceeb408ec943b98febeb698ba92645><p class=pgc-img-caption>图像轮廓</p></div><pre><code>import cv2import numpy as npimg = cv2.imread('handwriting.jpg', 0)_, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)image, contours, hierarchy = cv2.findContours(thresh, 3, 2)# 以数字3的轮廓为例cnt = contours[0]img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)img_color2 = np.copy(img_color1)cv2.drawContours(img_color1, [cnt], 0, (0, 0, 255), 2)cv2.imshow('img',img_color1)cv2.waitKey(0)</code></pre><p>️采用图像矩</p><pre><code>M = cv2.moments(cnt)# 对象的质心cx = int(M['m10'] / M['m00'])cy = int(M['m01'] / M['m00'])</code></pre><p>✔️M中包含了很多轮廓的特征信息，比如M[‘m00’]表示轮廓面积，与cv2.contourArea() 计算结果是一样的.</p><h1 class=pgc-h-arrow-right>轮廓面积</h1><pre><code>area = cv2.contourArea(cnt)</code></pre><p>✔️注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。</p><blockquote><p>如果统计二值图中像素点个数，应尽量避免循环，可以使用cv2.countNonZero()，更加高效。</p></blockquote><h1 class=pgc-h-arrow-right>轮廓周长</h1><pre><code>perimeter = cv2.arcLength(cnt, True)</code></pre><p>✔️ 参数2表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是True。</p><h1 class=pgc-h-arrow-right>外接矩形</h1><ul><li>形状的外接矩形有两种，如下图，绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转：</li></ul><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/689cf209791c493f86d9f0f3f276775d><p class=pgc-img-caption>外接矩形</p></div><p>1️⃣ 外接矩形：</p><pre><code>x, y, w, h = cv2.boundingRect(cnt)</code></pre><p>2️⃣ 最小外接矩形：</p><pre><code>rect = cv2.minAreaRect(cnt)# 矩形四个角点取整box = np.int0(cv2.boxPoints(rect))cv2.drawContours(img_color1, [box], 0, (255, 0, 0), 2)</code></pre><p>✔️ np.int0(x) 是把x取整的操作，比如377.93就会变成377，也可以用x.astype(np.int)</p><h1 class=pgc-h-arrow-right>最小外接圆</h1><pre><code>(x, y), radius = cv2.minEnclosingCircle(cnt)(x, y, radius) = cv2.int0((x, y, radius))cv2.circle(img_color2, (x,y), radius, (0, 0, 255), 2)</code></pre><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/329ba735661d418a91f3363a5e76c19a><p class=pgc-img-caption>最小外接圆</p></div><h1 class=pgc-h-arrow-right>拟合椭圆</h1><pre><code>ellipse = cv2.fitEllipse(cnt)cv2.ellipse(img_color2, ellipse, (255,255,0), 2)</code></pre><h1 class=pgc-h-arrow-right>形状匹配</h1><ul><li>cv2.matchShapes()可以检测两个形状之间的相似度，返回值越小，越相似 ⛳️</li></ul><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fdc25c96f3804b249e112d6422052ab8><p class=pgc-img-caption>形状匹配</p></div><pre><code>img = cv2.imread('shapes.jpg', 0)_, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)image, contours, hierarchy = cv2.findContours(thresh, 3, 2)img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR)  # 用于绘制的彩色图</code></pre><p>图中有3条轮廓，我们用A/B/C表示：</p><pre><code>cnt_a, cnt_b, cnt_c = contours[0], contours[1], contours[2]print(cv2.matchShapes(cnt_b, cnt_b, 1, 0.0))  # 0.0print(cv2.matchShapes(cnt_b, cnt_c, 1, 0.0))  # 2.17e-05print(cv2.matchShapes(cnt_b, cnt_a, 1, 0.0))  # 0.418</code></pre><p>✔️ 可以看到BC相似程度比AB高很多，并且图形的旋转或缩放并没有影响。其中，参数3是匹配方法，参数4是OpenCV的预留参数，暂时没有实现，可以不用理会。</p><h1 class=pgc-h-arrow-right>轮廓近似</h1><ul><li>将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定，用的Douglas-Peucker算法。⛳️</li></ul><pre><code>import cv2import numpy as np# 1.先找到轮廓img = cv2.imread('unregular.jpg', 0)_, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)image, conturs, hierarchy = cv2.findContours(thresh, 3, 2)cnt = contours[0]# 2.进行多边形逼近，得到多边形的角点approx = cv2.approxPolyDP(cnt, 3, True)# 3.画出多边形image = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR)cv2.polylines(image, [approx], True, (0, 255, 0), 2)</code></pre><p>其中cv2.approxPolyDP() 的参数2(epsilonepsilon)是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数3表示是否闭合。</p><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4166d943f4a54158904e84f479ce29ae><p class=pgc-img-caption>轮廓近似</p></div><h1 class=pgc-h-arrow-right>凸包</h1><ul><li>凸包跟多边形逼近很像，只不过它是物体最外层的”凸”多边形：集合A内连接任意两个点的直线都在A的内部，则称集合A是凸形的。如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷(Convexity Defects)，凸缺陷常用来进行手势识别等。</li></ul><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14b9b90ff0284b2eab074a91577b71f8><p class=pgc-img-caption></p></div><pre><code>import cv2img = cv2.imread('convex.jpg', 0)_, th = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY+cv2.THRESH_OTSU)image, contours, hierarchy = cv2.findContours(th, 3, 2)cnt = contours[0]image = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR)cv2.drawContours(image, contours, -1, (0, 0 , 255), 2)# 寻找凸包，得到凸包的角点hull = cv2.convexHull(cnt)# 绘制凸包cv2.polylines(image, [hull], True, (0, 255, 0), 2)</code></pre><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d591d07793f413bb441c89ed845cf22><p class=pgc-img-caption></p></div><p>✔️ 其中函数cv2.convexHull()有个可选参数returnPoints，默认是True，代表返回角点的x/y座标；如果为False的话，表示返回轮廓中是凸包角点的索引，比如说：</p><pre><code>print(hull[0])  # [[362 184]]（座标）hull2 = cv2.convexHull(cnt, returnPoints=False)print(hull2[0])  # [510]（cnt中的索引）print(cnt[510])  # [[362 184]]</code></pre><p>✔️ 当使用cv2.convexityDefects()计算凸包缺陷时，returnPoints需为False</p><p>✔️ 另外可以用下面的语句来判断轮廓是否是凸形的：</p><pre><code>print(cv2.isContourConvex(hull))  # True</code></pre><h1 class=pgc-h-arrow-right>凸面缺陷</h1><ul><li>OpenCV提供了现成的函数来做这个，cv2.convexityDefects().</li><li>注意：我们要传returnPointsFalse来找凸形外壳。</li><li>它返回了一个数组，每行包含这些值：<strong>[start point, end point, farthest point, approximate distance to farthest point]</strong>.我们可以用图像来显示他们。我们画根线把start point和end point连起来。然后画一个圆在最远点。记住最前三个返回值是 cnt 的索引，所以我们我们得从 cnt 里拿出这些值.</li></ul><pre><code>import cv2import numpy as npimg = cv2.imread('star.jpg')img_gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret, thresh = cv2.threshold(img_gray, 127, 255,0)_,contours,hierarchy = cv2.findContours(thresh,2,1)cnt = contours[2]# 返回凸包角点的索引hull = cv2.convexHull(cnt,returnPoints = False)# 检测凸凹陷defects = cv2.convexityDefects(cnt,hull)# 可视化for i in range(defects.shape[0]):    s,e,f,d = defects[i,0]    start = tuple(cnt[s][0])    end = tuple(cnt[e][0])    far = tuple(cnt[f][0])    cv2.line(img,start,end,[0,255,0],2)    cv2.circle(img,far,5,[0,0,255],-1)</code></pre><div class=pgc-img><img alt="Opencv从零开始 - 「启蒙篇」- 轮廓和轮廓特征" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e98af69d0f3a468cae27a5e3c6932844><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>点到轮廓距离</h1><ul><li>cv2.pointPolygonTest() 函数计算点到轮廓的最短距离（也就是垂线），又称多边形测试：</li></ul><pre><code>dist = cv2.pointPolygonTest(cnt, (100, 100), True)  # -3.53</code></pre><p>✔️ 其中参数3为True时表示计算距离值：点在轮廓外面值为负，点在轮廓上值为0，点在轮廓里面值为正；参数3为False时，只返回-1/0/1表示点相对轮廓的位置，不计算距离。</p><p><br></p><h1 class=pgc-h-arrow-right>未完待续~</h1><p>------------------------------------------------可爱の分割线------------------------------------------------</p><p>更多Opencv教程将后续发布，<strong>欢迎关注哟~</strong>❤️❤️❤️</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'轮廓','特征','Opencv'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>