<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>常用的NIO框架-Netty | 极客快訊</title><meta property="og:title" content="常用的NIO框架-Netty - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8121b707a0c043b5a0087400f083f24e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3199586.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><meta property="article:published_time" content="2020-10-29T20:51:14+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:14+08:00"><meta name=Keywords content><meta name=description content="常用的NIO框架-Netty"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3199586.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>常用的NIO框架-Netty</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><a class=pgc-link data-content=mp data-source=innerLink href=https://www.toutiao.com/item/6883067855705735693/ rel="noopener noreferrer" target=_blank>架构师-网络文章汇总</a></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1. Netty简介</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty是一个高性能、异步事件驱动的NIO框架，基于JAVA NIO提供的API实现。它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。 作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2. Netty线程模型</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在JAVA NIO方面Selector给Reactor模式提供了基础，Netty结合Selector和Reactor模式设计了高效的线程模型。先来看下Reactor模式：</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.1 Reactor模式</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Wikipedia这么解释Reactor模型：“The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.”。首先Reactor模式首先是事件驱动的，有一个或者多个并发输入源，有一个Server Handler和多个Request Handlers，这个Service Handler会同步的将输入的请求多路复用的分发给相应的Request Handler。可以如下图所示：</span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8121b707a0c043b5a0087400f083f24e><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">从结构上有点类似生产者和消费者模型，即一个或多个生产者将事件放入一个Queue中，而一个或者多个消费者主动的从这个队列中poll事件来处理；而Reactor模式则没有Queue来做缓冲，每当一个事件输入到Service Handler之后，该Service Handler会主动根据不同的Evnent类型将其分发给对应的Request Handler来处理。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.2 Reator模式的实现</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">关于Java NIO 构造Reator模式，Doug lea在《Scalable IO in Java》中给了很好的阐述，这里截取PPT对Reator模式的实现进行说明</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1.第一种实现模型如下：<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/807e41841c9443edb449ac46324a5e6e><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这是最简单的Reactor单线程模型，由于Reactor模式使用的是异步非阻塞IO，所有的IO操作都不会被阻塞，理论上一个线程可以独立处理所有的IO操作。这时Reactor线程是个多面手，负责多路分离套接字，Accept新连接，并分发请求到处理链中。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对于一些小容量应用场景，可以使用到单线程模型。但对于高负载，大并发的应用却不合适，主要原因如下：</span></p><ol start=1><li>当一个NIO线程同时处理成百上千的链路，性能上无法支撑，即使NIO线程的CPU负荷达到100%，也无法完全处理消息</li><li>当NIO线程负载过重后，处理速度会变慢，会导致大量客户端连接超时，超时之后往往会重发，更加重了NIO线程的负载。</li><li>可靠性低，一个线程意外死循环，会导致整个通信系统不可用</li></ol><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">为了解决这些问题，出现了Reactor多线程模型。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.Reactor多线程模型：<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37b7fd79de7d4ee7a5ba1edeca6876bc><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">相比上一种模式，该模型在处理链部分采用了多线程（线程池）。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在绝大多数场景下，该模型都能满足性能需求。但是，在一些特殊的应用场景下，如服务器会对客户端的握手消息进行安全认证。这类场景下，单独的一个Acceptor线程可能会存在性能不足的问题。为了解决这些问题，产生了第三种Reactor线程模型</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">3.Reactor主从模型<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48c314ddc1c24f7eabb3a06ff6c055b4><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">该模型相比第二种模型，是将Reactor分成两部分，mainReactor负责监听server socket，accept新连接；并将建立的socket分派给subReactor。subReactor负责多路分离已连接的socket，读写网络数据，对业务处理功能，其扔给worker线程池完成。通常，subReactor个数上可与CPU个数等同。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.3 Netty模型</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.2中说完了Reactor的三种模型，那么Netty是哪一种呢？其实Netty的线程模型是Reactor模型的变种，那就是去掉线程池的第三种形式的变种，这也是Netty NIO的默认模式。Netty中Reactor模式的参与者主要有下面一些组件：</span></p><ol start=1><li>Selector</li><li>EventLoopGroup/EventLoop</li><li>ChannelPipeline</li></ol><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Selector即为NIO中提供的SelectableChannel多路复用器，充当着demultiplexer的角色，这里不再赘述；下面对另外两种功能和其在Netty之Reactor模式中扮演的角色进行介绍。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.EventLoopGroup/EventLoop</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当系统在运行过程中，如果频繁的进行线程上下文切换，会带来额外的性能损耗。多线程并发执行某个业务流程，业务开发者还需要时刻对线程安全保持警惕，哪些数据可能会被并发修改，如何保护？这不仅降低了开发效率，也会带来额外的性能损耗。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">为了解决上述问题，Netty采用了串行化设计理念，从消息的读取、编码以及后续Handler的执行，始终都由IO线程EventLoop负责，这就</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">意外着</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">整个流程不会进行线程上下文的切换，数据也不会面临被并发修改的风险。这也解释了为什么Netty线程模型去掉了Reactor主从模型中线程池。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">EventLoopGroup是一组EventLoop的抽象，EventLoopGroup提供next接口，可以总一组EventLoop里面按照一定规则获取其中一个EventLoop来处理任务，对于EventLoopGroup这里需要了解的是在Netty中，在Netty服务器编程中我们需要BossEventLoopGroup和WorkerEventLoopGroup两个EventLoopGroup来进行工作。通常一个服务端口即一个ServerSocketChannel对应一个Selector和一个EventLoop线程，也就是说BossEventLoopGroup的线程数参数为1。BossEventLoop负责接收客户端的连接并将SocketChannel交给WorkerEventLoopGroup来进行IO处理。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">EventLoop的实现充当Reactor模式中的分发（Dispatcher）的角色。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">4.ChannelPipeline</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ChannelPipeline其实是担任着Reactor模式中的请求处理器这个角色。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ChannelPipeline的默认实现是DefaultChannelPipeline，DefaultChannelPipeline本身维护着一个用户不可见的tail和head的ChannelHandler，他们分别位于链表队列的头部和尾部。tail在更上层的部分，而head在靠近网络层的方向。在Netty中关于ChannelHandler有两个重要的接口，ChannelInBoundHandler和ChannelOutBoundHandler。inbound可以理解为网络数据从外部流向系统内部，而outbound可以理解为网络数据从系统内部流向系统外部。用户实现的ChannelHandler可以根据需要实现其中一个或多个接口，将其放入Pipeline中的链表队列中，ChannelPipeline会根据不同的IO事件类型来找到相应的Handler来处理，同时链表队列是责任链模式的一种变种，自上而下或自下而上所有满足事件关联的Handler都会对事件进行处理。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ChannelInBoundHandler对从客户端发往服务器的报文进行处理，一般用来执行半包/粘包，解码，读取数据，业务处理等；ChannelOutBoundHandler对从服务器发往客户端的报文进行处理，一般用来进行编码，发送报文到客户端。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">下图是对ChannelPipeline执行过程的说明：<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/489b64c3390341bdb4b1300cf6d1dc6e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">5.Buffer</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty提供的经过扩展的Buffer相对NIO中的有个许多优势，作为数据存取非常重要的一块，我们来看看Netty中的Buffer有什么特点。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1.ByteBuf读写指针</span></p><ul><li>在ByteBuffer中，读写指针都是position，而在ByteBuf中，读写指针分别为readerIndex和writerIndex，直观看上去ByteBuffer仅用了一个指针就实现了两个指针的功能，节省了变量，但是当对于ByteBuffer的读写状态切换的时候必须要调用flip方法，而当下一次写之前，必须要将Buffe中的内容读完，再调用clear方法。每次读之前调用flip，写之前调用clear，这样无疑给开发带来了繁琐的步骤，而且内容没有读完是不能写的，这样非常不灵活。相比之下我们看看ByteBuf，读的时候仅仅依赖readerIndex指针，写的时候仅仅依赖writerIndex指针，不需每次读写之前调用对应的方法，而且没有必须一次读完的限制。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.零拷贝</span></p><ul><li>Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</li><li>Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。</li><li>Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">3.引用计数与池化技术</span></p><ul><li>在Netty中，每个被申请的Buffer对于Netty来说都可能是很宝贵的资源，因此为了获得对于内存的申请与回收更多的控制权，Netty自己根据引用计数法去实现了内存的管理。Netty对于Buffer的使用都是基于直接内存（DirectBuffer）实现的，大大提高I/O操作的效率，然而DirectBuffer和HeapBuffer相比之下除了I/O操作效率高之外还有一个天生的缺点，即对于DirectBuffer的申请相比HeapBuffer效率更低，因此Netty结合引用计数实现了PolledBuffer，即池化的用法，当引用计数等于0的时候，Netty将Buffer回收致池中，在下一次申请Buffer的没某个时刻会被复用。</li></ul><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">总结</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty其实本质上就是Reactor模式的实现，Selector作为多路复用器，EventLoop作为转发器，Pipeline作为事件处理器。但是和一般的Reactor不同的是，Netty使用串行化实现，并在Pipeline中使用了责任链模式。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty中的buffer相对有NIO中的buffer又做了一些优化，大大提高了性能。</span></p><p><br></p><p>关于Netty的更多介绍，可以参考我前面的Netty系列文章。</p><p><a class=pgc-link data-content=mp data-source=innerLink href=https://www.toutiao.com/item/6876247461719966211/ rel="noopener noreferrer" target=_blank>「Netty核心技术」7-ChannelHandler源码</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'NIO','Netty','框架'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>