<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>动画学数据结构：轻松掌握树状数组 | 极客快訊</title><meta property="og:title" content="动画学数据结构：轻松掌握树状数组 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b713cfea7b2e4129af1ecdeb6d42df7e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3409557f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3409557f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3409557f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3409557f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3409557f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3409557f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3409557f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3409557f.html><meta property="article:published_time" content="2020-11-14T21:00:20+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:20+08:00"><meta name=Keywords content><meta name=description content="动画学数据结构：轻松掌握树状数组"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3409557f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>动画学数据结构：轻松掌握树状数组</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b713cfea7b2e4129af1ecdeb6d42df7e><p class=pgc-img-caption></p></div><p>本文来源于力扣圈子，作者：胡小旭。原文链接：<a class=pgc-link data-content=mp href=https://leetcode-cn.com/circle/article/OeMXPy/ target=_blank>力扣</a>（点击查看）</p><p>“树状数组或二叉索引树（英语：Binary Indexed Tree），又以其发明者命名为 Fenwick 树。其初衷是解决数据压缩里的累积频率（Cumulative Frequency）的计算问题，现多用于高效计算数列的前缀和， 区间和。它可以以 O(logn) 的时间得到任意前缀和，并同时支持在 O(logn) 时间内支持动态单点值的修改。空间复杂度 O(n)。”</p><p>文章先介绍低位运算（lowbit）的基本知识，再提及如何将一个整数划分为 logn 个区间的运算过程，进而延展到如何将线性序列以树行结构进行存取，接着介绍高级数据结构——树状数组的两个基本操作——查询前缀和与单点增加，最后介绍了树状数组的一个应用——求解逆序对数。</p><p><br></p><h1 class=pgc-h-arrow-right>lowbit（低位）运算</h1><p>lowbit(n) 定义为非负整数 n 在二进制表示下 “最低位的 1 及其后边所有的 0”构成的数值。</p><p>比如：n = 10，其二进制表示为</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0732fa47c7714e72a4e5bfca91803a8f><p class=pgc-img-caption></p></div><p>则其低位</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8596555cfa1345e1b0205b270618af3d><p class=pgc-img-caption></p></div><p><br></p><p><strong>公式</strong></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9387d97c2bc741a3a30f78f959d8afcf><p class=pgc-img-caption></p></div><p><strong>如何计算一个整数 n 中二进制表示下所有位是 1 的数值</strong>？</p><p>比如 n = 10，则其二进制表示下所有位是 1 的数值有：</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c63b526947cf47a2990440c6981c152e><p class=pgc-img-caption></p></div><p>朴素算法需要枚举整数中所有的位，时间复杂度为 O(len)，len 为整数 n 的二进制表示下的位数。</p><p>为了高效获取二进制表示下所有位是 1 的数值，可以利用 lowbit 运算，得到时间复杂度 O(len)，len 为二进制表示下为 1 的位的个数。</p><p>比如 n = 10，lowbit(10) = 2；接着令 n = n - lowbit(n) = 10 - 2 = 8，则 lowbit(n) = lowbit(8) = 8；接着令 n = n - lowbit(n) = 8 - 8 = 0，停止。</p><p>为了得到 n 的第几位为 1，可以对 2 和 8 分别取对数，即</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d7732871944404e89d4c795fe761397><p class=pgc-img-caption></p></div><p>由于 C++ math.h 库的 log 函数是以 e 为底的实数运算，并且复杂度常数较大，所以可以通过预处理，利用哈希表来代替 log 运算。</p><p><strong>C++ 实现</strong></p><p><br></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dfa7dcb086fb4df1892fd39165f170a2><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>树状数组</h1><p>假设整数 n，其二进制表示形式为：</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ac2efbdbe534da8a2573da4593459e5><p class=pgc-img-caption></p></div><p>代表二进制表示下位为 1 的索引下标值，且假设</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b8566b9291745d6af64d76eefae69b8><p class=pgc-img-caption></p></div><p>那么，可以将区间 [1，n] 划分成 log n 个小区间</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90d732c1467646f9a61eda5df3412c3b><p class=pgc-img-caption></p></div><p>比如，</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4658c1444e9b4a2fa99fe0c50d43c231><p class=pgc-img-caption></p></div><p>那么 [1，7] 区间可以划分成 [1，4] ，[5，6] 和 [7，7]，其区间长度分别为 lowbit(4) = 4，lowbit(6) = 2 和 lowbit(7) = 1。</p><p>利用 lowbit 运算计算区间：</p><p><strong>C++ 实现</strong></p><p><br></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0058dd314fc54563bf6768ad4060261a><p class=pgc-img-caption></p></div><p>树状数组是基于以上思想的数据结构，基本用途是维护序列的前缀和。</p><p>那么，假设有序列 A = {1,2,3,4,5,6,7,8}，现在的问题就是如何将这个序列划分成 log n 个小区间。不妨，利用序列的索引值（以 1 为起点开始计数），根据上述计算区间的方式，将其以如下树形结构展开。</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/70ed784ffd65442089521d9ddc9772e5><p class=pgc-img-caption>树状数组（Binary Indexed Tree） 以树形结构展开的序列 A</p></div><p><br>此时，以树形结构展开的序列 A 中的每一个节点都对应着树状数组中的一个值。那么这个值为以当前节点为根的子树中所有节点值的总和。</p><p>接着，我们看下以树形结构展开的树状数组是什么样的。</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/96c1dc171f5840d4892bc5faf45f5bee><p class=pgc-img-caption>以树形结构展开的树状数组（Binary Indexed Tree）</p></div><li>Index 代表序列 A 中元素的索引，为了方便，以 1 为起点计数</li><li>Original Value 代表序列 A 中的元素值</li><li>BIT Value（Binary Indexed Tree Value)代表树状数组中的值</li><li>Binary bit 代表索引值的二进制形式</li><li>Low bit 代表索引值的二进制形式下的地位</li><p>上图中最大的区别是某些节点中的值发生了变化。这是因为，在以树形结构展开的树状数组中的每一个值代表的是一个区间的总和。这个区间即为我们上述求解的区间，比如一个整数 7，可以将其划分成 [1，4] ，[5，6] 和 [7，7] 三个小区间。那么，这三个小区间的右端值作为索引对应的树状数组中的值即为当前区间元素的总和。</p><p>比如 Index = 4 对应的树状数组的值为（BIT Value）10，它代表 [1，4] 这个区间的和。</p><p>比如 Index = 6 对应的树状数组的值为 11，它代表 [5，6] 这个区间的和。</p><p><br></p><h1 class=pgc-h-arrow-right>基本操作</h1><p>树状数组支持两个基本操作——查询前缀和，单点增加。</p><p><strong>查询前缀和</strong></p><p>在寻求序列 A 的前 n 项的前缀和时，等于 n 代表的 log n 个区间的总和。</p><p><strong>C++ 代码实现</strong></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18200cb4e97842d3a1819804809e2946><p class=pgc-img-caption></p></div><p><strong>单点增加</strong></p><p>观察父子节点的关系，可以推算出，父节点的索引 parent(i)，为其子节点索引值 + 其低位 —— parent(i) = i + lowbit(i)。</p><p><strong>C++ 代码实现</strong></p><p><br></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d77ac86d086843539315715a2e3c14b7><p class=pgc-img-caption></p></div><p>关于查询前缀和与单点增加的计算过程，可以观看下面视频展示的动画。</p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a3507c0408b47dfa98956c77b1200da><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>树状数组与逆序对</h1><p>对于一个序列 A，如果 i &lt; j，并且 A[i] > A[j] ，那么则称 A[i] 与 A[j] 构成逆序对。利用树状数组数据结构可以求解序列 A 中的逆序对个数。</p><ol start=1><li>逆序遍历序列</li><li>利用树状数组的性质，使用 query 操作获取每一个元素的逆序对数</li><li>将当前元素更新（update）到树状数组中</li><li>循环迭代上述步骤，直到遍历所有元素</li></ol><p><strong>C++ 代码实现</strong></p><div class=pgc-img><img alt=动画学数据结构：轻松掌握树状数组 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae3ad773ef1e4e2db45e1be1d7adf15f><p class=pgc-img-caption></p></div><p>在每一次更新（update）树状数组时，以元素的值作为树状数组的索引，更新的值为 +1，代表个数。</p><p>在每一次获取（query） 逆序对数时，存在于树状数组中的元素的索引值都比当前元素的大（逆序遍历），那么自然获取到的树状数组的值即为索引值比当前元素的大，且值比当前元素的小的个数。</p><p>注意，上述的求解过程时，如果序列 A 的值范围较大时，那么需要离散化处理。</p><p><br></p><p><strong>参考</strong></p><ul class=list-paddingleft-2><li>《算法竞赛进阶指南》</li><li>维基百科——树状数组</li></ul><p><br></p><p>本文作者：胡小旭</p><p>声明：本文归作者版权所有，如需转载请联系。文中图片和视频为作者“胡小旭”制作，未经允许严禁修改和翻版使用。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'动画','学数据','结构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>