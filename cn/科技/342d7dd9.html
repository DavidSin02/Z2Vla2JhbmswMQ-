<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C语言指针终极指南！（附详尽图示和代码） | 极客快訊</title><meta property="og:title" content="C语言指针终极指南！（附详尽图示和代码） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4e7017cb21b9471891cf2f2febf5befe"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/342d7dd9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/342d7dd9.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="C语言指针终极指南！（附详尽图示和代码）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/342d7dd9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C语言指针终极指南！（附详尽图示和代码）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1为什么使用指针</p><p>假如我们定义了 char a=’A’ ，当需要使用 ‘A’ 时，除了直接调用变量 a ，还可以定义 char *p=&a ，调用 a 的地址，即指向 a 的指针 p ，变量 a（ char 类型）只占了一个字节,指针本身的大小由可寻址的字长来决定，指针 p 占用 4 个字节。</p><p>但如果要引用的是占用内存空间比较大东西，用指针也还是 4 个字节即可。</p><ul><li>使用指针型变量在很多时候占用更小的内存空间。</li></ul><p>变量为了表示数据，指针可以更好的传递数据，举个例子：</p><p>第一节课是 1 班语文， 2 班数学，第二节课颠倒过来， 1 班要上数学， 2 班要上语文，那么第一节课下课后需要怎样作调整呢？方案一：课间 1 班学生全都去 2 班， 2 班学生全都来 1 班，当然，走的时候要携带上书本、笔纸、零食……场面一片狼藉；方案二：两位老师课间互换教室。</p><p>显然，方案二更好一些，方案二类似使用指针传递地址，方案一将内存中的内容重新“复制”了一份，效率比较低。</p><ul><li>在数据传递时，如果数据块较大，可以使用指针传递地址而不是实际数据，即提高传输速度，又节省大量内存。</li></ul><p>一个数据缓冲区 char buf[100] ，如果其中 buf[0,1] 为命令号, buf[2,3] 为数据类型, buf[4~7] 为该类型的数值，类型为 int ，使用如下语句进行赋值：</p><pre><code>*(short*)&amp;buf[0]=DataId;*(short*)&amp;buf[2]=DataType;*(int*)&amp;buf[4]=DataValue;</code></pre><ul><li>数据转换，利用指针的灵活的类型转换，可以用来做数据类型转换，比较常用于通讯缓冲区的填充。</li><li>指针的机制比较简单，其功能可以被集中重新实现成更抽象化的引用数据形式</li><li>函数指针，形如: #define PMYFUN (void*)(int,int) ，可以用在大量分支处理的实例当中，如某通讯根据不同的命令号执行不同类型的命令，则可以建立一个函数指针数组，进行散转。</li><li>在数据结构中，链表、树、图等大量的应用都离不开指针。</li></ul><h2 class=pgc-h-arrow-right>2 指针是什么？</h2><p>操作系统将硬件和软件结合起来，给程序员提供的一种对内存使用的抽象，这种抽象机制使得程序使用的是虚拟存储器,而不是直接操作和使用真实存在的物理存储器。所有的虚拟地址形成的集合就是虚拟地址空间。</p><p>内存是一个很大的线性的字节数组，每个字节固定由 8 个二进制位组成，每个字节都有唯一的编号，如下图，这是一个 4G 的内存，他一共有 4x1024x1024x1024 = 4294967296 个字节，那么它的地址范围就是 0 ~ 4294967296 ，十六进制表示就是 0x00000000～0xffffffff ，当程序使用的数据载入内存时，都有自己唯一的一个编号，这个编号就是这个数据的地址。指针就是这样形成的。</p><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e7017cb21b9471891cf2f2febf5befe><p class=pgc-img-caption></p></div><p>1</p><pre><code>#include &lt;stdio.h&gt;int main(void){    char ch = 'a';    int  num = 97;    printf("ch 的地址:%p\n",&amp;ch);       //ch 的地址:00BEFDF7    printf("num的地址:%p\n",&amp;num);      //num的地址:00BEFDF8    return 0;}</code></pre><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fd427d1df114365bb9e040702354c52><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c8a7ed24e8149029fa7ce76b080e947><p class=pgc-img-caption></p></div><p>指针不仅可以表示变量的地址，还可以存储各种类型数据的地址，指针变量是用来保存这些地址的变量，与数组类似，依据地址存放的数据类型，指针也分为 int 指针类型， double 指针类型， char 指针类型等等。</p><p>综上，<strong>指针的实质就是数据在内存中的地址，而指针变量是用来保存这些地址的变量</strong>。</p><h2 class=pgc-h-arrow-right>指针变量 和 指向关系</h2><p>用来保存 指针 的变量，就是指针变量。如果指针变量p保存了变量 num的地址，则就说：p指向了变量num，也可以说p指向了num所在的内存块，指针变量pp指向了p所在的内存块，以下面为例：</p><pre><code>#include &lt;stdio.h&gt;int main(void){  int num = 97;  char ch = 'a';  int *p = &amp; num;  int **pp = &amp;p  char *p1 = &amp; ch;  printf("num 的地址:%p\n",&amp;num);     printf("指针p的值:%p\n",p);     printf("指针p的地址:%p\n",&amp;p);    printf("指针pp的值:%p\n",pp);   printf("ch 的地址:%p\n",&amp;ch);    return 0;}</code></pre><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b8673b6b16b49308fe658d86a405546><p class=pgc-img-caption></p></div><p>运行结果</p><ul><li>int型的num值为97占4个字节，内存地址为: 0113F924， char 型的 ch('a')值为97占1个字节，内存地址为: 0113F91B。</li></ul><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d9862e5b5ae44e719a1cd0c5abc412ef><p class=pgc-img-caption></p></div><p>int型占4个字节</p><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cd0bdcd5189849d3b02d05e1c628f094><p class=pgc-img-caption></p></div><p>char型占1个字节</p><ul><li>num的地址为： 0113F924， num的值为 97 ，指针 p 指向 num 的内存块，指针 p 地址为： 0113F90C， p的内存保存的值就是 num的地址 0113F924。</li></ul><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2d206eff17204877aafc7ad367a5c826><p class=pgc-img-caption></p></div><p>0x0113F90C存储的内容为地址0113F924</p><ul><li>指针变量 pp 指向 指针 p，指针 pp 内存值为 指针 p 的地址： 0113F90C，形成了只想指针的指针。</li></ul><div class=pgc-img><img alt=C语言指针终极指南！（附详尽图示和代码） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0fad3ae29e7c4c6e9efccbb8159db4ab><p class=pgc-img-caption></p></div><p>指针pp为指向指针p的指针</p><h3 class=pgc-h-arrow-right>定义指针变量</h3><p>C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。</p><p>引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。</p><pre><code>int a ; //int类型变量 aint *a ; //int* 变量aint arr[3]; //arr是包含3个int元素的数组int (* arr )[3]; //arr是一个指向包含3个int元素的数组的指针变量int* p_int; //指向int类型变量的指针 double* p_double; //指向idouble类型变量的指针 struct Student *p_struct; //结构体类型的指针int(*p_func)(int,int); //指向返回类型为int，有2个int形参的函数的指针 int(*p_arr)[3]; //指向含有3个int元素的数组的指针 int** p_pointer; //指向 一个整形变量指针的指针</code></pre><h3 class=pgc-h-arrow-right>取地址</h3><p>既然有了指针变量，那就得让他保存其它变量的地址，使用& 运算符取得一个变量的地址。</p><pre><code>int add(int a , int b){    return a + b;}int main(void){    int num = 97;    float score = 10.00F;    int arr[3] = {1,2,3};    int* p_num = #    float* p_score = &amp;score    int (*p_arr)[3] = &amp;arr               int (*fp_add)(int ,int )  = add;  //p_add是指向函数add的函数指针    return 0;}</code></pre><p><strong>特殊的情况，他们并不一定需要使用&取地址</strong>：</p><ul><li>数组名的值就是这个数组的第一个元素的地址。</li><li>函数名的值就是这个函数的地址。</li><li>字符串字面值常量作为右值时，就是这个字符串对应的字符数组的名称,也就是这个字符串在内存中的地址。</li></ul><pre><code>int add(int a , int b){    return a + b;}int main(void){    int arr[3] = {1,2,3};    int* p_first = arr;    int (*fp_add)(int ,int )  =  add;    const char* msg = "Hello world";    return 0;}</code></pre><h3 class=pgc-h-arrow-right>解地址</h3><p>对一个指针解地址，就可以取到这个内存数据，解地址 的写法，就是在指针的前面加一个 * 号。</p><p>解指针的实质是：从指针指向的内存块中取出这个内存数据。</p><pre><code>int main(void){    int age = 19;    int*p_age = &amp;age    *p_age  = 20;  //通过指针修改指向的内存数据    printf("age = %d",*p_age);   //通过指针读取指向的内存数据    printf("age = %d",age);    return 0;}</code></pre><h3 class=pgc-h-arrow-right>空指针</h3><p>空指针在概念上不同于未初始化的指针。空指针可以确保不指向任何对象或函数；而未初始化的指针则可能指向任何地方。空指针不是野指针。</p><p>在C语言中，我们让指针变量赋值为NULL表示一个空指针，而C语言中，NULL实质是 ((void*)0) ， 在C++中，NULL实质是0。</p><pre><code>#ifdef __cplusplus     #define NULL    0#else         #define NULL    ((void *)0)#endif</code></pre><h3 class=pgc-h-arrow-right>void*类型指针</h3><p>void是一种特殊的指针类型，可以用来存放任意对象的地址。一个void指针存放着一个地址，这一点和其他指针类似。不同的是，我们对它到底储存的是什么对象的地址并不了解。</p><pre><code>double a=2.3;int b=5;void *p=&amp;acout&lt;&lt;p&lt;&lt;endl;   //输出了a的地址p=&amp;bcout&lt;&lt;p&lt;&lt;endl;   //输出了b的地址//cout&lt;&lt;*p&lt;&lt;endl;这一行不可以执行，void*指针只可以储存变量地址，不可以直接操作它指向的对象</code></pre><p>由于void是空类型，只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。</p><h2 class=pgc-h-arrow-right>数组和指针</h2><ul><li>同类型指针变量可以相互赋值，数组不行，只能一个一个元素的赋值或拷贝</li><li>数组在内存中是连续存放的，开辟一块连续的内存空间。数组是根据数组的下进行访问的。指针很灵活，它可以指向任意类型的数据。指针的类型说明了它所指向地址空间的内存。</li><li>数组所占存储空间的内存： sizeof（数组名） 数组的大小： sizeof（数组名）/sizeof（数据类型），在32位平台下，无论指针的类型是什么， sizeof（指针名）都是 4 ，在 64 位平台下，无论指针的类型是什么， sizeof（指针名）都是 8 。</li><li>数组名作为右值的时候，就是第一个元素的地址</li></ul><pre><code>int main(void){    int arr[5] = {1,2,3,4,5};    int *p_first = arr;    printf("%d",*p_first);  //1    return 0;}</code></pre><ul><li>指向数组元素的指针 支持 递增 递减 运算。 p= p+1意思是，让 p指向原来指向的内存块的下一个相邻的相同类型的内存块。在数组中相邻内存就是相邻下标元素。</li></ul><h2 class=pgc-h-arrow-right>函数与指针</h2><h3 class=pgc-h-arrow-right>函数的参数和指针</h3><p>C语言中，实参传递给形参，是按值传递的，也就是说，函数中的形参是实参的拷贝份，形参和实参只是在值上面一样，而不是同一个内存数据对象。这就意味着：这种数据传递是单向的，即从调用者传递给被调函数，而被调函数无法修改传递的参数达到回传的效果。</p><pre><code>void change(int a){    a++;      //在函数中改变的只是这个函数的局部变量a，而随着函数执行结束，a被销毁。age还是原来的age，纹丝不动。}int main(void){    int age = 60;    change(age);    printf("age = %d",age);   // age = 60    return 0;}</code></pre><p>有时候我们可以使用函数的返回值来回传数据，在简单的情况下是可以的，但是如果返回值有其它用途（例如返回函数的执行状态量），或者要回传的数据不止一个，返回值就解决不了了。</p><p>传递变量的指针可以轻松解决上述问题。</p><pre><code>void change(int* pa){    (*pa)++;   //因为传递的是age的地址，因此pa指向内存数据age。当在函数中对指针pa解地址时，               //会直接去内存中找到age这个数据，然后把它增1。}int main(void){    int age = 160;    change(&amp;age);    printf("age = %d",age);   // age = 61    return 0;}</code></pre><p>比如指针的一个常见的使用例子：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;void swap(int *,int *);int main(){    int a=5,b=10;    printf("a=%d,b=%d\n",a,b);    swap(&amp;a,&amp;b);    printf("a=%d,b=%d\n",a,b);    return 0;}void swap(int *pa,int *pb){    int t=*pa;*pa=*pb;*pb=t;}</code></pre><p>在以上的例子中，swap函数的两个形参pa和pb可以接收两个整型变量的地址，并通过间接访问的方式修改了它指向变量的值。在main函数中调用swap时，提供的实参分别为&a,&b，这样就实现了pa=&a,pb=&b的赋值过程，这样在swap函数中就通过*pa修改了 a 的值，通过*pb修改了 b 的值。因此，如果需要在被调函数中修改主调函数中变量的值，就需要经过以下几个步骤：</p><ul><li>定义函数的形参必须为指针类型，以接收主调函数中传来的变量的地址；</li><li>调用函数时实参为变量的地址；</li><li>在被调函数中使用*间接访问形参指向的内存空间，实现修改主调函数中变量值的功能。</li></ul><p>指针作为函数的形参的另一个典型应用是当函数有多个返回值的情形。比如，需要在一个函数中统计一个数组的最大值、最小值和平均值。当然你可以编写三个函数分别完成统计三个值的功能。但比较啰嗦，如：</p><pre><code>int GetMax(int a[],int n){    int max=a[0],i;    for(i=1;i&lt;n;i++)    {        if(max&lt;a[i]) max=a[i];    }    return max;}int GetMin(int a[],int n){    int min=a[0],i;    for(i=1;i&lt;n;i++)    {        if(min&gt;a[i]) min=a[i];    }    return min;}double GetAvg(int a[],int n){    double avg=0;    int i;    for(i=0;i&lt;n;i++)    {        avg+=a[i];    }    return avg/n;}</code></pre><p>其实我们完全可以在一个函数中完成这个功能，由于函数只能有一个返回值，可以返回平均值，最大值和最小值可以通过指针类型的形参来进行实现：</p><pre><code>double Stat(int a[],int n,int *pmax,int *pmin){    double avg=a[0];    int i;    *pmax=*pmin=a[0];    for(i=1;i&lt;n;i++)    {        avg+=a[i];        if(*pmax&lt;a[i]) *pmax=a[i];        if(*pmin&gt;a[i]) *pmin=a[i];    }    return avg/n;}</code></pre><h3 class=pgc-h-arrow-right>函数的指针</h3><p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址。我们可以把函数的这个首地址赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。</p><p>函数指针的定义形式为：</p><p>returnType (*pointerName)(param list);</p><p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。</p><p>用指针来实现对函数的调用：</p><pre><code>#include &lt;stdio.h&gt;//返回两个数中较大的一个int max(int a, int b){    return a&gt;b ? a : b;}int main(){    int x, y, maxval;    //定义函数指针    int (*pmax)(int, int) = max;  //也可以写作int (*pmax)(int a, int b)    printf("Input two numbers:");    scanf("%d %d", &amp;x, &amp;y);    maxval = (*pmax)(x, y);    printf("Max value: %d\n", maxval);    return 0;}</code></pre><h2 class=pgc-h-arrow-right>结构体和指针</h2><p>结构体指针有特殊的语法： -> 符号</p><p>如果p是一个结构体指针，则可以使用 p ->【成员】 的方法访问结构体的成员</p><pre><code>typedef struct{    char name[31];    int age;    float score;}Student;int main(void){    Student stu = {"Bob" , 19, 98.0};    Student*ps = &amp;stu    ps-&gt;age = 20;    ps-&gt;score = 99.0;    printf("name:%s age:%d",ps-&gt;name,ps-&gt;age);    return 0;}</code></pre><h2 class=pgc-h-arrow-right>const 和 指针</h2><ul><li>指向常量的指针，值不能改变，指向可改变</li><li>常指针值能改变，指向不可改变</li><li>指向常量的常指针，都不能改变</li></ul><pre><code>#include &lt;stdio.h&gt; int main(){  // 1 可改变指针  const int a = 10;  int *p = &amp;a  *p = 1000;  printf("*p = %d\n", *p);   // 2 可改变指针  const b = 10;  int *pb = &amp;b  pb = p;  printf("*pb = %d\n", *pb);   // 3  const c = 10;  int * const pc = &amp;c  *pc = 1000;  //pc = pb;不能改变   //4  const d = 10;  const * int const pd = &amp;d  //*pd = 1000; 不能改变    printf("\n");  return 0;}</code></pre><h2 class=pgc-h-arrow-right>深拷贝和浅拷贝</h2><p>如果2个程序单元（例如2个函数）是通过拷贝 他们所共享的数据的 指针来工作的，这就是浅拷贝，因为真正要访问的数据并没有被拷贝。如果被访问的数据被拷贝了，在每个单元中都有自己的一份，对目标数据的操作相互 不受影响，则叫做深拷贝。</p><pre><code>#include &lt;iostream&gt;using namespace std;class CopyDemo{public:  CopyDemo(int pa,char *cstr)  //构造函数，两个参数  {     this-&gt;a = pa;     this-&gt;str = new char[1024]; //指针数组，动态的用new在堆上分配存储空间     strcpy(this-&gt;str,cstr);    //拷贝过来  }//没写，C++会自动帮忙写一个复制构造函数，浅拷贝只复制指针,如下注释部分  //CopyDemo(CopyDemo&amp; obj)    //{  //   this-&gt;a = obj.a;  //  this-&gt;str = obj.str; //这里是浅复制会出问题，要深复制  //}  CopyDemo(CopyDemo&amp; obj)  //一般数据成员有指针要自己写复制构造函数，如下  {     this-&gt;a = obj.a;    // this-&gt;str = obj.str; //这里是浅复制会出问题，要深复制     this-&gt;str = new char[1024];//应该这样写     if(str != 0)        strcpy(this-&gt;str,obj.str); //如果成功，把内容复制过来  }  ~CopyDemo()  //析构函数  {     delete str;  }public:     int a;  //定义一个整型的数据成员     char *str; //字符串指针};int main(){  CopyDemo A(100,"hello!!!");  CopyDemo B = A;  //复制构造函数，把A的10和hello!!!复制给B  cout &lt;&lt;"A:"&lt;&lt; A.a &lt;&lt; "," &lt;&lt;A.str &lt;&lt; endl;  //输出A:100，hello!!!  cout &lt;&lt;"B:"&lt;&lt; B.a &lt;&lt; "," &lt;&lt;B.str &lt;&lt; endl;  //输出B:100，hello!!!  //修改后,发现A,B都被改变，原因就是浅复制，A,B指针指向同一地方，修改后都改变  B.a = 80;  B.str[0] = 'k';  cout &lt;&lt;"A:"&lt;&lt; A.a &lt;&lt; "," &lt;&lt;A.str &lt;&lt; endl;  //输出A:100，kello!!!  cout &lt;&lt;"B:"&lt;&lt; B.a &lt;&lt; "," &lt;&lt;B.str &lt;&lt; endl;  //输出B:80，kello!!!  return 0;}</code></pre><p>根据上面实例可以看到，浅复制仅复制对象本身（其中包括是指针的成员），这样不同被复制对象的成员中的对应非空指针会指向同一对象，被成员指针引用的对象成为共享的，无法直接通过指针成员安全地删除（因为若直接删除，另外对象中的指针就会无效，形成所谓的野指针，而访问无效指针是危险的；</p><p>除非这些指针有引用计数或者其它手段确保被指对象的所有权）；而深复制在浅复制的基础上，连同指针指向的对象也一起复制，代价比较高，但是相对容易管理。</p><p><br></p><p>更多干货内容只需要你关注电子芯吧客微信公众号</p><p class=pgc-end-literature>本文转载自公众号“C语言与CPP编程” ，作者自成一派123</p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'语言','指针','终极'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>