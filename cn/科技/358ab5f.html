<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试官：问你一个，Spring事务是如何传播的？ | 极客快訊</title><meta property="og:title" content="面试官：问你一个，Spring事务是如何传播的？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6513100097ce4d27b1df49cd347e4d88"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><meta property="article:published_time" content="2020-10-29T20:50:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:41+08:00"><meta name=Keywords content><meta name=description content="面试官：问你一个，Spring事务是如何传播的？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/358ab5f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试官：问你一个，Spring事务是如何传播的？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>推荐学习</h1><ul><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6844768153789006339/?group_id=6844768153789006339" rel="noopener noreferrer" target=_blank>肝了十天半月，献上纯手绘“Spring/Cloud/Boot/MVC”全家桶脑图</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6876044225012892163/?group_id=6876044225012892163" rel="noopener noreferrer" target=_blank>疯狂膜拜！阿里出品Spring Security王者晋级文档</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6865671837171319299/?group_id=6865671837171319299" rel="noopener noreferrer" target=_blank>真香警告！Alibaba珍藏版mybatis手写文档，刷起来</a></li></ul><div class=pgc-img><img alt=面试官：问你一个，Spring事务是如何传播的？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6513100097ce4d27b1df49cd347e4d88><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">前言</span></h1><p style=text-align:start>Spring事务是如何传播的？</p><p style=text-align:start>其实<span style="color:#4d4d4d;--tt-darkmode-color: #999999">之前有分析事务注解的解析过程，本质上是将事务封装为切面加入到AOP的执行链中，因此会调用到MethodInceptor的实现类的invoke方法，而事务切面的Interceptor就是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TransactionInterceptor</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，所以本篇直接从该类开始。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">事务</span><span style="color:#4f4f4f;--tt-darkmode-color: #979797">切面的调用过程</span></h1><pre><code>	public Object invoke(MethodInvocation invocation) throws Throwable {		// Work out the target class: may be {@code null}.		// The TransactionAttributeSource should be passed the target class		// as well as the method, which may be from an interface.		Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);		// Adapt to TransactionAspectSupport's invokeWithinTransaction...		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这个方法本身没做什么事，主要是调用了父类的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">invokeWithinTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，注意最后一个参数，传入的是一个lambda表达式，而这个表达式中的调用的方法应该不陌生，在分析AOP调用链时，就是通过这个方法</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">传递到下一个切面</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">或是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">调用被代理实例的方法</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，忘记了的可以回去看看。</span></p><pre><code>	protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,			final InvocationCallback invocation) throws Throwable {		// If the transaction attribute is null, the method is non-transactional.		//获取事务属性类 AnnotationTransactionAttributeSource		TransactionAttributeSource tas = getTransactionAttributeSource();		//获取方法上面有@Transactional注解的属性		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);		//获取事务管理器		final PlatformTransactionManager tm = determineTransactionManager(txAttr);		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);			Object retVal = null;			try {				// 调用proceed方法				retVal = invocation.proceedWithInvocation();			}			catch (Throwable ex) {				// target invocation exception				//事务回滚				completeTransactionAfterThrowing(txInfo, ex);				throw ex;			}			finally {				cleanupTransactionInfo(txInfo);			}			//事务提交			commitTransactionAfterReturning(txInfo);			return retVal;		}			// 省略了else	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这个方法逻辑很清晰，一目了然，if里面就是对声明式事务的处理，先调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法开启事务，然后通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">invocation.proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">调用下一个切面，如果没有其它切面了，就是调用被代理类的方法，出现异常就回滚，否则提交事务，这就是Spring事务切面的执行过程。但是，我们主要要搞懂的就是在这些方法中是如何管理事务以及事务在多个方法之间是如何传播的。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">事务的传播性概念</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">传播性是Spring自己搞出来的，数据库是没有的，因为涉及到方法间的调用，那么必然就需要考虑事务在这些方法之间如何流转，所以Spring提供了7个传播属性供选择，可以将其看成两大类，即是否支持当前事务：</span></p><ol start=1><li>支持当前事务（在同一个事务中）：</li></ol><blockquote><p><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">PROPAGATION_REQUIRED：支持当前事务，如果不存在，就新建一个事务。PROPAGATION_MANDATORY：支持当前事务，如果不存在，就抛出异常。PROPAGATION_SUPPORTS：支持当前事务，如果不存在，就不使用事务。</span></p></blockquote><ol start=2><li>不支持当前事务（不在同一个事务中）：</li></ol><blockquote><p><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">PROPAGATION_NEVER：以非事务的方式运行，如果有事务，则抛出异常。PROPAGATION_NOT_SUPPORTED：以非事务的方式运行，如果有事务，则挂起当前事务。PROPAGATION_REQUIRES_NEW：新建事务，如果有事务，挂起当前事务（两个事务相互独立，父事务回滚不影响子事务）。PROPAGATION_NESTED：如果当前事务存在，则嵌套事务执行（指必须依存父事务，子事务不能单独提交且父事务回滚则子事务也必须回滚，而子事务若回滚，父事务可以回滚也可以捕获异常）。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。</span></p></blockquote><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">别看属性这么多，实际上我们主要用的是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">默认属性，一些特殊业务下可能会用到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以及</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_NESTED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。下面我会假设一个场景，并主要分析这三个属性。</span></p><pre><code>public class A {		@Autowired	private B b;	@Transactional	public void addA() {		b.addB();	}}public class B {	@Transactional	public void addB() {		// doSomething...	}}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">上面我创建了A、B两个类，每个类中有一个事务方法，使用了声明式事务并采用的默认传播属性，在A中调用了B的方法。<br>当请求来了调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">时，首先调用的是代理对象的方法，因此会进入</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法开启事务：</span></p><pre><code>	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {		// If no name specified, apply method identification as transaction name.		if (txAttr != null &amp;&amp; txAttr.getName() == null) {			txAttr = new DelegatingTransactionAttribute(txAttr) {				@Override				public String getName() {					return joinpointIdentification;				}			};		}		TransactionStatus status = null;		if (txAttr != null) {			if (tm != null) {				//开启事务，这里重点看				status = tm.getTransaction(txAttr);			}			else {			}		}		//创建事务信息对象，记录新老事务信息对象		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">实际上开启事务是通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">AbstractPlatformTransactionManager</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">做的，而这个类是一个抽象类，具体实例化的对象就是我们在项目里常配置的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionManager</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象。</span></p><pre><code>	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {		//这里重点看，.DataSourceTransactionObject拿到对象		Object transaction = doGetTransaction();		// Cache debug flag to avoid repeated checks.		boolean debugEnabled = logger.isDebugEnabled();		if (definition == null) {			// Use defaults if no transaction definition given.			definition = new DefaultTransactionDefinition();		}		//第一次进来connectionHolder为空的，所以不存在事务		if (isExistingTransaction(transaction)) {			// Existing transaction found -&gt; check propagation behavior to find out how to behave.			return handleExistingTransaction(definition, transaction, debugEnabled);		}		// Check definition settings for new transaction.		if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());		}		// No existing transaction found -&gt; check propagation behavior to find out how to proceed.		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {			throw new IllegalTransactionStateException(					"No existing transaction found for transaction marked with propagation 'mandatory'");		}		//第一次进来大部分会走这里		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			//先挂起			SuspendedResourcesHolder suspendedResources = suspend(null);				if (debugEnabled) {					logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);				}				try {					boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);					//创建事务状态对象，其实就是封装了事务对象的一些信息，记录事务状态的					DefaultTransactionStatus status = newTransactionStatus(							definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);					//开启事务,重点看看 DataSourceTransactionObject					doBegin(transaction, definition);					//开启事务后，改变事务状态					prepareSynchronization(status, definition);					return status;			}			catch (RuntimeException | Error ex) {				resume(null, suspendedResources);				throw ex;			}		}		else {			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这个方法流程比较长，一步步来看，先调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doGetTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法获取一个</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionObject</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象，这个类是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">JdbcTransactionObjectSupport</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的子类，在父类中持有了一个</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象，见名知意，这个对象保存了当前的连接。</span></p><pre><code>	protected Object doGetTransaction() {		//管理connection对象，创建回滚点，按照回滚点回滚，释放回滚点		DataSourceTransactionObject txObject = new DataSourceTransactionObject();		//DataSourceTransactionManager默认是允许嵌套事务的		txObject.setSavepointAllowed(isNestedTransactionAllowed());		//obtainDataSource() 获取数据源对象，其实就是数据库连接块对象		ConnectionHolder conHolder =				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());		txObject.setConnectionHolder(conHolder, false);		return txObject;	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">追溯</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">getResource</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法可以看到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder 是从ThreadLocal</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">里获取的，也就是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当前线程</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，key是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSource</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象；但是仔细思考下我们是第一次进来，所以这里肯定获取不到的，反之，要从这里获取到值，那必然是同一个线程第二次及以后进入到这里，也就是在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">时，另外需要注意这里保存</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionObject</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象时是将</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性设置为</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">false</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">了的。<br>继续往后，创建完</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">transaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象后，会调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">isExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">判断是否已经存在一个事务，如果存在就会调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">handleExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，这个方法就是处理事务传播的核心方法，因为我们是第一次进来，肯定不存在事务，所以先跳过。<br>再往后，可以看到就是处理不同的传播属性，主要看到下面这个部分：</span></p><pre><code>		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			//先挂起			SuspendedResourcesHolder suspendedResources = suspend(null);				if (debugEnabled) {					logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);				}				try {					boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);					//创建事务状态对象，其实就是封装了事务对象的一些信息，记录事务状态的					DefaultTransactionStatus status = newTransactionStatus(							definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);					//开启事务,重点看看 DataSourceTransactionObject					doBegin(transaction, definition);					//开启事务后，改变事务状态					prepareSynchronization(status, definition);					return status;			}			catch (RuntimeException | Error ex) {				resume(null, suspendedResources);				throw ex;			}		}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第一次进来时，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">、</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_NESTED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">都会进入到这里，首先会调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">suspend</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">挂起当前存在的事务，在这里没啥作用。接下来通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">创建了</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DefaultTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象，这个对象主要就是存储当前事务的一些状态信息，需要特别注意</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性设置为了</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">true</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，表示是一个新事务。状态对象创建好之后就是通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doBegin</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">开启事务，这是一个</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">模板方法</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">：</span></p><pre><code>	protected void doBegin(Object transaction, TransactionDefinition definition) {		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;		Connection con = null;		try {			//如果没有数据库连接			if (!txObject.hasConnectionHolder() ||					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {				//从连接池里面获取连接				Connection newCon = obtainDataSource().getConnection();				if (logger.isDebugEnabled()) {					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction");				}				//把连接包装成ConnectionHolder，然后设置到事务对象中				txObject.setConnectionHolder(new ConnectionHolder(newCon), true);			}			txObject.getConnectionHolder().setSynchronizedWithTransaction(true);			con = txObject.getConnectionHolder().getConnection();			//从数据库连接中获取隔离级别			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);			txObject.setPreviousIsolationLevel(previousIsolationLevel);			// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,			// so we don't want to do it unnecessarily (for example if we've explicitly			// configured the connection pool to set it already).			if (con.getAutoCommit()) {				txObject.setMustRestoreAutoCommit(true);				if (logger.isDebugEnabled()) {					logger.debug("Switching JDBC Connection [" + con + "] to manual commit");				}				//关闭连接的自动提交，其实这步就是开启了事务				con.setAutoCommit(false);			}			//设置只读事务 从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！			//设置只读事务就是告诉数据库，我这个事务内没有新增，修改，删除操作只有查询操作，不需要数据库锁等操作，减少数据库压力			prepareTransactionalConnection(con, definition);			//自动提交关闭了，就说明已经开启事务了，事务是活动的			txObject.getConnectionHolder().setTransactionActive(true);			int timeout = determineTimeout(definition);			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {				txObject.getConnectionHolder().setTimeoutInSeconds(timeout);			}			// Bind the connection holder to the thread.			if (txObject.isNewConnectionHolder()) {				//如果是新创建的事务，则建立当前线程和数据库连接的关系				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());			}		}		catch (Throwable ex) {			if (txObject.isNewConnectionHolder()) {				DataSourceUtils.releaseConnection(con, obtainDataSource());				txObject.setConnectionHolder(null, false);			}			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这个方法里面主要做了六件事：</span></p><ul><li>首先从连接池获取连接并保存到<strong>DataSourceTransactionObject</strong>对象中。</li><li>关闭数据库的<strong>自动提交</strong>，也就是开启事务。</li><li>获取数据库的隔离级别。</li><li>根据属性设置该事务是否为<strong>只读事务</strong>。</li><li>将该事务标识为<strong>活动事务</strong>（transactionActive=true）。</li><li>将<strong>ConnectionHolder</strong>对象与当前线程绑定。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">完成之后通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">prepareSynchronization</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">将事务的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">状态</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">设置到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TransactionSynchronizationManager</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象中进行管理。最后返回到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法中创建</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TransactionInfo</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象与当前线程绑定并返回。<br>通过以上的步骤就开启了事务，接下来就是通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">调用其它切面，这里我们先假设没有其它切面了，那么就是直接调用到A类的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，在这个方法中又调用了B类的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，那么肯定也是调用到代理类的方法，因此又会进入到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法中。但这次进来通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">isExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">判断是存在事务的，因此会进入到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">handleExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法：</span></p><pre><code>	private TransactionStatus handleExistingTransaction(			TransactionDefinition definition, Object transaction, boolean debugEnabled)			throws TransactionException {		//不允许有事务，直接异常		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {			throw new IllegalTransactionStateException(					"Existing transaction found for transaction marked with propagation 'never'");		}		//以非事务方式执行操作，如果当前存在事务，就把当前事务挂起		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {			if (debugEnabled) {				logger.debug("Suspending current transaction");			}			//挂起当前事务			Object suspendedResources = suspend(transaction);			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);			//修改事务状态信息，把事务的一些信息存储到当前线程中，ThreadLocal中			return prepareTransactionStatus(					definition, null, false, newSynchronization, debugEnabled, suspendedResources);		}		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {			if (debugEnabled) {				logger.debug("Suspending current transaction, creating new transaction with name [" +						definition.getName() + "]");			}			//挂起			SuspendedResourcesHolder suspendedResources = suspend(transaction);			try {				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);				DefaultTransactionStatus status = newTransactionStatus(						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);				doBegin(transaction, definition);				prepareSynchronization(status, definition);				return status;			}			catch (RuntimeException | Error beginEx) {				resumeAfterBeginException(transaction, suspendedResources, beginEx);				throw beginEx;			}		}		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			if (!isNestedTransactionAllowed()) {				throw new NestedTransactionNotSupportedException(						"Transaction manager does not allow nested transactions by default - " +						"specify 'nestedTransactionAllowed' property with value 'true'");			}			if (debugEnabled) {				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");			}			//默认是可以嵌套事务的			if (useSavepointForNestedTransaction()) {				// Create savepoint within existing Spring-managed transaction,				// through the SavepointManager API implemented by TransactionStatus.				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.				DefaultTransactionStatus status =						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);				//创建回滚点				status.createAndHoldSavepoint();				return status;			}			else {				// Nested transaction through nested begin and commit/rollback calls.				// Usually only for JTA: Spring synchronization might get activated here				// in case of a pre-existing JTA transaction.				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);				DefaultTransactionStatus status = newTransactionStatus(						definition, transaction, true, newSynchronization, debugEnabled, null);				doBegin(transaction, definition);				prepareSynchronization(status, definition);				return status;			}		}			// 省略				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这里面也是对每个传播属性的判断，先看</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的处理，因为该属性要求每次调用都开启一个新的事务，所以首先会将当前事务挂起，怎么挂起呢？</span></p><pre><code>	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {		if (TransactionSynchronizationManager.isSynchronizationActive()) {			List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();			try {				Object suspendedResources = null;				//第一次进来，肯定为null的				if (transaction != null) {					//吧connectionHolder设置为空					suspendedResources = doSuspend(transaction);				}				//做数据还原操作				String name = TransactionSynchronizationManager.getCurrentTransactionName();				TransactionSynchronizationManager.setCurrentTransactionName(null);				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();				TransactionSynchronizationManager.setActualTransactionActive(false);				return new SuspendedResourcesHolder(						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);			}			catch (RuntimeException | Error ex) {				// doSuspend failed - original transaction is still active...				doResumeSynchronization(suspendedSynchronizations);				throw ex;			}		}		else if (transaction != null) {			// Transaction active but no synchronization active.			Object suspendedResources = doSuspend(transaction);			return new SuspendedResourcesHolder(suspendedResources);		}		else {			// Neither transaction nor synchronization active.			return null;		}	}	protected Object doSuspend(Object transaction) {		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;		txObject.setConnectionHolder(null);		//解除绑定关系，		return TransactionSynchronizationManager.unbindResource(obtainDataSource());	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这里明显是进入第一个if并且会调用到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doSuspend</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，整体来说挂起事务很简单：首先将</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionObject</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">设置为空并解除与当前线程的绑定，之后将解除绑定的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其它属性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（事务名称、隔离级别、只读属性）通通封装到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">SuspendedResourcesHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象，并将当前事务的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">活动状态</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">设置为false。挂起事务之后又通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">创建了一个新的事务状态并调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doBegin</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">开启事务，这里不再重复分析。<br>接着来看</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_NESTED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">：</span></p><pre><code>		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			if (!isNestedTransactionAllowed()) {				throw new NestedTransactionNotSupportedException(						"Transaction manager does not allow nested transactions by default - " +						"specify 'nestedTransactionAllowed' property with value 'true'");			}			if (debugEnabled) {				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");			}			//默认是可以嵌套事务的			if (useSavepointForNestedTransaction()) {				// Create savepoint within existing Spring-managed transaction,				// through the SavepointManager API implemented by TransactionStatus.				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.				DefaultTransactionStatus status =						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);				//创建回滚点				status.createAndHoldSavepoint();				return status;			}			else {				// Nested transaction through nested begin and commit/rollback calls.				// Usually only for JTA: Spring synchronization might get activated here				// in case of a pre-existing JTA transaction.				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);				DefaultTransactionStatus status = newTransactionStatus(						definition, transaction, true, newSynchronization, debugEnabled, null);				doBegin(transaction, definition);				prepareSynchronization(status, definition);				return status;			}		}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这里面可以看到如果允许</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">嵌套事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，就会创建一个</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DefaultTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对象（注意</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">是false，表明不是一个新事务）和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">回滚点</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">；如果不允许</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">嵌套</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，就会创建</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">新事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">并开启。<br>当上面的判断都不满足时，也就是传播属性为默认</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">时，则只是创建了一个</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">为false的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DefaultTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">返回。<br>完成之后又是调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，那么就是执行B类的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，假如没有发生异常，那么就会回到切面调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">commitTransactionAfterReturning</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">提交</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的事务：</span></p><pre><code>	protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {		if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {			txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());		}	}	public final void commit(TransactionStatus status) throws TransactionException {		processCommit(defStatus);	}	private void processCommit(DefaultTransactionStatus status) throws TransactionException {		try {			boolean beforeCompletionInvoked = false;			try {				boolean unexpectedRollback = false;				prepareForCommit(status);				triggerBeforeCommit(status);				triggerBeforeCompletion(status);				beforeCompletionInvoked = true;				if (status.hasSavepoint()) {					if (status.isDebug()) {						logger.debug("Releasing transaction savepoint");					}					// 如果是nested，没有提交，只是将savepoint清除掉了					unexpectedRollback = status.isGlobalRollbackOnly();					status.releaseHeldSavepoint();				}				//如果都是PROPAGATION_REQUIRED，最外层的才会走进来统一提交，如果是PROPAGATION_REQUIRES_NEW，每一个事务都会进来				else if (status.isNewTransaction()) {					if (status.isDebug()) {						logger.debug("Initiating transaction commit");					}					unexpectedRollback = status.isGlobalRollbackOnly();					doCommit(status);				}				else if (isFailEarlyOnGlobalRollbackOnly()) {					unexpectedRollback = status.isGlobalRollbackOnly();				}			}		}		finally {			cleanupAfterCompletion(status);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">主要逻辑在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">processCommit</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法中。如果存在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">回滚点</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，可以看到并</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">没有提交事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，只是将</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当前事务的回滚点</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">清除了；而如果是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">新事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，就会调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doCommit</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">提交事务，也就是只有</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性下的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最外层事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性下的事务能提交。事务提交完成后会调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">cleanupAfterCompletion</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">清除当前事务的状态，如果有挂起的事务还会通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">resume</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">恢复挂起的事务（将解绑的连接和当前线程绑定以及将之前保存的事务状态重新设置回去）。当前事务正常提交后，那么就会轮到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法提交，处理逻辑同上，不再赘述。<br>如果调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">发生异常，就会通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">completeTransactionAfterThrowing</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">进行回滚：</span></p><pre><code>	protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {		if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {			if (logger.isTraceEnabled()) {				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() +						"] after exception: " + ex);			}			if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) {				try {					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());				}			}		}	}	public final void rollback(TransactionStatus status) throws TransactionException {		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;		processRollback(defStatus, false);	}	private void processRollback(DefaultTransactionStatus status, boolean unexpected) {		try {			boolean unexpectedRollback = unexpected;			try {				triggerBeforeCompletion(status);				//按照嵌套事务按照回滚点回滚				if (status.hasSavepoint()) {					if (status.isDebug()) {						logger.debug("Rolling back transaction to savepoint");					}					status.rollbackToHeldSavepoint();				}				//都为PROPAGATION_REQUIRED最外层事务统一回滚				else if (status.isNewTransaction()) {					if (status.isDebug()) {						logger.debug("Initiating transaction rollback");					}					doRollback(status);				}				else {					// Participating in larger transaction					if (status.hasTransaction()) {						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {							if (status.isDebug()) {								logger.debug("Participating transaction failed - marking existing transaction as rollback-only");							}							doSetRollbackOnly(status);						}						else {							if (status.isDebug()) {								logger.debug("Participating transaction failed - letting transaction originator decide on rollback");							}						}					}					else {						logger.debug("Should roll back transaction but cannot - no transaction available");					}					// Unexpected rollback only matters here if we're asked to fail early					if (!isFailEarlyOnGlobalRollbackOnly()) {						unexpectedRollback = false;					}				}			}			catch (RuntimeException | Error ex) {				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);				throw ex;			}			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);			// Raise UnexpectedRollbackException if we had a global rollback-only marker			if (unexpectedRollback) {				throw new UnexpectedRollbackException(						"Transaction rolled back because it has been marked as rollback-only");			}		}		finally {			cleanupAfterCompletion(status);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">流程和提交是一样的，先是判断有没有回滚点，如果有就回到到回滚点并清除该回滚点；如果没有则判断是不是新事务（</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性下的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最外层事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">属性下的事务），满足则直接回滚当前事务。回滚完成后同样需要清除掉当前的事务状态并恢复挂起的连接。另外需要特别注意的是在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">catch</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">里面调用完回滚逻辑后，还通过</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">throw</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">抛出了异常，这意味着什么？意味着即使是嵌套事务，内层事务的回滚也会导致外层事务的回滚，也就是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的事务也会跟着回滚。<br>至此，事务的传播原理分析完毕，深入看每个方法的实现是很复杂的，但如果仅仅是分析各个传播属性对事务的影响，则有一个简单的方法。我们可以将内层事务切面</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">等效替换</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">掉</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">invocation.proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，比如上面两个类的调用可以看作是下面这样：</span></p><pre><code>// addA的事务TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);Object retVal = null;try {	// addB的事务	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	Object retVal = null;	try {		retVal = invocation.proceedWithInvocation();	}	catch (Throwable ex) {		// target invocation exception		//事务回滚		completeTransactionAfterThrowing(txInfo, ex);		throw ex;	}	finally {		cleanupTransactionInfo(txInfo);	}	//事务提交	commitTransactionAfterReturning(txInfo);}catch (Throwable ex) {	//事务回滚	completeTransactionAfterThrowing(txInfo, ex);	throw ex;}//事务提交commitTransactionAfterReturning(txInfo);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这样看是不是很容易就能分析出事务之间的影响以及是提交还是回滚了？下面来看几个实例分析。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">实例分析</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">我再添加一个C类，和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addC</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的方法，然后在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">里面调用这个方法。</span></p><pre><code>TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);Object retVal = null;try {	// addB的事务	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	Object retVal = null;	try {		b.addB();	}	catch (Throwable ex) {		// target invocation exception		//事务回滚		completeTransactionAfterThrowing(txInfo, ex);		throw ex;	}	//事务提交	commitTransactionAfterReturning(txInfo);	// addC的事务	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	Object retVal = null;	try {		c.addC();	}	catch (Throwable ex) {		// target invocation exception		//事务回滚		completeTransactionAfterThrowing(txInfo, ex);		throw ex;	}	//事务提交	commitTransactionAfterReturning(txInfo);}catch (Throwable ex) {	//事务回滚	completeTransactionAfterThrowing(txInfo, ex);	throw ex;}//事务提交commitTransactionAfterReturning(txInfo);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">等效替换后就是上面这个代码，我们分别来分析。</span></p><ul><li>都是<strong>PROPAGATION_REQUIRED</strong>属性：通过上面的分析，我们知道三个方法都是同一个连接和事务，那么任何一个出现异常则都会回滚。</li><li><strong>addB</strong>为<strong>PROPAGATION_REQUIRES_NEW</strong>：如果B中抛出异常，那么B中肯定会回滚，接着异常向上抛，导致A事务整体回滚；如果C中抛出异常，不难看出C和A都会回滚，但B已经提交了，因此不会受影响。</li><li><strong>addC</strong>为<strong>PROPAGATION_NESTED</strong>，<strong>addB</strong>为<strong>PROPAGATION_REQUIRES_NEW</strong>：如果B中抛出异常，那么B回滚并抛出异常，A也回滚，C不会执行；如果C中抛出异常，先是回滚到<strong>回滚点</strong>并抛出异常，所以A也回滚，但B此时已经提交，不受影响。</li><li>都是<strong>PROPAGATION_NESTED</strong>：虽然创建了回滚点，但是仍然是同一个连接，任何一个发生异常都会回滚，如果不想影响彼此，可以try-catch生吞子事务的异常实现。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">还有其它很多情况，这里就不一一列举了，只要使用上面的分析方法都能够很轻松的分析出来。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">总结</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">本篇详细分析了事务的传播原理，另外还有</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">隔离级别</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，这在Spring中没有体现，需要我们自己结合数据库的知识进行分析设置。最后我们还需要考虑</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">声明式事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">编程式事务</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的优缺点，声明式事务虽然简单，但不适合用在长事务中，会占用大量连接资源，这时就需要考虑利用编程式事务的灵活性了。总而言之，事务的使用并不是一律默认就好，接口的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一致性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">吞吐量</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">与事务有着直接关系，严重情况下可能会导致系统崩溃。</span></p><blockquote><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">作者：</span>夜勿语</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">原文链接：</span>https://blog.csdn.net/l6108003/article/details/106696735</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','问你','一个'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>