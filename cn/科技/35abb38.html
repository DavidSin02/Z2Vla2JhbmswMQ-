<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试题第4篇：重写了equals，还要重写hashCode？ | 极客快訊</title><meta property="og:title" content="面试题第4篇：重写了equals，还要重写hashCode？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9b1f878c17e84c1caa06a5deda2c10f1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35abb38.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><meta property="article:published_time" content="2020-10-29T21:01:26+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:26+08:00"><meta name=Keywords content><meta name=description content="面试题第4篇：重写了equals，还要重写hashCode？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/35abb38.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试题第4篇：重写了equals，还要重写hashCode？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>《Java面试题系列》：一个长知识又很有意思的专栏。深入挖掘、分析源码、汇总原理、图文结合，打造公众号系列文章，面试与否均可提升Level。欢迎持续关注【程序新视界】。本篇为第4篇。</p></blockquote><p style=text-align:start>核心问题：重写了equals方法，为什么还要重写hashCode方法？</p><p style=text-align:start>这不仅仅是一道面试题，而且是关系到我们的代码是否健壮和正确的问题。在前面两篇文章涉及到了equals方法的底层讲解：《说说==和equals的区别？你的回答可能是错误的》和《Integer等号判断的内幕，你可能不知道？》。</p><p style=text-align:start>本篇文章，带大家从底层来分析一下hashcode方法重写的意义以及如何实现。</p><h1 class=pgc-h-arrow-right>回顾equals方法</h1><p style=text-align:start>我们先回顾一下Object的equals方法实现，并简单汇总一下使用equals方法的规律。</p><pre><code>public boolean equals(Object obj) {    return (this == obj);}</code></pre><p style=text-align:start>通过上面Object的源代码，可以得出一个结论：如果一个类未重写equals方法，那么本质上通过“==”和equals方法比较的效果是一样的，都是比较两个对象的的内存地址。</p><p style=text-align:start>前面两篇文章讲到String和Integer在比较时的区别，关键点也是它们对equals方法的实现。</p><p style=text-align:start>面试时总结一下就是：默认情况下，从Object类继承的equals方法与“==”完全等价，比较的都是对象的内存地址。但我们可以重写equals方法，使其按照需要进行比较，如String类重写了equals方法，比较的是字符的序列，而不再是内存地址。</p><h1 class=pgc-h-arrow-right>与hashCode方法的关系</h1><p style=text-align:start>那么equals方法与hashCode方法又有什么关系呢？我们来看Object上equals方法的一段注释。</p><blockquote><p>Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</p></blockquote><p style=text-align:start>大致意思是：当重写equals方法后有必要将hashCode方法也重写，这样做才能保证不违背hashCode方法中“相同对象必须有相同哈希值”的约定。</p><p style=text-align:start>此处只是提醒了我们重写hashCode方法的必要性，那其中提到的hashCode方法设计约定又是什么呢？相关的内容定义在hashCode方法的注解部分。</p><h1 class=pgc-h-arrow-right>hashCode方法约定</h1><p style=text-align:start>关于hashCode方法的约定原文比较多，大家直接看源码即可看到，这里汇总一下，共三条：</p><p style=text-align:start>（1）如果对象在使用equals方法中进行比较的参数没有修改，那么多次调用一个对象的hashCode()方法返回的哈希值应该是相同的。</p><p style=text-align:start>（2）如果两个对象通过equals方法比较是相等的，那么要求这两个对象的hashCode方法返回的值也应该是相等的。</p><p style=text-align:start>（3）如果两个对象通过equals方法比较是不同的，那么也不要求这两个对象的hashCode方法返回的值是不相同的。但是我们应该知道对于不同对象产生不同的哈希值对于哈希表(HashMap等)能够提高性能。</p><p style=text-align:start>其实，看到这里我们了解了hashCode的实现规约，但还是不清楚为什么实现equals方法需要重写hashCode方法。但我们可以得出一条规律：hashCode方法实际上必须要完成的一件事情就是，为equals方法认定为相同的对象返回相同的哈希值。</p><p style=text-align:start>其实在上面规约中提到了哈希表，这也正是hashCode方法运用的场景之一，也是我们为什么要重写的核心。</p><h1 class=pgc-h-arrow-right>hashCode应用场景</h1><p style=text-align:start>如果了解HashMap的数据结构，就会知道它用到“键对象”的哈希码，当我们调用put方法或者get方法对Map容器进行操作时，都是根据键对象的哈希码来计算存储位置的。如果我们对哈希码的获取没有相关保证，就可能会得不到预期的结果。</p><div class=pgc-img><img alt=面试题第4篇：重写了equals，还要重写hashCode？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9b1f878c17e84c1caa06a5deda2c10f1><p class=pgc-img-caption></p></div><p style=text-align:start>而对象的哈希码的获取正是通过hashCode方法获取的。如果自定义的类中没有实现该方法，则会采用Object中的hashCode()方法。</p><p style=text-align:start>在Object中该方法是一个本地方法，会返回一个int类型的哈希值。可以通过将对象的内部地址转换为整数来实现的，但是Java中没有强制要求通过该方式实现。</p><p style=text-align:start>具体实现网络上有不同的说法，有说通过内置地址转换得来，也有说“OpenJDK8默认hashCode的计算方法是通过和当前线程有关的一个随机数+三个确定值，运用Marsaglia's xorshift scheme随机数算法得到的一个随机数”获得。</p><p style=text-align:start>无论默认实现是怎样的，大多数情况下都无法满足equals方法相同，同时hashCode结果也相同的条件。比如下面的示例重写与否差距很大。</p><pre><code>public void test1() {	String s = "ok";	StringBuilder sb = new StringBuilder(s);	System.out.println(s.hashCode() + "  " + sb.hashCode());	String t = new String("ok");	StringBuilder tb = new StringBuilder(s);	System.out.println(t.hashCode() + "  " + tb.hashCode());}</code></pre><p style=text-align:start>上面这段代码打印的结果为：</p><pre><code>3548  18336389143548  1620303253</code></pre><p style=text-align:start>String实现了hashCode方法，而StringBuilder并没有实现，这就导致即使值是一样的，hashCode也不同。</p><p style=text-align:start>上个示例中问题还不太明显，下面我们以HashMap为例，看看如果没有实现hashCode方法会导致什么严重的后果。</p><pre><code>@Testpublic void test2() {	String hello = "hello";	Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();	String s1 = new String("key");	String s2 = new String("key");	map1.put(s1, hello);	System.out.println("s1.equals(s2):" + s1.equals(s2));	System.out.println("map1.get(s1):" + map1.get(s1));	System.out.println("map1.get(s2):" + map1.get(s2));	Map&lt;Key, String&gt; map2 = new HashMap&lt;&gt;();	Key k1 = new Key("A");	Key k2 = new Key("A");	map2.put(k1, hello);	System.out.println("k1.equals(k2):" + s1.equals(s2));	System.out.println("map2.get(k1):" + map2.get(k1));	System.out.println("map2.get(k2):" + map2.get(k2));}class Key {	private String k;	public Key(String key) {		this.k = key;	}	@Override	public boolean equals(Object obj) {		if (obj instanceof Key) {			Key key = (Key) obj;			return k.equals(key.k);		}		return false;	}}</code></pre><p style=text-align:start>实例中定义了内部类Key，其中实现了equals方法，但未实现hashCode方法。存放于Map中的value值都是字符串“hello”。</p><p style=text-align:start>代码分两段，第一段演示当Map的key通过实现了hashCode的String时是什么效果；第二段演示了当Map的key通过未实现hashCode方法的Key对象时是什么效果。</p><p style=text-align:start>执行上述代码，打印结果如下：</p><pre><code>s1.equals(s2):truemap1.get(s1):hellomap1.get(s2):hellok1.equals(k2):truemap2.get(k1):hellomap2.get(k2):null</code></pre><p style=text-align:start>分析结果可以看出，对于String作为key的s1和s2来说，通过equals比较相等是自然的，获得的值也是相同的。但k1和k2通过equals比较是相等，但为什么在Map中获得的结果却不一样？本质上就是因为没有重写hashCode方法导致Map在存储和获取过程中调用hashCode方法获得的值不一致。</p><p style=text-align:start>此时在Key类中添加hashCode方法：</p><pre><code>@Overridepublic int hashCode(){	return k.hashCode();}</code></pre><p style=text-align:start>再次执行，便可正常获得对应的值。</p><pre><code>s1.equals(s2):truemap1.get(s1):hellomap1.get(s2):hellok1.equals(k2):truemap2.get(k1):hellomap2.get(k2):hello</code></pre><p style=text-align:start>通过上面的典型实例演示了不重写hashCode方法的潜在后果。简单看一下HashMap中的put方法。</p><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 通过哈希值来查找底层数组位于该位置的元素p，如果p不为null，则使用新的键值对来覆盖旧的键值对    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        // (二者哈希值相等)且(二者地址值相等或调用equals认定相等)。        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        // 如果底层数组中存在传入的Key，那么使用新传入的覆盖掉查到的        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p style=text-align:start>在上述方法中，put方法在拿到key的第一步就对key对象调用了hashCode方法。暂且不看后面的代码，如果没有重写hashCode方法，就无法确保key的hash值一致，后续操作就是两个key的操作了。</p><h1 class=pgc-h-arrow-right>重写hashCode方法</h1><p style=text-align:start>了解了重写hashCode方法的重要性，也了解了对应的规约，那么下面我们就聊聊如何优雅的重写hashCode方法。</p><p style=text-align:start>首先，如果使用IDEA的话，那么直接使用快捷键即可。</p><div class=pgc-img><img alt=面试题第4篇：重写了equals，还要重写hashCode？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0ff7d86bc96d4a43bb149b499f35d8a1><p class=pgc-img-caption></p></div><p style=text-align:start>生成的效果如下：</p><pre><code>@Overridepublic boolean equals(Object o) {	if (this == o) {		return true;	}	if (o == null || getClass() != o.getClass()) {		return false;	}	Key key = (Key) o;	return Objects.equals(k, key.k);}@Overridepublic int hashCode() {	return Objects.hash(k);}</code></pre><p style=text-align:start>根据需要可对生成的方法内部实现进行修改。在上面的实例中用到了java.util.Objects类，它的hash方法的优点是如果参数为null，就只返回0，否则返回对象参数调用的hashCode的结果。Objects.hash方法源码如下：</p><pre><code>public static int hash(Object... values) {    return Arrays.hashCode(values);}</code></pre><p style=text-align:start>其中Arrays.hashCode方法源码如下：</p><pre><code>public static int hashCode(Object a[]) {    if (a == null)        return 0;    int result = 1;    for (Object element : a)        result = 31 * result + (element == null ? 0 : element.hashCode());    return result;}</code></pre><p style=text-align:start>当然此处只有一个参数，也可以直接使用Objects类hashCode方法：</p><pre><code>public static int hashCode(Object o) {    return o != null ? o.hashCode() : 0;}</code></pre><p style=text-align:start>如果是多个属性都参与hash值的情况建议可使用第一个方法。只不过需要注意，在类结构（成员变量）变动时，同步增减方法里面的参数值。</p><h1 class=pgc-h-arrow-right>小结</h1><p style=text-align:start>当我们准备面试时，一直在背诵“实现equals方法的同时也要实现hashCode方法”，牢记这些结论并没有错。但我们也不能因为匆忙准备面试题，而忘记了这些面试题之所以频繁出现的原因是什么。当深入探索之后，会发现在那些枯燥的结论背后还有这么多不容忽视的知识点，还有这么多有意思的设计与陷阱。</p><p style=text-align:start>我是觉得越研究越有意思，越研究越发现自己曾经的无知。你呢？关注一下，期待下一篇文章吧。</p><blockquote class=pgc-blockquote-abstract><p>原文首发于公众号：程序新视界</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'重写','面试题','equals'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>