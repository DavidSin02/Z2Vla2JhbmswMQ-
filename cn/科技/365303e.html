<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>管理 Vue 应用中的异步调用 vue-asyn-manager | 极客快訊</title><meta property="og:title" content="管理 Vue 应用中的异步调用  vue-asyn-manager  - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/7837421e-5bde-40e0-bcc4-4bd94bb40374"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/365303e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="管理 Vue 应用中的异步调用  vue-asyn-manager"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/365303e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>管理 Vue 应用中的异步调用 vue-asyn-manager</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>使用 vue-asyn-manager 管理 Vue 应用中的异步调用</strong></h1><div class=pgc-img><img alt="管理 Vue 应用中的异步调用  vue-asyn-manager" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/7837421e-5bde-40e0-bcc4-4bd94bb40374><p class=pgc-img-caption></p></div><p>不知道大家对 React Suspense 是否有过关注，也许 Suspense 让人比较激动的是在服务端的流式渲染，然而从目前来看，React Suspense 的功能其实就是个 Loadable。当然啦这是我个人的看法，不过这不是今天的重点，今天的重点是介绍如何在 Vue 应用中更好的管理异步调用，那为什么会扯到 React Suspense 呢？因为 vue-async-manager 的灵感来自于 React Suspense，因此让我们开始吧。</p><p>vue-async-manager 是一个开源项目：</p><ul><li>https://shuidi-fed.github.io/vue-async-manager/</li></ul><h1>指南</h1><blockquote><p>在 Vue 应用中更轻松的管理异步调用</p></blockquote><p>异步调用指的是什么？</p><p>这里所说的异步调用，主要指的是两件事儿：</p><ul><li>异步组件(Async Component)的加载</li><li>发送异步请求从 API 中获取数据</li></ul><p>等待异步组件的加载</p><p>实际上 Vue 的异步组件已经支持在加载过程中展示 loading 组件的功能，如下代码取自官网：</p><pre>new Vue({ // ... components: { 'my-component': () =&gt; ({ // 异步组件 component: import('./my-async-component'), // 加载异步组件过程中展示的 loading 组件 loading: LoadingComponent, // loading 组件展示的延迟时间 delay: 200 }) }})复制代码</pre><p>:::tip delay 用于指定 loading 组件展示的延迟时间，如上代码中延迟时间为 200ms，如果异步组件的加载在 200ms 之内完成，则 loading 组件就没有展示的机会。 :::</p><p>但它存在两个问题：</p><ul><li>1、loading 组件与异步组件紧密关联，无法将 loading 组件提升，并用于多个异步组件的加载。</li><li>2、如果异步组件自身仍有异步调用，例如请求 API，那么 loading 组件是不会等待 API 请求完成之后才隐藏的。</li></ul><p>vue-async-manager 提供了 &lt;Suspense> 组件，可以解决如上两个问题。</p><p>1、使用 lazy 函数创建异步组件</p><p>过去我们创建一个异步组件的方式是：</p><pre>const asyncComponent = () =&gt; import('./my-async.component.vue')复制代码</pre><p>现在我们使用 vue-async-manager 提供的 lazy 函数来创建异步组件：</p><pre>import { lazy } from 'vue-async-manager' const asyncComponent = lazy(() =&gt; import('./my-async.component.vue'))复制代码</pre><p>如上代码所示，仅仅是将原来的异步工厂函数作为参数传递给 lazy 函数即可。</p><p>2、使用 &lt;Suspense> 组件包裹异步组件</p><pre>&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 使用 Suspense 组件包裹可能出现异步组件的组件树 --&gt; &lt;Suspense&gt; &lt;!-- 展示 loading --&gt; &lt;div slot="fallback"&gt;loading&lt;/div&gt; &lt;!-- 异步组件 --&gt; &lt;asyncComponent1/&gt; &lt;asyncComponent2/&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 创建异步组件const asyncComponent1 = lazy(() =&gt; import('./my-async.component1.vue'))const asyncComponent2 = lazy(() =&gt; import('./my-async.component2.vue')) export default { name: 'App', components: { // 注册组件 asyncComponent1, asyncComponent2 }}&lt;/script&gt;复制代码</pre><p>只有当 &lt;asyncComponent1/> 和 &lt;asyncComponent2/> 全部加载完毕后，loading 组件才会消失。</p><div class=pgc-img><img alt="管理 Vue 应用中的异步调用  vue-asyn-manager" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/e0f9f202-5848-411d-a36b-fd7db67d6447><p class=pgc-img-caption></p></div><p>:::tip Live Demo: 等待所有异步组件加载完毕 :::</p><p>配合 vue-router 使用</p><p>我们在开发 Vue 应用时，最常使用异步组件的方式是配合 vue-router 做代码拆分，例如：</p><pre>const router = new VueRouter({ routes: [ { path: '/', component: () =&gt; import('./my-async-component.vue') } ]})复制代码</pre><p>为了让 &lt;Suspense> 组件等待这个异步组件的加载，我们可以使用 lazy 函数包裹这个异步组件工厂函数：</p><pre>const router = new VueRouter({ routes: [ { path: '/', component: lazy(() =&gt; import('./my-async-component.vue')) } ]})复制代码</pre><p>最后我们只需要用 &lt;Suspense> 组件包裹渲染出口(&lt;router-view>)即可：</p><pre>&lt;Suspense :delay="200"&gt; &lt;div slot="fallback"&gt;loading&lt;/div&gt; &lt;!-- 渲染出口 --&gt; &lt;router-view/&gt;&lt;/Suspense&gt;复制代码</pre><p>:::tip Live Demo: 配合 vue-router :::</p><p>API请求中如何展示 loading</p><p>过去，大多是手动维护 loading 的展示，例如“开始请求”时展示 loading，“请求结束”后隐藏 loading。而且如果有多个请求并发时，你就得等待所有请求全部完成后再隐藏 loading。总之你需要自己维护 loading 的状态，无论这个状态是存储在组件内，还是 store 中。</p><p>现在来看看 vue-async-manager 是如何解决 API 请求过程中 loading 展示问题的，假设有如下代码：</p><pre>&lt;Suspense&gt; &lt;div slot="fallback"&gt;loading...&lt;/div&gt; &lt;MyComponent/&gt;&lt;/Suspense&gt;复制代码</pre><p>在 &lt;Suspense> 组件内渲染了 &lt;MyComponent> 组件，该组件是一个普普通通的组件，在该组件内部，会发送 API 请求，如下代码所示：</p><pre>&lt;!-- MyComponent.vue --&gt;&lt;template&gt; &lt;!-- 展示请求回来的数据 --&gt; &lt;div&gt;{{ res }}&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import { getAsyncData } from 'api' export default { data: { res: {} }, async created() { // 异步请求数据 this.res = await getAsyncData(id) }}&lt;/script&gt;复制代码</pre><p>这是我们常见的代码，通常在 created 或者 mounted 钩子中发送异步请求获取数据，然而这样的代码对于 &lt;Suspense> 组件来说，它并不知道需要等待异步数据获取完成后再隐藏 loading。为了解决这个问题，我们可以使用 vue-async-manager 提供的 createResource 函数创建一个<strong>资源管理器</strong>：</p><pre>&lt;template&gt; &lt;!-- 展示请求回来的数据 --&gt; &lt;div&gt;{{ $rm.$result }}&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 创建一个资源管理器 this.$rm = createResource((params) =&gt; getAsyncData(params)) // 读取数据 this.$rm.read(params) }}&lt;/script&gt;复制代码</pre><p>为 createResource 函数传递一个工厂函数，我们创建了一个<strong>资源管理器</strong> $rm，接着调用资源管理器的 $rm.read() 函数进行读取数据。大家注意，上面的代码是以同步的方式来编写的，并且 &lt;Suspense> 组件能够知道该组件正在进行异步调用，因此 &lt;Suspense> 组件将等待该异步调用结束之后再隐藏 loading。</p><p>另外我们观察如上代码中的模板部分，我们展示的数据是 $rm.$result，实际上异步数据获取成功之后，得到的数据会保存在<strong>资源管理器</strong>的 $rm.$result 属性上，需要注意的是，该属性本身就是响应式的，因此你无需在组件的 data 中事先声明。</p><hr><p>:::tip Live Demo: Suspense 组件等待资源管理器获取数据完成 :::</p><p>配合 vuex</p><p>配合 vuex 很简单，只需要使用 mapActions 将 actions 映射为方法即可：</p><pre>export default { name: "AsyncComponent", methods: { ...mapActions(['increase']) }, created() { this.$rm = createResource(() =&gt; this.increase()) this.$rm.read() }};复制代码</pre><p>:::tip Live Demo: 配合 vuex :::</p><p>捕获组件树中的所有异步调用</p><p>&lt;Suspense> 组件不仅能捕获异步组件的加载，如果该异步组件自身还有其他的异步调用，例如通过<strong>资源管理器</strong>获取数据，那么 &lt;Suspense> 组件也能够捕获到这些异步调用，并等待所有异步调用结束之后才隐藏 loading 状态。</p><p>我们来看一个例子：</p><pre>&lt;Suspense&gt; &lt;div slot="fallback"&gt;loading&lt;/div&gt; &lt;!-- MyLazyComponent 是通过 lazy 函数创建的组件 --&gt; &lt;MyLazyComopnent/&gt;&lt;/Suspense&gt;复制代码</pre><p>在这段代码中，&lt;MyLazyComopnent/> 组件是一个通过 lazy 函数创建的组件，因此 &lt;Suspense> 组件可以等待该异步组件的加载，然而异步组件自身又通过<strong>资源管理器</strong>获取数据：</p><pre>// 异步组件export default { created() { // 创建一个资源管理器 this.$rm = createResource((params) =&gt; getAsyncData(params)) this.$rm.read(params) }}复制代码</pre><p>这时候，&lt;Suspense> 组件会等待两个异步调用全部结束之后才隐藏 loading，这两个异步调用分别是：</p><ul><li>1、异步组件的加载</li><li>2、异步组件内部通过<strong>资源管理器</strong>发出的异步请求</li></ul><p>:::tip 这个 Demo 也展示了如上描述的功能：</p><p>Live Demo: Suspense 组件等待资源管理器获取数据完成 :::</p><p>资源管理器</p><p>前面我们一直在强调一个词：<strong>资源管理器</strong>，我们把通过 createResource() 函数创建的对象称为<strong>资源管理器(Resource Manager)</strong>，因此我们约定使用名称 $rm 来存储 createResource() 函数的返回值。</p><p>资源管理器的完整形态如下：</p><pre>this.$rm = createResource(() =&gt; getAsyncData())this.$rm = { read(){}, // 一个函数，调用该函数会真正发送异步请求获取数据 $result, // 初始值为 null，异步数据请求成功后，保存着取得的数据 $error, // 初始值为 null，当异步请求出错时，其保存着 err 数据 $loading, // 一个boolean值，初始值为 false，代表着是否正在请求中 fork() // 根据已有资源管理器 fork 一个新的资源管理器}复制代码</pre><p>其中 $rm.read() 函数用来发送异步请求获取数据，可多次调用，例如点击按钮再次调用其获取数据。$rm.$result 我们也已经见过了，用来存储异步获取来的数据。$rm.$loading 是一个布尔值，代表着请求是否正在进行中，通常我们可以像如下这样自定义 loading 展示：</p><pre>&lt;template&gt; &lt;!-- 控制 loading 的展示 --&gt; &lt;MyButton :loading="$rm.$loading" @click="submit" &gt;提交&lt;/MyButton&gt;&lt;/template&gt; &lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 创建一个资源管理器 this.$rm = createResource((id) =&gt; getAsyncData(id)) }, methods: { submit() { this.$rm.read(id) } }}&lt;/script&gt;复制代码</pre><p>:::tip 更重要的一点是：<strong>资源管理器可以脱离 &lt;Suspense> 单独使用。</strong> :::</p><p>如果资源管理器在请求数据的过程中发生了错误，则错误数据会保存在 $rm.$error 属性中。$rm.fork() 函数用来根据已有<strong>资源管理器</strong>创建一个一模一样的资源管理器出来。</p><p>fork 一个资源管理器</p><p>当一个 API 用来获取数据，并且我们需要并发的获取两次数据，那么只需要调用两次 $rm.read() 即可：</p><pre>&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 创建一个资源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type))  // 连续获取两次数据 this.$rm.read('top') this.$rm.read('bottom') }}&lt;/script&gt;复制代码</pre><p>但是这么做会产生一个问题，由于一个<strong>资源管理器</strong>对应一个 $rm.$result，它只维护一份请求回来的数据以及 loading 状态，因此如上代码中，$rm.$result 最终只会保存 $rm.read('bottom') 的数据。当然了，有时候这是符合需求的，但如果需要保存两次调用的数据，那么就需要 fork 出一个新的资源管理器：</p><pre>&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 创建一个资源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type)) this.$rm2 = this.$rm.fork()  // 连续获取两次数据 this.$rm.read('top') this.$rm2.read('bottom') }}&lt;/script&gt;复制代码</pre><p>这样，由于 $rm 与 $rm2 是两个独立的资源管理器，因此它们互不影响。</p><p>prevent 选项与防止重复提交</p><p>假设我们正在提交表单，如果用户连续两次点击按钮，就会造成重复提交，如下例子：</p><pre>&lt;template&gt; &lt;button @click="submit"&gt;提交&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 创建一个资源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type)) }, methods: { submit() { this.$rm.read(data) } }}&lt;/script&gt;复制代码</pre><p>实际上，我们可以在创建资源管理器的时候提供 prevent 选项，这样创建出来的资源管理器将自动为我们防止重复提交：</p><pre>&lt;template&gt; &lt;button @click="submit"&gt;提交&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 创建一个资源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type), { prevent: true }) }, methods: { submit() { this.$rm.read(data) } }}&lt;/script&gt;复制代码</pre><p>当第一次点击按钮时会发送一个请求，在这个请求完成之前，将不会再次发送下一次请求。直到上一次请求完成之后，$rm.read() 函数才会再次发送请求。</p><p>loading 的展示形态</p><p>loading 的展示形态可以分为两种：一种是只展示 loading，不展示其他内容；另一种是正常渲染其他内容的同时展示 loading，比如页面顶部有一个长长的加载条，这个加载条不影响其他内容的正常渲染。</p><p>因此 vue-async-manager 提供了两种渲染模式：</p><pre>import VueAsyncManager from 'vue-async-manager'Vue.use(VueAsyncManager, { mode: 'visible' // 指定渲染模式，可选值为 'visible' | 'hidden'，默认值为：'visible'})复制代码</pre><p>默认情况下采用 'visible' 的渲染模式，意味着 loading 的展示可以与其他内容共存，如果你不想要这种渲染模式，你可以指定 mode 为 'hidden'。</p><p>另外以上介绍的内容都是由 &lt;Suspense> 组件来控制 loading 的展示，并且 loading 的内容由 &lt;Suspense> 组件的 fallback 插槽决定。但有的时候我们希望更加灵活，我们经常遇到这样的场景：点击按钮的同时在按钮上展示一个微小的 loading 状态，我们的代码看上去可能是这样的：</p><pre>&lt;MyButton :loading="isLoading" &gt;提交&lt;/MyButton&gt;复制代码</pre><p>loading 的形态由 &lt;MyButton> 组件提供，换句话说，我们抛弃了 &lt;Suspense> 的 fallback 插槽作为 loading 来展示。因此，我们需要一个手段来得知当前是否处于正在加载的状态，在上面我们已经介绍了该问题的解决办法，我们可以使用资源管理器的 $rm.$loading 属性：</p><pre>&lt;MyButton :loading="$rm.$loading" &gt;提交&lt;/MyButton&gt;复制代码</pre><p>错误处理</p><p>当 lazy 组件加载失败会展示 &lt;Suspense> 组件的 error 插槽，你也可以通过监听 &lt;Suspense> 的 rejected 事件来自定义错误处理。</p><p>:::tip Live Demo: 加载失败展示 error 插槽 :::</p><p>当错误发生时除了展示 error 插槽，你还可以通过监听 &lt;Suspense> 组件的 rejected 事件来自定义处理：</p><pre>&lt;template&gt; &lt;Suspense :delay="200" @rejected="handleError"&gt; &lt;p class="fallback" slot="fallback"&gt;loading&lt;/p&gt; &lt;AsyncComponent/&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script&gt;export default { // ...... methods: { handleError() { // Custom behavior } }};&lt;/script&gt;复制代码</pre><div class=pgc-img><img alt="管理 Vue 应用中的异步调用  vue-asyn-manager" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/989fa71e-f05e-4a87-9e09-b1da24542257><p class=pgc-img-caption></p></div><p>:::tip Live Demo: 通过事件处理 error :::</p><p>关于 LRU 缓存</p><p>React Cache 使用 LRU 算法缓存资源，这要求 API 具有幂等性，然而在我的工作环境中，在给定时间周期内真正幂等的 API 很少，因此暂时没有提供对缓存资源的能力。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Vue','应用','异步'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>