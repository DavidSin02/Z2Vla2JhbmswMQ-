<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用 Refit 框架访问 REST 接口 | 极客快訊</title><meta property="og:title" content="使用 Refit 框架访问 REST 接口 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5ec2341f607b4b9e86391a5b41edd175"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/37f6c6e3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/37f6c6e3.html><meta property="article:published_time" content="2020-11-14T21:00:28+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:28+08:00"><meta name=Keywords content><meta name=description content="使用 Refit 框架访问 REST 接口"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/37f6c6e3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用 Refit 框架访问 REST 接口</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>转载自【零度编程】，原文地址：https://www.xcode.me/post/5918</p><p><br></p><div class=pgc-img><img alt="使用 Refit 框架访问 REST 接口" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ec2341f607b4b9e86391a5b41edd175><p class=pgc-img-caption></p></div><p><br></p><p>Refit 是一个类型安全的 REST 开源库，是一套基于 RESTful 架构的 .NET 客户端实现，内部使用 HttpClient 类封装，可通过 Refit 更加简单安全地访问 Web API 接口，要使用 Refit 框架，只需要在项目中通过 NuGet 包安装器安装即可。</p><pre><code>Install-Package refit</code></pre><p>使用方法很简单：</p><pre><code>public interface IGitHubApi{	[Get("/users/{userid}")]	Task&lt;User&gt; GetUser(string userid);}</code></pre><p>以上方法定义一个 REST API 接口，该接口定义了 GetUser 函数，该函数通过 HTTP GET 请求去访问服务器的 /users/{userid} 路径并把返回的结果封装为 User 对象返回，其中 URL 路径中 {userid} 的值为 GetUser 函数的 userid 参数取值，然后，通过 RestService 类生成 IGitHubApi 的代理实现，通过代理直接调用 Web API 接口。</p><pre><code>var gitHubApi = RestService.For&lt;IGitHubApi&gt;("https://api.xcode.me");var octocat = await gitHubApi.GetUser("xcode");</code></pre><h2 class=pgc-h-arrow-right>API Attributes特性</h2><p>通过 Attribute 特性标记，指定请求方法和相对 URL 地址，内置支持 Get、Post、Put、Delete 和 Head 方法。</p><pre><code>[Get("/users/list")]</code></pre><p>也可以在 URL 中指定查询参数：</p><pre><code>[Get("/users/list?sort=desc")]</code></pre><p>方法中的 URL 地址可以使用占位符，占位符是由 {} 包围的字符串，如果函数参数与 URL 路径中的占位符名称不同，可使用 AliasAs 指定别名。</p><pre><code>[Get("/group/{id}/users")]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs("id")] int groupId)</code></pre><p>值得注意的是，参数名称和 URL 参数占位符不区分大小写，如果一个函数参数未被 URL 占位符所使用，那么它将自动被当作 QueryString 查询字符串来使用。</p><pre><code>[Get("/group/{id}/users")]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs("id")] int groupId, [AliasAs("sort")] string sortOrder);</code></pre><p>当我们调用 GroupList 方法时，相当于请求 "/group/4/users?sort=desc"这个地址，其中 sort 参数被当作 GET 参数自动使用。</p><h2 class=pgc-h-arrow-right>Dynamic Querystring Parameters</h2><p>函数参数可传递对象，对象的字段属性将被自动追加到 Querystring 查询字符串。</p><pre><code>public class MyQueryParams{	[AliasAs("order")]	public string SortOrder { get; set; }		public int Limit { get; set; }}[Get("/group/{id}/users")]Task&lt;List&lt;User&gt;&gt; GroupList([AliasAs("id")] int groupId, MyQueryParams param);[Get("/group/{id}/users")]Task&lt;List&lt;User&gt;&gt; GroupListWithAttribute([AliasAs("id")] int groupId, [Query(".","search")] MyQueryParams param);param.SortOrder = "desc";param.Limit = 10;GroupList(4, param)&gt;&gt;&gt; "/group/4/users?order=desc&amp;Limit=10"GroupListWithAttribute(4, param)&gt;&gt;&gt; "/group/4/users?search.order=desc&amp;search.Limit=10"</code></pre><h2 class=pgc-h-arrow-right>Collections as Querystring parameters</h2><p>除了支持对象参数外，还是支持集合参数，下面是使用示例：</p><pre><code>[Get("/users/list")]Task Search([Query(CollectionFormat.Multi)]int[] ages);Search(new [] {10, 20, 30})&gt;&gt;&gt; "/users/list?ages=10&amp;ages=20&amp;ages=30"[Get("/users/list")]Task Search([Query(CollectionFormat.Csv)]int[] ages);Search(new [] {10, 20, 30})&gt;&gt;&gt; "/users/list?ages=10%2C20%2C30"</code></pre><h2 class=pgc-h-arrow-right>Body内容</h2><p>通过使用 BodyAttribute 特性，将函数参数追加到 HTTP 请求的 Body 部分。</p><pre><code>[Post("/users/new")]Task CreateUser([Body] User user);</code></pre><p>根据参数的类型，提供 Body 数据有四种可能：如果类型为 Stream 流类型，则内容将通过 StreamContent 流式传输。如果类型是 String 字符串类型，则该字符串将直接用作内容。如果参数具有 [Body(BodySerializationMethod.UrlEncoded)] 属性，内容将被 URL 编码后使用。对于以上除外的其它类型，对象将被序列化为 JSON 传输。</p><h2 class=pgc-h-arrow-right>JSON内容</h2><p>基于 JSON 的请求和响应，内部使用 JSON.NET 框架进行序列化和反序列化，默认情况下，Refit 框架将使用 JsonConvert.DefaultSettings 来配置序列化器的行为：</p><pre><code>JsonConvert.DefaultSettings =    () =&gt; new JsonSerializerSettings() {        ContractResolver = new CamelCasePropertyNamesContractResolver(),        Converters = {new StringEnumConverter()}    };// Serialized as: {"day":"Saturday"}await PostSomeStuff(new { Day = DayOfWeek.Saturday });</code></pre><p>因为静态属性 DefaultSettings 是全局设置，它会影响整个应用程序，有些时候，我们希望对某些 API 请求使用特定序列化设置，可以使用 RefitSettings 来指定。</p><pre><code>var gitHubApi = RestService.For&lt;IGitHubApi&gt;("https://api.xcode.me",    new RefitSettings {        JsonSerializerSettings = new JsonSerializerSettings {            ContractResolver = new SnakeCasePropertyNamesContractResolver()        }    });var otherApi = RestService.For&lt;IOtherApi&gt;("https://api.xcode.me",    new RefitSettings {        JsonSerializerSettings = new JsonSerializerSettings {            ContractResolver = new CamelCasePropertyNamesContractResolver()        }    });</code></pre><p>对象属性的序列化行为可以通过 JSON.NET 框架本身的 JsonPropertyAttribute 特性定制：</p><pre><code>public class Foo {    // Works like [AliasAs("b")] would in form posts (see below)    [JsonProperty(PropertyName="b")]    public string Bar { get; set; }}</code></pre><h2 class=pgc-h-arrow-right>Form posts</h2><p>对于采用表单提交数据（application/x-www-form-urlencoded）的 API 接口，使用 BodySerializationMethod.UrlEncoded 初始化 BodyAttribute 特性，参数可以是一个 IDictionary 字典。</p><pre><code>public interface IMeasurementProtocolApi{    [Post("/collect")]    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Dictionary&lt;string, object&gt; data);}var data = new Dictionary&lt;string, object&gt; {    {"v", 1},    {"tid", "UA-1234-5"},    {"cid", new Guid("d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c")},    {"t", "event"},};// Serialized as: v=1&amp;tid=UA-1234-5&amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;t=eventawait api.Collect(data);</code></pre><p>通过表单提交传递数据，也可以是任何对象，对象的所有公开属性和字段将被序列化，可使用 AliasAs 指定别名：</p><pre><code>public interface IMeasurementProtocolApi{    [Post("/collect")]    Task Collect([Body(BodySerializationMethod.UrlEncoded)] Measurement measurement);}public class Measurement{    // Properties can be read-only and [AliasAs] isn't required    public int v { get { return 1; } }     [AliasAs("tid")]    public string WebPropertyId { get; set; }    [AliasAs("cid")]    public Guid ClientId { get; set; }    [AliasAs("t")]    public string Type { get; set; }    public object IgnoreMe { private get; set; }}var measurement = new Measurement {    WebPropertyId = "UA-1234-5",    ClientId = new Guid("d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c"),    Type = "event" };// Serialized as: v=1&amp;tid=UA-1234-5&amp;cid=d1e9ea6b-2e8b-4699-93e0-0bcbd26c206c&amp;t=eventawait api.Collect(measurement);</code></pre><h2 class=pgc-h-arrow-right>设置静态请求头</h2><p>您可以使用 HeadersAttribute 特性设置一个或多个 HTTP 静态请求标头：</p><pre><code>[Headers("User-Agent: Awesome Octocat App")][Get("/users/{user}")]Task&lt;User&gt; GetUser(string user);</code></pre><p>也可以通过将 HeadersAttribute 特性应用于接口，这将影响该接口中的所有请求方法：</p><pre><code>[Headers("User-Agent: Awesome Octocat App")]public interface IGitHubApi{    [Get("/users/{user}")]    Task&lt;User&gt; GetUser(string user);        [Post("/users/new")]    Task CreateUser([Body] User user);}</code></pre><h2 class=pgc-h-arrow-right>设置动态请求头</h2><p>如果请求头需要在运行时设置，则可以通过将 HeaderAttribute 特性应用到函数参数，从而为请求头添加动态值。</p><pre><code>[Get("/users/{user}")]Task&lt;User&gt; GetUser(string user, [Header("Authorization")] string authorization);// Will add the header "Authorization: token OAUTH-TOKEN" to the requestvar user = await GetUser("octocat", "token OAUTH-TOKEN");</code></pre><h2 class=pgc-h-arrow-right>授权(动态请求头)</h2><p>标头最常见的用途是授权，今天，大多数 API 都使用 oAuth 协议通过访问令牌授权，申请访问令牌，即可访问 API 接口，访问令牌到期后需要刷新令牌，取得更长寿命的令牌，封装这些令牌的操作，可通过自定义 HttpClientHandler 来实现：</p><pre><code>class AuthenticatedHttpClientHandler : HttpClientHandler{    private readonly Func&lt;Task&lt;string&gt;&gt; getToken;    public AuthenticatedHttpClientHandler(Func&lt;Task&lt;string&gt;&gt; getToken)    {        if (getToken == null) throw new ArgumentNullException(nameof(getToken));        this.getToken = getToken;    }    protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)    {        // See if the request has an authorize header        var auth = request.Headers.Authorization;        if (auth != null)        {            var token = await getToken().ConfigureAwait(false);            request.Headers.Authorization = new AuthenticationHeaderValue(auth.Scheme, token);        }        return await base.SendAsync(request, cancellationToken).ConfigureAwait(false);    }}</code></pre><p>虽然 HttpClient 包含几乎相同的方法签名, 但使用方式不同，HttpClient.SendAsync 没有被改装，必须改为修改 HttpClientHandler，像这样使用：</p><pre><code>class LoginViewModel{    AuthenticationContext context = new AuthenticationContext(...);        private async Task&lt;string&gt; GetToken()    {        // The AcquireTokenAsync call will prompt with a UI if necessary        // Or otherwise silently use a refresh token to return        // a valid access token	        var token = await context.AcquireTokenAsync("http://my.service.uri/app", "clientId", new Uri("callback://complete"));                return token;    }    public async void LoginAndCallApi()    {        var api = RestService.For&lt;IMyRestService&gt;(new HttpClient(new AuthenticatedHttpClientHandler(GetToken)) { BaseAddress = new Uri("https://the.end.point/") });        var location = await api.GetLocationOfRebelBase();    }}interface IMyRestService{    [Get("/getPublicInfo")]    Task&lt;Foobar&gt; SomePublicMethod();    [Get("/secretStuff")]    [Headers("Authorization: Bearer")]    Task&lt;Location&gt; GetLocationOfRebelBase();}</code></pre><p>在上面的例子中，当需要调用具有身份验证的接口时，AuthenticatedHttpClientHandler 将尝试获取一个新的访问令牌。由应用程序提供一个，检查现有访问令牌的到期时间，并在需要时获取新的访问令牌。</p><h2 class=pgc-h-arrow-right>‎重新定义标头‎</h2><p>当定义 HTTP 标头时，对于多次设置同名的标头，这些重名的标头不会相互覆盖，都将被添加到请求头中，值得注意的是，标头设置的优先级不同时，重新定义标头将被替换，它们的优先级是：</p><p>1、接口上的 Headers 特性（最低优先级），2、方法上的 Headers 特性，3、方法参数上的 Header 特性（最高优先级）</p><pre><code>[Headers("X-Emoji: :rocket:")]public interface IGitHubApi{    [Get("/users/list")]    Task&lt;List&gt; GetUsers();        [Get("/users/{user}")]    [Headers("X-Emoji: :smile_cat:")]    Task&lt;User&gt; GetUser(string user);        [Post("/users/new")]    [Headers("X-Emoji: :metal:")]    Task CreateUser([Body] User user, [Header("X-Emoji")] string emoji);}// X-Emoji: :rocket:var users = await GetUsers();// X-Emoji: :smile_cat:var user = await GetUser("octocat");// X-Emoji: :trollface:await CreateUser(user, ":trollface:");</code></pre><h2 class=pgc-h-arrow-right>删除标头</h2><p>当使用 HeadersAttribute 不提供值或者提供的值为 null 时， 请求表头将被自动移除。</p><pre><code>[Headers("X-Emoji: :rocket:")]public interface IGitHubApi{    [Get("/users/list")]    [Headers("X-Emoji")] // Remove the X-Emoji header    Task&lt;List&gt; GetUsers();        [Get("/users/{user}")]    [Headers("X-Emoji:")] // Redefine the X-Emoji header as empty    Task&lt;User&gt; GetUser(string user);        [Post("/users/new")]    Task CreateUser([Body] User user, [Header("X-Emoji")] string emoji);}// No X-Emoji headervar users = await GetUsers();// X-Emoji:var user = await GetUser("octocat");// No X-Emoji headerawait CreateUser(user, null);// X-Emoji:await CreateUser(user, "");</code></pre><h2 class=pgc-h-arrow-right>Multipart uploads</h2><p>Refit 框架也支持字节流和文件流的上传：</p><pre><code>public interface ISomeApi{    [Multipart]    [Post("/users/{id}/photo")]    Task UploadPhoto(int id, [AliasAs("myPhoto")] StreamPart stream);		someApiInstance.UploadPhoto(id, new StreamPart(myPhotoStream, "photo.jpg", "image/jpeg"));}</code></pre><h2 class=pgc-h-arrow-right>响应处理</h2><p>为了提高性能 Refit 只支持方法返回 Task 和 IObservable 类型，如需同步请求，可使用 async 和 await 异步技术。</p><pre><code>[Post("/users/new")]Task CreateUser([Body] User user);// This will throw if the network call failsawait CreateUser(someUser);</code></pre><p>如果类型参数为 HttpResponseMessage 或 string 类型，可以通过重载函数来分别返回。</p><pre><code>// Returns the content as a string (i.e. the JSON data)[Get("/users/{user}")]Task&lt;string&gt; GetUser(string user);// Returns the raw response, as an IObservable that can be used with the// Reactive Extensions[Get("/users/{user}")]IObservable&lt;HttpResponseMessage&gt; GetUser(string user);</code></pre><h2 class=pgc-h-arrow-right>使用通用接口</h2><p>有的 Web API 拥有一整套基于 CRUD 操作的 REST 服务，Refit 允许您使用通用泛型定义接口：</p><pre><code>public interface IReallyExcitingCrudApi&lt;T, in TKey&gt; where T : class{    [Post("")]    Task&lt;T&gt; Create([Body] T payload);    [Get("")]    Task&lt;List&lt;T&gt;&gt; ReadAll();    [Get("/{key}")]    Task&lt;T&gt; ReadOne(TKey key);    [Put("/{key}")]    Task Update(TKey key, [Body]T payload);    [Delete("/{key}")]    Task Delete(TKey key);}</code></pre><p>可以这样来调用以上接口封装：</p><pre><code>// The "/users" part here is kind of important if you want it to work for more// than one type (unless you have a different domain for each type)var api = RestService.For&lt;IReallyExcitingCrudApi&lt;User, string&gt;&gt;("http://api.xcode.me/users");</code></pre><h2 class=pgc-h-arrow-right>Using HttpClientFactory</h2><p>在 ASP.Net Core 2.1 中，可通过 Refix 框架提供的扩展方法注入类型客户端：</p><pre><code>public void ConfigureServices(IServiceCollection services){    services.AddHttpClient("hello", c =&gt;    {        c.BaseAddress = new Uri("http://api.xcode.me");    })    .AddTypedClient(c =&gt; Refit.RestService.For&lt;IHelloClient&gt;(c));    services.AddMvc();}</code></pre><p>除此之外，还支持通过 HttpClientFactory 创建请求代理，Refit 为此提供扩展，用此扩展前需要通过 NuGet 引用以下包，</p><pre><code>Install-Package Refit.HttpClientFactory</code></pre><p>引用程序包后，可以这样来配置：</p><pre><code>services.AddRefitClient&lt;IWebApi&gt;()        .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri("https://api.xcode.me"));        // Add additional IHttpClientBuilder chained methods as required here:        // .AddHttpMessageHandler&lt;MyHandler&gt;()        // .SetHandlerLifetime(TimeSpan.FromMinutes(2));</code></pre><p>也可以通过 RefitSettings 设置行为:</p><pre><code>var settings = new RefitSettings();// Configure refit settings hereservices.AddRefitClient&lt;IWebApi&gt;(settings)        .ConfigureHttpClient(c =&gt; c.BaseAddress = new Uri("https://api.xcode.me"));        // Add additional IHttpClientBuilder chained methods as required here:        // .AddHttpMessageHandler&lt;MyHandler&gt;()        // .SetHandlerLifetime(TimeSpan.FromMinutes(2));</code></pre><p>然后, 您可以使用构造函数将请求接口注入到控制器之中：</p><pre><code>public class HomeController : Controller{    public HomeController(IWebApi webApi)    {        _webApi = webApi;    }    private readonly IWebApi _webApi;    public async Task&lt;IActionResult&gt; Index(CancellationToken cancellationToken)    {        var thing = await _webApi.GetSomethingWeNeed(cancellationToken);        return View(thing);    }}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Refit','访问','REST'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>