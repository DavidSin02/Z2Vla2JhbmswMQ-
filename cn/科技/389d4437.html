<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python常用算法学习(5) 树二叉树（原理+代码）-最全总结 | 极客快訊</title><meta property="og:title" content="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/389d4437.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/389d4437.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/389d4437.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/389d4437.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/389d4437.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/389d4437.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/389d4437.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/389d4437.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/389d4437.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python常用算法学习(5) 树二叉树（原理+代码）-最全总结</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1，树</p><p>　　树是一种非常重要的非线性数据结构，直观的看，它是数据元素（在树中称为节点）按分支关系组织起来的结构，很像自然界中树那样。树结构在客观世界中广泛存在，如人类社会的族谱和各种社会组织机构都可用树形象表示。树在计算机领域中也得到了广泛应用，如在编译源程序时，可用树表示源程序的语法结构。又如在数据库系统中，树型结构也是信息的重要组织形式之一。一切具有层次关系的问题都可以用树来描述。</p><p>　　树（Tree）是元素的集合。树的定义是递归的，树是一种递归的数据结构。比如：目录结构。树是由n个结点组成的集合：如果n=0，那这就是一颗空树；如果 n>0，那么存在1个结点作为树的根节点，其他结点可以分为m个集合，每个集合本身又是一棵树。</p><ul><li>1，树的根结点没有前驱结点，除根结点之外所有结点有且只有一个前驱结点。</li><li>2，树中所有结点可以有零个或者多个后继结点。</li></ul><h4 class=pgc-h-arrow-right>1.1 树的术语</h4><ol start=1><li>根节点：树的第一个节点，没有父节点的节点</li><li>叶子节点：不带分叉的节点</li><li>树的深度（高度）：就是分了多少层</li><li>孩子节点，父节点：节点与节点之间的关系</li></ol><p>　　如下图，我们分别解释：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6><p class=pgc-img-caption></p></div><p></p><p>　 1）B是K的祖先结点，K是B的子孙节点，E是K的双亲节点，K是E的孩子节点，K是L的兄弟节点。</p><p>　　2）树中一个结点的子节点个数为该节点的度，树中结点最大度数为树的度。</p><p>　　3）度大于0为节点结点，度等于0为叶子结点。</p><p>　　4）结点层次如图，结点深度时从根结点从顶往下累加，结点高度从低往上累加，树的高度（深度）是树的最大层数。</p><p>　　5）有序树：从左到右有次序，有关联。反之为无序树。</p><p>　　6）两结点之间的路径是两个结点之间所经过的结点序列构成的，路径长度是路径上所经过的边的个数。</p><p>　　7）森林是 m （m >=0）棵互不相交的集合。</p><p>　　上面观察实际上给了我们一种严格的定义树的方法：</p><ul><li>1，树是元素的集合</li><li>2，该集合可以为空，这时树中没有元素，我们称树为空树（empty tree）</li><li>3，如果该集合不为空，那么该集合有一个根节点，以及0个或者多个子树。根节点与他的子树的根节点用一个边（edge）相连。</li></ul><h4 class=pgc-h-arrow-right>1.2 树的实现</h4><p>　　树的示意图已经给出了树的一种内存实现方法：每个节点存储元素和多个指向子节点的指针。然而，子节点数目的是不确定的。一个父节点可能有大量的子节点，而另一个父节点可能只有一个子节点，而树的增删节点操作会让子节点的数目发生进一步的变换。这种不确定性就可能就可能带来大量的内存相关操作，并且容易造成内存的浪费。</p><p>　　一种经典的实现方法如下：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0fa5dd92ef9b4c7d998bbfed1b1beec3><p class=pgc-img-caption></p></div><p><strong>　　树的内存实现：</strong>拥有同一父节点的两个结点互为兄弟节点（sibling）。上图的实现方式中，每个节点包含一个指针指向第一个子节点，并且有另一个指针指向他的下一个兄弟节点。这样，我们就可以用统一的，确定的结构来表示每个节点。</p><h4 class=pgc-h-arrow-right>1.3 树的实例——模拟文件系统</h4><p>　　代码如下：</p><pre><code>#_*_coding:utf-8_*_ class Node:    def __init__(self, name, type='dir'):        self.name = name        self.type = type  # 'dir'  or ; 'file'        self.children = []        self.parent = None        # 链式存储     def __repr__(self):        return self.name  class FileSystemTree:    def __init__(self):        self.root = Node("/")  # 首先我们创建一个根目录        self.now = self.root     def mkdir(self, name):        # 创建一个文件目录，所以我们必须保证name是以 /结尾，如果没有，我们就加        if name[-1] != '/':            name += '/'        node = Node(name)        # 创建一个文件目录        self.now.children.append(node)        node.parent = self.now     def ls(self):        # 展示当前文件夹下的文件        return self.now.children     def cd(self, name):        # 切换到指定目录  注意：支持绝对路径和相对路径        # 相对路径是从now的路径下开始，而绝对路径是从root路径下开始找        if name[-1] != '/':            name += '/'        if name == '../':            self.now = self.now.parent            return        for child in self.now.children:            if child.name == name:                # 如果传入的目录名等于孩子的目录名，我们直接切换                self.now = child                return        raise ValueError("invalid dir")  tree = FileSystemTree()tree.mkdir('var/')tree.mkdir('bin/')tree.mkdir('usr/')print(tree.ls())  # [var/, bin/, usr/]tree.cd('bin/')print(tree.ls())  # []print(tree.root.children)  # [var/, bin/, usr/]</code></pre><p>2，二叉树</p><h4 class=pgc-h-arrow-right>2.1 二叉树的定义</h4><p>　　二叉树的链式存储：将二叉树的节点定义为一个对象，节点之间通过类似链表的链接方式来连接。</p><p>　　二叉树是一种特殊的树，它具有以下特点：</p><p>　　1）至多只有两棵子树，二叉树有左右之分，次序不能颠倒，也是递归形式定义。</p><p>　　2）或者为空二叉树，即 n=0</p><p>　　3）或者由一个根结点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别是一颗二叉树。</p><p>　　4）每个节点至多有两个节点，即每个节点的度最多为2</p><p>　　5）二叉树中所有节点的形态有5种：空节点，无左右子树的节点，只有左子树的节点，只有右子树的节点和具有左右子树的节点</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27fb445860f744a38c15d9a0c5b4d80d><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>　　二叉树的定义如下：</h4><pre><code>class BiTreeNode:    def __init__(self, data):        self.data = data        self.lchild = None  # 左孩子        self.rchild = None  # 右孩子 a = BiTreeNode("A")b = BiTreeNode("B")c = BiTreeNode("C")d = BiTreeNode("D")e = BiTreeNode("E")f = BiTreeNode("F")g = BiTreeNode("G") e.lchild = ae.rchild = ga.rchild = cc.lchild = bc.rchild = dg.rchild = f root = eprint(root.lchild.rchild.data)</code></pre><p><strong>二叉树的节点定义</strong>：</p><pre><code>class BiTreeNode:    def __init__(self, data):        self.data = data        self.lchild = None  # 左孩子        self.rchild = None  # 右孩子</code></pre><p>2.2 二叉树与度为2的有序树的区别：</p><p>　　1）度为2的树至少有3个结点，而二叉树可以为空。</p><p>　　2）左右次数。</p><h3 class=pgc-h-arrow-right></h3><h4 class=pgc-h-arrow-right>2.3 二叉树的存储方式</h4><p>　　二叉树的存储结构分为链式存储结构和顺序存储结构（列表）</p><p><strong>二叉树的顺序存储方式</strong></p><p>　　 思考：<strong>父节点和左孩子节点的编号下标有什么关系？</strong></p><p>　　 0-1 1-3 2-5 3-7 4-9 i ----> 2i+1</p><p>　　<strong>父节点和右孩子节点的编号下标有有什么关系？</strong></p><p>　　0-2 1-4 2-6 3-8 4-10 i -----> 2i+2</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c8d16811660d4116bf2189a6e8c76ab7><p class=pgc-img-caption></p></div><p><strong>二叉树的链式存储</strong></p><p>　　结构采用链式存储二叉树中的数据元素，用链建立二叉树中结点之间的关系。二叉树最常用的链式存储结构是二叉链，每个节点包含三个域，分别是数据元素域 data，左孩子链域 LChild 和 右孩子链域 rChild。与单链表带头结点和不带头节点的两种情况相似，二叉链存储结构的二叉树也有带头结点和不带头节点两种。</p><h4 class=pgc-h-arrow-right>2.4 二叉树的遍历</h4><p>　　那么如何遍历一颗二叉树呢？其实有两种通用的遍历树策略：</p><h4 class=pgc-h-arrow-right>深度优先搜索（DFS）</h4><p>　　在这个策略中，我们采用深度作为优先级，以便从根开始一直到达某个确定的叶子，然后再返回根到达另一个分支。</p><p>　　深度优先搜索策略又可以根据根节点，左孩子和右孩子的相对顺序被细分为先序遍历，中序遍历和后序遍历。</p><h4 class=pgc-h-arrow-right>宽度优先搜索（BFS）</h4><p>　　我们按照高度顺序一层一层的访问整棵树，高层次的节点将会被低层次的节点先被访问到。</p><p>下图中的顶点按照访问的顺序编号，按照1-2-3-4-5 的顺序来比较不同的策略：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ff1598166ac46cc913ea9e75ba57e2d><p class=pgc-img-caption></p></div><p>　　下面学习二叉树的遍历方式，以下图的二叉树为例，我们分别学习前序遍历，中序遍历，后序遍历，层次遍历。</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc51802e911f4574b77c023a7def4766><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>前序遍历</h4><p>　　思想：先访问根节点，再先序遍历左子树，然后再序遍历右子树。总的来说是 根——左——右</p><p>　　前序遍历如图所示：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/caeea550866645a3b0c7f4f079a33fb3><p class=pgc-img-caption></p></div><p>　　代码如下：</p><pre><code># 二叉树的前序遍历def pre_order(root):    if root:        print(root.data)  # 先打印根节点        pre_order(root.lchild)        pre_order(root.rchild) # pre_order(root)'''EACBDGF'''</code></pre><p>中序遍历</p><p>　　思想：先中序访问左子树，再序访问根节点，最后中序遍历右子树。总的来说是 左——根——右</p><p>　　中序遍历如图所示：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/782df6bb32c64f38bf079d44c620487e><p class=pgc-img-caption></p></div><p>　　代码如图所示：</p><pre><code># 中序遍历def in_order(root):    if root:        in_order(root.lchild)        print(root.data)        in_order(root.rchild) # in_order(root)'''ABCDEGF'''</code></pre><p>后序遍历</p><p>　　思想：先后续访问左子树，然后后续访问右子树，最后访问根，总的来说是 左——右——根</p><p>　　后序遍历如图所示：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/966b5cff88584207a598ba43fe49265d><p class=pgc-img-caption></p></div><p>　　代码如下：</p><pre><code># 后序遍历def post_order(root):    if root:        post_order(root.lchild)        post_order(root.rchild)        print(root.data) post_order(root)'''BDCAFGE'''</code></pre><p>层次遍历（宽度优先遍历）</p><p>　　思想：利用<strong>队列</strong>，依次将根，左子树，右子树存入队列，按照<strong>队列</strong>的<strong>先进先出</strong>规则来实现层次遍历。</p><p>　　按照上面的例子：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ace9ee324bfb46858222201b579eb4a6><p class=pgc-img-caption></p></div><p>　　简单来说就是：根节点进队，然后出队，接着孩子节点入队，当队列为空则停止循环。</p><p>　　当E进队，然后E出队，E出队后，他的左孩子和右孩子进队，也就是AG；然后A出队，他没有左孩子，右孩子C进队，然后G出队，它没有左孩子，右孩子F进队。。。。。。</p><p>　　代码如下：</p><pre><code>from collections import deque def level_order(root):    queue = deque()    queue.append(root)    while len(queue) &gt; 0:  # 只要队不空        node = queue.popleft()        print(node.data)        if node.lchild:            queue.append(node.lchild)        if node.rchild:            queue.append(node.rchild) level_order(root)'''EAGCFBD'''</code></pre><p>3 几个特殊的二叉树</p><h4 class=pgc-h-arrow-right>3.1 满二叉树</h4><p>　　满二叉树作为一种特殊的二叉树，它是指：除了叶子节点，所有节点都有两个孩子（左子树和右子树），并且所有叶子节点深度都一样。</p><p>　　其特点有：</p><ul><li>1）叶子节点只能出现在最下面一层</li><li>2）非叶子节点度一定是2</li><li>3）在同样深度的二叉树中，满二叉树的节点个数最多，节点个数为：2h-1，其h为树的深度。</li></ul><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a25a33070f524d0ca463aaf166c8f28a><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>3.2 完全二叉树</h4><p>　　完全二叉树是由满二叉树引申而来，假设二叉树深度为 h，那么除了第h层外，之前的每一层（1~h-1）的节点数都达到最大，即没有空的位置，而且第K层的子节点也都集中在左子树上（顺序）。</p><p>　　其具有以下特点：</p><ul><li>1）叶子节点可以出现在最后一层或倒数第二层</li><li>2）最后一层的叶子节点一定集中在左部连续位置</li><li>3）完全二叉树严格按层序编号（可利用数组或列表实现，满二叉树同理）</li><li>4）若一个节点为叶子节点，那么编号比其大的节点均为叶子节点</li></ul><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d6b289264e64dfbbc4fd2a2a9c5f5bf><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>3.3 二叉排序树</h4><p>　　一颗二叉树或者空二叉树，如：左子树上所有关键字均小于根结点的关键字，右子树上的所有结点的关键字均大于根结点的关键字，左子树和右子树各是一颗二叉排序树。</p><h4 class=pgc-h-arrow-right>3.4 平衡二叉树</h4><p>　　树上任何一结点的左子树和右子树的深度只差不超过1 。</p><h3 class=pgc-h-arrow-right>4， 二叉搜索树（BST）</h3><h4 class=pgc-h-arrow-right>4.1 二叉搜索树的定义</h4><p>　　二叉搜索树(Binary Search Tree)，又名二叉排序树(Binary Sort Tree)。</p><p>　　由于二叉树的子节点数目确定，所以可以直接采用下图方式在内存中实现。每个节点有一个左子节点（left children）和右子节点（right children）。左子节点是左子树的根节点，右子节点是右子树的根节点。</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/952117ab7b704a67ab123070d2275205><p class=pgc-img-caption></p></div><p>　　如果我们给二叉树加一个额外的条件，就可以得到一种被称为二叉搜索树（binary search tree）的特殊二叉树。二叉搜索树要求：<strong>每个节点都不比它左子树的任意元素小，而且不比它的右子树的任意元素大。</strong></p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c8a965723fdc46d8bcfa558627825218><p class=pgc-img-caption></p></div><p></p><p>　　二叉搜索树是一颗二叉树且满足性质：设x是二叉树的一个节点。如果 y 是 x 左子树的一个节点，那么 y.key &lt;= x.key；如果y 是x 的右子树的一个节点，那么 y.key >= x.key。</p><h4 class=pgc-h-arrow-right>4.2 二叉搜索树的性质</h4><ul><li>1）若左子树不为空，则左子树上所有节点的值均小于或等于它的根节点的值</li><li>2）若右子树不为空，则右子树上所有节点的值均大于或等于它的跟节点的值</li><li>3）左右子树也分别为二叉搜索树</li></ul><p>　　二叉搜索树，注意树中元素的大小。二叉搜索树可以方便的实现搜索算法。在搜索元素 x 的时候，我们可以将 x 和根节点比较：</p><ul><li>1，如果 x 等于根节点，那么找到 x ,停止搜索（终止条件）</li><li>2，如果 x 小于根节点，那么搜索左子树</li><li>3，如果 x 大于根节点，那么搜索右子树</li></ul><p>　　二叉搜索树所需要进行的操作次数最多与树的深度相等。n个结点的二叉搜索树的深度最多为 n ，最少为 log(n).</p><h4 class=pgc-h-arrow-right>4.3 二叉搜索树的插入操作</h4><p>　　从根节点开始，若插入的值比根节点的值小，则将其插入根节点的左子树；若比根节点的值大，则将其插入根节点的右子树。该操作可以使用递归进行实现。</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/763e80396ca4454195d1a9114b4cc5b1><p class=pgc-img-caption></p></div><p>　　代码如下：</p><pre><code>class BiTreeNode:    def __init__(self, data):        self.data = data        self.lchild = None  # 左孩子        self.rchild = None  # 右孩子        self.parent = None  class BST:    def __init__(self, li=None):        self.root = None        if li:            for val in li:                self.insert_no_rec(val)     def insert(self, node, val):        if not node:            node = BiTreeNode(val)        elif val &lt; node.data:            node.lchild = self.insert(node.lchild, val)            node.lchild.parent = node        elif val &gt; node.data:            node.rchild = self.insert(node.rchild, val)            node.rchild.parent = node        return node     def insert_no_rec(self, val):        p = self.root        if not p:  # 空树            self.root = BiTreeNode(val)            return        while True:            if val &lt; p.data:                if p.lchild:                    p = p.lchild                else:  # 左孩子不存在                    p.lchild = BiTreeNode(val)                    p.lchild.parent = p                    return            elif val &gt; p.data:                if p.rchild:                    p = p.rchild                else:                    p.rchild = BiTreeNode(val)                    p.rchild.parent = p                    return            else:                return</code></pre><p>4.4 二叉搜索树的查询操作</p><p>　　 从根节点开始查找，待查找的值是否与根节点的值相同，若相同则返回True；否则，判断待寻找的值是否比根节点的值小，若是则进入根节点左子树进行查找，否则进入右子树进行查找。该操作使用递归实现。</p><p>　　代码如下：</p><pre><code>def query(self, node, val):    if not node:        return None    if node.data &lt; val:        return self.query(node.rchild, val)    elif node.data &gt; val:        return self.query(node.lchild, val)    else:        return node</code></pre><p>4.5 二叉树的查询操作——找最大值（最小值）</p><p>　　<strong>查找最小值</strong>：从根节点开始，沿着左子树一直往下，直到找到最后一个左子树节点，按照定义可知，该节点一定是该二叉搜索树中的最小值节点。</p><p>　　程序代码如下：</p><pre><code>def findMin(self, root):    '''查找二叉搜索树中最小值点'''    if root.left:        return self.findMin(root.left)    else:        return root</code></pre><p>　　<strong>查找最大值</strong>：从根节点开始，沿着右子树一直往下，知道找到最后一个右子树节点，按照定义可知，该节点一定是该二叉搜索树中的最大值节点。</p><p>　　程序代码如下：</p><pre><code>def findMax(self, root):    '''查找二叉搜索树中最大值点'''    if root.right:        return self.findMax(root.right)    else:        return root</code></pre><h4 class=pgc-h-arrow-right>4.6 二叉搜索树的删除操作</h4><p>　　对二叉搜索树节点的删除操作分为以下三种情况</p><p><strong>　　1，如果要删除的节点是叶子节点：直接删除</strong></p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0af099c4020e4463b46b10f6c82eb8b7><p class=pgc-img-caption></p></div><p>　　<strong>2，如果要删除的节点只有一个孩子：将此节点的父亲与孩子连接，然后删除该节点（注意：该待删节点可能只有左子树或者右子树）</strong></p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ae84a256867a451d87ae851a0e0e8e72><p class=pgc-img-caption></p></div><p>　　<strong>3，如果要删除的节点有两个孩子：将其右子树的最小节点（该节点最多有一个右孩子）删除，并替换当前节点</strong></p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ecfe3ef676154bd7934cb5f59a8fb4da><p class=pgc-img-caption></p></div><p>　　代码如下：</p><pre><code># _*_coding:utf-8_*_import random  class BiTreeNode:    def __init__(self, data):        self.data = data        self.lchild = None  # 左孩子        self.rchild = None  # 右孩子        self.parent = None  class BST:    def __init__(self, li=None):        self.root = None        if li:            for val in li:                self.insert_no_rec(val)      def __remove_node_1(self, node):        # 第一种情况：node是叶子节点        if not node.parent:            self.root = None        if node == node.parent.lchild:  # node是他父亲的左孩子            node.parent.lchild = None            node.parent = None  # 可以不写        else:  # node是他父亲的右孩子            node.parent.rchild = None     def __remove_node_21(self, node):        # 情况2.1:node只有一个孩子，且为左孩子        if not node.parent:  # 根节点            self.root = node.lchild            node.lchild.parent = None        elif node == node.parent.lchild:  # node是它父亲的左孩子            node.parent.lchild = node.lchild            node.lchild.parent = node.parent        else:  # node 是它父亲的右孩子            node.parent.rchild = node.lchild            node.lchild.parent = node.parent     def __remove_node_22(self, node):        # 情况2.2：node只有一个孩子，且为右孩子        if not node.parent:            self.root = node.rchild        elif node == node.parent.lchild:            node.parent.lchild = node.rchild            node.rchild.parent = node.parent        else:            node.parent.rchild = node.rchild            node.rchild.parent = node.parent     def delete(self, val):        if self.root:  # 不是空树            node = self.query_no_rec(val)            if not node:  # 不存在                return False            if not node.lchild and not node.rchild:  # 1，叶子节点                self.__remove_node_1(node)            elif not node.rchild:  # 2.1 只有一个左孩子                self.__remove_node_21(node)            elif not node.lchild:  # 2.2 只有一个右孩子                self.__remove_node_22(node)            else:                # 3,两个孩纸都有                min_node = node.rchild                while min_node.lchild:  # 有左孩子                    min_node = min_node.lchild                node.data = min_node.data                # 删除min_node                if min_node.rchild:                    self.__remove_node_22(min_node)                else:                    self.__remove_node_1(min_node)</code></pre><p>4.7 二叉搜索树的打印操作</p><p>　　实现二叉搜索树的前序遍历，中序遍历，后序遍历，并打印出来。其中中序遍历打印出来的数列是按照递增顺序排列。</p><p>　　程序的代码如下：</p><pre><code>def printTree(self, root):    # 打印二叉搜索树（中序打印，有序数列—）    if root == None:        return    self.printTree(root.left)    print(root.val, end=',')    self.printTree(root.right)</code></pre><h4 class=pgc-h-arrow-right>4.8 二叉树的插入，查询，删除，打印完整代码</h4><p>　　代码如下：</p><pre><code># _*_coding:utf-8_*_import random  class BiTreeNode:    def __init__(self, data):        self.data = data        self.lchild = None  # 左孩子        self.rchild = None  # 右孩子        self.parent = None  class BST:    def __init__(self, li=None):        self.root = None        if li:            for val in li:                self.insert_no_rec(val)     def insert(self, node, val):        if not node:            node = BiTreeNode(val)        elif val &lt; node.data:            node.lchild = self.insert(node.lchild, val)            node.lchild.parent = node        elif val &gt; node.data:            node.rchild = self.insert(node.rchild, val)            node.rchild.parent = node        return node     def insert_no_rec(self, val):        p = self.root        if not p:  # 空树            self.root = BiTreeNode(val)            return        while True:            if val &lt; p.data:                if p.lchild:                    p = p.lchild                else:  # 左孩子不存在                    p.lchild = BiTreeNode(val)                    p.lchild.parent = p                    return            elif val &gt; p.data:                if p.rchild:                    p = p.rchild                else:                    p.rchild = BiTreeNode(val)                    p.rchild.parent = p                    return            else:                return     def query(self, node, val):        if not node:            return None        if node.data &lt; val:            return self.query(node.rchild, val)        elif node.data &gt; val:            return self.query(node.lchild, val)        else:            return node     def query_no_rec(self, val):        p = self.root        while p:            if p.data &lt; val:                p = p.rchild            elif p.data &gt; val:                p = p.lchild            else:                return p        return None     def pre_order(self, root):        if root:            print(root.data, end=',')            self.pre_order(root.lchild)            self.pre_order(root.rchild)     def in_order(self, root):        if root:            self.in_order(root.lchild)            print(root.data, end=',')            self.in_order(root.rchild)     def post_order(self, root):        if root:            self.post_order(root.lchild)            self.post_order(root.rchild)            print(root.data, end=',')     def __remove_node_1(self, node):        # 第一种情况：node是叶子节点        if not node.parent:            self.root = None        if node == node.parent.lchild:  # node是他父亲的左孩子            node.parent.lchild = None            node.parent = None  # 可以不写        else:  # node是他父亲的右孩子            node.parent.rchild = None     def __remove_node_21(self, node):        # 情况2.1:node只有一个孩子，且为左孩子        if not node.parent:  # 根节点            self.root = node.lchild            node.lchild.parent = None        elif node == node.parent.lchild:  # node是它父亲的左孩子            node.parent.lchild = node.lchild            node.lchild.parent = node.parent        else:  # node 是它父亲的右孩子            node.parent.rchild = node.lchild            node.lchild.parent = node.parent     def __remove_node_22(self, node):        # 情况2.2：node只有一个孩子，且为右孩子        if not node.parent:            self.root = node.rchild        elif node == node.parent.lchild:            node.parent.lchild = node.rchild            node.rchild.parent = node.parent        else:            node.parent.rchild = node.rchild            node.rchild.parent = node.parent     def delete(self, val):        if self.root:  # 不是空树            node = self.query_no_rec(val)            if not node:  # 不存在                return False            if not node.lchild and not node.rchild:  # 1，叶子节点                self.__remove_node_1(node)            elif not node.rchild:  # 2.1 只有一个左孩子                self.__remove_node_21(node)            elif not node.lchild:  # 2.2 只有一个右孩子                self.__remove_node_22(node)            else:                # 3,两个孩纸都有                min_node = node.rchild                while min_node.lchild:  # 有左孩子                    min_node = min_node.lchild                node.data = min_node.data                # 删除min_node                if min_node.rchild:                    self.__remove_node_22(min_node)                else:                    self.__remove_node_1(min_node)      def printTree(self, root):        # 打印二叉搜索树（中序打印，有序数列—）        if root == None:            return        self.printTree(root.left)        print(root.val, end=',')        self.printTree(root.right) # 删除tree = BST([1, 4, 2, 5, 3, 8, 6, 9, 7])tree.in_order(tree.root)print(" ")tree.delete(4)tree.delete(1)tree.delete(8)tree.in_order(tree.root) '''# 插入操作tree = BST([4,6,7,9,2,1,3,5,8])tree.pre_order(tree.root)print(" ")tree.in_order(tree.root)print(" ")tree.post_order(tree.root)print(" ")'''4, 2, 1, 3, 6, 5, 7, 9, 8,1, 2, 3, 4, 5, 6, 7, 8, 9,1, 3, 2, 5, 8, 9, 7, 6, 4,''' # 查询操作li = list(range(0, 500, 2))random.shuffle(li) tree = BST(li)print(tree.query_no_rec(4).data)# 4 '''</code></pre><p>4.9 二叉搜索树的效率</p><p>　　平均情况下，二叉搜索树进行搜索的时间复杂度为O(nlgn)</p><p>　　最坏情况下，二叉搜索树可能非常偏斜，如下图所示：</p><div class=pgc-img><img alt="Python常用算法学习(5) 树二叉树（原理+代码）-最全总结" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6a6f6c0ef8f846259c581817e203f118><p class=pgc-img-caption></p></div><p><strong>解决方案</strong>：</p><ol start=1><li>随机化传入</li><li>AVL树</li></ol><p></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Python','学习','代码'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>