<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>spring框架的入门学习：AOP和面向切面的事务 | 极客快訊</title><meta property="og:title" content="spring框架的入门学习：AOP和面向切面的事务 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/fb037e70190b458d9f24f56fef7a85d7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="spring框架的入门学习：AOP和面向切面的事务"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/393e0ea8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>spring框架的入门学习：AOP和面向切面的事务</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>使用注解配置spring，需要以下几个步骤：</p><p>需要导入一个包：</p><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fb037e70190b458d9f24f56fef7a85d7><p class=pgc-img-caption></p></div><p><br></p><p>步骤1：需要为主配置文件引入新的命名空间（约束），和之前介绍的一样，导入新的约束：</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4da26c639057465f9a090e469f98e919><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba06df1c52a74233a21cd14a850183d4><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5d512a2d066e49e29efcc9f222f09980><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/552e4e21c0ba4702b24bea12acd7e64d><p class=pgc-img-caption></p></div><p>然后在application.xml的Design中右击beans</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/53e40986bf8146da94fc6a93ec53c48a><p class=pgc-img-caption></p></div><p>然后Add</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c64f4857747e4b15964bdb1d5d9fde67><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ae317de62d54bbca1ae15ead89a83b4><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d41ce214201d4562a4994f40b1207d55><p class=pgc-img-caption></p></div><p>这里面的命名空间使用context，需要指定，这是因为在之前导入Bean命名空间的时候没有指定，而没有指定的只能有一个，多个就会出问题，所以以后在导入命名空间都需要指定profix</p><p><strong>2.开启使用注解代理配置文件</strong></p><p>&lt;context:component-scan base-package="com.huanfeng.bean">&lt;/context:component-scan></p><p>这个配置的就是说spring会去com.huanfeng.bean中扫描所有的注解（包括bean包下面的所有类以及子包下的所有类），那么我们下面就可以在com.huanfeng.bean下的所有类中使用注解配置文件了</p><p><strong>3.在类中使用注解配置文件</strong></p><p><strong>@Component("user")</strong></p><p><strong>这个配置在类上，表示为类创建一个对象，这个对象的名字是user</strong></p><p><strong>@Service("user")</strong></p><p><strong>@Controller("user")</strong></p><p><strong>@Repository("user")</strong></p><p><strong>以上的三个注解和@Component效果是一样的，有时候为了将开发者清晰，所以常常使用@Service在service层，使用Controller在web层，使用Repository在dao层</strong></p><p><strong>@Scope(scopeName="singleton")</strong></p><p><strong>这个配置在类上，表示这个类只创建一个对象</strong></p><p><strong>@Value("18")</strong></p><p><strong>private Integer age</strong></p><p><strong>这个是配置直接为属性赋值，使用了反射的方式，获取到Field然后赋值</strong></p><p>@Value("huanfeng")</p><p>public void setName(String name){</p><p>this.name=name</p><p>}</p><p>以上是基本类型，如果使用引用类型属性可以：</p><p>@Autowired</p><p>private Car car</p><p>自动装配，spring会去寻找car对象赋值给这个属性，但是当这种类型的对象很多时，将出问题</p><p>@Qualifier("car")</p><p>private Car car</p><p>自动装配，spring会去寻找名为car的car对象赋值给这个属性</p><p>@Resource(name="car")</p><p>private Car car</p><p>手动注入，指定注入name为car的对象</p><p>需要注意的是要想注入car，需要在Car类上使用@Component来注明</p><p>这个是配置使用在方法上，这个表示调用setName方法传递参数huanfeng，完成为属性name的赋值工作，这个是和上面的为age属性赋值是一样的，不同的是这里没有使用反射</p><p>@PostConstruct</p><p>public void init(){...}</p><p>使用这个注解的方法会成为初始化方法，在容器创建对象的时候就会自动调用</p><p>@PreDestroy</p><p>public void destory(){..}</p><p>使用这个注解的方法会成为销毁方法，在容器销毁这个对象之前会自动调用</p><pre><code>@Component("user")@Scope(scopeName="singleton")public class User {	@Value("huanfeng")	private String name;	@Value("11")	private Integer age;	@Resource(name="car")	private Car car;		public User(String name,Integer age,Car car) {		System.out.println("执行了构造方法");		this.name=name;		this.age=age;		this.car=car;	}	public Car getCar() {		return car;	}	public void setCar(Car car) {		this.car = car;	}	public User() {		System.out.println("ssas");	}	public String getName() {		return name;	}	public void setName(String name) {		this.name = name;	}	public Integer getAge() {		return age;	}	public void setAge(Integer age) {		this.age = age;	}	@PostConstruct	public void init() {		System.out.println("初始化");	}	@PreDestroy	public void destroy() {		System.out.println("销毁方法");	}	public String toString() {		return this.age+this.name+this.car.getName();	}	}</code></pre><h1 class=pgc-h-arrow-right>spring中安装sts插件</h1><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be15d7c3404c4bef81190169a9ca7baf><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/597a1e2a373e4383b19769a1bd021265><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf050de3e47e44459e01090b66b174ad><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb15981ba94d4800923d1f714f816a1c><p class=pgc-img-caption></p></div><p>之后会等很长的一段时间</p><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77638b86be354285baa699e554efd0c0><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/02dbb7d1f13942b5a2dfee02ea2377fa><p class=pgc-img-caption></p></div><p>我们无论是使用注解来配置还是使用配置文件来配置，那么我们都需要测试是否配置成功：</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18e2895cf54247a5bcc1b223e1eb1157><p class=pgc-img-caption></p></div><p><br></p><pre><code>import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.env.SystemEnvironmentPropertySource;import com.huanfeng.bean.Complex;import com.huanfeng.bean.User;public class Demo {	@Test	public void fun1(){		//1 创建容器对象		ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");		//2 向容器"要"user对象		User c = (User) ac.getBean("user");		//3 打印user对象		System.out.println(c);	}}</code></pre><p>这样的测试方式，每次创建一个测试方法都需要创建一个容器对象，然后获取到容器中的方法，spring对其进行了整合，使用注解的方式，方便轻松</p><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/648a17495ec44e6e98fff674cbbf84d2><p class=pgc-img-caption></p></div><p>如图所示，我们现需要三个步骤，</p><p>第一步是使用注解让spring帮助我们创建容器</p><p>第二步是执行创建容器的时候使用哪个配置文件</p><p>第三步是我们想要测试哪个类，我们就写一个属性，然后注解这个属性，那么spring就会将这个对象赋值给这个属性，之后我们就可以进行测试了。</p><pre><code>package com.huanfeng.shiyan;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.env.SystemEnvironmentPropertySource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.bean.Complex;import com.huanfeng.bean.User;//帮我们创建容器@RunWith(SpringJUnit4ClassRunner.class)//指定创建容器时使用哪个配置文件@ContextConfiguration("classpath:applicationContext.xml")public class Demo {	//将名为user的对象注入到u变量中	@Resource(name="user")	private User u;	@Test	public void fun1(){		System.out.println(u);	}}</code></pre><h1 class=pgc-h-arrow-right>aop</h1><p>aop的核心思想</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6049d0bcbb5a4d1a83bc078a6209f66a><p class=pgc-img-caption></p></div><p>我们可以使用filter来拦截请求，在filter内部使用动态代理来解决request的乱码问题，这就是aop的思想，spring可以帮助我们生成代理对象，spring有两种代理方式：</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c49c92cac298465f9296e1eb1f9cba8a><p class=pgc-img-caption></p></div><p>要是使用动态代理需要注意的是被代理对象必须要实现接口才能产生代理对象</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15a4e5dd33b646e2ad0fe1327ad1fa74><p class=pgc-img-caption></p></div><p>在被代理对象中如果没有实现接口，那么没有办法使用动态代理技术</p><p>cglib代理技术可以对任何类生成代理，代理的原理是对目标对象进行继承代理，比如我们对A类进行cglib代理，实际上生成的这个代理对象是A类的子类</p><p>spring会优先使用动态代理技术</p><p>我们先来看看手动是如何安排的，下面通过一个具体例子来说明</p><p>具体说是手动的使用动态代理技术来完成对service的增强，也就是说在service中开启事务</p><p>我们先来建立一个Service的接口：</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d7b354bd2c949c38f13503db3971c6d><p class=pgc-img-caption></p></div><p>这个service有两个方法，一个方法是增加方法，另外一个方法是删除方法，然后创建Service类从而实现这个接口：</p><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/29f8ded1fb234db9ac8a298cb0b5c74c><p class=pgc-img-caption></p></div><p><br></p><pre><code>package com.huanfeng.service;public class UserServiceImpl implements UserService {	@Override	public void add() {		//这里的工作是增加user		System.out.println("增加");	}	@Override	public void delete() {		//这里的工作是删除user		System.out.println("删除");	}}</code></pre><p>按照之前的时候方法是直接使用Serive就可以了，但是此时的Service并没有开启事务，为了解决这个问题，我们可以使用动态代理技术，来对这个Service进行增强</p><p>首先创建一个动态代理类UserServiceProxyFactory</p><pre><code>package com.huanfeng.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import com.huanfeng.service.UserService;import com.huanfeng.service.UserServiceImpl;public class UserServiceProxyFactory implements InvocationHandler{	private UserService us;	public UserServiceProxyFactory(UserService us){		super();		this.us=us;	}	public UserService getUserServiceProxy() {		UserService userServiceProxy=(UserService) Proxy.newProxyInstance(UserServiceProxyFactory.class.getClassLoader(),UserServiceImpl.class.getInterfaces(),this);		return userServiceProxy;	}	@Override	public Object invoke(Object arg0, Method method, Object[] arg2) throws Throwable {		System.out.println("开启事务");		Object invoke=method.invoke(us, arg2);		System.out.println("关闭事务");		return invoke;	}}</code></pre><p>首先这个类有一个动态代理UserService的方法，这个getUserServiceProxy方法中使用proxy.newProxyInstance方法，这个方法传递三个参数，第一个参数是一个类加载器（随便一个都行），第二个参数是需要代理类的接口，第三个是InvokeHandler接口，因为我们的这个代理类实现了InvokeHandler接口，所以我们只需要传递参数this就好了，然后因为实现了这个接口，所以需要重写其invoke方法，这个方法的主要参数第二个是增强的方法，第三个是方法的参数，所以我们可以在invoke方法进行内部调用，在调用前后进行方法的增强工作。</p><pre><code>@Test	public void fun3() {		UserService us=new UserServiceImpl();		UserServiceProxyFactory factory=new UserServiceProxyFactory(us);		UserService usProxy=factory.getUserServiceProxy();		usProxy.add();	}</code></pre><p>首先我们创建一个Service，然后创建动态代理类并将这个Service作为参数传递。调用getUserServiceProxy方法就可以获取到这个Service的代理类了，之后只要调用这个方法，其实它都会走代理类的invoke方法，所以我们可以在内部对其进行增强了。</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7a6d58adf7cd4d3ba43406c0d6ecf4c7><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7f08ee0beeb4e009144b4365f5b0f62><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9dd96c9d14394684980c9d6b7cd063a5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>spring中aop的使用</h1><p>导报：</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b983474fb62e480e9dc5aecf3424b40e><p class=pgc-img-caption></p></div><p>导入aop的约束：</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fd8556412b1349c8ba8c39e977980b5e><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9613735406524b6fae39e7e036d57573><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06a1e1aebfe3496b82b2566c27eb6177><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f62121cadfa4a46991e4b1f8ae219c0><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e10103b08bbc4d4f8b95a18daf892211><p class=pgc-img-caption></p></div><p><strong>第一创建目标对象</strong></p><pre><code>public interface UserService {	public void add();	public void delete();}</code></pre><pre><code>public class UserServiceImpl implements UserService {	@Override	public void add() {		//这里的工作是增加user		System.out.println("增加");	}	@Override	public void delete() {		//这里的工作是删除user		System.out.println("删除");	}}</code></pre><p><strong>第二:设计通知</strong></p><p><strong>设计一个类，这个类中专门存放需要代理对象的通知，通知总共分为五种：</strong></p><p>前置通知 ：目标方法运行之前调用</p><p>后置通知(如果出现异常不会调用):在目标方法运行之后调用</p><p>环绕通知:在目标方法之前和之后都调用</p><p>异常拦截通知:如果出现异常,就会调用</p><p>后置通知(无论是否出现 异常都会调用):在目标方法运行之后调用</p><pre><code>package com.huang.aop;import org.aspectj.lang.ProceedingJoinPoint;public class MyAdvice {	//前置通知		public void before(){			System.out.println("这是前置通知!!");		}		//后置通知		public void afterReturning(){			System.out.println("这是后置通知(如果出现异常不会调用)!!");		}		//环绕通知		public Object around(ProceedingJoinPoint pjp) throws Throwable {			System.out.println("这是环绕通知之前的部分!!");			Object proceed = pjp.proceed();//调用目标方法			System.out.println("这是环绕通知之后的部分!!");			return proceed;		}		//异常通知		public void afterException(){			System.out.println("出事啦!出现异常了!!");		}		//后置通知		public void after(){			System.out.println("这是后置通知(出现异常也会调用)!!");		}}</code></pre><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7257b18d4ca34246beb74caf922174cf><p class=pgc-img-caption></p></div><p><strong>第三步：织入（使用配置的方式）</strong></p><p><strong>织入分为三步：</strong></p><p><strong>1.配置目标对象</strong></p><p><strong>2.配置通知对象</strong></p><p><strong>3.配置将通知织入目标对象</strong></p><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a18d717085c47519be9d68c0f0cd5c9><p class=pgc-img-caption></p></div><p><br></p><pre><code>&lt;!-- 1.配置目标对象 --&gt;	&lt;bean name="userService" class="com.huanfeng.service.UserServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置通知对象 --&gt;    &lt;bean name="myAdvice" class="com.huanfeng.aop.MyAdvice"&gt;&lt;/bean&gt;&lt;!-- 3.配置将通知织入目标对象 --&gt;	&lt;aop:config&gt;		&lt;aop:pointcut expression="execution(* com.huanfeng.service.*ServiceImpl.*(..))" id="pc"/&gt;		&lt;aop:aspect ref="myAdvice" &gt;			&lt;!-- 指定名为before方法作为前置通知 --&gt;			&lt;aop:after method="after" pointcut-ref="pc"/&gt;			&lt;aop:before method="before" pointcut-ref="pc" /&gt;			&lt;!-- 后置 --&gt;			&lt;aop:after-returning method="afterReturning" pointcut-ref="pc" /&gt;			&lt;!-- 环绕通知 --&gt;			&lt;aop:around method="around" pointcut-ref="pc" /&gt;			&lt;!-- 异常拦截通知 --&gt;			&lt;aop:after-throwing method="afterException" pointcut-ref="pc"/&gt;			&lt;!-- 后置 --&gt;			&lt;aop:after method="after" pointcut-ref="pc"/&gt;		&lt;/aop:aspect&gt;	&lt;/aop:config&gt;</code></pre><p>这个配置分为三部分：</p><p>第一部分是配置目标对象，使用bean的方式</p><p>第二部分是配置通知对象，使用bean的方式</p><p>第三部分是织入，execution(* com.huanfeng.service.*ServiceImpl.*(..))是固定的第一个*表示返回值任意，然后Service前面的*表示Service前面的任意，然后后面的*表示这个*ServiceImpl下面的所有的方法，(..)表示方法的参数是任意的，我们给这样的切点起名为pc，然后我们就就可以使用aop:aspect来进行织入了，ref表示增强的方法类，然后在内部对pc进行织入。</p><p>此时&lt;bean name="userService" class="com.huanfeng.service.UserServiceImpl">&lt;/bean>对应的这个类就被增强了</p><p>测试：</p><pre><code>cishipackage com.huanfeng.shiyan;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.bean.User;import com.huanfeng.service.UserService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class Demo {	@Resource(name="userService")	private UserService us;		@Test	public void fun1(){		us.add();	}	}</code></pre><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c3de133ae24f476fabf364d1673c5a32><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d07decfdc61b477383b5f3ab83205427><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ad0b4e1d24c4704aef69f8e2cbdb1c5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>spring的注解配置</h1><p>首先使用注解配置需要在xml中完成三步，其中前两步和前面一样，后面的一步是开启注解aop</p><pre><code>&lt;!-- 准备工作: 导入aop(约束)命名空间 --&gt;&lt;!-- 1.配置目标对象 --&gt;	&lt;bean name="userService" class="com.huanfeng.service.UserServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置通知对象 --&gt;    &lt;bean name="myAdvice" class="com.huanfeng.annotationaop.MyAdvice"&gt;&lt;/bean&gt;&lt;!-- 开启使用注解完成织入 --&gt;	&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><p>配置好了，之后我们需要在通知对象中进行配置：</p><pre><code>package com.huanfeng.annotationaop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;//@Aspect表示这是一个通知类@Aspectpublic class MyAdvice {	    //前置通知	    @Before("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void before(){			System.out.println("这是前置通知!!");		}		//后置通知	    @AfterReturning("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void afterReturning(){			System.out.println("这是后置通知(如果出现异常不会调用)!!");		}		//环绕通知	    @Around("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public Object around(ProceedingJoinPoint pjp) throws Throwable {			System.out.println("这是环绕通知之前的部分!!");			Object proceed = pjp.proceed();//调用目标方法			System.out.println("这是环绕通知之后的部分!!");			return proceed;		}		//异常通知	    @AfterThrowing("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void afterException(){			System.out.println("出事啦!出现异常了!!");		}		//后置通知	    @After("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void after(){			System.out.println("这是后置通知(出现异常也会调用)!!");		}}</code></pre><p>我们每个通知都写一个execution太费事了，我们可以统一处理：</p><pre><code>package com.huanfeng.annotationaop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;//@Aspect表示这是一个通知类@Aspectpublic class MyAdvice {	    //前置通知		@Pointcut("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void pc(){}	    @Before("MyAdvice.pc()")		public void before(){			System.out.println("这是前置通知!!");		}		//后置通知	    @AfterReturning("MyAdvice.pc()")		public void afterReturning(){			System.out.println("这是后置通知(如果出现异常不会调用)!!");		}		//环绕通知	    @Around("MyAdvice.pc()")		public Object around(ProceedingJoinPoint pjp) throws Throwable {			System.out.println("这是环绕通知之前的部分!!");			Object proceed = pjp.proceed();//调用目标方法			System.out.println("这是环绕通知之后的部分!!");			return proceed;		}		//异常通知	    @AfterThrowing("MyAdvice.pc()")		public void afterException(){			System.out.println("出事啦!出现异常了!!");		}		//后置通知	    @After("MyAdvice.pc()")		public void after(){			System.out.println("这是后置通知(出现异常也会调用)!!");		}}</code></pre><p>之后就可以测试了：</p><pre><code>package com.huanfeng.annotationaop;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.service.UserService;import com.huanfeng.service.UserServiceImpl;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:com/huanfeng/annotationaop/applicationContext.xml")public class Demo {	@Resource(name="userService")	private UserService us;	@Test	public void test1() {		us.add();	}}</code></pre><h1 class=pgc-h-arrow-right>spring整合jdbc模板</h1><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ca066823dd6442fa12b42bc1983fdb3><p class=pgc-img-caption></p></div><p>JdbcTemplate模板的使用，这个和QueryRunner使用是差不多的，将数据库连接池连接上就可以进行数据库操作了</p><pre><code>//创建连接池		ComboPooledDataSource dataSource=new ComboPooledDataSource();		dataSource.setDriverClass("com.mysql.jdbc.Driver");		dataSource.setJdbcUrl("jdbc:mysql:///spring_data");		dataSource.setUser("root");		dataSource.setPassword("root");		//创建JDBC模板对象		JdbcTemplate jt=new JdbcTemplate();		jt.setDataSource(dataSource);		String sql="DELETE FROM shiyan WHERE number='3'";		int i=jt.update(sql);		System.out.println(i);</code></pre><p>上面仅仅介绍了如何使用jabcTemplate来完成数据库的连接工作，对于数据库的操作而言，需要进行增删改查的操作，那么如何使用jdbc进行增删改查呢</p><pre><code>package com.huanfeng.dao;import java.util.List;import com.huanfeng.dao.User;public interface UserDao {	//增加	void add(User u);	//删除	void delete(Integer id);	//修改	void update(User u);	//查询指定id的uesr	User getById(Integer id);	//查询user总人数	int getTotalCount();	//查询所有user信息	List&lt;User&gt; getAll();}</code></pre><p>如下所示涵盖了使用jt处理常见数据库的增删改查操作的常用方法，其中除了查询之外都使用update方法，第一个参数是sql语句，第二个参数是sql语句的？对应的值。</p><p>查询使用query（获取list）和queryObject（获取一个对象或者单个值）都可以使用这种方法，第一个参数是sql，第三个参数是sql中的？（可有可无，这是可变长的参数），第二个是一个RowMapper这个类似于dbutils中的ListHandler,但是这个比较麻烦，需要我们手动的对其进行封装处理，然后里面的参数ResultSet表示查询出来的每一行结果，我们只需要将其封装成一个user对象就好了，然后它会自动的一次又一次地封装。</p><p>还有如果查询出来的结果是一个值，比如查询count(*)，那么我们可以使用queryObject，此时的第二个参数就不是RowMapper了，而是这个值对应的类型</p><pre><code>package com.huanfeng.dao;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import com.huanfeng.dao.User;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;public class UserDaoImpl implements UserDao {	private JdbcTemplate jt;	public void setjt(JdbcTemplate jt) {		this.jt=jt;	}	@Override	//这是增加方法	public void add(User u) {		String sql="insert into user values(?,?,null)";		jt.update(sql,u.getName(),u.getAge());	}    //这是删除方法	@Override	public void delete(Integer id) {		String sql="delete from user where id=?";		jt.update(sql,id);	}	@Override	//这是修改方法	public void update(User u) {		String sql="update user set name=? ,age=? where id=?";		jt.update(sql,u.getName(),u.getAge(),u.getId());	}	@Override	//这是获取指定id的用户	public User getById(Integer id) {		String sql="select * from user where id=?";		User u=jt.queryForObject(sql, new RowMapper&lt;User&gt;() {			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setName(rs.getString("name"));				u.setId(rs.getInt("id"));				return u;			}}, id);		return u;	}	@Override	//获取用户的数量	public int getTotalCount() {		String sql="select count(*) from user";		Integer c=jt.queryForObject(sql,Integer.class);		return c;	}	@Override	//获取所有的用户	public List&lt;User&gt; getAll() {		String sql="select * from user";		List&lt;User&gt; userList=jt.query(sql, new RowMapper&lt;User&gt;(){			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setId(rs.getInt("id"));				u.setName(rs.getString("name"));				return u;			}});		return userList;	}}</code></pre><p>将jdbc整合进spring中，并进行测试：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt;&lt;!-- 1、配置数据库连接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="jdbc:mysql:///spring_data"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="com.mysql.jbdc.Driver"&gt;&lt;/property&gt;	&lt;property name="user" value="root"&gt;&lt;/property&gt;	&lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2、配置模板JDBC --&gt;&lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl"&gt;	&lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>如上所示要想使用配置JDBC首先需要使用数据库连接池，然后将jdbc模板配置到userDao中，此时就可以在测试集中直接使用userDao来进行操作了：</p><pre><code>package com.huanfeng.dao;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.core.env.SystemEnvironmentPropertySource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:com/huanfeng/dao/applicationContext.xml")public class Demo {	@Resource(name="userDao")	private UserDao ud;	@Test	public void test1() {		User u=new User();		u.setAge(100);		u.setName("xia");		u.setId(3);		ud.add(u);	}	@Test	public void test2() {		ud.delete(1);	}	@Test	public void test3() {		User u=new User();		u.setAge(100);		u.setName("xiaoo");		u.setId(3);		ud.update(u);	}	@Test	public void test4() {		User u=ud.getById(2);		System.out.println(u);	}	@Test	public void test5() {		int c=ud.getTotalCount();		System.out.println(c);	}	@Test	public void test6() {		List&lt;User&gt; l=ud.getAll();		System.out.println(l);	}}</code></pre><p>jdbc的扩展，在之前我们使用了JdbcTemplate的时候使用了UserDaoImpl进行了参数传递，是否可以不进行这样地操作了？可以具体来说首先UserDaoImpl中使用，我们需要继承：</p><p>JdbcDaoSupport</p><p>这样就可以通过super.getJdbcTemplate()获取jdbc模板对象了。</p><p>那么在xml中就不用配置模板对象了，但是需要将数据库连接池配置到UserServiceDao中：</p><pre><code>package com.huanfeng.dao;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import com.huanfeng.dao.User;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;public class UserDaoImpl2 extends JdbcDaoSupport implements UserDao {	@Override	//这是增加方法	public void add(User u) {		String sql="insert into user values(?,?,null)";		super.getJdbcTemplate().update(sql,u.getName(),u.getAge());	}    //这是删除方法	@Override	public void delete(Integer id) {		String sql="delete from user where id=?";		super.getJdbcTemplate().update(sql,id);	}	@Override	//这是修改方法	public void update(User u) {		String sql="update user set name=?, age=? where id=?";		super.getJdbcTemplate().update(sql,u.getName(),u.getAge(),u.getId());	}	@Override	//这是获取指定id的用户	public User getById(Integer id) {		String sql="select * from user where id=?";		User u=super.getJdbcTemplate().queryForObject(sql, new RowMapper&lt;User&gt;() {			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setName(rs.getString("name"));				u.setId(rs.getInt("id"));				return u;			}}, id);		return u;	}	@Override	//获取用户的数量	public int getTotalCount() {		String sql="select count(*) from user";		Integer c=super.getJdbcTemplate().queryForObject(sql,Integer.class);		return c;	}	@Override	//获取所有的用户	public List&lt;User&gt; getAll() {		String sql="select * from user";		List&lt;User&gt; userList=super.getJdbcTemplate().query(sql, new RowMapper&lt;User&gt;(){			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setId(rs.getInt("id"));				u.setName(rs.getString("name"));				return u;			}});		return userList;	}}</code></pre><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt;&lt;!-- 1、配置数据库连接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="jdbc:mysql:///spring_data"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="com.mysql.jbdc.Driver"&gt;&lt;/property&gt;	&lt;property name="user" value="root"&gt;&lt;/property&gt;	&lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl2"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>将数据库连接池的配置到配置文件中：</p><pre><code>jdbc.jdbcUrl=jdbc:mysql:///spring_datajdbc.driverClass=com.mysql.jdbc.Driverjdbc.user=rootjdbc.password=root</code></pre><p>之后在xml中就可以这样进行配置了</p><pre><code>&lt;context:property-placeholder location="classpath:db.properties"  /&gt;&lt;!-- 1、配置数据库连接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>事务</h1><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/def44838ec284d2aa703a724d3b892dd><p class=pgc-img-caption></p></div><p><strong>事务的传播行为：</strong></p><blockquote class=pgc-blockquote-abstract><p>PROPAGION_XXX :事务的传播行为 * 保证同一个事务中 PROPAGATION_REQUIRED 支持当前事务，如果不存在 就新建一个(默认) PROPAGATION_SUPPORTS 支持当前事务，如果不存在，就不使用事务 PROPAGATION_MANDATORY 支持当前事务，如果不存在，抛出异常</p><p><br></p><p>* 保证没有在同一个事务中 PROPAGATION_REQUIRES_NEW 如果有事务存在，挂起当前事务，创建一个新的事务 PROPAGATION_NOT_SUPPORTED 以非事务方式运行，如果有事务存在，挂起当前事务</p><p><br></p><p>PROPAGATION_NEVER 以非事务方式运行，如果有事务存在，抛出异常</p><p><br></p><p>PROPAGATION_NESTED 如果当前事务存在，则嵌套事务执行</p></blockquote><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/66cfafbc03144d848bc806c01940f174><p class=pgc-img-caption></p></div><p>事务，转账</p><p>首先在xml中配置好数据库连接池，事务，以及service和dao：</p><pre><code>&lt;!-- 事务核心管理器，封装了所有事务操作 --&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt;	&lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务模板对象 --&gt;&lt;bean name="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt;	&lt;property name="transactionManager" ref="transactionManager" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 1、配置数据库连接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="AccountDao" class="com.huanfeng.dao.AccountDaoImpl"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;                           &lt;bean name="AccountService" class="com.huanfeng.service.AccountServiceImpl"&gt;	&lt;property name="ad" ref="AccountDao"&gt;&lt;/property&gt;	&lt;property name="tt" ref="transactionTemplate" &gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>首先配置事务的核心管理器，里面需要依赖数据库连接池，然后配置事务模板对象，这个依赖事务的核心管理器。</p><p>之后配置service和dao，dao中由于使用了继承JdbcDaoSupport，所以这里需要依赖数据库连接池，然后Service不仅依赖dao，而且还依赖事务模板对象。</p><pre><code>package com.huanfeng.dao;public interface AccountDao {	void increaseMoney(Integer id,Double money);	void decreaseMoney(Integer id,Double money);}</code></pre><pre><code>package com.huanfeng.dao;import org.springframework.jdbc.core.support.JdbcDaoSupport;public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {	@Override	public void increaseMoney(Integer id, Double money) {		String sql="update table_count set money=money+? where id=?";		super.getJdbcTemplate().update(sql,money,id);	}	@Override	public void decreaseMoney(Integer id, Double money) {		String sql="update table_count set money=money-? where id=?";		super.getJdbcTemplate().update(sql,money,id);	}}</code></pre><pre><code>package com.huanfeng.service;public interface AccountService {	public void transfer(Integer from,Integer to,Double money);}</code></pre><pre><code>package com.huanfeng.service;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;import com.huanfeng.dao.AccountDao;public class AccountServiceImpl implements AccountService {	private AccountDao ad;	private TransactionTemplate tt;	public TransactionTemplate getTt() {		return tt;	}	public void setTt(TransactionTemplate tt) {		this.tt = tt;	}	public AccountDao getAd() {		return ad;	}	public void setAd(AccountDao ad) {		this.ad = ad;	}	@Override	public void transfer(Integer from, Integer to, Double money) {				tt.execute(new TransactionCallbackWithoutResult() {			@Override			protected void doInTransactionWithoutResult(TransactionStatus arg0) {				//减钱				ad.decreaseMoney(from, money);				//加钱				ad.increaseMoney(to, money);			}		});	}}</code></pre><p>AccountServiceImpl中需要TransactionTemplate事务模板对象，以便于开启事务，之后可以测试了：</p><pre><code>package com.huanfeng.transaction;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.service.AccountService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:com/huanfeng/dao/applicationContext3.xml")public class Demo1 {	@Resource(name="AccountService")	private AccountService as;	@Test	public void test1() {		as.transfer(1, 2, 500d);	}}</code></pre><h1 class=pgc-h-arrow-right>aop配置事务</h1><p>首先配置约束</p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37ff33c55009412c852b351d1e7d3ed8><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72b21a1a1883496ebc4ed65d578a60e1><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b4ac682a46a4a669f21abb5c2748bd5><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入门学习：AOP和面向切面的事务 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/104e2d77dbd54ba2978ff1021c27da32><p class=pgc-img-caption></p></div><p>事务本身就需要开启事务以及关闭事务，所以可以使用面向切面的思想来对service中的方法进行增强，spring已经写好了通知，所以不需要我们写通知了，我们可以通过tx:advice来配置事务通知，然后将这个通知织入到service方法中，那么此时的service都是被事务增强的方法，之后就不需要手动增加事务了。配置如下：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd "&gt;&lt;context:property-placeholder location="classpath:db.properties"  /&gt;&lt;!-- 事务核心管理器，封装了所有事务操作 --&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt;	&lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务模板对象 --&gt;&lt;bean name="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt;	&lt;property name="transactionManager" ref="transactionManager" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager" &gt;	&lt;tx:attributes&gt;		&lt;!-- 以方法为单位,指定方法应用什么事务属性			isolation:隔离级别			propagation:传播行为			read-only:是否只读		 --&gt;		&lt;tx:method name="save*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="persist*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="update*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="modify*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="delete*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="remove*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="get*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt;		&lt;tx:method name="find*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt;		&lt;tx:method name="transfer" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;	&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置织入 --&gt;&lt;aop:config  &gt;	&lt;!-- 配置切点表达式 --&gt;	&lt;aop:pointcut expression="execution(* com.huanfeng.service.*ServiceImpl.*(..))" id="txPc"/&gt;	&lt;!-- 配置切面 : 通知+切点		 	advice-ref:通知的名称		 	pointcut-ref:切点的名称	 --&gt;	&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc" /&gt;&lt;/aop:config&gt;&lt;!-- 1、配置数据库连接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl2"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="AccountDao" class="com.huanfeng.dao.AccountDaoImpl"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;                           &lt;bean name="AccountService" class="com.huanfeng.service.AccountServiceImpl"&gt;	&lt;property name="ad" ref="AccountDao"&gt;&lt;/property&gt;	&lt;property name="tt" ref="transactionTemplate" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>之后再servie中直接调用dao中的方法就可以了：</p><pre><code>public void transfer(Integer from, Integer to, Double money) {				//减钱				ad.decreaseMoney(from, money);				//加钱				ad.increaseMoney(to, money);	}</code></pre><p>下面学习一下注解的配置方式</p><p>我们可以将前面的通知和织入全部删掉，使用&lt;tx:annotation-driven/>，此时的xml配置为：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd "&gt;&lt;context:property-placeholder location="classpath:db.properties"  /&gt;&lt;!-- 事务核心管理器，封装了所有事务操作 --&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt;	&lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事务模板对象 --&gt;&lt;bean name="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt;	&lt;property name="transactionManager" ref="transactionManager" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven/&gt;&lt;!-- 1、配置数据库连接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl2"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="AccountDao" class="com.huanfeng.dao.AccountDaoImpl"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;                           &lt;bean name="AccountService" class="com.huanfeng.service.AccountServiceImpl"&gt;	&lt;property name="ad" ref="AccountDao"&gt;&lt;/property&gt;	&lt;property name="tt" ref="transactionTemplate" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然后使用的时候可以直接在service中进行配置：</p><pre><code>@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)public void transfer(Integer from, Integer to, Double money) {				ad.decreaseMoney(from, money);				ad.increaseMoney(to, money);	}</code></pre><p>我们可以使用@Transational来直接在方法同配置通知，此时表示这个方法被事务通知增强了，当然如果每个方法都这样配置感觉麻烦，我们还可以直接配置在类上，这样表示这个类的所有方法都被增强了，但是第一优先级应该还是方法。</p><pre><code>@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=true)public class AccountServiceImpl implements AccountService {	private AccountDao ad ;	private TransactionTemplate tt;		@Override	@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)	public void transfer(final Integer from,final Integer to,final Double money) {				//减钱				ad.decreaseMoney(from, money);				int i = 1/0;				//加钱				ad.increaseMoney(to, money);	}}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'spring','入门','学习'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>