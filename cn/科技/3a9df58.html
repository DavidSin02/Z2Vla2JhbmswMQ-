<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>这就是所谓的JavaScript 异步！ | 极客快訊</title><meta property="og:title" content="这就是所谓的JavaScript 异步！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1537623322768a8d1eeb09f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a9df58.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a9df58.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="这就是所谓的JavaScript 异步！"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3a9df58.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>这就是所谓的JavaScript 异步！</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><strong>ECMAScript 6（简称ES6）将 JavaScript 异步编程带入了一个全新的阶段。这篇文章的主题，就是介绍更强大、更完善的 ES6 异步编程方法。</strong></blockquote><p class=ql-align-justify>首先我们回顾一下javascript异步的发展历程。</p><p class=ql-align-justify><strong>ES6 以前：</strong></p><p class=ql-align-justify>回调函数（callback）：nodejs express 中常用，ajax中常用。</p><p class=ql-align-justify><strong>ES6：</strong></p><p class=ql-align-justify>promise对象：nodejs最早有bluebird promise的雏形，axios中常用。</p><p class=ql-align-justify>generator函数：nodejs koa框架使用率很高。</p><p class=ql-align-justify><strong>ES7:</strong></p><p class=ql-align-justify>async/await语法：当前最常用的异步语法，nodejs koa2 完全使用该语法。</p><p class=ql-align-justify><br></p><h1 class=ql-align-justify>什么是异步</h1><p class=ql-align-justify>所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。比如，有一个任务是读取文件进行处理，异步的执行过程就是下面这样。</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1537623322768a8d1eeb09f><p class=pgc-img-caption>异步</p></div><p>上图中，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。</p><p class=ql-align-justify><strong>这种不连续的执行，就叫做异步。</strong>相应地，连续的执行，就叫做同步。</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15376233481046bab63cbb2><p class=pgc-img-caption>同步</p></div><p class=ql-align-justify>上图就是同步的执行方式。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p><h1>回调函数callback</h1><p>JavaScript 语言对异步编程的实现，就是回调函数。<strong>所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。</strong>它的英语名字 callback，直译过来就是"重新调用"。</p><p>回调字面也好理解，就是先处理本体函数，再处理回调的函数，举个例子，方便大家理解。</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1537622997912cab5bb0b54><p class=pgc-img-caption></p></div><p>上面的例子很好理解，首先执行主体函数A，打印结果：我是主题函数；</p><p>然后执行回调函数callback 也就是B，打印结果：我是回调函数。</p><h1>promise对象</h1><p>promise 对象用于一个异步操作的最终完成（或最终失败）及其结果的表示。</p><p>简单地说就是处理一个异步请求。我们经常会做些断言，如果我赢了你就嫁给我，如果输了我就嫁给你之类的断言。</p><p>这就是promise的中文含义：断言，一个成功，一个失败。</p><p>举个例子，方便大家理解：</p><p>promise构造函数的参数是一个函数，我们把它称为处理器函数。</p><p>处理器函数接收两个函数reslove和reject作为其参数，当异步操作顺利执行则执行reslove函数, 当异步操作中发生异常时，则执行reject函数。</p><p>通过resolve传入得的值，可以在then方法中获取到，通过reject传入的值可以在chatch方法中获取到。</p><p>因为then和catch都返回一个相同的promise对象，所以可以进行链式调用。</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153762315501373570fd644><p class=pgc-img-caption></p></div><p>Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p><p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p><p>那么，有没有更好的写法呢？</p><h1>协程</h1><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做"协程"（coroutine），意思是多个线程互相协作，完成异步任务。</p><p>协程有点像函数，又有点像线程。它的运行流程大致如下。</p><p>第一步，协程A开始执行。</p><p>第二步，协程A执行到一半，进入暂停，执行权转移到协程B。</p><p>第三步，（一段时间后）协程B交还执行权。</p><blockquote><p>第四步，协程A恢复执行。</p></blockquote><p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p><p>举例来说，读取文件的协程写法如下。</p><pre>function asnycJob() { // ...其他代码 var f = yield readFile(fileA); // ...其他代码}</pre><p>上面代码的函数 asyncJob 是一个协程，它的奥妙就在其中的 yield 命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p><p>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p><h1>Generator 函数</h1><p>Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p><pre>function* gen(x){ var y = yield x + 2; return y;}</pre><p>上面代码就是一个 Generator 函数。它不同于普通函数，是可以暂停执行的，所以函数名之前要加星号，以示区别。</p><p>整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。Generator 函数的执行方法如下。</p><pre>var g = gen(1);g.next() // { value: 3, done: false }g.next() // { value: undefined, done: true }</pre><p>上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。</p><p>换言之，next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。</p><h1>Generator 函数的用法</h1><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p><pre>var fetch = require('node-fetch');function* gen(){ var url = 'https://api.github.com/users/github'; var result = yield fetch(url); console.log(result.bio);}</pre><p>上面代码中，Generator 函数封装了一个异步操作，该操作先读取一个远程接口，然后从 JSON 格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了 yield 命令。</p><p>执行这段代码的方法如下。</p><pre>var g = gen();var result = g.next();result.value.then(function(data){ return data.json();}).then(function(data){ g.next(data);});</pre><p>上面代码中，首先执行 Generator 函数，获取遍历器对象，然后使用 next 方法（第二行），执行异步任务的第一阶段。由于 Fetch 模块返回的是一个 Promise 对象，因此要用 then 方法调用下一个next 方法。</p><p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p><h1><strong>async-await</strong></h1><p>async函数返回一个promise对象，如果在async函数中返回一个直接量，async会通过Promise.resolve封装成Promise对象。</p><p>我们可以通过调用promise对象的then方法，获取这个直接量。</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1537624051921dca81c57a8><p class=pgc-img-caption></p></div><p>那如过async函数不返回值，又会是怎么样呢？</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15376241919618e621073fd><p class=pgc-img-caption></p></div><p class=ql-align-justify>await会暂停当前async的执行，await会阻塞代码的执行，直到await后的表达式处理完成，代码才能继续往下执行。</p><p class=ql-align-justify>await后的表达式既可以是一个Promise对象，也可以是任何要等待的值。</p><p class=ql-align-justify>如果await等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</p><p class=ql-align-justify>上边你看到阻塞一词，不要惊慌，async/await只是一种语法糖，代码执行与多个callback嵌套调用没有区别。</p><p class=ql-align-justify>本质并不是同步代码，它只是让你思考代码逻辑的时候能够以同步的思维去思考，避开回调地狱。</p><p class=ql-align-justify>简而言之-async/await是以同步的思维去写异步的代码，所以async/await并不会影响node的并发数，大家可以大胆的应用到项目中去！</p><p class=ql-align-justify>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</p><p class=ql-align-justify>举个例子，方便大家理解：</p><div class=pgc-img><img alt="这就是所谓的JavaScript 异步！" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15376242467356d402bdecb><p class=pgc-img-caption></p></div><blockquote><p><strong>编程是一种修行，我愿与志同道合的朋友携手前行，一起探索有关编程的奥妙！</strong></p><p><strong>如果您在前端学习的过程中遇到难题，欢迎【关注】并【私信】我，大家一起交流解决！</strong></p></blockquote><p>推荐文章：</p><p><a class=pgc-link href="https://www.toutiao.com/i6603276505915064840/?group_id=6603276505915064840" target=_blank>不一样的JS函数总结，适合前端初学者的JavaScript函数代码</a></p><p><a class=pgc-link href="https://www.toutiao.com/i6603645385401434632/?group_id=6603645385401434632" target=_blank>原来这就是JS箭头函数！适合新手入门的前端JavaScript代码（上）</a></p><p><a class=pgc-link href="https://www.toutiao.com/i6602521406372577805/?group_id=6602521406372577805" target=_blank>JS函数声明和函数表达式的定义及其区别——超详讲解，值得拥有</a></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'所谓','JavaScript','异步'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>