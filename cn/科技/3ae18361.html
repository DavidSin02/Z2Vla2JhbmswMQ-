<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 | 极客快訊</title><meta property="og:title" content="基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/15285901190965dfa7b64c2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3ae18361.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ae18361.html><meta property="article:published_time" content="2020-11-14T21:04:03+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:03+08:00"><meta name=Keywords content><meta name=description content="基于红外通信的单片机综合编程控制技术实现遥控密码锁功能"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3ae18361.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基于红外通信的单片机综合编程控制技术实现遥控密码锁功能</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>一、设计的目的及意义</strong></p><p><strong>1.1、设计的现状及背景</strong></p><p>在日常的生活和工作中, 住宅与部门的安全防范、单位的文件档案、财务报表以及一些个人资料的保存多以加锁的办法来解决。若使用传统的机械式钥匙开锁，人们常需携带多把钥匙, 使用极不方便, 且钥匙丢失后安全性即大打折扣。随着科学技术的不断发展，人们对日常生活中的安全保险器件的要求越来越高。为满足人们对锁的使用要求，增加其安全性，用密码代替钥匙的密码锁应运而生。密码锁具有安全性高、成本低、功耗低、易操作等优点。</p><p>在安全技术防范领域，具有防盗报警功能的电子密码锁逐渐代替传统的机械式密码锁，克服了机械式密码锁密码量少、安全性能差的缺点，使密码锁无论在技术上还是在性能上都大大提高一步。随着大规模集成电路技术的发展，特别是单片机的问世，出现了带微处理器的智能密码锁，它除具有电子密码锁的功能外，还引入了智能化管理、专家分析系统等功能，从而使密码锁具有很高的安全性、可靠性，应用日益广泛。</p><p>随着人们对安全的重视和科技的发展，许多电子智能锁（指纹识别、IC卡辨认）已在国内外相继面世。但是这些产品的特点是针对特定的指纹和有效卡，只能适用于保密要求的箱、柜、门等。而且指纹识识别器若在公共场所使用存在容易机械损坏，IC卡还存在容易丢失、损坏等特点。加上其成本较高，一定程度上限制了这类产品的普及和推广。鉴于目前的技术水平与市场的接收程度，电子密码锁是这类电子防盗产品的主流。红外遥控是单工的红外通信方式，本设计的红外遥控采用以通信方式为基础的红外遥控，而且本设计也使用了红外通信技术，故着重分析红外通信的基本原理。</p><p>红外通信是利用红外技术实现两点间的近距离保密通信和信息转发。它一般由红外发射和接收系统两部分组成。发射系统对一个红外辐射源进行调制后发射红外信号，而接收系统用光学装置和红外探测器进行接收，就构成红外通信系统。但是接触式密码锁系统都相应的存在着不同的缺点。例如：接触式密码锁系统成本较低，体积小，卡片本身无须电源，但使用不太方便，而且有接触磨损。相比之下，红外遥控密码锁系统的成本与接触式密码锁系统相当，而且可以进行近距离遥控，使用十分方便。而且它已经与 PC 机的数据库相结合，可以组成一套酒店房间的门禁管理系统。 由于红外遥控具有许多优点， 例如红外线发射装置采用红外发光二极管遥控发射器易于小型化且价格低廉； 采用数字信号编码和二次调制方式，不仅可以实现多路信息的控制，增加遥控功能，提高信号传输的抗干扰性，减少误动作，而且功率消耗低；红外线不会向室外泄露，不会产生信号串扰；反应速度快、传输效率高、工作稳定可靠等。工业设备中，在高压、辐射、有毒气体、粉尘等环境下，采用红外线遥控不仅完全可靠而且能有效地隔离电气干扰。所以红外线遥控是目前使用最广泛的一种通信和遥控手段。</p><p><strong>1.2、设计的目的</strong></p><p>在科技高速发展的今天，非接触式控制越来越受大家欢迎，利用红外遥控，方便又安全。另外，红外线不会产生信号干扰，反应速度迅速、工作稳定度高等特点。而在工业制造中，在高压、辐射、腐蚀等恶劣环境下，采用红外遥控能够很好地隔离这些干扰。在本次设计中，为了更加方便操作，除了采用矩阵键盘对密码锁进行控制外，还可以用遥控器进行控制，以达到双控的目的。可以加深自己对所学专业的认识，关联知识，增强自己的动手能力，积累实践经验，为以后的工作打好基础。</p><p><strong>1.3、设计的意义</strong></p><p>随着科技的发展，人们生活的节奏也越来越快，随之人们对方便，快捷的要求也随之不断增高。遥控器的出现，在一定程度上满足了人们这个要求。遥控器是由高产的发明家Robert Adler在五十年代发明的[1]。而红外遥控是20世纪70年代才开始发展起来的一种远程控制技术，其原理是利用红外线来传递控制信号，实现对控制对象的远距离控制，具体来讲，就是有发射器发出红外线指令信号，有接收器接收下来并对信号进行处理，最后实现对控制对象的各种功能的远程控制。</p><p>红外遥控具有独立性、物理特性与可见光相似性、无穿透障碍物的能力及较强的隐蔽性等特点。随着红外遥控技术的开发和迅速发展，很多电器都应用了红外遥控，在日常的生活和工作中, 住宅与部门的安全防范、单位的文件档案、财务报表以及一些个人资料的保存多以加锁的办法来解决。若使用传统的机械式钥匙开锁，人们常需携带多把钥匙, 使用极不方便, 且钥匙丢失后安全性即大打折扣。随着科学技术的不断发展，人们对日常生活中的安全保险器件的要求越来越高。为满足人们对锁的使用要求，增加其安全性，用密码代替钥匙的密码锁应运而生。密码锁具有安全性高、成本低、功耗低、易操作等优点。 在安全技术防范领域，具有防盗报警功能的电子密码锁逐渐代替传统的机械式密码锁，克服了机械式密码锁密码量少、安全性能差的缺点，使密码锁无论在技术上还是在性能上都大大提高一步。随着大规模集成电路技术的发展，特别是单片机的问世，出现了带微处理器的智能密码锁，它除具有电子密码锁的功能外，还引入了智能化管理、专家分析系统等功能，从而使密码锁具有很高的安全性、可靠性，应用日益广泛。</p><p><strong>二、主要器件介绍</strong></p><p>系统主要有STC89C52RC单片机最小系统和LCD1602液晶显示、数据存储芯片24C02、红外发射接收模块等组成。</p><p><strong>2.1、主控器件</strong></p><p>本设计是STC89C52RC单片机为控制核心，矩阵键盘输入，红外遥控输入基于红外通信的单片机控制技术综合实现所有功能。系统框图如下图：</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15285901190965dfa7b64c2><p class=pgc-img-caption></p></div><p>单片机是STC公司最新推出的一种新型51内核的单片机。片内含有Flash程序存储器、SRAM、UART、SPI、PWM等模块。封装图如下图：</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590183690cd9950be22><p class=pgc-img-caption></p></div><p><strong>2.1.1、主要特性</strong></p><p>1. 增强型8051单片机，6时钟/机器周期和12时钟/机器周期可以任 意 选择，指令代码完全兼容传统8051.</p><p>2. 工作电压：5.5V～3.3V（5V单片机）/3.8V～2.0V（3V单片机）</p><p>3. 工作频率范围：0～40MHz，相当于普通8051的0～80MHz，实际工作频 率可达48MHz</p><p>4. 用户应用程序空间为8K字节 5. 片上集成512字节RAM</p><p>6. 通用I/O口（32个），复位后为：P1/P2/P3/P4是准双向口/弱上拉，</p><p>P0口是漏极开路输出，作为总线扩展用时，不用加上拉电阻，作为I/O 口 用时，需加上拉电阻。</p><p>7. ISP（在系统可编程）/IAP（在应用可编程），无需专用编程器，无需专 用仿真器，可通过串口（RxD/P3.0,TxD/P3.1）直接下载用户程序， 数秒即 可完成一片</p><p>8. 具有EEPROM功能</p><p>9. 具有看门狗功能</p><p>10. 共3个16位定时器/计数器。即定时器T0、T1、T2</p><p>11. 外部中断4路，下降沿中断或低电平触发电路，Power Down模式 可由外部中断低电平触发中断方式唤醒</p><p>12. 通用异步串行口（UART），还可用定时器软件实现多个UART</p><p>13. 工作温度范围：-40～+85℃（工业级）/0～75℃（商业级）</p><p><strong>2.1.2、引脚功能</strong></p><p>VCC（40引脚）：电源电压</p><p>VSS（20引脚）：接地</p><p>P0端口（P0.0～P0.7，39～32引脚）：P0口是一个漏极开路的8位双向I/O口。作为输出端口，每个引脚能驱动8个TTL负载，对端口P0写入“1”时，可以作为高阻抗输入。在访问外部程序和数据存储器时，P0口也可以提供低8位地址和8位数据的复用总线。此时，P0口内部上拉电阻有效。在Flash ROM编程时，P0端口接收指令字节；而在校验程序时，则输出指令字节。验证时要求外接上拉电阻。</p><p>P1端口（P1.0～P1.7，1～8引脚）：P1口是一个带内部上拉电阻的8位双向I/O口。P1的输出缓冲器可驱动（吸收或者输出电流方式）4个TTL输入。对端口写入1时，通过内部的上拉电阻把端口拉到高电位，这是可用作输入口。P1口作输入口使用时，因为有内部上拉电阻，那些被外部拉低的引脚会输出一个电流。</p><p>P2端口（P2.0～P2.7，21～28引脚）：P2口是一个带内部上拉电阻的8位双向I/O端口。P2的输出缓冲器可以驱动（吸收或输出电流方式）4个TTL输入。对端口写入1时，通过内部的上拉电阻把端口拉到高电平，这时可用作输入口。P2作为输入口使用时，因为有内部的上拉电阻，那些被外部信号拉低的引脚会输出一个电流</p><p>P3口引脚复用功能 引脚号 复用功能</p><p>P3.0 RXD（串行输入口）</p><p>P3.1 TXD（串行输出口）</p><p>P3.2 （外部中断0）</p><p>P3.3 （外部中断1）</p><p>P3.4 T0（定时器0的外部输入）</p><p>P3.5 T1（定时器1的外部输入）</p><p>P3.6 （外部数据存储器写选通）</p><p>P3.7 （外部数据存储器读选通）</p><p>RST（9引脚）：复位输入。当输入连续两个机器周期以上高电平时为有效，用来完成单片机单片机的复位初始化操作。看门狗计时完成后，RST引脚输出96个晶振周期的高电平。特殊寄存器AUXR（地址8EH）上的DISRTO位可以使此功能无效。DISRTO默认状态下，复位高电平有效。</p><p>ALE/（30引脚）：地址锁存控制信号（ALE）是访问外部程序存储器时，锁存低8位地址的输出脉冲。在Flash编程时，此引脚（）也用作编程输入脉冲。 在一般情况下，ALE以晶振六分之一的固定频率输出脉冲，可用来作为外部定时器或时钟使用。然而，特别强调，在每次访问外部数据存储器时，ALE脉冲将会跳过。如果需要，通过将地址位8EH的SFR的第0位置“1”，ALE操作将无效。这一位置“1”，ALE仅在执行MOVX或MOV指令时有效。否则，ALE将被微弱拉高。这个ALE使能标志位（地址位8EH的SFR的第0位）的设置对微控制器处于外部执行模式下无效。</p><p>VPP（31引脚）：访问外部程序存储器控制信号。为使能从0000H到FFFFH的外部程序存储器读取指令，必须接GND。注意加密方式1时，将内部锁定位RESET。为了执行内部程序指令，应该接VCC。在Flash编程期间，也接收12伏VPP电压。</p><p>XTAL1（19引脚）：振荡器反相放大器和内部时钟发生电路的输入端。</p><p>XTAL2（18引脚）：振荡器反相放大器的输入端。</p><p><strong>2.1.3、串口通信</strong></p><p>一条信息的各位数据被逐位顺序传送的通信方式成为串行通信。根据信息的传送方向，串行通信可以可以进一步划分为单工、半双工和全双工 3 种。信息只能单方向传送为单工；信息能双向传送但不能同时双向传送为半双工；信息能够同时双向传送则成为全双工。 8051 系列单片机有一个全双工串行口， 全双工的串行通信只需要一根输出线和输入线。</p><p>串行通信又有异步通信和同步通信这两种方式。异步通信用起始位“0”表示字符的开始，然后从低位到高位逐位传送数据，最后用停止位“1”表示字符结束。一个字符又称作一帧信息，一帧信息包括 1 位起始位、8 位数据位、1 位停止位，若数据位增加到第 9 位， 在 8051 系列单片机中， 第九位数据可以用作奇偶校验位， 也可以用作地址/数据帧标志。</p><p>8051 系列单片机串行 I/O 接口的工作原理就是： 当要发送数据时， 单片机自动将 SBUF 内的 8 位并行数据转换为一定格式的串行数据， 从 TXD 引脚按规定的波特率来输出； 当要接收数据时， 要监视 RXD 引脚，一旦出现起始位“0” ，按规定的波特率将外围设备送来的一定格式的串行数据转换成 8 位并行数据，等待用户读取 SBUF 寄存器，若不及时读取，SBUF 中的数据有可能被刷新。8051 系列单片机上有通用异步接收/发送器用于串行通信，发送时数据由 TXD 引脚输出，接收时数据从 RXD 引脚输入。有两个缓冲器（Serial Buffer） ，一个作发送缓冲器，另外一个作为接收缓冲器。UART 是可编程的全双工的串行口。</p><p>SBUF是可以直接寻址的专用寄存器。物理上，它对应着两个寄存器，即一个发送寄存器一个接收寄存器，CPU写SBUF就是修改发送寄存器；读SBUF就是读接收寄存器。接收器是双缓冲的，以避免在接收下一帧数据之前，CPU未能及时的响应接收器的中断，没有把上一帧的数据读走而产生两帧数据重叠的问题。对于发送器，为了保持最大的传输速率，一般不需要双缓冲，因为发送时CPU是主动的，不会产生重叠问题。</p><p>SCON是一个逐位定义的8位寄存器，用于控制串行通信的方式选择、接收和发送，指示串口的状态，SCON即可以字节寻址也可以位寻址，字节地址98H，地址位为98H~9FH。它的各个位定义如下：</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1528590308546abd0767045><p class=pgc-img-caption></p></div><p>SM2在工作方式2和3中是多机通信的使能位。在工作方式0中，SM2必须为0。在工作方式1中，若SM2=1且没有接收到有效的停止位，则接收中断标志位RI不会被激活。在工作方式2和3中若SM2=1且接收到的第9位数据（RB8）为0，则接收中断标志RB8不会被激活，若接收到的第9位数据（RB8）为1，则RI置位。此功能可用于多处理机通信。</p><p>REN为允许串行接收位，由软件置位或清除。置位时允许串行接收，清除时禁止串行接收。</p><p>TB8是工作方式2和3要发送的第9位数据。在许多通信协议中该位是奇偶位，可以按需要由软件置位或清除。在多处理机通信中，该位用于表示是地址帧还是数据帧。</p><p>RB8是工作方式2和3中接收到的第9位数据（例如是奇偶位或者地址/数据标识位），在工作方式1中若SM2=0，则RB8是已接收的停止位。在工作方式0中RB8不使用。</p><p>TI 为发送中断标志位，由硬件置位，软件清除。工作方式0中在发送第8位末尾由硬件置位；在其他工作方式时，在发送停止位开始时由硬件置位。TI=1时，申请中断。CPU响应中断后，发送下一帧数据。在任何工作方式中都必须由软件清除TI。</p><p>RI为接收中断标志位，由硬件置位，软件清除。工作方式0中在接收第8位末尾由硬件置位；在其他工作方式时，在接收停止位的中间由硬件置位。RI=1时，申请中断，要求CPU取走数据。但在工作方式1中，SM2=1且未接收到有效的停止位时，不会对RI置位。</p><p>在任何工作方式中都必须由软件清除RI。</p><p>系统复位时，SCON的所有位都被清除。</p><p>（1） 工作方式0</p><p>SM0=0且SM1=0时，串口选择工作方式0，实质这是一种同步移位寄存器模式。其数据传输的波特率固定为Fosc/12，数据由RXD引脚输入或输出，同步时钟由TXD引脚输出。接收/发送的是8位数据，传输是低位在前，帧格式如下：</p><p>…….. D0 D1 D2 D3 D4 D5 D6 D7 …….</p><p>（2）工作方式1</p><p>当SM0=0且SM1=1时，串口选择工作方式1，其数据传输的波特率由定时/计数器T1、T2的溢出速率决定，可通过程序设定。当T2CON寄存器中的RCLK和TCLK置位时，用T2作为发送和接收波特率发生器，而RCLK=TCLK=0时，用T1作为波特率发生器，两者还可以交叉使用，即发送和接收采用不同的波特率。数据由TXD引脚发送，由RXD引脚接收。发送或接收一帧的数据为10位，即1位起始位（0）、8位数据位（低位在先）和1位停止位（1）。帧格式如下：</p><p>起始位0 D0 D1 D2 D3 D4 D5 D6 D7 停止位1</p><p>类似于工作方式0，当执行任一条SBUF指令时，就启动串行数据的发送。在执行写入SBUF的指令时，也将“1”写入发送移位寄存器的第9位，并通知发送控制器有发送请求。实际上，发送过程始于内部的16分频计数器下次满度翻转（全“1”变全“0”）后的那几个机器周期的开始。所以，每位的发送过程与16分频计数器同步，而不是与“写SBUF”同步。</p><p>（3）方式 2 和方式 3</p><p>这两种方式都是 11 位异步接收/发送方式。他们的操作过程都是完全一样</p><p>的，所不同的是波特率而已。方式 3 波特率同方式 1（定时器 1 作为波特率时钟发生器） 。</p><p>方式 2 和方式 3 的发送起始于任何一条 SBUF 数据装载指令。当第 9 位数据（TB8）输出之后，TI 将被置位（TI=1） 。</p><p>方式 2 和方式 3 的接收数据前提条件也是 REN 被编程为 1。 在第 9 位数据接收到后， 如果下列条件同时满足，即 RI=0 且 SM2=0 或者接收到的第 9 位为 1，则将已接受的数据装入 SBUF 缓冲器和 RB8，并将RI 置位（RI=1）否则接收数据无效。</p><p>8051 串行口的不同寻常的特征是包括第 9 位方式。它允许把在串行口通信增加的第 9 位用于标志特殊字节的接收。用这种方式，一个单片机可以和大量的其他单片机对话而不打扰不寻址的单片机，这种多机通信方式必须工作在严格的主从方式，由软件进行分析。</p><p>2.2 、LCD1602的原理</p><p>2.2.1 LCD1602的概述</p><p>液晶显示的原理是利用液晶的物理特性，通过电压对其显示区域进行控制，有电就有显示。LCD1602是有32个5x7点阵组成的行字符型显示屏。其操作方法如下：读写时序操作</p><p>读状态RS=L，R/W=H，E=H输出D0—D7</p><p>写指令RS=L，R/W=L，D0—D7指令码，E=高脉冲</p><p>读数据RS=H，R/W=H，E=H输出D0—D7数据</p><p>写数据RS=H，R/W=L，D0—D7数据，E=高脉冲</p><p><strong>2.2.2LCD1602的操作时序</strong></p><p>写操作时序图</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1528590549117f681e5d856><p class=pgc-img-caption></p></div><p><strong>2.2.3 LCD1602的基本命令</strong></p><p>1、RAM地址映射图</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590595973d036910e11><p class=pgc-img-caption></p></div><p><strong>2、指令码</strong></p><p>1602液晶模块内部的控制器共有11条控制指令，如表10-14所示：</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/152859065763283f700fe69><p class=pgc-img-caption></p></div><p>指令1：清显示，指令码01H,光标复位到地址00H位置。指令2：光标复位，光标返回到地址00H。</p><p>指令3：光标和显示模式设置I/D：光标移动方向，高电平右移，低电平左移S:屏幕上所有文字是否左移或者右移。高电平表示有效，低电平则无效。</p><p>指令4：显示开关控制。D：控制整体显示的开与关，高电平表示开显示，低电平表示关显示C：控制光标的开与关，高电平表示有光标，低电平表示无光标B：控制光标是否闪烁，高电平闪烁，低电平不闪烁。</p><p>指令5：光标或显示移位S/C：高电平时移动显示的文字，低电平时移动光标。</p><p>指令6：功能设置命令DL：高电平时为4位总线，低电平时为8位总线N：低电平时为单行显示，高电平时双行显示F:低电平时显示5x7的点阵字符，高电平时显示5x10的点阵字符。指令7：字符发生器RAM地址设置。</p><p>指令8：DDRAM地址设置。</p><p>指令9：读忙信号和光标地址BF：为忙标志位，高电平表示忙，此时模块不能接收命令或者数据，如果为低电平表示不忙。</p><p>指令10：写数据。</p><p>指令11：读数据。</p><p>2.3、红外一体化接收头</p><p>2.3.1红外一体化接收头的概述</p><p>红外遥控信号是一连串的二进制脉冲码。为了使其在无线传输过程中免受其他红外信号的干扰,通常都是先将其调制在特定的载波频率上,然后再经红外发射二极管发射出去,而红外线接收装置则要滤除其他杂波,只接收该特定频率的信号并将其还原成二进制脉冲码,也就是解调.</p><p>目前,对于这种进行了调制的红外遥控信号，通常是采用一体化红外线接收头进行调解.一体化红外线接收头将低噪音放大器,限幅器,带通滤波器,解调器,,以及整形驱动电路等集成在一起.一体化红外线接收头体积小,灵敏度高,外接元件少,抗干扰能力强,使用十分方便。</p><p>红外信号收发系统的典型电路如图1所示，红外接收电路通常被厂家集成在一个元件中，成为一体化红外接收头。 内部电路包括红外监测二极管，放大器，限幅器，带通滤波器，积分电路，比较器等。红外监测二极管监测到红外信号，然后把信号送到放大器和限幅器，限幅器把脉冲幅度控制在一定的水平，而不论红外发射器和接收器的距离远近。交流 信号进入带通滤波器，带通滤波器可以通过30khz到60khz的负载波，通过解调电路和积分电路进入比较器，比较器输出 高低电平，还原出发射端的信号波形。注意输出的高低电平和发射端是反相的，这样的目的是为了提高接收的灵敏度。</p><p>红外接收头的种类很多，引脚定义也不相同，一般都有三个引脚，包括供电脚，接地和信号输出脚。根据发射端调制 载波的不同应选用相应解调频率的接收头。</p><p>红外接收头内部放大器的增益很大，很容易引起干扰，因此在接收头的供电脚上须加上滤波电容，一般在22uf以上。 有的厂家建议在供电脚和电源之间接入330欧电阻，进一步降低电源干扰。</p><p>2.3.2红外一体化接收头的应用</p><p>红外遥控是以调制的方式发射数据，就是把数据和一定频率的载波进行“与”操作，这样既可以提高发射效率又可以降低电源 功耗。</p><p>调制载波频率一般在30khz到60khz之间，大多数使用的是38kHz，占空比1/3的方波，如图2所示，这是由发射端所使用的 455kHz晶振决定的。在发射端要对晶振进行整数分频，分频系数一般取12，所以455kHz÷12≈37.9 kHz≈38kHz。</p><p>单片机可以准备接收下面的数据。地址码由8位二进制组成，共256种．图中地址码重发了一次。主要是加强发射机的可靠性．如果两次地址码不相同．则说明本帧数据有错．应丢弃。不同的设备可以拥有不同的地址码．因此。同种编码的发射机只要设置地址码不同，也不会相互干扰。在同一个发射机中．所有按键发出的地址码都是相同的。数据码为8位，可编码256种状态，代表实际所按下的键。数据反码是数据码的各位求反，通过比较数据码与数据反码．可判断接收到的数据是否正确。如果数据码与数据反码之间的关系不满足相反的关系．则本次遥控接收有误．数据应丢弃。在同一个发射机上，所有按键的数据码均不相同。</p><p>数据格式包括了引导码、用户码、数据码和数据码反码，编码总占32位。数据反码是数据码反相后的编码，编码时可用于对数据的纠错。注意：第二段的用户码也可以在遥控应用电路中被设置成第一段用户码的反码。</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590702549e62d451cb5><p class=pgc-img-caption></p></div><p>用户码或数据码中的每一个位可以是位‘1’，也可以是位‘0’。区分‘0’和‘1’是利用脉冲的时间间隔来区分，这种编码方式称为脉冲位置调制方式，英文简写PPM。</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15285907523695a17b2a4e9><p class=pgc-img-caption></p></div><p>以接收TC9012遥控器编码为例，解码方法如下：</p><p>设外部中断为下降沿中断，定时器0(或者1)为16位计时器．初始值均为0</p><p>(2)第一次进入遥控中断后，开始计时。</p><p>(3)从第二次进入遥控中断起，先停止计时。并将计时值保存后，再重新计时。如果计时值等于前导码的时间，设立前导码标志。准备接收下面的一帧遥控数据，如果计时值不等于前导码的时间，但前面已接收到前导码，则判断是遥控数据的0还是1。</p><p>(4)继续接收下面的地址码、数据码、数据反码。</p><p>(5)当接收到32位数据时，说明一帧数据接收完毕。此时可停止定时器的计时，并判断本次接收是否有效．如果两次地址码相同且等于本系统的地址，数据码与数据反码之和等于0FFH，则接收的本帧数据码有效。否则丢弃本次接收到的数据。</p><p>(6)接收完毕，初始化本次接收的数据，准备下一次遥控接收。</p><p><strong>三、程序设计</strong></p><p>红外遥控锁系统主要由单片机通过红外通信控制,当其完成红外信号，读取数据，,其数据的传输根据协议的内容,发生错误时，有单片机发出警报，超出一定次数就把键盘锁死报警。红外遥控锁系统程序需要完成以下的功能：</p><p>1、矩阵键盘，可以设置密码开锁及密码重置；</p><p>3、遥控器输入密码开锁及密码重置；</p><p>5、密码输入输入信息或密码输入错误报警及键盘锁死；</p><p>6、用1602液晶显示功能状态。</p><p>矩阵键盘设置程序流程图如下：</p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590846628be32c7cae7><p class=pgc-img-caption></p></div><p><strong>四、过程分享</strong></p><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590913328337d5e9ef0><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590914609e03486c99f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1528590913628d500b50ec9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/152859091370487c6a822fb><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/152859091361756e9351d87><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/152859091345945a4c727ba><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590914199434a7926c9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15285909144025a2bcd19d4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1528590914548f3c97b9c34><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15285909144929d51fc2460><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590915130bbca5e3920><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1528590916384c502e0f80c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/152859091578251a311b35f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528590916545fa47b6bf68><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1528590915604cd2c394447><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15285909164242003d3c5cc><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528591068251d42898405e><p class=pgc-img-caption>PCB图</p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15285909845272d956b685a><p class=pgc-img-caption>原理图</p></div><div class=pgc-img><img alt=基于红外通信的单片机综合编程控制技术实现遥控密码锁功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1528591229939166f33875f><p class=pgc-img-caption></p></div><p><strong>程序代码：</strong></p><p>//(智能存钱管) //晶振12Mkz</p><p>//功能：该系统具有存钱取钱功能，存钱时需要输入密码 密码为000000</p><p>//密码可修改 万能密码为：131420 改密码可初始化密码为：000000 密码与存钱数有掉电保存功能</p><p>#include&lt;reg52.h> //头文件</p><p>#include&lt;intrins.h></p><p>#define uchar unsigned char //宏定义</p><p>#define uint unsigned int</p><p>#define LCD1602_dat P0</p><p>uchar irbyte[4];</p><p>uchar irtime,irflag,bitnum,irdateok;</p><p>uchar irdate[33];</p><p>sbit LCD1602_rs=P1^0;</p><p>sbit LCD1602_rw=P1^1;</p><p>sbit LCD1602_e=P1^2;</p><p>sbit led=P2^0;</p><p>sbit beep=P2^7;</p><p>sbit Scl=P3^5; //24C02串行时钟</p><p>sbit Sda=P3^4; //24C02串行数据</p><p>uchar ptem,mm[6],mm_n1[6],mm_n2[6],n,j;</p><p>uchar step,ms,time,cw;</p><p>uchar zt[2];</p><p>bit cq,beep1,beep2;</p><p>void mDelay(uint t) //延时</p><p>{</p><p>uchar i;</p><p>while(t--)</p><p>{</p><p>for(i=0;i&lt;125;i++)</p><p>{;}</p><p>}</p><p>}</p><p>void Nop(void) //空操作</p><p>{</p><p>_nop_();</p><p>_nop_();</p><p>_nop_();</p><p>_nop_();</p><p>}</p><p>/*起始条件*/</p><p>void Start(void)</p><p>{</p><p>Sda=1;</p><p>Scl=1;</p><p>Nop();</p><p>Sda=0;</p><p>Nop();</p><p>}</p><p>/*停止条件*/</p><p>void Stop(void)</p><p>{</p><p>Sda=0;</p><p>Scl=1;</p><p>Nop();</p><p>Sda=1;</p><p>Nop();</p><p>}</p><p>/*应答位*/</p><p>void Ack(void)</p><p>{</p><p>Sda=0;</p><p>Nop();</p><p>Scl=1;</p><p>Nop();</p><p>Scl=0;</p><p>}</p><p>/*反向应答位*/</p><p>void NoAck(void)</p><p>{</p><p>Sda=1;</p><p>Nop();</p><p>Scl=1;</p><p>Nop();</p><p>Scl=0;</p><p>}</p><p>/*发送数据子程序，Data为要求发送的数据*/</p><p>void Send(uchar Data)</p><p>{</p><p>uchar BitCounter=8;</p><p>uchar temp;</p><p>do</p><p>{</p><p>temp=Data;</p><p>Scl=0;</p><p>Nop();</p><p>if((temp&0x80)==0x80)</p><p>Sda=1;</p><p>else</p><p>Sda=0;</p><p>Scl=1;</p><p>temp=Data&lt;&lt;1;</p><p>Data=temp;</p><p>BitCounter--;</p><p>}</p><p>while(BitCounter);</p><p>Scl=0;</p><p>}</p><p>/*读一字节的数据，并返回该字节值*/</p><p>uchar Read(void)</p><p>{</p><p>uchar temp=0;</p><p>uchar temp1=0;</p><p>uchar BitCounter=8;</p><p>Sda=1;</p><p>do{</p><p>Scl=0;</p><p>Nop();</p><p>Scl=1;</p><p>Nop();</p><p>if(Sda)</p><p>temp=temp|0x01;</p><p>else</p><p>temp=temp&amp;0xfe;</p><p>if(BitCounter-1)</p><p>{</p><p>temp1=temp&lt;&lt;1;</p><p>temp=temp1;</p><p>}</p><p>BitCounter--;</p><p>}</p><p>while(BitCounter);</p><p>return(temp);</p><p>}</p><p>void WrToROM(uchar Data[],uchar Address,uchar Num)</p><p>{</p><p>uchar i;</p><p>uchar *PData;</p><p>PData=Data;</p><p>for(i=0;i&lt;Num;i++)</p><p>{</p><p>Start();</p><p>Send(0xa0);</p><p>Ack();</p><p>Send(Address+i);</p><p>Ack();</p><p>Send(*(PData+i));</p><p>Ack();</p><p>Stop();</p><p>mDelay(20);</p><p>}</p><p>}</p><p>void RdFromROM(uchar Data[],uchar Address,uchar Num)</p><p>{</p><p>uchar i;</p><p>uchar *PData;</p><p>PData=Data;</p><p>for(i=0;i&lt;Num;i++)</p><p>{</p><p>Start();</p><p>Send(0xa0);</p><p>Ack();</p><p>Send(Address+i);</p><p>Ack();</p><p>Start();</p><p>Send(0xa1);</p><p>Ack();</p><p>*(PData+i)=Read();</p><p>Scl=0;</p><p>NoAck();</p><p>Stop();</p><p>}</p><p>}</p><p>void delay(uint T) //延时函数</p><p>{</p><p>while(T--);</p><p>}</p><p>void qing() // 清楚数据</p><p>{</p><p>uint i;</p><p>for(i=0;i&lt;33;i++)</p><p>{</p><p>irdate[i]=0;</p><p>}</p><p>}</p><p>void deal_with() //解码处理部分</p><p>{</p><p>uchar i,j,k,temp;</p><p>k=1;</p><p>for(j=0;j&lt;4;j++)</p><p>{</p><p>for(i=0;i&lt;8;i++)</p><p>{</p><p>temp=temp>>1;</p><p>if(irdate[k]>7)</p><p>{</p><p>temp=temp|0x80;</p><p>}</p><p>k++;</p><p>}</p><p>irbyte[j]=temp;</p><p>}</p><p>}</p><p>void LCD1602_write(uchar order,dat) //1602 一个字节 处理</p><p>{</p><p>LCD1602_e=0;</p><p>LCD1602_rs=order;</p><p>LCD1602_dat=dat;</p><p>LCD1602_rw=0;</p><p>LCD1602_e=1;</p><p>delay(1);</p><p>LCD1602_e=0;</p><p>}</p><p>void LCD1602_writebyte(uchar *prointer) //1602 字符串 处理</p><p>{</p><p>while(*prointer!='\0')</p><p>{</p><p>LCD1602_write(1,*prointer);</p><p>prointer++;</p><p>}</p><p>}</p><p>void LCD1602_cls() //1602 初始化</p><p>{</p><p>LCD1602_write(0,0x01); //1602 清屏 指令</p><p>delay(1500);</p><p>LCD1602_write(0,0x38); // 功能设置 8位、5*7点阵</p><p>delay(1500);</p><p>LCD1602_write(0,0x0c); //设置 光标 不显示开关、不显示光标、字符不闪烁</p><p>LCD1602_write(0,0x06);</p><p>LCD1602_write(0,0xd0);</p><p>delay(1500);</p><p>}</p><p>uchar key_fs() //矩阵按键返回按码</p><p>{</p><p>uchar fs=255;</p><p>P1=0x0f;</p><p>if(P1!=0x0f)</p><p>{</p><p>delay(800);</p><p>P1=0x0f;</p><p>if(P1!=0x0f)</p><p>{</p><p>ptem=P1;</p><p>P1=0xf0;</p><p>ptem=ptem|P1;</p><p>switch (ptem)</p><p>{</p><p>case 0xe7:</p><p>fs=1;</p><p>break;</p><p>case 0xd7:</p><p>fs=2;</p><p>break;</p><p>case 0xb7:</p><p>fs=3;</p><p>break;</p><p>case 0x77:</p><p>fs=10;</p><p>break;</p><p>case 0xeb:</p><p>fs=4;</p><p>break;</p><p>case 0xdb:</p><p>fs=5;</p><p>break;</p><p>case 0xbb:</p><p>fs=6;</p><p>break;</p><p>case 0x7b:</p><p>fs=11;</p><p>break;</p><p>case 0xed:</p><p>fs=7;</p><p>break;</p><p>case 0xdd:</p><p>fs=8;</p><p>break;</p><p>case 0xbd:</p><p>fs=9;</p><p>break;</p><p>case 0x7d:</p><p>fs=12;</p><p>break;</p><p>case 0xee:</p><p>fs=13;</p><p>break;</p><p>case 0xde:</p><p>fs=0;</p><p>break;</p><p>case 0xbe:</p><p>fs=14;</p><p>break;</p><p>case 0x7e:</p><p>fs=15;</p><p>break;</p><p>}</p><p>P1=0x0f;</p><p>while(P1!=0x0f)</p><p>{</p><p>P1=0x0f;</p><p>}</p><p>}</p><p>}</p><p>return(fs);</p><p>}</p><p>void show() //显示程序</p><p>{</p><p>LCD1602_write(0,0x80);</p><p>LCD1602_writebyte("===Coded Lock===");</p><p>}</p><p>unsigned char coding_1(unsigned char m)</p><p>{</p><p>unsigned char k;</p><p>switch(m)</p><p>{</p><p>case (0x0c): k=1;break;</p><p>case (0x18): k=2;break;</p><p>case (0x5e): k=3;break;</p><p>case (0x08): k=4;break;</p><p>case (0x1c): k=5;break;</p><p>case (0x5a): k=6;break;</p><p>case (0x42): k=7;break;</p><p>case (0x52): k=8;break;</p><p>case (0x4a): k=9;break;</p><p>case (0x09): k=13;break;</p><p>case (0x16): k=0;break;</p><p>case (0x19): k=14;break;</p><p>case (0x0d): k=15;break;</p><p>case (0x07): k=12;break;</p><p>}</p><p>return(k);</p><p>}</p><p>void key() //按键键码处理程序</p><p>{</p><p>uchar fz=255,i;</p><p>if(irbyte[2]!=0)</p><p>{</p><p>fz=coding_1(irbyte[2]);</p><p>do</p><p>{</p><p>qing();</p><p>deal_with();</p><p>}while(irbyte[2]!=0);</p><p>}else</p><p>{</p><p>fz=key_fs();</p><p>}</p><p>if(fz!=255)</p><p>{</p><p>beep2=1;beep=0;</p><p>delay(10000);</p><p>beep2=0;beep=1;</p><p>}</p><p>if(step==0)</p><p>{</p><p>if(fz&lt;10&&cq==0&&n&lt;6)</p><p>{</p><p>if(n==0)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte("Pass:");</p><p>}</p><p>mm_n1[n]=fz;</p><p>n++;</p><p>LCD1602_write(0,0xc5);</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>LCD1602_writebyte("*");</p><p>}</p><p>}</p><p>}else if(step==1|step==2)</p><p>{</p><p>if(fz&lt;10&&n&lt;6)</p><p>{</p><p>mm_n1[n]=fz;</p><p>n++;</p><p>LCD1602_write(0,0xc9);</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>LCD1602_writebyte("*");</p><p>}</p><p>}</p><p>}else if(step==3)</p><p>{</p><p>if(fz&lt;10&&n&lt;6)</p><p>{</p><p>mm_n2[n]=fz;</p><p>n++;</p><p>LCD1602_write(0,0xc6);</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>LCD1602_writebyte("*");</p><p>}</p><p>}</p><p>}</p><p>switch(fz)</p><p>{</p><p>case 11:</p><p>break;</p><p>case 12:</p><p>if(n!=0)</p><p>{</p><p>n--;</p><p>if(step==0)</p><p>{</p><p>mm_n1[n+1]=0xff;</p><p>LCD1602_write(0,0xc5);</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>LCD1602_writebyte("*");</p><p>}</p><p>for(i=0;i&lt;6-n;i++)</p><p>{</p><p>LCD1602_writebyte(" ");</p><p>}</p><p>}else if(step==1|step==2)</p><p>{</p><p>mm_n1[n+1]=0xff;</p><p>LCD1602_write(0,0xc9);</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>LCD1602_writebyte("*");</p><p>}</p><p>for(i=0;i&lt;6-n;i++)</p><p>{</p><p>LCD1602_writebyte(" ");</p><p>}</p><p>}else if(step==3)</p><p>{</p><p>mm_n2[n+1]=0xff;</p><p>LCD1602_write(0,0xc6);</p><p>for(i=0;i&lt;n;i++)</p><p>{</p><p>LCD1602_writebyte("*");</p><p>}</p><p>for(i=0;i&lt;6-n;i++)</p><p>{</p><p>LCD1602_writebyte(" ");</p><p>}</p><p>}</p><p>}</p><p>break;</p><p>case 13:</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte("Password");</p><p>step=0;</p><p>cq=0;</p><p>n=0;</p><p>led=0;</p><p>zt[0]='N';</p><p>zt[1]='O';</p><p>WrToROM(zt,10,2);</p><p>break;</p><p>case 14:</p><p>if(step==0)</p><p>{</p><p>if(n==6)</p><p>{</p><p>n=0;</p><p>for(i=0;i&lt;6;i++)</p><p>{</p><p>if(mm[i]!=mm_n1[i])</p><p>{</p><p>break;</p><p>}</p><p>}</p><p>if(i==6)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Open");</p><p>led=1;</p><p>zt[0]='O';</p><p>zt[1]='K';</p><p>WrToROM(zt,10,2);</p><p>cq=1;</p><p>cw=0;</p><p>}else if(mm_n1[0]==1&&mm_n1[1]==3&&mm_n1[2]==1&&mm_n1[3]==4&&mm_n1[4]==2&&mm_n1[5]==0)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc3);</p><p>LCD1602_writebyte("Pass init");</p><p>for(j=0;j&lt;6;j++)</p><p>{</p><p>mm[j]=0;</p><p>}</p><p>cw=0;</p><p>WrToROM(mm,0,6);</p><p>}else</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>time=3;</p><p>cw++;</p><p>if(cw>2)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc2);</p><p>LCD1602_writebyte("Locked state");</p><p>while(1)</p><p>{</p><p>beep1=1;</p><p>cw=3;</p><p>time=5;</p><p>}</p><p>}</p><p>}</p><p>}else</p><p>{</p><p>n=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>time=3;</p><p>cw++;</p><p>if(cw>2)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc2);</p><p>LCD1602_writebyte("Locked state");</p><p>while(1)</p><p>{</p><p>beep1=1;</p><p>cw=3;</p><p>time=5;</p><p>}</p><p>}</p><p>}</p><p>}else if(step==1)</p><p>{</p><p>if(n==6)</p><p>{</p><p>n=0;</p><p>for(i=0;i&lt;6;i++)</p><p>{</p><p>if(mm[i]!=mm_n1[i])</p><p>{</p><p>break;</p><p>}</p><p>}</p><p>if(i==6)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte("New pass:");</p><p>step=2;</p><p>}else</p><p>{</p><p>step=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>}</p><p>}else</p><p>{</p><p>step=0;</p><p>n=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>}</p><p>}else if(step==2)</p><p>{</p><p>if(n==6)</p><p>{</p><p>n=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte("Again:");</p><p>step=3;</p><p>}else</p><p>{</p><p>step=0;</p><p>n=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>}</p><p>}else</p><p>{</p><p>step=0;</p><p>if(n==6)</p><p>{</p><p>n=0;</p><p>for(i=0;i&lt;6;i++)</p><p>{</p><p>if(mm_n1[i]!=mm_n2[i])</p><p>{</p><p>break;</p><p>}</p><p>}</p><p>if(i==6)</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc4);</p><p>LCD1602_writebyte("Pass OK");</p><p>for(i=0;i&lt;6;i++)</p><p>{</p><p>mm[i]=mm_n1[i];</p><p>}</p><p>WrToROM(mm,0,6);</p><p>}else</p><p>{</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>}</p><p>}else</p><p>{</p><p>n=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc5);</p><p>LCD1602_writebyte("Error");</p><p>}</p><p>}</p><p>break;</p><p>case 15:</p><p>step=1;</p><p>n=0;</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte(" ");</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte("Old pass:");</p><p>break;</p><p>}</p><p>}</p><p>void main() //主程序</p><p>{</p><p>TMOD=0x12;</p><p>TH0=0;</p><p>TL0=0;</p><p>TH1=0x3c;</p><p>TL1=0xb0;</p><p>EA=1;</p><p>ET0=1;</p><p>ET1=1;</p><p>TR0=1;</p><p>TR1=1;</p><p>EX0=1;</p><p>IT0=1;</p><p>LCD1602_cls();</p><p>RdFromROM(zt,10,2);</p><p>if(zt[0]=='O'&&zt[1]=='K')</p><p>{</p><p>led=1;</p><p>}else</p><p>{</p><p>led=0;</p><p>}</p><p>show();</p><p>LCD1602_write(0,0xc0);</p><p>LCD1602_writebyte("Password");</p><p>RdFromROM(mm,0,6);</p><p>while(1)</p><p>{</p><p>if(irdateok==1) //解码完成处理</p><p>{</p><p>irdateok=0;</p><p>deal_with();</p><p>}</p><p>key();</p><p>}</p><p>}</p><p>void time3_interrupt()interrupt 3</p><p>{</p><p>TH1=0x3c;</p><p>TL1=0xb0;</p><p>ms++;</p><p>if(ms%3==0)</p><p>{</p><p>if(beep2==0)</p><p>{</p><p>if(beep1==1)</p><p>{</p><p>beep=!beep;</p><p>}else</p><p>{</p><p>beep=1;</p><p>}</p><p>}</p><p>}</p><p>if(ms>19)</p><p>{</p><p>ms=0;</p><p>if(time!=0)</p><p>{</p><p>time--;</p><p>beep1=1;</p><p>}</p><p>else beep1=0;</p><p>}</p><p>}</p><p>//==================================定时器0中断函数，用于数码管扫描显示====================================</p><p>void time0_interrupt()interrupt 1</p><p>{</p><p>irtime++;</p><p>}</p><p>void int0() interrupt 0 //遥控器解码</p><p>{</p><p>if(irflag==1)</p><p>{</p><p>if(irtime>32)</p><p>{</p><p>bitnum=0;</p><p>}</p><p>irdate[bitnum]=irtime;</p><p>irtime=0;</p><p>bitnum++;</p><p>if(bitnum==33)</p><p>{</p><p>bitnum=0;</p><p>irdateok=1;</p><p>}</p><p>}</p><p>else</p><p>{</p><p>irflag=1;</p><p>irtime=0;</p><p>}</p><p>}</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'红外','单片机','综合'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>