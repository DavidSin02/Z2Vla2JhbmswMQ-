<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Redis的5种数据类型与编码结构分析 | 极客快訊</title><meta property="og:title" content="Redis的5种数据类型与编码结构分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b51e65c8c7cf429aa2911bb775b98cc4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3d0c5523.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3d0c5523.html><meta property="article:published_time" content="2020-11-14T21:05:10+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:10+08:00"><meta name=Keywords content><meta name=description content="Redis的5种数据类型与编码结构分析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3d0c5523.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Redis的5种数据类型与编码结构分析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>一、概述</strong></p><ul><li>Redis作为一个分布式缓存实现，相对于Memecache，除了支持持久化之外，一个重要的特性是Redis支持丰富的数据类型，即Memecache只支持字符串类型，所有键值对都是字符串类型，而Redis的值支持字符串，列表，字典，集合，有序集合五种类型，故可以提供更加丰富的操作。</li><li>Redis的每种数据类型都支持多种底层数据结构实现，即每种数据类型并不是绑定为一种数据结构的，而是可以多种。这种设计的原因是：Redis是一种内存数据库，所有数据都保存在内存中，故在设计时，需要在保证性能的前提下，尽可能的减少内存消耗，在内存和性能之间进行一个平衡，从而可以存储更多的数据。所以在介绍数据类型之前，先介绍一下Redis底层的数据结构。</li></ul><p><strong>二、数据结构</strong></p><p><strong>简单动态字符串</strong></p><ul><li>Redis是使用C语言编写的，Redis没有直接使用C语言的字符串实现，而是基于C语言的字符串实现了简单动态字符串。其主要原因是C的字符串是底层的API，存在以下问题：（1）没有记录字符串长度，故需要O(n)复杂度获取字符串长度；（2）由于没有记录字符串长度，故容易出现缓冲区溢出问题；（3）每次对字符串拓容都需要使用系统调用，没有预留空间（4）C的字符串只能保存字符。</li><li>基于以上问题，Redis的简单动态字符串提供了：（1）通过len记录字符串长度，实现O(1)复杂度获取；（2）内部字符串数组预留了空间，减少字符串的内存重分配次数，同时实现了自动拓容避免缓冲区溢出问题；（3）内部字符数组基于字节来保存数据，故可以保存字符和二进制数据。具体数据结构设计如下：</li></ul><pre>struct __attribute__ ((__packed__)) sdshdr64 { // 已使用字符串长度 uint64_t len; /* used */ // 一共分配了多少字节，alloc - len就是预留的 uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ // 字节数组 char buf[];};</pre><p><strong>双向链表</strong></p><ul><li>C语言没有提供双向链表的实现，故Redis自身实现了一个双向链表，主要用于存放列表数据。具体数据结构如下：</li><li>链表节点定义：</li></ul><pre>typedef struct listNode { // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 数据，使用void指针实现多态，即可以存放多种数据类型的数据 void *value;} listNode;</pre><ul><li>链表定义：</li></ul><pre>typedef struct list { // 链表头指针 listNode *head; // 链表尾指针 listNode *tail; void *(*dup)(void *ptr); void (*free)(void *ptr); int (*match)(void *ptr, void *key); // 链表长度 unsigned long len;} list;</pre><p><strong>链式哈希字典</strong></p><ul><li>Redis的哈希表实现为链式哈希，即冲突节点使用链表来维护，具体数据结构如下：</li><li>哈希链表节点：</li></ul><pre>// 哈希链表节点typedef struct dictEntry { // 键key void *key; union { // 值value void *val; uint64_t u64; int64_t s64; double d; } v; // 下一个链表节点 struct dictEntry *next;} dictEntry;</pre><ul><li>链式哈希表实现：</li></ul><pre>// 链式哈希表实现typedef struct dictht { // 链式哈希实现 dictEntry **table; // 哈希表元素个数 unsigned long size; // 哈希掩码，用于基于&amp;与运算来计算哈希索引，大小总是为size -1 unsigned long sizemask; unsigned long used;} dictht;</pre><ul><li>Redis哈希结构：</li></ul><pre>typedef struct dict { dictType *type; void *privdata; // 两个哈希表，其中一个空着在rehash的时候使用 dictht ht[2]; long rehashidx; /* rehashing not in progress if rehashidx == -1 */ unsigned long iterators; /* number of iterators currently running */} dict;</pre><p><strong>压缩列表ziplist</strong></p><ul><li>压缩列表主要是基于节省内存的目标设计的，是由一些特殊编码的连续内存块组成的顺序型数据结构。</li><li>当列表元素较少且元素类型都是小整数或者比较短的字符串时，使用压缩列表来存储。因为压缩列表的数据存取一般是需要遍历，即线性O(n)时间复杂度，但是元素较少时，不会造成性能问题，类似于常量O(1)时间复杂度了。</li><li>压缩列表的整体结构如下：主要包括了列表总字节数zlbytes，列表尾节点距离列表起始地址多少个字节数zltail，列表总元素个数zllen，列表元素数据节点entry（图片均引自黄建宏的《Redis设计与实现》）</li></ul><div class=pgc-img><img alt=Redis的5种数据类型与编码结构分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b51e65c8c7cf429aa2911bb775b98cc4><p class=pgc-img-caption></p></div><ul><li>元素列表的元素节点：每个节点都包含了前一个节点的大小，从而基于当前元素的位置计算前一个节点的位置实现遍历；encoding表示content所保存的值的数据类型和长度，content为具体的值。</li></ul><p><strong>数集合intset</strong></p><ul><li>整数集合是集合的一种数据结构，当集合只存在整数元素且集合元素个数不多时，使用这种数据结构。</li><li>具体数据结构定义如下：</li></ul><pre>typedef struct intset { uint32_t encoding; uint32_t length; // 整数元素集合，类型为int8整数 int8_t contents[];} intset;</pre><p><strong>跳跃表skiplist</strong></p><ul><li>跳跃表是一种特殊的链表结构，在每个链表节点包含了指向其他链表节点的指针，故可以快速访问其他链表节点，而不需要顺序遍历，实现了通过空间换时间的方法来优化性能。跳跃表的读写平均复杂度为O(logN)，故树结构差不多，不过结构比树结构简单。</li><li>在Redis中，跳跃表主要用于实现有序集合zset，每个链表节点包含了成员对象和分数。从头结点到尾节点，以分值从小到大的升序排序。</li><li>跳跃表定义：</li></ul><pre>typedef struct zskiplist { // 跳跃表的头结点和尾节点 struct zskiplistNode *header, *tail; // 链表节点总个数 unsigned long length; // 层的个数 int level;} zskiplist;</pre><ul><li>跳跃表节点定义：</li></ul><pre>typedef struct zskiplistNode { // 成员对象 sds ele; // 分数 double score; // 后置节点 struct zskiplistNode *backward; // 层级 struct zskiplistLevel { // forward指针，执行下一层的某个节点 struct zskiplistNode *forward; // forward指针对应的节点相对当前节点的层的跨度 unsigned int span; } level[];} zskiplistNode;</pre><ul><li>结构示意图：</li></ul><div class=pgc-img><img alt=Redis的5种数据类型与编码结构分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5f07721103bb4c6994c743a15da3b463><p class=pgc-img-caption></p></div><p><strong>三、数据类型</strong></p><ul><li>以下数据类型为提供给应用程序使用的，在底层实现中使用以上的一种或者多种数据结构进行编码。</li><li>对应每个键key可以使用TYPE命令查看其值的数据类型，使用OBJECT ENCODING来查查底层的编码类型，如下：</li></ul><pre>127.0.0.1:6379&gt; set test 123OK127.0.0.1:6379&gt; type teststring127.0.0.1:6379&gt; object encoding test"int"127.0.0.1:6379&gt;</pre><p><strong>字符串string</strong></p><ul><li>在Redis中，对应整数类型，如果不超过C语言long类型的范围，则使用long类型来存储，如果超过则使用embstr或者raw字符串来存储；对应字符串和浮点数统一使用embstr或raw字符串来存储。</li><li>int：可以使用long类型来保存的整数。</li><li>embstr：字符串的字节数小于等于32时，使用embstr来编码，注意无法使用long类型来保存的整数，浮点数在Redis中都是使用字符串来存储的，如果遇到计算命令，如incrby递增，则Redis在读出该字符串后，先转换为相应的整数或浮点数进行计算。</li><li>raw：embstr无法存储的字符串，即字节数大于32个字节的，则使用raw来编码。</li><li>embstr和raw编码一样，都是用于存储字符串，embstr是对raw在存储短字符时的一种优化。不同的是embstr主要用于存放短字符串，在内存分配方面使用一次内存分配来创建数据类型string在Redis内部对应的对象redisObject和用于存储数据的简单动态字符串sds，而raw由于需要分配较大的sds，故使用两次内存分配分别创建以上两个对象。</li></ul><p><strong>列表list</strong></p><ul><li>列表主要用于存放多个相同或不同的元素，在底层编码方面也存在压缩列表和双向链表两种数据结构。</li><li>选择规则：列表中的所保存的字符串元素的长度都小于64个字节，且列表中元素个数小于512个时，使用压缩列表，否则使用双向链表。</li><li>以上为默认规则，其中切换临界点：字符串长度和列表元素个数可以在配置文件redis.conf中通过list-max-ziplist-value，list-max-ziplist-entries来修改。</li></ul><p><strong>字典hash</strong></p><ul><li>字典主要用于存放键值对数据，在底层编码也存在压缩列表和链式哈希表两种数据结构。</li><li>选择规则：哈希对象的键和值的字符串长度都小于64字节且所有哈希对象个数小于512个，则使用压缩列表，否则使用链式哈希表。</li><li>以上为默认规则，也可以通过redis.conf中的hash-max-ziplist-value和hash-max-ziplist-entries参数来修改。</li></ul><p><strong>集合set</strong></p><ul><li>集合set是一个存放无重复元素的集合，在底层编码方面存在整数集合和链式哈希表两种数据结构。</li><li>选择规则：集合中所有元素均为整数值（具体为int8）且元素个数不超过512个，则使用整数集合intset，否则使用链式哈希表。</li><li>以上为默认规则，其中512的可以在redis.conf中通过set-max-intset-entries参数来修改。</li></ul><p><strong>有序集合zset</strong></p><ul><li>有序集合主要实现了通过分数score来排序的功能，其中score可以重复，成员对象member不能重复，即有序是面向分数score的，集合是面向成员对象member的。</li><li>在底层编码也存在压缩列表和跳跃表两种数据结构。</li><li>选择规则：有序集合元素个数少于128个且每个元素的成员对象member的长度都小于64个字节，则使用压缩列表，否则使用跳跃表。</li><li>以上规则可以在redis.conf中通过zset-max-ziplist-entires和zset-max-ziplist-value来修改。</li></ul><p><strong>四、编码降级</strong></p><ul><li>除了字符串的值可以在int，embstr，raw之间切换之外（字符串类型对于SET命令其实是一个新的对象了），其他类型，即压缩列表，整数集合intset和其他数据结构之间是不能降级的，如对于集合set，值从整数集合inset升级为链式哈希表之后，在删除元素时，不能再降级为整数集合，如下：</li></ul><pre>127.0.0.1:6379&gt; sadd set2 1(integer) 1127.0.0.1:6379&gt; object encoding set2"intset"// 添加hello字符串从整数集合intset升级为hashtable127.0.0.1:6379&gt; sadd set2 hello(integer) 1127.0.0.1:6379&gt; object encoding set2"hashtable"// 移除hello之后，集合只存在1这一个整数，集合不会降级为整数集合intset127.0.0.1:6379&gt; srem set2 hello(integer) 1127.0.0.1:6379&gt; smembers set21) "1"127.0.0.1:6379&gt; object encoding set2"hashtable"</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Redis','种数据','类型'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>