<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JavaScript二叉树（二叉搜索树）的详细介绍 | 极客快訊</title><meta property="og:title" content="JavaScript二叉树（二叉搜索树）的详细介绍 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9f01674b907b45c390bbc94168d16a71"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3dc85d2e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3dc85d2e.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="JavaScript二叉树（二叉搜索树）的详细介绍"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3dc85d2e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JavaScript二叉树（二叉搜索树）的详细介绍</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>本篇文章给大家带来的内容是关于JavaScript中二叉树（二叉堆）的介绍（代码示例），有一定的参考价值，有需要的朋友可以参考一下，希望对你有所帮助。</p><p><strong>二叉树</strong></p><p>二叉树(Binary Tree)是一种树形结构，它的特点是每个节点最多只有两个分支节点，一棵二叉树通常由根节点，分支节点，叶子节点组成。而每个分支节点也常常被称作为一棵子树。</p><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9f01674b907b45c390bbc94168d16a71><p class=pgc-img-caption></p></div><ul><li>根节点：二叉树最顶层的节点</li><li>分支节点：除了根节点以外且拥有叶子节点</li><li>叶子节点：除了自身，没有其他子节点</li></ul><p><strong>常用术语</strong></p><p>在二叉树中，我们常常还会用父节点和子节点来描述，比如图中2为6和3的父节点，反之6和3是2子节点</p><p><strong>二叉树的三个性质</strong></p><ol><li>在二叉树的第i层上，至多有2^i-1个节点</li></ol><ul><li class=ql-indent-1>i=1时，只有一个根节点，2^(i-1) = 2^0 = 1</li></ul><ol><li>深度为k的二叉树至多有2^k-1个节点</li></ol><ul><li class=ql-indent-1>i=2时，2^k-1 = 2^2 - 1 = 3个节点</li></ul><ol><li>对任何一棵二叉树T，如果总结点数为n0，度为2(子树数目为2)的节点数为n2,则n0=n2+1</li></ol><p>树和二叉树的三个主要差别</p><ul><li>树的节点个数至少为1，而二叉树的节点个数可以为0</li><li>树中节点的最大度数(节点数量)没有限制,而二叉树的节点的最大度数为2</li><li>树的节点没有左右之分，而二叉树的节点有左右之分</li></ul><p>二叉树分类</p><p>二叉树分为完全二叉树(complete binary tree)和满二叉树(full binary tree)</p><ul><li>满二叉树：一棵深度为k且有2^k - 1个节点的二叉树称为满二叉树</li><li>完全二叉树：完全二叉树是指最后一层左边是满的，右边可能满也可能不满，然后其余层都是满的二叉树称为完全二叉树(满二叉树也是一种完全二叉树)</li></ul><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6391dd66723a4930a0fb3919a9e5cfd9><p class=pgc-img-caption></p></div><p>二叉树的数组表示</p><p>用一个数组来表示二叉树的结构，将一组数组从根节点开始从上到下，从左到右依次填入到一棵完全二叉树中，如下图所示</p><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/98d5295ce6bb4ddda475a8b39bb76a5b><p class=pgc-img-caption></p></div><p>通过上图我们可以分析得到数组表示的完全二叉树拥有以下几个性质：</p><ul><li>left = index * 2 + 1，例如：根节点的下标为0，则左节点的值为下标array[0＊2+1]=1</li><li>right = index * 2 + 2，例如：根节点的下标为0，则右节点的值为下标array[0＊2+2]=2</li><li>序数 >= floor(N/2)都是叶子节点，例如：floor(9/2) = 4，则从下标4开始的值都为叶子节点</li></ul><p>二叉堆</p><p>二叉堆由一棵完全二叉树来表示其结构，用一个数组来表示，但一个二叉堆需要满足如下性质：</p><ul><li>二叉堆的父节点的键值总是大于或等于(小于或等于)任何一个子节点的键值</li><li>当父节点的键值大于或等于(小于或等于)它的每一个子节点的键值时，称为<strong>最大堆（最小堆）</strong></li></ul><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5edd1a8b4d944a4a8f23e26987a38ce5><p class=pgc-img-caption></p></div><ul><li><br></li></ul><p>从上图可以看出：</p><ul><li>左图：父节点总是大于或等于其子节点，所以满足了二叉堆的性质，</li><li>右图：分支节点7作为2和12的父节点并没有满足其性质(大于或等于子节点)。</li></ul><p>二叉堆的主要操作</p><ul><li>insert：插入节点</li><li>delete：删除节点</li><li>max-hepify：调整分支节点堆性质</li><li>rebuildHeap：重新构建整个二叉堆</li><li>sort：排序</li></ul><p>初始化一个二叉堆</p><p>从上面简单的介绍，我们可以知道，一个二叉堆的初始化非常的简单，它就是一个数组</p><ul><li>初始化一个数组结构</li><li>保存数组长度</li></ul><p>class Heap{</p><p>constructor(arr){</p><p>this.data = [...arr];</p><p>this.size = this.data.length;</p><p>}</p><p>}</p><p>max-heapify最大堆操作</p><p>max-heapify是把每一个不满足最大堆性质的分支节点进行调整的一个操作。</p><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1cf8b7cc44a1462e825e932bf750c6d4><p class=pgc-img-caption></p></div><p>如上图：</p><ol><li>调整分支节点2（分支节点2不满足最大堆的性质）</li></ol><ul><li class=ql-indent-1>默认该分支节点为最大值</li></ul><ol><li>将2与左右分支比较，从2，12，5中找出最大值，然后和2交换位置</li></ol><ul><li class=ql-indent-1>根据上面所将的二叉堆性质，分别得到分支节点2的左节点和右节点</li><li class=ql-indent-1>比较三个节点，得到最大值的下标max</li><li class=ql-indent-1>如果该节点本身就是最大值，则停止操作</li><li class=ql-indent-1>将max节点与父节点进行交换</li></ul><ol><li>重复step2的操作，从2，4，7中找出最大值与2做交换</li></ol><ul><li class=ql-indent-1>递归</li></ul><p>maxHeapify(i) {</p><p>let max = i;</p><p>if(i >= this.size){</p><p>return;</p><p>}</p><p>// 当前序号的左节点</p><p>const l = i * 2 + 1;</p><p>// 当前需要的右节点</p><p>const r = i * 2 + 2;</p><p>// 求当前节点与其左右节点三者中的最大值</p><p>if(l &lt; this.size && this.data[l] > this.data[max]){</p><p>max = l;</p><p>}</p><p>if(r &lt; this.size && this.data[r] > this.data[max]){</p><p>max = r;</p><p>}</p><p>// 最终max节点是其本身,则已经满足最大堆性质，停止操作</p><p>if(max === i) {</p><p>return;</p><p>}</p><p>// 父节点与最大值节点做交换</p><p>const t = this.data[i];</p><p>this.data[i] = this.data[max];</p><p>this.data[max] = t;</p><p>// 递归向下继续执行</p><p>return this.maxHeapify(max);</p><p>}</p><p>重构堆</p><p>我们可以看到，刚初始化的堆由数组表示，这个时候它可能并不满足一个最大堆或最小堆的性质，这个时候我们可能需要去将整个堆构建成我们想要的。</p><p>上面我们做了max-heapify操作，而max-heapify只是将某一个分支节点进行调整，而要将整个堆构建成最大堆，则需要将所有的分支节点都进行一次max-heapify操作，如下图，我们需要依次对12，3，2，15这4个分支节点进行max-hepify操作</p><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4a53ec061480437bb9bb5dc16721e32e><p class=pgc-img-caption></p></div><p>具体步骤：</p><ul><li>找到所有分支节点：上面堆的性质提到过叶子节点的序号>=Math.floor(n/2)，因此小于Math.floor(n/2)序号的都是我们需要调整的节点。</li><li class=ql-indent-1>例如途中所示数组为[15,2,3,12,5,2,8,4,7] => Math.floor(9/2)=4 => index小于4的分别是15，2，3，12(需要调整的节点)，而5，2，8，4，7为叶子节点。</li><li>将找到的节点都进行maxHeapify操作</li></ul><p>rebuildHeap(){</p><p>// 叶子节点</p><p>const L = Math.floor(this.size / 2);</p><p>for(let i = L - 1; i>=0; i--){</p><p>this,maxHeapify(i);</p><p>}</p><p>}</p><p>最大堆排序</p><div class=pgc-img><img alt=JavaScript二叉树（二叉搜索树）的详细介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/311cad3fbb5444028367a6f04cfc1e2c><p class=pgc-img-caption></p></div><p>最大堆的排序，如上图所示：</p><ul><li>交换首尾位置</li><li>将最后个元素从堆中拿出，相当于堆的size-1</li><li>然后在堆根节点进行一次max-heapify操作</li><li>重复以上三个步骤，知道size=0 (这个边界条件我们在max-heapify函数里已经做了)</li></ul><p>sort() {</p><p>for(let i = this.size - 1; i > 0; i--){</p><p>swap(this.data, 0, i);</p><p>this.size--;</p><p>this.maxHeapify(0);</p><p>}</p><p>}</p><p>插入和删除</p><p>这个的插入和删除就相对比较简单了，就是对一个数组进行插入和删除的操作</p><ul><li>往末尾插入</li><li>堆长度+1</li><li>判断插入后是否还是一个最大堆</li><li>不是则进行重构堆</li></ul><p>insert(key) {</p><p>this.data[this.size] = key;</p><p>this.size++</p><p>if (this.isHeap()) {</p><p>return;</p><p>}</p><p>this.rebuildHeap();</p><p>}</p><ul><li>删除数组中的某个元素</li><li>堆长度-1</li><li>判断是否是一个堆</li><li>不是则重构堆</li></ul><p>delete(index) {</p><p>if (index >= this.size) {</p><p>return;</p><p>}</p><p>this.data.splice(index, 1);</p><p>this.size--;</p><p>if (this.isHeap()) {</p><p>return;</p><p>}</p><p>this.rebuildHeap();</p><p>}</p><p>完整代码</p><p>/**</p><p>* 最大堆</p><p>*/</p><p>function left(i) {</p><p>return i * 2 + 1;</p><p>}</p><p>function right(i) {</p><p>return i * 2 + 2;</p><p>}</p><p>function swap(A, i, j) {</p><p>const t = A[i];</p><p>A[i] = A[j];</p><p>A[j] = t;</p><p>}</p><p>class Heap {</p><p>constructor(arr) {</p><p>this.data = [...arr];</p><p>this.size = this.data.length;</p><p>}</p><p>/**</p><p>* 重构堆</p><p>*/</p><p>rebuildHeap() {</p><p>const L = Math.floor(this.size / 2);</p><p>for (let i = L - 1; i >= 0; i--) {</p><p>this.maxHeapify(i);</p><p>}</p><p>}</p><p>isHeap() {</p><p>const L = Math.floor(this.size / 2);</p><p>for (let i = L - 1; i >= 0; i++) {</p><p>const l = this.data[left(i)] || Number.MIN_SAFE_INTEGER;</p><p>const r = this.data[right(i)] || Number.MIN_SAFE_INTEGER;</p><p>const max = Math.max(this.data[i], l, r);</p><p>if (max !== this.data[i]) {</p><p>return false;</p><p>}</p><p>return true;</p><p>}</p><p>}</p><p>sort() {</p><p>for (let i = this.size - 1; i > 0; i--) {</p><p>swap(this.data, 0, i);</p><p>this.size--;</p><p>this.maxHeapify(0);</p><p>}</p><p>}</p><p>insert(key) {</p><p>this.data[this.size++] = key;</p><p>if (this.isHeap()) {</p><p>return;</p><p>}</p><p>this.rebuildHeap();</p><p>}</p><p>delete(index) {</p><p>if (index >= this.size) {</p><p>return;</p><p>}</p><p>this.data.splice(index, 1);</p><p>this.size--;</p><p>if (this.isHeap()) {</p><p>return;</p><p>}</p><p>this.rebuildHeap();</p><p>}</p><p>/**</p><p>* 堆的其他地方都满足性质</p><p>* 唯独跟节点，重构堆性质</p><p>* @param {*} i</p><p>*/</p><p>maxHeapify(i) {</p><p>let max = i;</p><p>if (i >= this.size) {</p><p>return;</p><p>}</p><p>// 求左右节点中较大的序号</p><p>const l = left(i);</p><p>const r = right(i);</p><p>if (l &lt; this.size && this.data[l] > this.data[max]) {</p><p>max = l;</p><p>}</p><p>if (r &lt; this.size && this.data[r] > this.data[max]) {</p><p>max = r;</p><p>}</p><p>// 如果当前节点最大，已经是最大堆</p><p>if (max === i) {</p><p>return;</p><p>}</p><p>swap(this.data, i, max);</p><p>// 递归向下继续执行</p><p>return this.maxHeapify(max);</p><p>}</p><p>}</p><p>module.exports = Heap;</p><p>总结</p><p>堆讲到这里就结束了，堆在二叉树里相对会比较简单，常常被用来做排序和优先级队列等。堆中比较核心的还是max-heapify这个操作，以及堆的三个性质。</p><p>以上就是JavaScript中二叉树（二叉堆）的介绍（代码示例）的详细内容，更多请关注其它相关文章！</p><p>更多技巧请《转发 + 关注》哦！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'二叉','JavaScript','详细介绍'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>