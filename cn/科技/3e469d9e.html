<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python标准库之struct | 极客快訊</title><meta property="og:title" content="Python标准库之struct - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f13f4c95896444989d1575168e474248"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e469d9e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e469d9e.html><meta property="article:published_time" content="2020-10-29T21:09:08+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:08+08:00"><meta name=Keywords content><meta name=description content="Python标准库之struct"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3e469d9e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python标准库之struct</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=Python标准库之struct onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f13f4c95896444989d1575168e474248><p class=pgc-img-caption></p></div><p>Python 为了保持语言的简洁，仅为用户提供了几种简单的数据结构：int, float, str, list, dict，tuple。不同于编译型语言 C/C++，在 Python 中，我们往往不需要关心不同类型的变量在解释器内部的实现方式。例如，对于一个长整形数据，我们在 Python 2 中可以直接写成 a=123456789012345L，而不用去考虑变量 a 占了几个字节。这种抽象的方式为程序的编写提供了足够的支持，但是在某些情况下（比如读写二进制文件，进行网络 Raw Socket 编程）的时候，我们需要一些其他模块来实现我们关于变量长度控制的需求。</p><h1>struct 模块</h1><p>当我们在 Python 中跟二进制数据打交道的时候，就要用到 struct 这个模块了。struct 模块为 Python 与 C 的混合编程，处理二进制文件以及进行网络协议交互提供了便利。理解这个模块主要需要理解三个函数：</p><pre>struct.pack(fmt, v1, v2, ...)struct.unpack(fmt, string)struct.calcsize(fmt)</pre><p>第一个函数 pack 负责将不同的变量打包在一起，成为一个字节字符串，即类似于 C 语言中的字节流。第二个函数 unpack 将字节字符串解包成为变量。第三个函数 calsize 计算按照格式 fmt 打包的结果有多少个字节。这里打包格式 fmt 确定了将变量按照什么方式打包成字节流，其包含了一系列的格式字符串。</p><h1>关于格式字符串</h1><p>在Python手册中，给出了C语言中常用类型与Python类型对应的格式符：</p><div class=pgc-img><img alt=Python标准库之struct onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/db38d9b875564ce8a954592e5c331dc6><p class=pgc-img-caption></p></div><h1>struct.pack(fmt, v1, v2, ...)</h1><blockquote><p>Return a string containing the values v1, v2, ... packed according to the given format. The arguments must match the values required by the format exactly.</p></blockquote><p>struct.pack用于将Python的值根据格式符，转换为字符串,准确来说是Byte。这个地方我们之前有提过，Python3内的unicode和bytes，在Py3内<strong>文本总是Unicode，由str类型表示，二进制数据则由bytes类型表示。</strong><br></p><div class=pgc-img><img alt=Python标准库之struct onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/45bed1546ec140de964da8ce8f509355><p class=pgc-img-caption></p></div><p><br>Py2是没有Byte这么个东西的。参数fmt是格式字符串，v1, v2, ...表示要转换的python值。下面的例子将两个整数转换为字符串:</p><p><br></p><pre>import struct a = 20 b = 400byte = struct.pack("ii", a, b) #转换后的str相当于其他语言中的字节流（字节数组），可以在网络上传输 big = struct.pack("&gt;ii", a, b) #大端保存small = struct.pack("&lt;ii", a, b) #小端保存print(byte)# &gt;&gt;&gt;:b'1400000090010000'print(big)# &gt;&gt;&gt;:b'0000001400000190'print(small)# &gt;&gt;&gt;:b'1400000090010000'print (byte[0],byte[4]) # &gt;&gt;&gt;:b'1400000090010000'</pre><p>格式符"i"表示转换为int，'ii'表示有两个int变量。进行转换后的结果长度为8个字节（int类型占用4个字节，两个int为8个字节）可以看到输出的结果是乱码，因为结果是二进制数据，所以显示为乱码。可以使用python的内置函数repr来获取可识别的字符串 ，以上问题在Python3中不会出现了其中十六进制的0x00000014, 0x00000190分别表示20和400。</p><p>上一段代码<strong>最后那个很有意思诶，竟然是默认采用小端</strong>。</p><p>大端存储和小端存储</p><p>小端：<strong>较高</strong>的有效字节存放在<strong>较高</strong>的存储器地址，<strong>较低</strong>的有效字节存放在<strong>较低</strong>的存储器地址。<br>大端：<strong>较高</strong>的有效字节存放在<strong>较低</strong>的存储器地址，<strong>较低</strong>的有效字节存放在<strong>较高</strong>的存储器地址。</p><p>如果将一个16位的整数0x1234存放到一个短整型变量（short）中。这个短整型变量在内存中的存储在大小端模式由下表所示。</p><p>地址偏移 大端模式 小端模式 0x00 12（OP0） 34（OP1） 0x01 34（OP1） 12（OP0）</p><p>采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。</p><p><br></p><h1>struct.unpack(fmt, buffer)</h1><blockquote><p>Unpack from the buffer buffer (presumably packed by pack(fmt, ...)) according to the format string fmt. The result is a tuple even if it contains exactly one item. The buffer’s size in bytes must match the size required by the format, as reflected by calcsize().</p></blockquote><p>struct.unpack做的工作刚好与struct.pack相反，用于将字节流转换成python数据类型。它的函数原型为：struct.unpack(fmt, string)，该函数返回一个tuple。</p><pre>import structa = struct.pack("2I3sI", 12, 34, "abc", 56)b = struct.unpack("2I3sI", a)print b## 输出 (12, 34, 'abc', 56)</pre><h1>struct.calcsize(fmt)</h1><blockquote><p>Return the size of the struct (and hence of the bytes object produced by pack(fmt, ...)) corresponding to the format string fmt.</p></blockquote><p>struct.calcsize用于计算格式字符串所对应的结果的长度，如：struct.calcsize('ii')，返回8。因为两个int类型所占用的长度是8个字节。</p><h1>使用 struct 打包定长结构</h1><p>一般而言，在使用 struct 的时候，要打包的数据都是定长的。定长的数据代表你需要明确给出要打包的或者解包的数据长度，否则打包解包函数将会出错。下面用例子说明什么是定长打包：</p><pre>import structa = struct.pack("2I3sI", 12, 34, "abc", 56)b = struct.unpack("2I3sI", a)print b## 输出 (12, 34, 'abc', 56)</pre><p>上面的代码将两个整数 12 和 34，一个字符串 “abc” 和一个整数 56 一起打包成为一个字节字符流，然后再解包。其中打包格式中明确指出了打包的长度："2I" 表明起始是两个unsigned int，"3s" 表明长度为4的字符串，最后一个 "I" 表示最后紧跟一个 unsigned int。所以上面的打印 b 输出结果是：(12, 34, ‘abc’, 56)。</p><p>我们可以调用 calcsize() 来计算 "2I3sI" 这个模式占用的字节数：</p><pre>print struct.calcsize("2I3sI")## 输出 16</pre><p>可以看到上面的三个整型加一个 3 字符的字符串一共占用了 16 个字节。为什么会是 16 个字节呢？不应该是 15 个字节吗？其实，在 struct 的打包过程中，根据特定类型的要求，必须进行字节对齐。由于默认 unsigned int 型占用四个字节，因此要在字符串的位置进行4字节对齐，因此即使是 3 个字符的字符串也要占用 4 个字节。</p><p>再看一下不需要字节对齐的模式：</p><pre>print struct.calcsize("2Is")## 输出 9</pre><p>由於单字符出现在两个整型之后，不需要进行字节对齐，所以输出结果是 9.</p><p>需要指出的是，对于 unpack 而言，只要 fmt 对应的字节数和字节字符串 string 的字节数一致，就可以成功的进行解析，否则 unpack 函数将抛出异常。例如我们也可以使用如下的 fmt 解析出 a：</p><pre>c = struct.unpack("2I2sI", a)print struct.calcsize("2I2sI")print c## 输出 16 (12, 34, 'ab', 56)</pre><p>可以看到这里 unpack 解析出了字符串的前两个字符，没有产生任何问题。</p><h1>struct 处理不定长数据</h1><p>我们看到了在使用 pack 和 unpack 的过程中，我们需要明确的指出打包模式中每个位置的长度。比如格式 "2I3sI" 就明确指出了整型的个数和字符串的个数。有时候，我们还可能会需要处理变长的打包数据。</p><p><strong>变长字符串的打包</strong></p><p>例如我们在程序中可能会得到一个字符串 s，这个 s 没有一个固定的长度，所以我们每次打包的时候都需要将 s 的长度也打包到一起，这样我们才能进行正确的解包。其实，这种情况在处理网络数据包中非常常见。在使用网络编程的时候，我们可能利用报文的第一个字段记录报文的长度。每次读取报文的时候，我们先读取报文的第一个字段，获取其长度之后在处理报文内容。</p><p>我们可以采用两种方式处理这种情况：</p><pre>s = bytes(s, 'utf-8') # Or other appropriate encodingstruct.pack("I%ds" % (len(s),), len(s), s)</pre><p>或者</p><pre>struct.pack("I", len(s)) + s</pre><p>第一种方式先将报文转变成为字节码，然后获取字节码的长度，将长度嵌入到打包之后的报文中去。可以看到格式字符串中的 "I" 就用来记录报文的长度。第二种方式是直接将字符串的长度打包成字节字符串，再跟原始字符串做一个连接操作。</p><p>变长字符串的解包</p><p>根据上面的打包方式，我们可以轻松的解开打包串：</p><pre>int_size = struct.calcsize("I")(i,), data = struct.unpack("I", data[:int_size]), data[int_size:]data_content = data[i:]</pre><p>由于报文的长度 len(s) 我们使用定长的整型 "I" 进行了打包，所以解包的时候我们可以先将报文长度获取出来，之后再根据报文长度读取报文内容。</p><h1>实现简单的自定义协议数据传输<br></h1><p>工作曾曾遇到过一个需要后端服务生成多整图片，返回给前端js使用, 第一方案是使用base64把图片二进制文件转换成字符串，打包返回给前端使用，私有协议分三段如下：</p><div class=pgc-img><img alt=Python标准库之struct onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed0f5964072d44e2a55b53e8b15f40db><p class=pgc-img-caption></p></div><p>例如：3L80205_768037_128848base64strs</p><p>可以端通过解析返回的数据头信息，获取图片数据，根据长度读取二进制长度生成多张图片，但在实际应用中发现，经过base64编码的二进制文件，文件大小增加了30%-50%，造成了不必要的网络开销，后经过优化，直接使用二进制传输文件，核心代码如下：</p><div class=pgc-img><img alt=Python标准库之struct onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d247a8f1ca7a4859ba832c4fba740190><p class=pgc-img-caption></p></div><p>以上就是对使用struct进行数据打包，实现了简易版的ziplist的功能。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Python','标准库','struct'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>