<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>计算机通信之谜，带你彻底理解socket网络编程（一） | 极客快訊</title><meta property="og:title" content="计算机通信之谜，带你彻底理解socket网络编程（一） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c2b2caf6f97d420e9da2d36b5464072b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><meta property="article:published_time" content="2020-10-29T21:10:18+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:18+08:00"><meta name=Keywords content><meta name=description content="计算机通信之谜，带你彻底理解socket网络编程（一）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3e8892b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>计算机通信之谜，带你彻底理解socket网络编程（一）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">出现一项技术，首先我们弄懂一下，为什么要出现。那么为什么要出现socket这玩意呢？可以很简单的用一句话来概括：</span></p><blockquote><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">为了实现两台计算机的通信</span></span></p></blockquote><div class=pgc-img><img alt=计算机通信之谜，带你彻底理解socket网络编程（一） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2b2caf6f97d420e9da2d36b5464072b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1、socket诞生的原因</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">两台装有操作系统的机子要想实现通信，第一要联网，第二通信双方一定制定某种规则。我们平时最为常见的http请求也是一种通信协议，只不过它是属于应用层的。http协议将要发送的数据封装后，传到下面一层处理，这下一层就是传输层，也是我们今天要说的重点。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">应用层的数据封装之后要发到下面的传输层，那么传输层就需要对外提供接口，让应用层可以调用传输层的数据，这个就是socket。传输层就是通过socket来对外提供服务的，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">毫不夸张的说，socket是计算机通信的基石</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，任何两台计算机要想实现通信，必须要有socket。传输层是在操作系统层面，socket的实现细节是操作系统已经封装好的了。所以聪明的你可能已经知道了，不同的操作系统实现的socket各不相同，对外提供的函数可能也有点不同。我们这里讨论的都是Linux系统。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2、服务端和客户端的代码实现</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其他的先不说，我们先给出服务端和客户端的代码，然后通过代码来分析两台主机通信之间的过程。这个代码已经在Linux上运行过了，完全可以使用，大家需要的话可以直接拿去用。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.1、服务端代码</span></h1><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt; #define BUF_SIZE 512#define ERR_EXIT(m)         \	do                      \	{                       \		perror(m);          \		exit(EXIT_FAILURE); \	} while (0) int main(){	//创建套接字	int m_sockfd = socket(AF_INET, SOCK_STREAM, 0);	if (m_sockfd &lt; 0)	{		ERR_EXIT("create socket fail");	} 	//初始化socket元素	struct sockaddr_in server_addr;	int server_len = sizeof(server_addr);	memset(&amp;server_addr, 0, server_len); 	server_addr.sin_family = AF_INET;	//server_addr.sin_addr.s_addr = inet_addr("0.0.0.0"); //用这个写法也可以	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(39002); 	//绑定文件描述符和服务器的ip和端口号	int m_bindfd = bind(m_sockfd, (struct sockaddr *)&amp;server_addr, server_len);	if (m_bindfd &lt; 0)	{		ERR_EXIT("bind ip and port fail");	} 	//进入监听状态，等待用户发起请求	int m_listenfd = listen(m_sockfd, 20);	if (m_listenfd &lt; 0)	{		ERR_EXIT("listen client fail");	} 	//定义客户端的套接字，这里返回一个新的套接字，后面通信时，就用这个m_connfd进行通信	struct sockaddr_in client_addr;	socklen_t client_len = sizeof(client_addr);	int m_connfd = accept(m_sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_len); 	//接收客户端数据，并相应	char buffer[BUF_SIZE];	recv(m_connfd, buffer, sizeof(buffer), 0);	printf("server recv:%s\n", buffer);	strcat(buffer, "+ACK");	send(m_connfd, buffer, sizeof(buffer), MSG_NOSIGNAL); 	//关闭套接字	close(m_connfd);	close(m_sockfd); 	return 0;}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2、客户端代码</span></h1><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt; #define BUF_SIZE 512#define ERR_EXIT(m)         \	do                      \	{                       \		perror(m);          \		exit(EXIT_FAILURE); \	} while (0) int main(){	//创建套接字	int m_sockfd = socket(AF_INET, SOCK_STREAM, 0);	if (m_sockfd &lt; 0)	{		ERR_EXIT("create socket fail");	} 	//服务器的ip为本地，端口号	struct sockaddr_in server_addr;	memset(&amp;server_addr, 0, sizeof(server_addr));	server_addr.sin_family = AF_INET;	server_addr.sin_addr.s_addr = inet_addr("81.68.140.74");	server_addr.sin_port = htons(39002); 	//向服务器发送连接请求	int m_connectfd = connect(m_sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));	if (m_connectfd &lt; 0)	{		ERR_EXIT("connect server fail");	}	//发送并接收数据	char buffer[BUF_SIZE];	printf("client send:");	scanf("%s", buffer);	send(m_sockfd, buffer, sizeof(buffer), 0);	recv(m_sockfd, buffer, sizeof(buffer), 0);	printf("client recv:%s\n", buffer); 	//断开连接	close(m_sockfd); 	return 0;}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以上就是服务端和客户端的代码，</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">这个代码本身没问题，但是有点小缺点</span>，最后我们会提到。接着笔者分析一下上面的所有socket相关函数，让大家可以更加深刻的了解socket网络编程。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3、socket的基本操作</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">既然socket是“open—write/read—close”模式的一种实现，那么socket就提供了这些操作对应的函数接口。下面介绍几个基本的socket接口函数。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.1、socket()函数</span></h1><pre><code>int socket(int domain, int type, int protocol);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">socket函数对应于普通文件的打开操作，普通文件的打开操作返回一个文件描述字，而</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">socket()</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用于创建一个socket描述符（socket descriptor），它唯一标识一个socket。这个socket描述字跟文件描述字一样，后续的操作都有用到它，把它作为参数，通过它来进行一些读写操作。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">正如可以给fopen的传入不同参数值，以打开不同的文件。创建socket的时候，也可以指定不同的参数创建不同的socket描述符，socket函数的三个参数分别为：</span></p><ul><li>domain：即协议域，又称为协议族（family）。常用的协议族有，AF_INET、AF_INET6、AF_LOCAL（或称AF_UNIX，Unix与socket）、AF_ROUTE等等。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET决定了要用ipv4地址（32位的）与端口号（16位的）的组合、AF_UNIX决定了要用一个绝对路径名作为地址。</li><li>type：指定socket类型。常用的socket类型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议<span style="color:#f33b45;--tt-darkmode-color: #F33B45">（后面两种在网络编程当中很少见到，大家不需要深究）</span></li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当我们调用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">socket</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">创建一个socket时，返回的socket描述字它存在于协议族（address family，AF_XXX）空间中，但没有一个具体的地址。如果想要给它复制一个地址，就必须调用bind()函数，否则就当调用connect()、listen()时系统会自动随机分配一个端口。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.2、bind()函数</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">正如上面所说bind()函数把一个地址族中的特定地址赋给socket。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</span></p><pre><code>int bind(int sockfd, const struct sockaddr *addr, int addrlen);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">函数的三个参数分别为：</span></p><ul><li>sockfd：即socket描述字，它是通过socket()函数创建了，唯一标识一个socket。bind()函数就是将给这个描述字绑定一个名字。</li><li>addr：一个const struct sockaddr *指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同。</li><li>addrlen：对应的是地址的长度。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">下面是一个bind()函数的例子，希望大家可以理解这个用法</span></p><pre><code>    struct sockaddr_in server_addr;	int server_len = sizeof(server_addr);	memset(&amp;server_addr, 0, server_len); 	server_addr.sin_family = AF_INET;	//server_addr.sin_addr.s_addr = inet_addr("0.0.0.0"); //用这个写法也可以	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(39002); 	//绑定文件描述符和服务器的ip和端口号	int m_bindfd = bind(m_sockfd, (struct sockaddr *)&amp;server_addr, server_len);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通常服务器在启动的时候都会绑定一个众所周知的地址（如ip地址+端口号），用于提供服务，客户就可以通过它来接连服务器；而客户端就不用指定，有系统自动分配一个端口号和自身的ip地址组合。这就是为什么通常服务器端在listen之前会调用bind()，而客户端就不会调用，而是在connect()时由系统随机生成一个。</span></p><blockquote><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">网络字节序与主机字节序</span></span></p><p><strong><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">主机字节序</span></strong><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">就是我们平常说的大端和小端模式：不同的CPU有不同的字节序类型，这些字节序是指整数在内存中保存的顺序，这个叫做主机序。引用标准的Big-Endian和Little-Endian的定义如下：</span></p><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">　　a) Little-Endian就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</span></span></p><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">　　b) Big-Endian就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。</span></span></p><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">网络字节序</span></span></strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">：4个字节的32 bit值以下面的次序传输：首先是0～7bit，其次8～15bit，然后16～23bit，最后是24~31bit。这种传输次序称作大端字节序。</span></span><strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">由于TCP/IP首部中所有的二进制整数在网络中传输时都要求以这种次序，因此它又称作网络字节序。</span></span></strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序，一个字节的数据没有顺序的问题了。</span></span></p><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">所以：在将一个地址绑定到socket的时候，请先将主机字节序转换成为网络字节序，而不要假定主机字节序跟网络字节序一样使用的是Big-Endian。由于这个问题曾引发过血案！公司项目代码中由于存在这个问题，导致了很多莫名其妙的问题，所以请谨记对主机字节序不要做任何假定，务必将其转化为网络字节序再赋给socket。</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.3、listen()</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果作为一个服务器，在调用socket()、bind()之后就会调用listen()来监听这个socket。</span></p><pre><code>int listen(int sockfd, int backlog);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">listen函数的第一个参数即为要监听的socket描述字，</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">就是上面创建的那个socket()函数的返回值。</span>第二个参数为相应socket可以排队的最大连接个数，<span style="color:#f33b45;--tt-darkmode-color: #F33B45">可以理解为有多少个客户端连接。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：socket()函数创建的socket默认是一个主动类型的，listen函数将socket变为被动类型的，等待客户的连接请求。listen()如果返回 –1 ，那么说明在listen()的执行过程中发生了错误。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.4、connect()函数</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">客户端通过调用connect函数来建立与TCP服务器的连接，connect()函数结构如下</span></p><pre><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">connect函数的第一个参数即为客户端的socket描述字，就是上面客户端创建的socket()函数的返回值，一般都是大于0的。第二参数为服务器的socket地址，是一个存储远程计算机的IP地址和端口信息的结构，一般为服务器的ip与port。第三个参数为socket地址的长度，这里addrlen=sizeof(addr)。</span></p><p style=text-align:start><span style="color:#f33b45;--tt-darkmode-color: #F33B45">注意：这里的远程服务端的端口一定要设置好，千万不要设置了被服务器防火墙拦截的端口。之前我就是一直无法连接，后面查询才知道，我设置的端口被服务器防火墙给拦截了。切记切记！！！</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.4、accept()函数</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TCP服务器端依次调用socket()、bind()、listen()之后，就会监听指定的socket地址了。TCP客户端依次调用socket()、connect()之后就向TCP服务器发送了一个连接请求。TCP服务器监听到这个请求之后，就会调用accept()函数去接收请求，这样连接就建立好了。之后就可以开始网络I/O操作了，即类同于普通文件的读写I/O操作。</span></p><pre><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">accept函数的第一个参数为服务器的socket描述字，第二个参数为指向struct sockaddr *的指针，用于返回客户端的协议地址，第三个参数为协议地址的长度，</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">要注意这个长度的类型是socklen_t，不可写成int。</span>如果accpet成功，那么其返回值是由内核自动生成的一个全新的描述字，代表与返回客户的TCP连接。</p><pre><code>//定义客户端的套接字，这里返回一个新的套接字，后面通信时，就用这个m_connfd进行通信	struct sockaddr_in client_addr;	socklen_t client_len = sizeof(client_addr);	int m_connfd = accept(m_sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_len);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：accept的第一个参数为服务器的socket描述字，是服务器开始调用socket()函数生成的，称为监听socket描述字；而accept函数返回的是已连接的socket描述字。一个服务器通常通常仅仅只创建一个监听socket描述字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建了一个已连接socket描述字，当服务器完成了对某个客户的服务，相应的已连接socket描述字就被关闭。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.5、read()、write()等函数</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">到了这里，服务器与客户已经建立好连接了。建立连接之后，我们就是发送通过客户端发送数据给服务端，当然也可以服务端发过来。因为TCP连接是全双工的。用以下函数可以实现了网网络中不同进程之间的通信！网络I/O操作有下面几组：</span></p><pre><code>read()/write()recv()/send()readv()/writev()recvmsg()/sendmsg()recvfrom()/sendto()</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">笔者这里经常用的是read()/write()和recv()/send这两组函数，当然其他的也是可以的。具体有啥区别，我也没有太多的去深究。有兴趣的同学可以去了解了解。</span></p><pre><code>#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); #include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,			  const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,				struct sockaddr *src_addr, socklen_t *addrlen); ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">read函数是负责从fd中读取内容。当读成功时，read返回实际所读的字节数，如果返回的值是0表示已经读到文件的结束了，小于0表示出现了错误。如果错误为EINTR说明读是由中断引起的，如果是ECONNREST表示网络连接出了问题。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">write函数将buf中的nbytes字节内容写入文件描述符fd。成功时返回写的字节数，失败时返回-1，并设置errno变量。 在网络程序中，当我们向套接字文件描述符写时有两种可能。1)write的返回值大于0，表示写了部分或者是全部的数据。2)返回的值小于0，此时出现了错误。我们要根据错误类型来处理。如果错误为EINTR表示在写的时候出现了中断错误。如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.6、close()函数</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在服务器与客户端建立连接之后，会进行一些读写操作，完成了读写操作就要关闭相应的socket描述字，好比操作完打开的文件要调用fclose关闭打开的文件。</span></p><pre><code>#include &lt;unistd.h&gt;int close(int fd);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">该函数的参数就是上面创建的socket的返回值，该描述字不能再由调用进程使用，也就是说不能再作为read或write的第一个参数。至此，socket就会关闭，连接断掉，不能再进行通信了。</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">我们熟知的http协议，每次请求之后都会断开，就是调用了这个close()函数的原因。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：close操作只是使相应socket描述字的引用计数-1，只有当引用计数为0的时候，才会触发TCP客户端向服务器发送终止连接请求。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">4、代码的缺陷</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以上服务端和客户端的代码是socket通信中最基础的，就是说要想实现两台计算机通信，以上函数都是必须的。但是如果大家有去运行以上代码的话就会发现，启动服务端后，在启动客户端，这时候只是运行一次，客户端和服务端就都close()退出了，也就是说长连接断掉了，这显然不符合实际的使用情况。我们需要的是源源不断的可以发送数据，那么以上代码如何改呢？大家可以思考思考。</span></p><div class=pgc-img><img alt=计算机通信之谜，带你彻底理解socket网络编程（一） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/08bbda53ce134f6caa4e3fb87d2e0a83><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=计算机通信之谜，带你彻底理解socket网络编程（一） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34f347de8edb48d8ac8c070a54bb15c7><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'计算机','彻底','socket'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>