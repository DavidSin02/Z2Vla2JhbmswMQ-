<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA线程安全及性能的优化笔记(三)——Volatile关键字 | 极客快訊</title><meta property="og:title" content="JAVA线程安全及性能的优化笔记(三)——Volatile关键字 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/62d649c2284b437aa978f17b98b38630"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f0ff269.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f0ff269.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="JAVA线程安全及性能的优化笔记(三)——Volatile关键字"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3f0ff269.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA线程安全及性能的优化笔记(三)——Volatile关键字</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前期回顾：</h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6812853871497445899/?group_id=6812853871497445899" rel="noopener noreferrer" target=_blank>JAVA线程安全及性能的优化笔记(二)——Synchronized关键字</a></p><hr><h1 class=pgc-h-arrow-right>本期正文：</h1><p>volatile是java提供的一种同步手段，只不过它是轻量级的同步，为什么这么说？因为volatile只能保证多线程的内存可见性，不能保证多线程的执行有序性。而最彻底的同步要保证有序性和可见性，例如synchronized。任何被volatile修饰的变量，都不拷贝副本到工作内存，任何修改都能及时写在主存。因此对于valatile修饰的变量的修改，所有线程马上就能看到，但是volatile不能保证对变量的修改时有序的。什么意思呢？</p><pre><code>publicclassVolatileTest{	publicvolatileinta;	publicvoidadd(intcount){		a=a+count;	}}</code></pre><p>当一个VolatileTest对象被多个线程共享，a的值不一定是正确的，因为a=a+count包含了好几部操作，而此时多个线程的执行是无序的，因为没有任何机制来保证多个线程的执行有序性和原子性。volatile存在的意义是，任何线程对a的修改，都会马上被其他线程读取到，因为直接操作主存，没有线程对工作内存和主存的同步。所以，volatile的使用场景是有限的，在有限的一些情况下可以使用volatile变量代替锁。要使用volatile变量提供理想的线程安全，必须同时满足下面两个条件：</p><ol start=1><li>对变量的写操作不依赖于当前值</li><li>该变量没有包含在具有其他变量的不变式中</li></ol><p>volatile只保证了可见性，所以volatile适合直接赋值的场景。</p><pre><code>publicclassVolatileTest{	publicvolatileinta;	publicvoidseta(inta){		this.a=a;	}}</code></pre><p>在没有volatile声明时，多线程环境下，a的最终值不一定是正确的，因为this.a=a;涉及到给a赋值和将a同步回主存的步骤，这个顺序可能被打乱。如果用volatile声明了，读取主存副本到工作内存和同步a到主存的步骤，相当于是一个原子操作。所以简单来说，volatile适合这种场景：一个变量被多个线程共享，线程直接给这个变量赋值。这是一种很简单的同步场景，这时候使用volatile的开销将会非常小。</p><p>站内很多人都问我，所谓线程的“工作内存”到底是个什么东西？有的人认为是线程的栈，其实这种理解是不正确的。看看JLS(java语言规范)对线程工作内存的描述，线程的workingmemory只是cpu的寄存器和告诉缓存的抽象描述。</p><p>可能很多人都觉得莫名其妙，说JVM的内存模型，怎么会扯到cpu上去呢？此时，我认为很有必要阐述下，免得很多人看的不明不白的。先抛开java虚拟机不谈，我们都知道，现在的计算机，cpu在计算的时候，并不总是从内存读取数据，它的数据读取顺序优先级是：寄存器—高速缓存—内存。线程消耗的是cpu，线程计算的时候，原始的数据来自内存，在计算过程中，有些数据可能被频繁读取，这些数据被存储在寄存器和高速缓存中，当线程计算完后，这些缓存的数据在适当的时候应该写会内存。当多个线程同时读写某个内存数据时，就会产生多线程并发问题，涉及到三个特征：原子性，有序性，可见性。在《线程安全总结》这篇文章中，为了理解方便，我把原子性和有序性统一叫做“多线程执行有序性”。支持多线程的平台都会面临这种问题，运行在多线程平台上支持多线程的语言应该提供解决该问题的方案。</p><p>那么我们看看JVM，JVM是一个虚拟的计算机，它也会面临多线程并发问题，java程序运行在虚拟机平台上，java程序员不可能直接去控制底层线程对寄存器高速缓存内存之间的同步，那么java从语法层面，应该给开发人员提供一种解决方案，这个方案就是诸如synchronized，volatile，锁机制(如同步块，就绪队列，阻塞队列)等等。这些方案只是语法层面的，但我们要从本质上去理解它，不能仅仅知道一个synchronized可以保证同步就完了。在这里我说的是jvm的内存模型，是动态的，面向多线程并发的，沿袭JSL的”workingmemory”的说法，只是不想闲扯到太多底层细节，因为《线程安全总结》这篇文章在说明怎样从语法层而去理解java线程同步，知道各个关键字的使用场景。</p><p>今天有人问我，那java的线程不是有栈吗？难道栈不是工作内存吗？工作内存这四个字得放到具体的场景中区描述，方能体现它具体的意义，在描述JVM的线程同步时，工作内存指的是寄存器和高速缓存的抽象描述，具体请自行参阅JLS。上面讲的都是动态的内存模型，甚至已经超出了JVM的范围，那么JVM的内存静态存储是怎样划分的？今天还有人问我，jvm的内存模型不是有eden区吗？也不见得你提起。我跟他说，这是两个角度去看的，甚至是不同的范围，动态的线程同步的内存模型，涵盖了cpu，寄存器，高速缓存，内存；jvm的静态内存存储模型只是一种对内存的物理划分而已，它只局限在内存，而且只局限在jvm的内存。那么线程栈，eden区都仅仅在jvm内存。</p><p>说说jvm的线程栈和有个朋友反复跟我纠结的eden区吧。jvm的内存，被划分了很多的区域</p><p><strong>1. 程序计数器</strong></p><p>每一个java线程都有一个线程计数器来用于保存程序执行到当前方法的哪一个指令。</p><p><strong>2. 线程栈</strong></p><p>线程的每个方法被执行的时候，都会同时创建一个帧(Frame)</p><p>用于存储本地变脸表、操作栈、动态链接、方法出入口等信息。每个方法的调用至完成，就意味着一个帧在VM栈中的入栈至出栈的过程。如果线程请求的栈深度大于虚拟机所允许的深度，讲抛出StackOverflowError异常；如果VM栈可以动态扩展（VMSpec中允许固定长度的VM栈），当扩展时无法申请到足够内存则抛出OutOfMemoryError异常。</p><p><strong>3. 本地方法栈</strong></p><p><strong>4. 堆</strong></p><p>每个线程的栈都是该线程私有的，堆则是所有线程共享的。当我们new一个对象时，该对象就被分配到了堆中。但是堆，并不是一个简单的概念，堆区又划分了很多区域，问为什么堆划分了这么多区域，这是为了JVM的内存垃圾收集，似乎越扯越远了，扯到垃圾收集了，现在的jvm的gc都是按代收集，堆区大致被分为三大块：新生代、旧生代、持久代(虚拟的)；新生代又分为eden区，s0区，s1区。新建一个对象时，基本小的对象，生命周期短的对象都会放在新生代的eden区中，eden区满时，有一个小范围的gc(minorgc)，整个新生代满时，会有一个大范围的gc(majorgc)，讲新生代里的部分对象转到旧生代里。</p><p><strong>5. 方法区</strong></p><p>其实就是永久代(PermanentGeneration)，方法区中存放了每个Class的结构信息，包括常量池、字段描述、方法描述等等。VMSpace描述中对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存，也可以选择固定大小或者可扩展外，甚至可以选择不现实垃圾收集。相对来说，垃圾收集行为在这个区域是相对比较少发生的，但并不是某些描述那样永久代不会发生GC(至少对当前主流的商业JVM实现来说是如此)，这里的GC主要是对常量池的回收和对类的卸载，虽然回收的”成绩”一般也比较差强人意，尤其是类卸载，条件相当苛刻</p><p><strong>6. 常量池</strong></p><p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量表(constant_pooltable)，用于存放编译期已可知的常量，这部分内容将在类加载后进入方法区(永久代)存放。但是Java语言并不要求常量一定只有编译期预置入Class的常量表的内容才能进入方法区常量池，运行期间也可将新内容放入常量池(最典型的String.intern()方法)</p><h1 class=pgc-h-arrow-right>未完待续</h1><p><strong>推荐阅读：</strong><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6811403312651305483/?group_id=6811403312651305483" rel="noopener noreferrer" target=_blank>阿里8年Java架构师感悟——写给还在迷茫中的朋友</a></p><li><strong>针对于Java程序员，笔者最近整理了一些面试真题，思维导图，程序人生等PDF学习资料；</strong></li><li><strong>关注私信我"86"，即可获取！</strong></li><li><strong>希望读到这的您能点个小赞和关注下我，以后还会更新技术干货，谢谢您的支持！</strong></li><div class=pgc-img><img alt=JAVA线程安全及性能的优化笔记(三)——Volatile关键字 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62d649c2284b437aa978f17b98b38630><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JAVA','线程','优化'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>