<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用Spring进行面向切面编程（AOP） | 极客快訊</title><meta property="og:title" content="使用Spring进行面向切面编程（AOP） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/b09bdd90d1394d74a47e1c0363fd950a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="使用Spring进行面向切面编程（AOP）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3f29dcd0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用Spring进行面向切面编程（AOP）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=使用Spring进行面向切面编程（AOP） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b09bdd90d1394d74a47e1c0363fd950a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>前言</h1><p>面向切面编程（AOP）提供另外一种角度来思考程序结构，通过这种方式弥补了面向对象编程（OOP）的不足。 除了类（classes）以外，AOP提供了 切面。切面对关注点进行模块化，例如横切多个类型和对象的事务管理。 （这些关注点术语通常称作 横切（crosscutting） 关注点。）</p><p>Spring的一个关键的组件就是 AOP框架。 尽管如此，Spring IoC容器并不依赖于AOP，这意味着你可以自由选择是否使用AOP，AOP提供强大的中间件解决方案，这使得Spring IoC容器更加完善。</p><h1 class=pgc-h-arrow-right>Spring 2.0 AOP</h1><p>Spring 2.0 引入了一种更加简单并且更强大的方式来自定义切面，用户可以选择使用基于模式（schema-based）的方式或者使用@AspectJ注解。 这两种风格都完全支持通知（Advice）类型和AspectJ的切入点语言，虽然实际上仍然使用Spring AOP进行织入（Weaving）。</p><p>本章主要讨论Spring 2.0对基于模式和基于@AspectJ的AOP支持。请查阅"AOP声明风格的选择"一节获取 为你的应用选择适当的声明风格的建议。Spring 2.0完全保留了对Spring 1.2的向下兼容性，下一章 将讨论 Spring 1.2 API所提供的底层的AOP支持。</p><p>Spring中所使用的AOP：提供声明式企业服务，特别是为了替代EJB声明式服务。 最重要的服务是 声明性事务管理（declarative transaction management） ， 这个服务建立在Spring的抽象事务管理（transaction abstraction）之上。</p><p>允许用户实现自定义的切面，用AOP来完善OOP的使用。</p><p>这样你可以把Spring AOP看作是对Spring的一种增强，它使得Spring可以不需要EJB就能提供声明式事务管理； 或者也可以使用Spring AOP框架的全部功能来实现自定义的切面。</p><p>本章首先 介绍了AOP的概念，无论你打算采用哪种风格的切面声明，这个部分都值得你一读。 本章剩下的部分将着重于Spring 2.0对AOP的支持； 下一章 提供了关于Spring 1.2风格的AOP概述，也许你已经在其他书本，文章以及已有的应用程序中碰到过这种AOP风格。 如果你只打算使用通用的声明式服务或者预先打包的声明式中间件服务，例如缓冲池（pooling）， 那么你不必直接使用Spring AOP，而本章的大部分内容也可以直接跳过。</p><p><strong>1. AOP概念</strong></p><p>首先让我们从定义一些重要的AOP概念开始。这些术语不是Spring特有的。 不幸的是，AOP术语并不是特别的直观；如果Spring使用自己的术语，将会变得更加令人困惑。 切面（Aspect）： 一个关注点的模块化，这个关注点可能会横切多个对象。事务管理是J2EE应用中一个关于横切关注点的很好的例子。 在Spring AOP中，切面可以使用通用类（基于模式的风格） 或者在普通类中以 @Aspect 注解（@AspectJ风格）来实现。</p><ul><li><strong>连接点（Joinpoint）</strong>： 在程序执行过程中某个特定的点，比如某方法调用的时候或者处理异常的时候。 在Spring AOP中，一个连接点 总是 代表一个方法的执行。 通过声明一个org.aspectj.lang.JoinPoint类型的参数可以使通知（Advice）的主体部分获得连接点信息。</li><li><strong>通知（Advice）</strong>： 在切面的某个特定的连接点（Joinpoint）上执行的动作。通知有各种类型，其中包括“around”、“before”和“after”等通知。 通知的类型将在后面部分进行讨论。许多AOP框架，包括Spring，都是以拦截器做通知模型， 并维护一个以连接点为中心的拦截器链。</li><li><strong>切入点（Pointcut）</strong>： 匹配连接点（Joinpoint）的断言。通知和一个切入点表达式关联，并在满足这个切入点的连接点上运行（例如，当执行某个特定名称的方法时）。 切入点表达式如何和连接点匹配是AOP的核心：Spring缺省使用AspectJ切入点语法。</li><li><strong>引入（Introduction）</strong>： （也被称为内部类型声明（inter-type declaration））。声明额外的方法或者某个类型的字段。 Spring允许引入新的接口（以及一个对应的实现）到任何被代理的对象。 例如，你可以使用一个引入来使bean实现 IsModified 接口，以便简化缓存机制。</li><li><strong>目标对象（Target Object）</strong>： 被一个或者多个切面（aspect）所通知（advise）的对象。也有人把它叫做 被通知（advised） 对象。 既然Spring AOP是通过运行时代理实现的，这个对象永远是一个 被代理（proxied） 对象。</li><li><strong>AOP代理（AOP Proxy）</strong>： AOP框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。 注意：Spring 2.0最新引入的基于模式（schema-based）风格和@AspectJ注解风格的切面声明，对于使用这些风格的用户来说，代理的创建是透明的。</li><li><strong>织入（Weaving）</strong>： 把切面（aspect）连接到其它的应用程序类型或者对象上，并创建一个被通知（advised）的对象。 这些可以在编译时（例如使用AspectJ编译器），类加载时和运行时完成。 Spring和其他纯Java AOP框架一样，在运行时完成织入。 通知的类型：前置通知（Before advice）： 在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li><strong>返回后通知（After returning advice）</strong>： 在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回。</li><li><strong>抛出异常后通知（After throwing advice）</strong>： 在方法抛出异常退出时执行的通知。</li><li><strong>后通知（After (finally) advice）</strong>： 当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）。</li><li><strong>环绕通知（Around Advice）</strong>： 包围一个连接点（join point）的通知，如方法调用。这是最强大的一种通知类型。 环绕通知可以在方法调用前后完成自定义的行为。它也会选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</li></ul><p>环绕通知是最常用的一种通知类型。大部分基于拦截的AOP框架，例如Nanning和JBoss4，都只提供环绕通知。</p><p>跟AspectJ一样，Spring提供所有类型的通知，我们推荐你使用尽量简单的通知类型来实现需要的功能。 例如，如果你只是需要用一个方法的返回值来更新缓存，虽然使用环绕通知也能完成同样的事情， 但是你最好使用After returning通知而不是环绕通知。 用最合适的通知类型可以使得编程模型变得简单，并且能够避免很多潜在的错误。 比如，你不需要调用 JoinPoint（用于Around Advice）的 proceed() 方法，就不会有调用的问题。</p><p>在Spring 2.0中，所有的通知参数都是静态类型，因此你可以使用合适的类型（例如一个方法执行后的返回值类型）作为通知的参数而不是使用一个对象数组。</p><p>切入点（pointcut）和连接点（join point）匹配的概念是AOP的关键，这使得AOP不同于其它仅仅提供拦截功能的旧技术。 切入点使得定位通知（advice）可独立于OO层次。 例如，一个提供声明式事务管理的around通知可以被应用到一组横跨多个对象中的方法上（例如服务层的所有业务操作）。</p><p><strong>2. Spring AOP的功能和目标</strong></p><p>Spring AOP用纯Java实现。它不需要专门的编译过程。Spring AOP不需要控制类装载器层次，因此它适用于J2EE web容器或应用服务器。</p><p>Spring目前仅支持使用方法调用作为连接点（join point）（在Spring bean上通知方法的执行）。 虽然可以在不影响到Spring AOP核心API的情况下加入对成员变量拦截器支持，但Spring并没有实现成员变量拦截器。 如果你需要把对成员变量的访问和更新也作为通知的连接点，可以考虑其它语法的Java语言，例如AspectJ。</p><p>Spring实现AOP的方法跟其他的框架不同。Spring并不是要尝试提供最完整的AOP实现（尽管Spring AOP有这个能力）， 相反的，它其实侧重于提供一种AOP实现和Spring IoC容器的整合，用于帮助解决在企业级开发中的常见问题。</p><p>因此，Spring AOP通常都和Spring IoC容器一起使用。 Aspect使用普通的bean定义语法（尽管Spring提供了强大的“自动代理（autoproxying）”功能）： 与其他AOP实现相比这是一个显著的区别。有些事使用Spring AOP是无法轻松或者高效的完成的，比如说通知一个细粒度的对象。 这种时候，使用AspectJ是最好的选择。不过经验告诉我们： 于大多数在J2EE应用中遇到的问题，只要适合AOP来解决的，Spring AOP都没有问题，Spring AOP提供了一个非常好的解决方案。</p><p>Spring AOP从来没有打算通过提供一种全面的AOP解决方案来取代AspectJ。 我们相信无论是基于代理（proxy-based ）的框架比如说Spring亦或是full-blown的框架比如说是AspectJ都是很有价值的，他们之间的关系应该是互补而不是竞争的关系。 Spring 2.0可以无缝的整合Spring AOP，IoC 和AspectJ，使得所有的AOP应用完全融入基于Spring的应用体系。 这样的集成不会影响Spring AOP API或者AOP Alliance API；Spring AOP保留了向下兼容性。接下来的一章会详细讨论Spring AOP API。</p><p><strong>3. Spring的AOP代理</strong></p><p>Spring缺省使用J2SE 动态代理（dynamic proxies）来作为AOP的代理。这样任何接口都可以被代理。</p><p>Spring也支持使用CGLIB代理. 对于需要代理类而不是代理接口的时候CGLIB代理是很有必要的。 如果一个业务对象并没有实现一个接口，默认就会使用CGLIB。 作为面向接口编程的最佳实践，业务对象通常都会实现一个或多个接口。但也有可能会 强制使用CGLIB， 在这种情况（希望不常有）下，你可能需要通知一个没有在接口中声明的方法，或者需要传入一个代理对象给方法作为具体类型在Spring 2.0之后，Spring可能会提供多种其他类型的AOP代理，包括了完整的生成类。这不会影响到编程模型。</p><p><strong>4. @AspectJ支持</strong></p><p>"@AspectJ"使用了Java 5的注解，可以将切面声明为普通的Java类。 AspectJ 5发布的 AspectJ project 中引入了这种@AspectJ风格。 Spring 2.0 使用了和AspectJ 5一样的注解，使用了AspectJ 提供的一个库来做切点（pointcut）解析和匹配。 但是，AOP在运行时仍旧是纯的Spring AOP，并不依赖于AspectJ 的编译器或者织入器（weaver）。 使用AspectJ的编译器或者织入器（weaver）的话就可以使用完整的AspectJ 语言，我们将在 Section 6.8, “在Spring应用中使用AspectJ” 中讨论这个问题。</p><p><strong>5. 启用@AspectJ支持</strong></p><p>为了在Spring配置中使用@AspectJ aspects，你必须首先启用Spring对基于@AspectJ aspects的配置支持，自动代理（autoproxying）基于通知是否来自这些切面。 自动代理是指Spring会判断一个bean是否使用了一个或多个切面通知，并据此自动生成相应的代理以拦截其方法调用，并且确认通知是否如期进行。</p><p>通过在你的Spring的配置中引入下列元素来启用Spring对@AspectJ的支持：</p><p>我们假使你正在使用 Appendix A, XML Schema-based configuration 所描述的schema支持。</p><p>如果你正在使用DTD，你仍旧可以通过在你的application context中添加如下定义来启用@AspectJ支持：</p><p>你需要在你的应用程序的classpath中引入两个AspectJ库：aspectjweaver.jar 和 aspectjrt.jar。 这些库可以在AspectJ的安装包（1.5.1或者之后的版本）中的 lib 目录里找到，或者也可以在Spring依赖库的 lib/aspectj 目录下找到。</p><p><strong>6. 声明一个切面</strong></p><p>在启用@AspectJ支持的情况下，在application context中定义的任意带有一个@Aspect切面（拥有@Aspect注解）的bean都将被Spring自动识别并用于配置在Spring AOP。 以下例子展示了为了完成一个不是非常有用的切面所需要的最小定义：</p><p>下面是在application context中的一个常见的bean定义，这个bean指向一个使用了 @Aspect 注解的bean类：</p><p>下面是 NotVeryUsefulAspect 类定义，使用了 org.aspectj.lang.annotation.Aspect 注解。</p><pre><code>package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect {}</code></pre><p>切面（用 @Aspect 注解的类）和其他类一样有方法和字段定义。他们也可能包括切入点，通知和引入（inter-type）声明。</p><p><strong>7. 声明一个切入点（pointcut）</strong></p><p>回想一下，切入点决定了连接点关注的内容，使得我们可以控制通知什么时候执行。 Spring AOP 只支持 Spring bean 方法执行连接点。所以你可以把切入点看做是匹配 Spring bean 上方法的执行。 一个切入点声明有两个部分：一个包含名字和任意参数的签名，还有一个切入点表达式，该表达式决定了我们关注那个方法的执行。 在 @AspectJ 注解风格的 AOP 中，一个切入点签名通过一个普通的方法定义来提供，并且切入点表达式使用 @Pointcut 注解来表示（作为切入点签名的方法必须返回 void 类型）。</p><p>用一个例子会帮助我们区分切入点签名和切入点表达式之间的差别，下面的例子定义了一个切入点'anyOldTransfer'， 这个切入点将匹配任何名为 "transfer" 的方法的执行：</p><pre><code>@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() {}// the pointcut signature</code></pre><p>切入点表达式，也就是 @Pointcut 注解的值，是正规的AspectJ 5切入点表达式。 如果你想要更多了解AspectJ的 切入点语言，请参见 AspectJ 编程指南（如果要了解基于Java 5的扩展请参阅 AspectJ 5 开发手册） 或者其他人写的关于AspectJ的书，例如Colyer et. al.着的《Eclipse AspectJ》或者Ramnivas Laddad着的《AspectJ in Action》。</p><p><strong>8. 切入点指定者的支持</strong></p><p>Spring AOP 支持在切入点表达式中使用如下的AspectJ切入点指定者：</p><p><strong>其他的切入点类型</strong></p><p>完整的AspectJ切入点语言支持额外的切入点指定者，但是Spring不支持这个功能。 他们分别是call, initialization, preinitialization, staticinitialization, get, set, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this 和 @withincode。 在Spring AOP中使用这些指定者将会导致抛出IllegalArgumentException异常。</p><p>Spring AOP支持的切入点指定者可能在将来的版本中得到扩展，不但支持更多的AspectJ 切入点指定者（例如"if"），还会支持某些Spring特有的切入点指定者，比如"bean"（用于匹配bean的名字）。 execution - 匹配方法执行的连接点，这是你将会用到的Spring的最主要的切入点指定者。</p><ul><li><strong>within</strong> - 限定匹配特定类型的连接点（在使用Spring AOP的时候，在匹配的类型中定义的方法的执行）。</li><li><strong>this</strong> - 限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中bean reference（Spring AOP 代理）是指定类型的实例。</li><li><strong>target</strong> - 限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中目标对象（被代理的appolication object）是指定类型的实例。</li><li><strong>args</strong> - 限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中参数是指定类型的实例。</li><li><strong>@target</strong> - 限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中执行的对象的类已经有指定类型的注解。</li><li><strong>@args</strong> - 限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中实际传入参数的运行时类型有指定类型的注解。</li><li><strong>@within</strong> - 限定匹配特定的连接点，其中连接点所在类型已指定注解（在使用Spring AOP的时候，所执行的方法所在类型已指定注解）。</li><li><strong>@annotation</strong> - 限定匹配特定的连接点（使用Spring AOP的时候方法的执行），其中连接点的主题有某种给定的注解。 因为Spring AOP限制了连接点必须是方法执行级别的，pointcut designators的讨论也给出了一个定义，这个定义和AspectJ的编程指南中的定义相比显得更加狭窄。 除此之外，AspectJ它本身有基于类型的语义，在执行的连接点'this'和'target'都是指同一个对象，也就是执行方法的对象。 Spring AOP是一个基于代理的系统，并且严格区分代理对象本身（对应于'this'）和背后的目标对象（对应于'target'） 6.2.3.2. 合并切入点表达式</li></ul><p>切入点表达式可以使用using '&', '||' 和 '!'来合并.还可以通过名字来指向切入点表达式。 以下的例子展示了三种切入点表达式： anyPublicOperation（在一个方法执行连接点代表了任意public方法的执行时匹配）； inTrading（在一个代表了在交易模块中的任意的方法执行时匹配） 和 tradingOperation（在一个代表了在交易模块中的任意的公共方法执行时匹配）。</p><pre><code>@Pointcut("execution(public * *(..))")    private void anyPublicOperation() {}@Pointcut("within(com.xyz.someapp.trading..*")    private void inTrading() {}@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")    private void tradingOperation() {}</code></pre><p>就上所示的，从更小的命名组件来构建更加复杂的切入点表达式是一种最佳实践。 当用名字来指定切入点时使用的是常见的Java成员可视性访问规则。 （比如说，你可以在同一类型中访问私有的切入点，在继承关系中访问受保护的切入点，可以在任意地方访问公共切入点。 成员可视性访问规则不影响到切入点的 匹配。</p><p><strong>9. 共享常见的切入点（pointcut）定义</strong></p><p>当开发企业级应用的时候，你通常会想要从几个切面来参考模块化的应用和特定操作的集合。 我们推荐定义一个“SystemArchitecture”切面来捕捉常见的切入点表达式。一个典型的切面可能看起来像下面这样：</p><pre><code>package com.xyz.someapp;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class SystemArchitecture {    /**   * A join point is in the web layer if the method is defined   * in a type in the com.xyz.someapp.web package or any sub-package   * under that.   */    @Pointcut("within(com.xyz.someapp.web..*)")      public void inWebLayer() {    }    /**   * A join point is in the service layer if the method is defined   * in a type in the com.xyz.someapp.service package or any sub-package   * under that.   */    @Pointcut("within(com.xyz.someapp.service..*)")      public void inServiceLayer() {    }    /**   * A join point is in the data access layer if the method is defined   * in a type in the com.xyz.someapp.dao package or any sub-package   * under that.   */    @Pointcut("within(com.xyz.someapp.dao..*)")      public void inDataAccessLayer() {    }    /**   * A business service is the execution of any method defined on a service   * interface. This definition assumes that interfaces are placed in the   * "service" package, and that implementation types are in sub-packages.   *    * If you group service interfaces by functional area (for example,    * in packages com.xyz.someapp.abc.service and com.xyz.def.service) then   * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"   * could be used instead.   */    @Pointcut("execution(* com.xyz.someapp.service.*.*(..))")      public void businessService() {    }    /**   * A data access operation is the execution of any method defined on a    * dao interface. This definition assumes that interfaces are placed in the   * "dao" package, and that implementation types are in sub-packages.   */    @Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")      public void dataAccessOperation() {    }}</code></pre><p>示例中的切入点定义了一个你可以在任何需要切入点表达式的地方可引用的切面。</p><p><strong>示例</strong></p><p>Spring AOP 用户可能会经常使用 execution pointcut designator。执行表达式的格式如下：</p><pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</code></pre><p>除了返回类型模式（上面代码片断中的ret-type-pattern），名字模式和参数模式以外，所有的部分都是可选的。 返回类型模式决定了方法的返回类型必须依次匹配一个连接点。 你会使用的最频繁的返回类型模式是 *，它代表了匹配任意的返回类型。 一个全称限定的类型名将只会匹配返回给定类型的方法。名字模式匹配的是方法名。 你可以使用*通配符作为所有或者部分命名模式。 参数模式稍微有点复杂：() 匹配了一个不接受任何参数的方法， 而 (..) 匹配了一个接受任意数量参数的方法（零或者更多）。 模式 (*) 匹配了一个接受一个任何类型的参数的方法。 模式 (*,String) 匹配了一个接受两个参数的方法，第一个可以是任意类型，第二个则必须是String类型。</p><ul><li>下面给出一些常见切入点表达式的例子。任意公共方法的执行：execution(public * *(..))</li><li>任何一个以“set”开始的方法的执行：execution(* set*(..))</li><li>AccountService 接口的任意方法的执行：execution(* com.xyz.service.AccountService.*(..))</li><li>定义在service包里的任意方法的执行：execution(* com.xyz.service.*.*(..))</li><li>定义在service包或者子包里的任意方法的执行：execution(* com.xyz.service..*.*(..))</li><li>在service包里的任意连接点（在Spring AOP中只是方法执行） ：within(com.xyz.service.*)</li><li>在service包或者子包里的任意连接点（在Spring AOP中只是方法执行） ：within(com.xyz.service..*)</li></ul><p>实现了AccountService接口的代理对象的任意连接点（在Spring AOP中只是方法执行） ：this(com.xyz.service.AccountService)'this'在binding form中用的更多</p><p>实现了AccountService接口的目标对象的任意连接点（在Spring AOP中只是方法执行） ：target(com.xyz.service.AccountService)'target'在binding form中用的更多</p><p>任何一个只接受一个参数，且在运行时传入的参数实现了Serializable接口的连接点 （在Spring AOP中只是方法执行）args(java.io.Serializable)'args'在binding form中用的更多</p><p>请注意在例子中给出的切入点不同于 execution(* *(java.io.Serializable))： args只有在动态运行时候传入参数是可序列化的（Serializable）才匹配，而execution 在传入参数的签名声明的类型实现了 Serializable 接口时候匹配。</p><p>有一个 @Transactional 注解的目标对象中的任意连接点（在Spring AOP中只是方法执行） @target(org.springframework.transaction.annotation.Transactional)'@target' 也可以在binding form中使用：请常见以下讨论通知的章节中关于如何使得annotation对象可以在通知体内访问到的部分。</p><p>任何一个目标对象声明的类型有一个 @Transactional 注解的连接点（在Spring AOP中只是方法执行）@within(org.springframework.transaction.annotation.Transactional)'@within'也可以在binding form中使用：- 请常见以下讨论通知的章节中关于如何</p><h1 class=pgc-h-arrow-right>Java程序员福利：金三银四，我把最近一年经历过的Java岗位面试，和一些刷过的面试题都做成了PDF，PDF都是可以免费分享给大家的，关注私信我：【101】，免费领取！</h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Spring','进行','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>