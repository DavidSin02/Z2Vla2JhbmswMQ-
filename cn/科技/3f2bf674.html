<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>进程、线程、协程的选择与文件并发操作 | 极客快訊</title><meta property="og:title" content="进程、线程、协程的选择与文件并发操作 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/622e63700f544942809d9a374757630e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="进程、线程、协程的选择与文件并发操作"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3f2bf674.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>进程、线程、协程的选择与文件并发操作</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p><strong>代码运行环境</strong></p><p>Centos 4u3</p><p>gcc 482 -std=c++11</p><p>AMD x86指令集</p></blockquote><p><em>计算机系统软件体系结构中有一个非常著名的观点“Any problem in computer science can be solved by anther layer of indirection.”</em></p><p>实际上进程、线程、协程也是一个分层设计。在这里简单说明一下不同层次的简要介绍以及适用场景，并结合最近做的一个文件审计系统说明文件并发操作的注意点。 一些Unix实现的细节在这里不描述，大家可以去看《APUE》。</p><h1>一、进程</h1><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p><p>每一个进程都有它自己的地址空间，包括文本区域（text region）、数据区域（data region）和堆栈（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。多进程间通信需要借助管道、信号量、共享内存、RPC、消息队列等等手段。</p><p>多进程时需要注意fork的使用，fork函数一次调用两次返回。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。UNIX将复制父进程的地址空间内容给子进程，因此，子进程有了独立的地址空间 。下面的case中显示，子进程会复制父进程的输入输出缓冲区的内容，“test”会被打印两遍，而如果把printf("test")更换为printf("test\n")，则运行程序时只会打印一遍“test”。这与printf的打印机制有关，当遇到换行符后printf把缓冲区内的内容都输出给显示设备。这时再发生fork的话，缓冲区没有任何内容，所以只打印了一遍。</p><pre>#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; using namespace std;  int main () { pid_t pid; printf("test"); pid=fork(); if (pid &lt; 0) printf("error in fork!"); else if (pid == 0) printf("i am the child process, my process id is %d\n",getpid()); else printf("i am the parent process, my process id is %d\n",getpid()); return 0; } </pre><h1>二、线程</h1><p>线程（Thread）能够独立工作、在多核情况下可以同时工作，而且线程消耗的资源要比进程小，同一个进程下的线程共享进程的地址空间和内存空间。</p><p><strong>2.1临界区</strong></p><p>相对于进程间通信，线程之间通信就变得非常容易了，但是在通信时仍然需要注意对变量进行保护，关于线程间通信的注意事项我们可以看一下下面的示例case1 ：</p><pre>#include &lt;thread&gt; #include &lt;iostream&gt; #include &lt;chrono&gt;  int testThread = 0; void func(int threadNum) { for (int i = 0; i &lt; 5; i++) { testThread = testThread + 1; printf("Thread %d called. testThread is %d\n", threadNum, testThread); } }  int main() { std::thread t1(func, 1); t1.detach(); std::thread t2(func, 2); t2.detach(); std::this_thread::sleep_for(std::chrono::nanoseconds(1)); printf("print:%d", testThread); std::cout &lt;&lt; testThread &lt;&lt; std::endl; return 0; } </pre><p>运行结果如下：</p><pre>$ ./a.out Thread 1 called. testThread is 1 Thread 1 called. testThread is 3 Thread 1 called. testThread is 4 Thread 1 called. testThread is 5 Thread 1 called. testThread is 6 Thread 2 called. testThread is 2 Thread 2 called. testThread is 7 Thread 2 called. testThread is 8 Thread 2 called. testThread is 9 Thread 2 called. testThread is 10 print:1010  $ ./a.out Thread 2 called. testThread is 2 Thread 2 called. testThread is 3 Thread 2 called. testThread is 4 Thread 2 called. testThread is 5 Thread 1 called. testThread is 1 Thread 1 called. testThread is 7 Thread 1 called. testThread is 8 print:6Thread 1 called. testThread is 9 Thread 1 called. testThread is 10 Thread 2 called. testThread is 6 9 </pre><p>调用这个程序会发现主线程print testThread产生不同的结果，深究一下具体原因是因为主线程去获取testThread的时间点不一样，我们可以研究一下汇编代码。累加操作是从指令寄存器读出数据到累加寄存器，加1后再放回指令寄存器。而printf的时候是从指令寄存器里读出数据到累加寄存器，然后把累加寄存器的值交给printf函数调用。</p><p>通过汇编代码就可以很好地理解这个程序的输出结果了，主线程中的printf函数调用获取到了一个”过时”的全局变量，这段代码也告诉我们使用多线程的时候一定要注意临界区的变量，必要时需要加锁。（也告诉我们C++代码需要深挖到汇编层次才能看清实际问题，<strong>In C++, simple things are simple and portable, complex things require getting your hands dirty under the hood</strong>，LOL）,汇编代码如下：</p><pre>// print 段汇编代码 movl testThread(%rip), %eax movl %eax, %esi movl $.LC1, %edi movl $0, %eax call printf // 线程函数累加段汇编代码 movl testThread(%rip), %eax addl $1, %eax movl %eax, testThread(%rip) </pre><p>使用单条内嵌汇编操作码在单处理器系统上可能不会有什么问题。每个加一操作都将完整地进行，并且多半会得到期望的结果。但是多处理器系统则截然不同。在多 CPU 机器上，两个单独的处理器可能会在几乎同一时刻（或者，就在同一时刻）执行上述赋值语句。不要忘了，这时对内存的修改需要先从 L1 写入 L2 高速缓存、然后才写入主存。最终，根本无法搞清在写入主存的竞争中，哪个 CPU 将会”胜出”。要产生可预测的代码，应使用互斥对象。互斥对象将插入一道”内存关卡”，由它来确保对主存的写入按照线程锁定互斥对象的顺序进行。 上面的case其实还是一种比较简单的情况，没有考虑SMP机器对主存的竞争关系。所有线程都执行这一句testThread = testThread + 1;操作，都有可能会得到不符预期的值，首先，我们不应该假定上述赋值语句一定会被编译成一条机器指令，除非亲自验证了机器代码。即使插入某些内嵌汇编语句以确保加一操作的完整执行，甚至，即使是自己动手写编译器！ 但是即使这样做了，仍然可能有问题。</p><p>更复杂的情况下，考虑一种以 32 位块为单位更新主存的 SMP 体系结构。如果未使用互斥对象就对一个 64 位整数进行加一操作，整数的最高 4 位字节可能来自一个 CPU，而其它 4 个字节却来自另一 CPU。糟糕吧！最糟糕的是，使用差劲的技术，您的程序在重要客户的系统上有可能不是很长时间才崩溃一次。David R. Butenhof 在他的《POSIX 线程编程》一书中，讨论了由于未使用互斥对象而将产生的种种情况。</p><p><strong>2.2 条件变量</strong></p><p><strong>2.3 线程池</strong></p><h1>三、协程</h1><p>协程（Coroutine）减少异步回调编程</p><h1>四、文件并发操作</h1><p><strong>4.1 Linux系统文件操作过程</strong></p><p>“一切皆是文件”是 Unix/Linux 的基本哲学之一，最近在做的审计日志系统正好涉及到了多进程对文件的并发操作，在这里记录一下文件并发操作的细节。为了搞清楚并发操作对文件读写效果产生的影响，有三点知识需要进行说明 第一点是我们需要清楚操作系统读写文件的步骤：</p><ol><li>通过文件名找到对应的操作系统inode</li><li>通过inode获取文件信息，找到文件block的位置</li><li>对对应block数据进行读写</li></ol><div class=pgc-img><img alt=进程、线程、协程的选择与文件并发操作 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/622e63700f544942809d9a374757630e><p class=pgc-img-caption></p></div><p>第二点是如果IO操作不是直接IO，那么操作系统为了平滑硬盘读写慢的影响，通常在内核有设置缓存区。如果是用C库进行文件读写，那么为了减少在用户态和内核态直接的切换次数以及系统调用（read && write）的次数，在用户态还多了一层缓冲区。 缓存是用来减少高速设备访问低速设备所需平均时间的组件，文件读写涉及到计算机内存和磁盘，内存操作速度远远大于磁盘。 当内核收到读写的请求时，内核先去缓存区找是否有请求的数据，有就直接返回，如果没有则通过驱动程序直接操作磁盘。</p><p>第三点是fd和inode的映射关系 这里是fs_struct在内核中的定义</p><pre>struct fs_struct {//建立进程与文件系统的关系 atomic_t count; /*结构的使用计数*/ rwlock_t lock; /*保护该结构体的锁*/ int umask； /*默认的文件访问权限*/ struct dentry * root; /*根目录的目录项对象*/ struct dentry * pwd; /*当前工作目录的目录项对象*/ struct dentry * altroot； /*可供选择的根目录的目录项对象*/ struct vfsmount * rootmnt; /*根目录的安装点对象*/ struct vfsmount * pwdmnt; /*pwd的安装点对象*/ struct vfsmount * altrootmnt;/*可供选择的根目录的安装点对象*/ };</pre><p>清楚了这些后，我们就知道如何应对文件并发访问了</p><p><strong>4.2 多进程读写文件</strong></p><p><strong>4.3 多线程读写文件</strong></p><p><strong>4.4 mmap</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'进程','线程','协程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/ab6b08d6.html alt=并发最基本要理解的进程、线程、协程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f756a3627164d4f93883dd7c0e0bac5 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/ab6b08d6.html title=并发最基本要理解的进程、线程、协程>并发最基本要理解的进程、线程、协程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>