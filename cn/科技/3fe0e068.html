<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 | 极客快訊</title><meta property="og:title" content="“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/8efe683ede77421a822e5586c0edfb62"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3fe0e068.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3fe0e068.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/3fe0e068.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>难度</strong></h1><p>初级</p><h1><strong>学习时间</strong></h1><p>30分钟</p><h1><strong>适合人群</strong></h1><p>零基础</p><h1><strong>开发语言</strong></h1><p>Java</p><h1><strong>开发环境</strong></h1><ul><li>JDK v11</li><li>IntelliJ IDEA v2018.3</li></ul><h1><strong>友情提示</strong></h1><ul><li><strong>本教学属于系列教学，内容具有连贯性，本章使用到的内容之前教学中都有详细讲解。</strong></li><li><strong>本章内容针对零基础或基础较差的同学比较友好，可能对于有基础的同学来说很简单，希望大家可以根据自己的实际情况选择继续看完或等待看下一篇文章。谢谢大家的谅解！</strong></li></ul><h1><strong>1.准备继承类</strong></h1><p>这里我们准备两个类,它们是继承关系，子类为Zi，父类为Fu。</p><p>Fu类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8efe683ede77421a822e5586c0edfb62><p class=pgc-img-caption></p></div><p>Zi类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1afd99180344460089b2fd13cb61a1f7><p class=pgc-img-caption></p></div><h1>2.准备重写方法</h1><p>那么接下来呢，我们就在Fu类中写上一个成员方法，然后让子类去重写这个成员方法。</p><p>Fu类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dac5dc26ca474221a200c51baa434351><p class=pgc-img-caption></p></div><p>Zi类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5f0f1fa110c94ceda4e1f688c06b4df9><p class=pgc-img-caption></p></div><h1>3.父类中成员方法抛异常</h1><p>子父类也有了，方法也重写了。接下来就是在父类方法上抛出异常，然后观察子类方法会出现什么错误。</p><p>演示：</p><p>请给父类方法抛出一个异常。</p><p>请观察程序运行结果。</p><p>代码：</p><p>Fu类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d202c02c2efb466d983ed33a75b417d5><p class=pgc-img-caption></p></div><p>Zi类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36d187befece4308b335355644223e7a><p class=pgc-img-caption></p></div><p>Main类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a0e6e49c66ef4a899679c271b46d9979><p class=pgc-img-caption></p></div><p>结果：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/07ef92c4dd8f4ddebfa782c16c13dd94><p class=pgc-img-caption></p></div><p>错误信息：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b9df98af5834bd4b99d533e398946d9><p class=pgc-img-caption></p></div><p>文字版：</p><blockquote><p><strong>Information:java: Errors occurred while compiling module 'Hello'</strong></p><p><strong>Information:javac 11 was used to compile java sources</strong></p><p><strong>Information:2019-01-02 23:13 - Compilation completed with 1 error and 0 warnings in 3 s 113 ms</strong></p><p><strong>/Users/admin/Workspace/Java/Hello/src/lab/Zi.java</strong></p><p><strong>Error:(13, 18) java: 未报告的异常错误java.io.IOException; 必须对其进行捕获或声明以便抛出</strong></p></blockquote><p>从运行结果来看，我们程序出现了一点小小的错误。</p><p>错误信息显示，我们没有对一个叫做“IOException”的异常进行try-catch或throws。</p><p>首先，我们先得知道为什么会出现有“异常需要捕获或者声明”这个错误？</p><p><strong>只有调用有可能产生异常的方法，才会出现此错误。</strong></p><p>那就是说我们调用了会产生异常的方法？</p><p>是的。</p><p>哪段程序调用了会产生异常的方法？</p><p>首先从Main类中的main()方法来看：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/68da04ed1ce5470a9bf691dd6f9ecafe><p class=pgc-img-caption></p></div><p>从代码块中可以看到，我们创建了子类对象并调用了其say()方法，那么，say()方法会不会产生异常呢？我们来看看：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d0b91286603c4bb3bc94c0f55e756fe9><p class=pgc-img-caption></p></div><p>从程序代码来看，子类中的say()方法并没有声明说会产生异常，所以子类中的say()方法被调用时不会产生异常。</p><p>再来看子类中的say()方法里面：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87486fa30d834363b362f1a829b8a572><p class=pgc-img-caption></p></div><p>子类中的say()方法里面调用了父类的say()方法，我们再去看看父类中的say()方法：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a095b78d6cde4929b4658ad4d083fc19><p class=pgc-img-caption></p></div><p>首先我们看到父类中的say()方法上使用throws声明调用此方法有可能产生异常，而且该异常是IOException，好像问题的源头已经找到了，但最终是不是调用了父类中的say()方法产生的异常呢，再往下看。</p><p>父类中的say()方法里面：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/529d92598d3e43deab03fb393a0a6163><p class=pgc-img-caption></p></div><p>好，这段代码已经明确要抛出一个IOException异常，因为if的条件表达式为true，所以if语句里面的代码必定执行，也就抛出了IOException。由于IOException是一个非运行时异常，所以需要try-catch或throws处理，父类中的say()方法选择的是throws，将其声明在方法上。</p><p>这里就解决一个问题：IOException从哪里来的？</p><p><strong>IOException是调用父类方法来的。</strong></p><p>对于有throws声明会产生异常的方法，调用者只有两种处理方式：try-catch或thorws。</p><p>我们来看看子类调用父类有可能产生异常的方法处理方式是什么：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/652dfb55f2f64c6cb28eaafd1c45305c><p class=pgc-img-caption></p></div><p>从程序代码中看，很遗憾，什么处理方式都没有，所以程序会报错。</p><p><strong>虽然错误被我们找到了，但是我还是要跟大家说声抱歉，因为这个错误其实可以从错误信息中看出来，但我还是一步一步带领大家来找，其实是希望大家可以把之前的知识回顾一下，比如父子类方法之间的调用、抛异常以及声明异常。</strong></p><p>错误点被我们找到了，我们待会来处理它。现在我们来看看如何通过错误信息来看：</p><blockquote><p><strong>/Users/admin/Workspace/Java/Hello/src/lab/Zi.java</strong></p><p><strong>Error:(13, 18) java: 未报告的异常错误java.io.IOException; 必须对其进行捕获或声明以便抛出</strong></p></blockquote><p>错误信息中告诉我们在<strong>Zi类的第13行代码处</strong>，有一个未报告的异常错误java.io.IOException; 必须对其进行捕获或声明以便抛出。</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b6c4b1f4c1345f1bdc3cc2932e336b8><p class=pgc-img-caption></p></div><p>我们调用父类方法的地方正是在13行，错误点也被找到了。</p><p>接下来，我们对其进行处理（try-catch或throws）：</p><p>try-catch：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2fab920bdc8b494489b66339f25c2fe1><p class=pgc-img-caption></p></div><p>throws：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/40ae3b6f7b504ad18d756746841530b0><p class=pgc-img-caption></p></div><p>上面我们分别演示了try-catch和throws两种处理方式。try-catch这种方式最实用和最便捷，也不会出错。但throws情况又不一样了，下面就来讨论throws在继承中有哪些需要注意的地方。</p><h1>4.抛出新异常</h1><p>什么叫抛出新异常呢？</p><p>就是抛出父类方法已经声明的异常列表里面没有的异常。比如上节例子中父类的say()方法声明的异常列表里只有一个IOException，我们只需抛出非IOException的异常都叫抛出新异常。</p><p>好，我们来试试。</p><p><strong>注意：</strong></p><p><strong>我们演示程序中抛出的异常都是非运行时异常，这是因为非运行时异常必须try-catch或throws，所以下面选择的新异常也是非运行时异常，有可能大家会觉得这几个异常和程序没有什么关联，对的，我们仅仅是为了演示，实际开发中不是这样的，请大家谅解！</strong></p><p>Fu类不变：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0f5ac6f677745e39ef56c94fe5f0ad5><p class=pgc-img-caption></p></div><p>Zi类say()方法抛出新异常ClassNotFoundException，ClassNotFoundException是一个非运行时异常：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c30ebc6c33424333b9e6b368a3f9e014><p class=pgc-img-caption></p></div><p>既然Zi类say()方法抛出异常，那么调用者需要对其进行处理：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ed8a5162fc7d4ae29d7ff743df9088b5><p class=pgc-img-caption></p></div><p>运行程序，执行结果：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/745a05e31caa45ca8f75114017649a48><p class=pgc-img-caption></p></div><p>错误信息：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/423a442a41d644d69448b8ec9b23ac35><p class=pgc-img-caption></p></div><p>文字版：</p><blockquote><p><strong>/Users/admin/Workspace/Java/Hello/src/lab/Zi.java</strong></p><p><strong>Error:(14, 17) java: lab.Zi中的say()无法覆盖lab.Fu中的say()</strong></p><p><strong>被覆盖的方法未抛出java.lang.ClassNotFoundException</strong></p></blockquote><p>从错误信息中我们可以看出，在Zi类的第14行代码处，这就下面这段代码：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5e65a00d467e49cc942d7873ad26f202><p class=pgc-img-caption></p></div><p>错误原因：Zi中的say()无法覆盖lab.Fu中的say()</p><p>发生子类方法无法覆盖（即重写）父类方法，我们之前学过方法的重写，它需要子类方法和父类方法一摸一样，这样才能发生覆盖。</p><p>那么，这里不能发生覆盖的原因是什么呢？</p><p>不能覆盖的原因是<strong>被覆盖的方法未抛出java.lang.ClassNotFoundException</strong>。</p><p>被覆盖的方法是指哪个方法？</p><p>父类的方法。在本例中指的是Fu类中的say()方法。</p><p>换言之就是：<strong>Fu类中的say()方法未抛出java.lang.ClassNotFoundException</strong>。</p><p>我们就可以得出结论：<strong>当重写方法时，只能抛出父类方法声明的异常列表中的异常，不能抛出新异常。</strong></p><p>这只是当父类方法抛出一个异常时的情况，当父类方法抛出多个异常时，情况又会是怎样呢？</p><h1>5.抛出异常子集</h1><p>大家注意看清楚本小节标题，是抛出异常子集，不是抛出异常子类。</p><p>既然是子集，那么声明的异常肯定是在两个或两个以上。接下来，来改写Fu类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f86eedad6ba144dd84da421cb50e8e1f><p class=pgc-img-caption></p></div><p>Zi类不变：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/26f3f779d7f144e4a23f31b5277d59d9><p class=pgc-img-caption></p></div><p>Main类处理异常行为发生了改变，打印输出语句也是方便大家观察：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb6647a0c2b14889b3f6240140062e6c><p class=pgc-img-caption></p></div><p>运行程序，执行结果：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5cc092d57b264d3482214aa11001bf25><p class=pgc-img-caption></p></div><p>这个执行结果是正确的，程序没有问题。我们来简单分析一下程序代码。</p><p>首先，我们在父类方法中抛出两个异常并使用throws进行声明：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7cd8cc2aa2ff4c8d94ac7e8c2027db3d><p class=pgc-img-caption></p></div><p>然后子类对其方法进行重写并调用父类方法，将父类方法产生的两个异常抛出：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ea5fddf31184ddbb43d9566719ea9a9><p class=pgc-img-caption></p></div><p>最后，我们在Main类的main()方法中创建子类对象并调用say()方法，对抛出的异常处理：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/629981eb23a541519232927a6311208f><p class=pgc-img-caption></p></div><p>执行结果：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/386e2a6b37024ac094a98ad6952dd530><p class=pgc-img-caption></p></div><p>本例子主要演示了父类方法抛出多个异常，子类方法在重写的同时又去调用了父类方法，因为父类方法会抛出异常，所以子类方法必须进行处理（try-catch或throws），我们选择throws，这时父类方法抛出多少个异常，子类方法也必须抛出和父类一摸一样的异常。</p><p>有同学就有疑问了，我能不能捕获一个异常，然后其他异常将其抛出？</p><p>可以。</p><p>我们来试试，更改Zi类：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e68fbdc7e30a4126999df2b0f281153e><p class=pgc-img-caption></p></div><p>我们子类将父类方法中抛出的两个异常IOException和ClassNotFoundException，一个进行捕获，一个进行抛出，IOException被捕获，ClassNotFoundException被抛出。</p><p>这样的话，我们的Main类也是需要更改的：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dcc9cfaf299e47a7afde1c47053b80de><p class=pgc-img-caption></p></div><p>运行程序，执行结果：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aa9bd0a9b33541e3968049488a6c754a><p class=pgc-img-caption></p></div><p>从运行结果来看，父类方法抛出的异常被我们子类捕获到了：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75e66351e7514407a9ca1b2dd448efb1><p class=pgc-img-caption></p></div><p>我们子类抛出的异常被调用者捕获到了：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cdd8aa6d10bd4392a13d12f83591df6c><p class=pgc-img-caption></p></div><p><strong>本例子演示了我们子类方法可以抛出父类方法异常子集，本例中父类方法异常列表中有两个IOException和ClassNotFoundException，但我们子类只抛出了其中一个ClassNotFoundException。这就是子类方法抛出父类方法异常列表的子集。</strong></p><h1>6.需要注意的地方</h1><p>第一个需要注意的地方，实际开发中，我们有可能是不调用父类方法的：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e0d87016450646008d71cd287e443b0d><p class=pgc-img-caption></p></div><p><strong>这样就意味着，只要我们子类中不抛出异常，那么就没有必要声明异常。</strong></p><p>第二个需要注意的地方，实际开发中，我们可能会产生新异常，这里千万不能抛出，只能try-catch（面试考点）：</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c07a64f95dc1437f8647c8b3d713f76c><p class=pgc-img-caption></p></div><p><strong>当重写方法时，子类方法中出现新异常，只能try-catch，不能抛出。</strong></p><p><strong>当重写方法时，子类方法中出现新异常，只能try-catch，不能抛出。</strong></p><p><strong>当重写方法时，子类方法中出现新异常，只能try-catch，不能抛出。</strong></p><p>重要的事情说了三遍，希望大家记住，非常重要，实际开发中很常见。</p><p>第三个需要注意的地方，我们能不能抛出父类方法抛出的异常的父类？</p><p>答案是不可以。</p><p>“我们能不能抛出父类方法抛出的异常的父类？”这句话有点绕，我们来分词看：</p><pre>我们 能不能 抛出 父类方法抛出的异常 的父类？</pre><p>换言之，父类方法抛出IOException，子类的重写方法能不能抛出IOException的父类Exception？</p><p>这肯定不能，比如说，父类抛出一只狗，你子类却抛出一个动物，这显然不合适，因为动物有很多，猫也是动物，我怎么知道你子类抛出的动物是狗还是猫，还是其他的什么动物。换作异常也一样，我父类方法抛出的是IOException，你子类却抛出Exception，Exception子类有很多，比如ClassNotFoundException，我怎么知道你到底抛的是IOException还是ClassNotFoundException，这显然就不对了。</p><p><strong>当重写方法时，子类方法不能抛出父类方法异常的父类。</strong></p><p>这个在实际开发中也很常见，希望大家注意。</p><h1><strong>总结</strong></h1><ul><li>重写方法时只能抛出父类异常子集。</li><li>当重写方法时，只能抛出父类方法声明的异常列表中的异常，不能抛出新异常。</li><li>只要我们子类中不抛出异常，那么就没有必要声明异常。</li><li>当重写方法时，子类方法中出现新异常，只能try-catch，不能抛出。</li><li>当重写方法时，子类方法不能抛出父类方法异常的父类。</li></ul><p>至此，Java中重写方法与异常相关内容讲解先告一段落，更多内容请持续关注。</p><h1><strong>答疑</strong></h1><p>如果大家有问题或想了解更多前沿技术，请在下方留言或评论，我会为大家解答。</p><h1><strong>上一章</strong></h1><p><a class=pgc-link href="https://www.toutiao.com/i6641131191921541640/?group_id=6641131191921541640" target=_blank>“全栈2019”Java异常第十章：throw与throws区别详解</a></p><h1><strong>下一章</strong></h1><p>“全栈2019”Java异常第十二章：catch与异常匹配</p><h1><strong>学习小组</strong></h1><p>加入同步学习小组，共同交流与进步。</p><ul><li><strong>方式一：关注头条号Gorhaf，私信“Java学习小组”。</strong></li><li><strong>方式二：关注公众号Gorhaf，回复“Java学习小组”。</strong></li></ul><h1><strong>全栈工程师学习计划</strong></h1><p>关注我们，加入“全栈工程师学习计划”。</p><div class=pgc-img><img alt=“全栈2019”Java异常第十一章：重写方法时子类不能抛出新异常 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7782c8aee3024b2f9a865e0fa40280dc><p class=pgc-img-caption></p></div><h1><strong>版权声明</strong></h1><p>原创不易，未经允许不得转载！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异常','全栈','2019'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>