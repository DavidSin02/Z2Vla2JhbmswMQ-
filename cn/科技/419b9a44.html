<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>熬了7天，总结出来了Java中动态规则的实现方式 | 极客快訊</title><meta property="og:title" content="熬了7天，总结出来了Java中动态规则的实现方式 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><meta property="article:published_time" content="2020-11-14T20:59:54+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:54+08:00"><meta name=Keywords content><meta name=description content="熬了7天，总结出来了Java中动态规则的实现方式"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/419b9a44.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>熬了7天，总结出来了Java中动态规则的实现方式</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>背景</strong></h1><p style=text-align:start>业务系统在应用过程中，有时候要处理“经常变化”的部分，这部分需求可能是“业务规则”，也可能是“不同的数据处理逻辑”，这部分动态规则的问题，往往需要可配置，并对性能和实时性有一定要求。</p><p style=text-align:start>Java不是解决动态层问题的理想语言，在实践中发现主要有以下几种方式可以实现：</p><ul><li>表达式语言（expression language）</li><li>动态语言（dynamic/script language language），如Groovy</li><li>规则引擎（rule engine）</li></ul><h1 class=pgc-h-arrow-right><strong>表达式语言</strong></h1><p style=text-align:start>Java Unified Expression Language，简称JUEL，是一种特殊用途的编程语言，主要在Java Web应用程序用于将表达式嵌入到web页面。Java规范制定者和Java Web领域技术专家小组制定了统一的表达式语言。JUEL最初包含在JSP 2.1规范JSR-245中，后来成为Java EE 7的一部分，改在JSR-341中定义。</p><p style=text-align:start>主要的开源实现有：OGNL ，MVEL ，SpEL，JUEL，Java Expression Language (JEXL)，JEval，Jakarta JXPath 等。</p><p style=text-align:start>这里主要介绍在实践中使用较多的MVEL、OGNL和SpEL。</p><p style=text-align:start><strong>OGNL(Object Graph Navigation Library)</strong></p><p style=text-align:start>在Struts 2 的标签库中都是使用OGNL表达式访问ApplicationContext中的对象数据，简单示例：</p><pre><code>Foo foo = new Foo();foo.setName(&#34;test&#34;);Map&lt;String, Object&gt; context = new HashMap&lt;String, Object&gt;();context.put(&#34;foo&#34;,foo);String expression = &#34;foo.name == &#39;test&#39;&#34;;try {    Boolean result = (Boolean) Ognl.getValue(expression,context);    System.out.println(result);} catch (OgnlException e) {    e.printStackTrace();}</code></pre><p style=text-align:start><strong>MVEL</strong></p><p style=text-align:start>MVEL最初作为Mike Brock创建的 Valhalla项目的表达式计算器（expression evaluator），相比最初的OGNL、JEXL和JUEL等项目，而它具有远超它们的性能、功能和易用性 - 特别是集成方面。它不会尝试另一种JVM语言，而是着重解决嵌入式脚本的问题。</p><p style=text-align:start>MVEL主要使用在Drools，是Drools规则引擎不可分割的一部分。</p><p style=text-align:start>MVEL语法较为丰富，不仅包含了基本的属性表达式，布尔表达式，变量复制和方法调用，还支持函数定义，详情参见MVEL Language Guide 。</p><p style=text-align:start>MVEL在执行语言时主要有解释模式（Interpreted Mode）和编译模式（Compiled Mode ）两种：</p><ul><li>解释模式（Interpreted Mode）是一个无状态的，动态解释执行，不需要负载表达式就可以执行相应的脚本。</li><li>编译模式（Compiled Mode）需要在缓存中产生一个完全规范化表达式之后再执行。</li></ul><pre><code>//解释模式Foo foo = new Foo();foo.setName(&#34;test&#34;);Map context = new HashMap();String expression = &#34;foo.name == &#39;test&#39;&#34;;VariableResolverFactory functionFactory = new MapVariableResolverFactory(context);context.put(&#34;foo&#34;,foo);Boolean result = (Boolean) MVEL.eval(expression,functionFactory);System.out.println(result);//编译模式Foo foo = new Foo();foo.setName(&#34;test&#34;);Map context = new HashMap();String expression = &#34;foo.name == &#39;test&#39;&#34;;VariableResolverFactory functionFactory = new MapVariableResolverFactory(context);context.put(&#34;foo&#34;,foo);Serializable compileExpression = MVEL.compileExpression(expression);Boolean result = (Boolean) MVEL.executeExpression(compileExpression, context, functionFactory);</code></pre><p style=text-align:start><strong>SpEL</strong></p><p style=text-align:start>SpEl(Spring表达式语言）是一个支持查询和操作运行时对象导航图功能的强大的表达式语言。 它的语法类似于传统EL，但提供额外的功能，最出色的就是函数调用和简单字符串的模板函数。SpEL类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p><p style=text-align:start>SpEL主要提供基本表达式、类相关表达式及集合相关表达式等，详细参见Spring 表达式语言 (SpEL) 。</p><p style=text-align:start>类似与OGNL，SpEL具有expression(表达式)，Parser（解析器），EvaluationContext(上下文）等基本概念；类似于MVEL，SpEl也提供了解释模式和编译模式两种运行模式。</p><pre><code>//解释器模式Foo foo = new Foo();foo.setName(&#34;test&#34;);// Turn on:// - auto null reference initialization// - auto collection growingSpelParserConfiguration config = new SpelParserConfiguration(true,true);ExpressionParser parser = new SpelExpressionParser(config);String expressionStr = &#34;#foo.name == &#39;test&#39;&#34;;StandardEvaluationContext context = new StandardEvaluationContext();context.setVariable(&#34;foo&#34;,foo);Expression expression = parser.parseExpression(expressionStr);Boolean result = expression.getValue(context,Boolean.class);//编译模式config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, RunSpel.class.getClassLoader());parser = new SpelExpressionParser(config);context = new StandardEvaluationContext();context.setVariable(&#34;foo&#34;,foo);expression = parser.parseExpression(expressionStr);result = expression.getValue(context,Boolean.class);</code></pre><h1 class=pgc-h-arrow-right>规则引擎</h1><p style=text-align:start>一些规则引擎（rule engine）：aviator，easy-rules，drools，esper, siddhi</p><p style=text-align:start><strong>aviator</strong></p><p style=text-align:start>AviatorScript 是一门高性能、轻量级寄宿于 JVM 之上的脚本语言。</p><p style=text-align:start>使用场景包括：</p><ol start=1><li>规则判断及规则引擎</li><li>公式计算</li><li>动态脚本控制</li><li>集合数据 ELT 等</li></ol><pre><code>public class Test {   public static void main(String[] args) {       String expression = &#34;a+(b-c)&gt;100&#34;;       // 编译表达式       Expression compiledExp = AviatorEvaluator.compile(expression);       Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();       env.put(&#34;a&#34;, 100.3);       env.put(&#34;b&#34;, 45);       env.put(&#34;c&#34;, -199.100);       // 执行表达式       Boolean result = (Boolean) compiledExp.execute(env);       System.out.println(result);   }}</code></pre><p style=text-align:start><strong>easy-rules</strong></p><p style=text-align:start>Easy Rules is a Java rules engine。</p><p style=text-align:start>使用POJO定义规则：</p><pre><code>@Rule(name = &#34;weather rule&#34;, description = &#34;if it rains then take an umbrella&#34;)public class WeatherRule {    @Condition    public boolean itRains(@Fact(&#34;rain&#34;) boolean rain) {        return rain;    }        @Action    public void takeAnUmbrella() {        System.out.println(&#34;It rains, take an umbrella!&#34;);    }}Rule weatherRule = new RuleBuilder()        .name(&#34;weather rule&#34;)        .description(&#34;if it rains then take an umbrella&#34;)        .when(facts -&gt; facts.get(&#34;rain&#34;).equals(true))        .then(facts -&gt; System.out.println(&#34;It rains, take an umbrella!&#34;))        .build();</code></pre><p style=text-align:start>支持使用表达式语言（MVEL/SpEL）来定义规则：</p><p style=text-align:start>weather-rule.yml example:</p><pre><code>name: &#34;weather rule&#34;description: &#34;if it rains then take an umbrella&#34;condition: &#34;rain == true&#34;actions:  - &#34;System.out.println(\&#34;It rains, take an umbrella!\&#34;);&#34;</code></pre><pre><code>MVELRuleFactory ruleFactory = new MVELRuleFactory(new YamlRuleDefinitionReader());Rule weatherRule = ruleFactory.createRule(new FileReader(&#34;weather-rule.yml&#34;));</code></pre><p style=text-align:start>触发规则：</p><pre><code>public class Test {    public static void main(String[] args) {        // define facts        Facts facts = new Facts();        facts.put(&#34;rain&#34;, true);        // define rules        Rule weatherRule = ...        Rules rules = new Rules();        rules.register(weatherRule);        // fire rules on known facts        RulesEngine rulesEngine = new DefaultRulesEngine();        rulesEngine.fire(rules, facts);    }}</code></pre><p style=text-align:start><strong>drools</strong></p><p style=text-align:start>An open source rule engine, DMN engine and complex event processing (CEP) engine for Java and the JVM Platform.</p><p style=text-align:start>定义规则：</p><pre><code>import com.lrq.wechatDemo.domain.User   // 导入类dialect  &#34;mvel&#34;rule &#34;age&#34;    // 规则名，唯一    when        $user : User(age&lt;15 || age&gt;60)  //规则的条件部分    then        System.out.println(&#34;年龄不符合要求！&#34;);end</code></pre><p style=text-align:start>参考例子：</p><pre><code>public class TestUser {    private static KieContainer container = null;    private KieSession statefulKieSession = null;    @Test    public void test(){        KieServices kieServices = KieServices.Factory.get();        container = kieServices.getKieClasspathContainer();        statefulKieSession = container.newKieSession(&#34;myAgeSession&#34;);        User user = new User(&#34;duval yang&#34;,12);        statefulKieSession.insert(user);        statefulKieSession.fireAllRules();        statefulKieSession.dispose();    }}</code></pre><p style=text-align:start>drools是比较重的规则引擎，有自己的状态存储，详见其官方文档。</p><p style=text-align:start><strong>esper</strong></p><p style=text-align:start>Esper is a component for complex event processing (CEP), streaming SQL and event series analysis, available for Java as Esper, and for .NET as NEsper.</p><p style=text-align:start>一个例子：</p><pre><code>public class Test {    public static void main(String[] args) throws InterruptedException {        EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();         EPAdministrator admin = epService.getEPAdministrator();         String product = Apple.class.getName();        String epl = &#34;select avg(price) from &#34; + product + &#34;.win:length_batch(3)&#34;;         EPStatement state = admin.createEPL(epl);        state.addListener(new AppleListener());         EPRuntime runtime = epService.getEPRuntime();         Apple apple1 = new Apple();        apple1.setId(1);        apple1.setPrice(5);        runtime.sendEvent(apple1);         Apple apple2 = new Apple();        apple2.setId(2);        apple2.setPrice(2);        runtime.sendEvent(apple2);         Apple apple3 = new Apple();        apple3.setId(3);        apple3.setPrice(5);        runtime.sendEvent(apple3);    }}</code></pre><p style=text-align:start><strong>siddhi</strong></p><p style=text-align:start>Siddhi is a cloud native <em>Streaming</em> and <em>Complex Event Processing</em> engine that understands Streaming SQL queries in order to capture events from diverse data sources, process them, detect complex conditions, and publish output to various endpoints in real time.</p><p style=text-align:start>For example:</p><pre><code>package io.siddhi.sample;import io.siddhi.core.SiddhiAppRuntime;import io.siddhi.core.SiddhiManager;import io.siddhi.core.event.Event;import io.siddhi.core.stream.input.InputHandler;import io.siddhi.core.stream.output.StreamCallback;import io.siddhi.core.util.EventPrinter;/** * The sample demonstrate how to use Siddhi within another Java program. * This sample contains a simple filter query. */public class SimpleFilterSample {    public static void main(String[] args) throws InterruptedException {        // Create Siddhi Manager        SiddhiManager siddhiManager = new SiddhiManager();        //Siddhi Application        String siddhiApp = &#34;&#34; +                &#34;define stream StockStream (symbol string, price float, volume long); &#34; +                &#34;&#34; +                &#34;@info(name = &#39;query1&#39;) &#34; +                &#34;from StockStream[volume &lt; 150] &#34; +                &#34;select symbol, price &#34; +                &#34;insert into OutputStream;&#34;;        //Generate runtime        SiddhiAppRuntime siddhiAppRuntime = siddhiManager.createSiddhiAppRuntime(siddhiApp);        //Adding callback to retrieve output events from stream        siddhiAppRuntime.addCallback(&#34;OutputStream&#34;, new StreamCallback() {            @Override            public void receive(Event[] events) {                EventPrinter.print(events);                //To convert and print event as a map                //EventPrinter.print(toMap(events));            }        });        //Get InputHandler to push events into Siddhi        InputHandler inputHandler = siddhiAppRuntime.getInputHandler(&#34;StockStream&#34;);        //Start processing        siddhiAppRuntime.start();        //Sending events to Siddhi        inputHandler.send(new Object[]{&#34;IBM&#34;, 700f, 100L});        inputHandler.send(new Object[]{&#34;WSO2&#34;, 60.5f, 200L});        inputHandler.send(new Object[]{&#34;GOOG&#34;, 50f, 30L});        inputHandler.send(new Object[]{&#34;IBM&#34;, 76.6f, 400L});        inputHandler.send(new Object[]{&#34;WSO2&#34;, 45.6f, 50L});        Thread.sleep(500);        //Shutdown runtime        siddhiAppRuntime.shutdown();        //Shutdown Siddhi Manager        siddhiManager.shutdown();    }}</code></pre><p style=text-align:start>esper和siddhi都是streaming process，支持CEP和SQL，详见其官方文档。</p><h1 class=pgc-h-arrow-right><strong>动态JVM语言</strong></h1><p style=text-align:start><strong>Groovy</strong></p><p style=text-align:start>Groovy除了Gradle 上的广泛应用之外，另一个大范围的使用应该就是结合Java使用动态代码了。Groovy的语法与Java非常相似，以至于多数的Java代码也是正确的Groovy代码。Groovy代码动态的被编译器转换成Java字节码。由于其运行在JVM上的特性，Groovy可以使用其他Java语言编写的库。</p><p style=text-align:start>Groovy可以看作给Java静态世界补充动态能力的语言，同时Groovy已经实现了java不具备的语言特性：</p><ul><li>函数字面值；</li><li>对集合的一等支持；</li><li>对正则表达式的一等支持；</li><li>对xml的一等支持；</li></ul><p style=text-align:start>Groovy作为基于JVM的语言，与表达式语言存在语言级的不同，因此在语法上比表达还是语言更灵活。Java在调用Groovy时，都需要将Groovy代码编译成Class文件。</p><p style=text-align:start>Groovy 可以采用GroovyClassLoader、GroovyShell、GroovyScriptEngine和JSR223 等方式与Java语言集成。</p><p style=text-align:start>一个使用GroovyClassLoader动态对json对象进行filter的例子：</p><pre><code>public class GroovyFilter implements Filter {    private static String template =  &#34;&#34; +            &#34;package com.alarm.eagle.filter;&#34; +            &#34;import com.fasterxml.jackson.databind.node.ObjectNode;&#34; +            &#34;def match(ObjectNode o){[exp]}&#34;;    private static String method = &#34;match&#34;;    private String filterExp;    private transient GroovyObject filterObj;    public GroovyFilter(String filterExp) throws Exception {        ClassLoader parent = Thread.currentThread().getContextClassLoader();        GroovyClassLoader classLoader = new GroovyClassLoader(parent);        Class clazz = classLoader.parseClass(template.replace(&#34;[exp]&#34;, filterExp));        filterObj = (GroovyObject)clazz.newInstance();    }    public boolean filter(ObjectNode objectNode) {        return (boolean)filterObj.invokeMethod(method, objectNode);    }}</code></pre><p style=text-align:start>Java每次调用Groovy代码都会将Groovy编译成Class文件，因此在调用过程中会出现JVM级别的问题。如使用GroovyShell的parse方法导致perm区爆满的问题，使用GroovyClassLoader加载机制导致频繁gc问题和CodeCache用满，导致JIT禁用问题等，相关问题可以参考Groovy与Java集成常见的坑 。</p><hr><p>关注我，私信回复【<strong>资料</strong>】即可领取视频中java相关资料以及一份227页最新的bat大厂面试宝典</p><h1 class=pgc-h-arrow-right>最后</h1><p style=text-align:start>欢迎大家一起交流，喜欢文章记得关注我点个赞哟，感谢支持！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'总结','出来','Java'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>