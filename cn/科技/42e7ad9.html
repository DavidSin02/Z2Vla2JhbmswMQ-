<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>网络编程 用户态协议栈之 TCP/IP 的设计 | 极客快訊</title><meta property="og:title" content="网络编程 用户态协议栈之 TCP/IP 的设计 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f1ee5eb624d94284bf71514f3cc5ea7b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="网络编程 用户态协议栈之 TCP/IP 的设计"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/42e7ad9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>网络编程 用户态协议栈之 TCP/IP 的设计</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1. Netmap 简介</strong></p><p>Netmap 是一个高性能收发原始数据包的框架，由 Luigi Rizzo 等人开发完成，其包含了内核</p><p>模块以及用户态库函数。其目标是，不修改现有操作系统软件以及不需要特殊硬件支持，实</p><p>现用户态和网卡之间数据包的高性能传递。其原理图如下，数据包不经过操作系统内核进行</p><p>处理，用户空间程序收发数据包时，直接与网卡进行通信。</p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1ee5eb624d94284bf71514f3cc5ea7b><p class=pgc-img-caption></p></div><p><br></p><p>相关视频教程</p><p><a class=pgc-link data-content=mp href=https://www.ixigua.com/i6844073817476694531/ rel="noopener noreferrer" target=_blank>Linux服务器开发/网络编程/TCP/IP协议栈深度解析第一课</a></p><p><a class=pgc-link data-content=mp href=https://www.ixigua.com/i6844074791129842188/ rel="noopener noreferrer" target=_blank>Linux服务器开发/网络编程/TCP/IP协议栈深度解析第二课</a></p><p><a class=pgc-link data-content=mp href=https://www.ixigua.com/i6847748577859633668/ rel="noopener noreferrer" target=_blank>Linux服务器开发/网络编程/TCP/IP协议栈深度解析【完结篇】</a></p><p>相关代码关注后私信回复：1</p><p><strong>1. 数据结构</strong></p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/055d156edb28447cb4ed1b477fe54c80><p class=pgc-img-caption></p></div><p><strong></strong></p><p>在 Netmap 框架下，内核拥有数据包池，发循环接收环上的数据包不需要动态申请，有数据</p><p>到达网卡时，当有数据到达后，直接从数据包池中取出一个数据包，然后将数据放入此数据</p><p>包中，再将数据包的描述符放入接收环中。内核中的数据包池，通过 mmap 技术映射到用户</p><p>空间。用户态程序最终通过 netmap_if 获取接收发送环 netmap_ring，进行数据包的获取发</p><p>送。</p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/afe8be44-68c3-456c-88b5-3b86b7576515><p class=pgc-img-caption></p></div><p><strong>2. 特点总结</strong></p><p><strong>（1）性能高 </strong>：数据包不走传统协议栈，不需要层层解析，用户态直接与网卡的接受环和发</p><p>循环交互。性能高的具体原因有以下三个：</p><p>（a） 系统调用以及处理数据包的时间花费少</p><p>（b） 不需要进行数据包的内存分配：采用数据包池，当有数据到达后，直接从数据包</p><p>池中取出一个数据包，然后将数据放入此数据包中，再将数据包的描述符放入接收环中。</p><p>（c） 数据拷贝次数少：内核中的数据包采用 mmap 技术映射到用户态。所以数据包在</p><p>到达用户态时，不需要进行数据包的拷贝。</p><p><strong>（2） 稳定性高 </strong>：有关网卡寄存器数据的维护都是在内核模块进行，用户不会直接操作寄</p><p>存器。所以在用户态操作时，不会导致操作系统崩溃</p><p><strong>（3） 亲和性 </strong>：可采用了 CPU 亲和性，实现 CPU 和网卡绑定，提高性能。</p><p><strong>（4） 易用性好 </strong>：API 操作简单，用户态只需要调用 ioctl 函数即可完成数据包收发工作</p><p><strong>（5） 与硬件解耦 </strong>：不依赖硬件，只需要对网卡驱动程序稍微做点修改就可以使用此框架</p><p>（几十行行），传统网卡驱动将数据包传递给操作系统内核中协议栈，而修改后的数据包直</p><p>接放入 Netmap_ring 供用户使用。</p><p><strong>2. Netmap API 介绍</strong></p><p><strong>1. 简要说明</strong></p><p>1.netmap API 主要为两个头文件 netmap.h 和 netmap_user.h ，当解压下载好的 netmap</p><p>程序后，在./netmap/sys/net/目录下，本文主要对这两个头文件进行分析。</p><p>2.我们从 netmap_user.h 头文件开始看起。</p><p><strong>2. likely()和 unlikely()</strong></p><p>这两个宏定义是对编译器做优化的，并不会对变量做什么改变。后面看到这两个宏的调</p><p>用自动忽略就好了。</p><pre><code>#ifndef likely#define likely(x) __builtin_expect(!!(x), 1)#define unlikely(x) __builtin_expect(!!(x), 0)#endif /* likely and unlikely */</code></pre><p><strong>3. netmap.h 头文件</strong></p><p>1.netmap.h 被 netmap_user.h 调用，里面定义了一些宏和几个主要的结构体，如</p><p>nmreq{}, netmap_if{}, netmap_ring{}, netmap_slot{}。</p><p>2.一个网卡(或者网络接口)只有一个 netmap_if{}结构，在使用 mmap()申请的共享内存中，</p><p>通过 netmap_if{}结构可以访问到任何一个发送/接收环(也就是 netmap_ring{}结构，一个</p><p>netmap_if{}可以对应多发送/接收环,这应该和物理硬件有关 ，我在虚拟机下只有一对环，在</p><p>真实主机上有两队环)。</p><p>3.找到 netmap_ring{}的地址后，我们就可以找到环中每一个 buffer 的地址(buffer 里面存</p><p>储的是将要发送/接收的数据包)。后面会讲解这是如何实现的。</p><p>4.通过一个 nifp 是如何访问到多个收/发环的，通过一个 ring 如何找到多个不同的 buffer</p><p>地址的，其实都是通过存储这些结构体相邻的后面一部分空间实现。</p><p>(申请共享内存的时候，</p><p>这些均已被设计好)</p><p><strong>4. 几个重要的宏定义</strong></p><p><strong>1._NETMAP_OFFSET</strong></p><pre><code>#define _NETMAP_OFFSET(type, ptr, offset) \ ((type)(void *)((char *)(ptr) + (offset)))</code></pre><p>解释：该宏定义的作用是将 ptr 指针(将转成 char *类型)向右偏移 offset 个字节，再将其转化</p><p>为指定的类型 type。</p><p><strong>2.NETMAP_IF</strong></p><pre><code>#define NETMAP_IF(_base, _ofs) _NETMAP_OFFSET(struct netmap_if *,_base, _ofs)</code></pre><p>解释：该宏定义将_base 指针向右偏移_ofs 个字节后，将转为 netmap_if *类型返回。在 nemap</p><p>中通过此宏得到 d->nifp 的地址。</p><p><strong>3.NETMAP_TXRING</strong></p><pre><code>#define NETMAP_TXRING(nifp, index) _NETMAP_OFFSET(struct netmap_ring*, \ nifp, (nifp)-&gt;ring_ofs[index] )</code></pre><p>解释：1.通过该宏定义，可以找到 nifp 的第 index 个发送环的地址(index 是从 0 开始的)，</p><p>ring_ofs[index]为偏移量，由内核生成。</p><p>2.其中，我们注意到 struct netmap_if{}最后面只定义了 const ssize_t ring_ofs[0]，实际</p><p>上其它的 netmap 环的偏移量都写在了该结构体后面的内存地址里面，直接访问就可以了。</p><p><strong>4.NETMAP_RXRING</strong></p><pre><code>#define NETMAP_RXRING(nifp, index) _NETMAP_OFFSET(struct netmap_ring*, \ nifp, (nifp)-&gt;ring_ofs[index + (nifp)-&gt;ni_tx_rings + 1] )</code></pre><p>解释：通过该宏定义，可以找到 nifp 的第 index 个接收环的地址，其中(nifp)->ring_ofs[]里面</p><p>的下标为 index+(nifp)->ni_tx_rings+1，正好与发送环的偏移量区间隔开 1 个。(我想这应该是</p><p>作者特意设计的)</p><p><strong>5.NETMAP_BUF</strong></p><pre><code>#define NETMAP_BUF(ring, index) \ ((char *)(ring) + (ring)-&gt;buf_ofs +((index)*(ring)-&gt;nr_buf_size))</code></pre><p>解释：1.通过该宏定义，可以找到 ring 这个环的第 index 个 buffer 的地址(buffer 里面存的酒</p><p>是我们接收/将发送的完整数据包)，每个 buffer 占的长度是 2048 字节(在(ring)->nr_buf_size</p><p>也给出了)。</p><p>2.其中(ring) ->buf_ofs 是固定的偏移量，不同的环这个值不相同，但所有的(char</p><p>*)(ring)+(ring)->buf_ofs 会指向同一个地址，也就是存放 buffer 的连续内存的开始地址</p><p>(d->buf_start 会指向该地址)。</p><p><strong>6. NETMAP_BUF_IDX</strong></p><pre><code>#define NETMAP_BUF_IDX(ring, buf) \ ( ((char *)(buf) - ((char *)(ring) + (ring)-&gt;buf_ofs) ) / \ (ring)-&gt;nr_buf_size )</code></pre><p>解释：在讲 NETMAP_BUF 的时候我们说(char *)(ring) + (ring)->buf_ofs)总会指向存放 buffer 的</p><p>起始位置(无论是哪一个环)，在这段内存中将第一个 buffer 下标标记为 0 的话，</p><p>NETMAP_BUF_IDX 计算的恰好是指针 buf 所指 buffer 的下标。</p><p>上面几个宏一时没弄懂也没关系，下面调用的时候还会提的。</p><p><strong>5. nm_open 函数</strong></p><p>1.调用 nm_open 函数时，如：nmr = nm_open("netmap:eth0", NULL, 0, NULL); nm_open()会</p><p>对传递的 ifname 指针里面的字符串进行分析，提取出网络接口名。</p><p>2.nm_open() 会 对 struct nm_desc *d 申 请 内 存 空 见 ， 并 通 过 d->fd =</p><p>open(NETMAP_DEVICE_NAME, O_RDWR);打开一个特殊的设备/dev/netmap 来创建文件描述</p><p>符 d->fd。</p><p>3.通过 ioctl(d->fd, NIOCREGIF, &d->req)语句，将 d->fd 绑定到一个特殊的接口，并对 d->req</p><p>结构体里面的成员最初始化，包括 <strong>a.</strong>在共享内存区域中 nifp 的偏移，<strong>b.</strong>共享区域的大小</p><p>nr_memsize，<strong>c.</strong>tx/rx 环的大小 nr_tx_slots/nr_rx_slots(大小为 256)，<strong>d.</strong>tx/rx 环的数量 nr_tx_rings、</p><p>nr_rx_rings(视硬件性能而定)等。</p><p>4.接着在 if ((!(new_flags & NM_OPEN_NO_MMAP) || parent) && nm_mmap(d, parent))语句</p><p>中调用 nm_mmap 函数，继续给 d 指针指向的内存赋值。</p><p><strong>6. nm_mmap 函数</strong></p><p>nm_mmap()源码：</p><pre><code>static int nm_mmap(struct nm_desc *d, const struct nm_desc *parent){//XXX TODO: check if mmap is already doneif (IS_NETMAP_DESC(parent) &amp;&amp; parent-&gt;mem &amp;&amp; parent-&gt;req.nr_arg2== d-&gt;req.nr_arg2) {/* do not mmap, inherit from parent */ D("do not mmap, inherit from parent"); d-&gt;memsize = parent-&gt;memsize; d-&gt;mem = parent-&gt;mem; } else {/* XXX TODO: 检查如果想申请的内存太大 (or there is overflow)*/ d-&gt;memsize = d-&gt;req.nr_memsize; /* 将需要申请的内存大小赋值给 d-&gt;memsize */ d-&gt;mem = mmap(0, d-&gt;memsize, PROT_WRITE | PROT_READ,MAP_SHARED, d-&gt;fd, 0); /* 申请共享内存 */if (d-&gt;mem == MAP_FAILED) {goto fail; } d-&gt;done_mmap = 1; } {struct netmap_if *nifp = NETMAP_IF(d-&gt;mem, d-&gt;req.nr_offset);/*通过 d-&gt;req.nr_offset 这个偏移量的到 nifp 的地址，NETMAP_IF 前面说过*/int i;/* *for(i=0; i&lt;=2; i++) * printf("ring_ofs[%d]:0x%x\n",i,nifp-&gt;ring_ofs[i]); //这里是我自己加的，为了手动计算收/发环的偏移量 */struct netmap_ring *r = NETMAP_RXRING(nifp,); //对 nifp，找接收包的环 r，因为 index 为 0，所以省略了 *(struct netmap_if **) (uintptr_t) &amp;(d-&gt;nifp) = nifp; //对d-&gt;nifp 赋值，虽然 d-&gt;nifp 使用 const 定义的，但对其取地址再强值类型转换后，依然可以对其指向的空间进行操作 *(struct netmap_ring **) (uintptr_t) &amp;d-&gt;some_ring = r; //桶理，对 d-&gt;some_ring 进行赋值，此处指向了第一个接受(rx)环。 //printf("buf_ofs:0x%x\n", (u_int)r-&gt;buf_ofs); *(void **) (uintptr_t) &amp;d-&gt;buf_start = NETMAP_BUF(r, 0);//计算第一个 buffer 的地址，并存入 d-&gt;buf_start 指针中 *(void **) (uintptr_t) &amp;d-&gt;buf_end = (char *) d-&gt;mem +d-&gt;memsize; //计算共享区间的最后一个地址，赋值给 d-&gt;buf_end }return 0; fail: return EINVAL;}</code></pre><p>其中：</p><p>1.nifp 为申请的共享内存首地址 d->mem 向右偏移 d->req.nr_offset(该值在调用前面的</p><p>ioctl()时得到)得到。并且一个网络接口(网卡)只对应一个 nifp。(使用宏 NETMAP_IF 计算)</p><p>2.得到的nifp 的地址，nifp 结构体里最后定义的 ring_ofs[0]以及接下来内存中的 ring_ofs[1]，</p><p>ring_ofs[2]...，这些内存中存储的是访问每一个环(tx or rx ring)的偏移量，通过这个偏移量我</p><p>们可以得到每一个环的地址(使用宏 NETMAP_RXRING/NETMAP_TXRING 进行计算)。</p><p>3.得到每个收/发环的地址了，netmap_ring 结构体最后面有一个 struct netmap_slot slot[0];，</p><p>通过 slot[0],后面内存的 slot[1],slot[2],slot[3]...,取出里面的偏移量就可以得到每一个 buffer(也</p><p>叫数据包槽)的地址了(使用宏 NETMAP_BUF 计算得到)。</p><p>到这里，netmap 如何访问到内存</p><p>槽中的每一个 buffer 的，我们都知道了。实际上 netmap 运行的数据结构就和下图描述的一</p><p>杨：</p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71252bbce52a4a66b7be3e492f68deda><p class=pgc-img-caption></p></div><p>4.在 struct nm_desc 中，nifp，some_ring，buf_start，buf_end 等指针都定义为 const 的，</p><p>但我们通过对其取地址再强转指针的方式去往这些指针指向的内存中赋值。</p><p>注:在 nm_mmap()中使用 mmap()申请共享的时候，这些数据结构里数据的设计是内核模</p><p>块就已写好了的，我们在这里其实是在做验证。</p><p><strong>7. nm_nextpkt 函数</strong></p><p>1.nm_nextpkt()是用来接收网卡上到来的数据包的函数。</p><p>2.nm_nextpkt()会将所有 rx 环都检查一遍，当发现有一个 rx 还有需要接收的数据包时，</p><p>得到这个数据包的地址，并返回。所以 nm_nextpkt()每次只能取一个数据包。</p><p>nm_nextpkt()源代码：</p><pre><code>static u_char *nm_nextpkt(struct nm_desc *d, struct nm_pkthdr *hdr){int ri = d-&gt;cur_rx_ring; //当前的接收环的编号do {/* compute current ring to use */struct netmap_ring *ring = NETMAP_RXRING(d-&gt;nifp, ri); //得到当前 rx 环的地址if (!nm_ring_empty(ring)) //判断环里是否有新到的包 { u_int i = ring-&gt;cur; //当前该访问哪个槽(buffer)了 u_int idx = ring-&gt;slot[i].buf_idx; //得到第 i 个 buffer 的下标 //printf("%d\n", idx); u_char *buf = (u_char *) NETMAP_BUF(ring, idx); //得到存有到来数据包的地址 // __builtin_prefetch(buf); hdr-&gt;ts = ring-&gt;ts; hdr-&gt;len = hdr-&gt;caplen = ring-&gt;slot[i].len; ring-&gt;cur = nm_ring_next(ring, i); //ring-&gt;cur 向后移动一位/* we could postpone advancing head if we want * to hold the buffer. This can be supported in * the future. */ ring-&gt;head = ring-&gt;cur; d-&gt;cur_rx_ring = ri; //将当前环(d-&gt;cur_rx_ring)指向第 ri个(因为可能有多个环)。return buf; //将数据包地址返回 } ri++;if (ri &gt; d-&gt;last_rx_ring) //如果 ri 超过了 rx 环的数量，则再从第一个 rx 还开始检测是否有包到来。 ri = d-&gt;first_rx_ring; } while (ri != d-&gt;cur_rx_ring);return NULL; /* 什么也没发现 */}</code></pre><p><strong>8. nm_inject 函数</strong></p><p>1.nm_inject()是用来往共享内存中写入待发送的数据包数据的。数据包经共享内存拷贝到</p><p>网卡，然后发送出去。所以 nm_inject()是用来发包的。</p><p>2.nm_inject()也会查找所有的发送环(tx 环)，找到一个可以发送的槽，就将数据包写入并</p><p>返回，所以每次函数调用也只能发送一个包。</p><p>源代码：</p><pre><code>static int nm_inject(struct nm_desc *d, const void *buf, size_t size){ u_int c, n = d-&gt;last_tx_ring - d-&gt;first_tx_ring + 1;for (c = 0; c &lt; n; c++) {/* 计算当前的环去使用(compute current ring to use) */struct netmap_ring *ring; uint32_t i, idx; uint32_t ri = d-&gt;cur_tx_ring + c; //该访问第几个 tx 环了if (ri &gt; d-&gt;last_tx_ring) //当超过访问的 tx 环的下标范围时，从头开始访问 ri = d-&gt;first_tx_ring; ring = NETMAP_TXRING(d-&gt;nifp, ri); //得到当前 tx 环的地址if (nm_ring_empty(ring)) //如果当前 tx 环是满的(ring-&gt;cur=ring-&gt;tail 表示没地方存数据包了)，就跳过 {continue; } i = ring-&gt;cur; //当前要往哪个槽(槽指向 buffer)中写入数据 idx = ring-&gt;slot[i].buf_idx; //得到这个槽相对于 buffer 起始地址(d-&gt;buf_start)的下标编号 ring-&gt;slot[i].len = size; //size 为待发送数据包的长度 nm_pkt_copy(buf, NETMAP_BUF(ring, idx), size); //将 buf 里存的数据包拷贝给 ring 这个环的第 i 个槽 d-&gt;cur_tx_ring = ri; ring-&gt;head = ring-&gt;cur = nm_ring_next(ring, i); //将 head 和cur 指向下一个槽return size; }return 0; /* 失败 */}</code></pre><p><strong>9. nm_close 函数</strong></p><p>1.nm_close 函数就是回收动态内存，回收共享内存，关闭文件描述符什么的了。</p><p>源代码：</p><pre><code>static int nm_close(struct nm_desc *d){/* * ugly trick to avoid unused warnings */static void *__xxzt[] __attribute__ ((unused)) = { (void *) nm_open, (void *) nm_inject, (void *) nm_dispatch,(void *) nm_nextpkt };if (d == NULL || d-&gt;self != d)return EINVAL;if (d-&gt;done_mmap &amp;&amp; d-&gt;mem) munmap(d-&gt;mem, d-&gt;memsize); //释放申请的共享内存if (d-&gt;fd != -1) { close(d-&gt;fd); //关闭文件描述符 } bzero(d, sizeof(*d)); //将 d 指向的空间全部置 0free(d); //释放指针 d 指向的空间return 0;}</code></pre><p><strong>3. NtyTCP 安装</strong></p><p>VMWare 编译与调试</p><p>1. 添加两个网络适配器</p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5dce24ce401743a99cceaca7ce63ca6c><p class=pgc-img-caption></p></div><p>系统启动后，</p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/304453e7d91e4db58efb0cb1c01fd4c6><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dd239c37aea9419eaf95e7089e5afed2><p class=pgc-img-caption></p></div><p>添加绑定的网卡的 IP 地址，十六进制 IP 地址，网卡相应的 MAC 地址。</p><p>代码地址</p><p>https://github.com/wangbojing/NtyTcp.git</p><p>环境编译，下面以 ubuntu server 版本为例。</p><p>先安装 netmap</p><p>Ubuntu 14.04</p><p>https://github.com/wangbojing/netmap.git</p><p>Ubuntu 16.04</p><p>https://github.com/luigirizzo/netmap.git</p><p># ./configure</p><p># make</p><p># make install</p><p>进入 ntytcp 的目录</p><p>直接 make</p><div class=pgc-img><img alt="网络编程 用户态协议栈之 TCP/IP 的设计" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8db4d48b8e2d4c3ea8416ddc3f391b47><p class=pgc-img-caption></p></div><p><br></p><p><strong>4. C10M 的问题</strong></p><p>截至目前，40gpbs、32-cores、256G RAM 的 X86 服务器在 Newegg 网站上的报价是几千</p><p>美元。实际上以这样的硬件配置来看，它完全可以处理 1000 万个以上的并发连接，如果它</p><p>们不能，那是因为你选择了错误的软件，而不是底层硬件的问题。</p><p>可以预见在接下来的 10 年里，因为 IPv6 协议下每个服务器的潜在连接数都是数以百万</p><p>级的，单机服务器处理数百万的并发连接（甚至千万）并非不可能，但我们需要重新审视目</p><p>前主流 OS 针对网络编程这一块的具体技术实现。</p><p><strong>1、解决 C10M 问题并非不可能</strong></p><p>很多人会想当然的认为，要实现 C10M（即单机千万）并发连接和处理能力，是不可能的。</p><p>不过事实并非如此，现在系统已经在用你可能不熟悉甚至激进的方式支持千万级别的并发连</p><p>接。</p><p>要知道它是如何做到的，我们首先要了解 Errata Security 的 CEO Robert Graham，以及他在</p><p>Shmoocon 2013 大会上的“天方夜谈”视频记录： C10M Defending The Internet At Scale（此</p><p>为 Yutube 视频，你懂的）。</p><p>Robert 用一种我以前从未听说的方式来很巧妙地解释了这个问题。他首先介绍了一点有关</p><p>Unix 的历史，Unix 的设计初衷并不是一般的服务器操作系统，而是电话网络的控制系统。由</p><p>于是实际传送数据的电话网络，所以在控制层和数据层之间有明确的界限。问题是我们现在</p><p>根本不应该使用 Unix 服务器作为数据层的一部分。正如设计只运行一个应用程序的服务器</p><p>内核，肯定和设计多用户的服务器内核是不同的。</p><p><strong>Robert Graham 的结论是：</strong>OS 的内核不是解决 C10M 问题的办法，恰恰相反 OS 的内核正是</p><p>导致 C10M 问题的关键所在。</p><p>这也就意味着：</p><p>不要让 OS 内核执行所有繁重的任务：将数据包处理、内存管理、处理器调度等任务从内核</p><p>转移到应用程序高效地完成，让诸如 Linux 这样的 OS 只处理控制层，数据层完全交给应用</p><p>程序来处理。</p><p>最终就是要设计这样一个系统，该系统可以处理千万级别的并发连接，它在 200 个时钟周期</p><p>内处理数据包，在 14 万个时钟周期内处理应用程序逻辑。由于一次主存储器访问就要花费</p><p>300 个时钟周期，所以这是最大限度的减少代码和缓存丢失的关键。</p><p>面向数据层的系统可以每秒处理 1 千万个数据包，面向控制层的系统，每秒只能处理 1 百万</p><p>个数据包。这似乎很极端，请记住一句老话：可扩展性是专业化的，为了做好一些事情，你</p><p>不能把性能问题外包给操作系统来解决，你必须自己做。</p><p><strong>2、回顾一下 C10K 问题</strong></p><p>10 年前，开发人员处理 C10K 可扩展性问题时，尽量避免服务器处理超过 1 万个的并</p><p>发连接。通过改进操作系统内核以及用事件驱动服务器（典型技术实现如：Nginx 和</p><p>Node）代替线程服务器（典型代表：Apache），使得这个问题已经被解决。人们用十年的</p><p>时间从 Apache 转移到可扩展服务器，在近几年，可扩展服务器的采用率增长得更快了。</p><p>以传统网络编程模型作为代表的 Apache 为例，我们来看看它在 C10K 问题上的局限表</p><p>现在哪些方面，并针对性的讨论对应的解决方法。Apache 的问题在于服务器的性能会随着</p><p>连接数的增多而变差，实际上性能和可扩展性并不是一回事。当人们谈论规模时，他们往</p><p>往是在谈论性能，但是规模和性能是不同的，比如 Apache。持续几秒的短期连接：比如快</p><p>速事务，如果每秒处理 1000 个事务，只能有约 1000 个并发连接到服务器。如果事务延长</p><p>到 10 秒，要维持每秒 1000 个事务则必须打开 1 万个并发连接。这种情况下：尽管你不顾</p><p>DoS 攻击，Apache 也会性能陡降，同时大量的下载操作也会使 Apache 崩溃。</p><p>如果每秒处理的连接从 5 千增加到 1 万，你会怎么做？比方说，你升级硬件并且提高</p><p>处理器速度到原来的 2 倍。到底发生了什么？你得到两倍的性能，但你没有得到两倍的处</p><p>理规模。每秒处理的连接可能只达到了 6000。你继续提高速度，情况也没有改善。甚至 16</p><p>倍的性能时，仍然不能处理 1 万个并发连接。所以说性能和可扩展性是不一样的。</p><p>问题在于 Apache 会创建一个 CGI 进程，然后关闭，这个步骤并没有扩展。为什么呢？</p><p>内核使用的 O(N^2)算法使服务器无法处理 1 万个并发连接。</p><p><strong>OS 内核中的两个基本问题：</strong></p><p> 连接数=线程数/进程数：当一个数据包进来，内核会遍历其所有进程以决定由哪个进程</p><p>来处理这个数据包。</p><p> 连接数=选择数/轮询次数（单线程）：同样的可扩展性问题，每个包都要走一遭列表上</p><p>所有的 socket。</p><p>通过上述针对 Apache 所表现出的问题，实际上彻底解决并发性能问题的解决方法的根</p><p>本就是改进 OS 内核使其在常数时间内查找，使线程切换时间与线程数量无关，使用一个新</p><p>的可扩展 epoll()/IOCompletionPort 常数时间去做 socket 查询。</p><p>因为线程调度并没有得到扩展，所以服务器大规模对 socket 使用 epoll 方法，这样就导</p><p>致需要使用异步编程模式，而这些编程模式正是 Nginx 和 Node 类型服务器具有的。所以当</p><p>从 Apache 迁移到 Nginx 和 Node 类型服务器时，即使在一个配置较低的服务器上增加连接</p><p>数，性能也不会突降。所以在处理 C10K 连接时，一台笔记本电脑的速度甚至超过了 16 核的</p><p>服务器。这也是前一个 10 年解决 C10K 问题的普遍方法。</p><p><strong>3、实现 C10M 意味着什么？</strong></p><p><strong>实现 10M（即 1 千万）的并发连接挑战意味着什么：</strong></p><p> <strong>1 千万的并发连接数</strong>；</p><p> <strong>100 万个连接/秒：</strong>每个连接以这个速率持续约 10 秒；</p><p> <strong>10GB/秒的连接：</strong>快速连接到互联网；</p><p> <strong>1 千万个数据包/秒：</strong>据估计目前的服务器每秒处理 50K 数据包，以后会更多；</p><p> <strong>10 微秒的延迟：</strong>可扩展服务器也许可以处理这个规模（但延迟可能会飙升）；</p><p> <strong>10 微秒的抖动：</strong>限制最大延迟；</p><p> <strong>并发 10 核技术：</strong>软件应支持更多核的服务器（通常情况下，软件能轻松扩展到四核，</p><p>服务器可以扩展到更多核，因此需要重写软件，以支持更多核的服务器）。</p><p><strong>4、为什么说实现 C10M 的挑战不在硬件而在软件？</strong></p><p><strong>1. 理由概述</strong></p><p>硬件不是 10M 问题的性能瓶颈所在处，真正的问题出在软件上，尤其是*nux 操作系统。</p><p>理由如下面这几点：</p><p><strong>首先：</strong>最初的设计是让 Unix 成为一个电话网络的控制系统，而不是成为一个服务器操</p><p>作系统。对于控制系统而言，针对的主要目标是用户和任务，而并没有针对作为协助功能的</p><p>数据处理做特别设计，也就是既没有所谓的快速路径、慢速路径，也没有各种数据服务处理</p><p>的优先级差别。</p><p><strong>其次：</strong>传统的 CPU，因为只有一个核，操作系统代码以多线程或多任务的形式来提升整</p><p>体性能。而现在，4 核、8 核、32 核、64 核和 100 核，都已经是真实存在的 CPU 芯片，如</p><p>何提高多核的性能可扩展性，是一个必须面对的问题。比如让同一任务分割在多个核心上执</p><p>行，以避免 CPU 的空闲浪费，当然，这里面要解决的技术点有任务分割、任务同步和异步</p><p>等。</p><p><strong>再次：</strong>核心缓存大小与内存速度是一个关键问题。现在，内存已经变得非常的便宜，随</p><p>便一台普通的笔记本电脑，内存至少也就是 4G 以上，高端服务器的内存上 24G 那是相当的</p><p>平常。但是，内存的访问速度仍然很慢，CPU 访问一次内存需要约 60~100 纳秒，相比很久</p><p>以前的内存访问速度，这基本没有增长多少。对于在一个带有 1GHZ 主频 CPU 的电脑硬件</p><p>里，如果要实现 10M 性能，那么平均每一个包只有 100 纳秒，如果存在两次 CPU 访问内存，</p><p>那么 10M 性能就达不到了。核心缓存，也就是 CPU L1/L2/LL Cache，虽然访问速度会快些，</p><p>但大小仍然不够，我之前接触到的高端至强，LLC 容量大小貌似也就是 12M。</p><p><strong>2. 解决思路</strong></p><p>解决这些问题的关键在于如何将功能逻辑做好恰当的划分，比如专门负责控制逻辑的控</p><p>制面和专门负责数据逻辑的数据面。数据面专门负责数据的处理，属于资源消耗的主要因素，</p><p>压力巨大，而相比如此，控制面只负责一些偶尔才有非业务逻辑，比如与外部用户的交互、</p><p>信息的统计等等。我之前接触过几种网络数据处理框架，比如 Intel 的 DPDK、6wind、windriver，</p><p>它们都针对 Linux 系统做了特别的补充设计，增加了数据面、快速路径等等特性，其性能的</p><p>提升自然是相当巨大。</p><p><strong>看一下这些高性能框架的共同特点：</strong></p><p> <strong>数据包直接传递到业务逻辑：</strong></p><p>而不是经过 Linux 内核协议栈。这是很明显的事情，因为我们知道，Linux 协议栈是复</p><p>杂和繁琐的，数据包经过它无非会导致性能的巨大下降，并且会占用大量的内存资</p><p>元，之前有同事测试过，Linux 内核要吃掉 2.5KB 内存/socket。我研究过很长一段时间</p><p>的 DPDK 源码，其提供的 82576 和 82599 网卡驱动就直接运行在应用层，将接管网卡</p><p>收到的数据包直接传递到应用层的业务逻辑里进行处理，而无需经过 Linux 内核协议</p><p>栈。当然，发往本服务器的非业务逻辑数据包还是要经过 Linux 内核协议栈的，比如</p><p>用户的 SSH 远程登录操作连接等。</p><p> <strong>多线程的核间绑定：</strong></p><p>一个具有 8 核心的设备，一般会有 1 个控制面线程和 7 个或 8 个数据面线程，每一个</p><p>线程绑定到一个处理核心（其中可能会存在一个控制面线程和一个数据面线程都绑定</p><p>到同一个处理核心的情况）。这样做的好处是最大化核心 CACHE 利用、实现无锁设</p><p>计、避免进程切换消耗等等。</p><p> <strong>内存是另外一个核心要素：</strong></p><p>常见的内存池设计必须在这里得以切实应用。有几个考虑点，首先，可以在 Linux 系统</p><p>启动时把业务所需内存直接预留出来，脱离 Linux 内核的管理。其次，Linux 一般采用 4K</p><p>每页，而我们可以采用更大内存分页，比如 2M，这样能在一定程度上减少地址转换等</p><p>的性能消耗。</p><p>3. <strong>关于 Intel 的 DPDK 框架</strong>/<strong> Netmap 开源框架</strong></p><p>随着网络技术的不断创新和市场的发展，越来越多的网络设备基础架构开始向基于通用处理</p><p>器平台的架构方向融合，期望用更低的成本和更短的产品开发周期来提供多样的网络单元和</p><p>丰富的功能，如应用处理、控制处理、包处理、信号处理等。为了适应这一新的产业趋势，</p><p>Intel 推出了基于 Intel x86 架构 DPDK (Data Plane Development Kit，数据平面开发套件) 实现</p><p>了高效灵活的包处理解决方案。经过近 6 年的发展，DPDK 已经发展成支持多种高性能网卡</p><p>和多通用处理器平台的开源软件工具包。</p><p><strong>5、解决 C10M 问题的思路总结</strong></p><p><strong>综上所述，解决 C10M 问题的关键主要是从下面几个方面入手：</strong></p><p>网卡问题</p><p><strong>网卡问题：</strong>通过内核工作效率不高</p><p><strong>解决方案：</strong>使用自己的驱动程序并管理它们，使适配器远离操作系统。</p><p>CPU 问题</p><p><strong>CPU 问题：</strong>使用传统的内核方法来协调你的应用程序是行不通的。</p><p><strong>解决方案：</strong>Linux 管理前两个 CPU，你的应用程序管理其余的 CPU，中断只发生在你允许的</p><p>CPU 上。</p><p>内存问题</p><p><strong>内存问题：</strong>内存需要特别关注，以求高效。</p><p><strong>解决方案：</strong>在系统启动时就分配大部分内存给你管理的大内存页。</p><p>以 Linux 为例，解决的思路就是将控制层交给 Linux，应用程序管理数据。应用程序与内核</p><p>之间没有交互、没有线程调度、没有系统调用、没有中断，什么都没有。 然而，你有的是</p><p>在 Linux 上运行的代码，你可以正常调试，这不是某种怪异的硬件系统，需要特定的工程师。</p><p>你需要定制的硬件在数据层提升性能，但是必须是在你熟悉的编程和开发环境上进行。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'网络','编程','用户态'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>