<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码） | 极客快訊</title><meta property="og:title" content="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/431a4fb9cb0f4359a50cfec2a27d5ebd"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4313f7a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4313f7a.html><meta property="article:published_time" content="2020-10-29T20:50:35+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:35+08:00"><meta name=Keywords content><meta name=description content="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4313f7a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><p>『运筹OR帷幄』原创</p><p><br></p><p><strong>作者：康仔</strong></p><p><br></p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/431a4fb9cb0f4359a50cfec2a27d5ebd><p class=pgc-img-caption></p></div><p>编者按：</p><p>列生成算法作为一种处理大规模线性规划问题的常用算法，在为NP-hard 问题设计启发式算法方面亦有广泛的应用，同时常与DW分解联合使用。本文从下料问题的建模方式出发，向读者展示了简单的适用于列生成算法的问题模型特征。本文将使用Python调用Gurobi实现下料问题的列生成算法求解。由于下料问题模型特性，因此省去了DW分解方法的赘述，其次基于下料问题子问题的特殊性，也省去了对普适的子问题求解方法（例如动态规划，分支定界等）的介绍，因此本文将是一篇言简意赅的列生成算法入门教程。</p><p><br></p><p>该文首次编辑于2018.1.11，本次为旧文新发。</p><p><br></p><p><strong>【编码】</strong>系列文章为<strong>『运筹OR帷幄』</strong>最新推出的版块之一，主要聚焦于经典算法的代码实现及案例可视化，或最新paper算法复现。目的是为了理论联系实际，以代码为基础让算法理论能够落地。</p><p><strong>前言：</strong></p><p>“列生成方法（Column Generation，CG）用来解决大型线性规划问题”，这是许多书中对列生成算法的描述最多的一句话，接下来的D-W分解（Dantzig-Wolfe decomposition），可能就让初学者迷迷糊糊，从理论到理论的证明并不是工科生的强项，所以我换了一个角度来简单描述一下列生成方法的一个初步使用。旅行商问题（Travelling salesman problem,TSP），车辆路径问题（Vehicle Routing Problem,VRP），车间调度问题（scheduling）等一系列组合优化问题的下界（lower bound）求解方向的论文可以查得到许多，其中也有人使用拉格朗日松弛（lagrangian relaxation）等不同的求解技术。</p><p><br></p><p>优化对象：一维下料问题</p><p>1</p><p><br></p><p>一维下料问题的 一般描述是：钢材厂（也许是木材厂，铝材厂，造纸厂，emmm..）有一批钢管数量为</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0133ce22642b4600a085e2c6ec3d8b9a><p class=pgc-img-caption></p></div><p>，长度都为</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/435901b78cae432e8dd8fff01000c885><p class=pgc-img-caption></p></div><p>；假设有</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5e2710a94189475fa089bd474672b691><p class=pgc-img-caption></p></div><p>个顾客，来钢厂下订单:每位顾客需要长度为</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b84f6a0354b647ee9c4a605f0a753784><p class=pgc-img-caption></p></div><p>（</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06625b41d89649fb80e45fe62953e5c1><p class=pgc-img-caption></p></div><p>，也就是下文切割规格 ）的钢管</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/97d328e342054c57954874e1fd06e88c><p class=pgc-img-caption></p></div><p>根，优化的目标是:如何切割钢管使得我既能满足客户的需求又使得的消耗的最少呢？</p><p><br></p><p>显然，在不加附加约束的情况下，这是一个典型的0-1整数规划(IP)，可以参见 @留德华叫兽相关介绍，例如：</p><p><strong>【学界】离散/整数/组合/非凸优化概述及其在AI的应用：http://t.cn/RohgcpT</strong></p><p>而且我们知道最差的情况是用料</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a378e6386faa482493b1350d8ce4ee42><p class=pgc-img-caption></p></div><p>，也就是我每一根都拿来切，每一根只切成</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b84f6a0354b647ee9c4a605f0a753784><p class=pgc-img-caption></p></div><p>的长度。这样是很可耻的，剩下的拿来做金箍棒吗？？所以我们得利用数学的力量！建模啊</p><p><br></p><ul class=list-paddingleft-2><li>模型1：一种直观的建模方式</li></ul><p><br></p><p>第一步：确定我们的决策变量为</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4330d5424140451ca6a76a9c28fa58fe><p class=pgc-img-caption></p></div><p>表示是否写切割钢管i, 既然是整数规划，</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4330d5424140451ca6a76a9c28fa58fe><p class=pgc-img-caption></p></div><p>的取值只能是整数。</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1aa96207af624b688edb50352a45d9fe><p class=pgc-img-caption></p></div><p>在每一根上我们不可能只切割一种</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b84f6a0354b647ee9c4a605f0a753784><p class=pgc-img-caption></p></div><p>；为确保最小浪费，所以要尽可能安排多的切割规格在一根钢管上，所以还需要添加变量</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8b6f75fe2e9f4ca3bc0844bc1767aca4><p class=pgc-img-caption></p></div><p>,表示在钢管i上切</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8b6f75fe2e9f4ca3bc0844bc1767aca4><p class=pgc-img-caption></p></div><p>次来满足客户j的需求。到此大家可能自己也把约束想出来了：</p><p>优化目标：最少的切割钢管数</p><p>约束1：不管怎样咋切，顾客的要求一定满足（他们是上帝）</p><p>约束2：我在选中的每根钢管上切割，不管安排几个切割规格，加和总不能大于我的钢管长度</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/435901b78cae432e8dd8fff01000c885><p class=pgc-img-caption></p></div><p>（巧妇难为无米之炊）</p><p>这种方式emmmmm...........不太数学，换一下</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/86767c8a0bbd4cab81ca73e2cc3bec8d><p class=pgc-img-caption></p></div><p>还是抽象？那具体到一个例子来看：</p><p>假设我的钢管长度为120米，总共有240根，现在有10个顾客，顾客的要求用Python随机生成如下：</p><p>demands = [10, 11, 11, 12, 12, 12, 10, 11, 12, 10]</p><p>lengths = [92, 59, 97, 32, 38, 55, 80, 75, 108, 57]</p><p>把上边约束写开：</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f971dade5da940098af38ded36313e8b><p class=pgc-img-caption></p></div><p>这样就比较清楚了，接下来，我们用Python2.7写调用gurobi 求解器进行求解(这个模型这么完美，一定很快得出答案！千万不要这么想，因为我们还没用列生成)，我们把程序录入</p><pre><code>#-*- coding: cp936 -*-import numpy as npimport randomfrom gurobipy import *L = 120 #最大长M =240 #总数demands =[ 10 , 11,  11 , 12 , 12 , 12 , 10 , 11 , 12 , 10]lengths = [ 92,  59  ,97 , 32,  38 , 55 , 80 , 75 ,108,  57]demands=np.array(demands )lengths =np.array(lengths)c = {}x={}mol = Model("XP")for i in range(M):    c[i] = mol.addVar(obj=1,  vtype=GRB.BINARY,name="c[%s]"%i ) #添加决策变量for i in range(10):    for j in range(M):#添加变量        x[j,i]=mol.addVar(lb=0,obj=0,  vtype=GRB.INTEGER,name="c[%s][%s]"%(j,i))for k in range(10):            coef =[1 for j in range(M) ]    var = [x[j,k] for j in range(M) ]    mol.addConstr(LinExpr(coef, var), "&gt;=", demands[k], name="demands" )for l in range(M):            coef = [lengths[i] for i in range(10)]    var = [x[l, i] for i in range(10) ]    mol.addConstr(LinExpr(coef, var), "&lt;=", L*c[l], name="withlimit" )mol.optimize()mol.printAttr('x')obj = mol.getObjective()print objfor v in mol.getVars():    print('%s %g' % (v.varName, v.x))</code></pre><p>waiting。。。。</p><p>waiting。。。。</p><p>。。。。。。</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15d3a448b7de48bd93d52c5acbf33a69><p class=pgc-img-caption></p></div><p>gurobi的求解过程</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e13d68624a1c44889b52c88a97627f5d><p class=pgc-img-caption></p></div><p>输出的最后的结果</p><p>以上截图是gurobi的log部分截图，我们找到最优了！只需要切割72根，没错，时间就是这么长1295s，我们的规模也不大，10客户都满足不了？？工厂恐怕每天不止10个客户............不要想：一定是Python的问题！你可以用C++,C, 那就是求解器gurobi的问题，你可以选用cplex,(有用的，可以对比结果)。此模型在1939 年，由前苏联经济学家 Kantorovich 给出[1]</p><ul class=list-paddingleft-2><li>对模型1的反思</li></ul><p><br></p><p>只要思想不滑坡，方法总比困难多！</p><p>如果我们这样思考：在模型1中我们算的是最小的钢管被切割数量，但是我们同时也知道了每一种切割规格被切割的次数和每一根钢管上的切割规格。我们可以把每一种钢管的切割看着成一种模式，再次建模。</p><p>举例说明：假设有4个顾客和其要求来看，其要求的长度lengths=[92, 59, 97, 32]数量是demands=[10, 11, 11, 12]我们可以列出其切割模式：</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6a0228ffc304154830b5d5cd7d6e992><p class=pgc-img-caption></p></div><p>。。。</p><p>可以看出我们只要从中找出最好的组合，问题就迎刃而解。换成数学表达形式：</p><p>用</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4330d5424140451ca6a76a9c28fa58fe><p class=pgc-img-caption></p></div><p>此时用来表示切割模式</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4c3bd844c1674448bb796b9e77afe007><p class=pgc-img-caption></p></div><p>使用的次数;</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44c4a6ef628544239f6617a35dcef7fe><p class=pgc-img-caption></p></div><p>表示在第j种模式下，第i个要求切割次数。</p><p><br></p><p>表示成矩阵形式：</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6a6076af703c4e18bcaeef89bae3969b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/727cf69f2aa84cd0831aa8127416da15><p class=pgc-img-caption></p></div><p>其第一列表示的含义第二种要求切割两次，其余的不切取0。那每一列就代表一个可行的切割方式，把所有的的列找出来，那问题就解决了。但是我们面临的问题是当我的要求是几百个客户时，它可行的列的个数是成千上万个，穷举找出所有的列是不可行的，这就是我们面临的组合爆炸问题。但还是要给出这个问题的模型</p><ul class=list-paddingleft-2><li>模型2 ：列生成初探</li></ul><p><br></p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b4d8ff9341b4517864355cb5d5cc3e1><p class=pgc-img-caption></p></div><p>当</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4330d5424140451ca6a76a9c28fa58fe><p class=pgc-img-caption></p></div><p>取正整数的时候，又是一个整数规划，这种表现形式就是我们熟知的set covering形式（参见孙小玲《整数规划》）。这个模型比上一个更为简单，但是面临的 问题是当规模较大的时候无法找到所有的列。</p><p>当我们把</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4330d5424140451ca6a76a9c28fa58fe><p class=pgc-img-caption></p></div><p>松弛以后，即让其取值为正数。模型就变成一个线性规划，对于线性规划，我们想到的就是单纯形法，从一个顶点解开始，求其检验数，迭代....思路是对的。但是单纯形法要求知道所有列，这又矛盾！所以我们要找到一种方法使得，不需要列出所有列的迭代方式就能求解。</p><p>在单纯形法和其对偶形式中：单纯形法及其对偶中，其非基变量检验数最终的表达形式</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/748fba63be2544b794a75fb2cfe37978><p class=pgc-img-caption></p></div><p>,如果</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23a58b76039748689c9fe585666c01a4><p class=pgc-img-caption></p></div><p>，此时便找到最优解，否则我们选择进基列和出基列进行换基，再次迭代（检验数有两种的表现形式，其中差一个负号，判断方式也就相反）。</p><p>所以列生成的思想：单纯形法要找到所有的N！我们想能不能不用找出所有列，我们先找到其中的一小部分可行解，计算其检验数，如果小于零，再添加一列，再求解新问题及其检验数，如果还小于零，再添加一列，往复循环，直至求到最优。我们把这种方法成为列生成方法。当只有部分可行解构成的模型时，如下所示，我们把此模型称之为限制主问题（RMP），其此时检验数的形式</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3a208c8e9b0145fe893feabd70edd158><p class=pgc-img-caption></p></div><p>,令</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39463208be0945caa7ce2d1cc487051a><p class=pgc-img-caption></p></div><p>,检验数的形式变为</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/60f2404764734c0b9676d594dc936b39><p class=pgc-img-caption></p></div><p>，在此问题中</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fbabc6116fef4ae3a422bc5602254b9a><p class=pgc-img-caption></p></div><p>为1，</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ce3b8e76c1946528a328f0ccba5947f><p class=pgc-img-caption></p></div><p>可以通过gurobi 等求解器求出。那么剩下的就是解决怎么找到可行的一列m，我们把寻找找求解可行的一列m称为求解子问题（sub-problem）。</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8fa907cde20441e09889870e43a77130><p class=pgc-img-caption></p></div><p>其中m&lt;n，以上的形式就是限制主问题，当我们求解限制主问题时，我们会得到乘子</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ce3b8e76c1946528a328f0ccba5947f><p class=pgc-img-caption></p></div><p>，子问题是什么呢？既然当我们的检验数是负的才可以添加一列，等价于我要找一个最大的</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6096f983286e4d009286a18129c51a38><p class=pgc-img-caption></p></div><p>(</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6096f983286e4d009286a18129c51a38><p class=pgc-img-caption></p></div><p>代表每一根钢管上的切割模式及其切割次数),这一列要满足的情况就是我切割要求的长度</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b84f6a0354b647ee9c4a605f0a753784><p class=pgc-img-caption></p></div><p>时，不能大于我的钢管固定长度</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/435901b78cae432e8dd8fff01000c885><p class=pgc-img-caption></p></div><p></p><p>写出子问题</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e30bc1f606c4fdd8743e86e842c4f0a><p class=pgc-img-caption></p></div><p>求出新的一列然后添加到限制主规划中，重新求解，再更新子问题，求解新的一列。</p><p>我们仍然通过一个小例子来看一下列生成算法：</p><p>假设钢管的长度是120米,有三个顾客来下单lengths=[56,78,30];demands=[50,65,80],首先，我们要建模并且给出一个可行解，最笨的可行解莫过于每一种模式只取一种</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b84f6a0354b647ee9c4a605f0a753784><p class=pgc-img-caption></p></div><p>那在RLMP模型下,</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8627b83681b14a2abc9dd12b52b6b555><p class=pgc-img-caption></p></div><p>,</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ade467e3ff8d443fa2981d243cf07940><p class=pgc-img-caption></p></div><p>,</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75ff371011a4453e830b73f29599cee8><p class=pgc-img-caption></p></div><p>=1，其余取值为0建立模型如下：</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d87768fa1c74b6ab3d59d340e4440f2><p class=pgc-img-caption></p></div><p>还是使用Python建模，gurobi求解，并且gurobi 可以通过getAttr(GRB.Attr.Pi)来获得乘子</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ce3b8e76c1946528a328f0ccba5947f><p class=pgc-img-caption></p></div><pre><code>================= RESTART: C:\gurobi752\win64\python27\m.py =================Optimize a model with 3 rows, 3 columns and 3 nonzerosIteration    Objective       Primal Inf.    Dual Inf.      Time       0    1.9500000e+02   0.000000e+00   0.000000e+00      0sSolved in 0 iterations and 0.06 secondsOptimal objective  1.950000000e+02y1 = 50y2 = 65y3 = 80Obj: 195pi: [1.0, 1.0, 1.0]&gt;&gt;&gt;</code></pre><p>接下来我们要求解子问题，看能否找到一列使得检验数为负，从而添加一列，继续优化</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dd4a4d82c9e0413b967261d1cab970cc><p class=pgc-img-caption></p></div><p>结果为：</p><pre><code>Optimize a model with 1 rows, 3 columns and 3 nonzerosIteration    Objective       Primal Inf.    Dual Inf.      Time       0    4.0000000e+00   0.000000e+00   0.000000e+00      1sSolved in 0 iterations and 1.15 secondsOptimal objective  4.000000000e+00m1 = 0m2 = 0m3 = 4Obj: 4</code></pre><p>我们找到一列新的</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e600021f53654abd825f6afbfb799e99><p class=pgc-img-caption></p></div><p>,然后计算检验数</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b98f25fd89948c0bd48e054431d8f3c><p class=pgc-img-caption></p></div><p>=1-4=-3，可以将这一列选中，添加RMP变为：</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cb5241ba01c0436b9354c1c90dce19a5><p class=pgc-img-caption></p></div><p>结果为：</p><pre><code>Optimize a model with 3 rows, 4 columns and 4 nonzerosIteration    Objective       Primal Inf.    Dual Inf.      Time       0    1.3500000e+02   0.000000e+00   0.000000e+00      0sSolved in 0 iterations and 0.03 secondsOptimal objective  1.350000000e+02y1 = 50y2 = 65y3 = 0y4 = 20Obj: 135pi: [1.0, 1.0, 0.25]</code></pre><p>再求解子问题：</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3984cd7f91eb43b4817e9fd8723e6d0a><p class=pgc-img-caption></p></div><p>结果为：</p><pre><code>Optimize a model with 1 rows, 3 columns and 3 nonzerosIteration    Objective       Primal Inf.    Dual Inf.      Time       0    2.1428571e+00   0.000000e+00   0.000000e+00      0sSolved in 0 iterations and 0.07 secondsOptimal objective  2.142857143e+00m1 = 2.14286m2 = 0m3 = 0Obj: 2.14286</code></pre><p>显然，检验数仍为负数，可以选择一列再迭代</p><p>Continue。。。</p><p>注意到我们的子问题没有让变量取整数，是因为在列生成算法中，通常需要自己设计分枝策略，所以未规定其变量为整数。</p><p>第二种模型由Gilmore 和 Gomory 分别在文章[2]、[3]、[4]中提出并使用。</p><p>现简单给出列生成算法步骤：</p><p>step1：给出模型的初始解，其解代表可行列</p><p>step2: 求解主规划（RMP）并获取乘子</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ce3b8e76c1946528a328f0ccba5947f><p class=pgc-img-caption></p></div><p>step3: 求解子问题 ，并计算</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b98f25fd89948c0bd48e054431d8f3c><p class=pgc-img-caption></p></div><p>，如果小于0，向限制主问题中添加一列求解，返回step2</p><p>step4: 若</p><div class=pgc-img><img alt="优化 | 从下料问题看整数规划中的列生成方法（附求解器源代码）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2b98f25fd89948c0bd48e054431d8f3c><p class=pgc-img-caption></p></div><p>大于等于零，停止算法，输出最优解</p><p><br></p><p>结论</p><p>2</p><p><br></p><p>但是当我们去翻看SCI中关于这方面的论文，会发现列生成方法通常结合动态规划，分支定界算法结合使用，称之为分支定价算法（branch and price）。这里我们通过一个下料问题小例子，来从另一个角度阐述了一下列生成算法的思想，绕过了DW分解的理论，但是如果想要深入研究，请从线性规划，凸优化，闵可夫斯基定理等开始看起，本文的指导思想是孙小玲教授《整数规划》，章学仁《线性规划》，钱颂迪《运筹学》参考写成，参考论文：</p><p>[1] Haessler R W. Sweeney P E. Cutting Stock Problem and Solution Procedures [J]. European Journal of Operation of Research, 1991, 54: 141-150</p><p>[2] Gilmore P C, Gomory R E. A linear programming approach to the cutting stock problem [J] Operations Research,1961, 9: 849-859.</p><p>[3] Gilmore P C, Gomory R E. A linear programming approach to the cutting stock problem [J]. Operations Research, 1963, 1:863-888.</p><p>[4] Gilmore P C, Gomory R E. Multistage cutting stock problems of two and more dimensions [J].Operations Research, 1965, 13: 94-120.</p><p>由于匆忙，难免有不足之处，恳请赐教。</p><p>对于车间调度的问题求解最优解的问题，大家使用最多的是智能算法比如遗传，模拟退火，果蝇，蝙蝠，花粉，粒子群，EDA算法等等，但是通过列生成得到的优良的下界可以对智能算法的上界进行一个良好的估计，这也是价值所在。</p><p>关于这部分内容，可以参考：</p><p><strong>【学界】整数规划精确算法/近似算法/(元)启发算法/神经网络反向传播等算法的区别与关联：http://t.cn/RlNoJ19</strong></p><blockquote><p><strong>主问题和子问题的Python 程序已上传（链接：https://pan.baidu.com/s/1jIVMNnK 密码：znru）但作者暂时没有做一键启动，以后会添加在上述链接中。</strong></p></blockquote><hr><p>审稿人 知乎ID：PhilFWu 系美国俄亥俄州立大学运筹学博士现为LLamasoft的应用科学家，专注于研究并编写路径优化问题和供应链网络优化问题的求解器；博士期间专注于随机优化，整数规划，最优控制理论，以及电力市场及电网运行策略；曾在洛斯·阿拉莫斯国家试验室研究天然气管网的控制与优化，天然气市场的重构。</p><p>知乎ID：吐服 大连海事大学物流实验室：杨敏，大连海事物流工程与管理研究生在读，研究方向为港口仿真，航线优化等。</p><p>知乎ID：浊清风 孙卓，大连海事大学物流系教授，博士生导师，从事交通物流网络优化、计算机仿真等研究。曾获由阿里巴巴、香港科技大学、美国INFORMS协会举办的菜鸟网络全球算法大赛季军。开源空间建模框架MicroCity：http://microcity.github.io/。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'下料','优化','问题'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>