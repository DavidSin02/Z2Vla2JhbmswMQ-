<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Windows内核漏洞利用教程 | 极客快訊</title><meta property="og:title" content="Windows内核漏洞利用教程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1f6c9a9254bd425e80f44d858e49e2fd"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4360e66.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4360e66.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4360e66.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4360e66.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4360e66.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4360e66.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4360e66.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4360e66.html><meta property="article:published_time" content="2020-10-29T21:08:07+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:07+08:00"><meta name=Keywords content><meta name=description content="Windows内核漏洞利用教程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4360e66.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Windows内核漏洞利用教程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>堆栈溢出漏洞</h1><p>首先，我们将从HackSysExtremeVulnerableDriver中的vanilla栈溢出漏洞开始讲起。</p><p>当向堆栈上的缓冲区存放的数据超出其存储容量时（例如，向16字节缓冲区（这里的缓冲区可以是字符数组或类似对象）中存放20个字节时），多出来的数据将会写入附近的内存中，从而覆盖或破坏堆栈。</p><p>这里的核心思想是控制溢出过程，以便可以覆盖保存在堆栈中的返回地址，并在执行当前（易受攻击的）函数后，将返回我们的覆盖值，其中存放的是相应的shellcode。</p><p>注意：在执行我们的shellcode之后，代码执行流程必须回到相应的应用程序，就这里来说，是交还给内核，否则，就会破坏应用程序。通常情况下，应用程序崩溃后，我们可以重新启动它，但是如果内核内存发生损坏的话，内核发出kernel panic，导致蓝屏死机，这是我们最不想要的。</p><p>为了解决这个问题，我们需要恢复执行路径，以便在执行shellcode之后，将执行流程返回到执行易受攻击的函数后面相应的函数。</p><p><strong>含有堆栈溢出漏洞的代码</strong></p><p>现在，我们已经了解了攻击思路，下面，让我们考察一下易受攻击的代码（位于StackOverflow.c文件中的函数TriggerStackOverflow）。首先，该函数会创建一个ULONG型数组，它可以容纳512个成员元素（在common.h头文件中，BufferSize被设置为512）。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f6c9a9254bd425e80f44d858e49e2fd><p class=pgc-img-caption>存在堆栈溢出漏洞的函数</p></div><p>然后，内核会检查缓冲区是否驻留在用户空间中，并在非分页池中为其分配内存。</p><p>完成上述操作后，内核会将数据从用户空间的缓冲区复制到内核空间的KernelBuffer中，实际上，它本质上就是一个ULONG型数组。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7666e95e98f74a809c64e2731e007899><p class=pgc-img-caption>溢出点</p></div><p><strong>堆栈溢出</strong></p><p>请大家注意RtlCopyMemory（它本质上就是memcpy）函数的第三个参数Size，它是用户空间缓冲区的长度，而非内核空间缓冲区的长度。这里就是发生缓冲区溢出的关键点。</p><p><strong>漏洞验证</strong></p><p>现在，为了验证这里是否为该漏洞的实际位置，我们将编写一个函数，让它调用函数StackOverflowIOCTLHandler的IOCTL。需要说明的是，具体IOCTL代码请参见exploit/common.h文件。</p><p>注意：我们本可以从编译后的驱动程序本身获得IOCTL代码，但是既然我们有这样的优势，为什么不用呢？</p><p><strong>什么是IOCTL代码？</strong></p><p>“I/O控制码（IOCTL）用于用户模式应用程序和驱动程序之间的通信，或用于堆栈中驱动程序之间的内部通信。I/O控制代码可以通过IRP进行发送。”——Microsoft.com</p><p>基本上，如果驱动程序具有相应的IOCTL代码，就可以直接在驱动程序中调用内核函数。</p><p>要使用IOCTL代码，我们可以借助于DeviceIoControl函数，该函数的详细说明请参阅这里。</p><p>DeviceIoControl函数的原型是：</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a7a077110ad45bab780a5e497aa62aa><p class=pgc-img-caption>DeviceIoControl函数的原型</p></div><p>我使用C++语言编写了一个函数，它可以通过DeviceIoControl来调用StackOverflowIoctlHandler，后者又会调用TriggerStackOverflow——一个含有堆栈溢出漏洞的函数。</p><p>我们知道该缓冲区是长度为512个ULONG型元素，所以，我们可以再附加由me tasploit框架中的pattern_create.rb生成的100字节模式。</p><p>最后，将这个缓冲区的内容发送到HEVD，看看会发生什么情况。</p><p>注意：这个函数位于头文件StackOverflow.h中，并且由main函数来调用它。完整的代码，请访问我的代码库。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed6dbfb0b7a8479ca63918e35c27fd02><p class=pgc-img-caption>用于利用堆栈溢出的POC</p></div><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cdce2671bb648c4aaf7da6bb5174ea8><p class=pgc-img-caption>用于利用堆栈溢出的POC</p></div><p>在Win7系统上编译并执行二进制文件后，我们可以在WinDbg中看到：</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45c524e6287b434ab6022ecb6d6fa7a4><p class=pgc-img-caption>发生在WinDbg中的崩溃</p></div><p>如您所见，这里存在访问违例，EIP指向了31624130。</p><p>利用me tasploit的pattern_offset.rb的模式之后，我们会发现其偏移量为32。下面，我们开始利用这个漏洞。</p><p><strong>堆栈溢出漏洞的利用方法</strong></p><p>为了利用这个漏洞，我们只需要用HEVD中提供的TokenStealingPayloadWin7 shellcode覆盖保存的返回地址，就可以了。</p><p>注意：为了防止崩溃，可能需要对shellcode稍加修改，这一个任务留作作业。</p><p><strong>获取Shell</strong></p><p>让我们首先检查当前身份是否为普通用户。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/da1efb4e5fab4cb7bd98adf0dfdf29c0><p class=pgc-img-caption>普通用户</p></div><p>可以看出，当前身份只是普通用户。</p><p>在运行漏洞利用代码之后，转身变为ntauthority/system用户。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4dd30d1df4e4bd8b7f205287ef6eed0><p class=pgc-img-caption>NT Authority/SYSTEMShell</p></div><p>参考资料</p><ul><li>HackSysTeam</li><li>FuzzySecurity</li></ul><h1>类型混淆漏洞</h1><p><strong>什么是类型混淆漏洞？</strong></p><p>类型混淆是这样一种漏洞，即应用程序没有验证对象的类型（函数、数据类型等），就直接按预期类型对其进行处理，所以，当传递给程序的其实是其他类型的对象时，就会出现这种类型的安全漏洞。</p><p><strong>含有类型混淆漏洞的代码</strong></p><p>现在，我们已经了解了类型混淆漏洞的概念，下面，让我们开始考察含有这种类型的漏洞的代码（位于typeconfusion.c中的函数triggerTypeConfusion中）。</p><p>首先，内核会检查缓冲区是否位于用户空间中，然后，在非分页池中为其分配内存空间。完成上述操作后，内核将objectID从用户空间缓冲区赋值给内核空间缓冲区，并对对象类型执行相同的操作。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e59b3f7998e34ddc8a91b290e9634bc7><p class=pgc-img-caption>为objectID和objectType赋值</p></div><p>之后，内核会对对象调用TypeConfusionInitializer函数（内核模式而非用户模式）。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/58e50ce924324f39963e6da5365116b2><p class=pgc-img-caption>为对象调用TypeConfusionInitializer函数</p></div><p>让我们考察一下这个函数:</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba8b6c4aecd94a75810711c13d422e2a><p class=pgc-img-caption>函数类型ConfusionobjectInitializer</p></div><p>这个函数首先接收对象，并调用对象中的函数指针。</p><p>让我们看看kernel_type_confusion_object的结构（本质上是一个结构体），它位于typeconfusion.h头文件中。这个头文件保存了用户空间对象和内核空间对象的定义，这使得该漏洞的利用方法要比堆栈溢出漏洞的利用方法更容易一些。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e732536c243e4179b9090a4c135c7f26><p class=pgc-img-caption>对象原型</p></div><p>首先，让我们看看用户模式对象中所包含的内容。实际上，这个用户模式对象是一个包含2个成员的结构体，这些成员为：</p><p>l 对象ID</p><p>l 对象类型</p><p>在内核模式对象的情况下，它也是一个包含2个成员的结构：</p><p>l 对象ID</p><p>l 第二个成员是UNION，可以保存：</p><p>1. 对象类型</p><ol><li>回调函数（函数指针）</li></ol><p>我们知道UNION变量一次只能存放一个成员，这里它可以是一个object Type，也可以是一个指向TypeConfusionInitializer函数调用的函数的指针。</p><p>当函数TriggerTypeConfusion函数没有验证第二个成员是objectType还是Callback时，就会触发类型混淆漏洞。</p><p><strong>类型混淆漏洞的利用方法</strong></p><p>为了利用这种类型的漏洞，只需传递一个结构体，并且让该结构体的第二个成员为我们想要从内核空间调用的函数的地址即可。</p><p>就这里来说，该结构体的第二个成员存放的是令牌窃取Shellcode代码的地址，以替换我们的进程的令牌，这样，当创建新进程时，将使用该令牌。</p><p>但是，需要注意的是，这里需要使用HEVD提供的shellcode（TokenStealingPayloadWin7无法正常使用，并且会导致系统崩溃）。</p><p><strong>修改shellcode</strong></p><p>由于函数TypeConfusionInitializer会调用Callback指针，既然它是一个函数，所以，我们需要设置函数的prologue和epilogue，并将ret 8改为ret。</p><p>注意：这里我将shellcode函数编译为裸函数，如果您不这样做的活，也可以直接使用提供的shellcode。之所以这么做，只是不喜欢编译器将额外的代码添加到shellcode代码中而已。</p><p>我的漏洞利用代码可以从这里下载。</p><p><strong>获得Shell</strong></p><p>让我们首先检查当前身份是否为普通用户。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/da1efb4e5fab4cb7bd98adf0dfdf29c0><p class=pgc-img-caption>普通用户</p></div><p>可以看出，当前身份只是普通用户。</p><p>运行漏洞利用代码后，我们将华丽变身为ntauthority/system用户。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c564eda56764ce29feb63bd918e852f><p class=pgc-img-caption>利用类型混淆漏洞获取SYSTEM Shell</p></div><h1><strong>整数溢出</strong></h1><p>下面，我们开始介绍如何利用HacksysExtremeVulnerableDriver中的整数溢出漏洞。</p><p><strong>什么是整数溢出漏洞？</strong></p><p>对于不了解整数溢出的人来说，听到这个名称的时候可能会非常困惑——整数怎么会溢出呢？</p><p>实际的整数是不会溢出。CPU会将整数存储在固定长度的内存空间中（注意，这里我们不会讨论堆或类似的内容）。如果您熟悉C/C++之类的编程语言的话，您可能还记得各种数据类型都具有固定的长度。</p><p>在大多数机器和操作系统上，字符变量长度为1字节，整型变量的长度为4字节。这意味着char数据类型可以保存长度为8比特的值，取值范围从0到255，如果是带符号的值，则取值范围为-128到127。整型变量也是如此，在整型变量长度为4字节的机器上，可以保存0到2的32次方-1之间的值（无符号值）。</p><p>现在，让我们考虑使用一个最大值为2的32次方-1或0xFFFFFFF的无符号整型变量。取最大值后，如果再加1，会发生什么情况呢？由于所有32位上的值均为1，因此，加1将使其变为一个长度为33位的值，但由于存储器只能容纳32位，因此这32位上的值将被设为0。</p><p>在执行上面的操作时，CPU通常会将数字加载到32位寄存器（此处指x86)中，加1时会设置进位标志，而寄存器各位的值为0，因为现在所有32位上的值都为0。</p><p>现在，如果进行长度检查，查看值的长度是否大于指定的值，比如10，则该检查将返回fail，但如果不存在长度限制，则比较操作将返回true。</p><p>为了加深理解，让我们来考察一下具体的漏洞代码：如何利用HEVD中的整数溢出漏洞来获得Windows内核中的代码执行权限。</p><p><strong>含有整数溢出漏洞的代码</strong></p><p>现在已经了解了整数溢出漏洞的相关概念，接下来，我们来分析一下含有该漏洞的代码（该漏洞位于IntegerOverflow.c中的函数TriggerIntegerOverflow中）。</p><p>首先，该函数会创建一个ULONG型数组，该数组可以存放512个成员元素（在common.h头文件中，BufferSize被设置为512）。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1fbd51c1c2a541b8bbfa35e7ea2033cf><p class=pgc-img-caption>IntegerOverflow.c中含有整数溢出漏洞的函数</p></div><p>然后，内核会检查缓冲区是否位于用户空间中，然后，它还会为我们打印一些信息。这些信息对于我们来说非常有帮助。</p><p>完成上述操作后，内核会检查数据的长度（以及终结符的长度，即4个字节）是否大于KernelBuffer的长度。如果是的话，则退出，并且不会将用户空间中的缓冲区内容拷贝到内核空间的相应缓冲区中。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4f3120064c394258a499641bd844a6c2><p class=pgc-img-caption>长度检查</p></div><p>但是，如果情况并非如此，则继续进行，并将数据复制到内核缓冲区中。</p><p>这里要注意的另一件事是，如果它在用户区缓冲区中遇到BufferTerminator，就会停止复制，并继续执行后面的代码。因此，我们需要将BufferTerminator放在用户模式缓冲区的末尾。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9c09be22a3c24e6da946ee4967ff06af><p class=pgc-img-caption>将用户空间数据复制到内核空间的函数堆栈</p></div><p><strong>整数溢出</strong></p><p>IntegerOverflow.c的第100行代码的问题在于，如果我们提供的size参数为0xFFFFFFFC，然后再加上BufferTerminator的长度（这里是4个字节），则有效长度变为：0xFFFFFFFC+ 4 = 0x00000000，即大于KernelBuffer的长度，但是，由于我们通过了数据长度的检查，所以，能够将该缓冲区内容复制到内核空间。</p><p><strong>漏洞验证</strong></p><p>现在，为了验证这个漏洞，我们将把缓冲区内容发送到HEVD，但是将0xFFFFFFFC作为缓冲区的长度进行传递。现在，我们不用设置一个巨大的缓冲区来令内核崩溃，相反，只需发送一个小型的缓冲区并确认漏洞即可。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/afa472d20c6b471dbe1f3318c20901c2><p class=pgc-img-caption>触发整数溢出的PoC</p></div><p>由于我们知道缓冲区长度为512个ULONG型元素，因此，我们可以发送这么长的数据，并查看内核的反应。</p><p>注意：这里的重点是DeviceIoControl的第4个参数，而不是实际数据。</p><p>最后，将该缓冲区内容发送到HEVD，看看到底会发生什么情况。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9711b79298c492e983e64d270483092><p class=pgc-img-caption>成功触发整数溢出漏洞</p></div><p>正如您看到的那样，UserBufferSize的值为0xFFFFFFFC，但我们仍设法绕过了长度的有效性检查并触发了整数溢出漏洞。</p><p>我们发现，通过设置0xFFFFFFFC，我们可以绕过长度检查，接下来要做的事情，就是在UserBuffer之后放置一个模式（一个唯一无二的模式），然后放置终结符，以找到保存的返回指针。</p><p>如果您不清楚该如何操作，请阅读本文的前面部分，那里有具体的介绍。</p><p>下面，我们开始介绍如何利用这个漏洞。</p><p><strong>整数溢出的利用方法</strong></p><p>下面，我们会通过HEVD提供的TokenStealingPayloadWin7 shellcode来覆盖保存的返回地址，这样，我们就大功告成了。</p><p>注意：为了避免崩溃，需要对shellcode稍作修改，这项任务留作课后作业。</p><p><strong>获得shell</strong></p><p>下面，首先来检查一下当前的身份是否为普通用户。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/da1efb4e5fab4cb7bd98adf0dfdf29c0><p class=pgc-img-caption>普通用户</p></div><p>可以看出，当前身份只是普通用户。</p><p>运行我们的漏洞代码之后，我们的身份已经变为ntauthority/system。</p><div class=pgc-img><img alt=Windows内核漏洞利用教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/79211fa98f5a4ec8a0e181357ad317de><p class=pgc-img-caption>成功利用整数溢出漏洞</p></div><p>完整的代码，大家可以从作者的代码库中下载。</p><p>参考资料</p><ul><li>HackSysTeam：https://github.com/hacksysteam</li><li>FuzzySecurity：http://www.fuzzysecurity.com/</li></ul><p>原文地址：https://pwnrip.com/windows-kernel-exploitation-part-1-stack-buffer-overflows/</p><p>白帽汇从事信息安全，专注于安全大数据、企业威胁情报。</p><p>公司产品：FOFA-网络空间安全搜索引擎、FOEYE-网络空间检索系统、NOSEC-安全讯息平台。</p><p>为您提供：网络空间测绘、企业资产收集、企业威胁情报、应急响应服务。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Windows','内核','教程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>