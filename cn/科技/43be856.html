<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>句法分析和语义理解专场｜AIS预讲会全程干货分享 | 极客快訊</title><meta property="og:title" content="句法分析和语义理解专场｜AIS预讲会全程干货分享 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/152929264899430186f589b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/43be856.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/43be856.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/43be856.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/43be856.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/43be856.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/43be856.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/43be856.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/43be856.html><meta property="article:published_time" content="2020-10-29T21:05:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:58+08:00"><meta name=Keywords content><meta name=description content="句法分析和语义理解专场｜AIS预讲会全程干货分享"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/43be856.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>句法分析和语义理解专场｜AIS预讲会全程干货分享</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>AIS （ACL、IJCAI、SIGIR） 2018</strong></p><p><strong>Session 10：Syntactic and Semantic</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152929264899430186f589b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926757540ecc280fe7><p class=pgc-img-caption></p></div><p><strong>1. 江心舟 苏州大学</strong></p><p><strong>Supervised Treebank Conversion: Data and Approaches</strong></p><p><strong>（本次AIS论文预讲会由李正华老师代替江心舟作口头报告）</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152929267598344a2366f59><p class=pgc-img-caption></p></div><p>我们的主要工作是树库转化。先介绍一下什么是依存句法分析。依存句法分析的目标就是给一个句子，然后把它上面结构化的信息标出来。它以弧为单位，就是以两个词之间的搭配关系为基本单位。搭配关系就是它们之间的语法关系，有时候可能会有一些语义信息。</p><p>这几年依存句法分析发展很快，2016年的时候，谷歌提出来一个模型提高了3个点，2017年Stanford又提出了一个模型，比谷歌又高了4个点。依存句法分析还有什么挑战可以做呢？我个人理解，第一方面是怎么样处理稍微不规范的网络文本。另外目前模型还没有把一些语义的知识、人类世界的知识融入进去，这是整个机器学习领域要去考虑的问题。但是怎么利用已有的树库让训练数据更加充分一些。</p><p>接下来我们要回答两个问题，一个问题是怎么样把不同规范的树库转化成同一个规范的树库。比如说这个句子是哈工大的规范，而我们自己定义了一个规范。这两个规范不管是依存弧的定义，还是依存关系的定义，都是不一样的。怎么样把别人的这棵树转化成自己的这棵树？这叫树库转化的问题。大家可以理解机器翻译问题，就是把一个句子转化成另外一个句子。我们这个问题实际上是怎么把一棵树转化为另外一棵树，这个问题更复杂一些。第二个问题，如果把这些不同规范的数据转换统一规范了以后，是不是真的比目前比较常用的方法能更好地帮助句法模型在目标规范上？ 这两个问题我们的工作都有一个初步的答案，是YES。</p><p>对于树库转化的问题有什么挑战呢？最重要的一个挑战就是，我们目前没有这样的数据。给一个句子，我标了两棵树，一棵树是源端规范的，另外一棵树是目标端规范的。我们把这个叫bi-tree aligned data。当没有这个数据，前人他们就用了其他的方式去做，而我们用了super-wise的方式。</p><p>第一件事就是标了一个数据，产生有两棵树句子的一个数据。不是一个句子拿来标两棵树，在哈工大数据上，我们标了1万句，本来已经有哈工大这棵树了。我们在这个基础上，用我们新的规范，再把它标了一遍，差不多标了一万句。标的过程中，是有选择地标，每个句子平均标了30%的词。</p><p>我们有一个标注平台，雇了差不多15个同学，这批数据一共花了差不多500个小时/人，总的准确率是78.6%，人和人之间弧的一致性71.5%，句子一致性43.7%。这个数据是严格的双人标注，两个人如果不一致，会有专家审核等等，让我们的数据标注质量有一个流程来控制，确保它的数据。</p><p>树库转化的任务是首先给一个句子，然后给了源端的一棵树，用源端树产生目标端树。我们任务本身核心的挑战，或者最重要的一个难点，就在于怎么样能够充分地利用源端树的信息，来指导上面目标端树的产生构建。</p><p>我们提出两种方法，一种叫pattern embedding，一种是treeLSTM。给一个弧打分，打分的时候，考虑怎么样用源端的这棵树，来指导这个弧打分的时候的分值函数。</p><p>实验结果证明了两点。第一，转化的结果，其中两种方法非常接近，结果都差不多，都非常有效，而且非常简单。另外我们把转化过的树库用了以后，Parsing性能也有比较大的提高。这就是我们的贡献，数据、方法和第一次提出来这个任务。未来我们会把其他的树库转化成我们的规范，不断地标其他的树库，希望把汉语依存分析做到非常好的效果。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1529292675698a88850387b><p class=pgc-img-caption></p></div><p><strong>2. 陈宇非 北京大学</strong></p><p><strong>Accurate SHRG-Based Semantic Parsing</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152929267600454ce4e033f><p class=pgc-img-caption></p></div><p>我们的工作做的是图结构的语义表示。什么是图结构语义表示呢？对比一下SDG和AMR，SDG是一种比较简单的图结构，建模的是词与词之间的二元关系。而AMR比SDG要复杂一些，它的思想是把不同表述方式统一起来，AMR可以把很多种形式不同的句子，只要语义相同，就可以统一成一种图结构的表示。例如一句话用主动语态和被动语态说，表面相差是很大的，但是图结构语义表示希望能把它们表示成统一的语义图。</p><p>我们论文中涉及的数据，也是一种图结构语义表示，它跟AMR比较像，图里面的节点和句子里的词并不是一一对应的。它标注的时候，先通过一种语法来得到侯选的结果，然后再进行人工消歧，所以它的标注一致度比前面的AMR高许多。</p><p>上下文无关文法是把句子描述成一种递归的形式，超边替换文法是上下文无关文法在图上面的表示。它的基本概念和刚才的上下文无关文法是同样的，首先有一个起始符号S，每一步把一条边替换成一个子图。经过一系列的替换，就可以从S个符号展开得到一个比较完整的图。</p><p>超边同步替换文法就是在句子的句法和语义之间建一个同步映射的关系。CFG每条规则都有一个与之同步的语义规则，所以在得到句法规则之后，我们就可以同步找出句法规则对应的语义规则，并进行超边替换，得到具体的语义图。但是在语料中是没有语义图生成过程的，需要通过抽取的方式得到语义图的生成过程。语法抽取过程和图展开的过程是相反的，不断地从最后得到的图中找出一个图的片段，把它缩成一条边。最后整个图被缩成一个起始符号S，我们就可以得到这个图的生成过程了，进而就可以抽出这个图的语法。</p><p>我们的解析主要是利用神经网络进行。它主要有两个步骤，第一个步骤是句法解析，第二个步骤是语义解析。句法解析即，首先有一个字符串，要得到它的句法树。第二个是语义表示，句法树里面每个节点都有它的CFG规则，要找出CFG规则对应的SHRG规则。</p><p>我们句法分析的过程主要是基于LSTM-Minus进行的。两个输出向量相减之后，会得到一个向量，向量之间就可以表示某个字符串的子串。</p><p>语义解析也很多种模型，最简单的就是基于计数的模型。我们就选择训练数据里面出现最多的语义规则。二个是基于规则向量的消歧模型，我们会把子串对应的向量和规则对应的向量拼起来，放到一个全链接网络里面得到一个分数，再选用分数最高的规则。</p><p>第三个是基于全局的模型。我在每一个节点中都选出分数最高的K个子图，经过Beam-Search操作之后，就可以得到一个考虑全局信息的语义图。这是我们的结果。可以看到我们的模型比对比模型的效果好很多。我们有三种模型，即使是最简单的基于计数的模型，也可以得到比较好的效果。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926757540ecc280fe7><p class=pgc-img-caption></p></div><p><strong>3. 陈宇非 北京大学</strong></p><p><strong>Pre-and In-parsing Models for Neural Empty Category Detection</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15292926759515da0f18a8c><p class=pgc-img-caption></p></div><p>如果大家做过句法分析的话会发现，树库除了句子之外，句之间还插入了很多空节点，这些空节点表示的含义，就是省略的主语之类的信息。我们要做的工作就是空节点检测，就是我给出一个表面的句子，这个句子里面会有一些省略的主语，怎么把这些省略的成分标出来，这个任务就是空范畴的检测。</p><p>空范畴检测方法分为三种：pre-parsing、in-parsing和post-parsing。pre-parsing是在和那个句法分析无关情况下进行空范畴的检测。in-parsing是空范畴检测和句法分析两个结合在一起。post-parsing是先得到句法分析结果，然后再进行空范畴分析。</p><p>进行空范畴分析的时候，我们要得到什么样的特征？首先第一个特征是序列的特征，空范畴的旁边可能会有什么词。还有一些比较远距离的依赖，可能有一些词和空范畴比较远，但是他们可能也会对空范畴检测有帮助。</p><p>我们提出第一个模型是一个基于序列标注的模型，因为我们已经得到原始句子，可以把空范畴依附到句子旁边。我们提出了三种模型：第一种是在词和词之间插入一些空位，把空范畴依附到空位上面。第二个是空范畴依附到下一个词上面，pre2表示的是最多会有两个连续的空范畴。第三个模型是如果有连续空范畴的话，我们可能会把它依附到前面的词或者后面的词上面。</p><p>第一种模型是在词和词之间插入了很多空位，每两个词之间都会插入空位，我们就把空范畴的标签放到空位上面。下面的模型都没有插入空位，我们把空范畴的标签放在前一个词，或者后一个词上面。</p><p>第二种模型是和依赖句法分析一起做的。首先是我们找出分数最大的句法树的过程。我们的一阶模型是对边进行建模，边可能是会有实节点和实节点之间的边，还有实节点和空节点之间的边，我们分别用一个全连接层对他们进行建模。</p><p>还有二阶的模型。它的基本元素不是边，而是两条边组成的对、比如说IJ和IK这两条边，就可以表示成IJK这个边对，我们也可以通过一个全连接层对他们进行建模。对二阶模型，我们组在2017年提出了一个动态规划算法，来进行空节点和句法分析的联合检测。</p><p>我们模型的结果是对比了LSTM-CRF序列标注模型，还有线性的序列标注模型的结果，我们可以看到LSTM-CRF模型对序列模型有很大的提升。</p><p>第二个是我们in-parsing模型的结果。因为我们的in-parsing模型是空节点检测和句法分析一起进行的，所以我们可以看到空节点检测这种方式，不仅会对空节点检测效果有提升，而且会对句法分析的结果有提升，就是空节点检测和句法分析可以互相提高对方。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152929267635351af1af32e><p class=pgc-img-caption></p></div><p><strong>4. 陈波 中科院软件所</strong></p><p><strong>Sequence-to-Action:End-to-End Semantic Graph Generation for Semantic Parsing</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15292926760365707350d97><p class=pgc-img-caption></p></div><p>首先我们简单介绍一下语义解析任务。语义解析是将自然语言句子解析成计算机可识别或可执行的语义表示，比如用逻辑表达式来表达句子的语义。这是一个语义解析的句子，自然语言句子“奥巴马出身在哪个城市”，它所对应的逻辑表达式，它的解释就是一个边的X，它的类别是城市，它与奥巴马实体之间有出身语义的关系。而我们得到一个句子的语义表示之后，我们在知识库的支撑下，就可以得到这个句子准确的答案，我们可以得到句子的准确答案，奥巴马出生的城市是火奴鲁鲁。语义解析的应用非常广泛，可以应用于自动问答等等。</p><p>现阶段语义解析面临的问题，我们觉得是传统的语义解析过于依赖于词典和文法。比如以前很多工作都致力于怎么进行词典的学习，怎么扩充词典，另外还需要定义很多组合文法。而这两年有两类语义解析的方法，它们解决传统语义解析方法面临的问题：一类是基于语义图构建的方法，这类方法是用语义图表示，这种方法的优点是不再需要组合的文法，把语义落地这部分转换成一个关系匹配的过程，不再需要词典。</p><p>另外一个现阶段比较火的序列到序列的方法，直接把句子的语义逻辑表达式序列化，把语义解析过程转换成序列-到-序列的过程，这样就可以解决语义解析的问题。这种方法同样不需要文法、词典和定义特征，整个训练过程是端到端的。</p><p>我们综合这两类方法提出Sequence-to-Action，首先我们使用语义图来表示句子的语义，不使用逻辑表达式。另外我们把语义图构建过程看成是一个动作序列，我们希望对句子进行解析，得到句子的语义图。语义图是一步一步构建过来的，我们把它的构建过程看作是一个动作序列，这样可以把整个语义解析看作是一个句子的序列到动作系列的过程，这样可以使用RNN模型进行建模。这种方法的优点，是它综合利用了语义图的语义表示能力以及像Sequence-to-Sequence模型序列预测的能力。</p><p>这种方法和之前基于语义图构建的方法对比，不需要借助于句法分析结果或者是特定的模板构建这么一个语义图，而直接使用端到端的方法生成语义图。而对比基于Sequence-to-Sequence的方法，我们使用动作编码来构建语义图、构建建模更多句法信息，同时我们考虑了生成动作之间的一些联系。就是在decode过程中，可以方便添加一些句法和语义约束用来过滤一些错误的动作。</p><p>我们方法的一个框架举个例子说明。当输入一个句子的时候，我们使用了RNN的模型，生成一个动作序列。这个动作序列可以用来构建语义图。在生成动作序列的过程中，可以添加一些约束条件，来限制可生成的动作，及时过滤掉一些错误的动作。而整个框架，首先需要定义一个动作集，这个动作集就是来建模语义图的过程。这个动作集，它比较普遍，任何一个语义图都是有一些节点、一些边组建成的，具有一定的普遍性。而具体的针对每个数据集，它的边、它的实体，它的这些信息是不同的话，可能对应的动作稍微有所不同，但是大体上类别是基于添加边、添加节点、添加类别节点等等。</p><p>而我们所使用的Sequence-to-Action模型与现阶段使用最为广泛的编码器模型没什么区别，唯一的区别是我们加入了一个控制器，用来添加一些句法约束和语义约束。</p><p>我们在编码器中加入一些句法约束和语义约束。句法约束就是保证生成的动作序列能够构建一个有效的图，所对应的语义约束保证生成的动作序列所构建的语义图，不违背知识库的约束。比如说每一条边所连接的两个节点，必须符合知识库里面的约束。还有另外一种约束，就是每个节点的类别必须是不矛盾的。</p><p>我们在三个数据集上进行了实验，分别是美国地理GeoQuery和美国航空ATIS数据集和OVERNIGHT数据集三个上面都取得了比较理想的效果。在OVERNIGHT数据集上取得了最好的效果，在GeoQuery和ATIS数据集上面取得了比较好的效果。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926757540ecc280fe7><p class=pgc-img-caption></p></div><p><strong>5. 屠可伟 上海科技大学</strong></p><p><strong>Gaussian Mixture Latent Vector Grammars</strong></p><p><strong>（该论文第一作者为赵彦鹏，AIS预讲会现场由张力文代替作口头报告）</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1529292676198717cd98029><p class=pgc-img-caption></p></div><p>成分文法分析（Constituency Parsing）旨在得到语言的结构化表示，即得到语言所对应的语法树。如右图所示，He found me 这句话，我们想要找到它的句法结构。概率上下文无关文法（Probabilistic Context Free Grammars）就是一种非常经典的方法，但是这种方法,假设文法规则的概率和其所在的上下文位置无关，有非常大的局限性。</p><p>针对这个局限性，前人提出了非常多解决方法：句法标注，即在语法树中的句法类别上标注出其父节点或者兄弟节点的句法信息；词汇标注，即在语法树中的句法类别上标注出其对应的句子成分的中心词。</p><p>之后出现了自动学习细粒度句法类别的方法，即隐变量文法（Latent Variable Grammars，LVG）。隐变量文法为每个句法类别（Nonterminal）关联一个离散隐变量，离散隐变量的取值表示具体的句法子类别(subtype)。但是这种模型对于每个原始句法类别，只能建模其有限个句法子类别。</p><p>总结以上工作，我们发现不断细化句法类别，能够得到更加精确的文法分析结果。</p><p>因此，我们提出隐向量文法（Latent Vector Grammars, LVeG），目的是建模每个 Nonterminal的无穷个subtype。LVeG将 nonterminal 关联到一个连续空间上，空间上的每个点都可以看做一个subtype。举例来说，P(0.3, 2.1)这个 subtype 生成了he，而P(0.5, 1.4)生成了me。</p><p>与之前的 LVG 做一下对比：在LVG中，每一个nonterminal都变成有限多份，假设NP只有M个subtypes，P也只有M个subtypes，rule：NP->P，它们的subtype rule 只会有M²个，然后因为我们将每个nonterminal分成无限多份，所以我们的 NP->P 也会有无限多种 subtype rule。除此之外，LVG 具有一个表示该文法规则的概率的参数；而在 LVeG 中，grammar rule 具有一个表示该文法规则权重密度的参数。</p><p>事实上，LVG 可以被看做是 LVeG 的一个特例。通过将 LVG 的离散变量取值转换为 One-hot Vectors，就可以将LVG 投影到连续空间上。组合向量文法（Compositional Vector Grammars，CVG）同样是赋予句法子类别连续向量化表示，我们能够证明该模型也是 LVeG 的一种特例。</p><p>既然 LVeG 可以被看作是LVG的一种扩展，那LVG遇到一些问题，LVeG也会遇到。如果我们直接用 CRK 对LV(e)G做 Parsing 的时间复杂度是 exponential 的，而且最终得到的是 subtype tree，但最终需要的是 unrefined parse tree。因此需要采取一些近似方法。</p><p>在这里我们采取的是max-rule parsing，这种方法针对每个句子在每个位置计算每个grammarrule 的expected count，或者说 posterior probability，然后再利用后验概率跑 CYK 算法，得到最后的结果。在LVG中计算后验概率这一步在连续空间上有可能是不可计算的，为了解决这个问题，我们提出了Gaussian Mixture LVeGs(GM-LVeGs)。GM-LVeGs 将grammmar rule 的 weight function 定义为混合高斯分布(GaussianMixture)，因为混合高斯分布对于加法，乘法，积分都是有闭式解的，所以在我们可得到求 Inside score, outside score 和 posteriorprobability 的解析解.。</p><p>GM-LVeG 的目标函数是传统的 conditional log likelihood，我们用Adam 作为优化算法，而且当高斯分布是对角高斯的时候，可以推导出梯度计算的解析解。在POS-taggng实验中，我们在WSJ数据集上以及UD的8种语言做了测试，与LVG做了比较。我们可以取得与相对较好的效果。</p><p>在Constituency Parsing 实验中，我们与LVG 和 CVG 等方法在wsj 数据集上做了比较。可以发现，不管在长度40以下的句子中，还是全部句子中，我们都能取得较好的效果。</p><p>总结一下，我们提出了一种新的框架，Latent Verctor Grammar, 将每一个nonterminal关联到一个连续空间上，并且我们证明了之前的LVG、CVG这些算法都可以看作是LVeG一种特例；之后我们还提出了GaussianMixture LVeGs。其中每个grammar rule 的 weight function定义为 Gaussian mixtures。并且提出了多项式时间的学习与推理算法，可以在POS tagging 和 constituency parsing都取得很好的效果。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926757540ecc280fe7><p class=pgc-img-caption></p></div><p><strong>6. 金晖明和朱昊 北京航空航天大学和清华大学</strong></p><p><strong>Incorporating Chinese Characters of Words for Lexical Sememe Prediction</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/152929267631546d831efd3><p class=pgc-img-caption></p></div><p>金晖明：Sememe官方的翻译叫做义元，考虑一些汉字信息的义元预测。</p><p>先给大家讲一下背后的知识，首先义元做一个定义就是最小的语义单元。义元的标注不是天然的，而是由语言学家们进行标注的，构成了一个数据库。这个是董振东和董强先生提出的知网HowNet中用到的概念，知网是广为人知的数据库。知网里面差不多2000个义元，这些义元标注了10万个词和短语，每一个词和短语有若干个意义，可能是多义的，每个意义由若干个义元组成。</p><p>义元之间有树状的结构组织，然后义元之间存在多种关系。例如“苹果”这个概念，它有两个意义，一个是一种电脑，另外是一种水果。首先它的定义是一种电脑，样式能携带。然后它是一种特定牌子、能携带的电脑，这就是“苹果”。另外一个定义就是一种水果，大家可以看到意义就是用一些特定的义元来解释这个词的含义。</p><p>我们的工作任务是义元推荐。就是用词汇的表示学习，对新词进行义元的推荐，你不知道它的义元该怎么标，你这个模型告诉他，义元该怎么标。谢若冰等之前的工作提出了两种方法，基于协同过滤和矩阵分解。这两种方法还是挺有效的，但是他们的问题是仅用了外部信息，即从大规模文本中学到的Context信息。</p><p>我们的模型是先提出使用内部信息的模型，首先是类似于协同过滤的方法。首先将字在单词中出现的位置分为前、中、后。因为字在不同的位置，可能代表不同的含义。然后根据词形的相似度进行义元的推荐。</p><p>另外矩阵分解也是把这两个矩阵进行分解，求一个最具代表性的词，因为字的歧义性比词要强，所以每一个字学习了多个Embedding，分解的时候选择一个词当中最具代表性的一个字最具代表性的Embedding，作为这个词在和义元进行比较时候的Embedding。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1529292676469b408014ed3><p class=pgc-img-caption></p></div><p>朱昊：我们现在建立了一个从汉字去推断汉字所构成的词义元的模型，这是基于一个基本假设，汉字和它所构成的词之间具有非常强的联系。仅仅使用汉字的模型，它的效果虽然不如仅仅使用上下文的模型，但也没有差特别多。更为重要的是，我们将两种模型做了很简单的集成，然后发现效果得到非常大提升。说明两种模型具有很强的互补性。我们猜测，它其实是在语料比较稀疏，出现频率比较低的词上面效果会比较好。</p><p>我们的实验也证明了这一点，当我们的词频非常低，甚至低到了只在语料中出现50次的时候，我们会发现，我们模型的效果跟高频词之间的效果相差无几，仅仅低了0.03。之前使用上下文的模型，他们的效果下降了50%。由于我们模型加入，集成模型的能力也更加鲁棒。</p><p>我们还可以更仔细地分析，究竟在哪些词上面，我们的效果做得尤其好。例如钟表匠，在语料中，尽管钟表匠出现频次比较高，但是使用上下文模型仍然没有预测出来跟时间相关的义元，而我们的模型就可以。第二个例子是奥斯卡，这样一个音译词，汉字跟词义之间不具有任何联系，我们的模型做得会相对比较差。</p><p>我们提出来了一个基于汉字来预测义元的模型，之后也会有非常多可以拓展的工作。我们的模型验证了了汉字与其构成的词之间有很强的联系，为之后使用character-level 自然语言处理模型提供了基础。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926757540ecc280fe7><p class=pgc-img-caption></p></div><p><strong>7. 罗福莉 北京大学</strong></p><p><strong>Incorporating Glosses into Neural Word Sense Disambiguation</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15292926765866d7c51e50f><p class=pgc-img-caption></p></div><p>Word SenseDisambiguation（WSD，词义消歧）是一个比较传统的NLP任务了。首先我们看一个例子，对play这个多意词，它在不同的上下文中，可能会表示不同的意思（sense）。比如说第一个句子，We played football all afternoon，这表示打球。在其他句子中还可以表示弹奏乐器和扮演角色。对于这些sense，它在字典里面都对应了一段文本的解释性的句子，通常叫做gloss。比如说对play的第一个sense的gloss是：“participate in games or sport”。对于传统的无监督的纯基于知识的方法只是依靠于多义词的上下文context和它的gloss计算一个相似度，选取最大相似度的gloss所在的sense，就是这个词在当前上下文中所对应的正确的含义。</p><p>对于传统的有监督的方法，往往只依靠于上面有标注sense的上下文context，训练的一个或者多个的分类器。（因为每个词有不同的sense，所以通常是为为每一个多义词训练一个分类器，但是neural-based的方法通常是为所有词训练一个统一的分类器）。我们这篇文章主要的工作主要的启发是：不管是labeled data，还是lexical knowledge，都是对词义消歧非常有帮助的。于是我们就想，能否用一个模型，把这两种数据都建模进去，这就是我们这篇论文主要的动机。</p><p>怎么去建模这两种知识？其实可以把它转化成阅读理解的问题。比如说对于阅读理解的问题，有一个question对应了一段document，并有一个answer。对于我们的词义消歧任务而言，document也就是这个多义词所有sense的glosses。比如说play这个单词在字典里有N个意思，对应的document就是N个sense的解释gloss句子。question就是说在当前上下文context当中，play单词到底是哪一个含义（sense）。对应的answer就是选出正确sense对应的gloss的句子编号。当把“加入知识的有监督词义消歧问题”这个问题转化成阅读理解/QA问题后，就可以利用QA一些框架去解决这个问题。经过调研和实验，我们发现memory network很适合解决这个问题。</p><p>下面看一下模型主要的架构，主要包含了4个module。Context module主要是建模的句子所的上下文的信息，把它建模成一个向量。Gloss module主要是建模的每个句子的sense的解释gloss，把每个gloss表示成一个向量。在Memory module中通过多轮（pass）不断地去计算每个gloss跟context的相似性，最后把Memory module最后一个pass的attention取出来，作为最后context跟gloss的相似度得分。最后Answer Module将这个相似度得分和context过一个MLP的得分相加，再取softmax，就得到了不同sense的概率分布，继而通过最大化交叉熵来训练整个模型。</p><p>实验过程中，我们发现由于有些gloss的句子只有几个单词，继而影响生成的gloss vector不准确。因而我们的改进模型用了上下位的词的gloss来扩充sense的信息。句子的改进是在上一个模型基础上扩充了Gloss module，用了BiLSTM来fusion上下位词的gloss的vector。</p><p>我们最好的模型相对于完全只使用标注数据的BiLSTM，提高了2.2个百分点。加入gloss的knowledge对性能提高非常明显，同时我们的模型在所有Semeval数据集上都达到了最好的效果。下面看一个Multi-pass的影响，可以看到加入了多跳的机制，可以拉大正确sense和错误sense之间的Attention值。</p><p>最后说一下未来的一些工作。我们只用到了Gloss的文本信息，还有很丰富的结构化信息在WordNet中没有用到。还有一个是我们把每个gloss直接建模成一个向量去用，在Gloss上进行更“细粒度”地跟Context进行关联度建模的是否更有意义，也值得我们深入思考和实验。</p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926757540ecc280fe7><p class=pgc-img-caption></p></div><p><strong>8. 赵露君 复旦大学</strong></p><p><strong>Neural Networks Incorporating Unlabeled and Partially-labeled Data for Cross-domain Chinese Word Segmentation</strong></p><div class=pgc-img><img alt=句法分析和语义理解专场｜AIS预讲会全程干货分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15292926766430765086242><p class=pgc-img-caption></p></div><p>首先介绍一下中文分词的任务，然后介绍一下我们的模型，最后讲一下实验的一些结果。</p><p>中文分词的东西，输入是这样一段文本，希望输出的时候，是把它分成每一个词。这个任务一般来说会建模成一个序列标注的任务，每一个字打4个标签，表示是否是词的开头、中间或者结尾，或者这个字本身就是一个词。我们主要是利用了两个语料，第一个是Unlabeled的dada，第二个是Partially-labeled data。</p><p>比如说这里“美国|总统”这样两个词，如果你是在词的中间去切，比如说“美国总”，你是非常容易预测对下一个字的，预测下一个字是“统”的概率是0.71。如果在两个词中间分开，比如说给定“美国”预测下一个字，非常难以预测对下一个字是“总”（概率是0.05）。这个概率是由language model给出的，所以说你可以通过language model来发现字之间共现的信息，这个信息对于分词是比较有帮助的。而且language model是可以用Unlabeled dada来训练的。为了把语言模型的特征更好地结合到分词里面，我们的架构中使用了gate机制，就是用GRU来实现的，把三个特征做一个融合，最后做一个分词。</p><p>第二个是利用partially-labeled data，比如说“美国总统住在白宫”，如果“总统”是一个超链接，我们可以认为这就是一个词，产生了下面的partially-labeled data。</p><p>接下来看一下我们的实验，原领域是人民日报语料（新闻领域），目标领域有四个，金融、医学、文学和计算机领域。另外一组是一个小说（诛仙）来作为目标领域，CTB5作为原领域。</p><p>我们的模型在这5个实验里面，只有一个是没有比过2017年工作，其他4个实验都达到了最好的结果。这里有一个比较奇怪的地方，我们发现在文学领域你加了partially-labeled之后，反而比不加partially-labeled效果要差。</p><p>我们来分析一下加language model跟加partially-labeled到底有什么不一样。“小周”、“田灵儿”，都是人名。我们发现BilSTM把这两个人名都分错了，加了语言模型的时候，有一个人名（“田灵儿”）就对了。我们通过分析发现，“田灵儿”是这本书的主角，她出现的次数比较多，“小周”出现的次数比较少。对于Unlabeled data来说，如果这个词出现次数越多，通过Unlabeled data 就更容易捕捉到这个词的信息。如果出现次数比较小，你直接把它partially-labeled这是一个比较好的办法。</p><p>这个实验主要是分析数据量大小对实验结果的影响，你用了unlabeled越多，效果越好。partially-labeled是不一样的，它可能是先上升，后下降。partially-labeled里面有非常非常多噪声的，导致你用的越多，后面慢慢是下降的，这是我们的分析，谢谢大家！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'句法分析','语义','专场'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>