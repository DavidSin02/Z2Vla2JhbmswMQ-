<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>redis使用场景与可重入分布式锁介绍（干货） | 极客快訊</title><meta property="og:title" content="redis使用场景与可重入分布式锁介绍（干货） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e19c82bdf324454bae6b198a62186529"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/449e7e42.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/449e7e42.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="redis使用场景与可重入分布式锁介绍（干货）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/449e7e42.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>redis使用场景与可重入分布式锁介绍（干货）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1、为什么使用</strong></p><ol start=1><li><strong>解决应用服务器的cpu和内存压力</strong></li><li><strong>减少io的读操作，减轻io的压力</strong></li><li><strong>关系型数据库的扩展性不强，难以改变表结构</strong></li></ol><p><br></p><p><strong>2、适用场景：</strong></p><ol start=1><li><strong>数据高并发的读写</strong></li><li><strong>海量数据的读写</strong></li><li><strong>对扩展性要求高的数据</strong></li></ol><p><strong>不适场景：</strong></p><ol start=1><li>需要事务支持（非关系型数据库）</li><li>基于sql结构化查询储存，关系复杂</li></ol><p><br></p><div class=pgc-img><img alt=redis使用场景与可重入分布式锁介绍（干货） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e19c82bdf324454bae6b198a62186529><p class=pgc-img-caption></p></div><p><br></p><p><strong>3：使用redis理由：</strong></p><p><br>完全基于内存所以速度很快，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件； 注意：单线程仅仅是说在网络请求这一模块上用一个请求处理客户端的请求，在持久化时它就会重开一个线程/进程去进行处理</p><p>丰富的数据类型，Redis有8种数据类型，常用的有 String、Hash、List、Set、 SortSet 这5种，都是基于键值的方式组织数据。每一种数据类型提供了非常丰富的操作命令，可以满足绝大部分需求</p><p><br></p><div class=pgc-img><img alt=redis使用场景与可重入分布式锁介绍（干货） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cac4bc0df21e476085dcd25fed7f3dac><p class=pgc-img-caption></p></div><p><strong>String</strong></p><p>字符串是最常用的数据类型，他能够存储任何类型的字符串，当然也包括二进制、JSON化的对象、甚至是Base64编码之后的图片。在Redis中一个字符串最大的容量为512MB.</p><p><strong>常规key-value缓存应用； 常规计数：微博数，粉丝数等。</strong></p><p><strong>Hash</strong></p><p>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 <strong>比如我们可以使用hash 数据结构来存储用户信息，商品信息等等。</strong></p><p><strong>List</strong></p><p>list 就是链表，Redis list的应用场景非常多，也是Redis最重要的数据结构之一，<strong>比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</strong></p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>换句话说，Redis的List实际是设计来用于实现队列，而不是用于实现类似ArrayList这样的列表的。如果你不是想要实现一个双端出入的队列，那么请尽量不要使用Redis的List数据结构。</p><p><br></p><p><strong>Set</strong></p><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p><p><strong>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程</strong>，</p><p><br></p><p><strong>Sorted Set</strong></p><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</strong></p><p><br></p><p>================================================================================</p><p><strong>可重入锁：</strong></p><p><br></p><p><strong>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</strong></p><p><br></p><div class=pgc-img><img alt=redis使用场景与可重入分布式锁介绍（干货） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ac02caba5644344b60a513b8f021d1f><p class=pgc-img-caption></p></div><p><br></p><p>1、互斥性。在任意时刻，只有一个客户端能持有锁。</p><p>2、不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</p><p>3、具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</p><p>4、解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</p><p><br></p><p><br></p><p><strong>如果你通过网络搜索分布式锁，最多的就是基于redis的了。基于redis的分布式锁得益于redis的单线程执行机制，单线程在执行上就保证了指令的顺序化，所以很大程度上降低了开发人员的思考设计成本。但是，基于redis做分布式锁难道真的这么容易吗？</strong></p><p><strong>1.超时问题</strong></p><p>在正常的业务当中，当一个线程获取到锁并且设置了锁的过期时间之后，会出现由于业务代码执行时间过长，锁由于到达超时时间自动释放的情况。自动释放之后，其他的线程就会获取到分布式锁，导致业务代码不会串行执行。如果业务上允许这样的情况偶尔发生，那程序员就开干吧，最后顶多人工干预一下，update 一下数据库。</p><p>为了避免这类情况发生，在使用redis分布式锁的时候，业务方应尽量避免长时间执行的代码任务。</p><p>如果设置锁的超时时间比较长，在一定程度上可以缓解业务代码执行时间长锁自动到期的问题，但是一旦业务代码down掉，其他等待锁的线程等待的时间会比较长，这种情况下，确保获取到锁的程序不会down 成为了主要问题。</p><p><br></p><p><strong>2.获取锁失败</strong></p><p>当锁被一个调用方获取之后，其他调用方在获取锁失败之后，是继续轮询还是直接业务失败呢？如果是继续轮询的话，同步情况下当前线程会一直处于阻塞状态，所以这里轮询的情况还是建议使用异步。</p><p><strong>3.可重入性</strong></p><p>可重入性是指已经拥有锁的客户端再次请求加锁，如果锁支持同一个客户端重复加锁，那么这个锁就是可重入的。如果基于redis的分布式锁要想支持可重入性，需要客户端封装，可以使用threadlocal存储持有锁的信息。这个封装过程会增加代码的复杂度，所以菜菜不推荐这样做。</p><p><strong>4.redis挂了</strong></p><p>如果在多个客户端获取锁的过程中，redis 挂了怎么办呢？假如一个客户端已经获取到了锁，这个时候redis挂了（假如是redis集群），其他的redis服务器会接着提供服务，这个时候其他客户端可以在新的服务器上获取到锁了，这也导致了锁意义的丢失。有兴趣的同学可以去看看<strong>RedLock</strong>，这种方案以牺牲性能的代价解决了这个问题。</p><p><strong>RedLock算法加锁步骤如下</strong></p><ol start=1><li><strong>获取当前Unix时间，以毫秒为单位。</strong></li><li><strong>依次尝试从N个实例，使用相同的key和随机值获取锁。在步骤2，当向Redis设置锁时,客户端应该设置一个网络连接和响应超时时间，这个超时时间应该小于锁的失效时间。例如你的锁自动失效时间为10秒，则超时时间应该在5-50毫秒之间。这样可以避免服务器端Redis已经挂掉的情况下，客户端还在死死地等待响应结果。如果服务器端没有在规定时间内响应，客户端应该尽快尝试另外一个Redis实例。</strong></li><li><strong>客户端使用当前时间减去开始获取锁时间（步骤1记录的时间）就得到获取锁使用的时间。当且仅当从大多数（这里是3个节点）的Redis节点都取到锁，并且使用的时间小于锁失效时间时，锁才算获取成功。</strong></li><li><strong>如果取到了锁，key的真正有效时间等于有效时间减去获取锁所使用的时间（步骤3计算的结果）。</strong></li><li><strong>如果因为某些原因，获取锁失败（没有在至少N/2+1个Redis实例取到锁或者取锁时间已经超过了有效时间），客户端应该在所有的Redis实例上进行解锁（即便某些Redis实例根本就没有加锁成功）。</strong></li></ol><p><strong>5.时钟跳跃问题</strong></p><p>在某些时候，redis的服务器时间发生的跳跃，由于锁的过期时间依赖于服务器时间，所以也会出现两个客户端同时获取到锁的情况发生。</p><p><strong>6.原子操作</strong></p><p><br>当把以上问题都有解决方案了之后，基于redis的分布式锁才可以放心使用。</p><p><br></p><p>===============================================================================</p><p><strong>Redis锁的过期时间小于业务的执行时间该如何续期？</strong></p><p>默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.</p><p><br></p><p><br></p><div class=pgc-img><img alt=redis使用场景与可重入分布式锁介绍（干货） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8669ff71344444e81b4074af6d2f09e><p class=pgc-img-caption></p></div><p><strong>1）加锁机制</strong></p><p>咱们来看上面那张图，现在某个客户端要加锁。如果该客户端面对的是一个redis cluster集群，他首先会根据hash节点选择一台机器。</p><p><strong>这里注意</strong>，仅仅只是选择一台机器！这点很关键！</p><p><strong>为啥要用lua脚本呢？</strong></p><p><strong>因为一大坨复杂的业务逻辑，可以通过封装在lua脚本中发送给redis，保证这段复杂业务逻辑执行的原子性。</strong></p><p><strong>（2）锁互斥机制</strong></p><p>那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？</p><p>此时客户端2会进入一个while循环，不停的尝试加锁。</p><p><strong>（3）watch dog自动延期机制</strong></p><p>客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？</p><p>简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。</p><p><br></p><p><strong>（4）释放锁机制</strong></p><p>如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。</p><p>其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。</p><p>===========================================================================</p><p><br></p><p><br></p><div class=pgc-img><img alt=redis使用场景与可重入分布式锁介绍（干货） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/07749b69-e545-4fa9-94c8-8aa7e2dd4b70><p class=pgc-img-caption></p></div><p>以上就是redis使用场景和redis分布式锁介绍：</p><p>记录学习，每天进步一点点的橘子大王</p><p><strong></strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'redis','场景','锁介绍'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>