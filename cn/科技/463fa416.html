<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MySQL无锁化WAL系统那些事儿 | 极客快訊</title><meta property="og:title" content="MySQL无锁化WAL系统那些事儿 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/827b597cea3c4927a30175adbb9ed922"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/463fa416.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><meta property="article:published_time" content="2020-10-29T21:09:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:58+08:00"><meta name=Keywords content><meta name=description content="MySQL无锁化WAL系统那些事儿"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/463fa416.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MySQL无锁化WAL系统那些事儿</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><h3 class=pgc-h-arrow-right><br></h3><div class=pgc-img><img alt=MySQL无锁化WAL系统那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/827b597cea3c4927a30175adbb9ed922><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>概述</h3><p>数据库系统一般采用WAL(write ahead log)技术来实现原子性和持久性，MYSQL也不例外。WAL中记录事务的更新内容，通过WAL将随机的脏页写入变成顺序的日志刷盘，可极大提升数据库写入性能，因此，WAL的写入能力决定了数据库整体性能的上限，尤其是在高并发时。</p><p>在MYSQL 8以前，写日志被保护在一把大锁之下，本来并行事务日志写入被人为串行化处理。虽简化了逻辑，但也极大限制了整体的性能表现。8.0很大的一部分工作便是将日志系统并行化。</p><h3 class=pgc-h-arrow-right>日志并行化</h3><p>日志并行化的思路也很简单：将写日志拆分为两个过程：</p><ol start=1><li>从内存log buffer中为日志预留空间</li></ol><p>2. 将日志内容拷贝至1预留的空间</p><p>而在这两个步骤中，只需要步骤1保证在多并发并发预留空间时的正确性即可，确保并发线程预留的日志空间不会交叉。一旦预留成功，步骤2各并发线程可互不干扰地执行拷贝至自己的预留空间即可，这天然可并发。</p><p>而在步骤1中也可以使用原子变量来代替代价较高锁实行预留，在mysql 8实现中，其实就两行代码：</p><pre><code>Log_handle log_buffer_reserve(log_t &amp;log, size_t len) {    ...    const sn_t start_sn = log.sn.fetch_add(len);    const sn_t end_sn = start_sn + len;    ...}</code></pre><p>可以看到，只需要一个原子变量log.sn记录当前分配的位置信息，下次分配时更新该log.sn即可，非常简洁优雅。</p><p>8.0中引入的并行日志系统虽然很美好，但是也会带来一些小麻烦，我们下面会详细描述其引入的日志空洞问题并阐述其解决方案。</p><h3 class=pgc-h-arrow-right>Log Buffer空洞问题</h3><p>Mysql 8.0中使用了无锁预分配的方式可以使MTR并行地将WAL日志写入到Log Buffer，提升性能。但这样势必会带来Redo Log Buffer的空洞问题，如下：</p><div class=pgc-img><img alt=MySQL无锁化WAL系统那些事儿 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4227f14c46a243759c49e77d338f7d57><p class=pgc-img-caption></p></div><p>上图中，3个线程分别分配了对应的redo buffer，线程1和3已经完成了wal日志内容的拷贝，而线程2则还在拷贝中，此时写入线程最多只能将thread-1的redo log写入日志文件。 为此，MySQL 8.0中引入了 <strong>Link_buf</strong> 。</p><h3 class=pgc-h-arrow-right>Link_buf原理</h3><p>Link_buf用于辅助表示其他数据结构的使用情况，在Link_buf中，如果一个索引位置index处存储的是非0值n，则表示Link_buf辅助标记的那个数据结构，从index开始后面n个元素已被占用。</p><pre><code>template &lt;typename Position = uint64_t&gt;class Link_buf { private:  ...  size_t m_capacity;  std::atomic&lt;Distance&gt; *m_links;  alignas(INNOBASE_CACHE_LINE_SIZE) std::atomic&lt;Position&gt; m_tail;};</code></pre><p>Link_buf是一个定长数组，且保证数组的每个元素的更新是原子操作的。以环形的方式复用已经释放的空间。</p><p>同时Link_buf内部维护了一个变量 m_tail 表示当前最大可达的LSN。</p><p>Innodb日志系统中为Log Buffer维护了两个Link_buf类型的变量 recent_written 和 recent_closed 。示意图如下：</p><div class=pgc-img><img alt=MySQL无锁化WAL系统那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1b02edfb4b74c96b0a59c375f5ae60c><p class=pgc-img-caption></p></div><p>上图中，共有两处日志空洞，起始的LSN为lsn1与lsn3，均有4个字节。而lsn2处的redo log已经写入，共3个字节。在 recent_written 中，lsn1开始处的4个atomic均是0，lsn3同样如此，而lsn2处开始的存储的则是3，0，0表示从该位置起的3个字节已经成功写入了redo日志。</p><p>接下来当lsn1处的空洞被填充后，Link_buf中该处对应的内容就会被设置，如下：</p><div class=pgc-img><img alt=MySQL无锁化WAL系统那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0cb803821dbb4986b9754a634a3b29e7><p class=pgc-img-caption></p></div><p>同理，当lsn3处的空洞也被填充后，状态变成下面这样：</p><div class=pgc-img><img alt=MySQL无锁化WAL系统那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de6b8c77b1e941cd99b0b09b8364ae6c><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>Link_buf实现</h3><p><strong>初始化</strong></p><pre><code>bool log_sys_init(...){    ...    log_allocate_recent_written(log);    ...}​constexpr ulong INNODB_LOG_RECENT_WRITTEN_SIZE_DEFAULT = 1024 * 1024;ulong srv_log_recent_written_size = INNODB_LOG_RECENT_WRITTEN_SIZE_DEFAULT;​static void log_allocate_recent_written(log_t &amp;log) {  // 默认值为1MB  log.recent_written = Link_buf&lt;lsn_t&gt;{srv_log_recent_written_size};}​// Link_buf构造template &lt;typename Position&gt;Link_buf&lt;Position&gt;::Link_buf(size_t capacity)    : m_capacity(capacity), m_tail(0){  ...  m_links = UT_NEW_ARRAY_NOKEY(std::atomic&lt;Distance&gt;, capacity);  for (size_t i = 0; i &lt; capacity; ++i) {    m_links[i].store(0);  }}</code></pre><p>从构造函数中可以看到，LinkBuf内核心成员是一维数组，数组的成员类型是原子类型的Distance（uint64_t），数组成员个数则由创建者决定，如Innodb中为recent_written创建的LinkBuf的数组成员个数为1MB，而为recent_closed创建的LinkBuf的数组成员个数为2MB。</p><p>同时，创建完成后会将数组的每个成员初始化为0。</p><h3 class=pgc-h-arrow-right>mtr log拷贝完成</h3><p>mtr在commit时会将其运行时产生的所有redo log拷贝至Innodb全局的redo log buffer，这借助了 mtr_write_log_t 对象来完成，且每次拷贝按照block为单位进行。需要说明的是：一个mtr中可能存在多个block来存储mtr运行时产生的redo log，每个block拷贝完成后均触发一次Link_buf的更新。</p><pre><code>struct mtr_write_log_t {  bool operator()(const mtr_buf_t::block_t *block) {    ...    // 拷贝完成后触发LinkBuf更新    log_buffer_write_completed(*log_sys, m_handle, start_lsn, end_lsn);  }}​void log_buffer_write_completed(log_t &amp;log, const Log_handle &amp;handle,                                lsn_t start_lsn, lsn_t end_lsn) {  ...  // 更新本次写入的内容范围对应的LinkBuf内特定的数组项值  log.recent_written.add_link(start_lsn, end_lsn);}​template &lt;typename Position&gt;inline size_t Link_buf&lt;Position&gt;::slot_index(Position position) const {  return position &amp; (m_capacity - 1);}​template &lt;typename Position&gt;inline void Link_buf&lt;Position&gt;::add_link(Position from, Position to) {  // 定位本次写入的内容范围所在数组项index  // 算法是将起始lsn(@from)对数组容量取模，即from % capacity  const auto index = slot_index(from);  auto &amp;slot = m_links[index];  slot.store(to - from);}</code></pre><p>在这里会找到start_lsn对应的slot，并在该slot内设置值为end_lsn - start_lsn，记录该位置处已写入的内容数量。</p><p><strong>log_advance_ready_for_write_lsn</strong></p><p>Innodb将redo log buffer内容写入日志文件时需要保证不能存在空洞，即在写入前需要获得当前最大的无空洞lsn。这同样依赖LinkBuf。在后台写日志线程 log_writer 的 log_advance_ready_for_write_lsn 函数中完成。</p><pre><code>void log_writer(log_t *log_ptr) {    ...    for (uint64_t step = 0;; ++step) {      (void)log_advance_ready_for_write_lsn(log);    }}​bool log_advance_ready_for_write_lsn(log_t &amp;log) {  const lsn_t write_lsn = log.write_lsn.load();  const auto write_max_size = srv_log_write_max_size;​  auto stop_condition = [&amp;](lsn_t prev_lsn, lsn_t next_lsn) {    return (next_lsn - write_lsn &gt;= write_max_size);  };  const lsn_t previous_lsn = log_buffer_ready_for_write_lsn(log);​  if (log.recent_written.advance_tail_until(stop_condition)) {    const lsn_t previous_lsn = log_buffer_ready_for_write_lsn(log);    return (true);  } else {    return (false);  }}</code></pre><p>这里的关键在于函数 Link_buf::advance_tail_until ，即推进Link_buf::m_tail。</p><pre><code>bool Link_buf&lt;Position&gt;::next_position(Position position, Position &amp;next) {  const auto index = slot_index(position);  auto &amp;slot = m_links[index];  const auto distance = slot.load();  next = position + distance;  return distance == 0;}​bool Link_buf&lt;Position&gt;::advance_tail_until(Stop_condition stop_condition) {  auto position = m_tail.load();  while (true) {    Position next;    bool stop = next_position(position, next);    if (stop || stop_condition(position, next)) {      break;    }    /* 回收slot */    claim_position(position);    position = next;  }  if (position &gt; m_tail.load()) {    m_tail.store(position);    return true;  } else {    return false;  }}</code></pre><p>这里的原理也比较简单，可以用下面的图来表示：</p><div class=pgc-img><img alt=MySQL无锁化WAL系统那些事儿 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29eeefb00be2484a8d7d7baec8d214d7><p class=pgc-img-caption></p></div><p>简单来说，就是从上次尾部位置(m_tail)开始，顺序遍历数组，如果该项不为0，则推进m_tail，否则意味着出现了空洞，就不能再往下推进了。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'MySQL','无锁化','WAL'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>