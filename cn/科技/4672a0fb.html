<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>牛人讲解Java可重入锁原理 | 极客快訊</title><meta property="og:title" content="牛人讲解Java可重入锁原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1535262549376823724db60"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="牛人讲解Java可重入锁原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4672a0fb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>牛人讲解Java可重入锁原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><br></h1><p><strong>一、 概述</strong></p><p>本文首先介绍Lock接口、ReentrantLock的类层次结构以及锁功能模板类AbstractQueuedSynchronizer的简单原理，然后通过分析ReentrantLock的lock方法和unlock方法，来解释ReentrantLock的内部原理，最后做一个总结。本文不涉及ReentrantLock中的条件变量。</p><p><strong>1.1、Lock接口</strong></p><p>Lock接口，是对控制并发的工具的抽象。它比使用synchronized关键词更灵活，并且能够支持条件变量。它是一种控制并发的工具，一般来说，它控制对某种共享资源的独占。也就是说，同一时间内只有一个线程可以获取这个锁并占用资源。其他线程想要获取锁，必须等待这个线程释放锁。在Java实现中的ReentrantLock就是这样的锁。另外一种锁，它可以允许多个线程读取资源，但是只能允许一个线程写入资源，ReadWriteLock就是这样一种特殊的锁，简称读写锁。下面是对Lock接口的几个方法的总体描述：</p><p>方法名称描述lock获取锁，如果锁无法获取，那么当前的线程就变为不可被调度，直到锁被获取到lockInterruptibly获取锁，除非当前线程被中断。如果获取到了锁，那么立即返回，如果获取不到，那么当前线程变得不可被调度，一直休眠直到下面两件事情发生：1、当前线程获取到了锁2、其他的线程中断了当前的线程</p><p>tryLock如果调用的时候能够获取锁，那么就获取锁并且返回true，如果当前的锁无法获取到，那么这个方法会立刻返回falsetryLcok(long time,TimeUnit unit)在指定时间内尝试获取锁如果可以获取锁，那么获取锁并且返回true，如果当前的锁无法获取，那么当前的线程变得不可被调度，直到下面三件事之一发生：1、当前线程获取到了锁2、当前线程被其他线程中断</p><p>3、指定的等待时间到了</p><p>unlock释放当前线程占用的锁newCondition返回一个与当前的锁关联的条件变量。在使用这个条件变量之前，当前线程必须占用锁。调用Condition的await方法，会在等待之前原子地释放锁，并在等待被唤醒后原子的获取锁</p><p>接下来，我们将围绕lock和unlock这两个方法，来介绍整个ReentrantLock是怎么工作的。在介绍ReentrantLock之前，我们首先来看一下ReentrantLock的类层次结构以及和它密切相关的AbstractQueuedSynchronizer</p><p><strong>1.2、ReentrantLock类层次结构</strong></p><div class=pgc-img><img alt=牛人讲解Java可重入锁原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535262549376823724db60><p class=pgc-img-caption></p></div><p>ReentrantLock实现了Lock接口，内部有三个内部类，Sync、NonfairSync、FairSync，Sync是一个抽象类型，它继承AbstractQueuedSynchronizer，这个AbstractQueuedSynchronizer是一个模板类，它实现了许多和锁相关的功能，并提供了钩子方法供用户实现，比如tryAcquire，tryRelease等。Sync实现了AbstractQueuedSynchronizer的tryRelease方法。NonfairSync和FairSync两个类继承自Sync，实现了lock方法，然后分别公平抢占和非公平抢占针对tryAcquire有不同的实现。</p><p><strong>1.3、AbstractQueuedSynchronizer</strong></p><p>首先，AbstractQueuedSynchronizer继承自AbstractOwnableSynchronizer，AbstractOwnableSynchronizer的实现很简单，它表示独占的同步器，内部使用变量exclusiveOwnerThread表示独占的线程。</p><p>其次，AbstractQueuedSynchronizer内部使用CLH锁队列来将并发执行变成串行执行。整个队列是一个双向链表。每个CLH锁队列的节点，会保存前一个节点和后一个节点的引用，当前节点对应的线程，以及一个状态。这个状态用来表明该线程是否应该block。当节点的前一个节点被释放的时候，当前节点就被唤醒，成为头部。新加入的节点会放在队列尾部。</p><p><strong>二、 非公平锁的lock方法</strong></p><p><strong>2.1、lock方法流程图</strong></p><div class=pgc-img><img alt=牛人讲解Java可重入锁原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535262549148d5cacea56e><p class=pgc-img-caption></p></div><p><strong>2.2、lock方法详细描述</strong></p><p>1、在初始化ReentrantLock的时候，如果我们不传参数是否公平，那么默认使用非公平锁，也就是NonfairSync。</p><p>2、当我们调用ReentrantLock的lock方法的时候，实际上是调用了NonfairSync的lock方法，这个方法先用CAS操作，去尝试抢占该锁。如果成功，就把当前线程设置在这个锁上，表示抢占成功。如果失败，则调用acquire模板方法，等待抢占。代码如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>static final <strong>class</strong> NonfairSync <strong>extends</strong> Sync {</p><p>final <strong>void</strong> lock() {</p><p><strong>if</strong> (compareAndSetState(0, 1))</p><p>setExclusiveOwnerThread(Thread.currentThread());</p><p><strong>else</strong></p><p>acquire(1);</p><p>}</p><p>protected final <strong>boolean</strong> tryAcquire(<strong>int</strong> acquires) {</p><p><strong>return</strong> nonfairTryAcquire(acquires);</p><p>}</p><p>}</p><p>3、调用acquire(1)实际上使用的是AbstractQueuedSynchronizer的acquire方法，它是一套锁抢占的模板，总体原理是先去尝试获取锁，如果没有获取成功，就在CLH队列中增加一个当前线程的节点，表示等待抢占。然后进入CLH队列的抢占模式，进入的时候也会去执行一次获取锁的操作，如果还是获取不到，就调用LockSupport.park将当前线程挂起。那么当前线程什么时候会被唤醒呢？当持有锁的那个线程调用unlock的时候，会将CLH队列的头节点的下一个节点上的线程唤醒，调用的是LockSupport.unpark方法。acquire代码比较简单，具体如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>public final <strong>void</strong> acquire(<strong>int</strong> arg) {</p><p><strong>if</strong> (!tryAcquire(arg) &&</p><p>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</p><p>selfInterrupt();</p><p>}</p><p>3.1、acquire方法内部先使用tryAcquire这个钩子方法去尝试再次获取锁，这个方法在NonfairSync这个类中其实就是使用了nonfairTryAcquire，具体实现原理是先比较当前锁的状态是否是0，如果是0，则尝试去原子抢占这个锁（设置状态为1，然后把当前线程设置成独占线程），如果当前锁的状态不是0，就去比较当前线程和占用锁的线程是不是一个线程，如果是，会去增加状态变量的值，从这里看出可重入锁之所以可重入，就是同一个线程可以反复使用它占用的锁。如果以上两种情况都不通过，则返回失败false。代码如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>final <strong>boolean</strong> nonfairTryAcquire(<strong>int</strong> acquires) {</p><p>final Thread current = Thread.currentThread();</p><p><strong>int</strong> c = getState();</p><p><strong>if</strong> (c == 0) {</p><p><strong>if</strong> (compareAndSetState(0, acquires)) {</p><p>setExclusiveOwnerThread(current);</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p>}</p><p><strong>else</strong> <strong>if</strong> (current == getExclusiveOwnerThread()) {</p><p><strong>int</strong> nextc = c + acquires;</p><p><strong>if</strong> (nextc &lt; 0) // overflow</p><p><strong>throw</strong> <strong>new</strong> Error("Maximum lock count exceeded");</p><p>setState(nextc);</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>3.2、tryAcquire一旦返回false，就会则进入acquireQueued流程，也就是基于CLH队列的抢占模式：</p><p>3.2.1、首先，在CLH锁队列尾部增加一个等待节点，这个节点保存了当前线程，通过调用addWaiter实现，这里需要考虑初始化的情况，在第一个等待节点进入的时候，需要初始化一个头节点然后把当前节点加入到尾部，后续则直接在尾部加入节点就行了。</p><p>代码如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>private Node addWaiter(Node mode) {</p><p>// 初始化一个节点，这个节点保存当前线程</p><p>Node node = <strong>new</strong> Node(Thread.currentThread(), mode);</p><p>// 当CLH队列不为空的视乎，直接在队列尾部插入一个节点</p><p>Node pred = tail;</p><p><strong>if</strong> (pred != <strong>null</strong>) {</p><p>node.prev = pred;</p><p><strong>if</strong> (compareAndSetTail(pred, node)) {</p><p>pred.next = node;</p><p><strong>return</strong> node;</p><p>}</p><p>}</p><p>// 当CLH队列为空的时候，调用enq方法初始化队列</p><p>enq(node);</p><p><strong>return</strong> node;</p><p>}</p><p>private Node enq(final Node node) {</p><p><strong>for</strong> (;;) {</p><p>Node t = tail;</p><p><strong>if</strong> (t == <strong>null</strong>) { // 初始化节点，头尾都指向一个空节点</p><p><strong>if</strong> (compareAndSetHead(<strong>new</strong> Node()))</p><p>tail = head;</p><p>} <strong>else</strong> {// 考虑并发初始化</p><p>node.prev = t;</p><p><strong>if</strong> (compareAndSetTail(t, node)) {</p><p>t.next = node;</p><p><strong>return</strong> t;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>3.2.2、将节点增加到CLH队列后，进入acquireQueued方法。</p><p>首先，外层是一个无限for循环，如果当前节点是头节点的下个节点，并且通过tryAcquire获取到了锁，说明头节点已经释放了锁，当前线程是被头节点那个线程唤醒的，这时候就可以将当前节点设置成头节点，并且将failed标记设置成false，然后返回。至于上一个节点，它的next变量被设置为null，在下次GC的时候会清理掉。</p><p>如果本次循环没有获取到锁，就进入线程挂起阶段，也就是shouldParkAfterFailedAcquire这个方法。</p><p>代码如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>final <strong>boolean</strong> acquireQueued(final Node node, <strong>int</strong> arg) {</p><p><strong>boolean</strong> failed = <strong>true</strong>;</p><p><strong>try</strong> {</p><p><strong>boolean</strong> interrupted = <strong>false</strong>;</p><p><strong>for</strong> (;;) {</p><p>final Node p = node.predecessor();</p><p><strong>if</strong> (p == head && tryAcquire(arg)) {</p><p>setHead(node);</p><p>p.next = <strong>null</strong>; // help GC</p><p>failed = <strong>false</strong>;</p><p><strong>return</strong> interrupted;</p><p>}</p><p><strong>if</strong> (shouldParkAfterFailedAcquire(p, node) &&</p><p>parkAndCheckInterrupt())</p><p>interrupted = <strong>true</strong>;</p><p>}</p><p>} <strong>finally</strong> {</p><p><strong>if</strong> (failed)</p><p>cancelAcquire(node);</p><p>}</p><p>}</p><p>3.2.3、如果尝试获取锁失败，就会进入shouldParkAfterFailedAcquire方法，会判断当前线程是否挂起，如果前一个节点已经是SIGNAL状态，则当前线程需要挂起。如果前一个节点是取消状态，则需要将取消节点从队列移除。如果前一个节点状态是其他状态，则尝试设置成SIGNAL状态，并返回不需要挂起，从而进行第二次抢占。完成上面的事后进入挂起阶段。</p><p>代码如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>private static <strong>boolean</strong> shouldParkAfterFailedAcquire(Node pred, Node node) {</p><p><strong>int</strong> ws = pred.waitStatus;</p><p><strong>if</strong> (ws == Node.SIGNAL)</p><p>//</p><p><strong>return</strong> <strong>true</strong>;</p><p><strong>if</strong> (ws > 0) {</p><p>//</p><p><strong>do</strong> {</p><p>node.prev = pred = pred.prev;</p><p>} <strong>while</strong> (pred.waitStatus > 0);</p><p>pred.next = node;</p><p>} <strong>else</strong> {</p><p>//</p><p>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>3.2.4、当进入挂起阶段，会进入parkAndCheckInterrupt方法，则会调用LockSupport.park(this)将当前线程挂起。代码：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>private final <strong>boolean</strong> parkAndCheckInterrupt() {</p><p>LockSupport.park(<strong>this</strong>);</p><p><strong>return</strong> Thread.interrupted();</p><p>}</p><p><strong>三、 非公平锁的unlock方法</strong></p><p><strong>3.1、unlock方法的活动图</strong></p><div class=pgc-img><img alt=牛人讲解Java可重入锁原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535262549396988e364ba9><p class=pgc-img-caption></p></div><p><strong>3.2、unlock方法详细描述</strong></p><p>1、调用unlock方法，其实是直接调用AbstractQueuedSynchronizer的release操作。</p><p>2、进入release方法，内部先尝试tryRelease操作,主要是去除锁的独占线程，然后将状态减一，这里减一主要是考虑到可重入锁可能自身会多次占用锁，只有当状态变成0，才表示完全释放了锁。</p><p>3、一旦tryRelease成功，则将CHL队列的头节点的状态设置为0，然后唤醒下一个非取消的节点线程。</p><p>4、一旦下一个节点的线程被唤醒，被唤醒的线程就会进入acquireQueued代码流程中，去获取锁。</p><p>具体代码如下：</p><p>unlock代码：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>public <strong>void</strong> unlock() {</p><p>sync.release(1);</p><p>}</p><p>release方法代码：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>public final <strong>boolean</strong> release(<strong>int</strong> arg) {</p><p><strong>if</strong> (tryRelease(arg)) {</p><p>Node h = head;</p><p><strong>if</strong> (h != <strong>null</strong> && h.waitStatus != 0)</p><p>unparkSuccessor(h);</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>Sync中通用的tryRelease方法代码：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>protected final <strong>boolean</strong> tryRelease(<strong>int</strong> releases) {</p><p><strong>int</strong> c = getState() - releases;</p><p><strong>if</strong> (Thread.currentThread() != getExclusiveOwnerThread())</p><p><strong>throw</strong> <strong>new</strong> IllegalMonitorStateException();</p><p><strong>boolean</strong> free = <strong>false</strong>;</p><p><strong>if</strong> (c == 0) {</p><p>free = <strong>true</strong>;</p><p>setExclusiveOwnerThread(<strong>null</strong>);</p><p>}</p><p>setState(c);</p><p><strong>return</strong> free;</p><p>}</p><p>unparkSuccessor代码：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>private <strong>void</strong> unparkSuccessor(Node node) {</p><p><strong>int</strong> ws = node.waitStatus;</p><p><strong>if</strong> (ws &lt; 0)</p><p>compareAndSetWaitStatus(node, ws, 0);</p><p>Node s = node.next;</p><p><strong>if</strong> (s == <strong>null</strong> || s.waitStatus > 0) {</p><p>s = <strong>null</strong>;</p><p><strong>for</strong> (Node t = tail; t != <strong>null</strong> && t != node; t = t.prev)</p><p><strong>if</strong> (t.waitStatus &lt;= 0)</p><p>s = t;</p><p>}</p><p><strong>if</strong> (s != <strong>null</strong>)</p><p>LockSupport.unpark(s.thread);</p><p>}</p><p><strong>四、 公平锁和非公平锁的区别</strong></p><p>公平锁和非公平锁，在CHL队列抢占模式上都是一致的，也就是在进入acquireQueued这个方法之后都一样，它们的区别在初次抢占上有区别，也就是tryAcquire上的区别，下面是两者内部调用关系的简图：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>NonfairSync</p><p>lock —> compareAndSetState</p><p>| —> setExclusiveOwnerThread</p><p>—> accquire</p><p>| —> tryAcquire</p><p>|—>nonfairTryAcquire</p><p>|—> acquireQueued</p><p>FairSync</p><p>lock —> acquire</p><p>| —> tryAcquire</p><p>|—>!hasQueuePredecessors</p><p>|—>compareAndSetState</p><p>|—>setExclusiveOwnerThread</p><p>|—> acquireQueued</p><p>真正的区别就是公平锁多了hasQueuePredecessors这个方法，这个方法用于判断CHL队列中是否有节点，对于公平锁，如果CHL队列有节点，则新进入竞争的线程一定要在CHL上排队，而非公平锁则是无视CHL队列中的节点，直接进行竞争抢占，这就有可能导致CHL队列上的节点永远获取不到锁，这就是非公平锁之所以不公平的原因。</p><p><strong>五、 总结</strong></p><p>线程使用ReentrantLock获取锁分为两个阶段，第一个阶段是初次竞争，第二个阶段是基于CHL队列的竞争。在初次竞争的时候是否考虑队列节点直接区分出了公平锁和非公平锁。在基于CHL队列的锁竞争中，依靠CAS操作保证原子操作，依靠LockSupport来做线程的挂起和唤醒，使用队列来保证并发执行变成了串行执行，从而消除了并发所带来的问题。总体来说，ReentrantLock是一个比较轻量级的锁，而且使用面向对象的思想去实现了锁的功能，比原来的synchronized关键字更加好理解。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'讲解','Java','可重'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>