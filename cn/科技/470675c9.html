<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你真的懂 Java 的内存管理和引用类型吗？ | 极客快訊</title><meta property="og:title" content="你真的懂 Java 的内存管理和引用类型吗？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/5b5c00020eae480adb96"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/470675c9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="你真的懂 Java 的内存管理和引用类型吗？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/470675c9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你真的懂 Java 的内存管理和引用类型吗？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>对于 Java 程序员来说，在 Java 虚拟机自动内存管理机制的帮助下，不再需要为每一个 new 操作去写对应的 delete/free 代码，不容易出现内存泄露和内存溢出的问题。不过，也正是因为 Java 程序员把内存控制的权力交给了 Java 虚拟机，一旦出现内存泄露和内存溢出的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会非常艰难。</p><p>本文将会对 Java 的内存管理以及四种引用类型，做一个总结。</p><h1><strong>一、Java 内存管理</strong></h1><p>Java 内存管理就是对象的分配和释放问题。在 Java 中，内存的分配是由「程序」完成的，而内存的释放是由 Java 垃圾回收器（GC）完成的，这种方式确实简化了程序员的工作，但也同时加重了 JVM 的工作。这也是 Java 程序运行速度较慢的原因之一。</p><p>为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，监控对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p><p><strong>1、Java 内存分配策略</strong></p><p>Java 程序运行时的内存分配策略有三种，分别是静态分配、栈式分配和堆式分配，三种方式所使用的内存空间分别是静态存储区（方法区）、栈区和堆区。</p><p><strong>静态存储区（方法区）：</strong>主要存放静态变量。这块「内存」在程序编译时就已经分配好了，并且在程序整个运行期间都存在。</p><p><strong>栈区：</strong>当方法被执行时，方法体内的局部变量（包括基础数据类型、对象的引用）都在栈上创建，并在方法执行结束时。这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><p><strong>堆区：</strong>又称动态内存分配，通常就是指程序运行时直接 new 出来的内存，也就是对象的实例，这部分「内存」在不使用时将会被 Java 垃圾回收器来负责回收。</p><p><strong>下面通过一个例子，来详细说明一下：</strong></p><p>public class Sample {</p><p>int s1 = 0;</p><p>Sample mSample1 = new Sample();</p><p>public void method() {</p><p>int s2 = 1;</p><p>Sample mSample2 = new Sample();</p><p>}</p><p>}</p><p>Sample mSample3 = new Sample();</p><p>Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。mSample3 指向的对象实体存放于堆上，包括这个对象的所有成员变量 s1 和 mSample1，但它的引用变量是存在于栈中的。</p><h1><strong>结论：</strong></h1><p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储在堆中 —— 因为他们属于方法中的变量，生命周期随方法而结束</p><p>成员变量全部存储于堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被 new 出来使用的</p><p><img alt="你真的懂 Java 的内存管理和引用类型吗？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/5b5c00020eae480adb96></p><h1><strong>2、Java 垃圾回收器</strong></h1><p>在 Java 堆和静态存储区（方法区）中，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾回收器所关注的便是这部分的内存。</p><p><strong>2.1 判断对象是否存活的方法</strong></p><p>在堆里面存放着 Java 世界中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确定这些对象之中哪些还「存活」着，哪些已经「死去」。</p><p><strong>引用计数算法</strong></p><p>给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加 1，当引用失效</p><p>时，就减 1。任何时刻计数器为 0 的对象就是不可能再被使用的。</p><p>引用计数算法的实现比较简单，判定效率也很高，在大部分情况下它都是一个不错的算法。但是，至少主流的 Java 虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互循环引用的问题。</p><p><strong>可达性分析算法</strong></p><p>在主流的商用程序语言（Java、C#）的主流实现中，都是称通过可达性分析来判定对象是否存活的。这个算法的基本思想就是通过一系列的称为「GC Roots」的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p><p><strong>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</strong></p><p>虚拟机栈（栈帧中的本地变量表）中引用的对象</p><p>方法区中类静态属性引用的对象</p><p>方法区中常量引用的对象</p><p>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</p><h1><strong>2.2 垃圾收集算法</strong></h1><p><strong>标记 — 清除算法</strong></p><p>最基础的收集算法就是「标记 — 清除」（Mark - Sweep）算法，如同它的名字一样，算法分为「标记」和「清除」两个阶段：</p><p>标记出所有需要回收的对象</p><p>在标记完成后统一回收所有被标记的对象</p><p>之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其不足进行改进而得到的。它的主要不足主要有两个：</p><p>效率问题，标记和清除两个过程的效率都不高</p><p>空间问题，标记清除之后会产生大量不连续的内存碎片</p><p>内存碎片太多，可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p><p><strong>复制算法</strong></p><p>为了解决效率问题，一种称为「复制」的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为原来的一半。</p><p><strong>标记 — 整理算法</strong></p><p>复制算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50 % 的空间，就需要有额外的空间进行担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，提出了另一种「标记 — 整理」算法，标记过程仍然与「标记 — 清理」算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存。</p><p><strong>分代收集算法</strong></p><p>当前商业虚拟机的垃圾收集都采用「分代收集」算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。</p><p>在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集，而老年代中因为对象存活率高、没有额外空间对它进行担保，就必须采用「标记 — 清理」或者「标记 — 整理」算法来回收。</p><h1><strong>二、Java 的引用类型</strong></h1><p>在 JDK 1.2 以前，Java 中引用的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。一个对象在这种定义下只有被引用或没有被引用两种状态，对于描述一些「食之无味，弃之可惜」的对象就显得无能为力了。</p><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存之中，如果内存空间在进行垃圾回收后还是非常紧张，则可以抛弃这些对象，很多系统的缓存功能都符合这样的应用场景。</p><p>在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 中，这四种引用强度一次逐渐减弱</p><p><strong>强引用：</strong>指在程序代码之中普遍存在的，类似 Object obj = new Object() 这类的引用，只要强引用还存在，垃圾回收器「永远」不会回收掉被引用的对象</p><p><strong>软引用：</strong>用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常</p><p><strong>弱引用：</strong>用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</p><p><strong>虚引用：</strong>也被称为幽灵引用或幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的 唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</p><h1><strong>最后，用一张图总结下它们之间的区别：</strong></h1><p><img alt="你真的懂 Java 的内存管理和引用类型吗？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/5b5c00020a993cf15d40></p><p><strong>最后：如果有发现文章内容哪里写错的，欢迎指正、建议。想要了解更多的Java知识的，欢迎关注本头条号，谢谢。</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','内存','类型'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>