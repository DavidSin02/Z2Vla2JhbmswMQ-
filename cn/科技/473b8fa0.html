<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>详解JS中的事件机制(带实例) | 极客快訊</title><meta property="og:title" content="详解JS中的事件机制(带实例) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/780efda3-0c9d-4ac0-be7b-318d4cfa7db1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><meta property="article:published_time" content="2020-10-29T21:11:54+08:00"><meta property="article:modified_time" content="2020-10-29T21:11:54+08:00"><meta name=Keywords content><meta name=description content="详解JS中的事件机制(带实例)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/473b8fa0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>详解JS中的事件机制(带实例)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=详解JS中的事件机制(带实例) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/780efda3-0c9d-4ac0-be7b-318d4cfa7db1><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>1. 事件冒泡与事件捕获</h2><p>事件冒泡和事件捕获分别由微软和网景公司提出，这两个概念都是为了解决页面中事件流（事件发生顺序）的问题。考虑下面这段代码，就不写html->head,body之类的代码了，自行脑补</p><pre><code>&lt;div id="outer"&gt;       &lt;p id="inner"&gt;Click me!&lt;/p&gt;&lt;/div&gt;</code></pre><p>上面的代码当中一个div元素当中有一个p子元素，如果两个元素都有一个click的处理函数，那么我们怎么才能知道哪一个函数会首先被触发呢？为了解决这个问题微软和网景提出了两种几乎完全相反的概念。</p><h4 class=pgc-h-arrow-right>1.1 事件冒泡</h4><p>微软提出了名为事件冒泡(event bubbling) 的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象。 因此在事件冒泡的概念下在p元素上发生click事件的顺序应该是p -> div -> body -> html -> document</p><h4 class=pgc-h-arrow-right>1.2 事件捕获</h4><p>网景提出另一种事件流名为事件捕获(event capturing) 。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。</p><p>因此在事件捕获的概念下在p元素上发生click事件的顺序应该是document -> html -> body -> div -> p</p><h4 class=pgc-h-arrow-right>1.3 addEventListener的第三个参数</h4><p>网景 和 微软 曾经的战争还是比较火热的，当时， 网景主张捕获方式，微软主张冒泡方式。后来 w3c 采用折中的方式，平息了战火，制定了统一的标准——<strong>先捕获再冒泡</strong>。 addEventListener的第三个参数就是为冒泡和捕获准备的.addEventListener有三个参数：</p><pre><code>element.addEventListener(event, function, useCapture)</code></pre><p>第一个参数是需要绑定的事件 第二个参数是触发事件后要执行的函数 第三个参数默认值是false，表示在<strong>事件冒泡阶段</strong>调用事件处理函数;如果参数为true，则表示在<strong>事件捕获阶段</strong>调用处理函数。</p><h2 class=pgc-h-arrow-right>2. 实例讲解</h2><h4 class=pgc-h-arrow-right>2.1 冒泡的案例</h4><pre><code>&lt;div id="s1"&gt;s1    &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    s1.addEventListener("click",function(e){    console.log("s1 冒泡事件"); },false);    s2.addEventListener("click",function(e){    console.log("s2 冒泡事件"); },false);&lt;/script&gt;</code></pre><p>当我们点击s2的时候，执行结果如下：</p><div class=pgc-img><img alt=详解JS中的事件机制(带实例) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/672c42d0aae946ae89c1d213118579ce><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>2.2 捕获的案例</h4><pre><code>&lt;div id="s1"&gt;s1 &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt; s1.addEventListener("click",function(e){ console.log("s1 捕获事件"); },true); s2.addEventListener("click",function(e){ console.log("s2 捕获事件"); },true);&lt;/script&gt;</code></pre><p>当我们点击s2的时候，执行结果如下：</p><pre><code>s1 捕获事件s2 捕获事件</code></pre><h2 class=pgc-h-arrow-right>3. 事件捕获vs事件冒泡</h2><p>当事件捕获和事件冒泡一起存在的情况，事件又是如何触发呢。这里记被点击的DOM节点为target节点</p><ol start=1><li>document 往 target节点，捕获前进，遇到注册的捕获事件立即触发执行</li><li>到达target节点，触发事件（对于target节点上，是先捕获还是先冒泡则捕获事件和冒泡事件的注册顺序，先注册先执行）</li><li>target节点 往 document 方向，冒泡前进，遇到注册的冒泡事件立即触发</li></ol><h4 class=pgc-h-arrow-right>3.1 总结下就是:</h4><ul><li>对于非target节点则先执行捕获在执行冒泡</li><li>对于target节点则是先执行先注册的事件，无论冒泡还是捕获</li></ul><pre><code>&lt;div id="s1"&gt;s1 &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;s1.addEventListener("click",function(e){       console.log("s1 冒泡事件"); },false);s2.addEventListener("click",function(e){       console.log("s2 冒泡事件");},false);s1.addEventListener("click",function(e){       console.log("s1 捕获事件");},true);s2.addEventListener("click",function(e){      console.log("s2 捕获事件");},true);&lt;/script&gt;</code></pre><p>当我们点击s2的时候,执行结果如下：</p><pre><code>s1 捕获事件s2 冒泡事件s2 捕获事件s1 冒泡事件</code></pre><p>这里大体分析下执行结果 点击s2，click事件从document->html->body->s1->s2(捕获前进)这里在s1上发现了捕获注册事件，则输出<strong>"s1 捕获事件"</strong> 到达s2，已经到达目的节点， s2上注册了冒泡和捕获事件，先注册的冒泡后注册的捕获，则先执行冒泡，输出<strong>"s2 冒泡事件"</strong> 再在s2上执行后注册的事件，即捕获事件，输出<strong>"s2 捕获事件"</strong> 下面进入冒泡阶段，按照s2->s1->body->html->documen(冒泡前进) 在s1上发现了冒泡事件，则输出<strong>"s1 冒泡事件"</strong></p><h2 class=pgc-h-arrow-right>4. 事件冒泡与事件捕获应用:事件代理</h2><h4 class=pgc-h-arrow-right>4.1 案例</h4><p>在实际的开发当中，利用事件流的特性，我们可以使用一种叫做事件代理的方法。</p><pre><code>&lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;black&lt;/li&gt; &lt;li&gt;white&lt;/li&gt;&lt;/ul&gt;</code></pre><p>如果点击页面中的li元素，然后输出li当中的颜色，我们通常会这样写:</p><pre><code>(function(){ var color_list = document.getElementById('color-list'); var colors = color_list.getElementsByTagName('li'); for(var i=0;i&lt;colors.length;i++){ colors[i].addEventListener('click',showColor,false); }; function showColor(e){ var x = e.target; console.log("The color is " + x.innerHTML); };})();</code></pre><p>利用事件流的特性，我们只绑定一个事件处理函数也可以完成：</p><pre><code>(function(){  var color_list =document.getElementById('color-list');  color_list.addEventListener('click',showColor,false);  function showColor(e){  var x = e.target;  if(x.nodeName.toLowerCase() === 'li'){  console.log('The color is ' + x.innerHTML);  } }})();</code></pre><p>使用事件代理的好处不仅在于将多个事件处理函数减为一个，而且对于不同的元素可以有不同的处理方法。假如上述列表元素当中添加了其他的元素（如：a、span等），我们不必再一次循环给每一个元素绑定事件，直接修改事件代理的事件处理函数即可。</p><h2 class=pgc-h-arrow-right>5. 冒泡还是捕获？</h2><p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p><h4 class=pgc-h-arrow-right>5.1 IE浏览器兼容</h4><p>IE浏览器对addEventListener兼容性并不算太好，只有IE9以上可以使用。</p><p>要兼容旧版本的IE浏览器，可以使用IE的attachEvent函数</p><pre><code>object.attachEvent(event, function)</code></pre><p>两个参数与addEventListener相似，分别是事件和处理函数，默认是事件冒泡阶段调用处理函数，要注意的是，写事件名时候要加上"on"前缀（"onload"、"onclick"等）。</p><h2 class=pgc-h-arrow-right>6. 事件注意点</h2><ul><li>事件分为三个阶段： 事件捕获 --> 事件目标 --> 事件冒泡</li><li>事件捕获：事件发生时（onclick,onmouseover……）首先发生在document上，然后依次传递给body、……最后到达目的节点（即事件目标）。</li><li>事件冒泡：事件到达事件目标之后不会结束，会逐层向上冒泡，直至document对象，跟事件捕获相反</li></ul><h4 class=pgc-h-arrow-right>6.1 常用技巧</h4><p>1、onlick -->事件冒泡，重写onlick会覆盖之前属性，没有兼容性问题</p><pre><code>ele.onclik = null;   //解绑单击事件，将onlick属性设为null即可</code></pre><p>2、addEventListener(event.type, handle, boolean); IE8及以下不支持，属于DOM2级的方法，可添加多个方法不被覆盖</p><pre><code>//事件类型没有on，false 表示在事件第三阶段（冒泡）触发，true表示在事件第一阶段（捕获）触发。 如果handle是同一个方法，只执行一次。ele.addEventListener('click', function(){ }, false);  //解绑事件，参数和绑定一样ele.removeEventListener(event.type, handle, boolean);</code></pre><p>3、attachEvent(event.type, handle ); IE特有，兼容IE8及以下，可添加多个事件处理程序，只支持冒泡阶段</p><pre><code>//如果handle是同一个方法，绑定几次执行几次，这点和addEventListener不同,事件类型要加on,例如onclick而不是clickele.attachEvent('onclick', function(){ }); //解绑事件，参数和绑定一样ele.detachEvent("onclick", function(){ });</code></pre><p>4、默认事件行为：href=""链接，submit表单提交等 <strong>阻止默认事件：</strong> （1）return false; 阻止独享属性（通过on这种方式）绑定的事件的默认事件</p><pre><code>ele.onclick = function() {    ……                         //你的代码    return false;              //通过返回false值阻止默认事件行为};</code></pre><p>（2）event.preventDefault( ); 阻止通过 addEventListener( ) 添加的事件的默认事件</p><pre><code>element.addEventListener("click", function(e){    var event = e || window.event;    ……    event.preventDefault( );      //阻止默认事件},false);</code></pre><p>（3）event.returnValue = false; 阻止通过 attachEvent( ) 添加的事件的默认事件</p><pre><code>element.attachEvent("onclick", function(e){    var event = e || window.event;    ……    event.returnValue = false;       //阻止默认事件},false);</code></pre><p>5、接下来我们把事件绑定以及事件解绑封装成为一个函数，兼容浏览器，包括IE6及以上</p><pre><code>// 事件绑定function addEvent(element, eType, handle, bol) {    if(element.addEventListener){           //如果支持addEventListener        element.addEventListener(eType, handle, bol);    }else if(element.attachEvent){          //如果支持attachEvent        element.attachEvent("on"+eType, handle);    }else{                                  //否则使用兼容的onclick绑定        element["on"+eType] = handle;    }}</code></pre><pre><code>// 事件解绑function removeEvent(element, eType, handle, bol) {    if(element.addEventListener){        element.removeEventListener(eType, handle, bol);    }else if(element.attachEvent){        element.detachEvent("on"+eType, handle);    }else{        element["on"+eType] = null;    }}</code></pre><p><strong>A.● 事件冒泡、事件捕获阻止：</strong></p><pre><code>event.stopPropagation( );                // 阻止事件的进一步传播，包括（冒泡，捕获），无参数event.cancelBubble = true;             // true 为阻止冒泡</code></pre><p><strong>B.● 事件委托:</strong> 利用事件冒泡的特性，将里层的事件委托给外层事件，根据event对象的属性进行事件委托，改善性能。 使用事件委托能够避免对特定的每个节点添加事件监听器；事件监听器是被添加到它们的父元素上。事件监听器会分析从子元素冒泡上来的事件，找到是哪个子元素的事件。</p><p>来个例子吧，如果要单独点击table里面的td，普通做法是for循环给每个td绑定事件，td少的话性能什么差别，td如果多了，就不行了，我们使用事件委托:</p><pre><code> &lt;!-- HTML --&gt;&lt;table id="out" border="1" style="cursor: pointer;"&gt;    &lt;tr&gt;    　　&lt;td&gt;table01&lt;/td&gt;    　　&lt;td&gt;table02&lt;/td&gt;    　　&lt;td&gt;table03&lt;/td&gt;    　　&lt;td&gt;table04&lt;/td&gt;    　　&lt;td&gt;table05&lt;/td&gt;    　　&lt;td&gt;table06&lt;/td&gt;    　　&lt;td&gt;table07&lt;/td&gt;    　　&lt;td&gt;table08&lt;/td&gt;    　　&lt;td&gt;table09&lt;/td&gt;    　　&lt;td&gt;table10&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><pre><code>var out = document.getElementById("out");      if(out.addEventListener){          out.addEventListener("click",function(e){              var e = e||window.event;              //IE没有e.target，有e.srcElement              var target = e.target||e.srcElement;             //判断事件目标是否是td，是的话target即为目标节点td            if(target.tagName.toLowerCase()=="td"){                 changeStyle(target);                 console.log(target.innerHTML);             }         },false);     }else{         out.attachEvent("onclick",function(e){             var e = e||window.event;             //IE没有e.target，有e.srcElement             var target = e.target||e.srcElement;             //判断事件目标是否是td，是的话target即为目标节点td             if(target.tagName.toLowerCase()=="td"){                 changeStyle(target);                 console.log(target.innerHTML);             }         });     }; }; function changeStyle(ele){     ele.innerHTML = "已点击"     ele.style.background="#900";     ele.style.color = "#fff"; }</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'详解','JS','机制'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>