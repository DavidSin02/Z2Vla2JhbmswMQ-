<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>工程师必知必会select count()你知多少？一文读懂 | 极客快訊</title><meta property="og:title" content="工程师必知必会select count()你知多少？一文读懂 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/cfac7557a83047469f3de4270e371eaa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><meta property="article:published_time" content="2020-11-14T21:07:40+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:40+08:00"><meta name=Keywords content><meta name=description content="工程师必知必会select count()你知多少？一文读懂"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4bbdc7e2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>工程师必知必会select count()你知多少？一文读懂</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>“SELECT COUNT( * ) FROM T” 是个再常见不过的 SQL 需求了。在 MySQL 的使用规范中，我们一般使用事务引擎 InnoDB 作为(一般业务)表的存储引擎，在此前提下，COUNT( * )操作的时间复杂度为 O(N)，其中 N 为表的行数。</p><p>而 MyISAM 表中可以快速取到表的行数。这些实践经验的背后是怎样的机制，以及为什么需要/可以是这样，就是此文想要探讨的。</p><p>先来看一下概况: MySQL COUNT( * ) 在 2 种存储引擎中的部分问题：</p><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cfac7557a83047469f3de4270e371eaa><p class=pgc-img-caption></p></div><p>下面就带着这些问题，以 InnoDB 存储引擎为主来进行讨论。</p><p>一、InnoDB 全表 COUNT( * )</p><p>主要问题:</p><ol><li>执行过程是怎样的？</li><li>如何计算 count？影响 count 结果的因素有哪些？</li><li>count 值存在哪里？涉及的数据结构是怎样的？</li><li>为什么 InnoDB 只能通过扫表来实现 count( * )？(见本文最后的问题)</li><li>全表COUNT( * )作为 table scan 类型操作的一个 case，有什么风险？</li><li>COUNT(* )操作是否会像“SELECT * ”一样可能读取大字段涉及的溢出页？</li></ol><p class=ql-align-center>1</p><p><strong>1. 执行框架 – 循环: 读取 + 计数？</strong></p><p>1.1 基本结论</p><ol><li>全表扫描，一个循环解决问题。</li><li>循环内: 先读取一行，再决定该行是否计入 count。</li><li>循环内是一行一行进行计数处理的。</li></ol><p>1.2 说明</p><p>简单 SELELCT-SQL 的执行框架，类比 INSERT INTO … SELECT 是同样的过程。</p><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/52dcaaf2c1ff445f9776538516b4d745><p class=pgc-img-caption></p></div><p>下面会逐步细化如何读取与计数 ( count++ ) 。</p><p class=ql-align-center>2</p><p><strong>执行过程？</strong></p><p>引述: 执行过程部分，分为 4 个部分:</p><ol><li>COUNT( * ) 前置流程: 从 Client 端发 SQL 语句，到 MySQL-Server 端执行 SELECT 之前，为后面的一些阐述做一铺垫。</li><li>COUNT( * ) 流程: 简要给出代码层面的流程框架及 2 个核心步骤的重点调用栈部分。</li><li>读取一行: 可见性及 row_search_mvcc 函数，介绍可见性如何影响 COUNT( * ) 结果。</li><li>计数一行: Evaluate_join_record 与列是否为空，介绍计数过程如何影响 COUNT( * ) 结果。</li></ol><p>如果读者希望直接看如何进行 COUNT( * )，那么也可以忽略 (1)，而直接跳到 (2) 开始看。</p><p>2.1 COUNT( * ) 前置流程回忆 – 从 Client 端发 SQL 到 sub_select 函数</p><p>为了使看到的调用过程不太突兀，我们还是先回忆一下如何执行到 sub_select 函数这来的：</p><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c877f728cdb14eae9c3cb06c51315579><p class=pgc-img-caption></p></div><ol><li>MySQL-Client 端发送 SQL 语句，根据 MySQL 通信协议封包发送。</li><li>Mysql-Server 端接收数据包，由协议解析出 command 类型 ( QUERY ) 及 SQL 语句 ( 字符串 ) 。</li><li>SQL 语句经过解析器解析输出为 JOIN 类的对象，用于结构化地表达该 SQL 语句。</li><li>PS: 这里的 JOIN 结构，不仅仅是纯语法结构，而是已经进行了语义处理，粗略地说，汇总了表的列表 ( table_list )、目标列的列表 ( target_list )、WHERE 条件、子查询等语法结构。</li><li>在全表 COUNT( * )-case 中，table_list = [表“t”(别名也是“t”)]，target_list = [目标列对象(列名为“COUNT( * )”)]，当然这里没有 WHERE 条件、子查询等结构。</li><li>JOIN 对象有 2 个重要的方法: JOIN::optimize(), JOIN::exec()，分别用于进行查询语句的优化 和 查询语句的执行。</li></ol><ul><li class=ql-indent-1>join->optimize()，优化阶段 (稍后 myisam 下全表 count( * ) 操作会涉及这里的一点内容)。</li><li class=ql-indent-1>join->exec()，执行阶段 ( 重点 )，包含了 InnoDB 下全表count( * ) 操作的执行流程。</li></ul><ol><li>join->exec() 经过若干调用，将调用到 sub_select 函数来执行简单 SQL，包括 COUNT( * ) 。</li><li>END of sub_select 。</li></ol><p>2.2 COUNT( * ) 流程 ( 于 sub_select 函数中 )</p><p>上层的流程与代码是比较简单的，集中在 sub_select 函数中，其中 2 类函数分别对应于前面”执行框架”部分所述的 2 个步骤 – 读取、计数。先给出结论如下：</p><ol><li>读取一行：从相对顶层的 sub_select 函数经过一番调用，最终所有分支将调用到 row_search_mvcc 函数中，该函数就是用于从 InnoDB 存储引擎所存储的 B+-tree 结构中读取一行到内存中的一个 buf (uchar * ) 中，待后续处理使用。</li><li>这里会涉及行锁的获取、MVCC 及行可见性的问题。当然对 于 SELECT COUNT( * ) 这类快照读而言，只会涉及 MVCC 及其可见性，而不涉及行锁。详情可跳至“可见性与 row_search_mvcc 函数”部分。</li><li>计数一行: 代码层面，将会在 evaluate_join_record 函数中对所读取的行进行评估，看其是否应当计入 count 中 ( 即是否要 count++ )。</li><li>简单来说，COUNT(arg) 本身为 MySQL 的函数操作，对于一行来说，若括号内的参数 arg ( 某列或整行 ) 的值若不是 NULL，则 count++，否则对该行不予计数。详情可跳至“ Evaluate_join_record 与列是否为空”部分。</li></ol><p>这两个阶段对 COUNT( * )结果的影响如下: (两层过滤)</p><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de3aedf6a7484d1493251470a8b0fa2d><p class=pgc-img-caption></p></div><p>SQL 层流程框架相关代码摘要如下:</p><p>1210 enum_nested_loop_state</p><p>1211 sub_select(JOIN *join, QEP_TAB *const qep_tab,bool end_of_records)</p><p>1212 {</p><p>1213 DBUG_ENTER("sub_select");</p><p>... ... // 此处省略1000字</p><p>1265 while (rc == NESTED_LOOP_OK && join->return_tab >= qep_tab_idx)</p><p>1266 {</p><p>1267 int error;</p><p>// 第一步，从存储引擎中获取一行；</p><p>1268 if (in_first_read)</p><p>1269 {</p><p>1270 in_first_read= false;</p><p>// 第一步，首次读取，扫描第一个满足条件的记录；</p><p>// 初始化cursor，从”头”扫描到某个位置</p><p>// 类似: SELECT id FROM t LIMIT 1;</p><p>1271 error= (*qep_tab->read_first_record)(qep_tab);</p><p>1272 }</p><p>1273 else</p><p>// 第一步，后续读取，在前次扫描的位置上继续遍历，找到一个满足条件的记录；</p><p>// 类似: SELECT id FROM t WHERE id > $last_id LIMIT 1;</p><p>1274 error= info->read_record(info);</p><p>... ... // 此处省略1000字</p><p>// 第二步，处理刚刚取出的一行</p><p>1291 rc= evaluate_join_record(join, qep_tab);</p><p>... ... // 此处省略1000字</p><p>1303 DBUG_RETURN(rc);</p><p>1304 }</p><p><strong>Q：代码层面，第一步骤(读取一行)有 2 个分支，为什么？</strong></p><p><strong>A：</strong>从 InnoDB 接口层面考虑，分为 “读第一行” 和 “读下一行”，是 2 个不同的执行过程，读第一行需要找到一个 ( cursor ) 位置并做一些初始化工作让后续的过程可递归。</p><p>正如我们如果用脚本/程序来进行逐行的扫表操作，实现上就会涉及下面 2 个 SQL：</p><p>// SELECT id FROM t LIMIT 1; OR SELECT MIN(id)-1 FROM t; -> $last_id</p><p>// SELECT id FROM t WHERE id > $last_id LIMIT 1;</p><p>具体涉及到此例的代码，SQL 层到存储引擎层的调用关系，读取阶段的调用栈如下：(供参考)</p><p>sub_select 函数中从 SQL 层到 InnoDB 层的函数调用关系：(同颜色、同缩进 表示同一层)</p><p>Ø (*qep_tab->read_first_record) ()</p><p>| -- > join_read_first(tab)</p><p>| -- > tab->read_record.read_record=join_read_next;</p><p>| -- > table->file->ha_index_init()</p><p>| -- > handler::ha_index_init(uint idx, bool sorted)</p><p>| -- > ha_innobase::index_init()</p><p>| -- > table->file->ha_index_first()</p><p>| -- > handler::ha_index_first(uint idx, bool sorted)</p><p>| -- > ha_innobase::index_first()</p><p>| -- > ha_innobase::index_read()</p><p>| -- > row_search_mvcc()</p><p>初始化cursor并将其放到一个有效的初始位置上;</p><p>Ø info->read_record (info)</p><p>| -- > join_read_next(info)</p><p>| -- > info->table->file->ha_index_next(info->record))</p><p>| -- > handler::ha_index_next(uchar * buf)</p><p>| -- > ha_innobase::index_next(uchar * buf)</p><p>| -- > general_fetch(buf, ROW_SEL_NEXT, 0)</p><p>| -- > row_search_mvcc()</p><p>“向前”移动一次cursor;</p><p>我们可以看到，无论是哪一个分支的读取，最终都殊途同归于 row_search_mvcc 函数。</p><p>以上是对 LOOP 中的代码做一些简要的说明，下面来看 row_search_mvcc 与 evaluate_join_record 如何输出最终的 count 结果。</p><p>2.3 行可见性及 row_search_mvcc 函数</p><p>这里我们主要通过一组 case 和几个问题来看行可见性对 COUNT( * ) 的影响。</p><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de39ef65737843478ed0e0f494f01a85><p class=pgc-img-caption></p></div><p><strong>Q：对于“SELECT COUNT( * ) FROM t”或者“SELECT MIN(id) FROM t”操作，第一次的读行操作读到的是表 t 中 ( B+ 树最左叶节点 page 内 ) 的最小记录吗？( ha_index_first 为何也调用 row_search_mvcc 来获取最小 key 值？)</strong></p><p><strong>A：</strong>不一定。即使是 MIN ( id ) 也不一定就读取的是 id 最小的那一行，因为也同样有行可见性的问题，实际上 index_read 取到的是 当前事务内语句可见的最小 index 记录。这也反映了前面提到的 join_read_first 与 join_read_next “殊途同归”到 row_search_mvcc 是理所应当的。</p><p><strong>Q：针对图中最后一问，如果事务 X 是 RU ( Read-Uncommitted ) 隔离级别，且 C-Insert ( 100 ) 的完成是在 X-count( * ) 执行过程中 ( 仅扫描到 5 或 10 这条记录 ) 完成的，那么 X-count( * ) 在事务 C-Insert ( 100 ) 完成后，能否在之后的读取过程中看到 100 这条记录呢？</strong></p><p><strong>A：</strong>MySQL 采取”读到什么就是什么”的策略，即 X-count( * ) 在后面可以读到 100 这条记录。</p><p>2.4 evaluate_join_record 与列是否为空</p><p><strong>Q：某一行如何计入 count？</strong></p><p><strong>A：</strong>两种情况会将所读的行计入 count:</p><ol><li>如果 COUNT 函数中的参数是某列，则会判断所读行中该列定义是否 Nullable 以及该列的值是否为 NULL；若两者均为是，则不会计入 count，否则将计入 count。</li></ol><ul><li class=ql-indent-1>e.g. SELECT COUNT(col_name) FROM t</li><li class=ql-indent-1>col_name 可以是主键、唯一键、非唯一键、非索引字段</li></ul><ol><li>如果 COUNT 中带有 * ，则会判断这部分的整行是否为 NULL，如果判断参数为 NULL，则忽略该行，否则 count++。</li></ol><ul><li>e.g-1. SELECT COUNT(*) FROM t</li><li>e.g-2. SELECT COUNT(B.*) FROM A LEFT JOIN B ON A.id = B.id</li></ul><p><strong>Q：特别地，对于 SELECT COUNT(id) FROM t，其中 id 字段是表 t 的主键，则如何？</strong></p><p><strong>A：</strong>效果上等价于 COUNT( * )。因为无论是 COUNT( * )，还是 COUNT ( pk_col ) 都是因为有主键从而充分断定索取数据不为 NULL，这类 COUNT 表达式可以用于获取当前可见的表行数。</p><p><strong>Q：用户层面对 InnoDB COUNT( * ) 的优化操作问题</strong></p><p><strong>A：</strong>这个问题是业界熟悉的一个问题，扫描非空唯一键可得到表行数，但所涉及的字节数可能会少很多(在表的行长与主键、唯一键的长度相差较多时)，相对的 IO 代价小很多。</p><p>相关调用栈参考如下:</p><p>参考一:</p><p>evaluate_join_record()</p><p>| -- > rc= (*qep_tab->next_select)(join, qep_tab+1, 0);</p><p>| -- > end_send_group(...)</p><p>| -- > init_sum_functions(join->sum_funcs, join->sum_funcs_end[idx+1]))</p><p>| -- > (*func_ptr)->reset_and_add()</p><p>| -- > Item_sum::aggregator_clear()</p><p>| -- > Item_sum::aggregator_add()</p><p>| -- > update_sum_func(Item_sum **func_ptr)</p><p>| -- > (*func_ptr)->add()</p><p>| -- > Item_sum::aggregator_add()</p><p>参考二: (Item_sum::aggregator_add)</p><p>((Item_sum *) (*func_ptr))->aggregator_add()</p><p>| -- > (Item_sum *)this->aggr->add()</p><p>| -- > ((Aggregator_simple *) aggr)->item_sum->add()</p><p>| -- > if (! aggr->arg_is_null(false))</p><p>| ------ > ((Item_sum_count *)aggr->item_sum)->count++;</p><p>二、数据结构:</p><p><strong>Q：count 值存储在哪个内存变量里？</strong></p><p>**A：**SQL 解析后，存储于表达 COUNT( * ) 这一项中，((Item_sum_count*)item_sum)->count</p><p>如下图所示回顾我们之前“COUNT( * )前置流程”部分提到的 JOIN 结构。</p><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/249ae0ac58a7400fa873cffe3a77f30a><p class=pgc-img-caption></p></div><p>即 SQL 解析器为每个 SQL 语句进行结构化，将其放在一个 JOIN 对象 ( join ) 中来表达。在该对象中创建并填充了一个列表 result_field_list 用于存放结果列，列表中每个元素则是一个结果列的 ( Item_result_field* ) 对象 ( 指针 ) 。</p><p>在 COUNT( * )-case 中，结果列列表只包含一个元素，( Item_sum_count: public Item_result_field ) 类型对象 ( name = “COUNT( * )”)，其中该类所特有的成员变量 count即为所求。</p><p>三、MyISAM 全表 COUNT( * )</p><p>由于 MyISAM 引擎并不常用于实际业务中，仅做简要描述如下：</p><ol><li>MyISAM-COUNT( * ) 操作是 O(1) 时间复杂度的操作。</li><li>每张 MyISAM 表中存放了一个 meta 信息-count 值，在内存中与文件中各有一份，内存中的 count 变量值通过读取文件中的 count 值来进行初始化。</li><li>SELECT COUNT( * ) FROM t 会直接读取内存中的表 t 对应的 count 变量值。</li><li>内存中的 count 值与文件中的 count 值由写操作来进行更新，其一致性由表级锁来保证。</li><li>表级锁保证的写入串行化使得，同一时刻所有用户线程的读操作要么被锁，要么只会看到一种数据状态。</li></ol><p>四、几个问题</p><p><strong>Q：MyISAM 与 InnoDB 在 COUNT( * ) 操作的执行过程在哪里开始分道扬镳？</strong></p><ul><li>共性：共性存在于 SQL 层，即 SQL 解析之后的数据结构是一致的，count 变量都是存在于作为结果列的 Item_sum_count 类型对象中；返回给客户端的过程也类似 – 对该 count 变量进行赋值并经由 MySQL 通信协议返回给客户端。</li><li>区别：InnoDB 的 count 值计算是在 SQL 执行阶段进行的；而 MyISAM 表本身在内存中有一份包含了表 row_count 值的 meta 信息，在 SQL 优化阶段通过存储引擎的标记给优化器一个 hint，表明该表所用的存储引擎保存了精确行数，可以直接获取到，无需再进入执行器。</li></ul><div class=pgc-img><img alt="工程师必知必会select count(*)你知多少？一文读懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a13f81a3ff949c5ae0aadcd446a78ba><p class=pgc-img-caption></p></div><p><strong>Q：InnoDB 中为何无法向 MyISAM 一样维护住一个 row_count 变量？</strong></p><p><strong>A：</strong>从 MVCC 机制与行可见性问题中可得到原因，每个事务所看到的行可能是不一样的，其 count( * ) 结果也可能是不同的；反过来看，则是 MySQL-Server 端无法在同一时刻对所有用户线程提供一个统一的读视图，也就无法提供一个统一的 count 值。</p><p>PS: 对于多个访问 MySQL 的用户线程 ( COUNT( * ) ) 而言，决定它们各自的结果的因素有几个:</p><ol><li>一组事务执行前的数据状态(初始数据状态)。</li><li>有时间重叠的事务们的执行序列 (操作时序，事务理论表明 并发事务操作的可串行化是正确性的必要条件)。</li><li>事务们各自的隔离级别(每个操作的输入)。</li></ol><p>其中 1、2 对于 Server 而言都是全局或者说可控的，只有 3 是每个用户线程中事务所独有的属性，这是 Server 端不可控的因素，因此 Server 端也就对每个 COUNT( * ) 结果不可控了。</p><p><strong>Q：InnoDB-COUNT( * ) 属 table scan 操作，是否会将现有 Buffer Pool 中其它用户线程所需热点页从 LRU-list 中挤占掉，从而其它用户线程还需从磁盘 load 一次，突然加重 IO 消耗，可能对现有请求造成阻塞？</strong></p><p><strong>A：</strong>MySQL 有这样的优化策略，将扫表操作所 load 的 page 放在 LRU-list 的 young/old 的交界处 ( LRU 尾部约 3/8 处 )。这样用户线程所需的热点页仍然在 LRU-list-young 区域，而扫表操作不断 load 的页则会不断冲刷 old 区域的页，这部分的页本身就是被认为非热点的页，因此也相对符合逻辑。</p><p>PS: 个人认为还有一种类似的优化思路，是限定扫描操作所使用的 Buffer Pool 的大小为 O(1) 级别，但这样做需要付出额外的内存管理成本。</p><p><strong>Q：InnoDB-COUNT( * ) 是否会像 SELECT * FROM t 那样读取存储大字段的溢出页(如果存在)？</strong></p><p><strong>A：</strong>否。因为 InnoDB-COUNT( * ) 只需要数行数，而每一行的主键肯定不是 NULL，因此只需要读主键索引页内的行数据，而无需读取额外的溢出页。</p><p class=ql-align-center>———— e n d ————</p><p class=ql-align-center><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'师必知','必会','select'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>