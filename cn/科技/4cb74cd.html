<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记 | 极客快訊</title><meta property="og:title" content="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cb74cd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cb74cd.html><meta property="article:published_time" content="2020-10-29T20:59:18+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:18+08:00"><meta name=Keywords content><meta name=description content="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4cb74cd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-center><br></p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e><p class=pgc-img-caption></p></div><p><strong>引言有点长</strong></p><p>前端的宝宝会用ajax,用异步编程到快乐的不行~ 我们java也有异步,用起来比他们还快乐~ 我们bia<sub>ji</sub>一个注(gǒupí)解(gāoyào),也是快乐风男...</p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76774e1aae234e1fb0cd43b2cd9efe23><p class=pgc-img-caption></p></div><p>且看下面的栗子:</p><p>注册一个用户,给他的账户初始化积分(也可以想象成注册奖励),再给用户发个注册通知短信,再发个邮件,(只是举栗子,切莫牛角大法),这样一个流程,短信和邮件我觉得完全可以拆分出来,没必要拖在在主流程上来(再补充上<strong>事务</strong>[ACID:原子性,一致性,隔离性,持久性]就好了):</p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64c95c7e357b4756aedc1df7d658f878><p class=pgc-img-caption></p></div><p>今天就这点业务,我在暗想,这不是一个注解就搞掂的嘛~~~ <sub>哈哈哈</sub></p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39c186d466d1403b9163b08677a2675f><p class=pgc-img-caption></p></div><p>结果不是想象中的那么完美~~ 来看我的<strong>异(dind)步(ding)历险记</strong></p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9fea1352e1e44ad89441576d6bb309ca><p class=pgc-img-caption></p></div><p>我的首发原创博客地址:<strong>你的@Async就真的异步吗 ☞ 异步历险奇遇记</strong><sup><strong>[1] https://juejin.im/post/5d47a80a6fb9a06ad3470f9a </strong></sup>里面有gitHub项目地址,关注我,里面实战多多哦~</p><hr><p><strong>奇遇一 循环依赖异常</strong></p><p>看code:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserService userService;  @Override @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用户成功:" + user); userService.senMsg(user); userService.senEmail(user); return insert; } @Async @Override public Boolean senMsg(User user) { try { TimeUnit.SECONDS.sleep(2); System.out.println("发送短信中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",手机号:" + user.getMobile() + "发送短信成功"); return true; } @Async @Override public Boolean senEmail(User user) { try { TimeUnit.SECONDS.sleep(3); System.out.println("发送邮件中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",邮箱:" + user.getEmail() + "发送邮件成功"); return true; }</pre><p>结果:启动不起来,Spring循环依赖问题。 Spring不是解决了循环依赖问题吗，它是支持循环依赖的呀？怎么会呢？</p><p>不可否认，在这之前我也是这么坚信的，倘若你目前也和我有一样坚挺的想法,那就让异常UnsatisfiedDependencyException,has been injected into other beans [userServiceImpl] in its raw version as part of a circular reference,,来鼓励你,拥抱你, 就是这么的不给面子,赤裸裸的circular reference。</p><p>谈到Spring Bean的循环依赖，有的小伙伴可能比较陌生，毕竟开发过程中好像对循环依赖这个概念无感知。其实不然，你有这种错觉，那是因为你工作在Spring的<strong>襁褓</strong>中，从而让你“<strong>高枕无忧</strong>”~ 其实我们的代码中肯定被我们写了循环依赖,比如像这样:</p><pre>@Servicepublic class AServiceImpl implements AService { @Autowired private BService bService; ...}@Servicepublic class BServiceImpl implements BService { @Autowired private AService aService; ...}</pre><p><strong>通过实验总结出</strong>，出现使用@Async导致循环依赖问题的必要条件：</p><ul><li>已开启@EnableAsync的支持</li><li>@Async注解所在的Bean被循环依赖了</li></ul><p><strong>奇遇二 异步失效异常</strong></p><p>那么既然不能循环依赖,我们就不循环依赖,我们这么来:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Autowired SendService sendService;  @Override @Transactional() public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用户成功:" + user); this.senMsg(user); this.senEmail(user); return insert; } @Async @Override public Boolean senMsg(User user) { System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",手机号:" + user.getMobile() + "发送短信成功"); return true; } @Async @Override public Boolean senEmail(User user) { System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",邮箱:" + user.getEmail() + "发送邮件成功"); return true; }</pre><p>结果我们测试了几把,我打印一下结果:</p><pre>2019-08-05 21:59:32.304 INFO 14360 --- [nio-8080-exec-3] com.alibaba.druid.pool.DruidDataSource : {dataSource-1} inited2019-08-05 21:59:32.346 DEBUG 14360 --- [nio-8080-exec-3] c.b.lea.mybot.mapper.UserMapper.insert : ==&gt; Preparing: insert into t_user (username, sex, mobile,email) values (?, ?, ?,?) 2019-08-05 21:59:32.454 DEBUG 14360 --- [nio-8080-exec-3] c.b.lea.mybot.mapper.UserMapper.insert : ==&gt; Parameters: 王麻子(String), 男(String), 18820158833(String), 22qq@qq.com(String)2019-08-05 21:59:32.463 DEBUG 14360 --- [nio-8080-exec-3] c.b.lea.mybot.mapper.UserMapper.insert : &lt;== Updates: 1User 保存用户成功:User(id=101, username=王麻子, mobile=18820158833, email=22qq@qq.com, sex=男, password=123435, createTime=Mon Aug 05 12:20:51 CST 2019, updateTime=null)发送短信中:.....http-nio-8080-exec-3给用户id:101,手机号:18820158833发送短信成功发送邮件中:.....http-nio-8080-exec-3给用户id:101,邮箱:22qq@qq.com发送邮件成功</pre><p>这不白瞎了吗?感知不到我的爱,白写了,难受~~线程依然是http-nio-8080-exec-3,那么为什么了呢? 下面会讲的哦,先说结论:</p><p><strong>通过实验总结出</strong>，出现使用@Async导致异步失效的原因：</p><ul><li>在本类中使用了异步是不支持异步的</li><li>调用者其实是this,是当前对象,不是真正的代理对象userService,spring无法截获这个方法调用 所以不在不在本类中去调用,网上的解决方法有applicationContext.getBean(UserService.class)和AopContext.currentProxy()</li></ul><p><strong>奇遇三 事务失效异常</strong></p><p>那么,既然不能用当前对象,那我们用代理,AopContext.currentProxy(),然鹅,你发现,报错了,对Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.就他:</p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/412d5981a2be4f9182be7f899e5d94d2><p class=pgc-img-caption></p></div><p>但是你去网上百度就会发现,都这么搞</p><pre>@EnableAspectJAutoProxy(exposeProxy = true)</pre><p>我也这么搞,但是又报错了,细细的看报错内容,才发现少了个jar包这东西要配合切面织入,要配合,懂吗?,来上包</p><pre> &lt;!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.2&lt;/version&gt; &lt;/dependency&gt;</pre><p>再来看为撒: 这是一个性感的话题,exposeProxy = true它的作用就是<strong>启用切面的自动代理</strong>,说人话就是<strong>暴露当前代理对象到当前线程绑定</strong>, 看个报错Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.就是AopContext搞得鬼.</p><p>public final class AopContext {</p><p>private static final ThreadLocal&lt;Object> currentProxy = new NamedThreadLocal&lt;>("Current AOP proxy");</p><p>private AopContext() {</p><p>}</p><p>// 该方法是public static方法，说明可以被任意类进行调用</p><p>public static Object currentProxy() throws IllegalStateException {</p><p>Object proxy = currentProxy.get();</p><p>// 它抛出异常的原因是当前线程并没有绑定对象</p><p>// 而给线程绑定对象的方法在下面：特别有意思的是它的访问权限是default级别，也就是说只能Spring内部去调用</p><p>if (proxy == null) {</p><p>throw new IllegalStateException("Cannot find current proxy: Set 'exposeProxy' property on Advised to 'true' to make it available.");</p><p>}</p><p>return proxy;</p><p>}</p><p>// 它最有意思的地方是它的访问权限是default的，表示只能给Spring内部去调用</p><p>// 调用它的类有CglibAopProxy和JdkDynamicAopProxy</p><p>@Nullable</p><p>static Object setCurrentProxy(@Nullable Object proxy) {</p><p>Object old = currentProxy.get();</p><p>if (proxy != null) {</p><p>currentProxy.set(proxy);</p><p>} else {</p><p>currentProxy.remove();</p><p>}</p><p>return old;</p><p>}</p><p>}</p><p>所以我们要做启用代理设置,让代理生效,来走起,主线程的方法使用来调用异步方法,来测试走起: no code said niao:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override@Transactional(propagation = Propagation.REQUIRED) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用户成功:" + user); UserService currentProxy = UserService.class.cast(AopContext.currentProxy()); currentProxy.senMsg(user); currentProxy.senEmail(user); int i = 1 / 0; return insert; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void senMsg(User user) { user.setUsername(Thread.currentThread().getName()+"发短信测试事务...."+ new Random().nextInt()); userMapper.insert(user); System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",手机号:" + user.getMobile() + "发送短信成功"); } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void senEmail(User user) { user.setUsername("发邮件测试事务...."+ new Random().nextInt()); userMapper.insert(user); int i = 1 / 0; System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",邮箱:" + user.getEmail() + "发送邮件成功"); }} </pre><p>测试结果:</p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f866b864cb644be946b2cde2f587dd3><p class=pgc-img-caption></p></div><p>如我们所愿,事务和异步都生效了</p><pre>1. 异步线程SimpleAsyncTaskExecutor-1和SimpleAsyncTaskExecutor-2分别发短信和邮件,主线程保存用户2. 实际结果,主线程保存的那个用户失败,名字叫'发送短信'的也保存失败,只有叫'发邮件'的用户插入成功3. 那么就做到了事务的线程隔离,事务的互不影响,完美4. 亲,你这么写了吗?这么写不优美,虽然有用,但是写的另辟蹊径啊</pre><p><strong>奇遇四 异步嵌套异常</strong></p><p>来,我们看个更骚气的,异步中嵌套异步,来上code:</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Override@Transactional(propagation = Propagation.REQUIRED) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用户成功:" + user); UserService currentProxy = UserService.class.cast(AopContext.currentProxy()); currentProxy.send(user); return insert; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void send(User user) { //发短信 user.setUsername(Thread.currentThread().getName()+"发短信测试事务...."+ new Random().nextInt()); userMapper.insert(user); System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",手机号:" + user.getMobile() + "发送短信成功"); //发邮件 UserService currentProxy = UserService.class.cast(AopContext.currentProxy()); currentProxy.senEmail(user); }  @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public void senEmail(User user) { user.setUsername("发邮件测试事务...."+ new Random().nextInt()); userMapper.insert(user); System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",邮箱:" + user.getEmail() + "发送邮件成功"); }}</pre><p>看我们猜下结果? 数据库会新增几个数据?3个?2个?1个?0个?纳尼报错?</p><p>哈哈``` 上结果:</p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c410d8e4542447e299cb8c9aac2578e6><p class=pgc-img-caption></p></div><p><strong>答案</strong>:只有一条数据主线程保存成功,短信和邮件的插入都失败了,最主要的是还报错了,又是那个~~~Set 'exposeProxy' property on Advised to 'true'磨人的小妖精</p><p><strong>通过实验总结出</strong>，出现导致异步嵌套使用失败的原因：</p><ul><li>在本类中使用了异步嵌套异步是不支持的</li><li>调用者其实被代理过一次了,再嵌套会出现'二次代理',其实是达不到代理了效果,因为已经异步了.即时你在嵌套中不使用代理去获取,即使不保存,但是事务和异步效果都会跟随当前的代理,即嵌套的效果是达不到再次异步的.</li><li>解决办法应该有,但是我觉得我还没找到.这个写法是我们应该规避的,我们应该遵循规范,启用新的服务类去完成我们的异步工作</li></ul><p>下面我们举个栗子:正确的写法,优雅的写法</p><pre>@Servicepublic class UserServiceImpl implements UserService { @Autowired UserMapper userMapper; @Autowired SendService sendService; @Override@Transactional(propagation = Propagation.REQUIRED) public int save(UserDTO userDTO) { User user = new User(); BeanCopyUtils.copy(userDTO, user); int insert = userMapper.insert(user); System.out.println("User 保存用户成功:" + user); sendService.senMsg(user); sendService.senEmail(user); return insert; }}---------------无责任分割线--------------------@Servicepublic class SendServiceImpl implements SendService { @Override @Async @Transactional(propagation = Propagation.REQUIRES_NEW) public Boolean senMsg(User user) { try { TimeUnit.SECONDS.sleep(2); System.out.println("发送短信中:....."); } catch (InterruptedException e) { e.printStackTrace(); } int i = 1 / 0; System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",手机号:" + user.getMobile() + "发送短信成功"); return true; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public Boolean senEmail(User user) { try { TimeUnit.SECONDS.sleep(3); System.out.println("发送邮件中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",邮箱:" + user.getEmail() + "发送邮件成功"); return true; }}</pre><p>结果肯定完美:</p><div class=pgc-img><img alt="Spring异步编程 | 你的@Async就真的异步吗？异步历险奇遇记" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8aaae381bb5f4a8cb5a6d47557519a76><p class=pgc-img-caption></p></div><p>因此当你看到你同事就在本类写个方法标注上@Async然后调用，请制止他吧，做的无用功~~~（关键自己还以为有用，这是最可怕的深坑~）</p><p>那我补充点:@EnableAspectJAutoProxy(exposeProxy = true)的作用: 此注解它导入了AspectJAutoProxyRegistrar，最终设置此注解的两个属性的方法为：</p><pre>public abstract class AopConfigUtils { ...正在加(sheng)载(lue)代码中 请稍后....	public static void forceAutoProxyCreatorToUseClassProxying(BeanDefinitionRegistry registry) {		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {			BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);			definition.getPropertyValues().add("proxyTargetClass", Boolean.TRUE);		}	}	public static void forceAutoProxyCreatorToExposeProxy(BeanDefinitionRegistry registry) {		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {			BeanDefinition definition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);			definition.getPropertyValues().add("exposeProxy", Boolean.TRUE);		}	}}</pre><p>看到此注解标注的属性值最终都被设置到了internalAutoProxyCreator身上，也就是它：<strong>自动代理创建器</strong>。 首先我们需要明晰的是：@Async的代理对象并不是由自动代理创建器来创建的，而是由AsyncAnnotationBeanPostProcessor一个单纯的BeanPostProcessor实现的,很显然当执行AopContext.currentProxy()这句代码的时候报错了。@EnableAsync给容器注入的是AsyncAnnotationBeanPostProcessor，它用于给@Async生成代理，但是它仅仅是个BeanPostProcessor并不属于自动代理创建器，因此exposeProxy = true对它无效。 所以AopContext.setCurrentProxy(proxy);这个set方法肯定就不会执行，所以,因此,但凡只要业务方法中调用AopContext.currentProxy()方法就铁定抛异常~~</p><p><strong>奇遇五 基本类型异常</strong></p><p>看嘛,发短信其实是一些网关调用,我想写个看短信,邮件发送成功的标志,是否调用成功的状态,来走起</p><pre>....省略...UserService---------------无责任分割线--------------------@Servicepublic class SendServiceImpl implements SendService { @Override @Async @Transactional(propagation = Propagation.REQUIRES_NEW) public boolean senMsg(User user) { try { TimeUnit.SECONDS.sleep(2); System.out.println("发送短信中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",手机号:" + user.getMobile() + "发送短信成功"); return true; } @Async @Override @Transactional(propagation = Propagation.REQUIRES_NEW) public boolean senEmail(User user) { try { TimeUnit.SECONDS.sleep(3); System.out.println("发送邮件中:....."); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(Thread.currentThread().getName() + "给用户id:" + user.getId() + ",邮箱:" + user.getEmail() + "发送邮件成功"); return true; }}</pre><p>瞪大眼睛看,我的返回结果是boolean,属于基本类型,虽然没有用,但是报错了:</p><pre>org.springframework.aop.AopInvocationException: Null return value from advice does not match primitive return type for: public boolean com.boot.lea.mybot.service.impl.SendServiceImpl.senMsg(com.boot.lea.mybot.entity.User)</pre><p>导致我的数据库一条数据都没有,影响到主线程了,可见问题发生在主线程<strong>触发</strong>异步线程的时候,那我们找原因: 是走代理触发的:我先找这个类CglibAopProxy再顺藤摸瓜</p><pre>/**	 * Process a return value. Wraps a return of {@code this} if necessary to be the	 * {@code proxy} and also verifies that {@code null} is not returned as a primitive.	 */	private static Object processReturnType(Object proxy, Object target, Method method, Object retVal) {		// Massage return value if necessary		if (retVal != null &amp;&amp; retVal == target &amp;&amp;				!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {			// Special case: it returned "this". Note that we can't help			// if the target sets a reference to itself in another returned object.			retVal = proxy;		}		Class&lt;?&gt; returnType = method.getReturnType();		if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {			throw new AopInvocationException(					"Null return value from advice does not match primitive return type for: " + method);		}		return retVal;	}</pre><p>在这retVal == null && returnType != Void.TYPE && returnType.isPrimitive(),因为我们的这种异步其实是不支持友好的返回结果的,我们的结果应该是void,因为这个异步线程被主线程触发后其实被当做一个任务提交到Spring的异步的一个线程池中进行异步的处理任务了,线程之间的通信是不能之间返回的,其实用这种写法我们就应该用void去异步执行,不要有返回值,而且我们的返回值是isPrimitive(),是基本类型,刚好达标....</p><p><strong>那么我大声喊出,使用异步的时候尽量不要有返回值,实在要有你也不能用基本类型.</strong></p><p><strong>奇遇六 返回异步结果</strong></p><p>有些人就是难受,就是想要返回结果,那么也是可以滴:但是要借助Furtrue小姐姐的get()来进行线程之间的阻塞通信,毕竟小姐姐⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄害羞.</p><p>酱紫写,你就可以阻塞等到执行任务有结果的时候去获取真正的结果了,这个写法和我之前的文章<strong>JAVA并发异步编程 原来十个接口的活现在只需要一个接口就搞定!</strong><sup><strong>[2]</strong></sup>是一样的道理了</p><pre>import com.boot.lea.mybot.service.AsyncService;import com.boot.lea.mybot.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import org.springframework.stereotype.Service;@Service@Async("taskExecutor")public class AsyncServiceImpl implements AsyncService { @Autowired private UserService userService; @Override public Future&lt;Long&gt; queryUserMsgCount(final Long userId) { System.out.println("当前线程:" + Thread.currentThread().getName() + "=-=====queryUserMsgCount"); long countByUserId = userService.countMsgCountByUserId(userId); return new AsyncResult&lt;&gt;(countByUserId); } @Override public Future&lt;Long&gt; queryCollectCount(final Long userId) { System.out.println("当前线程:" + Thread.currentThread().getName() + "=-====queryCollectCount"); long collectCount = userService.countCollectCountByUserId(userId); return new AsyncResult&lt;&gt;(collectCount); }</pre><p><strong>你需要知道的九大异步注意事项</strong></p><ol><li>尽量不要在本类中异步调用</li><li>尽量不要有返回值</li><li>不能使用本类的私有方法或者非接口化加注@Async,因为代理不到失效</li><li>异步方法不能使用static修饰</li><li>异步类没有使用@Component注解（或其他注解）导致spring无法扫描到异步类</li><li>类中需要使用@Autowired或@Resource等注解自动注入，不能自己手动new对象</li><li>如果使用SpringBoot框架必须在启动类中增加@EnableAsync注解</li><li>在调用Async方法的方法上标注@Transactional是管理调用方法的事务的</li><li>在Async方法上标注@Transactional是管理异步方法的事务,事务因线程隔离</li></ol><p><strong>你需要懂的异步原理</strong></p><p><strong>@Async的异步</strong>:</p><ul><li>实际是spring 在扫描bean的时候会扫描方法上是否包含@Async的注解，如果包含的，spring会为这个bean动态的生成一个子类，我们称之为代理类(jdkProxy)， 代理类是继承我们所写的bean的，然后把代理类注入进来，那此时，在执行此方法的时候，会到代理类中，代理类判断了此方法需要异步执行，就不会调用父类 (我们原本写的bean)的对应方法。</li><li>spring自己维护了一个队列，他会把需要执行的方法，放入队列中，等待线程池去读取这个队列，完成方法的执行， 从而完成了异步的功能。</li><li>我们可以关注到再配置task的时候，是有参数让我们配置线程池的数量的。因为这种实现方法，所以在同一个类中的方法调用，添加@Async注解是失效的！，原因是当你在同一个类中的时候，方法调用是在类体内执行的，spring无法截获这个方法调用(为什么呢,这个就是下文讲的...奸笑...嘻嘻嘻嘻...)。</li><li>那在深入一步，Spring为我们提供了AOP，面向切面的功能。他的原理和异步注解的原理是类似的，spring在启动容器的时候，会扫描切面所定义的 类。在这些类被注入的时候，所注入的也是代理类，当你调用这些方法的时候，本质上是调用的代理类。通过代理类再去执行父类相对应的方法，那spring只需要在调用之前和之后执行某段代码就完成了AOP的实现了！</li></ul><p>SpringBoot环境中，要使用@Async注解,我们需要先在启动类上加上@EnableAsync注解。这个与在SpringBoot中使用@Scheduled注解需要在启动类中加上@EnableScheduling是一样的道理（当然你使用古老的XML配置也是可以的，但是在SpringBoot环境中，建议的是全注解开发），具体原理下面会分析。加上@EnableAsync注解后，如果我们想在调用一个方法的时候开启一个新的线程开始异步操作，我们只需要在这个方法上加上@Async注解，当然前提是，这个方法所在的类必须在Spring环境中。</p><pre>示例:非spingboot项目&lt;task:annotation-driven executor="annotationExecutor" /&gt;&lt;!-- 支持 @Async 注解 --&gt;&lt;task:executor id="annotationExecutor" pool-size="20"/&gt;</pre><p>执行流程:</p><ol><li>扫描是否开启注解EnableAsync,@EnableAsync注解上有个@Import(AsyncConfigurationSelector.class),springboot的注入老套路了</li><li>请您再移步AsyncConfigurationSelector,看到selectImports方法了没,这里使用的是默认使用的是ProxyAsyncConfiguration这个配置类</li><li>继续观摩ProxyAsyncConfiguration继承AbstractAsyncConfiguration,它里面的的setConfigurers说明了我们可以通过实现AsyncConfigurer接口来完成线程池以及异常处理器的配置,而且在Spring环境中只能配置一个实现类，否则会抛出异常。 上一点代码:</li></ol><pre> /**	 * Collect any {@link AsyncConfigurer} beans through autowiring.	 */	@Autowired(required = false)	void setConfigurers(Collection&lt;AsyncConfigurer&gt; configurers) { 		if (CollectionUtils.isEmpty(configurers)) {			return;		} //AsyncConfigurer用来配置线程池配置以及异常处理器，而且在Spring环境中最多只能有一个，在这里我们知道了，如果想要自己去配置线程池，只需要实现AsyncConfigurer接口，并且不可以在Spring环境中有多个实现AsyncConfigurer的类。		if (configurers.size() &gt; 1) {			throw new IllegalStateException("Only one AsyncConfigurer may exist");		}		AsyncConfigurer configurer = configurers.iterator().next();		this.executor = configurer.getAsyncExecutor();		this.exceptionHandler = configurer.getAsyncUncaughtExceptionHandler();	}</pre><ol><li>ProxyAsyncConfiguration注入的bean AsyncAnnotationBeanPostProcessor,这个BeanPostBeanPostProcessor很显然会对带有能够引发异步操作的注解（比如@Async）的Bean进行处理</li><li>我们注意到AsyncAnnotationBeanPostProcessor有重写父类的setBeanFactory，这个方法是不是有点熟悉呢，它是BeanFactoryAware接口中的方法，AsyncAnnotationBeanPostProcessor的父类实现了这个接口，在我们很久之前分析过的Bean的初始化中，是有提到过这个接口的，实现了Aware类型接口的Bean，会在初始化Bean的时候调用相应的初始化方法，具体可以查看AbstractAutowireCapableBeanFactory#initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd)方法</li><li>处理Bean的postProcessAfterInitialization方法在祖先类AbstractAdvisingBeanPostProcessor中。从源码中可以看到。AsyncAnnotationBeanPostProcessor是对Bean进行后置处理的BeanPostProcessor</li><li>最后代理到JdkDynamicAopProxy的invoke方法中,是用了责任链模式:List&lt;Object> chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);,将代理进行拦截来执行,通知链会包含setBeanFactory()方法生成的通知,执行链会用于创建ReflectiveMethodInvocation对象，最终是调用ReflectiveMethodInvocation的proceed()来完成对方法的增强处理,proceed()方法在这里会执行最后一个分支</li><li>具体执行的是AsyncExecutionInterceptor的invoke()</li><li><strong>注意</strong>:虽然上文Spring环境中只能有一个AsyncConfigurer实现类，但是不意味着，在Spring环境中只能配置一个线程池，在Spring环境中是可以配置多个线程池，而且我们可以在使用@Async注解进行异步操作的时候，通过在value属性上指定线程池BeanName,这样就可以指定相应的线程池来作为任务的载体,参见:determineAsyncExecutor</li></ol><p><strong>小结兄弟:</strong></p><p>当我们想要在SpringBoot中方便的使用@Async注解开启异步操作的时候，只需要实现AsyncConfigurer接口（这样就配置了默认线程池配置，当然该类需要在Spring环境中，因为是默认的，所以只能有一个，没有多个实现类排优先级的说法），实现对线程池的配置，并在启动类上加上@EnableAsync注解，即可使得@Async注解生效。</p><p>我们甚至可以不显式的实现AsyncConfigurer，我们可以在Spring环境中配置多个Executor类型的Bean，在使用@Async注解时，将注解的value指定为你Executor类型的BeanName，就可以使用指定的线程池来作为任务的载体，这样就使用线程池也更加灵活。</p><p><strong>参考资料</strong></p><p>[1]</p><p>你的@Async就真的异步吗 ☞ 异步历险奇遇记: <em>https://juejin.im/post/5d47a80a6fb9a06ad3470f9a</em></p><p>[2]</p><p>JAVA并发异步编程 原来十个接口的活现在只需要一个接口就搞定!: <em>https://juejin.im/post/5d3c46d2f265da1b9163dbce</em></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异步','Spring','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>