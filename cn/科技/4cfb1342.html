<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>常用的模型集成方法介绍：bagging、boosting 、stacking | 极客快訊</title><meta property="og:title" content="常用的模型集成方法介绍：bagging、boosting 、stacking - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/3dfcccf9ddd24259a441be33af21e5e9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4cfb1342.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4cfb1342.html><meta property="article:published_time" content="2020-11-14T21:05:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:42+08:00"><meta name=Keywords content><meta name=description content="常用的模型集成方法介绍：bagging、boosting 、stacking"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4cfb1342.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>常用的模型集成方法介绍：bagging、boosting 、stacking</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>「团结就是力量」。这句老话很好地表达了机器学习领域中强大「集成方法」的基本思想。总的来说，许多机器学习竞赛（包括 Kaggle）中最优秀的解决方案所采用的集成方法都建立在一个这样的假设上：将多个模型组合在一起通常可以产生更强大的模型。</p></blockquote><p>本文介绍了集成学习的各种概念，并给出了一些必要的关键信息，以便读者能很好地理解和使用相关方法，并且能够在有需要的时候设计出合适的解决方案。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3dfcccf9ddd24259a441be33af21e5e9><p class=pgc-img-caption></p></div><p>本文将讨论一些众所周知的概念，如自助法、自助聚合（bagging）、随机森林、提升法（boosting）、堆叠法（stacking）以及许多其它的基础集成学习模型。</p><p>为了使所有这些方法之间的联系尽可能清晰，我们将尝试在一个更广阔和逻辑性更强的框架中呈现它们，希望这样会便于读者理解和记忆。</p><p><strong>何为集成方法？</strong></p><p>集成学习是一种机器学习范式。在集成学习中，我们会训练多个模型（通常称为「弱学习器」）解决相同的问题，并将它们结合起来以获得更好的结果。最重要的假设是：当弱模型被正确组合时，我们可以得到更精确和/或更鲁棒的模型。</p><p>在集成学习理论中，我们将弱学习器（或基础模型）称为「模型」，这些模型可用作设计更复杂模型的构件。在大多数情况下，这些基本模型本身的性能并不是非常好，这要么是因为它们具有较高的偏置（例如，低自由度模型），要么是因为他们的方差太大导致鲁棒性不强（例如，高自由度模型）。</p><p>集成方法的思想是通过将这些弱学习器的偏置和/或方差结合起来，从而创建一个「强学习器」（或「集成模型」），从而获得更好的性能。</p><p><strong>组合弱学习器</strong></p><p>为了建立一个集成学习方法，我们首先要选择待聚合的基础模型。在大多数情况下（包括在众所周知的 bagging 和 boosting 方法中），我们会使用单一的基础学习算法，这样一来我们就有了以不同方式训练的同质弱学习器。</p><p>这样得到的集成模型被称为「同质的」。然而，也有一些方法使用不同种类的基础学习算法：将一些异质的弱学习器组合成「异质集成模型」。</p><p>很重要的一点是：我们对弱学习器的选择应该和我们聚合这些模型的方式相一致。如果我们选择具有低偏置高方差的基础模型，我们应该使用一种倾向于减小方差的聚合方法；而如果我们选择具有低方差高偏置的基础模型，我们应该使用一种倾向于减小偏置的聚合方法。</p><p>这就引出了如何组合这些模型的问题。我们可以用三种主要的旨在组合弱学习器的「元算法」：</p><ul><li>bagging，该方法通常考虑的是同质弱学习器，相互独立地并行学习这些弱学习器，并按照某种确定性的平均过程将它们组合起来。</li><li>boosting，该方法通常考虑的也是同质弱学习器。它以一种高度自适应的方法顺序地学习这些弱学习器（每个基础模型都依赖于前面的模型），并按照某种确定性的策略将它们组合起来。</li><li>stacking，该方法通常考虑的是异质弱学习器，并行地学习它们，并通过训练一个「元模型」将它们组合起来，根据不同弱模型的预测结果输出一个最终的预测结果。</li></ul><p>非常粗略地说，我们可以说 bagging 的重点在于获得一个方差比其组成部分更小的集成模型，而 boosting 和 stacking 则将主要生成偏置比其组成部分更低的强模型（即使方差也可以被减小）。</p><p>在接下来的章节中，我们将具体介绍 bagging 和 boosting 方法（它们比 stacking 方法使用更广泛，并且让我们可以讨论一些集成学习的关键概念），然后简要概述 stacking 方法。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f181f49babd40678932beba8d302b12><p class=pgc-img-caption></p></div><p><em>我们可以将弱学习器结合起来以得到性能更好的模型。组合基础模型的方法应该与这些模型的类型相适应。</em></p><p><strong>关于 Bagging</strong></p><p>在「并行化的方法」中，我们单独拟合不同的学习器，因此可以同时训练它们。最著名的方法是「bagging」（代表「自助聚合」），它的目标是生成比单个模型更鲁棒的集成模型。</p><p><strong>自助法</strong></p><p>这种统计技术先随机抽取出作为替代的 B 个观测值，然后根据一个规模为 N 的初始数据集生成大小为 B 的样本（称为自助样本）。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a6a6814233244ad5a605507d3a7ed189><p class=pgc-img-caption></p></div><p><em>自助抽样过程示意图。</em></p><p>在某些假设条件下，这些样本具有非常好的统计特性：在一级近似中，它们可以被视为是直接从真实的底层（并且往往是未知的）数据分布中抽取出来的，并且彼此之间相互独立。因此，它们被认为是真实数据分布的代表性和独立样本（几乎是独立同分布的样本）。</p><p>为了使这种近似成立，必须验证两个方面的假设。</p><p>首先初始数据集的大小 N 应该足够大，以捕获底层分布的大部分复杂性。这样，从数据集中抽样就是从真实分布中抽样的良好近似（代表性）。</p><p>其次，与自助样本的大小 B 相比，数据集的规模 N 应该足够大，这样样本之间就不会有太大的相关性（独立性）。注意，接下来我可能还会提到自助样本的这些特性（代表性和独立性），但读者应该始终牢记：「这只是一种近似」。</p><p>举例而言，自助样本通常用于评估统计估计量的方差或置信区间。根据定义，统计估计量是某些观测值的函数。因此，随机变量的方差是根据这些观测值计算得到的。</p><p>为了评估这种估计量的方差，我们需要对从感兴趣分布中抽取出来的几个独立样本进行估计。在大多数情况下，相较于实际可用的数据量来说，考虑真正独立的样本所需要的数据量可能太大了。</p><p>然而，我们可以使用自助法生成一些自助样本，它们可被视为「最具代表性」以及「最具独立性」（几乎是独立同分布的样本）的样本。这些自助样本使我们可以通过估计每个样本的值，近似得到估计量的方差。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c30664df4d4c4c458a9e7e65b6ddcc67><p class=pgc-img-caption></p></div><p><em>自助法经常被用于评估某些统计估计量的方差或置信区间。</em></p><p><strong>关于 Boosting</strong></p><p>在「顺序化的方法中」，组合起来的不同弱模型之间不再相互独立地拟合。其思想是「迭代地」拟合模型，使模型在给定步骤上的训练依赖于之前的步骤上拟合的模型。「Boosting」是这些方法中最著名的一种，它生成的集成模型通常比组成该模型的弱学习器偏置更小。</p><p><strong>提升方法</strong></p><p>Boosting 方法和bagging 方法的工作思路是一样的：我们构建一系列模型，将它们聚合起来得到一个性能更好的强学习器。然而，与重点在于减小方差的 bagging 不同，boosting 着眼于以一种适应性很强的方式顺序拟合多个弱学习器：序列中每个模型在拟合的过程中，会更加重视那些序列中之前的模型处理地很糟糕的观测数据。</p><p>直观地说，每个模型都把注意力集中在目前最难拟合的观测数据上。这样一来，在这个过程的最后，我们就获得了一个具有较低偏置的强学习器（我们会注意到，boosting 也有减小方差的效果）。和 bagging 一样，Boosting 也可以用于回归和分类问题。</p><p>由于其重点在于减小偏置，用于 boosting 的基础模型通常是那些低方差高偏置的模型。例如，如果想要使用树作为基础模型，我们将主要选择只有少许几层的较浅决策树。</p><p>而选择低方差高偏置模型作为 boosting 弱学习器的另一个重要原因是：这些模型拟合的计算开销较低（参数化时自由度较低）。</p><p>实际上，由于拟合不同模型的计算无法并行处理（与 bagging 不同），顺序地拟合若干复杂模型会导致计算开销变得非常高。</p><p>一旦选定了弱学习器，我们仍需要定义它们的拟合方式（在拟合当前模型时，要考虑之前模型的哪些信息？）和聚合方式（如何将当前的模型聚合到之前的模型中？）在接下来的两小节中，我们将讨论这些问题，尤其是介绍两个重要的 boosting 算法：自适应提升（adaboost ）和梯度提升（gradient boosting）。</p><p>简而言之，这两种元算法在顺序化的过程中创建和聚合弱学习器的方式存在差异。自适应增强算法会更新附加给每个训练数据集中观测数据的权重，而梯度提升算法则会更新这些观测数据的值。这里产生差异的主要原因是：两种算法解决优化问题（寻找最佳模型——弱学习器的加权和）的方式不同。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4003b5bc2f0c4be8aa01559446ed77ed><p class=pgc-img-caption></p></div><p><em>Boosting 会迭代地拟合一个弱学习器，将其聚合到集成模型中，并「更新」训练数据集，从而在拟合下一个基础模型时更好地考虑当前集成模型的优缺点。</em></p><p><strong>自适应 boosting</strong></p><p>在自适应 boosting（通常被称为「adaboost」）中，我们将集成模型定义为 L 个弱学习器的加权和</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ca584acb47554e43944b82f449fe7e7c><p class=pgc-img-caption></p></div><p>，其中 c_l 是系数而 w_l 是弱学习器</p><p>寻找这种最佳集成模型是一个「困难的优化问题」。因此，我们并没打算一次性地解决该问题（找到给出最佳整体加法模型的所有系数和弱学习器），而是使用了一种更易于处理的「迭代优化过程」（即使它有可能导致我们得到次优解）。</p><p>另外，我们将弱学习器逐个添加到当前的集成模型中，在每次迭代中寻找可能的最佳组合（系数、弱学习器）。换句话说，我们循环地将 s_l 定义如下：</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3475c71c2e084421b6e2bdaaad1470c4><p class=pgc-img-caption></p></div><p>其中，c_l 和 w_l 被挑选出来，使得 s_l 是最适合训练数据的模型，因此这是对 s_(l-1) 的最佳可能改进。我们可以进一步将其表示为：</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ee4a5411dd34b3fad872e5007feee7e><p class=pgc-img-caption></p></div><p>其中，E(.) 是给定模型的拟合误差，e(.,.)是损失/误差函数。因此，我们并没有在求和过程中对所有 L 个模型进行「全局优化」，而是通过「局部」优化来近似最优解并将弱学习器逐个添加到强模型中。</p><p>更特别的是，在考虑二分类问题时，我们可以将 adaboost 算法重新写入以下过程：首先，它将更新数据集中观测数据的权重，训练一个新的弱学习器，该学习器重点关注当前集成模型误分类的观测数据。其次，它会根据一个表示该弱模型性能的更新系数，将弱学习器添加到加权和中：弱学习器的性能越好，它对强学习器的贡献就越大。</p><p>因此，假设我们面对的是一个二分类问题：数据集中有 N 个观测数据，我们想在给定一组弱模型的情况下使用 adaboost 算法。在算法的起始阶段（序列中的第一个模型），所有的观测数据都拥有相同的权重「1/N」。然后，我们将下面的步骤重复 L 次（作用于序列中的 L 个学习器）：</p><ul><li>用当前观测数据的权重拟合可能的最佳弱模型</li><li>计算更新系数的值，更新系数是弱学习器的某种标量化评估指标，它表示相对集成模型来说，该弱学习器的分量如何</li><li>通过添加新的弱学习器与其更新系数的乘积来更新强学习器</li><li>计算新观测数据的权重，该权重表示我们想在下一轮迭代中关注哪些观测数据（聚和模型预测错误的观测数据的权重增加，而正确预测的观测数据的权重减小）</li></ul><p>重复这些步骤，我们顺序地构建出 L 个模型，并将它们聚合成一个简单的线性组合，然后由表示每个学习器性能的系数加权。注意，初始 adaboost 算法有一些变体，比如 LogitBoost（分类）或 L2Boost（回归），它们的差异主要取决于损失函数的选择。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b7985e4e05d41afbc3542630027d544><p class=pgc-img-caption></p></div><p><em>Adaboost 在每次迭代中更新观测数据的权重。正确分类的观测数据的权重相对于错误分类的观测数据的权重有所下降。在最终的集成模型中，性能更好的模型具有更高的权重。</em></p><p><strong>Stacking 概述</strong></p><p>Stacking 与 bagging 和 boosting 主要存在两方面的差异。首先，Stacking 通常考虑的是异质弱学习器（不同的学习算法被组合在一起），而bagging 和 boosting 主要考虑的是同质弱学习器。其次，stacking 学习用元模型组合基础模型，而bagging 和 boosting 则根据确定性算法组合弱学习器。</p><p><strong>堆叠法（Stacking）</strong></p><p>正如上文已经提到的，stacking 的概念是学习几个不同的弱学习器，并通过训练一个元模型来组合它们，然后基于这些弱模型返回的多个预测结果输出最终的预测结果。</p><p>因此，为了构建 stacking 模型，我们需要定义两个东西：想要拟合的 L 个学习器以及组合它们的元模型。</p><p>例如，对于分类问题来说，我们可以选择 KNN 分类器、logistic 回归和SVM 作为弱学习器，并决定学习神经网络作为元模型。然后，神经网络将会把三个弱学习器的输出作为输入，并返回基于该输入的最终预测。</p><p>所以，假设我们想要拟合由 L 个弱学习器组成的 stacking 集成模型。我们必须遵循以下步骤：</p><ul><li>将训练数据分为两组</li><li>选择 L 个弱学习器，用它们拟合第一组数据</li><li>使 L 个学习器中的每个学习器对第二组数据中的观测数据进行预测</li><li>在第二组数据上拟合元模型，使用弱学习器做出的预测作为输入</li></ul><p>在前面的步骤中，我们将数据集一分为二，因为对用于训练弱学习器的数据的预测与元模型的训练不相关。因此，将数据集分成两部分的一个明显缺点是，我们只有一半的数据用于训练基础模型，另一半数据用于训练元模型。</p><p>为了克服这种限制，我们可以使用某种「k-折交叉训练」方法（类似于 k-折交叉验证中的做法）。这样所有的观测数据都可以用来训练元模型：对于任意的观测数据，弱学习器的预测都是通过在 k-1 折数据（不包含已考虑的观测数据）上训练这些弱学习器的实例来完成的。</p><p>换句话说，它会在 k-1 折数据上进行训练，从而对剩下的一折数据进行预测。迭代地重复这个过程，就可以得到对任何一折观测数据的预测结果。这样一来，我们就可以为数据集中的每个观测数据生成相关的预测，然后使用所有这些预测结果训练元模型。</p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/98e4dd95d42e48b5acf325e7ee19b817><p class=pgc-img-caption></p></div><p><em>Stacking 方法会训练一个元模型，该模型根据较低层的弱学习器返回的输出结果生成最后的输出。</em></p><div class=pgc-img><img alt="常用的模型集成方法介绍：bagging、boosting 、stacking" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e5ad67adb364bcbafea7088db092c28><p class=pgc-img-caption></p></div><p><em>原文链接：https://towardsdatascience.com/ensemble-methods-bagging-boosting-and-stacking-c9214a10a205</em></p><p>原文发布于微信公众号 - 机器之心（almosthuman2014）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'介绍','bagging','boosting'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>