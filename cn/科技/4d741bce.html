<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>有一说一！SpringAOP+源码解析，切就完事了 | 极客快訊</title><meta property="og:title" content="有一说一！SpringAOP+源码解析，切就完事了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/965c060c22b942c1a3a9f143215f114c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4d741bce.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4d741bce.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="有一说一！SpringAOP+源码解析，切就完事了"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4d741bce.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>有一说一！SpringAOP+源码解析，切就完事了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、AOP、SpringAOP、AspectJ的区别</h1><p>AOP为Aspect Oriented Programming的缩写，意为：<strong>面向切面编程</strong>，通过<strong>预编译方式和运行期间动态代理</strong>实现程序功能的统一维护的一种技术。利用AOP可以<strong>对业务逻辑的各个部分进行隔离</strong>，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>文有文的，没用过确实很懵，但是用过之后，不说清晰，起码有点意思了。</p><blockquote><p>Spring AOP：</p><p>它基于动态代理来实现。默认的，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。大家一定要明白背后的意思，包括什么时候会不用 JDK 提供的动态代理，而用 CGLIB 实现。Spring 3.2 以后，spring-core 直接就把 CGLIB 和 ASM 的源码包括进来了，这也是为什么我们不需要显式引入这两个依赖Spring 的 IOC 容器和 AOP 都很重要，Spring AOP 需要依赖于 IOC 容器来管理。如果你是 web 开发者，有些时候，你可能需要的是一个 Filter 或一个 Interceptor，而不一定是 AOP。Spring AOP 只能作用于 Spring 容器中的 Bean，它是使用纯粹的 Java 代码实现的，只能作用于 bean 的方法。Spring 提供了 AspectJ 的支持，后面我们会单独介绍怎么使用，一般来说我们用纯的 Spring AOP 就够了。很多人会对比 Spring AOP 和 AspectJ 的性能，Spring AOP 是基于代理实现的，在容器启动的时候需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 那么好。</p><p>AspectJ：</p><p>AspectJ 出身也是名门，来自于 Eclipse 基金会，link：https://www.eclipse.org/aspectj</p><p>属于静态植入，它是通过修改代码来实现的，它的植入时机可以是：</p><p>Compile-time weaving：编译期织入，如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译器的时候就进行植入，否则没法编译类 B。Post-compile weaving：也就是已经生成了 .class 文件，或已经达成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。Load-time weaving：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法。1、自定义类加载器来干这个，这个应该是最容易想到的办法，在被织入类加载到 JVM 前去对它进行加载，这样就可以在加载的时候定义行为了。2、在 JVM 启动的时候指定 AspectJ 提供的 agent：-javaagent:xxx/xxx/aspectjweaver.jar。</p><p>AspectJ 能干很多 Spring AOP 干不了的事情，它是 AOP 编程的完全解决方案。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。</p><p>因为 AspectJ 在实际代码运行前完成了植入，所以大家会说它生成的类是没有额外运行时开销的。</p></blockquote><h1 class=pgc-h-arrow-right><strong>二、AOP关键术语</strong></h1><div class=pgc-img><img alt=有一说一！SpringAOP+源码解析，切就完事了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/965c060c22b942c1a3a9f143215f114c><p class=pgc-img-caption></p></div><ul><li>切面（Aspect）：也就是我们定义的专注于提供辅助功能的模块，比如安全管理，日志信息等。</li><li>连接点（JoinPoint）：切面代码可以通过连接点切入到正常业务之中，图中每个方法的每个点都是连接点。</li><li>切入点（PointCut）：一个切面不需要通知所有的连接点，而<strong>在连接点的基础之上增加切入的规则</strong>，选择需要增强的点，最终真正通知的点就是切入点。</li><li>通知方法（Advice）：就是切面需要执行的工作，主要有五种通知：before，after，afterReturning，afterThrowing，around。</li><li>织入（Weaving）：将切面应用到目标对象并创建代理对象的过程，SpringAOP选择在目标对象的运行期动态创建代理对</li><li>引入（introduction）：在不修改代码的前提下，引入可以在运行期为类动态地添加方法或字段。</li></ul><h1 class=pgc-h-arrow-right><strong>三、通知的五种类型</strong></h1><ul><li>前置通知Before：目标方法调用之前执行的通知。</li><li>后置通知After：目标方法完成之后，无论如何都会执行的通知。</li><li>返回通知AfterReturning：目标方法成功之后调用的通知。</li><li>异常通知AfterThrowing：目标方法抛出异常之后调用的通知。</li><li>环绕通知Around：可以看作前面四种通知的综合。</li></ul><h1 class=pgc-h-arrow-right><strong>四、切入点表达式</strong></h1><p>上面提到：连接点增加切入规则就相当于定义了切入点，当然切入点表达式分为两种：within和execution，这里主要学习execution表达式。</p><ul><li>写法：execution(访问修饰符 返回值 包名.包名……类名.方法名(参数列表))</li><li>例：execution(public void com.smday.service.impl.AccountServiceImpl.saveAccount())</li><li>访问修饰符可以省略，返回值可以使用通配符*匹配。</li><li>包名也可以使用*匹配，数量代表包的层级，当前包可以使用..标识，例如* *..AccountServiceImpl.saveAccount()</li><li>类名和方法名也都可以使用*匹配：* *..*.*()</li><li>参数列表使用..可以标识有无参数均可，且参数可为任意类型。</li></ul><blockquote><p>全通配写法：* *…*.*(…)</p></blockquote><p>通常情况下，切入点应当设置在业务层实现类下的所有方法：* com.smday.service.impl.*.*(..)。</p><h1 class=pgc-h-arrow-right><strong>五、AOP应用场景</strong></h1><ul><li>记录日志</li><li>监控性能</li><li>权限控制</li><li>事务管理</li></ul><h1 class=pgc-h-arrow-right><strong>六、AOP源码分析</strong></h1><h1 class=pgc-h-arrow-right><strong>SpringBean的生命周期</strong></h1><p>写了好多篇文章，每次都要来回顾一下SpringBean的生命周期，可见它真的十分重要。</p><ul><li>Spring的完整生命周期。</li><li>Spring解决循环依赖，对实例化之后，初始化之前动了手脚。</li></ul><p>Spring的Aop又是在哪完成的对目标对象的代理呢？我们大概也能够想到，其实就是在执行回调的时候。按照惯例，先复习一下，从getBean开始到返回Bean经历了什么：</p><div class=pgc-img><img alt=有一说一！SpringAOP+源码解析，切就完事了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7b40b58f048d4a25a0eee21e8e3aeace><p class=pgc-img-caption></p></div><p>回顾完SpringBean的创建流程之后，我们以注解方式@EnableAspectJAutoProxy配置Aop开启@Aspectj为例，进行一波AOP的流程总结：</p><h1 class=pgc-h-arrow-right><strong>AOP的流程总结</strong></h1><p>通过源码可以发现，其实是通过@EnableAspectJAutoProxy注解注入了一个AnnotationAwareAspectJAutoProxyCreator，但这个类中其实并没有重写postProcessAfterInitialization()，最终实现其实是在AbstractAutoProxyCreator中。</p><p>具体干的事情，我已经通过一张图总结出来了，如果想要了解更加具体的信息，不妨打开源码，可以看的更加清晰一些。</p><div class=pgc-img><img alt=有一说一！SpringAOP+源码解析，切就完事了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/58d5f2744d3d4b7a9beecbc7f80de87e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>AnnotationAwareAspectJAutoProxyCreator的注册</strong></h1><p>首先是对AnnotationAwareAspectJAutoProxyCreator的注册环节：【在此不作赘述】</p><pre><code>class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser {    @Override    @Nullable     // 1. 注册proxy creator    public BeanDefinition parse(Element element, ParserContext parserContext) {    AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);        extendBeanDefinition(element, parserContext);        return null;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>applyBeanPostProcessorsAfterInitialization入口</strong></h1><p>AbstractAutowireCapableBeanFactory.java</p><pre><code>protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {    //如果bean实现了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware接口, 回调    invokeAwareMethods(beanName, bean);    Object wrappedBean = bean;    //aop在init-method之前并没有进行操作, 目前还是原来那个对象    if (mbd == null || !mbd.isSynthetic()) {        //BeanPostProcessor 的 postProcessBeforeInitialization 回调        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);    }     //处理bean中定义的init-method或 bean实现了InitializingBean ,调用afterPropertiesSet() 方法    invokeInitMethods(beanName, wrappedBean, mbd);    if (mbd == null || !mbd.isSynthetic()) {        //BeanPostProcessor 的 postProcessAfterInitialization 回调 注意这里！        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);    }    return wrappedBean;}</code></pre><pre><code>@Overridepublic Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)    throws BeansException {    Object result = existingBean;    for (BeanPostProcessor processor : getBeanPostProcessors()) {        //AnnotationAwareAspectJAutoProxyCreator        Object current = processor.postProcessAfterInitialization(result, beanName);        if (current == null) {            return result;        }        result = current;    }    return result;//返回[可能代理后的]结果}</code></pre><h1 class=pgc-h-arrow-right><strong>AbstractAutoProxyCreator的主要方法</strong></h1><pre><code>//SpringAop在IOC容器创建bean实例的最后对bean进行处理,进行代理增强, AbstractAutoProxyCreato	@Override public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {    if (bean != null) {        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (this.earlyProxyReferences.remove(cacheKey) != bean) {            return wrapIfNecessary(bean, beanName, cacheKey);//这个方法将返回代理类        }    }    return bean;}</code></pre><pre><code>protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {    //返回匹配当前bean 的所有的advisor, advice, interceptor    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        //在这里创建代理        Object proxy = createProxy(            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }    this.advisedBeans.put(cacheKey, Boolean.FALSE);    return bean;}</code></pre><h1 class=pgc-h-arrow-right><strong>createProxy过程</strong></h1><pre><code>protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,@Nullable Object[] specificInterceptors, TargetSource targetSource) {	//创建ProxyFactory实例    ProxyFactory proxyFactory = new ProxyFactory();    proxyFactory.copyFrom(this);	//在schema-based配置方式里,可以将 proxy-target-class="true",这样不管有没有接口都使用cglib    if (!proxyFactory.isProxyTargetClass()) {        if (shouldProxyTargetClass(beanClass, beanName)) {            proxyFactory.setProxyTargetClass(true);        }        else {            evaluateProxyInterfaces(beanClass, proxyFactory);        }    }	//返回当前bean的advisors数组    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);    proxyFactory.addAdvisors(advisors); //设置advisors数组    proxyFactory.setTargetSource(targetSource);//targetSource 携带了真实实现的信息    customizeProxyFactory(proxyFactory);    proxyFactory.setFrozen(this.freezeProxy);    if (advisorsPreFiltered()) {        proxyFactory.setPreFiltered(true);    }    return proxyFactory.getProxy(getProxyClassLoader());//getProxy(getProxyClassLoader())这一步创建代理}</code></pre><h1 class=pgc-h-arrow-right><strong>JDK动态代理和CGLIB动态代理何时使用</strong></h1><p>这一步产生分歧的地方在ProxyFactory的getProxy方法，在getProxy之前，首先需要执行createAopProxy，而createAopProxy方法又被这个AopProxyFactory调用：</p><pre><code>protected final synchronized AopProxy createAopProxy() {    if (!this.active) {        activate();    }    //创建AopProxy之前,需要一个AopProxyFactory    return getAopProxyFactory().createAopProxy(this);}// ProxyCreatorSupport//这个aopProxyFactory用于创建aopProxy, 之后可以用aopProxy.getProxy(classLoader)创建代理public ProxyCreatorSupport() {    this.aopProxyFactory = new DefaultAopProxyFactory();}</code></pre><p>也就是最后会走到DefaultAopProxyFactory中</p><pre><code>@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {        if (!IN_NATIVE_IMAGE &amp;&amp;         (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config))) {        Class&lt;?&gt; targetClass = config.getTargetClass();        if (targetClass == null) {            throw new AopConfigException();        }        //如果要代理的类本身就是接口,使用JDK动态代理        if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {            return new JdkDynamicAopProxy(config);        }        //jdk动态代理基于接口,只有接口中的方法才会被增强, cglib基于类继承,如果方法使用了final或者private修饰,也不能增强        return new ObjenesisCglibAopProxy(config);    }    else {        // 如果有接口，会跑到这个分支        return new JdkDynamicAopProxy(config);    }}</code></pre><p>总结：</p><ul><li>如果被代理的目标实现了一个或多个自定义的接口，那么就会使用JDK动态代理。</li><li>如果没有实现任何接口，则使用CGLIB实现代理。</li><li>如果设置proxy-target-class=true或&lt;property name="proxyTargetClass" value="true"/>则不管有没有实现接口都会使用CGLIB。</li></ul><h1 class=pgc-h-arrow-right><strong>七、JDK动态代理的实现</strong></h1><p>最终的最终，都会走到真正创建代理对象的流程上：</p><pre><code>@Overridepublic Object getProxy(@Nullable ClassLoader classLoader) {	//获取代理接口    Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);    //查找代理目标的接口是否定义equals和hashcode方法    findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);    //使用jdk动态代理创建代理对象    return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);}</code></pre><p>第一个参数：classLoader。</p><p>第二个参数：实现的接口。</p><p>第三个参数：InvocationHandler实例。</p><p>而本身JdkDynamicAopProxy本就实现了InvocationHandler，因此传入this。至此，当调用被代理类的方法的时候，都会最终调用代理类实现的invoke方法，在这个方法中定义横切的逻辑。</p><pre><code>public interface InvocationHandler {    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable;}</code></pre><ul><li>proxy：代理对象的引用。</li><li>method：当前执行的方法。</li><li>args：当前执行方法所需的参数。</li><li>return：和被代理对象有相同的返回值。</li></ul><pre><code>@Override@Nullablepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable { 	//当生成的代理类对外提供服务的时候,都会导入到这个invoke方法中    Object oldProxy = null;    boolean setProxyContext = false;	    TargetSource targetSource = this.advised.targetSource;    Object target = null;    try {        if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {            // 对equals方法的代理            return equals(args[0]);        }        else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {            //对hashCode()方法的代理            return hashCode();        }        //...        Object retVal;		//如果设置了exposeProxy,将proxy放入ThreadLocal中        if (this.advised.exposeProxy) {             oldProxy = AopContext.setCurrentProxy(proxy);            setProxyContext = true;        }        // Get as late as possible to minimize the time we "own" the target,        // in case it comes from a pool.        target = targetSource.getTarget();        Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);        // 获取目标方法的拦截链，包含所有要执行的 advice        List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);        // 检查一下这个链上是不是有advice，如果没有的话，可以跳过创建MethodInvocation        if (chain.isEmpty()) { //chain如果是空的,表示不需要被增强，直接调用目标方法            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);            retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);        }        else {            // 如果chain里有advice 执行方法,得到返回值            MethodInvocation invocation =                new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);            //沿着拦截器链，执行通知            retVal = invocation.proceed();        }        // 对返回值的处理        Class&lt;?&gt; returnType = method.getReturnType();        if (retVal != null &amp;&amp; retVal == target &amp;&amp;            returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;            !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {            retVal = proxy;        }        else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {            throw new AopInvocationException();        }        return retVal;    }    finally {        if (target != null &amp;&amp; !targetSource.isStatic()) {            // 释放目标对象            targetSource.releaseTarget(target);        }        if (setProxyContext) {            // 存储代理对象            AopContext.setCurrentProxy(oldProxy);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>八、总结</strong></h1><blockquote><p>以@AspectJ注解方式为例</p></blockquote><ul><li>首先，依据&lt;aop:aspectj-autoproxy>或@EnableAspectJAutoProxy，Spring会在容器启动的时候注册名叫internalAutoProxyCreator的AnnotationAwareAspectJAutoProxyCreator。</li><li>在bean实例化完成，属性装配完成之后，开始执行回调方法，这时取出所有的BeanPostProcessor，执行其postProcessAfterInitialization方法，准备开始对目标对象代理的创建。</li><li>首先创建一个代理工厂ProxyFactory，设置一系列的属性，如所有的通知方法，增强器，拦截器和目标类等注入代理工厂，再调用ProxyFactory.getProxy(classLoader)获取代理。</li><li>通过判断是用JDK动态代理还是CGLIB创建不同的AopProxy，最后获取getProxy。</li></ul><p>如果感觉本文对你有帮助关注我一起学习进步！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SpringAOP','源码','完事'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>