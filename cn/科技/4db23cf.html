<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++ 一篇搞懂多态的实现原理 | 极客快訊</title><meta property="og:title" content="C++ 一篇搞懂多态的实现原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/01b75b1d55184a0b9209f0bc6ef053b3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4db23cf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4db23cf.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="C++ 一篇搞懂多态的实现原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/4db23cf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++ 一篇搞懂多态的实现原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>虚函数和多态</p><h2 class=pgc-h-arrow-right>01 虚函数</h2><pre><code>virtualvirtual</code></pre><pre><code>class Base {    virtual int Fun() ; // 虚函数};int Base::Fun() // virtual 字段不用在函数体时定义{ }</code></pre><h2 class=pgc-h-arrow-right>02 多态的表现形式一</h2><ul><li>「派生类的指针」可以赋给「基类指针」；</li><li>通过基类指针调用基类和派生类中的同名「虚函数」时:若该指针指向一个基类的对象，那么被调用是基类的虚函数；若该指针指向一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul><p>这种机制就叫做“多态”，说白点就是 <strong>调用哪个虚函数，取决于指针对象指向哪种类型的对象</strong> 。</p><pre><code>// 基类class CFather {public:    virtual void Fun() { } // 虚函数};// 派生类class CSon : public CFather { public :    virtual void Fun() { }};int main() {    CSon son;    CFather *p = &amp;son;    p-&gt;Fun(); //调用哪个虚函数取决于 p 指向哪种类型的对象    return 0;}</code></pre><p>上例子中的 p 指针对象指向的是 CSon 类对象，所以 p->Fun() 调用的是 CSon 类里的 Fun 成员函数。</p><h2 class=pgc-h-arrow-right>03 多态的表现形式二</h2><ul><li>派生类的对象可以赋给基类「引用」</li><li>通过基类引用调用基类和派生类中的同名「虚函数」时:若该引用引用的是一个基类的对象，那么被调用是基类的虚函数；若该引用引用的是一个派生类的对象，那么被调用的是派生类的虚函数。</li></ul><p>这种机制也叫做“多态”，说白点就是 <strong>调用哪个虚函数，取决于引用的对象是哪种类型的对象</strong> 。</p><pre><code>// 基类class CFather {public:    virtual void Fun() { } // 虚函数};// 派生类class CSon : public CFather { public :    virtual void Fun() { }};int main() {    CSon son;    CFather &amp;r = son;    r.Fun(); //调用哪个虚函数取决于 r 引用哪种类型的对象    return 0;}}</code></pre><p>上例子中的 r 引用的对象是 CSon 类对象，所以 r.Fun() 调用的是 CSon 类里的 Fun 成员函数。</p><h2 class=pgc-h-arrow-right>04 多态的简单示例</h2><pre><code>class A {public :    virtual void Print() { cout &lt;&lt; "A::Print"&lt;&lt;endl ; }};// 继承A类class B: public A {public :    virtual void Print() { cout &lt;&lt; "B::Print" &lt;&lt;endl; }};// 继承A类class D: public A {public:    virtual void Print() { cout &lt;&lt; "D::Print" &lt;&lt; endl ; }};// 继承B类class E: public B {    virtual void Print() { cout &lt;&lt; "E::Print" &lt;&lt; endl ; }};</code></pre><p>A类、B类、E类、D类的关系如下图：</p><div class=pgc-img><img alt="C++ 一篇搞懂多态的实现原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01b75b1d55184a0b9209f0bc6ef053b3><p class=pgc-img-caption></p></div><pre><code>int main() {    A a; B b; E e; D d;        A * pa = &amp;a;     B * pb = &amp;b;    D * pd = &amp;d;     E * pe = &amp;e;        pa-&gt;Print();  // a.Print()被调用，输出：A::Print        pa = pb;    pa -&gt; Print(); // b.Print()被调用，输出：B::Print        pa = pd;    pa -&gt; Print(); // d.Print()被调用，输出：D::Print        pa = pe;    pa -&gt; Print(); // e.Print()被调用，输出：E::Print        return 0;}</code></pre><h2 class=pgc-h-arrow-right>05 多态作用</h2><p>在面向对象的程序设计中使用「多态」，能够增强程序的 <strong>可扩充性</strong> ，即程序需要修改或增加功能的时候，需要 <strong>改动和增加的代码较少</strong> 。</p><h2 class=pgc-h-arrow-right>LOL 英雄联盟游戏例子</h2><p>下面我们用设计 LOL 英雄联盟游戏的英雄的例子，说明多态为什么可以在修改或增加功能的时候，可以较少的改动代码。</p><p>LOL 英雄联盟是 5v5 竞技游戏，游戏中有很多英雄，每种英雄都有一个「类」与之对应，每个英雄就是一个「对象」。</p><p>英雄之间能够互相攻击，攻击敌人和被攻击时都有相应的动作，动作是通过对象的成员函数实现的。</p><p>下面挑了五个英雄：</p><ul><li>探险家 CEzreal</li><li>盖楼 CGaren</li><li>盲僧 CLeesin</li><li>无极剑圣 CYi</li><li>瑞兹 CRyze</li></ul><div class=pgc-img><img alt="C++ 一篇搞懂多态的实现原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/16e8ecdbee3c4ee99d52854d69547231><p class=pgc-img-caption></p></div><p>基本思路：</p><ol start=1><li>为每个英雄类编写 Attack 、 FightBack 和 Hurted 成员函数。</li></ol><pre><code>AttackFightBackHurted</code></pre><ol start=1><li>设置基类 CHero ，每个英雄类都继承此基类</li></ol><div class=pgc-img><img alt="C++ 一篇搞懂多态的实现原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4e6dc532a6814383a86b7d381e4be01e><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>02 非多态的实现方法</h2><pre><code>// 基类class CHero {protected:      int m_nPower ; //代表攻击力    int m_nLifeValue ; //代表生命值};// 无极剑圣类class CYi : public CHero {public:    // 攻击盖伦的攻击函数    void Attack(CGaren * pGaren)     {        .... // 表现攻击动作的代码        pGaren-&gt;Hurted(m_nPower);        pGaren-&gt;FightBack(this);    }    // 攻击瑞兹的攻击函数    void Attack(CRyze * pRyze)     {        .... // 表现攻击动作的代码        pRyze-&gt;Hurted(m_nPower);        pRyze-&gt;FightBack( this);    }        // 减少自身生命值    void Hurted(int nPower)     {        ... // 表现受伤动作的代码        m_nLifeValue -= nPower;    }        // 反击盖伦的反击函数    void FightBack(CGaren * pGaren)     {        ...．// 表现反击动作的代码        pGaren-&gt;Hurted(m_nPower/2);    }        // 反击瑞兹的反击函数    void FightBack(CRyze * pRyze)     {        ...．// 表现反击动作的代码        pRyze-&gt;Hurted(m_nPower/2);    }};</code></pre><p>有 n 种英雄， CYi 类中就会有 n 个 Attack 成员函数，以及 n 个 FightBack成员函数。对于其他类也如此。</p><p>如果游戏版本升级，增加了新的英雄寒冰艾希 CAshe ，则程序改动较大。所有的类都需要增加两个成员函数:</p><pre><code>void Attack(CAshe * pAshe);void FightBack(CAshe * pAshe);</code></pre><p>这样工作量是非常大的！！非常的不人性，所以这种设计方式是非常的不好！</p><h2 class=pgc-h-arrow-right>03 多态的实现方式</h2><p>用多态的方式去实现，就能得知多态的优势了，那么上面的栗子改成多态的方式如下：</p><pre><code>// 基类class CHero {public:    virtual void Attack(CHero *pHero){}    virtual voidFightBack(CHero *pHero){}    virtual void Hurted(int nPower){}protected:      int m_nPower ; //代表攻击力    int m_nLifeValue ; //代表生命值};// 派生类 CYi:class CYi : public CHero {public:    // 攻击函数    void Attack(CHero * pHero)     {        .... // 表现攻击动作的代码        pHero-&gt;Hurted(m_nPower); // 多态        pHero-&gt;FightBack(this);  // 多态    }        // 减少自身生命值    void Hurted(int nPower)     {        ... // 表现受伤动作的代码        m_nLifeValue -= nPower;    }        // 反击函数    void FightBack(CHero * pHero)     {        ...．// 表现反击动作的代码        pHero-&gt;Hurted(m_nPower/2); // 多态    }};</code></pre><p>如果增加了新的英雄寒冰艾希 CAshe ，只需要编写新类 CAshe ，不再需要在已有的类里专门为新英雄增加：</p><pre><code>void Attack( CAshe * pAshe) ;void FightBack(CAshe * pAshe) ;</code></pre><p>所以已有的类可以原封不动，那么使用多态的特性新增英雄的时候，可见改动量是非常少的。</p><p>多态使用方式：</p><pre><code>void CYi::Attack(CHero * pHero) {    pHero-&gt;Hurted(m_nPower); // 多态    pHero-&gt;FightBack(this);  // 多态}CYi yi; CGaren garen; CLeesin leesin; CEzreal ezreal;yi.Attack( &amp;garen );  //(1)yi.Attack( &amp;leesin ); //(2)yi.Attack( &amp;ezreal ); //(3)</code></pre><p>根据多态的规则，上面的(1)，(2)，(3)进入到 CYi::Attack 函数后</p><p>，分别调用：</p><pre><code>CGaren::HurtedCLeesin::HurtedCEzreal::Hurted</code></pre><h2 class=pgc-h-arrow-right>多态的又一例子</h2><p>出一道题考考大家，看大家是否理解到了多态的特性，下面的代码， pBase->fun1() 输出结果是什么呢？</p><pre><code>class Base {public:    void fun1()     {         fun2();     }        virtual void fun2()  // 虚函数    {         cout &lt;&lt; "Base::fun2()" &lt;&lt; endl;     }};class Derived : public Base {public:    virtual void fun2()  // 虚函数    {         cout &lt;&lt; "Derived:fun2()" &lt;&lt; endl;     }};int main() {    Derived d;    Base * pBase = &amp; d;    pBase-&gt;fun1();    return 0;}</code></pre><p>是不是大家觉得 pBase 指针对象虽然指向的是派生类对象，但是派生类里没有 fun1 成员函数，则就调用基类的 fun1 成员函数， Base::fun1() 里又会调用基类的 fun2 成员函数，所以输出结果是 Base::fun2() ？</p><p>假设我把上面的代码转换一下， 大家还觉得输出的是 Base::fun2() 吗？</p><pre><code>class Base {public:    void fun1()     {         this-&gt;fun2();  // this是基类指针，fun2是虚函数，所以是多态    }}</code></pre><p>this 指针的作用就是指向成员函数所作用的对象， 所以非静态成员函数中可以直接使用 this 来代表指向该函数作用的对象的指针。</p><p>pBase 指针对象指向的是派生类对象，派生类里没有 fun1 成员函数，所以就会调用基类的 fun1 成员函数，在 Base::fun1() 成员函数体里执行 this->fun2() 时，实际上指向的是派生类对象的 fun2 成员函数。</p><p>所以正确的输出结果是：</p><pre><code>Derived:fun2()</code></pre><p>所以我们需要注意：</p><h4 class=pgc-h-arrow-right>在非构造函数，非析构函数的成员函数中调用「虚函数」，是多态!!!</h4><h2 class=pgc-h-arrow-right>构造函数和析构函数中存在多态吗？</h2><p>在构造函数和析构函数中调用「虚函数」，不是多态。编译时即可确定，调用的函数是 <strong>自己的类或基类</strong> 中定义的函数，不会等到运行时才决定调用自己的还是派生类的函数。</p><p>我们看如下的代码例子，来说明：</p><pre><code>// 基类class CFather {public:    virtual void hello() // 虚函数    {        cout&lt;&lt;"hello from father"&lt;&lt;endl;     }        virtual void bye() // 虚函数    {        cout&lt;&lt;"bye from father"&lt;&lt;endl;     }};// 派生类class CSon : public CFather{ public:    CSon() // 构造函数    {         hello();     }        ~CSon()  // 析构函数    {         bye();    }    virtual void hello() // 虚函数    {         cout&lt;&lt;"hello from son"&lt;&lt;endl;    }};int main(){    CSon son;    CFather *pfather;    pfather = &amp; son;    pfather-&gt;hello(); //多态    return 0;}</code></pre><p>输出结果：</p><pre><code>hello from son  // 构造son对象时执行的构造函数hello from son  // 多态bye from father // son对象析构时，由于CSon类没有bye成员函数，所以调用了基类的bye成员函数</code></pre><h2 class=pgc-h-arrow-right>多态的实现原理</h2><p>「多态」的关键在于通过 <strong>基类指针或引用</strong> 调用一个 <strong>虚函数</strong> 时，编译时不能确定到底调用的是基类还是派生类的函数，运行时才能确定。</p><p>我们用 sizeof 来运算有有虚函数的类和没虚函数的类的大小，会是什么结果呢？</p><pre><code>class A {public:    int i;    virtual void Print() { } // 虚函数};class B{public:    int n;    void Print() { } };int main() {    cout &lt;&lt; sizeof(A) &lt;&lt; ","&lt;&lt; sizeof(B);    return 0;}</code></pre><p>在64位机子，执行的结果：</p><pre><code>16,4</code></pre><p>从上面的结果，可以发现有虚函数的类，多出了 8 个字节，在 64 位机子上指针类型大小正好是 8 个字节，这多出 8 个字节的指针有什么作用呢？</p><h2 class=pgc-h-arrow-right>01 虚函数表</h2><p>每一个有「虚函数」的类（或有虚函数的类的派生类）都有一个「虚函数表」，该类的任何对象中都放着 <strong>虚函数表的指针</strong> 。「虚函数表」中列出了该类的「虚函数」地址。</p><h4 class=pgc-h-arrow-right>多出来的 8 个字节就是用来放「虚函数表」的地址。</h4><pre><code>// 基类class Base {public:    int i;    virtual void Print() { } // 虚函数};// 派生类class Derived : public Base{public:    int n;    virtual void Print() { } // 虚函数};</code></pre><p>上面 Derived 类继承了 Base类，两个类都有「虚函数」，那么它「虚函数表」的形式可以理解成下图：</p><div class=pgc-img><img alt="C++ 一篇搞懂多态的实现原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bdbf13ebb0240e1b22a27fe4f7ccf1d><p class=pgc-img-caption></p></div><p>多态的函数调用语句被编译成一系列根据基类指针所指向的（或基类引用所引用的）对象中 <strong>存放的虚函数表的地址</strong> ，在虚函数表中查找虚函数地址，并调用虚函数的指令。</p><h2 class=pgc-h-arrow-right>02 证明虚函数表指针的作用</h2><p>在上面我们用 sizeof 运算符计算了有虚函数的类的大小，发现是多出了 8 字节大小（64位系统），这多出来的 8 个字节就是指向「虚函数表的指针」。「虚函数表」中列出了该类的「虚函数」地址。</p><p>下面用代码的例子，来证明「虚函数表指针」的作用：</p><pre><code>// 基类class A {public:     virtual void Func()  // 虚函数    {         cout &lt;&lt; "A::Func" &lt;&lt; endl;     }};// 派生类class B : public A {public:     virtual void Func()  // 虚函数    {         cout &lt;&lt; "B::Func" &lt;&lt; endl;    }};int main() {    A a;        A * pa = new B();    pa-&gt;Func(); // 多态        // 64位程序指针为8字节    int * p1 = (int *) &amp; a;    int * p2 = (int *) pa;        * p2 = * p1;    pa-&gt;Func();        return 0;}</code></pre><p>输出结果：</p><pre><code>B::FuncA::Func</code></pre><ul><li>第 25-26 行代码中的 pa 指针指向的是 B 类对象，所以 pa->Func() 调用的是 B 类对象的虚函数 Func() ，输出内容是 B::Func ；</li><li>第 29-30 行代码的目的是把 A 类的头 8 个字节的「虚函数表指针」存放到 p1 指针和把 B 类的头 8 个字节的「虚函数表指针」存放到 p2 指针；</li><li>第 32 行代码目的是把 A 类的「虚函数表指针」 赋值给 B 类的「虚函数表指针」，所以相当于把 B 类的「虚函数表指针」 替换 成了 A 类的「虚函数表指针」；</li><li>由于第 32 行的作用，把 B 类的「虚函数表指针」 替换 成了 A 类的「虚函数表指针」，所以第 33 行调用的是 A 类的虚函数 Func() ，输出内容是 A::Func</li></ul><p>通过上述的代码和讲解，可以有效的证明了「虚函数表的指针」的作用，「虚函数表的指针」指向的是「虚函数表」，「虚函数表」里存放的是类里的「虚函数」地址，那么在调用过程中，就能实现多态的特性。</p><h2 class=pgc-h-arrow-right>虚析构函数</h2><p>析构函数是在删除对象或退出程序的时候，自动调用的函数，其目的是做一些资源释放。</p><p>那么在多态的情景下，通过基类的指针删除派生类对象时，通常情况下只调用基类的析构函数，这就会存在派生类对象的析构函数没有调用到，存在资源泄露的情况。</p><p>看如下的例子：</p><pre><code>// 基类class A {public:     A()  // 构造函数    {        cout &lt;&lt; "construct A" &lt;&lt; endl;    }        ~A() // 析构函数    {        cout &lt;&lt; "Destructor A" &lt;&lt; endl;    }};// 派生类class B : public A {public:     B()  // 构造函数    {        cout &lt;&lt; "construct B" &lt;&lt; endl;    }        ~B()// 析构函数    {        cout &lt;&lt; "Destructor B" &lt;&lt; endl;    }};int main() {    A *pa = new B();    delete pa;        return 0;}</code></pre><p>输出结果：</p><pre><code>construct Aconstruct BDestructor A</code></pre><p>从上面的输出结果可以看到，在删除 pa 指针对象时， B 类的析构函数没有被调用。</p><h4 class=pgc-h-arrow-right>解决办法：把基类的析构函数声明为virtual</h4><ul><li>派生类的析构函数可以 virtual 不进行声明；</li><li>通过基类的指针删除派生类对象时，首先调用派生类的析构函数，然后调用基类的析构函数，还是遵循「先构造，后虚构」的规则。</li></ul><p>将上述的代码中的基类的析构函数，定义成「虚析构函数」：</p><pre><code>// 基类class A {public:     A()      {        cout &lt;&lt; "construct A" &lt;&lt; endl;    }        virtual ~A() // 虚析构函数    {        cout &lt;&lt; "Destructor A" &lt;&lt; endl;    }};</code></pre><p>输出结果：</p><pre><code>construct Aconstruct BDestructor BDestructor A</code></pre><p>所以要养成好习惯:</p><ul><li>一个类如果定义了虚函数，则应该将析构函数也定义成虚函数;</li><li>或者，一个类打算作为基类使用，也应该将析构函数定义成虚函数。</li><li>注意：不允许构造函数不能定义成虚构造函数。</li></ul><h2 class=pgc-h-arrow-right>纯虚函数和抽象类</h2><p>纯虚函数： 没有函数体的虚函数</p><pre><code>class A {public:    virtual void Print( ) = 0 ; //纯虚函数private:     int a;};</code></pre><p>包含纯虚函数的类叫抽象类</p><ul><li>抽象类只能作为基类来派生新类使用，不能创建抽象类的对象</li><li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li></ul><pre><code>A a;         // 错，A 是抽象类，不能创建对象A * pa ;     // ok,可以定义抽象类的指针和引用pa = new A ; // 错误, A 是抽象类，不能创建对象</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'搞懂','C++','多态'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>