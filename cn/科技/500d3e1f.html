<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法 － 七大排序算法详细介绍 | 极客快訊</title><meta property="og:title" content="算法 － 七大排序算法详细介绍 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/500d3e1f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/500d3e1f.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="算法 － 七大排序算法详细介绍"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/500d3e1f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法 － 七大排序算法详细介绍</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>排序的相关概念</p><p class=ql-align-justify>排序的分类</p><ul><li class=ql-align-justify>根据在排序过程中<strong>带排序的记录</strong>是否全部被放置在内存中，排序分为：</li><li class="ql-align-justify ql-indent-1">内排序</li><li class="ql-align-justify ql-indent-1">外排序</li></ul><p class=ql-align-justify>1.内排序</p><p class=ql-align-justify><strong>内排序是在排序整个过程中，带排序的所有记录全部放置在内存中</strong>。</p><p class=ql-align-justify>影响内排序的主要因素</p><ul><li class=ql-align-justify>时间性能。</li><li class="ql-align-justify ql-indent-1">(主要受<strong>比较</strong>和<strong>移动</strong>两种操作的影响）</li><li class=ql-align-justify>辅助空间。</li><li class=ql-align-justify>算法的复杂性。</li></ul><p class=ql-align-justify><strong>内排序的分类</strong></p><p class=ql-align-justify>根据排序过程中<strong>借助的主要操作</strong>，内排序分为：</p><ul><li class=ql-align-justify>插入排序</li><li class=ql-align-justify>交换排序</li><li class=ql-align-justify>选择排序</li><li class=ql-align-justify>归并排序</li></ul><p class=ql-align-justify>2.外排序</p><p class=ql-align-justify><strong>外排序是由于排序的记录个数太多，不能同时放置在内存中，整个排序过程需要在内外存之间多次交换数据才能进行</strong>。</p><p class=ql-align-justify>按照算法的复杂度分类</p><ul><li class=ql-align-justify>简单算法：</li><li class="ql-align-justify ql-indent-1">冒泡排序、简单选择排序、直接插入排序。</li><li class=ql-align-justify>复杂排序：</li><li class="ql-align-justify ql-indent-1">希尔排序、堆排序、归并排序、快速排序。</li></ul><p class=ql-align-justify><br></p><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>一、冒泡排序算法</p><p class=ql-align-justify>因为在冒泡排序中要用到<strong>顺序表结构</strong>和<strong>数组两元素的交换</strong>，先把这些写成函数</p><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 100#define TRUE 1#define FALSE 0typedef struct {  int r[MAXSIZE + 1]; int length;}SqList;void swap(SqList *L, int i, int j){ int temp = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[j]; L-&gt;r[j] = temp;}</pre><p class=ql-align-justify>1.1 冒泡排序的初级版实现</p><p class=ql-align-justify>冒泡排序（Bubble Sort）是一种<strong>交换排序</strong>，它的基本思想是：<strong>两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止</strong>。</p><ul><li><br></li></ul><pre>void BubblSort0(SqList *L){ int i,j;  for (i = 1; i &lt; L-&gt;length; i++) for (j = i+1; j &lt;= L-&gt;length; j++) if (L-&gt;r[i] &gt; L-&gt;r[j]) swap(L, i, j);}</pre><p class=ql-align-justify>对于这段代码，是最简单的冒泡，其实就是最简单的交换排序而已。<strong>它的思路就是让每一个关键字，都和它后面的每一个关键字比较，如果大则交换，这样第一位置的关键字在第一次循环后一定变成最小值</strong>。</p><p class=ql-align-justify>假设我们待排序的关键字序列是{9，1，5，8，3，7，4，6，2}</p><ul><li class=ql-align-justify>当i = 1时，9与1交换后，在第一位置的1与后面的关键字比较都小，因此它就只最小值。</li><li class=ql-align-justify>当i = 2时，第二位置先后由9换成5，换成3，换成2，完成了第二小的数字交换。</li><li class=ql-align-justify>后面数字依次比较和交换，得到最终结果。</li></ul><p class=ql-align-justify><br></p><div class=pgc-img><img alt="算法 － 七大排序算法详细介绍" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>1.2 冒泡排序的实现</p><p class=ql-align-justify>对于上面的算法，代码虽然简单易懂，但是效率非常低。可以改进成接下来的代码</p><ul><li><br></li></ul><pre>void BubbleSort(SqList *L){ int i,j; for (i = 1; i &lt; L-&gt;length; i++) for (j = L-&gt;length - 1; j &gt;= i; j--) if (L-&gt;r[j] &gt; L-&gt;r[j+1]) swap(L, j, j+1);}</pre><p class=ql-align-justify>代码解释</p><p class=ql-align-justify>假设我们待排序的关键字序列是{9，1，5，8，3，7，4，6，2}</p><ul><li class=ql-align-justify>当i = 1时，<strong>变量j由8反向循环到1</strong>，逐个比较，将<strong>较小值</strong>交换到前面，直到最后找到最小值放置在了第1的位置。</li><li class=ql-align-justify>当i = 1、 j = 8时，6 > 2 ，因此交换了它们的位置，j = 7时，4 > 2， 所以交换......直到j = 2时，因为 1 &lt; 2， 所以不交换。</li><li class=ql-align-justify>j = 1 时，9 > 1，交换，最终得到最小值1放置第一的位置。</li><li class=ql-align-justify>在不断循环的过程中，<strong>除了将关键字1放到第一的位置，还将关键字2从第九位置提到了第三的位置</strong>，显然比前面的算法有进步。</li><li class=ql-align-justify>当i = 2时，变量j由8反向循环到2，逐个比较，<strong>在将关键字2交换到第二位置的同时，也将关键字4和3有所提升</strong>。</li></ul><p class=ql-align-justify>1.3 冒泡排序的优化</p><ul><li class=ql-align-justify>在排序的过程中，增加一个标记变量flag来记录位置是否发生了变化</li><li class=ql-align-justify>如果没有发生交换，说明数组已经有序了。</li><li><br></li></ul><pre>void BubbleSort1(SqList *L){ int i,j;  int flag = TRUE; for (i = 1; i &lt; L-&gt;length &amp;&amp; flag; i++) { flag = FALSE; for (j = L-&gt;length - 1; j &gt;= i; j--) { if (L-&gt;r[j] &gt; L-&gt;r[j+1]) { swap(L, j, j+1); flag = TRUE; } } }}</pre><p class=ql-align-justify>测试</p><pre>#define N 9int main(int argc, const char * argv[]) {  int i; int d[N] = {9,1,5,8,3,7,4,6,2};  SqList l0; for (i = 0; i &lt; N; i++) l0.r[i+1] = d[i]; l0.length = N;  printf("排序前：\n"); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n");  printf("1.0 初级冒泡排序结果:\n"); BubblSort0(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n");  printf("1.1 冒泡排序结果:\n"); BubbleSort(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n"); printf("1.2 优化后冒泡排序结果:\n"); BubbleSort1(&amp;l0); for (i = 0; i &lt; l0.length; i++) { printf("%d ", l0.r[i+1]); } printf("\n"); return 0;}</pre><p class=ql-align-justify>测试结果</p><div class=pgc-img><img alt="算法 － 七大排序算法详细介绍" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/12563821829046ff9e833e89c948b9d5><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>二、简单选择排序</p><p class=ql-align-justify>简单选择排序法(Simple Selection Sort)是<strong>通过n-i次关键字间的比较</strong>，<strong>从n-i+1个记录中选出关键字最小的记录，并和第i(1&lt;=i&lt;=n)个记录交换</strong>。</p><p class=ql-align-justify>简单选择排序法的工作原理是：<strong>每一次从无序组的数据元素中选出最小（或最大）的一个元素，存放在无序组的起始位置，无序组元素减少，有序组元素增加，直到全部待排序的数据元素排完</strong>。</p><ul><li><br></li></ul><pre>void SelectSort(SqList *L){ int i, j, min; for (i = 1; i &lt; L-&gt;length; i++) { min = i; for (j = i + 1; j &lt;= L-&gt;length; j++) { if (L-&gt;r[min] &gt; L-&gt;r[j]) min = j; }  if (i != min)  swap(L, i, min); }}</pre><p class=ql-align-justify>代码说明</p><ul><li class=ql-align-justify>简单选择排序相对简单，交换移动数据的次数相当少，节约时间。</li><li class=ql-align-justify>简单选择排序的时间复杂度为O(n^2)。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>三、直接插入排序</p><p class=ql-align-justify>直接插入排序(Straight Insertion Sort)的基本操作是<strong>将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录增1的有序表。</strong></p><p class=ql-align-justify>直接插入排序的核心思想：将一个记录插入到一个已经排序好的表中，以得到一个记录增加1的有序表。<strong>并且它把当前元素大的记录都往后移动，用以腾出“自己”该插入的位置。</strong>当n-1趟插入完成后该记录就是有序序列。</p><pre class=ql-align-justify>void InsertSort(SqList *L){ int i, j; for (i = 2; i &lt; L-&gt;length; i++) {  if (L-&gt;r[i] &lt; L-&gt;r[i-1]) {  L-&gt;r[0] = L-&gt;r[i]; for (j = i-1; L-&gt;r[j] &gt; L-&gt;r[0]; j++) L-&gt;r[j+1] = L-&gt;r[i];  L-&gt;r[j+1] = L-&gt;r[0]; } }}</pre><p class=ql-align-justify>代码说明</p><ul><li class=ql-align-justify>直接插入排序的时间复杂度为O(n^2)。</li><li class=ql-align-justify>直接插入排序比冒泡和简单选择排序的性能要好一些。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>四、希尔排序</p><p class=ql-align-justify>希尔排序是对直接插入排序的改进：</p><ul><li class=ql-align-justify><strong>将原本有大量记录数的记录进行分组。分割成若干个子序列</strong>；</li><li class=ql-align-justify>对子序列<strong>分别进行直接插入排序</strong>；</li><li class=ql-align-justify>当整个序列都<strong>基本有序时</strong>（<em>注意是基本有序</em>），再对全体记录进行一次直接插入排序。</li><li class=ql-align-justify>所谓的<strong>基本有序</strong>，<strong>就是小的关键字基本在前，大的基本在后面，不大不小的基本在中间</strong>，如{9,1,5,8,3,7,5,6,2}，变成{2,1,3,6,4,7,8,9}这样就是<strong>基本有序</strong>，但是像{1,5,9,7,8,2,4,6}这样9在第三位，2在倒数第三位就不是基本有序。</li><li class=ql-align-justify>对于分割子序列，采取<strong>跳跃分割的策略</strong>：</li><li class=ql-align-justify><strong>将相距某个“增量”的记录组成一个子序列</strong>，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。</li><li class=ql-align-justify>增量的选取非常关键，但是现在还是一个数学难题(迄今没有找到一种最好的增量序列),大量研究表明，增量序列为dlta[k] = 2^(t-k+1) - 1时，可以获得不错的效果。</li></ul><p class=ql-align-justify>希尔排序的核心思想：<strong>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止</strong></p><ul><li><br></li></ul><pre>void ShellSort(SqList *L){  int i,j;  int increment = L-&gt;length;  do { increment = increment /3 +1;  for (i = increment + 1; i &lt; L-&gt;length; i++) {  if (L-&gt;r[i] &lt; L-&gt;r[i-increment]) {  L-&gt;r[0] = L-&gt;r[i];  for (j = i - increment; i &gt;0 &amp;&amp; L-&gt;r[0] &lt; L-&gt;r[j]; j -= increment) L-&gt;r[j+increment] = L-&gt;r[j];  L-&gt;r[j+increment] = L-&gt;r[0]; } } } while (increment &gt; 1);}</pre><p class=ql-align-justify>代码说明</p><ul><li class=ql-align-justify>希尔排序的时间复杂度为O(n^(3/2))，要好于直接插入排序的O(n^2);</li><li class=ql-align-justify><strong>增量的最后一个增量之必须等于1才行</strong>。</li><li class=ql-align-justify>由于记录是跳跃式的移动，所以希尔排序<strong>不是一种稳定的排序算法</strong>。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>五、堆排序</p><p class=ql-align-justify>堆的概念</p><p class=ql-align-justify>堆是具有如下性质的<strong>完全二叉树</strong>：</p><ul><li class=ql-align-justify>每个结点的值都<strong>大于或等于其其左右孩子结点的值，为大顶堆</strong>。</li><li class=ql-align-justify>或者每个结点的值都<strong>小于或等于其左右孩子结点的值，称为小顶堆</strong>。</li><li class=ql-align-justify>因此<strong>根节点一定是堆中所有结点最大（小）者</strong>。</li><li class=ql-align-justify>如图左边为大顶堆，右边为小顶堆：</li></ul><div class=pgc-img><img alt="算法 － 七大排序算法详细介绍" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/38cd58b7790a484fa73f96020a2a12cd><p class=pgc-img-caption></p></div><ul><li class=ql-align-justify><br></li><li class=ql-align-justify>左边为大顶堆，右边为小顶堆</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>堆排序算法</p><p class=ql-align-justify><strong>堆排序（Heap Sort）</strong>是利用堆（假设是大顶堆）进行排序。</p><p class=ql-align-justify>堆排序的核心思想：</p><ul><li class=ql-align-justify>将待排序的序列构造成一个大顶堆。</li><li class=ql-align-justify>此时，<strong>整个序列的最大值就是堆顶的根节点。</strong></li><li class=ql-align-justify>将根节点移走(<strong>其实就是将它与堆数组的末尾元素交换，此时末尾元素就是最大值</strong>)，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素的次小值。</li><li class=ql-align-justify>重复上诉操作，便能得到一个有序序列。</li></ul><p class=ql-align-justify><br></p><div class=pgc-img><img alt="算法 － 七大排序算法详细介绍" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5515ac00d7e945519f8f771b21b617dd><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>堆排序算法核心</p><ul><li class=ql-align-justify>如何由一个无序序列构建成一个堆</li><li class=ql-align-justify>如何在输出堆顶元素后，调整剩余元素成一个新的堆</li></ul><p class=ql-align-justify>堆排序算法代码实现</p><ul><li><br></li></ul><pre>void HeadAdjust(SqList *L, int s, int m){ int temp, j; temp = L-&gt;r[s];  for (j = 2 *s; j &lt;= m; j *= 2) {  if (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j+1]) j++;  if (temp &gt;= L-&gt;r[j]) break;  L-&gt;r[s] = L-&gt;r[j]; s = j; }  L-&gt;r[s] = temp;}void HeapSort(SqList *L){ int i;  for (i = L-&gt;length / 2; i&gt;0; i--) HeadAdjust(L, i, L-&gt;length);  for (i = L-&gt;length; i &gt; 1; i--) { swap(L, 1, i); HeadAdjust(L, 1, i-1); }}</pre><p class=ql-align-justify>堆排序算法代码说明</p><ul><li class=ql-align-justify>堆排序方法HeapSort中有两个for循环：</li><li class=ql-align-justify>第一个for循环完成将现在的待排序序列构建成一个大顶堆；</li><li class=ql-align-justify>第二个for循环完成逐渐将每个最大值的根节点与末尾元素交换，并且再调整其成为大顶堆。</li><li class="ql-align-justify ql-indent-1">第一个for循环中的i = L->length / 2,i从[9/2]=4开始，4->3->2->1的变化量。</li><li class="ql-align-justify ql-indent-1">（这里赋值的原因是这些都是有孩子的结点）</li><li class="ql-align-justify ql-indent-1">构建好有孩子的结点之后，就可以从上到下、从左到右，将每个将每个非终端结点（非叶子结点）当做<strong>根节点</strong>,将其和子树调整成大顶堆。</li><li class=ql-align-justify>函数HeadAdjust的作用是将数组构建成一个大顶堆，在构建的时候利用了二叉树的性质。</li><li class=ql-align-justify>构建堆的时间复杂度为O(n)，重建堆的时间复杂度为O(nlogn)，所以总体来说<strong>堆排序的时间复杂度为O(nlogn)</strong>，性能上远好于冒泡、简单选择、直接插入的时间复杂度。</li><li class=ql-align-justify>在空间复杂度上，由于记录的交换和比较是跳跃式进行的，所以<strong>堆排序是一种不稳定的排序方法</strong>。</li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>六、归并排序</p><p class=ql-align-justify><strong>归并排序(Merging Sort)</strong>是利用归并的思想实现的。2路归并排序的核心思想如下：</p><ul><li class=ql-align-justify>假设初始序列有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为<strong>1</strong>，然后两两归并，得到n/2个长度为2或者1的有序子序列</li><li class=ql-align-justify>再两两归并...如此重复，直至得到一个长度为n的有序序列为止。</li></ul><p class=ql-align-justify>6.1归并排序的实现思路（递归实现）</p><ul><li class=ql-align-justify>将序列平均分成两部分</li><li class=ql-align-justify>分别对这两部分用递归来归并</li><li class=ql-align-justify>将这两部分归并到一起</li></ul><p class=ql-align-justify>归并排序的代码实现（递归实现）</p><ul><li><br></li></ul><pre>#pragma - 6.归并排序(递归实现)void Merge(int SR[], int TR[], int i, int m, int n){  int j, k, l;  for (j = m+1, k = i; i &lt;= m &amp;&amp; j &lt;= n; k++) {  if (SR[i] &lt; SR[j]) TR[k] = SR[i++]; else TR[k] = SR[j++]; }  if (i &lt;= m) { for (l=0; l &lt;= m-i; l++) TR[k+l] = SR[i+l]; }  if (j &lt;= n) { for (l=0; l &lt;= n-j; l++) TR[k+l] = SR[j+l]; }}void MSort(int SR[], int TR1[], int s, int t){ int m; int TR2[MAXSIZE+1];  if (s == t) { TR1[s] = SR[s]; }else{ m = (s+t)/2; MSort(SR, TR2, s, m); MSort(SR, TR2, m+1, t); Merge(TR2, TR1, s, m, t); }}void MergeSort(SqList *L){ MSort(L-&gt;r, L-&gt;r, 1, L-&gt;length);}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>归并排序的总结（递归实现）</p><ul><li class=ql-align-justify>归并排序总的时间复杂度为O(nlogn)，并且这是归并排序算法中最好、最坏、平均的时间性能。</li><li class=ql-align-justify>归并排序的空间复杂度为O(n+logn)</li><li class=ql-align-justify>归并排序是一种比较占内存，但是<strong>效率高且稳定</strong>的算法。</li></ul><p class=ql-align-justify>6.2归并排序的实现（迭代非递归实现）</p><p class=ql-align-justify>用迭代实现的话，可以<strong>从最小的序列开始归并直到完成</strong>。</p><ul><li><br></li></ul><pre>#pragma - 7.归并排序（迭代实现）void MergePass(int SR[], int TR[], int s, int n){  int i = 1; int j;  while (i &lt;= n-2*s+1) { Merge(SR, TR, i, i+s-1, i+2*s-1); i = i+2*s; }  if (i &lt; n-s+1) Merge(SR, TR, i, i+s-1, n); else for (j = i; j &lt;= n; j++) TR[j] = SR[j];}void MergeSort2(SqList *L){  int * TR = (int *)malloc(sizeof(L-&gt;length*sizeof(int))); int k = 1;  while (k &lt; L-&gt;length) { MergePass(L-&gt;r, TR, k, L-&gt;length); k = 2*k;  MergePass(TR, L-&gt;r, k, L-&gt;length); k = 2*k; }}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>归并的迭代实现总结</p><ul><li class=ql-align-justify>非递归的迭代方法，避免了递归时深度为log2n的栈空间，空间只是用到申请归并临时用的TR数组，因此<strong>空间复杂度为O(n)</strong>.</li><li class=ql-align-justify>并且相对于递归，在时间性能上也有一定的提升，所以使用归并时，<strong>尽量使用非递归实现。</strong></li></ul><hr class=ql-align-justify><p class=ql-align-justify><br></p><p class=ql-align-justify>七、快速排序</p><p class=ql-align-justify><strong>快速排序(Quick Sort)</strong>的基本思想是：</p><ul><li class=ql-align-justify>通过一趟排序将待排序记录分割成独立的两部分</li><li class=ql-align-justify>其中一部分记录的关键字均比另一部分记录的关键字小；</li><li class=ql-align-justify>则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。</li></ul><p class=ql-align-justify>快速排序的实现思路</p><ul><li class=ql-align-justify>选取一个<strong>关键字</strong>，放到一个位置，<strong>使得它的左边的值都比它小，右边的值都比它大</strong>，这个关键字叫做<strong>枢轴（pivot)</strong></li><li class=ql-align-justify>然后分别对左边和右边进行排序。</li></ul><p class=ql-align-justify>快速排序的代码实现</p><ul><li><br></li></ul><pre>#pragma - 8.快速排序int Partition(SqList * L, int low, int high){  int pivotkey; pivotkey = L-&gt;r[low];  while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high --; swap(L, low, high);  while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) high++; swap(L, low, high); }  return low;}void QSort(SqList *L, int low, int high){  int pivot; if (low &lt; high) { pivot = Partition(L, low, high); QSort(L, low, pivot-1); QSort(L, pivot+1, high); }}void QuickSort(SqList *L){ QSort(L, 1, L-&gt;length);}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>快速排序的代码说明</p><ul><li class=ql-align-justify>Partition函数就是将选取的pivotkey不断交换，<strong>将比它小的换到它的左边，比它大的交换到它的右边，它也在交换中不断更改自己的位置</strong>，直到完全满足这个要求为止。</li><li class=ql-align-justify>快速排序的时间性能取决于快速递归的深度，<strong>快排的时间复杂度为O(nlogn)</strong>。</li><li class=ql-align-justify>快速排序的空间复杂度主要是递归造成的栈空间的使用，平均情况下<strong>空间复杂度为O(nlogn)。</strong></li><li class=ql-align-justify>由于关键字的比较和交换是跳跃进行的，因此，<strong>快排是一种不稳定的排序算法</strong></li></ul><p class=ql-align-justify>快速排序的优化</p><ol><li class=ql-align-justify><strong>优化选取枢轴</strong></li><li class=ql-align-justify>在上面的代码中，选取枢轴的方式为：</li><li class=ql-align-justify>pivotkey = L->r[low]，即用序列的第一个元素作为枢轴，这是理想情况下 L->r[low]是中间数。</li><li class=ql-align-justify>但是对于其他情况，这种<strong>固定选取</strong>第一个关键子作为首个枢轴的方法就不是很合理。</li><li class=ql-align-justify>于是可以用下面的方法优化：</li></ol><ul><li class="ql-align-justify ql-indent-1"><strong>三数取中(median-of-three)法</strong>：</li><li class="ql-align-justify ql-indent-1"><strong>取三个关键子进行排序，将中间数作为枢轴，一般取左端、右端和中间三个数</strong>，也可以随机选取。</li><li class="ql-align-justify ql-indent-1"><strong>九数取中(median-of-nine)法</strong>：</li><li class="ql-align-justify ql-indent-1">先从数组中分三次取样，每次取三个数，三个样品各取中数，然后从这三个数当中再取出一个中数作为枢轴</li></ul><p class=ql-align-justify><strong>三数取中(median-of-three)法</strong>代码：</p><ul><li><br></li></ul><pre> int pivotkey;  int m = low + (high - low)/2;  if (L-&gt;r[low] &gt; L-&gt;r[high]) swap(L, low, high);  if (L-&gt;r[m] &gt; L-&gt;r[high]) swap(L, high, m); if (L-&gt;r[m] &gt; L-&gt;r[low]) swap(L, m, low);  pivotkey = L-&gt;r[low];</pre><ol><li class=ql-align-justify><strong>优化不必要的交换</strong></li><li class=ql-align-justify><strong>优化小数组时的排序方案</strong></li><li class=ql-align-justify><strong>优化递归操作</strong></li></ol><p class=ql-align-justify>快速排序优化后的代码</p><ul><li><br></li></ul><pre>int Partition1(SqList * L, int low, int high){  int pivotkey;  int m = low + (high - low)/2;  if (L-&gt;r[low] &gt; L-&gt;r[high]) swap(L, low, high);  if (L-&gt;r[m] &gt; L-&gt;r[high]) swap(L, high, m); if (L-&gt;r[m] &gt; L-&gt;r[low]) swap(L, m, low);  pivotkey = L-&gt;r[low]; L-&gt;r[0] = pivotkey;  while (low &lt; high) { while (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey) high--; L-&gt;r[low] = L-&gt;r[high];  while (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey) low++; L-&gt;r[high] = L-&gt;r[low]; }  L-&gt;r[low] = L-&gt;r[0];  return low;}void QSort1(SqList *L, int low, int high){  int pivot; if ((high -low) &gt; MAX_LINEGIH_INSERT_SORT) { while (low &lt; high) { pivot = Partition1(L, low, high); QSort1(L, low, pivot-1);  low = pivot+1; } }else InsertSort(L);}void QuickSort1(SqList *L){ QSort1(L, 1, L-&gt;length);}</pre><ul><li class=ql-align-justify><strong>希尔排序</strong>相当于<strong>直接插入排序</strong>的升级，同属于<strong>插入排序类</strong></li><li class=ql-align-justify><strong>堆排序</strong>相当于<strong>简单选择排序</strong>的升级，同属于<strong>选择排序类</strong></li><li class=ql-align-justify><strong>快速排序</strong>相当于<strong>冒泡排序</strong>的升级，同属于<strong>交换排序类</strong></li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'算法','详细介绍','排序'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>