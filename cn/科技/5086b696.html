<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>架构师成神之路 | 极客快訊</title><meta property="og:title" content="架构师成神之路 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f284b547c7aa4e6f857167b519f5c885"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5086b696.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5086b696.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5086b696.html><meta property="article:published_time" content="2020-11-14T21:01:46+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:46+08:00"><meta name=Keywords content><meta name=description content="架构师成神之路"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5086b696.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>架构师成神之路</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>这是本人的架构师学习路线，分享出来希望能帮到大家，谢谢。</strong></p><p>https://blog.csdn.net/hguisu/article/details/78258430 架构设计</p><p>https://blog.csdn.net/u012410733/article/list/3?t=1 dubbo很好的博客</p><p>源码：springmvc、mybatis、spring、dubbbo、rocketmq</p><p>一、常用设计模式</p><p>1、proxy模式</p><pre>package com.sun.proxy;import com.sun.cglibproxy.Cglibproxy;import com.sun.jdkproxy.JdkProxy;public class Main { public static void main(String[] args) { //静态代理 Proxy proxy = new Proxy(new RealSubject()); proxy.request(); //jdk动态代理 JdkProxy jdkProxy = new JdkProxy(new RealSubject()); Subject subject1 = (Subject)jdkProxy.getProxyObject(); subject1.request(); //cglib动态代理 Cglibproxy cglibproxy = new Cglibproxy(new RealSubject()); Subject subject2 = (Subject)cglibproxy.getProxyObject(); subject2.request(); }}</pre><p>2、工厂模式</p><p>https://www.cnblogs.com/carryjack/p/7709861.html</p><p>https://www.cnblogs.com/zailushang1996/p/8601808.html</p><p>https://www.jianshu.com/p/74f4c52e1bd9</p><p>1）简单工厂</p><p>2）工厂方法 //一个产品</p><p>2）抽象工厂 //多个产品，一个产品族</p><p>结合spring中的FactoryBean</p><p>阅读原码，FactoryBean是通过泛型传递实际对象的类型，它有三个方法：</p><p>a)getObject()，返回生成的对象;</p><p>b)getObjectType()，返回对象类型;</p><p>c)isSingleton() ，是否是单例，true:是，false:不是。</p><p>3、单例（Singleton）模式</p><p>https://www.cnblogs.com/cielosun/p/6582333.html</p><p>单例模式有3个要点：</p><p>某个类只能有一个实例</p><p>它必须自行创建这个实例</p><p>它必须自行向整个系统提供这个实例</p><p>1）懒汉模式</p><pre>public class SingletonDemo { private static SingletonDemo instance; private SingletonDemo(){ } public static SingletonDemo getInstance(){ if(instance==null){ instance=new SingletonDemo(); } return instance; }}</pre><p>如上，通过提供一个静态的对象instance，利用private权限的构造方法和getInstance()方法来给予访问者一个单例。</p><p>缺点是，没有考虑到线程安全，可能存在多个访问者同时访问，并同时构造了多个对象的问题。之所以叫做懒汉模式，主要是因为此种方法可以非常明显的lazy loading。</p><p>2）线程安全的懒汉模式</p><pre>public class SingletonDemo { private static SingletonDemo instance; private SingletonDemo(){ } public static synchronized SingletonDemo getInstance(){ if(instance==null){ instance=new SingletonDemo(); } return instance; }}</pre><p>然而并发其实是一种特殊情况，大多时候这个锁占用的额外资源都浪费了，这种打补丁方式写出来的结构效率很低。</p><p>3）饿汉模式</p><pre>public class EHsingleton { private static EHsingleton instance = new EHsingleton(); private EHsingleton(){} public static EHsingleton getInstance(){ return instance; }}</pre><p>单例加载时就加载,这种方法没有起到lazy loading的效果</p><p>4)静态内部类加载</p><pre>public class StaticClasssingleton { private static class StaticClasssingletonHelper{ private static StaticClasssingleton instance = new StaticClasssingleton(); } private StaticClasssingleton(){ System.out.println("Singleton has loaded"); } public static StaticClasssingleton getInstance(){ return StaticClasssingletonHelper.instance; }}</pre><p>使用内部类的好处是，静态内部类不会在单例加载时就加载，而是在调用getInstance()方法时才进行加载，达到了类似懒汉模式的效果，而这种方法又是线程安全的。</p><p>5)枚举方法</p><pre>enum SingletonDemo{ INSTANCE; public void otherMethods(){ System.out.println("Something"); }}</pre><p>6)双重校验锁法</p><p>//双重校验锁法</p><pre>public class DoubleSynchronizedSingleton { private static DoubleSynchronizedSingleton instance; private DoubleSynchronizedSingleton(){}; public static DoubleSynchronizedSingleton getInstance(){ if(instance == null){ synchronized (DoubleSynchronizedSingleton.class) { if(instance == null){ instance = new DoubleSynchronizedSingleton(); } } } return instance; }}</pre><p>接下来我解释一下在并发时，双重校验锁法会有怎样的情景：</p><p>STEP 1. 线程A访问getInstance()方法，因为单例还没有实例化，所以进入了锁定块。</p><p>STEP 2. 线程B访问getInstance()方法，因为单例还没有实例化，得以访问接下来代码块，而接下来代码块已经被线程1锁定。</p><p>STEP 3. 线程A进入下一判断，因为单例还没有实例化，所以进行单例实例化，成功实例化后退出代码块，解除锁定。</p><p>STEP 4. 线程B进入接下来代码块，锁定线程，进入下一判断，因为已经实例化，退出代码块，解除锁定。</p><p>STEP 5. 线程A初始化并获取到了单例实例并返回，线程B获取了在线程A中初始化的单例。</p><p>理论上双重校验锁法是线程安全的，并且，这种方法实现了lazyloading。</p><p>//Spring单例模式与线程安全</p><p>https://www.cnblogs.com/wxd0108/p/5524756.html</p><p>同步机制采用了 “ 以时间换空间 ” 的方式，而 ThreadLocal 采用了 “ 以空间换时间 ” 的方式,前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响</p><p>ThreadLocal 是解决线程安全问题一个很好的思路，它通过为每个线程提供一个独立的变量副本解决了变量并发访问的冲突问题。在很多情况下， ThreadLocal 比直接使用 synchronized 同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p><p>4、delegate 委派模式</p><pre>class A{ void method1(){...} void method2(){...}}class B{ //delegation A a = new A(); //method with the same name in A void method1(){ a.method1();} void method2(){ a.method2();} //other methods and attributes ...}public class Test{ public static void main(String args[]){ B b = new B(); b.method1();//invoke method2 of class A in fact b.method2();//invoke method1 of class A in fact }}</pre><p>委托的缺点：代码量大，类更多。</p><p>----- delegate委派模式和Proxy代理模式 -----</p><p>Proxy :译为代理， 被代理方（B）与代理方（A）的接口完全一致。</p><p>主要使用场景：为简化编程（或无法操作B）而把请求交给代理方（A），由代理方与被代理方进行通信，以完成请求。</p><p>Delegete : 译为委托</p><p>主要使用场景：一件事情（或一个请求）对象本身不知道怎样处理，对象把请求交给其它对象来做。</p><p>简单来讲，可以这么理解，代理是若干个对象实现了一个共同的接口，而委派只是说明一个对象引用了另一个对象，并不牵扯接口。</p><p>应用场景</p><p>Spring MVC框架中的DispatcherServlet其实就用了委派模式，也有人称为是代理模式和策略模式的组合。</p><p>DispatcherServlet的委托流程</p><p>用户发送请求——>DispatcherServlet，前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制。</p><p>DispatcherServlet——>HandlerMapping，映射处理器将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象。</p><p>DispatcherServlet——>HandlerAdapter，处理器适配器将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器。</p><p>DispatcherServlet——> ViewResolver， 视图解析器将把ModelAndView对象（包含模型数据、逻辑视图名）解析为具体的View。</p><p>DispatcherServlet——>View，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构。</p><p>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p><p>5、Strategy策略模式</p><p>https://www.jianshu.com/p/7b7de81cdfbe</p><p>准备一组算法，并将每一个算法封装起来，使得它们可以互换</p><p>这个模式涉及到三个角色：</p><p>● 环境(Context)角色：持有一个Strategy的引用。</p><p>● 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</p><p>● 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。</p><p>策略模式的优点：</p><p> 算法可以自由切换；</p><p> 避免使用多重条件判断；</p><p> 扩展性良好。</p><p>策略模式的缺点：</p><p> 策略类会增多</p><p> 所有策略类都需要对外暴露</p><p>策略模式的适用场景：</p><p> 当一个系统中有许多类，它们之间的区别仅在于它们的行为，希望动态地让一个对象在许多行为中选择一种行为时；</p><p> 当一个系统需要动态地在几种算法中选择一种时；</p><p> 当一个对象有很多的行为，不想使用多重的条件选择语句来选择使用哪个行为时。</p><p>6、prototype 原型模式</p><p>https://www.cnblogs.com/cxxjohnson/p/6403949.html</p><p>原型模式：原型模式就是从一个对象再创建另外一个可定制的对象，而且不需要知道任何创建的细节。</p><p>所谓原型模式，就是java中的克隆技术，以某个对象为原型。复制出新的对象。显然新的对象具备原型对象的特点。效率高（避免了重新执行构造过程步骤）</p><p>克隆类似于new，但和new不同。new创建新的对象属性采用的是默认值。克隆出来的对象的属性值完全和原型对象相同。并且克隆出的新对象不会影响原型对象，克隆后。还可以再修改克隆对象的值。</p><p>要实现原型模式，必须实现Cloneable接口，而这个接口里面是空的。</p><p>浅克隆：copy该对象，然后保留该对象原有的引用。也就是说不克隆该对象的属性。</p><p>深克隆：copy该对象，并且把该对象的所有属性也克隆出一份新的。</p><p>通过序列化和反序列化来实现深克隆对象：序列化需要原型对象实现Serializable接口</p><p>所以，通过原型模式创建对象，可以大大提高创建的效率，直接克隆，避免了重新执行构造过程。原型模式和工厂模式搭配起来，是常用的使用方式。</p><p>新的问题：Java的clone方法实现的是浅复制，对基本类型的复制，这样的操作是没有问题的。但对非基本类型的变量，复制的是对象的引用，导致最后两个变量指向同一个对象。</p><p>解决方法：深复制</p><p>PS：深拷贝与浅拷贝问题中，会发生深拷贝的有java中的8中基本类型以及他们的封装类型，另外还有String类型。其余的都是浅拷贝。</p><p>浅拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象.</p><p>深拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制.</p><p>7、template 模板模式</p><p>https://www.cnblogs.com/qq-361807535/p/6854191.html</p><p>模板模式是使用一个抽象类，里面定义了一系列模板方法，也就是一个算法骨架，再定义一个总的调用统筹方法。统筹方法就是定义模板方法的执行顺序，一般设定该方法为final ，是不让子类破坏的。</p><p>现在有一个问题：我们能不能用接口去代替AbstractDisplay？答案是：不可以，因为我们这种模式的侧重点在于由父类决定处理流程，这处理流程display方法必须要在父类中去实现，但是接口是不能去实现方法的。</p><p>场景:</p><p>jdbcTemplate callback结合使用</p><pre>public abstract class JdbcTemplate {  //template method  public final Object execute(String sql) throws SQLException{  Connection con = HsqldbUtil.getConnection();  Statement stmt = null;  try {  stmt = con.createStatement();  ResultSet rs = stmt.executeQuery(sql);  Object result = doInStatement(rs);//abstract method  return result;  }  catch (SQLException ex) {  ex.printStackTrace();  throw ex;  }  finally {  try {  stmt.close();  } catch (SQLException e) {  e.printStackTrace();  }  try {  if(!con.isClosed()){  try {  con.close();  } catch (SQLException e) {  e.printStackTrace();  }  }  } catch (SQLException e) {  e.printStackTrace();  }  }  }  //implements in subclass  protected abstract Object doInStatement(ResultSet rs); } </pre><p>在上面这个抽象类中，封装了SUN JDBC API的主要流程，而遍历ResultSet这一步骤则放到抽象方法doInStatement()中，由子类负责实现。</p><p>好，我们来定义一个子类，并继承上面的父类：</p><pre>public class JdbcTemplateUserImpl extends JdbcTemplate {  @Override  protected Object doInStatement(ResultSet rs) {  List&lt;User&gt; userList = new ArrayList&lt;User&gt;();  try {  User user = null;  while (rs.next()) {  user = new User();  user.setId(rs.getInt("id"));  user.setUserName(rs.getString("user_name"));  user.setBirth(rs.getDate("birth"));  user.setCreateDate(rs.getDate("create_date"));  userList.add(user);  }  return userList;  } catch (SQLException e) {  e.printStackTrace();  return null;  }  } } </pre><p>由代码可见，我们在doInStatement()方法中，对ResultSet进行了遍历，最后并返回。</p><p>有人可能要问：我如何获取ResultSet 并传给doInStatement()方法啊？？呵呵，问这个问题的大多是新手。因为此方法不是由子类调用的，而是由父类调用，并把ResultSet传递给子类的。我们来看一下测试代码：</p><p>String sql = "select * from User";</p><p>JdbcTemplate jt = new JdbcTemplateUserImpl();</p><p>List&lt;User> userList = (List&lt;User>) jt.execute(sql);</p><p>为什么spring不用传统的模板方法，而加之以Callback进行配合呢？</p><p>试想，如果父类中有10个抽象方法，而继承它的所有子类则要将这10个抽象方法全部实现，子类显得非常臃肿。而有时候某个子类只需要定制父类中的某一个方法该怎么办呢？这个时候就要用到Callback回调了</p><p>二、spring5</p><p>1、IOC容器设计原理及高级特性</p><p>https://www.cnblogs.com/linjiqin/archive/2013/11/04/3407126.html 设计原理</p><p>https://blog.csdn.net/sugar_rainbow/article/details/76757383 高级特性</p><p>https://www.cnblogs.com/ITtangtang/p/3978349.html 源码解析</p><p>在Spring IOC容器的代表就是org.springframework.beans包中的BeanFactory接口，BeanFactory接口提供了IOC容器最基本功能；而org.springframework.context包下的ApplicationContext接口扩展了BeanFactory，还提供了与Spring AOP集成、国际化处理、事件传播及提供不同层次的context实现 (如针对web应用的WebApplicationContext)。简单说， BeanFactory提供了IOC容器最基本功能，而 ApplicationContext 则增加了更多支持企业级功能支持。ApplicationContext完全继承BeanFactory，因而BeanFactory所具有的语义也适用于ApplicationContext。</p><p>让我们来看下IOC容器到底是如何工作。在此我们以xml配置方式来分析一下：</p><p>一、准备配置文件：就像前边Hello World配置文件一样，在配置文件中声明Bean定义也就是为Bean配置元数据。</p><p>二、由IOC容器进行解析元数据： IOC容器的Bean Reader读取并解析配置文件，根据定义生成BeanDefinition配置元数据对象，IOC容器根据BeanDefinition进行实例化、配置及组装Bean。</p><p>三、实例化IOC容器：由客户端实例化容器，获取需要的Bean。</p><pre>public void refresh() throws BeansException, IllegalStateException {  synchronized (this.startupShutdownMonitor) {  //调用容器准备刷新的方法，获取容器的当时时间，同时给容器设置同步标识  prepareRefresh();  //告诉子类启动refreshBeanFactory()方法，Bean定义资源文件的载入从  //子类的refreshBeanFactory()方法启动  ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();  //为BeanFactory配置容器特性，例如类加载器、事件处理器等  prepareBeanFactory(beanFactory);  try {  //为容器的某些子类指定特殊的BeanPost事件处理器  postProcessBeanFactory(beanFactory);  //调用所有注册的BeanFactoryPostProcessor的Bean  invokeBeanFactoryPostProcessors(beanFactory);  //为BeanFactory注册BeanPost事件处理器.  //BeanPostProcessor是Bean后置处理器，用于监听容器触发的事件  registerBeanPostProcessors(beanFactory);  //初始化信息源，和国际化相关.  initMessageSource();  //初始化容器事件传播器.  initApplicationEventMulticaster();  //调用子类的某些特殊Bean初始化方法  onRefresh();  //为事件传播器注册事件监听器.  registerListeners();  //初始化所有剩余的单态Bean.  finishBeanFactoryInitialization(beanFactory);  //初始化容器的生命周期事件处理器，并发布容器的生命周期事件  finishRefresh();  }  catch (BeansException ex) {  //销毁以创建的单态Bean  destroyBeans();  //取消refresh操作，重置容器的同步标识.  cancelRefresh(ex);  throw ex;  }  }  }</pre><p>Spring IoC容器对Bean定义资源的载入是从refresh()函数开始的，refresh()是一个模板方法，refresh()方法的作用是：在创建IoC容器前，如果已经有容器存在，则需要把已有的容器销毁和关闭，以保证在refresh之后使用的是新建立起来的IoC容器。refresh的作用类似于对IoC容器的重启，在新建立好的容器中对容器进行初始化，对Bean定义资源进行载入</p><p>FileSystemXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh()函数启动整个IoC容器对Bean定义的载入过程</p><p>2、spring aop</p><pre>public class MyAspect { private final Logger logger = LoggerFactory.getLogger(this.getClass()); @Pointcut("execution(public void *.method1)") public void pointcutName(){} @Around("pointcutName()") public Object performanceTrace(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { try { logger.info("log....."); return proceedingJoinPoint.proceed(); } finally { logger.info("log end"); } }}</pre><p>定义Aspect</p><pre>@Aspect@Componentpublic class AdviceTest { @Pointcut("@annotation(com.listenzhangbin.aop.Timer)") public void pointcut() { } @Before("pointcut()") public void before() { System.out.println("before"); }}</pre><p>3、spring 事务</p><p>https://baijiahao.baidu.com/s?id=1607466404459549668&wfr=spider&for=pc</p><p>1）、配置文件开启注解驱动，在相关的类和方法上通过注解@Transactional标识。</p><p>2）、spring 在启动的时候会去解析生成相关的bean，这时候会查看拥有相关注解的类和方法，并且为这些类和方法生成代理，并根据@Transaction的相关参数进行相关配置注入，这样就在代理中为我们把相关的事务处理掉了（开启正常提交事务，异常回滚事务）。</p><p>3）、真正的数据库层的事务提交和回滚是通过binlog或者redo log实现的。</p><p>4、springmvc九大组件以及手写springmvc框架</p><p>https://www.cnblogs.com/java1024/p/8556519.html</p><p>https://blog.csdn.net/it_freshman/article/details/81365000 SpringMVC3-处理-源码跟踪</p><p>https://www.cnblogs.com/kylyww/p/6405888.html</p><p>初始化流程</p><p>使用Spring MVC 时，需要在web.xml中配置DispatchServlet,这个DispatchServlet可以看成一个控制器的具体实现。作为一个控制器所有的请求都要通过它来处理，进行转发、匹配、数据处理后并转由页面进行展示。因此DispatchServlet是Spring MVC的核心部分。</p><p>在完成ContextLoaderListener的初始化后，Web容器开始初始化DispatcherServlet,这个初始化的启动与在web.xml中对载入次序的定义有关。DispathcerServlet会建立自己的上下文来持有Spring MVC的Bean,在建立这个自己的IOC容器时，会从ServletContext中得到根上下文作为自己持有上下文的双亲上下文。有了这个根上下文再对自己持有的上下文进行初始化，最后将自己持有的上下文保存到ServletContext中。</p><p>首先看看DispatcherSerlvet的继承关系：DispatcherServlet继承自FrameworkServlet,而FrameworkServet继承自HttpServletBean.HttpServletBean有继承了HttpServlet.</p><p>DispatcherServlet动作大致可以分为两个部分：初始化部分由initServletBean()启动，通过initWebApplicationContext()方法调用DispatcherServlet的initStrategies方法。在这个方法里，DispatcherServlet对MVC的其他部分进行了初始化，比如handlerMapping,ViewResolver;另一个部分是对Http的请求进行响应，作为一个Servlet，web容器会调用Servlet的doGet()和doPost()方法，在经过FrameServlet的processRequest（）简单处理后，会调用DispatcherServlet的doService（）方法，在这个方法中封装了doDispatch().</p><p>在这里主要介绍初始化部分。</p><p>作为Servlet, DispatcherServlet的启动过程和Servlet启动过程是相联系的。在Servlet的初始化过程中，Servlet的init方法被调用，已进行初始化。</p><p>HttppServletBean.init()->FrameworkServlet.initWebApplicationContext()->DispatcherServlet.onRefresh().->initStrategies(初始化九大组件)</p><p>springmvc请求流程</p><p>httpServlet#service->protected service->doGet/doPost->frameworkServlet#doGet/doPost->final processRequest(无论成功与否 发布publishRequestHandledEvent)->abstract doService->DispatcherServlet#doService（设置九大组件的属性）->doDispatcher</p><p>往下流程：</p><p>用户发送请求至前端控制器DispatcherServlet</p><p>DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p><p>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p><p>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</p><p>执行处理器(Controller，也叫后端控制器)。</p><p>Controller执行完成返回ModelAndView</p><p>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet</p><p>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</p><p>ViewReslover解析后返回具体View</p><p>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</p><p>DispatcherServlet响应用户。</p><p>从上面可以看出，DispatcherServlet有接收请求，响应结果，转发等作用。有了DispatcherServlet之后，可以减少组件之间的耦合度。</p><p>doDispatch()结构</p><p>doDispatch的方法也非常简洁，从顶层设计了整个请求的处理过程。doDispatch的最核心代码只有4句，它们的任务分别是：</p><p>根据request找到Handler以及对应的interceptors</p><p>根据Handler找到对应的HandlerAdapter</p><p>用HandlerAdapter处理Handler</p><p>处理上面处理之后的结果（包含找到View并渲染给用户）,最终调用afterCompletion</p><pre>protected void doDispatcher(HttpServletRequest req, HttpServletResponse res) throws Exception{ HttpServletRequest processRequet = req; HandlerExecutionChain mappedHandler = null; ModelAndView mv = null; processRequet = checkMultipart(req); //获取handler mappedHandler = getHandler(processRequet); //获取handlerAdapter HandlerAdapter h = getHandlerAdapter(mappedHandler.getHandler()); //执行handler注册的interceptors中的preHandle方法 HandlerInterceptor[] interceptors = mappedHandler.getInterceptors(); for(int i = 0 ;i&lt;interceptors.length;i++){ interceptors[i].preHandle(processRequet, res, mappedHandler); } //处理handler mv = h.handle(processRequet, res, mappedHandler.getHandler()); //执行handler注册的interceptors中的postHandle方法 for(int i = 0 ;i&lt;interceptors.length;i++){ interceptors[i].postHandle(processRequet, res, mappedHandler,mv); } }</pre><p>三、mybatis</p><p>1、mybatis代码自动生成器</p><p>generatorConfig.xml</p><p>2、mybatis动态代理的实现</p><p>https://blog.csdn.net/xiaokang123456kao/article/details/76228684</p><p>使用jdk动态代理实现</p><p>3、mybatis源码解析</p><p>https://blog.csdn.net/ma15732625261/article/details/81123349</p><p>https://www.jianshu.com/p/0d7db721c4b5</p><p>总结：</p><p>1）获取sqlsessionFactory：把配置文件解析关保存在configuration对象中，返回包含了configuration的defaultSqlSession对象</p><p>2）获取sqlSession：返回sqlsession实现类defaultsqlsession对象，它里面包含了executor和configuration，executor在这步创建</p><p>3）获取接口代理对象MapperProxy：getmapper返回接口的代理对象，包含sqlsession对象</p><p>4）代理对象-》defaultsqlsession->executor->statementhandler->parameterhandler,resultsethandler->typehandler->jdbc</p><p>加载全局配置文件->配置类->MapperFactoryBean（MapperFactoryBean 实现了Spring的FactoryBean接口） 创建UserMapper实例，该实例是通过jdk的动态代理实现的</p><p>->MapperProxy(MapperProxyFactory创建)->sqlsessiontemplate->mapperProxy#invoke->mapperMethod#execute->sqlsessiontemplate#select->SqlSessionInterceptor#invoke</p><p>->sqlsession#invoke->sqlSession#commit->sqlSession#closeSqlsession</p><p>主要构件及其相互关系</p><p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p><p>SqlSession：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能；</p><p>Executor：MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护；</p><p>StatementHandler：封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。</p><p>ParameterHandler：负责对用户传递的参数转换成JDBC Statement 所需要的参数；</p><p>ResultSetHandler：负责将JDBC返回的ResultSet结果集对象转换成List类型的集合；</p><p>TypeHandler：负责java数据类型和jdbc数据类型之间的映射和转换；</p><p>MappedStatement：MappedStatement维护了一条&lt;select|update|delete|insert>节点的封装；</p><p>SqlSource：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回；</p><p>BoundSql：表示动态生成的SQL语句以及相应的参数信息；</p><p>Configuration：MyBatis所有的配置信息都维持在Configuration对象之中；</p><p>---------------------</p><p>https://blog.csdn.net/worn_xiao/article/details/78888640 mybatis的工作原理</p><p>如上图所示是mybatis的工作原理</p><p>1 首先程序加载全局的配置文件，形成配置文件类</p><p>2 通过Mapper的接口形成一个mapper的代理</p><p>3 通过调用mapper的代理执行对应的方法，此时代理中会发现，method.getdeclareClass并不是一个类，而是一个接口</p><p>4 此时通过执行mapperMethod，也就是接口的方法，因为mepperproxy是组合了sqlsession的，当调用mapper接口的方法时，它通过方法的映射，最终还是调用的sqlsession的接口方法。</p><p>5sqlsession本身不带有接口的实现类，所以此时sqlsession类就组合进来Excutor执行器对接口中从配置文件中获取到的statement对应的sql进行执行。最终返回结果映射。</p><p>---------------------</p><p>各个Executor简单分析</p><p>SimpleExecutor是最简单的执行器，根据对应的sql直接执行即可，不会做一些额外的操作；</p><p>BatchExecutor执行器，顾名思义，通过批量操作来优化性能。通常需要注意的是批量更新操作，由于内部有缓存的实现，使用完成后记得调用flushStatements来清除缓存。</p><p>ReuseExecutor 可重用的执行器，重用的对象是Statement，也就是说该执行器会缓存同一个sql的Statement，省去Statement的重新创建，优化性能。内部的实现是通过一个HashMap来维护Statement对象的。由于当前Map只在该session中有效，所以使用完成后记得调用flushStatements来清除Map</p><p>这些就是mybatis的三种执行器。你可以通过配置文件的settings里面的元素defaultExecutorType，配置它，默认是采用SimpleExecutor如果你在Spring运用它，那么你可以这么配置它：</p><p>如果有二级缓存配置开启，则创建cachingExecutor</p><p>&lt;bean id="sqlSessionTemplateBatch" class="org.mybatis.spring.SqlSessionTemplate"></p><p>&lt;constructor-arg index="0" ref="sqlSessionFactory" /></p><p>&lt;!--更新采用批量的executor --></p><p>&lt;constructor-arg index="1" value="BATCH"/></p><p>&lt;/bean></p><p>---------------------</p><p>这样，它便是一个批量的执行器。mybatis的三个executor都有一个共同的父类——BaseExecutor。</p><p>https://blog.csdn.net/qq_38409944/article/details/82494187</p><p>总结：</p><p>1、获取sqlSessionFactory对象:</p><p>根据配置文件（全局，sql映射）初始化出Configuration对象</p><p>解析文件的每一个信息保存在Configuration中，返回包含Configuration的DefaultSqlSession；</p><p>注意：MappedStatement：代表一个增删改查的详细信息</p><p>2、获取sqlSession对象</p><p>返回一个DefaultSQlSession对象，包含Executor和Configuration;</p><p>这一步会创建Executor对象；</p><p>Executor（根据全局配置文件中的defaultExecutorType创建出对应的Executor）</p><p>3、获取接口的代理对象（MapperProxy）</p><p>DefaultSqlSession.getMapper（）：拿到Mapper接口对应的MapperProxy；</p><p>使用MapperProxyFactory创建一个MapperProxy的代理对象</p><p>代理对象里面包含了，DefaultSqlSession（Executor）</p><p>4、执行增删改查方法</p><p>1）调用DefaultSqlSession的增删改查（Executor）；</p><p>2）会创建一个StatementHandler对象。</p><p>（同时也会创建出ParameterHandler和ResultSetHandler）</p><p>3）调用StatementHandler预编译参数以及设置参数值;</p><p>使用ParameterHandler来给sql设置参数</p><p>4）调用StatementHandler的增删改查方法；</p><p>5）ResultSetHandler封装结果</p><p>SqlSession是过程级,一个方法中建立,方法结束应该关闭,不是线程安全的</p><p>四、maven</p><p>1、 Maven中的dependency的scope作用域详解</p><p>1）、test范围指的是测试范围有效，在编译和打包时都不会使用这个依赖</p><p>2）、compile范围指的是编译范围有效，在编译和打包时都会将依赖存储进去</p><p>3）、provided依赖：在编译和测试的过程有效，最后生成war包时不会加入，诸如：servlet-api，因为servlet-api，tomcat等web服务器已经存在了，如果再打包会冲突</p><p>4）、runtime在运行的时候依赖，在编译的时候不依赖</p><p>2、maven jar包</p><p>https://blog.csdn.net/T2080305/article/details/82144543</p><p>1）maven中jar包的依赖是传递依赖</p><p>2）Maven采用了两种避免冲突的策略： 1、短路优先，2、声明优先</p><p>解决方案：1、移除多余的jar包</p><p>五、分布式架构原理</p><p>1、漫谈分布式架构</p><p>https://blog.csdn.net/lj1314ailj/article/details/80765012</p><p>2、分布式架构及意义</p><p>https://blog.csdn.net/qq_41555178/article/details/81484473</p><p>https://blog.csdn.net/yp1125/article/details/79125477</p><p>https://www.cnblogs.com/dump/p/8125539.html 大型分布式架构详解</p><p>3、分布式架构网络通信原理剖析</p><p>RMI（远程方法调用）：</p><p>1）客户端发起请求，请求转交至RMI客户端的stub类；</p><p>2）stub类将请求的接口、方法、参数等信息进行序列化；</p><p>3）基于socket将序列化后的流传输至服务器端；</p><p>4）服务器端接收到流后转发至相应的skelton类；</p><p>5）skelton类将请求的信息反序列化后调用实际的处理类；</p><p>6）处理类处理完毕后将结果返回给skelton类；</p><p>7）Skelton类将结果序列化，通过socket将流传送给客户端的stub；</p><p>8）stub在接收到流后反序列化，将反序列化后的Java Object返回给调用者。</p><p>XML-RPC：</p><p>1）客户端发起请求，按照XML-RPC协议将请求信息进行填充；</p><p>2）填充完毕后将xml转化为流，通过传输协议进行传输；</p><p>3）接收到在接收到流后转换为xml，按照XML-RPC协议获取请求的信息并进行处理；</p><p>4）处理完毕后将结果按照XML-RPC协议写入xml中并返回。</p><p>4、通信协议中的序列化与反序列化</p><p>https://blog.csdn.net/sanyaoxu_2/article/details/79722431</p><p>1）序列化的“鼻祖”</p><p>我知道的第一种序列化协议就是Java默认提供的序列化机制，需要序列化的Java对象只需要实现 Serializable / Externalizable 接口并生成序列化ID，这个类就能够通过 ObjectInput 和 ObjectOutput 序列化和反序列化，若对Java默认的序列化协议不了解，或是遗忘了，请参考：序列化详解</p><p>但是Java默认提供的序列化有很多问题，主要有以下几个缺点：</p><p>无法跨语言：我认为这对于Java序列化的发展是致命的“失误”，因为Java序列化后的字节数组，其它语言无法进行反序列化。；</p><p>序列化后的码流太大:：相对于目前主流的序列化协议，Java序列化后的码流太大；</p><p>序列化的性能差：由于Java序列化采用同步阻塞IO，相对于目前主流的序列化协议，它的效率非常差。</p><p>2）.影响序列化性能的关键因素</p><p>序列化后的码流大小（网络带宽的占用）；</p><p>序列化的性能（CPU资源占用）；</p><p>是否支持跨语言（异构系统的对接和开发语言切换）。</p><p>5、dubbo 管理平台与监控平台的安装与部署</p><p>https://blog.csdn.net/lindonglian/article/details/78562678</p><p>6、Dubbo集群容错机制及负载均衡策略</p><p>https://www.jianshu.com/p/48acb5707da5</p><p>1）这里的Invoker是Provider的一个可调用Service的抽象，Invoker封装了Provider地址及Service接口信息。</p><p>2）Directory代表多个Invoker，可以把它看成List&lt;Invoker>，但与List不同的是，它的值可能是动态变化的，比如注册中心推送变更。</p><p>3）Cluster将Directory中的多个Invoker伪装成一个Invoker，对上层透明，伪装过程包含了容错逻辑，调用失败后，重试另一个。</p><p>4）Router负责从多个Invoker中按路由规则选出子集，比如读写分离，应用隔离等。</p><p>5）LoadBalance负责从多个Invoker中选出具体的一个用于本次调用，选的过程包含了负载均衡算法，调用失败后，需要重选。</p><p>7、dubbo 源码解析</p><p>https://blog.csdn.net/u012410733/article/details/77417497 dubbo说得比较到位</p><p>cluster#join->Directory#list->router#route->LoadBalance#select</p><p>proxyfactory#getInvoker#getProxy</p><p>protocol#export#refer</p><p>referenceconfig#init</p><p>serviceconfig#ref实例</p><p>集群容错主要包括以下几种模式：</p><p>Failover Cluster：失败自动切换，当出现失败，重试其它服务器 。通常用于读操作，但重试会带来更长延迟。可通过 retries="2" 来设置重试次数(不含第一次)。</p><p>Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。</p><p>Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。</p><p>Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</p><p>Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数。</p><p>Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 2。通常用于通知所有提供者更新缓存或日志等本地资源信息。</p><p>1）服务提供者暴露一个服务的详细过程</p><p>具体服务到Invoker的转化：ServiceConfig类#对外提供服务的实际类引用ref->ProxyFactory#getInvoker->AbstractProxyInvoker</p><p>Invoker转换到Exporter: DubboProtocol#export->它主要是打开socket侦听服务，并接收客户端发来的各种请求，通讯细节由Dubbo自己实现</p><p>serviceconfig#ref实例-》proxyfactory#getInvoker(AbstractProxyInvoker实例，即invoker)->protocol#export</p><p>invoker:interface的class实例、实例类对象、url、当前接口的代理对象wrapper实例</p><p>2）服务消费者消费一个服务的详细过程</p><p>ReferenceConfig#init->DubboProtocol#refer[获取invoker]->ProxyFactory#getProxy->ref</p><p>3）dubbo源码分析 之 架构原理探索</p><p>启动Zookeeper服务：用于dubbo的注册中心。</p><p>启动Zookeeper Inspector:它是Zookeeper服务信息查看工具。</p><p>4）dubbo源码分析 之 内核SPI实现</p><p>为什么不使用JDK SPI</p><p>在dubbo中它实现了一套自己的SPI机制。JDK标准的SPI会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源.</p><p>增加了对扩展点IoC和AOP的支持，一个扩展点可以直接setter注入其它扩展点。</p><p>dubbo的领域对象</p><p>在dubbo当中它的核心领域对象就是Invoker，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它。</p><p>在dubbo中通过Protocol这个来管理Invoker的生命周期，包括服务的暴露与引用都是通过它来完成的。而在进行服务调用的时候通过Invocation来保存调用过程中的变量：包括方法名，参数等。所以在整个dubbo调用过程当中：</p><p>Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。</p><p>Protocol 是服务域，它是 Invoker 暴露和引用的主功能入口，它负责 Invoker 的生命周期管理。</p><p>Invocation 是会话域，它持有调用过程中的变量，比如方法名，参数等。</p><p>dubbo 远程服务(Provider)暴露最终其实就是创建一个 Netty Serve 服务，然后在 dubbo 在服务引用的时候创建一个 Netty Client 服务。其实 dubbo 远程通信的原理其实就是基于 Socket 的远程通信。下面我们来看一下 dubbo 是如何创建一个 Netty 服务的，下面就是它创建的序列图：</p><p>它通过传入 URL 与 requestHandler来创建一个 ExchangeServer，通过Netty 基于 NIO的形式通过自定义Channel来接收服务引用方传递过来的信息，以及发送调用远程服务的本地方法后的数据给服务调用者。URL 里面主要包含 IP 地址 与 端口信息用于创建 Socket 连接，而 requestHandler是一个 ExchangeHandler 通过自定义协议来处理 dubbo 的远程通信。</p><p>https://www.cnblogs.com/lengfo/p/4293399.html dubbo各协议性能比较</p><p>性能分析</p><p>测试过程中尽管考虑了非常多的影响因素，但仍然有很多局限性，包括连接数限制、并发量、线程池策略、Cache、IO、硬件性能瓶颈等等因素，而且各自的适用场景不同，测试结果仅供参考。</p><p>从单线程测试结果可以看出，dubbo协议采用NIO复用单一长连接更适合满足高并发小数据量的rpc调用，而在大数据量下的传输性能并不好，建议使用rmi协议，多线程测试中dubbo协议对小数据量的rpc调用同样保持优势，在大数据量的传输中由于长连接的原因对比rmi协议传输耗时差距并不明显，这点同样验证了上述观点。关于数据的序列化方式选择需要考虑序列化和反序列化的效率问题，传输内容的大小，以及格式的兼容性约束，其中hessian2作为duobb协议下的默认序列化方式，推荐使用。</p><p>8、分布式消息通信activemq/kafka/rabbitmq/rocketmq</p><p>能够保证严格的消息顺序</p><p>提供丰富的消息拉取模式</p><p>高效的订阅者水平扩展能力</p><p>实时的消息订阅机制</p><p>亿级消息堆积能力</p><p>Metaq3.0 版本改名，产品名称改为RocketMQ</p><p>RocketMQ是阿里review kafka的java版，如果 消息性能要求高 用rocketmq与kafka可以更优</p><p>总结：</p><p>1、性能小 量小 用什么都没有关系，性质是一样的，如果 消息性能要求高 用rocketmq与kafka可以更优，rocketmq与kafka 比较就看技术选型了，各有利弊，看业务需要。</p><p>2、activemq rabbitmq 与 kafka、rocketmq有很大的区别就是前2个只支持主从模式，后2个是分布式消息系统，支持分布式。</p><p>3、持久化消息比较： zeroMq不支持，activeMq和rabbitMq都支持。</p><p>持久化消息主要是指：MQ down或者MQ所在的服务器down了，消息不会丢失的机制。</p><p>4、其中包括持久化消息和瞬时消息的测试。注意这篇文章里面提到的MQ，都是采用默认配置的，并无调优。</p><p>ZeroMq 最好，RabbitMq 次之， ActiveMq 最差。这个结论来自于以下这两篇文章。</p><p>http://blog.x-aeon.com/2013/04/10/a-quick-message-queue-benchmark-activemq-rabbitmq-hornetq-qpid-apollo/</p><p>其中包括持久化消息和瞬时消息的测试。注意这篇文章里面提到的MQ，都是采用默认配置的，并无调优。</p><p>http://www.cnblogs.com/amityat/archive/2011/08/31/2160293.html</p><p>显示的是发送和接受的每秒钟的消息数。整个过程共产生1百万条1K的消息。测试的执行是在一个Windows Vista上进行的。</p><p>5、技术点：可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统、社区</p><p>RabbitMq最好，ActiveMq次之，ZeroMq最差。当然ZeroMq也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</p><p>所以在可靠性和可用性上，RabbitMQ是首选，虽然ActiveMQ也具备，但是它性能不及RabbitMQ。</p><p>6、高并发</p><p>从实现语言来看，RabbitMQ最高，原因是它的实现语言是天生具备高并发高可用的erlang语言。</p><p>小结：</p><p>按照目前网络上的资料，RabbitMQ、activeM、zeroMQ三者中，综合来看，RabbitMQ是首选。下面提供一篇文章，是淘宝使用RabbitMQ的心得，可以参看一些业务场景。</p><p>http://www.docin.com/p-462677246.html</p><p>7、kafka和RabbitMQ的比较</p><p>关于这两种MQ的比较，网上的资料并不多，最权威的的是kafka的提交者写一篇文章。http://www.quora.com/What-are-the-differences-between-Apache-Kafka-and-RabbitMQ</p><p>里面提到的要点：</p><p>1)、 RabbitMq比kafka成熟，在可用性上，稳定性上，可靠性上，RabbitMq超过kafka</p><p>2)、 Kafka设计的初衷就是处理日志的，可以看做是一个日志系统，针对性很强，所以它并没有具备一个成熟MQ应该具备的特性</p><p>3)、 Kafka的性能（吞吐量、tps）比RabbitMq要强，这篇文章的作者认为，两者在这方面没有可比性。</p><p>这里在附上两篇文章，也是关于kafka和RabbitMq之间的比较的：</p><p>1)、http://www.mrhaoting.com/?p=139</p><p>2)、http://www.liaoqiqi.com/post/227</p><p>总结：</p><p>两者对比后，我仍然是选择RabbitMq，性能其实是很强劲的，同时具备了一个成熟的MQ应该具有的特性，我们无需重新发明轮子。</p><p>8、redis api</p><p>https://blog.csdn.net/zhangguanghui002/article/details/78770071</p><pre>public static void test(){ ShardedJedis jedis = RedisManager.getJedis(); String key = "11"; String value = "11"; //----------value---------------------- boolean ex = jedis.exists(key);//该key是否存在 long count = jedis.del(key);//删除key,返回删除key的数量 //返回值：// none (key不存在)// string (字符串)// list (列表)// set (集合)// zset (有序集)// hash (哈希表) String type = jedis.type(key);//返回key的类型 jedis.hkeys(key); jedis.srandmember(key);// 当 key 不存在时，返回 -2 。// 当 key 存在但没有设置剩余生存时间时，返回 -1 。// 否则，以秒为单位，返回 key 的剩余生存时间。 jedis.ttl(key);//获取剩余生存时间 返回值时间// 设置成功返回 1 。// 当 key 不存在或者不能为 key 设置生存时间时(比如在低于 2.1.3 版本的 Redis 中你尝试更新 key 的生存时间)，返回 0  jedis.expire(key, 1);//设置过期时间为1秒// 当生存时间移除成功时，返回 1 .// 如果 key 不存在或 key 没有设置生存时间，返回 0 jedis.persist(key); //----------String----------------------// 在 Redis 2.6.12 版本以前， SET 命令总是返回 OK 。// 从 Redis 2.6.12 版本开始， SET 在设置操作成功完成时，才返回 OK 。// 如果设置了 NX 或者 XX ，但因为条件没达到而造成设置操作未执行，那么命令返回空批量回复（NULL Bulk Reply）。 jedis.set(key, value); jedis.setnx(key, value);//重复不插入 jedis.setex(key, 1, value);//增加数据项并设置有效时间 jedis.del(key); jedis.get(key); jedis.append(key, value);//在key对应的value后面扩展字符串value// 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。 jedis.getSet(key, value);//获取key对应的value并更新value jedis.getrange(key, 3, 6);//截取得出的子字符串。 jedis.incr(key);//将key对应的值+1 jedis.incrBy(key, 2);//将key对应的值+2 jedis.decr(key);//将key对应的值-1 jedis.decrBy(key, 2);//将key对应的值-2 //----------list---------------------- jedis.lpush(key, "1","a","c");//返回值 执行 LPUSH 命令后，列表的长度 jedis.lpush(key, value);//左插入 jedis.lrange(key, 0, 2);//获取list对应区间0到2的元素// 根据参数 count 的值，移除列表中与参数 value 相等的元素。//// count 的值可以是以下几种：//// count &gt; 0 : 从表头开始向表尾搜索，移除与 value 相等的元素，数量为 count 。// count &lt; 0 : 从表尾开始向表头搜索，移除与 value 相等的元素，数量为 count 的绝对值。// count = 0 : 移除表中所有与 value 相等的值 jedis.lrem(key, count, value); //删除list对应区间之外的元素 jedis.ltrim(key, 1, 2); jedis.lpop(key);//key对应list左出栈一个元素 jedis.rpush(key, value);//右插入 jedis.rpop(key);//key对应list右出栈一个元素 jedis.lset(key, 1, value);//修改key对应list指定下标index的值为value jedis.llen(key);//获取list的长度 jedis.lindex(key, 1);//获取list下标index的值 jedis.sort(key);//list里面的值从小到大排序 //----------set---------------------- jedis.sadd(key, "1","2");//将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略。 jedis.smembers(key);//获取该set对应的所有元素 jedis.srem(key, value);//删除一个值为value的元素 jedis.srem(key, "1","2","3");//删除一个值为value1,value2的元素 jedis.spop(key);//随机移除一个元素 jedis.scard(key);//获取set中元素个数 //----------hash---------------------- jedis.hmset(key, new HashMap&lt;String, String&gt;());//添加一个hash jedis.hset(key, "12", value);//往hash插入一个新域 jedis.hgetAll(key);//获取hash所有元素 jedis.hkeys(key);//获取hash所有元素的key jedis.hvals(key);//获取hash所有元素的value jedis.hincrBy(key, "12", 1);//把hash中key对应元素value+1 jedis.hdel(key, "12",value);//从hash中删除一个域多个元素 jedis.hlen(key);//获取hash中元素个数 jedis.hexists(key, "12");//判断hash中是否有12对应的元素 jedis.hmget(key, "12","13");//获取hash中一个或多个元素value jedis.hget(key, "12");//获取hash中一个元素value //-----------zsort------------------ jedis.zadd(key, new HashMap&lt;String, Double&gt;());//添加一个zset jedis.zrange(key, 1, 3);//获取zset中index，1-3中的元素value jedis.zrangeWithScores(key, 1, 3);//获取zset中index，1-3中的元素 jedis.zscore(key, value);//获取value为value的score值 jedis.zrank(key, value);//获取value为value的score排名 jedis.zrem(key, value);//删除value值为value的元素 jedis.zcard(key);//获取元素个数 jedis.zincrby(key, 1, value);//将zset中val为value的score+=1 //-----------排序操作------------------ SortingParams s = new SortingParams(); jedis.sort(key, s.alpha());//按首字母a-z排序 jedis.sort(key, s.asc());//按数字升序排 jedis.sort(key, s.desc());//按数字降序排 }</pre><p>9、redis主从复制</p><p>全量同步</p><p>Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份</p><p>增量同步</p><p>Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。</p><p>增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</p><p>Redis主从同步策略</p><p>主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。当然，如果有需要，slave 在任何时候都可以发起全量同步。redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。</p><p>无磁盘复制</p><p>通常来讲，一个完全重新同步需要在磁盘上创建一个RDB文件，然后加载这个文件以便为从服务器发送数据。</p><p>如果使用比较低速的磁盘，这种操作会给主服务器带来较大的压力。Redis从2.8.18版本开始尝试支持无磁盘的复制。</p><p>使用这种设置时，子进程直接将RDB通过网络发送给从服务器，不使用磁盘作为中间存储。</p><p>1）RDB方式(默认)</p><p>RDB方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间和改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。RDB是redis默认采用的持久化方式，在配置文件中已经预置了3个条件：</p><p>save 900 1 #900秒内有至少1个键被更改则进行快照</p><p>save 300 10 #300秒内有至少10个键被更改则进行快照</p><p>save 60 10000 #60秒内有至少10000个键被更改则进行快照</p><p>可以存在多个条件，条件之间是"或"的关系，只要满足其中一个条件，就会进行快照。 如果想要禁用自动快照，只需要将所有的save参数删除即可。</p><p>Redis默认会将快照文件存储在当前目录(可CONFIG GET dir来查看)的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。</p><p>Redis实现快照的过程</p><p>- Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；</p><p>- 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件；</p><p>- 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成。</p><p>- 在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令 ），操作系统会将该片数据复制一份以保证子进程的数据不受影响，所以新的RDB文件存储的是执行fork一刻的内存数据。</p><p>Redis在进行快照的过程中不会修改RDB文件，只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实 现Redis数据库备份。RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。</p><p>除了自动快照，还可以手动发送SAVE或BGSAVE命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内 存中需要花费20～30秒钟。 通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。</p><p>2）AOF方式</p><p>默认情况下Redis没有开启AOF(append only file)方式的持久化，可以在redis.conf中通过appendonly参数开启：</p><p>appendonly yes</p><p>在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些</p><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：</p><p>appendfilename appendonly.aof</p><p>配置redis自动重写AOF文件的条件</p><p>auto-aof-rewrite-percentage 100 # 当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据</p><p>auto-aof-rewrite-min-size 64mb # 允许重写的最小AOF文件大小</p><p>配置写入AOF文件后，要求系统刷新硬盘缓存的机制</p><p># appendfsync always # 每次执行写入都会执行同步，最安全也最慢</p><p>appendfsync everysec # 每秒执行一次同步操作</p><p># appendfsync no # 不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），最快也最不安全</p><p>Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少</p><p>10、nginx反向代理及负载均衡服务配置</p><p>https://www.cnblogs.com/Miss-mickey/p/6734831.html</p><p>11、netty 高性能</p><p>https://www.cnblogs.com/Irving/p/5709130.html</p><p>Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持，作为一个异步NIO框架，Netty的所有IO操作都是异步非阻塞的，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。</p><p>Netty架构分析</p><p>Netty 采用了比较典型的三层网络架构进行设计，逻辑架构图如下所示：</p><p>第一层：Reactor 通信调度层，它由一系列辅助类完成，包括 Reactor 线程 NioEventLoop 以及其父类、NioSocketChannel/NioServerSocketChannel 以及其父 类、ByteBuffer 以及由其衍生出来的各种 Buffer、Unsafe 以及其衍生出的各种内 部类等。该层的主要职责就是监听网络的读写和连接操作，负责将网络层的数据 读取到内存缓冲区中，然后触发各种网络事件，例如连接创建、连接激活、读事 件、写事件等等，将这些事件触发到 PipeLine 中，由 PipeLine 充当的职责链来 进行后续的处理。</p><p>第二层：职责链 PipeLine，它负责事件在职责链中的有序传播，同时负责动态的 编排职责链，职责链可以选择监听和处理自己关心的事件，它可以拦截处理和向 后/向前传播事件，不同的应用的 Handler 节点的功能也不同，通常情况下，往往 会开发编解码 Hanlder 用于消息的编解码，它可以将外部的协议消息转换成内部 的 POJO 对象，这样上层业务侧只需要关心处理业务逻辑即可，不需要感知底层 的协议差异和线程模型差异，实现了架构层面的分层隔离。</p><p>第三层：业务逻辑处理层，可以分为两类：</p><p>纯粹的业务逻辑 处理，例如订单处理。</p><p>应用层协议管理，例如HTTP协议、FTP协议等。</p><p>接下来，我从影响通信性能的三个方面（I/O模型、线程调度模型、序列化方式）来谈谈Netty的架构。</p><p>12、分布式全局id</p><p>1)Redis生成ID</p><p>当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现</p><p>2)SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：</p><p>1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0</p><p>41位，用来记录时间戳（毫秒）。</p><p>41位可以表示个数字，</p><p>如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 ，减1是因为可表示的数值范围是从0开始算的，而不是1。</p><p>也就是说41位可以表示个毫秒的值，转化成单位年则是年</p><p>10位，用来记录工作机器id。</p><p>可以部署在个节点，包括5位datacenterId和5位workerId</p><p>5位（bit）可以表示的最大正整数是，即可以用0、1、2、3、....31这32个数字，来表示不同的datecenterId或workerId</p><p>12位，序列号，用来记录同毫秒内产生的不同id。</p><p>12位（bit）可以表示的最大正整数是，即可以用0、1、2、3、....4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号</p><p>由于在Java中64bit的整数是long类型，所以在Java中SnowFlake算法生成的id就是long来存储的。</p><p>SnowFlake可以保证：</p><p>所有生成的id按时间趋势递增</p><p>整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）</p><p>13、session跨域共享 单点登录</p><p>session cookie 存储的是JSESSIONID</p><p>session存储在服务器端 cookie存储在浏览器端</p><p>服务器端(Tomcat) 会生成一个唯一的sessionId号存储在cookie中 叫 jessionid</p><p>在服务器端（tomcat）中存储serssion 使用concurrentMap (ConcurrentMap key JSESSIONID values session)</p><p>浏览器端下次请求服务器端是将jsessionId带过来 找到对应的session 获取session中存储的信息（用户信息）</p><p>14、分布式事务</p><p>https://www.cnblogs.com/lfs2640666960/p/9476241.html</p><p>对于TCC的解释:</p><p>Try阶段：尝试执行,完成所有业务检查（一致性）,预留必须业务资源（准隔离性）</p><p>Confirm阶段：确认执行真正执行业务，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作满足幂等性。要求具备幂等设计，Confirm失败后需要进行重试。</p><p>Cancel阶段：取消执行，释放Try阶段预留的业务资源</p><p>Cancel操作满足幂等性Cancel阶段的异常和Confirm阶段异常处理方案基本上一致。</p><p>举个简单的例子如果你用100元买了一瓶水，</p><p>Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。</p><p>如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。</p><p>如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)</p><p>对于TCC来说适合一些:</p><p>强隔离性，严格一致性要求的活动业务。</p><p>执行时间较短的业务</p><p>方案2 – RocketMQ 事务消息</p><p>为了能解决该问题，同时又不和业务耦合，RocketMQ提出了“事务消息”的概念。</p><p>具体来说，就是把消息的发送分成了2个阶段：Prepare阶段和确认阶段。</p><p>具体来说，上面的2个步骤，被分解成3个步骤：</p><p>(1) 发送Prepared消息</p><p>(2) update DB</p><p>(3) 根据update DB结果成功或失败，Confirm或者取消Prepared消息。</p><p>可能有人会问了，前2步执行成功了，最后1步失败了怎么办？这里就涉及到了RocketMQ的关键点：RocketMQ会定期（默认是1分钟）扫描所有的Prepared消息，询问发送方，到底是要确认这条消息发出去？还是取消此条消息？</p><p>可以考虑加定时任务自动扫描，自动努力保持一致性。</p><p>15、服务降级、限流</p><p>https://blog.csdn.net/vtopqx/article/details/79494599 1、mock 2、管理界面手动配置</p><p>https://blog.csdn.net/luckykapok918/article/details/72381992</p><p>查看dubbo的官方文档，可以发现有个mock的配置，mock只在出现非业务异常(比如超时，网络异常等)时执行。mock的配置支持两种，一种为boolean值，默认的为false。如果配置为true，则缺省使用mock类名，即类名+Mock后缀；另外一种则是配置"return null"，可以很简单的忽略掉异常。</p><p>dubbo开发中，通常是微服务架构，那么在使用过程中可能会遇到多种问题：</p><p>1）多个服务之间可能由于服务没有启动或者网络不通，调用中会出现远程调用失败;</p><p>2) 服务请求过大，需要停止部分服务以保证核心业务的正常运行；</p><p>以上两个问题可以使用Dubbo的服务降级来实现；</p><p>即：在服务宕掉或者并发数太高导致的RpcException异常时，进行友好的处理或者提示，而不是内部报错导致系统不可用。</p><p>1）第一种方式：在消费者端屏蔽</p><p>2） &lt;dubbo:reference id="userService" check="false" interface="com.cwh.service.UserService" timeout="3000" mock="return null"/></p><p>3） &lt;dubbo:reference id="userService" check="false" interface="com.cwh.service.UserService" timeout="3000" mock="true"/></p><p>打开soa-user-api项目，在com.cwh.service下也就是同UserService统计目录下新建一个UserServiceMock，注意这里名字一点要是该接口名+Mock：</p><pre>package com.cwh.service;import java.util.ArrayList;import java.util.List;import com.cwh.model.Article;import com.cwh.model.User;public class UserServiceMock implements UserService{ public List&lt;Article&gt;getUserArticles(int uid){ return null; } public List&lt;User&gt;getUser(String name){ //throw new RuntimeException("服务降级-----"); User user = new User(); user.setUserName("服务降级啦"); user.setUserAge("500"); List&lt;User&gt; list = new ArrayList&lt;User&gt;(); list.add(user); return list; }}</pre><p>16、分布式任务调度框架</p><p>https://blog.csdn.net/u012379844/article/details/82716146 总结各分布式任务调度框架</p><p>下载Elastic-job-lite源码，使用maven进行打包。在elastic-job-lite/elastic-job-lite-console/target/elastic-job-lite-console-3.0.0.M1-SNAPSHOT/中，然后解压，会有start.bat和start.sh两个脚本，启动。</p><p>六、微服务</p><p>1、微服务框架集成mybatis实现多数据源路由实战</p><p>https://www.2cto.com/kf/201805/746354.html</p><p>https://blog.csdn.net/xgx120413/article/details/80743959</p><p>2、如何设计微服务及其设计原则</p><p>https://blog.csdn.net/tiandiwuya/article/details/78543336</p><p>我们总结了四个方面的优点，分别如下：</p><p>是每个微服务组件都是简单灵活的，能够独立部署。不再像以前一样，应用需要一个庞大的应用服务器来支撑。</p><p>可以由一个小团队负责更专注专业，相应的也就更高效可靠。</p><p>微服务之间是松耦合的，微服务内部是高内聚的，每个微服务很容易按需扩展。</p><p>微服务架构与语言工具无关，自由选择合适的语言和工具，高效的完成业务目标即可。</p><p>我们总结了四个原则推荐给大家：</p><p>AKF拆分原则</p><p>前后端分离</p><p>无状态服务</p><p>Restful通信风格</p><p>对于无状态服务，首先说一下什么是状态：如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个“状态”数据的服务被称为有状态服务，反之称为无状态服务。</p><p>那么这个无状态服务原则并不是说在微服务架构里就不允许存在状态，表达的真实意思是要把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。</p><p>场景说明：例如我们以前在本地内存中建立的数据缓存、Session缓存，到现在的微服务架构中就应该把这些数据迁移到分布式缓存中存储，让业务服务变成一个无状态的计算节点。迁移后，就可以做到按需动态伸缩，微服务应用在运行时动态增删节点，就不再需要考虑缓存数据如何同步的问题。</p><p>作为一个原则来讲本来应该是个“无状态通信原则”，在这里我们直接推荐一个实践优选的Restful 通信风格 ，因为他有很多好处：</p><p>无状态协议HTTP，具备先天优势，扩展能力很强。例如需要安全加密是，有现成的成熟方案HTTPS可用。</p><p>JSON 报文序列化，轻量简单，人与机器均可读，学习成本低，搜索引擎友好。</p><p>语言无关，各大热门语言都提供成熟的Restful API框架，相对其他的一些RPC框架生态更完善。</p><p>当然在有些特殊业务场景下，也需要采用其他的RPC框架，如thrift、avro-rpc、grpc。但绝大多数情况下Restful就足够用了。</p><p>七、性能优化</p><p>1、性能指标</p><p>https://www.cnblogs.com/wangmo/p/8074879.html</p><p>一．系统吞度量要素：</p><p>一个系统的吞度量（承压能力）与request对CPU的消耗、外部接口、IO等等紧密关联。单个reqeust 对CPU消耗越高，外部系统接口、IO影响速度越慢，系统吞吐能力越低，反之越高。</p><p>系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间</p><p>QPS（TPS）：每秒钟request/事务 数量</p><p>并发数： 系统同时处理的request/事务数</p><p>响应时间： 一般取平均响应时间</p><p>（很多人经常会把并发数和TPS理解混淆）</p><p>2、jvm调优</p><p>https://www.cnblogs.com/xingzc/p/5756119.html</p><p>概括：</p><p>1 栈是运行时的单位 , 而堆是存储的单元。</p><p>2 栈解决程序的运行问题，即程序如何执行，或者说如何处理数据，</p><p>堆解决的是数据存储的问题，即数据怎么放，放在哪儿。</p><p>在java中一个线程就会相应有一个线程栈与之对应，这点很容易理解，因为不同的线程执行逻辑有所不同，因此需要一个独立的线程栈。</p><p>而堆则是所有线程共享的</p><p>java中，栈的大小通过-Xss来设置，当栈中存储的数据比较多时，需要适当调大这个值，否则会出现 java.lang.StackOverflowError异常。</p><p>常见的出现这个异常的是无法返回的递归，因为此时栈中保存的信息都是方法返回的记录点。</p><p>基本数据类型的大小是固定的，这里就不多说了，对于非基本类型的java对象，其大小就值得商讨。</p><p>在java中，一个空Object对象的大小是8byte，这个大小只是保存堆中一个没有任何属性的对象的大小。看看下面语句：</p><p>Object ob = new Object();</p><p>这样在程序中完成了一个java对象的声明，但是它所占的空间为：4byte+8byte。</p><p>（4byte是上面部分所说的java栈中保存引用的所需要空间，而那8byte则是java堆中对象的信息）。</p><p>持久代：</p><p>用于存放静态文件，如java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class,例如Hibernate等，在这种时候需要设置一个比较大的持久空间来存放这些运行过程中新增的类。持久代大小通过 -XX:MaxPermSize = &lt;N> 进行设置</p><p>有如下原因可能导致Full GC:</p><p>年老代（Tenured）被写满</p><p>持久代（Perm）被写满</p><p>System.gc()被显式调用</p><p>上一次GC之后Heap的各域分配策略动态变化</p><p>选择合适的垃圾收集算法</p><p>1)串行收集器</p><p>用单线程处理所有垃圾回收工作，因为无需多线程交互，所有效率比较高。但是，也无法使用多处理器的优势，所以此收集器适合单处理器机器。当然，此收集器也可以用在小数据量（100M左右）情况下的多处理器机器上。可以使用 -XX:+UseSerialGC打开</p><p>2)并行收集器</p><p>对年轻代进行并行垃圾回收，因此可以减少垃圾回收时间。一般在多线程多处理器机器上使用。使用 -XX:+UseParallelGC 打开。并行收集器在 J2SE5.0第六6更新上引入，在java SE6.0中进行了增强 --- 可以对年老代进行并行收集。如果年老代不使用并行收集的话，默认是使用单线程进行垃圾回收，因此会制约扩展能力。使用 -XX:+UseParallelOldGC打开。</p><p>使用 -XX:ParallelGCThreads = &lt;N> 设置并行垃圾回收的线程数。此值可以设置与机器处理器数量相等</p><p>此收集器可以进行如下配置：</p><p>最大垃圾回收暂停：指定垃圾回收时的最长暂停时间，通过-XX:MaxGCPauseMillis = &lt;N>指定。&lt;N> 为毫秒，如果指定了此值的话，堆大小和垃圾回收相关参数会进行调整以达到指定值。设定此值可能会减少应用的吞吐量。</p><p>吞吐量：吞吐量为垃圾回收时间与非垃圾回收时间的比值，通过-XX:GCTimeRatio = &lt;N> 来设定，公式为 1/(1 + N)。例如，-XX:GCTimeRatio = 19时，表示5%的时间用于垃圾回收。默认情况为99，即1%的时间用于垃圾回收。</p><p>3)并发收集器</p><p>可以保证大部分工作都并发进行（应用不停止），垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用。使用 -XX:+UseConcMarkSweepGC打开。</p><p>小结</p><p>串行处理器：</p><p>-- 适用情况：数据量比较小（100M左右），单处理器下并且对相应时间无要求的应用。</p><p>-- 缺点：只能用于小型应用。</p><p>并行处理器：</p><p>-- 适用情况：“对吞吐量有高要求”，多CPU，对应用过响应时间无要求的中、大型应用。举例：后台处理、科学计算。</p><p>-- 缺点：垃圾收集过程中应用响应时间可能加长。</p><p>并发处理器：</p><p>-- 适用情况：“对响应时间有高要求”，多CPU，对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。</p><p>以下配置主要针对分代垃圾回收算法而言。</p><p>堆大小设置</p><p>年轻代的设置很关键</p><p>JVM中最大堆大小有三方面限制：相关操作系统的数据模型（32-bit 还是64-bit）限制；系统的可用虚拟内存限制；系统的可用物理内存限制。32位系统下，一般限制在1.5G~2G；64位操作系统对内存无限制。在Windows Server 2003系统，3.5G物理内存，JDK5.0下测试，最大可设置为1478m。</p><p>典型设置：</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k</p><p>-Xmx3550m：设置JVM最大可用内存为3550m。</p><p>-Xms3550m：设置JVM初始内存为3550m。此值可以设置与 -Xmx 相同，以避免每次垃圾回收完成后JVM重新分配内存。</p><p>-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小+年老代大小+持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</p><p>-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256k。根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。</p><p>java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0</p><p>-XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1:4，年轻代占整个堆栈的1/5。</p><p>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6。</p><p>-XX:MaxPermSize=16m：设置持久代大小为16m。</p><p>-XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代的存活时间，增加在年轻代被回收的概率。</p><p>回收器选择</p><p>JVM给了三种选择：串行收集器、并行收集器、并发收集器，但是串行收集器只适用于小数据量的情况，所以这里的选择主要针对并行收集器和并发收集器。默认情况下，JDK5.0以前都是使用串行收集器，如果想使用其他收集器需要在启动的时候加入相应参数。JDK5.0以后，JVM会根据当前系统配置进行判断。</p><p>吞吐量优先的并行收集器</p><p>如上文所述，并行收集器主要以到达一定的吞吐量为目标，适用于科学计算和后台处理等。</p><p>典型配置：</p><p>java -Xmx3800m -Xms3800m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20</p><p>-XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。</p><p>-XX:+ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:ParallelGCThreads=20 -XX:+UseParallelOldGC</p><p>-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100</p><p>-XX:MaxGCPauseMillis=100：设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。</p><p>java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC -XX:MaxGCPauseMillis=100 -XX:+UseAdaptiveSizePolicy</p><p>-XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低响应时间或者收集频率等，此值建议使用并行收集器时，一直打开。</p><p>响应时间优先的并发收集器</p><p>如上文所述，并发收集器主要是保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。</p><p>典型配置：</p><p>java -Xmx3550m -Xms3550 -Xmn2g -Xss128k -XX:ParallelGCThreads=20 -XX:+UseConcMarkSweepGC -XX:+UseParNewGC</p><p>-XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。</p><p>-XX:+UseParNewGC：设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。</p><p>java -Xmx3550m -Xms3550 -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC -XX:CMSFullGCsBeforeCompaction=5 -XX:+UseCMSCompactAtFullCollection</p><p>-XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。</p><p>-XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片。</p><p>常见配置汇总</p><p>堆设置</p><p>-Xms：初始堆大小</p><p>-Xmx：最大堆大小</p><p>-XX:NewSize=n：设置年轻代大小</p><p>-XX:NewRatio=n：设置年轻代和年老代的比值。如：为3，表示年轻代与年老代比值为1：3，表示Eden：Survivor=3:2，一个Survivor区占整个年轻代的1/5。</p><p>-XX:MaxPermSize=n：设置持久代大小</p><p>收集器设置</p><p>-XX:+UseSerialGC：设置串行收集器</p><p>-XX:+UseParallelGC：设置并行收集器</p><p>-XX:+UseParalledlOldGC：设置并行年老代收集器</p><p>-XX:+UseConcMarkSweepGC：设置并发收集器</p><p>垃圾回收统计信息</p><p>-XX:+PrintGC</p><p>-XX:+PrintGCDetails</p><p>-XX:+PrintGCTimeStamps</p><p>-Xloggc:filename</p><p>并行收集器设置</p><p>-XX:ParallelGCThreads=n：设置并行收集器收集时使用的CPU数。并行收集线程数。</p><p>-XX:MaxGCPauseMillis=n：设置并行收集最大暂停时间</p><p>-XX:GCTimeRatio=n：设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+N)</p><p>并发收集器设置</p><p>-XX:+CMSIncrementalMode：设置为增量模式。适用於单CPU情况。</p><p>-XX:+ParallelGCThreads=n：设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><p>八、底层知识</p><p>1、JMM</p><p>JMM简介：</p><p>JMM：Java Memory Model(Java内存模型)，围绕着在并发过程中如何处理可见性、原子性、有序性这三个特性而建立的模型。OK，我们看一下三种特征。</p><p>原子性（atomicity）： 原子性是指一个操作不能被打断，要么全部执行完毕，要么不执行。在这点上有点类似于事务操作，要么全部执行成功，要么回退到执行该操作之前的状态 。由Java内存模型来直接保证原子性变量操作包括read, load, assign, use, store和write。大致可以认为基本数据类型的访问读写是具有原子性的。如果应用场景需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足需求，尽管虚拟机没有把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式地使用这两个操作，这两个字节码指令反映到Java代码中就是同步块——synchronized关键字，因此在synchronized块之间的操作也具备原子性。</p><p>可见性（visibility）： 可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步到主内存，无论是普通变量还是volatile变量都是如此，普通变量与volatile变量的区别是，volatile的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说volatile保证了多线程操作时变量的可见性，而普通变量不能保证这一点。</p><p>除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中”这条规则获得的，而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把"this"的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那在其他线程中就能看见final字段的值。</p><p>有序性： Java程序天然的有序性可以总结为一句话：如果本线程内观察，所有的操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。JMM模型提供了volatile和synchronized来保证线程之间操作的有序性。</p><p>总之，JMM模型就是提供一套机制来保证操作的原子性、可见性和有序性。根据数据是否被线程可见将JVM将内存组织为主内存和工作内存两个部分。主内存中主要包括本地方法区和堆。每个线程都有一个工作内存，工作内存中主要包括两个部分，一个是属于该线程的栈和对主存部分变量拷贝的寄存器：</p><p>总结：</p><p>① 线程间通信是通过共享主内存的方式去实现的。</p><p>② 线程间对共享数据操作时必须具备原子性、可见性和有序性。</p><p>③ 为了保证对主内存操作数据时不同步也为了操作的方便性，Java提供了Synchronized保证操作的原子性、可见性和有序性。提供了volatile可以保证操作的可见性。</p><p>volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</p><p>volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>1.1线程通信</p><p>https://blog.csdn.net/hqq2023623/article/details/51000854</p><p>https://blog.csdn.net/u012810020/article/details/60765988</p><p>https://www.jianshu.com/p/8a58d8335270</p><p>同步是指程序用于控制不同线程之间操作发生相对顺序的机制</p><p>1）共享内存</p><p>在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信</p><p>2）消息传递</p><p>在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来进行通信</p><p>java中典型的消息传递方式就是wait()和notify()</p><p>1.2消息传递</p><p>java中典型的消息传递方式就是wait()和notify()</p><p>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区</p><p>2、彻底搞懂synchronized(从偏向锁到重量级锁)</p><p>偏向锁01->轻量级锁00（自旋锁，自适应自旋锁--轻量级锁也被称为非阻塞同步、乐观锁，因为这个过程并没有把线程阻塞挂起，而是让线程空循环等待，串行执行。）->重量级锁10（互斥锁(重量级锁)也称为阻塞同步、悲观锁）</p><p>https://blog.csdn.net/qq_38462278/article/details/81976428</p><p>synchronized可重入锁的实现</p><p>之前谈到过，每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程持有，那么任何线程都都可能获得该锁而调用相应方法。当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器计为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增。当线程退出一个synchronized方法/块时，计数器会递减，如果计数器为0则释放该锁。</p><p>刚才我们说，锁实际上是加在对象上的，那么被加了锁的对象我们称之为锁对象，在java中，任何一个对象都能成为锁对象。</p><p>为了让大家更好着理解虚拟机是如何知道这个对象就是一个锁对象的，我们下面简单介绍一下java中一个对象的结构。</p><p>java对象在内存中的存储结构主要有一下三个部分：</p><p>对象头</p><p>实例数据</p><p>填充数据</p><p>这里强调一下，对象头里的数据主要是一些运行时的数据。</p><p>其简单的结构如下</p><p>长度 内容 说明</p><p>32/64bit Mark Work hashCode,GC分代年龄，锁信息</p><p>32/64bit Class Metadata Address 指向对象类型数据的指针</p><p>32/64bit Array Length 数组的长度(当对象为数组时)</p><p>当我们创建一个对象LockObject时，该对象的部分Markword关键数据如下。</p><p>bit fields 是否偏向锁 锁标志位</p><p>hash 0 01</p><p>从图中可以看出，偏向锁的标志位是“01”，状态是“0”，表示该对象还没有被加上偏向锁。（“1”是表示被加上偏向锁）。该对象被创建出来的那一刻，就有了偏向锁的标志位，这也说明了所有对象都是可偏向的，但所有对象的状态都为“0”，也同时说明所有被创建的对象的偏向锁并没有生效。</p><p>1）偏向锁 （在Jdk1.6中，偏向锁的开关是默认开启的，适用于只有一个线程访问同步块的场景）</p><p>不过，当线程执行到临界区（critical section）时，此时会利用CAS(Compare and Swap)操作，将线程ID插入到Markword中，同时修改偏向锁的标志位。</p><p>所谓临界区，就是只允许一个线程进去执行操作的区域，即同步代码块。CAS是一个原子性操作</p><p>此时的Mark word的结构信息如下：</p><p>bit fields 是否偏向锁 锁标志位</p><p>threadId epoch 1 01</p><p>此时偏向锁的状态为“1”，说明对象的偏向锁生效了，同时也可以看到，哪个线程获得了该对象的锁。</p><p>bit fields 锁标志位</p><p>指向LockRecord的指针 00</p><p>注：锁标志位”00”表示轻量级锁</p><p>轻量级锁主要有两种</p><p>自旋锁</p><p>自适应自旋锁</p><p>自旋锁的一些问题</p><p>如果同步代码块执行的很慢，需要消耗大量的时间，那么这个时侯，其他线程在原地等待空消耗cpu，这会让人很难受。</p><p>本来一个线程把锁释放之后，当前线程是能够获得锁的，但是假如这个时候有好几个线程都在竞争这个锁的话，那么有可能当前线程会获取不到锁，还得原地等待继续空循环消耗cup，甚至有可能一直获取不到锁。</p><p>默认情况下，自旋的次数为10次，用户可以通过-XX:PreBlockSpin来进行更改。</p><p>3、并发基础 aqs、cas</p><p>https://blog.csdn.net/zs064811/article/details/76996727 分独占锁与共享锁两类</p><p>4、countdownlatch cyclicbarrier semaphore</p><p>https://www.cnblogs.com/dolphin0520/p/3920397.html</p><p>1）countdownlatch -- await(),countdown()</p><p>2) cyclicbarrier -- await()</p><p>3) semaphore</p><p>Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。</p><p>下面对上面说的三个辅助类进行一个总结：</p><p>1）CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同：</p><p>CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；</p><p>而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；</p><p>另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。</p><p>2）Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。</p><p>5、并发集合concurrentHashMap</p><p>http://www.importnew.com/28263.html</p><p>6、threadlocal (使用场景，数据库连接，session管理(sessionfactory管理))</p><p>https://www.cnblogs.com/dolphin0520/p/3920407.html</p><p>虽然ThreadLocal的get，set方法可以清除ThreadLocalMap中key为null的value，但是get，set方法在内存泄露后并不会必然调用，所以为了防止此类情况的出现，我们有两种手段。</p><p>1、使用完线程共享变量后，显示调用ThreadLocalMap.remove方法清除线程共享变量；</p><p>2、JDK建议ThreadLocal定义为private static，这样ThreadLocal的弱引用问题则不存在了。</p><p>7、fork/join框架</p><p>https://www.cnblogs.com/senlinyang/p/7885964.html</p><p>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务(工作窃取算法)</p><p>https://www.cnblogs.com/wzqjy/p/7921063.html Java--8--新特性--串并行流与ForkJoin框架</p><p>Fork/Join与传统线程池的区别！</p><p>Fork/Join采用“工作窃取模式”，当执行新的任务时他可以将其拆分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随即线程中偷一个并把它加入自己的队列中。</p><p>就比如两个CPU上有不同的任务，这时候A已经执行完，B还有任务等待执行，这时候A就会将B队尾的任务偷过来，加入自己的队列中，对于传统的线程，ForkJoin更有效的利用的CPU资源！</p><p>8、callable,future</p><p>https://www.cnblogs.com/dolphin0520/p/3949310.html</p><p>Future类位于java.util.concurrent包下，它是一个接口：</p><pre>public interface Future&lt;V&gt; { boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;}</pre><p>9、线程池</p><p>executors创建的fixed,single的线程池，队列最大是integer.max会出现oom,cached,schedul创建的线程池会无限大integer.max，导致oom</p><div class=pgc-img><img alt=架构师成神之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f284b547c7aa4e6f857167b519f5c885><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'架构','师成','神之路'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>