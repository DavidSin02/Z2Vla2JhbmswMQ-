<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java面向对象之：接口、多态 | 极客快訊</title><meta property="og:title" content="Java面向对象之：接口、多态 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/d3f6934313714e52ae0687177d6ea9ad"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51db267.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/51db267.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/51db267.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="Java面向对象之：接口、多态"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/51db267.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java面向对象之：接口、多态</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>本篇我们将学习面向对象中的接口和多态：</p><h1 class=pgc-h-arrow-right><strong>第一章：接口</strong></h1><h1 class=pgc-h-arrow-right><strong>1.1-接口概述（了解）</strong></h1><p style=text-align:start><strong>什么是接口</strong></p><h1 class=pgc-h-arrow-right><strong>Java中的接口是 一系列方法的声明 ，是一些 方法特征的集合 。</strong></h1><p style=text-align:start>一个接口 <strong>只有方法的特征（只有声明）</strong> 没有 <strong>方法的实现（没有方法体）</strong> ，因此这些方法可以在不同的地方被不同的类实现，而这些实现可以具有不同的行为（功能）</p><p style=text-align:start>如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是 <strong>封装了方法</strong>，包含抽象方法（JDK 7及以前），默认方法和静态方法（JDK 8）。</p><p style=text-align:start>总而言之，Java中的接口就是一系列方法声明的集合。</p><p style=text-align:start><strong>为什么需要接口</strong></p><p style=text-align:start>接口的优势：</p><ul><li>是多态的基础</li><li>可以多实现（可以理解为多继承）</li></ul><p style=text-align:start><strong>接口是一种引用数据类型</strong></p><p style=text-align:start>接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p><p style=text-align:start>类和接口都是java代码，都会转换为字节码文件</p><pre><code>public class 类名.java → 类名.classpublic interface 接口名.java → 接口名.class</code></pre><h1 class=pgc-h-arrow-right><strong>1.2-接口的定义格式（记忆）</strong></h1><p style=text-align:start><strong>定义格式：关键字 interface</strong></p><pre><code>public interface 接口名称 {    // 抽象方法    // 默认方法    // 静态方法}</code></pre><p style=text-align:start><strong>接口中定义抽象方法</strong></p><p style=text-align:start>抽象方法：使用 <strong>abstract </strong>关键字修饰，可以省略，没有方法体。该方法供子类实现使用。</p><pre><code>public interface InterFaceName {    public abstract void method();}</code></pre><p style=text-align:start><strong>接口中定义默认方法和静态方法</strong></p><p style=text-align:start>默认方法：使用 <strong>default </strong>修饰，不可省略，供子类调用或者子类重写。</p><p style=text-align:start>静态方法：使用 <strong>static </strong>修饰，供接口直接调用。</p><pre><code>public interface InterFaceName {    public default void method() {        // 执行语句    }    public static void method2() {        // 执行语句        }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.3-接口的使用方式（记忆）</strong></h1><p style=text-align:start>我们之前学习继承时，父类需要子类继承。而接口和继承中父类相似，也需要一个类似子类的实现类来实现接口。</p><p style=text-align:start><strong>接口的实现</strong></p><p style=text-align:start>类与 <strong>接口</strong> 的关系为实现关系，即 <strong>类实现接口</strong> ，该类可以称为接口的 <strong>实现类</strong> ，也可以称为 <strong>接口的子类</strong> 。</p><p style=text-align:start>实现的动作类似继承，格式相仿，只是关键字不同，实现使用 <strong>implements </strong>关键字。</p><p style=text-align:start><strong>非抽象类实现接口注意事项</strong></p><ol start=1><li>必须重写接口中所有抽象方法。</li><li>继承了接口的默认方法，即可以直接调用，也可以重写。</li></ol><p style=text-align:start><strong>子类实现接口格式</strong></p><pre><code>public class 类名 implements 接口名 {    // 重写接口中抽象方法【必须】      // 重写接口中默认方法【可选】}</code></pre><p style=text-align:start><strong>子类实现接口中的 抽象方法</strong></p><p style=text-align:start>对于接口中定义的抽象方法，子类必须全部实现（重写）。代码如下：</p><p style=text-align:start>定义一个接口：LiveAble</p><pre><code>public interface LiveAble {    // 定义抽象方法    public abstract void eat();    public abstract void sleep();}</code></pre><p style=text-align:start>定义一个实现类：Animal</p><pre><code>public class Animal implements LiveAble {    @Override    public void eat() {        System.out.println("吃东西");    }    @Override    public void sleep() {        System.out.println("晚上睡");    }}</code></pre><p style=text-align:start>定义一个测试类：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 创建子类对象          Animal a = new Animal();        // 调用实现后的方法        a.eat();        a.sleep();    }}/*    输出结果：        吃东西        晚上睡*/</code></pre><p style=text-align:start><strong>子类使用或重写接口中的 默认方法</strong></p><p style=text-align:start>对于接口中的默认方法，子类可以继承，也可以重写，二选一，但是只能通过实现类的对象来调用。</p><h1 class=pgc-h-arrow-right><strong>直接使用默认方法，代码如下：</strong></h1><p style=text-align:start>定义接口：LiveAble</p><pre><code>public interface LiveAble {    public default void fly(){        System.out.println("天上飞");    }}</code></pre><p style=text-align:start>定义实现类：Animal</p><pre><code>public class Animal implements LiveAble {    // 继承，什么都不用写，直接调用}</code></pre><p style=text-align:start>定义测试类：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 创建子类对象          Animal a = new Animal();        // 调用默认方法        a.fly();    }}/*    输出结果：        天上飞*/</code></pre><h1 class=pgc-h-arrow-right><strong>或者重写默认方法，代码如下：</strong></h1><p style=text-align:start>定义接口：LiveAble 同上</p><p style=text-align:start>定义实现类：Animal</p><pre><code>public class Animal implements LiveAble {    @Override    public void fly() {        System.out.println("自由自在的飞");    }}</code></pre><p style=text-align:start>定义测试类：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // 创建子类对象          Animal a = new Animal();        // 调用重写方法        a.fly();    }}/*    输出结果：        自由自在的飞*/</code></pre><p style=text-align:start><strong>接口中 静态方法 的使用</strong></p><p style=text-align:start>静态与.class 文件相关， <strong>只能使用接口名调用</strong> ，不可以通过实现类的类名或者实现类的对象调用，代码如下：</p><p style=text-align:start>定义接口：LiveAble</p><pre><code>public interface LiveAble {    public static void run(){        System.out.println("跑起来~~~");    }}</code></pre><p style=text-align:start>定义实现类：Animal</p><pre><code>public class Animal implements LiveAble {    // 无法重写静态方法}</code></pre><p style=text-align:start>定义测试类：Test</p><pre><code>public class Test {    public static void main(String[] args) {        // Animal.run(); // 【错误】无法继承方法,也无法调用        LiveAble.run(); //     }}/*    输出结果：        跑起来~~~*/</code></pre><p style=text-align:start><strong>接口中 不能定义成员变量 ,可以定义常量</strong></p><p style=text-align:start>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static final修饰。</p><p style=text-align:start>定义接口：LiveAble</p><pre><code>public interface LiveAble {   int NUM0 ; // 错误,必须赋值     int NUM1 =10; // 正确 , 省去了默认修饰符 public static final   public static final int NUM2= 100; // 正确 , 完整写法}</code></pre><p style=text-align:start>定义测试类：</p><pre><code>public class Test {   public static void main(String[] args) {        System.out.println(Live.NUM1);        System.out.println(Live.NUM2);    }}/*    输出结果：    10    100*/</code></pre><h1 class=pgc-h-arrow-right><strong>1.4-接口的多实现（记忆）</strong></h1><p style=text-align:start>在继承体系中，一个类只能继承一个父类（单继承）。</p><p style=text-align:start>而对于接口而言，一个类是可以实现多个接口的，这叫做接口的 <strong>多实现</strong> 。</p><p style=text-align:start>并且，一个类能 <strong>继承一个父类</strong> ，同时 <strong>实现多个接口</strong> 。</p><p style=text-align:start><strong>实现格式</strong></p><pre><code>public class 类名 [extends 父类名] implements 接口名1,接口名2,接口名3... {    // 重写接口中抽象方法【必须】      // 重写接口中默认方法【不重名时可选】}</code></pre><p style=text-align:start>[ ]中的格式： 表示可选操作。</p><p style=text-align:start><strong>接口多实现的抽象方法</strong></p><p style=text-align:start>接口中，有多个抽象方法时，实现类必须重写所有抽象方法 <strong>。如果抽象方法有重名的，只需要重写一次。</strong> 代码如下：</p><p style=text-align:start>定义多个接口：</p><pre><code>interface A {    public abstract void showA();    public abstract void show();}interface B {    public abstract void showB();    public abstract void show();}</code></pre><p style=text-align:start>定义实现类：</p><pre><code>public class C implements A,B{    @Override    public void showA() {        System.out.println("showA");    }    @Override    public void showB() {        System.out.println("showB");    }    @Override    public void show() {        System.out.println("show");    }}</code></pre><p style=text-align:start><strong>接口多实现的默认方法</strong></p><p style=text-align:start>接口中，有多个默认方法时，实现类都可继承使用。 <strong>如果默认方法有重名的，必须重写一次。</strong>代码如下：</p><p style=text-align:start>定义多个接口：</p><pre><code>interface A {    public default void methodA(){}    public default void method(){}}interface B {    public default void methodB(){}    public default void method(){}}</code></pre><p style=text-align:start>定义实现类：</p><pre><code>public class C implements A,B{    @Override    public void method() {        System.out.println("method");    }}</code></pre><p style=text-align:start><strong>接口多实现中的静态方法</strong></p><p style=text-align:start>接口中，存在 <strong>同名的静态方法并不会冲突</strong> ，原因是只能通过各自接口名访问静态方法。</p><pre><code>public interface MyInterface{    public static void inter(){        system.out.println("接口静态方法");    }}public class Test{    public static void main(String[] args){        //接口名直接调用        MyInterface.inter();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.5 接口的多继承 （记忆）</strong></h1><p style=text-align:start>一个接口能继承 <strong>另一个或者多个</strong> 接口，这和类之间的继承比较相似。</p><p style=text-align:start>接口的继承使用 extends 关键字，子接口继承父接口的方法。 如果父接口中的默认方法有重名的，那么子接口需要重写一次。 代码如下：</p><p style=text-align:start>定义父接口：</p><pre><code>interface A {    public default void method(){        System.out.println("AAAAAAAAAAAAAAAAAAA");    }}interface B {    public default void method(){        System.out.println("BBBBBBBBBBBBBBBBBBB");    }}</code></pre><p style=text-align:start>定义子接口：</p><pre><code>interface D extends A,B{    @Override    public default void method() {        System.out.println("DDDDDDDDDDDDDD");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>1.6 抽象类和接口的区别（理解）</strong></h1><p style=text-align:start>通过实例进行分析和代码演示抽象类和接口的用法。</p><p style=text-align:start>举例：犬和缉毒犬</p><p style=text-align:start>犬：</p><ul><li>行为：吼叫；吃饭；</li></ul><p style=text-align:start>缉毒犬：</p><ul><li>行为：吼叫；吃饭；缉毒；</li></ul><p style=text-align:start>思考</p><p style=text-align:start>由于犬分为很多种类，他们吼叫和吃饭的方式不一样，在描述的时候不能具体化，也就是吼叫和吃饭的行为不能明确。</p><p style=text-align:start>当描述行为时，行为的具体动作不能明确，这时，可以将这个行为写为抽象行为，那么这个类也就是抽象类。</p><p style=text-align:start>可是当缉毒犬有其他额外功能时，而这个功能并不在这个事物的体系中。这时可以让缉毒犬具备犬科自身特点的同时也有其他额外功能，可以将这个额外功能定义接口中。</p><p style=text-align:start>代码</p><pre><code>interface 缉毒{    public abstract void 缉毒();}//定义犬科的这个提醒的共性功能abstract class 犬科{    public abstract void 吃饭();    public abstract void 吼叫();}// 缉毒犬属于犬科一种，让其继承犬科，获取的犬科的特性，//由于缉毒犬具有缉毒功能，那么它只要实现缉毒接口即可，这样即保证缉毒犬具备犬科的特性，也拥有了缉毒的功能class 缉毒犬 extends 犬科 implements 缉毒{    public void 缉毒() {    }    void 吃饭() {    }    void 吼叫() {    }}class 缉毒猪 implements 缉毒{    public void 缉毒() {    }}</code></pre><p style=text-align:start><strong>通过示例总结抽象类和接口的区别</strong></p><h1 class=pgc-h-arrow-right><strong>相同点：</strong></h1><ul><li>都位于继承的顶端，用于被其他类实现或继承；</li><li>都不能直接实例化对象；</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法；</li></ul><h1 class=pgc-h-arrow-right><strong>区别：</strong></h1><ul><li>抽象类为部分方法提供实现，避免子类重复实现这些方法，提高代码重用性；接口只能包含抽象方法；</li><li>一个类只能继承一个直接父类(可能是抽象类)，却可以实现多个接口(接口弥补了Java的单继承)；</li><li>抽象类为继承体系中的共性内容，接口为继承体系中的扩展功能；</li></ul><h1 class=pgc-h-arrow-right><strong>语法具体区别：</strong></h1><ul><li>成员区别抽象类变量，常量；有构造方法；有抽象方法，也有非抽象方法接口常量；抽象方法</li><li>关系区别类与类继承，单继承类与接口实现，可以单实现，也可以多实现接口与接口继承，单继承，多继承</li><li>设计理念区别抽象类对类抽象，包括属性、行为接口对行为抽象，主要是行为</li></ul><h1 class=pgc-h-arrow-right><strong>第二章：多态</strong></h1><h1 class=pgc-h-arrow-right><strong>2.1-多态概述（了解）</strong></h1><p style=text-align:start><strong>什么是多态？</strong></p><p style=text-align:start>首先，多态是继封装、继承之后，面向对象的第三大特性。</p><p style=text-align:start>多态Polymorphism，按字面意思就是“多种状态”。</p><p style=text-align:start>生活中，比如跑的动作，小猫、小狗和大象，跑起来是不一样的。再比如飞的动作，昆虫、鸟类和飞机，飞起来也是不一样的。可见，同一行为，通过不同的事物，可以体现出来的不同的形态。多态，描述的就是这样的状态。</p><h1 class=pgc-h-arrow-right><strong>在面向对象编程中，多态是指 同一行为 ，具有 多个不同表现形式 。</strong></h1><div class=pgc-img><img alt=Java面向对象之：接口、多态 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3f6934313714e52ae0687177d6ea9ad><p class=pgc-img-caption></p></div><p style=text-align:start><strong>多态的前提</strong></p><ol start=1><li>继承或者实现【二选一】</li><li>方法的重写【意义体现：不重写，无意义】</li><li>父类引用指向子类对象【格式体现】</li></ol><h1 class=pgc-h-arrow-right><strong>2.2-多态的语法格式（记忆）</strong></h1><p style=text-align:start><strong>语法格式</strong> ：</p><pre><code>父类类型 变量名 = new 子类()；变量名.方法名();</code></pre><p style=text-align:start>父类类型：是指子类继承的 <strong>父类类型</strong> ，或者实现的 <strong>父接口类型</strong> 。</p><p style=text-align:start><strong>示例代码：</strong></p><p style=text-align:start>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</p><p style=text-align:start>定义父类：</p><pre><code>public abstract class Animal {      public abstract void eat();  }</code></pre><p style=text-align:start>定义子类：</p><pre><code>class Cat extends Animal {      public void eat() {          System.out.println("吃鱼");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨头");      }  }</code></pre><p style=text-align:start>定义测试类：</p><pre><code>public class Test {    public static void main(String[] args) {        // 多态形式，创建对象        Animal a1 = new Cat();          // 调用的是 Cat 的 eat        a1.eat();                  // 多态形式，创建对象        Animal a2 = new Dog();         // 调用的是 Dog 的 eat        a2.eat();                   }  }</code></pre><h1 class=pgc-h-arrow-right><strong>2.3-多态的好处（理解）</strong></h1><p style=text-align:start>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能 <strong>体现出多态的扩展性与灵活性</strong> 。</p><p style=text-align:start>示例代码如下：</p><p style=text-align:start>定义父类：</p><pre><code>public abstract class Animal {      public abstract void eat();  }</code></pre><p style=text-align:start>定义子类：</p><pre><code>class Cat extends Animal {      public void eat() {          System.out.println("吃鱼");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨头");      }  }</code></pre><p style=text-align:start>定义测试类：</p><pre><code>public class Test {    public static void main(String[] args) {        // 多态形式，创建对象        Cat c = new Cat();          Dog d = new Dog();         // 调用showCatEat         showCatEat(c);        // 调用showDogEat         showDogEat(d);         /*        以上两个方法, 均可以被showAnimalEat(Animal a)方法所替代        而执行效果一致        */        showAnimalEat(c);        showAnimalEat(d);     }    public static void showCatEat (Cat c){        c.eat();     }    public static void showDogEat (Dog d){        d.eat();    }    public static void showAnimalEat (Animal a){        a.eat();    }}</code></pre><p style=text-align:start>由于多态特性的支持，showAnimalEat方法的Animal类型，是Cat和Dog的父类类型，父类类型接收子类对象，当然可以把Cat对象和Dog对象，传递给方法。</p><p style=text-align:start>当eat方法执行时，多态规定，执行的是子类重写的方法，那么效果自然与showCatEat、showDogEat方法一致，所以showAnimalEat完全可以替代以上两方法。</p><p style=text-align:start>不仅仅是替代，在扩展性方面，无论之后再多的子类出现，我们都不需要编写showXxxEat方法了，直接使用showAnimalEat都可以完成。</p><p style=text-align:start>所以，多态的好处，体现在，可以使程序编写的更简单，并有良好的扩展。</p><h1 class=pgc-h-arrow-right><strong>2.4-多态的转型（理解）</strong></h1><p style=text-align:start>多态的转型分为 <strong>向上转型</strong> 与 <strong>向下转型</strong> 两种：</p><p style=text-align:start><strong>向上转型</strong></p><p style=text-align:start>多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。</p><p style=text-align:start>表现形式：当父类引用指向一个子类对象时，便是向上转型。</p><pre><code>父类类型  变量名 = new 子类类型();如：Animal a = new Cat();</code></pre><p style=text-align:start><strong>向下转型</strong></p><p style=text-align:start>父类类型向子类类型向下转换的过程，这个过程是强制的。</p><p style=text-align:start>表现形式：一个已经向上转型的子类对象，将父类引用转为子类引用，可以使用强制类型转换的格式，便是向下转型。</p><pre><code>子类类型 变量名 = (子类类型) 父类变量名;如:    Animal a = new Cat();   // Cat 向上转型为Animal a表示Cat转型后的Animal类型    Cat c =(Cat) a;         // 已经向上转型的Cat类型a，向下强制转型为Cat</code></pre><p style=text-align:start><strong>为什么还要向下转型呢</strong> ？</p><p style=text-align:start>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说， <strong>不能调用</strong> 子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做向下转型。示例代码如下：</p><p style=text-align:start>定义类：</p><pre><code>abstract class Animal {      abstract void eat();  }  class Cat extends Animal {      public void eat() {          System.out.println("吃鱼");      }      public void catchMouse() {          System.out.println("抓老鼠");      }  }  class Dog extends Animal {      public void eat() {          System.out.println("吃骨头");      }      public void watchHouse() {          System.out.println("看家");      }  }</code></pre><p style=text-align:start>定义测试类：</p><pre><code>public class Test {    public static void main(String[] args) {        // 向上转型          Animal a = new Cat();          a.eat();                 // 调用的是 Cat 的 eat        // 向下转型          Cat c = (Cat)a;               c.catchMouse();         // 调用的是 Cat 的 catchMouse    }  }</code></pre><p style=text-align:start><strong>转型异常</strong></p><p style=text-align:start>转型的过程中，一不小心就会遇到这样的问题，请看如下代码：</p><pre><code>public class Test {    public static void main(String[] args) {        // 向上转型          Animal a = new Cat();          a.eat();               // 调用的是 Cat 的 eat        // 向下转型          Dog d = (Dog)a;               d.watchHouse();        // 调用的是 Dog 的 watchHouse 【运行报错】    }  }</code></pre><p style=text-align:start>这段代码可以通过编译，但是运行时，却报出了 ClassCastException ，类型转换异常！这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。</p><p style=text-align:start>为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，格式如下：</p><pre><code>变量名 instanceof 数据类型 // 如果变量属于该数据类型，返回true。// 如果变量不属于该数据类型，返回false。</code></pre><p style=text-align:start>所以，转换前，我们最好先做一个判断，代码如下：</p><pre><code>public class Test {    public static void main(String[] args) {        // 向上转型          Animal a = new Cat();          a.eat();               // 调用的是 Cat 的 eat        // 向下转型          if (a instanceof Cat){            Cat c = (Cat)a;                   c.catchMouse();        // 调用的是 Cat 的 catchMouse        } else if (a instanceof Dog){            Dog d = (Dog)a;                   d.watchHouse();       // 调用的是 Dog 的 watchHouse        }    }  }</code></pre><h1 class=pgc-h-arrow-right><strong>第三章：综合案例</strong></h1><p style=text-align:start>需求：</p><p style=text-align:start>定义笔记本类，具备开机，关机和使用USB设备的功能。</p><p style=text-align:start>具体是什么USB设备，笔记本并不关心，只要符合USB规格的设备都可以。</p><p style=text-align:start>鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，不然鼠标和键盘的生产出来无法使用；</p><p style=text-align:start>进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘</p><ul><li>USB接口，包含开启功能、关闭功能</li><li>笔记本类，包含运行功能、关机功能、使用USB设备功能</li><li>鼠标类，要符合USB接口</li><li>键盘类，要符合USB接口</li></ul><p style=text-align:start>分析：</p><p style=text-align:start>阶段一：使用笔记本，笔记本有运行功能，需要笔记本对象来运行这个功能</p><p style=text-align:start>阶段二：想使用一个鼠标，又有一个功能使用鼠标，并多了一个鼠标对象。</p><p style=text-align:start>阶段三：还想使用一个键盘 ，又要多一个功能和一个对象。</p><p style=text-align:start>问题：每多一个功能就需要在笔记本对象中定义一个方法，不爽，程序扩展性极差。</p><p style=text-align:start>解决：使用多态机制，降低鼠标、键盘等外围设备和笔记本电脑的耦合性。</p><div class=pgc-img><img alt=Java面向对象之：接口、多态 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4883383d06f14c549c5552cb9019f474><p class=pgc-img-caption></p></div><p style=text-align:start>代码：</p><pre><code>//定义鼠标、键盘，笔记本三者之间应该遵守的规则 public interface USB {    void open();// 开启功能    void close();// 关闭功能}//鼠标实现USB规则public class Mouse implements USB {    public void open() {        System.out.println("鼠标开启");    }    public void close() {        System.out.println("鼠标关闭");    }}//键盘实现USB规则public class KeyBoard implements USB {    public void open() {        System.out.println("键盘开启");    }    public void close() {        System.out.println("键盘关闭");    }}//定义笔记本public class NoteBook {    // 笔记本开启运行功能    public void run() {        System.out.println("笔记本运行");    }    // 笔记本使用usb设备，这时当笔记本对象调用这个功能时，必须给其传递一个符合USB规则的USB设备    public void useUSB(USB usb) {        // 判断是否有USB设备        if (usb != null) {            usb.open();            usb.close();        }    }    public void shutDown() {        System.out.println("笔记本关闭");    }}//测试public class Test {    public static void main(String[] args) {        // 创建笔记本实体对象        NoteBook nb = new NoteBook();        // 笔记本开启        nb.run();        // 创建鼠标实体对象        Mouse m = new Mouse();        // 笔记本使用鼠标        nb.useUSB(m);        // 创建键盘实体对象        KeyBoard kb = new KeyBoard();        // 笔记本使用键盘        nb.useUSB(kb);        // 笔记本关闭        nb.shutDown();    }}</code></pre><p><br></p><div class=pgc-img><img alt=Java面向对象之：接口、多态 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/063bdf869aa44936a5e72836a522cd46><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','对象','多态'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/9427df4.html alt=Java面向对象——多态 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aeb5a80f2ae143899e63547c947fe881 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/9427df4.html title=Java面向对象——多态>Java面向对象——多态</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>