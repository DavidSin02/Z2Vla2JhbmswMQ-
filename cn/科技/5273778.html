<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>汇编干货第三章 | 极客快訊</title><meta property="og:title" content="汇编干货第三章 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/106cd543a805444295836b37ed89a1f4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5273778.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5273778.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5273778.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="汇编干货第三章"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5273778.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>汇编干货第三章</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/106cd543a805444295836b37ed89a1f4><p class=pgc-img-caption></p></div><p>是时候关注我们一波了&lt;微信公众号渗透云笔记></p><p>包含多个段的程序</p><p>前面说道，如果要使用安全的内存空间，0:200~0:2FF是相对安全得内存空间，可是这段空间只有256字节，如果需要的空间大于256字节该怎么办呢？</p><p>在操作系统允许的情况下，程序可以取得任意容量的空间。</p><p>取得空间的方法有两种。</p><ul><li>加载程序时为程序分配</li><li>执行过程中向系统申请（这里不讨论）</li></ul><p>若要一个程序在加载时取得所需的空间，则必须在源程序做出说明。</p><p>上面是从内存空间获取的角度上，谈定义段的问题。为了可读性、功能设计，一般一额定义不同的段来存放。</p><p>关于段的问题，我们将以这样的顺序讨论多个段的问题：</p><ul><li>在一个段中存放数据、代码、栈;</li><li>将数据、代码、栈放入不同的段中。</li></ul><p>在代码段中使用数据</p><p>我们可以在程序中，定义我们希望处理的数据，数据作为程序的一部分一同被编译、链接写到可执行文件中。</p><p>考虑这样一个问题，编程计算8个数据的和，结果存放在AX寄存器中，下面是用我们前面知识写出的代码。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/91b7496c0bf34edca81744f4ac18dadf><p class=pgc-img-caption></p></div><p>这里出现了一个新的指令dw，dw即“define word”，在这里，定义了8个字型数据，占用16字节的内存空间。</p><p>使用Debug调试程序，不运行，发现一个问题，程序所在的内存区为075C:0（DS=075C）,前256字节存放着PSP，程序的存放位置应为076C:0，使用U指令查看确发现有点不对。</p><p>实际上，看到其实是有dw定义的数据，从第16字节开始才是汇编指令对应的机器码。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/52418377711d4fd6b8e96eb40610ade8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f8c22945a9a4dd8a26ade19142b5f41><p class=pgc-img-caption></p></div><p>怎样执行程序中的指令呢？在Debug中，可以手动修改IP寄存器的值，从而使CS:IP指向程序的另一条指令。</p><p>这样一来，在系统运行时就会出现问题，程序的入口不是我们希望执行的指令。</p><p>借助伪指令可以通知编译器程序的入口。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddf9af725c244fb7901be3073db389db><p class=pgc-img-caption></p></div><p>有了这个指令，可以仿照这个模板写出更多的程序，start上面安排数据，start和end start之间安排代码。</p><p>在代码段中使用栈</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/52f953cf7df04e06a0cd4a1c26fe3730><p class=pgc-img-caption></p></div><p>这里的检测点没做出来，看视频才想通的，后来发现这个题目第一眼没看懂。</p><p>检测点考察dw定义的数据在内存空间的位置，理解了这一点，题目就可以做出来了。</p><p>注释未知的指令，在debug模式中运行可以直观的感受到到这一点。</p><p>将数据、代码、栈放入不同的段</p><p>前面的内容中，我们将数据、栈和代码都放到了一个段里面，编程的时候需要注意何处是数据，何处是栈，何处是代码。显然这样有问题：</p><ul><li>程序混乱</li><li>8086的段空间限制只有64KB</li></ul><p>下面的程序用不同的段实现了上面的功能</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/65b1fe3be8c5421c935b4c26ef869c12><p class=pgc-img-caption></p></div><ul><li>对于不同的段，使用不同的段名联系不同的段寄存器。</li><li>注意红线的部分，段名相当于一个标号，代表了段地址，8086CPU不允许将一个数值送入段寄存器，因此使用其它寄存器中转</li><li>“代码段”、“数据段”、“栈段”完全是我们的安排</li><li>CPU如何处理定义的段的内容，取决与程序中具体的汇编指令。</li><li class=ql-indent-1>段名只是为了阅读性</li><li class=ql-indent-1>cs:code等代码将段名和寄存器联系起来</li><li class=ql-indent-1>end start指明了程序的入口，CS:IP指向这个入口，从而执行程序的第一条指令</li></ul><p>编写、调试具有多个段的程序</p><p>这里是两个检测点，为了理解不同段在内存空间中的排列，一个段在内存空间中最小单位为16字节。</p><p>限于篇幅原因，我这里介绍比较最后的一个实验。</p><p>程序如下，编写code段的代码，用push指令将a段中的前8个字型数据逆序存储在b段中。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e0da7f9180be4fc68891f1239372a5ee><p class=pgc-img-caption></p></div><p>写出程序很容易，不过这不是我要说的重点。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c7748fa7e6f4afdb0b54258b76138e9><p class=pgc-img-caption></p></div><p>程序运行完之后，查看内存空间，注意我这里查看的DS。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7decc55e980d4e20882cdaaf4912fb7f><p class=pgc-img-caption></p></div><p>从数据对应关系不难判断，76C:00~76C:1F是我们定义的数据段， 076C:20~76C:2E是我们定义的栈段，76C:30之后是代码段。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57119f4d8599478ca3eaa553f20cf044><p class=pgc-img-caption></p></div><p>查看对应的寄存器，也验证了这一点，</p><p>$076C \times 10H+0=76C0H=76C \times 10H+0$</p><p>$076C \times 10H+20=76E0H=76E \times 10H+0$</p><p>$076C \times10H+30=76F0H=76F \times 10H+0$</p><p>这里主要涉及到了一些段编译的规则，编译的规则影响了内存的分配。我们在使用SSD格式化的时候，有一个选项为4K对齐，4K对齐是为了让操作系统的最小分配单元和闪存的一个页对应，提高读写效率，实际使用过程中，即使文件没有那么大，实际占用的均为4KB的倍数，在这一点上和编译规则有些相似。</p><p>更灵活的定位内存地址的方法</p><p>前面，我们用[0]、[bx]的方法，定位内存单元的地址。本章介绍更为灵活的定位内存地址和相关的编程方法。</p><p>and和or指令</p><pre>12345678;and指令：逻辑与指令，按位进行与运算mov al,00001111Band al,11110000B;执行后AL=00000000B 相应位设为0;or指令：理解与指令，按位进行或运算mov al,00001111Bor al,11110000B;执行后 AL=11111111B 相应位设为1</pre><p>以字符形式给出的数据</p><p>计算机中所有的信息都是二进制，而人能理解的信息是具有约定意义的字符。将字符存储在计算机中，就要对其进行编码。计算机存储的信息展示给我们看时，就要对其进行解码。</p><p>ASCII是基于拉丁字母的一套编码系统。例如，文件编辑过程中，按一下按键的“a”键，计算机用ASII码规则编码为61H存储在内存中;文件编辑器从内存中取出61H，送入显卡上的显存中；显卡用ASII码的规则解释显存的内容，显卡驱动显示器，我们在显示器看到了字符“a”。</p><p>我们可以在汇编程序中，用‘……‘的方式指明数据是以字符的形式给出，编译器将转化为相对应的ASCII码。</p><p>大小写转换的问题</p><p>在codesg中填写代码（我这里写好了），将datasg中的第一个字符串转化为大写，第二个字符转化为小写。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67ca1944f2b54a1b9fe531f42021e78a><p class=pgc-img-caption></p></div><p>查看字母的ASCII表。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f644a9b423a4dc39e5243b724b07204><p class=pgc-img-caption></p></div><p>可以发现，大写字母到小写字母在于寄存器中第5个字符的不同（我没说错，从右往左数，从0到7），那么这道题的关键在于将第5个字符置0的转换了，写出上面的代码就很简单了。</p><p>[bx+idata]</p><p>前面使用[bx]的方式来指明一个内存单元，还可以使用[bx+idata]来表示内存单元，他的偏移地址为[bx]+idata。</p><p>有了这个特性，前面我们做过一道将a段和b段的内容相加到c段中的题目，可以将代码优化。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/528feae7dc7744418f0f1eb804d7646c><p class=pgc-img-caption></p></div><p>可以看出灵活的内存访问方式，减少了指令，加快的程序运行速度。</p><p>SI+DI</p><p>SI和DI是8086CPU中和BX功能相近的寄存器，SI和DI不能分成两个8为寄存器来使用</p><p>[bx+si]和[bx+di]</p><p>在前面，我们用[bx]和[bx+idata]的方式来指明一个内存单元，还可以使用更为灵活的方式：[bx+si]和[bx+di]</p><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)（即bx中的数值加上si的数值）</p><p>[bx+si+idata]和[bx+di+idata]</p><p>[bx+si+idata]表示一个内存单元，偏移地址为(bx)+(si)+(idata)。</p><p>不同的寻址方式的应用</p><ul><li>[idata]用一个常量表示内存地址，可直接定位一个内存单元</li><li>[bx]用一个变量表示内存地址，可间接定位一个内存单元</li><li>[bx+idata]用一个变量和常量表示内存地址，可在一个起始位置的基础上用变量间接定位一个内存单元</li><li>[bx+si]用两个变量表示地址</li><li>[bx+si+idata]用两个变量和一个常量便是地址。</li></ul><p>如下图，将datasg段中的每个单词改为大写字母</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfd9bfcc22f04cba97793dccebd3bc0e><p class=pgc-img-caption></p></div><p>db指令和dw指令类似，不过他定义的是字节型数据</p><p>总共数据有4行，每行有3个字母需要更改，也就是$4\times3$此二重循环，有限的循环可以使用loop指令，这里需要存储两个循环次数，经过艰苦的思考（并没有，我想不出来，看书上思路了），可以使用空寄存器DX暂存，循环完成后又拿回（下图左）。</p><p>程序中进场需要进行数据的暂存，寄存器的数量有限，如果不适用寄存器，只能使用内存了，我们开辟了新的一块内存，先存放在内存中，需要的时候在从内存单元中恢复（下图中）。</p><p>我们使用内存来暂存数据，这是比较聪明的选择，但是值得推敲的是，我们用怎样的结构来保存这些数据，从而使程序更为清晰。</p><p>一般来说，在需要暂存数据的时候，都应该使用栈。</p><p>我们使用栈暂存数据，采用相关的指令将数据入栈，需要时在出栈（下图右）。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e09ded2a8a4b499fa1b1662b10cd6940><p class=pgc-img-caption></p></div><p>为什么要用[bx+si+data]的形式来表示？</p><ul><li>为了可阅读性，理解数据的起始，体现了偏移的思想</li></ul><p>程序如何改进？</p><ul><li>更多的数据入栈，比如上面的BX进行入栈</li></ul><p>数据处理的两个基本问题</p><ul><li>处理的数据在什么地方</li><li>要处理的数据有多长</li></ul><p>reg和sreg</p><p>定义描述性的符号reg和sreg，reg表示一个寄存器，sreg表示一个段寄存器。</p><p>reg：x、bx、cx、dx、ah、al、bh、bl、cx、bl、dh、dl、sp、bp、si、di;</p><p>sreg：ds、ss、cs、es</p><p>bx、si、di和bp</p><ul><li>8086CPU中，只有这4个寄存器可以用在[…]中进行内存单元寻址</li><li>在[…]可以单个出现，或只能以4中组合出现：bx和si、bx和di、bp和si、bp和di.</li><li>指令没有显性给出段地址，段地址就默认在SS中。</li></ul><p>处理的数据在什么地方</p><p>机器指令不关心数据的值多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令执行前，处理的数据可以在3个地方：CPU内部、内存、端口（后面介绍）</p><p>汇编语言中数据的表达</p><ul><li>立即数：直接在包含在机器指令中的数据（执行前在CPU的指令缓冲器中），称为立即数（idata)</li><li>寄存器：数据在寄存器中，给出寄存器名使用</li><li>段地址（SA）和偏移地址（EA）：段地址默认在DS中，若BP做为有效地址的一部分，段地址默认在SS中，可以显性给出段寄存器</li></ul><p>寻址方式</p><p>数据存放在内存中的时候，可是用多种方式给定这个内存单元的偏移地址，这种定位内存单元的方法一般被称为寻址方式。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4455638b3f045e0be2d0cbbe1b59962><p class=pgc-img-caption></p></div><p>指令的数据有多长</p><p>8086CPU中，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。</p><ul><li>通过寄存器指明要处理的数据的尺寸，mov ax,1与mov al,1</li><li>没有寄存器时，用操作符指明：X ptr指明内存单元长度，X可以为word或byte</li></ul><p>顺便说一下，[bx].10h[si]=[bx+16+si]。</p><p>div指令</p><p>div是触发指令</p><ul><li>除数：有8位和16位两种，在一个reg或内存单元中</li><li>被除数：默认放在AX或DX和AX中</li><li class=ql-indent-1>如果除数为8位，则被除数则为16位，默认在AX中存放</li><li class=ql-indent-1>如果除数为16位，被除数为32位,在DX和AX中存放，DX存放高16位，AX存放低16位</li><li>结果</li><li class=ql-indent-1>如果除数为8位，AL存储除法操作的商，AH存储除法操作的余数</li><li class=ql-indent-1>如果除数为16位，AX存储除法操作的商，DX存储除法操作的余数</li></ul><p>单纯看这段话容易看懵，在debug模式中试验下。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e8727dbdb9734357bd65493f4747bc64><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0b061135183429e92f3b725ec95c0d2><p class=pgc-img-caption></p></div><p>说明，这里演示的是$\frac{16}{3}=5\cdots\cdots1 $,其中16的部分在指令中我使用的是十六进制”10H“。</p><p>伪指令dd</p><p>前面使用db和dw定义字节型数据和字型数据。dd用来定义dword(double word，双字)型数据</p><p>伪指令dup</p><p>dup是一个操作符，同db、dw、dd等一样，也是由编译器识别处理的符号。配合db、dw、dd等数据定义伪指令使用，用来进行数据的重复。</p><p>使用的格式如下</p><pre>123db 重复的次数 dup （重复的字节型数据）dw 重复的次数 dup （重复的字型数据）dd 重复的次数 dup （重复的双字型数据）</pre><p>实验七</p><p>这里基本将所有的知识都运用起来了，笔者自己做的时候感觉自己好渣，想不出来。还是需要进行分析，理解数据从哪里来，到哪里去，中间做了什么。</p><p>题目是将data中的年、收入、计算的人均收入写到table段中。直接给代码。</p><div class=pgc-img><img alt=汇编干货第三章 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f5fb81517a814614ba67a047b6ca5866><p class=pgc-img-caption></p></div><ul><li>年份的传递，可以使用寄存器，使用栈明显是更好的选择</li><li>使用相应的寄存器存储偏移量，可以使用[bx+idata]访问数据节省寄存器</li><li>除法运算中被除数为双字，使用AX、DX分别存储低16位和高16位，将AX中的商传递到Table段</li></ul><p>实验的反思</p><p>这个实验的段名仿佛在暗示什么，回顾我们做了什么，我们将零散的数据结构化，使数据阅读性提升，使用偏移地址访问非常遍历。换句话说，如果编写程序时，将数据结构化，程序效率也将提升。程序的效率与数据组织的合理不合理有关，有一门课程叫数据结构，讲的就是这么个问题。</p><p>本质上可以归纳为对数据的组织，而下一章转移指令的原理，本质上是对代码的组织。</p><p>总结</p><p>前两章的介绍都是为了理解数据在内存中如何排列，后一章理解数据在处理过程中的细节。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'编干货','第三章'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>