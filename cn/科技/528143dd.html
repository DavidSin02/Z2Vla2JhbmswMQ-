<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>搞定Nginx高并发原理：多进程单线程和多路IO复用模型 | 极客快訊</title><meta property="og:title" content="搞定Nginx高并发原理：多进程单线程和多路IO复用模型 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/610f1711076040f6b29d18fee72b537c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/528143dd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/528143dd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/528143dd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/528143dd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/528143dd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/528143dd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/528143dd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/528143dd.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="搞定Nginx高并发原理：多进程单线程和多路IO复用模型"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/528143dd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>搞定Nginx高并发原理：多进程单线程和多路IO复用模型</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Nginx现在是非常火爆的web服务器，她使用更少的资源，支持更多的并发连接数，实现了linux的epoll模型。</p><div class=pgc-img><img alt=搞定Nginx高并发原理：多进程单线程和多路IO复用模型 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/610f1711076040f6b29d18fee72b537c><p class=pgc-img-caption></p></div><p>Nginx采用的是多进程单线程和多路IO复用模型。使用了I/O多路复用技术的Nginx，就成了”并发事件驱动“的服务器。这里再强调下重点，</p><ul><li><strong>多进程单线程</strong></li><li><strong>多路IO复用模型</strong></li></ul><div class=pgc-img><img alt=搞定Nginx高并发原理：多进程单线程和多路IO复用模型 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/91bfdf3dae6345cc9ad8c584d79a5934><p class=pgc-img-caption></p></div><h1><strong>一、多进程单线程</strong></h1><p>Nginx 自己实现了对epoll的封装，是多进程单线程的典型代表。使用多进程模式，不仅能提高并发率，而且进程之间是相互独立的，一 个worker进程挂了不会影响到其他worker进程。</p><p><strong>master进程管理worker进程：</strong></p><ol start=1><li>接收来自外界的信号。</li><li>向各worker进程发送信号。</li><li>监控woker进程的运行状态。</li><li>当woker进程退出后（异常情况下），会自动重新启动新的woker进程。</li></ol><p>注意worker进程数，一般会设置成机器cpu核数。因为更多的worker只会导致进程之间相互竞争cpu，从而带来不必要的上下文切换。</p><div class=pgc-img><img alt=搞定Nginx高并发原理：多进程单线程和多路IO复用模型 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/70e95670-eefb-44cc-a029-2b878fd2939b><p class=pgc-img-caption></p></div><h1><strong>二、IO 多路复用模型 epoll</strong></h1><p>多路复用，允许我们只在事件发生时才将控制返回给程序，而其他时候内核都挂起进程，随时待命。</p><p>epoll通过在Linux内核中申请一个简易的文件系统（文件系统一般用B+树数据结构来实现），其工作流程分为三部分：</p><ol start=1><li>调用 int epoll_create(int size)建立一个epoll对象，内核会创建一个eventpoll结构体，用于存放通过epoll_ctl()向epoll对象中添加进来的事件，这些事件都会挂载在红黑树中。</li><li>调用 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) 在 epoll 对象中为 fd 注册事件，所有添加到epoll中的事件都会与设备驱动程序建立回调关系，也就是说，当相应的事件发生时会调用这个sockfd的回调方法，将sockfd添加到eventpoll 中的双链表。</li><li>调用 int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout) 来等待事件的发生，timeout 为 -1 时，该调用会阻塞知道有事件发生。</li></ol><p>注册好事件之后，只要有fd上事件发生，epoll_wait()就能检测到并返回给用户，用户执行阻塞函数时就不会发生阻塞了。</p><p>epoll()在中内核维护一个链表，epoll_wait直接检查链表是不是空就知道是否有文件描述符准备好了。顺便提一提，epoll与select、poll相比最大的优点是不会随着sockfd数目增长而降低效率，使用select()时，内核采用轮训的方法来查看是否有fd准备好，其中的保存sockfd的是类似数组的数据结构fd_set，key 为 fd，value为0或者1（发生时间）。</p><p>能达到这种效果，是因为在内核实现中epoll是根据每 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。那么，某个sockfd上的事件发生时，与它对应的回调函数就会被调用，将这个sockfd加入链表，其他处于“空闲的”状态的则不会。在这点上，epoll 实现了一个"伪"AIO。</p><p>可以看出，因为一个进程里只有一个线程，所以一个进程同时只能做一件事，但是可以通过不断地切换来“同时”处理多个请求。</p><p>例子：Nginx 会注册一个事件：“如果来自一个新客户端的连接请求到来了，再通知我”，此后只有连接请求到来，服务器才会执行 accept() 来接收请求。又比如向上游服务器（比如 PHP-FPM）转发请求，并等待请求返回时，这个处理的 worker 不会在这阻塞，它会在发送完请求后，注册一个事件：“如果缓冲区接收到数据了，告诉我一声，我再将它读进来”，于是进程就空闲下来等待事件发生。</p><p>这样，基于 多进程+epoll， Nginx 便能实现高并发。</p><div class=pgc-img><img alt=搞定Nginx高并发原理：多进程单线程和多路IO复用模型 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/0862c690-0f8d-40e9-a1af-a2b89b3602db><p class=pgc-img-caption></p></div><h1><strong>三、worker进程工作流程</strong></h1><p>当一个 worker 进程在 accept() 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由worker进程来处理，而且只会在一个worker进程中处理。优点：</p><ol start=1><li>节省锁带来的开销。每个worker进程都彼此独立地工作，不共享任何资源，因此不需要锁。同时在编程以及问题排查上时，也会方便很多。</li><li>独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。当然，worker进程自己也能发生意外退出。</li></ol><h1><strong>四、对惊群效应的处理</strong></h1><p>Nginx提供了一个accept_mutex这个东西，这是一个加在accept上的一把互斥锁。即每个worker进程在执行accept()之前都需要先获取锁，accept()成功之后再解锁。有了这把锁，同一时刻，只会有一个进程执行accpet()，这样就不会有惊群问题了。accept_mutex是一个可控选项，我们可以显示地关掉，默认是打开的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Nginx','进程','单线程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>