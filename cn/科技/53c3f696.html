<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>啃碎并发（三）：Java线程上下文切换 | 极客快訊</title><meta property="og:title" content="啃碎并发（三）：Java线程上下文切换 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/897b8ce999f3444c9f541524383802dc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/53c3f696.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/53c3f696.html><meta property="article:published_time" content="2020-10-29T21:12:23+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:23+08:00"><meta name=Keywords content><meta name=description content="啃碎并发（三）：Java线程上下文切换"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/53c3f696.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>啃碎并发（三）：Java线程上下文切换</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>前言</p><p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是<strong>多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间</strong><strong>片</strong><strong>运行</strong>。</p><p>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。<strong>一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序</strong>。</p><p>多线程比多任务更加有挑战。<strong>多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作</strong>。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着<strong>不同的线程能被不同的CPU核得到真正意义的并行执行</strong>。</p><p>所以，<strong>在多线程、多任务情况下，线程上下文切换是必须的</strong>，然而对于CPU架构设计中的概念，应先熟悉了解，这样会有助于理解线程上下文切换原理。</p><h1 class=pgc-h-arrow-right>1 多核、多CPU、超线程、多线程</h1><h1 class=pgc-h-arrow-right>1.1 为什么要多核</h1><p>先要说的是多核、多CPU、超线程，这三个其实都是CPU架构设计的概念，<strong>一个现代CPU除了处理器核心之外还包括寄存器、L1L2缓存这些存储设备、浮点运算单元、整数运算单元等一些辅助运算设备以及内部总线等</strong>。一个多核的CPU也就是一个CPU上有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，<strong>就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，同时还要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存</strong>。</p><h1 class=pgc-h-arrow-right>1.2 为什么要多CPU</h1><p>前面提了多核的好处，那为什么要多CPU呢？这个其实很容易想到，如果要运行多个程序（进程）的话，假如只有一个CPU的话，就意味着要经常进行进程上下文切换，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以<strong>多个进程就必然要经常进行进程上下文切换，这个代价是很高的</strong>。</p><h1 class=pgc-h-arrow-right>1.3 为什么要超线程</h1><p>超线程这个概念是Intel提出的，<strong>简单来说是在一个CPU上真正的并发两个线程</strong>，听起来似乎不太可能，因为CPU都是分时的啊，其实这里也是分时，<strong>因为前面也提到一个CPU除了处理器核心还有其他设备，一段代码执行过程也不光是只有处理器核心工作，如果两个线程A和B，A正在使用处理器核心，B正在使用缓存或者其他设备，那AB两个线程就可以并发执行，但是如果AB都在访问同一个设备，那就只能等前一个线程执行完后一个线程才能执行</strong>。实现这种并发的原理是<strong>在CPU里加了一个协调辅助核心</strong>，根据Intel提供的数据，这样一个设备会使得设备面积增大5%，但是性能提高15%~30%。</p><h1 class=pgc-h-arrow-right>1.4 为什么要多线程</h1><p>这个问题也许是面试中问的最多的一个经典问题了，<strong>一个进程里多线程之间可以共享变量，线程间通信开销也较小，可以更好的利用多核CPU的性能，多核CPU上跑多线程程序往往会比单线程更快</strong>，有的时候甚至在单核CPU上多线程程序也会有更好的性能，<strong>因为虽然多线程会有上下文切换和线程创建销毁开销，但是单线程程序会被IO阻塞无法充分利用CPU资源，加上线程的上下文开销较低以及线程池的大量应用，多线程在很多场景下都会有更高的效率</strong>。</p><h1 class=pgc-h-arrow-right>1.5 线程与进程</h1><p><strong>进程是操作系统的管理单位，而线程则是进程的管理单位</strong>；一个进程至少包含一个执行线程。不管是在单线程还是多线程中，<strong>每个线程都有一个程序计数器（记录要执行的下一条指令），一组寄存器（保存当前线程的工作变量），堆栈（记录执行历史，其中每一帧保存了一个已经调用但未返回的过程）</strong>。虽然线程寄生在进程中，但与他的进程是不同的概念，并且可以分别处理：<strong>进程是系统分配资源的基本单位，线程是调度CPU的基本单位</strong>。</p><p>一个线程指的是进程中一个单一顺序的控制流，一个进程中可以并行多个线程，每条线程并行执行不同的任务。<strong>每个线程共享堆空间，拥有自己独立的栈空间</strong>。</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/897b8ce999f3444c9f541524383802dc><p class=pgc-img-caption>进程&线程表项</p></div><p><br></p><h1 class=pgc-h-arrow-right>2 上下文切换</h1><p>支持多任务处理是CPU设计史上最大的跨越之一。<strong>在计算机中，多任务处理是指同时运行两个或多个程序</strong>。从使用者的角度来看，这看起来并不复杂或者难以实现，但是它确实是计算机设计史上一次大的飞跃。<strong>在多任务处理系统中，CPU需要处理所有程序的操作，当用户来回切换它们时，需要记录这些程序执行到哪里</strong>。上下文切换就是这样一个过程，允许CPU记录并恢复各种正在运行程序的状态，使它能够完成切换操作。</p><p>多任务系统往往需要同时执行多道作业。作业数往往大于机器的CPU数，然而一颗CPU同时只能执行一项任务，如何让用户感觉这些任务正在同时进行呢? 操作系统的设计者<strong>巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，在加载下一任务的状态后，继续服务下一任务</strong>。<strong>任务的状态保存及再加载, 这段过程就叫做上下文切换</strong>。时间片轮转的方式使多个任务在同一颗CPU上执行变成了可能。</p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b6689c527b334047a3b4072519574294><p class=pgc-img-caption>任务的状态保存及再加载, 这段过程就叫做上下文切换</p></div><p><br></p><h1 class=pgc-h-arrow-right>2.1 基本概念</h1><p>上下文切换（有时也称做进程切换或任务切换）是指CPU从一个进程或线程切换到另一个进程或线程。</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0104d0e03f404dccaf658986d9904bf9><p class=pgc-img-caption></p></div><p><br></p><p>上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行以下的活动：</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9fdf85330eee44c3b5b15d8f2ab18bf9><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.2 切换种类</h1><p>上下文切换在不同的场合有不同的含义，在下表中列出：</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c296caa9394b4f86b1f9e673d96ba5e6><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.3 切换步骤</h1><p>在上下文切换过程中，CPU会停止处理当前运行的程序，并保存当前程序运行的具体位置以便之后继续运行。从这个角度来看，上下文切换有点像我们同时阅读几本书，在来回切换书本的同时我们需要记住每本书当前读到的页码。<strong>在程序中，上下文切换过程中的“页码”信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。“页码”信息会一直保存到CPU的内存中，直到他们被再次使用</strong>。</p><p><strong>PCB通常是系统内存占用区中的一个连续存区，它存放着操作系统用于描述进程情况及控制进程运行所需的全部信息</strong>，它使一个在多道程序环境下不能独立运行的程序成为一个能独立运行的基本单位或一个能与其他进程并发执行的进程。</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0a2b1322eac447b495050ae51ef7841f><p class=pgc-img-caption></p></div><p><br></p><p>线程切换和进程切换的步骤也不同。进程的上下文切换分为两步：</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f5d4a59e0873491a925a895ea0ca594f><p class=pgc-img-caption></p></div><p><br></p><p>对于Linux来说，线程和进程的最大区别就在于地址空间。<strong>对于线程切换，第1步是不需要做的，第2是进程和线程切换都要做的</strong>。所以明显是进程切换代价大。线程上下文切换和进程上下文切换一个最主要的区别是<strong>线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的</strong>。这两种上下文切换的处理都是<strong>通过操作系统内核来完成的</strong>。内核的这种切换过程伴随的<strong>最显著的性能损耗是将寄存器中的内容切换出</strong>。</p><p>对于一个正在执行的进程包括<strong>程序计数器、寄存器、变量的当前值等</strong>，而这些数据都是<strong>保存在CPU的寄存器中的，且这些寄存器只能是正在使用CPU的进程才能享用</strong>，<strong>在进程切换时，首先得保存上一个进程的这些数据（便于下次获得CPU的使用权时从上次的中断处开始继续顺序执行，而不是返回到进程开始，否则每次进程重新获得CPU时所处理的任务都是上一次的重复，可能永远也到不了进程的结束处，因为一个进程几乎不可能执行完所有任务后才释放CPU），然后将本次获得CPU的进程的这些数据装入CPU的寄存器从上次断点处继续执行剩下的任务</strong>。</p><p><strong>操作系统为了便于管理系统内部进程，为每个进程创建了一张进程表项：</strong></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/051a2c4fb3534c7d812d6d91fcbcd1f5><p class=pgc-img-caption>进程表项</p></div><p><br></p><h1 class=pgc-h-arrow-right>2.4 切换查看</h1><p>在Linux系统下可以使用vmstat命令来查看上下文切换的次数，下面是利用vmstat查看上下文切换次数的示例：</p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c1b967f535c489d90d922dcf49352a0><p class=pgc-img-caption>上线文切换查看</p></div><p><br></p><p>vmstat 1指每秒统计一次,<strong>其中cs列就是指上下文切换的数目</strong>. 一般情况下, 空闲系统的上下文切换每秒大概在1500以下.</p><h1 class=pgc-h-arrow-right>3 切换原因</h1><p>引起线程上下文切换的原因，主要存在三种情况如下：</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/86dbe4ddc5ef4f62a4dac204f4c23abc><p class=pgc-img-caption></p></div><p><br></p><p>对于我们经常<strong>使用的抢占式操作系统</strong>而言，引起线程上下文切换的原因大概有以下几种：</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a44025c2074e4c48969e692e2b88e807><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>4 切换损耗</h1><p>上下文切换会带来<strong>直接和间接</strong>两种因素影响程序性能的消耗。</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90880f19818a470aa59b647b41bcc771><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>5 减少切换</h1><p>既然上下文切换会导致额外的开销，因此减少上下文切换次数便可以提高多线程程序的运行效率。但上下文切换又分为2种：</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/015dbc02380d4db6b27fd9a8a353395c><p class=pgc-img-caption></p></div><p><br></p><p>所以，减少上下文切换的方法<strong>有无锁并发编程、CAS算法、使用最少线程和使用协程</strong>。</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04b06ed06fe342eb8346128631b3ab78><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>6 线程数目</h1><p>合理设置线程数目，关键点是：<strong>1. 尽量减少线程切换和管理的开支；2. 最大化利用CPU</strong>；</p><p><br></p><div class=pgc-img><img alt=啃碎并发（三）：Java线程上下文切换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/73419a9c060a4e298ff9f5c213010ee1><p class=pgc-img-caption></p></div><p><br></p><p>所以<strong>对于任务耗时短的情况，要求线程尽量少</strong>，如果线程太多，有可能出现线程切换和管理的时间，大于任务执行的时间，那效率就低了；</p><p><strong>对于耗时长的任务，要分是CPU任务，还是IO等类型的任务</strong>。如果是CPU类型的任务，线程数不宜太多；但是如果是IO类型的任务，线程多一些更好，可以更充分利用CPU。</p><p><strong>高并发，低耗时的情况</strong>：建议少线程，只要满足并发即可，<strong>因为上下文切换本来就多，并且高并发就意味着CPU是处于繁忙状态的， 增加更多地线程也不会让线程得到执行时间片，反而会增加线程切换的开销</strong>；例如并发100，线程池可能设置为10就可以；</p><p><strong>低并发，高耗时的情况</strong>：建议多线程，保证有空闲线程，接受新的任务；例如并发10，线程池可能就要设置为20；</p><p><strong>高并发高耗时</strong>：1. 要分析任务类型；2. 增加排队；3. 加大线程数</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','线程','切换'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>