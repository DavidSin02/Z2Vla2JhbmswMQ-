<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 | 极客快訊</title><meta property="og:title" content="鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4331d0b354d4405b91ff022ac65cd4bc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5487254a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5487254a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5487254a.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5487254a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4331d0b354d4405b91ff022ac65cd4bc><p class=pgc-img-caption></p></div><p><strong>|</strong>导语：非常幸运的是，从4月份至今，我能够全身心投入到腾讯新闻的单元测试专项任务中，从无知懵懂，到不断深入理解的过程，与开发同学互帮互助，受益匪浅。 在此过程中，得到了质量总监、新闻总监和乔帮主的倾囊指导，真心感谢！！ 我希望把所有心得，总结成一篇较为全面的文章，分享给其他团队。 时刻牢记：</p><ol><li>不要滥用mock</li><li>基于意图。</li></ol><p>在我们谈到单元测试，大都清楚是测试函数符合预期，国外很多大公司都将单测执行的很好，国内成功的案例则相对有限。在本文中，笔者将在腾讯新闻项目中亲身经历单测从无到有的实践过程梳理为可读可参考的经验分享出来。在实践的过程我发现，单测可以推动产品质量转为优秀，推动实行它的过程更需要对它有真实的认识以及一套方法论。</p><h1>一. 为单元测试"正名"</h1><p>我曾经认为，单元测试面向的是一个函数。任何走出一个函数的测试，都不是单元测试。</p><p>其实，对"单元"的定义取决于自己。如果你正在使用函数式编程，一个单元最有可能指的是一个函数。你的单元测试将使用不同的参数调用这个函数，并断言它返回了期待的结果；在面向对象语言里，下至一个方法，上至一个类都可以是一个单元（从一个单一的方法到一整个的类都可以是一个单元）。<strong>意图</strong>很重要（"意图"二字是本文中第一次提到，它很重要）</p><p>我们有单元测试、增量测试、集成测试、回归测试、冒烟测试等等，名字非常多。谷歌看到这种"百家争鸣"的现象，创立了自己的命名方式，只分为<strong>小型测试</strong>、<strong>中型测试</strong>和<strong>大型测试</strong>。</p><p>· 小型测试，针对单个函数的测试，关注其内部逻辑，mock所有需要的服务。小型测试带来优秀的代码质量、良好的异常处理、优雅的错误报告</p><p>· 中型测试，验证两个或多个制定的模块应用之间的交互</p><p>· 大型测试，也被称为"系统测试"或"端到端测试"。大型测试在一个较高层次上运行，验证系统作为一个整体是如何工作的。、</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f88b0cd2ffa4466b58d8b12893160e4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2a1673a6d174df4b8cd6f05fd182ddd><p class=pgc-img-caption></p></div><p>结论：我们的单元测试，既可以针对一个函数写case，也可以按照函数的调用关系串起来写case。</p><h1>二. 金字塔模型</h1><p>在金字塔模型之前，流行的是冰淇淋模型。包含了大量的手工测试、端到端的自动化测试及少量的单元测试。造成的后果是，随着产品壮大，手工回归测试时间越来越长，质量很难把控；自动化case频频失败，每一个失败对应着一个长长的函数调用，到底哪里出了问题？单元测试少的可怜，基本没作用。</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ded9ab1719a478d9eac72dfc60f6037><p class=pgc-img-caption></p></div><p>Mike Cohn 在他的著作《Succeeding with Agile》一书中提出了<strong>"测试金字塔"</strong>这个概念。这个比喻非常形象，它让你一眼就知道测试是需要分层的。它还告诉你每一层需要写多少测试。</p><p>测试金字塔本身是一条很好的经验法则，我们最好记住Cohn在金字塔模型中提到的两件事：</p><ul><li>编写不同粒度的测试</li><li>层次越高，你写的测试应该越少</li></ul><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eca77090e4d4aebb814dbb443838410><p class=pgc-img-caption></p></div><p>同时，我们对金字塔的理解绝不能止步于此，要进一步理解：</p><p>我把金字塔模型理解为——<strong>冰激凌融化了</strong>。就是指，最顶部的"手工测试"理论上全部要自动化，向下融化，优先全部考虑融化成单元测试，单元测试覆盖不了的 放在中间层（分层测试），再覆盖不了的才会放到UI层。因此，UI层的case，能没有就不要有，跑的慢还不稳定。按照乔帮主的说法，我不分单元测试还是分层测试，统一都叫自动化测试，那就应该把所有的自动化case看做一个整体，case不要冗余，单元测试能覆盖，就要把这个case从分层或ui中去掉。</p><p>越是底层的测试，牵扯到相关内容越少，而高层测试则涉及面更广。比如单元测试，它的关注点只有一个单元，而没有其它任何东西。所以，只要一个单元写好了，测试就是可以通过的；而集成测试则要把好几个单元组装到一起才能测试，测试通过的前提条件是，所有这些单元都写好了，这个周期就明显比单元测试要长；系统测试则要把整个系统的各个模块都连在一起，各种数据都准备好，才可能通过。</p><p>另外，因为涉及到的模块过多，任何一个模块做了调整，都有可能破坏高层测试，所以，高层测试通常是相对比较脆弱的，在实际的工作中，有些高层测试会牵扯到外部系统，这样一来，复杂度又在不断地提升。</p><h1><strong>三. 为什么做单测</strong></h1><p>这个问题我们规避不掉。新闻是这次研发模式改革的主力军之一，所以自上而下的推动让这个问题不那么棘手：做了就是做了。不做，却又有那么多的理由：</p><p>（搜集到的吐槽真实声音）</p><p>· <em>单元测试浪费了太多的时间</em></p><p>· <em>单元测试仅仅是证明这些代码做了什么</em></p><p>· <em>我是很棒的程序员，我是不是可以不进行单元测试？</em></p><p>· <em>后面的集成测试将会抓住所有的bug</em></p><p>· <em>单元测试的成本效率不高我把测试都写了，那么测试人员做什么呢？</em></p><p>· <em>公司请我来是写代码，而不是写测试</em></p><p>· <em>测试代码的正确性，并不是我的工作</em></p><p>我觉得我们总监指导的很到位：改革，一是工作方式的改革，更难的是思想上的改革。</p><h1><strong>单元测试的意义</strong></h1><p>新闻的总监dot老师是至始至终推进单测的好领导，他讲述了螺丝钉与飞机的故事：</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b5be4a22ca12410dae12bd951acf54d4><p class=pgc-img-caption></p></div><ul><li>单元测试对我们的产品质量是非常重要的。</li><li>单元测试是所有测试中最底层的一类测试，是第一个环节，也是最重要的一个环节，是<strong>唯一一次有保证能够代码覆盖率达到100%的测试</strong>，是整个软件测试过程的基础和前提，单元测试防止了开发的后期因bug过多而失控，单元测试的性价比是最好的。</li><li>据统计，大约有80%的错误是在软件设计阶段引入的，并且修正一个软件错误所需的费用将随着软件生命期的进展而上升。错误发现的越晚，修复它的费用就越高，而且呈指数增长的趋势。作为编码人员，也是单元测试的主要执行者，是唯一能够做到生产出无缺陷程序这一点的人，其他任何人都无法做到这一点</li><li>代码规范、优化，可测试性的代码</li><li>放心重构</li><li>自动化执行three-thousand times</li></ul><p>下面这张图，来自微软的统计数据：bug在单元测试阶段被发现，平均耗时3.25小时，如果漏到系统测试阶段，要花费11.5小时。</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9bd4b79c969443deb3189296603afbae><p class=pgc-img-caption></p></div><p>下面这张图，旨在说明两个问题：85%的缺陷都在代码设计阶段产生，而发现bug的阶段越靠后，耗费成本就越高，指数级别的增高。所以，在早期的单元测试就能发现bug，省时省力，一劳永逸，何乐而不为呢</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f185b9b0fc749939ea1de3641857796><p class=pgc-img-caption></p></div><h1><strong>单元测试特别耗时？</strong></h1><p><strong>不能一刀切，不能只盯着单测阶段的耗时</strong>。</p><p>我采访了新闻客户端、后台的开发，首先肯定的是，单测会增加开发量、增加开发时长；</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fdbb094233a74d4d94821d156a91ad49><p class=pgc-img-caption></p></div><p>在《单元测试的艺术》这本书提到一个案例：找了开发能力相近的两个团队，同时开发相近的需求。进行单测的团队在编码阶段时长增长了一倍，从7天到14天，但是，这个团队在集成测试阶段的表现非常顺畅，bug量小，定位bug迅速等。最终的效果，整体交付时间和缺陷数，均是单测团队最少。</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/91142ef80f46493d85e436fc0d51aef3><p class=pgc-img-caption></p></div><p>单测，存在即合理。一方面，需要把单测放在整个迭代周期来观测其效果；一方面，写单测也是技术活，<strong>写得好的同学</strong>，时间少代码质量高（也即，不是说写了单测，就能写好单测）</p><h1>谁来写单测呢？</h1><ul><li>开发同学写单测</li><li>测试同学具有写单测的能力。重点在于开发脚手架、分层测试/端到端测试</li></ul><h1>增量还是存量</h1><ul><li>单测case针对增量代码</li><li>当存量代码出现大规模重构，后者质量暴露出极大风险时，都是推动补全单测的好时机</li></ul><h1>四. 单元测试的阶段</h1><p>1. 广义的单元测试，我们指这三部分的有机组合：</p><ul><li>code review</li><li>静态代码扫描</li><li>单元测试用例编写</li></ul><p>2. 结合新闻的实践，我把单测成长的过程分为4个目标，分别为：</p><ul><li>会写，全员可写</li><li>写的好，同时关注可测性问题，试点解决</li><li>识别可测性问题，熟练使用重构方法进行重构；识别代码架构设计问题；case与业务代码同步编写</li><li>TDD。但这个目标是期望，不能作为必须实现的目标。</li></ul><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bfcdb302154494f803cf9aa3aefc004><p class=pgc-img-caption></p></div><p>截至发稿当天，新闻处于第三阶段，即，每个迭代均能产出高质量的case，人数覆盖和需求覆盖均较高；关注重点在于可测性，时刻注重重构。</p><h1>五. 单元测试的指标</h1><p>还挺尴尬的，不太有直接的指标去衡量单测的效果。我们也经常被问到，"怎么证明你们新闻单测的作用呀？"</p><ul><li>bug类指标（间接指标）：连续迭代的bug总数趋势、迭代内新建bug的趋势、千行bug率</li><li>单测的需求覆盖度（50%以上），参与人员覆盖度（80%以上）</li><li>单测case总数趋势，代码行增量趋势</li><li>增量代码的行覆盖率（接入层80%，客户端30%）</li><li>单函数圈复杂度（低于40），单函数代码行数（低于80），扫描告警数</li></ul><p>在迭代需求持续高吞吐量的前提下，以新闻iOS的数据为例：</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8392a0ec7af942f9870e247a69cca484><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4381c8be6e964433b7be2c0eee9663aa><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/157717b6709c4142aaa496fb5d41d1ee><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/50c8a3d30ef44b369221bed576ca1c15><p class=pgc-img-caption></p></div><h1>六. go单元测试框架选型</h1><p>基本选型：testify + gomonkey</p><p>附加：httptest + sqlmock</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b424f96c0b8146b7a35d328a8684c17a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/993130c9b0dc4a8fb520bec9680a3863><p class=pgc-img-caption></p></div><h1>前提</h1><ul><li>测试文件，以_test.go结尾，与被测文件放于相同目录</li><li>测试函数，函数名以Test开头，并且随后的第一个字符必须为大写字母或下划线，如：TestParseReq_CorrectNum_TableDriven</li><li>测试函数，参数为t *testing.T；对于bench测试，参数为b *testing.B</li><li>运行命令行，我的文章有深入讲解：</li></ul><h1>testify常规用法</h1><p>testify基于gotesting编写，所以语法上、执行命令行与go test完全兼容</p><ul><li>支持大量高效的api，比如：</li></ul><p>assert.Equal：常规对比，是把两者分别换成[]byte去严格比对</p><p>assert.Nil：判断对象为nil时，有时对err判空时也用</p><p>assert.Error：判断err的具体类型和内容</p><p>assert.JSONEq：这个比较有用，对比map时；或者对比struct的时候，也会先转为map，在用这个api去做对比，如下面这个例子，我封装了建议的方法去将struct转换为string(json)：</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/59a8742a214846ce9f49ba3d32398bff><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0b5039bd234643c19652a25b4ce9be95><p class=pgc-img-caption></p></div><ul><li>支持suite，用例集管理</li><li>运行时，可以指定用例集执行</li></ul><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/32e27aa7c9f44fa99448c5f06233ffcd><p class=pgc-img-caption></p></div><ul><li>自带mock工具，但只支持接口方法的mock，而且用法相对复杂</li><li>table-driven</li></ul><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/07865253e3844b7ca36ab6b8e7679400><p class=pgc-img-caption></p></div><h1>gomonkey用法（加粗字体表示常用）</h1><p>https://github.com/agiledragon/gomonkey</p><p>https://studygolang.com/articles/15034</p><ul><li><strong>支持为一个函数打一个桩</strong></li><li><strong>支持为一个成员方法打一个桩</strong></li><li>支持为一个全局变量打一个桩</li><li>支持为一个函数变量打一个桩</li><li><strong>支持为一个函数打一个特定的桩序列</strong></li><li><strong>支持为一个成员方法打一个特定的桩序列</strong></li><li>支持为一个函数变量打一个特定的桩序列</li><li>table-driven的方式定义一系列stub</li></ul><p>注意，对内联函数的Stub，go test命令行一定要加上参数才可生效。见官方文档。所以，我的命令行默认加上-gcflags=all=-l就行了。</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8634c1c88b19495c830401a99a5d24db><p class=pgc-img-caption></p></div><p>我设置了一些goland的代码模板，放在附件中。</p><p>ApplyFunc是对外部函数Stub（非类方法）</p><pre>/* 用法：gomonkey.ApplyFunc(被stub函数名, 被stub函数签名) 函数返回值*例子：patches := gomonkey.ApplyFunc(fake.Exec, func(_ string, _ ...string) (string, error) {return outputExpect, nil})*/patches := gomonkey.ApplyFunc(lcache.GetCache, func(_ string) (interface{}, bool) {return getCommentsResp()})defer patches.Reset()</pre><p>ApplyMethod是对类函数Stub。但这里注意，要被stub的方式是私有方法，gomonkey通过反射是找不到的，有两种解决方法：</p><p>1）使用增强版的gomonkey；</p><p>2）不Stub它，而是选择走进这个函数，这个话题在后面专题谈mock的时候说。</p><pre>/* 用法：gomonkey.ApplyMethod(反射类名, 被stub函数签名) 函数返回值*例子：var s *fake.Slicepatches := ApplyMethod(reflect.TypeOf(s), "Add", func(_ *fake.Slice, _ int) error {return nil})*/var ac *auth.AuthCheckpatches := gomonkey.ApplyMethod(reflect.TypeOf(ac), "PrepareWithHttp", func(_ *auth.AuthCheck, _ *http.Request, _ ...auth.AuthOption) error {return fmt.Errorf("prepare with nil object")})defer patches.Reset()</pre><p>ApplyMethodSeq是对同一个Stub的函数返回不同的结果</p><pre>/* 用法：gomonkey.ApplyMethodSeq(类的反射，"被stub函数名", 返回结构体)；Params{info1},中括号内为被stub函数的返回值列表；Times为生效次数*例子：e := &amp;fake.Etcd{}info1 := "hello cpp"info2 := "hello golang"info3 := "hello gomonkey"outputs := []OutputCell{{Values: Params{info1, nil}},{Values: Params{info2, nil}},{Values: Params{info3, nil}},}patches := ApplyMethodSeq(reflect.TypeOf(e), "Retrieve", outputs)defer patches.Reset()*/conn := &amp;redis.RedisConn{}patch1 := gomonkey.ApplyFunc(redis.NewRedisHTTP, func(serviceName string, _ string) *redis.RedisConn {conn := &amp;redis.RedisConn{redis.RedisConfig{},&amp;redis.RedisHelper{},}return conn})defer patch1.Reset()// mock redis data. 返回空和不为空的情况outputCell := []gomonkey.OutputCell{{Values: gomonkey.Params{"12", nil}, Times: 1},{Values: gomonkey.Params{"", nil}, Times: 1},}patchs := gomonkey.ApplyMethodSeq(reflect.TypeOf(conn.RedisHelper), "Get", outputCell)defer patchs.Reset()</pre><p>先举这几个例子，详细的可以在上面的链接文章中全面得到。</p><p>这里补充一点，对类方法进行stub，<strong>必须要找到该方法对应的真实的类（结构体）</strong>，举个例子：</p><pre>//被测函数中有如下一段，其中的Get方法我们想stub掉，只要找到Get方法对应的类就好了readCountStr, _ := conn.Get(redisKey)if len(readCountStr) == 0 {return 0, nil}</pre><pre>//定位conn，是RedisConn类型的structtype RedisConn struct {RedisConfig*RedisHelper}//所以第一次，我用gomonkey.AppleyMethod时这么写：patches := gomonkey.ApplyMethod(reflect.TypeOf(*RedisConn),"Get", func(_ *redis.RedisHelper,_ string, _ []string) ([]string, error){return info,err_notNil})defer patches.Reset()//运行时报了空指针panic，提示RedisConn没有Get方法 </pre><pre>//继续追，原来Get是*RedisHelper的方法，组合到了RedisConn结构体中，共用方法。但我们使用gomonkey时，需要指向真正定义它的类func (this *RedisHelper) Get(key string) (string, error) {return redigo.String(this.Do("GET", key))</pre><pre>//最终这么写:patches := gomonkey.ApplyMethod(reflect.TypeOf(giftData.rankRedisRD.RedisHelper),"Get", func(_ *redis.RedisHelper,_ string, _ []string) ([]string, error){return info,err_notNil})defer patches.Reset()</pre><h1>七. 必须说一说mock了</h1><h1>test doubles</h1><p>在《xUnit Test Patterns》一书中，作者首次提出test doubles（测试替身）的概念。我们常挂在嘴边的mock只是其中一种，而且是最容易与Stub（打桩）混淆的一种。在上一节中对gomonkey的介绍，你可以注意到了，我没有使用mock，全部是Stub。是的，gomonkey不是mock工具，只是一个高级打桩的工具，适配了我们大部分的使用场景。</p><p>测试替身，共有五种：可以参考这篇翻译</p><ul><li>Dummy Object：</li></ul><p>用于传递给调用者但是永远不会被真实使用的对象，通常它们只是用来填满参数列表</p><ul><li>Test Stub</li></ul><p>Stubs通常用于在测试中提供封装好的响应，譬如有时候编程设定的并不会对所有的调用都进行响应。Stubs也会记录下调用的记录，譬如一个email gateway就是一个很好的例子，它可以用来记录所有发送的信息或者它发送的信息的数目。简而言之，Stubs一般是对一个真实对象的封装</p><ul><li>Test Spy</li></ul><p>Test Spy像一个间谍，安插在了SUT内部，专门负责将SUT内部的间接输出(indirect outputs)传到外部。它的特点是将内部的间接输出返回给测试案例，由测试案例进行验证，Test Spy只负责获取内部情报，并把情报发出去，不负责验证情报的正确性</p><ul><li>Mock Object</li></ul><p>针对设定好的调用方法与需要响应的参数封装出合适的对象</p><ul><li>Fake Object</li></ul><p>Fake对象常常与类的实现一起起作用，但是只是为了让其他程序能够正常运行，譬如内存数据库就是一个很好的例子。</p><h1>stub与mock</h1><p>打桩和mock应该是最容易混淆的，而且习惯上我们统一用mock去形容模拟返回的能力，习惯成自然，也就把mock常挂在嘴边了。</p><p>就我的理解，stub可以理解为mock的子集，mock更强大一些：</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f4bd150027e443488017ee6ed4f8d55a><p class=pgc-img-caption></p></div><ul><li>mock可以验证实现过程，验证某个函数是否被执行，被执行几次</li><li>mock可以依条件生效，比如传入特定参数，才会使mock效果生效</li><li>mock可以指定返回结果</li><li>当mock指定任何参数都返回固定的结果时，它等于stub</li></ul><p>只不过，go的mock工具gomock只基于接口生效，不适合新闻、企鹅号项目，而gomonkey的stub覆盖了大部分的使用场景。</p><h1>八. 不要滥用mock</h1><p>我把这一部分单独放一章节，表现出它重要的意义。需要读懂肖鹏的《mock七宗罪》，在gitchat上。</p><h1>两个门派</h1><p>约从2004-2005年间，江湖上形成两大门派：经典测试驱动开发派 和 mockist（mock极端派）。</p><p>先说mockist。他主张将被测函数 <strong>所有</strong> 调用的外面函数，全部mock。也即，只关注被测函数自己的一行行代码，只要调用其他函数，全都mock掉，用假数据来测试。</p><p>再说经典测试驱动开发派，他们主张不要滥用mock，能不mock就不mock，被测单元也不一定是具体的一个函数，可能是多个函数，串起来。<strong>必要的时候再mock</strong>。</p><p>两个门派相争多年，理论各有利弊，至今仍然共存。存在即合理。比如mockist，使用了过多的mock，无法覆盖函数接口，这部分又是很容易出错的；经典派，串的太多，又被质疑是集成测试。</p><p>对于我们实际应用，<strong>不必强制遵从某一派，结合即可</strong>，需要的时候mock，尽量少mock，不用纠结。</p><h1>什么时候适合mock</h1><p>如果一个对象具有以下特征，比较适合使用mock对象：</p><ul><li>该对象提供非确定的结果（比如当前的时间或者当前的温度）</li><li>对象的某些状态难以创建或者重现（比如网络错误或者文件读写错误）</li><li>对象方法上的执行太慢（比如在测试开始之前初始化数据库）</li><li>该对象还不存在或者其行为可能发生变化（比如测试驱动开发中驱动创建新的类）</li><li>该对象必须包含一些专门为测试准备的数据或者方法（后者不适用于静态类型的语言，流行的Mock框架不能为对象添加新的方法。Stub是可以的。）</li></ul><p><strong>因此，不要滥用mock（stub），当被测方法中调用其他方法函数，第一反应应该走进去串起来，而不是从根部就mock掉了。</strong></p><h1>九. 用例设计法</h1><p>乔帮主介绍了一篇文章：像机器一样思考</p><p>文章讲述思考程序设计的根本思路——考虑输入输出。我们设计case，想要得到最全面的设计，根本是考虑全输入全输出的组合，当然，一方面，这么做耗时太大，很多时候是不可执行的；一方面，这不是想要的结果，要考虑投入产出比。这时，需要理论与实践相结合，理论指导实践，实践精细理论。</p><h1>先说理论</h1><p>1. 还是从上篇文章说起，考虑输入、输出，就要先知道哪些属于输入输出：</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92a8de5d507d41edba52bae28f8b5511><p class=pgc-img-caption></p></div><p>2. 白盒&黑盒设计</p><p>白盒法：</p><ul><li>逻辑覆盖（语句、分支、条件、条件组合等）</li><li>路径（全路径、最小线性无关路径）</li><li>循环：结合5种场景（跳过循环、循环一次，循环最大次，循环m次命中、循环m次未命中）</li></ul><p>黑盒法：</p><p>等价类：正确的，错误的（合法的，非法的）</p><p>边界法：[1，10] ==> 0，1，2，9，10，11（是等价类的有效补充）</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ecfd4de22364bf088605483ce0caa0d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec3a65a854884a36b1359b80fd449d3e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ec53ecd22f2a42e0b1eef66a08000e1b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fbc4ebd4c25b4a2fbecb16b19b2bb3f5><p class=pgc-img-caption></p></div><p>3. 结合应用</p><p>全输入输出，实施难度较大，转而我们思考到业内大神们设计出白盒黑盒设计法，通过仔细思考，可以判断出是对全输入全输出的方法论体现。</p><p>因此，白盒&黑盒用例设计法，每一种我都亲自实践，理解其优缺点，从设计覆盖角度，条件组合>最小线性无关路径>条件>分支>语句。</p><p>下面这张图，是我早期思考用例设计时的一次实践，现在回忆起来，它过度设计了。</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/73e5aaee12f64a7094294e6eac448699><p class=pgc-img-caption></p></div><p>但实际中，我们担心"过度设计"，也还无法给出答案"用什么方法设计保证万无一失"。</p><ul><li>过度设计，也会使case脆弱</li><li>在有限的时间内，我们寻求收益较大化</li></ul><p>1. 小函数&重要（计算，对象处理）：尽量设计全面</p><p>2. 逻辑较重，代码行数较多：分支、语句覆盖 + 循环 + 典型的边界处理（我们看个例子：GetUserGiftList）</p><p>3. 引出"基于实现"与"<strong>基于意图</strong>"的设计：过多去Stub被测函数内部的调用，就越接近"基于实现"（第二次提到"基于意图"）</p><h1>十. 基于意图与基于实现</h1><p>这个话题是非常重要的。</p><p><strong>基于意图</strong>：思考函数最终想做什么，把被测函数当做黑盒，考虑其输出输出，而不要关注其中间是怎样实现的，究竟生成了什么临时变量，循环了几次，有什么判断等。</p><p><strong>基于实现</strong>：输入输出我也考虑，中间怎么实现的我也考虑。mock就是一个好例子，比如我们写一个case，我们会用mock去验证函数内是否调用了哪个外部方法、调用了几次，语句的执行顺序是怎样的。程序的变动比需求还快，重构随时都有，稍有一变，case大批量失败，这也是《mock七宗罪》中提到的一种情况。</p><p><strong>我们要的是基于意图，远离基于实现</strong>。</p><p>dot老师和乔帮主给我们上了课程，结合实战经验，我总结如下：</p><p>1. "要么写好，要么不写"。case也是代码，也需要维护，也有工作量，所以要写的到位，而不是写得多。写了一堆没用的，你还得维护，不如删了。</p><p>2. 拿到一个函数，先问问自己，这个函数要实现什么功能，最终输出是什么；然后，问自己，这个函数的风险在哪里，哪部分逻辑不太自信，最容易出错（计算、复杂的判断、某异常分支的命中等）。这些才是我们case要覆盖的点。</p><p>3. 内联函数、直接get/set，没几行没什么逻辑的，只要你判断没什么风险，就不用写case。</p><p>4. 确定了要写的case，再用分支条件组合、边界等核心方面设计出具体用例，实施编写。</p><p>我们看一个具体的case：</p><p>1. 拿到这个函数，作为<strong>测试同学的我</strong>先向开发了解该函数的意图：对符合格式、符合时间的用户礼物进行加和</p><p>2. 读代码，了解了代码流程、几个异常分支，先做了code review</p><p>3. 根据必要的异常分支，设计case覆盖</p><p>4. 对正常的业务流程，是按照开发讲述的函数意图，进行设计，case如下：</p><p>被测函数：</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c8720535d254342917b1e2da054d3cf><p class=pgc-img-caption></p></div><p>正常路径的单测case</p><pre>func TestNum_CorrectRet(t *testing.T) {giftRecord := map[string]string{"1:1000": "10","1:2001": "100","1:999": "20","2": "200","a": "30","2:1001": "20","2:999": "200",}expectRet := map[int]int{1: 110,2: 20,}var s *redis.xxxpatches := gomonkey.ApplyMethod(reflect.TypeOf(s), "Getxxx", func(_ *redis.xxx, _ string)(map[string]string, error) {return giftRecord, nil})defer patches.Reset()p := &amp;StarData{xxx }userStarNum, err := p.GetNum(10000)assert.Nil(t, err)assert.JSONEq(t, Calorie.StructToString(expectRet), Calorie.StructToString(userStarNum))}</pre><p><strong>有同学会问到</strong>：但是你最终还是看的代码呀？看到代码的正确逻辑是怎么处理的，再去设计的case和构造数据吧？而且你不看代码，怎么知道有哪些异常分支要覆盖呢？</p><p>答：</p><p>1. 我现在作为测试同学写开发同学的case，确实需要知道有哪些异常分支要处理， 但不局限于代码中的几种，还应该包括我理解到的异常分支，都要体现在case中。我们的case绝不是为了证明代码是怎么实现的！通过单测，我们经常能够发现bug。但是将来是开发来写单测的，他自己设计的函数肯定知道要覆盖哪些异常分支。</p><p>2. 嗯，我需要看代码的正常流程是怎样的，但不代表着把代码扒下来以设计出case。case实际上是通过与开发的沟通后，了解输入数据的结构，输出的格式，数据校验和计算的过程，去设计输入输出的。</p><h1>十一. 用例编写的策略</h1><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0a34a8e2cf5b4059b4dcfa0fc4a69ee0><p class=pgc-img-caption></p></div><p>对于怎么个顺序去写单测，我们重点实践了一番，基本上也就三种情况吧：</p><ul><li>独立原子：mockist，被我们推翻了。当然，最底部的函数可能没有外部依赖，那单测它就够了。</li><li>自上而下（红线）：从入口函数往下测。实践的过程中，我发现很难执行，因为我从入口处就要想好每一次调用都需要返回哪些数据及格式，串起来一个case已经非常不易。</li><li>自下而上(黄线)：我们发现，入口函数，往往没什么逻辑，调用另一个函数然后拿到响应返回。所以入口函数，也许不用写？我们继续往下看，每一次调用的函数都看，也调出了以往的线上线下bug，我们发现出现问题的代码部分往往是调用链的底端，尤其是涉及计算、复杂分支循环等。而且，底端的函数往往可测性较好。</li></ul><p>因此，考虑两方面，<strong>我们选择自下而上设计来选择函数编写case</strong>：</p><p>1. 底部的函数可测性通常很好</p><p>2. 核心逻辑比较多，尤其涉及计算、拼接，分支的。</p><h1>十二. 可测性问题的解决——重构</h1><p>导致无法写单测的重要原因是，代码可测性不好。如果一个函数八九十行、二三百行，基本就是不可测的，或者说"不好测的"。因为里面逻辑太多了，从第一行到最后一行都经历了什么，各种函数调用外部依赖，各种if/for，各种异常分支处理，写一个case的代码行数可能是原函数的几倍。</p><p>因此，推动单测走下去，重构提升可测性是必须环节。而且，通过重构，代码结构间接清晰了，更可读可维护，更容易发现和定位问题。</p><p>常见的问题：重复代码、魔法数字、箭头式的代码等</p><p>推荐的理论书籍是《重构：改善既有代码的设计》第二版、《clean code》</p><p>我输出了一篇关于重构的文章。</p><p>使用codecc（腾讯代码检查中心）的圈复杂度、函数长度来评估代码结构质量，我们与开发一起学习，一起实践，不断有成果输出。</p><p>对于箭头式的代码，可考虑如下步骤：</p><p>1. 多使用卫语句，先判断异常，异常return</p><p>2. 将判断语句抽离</p><p>3. 将核心部分抽离为函数</p><h1>十三. 用例维护，可读性、可维护性、可信赖性</h1><h1>用例设计要素</h1><ul><li>将内部逻辑与外部请求分开测试</li><li>对服务边界（interface）的输入和输出进行严格验证</li><li>用断言来代替原生的报错函数</li><li>避免随机结果</li><li>尽量避免断言时间的结果</li><li>适时使用setup和teardown</li><li>测试用例之间相互隔离，不要相互影响</li><li>原子性，所有的测试只有两种结果：成功和失败</li><li>避免测试中的逻辑，即不该包含if、switch、for、while等</li><li>不要保护起来，try…catch…</li><li>每个用例只测试一个关注点</li><li>少用sleep，延缓测试时长的行为都是不健康的</li><li>3A策略：arrange，action，assert</li></ul><h1>用例可读性</h1><ul><li>标题要明确表明意图，如Test+被测函数名+condition+result。case失败后，通过名字就知道哪个场景失败，而不用一行行再读代码。将来维护这个测试代码的，可能是其他人，我们需要让别人容易读懂</li><li>测试代码的内容要清晰，3A原则：arrange，action，assert 分成三部分。数据准备部分arrange如果代码行较多，考虑抽离出去。</li><li>断言的意图明显，可以考虑将魔法数字变为变量，命名通俗易通</li><li>一个case，不要做过多的assert，要专一</li><li>和业务代码的要求一致，都要可读</li></ul><h1>用例可维护性</h1><ul><li>重复：文本字符串重复、结构重复、语义重复</li><li>拒绝硬编码</li><li>基于意图的设计。不要因为业务代码重构一次，就导致一批case失败</li><li>注意代码的各种坏味道，可参见《重构》第二版</li></ul><h1>用例可信赖性</h1><p>单元测试，小而且运行快，它不是为了发现本次的bug，更是为了放在流水线上 努力发现每一次MR是否产生了bug。单测运行失败，唯一的原因只应该是出现bug，而不是因为外部依赖不稳定、基于实现的涉及等，长期的失败将失去单元测试的警示作用，"狼来了"的故事是惨痛的教训。</p><ul><li>非被测程序缺陷，随机失败的case</li><li>永不失败的case</li><li>没有assert的case</li><li>名不副实的case</li></ul><h1>十四. 新闻单元测试的推动过程</h1><p>我们提到，对单元测试的实践分为4个阶段，每阶段均有目标。</p><h1>第一阶段 会写，全员写，不要求写好</h1><ul><li>由上而下的推动，从总监到组长，极力支持，毫无犹豫，使组员情绪高涨</li><li>快速确定单测框架，熟练使用</li><li>结合开发需求，输出各场景下 单测框架的使用方法，包括assert、mock，table-driven等</li><li>封装http2WebContext，方便生成context对象</li><li>多次培训，讲解单测理论及框架使用</li><li>各团队（终端、接入层）指定单测接口人，由他先尝螃蟹。他是最熟悉框架使用，在前期写最多case的人</li><li>在磨合好单测框架的集成使用后，启动会，部分同学先试点使用，确保连续两个迭代，这几个同学都有case输出</li><li>每个迭代总结数据中，加入单测相关数据：组长和总监非常关注单测数据信息，针对性鼓励提升case数量和代码行数</li></ul><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92bcb784395341bda1888cbff5fd6024><p class=pgc-img-caption></p></div><h1>第二阶段 写好，有效，全员写</h1><ul><li>测试同学探索出mock的正确使用方法、用例设计的正确思路，分享给团队，经过探讨达成一致</li><li>结对编程，每迭代结对2-3个开发，共同写case，互相提升。</li></ul><p>这里的结对是灵活的：有的开发，只需用半天的时间给他讲框架使用，同他练习，他就可以上手了不需要再担心；有的开发，会分给测试同学需求，测试同学写完case后，开发review学习，并尝试写出自己的第一个case；有的开发，一开始可能不太接受，以需求不适合单测为理由，观察了一段时间，他发现其他人都写了，也没那么难，对团队也有利，他甚至会主动找到测试同学教他写case。</p><ul><li>测试同学对开发提交的case进行review，跟进开发修改后重新MR</li><li>连续两个迭代，邀请dot老师、乔帮主进行case review，效果非常好</li><li>对迭代的单测数据分析，关注需求覆盖度、人员覆盖度，case增量</li><li>组长持续鼓励支持单测</li><li>每迭代的需求增加"单元测试"字段，由组长评估后置位。不带单测的MR不予通过，单测也要被review</li></ul><h1>第三阶段 可测性提升</h1><ul><li>测试和开发共同学习《重构》第二版，每周有分享会</li><li>某些骨干同学优先重构自己的代码</li><li>测试同学严格要求，先保证有单测，然后小步重构，每一步均有单测保障</li><li>通过流水线的codecc扫描，圈复杂度和函数长度必须达标，不可人工干预其通过</li></ul><h1>第四阶段 TDD</h1><ul><li>先不保证开发同学做到TDD，门槛还是挺高的，而且需要在线下熟练之后再运用到业务开发中</li><li>逐步推动开发将业务代码和测试代码同步编写，而不是完成业务代码后再补case</li><li>测试同学练成TDD</li></ul><h1>十五. 流水线</h1><p>单测要放在流水线上跑，客户端和后台都配好了流水线，保证每次push和MR都运行一次，发报告。</p><p>对于go的单测，新闻接入层各模块是通过MakeFile来编译，因为要导入一些环境变量，所以我将go test集成在MakeFile中，执行make test即可运行该模块下所有的测试用例。</p><pre>GO = goCGO_LDFLAGS = xxxCGO_LDFLAGS += xxxCGO_LDFLAGS += xxxCGO_LDFLAGS += xxxTARGET =aaaexport CGO_LDFLAGSall:$(TARGET)$(TARGET): main.go$(GO) build -o $@ $^test:CFLAGS=-gexport CFLAGS$(GO) test $(M) -v -gcflags=all=-l -coverpkg=./... -coverprofile=test.out ./...clean:rm -f $(TARGET) </pre><p>注：上述做法，只能生成被测试的代码文件的覆盖率，无法拿到未被测试覆盖率情况。可以在根目录建一个空的测试文件，就能解决这个问题，拿到全量代码覆盖率。</p><pre>//main_test.gopackage mainimport ("fmt""testing")func TestNothing(t *testing.T) {fmt.Println("ok")}</pre><p>流水线加上流程</p><div class=pgc-img><img alt=鹅厂开发谈单元测试：牢记这两点，从此远离无效的单元测试 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2408343b98b74211ba58981b9595df0a><p class=pgc-img-caption></p></div><pre># cd ${WORKSPACE} 可进入当前工作空间目录export GOPATH=${WORKSPACE}/xxxpwdecho "====================work space"echo ${WORKSPACE}cd ${GOPATH}/srcfor file in `ls`:doif [ -d $file ]thenif [[ "$file" == "a" ]] || [[ "$file" == "b" ]] || [[ "$file" == "c" ]] || [[ "$file" == "d" ]]thenecho $fileecho ${GOPATH}"/src/"$filecp -r ${GOPATH}/src/tools/qatesting/main_test.go ${GOPATH}/src/$file"/."cd ${GOPATH}/src/$filemake testcd ..fifidone</pre><h1>附录. 资料</h1><ul><li>《测试驱动开发》</li><li>《单元测试的艺术》</li><li>《有效的单元测试》</li><li>《重构，改善既有代码的设计》</li><li>《修改代码的艺术》</li><li>《测试驱动开发的三项修炼》</li><li>《xUnit Test Patterns》</li><li>mock七宗罪</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'单元','测试','鹅厂'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>