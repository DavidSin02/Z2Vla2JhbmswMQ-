<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java从入门到放弃（6）面向对象 | 极客快訊</title><meta property="og:title" content="Java从入门到放弃（6）面向对象 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/54d17c3b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/54d17c3b.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="Java从入门到放弃（6）面向对象"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/54d17c3b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java从入门到放弃（6）面向对象</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>一、什么是面向对象</strong></p><ol start=1><li>面向对象 将事物高度抽象化的编程模式。将问题分成一个一个的步骤，对每个步骤进行相应的抽象，形成对象。通过不同对象之间的调用，组合解决问题。例如，想造一辆车，上来先把车的各种属性定义出来，然后抽象成一个Car类</li><li>面向过程 自顶向下的编程模式。把问题分成一个一个的步骤，每个步骤用函数实现，依次调用即可，最典型的例子就是实现一个简单的冒泡排序</li><li>二者比较：面向对象占用资源相对高，速度相对慢；面向过程占用资源相对低，速度相对快。</li></ol><p><br></p><p>面向对象的三大特征（封装，继承，多态）</p><ol start=1><li>封装 就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</li><li>继承 是指可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为子类或派生类，被继承的类称为基类、父类或超类。继承的过程。就是从一般到特殊的过程。要实现继承可以通过继承和组合来实现。继承概念的实现方式有两类：实现继承和接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</li><li>多态 指一个类实例的相同方法在不同情形有不同的表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类。他们（那些操作）可以通过相同的方式予以调用。最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构和行为</li></ol><p><br></p><p>五大基本原则（ 你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。）</p><ol start=1><li>单一职责原则 核心思想是：一个类，最好只做一件事，只有一个引起他的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能会引起他变化的原因就越多，这将导致职责依赖，相互之间产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起他变化的原因。</li><li>开放封闭原则 核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。主要体现在两个方面，一是对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适用于新的情况。二是对修改封闭意味着类一旦设计完成，就可以独立的完成其工作，而不要对其进行任何形式的修改。 实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</li><li>里氏替换原则 核心思想是： 子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</li><li>依赖倒置原则 核心思想是： 依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</li><li>接口隔离原则 核心思想是： 使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</li></ol><p><strong>二、平台无关性</strong></p><p>对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。</p><p>对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演着重要角色的有Java语言规范、Class文件、Java虚拟机等。</p><ul><li>Java语言规范</li><ul><li>通过规定Java语言中基本数据类型的取值范围和行为</li></ul><li>Class文件</li><ul><li>所有Java文件要编译成统一的Class文件</li></ul><li>Java虚拟机</li><ul><li>通过Java虚拟机将Class文件转成对应平台的二进制文件等</li></ul></ul><p>Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。</p><p><strong>三、值传递</strong></p><h3 class=pgc-h-arrow-right>实参与形参</h3><p>在Java中定义方法的时候是可以定义参数的。比如Java中的main方法，public static void main(String[] args)，这里面的args就是参数。参数在程序语言中分为形式参数和实际参数。其中， 形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。 实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。</p><p>例如：</p><p>public void hello(String name) { //形式参数为 name</p><p>System.out.println(name);</p><p>}</p><p>public static void main(String[] args) {</p><p>hello("nihao")//实际参数为 nihao</p><p>}</p><p>实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。</p><h3 class=pgc-h-arrow-right>值传递与引用传递</h3><p>值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>引用传递是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p><br></p><p>无论是值传递还是引用传递，其实都是一种求值策略。在求值策略中，还有一种叫做按共享传递。其实Java中的参数传递严格意义上说应该是按共享传递。</p><p><br></p><p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。</p><p><br></p><p>Java中的传递，是值传递，而这个值，实际上是对象的引用。</p><p>基本示例：</p><p>public class MyCode {</p><p>public static void main(String[] args) {</p><p>int a = 10;</p><p>System.out.println("原始"+a);</p><p>change(a);</p><p>System.out.println("变化"+a);</p><p><br></p><p>//对象</p><p>User user = new User();</p><p>user.setId(1);</p><p>user.setName("zhizh");</p><p>user.setPwd("dasjasdh");</p><p>System.out.println("原始"+user);</p><p>System.out.println("原始地址"+user.hashCode());</p><p>chnageObject(user);</p><p>System.out.println("变化"+user);</p><p>System.out.println("变化地址"+user.hashCode());</p><p><br></p><p>}</p><p><br></p><p>private static void chnageObject(User user) {</p><p>user.setId(2);</p><p>user.setName("ceshi");</p><p>user.setPwd("dsadas");</p><p>}</p><p><br></p><p>private static void change(int a) {</p><p>a = a+1;</p><p>}</p><p>}</p><p>结果：</p><p>原始10</p><p>变化10</p><p>原始User{id=1, name='zhizh', pwd='dasjasdh'}</p><p>原始地址460141958</p><p>变化User{id=2, name='ceshi', pwd='dsadas'}</p><p>变化地址460141958</p><p>由示例得出，方法对a的修改并没有改变a本身的值，当传递的参数为对象时，事实上传递的是对象的地址，就表现为地址不变，但是对象的属性值发生了改变</p><p>所以Java的参数传递为值传递</p><p><strong>四、封装、继承、多态</strong></p><p>1.多态 基本概念就是统一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。多态应该是一种运行期的状态。 为了实现运行期的多态，或者说是动态绑定，需要满足三个条件。即有类继承或者接口实现、子类要重写父类的方法、父类的引用指向子类的对象。更合适的解释是： 多态应该是一种运行期特性，Java中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。</p><p>示例：</p><p>public class MyCode2 {</p><p>public static void main(String[] args) {</p><p>Parent son = new Son();</p><p>Parent daughter = new Daughter();</p><p>son.call();</p><p>daughter.call();</p><p>}</p><p>}</p><p>class Parent{</p><p>public void call(){</p><p>System.out.println("我是爸爸");</p><p>}</p><p>}</p><p>class Son extends Parent{</p><p>@Override</p><p>public void call() {</p><p>System.out.println("我是儿子");</p><p>}</p><p>}</p><p>class Daughter extends Parent{</p><p>@Override</p><p>public void call() {</p><p>System.out.println("我是女儿");</p><p>}</p><p>}</p><p><br></p><p>结果：</p><p>我是儿子</p><p>我是女儿</p><p>2.方法重写与重载</p><p>定义：</p><ul><li>重载 简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</li><li>重写 重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</li></ul><p>区别：</p><p>1、重载是一个编译期概念、重写是一个运行期间概念。</p><p>2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</p><p>3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</p><p>4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）</p><p><br></p><p>方法重写的条件：</p><p>1.参数列表必须完全与被重写方法的相同；</p><p>2.返回类型必须完全与被重写方法的返回类型相同；</p><p>3.访问级别的限制性一定不能比被重写方法的强；</p><p>4.访问级别的限制性可以比被重写方法的弱；</p><p>5.重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常；</p><p>6.重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）；</p><p>7.不能重写被标示为final的方法；</p><p>8.如果不能继承一个方法，则不能重写这个方法。</p><p><br></p><p>方法重载的条件：</p><p>1.被重载的方法必须改变参数列表；</p><p>2.被重载的方法可以改变返回类型；</p><p>3.被重载的方法可以改变访问修饰符；</p><p>4.被重载的方法可以声明新的或更广的检查异常；</p><p>5.方法能够在同一个类中或者在一个子类中被重载。</p><p><br></p><p>3.继承</p><p>Java的代码复用技术</p><p>Java代码的复用有继承，组合以及代理三种具体的表现形式。</p><p><br></p><p>继承是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种is-a关系。</p><p><br></p><p>组合体现的是整体与部分、拥有的关系，即has-a的关系。</p><p><br></p><p>4.构造函数</p><p>构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。 构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。 如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -> 0，Integet -> null。</p><p><br></p><p>5.类变量，成员变量，局部变量</p><p>Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p><p><br></p><p>public class MyCode3 {</p><p>//类变量</p><p>private static int a = 1;</p><p>//成员变量</p><p>private int b = 1;</p><p><br></p><p>public void test(){</p><p>int c;//局部变量</p><p>}</p><p>}</p><p><br></p><p>6.作用域</p><h3 class=pgc-h-arrow-right>对于成员变量和方法的作用域，public,protected,private以及不写之间的区别。</h3><ul><li>public :表明该成员变量或者方法是对所有类或者对象都是可见的,所有类或者对象都可以直接访问</li><li>private:表明该成员变量或者方法是私有的,只有当前类对其具有访问权限,除此之外其他类或者对象都没有访问权限.子类也没有访问权限.</li><li>protected:表明成员变量或者方法对类自身,与同在一个包中的其他类可见,其他包下的类不可访问,除非是他的子类</li><li>default:表明该成员变量或者方法只有自己和其位于同一个包的内可见,其他包内的类不能访问,即便是它的子类</li></ul><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','从入','门到'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>