<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文读懂主成分分析 | 极客快訊</title><meta property="og:title" content="一文读懂主成分分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6489dda06d314985b5532505525702cc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/557c7592.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/557c7592.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/557c7592.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/557c7592.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/557c7592.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/557c7592.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/557c7592.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/557c7592.html><meta property="article:published_time" content="2020-11-14T21:05:18+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:18+08:00"><meta name=Keywords content><meta name=description content="一文读懂主成分分析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/557c7592.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文读懂主成分分析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在我的研究生统计理论课上使用的教科书开头，作者（乔治·卡塞拉和罗杰·伯格）在序言中解释了他们为什么选择写教科书：</p><blockquote class=pgc-blockquote-abstract><p>"当有人发现您正在写教科书时，将提出两个问题中的一个或两个。 第一个是"为什么要写书？"，第二个是"您的书与书本有何不同？"第一个问题很容易回答。 您之所以写书是因为您对当今存在的其它教科书不完全满意。"</p></blockquote><p>我在这里运用作者的逻辑。 主成分分析（PCA）是在统计和数据科学领域中需要了解的一种重要技术……但是，当为我的联大学生们上一堂课时，我发现在线资源过于技术化，无法完全满足我们的需求 ，和/或提供有冲突的信息。 可以肯定地说，我对此处的教科书不完全满意。</p><p>因此，我想将PCA的"什么"，"何时"，"如何"和"为什么"放在一起，并链接到一些有助于进一步解释该主题的资源。具体来说，我想介绍这种方法的原理，内在的数学原理，一些最佳实践以及该方法的潜在缺点。</p><p>虽然我想使PCA尽可能容易访问，但是我们将介绍的算法是非常技术性的。 熟悉以下部分或全部内容将使本文和PCA作为一种更易于理解的方法：矩阵运算/线性代数（矩阵乘法，矩阵转置，矩阵逆，矩阵分解，特征向量/特征值）和统计/机器学习（ 标准化，方差，协方差，独立性，线性回归，特征选择）。 我在整篇文章中都嵌入了这些主题的插图的链接，但希望这些链接可以起到提醒作用，而不是阅读本文所必需的阅读内容。</p><h1 class=pgc-h-arrow-right>什么是PCA？</h1><p>假设您要预测2017年美国的国内生产总值（GDP）。您拥有许多可用信息：2017年第一季度的美国GDP，2016年全年的美国GDP， 2015年，依此类推。 您具有任何公开可用的经济指标，例如失业率，通货膨胀率等。 您有2010年的美国人口普查数据估算每个行业的美国人数量，而美国社区调查数据则在每次普查之间都会更新这些估算值。 你知道众议院和参议院有多少成员属于每个政党。 您可以收集股价数据，一年中进行的IPO数量以及有多少CEO似乎正在竞购公职。 尽管要考虑的变量太多，但这只是表面问题。</p><p>TL; DR-您需要考虑很多变量。</p><p>如果您以前使用过很多变量，那么您就会知道这会带来问题。 您了解每个变量之间的关系吗？ 您是否有太多变量，以至于有可能使模型无法适应数据，或者可能违反了使用哪种建模策略的假设？</p><p>您可能会问这样一个问题："如何使用我收集的所有变量，只关注其中的几个？"从技术上讲，您想"减小特征空间的维数。"通过减小在特征空间中维数，要考虑的变量之间的关系较少，并且过拟合的可能性也较小。 （注意：这并不意味着过度拟合等不再是问题，而是我们朝着正确的方向发展！）</p><p>毫不奇怪，减小特征空间的尺寸称为"降维"。有很多方法可以实现降维，但是这些技术大多数都属于两类之一：</p><ul><li>功能消除</li><li>特征提取</li></ul><p>消除特征的功能听起来像是：我们通过消除特征来减少特征空间。 在上面的GDP示例中，我们可能会删除所有变量，而不是考虑所有变量，但我们认为这三个变量可以最好地预测美国的国内生产总值。 特征消除方法的优点包括简单和保持变量的可解释性。</p><p>但不利的是，您无法从删除的变量中获得任何信息。 如果仅使用去年的GDP，根据美国社区调查最新数字得出的制造业就业人口比例以及失业率来预测今年的GDP，那么我们将错过任何可能对模型产生影响的变量。 通过消除特征，我们还完全消除了删除变量所带来的好处。</p><p>但是，特征提取不会遇到此问题。 假设我们有十个独立变量。 在特征提取中，我们创建了十个"新"自变量，其中每个"新"自变量是十个"旧"自变量中每个变量的组合。 但是，我们以特定的方式创建这些新的自变量，并根据它们对我们的因变量的预测程度对这些新变量进行排序。</p><p>您可能会说："降维在哪里起作用？"好吧，我们保留了尽可能多的新自变量，但是我们删除了"最不重要的"。因为我们按新变量的好坏程度对其进行了排序来预测我们的因变量，我们知道哪个变量是最重要和最不重要的。 但是-这就是关键-因为这些新的独立变量是我们旧变量的组合，所以即使删除一个或多个"新"变量，我们仍然保留旧变量中最有价值的部分！</p><p>主成分分析是一种特征提取技术，因此它以特定的方式组合了我们的输入变量，然后我们可以删除"最不重要"的变量，同时仍保留所有变量中最有价值的部分！ 另外一项好处是，PCA之后的每个"新"变量都彼此独立。 这是有好处的，因为线性模型的假设要求我们的自变量彼此独立。 如果我们决定用这些"新"变量拟合线性回归模型（请参见下面的"主要成分回归"），则必须满足此假设。</p><h1 class=pgc-h-arrow-right>我什么时候应该使用PCA？</h1><ul><li>您是否要减少变量的数量，但无法识别变量以将其完全排除在考虑范围之外？</li><li>您是否要确保变量相互独立？</li><li>您是否愿意让自变量难以解释？</li></ul><p>如果您对所有三个问题的回答均为"是"，则PCA是一种很好的使用方法。 如果对问题3回答"否"，则不应使用PCA。</p><h1 class=pgc-h-arrow-right>PCA如何工作？</h1><p>此后的部分讨论了PCA为何起作用，但在进入算法之前提供简短摘要可能对上下文有帮助：</p><p>· 我们将计算一个矩阵，该矩阵总结我们的变量如何相互关联。</p><p>· 然后，我们将该矩阵分解为两个独立的部分：方向和幅度。 然后，我们可以了解数据的"方向"及其"大小"（或每个方向的"重要性"如何）。 以下来自setosa.io小程序的屏幕截图显示了此数据中的两个主要方向："红色方向"和"绿色方向"。在这种情况下，"红色方向"更为重要。 我们稍后将讨论为什么会这样，但是考虑到点的排列方式，您能看到为什么"红色方向"比"绿色方向"看起来更重要吗？（提示：最合适的线适合什么？ 这个数据看起来像什么？）</p><div class=pgc-img><img alt=一文读懂主成分分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6489dda06d314985b5532505525702cc><p class=pgc-img-caption>Our original data in the xy-plane. (Source.)</p></div><p>· 我们将转换原始数据，使其与这些重要方向（原始变量的组合）保持一致。 下面的屏幕截图（同样来自setosa.io）与上面的数据完全相同，但是经过了转换，现在x轴和y轴分别是"红色方向"和"绿色方向"。 像这儿？</p><div class=pgc-img><img alt=一文读懂主成分分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c6811ea7dc014554955e27e4b229fba2><p class=pgc-img-caption>Our original data transformed by PCA. (Source.)</p></div><p>· 尽管此处的可视示例是二维的（因此我们有两个"方向"），但请考虑一下我们的数据具有更大维度的情况。 通过确定哪些"方向"最"重要"，我们可以通过删除"最不重要"的"方向"来将数据压缩或投影到较小的空间。通过将数据投影到较小的空间，我们正在减少 特征空间的维数…但是由于我们已经沿这些不同的"方向"转换了数据，因此我们确保将所有原始变量保留在模型中！</p><p>在这里，我逐步介绍了执行PCA的算法。 我试图避免过于技术化，但是这里不可能忽略细节，因此我的目标是尽可能明确地介绍所有内容。 下一部分将更深入地介绍算法的工作原理。</p><p>开始之前，您应该将表格数据组织为n行，并可能包含p + 1列，其中一列对应于您的因变量（通常表示为Y），p列对应于一个自变量（通常以矩阵表示） X）。</p><ul><li>如果存在Y变量并将其作为数据的一部分，则按照上面的定义将数据分为Y和X（我们将主要使用X。）（注意：如果没有Y的列，那没关系-跳到 下一点！）</li><li>取自变量X的矩阵，对于每列，从每个条目中减去该列的平均值。 （这确保每列的平均值为零。）</li><li>决定是否标准化。 给定X列，具有较高方差的特征是否比具有较低方差的特征更重要，或者特征的重要性与方差无关？ （在这种情况下，重要性表示要素对Y的预测程度。）如果要素的重要性与要素的方差无关，则将列中的每个观察值除以该列的标准差。 （这与步骤2相结合，对X的每一列进行了标准化，以确保每一列具有均值为零和标准偏差1。）将居中（并可能经过标准化）的矩阵称为Z。</li><li>取矩阵Z，对其进行转置，然后将转置后的矩阵乘以Z。</li><li>这可能是最困难的步骤-在这里坚持我。）计算特征向量及其对应的ZᵀZ特征值。 在大多数计算程序包中，这很容易做到—实际上，ZᵀZ的特征分解是将ZᵀZ分解为PDP⁻¹，其中P是特征向量的矩阵，D是对角矩阵，特征值在对角线上，各处均为零 其他。 D对角线上的特征值将与P中的相应列相关联-即D的第一元素为λ₁，而对应的特征向量为P的第一列。这对于D中的所有元素及其中的相应特征向量均成立 P。我们将始终能够以这种方式计算PDP¹。 （奖金：对于感兴趣的人，我们总是可以以这种方式计算PDPsemi¹，因为ZᵀZ是对称的正半定矩阵。）</li><li>取特征值λ1，λ2，...，λp并将其从最大到最小排序。 为此，请对P中的特征向量进行相应排序。 （例如，如果λ2是最大特征值，则取P的第二列并将其放在第一列的位置。）根据计算包的不同，这可以自动完成。 将此特征向量的分类矩阵称为P *。 （P *的列应与P的列相同，但顺序可能不同。）请注意，这些特征向量彼此独立。</li><li>计算Z * = ZP *。 这个新矩阵Z *是X的居中/标准化版本，但是现在每个观察值都是原始变量的组合，其中权重由特征向量确定。 另外，由于P *中的特征向量彼此独立，因此Z *的每一列也彼此独立！</li></ul><div class=pgc-img><img alt=一文读懂主成分分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9920ddc0a7504b5abb32b28162fd4f98><p class=pgc-img-caption></p></div><blockquote class=pgc-blockquote-abstract><p>An example from setosa.io where we transform five data points using PCA. The left graph is our original data X; the right graph would be our transformed data Z*.</p></blockquote><p>注意此图中的两件事：</p><ul><li>这两个图表显示了完全相同的数据，但是右图反映了转换后的原始数据，因此我们的轴现在是主要组成部分。</li><li>在两个图中，主成分彼此垂直。 实际上，每个主成分将始终与其他所有主成分正交（也称为官方数学术语为"正交"）。 （不相信我吗？尝试破坏小程序！）</li></ul><p>因为我们的主成分彼此正交，所以它们在统计上彼此线性独立……这就是为什么我们的Z *列彼此线性独立的原因！</p><p>最后，我们需要确定要保留多少个特征或要删除多少个特征。 有三种常见的方法可以确定这一点，下面将对其进行讨论，然后给出一个明确的示例：</p><ul><li>方法1：我们任意选择要保留的尺寸。 也许我想在二维上直观地表示事物，所以我可能只保留两个特征。 这取决于用例，对于要选择多少功能并没有严格的规定。</li><li>方法2：计算每个要素解释的方差比例（以下简要说明），选择一个阈值，然后添加要素，直到达到该阈值。 （例如，如果要解释模型可能解释的总变异性的80％，请添加具有最大解释变异率的要素，直到解释变异率达到或超过80％。）</li><li>方法3：这与方法2密切相关。计算每个要素的解释方差比例，按解释的方差比例对要素进行排序，并绘制保留更多要素的累计方差比例。 （此图称为碎石图，如下所示。）通过确定添加新特征的点相对于先前特征有明显下降的方差，然后选择直到该点的特征，可以选择要包含的特征数。 。 （我称这种方法为"查找肘部"方法，因为在卵石图中查看"弯曲"或"肘部"可以确定出现最大方差下降的原因。）</li></ul><p>因为每个特征值大致都是其对应特征向量的重要性，所以解释的方差比例是您保留的特征的特征值之和除以所有特征的特征值之和。</p><div class=pgc-img><img alt=一文读懂主成分分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ca2d5b3afdb4407a8c7381293f46159><p class=pgc-img-caption>Scree Plot for Genetic Data. (Source.)</p></div><p>考虑此卵石图用于遗传数据。 （来源：此处。）红线表示每个要素所解释的方差比例，其计算方法是将该主成分的特征值除以所有特征值的总和。 通过仅包括主成分1来解释的方差比例是λ1 /（λ1 +λ2 +…+λp），大约为23％。 仅包括主成分2所解释的变化比例为λ2 /（λ1 +λ2 +…+λp），或约19％。</p><p>通过同时包括主成分1和2来解释的方差比例为（λ1 +λ2）/（λ1 +λ2 +…+λp），大约为42％。 这是黄线出现的地方； 黄线表示累积的方差比例，如果您包括该点之前的所有主要成分，则说明该比例。 例如，PC2上方的黄点表示包括主成分1和2将解释模型中总方差的大约42％。</p><p>现在让我们来看一些示例：</p><ul><li>方法1：我们任意选择要包含的多个主要组件。 假设我想在模型中保留五个主要组成部分。 在上面的遗传数据案例中，这五个主要成分可解释总变异性的约66％，这可通过包括所有13个主要成分来解释。</li><li>方法2：假设我想包括足够的主成分以解释所有13个主成分所解释的总变异性的90％。 在上面的遗传数据案例中，我将包括前10个主要成分，并从Z *中删除最后三个变量。</li><li>方法3：在这里，我们要"查找肘部"。在上面的卵石图中，我们看到在主成分2和主成分3之间解释的可变性比例有很大下降。在这种情况下，我们可能包括 前两个功能并删除其余功能。 如您所见，此方法有点主观，因为"弯头"没有精确的数学定义，在这种情况下，我们将包括一个仅能解释总变异性42％的模型。</li></ul><p>（注意：有些碎石图在Y轴上具有特征向量的大小，而不是方差的比例。这会得出相等的结果，但是需要用户手动计算方差的比例。此处可以看到一个示例。 ）</p><p>删除要删除的转换变量后，就完成了！ 那就是PCA。</p><h1 class=pgc-h-arrow-right>但是，例如，为什么 PCA起作用？</h1><p>虽然PCA是一种技术很强的方法，依赖于深入的线性代数算法，但考虑到它却是一种相对直观的方法。</p><ul><li>首先，协方差矩阵ZᵀZ是一个矩阵，其中包含对Z中每个变量与Z中每个其他变量的关系的估计。了解一个变量与另一个变量如何关联非常有力。</li><li>其次，特征值和特征向量很重要。 特征向量代表方向。 考虑将数据绘制在多维散点图上。 然后，您可以将单个特征向量视为数据散点图中的特定"方向"。 特征值表示幅度或重要性。 特征值越大，方向越重要。</li><li>最后，我们假设特定方向上的更多可变性与解释因变量的行为相关。 大量的可变性通常表示信号，而较小的可变性通常表示噪声。 因此，在特定方向上存在更大的可变性，理论上表明我们想要检测的重要事物。 （setosa.io PCA小程序是处理数据并说服自己为什么有意义的一种好方法。）</li></ul><p>因此，PCA是一种汇集了以下内容的方法：</p><ul><li>衡量每个变量如何相互关联的一种方法。 （协方差矩阵。）</li><li>数据分散的方向。 （特征向量）</li><li>这些不同方向的相对重要性。 （特征值。）</li></ul><p>PCA结合了我们的预测变量，并允许我们丢弃相对不重要的特征向量。</p><h1 class=pgc-h-arrow-right>PCA有扩展吗？</h1><p>是的，在合理的空间范围内，我所能解决的还不止这些。 我最常看到的一个是主成分回归，我们将未转换的Y回归到我们未删除的Z *子集上。 （这是Z *列的独立性出现的地方；通过将Z *上的Y回归，我们知道必须满足自变量所要求的独立性。但是，我们仍然需要检查其他假设。）</p><p>我见过的另一个常见的变体是内核PCA。</p><h1 class=pgc-h-arrow-right>结论</h1><p>希望本文对您有所帮助！ 请查看以下一些资源，以更深入地讨论PCA。 让我知道您的想法，尤其是在有改进建议的情况下。</p><p>我要感谢我的朋友Ritika Bhasker，Joseph Nelson和Corey Smith的建议和修改。 您应该在Medium上检查Ritika和Joseph，他们的职位比我的职位更具娱乐性。 （Corey过于专注于不让他的博士学位研究sc众取宠。）</p><p>我还想给setosa.io小程序以极大的帮助，以直观直观地显示PCA。</p><p>编辑：感谢Michael Matthews在上面的步骤7中注意到Z *公式中的错字。 他正确地指出Z * = ZP ，而不是ZᵀP。 也要感谢Chienlung Cheung在上面的步骤8中注意到另一种错字，并指出我已经将"特征向量"与"特征值"混为一谈。</p><h1 class=pgc-h-arrow-right>参考资源：</h1><p>这是我用来撰写此PCA文章的资源列表，以及我通常认为对理解PCA有用的其他资源。 如果您知道任何可以很好地包含在此列表中的资源，请发表评论，我会添加它们。</p><p><strong>非学术文章和资源</strong></p><ul><li>Setosa.io的PCA小程序。 （一个小程序，使您可以直观地看到主要成分是什么，以及数据如何影响主要成分。）</li><li>对PCA算法和算法本身的构建块的半学术性演练。</li><li>总之，这个StackExchange问题的最佳答案是出色的。</li><li>CrossValidated问答，讨论PCA是否存在参数假设。 （扰流警报：PCA本身是非参数方法，但是使用PCA之后的回归或假设检验可能需要参数假设。）</li><li>没有Wikipedia链接，资源列表很难完成，对吗？ （尽管Wikipedia的目标不大，但它在页面底部具有可靠的其他链接和资源列表。）</li></ul><p><strong>代码资源</strong></p><ul><li>sklearn库中的PCA的Python文档。</li><li>PCA在AnalyticsVidhya上的解释。</li><li>在Python中用一些很酷的方法实现PCA。</li><li>比较在R中实现PCA的方法。</li></ul><p><strong>学术教科书和文章</strong></p><ul><li>James，Witten，Hastie和Tibshirani撰写的第6版《统计学习入门》。 （在第6.3、6.7和10.2章中对PCA进行了广泛的介绍，这本书假定读者具有线性回归的知识，但考虑到所有因素，它很容易理解。）</li><li>宾夕法尼亚州立大学STAT 505（应用的多元统计分析）课程的注释。 （我发现宾州州立大学的在线统计课程说明令人难以置信，这里的" PCA"部分特别有用。）</li><li>线性代数及其应用，第四版，David Lay着。 （第7.5章介绍了PCA。）</li><li>Google Research的Jonathon Shlens撰写的主成分分析教程。</li><li>卡内基梅隆大学的Cosma Shalizi撰写了有关主成分分析的章节草案。</li><li>应用预测模型中有关数据预处理的一章在第3.3节中介绍了主成分分析（带视觉效果！）。 （向杰伊·卢卡斯推荐）！</li><li>《统计学习的要素》，第10版，由Hastie，Tibshirani和Friedman撰写。 （PCA在第3.5、14.5和18.6章中进行了广泛介绍。该书假设线性回归，矩阵代数和微积分的知识，并且比《统计学习入门》具有更多的技术性，但是鉴于共同作者，二者遵循相似的结构 ）</li></ul><p><strong>切向资源</strong></p><ul><li>线性代数YouTube系列的精髓（包括一个与特征向量和特征值有关的视频，该视频与PCA尤其相关；与tim Book在一起，以使我意识到这一不可思议的资源。）</li></ul><p><br></p><p>(本文翻译自Matt Brems的文章《A One-Stop Shop for Principal Component Analysis》，参考：https://towardsdatascience.com/a-one-stop-shop-for-principal-component-analysis-5582fb7e0a9c)</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'懂主','一文','成分'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>