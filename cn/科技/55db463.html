<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入了解一些Android动画 | 极客快訊</title><meta property="og:title" content="深入了解一些Android动画 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ee4f15e064504e11869881b7ee7dbd0d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55db463.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/55db463.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/55db463.html><meta property="article:published_time" content="2020-10-29T20:50:38+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:38+08:00"><meta name=Keywords content><meta name=description content="深入了解一些Android动画"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/55db463.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入了解一些Android动画</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、PropertyValuesHolder</h1><p>阅读本文需要上一本Android属性动画的基础，这样才可以明白接下来要讲什么。</p><h2 class=pgc-h-arrow-right>1.理解和使用</h2><p>PropertyValuesHolder 是ObjectAnimation类似的一个方法，只是少了一个target，就是要执行的控件。看看正常的使用方法：会同时执行全部的Holder</p><pre><code>public void  doPropertyValuesHolder(){        //定义一个旋转Holder        PropertyValuesHolder rotationHolder=                PropertyValuesHolder.ofFloat(                        "rotation",                        60f,40f,100f,-60f,40f,88f,77f);        //定义一个透明Holder        PropertyValuesHolder alphaHolder=                PropertyValuesHolder.ofFloat(                        "alpha",                        0.01f,0.5f,1.0f,0.8f,0.2f,0.0f);        //加载进ObjectAnimator        ObjectAnimator objectAnimator=ObjectAnimator.ofPropertyValuesHolder(ballImageView,rotationHolder,alphaHolder);        objectAnimator.setDuration(3000);        objectAnimator.start();    }</code></pre><h2 class=pgc-h-arrow-right>2.方法和参数</h2><p>可以看看这个方法的参数：</p><pre><code>ObjectAnimator ofPropertyValuesHolder(Object target,PropertyValuesHolder... values)</code></pre><pre><code>PropertyValuesHolder ofFloat(String propertyName, float... values)</code></pre><p>Object target 是要显示动画的控件</p><p>PropertyValuesHolder... values 装载多个PropertyValuesHolder</p><p>String propertyName 代表要反射的参数，跟ObjectAnimation的参数是一样的</p><p>float... values 代表是可变长参数 这样的方法还有以下图片这些：</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee4f15e064504e11869881b7ee7dbd0d><p class=pgc-img-caption></p></div><p>其中ofObject()方法 ，也是跟ObjectAnimation的相似，也是要自定义TypeEvaluator。</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c20d7deef644470a8e143dd181aceb86><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>二、Keyframe</h1><h2 class=pgc-h-arrow-right>1.理解和使用</h2><p>看名字，就是理解为关键帧的意思，在动画中，在某帧做一些操作，从而实现对比效果比较明显的效果。 关键帧表示是某个物体在哪个时间点应该在哪个位置上。 具体使用：</p><pre><code> public void  doPropertyValuesHolderKeyFrame(){        //头keyframe1，从进度0.6开始，在进度60%的时候，数值是0.1f        Keyframe keyframe1=Keyframe.ofFloat(0.6f,0.1f);        //中间keyframe2        Keyframe keyframe2=Keyframe.ofFloat(0.1f,0.8f);        //尾部keyframe3，以50%进度作为结束，这时候的数值为0.2f        Keyframe keyframe3=Keyframe.ofFloat(0.5f,0.2f);        //装载到Holder中，并设置要反射的方法，这是反射的是setAlpha()方法，控制透明度        PropertyValuesHolder alphaHolder=PropertyValuesHolder.ofKeyframe("alpha",keyframe1,keyframe2,keyframe3);        //把装载到Holder中装载到ObjectAnimator或者ValueAnimation        ObjectAnimator objectAnimator=ObjectAnimator.ofPropertyValuesHolder(ballImageView,alphaHolder);        objectAnimator.setDuration(3000);        objectAnimator.start();    }</code></pre><h2 class=pgc-h-arrow-right>2.方法和参数</h2><pre><code>Keyframe ofFloat(float fraction, float value)</code></pre><p>float fraction 表示进度</p><p>float value 表示在这个进度下的数值</p><pre><code> PropertyValuesHolder ofKeyframe(String propertyName, Keyframe... values)</code></pre><p>String propertyName 要反射的set方法</p><p>Keyframe... values 传入Keyframe</p><p>Keyframe的方法，也是和其他的类似的。</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a376cc480be040d29b655e1d4071d467><p class=pgc-img-caption></p></div><p>Keyframe的set方法，设置进度，插值器，数值。 没有设置插值器的时候，默认是线性插值器</p><pre><code> keyframe1.setInterpolator(new LinearInterpolator()); //默认线性插值器</code></pre><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fbb2b7bfe53e4c13a2d95d25f1d731d6><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>3.帧的操作</h2><p>直接写结论：</p><ul><li>如果去掉0帧，则以第一个关键帧为起始位置</li><li>如果去掉结束帧（进度为1），则以最后一个关键帧为结束位置</li><li>使用keyframe来构建动画，至少需要2帧</li></ul><h1 class=pgc-h-arrow-right>三、ViewPropertyAnimator</h1><h2 class=pgc-h-arrow-right>1.理解和使用</h2><p>可以通过串行的形式，快速定义动画，省去一些定义，在每次界面绘制的时候，启动动画，比其他的更节省消耗。 比如：</p><pre><code> ballImageView.animate().alpha(0.5f).rotation(360f).scaleX(1.5f).translationX(100f);</code></pre><h2 class=pgc-h-arrow-right>2.参数和方法</h2><p>可以看到这些方法的返回值，基本都是ViewPropertyAnimator</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/33e72dc69af4456daf9d5ae696ba8931><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9c20521105694cf6bcc01577ec0a3091><p class=pgc-img-caption></p></div><p>再引用一张表格：</p><p>函数 含义 alpha(float value) 设置透明度 scaleY(float value) 设置 Y轴方向的缩放大小 scaleX(float value) 设置X轴方向的缩放大小 translationY(float value) 设置Y轴方向的移动值 translationX(float value) 设置X轴方向的移动值 rotation(float value) 设置绕Z轴旋转度数 rotationX(float value) 设置绕x轴旋转度数 rotationY(float value) 设置绕 Y 轴旋转度数 x(float value) 相对于父容器的左上角座标在 X轴方向的最终位置 y(float value) 相对于父容器的左上角座标在Y轴方向的最终位置 alphaBy(float value) 设置透明度增量 rotationBy(float value) 设置绕Z轴旋转增量 rotationXBy(float value) 设置绕 X 油旋转增量 rotationYBy(float value) 设置统Y轴旋转增量 translationXBy(float value) 设置X轴方向的移动值增量 translationYBy(float value) 设置Y轴方向的移动值增量 scaleXBy(float value) 设置X轴方向的缩放大小增量 scaleYBy(float value) 设置 Y轴方向的缩放大小增量 xBy(float value) 相对于父容器的左上角座标在 X轴方向的位置增量 yBy(float value) 相对于父容器的左上角座标在 Y轴方向的位置增量 setlnterpolator(Timelnterpolator interpolator) 设置插值器 setStartDelay(long startDelay) 设置开始延时 setDuration(long duration) 设置动画时长</p><h1 class=pgc-h-arrow-right>四、animateLayoutChanges</h1><p>android:animateLayoutChanges="true" 在Layout加入控件，或者移除控件的时候，添加动画，但是只能使用默认动画。</p><pre><code> &lt;LinearLayout            android:animateLayoutChanges="true"            android:layout_width="match_parent"            android:layout_height="match_parent"            android:orientation="vertical"/&gt;</code></pre><h1 class=pgc-h-arrow-right>五、LayoutTransition</h1><p>LayoutTransition可以控制ViewGroup的动画，可以使用自定义的动画。 具体使用：</p><pre><code> public void doLayoutTransition(){        LinearLayout linearLayout=new LinearLayout(this);        //1.创建实例        LayoutTransition transition=new LayoutTransition();        //2.创建动画        ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(null,"rotation",0f,90f,0f);        //3.动画出现形式进行设置        transition.setAnimator(LayoutTransition.DISAPPEARING,objectAnimator);        //4.将LayoutTransition设置到ViewGroup中        linearLayout.setLayoutTransition(transition);          //5.开源动画库 NineOldAndroids    }</code></pre><p>setAnimator(int transitionType, Animator animator)</p><p>这个方法中，transitionType有五个选项</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/376a1c51788048f99470d2f1c2801260><p class=pgc-img-caption></p></div><p>CHANGE_APPEARING 由于容器中要显示一个新的元素，其他需要变化的元素所应用的动画（问题多，不常用）</p><p>_CHANGE_DISAPPEARING_ 当个容器中某个元素要消失时，其他需要变化的元素所应用的动画（问题多，不常用）</p><p>_CHANGING_ 容器中正在更改的元素的动画变化</p><p>_APPEARING_ 元素在容器中出现时所定义的动画</p><p>_DISAPPEARING_ 元素在容器中消失时所定义的动画</p><h1 class=pgc-h-arrow-right>六、PathMeasure</h1><p>PathMeasure类似一个计算器，可以计算出目标path的座标，长度等</p><h2 class=pgc-h-arrow-right>1.初始化</h2><pre><code>  public void doPathMeasure(){        Path path=new Path();        //初始化方法1        PathMeasure pathMeasure1=new PathMeasure();        pathMeasure1.setPath(path,true);        //初始化方法2        PathMeasure pathMeasure2=new PathMeasure(path,false);    }</code></pre><p>setPath(Path path, boolean forceClosed) path 就是代表要计算的目标Path。 forceClosed 是否闭合，true会计算闭合状态下的Path，false会按照Path原来情况来计算。</p><h2 class=pgc-h-arrow-right>2.函数调用</h2><p>自定义一个view</p><pre><code>public class PathView extends View {    Path mPath;    Paint mPaint;    PathMeasure mPathMeasure;    public PathView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        mPath=new Path();        mPaint=new Paint();        mPathMeasure=new PathMeasure();    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        canvas.translate(250,250); //画布移动        mPaint.setColor(Color.BLUE); //画笔颜色        mPaint.setStrokeWidth(5); //画笔粗细        mPaint.setStyle(Paint.Style.STROKE); //画笔风格        mPath.moveTo(0,0);        mPath.lineTo(0,100);        mPath.lineTo(100,100);        mPath.lineTo(100,0);        mPathMeasure.setPath(mPath,true);        Log.v("showLog",                "getLength()=="+mPathMeasure.getLength()                        +"  isClosed()=="+ mPathMeasure.isClosed()); //结果400.0  true        mPathMeasure.setPath(mPath,false);        Log.v("showLog",                "getLength()=="+mPathMeasure.getLength()                        +"  isClosed()=="+ mPathMeasure.isClosed()); //结果300.0  false        canvas.drawPath(mPath,mPaint); //绘制路径    }}</code></pre><p>绘制效果：</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cdb95babbae8487ca5b6ebaa22dd5983><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.1 PathMeasure.getLength()</h3><p>PathMeasure.getLength() 函数用于测量路径的长度</p><h3 class=pgc-h-arrow-right>2.2 PathMeasure.isClosed()</h3><p>PathMeasure.isClosed() 函数用于返回是否测量闭合状态</p><h3 class=pgc-h-arrow-right>2.3 PathMeasure.nextContour()</h3><pre><code>           mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);        canvas.drawPath(mPath, mPaint);        mPath.addRect(-100, -100, 100, 100, Path.Direction.CW);        canvas.drawPath(mPath, mPaint);        mPath.addRect(-120, -120, 120, 120, Path.Direction.CW);        canvas.drawPath(mPath, mPaint);        mPathMeasure.setPath(mPath, false);        do {            float len = mPathMeasure.getLength();            Log.v("showLog", "len=" + len);        } while (mPathMeasure.nextContour());</code></pre><p>效果：</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fd3d920653774afbbfd834f878cb2857><p class=pgc-img-caption></p></div><p>打印结果：</p><pre><code>len=400.0len=800.0len=960.0</code></pre><p>PathMeasure.nextContour()得到的顺序与添加的Path的顺序相同</p><p>PathMeasure.getLength()只是得到当前path的长度，不是全部的长度</p><h3 class=pgc-h-arrow-right>2.3 getSegment()</h3><p>使用getSegment函数需要禁用硬件加速 在构造方法中加入 setLayerType(LAYER_TYPE_SOFTWARE,null);</p><pre><code>         mPath.addRect(-50, -50, 50, 50, Path.Direction.CW);        mPathMeasure.setPath(mPath,false); //计算的path        mPathMeasure.getSegment(0,150,mDstPath,true); //截取并添加到mDstPath，是添加，不是其他        canvas.drawPath(mPath, mPaint); //绘制原来的path        canvas.translate(200,0); //画布移动        mPaint.setColor(Color.RED);        canvas.drawPath(mDstPath, mPaint); //绘制添加后的mDstPath</code></pre><pre><code> boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</code></pre><p>startDpath开始截取的点，截取的起始点，是以左上角的点开始的</p><p>stopD截取停止的点</p><p>dst截取后添加到的path</p><p>startWithMoveTo是否保存原状，true保存原样，false则会连接初始点和终点，和原来的不一定相同形状 以上代码的效果: 截图的方向，与原来的path的生成方向有关</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/852d4797db5c4b068f32a4f353728fdd><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.4 动态画圆的例子</h3><p>代码：</p><pre><code>public class PathView extends View {    Path mPath, mDstPath;    Paint mPaint;    PathMeasure mPathMeasure;    float mCurAnimValue;    public PathView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        setLayerType(LAYER_TYPE_SOFTWARE, null);        mPath = new Path();        mDstPath = new Path();        mPaint = new Paint();        mPathMeasure = new PathMeasure();        mPaint.setColor(Color.BLUE); //画笔颜色        mPaint.setStrokeWidth(5); //画笔粗细        mPaint.setStyle(Paint.Style.STROKE); //画笔风格        mPath.addCircle(100, 100, 50, Path.Direction.CW); //一个完整的圆        mPathMeasure.setPath(mPath, true); //要计算的path        ValueAnimator animator = ValueAnimator.ofFloat(0, 1); //进度 0~1        animator.setRepeatCount(ValueAnimator.INFINITE); //无限循环        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                mCurAnimValue = (Float) animation.getAnimatedValue(); //得到当前的进度                invalidate();//重绘，重新执行onDraw()方法            }        });        animator.setDuration(5000);        animator.start();    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        canvas.translate(100, 100); //画布移动        float stop=mPathMeasure.getLength()*mCurAnimValue; //一个进度确定一个截取点        mDstPath.reset();        mPathMeasure.getSegment(0,stop,mDstPath,true); //一点点添加        canvas.drawPath(mDstPath,mPaint); //每次有进度更新，就绘制一小段截取    }}</code></pre><p>效果：</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/91192788a7424bd79bb6e3985019444a><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.5 getPosTan()</h3><p>先看看函数的定义：</p><pre><code>boolean getPosTan(float distance, float pos[], float tan[]) </code></pre><p>float distance 距离path的其实长度</p><p>float pos[] 该点的座标值。x和y pos[0]=x，pos[1]=y</p><p>float tan[] 该点的正切值。x和y pos[0]=x，pos[1]=y tan&lt;a=y/x</p><h3 class=pgc-h-arrow-right>2.6 箭头画圆的例子</h3><p>代码：</p><pre><code>public class PathView extends View {    Path mPath, mDstPath;    Paint mPaint;    PathMeasure mPathMeasure;    float mCurAnimValue;    Bitmap mArrowBmp;    float[] mPos;    float[] mTan;    int mCenterX,mCenterY;    float mRadius;    public PathView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        setLayerType(LAYER_TYPE_SOFTWARE, null);        mPath = new Path();        mDstPath = new Path();        mPaint = new Paint();        mPathMeasure = new PathMeasure();        mPos=new float[2];        mTan=new float[2];        //加载箭头图片        mArrowBmp= BitmapFactory.decodeResource(getResources(), R.drawable.arrow);        mPaint.setColor(Color.BLUE); //画笔颜色        mPaint.setStrokeWidth(5); //画笔粗细        mPaint.setStyle(Paint.Style.STROKE); //画笔风格        mPath.addCircle(540, 972, 486, Path.Direction.CW); //一个完整的圆        mPathMeasure.setPath(mPath, true); //要计算的path        ValueAnimator animator = ValueAnimator.ofFloat(0, 1); //进度 0~1        animator.setRepeatCount(ValueAnimator.INFINITE); //无限循环        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                mCurAnimValue = (Float) animation.getAnimatedValue(); //得到当前的进度                invalidate();//重绘，重新执行onDraw()方法            }        });        animator.setDuration(5000);        animator.start();    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        /*         * 得到h,w的最小的那个值;         * &gt;&gt; 1 移位 跟 /2 相同;         * 乘以0.9f,表示占布局的90%         * */        mRadius = (Math.min(h, w) &gt;&gt; 1) * 0.9f;        // 中心座标        mCenterX = w / 2;        mCenterY = h / 2;        Log.v("showLog",mCenterX+"  "+mCenterY+"  "+mRadius);        postInvalidate();        super.onSizeChanged(w, h, oldw, oldh);    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        float stop=mPathMeasure.getLength()*mCurAnimValue; //一个进度确定一个截取点        mDstPath.reset();        mPathMeasure.getSegment(0,stop,mDstPath,true); //一点点添加        canvas.drawPath(mDstPath,mPaint); //每次有进度更新，就绘制一小段截取        mPathMeasure.getPosTan(stop,mPos,mTan); //获得每点的正切值和座标        /**         *    Math.atan2(mTan[1],mTan[0])获得tan的弧度值         *    *180.0/Math.PI将转化为角度值         * */        float degrees=(float)(Math.atan2(mTan[1],mTan[0])*180.0/Math.PI);        Matrix matrix=new Matrix();        /**         * 将图片围绕中心点旋转指定角度         * postRotate(float degrees, float px, float py)         * degrees是角度  （px,py）是图片中心点         * */        matrix.postRotate(degrees,mArrowBmp.getWidth()/2,mArrowBmp.getHeight()/2);        /**         * 将图片从默认的（0，0）点移动到路径的最前端         * */        matrix.postTranslate(mPos[0]-mArrowBmp.getWidth()/2,mPos[1]-mArrowBmp.getHeight()/2);        //绘制图片        canvas.drawBitmap(mArrowBmp,matrix,mPaint);    }}</code></pre><p>效果：</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5504f7ffdf344e98b5ba748f9cc7eed3><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>2.7 getMatrix()</h3><p>参数类型：</p><pre><code>boolean getMatrix(float distance, Matrix matrix, int flags)</code></pre><p>使用方法：</p><pre><code>          //计算方位角        Matrix matrix = new Matrix();        //获取位置信息        mPathMeasure.getMatrix(stop,matrix,PathMeasure.POSITION_MATRIX_FLAG);        //获取切边信息        mPathMeasure.getMatrix(stop,matrix,PathMeasure.TANGENT_MATRIX_FLAG); </code></pre><h3 class=pgc-h-arrow-right>2.8 支付成功例子</h3><pre><code>public class TickView extends View {    Path mPath, mDstPath;    Paint mPaint;    PathMeasure mPathMeasure;    float mCurAnimValue;    int mCenterX, mCenterY;    float mRadius;    public TickView(Context context, @Nullable AttributeSet attrs) {        super(context, attrs);        setLayerType(LAYER_TYPE_SOFTWARE, null);        mPath = new Path();        mDstPath = new Path();        mPaint = new Paint();        mPathMeasure = new PathMeasure();        mPaint.setColor(Color.BLUE); //画笔颜色        mPaint.setStrokeWidth(5); //画笔粗细        mPaint.setStyle(Paint.Style.STROKE); //画笔风格        mCenterX = 540;        mCenterY = 972;        mRadius = 486 / 2;        /**         * 圆         * */        mPath.addCircle(mCenterX, mCenterY, mRadius, Path.Direction.CW);        /**         * 对勾         * */        mPath.moveTo(mCenterX - mRadius / 2, mCenterY);        mPath.lineTo(mCenterX, mCenterY + mRadius / 2);        mPath.lineTo(mCenterX + mRadius / 2, mCenterY - mRadius / 3);        mPathMeasure.setPath(mPath, false); //要计算的path        ValueAnimator animator = ValueAnimator.ofFloat(0, 2); //进度 0~1 是圆，1~2是对勾        animator.setRepeatCount(ValueAnimator.RESTART);        animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {            @Override            public void onAnimationUpdate(ValueAnimator animation) {                mCurAnimValue = (Float) animation.getAnimatedValue(); //得到当前的进度                invalidate();//重绘，重新执行onDraw()方法            }        });        animator.setDuration(5000);        animator.start();    }    @Override    protected void onSizeChanged(int w, int h, int oldw, int oldh) {        /*         * 得到h,w的最小的那个值;         * &gt;&gt; 1 移位 跟 /2 相同;         * 乘以0.9f,表示占布局的90%         * */        mRadius = (Math.min(h, w) &gt;&gt; 1) * 0.9f;        // 中心座标        mCenterX = w / 2;        mCenterY = h / 2;        Log.v("showLog", mCenterX + "  " + mCenterY + "  " + mRadius);        postInvalidate();        super.onSizeChanged(w, h, oldw, oldh);    }    @Override    protected void onDraw(Canvas canvas) {        super.onDraw(canvas);        if (mCurAnimValue &lt; 1) {            float stop = mPathMeasure.getLength() * mCurAnimValue;            mPathMeasure.getSegment(0, stop, mDstPath, true);        } else if (mCurAnimValue == 1) {            mPathMeasure.getSegment(0, mPathMeasure.getLength(), mDstPath, true);            mPathMeasure.nextContour();        } else {            float stop = mPathMeasure.getLength() * (mCurAnimValue - 1);            mPathMeasure.getSegment(0, stop, mDstPath, true);        }        canvas.drawPath(mDstPath, mPaint);    }}</code></pre><p>效果：</p><div class=pgc-img><img alt=深入了解一些Android动画 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/930b90db257c42069501f2e75f43e805><p class=pgc-img-caption></p></div><p>编程中我们会遇到多少挫折？表放弃，沙漠尽头必是绿洲。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'了解','Android','动画'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>