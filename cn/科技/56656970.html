<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>老大吩咐的可重入分布式锁，终于完美的实现了 | 极客快訊</title><meta property="og:title" content="老大吩咐的可重入分布式锁，终于完美的实现了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c6023f6931ac4b409b0fa5ed962428a0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56656970.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56656970.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56656970.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="老大吩咐的可重入分布式锁，终于完美的实现了"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/56656970.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>老大吩咐的可重入分布式锁，终于完美的实现了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>重做永远比改造简单</p><p>最近在做一个项目，将一个其他公司的实现系统（下文称作旧系统），完整的整合到自己公司的系统（下文称作新系统）中，这其中需要将对方实现的功能完整在自己系统也实现一遍。</p><p>旧系统还有一批存量商户，为了不影响存量商户的体验，新系统提供的对外接口，还必须得跟以前一致。最后系统完整切换之后，功能只运行在新系统中，这就要求旧系统的数据还需要完整的迁移到新系统中。</p><p>当然这些在做这个项目之前就有预期，想过这个过程很难，但是没想到有那么难。原本感觉排期大半年，时间还是挺宽裕，现在感觉就是大坑，还不得不在坑里一点点去填。</p><div class=pgc-img><img alt=老大吩咐的可重入分布式锁，终于完美的实现了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6023f6931ac4b409b0fa5ed962428a0><p class=pgc-img-caption></p></div><p>哎，说多都是泪，不吐槽了，等到下次做完再给大家覆盘下真正心得体会。</p><p>回到正文，上篇文章<strong>Redis 分布式锁</strong>，咱们基于 Redis 实现一个分布式锁。这个分布式锁基本功能没什么问题，但是缺少可重入的特性，所以这篇文章小黑哥就带大家来实现一下可重入的分布式锁。</p><p>本篇文章将会涉及以下内容：</p><ul><li>可重入</li><li>基于 ThreadLocal 实现方案</li><li>基于 Redis Hash 实现方案</li></ul><h2 class=pgc-h-arrow-right>可重入</h2><p>说到可重入锁，首先我们来看看一段来自 <strong>wiki</strong> 上可重入的解释：</p><blockquote><p>“</p><p>若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为<strong>可重入</strong>（reentrant或re-entrant）的。即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果。与多线程并发执行的线程安全不同，可重入强调对单个线程执行时重新进入同一个子程序仍然是安全的。</p></blockquote><p>当一个线程执行一段代码成功获取锁之后，继续执行时，又遇到加锁的代码，可重入性就就保证线程能继续执行，而不可重入就是需要等待锁释放之后，再次获取锁成功，才能继续往下执行。</p><p>用一段 Java 代码解释可重入：</p><pre><code>public synchronized void a() {    b();}public synchronized void b() {    // pass}</code></pre><p>假设 X 线程在 a 方法获取锁之后，继续执行 b 方法，如果此时<strong>不可重入</strong>，线程就必须等待锁释放，再次争抢锁。</p><p>锁明明是被 X 线程拥有，却还需要等待自己释放锁，然后再去抢锁，这看起来就很奇怪，我释放我自己~</p><div class=pgc-img><img alt=老大吩咐的可重入分布式锁，终于完美的实现了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/978d3c7e06f44f84824be000d01abbc5><p class=pgc-img-caption></p></div><p>我打我自己</p><p>可重入性就可以解决这个尴尬的问题，当线程拥有锁之后，往后再遇到加锁方法，直接将加锁次数加 1，然后再执行方法逻辑。退出加锁方法之后，加锁次数再减 1，当加锁次数为 0 时，锁才被真正的释放。</p><p>可以看到可重入锁最大特性就是计数，计算加锁的次数。所以当可重入锁需要在分布式环境实现时，我们也就需要统计加锁次数。</p><p>分布式可重入锁实现方式有两种：</p><ul><li>基于 ThreadLocal 实现方案</li><li>基于 Redis Hash 实现方案</li></ul><p>首先我们看下基于 ThreadLocal 实现方案。</p><h2 class=pgc-h-arrow-right>基于 ThreadLocal 实现方案</h2><h3 class=pgc-h-arrow-right>实现方式</h3><p>Java 中 ThreadLocal可以使每个线程拥有自己的实例副本，我们可以利用这个特性对线程重入次数进行技术。</p><p>下面我们定义一个ThreadLocal的全局变量 LOCKS，内存存储 Map 实例变量。</p><pre><code>private static ThreadLocal&lt;Map&lt;String, Integer&gt;&gt; LOCKS = ThreadLocal.withInitial(HashMap::new);</code></pre><p>每个线程都可以通过 ThreadLocal获取自己的 Map实例，Map 中 key 存储锁的名称，而 value存储锁的重入次数。</p><p><strong>加锁的代码如下：</strong></p><pre><code>/** * 可重入锁 * * @param lockName  锁名字,代表需要争临界资源 * @param request   唯一标识，可以使用 uuid，根据该值判断是否可以重入 * @param leaseTime 锁释放时间 * @param unit      锁释放时间单位 * @return */public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {    Map&lt;String, Integer&gt; counts = LOCKS.get();    if (counts.containsKey(lockName)) {        counts.put(lockName, counts.get(lockName) + 1);        return true;    } else {        if (redisLock.tryLock(lockName, request, leaseTime, unit)) {            counts.put(lockName, 1);            return true;        }    }    return false;}</code></pre><blockquote><p>“</p><p>ps: redisLock#tryLock 为上一篇文章实现的分布锁。</p><p>由于公号外链无法直接跳转，关注『<strong>程序通事</strong>』，回复<strong>分布式锁</strong>获取源代码。</p></blockquote><p>加锁方法首先判断当前线程是否已经已经拥有该锁，若已经拥有，直接对锁的重入次数加 1。</p><p>若还没拥有该锁，则尝试去 <strong>Redis</strong> 加锁，加锁成功之后，再对重入次数加 1 。</p><p><strong>释放锁的代码如下：</strong></p><pre><code>/** * 解锁需要判断不同线程池 * * @param lockName * @param request */public void unlock(String lockName, String request) {    Map&lt;String, Integer&gt; counts = LOCKS.get();    if (counts.getOrDefault(lockName, 0) &lt;= 1) {        counts.remove(lockName);        Boolean result = redisLock.unlock(lockName, request);        if (!result) {            throw new IllegalMonitorStateException("attempt to unlock lock, not locked by lockName:+" + lockName + " with request: "                    + request);        }    } else {        counts.put(lockName, counts.get(lockName) - 1);    }}</code></pre><p>释放锁的时首先判断重入次数，若大于 1，则代表该锁是被该线程拥有，所以直接将锁重入次数减 1 即可。</p><p>若当前可重入次数小于等于 1，首先移除 Map中锁对应的 key，然后再到 Redis 释放锁。</p><p>这里需要注意的是，当锁未被该线程拥有，直接解锁，可重入次数也是小于等于 1 ，这次可能无法直接解锁成功。</p><blockquote><p>“</p><p>ThreadLocal 使用过程要记得及时清理内部存储实例变量，防止发生内存泄漏，上下文数据串用等问题。</p><p>下次咱来聊聊最近使用 ThreadLocal 写的 Bug。</p></blockquote><h3 class=pgc-h-arrow-right>相关问题</h3><p>使用 ThreadLocal 这种本地记录重入次数，虽然真的简单高效，但是也存在一些问题。</p><p><strong>过期时间问题</strong></p><p>上述加锁的代码可以看到，重入加锁时，仅仅对本地计数加 1 而已。这样可能就会导致一种情况，由于业务执行过长，Redis 已经过期释放锁。</p><p>而再次重入加锁时，由于本地还存在数据，认为锁还在被持有，这就不符合实际情况。</p><p>如果要在本地增加过期时间，还需要考虑本地与 Redis 过期时间一致性的，代码就会变得很复杂。</p><p><strong>不同线程/进程可重入问题</strong></p><p>狭义上可重入性应该只是对于<strong>同一线程</strong>的可重入，但是实际业务可能需要不同的应用线程之间可以重入同把锁。</p><p>而 ThreadLocal的方案仅仅只能满足同一线程重入，无法解决不同线程/进程之间重入问题。</p><p>不同线程/进程重入问题就需要使用下述方案 Redis Hash 方案解决。</p><h2 class=pgc-h-arrow-right>基于 Redis Hash 可重入锁</h2><h3 class=pgc-h-arrow-right>实现方式</h3><p>ThreadLocal 的方案中我们使用了 Map 记载锁的可重入次数，而 Redis 也同样提供了 Hash （哈希表）这种可以存储键值对数据结构。所以我们可以使用 Redis Hash 存储的锁的重入次数，然后利用 lua 脚本判断逻辑。</p><p>加锁的 lua 脚本如下：</p><pre><code>---- 1 代表 true---- 0 代表 falseif (redis.call('exists', KEYS[1]) == 0) then    redis.call('hincrby', KEYS[1], ARGV[2], 1);    redis.call('pexpire', KEYS[1], ARGV[1]);    return 1;end ;if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then    redis.call('hincrby', KEYS[1], ARGV[2], 1);    redis.call('pexpire', KEYS[1], ARGV[1]);    return 1;end ;return 0;</code></pre><blockquote><p>“</p><p>如果 KEYS:[lock],ARGV[1000,uuid]</p></blockquote><p>不熟悉 lua 语言同学也不要怕，上述逻辑还是比较简单的。</p><p>加锁代码首先使用 Redis exists 命令判断当前 lock 这个锁是否存在。</p><p>如果锁不存在的话，直接使用 hincrby创建一个键为 lock hash 表，并且为 Hash 表中键为 uuid 初始化为 0，然后再次加 1，最后再设置过期时间。</p><p>如果当前锁存在，则使用 hexists判断当前 lock 对应的 hash 表中是否存在 uuid 这个键，如果存在,再次使用 hincrby 加 1，最后再次设置过期时间。</p><p>最后如果上述两个逻辑都不符合，直接返回。</p><p>加锁代码如下:</p><pre><code>// 初始化代码String lockLuaScript = IOUtils.toString(ResourceUtils.getURL("classpath:lock.lua").openStream(), Charsets.UTF_8);lockScript = new DefaultRedisScript&lt;&gt;(lockLuaScript, Boolean.class);/** * 可重入锁 * * @param lockName  锁名字,代表需要争临界资源 * @param request   唯一标识，可以使用 uuid，根据该值判断是否可以重入 * @param leaseTime 锁释放时间 * @param unit      锁释放时间单位 * @return */public Boolean tryLock(String lockName, String request, long leaseTime, TimeUnit unit) {    long internalLockLeaseTime = unit.toMillis(leaseTime);    return stringRedisTemplate.execute(lockScript, Lists.newArrayList(lockName), String.valueOf(internalLockLeaseTime), request);}</code></pre><blockquote><p>“</p><p>Spring-Boot 2.2.7.RELEASE</p></blockquote><p>只要搞懂 Lua 脚本加锁逻辑，Java 代码实现还是挺简单的，直接使用 SpringBoot 提供的 StringRedisTemplate 即可。</p><p>解锁的 Lua 脚本如下：</p><pre><code>-- 判断 hash set 可重入 key 的值是否等于 0-- 如果为 0 代表 该可重入 key 不存在if (redis.call('hexists', KEYS[1], ARGV[1]) == 0) then    return nil;end ;-- 计算当前可重入次数local counter = redis.call('hincrby', KEYS[1], ARGV[1], -1);-- 小于等于 0 代表可以解锁if (counter &gt; 0) then    return 0;else    redis.call('del', KEYS[1]);    return 1;end ;return nil;</code></pre><p>首先使用 hexists 判断 Redis Hash 表是否存给定的域。</p><p>如果 lock 对应 Hash 表不存在，或者 Hash 表不存在 uuid 这个 key，直接返回 nil。</p><p>若存在的情况下，代表当前锁被其持有，首先使用 hincrby使可重入次数减 1 ，然后判断计算之后可重入次数，若小于等于 0，则使用 del 删除这把锁。</p><p>解锁的 Java 代码如下：</p><pre><code>// 初始化代码：String unlockLuaScript = IOUtils.toString(ResourceUtils.getURL("classpath:unlock.lua").openStream(), Charsets.UTF_8);unlockScript = new DefaultRedisScript&lt;&gt;(unlockLuaScript, Long.class);/** * 解锁 * 若可重入 key 次数大于 1，将可重入 key 次数减 1 &lt;br&gt; * 解锁 lua 脚本返回含义：&lt;br&gt; * 1:代表解锁成功 &lt;br&gt; * 0:代表锁未释放，可重入次数减 1 &lt;br&gt; * nil：代表其他线程尝试解锁 &lt;br&gt; * &lt;p&gt; * 如果使用 DefaultRedisScript&lt;Boolean&gt;，由于 Spring-data-redis eval 类型转化，&lt;br&gt; * 当 Redis 返回  Nil bulk, 默认将会转化为 false，将会影响解锁语义，所以下述使用：&lt;br&gt; * DefaultRedisScript&lt;Long&gt; * &lt;p&gt; * 具体转化代码请查看：&lt;br&gt; * JedisScriptReturnConverter&lt;br&gt; * * @param lockName 锁名称 * @param request  唯一标识，可以使用 uuid * @throws IllegalMonitorStateException 解锁之前，请先加锁。若为加锁，解锁将会抛出该错误 */public void unlock(String lockName, String request) {    Long result = stringRedisTemplate.execute(unlockScript, Lists.newArrayList(lockName), request);    // 如果未返回值，代表其他线程尝试解锁    if (result == null) {        throw new IllegalMonitorStateException("attempt to unlock lock, not locked by lockName:+" + lockName + " with request: "                + request);    }}</code></pre><p>解锁代码执行方式与加锁类似，只不过解锁的执行结果返回类型使用 Long。这里之所以没有跟加锁一样使用 Boolean ,这是因为解锁 lua 脚本中，三个返回值含义如下：</p><ul><li>1 代表解锁成功，锁被释放</li><li>0 代表可重入次数被减 1</li><li>null 代表其他线程尝试解锁，解锁失败</li></ul><p>如果返回值使用 Boolean，<strong>Spring-data-redis</strong> 进行类型转换时将会把 null 转为 false，这就会影响我们逻辑判断，所以返回类型只好使用 Long。</p><p>以下代码来自 JedisScriptReturnConverter：</p><div class=pgc-img><img alt=老大吩咐的可重入分布式锁，终于完美的实现了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/99d27b39cdd04f65907b9fb5feaef797><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>相关问题</h3><p><strong>spring-data-redis 低版本问题</strong></p><p>如果 Spring-Boot 使用 Jedis 作为连接客户端,并且使用Redis Cluster 集群模式，需要使用 <strong>2.1.9</strong> 以上版本的<strong>spring-boot-starter-data-redis</strong>,不然执行过程中将会抛出：</p><pre><code>org.springframework.dao.InvalidDataAccessApiUsageException: EvalSha is not supported in cluster environment.</code></pre><p>如果当前应用无法升级 spring-data-redis也没关系，可以使用如下方式，直接使用原生 Jedis 连接执行 lua 脚本。</p><p>以加锁代码为例：</p><pre><code>public boolean tryLock(String lockName, String reentrantKey, long leaseTime, TimeUnit unit) {    long internalLockLeaseTime = unit.toMillis(leaseTime);    Boolean result = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;) connection -&gt; {        Object innerResult = eval(connection.getNativeConnection(), lockScript, Lists.newArrayList(lockName), Lists.newArrayList(String.valueOf(internalLockLeaseTime), reentrantKey));        return convert(innerResult);    });    return result;}private Object eval(Object nativeConnection, RedisScript redisScript, final List&lt;String&gt; keys, final List&lt;String&gt; args) {    Object innerResult = null;    // 集群模式和单点模式虽然执行脚本的方法一样，但是没有共同的接口，所以只能分开执行    // 集群    if (nativeConnection instanceof JedisCluster) {        innerResult = evalByCluster((JedisCluster) nativeConnection, redisScript, keys, args);    }    // 单点    else if (nativeConnection instanceof Jedis) {        innerResult = evalBySingle((Jedis) nativeConnection, redisScript, keys, args);    }    return innerResult;}</code></pre><p><strong>数据类型转化问题</strong></p><p>如果使用 Jedis 原生连接执行 Lua 脚本，那么可能又会碰到数据类型的转换坑。</p><div class=pgc-img><img alt=老大吩咐的可重入分布式锁，终于完美的实现了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/681839946566422e82de2718aeaebb9a><p class=pgc-img-caption></p></div><p>可以看到 Jedis#eval返回 Object，我们需要具体根据 Lua 脚本的返回值的，再进行相关转化。这其中就涉及到 Lua 数据类型转化为 Redis 数据类型。</p><p>下面主要我们来讲下 Lua 数据转化 Redis 的规则中几条比较容易踩坑：</p><p>1、Lua number 与 Redis 数据类型转换</p><p>Lua 中 number 类型是一个双精度的浮点数，但是 Redis 只支持整数类型，所以这个转化过程将会丢弃小数位。</p><div class=pgc-img><img alt=老大吩咐的可重入分布式锁，终于完美的实现了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99610da571ac4751b1ac07ab57f6e265><p class=pgc-img-caption></p></div><p>2、Lua boolean 与 Redis 类型转换</p><p>这个转化比较容易踩坑，Redis 中是不存在 boolean 类型，所以当Lua 中 true 将会转为 Redis 整数 1。而 Lua 中 false 并不是转化整数，而是转化 <strong>null</strong> 返回给客户端。</p><div class=pgc-img><img alt=老大吩咐的可重入分布式锁，终于完美的实现了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae744ace602847bf9d1f5667a3fc2aca><p class=pgc-img-caption></p></div><p>3、Lua nil 与 Redis 类型转换</p><p>Lua nil 可以当做是一个空值，可以等同于 Java 中的 <strong>null</strong>。在 Lua 中如果 nil 出现在条件表达式，将会当做 false 处理。</p><p>所以 Lua nil 也将会 <strong>null</strong> 返回给客户端。</p><p>其他转化规则比较简单，详情参考:</p><p><strong>http://doc.redisfans.com/script/eval.html</strong></p><h2 class=pgc-h-arrow-right>总结</h2><p>可重入分布式锁关键在于对于锁重入的计数，这篇文章主要给出两种解决方案，一种基于 ThreadLocal 实现方案，这种方案实现简单，运行也比较高效。但是若要处理锁过期的问题，代码实现就比较复杂。</p><p>另外一种采用 Redis Hash 数据结构实现方案，解决了 ThreadLocal 的缺陷，但是代码实现难度稍大，需要熟悉 Lua 脚本，以及Redis 一些命令。另外使用 <strong>spring-data-redis</strong> 等操作 Redis 时不经意间就会遇到各种问题。</p><h2 class=pgc-h-arrow-right>帮助</h2><p><strong>https://www.sofastack.tech/blog/sofa-jraft-rheakv-distributedlock/</strong></p><p><strong>https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html</strong></p><h2 class=pgc-h-arrow-right>最后说两句（求关注）</h2><p>看完文章，哥哥姐姐们点个<strong>在看</strong>吧，周更真的超累，不知觉又写了两天，拒绝白嫖，来点正反馈呗~。</p><p>最后感谢各位的阅读，才疏学浅，难免存在纰漏，如果你发现错误的地方，可以留言指出。如果看完文章还有其他不懂的地方，欢迎加我，互相学习，一起成长~</p><p>最后谢谢大家支持~</p><p>最最后，重要的事再说一篇~</p><p>快来关注我呀~ 快来关注我呀~ 快来关注我呀~</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'式锁','终于','实现'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>