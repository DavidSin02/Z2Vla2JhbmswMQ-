<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「排序」归并排序和逆序数问题探究 | 极客快訊</title><meta property="og:title" content="「排序」归并排序和逆序数问题探究 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/376607cc-e1f3-48f0-85d8-4a952ed4df5e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56f773f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/56f773f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/56f773f.html><meta property="article:published_time" content="2020-10-29T20:52:58+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:58+08:00"><meta name=Keywords content><meta name=description content="「排序」归并排序和逆序数问题探究"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/56f773f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「排序」归并排序和逆序数问题探究</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>微信公众号：bigsai</p><p>头条号：一直码农一直爽</p></blockquote><h2 class=pgc-h-arrow-right>前言</h2><p><br></p><div class=pgc-img><img alt=「排序」归并排序和逆序数问题探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/376607cc-e1f3-48f0-85d8-4a952ed4df5e><p class=pgc-img-caption></p></div><p><br></p><p>在排序中，我们可能大部分更熟悉冒泡排序、快排之类。对归并排序可能比较陌生。然而事实上归并排序也是一种稳定的排序，时间复杂度为O(nlogn).</p><p>归并排序是基于分治进行归并的，有<strong>二路归并</strong>和多路归并.我们这里只讲二路归并并且日常用的基本是二路归并。并且<strong>归并排序的实现方式</strong>有递归形式和非递归形式。要注意其中的区分(思想上没有大的区别，只是划分上会有区分后面会对比)。</p><p>并且归并排序很重要的一个应用是求序列中的逆序数个数。当然<strong>逆序数也可以用树状数组</strong>完成，这里就不介绍了。</p><h2 class=pgc-h-arrow-right>归并排序(merge sort)</h2><p>归并和快排都是<strong>基于分治算法</strong>的。分治算法其实应用挺多的，很多分治会用到递归，也有很多递归实现的算法是分治，但事实上<strong>分治和递归是两把事</strong>。分治就是分而治之。因为面对排序，如果不采用合理策略。每多一个数就会对整个整体带来巨大的影响。而分治就是将整个问题可以分解成相似的子问题。子问题的解决要远远高效于整个问题的解决，并且子问题的合并并不占用太大资源。</p><p>至于归并的思想是这样的：</p><ul><li>第一次：整串先进行划分成1个一个单独，第一次是一一(12 34 56---)归并成若干对，分成若干2个区间.归并完(xx xx xx xx----)这样局部有序的序列。</li><li>第二次就是两两归并成若干四个(1234 5678 ----)<strong>每个小局部是有序的</strong>。</li><li>就这样一直到最后这个串串只剩一个，然而这个耗费的总次数logn。每次操作的时间复杂的又是O(n)。所以总共的时间复杂度为O(nlogn).</li></ul><p>对于分治过程你可能了解了，但是这个两两merge的过程其实是很重要的。首先我们直到的两个序列都是有序的。其实思想也很简单，假设两个串串为 3 5 7 8和2 6 9 10进行归并操作。我们需要借助一个额外的数组team[8]将两个串串有序存进去就行。而流程是这样的：</p><div class=pgc-img><img alt=「排序」归并排序和逆序数问题探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03da2929f86d449cbd7d02c70dbd5f24><p class=pgc-img-caption></p></div><p><br></p><p><strong>非递归的归并</strong>正常归并的代码实现都是借助递归的。但是也有不借助递归的。大部分<strong>课本或者考试</strong>如果让你列归并的序列，那么<strong>默认就是非递归</strong>的，比如一个序列9,2,6,3,8,1,7,4,10,5序列的划分也是这样的。</p><pre><code>第一次结束： {2,9}{3,6}{1,8}{4,7}{5,10}第二次结束：{2,3,6,9}{1,4,7,8}{5,10}第三次结束：{1,2,3,4,6,7,8,9}{5,10}第四次结束：{1,2,3,4,5,6,7,8,9,10}</code></pre><p><strong>递归的归并</strong>在代码实现上的归并可能大部分都是递归的归并。并且递归和分治整在一起真的是很容易理解。递归可以将问题分解成子问题，而这恰恰是分治所需要的手段。而递归的<strong>一来一回</strong>过程的来(分治)回(归并)，一切都刚刚好。</p><p>而递归的思想和上面非递归肯定不同的，你可以想想非递归：我要考虑当前几个进行归并，每个开始的头座标该怎么表示，还要考虑是否越界等等问题哈，<strong>写起来略麻烦</strong>。</p><p>而非递归它的过程就是局部—>整体的过程，而递归是整体—>局部—>整体的过程。而递归实现的归并的思想：</p><pre><code> void mergesort(int[] array, int left, int right) {       int mid=(left+right)/2;//找到中间节点      if(left&lt;right)//如果不是一个节点就往下递归分治        {    mergesort(array, left, mid);//左区间(包过mid)进行归并排序          mergesort(array, mid+1, right);//右区间进行归并排序              merge(array, left,mid, right);//左右已经有序了，进行合并          } }</code></pre><p>同样是9,2,6,3,8,1,7,4,10,5这么一串序列，它的递归实现的顺序是这样的(可能部分有点问题，但是还是有助于理解的)：</p><div class=pgc-img><img alt=「排序」归并排序和逆序数问题探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/74e34b46c9ec4a16a387b191a2720a5e><p class=pgc-img-caption></p></div><p><br></p><p>所以实现一个归并排序的代码为：</p><pre><code>private static void mergesort(int[] array, int left, int right) {      int mid=(left+right)/2;       if(left&lt;right)        {           mergesort(array, left, mid);           mergesort(array, mid+1, right);         merge(array, left,mid, right);       }    }   private static void merge(int[] array, int l, int mid, int r) {    int lindex=l;int rindex=mid+1;          int team[]=new int[r-l+1];        int teamindex=0;       while (lindex&lt;=mid&amp;&amp;rindex&lt;=r) {//先左右比较合并          if(array[lindex]&lt;=array[rindex])            {           team[teamindex++]=array[lindex++];           }               else {                                 team[teamindex++]=array[rindex++];           }        }          while(lindex&lt;=mid)//当一个越界后剩余按序列添加即可        {               team[teamindex++]=array[lindex++];         }        while(rindex&lt;=r)          {               team[teamindex++]=array[rindex++];     }         for(int i=0;i&lt;teamindex;i++)       {            array[l+i]=team[i];       }  }</code></pre><h2 class=pgc-h-arrow-right>逆序数</h2><p>首先得了解什么是逆序数：</p><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对</p></blockquote><p>也就是比如3 2 1.看3 ，有2 1在后面，看2 有1在后面有3个逆序数。而比如1 2 3的逆序数为0.</p><p>在数组中，暴力确实可以求出逆序数，但是暴力之法太复杂，不可取！<strong>而有什么好的方法能解决这个问题呢？</strong> 当前序列我可能不知道有多少序列。<strong>但是我们直到如果这个序列如果有序那么逆序数就为0</strong>.</p><p>在看个序列 abcd 3 2 1 efg编程abcd 1 2 3 efg整个序列逆序数减少3个。因为如果不管abcd还是efg和123三个数相对位置没有变。所以我们是可以通过某种方法确定逆序数对的。</p><p>我们就希望能不能有个过程，动态改变如果逆序数发生变化能够记录下来？！比如动那么一下能够知道有没有改变的。并且这个动不能瞎动，<strong>最好是局部的，有序的动</strong>。归并排序就是很适合的一个结构。因为肯定<strong>要选个小于O(n^2^)的复杂度算法</strong>，而归并排序满足，<strong>并且每次只和邻居进行归并，归并后该部分有序。</strong></p><p>纵观归并的每个单过程例如两个有序序列：假设序列2 3 6 8 9和序列1 4 7 10 50这个相邻区域进行归并。</p><div class=pgc-img><img alt=「排序」归并排序和逆序数问题探究 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f88ee4a64a72486d9bc65e0fa9e81bf4><p class=pgc-img-caption></p></div><p>在这里插入图片描述</p><p>而纵观整个归并排序。<strong>变化过程只需要注意一些相对变化即可也就是把每个归并的过程逆序数发生变化进行累加，那么最终有序的那个序列为止得到的就是整个序列的逆序数！</strong></p><div class=pgc-img><img alt=「排序」归并排序和逆序数问题探究 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee5366f7338b480dac1a29e03ab6a25e><p class=pgc-img-caption></p></div><p>至于规律，<strong>你可以发现每次归并过程中，当且仅当右侧的数提前放到左侧，而左侧还未放置的个数就是该元素减少的逆序个数！</strong> 这个需要消化一下，而在代码实现中，需要这样进行即可！</p><pre><code>int value;-----------------private static void merge(int[] array, int l, int mid, int r) {		int lindex=l;int rindex=mid+1;		int team[]=new int[r-l+1];		int teamindex=0;		while (lindex&lt;=mid&amp;&amp;rindex&lt;=r) {			if(array[lindex]&lt;=array[rindex])			{				team[teamindex++]=array[lindex++];			}			else {								team[teamindex++]=array[rindex++];				value+=mid-lindex+1;//加上左侧还剩余的			}		}		while(lindex&lt;=mid)	      {	    	  team[teamindex++]=array[lindex++];	    	  	      }		while(rindex&lt;=r)	      {	    	  team[teamindex++]=array[rindex++];	      }			for(int i=0;i&lt;teamindex;i++)		{			array[l+i]=team[i];		}			}</code></pre><h2 class=pgc-h-arrow-right>结语</h2><p>至于<strong>归并排序和逆序数</strong>就讲这么多了！个人感觉已经尽力讲了，如果有错误或者不好的地方还请各位指正。如果感觉可以，还请点赞，关注一波哈。</p><p>欢迎关注公众号：<strong>bigsai</strong></p><p>头条号：<strong>一直码农一直爽</strong></p><p>长期奋战输出！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'排序','逆序','数问题'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>