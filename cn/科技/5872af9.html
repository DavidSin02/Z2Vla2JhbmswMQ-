<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux中断机制：硬件处理，初始化和中断处理 | 极客快訊</title><meta property="og:title" content="Linux中断机制：硬件处理，初始化和中断处理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1534258428582a2d6399914"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5872af9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5872af9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5872af9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5872af9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5872af9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5872af9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5872af9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5872af9.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="Linux中断机制：硬件处理，初始化和中断处理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5872af9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux中断机制：硬件处理，初始化和中断处理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>来源: CSDN | phenix_lord的专栏</p><p><strong>硬件处理</strong></p><p>最近解决一个关于Linux中断的问题，把相关机制整理了一遍，记录在此。</p><p>不同的外部设备、不同的体系结构、不同的OS其中断实现机制都有差别，本文对应的OS为linux3.4版本，外部设备为PCI设备、系统为X86。</p><p>概览</p><p>中断让外设能够通知CPU他需要获得服务(让CPU执行指定的中断服务例程ISR)。为了达到这个目的，首先要为中断执行做好准备，完成初始化相关的操作。包括：</p><p>1、 初始化中断控制器等相关器件(OS初始化过程中完成)；</p><p>2、 配置并使能外部设备(比如使用pci_enable_msix)，得到irq号；在这个操作过程中，内核需要完成的大致操作是：</p><p>1、 确定该中断的执行CPU，并在对应CPU上建立vector和irq号的对应关系(利用全局per-cpu变量vector_irq)，配置中断控制器(I/OAPIC、PIR等)，可能还需要设置外部设备(比如设置MSI</p><p>Capacity registers)；</p><p>2、 为对应的irq_desc初始化正确的handle_irq接口(通用逻辑接口)；</p><p>3、 为对应的irq_desc初始化正确的底层chip操作接口。</p><p>3、 使用request_irq号为该中断号指定一个服务例程；</p><p>完成了以上的初始化操作，在外设中断到来的时候，为该中断指定的ISR(Interrupt Service Routines)就能得到执行，这个执行过程大致如下：</p><p>1、 外设根据各自的配置，产生中断信号或者中断消息(MSI，INT# message)。</p><p>2、 中断控制器从外设获取中断电信号或者中断消息，把它翻译为vector(CPU使用这个参数来决定是谁发生了中断，要如何处理)并提交到CPU。</p><p>3、 对X86系统，CPU利用从中断控制器获取到的vector为索引，查询IDT (interrupt deor table)得到该中断的处理接口(对linux，是在entry_64.s中定义的函数common_interrupt接口)并执行。</p><p>4、 在linux定义的common_interrupt接口中，执行完中断执行环境建立后，会进入generic interrupt layer执行，其首先通过vector查找到irq和对应的irq_desc结构，并执行该结构的handle_irq接口，这个接口就是generic interrupt layer的通用逻辑接口，比如handle_edge_irq/handle_level_irq等；在中断执行的通用逻辑接口中，会通过irq_desc::action调用外设指定的ISR。</p><p>在linux中可以通过/proc/interrupts查看当前系统中所有中断的统计信息，在/proc/irq/xxx(中断号)下面，可以看到该中断的详细信息。</p><p>中断相关硬件</p><p>这里的描述很多来自INTEL的文档《Intel Software developer’s Manual, system programming guide》和《PCI Express System Architecture》</p><p>中断控制器</p><p>中断控制器的功能是：把外设的中断信号，转换成CPU能够明白的vector，并完成中断执行控制，确保在合适的时机把中断提交给CPU执行。对这部分内容，《interrupt in linux》有详细的描述。</p><p>1、 8259A：</p><p>每个8259A有8个管脚，每个管脚对应其连接的CPU的IDT中的一个vector，单独使用8259A，其硬件连线就决定了对设备vector的使用。典型的场景是使用两个8259A级联，理论最多16个中断号(就是ISA IRQs)，实际能提供对15个中断线的处理(master的IRQ2用于连接slave),其具体的分配见下图。</p><p>2、 PIR：</p><p>用于完成输入的信号到输出信号的映射。在下图中PIR被用于完成多个PCI设备的INT#信号到8259A对应引脚的路由。对应这种连接方式，在PCI设备初始化的时候，OS会根据BISO提供的信息设置PIR，把INT#路由到O0-O3中正确的管脚，从而体现到8259A的正确管脚(对应了vector)，这样INT#信号就被转换为vector并提交到CPU。由于可能有较多的PCI设备，而PIR的输入/出错管脚有限，所以连接到相同输入关键的INT#会共享一个中断。</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534258428582a2d6399914><p class=pgc-img-caption></p></div><p>3、 I/O APIC</p><p>每个I/O APIC提供24个管脚，能够和外部设备的中断线连接，每个管脚都可以通过配RTE(Redirection table entry)配置对应的vector。其功能是：把外部设备的中断请求，翻译为local APIC的interrupt message，并按照配置的vector，发送给指定的local APIC处理(在SMP系统，存在多个CPU，也就有多个local APIC)。通常的配置方式是：第一个I/O APIC的前16个管脚，配置来处理之前的ISA IRQs，其它外设比如PCI设备，则直接使用其他管脚连接。</p><p>4、 local APIC</p><p>其负责处理IPI(inter-process interrupt)、直接连接的中断处理、接收和处理interrupt message，每个CPU有自己的local APIC。</p><p>对应I/O APIC和local APIC的组合，其连接方式见下图</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534258428667c4d0bfe3af><p class=pgc-img-caption></p></div><p>针对X86中断控制器硬件和linux对这些硬件的初始化，在《interrupt in linux》中有很详细的描述。</p><p>X86对中断的处理</p><p>Local APIC的处理过程</p><p>每个local APIC对应了一个CPU。其处理interrupt message的过程如下：</p><p>1、 判断该中断的destination是否为当前APIC，如果不是则忽略，否则继续处理</p><p>2、 如果是SMI/NMI/INIT/ExtINT, or SIPI（这些中断都负责特殊的系统管理任务，外设一般不会使用）被直接送到CPU执行，否则执行下一步。</p><p>3、 设置Local APIC 的IRR寄存器的对应bit位。</p><p>4、 如果该中断优先级高于当前CPU正在执行的中断，且当前CPU没有屏蔽中断(按照X86和LINUX的实现，这时是屏蔽了中断的)，则该高优先级中断会中断当前正在执行的中断(置ISR位，并开始执行)，低优先级中断会在高优先级中断完成后继续执行，否则只有等到当前中断执行完成(写了EOI寄存器)后才能开始执行下一个中断。</p><p>5、 在CPU可以处理下一个中断的时候，从IRR中选取最高优先级的中断，清0 IRR中的对应位，并设置ISR中的对应位，然后ISR中最高优先级的中断被发送到CPU执行(如果其它优先级和屏蔽检查通过)。</p><p>6、 CPU执行中断处理例程，在合适的时机(在IRET指令前)通过写EOI寄存器来确认中断处理已经完成，写EOI寄存器会导致local APIC清理ISR的对应bit，对于level trigged中断，还会向所有的I/O APIC发送EOI message，通告中断处理已经完成。</p><p>说明：</p><p>1、 关于Local APIC的IRR和ISR</p><p>寄存器interrupt request register (IRR) 和 in-service register (ISR)，都是256bit寄存器，每个bit对应一个中断(其中[0-15]不能使用，SMI/NMI/INIT/ExtINT/SIPI的发送和执行不经过ISR和IRR) 。IRR中保存的是已经被local APIC接纳但是还没有开始执行的中断；ISR中保持的是当前正在执行但是还没有完成的中断。</p><p>2、 中断优先级</p><p>对应通过local APIC发送到CPU的中断，按照其vector进行优先级排序：</p><p>优先级=vector/16</p><p>数值越大，优先级越高。由于local APIC允许的vector范围为[16,255]，而X86系统预留了[0,31]作为系统保留使用的vector，实际的用户定义中断的优先级的取值范围为[2,15]，在每个优先级内部，vector的值越大，优先级越高。</p><p>Local APIC中还有一个关于中断优先级的寄存器TPR(task priority register)寄存器：用于确定打断线程执行需要的中断优先级级别，只有优先级高于设置值的中断才会被CPU执行 (SMI/NMI/INIT/ExtINT, or SIPI不受限制)，也就是除了特殊中断外，优先级低于TPR指定值的中断将被忽略。</p><p>3、 中断的pending</p><p>对于同一个vector，如果有多次中断请求，可能IRR和ISR对应的bit位都被置位，也就是对同一个vector，local APIC可以pending两个中断，其后的即使有多处，也会被合并为一个执行。</p><p>4、 中断执行时机</p><p>中断的执行总是在指令边界开始(只有一个特殊的exception：abort在外，出现了这个中断，系统基本上也就完蛋了)，也就是中断不可能打断指令的执行。</p><p>CPU对中断和异常的处理</p><p>相关概念</p><p>1、 vector(中断向量)</p><p>vector是一个整数，在X86CPU上，使用vector对中断(interrupt，外部设备产生)和异常(exception，CPU在程序执行中产生)统一编号，每个CPU核心内部，中断/异常和vector所以一一对应的；但是在各个不同的CPU核心上，相同的vector可以对应不同的中断(至少对于linux的设置，异常还是使用相同的vector)。</p><p>vector的取值范围为[0,255]，其中[0,31]被系统保留使用(多数作为异常的vector)，其余的可供外设中断使用(系统设备比如local APIC也占用了部分[32,255]这个范围的vector)。</p><p>2、 IDT(interrupt deor table)</p><p>X86 CPU采用一个有256个元素的数组来描述中断/异常，该数组的index为vector；其内容包括了三种gate deor，用于描述一个中断/异常的处理接口；这个数组就是IDT，CPU在收到中断请求的时候，就利用vector获取到对应的中断处理接口描述并执行。</p><p>3、 可屏蔽中断</p><p>通过CPU INTR管脚/local APIC接收到的中断是可屏蔽中断，这些中断能够通过清零EFLAGS的IF来屏蔽(CLI指令)。通过INT n指令生成的中断即使使用了和外部中断一样的vector，也是不可屏蔽的；同样CPU运行过程中同步产生的trap、fault、abort等异常也是不可屏蔽的。</p><p>4、 NMI</p><p>NMI是不可屏蔽中断(不可通过IF标志屏蔽)，是通过CPU的NMI管脚发出的中断或者通过delivery mode为NMI的方式提交的中断。NMI中断在执行前，CPU不仅会屏蔽其它中断，也会屏蔽NMI中断，直到NMI中断处理执行完成(IRET指令被执行)。使用INT 2指令虽然能执行NMI中断处理函数，但是相关硬件不会介入，也就是没有相关的屏蔽NMI中断的操作。</p><p>CPU执行中断的过程</p><p>1、 利用vector，查IDT得到中断描述符；</p><p>2、 如果中断发生在用户态，会首先执行stack switch切换到内核态执行；</p><p>3、 依次保存EFLAGS CS IP到当前栈,如果需要(有error code的异常)，把error code PUSH到当前栈。并把IF/TF位清零屏蔽可屏蔽中断；至此，CPU完成了中断处理程序执行环境的建立。</p><p>4、 执行中断描述符定义的中断处理入口(IDT中指定地址的代码)；</p><p>5、 根据环境执行不同的中断退出方式，比如执行现场调度操作(retint_careful和retint_kernel)，最终都会执行IRET指令；至此，中断执行完成。</p><p>异常的执行过程类似，只不过异常在执行前不会把IF位清零，只清零TF位。</p><p>PCI设备的中断</p><p>本部分的很多内容来自《PCI Interrupts for x86 Machines under FreeBSD》和《PCI Express®</p><p>Base Specification Revision 3.0》和《PCI Express System Architecture》。</p><p>PCI设备的中断有两种模式：一种是INT#模式，一种是MSI模式。</p><p>INT#模式</p><p>每个PCI设备用四个中断信号，对应INTA#、INTB# INTC#、INTD#，这些中断信号采用level trigger 的方式并且为低电平有效，PCI设备通过拉低对应的信号来assert对应的中断，并在ISR访问PCI设备的指定寄存器deassert该中断。</p><p>中断线和X86系统的连接</p><p>这里存在两种常见连接模式，一种是使用老的8259A+PIR的系统，一种是使用新的I/O APIC的系统。</p><p>对于使用8259A的系统：PCI的中断线连接到一个可编程的PIR设备,再通过该设备连接到8259A(见X86中断控制器一章的图)；对于采用I/OAPIC的系统，可以使用以下的连接方式，同样这里只画出了一个中断线，同时根据不同的系统配置可能存在多个I/OAPIC。除了采用直接的中断引脚连接，PCI还支持virtual INT#，使用INT# message(Assert INT# message和deassert INT# message)的方式来使用INT#信号。</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258428680dbb06d808e><p class=pgc-img-caption></p></div><p>NT#模式的局限</p><p>1、 中断数量有限且不方便扩展：每个物理的PCI设备，最多只有4个中断但是至少能支持8个function，且系统中可能存在多个PCI设备，不得不使用中断共享的模式，影响使用性能。</p><p>2、 同步问题：由于INT#中断采用的是side channel，中断信号和数据本身存在不同步的问题：可能在中断到达的时候，对应的数据没有达到，为了处理这个问题，一般采用“读刷新”的做法，也就是在使用该设备写入到X86的数据之前，ISR先对这个设备进行一次读操作来确保相关数据已经写入完成，比如读PCI设备的中断状态寄存器等。</p><p>MSI/MSI-X模式</p><p>在这种模式下，PCI设备通过和数据DMA一样的通道来完成中断处理，通过向特定地址空间(系统FSB Interrupt存储器空间)发起一个写操作来发起中断。该写操作的地址和数据信息在PCI设备初始化MSI功能的时候已经填写到MSI Capacity registers(MSI模式)/MSI-X table(MSI-X)中(对X86,这个地址空间是FEE00000H开始的地址空间，其实就是local APIC寄存器映射的地址空间)，地址信息保存在Message address register，其中包含了目标CPU信息和FSB Interrupt存储器空间；数据中包含了该MSI中断对应的vector，保存在Message data register中。 MCH(memory control hub)截获这个写操作，转换为FSB interrupt message并向各个CPU核心广播，local APIC接收并处理这个消息，最终触发CPU的中断处理过程。使用这种机制，中断的数量不受PIR/ IOAPIC等各种器件管脚数量的限制,MSI可以支持32个中断，而MSI-X可以达到2048个；中断的传递相当直接，省略了中断路由的过程；并且能直接从interrupt message中获取vector信息，减少了交互过程。</p><p><strong>初始化</strong></p><p>相关概念和关键数据结构</p><p>1、 irq号：在当前系统中全局唯一，对应内核数据结构struct irq_desc，每个外设的中断有一个irq号(体系结构预留的中断，是没有对应的irq_desc结构和irq号的)，该irq在该中断的生命周期内都不会改变，且和该中断的中断处理函数关联；内核使用一个bitmap allocated_irqs来标识当前系统已经分配的irq；irq号的管理与底层中断设备和配置无关，属于Generic Interrupt Layer；对于irq号分布集中的情况，不配置CONFIG_SPARSE_IRQ，内核采用数组直接管理，数组下标就是irq号；而对于irq号比较分散的，设置CONFIG_SPARSE_IRQ，内核采用radix tree来管理所有的irq号。</p><p>2、 vector号：内核使用全局bitmap used_vectors来标识那些vector被系统预留，不能被外设分配使用。</p><p>3、 irq号和vector号的关联：内核中使用per-cpu变量vector_irq来描述irq号和vector号的关联，对每个CPU，vector_irq是一个数组，在X86架构下成员数量为256，其数组的index为vector，值为irq,如果为-1则表示该CPU上的这个vector尚未分配。</p><p>4、 struct irq_desc结构，用来描述一个中断，是内核generic interrupt layer的关键数据结构，其包含了中断的大部分信息，并连接了driver层和物理中断设备层，每个irq号对应一个该结构，共享相同irq号的中断共享该结构。它的关键成员包括：</p><p>a) irq_data :为该中断对应的物理中断设备层相关的数据。</p><p>b) handle_irq：为该该中断使用的通用逻辑接口。</p><p>c) action：为driver层提供的ISR信息，其为一个单向链表结构，所有共享该中断的设备的ISR都链接在这里。</p><p>内核关键数据结构和相关初始化</p><p>对X86 CPU，Linux内核使用全局idt_table来表达当前的IDT，该变量定义在traps.c</p><p>gate_desc idt_table[NR_VECTORS] __page_aligned_data = { { { { 0, 0 } } }, };//初始化为全0。</p><p>对中断相关的初始化，内核主要有以下工作：</p><p>1、 设置used_vectors，确保外设不能分配到X86保留使用的vector(预留的vector范围为[0,31]，另外还有其他通过apic_intr_init等接口预留的系统使用的vector);</p><p>2、 设置X86CPU保留使用的vector对应的IDT entry;这些entry使用特定的中断处理接口；</p><p>3、 设置外设 (包括ISA中断)使用的中断处理接口，这些中断处理接口都一样。</p><p>4、 设置ISA IRQ使用的irq_desc；</p><p>5、 把IDT的首地址加载到CPU的IDTR(Interrupt Deor Table Register);</p><p>6、 初始化中断控制器(下一章描述)</p><p>以上工作主要在以下函数中完成：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534258428642be0bb45512><p class=pgc-img-caption></p></div><p>可以看到，这个过程会完成每个中断vector对应的idt entry的初始化，系统把这些中断vector分成以下几种：</p><p>1、X86保留vector，这些vector包括[0,0x1f]和APIC等系统部件占用的vector,对这些vector，会记录在bitmap used_vectors中，确保不会被外设分配使用；同时这些vector都使用各自的中断处理接口，其中断处理过程相对简单(没有generic interrupt layer的参与，CPU直接调用到各自的ISR)。</p><p>2、ISA irqs，对这些中断，在初始化过程中已经完成了irq_desc、vector_irq、以及IDT中对应entry的分配和设置，同时可以发现ISA中断，在初始化的时候都被设置为运行在0号CPU。</p><p>3、其它外设的中断，对这些中断，在初始化过程中仅设置了对应的IDT，和ISA中断一样，其中断处理接口都来自interrupt数组。</p><p>中断处理接口interrupt数组</p><p>interrupt数组是内核中外设中断对应的IDT entry，其在entry_64.S中定义，定义如下：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258428632af8144e87a><p class=pgc-img-caption></p></div><p>这段汇编的效果是：在代码段，生成了一个符号irq_entries_start，该符号对应的内容是一组可执行代码，一共(NR_VECTORS-FIRST_EXTERNAL_VECTOR+6)/7组，每组为7个中断入口，为：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15342584286688a54aab0cf><p class=pgc-img-caption></p></div><p>每组的最后一个中断入口不需要jmp 2f是因为其pushq_cfi(就是pushq咯)下面就</p><p>是2f这个标号的地址了。（不明白的是：为什么不在jmp 2f的地方直接写上jmp common_interrupt?非要jmp 2f，2f的地方再次jmp common_interrupt？）</p><p>而interrupt是一个数组，该数组在初始化完成后释放，其每个数组项都是一个地址，是对应的“pushq_cfi”代码的地址(每个代表中断入口的标号)。系统在初始化的时候，对外设使用interrupt数组作中断处理接口，就是在中断发生时，执行代码段：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258428726b0c304c9a0><p class=pgc-img-caption></p></div><p>初始化中断控制器</p><p>对中断控制器的使用基本上有三种机制：</p><p>1、 中断路由表 $PIR</p><p>struct irq_routing_table，该结构用于使用PIR和8259A的系统，在微软的文献《PCI IRQ Routing Table Specification》中描述了该结构详细信息。其描述了一个PCI设备的INT#是如何连接到PIR设备的输入端口的。其关键数据是一个可变长的struct irq_info数组，每个struct irq_info描述了一个PCI物理设备的4个INT#相关的中断路由信息和对应可用的ISA IRQs的bitmap。BIOS根据相关设备的物理连接填写该数据结构，OS在设备初始化过程中使用这些信息为使用INT#的设备分配对应的vector和irq。</p><p>2、 MP table</p><p>struct mpc_intsrc，该数据结构用于使用I/O APIC的系统中，描述系统中所有PCI设备4个INT#信号和I/O APIC输入引脚的对应关系。该数据结构的srcbus成员为对应PCI设备的bus id；srcbusirq描述了一个INT#信号，其bit0-bit1用于描述是INTA#–INTD#中的哪一个(对应值为0-3)，bit2-bit6描述该PCI设备的slot id。dstapic为该描述对应的I/O APIC的ID。dstirq描述srcbus和srcbusirq确定的INT#对应的irq号信息(具体的解析有多种情况)。在系统中有一个以该数据结构为成员的全局数组mp_irqs，用于管理系统中所有的硬件中断信号和irq之间的关联。对MP table及其使用的更加详细的描述，见《Multiprocessor Specification v1.4》</p><p>3、 ACPI(Advanced Configuration and PowerInterface)机制</p><p>这种机制为I/O APIC机制和中PIR机制提供统一的管理界面，该机制使用struct acpi_prt_entry描述INT#和GSI(能和vector、irq对应)的关系，系统中所有的struct acpi_prt_entry由OS从BIOS提供的信息中获取，并保存在链表acpi_prt_list中。</p><p>注：对GSI的说明，GSI(global system interrupt)表示的是系统中中断控制器的每个输入管脚的唯一编号，在使用ACPI模式管理中断控制器的时候使用。对使用8259A的系统，GSI和ISA IRQ是一一对应的。对于使用APIC的，每个I/O APIC会由BISO分配一个基址，这个base+对应管脚的编号(从0开始)就是对应的GSI。通常是基址为0的I/O APIC的前16个管脚用于ISA IRQS，对GSI更加详细的描述，见《Advanced Configuration and Power Interface Revision 2.0》</p><p>除了中断路由表，其它两种机制的初始化(包括相关中断路由信息的初始化)的在《interrupt in linux》中有很详细的描述。这些初始化操作都在内核初始化的时候完成。</p><p>为PCI设备配置中断</p><p>为PCI设备配置中断，分为两个步骤，</p><p>步骤一：为设备分配irq号(对MSIX，会有多个)，为该中断分配执行CPU和它使用的vector，并通过对中断控制器的设置，确保对应的中断信号和vector匹配。对于使用INT#类型的中断，通常通过pci_enable_device/pci_enable_device_mem/pci_enable_device_io中对函数pcibios_enable_device的调用来完成(只有在没有开启MSI/MSIX的时候才会为INT#做配置)，而要配置MSI/MSIX中断要使用的是pci_enable_msix。</p><p>步骤二：request_irq为该设备的irq指定对应的中断处理例程，把irq号和驱动定义ISR关联。</p><p>pcibios_enable_device</p><p>该接口用于使能PCI设备INT#模式的中断。其主要功能由pcibios_enable_irq(dev)完成，pcibios_enable_irq是一个函数指针，对于ACPI模式，其在上电过程中被设置为acpi_pci_irq_enable，其它情况被设置为pirq_enable_irq。</p><p>对ACPI模式，其执行过程为：</p><p>1、 acpi_pci_irq_enable：其先根据设备的管脚信息获取一个GSI(可以认为有了GSI，就有了irq号，gsi_to_irq可以完成其转换)，有了gsi/irq，要完成设置还必须有vector并且把它们关联起来，因此如果GSI获取成功，会使用acpi_register_gsi来完成后续操作。</p><p>2、 acpi_register_gsi：其主要功能由__acpi_register_gsi来完成，该函数指针在ACPI模式下被设置为acpi_register_gsi_ioapic，acpi_register_gsi_ioapic的执行过程如下：</p><p>mp_register_gsi===>io_apic_set_pci_routing===>io_apic_set_pci_routing===>io_apic_setup_irq_pin_once===>io_apic_setup_irq_pin===>setup_ioapic_irq，在setup_ioapic_irq中，就会利用assign_irq_vector为该irq选择对应的执行CPU，并分配该CPU上的vector，同时还把该vector等配置写入到I/O APIC对应管脚的RTE，从而完成整个中断的配置。这样在该INT#信号到来的时候，I/O APIC就能根据对应管脚的RTE，把该信号翻译为一个vector，并通过中断消息发送到local APIC。同时在setup_ioapic_irq中，还通过ioapic_register_intr===>irq_set_chip_and_handler_name为得到的irq号对应的irq_desc设置了->irq_data.chip和handle_irq函数指针（对level触发的，为handle_fasteoi_irq，否则为handle_edge_irq）</p><p>对其它模式，其通过pcibios_lookup_irq完成执行：</p><p>在配置了I/O APIC的场景，pirq_enable_irq通过IO_APIC_get_PCI_irq_vector获取到irq号，然后和ACPI模式一样，通过io_apic_set_pci_routing完成对I/O APIC的配置。而对没有配置I/O APIC的场景，主要通过pcibios_lookup_irq来完成相关操作：</p><p>1、 pcibios_lookup_irq通过读取BIOS提供的中断路由表 ($PIR表，irq_routing_table)信息和当前irq分配情况(pirq_penalty数组)，在考虑均衡的前提下为当前设备分配一个可用的irq。</p><p>2、 根据当前PIR的相关信息，决定最终的irq号选择，相关代码行如下</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15342584287973067e8cd41><p class=pgc-img-caption></p></div><p>也就是：如果是硬链接(INT#直接连接到了8259A，没有经过PIR)，直接获取irq号，如果PIR中已经有该输入线的配置，使用已有的值，否则利用刚刚分配的可用irq，并写入到PIR，以便能够完成中断信号到irq号的转换。</p><p>注意：</p><p>1、这里的r，也就是pirq_router，代表一种PIR硬件，全局配置pirq_routers中描述了当前支持的PIR，并在初始化的时候通过pirq_find_router获取了对应当前配置的PIR对应的描述。</p><p>2、这里没有分配vector，是因为这里使用的irq号范围为0-16，是ISA IRQs，其与vector的对应关系简单：vector = IRQ0_VECTOR + irq，并在系统初始化过程中，已经通过early_irq_init中分配了irq_desc结构，通过init_IRQ设置了vector_irq(只运行于CPU0上)，然后通过x86_init.irqs.intr_init(native_init_IRQ)===> x86_init.irqs.pre_vector_init(init_ISA_irqs)设置了->irq_data.chip(i8259A_chip)和handle_irq函数指针(handle_level_irq)。</p><p>Pci_enable_msix</p><p>该函数完成MSIX中断相关的设置。</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153425842873694ea3e9dce><p class=pgc-img-caption></p></div><p>msix_capability_init中实现中断初始化的是arch_setup_msi_irqs，对于X86系统，其为x86_setup_msi_irqs，x86_setup_msi_irqs中直接调用了native_setup_msi_irqs，该函数是X86系统中实现MSIX中断初始化的关键函数，对于没有启用interrupt remap的系统，其实现如下：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15342584288359b8d5514e5><p class=pgc-img-caption></p></div><p>该函数中有两个关键函数，分别是create_irq_nr和setup_msi_irq，其中create_irq_nr是分配一个vector给当前的中断，分配vector的同时，也为该中断指定了执行CPU。setup_msi_irq则负责把相关配置信息写入到PCIE配置区，并设置irq_desc的数据，其中关键的是irq_desc的handle_irq被设置为handle_edge_irq。</p><p>create_irq_nr的实现如下：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1534258428880d68b6734a3><p class=pgc-img-caption></p></div><p>其中__assign_irq_vector负责分配vector，并和中断在CPU上的调度相关，其实现如下</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534258428954e5a06ea138><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15342584289160ecaed1f5a><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534258428958f5d6b1dddd><p class=pgc-img-caption></p></div><p>从实现中可以看到，该函数从FIRST_EXTERNAL_VECTOR(外设中断的起始vector号，通常是0x20) 到first_system_vector(外部中断结束vector号，通常是254，255被系统作为保留的SPURIOUS_APIC_VECTOR使用)的范围中，为当前中断分配一个vector，要求该vector在对应的cpu上均可用，该vector按照系统配置的要求和对应的cpu核心绑定，并在要求的cpu中没有被其它中断使用。需要说明的是，在setup_msi_irq中会再次通过msi_compose_msg再次调用__assign_irq_vector，但是由于这时已经存在满足CPU绑定要求的vector，不会多次分配。</p><p>从以上分析可以得到MSI-X中断的一个绑定特征：根据当前APIC配置，每个中断都有对应的可以运行的cpu，pci_enable_msix在这些要求的cpu核心上建立了vector (APIC的配置由数据结构struct apic来抽象，其vector_allocation_domain用于决定需要在那些cpu核心上为该中断建立vector)，当前我的系统使用的是apic_physflat，对每个MSI中断，其只在一个cpu核心上建立vector，对应的MSI-X中断事实上被绑定到该cpu核心上。在用户通过echo xxx > /proc/irq/xxx/affinity来调整中断的绑定属性时，内核会重新为该中断分配一个新的在对应核心上可用的vector，但是irq号不会改变。绑定属性调整的调用路径大致为irq_affinity_proc_fops===>irq_affinity_proc_write===> write_irq_affinity===>irq_set_affinity===>__irq_set_affinity_locked===>chip->irq_set_affinity(msi_set_affinity)。也就是最终通过msi_set_affinity来实现，在该函数中首先通过 __ioapic_set_affinity在绑定属性要求的cpu中选择空闲vector，然后通过__write_msi_msg把配置写入PCIE配置区。需要说明的是：该irq最终可以运行的cpu数量并不完全由用户指定，还与apic的模式相关，对于apic_physflat，实际上只为该irq分配了一个cpu核心，该irq只能运行在用户指定的cpu中的一个，而不是全部。</p><p>附：关于全局变量apic</p><p>该全局变量为local apic的抽象，在不同的系统配置下，有不同的选择，其最终的选择结果，由内核的config(反应在/arch/x86/kernel/apic/Makefile)和硬件配置等来决定。</p><p>1、 定义各种apic driver</p><p>首先，每种apic配置都会使用apic_driver/ apic_drivers来定义，apic_driver的定义如下</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258428997da4233d912><p class=pgc-img-caption></p></div><p>这个定义的目的是把sym的地址写入到名为” .apicdrivers”的段中。</p><p>2、 定义全局符号__apicdrivers和__apicdrivers_end</p><p>在linker vmlinux.lds.S中，定义了__apicdrivers为” .apicdrivers”段的开始地址，而__apicdrivers_end为结束地址。” .apicdrivers”段中是各个不同的apic配置对应的struct apic。</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258429081eadea1aa05><p class=pgc-img-caption></p></div><p>3、 apic的probe</p><p>在初始化过程(start_kernel)中，会调用default_setup_apic_routing(probe_64.c中定义)来完成apic的probe，该函数会按照各个struct apic结构在.apicdrivers中的顺序，依次调用其probe接口，第一个调用返回非0的struct apic结构就被初始化到全局变量apic。也就是：如果有多个apic结构可用，最终会选择在.apicdrivers段中出现的第一个；所以makefile文件中各个.o出现的顺序也会觉得最终的apic probe结果。</p><p>request_irq</p><p>该函数把irq和用户指定的中断处理函数关联。用户指定的每个处理函数对应于一个struct irqaction结构，这些处理函数构成一个链表，保存在struct irq_desc：：action成员中。详细见request_irq===>request_threaded_irq中的处理。</p><p><strong>中断的执行</strong></p><p>在内核代码中，对X86平台中断执行的基本过程是：</p><p>1、 通过IDT中的中断描述符，调用common_interrupt；</p><p>2、 通过common_interrupt，调用do_IRQ，完成vector到irq_desc的转换，进入Generic interrupt layer(调用处理函数generic_handle_irq_desc)；</p><p>3、 调用在中断初始化的时候，按照中断特性(level触发，edge触发等、simple等)初始化的irq_desc:: handle_irq，执行不同的通用处理接口，比如handle_simple_irq；</p><p>4、 这些通用处理接口会调用中断初始化的时候注册的外部中断处理函数；完成EOI等硬件相关操作；并完成中断处理的相关控制。</p><p>common_interrupt</p><p>按照之前CPU执行中断过程的描述，X86 CPU在准备好了中断执行环境后，会调用中断描述符定义的中断处理入口；根据中断相关初始化过程我们知道，对于用户自定义中断，中断处理入口都是(对系统预留的，就直接执行定义的接口了)：</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153425842905606e3614287><p class=pgc-img-caption></p></div><p>就是在把vector入栈后，执行common_interrupt，common_interrupt在entry_64.S中定义，其中关键步骤为：调用do_IRQ，完成后会根据环境判断是否需要执行调度，最后执行iretq指令完成中断处理，iret指令的重要功能就是回复中断函数前的EFLAGS(执行中断入口前被入栈保存，并清零IF位关中断)，并恢复执行被中断的程序(这里不一定会恢复到之前的执行环境，可能执行软中断处理，或者执行调度)。</p><p>do_IRQ</p><p>do_IRQ的基本处理过程如下，其负责中断执行环境建立、vector到irq的转换等</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258429020d442fd558f><p class=pgc-img-caption></p></div><p>Generic interrupt layer</p><p>该层负责的是平台无关/设备无关的中断通用逻辑，对这部分，在《Linux generic IRQ handling》中有详细描述。其负责完成中断处理的接口是generic_handle_irq_desc，该接口会执行irq_desc：：handle_irq； Generic interrupt layer根据中断特性的不同，把中断分成几类，包括：level type(handle_level_irq)、edge type(handle_edge_irq)、simple type(handle_simple_irq)等，这些中断类型对应的处理函数是都在kernel/irq/chip.c中定义，并入前面的描述，在相关中断初始化的时候，被赋值给irq_desc：：handle_irq；对于PCI设备，只用了两种，level type(INT#模式)、edge type(MSI/MSI-X模式)。</p><p>edge 触发中断的基本处理过程：</p><p>电压跳变触发中断===>中断控制器接收中断，记IRR寄存器===>中断控制器置ISR寄存器===>CPU屏蔽本CPU中断===>CPU处理中断，发出EOI===>中断控制器确认可以处理下一次中断===>ISR清中断源，电压归位===>中断源可以发起下一次中断===>CPU中断处理完成，执行完现场处理后执行IRET，不再屏蔽本CPU中断。</p><p>edge触发的特点：</p><p>a) 中断不会丢</p><p>如果中断触发时中断被屏蔽，那么中断控制器会记录下该中断，在屏蔽取消的时候会再执行。</p><p>b) edge触发的缺点是完成共享不方便：</p><p>比如A和B两个中断源共享一个中断，每次ISR先检查A再检查B，如果B先发生中断，在ISR检查完A，检查B的过程中，A发生中断。那么在ISR处理开始的时候，A会告诉ISR，不是它干的，然后ISR处理B的中断，完成后通过清理中断源把B的电压归位，但是由于A的中断没有得到处理，电压没有归位，这个共享的中断就不能得到再次触发了。</p><p>edge触发对应的通用逻辑接口</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534258429102c1eeea4c36><p class=pgc-img-caption></p></div><p>level 触发：</p><p>这种模式下，外设通过把电压保持到某个门限值来完成触发中断，在处理完成(EOI)后，如果电压还在门限值，就会再次触发中断的执行。</p><p>level触发的特点：</p><p>a) 方便中断共享</p><p>b) 对中断触发时中断被屏蔽的情况，如果中断屏蔽解除后仍然引脚电压仍然在门限值，就执行该中断的ISR，否则不执行。</p><p>需要说明的是：对于使用local APIC的系统，level触发和edge触发需要配置local APIC的Local Vector Table。</p><p>4、 level触发对应的通用逻辑接口</p><div class=pgc-img><img alt=Linux中断机制：硬件处理，初始化和中断处理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534258429185eae7337d60><p class=pgc-img-caption></p></div><p>level触发和edge触发在通用逻辑层最大的不同就是当其他CPU正在处理该中断的时候，系统的行为，对edge触发，会把该中断记录下来，当前处理结束后再次执行，而level直接退出。产生这种差异的原因是：level触发不怕丢？</p><p>无论是那种触发方式，都会调用handle_irq_event处理中断，该函数中会遍历irq_desc::action链表，执行action->handler，也就是驱动在中断初始化的时候，通过request_irq注册的中断处理接口。</p><p>总结 中断的使能状态</p><p>1、 在local APIC层次(当前CPU)，一个中断正在处理的时候，不会有相同的中断或者优先级低于该中断的其它中断来打断当前中断的执行；但是高优先级中断可以打断低优先级中断。</p><p>2、 在X86 CPU层次(当前CPU)，从中断执行开始到IRET，IF位都被清零，也就是只有不可屏蔽中断能够打断当前中断的执行。</p><p>3、 在Generic interrupt layer层次，如果一个中断已经在系统中执行，会阻止该中断在其它CPU上的执行。</p><p>4、 在外设/驱动中断处理函数层次往往也有中断使能的功能，比如启用了NAPI的网卡，在中断处理函数开始执行的时候，往往会通过硬件功能关闭该中断，要在对应的软中断完成处理后才通过硬件功能使能该中断。</p><p>注：NMI中断虽然称为不可屏蔽中断，也有一个例外：NMI中断执行过程中，该CPU屏蔽了后来的NMI中断。</p><p>中断的执行CPU</p><p>通过中断初始化过程我们知道：中断在那个CPU上执行，取决于在那个CPU上申请了vector并配置了对应的中断控制器(比如local APIC)。如果想要改变一个中断的执行CPU，必须重新申请vector并配置中断控制器。一般通过echo xxx > /proc/irq/xxx/affinity来完成调整，同时irq_balance一类软件可以用于完成中断的均衡。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'中断','处理','Linux'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>