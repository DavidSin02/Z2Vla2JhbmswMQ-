<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python -- 函数 | 极客快訊</title><meta property="og:title" content="Python -- 函数 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f37a722d91c0477bbcecf6dd90fad05c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/59f27c81.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/59f27c81.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="Python -- 函数"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/59f27c81.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python -- 函数</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>函数</strong></h1><h1 class=pgc-h-arrow-right><strong>一、函数基础</strong></h1><h1 class=pgc-h-arrow-right><strong>1.什么是函数？</strong></h1><p style=text-align:start>在程序中，函数就是具备某一功能的工具，事先将工具准备好就是函数的定义，遇到应用场景拿来就用就是函数的调用。</p><p style=text-align:start>函数只是一种思绪，干活的具体的实现都是靠if/while/for+变量，函数只是让干活更轻松。</p><h1 class=pgc-h-arrow-right><strong>2.为何用函数？</strong></h1><p style=text-align:start>如果不使用函数，写程序时就会遇到这三个问题：</p><ol start=1><li>程序冗长</li><li>程序的扩展性差</li><li>程序的可读性差</li></ol><h1 class=pgc-h-arrow-right><strong>函数可以把重复代码写成一个通用模板，可以把冗余的代码独立开。</strong></h1><h1 class=pgc-h-arrow-right><strong>3.如何用函数？</strong></h1><p style=text-align:start>先定义函数，后调用。</p><ul><li>定义函数：</li></ul><pre><code>def 函数名(param1、param2....):    ''''''    函数功能的描述信息    :param1:描述    :param2:描述    :return:返回值    '''''''    code 1    code 2    code 3    ...        return 返回值</code></pre><ul><li>调用函数</li></ul><pre><code>函数名(param1、param2...)</code></pre><h1 class=pgc-h-arrow-right>注册功能函数：</h1><pre><code># 注册功能函数def reqister():    """注册功能"""    username=input('username:').strip()    pwd=input('password:').strip()        with open('   ','a',encoding='utf8')as fa:        fa.write(f"{username}:{pwd}\n")        fa.flush()</code></pre><h1 class=pgc-h-arrow-right>登陆功能函数：</h1><pre><code>#登录功能函数def login():    """登录功能"""    inp_username=input('username:').strip()    inp_pwd=input('password:').strip()        with open('38a.txt', 'rt', encoding='utf8') as fr:        for user_info in fr:            user_info = user_info.strip('\n')            user_info_list = user_info.split(':')            if inp_username == user_info_list[0] and inp_pwd ==user_info_list[1]:                print('login successful')                break        else:            print('failed')</code></pre><h1 class=pgc-h-arrow-right>函数定义阶段：</h1><pre><code>def func():    bar()    #不属于语法错误，不会报错    print('*'*10)</code></pre><p>置检测语法，不执行函数体代码</p><h1 class=pgc-h-arrow-right>函数调用阶段</h1><pre><code>def bar():    print('from bar')def foo():    print('from foo')    bar()foo()'''from foofrom bar'''</code></pre><h1 class=pgc-h-arrow-right><strong>二、定义函数的三种形式</strong></h1><h1 class=pgc-h-arrow-right><strong>定义函数时参数是函数体接收外部传值的一种媒介，其实就是一个变量名</strong></h1><h1 class=pgc-h-arrow-right><strong>比较两个数的大小，max是内置关键字</strong></h1><h1 class=pgc-h-arrow-right><strong>1.无参函数</strong></h1><p style=text-align:start>在函数阶段括号内没有参数，称为无参函数。需要注意的是：定义时无参，意味着调用时也无需传入参数。</p><pre><code>def self_max():    x, y = 10, 20    if x &gt; y:        print(x)    else:        print(y)self_max()</code></pre><h1 class=pgc-h-arrow-right><strong>2.有参函数</strong></h1><p style=text-align:start>在函数定义阶段括号内有参数，称为有参函数。定义时有参，意味着调用时也必须传入参数。有几个参数，就必须传入几个参数</p><pre><code>def self_max(x, y):    if x &gt; y:        print(x)    else:        print(y)self_max(100,500)</code></pre><h1 class=pgc-h-arrow-right><strong>3.空参数</strong></h1><p style=text-align:start>当你只知道你需要实现某个功能，但不知道该如何用代码实现时，你可以暂时写个空函数，然后先实现其他的功能。</p><pre><code>def self_max():    passself_max()</code></pre><h1 class=pgc-h-arrow-right><strong>三、函数的返回值</strong></h1><h1 class=pgc-h-arrow-right><strong>1.什么是返回值？</strong></h1><p style=text-align:start>函数内部代码经过一些列逻辑处理获得的结果</p><pre><code>def self_max(x,y):      #x=1000,y=100    if x&gt;y:        return x        #返回一个值，给函数名       #return 任意数据类型的数据    else:        return y</code></pre><pre><code># 变量名用来接收变量值# 函数名用来接收函数的返回值# print(self_max(10,100))  # 返回值默认为None</code></pre><h1 class=pgc-h-arrow-right><strong>2.为什么要有返回值？</strong></h1><p style=text-align:start>现在有一个需求，比较两个人的月薪，然后想获取月薪较大人的年薪。</p><p style=text-align:start>如果需要在程序中拿到函数的处理结果做进一步的处理，则需要函数必须要有返回值。</p><p style=text-align:start>需要注意的是：</p><ul><li>return是一个函数结束的标志，函数内可以有多个return，只要执行到return，函数就会停止。</li><li>return的返回值可以返回任意数据类型</li><li>return的返回值无个数限制，即可以使用逗号隔开返回多个值</li></ul><pre><code># 0. return 默认返回None# 1. return可以返回任意数据类型的数据# 2. 当return返回多个值的时候,会以元祖的形式把多个值包在一起# 3. return 会终止函数</code></pre><h1 class=pgc-h-arrow-right><strong>四、函数的调用</strong></h1><h1 class=pgc-h-arrow-right><strong>1.什么是函数调用？</strong></h1><p style=text-align:start>第一次将函数其实就讲了函数的调用，但是你不得不再次更新你对函数调用的印象。函数名(…)即调用函数，会执行函数体代码，直到碰到return或者执行完函数体内所有代码结束。</p><p style=text-align:start>函数运行完毕所有代码，如果函数体不写return，则会返回None。</p><pre><code>def foo():    passprint(foo())</code></pre><pre><code>none</code></pre><h1 class=pgc-h-arrow-right><strong>2.为何用调用函数？</strong></h1><p style=text-align:start>使用函数的功能</p><h1 class=pgc-h-arrow-right>3.函数调用的三种形式</h1><pre><code>def max_self(x,y):    if x&gt;y:        return x    else:        return y    # 1.      max_self(1,2)# 2.      res = max_self(1,2)*12# 3.      max_self(max_self(20000,30000),40000)</code></pre><h1 class=pgc-h-arrow-right><strong>五、函数参数的应用</strong></h1><h1 class=pgc-h-arrow-right><strong>１.形参和实参</strong></h1><ul><li>形参</li><li>实参</li></ul><pre><code>##  函数分为两个阶段# # 1. 定义阶段:定义阶段的x和y被称为形参,形参具有描述意义,类似于变量名,不为具体的数据类型# # 2. 调用阶段:调用阶段的x和y被称为实参,实参必须是具体的数据类型### # 默认形参:在函数定义阶段,提前赋值给形参,当你实参传值的时候,实参传的值会覆盖默认值</code></pre><h1 class=pgc-h-arrow-right><strong>2.位置参数</strong></h1><ul><li>位置形参在函数定义阶段，按照从左到右的顺序依次定义的形参，称之为位置形参特点：按照位置定义的形参，都必须被传值，多一个不行，少一个也不行。</li><li>位置实参在函数调用阶段，按照从左到右的顺序依次定义的实参，称之为位置实参特点：按照位置为对应的形参依次传值</li></ul><h1 class=pgc-h-arrow-right><strong>3.关键字实参</strong></h1><p style=text-align:start>在调用函数时，按照key=value的形式为指定的参数传值，称为关键字实参。</p><p style=text-align:start>用在函数调用阶段,找到与形参的对应关系,并赋值给对应的形参,形参名为什么则关键字实参名也必须是什么</p><p style=text-align:start>特点：可以打破位置的限制，但仍能为指定的形参赋值。</p><p style=text-align:start>注意：</p><ol start=1><li>可以混用位置实参和关键字实参，但是位置实参必须在关键字实参的左边。</li><li>可以混用位置实参和关键字实参，但不能对一个形参重复赋值。</li></ol><h1 class=pgc-h-arrow-right><strong>4.默认实参</strong></h1><p style=text-align:start>在定义阶段，就已经被赋值</p><pre><code>def func(x, y=10):    print(x)    print(y)    func(2)</code></pre><p>特点：在定义阶段就已经被赋值，意味着在调用时可以不用为其赋值</p><p style=text-align:start>注意：</p><ol start=1><li>位置形参必须放在默认形参的左边。</li><li>默认形参的值只在定义阶段赋值一次，也就是说默认参数的值在函数定义阶段就已经固定了。</li></ol><p style=text-align:start>默认参数的值通常应该是不可变类型</p><h1 class=pgc-h-arrow-right><strong>5.总结</strong></h1><p style=text-align:start>实参的应用：取决于个人习惯</p><p style=text-align:start>形参的应用：</p><ol start=1><li>大多数情况的调用值一样，就应该将该参数定义成位置形参</li><li>大多数情况的调用值一样，就应该将该参数定义成默认形参</li></ol><h1 class=pgc-h-arrow-right><strong>六、可变长参数</strong></h1><p style=text-align:start>可变长参数：指的是在调用函数时，传入的参数个数可以不固定</p><p style=text-align:start>调用函数时，传值的方式无非两种，一种是位置实参，另一种是关键字实参，因此形参也必须得有两种解决方法，以此来分别接收溢出的位置实参(*)与关键字实参(**)</p><pre><code>def self_max(a,b,c,d,e,f,g,h,k,x=1,y=3,z=4):  # 默认参数    print(a,b,c,d,e,f,g,h,k,x,y,z)# a= (1,2,3,4,5,6,7,8,9)a= [1,2,3,4,5,6,7,8,9]  # *把这个列表内的元素一个一个取出来,然后一个一个传给这个函数b = {'x':10,'y':12}  # **会把这个字典打散成键值对的形式作为实参传给函数self_max(*a,**b)  # 可变长实参 # (1,2,3,4,5,6,7,8,9,x=10,y=12)# self_max(1,2,3,4,5,6,7,8,9) # *a的作用# self_max(x=10,y=12)   # **b的作用</code></pre><h1 class=pgc-h-arrow-right><strong>1.可变长形参之*</strong></h1><p style=text-align:start>形参中的 * 会 将溢出的位置实参全部接收，然后存储元组的形式，然后把元组赋值给 * 后的参数。需要注意的是：*后的参数名约定俗成为args。</p><pre><code>def sum_self(*args):    res = 0    for num in args:        res += num    return resres = sum_self(1, 2, 3, 4)print(res)102.可变长实参之*实参中的，会将*后参数的值循环取出，打散成位置实参。以后但凡碰到实参中带 *的，它就是位置实参，应该马上打散成位置实参去看</code></pre><p>10</p><h1 class=pgc-h-arrow-right>2.可变长实参之*</h1><p style=text-align:start>实参中的<em>，</em>会将*后参数的值循环取出，打散成位置实参。以后但凡碰到实参中带 *的，它就是位置实参，应该马上打散成位置实参去看</p><pre><code>def func(x, y, z, *args):    print(x, y, z, args)func(1, *(1, 2), 3, 4)</code></pre><p>1 1 2 (3, 4)</p><h1 class=pgc-h-arrow-right><strong>3.可变长形参之**</strong></h1><p style=text-align:start>形参中的 ** 会将溢出的关键字实参全部接收，然后存储字典的形式，然后把字典赋值给 ** 后的参数。需要注意的是：**后的参数名约定俗成为kwargs</p><pre><code>def func(**kwargw):    print(kwargw)func(a=5)</code></pre><p>{'a': 5}</p><h1 class=pgc-h-arrow-right><strong>4.可变长实参之**</strong></h1><p style=text-align:start>实参中的** ，** 会将 ** 后参数的值循环取出，打散成关键字实参。以后但凡碰到实参中带** 的，它就是关键字实参，应该马上打散成关键字实参去看</p><pre><code>def func(x, y, z, **kwargs):    print(x, y, z, kwargs)func(1, 3, 4, **{'a': 1, 'b': 2})</code></pre><p>1 3 4 {'a': 1, 'b': 2}</p><h1 class=pgc-h-arrow-right>5.可变长参数应用</h1><pre><code># 可变长形参def self_max(*args,**kwargs):    print(args)  #*a接受了所有位置实参,然后以元祖的形式保存下来,只接受位置参数,不接受关键字实参    print(kwargs)  # **b接收所有的关键字实参,然后以字典的形式保存下来self_max(1,2,3,4,5,6,7,x=6,y=8,z=20,a=10,c=1000)# *后面必须得写args,**后面必须得写kwargs,约定俗成的一种规范</code></pre><h1 class=pgc-h-arrow-right><strong>6.命名关键字形参(了解)</strong></h1><p style=text-align:start>命名关键字形参：在函数定义阶段，*后面的参数都是命名关键字参数。</p><p style=text-align:start>特点：在传值时，必须按照key=value的方式传值，并且key必须命名关键字参数的指定的参数名</p><div class=pgc-img><img alt="Python -- 函数" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f37a722d91c0477bbcecf6dd90fad05c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Python','--','函数'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>