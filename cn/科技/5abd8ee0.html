<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经 | 极客快訊</title><meta property="og:title" content="四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/af6b4034b7db48f0907aff6d641e490c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5abd8ee0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5abd8ee0.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5abd8ee0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>导读</h1><p>前面文章<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6876269894007161348/?group_id=6876269894007161348?group_id=6876269894007161348" rel="noopener noreferrer" target=_blank>一、深入理解-Java集合初篇</a> 中我们对Java的集合体系进行一个简单的分析介绍，上两篇文章<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877007182232027655/?group_id=6877007182232027655?group_id=6877007182232027655" rel="noopener noreferrer" target=_blank>二、Jdk1.7和1.8中HashMap数据结构及源码分析</a> 、<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877050052326457860/?group_id=6877050052326457860?group_id=6877050052326457860" rel="noopener noreferrer" target=_blank>二、JDK1.7和1.8HashMap数据结构及源码分析-续</a> 中我们分别对JDK1.7和JDK1.8中HashMap的数据结构、主要声明变量、构造函数、HashMap的put操作方法做了深入的讲解和源码分析。<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877362834460639757/?group_id=6877362834460639757?group_id=6877362834460639757" rel="noopener noreferrer" target=_blank>三、深入理解Java中的HashMap「网易面试快答」</a> 文章中主要针对面试中常见的文件进行简单解答。</p><p><strong>本篇文章我们将要对JDK1.7中HashMap的哈希冲突及减少哈希冲突的解决方案做详细的介绍，并通过源码加深大家的理解。</strong></p><p><br></p><p><strong class=highlight-text>如果大家在面试中针对Java集合或者Java中的HashMap大家还有什么疑问或者其他问题，可以评论区告诉我。</strong></p><h1 class=pgc-h-arrow-right>简单介绍</h1><p>JDK1.7---》哈希表，链表</p><p>JDK1.8---》哈希表，链表，红黑树--- JDK1.8之后，当链表长度超过8使用红黑树。</p><p><strong class=highlight-text>非线程安全</strong></p><p><strong class=highlight-text>0.75的负载因子，扩容必须为原来的两倍。</strong></p><p><strong class=highlight-text>默认大小为16，传入的初始大小必须为2的幂次方的值，如果不为也会变为2的幂次方的值。</strong></p><p>根据HashCode存储数据。</p><h1 class=pgc-h-arrow-right>JDK1.7的哈希冲突解决方案</h1><h1 class=pgc-h-arrow-right>1.配置threshold：jdk.map.althashing.threshold（阀值-门槛）</h1><p><strong>配置改变hash冲突的门槛</strong></p><p><strong>源码：</strong></p><pre><code>/** * The default threshold of map capacity above which alternative hashing is * used for String keys. Alternative hashing reduces the incidence of * collisions due to weak hash code calculation for String keys. * &lt;p/&gt; * This value may be overridden by defining the system property * {@code jdk.map.althashing.threshold}. A property value of {@code 1} * forces alternative hashing to be used at all times whereas * {@code -1} value ensures that alternative hashing is never used. */static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</code></pre><p><strong></strong></p><p>-Djdk.map.althashing.threshold = -1: 表示不做优化（不配置这个值作用一样）<br>-Djdk.map.althashing.threshold &lt; 0: 报错</p><p>-Djdk.map.althashing.threshold = 1: 表示总是启用随机HashSeed<br>-Djdk.map.althashing.threshold >= 0 : 表示hashMap内部的数组长度超过该值了就使用随机HashSeed，降低碰撞</p><p><strong class=highlight-text>如果 配置该值为-1，表示不做hash冲突的优化；</strong></p><p><strong class=highlight-text>如果 配置该值小于0，则报错；</strong></p><p><strong class=highlight-text>如果 配置该值为1 则表示总是使用一个随机值（哈希因子hashseed）对hash冲突.</strong></p><p><strong class=highlight-text>如果 配置该值大于等于0 表示当HashMap中数组长度超过该值的时候就使用随机值（哈希因子hashseed）来降低哈希冲突的可能性。</strong></p><p></p><h1 class=pgc-h-arrow-right>2使用一个私有的静态内部类Holder加载虚拟机引导之后才被初始化的值。</h1><p>使用私有的静态内部类Holder加载上一步配置的Jdk.map.althashing.threshold。</p><p><strong>源码：</strong></p><pre><code>/** * The default threshold of map capacity above which alternative hashing is * used for String keys. Alternative hashing reduces the incidence of * collisions due to weak hash code calculation for String keys. * &lt;p/&gt; * This value may be overridden by defining the system property * {@code jdk.map.althashing.threshold}. A property value of {@code 1} * forces alternative hashing to be used at all times whereas * {@code -1} value ensures that alternative hashing is never used. */static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;/** * holds values which can't be initialized until after VM is booted. */private static class Holder {    /**     * Table capacity above which to switch to use alternative hashing.     */    static final int ALTERNATIVE_HASHING_THRESHOLD;    static {        String altThreshold = java.security.AccessController.doPrivileged(            new sun.security.action.GetPropertyAction(                "jdk.map.althashing.threshold"));        int threshold;        try {            threshold = (null != altThreshold)                    ? Integer.parseInt(altThreshold)                    : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;            // disable alternative hashing if -1            if (threshold == -1) {                threshold = Integer.MAX_VALUE;            }            if (threshold &lt; 0) {                throw new IllegalArgumentException("value must be positive integer.");            }        } catch(IllegalArgumentException failed) {            throw new Error("Illegal value for 'jdk.map.althashing.threshold'", failed);        }        ALTERNATIVE_HASHING_THRESHOLD = threshold;    }}/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. If 0 then * alternative hashing is disabled. */transient int hashSeed = 0;</code></pre><p><strong>源码解读：</strong></p><p>1、static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;</p><p>如果在上一步中没有配置“jdk.map.althashing.threshold”,则使用该值表示是否对HashMap中的哈希冲突做干扰。该值的默认值是Integer的最大值。表示只有当HashMap中数组容量达到Integer的最大值时候才会做哈希冲突的干扰。设置这个值这么大，其实就是不做哈希冲突干扰。</p><p>2、在私有的静态内部类Holder中做判断判断。</p><p>①加载（jdk.map.althashing.threshold）配置的altThreshold;</p><pre><code>String altThreshold = java.security.AccessController.doPrivileged(    new sun.security.action.GetPropertyAction(        "jdk.map.althashing.threshold"));</code></pre><p>②如果从配置中加载到的altThreshold不为空，则把threshold赋值为加载到的altThreshold;</p><p>如果没有配置该altThreshold则使用默认的ALTERNATIVE_HASHING_THRESHOLD_DEFAULT，即Integer.MAX_VALUE;</p><pre><code>threshold = (null != altThreshold)        ? Integer.parseInt(altThreshold)        : ALTERNATIVE_HASHING_THRESHOLD_DEFAULT;</code></pre><p>③如果在JDK中配置的jdk.map.althashing.threshold为默认值-1，则把threshold设置为Integer.MAX_VALUE;</p><pre><code>// disable alternative hashing if -1if (threshold == -1) {    threshold = Integer.MAX_VALUE;}</code></pre><p>④．如果在JDK中配置的jdk.map.althashing.threshold值小于0，则报错，表示该值不是一个有效值。</p><pre><code>if (threshold &lt; 0) {    throw new IllegalArgumentException("value must be positive integer.");}</code></pre><p>⑤．把经过计算的threshold的值赋值给“ALTERNATIVE_HASHING_THRESHOLD”.</p><p><strong class=highlight-text>也就是说最终是否对哈希冲突做干扰，或者在什么情况进行干扰是存储在“ALTERNATIVE_HASHING_THRESHOLD”中的。</strong></p><pre><code>ALTERNATIVE_HASHING_THRESHOLD = threshold;</code></pre><p>⑥．解决哈希冲突的干扰因子。根据上一步中计算的配置“ALTERNATIVE_HASHING_THRESHOLD”判断是否启用该干扰因子。</p><pre><code>/** * A randomizing value associated with this instance that is applied to * hash code of keys to make hash collisions harder to find. If 0 then * alternative hashing is disabled. */transient int hashSeed = 0;</code></pre><p><strong>从代码看出jdk.map.althashing.threshold这个变量设置的值最终会存放在静态常量ALTERNATIVE_HASHING_THRESHOLD</strong></p><h1 class=pgc-h-arrow-right>3.根据初始化的HashMap容量大小，决定干扰因子的值。</h1><p><strong>源码：</strong></p><pre><code>/**初始化哈希干扰的掩码值，我们把它的设置延迟到了真正使用它的时候。 * Initialize the hashing mask value. We defer initialization until we * really need it. */final boolean initHashSeedAsNeeded(int capacity) {   /**判断是否开启了hash干扰。如果hashseed 等于 0，则currentAltHashing = false;如果hashseed 不等于 0 ，则currentAltHashing = true;**/     boolean currentAltHashing = hashSeed != 0;/** 判断是否使用为干扰1.如果当前HashMap数组容量的大小等于jdk配置    中“jdk.map.althashing.threshold”的值时候，    且VM .isbooted 为true 时候，userAltHashing 为true;2.如果当前HashMap数组容量的小于jdk配置    中“jdk.map.althashing.threshold”的值时候，    且VM .isbooted 为true 时候，userAltHashing 为false;3. 如果当前HashMap数组容量的大小等于jdk配置    中“jdk.map.althashing.threshold”的值时候，    且VM .isbooted 为false 时候，userAltHashing 为false;4. 如果当前HashMap数组容量的小于jdk配置    中“jdk.map.althashing.threshold”的值时候，    且VM .isbooted 为false 时候，userAltHashing 为false;**/    boolean useAltHashing = sun.misc.VM.isBooted() &amp;&amp;            (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD);/** 对以上的两个值进行“异或”处理异或的结果为 两个值相同为0，两个值不同为1.也就是说 currentAltHashing 为true时且useAltHashing也为true时，或者 currentAltHashing 为false时且useAltHashing也为false时switching的结果为 true.其他情况时候，switching为false.**/    boolean switching = currentAltHashing ^ useAltHashing;    if (switching) {/**如果switching为true ，设置hashSeed(干扰因子)的值。如果useAltHashing的值为true，则随机一个干扰值给HashSeed。否则赋值为0.**/         hashSeed = useAltHashing            ? sun.misc.Hashing.randomHashSeed(this)            : 0;    }//返回是否启用干扰因子    return switching;}</code></pre><p><strong>源码解读：</strong></p><p><strong class=highlight-text>当hashMap扩大容量时，都是调用该方法。从代码可以看出，当数组容量超过，我们设定的值ALTERNATIVE_HASHING_THRESHOLD且是vm booted，同时 hashSeed==0的时候，hashSeed的值就是用随机量，而不是固定的等于0。这样就能降低碰撞，就能降低演化成链表概率。</strong></p><p><strong>代码具体过程：</strong></p><pre><code>当 hashSeed==0 则 currentAltHashing=false当 capacity &lt; Holder.ALTERNATIVE_HASHING_THRESHOLD 则currentAltHashing =false结果:switching=false 当 hashSeed==0 则 currentAltHashing=false当 capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD  则 currentAltHashing =true结果:switching=true  当 hashSeed !=0 则 currentAltHashing=true当 capacity &lt; Holder.ALTERNATIVE_HASHING_THRESHOLD  则 currentAltHashing =false结果:当 switching=true 当 hashSeed !=0 则 currentAltHashing=true当 capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD  则 currentAltHashing =true结果:switching=false</code></pre><p>回头再看代码，发现很巧妙</p><p>结论：</p><p>①.如果不配置“jdk.map.althashing.threshold”,则HashMap中的私有静态内部类中的’ALTERNATIVE_HASHING_THRESHOLD‘的值为Integer.MAX_VALUE，且HashSeed默认值为0，则switching的值永远为false，也就永远不会改变干扰因子（HashSeed）的值。</p><p>②．如果配置了“jdk.map.althashing.threshold”,则会根据当前HashMap中的数组容量动态的变更HashSeed的值，以便于引入HashSeed降低哈希冲突。</p><p>-Djdk.map.althashing.threshold=-1:表示不做优化（不配置这个值作用一样）<br>-Djdk.map.althashing.threshold&lt;0:报错</p><p>-Djdk.map.althashing.threshold=1:表示总是启用随机HashSeed<br>-Djdk.map.althashing.threshold>=0:便是hashMap内部的数组长度超过该值了就使用随机HashSeed，降低碰撞</p><h1 class=pgc-h-arrow-right>4.获取key的Hash值，位干扰。</h1><p><strong>源码：</strong></p><pre><code>/** * Retrieve object hash code and applies a supplemental hash function to the * result hash, which defends against poor quality hash functions.  This is * critical because HashMap uses power-of-two length hash tables, that * otherwise encounter collisions for hashCodes that do not differ * in lower bits. Note: Null keys always map to hash 0, thus index 0. */final int hash(Object k) {/** 获取哈希干扰因子，该因子会跟根据HashMap的容量进行变更变更情况根据上一步的“final boolean initHashSeedAsNeeded(int capacity)”方法动态变更**/     int h = hashSeed;//如果为干扰因子不为0，且传入的key类型为String,则使用特定的算法（sun.misc.Hashing.stringHash32((String) k)）对该key进行hash计算。并返回    if (0 != h &amp;&amp; k instanceof String) {        return sun.misc.Hashing.stringHash32((String) k);    }//如果哈希干扰因子为0 或者 k的类型不为String则使用异或操作变更key的hashcode    h ^= k.hashCode();//为了减少Hash冲突出现次数进行必要的位干扰，默认负载因子是8.    // This function ensures that hashCodes that differ only by    // constant multiples at each bit position have a bounded    // number of collisions (approximately 8 at default load factor).    h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);    return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);}</code></pre><p><strong>源码解读：</strong></p><p>可以看出生成的hash值和hashSeed 这个值有着紧密的关系，但是这个值默认是0。也就是说不管HashMap存多少数据，hashSeed 都是不会变的，可以看出随着hashMap 的容量增大，hash碰撞的概率增大的可能性也就增大。如果hash值，碰撞很高的话，那么hashMap逐渐演化成链表，性能就急剧下降。</p><p>在hash(Object k)中有这么一段位运算的代码：</p><pre><code>h ^= k.hashCode();h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12);return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);</code></pre><p>看起来既简单又深奥的样子，让我们来看看这段代码隐藏的东西吧。</p><p>k.hashCode()函数调用的是key键值类型自带的哈希函数，由于不同的对象其hashCode()有可能相同，所以需对hashCode()再次哈希，以降低相同率。</p><p>接下来的一串与运算和异或运算，称之为“扰动函数”，扰动的核心思想在于使计算出来的值在保留原有相关特性的基础上，增加其值的不确定性，从而降低冲突的概率。不同的版本实现的方式不一样，但其根本思想是一致的。<br>这里的具体实现方式是如何保证的呢？笔者功力浅薄，暂时还没有答案，如果有朋友知道的话可以交流。但是，“扰动函数”的核心思想一定要明白。</p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/af6b4034b7db48f0907aff6d641e490c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>往期文章链接</h1><p><strong>Java集合</strong></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6876269894007161348/?group_id=6876269894007161348?group_id=6876269894007161348" rel="noopener noreferrer" target=_blank>一、深入理解-Java集合初篇</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877007182232027655/?group_id=6877007182232027655?group_id=6877007182232027655" rel="noopener noreferrer" target=_blank>二、Jdk1.7和1.8中HashMap数据结构及源码分析</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877050052326457860/?group_id=6877050052326457860?group_id=6877050052326457860" rel="noopener noreferrer" target=_blank>二、JDK1.7和1.8HashMap数据结构及源码分析-续</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877362834460639757/?group_id=6877362834460639757?group_id=6877362834460639757" rel="noopener noreferrer" target=_blank>三、深入理解Java中的HashMap「网易面试快答」</a></p><p><br></p><p><strong>Java-IO体系</strong></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6873764446930633230/?group_id=6873764446930633230" rel="noopener noreferrer" target=_blank>一、JAVA IO/NIO体系介绍</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6873765094426313219/?group_id=6873765094426313219" rel="noopener noreferrer" target=_blank>二、网络IO原理-创建ServerSocket-彻底弄懂IO</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6873765826462220814/?group_id=6873765826462220814" rel="noopener noreferrer" target=_blank>三、JAVA中ServerSocket调用Linux系统内核</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6874772531308724750/?group_id=6874772531308724750" rel="noopener noreferrer" target=_blank>四、「大厂职员教你」IO进化过程之BIO</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6874782223262810635/?group_id=6874782223262810635" rel="noopener noreferrer" target=_blank>五、「大厂职员教你」Java-IO进化过程之NIO</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875153531486077448/?group_id=6875153531486077448" rel="noopener noreferrer" target=_blank>六、Selector实现Netty中Reactor单线程模型</a></p><p><br><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875498967183032840/?group_id=6875498967183032840" rel="noopener noreferrer" target=_blank>七、Selector实现Netty中Reactor主从模型</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875960048917414407/?group_id=6875960048917414407" rel="noopener noreferrer" target=_blank>八、Netty入门服务端代码</a></p><p><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877376837149065741/?group_id=6877376837149065741" rel="noopener noreferrer" target=_blank>九、IO进化过程之EVENT（EPOLL-事件驱动异步模型）</a></p><p>如需了解更多更详细内容也可关注本人CSDN博客：<strong>不吃_花椒</strong></p><h1 class=pgc-h-arrow-right>Java集合还需要学习的内容</h1><p><br></p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/525daadbc273400c9608cc01da77bed7><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4c1effd30384d50974b96b130200436><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=四、JDK1.7中HashMap哈希冲突解决方案-阿里面试经 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/21837c954b8b448fab8a03b1a0bbe55c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JDK1.7','HashMap','哈希'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>