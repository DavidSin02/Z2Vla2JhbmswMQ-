<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 | 极客快訊</title><meta property="og:title" content="动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2213ae70bb254bdcb7c9305d0a560b20"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5b8b8a5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5b8b8a5.html><meta property="article:published_time" content="2020-10-29T20:50:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:28+08:00"><meta name=Keywords content><meta name=description content="动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5b8b8a5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>TCP是一个面向连接的协议，任何一方在发送数据之前，都必须先在双方之间建立一条连接。所以，本文就主要看看TCP连接的建立和终止。</p><p>在开始介绍TCP连接之前，先来看看TCP数据包的首部，首部里面有很多重要的字段，在我们实现程序的时候需要进行设置。</p><h1>TCP的首部</h1><p>在OSI七层模型中，上层的数据包都会作为下层数据包的数据部分（payload）。</p><p>也就是说，当构造TCP数据包的时候，会把应用层的数据包作为TCP包的数据部分，然后加上TCP头构成TCP数据包；同样，当构造IP数据包的时候，整个TCP包就会被当作数据部分，然后加上IP头构成IP数据包。</p><div class=pgc-img><img alt=动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2213ae70bb254bdcb7c9305d0a560b20></div><p>TCP头的数据格式如下，在不包括可选字段的情况下，一般TCP头会占用20个字节。</p><div class=pgc-img><img alt=动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6f2c33f651c44c8fa261039e49333852></div><p><strong>在TCP首部中，有几个字段是需要关注一下：</strong></p><ul><li>在TCP首部中没有源和目标的IP、MAC地址（IP和MAC地址分别是网络层和链路层首部的信息），只有源和目标的端口</li><li>Sequence Number是包的序号，网络层（IP层）的传输是不可靠的，可能产生包乱序，所以这个需要可以解决网络包乱序的问题</li><li>Acknowledgement Number用来确认收到数据包的确认序号，为TCP的传输提供了可靠性保证</li><li>TCP Flags包括了8个bit，通过对这些bit的设置，可以代表不同类型的TCP数据包</li></ul><p>下面就看看TCP连接的建立和终止。</p><h1>TCP连接建立</h1><p>TCP连接建立的过程被称为三次握手过程：</p><ol><li>连接建立发起端发送[SYN]包，该端将主动打开（active open）</li><li>接收端将发送[SYN, ACK]包，该端将被动打开（passive open），ACK标志表示对收到的[SYN]包的确认</li><li>连接建立发起端发送[ACK]包确认[SYN, ACK]包</li></ol><div class=pgc-img><img alt=动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52b3e6184085488b8a6680a0259c8f69></div><h1>Initial Sequence Number</h1><p>连接建立过程中，一个重要的工作就是初始化Sequence Number，通信的双方在建立连接的过程中互相通知对方自己的初始Sequence Number（ISN：Initial Sequence Number）。ISN不是固定的，ISN跟时钟绑定，根据特定的间隔自增，直到超过2^32，又从0开始。</p><p>SYN全称就是Synchronize Sequence Number，通过seq序号，TCP就可以保证数据包的顺序；通过ack序号，TCP就有了可靠性。</p><h1>连接建立注意点</h1><p>在建立TCP连接的过程中，有以下两点需要注意一下：</p><ol><li>[SYN]标志的数据包会使用消耗一个序号，所以对端的确认号（ack）是当前序号（seq）加一</li><li>当被动打开端发送[ACK]确认包的时候，同时设置了[SYN]标志，所以TCP连接建立的过程只需要三次握手，而不是四次</li></ol><h1>TCP连接终止</h1><p>TCP连接终止的过程被称为四次挥手过程，以下图为例：</p><ol><li>连接终止端（client）发送[FIN, ACK] 包，关闭client到server方向的数据发送通路</li><li>server端发送[ACK]包来确认来自client的[FIN, ACK] 包</li><li>server端发送[FIN, ACK] 包，关闭server到client方向的数据发送通路</li><li>client端发送[ACK]包来确认来自server的[FIN, ACK] 包，到此TCP连接关闭</li></ol><div class=pgc-img><img alt=动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3bacf62a29ee4c08939ed6de4f5db07b></div><h1>连接终止注意点</h1><p>在建立TCP连接的过程中，有以下两点需要注意一下：</p><ul><li>[FIN]标志的数据包会使用消耗一个序号，所以对端的确认号（ack）是当前序号（seq）加一</li><li>与建立连接时的三次 握手不同，终止连接需要四次挥手因为TCP连接是全双工的，每个方向都必须单独进行关闭。当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，但是TCP连接在收到一个FIN后仍能发送数据</li></ul><h1>TCP连接实验</h1><p>好了，了解了TCP连接建立和终止的基本知识后，就可以通过Pcap.Net来进行TCP连接建立和终止的实验了。</p><p>建立连接代码的基本流程如下：</p><ol><li>client程序使用一个初始的seq序号（100），然后生成并发送一个带[SYN]标志的TCP包</li><li>client将期待来自服务端的[SYN, ACK]包</li><li>当收到[SYN, ACK]包之后，client需要生成并发送一个[ACK]包进行确认，这个[ACK]包的ack号是[SYN, ACK]包seq号加一</li></ol><p>终止连接代码的基本流程如下：</p><ol><li>client程序delay 10秒钟，然后发送[FIN, ACK]包关闭client到server的通路，继续使用全局的seq号</li><li>client将期待来自服务端的[ACK]包，以及[FIN, ACK]包</li><li>最后client发送[ACK]包，seq号需要加一，因为[FIN]标志的包将消耗一个序号，TCP连接终止完成</li></ol><p>主程序如下，发送TCP连接建立和终止请求，每个请求发送后都用PacketHandler处理收到的包：</p><p>communicator.SendPacket(Utils.BuildTcpPacket(endPointInfo, TcpControlBits.Synchronize, null));</p><p>PacketHandler(communicator, endPointInfo);</p><p>// delay 10 secs, then client to send Fin</p><p>Thread.Sleep(10000);</p><p>communicator.SendPacket(Utils.BuildTcpPacket(endPointInfo, TcpControlBits.Fin | TcpControlBits.Acknowledgment));</p><p>PacketHandler(communicator, endPointInfo);</p><p>程序的主要逻辑在PacketHandler中，这个函数根据收到的不同TCP包的类型完成不同的逻辑，产生并发送不同类型的包。</p><p>例如，当PacketHandler接收到来自服务端的[SYN, ACK]包后，处理函数就会生成并发送一个[ACK]确认包。也就是说，PacketHandler的逻辑就是实现了TCP连接建立和终止的逻辑。</p><p>private static void PacketHandler(PacketCommunicator communicator, EndPointInfo endPointInfo)</p><p>{</p><p>Packet packet = null;</p><p>bool running = true;</p><p>do</p><p>{</p><p>PacketCommunicatorReceiveResult result = communicator.ReceivePacket(out packet);</p><p>switch (result)</p><p>{</p><p>case PacketCommunicatorReceiveResult.Timeout:</p><p>// Timeout elapsed</p><p>continue;</p><p>case PacketCommunicatorReceiveResult.Ok:</p><p>bool isRecvedPacket = (packet.Ethernet.IpV4.Destination.ToString() == endPointInfo.SourceIp) ? true : false;</p><p>if (isRecvedPacket)</p><p>{</p><p>switch (packet.Ethernet.IpV4.Tcp.ControlBits)</p><p>{</p><p>case (TcpControlBits.Synchronize | TcpControlBits.Acknowledgment):</p><p>Utils.PacketInfoPrinter(packet);</p><p>Packet ack4SynAck = Utils.BuildTcpResponsePacket(packet, TcpControlBits.Acknowledgment);</p><p>communicator.SendPacket(ack4SynAck);</p><p>break;</p><p>case (TcpControlBits.Fin | TcpControlBits.Acknowledgment):</p><p>Utils.PacketInfoPrinter(packet);</p><p>Packet ack4FinAck = Utils.BuildTcpResponsePacket(packet, TcpControlBits.Acknowledgment);</p><p>communicator.SendPacket(ack4FinAck);</p><p>break;</p><p>case TcpControlBits.Acknowledgment:</p><p>Utils.PacketInfoPrinter(packet);</p><p>break;</p><p>default:</p><p>Utils.PacketInfoPrinter(packet);</p><p>break;</p><p>}</p><p>}</p><p>else</p><p>{</p><p>switch (packet.Ethernet.IpV4.Tcp.ControlBits)</p><p>{</p><p>case (TcpControlBits.Fin | TcpControlBits.Acknowledgment):</p><p>Utils.PacketInfoPrinter(packet);</p><p>break;</p><p>case TcpControlBits.Synchronize:</p><p>Utils.PacketInfoPrinter(packet);</p><p>break;</p><p>case TcpControlBits.Acknowledgment:</p><p>Utils.PacketInfoPrinter(packet);</p><p>running = false;</p><p>break;</p><p>default:</p><p>Utils.PacketInfoPrinter(packet);</p><p>break;</p><p>}</p><p>}</p><p>break;</p><p>default:</p><p>throw new InvalidOperationException("The result " + result + " should never be reached here");</p><p>}</p><p>} while (running);</p><p>}</p><p>在PacketHandler函数中用到了BuildTcpResponsePacket这个函数，这个函数根据收到的TCP包，来构建response包。</p><p>这个函数有下面几个注意点：</p><ul><li>该函数会根据收到的包，设置response包的源和目的地址</li><li>该函数会接受PacketHandler传递来的TCP flags，并设置到TCP首部中</li><li>该函数的另一个重要部分就是会计算并设置TCP首部中的seq号ack号，这一点很重要</li></ul><p>public static Packet BuildTcpResponsePacket(Packet packet, TcpControlBits tcpControlBits)</p><p>{</p><p>EthernetLayer ethernetHeader = new EthernetLayer</p><p>{</p><p>Source = new MacAddress(packet.Ethernet.Destination.ToString()),</p><p>Destination = new MacAddress(packet.Ethernet.Source.ToString()),</p><p>EtherType = EthernetType.None, // Will be filled automatically.</p><p>};</p><p>IpV4Layer ipHeader = new IpV4Layer</p><p>{</p><p>Source = new IpV4Address(packet.Ethernet.IpV4.Destination.ToString()),</p><p>CurrentDestination = new IpV4Address(packet.Ethernet.IpV4.Source.ToString()),</p><p>Fragmentation = IpV4Fragmentation.None,</p><p>HeaderChecksum = null, // Will be filled automatically.</p><p>Identification = 123,</p><p>Options = IpV4Options.None,</p><p>Protocol = null, // Will be filled automatically.</p><p>Ttl = 100,</p><p>TypeOfService = 0,</p><p>};</p><p>TcpLayer tcpHeader = new TcpLayer</p><p>{</p><p>SourcePort = packet.Ethernet.IpV4.Tcp.DestinationPort,</p><p>DestinationPort = packet.Ethernet.IpV4.Tcp.SourcePort,</p><p>Checksum = null, // Will be filled automatically.</p><p>SequenceNumber = seqNum = packet.Ethernet.IpV4.Tcp.AcknowledgmentNumber,</p><p>AcknowledgmentNumber = ackNum = packet.Ethernet.IpV4.Tcp.SequenceNumber + (uint)((packet.Ethernet.IpV4.Tcp.Payload.Length > 0) ? packet.Ethernet.IpV4.Tcp.Payload.Length : 1),</p><p>ControlBits = tcpControlBits,</p><p>Window = windowSize,</p><p>UrgentPointer = 0,</p><p>Options = TcpOptions.None,</p><p>};</p><p>PacketBuilder builder = new PacketBuilder(ethernetHeader, ipHeader, tcpHeader);</p><p>return builder.Build(DateTime.Now);</p><p>}</p><h1>运行效果</h1><p>打开Wireshark监听"VirtualBox Host-Only Network"网卡，并设置filter为"port 8081"。</p><p>然后运行程序，通过console可以看到客户端发送的包，以及服务端返回的包，通过这些包完成了TCP连接的建立和终止。</p><div class=pgc-img><img alt=动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22a89c80460443b3889c134c8d43e75a></div><p>下面是Wireshark中显示的结果，Wireshark比较友好，会显示相对seq号，所以看到的都是从0开始编号。</p><p>注意seq号和ack号的变化，[SYN]和[FIN]标志的TCP包都会消耗一个序号。</p><div class=pgc-img><img alt=动手学习TCP：TCP连接建立与终止，它是一个面向连接的协议 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2a16e7e8b6d4497bbe1b7c3841e6a89d></div><h1>总结</h1><p>本文介绍了TCP首部，通过设置TCP首部中的[SYN]标志，可以构造TCP连接建立请求包；通过设置[FIN]标志，可以构造TCP连接终止请求包。</p><p>文中使用Pcap.Net构建了一个简单的客户端，完成了向服务器建立（三次握手）和终止（四次挥手）连接的过程。</p><p>通过这个实验，一定会对TCP连接的建立和终止有一个比较直观的认识。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'TCP','连接','动手'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>