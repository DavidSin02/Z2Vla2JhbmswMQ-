<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux系统调用详解（实现机制分析） | 极客快訊</title><meta property="og:title" content="Linux系统调用详解（实现机制分析） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5cf7cc6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5cf7cc6.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="Linux系统调用详解（实现机制分析）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5cf7cc6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux系统调用详解（实现机制分析）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用概述</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">计算机系统的各种硬件资源是有限的，在现代多任务操作系统上同时运行的多个进程都需要访问这些资源，为了更好的管理这些资源进程是不允许直接操作的，所有对这些资源的访问都必须有操作系统控制。也就是说操作系统是使用这些资源的唯一入口，而这个入口就是操作系统提供的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用（System Call）</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。在linux中系统调用是用户空间访问内核的唯一手段，除异常和陷入外，他们是内核唯一的合法入口。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般情况下应用程序通过应用编程接口API，而不是直接通过系统调用来编程。在Unix世界，最流行的API是基于POSIX标准的。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">操作系统一般是通过中断从用户态切换到内核态。中断就是一个硬件或软件请求，要求CPU暂停当前的工作，去处理更重要的事情。比如，在x86机器上可以通过int指令进行软件中断，而在磁盘完成读写操作后会向CPU发起硬件中断。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">中断有两个重要的属性，中断</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">号</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和中断处理程序。中断号用来标识不同的中断，不同的中断具有不同的中断处理程序。在操作系统内核中维护着一个中断向量表（Interrupt Vector Table），这个数组存储了所有中断处理程序的地址，而中断号就是相应中断在中断向量表中的偏移量。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般地，系统调用都是通过软件中断实现的，x86系统上的软件中断由int $0x80指令产生，而128号异常处理程序就是系统调用处理程序system_call()，它与硬件体系有关，在entry.S中用汇编写。接下来就来看一下Linux下系统调用具体的实现过程。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">为什么需要系统调用</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">linux内核中设置了一组用于实现系统功能的子程序，称为系统调用。系统调用和普通库函数调用非常相似，只是系统调用由操作系统核心提供，运行于</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">内核态</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，而普通的函数调用由函数库或用户自己提供，运行于</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用户态</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般的，进程是不能访问内核的。它不能访问内核所占内存空间也不能调用内核函数。CPU硬件决定了这些（这就是为什么它被称作</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">“保护模式”</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">）。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">为了和用户空间上运行的进程进行交互，内核提供了一组接口。透过该接口，应用程序可以访问硬件设备和其他操作系统资源。这组接口在应用程序和内核之间扮演了使者的角色，应用程序发送各种请求，而内核负责满足这些请求(或者让应用程序暂时搁置)。实际上提供这组接口主要是为了保证系统稳定可靠，避免应用程序肆意妄行，惹出大麻烦。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用在用户空间进程和硬件设备之间添加了一个中间层。该层主要作用有三个：</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1、它为用户空间提供了一种统一的硬件的抽象接口。比如当需要读些文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2、系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限和其他一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确地使用硬件设备，窃取其他进程的资源，或做出其他什么危害系统的事情。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">3、每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核的</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">惟一</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">手段；除异常和中断外，它们是内核惟一的合法入口。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">API/POSIX/C库的区别与联系</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一般情况下，应用程序通过应用编程接口(API)而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用一一对应。</span></p><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。</span></span></p></blockquote><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在Unix世界中，最流行的应用编程接口是基于POSIX标准的，其目标是提供一套大体上基于Unix的可移植操作系统标准。POSIX是说明API和系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX而定义的API函数和系统调用之间有着直接关系。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供如下图所示。C库实现了 Unix系统的主要API，包括标准C库函数和系统调用。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">从程序员的角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数及应用程序是怎么使用系统调用不是内核所关心的。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">关于Unix的界面设计有一句通用的格言“提供机制而不是策略”。换句话说，Unix的系统调用抽象出了用于完成某种确定目的的函数。</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">至干</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这些函数怎么用完全不需要内核去关心。区别对待机制(mechanism)和策略(policy)是Unix设计中的一大亮点。大部分的编程问题都可以被切割成两个部分:“需要提供什么功能”(机制)和“怎样实现这些功能”(策略)。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">区别</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">api是函数的定义，规定了这个函数的功能，跟内核无直接关系。而系统调用是通过中断向内核发请求，实现内核提供的某些服务。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">联系</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一个api可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。<br>程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。<br>因此，API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。<br>系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。<br>并不是所有的API函数都一一对应一个系统调用，有时，一个API函数会需要几个系统调用来共同完成函数的功能，甚至还有一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</span></p><p style=text-align:start><strong>需要C/C++ Linux高级服务器架构师学习资料后台私信“资料”（包括C/C++，Linux，golang技术，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒体，CDN，P2P，K8S，Docker，TCP/IP，协程，DPDK，ffmpeg等）</strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用的实现原理</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">基本机制</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">前文已经提到了Linux下的系统调用是通过0x80实现的，但是我们知道操作系统会有多个系统调用（Linux下有319个系统调用），而对于同一个中断号是如何处理多个不同的系统调用的？最简单的方式是对于不同的系统调用采用不同的中断号，但是中断号明显是一种稀缺资源，Linux显然不会这么做；还有一个问题就是系统调用是需要提供参数，并且具有返回值的，这些参数又是怎么传递的？也就是说，对于系统调用我们要搞清楚两点：</span></p><ol start=1><li>1.系统调用的函数名称转换。</li><li>2.系统调用的参数传递。</li></ol><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">首先看第一个问题。实际上，Linux中每个系统调用都有相应的系统调用号作为唯一的标识，内核维护一张系统调用表，sys_call_table，表中的元素是系统调用函数的起始地址，而系统调用号就是系统调用在调用表的偏移量。在x86上，系统调用号是通过eax寄存器传递给内核的。比如fork（）的实现：</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用户空间的程序无法直接执行内核代码。它们不能直接调用内核空间中的函数，因为内核驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统安全就会失去控制。所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序来执行该系统调用了。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通知内核的机制是靠软件中断实现的。首先，用户程序为系统调用设置参数。其中一个参数是系统调用编号。参数设置完成后，程序执行“系统调用”指令。x86系统上的软中断由int产生。这个指令会导致一个异常：产生一个事件，这个事件会致使处理器切换到内核态并跳转到一个新的地址，并开始执行那里的异常处理程序。此时的异常处理程序实际上就是系统调用处理程序。它与硬件体系结构紧密相关。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">新地址的指令会保存程序的状态，计算出应该调用哪个系统调用，调用内核中实现</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">那个</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用的函数，恢复用户程序状态，然后将控制权返还给用户程序。系统调用是设备驱动程序中定义的函数最终被调用的一种方式。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">从系统分析的角度，linux的系统调用涉及4个方面的问题。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">响应函数</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_xxx</span></span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">响应函数名以“sys_”开头，后跟该系统调用的名字。</span></p><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">例如</span></span></p><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">系统调用</span></span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">fork()</span></span>的响应函数是<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_fork()</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">Kernel/fork.c</span></span>),</p><p><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">exit()</span></span>的响应函数是<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_exit()</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">kernel/fork.</span></span>)。</p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用表与系统调用号-=>数组与下标</span></h1><hr><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">文件</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">include/asm/unisted.h</span></span>为每个系统调用规定了唯一的编号。</p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/118c01f3d890476f8fe254c21f8f0cad><p class=pgc-img-caption></p></div><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">在我们系统中/usr/include/asm/unistd_32.h，可以通过find / -name unistd_32.h -print查找）<br>而内核中的头文件路径不同的内核版本以及不同的发行版，文件的存储结构可能有所区别</span></span></p></blockquote><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/59cc1fbf068b4912a5bb2241de256fd6><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5d2530cd229a416f973080c77ee3d8fa><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ee6627baf804e72b59192004c49016d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71e628fdd8084f2a8035ea867abe8b13><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">假设用name表示系统调用的名称，那么系统调用号与系统调用</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">响应</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">函数的关系是：以系统调用号</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_NR_name</span></span>作为下标，可找出系统调用表<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/entry.S</span></span>)中对应表项的内容，它正好是该系统调用的响应函数<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_name</span></span>的入口地址。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用表</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>记录了各<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_name</span></span>函数在表中的位置，共190项。有了这张表，就很容易根据特定系统调用</p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5fc645c423da4a06877c5a24443a7d06><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在表中的偏移量，找到对应的系统调用</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">响应</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">函数的入口地址。系统调用表共256项，余下的项是可供用户自己添加的系统调用空间。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就被用来指明到底是要执行哪个系统调用。进程不会提及系统调用的名称。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用号相当关键，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。Linux有一个“未实现”系统调用</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_ni_syscall()</span></span>，它除了返回一<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ENOSYS</span></span>外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设的。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">因为所有的系统调用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">x86</span></span>上，系统调用号是通过<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">eax</span></span>寄存器传递给内核的。在陷人内核之前，用户空间就把相应系统调用所对应的号放入<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">eax</span></span>中了。这样系统调用处理程序一旦运行，就可以从<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">eax</span></span>中得到数据。其他体系结构上的实现也都类似。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>中。它与体系结构有关，一般在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">entry.s</span></span>中定义。这个表中为每一个有效的系统调用指定了惟一的系统调用号。<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table</span></span>是一张由指向实现各种系统调用的内核函数的函数指针组成的表：<br><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system_call()</span></span>函数通过将给定的系统调用号与<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">NR_syscalls</span></span>做比较来检查其有效性。如果它大于或者等于<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">NR syscalls</span></span>,该函数就返回一<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ENOSYS</span></span>。否则，就执行相应的系统调用。</p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed6cc376c01c44faadabf8a3890bb288><p class=pgc-img-caption></p></div><pre><code> call *sys_ call-table(，%eax, 4)1</code></pre><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">由于系统调用表中的表项是以32位(4字节)类型存放的，所以内核需要将给定的系统调用号乘以4，然后用所得的结果在该表中查询其位置</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">进程的系统调用命令转换为INT 0x80中断的过程</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">宏定义</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscallN()</span></span>见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">include/asm/unisted.h</span></span>)用于系统调用的格式转换和参数的传递。N取0~5之间的整数。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">参数个数为N的系统调用由_syscallN()负责格式转换和参数传递。系统调用</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">号</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">放入EAX寄存器，启动INT 0x80后，规定返回值送EAX寄存器。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用功能模块的初始化</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对系统调用的初始化也就是对</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">INT 0x80</span></span>的初始化。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统启动时，汇编子程序</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">setup_idt</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/head.S</span></span>)准备了1张256项的idt表，由<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">start_kernel()</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">init/main.c),trap_init()</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/traps.c</span></span>)调用的C语言宏定义<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">set_system_gate(0x80,&system_call)</span></span>(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">include/asm/system.h</span></span>)设置<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">0x80</span></span>号软中断的服务程序为 system_call(见<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/i386/kernel/entry.S</span></span>), <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system.call</span></span>就是所有系统调用的总入口。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">内核如何为各种系统调用服务</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当进程需要进行系统调用时，必须以C语言函数的形式写一句系统调用命令。该命令如果已在某个头文件中由相应的</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscallN()</span></span>展开，则用户程序必须包含该文件。当进程执行到用户程序的系统调用命令时，实际上执行了由宏命令_syscallN()展开的函数。系统调用的参数 由各通用寄存器传递，然后执行INT 0x80，以内核态进入入口地址<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system_call</span></span>。</p><h1 class=pgc-h-arrow-right><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ret_from_sys_call</span></span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ret_from_sys_call</span></span>入口的汇编程序段在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">linux</span></span>进程管理中起到了十分重要的作用。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">所有系统调用结束前以及大部分</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">中断</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">服务返回前，都会跳转至此处入口地址。 该段程序不仅仅为系统调用服务，它还处理中断嵌套、CPU调度、信号等事务。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">内核如何为系统调用的参数传递参数</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">参数传递</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">除了系统调用号以外，大部分系统调用都还需要一些外部的参数</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输人</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。所以，在发生异常的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号一样把这些参数也存放在寄存器里。在x86系统上，</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ebx</span></span>, <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ecx</span></span>, <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">edx</span></span>, <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">esi</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">edi</span></span>按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在eax寄存器中。接下来许多关于系统调用处理程序的描述都是针对x86版本的。但不用担心，所有体系结构的实现都很类似。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">参数验证</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用必须仔细检查它们所有的参数是否合法有效。举例来说，与文件I/O相关的系统调用必须检查文件描述符是否有效。与进程相关的函数必须检查提供的PID是否有效。必须检查每个参数，保证它们不但合法有效，而且正确。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最重要的一种检查就是检查用户提供的指针是否有效。试想，如果一个进程可以给内核传递指针而又无须被检查，那么它就可以给出一个它根本就没有访问权限的指针，哄骗内核去为它拷贝本不允许它访问的数据，如原本属于其他进程的数据。在接收一个用户空间的指针之前，内核必须保证：</span></p><ul><li><span style="color:#4d4d4d;--tt-darkmode-color: #999999">指针指向的内存区域属于用户空间。进程决不能哄骗内核去读内核空间的数据。</span></li><li><span style="color:#4d4d4d;--tt-darkmode-color: #999999">指针指向的内存区域在进程的地址空间里。进程决不能哄骗内核去读其他进程的数据。</span></li><li><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果是读，该内存应被标记为可读。如果是写，该内存应被标记为可写。进程决不能绕过内存访问限制。</span></li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">内核提供了两个方法来完成必须的检查和内核空间与用户空间之间数据的来回拷贝。注意，内核无论何时都不能轻率地接受来自用户空间的指针!这两个方法中必须有一个被调用。为了向用户空间写入数据，内核提供了</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_to_user()</span></span>，它需要三个参数。第一个参数是进程空间中的目的内存地址。第二个是内核空间内的源地址。最后一个参数是需要拷贝的数据长度(字节数)。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">为了从用户空间读取数据，内核提供了</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_from_ user()</span></span>，它和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy-to-User()</span></span>相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度由第三个参数决定。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数。如果成功，返回0。当出现上述错误时，系统调用返回标准-EFAULT。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_to_user()</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">copy_from_user()</span></span>都有可能引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，这种情况就会发生。此时，进程就会休眠，直到缺页处理程序将该页从硬盘重新换回物理内存。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用的返回值</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">系统调用(在Linux中常称作syscalls)通常通过函数进行调用。它们通常都需要定义一个或几个参数(输入)而且可能产生一些副作用，例如写某个文件或向给定的指针拷贝数据等等。为防止和正常的返回值混淆，系统调用并不直接返回错误码，而是将错误码放入一个名为errno的全局变量中。通常用一个负的返回值来表明错误。返回一个0值通常表明成功。如果一个系统调用失败，你可以读出errno的值来确定问题所在。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。</span></p><p style=text-align:start><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>不同数值所代表的错误消息定义在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno.h</span></span>中，你也可以通过命令”man 3 errno”来察看它们。需要注意的是，<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>的值只在函数发生错误时设置，如果函数不发生错误，<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>的值就无定义，并不会被置为0。另外，在处理<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>前最好先把它的值存入另一个变量，因为在错误处理过程中，即使像<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">printf()</span></span>这样的函数出错时也会改变<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">errno</span></span>的值。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当然，系统调用最终具有一种明确的操作。举例来说，如getpid()系统调用，根据定义它会返回当前进程的PID。内核中它的实现非常简单:</span></p><pre><code>asmlinkage long sys_ getpid(void){    return current-&gt; tgid;}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">上述的系统调用尽管非常简单，但我们还是可以从中发现两个特别之处。首先，注意函数声明中的asmlinkage限定词，这是一个小</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">戏法</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，用于通知编译器仅从栈中提取该函数的参数。所有的系统调用都需要这个限定词。其次，注意系统调用get_pid()在内核中被定义成sys_ getpid。这是Linux中所有系统调用都应该遵守的命名规则。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">访问系统调用</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用上下文</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">内核在执行系统调用的时候处于进程上下文。</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">current</span></span>指针指向当前任务，即引发系统调用的那个进程。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在进程上下文中，内核可以休眠并且可以被抢占。这两点都很重要。首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能。休眠的能力会给内核编程带来极大便利。在进程上下文中能够被抢占，其实表明，像用户空间内的进程一样，当前的进程同样可以被其他进程抢占。因为新的进程可以使用相同的系统调用，所以必须小心，保证该系统调用是可重人的。当然，这也是在对称多处理中必须同样关心的问题。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当系统调用返回的时候，控制权仍然在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">system_call()</span></span>中，它最终会负责切换到用户空间并让用户进程继续执行下去。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用访问示例</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">操作系统使用系统调用表将系统调用编号翻译为特定的系统调用。系统调用表包含有实现每个系统调用的函数的地址。例如，</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">read()</span></span> 系统调用函数名为<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read</span></span>。<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">read()</span></span>系统调用编号是 3，所以<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span> 位于系统调用表的第四个条目中（因为系统调用起始编号为0）。从地址 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_call_table + (3 * word_size)</span></span> 读取数据，得到<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span>的地址。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">找到正确的系统调用地址后，它将控制权转交给那个系统调用。我们来看定义</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span>的位置，即<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">fs/read_write.c</span></span>文件。这个函数会找到关联到 fd 编号（传递给 read() 函数的）的文件结构体。那个结构体包含指向用来读取特定类型文件数据的函数的指针。进行一些检查后，它调用与文件相关的 read() 函数，来真正从文件中读取数据并返回。与文件相关的函数是在其他地方定义的 —— 比如套接字代码、文件系统代码，或者设备驱动程序代码。这是特定内核子系统最终与内核其他部分协作的一个方面。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">读取函数结束后，从</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">sys_read()</span></span>返回，它将控制权切换给 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ret_from_sys</span></span>。它会去检查那些在切换回用户空间之前需要完成的任务。如果没有需要做的事情，那么就恢复用户进程的状态，并将控制权交还给用户程序。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">从用户空间直接访问系统调用</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通常，系统调用靠C库支持。用户程序通过包含标准头文件并和C库链接，就可以使用系统调用(或者调用库函数，再由库函数实际调用)。但如果你仅仅写出系统调用，glibc库恐怕并不提供支持。值得庆幸的是，Linux本身提供了一组宏，用于直接对系统调用进行访问。它会设置好寄存器并调用陷人指令。这些宏是</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscalln()</span></span>，其中n的范围从0到6。代表需要传递给系统调用的参数个数，这是由于该宏必须了解到底有多少参数按照什么次序压入寄存器。举个例子，open()系统调用的定义是:</p><pre><code>long open(const char *filename, int flags, int mode)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">而不靠库支持，直接调用此系统调用的宏的形式为:</span></p><pre><code>#define NR_ open 5syscall3(long, open, const char*，filename, int, flags, int, mode)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这样，应用程序就可以直接使用</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">open()</span></span><br>对于每个宏来说，都有2+ n个参数。<br>第一个参数对应着系统调用的返回值类型。<br>第二个参数是系统调用的名称。再以后是按照系统调用参数的顺序排列的每个参数的类型和名称。<br><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_NR_ open</span></span>在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">&lt;asm/unistd.h></span></span>中定义，是系统调用号。该宏会被扩展成为内嵌汇编的C函数。由汇编语言执行前一节所讨论的步骤，将系统调用号和参数压入寄存器并触发软中断来陷入内核。调用<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">open()</span></span>系统调用直接把上面的宏放置在应用程序中就可以了。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">让我们写一个宏来使用前面编写的foo()系统调用，然后再写出测试代码炫耀一下我们所做的努力。</span></p><pre><code>#define NR foo 283_sysca110(long, foo)int main(){long stack size;stack_ size=foo();printf("The kernel stacksize is 81d/n"，stack_ size);return;}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">添加系统调用</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">通过修改内核源代码添加系统调用</span></h1><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">linux-2.6.*</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通过以上分析linux系统调用的过程，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">将自己的系统调用加到内核中就是一件容易的事情。下面介绍一个实际的系统调用，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">并把它加到内核中去。要增加的系统调用是：inttestsyscall()，其功能是在控制终端屏幕上显示hello world，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">执行成功后返回0。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">编写int testsyscall()系统调用–响应函数</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">编写一个系统调用意味着要给内核增加1个函数，将新函数放入文件kernel/sys.c中。新函数代码如下：</span></p><pre><code>asmlingkage sys_testsyscall(){     print("hello world\n");        return 0; }</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">添加系统调用号</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">编写了新的系统调用过程后，下一项任务是使内核的其余部分知道这一程序的存在，然后重建包含新的系统调用的内核。为了把新的函数连接到已有的内核中去， 需要编辑2个文件：</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1).inculde/asm/unistd.h在这个文件中加入</span></p><pre><code>#define_NR_testsyscall 191</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统调用表中添加对应项</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2).are/i386/kernel/entry.s这个文件用来对指针数组初始化，在这个文件中增加一行：</span></p><pre><code> .long SYMBOL_NAME(_sys_tsetsycall)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">将</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">.rept NR_syscalls-190</span></span>改为<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">NR_SYSCALLS-191</span></span>,然后重新编译和运行新内核。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">使用新的系统调用</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在保证的C语言库中没有新的系统调用的程序段，必须自己建立其代码如下</span></p><pre><code>#inculde_syscall0(int,testsyscall)main(){    tsetsyscall();}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在这里使用了</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">_syscall0</span></span>宏指令，宏指令本身在程序中将扩展成名为<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">syscall()</span></span>的函数，它在<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">main()</span></span>函数内部加以调用。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">testsyscall()</span></span>函数中， 预处理程序产生所有必要的机器指令代码，包括用系统调用参数值加载相应的<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">cpu</span></span>寄存器， 然后执行<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">int 0x80</span></span>中断指令。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">linux-3.*</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在linux-3.8.4/kernel/sys.c 文件末尾添加新的系统调用函数如：</span></p><pre><code>asmlinkage int sys_mycall(int number){        printk("这是我添加的第一个系统调用");        return number; }</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/x86/syscall_32.tbl</span></span>下找到<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">unused 223</span></span>号调用然后替换如：</p><pre><code>223 i386 mycall sys_mycall</code></pre><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">如果是64位系统，在</span></span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">arch/x86/syscalls/syscall_64.tbl</span></span>下找到<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">313</span></span>号系统调用，然后在其下面加上<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">314</span></span>号自己的中断如：<br>`314 common mycall sys_mycall</p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">利用内核模块添加系统调用</span></h1><hr><p>模块是内核的一部分，但是并没有被编译到内核里面去。它们被分别编译并连接成一组目标文件， 这些文件能被插入到正在运行的内核，或者从正在运行的内核中移走。内核模块至少必须有2个函数：<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">init_module</span></span>和<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">cleanup_module</span></span>。</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第一个函数是在把模块插入内核时调用的;</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第二个函数则在删除该模块时调用。由于内核模块是内核的一部分，所以能访问所有内核资源。根据对linux系统调用机制的分析，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果要增加系统调用，可以编写自己的函数来实现，然后在sys_call_table表中增加一项，使该项中的指针指向自己编写的函数，</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">就可以实现系统调用。下面用该方法实现在控制终端上打印“hello world” 的系统调用testsyscall()。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">编写系统调用内核模块</span></h1><hr><pre><code>#inculde(linux/kernel.h)#inculde(linux/module.h)#inculde(linux/modversions.h)#inculde(linux/sched.h) #inculde(asm/uaccess.h)#define_NR_testsyscall 191extern viod *sys_call+table[];asmlinkage int testsyscall(){     printf("hello world\n");    return 0;}int init_module(){     sys_call_table[_NR_tsetsyscall]=testsyscall;    printf("system call testsyscall() loaded success\n");    return 0;}void cleanup_module(){}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">使用新的系统调用</span></h1><pre><code>#define_NR_testsyscall 191_syscall0(int,testsyscall)main(){    testsyscall();}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">内核Linux系统调用的列表</span></h1><hr><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以下是Linux系统调用的一个列表，包含了大部分常用系统调用和由系统调用派生出的的函数。</span></p><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">进程控制</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b918ff71dcc4802a2f95b99410e7cfe><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">文件系统控制</span></h1><hr><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">文件读写操作</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e48933b57a94945918b332e448f99c5><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">文件系统操作</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5f66ec6f76d142b08f91eb6f928d79c9><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">系统控制</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/21f54a6904da4b4fac5afff2dec5cd1f><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">内存管理</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1f4c3d6a9494487ea548e116af35e96a><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">网络管理</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/437cc925bf2c4e8285fb73d6f1c7babf><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">socket控制</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/88ef63bdf49c41ab82af6fa6f4cad79a><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">用户管理</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3abe8c1de0b4d6c8d21b340cd1c84ed><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">进程间通信</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bfc68fded2a34ad7b61528317cec0fc9><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">信号</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8551fa049fe745338ebf72838a71e7d9><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">消息</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/adc0c57b9d0a41ab87dfe6fe7d2e2cd0><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">管道</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/079c2fe70c4c4d528437f9301576aad3><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">信号量</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfc9e4d0d1af4865a87caa8b1a5cade7><p class=pgc-img-caption></p></div><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #979797">共享内存</span></strong></p><div class=pgc-img><img alt=Linux系统调用详解（实现机制分析） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/51bb56add68b4e06b13d8a585a78749e><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','系统','调用'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>