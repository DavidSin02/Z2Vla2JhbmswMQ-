<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹ | æå®¢å¿«è¨Š</title><meta property="og:title" content="Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹ - æå®¢å¿«è¨Š"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/1b7a1014-7ea5-421b-808e-c41398f5e4aa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5d9900a2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5d9900a2.html><meta property="article:published_time" content="2020-11-14T21:00:07+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:07+08:00"><meta name=Keywords content><meta name=description content="Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹"><meta name=author content="æå®¢å¿«è¨Š"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5d9900a2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>ğŸ¤“ æå®¢å¿«è®¯ Geek Bank</a></h1><p class=description>ä¸ºä½ å¸¦æ¥æœ€å…¨çš„ç§‘æŠ€çŸ¥è¯† ğŸ§¡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>çŒœä½ å–œæ­¡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=ç§‘æŠ€>ç§‘æŠ€</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=éŠæˆ²>éŠæˆ²</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=ç§‘å­¸>ç§‘å­¸</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>ç§‘æŠ€</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/1b7a1014-7ea5-421b-808e-c41398f5e4aa><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>Flinkçš„æ•°æ®æŠ½è±¡</h1><p><strong>MemorySegment</strong></p><p>Flinkä½œä¸ºä¸€ä¸ªé«˜æ•ˆçš„æµæ¡†æ¶ï¼Œä¸ºäº†é¿å…JVMçš„å›ºæœ‰ç¼ºé™·ï¼ˆjavaå¯¹è±¡å­˜å‚¨å¯†åº¦ä½ï¼ŒFGCå½±å“ååå’Œå“åº”ç­‰ï¼‰ï¼Œå¿…ç„¶èµ°ä¸Šè‡ªä¸»ç®¡ç†å†…å­˜çš„é“è·¯ã€‚</p><p>è¿™ä¸ªMemorySegmentå°±æ˜¯Flinkçš„å†…å­˜æŠ½è±¡ã€‚é»˜è®¤æƒ…å†µä¸‹ï¼Œä¸€ä¸ªMemorySegmentå¯ä»¥è¢«çœ‹åšæ˜¯ä¸€ä¸ª32kbå¤§çš„å†…å­˜å—çš„æŠ½è±¡ã€‚è¿™å—å†…å­˜æ—¢å¯ä»¥æ˜¯JVMé‡Œçš„ä¸€ä¸ªbyte[]ï¼Œä¹Ÿå¯ä»¥æ˜¯å †å¤–å†…å­˜ï¼ˆDirectByteBufferï¼‰ã€‚</p><p>å¦‚æœè¯´byte[]æ•°ç»„å’Œdirect memoryæ˜¯æœ€åº•å±‚çš„å­˜å‚¨ï¼Œé‚£ä¹ˆmemorysegmentå°±æ˜¯åœ¨å…¶ä¸Šè¦†ç›–çš„ä¸€å±‚ç»Ÿä¸€æŠ½è±¡ã€‚å®ƒå®šä¹‰äº†ä¸€ç³»åˆ—æŠ½è±¡æ–¹æ³•ï¼Œç”¨äºæ§åˆ¶å’Œåº•å±‚å†…å­˜çš„äº¤äº’ï¼Œå¦‚ï¼š</p><pre><code>public abstract class MemorySegment {    public abstract byte get(int index);        public abstract void put(int index, byte b);        public int size() ;        public abstract ByteBuffer wrap(int offset, int length);        ......}</code></pre><p>æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œå®ƒåœ¨æä¾›äº†è¯¸å¤šç›´æ¥æ“ä½œå†…å­˜çš„æ–¹æ³•å¤–ï¼Œè¿˜æä¾›äº†ä¸€ä¸ªwrap()æ–¹æ³•ï¼Œå°†è‡ªå·±åŒ…è£…æˆä¸€ä¸ªByteBufferï¼Œæˆ‘ä»¬å¾…ä¼šå„¿è®²è¿™ä¸ªByteBufferã€‚</p><p>Flinkä¸ºMemorySegmentæä¾›äº†ä¸¤ä¸ªå®ç°ç±»ï¼šHeapMemorySegmentå’ŒHybridMemorySegmentã€‚ä»–ä»¬çš„åŒºåˆ«åœ¨äºå‰è€…åªèƒ½åˆ†é…å †å†…å­˜ï¼Œè€Œåè€…èƒ½ç”¨æ¥åˆ†é…å †å†…å’Œå †å¤–å†…å­˜ã€‚äº‹å®ä¸Šï¼ŒFlinkæ¡†æ¶é‡Œï¼Œåªä½¿ç”¨äº†åè€…ã€‚è¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿ</p><p>å¦‚æœHybridMemorySegmentåªèƒ½ç”¨äºåˆ†é…å †å¤–å†…å­˜çš„è¯ï¼Œä¼¼ä¹æ›´åˆå¸¸ç†ã€‚ä½†æ˜¯åœ¨JVMçš„ä¸–ç•Œä¸­ï¼Œå¦‚æœä¸€ä¸ªæ–¹æ³•æ˜¯ä¸€ä¸ªè™šæ–¹æ³•ï¼Œé‚£ä¹ˆæ¯æ¬¡è°ƒç”¨æ—¶ï¼ŒJVMéƒ½è¦èŠ±æ—¶é—´å»ç¡®å®šè°ƒç”¨çš„åˆ°åº•æ˜¯å“ªä¸ªå­ç±»å®ç°çš„è¯¥è™šæ–¹æ³•ï¼ˆæ–¹æ³•é‡å†™æœºåˆ¶ï¼Œä¸æ˜ç™½çš„å»çœ‹JVMçš„invokeVirtualæŒ‡ä»¤ï¼‰ï¼Œä¹Ÿå°±æ„å‘³ç€æ¯æ¬¡éƒ½è¦å»ç¿»æ–¹æ³•è¡¨ï¼›è€Œå¦‚æœè¯¥æ–¹æ³•è™½ç„¶æ˜¯ä¸ªè™šæ–¹æ³•ï¼Œä½†å®é™…ä¸Šæ•´ä¸ªJVMé‡Œåªæœ‰ä¸€ä¸ªå®ç°ï¼ˆå°±æ˜¯è¯´åªåŠ è½½äº†ä¸€ä¸ªå­ç±»è¿›æ¥ï¼‰ï¼Œé‚£ä¹ˆJVMä¼šå¾ˆèªæ˜çš„æŠŠå®ƒå»è™šåŒ–å¤„ç†ï¼Œè¿™æ ·å°±ä¸ç”¨æ¯æ¬¡è°ƒç”¨æ–¹æ³•æ—¶å»æ‰¾æ–¹æ³•è¡¨äº†ï¼Œèƒ½å¤Ÿå¤§å¤§æå‡æ€§èƒ½ã€‚ä½†æ˜¯åªåˆ†é…å †å†…æˆ–è€…å †å¤–å†…å­˜ä¸èƒ½æ»¡è¶³æˆ‘ä»¬çš„éœ€è¦ï¼Œæ‰€ä»¥å°±å‡ºç°äº†HybridMemorySegmentåŒæ—¶å¯ä»¥åˆ†é…ä¸¤ç§å†…å­˜çš„è®¾è®¡ã€‚</p><p>æˆ‘ä»¬å¯ä»¥çœ‹çœ‹HybridMemorySegmentçš„æ„é€ ä»£ç ï¼š</p><pre><code>HybridMemorySegment(ByteBuffer buffer, Object owner) {        super(checkBufferAndGetAddress(buffer), buffer.capacity(), owner);        this.offHeapBuffer = buffer;    }            HybridMemorySegment(byte[] buffer, Object owner) {        super(buffer, owner);        this.offHeapBuffer = null;    }</code></pre><p>å…¶ä¸­ï¼Œç¬¬ä¸€ä¸ªæ„é€ å‡½æ•°çš„checkBufferAndGetAddress()æ–¹æ³•èƒ½å¤Ÿå¾—åˆ°direct bufferçš„å†…å­˜åœ°å€ï¼Œå› æ­¤å¯ä»¥æ“ä½œå †å¤–å†…å­˜ã€‚</p><h1 class=pgc-h-arrow-right>ByteBufferä¸NetworkBufferPool</h1><p>åœ¨MemorySegmentè¿™ä¸ªæŠ½è±¡ä¹‹ä¸Šï¼ŒFlinkåœ¨æ•°æ®ä»operatorå†…çš„æ•°æ®å¯¹è±¡åœ¨å‘TaskManagerä¸Šè½¬ç§»ï¼Œé¢„å¤‡è¢«å‘ç»™ä¸‹ä¸ªèŠ‚ç‚¹çš„è¿‡ç¨‹ä¸­ï¼Œä½¿ç”¨çš„æŠ½è±¡æˆ–è€…è¯´å†…å­˜å¯¹è±¡æ˜¯Bufferã€‚</p><p>æ³¨æ„ï¼Œè¿™ä¸ªBufferæ˜¯ä¸ªflinkæ¥å£ï¼Œä¸æ˜¯java.nioæä¾›çš„é‚£ä¸ªBufferæŠ½è±¡ç±»ã€‚Flinkåœ¨è¿™ä¸€å±‚é¢åŒæ—¶ä½¿ç”¨äº†è¿™ä¸¤ä¸ªåŒåæ¦‚å¿µï¼Œç”¨æ¥å­˜å‚¨å¯¹è±¡ï¼Œç›´æ¥çœ‹ä»£ç æ—¶åˆ°å¤„éƒ½æ˜¯å„ç§xxxBufferå¾ˆå®¹æ˜“æ··æ·†ï¼š</p><ul class=list-paddingleft-2><li>javaæä¾›çš„é‚£ä¸ªBufferæŠ½è±¡ç±»åœ¨è¿™ä¸€å±‚ä¸»è¦ç”¨äºæ„å»ºHeapByteBufferï¼Œè¿™ä¸ªä¸»è¦æ˜¯å½“æ•°æ®ä»jvmé‡Œçš„ä¸€ä¸ªå¯¹è±¡è¢«åºåˆ—åŒ–æˆå­—èŠ‚æ•°ç»„æ—¶ç”¨çš„ï¼›</li><li>Flinkçš„è¿™ä¸ªBufferæ¥å£ä¸»è¦æ˜¯ä¸€ç§flinkå±‚é¢ç”¨äºä¼ è¾“æ•°æ®å’Œäº‹ä»¶çš„ç»Ÿä¸€æŠ½è±¡ï¼Œå…¶å®ç°ç±»æ˜¯NetworkBufferï¼Œæ˜¯å¯¹MemorySegmentçš„åŒ…è£…ã€‚Flinkåœ¨å„ä¸ªTaskManagerä¹‹é—´ä¼ é€’æ•°æ®æ—¶ï¼Œä½¿ç”¨çš„æ˜¯è¿™ä¸€å±‚çš„æŠ½è±¡ã€‚å› ä¸ºBufferçš„åº•å±‚æ˜¯MemorySegmentï¼Œè¿™å¯èƒ½ä¸æ˜¯JVMæ‰€ç®¡ç†çš„ï¼Œæ‰€ä»¥ä¸ºäº†çŸ¥é“ä»€ä¹ˆæ—¶å€™ä¸€ä¸ªBufferç”¨å®Œäº†å¯ä»¥å›æ”¶ï¼ŒFlinkå¼•å…¥äº†å¼•ç”¨è®¡æ•°çš„æ¦‚å¿µï¼Œå½“ç¡®è®¤è¿™ä¸ªbufferæ²¡æœ‰äººå¼•ç”¨ï¼Œå°±å¯ä»¥å›æ”¶è¿™ä¸€ç‰‡MemorySegmentç”¨äºåˆ«çš„åœ°æ–¹äº†ï¼ˆJVMçš„åƒåœ¾å›æ”¶ä¸ºå•¥ä¸ç”¨å¼•ç”¨è®¡æ•°ï¼Ÿè¯»è€…æ€è€ƒä¸€ä¸‹ï¼‰ï¼š</li></ul><pre><code>public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {    private volatile int refCnt = 1;        ......}</code></pre><p>ä¸ºäº†æ–¹ä¾¿ç®¡ç†NetworkBufferï¼ŒFlinkæä¾›äº†BufferPoolFactoryï¼Œå¹¶ä¸”æä¾›äº†å”¯ä¸€å®ç°NetworkBufferPoolï¼Œè¿™æ˜¯ä¸ªå·¥å‚æ¨¡å¼çš„åº”ç”¨ã€‚</p><p>NetworkBufferPoolåœ¨æ¯ä¸ªTaskManagerä¸Šåªæœ‰ä¸€ä¸ªï¼Œè´Ÿè´£æ‰€æœ‰å­taskçš„å†…å­˜ç®¡ç†ã€‚å…¶å®ä¾‹åŒ–æ—¶å°±ä¼šå°è¯•è·å–æ‰€æœ‰å¯ç”±å®ƒç®¡ç†çš„å†…å­˜ï¼ˆå¯¹äºå †å†…å­˜æ¥è¯´ï¼Œç›´æ¥è·å–æ‰€æœ‰å†…å­˜å¹¶æ”¾å…¥è€å¹´ä»£ï¼Œå¹¶ä»¤ç”¨æˆ·å¯¹è±¡åªåœ¨æ–°ç”Ÿä»£å­˜æ´»ï¼Œå¯ä»¥æå¤§ç¨‹åº¦çš„å‡å°‘Full GCï¼‰ï¼Œæˆ‘ä»¬çœ‹çœ‹å…¶æ„é€ æ–¹æ³•ï¼š</p><pre><code>public NetworkBufferPool(int numberOfSegmentsToAllocate, int segmentSize) {        ......                try {            this.availableMemorySegments = new ArrayBlockingQueue&lt;&gt;(numberOfSegmentsToAllocate);        }        catch (OutOfMemoryError err) {            throw new OutOfMemoryError("Could not allocate buffer queue of length "                    + numberOfSegmentsToAllocate + " - " + err.getMessage());        }        try {            for (int i = 0; i &lt; numberOfSegmentsToAllocate; i++) {                ByteBuffer memory = ByteBuffer.allocateDirect(segmentSize);                availableMemorySegments.add(MemorySegmentFactory.wrapPooledOffHeapMemory(memory, null));            }        }        ......                long allocatedMb = (sizeInLong * availableMemorySegments.size()) &gt;&gt; 20;        LOG.info("Allocated {} MB for network buffer pool (number of memory segments: {}, bytes per segment: {}).",                allocatedMb, availableMemorySegments.size(), segmentSize);    }</code></pre><p>ç”±äºNetworkBufferPoolåªæ˜¯ä¸ªå·¥å‚ï¼Œå®é™…çš„å†…å­˜æ± æ˜¯LocalBufferPoolã€‚æ¯ä¸ªTaskManageréƒ½åªæœ‰ä¸€ä¸ªNetworkBufferPoolå·¥å‚ï¼Œä½†æ˜¯ä¸Šé¢è¿è¡Œçš„æ¯ä¸ªtaskéƒ½è¦æœ‰ä¸€ä¸ªå’Œå…¶ä»–taskéš”ç¦»çš„LocalBufferPoolæ± ï¼Œè¿™ä»é€»è¾‘ä¸Šå¾ˆå¥½ç†è§£ã€‚å¦å¤–ï¼ŒNetworkBufferPoolä¼šè®¡ç®—è‡ªå·±æ‰€æ‹¥æœ‰çš„æ‰€æœ‰å†…å­˜åˆ†ç‰‡æ•°ï¼Œåœ¨åˆ†é…æ–°çš„å†…å­˜æ± æ—¶å¯¹æ¯ä¸ªå†…å­˜æ± åº”è¯¥å æœ‰çš„å†…å­˜åˆ†ç‰‡æ•°é‡åˆ†é…ï¼Œæ­¥éª¤æ˜¯ï¼š</p><ul class=list-paddingleft-2><li>é¦–å…ˆï¼Œä»æ•´ä¸ªå·¥å‚ç®¡ç†çš„å†…å­˜ç‰‡ä¸­æ‹¿å‡ºæ‰€æœ‰çš„å†…å­˜æ± æ‰€éœ€è¦çš„æœ€å°‘Bufferæ•°ç›®æ€»å’Œå¦‚æœæ­£å¥½åˆ†é…å®Œï¼Œå°±ç»“æŸ</li><li>å…¶æ¬¡ï¼ŒæŠŠæ‰€æœ‰çš„å‰©ä¸‹çš„æ²¡åˆ†é…çš„å†…å­˜ç‰‡ï¼ŒæŒ‰ç…§æ¯ä¸ªLocalBufferPoolå†…å­˜æ± çš„å‰©ä½™æƒ³è¦å®¹é‡å¤§å°è¿›è¡ŒæŒ‰æ¯”ä¾‹åˆ†é…</li><li>å‰©ä½™æƒ³è¦å®¹é‡å¤§å°æ˜¯è¿™ä¹ˆä¸ªä¸œè¥¿ï¼šå¦‚æœè¯¥å†…å­˜æ± è‡³å°‘éœ€è¦3ä¸ªbufferï¼Œæœ€å¤§éœ€è¦10ä¸ªbufferï¼Œé‚£ä¹ˆå®ƒçš„å‰©ä½™æƒ³è¦å®¹é‡å°±æ˜¯7å®ç°ä»£ç å¦‚ä¸‹ï¼š</li></ul><pre><code>private void redistributeBuffers() throws IOException {        assert Thread.holdsLock(factoryLock);        // All buffers, which are not among the required ones        final int numAvailableMemorySegment = totalNumberOfMemorySegments - numTotalRequiredBuffers;        if (numAvailableMemorySegment == 0) {            // in this case, we need to redistribute buffers so that every pool gets its minimum            for (LocalBufferPool bufferPool : allBufferPools) {                bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments());            }            return;        }        long totalCapacity = 0; // long to avoid int overflow        for (LocalBufferPool bufferPool : allBufferPools) {            int excessMax = bufferPool.getMaxNumberOfMemorySegments() -                bufferPool.getNumberOfRequiredMemorySegments();            totalCapacity += Math.min(numAvailableMemorySegment, excessMax);        }        // no capacity to receive additional buffers?        if (totalCapacity == 0) {            return; // necessary to avoid div by zero when nothing to re-distribute        }        final int memorySegmentsToDistribute = MathUtils.checkedDownCast(                Math.min(numAvailableMemorySegment, totalCapacity));        long totalPartsUsed = 0; // of totalCapacity        int numDistributedMemorySegment = 0;        for (LocalBufferPool bufferPool : allBufferPools) {            int excessMax = bufferPool.getMaxNumberOfMemorySegments() -                bufferPool.getNumberOfRequiredMemorySegments();            // shortcut            if (excessMax == 0) {                continue;            }            totalPartsUsed += Math.min(numAvailableMemorySegment, excessMax);            final int mySize = MathUtils.checkedDownCast(                    memorySegmentsToDistribute * totalPartsUsed / totalCapacity - numDistributedMemorySegment);            numDistributedMemorySegment += mySize;            bufferPool.setNumBuffers(bufferPool.getNumberOfRequiredMemorySegments() + mySize);        }        assert (totalPartsUsed == totalCapacity);        assert (numDistributedMemorySegment == memorySegmentsToDistribute);    }</code></pre><p>æ¥ä¸‹æ¥è¯´è¯´è¿™ä¸ªLocalBufferPoolå†…å­˜æ± ã€‚<br>LocalBufferPoolçš„é€»è¾‘æƒ³æƒ³æ— éæ˜¯å¢åˆ æ”¹æŸ¥ï¼Œå€¼å¾—è¯´çš„æ˜¯å…¶fieldsï¼š</p><pre><code>/** è¯¥å†…å­˜æ± éœ€è¦çš„æœ€å°‘å†…å­˜ç‰‡æ•°ç›®*/    private final int numberOfRequiredMemorySegments;    /**     * å½“å‰å·²ç»è·å¾—çš„å†…å­˜ç‰‡ä¸­ï¼Œè¿˜æ²¡æœ‰å†™å…¥æ•°æ®çš„ç©ºç™½å†…å­˜ç‰‡     */    private final ArrayDeque&lt;MemorySegment&gt; availableMemorySegments = new ArrayDeque&lt;MemorySegment&gt;();    /**     * æ³¨å†Œçš„æ‰€æœ‰ç›‘æ§bufferå¯ç”¨æ€§çš„ç›‘å¬å™¨     */    private final ArrayDeque&lt;BufferListener&gt; registeredListeners = new ArrayDeque&lt;&gt;();    /** èƒ½ç»™å†…å­˜æ± åˆ†é…çš„æœ€å¤§åˆ†ç‰‡æ•°*/    private final int maxNumberOfMemorySegments;    /** å½“å‰å†…å­˜æ± å¤§å° */    private int currentPoolSize;    /**     * æ‰€æœ‰ç»ç”±NetworkBufferPoolåˆ†é…çš„ï¼Œè¢«æœ¬å†…å­˜æ± å¼•ç”¨åˆ°çš„ï¼ˆéç›´æ¥è·å¾—çš„ï¼‰åˆ†ç‰‡æ•°     */    private int numberOfRequestedMemorySegments;</code></pre><p>æ‰¿æ¥NetworkBufferPoolçš„é‡åˆ†é…æ–¹æ³•ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹LocalBufferPoolçš„setNumBuffers()æ–¹æ³•ï¼Œä»£ç å¾ˆçŸ­ï¼Œé€»è¾‘ä¹Ÿç›¸å½“ç®€å•ï¼Œå°±ä¸å±•å¼€è¯´äº†ï¼š</p><pre><code>public void setNumBuffers(int numBuffers) throws IOException {        synchronized (availableMemorySegments) {            checkArgument(numBuffers &gt;= numberOfRequiredMemorySegments,                    "Buffer pool needs at least %s buffers, but tried to set to %s",                    numberOfRequiredMemorySegments, numBuffers);            if (numBuffers &gt; maxNumberOfMemorySegments) {                currentPoolSize = maxNumberOfMemorySegments;            } else {                currentPoolSize = numBuffers;            }            returnExcessMemorySegments();            // If there is a registered owner and we have still requested more buffers than our            // size, trigger a recycle via the owner.            if (owner != null &amp;&amp; numberOfRequestedMemorySegments &gt; currentPoolSize) {                owner.releaseMemory(numberOfRequestedMemorySegments - numBuffers);            }        }    }</code></pre><h1 class=pgc-h-arrow-right><strong>RecordWriterä¸Record</strong></h1><p>æˆ‘ä»¬æ¥ç€å¾€é«˜å±‚æŠ½è±¡èµ°ï¼Œåˆšåˆšæåˆ°äº†æœ€åº•å±‚å†…å­˜æŠ½è±¡æ˜¯MemorySegmentï¼Œç”¨äºæ•°æ®ä¼ è¾“çš„æ˜¯Bufferï¼Œé‚£ä¹ˆï¼Œæ‰¿ä¸Šå¯ä¸‹å¯¹æ¥ä»Javaå¯¹è±¡è½¬ä¸ºBufferçš„ä¸­é—´å¯¹è±¡æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ˜¯StreamRecordã€‚</p><p>ä»StreamRecord&lt;T>è¿™ä¸ªç±»åå­—å°±å¯ä»¥çœ‹å‡ºæ¥ï¼Œè¿™ä¸ªç±»å°±æ˜¯ä¸ªwrapï¼Œé‡Œé¢ä¿å­˜äº†åŸå§‹çš„Javaå¯¹è±¡ã€‚å¦å¤–ï¼ŒStreamRecordè¿˜ä¿å­˜äº†ä¸€ä¸ªtimestampã€‚</p><p>é‚£ä¹ˆè¿™ä¸ªå¯¹è±¡æ˜¯æ€ä¹ˆå˜æˆLocalBufferPoolå†…å­˜æ± é‡Œçš„ä¸€ä¸ªå¤§å·å­—èŠ‚æ•°ç»„çš„å‘¢ï¼Ÿå€ŸåŠ©äº†StreamWriterè¿™ä¸ªç±»ã€‚</p><p>æˆ‘ä»¬ç›´æ¥æ¥çœ‹æŠŠæ•°æ®åºåˆ—åŒ–äº¤å‡ºå»çš„æ–¹æ³•ï¼š</p><pre><code>private void sendToTarget(T record, int targetChannel) throws IOException, InterruptedException {        RecordSerializer&lt;T&gt; serializer = serializers[targetChannel];        SerializationResult result = serializer.addRecord(record);        while (result.isFullBuffer()) {            if (tryFinishCurrentBufferBuilder(targetChannel, serializer)) {                // If this was a full record, we are done. Not breaking                // out of the loop at this point will lead to another                // buffer request before breaking out (that would not be                // a problem per se, but it can lead to stalls in the                // pipeline).                if (result.isFullRecord()) {                    break;                }            }            BufferBuilder bufferBuilder = requestNewBufferBuilder(targetChannel);            result = serializer.continueWritingWithNextBufferBuilder(bufferBuilder);        }        checkState(!serializer.hasSerializedData(), "All data should be written at once");                                if (flushAlways) {            targetPartition.flush(targetChannel);        }    }</code></pre><p>å…ˆè¯´æœ€åä¸€è¡Œï¼Œå¦‚æœé…ç½®ä¸ºflushAlwaysï¼Œé‚£ä¹ˆä¼šç«‹åˆ»æŠŠå…ƒç´ å‘é€å‡ºå»ï¼Œä½†æ˜¯è¿™æ ·ååé‡ä¼šä¸‹é™ï¼›Flinkçš„é»˜è®¤è®¾ç½®å…¶å®ä¹Ÿä¸æ˜¯ä¸€ä¸ªå…ƒç´ ä¸€ä¸ªå…ƒç´ çš„å‘é€ï¼Œæ˜¯å•ç‹¬èµ·äº†ä¸€ä¸ªçº¿ç¨‹ï¼Œæ¯éš”å›ºå®šæ—¶é—´flushä¸€æ¬¡æ‰€æœ‰channelï¼Œè¾ƒçœŸèµ·æ¥ä¹Ÿç®—æ˜¯mini batchäº†ã€‚å†è¯´åºåˆ—åŒ–é‚£ä¸€å¥:SerializationResult result = serializer.addRecord(record);ã€‚åœ¨è¿™è¡Œä»£ç ä¸­ï¼ŒFlinkæŠŠå¯¹è±¡è°ƒç”¨è¯¥å¯¹è±¡æ‰€å±çš„åºåˆ—åŒ–å™¨åºåˆ—åŒ–ä¸ºå­—èŠ‚æ•°ç»„ã€‚</p><h1 class=pgc-h-arrow-right>æ•°æ®æµè½¬è¿‡ç¨‹</h1><p>ä¸Šä¸€èŠ‚è®²äº†å„å±‚æ•°æ®çš„æŠ½è±¡ï¼Œè¿™ä¸€èŠ‚è®²è®²æ•°æ®åœ¨å„ä¸ªtaskä¹‹é—´exchangeçš„è¿‡ç¨‹ã€‚</p><h1 class=pgc-h-arrow-right>æ•´ä½“è¿‡ç¨‹</h1><p>çœ‹è¿™å¼ å›¾ï¼š</p><div class=pgc-img><img alt=Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/867ece4553124fdfb6151b38bb0dbc77><p class=pgc-img-caption></p></div><p>1.ç¬¬ä¸€æ­¥å¿…ç„¶æ˜¯å‡†å¤‡ä¸€ä¸ªResultPartitionï¼›2.é€šçŸ¥JobMasterï¼›3.JobMasteré€šçŸ¥ä¸‹æ¸¸èŠ‚ç‚¹ï¼›å¦‚æœä¸‹æ¸¸èŠ‚ç‚¹å°šæœªéƒ¨ç½²ï¼Œåˆ™éƒ¨ç½²ä¹‹ï¼›4.ä¸‹æ¸¸èŠ‚ç‚¹å‘ä¸Šæ¸¸è¯·æ±‚æ•°æ®5.å¼€å§‹ä¼ è¾“æ•°æ®</p><h1 class=pgc-h-arrow-right>æ•°æ®è·¨taskä¼ é€’</h1><p>æœ¬èŠ‚è®²ä¸€ä¸‹ç®—å­ä¹‹é—´å…·ä½“çš„æ•°æ®ä¼ è¾“è¿‡ç¨‹ã€‚ä¹Ÿå…ˆä¸Šä¸€å¼ å›¾ï¼š</p><div class=pgc-img><img alt=Flinkä¸­çš„æ•°æ®æŠ½è±¡åŠæ•°æ®äº¤æ¢è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b5f2986097a4c7b929313895f2cae05><p class=pgc-img-caption></p></div><p>æ•°æ®åœ¨taskä¹‹é—´ä¼ é€’æœ‰å¦‚ä¸‹å‡ æ­¥ï¼š</p><p>1.æ•°æ®åœ¨æœ¬operatorå¤„ç†å®Œåï¼Œäº¤ç»™RecordWriterã€‚æ¯æ¡è®°å½•éƒ½è¦é€‰æ‹©ä¸€ä¸ªä¸‹æ¸¸èŠ‚ç‚¹ï¼Œæ‰€ä»¥è¦ç»è¿‡ChannelSelectorã€‚2.æ¯ä¸ªchanneléƒ½æœ‰ä¸€ä¸ªserializerï¼ˆæˆ‘è®¤ä¸ºè¿™åº”è¯¥æ˜¯ä¸ºäº†é¿å…å¤šçº¿ç¨‹å†™çš„éº»çƒ¦ï¼‰ï¼ŒæŠŠè¿™æ¡Recordåºåˆ—åŒ–ä¸ºByteBuffer3.æ¥ä¸‹æ¥æ•°æ®è¢«å†™å…¥ResultPartitionä¸‹çš„å„ä¸ªsubPartitioné‡Œï¼Œæ­¤æ—¶è¯¥æ•°æ®å·²ç»å­˜å…¥DirectBufferï¼ˆMemorySegmentï¼‰4.å•ç‹¬çš„çº¿ç¨‹æ§åˆ¶æ•°æ®çš„flushé€Ÿåº¦ï¼Œä¸€æ—¦è§¦å‘flushï¼Œåˆ™é€šè¿‡Nettyçš„nioé€šé“å‘å¯¹ç«¯å†™å…¥5.å¯¹ç«¯çš„netty clientæ¥æ”¶åˆ°æ•°æ®ï¼Œdecodeå‡ºæ¥ï¼ŒæŠŠæ•°æ®æ‹·è´åˆ°bufferé‡Œï¼Œç„¶åé€šçŸ¥InputChannel6.æœ‰å¯ç”¨çš„æ•°æ®æ—¶ï¼Œä¸‹æ¸¸ç®—å­ä»é˜»å¡é†’æ¥ï¼Œä»InputChannelå–å‡ºbufferï¼Œå†è§£åºåˆ—åŒ–æˆrecordï¼Œäº¤ç»™ç®—å­æ‰§è¡Œç”¨æˆ·ä»£ç æ•°æ®åœ¨ä¸åŒæœºå™¨çš„ç®—å­ä¹‹é—´ä¼ é€’çš„æ­¥éª¤å°±æ˜¯ä»¥ä¸Šè¿™äº›ã€‚</p><p>äº†è§£äº†æ­¥éª¤ä¹‹åï¼Œå†æ¥çœ‹ä¸€ä¸‹éƒ¨åˆ†å…³é”®ä»£ç ï¼šé¦–å…ˆæ˜¯æŠŠæ•°æ®äº¤ç»™recordwriterã€‚</p><pre><code>//RecordWriterOutput.java    @Override    public void collect(StreamRecord&lt;OUT&gt; record) {        if (this.outputTag != null) {            // we are only responsible for emitting to the main input            return;        }        //è¿™é‡Œå¯ä»¥çœ‹åˆ°æŠŠè®°å½•äº¤ç»™äº†recordwriter        pushToRecordWriter(record);    }</code></pre><p>ç„¶årecordwriteræŠŠæ•°æ®å‘é€åˆ°å¯¹åº”çš„é€šé“ã€‚</p><pre><code>//RecordWriter.java    public void emit(T record) throws IOException, InterruptedException {        //channelselectorç™»åœºäº†        for (int targetChannel : channelSelector.selectChannels(record, numChannels)) {            sendToTarget(record, targetChannel);        }    }            private void sendToTarget(T record, int targetChannel) throws IOException, InterruptedException {                //é€‰æ‹©åºåˆ—åŒ–å™¨å¹¶åºåˆ—åŒ–æ•°æ®        RecordSerializer&lt;T&gt; serializer = serializers[targetChannel];        SerializationResult result = serializer.addRecord(record);        while (result.isFullBuffer()) {            if (tryFinishCurrentBufferBuilder(targetChannel, serializer)) {                // If this was a full record, we are done. Not breaking                // out of the loop at this point will lead to another                // buffer request before breaking out (that would not be                // a problem per se, but it can lead to stalls in the                // pipeline).                if (result.isFullRecord()) {                    break;                }            }            BufferBuilder bufferBuilder = requestNewBufferBuilder(targetChannel);            //å†™å…¥channel            result = serializer.continueWritingWithNextBufferBuilder(bufferBuilder);        }        checkState(!serializer.hasSerializedData(), "All data should be written at once");        if (flushAlways) {            targetPartition.flush(targetChannel);        }    }</code></pre><p>æ¥ä¸‹æ¥æ˜¯æŠŠæ•°æ®æ¨ç»™åº•å±‚è®¾æ–½ï¼ˆnettyï¼‰çš„è¿‡ç¨‹ï¼š</p><pre><code>//ResultPartition.java    @Override    public void flushAll() {        for (ResultSubpartition subpartition : subpartitions) {            subpartition.flush();        }    }            //PartitionRequestQueue.java        void notifyReaderNonEmpty(final NetworkSequenceViewReader reader) {        //è¿™é‡Œäº¤ç»™äº†netty serverçº¿ç¨‹å»æ¨        ctx.executor().execute(new Runnable() {            @Override            public void run() {                ctx.pipeline().fireUserEventTriggered(reader);            }        });    }</code></pre><p>nettyç›¸å…³çš„éƒ¨åˆ†ï¼š</p><pre><code>//AbstractChannelHandlerContext.java    public ChannelHandlerContext fireUserEventTriggered(final Object event) {        if (event == null) {            throw new NullPointerException("event");        } else {            final AbstractChannelHandlerContext next = this.findContextInbound();            EventExecutor executor = next.executor();            if (executor.inEventLoop()) {                next.invokeUserEventTriggered(event);            } else {                executor.execute(new OneTimeTask() {                    public void run() {                        next.invokeUserEventTriggered(event);                    }                });            }            return this;        }    }</code></pre><p>æœ€åçœŸå®çš„å†™å…¥ï¼š</p><pre><code>//PartittionRequesetQueue.java    private void enqueueAvailableReader(final NetworkSequenceViewReader reader) throws Exception {        if (reader.isRegisteredAsAvailable() || !reader.isAvailable()) {            return;        }        // Queue an available reader for consumption. If the queue is empty,        // we try trigger the actual write. Otherwise this will be handled by        // the writeAndFlushNextMessageIfPossible calls.        boolean triggerWrite = availableReaders.isEmpty();        registerAvailableReader(reader);        if (triggerWrite) {            writeAndFlushNextMessageIfPossible(ctx.channel());        }    }        private void writeAndFlushNextMessageIfPossible(final Channel channel) throws IOException {                ......                next = reader.getNextBuffer();                if (next == null) {                    if (!reader.isReleased()) {                        continue;                    }                    markAsReleased(reader.getReceiverId());                    Throwable cause = reader.getFailureCause();                    if (cause != null) {                        ErrorResponse msg = new ErrorResponse(                            new ProducerFailedException(cause),                            reader.getReceiverId());                        ctx.writeAndFlush(msg);                    }                } else {                    // This channel was now removed from the available reader queue.                    // We re-add it into the queue if it is still available                    if (next.moreAvailable()) {                        registerAvailableReader(reader);                    }                    BufferResponse msg = new BufferResponse(                        next.buffer(),                        reader.getSequenceNumber(),                        reader.getReceiverId(),                        next.buffersInBacklog());                    if (isEndOfPartitionEvent(next.buffer())) {                        reader.notifySubpartitionConsumed();                        reader.releaseAllResources();                        markAsReleased(reader.getReceiverId());                    }                    // Write and flush and wait until this is done before                    // trying to continue with the next buffer.                    channel.writeAndFlush(msg).addListener(writeListener);                    return;                }                ......            }</code></pre><p>ä¸Šé¢è¿™æ®µä»£ç é‡Œç¬¬äºŒä¸ªæ–¹æ³•ä¸­è°ƒç”¨çš„writeAndFlush(msg)å°±æ˜¯çœŸæ­£å¾€nettyçš„nioé€šé“é‡Œå†™å…¥çš„åœ°æ–¹äº†ã€‚åœ¨è¿™é‡Œï¼Œå†™å…¥çš„æ˜¯ä¸€ä¸ªRemoteInputChannelï¼Œå¯¹åº”çš„å°±æ˜¯ä¸‹æ¸¸èŠ‚ç‚¹çš„InputGateçš„channelsã€‚</p><p>æœ‰å†™å°±æœ‰è¯»ï¼Œnioé€šé“çš„å¦ä¸€ç«¯éœ€è¦è¯»å…¥bufferï¼Œä»£ç å¦‚ä¸‹ï¼š</p><pre><code>//CreditBasedPartitionRequestClientHandler.java    private void decodeMsg(Object msg) throws Throwable {        final Class&lt;?&gt; msgClazz = msg.getClass();        // ---- Buffer --------------------------------------------------------        if (msgClazz == NettyMessage.BufferResponse.class) {            NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;            RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);            if (inputChannel == null) {                bufferOrEvent.releaseBuffer();                cancelRequestFor(bufferOrEvent.receiverId);                return;            }            decodeBufferOrEvent(inputChannel, bufferOrEvent);        }                ......            }</code></pre><p>æ’ä¸€å¥ï¼ŒFlinkå…¶å®åšé˜»å¡å’Œè·å–æ•°æ®çš„æ–¹å¼éå¸¸è‡ªç„¶ï¼Œåˆ©ç”¨äº†ç”Ÿäº§è€…å’Œæ¶ˆè´¹è€…æ¨¡å‹ï¼Œå½“è·å–ä¸åˆ°æ•°æ®æ—¶ï¼Œæ¶ˆè´¹è€…è‡ªç„¶é˜»å¡ï¼›å½“æ•°æ®è¢«åŠ å…¥é˜Ÿåˆ—ï¼Œæ¶ˆè´¹è€…è¢«notifyã€‚Flinkçš„èƒŒå‹æœºåˆ¶ä¹Ÿæ˜¯å€Ÿæ­¤å®ç°ã€‚</p><p>ç„¶ååœ¨è¿™é‡Œåˆååºåˆ—åŒ–æˆStreamRecordï¼š</p><pre><code>//StreamElementSerializer.java    public StreamElement deserialize(DataInputView source) throws IOException {        int tag = source.readByte();        if (tag == TAG_REC_WITH_TIMESTAMP) {            long timestamp = source.readLong();            return new StreamRecord&lt;T&gt;(typeSerializer.deserialize(source), timestamp);        }        else if (tag == TAG_REC_WITHOUT_TIMESTAMP) {            return new StreamRecord&lt;T&gt;(typeSerializer.deserialize(source));        }        else if (tag == TAG_WATERMARK) {            return new Watermark(source.readLong());        }        else if (tag == TAG_STREAM_STATUS) {            return new StreamStatus(source.readInt());        }        else if (tag == TAG_LATENCY_MARKER) {            return new LatencyMarker(source.readLong(), new OperatorID(source.readLong(), source.readLong()), source.readInt());        }        else {            throw new IOException("Corrupt stream, found tag: " + tag);        }    }</code></pre><p>ç„¶åå†æ¬¡åœ¨StreamInputProcessor.processInput()å¾ªç¯ä¸­å¾—åˆ°å¤„ç†ã€‚</p><p>è‡³æ­¤ï¼Œæ•°æ®åœ¨è·¨jvmçš„èŠ‚ç‚¹ä¹‹é—´çš„æµè½¬è¿‡ç¨‹å°±è®²å®Œäº†ã€‚</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'æ•°æ®','Flink','äº¤æ¢'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=æœç´¢>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>ğŸ”</button></form></section><section class=widget><h3 class=widget-title>æœ€æ–°æ–‡ç«  âš¡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>å…¶ä»–</h3><ul class=widget-list><li><a href=TOS.html>ä½¿ç”¨æ¢æ¬¾</a></li><li><a href=CommentPolicy.html>ç•™è¨€æ”¿ç­–</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>è¯çµ¡æˆ‘å€‘</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>æå®¢å¿«è¨Š</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>