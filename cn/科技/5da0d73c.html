<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验 | 极客快訊</title><meta property="og:title" content="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5da0d73c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5da0d73c.html><meta property="article:published_time" content="2020-11-14T21:04:16+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:16+08:00"><meta name=Keywords content><meta name=description content="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5da0d73c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1）实验平台：正点原子开拓者FPGA 开发板</p><p style=text-align:start>2）摘自《开拓者FPGA开发指南》关注官方微信号公众号，获取更多资料：正点原子</p><p style=text-align:start>3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-13912-1-1.html</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption></p></div><p><strong>第三十二章 音频环回实验</strong></p><p>WM8978是一个低功耗、高质量的立体声多媒体数字信号编译码器，它结合了一个高质量的</p><p>立体声音频DAC和ADC，带有灵活的音频线输入、麦克风输入和音频输出处理。其主要应用于便</p><p>携式应用，可以应用到可携式数码摄像机或数码相机等设备。本章我们将使用FPGA开发板上的</p><p>WM8978器件实现音频环回的功能。</p><p>本章包括以下几个部分：</p><p>32.1 WM8978简介</p><p>32.2 实验任务</p><p>32.3 硬件设计</p><p>32.4 程序设计</p><p>32.5 下载验证</p><p><strong>WM8978简介</strong></p><p>WM8978是欧胜（Wolfson）推出的一款全功能音频处理器。它带有一个HI-FI级数字信号处</p><p>理内核，支持增强3D硬件环绕音效，以及5频段的硬件均衡器，可以有效改善音质。</p><p>WM8978具有高级的片上数字信号处理功能，包含一个5路均衡功能，一个用于ADC和麦克风</p><p>或者线路输入之间的混合信号的电平自动控制功能，一个纯粹的录音或者重放的数字限幅功能。</p><p>另外在ADC的线路上提供了一个数字滤波的功能，可以更好的应用滤波，比如“减少风噪”。</p><p>WM8978集成了立体声差分麦克风的前置放大与扬声器、耳机和差分、立体声线输出的驱动，</p><p>减少了应用时必需的外部组件，比如不需要单独的麦克风或者耳机的放大器。WM8978提供了一</p><p>个强悍的扬声器功放，可提供高达900mW的高质量音响效果扬声器功率，一个数字回放限制器</p><p>可防止扬声器声音过载。WM8978进一步提升了耳机放大器输出功率，在推动16欧姆耳机的时候，</p><p>每个声道最大输出功率高达40毫瓦！可以连接市面上绝大多数适合随身听的高端HI-FI耳机。</p><p>WM8978整体功能模块的框图如图 32.1.1所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af46b0d04a9144bb825a3b581f979193><p class=pgc-img-caption></p></div><p><br></p><p>图 32.1.1 WM8978整体功能框图</p><p>WM8978可通过I2S或PCM音频接口（I2S/PCM AUDIO INTERFACE）与FPGA进行音频数据传输。</p><p>具体应用哪种方式可通过控制接口（Control Interface）配置相应的寄存器。控制接口是一</p><p>个可选的2线或3线结构。通过MODE引脚选择（MODE引脚接高电平时为3线接口模式、低电平时</p><p>为2线接口模式），当控制接口为2线接口模式时，其时序图如下图所示。</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/29260db47da044969006c94a27cefceb><p class=pgc-img-caption></p></div><p>图 32.1.2 两线接口时序图</p><p>由上图可见，其时序图与I2C时序相同。此时SCLK为串行时钟线、SDIN为串行数据线，WM8978</p><p>芯片的器件地址固定为0011010b。本次实验我们使用的是两线的控制接口。</p><p>音频接口的ADCDAT为ADC数据的输出接口，本实验中WM8978通过此接口输出音频给FPGA，</p><p>DACDAT为DAC数据的输入接口，WM8978通过此接口接收FPGA输出的音频。LRC为音频左右声道的</p><p>数据对齐时钟信号，BCLK即Bit Clock（位时钟），用于同步数据输入和输出。MCLK为主时钟</p><p>输入接口，MCLK的频率为256fs，fs为音频的采样率，一般为48kHz，所以MCLK为256 × 48 =</p><p>12288kHz = 12.288MHz。我们一般使用FPGA内部的PLL分频得到12MHz的时钟信号，然后通过</p><p>配置WM8978内部的寄存器使其PLL输出12.288MHz的时钟信号。</p><p>WM8978支持主从两种工作模式。主从工作模式的区别在于BCLK和LRC由谁控制。在主模式</p><p>下，WM8978作为主控设备，产生BCLK和LRC信号并输出。在从模式下，BCLK和LRC信号由外部设</p><p>备（本实验指FPGA）提供，WM8978作为从设备接收BCLK和LRC信号。可见如果使WM8978工作在</p><p>从模式下，我们需要通过FPGA产生BCLK和LRC信号，既浪费FPGA内部的资源也浪费（空闲）了</p><p>WM8978本身的资源，所以一般使WM8978工作在主模式下。主从工作模式通过配置R6寄存器的</p><p>bit0位来设置，bit0位为0时WM8978工作在从模式下，为1时WM8978工作在主模式下，本次实验</p><p>我们使WM8978工作在主模式下。</p><p>对于音频接口，本次实验我们采用I2S音频总线接口传输音频数据。I2S(Inter-IC Sound)</p><p>总线，又称集成电路内置音频总线，是飞利浦公司为数字音频设备之间的音频数据传输而制定</p><p>的一种总线标准，该总线专门负责音频设备之间的数据传输，广泛应用于各种多媒体系统。I2S</p><p>的优点是接收端与发送端的音频数据有效位数可以不同。如果接收端能处理的有效位数少于发</p><p>送端，可以放弃数据帧中多余的低位数据；如果接收端能处理的有效位数多于发送端，可以自</p><p>行补足剩余的位。这种同步机制使得数字音频设备的互连更加方便，而且不会造成数据错位。</p><p>I2S总线的音频传输格式如下图：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/82272114282f415986fea7048633978f><p class=pgc-img-caption></p></div><p>图 32.1.3 I2S总线音频传输格式</p><p>fs为音频的采样率，LRC为左右声道的对齐时钟。由上图可知，当LRC为低电平时传输左声</p><p>道的音频数据，高电平时传输右声道的音频数据。位时钟BCLK的频率=2×采样频率×采样位数，</p><p>由于使用的是主模式，LRC和位时钟BCLK由WM8978提供，所以我们无需关心其频率的大小。我</p><p>们需要注意的是I2S格式的音频信号DACDAT和ADCDAT无论有多少位有效数据，数据的最高位总</p><p>是出现在LRC变化后的第2个BCLK脉冲处，即传输数据时高位在前，且该位在LRC变化后BCLK的</p><p>第2个上升沿采样到。</p><p>图 32.1.1中的LIP（LIN）、RIP（RIN）分别为左麦克风前置放大同相（反相）输入和右</p><p>麦克风前置放大同相（反相）输入，L2/GPIO2和R2/GPIO3分别为左通道线输入/GPIO引脚和右</p><p>通道线输入/GPIO引脚，AUXL和AUXR为左右辅助输入。LOUT1和ROUT1为耳机的左右输出，LOUT2</p><p>为第二左输出或者BTL扬声器反相输出，ROUT2第二右输出或者BTL扬声器同相输出。</p><p>由图 32.1.1可见输入到输出的通道通过一个个开关控制，每个开关由相应的寄存器控制。</p><p>配置相应的寄存器就可打开相应的通道、使能相应的功能。</p><p>WM8978内部有58个寄存器。每个寄存器的地址位为7位，数据位为9位。可通过控制接口配</p><p>置相应的寄存器以打开相应的通道或使能相应的功能。这里我们简单介绍一下要正常使用</p><p>WM8978来播放音乐时，需要配置的寄存器。</p><p>1.寄存器R0（00h），该寄存器用于控制WM8978的软复位，写任意值到该寄存器地址，即</p><p>可实现WM8978的软复位。</p><p>2.寄存器R1（01h），该寄存器需要设置VMIDSEL（bit[1:0]）为2’b11，开启最快启动；</p><p>BUFIOEN（bit2）为1，避免输入输出直接在WM8978内部环回；BIASEN（bit3）为1，模拟部分</p><p>的放大器才会工作，才可以听到声音，PLLEN（bit5）为1使能WM8978内部PLL功能，使WM8978</p><p>内部的主时钟为12.288MHz。</p><p>3.寄存器R2（02h），该寄存器需要设置ROUT1EN(bit8)、LOUT1EN(bit7)为1，使能耳机输</p><p>出；BOOSTENR（bit5）、BOOSTENL（bit4）为1，使能左右声道进入BOOST；ADCENR（bit1）、</p><p>ADCENL（bit0）为1，使能左右声道的ADC功能。</p><p>4.寄存器R3（03h），该寄存器要设置LOUT2EN(bit6)，ROUT2EN(bit5)，RMIXER(bit3)，</p><p>LMIXER(bit2)，DACENR(bit1)和DACENL(bit0)等6个位为1。LOUT2EN和ROUT2EN，设置为1，使</p><p>能喇叭输出；LMIXER和RMIXER设置为1，使能左右声道混合器；DACENL和DACENR则是使能左右</p><p>声道的DAC，使数字音频信号转换为模拟音频信号。</p><p>5.寄存器R4（04h），该寄存器要设置WL(bit[6:5])和FMT(bit[4:3]) 4个位。WL(bit[6:5])</p><p>用于设置字长（即设置音频数据有效位数），00表示16位音频，10表示24位音频；FMT(bit[4:3])</p><p>用于设置音频接口数据传输格式，我们设置为10，使用I2S音频数据格式传输音频数据。</p><p>6.寄存器R6（06h），该寄存器的MS（bit0）设置为1，使WM8978工作在主模式下，输出BCLK</p><p>和LRC给FPGA。</p><p>7.寄存器R7（07h），该寄存器我们要设置采样率SR（bit[3:1]）为000，使用48kHz的采</p><p>样率；设置SLOWCLKEN（bit0）为1，使能零交叉功能。</p><p>8.寄存器R10（0Ah），该寄存器我们要设置DACOSR128(bit3)为1，DAC得到最好的SNR。</p><p>9.寄存器R14（0Eh），该寄存器我们要设置ADCOSR128(bit3)为1，ADC得到最好的SNR。</p><p>10.寄存器R43（2Bh），该寄存器我们只需要设置INVROUT2（bit4）为1即可，反转ROUT2</p><p>输出，更好的驱动喇叭。</p><p>11.寄存器R47（2Fh）和寄存器R48（30h），这两个寄存器设置类似，一个用于设置左声</p><p>道（R47）输入增益（bit[6:4]），另外一个用于设置右声道（R48）输入增益（bit[6:4]）。</p><p>12.寄存器R49（31h），该寄存器我们要设置SPKBOOST(bit2)和TSDEN(bit1)这两个位。</p><p>SPKBOOST用于设置喇叭的增益，我们设置为1（gain=+1.5）以获得更大的声音；TSDEN用于设</p><p>置过热保护，设置为1（开启）即可。</p><p>13.寄存器R50（32h）和 R51（33h），这两个寄存器一个用于设置左声道（R50），另外</p><p>一个用于设置右声道（R51）。我们只需要设置这两个寄存器的最低位为1即可，将左右声道的</p><p>DAC输出接入左右声道混合器里面，才能在耳机/喇叭听到音乐。</p><p>14.寄存器R52（34h）和R53（35h），这两个寄存器用于设置耳机音量，同样一个用于设</p><p>置左声道（R52），另外一个用于设置右声道（R53）。这两个寄存器的最高位（HPVU）用于设</p><p>置是否更新左右声道的音量，最低6位用于设置左右声道的音量，我们可以先设置好两个寄存器的音量值，最后设置其中一个寄存器最高位为1，即可更新音量设置。</p><p>15.寄存器R54（36h）和R55（37h），这两个寄存器用于设置喇叭音量，同R52，R53设置</p><p>一模一样，这里就不细说了。</p><p>以上，就是我们用WM8978播放音乐时的设置，按照以上所述，对各个寄存器进行相应的配</p><p>置，即可使用WM8978播放音乐了。还有其他一些3D设置，EQ设置等，我们这里就不再介绍了，</p><p>大家参考WM8978的数据手册自行研究下即可。</p><p><strong>实验任务</strong></p><p>本节实验任务是将电脑或手机的音乐通过开拓者开发板上的WM8978器件输出到FPGA，然后</p><p>FPGA通过WM8978器件输出给耳机和喇叭。</p><p><strong>硬件设计</strong></p><p>开拓者开发板上音频模块WM8978接口部分的原理图如图 32.3.1所示。</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c98adda02ec4e718b38ce981637211a><p class=pgc-img-caption></p></div><p><br></p><p>图 32.3.1 WM8978接口原理图</p><p>WM8978的MODE引脚接地，选择的是两线接口模式，等同于I2C接口。L2/GPIO2和R2/GPIO3</p><p>作为音频输入接口（LINE_IN），外部音频从此接口输入；LOUT1和ROUT1作为音频输出接口</p><p>（PHONE），输出给外接耳机。LOUT2和ROUT2为喇叭接口。</p><p>本实验中，各端口信号的管脚分配如下表所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ece245ba4c634131a200303bf056e8ea><p class=pgc-img-caption></p></div><p><br></p><p>表 32.3.1 音频环回实验管脚分配</p><p><strong>程序设计</strong></p><p>根据实验任务，我们可以大致规划出系统的控制流程：FPGA首先通过控制接口配置WM8978</p><p>相关的寄存器，然后接收WM8978传输过来的音频数据，并将接收到的音频数据传递给WM8978发</p><p>送出去。由此画出系统的功能框图如下所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f25a30c1a3547e6b3b8622a229e78ab><p class=pgc-img-caption></p></div><p>图 32.4.1 WM8978音频环回实验系统框图</p><p>由系统框图可知，FPGA部分包括八个模块，顶层模块（audio_speak）、WM8978控制模块（wm8978_ctrl）、时钟分频模块（pll_clk）、音频接收模块（audio_receive）、音频发送模</p><p>块（audio_send）、WM8978配置模块（wm8978_config）、I2C配置模块（i2c_reg_cfg）和I2C</p><p>驱动模块（i2c_dri）。各模块的功能如下：</p><p>顶层模块（audio_speak）：顶层模块完成了对WM8978控制模块和时钟分频模块的例化。</p><p>并将音频接收模块接收到的音频数据adc_data连接至音频发送模块的数据端口dac_data，实现</p><p>信号的交互连接。顶层模块的原理图如下图所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01ed80c5143147f59ab62e35e2227a45><p class=pgc-img-caption></p></div><p><br></p><p>图 32.4.2 顶层模块原理图</p><p>时钟分频模块（pll_clk）：时钟分频模块即锁相环（PLL）模块，调用锁相环（PLL）IP</p><p>核以产生12Mhz时钟作为WM8978的主时钟MCLK。</p><p>WM8978控制模块（wm8978_ctrl）：WM8978控制模块例化了WM8978配置模块，音频接收模</p><p>块和音频发送模块。WM8978控制模块是对WM8978器件底层操作的封装，使用WM8978时例化此模</p><p>块即可。WM8978控制模块的原理图如下图所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dfb79da18baf4dd78e187ead69255c3d><p class=pgc-img-caption></p></div><p>图 32.4.3 WM8978控制模块原理图</p><p>音频接收模块（audio_receive）：音频接收模块是接收来自WM8978的音频数据，并将WM8978</p><p>串行输入的音频数据进行并行处理。</p><p>音频发送模块（audio_send）：音频发送模块是将FPGA输出的并行音频数据串行输出至</p><p>WM8978。</p><p>WM8978配置模块（wm8978_config）：WM8978配置模块例化了I2C驱动模块（i2c_dri）和</p><p>I2C配置模块（i2c_reg_cfg），其内部端口及信号连接如下图所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/708f33e8db0c4af6a8312b013253d419><p class=pgc-img-caption></p></div><p><br></p><p>图 32.4.4 WM8978配置模块原理图</p><p>I2C驱动模块（i2c_dri）：因为WM8978的两线控制接口的时序与I2C时序相同，所以我们</p><p>这里调用了“EEPROM实验”的I2C驱动模块，实现FPGA对WM8978控制接口的操作。</p><p>I2C配置模块（i2c_reg_cfg）：主要完成对WM8978相关寄存器的配置。</p><p>顶层模块的代码如下：</p><p>1 <strong>module </strong>audio_speak<strong>(</strong></p><p>2 //system clock 50MHz</p><p>3 <strong>input</strong> sys_clk <strong>,</strong> // 系统时钟(50MHz)</p><p>4 <strong>input</strong> sys_rst_n <strong>,</strong> // 系统复位</p><p>5</p><p>6 //wm8978 interface</p><p>7 //audio interface(master mode)</p><p>8 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位时钟</p><p>9 <strong>input</strong> aud_lrc <strong>,</strong> // 对齐信号</p><p>10 <strong>input</strong> aud_adcdat<strong>,</strong> // 音频输入</p><p>11 <strong>output</strong> aud_mclk <strong>,</strong> // WM8978的主时钟(最大为12.288MHz)</p><p>12 <strong>output</strong> aud_dacdat<strong>,</strong> // 音频输出</p><p>13 //control interface</p><p>14 <strong>output</strong> aud_scl <strong>,</strong> // WM8978的SCL信号</p><p>15 <strong>inout</strong> aud_sda // WM8978的SDA信号</p><p>16 <strong>);</strong></p><p>17</p><p>18 //wire define</p><p>19 <strong>wire</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> adc_data<strong>;</strong> // FPGA采集的音频数据</p><p>20</p><p>21 //*****************************************************</p><p>22 //** main code</p><p>23 //*****************************************************</p><p>24</p><p>25 //例化pll_clk</p><p>26 pll_clk u_pll_clk<strong>(</strong></p><p>27 <strong>.</strong>areset <strong>(~</strong>sys_rst_n<strong>),</strong> // pll_clk异步复位信号</p><p>28 <strong>.</strong>inclk0 <strong>(</strong>sys_clk <strong>),</strong> // 输入sys_clk = 50 MHZ</p><p>29 <strong>.</strong>c0 <strong>(</strong>aud_mclk <strong>)</strong> // WM8978的MCLK信号（12MHz)</p><p>30 <strong>);</strong></p><p>31</p><p>32 //例化WM89878控制模块</p><p>33 wm8978_ctrl u_wm8978_ctrl<strong>(</strong></p><p>34 //system clock</p><p>35 <strong>.</strong>clk <strong>(</strong>sys_clk <strong>),</strong> // 时钟信号</p><p>36 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 复位信号</p><p>37 //wm8978 interface</p><p>38 //audio interface(master mode)</p><p>39 <strong>.</strong>aud_bclk <strong>(</strong>aud_bclk <strong>),</strong> // WM8978位时钟</p><p>40 <strong>.</strong>aud_lrc <strong>(</strong>aud_lrc <strong>),</strong> // 对齐信号</p><p>41 <strong>.</strong>aud_adcdat <strong>(</strong>aud_adcdat <strong>),</strong> // 音频输入</p><p>42 <strong>.</strong>aud_dacdat <strong>(</strong>aud_dacdat <strong>),</strong> // 音频输出</p><p>43 //control interface</p><p>44 <strong>.</strong>aud_scl <strong>(</strong>aud_scl <strong>),</strong> // WM8978的SCL信号</p><p>45 <strong>.</strong>aud_sda <strong>(</strong>aud_sda <strong>),</strong> // WM8978的SDA信号</p><p>46 //user interface</p><p>47 <strong>.</strong>dac_data <strong>(</strong>adc_data <strong>),</strong> // 输出的音频数据</p><p>48 <strong>.</strong>adc_data <strong>(</strong>adc_data <strong>),</strong> // 输入的音频数据</p><p>49 <strong>.</strong>rx_done <strong>(),</strong> // 一次接收完成</p><p>50 <strong>.</strong>tx_done <strong>()</strong> // 一次发送完成</p><p>51 <strong>);</strong></p><p>52</p><p>53 <strong>endmodule</strong></p><p>顶层模块中主要完成对其余模块的例化。程序中第29行的c0是经锁相环（PLL）分频输出</p><p>的WM8978的主时钟。第48行是FPGA串转并处理后的音频数据，这里我们直接把该端口的音频数</p><p>据信号连到第47行的音频数据端口dac_data，实现音频数据的环回。当然了也可以直接将音频</p><p>输入信号aud_adcdat直接连接至第42行的音频输出端口aud_dacdat，来实现音频环回，但这样</p><p>处理就不能测试音频接收模块和音频发送模块的功能是否正确。</p><p>WM8978控制模块的代码如下所示：</p><p>1 <strong>module </strong>wm8978_ctrl<strong>(</strong></p><p>2 //system clock</p><p>3 <strong>input</strong> clk <strong>,</strong> // 时钟信号</p><p>4 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>5</p><p>6 //wm8978 interface</p><p>7 //audio interface(master mode)</p><p>8 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位时钟</p><p>9 <strong>input</strong> aud_lrc <strong>,</strong> // 对齐信号</p><p>10 <strong>input</strong> aud_adcdat <strong>,</strong> // 音频输入</p><p>11 <strong>output</strong> aud_dacdat <strong>,</strong> // 音频输出</p><p>12 //control interface</p><p>13 <strong>output</strong> aud_scl <strong>,</strong> // WM8978的SCL信号</p><p>14 <strong>inout</strong> aud_sda <strong>,</strong> // WM8978的SDA信号</p><p>15</p><p>16 //user interface</p><p>17 <strong>input</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> dac_data <strong>,</strong> // 输出的音频数据</p><p>18 <strong>output</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> adc_data <strong>,</strong> // 录音的数据</p><p>19 <strong>output</strong> rx_done <strong>,</strong> // 一次接收完成</p><p>20 <strong>output</strong> tx_done // 一次发送完成</p><p>21 <strong>);</strong></p><p>22</p><p>23 //parameter define</p><p>24 <strong>parameter</strong> WL <strong>= </strong>6'd32<strong>;</strong> // word length音频字长定义</p><p>25</p><p>26 //*****************************************************</p><p>27 //** main code</p><p>28 //*****************************************************</p><p>29</p><p>30 //例化wm8978_config,配置WM8978的寄存器</p><p>31 wm8978_config <strong>#(.</strong>WL<strong>(</strong>WL<strong>)) </strong>u_wm8978_config<strong>(</strong></p><p>32 //system clock</p><p>33 <strong>.</strong>clk <strong>(</strong>clk <strong>),</strong> // 时钟信号</p><p>34 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 复位信号</p><p>35 //wm8978 interface</p><p>36 <strong>.</strong>aud_scl <strong>(</strong>aud_scl <strong>),</strong> // WM8978的SCL时钟</p><p>37 <strong>.</strong>aud_sda <strong>(</strong>aud_sda <strong>)</strong> // WM8978的SDA信号</p><p>38 //user interface</p><p>39 <strong>);</strong></p><p>40</p><p>41 //例化audio_receive，FPGA接收WM8978的音频数据</p><p>42 audio_receive <strong>#(.</strong>WL<strong>(</strong>WL<strong>)) </strong>u_audio_receive<strong>(</strong></p><p>43 //system reset</p><p>44 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 复位信号</p><p>45 //wm8978 interface</p><p>46 <strong>.</strong>aud_bclk <strong>(</strong>aud_bclk<strong>),</strong> // WM8978位时钟</p><p>47 <strong>.</strong>aud_lrc <strong>(</strong>aud_lrc <strong>),</strong> // 对齐信号</p><p>48 <strong>.</strong>aud_adcdat<strong>(</strong>aud_adcdat<strong>),</strong> // 音频输入</p><p>49 //user interface</p><p>50 <strong>.</strong>rx_done <strong>(</strong>rx_done <strong>),</strong> // FPGA接收数据完成</p><p>51 <strong>.</strong>adc_data <strong>(</strong>adc_data<strong>)</strong> // FPGA接收的数据</p><p>52 <strong>);</strong></p><p>53</p><p>54 //例化audio_send，FPGA向WM8978传送音频数据</p><p>55 audio_send <strong>#(.</strong>WL<strong>(</strong>WL<strong>)) </strong>u_audio_send<strong>(</strong></p><p>56 //system reset</p><p>57 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 复位信号</p><p>58 //wm8978 interface</p><p>59 <strong>.</strong>aud_bclk <strong>(</strong>aud_bclk <strong>),</strong> // WM8978位时钟</p><p>60 <strong>.</strong>aud_lrc <strong>(</strong>aud_lrc <strong>),</strong> // 对齐信号</p><p>61 <strong>.</strong>aud_dacdat<strong>(</strong>aud_dacdat<strong>),</strong> // 音频数据输出</p><p>62 //user interface</p><p>63 <strong>.</strong>dac_data <strong>(</strong>dac_data <strong>),</strong> // 预输出的音频数据</p><p>64 <strong>.</strong>tx_done <strong>(</strong>tx_done <strong>)</strong> // 发送完成信号</p><p>65 <strong>);</strong></p><p>66</p><p>67 <strong>endmodule</strong></p><p>WM8978控制模块主要完成对WM8978器件层代码的封装，这样当操作WM8978时，只需例化</p><p>此模块即可实现WM8978的寄存器配置、音频接收、音频发送的功能。代码第24行的参数WL即音</p><p>频字长（word length），当用于接收、发送不同字长的音频数据时，可修改此参数。</p><p>WM8978音频配置模块的代码如下所示：</p><p>1 <strong>module </strong>wm8978_config<strong>(</strong></p><p>2 //system clock</p><p>3 <strong>input</strong> clk <strong>,</strong> // 时钟信号</p><p>4 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>5</p><p>6 //wm8978 interface</p><p>7 <strong>output</strong> aud_scl <strong>,</strong> // WM8978的SCL时钟</p><p>8 <strong>inout</strong> aud_sda // WM8978的SDA信号</p><p>9</p><p>10 //user interface</p><p>11 <strong>);</strong></p><p>12</p><p>13 //parameter define</p><p>14 <strong>parameter</strong> SLAVE_ADDR <strong>=</strong> 7'h1a <strong>;</strong> // 器件地址</p><p>15 <strong>parameter</strong> WL <strong>=</strong> 6'd32 <strong>;</strong> // word length音频字长参数设置</p><p>16 <strong>parameter</strong> BIT_CTRL <strong>=</strong> 1'b0 <strong>;</strong> // 字地址位控制参数(16b/8b)</p><p>17 <strong>parameter</strong> CLK_FREQ <strong>= </strong>26'd50_000_000<strong>;</strong> // i2c_dri模块的驱动时钟频率(CLK_FREQ)</p><p>18 <strong>parameter</strong> I2C_FREQ <strong>= </strong>18'd250_000 <strong>;</strong> // I2C的SCL时钟频率</p><p>19</p><p>20 //wire define</p><p>21 <strong>wire</strong> clk_i2c <strong>;</strong> // i2c的操作时钟</p><p>22 <strong>wire</strong> i2c_exec <strong>;</strong> // i2c触发控制</p><p>23 <strong>wire</strong> i2c_rh_wl <strong>;</strong> // I2C读写控制信号</p><p>24 <strong>wire</strong> i2c_done <strong>;</strong> // i2c操作结束标志</p><p>25 <strong>wire</strong> cfg_done <strong>;</strong> // WM8978配置完成标志</p><p>26 <strong>wire</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> reg_data <strong>;</strong> // WM8978需要配置的寄存器（地址及数据）</p><p>27</p><p>28 //*****************************************************</p><p>29 //** main code</p><p>30 //*****************************************************</p><p>31</p><p>32 //例化i2c_dri,调用IIC协议</p><p>33 i2c_dri <strong>#(</strong></p><p>34 <strong>.</strong>SLAVE_ADDR <strong>(</strong>SLAVE_ADDR<strong>),</strong> // slave address从机地址，放此处方便参数传递</p><p>35 <strong>.</strong>CLK_FREQ <strong>(</strong>CLK_FREQ <strong>),</strong> // i2c_dri模块的驱动时钟频率(CLK_FREQ)</p><p>36 <strong>.</strong>I2C_FREQ <strong>(</strong>I2C_FREQ <strong>)</strong> // I2C的SCL时钟频率</p><p>37 <strong>) </strong>u_i2c_dri<strong>(</strong></p><p>38 //global clock</p><p>39 <strong>.</strong>clk <strong>(</strong>clk <strong>),</strong> // i2c_dri模块的驱动时钟(CLK_FREQ)</p><p>40 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 复位信号</p><p>41 //i2c interface</p><p>42 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C触发执行信号</p><p>43 <strong>.</strong>bit_ctrl <strong>(</strong>BIT_CTRL <strong>),</strong> // 器件地址位控制(16b/8b)</p><p>44 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl <strong>),</strong> // I2C读写控制信号</p><p>45 <strong>.</strong>i2c_addr <strong>(</strong>reg_data<strong>[</strong>15<strong>:</strong>8<strong>]),</strong> // I2C器件字地址</p><p>46 <strong>.</strong>i2c_data_w <strong>(</strong>reg_data<strong>[ </strong>7<strong>:</strong>0<strong>]),</strong> // I2C要写的数据</p><p>47 <strong>.</strong>i2c_data_r <strong>(),</strong> // I2C读出的数据</p><p>48 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I 2C一次操作完成</p><p>49 <strong>.</strong>scl <strong>(</strong>aud_scl <strong>),</strong> // I2C的SCL时钟信号</p><p>50 <strong>.</strong>sda <strong>(</strong>aud_sda <strong>),</strong> // I2C的SDA信号</p><p>51 //user interface</p><p>52 <strong>.</strong>dri_clk <strong>(</strong>clk_i2c <strong>)</strong> // I2C操作时钟</p><p>53 <strong>);</strong></p><p>54</p><p>55 //例化i2c_reg_cfg模块，配置WM8978的寄存器</p><p>56 i2c_reg_cfg <strong>#(.</strong>WL<strong>(</strong>WL<strong>)</strong> // word length音频字长参数设置</p><p>57 <strong>) </strong>u_i2c_reg_cfg<strong>(</strong></p><p>58 //clock & reset</p><p>59 <strong>.</strong>clk <strong>(</strong>clk_i2c <strong>),</strong> // i2c_reg_cfg驱动时钟(一般取1MHz)</p><p>60 <strong>.</strong>rst_n <strong>(</strong>rst_n <strong>),</strong> // 复位信号</p><p>61 //i2c interface</p><p>62 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I2C一次操作完成的反馈信号</p><p>63 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C触发执行信号</p><p>64 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl<strong>),</strong> // i2c读写控制</p><p>65 <strong>.</strong>cfg_done <strong>(</strong>cfg_done <strong>),</strong> // WM8978配置完成</p><p>66 <strong>.</strong>i2c_data <strong>(</strong>reg_data <strong>)</strong> // 寄存器数据（7位地址+9位数据）</p><p>67 <strong>);</strong></p><p>68</p><p>69 <strong>endmodule</strong></p><p>WM8978音频配置模块主要完成对I2C驱动模块和寄存器配置模块的例化。程序中第15行的</p><p>WL参数用于音频字长设置，也即音频的采样后的量化位数。音频字长可选择为16bit、20bit、</p><p>24bit或32bit，量化位数越多，声音的质量越高，这里我们采用32bit。</p><p>其中I2C驱动模块（i2c_dri）程序与“EEPROM读写实验”章节中的IIC驱动模块（i2c_dri）</p><p>程序完全相同。有关IIC驱动模块的详细介绍请大家参考“EEPROM读写实验”。</p><p>I2C配置模块的代码如下：</p><p>1 <strong>module </strong>i2c_reg_cfg <strong>(</strong></p><p>2 <strong>input</strong> clk <strong>,</strong> // i2c_reg_cfg驱动时钟(一般取1MHz)</p><p>3 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>4 <strong>input</strong> i2c_done <strong>,</strong> // I2C一次操作完成反馈信号</p><p>5 <strong>output</strong> <strong>reg</strong> i2c_exec <strong>,</strong> // I2C触发执行信号</p><p>6 <strong>output</strong> <strong>reg</strong> cfg_done <strong>,</strong> // WM8978配置完成</p><p>7 <strong>output</strong> <strong>reg</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> i2c_data // 寄存器数据（7位地址+9位数据）</p><p>8 <strong>);</strong></p><p>9</p><p>10 //parameter define</p><p>11 <strong>parameter</strong> WL <strong>= </strong>6'd32<strong>;</strong> // word length音频字长参数设置</p><p>12</p><p>13 //parameter define</p><p>14 <strong>localparam </strong>REG_NUM <strong>= </strong>5'd19<strong>;</strong> // 总共需要配置的寄存器个数</p><p>15 <strong>localparam </strong>PHONE_VOLUME <strong>= </strong>6'd30<strong>;</strong> // 耳机输出音量大小参数（0~63）</p><p>16 <strong>localparam </strong>SPEAK_VOLUME <strong>= </strong>6'd45<strong>;</strong> // 喇叭输出音量大小参数（0~63）</p><p>17</p><p>18 //reg define</p><p>19 <strong>reg</strong> <strong>[</strong>1<strong>:</strong>0<strong>]</strong> wl <strong>;</strong> // word length音频字长参数定义</p><p>20 <strong>reg</strong> <strong>[</strong>7<strong>:</strong>0<strong>]</strong> start_init_cnt<strong>;</strong> // 初始化延时计数器</p><p>21 <strong>reg</strong> <strong>[</strong>4<strong>:</strong>0<strong>]</strong> init_reg_cnt <strong>;</strong> // 寄存器配置个数计数器</p><p>22</p><p>23 //*****************************************************</p><p>24 //** main code</p><p>25 //*****************************************************</p><p>26</p><p>27 //音频字长（位数）参数设置</p><p>28 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>29 <strong>if(!</strong>rst_n<strong>)</strong></p><p>30 wl <strong>&lt;= </strong>2'b00<strong>;</strong></p><p>31 <strong>else begin</strong></p><p>32 <strong>case(</strong>WL<strong>)</strong></p><p>33 6'd16<strong>:</strong> wl <strong>&lt;= </strong>2'b00<strong>;</strong></p><p>34 6'd20<strong>:</strong> wl <strong>&lt;= </strong>2'b01<strong>;</strong></p><p>35 6'd24<strong>:</strong> wl <strong>&lt;= </strong>2'b10<strong>;</strong></p><p>36 6'd32<strong>:</strong> wl <strong>&lt;= </strong>2'b11<strong>;</strong></p><p>37 <strong>default:</strong></p><p>38 wl <strong>&lt;= </strong>2'd00<strong>;</strong></p><p>39 <strong>endcase</strong></p><p>40 <strong>end</strong></p><p>41 <strong>end</strong></p><p>42</p><p>43 //上电或复位后延时一段时间</p><p>44 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>45 <strong>if(!</strong>rst_n<strong>)</strong></p><p>46 start_init_cnt <strong>&lt;= </strong>8'd0<strong>;</strong></p><p>47 <strong>else if(</strong>start_init_cnt <strong>&lt; </strong>8'hff<strong>)</strong></p><p>48 start_init_cnt <strong>&lt;= </strong>start_init_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>49 <strong>end</strong></p><p>50</p><p>51 //触发I2C操作</p><p>52 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>53 <strong>if(!</strong>rst_n<strong>)</strong></p><p>54 i2c_exec <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>55 <strong>else if(</strong>init_reg_cnt <strong>== </strong>5'd0 <strong>& </strong>start_init_cnt <strong>== </strong>8'hfe<strong>)</strong></p><p>56 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>57 <strong>else if(</strong>i2c_done <strong>&& </strong>init_reg_cnt <strong>&lt; </strong>REG_NUM<strong>)</strong></p><p>58 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>59 <strong>else</strong></p><p>60 i2c_exec <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>61 <strong>end</strong></p><p>62</p><p>63 //配置寄存器计数</p><p>64 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>65 <strong>if(!</strong>rst_n<strong>)</strong></p><p>66 init_reg_cnt <strong>&lt;= </strong>5'd0<strong>;</strong></p><p>67 <strong>else if(</strong>i2c_exec<strong>)</strong></p><p>68 init_reg_cnt <strong>&lt;= </strong>init_reg_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>69 <strong>end</strong></p><p>70</p><p>71 //寄存器配置完成信号</p><p>72 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>73 <strong>if(!</strong>rst_n<strong>)</strong></p><p>74 cfg_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>75 <strong>else if(</strong>i2c_done <strong>& (</strong>init_reg_cnt <strong>== </strong>REG_NUM<strong>) )</strong></p><p>76 cfg_done <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>77 <strong>end</strong></p><p>78</p><p>79 //配置I2C器件内寄存器地址及其数据</p><p>80 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>81 <strong>if(!</strong>rst_n<strong>)</strong></p><p>82 i2c_data <strong>&lt;= </strong>16'b0<strong>;</strong></p><p>83 <strong>else begin</strong></p><p>84 <strong>case(</strong>init_reg_cnt<strong>)</strong></p><p>85 // R0,软复位</p><p>86 5'd0 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd0 <strong>,</strong>9'b1<strong>};</strong></p><p>87 // R1,设置VMIDSEL,BUFIOEN,BIASEN,PLLEN,BUFDCOPEN</p><p>88 5'd1 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd1 <strong>,</strong>9'b1_0010_1111<strong>};</strong></p><p>89 // R2,使能BOOSTENR,BOOSTENL和ADCENR/L；使能ROUT1,LOUT1</p><p>90 5'd2 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd2 <strong>,</strong>9'b1_1011_0011<strong>};</strong></p><p>91 // R3,LOUT2,ROUT2输出使能(喇叭工作),RMIX,LMIX,DACENR、DACENL使能</p><p>92 5'd3<strong>: </strong>i2c_data <strong>&lt;=</strong> <strong>{</strong>7'd3 <strong>,</strong>9'b0_0110_1111<strong>};</strong></p><p>93 // R4,配置wm8978音频接口数据为I2S格式（bit4：3），字长度(wl)</p><p>94 5'd4 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd4 <strong>,{</strong>2'd0<strong>,</strong>wl<strong>,</strong>5'b10000<strong>}};</strong></p><p>95 // R6,设置为MASTER MODE(BCLK和LRC输出)</p><p>96 5'd5 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd6 <strong>,</strong>9'b0_0000_0001<strong>};</strong></p><p>97 // R7,使能slow clock，采样率为48KHz（bit3：1）</p><p>98 5'd6 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd7 <strong>,</strong>9'b0_0000_0001<strong>};</strong></p><p>99 // R10,设置DAC过采样率为128x（bit3）,以实现最佳信噪比</p><p>100 5'd7 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd10<strong>,</strong>9'b0_0000_1000<strong>};</strong></p><p>101 // R14,设置ADC过采样率为128x（bit3）,以达到最佳信噪比</p><p>102 5'd8 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd14<strong>,</strong>9'b1_0000_1000<strong>};</strong></p><p>103 // R43,INVROUT2（bit4）反向,驱动喇叭</p><p>104 5'd9 <strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd43<strong>,</strong>9'b0_0001_0000<strong>};</strong></p><p>105 // R47,左通道输入增益控制，L2_2BOOSTVOL（bit6：4）</p><p>106 5'd10<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd47<strong>,</strong>9'b0_0111_0000<strong>};</strong></p><p>107 // R48,右通道输入增益控制</p><p>108 5'd11<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd48<strong>,</strong>9'b0_0111_0000<strong>};</strong></p><p>109 // R49,TSDEN（bit0）,开启过热保护；SPKBOOST（bit2）1.5倍增益</p><p>110 5'd12<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd49<strong>,</strong>9'b0_0000_0110<strong>};</strong></p><p>111 // R50,选择左DAC输出至左输出混合器（bit0）</p><p>112 5'd13<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd50<strong>,</strong>9'b1<strong>};</strong></p><p>113 // R51,选择右DAC输出至右输出混合器（bit0）</p><p>114 5'd14<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd51<strong>,</strong>9'b1<strong>};</strong></p><p>115 // R52,耳机左声道音量设置（bit5:0），使能零交叉（bit7）</p><p>116 5'd15<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd52<strong>,{</strong>3'b010<strong>,</strong>PHONE_VOLUME<strong>}};</strong></p><p>117 // R53,耳机右声道音量设置（bit5:0），使能零交叉（bit7）,同步更新(HPVU=1)</p><p>118 5'd16<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd53<strong>,{</strong>3'b110<strong>,</strong>PHONE_VOLUME<strong>}};</strong></p><p>119 // R54,喇叭左声道音量设置（bit5:0），使能零交叉（bit7）</p><p>120 5'd17<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd54<strong>,{</strong>3'b010<strong>,</strong>SPEAK_VOLUME<strong>}};</strong></p><p>121 // R55,喇叭右声道音量设置（bit5:0），使能零交叉（bit7）,同步更新(SPKVU=1)</p><p>122 5'd18<strong>: </strong>i2c_data <strong>&lt;= {</strong>7'd55<strong>,{</strong>3'b110<strong>,</strong>SPEAK_VOLUME<strong>}};</strong></p><p>123 <strong>default : ;</strong></p><p>124 <strong>endcase</strong></p><p>125 <strong>end</strong></p><p>126 <strong>end</strong></p><p>127</p><p>128 <strong>endmodule</strong></p><p>I2C配置模块主要完成对WM8978的寄存器配置。WM8978开始上电时电压有可能不够稳定，</p><p>所以程序中定义了一个延时计数器（start_init_cnt）等待WM8978工作在稳定的状态。当计数</p><p>器计数到预设值之后，开始第一次配置即软复位，目的是让所有的寄存器复位到默认的状态。</p><p>发送完软件复位命令后，紧接着配置剩下的寄存器。在代码的第14行定义了总共需要配置的寄</p><p>存器的个数，如果增加或者删减了寄存器的配置，需要修改此参数。第15行和第16行分别为耳</p><p>机和喇叭的音量参数，调整耳机和喇叭的音量可修改此参数。</p><p>音频接收模块代码如下：</p><p>1 <strong>module </strong>audio_receive <strong>#(parameter </strong>WL <strong>= </strong>6'd32<strong>) (</strong> // WL(word length音频字长定义)</p><p>2 //system clock 50MHz</p><p>3 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>4</p><p>5 //wm8978 interface</p><p>6 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位时钟</p><p>7 <strong>input</strong> aud_lrc <strong>,</strong> // 对齐信号</p><p>8 <strong>input</strong> aud_adcdat<strong>,</strong> // 音频输入</p><p>9</p><p>10 //user interface</p><p>11 <strong>output</strong> <strong>reg</strong> rx_done <strong>,</strong> // FPGA接收数据完成</p><p>12 <strong>output</strong> <strong>reg [</strong>31<strong>:</strong>0<strong>]</strong> adc_data // FPGA接收的数据</p><p>13 <strong>);</strong></p><p>14</p><p>15 //reg define</p><p>16 <strong>reg</strong> aud_lrc_d0<strong>;</strong> // aud_lrc延迟一个时钟周期</p><p>17 <strong>reg</strong> <strong>[ </strong>5<strong>:</strong>0<strong>]</strong> rx_cnt<strong>;</strong> // 发送数据计数</p><p>18 <strong>reg</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> adc_data_t<strong>;</strong> // 预输出的音频数据的暂存值</p><p>19</p><p>20 //wire define</p><p>21 <strong>wire</strong> lrc_edge <strong>;</strong> // 边沿信号</p><p>22</p><p>23 //*****************************************************</p><p>24 //** main code</p><p>25 //*****************************************************</p><p>26</p><p>27 <strong>assign</strong> lrc_edge <strong>= </strong>aud_lrc <strong>^ </strong>aud_lrc_d0<strong>;</strong> // LRC信号的边沿检测</p><p>28</p><p>29 //为了在aud_lrc变化的第二个AUD_BCLK上升沿采集aud_adcdat,延迟打拍采集</p><p>30 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>31 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>32 aud_lrc_d0 <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>33 <strong>end</strong></p><p>34 <strong>else</strong></p><p>35 aud_lrc_d0 <strong>&lt;= </strong>aud_lrc<strong>;</strong></p><p>36 <strong>end</strong></p><p>37</p><p>38 //采集32位音频数据的计数</p><p>39 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>40 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>41 rx_cnt <strong>&lt;= </strong>6'd0<strong>;</strong></p><p>42 <strong>end</strong></p><p>43 <strong>else if(</strong>lrc_edge <strong>== </strong>1'b1<strong>)</strong></p><p>44 rx_cnt <strong>&lt;= </strong>6'd0<strong>;</strong></p><p>45 <strong>else if(</strong>rx_cnt <strong>&lt; </strong>6'd35<strong>)</strong></p><p>46 rx_cnt <strong>&lt;= </strong>rx_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>47 <strong>end</strong></p><p>48</p><p>49 //把采集到的音频数据临时存放在一个寄存器内</p><p>50 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>51 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>52 adc_data_t <strong>&lt;= </strong>32'b0<strong>;</strong></p><p>53 <strong>end</strong></p><p>54 <strong>else if(</strong>rx_cnt <strong>&lt; </strong>WL<strong>)</strong></p><p>55 adc_data_t<strong>[</strong>WL <strong>- </strong>1'd1 <strong>- </strong>rx_cnt<strong>] &lt;= </strong>aud_adcdat<strong>;</strong></p><p>56 <strong>end</strong></p><p>57</p><p>58 //把临时数据传递给adc_data,并使能rx_done,表明一次采集完成</p><p>59 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>60 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>61 rx_done <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>62 adc_data <strong>&lt;= </strong>32'b0<strong>;</strong></p><p>63 <strong>end</strong></p><p>64 <strong>else if(</strong>rx_cnt <strong>== </strong>6'd32<strong>) begin</strong></p><p>65 rx_done <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>66 adc_data<strong>&lt;= </strong>adc_data_t<strong>;</strong></p><p>67 <strong>end</strong></p><p>68 <strong>else</strong></p><p>69 rx_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>70 <strong>end</strong></p><p>71</p><p>72 <strong>endmodule</strong></p><p>音频接收模块的时钟信号是WM8978的位时钟信号aud_bclk，所以在程序的第3行我们只定</p><p>义了rst_n信号。</p><p>第27行的assign语句和第30行的always语句实现了aud_lrc信号的双边沿检测。第39行和</p><p>第50行的always语句实现了音频信号 aud_adcdat在aud_lrc信号变化后的第二个 BCLK</p><p>（aud_bclk）的上升沿采样，以及把音频信号的最高有效位放在adc_data_t的最高位。</p><p>音频发送模块的代码如下：</p><p>1 <strong>module </strong>audio_send <strong>#(parameter </strong>WL <strong>= </strong>6'd32<strong>) (</strong> // WL(word length音频字长定义)</p><p>2 //system reset</p><p>3 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>4</p><p>5 //wm8978 interface</p><p>6 <strong>input</strong> aud_bclk <strong>,</strong> // WM8978位时钟</p><p>7 <strong>input</strong> aud_lrc <strong>,</strong> // 对齐信号</p><p>8 <strong>output</strong> <strong>reg</strong> aud_dacdat<strong>,</strong> // 音频数据输出</p><p>9 //user interface</p><p>10 <strong>input</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> dac_data <strong>,</strong> // 预输出的音频数据</p><p>11 <strong>output</strong> <strong>reg</strong> tx_done // 发送一次音频位数完成</p><p>12 <strong>);</strong></p><p>13</p><p>14 //reg define</p><p>15 <strong>reg</strong> aud_lrc_d0<strong>;</strong> // aud_lrc延迟一个时钟周期</p><p>16 <strong>reg</strong> <strong>[ </strong>5<strong>:</strong>0<strong>]</strong> tx_cnt<strong>;</strong> // 发送数据计数</p><p>17 <strong>reg</strong> <strong>[</strong>31<strong>:</strong>0<strong>]</strong> dac_data_t<strong>;</strong> // 预输出的音频数据的暂存值</p><p>18</p><p>19 //wire define</p><p>20 <strong>wire</strong> lrc_edge<strong>;</strong> // 边沿信号</p><p>21</p><p>22 //*****************************************************</p><p>23 //** main code</p><p>24 //*****************************************************</p><p>25</p><p>26 <strong>assign</strong> lrc_edge <strong>= </strong>aud_lrc <strong>^ </strong>aud_lrc_d0<strong>;</strong> // LRC信号的边沿检测</p><p>27</p><p>28 //为了在aud_lrc变化的第二个AUD_BCLK上升沿采集aud_adcdat,延迟打拍采集</p><p>29 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>30 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>31 aud_lrc_d0 <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>32 <strong>end</strong></p><p>33 <strong>else</strong></p><p>34 aud_lrc_d0 <strong>&lt;= </strong>aud_lrc<strong>;</strong></p><p>35 <strong>end</strong></p><p>36</p><p>37 //发送32位音频数据的计数</p><p>38 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>39 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>40 tx_cnt <strong>&lt;=</strong> 6'd0<strong>;</strong></p><p>41 dac_data_t <strong>&lt;= </strong>32'd0<strong>;</strong></p><p>42 <strong>end</strong></p><p>43 <strong>else if(</strong>lrc_edge <strong>== </strong>1'b1<strong>) begin</strong></p><p>44 tx_cnt <strong>&lt;= </strong>6'd0<strong>;</strong></p><p>45 dac_data_t <strong>&lt;= </strong>dac_data<strong>;</strong></p><p>46 <strong>end</strong></p><p>47 <strong>else if(</strong>tx_cnt <strong>&lt; </strong>6'd35<strong>)</strong></p><p>48 tx_cnt <strong>&lt;= </strong>tx_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>49 <strong>end</strong></p><p>50</p><p>51 //发送完成信号</p><p>52 <strong>always @(posedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>53 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>54 tx_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>55 <strong>end</strong></p><p>56 <strong>else if(</strong>tx_cnt <strong>== </strong>6'd32<strong>)</strong></p><p>57 tx_done <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>58 <strong>else</strong></p><p>59 tx_done <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>60 <strong>end</strong></p><p>61</p><p>62 //把预发送的音频数据串行发送出去</p><p>63 <strong>always @(negedge </strong>aud_bclk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>64 <strong>if(!</strong>rst_n<strong>) begin</strong></p><p>65 aud_dacdat <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>66 <strong>end</strong></p><p>67 <strong>else if(</strong>tx_cnt <strong>&lt; </strong>WL<strong>)</strong></p><p>68 aud_dacdat <strong>&lt;= </strong>dac_data_t<strong>[</strong>WL <strong>- </strong>1'd1 <strong>- </strong>tx_cnt<strong>];</strong></p><p>69 <strong>else</strong></p><p>70 aud_dacdat <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>71 <strong>end</strong></p><p>72</p><p>73 <strong>endmodule</strong></p><p>音频发送模块与音频接收模块基本相同，有一点区别是程序第63行我们使用的是aud_bclk</p><p>的下降沿。这是为了能够让WM8978正确采集到I2S总线上的音频数据，即aud_lrc信号变化后的</p><p>第二个BCLK（aud_bclk）的上升沿采样到FPGA发送的音频信号aud_dacdat。</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/68925809a31748da9af4832f3d7c9a20><p class=pgc-img-caption></p></div><p><br></p><p>图 32.4.5是为音频环回过程中SignalTap抓取到的波形图。</p><p>从图中可以看到音频环回模块的aud_lrc信号的边沿检测信号lrc_edge，在aud_lrc变化后的第一个aud_bclk的低电平时拉高。</p><p>当FPGA接收音频时，在接下来的aud_bclk的第一个上升沿rx_cnt变为00h，在第二个上升沿时</p><p>采集WM8978发送过来的音频数据。当FPGA发送音频时，在接下来的aud_bclk的第一个下降沿传</p><p>输音频数据给WM8978，在第二个上升沿时WM8978采集FPGA发送的音频数据。这样就满足了I2S</p><p>信号传输格式的要求。</p><p>图 32.4.5 音频环回过程中 SignalTap抓取的波形图</p><p><strong>下载验证</strong></p><p>首先我们打开音频环回实验工程，在工程所在的路径下打开audio_speak/par文件夹，在</p><p>里面找到“audio_speak.qpf”并双击打开。注意工程所在的路径名只能由字母、数字以及下</p><p>划线组成，不能出现中文、空格以及特殊字符等。工程打开后如图 32.5.1所示。</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/77a9e33e5b16491a9f430ca616b0169b><p class=pgc-img-caption></p></div><p><br></p><p>图 32.5.1 音频环回实验工程</p><p>然后将下载器一端连电脑，另一端与开发板上对应端口连接，将音频连接线的一端连接至</p><p>电脑或手机的音频输出端口，另一端连接至WM8978的LINE_IN接口，然后将耳机连接至WM8978</p><p>的PHONE接口，最后连接电源线并打开电源开关。</p><p>开拓者开发板实物图如下所示：</p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f49ccc9ab92843189d9e512ad9e478cf><p class=pgc-img-caption></p></div><p>图 32.5.2 开拓者开发板硬件图</p><p>接下来我们下载程序，验证WM8978的音频环回功能。</p><p>工程打开后通过点击工具栏中的“Programmer”图标打开下载界面，通过“Add File”按</p><p>钮选择audio_speak/par/output_files目录下的“audio_speak.sof”文件。开发板电源打开</p><p>后，在程序下载界面点击“Hardware Setup”，在弹出的对话框中选择当前的硬件连接为“USB-</p><p>Blaster[USB-0]”。然后点击“Start”将工程编译完成后得到的sof文件下载到开发板中，如</p><p>图 32.5.3所示。</p><p><br></p><div class=pgc-img><img alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/33ad51f6505a4057bd483bdb198af6f5><p class=pgc-img-caption></p></div><p>图 32.5.3 程序下载界面</p><p>下载完成后打开音频连接线一端连接的电脑或手机，播放一首音乐，这时听到喇叭播放音</p><p>乐，戴上耳机，也能听到播放的音乐，说明音频环回实验程序下载验证成功。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'正点','开拓者','FPGA'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正点原子开拓者FPGA开发板资料连载第二十三章RGBTFT-LCD字符显示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/acdfbd47.html title=正点原子开拓者FPGA开发板资料连载第二十三章RGBTFT-LCD字符显示>正点原子开拓者FPGA开发板资料连载第二十三章RGBTFT-LCD字符显示</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/6cbd5c1.html alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/6cbd5c1.html title=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验>正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>