<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 | 极客快訊</title><meta property="og:title" content="Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/7872f862899e449b82762f48acd09ec2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e008fe9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e008fe9.html><meta property="article:published_time" content="2020-10-29T21:08:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:52+08:00"><meta name=Keywords content><meta name=description content="Android游戏2048方块的设计实现，编写，加上色彩，分数等功能"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5e008fe9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android游戏2048方块的设计实现，编写，加上色彩，分数等功能</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>关于2048，我看到很多大神，比如医生，郭神，所以我也研究了一段时间，还好是研究了一套逻辑，这是一整套的2048游戏从设计到逻辑再到编写的全部过程，小伙伴们看仔细咯，刚好今天是礼拜天，一天应该了一把这篇博客发表了，其实2048开发起来还是有点难度的，并且他的逻辑挺强的，我也是看了很多的资料偷学的，很适合来锻炼自己的逻辑性</p><p>我们首先先来选择开发环境，这里我们就以Eclipse为IDE，新建一个工程——Game2048</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7872f862899e449b82762f48acd09ec2><p class=pgc-img-caption></p></div><h1>一.Score分数</h1><p>既然是2048游戏，我们也就做一个简单的，他有一个分数，然后就是一个游戏的布局，我们也做一个简单的4*4的游戏，大概的设计图就是这样</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/abdd3946946e4a7e8a8d46cf73d6ea0e><p class=pgc-img-caption></p></div><h1>二.游戏类：GameView</h1><p>因为我们的游戏所使用到的布局就是GridLayout，所以我们新建一个GameView继承自GridLayout，然后通过算法动态添加方块，并且监听手势进行操作，这个重写的GridLayout就是游戏的布局了</p><p>&lt;com.lgl.game2048.GameView</p><p>android:id="@+id/game_view"</p><p>android:layout_width="match_parent"</p><p>android:layout_height="0dp"</p><p>android:layout_weight="1" /></p><h1>三.实现交互逻辑</h1><p>我们这里铁定是手势操作啦，这里我们就得区分手势是往上，往下，往左，往右，的手势，这时候，我们就需要用到手势监听——OnTouchListener了，也为了确保是实时监听，我们直接在initView的初始方法中处理</p><p>我们其实只要知道两点，用户手指按下的座标点和手指离开的座标点，然后进行比对，就能识别出用户的意图了</p><p>其实关于MotionEvent的几个方法，大家估计都见怪不怪了，因为用的太多了</p><p>// 初始化</p><p>private void initView() {</p><p>// 识别手势</p><p>setOnTouchListener(new OnTouchListener() {</p><p>// 起始点和偏移点</p><p>private float startX, startY, offsetX, offsetY;</p><p>@Override</p><p>public boolean onTouch(View v, MotionEvent event) {</p><p>/**</p><p>* 交互逻辑 :我们其实只要知道两点，用户手指按下的座标点和手指离开的座标点，然后进行比对，就能识别出用户的意图了</p><p>*/</p><p>switch (event.getAction()) {</p><p>// 手指按下</p><p>case MotionEvent.ACTION_DOWN:</p><p>// 记录按下的x,y座标</p><p>startX = event.getX();</p><p>startY = event.getY();</p><p>break;</p><p>// 手指离开</p><p>case MotionEvent.ACTION_UP:</p><p>// 手指离开之后计算偏移量(离开的位置-按下的位置在进行判断是往哪个方向移动)</p><p>offsetX = event.getX() - startX;</p><p>offsetY = event.getY() - startY;</p><p>// 开始识别方向</p><p>// offsetX 的绝对值大于offsetY的绝对值 说明在水平方向</p><p>if (Math.abs(offsetX) > Math.abs(offsetY)) {</p><p>// (直接&lt;0 会有些许误差，我们可以 &lt;-5)</p><p>if (offsetX &lt; -5) {</p><p>// 左</p><p>System.out.println("左");</p><p>} else if (offsetX > 5) {</p><p>// 右</p><p>System.out.println("右");</p><p>}</p><p>// 开始计算垂直方向上下的滑动</p><p>} else {</p><p>if (offsetY &lt; -5) {</p><p>// 上</p><p>System.out.println("上");</p><p>} else if (offsetY > 5) {</p><p>// 下</p><p>System.out.println("下");</p><p>}</p><p>}</p><p>break;</p><p>}</p><p>return true;</p><p>}</p><p>});</p><p>}</p><p>上面的逻辑是不是非常的简单，然后我们操作一下，看log</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/da2de7afc9bc4af5bf81270f3664a7c4><p class=pgc-img-caption></p></div><p>现在手势识别也是很精准了，当然，我们的代码设计也不能太过臃肿，所以，我们的操作逻辑就不在里面编写了，我们分别实现四个方向的方法</p><p>// 左</p><p>private void isLeft() {</p><p>}</p><p>// 右</p><p>private void isRight() {</p><p>}</p><p>// 上</p><p>private void isTop() {</p><p>}</p><p>// 下</p><p>private void isButtom() {</p><p>}</p><p>然后把输出语句替换掉，监听到哪个方向就执行哪个方法</p><p>//System.out.println("上，下，左，右");</p><p>private void isXXX() {</p><p>}</p><h1>四.实现方块类CardView</h1><p>我们可以把这一个个卡片看作是一个对象，我们每次操作，他都要进行实例化</p><p>首先，我们新建一个类CardView继承自FrameLayout，再里面我们要考虑三点</p><p>>1.卡片</p><p>>2.卡片上的数字</p><p>>卡片相同的比较</p><p>package com.lgl.game2048;</p><p>import android.content.Context;</p><p>import android.widget.FrameLayout;</p><p>import android.widget.TextView;</p><p>public class CardView extends FrameLayout {</p><p>// 卡片数量</p><p>private int num = 0;</p><p>// 卡片文字</p><p>private TextView tv_num;</p><p>public CardView(Context context) {</p><p>super(context);</p><p>// 初始化TextView</p><p>tv_num = new TextView(getContext());</p><p>// 卡片文字大小</p><p>tv_num.setTextSize(20);</p><p>// 布局控制器，填充满整个父容器</p><p>LayoutParams lp = new LayoutParams(-1, -1);</p><p>addView(tv_num, lp);</p><p>setNum(0);</p><p>}</p><p>public int getNum() {</p><p>return num;</p><p>}</p><p>public void setNum(int num) {</p><p>this.num = num;</p><p>// 要呈现出来的文字（这里要注意是String类型的）</p><p>tv_num.setText(num + "");</p><p>}</p><p>// 两卡片相同的比较方法</p><p>public boolean equals(CardView card) {</p><p>return getNum() == card.getNum();</p><p>}</p><p>}</p><h1>五.动态分配方块的宽高以及添加方块</h1><p><strong>1.动态分配方块的宽高</strong></p><p>写到这里，就有一个梗了，还是Android的老毛病，屏幕的适配问题，所以我们队卡牌的宽高是不能做限定的，也就是说我们要去根据手机屏幕动态分配卡片的width和height，在这里我们就得用到我之前一篇博客</p><p>[Android绘图机制（一）——自定义View的基础属性和方法](http://blog.csdn.net/qq_26787115/article/details/50457413)</p><p>中提到的一个方法了</p><p>@Override</p><p>protected void onSizeChanged(int w, int h, int oldw, int oldh) {</p><p>// TODO Auto-generated method stub</p><p>super.onSizeChanged(w, h, oldw, oldh);</p><p>他负责我们的View在父容器的位置，所以我们动态分配高宽也是在他这里面完成，首先，位置发生改变之后，我们得到的位置是一个确定数，但是为了防止用户是横放这手机，这就蛋疼了，所以我们得进行一个设置了</p><p>我们打开AndroidManifest.xml的activity标签中加入</p><p>//禁止屏幕横屏</p><p>android:screenOrientation="portrait"</p><p>好的，现在可以计算了</p><p>宽高求最小值 因为考虑到，我们的方阵他是正方形的，而手机屏幕是长方形的，这样，我们的正方形要设置变长就得求长方形的宽，也就是最小值了</p><p>并且我们也不需要他填满宽度，我们需要一点空隙，所以我们减去10个像素</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cccc9f254a924cbc82a8489bc774a03b><p class=pgc-img-caption></p></div><p>再让他除以4，通过这种方式，我们就可以动态平分这个宽度了</p><p>int cardWidth = (Math.min(w, h)-10)/4;</p><p><strong>2.添加方块</strong></p><p><strong>-1.添加卡片</strong></p><p>// 添加卡片,参数为卡片的宽高，因为他是正方形，所以宽高都是cardWidth</p><p>private void addCard(int cardWidth, int cardHeight) {</p><p>// 创建方块</p><p>CardView c;</p><p>// 循环添加</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>c = new CardView(getContext());</p><p>// num为随机数</p><p>c.setNum(2);</p><p>addView(c, cardWidth, cardHeight);</p><p>}</p><p>}</p><p>}</p><p>好的，我们来运行一下（换个AS2.0的模拟器感觉萌萌哒）</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/401f0face39842f9b42ebeb17850dcb2><p class=pgc-img-caption></p></div><p><strong>-2.方块换行</strong></p><p>你会发现，并没有4*4，而且一排没有换行，我们回到GameView的initView()方法中添加</p><p>//换行</p><p>setColumnCount(4);</p><p>现在再看看</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63575f2ed5e0426bac816d44bbb416b8><p class=pgc-img-caption></p></div><p><strong>-3.文字居中</strong></p><p>现在我们调整一下，让文字居中，在CardView中</p><p>//文字居中</p><p>tv_num.setGravity(Gravity.CENTER);</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e45998b1be0f4214be3a6223ec69f579><p class=pgc-img-caption></p></div><p>现在是不是好看多了</p><p><strong>-4.方块颜色</strong></p><p>```</p><p>//设置文字背景(暗卡其色)</p><p>tv_num.setBackgroundColor(0xffBDB76A);</p><p>```</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d1d0ebd95c3e4ef2953371a45ff2159f><p class=pgc-img-caption></p></div><p><strong>-5.方块间距</strong></p><p>既然是方块间隔，我们还是回到CardView里面，还记得我们设置的LayoutParams吗？你可能想到了吧，我们用Margins</p><p>//设置间距</p><p>lp.setMargins(10, 10, 0, 0);</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d31f5b596b2b4f11970c371f61523d6d><p class=pgc-img-caption></p></div><p><strong>-6.记忆方块</strong></p><p>我们所操作之后，会有新生成的卡片，为了不重合，我们得做一个记忆功能</p><p>// 记录卡片的二维数组</p><p>private CardView[][] cards = new CardView[4][4];</p><p>然后在addCard()方法中</p><p>//记忆</p><p>cards[j][i] = c;</p><h1>六.随机数</h1><p>我们先来思考一下这个随机数的逻辑，我们玩2048的时候，是不是开始新游戏的时候会随机出现两个方块，而这两个方块，他是随机出现在4*4的任意位置的，所以，我们确定下来，一开始是两个方块的随机出现，再接下来，我们会发现，他有时候是两个2，但是有时候是一个2，一个4，这个4出现的机率有点小，而且我们作为游戏规则制定者，这个也是我们控制的，这里，我不想他出现的很容易，所以我这里的逻辑就设置成1-9，这样4出现的概率会小很多，好了，基本确定了，我们就开始写代码了，我们写一个方法，在此之前，我们要对之前的代码进行调整一下，在CardView中setNum方法中，我们默认为0就占一格，</p><p>// 要呈现出来的文字（这里要注意是String类型的）</p><p>if (num &lt;= 0) {</p><p>tv_num.setText("");</p><p>} else {</p><p>tv_num.setText(num + "");</p><p>}</p><p>然后把刚才的文字设置换成0</p><p>// c.setNum(2);</p><p>c.setNum(0);</p><p>然后我们就可以添加随机数了，我们新建一个方法addRandom();</p><p>// 随机数</p><p>private void addRandom() {</p><p>// 我们新建一个lsit存放空的方块，操作之前清空</p><p>point.clear();</p><p>// 对所有的位置进行遍历</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>// 空方块才可以添加数字，有值我们就不添加</p><p>if (cards[j][i].getNum() &lt;= 0) {</p><p>point.add(new Point(j, i));</p><p>}</p><p>}</p><p>}</p><p>// for循环走完之后我们要取方块</p><p>Point p = point.remove((int) (Math.random() * point.size()));</p><p>// 我们用Math.random()返回一个0-1的数，当大于0.1的时候是2否则就是4，也就是4出现的概率为十分之一</p><p>cards[p.x][p.y].setNum(Math.random() > 0.1 ? 2 : 4);</p><p>}</p><p>这个时候我们就可以开始游戏了，为了方便等下我们需要重新开始游戏，我们就新建一个startGame()方法，让他在onSizeChanged()调用</p><p>// 开启游戏</p><p>private void startGame() {</p><p>// 既然是开始游戏，我们就要对所有的值进行清理</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>cards[j][i].setNum(0);</p><p>}</p><p>}</p><p>// 重新添加随机数</p><p>addRandom();</p><p>// 我们要添加两个</p><p>addRandom();</p><p>}</p><p>好的，我们现在运行一下啊</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/146872a8714144f196b4043e0c0dc467><p class=pgc-img-caption></p></div><p>这正是我们要的效果，每次进入游戏随机生成两个方块，他会出现在不同的位置，而且会出现2和4，4的概率小很多</p><p><strong>七.实现方块滑动，递加逻辑</strong></p><p>好的，终于到了核心的东西了，这次我们就要用到之前所写的上下左右方向方法了</p><p>// 左</p><p>private void isLeft() {</p><p>/**</p><p>* 这里的逻辑有三种情况 1.左边为空，直接左滑到最后一格 2.左边碰到的第一个数是相等的，就相加 3.左边碰到的第一个数是不相等的，靠在旁边</p><p>*/</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>// 往左滑是一行一行去遍历的</p><p>for (int j2 = j + 1; j2 &lt; 4; j2++) {</p><p>// 如果说遍历到值</p><p>if (cards[j2][i].getNum() > 0) {</p><p>// 如果当前位置上为0,就放在这个位置上去</p><p>if (cards[j][i].getNum() &lt;= 0) {</p><p>cards[j][i].setNum(cards[j2][i].getNum());</p><p>// 把原来位置上的数字清除</p><p>cards[j2][i].setNum(0);</p><p>// 让图形继续遍历</p><p>j--;</p><p>// 有值，并且还相同</p><p>} else if (cards[j][i].equals(cards[j2][i])) {</p><p>// 合并,这里做了一个很巧妙的写法，我们相加，其实2048方块上的数字都是双倍的，所以我们只要原数据*2就可以了</p><p>cards[j][i].setNum(cards[j][i].getNum() * 2);</p><p>// 把原来位置上的数字清除</p><p>cards[j2][i].setNum(0);</p><p>}</p><p>break;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>// 右</p><p>private void isRight() {</p><p>/**</p><p>* 这里的逻辑有三种情况 1.左边为空，直接左滑到最后一格 2.左边碰到的第一个数是相等的，就相加 3.左边碰到的第一个数是不相等的，靠在旁边</p><p>*/</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>for (int j = 3; j >= 0; j--) {</p><p>// 往左滑是一行一行去遍历的</p><p>for (int j2 = j - 1; j2 >= 0; j2--) {</p><p>// 如果说遍历到值</p><p>if (cards[j2][i].getNum() > 0) {</p><p>// 如果当前位置上为0,就放在这个位置上去</p><p>if (cards[j][i].getNum() &lt;= 0) {</p><p>cards[j][i].setNum(cards[j2][i].getNum());</p><p>// 把原来位置上的数字清除</p><p>cards[j2][i].setNum(0);</p><p>// 让图形继续遍历</p><p>j++;</p><p>// 有值，并且还相同</p><p>} else if (cards[j][i].equals(cards[j2][i])) {</p><p>// 合并,这里做了一个很巧妙的写法，我们相加，其实2048方块上的数字都是双倍的，所以我们只要原数据*2就可以了</p><p>cards[j][i].setNum(cards[j][i].getNum() * 2);</p><p>// 把原来位置上的数字清除</p><p>cards[j2][i].setNum(0);</p><p>}</p><p>break;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>// 上</p><p>private void isTop() {</p><p>/**</p><p>* 这里的逻辑有三种情况 1.左边为空，直接左滑到最后一格 2.左边碰到的第一个数是相等的，就相加 3.左边碰到的第一个数是不相等的，靠在旁边</p><p>*/</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>// 往左滑是一行一行去遍历的</p><p>for (int i2 = i + 1; i2 &lt; 4; i2++) {</p><p>// 如果说遍历到值</p><p>if (cards[j][i2].getNum() > 0) {</p><p>// 如果当前位置上为0,就放在这个位置上去</p><p>if (cards[j][i].getNum() &lt;= 0) {</p><p>cards[j][i].setNum(cards[j][i2].getNum());</p><p>// 把原来位置上的数字清除</p><p>cards[j][i2].setNum(0);</p><p>// 让图形继续遍历</p><p>i--;</p><p>// 有值，并且还相同</p><p>} else if (cards[j][i].equals(cards[j][i2])) {</p><p>// 合并,这里做了一个很巧妙的写法，我们相加，其实2048方块上的数字都是双倍的，所以我们只要原数据*2就可以了</p><p>cards[j][i].setNum(cards[j][i].getNum() * 2);</p><p>// 把原来位置上的数字清除</p><p>cards[j][i2].setNum(0);</p><p>}</p><p>break;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>// 下</p><p>private void isButtom() {</p><p>/**</p><p>* 这里的逻辑有三种情况 1.左边为空，直接左滑到最后一格 2.左边碰到的第一个数是相等的，就相加 3.左边碰到的第一个数是不相等的，靠在旁边</p><p>*/</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>for (int i = 3; i >= 0; i--) {</p><p>// 往左滑是一行一行去遍历的</p><p>for (int i2 = i - 1; i2 >= 0; i2--) {</p><p>// 如果说遍历到值</p><p>if (cards[j][i2].getNum() > 0) {</p><p>// 如果当前位置上为0,就放在这个位置上去</p><p>if (cards[j][i].getNum() &lt;= 0) {</p><p>cards[j][i].setNum(cards[j][i2].getNum());</p><p>// 把原来位置上的数字清除</p><p>cards[j][i2].setNum(0);</p><p>// 让图形继续遍历</p><p>i++;</p><p>// 有值，并且还相同</p><p>} else if (cards[j][i].equals(cards[j][i2])) {</p><p>// 合并,这里做了一个很巧妙的写法，我们相加，其实2048方块上的数字都是双倍的，所以我们只要原数据*2就可以了</p><p>cards[j][i].setNum(cards[j][i].getNum() * 2);</p><p>// 把原来位置上的数字清除</p><p>cards[j][i2].setNum(0);</p><p>}</p><p>break;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>四个方法的逻辑都是大同小异的，不过逻辑性还是很强的，大家可以适当的去研究一下然后我们多增加几个方块先来模拟下效果</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c86504398c3f47ed921092b6101f75d6><p class=pgc-img-caption></p></div><h1>八.计分</h1><p>方块的逻辑差不多写完了，我们先来就在MainActivity里面来实现我们的Score计分</p><p><strong>MainActivity</strong></p><p>package com.lgl.game2048;</p><p>import android.app.Activity;</p><p>import android.os.Bundle;</p><p>import android.widget.TextView;</p><p>public class MainActivity extends Activity {</p><p>private TextView tv_score;</p><p>//外界可以访问的实例</p><p>private static MainActivity mainActivity = null;</p><p>//积分器</p><p>private int score = 0;</p><p>public MainActivity() {</p><p>mainActivity = this;</p><p>}</p><p>@Override</p><p>protected void onCreate(Bundle savedInstanceState) {</p><p>super.onCreate(savedInstanceState);</p><p>setContentView(R.layout.activity_main);</p><p>tv_score = (TextView) findViewById(R.id.tv_score);</p><p>}</p><p>public static MainActivity getMainActivity() {</p><p>return mainActivity;</p><p>}</p><p>public static void setMainActivity(MainActivity mainActivity) {</p><p>MainActivity.mainActivity = mainActivity;</p><p>}</p><p>//清除分数</p><p>public void clearScore(){</p><p>score = 0;</p><p>showScore();</p><p>}</p><p>//分数</p><p>public void showScore(){</p><p>tv_score.setText("分数:"+score);</p><p>}</p><p>public void addScore(int s){</p><p>score += s;</p><p>showScore();</p><p>}</p><p>}</p><p>这是我们计分的过程，我们思考一下在什么时候计分呢？想想就知道在滑动的时候俩值相加的时候开始计分，所以我们在四个滑动方法有值的判断句中添加</p><p>//开始计分</p><p>MainActivity.getMainActivity().addScore(cards[j][i].getNum());</p><p>同时，我们在开始游戏的时候要清零，所以我们在startGame方法中要添加</p><p>//计分清零</p><p>MainActivity.getMainActivity().clearScore();</p><h1>九.滑动后增加方块</h1><p>我们默认进来是两个方块，但是滑动之后我们应该也要随机增加方块才能达到游戏的逻辑，你说是吧！</p><p>所以，只要你滑动了，我们就要添加，一直到gameover结束为止，那我们依然在那四个方向方法里写</p><p>private void isxx(){</p><p>// 加个判断是否可以添加</p><p>boolean isAdd = false;</p><p>for(....){</p><p>for(....){</p><p>for(....){</p><p>if(....){</p><p>if(....){</p><p>....</p><p>// 可以添加</p><p>isAdd = true;</p><p>}else if(....){</p><p>....</p><p>// 可以添加</p><p>isAdd = true;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>// 开始进行判断</p><p>if (isAdd) {</p><p>// 如果可以合并，我们添加随机数</p><p>addRandom();</p><p>}</p><p>}</p><p>好的，我们现在来运行一下</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46e1d767a3cd48ec8e58c93ee01ecb82><p class=pgc-img-caption></p></div><p>游戏现在大体上是OK的了</p><h1>十.游戏结束</h1><p>游戏有始有终，我们现在就来判断游戏结束，游戏结束有两个前提</p><p>1.16个格子都是满的</p><p>2.上下左右相邻的格子都不相同</p><p>这样的话我们就可以写一个endGame方法，然后让他在每次增加方块的时候调用了</p><p>// 游戏结束</p><p>private void endGame() {</p><p>// 在每次添加新的方块的时候判断一下</p><p>// 是否结束？</p><p>boolean isEnd = true;</p><p>ALL: // 标签，让break跳出整个循环</p><p>for (int i = 0; i &lt; 4; i++) {</p><p>for (int j = 0; j &lt; 4; j++) {</p><p>// 等于0的话游戏没有结束,或者上下左右还是有相同的数</p><p>if (cards[j][i].getNum() == 0</p><p>// 左</p><p>|| (j > 0 && cards[j][i].equals(cards[j - 1][i]))</p><p>// 右</p><p>|| (j &lt; 3) && cards[j][i].equals(cards[j + 1][i])</p><p>// 上</p><p>|| (i > 0 && cards[j][i].equals(cards[j][i - 1]))</p><p>// 下</p><p>|| (i &lt; 3 && cards[j][i].equals(cards[j][i + 1]))) {</p><p>// 说明游戏没有结束</p><p>isEnd = false;</p><p>break ALL;</p><p>}</p><p>}</p><p>}</p><p>if (isEnd) {</p><p>// 当isEnd = true的时候游戏结束</p><p>new AlertDialog.Builder(getContext())</p><p>.setTitle("Sorry，游戏结束！")</p><p>.setMessage("是否重新开始？")</p><p>.setPositiveButton("是",</p><p>new DialogInterface.OnClickListener() {</p><p>@Override</p><p>public void onClick(DialogInterface dialog,</p><p>int which) {</p><p>// 重新开始</p><p>startGame();</p><p>}</p><p>})</p><p>.setNegativeButton("否",</p><p>new DialogInterface.OnClickListener() {</p><p>@Override</p><p>public void onClick(DialogInterface dialog,</p><p>int which) {</p><p>}</p><p>}).show();</p><p>}</p><p>}</p><p>好的，现在我们可以来检测一下了</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a42d79b6117a4428839779f8299de35a><p class=pgc-img-caption></p></div><h1>十一.优化之色块</h1><p>我们的数字每个数字代表一种颜色，这里我就简单的写点颜色，你们要是喜欢可以自己想改什么就改什么</p><p>在CardView中setnum方法里</p><p>switch (num) {</p><p>case 0:</p><p>tv_num.setBackgroundColor(0xffBDB76A);</p><p>break;</p><p>case 2:</p><p>tv_num.setBackgroundColor(0xffeee4da);</p><p>break;</p><p>case 4:</p><p>tv_num.setBackgroundColor(0xffede0c8);</p><p>break;</p><p>case 8:</p><p>tv_num.setBackgroundColor(0xfff2b179);</p><p>break;</p><p>case 16:</p><p>tv_num.setBackgroundColor(0xfff59563);</p><p>break;</p><p>case 32:</p><p>tv_num.setBackgroundColor(0xfff67c5f);</p><p>break;</p><p>case 64:</p><p>tv_num.setBackgroundColor(0xfff65e3b);</p><p>break;</p><p>case 128:</p><p>tv_num.setBackgroundColor(0xffedcf72);</p><p>break;</p><p>case 256:</p><p>tv_num.setBackgroundColor(0xffedcc61);</p><p>break;</p><p>case 512:</p><p>tv_num.setBackgroundColor(0xffedc850);</p><p>break;</p><p>case 1024:</p><p>tv_num.setBackgroundColor(0xffedc53f);</p><p>break;</p><p>case 2048:</p><p>tv_num.setBackgroundColor(0xffedc22e);</p><p>break;</p><p>default:</p><p>tv_num.setBackgroundColor(0xff3c3a32);</p><p>break;</p><p>}</p><p>我们运行下</p><div class=pgc-img><img alt=Android游戏2048方块的设计实现，编写，加上色彩，分数等功能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4229ae6fbd354505ae64166f52b6cedd><p class=pgc-img-caption></p></div><p>Demo下载地址：http://download.csdn.net/detail/qq_26787115/9409068</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Android','游戏','2048'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>