<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件 | 极客快訊</title><meta property="og:title" content="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/18f1b156dc784f34a3ae9edea43e9a78"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5e149ba4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5e149ba4.html><meta property="article:published_time" content="2020-10-29T21:08:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:52+08:00"><meta name=Keywords content><meta name=description content="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5e149ba4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最近开始学习网络安全和系统安全，接触到了很多新术语、新方法和新工具，作为一名初学者，感觉安全领域涉及的知识好广、好杂，但同时也非常有意思。这系列文章是作者学习安全过程中的总结和探索，我们一起去</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">躺</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">过那些坑、跨过那些洞、守住那些站，真心希望文章对您有所帮助，感谢您的阅读和关注。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Python黑帽第一篇文章将分享获取Windows主机信息，利用注册表获取主机名及USB历史痕迹、回收站文件等，这些知识广泛应用于电子取证、Web渗透和攻击溯源领域，其中USB获取是亮点。希望这篇基础文章对您有所帮助，更希望大家提高安全意识，学会相关防范，也欢迎大家讨论。娜璋AI安全之家于2020年8月18日开通，将专注于Python和安全技术，主要分享Web渗透、系统安全、CVE复现、威胁情报分析、人工智能、大数据分析、恶意代码检测等文章。真心想把自己近十年的所学所做所感分享出来，与大家一起进步。</span></p><p><br></p><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">声明：本人坚决反对利用教学方法进行恶意攻击的行为，一切错误的行为必将受到严惩，绿色网络需要我们共同维护，更推荐大家了解技术背后的原理，更好地进行安全防护。虽然作者是一名安全小白，但会保证每一篇文章都会很用心地撰写，希望这些基础性文章对你有所帮助，在安全路上一起前行。</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">一.获取Windows主机信息</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">WMI(Windows Management Instrumentation) 是一项核心的Windows管理技术，WMI模块可用于获取Windows内部信息。WMI作为一种规范和基础结构，通过它可以访问、配置、管理和监视几乎所有的Windows资源，比如用户可以在远程计算机器上启动一个进程；设定一个在特定日期和时间运行的进程；远程启动计算机；获得本地或远程计算机的已安装程序列表；查询本地或远程计算机的Windows事件日志等等。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">本文使用Python获取Windows系统上相关的信息可以使用WMI接口，安装调用PIP工具即可。</span></p><ul><li>pip install wmi</li><li>import wmi</li></ul><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18f1b156dc784f34a3ae9edea43e9a78><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">下面的代码是获取Windows主机相关信息。</span></p><pre><code>import wmiimport osimport socketw = wmi.WMI()#获取电脑使用者信息for CS in w.Win32_ComputerSystem():    #print(CS)    print("电脑名称: %s" %CS.Caption)    print("使用者: %s" %CS.UserName)    print("制造商: %s" %CS.Manufacturer)    print("系统信息: %s" %CS.SystemFamily)    print("工作组: %s" %CS.Workgroup)    print("机器型号: %s" %CS.model)    print("")#获取操作系统信息for OS in w.Win32_OperatingSystem():    #print(OS)    print("操作系统: %s" %OS.Caption)    print("语言版本: %s" %OS.MUILanguages)    print("系统位数: %s" %OS.OSArchitecture)    print("注册人: %s" %OS.RegisteredUser)    print("系统驱动: %s" %OS.SystemDevice)    print("系统目录: %s" %OS.SystemDirectory)    print("")#获取电脑IP和MAC信息for address in w.Win32_NetworkAdapterConfiguration(ServiceName = "e1dexpress"):    #print(address)    print("IP地址: %s" % address.IPAddress)    print("MAC地址: %s" % address.MACAddress)    print("网络描述: %s" % address.Description)    print("")#获取电脑CPU信息for processor in w.Win32_Processor():    #print(processor)    print("CPU型号: %s" % processor.Name.strip())    print("CPU核数: %s" % processor.NumberOfCores)    print("")#获取BIOS信息for BIOS in w.Win32_BIOS():    #print(BIOS)    print("使用日期: %s" %BIOS.Description)    print("主板型号: %s" %BIOS.SerialNumber)    print("当前语言: %s" %BIOS.CurrentLanguage)    print("")#获取内存信息for memModule in w.Win32_PhysicalMemory():    totalMemSize = int(memModule.Capacity)    print("内存厂商: %s" %memModule.Manufacturer)    print("内存型号: %s" %memModule.PartNumber)    print("内存大小: %.2fGB" %(totalMemSize/1024**3))    print("")#获取磁盘信息for disk in w.Win32_DiskDrive():    diskSize = int(disk.size)    print("磁盘名称: %s" %disk.Caption)    print("硬盘型号: %s" %disk.Model)    print("磁盘大小: %.2fGB" %(diskSize/1024**3))#获取显卡信息for xk in w.Win32_VideoController():    print("显卡名称: %s" %xk.name)    print("")       #获取计算机名称和IPhostname = socket.gethostname()ip = socket.gethostbyname(hostname)print("计算机名称: %s" %hostname)print("IP地址: %s" %ip)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输出结果如下图所示：</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a38bf7d7e6241298d88d1a6f1966bce><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8bf7c2306c4149f0813362aecbd1e6a7><p class=pgc-img-caption></p></div><p><br></p><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">二.获取Windows注册表信息</span></h1><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1.注册表基本结构</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注册表（Registry）是Windows系统中一个重要的数据库，它用于存储有关应用程序、用户和系统信息。注册表的结构就像</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一颗树</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，树的顶级节点(hive)不能添加、修改和删除，如下图所示是Windows注册表的顶级节点。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a2b3054b9d4c4ab7beaedf509a680ab2><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在C#中对注册表进行操作，需要引用命名空间using Microsoft.Win32。</span></p><ul><li><strong>RegistryKey类</strong>：表示注册表中的顶级结点，此类是注册表的封装。</li><li><strong>Registry类</strong>：提供表示Windows注册表中的根项RegistryKey对象，并提供访问项/值的static方法。常用的Registry对象的顶级节点（蜂窝,hive）的属性如下表所示：</li></ul><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b59c6ae501214fa8a820992e532f37da><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注册表中常用的数据类型有：</span></p><ul><li><strong>REG_SZ</strong>：字符串数据的主要类型，用于存储固定长度的字符串或其他短文本值。我们在实际程序中常用这种数据类型，如果要保存布尔值时，将它表示成0或1。</li><li><strong>REG_BINARY</strong>：用于存储二进制数据。</li><li><strong>REG_EXPAND_SZ</strong>：可扩展的字符串值，可以保存在运行时才解析的系统变量。</li><li><strong>REG_MULTI_SZ</strong>：以数组的格式保存多个文本字符串，每个字符串"元素"都以null字符结束。</li></ul><p><br></p><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.注册表基本操作</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Python注册表操作主要调用winreg扩展包。官方文档如下：</span></p><ul><li>https://docs.python.org/3.0/library/winreg.html</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">基本操作函数如下：</span></p><p style=text-align:start><strong><span style="background-color:#f8f840;--tt-darkmode-bgcolor: #D0D036">(1) 创建操作</span></strong></p><ul><li><strong>winreg.ConnectRegistry(computer_name, key)</strong><br>与计算机的预定义注册表句柄建立连接</li><li><strong>winreg.CreateKey(key, sub_key)</strong><br>创建或打开指定的键</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">例如在HKEY_CURRENT_USER下创建键Eastmount，其中我们最常用的是在\Software这个键下创建程序产品键，保存一些程序的配置在注册表中。如果Software中没有Eastmount键，则会先创建这个键及其子键，如果存在就不会重写。</span></p><pre><code>import winreg as wg#创建键subDir = r"Software\Microsoft\Windows\CurrentVersion\Explorer"key_test = wg.OpenKey(wg.HKEY_CURRENT_USER, subDir)wg.CreateKey(key_test, 'Eastmount')wg.CloseKey(key_test)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">运行结果如下:</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9d7dc51ef134f9f8071fc8dbeeff79f><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><strong><span style="background-color:#f8f840;--tt-darkmode-bgcolor: #D0D036">(2) 检索键值操作</span></strong></p><ul><li><strong>winreg.QueryInfoKey(key)</strong><br>以元组形式返回键的信息</li><li><strong>winreg.QueryValue(key, sub_key)</strong><br>以字符串形式检索键的未命名值</li><li><strong>winreg.QueryValueEx(key, value_name)</strong><br>检索与打开注册表项关联的指定值名称的类型和数据</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在Eastmount下面新建一个值yxz，内容为“hello na”，然后编写代码读取相关的内容。</span></p><pre><code>#获取键值数据项值subDir = r"Software\Microsoft\Windows\CurrentVersion\Explorer\Eastmount"key_test = wg.OpenKey(wg.HKEY_CURRENT_USER, subDir)value,type_ = wg.QueryValueEx(key_test,'yxz')print(value)print(type_)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输出结果如下图所示：</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fdbe11f8733a4a02a53ebadd248b5079><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a6e524d77c6c4805b568bbc234feea4a><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><strong><span style="background-color:#f8f840;--tt-darkmode-bgcolor: #D0D036">(3) 创建键值操作</span></strong></p><ul><li><strong>winreg.SetValue(key, sub_key, type, value)</strong><br>将值与指定的键关联</li><li><strong>winreg.SetValueEx(key, value_name, reserved, type, value)</strong><br>将数据存储在打开的注册表项Value字段中</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">创建键值代码如下，但会提示PermissionError: [WinError 5] 拒绝访问错误。</span></p><pre><code>#创建键值数据项subDir = r"Software\Microsoft\Windows\CurrentVersion\Explorer\Eastmount"key_test = wg.OpenKey(wg.HKEY_CURRENT_USER, subDir)print(key_test)#PermissionError: [WinError 5] 拒绝访问wg.SetValueEx(key_test,'data','',wg.REG_SZ,'0') wg.CloseKey(key_test)</code></pre><p><strong><span style="background-color:#f8f840;--tt-darkmode-bgcolor: #D0D036">(4) 删除键值操作</span></strong></p><ul><li><strong>winreg.DeleteKey(key, sub_key)</strong><br>删除指定的键</li><li><strong>winreg.DeleteValue(key, value)</strong><br>从注册表项中删除值</li></ul><pre><code>#删除键值数据项subDir = r"Software\Microsoft\Windows\CurrentVersion\Explorer\Eastmount"key_test = wg.OpenKey(wg.HKEY_CURRENT_USER,subDir,0,wg.KEY_WRITE)wg.DeleteValue(key_test,'yxz')wg.CloseKey(key_test)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">成功删除键值，如下图所示。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9f22c4f8bf9a4d4199bc0dcc852d5308><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><strong><span style="background-color:#f8f840;--tt-darkmode-bgcolor: #D0D036">(5) 其他操作</span></strong></p><ul><li><strong>winreg.EnumKey(key, index)</strong><br>枚举打开注册表的键</li><li><strong>winreg.EnumValue(key, index)</strong><br>枚举打开注册表项的值</li><li><strong>winreg.OpenKey(key, sub_key,sam=KEY_READ)</strong><br>打开指定键</li><li><strong>winreg.FlushKey(key)</strong><br>刷新注册表</li><li><strong>winreg.LoadKey(key, sub_key, file_name)</strong><br>在指定键下创建一个子键，并将注册信息从指定文件存储到该子键中</li></ul><p><br></p><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.获取用户账户信息</span></h1><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8db6d9d1d44146cdaf5df879ccd7ef25><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">获取用户名称的代码如下：</span></p><pre><code># encoding:utf-8from winreg import *import sys#连接注册表根键 以HKEY_LOCAL_MACHINE为例regRoot = ConnectRegistry(None, HKEY_LOCAL_MACHINE)subDir = r'SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList'#获取指定目录下所有键的控制keyHandle = OpenKey(regRoot, subDir)#获取该目录下所有键的个数(0-下属键个数 1-当前键值个数)count = QueryInfoKey(keyHandle)[0]for i in range(count):    #穷举键获取键名    subKeyName = EnumKey(keyHandle, i)    subDir_2 = r'%s\%s' % (subDir, subKeyName)        #根据获取的键名拼接之前的路径作为参数 获取当前键下所属键的控制    keyHandle_2 = OpenKey(regRoot, subDir_2)    num = QueryInfoKey(keyHandle_2)[1]    for j in range(num):        name, value, type_ = EnumValue(keyHandle_2, j)        if('ProfileImagePath' in name and 'Users' in value):            print(value)    #读写操作结束后关闭键    CloseKey(keyHandle_2)    CloseKey(keyHandle)CloseKey(regRoot)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">执行结果如下，我们可以通过读取含有Users字段的数据，从而间接获取用户账户信息。</span></p><pre><code>C:\Usersiuzhang</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">三.获取回收站内容</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">为什么我们要去获取回收站文件呢？因为很多情况下调查取证需要获取远程目标的历史痕迹，回收站是重要的一个目标。在Windows操作系统中，回收站是一个专门用来存放被删除文件的特色文件夹。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在使用FAT文件系统的Windows98系统中，回收站目录通常是C:\Recycled；在Windows NT2000、Windows XP在内支持的NTFS操作系统中，C:\Recycler；在Windows Vista和Windows7中，回收站目录是C:\$Recycle.Bin。如下图所示，回收站中包含两个文件，分别位于桌面和D盘目录。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a204919dd7f429e8103fd91afe14e72><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第一步，检测回收站目录是否存在。</span></strong></p><pre><code>import osdef returnDir():    #定义回收站目录    dirs = ['C:\\Recycler\\', 'C:\\Recycled', 'C:\\$Recycle.Bin\\']    for recycleDir in dirs:        if os.path.isdir(recycleDir):            return recycleDir    return None#调用函数res = returnDir()print(res) #C:\$Recycle.Bin\</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Windows10操作系统输出结果如下图所示：</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e933ca76d25d4a258c09429ceb05d015><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第二步，找到回收站之后，检测其中的内容，如下图所示，字符串SID与用户账户名是对应的，比如1001结尾的SID。</span></strong></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3eb7d83ee654425385a60845bbfc6bbe><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第三步，编写代码获取回收站文件夹所在目录。</span></strong></p><pre><code>import os#判断回收站目录是否存在def returnDir():    dirs = ['C:\\Recycler\\', 'C:\\Recycled', 'C:\\$Recycle.Bin\\']    for recycleDir in dirs:        if os.path.isdir(recycleDir):            return recycleDir    return None#获取回收站内容def findRecycle(recycleDir):    dirList = os.listdir(recycleDir)    for sid in dirList:        print(sid)        files = os.listdir(recycleDir+sid)        print(files,"\n")#主函数def main():    res = returnDir()    print(res) #C:\$Recycle.Bin\    findRecycle(res)    if __name__ == '__main__':    main()</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输出结果如下图所示：</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0355fc475844f82ad65a5c6bb15df51><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第四步，用python将用户的SID关联起来，使用Windows注册表将SID转化为一个准确的用户名。</span></strong></p><ul><li>通过检查Windows注册表键值</li><li>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\ProfileImagePath</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">编写一个函数来将每一个SID转化为用户名，这个函数将打开注册便检查ProfileImagePath键值，找到其值并从中找到用户名。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/78a170592fae4b97ba75eb1049db29bc><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如下图所示，用户名为“xiuzhang”。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/54075b5c16a44ca6bab4a83a96adbd14><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第五步，获取回收站所有内容。</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br></span><span style="background-color:#f8f840;--tt-darkmode-bgcolor: #D0D036">完整代码：</span></p><pre><code>import osimport winreg#判断回收站目录是否存在def returnDir():    dirs = ['C:\\Recycler\\', 'C:\\Recycled', 'C:\\$Recycle.Bin\\']    for recycleDir in dirs:        if os.path.isdir(recycleDir):            return recycleDir    return None#通过sid获取用户名信息def sid2user(sid):    try:        key = winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE,                                "SOFTWARE\Microsoft\Windows NT\CurrentVersion\ProfileList\\" + sid)        #获取该目录下所有键的个数: 0-下属键个数; 1-当前键值个数        count = winreg.QueryInfoKey(key)[1]         for j in range(count):            #FileNotFoundError: [WinError 2] 系统找不到指定的文件            #(value, type) = winreg.QueryValue(key, 'ProfileImagePath')            name, value, type = winreg.EnumValue(key, j)            if('ProfileImagePath' in name):                user = value.split('\\')[-1]                #print(user)        return user    except:        return sid#获取回收站内容def findRecycle(recycleDir):    dirList = os.listdir(recycleDir)    for sid in dirList:        print(sid)        files = os.listdir(recycleDir+sid)        print(files)        user = sid2user(sid)        print('[*]Listing Files For User:' + str(user))        for file in files:            print('[+]Found File:' + str(file))        print("")#主函数def main():    res = returnDir()    print(res)             #C:\$Recycle.Bin    findRecycle(res)    if __name__ == '__main__':    main()</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输出结果如下图所示：</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7ef6b58186249c5986c81f00466a8ed><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">对应的回收站内容如下，但非常可惜获取的值无法对应，why？后续作者会继续深入挖掘。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cec8026cc16d479ea2dd686cd3f0a172><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br></span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c2899141e4404d2599745ce15ba387b8><p class=pgc-img-caption></p></div><p><br></p><hr><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果我们想把文件删除到回收站，又怎么解决呢？Python删除文件一般使用os.remove，但这样是直接删除文件，不删到回收站的，那么想删除文件到回收站怎么办？</span></strong></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">(1) 安装pypiwin32扩展包（含win32api）。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/49332704024948ef96cc03ccdea62e00><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">(2) 调用SHFileOperation函数实现删除文件至回收站。</span></p><blockquote><p><span style="color:#555666;--tt-darkmode-color: #555666"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">在Windows的shellapi文件中定义了一个名为SHFileOperation的外壳函数，用它可以实现各种文件操作，如文件的拷贝、删除、移动等，该函数使用起来非常简单，它只有一个指向SHFILEOPSTRUCT结构的参数。</span></span></p></blockquote><pre><code>from win32com.shell import shell,shellconimport osdebug = Falsedef deltoreCyclebin(filename):    #直接删除文件，不经过回收站    #os.remove(filename)     if not debug:        #删除文件到回收站        res = shell.SHFileOperation((0,                                     shellcon.FO_DELETE,                                     filename,                                     None,                                     shellcon.FOF_SILENT | shellcon.FOF_ALLOWUNDO | shellcon.FOF_NOCONFIRMATION,                                     None,                                     None))        print(res)        if not res[1]:            os.system('del '+ filename)if __name__ == '__main__':    filename = "C:\\Users\iuzhang\\Desktop\\require.rb"    deltoreCyclebin(filename)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最终效果如下图所示，可以看到require.rb文件被成功删除。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aacd301cc20144af800b149a62325c79><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">可能会遇到“PermissionError: [WinError 5] 拒绝访问”问题，我们需要设置Python.exe用户名完全控制，并且用管理员方式打开即可解决。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f0a761d2c72e48678f4814643c69ded3><p class=pgc-img-caption></p></div><p><br></p><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">四.获取U盘痕迹</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在Windows系统中，当一个USB移动存储设备插入时，就会在注册表中留下痕迹。当移动设备插入计算机时，即插即用管理器PnP(Plug and Play)接受该事件，并且在USB设备的固件(Firewre information)中查询有关该设备的描述信息(厂商、型号、序列号等)。当设备被识别后，在注册表中创建一个新的键值：</span></p><ul><li><strong>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\USBSTOR</strong></li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在这个键值下，会看到类似下面的结构子键，该子键代表设备类标示符，用来标识设备的一个特定类。</span></p><ul><li><strong>Disk&Ven_###&Prod_###&Rev_###</strong></li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其中，子键中"###"代表区域由PnP管理器依据在USB设备描述符中获取的数据填写。如下图所示：</span></p><ul><li><strong>Disk&Ven_aigo&Prod_Miniking&Rev_8.07是Device class ID</strong></li><li><strong>Q0UKCH37&0是Unique instance ID(UID)</strong></li></ul><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ed47bdcd6a9437bb044424afc391e54><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意需要判断Service值为disk，即为磁盘的子项，光盘为cdrom。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab9eb3ba70d347dabdb63e5f011a0248><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果使用UVCView工具可以看见USB设备描述内容，其中的信息都是相互对应的。设备类ID一旦建立，就需要建立一个特定</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">唯一</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的UID，它可以把具有同一设备类标识的多个存储设备区分。</span></p><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">完整实现代码如下：</span></strong></p><pre><code># encoding:utf-8from winreg import *import sysusb_name = []uid_flag = []usb_path = []#连接注册表根键 以HKEY_LOCAL_MACHINE为例regRoot = ConnectRegistry(None, HKEY_LOCAL_MACHINE)#检索子项subDir = r"SYSTEM\CurrentControlSet\Enum\USBSTOR"#获取指定目录下所有键的控制keyHandle = OpenKey(regRoot, subDir)#获取该目录下所有键的个数(0-下属键个数 1-当前键值个数)count = QueryInfoKey(keyHandle)[0]print(count)#穷举USBSTOR键获取键名for i in range(count):    subKeyName = EnumKey(keyHandle, i)    subDir_2 = r'%s\%s' % (subDir, subKeyName)    #print(subDir_2)    #根据获取的键名拼接之前的路径作为参数 获取当前键下所属键的控制    keyHandle_2 = OpenKey(regRoot, subDir_2)    num = QueryInfoKey(keyHandle_2)[0]    #遍历子键内容    for j in range(num):        subKeyName_2 = EnumKey(keyHandle_2, j)        #print(subKeyName_2)        result_path = r'%s\%s' % (subDir_2, subKeyName_2)        #获取具体键值内容并判断Service为disk        keyHandle_3 = OpenKey(regRoot, result_path)        numKey = QueryInfoKey(keyHandle_3)[1]        for k in range(numKey):            #获取USB名称            name, value, type_ = EnumValue(keyHandle_3, k)            if(('Service' in name) and ('disk'in value)):                value,type_ = QueryValueEx(keyHandle_3,'FriendlyName')                usb = value                uid = subKeyName_2                path = "USBSTOR" + "\\" + subKeyName + "\\" + subKeyName_2                print(usb)                print(uid)                print(path)                                print("")    #关闭键值CloseKey(keyHandle)CloseKey(regRoot)</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输出的USB记录键名如下图所示：</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eeaba84a897d4671b5877c14111da572><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其中对应的注册表信息如下图所示，FriendlyName即是输出的“USB名称 Kingston DataTraveler 2.0 USB Device”，UID序号为“C860008862F1EE501A0F0105&0”，搜索的Service(服务)为disk(磁盘)的选项。</span></p><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/807a2adeb953415cb789ae36af51f295><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">简单总结：</span></strong></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">个人感觉这方面的资料真心很少，文章博客也少，所以看起来操作似乎很简单，但真正实现起来还是令人深思的。然后就是其实存储USB记录的还有很多键值，如</span></p><ul><li><strong>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\USB</strong><br>该键值中能看到厂商号(VID_)、厂商产品号(PID_)，还有LocationInformation(端口号) Port_#0001.Hub_#0005等。</li></ul><div class=pgc-img><img alt="「Python黑帽」 获取注册表、U盘历史痕迹和回收站文件" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab2df992f7f84aeabd3a45c09e636468><p class=pgc-img-caption></p></div><ul><li><strong>HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\DeviceClasses</strong><br>该键值下有两个设备类：{53F56307-B6BF-11D0-94F2-00A0C91EFB8B}{53F5630d-B6BF-11D0-94F2-00A0C91EFB8B}，可以通过他们获取USB最后接入系统时间。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">接下来我想要完成的就是如何把这些键值联系起来，似乎要通过Dictionary&lt;string, UInfo>，同时怎样获取时间，怎样正确删除这些信息都值得深究。</span></p><p><br><strong>更多黑客教程，搭建钓鱼网站，如何反盗别人的账号 记得私信小编01获取</strong></p><hr><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">五.总结</span></h1><p style=text-align:start><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这篇文章真的花费了一些精力，希望您喜欢。同时感觉自己要学习的知识好多，也有好多大神卧虎藏龙，开源分享。作为初学者，我们可能有差距，不论你之前是什么方向，是什么工作，是什么学历，是大学大专中专，亦或是高中初中，只要你喜欢安全，喜欢渗透，就朝着这个目标去努力吧！有差距不可怕，我们需要的是去缩小差距，去战斗，况且这个学习的历程真的很美，安全真的有意思。但切勿去做坏事，我们需要的是白帽子，是维护我们的网络，安全路上共勉。</span></strong></p><p>此文转载于：Eastmount</p><p>著作权归作者所有，如有侵权联系小编删除！</p><p>原文地址：https://blog.csdn.net/Eastmount/article/details</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'回收站','Python','黑帽'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>