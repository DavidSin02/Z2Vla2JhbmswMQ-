<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SPI协议详解 | 极客快訊</title><meta property="og:title" content="SPI协议详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/30e622a233f8489798892e001006ea4a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5eef641.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5eef641.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5eef641.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5eef641.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5eef641.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5eef641.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5eef641.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5eef641.html><meta property="article:published_time" content="2020-10-29T21:05:00+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:00+08:00"><meta name=Keywords content><meta name=description content="SPI协议详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5eef641.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SPI协议详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><p>1、 SPI简介</p><p>SPI，是英语Serial Peripheral interface的缩写，顾名思义就是串行外围设备接口。是Motorola首先在其MC68HCXX系列处理器上定义的。SPI接口主要应用在 EEPROM，FLASH，实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。SPI是一种高速的，全双工，同步的通信总线，并且在芯片的管脚上只占用四根线，节约了芯片的管脚，同时为PCB的布局上节省空间，提供方便，正是出于这种简单易用的特性，现在越来越多的芯片集成了这种通信协议。</p><p>2、 SPI特点</p><p>2.1采用主-从模式(Master-Slave) 的控制方式</p><p>SPI 规定了两个 SPI 设备之间通信必须由主设备 (Master) 来控制次设备 (Slave). 一个 Master 设备可以通过提供 Clock 以及对 Slave 设备进行片选 (Slave Select) 来控制多个 Slave 设备, SPI 协议还规定 Slave 设备的 Clock 由 Master 设备通过 SCK 管脚提供给 Slave 设备, Slave 设备本身不能产生或控制 Clock, 没有 Clock 则 Slave 设备不能正常工作</p><p>2.2采用同步方式(Synchronous)传输数据</p><p>Master 设备会根据将要交换的数据来产生相应的时钟脉冲(Clock Pulse), 时钟脉冲组成了时钟信号(Clock Signal) , 时钟信号通过时钟极性 (CPOL) 和 时钟相位 (CPHA) 控制着两个 SPI 设备间何时数据交换以及何时对接收到的数据进行采样, 来保证数据在两个设备之间是同步传输的.</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/30e622a233f8489798892e001006ea4a><p class=pgc-img-caption></p></div><p>2.3数据交换(Data Exchanges)</p><p>SPI 设备间的数据传输之所以又被称为数据交换, 是因为 SPI 协议规定一个 SPI 设备不能在数据通信过程中仅仅只充当一个 "发送者(Transmitter)" 或者 "接收者(Receiver)". 在每个 Clock 周期内, SPI 设备都会发送并接收一个 bit 大小的数据(不管主设备好还是从设备), 相当于该设备有一个 bit 大小的数据被交换了. 一个 Slave 设备要想能够接收到 Master 发过来的控制信号, 必须在此之前能够被 Master 设备进行访问 (Access). 所以, Master 设备必须首先通过 SS/CS pin 对 Slave 设备进行片选, 把想要访问的 Slave 设备选上. 在数据传输的过程中, 每次接收到的数据必须在下一次数据传输之前被采样. 如果之前接收到的数据没有被读取, 那么这些已经接收完成的数据将有可能会被丢弃, 导致 SPI 物理模块最终失效. 因此, 在程序中一般都会在 SPI 传输完数据后, 去读取 SPI 设备里的数据, 即使这些数据(Dummy Data)在我们的程序里是无用的(虽然发送后紧接着的读取是无意义的，但仍然需要从寄存器中读出来)。</p><p>2.4 SPI有四种传输模式</p><p>上升沿、下降沿、前沿、后沿触发。当然也有MSB和LSB传输方式.</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c50b28cac194941a190528fa68caa4f><p class=pgc-img-caption></p></div><p>2.5 SPI只有主模式和从模式之分。</p><p>没有读和写的说法，因为实质上每次SPI是主从设备在交换数据。也就是说，你发一个数据必然会收到一个数据；你要收一个数据必须也要先发一个数据。</p><p>3、 工作机制</p><p>3.1概述</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/642816a777e74190ac74f65dcbb7679f><p class=pgc-img-caption></p></div><p>上图只是对 SPI 设备间通信的一个简单的描述, 下面就来解释一下图中所示的几个组件(Module):</p><p>SSPBUF,Synchronous Serial Port Buffer, 泛指 SPI 设备里面的内部缓冲区, 一般在物理上是以 FIFO 的形式, 保存传输过程中的临时数据;</p><p>SSPSR, Synchronous Serial Port Register, 泛指 SPI 设备里面的移位寄存器(Shift Regitser), 它的作用是根据设置好的数据位宽(bit-width) 把数据移入或者移出 SSPBUF;</p><p>Controller, 泛指 SPI 设备里面的控制寄存器, 可以通过配置它们来设置 SPI 总线的传输模式。</p><p>通常情况下, 我们只需要对上图所描述的四个管脚(pin) 进行编程即可控制整个 SPI 设备之间的数据通信:</p><p>SCK, Serial Clock, 主要的作用是 Master 设备往 Slave 设备传输时钟信号, 控制数据交换的时机以及速率;</p><p>SS/CS, Slave Select/Chip Select, 用于 Master 设备片选 Slave 设备, 使被选中的 Slave 设备能够被 Master 设备所访问;</p><p>SDO/MOSI, Serial Data Output/Master Out Slave In, 在 Master 上面也被称为 Tx-Channel, 作为数据的出口, 主要用于 SPI 设备发送数据;</p><p>SDI/MISO, Serial Data Input/Master In Slave Out, 在 Master 上面也被称为 Rx-Channel, 作为数据的入口, 主要用于SPI 设备接收数据;</p><p>SPI 设备在进行通信的过程中, Master 设备和 Slave 设备之间会产生一个数据链路回环(Data Loop), 就像上图所画的那样, 通过 SDO 和 SDI 管脚, SSPSR 控制数据移入移出 SSPBUF, Controller 确定 SPI 总线的通信模式, SCK 传输时钟信号。</p><p>3.2 Timing</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a2c2c4ca184d4786927846e471da08a4><p class=pgc-img-caption></p></div><p>上图通过 Master 设备与 Slave 设备之间交换1 Byte 数据来说明 SPI 协议的工作机制.</p><p>首先, 在这里解释一下相位和极性的概念</p><p>3.2.1 SPI相关的缩写或说法</p><p>SPI的极性Polarity和相位Phase，最常见的写法是CPOL和CPHA，不过也有一些其他写法，简单总结如下：</p><p>CKPOL (Clock Polarity) = CPOL = POL = Polarity = （时钟）极性</p><p>CKPHA (Clock Phase) = CPHA = PHA = Phase = （时钟）相位</p><p>SCK=SCLK=SPI的时钟</p><p>Edge=边沿，即时钟电平变化的时刻，即上升沿(rising edge)或者下降沿(falling edge)</p><p>对于一个时钟周期内，有两个edge，分别称为：</p><p>Leading edge=前一个边沿=第一个边沿，对于开始电压是1，那么就是1变成0的时候，对于开始电压是0，那么就是0变成1的时候；</p><p>Trailing edge=后一个边沿=第二个边沿，对于开始电压是1，那么就是0变成1的时候（即在第一次1变成0之后，才可能有后面的0变成1），对于开始电压是0，那么就是1变成0的时候；</p><p>3.2.2 SPI的相位和极性</p><p>CPOL和CPHA，分别都可以是0或时1，对应的四种组合就是：</p><p>Mode 0 CPOL=0, CPHA=0</p><p>Mode 1 CPOL=0, CPHA=1</p><p>Mode 2 CPOL=1, CPHA=0</p><p>Mode 3 CPOL=1, CPHA=1</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e44659a2a57e4b1cb182a632f6b1cff2><p class=pgc-img-caption></p></div><p>3.2.3 CPOL极性</p><p>先说什么是SCLK时钟的空闲时刻，其就是当SCLK在数发送8个bit比特数据之前和之后的状态，于此对应的，SCLK在发送数据的时候，就是正常的工作的时候，有效active的时刻了。</p><p>先说英文，其精简解释为：Clock Polarity = IDLE state of SCK。</p><p>再用中文详解：</p><p>SPI的CPOL，表示当SCLK空闲idle的时候，其电平的值是低电平0还是高电平1：</p><p>CPOL=0，时钟空闲idle时候的电平是低电平，所以当SCLK有效的时候，就是高电平，就是所谓的active-high；</p><p>CPOL=1，时钟空闲idle时候的电平是高电平，所以当SCLK有效的时候，就是低电平，就是所谓的active-low；</p><p>3.2.4 CPHA相位</p><p>首先说明一点，capture strobe = latch = read = sample，都是表示数据采样，数据有效的时刻。相位，对应着数据采样是在第几个边沿（edge），是第一个边沿还是第二个边沿，0对应着第一个边沿，1对应着第二个边沿。</p><p>对于：</p><p>CPHA=0，表示第一个边沿：</p><p>对于CPOL=0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿；</p><p>对于CPOL=1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿；</p><p>CPHA=1，表示第二个边沿：</p><p>对于CPOL=0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿；</p><p>对于CPOL=1，idle时候的是高电平，第一个边沿就是从低变到高，所以是上升沿；</p><p>还是上图大家更容易看懂</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e436cc2a75de46c6931ae574bd11cf6a><p class=pgc-img-caption></p></div><p>3.2.5 软件中如何设置SPI的极性和相位</p><p>SPI分主设备和从设备，两者通过SPI协议通讯。</p><p>而设置SPI的模式，是从设备的模式，决定了主设备的模式。</p><p>所以要先去搞懂从设备的SPI是何种模式，然后再将主设备的SPI的模式，设置和从设备相同的模式，即可正常通讯。</p><p>对于从设备的SPI是什么模式，有两种：</p><p>3.2.5.1固定的，有SPI从设备硬件决定的</p><p>SPI从设备，具体是什么模式，相关的datasheet中会有描述，需要自己去datasheet中找到相关的描述，即：</p><p>关于SPI从设备，在空闲的时候，是高电平还是低电平，即决定了CPOL是0还是1；</p><p>然后再找到关于设备是在上升沿还是下降沿去采样数据，这样就是，在定了CPOL的值的前提下，对应着可以推算出CPHA是0还是1了。</p><p>3.2.5.2 可配置的，由软件自己设定</p><p>从设备也是一个SPI控制器，4种模式都支持，此时只要自己设置为某种模式即可。</p><p>然后知道了从设备的模式后，再去将SPI主设备的模式，设置为和从设备模式一样，即可。</p><p>对于如何配置SPI的CPOL和CPHA的话，不多细说，多数都是直接去写对应的SPI控制器中对应寄存器中的CPOL和CPHA那两位，写0或写1即可。</p><p>3.3 SSPSR</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e3972460fed2451ca07bc851ff831578><p class=pgc-img-caption></p></div><p>SSPSR 是 SPI 设备内部的移位寄存器(Shift Register). 它的主要作用是根据 SPI 时钟信号状态, 往 SSPBUF 里移入或者移出数据, 每次移动的数据大小由 Bus-Width 以及 Channel-Width 所决定。</p><p>Bus-Width 的作用是指定地址总线到 Master 设备之间数据传输的单位.</p><p>例如, 我们想要往 Master 设备里面的 SSPBUF 写入 16 Byte 大小的数据: 首先, 给 Master 设备的配置寄存器设置 Bus-Width 为 Byte; 然后往 Master 设备的 Tx-Data 移位寄存器在地址总线的入口写入数据, 每次写入 1 Byte 大小的数据(使用 writeb 函数); 写完 1 Byte 数据之后, Master 设备里面的 Tx-Data 移位寄存器会自动把从地址总线传来的1 Byte 数据移入 SSPBUF 里; 上述动作一共需要重复执行 16 次.</p><p>Channel-Width 的作用是指定 Master 设备与 Slave 设备之间数据传输的单位. 与 Bus-Width 相似, Master 设备内部的移位寄存器会依据 Channel-Width 自动地把数据从 Master-SSPBUF 里通过 Master-SDO 管脚搬运到 Slave 设备里的 Slave-SDI 引脚, Slave－SSPSR 再把每次接收的数据移入 Slave-SSPBUF里.通常情况下, Bus-Width 总是会大于或等于 Channel-Width, 这样能保证不会出现因 Master 与 Slave 之间数据交换的频率比地址总线与 Master 之间的数据交换频率要快, 导致 SSPBUF 里面存放的数据为无效数据这样的情况.</p><p>3.4 SSPBUF</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8e8bbf7f2144bb6bb08c6ced1d3dd34><p class=pgc-img-caption></p></div><p>我们知道, 在每个时钟周期内, Master 与 Slave 之间交换的数据其实都是 SPI 内部移位寄存器从 SSPBUF 里面拷贝的. 我们可以通过往 SSPBUF 对应的寄存器 (Tx-Data / Rx-Data register) 里读写数据, 间接地操控 SPI 设备内部的 SSPBUF.</p><p>例如, 在发送数据之前, 我们应该先往 Master 的 Tx-Data 寄存器写入将要发送出去的数据, 这些数据会被 Master-SSPSR 移位寄存器根据 Bus-Width 自动移入 Master-SSPBUF 里, 然后这些数据又会被 Master-SSPSR 根据 Channel-Width 从 Master-SSPBUF 中移出, 通过 Master-SDO 管脚传给 Slave-SDI 管脚, Slave-SSPSR 则把从 Slave-SDI 接收到的数据移入 Slave-SSPBUF 里. 与此同时, Slave-SSPBUF 里面的数据根据每次接收数据的大小(Channel-Width), 通过 Slave-SDO 发往 Master-SDI, Master-SSPSR 再把从 Master-SDI 接收的数据移入 Master-SSPBUF.在单次数据传输完成之后, 用户程序可以通过从 Master 设备的 Rx-Data 寄存器读取 Master 设备数据交换得到的数据.</p><p>3.5 Controller</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e2dc6a1abe85429ab28734dbef8efef0><p class=pgc-img-caption></p></div><p>Master 设备里面的 Controller 主要通过时钟信号(Clock Signal)以及片选信号(Slave Select Signal)来控制 Slave 设备. Slave 设备会一直等待, 直到接收到 Master 设备发过来的片选信号, 然后根据时钟信号来工作.</p><p>Master 设备的片选操作必须由程序所实现. 例如: 由程序把 SS/CS 管脚的时钟信号拉低电平, 完成 SPI 设备数据通信的前期工作; 当程序想让 SPI 设备结束数据通信时, 再把 SS/CS 管脚上的时钟信号拉高电平.</p><p>4. SPI举例</p><p>上面说了那么多，在这里我来举一个例子帮助大家理解。</p><p>SPI是一个环形总线结构，由ss（cs）、sck、sdi、sdo构成，其时序其实很简单，主要是在sck的控制下，两个双向移位寄存器进行数据交换。</p><p>假设下面的8位寄存器装的是待发送的数据10101010，上升沿发送、下降沿接收、高位先发送。</p><p>那么第一个上升沿来的时候 数据将会是sdo=1；寄存器=0101010x。下降沿到来的时候，sdi上的电平将所存到寄存器中去，那么这时寄存器=0101010sdi，这样在 8个时钟脉冲以后，两个寄存器的内容互相交换一次。这样就完成里一个spi时序。</p><p>举例：</p><p>假设主机和从机初始化就绪：并且主机的sbuff=0xaa，从机的sbuff=0x55，下面将分步对spi的8个时钟周期的数据情况演示一遍:假设上升沿发送数据</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aea85f6607284ad7bff7fdb62330c5c4><p class=pgc-img-caption></p></div><p>这样就完成了两个寄存器8位的交换，上面的上表示上升沿、下表示下降沿，sdi、sdo相对于主机而言的。已经很接近理解了，下一步就是把 上面的过程转为动画</p><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c131562c2564fcc95168b9e9cb8d343><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/09141a55d0a147139ef1a311973cfb2d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=SPI协议详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/009cf169359b46a2b385cee8d2a07746><p class=pgc-img-caption></p></div><p>5、 STM32驱动</p><p>STM32的spi较为简单，因为STM32的内部集成有SPI。</p><pre><code>5.1 SPI的初始化void SPIInit(void){    SPI_InitTypeDef SPI_InitStructure;    //初始化SPI与GPIO口的连接    FLASH_GPIO_Init();    /*!&lt; Deselect the FLASH: Chip Select high */    CE_High();    /*!&lt; SPI configuration */    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;    SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;    SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;    SPI_InitStructure.SPI_BaudRatePrescaler =                     SPI_BaudRatePrescaler_8;    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;    SPI_InitStructure.SPI_CRCPolynomial = 7;    SPI_Init(SPI1, &amp;SPI_InitStructure);    /*!&lt; Enable the sFLASH_SPI */    SPI_Cmd(SPI1, ENABLE);}</code></pre><p>5.2 SPI写1个字节</p><p>```</p><pre><code>uint8 Send_Byte(uint8 data){    //发送不为空    while(!(SPI1-&gt;SR &amp; SPI_I2S_FLAG_TXE));    SPI1-&gt;DR = data;    //读取收到的数据    while(!(SPI1-&gt;SR &amp; SPI_I2S_FLAG_RXNE));    return SPI1-&gt;DR;}</code></pre><p>```</p><pre><code>5.3 SPI读一个字节uint8 Get_Byte(void){    //发送不为空    while(!(SPI1-&gt;SR &amp; SPI_I2S_FLAG_TXE)); // 发送缓冲为空，跳出循环    SPI1-&gt;DR = 0xFF; //    //读取收到的数据    while(!(SPI1-&gt;SR &amp; SPI_I2S_FLAG_RXNE)); //接受缓冲非空，跳出循环    return SPI1-&gt;DR;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SPI','协议','详解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>