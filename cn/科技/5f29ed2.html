<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高性能线程间消息传递库Disruptor | 极客快訊</title><meta property="og:title" content="高性能线程间消息传递库Disruptor - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/37450e36f66249f7b616999d755f7317"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f29ed2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f29ed2.html><meta property="article:published_time" content="2020-10-29T21:04:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:29+08:00"><meta name=Keywords content><meta name=description content="高性能线程间消息传递库Disruptor"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5f29ed2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高性能线程间消息传递库Disruptor</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>一、概述</strong></h1><p>LMAX Disruptor是一个高性能的线程间消息传递库。它源于LMAX对并发性，性能和非阻塞算法的研究，如今构成了其Exchange基础架构的核心部分。</p><p>理解Disruptor是什么的最好方法是将它与目前已经的很好理解和非常相似的东西进行比较，例如与Java的BlockingQueue进行对比。与队列一样，Disruptor的目的是在同一进程内的线程之间移动数据（例如消息或事件）。但是，Disruptor相比队列提供了一些关键功能，它们是：</p><ul><li>同一个消息会向所有消费者都发送-多播能力，与消费者依赖图有关（Multicast events to consumers, with consumer dependency graph）。</li><li>为事件（events）预先分配内存，避免gc与内存分配开销。</li><li>可选择无锁(lock-free)，基于CAS多个生产者不会竞争通一个元素，实现无锁操作元素。</li><li>缓存行填充，避免伪共享</li><li>使用两阶段协议，让多个线程可用同时修改不同元素，注意，读取时候只能读取到先提交的元素。</li></ul><h1><strong>二、核心概念</strong></h1><p>在我们理解Disruptor如何工作前，我们先看看Disruptor中的核心术语的介绍，或者说是DDD中描述的域对象</p><ul><li>Ring Buffer: 环形缓冲区通常被认为是Disruptor的核心，但是从3.0开始，Ring Buffer仅负责存储和更新通过Disruptor的数据（事件）。对于一些高级用例，可以完全由用户替换。</li><li>Sequence: Disruptor使用Sequences作为识别特定组件所在位置的方法。每个消费者（EventProcessor）都像Disruptor本身一样维护一个Sequence。大多数并发代码依赖于这些Sequence值的移动，因此Sequence支持AtomicLong的许多当前功能。事实上，3版本与2之间唯一真正的区别是序列包含额外的功能，以防止Sequence和其他值之间出现伪共享。</li><li>Sequencer: Sequencer是Disruptor的真正核心。该接口的2个实现（单生产者，多生产者）实现了所有并发算法，用于在生产者和消费者之间快速，正确地传递数据。</li><li>Sequence Barrier: 序列屏障（Sequence Barrier）由Sequencer产生，幷包含对Sequencer中主要发布的序列Sequence和任何依赖消费者的序列Sequence的引用。它包含确定是否有任何可供消费者处理的事件的逻辑。</li><li>Wait Strategy: 等待策略，确定消费者如何等待生产者将事件放入Disruptor。</li><li>Event: 从生产者传递给消费者的数据单位。事件没有特定的代码表示，因为它完全由用户定义。</li><li>EventProcessor: 用于处理来自Disruptor的事件的主事件循环，并拥有消费者序列的所有权。有一个名为BatchEventProcessor的实现，它包含事件循环的有效实现，并将回调到使用的提供的EventHandler接口实现（在线程池内运行BatchEventProcessor的run方法）。</li><li>EventHandler: 由用户实现并代表Disruptor的消费者的接口。</li><li>Producer: 调用Disruptor以将事件放入队列的用户代码。这个概念在代码中也没有表示。</li></ul><p>为了将这些元素置于上下文中，下面是LMAX如何在其高性能核心服务中使用Disruptor的示例，例如：exchange(交易系统)。如下图Disruptor和其一系列依赖的消费者。</p><div class=pgc-img><img alt=高性能线程间消息传递库Disruptor onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/37450e36f66249f7b616999d755f7317><p class=pgc-img-caption></p></div><p>c1,c2对同一个元素处理完毕后在进行c3处理。</p><p>每个消费者持有自己的当前消费序号，写入时候要看序号最小的消费者序号，c3消费时候要看c1,c2最小的序号。</p><p>每个EventHandler被包裹到对于的BatchEventProcessor中，BatchEventProcessor是一个事件处理循环，类似NIOevenloop,每个BatchEventProcessor被分到线程池里面一个固定线程来执行。BatchEventProcessor发现后可用元素后，就调用EventHandler发射出元素。</p><div class=pgc-img><img alt=高性能线程间消息传递库Disruptor onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a3d4c9dcdbe643808651169d63be83cf><p class=pgc-img-caption></p></div><p>如上图c1,c2,c3共享同一个ringbuffer，读写都是同一个ringbuffer.</p><p>如上图c1,c2（EventHandler）分别被自己的BatchEventProcessor包裹，但是其共享同一个SequenceBarrier，c1,c2读取元素时候要调用EventHandler的waitfor来判断是否有可以读取的元素。</p><p>c3被自己的BatchEventProcessor包裹，其有自己的SequenceBarrier，并且持有其依赖的前面的所有消费者的引用。</p><p>c3消费元素时候要看其依赖的所有消费者，看其是否都消费了某一个元素，如果是其才可以消费。</p><h1><strong>三、多播事件-Multicast Events</strong></h1><p>这是Java中队列和Disruptor之间最大的行为差异。当您有多个消费者在同一个Disruptor上监听事件时候，所有事件都会发布给所有消费者，而Java队列中的每个事件只会发送给某一个消费者。 Disruptor的行为旨在用于需要对同一数据进行独立的多个并行操作的情况。来自LMAX的规范示例是我们有三个操作，即日志记录（将输入数据写入持久性日志文件），复制（将输入数据发送到另一台机器以确保存在数据的远程副本）和业务逻辑（真正的处理工作）。</p><p>使用WorkerPool也可以执行Executor样式的事件处理，其中通过并行处理不同事件来实现可伸缩。请注意，它是在现有的Disruptor类之上进行的，并且不会使用相同的第一类支持进行处理，因此它可能不是实现该特定目标的最有效方法。</p><p>查看图1.可以看到有3个事件处理程序监听（JournalConsumer，ReplicationConsumer和ApplicationConsumer）到Disruptor，这些事件处理程序中的每一个都将接收Disruptor中可用的所有消息（按相同的顺序）。这允许每个消费者的工作并行运行。</p><h1><strong>四、消费者依赖图-Consumer Dependency Graph</strong></h1><p>为了支持并行处理行为的实际应用，有必要支持消费者之间的协调。返回参考上述示例，必须防止业务逻辑消费者在日记和复制消费者完成其任务之前取得进展。我们称这个概念为门控gating，或者更准确地说，这种行为的超集特征称为门控。门控发生在两个地方。首先，我们需要确保生产者不会超过消费者。这是通过RingBuffer.addGatingConsumers（）将相关的消费者添加到Disruptor来处理的。其次，先前提到的情况是通过构造一个SequenceBarrier，其包含组元的Sequences，其必须首先完成他们的处理</p><p>参考图1，有3个消费者正在监听来自Ring Buffer的事件。此示例中有一个依赖关系图。 ApplicationConsumer依赖于JournalConsumer和ReplicationConsumer。这意味着JournalConsumer和ReplicationConsumer可以彼此并行自由运行。从ApplicationConsumer的SequenceBarrier到JournalConsumer和ReplicationConsumer的序列的连接可以看到依赖关系。值得注意的是Sequencer与下游消费者之间的关系。它的一个作用是确保发布不包装Ring Buffer。要做到这一点，下游消费者中没有一个可能具有低于环形缓冲区序列的序列，而不是环形缓冲区的大小。但是，使用依赖关系图可以进行有趣的优化。由于ApplicationConsumers Sequence保证小于或等于JournalConsumer和ReplicationConsumer（这是该依赖关系所确保的），因此Sequencer只需要查看ApplicationConsumer的Sequence。在更一般的意义上，Sequencer只需要知道作为依赖关系树中叶节点的使用者的序列。</p><h1><strong>五、事件预分配-Event Preallocation</strong></h1><p>Disruptor的目标之一是在低延迟环境中使用。在低延迟系统中，必须减少或移除内存分配。在基于Java的系统中，目的是减少由于垃圾收集导致的系统停顿（在低延迟C / C ++系统中，由于存在于内存分配器上的争用，大量内存分配也存在问题）。</p><p>为了支持这一点，用户可以预先分配Disruptor中事件所需的存储空间。在构造期间，EventFactory由用户提供，并将在Disruptor的Ring Buffer中为每个条目调用。将新数据发布到Disruptor时，API将允许用户获取构造的对象，以便他们可以调用方法或更新该存储对象上的字段。 Disruptor保证这些操作只要正确实现就是并发安全的。</p><h1><strong>六、可选的无锁-Optionally Lock-free</strong></h1><p>低延迟期望推动的另一个关键实现细节是广泛使用无锁算法来实现Disruptor。所有内存可见性和正确性保证都是使用内存屏障（体现为volatile）和/或CAS操作实现的。只有一个情况需要实际锁定并且在BlockingWaitStrategy中。这仅仅是为了使用条件变量，以便在等待新事件到达时前parked消费线程。许多低延迟系统将使用忙等待busy-wait 来避免使用条件可能引起的抖动，但是大量在系统繁忙等待的操作可能导致性能显著下降，尤其是在CPU资源严重受限的情况下。例如。虚拟化环境中的Web服务器。</p><div class=tt-column-card data-content='{"new_thumb_url": "http://sf1-ttcdn-tos.pstatp.com/img/pgc-image/156154482609605e3db01c4", "title": "\u5206\u5e03\u5f0fRPC\u6846\u67b6Dubbo\u5185\u6838\u539f\u7406\u5256\u6790", "distribution_user_id": 1624358660504589, "price": 29.9, "column_id": "6706788500336804110", "share_price": 2.39, "author_description": "\u683c\u5c40\u591a", "thumb_url": "http://p7.pstatp.com/large/pgc-image/156154482609605e3db01c4", "sold": 31}'></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'线程间','传递','Disruptor'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/5df1266.html alt=高性能线程间消息传递库Disruptor概述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/258a533914264f00a8d1cea6e202284b style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/5df1266.html title=高性能线程间消息传递库Disruptor概述>高性能线程间消息传递库Disruptor概述</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>