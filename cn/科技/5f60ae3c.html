<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java中，可以通过传递超类方法中使用的参数的子类来覆盖方法吗？ | 极客快訊</title><meta property="og:title" content="java中，可以通过传递超类方法中使用的参数的子类来覆盖方法吗？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/2befa93523904481ada1fe7a1df6f511"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5f60ae3c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5f60ae3c.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="java中，可以通过传递超类方法中使用的参数的子类来覆盖方法吗？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5f60ae3c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java中，可以通过传递超类方法中使用的参数的子类来覆盖方法吗？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>前言</strong></p><p><strong>什么是序列化和反序列化</strong></p><p>Java 提供了一种对象序列化的机制，该机制中，一个对象可以被表示为一个字节序列，该字节序列包括该对象的数据、有关对象的类型的信息和存储在对象中数据的类型。反序列化就是通过序列化后的字段还原成这个对象本身。但标识不被序列化的字段是不会被还原的。</p><p><strong>序列化有什么用</strong></p><p>1）网站相应的 session对象存储在硬盘上，那么保存在 session中的内容就必须实现相关的序列化操作。</p><p>2）如果使用的 java对象要在分布式中使用或者在 rmi远程调用的网络中使用的话，那么相关的对象必须实现 java序列化接口。</p><p><strong>Java反序列化类型</strong></p><p>我们最常见就是原生的java反序列化类型，其实java中有几种方式可以执行反序列化，本文目的也是对这几种类型的反序列化方法进行归纳和总结。</p><p><strong>1、 Java原生序列化</strong></p><p>Java包中自带的类InputStream和OutputStream，它们之间可以互相转化，使用writeObject序列化，使用readObject反序列化。</p><pre>import java.io.*; public class DeserializeDemo{ public static void main(String [] args) { Employee e = null; try { FileInputStream fileIn = new FileInputStream("/tmp/employee.ser"); ObjectInputStream in = new ObjectInputStream(fileIn); e = (Employee) in.readObject(); in.close(); fileIn.close(); }catch(IOException i) { i.printStackTrace(); return; }catch(ClassNotFoundException c) { System.out.println("Employee class not found"); c.printStackTrace(); return; } System.out.println("Deserialized Employee..."); System.out.println("Name: " + e.name); System.out.println("Address: " + e.address); System.out.println("SSN: " + e.SSN); System.out.println("Number: " + e.number); }}</pre><p><strong>2、 Json反序列化</strong></p><p>Json序列化一般会使用jackson包，通过ObjectMapper类来进行一些操作，比如将对象转化为byte数组或者将json串转化为对象。</p><pre>public static &lt;T&gt; String serialize(T t) throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper(); String jsonResult = mapper.writerWithDefaultPrettyPrinter() .writeValueAsString(t); return jsonResult; }</pre><p><strong>3、 Fastjson反序列化</strong></p><p>Fastjson是一个性能很好的Java语言实现的Json解析器和生成器，由来自阿里巴巴的工程师开发。具有极快的性能，超越任何其他的Java Json Parser。Fastjson使用parseObject来进行反序列化。</p><pre>import com.alibaba.fastjson.JSON;  public class Person {  int age;  String name;  public int getAge() {  return age;  }  public void setAge(int age) {  this.age = age;  }  public String getName() {  return name;  }  public void setName(String name) {  this.name = name;  }  public static void main(String[] args) {  String jsonString="{\"name\":\"hah\",\"age\":1}";  Person person = JSON.parseObject(jsonString, Person.class);  System.out.println(1);  } } </pre><p><strong>4、Protobuf 反序列化</strong></p><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API。</p><p><strong>proto.proto文件内容</strong></p><pre>package proto;message TestMsg{ optional string id = 1; optional string name = 2;}</pre><p><strong>序列化</strong></p><pre>public byte[] build(){ Proto.TestMsg.Builder builder = Proto.TestMsg.newBuilder(); builder.setId("ID的值"); builder.setName("Name的值"); Proto.TestMsg msg = builder.build(); return msg.toByteArray();}</pre><p><strong>反序列化</strong></p><pre>Proto.TestMsg msg = Proto.TestMsg.parseFrom(message.returnByte());System.out.Println(msg);</pre><p><strong>各方式反序列化比较</strong></p><div class=pgc-img><img alt=java中，可以通过传递超类方法中使用的参数的子类来覆盖方法吗？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2befa93523904481ada1fe7a1df6f511><p class=pgc-img-caption></p></div><p><strong>各序列化漏洞简介</strong></p><p>除了使用protobuf进行反序列化没有出现过漏洞，其他方式的序列化都曾出现过漏洞。下面将简单介绍下漏洞，详细的漏洞和exp构造方法大家可以去网上搜索关键字查看（java几个反序列化漏洞exp构造过程都十分精彩，推荐大家认真阅读下）</p><p><strong>1、Object Serialize 漏洞</strong></p><p>Apache Commons Collections中实现了TransformedMap ，该类可以在一个元素被添加/删除/或是被修改时(即key或value：集合中的数据存储形式即是一个索引对应一个值，就像身份证与人的关系那样)，会调用transform方法自动进行特定的修饰变换。</p><div class=pgc-img><img alt=java中，可以通过传递超类方法中使用的参数的子类来覆盖方法吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a63cc22045484968a7b8d774ba07facf><p class=pgc-img-caption></p></div><p>TransformedMap.decorate方法，预期是对Map类的数据结构进行转化，该方法有三个参数。</p><ul><li>第一个参数为待转化的Map对象</li><li>第二个参数为Map对象内的key要经过的转化方法（可为单个方法，也可为链，也可为空）</li><li>第三个参数为Map对象内的value要经过的转化方法</li></ul><p>通过对第三个参数通过构造ChainedTransformer链，通过一系列变化，最终执行系统命令。</p><p><strong>2、Jackson-databind 漏洞</strong></p><p>Jackson是一套开源的java序列化与反序列化工具框架，可将java对象序列化为xml和json格式的字符串及提供对应的反序列化过程。由于其解析效率较高，目前是Spring MVC中内置使用的解析方式，该漏洞的触发条件是ObjectMapper反序列化前调用了enableDefaultTyping方法。该方法允许json字符串中指定反序列化java对象的类名，而在使用Object、Map、List等对象时，可诱发反序列化漏洞，导致可执行任意命令。</p><p><strong>3、FastJson 漏洞</strong></p><p>fastjson在解析json的过程中，支持使用autoType来实例化某一个具体的类，并通过json来填充其属性值。而JDK自带的类com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl中有一个私有属性_bytecodes，其部分方法会执行这个值中包含的Java字节码。通过注入恶意代码到_bytecode，导致任意代码执行漏洞。</p><p>注：Fastjson和Jackson Payload构造的方式都一样，虽然解析函数不一样，但是都是将json转为object，过程是类似的。</p><p><strong>防止反序列化漏洞</strong></p><p><strong>1、Java Serialization</strong></p><ul><li>jdk里增加了一个filter机制 <strong><em>http://openjdk.java.net/jeps/290</em></strong> ，这个一开始是出现在jdk9上的，后面移值回jdk6/7/8上，如果安装的jdk版本是比较新的，可以找到相关的类</li><li>Oracle打算废除java序列化： <strong><em>https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html</em></strong></li></ul><p><strong>2、jackson-databind</strong></p><ul><li>jackson-databind里是过滤掉一些已知的类，参见 <strong><em>SubTypeValidator.java</em></strong></li><li>jackson-databind的 <strong><em>CVE issue列表</em></strong></li></ul><p><strong>3、fastjson</strong></p><ul><li>fastjson通过一个denyList来过滤掉一些危险类的package，参见 <strong><em>ParserConfig.java</em></strong></li><li>fastjson在新版本里denyList改为通过hashcode来隐藏掉package信息，但通过这个 <strong><em>DenyTest5</em></strong> 可以知道还是过滤掉常见危险类的package</li><li>fastjson在新版本里默认把autoType的功能禁止掉了</li></ul><p><strong>这些序列化漏洞的根本原因是： 没有控制序列化的类型范围。</strong></p><p>仔细看的读者会发现并没有提及protobuf的反序列化漏洞， 为什么在protobuf里并没有这些反序列化问题？</p><ul><li>protobuf在IDL里定义好了package范围</li><li>protobuf的代码都是自动生成的，怎么处理二进制数据都是固定的</li></ul><p>protobuf把一切都框住了，少了灵活性，自然就少漏洞。</p><p>注：IDL（Interface description language）文件：参与通讯的各方需要对通讯的内容需要做相关的约定（Specifications）。为了建立一个与语言和平台无关的约定，这个约定需要采用与具体开发语言、平台无关的语言来进行描述。这种语言被称为接口描述语言（IDL），采用IDL撰写的协议约定称之为IDL文件。</p><p><strong>总结：</strong></p><p>本文总结了java反序列化的几种方式，并回顾了java几个经典的漏洞以及对应的修复方案，希望通过本文，大家对java反序列化漏洞有更深刻的认知。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'java','通过','传递'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>