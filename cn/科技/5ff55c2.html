<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>写一个java工具从数据库生成实体类 | 极客快訊</title><meta property="og:title" content="写一个java工具从数据库生成实体类 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/5ff55c2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/5ff55c2.html><meta property="article:published_time" content="2020-10-29T20:59:31+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:31+08:00"><meta name=Keywords content><meta name=description content="写一个java工具从数据库生成实体类"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/5ff55c2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>写一个java工具从数据库生成实体类</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>开始写之前的说明</strong></p><p>​ 这只是一个简单的解析数据库建表语句之后，根据解析结果生成java文件的一个简单工具。写的原因有两个。</p><p>​ 1：项目中没有人写实体类的注释，字段的注释，现有的工具也没法根据数据库的注释自动添加到class文件上。</p><p>​ 2：自己写一个也似乎不是很难。</p><p>​ 所以就自己写了一个。</p><p>这里在生成java文件的时候用的是<strong>freemarker</strong>。用了<strong>jdbc</strong>作为执行sql的工具。</p><p>这个项目已经放在github上了，地址：https://github.com/hjx601496320/entityMaker 。</p><p><strong>用到的依赖：</strong></p><pre>&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.28&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.45&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt;&lt;/dependency&gt;</pre><p><strong>获取数据库中的所有的表名称</strong></p><p>想要根据数据库中的建表语句来创建java文件首先要先知道数据库中都有那些表。so，开始。</p><p><strong>配置数据库的相关信息</strong></p><p>在获取数据库链接前，我们先写一个文件用来保存数据库链接的各种信息。</p><p>新建文件<strong>config.xml</strong></p><pre>&lt;xml&gt; &lt;jdbc.url&gt;&lt;/jdbc.url&gt; &lt;jdbc.username&gt;&lt;/jdbc.username&gt; &lt;jdbc.password&gt;&lt;/jdbc.password&gt;&lt;/xml&gt;</pre><p><strong>jdbc.url</strong>：链接数据库的url。例如：jdbc:mysql://127.0.0.1:3306/demo?useSSL=true</p><p><strong>jdbc.username</strong>：数据库的用户名。</p><p><strong>jdbc.password</strong>：数据库的密码。</p><p>这样就配置好了。</p><p><strong>写一个工具类读取xml：XmlUtils.java</strong></p><pre>import org.w3c.dom.Document;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import java.io.ByteArrayInputStream;import java.io.InputStream;import java.util.Scanner;/** * 读取xml */public class XmlUtils { /** * 读取 Document * * @param xmlPath * @return */ public static Document getConfigDocument(String xmlPath) { try { InputStream resourceAsStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(xmlPath); Scanner scanner = new Scanner(resourceAsStream); StringBuilder stringBuilder = new StringBuilder(); while (scanner.hasNextLine()) { stringBuilder.append(scanner.nextLine()).append("\n"); } DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder documentBuilde = documentBuilderFactory.newDocumentBuilder(); Document document = documentBuilde.parse(new ByteArrayInputStream(stringBuilder.toString().getBytes())); return document; } catch (Exception e) { e.printStackTrace(); return null; } }}</pre><p><strong>打开数据库链接</strong></p><pre>//获取数据库配置信息Document configXml = XmlUtils.getConfigDocument(CONFIG_PATH);Element element = configXml.getDocumentElement();String jdbcUrl = element.getElementsByTagName("jdbc.url").item(0).getTextContent();String username = element.getElementsByTagName("jdbc.username").item(0).getTextContent();String password = element.getElementsByTagName("jdbc.password").item(0).getTextContent();//打开数据库链接Connection conn = (Connection) DriverManager.getConnection(jdbcUrl, username, password);</pre><p>获取到链接之后，下一步就是要读取数据库中的表数据了。</p><p><strong>获取数据库中的表</strong></p><pre>Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery("SHOW TABLES;");while (resultSet.next()) { //这里就获取到了数据库中的所有的表的名称了。 String tableName = resultSet.getString(1);}</pre><p>这里拿到表名称后就可以依次得到建表语句，并解析建表语句了。</p><p>这里之所以使用解析建表语句的方法是因为这样可以比较完整的得到注释信息。用另一种方法的时候表的注释一直获取不到（另一种方法我忘记怎么说了～）。</p><p><strong>得到建表语句</strong></p><p>这里就是拼接sql，然后执行就好了。下面是代码：</p><pre>Statement statement = connection.createStatement();ResultSet resultSet = statement.executeQuery("show CREATE TABLE 表名称");while (resultSet.next()) { //这里就得到了表的建表语句 String createTableSql = resultSet.getString(2);}</pre><p>做到这一步，我们就完整的得到了数据库中的所有的建表语句了。接下来就是要分析建表语句并且用来生成实体类了。</p><p><strong>建表语句分析</strong></p><p><strong>建表sql</strong></p><p>下面是执行 sql <strong>show create table user</strong> 的结果：</p><pre>CREATE TABLE `user` (  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',  `name` varchar(225) DEFAULT NULL COMMENT '用户名',  `create_date` datetime DEFAULT NULL,  `status` int(11) DEFAULT NULL,  `age` int(11) DEFAULT NULL COMMENT '年龄',  `mark` varchar(225) DEFAULT NULL,  PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2104778081 DEFAULT CHARSET=latin1 COMMENT='用户表' </pre><p>这里可以看出，要创建的实体类的名称就在第一行的<strong>CREATE TABLE</strong> 后的两个<strong>`</strong>符号中间，这样我们就可以通过正则将表的名称取出来，然后转换成为我们需要的class名称。首先我们先写一个通过正则提取数据的方法，下面是代码：</p><p><strong>正则代码</strong></p><pre> /** * 根据正则查找 * * @param sql * @param pattern * @param group * @return */ static String getByPattern(String sql, String pattern, int group) { Pattern compile = Pattern.compile(pattern); Matcher matcher = compile.matcher(sql); while (matcher.find()) { return matcher.group(group); } return null; }</pre><p>现在开始从建表语句中提取table的名称（虽然在获得数据库所有表的时候就已经知道了，但是在写一次也没有什么问题不是吗 ~~~），下面是代码：</p><p><strong>获取表的名称</strong></p><pre> /** * 获得表的名称 * * @param sql * @return */ public static String getTableName(String sql) { return getByPattern(sql, "CREATE TABLE `(.*)`", 1); }</pre><p>这里就已经将表的名称取出来了。</p><p>接下来是获取表上的注释，这里我们取表的注释。下面是代码：</p><p><strong>提取表注释</strong></p><pre> public static String getTableComment(String sql) { return getByPattern(sql, "\\) .* COMMENT='(.*)'", 1); }</pre><p>现在开始获取id信息。</p><p><strong>获取id</strong></p><p>获取id依然是使用正则就好了，代码如下：</p><pre>public static String getId(String sql) { return getByPattern(sql, "PRIMARY KEY \\(`(.*)`\\)", 1);}</pre><p>因为原本语句中有一对括号，所以在这里对外面的括号做了转义处理。接下来开始提取数据库中的字段，字段类型，字段注释。</p><p><strong>字段，字段类型，字段注释</strong></p><p><strong>先取出来建表语句中的和字段相关的sql</strong></p><p>2019年01月21日，修改：</p><p>没想到有的表里没有id，就导致下面的代码执行后出错了，修改一下结束的判断。</p><pre> /** * 获取建表语句中和字段相关的sql * * @param sql * @return */ public static List&lt;String&gt; getColumnSqls(String sql) { List&lt;String&gt; lines = new ArrayList&lt;&gt;(); Scanner scanner = new Scanner(sql); boolean start = false; while (scanner.hasNextLine()) { String nextLine = scanner.nextLine(); if (nextLine.indexOf("CREATE TABLE") != -1) { start = true; continue; } //没想到有的表没有id /(ㄒoㄒ)/~~ if (nextLine.indexOf("PRIMARY KEY") != -1 || nextLine.indexOf("ENGINE=") != -1) { start = false; continue; } if (start) { lines.add(nextLine); } } return lines; }</pre><p>这里的运行结果是：</p><pre> `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',  `name` varchar(225) DEFAULT NULL COMMENT '用户名',  `create_date` datetime DEFAULT NULL,  `status` int(11) DEFAULT NULL,  `age` int(11) DEFAULT NULL COMMENT '年龄',  `mark` varchar(225) DEFAULT NULL, </pre><p>这也就取到了table中所有的字段相关信息了，接下来我们来获取字段名称：</p><p><strong>获取列名，注释，数据类型</strong></p><pre>List&lt;String&gt; columns = SqlUtils.getColumnSqls(sql);for (String oneLine : columns) { System.out.println(oneLine); String columnName = SqlUtils.getByPattern(oneLine, "`(.*)`", 1); String comment = SqlUtils.getByPattern(oneLine, "COMMENT '(.*)'", 1); String columnType = SqlUtils.getByPattern(oneLine, "`" + columnName + "` ([A-Za-z]*)", 1); System.out.printf("名称：%-20s 类型：%-20s 注释：%-20s \n", columnName, columnType, comment);}</pre><p>输出结果：</p><pre> `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id', 名称：id 类型：int 注释：用户id  `name` varchar(225) DEFAULT NULL COMMENT '用户名', 名称：name 类型：varchar 注释：用户名  `create_date` datetime DEFAULT NULL, 名称：create_date 类型：datetime 注释：null  `status` int(11) DEFAULT NULL, 名称：status 类型：int 注释：null  `age` int(11) DEFAULT NULL COMMENT '年龄', 名称：age 类型：int 注释：年龄  `mark` varchar(225) DEFAULT NULL, 名称：mark 类型：varchar 注释：null</pre><p>到了这，我就就已经从建表语句里拿到了所有需要的数据了，下面就开始使用这些数据来生成java文件了。</p><p><strong>根据上面获取的数据开始创建java文件</strong></p><p>终于开始要创建java文件了。</p><p>但是～在创建java文件的时候要先吧之前获取的数稍微处理一下，将sql中的格式转换为java中的格式。比如属性名称，数据类型，class名称之类的，现在开始～</p><p><strong>将表名称转换为合适的class名称</strong></p><p>就是首字母大写，驼峰式的命名规范。例如将<strong>user_log</strong>或者<strong>USER_LOG</strong>转换为UserLog。</p><p>我们可以这么写：</p><pre> /** * 类名称转换 * * @param tableName * @return */ public static String entityName(String tableName) { String lowerCaseName = tableName.toLowerCase(); StringBuilder newName = new StringBuilder(); char[] chars = lowerCaseName.toCharArray(); boolean change = false; for (int i = 0; i &lt; chars.length; i++) { char aChar = chars[i]; if (aChar == '_' &amp;&amp; !change) { change = true; continue; } //首字母大写 if (i == 0) { aChar = Character.toUpperCase(aChar); } if (change) { aChar = Character.toUpperCase(aChar); change = false; } newName.append(aChar); } return newName.toString(); }</pre><p>这样就得到了我们需要的class的名称了。</p><p><strong>将字段名称转换为java中的属性名称</strong></p><p>这里就是将上一步操作的首字母大写去掉就好了，下面是代码：</p><pre> /** * 属性名称转换 * * @param name * @return */ public static String fieldName(String name) { name = name.toLowerCase(); StringBuilder newName = new StringBuilder(); char[] chars = name.toCharArray(); boolean change = false; for (int i = 0; i &lt; chars.length; i++) { char aChar = chars[i]; if (aChar == '_' &amp;&amp; !change) { change = true; continue; } if (change) { aChar = Character.toUpperCase(aChar); change = false; } newName.append(aChar); } return newName.toString(); }</pre><p>接下来是将sql中的数据类型转换为java中的数据类型。</p><p><strong>sql数据类型转换</strong></p><p>这里用map做了一个映射，有自己特定要求的可以自己修改。</p><pre>public class ColumnFieldTypeMapping { private Map&lt;String, Class&gt; sqlFieldTypeMapping = new HashMap&lt;&gt;(); { sqlFieldTypeMapping.put("VARCHAR", String.class); sqlFieldTypeMapping.put("CHAR", String.class); sqlFieldTypeMapping.put("TEXT", String.class); sqlFieldTypeMapping.put("MEDIUMTEXT", String.class); sqlFieldTypeMapping.put("LONGTEXT", String.class); sqlFieldTypeMapping.put("TINYTEXT", String.class); sqlFieldTypeMapping.put("BIT", Boolean.class); sqlFieldTypeMapping.put("INT", int.class); sqlFieldTypeMapping.put("BIGINT", long.class); sqlFieldTypeMapping.put("DOUBLE", double.class); sqlFieldTypeMapping.put("TINYINT", int.class); sqlFieldTypeMapping.put("FLOAT", float.class); sqlFieldTypeMapping.put("DECIMAL", BigDecimal.class); sqlFieldTypeMapping.put("INT UNSIGNED", int.class); sqlFieldTypeMapping.put("BIGINT UNSIGNED", int.class); sqlFieldTypeMapping.put("DECIMAL UNSIGNED", BigDecimal.class); sqlFieldTypeMapping.put("DATETIME", Date.class); sqlFieldTypeMapping.put("TIME", Date.class); sqlFieldTypeMapping.put("DATE", Date.class); sqlFieldTypeMapping.put("TIMESTAMP", Date.class); } /** * 根据sql数据类型获取Java数据类型 * * @param columnType * @return */ public Class getFieldType(String columnType) { Class aClass = sqlFieldTypeMapping.get(columnType); if (aClass == null) { return sqlFieldTypeMapping.get(columnType.toUpperCase()); } return null; }}</pre><p>写到这里，所有参与生成java文件的信息就已经获取完成了。</p><p>这时候我们需要把他们组装起来，用来放进freemarker中来解析并生成java文件中的内容。</p><p><strong>组装参数</strong></p><p>这里可能我以后用这个代码干别的事情所以我建了两个类，一个是<strong>ClassModel.java</strong>，一个是<strong>EntityModel.java</strong>。</p><p>EntityModel继承了ClassModel。我们主要用的是<strong>EntityModel.java</strong>。下面是代码：</p><pre>import java.util.*;/** * 用于生成java Entity文件的类 */public class ClassModel { /** * java 中不需要引包的类型 */ private static List&lt;Class&gt; baseClass = Arrays.asList( int.class, double.class, float.class, long.class, short.class, byte.class, char.class, boolean.class, String.class ); /** * 类注释 */ private String classDoc; /** * 类名 */ private String className; /** * 类 包名 */ private String packageName; /** * K:属性名称 * V:属性类型 */ private Map&lt;String, Class&gt; fields = new HashMap&lt;&gt;(); /** * 属性的注释 */ private Map&lt;String, String&gt; fieldDoc = new HashMap&lt;&gt;(); ; private List&lt;Class&gt; imports = new ArrayList&lt;&gt;(); /** * 添加需要导入的包 * * @param importClass */ public void addImport(Class importClass) { if (baseClass.indexOf(importClass) != -1) { return; } if (imports.indexOf(importClass) == -1) { imports.add(importClass); } } /** * 添加属性 * * @param fieldName 属性名称 * @param fieldClass 属性类型 */ public void addfield(String fieldName, Class fieldClass) { if (!fields.containsKey(fieldName)) { fields.put(fieldName, fieldClass); } } /** * 添加属性注释 * * @param fieldName 属性名称 * @param fieldDoc 属性注释 */ public void addfieldDoc(String fieldName, String fieldDoc) { if (!this.fieldDoc.containsKey(fieldName)) { this.fieldDoc.put(fieldName, fieldDoc); } } public List&lt;Class&gt; getImports() { return imports; } public void setImports(List&lt;Class&gt; imports) { this.imports = imports; } public String getClassDoc() { return classDoc; } public void setClassDoc(String classDoc) { this.classDoc = classDoc; } public String getClassName() { return className; } public void setClassName(String className) { this.className = className; } public String getPackageName() { return packageName; } public void setPackageName(String packageName) { this.packageName = packageName; } public Map&lt;String, Class&gt; getFields() { return fields; } public void setFields(Map&lt;String, Class&gt; fields) { this.fields = fields; } public Map&lt;String, String&gt; getFieldDoc() { return fieldDoc; } public void setFieldDoc(Map&lt;String, String&gt; fieldDoc) { this.fieldDoc = fieldDoc; } @Override public String toString() { final StringBuilder sb = new StringBuilder("{"); sb.append(" \"classDoc\"=\"").append(classDoc).append('\"'); sb.append(", \"className\"=\"").append(className).append('\"'); sb.append(", \"packageName\"=\"").append(packageName).append('\"'); sb.append(", \"fields\"=").append(fields); sb.append(", \"fieldDoc\"=").append(fieldDoc); sb.append(", \"imports\"=").append(imports); sb.append('}'); return sb.toString(); }}import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * 数据库映射 */public class EntityModel extends ClassModel { /** * 数据库名称 */ private String tableName; /** * 数据库中的Id字段名称 */ private List&lt;String&gt; idColumnNames = new ArrayList&lt;&gt;(); /** * 类属性名对应数据库字段映射 * key: class 属性名称 * value：数据库字段名 */ private Map&lt;String, String&gt; fieldSqlName = new HashMap&lt;&gt;(); /** * 添加class 属性映射和 数据库 字段映射 * * @param fieldName * @param sqlName */ public void addfieldSqlName(String fieldName, String sqlName) { if (!fieldSqlName.containsKey(fieldName)) { fieldSqlName.put(fieldName, sqlName); } } /** * 添加id字段名 * * @param idColumnName */ public void addIdColumnName(String idColumnName) { idColumnNames.add(idColumnName); } public String getTableName() { return tableName; } public void setTableName(String tableName) { this.tableName = tableName; } public Map&lt;String, String&gt; getFieldSqlName() { return fieldSqlName; } public void setFieldSqlName(Map&lt;String, String&gt; fieldSqlName) { this.fieldSqlName = fieldSqlName; } public List&lt;String&gt; getIdColumnNames() { return idColumnNames; } public void setIdColumnNames(List&lt;String&gt; idColumnNames) { this.idColumnNames = idColumnNames; }}</pre><p>在这里将从数据库中得到的数据都组装好，就可以使用freemarker来生成Java文件的内容了。下面是代码：</p><pre>/** * 根据建表语句组装EntityModel * * @param createTableSql * @return */EntityModel makeModelBySql(String createTableSql) { Formatter formatter = new Formatter(); EntityModel model = new EntityModel(); String tableComment = SqlUtils.getTableComment(createTableSql); String tableName = SqlUtils.getTableName(createTableSql); String id = SqlUtils.getId(createTableSql); model.addIdColumnName(id); model.setClassName(NameConvert.entityName(tableName)); model.setTableName(tableName); //注释是null的时候用数据库表名作为注释 model.setClassDoc(tableComment == null ? tableName : tableComment); List&lt;String&gt; line = SqlUtils.getColumnSqls(createTableSql); for (String oneLine : line) { String columnName = SqlUtils.getByPattern(oneLine, "`(.*)`", 1); String comment = SqlUtils.getByPattern(oneLine, "COMMENT '(.*)'", 1); String columnType = SqlUtils.getByPattern(oneLine, "`" + columnName + "` ([A-Za-z]*)", 1); String fieldName = NameConvert.fieldName(columnName); Class fieldClass = columnFieldTypeMapping.getFieldType(columnType); if (fieldClass == null) { formatter.format("table:%s columnName:%s sql类型:%s 没有映射类型", tableName, columnName, columnType); throw new UnsupportedOperationException(formatter.toString()); } model.addfield(fieldName, fieldClass); //字段注释是null的时候用数据库字段名作为注释 model.addfieldDoc(fieldName, comment == null ? columnName : comment); model.addfieldSqlName(fieldName, columnName); model.addImport(fieldClass); } return model;}</pre><p>这样一个我们需要的参数就组装好了。现在开始编写freemarker用的代码。</p><p><strong>freemarker工具类</strong></p><p>用来加载freemarker模板和处理模板中的参数。<strong>FreeMarkerUtils.java</strong>,代码如下：</p><pre>import freemarker.cache.StringTemplateLoader;import freemarker.template.Configuration;import freemarker.template.DefaultObjectWrapper;import freemarker.template.Template;import java.io.StringWriter;import java.io.Writer;import java.util.Locale;import java.util.Scanner;public class FreeMarkerUtils { /** * freemarker工具， * * @param subjectParams * @param templetPath * @return * @throws Exception */ public static String getJavaClass(Object subjectParams, String templetPath) throws Exception { StringTemplateLoader loader = new StringTemplateLoader(); Scanner scanner = new Scanner(Thread.currentThread().getContextClassLoader().getResourceAsStream(templetPath)); StringBuilder builder = new StringBuilder(); while (scanner.hasNext()) { builder.append(scanner.nextLine()).append("\n"); } String name = System.currentTimeMillis() + ""; loader.putTemplate(name, builder.toString()); //第一步：实例化Freemarker的配置类 Configuration conf = new Configuration(); conf.setObjectWrapper(new DefaultObjectWrapper()); conf.setLocale(Locale.CHINA); conf.setDefaultEncoding("utf-8"); conf.setTemplateLoader(loader); //处理空值为空字符串 conf.setClassicCompatible(true); Template template = conf.getTemplate(name); Writer out = new StringWriter(2048); template.process(subjectParams, out); String javaClass = out.toString(); return javaClass; }}</pre><p>现在有了工具类之后，还不能立即开始生成java文件，因为还要继续设置java的package和生成文件的路径，这时候我们可以修改之前写的<strong>config.xml</strong></p><p><strong>修改config.xml</strong></p><pre>&lt;xml&gt; &lt;jdbc.url&gt;&lt;/jdbc.url&gt; &lt;jdbc.username&gt;&lt;/jdbc.username&gt; &lt;jdbc.password&gt;&lt;/jdbc.password&gt; &lt;basePath&gt;/home/hjx/work/demo/src/main/java&lt;/basePath&gt; &lt;entityPackage&gt;top.hejiaxuan.demo.entity&lt;/entityPackage&gt;&lt;/xml&gt;</pre><p>这里添加了两个参数：<strong>basePath</strong>和<strong>entityPackage</strong>。一个是要生成java的文件的路径，一个是java文件的包名。</p><p>然后我们再写一个写出文件的工具类<strong>FileUtils.java</strong></p><p><strong>编写FileUtils.java</strong></p><pre>import java.io.*;public class FileUtils { /** * 写入文件 * * @param path 文件路径 * @param content 文件内容 */ public static void write(String path, String content) { File file = new File(path); File parentFile = file.getParentFile(); try { if (!parentFile.exists()) { parentFile.mkdirs(); } if (!file.exists()) { file.createNewFile(); } FileWriter fileWriter = new FileWriter(file); fileWriter.write(content); fileWriter.close(); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }}</pre><p>这样就万事具备，就差生成文件啦。下面就开始啦～～～</p><p><strong>开始生成java文件</strong></p><p>在生成文件前，我们还需要把<strong>basePath</strong>，<strong>entityPackage</strong>从配置文件里取出来，这一步我就不写了～～</p><pre>static final String DOT = ".";static final String FILE_TYPE = ".java";static final String ENTITY_TEMPLET_PATH = "EntityTemp.ftl";/** * 用于生成一个类文件 * * @param entityModel * @return */boolean makeOneClass(EntityModel entityModel) { entityModel.setPackageName(entityPackage); String filePath = basePath + "/" + entityPackage.replace(DOT, "/") + "/" + entityModel.getClassName() + FILE_TYPE; try { String javaClassString = FreeMarkerUtils.getJavaClass(entityModel, ENTITY_TEMPLET_PATH); FileUtils.write(filePath, javaClassString); return true; } catch (Exception e) { e.printStackTrace(); } return false;}</pre><p>好啦～～～大功告成。</p><p><strong>额～～～</strong></p><p>好像少点啥～～～</p><p>模板文件没有放出来～～～</p><p>编写<strong>EntityTemp.ftl</strong></p><pre>package ${packageName};&lt;#--导入的包--&gt;&lt;#list imports as import&gt;import ${import.name};&lt;/#list&gt;&lt;#--类名--&gt;&lt;#if classDoc?length gt 0&gt;/** * ${classDoc} * @author hejiaxuan */&lt;/#if&gt;public class ${className} {&lt;#--属性名称--&gt;&lt;#list fields?keys as key&gt; &lt;#assign fieldDocStr = fieldDoc[key]&gt; &lt;#if fieldDocStr?length gt 0&gt; /**${fieldDocStr}*/ &lt;/#if&gt; &lt;#if idColumnNames?seq_contains(fieldSqlName[key])&gt; &lt;/#if&gt; private ${fields[key].simpleName} ${key};&lt;/#list&gt;&lt;#list fields?keys as key&gt; &lt;#assign fieldClass = fields[key].simpleName&gt;&lt;#--setter--&gt; public void set${key?cap_first}(${fieldClass} ${key}) { this.${key} = ${key}; }&lt;#--getter--&gt; public ${fieldClass} &lt;#if fieldClass="boolean"&gt;is&lt;#else&gt;get&lt;/#if&gt;${key?cap_first}() { return this.${key}; }&lt;/#list&gt; @Override public String toString() { final StringBuilder sb = new StringBuilder("[");&lt;#list fields?keys as key&gt; sb.append("${key}:").append(${key}).append("; ");&lt;/#list&gt; sb.append("]"); return sb.toString(); }}</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'一个','java','数据库'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>