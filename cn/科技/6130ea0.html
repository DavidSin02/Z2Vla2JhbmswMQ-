<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何增强Linux内核中的访问控制安全 | 极客快訊</title><meta property="og:title" content="如何增强Linux内核中的访问控制安全 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/4803f61d402c4c5eb125f3c52460a705"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6130ea0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6130ea0.html><meta property="article:published_time" content="2020-10-29T21:05:53+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:53+08:00"><meta name=Keywords content><meta name=description content="如何增强Linux内核中的访问控制安全"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6130ea0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何增强Linux内核中的访问控制安全</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>背景</strong></h1><p>前段时间，我们的项目组在帮客户解决一些操作系统安全领域的问题，涉及到windows，Linux，macOS三大操作系统平台。无论什么操作系统，本质上都是一个软件，任何软件在一开始设计的时候，都不能百分之百的满足人们的需求，所以操作系统也是一样，为了尽可能的满足人们需求，不得不提供一些供人们定制操作系统的机制。当然除了官方提供的一些机制，也有一些黑魔法，这些黑魔法不被推荐使用，但是有时候面对具体的业务场景，可以作为一个参考的思路。</p><h1><strong>Linux中常见的拦截过滤</strong></h1><p>本文着重介绍Linux平台上常见的拦截：</p><ol><li>用户态动态库拦截。</li><li>内核态系统调用拦截。</li><li>堆栈式文件系统拦截。</li><li>inline hook拦截。</li><li>LSM(Linux Security Modules)</li></ol><h1><strong>动态库劫持</strong></h1><p>Linux上的动态库劫持主要是基于LD_ PRELOAD环境变量，这个环境变量的主要作用是改变动态库的加载顺序，让用户有选择的载入不同动态库中的相同函数。但是使用不当就会引起严重的安全问题，我们可以通过它在主程序和动态连接库中加载别的动态函数，这就给我们提供了一个机会，向别人的程序注入恶意的代码。</p><p>假设有以下用户名密码验证的函数：</p><pre>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char **argv){char passwd[] = "password";if (argc &lt; 2) {printf("Invalid argc!\n");return;}if (!strcmp(passwd, argv[1])) {printf("Correct Password!\n");return;}printf("Invalid Password!\n");}</pre><p>我们再写一段hookStrcmp的程序，让这个比较永远正确。</p><pre>#include &lt;stdio.h&gt;int strcmp(const char *s1, const char *s2){/* 永远返回0，表示两个字符串相等 */return 0;}</pre><p>依次执行以下命令，就会使我们的hook程序先执行。</p><pre>gcc -Wall -fPIC -shared -o hookStrcmp.so hookStrcmp.cexport LD_PRELOAD=”./hookStrcmp.so”</pre><p>结果会发现，我们自己写的strcmp函数优先被调用了。这是一个最简单的劫持 ，但是如果劫持了类似于geteuid/getuid/getgid，让其返回0，就相当于暴露了root权限。所以为了安全起见，一般将LD_ PRELOAD环境变量禁用掉。</p><h1><strong>Linux系统调用劫持</strong></h1><p>最近发现在4.4.0的内核中有513多个系统调用(很多都没用过)，系统调用劫持的目的是改变系统中原有的系统调用，用我们自己的程序替换原有的系统调用。Linux内核中所有的系统调用都是放在一个叫做sys_ call _table的内核数组中，数组的值就表示这个系统调用服务程序的入口地址。整个系统调用的流程如下：</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4803f61d402c4c5eb125f3c52460a705><p class=pgc-img-caption></p></div><p>当用户态发起一个系统调用时，会通过80软中断进入到syscall hander，进而进入全局的系统调用表sys_ call _table去查找具体的系统调用，那么如果我们将这个数组中的地址改成我们自己的程序地址，就可以实现系统调用劫持。但是内核为了安全，对这种操作做了一些限制：</p><ol><li>sys_ call _table的符号没有导出，不能直接获取。</li><li>sys_ call _table所在的内存页是只读属性的，无法直接进行修改。</li></ol><p>对于以上两个问题，解决方案如下（方法不止一种）：</p><ol><li>获取sys<em> call </em>table的地址 ：grep sys _ call _table /boot/System.map-uname -r</li><li>控制页表只读属性是由CR0寄存器的WP位控制的，只要将这个位清零就可以对只读页表进行修改。</li></ol><pre>/* make the page writable */int make_rw(unsigned long address){unsigned int level;pte_t *pte = lookup_address(address, &amp;level);//查找虚拟地址所在的页表地址pte-&gt;pte |= _PAGE_RW;//设置页表读写属性return 0;}/* make the page write protected */int make_ro(unsigned long address){unsigned int level;pte_t *pte = lookup_address(address, &amp;level);pte-&gt;pte &amp;= ~_PAGE_RW;//设置只读属性return 0;}</pre><p><strong>开始替换系统调用</strong></p><p>本文实现的是对 ls这个命令对应的系统调用，系统调用号是 _ NR _getdents。</p><pre>static int syscall_init_module(void){orig_getdents = sys_call_table[__NR_getdents];make_rw((unsigned long)sys_call_table); //修改页属性sys_call_table[__NR_getdents] = (unsigned long *)hacked_getdents; //设置新的系统调用地址make_ro((unsigned long)sys_call_table);return 0;}</pre><p><strong>恢复原状</strong></p><pre>static void syscall_cleanup_module(void){printk(KERN_ALERT "Module syscall unloaded.\n");make_rw((unsigned long)sys_call_table);sys_call_table[__NR_getdents] = (unsigned long *)orig_getdents;make_ro((unsigned long)sys_call_table);}</pre><p>使用Makefile编译，insmod插入内核模块后，再执行ls时，就会进入到我们的系统调用，我们可以在hook代码中删掉某些文件，ls就不会显示这些文件，但是这些文件还是存在的。</p><h1><strong>堆栈式文件系统</strong></h1><p>Linux通过vfs虚拟文件系统来统一抽象具体的磁盘文件系统，从上到下的IO栈形成了一个堆栈式。通过对内核源码的分析，以一次读操作为例，从上到下所执行的流程如下：</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0009b55506774c3889852a0b9941be96><p class=pgc-img-caption></p></div><p>内核中采用了很多c语言形式的面向对象，也就是函数指针的形式，例如read是vfs提供用户的接口，具体底下调用的是ext2的read操作。我们只要实现VFS提供的各种接口，就可以实现一个堆栈式文件系统。Linux内核中已经集成了一些堆栈式文件系统，例如Ubuntu在安装时会提醒你是否需要加密home目录，其实就是一个堆栈式的加密文件系统（eCryptfs），原理如下：</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0acc8b09d5b3414d84195f9c461f5b2f><p class=pgc-img-caption></p></div><p>实现了一个堆栈式文件系统，相当于所有的读写操作都会进入到我们的文件系统，可以拿到所有的数据，就可以进行做一些拦截过滤。</p><p>以下是我实现的一个最简单的堆栈式文件系统，实现了最简单的打开、读写文件，麻雀虽小但五脏俱全。</p><p>https://github.com/wangzhangjun/wzjfs</p><p><strong>inline hook</strong></p><p>我们知道内核中的函数不可能把所有功能都在这个函数中全部实现，它必定要调用它的下层函数。如果这个下层函数可以得到我们想要的过滤信息内容，就可以把下层函数在上层函数中的offset替换成新的函数的offset，这样上层函数调用下层函数时，就会跳到新的函数中，在新的函数中做过滤和劫持内容的工作。所以从原理上来说，inline hook可以想hook哪里就hook哪里。</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bb86371eb13a41c9abdf07a63af7bf2b><p class=pgc-img-caption></p></div><p><strong>inline hook 有两个重要的问题：</strong></p><ol><li>如何定位hook点。</li><li>如何注入hook函数入口。</li></ol><p><strong>对于第一个问题:</strong></p><p>需要有一点的内核源码经验，比如说对于read操作，源码如下：</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fad0ebc8dddb4329883cd5cfd660ca7b><p class=pgc-img-caption></p></div><p>在这里当发起read系统调用后，就会进入到sys<em> read,在sys</em> read中会调用vfs<em> read函数，在vfs</em> read的参数中正好有我们需要过滤的信息，那么就可以把vfs_ read当做一个hook点。</p><p><strong>对于第二个问题:</strong></p><p>如何Hook？这里介绍两种方式：</p><p><strong>第一种方式：</strong>直接进行二进制替换，将call指令的操作数替换为hook函数的地址。</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c44ee124cd847ac9fe63f3f2d10e02f><p class=pgc-img-caption></p></div><p><strong>第二种方式：</strong>Linux内核提供的kprobes机制。</p><p>其原理是在hook点注入int 3(x86)的机器码，让cpu运行到这里的时候会触发sig<em> trap信号，然后将用户自定义的hook函数注入到sig</em> trap的回调函数中，达到触发hook函数的目的。这个其实也是调试器的原理。</p><h1><strong>LSM</strong></h1><p>LSM是Linux Secrity Module的简称，即linux安全模块。是一种通用的Linux安全框架，具有效率高，简单易用等特点。原理如下：</p><div class=pgc-img><img alt=如何增强Linux内核中的访问控制安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/598c84cbbfc34b5c926dd083fe986d4a><p class=pgc-img-caption></p></div><p>LSM在内核中做了以下工作：</p><ol><li>在特定的内核数据结构中加入安全域。</li><li>在内核源代码中不同的关键点插入对安全钩子函数的调用。</li><li>加入一个通用的安全系统调用。</li><li>提供了函数允许内核模块注册为安全模块或者注销。</li><li>将capabilities逻辑的大部分移植为一个可选的安全模块,具有可扩展性。</li></ol><h1><strong>适用场景</strong></h1><p>对于以上几种Hook方式，有其不同的应用场景。</p><ol><li>动态库劫持不太完全，劫持的信息有可能满足不了我们的需求，还有可能别人在你之前劫持了，一旦禁用LD_ PRELOAD就失效了。</li><li>系统调用劫持，劫持的信息有可能满足不了我们的需求，例如不能获取struct file结构体，不能获取文件的绝对路径等。</li><li>堆栈式文件系统，依赖于Mount,可能需要重启系统。</li><li>inline hook，灵活性高，随意Hook，即时生效无需重启，但是在不同内核版本之间通用性差，一旦某些函数发生了变化，Hook失效。</li><li>LSM，在早期的内核中，只能允许一个LSM内核模块加载，例如加载了SELinux，就不能加载其他的LSM模块，在最新的内核版本中不存在这个问题。</li></ol><h1><strong>总结</strong></h1><p>篇幅有限，本文只是介绍了Linux上的拦截技术，后续有机会可以一起探讨windows和macOS上的拦截技术。事实上类似的审计HOOK放到任何一个系统中都是刚需，不只是kernel，我们可以看到越来越多的vm和runtime甚至包括很多web组件、前端应用都提供了更灵活的hook方式，这是透明化和实时性两个安全大趋势下最常见的解决方案。</p><hr><p>文/ThoughtWorks 王张军</p><p>原文：https://insights.thoughtworks.cn/access-control-security-of-linux/</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'增强','Linux','内核'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>