<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>降维算法：主成分分析 VS 自动编码器 | 极客快訊</title><meta property="og:title" content="降维算法：主成分分析 VS 自动编码器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fad0c33b5c20404f958e51a1d9766f1f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62c1831.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62c1831.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62c1831.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62c1831.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62c1831.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62c1831.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62c1831.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62c1831.html><meta property="article:published_time" content="2020-10-29T21:05:25+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:25+08:00"><meta name=Keywords content><meta name=description content="降维算法：主成分分析 VS 自动编码器"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/62c1831.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>降维算法：主成分分析 VS 自动编码器</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fad0c33b5c20404f958e51a1d9766f1f><p class=pgc-img-caption></p></div><p><br></p><p>降维是一种减少特征空间维度以获得稳定的、统计上可靠的机器学习模型的技术。降维主要有两种途径：特征选择和特征变换。</p><p>特征选择通过选择重要程度最高的若干特征，移除共性的或者重要程度较低的特征。</p><p>特征转换也称为特征提取，试图将高维数据投影到低维空间。一些特征转换技术有主成分分析（PCA）、矩阵分解、自动编码器（Autoencoders）、t-Sne、UMAP等。</p><p>本文主要介绍了主成分分析以及自动编码器两种方法，具体分析两者的优缺点，并且通过一个生动的示例进行详解。</p><h1 class=pgc-h-arrow-right>主成分分析</h1><p>主成分分析是一种无监督技术，将原始数据投影到若干高方差方向（维度）。这些高方差方向彼此正交，因此投影数据的相关性非常低或几乎接近于 0。这些特征转换是线性的，具体方法是：</p><p>步骤一：计算相关矩阵数据，相关矩阵的大小为 n*n。</p><p>步骤二：计算矩阵的特征向量和特征值。</p><p>步骤三：选取特征值较高的 k 个特征向量作为主方向。</p><p>步骤四：将原始数据集投影到这 k 个特征向量方向，得到 k 维数据，其中 k≤n。</p><h1 class=pgc-h-arrow-right>自动编码器</h1><p>自动编码器是一种无监督的人工神经网络，它将数据压缩到较低的维数，然后重新构造输入。自动编码器通过消除重要特征上的噪声和冗余，找到数据在较低维度的表征。它基于编解码结构，编码器将高维数据编码到低维，解码器接收低维数据并尝试重建原始高维数据。</p><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5e59649273e741318eb6d7c11f71e0e5><p class=pgc-img-caption></p></div><p>自动编码器基本结构示意图</p><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/09d443bc380d4d24b9c6285a686098d8><p class=pgc-img-caption></p></div><p>深层自动编码器结构示意图</p><p>上图中， X 是输入数据，z 是 X 在低维空间的数据表征，X' 是重构得到的数据。根据激活函数的不同，数据从高纬度到低纬度的映射可以是线性的，也可以是非线性的。</p><h1 class=pgc-h-arrow-right>性能对比：主成分分析 VS 自动编码器</h1><p>1. PCA 只能做线性变换；而自动编码器既可以做线性变换，也可以做非线性变换。</p><p>1. 由于既有的 PCA 算法是十分成熟的，所以计算很快；而自动编码器需要通过梯度下降算法进行训练，所以需要花费更长的时间。</p><p>1. PCA 将数据投影到若干正交的方向；而自动编码器降维后数据维度并不一定是正交的。</p><p>1. PCA 是输入空间向最大变化方向的简单线性变换；而自动编码器是一种更复杂的技术，可以对相对复杂的非线性关系进行建模。</p><p>1. 依据经验来看，PCA 适用于数据量较小的场景；而自动编码器可以用于复杂的大型数据集。</p><p>1. PCA 唯一的超参数是正交向量的数量；而自动编码器的超参数则是神经网络的结构参数。</p><p>1. 单层的并且采用线性函数作为激活函数的自动编码器与 PCA 性能一致；但是多层的以非线性函数作为激活函数的自动编码器（深度自动编码器）能够具有很好的性能，虽然可能会存在过拟合，但是可以通过正则化等方式进行解决。</p><h1 class=pgc-h-arrow-right>降维示例：图像数据</h1><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/071b9219ba294c299eb0318f3c3a59b4><p class=pgc-img-caption></p></div><p>示例图片</p><p>该示例图片的数据维度为 360*460。我们将尝试通过 PCA 和自动编码器将数据规模降低为原有的 10%。</p><h1 class=pgc-h-arrow-right>PCA 方法</h1><pre><code>pct_reduction = 0.10reduced_pixel  = int( pct_reduction* original_dimensions[1])#Applying PCApca = PCA(n_components=reduced_pixel)pca.fit(image_matrix)#Transforming the input matrixX_transformed = pca.transform(image_matrix)print("Original Input dimesnions {}".format(original_dimensions))print("New Reduced dimensions {}".format(X_transformed.shape))</code></pre><p>输出如下：</p><pre><code>Original Input dimesnions (360, 460)New Reduced dimensions (360, 46)</code></pre><p>检查各维度的相关性：</p><pre><code>df_pca = pd.DataFrame(data = X_transformed,columns=list(range(X_transformed.shape[1])))figure = plt.figure(figsize=(10,6))corrMatrix = df_pca.corr()sns.heatmap(corrMatrix, annot=False)plt.show()</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d86462b1a63f490db066340f6e489a82><p class=pgc-img-caption></p></div><p>PCA降维后各维度相关性</p><p>从上图可以看出，PCA 降维后各个维度都是不相关的，也就是完全正交。</p><p>接下来，我们通过降维后的数据来重构原始数据：</p><pre><code>reconstructed_matrix = pca.inverse_transform(X_transformed)reconstructed_image_pca = Image.fromarray(np.uint8(reconstructed_matrix))plt.figure(figsize=(8,12))plt.imshow(reconstructed_image_pca,cmap = plt.cm.gray)</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fb7632df3f294e3182afd10da6c5633e><p class=pgc-img-caption></p></div><p>PCA 图像重构</p><p>计算重构后图像的均方根误差：</p><pre><code>def my_rmse(np_arr1,np_arr2):    dim = np_arr1.shape    tot_loss = 0    for i in range(dim[0]):        for j in range(dim[1]):            tot_loss += math.pow((np_arr1[i,j] - np_arr2[i,j]),2)    return round(math.sqrt(tot_loss/(dim[0]* dim[1]*1.0)),2)error_pca = my_rmse(image_matrix,reconstructed_matrix)</code></pre><p>计算可知，均方根误差为11.84。</p><h1 class=pgc-h-arrow-right>单层的以线性函数作为激活函数的自动编码器</h1><pre><code># Standarise the DataX_org = image_matrix.copy()sc = StandardScaler()X = sc.fit_transform(X_org)# this is the size of our encoded representationsencoding_dim = reduced_pixel # this is our input placeholderinput_img = Input(shape=(img.width,))# "encoded" is the encoded representation of the inputencoded = Dense(encoding_dim, activation='linear')(input_img)# "decoded" is the lossy reconstruction of the inputdecoded = Dense(img.width, activation=None)(encoded)# this model maps an input to its reconstructionautoencoder = Model(input_img, decoded)#Encoderencoder = Model(input_img, encoded)# create a placeholder for an encoded (32-dimensional) inputencoded_input = Input(shape=(encoding_dim,))# retrieve the last layer of the autoencoder modeldecoder_layer = autoencoder.layers[-1]# create the decoder modeldecoder = Model(encoded_input, decoder_layer(encoded_input))autoencoder.compile(optimizer='adadelta', loss='mean_squared_error')autoencoder.fit(X, X,                epochs=500,                batch_size=16,                shuffle=True)encoded_imgs = encoder.predict(X)decoded_imgs = decoder.predict(encoded_imgs)</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f27ca1e7143482fbd5e2ca4cac070e3><p class=pgc-img-caption></p></div><p>自动编码器结构</p><p>检查各维度的相关性：</p><pre><code>df_ae = pd.DataFrame(data = encoded_imgs,columns=list(range(encoded_imgs.shape[1])))figure = plt.figure(figsize=(10,6))corrMatrix = df_ae.corr()sns.heatmap(corrMatrix, annot=False)plt.show()</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7b28bf03c8a249aca8ff81b4c28f890f><p class=pgc-img-caption></p></div><p>自动编码器降维后各维度相关性</p><p>相关矩阵表明新的变换特征具有一定的相关性。皮尔逊相关系数与0有很大的偏差。</p><p>接下来，我们通过降维后的数据来重构原始数据：</p><pre><code>X_decoded_ae = sc.inverse_transform(decoded_imgs)reconstructed_image_ae = Image.fromarray(np.uint8(X_decoded_ae))plt.figure(figsize=(8,12))plt.imshow(reconstructed_image_ae,cmap = plt.cm.gray)</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72b4f8886066418a807ed8ecde1f05c7><p class=pgc-img-caption></p></div><p>自动编码器重构后的图像</p><p>计算重构后图像的均方根误差：</p><pre><code>error_ae = my_rmse(image_matrix,X_decoded_ae)</code></pre><p>计算可知，均方根误差为12.15。单层线性激活的自动编码器和 PCA 性能几乎一致。</p><h1 class=pgc-h-arrow-right>三层的以非线性函数为激活函数的自动编码器</h1><pre><code>input_img = Input(shape=(img.width,))encoded1 = Dense(128, activation='relu')(input_img)encoded2 = Dense(reduced_pixel, activation='relu')(encoded1)decoded1 = Dense(128, activation='relu')(encoded2)decoded2 = Dense(img.width, activation=None)(decoded1)autoencoder = Model(input_img, decoded2)autoencoder.compile(optimizer='adadelta', loss='mean_squared_error')autoencoder.fit(X,X,                epochs=500,                batch_size=16,                shuffle=True)# Encoderencoder = Model(input_img, encoded2)# Decoderdecoder = Model(input_img, decoded2)encoded_imgs = encoder.predict(X)decoded_imgs = decoder.predict(X)</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bcc9045d6fc1489f9451cf93824c51b8><p class=pgc-img-caption></p></div><p>自动编码器模型结构</p><p>图像重构：</p><pre><code>X_decoded_deep_ae = sc.inverse_transform(decoded_imgs)reconstructed_image_deep_ae = Image.fromarray(np.uint8(X_decoded_deep_ae))plt.figure(figsize=(8,12))plt.imshow(reconstructed_image_deep_ae,cmap = plt.cm.gray)</code></pre><div class=pgc-img><img alt="降维算法：主成分分析 VS 自动编码器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/56aa2acade7540b6ba5ead9e16303111><p class=pgc-img-caption></p></div><p><br></p><p>计算均方误差：</p><pre><code>error_dae = my_rmse(image_matrix,X_decoded_deep_ae)</code></pre><p>多层自动编码器的均方误差为 8.57，性能优于 PCA，提升了 28%。</p><p>具有非线性激活的附加层的自动编码器能够更好地捕获图像中的非线性特征。它能够比PCA更好地捕捉复杂的模式和像素值的突然变化。但是它需要花费相对较高的训练时间和资源。</p><h1 class=pgc-h-arrow-right>总结</h1><p>本文主要介绍了主成分分析以及自动编码器两种方法，具体分析两者的优缺点，并且通过一个生动的示例进行详解。</p><p>完整代码github： samread81/PCA-versus-AE</p><p>作者：Abhishek Mungoli</p><p>deephub翻译组：Oliver Lee</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'降维','VS','自动'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>