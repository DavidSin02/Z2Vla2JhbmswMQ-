<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java 集合Collection 子接口：List接口 set接口 queue 接口 | 极客快訊</title><meta property="og:title" content="java 集合Collection 子接口：List接口  set接口   queue 接口 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/c3e85753-f79f-45b8-b6a1-99263b2386a6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/62d69e2b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/62d69e2b.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="java 集合Collection 子接口：List接口  set接口   queue 接口"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/62d69e2b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java 集合Collection 子接口：List接口 set接口 queue 接口</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>本号用来发布软件编程相关知识，欢迎关注。</strong></h1><div class=pgc-img><img alt="java 集合Collection 子接口：List接口  set接口   queue 接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/c3e85753-f79f-45b8-b6a1-99263b2386a6><p class=pgc-img-caption></p></div><h1>概述</h1><p>所有集合的顶级接口Collection</p><ul><li>子接口:List接口 set接口 queue 接口</li><li>List接口：实现类有ArrayList linkedList stack vector</li><li>set接口：</li><li>HashSet 底层是使用HashMap(底层是数组加链表)</li><li>LinkedHashSet：保证数据有序</li><li>TreeSet:能排序</li><li>Queue接口：先进先出</li></ul><p>list和set是实现了collection接口的。Map不是collection的子接口或者实现类。Map是一个接口</p><h1>jdk1.8图</h1><h1>collection接口：</h1><div class=pgc-img><img alt="java 集合Collection 子接口：List接口  set接口   queue 接口" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c83f46c3c60344baa0d35520303ec187><p class=pgc-img-caption></p></div><h1>Map：</h1><div class=pgc-img><img alt="java 集合Collection 子接口：List接口  set接口   queue 接口" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/359faf22d7084da195db90cc2ef417e0><p class=pgc-img-caption></p></div><h1>List：</h1><p>可以允许重复的对象。</p><p>可以插入多个null元素。</p><p>是一个有序容器，保持了每个元素的插入顺序，输出的顺序就是插入的顺序。</p><p>List中提供索引的方式来添加元素和获取元素，由此可见List集合可是达到精确的存储和获取，</p><p>常用的实现类有 ArrayList、LinkedList 和 Vector。ArrayList 最为流行，它提供了使用索引的随意访问，而 LinkedList 则对于经常需要从 List 中添加或删除元素的场合更为合适。</p><h1>Set：</h1><p>不允许重复对象</p><p>只允许一个 null 元素</p><p>无序容器，你无法保证每个元素的存储顺序，TreeSet通过 Comparator 或者 Comparable 维护了一个排序顺序。</p><p>传入的参数都是对象，而Set只能一个一个的比较，显然效率和实用性是比不上List集合的</p><p>Set 接口最流行的几个实现类是 HashSet、LinkedHashSet 以及 TreeSet。最流行的是基于 HashMap 实现的 HashSet；TreeSet 还实现了 SortedSet 接口，因此 TreeSet 是一个根据其 compare() 和 compareTo() 的定义进行排序的有序容器。</p><h1>Map</h1><p>Map不是collection的子接口或者实现类。Map是一个接口。</p><p>Map 的 每个 Entry 都持有两个对象，也就是一个键一个值，Map 可能会持有相同的值对象但键对象必须是唯一的。</p><p>TreeMap 也通过 Comparator 或者 Comparable 维护了一个排序顺序。</p><p>Map 里你可以拥有随意个 null 值但最多只能有一个 null 键。</p><p>Map 接口最流行的几个实现类是 HashMap、LinkedHashMap、Hashtable 和 TreeMap.（HashMap、TreeMap最常用）</p><blockquote><p>人工智能教程：https://www.cbedai.net/gnailoug/</p></blockquote><h1>2.面试题：什么场景下使用list，set，map呢？优缺点</h1><ol><li>如果你经常会使用索引来对容器中的元素进行访问，那么 List 是你的正确的选择。如果你已经知道索引了的话，那么 List 的实现类比如 ArrayList 可以提供更快速的访问,如果经常添加删除元素的，那么肯定要选择LinkedList。</li><li>如果你想容器中的元素能够按照它们插入的次序进行有序存储，那么还是 List，因为 List 是一个有序容器，它按照插入顺序进行存储。</li><li>如果你想保证插入元素的唯一性，也就是你不想有重复值的出现，那么可以选择一个 Set 的实现类，比如 HashSet、LinkedHashSet 或者 TreeSet。所有 Set 的实现类都遵循了统一约束比如唯一性，而且还提供了额外的特性比如 TreeSet 还是一个 SortedSet，所有存储于 TreeSet 中的元素可以使用 Java 里的 Comparator 或者 Comparable 进行排序。LinkedHashSet 也按照元素的插入顺序对它们进行存储。</li><li>如果你以键和值的形式进行数据存储那么 Map 是你正确的选择。你可以根据你的后续需要从 Hashtable、HashMap、TreeMap 中进行选择。</li></ol><p>细说：</p><p>List 的实现类有 ArrayList，Vector 和 LinkedList：</p><p><strong>ArrayList：</strong> 底层使用数组来实现,可以自动扩容，初始容量默认是10，每一增加原有长度的一半，增删比较慢 查询速度快，线程不安全的一个列表</p><p><strong>LinkedList：</strong>增删快 查询慢 线程不安全，内存不连续</p><p>Vector是JDK1.0出现。底层使用数组实现，向量 ：默认容量是10，默认每次扩容是原来容量的一倍如果是写了增量，那么是原来容量加增量。直接子类是Stact，增删慢 查询快，Vector的方法都是同步方法，线程安全的集合。 .Enumeration 是JDK1.0出现。现在不常用。被iterator替代。Collention接口的父接口是Iterable，增强for循环本质上就是迭代器.</p><p>stack栈是vector的子类，先进后出。入栈/压栈:存数据，将数据从栈顶压到栈底。出栈/弹栈:取数据，将数据从栈底传到栈顶。</p><p>Queue(队列)：先进先出， 接口，父接口Collection</p><p>数组可以储存对象，也可以存储基本数据类型 Person[]</p><p>集合中不可以存放基本数据类型：Collection&lt;E> ：泛型，泛型的类型必须是引用数据类型</p><p>如果数据决定了查询和增删效率差不多，那么优先选择ArrayList还是LinkedList??</p><p>选择LinkedList。因为LinkedList是内存不连续的。ArrayList是内存连续的。</p><p>Set 散列集合的实现类有 HashSet 和 TreeSet；</p><p>HashSet：底层是由哈希表，线程不安全，默认的初始容量是16，HashSet指定初始容量，底层会保证结果一定是2的n次方的形式：10-->16 17 -->32</p><p>LinkedHashSet：是有序的集合(每一个桶之间的链表也有联系)，不会扩容</p><p>TreeSet：TreeSet 使用元素的自然顺序对元素进行排序，或者根据创建 set 时提供的 Comparator 进行排序。</p><p>Map 接口有三个实现类：Hashtable，HashMap，TreeMap，LinkedHashMap；</p><p>HashMap实现不同步，线程不安全。 HashTable线程安全 ， HashMap中的key-value都是存储在Entry中的。 HashMap可以存null键和null值，不保证元素的顺序恒久不变，通过hashCode()方法和equals方法保证键的唯一性</p><p>Hashtable：内部存储的键值对是无序的是按照哈希算法进行排序，与 HashMap 最大的区别就是线程安全。键或者值不能为 null，为 null 就会抛出空指针异常。</p><p>LinkedHashMap：有序的 Map 集合实现类，相当于一个栈，先 put 进去的最后出来，先进后出。</p><p>TreeMap：基于红黑树 (red-black tree) 数据结构实现，按 key 排序，默认的排序方式是升序。</p><div class=pgc-img><img alt="java 集合Collection 子接口：List接口  set接口   queue 接口" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/a6cdaea9-6bcd-4079-ac72-1c26619d3874><p class=pgc-img-caption></p></div><p>补充：</p><p>HashMap实际上是一个 HashMap 实例，HashMap底层是数组加链表，数组的每一个位置称之为桶，每一个桶上都是链表，存数据的时候，先计算是0-15哪个值，寻找对应的桶，在存放进桶的时候，要先和桶里面的数据进行对比，如果相等就舍弃，存放在链表的最前面，扩容后，会将原来的所有数据重新计算，重新存放的过程叫rehash,扩容的加载因子的0.75（太小频繁扩容，太大链表内容会过多，影响效率）,初始容量是16（太小：链表内容会过多，影响效率太大：浪费内存），每次扩容都会增加原来的一倍的数量，注意：，一个桶中存放10000个数据，其他桶中没有数据，那么会不会扩容，不会JDK1.8之后(链表长度超过8之后)会将桶中的链式栈结构扭转为二叉树结构，从而提升效率，）支持的；是无序的，不保证 set 元素的迭代顺序，不保证数据的位置(数据位置是可能发生改变的)</p><p>解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。</p><p>链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；</p><p>用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。</p><p>拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p><h1>2. Hashtable和HashMap的区别：</h1><p>a) 继承不同。 public class Hashtable extends Dictionary implements Map public class HashMap extends AbstractMap implements Map</p><p>b) HashMap线程不安全。 HashTable线程安全 。Hashtable中的方法是同步的，而HashMap中的方法是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p><p>c) Hashtable 中， key 和 value 都不允许出现 null 值。 在 HashMap 中， null 可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为 null 。当 get() 方法返回 null 值时，即可以表示 HashMap 中没有该键，也可以表示该键所对应的值为 null 。因此，在 HashMap 中不能由 get() 方法来判断 HashMap 中是否存在某个键， 而应该用 containsKey() 方法来判断。</p><p>d) 两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p><p>e) 哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p><p>f) Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。</p><p>HashTable中hash数组默认大小是11，增加的方式是old*2+1。</p><p>HashMap中hash数组的默认大小是16，而且一定是2的指数。</p><p>注： HashSet子类依靠hashCode()和equal()方法来区分重复元素。</p><p>HashSet内部使用Map保存数据，即将HashSet的数据作为Map的key值保存，这也是HashSet中元素不能重复的原因。而Map中保存key值的,会去判断当前Map中是否含有该Key对象，内部是先通过key的hashCode,确定有相同的hashCode之后，再通过equals方法判断是否相同。</p><h1>ConcurrentHashMap</h1><p>ConcurrentMap 并发映射：继承了Map接口，支持并发操作，并且保证并发操作过程中的安全性</p><p>ConcurrentHashMap 并发哈希映射：实现了Map接口，底层是基于数组+链表结构来存储，默认初始容量是16，默认加载因子是0.75，每次扩容默认增加一倍</p><p>异步式线程安全：采取的分桶/段锁机制 - 当有线程操作某个键值对的时候，会将这个键值对所在的桶整体锁起来，此时不影响其他桶的操作</p><p>在后续版本中，为了提高效率，在分桶锁的基础上，引入了读写锁：读锁：允许多个线程同时读，但是不允许线程写。写锁：只允许一个线程写， 但是不允许线程读</p><p>在CPU中，一旦引入了线程锁的问题，就会导致CPU的资源耗费比较严重，也因此在JDK1.8中，引入了无锁算法CAS（和内核相关的，必须计算机内核支持才能使用CAS） - Compare And Swap - 我认为V的值应该是A，如果是，那么将V的值更新为B，否则不修改并告诉V的值实际为多少 - 避免锁机制带来的CPU开销。先并发进程，在抢占进程，提高并发。</p><p>从JDK1.8开始，在桶的基础上引入了红黑树机制。当桶中的元素超过8个的时候，会将桶中的链表扭转成一棵红黑树；如果桶中的元素不足7个，则将红黑树再扭转回链表，树化的最小容量是64桶数量，>=64,才会启动红黑树，</p><blockquote><p>原文链接：https://blog.csdn.net/m0_37657725/article/details/98518585</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'接口','java','Collection'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>