<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试题：来，问你几个关于HashMap的问题？ | 极客快訊</title><meta property="og:title" content="面试题：来，问你几个关于HashMap的问题？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5f20ae3cdd6e48c48472055c9b03123d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/63e646bf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/63e646bf.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="面试题：来，问你几个关于HashMap的问题？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/63e646bf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试题：来，问你几个关于HashMap的问题？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre class=ql-align-right>作者：阿进的写字台 来源：https://www.cnblogs.com/homejim/p/10029796.html</pre><p class=ql-align-justify>1、HashMap在JAVA中的怎么工作的？</p><p class=ql-align-justify>基于Hash的原理。</p><p class=ql-align-justify>2、什么是哈希？</p><p class=ql-align-justify>最简单形式的 hash，是一种在对任何变量/对象的属性应用任何公式/算法后， 为其分配唯一代码的方法。</p><p class=ql-align-justify>一个真正的hash方法必须遵循下面的原则。</p><blockquote>哈希函数每次在相同或相等的对象上应用哈希函数时, 应每次返回相同的哈希码。换句话说, 两个相等的对象必须一致地生成相同的哈希码。</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>Java 中所有的对象都有 Hash 方法。</p><p class=ql-align-justify>Java中的所有对象都继承 Object 类中定义的 hashCode() 函数的默认实现。 此函数通常通过将对象的内部地址转换为整数来生成哈希码，从而为所有不同的对象生成不同的哈希码。</p><p class=ql-align-justify>3、你清楚HashMap 中的 Node 类的结构吗？</p><p class=ql-align-justify>Map的定义是： 将键映射到值的对象。</p><p class=ql-align-justify>因此，HashMap 中必须有一些机制来存储这个键值对。 答案是肯的。 HashMap 有一个内部类 Node，如下所示。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5f20ae3cdd6e48c48472055c9b03123d><p class=pgc-img-caption></p></div><p class=ql-align-justify>当然，Node 类具有存储为属性的键和值的映射。 key 已被标记为 final，另外还有两个字段：next 和 hash。</p><p class=ql-align-justify>在下面中， 我们将会理解这些属性的必须性。</p><p class=ql-align-justify>4、键值对在 HashMap中是如何存储的？</p><p class=ql-align-justify>键值对在 HashMap 中是以 Node 内部类的数组存放的，如下所示。</p><pre>transient Node&lt;K,V&gt;[] table;</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>哈希码计算出来之后， 会转换成该数组的下标， 在该下标中存储对应哈希码的键值对， 在此先不详细讲解hash碰撞的情况。</p><p class=ql-align-justify>该数组的长度始终是2的次幂， 通过以下的函数实现该过程。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d054c8c6bf784347b0d0519893544737><p class=pgc-img-caption></p></div><p class=ql-align-justify>其原理是将传入参数 (cap) 的低二进制全部变为1，最后加1即可获得对应的大于 cap 的 2 的次幂作为数组长度。</p><blockquote>为什么要使用2的次幂作为数组的容量呢？</blockquote><p class=ql-align-justify>在此有涉及到 HashMap 的 hash 函数及数组下标的计算， 键(key)所计算出来的哈希码有可能是大于数组的容量的，那怎么办？ 可以通过简单的求余运算来获得，但此方法效率太低。HashMap中通过以下的方法保证 hash 的值计算后都小于数组的容量。</p><pre>(n - 1) &amp; hash</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>这也正好解释了为什么需要2的次幂作为数组的容量。由于n是2的次幂，因此，n-1类似于一个低位掩码。通过与操作，高位的hash值全部归零，保证低位才有效 从而保证获得的值都小于n。</p><p class=ql-align-justify>同时，在下一次 resize() 操作时， 重新计算每个 Node 的数组下标将会因此变得很简单，具体的后文讲解。以默认的初始值16为例。</p><pre> 01010011 00100101 01010100 00100101&amp; 00000000 00000000 00000000 00001111---------------------------------- 00000000 00000000 00000000 00000101 //高位全部归零，只保留末四位 // 保证了计算出的值小于数组的长度 n</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>但是，使用了该功能之后，由于只取了低位，因此 hash 碰撞会也会相应的变得很严重。这时候就需要使用「扰动函数」。</p><pre> static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>该函数通过将哈希码的高16位的右移后与原哈希码进行异或而得到，以上面的例子为例。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b363f28919249a88f0da36000436085><p class=pgc-img-caption></p></div><p class=ql-align-justify>此方法保证了高16位不变， 低16位根据异或后的结果改变。计算后的数组下标将会从原先的5变为0。</p><p class=ql-align-justify>使用了 「扰动函数」 之后， hash 碰撞的概率将会下降。 有人专门做过类似的测试， 虽然使用该 「扰动函数」 并没有获得最大概率的避免 hash 碰撞，但考虑其计算性能和碰撞的概率， JDK 中使用了该方法，且只hash一次。</p><p class=ql-align-justify>5、哈希碰撞是如何处理的？</p><p class=ql-align-justify>在理想的情况下， 哈希函数将每一个 key 都映射到一个唯一的 bucket， 然而， 这是不可能的。哪怕是设计在良好的哈希函数，也会产生哈希冲突。</p><p class=ql-align-justify>前人研究了很多哈希冲突的解决方法，在维基百科中，总结出了四大类。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cf35f9d113c42e8b7f9598321520fac><p class=pgc-img-caption></p></div><p class=ql-align-justify>在 Java 的 HashMap 中， 采用了第一种 Separate chaining 方法(大多数翻译为拉链法)+链表和红黑树来解决冲突。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00bbf8ea490247a094fc882dea1a8304><p class=pgc-img-caption></p></div><p class=ql-align-justify>在 HashMap 中， 哈希碰撞之后会通过 Node 类内部的成员变量 Node&lt;K,V> next; 来形成一个链表(节点小于8)或红黑树（节点大于8， 在小于6时会从新转换为链表）， 从而达到解决冲突的目的。</p><pre>static final int TREEIFY_THRESHOLD = 8;static final int UNTREEIFY_THRESHOLD = 6;</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>6、HashMap 是如何初始化的？</p><pre> public HashMap(); public HashMap(int initialCapacity); public HashMap(Map&lt;? extends K, ? extends V&gt; m); public HashMap(int initialCapacity, float loadFactor); </pre><p class=ql-align-justify><br></p><p class=ql-align-justify>HashMap 中有四个构造函数， 大多是初始化容量和负载因子的操作。以 public HashMap(int initialCapacity, float loadFactor) 为例。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ceeb60e0b32141b4be3d22165c45643f><p class=pgc-img-caption></p></div><p class=ql-align-justify>通过该函数进行了容量和负载因子的初始化，如果是调用的其他的构造函数， 则相应的负载因子和容量会使用默认值（默认负载因子=0.75， 默认容量=16）。在此时， 还没有进行存储容器 table 的初始化， 该初始化要延迟到第一次使用时进行。</p><p class=ql-align-justify>7、HashMap 中哈希表是如何动态扩容的？</p><p class=ql-align-justify>所谓的哈希表， 指的就是下面这个类型为内部类Node的 table 变量。</p><pre>transient Node&lt;K,V&gt;[] table;</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>作为数组， 其在初始化时就需要指定长度。在实际使用过程中， 我们存储的数量可能会大于该长度，因此 HashMap 中定义了一个阈值参数(threshold)， 在存储的容量达到指定的阈值时， 需要进行扩容。</p><blockquote>我个人认为初始化也是动态扩容的一种， 只不过其扩容是容量从 0 扩展到构造函数中的数值（默认16）。 而且不需要进行元素的重hash.</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>7.1 扩容发生的条件</p><p class=ql-align-justify>初始化的话只要数值为空或者数组长度为 0 就会进行。 而扩容是在元素的数量大于阈值（threshold）时就会触发。</p><pre>threshold = loadFactor * capacity</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>比如 HashMap 中默认的 loadFactor=0.75, capacity=16, 则。</p><pre>threshold = loadFactor * capacity = 0.75 * 16 = 12</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>那么在元素数量大于 12 时， 就会进行扩容。 扩容后的 capacity 和 threshold 也会随之而改变。</p><p class=ql-align-justify>负载因子影响触发的阈值，因此，它的值较小的时候，HashMap 中的 hash 碰撞就很少， 此时存取的性能都很高，对应的缺点是需要较多的内存；而它的值较大时，HashMap 中的 hash 碰撞就很多，此时存取的性能相对较低，对应优点是需要较少的内存；不建议更改该默认值，如果要更改，建议进行相应的测试之后确定。</p><p class=ql-align-justify>7.2 再谈容量为2的整数次幂和数组索引计算</p><p class=ql-align-justify>前面说过了数组的容量为 2 的整次幂， 同时， 数组的下标通过下面的代码进行计算。</p><pre>index = (table.length - 1) &amp; hash</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>该方法除了可以很快的计算出数组的索引之外， 在扩容之后， 进行重 hash 时也会很巧妙的就可以算出新的 hash 值。 由于数组扩容之后， 容量是现在的 2 倍， 扩容之后 n-1 的有效位会比原来多一位， 而多的这一位与原容量二进制在同一个位置。 示例。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d8a608e94384b769d404592db5fe119><p class=pgc-img-caption></p></div><p class=ql-align-justify>这样就可以很快的计算出新的索引啦。</p><p class=ql-align-justify>7.3 步骤</p><ul><li class=ql-align-justify>先判断是初始化还是扩容， 两者在计算newCap和newThr时会不一样</li><li class=ql-align-justify>计算扩容后的容量，临界值。</li><li class=ql-align-justify>将hashMap的临界值修改为扩容后的临界值</li><li class=ql-align-justify>根据扩容后的容量新建数组，然后将hashMap的table的引用指向新数组。</li><li class=ql-align-justify>将旧数组的元素复制到table中。在该过程中， 涉及到几种情况， 需要分开进行处理（只存有一个元素， 一般链表， 红黑树）</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>具体的看代码吧。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8b56aa6d20fb48bfa68d91e2809fa87b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b0e46365359f4fc9a657651901213d64><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/61d2197094ec42469cd19a876ba70603><p class=pgc-img-caption></p></div><p class=ql-align-justify>7.4 注意事项</p><p class=ql-align-justify>虽然 HashMap 设计的非常优秀， 但是应该尽可能少的避免 resize(), 该过程会很耗费时间。</p><p class=ql-align-justify>同时， 由于 hashmap 不能自动的缩小容量 因此，如果你的 hashmap 容量很大，但执行了很多 remove操作时，容量并不会减少。如果你觉得需要减少容量，请重新创建一个 hashmap。</p><p class=ql-align-justify>8、HashMap.put() 函数内部是如何工作的？</p><p class=ql-align-justify>在使用多次 HashMap 之后， 大体也能说出其添加元素的原理：计算每一个key的哈希值， 通过一定的计算之后算出其在哈希表中的位置，将键值对放入该位置，如果有哈希碰撞则进行哈希碰撞处理。</p><p class=ql-align-justify>而其工作时的原理如下。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/16ca7be96dc344e4b740e5bbf43323ca><p class=pgc-img-caption></p></div><p class=ql-align-justify>源码如下。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4242e10f17d349569f77e05999c57d73><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/17f65860fced4e67b73a1f0c5a603dff><p class=pgc-img-caption></p></div><p class=ql-align-justify>在此过程中， 会涉及到哈希碰撞的解决。</p><p class=ql-align-justify>9、HashMap.get() 方法内部是如何工作的？</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a15c410b1a564014aa9a5d4ff6909cd5><p class=pgc-img-caption></p></div><p class=ql-align-justify>其最终是调用了 getNode 函数。 其逻辑如下。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05bdafbfe16940d18524f09a32479cad><p class=pgc-img-caption></p></div><p class=ql-align-justify>源码如下。</p><div class=pgc-img><img alt=面试题：来，问你几个关于HashMap的问题？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/acccea6ad033409598c19ebac52d0a01><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试题','问你','几个关'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>