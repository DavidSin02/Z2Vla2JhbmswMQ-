<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>用 Java 做个“你画手机猜”的小游戏 | 极客快訊</title><meta property="og:title" content="用 Java 做个“你画手机猜”的小游戏 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8acdf70eb23e47698077c6830b982e6c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a146196.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a146196.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a146196.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a146196.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a146196.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a146196.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a146196.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a146196.html><meta property="article:published_time" content="2020-10-29T21:10:09+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:09+08:00"><meta name=Keywords content><meta name=description content="用 Java 做个“你画手机猜”的小游戏"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6a146196.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>用 Java 做个“你画手机猜”的小游戏</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">本文适合有 Java 基础的人群</span></span></p></blockquote><div class=pgc-img><img alt="用 Java 做个“你画手机猜”的小游戏" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8acdf70eb23e47698077c6830b982e6c><p class=pgc-img-caption></p></div><p style=text-align:center;line-height:1;margin:0><span style=font-size:.833em>作者：<strong>DJL-Lanking</strong></span></p><p style=line-height:1;margin:0><span style=font-size:.833em>HelloGitHub 推出的《讲解开源项目》系列。有幸邀请到了亚马逊 + Apache 的工程师：Lanking（ https://github.com/lanking520 ），为我们讲解 DJL —— 完全由 Java 构建的深度学习平台，本文为系列的第三篇。</span></p><h1 class=pgc-h-arrow-right>一、前言</h1><p style=line-height:1;margin:0>在 2018 年时，Google 推出了《猜画小歌》应用：玩家可以直接与 AI 进行你画我猜的游戏。通过画出一个房子或者一个猫，AI 会推断出各种物品被画出的概率。它的实现得益于深度学习模型在其中的应用，通过深度神经网络的归纳，曾经令人头疼的绘画识别也变得易如反掌。现如今，只要使用一个简单的图片分类模型，我们便可以轻松的实现绘画识别。试试看这个在线涂鸦小游戏吧：</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">在线涂鸦小游戏：https://djl.ai/website/demo.html#doodle</span></span></p></blockquote><p style=line-height:1;margin:0>在当时，大部分机器学习计算任务仍旧需要依托网络在云端进行。随着算力的不断增进，机器学习任务已经可以直接在边缘设备部署，包括各类运行安卓系统的智能手机。但是，由于安卓本身主要是用 Java ，部署基于 Python 的各类深度学习模型变成了一个难题。为了解决这个问题，AWS 开发并开源了 DeepJavaLibrary (DJL)，一个为 Java 量身定制的深度学习框架。</p><p style=line-height:1;margin:0>在这个文章中，我们将尝试通过 PyTorch 预训练模型在安卓平台构建一个涂鸦绘画的应用。由于总代码量会比较多，我们这次会挑重点把最关键的代码完成。你可以后续参考我们完整的项目进行构建。</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">涂鸦应用完整代码：https://github.com/aws-samples/djl-demo/tree/master/android</span></span></p></blockquote><h1 class=pgc-h-arrow-right>二、环境配置</h1><p style=line-height:1;margin:0>为了兼容 DJL 需求的 Java 功能，这个项目需要 Android API 26 及以上的版本。你可以参考我们案例配置来节约一些时间，下面是这个项目需要的依赖项：</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">案例 gradle: https://github.com/aws-samples/djl-demo/blob/master/android/quickdraw_recognition/build.gradle</span></span></p></blockquote><pre><code>dependencies {    implementation 'androidx.appcompat:appcompat:1.2.0'    implementation 'ai.djl:api:0.7.0'    implementation 'ai.djl.android:core:0.7.0'    runtimeOnly 'ai.djl.pytorch:pytorch-engine:0.7.0'    runtimeOnly 'ai.djl.android:pytorch-native:0.7.0'}</code></pre><p style=line-height:1;margin:0>我们将使用 DJL 提供的 API 以及 PyTorch 包。</p><h1 class=pgc-h-arrow-right>三、构建应用</h1><h1 class=pgc-h-arrow-right>3.1 第一步：创建 Layout</h1><p style=line-height:1;margin:0>我们可以先创建一个 View class 以及 layout（如下图）来构建安卓的前端显示界面。</p><div class=pgc-img><img alt="用 Java 做个“你画手机猜”的小游戏" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0d85901767eb4a24a398dbe68d26fd77><p class=pgc-img-caption></p></div><p style=line-height:1;margin:0>如上图所示，你可以在主界面创建两个 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">View</span></span> 目标。<span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">PaintView</span></span> 是用来让用户画画的，在右下角 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">ImageView</span></span> 是用来展示用于深度学习推理的图像。同时我们预留一个按钮来进行画板的清空操作。</p><h1 class=pgc-h-arrow-right>3.2 第二步: 应对绘画动作</h1><p style=line-height:1;margin:0>在安卓设备上，你可以自定义安卓的触摸事件响应来应对用户的各种触控操作。在我们的情况下，我们需要定义下面三种时间响应：</p><ul><li>touchStart：感应触碰时触发</li><li>touchMove：当用户在屏幕上移动手指时触发</li><li>touchUp：当用户抬起手指时触发</li></ul><p style=line-height:1;margin:0>与此同时，我们用 paths 来存储用户在画板所绘制的路径。现在我们看一下实现代码。</p><h1 class=pgc-h-arrow-right>3.2.1 重写 OnTouchEvent 和 OnDraw 方法</h1><p style=line-height:1;margin:0>现在我们重写 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">onTouchEvent</span></span> 来应对各种响应：</p><pre><code>@Overridepublic boolean onTouchEvent(MotionEvent event) {    float x = event.getX();    float y = event.getY();    switch (event.getAction()) {        case MotionEvent.ACTION_DOWN :            touchStart(x, y);            invalidate();            break;        case MotionEvent.ACTION_MOVE :            touchMove(x, y);            invalidate();            break;        case MotionEvent.ACTION_UP :            touchUp();            runInference();            invalidate();            break;    }    return true;}</code></pre><p style=line-height:1;margin:0>如上面代码所示，你可以添加一个 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">runInference</span></span> 方法在 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">MotionEvent.ACTION_UP</span></span> 事件响应上。这个方法是用来在用户绘制完后对结果进行推理。在之后的几步中，我们会讲解它的具体实现。</p><p style=line-height:1;margin:0>我们同样需要重写 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">onDraw</span></span> 方法来展示用户绘制的图像：</p><pre><code>@Overrideprotected void onDraw(Canvas canvas) {    canvas.save();    this.canvas.drawColor(DEFAULT_BG_COLOR);    for (Path path : paths) {        paint.setColor(DEFAULT_PAINT_COLOR);        paint.setStrokeWidth(BRUSH_SIZE);        this.canvas.drawPath(path, paint);    }    canvas.drawBitmap(bitmap, 0, 0, bitmapPaint);    canvas.restore();}</code></pre><p style=line-height:1;margin:0>真正的图像会保存在一个 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">Bitmap</span></span> 上。</p><h1 class=pgc-h-arrow-right>3.2.2 操作开始（touchStart）</h1><p style=line-height:1;margin:0>当用户触碰行为开始时，下面的代码会建立一个新的路径同时记录路径中每一个点在屏幕上的座标。</p><pre><code>private void touchStart(float x, float y) {    path = new Path();    paths.add(path);    path.reset();    path.moveTo(x, y);    this.x = x;    this.y = y;}</code></pre><h1 class=pgc-h-arrow-right>3.2.3 手指移动（touchMove）</h1><p style=line-height:1;margin:0>在手指移动中，我们会持续记录座标点然后将它们构成一个 quadratic bezier. 通过一定的误差阀值来动态优化用户的绘画动作。只有差别超出误差范围内的动作才会被记录下来。</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">quadratic bezier 文档: https://developer.android.com/reference/android/graphics/Path</span></span></p></blockquote><pre><code>private void touchMove(float x, float y) {    if (x &lt; 0 || x &gt; getWidth() || y &lt; 0 || y &gt; getHeight()) {        return;    }    float dx = Math.abs(x - this.x);    float dy = Math.abs(y - this.y);    if (dx &gt;= TOUCH_TOLERANCE || dy &gt;= TOUCH_TOLERANCE) {        path.quadTo(this.x, this.y, (x + this.x) / 2, (y + this.y) / 2);        this.x = x;        this.y = y;    }}</code></pre><h1 class=pgc-h-arrow-right>3.2.4 操作结束（touchUp）</h1><p style=line-height:1;margin:0>当触控操作结束后，下面的代码会绘制一个路径同时计算最小长方形目标框。</p><pre><code>private void touchUp() {    path.lineTo(this.x, this.y);    maxBound.add(new Path(path));}</code></pre><h1 class=pgc-h-arrow-right>3.3 第三步：开始推理</h1><p style=line-height:1;margin:0>为了在安卓设备上进行推理任务，我们需要完成下面几个任务：</p><ul><li>从 URL 读取模型</li><li>构建前处理和后处理过程</li><li>从 PaintView 进行推理任务</li></ul><p style=line-height:1;margin:0>为了完成以下目标，我们尝试构建一个 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">DoodleModel</span></span> class。在这一步，我们将介绍一些完成这些任务的关键步骤。</p><h1 class=pgc-h-arrow-right>3.3.1 读取模型</h1><p style=line-height:1;margin:0>DJL 内建了一套模型管理系统。开发者可以自定义储存模型的文件夹。</p><pre><code>File dir = getFilesDir();System.setProperty("DJL_CACHE_DIR", dir.getAbsolutePath());</code></pre><p style=line-height:1;margin:0>通过更改 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">DJL_CACHE_DIR</span></span> 属性，模型会被存入相应路径下。</p><p style=line-height:1;margin:0>下一步可以通过定义 Criteria 从指定 URL 处下载模型。下载的 zip 文件内包含：</p><ul><li><span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">doodle_mobilenet.pt</span></span>：PyTorch 模型</li><li><span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">synset.txt</span></span>：包含分类任务中所有类别的名称</li></ul><pre><code>Criteria&lt;Image, Classifications&gt; criteria =            Criteria.builder()                    .setTypes(Image.class, Classifications.class)                    .optModelUrls("https://djl-ai.s3.amazonaws.com/resources/demo/pytorch/doodle_mobilenet.zip")                    .optTranslator(translator)                    .build();return ModelZoo.loadModel(criteria);</code></pre><p style=line-height:1;margin:0>上述代码同时定义了 translator，它会被用来做图片的前处理和后处理。</p><p style=line-height:1;margin:0>最后，如下述代码创建一个 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">Model</span></span> 并用它创建一个 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">Predictor</span></span>：</p><pre><code>@Overrideprotected Boolean doInBackground(Void... params) {    try {        model = DoodleModel.loadModel();        predictor = model.newPredictor();        return true;    } catch (IOException | ModelException e) {        Log.e("DoodleDraw", null, e);    }    return false;}</code></pre><p style=line-height:1;margin:0>更多关于模型加载的信息，请参阅如何加载模型。</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">DJL 模型加载文档：http://docs.djl.ai/docs/load_model.html</span></span></p></blockquote><h1 class=pgc-h-arrow-right>3.3.2 用 Translator 定义前处理和后处理</h1><p style=line-height:1;margin:0>在 DJL 中，我们定义了 Translator 接口进行前处理和后处理。在 DoodleModel 中我们定义了 ImageClassificationTranslator 来实现 Translator：</p><pre><code>ImageClassificationTranslator.builder()    .addTransform(new ToTensor())    .optFlag(Image.Flag.GRAYSCALE)    .optApplySoftmax(true).build());</code></pre><p style=line-height:1;margin:0>下面我们详细阐述 translator 所定义的前处理和后处理如何被用在模型的推理步骤中。当你创建 translator 时，内部程序会自动加载 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">synset.txt</span></span> 文件得到做分类任务时所有类别的名称。当模型的 <span style=font-size:.667em><span style="color:#ef7060;--tt-darkmode-color: #EF7060">predict()</span></span> 方法被调用时，内部程序会先执行所对应的 translator 的前处理步骤，而后执行实际推理步骤，最后执行 translator 的后处理步骤。对于前处理，我们会将 Image 转化 NDArray，用于作为模型推理过程的输入。对于后处理，我们对推理输出的结果（NDArray）进行 softmax 操作。最终返回结果为 Classifications 的一个实例。</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">自定义 Translator 案例：http://docs.djl.ai/jupyter/pytorch/load_your_own_pytorch_bert.html</span></span></p></blockquote><h1 class=pgc-h-arrow-right>3.3.3 用 PaintView 进行推理任务<br></h1><p style=line-height:1;margin:0>最后，我们来实现之前定义好的 runInference 方法。</p><pre><code>public void runInference() {    // 拷贝图像    Bitmap bmp = Bitmap.createBitmap(bitmap);    // 缩放图像    bmp = Bitmap.createScaledBitmap(bmp, 64, 64, true);   // 执行推理任务    Classifications classifications = model.predict(bmp);   // 展示输入的图像    Bitmap present = Bitmap.createScaledBitmap(bmp, imageView.getWidth(), imageView.getHeight(), true);    imageView.setImageBitmap(present);   // 展示输出的图像   if (messageToast != null) {        messageToast.cancel();    }    messageToast = Toast.makeText(getContext(), classifications.toString(), Toast.LENGTH_SHORT);    messageToast.show();}</code></pre><p style=line-height:1;margin:0>这将会创建一个 Toast 弹出页面用于展示结果，示例如下:</p><div class=pgc-img><img alt="用 Java 做个“你画手机猜”的小游戏" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/781cac64809f443cb8e3f8b418871928><p class=pgc-img-caption></p></div><p style=line-height:1;margin:0>恭喜你！我们完成了一个涂鸦识别小程序！</p><h1 class=pgc-h-arrow-right>3.4 可选优化：输入裁剪</h1><p style=line-height:1;margin:0>为了得到更高的模型推理准确度，你可以通过截取图像来去除无意义的边框部分。</p><div class=pgc-img><img alt="用 Java 做个“你画手机猜”的小游戏" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fd5e749815ae4ffaa1b59248c8993cd9><p class=pgc-img-caption></p></div><p style=line-height:1;margin:0>上面右侧的图片会比左边的图片有更好的推理结果，因为它所包含的空白边框更少。你可以通过 Bound 类来寻找图片的有效边界，即能把图中所有白色像素点覆盖的最小矩形。在得到 x 轴最左座标，y 轴最上座标，以及矩形高度和宽度后，就可以用这些信息截取出我们想要的图形（如右图所示）实现代码如下：</p><pre><code>RectF bound = maxBound.getBound();int x = (int) bound.left;int y = (int) bound.top;int width = (int) Math.ceil(bound.width());int height = (int) Math.ceil(bound.height());// 截取部分图像Bitmap bmp = Bitmap.createBitmap(bitmap, x, y, width, height);</code></pre><p style=line-height:1;margin:0>恭喜你！现在你就掌握了全部教程内容！期待看到你创建的第一个 DoodleDraw 安卓游戏！</p><p style=line-height:1;margin:0>最后，可以在GitHub找到本教程的完整案例代码。</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">涂鸦应用完整代码：https://github.com/aws-samples/djl-demo/tree/master/android</span></span></p></blockquote><h1 class=pgc-h-arrow-right>关于 DJL</h1><div class=pgc-img><img alt="用 Java 做个“你画手机猜”的小游戏" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e55b34f8991b402fbaed5531f6790422><p class=pgc-img-caption></p></div><p style=line-height:1;margin:0>Deep Java Library (DJL) 是一个基于 Java 的深度学习框架，同时支持训练以及推理。DJL 博取众长，构建在多个深度学习框架之上 (TenserFlow、PyTorch、MXNet 等) 也同时具备多个框架的优良特性。你可以轻松使用 DJL 来进行训练然后部署你的模型。</p><p style=line-height:1;margin:0>它同时拥有着强大的模型库支持：只需一行便可以轻松读取各种预训练的模型。现在 DJL 的模型库同时支持高达 70 个来自 GluonCV、 HuggingFace、TorchHub 以及 Keras 的模型。</p><blockquote><p style=line-height:1;margin:0><span style=font-size:.833em><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">项目地址：https://github.com/awslabs/djl/</span></span></p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','做个','你画'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>