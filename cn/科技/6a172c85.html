<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 | 极客快訊</title><meta property="og:title" content="缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a071adf1517b450eb341a46fbd40b609"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6a172c85.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6a172c85.html><meta property="article:published_time" content="2020-11-14T21:04:03+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:03+08:00"><meta name=Keywords content><meta name=description content="缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6a172c85.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>今天我简单的跟大家介绍一下关于Redis中缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级等概念的入门及简单解决方案。由于水平有限，如果发现以上文章有错误或者需要改进的地方请大家指出，万分感谢！！！</p><p class=ql-align-justify></p><p class=ql-align-justify><strong>一、缓存雪崩</strong></p><p class=ql-align-justify>通俗简单的理解就是：由于原有缓存失效（或者数据未加载到缓存中），新缓存未到期间（缓存正常从Redis中获取，如下图）所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机，造成系统的崩溃。</p><div class=pgc-img><img alt=缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a071adf1517b450eb341a46fbd40b609><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>缓存失效的时候如下图：</p><div class=pgc-img><img alt=缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7cd33898bd04fb3ae97be939d7d81a9><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>缓存失效时的雪崩效应对底层系统的冲击非常可怕！那有什么办法来解决这个问题呢？基本解决思路如下：</p><p class=ql-align-justify>第一，大多数系统设计者考虑用<strong>加锁</strong>或者<strong>队列</strong>的方式保证来保证不会有大量的线程对数据库一次性进行读写，避免缓存失效时对数据库造成太大的压力，虽然能够在一定的程度上缓解了数据库的压力但是与此同时又降低了系统的吞吐量。</p><p class=ql-align-justify>第二，分析用户的行为，尽量让缓存失效的时间均匀分布。</p><p class=ql-align-justify>第三，如果是因为某台缓存服务器宕机，可以考虑做主备，比如：redis主备，但是双缓存涉及到更新事务的问题，update可能读到脏数据，需要好好解决。</p><p class=ql-align-justify><strong>以下简单介绍两种实现方式的伪代码：</strong></p><p class=ql-align-justify>（1）碰到这种情况，一般并发量不是特别多的时候，使用最多的解决方案是<strong>加锁排队</strong>，伪代码如下：</p><div class=pgc-img><img alt=缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8ce9753d4634f099dfc46be1f47edd9><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间key是锁着的，这是过来1000个请求999个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法！</p><p class=ql-align-justify><strong>注意</strong>：加锁排队的解决方式分布式环境的并发问题，有可能还要解决分布式锁的问题；线程还会被阻塞，用户体验很差！因此，在真正的高并发场景下很少使用！</p><p class=ql-align-justify>（2）还有一个解决办法解决方案是：给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存，实例伪代码如下：</p><div class=pgc-img><img alt=缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6f984229e3ed459db3095b85059147af><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>解释说明：</strong></p><p class=ql-align-justify>1、缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际key的缓存；</p><p class=ql-align-justify>2、缓存数据：它的过期时间比缓存标记的时间延长1倍，例：标记缓存时间30分钟，数据缓存设置为60分钟。 这样，当缓存标记key过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</p><p class=ql-align-justify>关于缓存崩溃的解决方法，这里提出了三种方案：使用锁或队列、设置过期标志更新缓存、为key设置不同的缓存失效时间，还有<span>一各</span>被称为“二级缓存”的解决方法，有兴趣的读者可以自行研究。</p><p class=ql-align-justify><strong>二、缓存穿透</strong></p><p class=ql-align-justify>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询。</p><p class=ql-align-justify><strong>解决思路：</strong></p><p class=ql-align-justify>1，如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。</p><p class=ql-align-justify>2，根据缓存数据Key的规则。例如我们公司是做机顶盒的，缓存数据以Mac为Key，Mac是有规则，如果不符合规则就过滤掉，这样可以过滤一部分查询。在做缓存规划的时候，Key有一定规则的话，可以采取这种办法。这种办法只能缓解一部分的压力，过滤和系统无关的查询，但是无法根治。</p><p class=ql-align-justify>3，采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的BitSet中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力。关于布隆过滤器，详情查看：基于BitSet的布隆过滤器(Bloom Filter)</p><p class=ql-align-justify>大并发的缓存穿透会导致缓存雪崩。</p><div class=pgc-img><img alt=缓存雪崩,缓存穿透,缓存预热,缓存更新,缓存降级入门及简单解决 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/394375810aa74cf99149a13a82ba1e4e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的key进行预先校验，然后再放行给后面的正常缓存处理逻辑。</p><p class=ql-align-justify><strong>三、缓存预热</strong></p><p class=ql-align-justify>缓存预热这个应该是一个比较常见的概念，相信很多小伙伴都应该可以很容易的理解，缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据！</p><p class=ql-align-justify><strong>解决思路：</strong></p><p class=ql-align-justify>1、直接写个缓存刷新页面，上线时手工操作下；</p><p class=ql-align-justify>2、数据量不大，可以在项目启动的时候自动进行加载；</p><p class=ql-align-justify>3、定时刷新缓存；</p><p class=ql-align-justify><strong>四、缓存更新</strong></p><p class=ql-align-justify>除了缓存服务器自带的缓存失效策略之外（Redis默认的有6中策略可供选择），我们还可以根据具体的业务需求进行自定义的缓存淘汰，常见的策略有两种：</p><p class=ql-align-justify>（1）定时去清理过期的缓存；</p><p class=ql-align-justify>（2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</p><p class=ql-align-justify>两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂！具体用哪种方案，大家可以根据自己的应用场景来权衡。</p><p class=ql-align-justify><strong>五、缓存降级</strong></p><p class=ql-align-justify>当访问量剧增、服务出现问题（如响应时间慢或不响应）或非核心服务影响到核心流程的性能时，仍然需要保证服务还是可用的，即使是有损服务。系统可以根据一些关键数据进行自动降级，也可以配置开关实现人工降级。</p><p class=ql-align-justify>降级的最终目的是保证核心服务可用，即使是有损的。而且有些服务是无法降级的（如加入购物车、结算）。</p><p class=ql-align-justify>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p><p class=ql-align-justify>（1）一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p><p class=ql-align-justify>（2）警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p><p class=ql-align-justify>（3）错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p><p class=ql-align-justify>（4）严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p><p class=ql-align-justify>另外，我想补充一些知识点</p><p class=ql-align-justify><strong>分布式缓存系统面临的问题</strong></p><p class=ql-align-justify><strong>缓存一致性问题</strong></p><p class=ql-align-justify>1：缓存系统与底层数据的一致性。这点在底层系统是“可读可写”时，写得尤为重要</p><p class=ql-align-justify>2：有继承关系的缓存之间的一致性。为了尽量提高缓存命中率，缓存也是分层：全局缓存，二级缓存。他们是存在继承关系的。全局缓存可以有二级缓存来组成。</p><p class=ql-align-justify>3：多个缓存副本之间的一致性。为了保证系统的高可用性，缓存系统背后往往会接两套存储系统（如memcache，redis等）</p><p class=ql-align-justify><strong>缓存穿透和缓存雪崩</strong></p><p class=ql-align-justify>上面有讲述。</p><p class=ql-align-justify><strong>缓存数据的淘汰</strong></p><p class=ql-align-justify>缓存淘汰的策略有两种： (1) 定时去清理过期的缓存。 （2）当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。 两者各有优劣，第一种的缺点是维护大量缓存的key是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。 1. 预估失效时间 2. 版本号（必须单调递增，时间戳是最好的选择）3. 提供手动清理缓存的接口。</p><p class=ql-align-justify></p><p class=ql-align-justify><strong>缓存算法</strong></p><p class=ql-align-justify>FIFO算法：First in First out，先进先出。原则：一个数据最先进入缓存中，则应该最早淘汰掉。也就是说，当缓存满的时候，应当把最先进入缓存的数据给淘汰掉。</p><p class=ql-align-justify>LFU算法：Least Frequently Used，最不经常使用算法。</p><p class=ql-align-justify>LRU算法：Least Recently Used，近期最少使用算法。</p><p class=ql-align-justify>LRU和LFU的区别。LFU算法是根据在一段时间里数据项被使用的次数选择出最少使用的数据项，即根据使用次数的差异来决定。而LRU是根据使用时间的差异来决定的</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'缓存','预热','降级'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>