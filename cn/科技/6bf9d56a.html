<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>简单又复杂的“整数类型” | 极客快訊</title><meta property="og:title" content="简单又复杂的“整数类型” - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1539512950121b943404743"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6bf9d56a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6bf9d56a.html><meta property="article:published_time" content="2020-11-14T21:05:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:09+08:00"><meta name=Keywords content><meta name=description content="简单又复杂的“整数类型”"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6bf9d56a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>简单又复杂的“整数类型”</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>前言</h1><p>因为一道题目让我不断地深追下去，挖出了我多年的噩梦——数据类型的范围与长度。每次都想得头痛，因为平台不同、编译器不同、编程语言不同等等因素，又没去做实验，网上那么多说法该相信谁都不知道……那不如趁现在就来详细地解决掉它吧。</p><h1>一、原码、反码和补码</h1><p><strong>基础知识</strong></p><p>相信在大学的《数字逻辑》课上都学过这个内容了，原码、反码和补码都是基于二进制而言的：</p><p>【原码】第1位表示符号位，其余位是这个数的绝对值。这是最简单能够马上想到的表示方式了。</p><p>【反码】正数的反码是其本身；负数的反码：在原码的基础上，符号位不变，其余位取反。</p><p>【补码】正数的补码是其本身；负数的补码：在原码的基础上，符号位不变，其余位取反，最后+1。</p><p>举个例子，假设整数在机器上是用8位二进制数表示的（8位就和我们经常说的32位、64位是一样的含义）：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539512950121b943404743><p class=pgc-img-caption></p></div><p>为什么要用原码、反码和补码呢？</p><p><strong>原码的来源</strong></p><p>为了让二进制能够表示负数，产生了原码。</p><p><strong>反码的来源</strong></p><p>一个正数和一个负数运算需要辨别符号位，然而单独去辨别符号位会给电路设计带来极大的复杂度，因此人们想只设计加法电路，让符号位直接参与加法运算达到减法的目的，产生了反码。例如：3-2 = 3+(-2) = [0000 0011]反+[1111 1101]反 = [0000 0001]反 = [0000 0001]原=1（注意反码的加法当最高位进位的时候，最低位需要+1，不再详细描述，参考百度百科《二进制反码求和》）。这样符号位就能够参与运算了。</p><p><strong>补码的来源</strong></p><p>反码看起来很完美，但是仍然存在问题。例如3-3 = 3+(-3) = [0000 0011]反+[1111 1100]反 = [1111 1111]反 = [1000 0000]原=-0，而[0000 0000]反=[0000 0000]原 = +0，也就是说，零可以表示为两种形式，这种歧义同样不利于电路实现。并且由于反码的加减法还需要对溢出位进行处理，于是产生了补码。补码对溢出位直接丢弃，而0的表示只有一种[0000 0000]补，[1000 0000]补则看成是-128，解决了所有问题。</p><p><strong>原码、反码和补码的范围问题</strong></p><p>值得注意的是，8位的原码和反码都只能表示[-127, +127]范围内的整数，而补码可以表示[-128, +127]范围，多一个-128。这里的-128是计算得到的，而不是从反码推出的，-128根本无法用反码表示，却能够用补码计算，比如-127+(-1) = [1000 0001]补+[1111 1111]补 = [1000 0000]补。所以我们经常背的整数取值范围[-32768, +32767]之类的东西为什么负数总比整数的真值大1，就是这样来的。</p><h1>计算机中按位取反会发生什么？</h1><p>既然计算机表示的时候用的是补码，那么如果对十进制的整数【按位取反】操作到底操作的是补码还是二进制呢？</p><p><strong>实验一下吧：</strong></p><pre>printf("%d\n", ~(3));printf("%d\n", ~(-3));</pre><p>【平台】windows 8 64位</p><p>【IDE】vs2013 32位</p><p>【语言】C语言</p><p>【取反操作】~</p><p>【取反结果】~3 = -4，~(-3) = 2</p><p>数值比较小，最高位没有影响，就按照8位来仔细观察第一组数据：</p><p>3 = [0000 0011]b = [0000 0011]原 = [0000 0011]反 = [0000 0011]补</p><p>-4 = [无法表示]b = [1000 0100]原 = [1111 1011]反 = [1111 1100]补</p><p>对补码取的反，再来看第二组：</p><p>-3 = [无法表示]b = [1000 0011]原 = [1111 1100]反 = [1111 1101]补</p><p>2 = [0000 0010]b = [0000 0010]原 = [0000 0010]反 = [0000 0010]补</p><p>可以确信100%是对补码取的反了，纯的。</p><h1>二、C语言中的整数类型的大小和范围</h1><p>以前我们常常会去记忆[-32767, +32768]，尤其是在学pascal的时候，然而现在仔细想想，pascal都是多少年前的编程语言了，那时的电脑和现在的电脑完全不相同，记这个根本没用。整数类型的大小和范围和操作系统、编译器、编程语言都息息相关，抛开运行环境谈论sizeof出什么结果的题目都是耍流氓，然而笔试题这种流氓经常存在………</p><p><strong>整数类型的范围与表示位数</strong></p><p>用不同位数表示整数，取值的范围就不相同，由于采用补码，总可以多表示一个负数：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15395129503361983b9e620><p class=pgc-img-caption></p></div><p><strong>无符号unsigned</strong></p><p>无符号的时候，就可以不用担心符号位了，也就是可以表示0~2^bit-1个数，比如：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539512950134668a3ea377><p class=pgc-img-caption></p></div><p><strong>C语言中的整数类型及其长度</strong></p><p>基本整数类型有：char、short int、int、long、long long（c99新增）。</p><p>我总是在死记长度，总以为long比int更长，但其实C语言标准是这样规定的：</p><blockquote><p>int最少16位（2字节），long不能比int短，short不能比int长，具体位长由编译器开发商根据各种情况自己决定。</p></blockquote><p>好一个“自己决定”……好一个“不能比”……还是通常情况吧，列个表：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539512950158cdc470bf08><p class=pgc-img-caption></p></div><p>32位表示方式中，long int和int是一样大的！同时还反映了一个问题：64位运行的代码不一定能在32位上运行。</p><h1>C语言数据类型名称、输出和编译器的关系</h1><p><strong>g++和gcc</strong></p><p>g++把.c和.cpp程序都认为是c++程序，gcc则会用C语言的方式编译.c，用C++的方式编译.cpp。也就是说，如果你用C写的程序，用g++编译，很可能会报语法错误，因为g++对语法要求更严格，尽管C++是C语言的超集。其他的区别就是，g++能够自动链接c++的库，而gcc需要手动设置参数。</p><p><strong>gcc/g++与cl</strong></p><p>vs使用的编译器是cl.exe，这是微软自己开发的编译器。CL.exe是控制 Microsoft C 和 C++ 编译器与链接器的 32 位工具。cl和clang是不同的，在Visual Studio 2015已经整合了clang编译器，但它是被用于Android和 iOS上的应用开发。</p><p><strong>整数类型不同表示方式以及输出</strong></p><p>Visual Studio是在windows下运行的，通常支持__intxx这种写法来定义不同位数的整数，这是gcc/g++通常不支持的（没有实验过）。而long long这种写法在Visual C++ 6.0上是不支持的（没有实验过）。不过，在Visual Studio 2013上，全部的写法都支持，很可靠，列个表：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15395129507801b96be1112><p class=pgc-img-caption></p></div><p>并且，所有的printf写法都支持：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15395129501622602b43045><p class=pgc-img-caption></p></div><p><strong>做个实验：</strong></p><p>【操作系统】windows 8 64位</p><p>【IDE】Microsoft Visual Studio 2013 32位</p><p>【编译器】cl.exe win32</p><p>【代码】</p><pre>long long a = 1231321313131313131;__int64 b = 1231321313131313131; printf(" type=long long\n d=%d\n ld=%ld\n lld=%lld\n I64d=%I64d\n ---\n", a,a,a,a);printf(" type=__int64\n d=%d\n ld=%ld\n lld=%lld\n I64d=%I64d\n", b,b,b,b);</pre><p>【输出结果】</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15395129506302941e0bb1a><p class=pgc-img-caption></p></div><p>d和ld都溢出了，而lld、I64d可以工作得很好，而且对long long 和__int64没有任何区别</p><p>整数类型越界会发生什么？</p><p>这是一直都很好奇的事情，那就来实验一下。</p><p>【操作系统】windows 8 64位</p><p>【IDE】Microsoft Visual Studio 2013 32位</p><p>【编译器】cl.exe win32</p><p>【实验结果】</p><ol><li>取值范围unsigned short int 0~65535unsigned int 0～4294967295int -2147483648～2147483647long -2147483648 ~ 2147483647long long -9223372036854775808 ~ 9223372036854775807超上限（越来越大）会从最小值开始重新增长：unsigned short int 65536=0 | 65537= 1unsigned int 4294967296=0 | 4294967297= 1int 2147483648=-2147483648 | 2147483649 = -2147483647long 2147483648=-2147483648 | 2147483649 = -2147483647long long 9223372036854775808 = -9223372036854775808 | 9223372036854775809 = -9223372036854775807超下限（越来越小）会从最大值开始重新减小：unsigned short int -1=65535 | -2=65534unsigned int -1=4294967295 | -2=4294967294int -2147483649=2147483647 | -2147483650=2147483646long -2147483649=2147483647 | -2147483650=2147483646long long -9223372036854775809 = -9223372036854775807 | 9223372036854775810 = -9223372036854775806</li></ol><p>【探究原因】</p><p>想一下刚才的补码，假设32位，int取最大值2147483647，打开你的计算器，选择查看→程序员，输入这个数字，看到它的补码：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15395129505550e736a1848><p class=pgc-img-caption></p></div><p>[0111 1111 1111 1111 1111 1111 1111 1111]补 + [0000 0000 0000 0000 0000 0000 0000 0001]补的结果是[1000 0000 0000 0000 0000 0000 0000 0000]补 = -2147483648。</p><p>这就是为什么越界的2147483648，打印输出-2147483648的原因了。</p><p>【其他】</p><p>注意如果你直接进行赋值：</p><pre>int a = -2147483648;</pre><p>VS是会报错的：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539512950542036cb9b12b><p class=pgc-img-caption></p></div><p>long long 也是如此，因此这时候应该用：</p><pre>int a = INT_MIN;long long b = LLONG_MIN;</pre><p>来表示，可以看到它们的宏定义：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539512950435e03f235f3b><p class=pgc-img-caption></p></div><p>说好的可以多表示一个负数呢，怎么不行了呢，具体原因参考wiki《VS编写C程序报错error C4146: 一元负运算符应用于无符号类型，结果仍为无符号类》</p><h1>三、JAVA语言中的整数类型的大小和范围</h1><p><strong>基本信息</strong></p><p>因为我在尽量主学Java副学Python，所以这里也记录一下java的整数类型。java的整数类型比较神奇，有四种基本整数类型：byte、short、int、long，但由于java的设计初衷是跨平台运行的，Write Once and Run Anywhere，所以这几种类型的字长都是固定的，与任何其他的32位64位都无关，列个表：</p><div class=pgc-img><img alt=简单又复杂的“整数类型” onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1539512950635509b9fef52><p class=pgc-img-caption></p></div><p><strong>你可以自己测试一下：</strong></p><pre>System.out.println("Byte: " + Byte.SIZE/8);System.out.println("Short: " + Short.SIZE/8); System.out.println("Integer: " + Integer.SIZE/8); System.out.println("Long: " + Long.SIZE/8);</pre><p><strong>java中的unsigned类型</strong></p><p>java是几乎没有unsigned类型的。为什么说几乎呢，因为在多年的呼吁之后，最新的jdk8支持了unsigned的静态方法调用（也就是说不支持直接写unsigned int这种写法，只能通过Integer.xxxx来调用），参看《Unsigned Integer Arithmetic API now in JDK 8》。真应了那句老话：真香！为什么大家那么希望有unsigned类型呢？因为常常需要处理图片，而我们知道通常的图片数据是从0变化到255的，如果有unsigned byte，那不就刚好了嘛~由于没有unsigned，目前主流的做法是使用更大的类型比如short或者int。值得注意的是，如果要把表达0~255取值的byte转换到short/int，要处理一下符号。因为当从0~255的short/int转换为byte时，考虑他们的补码，例如255：</p><p>255 = short [0000 0000 1111 1111]补 → byte [1111 1111]补 = -1</p><p>128 = short [0000 0000 1000 0000]补 → byte[1000 0000]补 = -128</p><p>0 = short [0000 0000 0000 0000]补 → byte[0000 0000]补 = 0</p><p>127 = short[0000 0000 0111 1111]补 → byte[0111 1111]补 = 127</p><p>可以看出，0~127(short)被映射到0~127（byte），而128~255则被映射到（-128~-1）了，因此在byte转回short/int时，如果不加处理，得到的值会是-128：</p><p>-128 = byte[1000 0000]补 → short [1111 1111 1000 0000]补 = -128</p><p>处理的方法很简单，加个掩码0xff屏蔽掉高位的符号扩展即可，也就是将byte的值与0xff进行按位与：</p><p>-128 & 0xff = byte[1000 0000]补 & [1111 1111] → short[1111 1111 1000 0000]补 & [0000 0000 1111 1111] = [0000 0000 1000 0000]补 = 128</p><p>得到的值就正常了，用代码实验一下：</p><pre>short s_init = 128,s_force,s_and; byte b_force; b_force = (byte)s_init; s_force = (short)b_force; s_and = (short)(b_force &amp; 0xFF); System.out.println("初始short值= "+s_init+"\n转为byte= "+b_force+"\nbyte转为short= "+s_force+"\nbyte掩码后转为short= "+s_and);</pre><p>得到的结果是：</p><pre>初始short值= 128转为byte= -128byte转为short= -128byte掩码后转为short= 128</pre><p><strong>java中的char</strong></p><p>char类型长度2个字节，而且取值是无符号的0~65535，其他编程语言通常都是1个字节。java的char是Unicode编码，可以存放中文字符。那么为什么不用它来作为unsigned int 用呢？</p><p>【原因1】输出为字符。</p><p>java的char类型是设计为存储unicode字符的，采用UTF-16固定宽度的编码格式。虽然赋值的是数值88，但当调用System.out.println(a);的时候，出现的是字母X。</p><p>【原因2】运算困难。</p><pre>char a = 88;a = a + 1;</pre><p>编译器会报错需要char类型，而给的是int，因为当char类型运算后就是int类型了，不能直接存回char类型，需要进行强制转换：</p><pre>a = (char)(a + 1);</pre><p>既然这么麻烦，为何不直接用int呢？</p><p>java中整数类型越界会发生什么？</p><p>和C语言是一样的：当越上界，会从最小值继续累加；当越下界，会从最大值继续减小。原因同样是因为补码溢出位被丢弃，在测试的时候，不能直接赋值越界数值，否则会提示类型不匹配或者整数太大了。使用常量+1再强制转换类型，达到越界目的。</p><pre>byte a = (byte)(Byte.MAX_VALUE+1);</pre><p>输出结果：-128</p><p><strong>ps：码字不易，如果你觉得有帮助的话，帮忙转发一下吧～</strong></p><p>---------------------------------</p><p>微信公众号：<strong>轮子工厂，机器学习 | 数据结构与算法 | 源码分析 |　资源与工具分享</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'简单','杂的','整数'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>