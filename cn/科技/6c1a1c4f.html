<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>所有学机器学习的人必须要懂的5个回归损失函数 | 极客快訊</title><meta property="og:title" content="所有学机器学习的人必须要懂的5个回归损失函数 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e3705450196b412ba0d239f329ce5ed7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6c1a1c4f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6c1a1c4f.html><meta property="article:published_time" content="2020-11-14T21:05:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:42+08:00"><meta name=Keywords content><meta name=description content="所有学机器学习的人必须要懂的5个回归损失函数"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6c1a1c4f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>所有学机器学习的人必须要懂的5个回归损失函数</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>作者：Prince Grover编译：ronghuaiyang</blockquote><h1><strong>导读</strong></h1><blockquote><p>为模型选择合适的损失函数，让模型具有最好的效果。</p></blockquote><p>机器学习中的所有算法都依赖于函数的最小化或最大化，我们称之为“目标函数”。一组最小化的函数称为“损失函数”。损失函数是衡量预测模型在预测预期结果方面做得有多好。求函数最小值的一种常用方法是“梯度下降法”。把损失函数想象成起伏的山，而梯度下降就像从山上滑下来到达最低点。</p><p>没有一个单一的损失函数适用于所有类型的数据。它取决于许多因素，包括异常值的存在、机器学习算法的选择、梯度下降的时间效率、求导数的易用性和预测的置信度。本系列博客的目的是了解不同的损失以及每种损失如何帮助数据科学家。</p><p>损失函数可以大致分为两类：<strong>分类和回归损失</strong>。在这篇文章中，我主要关注回归损失。在以后的文章中，我将讨论其他类别的损失。如果我忘记了什么，请在评论中告诉我。此外，本博客所展示的所有代码和图表均可在 这里中找到。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e3705450196b412ba0d239f329ce5ed7><p class=pgc-img-caption>回归函数预测的数值，分类函数预测的是标签</p></div><h1><strong>回归损失</strong></h1><p><strong>1. 均方误差，二次型损失，L2损失</strong></p><p>均方误差(Mean Square Error, MSE)是最常用的回归损失函数。MSE是目标变量与预测值之间距离的平方和。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e34e17d58004fe68bbcb921aba8e1de><p class=pgc-img-caption></p></div><p>下面是一个MSE函数的图，其中真实目标值为100，预测值在-10,000到10,000之间。MSE损失(y轴)在预测(x轴)= 100时达到最小值。范围是0到∞。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/28960ff2fa444a52945f93c7c9f32287><p class=pgc-img-caption>Plot of MSE Loss (Y-axis) vs. Predictions (X-axis)</p></div><p><strong>2. 平均绝对误差，L1损失</strong></p><p>平均绝对误差(MAE)是回归模型中使用的另一个损失函数。MAE是目标变量和预测变量之间的绝对差值之和。所以它测量的是一组预测的平均误差大小，而不考虑它们的方向。(如果我们也考虑方向，那就叫做平均偏差误差(Mean Bias Error, MBE)，它是残差/误差的和)。范围也是0到∞。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b17d7f4ed3d045dfb38cde8ac7f04bc5><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/07b4c8c63bc64d55ab7683a5c39f90ba><p class=pgc-img-caption>Plot of MAE Loss (Y-axis) vs. Predictions (X-axis)</p></div><p><strong>MSE vs. MAE (L2 loss vs L1 loss)</strong></p><p><strong>简而言之，使用平方误差更容易，但是使用绝对误差对异常值更有鲁棒性。我们来理解一下为什么！</strong></p><p>当我们训练机器学习模型时，我们的目标是找到使损失函数最小化的点。当然，当预测值恰好等于真实值时，两个函数都达到最小值。</p><p>下面快速回顾一下这两种方法的python代码。我们可以编写自己的函数，也可以使用sklearn的内置度量函数：</p><pre> # true: Array of true target variable # pred: Array of predictions  def mse(true, pred):  return np.sum((true - pred)**2)  def mae(true, pred): return np.sum(np.abs(true - pred))  # also available in sklearn  from sklearn.metrics import mean_squared_error from sklearn.metrics import mean_absolute_error</pre><p>让我们看看2种情况下MAE和均方根误差的值(RMSE，也就是MSE的平方根，使其与MAE处于相同的规模)。在第一种情况下，预测值接近真实值，误差在观测值之间的方差很小。在第二种情况下，有一个异常值，误差很大。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/276701f571ca4e38b3923af7adf6a8e0><p class=pgc-img-caption>左: 误差很接近 右: 有一个误差和其他差别很大</p></div><p><strong>我们从中观察到什么，它如何帮助我们选择使用哪种损失函数？</strong></p><p>由于MSE平方误差(y - y_prediction = e)，所以如果e > 1，误差(e)的值会增加很多。如果我们有一个异常数据，e的值会变得很大并且e²>>e。这将使MSE损失模型比MAE损失模型给予离群值更多的权重。在上面的第二种情况中，以RMSE为损失的模型将被调整，以牺牲其他常见的例子来最小化单个的离群值情况，这将降低它的总体能力。</p><p>如果训练数据被异常值破坏(例如，我们在训练环境中错误地接收到巨大的负/正值，但在测试环境中却没有)，那么MAE损失是有用的。</p><p>直觉上，我们可以这样想：如果我们只需要对所有试图最小化MSE的观测结果给出一个预测，那么这个预测应该是所有目标值的平均值。但是如果我们试图最小化MAE，这个预测将是所有观测值的中值。我们知道中值比平均值更对异常值更健壮，这使得MAE比MSE对异常值更健壮。</p><p>使用MAE loss的一个大问题是(尤其是对于神经网络)，它的梯度始终是相同的，这意味着即使损失值很小，梯度也会很大。这不利于学习。为了解决这个问题，我们可以使用动态学习速率，当我们接近最小值时，动态学习速率会降低。MSE在这种情况下表现良好，即使有固定的学习速率也会收敛。MSE损失的梯度在损失值较大时较高，在损失接近0时减小，使得训练结束时更加精确(见下图)。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/863750a4510d49c5a2a8278495b1bae0><p class=pgc-img-caption></p></div><p><strong>决定使用哪个损失函数</strong> 如果异常值代表对业务重要而且是应该检测的异常，那么我们应该使用MSE。另一方面，如果我们认为离群值只是代表损坏的数据，那么我们应该选择MAE作为损失。</p><p>我建议阅读这篇文章，并结合一项不错的研究比较使用L1 loss和L2 loss的回归模型的性能，研究是否存在异常值。记住，L1和L2损失只是MAE和MSE的另一个名称。</p><blockquote><p><em>L1损失对异常值的鲁棒性更强，但其导数不是连续的，使得求解效率低下。L2损耗对异常值很敏感，但给出了一个更稳定、更封闭的解(通过将其导数设置为0.)</em></p></blockquote><p><strong>两者都有问题</strong>：在某些情况下，损失函数都不能给出理想的预测。例如，如果我们的数据中90%的观测值的真实目标值为150，其余10%的目标值在0-30之间。然后，一个以MAE为损失的模型可能预测所有观测值为150，忽略10%的异常情况，因为它将试图接近中值。在同样的情况下，使用MSE的模型会给出0到30范围内的许多预测，因为它会偏向于离群值。这两种结果在许多业务案例中都是不可取的。</p><p><strong>在这种情况下该怎么办</strong>？一个简单的解决方法是转换目标变量。另一种方法是尝试不同的损失函数。这就是我们的第三个损失函数背后的动机，Huber损失。</p><p><strong>3. Huber Loss, 平滑的平均绝对误差</strong></p><p>Huber loss对数据中异常值的敏感性小于平方误差损失。它在0处也是可微的。它基本上是绝对误差，当误差很小的时候，它变成了二次函数。多小的时候变成二次误差取决于超参数，，这是可调整的。Huber损失方法<strong>当~ 0时为MAE，当~∞时为MSE</strong></p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4abd8b5e7bc8418d85bac2ae67e7aa5f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba9edf182b1e4cecbcb7a561a5fcbaa9><p class=pgc-img-caption>Plot of Hoss Loss (Y-axis) vs. Predictions (X-axis</p></div><p>delta的选择非常关键，因为它决定了你愿意将什么视为异常值。大于delta的残差用L1最小化(L1对大的异常值不太敏感)，而小于delta的残差用L2“适当地”最小化。</p><p><strong>为什么使用Huber损失？</strong>使用MAE训练神经网络的一个大问题是它的梯度经常很大，这会导致在使用梯度下降法训练结束时会错过最小值。对于MSE，梯度随着损失接近最小值而减小，使其更加精确。</p><p>Huber损失在这种情况下非常有用，因为它会围绕着减小梯度的最小值曲线。它比MSE对异常值更有效。因此，它结合了MSE和MAE的优良性能。然而，Huber损失的问题是我们可能需要训练超参数delta，这是一个迭代过程。</p><p><strong>4. Log-Cosh Loss</strong></p><p>Log-cosh是回归任务中使用的另一个比L2更平滑的函数。Log-cosh是预测误差的双曲余弦的对数。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24bf960567384b4c97e32ec24e8301af><p class=pgc-img-caption>Plot of Log-cosh Loss (Y-axis) vs. Predictions (X-</p></div><p><strong>优点:</strong> log(cosh(x))对于小的x，大约等于(x ** 2) / 2对，对于大的x，大约等于abs(x) - log(2)。这意味着logcosh的工作原理与均方误差类似，但不会受到偶尔出现的严重错误预测的太大影响。它具有Huber损失的所有优点，不像Huber损失，它在任何地方都是二阶可微的。</p><p><strong>为什么我们需要二阶导数？</strong>许多ML模型的实现，如XGBoost，都使用牛顿法来寻找最优解，这就是为什么需要二阶导数(Hessian)。对于像XGBoost这样的ML框架，二阶可微的函数更为有利。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1f611bf77f5a4805958eefaec3a6a1d7><p class=pgc-img-caption>XgBoost中用的目标函数，注意，依赖一阶和二阶导数</p></div><p>但是log-cosh损失并不是完美的。它仍然存在梯度和hessian问题，因为对于偏离目标非常大的的预测是恒定的，因此导致XGBoost不进行分割。</p><p>Huber和Log-cosh损失函数的Python代码：</p><pre> # huber loss def huber(true, pred, delta): loss = np.where(np.abs(true-pred) &lt; delta , 0.5*((true-pred)**2), delta*np.abs(true - pred)- 0.5*(delta**2)) return np.sum(loss)  # log cosh loss def logcosh(true, pred): loss = np.log(np.cosh(pred - true)) return np.sum(loss)</pre><p><strong>5. 理解分位数损失</strong></p><p>在现实世界的大多数预测问题中，我们往往对预测中的不确定性感兴趣。我们需要了解预测的范围，而不是仅仅进行每个点的估算，这样可以显著改进许多业务问题的决策过程。</p><p>分位数损失函数在我们有兴趣预测一个区间而不是仅仅预测点时非常有用。最小二乘回归的预测区间是基于残差(y - y_hat)在自变量值之间具有恒定方差的假设。我们不能相信违反这一假设的线性回归模型。我们也不能抛弃将线性回归模型拟合为基线的想法，认为使用非线性函数或基于树的模型对这种情况进行建模总是更好的。这就是分位数损失和分位数回归可以弥补的地方，因为基于分位数损失的回归甚至为非恒定方差或非正态分布的残差提供了合理的预测区间。</p><p>让我们看一个例子，以更好地理解为什么基于分位数损失的回归在异方差数据中表现良好。</p><p><strong>分位数回归vs.普通最小二乘回归</strong></p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e0008d4fb6b4962adb611d3f57df06d><p class=pgc-img-caption>左: X1和Y是线性关系，具有固定的方差。右：X2和Y是线性关系，但是Y的方差随着X2增加（异方差性</p></div><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b675b3318cd74c8c8d817a9c21143655><p class=pgc-img-caption>橘色线表示了两种情况的OLS估计</p></div><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/075c01af44ec4a7ab07efa5d0b40f624><p class=pgc-img-caption>分位数回归。虚线表示基于0.05和0.09分位数损失的回归结果</p></div><p>上面的图的分位数回归的代码在这里。</p><p><strong>理解分位数损失</strong></p><p>基于分位数的回归旨在估计给定一定预测变量值的响应变量的条件“分位数”。分位数损失实际上只是MAE的延伸(当分位数是50%时，它就是MAE)。</p><p>我们的想法是，根据我们想给正误差或负误差更多的值来选择分位数值。损失函数试图对于过高的估计和过低的估计不同的惩罚，在此基础上选择分位数(γ)。例如，γ= 0.25分位数损失函数对于过高的预测给出了更多的惩罚，试图保持预测值略低于中位数。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d79c393489654a1abaf62b508e837327><p class=pgc-img-caption></p></div><p>γ是所需的分位数和值在0和1之间。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1e4a9984f6614cdb8becb8627c9abc67><p class=pgc-img-caption></p></div><p>Plot of Quantile Loss (Y-axis) vs. Predictions (X-axis). True value of Y = 0</p><p>我们也可以使用这个损失函数来计算神经网络或基于树的模型中的预测区间。下面是梯度增强树回归的Sklearn实现示例。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6d30f2101dc4b41ae5107d551040bcc><p class=pgc-img-caption>使用分位数损失预测间隔（梯度提升回归器）</p></div><p>上图显示了使用sklearn库的GradientBoostingRegression中可用的分位数损失函数计算出的90%的预测区间。上限是γ= 0.95，下限γ= 0.05。</p><h1>对比学习：</h1><p>“Gradient boosting machines, a tutorial”中提供了一个不错的模拟比较。证明上述损失函数的性质，他们模拟的使用sinc(x)对数据集采样，人工模拟噪声的函数有两个来源：高斯噪声ε~N (0,σ2)和脉冲噪声组件ξ~Bern(p)。加入脉冲噪声项来说明鲁棒性效果。下面是使用不同损失函数拟合GBM回归函数的结果。</p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/04efbfd77b27499092cbbe366521d7b7><p class=pgc-img-caption></p></div><p><strong>连续损失函数：(A) MSE损失函数；(B) MAE损失函数；(C)Huber损失函数；(D)分位数损失函数</strong>。将平滑的GBM拟合到有噪声的噪声sinc(<em>x</em>)数据的演示：<strong>(E)</strong>原始sinc(<em>x</em>)函数；<strong>(F)</strong>平滑的GBM，使用MSE和MAE损失拟合；<strong>(G)</strong> 平滑的GBM，使用Huber损失拟合δ= {4，2，1}；<strong>(H)</strong>平滑的GBM使用分位数的损失α= {0.5，0.1，0.9}。</p><p><strong>模拟的一些观察结果：</strong></p><ul><li class=ql-align-justify>具有MAE损失模型的预测受脉冲噪声的影响较小，而具有MSE损失函数的预测由于噪声所引起的差异而略有偏差。</li><li class=ql-align-justify>当模型存在huber损失时，预测对选取的超参数值不敏感。</li><li class=ql-align-justify>分位数损失很好地估计了相应的置信水平。</li></ul><p><strong>所有的损失函数画在一个图里</strong></p><div class=pgc-img><img alt=所有学机器学习的人必须要懂的5个回归损失函数 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a44a6edc8eae406ba88818ad9f3e3bac><p class=pgc-img-caption></p></div><p>英文原文：https://heartbeat.fritz.ai/5-regression-loss-functions-all-machine-learners-should-know-4fb140e9d4b0</p><p><strong>更多文章，请关注微信公众号：AI公园</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'学机器','学习','必须'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>