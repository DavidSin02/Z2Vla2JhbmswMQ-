<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 | 极客快訊</title><meta property="og:title" content="正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6cbd5c1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6cbd5c1.html><meta property="article:published_time" content="2020-10-29T21:05:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:37+08:00"><meta name=Keywords content><meta name=description content="正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6cbd5c1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p style=text-align:start>1）实验平台：正点原子开拓者FPGA 开发板</p><p style=text-align:start>2）摘自《开拓者FPGA开发指南》关注官方微信号公众号，获取更多资料：正点原子</p><p style=text-align:start>3）全套实验源码+手册+视频下载地址：http://www.openedv.com/thread-13912-1-1.html</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption></p></div><p><strong>第二十八章 EEPROM读写测试实验</strong></p><p>EEPROM是一种用于计算机系统的非易失性存储器，也常在嵌入式领域中作为数据的存储设</p><p>备，在物联网及可穿戴设备等需要存储少量数据的场景中也有广泛应用。本章我们学习EEPROM</p><p>的读写操作并进行EEPROM读写实验。</p><p>本章包括以下几个部分：</p><p>28.1 EEPROM简介</p><p>28.2 实验任务</p><p>28.3 硬件设计</p><p>28.4 程序设计</p><p>28.5 下载验证</p><p><strong>EEPROM简介</strong></p><p>EEPROM (Electrically Erasable Progammable Read Only Memory，E2PROM)即电可擦除</p><p>可编程只读存储器，是一种常用的非易失性存储器（掉电数据不丢失），EEPROM有多种类型的</p><p>产品，我们开拓者FPGA开发板上使用的是ATMEL公司生产的AT24C系列的AT24C64这一型号。</p><p>AT24C64具有高可靠性，可对所存数据保存100年，并可多次擦写，擦写次数达一百万次。</p><p>一般而言，对于存储类型的芯片，我们比较关注其存储容量。我们这次实验所用的</p><p>AT24C64存储容量为64Kbit，内部分成256页，每页32字节，共有8192个字节，且其读写操作都</p><p>是以字节为基本单位。可以把AT24C64看作一本书，那么这本书有256页，每页有32行，每行有</p><p>8个字，总共有256*32*8=65536个字，对应着AT24C64的64*1024=65536个bit。</p><p>知道了AT24C64的存储容量，就知道了读写的空间大小。那么我们该如何对AT24C64进行读</p><p>写操作呢？</p><p>由于AT24C64采用两线串行接口的双向数据传输协议——I2C协议实现读写操作，所以我们</p><p>有必要了解一下I2C协议。</p><p>I2C即Inter-Integrated Circuit(集成电路总线），是由Philips半导体公司（现在的NXP</p><p>半导体公司）在八十年代初设计出来的一种简单、双向、二线制总线标准。多用于主机和从机</p><p>在数据量不大且传输距离短的场合下的主从通信。主机启动总线，并产生时钟用于传送数据，</p><p>此时任何接收数据的器件均被认为是从机。</p><p>I2C总线由数据线SDA和时钟线SCL构成通信线路，既可用于发送数据，也可接收数据。在</p><p>主控与被控IC之间可进行双向数据传送，数据的传输速率在标准模式下可达100kbit/s，在快</p><p>速模式下可达400kbit/s，在高速模式下可达3.4Mbit/s，各种被控器件均并联在总线上，通过</p><p>器件地址（SLAVE ADDR，具体可查器件手册）识别。我们开拓者I2C总线物理拓扑结构如下图</p><p>所示。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f77db343b8f641e5994ea012ab2f809c><p class=pgc-img-caption></p></div><p>图 28.1.1 开拓者I2C总线物理拓扑结构图</p><p>图中的I2C_SCL是串行时钟线，I2C_SDA是串行数据线，由于I2C器件一般采用开漏结构与</p><p>总线相连，所以I2C_SCL和I2C_SDA均需接上拉电阻，也正因此，当总线空闲时，这两条线路都</p><p>处于高电平状态，当连到总线上的任一器件输出低电平，都将使总线拉低，即各器件的SDA及</p><p>SCL都是“线与”关系。</p><p>I2C总线支持多主和主从两种工作方式，通常工作在主从工作方式，我们的开发板就采用</p><p>主从工作方式。在主从工作方式中，系统中只有一个主机，其它器件都是具有I2C总线的外围</p><p>从机。在主从工作方式中，主机启动数据的发送（发出启动信号）并产生时钟信号，数据发送</p><p>完成后，发出停止信号。</p><p>I2C总线结构虽然简单，使用两线传输，然而要实现器件间的通信，需要通过控制SCL和SDA</p><p>的时序，使其满足I2C的总线传输协议，方可实现器件间的数据传输。那么I2C协议的时序是怎</p><p>样的呢？</p><p>在I2C器件开始通信（传输数据）之前，串行时钟线SCL和串行数据线SDA线由于上拉的原</p><p>因处于高电平状态，此时I2C总线处于空闲状态。如果主机（此处指FPGA）想开始传输数据，</p><p>只需在SCL为高电平时将SDA线拉低，产生一个起始信号，从机检测到起始信号后，准备接收数</p><p>据，当数据传输完成，主机只需产生一个停止信号，告诉从机数据传输结束，停止信号的产生</p><p>是在SCL为高电平时，SDA从低电平跳变到高电平，从机检测到停止信号后，停止接收数据。I2C</p><p>整体时序如下图。起始信号之前为空闲状态，起始信号之后到停止信号之前的这一段为数据传</p><p>输状态，主机可以向从机写数据，也可以读取从机输出的数据，数据的传输由双向数据线（SDA）</p><p>完成。停止信号产生后，总线再次处于空闲状态。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb444c6da96c493ebe5b1f3b4beedc79><p class=pgc-img-caption></p></div><p>图 28.1.2 I2C整体时序图</p><p>了解到了整体时序之后，我们可能有疑问，数据是以什么样的格式传输的呢？满足怎样的</p><p>时序要求呢？是在任何时候改变都可以吗？怎么知道从机有没有接收到数据呢？带着这些疑</p><p>问，我们继续学习I2C。</p><p>由于只有一根数据线进行数据的传输，如果不规定好传输规则肯定会导致信息错乱，如同</p><p>在单条道路上驾驶，没有交通规则，再好的道路也会发生拥堵甚至更糟。采用两线结构的I2C</p><p>虽然只有一根数据线，但由于还有一条时钟线，可以让数据线在时钟线的带领下有顺序的传送，</p><p>就好像单条道路上的车辆在交警或信号指示灯的指示下有规则的通行。那么I2C遵循怎样的规</p><p>则呢？</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d5fc8db0522e44af9743cc430ecb586d><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.3 I2C具体时序图</p><p>如果要想回答这些问题，我们得读懂图 28.1.3。由图 28.1.3可知，我们在起始信号之后，</p><p>主机开始发送传输的数据；在串行时钟线SCL为低电平状态时，SDA允许改变传输的数据位（1</p><p>为高电平，0为低电平），在SCL为高电平状态时，SDA要求保持稳定，相当于一个时钟周期传</p><p>输1bit数据，经过8个时钟周期后，传输了8bit数据，即一个字节。第8个时钟周期末，主机释</p><p>放SDA以使从机应答，在第9个时钟周期，从机将SDA拉低以应答；如果第9个时钟周期，SCL为</p><p>高电平时，SDA未被检测到为低电平，视为非应答，表明此次数据传输失败。第9个时钟周期末，</p><p>从机释放SDA以使主机继续传输数据，如果主机发送停止信号，此次传输结束。我们要注意的是数据以8bit即一个字节为单位串行发出，其最先发送的是字节的最高位。</p><p>I2C的时序部分已经基本介绍完了，但还有一个小问题，就是当多个I2C器件挂接在总线上</p><p>时，怎样才能与我们想要传输数据的器件进行通信。这就涉及到了器件地址（也称从机地址，</p><p>SLAVE ADDRESS）。</p><p>每个I2C器件都有一个器件地址，有些I2C器件的器件地址是固定的，而有些I2C器件的器</p><p>件地址由一个固定部分和一个可编程的部分构成，这是因为很可能在一个系统中有几个同样的</p><p>器件，器件地址的可编程部分能最大数量的使这些器件连接到I2C总线上，例如EEPROM器件，</p><p>为了增加系统的EEPROM容量，可能需要多个EEPROM。器件可编程地址位的数量由它可使用的管</p><p>脚决定，比如EEPROM器件一般会留下3个管脚用于可编程地址位。但有些I2C器件在出厂时器件</p><p>地址就设置好了，用户不可以更改（如实时时钟PCF8563的器件地址为固定的7’h51）。所以</p><p>当主机想给某个器件发送数据时，只需向总线上发送接收器件的器件地址即可。</p><p>对于AT24C64而言，其器件地址为1010加3位的可编程地址，3位可编程地址由器件上的3个</p><p>管脚A2、A1、A0（见图 28.3.2）的硬件连接决定。当硬件电路上分别将这三个管脚连接到GND</p><p>或VCC时，就可以设置不同的可编程地址。对于我们的开发板，这3个管脚连接到地。</p><p>进行数据传输时，主机首先向总线上发出开始信号，对应开始位S，然后按照从高到低的</p><p>位序发送器件地址，一般为7bit，第8bit位为读写控制位R/W，该位为0时表示主机对从机进行</p><p>写操作，当该位为1时表示主机对从机进行读操作，然后接收从机响应。对于AT24C64来说，其</p><p>传输器件地址格式如下图所示。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1d7f80efcc924cdbaf91de9c1a71351c><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.4 器件地址格式示意图</p><p>发送完第一个字节（7位器件地址和一位读写控制位）并收到从机正确的应答后就开始发</p><p>送字地址（Word Address）。一般而言，每个兼容I2C协议的器件，内部总会有可供读写的寄</p><p>存器或存储器，对于我们本次实验用到的EEPROM存储器，内部就是一系列顺序编址的存储单元。</p><p>所以，当我们对一个器件中的存储单元（包括寄存器）进行读写时，首先要指定存储单元的地</p><p>址即字地址，然后再向该地址写入内容。该地址为一个或两个字节长度，具体长度由器件内部</p><p>的存储单元的数量决定，当存储单元数量不超过一个字节所能表示的最大数量（2^8=256）时，</p><p>用一个字节表示，超过一个字节所能表示的最大数量时，就需要用两个字节来表示，例如同是</p><p>EEPROM存储器，AT24C02的存储单元容量为2Kbit=256Byte（一般bit缩写为b，Byte缩写为B），用一个字节地址即可寻址所有的存储单元，而AT24C64的存储单元容量为64Kb=8KB，需要13位</p><p>（2^13=8KB）的地址位，而I2C又是以字节为单位进行传输的，所以需要用两个字节地址来寻</p><p>址整个存储单元。图 28.1.4 和图 28.1.5分别为单字节字地址和双字节字地址器件的地址分</p><p>布图，其中单字节字地址的器件是以存储容量为2Kb的EEPROM存储器AT24C02为例，双字节字地</p><p>址的器件是以存储容量为64Kb的EEPROM存储器AT24C64为例，WA7即字地址Word Address的第7</p><p>位，以此类推，用WA是为了区别前面器件地址中的A。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d588fe8afe954c27813c10dcb77c7a22><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.4 单字节字地址分布</p><p><br></p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e4842632f9e2472b9bb8630f3d079f61><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.5 双字节字地址分布</p><p>主机发送完字地址，从机正确应答后就把内部的存储单元地址指针指向该单元。如果读写</p><p>控制位R/W位为“0”即写命令，从机就处于接收数据的状态，此时，主机就开始写数据了。写</p><p>数据分为单次写（对于EEPROM而言，称为字节写）和连续写（对于EEPROM而言，称为页写），</p><p>那么这两者有什么区别呢？对比图 28.1.6和图 28.1.7可知，两者的区别在于发送完一字节</p><p>数据后，是发送结束信号还是继续发送下一字节数据，如果发送的是结束信号，就称为单次写，</p><p>如果继续发送下一字节数据，就称为连续写。图 28.1.6是AT24C64的单次写（字节写）时序，对于字地址为单字节的I2C器件而言，在发送完字地址（对应图 28.1.6的字地址高位），且从</p><p>机应答后即可串行发送8bit数据。图 28.1.7是AT24C64连续写（页写）时序。要注意的是，对</p><p>于AT24C64的页写，是不能发送超过一页的单元容量的数据的，而AT24C64的一页的单元容量为</p><p>32Byte，当写完一页的最后一个单元时，地址指针指向该页的开头，如果再写入数据，就会覆</p><p>盖该页的起始数据。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b82d267760574f90aaaaa568bb15a3e3><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.6 单次写（字节写）时序</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52912b281c6144ca919e68dc5442a371><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.7 连续写（页写）时序</p><p>如果读写控制位R/W位为“1”即读命令，主机就处于接收数据的状态，从机从该地址单元</p><p>输出数据。读数据有三种方式：当前地址读、随机读和连续读。当前地址读是指在一次读或写</p><p>操作后发起读操作。由于I2C器件在读写操作后，其内部的地址指针自动加一，因此当前地址</p><p>读可以读取下一个字地址的数据。也就是说上次读或写操作的单元地址为02时，当前地址读的内容就是地址03处的单元数据，时序图如图 28.1.8所示。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1010474168f946b8a94cc7534e7be905><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.8 当前地址读时序</p><p>由于当前地址读极不方便读取任意的地址单元的数据，所以就有了随机读，随机读的时序</p><p>有点奇怪，见图 28.1.9，发送完器件地址和字地址后，竟然又发送起始信号和器件地址，而</p><p>且第一次发送器件地址时后面的读写控制位为“0”，也就是写命令，第二次发送器件地址时</p><p>后面的读写控制位为“1”，也就是读。为什么会有这样奇怪的操作呢？这是因为我们需要使</p><p>从机内的存储单元地址指针指向我们想要读取的存储单元地址处，所以首先发送了一次Dummy</p><p>Write也就是虚写操作，只所以称为虚写，是因为我们并不是真的要写数据，而是通过这种虚</p><p>写操作使地址指针指向虚写操作中字地址的位置，等从机应答后，就可以以当前地址读的方式</p><p>读数据了，如图 28.1.9所示，随机地址读是没有发送数据的单次写操作和当前地址读操作的</p><p>结合体。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/17bf56456294400aa3a716309225a84c><p class=pgc-img-caption></p></div><p><br></p><p>图 28.1.9 随机地址读时序</p><p>至于连续读，对应的是当前地址读和随机读都是一次读取一个字节而言的，它是将当前地</p><p>址读或随机读的主机非应答改成应答，表示继续读取数据，图 28.1.10是在当前地址读下的连</p><p>续读。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1fd48149af604cb0a7b6c6d508a07d2b><p class=pgc-img-caption></p></div><p>图 28.1.10 顺序读时序</p><p>至此，I2C协议就基本讲完了，本章我们主要采用单次写和随机读方式进行EEPROM读写测</p><p>试。</p><p><strong>实验任务</strong></p><p>本次实验任务是先通过FPGA从EEPROM（AT24C64）的存储器地址0至存储器地址255分别写</p><p>入数据0~255；写完之后再开始读取存储器地址0~ 255中的数据，若读取的值正确则LED灯常亮，</p><p>否则LED灯闪烁。</p><p><strong>硬件设计</strong></p><p>AT24C64芯片的常用封装形式有直插（DIP8）式和贴片（SO-8）式两种，无论是直插式还</p><p>是贴片式，其引脚功能与序号都一样，我们开发板上采用的是贴片式，实物图和引脚图分别如</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2216e1f820c44a96a067be20d64bf0f7><p class=pgc-img-caption></p></div><p><br></p><p>图 28.3.1和图 28.3.2所示。</p><p>图 28.3.1 开发板上的AT24C64实物图</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1fc0801ba14d429fafb2809d75da5bbd><p class=pgc-img-caption></p></div><p>AT24C64的引脚功能如下：</p><p>A2,A1,A0：可编程地址输入端。</p><p>GND：电源地引脚</p><p>SDA：SDA（Serial Data，串行数据）是双向串行数据输入/输出端。</p><p>SCL：SCL（Serial clock，串行时钟）串行时钟输入端。</p><p>WP（写保护）：AT24C64有一个写保护引脚用于提供数据保护，当写保护引脚连接至GND时，</p><p>芯片可以正常写，当写保护引脚连接至VCC时，使能写保护功能，此时禁止向芯片写入数据，</p><p>只能进行读操作。</p><p>VCC：电源输入引脚</p><p>我们的开拓者FPGA开发板上EEPROM的原理图如图 28.3.3所示：</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/26096342278f4f0b80e803e139ae8e7b><p class=pgc-img-caption></p></div><p><br></p><p>图 28.3.3 EEPROM原理图</p><p>由上图可知，我们开发板上的EEPROM可编程地址A2、A1、A0连接到地，所以AT24C64的器</p><p>件地址为1010000，如下图所示：</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d85285418b241b0a4e11df321c6ed90><p class=pgc-img-caption></p></div><p>图 28.3.4 AT24C64的器件地址</p><p>本实验中，系统时钟、按键复位以及EEPROM的SCL和SDA的管脚分配如下表所示：</p><p>表 28.3.1 串口通信实验管脚分配</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e745209797349668f21a36b131d2f3d><p class=pgc-img-caption></p></div><p><strong>程序设计</strong></p><p>根据实验任务，我们可以大致规划出系统的控制流程：首先FPGA向EEPROM写数据，写完之</p><p>后从EEPROM读出所写入的数据，并判断读出的数据与写入的数据是否相同，如果相同则LED灯</p><p>常亮，否则LED灯闪烁。由此画出系统的功能框图如下图所示：</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7127ca624edf41abafbdf2611da40bf9><p class=pgc-img-caption></p></div><p><br></p><p>图 28.4.1 EEPROM读写实验系统框图</p><p>由系统总体框图可知，FPGA部分包括四个模块，顶层模块（e2prom_top）、读写模块</p><p>（e2prom_rw）、I2C驱动模块（i2c_dri）和LED灯显示模块（led_alarm）。其中在顶层模块</p><p>中完成对I2C驱动模块的例化。</p><p>各模块端口及信号连接如图 28.4.2所示：</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2c112965e25246f597f020dfc2e8e1a2><p class=pgc-img-caption></p></div><p><br></p><p>图 28.4.2 顶层模块原理图</p><p>i2c_dri为I2C驱动模块，用来驱动I2C的读写操作。当FPGA通过EEPROM读写模块e2prom_rw</p><p>向EEPROM读写数据时，拉高i2c触发控制信号i2c_exec以使能I2C驱动模块，并使用读写控制信</p><p>号i2c_rh_wl控制读写操作，当i2c_rh_wl为低电平时，I2C驱动模块i2c_dri执行写操作，当</p><p>i2c_rh_wl为高电平时，I2C驱动模块i2c_dri执行读操作。此外，e2prom_rw模块通过i2c_addr</p><p>接口向i2c_dri模块输入器件字地址，通过i2c_data_w接口向i2c_dri模块输入写的数据，并通</p><p>过i2c_data_r接口读取i2c_dri模块读到的数据。error_flag是错误标志，用来控制led的显示</p><p>状态。</p><p>顶层模块的代码如下：</p><p>1 <strong>module </strong>e2prom_top<strong>(</strong></p><p>2 //system clock</p><p>3 <strong>input</strong> sys_clk <strong>,</strong> // 系统时钟</p><p>4 <strong>input</strong> sys_rst_n <strong>,</strong> // 系统复位</p><p>5 //eeprom interface</p><p>6 <strong>output</strong> scl <strong>,</strong> // eeprom的时钟线scl</p><p>7 <strong>inout</strong> sda <strong>,</strong> // eeprom的数据线sda</p><p>8 //user interface</p><p>9 <strong>output</strong> <strong>[</strong>3<strong>:</strong>0<strong>] </strong>led // led显示</p><p>10 <strong>);</strong></p><p>11</p><p>12 //parameter define</p><p>13 <strong>parameter</strong> SLAVE_ADDR <strong>=</strong> 7'b1010000 <strong>; </strong>// 器件地址</p><p>14 <strong>parameter</strong> BIT_CTRL <strong>=</strong> 1'b1 <strong>; </strong>// 字地址位控制参数(16b/8b)</p><p>15 <strong>parameter</strong> CLK_FREQ <strong>= </strong>26'd50_000_000<strong>; </strong>// i2c_dri模块的驱动时钟频率</p><p>16 <strong>parameter</strong> I2C_FREQ <strong>= </strong>18'd250_000 <strong>; </strong>// I2C的SCL时钟频率</p><p>17 <strong>parameter</strong> L_TIME <strong>= </strong>17'd125_000 <strong>; </strong>// led闪烁时间参数</p><p>18</p><p>19 //reg define</p><p>20 <strong>reg</strong> <strong>[</strong>25<strong>:</strong>0<strong>]</strong> cnt <strong>;</strong> // 计数</p><p>21 <strong>reg</strong> <strong>[ </strong>1<strong>:</strong>0<strong>]</strong> flow_cnt <strong>;</strong> // 状态流控制</p><p>22 <strong>reg</strong> <strong>[</strong>13<strong>:</strong>0<strong>]</strong> wait_cnt <strong>;</strong> // 等待计数</p><p>23</p><p>24 //wire define</p><p>25 <strong>wire</strong> clk <strong>;</strong> // I2C操作时钟</p><p>26 <strong>wire</strong> i2c_exec <strong>;</strong> // i2c触发控制</p><p>27 <strong>wire</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> i2c_addr <strong>;</strong> // i2c操作地址</p><p>28 <strong>wire</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_w<strong>;</strong> // i2c写入的数据</p><p>29 <strong>wire</strong> i2c_done <strong>;</strong> // i2c操作结束标志</p><p>30 <strong>wire</strong> i2c_rh_wl <strong>;</strong> // i2c读写控制</p><p>31 <strong>wire</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_r<strong>;</strong> // i2c读出的数据</p><p>32 <strong>wire</strong> error_flag<strong>;</strong> // 错误标志</p><p>33</p><p>34 //*****************************************************</p><p>35 //** main code</p><p>36 //*****************************************************</p><p>37</p><p>38 //例化e2prom读写模块</p><p>39 e2prom_rw u_e2prom_rw <strong>(</strong></p><p>40 //global clock</p><p>41 <strong>.</strong>clk <strong>(</strong>clk <strong>),</strong> // 时钟信号</p><p>42 <strong>.</strong>rst_n <strong>(</strong>sys_rst_n <strong>),</strong> // 复位信号</p><p>43 //i2c interface</p><p>44 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C触发执行信号</p><p>45 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl <strong>),</strong> // I2C读写控制信号</p><p>46 <strong>.</strong>i2c_addr <strong>(</strong>i2c_addr <strong>),</strong> // I2C器件内地址</p><p>47 <strong>.</strong>i2c_data_w <strong>(</strong>i2c_data_w<strong>),</strong> // I2C要写的数据</p><p>48 <strong>.</strong>i2c_data_r <strong>(</strong>i2c_data_r<strong>),</strong> // I2C读出的数据</p><p>49 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I2C一次操作完成</p><p>50 //user interface</p><p>51 <strong>.</strong>error_flag <strong>(</strong>error_flag<strong>)</strong> // 错误标志</p><p>52 <strong>);</strong></p><p>53</p><p>54 //例化i2c_dri</p><p>55 i2c_dri <strong>#(</strong></p><p>56 <strong>.</strong>SLAVE_ADDR <strong>(</strong>SLAVE_ADDR<strong>),</strong> // slave address从机地址，放此处方便参数传递</p><p>57 <strong>.</strong>CLK_FREQ <strong>(</strong>CLK_FREQ <strong>),</strong> // i2c_dri模块的驱动时钟频率(CLK_FREQ)</p><p>58 <strong>.</strong>I2C_FREQ <strong>(</strong>I2C_FREQ <strong>)</strong> // I2C的SCL时钟频率</p><p>59 <strong>) </strong>u_i2c_dri<strong>(</strong></p><p>60 //global clock</p><p>61 <strong>.</strong>clk <strong>(</strong>sys_clk <strong>),</strong> // i2c_dri模块的驱动时钟(CLK_FREQ)</p><p>62 <strong>.</strong>rst_n <strong>(</strong>sys_rst_n <strong>),</strong> // 复位信号</p><p>63 //i2c interface</p><p>64 <strong>.</strong>i2c_exec <strong>(</strong>i2c_exec <strong>),</strong> // I2C触发执行信号</p><p>65 <strong>.</strong>bit_ctrl <strong>(</strong>BIT_CTRL <strong>),</strong> // 器件地址位控制(16b/8b)</p><p>66 <strong>.</strong>i2c_rh_wl <strong>(</strong>i2c_rh_wl <strong>),</strong> // I2C读写控制信号</p><p>67 <strong>.</strong>i2c_addr <strong>(</strong>i2c_addr <strong>),</strong> // I2C器件内地址</p><p>68 <strong>.</strong>i2c_data_w <strong>(</strong>i2c_data_w<strong>),</strong> // I2C要写的数据</p><p>69 <strong>.</strong>i2c_data_r <strong>(</strong>i2c_data_r<strong>),</strong> // I2C读出的数据</p><p>70 <strong>.</strong>i2c_done <strong>(</strong>i2c_done <strong>),</strong> // I 2C一次操作完成</p><p>71 <strong>.</strong>scl <strong>(</strong>scl <strong>),</strong> // I2C的SCL时钟信号</p><p>72 <strong>.</strong>sda <strong>(</strong>sda <strong>),</strong> // I2C的SDA信号</p><p>73 //user interface</p><p>74 <strong>.</strong>dri_clk <strong>(</strong>clk <strong>)</strong> // I2C操作时钟</p><p>75 <strong>);</strong></p><p>76</p><p>77 //例化led_alarm模块</p><p>78 led_alarm <strong>#(.</strong>L_TIME<strong>(</strong>L_TIME <strong>)</strong> // 控制led闪烁时间</p><p>79 <strong>) </strong>u_led_alarm<strong>(</strong></p><p>80 //system clock</p><p>81 <strong>.</strong>clk <strong>(</strong>sys_clk <strong>),</strong> // 时钟信号</p><p>82 <strong>.</strong>rst_n <strong>(</strong>sys_rst_n <strong>),</strong> // 复位信号</p><p>83 //led interface</p><p>84 <strong>.</strong>led <strong>(</strong>led <strong>),</strong> // LED灯</p><p>85 //user interface</p><p>86 <strong>.</strong>error_flag <strong>(</strong>error_flag<strong>)</strong> // 错误标志</p><p>87 <strong>);</strong></p><p>88 <strong>endmodule</strong></p><p>顶层模块中主要完成对其余模块的例化，需要注意的是程序第13行到第17行定义了五个参</p><p>数，在模块例化时会将这些变量传递到相应的模块。</p><p>当程序用于读写不同器件地址的EEPROM时将SLAVE_ADDR修改为新的器件地址；字地址位控</p><p>制参数(16b/8b)BIT_CTRL是用来控制不同字地址的I2C器件读写时序中字地址的位数，当I2C器</p><p>件的字地址为16位时，参数BIT_CTRL设置为“1”，当I2C器件的字地址为8位时，参数BIT_CTRL</p><p>设置为“0”；i2c_dri模块的驱动时钟频率CLK_FREQ是指在例化I2C驱动模块i2c_dri时，驱动</p><p>i2c_dri模块的时钟频率；I2C的SCL时钟频率参数I2C_FREQ是用来控制I2C协议中的SCL的频率，</p><p>一般不超过400KHz；led闪烁时间参数L_TIME用来控制led的闪烁间隔时间，参数值与驱动该模</p><p>块的clk时钟频率有关。例如，控制led闪烁的间隔时间为0.25s，clk的频率为1MHz时，</p><p>0.25s/1us=250000，由于代码中当计数器计数到L_TIME的值时，LED的状态改变一次，LED高电</p><p>平加上低电平的时间才是一次闪烁的时间，所以L_TIME的值应定义成125000。</p><p>由前面的I2C读写操作时序图我们可以发现，I2C驱动模块非常适合采用状态机来编写。无</p><p>论是字节写（图 28.1.6）还是随机读（图 28.1.9），都要先从空闲状态开始，先发送起始信</p><p>号，然后发送器件地址和读写命令（这里为了方便表示我们使用“控制命令”来表示器件地址</p><p>和读写命令）。发送完控制命令并接收应答信号后发送字地址，然后就可以进行读写数据的传</p><p>输了。读写数据传输结束后接收应答信号，最后发送停止信号，此时I2C读写操作结束，再次</p><p>进入空闲状态。</p><p>状态机的状态跳转图如下所示，总共有8个状态，一开始状态机处于空闲状态st_idle，当</p><p>I2C触发执行信号触发（i2c_exec=1）时，状态机进入发送控制命令状态st_sladdr；发送完控</p><p>制命令后就发送字地址，这里出于简单考虑，不对从机EEPROM的应答信号进行判断。由于字地</p><p>址存在单字节和双字节的区别，我们通过bit_ctrl信号判断是单字节还是双字节字地址。对于</p><p>双字节的字地址我们先发送高8位即第一个字节，发送完高8位后进入发送8位字地址状态st_addr8，也就是发送双字节地地址的低8位；对於单字节的字地址我们直接进入发送8位字地址</p><p>状态st_addr8。发送完字地址后，根据读写判断标志来判断是读操作还是写操作。如果是写</p><p>（wr_flag=0）就进入写数据状态st_data_wr，开始向EEPROM发送数据；如果是读（wr_flag=1）</p><p>就进入发送器件地址读状态st_addr_rd发送器件地址，此状态结束后就进入读数据状态</p><p>st_data_rd接收EEPROM输出的数据。读或写数据结束后就进入结束I2C操作状态st_done并发送</p><p>结束信号，此时，I2C总线再次进入空闲状态st_idle。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01c57d8ea1724026bf74ef0af3c47395><p class=pgc-img-caption></p></div><p><br></p><p>图 28.4.3 I2C驱动模块状态跳转图</p><p>在程序中我们采用三段式状态机。由于代码较长，我们在这里将其中第二段的源代码粘贴</p><p>如下：</p><p>105 //组合逻辑判断状态转移条件</p><p>106 <strong>always @( * ) begin</strong></p><p>107 next_state <strong>= </strong>st_idle<strong>;</strong></p><p>108 <strong>case(</strong>cur_state<strong>)</strong></p><p>109 st_idle<strong>: begin</strong> // 空闲状态</p><p>110 <strong>if(</strong>i2c_exec<strong>) begin</strong></p><p>111 next_state <strong>= </strong>st_sladdr<strong>;</strong></p><p>112 <strong>end</strong></p><p>113 <strong>else</strong></p><p>114 next_state <strong>= </strong>st_idle<strong>;</strong></p><p>115 <strong>end</strong></p><p>116 st_sladdr<strong>: begin</strong></p><p>117 <strong>if(</strong>st_done<strong>) begin</strong></p><p>118 <strong>if(</strong>bit_ctrl<strong>)</strong> // 判断是16位还是8位字地址</p><p>119 next_state <strong>= </strong>st_addr16<strong>;</strong></p><p>120 <strong>else</strong></p><p>121 next_state <strong>= </strong>st_addr8 <strong>;</strong></p><p>122 <strong>end</strong></p><p>123 <strong>else</strong></p><p>124 next_state <strong>= </strong>st_sladdr<strong>;</strong></p><p>125 <strong>end</strong></p><p>126 st_addr16<strong>: begin</strong> // 写16位字地址</p><p>127 <strong>if(</strong>st_done<strong>) begin</strong></p><p>128 next_state <strong>= </strong>st_addr8<strong>;</strong></p><p>129 <strong>end</strong></p><p>130 <strong>else begin</strong></p><p>131 next_state <strong>= </strong>st_addr16<strong>;</strong></p><p>132 <strong>end</strong></p><p>133 <strong>end</strong></p><p>134 st_addr8<strong>: begin</strong> // 8位字地址</p><p>135 <strong>if(</strong>st_done<strong>) begin</strong></p><p>136 <strong>if(</strong>wr_flag<strong>==</strong>1'b0<strong>)</strong> // 读写判断</p><p>137 next_state <strong>= </strong>st_data_wr<strong>;</strong></p><p>138 <strong>else</strong></p><p>139 next_state <strong>= </strong>st_addr_rd<strong>;</strong></p><p>140 <strong>end</strong></p><p>141 <strong>else begin</strong></p><p>142 next_state <strong>= </strong>st_addr8</p><p>143 <strong>end</strong></p><p>144 <strong>end</strong></p><p>145 st_data_wr<strong>: begin</strong> // 写数据(8 bit)</p><p>146 <strong>if(</strong>st_done<strong>)</strong></p><p>147 next_state <strong>= </strong>st_stop<strong>;</strong></p><p>148 <strong>else</strong></p><p>149 next_state <strong>= </strong>st_data_wr<strong>;</strong></p><p>150 <strong>end</strong></p><p>151 st_addr_rd<strong>: begin</strong> // 写地址以进行读数据</p><p>152 <strong>if(</strong>st_done<strong>) begin</strong></p><p>153 next_state <strong>= </strong>st_data_rd<strong>;</strong></p><p>154 <strong>end</strong></p><p>155 <strong>else begin</strong></p><p>156 next_state <strong>= </strong>st_addr_rd<strong>;</strong></p><p>157 <strong>end</strong></p><p>158 <strong>end</strong></p><p>159 st_data_rd<strong>: begin</strong> // 读取数据(8 bit)</p><p>160 <strong>if(</strong>st_done<strong>)</strong></p><p>161 next_state <strong>= </strong>st_stop<strong>;</strong></p><p>162 <strong>else</strong></p><p>163 next_state <strong>= </strong>st_data_rd<strong>;</strong></p><p>164 <strong>end</strong></p><p>165 st_stop<strong>: begin</strong> // 结束I2C操作</p><p>166 <strong>if(</strong>st_done<strong>)</strong></p><p>167 next_state <strong>= </strong>st_idle<strong>;</strong></p><p>168 <strong>else</strong></p><p>169 next_state <strong>= </strong>st_stop <strong>;</strong></p><p>170 <strong>end</strong></p><p>171 <strong>default: </strong>next_state<strong>= </strong>st_idle<strong>;</strong></p><p>172 <strong>endcase</strong></p><p>173 <strong>end</strong></p><p>我们可以对照着图 28.4.3来分析程序中各状态之间是如何跳转的。</p><p>EEPROM读写模块主要实现对I2C读写过程的控制，包括给出字地址及需要写入该地址中的数据、启动I2C读写操作、判断读写数据是否一致等。EEPROM读写模块的代码如下：</p><p>1 <strong>module </strong>e2prom_rw<strong>(</strong></p><p>2 //global clock</p><p>3 <strong>input</strong> clk <strong>,</strong> // 时钟信号</p><p>4 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>5</p><p>6 //i2c interface</p><p>7 <strong>output</strong> i2c_rh_wl <strong>,</strong> // I2C读写控制信号</p><p>8 <strong>output</strong> <strong>reg</strong> i2c_exec <strong>,</strong> // I2C触发执行信号</p><p>9 <strong>output</strong> <strong>reg</strong> <strong>[</strong>15<strong>:</strong>0<strong>]</strong> i2c_addr <strong>,</strong> // I2C器件字地址</p><p>10 <strong>output</strong> <strong>reg</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_w <strong>,</strong> // I2C要写的数据</p><p>11 <strong>input</strong> <strong>[ </strong>7<strong>:</strong>0<strong>]</strong> i2c_data_r <strong>,</strong> // I2C读出的数据</p><p>12 <strong>input</strong> i2c_done <strong>,</strong> // I2C一次操作完成</p><p>13</p><p>14 //user interface</p><p>15 <strong>output</strong> <strong>reg</strong> error_flag // 错误标志</p><p>16 <strong>);</strong></p><p>17</p><p>18 //parameter define</p><p>19 <strong>parameter</strong> WAIT <strong>= </strong>14'd5000 <strong>;</strong> // 读写等待时间</p><p>20 <strong>parameter</strong> BYTE_N <strong>= </strong>16'd255 <strong>;</strong> // 读写的字节数</p><p>21</p><p>22 //reg define</p><p>23 <strong>reg</strong> addr_over <strong>;</strong> // 地址结束标志</p><p>24 <strong>reg</strong> rom_w_done<strong>;</strong> // 字节全部写入e2prom的标志</p><p>25 <strong>reg</strong> <strong>[ </strong>1<strong>:</strong>0<strong>]</strong> flow_cnt <strong>;</strong> // 状态流控制</p><p>26 <strong>reg</strong> <strong>[</strong>13<strong>:</strong>0<strong>]</strong> wait_cnt <strong>;</strong> // 等待计数</p><p>27</p><p>28 //*****************************************************</p><p>29 //** main code</p><p>30 //*****************************************************</p><p>31</p><p>32 //读写控制</p><p>33 <strong>assign </strong>i2c_rh_wl <strong>= </strong>addr_over <strong>& </strong>rom_w_done<strong>;</strong></p><p>34</p><p>35 //eeprom字节地址配置</p><p>36 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>37 <strong>if(</strong>rst_n <strong>== </strong>1'b0<strong>) begin</strong></p><p>38 i2c_addr <strong>&lt;= </strong>16'd0<strong>;</strong></p><p>39 addr_over<strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>40 <strong>end</strong></p><p>41 <strong>else if(</strong>i2c_done <strong>== </strong>1'b1<strong>) begin</strong></p><p>42 <strong>if(</strong>i2c_rh_wl <strong>== </strong>1'b1<strong>) begin</strong></p><p>43 <strong>if(</strong>i2c_addr <strong>&lt; </strong>BYTE_N<strong>)</strong></p><p>44 i2c_addr <strong>&lt;= </strong>i2c_addr <strong>+ </strong>1'd1<strong>;</strong></p><p>45 <strong>else</strong></p><p>46 i2c_addr <strong>&lt;= </strong>i2c_addr<strong>;</strong></p><p>47 <strong>end</strong></p><p>48 <strong>else begin</strong></p><p>49 <strong>if(</strong>i2c_addr <strong>== </strong>BYTE_N<strong>) begin</strong></p><p>50 i2c_addr <strong>&lt;= </strong>16'd0<strong>;</strong></p><p>51 addr_over<strong>&lt;=</strong> 1'b1<strong>;</strong> //写完指定地址标志</p><p>52 <strong>end</strong></p><p>53 <strong>else</strong></p><p>54 i2c_addr <strong>&lt;= </strong>i2c_addr <strong>+ </strong>1'd1<strong>;</strong></p><p>55 <strong>end</strong></p><p>56 <strong>end</strong></p><p>57 <strong>else</strong></p><p>58 i2c_addr <strong>&lt;= </strong>i2c_addr<strong>;</strong></p><p>59 <strong>end</strong></p><p>60</p><p>61 //读写eeprom</p><p>62 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>63 <strong>if(</strong>rst_n <strong>== </strong>1'b0<strong>) begin</strong></p><p>64 flow_cnt <strong>&lt;=</strong> 2'b0<strong>;</strong></p><p>65 wait_cnt <strong>&lt;= </strong>14'b0<strong>;</strong></p><p>66 i2c_exec <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>67 i2c_data_w <strong>&lt;=</strong> 8'd0<strong>;</strong></p><p>68 rom_w_done <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>69 error_flag <strong>&lt;=</strong> 1'b1<strong>;</strong></p><p>70 <strong>end</strong></p><p>71 <strong>else begin</strong></p><p>72 i2c_exec <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>73 //从eeprom的第1页的第1个字节到第16页的第16个字节(共256字节)写入数据0~255</p><p>74 <strong>if(</strong>i2c_rh_wl <strong>== </strong>1'b0<strong>) begin</strong></p><p>75 <strong>case(</strong>flow_cnt<strong>)</strong></p><p>76 2'd0<strong>: begin</strong></p><p>77 rom_w_done <strong>&lt;=</strong> 1'b0<strong>;</strong></p><p>78 wait_cnt <strong>&lt;= </strong>wait_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>79 <strong>if(</strong>wait_cnt <strong>== </strong>14'd100<strong>) begin</strong></p><p>80 wait_cnt <strong>&lt;= </strong>14'd0<strong>;</strong></p><p>81 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>82 <strong>end</strong></p><p>83 <strong>end</strong></p><p>84 2'd1<strong>: begin</strong></p><p>85 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>86 i2c_data_w <strong>&lt;= </strong>i2c_addr<strong>[</strong>7<strong>:</strong>0<strong>];</strong></p><p>87 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>88 <strong>end</strong></p><p>89 2'd2<strong>: begin</strong></p><p>90 <strong>if(</strong>i2c_done <strong>== </strong>1'b1<strong>)</strong></p><p>91 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>92 <strong>end</strong></p><p>93 2'd3<strong>:begin</strong></p><p>94 <strong>if(</strong>wait_cnt <strong>== </strong>WAIT<strong>) begin</strong> //写间隔控制</p><p>95 flow_cnt <strong>&lt;=</strong> 2'b0<strong>;</strong></p><p>96 wait_cnt <strong>&lt;= </strong>14'd0<strong>;</strong></p><p>97 rom_w_done <strong>&lt;=</strong> 1'b1<strong>;</strong></p><p>98 <strong>end</strong></p><p>99 <strong>else</strong></p><p>100 wait_cnt <strong>&lt;= </strong>wait_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>101 <strong>end</strong></p><p>102 <strong>endcase</strong></p><p>103 <strong>end</strong></p><p>104 //读取从eeprom的第1页的第1个字节开始的共256字节的值并判断值是否正确</p><p>105 <strong>else begin</strong></p><p>106 <strong>case(</strong>flow_cnt<strong>)</strong></p><p>107 2'd0<strong>: begin</strong></p><p>108 wait_cnt <strong>&lt;= </strong>wait_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>109 <strong>if(</strong>wait_cnt <strong>== </strong>14'd100<strong>) begin</strong></p><p>110 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>111 wait_cnt <strong>&lt;= </strong>14'd0<strong>;</strong></p><p>112 <strong>end</strong></p><p>113 <strong>end</strong></p><p>114 2'd1<strong>: begin</strong></p><p>115 i2c_exec <strong>&lt;= </strong>1'b1<strong>;</strong></p><p>116 flow_cnt <strong>&lt;= </strong>flow_cnt <strong>+ </strong>1'b1<strong>;</strong></p><p>117 <strong>end</strong></p><p>118 2'd2<strong>: begin</strong></p><p>119 <strong>if(</strong>i2c_done <strong>== </strong>1'b1<strong>) begin</strong> // 判断I2C操作是否完成</p><p>120 <strong>if(</strong>i2c_addr<strong>[</strong>7<strong>:</strong>0<strong>] == </strong>i2c_data_r<strong>) begin</strong> // 判断读到的值正确与否</p><p>121 error_flag <strong>&lt;= </strong>1'b0<strong>;</strong> // 读到的值正确</p><p>122 flow_cnt <strong>&lt;= </strong>2'b0<strong>;</strong> // 返回状态0</p><p>123 <strong>end</strong></p><p>124 <strong>else begin</strong></p><p>125 error_flag <strong>&lt;= </strong>1'b1<strong>;</strong> // 读到的值错误</p><p>126 <strong>end</strong></p><p>127 <strong>end</strong></p><p>128 <strong>end</strong></p><p>129 <strong>default: </strong>flow_cnt <strong>&lt;= </strong>2'b0<strong>;</strong></p><p>130 <strong>endcase</strong></p><p>131 <strong>end</strong></p><p>132 <strong>end</strong></p><p>133 <strong>end</strong></p><p>134</p><p>135 <strong>endmodule</strong></p><p>程序中第62行的always块是读写控制块，具体是读还是写由I2C读写控制信号i2c_rh_wl决</p><p>定。当该信号为低电平时，为写数据操作，从EEPROM的存储地址0开始，每写入一个字节的数</p><p>据，地址加1，直至写入指定的字节数（BYTE_N）。当写最后一个存储地址结束后，写EEPROM</p><p>结束的标志信号rom_w_done拉高，写数据过程结束。由程序第33行可知，此时i2c_rh_wl为高</p><p>电平，程序进入读数据过程。由于写入每个存储单元的数据与该单元的地址相同，所以当读到</p><p>的数据与该存储单元的地址相等时，表明读写一致，错误标志信号error_flag为低电平；若两</p><p>者不相等，则说明读写过程发生错误，此时将error_flag拉高，结束读操作。图 28.4.4为写</p><p>过程中SignalTap抓取的波形图：</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4163c88e20694b7d91793d50879a2e56><p class=pgc-img-caption></p></div><p><br></p><p>图 28.4.4 写过程中SignalTap抓取的波形图</p><p>从该波形图中我们看到读写控制信号i2c_rh_wl为低电平，表示处于写操作状态。当I2C触</p><p>发执行信号i2c_exec为高电平时开始执行I2C写操作，从上图中可以看到当前写的存储单元地</p><p>址为0000h，写入的数据为00h。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2671254118d546cfb195db7310651930><p class=pgc-img-caption></p></div><p><br></p><p>图 28.4.5为读过程中SignalTap抓取的波形图。</p><p>图 28.4.5 读过程中SignalTap抓取的波形图</p><p>从该波形图中我们看到读写控制信号i2c_rh_wl为高电平，表示处于读操作状态，当I2C触</p><p>发执行信号i2c_exec为高电平时开始执行I2C读操作，从上图中可以看到当前读的存储单元地</p><p>址为0001h，读到的数据为01h。</p><p>led显示模块利用LED灯的显示状态来标识读写过程是否出错，在模块中通过检测错误标志</p><p>信号error_flag来改变LED灯的显示状态。</p><p>LED显示模块led_alarm代码如下：</p><p>1 <strong>module </strong>led_alarm <strong>#(parameter</strong> L_TIME <strong>= </strong>25'd25_000_000 // 控制led闪烁间隔时间</p><p>2 <strong>)(</strong> // 此处为500ms</p><p>3 //system clock</p><p>4 <strong>input</strong> clk <strong>,</strong> // 时钟信号</p><p>5 <strong>input</strong> rst_n <strong>,</strong> // 复位信号</p><p>6</p><p>7 //led interface</p><p>8 <strong>output</strong> <strong>[</strong>3<strong>:</strong>0<strong>]</strong> led <strong>, </strong>// LED 灯</p><p>9</p><p>10 //user interface</p><p>11 <strong>input</strong> error_flag // 错误标志</p><p>12 <strong>);</strong></p><p>13</p><p>14 //reg define</p><p>15 <strong>reg</strong> led_t <strong>;</strong> // 使用的led灯</p><p>16 <strong>reg</strong> <strong>[</strong>24<strong>:</strong>0<strong>]</strong> led_cnt<strong>;</strong> // led计数</p><p>17</p><p>18 //*****************************************************</p><p>19 //** main code</p><p>20 //*****************************************************</p><p>21</p><p>22 //led输出</p><p>23 <strong>assign</strong> led <strong>= {</strong>3'b000<strong>,</strong>led_t<strong>};</strong></p><p>24</p><p>25 //错误标志为1时led闪烁，否则，LED0常亮</p><p>26 <strong>always @(posedge </strong>clk <strong>or negedge </strong>rst_n<strong>) begin</strong></p><p>27 <strong>if(</strong>rst_n <strong>== </strong>1'b0<strong>) begin</strong></p><p>28 led_cnt <strong>&lt;= </strong>25'd0<strong>;</strong></p><p>29 led_t <strong>&lt;= </strong>1'b0<strong>;</strong></p><p>30 <strong>end</strong></p><p>31 <strong>else begin</strong></p><p>32 <strong>if(</strong>error_flag<strong>) begin</strong> // 读到的值错误</p><p>33 led_cnt <strong>&lt;= </strong>led_cnt <strong>+ </strong>25'd1<strong>;</strong></p><p>34 <strong>if(</strong>led_cnt <strong>== </strong>L_TIME<strong>) begin</strong> // 数据错误时LED灯每隔L_TIME时间闪烁一次</p><p>35 led_cnt <strong>&lt;= </strong>25'd0<strong>;</strong></p><p>36 led_t <strong>&lt;= ~</strong>led_t<strong>;</strong></p><p>37 <strong>end</strong></p><p>38 <strong>end</strong></p><p>39 <strong>else begin</strong> // 读完且读到的值正确</p><p>40 led_cnt <strong>&lt;= </strong>25'd0<strong>;</strong></p><p>41 led_t <strong>&lt;= </strong>1'b1<strong>;</strong> // led灯常亮</p><p>42 <strong>end</strong></p><p>43 <strong>end</strong></p><p>44 <strong>end</strong></p><p>45</p><p>46 <strong>endmodule</strong></p><p>程序第一行的参数L_TIME用于控制led闪烁间隔时间，在例化时重新指定参数值，可以改</p><p>变led闪烁的快慢。程序中第32行判断error_flag的值，当error_flag为高电平时表明读写数</p><p>据不一致，此时，led灯每隔L_TIME时间闪烁一次；当error_flag为低电平时，表明读写数据</p><p>一致，EEPROM读写正确，led灯常亮。</p><p><strong>下载验证</strong></p><p>首先我们打开工程，在工程所在的路径下打开e2prom_top/par文件夹，在里面找到</p><p>“e2prom_top.qpf”并双击打开。注意工程所在的路径名只能由字母、数字以及下划线组成，</p><p>不能出现中文、空格以及特殊字符等。EEPROM读写工程打开后如图 28.5.1所示。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/370425be859847788de53ddeee5cc5aa><p class=pgc-img-caption></p></div><p>图 28.5.1 EEPROM读写工程</p><p>接下来我们下载程序，验证EEPROM读写功能。工程打开后通过点击工具栏中的“Programmer”</p><p>图 标 打 开 下 载 界 面 ， 通 过 “ Add File ” 按 钮 选 择 EEPROM 读 写 工 程 中</p><p>e2prom_top/par/output_files 目录下的“e2prom_top.sof”文件。开发板电源打开后，在程</p><p>序下载界面点击“Hardware Setup”，在弹出的对话框中选择当前的硬件连接为“USB</p><p>Blaster[USB-0]”。然后点击“Start”将工程编译完成后得到的 sof 文件下载到开发板中，</p><p>如图 28.5.2所示。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0faf45ad3f344f859cb14ad2a501ed23><p class=pgc-img-caption></p></div><p>图 28.5.2 程序下载界面</p><p>接下来我们下载程序，验证通过I2C协议读写EEPROM功能。下载完成后观察开发板的led显</p><p>示如图 28.5.3所示，led灯常亮，说明通过EEPROM读写程序下载验证正确。</p><div class=pgc-img><img alt=正点原子开拓者FPGA开发板资料连载第二十八章EEPROM读写测试实验 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/239ca09b3ba647dea701ec7a17a646c2><p class=pgc-img-caption></p></div><p><br></p><p>图 28.5.3 开发板LED灯常亮</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'正点','开拓者','FPGA'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正点原子开拓者FPGA开发板资料连载第二十三章RGBTFT-LCD字符显示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/acdfbd47.html title=正点原子开拓者FPGA开发板资料连载第二十三章RGBTFT-LCD字符显示>正点原子开拓者FPGA开发板资料连载第二十三章RGBTFT-LCD字符显示</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/5da0d73c.html alt="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/5da0d73c.html title="正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验">正点原子开拓者FPGA开发板资料连载第三十二章 音频环回实验</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>