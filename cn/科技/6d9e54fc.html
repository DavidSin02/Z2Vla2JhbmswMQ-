<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>dbutils+反射实现自定义ORM框架，完成数据库切换过程 | 极客快訊</title><meta property="og:title" content="dbutils+反射实现自定义ORM框架，完成数据库切换过程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6d9e54fc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6d9e54fc.html><meta property="article:published_time" content="2020-10-29T21:12:23+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:23+08:00"><meta name=Keywords content><meta name=description content="dbutils+反射实现自定义ORM框架，完成数据库切换过程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6d9e54fc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>dbutils+反射实现自定义ORM框架，完成数据库切换过程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">背景</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">产品开发过程中，由于数据库性能问题，需要更换数据库，从一个 NoSQL 数据库切换到 RDB 数据库。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">原 ORM 框架的 DAO 层抽象了一个顶层的父类，换库方案是以此类为基础，重写一整套操作，可以将换库工作量降低到最少。那么工作量就落在了解决 ORM 映射问题上，原来使用的</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999"> </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">BSONObject</span></span> 工具包，直接完成Java对象到 JSON 对象的转换。现在需要利用原始的 JDBC、重写一套 ORM 映射机制。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">本文来介绍 ORM 的实现过程，基本思路是：自定义一个 MyBeanHandler ，利用 Java 反射机制完成 JDBC 的 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ResultSet</span></span> 和 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">JavaBean</span></span> 的转换。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">实现流程</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">基本思路：将数据库的一条查询结果，转换成Java实体类的实例，自定义一个</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ResultHandler</span></span>，接受一个类型 Class。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">由于 select 列可能不是 Java 全部的属性，所以不能遍历 Java 属性列表，在逐个从 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ResultSet</span></span> 获取该列的值，一旦某一列没有被查出来，<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ResultSet</span></span> 的 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">getObject(entityField)</span></span> 的时候直接报异常了。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">所以转换思路，以查询结果列，反向找到该列对应的 Java 类的属性，再用反射调用属性的 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">setter</span></span> 方法，完成实例的组装。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">此外，需要注意 Java 实体类属性的类型和数据库表列的类型，如果存在不一致的话，需要特殊处理。例如：Java 中 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">boolean</span></span> 类型的属性，对应到数据库中是 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">tinyint</span></span> 。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">还有一个特别重要的问题就是 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">ResultSet</span></span> 中获取的元数据信息中，所有的数值列都是 Java的封装类型，即：<strong>tiny/int/bigint 对应的 Class 是 Integer.class</strong> 。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Java 的封装类型和基本类型的 Class 是不同，</span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">int/long/byte/char/float</span></span> 的 Class 是对应的<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">类型名称 .class</span></span> ，如 i<span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">nt.class，long.class</span></span>。因此，调用 <span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">setter</span></span> 方法触发反射的类型一定要传递 Java 实体属性的类型。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">反射获取类属性</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">开发过程中有些模块的实体有公共属性，所以有不少实体类有基础父类属性，这些实体类对应的表字段，除了有自己定义的属性外，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">还必须包括父类的属性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">反射获取实体字段方法时，必须要获取父类所有字段，保证表字段的完整：</span></p><pre><code>	/**	 * 判断某个属性是否是简单属性：所有的简单类型和对应的包装类型都是	 * 	 * @param fieldType	 * @return	 */	public static boolean isSimpleTypeField(Class&lt;?&gt; fieldType) {		if (fieldType == Integer.class ||fieldType == int.class || fieldType == long.class ||fieldType == Long.class || fieldType == String.class				|| fieldType == Short.class || fieldType == Character.class) {			return true;		}		return false;	}		/**	 * 判断某个属性是否是boolean类型，有两种包装类型和原始boolean类型	 * 	 * @param fieldType	 * @return	 */	public static boolean isBooleanTypeField(Class&lt;?&gt; fieldType) {		if (fieldType == Boolean.class ||fieldType==boolean.class) {			return true;		}				return false;	}	/**	 * 获取某一个类的fieleName对应的Field对象，如果当前类没有，从父类获取	 * @comment 异常，不处理	 * @param entityClass	 * @param fieldName	 * @return	 */	public static Field getFieldOfEntity(Class&lt;?&gt; entityClass,String fieldName){		if(fieldName==null){			return null;		}				try {			return entityClass.getDeclaredField(fieldName);		} catch (NoSuchFieldException e) {			try {				return entityClass.getSuperclass().getDeclaredField(fieldName);			} catch (NoSuchFieldException e1) {							} catch (SecurityException e1) {							}		} catch (SecurityException e) {					}				return null;	}</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">此外，数据库表列名称和 Java 属性 setter 直接的映射关系，可以自定义的，通用的方法是二者名称一致，对应的就是 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">setXXX,getXXX,isXXX(boolean类型）</span></span>。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果数据库列表是下划线，那么就是另一种映射关系，这些都可以自定义映射规则的。那么获取</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">列</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">getter/setter</span></span> 方法为：</p><pre><code>/**	 * 获取某个属性的get方法名称	 * 	 * @param name	 * @return	 */	public static String obtainGetterName(String name,boolean isBooleanType) {		//特殊处理boolean类型，统一为isXXX		if(isBooleanType){			return &#34;is&#34; + name.substring(0, 1).toUpperCase()+name.substring(1);		}				return &#34;get&#34; + name.substring(0, 1).toUpperCase()+name.substring(1);	}	/**	 * 获取某个属性的set方法名称	 * 	 * @param name	 * @return	 */	public static String obtainSetterName(String name) {		return &#34;set&#34; + name.substring(0, 1).toUpperCase()+name.substring(1);	}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">自定义BeanHandler</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">按上述思路修正原来实现的 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">BeanHandler</span></span> 如下：</p><pre><code>public class MyBeanHandler&lt;T&gt; implements ResultSetHandler&lt;T&gt; {	private Logger logger = Logger.getLogger(MyBeanHandler.class);	private Class&lt;T&gt; entityClass;	public MyBeanHandler(Class&lt;T&gt; entityClass) {		this.entityClass = entityClass;	}	@Override	public T handle(ResultSet resultSet) {				try {			while (resultSet.next()) {				T result = null;				result = entityClass.newInstance();				ResultSetMetaData metaData = resultSet.getMetaData();				int columnCount = metaData.getColumnCount();				for(int col = 1 ; col &lt;= columnCount ; col++){					String name = metaData.getColumnName(col);					Object oldValue = resultSet.getObject(col);					Object columnValue = oldValue;					if(columnValue==null){//空，直接过滤掉。。。。						continue;					}										//获取该字段名称对应的Java实体类字段声明：updated on 2017-09-05					Field field = IntrospectUtil.getFieldOfEntity(entityClass,name);					if(field==null){					       continue;					}										Class&lt;?&gt; columnType = field.getType();					if (ArrayList.class == columnType || List.class == columnType) {						// 数据库存储的是JSON，回转成List对象						List&lt;Object&gt; list = JSONObject.parseArray(columnValue.toString(), Object.class);						columnValue = list;					} else if (IntrospectUtil.isSimpleTypeField(columnType)) {						// non op 普通属性，直接设置值					} else if(IntrospectUtil.isBooleanTypeField(columnType)){						columnValue = (Integer)oldValue==1 ? Boolean.TRUE:Boolean.FALSE;					}else {						// 复杂对象，且非List，通过JSON转换为对应类型的对象						columnValue = JSONObject.parseObject(columnValue.toString(), columnType);					}					//找到对应简单字段的原始字段类型，作为setter的方法类型					String setter = IntrospectUtil.obtainSetterName(name);					Method method = entityClass.getMethod(setter, columnType);					method.invoke(result, columnValue);				}								return result;			}		} catch (Exception e) {			logger.error(&#34;MyBeanHandler error&#34;, e);		}		return null;	}}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">启示录</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">反射应用时，Class 类的 </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">getDeclaredField</span></span> 能获取当前类的所有属性，静态、非静态的都能获取到。如果插入操作需要根据实体属性集合类定义 insert 后面的字段，<strong>需要排除掉静态成员变量</strong>。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">此外，父类的成员变量即使定义成 protected 的，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">也不能直接被</span></strong><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">子类</span></strong><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999"> </span><span style="color:#c7254e;--tt-darkmode-color: #C7254E"><span style="background-color:#f9f2f4;--tt-darkmode-bgcolor: #C2BCBE">getDeclaredField</span></span> 方法获取到；但是 getMethod 方法不仅能获取到自己的方法，同时也能获取父类继承来的方法。</p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">技术调研的代码和真正实现应用之间，还有一段距离，编程路漫漫呐！</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'dbutils','实现','自定义'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>