<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>连mysql锁的机制都不了解，怎么做架构师 | 极客快訊</title><meta property="og:title" content="连mysql锁的机制都不了解，怎么做架构师 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1533476323070887266574f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6e8f3f2e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6e8f3f2e.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="连mysql锁的机制都不了解，怎么做架构师"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6e8f3f2e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>连mysql锁的机制都不了解，怎么做架构师</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>引言</strong></p><p>数据库锁定机制简单来说就是数据库为了保证数据的一致性而使各种共享资源在被并发访问变得有序所设计的一种规则；对于任何一种数据库来说都需要有相应的锁定机制，Mysql也不例外。</p><p><strong>mysql 事务</strong></p><p>一般来说，事务是必须满足4个条件（ACID）：原子性（Atomicity，或称不可分割性）、一致性（Consistency）、隔离性（Isolation，又称独立性）、持久性（Durability）。</p><ol><li>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ol><p><strong>MYSQL 事务处理主要有两种方法：</strong></p><ol><li>用 BEGIN, ROLLBACK, COMMIT来实现</li><li>1)、BEGIN 开始一个事务</li><li>2)、ROLLBACK 事务回滚</li><li>3)、COMMIT 事务确认</li><li>直接用 SET 来改变 MySQL 的自动提交模式:</li><li>1)、SET AUTOCOMMIT=0 禁止自动提交</li><li>2)、SET AUTOCOMMIT=1 开启自动提交</li></ol><p><strong>事务隔离级别</strong></p><p>mysql事务隔离级别分为如下4种：</p><p>(1)读不提交(Read Uncommited，RU)</p><p>这种隔离级别下，事务间完全不隔离，会产生脏读，可以读取未提交的记录，实际情况下不会使用。</p><p>(2)读提交(Read commited，RC)</p><p>仅能读取到已提交的记录，这种隔离级别下，会存在幻读现象，所谓幻读是指在同一个事务中，多次执行同一个查询，返回的记录不完全相同的现象。幻读产生的根本原因是，在RC隔离级别下，每条语句都会读取已提交事务的更新，若两次查询之间有其他事务提交，则会导致两次查询结果不一致。虽然如此，读提交隔离级别在生产环境中使用很广泛。</p><p>(3)可重复读(Repeatable Read, RR)</p><p>可重复读隔离级别解决了不可重复读的问题，但依然没有解决幻读的问题。那么不可重复读与幻读有什么区别呢？不可重复读重点在修改，即读取过的数据，两次读的值不一样；而幻读则侧重于记录数目变化【插入和删除】。一般教科书上告诉我们只有到串行化隔离级别才解决幻读问题，但mysql的innodb比较特殊，RR即解决了幻读问题，主要通过GAP锁实现。另外，不是所有的数据库都实现了该隔离级别，后面会简单介绍下mysql是如何实现可重复读隔离级别的。</p><p>(4)串行化(Serializable)</p><p>在串行化隔离模式下，消除了脏读，幻象，但事务并发度急剧下降，事务的隔离级别与事务的并发度成反比，隔离级别越高，事务的并发度越低。实际生产环境下，dba会在并发和满足业务需求之间作权衡，选择合适的隔离级别。</p><p><strong>mysql 锁类型</strong></p><p>MySQL 各存储引擎使用了三种类型（级别）的锁定机制：行级锁定，页级锁定和表级锁定。</p><p><strong>1、行级锁定</strong></p><p>锁定对象的颗粒度很小，只对当前行进行锁定，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力；弊端就是获取锁释放锁更加频繁，系统消耗更大，同时行级锁定也最容易发生死锁；</p><p>行级锁定的主要是Innodb存储引擎和NDB Cluster存储引擎；</p><p><strong>2、表级锁定</strong></p><p>一次会将整张表锁定，该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小，而且可以避免死锁问题；弊端就是锁定资源争用的概率最高，并发处理能力最低；</p><p>使用表级锁定的主要是MyISAM，Memory，CSV等一些非事务性存储引擎。</p><p><strong>3、页级锁定</strong></p><p>锁定颗粒度介于行级锁定与表级锁之间，每页有多行数据，并发处理能力以及获取锁定所需要的资源开销在两者之间；</p><p>页级锁定主要是BerkeleyDB 存储引擎；</p><p><strong>两段锁协议(2PL)</strong></p><p>两段锁协议规定所有的事务应遵守的规则：</p><p>1.在对任何数据进行读、写操作之前，首先要申请并获得对该数据的封锁；</p><p>2.在释放一个封锁之后，事务不再申请和获得其它任何封锁；</p><p>即事务的执行分为两个阶段：</p><p>第一阶段是获得封锁的阶段，称为扩展阶段；第二阶段是释放封锁的阶段，称为收缩阶段；</p><p>1begin;insert ... 加锁1 update ... 加锁2 commit; 事务提交时，释放锁1，锁2</p><p>如果在加锁2的时候，加锁不成功，则进入等待状态，直到加锁成功才继续执行；</p><p>如果有另外一个事务获取锁的时候顺序刚好相反，是有可能导致死锁的；为此有了一次性封锁法，要求事务必须一次性将所有要使用的数据全部加锁，否则就不能继续执行；</p><p><strong>锁模式</strong></p><p>Innodb 实现了两种类型的行锁：</p><ol><li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li><li>排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li></ol><p>另外，为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。</p><ol><li>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ol><p>如果一个事务请求的锁模式与当前的锁兼容，innodb 就将请求的锁授予该事务；反之，如果两者不兼容，该事务就要等待锁释放。</p><p>意向锁是 innodb 自动加的，不需要用户干预。对于 update、delete 和 insert 语句，innodb 会自动给涉及数据集加排它锁（X）；对于普通 select 语句，innodb 不会加任何锁。</p><p>事务可以通过以下语句显式给记录集加共享锁或排它锁。</p><p>共享锁（S）：select * from table_name where … lock in share mode.</p><p>排它锁（X）: select * from table_name where … for update.</p><p>用 select… in share mode 获得共享锁，主要用在需要数据依存关系时来确认某行记录是否存在，并确保没有人对这个记录进行 update 或者 delete 操作。但是如果当前事务也需要对该记录进行更新操作,则有可能造成死锁，对于锁定行记录后需要进行更新操作的应用，应该使用 select… for update 方式获得排他锁。</p><p><strong>事务隔离级别和锁的关系</strong></p><p>数据库隔离级别：未提交读(Read uncommitted)，已提交读(Read committed)，可重复读(Repeatable read)和可串行化(Serializable)；</p><ol><li>未提交读(Read uncommitted)：可能读取到其他会话中未提交事务修改的数据，会出现脏读(Dirty Read)；</li><li>已提交读(Read committed)：只能读取到已经提交的数据，会出现不可重复读(NonRepeatable Read)；</li><li>可重复读(Repeatable read)：InnoDB默认级别，不会出现不可重复读(NonRepeatable Read)，但是会出现幻读(Phantom Read);</li><li>可串行化(Serializable)：强制事务排序，使之不可能相互冲突，从而解决幻读问题，使用表级共享锁，读写相互都会阻塞；</li></ol><p>常用的2种隔离级别是：已提交读(Read committed)和可重复读(Repeatable read)；mysql的默认隔离级别是可重复读。</p><p><strong>行锁的实现方式</strong></p><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的</p><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。如果不同的索引碰巧都落到了同一个行上，那么同样会阻塞。</p><p>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p><p><strong>间隙锁</strong></p><p>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁（Next-Key锁）。</p><p>举例来说，假如emp表中只有101条记录，其empid的值分别是 1,2,…,100,101，下面的SQL：</p><p>Select * from emp where empid > 100 for update;</p><p>是一个范围条件的检索，InnoDB不仅会对符合条件的empid值为101的记录加锁，也会对empid大于101（这些记录并不存在）的“间隙”加锁。</p><p>InnoDB使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上面的例子，要是不使用间隙锁，如果其他事务插入了empid大于100的任何记录，那么本事务如果再次执行上述语句，就会发生幻读；另外一方面，是为了满足其恢复和复制的需要</p><p>还要特别说明的是，InnoDB除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请求给一个不存在的记录加锁，InnoDB也会使用间隙锁！</p><p>MySQL的恢复机制是通过BINLOG记录来执行IUD操作来同步Slave的，这就要求：在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读，这已经超过了ISO/ANSI SQL92“可重复读”隔离级别的要求，实际上是要求事务要串行化。这也是许多情况下，InnoDB要用到间隙锁的原因，比如在用范围条件更新记录时，无论在Read Commited或是Repeatable Read隔离级别下，InnoDB都要使用间隙锁，但这并不是隔离级别要求的。</p><p>INSERT…SELECT…和 CREATE TABLE…SELECT…语句，可能会阻止对源表的并发更新，造成对源表锁的等待。如果查询比较复杂的话，会造成严重的性能问题，我们在应用中应尽量避免使用。实际上，MySQL将这种SQL叫作不确定（non-deterministic）的SQL，不推荐使用。</p><p><strong>测试mysql隔离级别</strong></p><p><strong>已提交读</strong></p><p>接下来我们测试下mysql的已提交读，我们先看下mysql的隔离级别：</p><p>1mysql> SELECT @@tx_isolation;</p><p>2+----------------+</p><p>3| @@tx_isolation |</p><p>4+----------------+</p><p>5| REPEATABLE-READ |</p><p>6+----------------+</p><p>设置隔离级别为已提交读</p><p>1set session transaction isolation level read committed;</p><p>2Query OK, 0 rows affected (0.02 sec)</p><p>3</p><p>4mysql> SELECT @@tx_isolation;</p><p>5+----------------+</p><p>6| @@tx_isolation |</p><p>7+----------------+</p><p>8| READ-COMMITTED |</p><p>9+----------------+</p><p>101 row in set (0.01 sec)</p><p>准备测试数据:</p><p>1CREATE TABLE `test_lock` (</p><p>2 `id` int(11) NOT NULL AUTO_INCREMENT,</p><p>3 `name` varchar(255) NOT NULL,</p><p>4 `type` int(11) DEFAULT NULL,</p><p>5 PRIMARY KEY (`id`)</p><p>6) ENGINE=InnoDB DEFAULT CHARSET=utf8</p><p>7</p><p>8mysql> insert into test_lock values(null,'zhaohui',1);</p><p>9mysql> insert into test_lock values(null,'zhaohui2',2);</p><p>模拟多个事务交叉执行:</p><p>Session1执行查询</p><p>1mysql> begin</p><p>2 -> ;</p><p>3Query OK, 0 rows affected (0.02 sec)</p><p>4</p><p>5mysql> select * from test_lock where id=1;</p><p>6+----+---------+------+</p><p>7| id | name | type |</p><p>8+----+---------+------+</p><p>9| 1 | zhaohui | 1 |</p><p>10+----+---------+------+</p><p>111 row in set (0.05 sec)</p><p>Session2更新数据</p><p>1 begin;</p><p>2Query OK, 0 rows affected (0.08 sec)</p><p>3</p><p>4mysql> update test_lock set name='zhaohui_new' where id=1;</p><p>5Query OK, 1 row affected (0.02 sec)</p><p>6Rows matched: 1 Changed: 1 Warnings: 0</p><p>7</p><p>8mysql> commit;</p><p>9Query OK, 0 rows affected (0.03 sec)</p><p>10</p><p>Session1执行查询</p><p>1select * from test_lock where id=1;</p><p>2+----+-------------+------+</p><p>3| id | name | type |</p><p>4+----+-------------+------+</p><p>5| 1 | zhaohui_new | 1 |</p><p>6+----+-------------+------+</p><p>71 row in set (0.04 sec)</p><p>Session1中出现了不可重复读(NonRepeatable Read)，也就是在查询的时候没有锁住相关的数据，导致出现了不可重复读，但是写入、修改和删除数据还是加锁了，如下所示：</p><p>Session1更新数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.01 sec)</p><p>3</p><p>4mysql> update test_lock set name='zhaohui_new2' where id=1;</p><p>5Query OK, 1 row affected (0.01 sec)</p><p>6Rows matched: 1 Changed: 1 Warnings: 0</p><p>Session2更新数据</p><p>1mysql> begin</p><p>2 -> ;</p><p>3Query OK, 0 rows affected (0.05 sec)</p><p>4</p><p>5mysql> update test_lock set name='zhaohui_new3' where id=1;</p><p>6ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</p><p>Session2更新在更新同一条数据的时候超时了，在更新数据的时候添加了排他锁；</p><p><strong>可重复读</strong></p><p>查看和设置隔离级别</p><p>1mysql> set session transaction isolation level repeatable read;</p><p>2Query OK, 0 rows affected (0.07 sec)</p><p>3</p><p>4mysql> SELECT @@tx_isolation;</p><p>5+-----------------+</p><p>6| @@tx_isolation |</p><p>7+-----------------+</p><p>8| REPEATABLE-READ |</p><p>9+-----------------+</p><p>101 row in set (0.05 sec)</p><p>模拟多个事务交叉执行:</p><p>Session1执行查询</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.03 sec)</p><p>3</p><p>4mysql> select * from test_lock where type=2;</p><p>5+----+----------+------+</p><p>6| id | name | type |</p><p>7+----+----------+------+</p><p>8| 2 | zhaohui2 | 2 |</p><p>9+----+----------+------+</p><p>101 row in set (0.02 sec)</p><p>Session2更新数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.05 sec)</p><p>3</p><p>4mysql> update test_lock set name='zhaohui2_new' where type=2;</p><p>5Query OK, 1 row affected (0.03 sec)</p><p>6Rows matched: 1 Changed: 1 Warnings: 0</p><p>7</p><p>8mysql> commit;</p><p>9Query OK, 0 rows affected (0.06 sec)</p><p>Session1执行查询</p><p>1mysql> select * from test_lock where type=2;</p><p>2+----+----------+------+</p><p>3| id | name | type |</p><p>4+----+----------+------+</p><p>5| 2 | zhaohui2 | 2 |</p><p>6+----+----------+------+</p><p>71 row in set (0.03 sec)</p><p>可以发现2次查询的数据结果是一样的，实现了可重复读(Repeatable read)，再来看一下是否有幻读的问题；</p><p>Session3插入数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.01 sec)</p><p>3</p><p>4mysql> insert into test_lock(name,type) values('zhaohui3',2);</p><p>5Query OK, 1 row affected (0.02 sec)</p><p>6</p><p>7mysql> commit;</p><p>8Query OK, 0 rows affected (0.02 sec)</p><p>Session1执行查询</p><p>1mysql> select * from test_lock where type=2;</p><p>2+----+----------+------+</p><p>3| id | name | type |</p><p>4+----+----------+------+</p><p>5| 2 | zhaohui2 | 2 |</p><p>6+----+----------+------+</p><p>71 row in set (0.01 sec)</p><p>这里发现一个奇怪的现象,按理说应该会出现两条记录，但是mysql在重复读的隔离级别下没有出现幻读的情况；</p><p>我们知道innodb默认是行锁级别，如何通过悲观锁的方式去实现可重复读和不出现幻读的现象，对读取的数据加共享锁，对同样的数据执行更新操作就只能等待，这样就可以保证可重复读，但是对于不出现幻读的现象无法通过锁定行数据来解决；</p><p>最终看到的现象是没有幻读的问题，同时如果对读取的数据加共享锁，更新相同数据应该会等待，上面的实例中并没有出现等待，所以mysql内部应该还有其他锁机制--MVCC机制；</p><p><strong>共享锁使用</strong></p><p>Session1查询数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.03 sec)</p><p>3</p><p>4mysql> select * from test_lock where type=2 lock in share mode;</p><p>5+----+--------------+------+</p><p>6| id | name | type |</p><p>7+----+--------------+------+</p><p>8| 2 | zhaohui2_new | 2 |</p><p>9| 3 | zhaohui3 | 2 |</p><p>10+----+--------------+------+</p><p>112 rows in set (0.15 sec)</p><p>Session2查询数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.01 sec)</p><p>3</p><p>4mysql> select * from test_lock where type=2 lock in share mode;</p><p>5+----+--------------+------+</p><p>6| id | name | type |</p><p>7+----+--------------+------+</p><p>8| 2 | zhaohui2_new | 2 |</p><p>9| 3 | zhaohui3 | 2 |</p><p>10+----+--------------+------+</p><p>112 rows in set (0.05 sec)</p><p>Session3 更新数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.02 sec)</p><p>3</p><p>4mysql> update test_lock set name='zhaohui3_new' where id=3;</p><p>5ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</p><p>Session1和Session2使用了共享锁，所以可以存在多个，并不冲突，但是Session3更新操作需要加上排他锁，和共享锁不能同时存在；</p><p><strong>排他锁使用</strong></p><p>Session1查询数据</p><p>1mysql> begin;</p><p>2Query OK, 0 rows affected (0.07 sec)</p><p>3</p><p>4mysql> select * from test_lock where type=2 for update;</p><p>5+----+--------------+------+</p><p>6| id | name | type |</p><p>7+----+--------------+------+</p><p>8| 2 | zhaohui2_new | 2 |</p><p>9| 3 | zhaohui3 | 2 |</p><p>10+----+--------------+------+</p><p>112 rows in set (15.02 sec)</p><p>Session2查询数据</p><p>1mysql>begin;</p><p>2Query OK, 0 rows affected (0.07 sec)</p><p>3</p><p>4mysql> select * from test_lock where type=2 for update;</p><p>5ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</p><p>排他锁只能有一个同时存在，如果session1获取了锁，那么session2将会等待超时。</p><p><strong>mysql MVCC</strong></p><p><strong>MVCC 简介</strong></p><p>MVCC (Multiversion Concurrency Control)，即多版本并发控制技术,它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能</p><p><strong>MVCC 实现</strong></p><p>MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制.</p><p>InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.</p><p>innodb存储的最基本row中包含一些额外的存储信息 DATA_TRX_ID，DATA_ROLL_PTR，DB_ROW_ID，DELETE BIT</p><ol><li>6字节的DATA_TRX_ID 标记了最新更新这条行记录的transaction id，每处理一个事务，其值自动+1</li><li>7字节的DATA_ROLL_PTR 指向当前记录项的rollback segment的undo log记录，找之前版本的数据就是通过这个指针</li><li>6字节的DB_ROW_ID，当由innodb自动产生聚集索引时，聚集索引包括这个DB_ROW_ID的值，否则聚集索引中不包括这个值.，这个用于索引当中</li><li>DELETE BIT位用于标识该记录是否被删除，这里的不是真正的删除数据，而是标志出来的删除。真正意义的删除是在commit的时候</li></ol><div class=pgc-img><img alt=连mysql锁的机制都不了解，怎么做架构师 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f><p class=pgc-img-caption></p></div><p>具体的执行过程</p><p>begin->用排他锁锁定该行->记录redo log->记录undo log->修改当前行的值，写事务编号，回滚指针指向undo log中的修改前的行</p><p>上述过程确切地说是描述了UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程</p><p>下面分别以select、delete、 insert、 update语句来说明：</p><p><strong>SELECT</strong></p><p>Innodb检查每行数据，确保他们符合两个标准：</p><p>1、InnoDB只查找版本早于当前事务版本的数据行(也就是数据行的版本必须小于等于事务的版本)，这确保当前事务读取的行都是事务之前已经存在的，或者是由当前事务创建或修改的行</p><p>2、行的删除操作的版本一定是未定义的或者大于当前事务的版本号，确定了当前事务开始之前，行没有被删除</p><p>符合了以上两点则返回查询结果。</p><p><strong>INSERT</strong></p><p>InnoDB为每个新增行记录当前系统版本号作为创建ID。</p><p><strong>DELETE</strong></p><p>InnoDB为每个删除行的记录当前系统版本号作为行的删除ID。</p><p><strong>UPDATE</strong></p><p>InnoDB复制了一行。这个新行的版本号使用了系统版本号。它也把系统版本号作为了删除行的版本。</p><p>这里简单做下总结：</p><ol><li>insert操作时 “创建时间”=DB_ROW_ID，这时，“删除时间 ”是未定义的；</li><li>update时，复制新增行的“创建时间”=DB_ROW_ID，删除时间未定义，旧数据行“创建时间”不变，删除时间=该事务的DB_ROW_ID；</li><li>delete操作，相应数据行的“创建时间”不变，删除时间=该事务的DB_ROW_ID；</li><li>select操作对两者都不修改，只读相应的数据</li></ol></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'mysql','锁的','机制'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>