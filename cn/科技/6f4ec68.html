<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试现场如何实现链表的逆序？ | 极客快訊</title><meta property="og:title" content="面试现场如何实现链表的逆序？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/dd4fe657023148848d17fcf7ab0c45f9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/6f4ec68.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/6f4ec68.html><meta property="article:published_time" content="2020-10-29T20:52:58+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:58+08:00"><meta name=Keywords content><meta name=description content="面试现场如何实现链表的逆序？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/6f4ec68.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试现场如何实现链表的逆序？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>前几天一位小伙伴去面试，被要求现场写如何实现链表的逆序？写完一种问还有没有其他方式？</p><p><br></p><div class=pgc-img><img alt=面试现场如何实现链表的逆序？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dd4fe657023148848d17fcf7ab0c45f9><p class=pgc-img-caption></p></div><p>今天咱们就来聊聊到底如何实现链表的逆序以及有哪些方法？（文中的链表是单链表）</p><p><br></p><div class=pgc-img><img alt=面试现场如何实现链表的逆序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7df60206474443b69da404dd71683449><p class=pgc-img-caption></p></div><p>给定一个带头节点的单链表，请将其逆序。如下图所示，head为头部。</p><p><br></p><div class=pgc-img><img alt=面试现场如何实现链表的逆序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76a521dfb8c14d06b91b75e74243c466><p class=pgc-img-caption></p></div><p>由於单链表与数组不相同，单链表中每个节点的地址都存储在其前驱节点的指针域中，因此，对单链表中任何一个结点的访问只能从链表的头指针开始进行遍历。在对链表的操作过程中，需要特别注意在修改结点指针域的时候，记录下后继结点的地址，否则会丢失后继结点。</p><h4 class=pgc-h-arrow-right>方法一：就地逆序</h4><p>序主要思路：在遍历链表时，修改当前结点的指针域的指向，让其指向它的前驱结点。为此，需要用一个指针变量来保存前驱结点的地址。此外，为了在调整当前结点指针域的指向后还能找到后继结点，还需要另外一个指针变量来保存后继结点的地址，在所有的结点都被保存好以后就可以直接完成指针的逆序了。除此之外，还需要特别注意对链表首尾结点的特殊处理。具体实现方式如下图所示。</p><p><br></p><div class=pgc-img><img alt=面试现场如何实现链表的逆序？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/90cef93675024e2a921cf9c4264081a5><p class=pgc-img-caption></p></div><p>在上图中，假设当前已经遍历到cur 结点，由于它所有的前驱结点都已经完成了逆序操作，因此，只需要使</p><pre><code>cur.next=pre</code></pre><p>即可完成逆序操作。在此之前，为了能够记录当前结点的后继结点的地址，需要用一个额外的指针next来保存后继结点的信息，通过上图（1）～（4）四步把实线的指针调整为虚线的指针就可以完成当前结点的逆序；当前结点完成逆序后，通过向后移动指针来对后续的结点用同样的方法进行逆序操作。</p><p><br>算法实现</p><pre><code>//节点信息public class Node {   public int data;   public Node next;}public class NodeReversal {   public static void main(String[] args) {       Node head = new Node();       head.next = null;       Node temp = null;       Node cur = head;       for (int i = 0; i &lt; 8; i++) {           temp = new Node();           temp.data = i;           temp.next = null;           cur.next = temp;           cur = temp;      }       System.out.println("逆序之前");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }       reversal(head);       System.out.println();       System.out.println("逆序之后");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }  }   public static void reversal(Node head) {       //如果头结点为空或者只有一个头结点，就不用反转了       if (head == null || head.next == null) {           return;      }       //前驱节点       Node pre = null;       //当前节点       Node cur = null;       //后继节点       Node next = null;       //把链表首节点变为尾节点       cur = head.next;       next = cur.next;       cur.next = null;       pre = cur;       cur = next;       //使当前遍历到的结点cur指向前驱节点       while (cur.next != null) {           next = cur.next;           cur.next = pre;           pre = cur;           cur = cur.next;           cur = next;      }       //节点最后一个结点指向倒数第二个节点       cur.next = pre;       //链表的头及诶单指向原来链表的尾节点       head.next = cur;  }}</code></pre><p>运行结果</p><pre><code>逆序之前0 1 2 3 4 5 6 7逆序之后7 6 5 4 3 2 1 0</code></pre><p><br>算法性能分析</p><p>以上这种方法只需要对链表进行一次遍历，因此，时间复杂度为O（N）。其中，N为链表的长度。但是需要常数个额外的变量来保存当前结点的前驱结点与后继结点，因此，空间复杂度为O（1）。</p><h4 class=pgc-h-arrow-right>方法二：递归法</h4><p>假定原链表为1→2→3→4→5→6→7，</p><p>递归法的主要思路为：先逆序除第一个结点以外的子链表</p><p>（将1→2→3→4→5→6→7变为1→7→6→5→4→3→2），</p><p>接着把结点1添加到逆序的子链表的后面</p><p>（1→2→3→4→5→6→7 变为7→6→5→4→3→2→1）。</p><p>同理，在逆序链表2→3→4→5→6→7时，</p><p>也是先逆序子链表3→4→5→6→7（逆序为2→7→6→5→4→3），</p><p>接着实现链表的整体逆序（2→7→6→5→4→3转换为7→6→5→4→3→2）。</p><h5 class=pgc-h-arrow-right>算法实现</h5><pre><code>public class NodeReversal {   public static void main(String[] args) {       Node head = new Node();       head.next = null;       Node temp = null;       Node cur = head;       for (int i = 0; i &lt; 8; i++) {           temp = new Node();           temp.data = i;           temp.next = null;           cur.next = temp;           cur = temp;      }       System.out.println("逆序之前");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }       reverse(head);       System.out.println();       System.out.println("逆序之后");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }  }   public static Node recursionReversal(Node head) {       if (head == null || head.next == null) {           return head;      }       //反转后面的节点       Node newHead = recursionReversal(head.next);       //把当前遍历的节点加到后面节点逆序后链表的尾部       head.next.next = head;       head.next = null;       return newHead;  }   /**    * 方法功能：对待头节点的单链表进行逆序    *    * @param head head链表头节点    */   public static void reverse(Node head) {       if (head == null) {           return;      }       //获取链表的第一个节点       Node firstNode = head.next;       //对链表进行逆序       Node newHead = recursionReversal(firstNode);       //头节点指向逆序后链表的第一个节点       head.next = newHead;  }}</code></pre><p>运行输出</p><pre><code>逆序之前0 1 2 3 4 5 6 7逆序之后7 6 5 4 3 2 1 0</code></pre><p>算法性能分析</p><p>由于递归法也只需要对链表进行一次遍历，因此，算法的时间复杂度也为O（N）。其中， N 为链表的长度。递归法的主要优点是：思路比较直观，容易理解，而且也不需要保存前驱结点的地址；缺点是：算法实现的难度较大。此外，由于递归法需要不断地调用自己，需要额外的压栈与弹栈操作，因此，与方法一相比性能会有所下降。</p><h4 class=pgc-h-arrow-right>方法三：插入法</h4><p>插入法的主要思路：从链表的第二个结点开始，把遍历到的结点插入到头结点的后面，直到遍历结束。假定原链表为<br></p><pre><code>head→1→2→3→4→5→6→7</code></pre><p>在遍历到2时，将其插入到头结点后，链表变为</p><pre><code> head→2→1→3→4→5→6→7</code></pre><p>同理将后序遍历到的所有结点都插入到头结点head后，就可以实现链表的逆序。</p><p><br>算法实现</p><pre><code>public class NodeReversal {   public static void main(String[] args) {       Node head = new Node();       head.next = null;       Node temp = null;       Node cur = head;       for (int i = 0; i &lt; 8; i++) {           temp = new Node();           temp.data = i;           temp.next = null;           cur.next = temp;           cur = temp;      }       System.out.println("逆序之前");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }       reversal(head);       System.out.println();       System.out.println("逆序之后");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }  }   public static void reversal(Node head) {       //判断链表是否为空       if (head == null || head.next == null) {           return;      }       //当前节点       Node cur = null;       //后排节点       Node next = null;       cur = head.next.next;       //设置链表第一个节点为尾节点       head.next.next = null;       //把遍历到节点插入到头节点的后面       while (cur != null) {           next = cur.next;           cur.next = head.next;           head.next = cur;           cur = next;      }  }}</code></pre><p>算法性能分析</p><p>以上这种方法也只需要对单链表进行一次遍历，因此，时间复杂度为O（N）。其中，N为链表的长度。与方法一相比，这种方法不需要保存前驱结点的地址，与方法二相比，这种方法不需要递归地调用，效率更高。</p><h4 class=pgc-h-arrow-right>引申</h4><p>①对不带头结点的单链表进行逆序；</p><p>②从尾到头输出链表。</p><h5 class=pgc-h-arrow-right>分析</h5><p>对不带头结点的单链表的逆序，读者可以自己练习（方法二已经实现了递归的方法），这里主要介绍单链表逆向输出的方法。</p><h5 class=pgc-h-arrow-right>方法一：就地逆序+顺序输出</h5><p>首先对链表进行逆序，然后顺序输出逆序后的链表。这种方法的缺点是改变了链表原来的结构。</p><h5 class=pgc-h-arrow-right>方法二：逆序+顺序输出</h5><p>申请新的存储空间，对链表进行逆序，然后顺序输出逆序后的链表。逆序的主要思路为：每当遍历到一个结点的时候，申请一块新的存储空间来存储这个结点的数据域，同时把新结点插入到新的链表的头结点后。这种方法的缺点是需要申请额外的存储空间。</p><h5 class=pgc-h-arrow-right>方法三：递归输出</h5><p>递归输出的主要思路：先输出除当前结点外的后继子链表，然后输出当前结点，假如链表为1→2→3→4→5→6→7，那么先输出2→3→4→5→6→7，再输出1。同理，对于链表2→3→4→5→6→7，也是先输出3→4→5→6→7，接着输出2，直到遍历到链表的最后一个结点7的时候会输出结点7，然后递归地输出6，5，…，1。实现代码如下：<br></p><pre><code>public class NodeReversal {   public static void main(String[] args) {       Node head = new Node();       head.next = null;       Node temp = null;       Node cur = head;       //制造链表0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7       for (int i = 0; i &lt; 8; i++) {           temp = new Node();           temp.data = i;           temp.next = null;           cur.next = temp;           cur = temp;      }       System.out.println("逆序之前");       for (cur = head.next; cur != null; cur =cur.next) {           System.out.print(cur.data + " ");      }       System.out.println();       System.out.println("逆序之后");              reversal(head.next);  }   public static void reversal(Node firstNode) {       if (firstNode == null) {           return;      }       reversal(firstNode.next);       System.out.print(firstNode.data + " ");  }}</code></pre><p>输出</p><pre><code>逆序之前0 1 2 3 4 5 6 7逆序之后7 6 5 4 3 2 1 0</code></pre><p>算法性能分析：以上这种方法只需要对链表进行一次遍历，因此，时间复杂度为O（N）。其中，N为链表的长度。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','现场','实现'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>