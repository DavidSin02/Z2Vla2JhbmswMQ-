<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>对话框窗口过程的另外一种实现方法 | 极客快訊</title><meta property="og:title" content="对话框窗口过程的另外一种实现方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/22ebb7b6d51f4de59abd3728621d1002"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/70402b6b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70402b6b.html><meta property="article:published_time" content="2020-11-14T21:01:56+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:56+08:00"><meta name=Keywords content><meta name=description content="对话框窗口过程的另外一种实现方法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/70402b6b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>对话框窗口过程的另外一种实现方法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>蝎子</h1><p>在之前的一篇关于对话框返回值的文章中，有人建议说可以使用另外一种不同的搞法：也即直接调用DefDlgProc这个API函数(就类似于窗口消息过程中调用默认的消息处理函数DefWindowProc一样，而不是直接返回TRUE或者FALSE。</p><h1 class=pgc-h-arrow-right>那，让我们试试呗</h1><p>实际上，我们准备试它两次。今天我会使用上述所说的方法，过几天，我还会演示另外一种完全不一样的做法。这两种做法中，都包含同一个的内部理念，而剩下的其他部分只是为了让这个理念能顺利跑起来的辅助结构而已。</p><p>这个所谓的第一种方法，实际上是使用了一种递归式调用手法，它尝试在对话框窗口过程中调用DefDlgProc，从而触发一种默认的消息处理流程。这种技巧需要设立一个标志，使用这个标志可以能够打破递归调用，从而退出无限循环。</p><p>因为通常你的对话框对象里已经有了一些数据成员了，所以，再添加一个数据成员应该不是什么大问题。</p><h1 class=pgc-h-arrow-right>上面所说的内部理念是：打破递归循环调用链</h1><p>DefDlgProc会调用对话框窗口过程来判断主程序的意图。当你想让Windows执行默认的消息处理时，你就会递归地调用DefDlgProc：在DefDlgProc这个函数的内部，它会回过头来，调用你的对话框窗口过程来判断你是否会希望覆盖默认的处理流程。</p><p>通过检测这个递归调用并返回FALSE，对DefDlgProc的递归调用就会执行默认处理并返回它的处理结果。</p><p>现在，你得到了默认消息处理的结果，你可以在返回之前修改它，然后调用链返回到外层的DefDlgProc，它会将这个值作为消息处理的最终处理结果。</p><p>如果有人喜欢看图的话，可以看看下面这个图：</p><div class=pgc-img><img alt=对话框窗口过程的另外一种实现方法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/22ebb7b6d51f4de59abd3728621d1002><p class=pgc-img-caption></p></div><p>基于上面的这个流程图，你应该能够自己写出对应的代码来。下面是我写的一个版本，我姑且把它称作是一个”WndProc-Like”的对话框。</p><div class=pgc-img><img alt=对话框窗口过程的另外一种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/044cfc84f4aa49c2b95f9fbc3dee41d7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=对话框窗口过程的另外一种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/691399dff32b4d4c9f7b2562673d93f3><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>让我们过一过上面的代码</h1><p>我将WLDlgProc声明为了虚方法，如果一个子类继承了WLDialogBox，则这个子类的窗口过程会被s_DlgProc调用，我们认为子类可能会在它们自己的窗口过程中执行自定义的行为。在基类的中，我们调用了DefDlgProcEx（这是个宏，来自windowsx.h头文件）来作为消息处理的默认方式（它的确做了许多脏活）。</p><p>是的，你想的没错，这个技法从1992年就已经被Microsoft公布出来了。如果你查看一下DefDlgProcEx这个宏的实现代码，就会发现，它会将检测递归调用的标志设置为TRUE，然后调用会触发递归调用的DefDlgProc。</p><p>本来我是想着再实现一份WLDefDlgProc的，它会调用DefDlgProcEx并且WLDlgProc会调用WLDefDlgProc。(在第一版中，我的确是这么做的)。但是，我最终没有选择这样做，我主要是不想有人跳过对基类WLDefDlgProc的调用。</p><p>如果你希望对消息进行默认的处理，则只需要将调用转发给基类的WLDefDlgProc即可。</p><p>s_DlgProc是所有Wndproc对话框实例的对话框窗口过程。当收到WM_INITDIALOG消息的时候，它会初始化自身，这样后面收到的消息就能准确地知道具体是哪个窗口实例负责处理此消息。</p><p>接下来，我们使用了CheckDlgRecursion这个宏(也是来自windowsx.h)。这个宏会检查递归调用标志，如果标志为TRUE，则它会将它设置为FALSE并立即返回FALSE，这样就可以打破递归调用循环了。</p><p>如果标志为FALSE，它会调用WLDlgProc这个方法(子类很有可能会重写这个方法)，然后设置对话框窗口过程的返回值并返回。</p><p>SetDlgMsgResult这个宏也来自于windowsx.h：它保存返回值到DWLP_MSGRESULT中并返回TRUE。除非出现一些特殊的消息，在这种情况下，它会直接返回，而不设置DWLP_MSGRESULT。<strong>对64位应用开发者的温馨提醒</strong>：当前实现的这个宏里有一个Bug。表达式[(BOOL)(result)]应该改为[(INT_PTR)(result)]，这样返回值的高32位就不会被截断了。</p><p>最后一个方法是DoModal，它会初始化递归调用标志并显示对话框。</p><p>下面是一个使用了上面这个类的一个例子：</p><div class=pgc-img><img alt=对话框窗口过程的另外一种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d5461671ac948fb9478428e975a2b59><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=对话框窗口过程的另外一种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bac383d3f0a5468fb158f0cecc005847><p class=pgc-img-caption></p></div><p>为了演示返回一个自定义的返回值，我重写了WM_SETCURSOR消息处理函数，这样当鼠标位于标题栏时，会显示一个自定义的光标。对于演示目的来说，这个代码已经足够达到目的了。</p><h1 class=pgc-h-arrow-right>请注意如下的两个方面</h1><p>我们通过调用__super::WLDlgProc来调用了默认的消息处理函数。在Visual C++扩展中，__super可以用来在子类中解析对基类的引用。这个关键字十分有用，因为它可以帮助开发者快速将调用转发给类的上一层基类。如果你希望将调动转发给基类的基类，则可以使用如下的技法：<strong>__super::__super::WLDlgProc</strong></p><p>如果你使用的编译器不支持__super关键字，则可以使用如下的typedef来间接实现：</p><p><strong>typedef WLDialogBox super;</strong></p><p>然后使用super::WLDlgProc就可以调用基类方法了。</p><p>实际上，在VC开发团队将__super关键字添加到产品中之前，我就是这样做的，可能是习惯了吧。</p><h1 class=pgc-h-arrow-right>课后练习</h1><p>递归调用标志真的有必要作为每个对话框示例的数据成员吗？可以将它设置为全局变量的吗？</p><h1 class=pgc-h-arrow-right>问题答案</h1><p>递归调用标志不需要作为每个对话框示例的数据成员。只需要保证它的生命周期足够长，以至于可以及时检测到递归调用。</p><p>但是，将它设置为全局变量也不是个好主意，因为可能在对DefDlgProc的递归调用中会同时有两个线程。</p><p>所以，倒是可以考虑使用TLV(Thread Local Variable)来存储这个变量，如果你希望使用C语言而不是C++类来实现的话。</p><p><br></p><div class=pgc-img><img alt=对话框窗口过程的另外一种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8e70b3b737cb4ba8abdb42dae189bff1><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'对话','过程','一种'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>