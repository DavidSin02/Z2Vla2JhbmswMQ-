<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试题：说说你理解的适配器模式？ | 极客快訊</title><meta property="og:title" content="面试题：说说你理解的适配器模式？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/e7f03097-2a01-41c0-b5fb-a009254307a1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/707bb2b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707bb2b.html><meta property="article:published_time" content="2020-10-29T20:53:45+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:45+08:00"><meta name=Keywords content><meta name=description content="面试题：说说你理解的适配器模式？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/707bb2b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试题：说说你理解的适配器模式？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify><strong>前语：不要为了读文章而读文章，一定要带着问题来读文章，勤思考</strong></p><div class=pgc-img><img alt=面试题：说说你理解的适配器模式？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/e7f03097-2a01-41c0-b5fb-a009254307a1><p class=pgc-img-caption></p></div><h1 class=ql-align-justify><strong>序言</strong></h1><p class=ql-align-justify>在以前学习适配器模式时，有个经典例子：就是有些电器的工作电压不是220V， 比如电脑工作电压20V,但是我们家庭用电的电压是220。怎么让20V的电脑在220V的电压下工作，这就需要一个电源适配器——俗称充电器或变压器。有了这个电源适配器 家庭的用电电压跟电脑的用电电压 即可兼容。</p><h1 class=ql-align-justify><strong># 适配器模式</strong></h1><p class=ql-align-justify>定义：将一个接口转换成客户所希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为为包装器（Wrapper）。适配器模式既可以作为类结构性模式，也可以作为对象型结构性模式。</p><div class=pgc-img><img alt=面试题：说说你理解的适配器模式？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/4fc6f192-74c3-4f91-a66a-3feb97910eca><p class=pgc-img-caption></p></div><p class=ql-align-justify><strong>Target(目标抽象类)：</strong>目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是一个具体的类。</p><p class=ql-align-justify><strong>Adapter（适配器类）: </strong>适配器可以调用另外一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心。</p><p class=ql-align-justify><strong>Adaptee(适配者类) ：</strong>适配者即被适配的角色，它定义了已存在的接口，这个接口需要适配。一般是一个具体的类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p><p class=ql-align-justify>在适配器模式结构图我们可以看到 Adapter（适配器）和Adaptee(适配者)是有一种关联的，这种关联可以是继承关系，也可以是一种组合关系。继承关系的我们一般称为<strong>类适配器模式</strong>; 组合关系的称为对象适配器模式。</p><h1 class=ql-align-justify><strong>类适配器模式</strong></h1><p class=ql-align-justify>定义一个需要被适配的类。</p><pre>/** * @program * @Desc Adaptee（适配者） * @Author 游戏人日常 * @CreateTime 2019/07/08--14:49 */ public class Adaptee { public void specificRequest(){ System.out.println("将需要被适配的方法"); } }</pre><p class=ql-align-justify>定义一个目标接口。</p><pre>/** * @program * @Desc 目标接口 * @Author 游戏人日常 * @CreateTime 2019/07/08--14:53 */ public interface Target { public void request(); }</pre><p class=ql-align-justify>定义适配器类， 因为是类适配器模式，所以我们需要继承Adaptee类。</p><pre>/** * @program * @Desc Adapter（适配者） * @Author 游戏人日常 * @CreateTime 2019/07/08--14:57 */ public class Adapter extends Adaptee implements Target { @Override public void request() { specificRequest(); } @Override public void specificRequest() { //这里可以加下其他操作 super.specificRequest(); //这里可以加下其他操作 } }</pre><p class=ql-align-justify>客户端测试。</p><pre>public static void main(String args []){ Target adapter=new Adapter(); adapter.request(); }</pre><p class=ql-align-justify>输出结果 ：</p><pre>将需要被适配的方法</pre><p class=ql-align-justify>这里我们可以看到适配器（Adapter）继承了适配者（Adaptee），然后实现了目标接口（Target）。这样使目标接口跟适配者的接口就关联起来了， 客户端通过调用适配器的方法，从而达到调用了适配者所被适配的方法。</p><h1 class=ql-align-justify><strong>对象适配器模式</strong></h1><p class=ql-align-justify>对象适配器模式跟类适配器模式所不同的就是适配器（Adapter）类是基于继承的，而对象适配器是基于组合的。其他的Target、Adaptee不变。</p><p class=ql-align-justify>定义适配器类。</p><pre>/** * @program * @Desc Adapter（适配者） * @Author 游戏人日常 * @CreateTime 2019/07/08--14:57 */ public class Adapter implements Target { private Adaptee adaptee =new Adaptee(); @Override public void request() { adaptee.specificRequest(); } }</pre><p class=ql-align-justify>客户端测试。</p><pre>public static void main(String args []){ Target adapter=new Adapter(); adapter.request(); }</pre><p class=ql-align-justify>输出结果 ：</p><pre>将需要被适配的方法</pre><p class=ql-align-justify>一般常用的就是对象适配器模式，很少用类适配器。 还有一种双向适配器模式，就是（Adapter）适配器包含对目标类（Target）和适配者类（Adaptee）两个引用。目标类可以通过适配器（Adapter）调用适配者（Adaptee中的方法， 适配者类也可以通过适配器调用目标类的方法。UML类图如下。</p><div class=pgc-img><img alt=面试题：说说你理解的适配器模式？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/566ae88bdc5b4d6f91f8fb5e8af32ccc><p class=pgc-img-caption></p></div><p class=ql-align-justify>适配器（Adapter）类一般写法如下：</p><pre>/** * @program * @Desc Adapter（适配者） * @Author 游戏人日常 * @CreateTime 2019/07/08--14:57 */ public class Adapter implements Target , Adaptee {  //同时对适配者和目标类的引用 private Target target; private Adaptee adaptee; public Adapter(Target target) { this.target = target; } public Adapter(Adaptee adaptee) { this.adaptee = adaptee; } @Override public void request() { adaptee.specificRequest(); } @Override public void specificRequest() { target.request(); } }</pre><p class=ql-align-justify>在实际的开发中很少使用双向适配器。</p><h1 class=ql-align-justify><strong>缺省适配器</strong></h1><p class=ql-align-justify>缺省适配器模式是适配器模式一种变体。</p><p class=ql-align-justify>定义：当不需要实现一个接口所提供的所有方法时，可以设计一个抽象类实现该接口，并为每个接口提供一个默认实现，那么该抽象类的子类可以选择性覆盖父类中的方法，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。</p><p class=ql-align-justify>简单的理解就是当适配者（Adaptee）有大量的方法时，那么每个适配器（Adapter）都要去实现接口中的这些方法，这样就感觉太费劲。所以这种情况下，可以考虑实现个默认的适配器，然后根据实际目标角色接口的类集成这个默认适配器，然后选择性的实现默认适配器中的一些方法。</p><p class=ql-align-justify>缺省适配器模式结构如下图：</p><div class=pgc-img><img alt=面试题：说说你理解的适配器模式？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/123ffb80-82f4-4dbc-a049-8789a49aa8b1><p class=pgc-img-caption></p></div><p class=ql-align-justify><strong>ServiceInterface(适配者接口) </strong>：是一个接口，里面包含大量的方法。</p><p class=ql-align-justify><strong>AbstractServiceClass(缺省适配器类) </strong>：实现了ServiceInterface中声明的方法， 通常定义为抽象类。</p><p class=ql-align-justify><strong>ConcreteServiceClass(具体业务类) </strong>：它是缺省适配器的子类，在没有引用适配器之前，它需要实现适配者（ServiceInterface）所有的方法， 有了缺省适配器类后，就可以有选择性的覆盖适配器类中的方法。</p><h1 class=ql-align-justify><strong>总结</strong></h1><p class=ql-align-justify><strong>读者福利：欢迎大家转发+关注，这次总结的面试题广受好评，分享给大家：<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6698297233164468747/?group_id=6698297233164468747" target=_blank>Java面试必刷真题200+，让你“过五关，斩六将”，轻松入大厂</a></strong></p><p class=ql-align-justify>适配器模式总共列出四种：类适配器模式、 对象适配器模式 、 双向适配器模式 、 缺省适配器模式。</p><ul><li class=ql-align-justify>类适配器模式 ：适配器（Adapter）跟适配者（Adaptee）是一种继承关系。</li><li class=ql-align-justify>对象适配器模式：适配器（Adapter）跟适配者（Adaptee）是一种组合关系。</li><li class=ql-align-justify>双向适配器模式 ：双向适配器是对象适配器模式的一种变体， 该模式的适配器（Adapter）不仅引用了适配者（Adaptee）,还对目标类（Target）引用。所以这种模式目标类和适配者之间互相适配。</li><li class=ql-align-justify>缺省适配器模式：当适配者接口中出现大量的方法时，就可以考虑这种模式。</li></ul><p class=ql-align-justify><strong>1、优点</strong></p><p class=ql-align-justify>类适配器模式和对象适配器模式都具有的优点：</p><ul><li class=ql-align-justify>将目标类（Target）和 适配者类（Adaptee）解耦， 引用一个适配器类（Adapter）就可以对适配者进行重用。</li><li class=ql-align-justify>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对客户端来而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li></ul><p class=ql-align-justify>对象适配器模式优点：</p><ul><li class=ql-align-justify>一个对象适配器可以把多个适配者适配到同一目标。</li><li class=ql-align-justify>可以适配一个适配者的子类，由于适配器和适配者之间是组合关系，根据“里氏代换原则”，适配者的子类也可以通过该适配器进行适配。</li></ul><p class=ql-align-justify><strong>2、缺点</strong></p><p class=ql-align-justify>类适配器模式缺点：</p><ul><li class=ql-align-justify>因为Java不支持多重继承，一次最多适配一个适配者类，不能同时适配多个适配者。</li><li class=ql-align-justify>适配者类不能为最终类，即适配者类不能用final关键字修饰。</li><li class=ql-align-justify>类适配器模式中的目标类只能为接口，不能为类。</li></ul><p class=ql-align-justify>对象适配器模式缺点：</p><p class=ql-align-justify>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦（因为类适配器模式是基于继承的，可以重写适配者类的方法，对象适配器模式则不能），如果一定要置换掉适配者类的方法，可以先做一个适配者的子类，将适配者类的方法置换掉，然后再把适配者的子类当作真正的适配者进行适配，实现过程较为复杂。</p><p class=ql-align-justify><strong>3、适用场景</strong></p><ul><li class=ql-align-justify>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合需要。</li><li class=ql-align-justify>想创建一个可以重用的类，用于与一些彼此之间没有太大的关联的一些类，包括一些可能再将来引进的类一起工作。</li></ul><blockquote><strong>有任何问题，欢迎大家留言评论，希望大家喜欢记得转发+关注哦！</strong></blockquote><p class=ql-align-justify><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试题','配器','理解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>