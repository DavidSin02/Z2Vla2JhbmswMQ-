<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>图解 Python 浅拷贝与深拷贝 | 极客快訊</title><meta property="og:title" content="图解 Python 浅拷贝与深拷贝 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fbdd000ca71d40fabe436e5c4b96414f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/707c3c1b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/707c3c1b.html><meta property="article:published_time" content="2020-11-14T21:04:04+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:04+08:00"><meta name=Keywords content><meta name=description content="图解 Python 浅拷贝与深拷贝"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/707c3c1b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>图解 Python 浅拷贝与深拷贝</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>Python 中的赋值语句不会创建对象的拷贝，仅仅只是将名称绑定至一个对象。对于不可变对象，通常没什么差别，但是处理可变对象或可变对象的集合时，你可能需要创建这些对象的 “真实拷贝”，也就是在修改创建的拷贝时不改变原始的对象。</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>本文将以图文方式介绍 Python 中复制或“克隆”对象的操作。</p><p class=ql-align-justify>首先介绍一下 Python 中浅拷贝与深拷贝的区别：</p><ul><li class=ql-align-justify><strong>浅拷贝</strong>：浅拷贝意味着构造一个新的集合对象，然后用原始对象中找到的子对象的引用来填充它。从本质上讲，浅层的复制只有一层的深度。复制过程不会递归，因此不会创建子对象本身的副本。</li><li class=ql-align-justify><strong>深拷贝</strong>：深拷贝使复制过程递归。这意味着首先构造一个新的集合对象，然后递归地用在原始对象中找到的子对象的副本填充它。以这种方式复制一个对象，遍历整个对象树，以创建原始对象及其所有子对象的完全独立的克隆。</li></ul><p class=ql-align-justify><br></p><h1 class=ql-align-justify><strong>赋值与引用</strong></h1><p class=ql-align-justify>在开始浅拷贝与深拷贝前，我们先来看一下 Python 中的赋值与引用。</p><pre class=ql-align-justify>lst = [1, 2, 3]new_list = lst</pre><p class=ql-align-justify>从字面上看，上述语句创建了变量 lst 和 new_list，并且 lst 和 new_list 的赋值都为一个列表。但是，Python 的赋值语句并不会复制对象，而是会重新创建一个对象的引用。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fbdd000ca71d40fabe436e5c4b96414f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>可以看出，lst 和 new_list 都引用了同一个列表。</p><h1 class=ql-align-justify><strong>创建浅拷贝</strong></h1><p class=ql-align-justify>不少教程里都会提到，如果你有一个列表，当你想要修改列表中的值但却不想影响原始对象时，可以使用 list 复制（浅拷贝）一个列表。</p><p class=ql-align-justify>我们先来试一下：</p><pre class=ql-align-justify>lst = [1, 2, 3]new_list = list(lst)</pre><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c41dcaa0bbbc4884b8142bae8dfabb31><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>没错，lst 和 new_list 分别指向了不同的列表。当修改 lst 列表中的值时，并不会对 new_list 对象产生影响。</p><pre class=ql-align-justify>lst[0] = 'x'print(lst)print(new_list)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>['x', 2, 3][1, 2, 3]</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b647ec9377244b368b4f06ec0cdd4811><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>之所以说 list 语句是浅拷贝，是因为这种修改只对一层对象有效，当列表中有子对象时，对子对象的修改将影响原始对象和浅拷贝对象。</p><p class=ql-align-justify>为了解释这一说法，让我们先创建一个嵌套列表，并使用 list 函数创建浅拷贝。</p><pre class=ql-align-justify>lst = [[1, 2, 3], [4, 5, 6]]new_list = list(lst)</pre><p class=ql-align-justify>这里 new_list 是有着和 lst 一样内容的新的独立的对象。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ff1d32bcaf80450dbbd18e6d7f2fd44b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>可以看到 lst 和 new_list 分别指向了不同的对象。</p><p class=ql-align-justify>对第一层 lst 的修改，将不会对 new_list 副本造成影响。</p><pre class=ql-align-justify>lst.append([7, 8, 9])print(lst)print(new_list)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>[[1, 2, 3], [4, 5, 6], [7, 8, 9]][[1, 2, 3], [4, 5, 6]]</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b099933b1031408faf9a2e824ef65f92><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>但是，因为我们只创建了原始列表的一个浅拷贝，所以 new_list 仍然包含对 lst 中存储的原始子对象的引用。</p><p class=ql-align-justify>也就是如上图所示，lst 和 new_list 的子列表都指向了相同的对象。</p><p class=ql-align-justify>子对象没有被复制，它们只是在复制的列表中被再次引用。</p><p class=ql-align-justify>因此，当你修改 lst 中的一个子对象时，这种修改也会反映到 new_list 中—— 这是因为两个列表共享相同的子对象。这种复制只是一个浅的，一个层级的复制：</p><pre class=ql-align-justify>lst[0][0] = 'x'print(lst)print(new_list)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>[['x', 2, 3], [4, 5, 6], [7, 8, 9]][['x', 2, 3], [4, 5, 6]]</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aaecd14b81a24767946b96dab5aef139><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>如果我们在第一步中创建了一个 lst 的深拷贝，那么两个对象就完全独立了。这是对象的浅拷贝和深拷贝之间的实际区别。</p><p class=ql-align-justify>使用 Python 标准库中的 copy 模块可以创建深拷贝，这个模块为创建任意 Python 对象的浅拷贝和深拷贝提供了一个简单的接口。</p><h1 class=ql-align-justify><strong>创建深拷贝</strong></h1><p class=ql-align-justify>这次我们使用 deepcopy() 函数创建一个对象的深拷贝：</p><pre class=ql-align-justify>import copylst = [[1, 2, 3], [4, 5, 6]]new_list = copy.deepcopy(lst)</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d0219155b0c0442e9d74fc52079686a8><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>从图中可以看出 lst 和 new_list 中的子对象指向了不同的对象，如果对 lst 的子对象进行修改，将不会影响 new_list。</p><p class=ql-align-justify>这一次，原始对象和复制对象都是完全独立的。如前面所说，递归克隆了 lst，包括它的所有子对象：</p><pre class=ql-align-justify>lst[0][0] = 'x'print(lst)print(new_list)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>[['x', 2, 3], [4, 5, 6]][[1, 2, 3], [4, 5, 6]]</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9c79e0bf38634475aaa19f23bb36495e><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>copy 模块中的 copy.copy() 函数也可以创建对象的浅拷贝。使用 copy.copy() 可以明确地表示创建浅拷贝。对于内置集合，简单地使用 list、dict 和 set 等工厂函数来创建浅拷贝是更加 Pythonic 的。</p><h1 class=ql-align-justify><strong>复制任意 Python 对象</strong></h1><p class=ql-align-justify>copy.copy() 和 copy.deepcopy() 函数可用于复制任意对象。以前面的列表复制示例为基础。让我们从定义一个简单的 2D 点类开始：</p><pre class=ql-align-justify>class Point: def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return f'Point({self.x!r}, {self.y!r})'</pre><p class=ql-align-justify>__repr__() 函数使我们可以轻松地在 Python 解释器中检查从这个类创建的对象。</p><p class=ql-align-justify>接下来，我们将创建一个 Point 实例，然后使用 copy 模块复制（浅拷贝）它：</p><pre class=ql-align-justify>a = Point(23, 42)b = copy.copy(a)print(a is b)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>False</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4b34c5719c1f499c9e8f6eee889ca24c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>a 和 b 分别指向了不同的 Point 实例。因为我们的 Point 对象使用不可变类型（int）作为其座标，所以在这种情况下，浅拷贝和深拷贝没有区别。但我马上会展开这个例子。</p><p class=ql-align-justify>接下来定义另一个类来表示 2D 矩形。矩形将使用 Point 对象来表示它们的座标：</p><pre class=ql-align-justify>class Rectangle: def __init__(self, topleft, bottomright): self.topleft = topleft self.bottomright = bottomright def _repr__(self): return (f'Rectangle({self.topleft!r}, {self.bottomright!r})')# 创建一个 Rectangle 实例的浅拷贝rect = Rectangle(Point(0, 1), Point(5, 6))shallow_rect = copy.copy(rect)print(rect)print(shallow_rect)print(rect is shallow_rect)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>Rectangle(Point(0, 1), Point(5, 6))Rectangle(Point(0, 1), Point(5, 6))False</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5e1ba58600cb457c991b0782bc07c734><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>跟前面 list 的例子一样，rect 和 shallow_rect 的子对象都有相同的引用。在对象层级中修改一个对象，将看到这个变化也反映在浅拷贝的副本中：</p><pre class=ql-align-justify>rect.topleft.x = 999print(rect)print(shallow_rect)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>Rectangle(Point(999, 1), Point(5, 6))Rectangle(Point(999, 1), Point(5, 6))</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>接下来创建 Rectangle 的深拷贝并对其进行修改：</p><pre class=ql-align-justify>deep_rect = copy.deepcopy(rect)deep_rect.topleft.x = 222print(rect)print(shallow_rect)print(deep_rect)</pre><p class=ql-align-justify><br></p><pre class=ql-align-justify>Rectangle(Point(999, 1), Point(5, 6))Rectangle(Point(999, 1), Point(5, 6))Rectangle(Point(222, 1), Point(5, 6))</pre><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt="图解 Python 浅拷贝与深拷贝" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d6f28cb163cb49c1964e09a3e056d528><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>可以看出，深拷贝完全独立于原始对象和浅拷贝对象。</p><p class=ql-align-justify>参阅 copy 模块文档 可以对复制进行进一步的研究。例如，对象可以通过定义特殊的方法 __copy__() 和 __deepcopy__() 来控制如何复制它们。</p><h1 class=ql-align-justify><strong>谨记三件事</strong></h1><ul><li class=ql-align-justify>创建对象的浅拷贝不会克隆子对象。因此，拷贝不会完全独立于原始对象。</li><li class=ql-align-justify>一个对象的深拷贝会递归地克隆子对象。克隆对象完全独立于原始对象，但是创建深拷贝速度较慢。</li><li class=ql-align-justify>可以使用 copy 模块复制任意对象（包括自定义类）。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'拷贝','图解','Python'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>