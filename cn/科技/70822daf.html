<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） | 极客快訊</title><meta property="og:title" content="TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/153490532779764442c6667"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70822daf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70822daf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/70822daf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70822daf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70822daf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/70822daf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/70822daf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/70822daf.html><meta property="article:published_time" content="2020-11-14T21:03:08+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:08+08:00"><meta name=Keywords content><meta name=description content="TensorFlow实战：Chapter-7下（TFTS库与时间序列预测）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/70822daf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>TensorFlow实战：Chapter-7下（TFTS库与时间序列预测）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><ul><li>本节简介</li><li>TensorFlow更新</li><li>注意</li><li>下载最新源码编译源码更新</li><li>首先卸载当前的tensorflow</li><li>参考官方的从源码安装tensorflow</li><li>直接使用pip工具更新</li><li>更新后可能会遇到的异常</li><li>自定义LSTM循环神经网络进行时间序列预测</li><li>工程实现</li><li>需要用到的模块</li><li>生成训练数据与测试数据</li><li>注解</li><li>定义网络模型</li><li>创建模型并训练</li><li>Estimator工具</li><li>绘图</li><li>利用TFTS进行时间序列预测</li><li>载入数据部分</li><li>从CSV文件中读入时间序列数据</li><li>使用AR模型预测时间序列</li><li>代码实现</li><li>产生数据</li><li>创建ar模型</li><li>训练评估模型并预测</li><li>使用LSTM预测单变量时间序列</li><li>产生训练数据</li><li>定义训练模型并预测</li><li>绘制预测数据图</li><li>使用LSTM预测多变量时间序列</li><li>获取训练数据</li><li>定义训练模型并预测</li><li>绘制预测图</li><li>总结</li></ul><h1><strong>本节简介</strong></h1><p>本节关于TFTS模块的使用参考知乎-何之源-如何优雅地用TensorFlow预测时间序列：TFTS库详细教程。</p><p>如何在TensorFlow上使用LSTM来做时间序列预测是一个很老的话题，然而一直没有比较好的解决方案。在刚刚发布的TensorFlow1.3版本中，在tf.contrib包下引入了一个Time Series模块(TensorFlow Time Series,TFTS)。其源码地址在github timeseries。TFTS提供了一套基础的时间序列模型API。<strong>目前提供AR、Anomaly Mixture AR、LSTM三种预测模型。</strong></p><p>这里因为是刚刚发布的库，文档匮乏，我们着重于介绍TFTS的以下几个功能:</p><ul><li>读入时间序列数据（分为从numpy数组和csv文件两种方式）</li><li>用AR模型对时间序列进行预测</li><li>用LSTM模型对时间序列进行预测（包含单变量和多变量）</li></ul><p>先看效果图，</p><ol><li>使用自定义LSTM循环网络对单变量进行时间序列预测(没使用TFTS，代码比较繁琐):</li></ol><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153490532779764442c6667><p class=pgc-img-caption></p></div><ol><li><br></li><li>使用TFTS下的AR模型预测效果如下，蓝色为训练数据，绿色为模型拟合数据，红色为预测数据:</li></ol><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1534905340254238b94744c><p class=pgc-img-caption></p></div><ol><li><br></li><li>使用TFTS下的LSTM对单变量进行时间序列预测:</li></ol><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15349053676857b8384ce87><p class=pgc-img-caption></p></div><ol><li><br></li><li>使用TFTS下的LSTM对多变量进行时间序列预测:</li></ol><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15349053822246c145a2838><p class=pgc-img-caption></p></div><ol><li><br></li></ol><p>这里涉及到的代码保存在github-hzy46.网速不好的同学可以到或者在CSDN上下载。</p><hr><hr><h1><strong>TensorFlow更新</strong></h1><p><strong>注意</strong></p><p>后面使用的LSTM模型的例子须使用TensorFlow最新的开发版的源码。具体来说，要保证下面这句话可以成功执行。</p><p>from tensorflow.contrib.timeseries.python.timeseries.estimators import TimeSeriesRegressor</p><ul><li>1</li><li>2</li></ul><p>如果执行不成功，则需要下面的更新操作。</p><p><strong>下载最新源码(编译源码更新)</strong></p><p><strong>1. 首先卸载当前的tensorflow</strong></p><p>pip uninstall tensorflow #gpu版 就是tensorflow-gpu</p><ul><li>1</li><li>2</li></ul><p><strong>2. 参考官方的从源码安装tensorflow</strong></p><p>参考TensorFlow官方安装教程。我的开发环境是Ubuntu16.04+1080显卡，需要安装gpu版本。</p><ul><li>保证显卡驱动，CUDA8.0,cudnn6.0安装成功</li><li>安装bazel bazel安装教程</li><li>安装Python依赖包</li><li>sudo apt-get install python-numpy python-dev python-pip python-wheel # 对py2</li><li>sudo apt-get install python3-numpy python3-dev python3-pip python3-wheel #对py3</li><li>1</li><li>2</li><li>从github上下载最新的源码</li><li>git clone https://github.com/tensorflow/tensorflow</li><li>1</li><li>配置tensorflow安装</li><li>cd tensorflow # cd to the top-level directory created</li><li>$ ./configure</li><li>'''</li><li>除了CUDA项选择y，其他都是n或者默认项.</li><li>Configuration finished</li><li>'''</li><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>编译成pip包</li></ul><p>'''</p><p>编译</p><p>'''</p><p>bazel build --config=opt --config=cuda //tensorflow/tools/pip_package:build_pip_package</p><p>'''</p><p>挺长的一段编译时间</p><p>生产pip包</p><p>'''</p><p>bazel-bin/tensorflow/tools/pip_package/build_pip_package /tmp/tensorflow_pkg</p><p>'''</p><p>安装</p><p>'''</p><p>sudo pip install /tmp/tensorflow_pkg/tensorflow-1.3.0-py2-none-any.whl</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li></ul><p>如果出啥问题，建议直接看官方教程来整，有啥小问题，上stackoverflow上找找原因。(从源码编译tensorflow前前后后花费了我2天的时间，现在整出来了，踩了不少的坑，感觉下次会快很多了～)</p><p>现在9月初tensorflow的pip安装版本还不支持这个TimeSeriesRegressor类，等到后面版本稳定更新了，应该可以用下面pip工具更新。</p><p><strong>直接使用pip工具更新</strong></p><p>因为本次用到的库需要运行在TensorFlow1.3版本，而我的环境是Ubuntu下的1.0.1版本的TensorFlow。如果你不知道自己的TensorFlow是啥版本，有一个简单的方法:</p><p>激活python编程环境，键入以下代码运行即可。</p><p>import tensorflow as tf</p><p>print(tf.__version__) # 查看tensorflow版本</p><p>print(tf.__path__) # 查看tensorflow安装位置</p><p>'''</p><p>输出：</p><p>1.0.1</p><p>['/root/anaconda2/lib/python2.7/site-packages/tensorflow']</p><p>'''</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul><p>更新方法也很简单，如果你的TensorFlow是普通的安装，直接在命令行键入以下命令:</p><p>$: sudo pip install --upgrade tensorflow-gpu # 我安装的是gpu版</p><ul><li>1</li></ul><p>等待更新完成即可。</p><p>import tensorflow as tf</p><p>print(tf.__version__) # 查看tensorflow版本</p><p>print(tf.__path__) # 查看tensorflow安装位置</p><p>'''</p><p>输出：</p><p>1.3.0</p><p>['/root/anaconda2/lib/python2.7/site-packages/tensorflow']</p><p>'''</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul><p><strong>更新后可能会遇到的异常</strong></p><ul><li>问题描述:</li><li>libcudnn.so.6:cannot open sharedobject file: No such file or directory</li><li>1</li><li>问题分析:</li><li>我在开始安装1.0.1版本的tensorflow时，配置的是CUDA8.0+cudnn-v5.1。这里我把tensorflow升级到1.3版本，新的Tensorflow适配的是cudnn-v6.0。故需要升级cudnn。</li><li>解决办法:</li><li>升级cudnn的方法参考安装CUDNN。</li></ul><ol><li>下载适配CUDA版本和系统版本的cudnn-v6.0</li></ol><ul><li><br></li></ul><ol><li>解压下载好的cudnn</li><li>$ : sudo tar -zxvf cudnn-8.0-linux-x64-v6.0.tgz</li><li>…</li><li>将解压文件拷贝并修改权限</li><li>$ :sudo cp cuda/include/cudnn.h /usr/local/cuda/include/ # copy file</li><li>$ :sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lin64/</li><li>$ :sudo chmod a+r /usr/local/cuda/include/cudnn.h # 修改权限</li><li>$ :sudo chmod a+r /usr/local/cuda/libcudnn*</li></ol><ul><li>1</li><li>2</li><li>3</li><li>4</li></ul><p>到这里，算是大功告成了～</p><hr><hr><h1><strong>自定义LSTM循环神经网络进行时间序列预测</strong></h1><p>在使用TFTS库前，我们先利用自定义循环神经网络预测正弦函数。初步学习一下如何使用LSTM循环神经网络进行时间序列预测，这里我们会使用TensorFlow的一个高级封装工具-TFLearn(集成在tf.contrib.learn).</p><p><strong>工程实现</strong></p><p><strong>1. 需要用到的模块</strong></p><p># coding:utf8</p><p>import numpy as np</p><p>import tensorflow as tf</p><p>from tensorflow.contrib.learn.python.learn.estimators.estimator import SKCompat</p><p>import matplotlib.pyplot as plt</p><p>learn = tf.contrib.learn</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul><p><strong>2. 生成训练数据与测试数据</strong></p><p>因为是要预测正弦函数，这里我们使用np模块下的np.sin函数生成训练数据和测试数据。</p><p>TRAINING_EXAMPLES = 10000 # 训练数据大小</p><p>TESTING_EXAMPLES = 1000 # 测试数据大小</p><p>SAMPLE_GAP = 0.01 #采样间隔</p><p>TIMESTEPS = 10 # 循环神经网络截断长度</p><p>def generate_data(seq):</p><p>'''</p><p>定义生成正弦函数数据函数</p><p>:param seq:</p><p>:return: X为训练数据序列,y为预测数据</p><p>'''</p><p>X = []</p><p>y = []</p><p>for i in range(len(seq) - TIMESTEPS - 1):</p><p>X.append([seq[i: i + TIMESTEPS]]) # 截取以i下标开始的以TIMESTEPS为batch的数据</p><p>y.append([seq[i + TIMESTEPS]]) # 预测i+TIMESTEPS的数据</p><p>return np.array(X, dtype=np.float32), np.array(y, dtype=np.float32)</p><p># 生成数据</p><p># TRAINING_EXAMPLES训练数据个数 SAMPLE_GAP采样间隔</p><p>test_start = TRAINING_EXAMPLES * SAMPLE_GAP</p><p># 训练数据和测试数据个数</p><p>test_end = (TRAINING_EXAMPLES + TESTING_EXAMPLES) * SAMPLE_GAP</p><p># np.linspace生成等差数列 即采样横轴数据</p><p># 从0到test_start,生成TRAINING_EXAMPLES个数据(即采样间隔为SAMPLE_GAP)</p><p>train_X, train_y = generate_data(np.sin(np.linspace(</p><p>0, test_start, TRAINING_EXAMPLES, dtype=np.float32)))</p><p># np.linspace生成等差数列</p><p>#</p><p>test_X, test_y = generate_data(np.sin(np.linspace(</p><p>test_start, test_end, TESTING_EXAMPLES, dtype=np.float32)))</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li></ul><hr><p><strong>注解：</strong></p><p>训练数据TRAINING_EXAMPLES加上测试数据TESTING_EXAMPLES一共需要11000组。</p><p>这里我们设置是采样间隔SAMPLE_GAP是0.01。故我们整个采样距离是11000*0.01=110.也就是在sin函数上，x轴为[0,110]这段距离上均分为11000份。</p><p>训练数据是以网络的截断长度为分割间距。这里循环神经网络的截断长度TIMESTEPS为10。故我们的数据也是10个采样点和对应的sin值为一组，预测第11个点。(训练时候就是回归第11个点的值).</p><ul><li>先使用np.linspace函数取出等差间隔的采样点</li><li>再使用np.sin函数获得对应的sin值。</li><li>在生成数据generate_data时，以TIMESTEPS截断数据到X内，将TIMESTEPS+1个数据放到对应的标签y内。</li></ul><p>下面是np.linspace和np.sin的用法示例：</p><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534905400997ddbd9982c2><p class=pgc-img-caption></p></div><hr><p><strong>3. 定义网络模型</strong></p><p>我们使用BasicLSTMCell和MultiRNNCell构成一个hidden_size为30的2层的LSTM循环神经网络。需要注意的是<strong>不同版本下在创建LSTMCells的方法是不一样的。</strong></p><p>HIDDEN_SIZE = 30 # 隐藏单元个数</p><p>NUM_LAYERS = 2 #LSTM层数</p><p>TRAINING_STEPS = 3000 # 训练数据轮数</p><p>BATCH_SIZE = 32 # batch大小</p><p>def lstm_model(X, y):</p><p>'''</p><p>定义LSTM模型</p><p>:param X: 训练数据</p><p>:param y: 预测标签</p><p>:return:</p><p>'''</p><p># 1.2版本后,tensorflow对使用BasicLSTMCell等 RNNCells生成cells有不同的处理方法，这里多层的RNN建议采用这种创建cell方法</p><p>stacked_rnn = []</p><p>for iiLyr in range(NUM_LAYERS):</p><p>stacked_rnn.append(tf.nn.rnn_cell.BasicLSTMCell(HIDDEN_SIZE, state_is_tuple=True))</p><p>cell = tf.nn.rnn_cell.MultiRNNCell(cells=stacked_rnn, state_is_tuple=True)</p><p>#lstm_cell = tf.contrib.rnn.BasicLSTMCell(HIDDEN_SIZE, state_is_tuple=True) #1.2版本前</p><p>#cell = tf.contrib.rnn.MultiRNNCell([lstm_cell] * NUM_LAYERS)</p><p># 将多层LSTM结构连接成RNN网络并计算其前向传播结果</p><p>output, _ = tf.nn.dynamic_rnn(cell, X, dtype=tf.float32)</p><p># 只关注网络的最后一个输出结果,即为下一时刻的预测输出</p><p>output = tf.reshape(output, [-1, HIDDEN_SIZE])</p><p># 通过无激活函数的全联接层计算线性回归，并将数据压缩成一维数组的结构。</p><p>predictions = tf.contrib.layers.fully_connected(output, 1, None)</p><p>labels = tf.reshape(y, [-1])</p><p>predictions = tf.reshape(predictions, [-1])</p><p># 定义平方差损失</p><p>loss = tf.losses.mean_squared_error(predictions, labels)</p><p># 创建模型优化器并得到优化步骤</p><p>train_op = tf.contrib.layers.optimize_loss(</p><p>loss, tf.contrib.framework.get_global_step(),</p><p>optimizer="Adagrad", learning_rate=0.1)</p><p>return predictions, loss, train_op</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li></ul><p><strong>4. 创建模型并训练</strong></p><p>这里我们使用了tf.contrib.learn下的一个<strong>封装模型工具Estimator</strong>。使用Estimator封装好一个预测模型后((已训练)，我们对测试数据进行了预测，再计算了下均方误差，大体上的评估了一下模型的预测性能。</p><p># 封装之前定义的lstm</p><p># 如果你的tensorflow1.2版本前已经训练好了这样的的一个模型，在tensorflow更新后，重新生成模型。</p><p># 因为在新版本的Tensorflow里，LSTM单元的文件改变了，这里我们简单的把以前的model_dir修改了，保证创建了新的模型</p><p>regressor = SKCompat(learn.Estimator(model_fn=lstm_model, model_dir="Models/model_3"))</p><p># 拟合数据</p><p>regressor.fit(train_X, train_y, batch_size=BATCH_SIZE, steps=TRAINING_STEPS)</p><p># 计算预测值</p><p>predicted = [[pred] for pred in regressor.predict(test_X)]</p><p># 计算MSE</p><p>rmse = np.sqrt(((predicted - test_y) ** 2).mean(axis=0))</p><p>print ("Mean Square Error is: %f" % rmse[0])</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li></ul><hr><p><strong>Estimator工具</strong></p><p>这里我们简单的介绍以下Estimator工具。</p><p>参考TensorFlow 0.12 Estimators Models Layers学习笔记。Estimators的作用是:</p><ul><li>tf.estimator framework用于快速构建和训练机器学习模型，同时Estimator提供了一些常见的模型(常见的回归和分类模型，例如:线性分类，线性回归等)</li><li>tf.estimator为monitors,checkpointing提供了初始化配置，同时提供了构建和评估自定义模型的大部分逻辑。依照着tutorial可以很方便的创建一个estimator.TensorFlow关于Estimator介绍</li></ul><p>总的来说，我们可以认为tf.estimator工具是用来提供一个自定义模型的框架，我们照着定义好的格式配置好输入即可。</p><ol><li><strong>创建一个Estimator</strong></li></ol><ul><li>先看构造器定义:</li><li>init(model_fn=None, model_dir=None, config=None, params=None, feature_engineering_fn=None)</li><li>'''</li><li>Args:</li><li>model_fn: 模型定义，定义了train, eval, predict的实现</li><li>model_dir: log文件和训练参数的保存目录</li><li>config: Configuration object</li><li>params: dict of hyper parameters that will be passed into model_fn. Keys are names of parameters, values are basic python types.</li><li>feature_engineering_fn: Feature engineering function. Takes features and labels which are the output of input_fn and returns features and labels which will be fed into model_fn. Please check model_fn for a definition of features and labels.</li><li>'''</li><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li><strong>tf.estimator常接收2个参数:model_fn和model_dir.注意到我们使用的.</strong></li><li>learn.Estimator(model_fn=lstm_model, model_dir="Models/model_3") # model_fn和model_dir参数</li><li>1</li><li><strong>这里需要注意model_fn:</strong></li></ul><ol><li>model_fn(features, labels, mode, params)</li><li>'''</li><li>features: Tensor or dict of Tensor's. 即样本数据x.</li><li>labels: Tensor or dict of Tensor's. 样本数据y.(支持无标签训练，调整对应的mode即可)</li><li>mode: 指定model_fn功能.</li><li>params: params is a dict of hyperparameters</li><li>'''</li></ol><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul><ol><li><strong>训练模型</strong></li><li>将我们的训练数据塞给fit，训练完成后，就会按照前面指定的model_dir存放训练好的模型.</li><li>fit(x=None, y=None, input_fn=None, steps=None, batch_size=None, monitors=None, max_steps=None)</li><li>'''</li><li>x: 训练数据x. 格式为[n_samples,n_features...],如果设置此参数，input_fn需为None.</li><li>y: 训练数据y。x对应的标签。</li><li>steps: 每次训练ops.</li><li>batch_size: minibatch size.</li><li>moitors: Used for callbacks inside the training loop.</li><li>max_steps: Number of total steps for which to train model.</li><li>input_fn: 说白了就是把x，y，batch_size包装一下。 用这个就不用设置x,y,batch_size了.</li><li>'''</li></ol><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li></ul><ol><li><strong>预测</strong></li><li>将需要预测的数据塞给predict，返回的就是预测值.</li><li>predict(x=None, input_fn=None, batch_size=None, outputs=None, as_iterable=True)</li><li>'''</li><li>x : 为需要预测的数据。</li><li>batch_size: minibatch size.</li><li>input_fn: 对x和batch_size的包装</li><li>outputs: list of str, name of the output to predict. If None, returns all</li><li>as_iterable: If True, return an iterable which keeps yielding predictions for each example until inputs are exhausted. Note: The inputs must terminate if you want the iterable to terminate (e.g. be sure to pass num_epochs=1 if you are using something like read_batch_features).</li><li>'''</li></ol><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li></ul><ol><li><strong>注意</strong></li><li><strong>前面我说了如果在输入的时候设置x,y,batch_size就不要设置input_fn，需要注意的是:，如果使用x,y而不是input_fn来传参数的形式，需要用Estimator里一个叫SKCompat的类包装一下</strong>.</li><li>estimator_instance = SKCompat(Estimator(model_fn=..., model_dir=...))</li></ol><ul><li>1</li><li>2</li></ul><ol><li>到这里，我们对TensorFlow内的Estimator工具介绍就算结束了～</li></ol><hr><p><strong>5. 绘图</strong></p><p>使用plt将预测数据和测试数据绘制出来，有一个直观上的认识。</p><p>fig = plt.figure()</p><p>plot_predicted, = plt.plot(predicted, label='predicted')</p><p>plot_test, = plt.plot(test_y[0:399], label='real_sin')</p><p>plt.legend([plot_predicted, plot_test],['predicted', 'real_sin'])</p><p>plt.show()</p><p>fig.savefig('pre_sin.png')</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li></ul><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534905420970d8901ff26f><p class=pgc-img-caption></p></div><hr><hr><h1><strong>利用TFTS进行时间序列预测</strong></h1><p>到这里算是切入主题了，下面介绍如何使用TFTS模块进行时间序列预测。</p><p><strong>载入数据部分</strong></p><p>对于时间序列预测问题，我们可以把<strong>数据抽象成:{观察点:观察值}</strong>。例如某年一月的价格为120元，二月的价格为130元，三月的价格为135元，四月的价格为132元。那么观察的时间点可以看做是1,2,3,4，而在各时间点上观察到的数据的值为120,130,135,132。</p><p>TFTS库提供了两个数据读取器NumpyReader和CSVReader.</p><p>NumpyReader用于从Numpy数组中读入数据，下面举一个demo:</p><p>import numpy as np</p><p>import matplotlib.pyplot as plt</p><p>x = np.array(range(1000))</p><p>noise = np.random.uniform(-0.2, 0.2, 1000) # 随机生成-0.2~0.2之间的数据</p><p>y = np.sin(np.pi * x * 0.01) + x * 0.005 + noise # y=sin(0.01*pi*x) + 0.005*x + noise</p><p>p = plt.plot(x, y)</p><p>plt.show()</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15349054358039a9e76c444><p class=pgc-img-caption></p></div><p>横轴即’采样点x’,纵轴为’采样值y’.</p><p>TFTS提供的读入x和y的接口非常简单，使用demo如下:</p><p>data = {</p><p>tf.contrib.timeseries.TrainEvalFeatures.TIMES: x,</p><p>tf.contrib.timeseries.TrainEvalFeatures.VALUES: y,</p><p>}</p><p>reader = NumpyReader(data)</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li></ul><p>我们首先把x和y转为Python中的dict.我们来分析以下上面data的写法。tf.contrib.timeseries.TrainEvalFeatures.TIMES就是一个字符串’times’，而对应tf.contrib.timeseries.TrainEvalFeatures.VALUES也是一个字符串’values’.上面的data定义也可以写成:</p><p>data = {</p><p>'times' : x,</p><p>'values': y,</p><p>}</p><ul><li>1</li><li>2</li><li>3</li><li>4</li></ul><p>至于为什么写成上面的那个形式，也是为了配合规范化。</p><p>NumpyReader返回的对象有一个<strong>read_full()方法，该方法用于从Reader中读取所有的数据</strong>，但需要注意的是:<strong>read_full()会产生读取队列</strong>(这样的处理训练数据的方法和TensorFlow开源的AlexNet网络上对输入数据做增强操作使用的方法类似)，这要求我们在使用该方法前，需要<strong>先调用tf.train.start_queue_runners启动队列</strong>，然后才能读取数据。使用的demo如下:</p><p>with tf.Session() as sess:</p><p>full_data = reader.read_full()</p><p>coord = tf.train.Coordinator() # 创建一个线程协调器</p><p>threads = tf.train.start_queue_runners(sess=sess, coord=coord) # 启动线程队列</p><p>print('times shape:', full_data['times'])</p><p>print('values shape:', full_data['values'])</p><p>print(sess.run(full_data)['times'][0:10])</p><p>print(sess.run(full_data)['values'][0:10])</p><p>coord.request_stop()</p><p>'''</p><p>输出:</p><p>times shape: Tensor("Squeeze_1:0", shape=(1000,), dtype=int64)</p><p>values shape: Tensor("Squeeze:0", shape=(1000, 1), dtype=float64)</p><p>[0 1 2 3 4 5 6 7 8 9]</p><p>[[-0.09581681]</p><p>[ 0.01284531]</p><p>[ 0.1107236 ]</p><p>[ 0.08856841]</p><p>[ 0.19104294]</p><p>[ 0.32795446]</p><p>[ 0.17780316]</p><p>[ 0.35017529]</p><p>[ 0.10477021]</p><p>[ 0.16101822]]</p><p>'''</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li></ul><p>通常在训练模型时，我们采需要的是<strong>minibatch形式的训练数据</strong>，TFTS库提供了<strong>tf.contrib.timeseries.RandomWindowInputFn</strong>方法用于在reader中随机选取window_size大小的数据组成一组序列数据。demo如下:</p><p>train_input_fn = tf.contrib.timeseries.RandomWindowInputFn(</p><p>reader, batch_size=2, window_size=10)</p><p>with tf.Session() as sess:</p><p>batch_data = train_input_fn.create_batch()</p><p>coord = tf.train.Coordinator()</p><p>threads = tf.train.start_queue_runners(sess=sess, coord=coord)</p><p>one_batch = sess.run(batch_data[0])</p><p>coord.request_stop()</p><p>print('one_batch_data:', one_batch)</p><p>'''</p><p>即一个batch为2组序列数据，每组序列数据有10条数据。</p><p>输出:</p><p>one_batch_data: {</p><p>'values': array([[[ 1.21827106],</p><p>[ 1.37975747],</p><p>[ 1.15419451],</p><p>[ 1.07579377],</p><p>[ 1.19008057],</p><p>[ 1.32173953],</p><p>[ 1.2152622 ],</p><p>[ 1.31092923],</p><p>[ 1.26184174],</p><p>[ 1.25915473]],</p><p>[[ 0.08465949],</p><p>[-0.0859257 ],</p><p>[-0.02987006],</p><p>[ 0.17472125],</p><p>[ 0.23542243],</p><p>[ 0.2032668 ],</p><p>[ 0.07650485],</p><p>[ 0.20822309],</p><p>[ 0.30753332],</p><p>[ 0.16054565]]]),</p><p>'times': array([[61, 62, 63, 64, 65, 66, 67, 68, 69, 70],</p><p>[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]])}</p><p>'''</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li></ul><p>TFTS从Numpy中读取数据的流程大概操作就是这样了～</p><hr><p><strong>从CSV文件中读入时间序列数据</strong></p><p>TFTS还提供了CSVReader用于读取CSV文件。</p><p>项目中提供了一个input_input_csv.py文件用于处理csv文件，这里处理的文件是’./data/period_trend.csv’.</p><p>这里CSV的文件形式如下(截取):</p><p>1,-0.6656603714</p><p>2,-0.1164380359</p><p>3,0.7398626488</p><p>4,0.7368633029</p><p>5,0.2289480898</p><p>6,2.257073255</p><p>7,3.023457405</p><p>8,2.481161007</p><p>9,3.773638612</p><p>10,5.059257738</p><p>11,3.553186083</p><p>12,4.554486452</p><p>13,3.655475698</p><p>14,3.419647598</p><p>15,4.303376245</p><p>16,4.830153934</p><p>17,7.253057441</p><p>18,5.064802335</p><p>19,5.448082106</p><p>20,6.251301517</p><p>...</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li></ul><p>CSV的第一列数据为时间点，第二列数据为对应的观察值。</p><p>CSVReader的操作步骤除了读取文件的部分不同，后面的操作和前面的NumpyReader是一样的。操作的demo如下:</p><p>from __future__ import print_function</p><p>import tensorflow as tf</p><p>csv_file_name = './data/period_trend.csv'</p><p>reader = tf.contrib.timeseries.CSVReader(csv_file_name)</p><p>with tf.Session() as sess:</p><p>data = reader.read_full()</p><p>coord = tf.train.Coordinator()</p><p>threads = tf.train.start_queue_runners(sess=sess, coord=coord)</p><p>print(sess.run(data))</p><p>coord.request_stop()</p><p>train_input_fn = tf.contrib.timeseries.RandomWindowInputFn(reader, batch_size=4, window_size=16)</p><p>with tf.Session() as sess:</p><p>data = train_input_fn.create_batch()</p><p>coord = tf.train.Coordinator()</p><p>threads = tf.train.start_queue_runners(sess=sess, coord=coord)</p><p>batch1 = sess.run(data[0])</p><p>batch2 = sess.run(data[0])</p><p>coord.request_stop()</p><p>print('batch1:', batch1)</p><p>print('batch2:', batch2)</p><p>'''</p><p>输出:</p><p>{'values': array([[ -0.66566038],</p><p>[ -0.11643804],</p><p>[ 0.73986262],</p><p>[ 0.73686332],</p><p>[ 0.22894809],</p><p>[ 2.25707316],</p><p>[ 3.02345729],</p><p>...</p><p>dtype=float32), 'times': array([ 1, 2, 3, 4, 5, 6, ...，500])}</p><p>batch1: {'values': array([[[ 9.75562382],</p><p>[ 9.1494894 ],</p><p>[ 8.94796562],</p><p>[ 9.1767683 ],dtype=float32), 'times': array([[ 98, 99，...,129]])}</p><p>batch2: {'values': array([[[ 4.97288084],</p><p>[ 5.21278238],...，dtype=float32), 'times': array([[ 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,</p><p>95, 96, 97],...，226]])}</p><p>'''</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li><li>28</li><li>29</li><li>30</li><li>31</li><li>32</li><li>33</li><li>34</li><li>35</li><li>36</li><li>37</li><li>38</li><li>39</li><li>40</li><li>41</li><li>42</li><li>43</li><li>44</li><li>45</li><li>46</li><li>47</li></ul><p>到这里为止，载入数据部分到这里就算结束了。</p><hr><p><strong>使用AR模型预测时间序列</strong></p><p>AR模型是一种线性预测，即已知N个数据，可由模型推出第N点前面或后面的数据（设推出P点），所以其本质类似于插值，其目的都是为了增加有效数据，只是AR模型是由N点递推，而插值是由两点（或少数几点）去推导多点，所以AR模型要比插值方法效果更好。</p><p><strong>代码实现</strong></p><p><strong>产生数据</strong></p><p>产生数据的方法就是上面介绍的方法。</p><p>x = np.array(range(1000))</p><p>noise = np.random.uniform(-0.2, 0.2, 1000)</p><p>y = np.sin(np.pi * x / 100) + x / 200. + noise</p><p>plt.plot(x, y)</p><p>plt.savefig('timeseries_y.jpg')</p><p>data = {</p><p>tf.contrib.timeseries.TrainEvalFeatures.TIMES: x,</p><p>tf.contrib.timeseries.TrainEvalFeatures.VALUES: y,</p><p>}</p><p>reader = NumpyReader(data)</p><p>train_input_fn = tf.contrib.timeseries.RandomWindowInputFn(</p><p>reader, batch_size=16, window_size=40)</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul><p><strong>创建ar模型</strong></p><p>创建ar模型，我们需要使用tf.contrib.timeseries.ARRegressor类</p><hr><p>先看下ARRegressor类</p><p>class ARRegressor(_TimeSeriesRegressor):</p><p>"""</p><p>ARRegressor是基于滑窗模型的。这要求输入窗口大小要固定为'input_window_size'，输出窗口大小固定为'output_window_size'. 同时这两个参数的和必须等于window_size(满足训练或评估时使用的input_fn)。建议使用'RandomWindowInputFn'(就是上面讲的随机产生batch数据的函数)产生训练或者评估。</p><p>"""</p><p>def __init__(self,</p><p>periodicities, input_window_size,</p><p>output_window_size, num_features, num_time_buckets=10,</p><p>loss=ar_model.ARModel.NORMAL_LIKELIHOOD_LOSS,</p><p>hidden_layer_sizes=None, anomaly_prior_probability=None,</p><p>anomaly_distribution=None, optimizer=None,</p><p>model_dir=None, config=None):</p><p>"""</p><p>参数:</p><p>periodicities: value or a list of values. 输入信号的周期。</p><p>input_window_size: 回归时给定的输入数据时间步数.</p><p>output_window_size: 预测时间步数，建议设置>1.</p><p>num_features: 时间序列的维度.(数据的观察值)</p><p>loss: SQUARED_LOSS 或者 NORMAL_LIKELIHOOD_LOSS.</p><p>hidden_layer_sizes: 默认即可.</p><p>anomaly_distribution；anomaly_distribution: 默认即可，指定即构成混合模型</p><p>optimizer: defaults to Adagrad with step size 0.1.</p><p>model_dir:模型存储地址.(上面Estimator有讲)</p><p>config: See `Estimator`.</p><p>"""</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li><li>18</li><li>19</li><li>20</li><li>21</li><li>22</li><li>23</li><li>24</li><li>25</li><li>26</li><li>27</li></ul><p>总的来说，需要填的参数有periodicities,input_window_size,output_window_size,num_features,loss。其它的参数默认即可。</p><hr><p>这里需要注意的有<strong>input_window_size + output_window_size = window_size</strong>.(RandomWindowInputFn生成数据里面的window_size).我们在上面的生成数据使用的window_size=40.下面使用的是input_window_size=30, output_window_size=10.就是输入序列30个，预测10个。</p><p><strong>num_features</strong>即时间序列的维度。就是在一个时间点上观察到的数据维度。我们这里每一步都是一个单独的值，所以num_features=1。</p><p><strong>periodicities</strong>是信号的周期分量的周期，我们信号的表达式为:</p><p>y=sin(0.01∗π∗x)+0.005∗x+noise</p><p>y=sin(0.01∗π∗x)+0.005∗x+noise</p><p>y的周期分量的frequency为2∗π∗(1/f)</p><p>2∗π∗(1/f),故f=200,所以periodicities=200</p><p>f=200,所以periodicities=200。</p><p><strong>loss</strong>的取值现在支持NORMAL_LIKELIHOOD_LOSS和SQUARED_LOSS。 ar = tf.contrib.timeseries.ARRegressor(</p><p>periodicities=200, input_window_size=30, output_window_size=10,</p><p>num_features=1,</p><p>loss=tf.contrib.timeseries.ARModel.NORMAL_LIKELIHOOD_LOSS)</p><p>'''</p><p>(input_window_size=30) + (output_window_size=10) = (window_size=40)</p><p>'''</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul><p><strong>训练评估模型并预测</strong></p><p>使用train函数传入创建好的数据train_input_fn训练模型即可.</p><p>ar.train(input_fn=train_input_fn, steps=6000)</p><ul><li>1</li></ul><p>接下来就是对模型进行评估，首先我们使用AR模型提供的evaluate函数，这里evaluation的处理是使用训练好的模型在原先的训练集上进行计算，由此我们可以观察到模型的拟合效果.</p><p>evaluation_input_fn = tf.contrib.timeseries.WholeDatasetInputFn(reader)</p><p>evaluation = ar.evaluate(input_fn=evaluation_input_fn, steps=1)</p><p># keys of evaluation: ['covariance', 'loss', 'mean', 'observed', 'start_tuple', 'times', 'global_step']</p><p># evaluation['covariance']代表协方差 evaluation['loss']代表损失 etc..</p><ul><li>1</li><li>2</li><li>3</li><li>4</li></ul><p>如果要理解这里evaluate函数的逻辑，这里AR模型：每次都接收长度为30的输入观测序列，并输出长度为10的预测序列。以此为规则，每次移动步长为1，以此类推，整个训练集长度为1000的序列，最终我们得到970个预测值。</p><p>这970个预测值记录在evaluation[‘mean’]中;evaluation还有其他几个键值:evaluation[‘loss’]表示总的损失，evaluation[‘times’]表示evaluation[‘mean’]对应的时间点等等.</p><p>评估完模型后，下面该是使用模型了，这里我们会用到predict函数来预测，传入参数为evaluation[‘start_tuple’]会被用于之后的预测中，它相当于最后30步的输出值和对应的时间点。以此为起点(也就是给定观察数据)，我们可以对1000步以后的值进行预测，对应的代码为：</p><p>(predictions,) = tuple(ar.predict(</p><p>input_fn=tf.contrib.timeseries.predict_continuation_input_fn(</p><p>evaluation, steps=250)))</p><ul><li>1</li><li>2</li><li>3</li></ul><p>这里的代码在1000步之后又像后预测了250个时间点。对应的值就保存在predictions[‘mean’]中。我们可以把观测到的值、模型拟合的值、预测值用下面的代码画出来：</p><p>plt.figure(figsize=(15, 5))</p><p>plt.plot(data['times'].reshape(-1), data['values'].reshape(-1), label='origin')</p><p>plt.plot(evaluation['times'].reshape(-1), evaluation['mean'].reshape(-1), label='evaluation')</p><p>plt.plot(predictions['times'].reshape(-1), predictions['mean'].reshape(-1), label='prediction')</p><p>plt.xlabel('time_step')</p><p>plt.ylabel('values')</p><p>plt.legend(loc=4)</p><p>plt.savefig('predict_result.jpg')</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li></ul><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534905582992424220237f><p class=pgc-img-caption></p></div><hr><p><strong>使用LSTM预测单变量时间序列</strong></p><p>注意：以下LSTM模型的例子必须使用TensorFlow最新的开发版的源码。具体来说，要保证</p><p>from tensorflow.contrib.timeseries.python.timeseries.estimators import TimeSeriesRegressor</p><ul><li>1</li></ul><p>可以成功执行。(就是前面说的需要安装最新版的tensorflow)</p><p>给出两个用LSTM预测时间序列模型的例子，分别是train_lstm.py和train_lstm_multivariate.py。前者是在LSTM中进行单变量的时间序列预测，后者是使用LSTM进行多变量时间序列预测。为了使用LSTM模型，我们需要先使用TFTS库对其进行定义，定义模型的代码来源于TFTS的示例源码，在train_lstm.py和train_lstm_multivariate.py中分别拷贝了一份。</p><p><strong>产生训练数据</strong></p><p>这里我们产生的数据公式修改一下</p><p>y=sin(π∗0.02∗x)+cos(π∗0.02∗x)+sin(π∗0.04∗x)+noise</p><p>y=sin(π∗0.02∗x)+cos(π∗0.02∗x)+sin(π∗0.04∗x)+noise</p><p>同样用函数加噪声的方法生成一个模拟的时间序列数据：</p><p>x = np.array(range(1000))</p><p>noise = np.random.uniform(-0.2, 0.2, 1000)</p><p>y = np.sin(np.pi * x / 50 ) + np.cos(np.pi * x / 50) + np.sin(np.pi * x / 25) + noise</p><p>data = {</p><p>tf.contrib.timeseries.TrainEvalFeatures.TIMES: x,</p><p>tf.contrib.timeseries.TrainEvalFeatures.VALUES: y,</p><p>}</p><p>'''</p><p>plt.plot(x, y)</p><p>plt.savefig('train_data.jpg')</p><p>'''</p><p>reader = NumpyReader(data)</p><p>train_input_fn = tf.contrib.timeseries.RandomWindowInputFn(</p><p>reader, batch_size=4, window_size=100) # batch_size为4 序列长度为100</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li></ul><p>产生数据如下:</p><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534905461004578947d80b><p class=pgc-img-caption></p></div><p><strong>定义训练模型并预测</strong></p><p>这里使用TFTS包内提供的TimeSeriesRegressor模型。其中_LSTMModel来自TFTS包的官方例子。</p><hr><ul><li><strong>_LSTMModel接受两个参数:</strong>num_units: 模型中使用的LSTM单元个数</li><li>num_features: 时间序列能观察到的维度.(即每个时间步能观察到的数据特征量)</li></ul><p>这里我们使用的模型参数为num_features = 1表示单变量时间序列，即每个时间点上观察到的量只是一个单独的数值。num_units=128表示使用隐层为128大小的LSTM模型。后续的训练，评估，预测和前面讲的代码类似。在以后的1000组数据上，我们向后预测了200组数据。</p><hr><p>代码如下:</p><p>estimator = ts_estimators.TimeSeriesRegressor(</p><p>model=_LSTMModel(num_features=1, num_units=128),</p><p>optimizer=tf.train.AdamOptimizer(0.001))</p><p>estimator.train(input_fn=train_input_fn, steps=2000)</p><p>evaluation_input_fn = tf.contrib.timeseries.WholeDatasetInputFn(reader)</p><p>evaluation = estimator.evaluate(input_fn=evaluation_input_fn, steps=1)</p><p># Predict starting after the evaluation 预测后续的200组数据</p><p>(predictions,) = tuple(estimator.predict(</p><p>input_fn=tf.contrib.timeseries.predict_continuation_input_fn(</p><p>evaluation, steps=200)))</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li></ul><p><strong>绘制预测数据图</strong></p><p>observed_times = evaluation["times"][0]</p><p>observed = evaluation["observed"][0, :, :]</p><p>evaluated_times = evaluation["times"][0]</p><p>evaluated = evaluation["mean"][0]</p><p>predicted_times = predictions['times']</p><p>predicted = predictions["mean"]</p><p>plt.figure(figsize=(15, 5))</p><p>plt.axvline(999, linestyle="dotted", linewidth=4, color='r')</p><p>observed_lines = plt.plot(observed_times, observed, label="observation", color="k")</p><p>evaluated_lines = plt.plot(evaluated_times, evaluated, label="evaluation", color="g")</p><p>predicted_lines = plt.plot(predicted_times, predicted, label="prediction", color="r")</p><p>plt.legend(handles=[observed_lines[0], evaluated_lines[0], predicted_lines[0]],</p><p>loc="upper left")</p><p>plt.savefig('predict_result.jpg')</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15349056032327a60fa42cb><p class=pgc-img-caption></p></div><hr><p><strong>使用LSTM预测多变量时间序列</strong></p><p>与上面的使用LSTM预测单变量时间序列不同的地方在于数据的读取和模型的预测量。使用原理实质上是一致的。</p><p><strong>获取训练数据</strong></p><p>所谓多变量时间序列，就是指在每个时间点上的观测量有多个值。在data/multivariate_periods.csv文件中，保存了一个多变量时间序列的数据：(下面是截取)</p><p>0,0.926906299771,1.99107237682,2.56546245685,3.07914768197,4.04839057867</p><p>1,0.108010001864,1.41645361423,2.1686839775,2.94963962176,4.1263503303</p><p>2,-0.800567600028,1.0172132907,1.96434754116,2.99885333086,4.04300485864</p><p>3,0.0607042871898,0.719540073421,1.9765012584,2.89265588817,4.0951014426</p><p>4,0.933712200629,0.28052120776,1.41018552514,2.69232603996,4.06481164223</p><p>5,-0.171730652974,0.260054421028,1.48770816369,2.62199129293,4.44572807842</p><p>6,-1.00180162933,0.333045158863,1.50006392277,2.88888309683,4.24755865606</p><p>7,0.0580061875336,0.688929398826,1.56543458772,2.99840358953,4.52726873347</p><p>8,0.764139447412,1.24704875327,1.77649279698,3.13578593851,4.63238922951</p><p>9,-0.230331874785,1.47903998963,2.03547545751,3.20624030377,4.77980005228</p><p>10,-1.03846045211,2.01133000781,2.31977503972,3.67951536251,5.09716775897</p><p>11,0.188643592253,2.23285349038,2.68338482249,3.49817168611,5.24928239634</p><p>12,0.91207302309,2.24244446841,2.71362604985,3.96332587625,5.37802271594</p><p>13,-0.296588665881,2.02594634141,3.07733910479,3.99698324956,5.56365901394</p><p>14,-0.959961476551,1.45078629833,3.18996420137,4.3763059609,5.65356015609</p><p>15,0.46313530679,1.01141441548,3.4980215948,4.20224896882,5.88842247449</p><p>16,0.929354125798,0.626635305936,3.70508262244,4.51791573544,5.73945973251</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li><li>16</li><li>17</li></ul><p>即每个时间步上能观察到多个数据变量(这里有5组数据)。举个简单的例子:如果现在我在跑步，每个时间步上，可以获取到我的心跳，血压，体温。这就是在每个时间步上能观察到3个数据变量。</p><p>下面依旧是使用CSVReader处理数据，区别在column_names参数，该参数告诉CSVReader那些变量是对应的时间步和变量。</p><p>csv_file_name = path.join("./data/multivariate_periods.csv")</p><p>reader = tf.contrib.timeseries.CSVReader(</p><p>csv_file_name,</p><p>column_names=((tf.contrib.timeseries.TrainEvalFeatures.TIMES,)</p><p>+ (tf.contrib.timeseries.TrainEvalFeatures.VALUES,) * 5))</p><p>train_input_fn = tf.contrib.timeseries.RandomWindowInputFn(</p><p>reader, batch_size=4, window_size=32)</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li></ul><p><strong>定义训练模型并预测</strong></p><p>这里与上面的程序不同的地方在于_LSTMModel中参数num_features=5.即能观察的数据量维度为5.本次向后预测的数据为100组。(训练数据100组)</p><p>estimator = ts_estimators.TimeSeriesRegressor(</p><p>model=_LSTMModel(num_features=5, num_units=128),</p><p>optimizer=tf.train.AdamOptimizer(0.001))</p><p>estimator.train(input_fn=train_input_fn, steps=200)</p><p>evaluation_input_fn = tf.contrib.timeseries.WholeDatasetInputFn(reader)</p><p>evaluation = estimator.evaluate(input_fn=evaluation_input_fn, steps=1)</p><p># Predict starting after the evaluation</p><p>(predictions,) = tuple(estimator.predict(</p><p>input_fn=tf.contrib.timeseries.predict_continuation_input_fn(</p><p>evaluation, steps=100)))</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li></ul><p><strong>绘制预测图</strong></p><p>observed_times = evaluation["times"][0]</p><p>observed = evaluation["observed"][0, :, :]</p><p>evaluated_times = evaluation["times"][0]</p><p>evaluated = evaluation["mean"][0]</p><p>predicted_times = predictions['times']</p><p>predicted = predictions["mean"]</p><p>plt.figure(figsize=(15, 5))</p><p>plt.axvline(99, linestyle="dotted", linewidth=4, color='r')</p><p>observed_lines = plt.plot(observed_times, observed, label="observation", color="k")</p><p>evaluated_lines = plt.plot(evaluated_times, evaluated, label="evaluation", color="g")</p><p>predicted_lines = plt.plot(predicted_times, predicted, label="prediction", color="r")</p><p>plt.legend(handles=[observed_lines[0], evaluated_lines[0], predicted_lines[0]],</p><p>loc="upper left")</p><p>plt.savefig('predict_result.jpg')</p><ul><li>1</li><li>2</li><li>3</li><li>4</li><li>5</li><li>6</li><li>7</li><li>8</li><li>9</li><li>10</li><li>11</li><li>12</li><li>13</li><li>14</li><li>15</li></ul><div class=pgc-img><img alt=TensorFlow实战：Chapter-7下（TFTS库与时间序列预测） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15349054915748b089e1943><p class=pgc-img-caption></p></div><hr><hr><h1><strong>总结</strong></h1><p>TFTS是Tensorflow官方提供的基于LSTM模型的时序预测工具，可以用于常见的时序模型上(替代HMM)。这里讲了如果使用TFTS模型读取数据并产生训练数据，同时讲了如果使用TFTS模块自带的AR和LSTM模型。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'TensorFlow','实战','Chapter'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>