<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>10 分钟看懂虚拟内存底层原理 | 极客快訊</title><meta property="og:title" content="10 分钟看懂虚拟内存底层原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e561c334c9f14a0eb1f7c339fa911b81"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71574c5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71574c5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/71574c5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71574c5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71574c5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/71574c5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/71574c5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/71574c5.html><meta property="article:published_time" content="2020-10-29T20:59:05+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:05+08:00"><meta name=Keywords content><meta name=description content="10 分钟看懂虚拟内存底层原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/71574c5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>10 分钟看懂虚拟内存底层原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>来源：zhuanlan.zhihu.com/p/61587598</p><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e561c334c9f14a0eb1f7c339fa911b81><p class=pgc-img-caption></p></div><p>前文我们又挖了许多坑，虚拟内存、DMA 等，越来越底层了。当然，我们一往无前，今天我们来学习虚拟内存到底是为何物，发现一篇好文，重新编辑了下，推荐大家！</p><h1 class=pgc-h-arrow-right>一、什么是虚拟内存？</h1><p>在理解什么是虚拟内存前，我们得先清楚什么是物理内存以及物理寻址，物理内存指的是硬件上的内存，因为 CPU 可以直接从物理内存中读取数据和指令，所以物理内存又叫做主存。</p><p>主存可以看做是一个由 M 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址（Physical Address，PA）。第一个字节的地址为 0，接下来的地址为 1，以此类推。<strong>CPU 访问内存的最简单的方式是使用物理寻址（physical addressing）。</strong></p><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9f2c8966e87447b902a2dd01f3ebff3><p class=pgc-img-caption></p></div><p>上图的是一条加载指令， CPU 在执行这条指令的时候，生成一个有效物理地址，通过内存总线，把这个物理地址传递给主存，主存取出从物理地址4处开始的 4 个字节字，然后将它返回给 CPU。</p><p>这种直接使用物理内存的状态下就会产生一些问题：</p><p>1、<strong>内存空间利用率的问题</strong>，各个进程对内存的使用会导致内存碎片化，当要用 malloc 分配一块很大的内存空间时，可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况，东一块西一块的内存碎片就被浪费掉了。</p><p>2、<strong>读写内存的安全性问题</strong>，物理内存本身是不限制访问的，任何地址都可以读写，而现代操作系统需要实现不同的页面具有不同的访问权限，例如只读的数据等等。</p><p>3、<strong>进程间的安全问题</strong>，各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，甚至修改内核地址空间的数据，这是操作系统所不愿看到的。</p><p>4、<strong>内存读写的效率问题</strong>，当多个进程同时运行，需要分配给进程的内存总和大于实际可用的物理内存时，需要将其他程序暂时拷贝到硬盘当中，然后将新的程序装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低。</p><p>为了解决上述的问题，大佬们设计了虚拟内存。</p><p><strong>虚拟内存（virtual memory，VM）</strong>，是一种内存管理技术。它是操作系统提供的一种对主存的抽象。虚拟内存的实现由操作系统软件和硬件结合完成，包括硬件异常、地址翻译、磁盘文件、内核程序等。</p><p><br></p><h1 class=pgc-h-arrow-right>二、虚拟内存解决了什么问题？</h1><p>1）虚拟内存给进程提供了一个更大的内存空间，不再受物理内存大小的限制。它将物理内存看作是存储在磁盘上的地址空间的缓存。虚拟内存技术在主存中只保留活动区域，然后根据需要在磁盘和主存之间来回传送数据，这样，它就可以更加高效的利用主存。</p><p>2）虚拟内存为程序提供内存管理。我们在敲代码的时候，不需要考虑这个变量会不会被其它程序错误的修改。因为虚拟内存帮我们做了这些事情，它给程序提供了<strong>内存隔离</strong>，为程序提供了安全的共享物理内存的途径。<strong>使得每个进程的地址空间不会被其它进程破坏。</strong>比如说我们在程序中定义了一个指针，并且为它分配了空间，这块内存最终会分配到物理内存上，你不用担心其它程序会分配相同的物理内存。</p><p>3）虚拟内存技术也给每个进程提供了一致的、完整的地址空间。比如在操作系统上执行若干个进程，每个进程都有相同的地址空间，都在同样的起始位置放置了堆、栈以及代码段等。这样，它简化了像链接器、加载器这样的程序的内存管理。</p><p><br></p><h1 class=pgc-h-arrow-right>三、虚拟寻址</h1><p>那一个进程可以用的内存究竟是多大呢？这主要受两方面的限制：</p><p>1）设置的<strong>交换空间</strong>的大小与物理内存大小的总和，虚拟内存存储在磁盘上面的空间就叫做交换空间，它通常对应一个文件或者是一个分区。所有进程共享同一个交换空间，如果交换空间和物理内存都被耗尽了，那么就不能再分配内存了。</p><p>2）进程可用的内存大小还受<strong>虚拟地址空间大小</strong>的影响，当一个进程的虚拟地址空间的所有地址都被分配了，那也不能再分配内存了。</p><p>在 32 位的程序中，由于指针的大小是 4 字节，所以它只能访问地址为 [0, 232 ) 的内存，它的地址数的总和是 4GB。而在 64 位的程序中，它能访问的地址范围是 [0, 264），地址数的总和为 16EB</p><p>上面说的范围，如 [0, 232）表示的就是<strong>虚拟地址空间</strong>，指的是进程所能访问的所有的虚拟内存地址的集合。虚拟地址空间主要受程序的位数影响。除此之外，它还受 CPU 的实现的影响，比如 i7 处理器，它所支持的虚拟地址空间的范围是 [0, 248），即 256TB，不过一般这也够了。</p><p>除了虚拟地址空间之外，还有一个叫做<strong>物理地址空间</strong>的东西。顾名思义，物理地址空间表示的是所有能访问的物理地址的集合，它受计算机的主存大小影响。比如说，计算机的内存是 4GB，那么物理地址空间就是 [0, 232)。</p><p><strong>使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong></p><p><strong>1、页（Page）</strong></p><p>虚拟内存被组织成为一个由存放在磁盘上的 N 个连续的字节大小的单元组成的数组，也就是字节数组。每个字节都有一个唯一的虚拟地址作为数组的索引。磁盘上活动的数组内容被缓存在主存中，主存和磁盘上会通过数据传输来完成同步。</p><p>然而，磁盘的设计不能快速的读取或者写入数据，因为它的<strong>随机读写性能比较差</strong>。比如系统要读取一个数组的所有数据，它就要访问数组的所有内存，而如果这些内存不在主存中，就得从磁盘上去装载数据到主存。如果是一个字节一个字节的读，可能就要在磁盘和主存之间传输 N 次数据，这样就会导致性能变得很差。</p><p>另外我们得为每个字节记录点什么信息，才可以知道这个内存是否已经被分配了，是否已经存在于主存中了。<strong>如果是按照一个字节一个字节的记录，那我们的大部分内存空间会用在了信息记录上面，而不是用于数据存储。</strong></p><p>所以要想虚拟内存获得比较高的性能和内存利用率，必须由另外一种机制来提供。<strong>通过将虚拟内存分割为虚拟页（Virtual Page, VP）的大小固定的块来解决这些问题。</strong>也就是说，在磁盘和主存中传输数据，每次至少传输一个虚拟页，记录内存信息，也是按照虚拟页来记录。即虚拟页是磁盘和主存的数据传输和管理单元。这样如果是访问刚才那个数组，大部分情况下只要在磁盘和主存之间传输一次数据就够了。</p><p>和虚拟页对应的还有物理页，概念和虚拟页基本相同，除了它是存储在主存中的。因为是按照页作为传输单元的，所以<strong>物理页和虚拟页的大小一致，</strong>一般情况下系统中的页大小都是一致的，比如说都是 4KB。</p><p><br></p><p><strong>2、页表（Page Table）</strong></p><p><strong>页表</strong>是记录页的状态的表，<strong>不同的进程间的页表是独立的</strong>。<strong>页表中的项叫做页表项（Page Table Entry, PTE）。</strong></p><p>PTE 的数量为 X=N/P，其中 N 表示虚拟地址空间中的地址数量，P 表示页的大小。可以看出，在虚拟地址空间大小不变的情况下，页的大小越大，那么 PTE 的数量就越少；页的大小越小， PTE 的数量就越多。</p><p>PTE 记录了很多信息，这里列举几个重要的：</p><p>1）有效位( P )，它标识对应的虚拟页面是否在物理内存中。</p><p>2）关联的物理页地址（Base addr），它表示的是对应的虚拟页存储在物理内存中的哪一页。</p><p>3）读写访问权限（R/W），表示对应的页是否为只读的，或者是可读可写的。</p><p>4）超级权限（U/S）表示该页是否只允许内核模式访问，还是用户模式也可以访问。</p><p>5）修改位（D），表示被加载到物理内存之后，页面的内容是否发生了修改。</p><p><br></p><p><strong>3、地址翻译</strong></p><p>PTE 按照<strong>虚拟页索引（VPN）</strong>排序，比如第 0 页位于的起始位置，第 1 页位于第 0 页后面，依此类推。VPN 是根据虚拟地址、页大小算出来的，比如页大小为 4KB，那第 0 页的地址就是页表的起始地址，第 1 页的地址就是页表地址+页大小，即 0x00001000。位于第 0 页和第 1 页之间的地址都属于第 0 页。</p><p>假设页大小为 4KB，地址空间为 32 位。系统将虚拟地址视为两部分组成，前 20 位表示页索引（VPN），后 12 位表示页偏移（VPO）。如果根据虚拟地址( VA ) 来写一个获取页索引( VPN )的公式就是：VPN=VA>>12。因为页大小是 4KB，所以一个虚拟地址需要使用 12（ 212 = 4KB ）位来描述这个地址在某页中的偏移量K。那么剩下的位就用来索引 PTE。</p><p>在 CPU 中地址翻译由一个叫做<strong> MMU（Memory Management Unit，内存管理单元）</strong>的硬件完成。MMU 接收一个虚拟地址，并且输出一个物理地址。如果这个虚拟地址在物理内存中存在，那么就叫做页命中。如果这个虚拟地址在物理内存中不存在，那么 MMU 将产生一个<strong>缺页错误</strong>。</p><p>下图展示了 MMU 如何利用页表来实现虚拟地址到物理地址的映射。n 位的虚拟地址包括两个部分：一个 p 位的虚拟 VPO，和一个 n-p 位的 VPN。MMU 利用 VPN 来选择适当的 PTE。将 PTE 中的物理页号（PPN）与 VPO串联起来，就得到了相应的物理地址。注意：<strong>物理页面偏移（PPO）和 VPO 是相同的。</strong></p><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1feea9bcb672495aba8ad455bc5fec33><p class=pgc-img-caption></p></div><p><strong>3.1 页命中</strong></p><p>页命中指的是当 MMU 需要根据虚拟地址输出物理地址时，这个地址所在的页已经被装载到物理内存中了。即对应的 PTE 的有效为为 1。</p><p>下面是页命中时的地址翻译的过程：</p><ol start=1><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>从 PTE 获取对应的物理页号 PPN。用物理页的基址加上页偏移 PPO（假设页大小为 4KB，那么页偏移就是虚拟地址的低 12 位，物理页的页偏移和虚拟页的页偏移相同），获取对应的物理地址。</li><li>主存/高速缓存将数据返回给 CPU。</li></ol><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fc2dc830529a4f0391ea1861e02a30d1><p class=pgc-img-caption></p></div><p><strong>3.2 缺页</strong></p><p>缺页是指当 CPU 请求一个虚拟地址时，虚拟地址所对应的页在物理内存中不存在。此时 MMU 会产生缺页错误，然后由内核的缺页处理程序从磁盘中调入对应的页到主存中。在处理完成后，CPU 会重新执行导致错误的指令，从而读取到对应的内存数据。</p><p>下面是缺页时的地址翻译的过程（第 1 步到第 3 步与页命中时相同）：</p><ol start=1><li>处理器生成一个虚拟地址，并把它传送给 MMU</li><li>MMU 生成根据虚拟地址生成 VPN，然后请求高速缓存/主存，获取 PTE 的数据。</li><li>高速缓存/主存向 MMU 返回 PTE 的数据</li><li>由于判断出 PTE 的有效位是 0，所以 CPU 将触发一次异常，将控制权转移给内核中的缺页异常处理程序。</li><li>缺页异常处理程序确定出物理内存中的牺牲页，如果这个页面被修改过了（D 标志位为 1），那么将牺牲页换出到磁盘。</li><li>缺页处理程序从磁盘中调入新的页面到主存中，并且更新 PTE</li><li>缺页处理程序将控制权返回给原来的进程，再次执行导致缺页的指令。再次执行后，就会产生页命中时的情况了。</li></ol><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d8fe8b0485745eeb237cf3bf3f5af26><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.3 翻译加速</strong></p><p>从页命中的流程图中可以看出，CPU 每次需要请求一个虚拟地址，MMU 就需要从内存/高速缓存中获取 PTE ，然后再根据 PTE 的内容去从物理内存中加载数据。</p><p>这样在最坏的情况下，相当于从内存/高速缓存中多读取了一次数据。许多 MMU 包含了一个关于 PTE 的小缓存，叫做 <strong>TLB（Translation Lookaside Buffer，翻译后备缓冲器</strong>，也可简称为“快表”）来消除这样的开销。</p><p>如果 TLB 命中了，那么所有的地址翻译步骤都是在 MMU 中执行的，所以非常快；如果 TLB 未命中，MMU 就必须从高速缓存/内存中获取相应的 PTE，然后将新取出来的 PTE 放在 TLB 中。</p><p><strong>3.4 多级页表</strong></p><p>前面有提到过，PTE 的数量由虚拟地址空间的大小和页大小决定。也就是：X=N/P。那如果我们有一个 32 位的物理地址空间、4KB 的页面和一个 4 字节的 PTE。即使程序只使用了一小部分虚拟地址空间，也总是需要一个 4MB的页表常驻主存。对于 64 位的系统来说，情况将变得更加复杂。</p><p>设计者非常聪明，它将页表设计成一个包括多级的层次结构来解决这个问题。</p><p>下图展示了一个两级页表的层次结构。二级页表中的每个 PTE 项都负责一个 4KB 页面，而一级页表中的每个 PTE 负责 1024 个二级页表项。</p><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/292b67bc8e734faabb26ae4c7b332f02><p class=pgc-img-caption></p></div><p>注意，<strong>常驻内存的只是一级页表，系统可以在需要时才创建、页面调入二级页表。</strong>这样就减少了主存的压力。另外如果一级页表中的一个 PTE 是空的，那么相应的二级页表就根本不存在。这样在一个只需要少量内存的程序上，绝大部分二级页表是不存在的。</p><p>下图展示的是一个 k 级层次页表的结构图，起始就是将 VPN 部分划分为多个段，每个段都代表某一级页表。而每一级中的 PTE 的 Base addr 为下一级提供入口地址。最后一级的 Base addr 则表示最终物理地址的 PPN。</p><div class=pgc-img><img alt="10 分钟看懂虚拟内存底层原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/85ebdcca1c5942d68f702fd3d76fdfed><p class=pgc-img-caption></p></div><p>​</p><p>ps：编辑不易，求个关注</p><p><strong>挖坑序列文章</strong></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6841192982410953227/?group_id=6841192982410953227" rel="noopener noreferrer" target=_blank>I/O Zero Copy是什么？看完这篇你绝对会了</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6840107444165673486/?group_id=6840107444165673486" rel="noopener noreferrer" target=_blank>10分钟看懂 Java IO 底层原理</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6839359605345092107/?group_id=6839359605345092107" rel="noopener noreferrer" target=_blank>深入分析 Java 需要编码的场景</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6838983257908838925/?group_id=6838983257908838925" rel="noopener noreferrer" target=_blank>Java 编码很难吗？看完这篇文章你就懂了</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6838601700027138572/?group_id=6838601700027138572" rel="noopener noreferrer" target=_blank>编码字符集和字符集编码傻傻分不清楚！看完这篇文章你就懂了？</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6838226320346841612/?group_id=6838226320346841612" rel="noopener noreferrer" target=_blank>为什么 String 要设计成 final ，又如何设计一个不可变类呢？</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6838224106819682819/?group_id=6838224106819682819" rel="noopener noreferrer" target=_blank>你真的懂 Java 的 String 吗？</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'存底','10','分钟'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>