<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java重点基础知识回顾 | 极客快訊</title><meta property="og:title" content="Java重点基础知识回顾 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/86a1f861-87fd-48a5-ad2c-ada591ff6801"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72987d84.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72987d84.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72987d84.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72987d84.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72987d84.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72987d84.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72987d84.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72987d84.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="Java重点基础知识回顾"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/72987d84.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java重点基础知识回顾</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Java重点基础知识回顾 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/86a1f861-87fd-48a5-ad2c-ada591ff6801><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>Java语言规范、API、JDK、IDE的含义：</h1><p style=text-align:start>Java语言规范是Java语法和语义技术性定义，API是应用程序接口（Java预定义类和接口），Java开发工具包（JDK）包含软件库、编译器、解释器以及其他工具，集成开发环境（IDE）提供编辑、编译、调试和在线帮助功能。</p><h1 class=pgc-h-arrow-right>Java平台版本：</h1><ul><li>Java SE：允许开发和部署在桌面、服务器和嵌入式环境和实时环境中使用的Java应用程序。</li><li>Java EE：它帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java应用程序。Java EE是在Java SE的基础上构建的，它提供web服务、组件模型、管理和通信API。</li><li>Java ME：它为在移动设备和嵌入式设备上运行的应用程序提供一个健壮且灵活的环境。</li></ul><h1 class=pgc-h-arrow-right>Java运行环境</h1><p style=text-align:start>Java的目标代码可以在任何平台上运行，Java的源代码编译之后生成.class文件，由字节码构成（比如博客之前安卓逆向研究的Dalvik字节码）。字节码可以在任何装有Java虚拟机的计算机上运行，Java虚拟机是一个用于解释字节码的软件。</p><h1 class=pgc-h-arrow-right>Java程序剖析：</h1><ul><li>注释：Java程序包含三种注释，即多行注释、单行注释、文档注释，多行注释,<br>/* 注释内容<br>注释内容<br><em>/<br>单行注释：//<br>文档注释：可以用javadoc提取注释，形成文档，<br>/</em>** 注释内容<br>*/</li><li>修饰符：常见如public, protected, private, static, abstract, final，用于指定数据、方法、类的属性以及它们的用法。</li><li>类：是Java的基本结构，一个程序可以包含一个或多个类，一个Java源文件里最多只有一个<strong>公有类</strong>。</li><li>main方法：Java解释器通过调用main方法执行应用程序。</li></ul><h1 class=pgc-h-arrow-right>常量：</h1><ul><li>一旦初始化后就不能再改变的数据，语法为final datatype CONSTANT_NAME = value;</li></ul><h1 class=pgc-h-arrow-right>Java数据类型</h1><ul><li>Java数据类型：包括基本类型和引用类型，<br>基本类型包括 整数类型（byte, short, int, long) 字符类型（char）浮点类型（float, double）逻辑类型（boolean）;<br>引用类型包括 类，接口，数组。<br>其中，浮点数中以d或D结尾或者无后缀表示double类型，以f或F结尾的表示float类型；整数字面值中以l或L结尾的表示long类型，其他表示int类型。</li><li>Java数值类型转换：<br>如果有一个操作数是double类型，另一个操作数转换为double 类型；否则，如果有一个操作数是float类型，另一个操作数转换为float类型；否则，如果有一个操作数是long类型，另一个操作数转换为long类型；否则，两个操作数都转换为int类型；<strong>数据转换总是向较大范围的数据类型转换，避免精度损失</strong>。<br><em>将值赋值给较大取值范围的变量时，自动进行类型转换；</em><br><em>将值赋值给较小取值范围的变量时，必须使用强制类型转换。</em></li><li>字符数据类型：char表示16位的单个Unicode字符，char类型的字面值 包括以两个单引号界定的单个Unicode字符，可以用\uxxxx形式表示的， 转义字符表示\n \t \b \r \f \ ` " 。</li></ul><h1 class=pgc-h-arrow-right>编程风格：</h1><p style=text-align:start>良好的编程风格有利于减少错误，产生容易阅读、易于理解的代码。类和方法前使用文档注释，方法步骤前使用行注释；变量和方法名使用小写，如果有多个单词，第一个单词首字母小写，其他单词首字母大写；类名的每个单词的首字母大写；常量使用大写，单词间以下划线分割。</p><h1 class=pgc-h-arrow-right>Java常见错误类型：</h1><p style=text-align:start>包括语法错误，即在编译期间产生的错误；运行时错误，导致程序非正常终止的错误；逻辑错误，程序不能按预期的方式执行，编译不会报错。</p><h1 class=pgc-h-arrow-right>条件语句：</h1><p style=text-align:start>包括If语句、switch语句、条件表达式，其中的if语句判断条件必须是boolean类型的；在if-else条件语句中，else语句与同一块中最近的if语句匹配。在使用条件语句中，避免在条件表达式中使用比较操作符判断布尔变量的真假。switch语句的判断条件expression的计算结果只能是<strong>byte, char, short, int</strong>。value1-valueN必须与 判断条件类型相同，且为常量表达式，不能是变量。</p><h1 class=pgc-h-arrow-right>Java中常用的数学函数：</h1><ul><li>Math.random方法生成[0.0,1.0)之间的double类型的随机数，可以用它写出简单的表达式来生成任意范围的随机数，一般地，a + (int)(Math.random() * b)返回[a, a+b）；还可以用该方法生成随机字符，Java中每个字符对应一个Unicode编码从0000到FFFF，在生成一个随机字符，就是产生一个0到65535之间的随机数，所以计算的表达式为(int)(Math.random() * (65535+1))。生成任意2个字符ch 1和ch2（ch1 &lt; ch2）之间的随机字符，<br>(char)(ch1 + (int)(Math.random() * (ch2 - ch1 + 1)))</li></ul><h1 class=pgc-h-arrow-right>字符数据类型和操作</h1><ul><li>在字符型数据和数值类型数据之间转换时，如果转换结果适用于目标变量（不会有精度损失），可以采用隐式转换；否则必须使用强制类型转换。</li><li>所有数值运算符都可以用在char型操作数上，如果另一个操作数是数值或字符，那么char型操作数就自动转换为数值；如果另一个操作数是字符串，那么char型操作数就会自动转换成字符串再和另外一个操作数字符串相连。</li></ul><h1 class=pgc-h-arrow-right>字符串类型</h1><p style=text-align:start>String类型是不可变的，其内容是不可修改的；如以下代码片段：</p><pre><code>String s = "java";s = "HTML";12</code></pre><p style=text-align:start>其中s可以理解为一个对象指针，其指向对象空间，其中的字符串为java，第二句赋值只是将s指向了另一个对象空间。</p><ul><li>equals方法用于比较两个字符串是否包含相同的内容。</li><li>equalsIngoreCase忽略大小写比较内容是否相同。</li><li>regionMatch比较部分内容是否相同。</li><li>startsWith判断是否以某个字符串开始。</li><li>endsWith判断是否以某个字符串结束。</li><li>compareTo方法用于比较两个字符串的大小，即第一个不同字符的差值.</li><li>调用length()方法可以获取字符串的长度。。</li><li>charAt(index)方法可以获取指定位置的字符，index必须位于0到s.length()-1之间。</li><li>concat()方法用于连接两个字符串，连接操作返回一个新的字符串。</li><li>indexOf返回字符串中字符或字符串匹配的位置，返回-1表示未找到。indexOf指定第二个参数表示从指定的位置开始查找。</li><li>toCharArray将字符串转换成字符数组。valueOf方法将基本数据类型转换为字符串，例如转化为字符串，如<br>String s1 = String.valueOf(1.0); String s2 = String.valueOf(true);;字符串转换为基本数据类型，Double.parseDouble(str)等。</li></ul><h1 class=pgc-h-arrow-right>方法：</h1><ul><li>方法签名指<strong>方法名称、参数类型、参数数量和返回类型</strong>；==一个类中不能包含签名相同或仅返回类型不同的多个方法；==方法头中声明的变量称为形参，**形参可以使用final修饰，表示方法内部不允许修改该参数；**形参不允许有默认值，最后一个可为变长参数。方法可以有返回值，构造函数没有返回值。</li><li>如果方法声明中含有形参，调用方法时必须提供实参，实参的类型必须与形参的类型兼容：如父类形参可用子类实参。</li><li>调用方法时，基本数据类型的实参值的副本被传递给方法的形参，方法内部对形参的修改不影响实参值；对象类型的参数是引用调用。</li></ul><h1 class=pgc-h-arrow-right>方法重载：</h1><ul><li>方法重载是指方法名称相同，但方法签名不同的方法，仅返回类型不同不可重载。一个类中可以包含多个重载的方法。</li><li>当调用方法时，Java编译器会根据实参的个数和类型寻找最准确的方法进行调用；调用时匹配的方法多于一个，则会产生编译错误，成为歧义调用。</li></ul><h1 class=pgc-h-arrow-right>数组：</h1><ul><li>数组是引用类型。</li><li>多维数组只是数组的数组，故数组元素也可能是引用类型变量</li><li>凡使用new后，内存单元都初始化为0或Null。</li><li>声明数组引用变量，datatype[] arrayRefVar；，任何实例化的数组都是Object的子类。</li><li>数组变量是引用类型的变量，声明数组变量并不分配内存空间，必须通过new实例化来分配内存空间。</li><li>新创建的数组其元素根据类型被初始化为默认的初始值，数值类型为0字符类型为’\u0000’布尔类型为false引用类型为null</li><li>数组可以在声明的括号后提供初始值，double[] mylist = {1.9, 2.9, 3, 3.5};或者double[] mylist = new double[]{1.9, 2.9, 3, 3.5};</li><li>数组的大小在创建这个数组之后不能被改变，arrayRefVar.length可以访问数组的长度。</li><li>直接使用赋值语句不能实现数组复制，结果是两个数组引用变量指向同一个数组对象。在将数组作为实参传递给方法时，修改形参引用的数组，将改变实参引用的数组。</li><li>JVM将数组存储在叫堆的内存区域里，数组引用存储在栈空间中。</li><li>String传递给方法：由于实参的字符序列不可修改，将克隆给形参。</li><li>可以把类型相同，但个数可变的参数传递给方法，方法中的参数声明为typeName…parameterName，==Java将可变长参数当数组看待，通过length属性得到可变参数的个数。</li></ul><pre><code>print(String...args){	//可看作String[] args	for(String temp: args)		System.out.println(temp);	System.out.println(args.length);}12345</code></pre><ul><li>java.util.Arrays类包括各种静态方法，其中实现了数组的排序和查找，即sort方法与binarySearch方法。</li><li>二维数组的每个元素（数组）的长度可以不同，创建二维不规则数组时，可以只指定第一维下标，第一维的每个元素为null, 必须为每个元素使用new创建数组。</li></ul><h1 class=pgc-h-arrow-right>面向对象思考：</h1><ul><li>类间的关系描述方法，关联关系：是一种通用的二元关系，对象间通过活动发生联系，例如学生选学课程，教师教授课程。==在Java中，关联关系可以用数据域或方法来实现，对于方法，一个类中的方法包含另一个类作为参数。</li><li>聚合关系是一种拥有关系，表示整体与部分之间的关系，即Has-a的关系，在聚合关系中，一个对象可以被多个聚集着拥有; 组合关系是一种隶属关系，一个从属者只能被一个聚集着拥有。如一个Name对象只能为一个Person所拥有，但一个Address对象可以被多个Person所共享。</li><li>继承关系，表示子类与父类之间的is-a关系，通过继承，子类可以重用父类的数据和代码。</li><li>实现关系，表示接口和类之间的关系，类实现接口。</li></ul><h1 class=pgc-h-arrow-right>继承：</h1><p style=text-align:start>继承是一种软件重用，如果没有继承，会出现很多重复定义。语法为:</p><pre><code>class ClassName extends Superclass{	classbody}123</code></pre><p style=text-align:start>子类继承了父类中可访问的数据域和方法，子类也可添加新的数据域和方法，子类不继承符类的构造函数。一个子类只能有一个直接父类：单继承。子类继承的父类的私有属性不能访问，但是可以通过所继承的get和set公有方法设置和访问。</p><hr><ul><li>当第一次创建子类对象时，首先初始化其父类静态成员变量（如果没有父类对象），然后初始化当前子类对象的静态成员变量。注意：第一次之后创建子类对象时，不会再次初始化父类和子类的静态成员变量。其实，静态成员变量在有任何实例变量对象之前已经存在。<br>接着执行该子类对象的父类的构造函数super(…)，可能是编译为父类提供的默认无参构造函数super()。然后执行子类实例变量定义时的初始化表达式，若定义时未给出初始值，则默认为0或null.最后执行子类构造函数中super(…)后面的语句。</li><li>super关键字：super调用父类的构造函数，必须是子类构造函数的第一条且仅一条语句（先构造父类），如果子类构造函数中没有显示地调用父类的构造函数，那么将自动调用父类不带参数的构造函数。 如果父类属性或方法可以在子类访问，则使用super.data或者super.method(parameters)进行访问。</li><li>super与无参构造函数：<strong>如果一个类自定义了构造函数（不管有无参数），系统不会自动加上无参构造函数；</strong> 反之，如果没定义则会加上。编译在为子类添加无参构造函数时，用super()默认调用父类的无参构造函数，如果找不到父类的无参构造函数，则子类添加无参构造函数失败。 所以，如果一个类定义了带参数的构造函数，一定别忘了定义一个无参构造函数。</li></ul><h1 class=pgc-h-arrow-right>实例方法覆盖</h1><ul><li>如果子类重新定义了从父类中继承的实例方法，称为方法覆盖。</li><li>仅当方法是**可访问的实例方法**时，才能被覆盖，即私有实例方法不能被覆盖，私有方法自动视为final. （final修饰类时表示其不可被继承；修饰方法表示不可在子类中被重写；修饰成员变量时表示只能在声明处或者构造函数中初始化一次）。</li><li>静态方法不能被覆盖，如果静态方法在子类中重新定义，那么父类方法将被<strong>隐藏</strong>。</li><li>一旦父类中的方法被覆盖，则不能通过引用的子类对象访问被覆盖的父类方法。在子类类体函数中可以使用super引用被覆盖的父类方法。</li><li>隐藏和覆盖的区别：覆盖，子类对象被父类引用变量引用，父类引用变量调用的相同签名的函数是子类函数（不能发现父类函数，晚期绑定）；隐藏，同上，但父类引用变量访问的是父类变量、函数（可以在发现）。</li><li>子类方法同样可以与父类中可访问的方法构成重载。</li></ul><h1 class=pgc-h-arrow-right>多态和动态绑定：</h1><p style=text-align:start>重载发生在编译时，编译时编译器根据方法签名找到最合适的方法；多态发生在运行时，运行时JVM根据变量所引用的对象的真正类型来找到最合适的实例方法。多态是晚期绑定，绑定是指找到函数的入口地址的过程。</p><h1 class=pgc-h-arrow-right>访问控制符和修饰符final</h1><p>成员修饰符本类本包子类它包publicyyyyprotectedyyyn无(package)yynnprivateynnn</p><ul><li>父类私有成员在子类不可见；</li><li>父类公有和保护成员在子类可见</li><li>继承到子类后不改变父类成员的访问权限。<br></li></ul><h1 class=pgc-h-arrow-right>异常处理：</h1><ul><li>一般而言，带有异常处理的程序会写成try…catch的形式；在try体内完成程序的正常处理流程，在catch体内完成异常处理。</li><li>若正常的异常处理出现错误，则使用"throw &lt;异常对象引用>"抛出异常；抛出的异常由catch捕获，未被捕获的异常逐层传播到main，如果main也没有处理该异常，则操作系统会终止main执行。</li><li>抛出而未捕获（未处理）异常的函数，必须用throws声明其未处理的这些异常。有些异常是系统抛出的，程序只需要捕获处理即可。</li><li><strong>异常的捕获顺序</strong>：无论何时，throw以后的语句都不会执行；无论同层catch是否捕获、处理本层的异常（即使抛出或转发异常），同层的finally总是都会执行。 一个catch捕获到异常后，同层catch都不会执行，然后执行同层finally； <strong>一个同层try-catch-finally结束，若无异常则执行其后语句，若有异常，则跳过其后语句，进入上层catch流程</strong>。<br>上图中红色标出的为div的执行轨迹。</li></ul><h1 class=pgc-h-arrow-right>自定义异常类：</h1><p style=text-align:start>自定义异常类必须继承Throwable或其子类；自定义异常类通常继承Exception及其子类，因为它是程序可处理的类。自定义异常类会在父类的基础上增加成员变量，因此，通常需要覆盖toString函数（经常被打印）。未增加新成员就没有必要自定义异常类。自定义异常类通常不必定义clone, equals：捕获和处理异常时通常只是引用异常对象而已。</p><h1 class=pgc-h-arrow-right>抽象类：</h1><ul><li>Java可定义不含方法体的方法，其方法体由子类根据具体情况实现，这样的方法称为抽象方法，包括抽象方法的类必须是抽象类。抽象类和抽象方法的声明必须加上abstract关键字。</li><li>类C如果满足下面任一条件，则该类包含抽象方法且是抽象类：类C显示地进行一个抽象方法的声明；类C的父类中声明的抽象方法未在类C和它的父类中实现；类C的接口中声明一个方法，并且类C未实现该方法；只有类C有一个为实现的方法，类C就是抽象类。</li><li>抽象类不能被实例化，即不能用new关键字创建对象；抽象类可以定义构造函数，可以被子类调用；具体子类必须实现抽象父类中所有抽象方法，否则子类需要声明为抽象类；抽象类只能用具体子类的对象实例化。</li></ul><h1 class=pgc-h-arrow-right>接口：</h1><p style=text-align:start>接口是<strong>公共静态常量</strong>，<strong>公共静态方法</strong>和<strong>公共抽象方法</strong>，<strong>默认实例方法</strong>的集合。接口中的一切都默认是public的，没有修饰符的方法默认是abstract的，数据成员默认是static的。</p><p style=text-align:start>接口不能定义构造函数，一个接口可继承extends多个接口，接口不能被类extends，一个类可实现implements多个接口。</p><pre><code>public interface I1{	public static final int k = 1;	public abstract void m();}1234</code></pre><p style=text-align:start>等价于：</p><pre><code>public interface I1{	int k = 1;	//=1不可省略，因为默认是public static final的，必须初始化	void m();	//不可定义函数体，默认是public abstract.}1234</code></pre><p>接口中的方法通过“接口类型的引用变量.方法名”调用，但接口类型的引用变量必须引用实现了该接口的具体类的实例对象。接口中的常量名通过"接口名.常量名"访问。</p><div class=pgc-img><img alt=Java重点基础知识回顾 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/821e98da4f8749859596bb504add375f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Java重点基础知识回顾 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/063bdf869aa44936a5e72836a522cd46><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','重点','基础'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>