<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何利用Qt quick开发嵌入式应用程序，并实现远程调试 | 极客快訊</title><meta property="og:title" content="如何利用Qt quick开发嵌入式应用程序，并实现远程调试 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/262d0d4567724756af1f04c908cdb7ce"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72d91e2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72d91e2.html><meta property="article:published_time" content="2020-10-29T20:59:01+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:01+08:00"><meta name=Keywords content><meta name=description content="如何利用Qt quick开发嵌入式应用程序，并实现远程调试"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/72d91e2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何利用Qt quick开发嵌入式应用程序，并实现远程调试</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#555;--tt-darkmode-color: #555555">在本文的</span><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6877089982658544140/?group_id=6877089982658544140" rel="noopener noreferrer" target=_blank>第1部分</a>中，我们展示了如何在Visual Studio中针对Windows和嵌入式Linux创建多平台Qt Quick应用程序项目。现在，我们将展示如何在嵌入式设备上运行该应用程序。然后，我们将继续将该项目开发为我们打算创建的完整嵌入式应用程序。最后，我们将使用VS调试器对应用程序的C ++和QML代码进行远程调试。</p><p style=text-align:justify><strong>在嵌入式设备上运行</strong></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">我们已经展示了如何交叉编译在Visual Studio中创建的“ hello world” Qt Quick应用程序。现在，我们将看到如何在Raspberry Pi上运行该应用程序。由于我们将以全屏模式运行，因此我们必须首先向应用程序窗口中添加一些内容。</span></p><pre><code>Window {    visible: true    title: qsTr("Hello World")    Text {        id: clock        font.pointSize: 72        Timer {            interval: 1000; running: true; repeat: true            onTriggered: clock.text = (new Date).toLocaleTimeString(Qt.locale("de_DE"), "hh:mm:ss");        }    }}</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">和以前一样，选择Linux项目配置，然后按F7键开始交叉编译。</span></p><pre><code>1&gt;------ Build started: Project: QuickMirror, Configuration: Debug_RPi x64 ------1&gt;rcc qml.qrc1&gt;Invoking 'mkdir -p $(dirname qml.qrc); mkdir -p $(dirname /mnt/c/Users/user/Source/Repos/QuickMirror/main.qml); mkdir -p $(dirname /mnt/c/Users/user/Source/Repos/QuickMirror/obj/x64/Debug_RPi/rcc/qrc_qml.cpp); (/home/user/raspi/qt5/bin/rcc /mnt/c/Users/user/Source/Repos/QuickMirror/qml.qrc --name qml -o /mnt/c/Users/user/Source/Repos/QuickMirror/obj/x64/Debug_RPi/rcc/qrc_qml.cpp)', working directory: '/mnt/c/Users/user/Source/Repos/QuickMirror'1&gt;Starting remote build1&gt;Compiling sources:1&gt;qrc_qml.cpp1&gt;Linking objects1&gt;QuickMirror.vcxproj -&gt; C:\Users\user\Source\Repos\QuickMirror\bin64\Debug_RPi\QuickMirror.out========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">要在每次构建结束时自动复制应用程序文件，可以在“ WSL构建后事件”属性页中设置以下命令（</span><strong>A</strong>TTN： 这将以明文形式保存设备密码）。</p><pre><code>C:\Users\user&gt; scp C:\Users\user\Source\Repos\QuickMirror\bin64\Debug_RPi\QuickMirror.out pi@192.168.1.98:/home/pi/pi@192.168.1.98's password:QuickMirror.out 100% 465KB 1.6MB/s 00:00C:\Users\user&gt;</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">在启动Qt Quick应用程序之前，我们需要设置一些必需的环境变量：</span></p><ul><li><strong><span style="color:#666;--tt-darkmode-color: #666666">LD_LIBRARY_PATH</span></strong><span style="color:#666;--tt-darkmode-color: #666666"><br>Qt二进制文件安装目录的路径。<br></span></li><li><strong><span style="color:#666;--tt-darkmode-color: #666666">QT_QPA_PLATFORM</span></strong><span style="color:#666;--tt-darkmode-color: #666666"><br>平台插件。<br></span></li><li><strong><span style="color:#666;--tt-darkmode-color: #666666">QT_QPA_PLATFORM_PLUGIN_PATH</span></strong><span style="color:#666;--tt-darkmode-color: #666666"><br>平台插件安装目录的路径。<br></span></li><li><strong><span style="color:#666;--tt-darkmode-color: #666666">QT_QPA_EGLFS_PHYSICAL_WIDTH<br>QT_QPA_EGLFS_PHYSICAL_HEIGHT</span></strong><span style="color:#666;--tt-darkmode-color: #666666"><br>物理屏幕的宽度和高度，以毫米为单位。<br></span></li><li><strong><span style="color:#666;--tt-darkmode-color: #666666">QML2_IMPORT_PATH</span></strong><span style="color:#666;--tt-darkmode-color: #666666"><br>安装的QML模块的路径。</span></li></ul><pre><code>pi@raspberry-pi:~$ export LD_LIBRARY_PATH="/usr/local/qt5pi/lib"pi@raspberry-pi:~$ export QT_QPA_PLATFORM="eglfs"pi@raspberry-pi:~$ export QT_QPA_PLATFORM_PLUGIN_PATH="/usr/local/qt5pi/plugins/platforms"pi@raspberry-pi:~$ export QT_QPA_EGLFS_PHYSICAL_WIDTH="326"pi@raspberry-pi:~$ export QT_QPA_EGLFS_PHYSICAL_HEIGHT="520"pi@raspberry-pi:~$ export QML2_IMPORT_PATH="/usr/local/qt5pi/qml"pi@raspberry-pi:~$ ./QuickMirror.out</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">树莓派显示器</span></p><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/262d0d4567724756af1f04c908cdb7ce><p class=pgc-img-caption></p></div><p style=text-align:center><span style="color:#555;--tt-darkmode-color: #555555">在Raspberry Pi中运行“ Hello World”应用程序</span></p><h1 class=pgc-h-arrow-right>开发应用程序</h1><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">我们的应用程序的要求包括显示以下信息：</span></p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">当前时间</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">当前日期</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">周年纪念</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">天气预报</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">下次出发的公共交通工具</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">新闻</span></li></ul><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">我们将把每个项目封装为专用的QML类型。为此，我们必须首先将QML模块定义（qmldir）文件添加到项目中：</span></p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">选择“项目>添加新项。。> Qt> QML模块定义”。</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">在位置字段中，指示将包含QML文件的文件夹的路径。</span></li></ul><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d2fb342a66034b33beff3efa14ace6af><p class=pgc-img-caption></p></div><p style=text-align:center><span style="color:#555;--tt-darkmode-color: #555555">向项目添加新的QML模块定义</span></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">按下“添加”后，</span><strong>qmldir </strong>文件将在项目树中可用。我们将使用此文件来定义每种QML类型到其对应源文件的映射。</p><pre><code>ApiCall         1.0 QuickMirror.ApiCall.qmlCalendar        1.0 QuickMirror.Calendar.qmlClock           1.0 QuickMirror.Clock.qmlNewsTicker      1.0 QuickMirror.NewsTicker.qmlOnThisDay       1.0 QuickMirror.OnThisDay.qmlPublicTransport 1.0 QuickMirror.PublicTransport.qmlWeather         1.0 QuickMirror.Weather.qml</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">要将新的QML源文件添加到项目中：</span></p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">选择“项目>添加新项...> Qt> QML文件”。</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">将位置设置qmldir为创建文件的相同目录。</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">设置QML文件名。</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">按“添加”。</span></li></ul><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bab5b2756f354268b929a4d46bb05b00><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">我们将首先添加QML类型以显示当前时间，当前日期和重要的周年纪念日。该</span><strong>Clock</strong>类型将显示当前时间，每秒刷新一次。</p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">QuickMirror.Clock.qml</span></p><pre><code>  function refresh() {        text = (new Date).toLocaleTimeString(Qt.locale("de_DE"), "hh:mm");    }    Component.onCompleted : refresh();    Timer {        interval: 1000; running: true; repeat: true onTriggered: parent.refresh();    }} </code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">该</span><strong>Calendar</strong>类型将显示当前日期，并在不同语言环境之间循环。</p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">QuickMirror.Calendar.qml</span></p><pre><code>Text {    renderType: Text.NativeRendering    id: calendar    color: "white"    font.family: FontFamily_Bold    font.styleName: FontStyle_Bold    font.pointSize: 72    property var locales: ["en_US", "de_DE", "pt_PT"]    property var localeIdx: 0    function capitalize(s) {        return s.replace(/(^|-)./g, function(c) { return c.toUpperCase(); });    }    function setNextLocale() {        localeIdx = (localeIdx + 1) % locales.length;    }    function getCurrentText() {        var date = new Date;        var locale = Qt.locale(locales[localeIdx]);        var calendarText = capitalize(date.toLocaleDateString(locale, "dddd, dd"));        var monthShort = date.toLocaleDateString(locale, "MMM");        var monthLong = date.toLocaleDateString(locale, "MMMM");        if (monthLong.length &lt;= 5) { calendarText += capitalize(monthLong); } else { calendarText += capitalize(monthShort); if (!monthShort.endsWith(".")) calendarText += "."; } calendarText += date.toLocaleDateString(locale, " yyyy"); return calendarText; } Component.onCompleted: { text = getCurrentText(); } Timer { interval: 15000; running: true; repeat: true onTriggered: { setNextLocale(); text = getCurrentText(); } } Behavior on text { SequentialAnimation { NumberAnimation { target: calendar; property: "opacity"; to: 0.0; duration: 1000 } PropertyAction { target: calendar; property: "text" } NumberAnimation { target: calendar; property: "opacity"; to: 1.0; duration: 500 } } } }</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">除了日期/时间，我们的应用程序还将依靠Web API来检索信息。我们将</span><strong>curl</strong>在一个单独的过程中运行以连接到Web API。流程创建将由名为的C ++类处理<strong>Process</strong>。然后，QML类型<strong>ApiCall</strong>将使用一个<strong>Process</strong>对象以<strong>curl</strong>必要的参数开始并收集其输出。</p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">QuickMirror.ApiCall.qml</span></p><pre><code>Item {    property var url: ""    property var path: []    property var query: []    signal response(var response)    signal error(var error)    Process {        id: curl        property var path: Q_OS_WIN ? "C:\\Windows\\System32\\curl.exe" : "/usr/bin/curl"        property var request: ""        command: path + " -s \"" + request + "\""    }    function sendRequest() {        curl.request = url;        if (path.length &gt; 0)            curl.request += "/" + path.join("/");         if (query.length &gt; 0)            curl.request += "?" + query.join("&amp;");        curl.start();    }    Connections {        target: curl        onExit /*(int exitCode, QByteArray processOutput)*/ : {            if (exitCode != 0) {                console.log("ApiCall: exit " + exitCode);                console.log("==== ApiCall: request: " + curl.request);                return error("exit " + exitCode);            }            try {                return response(JSON.parse(processOutput));            } catch (err) {                console.log("ApiCall: error: " + err.toString());                console.log("==== ApiCall: request: " + curl.request);                console.log("==== ApiCall: response: " + processOutput);                return error(err);            }        }    }}</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">要创建</span><strong>Process</strong>C ++类：</p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">选择“项目>添加Qt类> Qt类”</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">将类名设置为Process</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">按“添加”</span></li></ul><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4efb65d124d44112bd30737478c15b05><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><pre><code>class Process : public QProcess{    Q_OBJECT    Q_PROPERTY(QString command READ command WRITE setCommand NOTIFY commandChanged)public:    Process(QObject* parent = 0);    ~Process();public:    Q_INVOKABLE void start();    void setCommand(const QString&amp; cmd);    QString command() const;signals:    void commandChanged();    void exit(int exitCode, QByteArray processOutput);protected:    void onFinished(int exitCode, QProcess::ExitStatus status);    void onErrorOccurred(QProcess::ProcessError error);private:    QString m_command;};</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">Process.cpp</span></p><pre><code>Process(QObject* parent) : QProcess(parent){    connect(        this, QOverload::of(&amp;QProcess::finished),        this, &amp;Process::onFinished);    connect(        this, &amp;QProcess::errorOccurred,        this, &amp;Process::onErrorOccurred);}Process::~Process(){}void Process::setCommand(const QString&amp; cmd){    if (cmd != m_command) {        m_command = cmd;        emit commandChanged();    }}QString Process::command() const{    return m_command;}void Process::start(){    if (state() == ProcessState::NotRunning)        QProcess::start(m_command);    else        qInfo() &lt;&lt; "==== QProcess: ERROR already running:" &lt;&lt; m_command; } void Process::onFinished(int exitCode, QProcess::ExitStatus status) { emit exit((status == ExitStatus::NormalExit) ? exitCode : -1, readAll()); } void Process::onErrorOccurred(QProcess::ProcessError error) { qInfo() &lt;&lt; "==== QProcess: ERROR " &lt;&lt; error; }</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">main.cpp</span></p><pre><code>int main(int argc, char* argv[]){    qmlRegisterType("Process", 1, 0, "Process");...</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">该</span><strong>OnThisDay</strong> QML类型将使用的实例，通过它们来获取显著的纪念日列表和循环每隔几秒钟。<strong> ApiCall</strong></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">QuickMirror.OnThisDay.qml</span></p><pre><code>Item {    id: onThisDay    clip: true    property int viewportHeight    property var events: []    property var births: []    property var deaths: []    property int idxEventType: -1    ApiCall {        id: onThisDayApi        property int month: 0        property int day: 0        property string eventType: ""        url: "https://byabbe.se"; path: ["on-this-day", month, day, eventType + ".json" ]        onResponse: {            if ("events" in response) {                events = shuffle(response.events);                eventType = "births";                sendRequest();            } else if ("births" in response) {                births = shuffle(response.births);                for (var i in births)                    births[i].year = "*" + births[i].year;                eventType = "deaths";                sendRequest();            } else if ("deaths" in response) {                deaths = shuffle(response.deaths);                for (var i in deaths)                    deaths[i].year = "†" + deaths[i].year;                next();            }        }    }    function init() {        events = [];        births = [];        deaths = [];        idxEventType = -1;        var today = new Date;        onThisDayApi.month = today.getMonth() + 1;        onThisDayApi.day = today.getDate();        onThisDayApi.eventType = "events";        onThisDayApi.sendRequest();    }    function next() {        if (events.length + births.length + deaths.length == 0)            return;        var today = new Date;        if (onThisDayApi.month != today.getMonth() + 1 || onThisDayApi.day != today.getDate())            return init();        onThisDayText.color = "white";        idxEventType = (idxEventType + 1) % 3;        var event;        switch (idxEventType) {            case 0:                if (events.length == 0)                    return next();                event = events.shift();                events = shuffle(events);                events.push(event);                break;            case 1:                if (births.length == 0)                    return next();                event = births.shift();                births = shuffle(births);                births.push(event);                break;            case 2:                if (deaths.length == 0)                    return next();                event = deaths.shift();                deaths = shuffle(deaths);                deaths.push(event);                break;        }        onThisDayText.text = event.year + " – " + event.description;        showText.start();    }    Component.onCompleted: {        init();    }    Timer {        id: timerRetry        interval: 10000; running: true; repeat: true        onTriggered: {            if (events.length + births.length + deaths.length == 0)                init();        }    }    SequentialAnimation {        id: showText        PropertyAction { target: onThisDayText; property: "y"; value: 25 }        NumberAnimation { target: onThisDayText; property: "opacity"; to: 1.0; duration: 500 }        PauseAnimation { duration: 3000 }        NumberAnimation {            target: onThisDayText            property: "y"            to: Math.min(-(25 + onThisDayText.contentHeight) + viewportHeight, 25)            duration: Math.max(0, (Math.abs(to - from) * 1000) / 25)        }        PauseAnimation { duration: 3000 }        NumberAnimation { target: onThisDayText; property: "opacity"; to: 0.0; duration: 1000 }        onFinished: {            onThisDay.next();        }    }    Text {        renderType: Text.NativeRendering        id: onThisDayText        wrapMode: Text.WordWrap        font.family: FontFamily_Normal        font.styleName: FontStyle_Normal        font.pointSize: 40        textFormat: Text.RichText        color: "white"        y: 25        anchors.left: parent.left        width: parent.width        height: contentHeight        opacity: 0    }    Rectangle {        id: top        anchors.top: parent.top        anchors.left: parent.left        width: parent.width        height: 10        gradient: Gradient {            orientation: Gradient.Vertical            GradientStop { position: 0.0; color: "black" }            GradientStop { position: 0.5; color: "transparent" }        }    }    Rectangle {        id: bottomFade        anchors.top: parent.top        anchors.topMargin: viewportHeight        anchors.left: parent.left        width: parent.width        height: 0.1 * viewportHeight        gradient: Gradient {            orientation: Gradient.Vertical            GradientStop { position: 0.0; color: "transparent" }            GradientStop { position: 0.5; color: "black" }        }    }    Rectangle {        anchors.top: bottomFade.bottom        anchors.bottom: parent.bottom        anchors.left: parent.left        width: parent.width        color: "black"    }}</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">现在，我们已经定义了一些应用程序的QML类型，我们将它们排列在主QML文件上。</span></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">main.qml</span></p><pre><code>import "QuickMirrorTypes"Window {    visible: true    title: qsTr("Quick Mirror")    Flickable {        anchors.fill: parent        contentWidth: mirror.width        contentHeight: mirror.height        Rectangle {            id: mirror            width: 1080            height: 1920            color: "black"            Clock {                id: clock                anchors.top: mirror.top                anchors.left: mirror.left            }            Calendar {                id: calendar                anchors.top: clock.bottom                anchors.topMargin: -20                anchors.left: mirror.left            }            Rectangle {                anchors.top: calendar.bottom                anchors.topMargin: -5                anchors.left: mirror.left                width: 800                height: 2                color: "white"            }            OnThisDay {                id: onThisDay                anchors.top: calendar.bottom                anchors.left: mirror.left                anchors.leftMargin: 10                anchors.bottom: mirror.bottom                width: 780                viewportHeight: 260            }        }    }}</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">最后，</span><strong>qmldir </strong>必须将QML文件和该文件全部添加到应用程序的资源文件中：</p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">双击项目树中的QRC文件</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">在“ Qt资源编辑器”窗口中，按“添加>添加文件”</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">选择所有QML文件和qmldir文件</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">在Qt资源编辑器中按“保存”</span></li></ul><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/48310e32cfbd4b568324aedc2763a036><p class=pgc-img-caption></p></div><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">构建和部署后，我们将能够启动应用程序并查看显示的信息。</span></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">树莓派显示器</span></p><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/317513d6e5274e7194e926e6e6db3700><p class=pgc-img-caption></p></div><p style=text-align:center><span style="color:#555;--tt-darkmode-color: #555555">在Raspberry Pi上运行的应用程序</span></p><h1 class=pgc-h-arrow-right>在Visual Studio中进行调试</h1><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">VS支持通过调试在WSL上运行的应用程序</span><strong>gdb</strong>。要在Raspberry Pi上运行时进行调试，我们将使用启动应用程序<strong>gdbserver</strong>，然后配置<strong>gdb</strong>为连接到设备并启动远程调试会话。</p><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6c331f9d8dd4326a5e8337f1f8aa0aa><p class=pgc-img-caption></p></div><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">为此，</span><strong>gdb </strong>WSL中安装的组件必须支持目标设备体系结构。一种简单的方法是安装<strong>gdb-multiarch</strong>。为了确保VS使用正确的调试器，我们将创建从<strong>gdb</strong>到的符号链接<strong>gdb-multiarch</strong>。</p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">WSL命令外壳</span></p><pre><code>user@buildhost:~$ sudo apt-get install gdb-multiarch...user@buildhost:~$ cd /usr/binuser@buildhost:/usr/bin$ sudo mv gdb gdb-bkupuser@buildhost:/usr/bin$ sudo ln -s gdb-multiarch gdbuser@buildhost:/usr/bin$ ls -go gdb*lrwxrwxrwx 1 13 Sep 2 11:31 gdb -&gt; gdb-multiarch-rwxr-xr-x 1 8440200 Feb 11 2020 gdb-bkup-rwxr-xr-x 1 15192808 Feb 11 2020 gdb-multiarchuser@buildhost:/usr/bin$</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">要在Visual Studio中设置远程调试会话，必须将两个附加命令传递给</span><strong>gdb</strong>。这是在“ GDB调试器”属性页面中配置的。</p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">Project Properties > Debugging > Additional Debugger Commands</span></p><pre><code>target extended-remote 192.168.1.98:2345set remote exec-file /home/pi/QuickMirror.out</code></pre><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d7f29d0b50f41edad3b6368d484e757><p class=pgc-img-caption></p></div><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">在开始远程调试会话之前，我们必须设置所需的环境变量并</span><strong>gdbserver</strong>在设备上启动。</p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">Raspberry Pi命令外壳</span></p><pre><code>pi@raspberry-pi:~$ export LD_LIBRARY_PATH="/usr/local/qt5pi/lib"pi@raspberry-pi:~$ export QT_QPA_PLATFORM="eglfs"pi@raspberry-pi:~$ export QT_QPA_PLATFORM_PLUGIN_PATH="/usr/local/qt5pi/plugins/platforms"pi@raspberry-pi:~$ export QT_QPA_EGLFS_PHYSICAL_WIDTH="326"pi@raspberry-pi:~$ export QT_QPA_EGLFS_PHYSICAL_HEIGHT="520"pi@raspberry-pi:~$ export QML2_IMPORT_PATH="/usr/local/qt5pi/qml"pi@raspberry-pi:~$ gdbserver --once --multi :2345Listening on port 2345</code></pre><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">按F5将启动远程调试会话。</span></p><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15f275a114be4302bbfeabaa6eb39956><p class=pgc-img-caption></p></div><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">在远程调试期间在C ++代码中的断点处停止</span></p><p style=text-align:justify><strong>远程QML调试</strong></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">在嵌入式设备上运行应用程序时，也可以调试QML代码。</span></p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">在Qt设置中启用QML调试：项目属性> Qt项目设置<br></span></li><li><span style="color:#666;--tt-darkmode-color: #666666">用于启动QML调试会话的安装程序参数</span></li></ul><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">项目属性>调试>程序参数</span></p><pre><code>-qmljsdebugger=port:8989,host:192.168.1.98,block</code></pre><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/58172861b64a466a93aa6a5559d3bdf4><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><h1 class=pgc-h-arrow-right>打包</h1><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">我们已经展示了如何使用Qt VS Tools扩展在带有Qt Quick的Visual Studio中创建多平台嵌入式应用程序。这包括：</span></p><ul><li><span style="color:#666;--tt-darkmode-color: #666666">从头开始创建Qt Quick项目</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">用QML编写应用程序代码</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">交叉编译应用程序</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">在嵌入式设备上部署和运行</span></li><li><span style="color:#666;--tt-darkmode-color: #666666">在Visual Studio中对C ++和QML代码进行远程调试</span></li></ul><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">该项目，包括所有源代码，可从以下网址获得：https : //github.com/micosta/quickmirror。</span></p><div class=pgc-img><img alt="如何利用Qt quick开发嵌入式应用程序，并实现远程调试" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bba17d71b18744f096680f0d5de88239><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:center><span style="color:#555;--tt-darkmode-color: #555555">应用程序在嵌入式设备上运行</span></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">感谢您的阅读和对Qt和VS Tools扩展的关注。如果您有任何疑问或建议，请在下面发表评论。</span></p><p style=text-align:justify><span style="color:#555;--tt-darkmode-color: #555555">如果这篇文章没能满足你的需求、点击</span><strong>“了解更多”</strong>！免费获取更多Qt资源教程！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Qt','quick','开发'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>