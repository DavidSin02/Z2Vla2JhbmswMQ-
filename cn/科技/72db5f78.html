<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构~单向环形链表 | 极客快訊</title><meta property="og:title" content="数据结构~单向环形链表 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6b0b1645262447c5b2376f1e826cec52"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/72db5f78.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/72db5f78.html><meta property="article:published_time" content="2020-10-29T21:09:57+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:57+08:00"><meta name=Keywords content><meta name=description content="数据结构~单向环形链表"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/72db5f78.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构~单向环形链表</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1>循环链表内存结构图</h1><div class=pgc-img><img alt=数据结构~单向环形链表 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6b0b1645262447c5b2376f1e826cec52><p class=pgc-img-caption></p></div><h1>循环链表操作分析</h1><p>1. 添加</p><p>a) 空链表添加第一个节点</p><p>b) 正常添加节点</p><p>i. 利用辅助节点，找到链表的最后一个节点</p><p>ii. 将新节点添加到最后</p><p>2. 删除</p><p>a) 删除首节点</p><p>i. 如果删除首节点后 size为0，说明链表为空。</p><p>ii. 正常删除首节点</p><p>注意：需要先找到当前链表的最后一个节点，改变尾结点的next指向新的首节点。</p><p>b) 删除正常节点</p><h1>循环链表代码实现</h1><pre>/** * All rights Reserved, Designed By https://www.tulingxueyuan.com/* @Title: CircleLinkedListDemo.java* @Package com.tuling.linked* @Description: * @author 北京图灵学院* @date 2019年11月19日* @version V1.0 */package com.tuling.linked;import com.tuling.linked.CircleNodeManager.Node;/** * @ClassName: CircleLinkedListDemo * @Description: * @author 小白 * @date 2019年11月19日 * */public class CircleLinkedListDemo {	/**	 * @Title: main 	 * @Description: 	 * @param args 	 * @return void 	 * @throws	 */	public static void main(String[] args) {		CircleNodeManager cnm = new CircleNodeManager();		cnm.add(1);		cnm.add(2);		cnm.add(3);		cnm.add(4);		cnm.add(5);		cnm.show();		System.out.println("-----------------");				System.out.println("要删除的节点为：" + cnm.del(1).getData());		cnm.show();	}}class CircleNodeManager {		//头结点，不存储数据，只负责记录 first 的地址	private Node head;	//首节点，真正的存储第一个数据。	private Node first;		private int size;		public CircleNodeManager() {		init();	}		/**	* @Title: init	* @Description:初始化链表 	* @param 	* @return void 	* @throws	*/	private void init() {		head = new Node(-1);		first = new Node(-1);		head.setNext(first);		first.setNext(first);		size = 0;	}		/**	* 	* @Title: add	* @Description:向尾部添加节点	* 	1、如果size == 0 ，说明链表为空，数据要加在首节点（first）上	* 	2、正常添加节点	* 		1&gt; 使用辅助节点找到当前链表的最后一个节点 currNode	* 		2&gt; currNode 的 next 指向新节点（addNode）	* 		3&gt; addNode 的 next 指向首节点（首节点地址在 head.next 中记录） 	* 	3、size + 1;	* @param data 	* @return void 	* @throws	*/	public void add(int data) {				if(size == 0) {			first.setData(data);		}else {			Node currNode = first;			while(true) {				if(currNode.getNext() == first) {					break;				}				currNode = currNode.getNext();			}			//循环结束，currNode 指向当前链表的最后一个节点			Node addNode = new Node(data);//该节点为需要添加的新节点			currNode.setNext(addNode);			addNode.setNext(head.getNext());		}		size++;	}		/**	* 	* @Title: show	* @Description:显示链表中的所有数据 	* @param 	* @return void 	* @throws	*/	public void show() {		if(size == 0) {			System.out.println("链表为空！");			return;		}		Node currNode = first;		while(true) {			System.out.println("当前节点为：" + currNode.getData());			if(currNode.getNext() == first) {				break;			}			currNode = currNode.getNext();		}	}		/**	* 	* @Title: del	* @Description:删除并返回要删除的节点对象 	* 	1、删除的是首节点	* 		1&gt; 删除首节点后 size == 0，说明链表为空，重新 init 即可	* 		2&gt; 删除首节点后，链表中还有元素	* 			1) 使用辅助节点，找到链表的最后一个节点	* 			2) 将 first 指向 first 的下一个节点：		first = first.next	* 			3) 将 最后一个节点的 next 指向新的 first：	currNode.next = first	* 			4) 将 head 节点的 next 指向新的 first：	head.next = first	* 	2、删除其他节点	* 			* 	3、size - 1	* @param data	* @param 	* @return Node 	* @throws	 */	public Node del(int data) {		if(size == 0) {			System.out.println("链表为空！");			return null;		}		Node delNode = null;		Node currNode = first;		if(first.getData() == data) {//要删除的是首节点						//记录要删除的节点，返回			delNode = first;						if(size-1 == 0) {				//TODO：不需要size--，因为init方法中做了初始化。				init();				return delNode;			}						//循环找到链表的最后一个节点			while(true) {				if(currNode.getNext() == first) {					break;				}				currNode = currNode.getNext();			}						//循环结束，currNode 指向链表的最后一个节点			//改变first 的指向。			first = first.getNext();			//head 节点指向新的 first			head.setNext(first);			//尾节点指向新的 first			currNode.setNext(first);			size--;		}else {//删除正常的节点			//循环找到要删除的节点			boolean flag = false;			while(true) {				if(currNode.getNext().getData() == data) {					flag = true;					break;				}				if(currNode.getNext() == first) {					break;				}				currNode = currNode.getNext();			}						//根据 flag 的值确定操作			if(flag) {				//记录要删除的节点				delNode = currNode.getNext();				//参考单向链表的删除				currNode.setNext(currNode.getNext().getNext());				size--;			}else {				System.out.println("为找到要删除的节点！");			}					}		return delNode;	}		/**	* @return head	*/	public Node getHead() {		return head;	}	/**	* @return first	*/	public Node getFirst() {		return first;	}	/**	* @return size	*/	public int getSize() {		return size;	}	class Node {		private int data;		private Node next;		/**		 * 创建一个新的实例 Node.		 *		 * @param data		 */		public Node(int data) {			super();			this.data = data;		}		/**		 * @return data		 */		public int getData() {			return data;		}		/**		 * @param data the data to set		 */		public void setData(int data) {			this.data = data;		}		/**		 * @return next		 */		public Node getNext() {			return next;		}		/**		 * @param next the next to set		 */		public void setNext(Node next) {			this.next = next;		}	}}</pre><h1>约瑟夫环</h1><p>据说著名犹太历史学家 Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p><div class=pgc-img><img alt=数据结构~单向环形链表 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/756c368d85ca40fd8ed3067e64f37936><p class=pgc-img-caption></p></div><h1>解决约瑟夫环</h1><p>修改测试代码：</p><pre>/** * All rights Reserved, Designed By https://www.tulingxueyuan.com/* @Title: CircleLinkedListDemo.java* @Package com.tuling.linked* @Description: * @author 北京图灵学院* @date 2019年11月19日* @version V1.0 */package com.tuling.linked;import com.tuling.linked.CircleNodeManager.Node;/** * @ClassName: CircleLinkedListDemo * @Description: * @author 小白 * @date 2019年11月19日 * */public class CircleLinkedListDemo {	/**	 * @Title: main 	 * @Description: 	 * @param args 	 * @return void 	 * @throws	 */	public static void main(String[] args) {		CircleNodeManager cnm = new CircleNodeManager();				int nums = 41;//总人数		int space = 3;//间隔				//--------------循环依次上循环链表中插入数据，构成环-----------------		for(int i = 1; i &lt;= nums; i++) {			cnm.add(i);		}						//--------------下面模拟自杀-----------------		//需要一个辅助节点，当做游标，不停移动。		Node currNode = cnm.getFirst();//从第一个人开始数数。				/**		 * 如果：currNode.getNext() == currNode 说明链表中只有一个元素		 */		while(currNode.getNext() != currNode) {//还有人没死，继续数数			//利用循环，根据 space 的值，不停的移动游标，也就是 currNode			for(int j = 1; j &lt; space; j++) {				currNode = currNode.getNext();			}						/**			 * 循环结束，currNode 指向要自杀的节点			 */			System.out.print(cnm.del(currNode.getData()).getData() + ", ");			//删除完成，游标一定要记得后移			currNode = currNode.getNext();		}		System.out.println();		System.out.println("自杀完成！");		cnm.show();	}}</pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','单向'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>