<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>5万字、97 张图总结操作系统核心知识点(上) | 极客快訊</title><meta property="og:title" content="5万字、97 张图总结操作系统核心知识点(上) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/98a0e3ef45ee4fc4b806e816919b54f0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/74c701b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/74c701b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/74c701b.html><meta property="article:published_time" content="2020-10-29T21:05:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:04+08:00"><meta name=Keywords content><meta name=description content="5万字、97 张图总结操作系统核心知识点(上)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/74c701b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>5万字、97 张图总结操作系统核心知识点(上)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/98a0e3ef45ee4fc4b806e816919b54f0></p><p>文末领取大图。</p><p>这不是一篇教你如何创建一个操作系统的文章，相反，这是一篇指导性文章，教你从几个方面来理解操作系统。首先你需要知道你为什么要看这篇文章以及为什么要学习操作系统。</p><h2>搞清楚几个问题</h2><p>首先你要搞明白你学习操作系统的目的是什么？操作系统的重要性如何？学习操作系统会给我带来什么？下面我会从这几个方面为你回答下。</p><p>操作系统也是一种软件，但是操作系统是一种非常复杂的软件。操作系统提供了几种抽象模型</p><ul><li>文件：对 I/O 设备的抽象</li><li>虚拟内存：对程序存储器的抽象</li><li>进程：对一个正在运行程序的抽象</li><li>虚拟机：对整个操作系统的抽象</li></ul><p>这些抽象和我们的日常开发息息相关。搞清楚了操作系统是如何抽象的，才能培养我们的抽象性思维和开发思路。</p><p>很多问题都和操作系统相关，操作系统是解决这些问题的基础。如果你不学习操作系统，可能会想着从框架层面来解决，那是你了解的还不够深入，当你学习了操作系统后，能够培养你的全局性思维。</p><p>学习操作系统我们能够有效的解决并发问题，并发几乎是互联网的重中之重了，这也从侧面说明了学习操作系统的重要性。</p><p>学习操作系统的重点不是让你从头制造一个操作系统，而是告诉你<strong>操作系统是如何工作的</strong>，能够让你对计算机底层有所了解，打实你的基础。</p><p>相信你一定清楚什么是编程</p><p><strong>Data structures + Algorithms = Programming</strong></p><p>操作系统内部会涉及到众多的数据结构和算法描述，能够让你了解算法的基础上，让你编写更优秀的程序。</p><p>我认为可以把计算机比作一栋楼</p><p>计算机的底层相当于就是楼的根基，计算机应用相当于就是楼的外形，而操作系统就相当于是告诉你大楼的构造原理，编写高质量的软件就相当于是告诉你构建一个稳定的房子。</p><h2>认识操作系统</h2><p>在了解操作系统前，你需要先知道一下什么是计算机系统：现代计算机系统由<strong>一个或多个处理器、主存、打印机、键盘、鼠标、显示器、网络接口以及各种输入/输出设备构成的系统</strong>。这些都属于硬件的范畴。我们程序员不会直接和这些硬件打交道，并且每位程序员不可能会掌握所有计算机系统的细节。</p><p>所以计算机科学家在硬件的基础之上，安装了一层软件，这层软件能够根据用户输入的指令达到控制硬件的效果，从而满足用户的需求，这样的软件称为 操作系统，它的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型。也就是说，操作系统相当于是一个中间层，为用户层和硬件提供各自的借口，屏蔽了不同应用和硬件之间的差异，达到统一标准的作用。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb4122e603fe4c44a557742c9c4ed258></p><p>上面一个操作系统的简化图，最底层是硬件，硬件包括<strong>芯片、电路板、磁盘、键盘、显示器</strong>等我们上面提到的设备，在硬件之上是软件。大部分计算机有两种运行模式：内核态 和 用户态，软件中最基础的部分是操作系统，它运行在 内核态 中。操作系统具有硬件的访问权，可以执行机器能够运行的任何指令。软件的其余部分运行在 用户态 下。</p><p>在大概了解到操作系统之后，我们先来认识一下硬件都有哪些</p><h2>计算机硬件</h2><p>计算机硬件是计算机的重要组成部分，其中包含了 5 个重要的组成部分：<strong>运算器、控制器、存储器、输入设备、输出设备</strong>。</p><ul><li>运算器：运算器最主要的功能是对数据和信息进行加工和运算。它是计算机中执行算数和各种逻辑运算的部件。运算器的基本运算包括加、减、乘、除、移位等操作，这些是由 算术逻辑单元(Arithmetic&logical Unit) 实现的。而运算器主要由算数逻辑单元和寄存器构成。</li><li>控制器：指按照指定顺序改变主电路或控制电路的部件，它主要起到了控制命令执行的作用，完成协调和指挥整个计算机系统的操作。控制器是由程序计数器、指令寄存器、解码译码器等构成。</li></ul><blockquote><p>运算器和控制器共同组成了 CPU</p></blockquote><ul><li><p>存储器：存储器就是计算机的记忆设备，顾名思义，存储器可以保存信息。存储器分为两种，一种是主存，也就是内存，它是 CPU 主要交互对象，还有一种是外存，比如硬盘软盘等。下面是现代计算机系统的存储架构</p></li><li><p>输入设备：输入设备是给计算机获取外部信息的设备，它主要包括键盘和鼠标。</p></li><li><p>输出设备：输出设备是给用户呈现根据输入设备获取的信息经过一系列的计算后得到显示的设备，它主要包括显示器、打印机等。</p></li></ul><p>这五部分也是冯诺伊曼的体系结构，它认为计算机必须具有如下功能：</p><p>把需要的程序和数据送至计算机中。必须具有长期记忆程序、数据、中间结果及最终运算结果的能力。能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力。能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作。能够按照要求将处理结果输出给用户。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b2ea176490f84d7caafc781e76d4dd18></p><p>下面是一张 intel 家族产品图，是一个详细的计算机硬件分类，我们在根据图中涉及到硬件进行介绍</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5e5b95938fe744cc9fada99cd90ae183></p><ul><li>总线(Buses)：在整个系统中运行的是称为总线的电气管道的集合，这些总线在组件之间来回传输字节信息。通常总线被设计成传送定长的字节块，也就是 字(word)。字中的字节数（字长）是一个基本的系统参数，各个系统中都不尽相同。现在大部分的字都是 4 个字节（32 位）或者 8 个字节（64 位）。</li></ul><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/000ab977b9f84f6e806199773f3adeb9></p><ul><li><p>I/O 设备(I/O Devices)：Input/Output 设备是系统和外部世界的连接。上图中有四类 I/O 设备：用于用户输入的键盘和鼠标，用于用户输出的显示器，一个磁盘驱动用来长时间的保存数据和程序。刚开始的时候，可执行程序就保存在磁盘上。</p><p>每个I/O 设备连接 I/O 总线都被称为控制器(controller) 或者是 适配器(Adapter)。控制器和适配器之间的主要区别在于封装方式。控制器是 I/O 设备本身或者系统的主印制板电路（通常称作主板）上的芯片组。而适配器则是一块插在主板插槽上的卡。无论组织形式如何，它们的最终目的都是彼此交换信息。</p></li><li><p>主存(Main Memory)，主存是一个临时存储设备，而不是永久性存储，磁盘是 永久性存储 的设备。主存既保存程序，又保存处理器执行流程所处理的数据。从物理组成上说，主存是由一系列 DRAM(dynamic random access memory) 动态随机存储构成的集合。逻辑上说，内存就是一个线性的字节数组，有它唯一的地址编号，从 0 开始。一般来说，组成程序的每条机器指令都由不同数量的字节构成，C 程序变量相对应的数据项的大小根据类型进行变化。比如，在 Linux 的 x86-64 机器上，short 类型的数据需要 2 个字节，int 和 float 需要 4 个字节，而 long 和 double 需要 8 个字节。</p></li><li><p>处理器(Processor)，CPU(central processing unit) 或者简单的处理器，是解释（并执行）存储在主存储器中的指令的引擎。处理器的核心大小为一个字的存储设备（或寄存器），称为程序计数器(PC)。在任何时刻，PC 都指向主存中的某条机器语言指令（即含有该条指令的地址）。</p><p>从系统通电开始，直到系统断电，处理器一直在不断地执行程序计数器指向的指令，再更新程序计数器，使其指向下一条指令。处理器根据其指令集体系结构定义的指令模型进行操作。在这个模型中，指令按照严格的顺序执行，执行一条指令涉及执行一系列的步骤。处理器从程序计数器指向的内存中读取指令，解释指令中的位，执行该指令指示的一些简单操作，然后更新程序计数器以指向下一条指令。指令与指令之间可能连续，可能不连续（比如 jmp 指令就不会顺序读取）</p></li></ul><p>下面是 CPU 可能执行简单操作的几个步骤</p><ul><li>加载(Load)：从主存中拷贝一个字节或者一个字到内存中，覆盖寄存器先前的内容</li><li>存储(Store)：将寄存器中的字节或字复制到主存储器中的某个位置，从而覆盖该位置的先前内容</li><li>操作(Operate)：把两个寄存器的内容复制到 ALU(Arithmetic logic unit)。把两个字进行算术运算，并把结果存储在寄存器中，重写寄存器先前的内容。</li></ul><blockquote><p>算术逻辑单元（ALU）是对数字二进制数执行算术和按位运算的组合数字电子电路。</p></blockquote><ul><li>跳转(jump)：从指令中抽取一个字，把这个字复制到程序计数器(PC) 中，覆盖原来的值</li></ul><h2>进程和线程</h2><p>关于进程和线程，你需要理解下面这张脑图中的重点</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29d7c00aea2948d38565591c2efb82c3></p><h2>进程</h2><p>操作系统中最核心的概念就是 进程，进程是对正在运行中的程序的一个抽象。操作系统的其他所有内容都是围绕着进程展开的。</p><p>在多道程序处理的系统中，CPU 会在进程间快速切换，使每个程序运行几十或者几百毫秒。然而，严格意义来说，在某一个瞬间，CPU 只能运行一个进程，然而我们如果把时间定位为 1 秒内的话，它可能运行多个进程。这样就会让我们产生并行的错觉。因为 CPU 执行速度很快，进程间的换进换出也非常迅速，因此我们很难对多个并行进程进行跟踪。所以，操作系统的设计者开发了用于描述并行的一种概念模型（顺序进程），使得并行更加容易理解和分析。</p><h3>进程模型</h3><p>一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e3103f2f68df463c83c541e7af862912></p><p>如上图所示，这是一个具有 4 个程序的多道处理程序，在进程不断切换的过程中，程序计数器也在不同的变化。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/230653c035b44e1994b11a0b762d47da></p><p>在上图中，这 4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p><p>从下图我们可以看到，在观察足够长的一段时间后，所有的进程都运行了，<strong>但在任何一个给定的瞬间仅有一个进程真正运行</strong>。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0d2c92e8eee445b7b5c5a9ed629bdd49></p><p>因此，当我们说一个 CPU 只能真正一次运行一个进程的时候，即使有 2 个核（或 CPU），<strong>每一个核也只能一次运行一个线程</strong>。</p><p>由于 CPU 会在各个进程之间来回快速切换，所以每个进程在 CPU 中的运行时间是无法确定的。并且当同一个进程再次在 CPU 中运行时，其在 CPU 内部的运行时间往往也是不固定的。</p><p>这里的关键思想是认识到一个进程所需的条件，进程是某一类特定活动的总和，它有程序、输入输出以及状态。</p><h3>进程的创建</h3><p>操作系统需要一些方式来创建进程。下面是一些创建进程的方式</p><ul><li>系统初始化（init）：启动操作系统时，通常会创建若干个进程。</li><li>正在运行的程序执行了创建进程的系统调用（比如 fork）</li><li>用户请求创建一个新进程：在许多交互式系统中，输入一个命令或者双击图标就可以启动程序，以上任意一种操作都可以选择开启一个新的进程，在基本的 UNIX 系统中运行 X，新进程将接管启动它的窗口。</li><li>初始化一个批处理工作</li></ul><p>从技术上讲，在所有这些情况下，让现有流程执行流程是通过创建系统调用来创建新流程的。该进程可能是正在运行的用户进程，是从键盘或鼠标调用的系统进程或批处理程序。这些就是系统调用创建新进程的过程。该系统调用告诉操作系统创建一个新进程，并直接或间接指示在其中运行哪个程序。</p><p>在 UNIX 中，仅有一个系统调用来创建一个新的进程，这个系统调用就是 fork。这个调用会创建一个与调用进程相关的副本。在 fork 后，一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件。</p><p>在 Windows 中，情况正相反，一个简单的 Win32 功能调用 CreateProcess，会处理流程创建并将正确的程序加载到新的进程中。这个调用会有 10 个参数，包括了需要执行的程序、输入给程序的命令行参数、各种安全属性、有关打开的文件是否继承控制位、优先级信息、进程所需要创建的窗口规格以及指向一个结构的指针，在该结构中新创建进程的信息被返回给调用者。<strong>在 Windows 中，从一开始父进程的地址空间和子进程的地址空间就是不同的</strong>。</p><h3>进程的终止</h3><p>进程在创建之后，它就开始运行并做完成任务。然而，没有什么事儿是永不停歇的，包括进程也一样。进程早晚会发生终止，但是通常是由于以下情况触发的</p><ul><li>正常退出(自愿的) ： 多数进程是由于完成了工作而终止。当编译器完成了所给定程序的编译之后，编译器会执行一个系统调用告诉操作系统它完成了工作。这个调用在 UNIX 中是 exit ，在 Windows 中是 ExitProcess。</li><li>错误退出(自愿的)：比如执行一条不存在的命令，于是编译器就会提醒并退出。</li><li>严重错误(非自愿的)</li><li>被其他进程杀死(非自愿的) ： 某个进程执行系统调用告诉操作系统杀死某个进程。在 UNIX 中，这个系统调用是 kill。在 Win32 中对应的函数是 TerminateProcess（注意不是系统调用）。</li></ul><h3>进程的层次结构</h3><p>在一些系统中，当一个进程创建了其他进程后，父进程和子进程就会以某种方式进行关联。子进程它自己就会创建更多进程，从而形成一个进程层次结构。</p><h4>UNIX 进程体系</h4><p>在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组。当用户从键盘中发出一个信号后，该信号被发送给当前与键盘相关的进程组中的所有成员（它们通常是在当前窗口创建的所有活动进程）。每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉。整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3df50f6030ff48f49771f7cc2ee32ac5></p><h4>Windows 进程体系</h4><p>相反，Windows 中没有进程层次的概念，Windows 中所有进程都是平等的，唯一类似于层次结构的是在创建进程的时候，父进程得到一个特别的令牌（称为句柄），该句柄可以用来控制子进程。然而，这个令牌可能也会移交给别的操作系统，这样就不存在层次结构了。而在 UNIX 中，进程不能剥夺其子进程的 进程权。（这样看来，还是 Windows 比较渣）。</p><h3>进程状态</h3><p>尽管每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间仍然需要相互帮助。当一个进程开始运行时，它可能会经历下面这几种状态</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bbff8cc6411849a5a50464342474743a></p><p>图中会涉及三种状态</p><ol><li>运行态，运行态指的就是进程实际占用 CPU 时间片运行时</li><li>就绪态，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态</li><li>阻塞态，除非某种外部事件发生，否则进程不能运行</li></ol><h3>进程的实现</h3><p>操作系统为了执行进程间的切换，会维护着一张表，这张表就是 进程表(process table)。每个进程占用一个进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息。</p><p>下面展示了一个典型系统中的关键字段</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/92f3b07a52b147e2943eb3c05da00361></p><p>第一列内容与进程管理有关，第二列内容与 存储管理有关，第三列内容与文件管理有关。</p><p>现在我们应该对进程表有个大致的了解了，就可以在对单个 CPU 上如何运行多个顺序进程的错觉做更多的解释。与每一 I/O 类相关联的是一个称作 中断向量(interrupt vector) 的位置（靠近内存底部的固定区域）。它包含中断服务程序的入口地址。假设当一个磁盘中断发生时，用户进程 3 正在运行，则中断硬件将程序计数器、程序状态字、有时还有一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所指示的地址。这就是硬件所做的事情。然后软件就随即接管一切剩余的工作。</p><p>当中断结束后，操作系统会调用一个 C 程序来处理中断剩下的工作。在完成剩下的工作后，会使某些进程就绪，接着调用调度程序，决定随后运行哪个进程。然后将控制权转移给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行，下面显示了中断处理和调度的过程。</p><ol><li><p>硬件压入堆栈程序计数器等</p></li><li><p>硬件从中断向量装入新的程序计数器</p></li><li><p>汇编语言过程保存寄存器的值</p></li><li><p>汇编语言过程设置新的堆栈</p></li><li><p>C 中断服务器运行（典型的读和缓存写入）</p></li><li><p>调度器决定下面哪个程序先运行</p></li><li><p>C 过程返回至汇编代码</p></li><li><p>汇编语言过程开始运行新的当前进程</p></li></ol><p>一个进程在执行过程中可能被中断数千次，但关键每次中断后，被中断的进程都返回到与中断发生前完全相同的状态。</p><h2>线程</h2><p>在传统的操作系统中，每个进程都有一个地址空间和一个控制线程。事实上，这是大部分进程的定义。不过，在许多情况下，经常存在同一地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。下面我们就着重探讨一下什么是线程</p><h3>线程的使用</h3><p>或许这个疑问也是你的疑问，为什么要在进程的基础上再创建一个线程的概念，准确的说，这其实是进程模型和线程模型的讨论，回答这个问题，可能需要分三步来回答</p><ul><li>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</li><li>线程要比进程更轻量级，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li><li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li></ul><h3>经典的线程模型</h3><p>进程中拥有一个执行的线程，通常简写为 线程(thread)。线程会有程序计数器，用来记录接着要执行哪一条指令；线程实际上 CPU 上调度执行的实体。</p><p>下图我们可以看到三个传统的进程，每个进程有自己的地址空间和单个控制线程。每个线程都在不同的地址空间中运行</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d14bbd4b069a416ba4c2a5c216cefc6f></p><p>下图中，我们可以看到有一个进程三个线程的情况。每个线程都在相同的地址空间中运行。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6c61d840c58a446282a7d87dfa6e8c33></p><p>线程不像是进程那样具备较强的独立性。同一个进程中的所有线程都会有完全一样的地址空间，这意味着它们也共享同样的全局变量。由于每个线程都可以访问进程地址空间内每个内存地址，<strong>因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</strong>。线程之间除了共享同一内存空间外，还具有如下不同的内容</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d927dd83658742518d2e22d5178f9a9d></p><p>上图左边的是同一个进程中每个线程共享的内容，上图右边是每个线程中的内容。也就是说左边的列表是进程的属性，右边的列表是线程的属性。</p><p><strong>线程之间的状态转换和进程之间的状态转换是一样的</strong>。</p><p>每个线程都会有自己的堆栈，如下图所示</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf502f22f32e4399a1a005a67e802536></p><h4>线程系统调用</h4><p>进程通常会从当前的某个单线程开始，然后这个线程通过调用一个库函数（比如 thread_create）创建新的线程。线程创建的函数会要求指定新创建线程的名称。创建的线程通常都返回一个线程标识符，该标识符就是新线程的名字。</p><p>当一个线程完成工作后，可以通过调用一个函数（比如 thread_exit）来退出。紧接着线程消失，状态变为终止，不能再进行调度。在某些线程的运行过程中，可以通过调用函数例如 thread_join ，表示一个线程可以等待另一个线程退出。这个过程阻塞调用线程直到等待特定的线程退出。在这种情况下，线程的创建和终止非常类似于进程的创建和终止。</p><p>另一个常见的线程是调用 thread_yield，它允许线程自动放弃 CPU 从而让另一个线程运行。这样一个调用还是很重要的，因为不同于进程，线程是无法利用时钟中断强制让线程让出 CPU 的。</p><h3>POSIX 线程</h3><p>POSIX 线程 通常称为 pthreads是一种独立于语言而存在的执行模型，以及并行执行模型。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56373349678a4346b3419cd24555f8d6></p><p>它允许程序控制时间上重叠的多个不同的工作流程。每个工作流程都称为一个线程，可以通过调用 POSIX Threads API 来实现对这些流程的创建和控制。可以把它理解为线程的标准。</p><blockquote><p>POSIX Threads 的实现在许多类似且符合POSIX的操作系统上可用，例如 <strong>FreeBSD、NetBSD、OpenBSD、Linux、macOS、Android、Solaris</strong>，它在现有 Windows API 之上实现了<strong>pthread</strong>。</p><p>IEEE 是世界上最大的技术专业组织，致力于为人类的利益而发展技术。</p></blockquote><p>线程调用描述pthread_create创建一个新线程pthread_exit结束调用的线程pthread_join等待一个特定的线程退出pthread_yield释放 CPU 来运行另外一个线程pthread_attr_init创建并初始化一个线程的属性结构pthread_attr_destory删除一个线程的属性结构</p><p>所有的 Pthreads 都有特定的属性，每一个都含有标识符、一组寄存器（包括程序计数器）和一组存储在结构中的属性。这个属性包括堆栈大小、调度参数以及其他线程需要的项目。</p><h3>线程实现</h3><p>主要有三种实现方式</p><ul><li>在用户空间中实现线程；</li><li>在内核空间中实现线程；</li><li>在用户和内核空间中混合实现线程。</li></ul><p>下面我们分开讨论一下</p><h4>在用户空间中实现线程</h4><p>第一种方法是把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。所有的这类实现都有同样的通用结构</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ef7e05728ba647ae94f1874af93b9bd9></p><p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合，包括前面提到的四个过程： pthread_create, pthread_exit, pthread_join 和 pthread_yield。</p><h3>在内核中实现线程</h3><p>当某个线程希望创建一个新线程或撤销一个已有线程时，它会进行一个系统调用，这个系统调用通过对线程表的更新来完成线程创建或销毁工作。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c8427c173be94beaa49bded24a776a37></p><p>内核中的线程表持有每个线程的寄存器、状态和其他信息。这些信息和用户空间中的线程信息相同，但是位置却被放在了内核中而不是用户空间中。另外，内核还维护了一张进程表用来跟踪系统状态。</p><p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 时间片（或者没有可运行的线程存在了）为止。</p><h3>混合实现</h3><p>结合用户空间和内核空间的优点，设计人员采用了一种内核级线程的方式，然后将用户级线程与某些或者全部内核线程多路复用起来</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/928de0d5349140e9a332ba8a18d53f3f></p><p>在这种模型中，编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度。采用这种方法，内核只识别内核级线程，并对其进行调度。其中一些内核级线程会被多个用户级线程多路复用。</p><h2>进程间通信</h2><p>进程是需要频繁的和其他进程进行交流的。下面我们会一起讨论有关 进程间通信(Inter Process Communication, IPC) 的问题。大致来说，进程间的通信机制可以分为 6 种</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1e9a3ab259e1488d84921cde6d5beeac></p><p>下面我们分别对其进行概述</p><h3>信号 signal</h3><p>信号是 UNIX 系统最先开始使用的进程间通信机制，因为 Linux 是继承于 UNIX 的，所以 Linux 也支持信号机制，通过向一个或多个进程发送异步事件信号来实现，信号可以从键盘或者访问不存在的位置等地方产生；信号通过 shell 将任务发送给子进程。</p><p>你可以在 Linux 系统上输入 kill -l 来列出系统使用的信号，下面是我提供的一些信号</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b532605323874d6c86264a5ad179e243></p><p>进程可以选择忽略发送过来的信号，但是有两个是不能忽略的：SIGSTOP 和 SIGKILL 信号。SIGSTOP 信号会通知当前正在运行的进程执行关闭操作，SIGKILL 信号会通知当前进程应该被杀死。除此之外，进程可以选择它想要处理的信号，进程也可以选择阻止信号，如果不阻止，可以选择自行处理，也可以选择进行内核处理。如果选择交给内核进行处理，那么就执行默认处理。</p><p>操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断，如果进程已经注册了新号处理程序，那么就执行进程，如果没有注册，将采用默认处理的方式。</p><h3>管道 pipe</h3><p>Linux 系统中的进程可以通过建立管道 pipe 进行通信</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b4eec716830949989ee39055758296d3></p><p>在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流。管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止。shell 中的管线 pipelines 就是用管道实现的，当 shell 发现输出</p><p>sort &lt;f | head</p><p>它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入。sort 进程产生的输出就不用写到文件中了，如果管道满了系统会停止 sort 以等待 head 读出数据</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/92a5e278c9484d90a726c31153ab3558></p><p>管道实际上就是 |，两个应用程序不知道有管道的存在，一切都是由 shell 管理和控制的。</p><h3>共享内存 shared memory</h3><p>两个进程之间还可以通过共享内存进行进程间通信，其中两个或者多个进程可以访问公共内存空间。两个进程的共享工作是通过共享内存完成的，一个进程所作的修改可以对另一个进程可见(很像线程间的通信)。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f4cb78e33a4c4bd9bcf4251b718a0c33></p><p>在使用共享内存前，需要经过一系列的调用流程，流程如下</p><ul><li>创建共享内存段或者使用已创建的共享内存段(shmget())</li><li>将进程附加到已经创建的内存段中(shmat())</li><li>从已连接的共享内存段分离进程(shmdt())</li><li>对共享内存段执行控制操作(shmctl())</li></ul><h3>先入先出队列 FIFO</h3><p>先入先出队列 FIFO 通常被称为 命名管道(Named Pipes)，命名管道的工作方式与常规管道非常相似，但是确实有一些明显的区别。未命名的管道没有备份文件：操作系统负责维护内存中的缓冲区，用来将字节从写入器传输到读取器。一旦写入或者输出终止的话，缓冲区将被回收，传输的数据会丢失。相比之下，命名管道具有支持文件和独特 API ，命名管道在文件系统中作为设备的专用文件存在。当所有的进程通信完成后，命名管道将保留在文件系统中以备后用。命名管道具有严格的 FIFO 行为</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/36ead583514340b192bb8b30f83e392f></p><p>写入的第一个字节是读取的第一个字节，写入的第二个字节是读取的第二个字节，依此类推。</p><h3>消息队列 Message Queue</h3><p>一听到消息队列这个名词你可能不知道是什么意思，消息队列是用来描述内核寻址空间内的内部链接列表。可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息。每个消息队列由 IPC 标识符唯一标识。消息队列有两种模式，一种是严格模式， 严格模式就像是 FIFO 先入先出队列似的，消息顺序发送，顺序读取。还有一种模式是 非严格模式，消息的顺序性不是非常重要。</p><h3>套接字 Socket</h3><p>还有一种管理两个进程间通信的是使用 socket，socket 提供端到端的双相通信。一个套接字可以与一个或多个进程关联。就像管道有命令管道和未命名管道一样，套接字也有两种模式，套接字一般用于两个进程之间的网络通信，网络套接字需要来自诸如TCP（传输控制协议）或较低级别UDP（用户数据报协议）等基础协议的支持。</p><p>套接字有以下几种分类</p><ul><li>顺序包套接字(Sequential Packet Socket)： 此类套接字为最大长度固定的数据报提供可靠的连接。此连接是双向的并且是顺序的。</li><li>数据报套接字(Datagram Socket)：数据包套接字支持双向数据流。数据包套接字接受消息的顺序与发送者可能不同。</li><li>流式套接字(Stream Socket)：流套接字的工作方式类似于电话对话，提供双向可靠的数据流。</li><li>原始套接字(Raw Socket)： 可以使用原始套接字访问基础通信协议。</li></ul><h2>调度</h2><p>当一个计算机是多道程序设计系统时，会频繁的有很多进程或者线程来同时竞争 CPU 时间片。当两个或两个以上的进程/线程处于就绪状态时，就会发生这种情况。如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 调度程序(scheduler) 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 调度算法(scheduling algorithm) 。</p><h3>调度算法的分类</h3><p>毫无疑问，不同的环境下需要不同的调度算法。之所以出现这种情况，是因为不同的应用程序和不同的操作系统有不同的目标。也就是说，在不同的系统中，调度程序的优化也是不同的。这里有必要划分出三种环境</p><ul><li>批处理(Batch) : 商业领域</li><li>交互式(Interactive)： 交互式用户环境</li><li>实时(Real time)</li></ul><h3>批处理中的调度</h3><p>现在让我们把目光从一般性的调度转换为特定的调度算法。下面我们会探讨在批处理中的调度。</p><h4>先来先服务</h4><p>最简单的非抢占式调度算法的设计就是 先来先服务(first-come,first-serverd)。当第一个任务从外部进入系统时，将会立即启动并允许运行任意长的时间。它不会因为运行时间太长而中断。当其他作业进入时，它们排到就绪队列尾部。当正在运行的进程阻塞，处于等待队列的第一个进程就开始运行。当一个阻塞的进程重新处于就绪态时，它会像一个新到达的任务，会排在队列的末尾，即排在所有进程最后。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/70a98177954f41409d5970a94dd827a4></p><p>这个算法的强大之处在于易于理解和编程，在这个算法中，一个单链表记录了所有就绪进程。要选取一个进程运行，只要从该队列的头部移走一个进程即可；要添加一个新的作业或者阻塞一个进程，只要把这个作业或进程附加在队列的末尾即可。这是很简单的一种实现。</p><h4>最短作业优先</h4><p>批处理中，第二种调度算法是 最短作业优先(Shortest Job First)，我们假设运行时间已知。例如，一家保险公司，因为每天要做类似的工作，所以人们可以相当精确地预测处理 1000 个索赔的一批作业需要多长时间。当输入队列中有若干个同等重要的作业被启动时，调度程序应使用最短优先作业算法</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ae3e193d8354bb49e56973546da9cc5></p><blockquote><p>需要注意的是，在所有的进程都可以运行的情况下，最短作业优先的算法才是最优的。</p></blockquote><h4>最短剩余时间优先</h4><p>最短作业优先的抢占式版本被称作为 最短剩余时间优先(Shortest Remaining Time Next) 算法。使用这个算法，调度程序总是选择剩余运行时间最短的那个进程运行。</p><h3>交互式系统中的调度</h3><p>交互式系统中在个人计算机、服务器和其他系统中都是很常用的，所以有必要来探讨一下交互式调度</p><h4>轮询调度</h4><p>一种最古老、最简单、最公平并且最广泛使用的算法就是 轮询算法(round-robin)。每个进程都会被分配一个时间段，称为时间片(quantum)，在这个时间片内允许进程运行。如果时间片结束时进程还在运行的话，则抢占一个 CPU 并将其分配给另一个进程。如果进程在时间片结束前阻塞或结束，则 CPU 立即进行切换。轮询算法比较容易实现。调度程序所做的就是维护一个可运行进程的列表，就像下图中的 a，当一个进程用完时间片后就被移到队列的末尾，就像下图的 b。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/120020ceaf7e416a86ee6db16419c0e4></p><h4>优先级调度</h4><p>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了优先级调度(priority scheduling)</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb0200482436459aa9891900f82522e1></p><p>它的基本思想很明确，每个进程都被赋予一个优先级，优先级高的进程优先运行。</p><h4>多级队列</h4><p>最早使用优先级调度的系统是 CTSS(Compatible TimeSharing System)。CTSS 在每次切换前都需要将当前进程换出到磁盘，并从磁盘上读入一个新进程。为 CPU 密集型进程设置较长的时间片比频繁地分给他们很短的时间要更有效（减少交换次数）。另一方面，如前所述，长时间片的进程又会影响到响应时间，解决办法是设置优先级类。属于最高优先级的进程运行一个时间片，次高优先级进程运行 2 个时间片，再下面一级运行 4 个时间片，以此类推。当一个进程用完分配的时间片后，它被移到下一类。</p><h4>最短进程优先</h4><p>最短进程优先是根据进程过去的行为进行推测，并执行估计运行时间最短的那一个。假设每个终端上每条命令的预估运行时间为 T0，现在假设测量到其下一次运行时间为 T1，可以用两个值的加权来改进估计时间，即aT0+ (1- 1)T1。通过选择 a 的值，可以决定是尽快忘掉老的运行时间，还是在一段长时间内始终记住它们。当 a = 1/2 时，可以得到下面这个序列</p><p>![image-20200220120452410](/Users/mr.l/Library/Application Support/typora-user-images/image-20200220120452410.png)</p><p>可以看到，在三轮过后，T0 在新的估计值中所占比重下降至 1/8。</p><h4>保证调度</h4><p>一种完全不同的调度方法是对用户做出明确的性能保证。一种实际而且容易实现的保证是：若用户工作时有 n 个用户登录，则每个用户将获得 CPU 处理能力的 1/n。类似地，在一个有 n 个进程运行的单用户系统中，若所有的进程都等价，则每个进程将获得 1/n 的 CPU 时间。</p><h4>彩票调度</h4><p>对用户进行承诺并在随后兑现承诺是一件好事，不过很难实现。但是存在着一种简单的方式，有一种既可以给出预测结果而又有一种比较简单的实现方式的算法，就是 彩票调度(lottery scheduling)算法。</p><p>其基本思想是为进程提供各种系统资源（例如 CPU 时间）的彩票。当做出一个调度决策的时候，就随机抽出一张彩票，拥有彩票的进程将获得该资源。在应用到 CPU 调度时，系统可以每秒持有 50 次抽奖，每个中奖者将获得比如 20 毫秒的 CPU 时间作为奖励。</p><h4>公平分享调度</h4><p>到目前为止，我们假设被调度的都是各个进程自身，而不用考虑该进程的拥有者是谁。结果是，如果用户 1 启动了 9 个进程，而用户 2 启动了一个进程，使用轮转或相同优先级调度算法，那么用户 1 将得到 90 % 的 CPU 时间，而用户 2 将之得到 10 % 的 CPU 时间。</p><p>为了阻止这种情况的出现，一些系统在调度前会把进程的拥有者考虑在内。在这种模型下，每个用户都会分配一些CPU 时间，而调度程序会选择进程并强制执行。因此如果两个用户每个都会有 50% 的 CPU 时间片保证，那么无论一个用户有多少个进程，都将获得相同的 CPU 份额。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb0a11978bf3497bac18d248274232e1></p><h3>实时系统中的调度</h3><p>实时系统(real-time) 是一个时间扮演了重要作用的系统。实时系统可以分为两类，硬实时(hard real time) 和 软实时(soft real time) 系统，前者意味着必须要满足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p><p>实时系统中的事件可以按照响应方式进一步分类为周期性(以规则的时间间隔发生)事件或 非周期性(发生时间不可预知)事件。一个系统可能要响应多个周期性事件流，根据每个事件处理所需的时间，可能甚至无法处理所有事件。例如，如果有 m 个周期事件，事件 i 以周期 Pi 发生，并需要 Ci 秒 CPU 时间处理一个事件，那么可以处理负载的条件是</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b623d2a282144fbb00fcbf78e4627ec></p><p>只有满足这个条件的实时系统称为可调度的，这意味着它实际上能够被实现。一个不满足此检验标准的进程不能被调度，因为这些进程共同需要的 CPU 时间总和大于 CPU 能提供的时间。</p><p>下面我们来了解一下内存管理，你需要知道的知识点如下</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d78500d90de43629ca4c439a0779a8c></p><h2>地址空间</h2><p>如果要使多个应用程序同时运行在内存中，必须要解决两个问题：保护和 重定位。第一种解决方式是用保护密钥标记内存块，并将执行过程的密钥与提取的每个存储字的密钥进行比较。这种方式只能解决第一种问题（破坏操作系统），但是不能解决多进程在内存中同时运行的问题。</p><p>还有一种更好的方式是创造一个存储器抽象：地址空间(the address space)。就像进程的概念创建了一种抽象的 CPU 来运行程序，地址空间也创建了一种抽象内存供程序使用。</p><h4>基址寄存器和变址寄存器</h4><p>最简单的办法是使用动态重定位(dynamic relocation)技术，它就是通过一种简单的方式将每个进程的地址空间映射到物理内存的不同区域。还有一种方式是使用基址寄存器和变址寄存器。</p><ul><li>基址寄存器：存储数据内存的起始位置</li><li>变址寄存器：存储应用程序的长度。</li></ul><p>每当进程引用内存以获取指令或读取、写入数据时，CPU 都会自动将基址值添加到进程生成的地址中，然后再将其发送到内存总线上。同时，它检查程序提供的地址是否大于或等于变址寄存器 中的值。如果程序提供的地址要超过变址寄存器的范围，那么会产生错误并中止访问。</p><h3>交换技术</h3><p>在程序运行过程中，经常会出现内存不足的问题。</p><p>针对上面内存不足的问题，提出了两种处理方式：最简单的一种方式就是交换(swapping)技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做虚拟内存(virtual memory)，虚拟内存技术能够允许应用程序部分的运行在内存中。下面我们首先先探讨一下交换</p><h4>交换过程</h4><p>下面是一个交换过程</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f6f13e17142e4d57bb3fcf05fe71a3fb></p><p>刚开始的时候，只有进程 A 在内存中，然后从创建进程 B 和进程 C 或者从磁盘中把它们换入内存，然后在图 d 中，A 被换出内存到磁盘中，最后 A 重新进来。因为图 g 中的进程 A 现在到了不同的位置，所以在装载过程中需要被重新定位，或者在交换程序时通过软件来执行；或者在程序执行期间通过硬件来重定位。基址寄存器和变址寄存器就适用于这种情况。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86dd8707c072426797f27160985a981a></p><p>交换在内存创建了多个 空闲区(hole)，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这项技术称为内存紧缩(memory compaction)。但是这项技术通常不会使用，因为这项技术会消耗很多 CPU 时间。</p><h3>空闲内存管理</h3><p>在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式</p><ul><li>位图(bitmap)</li><li>空闲列表(free lists)</li></ul><h4>使用位图的存储管理</h4><p>使用位图方法时，内存可能被划分为小到几个字或大到几千字节的分配单元。每个分配单元对应于位图中的一位，0 表示空闲， 1 表示占用（或者相反）。一块内存区域和其对应的位图如下</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30fe541b987d40c0a988784ee43f1997></p><p>位图提供了一种简单的方法在固定大小的内存中跟踪内存的使用情况，因为<strong>位图的大小取决于内存和分配单元的大小</strong>。这种方法有一个问题是，当决定为把具有 k 个分配单元的进程放入内存时，内容管理器(memory manager) 必须搜索位图，在位图中找出能够运行 k 个连续 0 位的串。在位图中找出制定长度的连续 0 串是一个很耗时的操作，这是位图的缺点。（可以简单理解为在杂乱无章的数组中，找出具有一大长串空闲的数组单元）</p><h4>使用链表进行管理</h4><p>另一种记录内存使用情况的方法是，维护一个记录已分配内存段和空闲内存段的链表，段会包含进程或者是两个进程的空闲区域。可用上面的图 c <strong>来表示内存的使用情况</strong>。链表中的每一项都可以代表一个 空闲区(H) 或者是进程(P)的起始标志，长度和下一个链表项的位置。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/711c3e07db3345dd829d84abb6562a3a></p><p>当按照地址顺序在链表中存放进程和空闲区时，有几种算法可以为创建的进程（或者从磁盘中换入的进程）分配内存。我们先假设内存管理器知道应该分配多少内存，最简单的算法是使用 首次适配(first fit)。内存管理器会沿着段列表进行扫描，直到找个一个足够大的空闲区为止。 除非空闲区大小和要分配的空间大小一样，否则将空闲区分为两部分，一部分供进程使用；一部分生成新的空闲区。首次适配算法是一种速度很快的算法，因为它会尽可能的搜索链表。</p><p>首次适配的一个小的变体是 下次适配(next fit)。它和首次匹配的工作方式相同，只有一个不同之处那就是下次适配在每次找到合适的空闲区时就会记录当时的位置，以便下次寻找空闲区时从上次结束的地方开始搜索，而不是像首次匹配算法那样每次都会从头开始搜索。</p><p>另外一个著名的并且广泛使用的算法是 最佳适配(best fit)。最佳适配会从头到尾寻找整个链表，找出能够容纳进程的最小空闲区。</p><h2>虚拟内存</h2><p>尽管基址寄存器和变址寄存器用来创建地址空间的抽象，但是这有一个其他的问题需要解决：管理软件的不断增大(managing bloatware)。虚拟内存的基本思想是，每个程序都有自己的地址空间，这个地址空间被划分为多个称为页面(page)的块。每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。</p><h3>分页</h3><p>大部分使用虚拟内存的系统中都会使用一种 分页(paging) 技术。在任何一台计算机上，程序会引用使用一组内存地址。当程序执行</p><p>MOV REG,1000</p><p>这条指令时，它会把内存地址为 1000 的内存单元的内容复制到 REG 中（或者相反，这取决于计算机）。地址可以通过索引、基址寄存器、段寄存器或其他方式产生。</p><p>这些程序生成的地址被称为 虚拟地址(virtual addresses) 并形成虚拟地址空间(virtual address space)，在没有虚拟内存的计算机上，系统直接将虚拟地址送到内存中线上，读写操作都使用同样地址的物理内存。<strong>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上</strong>。相反，会使用 MMU(Memory Management Unit) 内存管理单元把<strong>虚拟地址映射为物理内存地址</strong>，像下图这样</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4134993dd1ca403aa77860dec4bcd797></p><p>下面这幅图展示了这种映射是如何工作的</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c18a75e781944ad1855cada7e469f0ed></p><p>页表给出虚拟地址与物理内存地址之间的映射关系。每一页起始于 4096 的倍数位置，结束于 4095 的位置，所以 4K 到 8K 实际为 4096 - 8191 ，8K - 12K 就是 8192 - 12287</p><p>在这个例子中，我们可能有一个 16 位地址的计算机，地址从 0 - 64 K - 1，这些是虚拟地址。然而只有 32 KB 的物理地址。所以虽然可以编写 64 KB 的程序，但是程序无法全部调入内存运行，在磁盘上必须有一个最多 64 KB 的程序核心映像的完整副本，以保证程序片段在需要时被调入内存。</p><h3>页表</h3><p>虚拟页号可作为页表的索引用来找到虚拟页中的内容。由页表项可以找到页框号（如果有的话）。然后把页框号拼接到偏移量的高位端，以替换掉虚拟页号，形成物理地址。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ff1abf50d9214edf8e172d1c1696ad47></p><p>因此，页表的目的是把虚拟页映射到页框中。从数学上说，页表是一个函数，它的参数是虚拟页号，结果是物理页框号。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81e798cbe5c14c1aa1dc9778d982a1a9></p><p>通过这个函数可以把虚拟地址中的虚拟页转换为页框，从而形成物理地址。</p><h4>页表项的结构</h4><p>下面我们探讨一下页表项的具体结构，上面你知道了页表项的大致构成，是由页框号和在/不在位构成的，现在我们来具体探讨一下页表项的构成</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af10b735a77d4e36a15b4dc436f243b0></p><p>页表项的结构是与机器相关的，但是不同机器上的页表项大致相同。上面是一个页表项的构成，不同计算机的页表项可能不同，但是一般来说都是 32 位的。页表项中最重要的字段就是页框号(Page frame number)。毕竟，页表到页框最重要的一步操作就是要把此值映射过去。下一个比较重要的就是在/不在位，如果此位上的值是 1，那么页表项是有效的并且能够被使用。如果此值是 0 的话，则表示该页表项对应的虚拟页面不在内存中，访问该页面会引起一个缺页异常(page fault)。</p><p>保护位(Protection) 告诉我们哪一种访问是允许的，啥意思呢？最简单的表示形式是这个域只有一位，<strong>0 表示可读可写，1 表示的是只读</strong>。</p><p>修改位(Modified) 和 访问位(Referenced) 会跟踪页面的使用情况。当一个页面被写入时，硬件会自动的设置修改位。修改位在页面重新分配页框时很有用。如果一个页面已经被修改过（即它是 脏 的），则必须把它写回磁盘。如果一个页面没有被修改过（即它是 干净的），那么重新分配时这个页框会被直接丢弃，因为磁盘上的副本仍然是有效的。这个位有时也叫做 脏位(dirty bit)，因为它反映了页面的状态。</p><p>访问位(Referenced) 在页面被访问时被设置，不管是读还是写。这个值能够帮助操作系统在发生缺页中断时选择要淘汰的页。不再使用的页要比正在使用的页更适合被淘汰。这个位在后面要讨论的页面置换算法中作用很大。</p><p>最后一位用于禁止该页面被高速缓存，这个功能对于映射到设备寄存器还是内存中起到了关键作用。通过这一位可以禁用高速缓存。具有独立的 I/O 空间而不是用内存映射 I/O 的机器来说，并不需要这一位。</p><h2>页面置换算法</h2><p>下面我们就来探讨一下有哪些页面置换算法。</p><h3>最优页面置换算法</h3><p>最优的页面置换算法的工作流程如下：在缺页中断发生时，这些页面之一将在下一条指令（包含该指令的页面）上被引用。其他页面则可能要到 10、100 或者 1000 条指令后才会被访问。每个页面都可以用在该页首次被访问前所要执行的指令数作为标记。</p><p>最优化的页面算法表明应该标记最大的页面。如果一个页面在 800 万条指令内不会被使用，另外一个页面在 600 万条指令内不会被使用，则置换前一个页面，从而把需要调入这个页面而发生的缺页中断推迟。计算机也像人类一样，会把不愿意做的事情尽可能的往后拖。</p><p>这个算法最大的问题时无法实现。当缺页中断发生时，操作系统无法知道各个页面的下一次将在什么时候被访问。这种算法在实际过程中根本不会使用。</p><h3>最近未使用页面置换算法</h3><p>为了能够让操作系统收集页面使用信息，大部分使用虚拟地址的计算机都有两个状态位，R 和 M，来和每个页面进行关联。<strong>每当引用页面（读入或写入）时都设置 R，写入（即修改）页面时设置 M</strong>，这些位包含在每个页表项中，就像下面所示</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/465e443916a74425b1eb696dc800a11d></p><p>因为每次访问时都会更新这些位，因此由硬件来设置它们非常重要。一旦某个位被设置为 1，就会一直保持 1 直到操作系统下次来修改此位。</p><p>如果硬件没有这些位，那么可以使用操作系统的缺页中断和时钟中断机制来进行模拟。当启动一个进程时，将其所有的页面都标记为不在内存；一旦访问任何一个页面就会引发一次缺页中断，此时操作系统就可以设置 R 位(在它的内部表中)，修改页表项使其指向正确的页面，并设置为 READ ONLY 模式，然后重新启动引起缺页中断的指令。如果页面随后被修改，就会发生另一个缺页异常。从而允许操作系统设置 M 位并把页面的模式设置为 READ/WRITE。</p><p>可以用 R 位和 M 位来构造一个简单的页面置换算法：当启动一个进程时，操作系统将其所有页面的两个位都设置为 0。R 位定期的被清零（在每个时钟中断）。用来将最近未引用的页面和已引用的页面分开。</p><p>当出现缺页中断后，操作系统会检查所有的页面，并根据它们的 R 位和 M 位将当前值分为四类：</p><ul><li>第 0 类：没有引用 R，没有修改 M</li><li>第 1 类：没有引用 R，已修改 M</li><li>第 2 类：引用 R ，没有修改 M</li><li>第 3 类：已被访问 R，已被修改 M</li></ul><p>尽管看起来好像无法实现第一类页面，但是当第三类页面的 R 位被时钟中断清除时，它们就会发生。时钟中断不会清除 M 位，因为需要这个信息才能知道是否写回磁盘中。清除 R 但不清除 M 会导致出现一类页面。</p><p>NRU(Not Recently Used) 算法从编号最小的非空类中随机删除一个页面。此算法隐含的思想是，在一个时钟内（约 20 ms）淘汰一个已修改但是没有被访问的页面要比一个大量引用的未修改页面好，NRU 的主要优点是<strong>易于理解并且能够有效的实现</strong>。</p><h3>先进先出页面置换算法</h3><p>另一种开销较小的方式是使用 FIFO(First-In,First-Out) 算法，这种类型的数据结构也适用在页面置换算法中。由操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。在发生缺页异常时，会把头部的页移除并且把新的页添加到表尾。</p><h3>第二次机会页面置换算法</h3><p>我们上面学到的 FIFO 链表页面有个缺陷，那就是出链和入链并不会进行 check 检查，这样就会容易把经常使用的页面置换出去，为了避免这一问题，我们对该算法做一个简单的修改：我们检查最老页面的 R 位，如果是 0 ，那么这个页面就是最老的而且没有被使用，那么这个页面就会被立刻换出。如果 R 位是 1，那么就清除此位，此页面会被放在链表的尾部，修改它的装入时间就像刚放进来的一样。然后继续搜索。</p><p>这种算法叫做 第二次机会(second chance)算法，就像下面这样，我们看到页面 A 到 H 保留在链表中，并按到达内存的时间排序。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f89e0afcb34a44f3b363e43ebc596933></p><p>a）按照先进先出的方法排列的页面；b）在时刻 20 处发生缺页异常中断并且 A 的 R 位已经设置时的页面链表。</p><p>假设缺页异常发生在时刻 20 处，这时最老的页面是 A ，它是在 0 时刻到达的。如果 A 的 R 位是 0，那么它将被淘汰出内存，或者把它写回磁盘（如果它已经被修改过），或者只是简单的放弃（如果它是未被修改过）。另一方面，如果它的 R 位已经设置了，则将 A 放到链表的尾部并且重新设置装入时间为当前时刻（20 处），然后清除 R 位。然后从 B 页面开始继续搜索合适的页面。</p><p>寻找第二次机会的是在最近的时钟间隔中未被访问过的页面。如果所有的页面都被访问过，该算法就会被简化为单纯的 FIFO 算法。具体来说，假设图 a 中所有页面都设置了 R 位。操作系统将页面依次移到链表末尾，每次都在添加到末尾时清除 R 位。最后，算法又会回到页面 A，此时的 R 位已经被清除，那么页面 A 就会被执行出链处理，因此算法能够正常结束。</p><h3>时钟页面置换算法</h3><p>一种比较好的方式是把所有的页面都保存在一个类似钟面的环形链表中，一个表针指向最老的页面。如下图所示</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc59316ed3b145679636a19487f4a270></p><p>当缺页错误出现时，算法首先检查表针指向的页面，如果它的 R 位是 0 就淘汰该页面，并把新的页面插入到这个位置，然后把表针向前移动一位；如果 R 位是 1 就清除 R 位并把表针前移一个位置。重复这个过程直到找到了一个 R 位为 0 的页面位置。了解这个算法的工作方式，就明白为什么它被称为 时钟(clokc)算法了。</p><h3>最近最少使用页面置换算法</h3><p>在前面几条指令中频繁使用的页面和可能在后面的几条指令中被使用。反过来说，已经很久没有使用的页面有可能在未来一段时间内仍不会被使用。这个思想揭示了一个可以实现的算法：在缺页中断时，置换未使用时间最长的页面。这个策略称为 LRU(Least Recently Used) ，最近最少使用页面置换算法。</p><p>虽然 LRU 在理论上是可以实现的，但是从长远看来代价比较高。为了完全实现 LRU，会在内存中维护一个所有页面的链表，最频繁使用的页位于表头，最近最少使用的页位于表尾。困难的是在每次内存引用时更新整个链表。在链表中找到一个页面，删除它，然后把它移动到表头是一个非常耗时的操作，即使使用硬件来实现也是一样的费时。</p><h3>用软件模拟 LRU</h3><p>尽管上面的 LRU 算法在原则上是可以实现的，<strong>但是很少有机器能够拥有那些特殊的硬件</strong>。上面是硬件的实现方式，那么现在考虑要用软件来实现 LRU 。一种可以实现的方案是 NFU(Not Frequently Used，最不常用)算法。它需要一个软件计数器来和每个页面关联，初始化的时候是 0 。在每个时钟中断时，操作系统会浏览内存中的所有页，会将每个页面的 R 位（0 或 1）加到它的计数器上。这个计数器大体上跟踪了各个页面访问的频繁程度。当缺页异常出现时，则置换计数器值最小的页面。</p><p>只需要对 NFU 做一个简单的修改就可以让它模拟 LRU，这个修改有两个步骤</p><ul><li>首先，在 R 位被添加进来之前先把计数器右移一位；</li><li>第二步，R 位被添加到最左边的位而不是最右边的位。</li></ul><p>修改以后的算法称为 老化(aging) 算法，下图解释了老化算法是如何工作的。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bdccc7c258c044a78dac8501c7d485db></p><p>我们假设在第一个时钟周期内页面 0 - 5 的 R 位依次是 1，0，1，0，1，1，（也就是页面 0 是 1，页面 1 是 0，页面 2 是 1 这样类推）。也就是说，<strong>在 0 个时钟周期到 1 个时钟周期之间，0，2，4，5 都被引用了</strong>，从而把它们的 R 位设置为 1，剩下的设置为 0 。在相关的六个计数器被右移之后 R 位被添加到 左侧 ，就像上图中的 a。剩下的四列显示了接下来的四个时钟周期内的六个计数器变化。</p><blockquote><p>CPU正在以某个频率前进，该频率的周期称为时钟滴答或时钟周期。一个 100Mhz 的处理器每秒将接收100,000,000个时钟滴答。</p></blockquote><p>当缺页异常出现时，将置换（就是移除）计数器值最小的页面。如果一个页面在前面 4 个时钟周期内都没有被访问过，那么它的计数器应该会有四个连续的 0 ，因此它的值肯定要比前面 3 个时钟周期内都没有被访问过的页面的计数器小。</p><p>这个算法与 LRU 算法有两个重要的区别：看一下上图中的 e，第三列和第五列</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebf68175f87347c198ecb9cd42964f67></p><h3>工作集时钟页面置换算法</h3><p>当缺页异常发生后，需要扫描整个页表才能确定被淘汰的页面，因此基本工作集算法还是比较浪费时间的。一个对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息，这种算法称为WSClock(工作集时钟)。由于它的实现简单并且具有高性能，因此在实践中被广泛应用。</p><p>与时钟算法一样，所需的数据结构是一个以页框为元素的循环列表，就像下面这样</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa76676b35da40b499e33c6fafdd2290></p><p>工作集时钟页面置换算法的操作：a) 和 b) 给出 R = 1 时所发生的情形；c) 和 d) 给出 R = 0 的例子</p><p>最初的时候，该表是空的。当装入第一个页面后，把它加载到该表中。随着更多的页面的加入，它们形成一个环形结构。每个表项包含来自基本工作集算法的上次使用时间，以及 R 位（已标明）和 M 位（未标明）。</p><p>与时钟算法一样，在每个缺页异常时，首先检查指针指向的页面。如果 R 位被是设置为 1，该页面在当前时钟周期内就被使用过，那么该页面就不适合被淘汰。然后把该页面的 R 位置为 0，指针指向下一个页面，并重复该算法。该事件序列化后的状态参见图 b。</p><p>现在考虑指针指向的页面 R = 0 时会发生什么，参见图 c，如果页面的使用期限大于 t 并且页面为被访问过，那么这个页面就不会在工作集中，并且在磁盘上会有一个此页面的副本。申请重新调入一个新的页面，并把新的页面放在其中，如图 d 所示。另一方面，如果页面被修改过，就不能重新申请页面，因为这个页面在磁盘上没有有效的副本。为了避免由于调度写磁盘操作引起的进程切换，指针继续向前走，算法继续对下一个页面进行操作。毕竟，有可能存在一个老的，没有被修改过的页面可以立即使用。</p><p>原则上来说，所有的页面都有可能因为磁盘I/O 在某个时钟周期内被调度。为了降低磁盘阻塞，需要设置一个限制，即最大只允许写回 n 个页面。一旦达到该限制，就不允许调度新的写操作。</p><p>那么就有个问题，指针会绕一圈回到原点的，如果回到原点，它的起始点会发生什么？这里有两种情况：</p><ul><li>至少调度了一次写操作</li><li>没有调度过写操作</li></ul><p>在第一种情况中，指针仅仅是不停的移动，寻找一个未被修改过的页面。由于已经调度了一个或者多个写操作，最终会有某个写操作完成，它的页面会被标记为未修改。置换遇到的第一个未被修改过的页面，这个页面不一定是第一个被调度写操作的页面，因为硬盘驱动程序为了优化性能可能会把写操作重排序。</p><p>对于第二种情况，所有的页面都在工作集中，否则将至少调度了一个写操作。由于缺乏额外的信息，最简单的方法就是置换一个未被修改的页面来使用，扫描中需要记录未被修改的页面的位置，如果不存在未被修改的页面，就选定当前页面并把它写回磁盘。</p><h3>页面置换算法小结</h3><p>我们到现在已经研究了各种页面置换算法，现在我们来一个简单的总结，算法的总结归纳如下</p><p>算法注释最优算法不可实现，但可以用作基准NRU(最近未使用) 算法和 LRU 算法很相似FIFO(先进先出) 算法有可能会抛弃重要的页面第二次机会算法比 FIFO 有较大的改善时钟算法实际使用LRU(最近最少)算法比较优秀，但是很难实现NFU(最不经常食用)算法和 LRU 很类似老化算法近似 LRU 的高效算法工作集算法实施起来开销很大工作集时钟算法比较有效的算法</p><ul><li><p>最优算法在当前页面中置换最后要访问的页面。不幸的是，没有办法来判定哪个页面是最后一个要访问的，因此实际上该算法不能使用。然而，它可以作为衡量其他算法的标准。</p></li><li><p>NRU 算法根据 R 位和 M 位的状态将页面氛围四类。从编号最小的类别中随机选择一个页面。NRU 算法易于实现，但是性能不是很好。存在更好的算法。</p></li><li><p>FIFO 会跟踪页面加载进入内存中的顺序，并把页面放入一个链表中。有可能删除存在时间最长但是还在使用的页面，因此这个算法也不是一个很好的选择。</p></li><li><p>第二次机会算法是对 FIFO 的一个修改，它会在删除页面之前检查这个页面是否仍在使用。如果页面正在使用，就会进行保留。这个改进大大提高了性能。</p></li><li><p>时钟 算法是第二次机会算法的另外一种实现形式，时钟算法和第二次算法的性能差不多，但是会花费更少的时间来执行算法。</p></li><li><p>LRU 算法是一个非常优秀的算法，但是没有特殊的硬件(TLB)很难实现。如果没有硬件，就不能使用 LRU 算法。</p></li><li><p>NFU 算法是一种近似于 LRU 的算法，它的性能不是非常好。</p></li><li><p>老化 算法是一种更接近 LRU 算法的实现，并且可以更好的实现，因此是一个很好的选择</p></li><li><p>最后两种算法都使用了工作集算法。工作集算法提供了合理的性能开销，但是它的实现比较复杂。WSClock 是另外一种变体，它不仅能够提供良好的性能，而且可以高效地实现。</p></li></ul><p>总之，<strong>最好的算法是老化算法和WSClock算法</strong>。他们分别是基于 LRU 和工作集算法。他们都具有良好的性能并且能够被有效的实现。还存在其他一些好的算法，但实际上这两个可能是最重要的。</p><p>下面来聊一聊文件系统，你需要知道下面这些知识点</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8783a883a02b4772a5b2ae5b0b2f0672></p><h2>文件</h2><h3>文件命名</h3><p>文件是一种抽象机制，它提供了一种方式用来存储信息以及在后面进行读取。可能任何一种机制最重要的特性就是管理对象的命名方式。在创建一个文件后，它会给文件一个命名。当进程终止时，文件会继续存在，并且其他进程可以使用名称访问该文件。</p><p>文件命名规则对于不同的操作系统来说是不一样的，但是所有现代操作系统都允许使用 1 - 8 个字母的字符串作为合法文件名。</p><p>某些文件区分大小写字母，而大多数则不区分。UNIX 属于第一类；历史悠久的 MS-DOS 属于第二类（顺便说一句，尽管 MS-DOS 历史悠久，但 MS-DOS 仍在嵌入式系统中非常广泛地使用，因此它绝不是过时的）；因此，UNIX 系统会有三种不同的命名文件：maria、Maria、MARIA 。在 MS-DOS ，所有这些命名都属于相同的文件。</p><p><img alt="5万字、97 张图总结操作系统核心知识点(上)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a6e9511ee8b41e3afe48a909912893e></p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'万字','97','张图'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/aafa7dc.html alt="5万字、97 张图总结操作系统核心知识点(下)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c3b64f421acc45b2a147aa814c139b48 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/aafa7dc.html title="5万字、97 张图总结操作系统核心知识点(下)">5万字、97 张图总结操作系统核心知识点(下)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>