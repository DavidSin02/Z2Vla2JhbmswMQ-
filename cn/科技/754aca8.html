<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus | 极客快訊</title><meta property="og:title" content="Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/153260587912802d119c482"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/754aca8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/754aca8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/754aca8.html><meta property="article:published_time" content="2020-10-29T21:04:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/754aca8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>背景</strong></p><p>对于Android系统来说，消息传递是最基本的组件，每一个App内的不同页面，不同组件都在进行消息传递。消息传递既可以用于Android四大组件之间的通信，也可用于异步线程和主线程之间的通信。对于Android开发者来说，经常使用的消息传递方式有很多种，从最早使用的Handler、BroadcastReceiver、接口回调，到近几年流行的通信总线类框架EventBus、RxBus。Android消息传递框架，总在不断的演进之中。</p><p><strong>从EventBus说起</strong></p><p>EventBus是一个Android事件发布/订阅框架，通过解耦发布者和订阅者简化Android事件传递。EventBus可以代替Android传统的Intent、Handler、Broadcast或接口回调，在Fragment、Activity、Service线程之间传递数据，执行方法。</p><p>EventBus最大的特点就是简洁、解耦。在没有EventBus之前我们通常用广播来实现监听，或者自定义接口函数回调，有的场景我们也可以直接用Intent携带简单数据，或者在线程之间通过Handler处理消息传递。但无论是广播还是Handler机制远远不能满足我们高效的开发。EventBus简化了应用程序内各组件间、组件与后台线程间的通信。EventBus一经推出，便受到广大开发者的推崇。</p><p>现在看来，EventBus给Android开发者世界带来了一种新的框架和思想，就是消息的发布和订阅。这种思想在其后很多框架中都得到了应用。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153260587912802d119c482><p class=pgc-img-caption></p></div><p>图片摘自EventBus GitHub主页</p><p><strong>发布/订阅模式</strong></p><p>订阅发布模式定义了一种“一对多”的依赖关系，让多个订阅者对象同时监听某一个主题对象。这个主题对象在自身状态变化时，会通知所有订阅者对象，使它们能够自动更新自己的状态。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1532605879208bb17a1c8b4><p class=pgc-img-caption></p></div><p><strong>RxBus的出现</strong></p><p>RxBus不是一个库，而是一个文件，实现只有短短30行代码。RxBus本身不需要过多分析，它的强大完全来自于它基于的RxJava技术。响应式编程（Reactive Programming）技术这几年特别火，RxJava是它在Java上的实作。RxJava天生就是发布/订阅模式，而且很容易处理线程切换。所以，RxBus凭借区区30行代码，就敢挑战EventBus“江湖老大”的地位。</p><p><strong>RxBus原理</strong></p><p>在RxJava中有个Subject类，它继承Observable类，同时实现了Observer接口，因此Subject可以同时担当订阅者和被订阅者的角色，我们使用Subject的子类PublishSubject来创建一个Subject对象（PublishSubject只有被订阅后才会把接收到的事件立刻发送给订阅者），在需要接收事件的地方，订阅该Subject对象，之后如果Subject对象接收到事件，则会发射给该订阅者，此时Subject对象充当被订阅者的角色。</p><p>完成了订阅，在需要发送事件的地方将事件发送给之前被订阅的Subject对象，则此时Subject对象作为订阅者接收事件，然后会立刻将事件转发给订阅该Subject对象的订阅者，以便订阅者处理相应事件，到这里就完成了事件的发送与处理。</p><p>最后就是取消订阅的操作了，RxJava中，订阅操作会返回一个Subscription对象，以便在合适的时机取消订阅，防止内存泄漏，如果一个类产生多个Subscription对象，我们可以用一个CompositeSubscription存储起来，以进行批量的取消订阅。</p><p><strong>RxBus有很多实现，如：</strong></p><blockquote><p>AndroidKnife/RxBus（https://github.com/AndroidKnife/RxBus）</p><p>Blankj/RxBus（https://github.com/Blankj/RxBus）</p></blockquote><p>其实正如前面所说的，RxBus的原理是如此简单，我们自己都可以写出一个RxBus的实现：</p><p><strong>基于RxJava1的RxBus实现：</strong></p><blockquote><p>public final class RxBus {</p><p>private final Subject&lt;Object, Object> bus;</p><p>private RxBus() {</p><p>bus = new SerializedSubject&lt;>(PublishSubject.create());</p><p>}</p><p>private static class SingletonHolder {</p><p>private static final RxBus defaultRxBus = new RxBus();</p><p>}</p><p>public static RxBus getInstance() {</p><p>return SingletonHolder.defaultRxBus;</p><p>}</p><p>/*</p><p>* 发送</p><p>*/</p><p>public void post(Object o) {</p><p>bus.onNext(o);</p><p>}</p><p>/*</p><p>* 是否有Observable订阅</p><p>*/</p><p>public boolean hasObservable() {</p><p>return bus.hasObservers();</p><p>}</p><p>/*</p><p>* 转换为特定类型的Obserbale</p><p>*/</p><p>public &lt;T> Observable&lt;T> toObservable(Class&lt;T> type) {</p><p>return bus.ofType(type);</p><p>}</p><p>}</p></blockquote><p><strong>基于RxJava2的RxBus实现：</strong></p><blockquote><p>public final class RxBus2 {</p><p>private final Subject&lt;Object> bus;</p><p>private RxBus2() {</p><p>// toSerialized method made bus thread safe</p><p>bus = PublishSubject.create().toSerialized();</p><p>}</p><p>public static RxBus2 getInstance() {</p><p>return Holder.BUS;</p><p>}</p><p>private static class Holder {</p><p>private static final RxBus2 BUS = new RxBus2();</p><p>}</p><p>public void post(Object obj) {</p><p>bus.onNext(obj);</p><p>}</p><p>public &lt;T> Observable&lt;T> toObservable(Class&lt;T> tClass) {</p><p>return bus.ofType(tClass);</p><p>}</p><p>public Observable&lt;Object> toObservable() {</p><p>return bus;</p><p>}</p><p>public boolean hasObservers() {</p><p>return bus.hasObservers();</p><p>}</p><p>}</p></blockquote><p><strong>引入LiveDataBus的想法</strong></p><p><strong>从LiveData谈起</strong></p><p>LiveData是Android Architecture Components提出的框架。LiveData是一个可以被观察的数据持有类，它可以感知并遵循Activity、Fragment或Service等组件的生命周期。正是由于LiveData对组件生命周期可感知特点，因此可以做到仅在组件处于生命周期的激活状态时才更新UI数据。</p><p>LiveData需要一个观察者对象，一般是Observer类的具体实现。当观察者的生命周期处于STARTED或RESUMED状态时，LiveData会通知观察者数据变化；在观察者处于其他状态时，即使LiveData的数据变化了，也不会通知。</p><p><strong>LiveData的优点</strong></p><ul><li><strong>UI和实时数据保持一致，</strong>因为LiveData采用的是观察者模式，这样一来就可以在数据发生改变时获得通知，更新UI。</li><li><strong>避免内存泄漏，</strong>观察者被绑定到组件的生命周期上，当被绑定的组件销毁（destroy）时，观察者会立刻自动清理自身的数据。</li><li><strong>不会再产生由于Activity处于stop状态而引起的崩溃，</strong>例如：当Activity处于后台状态时，是不会收到LiveData的任何事件的。</li><li><strong>不需要再解决生命周期带来的问题，</strong>LiveData可以感知被绑定的组件的生命周期，只有在活跃状态才会通知数据变化。</li><li><strong>实时数据刷新，</strong>当组件处于活跃状态或者从不活跃状态到活跃状态时总是能收到最新的数据。</li><li><strong>解决Configuration Change问题，</strong>在屏幕发生旋转或者被回收再次启动，立刻就能收到最新的数据。</li></ul><p>谈一谈Android Architecture Components</p><p>Android Architecture Components的核心是Lifecycle、LiveData、ViewModel 以及 Room，通过它可以非常优雅的让数据与界面进行交互，并做一些持久化的操作，高度解耦，自动管理生命周期，而且不用担心内存泄漏的问题。</p><ul><li><strong>Room</strong></li><li>一个强大的SQLite对象映射库。</li><li><strong>ViewModel</strong></li><li>一类对象，它用于为UI组件提供数据，在设备配置发生变更时依旧可以存活。</li><li><strong>LiveData</strong> 一个可感知生命周期、可被观察的数据容器，它可以存储数据，还会在数据发生改变时进行提醒。</li><li><strong>Lifecycle</strong></li><li>包含LifeCycleOwer和LifecycleObserver，分别是生命周期所有者和生命周期感知者。</li></ul><p><strong>Android Architecture Components的特点</strong></p><ul><li><strong>数据驱动型编程</strong></li><li>变化的永远是数据，界面无需更改。</li><li><strong>感知生命周期，防止内存泄漏</strong></li><li><strong>高度解耦</strong></li><li>数据，界面高度分离。</li><li><strong>数据持久化</strong></li><li>数据、ViewModel不与 UI的生命周期挂钩，不会因为界面的重建而销毁。</li></ul><p><strong>重点：为什么使用LiveData构建数据通信总线LiveDataBus</strong></p><p><strong>使用LiveData的理由</strong></p><ul><li><strong>LiveData具有的这种可观察性和生命周期感知的能力，使其非常适合作为Android通信总线的基础构件。</strong></li><li><strong>使用者不用显示调用反注册方法。</strong></li><li>由于LiveData具有生命周期感知能力，所以LiveDataBus只需要调用注册回调方法，而不需要显示的调用反注册方法。这样带来的好处不仅可以编写更少的代码，而且可以完全杜绝其他通信总线类框架（如EventBus、RxBus）忘记调用反注册所带来的内存泄漏的风险。</li></ul><p><strong>为什么要用LiveDataBus替代EventBus和RxBus</strong></p><ul><li><strong>LiveDataBus的实现及其简单</strong>，相对EventBus复杂的实现，LiveDataBus只需要一个类就可以实现。</li><li><strong>LiveDataBus可以减小APK包的大小</strong>，由于LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，没有其他依赖，本身实现只有一个类。作为比较，EventBus JAR包大小为57kb，RxBus依赖RxJava和RxAndroid，其中RxJava2包大小2.2MB，RxJava1包大小1.1MB，RxAndroid包大小9kb。使用LiveDataBus可以大大减小APK包的大小。</li><li><strong>LiveDataBus依赖方支持更好</strong>，LiveDataBus只依赖Android官方Android Architecture Components组件的LiveData，相比RxBus依赖的RxJava和RxAndroid，依赖方支持更好。</li><li><strong>LiveDataBus具有生命周期感知</strong>，LiveDataBus具有生命周期感知，在Android系统中使用调用者不需要调用反注册，相比EventBus和RxBus使用更为方便，并且没有内存泄漏风险。</li></ul><p><strong>LiveDataBus的设计和架构</strong></p><p><strong>LiveDataBus的组成</strong></p><ul><li><strong>消息</strong></li><li>消息可以是任何的Object，可以定义不同类型的消息，如Boolean、String。也可以定义自定义类型的消息。</li><li><strong>消息通道</strong></li><li>LiveData扮演了消息通道的角色，不同的消息通道用不同的名字区分，名字是String类型的，可以通过名字获取到一个LiveData消息通道。</li><li><strong>消息总线</strong></li><li>消息总线通过单例实现，不同的消息通道存放在一个HashMap中。</li><li><strong>订阅</strong></li><li>订阅者通过getChannel获取消息通道，然后调用observe订阅这个通道的消息。</li><li><strong>发布</strong></li><li>发布者通过getChannel获取消息通道，然后调用setValue或者postValue发布消息。</li></ul><p><strong>LiveDataBus原理图</strong></p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1532605879297c275574cb1><p class=pgc-img-caption></p></div><p><strong>LiveDataBus的实现</strong></p><p><strong>第一个实现：</strong></p><blockquote><p>public final class LiveDataBus {</p><p>private final Map&lt;String, MutableLiveData&lt;Object>> bus;</p><p>private LiveDataBus() {</p><p>bus = new HashMap&lt;>();</p><p>}</p><p>private static class SingletonHolder {</p><p>private static final LiveDataBus DATA_BUS = new LiveDataBus();</p><p>}</p><p>public static LiveDataBus get() {</p><p>return SingletonHolder.DATA_BUS;</p><p>}</p><p>public &lt;T> MutableLiveData&lt;T> getChannel(String target, Class&lt;T> type) {</p><p>if (!bus.containsKey(target)) {</p><p>bus.put(target, new MutableLiveData&lt;>());</p><p>}</p><p>return (MutableLiveData&lt;T>) bus.get(target);</p><p>}</p><p>public MutableLiveData&lt;Object> getChannel(String target) {</p><p>return getChannel(target, Object.class);</p><p>}</p><p>}</p></blockquote><p>短短二十行代码，就实现了一个通信总线的全部功能，并且还具有生命周期感知功能，并且使用起来也及其简单：</p><p><strong>注册订阅：</strong></p><blockquote><p>LiveDataBus.get().getChannel("key_test", Boolean.class)</p><p>.observe(this, new Observer&lt;Boolean>() {</p><p>@Override</p><p>public void onChanged(@Nullable Boolean aBoolean) {</p><p>}</p><p>});</p></blockquote><p><strong>发送消息：</strong></p><blockquote><p>LiveDataBus.get().getChannel("key_test").setValue(true);</p></blockquote><p>我们发送了一个名为"key_test"，值为true的事件。</p><p>这个时候订阅者就会收到消息，并作相应的处理，非常简单。</p><p><strong>问题出现</strong></p><p>对于LiveDataBus的第一版实现，我们发现，在使用这个LiveDataBus的过程中，订阅者会收到订阅之前发布的消息。对于一个消息总线来说，这是不可接受的。无论EventBus或者RxBus，订阅方都不会收到订阅之前发出的消息。对于一个消息总线，LiveDataBus必须要解决这个问题。</p><p><strong>问题分析</strong></p><p>怎么解决这个问题呢？先分析下原因：</p><p>当LifeCircleOwner的状态发生变化的时候，会调用LiveData.ObserverWrapper的activeStateChanged函数，如果这个时候ObserverWrapper的状态是active，就会调用LiveData的dispatchingValue。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15326058791517f12641571><p class=pgc-img-caption></p></div><p>在LiveData的dispatchingValue中，又会调用LiveData的considerNotify方法。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15326058792210910f8b537><p class=pgc-img-caption></p></div><p>在LiveData的considerNotify方法中，红框中的逻辑是关键，如果ObserverWrapper的mLastVersion小于LiveData的mVersion，就会去回调mObserver的onChanged方法。而每个新的订阅者，其version都是-1，LiveData一旦设置过其version是大于-1的（每次LiveData设置值都会使其version加1），这样就会导致LiveDataBus每注册一个新的订阅者，这个订阅者立刻会收到一个回调，即使这个设置的动作发生在订阅之前。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/153260587914599287f92a0><p class=pgc-img-caption></p></div><p><strong>问题原因总结</strong></p><p>对于这个问题，总结一下发生的核心原因。对于LiveData，其初始的version是-1，当我们调用了其setValue或者postValue，其vesion会+1；对于每一个观察者的封装ObserverWrapper，其初始version也为-1，也就是说，每一个新注册的观察者，其version为-1；当LiveData设置这个ObserverWrapper的时候，如果LiveData的version大于ObserverWrapper的version，LiveData就会强制把当前value推送给Observer。</p><p><strong>如何解决这个问题</strong></p><p>明白了问题产生的原因之后，我们来看看怎么才能解决这个问题。很显然，根据之前的分析，只需要在注册一个新的订阅者的时候把Wrapper的version设置成跟LiveData的version一致即可。</p><p>那么怎么实现呢，看看LiveData的observe方法，他会在步骤1创建一个LifecycleBoundObserver，LifecycleBoundObserver是ObserverWrapper的派生类。然后会在步骤2把这个LifecycleBoundObserver放入一个私有Map容器mObservers中。无论ObserverWrapper还是LifecycleBoundObserver都是私有的或者包可见的，所以无法通过继承的方式更改LifecycleBoundObserver的version。</p><p>那么能不能从Map容器mObservers中取到LifecycleBoundObserver，然后再更改version呢？答案是肯定的，通过查看SafeIterableMap的源码我们发现有一个protected的get方法。因此，在调用observe的时候，我们可以通过反射拿到LifecycleBoundObserver，再把LifecycleBoundObserver的version设置成和LiveData一致即可。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153260587956410d5916b87><p class=pgc-img-caption></p></div><p>对于非生命周期感知的observeForever方法来说，实现的思路是一致的，但是具体的实现略有不同。observeForever的时候，生成的wrapper不是LifecycleBoundObserver，而是AlwaysActiveObserver（步骤1），而且我们也没有机会在observeForever调用完成之后再去更改AlwaysActiveObserver的version，因为在observeForever方法体内，步骤3的语句，回调就发生了。</p><div class=pgc-img><img alt=Android消息总线的演进之路：用LiveDataBus替代RxBus、EventBus onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1532605879463daf62b18de><p class=pgc-img-caption></p></div><p>那么对于observeForever，如何解决这个问题呢？既然是在调用内回调的，那么我们可以写一个ObserverWrapper，把真正的回调给包装起来。把ObserverWrapper传给observeForever，那么在回调的时候我们去检查调用栈，如果回调是observeForever方法引起的，那么就不回调真正的订阅者。</p><p><strong>LiveDataBus最终实现</strong></p><blockquote><p>public final class LiveDataBus {</p><p>private final Map&lt;String, BusMutableLiveData&lt;Object>> bus;</p><p>private LiveDataBus() {</p><p>bus = new HashMap&lt;>();</p><p>}</p><p>private static class SingletonHolder {</p><p>private static final LiveDataBus DEFAULT_BUS = new LiveDataBus();</p><p>}</p><p>public static LiveDataBus get() {</p><p>return SingletonHolder.DEFAULT_BUS;</p><p>}</p><p>public &lt;T> MutableLiveData&lt;T> with(String key, Class&lt;T> type) {</p><p>if (!bus.containsKey(key)) {</p><p>bus.put(key, new BusMutableLiveData&lt;>());</p><p>}</p><p>return (MutableLiveData&lt;T>) bus.get(key);</p><p>}</p><p>public MutableLiveData&lt;Object> with(String key) {</p><p>return with(key, Object.class);</p><p>}</p><p>private static class ObserverWrapper&lt;T> implements Observer&lt;T> {</p><p>private Observer&lt;T> observer;</p><p>public ObserverWrapper(Observer&lt;T> observer) {</p><p>this.observer = observer;</p><p>}</p><p>@Override</p><p>public void onChanged(@Nullable T t) {</p><p>if (observer != null) {</p><p>if (isCallOnObserve()) {</p><p>return;</p><p>}</p><p>observer.onChanged(t);</p><p>}</p><p>}</p><p>private boolean isCallOnObserve() {</p><p>StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();</p><p>if (stackTrace != null && stackTrace.length > 0) {</p><p>for (StackTraceElement element : stackTrace) {</p><p>if ("android.arch.lifecycle.LiveData".equals(element.getClassName()) &&</p><p>"observeForever".equals(element.getMethodName())) {</p><p>return true;</p><p>}</p><p>}</p><p>}</p><p>return false;</p><p>}</p><p>}</p><p>private static class BusMutableLiveData&lt;T> extends MutableLiveData&lt;T> {</p><p>private Map&lt;Observer, Observer> observerMap = new HashMap&lt;>();</p><p>@Override</p><p>public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T> observer) {</p><p>super.observe(owner, observer);</p><p>try {</p><p>hook(observer);</p><p>} catch (Exception e) {</p><p>e.printStackTrace();</p><p>}</p><p>}</p><p>@Override</p><p>public void observeForever(@NonNull Observer&lt;T> observer) {</p><p>if (!observerMap.containsKey(observer)) {</p><p>observerMap.put(observer, new ObserverWrapper(observer));</p><p>}</p><p>super.observeForever(observerMap.get(observer));</p><p>}</p><p>@Override</p><p>public void removeObserver(@NonNull Observer&lt;T> observer) {</p><p>Observer realObserver = null;</p><p>if (observerMap.containsKey(observer)) {</p><p>realObserver = observerMap.remove(observer);</p><p>} else {</p><p>realObserver = observer;</p><p>}</p><p>super.removeObserver(realObserver);</p><p>}</p><p>private void hook(@NonNull Observer&lt;T> observer) throws Exception {</p><p>//get wrapper's version</p><p>Class&lt;LiveData> classLiveData = LiveData.class;</p><p>Field fieldObservers = classLiveData.getDeclaredField("mObservers");</p><p>fieldObservers.setAccessible(true);</p><p>Object objectObservers = fieldObservers.get(this);</p><p>Class&lt;?> classObservers = objectObservers.getClass();</p><p>Method methodGet = classObservers.getDeclaredMethod("get", Object.class);</p><p>methodGet.setAccessible(true);</p><p>Object objectWrapperEntry = methodGet.invoke(objectObservers, observer);</p><p>Object objectWrapper = null;</p><p>if (objectWrapperEntry instanceof Map.Entry) {</p><p>objectWrapper = ((Map.Entry) objectWrapperEntry).getValue();</p><p>}</p><p>if (objectWrapper == null) {</p><p>throw new NullPointerException("Wrapper can not be bull!");</p><p>}</p><p>Class&lt;?> classObserverWrapper = objectWrapper.getClass().getSuperclass();</p><p>Field fieldLastVersion = classObserverWrapper.getDeclaredField("mLastVersion");</p><p>fieldLastVersion.setAccessible(true);</p><p>//get livedata's version</p><p>Field fieldVersion = classLiveData.getDeclaredField("mVersion");</p><p>fieldVersion.setAccessible(true);</p><p>Object objectVersion = fieldVersion.get(this);</p><p>//set wrapper's version</p><p>fieldLastVersion.set(objectWrapper, objectVersion);</p><p>}</p><p>}</p><p>}</p></blockquote><p><strong>注册订阅：</strong></p><blockquote><p>LiveDataBus.get()</p><p>.with("key_test", String.class)</p><p>.observe(this, new Observer&lt;String>() {</p><p>@Override</p><p>public void onChanged(@Nullable String s) {</p><p>}</p><p>});</p></blockquote><p><strong>发送消息：</strong></p><blockquote><p>LiveDataBus.get().with("key_test").setValue(s);</p></blockquote><p><strong>源码说明</strong></p><p>LiveDataBus的源码可以直接拷贝使用，也可以前往作者的GitHub仓库查看下载：</p><blockquote><p>https://github.com/JeremyLiao/LiveDataBus</p></blockquote><p><strong>总结</strong></p><p>本文提供了一个新的消息总线框架——LiveDataBus。订阅者可以订阅某个消息通道的消息，发布者可以把消息发布到消息通道上。利用LiveDataBus，不仅可以实现消息总线功能，而且对于订阅者，他们不需要关心何时取消订阅，极大减少了因为忘记取消订阅造成的内存泄漏风险。</p><p><strong>作者简介</strong></p><p>海亮，美团高级工程师，2017年加入美团，目前主要负责美团轻收银、美团收银零售版等App的相关业务及模块开发工作。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Android','总线','演进'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>