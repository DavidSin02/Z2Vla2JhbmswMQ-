<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ | 极客快訊</title><meta property="og:title" content="IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/af57fda2821d40ac90eed42e840e18ab"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7693935.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7693935.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7693935.html><meta property="article:published_time" content="2020-10-29T20:53:21+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:21+08:00"><meta name=Keywords content><meta name=description content="IM里“附近的人”功能实现原理是什么？如何高效率地实现它？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7693935.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>IM里“附近的人”功能实现原理是什么？如何高效率地实现它？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>本文引用了饿了么资深开发工程师万汨“Redis 到底是怎么实现“附近的人”这个功能的呢？”一文的内容，感谢原作者的分享，为了提升文章品质，即时通讯收录时有内容补充和修订。</p><h1>1、引言</h1><p>基本上以陌生人社交为主的IM产品里，都会增加“附近的人”、“附近的xxx”这种以LBS（地理位置）为导向的产品特色（微信这个熟人社交产品里为啥也有“附近的人”？这当然是历史原因了，微信当初还不是想借此引流嘛。。。），因为“附近的xxx”这种类似功能在产品运营早期，对于种子用户的积累有很大帮助（必竟某种需求，对于人类来说，是上帝赋予的最原始冲动，你懂的...）。<br><strong>比如下图中的几款主流移动端IM中的“附近的xxx”功能：</strong></p><div class=pgc-img><img alt=IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af57fda2821d40ac90eed42e840e18ab><p class=pgc-img-caption></p></div><p>那么，对于很多即时通讯（IM）的开发者初学者来说，“附近的人”或者类似功能，在技术实现上还有点摸不着头脑。本文将简要的为你讲解“附近的人”的基本理论原理，并以Redis的GEO系列地理位置操作指令为例，理论联系实际地为你讲解它们是如何被高效实现的。<br><strong>阅读提示：</strong>本文适合有一定Redis使用经验的服务器后端开发人员阅读，IM移动客户端开发人员没有太多阅读的必要（理论原理倒是可以知道一下），必竟“附近的xxx”功能主要工作在服务端，而不在客户端。</p><p>（本文同步发布于：http://www.52im.net/thread-2827-1-1.html）<br></p><h1>2、IM开发干货系列文章</h1><p><strong>本文是系列文章中的第19篇，总目录如下：</strong></p><ul class=litype_1><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-294-1-1.html target=_blank>IM消息送达保证机制实现(一)：保证在线实时消息的可靠投递</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-594-1-1.html target=_blank>IM消息送达保证机制实现(二)：保证离线消息的可靠投递</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-714-1-1.html target=_blank>如何保证IM实时消息的“时序性”与“一致性”？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-715-1-1.html target=_blank>IM单聊和群聊中的在线状态同步应该用“推”还是“拉”？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-753-1-1.html target=_blank>IM群聊消息如此复杂，如何保证不丢不重？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-783-1-1.html target=_blank>一种Android端IM智能心跳算法的设计与实现探讨（含样例代码）</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-787-1-1.html target=_blank>移动端IM登录时拉取数据如何作到省流量？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-802-1-1.html target=_blank>通俗易懂：基于集群的移动端IM接入层负载均衡方案分享</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-867-1-1.html target=_blank>浅谈移动端IM的多点登陆和消息漫游原理</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1351-1-1.html target=_blank>IM开发基础知识补课(一)：正确理解前置HTTP SSO单点登陆接口的原理</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1356-1-1.html target=_blank>IM开发基础知识补课(二)：如何设计大量图片文件的服务端存储架构？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1366-1-1.html target=_blank>IM开发基础知识补课(三)：快速理解服务端数据库读写分离原理及实践建议</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1525-1-1.html target=_blank>IM开发基础知识补课(四)：正确理解HTTP短连接中的Cookie、Session和Token</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1611-1-1.html target=_blank>IM群聊消息的已读回执功能该怎么实现？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1616-1-1.html target=_blank>IM群聊消息究竟是存1份(即扩散读)还是存多份(即扩散写)？</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1979-1-1.html target=_blank>IM开发基础知识补课(五)：通俗易懂，正确理解并用好MQ消息队列</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-866-1-1.html target=_blank>一个低成本确保IM消息时序的方法探讨</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2759-1-1.html target=_blank>IM开发基础知识补课(六)：数据库用NoSQL还是SQL？读这篇就够了！</a>》</li><li>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2827-1-1.html target=_blank>IM里“附近的人”功能实现原理是什么？如何高效率地实现它？</a>》（本文）</li></ul><h1>3、“附近的人”功能原理</h1><p>其实，“附近的人”功能原理并不复杂。<br><strong>它需要做以下两件事情：</strong></p><ul><li>1）所有使用该IM产品的人，在使用“附近的人”功能前提交自已的地理位置；</li><li>2）根据“我”的地理位置，计算出别人跟我的距离；</li><li>3）将第2步中计算出的距离由近及远，进行排序。<br></li></ul><p><strong>具体在产品技术上的实现原理，也很容易理解：</strong></p><ul><li>1）现在移动端（ios、android等），通过系统的API很容易抓到用户当前的位置（即经纬度数据）；</li><li>2）根据第1步中的经纬度数据，很容易计算出两个点之间的距离（计算公式原理，可以百度一下，我的几何和数学知识都还给老师了，给你讲不了）；</li><li>3）对第2步中的计算结果排序就更简单了，没什么好提的。<br></li></ul><p>对于IM新手来说，可能对于第2步中的根据经纬度数据计算出两点距离，觉得有点难度，实际上根据数据公式（自已百度一下吧，有点复杂，哥不贴了），用代码来实现，只有短短的十来行代码。<br><strong>下面是一个简单的Java版实现：</strong></p><blockquote><p>/**</p><p>* 计算地球上任意两点(经纬度)距离</p><p>*</p><p>* @param long1 第一点经度</p><p>* @param lat1 第一点纬度</p><p>* @param long2 第二点经度</p><p>* @param lat2 第二点纬度</p><p>* @return 返回距离 单位：米</p><p>*/</p><p>public static double Distance(double long1, double lat1, double long2, double lat2)</p><p>{</p><p>double a, b, R;</p><p>R = 6378137; // 地球半径</p><p>lat1 = lat1 * Math.PI / 180.0;</p><p>lat2 = lat2 * Math.PI / 180.0;</p><p>a = lat1 - lat2;</p><p>b = (long1 - long2) * Math.PI / 180.0;</p><p>double d;</p><p>double sa2, sb2;</p><p>sa2 = Math.sin(a / 2.0);</p><p>sb2 = Math.sin(b / 2.0);</p><p>d = 2 * R * Math.asin(Math.sqrt(sa2 * sa2 + Math.cos(lat1) * Math.cos(lat2) * sb2 * sb2));</p><p>return d;</p><p>}</p></blockquote><p>在进行代码测试的时候，可以结合这个在线工具网页进行结果检验：<a class=pgc-link data-content=mp href=http://www.hhlink.com/%E7%BB%8F%E7%BA%AC%E5%BA%A6/ target=_blank>http://www.hhlink.com/%E7%BB%8F%E7%BA%AC%E5%BA%A6/</a><br>嗯，看起来好简单！<br></p><h1>4、自已从零实现的话，没有难度吗？</h1><p>嗯，通过上一节的原理讲解，目前为止，看起来确实很简单。<br>但，如果自已从零实现的话，对于IM这种高性能、高并发场景来说，确实有一点难度，难不在移动客户端，而是在服务端。<br><strong>技术难点主要包括：</strong></p><ul><li>1）如何高效地进行两点距离的计算，对于高并发服务端来说，像上一节中的代码那样，一个一个计算，还是有点不高效；</li><li>2）如何高效地进行地理围栏的圈定（难道是把所有当前在线的用户，离我的距离都一一算一遍，然后按距离进行筛选？那性能岂不是噩梦？）。<br></li></ul><p>那，有救吗？答案是有！继续看下一节。<br></p><h1>5、Redis里的GEO地理位置相关指令，就能很好的上述问题</h1><p>针对“附近的人”这一位置服务领域的应用场景，服务端高性能场景下，常见的可使用PG、MySQL和MongoDB等多种DB的空间索引进行实现。<br>而<a class=pgc-link data-content=mp href=http://www.52im.net/redis.io/ target=_blank>Redis</a>另辟蹊径，结合其有序队列zset以及geohash编码，实现了空间搜索功能，且拥有极高的运行效率。<br>要提供完整的“附近的人”这样的功能或服务，最基本的是要实现“增”、“删”、“查”的功能。本文余下的文字，以下将分别进行介绍，其中会重点对查询功能进行解析。并将从Redis源码角度对其算法原理进行解析，并推算查询时间复杂度。<br><strong>Redis相关资源：</strong></p><ul><li>1）Redis官网：<a class=pgc-link data-content=mp href=https://redis.io/ target=_blank>https://redis.io</a><br></li><li>2）Redis的GEO指令说明（英文）：<a class=pgc-link data-content=mp href=https://redis.io/commands target=_blank>https://redis.io/commands</a><br></li><li>3）Redis的GEO指令说明（中文）：<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geoadd.html target=_blank>http://redisdoc.com/geo/geoadd.html</a><br></li></ul><h1>6、Redis的GEO地理位置操作指令</h1><p>自 Redis 3.2版 开始，Redis基于geohash和有序集合提供了地理位置相关功能。<br><strong>Redis中的6个地理位置相关操作指令（见<a class=pgc-link data-content=mp href=https://redis.io/commands target=_blank>官方文档</a>）：</strong></p><div class=pgc-img><img alt=IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a71387f252854b4d8f98bc2dfe1648c9><p class=pgc-img-caption></p></div><p><strong>Redis Geo模块的6个指令用途说明：</strong></p><ul><li>1）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geoadd.html# target=_blank>GEOADD</a>：将给定的位置对象（纬度、经度、名字）添加到指定的key；</li><li>2）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geopos.html target=_blank>GEOPOS</a>：从key里面返回所有给定位置对象的位置（经度和纬度）；</li><li>3）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geodist.html target=_blank>GEODIST</a>：返回两个给定位置之间的距离；</li><li>4）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geohash.html target=_blank>GEOHASH</a>：返回一个或多个位置对象的Geohash表示；</li><li>5）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadius.html target=_blank>GEORADIUS</a>：以给定的经纬度为中心，返回目标集合中与中心的距离不超过给定最大距离的所有位置对象；</li><li>6）<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadiusbymember.html target=_blank>GEORADIUSBYMEMBER</a>：以给定的位置对象为中心，返回与其距离不超过给定最大距离的所有位置对象。</li></ul><p>其中，组合使用<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/geoadd.html# target=_blank>GEOADD</a>和<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadius.html target=_blank>GEORADIUS</a>可实现“附近的人”中“增”和“查”的基本功能。要实现类似于微信中“附近的人”功能，可直接使用<a class=pgc-link data-content=mp href=http://redisdoc.com/geo/georadiusbymember.html target=_blank>GEORADIUSBYMEMBER</a>命令。<br>其中“给定的位置对象”即为用户本人，搜索的对象为其他用户。不过本质上，GEORADIUSBYMEMBER = GEOPOS + GEORADIUS，即先查找用户位置再通过该位置搜索附近满足位置相互距离条件的其他用户对象。<br><strong>使用时的注意点：</strong></p><ul><li>1）Redis GEO操作中只包含了“增”和“查”的操作，并无专门“删除”命令。主要是因为Redis内部使用有序集合(zset)保存位置对象，可用zrem删除；</li><li>2）在Redis源码geo.c的文件注释中，只说明了该文件为GEOADD、GEORADIUS和GEORADIUSBYMEMBER的实现；</li><li>3）从侧面看出其他三个命令为辅助命令。</li></ul><p>本文的余下内容，将会从源码角度入手，着生理地对GEOADD和GEORADIUS命令进行分析，剖析其算法原理。<br></p><h1>7、Redis的GEOADD指令是如何高效实现的</h1><p><strong>7.1 使用方式</strong></p><blockquote><p>GEOADD key longitude latitude member [longitude latitude member ...]</p></blockquote><p>以上命令，将给定的位置对象（纬度、经度、名字）添加到指定的key。<br>其中，key为集合名称，member为该经纬度所对应的对象。在实际运用中，当所需存储的对象数量过多时，可通过设置多key(如一个省一个key)的方式对对象集合变相做sharding，避免单集合数量过多。<br><strong>成功插入后的返回值：</strong></p><blockquote><p>(integer) N</p></blockquote><p>其中N为成功插入的个数。</p><p><strong>7.2 源码分析</strong></p><blockquote><p>/* GEOADD key long lat name [long2 lat2 name2 ... longN latN nameN] */</p><p>void geoaddCommand(client *c) {</p><p>//参数校验</p><p>/* Check arguments number for sanity. */</p><p>if ((c->argc - 2) % 3 != 0) {</p><p>/* Need an odd number of arguments if we got this far... */</p><p>addReplyError(c, "syntax error. Try GEOADD key [x1] [y1] [name1] "</p><p>"[x2] [y2] [name2] ... ");</p><p>return;</p><p>}</p><p>//参数提取Redis</p><p>int elements = (c->argc - 2) / 3;</p><p>int argc = 2+elements*2; /* ZADD key score ele ... */</p><p>robj **argv = zcalloc(argc*sizeof(robj*));</p><p>argv[0] = createRawStringObject("zadd",4);</p><p>argv[1] = c->argv[1]; /* key */</p><p>incrRefCount(argv[1]);</p><p>//参数遍历+转换</p><p>/* Create the argument vector to call ZADD in order to add all</p><p>* the score,value pairs to the requested zset, where score is actually</p><p>* an encoded version of lat,long. */</p><p>int i;</p><p>for (i = 0; i &lt; elements; i++) {</p><p>double xy[2];</p><p>//提取经纬度</p><p>if (extractLongLatOrReply(c, (c->argv+2)+(i*3),xy) == C_ERR) {</p><p>for (i = 0; i &lt; argc; i++)</p><p>if (argv[i ]) decrRefCount(argv[i ]);</p><p>zfree(argv);</p><p>return;</p><p>}</p><p>//将经纬度转换为52位的geohash作为分值 & 提取对象名称</p><p>/* Turn the coordinates into the score of the element. */</p><p>GeoHashBits hash;</p><p>geohashEncodeWGS84(xy[0], xy[1], GEO_STEP_MAX, &hash);</p><p>GeoHashFix52Bits bits = geohashAlign52Bits(hash);</p><p>robj *score = createObject(OBJ_STRING, sdsfromlonglong(bits));</p><p>robj *val = c->argv[2 + i * 3 + 2];</p><p>//设置有序集合的对象元素名称和分值</p><p>argv[2+i*2] = score;</p><p>argv[3+i*2] = val;</p><p>incrRefCount(val);</p><p>}</p><p>//调用zadd命令，存储转化好的对象</p><p>/* Finally call ZADD that will do the work for us. */</p><p>replaceClientCommandVector(c,argc,argv);</p><p>zaddCommand(c);</p><p>}</p></blockquote><p>通过Redis源码分析可以看出，Redis内部使用有序集合(zset)保存位置对象，有序集合中每个元素都是一个带位置的对象，元素的score值为其经纬度对应的52位的geohash值：</p><p>1）double类型精度为52位；<br>2）geohash是以base32的方式编码，52bits最高可存储10位geohash值，对应地理区域大小为0.6*0.6米的格子。换句话说经Redis geo转换过的位置理论上会有约0.3*1.414=0.424米的误差。</p><p><strong>7.3 算法小结</strong></p><p><strong>简单总结下GEOADD命令都干了啥：</strong></p><ul><li>1）参数提取和校验；</li><li>2）将入参经纬度转换为52位的geohash值（score）；</li><li>3）调用ZADD命令将member及其对应的score存入集合key中。</li></ul><h1>8、Redis的GEORADIUS指令是如何高效实现的</h1><p><strong>8.1 使用方式</strong></p><blockquote><p>GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC] [COUNT count] [STORE key] [STORedisT key]</p></blockquote><p>以上指令，将以给定的经纬度为中心，返回目标集合中与中心的距离不超过给定最大距离的所有位置对象。<br></p><blockquote><p>范围单位：m | km | ft | mi --> 米 | 千米 | 英尺 | 英里<br>额外参数：<br>- WITHDIST：在返回位置对象的同时，将位置对象与中心之间的距离也一并返回。距离的单位和用户给定的范围单位保持一致。<br>- WITHCOORD：将位置对象的经度和维度也一并返回。<br>- WITHHASH：以 52 位有符号整数的形式，返回位置对象经过原始 geohash 编码的有序集合分值。这个选项主要用于底层应用或者调试，实际中的作用并不大。<br>- ASC|DESC：从近到远返回位置对象元素 | 从远到近返回位置对象元素。<br>- COUNT count：选取前N个匹配位置对象元素。（不设置则返回所有元素）<br>- STORE key：将返回结果的地理位置信息保存到指定key。<br>- STORedisT key：将返回结果离中心点的距离保存到指定key。</p></blockquote><p>由于 STORE 和 STORedisT 两个选项的存在，GEORADIUS 和 GEORADIUSBYMEMBER 命令在技术上会被标记为写入命令，从而只会查询（写入）主实例，QPS过高时容易造成主实例读写压力过大。<br>为解决这个问题，在 Redis 3.2.10 和 Redis 4.0.0 中，分别新增了 GEORADIUS_RO 和 GEORADIUSBYMEMBER_RO两个只读命令。<br>不过，在实际开发中笔者发现 在java package Redis.clients.jedis.params.geo 的 GeoRadiusParam 参数类中并不包含 STORE 和 STORedisT 两个参数选项，在调用georadius时是否真的只查询了主实例，还是进行了只读封装。感兴趣的朋友可以自己研究下。<br><strong>成功查询后的返回值：</strong></p><blockquote><p>不带WITH限定，返回一个member list，如：["member1","member2","member3"]</p></blockquote><p><br><strong>带WITH限定，member list中每个member也是一个嵌套list，如：</strong></p><blockquote><p>[</p><p>["member1", distance1, [longitude1, latitude1]]</p><p>["member2", distance2, [longitude2, latitude2]]</p><p>]</p></blockquote><p><strong>8.2源码分析</strong></p><p><br>此段源码较长，看不下去的可直接看中文注释，或直接跳到小结部分。</p><blockquote><p>/* GEORADIUS key x y radius unit [WITHDIST] [WITHHASH] [WITHCOORD] [ASC|DESC]</p><p>* [COUNT count] [STORE key] [STORedisT key]</p><p>* GEORADIUSBYMEMBER key member radius unit ... options ... */</p><p>void georadiusGeneric(client *c, int flags) {</p><p>robj *key = c->argv[1];</p><p>robj *storekey = NULL;</p><p>int stoRedist = 0; /* 0 for STORE, 1 for STORedisT. */</p><p>//根据key获取有序集合</p><p>robj *zobj = NULL;</p><p>if ((zobj = lookupKeyReadOrReply(c, key, shared.null[c->resp])) == NULL ||</p><p>checkType(c, zobj, OBJ_ZSET)) {</p><p>return;</p><p>}</p><p>//根据用户输入（经纬度/member）确认中心点经纬度</p><p>int base_args;</p><p>double xy[2] = { 0 };</p><p>if (flags & RADIUS_COORDS) {</p><p>……</p><p>}</p><p>//获取查询范围距离</p><p>double radius_meters = 0, conversion = 1;</p><p>if ((radius_meters = extractDistanceOrReply(c, c->argv + base_args - 2,</p><p>&conversion)) &lt; 0) {</p><p>return;</p><p>}</p><p>//获取可选参数 （withdist、withhash、withcoords、sort、count）</p><p>int withdist = 0, withhash = 0, withcoords = 0;</p><p>int sort = SORT_NONE;</p><p>long long count = 0;</p><p>if (c->argc > base_args) {</p><p>... ...</p><p>}</p><p>//获取 STORE 和 STORedisT 参数</p><p>if (storekey && (withdist || withhash || withcoords)) {</p><p>addReplyError(c,</p><p>"STORE option in GEORADIUS is not compatible with "</p><p>"WITHDIST, WITHHASH and WITHCOORDS options");</p><p>return;</p><p>}</p><p>//设定排序</p><p>if (count != 0 && sort == SORT_NONE) sort = SORT_ASC;</p><p>//利用中心点和半径计算目标区域范围</p><p>GeoHashRadius georadius =</p><p>geohashGetAreasByRadiusWGS84(xy[0], xy[1], radius_meters);</p><p>//对中心点及其周围8个geohash网格区域进行查找，找出范围内元素对象</p><p>geoArray *ga = geoArrayCreate();</p><p>membersOfAllNeighbors(zobj, georadius, xy[0], xy[1], radius_meters, ga);</p><p>//未匹配返空</p><p>/* If no matching results, the user gets an empty reply. */</p><p>if (ga->used == 0 && storekey == NULL) {</p><p>addReplyNull(c);</p><p>geoArrayFree(ga);</p><p>return;</p><p>}</p><p>//一些返回值的设定和返回</p><p>……</p><p>geoArrayFree(ga);</p><p>}</p></blockquote><p><br><strong>上文代码中最核心的步骤有两个：</strong></p><ul><li>一是“计算中心点范围；</li><li>二是“对中心点及其周围8个geohash网格区域进行查找”。</li></ul><p>对应的是geohashGetAreasByRadiusWGS84和membersOfAllNeighbors两个函数。<br>我们依次来看。<br><strong>计算中心点范围：</strong></p><blockquote><p>// geohash_helper.c</p><p>GeoHashRadius geohashGetAreasByRadiusWGS84(double longitude, double latitude,</p><p>double radius_meters) {</p><p>return geohashGetAreasByRadius(longitude, latitude, radius_meters);</p><p>}</p><p>//返回能够覆盖目标区域范围的9个geohashBox</p><p>GeoHashRadius geohashGetAreasByRadius(double longitude, double latitude, double radius_meters) {</p><p>//一些参数设置</p><p>GeoHashRange long_range, lat_range;</p><p>GeoHashRadius radius;</p><p>GeoHashBits hash;</p><p>GeoHashNeighbors neighbors;</p><p>GeoHashArea area;</p><p>double min_lon, max_lon, min_lat, max_lat;</p><p>double bounds[4];</p><p>int steps;</p><p>//计算目标区域外接矩形的经纬度范围（目标区域为：以目标经纬度为中心，半径为指定距离的圆）</p><p>geohashBoundingBox(longitude, latitude, radius_meters, bounds);</p><p>min_lon = bounds[0];</p><p>min_lat = bounds[1];</p><p>max_lon = bounds[2];</p><p>max_lat = bounds[3];</p><p>//根据目标区域中心点纬度和半径，计算带查询的9个搜索框的geohash精度（位）</p><p>//这里用到latitude主要是针对极地的情况对精度进行了一些调整（纬度越高，位数越小）</p><p>steps = geohashEstimateStepsByRadius(radius_meters,latitude);</p><p>//设置经纬度最大最小值：-180&lt;=longitude&lt;=180, -85&lt;=latitude&lt;=85</p><p>geohashGetCoordRange(&long_range,&lat_range);</p><p>//将待查经纬度按指定精度（steps）编码成geohash值</p><p>geohashEncode(&long_range,&lat_range,longitude,latitude,steps,&hash);</p><p>//将geohash值在8个方向上进行扩充，确定周围8个Box（neighbors）</p><p>geohashNeighbors(&hash,&neighbors);</p><p>//根据hash值确定area经纬度范围</p><p>geohashDecode(long_range,lat_range,hash,&area);</p><p>//一些特殊情况处理</p><p>……</p><p>//构建并返回结果</p><p>radius.hash = hash;</p><p>radius.neighbors = neighbors;</p><p>radius.area = area;</p><p>return radius;</p><p>}</p></blockquote><p><br><strong>对中心点及其周围8个geohash网格区域进行查找:</strong></p><blockquote><p>// geo.c</p><p>//在9个hashBox中获取想要的元素</p><p>int membersOfAllNeighbors(robj *zobj, GeoHashRadius n, double lon, double lat, double radius, geoArray *ga) {</p><p>GeoHashBits neighbors[9];</p><p>unsigned int i, count = 0, last_processed = 0;</p><p>int debugmsg = 0;</p><p>//获取9个搜索hashBox</p><p>neighbors[0] = n.hash;</p><p>……</p><p>neighbors[8] = n.neighbors.south_west;</p><p>//在每个hashBox中搜索目标点</p><p>for (i = 0; i &lt; sizeof(neighbors) / sizeof(*neighbors); i++) {</p><p>if (HASHISZERO(neighbors[i ])) {</p><p>if (debugmsg) D("neighbors[%d] is zero",i);</p><p>continue;</p><p>}</p><p>//剔除可能的重复hashBox (搜索半径>5000KM时可能出现)</p><p>if (last_processed &&</p><p>neighbors[i ].bits == neighbors[last_processed].bits &&</p><p>neighbors[i ].step == neighbors[last_processed].step)</p><p>{</p><p>continue;</p><p>}</p><p>//搜索hashBox中满足条件的对象</p><p>count += membersOfGeoHashBox(zobj, neighbors[i ], ga, lon, lat, radius);</p><p>last_processed = i;</p><p>}</p><p>return count;</p><p>}</p><p>int membersOfGeoHashBox(robj *zobj, GeoHashBits hash, geoArray *ga, double lon, double lat, double radius) {</p><p>//获取hashBox内的最大、最小geohash值（52位）</p><p>GeoHashFix52Bits min, max;</p><p>scoresOfGeoHashBox(hash,&min,&max);</p><p>//根据最大、最小geohash值筛选zobj集合中满足条件的点</p><p>return geoGetPointsInRange(zobj, min, max, lon, lat, radius, ga);</p><p>}</p><p>int geoGetPointsInRange(robj *zobj, double min, double max, double lon, double lat, double radius, geoArray *ga) {</p><p>//搜索Range的参数边界设置（即9个hashBox其中一个的边界范围）</p><p>zrangespec range = { .min = min, .max = max, .minex = 0, .maxex = 1 };</p><p>size_t origincount = ga->used;</p><p>sds member;</p><p>//搜索集合zobj可能有ZIPLIST和SKIPLIST两种编码方式，这里以SKIPLIST为例，逻辑是一样的</p><p>if (zobj->encoding == OBJ_ENCODING_ZIPLIST) {</p><p>……</p><p>} else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {</p><p>zset *zs = zobj->ptr;</p><p>zskiplist *zsl = zs->zsl;</p><p>zskiplistNode *ln;</p><p>//获取在hashBox范围内的首个元素（跳表数据结构，效率可比拟于二叉查找树），没有则返0</p><p>if ((ln = zslFirstInRange(zsl, &range)) == NULL) {</p><p>/* Nothing exists starting at our min. No results. */</p><p>return 0;</p><p>}</p><p>//从首个元素开始遍历集合</p><p>while (ln) {</p><p>sds ele = ln->ele;</p><p>//遍历元素超出range范围则break</p><p>/* Abort when the node is no longer in range. */</p><p>if (!zslValueLteMax(ln->score, &range))</p><p>break;</p><p>//元素校验（计算元素与中心点的距离）</p><p>ele = sdsdup(ele);</p><p>if (geoAppendIfWithinRadius(ga,lon,lat,radius,ln->score,ele)</p><p>== C_ERR) sdsfree(ele);</p><p>ln = ln->level[0].forward;</p><p>}</p><p>}</p><p>return ga->used - origincount;</p><p>}</p><p>int geoAppendIfWithinRadius(geoArray *ga, double lon, double lat, double radius, double score, sds member) {</p><p>double distance, xy[2];</p><p>//解码错误, 返回error</p><p>if (!decodeGeohash(score,xy)) return C_ERR; /* Can't decode. */</p><p>//最终距离校验(计算球面距离distance看是否小于radius)</p><p>if (!geohashGetDistanceIfInRadiusWGS84(lon,lat, xy[0], xy[1],</p><p>radius, &distance))</p><p>{</p><p>return C_ERR;</p><p>}</p><p>//构建并返回满足条件的元素</p><p>geoPoint *gp = geoArrayAppend(ga);</p><p>gp->longitude = xy[0];</p><p>gp->latitude = xy[1];</p><p>gp->dist = distance;</p><p>gp->member = member;</p><p>gp->score = score;</p><p>return C_OK;</p><p>}</p></blockquote><p><strong>8.3 算法小结</strong></p><p><strong>抛开众多可选参数不谈，简单总结下GEORADIUS命令是怎么利用geohash获取目标位置对象的：</strong></p><ul><li>1）参数提取和校验；</li><li>2）利用中心点和输入半径计算待查区域范围。这个范围参数包括满足条件的最高的geohash网格等级(精度) 以及 对应的能够覆盖目标区域的九宫格位置；（后续会有详细说明）</li><li>3）对九宫格进行遍历，根据每个geohash网格的范围框选出位置对象。进一步找出与中心点距离小于输入半径的对象，进行返回。<br></li></ul><p><strong>直接描述不太好理解，我们通过如下两张图在对算法进行简单的演示：</strong></p><div class=pgc-img><img alt=IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1e93bc8088524232b29062d4c8ada6bb><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc9e2446d3fc4726b626aa9361be4cfa><p class=pgc-img-caption></p></div><p><br>如上图所示，令左图的中心为搜索中心，绿色圆形区域为目标区域，所有点为待搜索的位置对象，红色点则为满足条件的位置对象。<br>在实际搜索时,首先会根据搜索半径计算geohash网格等级（即右图中网格大小等级），并确定九宫格位置（即红色九宫格位置信息）；再依次查找计算九宫格中的点（蓝点和红点）与中心点的距离，最终筛选出距离范围内的点（红点）。<br></p><p><strong>8.4 算法分析</strong></p><p>为什么要用这种算法策略进行查询，或者说这种策略的优势在哪，让我们以问答的方式进行分析说明。<br><strong>为什么要找到满足条件的最高的geohash网格等级？为什么用九宫格？</strong><br>这其实是一个问题，本质上是对所有的元素对象进行了一次初步筛选。 在多层geohash网格中，每个低等级的geohash网格都是由4个高一级的网格拼接而成（如下图）。</p><div class=pgc-img><img alt=IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f75c7af853049eea44d0a7cfb80b19d><p class=pgc-img-caption></p></div><p>换句话说，geohash网格等级越高，所覆盖的地理位置范围就越小。 当我们根据输入半径和中心点位置计算出的能够覆盖目标区域的最高等级的九宫格（网格）时，就已经对九宫格外的元素进行了筛除。 这里之所以使用九宫格，而不用单个网格，主要原因还是为了避免边界情况，尽可能缩小查询区域范围。试想以0经纬度为中心，就算查1米范围，单个网格覆盖的话也得查整个地球区域。而向四周八个方向扩展一圈可有效避免这个问题。<br><strong>如何通过geohash网格的范围框选出元素对象？效率如何？</strong><br>首先在每个geohash网格中的geohash值都是连续的，有固定范围。所以只要找出有序集合中，处在该范围的位置对象即可。以下是有序集合的跳表数据结构：</p><div class=pgc-img><img alt=IM里“附近的人”功能实现原理是什么？如何高效率地实现它？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2a268ad53bb04c368424286f898f8ccb><p class=pgc-img-caption></p></div><p>其拥有类似二叉查找树的查询效率，操作平均时间复杂性为O(log(N))。且最底层的所有元素都以链表的形式按序排列。所以在查询时，只要找到集合中处在目标geohash网格中的第一个值，后续依次对比即可，不用多次查找。 九宫格不能一起查，要一个个遍历的原因也在于九宫格各网格对应的geohash值不具有连续性。只有连续了，查询效率才会高，不然要多做许多距离运算。<br></p><h1>9、本文小结</h1><p><br>综合上述章节，我们从源码角度解析了Redis Geo模块中 “增（GEOADD）” 和 “查（GEORADIUS）” 的详细过程。并可推算出Redis中GEORADIUS查找附近的人功能，时间复杂度为：O(N+log(M))。<br><strong>其中：</strong></p><ul><li>1）N为九宫格范围内的位置元素数量（要算距离）；</li><li>2）M是指定层级格子的数量；</li><li>3）log(M)是跳表结构中找到每个格子首元素的时间复杂度（这个过程一般会进行9次）。</li></ul><p>结合Redis本身基于内存的存储特性，在实际使用过程中有非常高的运行效率。<br>以上，就是本文的全部答案，不知是否对你有帮助！<br></p><h1>附录：更多IM开发综合文章</h1><p>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-464-1-1.html target=_blank>新手入门一篇就够：从零开发移动端IM</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1587-1-1.html target=_blank>移动端IM开发者必读(一)：通俗易懂，理解移动网络的“弱”和“慢”</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1588-1-1.html target=_blank>移动端IM开发者必读(二)：史上最全移动弱网络优化方法总结</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1470-1-1.html target=_blank>从客户端的角度来谈谈移动端IM的消息可靠性和送达机制</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1413-1-1.html target=_blank>现代移动端网络短连接的优化手段总结：请求速度、弱网适应、安全保障</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1391-1-1.html target=_blank>腾讯技术分享：社交网络图片的带宽压缩技术演进之路</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1686-1-1.html target=_blank>小白必读：闲话HTTP短连接中的Session和Token</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1351-1-1.html target=_blank>IM开发基础知识补课：正确理解前置HTTP SSO单点登陆接口的原理</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1221-1-1.html target=_blank>移动端IM中大规模群消息的推送如何保证效率、实时性？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-133-1-1.html target=_blank>移动端IM开发需要面对的技术问题</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-150-1-1.html target=_blank>开发IM是自己设计协议用字节流好还是字符流好？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-175-1-1.html target=_blank>请问有人知道语音留言聊天的主流实现方式吗？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-802-1-1.html target=_blank>通俗易懂：基于集群的移动端IM接入层负载均衡方案分享</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-195-1-1.html target=_blank>微信对网络影响的技术试验及分析（论文全文）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-218-1-1.html target=_blank>即时通讯系统的原理、技术和应用（技术论文）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-447-1-1.html target=_blank>开源IM工程“蘑菇街TeamTalk”的现状：一场有始无终的开源秀</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1208-1-1.html target=_blank>QQ音乐团队分享：Android中的图片压缩技术详解（上篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1212-1-1.html target=_blank>QQ音乐团队分享：Android中的图片压缩技术详解（下篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-675-1-1.html target=_blank>腾讯原创分享(一)：如何大幅提升移动网络下手机QQ的图片传输速度和成功率</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-696-1-1.html target=_blank>腾讯原创分享(二)：如何大幅压缩移动网络下APP的流量消耗（上篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-697-1-1.html target=_blank>腾讯原创分享(三)：如何大幅压缩移动网络下APP的流量消耗（下篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-684-1-1.html target=_blank>如约而至：微信自用的移动端IM网络层跨平台组件库Mars已正式开源</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1191-1-1.html target=_blank>基于社交网络的Yelp是如何实现海量用户图片的无损压缩的？</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1559-1-1.html target=_blank>腾讯技术分享：腾讯是如何大幅降低带宽和网络流量的(图片压缩篇)</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1560-1-1.html target=_blank>腾讯技术分享：腾讯是如何大幅降低带宽和网络流量的(音视频技术篇)</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1693-1-1.html target=_blank>字符编码那点事：快速理解ASCII、Unicode、GBK和UTF-8</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1802-1-1.html target=_blank>全面掌握移动端主流图片格式的特点、性能、调优等</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1961-1-1.html target=_blank>子弹短信光鲜的背后：网易云信首席架构师分享亿级IM平台的技术实践</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1979-1-1.html target=_blank>IM开发基础知识补课(五)：通俗易懂，正确理解并用好MQ消息队列</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-1998-1-1.html target=_blank>微信技术分享：微信的海量IM聊天消息序列号生成实践（算法原理篇）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2671-1-1.html target=_blank>自已开发IM有那么难吗？手把手教你自撸一个Andriod版简易IM (有源码)</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2747-1-1.html target=_blank>融云技术分享：解密融云IM产品的聊天消息ID生成策略</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2768-1-1.html target=_blank>适合新手：从零开发一个IM服务端（基于Netty，有完整源码）</a>》<br>《<a class=pgc-link data-content=mp href=http://www.52im.net/thread-2775-1-1.html target=_blank>拿起键盘就是干：跟我一起徒手开发一套分布式IM系统</a>》<br>>> <a class=pgc-link data-content=mp href="http://www.52im.net/forum.php?mod=collection&action=view&ctid=10" target=_blank>更多同类文章 ……</a><br></p><p>（本文同步发布于：http://www.52im.net/thread-2827-1-1.html）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'IM','实现','什么'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>