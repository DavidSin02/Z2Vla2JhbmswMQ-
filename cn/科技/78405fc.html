<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>typeScript 配置文件该怎么写？ | 极客快訊</title><meta property="og:title" content="typeScript 配置文件该怎么写？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/76865d96fff44102a2551ca3c513ec22"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78405fc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78405fc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78405fc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78405fc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78405fc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78405fc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78405fc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78405fc.html><meta property="article:published_time" content="2020-10-29T20:59:54+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:54+08:00"><meta name=Keywords content><meta name=description content="typeScript 配置文件该怎么写？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/78405fc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>typeScript 配置文件该怎么写？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>TypeScript 的学习资料非常多，其中也不乏很多优秀的文章和教程。但是目前为止没有一个我特别满意的。原因有：</p><ul><li>它们大多数没有一个清晰的主线，而是按照 API 组织章节的，内容在<strong>「逻辑上」</strong>比较零散。</li><li>大多是“讲是什么，怎么用“，而不是”讲为什么，讲原理“。</li><li>大多数内容比较枯燥，趣味性比较低。都是干巴巴的文字，没有图片，缺乏能够引起强烈共鸣的例子。</li></ul><p>因此我的想法是做一套不同市面上大多数的 TypeScript 学习教程。以人类认知的角度思考问题，学习 TypeScript，通过通俗易懂的例子和图片来帮助大家建立 TypeScript 世界观。</p><p>系列安排：</p><ul><li>上帝视角看 TypeScript（已发布）</li><li>TypeScript 类型系统（已发布）</li><li>types 和 @types 是什么？（已发布）</li><li>你不知道的 TypeScript 泛型（万字长文，建议收藏）（已发布）</li><li>TypeScript 配置文件该怎么写？（就是本文）</li><li>TypeScript 是如何与 React，Vue，Webpack 集成的？</li><li>TypeScript 练习题</li></ul><blockquote><p>❝</p><p>目录将来可能会有所调整。</p><p>❞</p></blockquote><p>注意，我的系列文章基本不会讲 API，因此需要你有一定的 TypeScript 使用基础，推荐两个学习资料。</p><ul><li>深入理解 TypeScript</li><li>官方文档</li></ul><p>结合这两个资料和我的系列教程，掌握 TypeScript 指日可待。</p><p>接下来，我们通过几个方面来从宏观的角度来看一下 TypeScript。</p><h1 class=pgc-h-arrow-right><strong>前言</strong></h1><p>这篇文章是我的 TypeScript 系列的<strong>「第 5 篇」</strong>。今天我们就来看下， TypeScript 的配置文件 tsconfig.json 该如何写。</p><p>和 package.json 一样， 它也是一个 JSON 文件。package.json 是包描述文件，对应的 Commonjs 规范，而 <strong>「tsconfig.json 是最终被 TypeScript Compiler 解析和使用的一个 JSON 文件」</strong>。 TypeScript Compiler 用这个配置文件来决定如何对项目进行编译。</p><p>说到编译，不得不提一个知名选手 - babel。 和 TypeScript 类似， 他们都可以将一种语法静态编译成另外一种语法。如果说我想编译一个文件，我只需要告诉 babel 我的文件路径即可。</p><pre><code>npx babel script.js</code></pre><p>有时候我想编译整个文件夹：</p><pre><code>npx babel src --out-dir lib</code></pre><p>babel 也可以指定输出目录，指定需要忽略的文件或目录等等， TypeScript 也是一样！你当然可以像 babel 一样在命令行中全部指定好，也可以将这些配置放到 tsconfig.json 中，以配置文件的形式传递给 TypeScript Compiler 。 这就是 tsconfig.json 文件的初衷，即接受用户输入作为配置项。</p><h1 class=pgc-h-arrow-right><strong>初探 tsconfig</strong></h1><p>我们先来看一个简单的 tsconfig 文件。</p><pre><code>{  "compilerOptions": {    "outDir": "./built",    "allowJs": true,    "target": "es5"  },  "include": ["./src/**/*"]}</code></pre><p>如上配置做了：</p><ul><li>读取所有可识别的 src 目录下的文件（通过 include）。</li><li>接受 JavaScript 做为输入（通过 allowJs）。</li><li>生成的所有文件放在 built 目录下（通过 outDir）。</li><li>将 JavaScript 代码降级到低版本比如 ECMAScript 5（通过 target）。</li></ul><p>实际项目有比这个更复杂。 接下来， 我们来进一步解读。 不过在讲配置项之前，我们先来看下 tsconfig.json 是如何被解析的。</p><h1 class=pgc-h-arrow-right><strong>tsconfig 是如何被解析的？</strong></h1><p><strong>「如果一个目录下存在一个 tsconfig.json 文件，那么意味着这个目录是 TypeScript 项目的根目录。」</strong> 如果你使用 tsc 编译你的项目，并且没有显式地指定配置文件的路径，那么 tsc 则会逐级向上搜索父目录寻找 tsconfig.json ，这个过程类似 node 的模块查找机制。</p><div class=pgc-img><img alt="typeScript 配置文件该怎么写？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76865d96fff44102a2551ca3c513ec22><p class=pgc-img-caption></p></div><p>如图：</p><ul><li>在 _uglify-js@3.7.2@uglify-js 下执行 tsc 则会找到 配置文件 1，在 _uglify-js@3.7.2@uglify-js/bin 下执行 tsc 也会找到 配置文件 1</li><li>同理在 lib，node_modules 也会找到 配置文件 1</li><li>在 _uglify-js@3.7.2@uglify-js/bin/lucifer 下执行 tsc 则会找到 配置文件 2</li><li>在 _uglify-js@3.7.2@uglify-js/lib/lucifer 下执行 tsc 则会找到 配置文件 3</li></ul><p>我在 上帝视角看 TypeScript 一种讲述了 TypeScript 究竟做了什么，带你从宏观的角度看了一下 TypeScript。 其中提到了 TypeScript 编译器会接受文件或者文件集合作为输入，最终转换为 JavaScript（noEmit 为 false） 和 .d.ts(declarations 为 true)。</p><div class=pgc-img><img alt="typeScript 配置文件该怎么写？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c705c11476648f39ba0f41f4d529a63><p class=pgc-img-caption></p></div><p>这里其实还少了一个点，那就是除了接受文件或者文件集合作为输入，还会接受 tsconfig.json。tsconfig.json 的内容决定了编译的范围和行为，不同的 配置可能会得到不同的输出，或者得到不同的检查结果。</p><p>当 tsc 找到了一个 tsconfig.json 文件，那么其规定的编译目录则全部会被 typescript 处理，当然也包括其依赖的文件。 如果 tsc 没有找到一个 tsconfig.json 或 tsconfig 没有有效信息，那么 tsc 会使用默认配置。 比如 tsconfig 是一个空的就没有有效信息：</p><pre><code>{}</code></pre><blockquote><p>❝</p><p>tsconfig 的全部属性，以及属性的默认值可以在这里找到： http://json.schemastore.org/tsconfig</p><p>❞</p></blockquote><p>总结一下 tsc 解析 tsconfig.json 的逻辑。</p><ul><li>如果命令行指定了配置选项或者指定了配置文件的路径，那么直接会读取。 根据 tsconfig json schema 校验是否格式正确。 如果正确，则将其和默认配置合并（如果有 extends 字段，也会一起合并），将合并后的配置传递给 TypeScript 编译器并开始编译。否则抛出错误</li><li>否则，会从当前目录查找 tsconfig.json 文件， 如果找不到则逐层向上搜索父目录。 如果找到了则会去根据 tsconfig json schema 校验是否格式正确。 如果正确，则将其和默认配置合并（如果有 extends 字段，也会一起合并），将合并后的配置传递给 TypeScript 编译器并开始编译。否则抛出错误 否则，始终找不到则直接使用默认配置</li></ul><h1 class=pgc-h-arrow-right><strong>tsconfig 的顶层属性</strong></h1><p>tsconfig 的顶层属性（Top Level）不多，主要有：<strong>「compilerOptions, files, include, exclude,extends,compileOnSave」</strong>等。</p><ul><li>compilerOptions 是重头戏，其属性也是最多的，我们的项目也是对这个定制比较多，这个我后面会重点讲。</li><li>files 则是你需要编译的文件</li><li>exclude 则是你不需要编译的文件目录（支持 glob）</li><li>include 是你需要编译的文件目录（支持 glob）</li><li>extends 就是继承另外一个配置文件，TypeScript 会对其进行合并，多项目公共配置有用。你也可以直接继承社区的“最佳实践”，比如:</li></ul><pre><code>{  "extends": "@tsconfig/node12/tsconfig.json",  "compilerOptions": {},  "include": ["src/**/*"],  "exclude": ["node_modules"]}</code></pre><ul><li>compileOnSave 则是和编辑器（确切地说是文件系统）联动的配置，即是否在文件保存后进行编译，实际项目不建议使用。</li></ul><p>除了 compilerOptions，其他也相对比较好理解。 因此接下来我只针对 compilerOptions 详细讲解一番。</p><h1 class=pgc-h-arrow-right><strong>tsconfig 的编译项</strong></h1><p>详细全面的内容，大家只需要参考官网[1]的就好了。官网写的不仅全面，而且做了分类，非常清晰。</p><p>接下来，我会根据功能分开讲几个<strong>「常用」</strong> 的配置。</p><h1 class=pgc-h-arrow-right><strong>文件相关</strong></h1><p>常用的是以下四个，由于前面已经做了介绍，因此就不赘述了。</p><ul><li>exclude</li><li>extends</li><li>files</li><li>include</li></ul><h1 class=pgc-h-arrow-right><strong>严格检查</strong></h1><ul><li>alwaysStrict</li></ul><p>默认：false</p><p>首次发布版本：2.1</p><p>这个是和 ECMAScript 规范相关的，工作机制和 ES 5 的严格模式一样， 并且输出的 JS 顶部也会也会带上 'use strict'。</p><ul><li>noImplicitAny（推荐打开）</li></ul><p>默认：true</p><p>首次发布版本：-</p><p>我在 - TypeScript 类型系统 中提到了如果不对变量显式声明类型，那么 TypeScript 会对变量进行类型推导，这当然也有推导不出的情况，这个时候该变量的类型就是 any，这个叫做隐式 any。区别于显式 any：</p><pre><code>const a: any = {};</code></pre><p>隐式 any 是 TypeScript 编译器推断的。</p><ul><li>noImplicitThis（推荐打开）</li></ul><p>默认：true</p><p>首次发布版本：2.0</p><p>和隐式 any 类型， 只不过这次是针对的特殊的一个关键字 this，也就是你需要显式地指定 this 的类型。</p><ul><li>strict（推荐打开）</li></ul><p>默认：true</p><p>首次发布版本：2.3</p><p>实际上 strict 只是一个简写，是多个规则的合集。 类似于 babel 中插件（plugins）和 预设（presets）的差别。换句话说如果你指定了 strict 为 true ，那么所有严格相关的规则的都会开启，我所讲的<strong>「严格检查」</strong>都是，还有一部分我没有提到的。另外将来如果增加更多严格规则，你只要开启了 strict 则会自动加进来。</p><h1 class=pgc-h-arrow-right><strong>模块解析</strong></h1><h1 class=pgc-h-arrow-right><strong>模块相关</strong></h1><p>目的：<strong>「allowSyntheticDefaultImports，allowUmdGlobalAccess，esModuleInterop，moduleResolution 都是为了和其他模块化规范兼容做的。」</strong></p><ul><li>allowSyntheticDefaultImports</li><li>allowUmdGlobalAccess</li><li>esModuleInterop</li><li>moduleResolution</li></ul><p>还有一个配置 <strong>「module」</strong>，规定了项目的模块化方式，选项有 AMD，UMD，commonjs 等。</p><h1 class=pgc-h-arrow-right><strong>路径相关</strong></h1><p>目的： <strong>「baseUrl，paths，rootDirs， typeRoots，types 都是为了简化路径的拼写做的。」</strong></p><ul><li>baseUrl</li></ul><p>这个配置是告诉 TypeScript 如何解析模块路径的。比如：</p><pre><code>import { helloWorld } from "hello/world";console.log(helloWorld);</code></pre><p>这个就会从 baseUrl 下找 hello 目录下的 world 文件。</p><ul><li>paths</li></ul><p>定义类似别名的存在，从而简化路径的书写。</p><ul><li>rootDirs</li></ul><p>注意是 rootDirs ，而不是 rootDir，也就是说根目录可以有多个。 当你指定了多个根目录的时候， 不同根目录的文件可以像在一个目录下一样互相访问。</p><blockquote><p>❝</p><p>实际上也有一个叫 rootDir 的， 和 rootDirs 的区别就是其只能指定一个。</p><p>❞</p></blockquote><ul><li>typeRoots</li><li>types</li></ul><p>types 和 typeRoots 我在 - types 和 @types 是什么？ 已经讲得很清楚了，这里就不多说了。</p><h1 class=pgc-h-arrow-right><strong>项目配置</strong></h1><h1 class=pgc-h-arrow-right><strong>JavaScript 相关</strong></h1><ul><li>allowJs</li></ul><p>默认：false</p><p>首次发布版本：1.8</p><p>顾名思义，允许在 TypeScript 项目中使用 JavaScript，这在从 JavaScript 迁移到 TypeScript 中是非常重要的。</p><ul><li>checkJs</li></ul><p>默认：false</p><p>首次发布版本：-</p><p>和 allowJs 类似， 只不过 checkJs 会额外对 JS 文件进行校验。</p><h1 class=pgc-h-arrow-right><strong>声明文件相关</strong></h1><p>如果 TypeScript 是将 TS 文件编译为 JS，那么声明文件 + JS 文件就可以反推出 TS 文件。</p><p>这两个用来生成 .d.ts 和 .d.ts 的 sourcemap 文件。</p><ul><li>declaration</li></ul><p>默认：false</p><p>首次发布版本：1.0</p><ul><li>declarationMap</li></ul><p>默认：false</p><p>首次发布版本：2.9</p><h1 class=pgc-h-arrow-right><strong>外部库相关</strong></h1><ul><li>jsx</li></ul><p>默认：react</p><p>首次发布版本：2.2</p><p>这个是告诉 TypeScript 如何编译 jsx 语法的。</p><ul><li>lib</li></ul><p>默认：-</p><p>首次发布版本：2.0</p><p>lib 我在 TypeScript 类型系统 中讲过。 Typescript 提供了诸如 lib.d.ts 等类型库文件。随着 ES 的不断更新， JavaScript 类型和全局变量会逐渐变多。Typescript 也是采用这种 lib 的方式来解决的。</p><div class=pgc-img><img alt="typeScript 配置文件该怎么写？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/890c0946a87940a180d112c2ae69a9cb><p class=pgc-img-caption></p></div><p>（TypeScript 提供的部分 lib）</p><h1 class=pgc-h-arrow-right><strong>输出相关</strong></h1><p>outDir 和 outFile 这两个配置则是告诉 TypeScript 将文件生成到哪里。</p><ul><li>outDir</li></ul><p>默认：和 ts 文件同目录（且同名，只是后缀不同）</p><p>首次发布版本：-</p><ul><li>outFile</li></ul><p>默认：-</p><p>首次发布版本：1.0</p><p>module 是 CommonJS 和 ES6 module 不能知道 outFile，只有是 None, System 或 AMD 才行，其会将这些模块的文件内容打包到全局文件内容之后。</p><p>而 noEmit 则是控制是否输出 JS 文件的。</p><ul><li>noEmit</li></ul><p>默认：false</p><p>首次发布版本：-</p><p>如果你只希望用 TypeScript 进行类型检查，不希望要它生成文件，则可以将 noEmit 设置成 true。</p><ul><li>target</li></ul><p>即输出的 JavaScript 对标的 ECMA 规范。 比如 “target”: “es6” 就是将 es6 + 的语法转换为 ES6 的 代码。其选项有 ES3，ES5，ES6 等。</p><blockquote><p>❝</p><p>为什么没有 ES4 ？ ^_^</p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>总结</strong></h1><ul><li>tsconfig 就是一个 JSON 文件，TypeScript 会使用该文件来决定如何编译和检查 TypeScript 项目。和 babel 类似，甚至很多配置项都是相通的。</li><li>如果一个目录下存在一个 tsconfig.json 文件，那么意味着这个目录是 TypeScript 项目的根目录。 如果你使用 tsc 编译你的项目，并且没有显式地指定配置文件的路径，那么 tsc 则会逐级向上搜索父目录寻找 tsconfig.json ，这个过程类似 node 的模块查找机制。</li><li>tsconfig 中最重要的恐怕就是编译器选项（compilerOptions）了。如果你按照功能去记忆则会比较简单， 比如文件相关的有哪些， 严格检查的有哪些，声明文件的有哪些等等。</li></ul><h1 class=pgc-h-arrow-right><strong>参考</strong></h1><ul><li>typescriptlang's tsconfig</li></ul><h1 class=pgc-h-arrow-right><strong>关注我</strong></h1><p>大家也可以关注我的公众号《脑洞前端》获取更多更新鲜的前端硬核文章，带你认识你不知道的前端。</p><p><br></p><p>点关注，不迷路！</p><h1 class=pgc-h-arrow-right><strong>Reference</strong></h1><p>[1]官网-tsconfig: <em>https://www.typescriptlang.org/tsconfig</em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'配置文件','typeScript','怎么'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>