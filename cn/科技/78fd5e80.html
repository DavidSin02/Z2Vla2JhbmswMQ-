<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 | 极客快訊</title><meta property="og:title" content="如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9e3a5e844e39410f99199ab7dbd0cd67"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/78fd5e80.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/78fd5e80.html><meta property="article:published_time" content="2020-11-14T21:03:07+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:07+08:00"><meta name=Keywords content><meta name=description content="如何优雅地用TensorFlow预测时间序列：TFTS库详细教程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/78fd5e80.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何优雅地用TensorFlow预测时间序列：TFTS库详细教程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>前言</strong></p><p>如何用TensorFlow结合LSTM来做时间序列预测其实是一个很老的话题，然而却一直没有得到比较好的解决。如果在Github上搜索“tensorflow time series”，会发现star数最高的已经和TF 1.0版本不兼容了，并且其他的项目使用的方法也各有不同，比较混乱。</p><p><strong>在刚刚发布的TensorFlow 1.3版本中，引入了一个TensorFlow Time Series模块</strong>。TFTS专门设计了一套针对时间序列预测问题的API，<strong>目前提供AR、Anomaly Mixture AR、LSTM三种预测模型。</strong></p><p>由于是刚刚发布的库，文档还是比较缺乏的，我通过研究源码，大体搞清楚了这个库的设计逻辑和使用方法，这篇文章是一篇教程帖，会详细的介绍TFTS库的以下几个功能：</p><ul><li>读入时间序列数据（分为从numpy数组和csv文件两种方式）</li><li>用AR模型对时间序列进行预测</li><li>用LSTM模型对时间序列进行预测（包含单变量和多变量）</li></ul><p>先上效果图，使用AR模型预测的效果如下图所示，蓝色线是训练数据，绿色为模型拟合数据，红色线为预测值：</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9e3a5e844e39410f99199ab7dbd0cd67><p class=pgc-img-caption></p></div><p>使用LSTM进行单变量时间序列预测：</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2703d167c7e5461586aaa406c7c3d715><p class=pgc-img-caption></p></div><p>使用LSTM进行多变量时间序列预测（每一条线代表一个变量）：</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c38a101de34641e9a761f2459009dfff><p class=pgc-img-caption></p></div><p><strong>文中涉及的所有代码已经保存在Github上了，地址是：Tensorflow-Time-Series-Examples，以下提到的所有代码和文件都是相对于这个项目的根目录来说的。</strong></p><p><strong>时间序列问题的一般形式</strong></p><p>一般地，时间序列数据可以看做由两部分组成：<strong>观察的时间点</strong>和<strong>观察到的值</strong>。以商品价格为例，某年一月的价格为120元，二月的价格为130元，三月的价格为135元，四月的价格为132元。那么观察的时间点可以看做是1,2,3,4，而在各时间点上观察到的数据的值为120,130,135,132。</p><p><strong>从Numpy数组中读入时间序列数据</strong></p><p>如何将这样的时间序列数据读入进来？TFTS库中提供了两个方便的读取器NumpyReader和CSVReader。前者用于从Numpy数组中读入数据，后者则可以从CSV文件中读取数据。</p><p>我们利用np.sin，生成一个实验用的时间序列数据，这个时间序列数据实际上就是在正弦曲线上加上了上升的趋势和一些随机的噪声：</p><p>如图：</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/274d023c51a44834a4284f07e4659507><p class=pgc-img-caption></p></div><p>横座标对应变量“x”，纵座标对应变量“y”，它们就是我们之前提到过的“观察的时间点”以及“观察到的值”。TFTS读入x和y的方式非常简单，请看下面的代码：</p><p>我们首先把x和y变成python中的词典（变量data）。变量data中的键值tf.contrib.timeseries.TrainEvalFeatures.TIMES实际就是一个字符串“times”，而tf.contrib.timeseries.TrainEvalFeatures.VALUES就是字符串”values”。所以上面的定义直接写成“data = {‘times’:x, ‘values’:y}”也是可以的。写成比较复杂的形式是为了和源码中的写法保持一致。</p><p>得到的reader有一个read_full()方法，它的返回值就是时间序列对应的Tensor，我们可以用下面的代码试验一下：</p><p><strong>不能直接使用sess.run(reader.read_full())来从reader中取出所有数据。原因在于read_full()方法会产生读取队列，而队列的线程此时还没启动，我们需要使用tf.train.start_queue_runners启动队列，才能使用sess.run()来获取值。</strong></p><p>我们在训练时，通常不会使用整个数据集进行训练，而是采用batch的形式。从reader出发，建立batch数据的方法也很简单：</p><p>tf.contrib.timeseries.RandomWindowInputFn会在reader的所有数据中，随机选取窗口长度为window_size的序列，幷包装成batch_size大小的batch数据。<strong>换句话说，一个batch内共有batch_size个序列，每个序列的长度为window_size。</strong></p><p>以batch_size=2, window_size=10为例，我们可以打出一个batch内的数据：</p><p>这部分读入代码的地址在github上</p><p><strong>从CSV文件中读入时间序列数据</strong></p><p>有的时候，时间序列数据是存在CSV文件中的。我们当然可以将其先读入为Numpy数组，再使用之前的方法处理。更方便的做法是使用tf.contrib.timeseries.CSVReader读入。项目中提供了一个代码，示例如何将文件./data/period_trend.csv中的时间序列读入进来。</p><p>假设CSV文件的时间序列数据形式为：</p><p>CSV文件的第一列为时间点，第二列为该时间点上观察到的值。将其读入的方法为：</p><p>从reader建立batch数据形成train_input_fn的方法和之前完全一样。下面我们就利用这个train_input_fn来训练模型。</p><p><strong>使用AR模型预测时间序列</strong></p><p>自回归模型（Autoregressive model，可以简称为AR模型）是统计学上处理时间序列模型的基本方法之一。在TFTS中，已经实现了一个自回归模型。使用AR模型训练、验证并进行时间序列预测的示例程序。</p><p>先建立一个train_input_fn：</p><p>针对这个序列，对应的AR模型的定义就是：</p><p>这里的几个参数比较重要，分别给出解释。第一个参数periodicities表示序列的规律性周期。我们在定义数据时使用的语句是：“y = np.sin(np.pi * x / 100) + x / 200. + noise”，因此周期为200。input_window_size表示模型每次输入的值，output_window_size表示模型每次输出的值。<strong>input_window_size和output_window_size加起来必须等于train_input_fn中总的window_size。</strong>在这里，我们总的window_size为40，input_window_size为30，output_window_size为10，也就是说，一个batch内每个序列的长度为40，其中前30个数被当作模型的输入值，后面10个数为这些输入对应的目标输出值。最后一个参数loss指定采取哪一种损失，一共有两种损失可以选择，分别是NORMAL_LIKELIHOOD_LOSS和SQUARED_LOSS。</p><p><strong>num_features参数表示在一个时间点上观察到的数的维度。我们这里每一步都是一个单独的值，所以num_features=1。</strong></p><p>除了程序中出现的几个参数外，还有一个比较重要的参数是model_dir。它表示模型训练好后保存的地址，如果不指定的话，就会随机分配一个临时地址。</p><p>使用变量ar的train方法可以直接进行训练：</p><p>TFTS中验证(evaluation)的含义是：使用训练好的模型在原先的训练集上进行计算，由此我们可以观察到模型的拟合效果，对应的程序段是：</p><p>如果要理解这里的逻辑，首先要理解之前定义的AR模型：它每次都接收一个长度为30的输入观测序列，并输出长度为10的预测序列。整个训练集是一个长度为1000的序列，前30个数首先被当作“初始观测序列”输入到模型中，由此就可以计算出下面10步的预测值。接着又会取30个数进行预测，这30个数中有10个数就是前一步的预测值，新得到的预测值又会变成下一步的输入，以此类推。</p><p>最终我们得到970个预测值（970=1000-30，因为前30个数是没办法进行预测的）。这970个预测值就被记录在evaluation[‘mean’]中。evaluation还有其他几个键值，如evaluation[‘loss’]表示总的损失，evaluation[‘times’]表示evaluation[‘mean’]对应的时间点等等。</p><p>evaluation[‘start_tuple’]会被用于之后的预测中，它相当于最后30步的输出值和对应的时间点。以此为起点，我们可以对1000步以后的值进行预测，对应的代码为：</p><p>这里的代码在1000步之后又像后预测了250个时间点。对应的值就保存在predictions[‘mean’]中。我们可以把观测到的值、模型拟合的值、预测值用下面的代码画出来：</p><p>画好的图片会被保存为“predict_result.jpg”</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ce8fa38bea534298abde6490864a0c74><p class=pgc-img-caption></p></div><p><strong>使用LSTM预测单变量时间序列</strong></p><p><strong>注意：以下LSTM模型的例子必须使用TensorFlow最新的开发版的源码。具体来说，要保证“from tensorflow.contrib.timeseries.python.timeseries.estimators import TimeSeriesRegressor”可以成功执行。</strong></p><p>给出两个用LSTM预测时间序列模型的例子，前者是在LSTM中进行单变量的时间序列预测，后者是使用LSTM进行多变量时间序列预测。为了使用LSTM模型，我们需要先使用TFTS库对其进行定义，定义模型的代码，在train_lstm.py和train_lstm_multivariate.py中分别拷贝了一份。</p><p>我们同样用函数加噪声的方法生成一个模拟的时间序列数据：</p><p>此处y对x的函数关系比之前复杂，因此更适合用LSTM这样的模型找出其中的规律。得到y和x后，使用NumpyReader读入为Tensor形式，接着用tf.contrib.timeseries.RandomWindowInputFn将其变为batch训练数据。<strong>一个batch中有4个随机选取的序列，每个序列的长度为100。</strong></p><p>接下来我们定义一个LSTM模型：</p><p><strong>num_features = 1表示单变量时间序列，即每个时间点上观察到的量只是一个单独的数值。num_units=128表示使用隐层为128大小的LSTM模型。</strong></p><p>训练、验证和预测的方法都和之前类似。在训练时，我们在已有的1000步的观察量的基础上向后预测200步：</p><p>将验证、预测的结果取出并画成示意图，画出的图像会保存成“predict_result.jpg”文件：</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/08deb674ae9742208c27714883b76d1a><p class=pgc-img-caption></p></div><p><strong>使用LSTM预测多变量时间序列</strong></p><p>所谓多变量时间序列，就是指在每个时间点上的观测量有多个值。在data/multivariate_periods.csv文件中，保存了一个多变量时间序列的数据：</p><p>这个CSV文件的第一列是观察时间点，除此之外，每一行还有5个数，表示在这个时间点上的观察到的数据。<strong>换句话说，时间序列上每一步都是一个5维的向量。</strong></p><p>使用TFTS读入该CSV文件的方法为：</p><p>与之前的读入相比，唯一的区别就是column_names参数。它告诉TFTS在CSV文件中，哪些列表示时间，哪些列表示观测量。</p><p>接下来定义LSTM模型：</p><p>区别在于使用num_features=5而不是1，原因在于我们在每个时间点上的观测量是一个5维向量。</p><p>训练、验证、预测以及画图的代码与之前比较类似，此处直接给出最后的运行结果：</p><div class=pgc-img><img alt=如何优雅地用TensorFlow预测时间序列：TFTS库详细教程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c38a101de34641e9a761f2459009dfff><p class=pgc-img-caption></p></div><p>图中前100步是训练数据，一条线就代表观测量在一个维度上的取值。100步之后为预测值。</p><p>原文转自：https://zhuanlan.zhihu.com/p/28475975</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'优雅','地用','TensorFlow'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>