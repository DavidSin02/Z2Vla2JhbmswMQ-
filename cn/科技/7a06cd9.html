<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试中常考的堆、栈和队列如何理解与应用？ | 极客快訊</title><meta property="og:title" content="面试中常考的堆、栈和队列如何理解与应用？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0a8a1934fd404a3e9bfdbe5c49d1aa74"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7a06cd9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7a06cd9.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="面试中常考的堆、栈和队列如何理解与应用？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7a06cd9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试中常考的堆、栈和队列如何理解与应用？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0a8a1934fd404a3e9bfdbe5c49d1aa74><p class=pgc-img-caption></p></div><p class=ql-align-justify>「堆栈」作为计算机科学中的一个专有词语，在许多的面试和考试中会出现，一般在面试的过程中我们讨论的「堆栈」指的是数据结构中的堆栈，此外，计算机操作系统中也有关于堆栈的定义，我们需要明确操作系统中的堆、栈和数据结构堆、栈不是一个概念，它们除了名字一样没有什么必然的联系，本文主要介绍数据结构中的堆栈，有兴趣的同学可以去了解一下操作系统中的堆栈。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f449ea5bad834813af6e503d23bcae5b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center><strong>堆、栈和队列</strong></p><p class=ql-align-justify>在数据结构中，「堆栈」分别有着以下含义：</p><ul><li class=ql-align-justify>堆（heap）也被称为优先队列，队列中允许的操作是 <strong>先进先出</strong>（FIFO），在队尾插入元素，在队头取出元素。而堆也是一样，在堆底插入元素，在堆顶取出元素。二叉树的衍生，有最小堆最大堆的两个概念，将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。</li><li class=ql-align-justify>有一个比较有名的堆排序算法正是基于这个数据结构而来，在 <a class=pgc-link data-content=mp href="https://www.toutiao.com/i6637267422963302920/?group_id=6637267422963302920" target=_blank>视频｜手撕九大经典排序算法，看我就够了！</a> 中我们有所涉及，欢迎有兴趣的读者进行学习。</li></ul><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a31d98999564e1dbb96d378e50ee4a4><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>栈（Stack）又名堆栈，作为一个 <strong>先进后出 </strong>的数据结构。（<strong>注意：这里的堆栈本身就是栈，只是换了个抽象的名字</strong>。）</li></ul><blockquote><p>它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p></blockquote><ul><li class=ql-align-justify>其运行方式如下：</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3049aad84d304d5594cbfe46f78358c6><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>另外补充一个和堆栈比较相关的概念——队列</p><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/23c7da359f0148f7905c98328e40d868><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li class=ql-align-justify>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。</li><li class=ql-align-justify>队列采用<strong> 先进先出</strong> FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。</li></ul><p class=ql-align-justify>在了解了上面一些基本的概念后，我们来看看在实际的面试中有可能会遇到哪些相关的题目吧~</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bce0c26dd56e47a6b3759e3965434024><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center><strong>面试题</strong></p><p>「一个栈来确认括号是否匹配」这类题目不仅会出现在面试当中，在许多高校的编程题目中也会有所出现。在力扣（LeetCode）上有这样一个题目：</p><p><strong>20.有效的括号</strong><a class=pgc-link data-content=mp href=https://leetcode-cn.com/problems/valid-parentheses/solution/you-xiao-de-gua-hao-by-leetcode/ target=_blank>力扣</a></p><p>题目描述</p><p>给定一个只包 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li class=ql-align-justify>左括号必须用相同类型的右括号闭合。</li><li class=ql-align-justify>左括号必须以正确的顺序闭合。</li></ul><p class=ql-align-justify>注意：空字符串可被认为是有效字符串。</p><p class=ql-align-justify><strong>示例 1</strong>:</p><pre class=ql-align-justify>输入: "()"输出: true</pre><p class=ql-align-justify><strong>示例 2</strong>:</p><pre>输入: "()[]{}"输出: true</pre><p class=ql-align-justify><strong>示例 3</strong>:</p><pre>输入: "(]"输出: false</pre><p class=ql-align-justify><strong>示例 4</strong>:</p><pre>输入: "([)]"输出: false</pre><p class=ql-align-justify><strong>示例 5</strong>:</p><pre>输入: "{[]}"输出: true</pre><p><strong>解题思路</strong></p><p>对于没有学过「栈」这个数据结构的同学来说可能遇到这一类的问题咋一看可能有点没有头绪，但是其实只需要判断下一个元素是否在栈顶即可判断括号的匹配情况，即如果遇到一个左括号，我们将这个符号插入压栈，如果遇到一个右括号，我们判断一下栈顶的元素是否是对应的左括号，如果是（即与栈顶元素匹配），那么就一起出栈，否则的话直接返回 false 表示字符串无效。</p><p>我们来看一例子，假设字符串是 ( ) [ ]，栈的变化分别为：</p><ol><li>( 入栈</li><li>) 入栈，发现与栈顶元素 ( 匹配，出栈，目前栈为空</li><li>[ 入栈</li><li>] 入栈，发现和栈顶元素 [ 匹配，出栈，栈为空</li></ol><p>而如果是：(]，栈的变化会是怎么样的呢？</p><ol><li>( 入栈</li><li>] 入栈，栈顶元素为 (，不匹配，直接返回 false</li></ol><p><strong>C++ 代码实现如下</strong>：</p><pre>class Solution {public: bool isValid (string const&amp; s) { // 定义左右两边的括号序列 string left = "([{"; string right = ")]}"; stack&lt;char&gt; stk;​ for (auto c : s) { // 判断每一个输入的字符是否为左括号，如果是就压栈 if (left.find(c) != string::npos) { stk.push (c); } else { // 如果不是左括号，且如果发现栈为空，或者栈顶元素不是匹配的左括号的话，就返回 false if (stk.empty () || stk.top () != left[right.find (c)]) return false; // 如果匹配的话，就把栈顶出栈 else stk.pop (); } } return stk.empty(); }};</pre><p>有了栈的知识之后，另一个可以用栈来完成的操作是实现一个队列，比如在力扣（LeetCode）上有这样一个题目：</p><p><strong>232.用栈实现队列</strong></p><p><strong>题目描述</strong></p><p><strong>使用栈实现队列的下列操作：</strong></p><ul><li>push(x) -- 将一个元素放入队列的尾部。</li><li>pop() -- 从队列首部移除元素。</li><li>peek() -- 返回队列首部的元素。</li><li>empty() -- 返回队列是否为空。</li></ul><p><strong>示例</strong>:</p><pre>MyQueue queue = new MyQueue();​queue.push(1);queue.push(2); queue.peek(); // 返回 1queue.pop(); // 返回 1queue.empty(); // 返回 false</pre><p><strong>说明</strong>:</p><ul><li>你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。</li><li>你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。</li><li>假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。</li></ul><p><strong>解题思路</strong></p><p>在上面的介绍中我们得知队列是一种先进先出（first in - first out， FIFO）的数据结构，队列中的元素都从后端（rear）入队（push），从前端（front）出队（pop）。 实现队列最直观的方法是用链表，但在这篇文章里我会介绍另一个方法 - 使用栈。 栈是一种 <strong>后进先出</strong>（last in - first out， LIFO）的数据结构，栈中元素从栈顶（top）压入（push)，也从栈顶弹出（pop）。 为了满足队列的 FIFO 的特性，我们需要用到两个栈，用它们其中一个来反转元素的入队顺序，用另一个来存储元素的最终顺序。</p><p><strong>C++ 实现如下</strong>：</p><pre>class MyQueue {public: /** Initialize your data structure here. */ MyQueue() : s1(), s2(){  }  /** Push element x to the back of queue. */ void push(int x) { s1.push(x); }  /** Removes the element from in front of queue and returns that element. */ int pop() { if(s2.empty()) { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } } int ret = s2.top(); s2.pop(); return ret; }  /** Get the front element. */ int peek() { if(s2.empty()) { while(!s1.empty()) { s2.push(s1.top()); s1.pop(); } } return s2.top(); }  /** Returns whether the queue is empty. */ bool empty() { return s1.empty() &amp;&amp; s2.empty(); }private: stack&lt;int&gt; s1; stack&lt;int&gt; s2;};/** * Your MyQueue object will be instantiated and called as such: * MyQueue* obj = new MyQueue(); * obj-&gt;push(x); * int param_2 = obj-&gt;pop(); * int param_3 = obj-&gt;peek(); * bool param_4 = obj-&gt;empty(); */</pre><p>下面来看一个考察「堆」的面试题：</p><p><strong>​23.合并K个排序链表</strong><a class=pgc-link data-content=mp href=https://leetcode-cn.com/problems/merge-k-sorted-lists/ target=_blank>力扣</a></p><p><strong>题目描述</strong></p><p><strong>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</strong></p><p><strong>示例:</strong></p><pre>输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</pre><p><strong>解题思路</strong></p><p>一个最简单的想法是通过暴力的方法先遍历整个链表到一个数组中进行排序，然后将已经排序的新数组生成一个新的链表。</p><p><strong>Python 实现如下</strong>：</p><pre>class Solution(object):  def mergeKLists(self, lists): """ :type lists: List[ListNode] :rtype: ListNode """ self.nodes = []  head = point = ListNode(0)  for l in lists:  while l:  self.nodes.append(l.val)  l = l.next  for x in sorted(self.nodes):  point.next = ListNode(x)  point = point.next  return head.next</pre><p>但是这个方法仅仅是能用而已，由于需要遍历整个列表，必然会导致一个非常高的时间复杂度，且由于这个是堆相关的面试题，所以我们可以考虑使用 <strong>最小堆 </strong>的方法。</p><div class=pgc-img><img alt=面试中常考的堆、栈和队列如何理解与应用？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b0fe65c144fb4dc9b27ef7abf65b7140><p class=pgc-img-caption></p></div><p>首先把 k 个链表的首元素都加入最小堆中，它们会自动排好序。然后我们每次取出最小的那个元素加入我们最终结果的链表中，然后把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆中没有元素了，此时 k 个链表也合并为了一个链表，返回首节点即可。</p><p><strong>C++ 实现如下</strong>：</p><pre>class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { auto cmp = [](ListNode*&amp; a, ListNode*&amp; b) { return a-&gt;val &gt; b-&gt;val; }; priority_queue&lt;ListNode*, vector&lt;ListNode*&gt;, decltype(cmp) &gt; q(cmp); for (auto node : lists) { if (node) q.push(node); } ListNode *dummy = new ListNode(-1), *cur = dummy; while (!q.empty()) { auto t = q.top(); q.pop(); cur-&gt;next = t; cur = cur-&gt;next; if (cur-&gt;next) q.push(cur-&gt;next); } return dummy-&gt;next; }};</pre><p><strong>拓展练习</strong></p><p>看完这篇文章，不知道你对堆、栈和队列是否有了一些基本的了解。在力扣上有许多相关题目供大家练习。例如，</p><p>「<strong>堆</strong>」（共有 34 道）</p><ul><li>接雨水 II</li><li>滑动窗口最大值</li><li>网络延迟时间</li></ul><p>「<strong>栈</strong>」（共有 49 道）</p><ul><li>接雨水</li><li>用队列实现栈</li><li>逆波兰表达式求值</li></ul><p>「<strong>队列</strong>」（共有 9 道）</p><ul><li>数据流中的移动平均值</li><li>贪吃蛇</li><li>任务调度器</li></ul><p>你还可以搭配 <a class=pgc-link data-content=mp href=https://leetcode-cn.com/explore/learn/card/queue-stack/ target=_blank>探索队列 & 栈 - 力扣 (LeetCode)</a>探索卡片进行针对性练习～</p><p>本文作者：Nova Kwok</p><p>声明：本文归 “力扣” 版权所有，如需转载请联系。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'常考','面试','队列'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>