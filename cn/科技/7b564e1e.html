<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring boot学习（六）Spring boot实现AOP记录操作日志 | 极客快訊</title><meta property="og:title" content="Spring boot学习（六）Spring boot实现AOP记录操作日志 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6824f504d2264a748492cd7ceb6732ba"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b564e1e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b564e1e.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="Spring boot学习（六）Spring boot实现AOP记录操作日志"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7b564e1e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring boot学习（六）Spring boot实现AOP记录操作日志</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>前言</strong></p><p>在实际的项目中，特别是管理系统中，对于那些重要的操作我们通常都会记录操作日志。比如对数据库的CRUD操作，我们都会对每一次重要的操作进行记录，通常的做法是向数据库指定的日志表中插入一条记录。这里就产生了一个问题，难道要我们每次在 CRUD的时候都手动的插入日志记录吗？这肯定是不合适的，这样的操作无疑是加大了开发量，而且不易维护，所以实际项目中总是利用AOP(Aspect Oriented Programming)即面向切面编程这一技术来记录系统中的操作日志。</p><p><strong>日志分类</strong></p><p>这里我把日志按照面向的对象不同分为两类：</p><ul><li>面向用户的日志：用户是指使用系统的人，这一类日志通常记录在数据库里边，并且通常是记录对数据库的一些CRUD操作。</li><li>面向开发者的日志：查看这一类日志的一般都是开发人员，这类日志通常保存在文件或者在控制台打印（开发的时候在控制台，项目上线之后之后保存在文件中），这一类日志主要用于开发者开发时期和后期维护时期定位错误。</li></ul><p>面向不同对象的日志，我们采用不同的策略去记录。很容易看出，对于面向用户的日志具有很强的灵活性，需要开发者控制用户的哪些操作需要向数据库记录日志，所以这一类保存在数据库的日志我们在使用 AOP记录时用自定义注解的方式去匹配；而面向开发者的日志我们则使用表达式去匹配就可以了（这里有可能叙述的有点模糊，看了下面去案例将会很清晰），下面分别介绍两种日志的实现。</p><p><strong>实现AOP记录面向用户的日志</strong></p><p>接下来分步骤介绍Spring boot中怎样实现通过AOP记录操作日志。</p><p><strong>添加依赖</strong></p><p>在pom.xml文件中添加如下依赖：</p><p>&lt;!-- aop依赖 --></p><p>&lt;dependency></p><p>&lt;groupId>org.springframework.boot&lt;/groupId></p><p>&lt;artifactId>spring-boot-starter-aop&lt;/artifactId></p><p>&lt;/dependency></p><p><strong>修改配置文件</strong></p><p>在项目的application.properties文件中添加下面一句配置：</p><p>spring.aop.auto=true</p><blockquote>这里特别说明下，这句话不加其实也可以，因为默认就是true，只要我们在pom.xml中添加了依赖就可以了，这里提出来是让大家知道有这个有这个配置。</blockquote><p><strong>自定义注解</strong></p><p>上边介绍过了了，因为这类日志比较灵活，所以我们需要自定义一个注解，使用的时候在需要记录日志的方法上添加这个注解就可以了，首先在启动类的同级包下边新建一个config包，在这个报下边新建new一个名为Log的Annotation文件，文件内容如下：</p><p>package com.web.springbootaoplog.config;</p><p>import java.lang.annotation.ElementType;</p><p>import java.lang.annotation.Retention;</p><p>import java.lang.annotation.RetentionPolicy;</p><p>import java.lang.annotation.Target;</p><p>/**</p><p>* @author Promise</p><p>* @createTime 2018年12月18日 下午9:26:25</p><p>* @description 定义一个方法级别的@log注解</p><p>*/</p><p>@Target(ElementType.METHOD)</p><p>@Retention(RetentionPolicy.RUNTIME)</p><p>public @interface Log {</p><p>String value() default "";</p><p>}</p><p>准备数据库日志表以及实体类，sql接口，xml文件</p><p>既然是向数据库中插入记录，那么前提是需要创建一张记录日志的表，下面给出我的表sql,由于是写样例，我这里这张表设计的很简单，大家可以自行设计。</p><p>CREATE TABLE `sys_log` (</p><p>`id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',</p><p>`user_id` int(11) NOT NULL COMMENT '操作员id',</p><p>`user_action` varchar(255) NOT NULL COMMENT '用户操作',</p><p>`create_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',</p><p>PRIMARY KEY (`id`)</p><p>) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='日志记录表';</p><p>当然还需要创建service接口文件以及接口实现类，这里直接给出代码：</p><p><strong>ISysLogServcie.java</strong></p><p>package com.web.springbootaoplog.service;</p><p>import com.web.springbootaoplog.entity.SysLog;</p><p>/**</p><p>* @author Promise</p><p>* @createTime 2018年12月18日 下午9:29:48</p><p>* @description 日志接口</p><p>*/</p><p>public interface ISysLogService {</p><p>/**</p><p>* 插入日志</p><p>* @param entity</p><p>* @return</p><p>*/</p><p>int insertLog(SysLog entity);</p><p>}</p><p><strong>SysLogServiceImpl.java</strong></p><p>package com.web.springbootaoplog.service.impl;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.stereotype.Service;</p><p>import com.web.springbootaoplog.config.Log;</p><p>import com.web.springbootaoplog.dao.SysLogMapper;</p><p>import com.web.springbootaoplog.entity.SysLog;</p><p>import com.web.springbootaoplog.service.ISysLogService;</p><p>/**</p><p>* @author Promise</p><p>* @createTime 2018年12月18日 下午9:30:57</p><p>* @description</p><p>*/</p><p>@Service("sysLogService")</p><p>public class SysLogServiceImpl implements ISysLogService{</p><p>@Autowired</p><p>private SysLogMapper sysLogMapper;</p><p>@Override</p><p>public int insertLog(SysLog entity) {</p><p>// TODO Auto-generated method stub</p><p>return sysLogMapper.insert(entity);</p><p>}</p><p>}</p><p><strong>AOP的切面和切点</strong></p><p>准备上边的相关文件后，下面来介绍重点--创建AOP切面实现类，同样我们这里将该类放在config包下，命名为LogAsPect.java,内容如下：</p><p>package com.web.springbootaoplog.config;</p><p>import java.lang.reflect.Method;</p><p>import java.util.Arrays;</p><p>import java.util.Date;</p><p>import org.aspectj.lang.JoinPoint;</p><p>import org.aspectj.lang.ProceedingJoinPoint;</p><p>import org.aspectj.lang.annotation.Around;</p><p>import org.aspectj.lang.annotation.Aspect;</p><p>import org.aspectj.lang.annotation.Before;</p><p>import org.aspectj.lang.annotation.Pointcut;</p><p>import org.aspectj.lang.reflect.MethodSignature;</p><p>import org.hibernate.validator.internal.util.logging.LoggerFactory;</p><p>import org.slf4j.Logger;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.core.LocalVariableTableParameterNameDiscoverer;</p><p>import org.springframework.stereotype.Component;</p><p>import com.web.springbootaoplog.entity.SysLog;</p><p>import com.web.springbootaoplog.service.ISysLogService;</p><p>/**</p><p>* @author Promise</p><p>* @createTime 2018年12月18日 下午9:33:28</p><p>* @description 切面日志配置</p><p>*/</p><p>@Aspect</p><p>@Component</p><p>public class LogAsPect {</p><p>private final static Logger log = org.slf4j.LoggerFactory.getLogger(LogAsPect.class);</p><p>@Autowired</p><p>private ISysLogService sysLogService;</p><p>//表示匹配带有自定义注解的方法</p><p>@Pointcut("@annotation(com.web.springbootaoplog.config.Log)")</p><p>public void pointcut() {}</p><p>@Around("pointcut()")</p><p>public Object around(ProceedingJoinPoint point) {</p><p>Object result =null;</p><p>long beginTime = System.currentTimeMillis();</p><p>try {</p><p>log.info("我在目标方法之前执行！");</p><p>result = point.proceed();</p><p>long endTime = System.currentTimeMillis();</p><p>insertLog(point,endTime-beginTime);</p><p>} catch (Throwable e) {</p><p>// TODO Auto-generated catch block</p><p>}</p><p>return result;</p><p>}</p><p>private void insertLog(ProceedingJoinPoint point ,long time) {</p><p>MethodSignature signature = (MethodSignature)point.getSignature();</p><p>Method method = signature.getMethod();</p><p>SysLog sys_log = new SysLog();</p><p>Log userAction = method.getAnnotation(Log.class);</p><p>if (userAction != null) {</p><p>// 注解上的描述</p><p>sys_log.setUserAction(userAction.value());</p><p>}</p><p>// 请求的类名</p><p>String className = point.getTarget().getClass().getName();</p><p>// 请求的方法名</p><p>String methodName = signature.getName();</p><p>// 请求的方法参数值</p><p>String args = Arrays.toString(point.getArgs());</p><p>//从session中获取当前登陆人id</p><p>// Long useride = (Long)SecurityUtils.getSubject().getSession().getAttribute("userid");</p><p>Long userid = 1L;//应该从session中获取当前登录人的id，这里简单模拟下</p><p>sys_log.setUserId(userid);</p><p>sys_log.setCreateTime(new java.sql.Timestamp(new Date().getTime()));</p><p>log.info("当前登陆人：{},类名:{},方法名:{},参数：{},执行时间：{}",userid, className, methodName, args, time);</p><p>sysLogService.insertLog(sys_log);</p><p>}</p><p>}</p><p>这里简单介绍下关于AOP的几个重要注解：</p><ul><li>@Aspect:这个注解表示将当前类视为一个切面类</li><li>@Component：表示将当前类交由Spring管理。</li><li>@Pointcut:切点表达式,定义我们的匹配规则，上边我们使用@Pointcut("@annotation(com.web.springbootaoplog.config.Log)")表示匹配带有我们自定义注解的方法。</li><li>@Around:环绕通知，可以在目标方法执行前后执行一些操作，以及目标方法抛出异常时执行的操作。</li></ul><p>下面看一段关键的代码：</p><p>log.info("我在目标方法之前执行！");</p><p>result = point.proceed();</p><p>long endTime = System.currentTimeMillis();</p><p>insertLog(point,endTime-beginTime);</p><p>其中result = point.proceed();这句话表示执行目标方法,可以看出我们在这段代码执行之前打印了一句日志，并在执行之后调用了insertLog()插入日志的方法，并且在方法中我们可以拿到目标方法所在的类名，方法名，参数等重要的信息。</p><p><strong>测试控制器</strong></p><p>在controller包下新建一个HomeCOntroller.java(名字大家随意),内容如下：</p><p>package com.web.springbootaoplog.controller;</p><p>import java.util.HashMap;</p><p>import java.util.Map;</p><p>import org.springframework.beans.factory.annotation.Autowired;</p><p>import org.springframework.stereotype.Controller;</p><p>import org.springframework.web.bind.annotation.RequestBody;</p><p>import org.springframework.web.bind.annotation.RequestMapping;</p><p>import org.springframework.web.bind.annotation.RequestMethod;</p><p>import org.springframework.web.bind.annotation.ResponseBody;</p><p>import com.web.springbootaoplog.config.Log;</p><p>import com.web.springbootaoplog.entity.SysLog;</p><p>import com.web.springbootaoplog.service.ISysLogService;</p><p>/**</p><p>* @author Promise</p><p>* @createTime 2019年1月2日 下午10:35:30</p><p>* @description 测试controller</p><p>*/</p><p>@Controller</p><p>public class HomeController {</p><p>private final static Logger log = org.slf4j.LoggerFactory.getLogger(HomeController.class);</p><p>@Autowired</p><p>private ISysLogService logService;</p><p>@RequestMapping("/aop")</p><p>@ResponseBody</p><p>@Log("测试aoplog")</p><p>public Object aop(String name, String nick) {</p><p>Map&lt;String, Object> map =new HashMap&lt;>();</p><p>log.info("我被执行了！");</p><p>map.put("res", "ok");</p><p>return map;</p><p>}</p><p>}</p><p>定义一个测试方法，带有两个参数，并且为该方法添加了我们自定义的@Log注解，启动项目，浏览器访问localhost:8080/aop?name=xfr&nick=eran,这时候查看eclipse控制台的部分输出信息如下：</p><p>2019-01-24 22:02:17.682 INFO 3832 --- [nio-8080-exec-1] c.web.springbootaoplog.config.LogAsPect : 我在目标方法之前执行！</p><p>2019-01-24 22:02:17.688 INFO 3832 --- [nio-8080-exec-1] c.w.s.controller.HomeController : 我被执行了！</p><p>2019-01-24 22:02:17.689 INFO 3832 --- [nio-8080-exec-1] c.web.springbootaoplog.config.LogAsPect : 当前登陆人：1,类名:com.web.springbootaoplog.controller.HomeController,方法名:aop,参数：[xfr, eran],执行时间：6</p><p>可以看到我们成功在目标方法执行前后插入了一些逻辑代码，现在再看数据库里边的数据：</p><div class=pgc-img><img alt="Spring boot学习（六）Spring boot实现AOP记录操作日志" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6824f504d2264a748492cd7ceb6732ba></div><p>成功记录了一条数据。</p><p><strong>实现AOP记录面向开发者的日志</strong></p><p>首先这里我列举一个使用该方式的应用场景，在项目中出现了bug，我们想要知道前台的请求是否进入了我们控制器中，以及参数的获取情况，下面开始介绍实现步骤。</p><p>其实原理跟上边是一样的，只是切点的匹配规则变了而已，而且不用将日志记录到数据库，打印出来即可。</p><p>首先在LogAsPect.java中定义一个新的切点表达式，如下：</p><p>@Pointcut("execution(public * com.web.springbootaoplog.controller..*.*(..))")</p><p>public void pointcutController() {}</p><p>@Pointcut("execution(public * com.web.springbootaoplog.controller..*.*(..))")表示匹配com.web.springbootaoplog.controller包及其子包下的所有公有方法。</p><p>再添加匹配到方法时我们要做的操作：</p><p>@Before("pointcutController()")</p><p>public void around2(JoinPoint point) {</p><p>//获取目标方法</p><p>String methodNam = point.getSignature().getDeclaringTypeName() + "." + point.getSignature().getName();</p><p>//获取方法参数</p><p>String params = Arrays.toString(point.getArgs());</p><p>log.info("get in {} params :{}",methodNam,params);</p><p>}</p><p>@Before:表示目标方法执行之前执行以下方法体的内容。</p><p>再在控制器中添加一个测试方法：</p><p>@RequestMapping("/testaop3")</p><p>@ResponseBody</p><p>public Object testAop3(String name, String nick) {</p><p>Map&lt;String, Object> map = new HashMap&lt;>();</p><p>map.put("res", "ok");</p><p>return map;</p><p>}</p><p>可以看到这个方法我们并没有加上@Log注解，重启项目，浏览器访问localhost:8080/testaop3?name=xfr&nick=eran,这时候查看eclipse控制台的部分输出信息如下：</p><p>2019-01-24 23:19:49.108 INFO 884 --- [nio-8080-exec-1] c.web.springbootaoplog.config.LogAsPect : get in com.web.springbootaoplog.controller.HomeController.testAop3 params :[xfr, eran]</p><p>打印出了关键日志，这样我们就能知道是不是进入了该方法，参数获取是否正确等关键信息。</p><p>这里有的朋友或许会有疑问这样会不会与添加了@Log的方法重复了呢，的确会，所以在项目中我通常都将@Log注解用在了Service层的方法上，这样也更加合理。</p><p><strong>结语</strong></p><p>好了，关于Aop记录日志的内容就介绍这么多了，下一篇再见。bye~</p><div class=pgc-img><img alt="Spring boot学习（六）Spring boot实现AOP记录操作日志" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/1f93e24e-004b-4597-9210-22c95dd7263f></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Spring','boot','学习'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>