<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>代码规范—使用 TypeScript 装饰器 | 极客快訊</title><meta property="og:title" content="代码规范—使用 TypeScript 装饰器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/dfic-imagehandler/4b5097e2-c4fd-4d37-9c54-707760739775"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7b70c367.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7b70c367.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="代码规范—使用 TypeScript 装饰器"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7b70c367.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>代码规范—使用 TypeScript 装饰器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>装饰器让程序员可以编写元信息以内省代码。装饰器的最佳使用场景是横切关注点——面向切面编程。<br></p><blockquote><p><strong>面向切面编程（AOP）</strong> 是一种编程范式，它允许我们分离横切关注点，借此达到增加模块化程度的目标。它可以在不修改代码自身的前提下，给已有代码增加额外的行为（通知）。</p></blockquote><pre>@log// 类装饰器classPerson { constructor(private firstName: string, private lastName: string) {}@log// 方法装饰器 getFullName() {return`${this.firstName} ${this.lastName}`; }}const person = newPerson('Mohan', 'Ram');person.getFullName();</pre><p>上面的代码展示了装饰器多么具有声明性。下面我们将介绍装饰器的细节：</p><ol start=1><li>什么是装饰器？它的目的和类型</li><li>装饰器的签名</li><li>方法装饰器</li><li>属性装饰器</li><li>参数装饰器</li><li>访问器装饰器</li><li>类装饰器</li><li>装饰器工厂</li><li>元信息反射 API</li><li>结语</li></ol><p>什么是装饰器？它的目的和类型</p><blockquote><p>装饰器是一种特殊的声明，可附加在类、方法、访问器、属性、参数声明上。</p></blockquote><p>装饰器使用 @expression 的形式，其中 expression 必须能够演算为在运行时调用的函数，其中包括装饰声明信息。</p><p>它起到了以声明式方法将元信息添加至已有代码的作用。</p><p>装饰器类型及其执行优先级为</p><ol start=1><li>类装饰器——优先级 4 （对象实例化，静态）</li><li>方法装饰器——优先级 2 （对象实例化，静态）</li><li>访问器或属性装饰器——优先级 3 （对象实例化，静态）</li><li>参数装饰器——优先级 1 （对象实例化，静态）</li></ol><p>注意，如果装饰器应用于类构造函数的参数，那么不同装饰器的优先级为：1. 参数装饰器，2. 方法装饰器，3. 访问器或参数装饰器，4. 构造器参数装饰器，5. 类装饰器。</p><pre>// 这是一个装饰器工厂——有助于将用户参数传给装饰器声明function f() { console.log("f(): evaluated");returnfunction (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log("f(): called"); }}function g() { console.log("g(): evaluated");returnfunction (target, propertyKey: string, descriptor: PropertyDescriptor) { console.log("g(): called"); }}class C {@f()@g() method() {}}// f(): evaluated// g(): evaluated// g(): called// f(): called</pre><p>我们看到，上面的代码中， f 和 g 返回了另一个函数（装饰器函数）。f 和 g 称为装饰器工厂。</p><blockquote><p><strong>装饰器工厂</strong> 帮助用户传递可供装饰器利用的参数。</p></blockquote><p>我们还可以看到，<strong>演算顺序</strong>为<strong>由顶向下</strong>，<strong>执行顺序</strong>为<strong>由底向上</strong>。</p><p>装饰器的签名</p><pre>declare type ClassDecorator = &lt;TFunctionextendsFunction&gt;(target: TFunction) =&gt; TFunction | void;declare type PropertyDecorator = (target: Object, propertyKey: string | symbol) =&gt; void;declare type MethodDecorator = &lt;T&gt;( target: Object, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor&lt;T&gt;) =&gt;TypedPropertyDescriptor&lt;T&gt; | void;</pre><p>方法装饰器</p><p>从上面的签名中，我们可以看到方法装饰器函数有三个参数：</p><ol start=1><li><strong>target</strong> —— 当前对象的原型，也就是说，假设 Employee 是对象，那么 target 就是 Employee.prototype</li><li><strong>propertyKey</strong> —— 方法的名称</li><li><strong>descriptor</strong> —— 方法的属性描述符，即 Object.getOwnPropertyDescriptor(Employee.prototype,propertyKey)</li></ol><pre>exportfunction logMethod( target: Object, propertyName: string, propertyDescriptor: PropertyDescriptor): PropertyDescriptor {// target === Employee.prototype// propertyName === "greet"// propertyDesciptor === Object.getOwnPropertyDescriptor(Employee.prototype, "greet")const method = propertyDesciptor.value; propertyDesciptor.value = function (...args: any[]) {// 将 greet 的参数列表转换为字符串constparams = args.map(a =&gt; JSON.stringify(a)).join();// 调用 greet() 并获取其返回值const result = method.apply(this, args);// 转换结尾为字符串const r = JSON.stringify(result);// 在终端显示函数调用细节 console.log(`Call: ${propertyName}(${params}) =&gt; ${r}`);// 返回调用函数的结果return result; }return propertyDesciptor;};classEmployee { constructor(private firstName: string, private lastName: string ) {}@logMethod greet(message: string): string {return`${this.firstName} ${this.lastName} says: ${message}`; }}const emp = newEmployee('Mohan Ram', 'Ratnakumar');emp.greet('hello');</pre><p>上面的代码应该算是自解释的——让我们看看编译后的 JavaScript 是什么样的。</p><pre>"use strict";var __decorate = (this &amp;&amp; this.__decorate) ||function (decorators, target, key, desc) {// 函数参数长度var c = arguments.length/** * 处理结果 * 如果仅仅传入了装饰器数组和目标，那么应该是个类装饰器。 * 否则，如果描述符（第 4 个参数）为 null，就根据已知值准备属性描述符， * 反之则使用同一描述符。 */var r = c &lt; 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;// 声明存储装饰器的变量var d;// 如果原生反射可用，使用原生反射触发装饰器if (typeofReflect === "object" &amp;&amp; typeofReflect.decorate === "function") { r = Reflect.decorate(decorators, target, key, desc) }else {// 自右向左迭代装饰器for (var i = decorators.length - 1; i &gt;= 0; i--) {// 如果装饰器合法，将其赋值给 dif (d = decorators[i]) {/** * 如果仅仅传入了装饰器数组和目标，那么应该是类装饰器， * 传入目标调用装饰器。 * 否则，如果 4 个参数俱全，那么应该是方法装饰器， * 据此进行调用。 * 反之则使用同一描述符。 * 如果传入了 3 个参数，那么应该是属性装饰器，可进行相应的调用。 * 如果以上条件皆不满足，返回处理的结果。 */ r = (c &lt; 3 ? d(r) : c &gt; 3 ? d(target, key, r) : d(target, key)) || r } } };/** * 由于只有方法装饰器需要根据应用装饰器的结果修正其属性， * 所以最后返回处理好的 r */return c &gt; 3 &amp;&amp; r &amp;&amp; Object.defineProperty(target, key, r), r; };varEmployee = /** @class */ (function () {functionEmployee(firstName, lastName) {this.firstName = firstName;this.lastName = lastName; }Employee.prototype.greet = function (message) {returnthis.firstName + " " + this.lastName + " says: " + message; };// typescript 调用 `__decorate` 辅助函数，// 以便在对象原型上应用装饰器 __decorate([ logMethod ], Employee.prototype, "greet");returnEmployee;}());var emp = newEmployee('Mohan Ram', 'Ratnakumar');emp.greet('hello');</pre><p>让我们开始分析 Employee 函数——构造器初始化 name 参数和 greet 方法，将其加入原型。</p><pre>__decorate([logMethod], Employee.prototype, "greet");</pre><p>这是 TypeScript 自动生成的通用方法，它根据装饰器类型和相应参数处理装饰器函数调用。</p><p>该函数有助于内省方法调用，并为开发者铺平了处理类似<strong>日志</strong>、<strong>记忆化</strong>、<strong>应用配置</strong>等横切关注点的道路。</p><p>在这个例子中，我们仅仅打印了函数调用及其参数、响应。</p><p>注意，阅读 __decorate 方法中的详细注释可以理解其内部机制。</p><p>属性装饰器</p><p>属性装饰器函数有两个参数：</p><ol start=1><li><strong>target</strong> —— 当前对象的原型，也就是说，假设 Employee 是对象，那么 target 就是 Employee.prototype</li><li><strong>propertyKey</strong> —— 属性的名称</li></ol><pre>function logParameter(target: Object, propertyName: string) {// 属性值let _val = this[propertyName];// 属性读取访问器const getter = () =&gt; { console.log(`Get: ${propertyName} =&gt; ${_val}`);return _val; };// 属性写入访问器const setter = newVal =&gt; { console.log(`Set: ${propertyName} =&gt; ${newVal}`); _val = newVal; };// 删除属性if (deletethis[propertyName]) {// 创建新属性及其读取访问器、写入访问器Object.defineProperty(target, propertyName, {get: getter,set: setter, enumerable: true, configurable: true }); }}classEmployee {@logParameter name: string;}const emp = newEmployee();emp.name = 'Mohan Ram';console.log(emp.name);// Set: name =&gt; Mohan Ram// Get: name =&gt; Mohan Ram// Mohan Ram</pre><p>上面的代码中，我们在装饰器中内省属性的可访问性。下面是编译后的代码。</p><pre>varEmployee = /** @class */ (function () {functionEmployee() { } __decorate([ logParameter ], Employee.prototype, "name");returnEmployee;}());var emp = newEmployee();emp.name = 'Mohan Ram'; // Set: name =&gt; Mohan Ramconsole.log(emp.name); // Get: name =&gt; Mohan Ram</pre><p>参数装饰器</p><p>参数装饰器函数有三个参数：</p><ol start=1><li><strong>target</strong> —— 当前对象的原型，也就是说，假设 Employee 是对象，那么 target 就是 Employee.prototype</li><li><strong>propertyKey</strong> —— 参数的名称</li><li><strong>index</strong> —— 参数数组中的位置</li></ol><pre>function logParameter(target: Object, propertyName: string, index: number) {// 为相应方法生成元数据键，以储存被装饰的参数的位置const metadataKey = `log_${propertyName}_parameters`;if (Array.isArray(target[metadataKey])) { target[metadataKey].push(index); }else { target[metadataKey] = [index]; }}classEmployee { greet(@logParameter message: string): string {return`hello ${message}`; }}const emp = newEmployee();emp.greet('hello');</pre><p>在上面的代码中，我们收集了所有被装饰的方法参数的索引或位置，作为元数据加入对象的原型。下面是编译后的代码。</p><pre>// 返回接受参数索引和装饰器的函数var __param = (this &amp;&amp; this.__param) || function (paramIndex, decorator) {// 该函数返回装饰器returnfunction (target, key) { decorator(target, key, paramIndex); }};varEmployee = /** @class */ (function () {functionEmployee() {}Employee.prototype.greet = function (message) {return"hello " + message; }; __decorate([ __param(0, logParameter) ], Employee.prototype, "greet");returnEmployee;}());var emp = newEmployee();emp.greet('hello');</pre><p>类似之前见过的 __decorate 函数， __param 函数返回一个封装参数装饰器的装饰器。</p><p>如我们所见，调用参数装饰器时，会忽略其返回值。这意味着，调用 __param 函数时，其返回值不会用来覆盖参数值。</p><p>这就是<strong>参数装饰器不返回</strong>的原因所在。</p><p>访问器装饰器</p><p>访问器不过是类声明中属性的读取访问器和写入访问器。</p><p><strong>访问器装饰器</strong>应用于访问器的<strong>属性描述符</strong>，可用于观测、修改、替换访问器的定义。</p><pre>function enumerable(value: boolean) {returnfunction ( target: any, propertyKey: string, descriptor: PropertyDescriptor) { console.log('decorator - sets the enumeration part of the accessor'); descriptor.enumerable = value; };}classEmployee {private _salary: number;private _name: string;@enumerable(false)get salary() { return`Rs. ${this._salary}`; }set salary(salary: any) { this._salary = +salary; }@enumerable(true)get name() {return`Sir/Madam, ${this._name}`; }set name(name: string) {this._name = name; }}const emp = newEmployee();emp.salary = 1000;for (let prop in emp) { console.log(`enumerable property = ${prop}`);}// salary 属性不在清单上，因为我们将其设为假// output:// decorator - sets the enumeration part of the accessor// decorator - sets the enumeration part of the accessor// enumerable property = _salary// enumerable property = name</pre><p>上面的例子中，我们定义了两个访问器 name 和 salary，并通过装饰器设置是否将其列入清单，据此决定对象的行为。name 将列入清单，而 salary 不会。</p><p>注意：TypeScript 不允许同时装饰单一成员的 get 和 set 访问器。相反，所有成员的装饰器都必须应用于首个指定的访问器（根据文档顺序）。这是因为装饰器应用于属性描述符，属性描述符结合了 get 和 set访问器，而不是分别应用于每项声明。</p><p>下面是编译的代码。</p><pre>function enumerable(value) {returnfunction (target, propertyKey, descriptor) { console.log('decorator - sets the enumeration part of the accessor'); descriptor.enumerable = value; };}varEmployee = /** @class */ (function () {functionEmployee() { }Object.defineProperty(Employee.prototype, "salary", {get: function () { return"Rs. " + this._salary; },set: function (salary) { this._salary = +salary; }, enumerable: true, configurable: true });Object.defineProperty(Employee.prototype, "name", {get: function () {return"Sir/Madam, " + this._name; },set: function (name) {this._name = name; }, enumerable: true, configurable: true }); __decorate([ enumerable(false) ], Employee.prototype, "salary", null); __decorate([ enumerable(true) ], Employee.prototype, "name", null);returnEmployee;}());var emp = newEmployee();emp.salary = 1000;for (var prop in emp) { console.log("enumerable property = " + prop);}</pre><p>类装饰器</p><p>类装饰器应用于类的构造器，可用于观测、修改、替换类定义。</p><pre>exportfunction logClass(target: Function) {// 保存一份原构造器的引用const original = target;// 生成类的实例的辅助函数function construct(constructor, args) {const c: any = function () {return constructor.apply(this, args); } c.prototype = constructor.prototype;returnnew c(); }// 新构造器行为const f: any = function (...args) { console.log(`New: ${original['name']} is created`);return construct(original, args); }// 复制 prototype 属性，保持 intanceof 操作符可用 f.prototype = original.prototype;// 返回新构造器（将覆盖原构造器）return f;}@logClassclassEmployee {}let emp = newEmployee();console.log('emp instanceof Employee');console.log(emp instanceofEmployee); // true</pre><p>上面的装饰器声明了一个名为 original 的变量，将其值设为被装饰的类构造器。</p><p>接着声明了名为 construct 的辅助函数。该函数用于创建类的实例。</p><p>我们接下来创建了一个名为 f 的变量，该变量将用作新构造器。该函数调用原构造器，同时在控制台打印实例化的类名。这正是我们<strong>给原构造器加入额外行为</strong>的地方。</p><p>原构造器的原型复制到 f，以确保创建一个 Employee 新实例的时候， instanceof 操作符的效果符合预期。</p><p>新构造器一旦就绪，我们便返回它，以完成类构造器的实现。</p><p>新构造器就绪之后，每次创建实例时会在控制台打印类名。</p><p>编译后的代码如下。</p><pre>varEmployee = /** @class */ (function () {functionEmployee() { }Employee = __decorate([ logClass ], Employee);returnEmployee;}());var emp = newEmployee();console.log('emp instanceof Employee');console.log(emp instanceofEmployee);</pre><p>在编译后的代码中，我们注意到两处不同：</p><ol start=1><li>如你所见，传给 __decorate 的参数有两个，装饰器数组和构造器函数。</li><li>TypeScript 编译器使用 __decorate 的返回值以覆盖原构造器。</li></ol><p>这正是<strong>类装饰器必须返回一个构造函数</strong>的原因所在。</p><p>装饰器工厂</p><p>由于每种装饰器都有它自身的调用签名，我们可以使用装饰器工厂来泛化装饰器调用。</p><pre>import { logClass } from'./class-decorator';import { logMethod } from'./method-decorator';import { logProperty } from'./property-decorator';import { logParameter } from'./parameter-decorator';// 装饰器工厂，根据传入的参数调用相应的装饰器exportfunction log(...args) {switch (args.length) {case3: // 可能是方法装饰器或参数装饰器// 如果第三个参数是数字，那么它是索引，所以这是参数装饰器iftypeof args[2] === "number") {return logParameter.apply(this, args); }return logMethod.apply(this, args);case2: // 属性装饰器return logProperty.apply(this, args);case1: // 类装饰器return logClass.apply(this, args);default: // 参数数目不合法thrownewError('Not a valid decorator'); }}@logclassEmployee {@logprivate name: string; constructor(name: string) {this.name = name; }@log greet(@log message: string): string {return`${this.name} says: ${message}`; }}</pre><p>元信息反射 API</p><p>元信息反射 API （例如 Reflect）能够用来以标准方式组织元信息。</p><p>「反射」的意思是代码可以侦测同一系统中的其他代码（或其自身）。</p><p>反射在组合/依赖注入、运行时类型断言、测试等使用场景下很有用。</p><pre>import"reflect-metadata";// 参数装饰器使用反射 api 存储被装饰参数的索引exportfunction logParameter(target: Object, propertyName: string, index: number) {// 获取目标对象的元信息const indices = Reflect.getMetadata(`log_${propertyName}_parameters`, target, propertyName) || []; indices.push(index);// 定义目标对象的元信息Reflect.defineMetadata(`log_${propertyName}_parameters`, indices, target, propertyName);}// 属性装饰器使用反射 api 获取属性的运行时类型exportfunction logProperty(target: Object, propertyName: string): void {// 获取对象属性的设计类型var t = Reflect.getMetadata("design:type", target, propertyName); console.log(`${propertyName} type: ${t.name}`); // name type: String}classEmployee {@logPropertyprivate name: string; constructor(name: string) {this.name = name; } greet(@logParameter message: string): string {return`${this.name} says: ${message}`; }}</pre><p>上面的代码用到了 reflect-metadata 这个库。其中，我们使用了反射元信息的设计键（例如：design:type）。目前只有三个：</p><ul class=list-paddingleft-2><li><strong>类型元信息</strong>用了元信息键 design:type。</li><li><strong>参数类型元信息</strong>用了元信息键 design:paramtypes。</li><li><strong>返回类型元信息</strong>用了元信息键 design:returntype。</li></ul><p>有了反射，我们就能够在运行时得到以下信息：</p><ul class=list-paddingleft-2><li>实体<strong>名</strong>。</li><li>实体<strong>类型</strong>。</li><li>实体实现的<strong>接口</strong>。</li><li>实体<strong>构造器参数</strong>的名称和类型。</li></ul><p>结语</p><ul class=list-paddingleft-2><li><strong>装饰器</strong> 不过是在<strong>设计时（design time）</strong>帮助<strong>内省</strong>代码，<strong>注解</strong>及修改类和属性的函数。</li><li>Yehuda Katz 提议在 ECMAScript 2016 标准中加入装饰器特性：tc39/proposal-decorators</li><li>我们可以通过<strong>装饰器工厂</strong>将用户提供的参数传给装饰器。</li><li>有 4 种装饰器：<strong>类</strong>装饰器、<strong>方法</strong>装饰器、<strong>属性/访问器</strong>装饰器、<strong>参数</strong>装饰器。</li><li><strong>元信息反射 API</strong> 有助于以标准方式在对象中加入元信息，以及在<strong>运行时</strong>获取<strong>设计类型信息</strong>。</li></ul><p>我把文中所有代码示例都放到了 mohanramphp/typescript-decorators 这个 Git 仓库中。谢谢阅读！</p><div class=pgc-img><img alt="代码规范—使用 TypeScript 装饰器" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/4b5097e2-c4fd-4d37-9c54-707760739775><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'代码','规范','TypeScript'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>