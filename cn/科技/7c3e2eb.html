<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>加解密算法分析 | 极客快訊</title><meta property="og:title" content="加解密算法分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a818781cfb0b4f73a68646ab958892ac"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7c3e2eb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7c3e2eb.html><meta property="article:published_time" content="2020-10-29T20:50:40+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:40+08:00"><meta name=Keywords content><meta name=description content="加解密算法分析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7c3e2eb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>加解密算法分析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>日常开发中，无论你是使用什么语言，都应该遇到过使用加解密的使用场景，比如接口数据需要加密传给前端保证数据传输的安全；HTTPS使用证书的方式首先进行非对称加密，将客户端的私匙传递给服务端，然后双方后面的通信都使用该私匙进行对称加密传输；使用MD5进行文件一致性校验，等等很多的场景都使用到了加解密技术。</p><p>很多时候我们对于什么时候要使用什么样的加解密方式是很懵的。因为可用的加解密方案实在是太多，大家对加解密技术的类型可能不是很清楚，今天这篇文章就来梳理一下目前主流的加解密技术，本篇文档只针对算法做科普性说明，不涉及具体算法分析。日常使用的加解密大致可以分为以下四类：</p><ol start=1><li><strong>散列函数(也称信息摘要)算法</strong></li><li><strong>对称加密算法</strong></li><li><strong>非对称加密算法</strong></li><li><strong>组合加密技术</strong></li></ol><h4 class=pgc-h-arrow-right>1. 散列函数算法#</h4><p>听名字似乎不是一种加密算法，类似于给一个对象计算出hash值。所以这种算法一般用于数据特征提取。常用的散列函数包括：MD5、SHA1、SHA2（包括SHA128、SHA256等）散列函数的应用很广，散列函数有个特点，它是一种单向加密算法，只能加密、无法解密。</p><h5 class=pgc-h-arrow-right>1.1 MD5</h5><p>先来看MD5算法，MD5算法是广为使用的数据特征提取算法，最常见的就是我们在下载一些软件，网站都会提供MD5值给你进行校验，你可以通过MD5值是否一致来检查当前文件是否被别人篡改。MD5算法具有以下特点：</p><ol start=1><li>任意长度的数据得到的MD5值长度都是相等的；</li><li>对原数据进行任一点修改，得到的MD5值就会有很大的变化；</li><li>散列函数的不可逆性，即已知原数据，无法通过特征值反向获取原数据。（需要说明的是2004年的国际密码讨论年会（CRYPTO）尾声，王小云及其研究同事展示了MD5、SHA-0及其他相关杂凑函数的杂凑冲撞。也就是说，她找出了第一个 两个值不同，但 MD5 值相同的碰撞的例子。这个应该不能称之为破解）</li></ol><h5 class=pgc-h-arrow-right>1.2 MD5用途：</h5><ol start=1><li>防篡改。上面说过用于文件完整性校验。</li><li>用于不想让别人看到明文的地方。比如用户密码入库，可以将用户密码使用MD5加密存储，下次用户输入密码登录只用将他的输入进行MD5加密与数据库的值判断是否一致即可，这样就有效防止密码泄露的风险。</li><li>用于文件秒传。比如百度云的文件秒传功能可以用这种方式来实现。在你点击上传的时候，前端同学会先计算文件的MD5值然后与服务端比对是否存在，如果有就会告诉你文件上传成功，即完成所谓的秒传。</li></ol><p>在JDK中提供了MD5的实现：java.security包中有个类MessageDigest，MessageDigest 类为应用程序提供信息摘要算法的功能，如 MD5 或 SHA 算法。信息摘要是安全的单向哈希函数，它接收任意大小的数据，输出固定长度的哈希值。</p><p>MessageDigest 对象使用getInstance函数初始化，该对象通过使用 update 方法处理数据。任何时候都可以调用 reset 方法重置摘要。一旦所有需要更新的数据都已经被更新了，应该调用 digest 方法之一完成哈希计算。</p><p>对于给定数量的更新数据，digest 方法只能被调用一次。digest 被调用后，MessageDigest 对象被重新设置成其初始状态。</p><p>下面的例子展示了使用JDK自带的MessageDigest类使用MD5算法。同时也展示了如果使用了update方法后没有调用digest方法，则会累计当前所有的update中的值在下一次调用digest方法的时候一并输出：</p><pre><code>Copypackage other;import java.security.MessageDigest;/** * @author: rickiyang * @date: 2019/9/13 * @description: */public class MD5Test {    static char[] hex = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};    public static void main(String[] args) {        try {            //申明使用MD5算法            MessageDigest md5 = MessageDigest.getInstance("MD5");            md5.update("a".getBytes());//            System.out.println("md5(a)=" + byte2str(md5.digest()));            md5.update("a".getBytes());            md5.update("bc".getBytes());            System.out.println("md5(abc)=" + byte2str(md5.digest()));            //你会发现上面的md5值与下面的一样            md5.update("abc".getBytes());            System.out.println("md5(abc)=" + byte2str(md5.digest()));        } catch (Exception e) {            e.printStackTrace();        }    }    /**     * 将字节数组转换成十六进制字符串     *     * @param bytes     * @return     */    private static String byte2str(byte[] bytes) {        int len = bytes.length;        StringBuffer result = new StringBuffer();        for (int i = 0; i &lt; len; i++) {            byte byte0 = bytes[i];            result.append(hex[byte0 &gt;&gt;&gt; 4 &amp; 0xf]);            result.append(hex[byte0 &amp; 0xf]);        }        return result.toString();    }}</code></pre><p>输出：</p><pre><code>Copymd5(a)=0CC175B9C0F1B6A831C399E269772661md5(abc)=900150983CD24FB0D6963F7D28E17F72md5(abc)=900150983CD24FB0D6963F7D28E17F72</code></pre><h5 class=pgc-h-arrow-right>2.1 SHA系列算法</h5><p>Secure Hash Algorithm，是一种与MD5同源的数据加密算法。SHA算法能计算出一个数位信息所对应到的，长度固定的字串，又称信息摘要。而且如果输入信息有任何的不同，输出的对应摘要不同的机率非常高。因此SHA算法也是FIPS所认证的五种安全杂凑算法之一。原因有两点：一是由信息摘要反推原输入信息，从计算理论上来说是极为困难的；二是，想要找到两组不同的输入信息发生信息摘要碰撞的机率，从计算理论上来说是非常小的。任何对输入信息的变动，都有很高的机率导致的信息摘要大相径庭。</p><p>SHA实际上是一系列算法的统称，分别包括：SHA-1、SHA-224、SHA-256、SHA-384以及SHA-512。后面4中统称为SHA-2，事实上SHA-224是SHA-256的缩减版，SHA-384是SHA-512的缩减版。各中SHA算法的数据比较如下表，其中的长度单位均为位：</p><p><strong>类别SHA-1SHA-224SHA-256SHA-384SHA-512</strong>消息摘要长度160224256384512消息长度小于264位小于264位小于264位小于2128位小于2128位分组长度51251251210241024计算字长度3232326464计算步骤数8064648080</p><p>SHA-1算法输入报文的最大长度不超过264位，产生的输出是一个160位的报文摘要。输入是按512 位的分组进行处理的。SHA-1是不可逆的、防冲突，并具有良好的雪崩效应。</p><p>上面提到的MessageDigest类同时也支持SHA系列算法，使用方式与MD5一样，注意SHA不同的类型：</p><pre><code>CopyMessageDigest md = MessageDigest.getInstance("SHA");MessageDigest md = MessageDigest.getInstance("SHA-224");MessageDigest md = MessageDigest.getInstance("SHA-384");</code></pre><h4 class=pgc-h-arrow-right>2. 对称加密算法#</h4><p>所谓的对称加密，意味着加密者和解密者需要同时持有一份相同的密匙，加密者用密匙加密，解密者用密匙解密即可。</p><p>常用的对称加密算法包括DES算法、AES算法等。 由于对称加密需要一个秘钥，而秘钥在加密者与解密者之间传输又很难保证安全性，所以目前用对称加密算法的话主要是用在加密者解密者相同，或者加密者解密者相对固定的场景。</p><p>对称算法又可分为两类：</p><p>第一种是一次只对明文中的单个位（有时对字节）运算的算法称为序列算法或序列密码；</p><p>另一种算法是对明文的一组位进行运算，这些位组称为分组，相应的算法称为分组算法或分组密码。现代计算机密码算法的典型分组长度为64位――这个长度既考虑到分析破译密码的难度，又考虑到使用的方便性。</p><h5 class=pgc-h-arrow-right>2.1 BASE64算法</h5><p>我们很熟悉的BASE64算法就是一个没有秘密的对称加密算法。因为他的加密解密算法都是公开的，所以加密数据是没有任何秘密可言，典型的防菜鸟不防程序员的算法。</p><p><strong>BASE64算法作用：</strong></p><ol start=1><li>用于简单的数据加密传输；</li><li>用于数据传输过程中的转码，解决中文问题和特殊符号在网络传输中的乱码现象。网络传输过程中如果双方使用的编解码字符集方式不一致，对于中文可能会出现乱码；与此类似，网络上传输的字符并不全是可打印的字符，比如二进制文件、图片等。Base64的出现就是为了解决此问题，它是基于64个可打印的字符来表示二进制的数据的一种方法。</li></ol><p><strong>BASE64原理</strong></p><p>BASE64的原理比较简单，每当我们使用BASE64时都会先定义一个类似这样的数组：</p><pre><code>Copy['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']</code></pre><p>上面就是BASE64的索引表，字符选用了"A-Z、a-z、0-9、+、/" 64个可打印字符，这是标准的BASE64协议规定。在日常使用中我们还会看到“=”或“==”号出现在BASE64的编码结果中，“=”在此是作为填充字符出现。</p><p>JDK提供了BASE64的实现：BASE64Encoder，我们可以直接使用：</p><pre><code>Copy//使用base64加密BASE64Encoder encoder = new BASE64Encoder();  String encrypt = encoder.encode(str.getBytes());  //使用base64解密BASE64Decoder decoder = new BASE64Decoder();  String decrypt = new String(decoder.decodeBuffer(encryptStr));  </code></pre><h5 class=pgc-h-arrow-right>2.2 DES</h5><p>DES (Data Encryption Standard)，在很长时间内，许多人心目中“密码生成”与DES一直是个同义词。</p><p>DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。它的密钥长度是56位（因为每个第8 位都用作奇偶校验），密钥可以是任意的56位的数，而且可以任意时候改变。</p><p>DES加密过程大致如下：</p><ol start=1><li>首先需要从用户处获取一个64位长的密码口令，然后通过等分、移位、选取和迭代形成一套16个加密密钥，分别供每一轮运算中使用；</li><li>然后将64位的明文分组M进行操作，M经过一个初始置换IP，置换成m0。将m0明文分成左半部分和右半部分m0 = (L0，R0)，各32位长。然后进行16轮完全相同的运算（迭代），这些运算被称为函数f，在每一轮运算过程中数据与相应的密钥结合；</li><li>在每一轮迭代中密钥位移位，然后再从密钥的56位中选出48位。通过一个扩展置换将数据的右半部分扩展成48位，并通过一个异或操作替代成新的48位数据，再将其压缩置换成32位。这四步运算构成了函数f。然后，通过另一个异或运算，函数f的输出与左半部分结合，其结果成为新的右半部分，原来的右半部分成为新的左半部分。将该操作重复16次；</li><li>经过16轮迭代后，左，右半部分合在一起经过一个末置换（数据整理），这样就完成了加密过程。</li></ol><p>对于DES解密的过程大家猛然一想应该是使用跟加密过程相反的算法，事实上解密和加密使用的是一样的算法，有区别的地方在于加密和解密在使用密匙的时候次序是相反的。比如加密的时候是K0,K1,K2......K15，那么解密使用密匙的次序就是倒过来的。之所以能用相同的算法去解密，这跟DES特意设计的加密算法有关，感兴趣的同学可以深入分析。</p><h5 class=pgc-h-arrow-right>2.3 AES</h5><p>高级加密标准(AES,Advanced Encryption Standard)，与DES一样，使用AES加密函数和密匙来对明文进行加密，区别就是使用的加密函数不同。</p><p>上面说过DES的密钥长度是56比特，因此算法的理论安全强度是2^56。但以目前计算机硬件的制作水准和升级情况，破解DES可能只是山脉问题，最终NIST(美国国家标准技术研究所（National Institute of Standards and Technology))选择了分组长度为128位的Rijndael算法作为AES算法。</p><p>AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同，如下表所示：</p><p>AES密钥长度（32位比特字)分组长度(32位比特字)加密轮数AES-1284410AES-1926412AES-2568414</p><h4 class=pgc-h-arrow-right>3. 非对称加密#</h4><p>非对称加密算法的特点是，秘钥一次会生成一对，其中一份秘钥由自己保存，不能公开出去，称为“私钥”，另外一份是可以公开出去的，称为“公钥”。</p><p>将原文用公钥进行加密，得到的密文只有用对应私钥才可以解密得到原文；</p><p>将原文用私钥加密得到的密文，也只有用对应的公钥才能解密得到原文；</p><p>因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p><div class=pgc-img><img alt=加解密算法分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a818781cfb0b4f73a68646ab958892ac><p class=pgc-img-caption></p></div><h5 class=pgc-h-arrow-right>与对称加密算法的对比</h5><ul><li>优点：其安全性更好，对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</li><li>缺点：非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</li></ul><p>在非对称加密中使用的主要算法有：RSA、Elgamal、ESA、揹包算法、Rabin、D-H、ECC（椭圆曲线加密算法）等。不同算法的实现机制不同。</p><h5 class=pgc-h-arrow-right>非对称加密工作原理</h5><p>下面我们就看一下非对称加密的工作原理。</p><ul><li>乙方生成一对密钥（公钥和私钥）并将公钥向其它方公开。</li><li>得到该公钥的甲方使用该密钥对机密信息进行加密后再发送给乙方。</li><li>乙方再用自己保存的另一把专用密钥（私钥）对加密后的信息进行解密。乙方只能用其专用密钥（私钥）解密由对应的公钥加密后的信息。</li><li>在传输过程中，即使攻击者截获了传输的密文，并得到了乙的公钥，也无法破解密文，因为只有乙的私钥才能解密密文。同样，如果乙要回复加密信息给甲，那么需要甲先公布甲的公钥给乙用于加密，甲自己保存甲的私钥用于解密。</li></ul><h5 class=pgc-h-arrow-right>非对称加密鼻祖：RSA</h5><p>RSA算法基于一个十分简单的数论事实：将两个大质数（素数）相乘十分容易，但是想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。比如：取两个简单的质数：67，73，得到两者乘积很简单4891；但是要想对4891进行因式分解，其工作量成几何增加。</p><p>应用场景：</p><p>HTTPS请求的SSL层。</p><div class=pgc-img><img alt=加解密算法分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8007ab02da54ee4b1b761777ca31da7><p class=pgc-img-caption></p></div><p>在JDK中也提供了RSA的实现，下面给出示例：</p><pre><code>Copy	/**     * 创建密匙对     *     * @return     */    private KeyPair genKeyPair() {        //创建 RSA Key 的生产者。        KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance("RSA");        //利用用户密码作为随机数初始化出 1024 比特 Key 的生产者。        //SecureRandom 是生成安全随机数序列，password.getBytes() 是种子，只要种子相同，序列就一样。        keyPairGen.initialize(1024, new SecureRandom("password".getBytes()));        //创建密钥对        return keyPairGen.generateKeyPair();    }    /**     * 生成公匙     *     * @return     */    public PublicKey genPublicKey() {        try {            //创建密钥对            KeyPair keyPair = genKeyPair();            //生成公钥            PublicKey publicKey = keyPair.getPublic();            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(publicKey.getEncoded());            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            publicKey = keyFactory.generatePublic(keySpec);            return publicKey;        } catch (Exception e) {            e.printStackTrace();        }        return null;    }    /**     * 生成私匙     *     * @return     */    public PrivateKey genPrivateKey() {        try {            //创建密钥对            KeyPair keyPair = genKeyPair();            //生成私匙            PrivateKey privateKey = keyPair.getPrivate();            X509EncodedKeySpec keySpec = new X509EncodedKeySpec(privateKey.getEncoded());            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            return keyFactory.generatePrivate(keySpec);        } catch (Exception e) {            e.printStackTrace();        }        return null;    }    /**     * 公钥加密     *     * @param data     * @param publicKey     * @return     * @throws Exception     */    public static byte[] encryptByPublicKey(byte[] data, String publicKey)            throws Exception {        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKey.getBytes());        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        Key publicK = keyFactory.generatePublic(x509KeySpec);        // 对数据加密        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.ENCRYPT_MODE, publicK);        int inputLen = data.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段加密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; 117) {                cache = cipher.doFinal(data, offSet, 117);            } else {                cache = cipher.doFinal(data, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * 117;        }        byte[] encryptedData = out.toByteArray();        out.close();        return encryptedData;    }    /**     * 私钥解密     *     * @param encryptedData     * @param privateKey     * @return     * @throws Exception     */    public static byte[] decryptByPrivateKey(byte[] encryptedData,                                             String privateKey) throws Exception {        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(privateKey.getBytes());        KeyFactory keyFactory = KeyFactory.getInstance(KEY_ALGORITHM);        Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.DECRYPT_MODE, privateK);        int inputLen = encryptedData.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段解密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; 118) {                cache = cipher.doFinal(encryptedData, offSet, 118);            } else {                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * 118;        }        byte[] decryptedData = out.toByteArray();        out.close();        return decryptedData;    }    /**     * 私钥加密     *     * @param data     * @param privateKey     * @return     * @throws Exception     */    public static byte[] encryptByPrivateKey(byte[] data, String privateKey)            throws Exception {        PKCS8EncodedKeySpec pkcs8KeySpec = new PKCS8EncodedKeySpec(publicKey.getBytes());        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        Key privateK = keyFactory.generatePrivate(pkcs8KeySpec);        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.ENCRYPT_MODE, privateK);        int inputLen = data.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段加密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; 117) {                cache = cipher.doFinal(data, offSet, 117);            } else {                cache = cipher.doFinal(data, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * 117;        }        byte[] encryptedData = out.toByteArray();        out.close();        return encryptedData;    }	/**     * 公钥解密     *     * @param encryptedData     * @param publicKey     * @return     * @throws Exception     */    public static byte[] decryptByPublicKey(byte[] encryptedData,                                            String publicKey) throws Exception {        X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(publicKey.getBytes());        KeyFactory keyFactory = KeyFactory.getInstance("RSA");        Key publicK = keyFactory.generatePublic(x509KeySpec);        Cipher cipher = Cipher.getInstance(keyFactory.getAlgorithm());        cipher.init(Cipher.DECRYPT_MODE, publicK);        int inputLen = encryptedData.length;        ByteArrayOutputStream out = new ByteArrayOutputStream();        int offSet = 0;        byte[] cache;        int i = 0;        // 对数据分段解密        while (inputLen - offSet &gt; 0) {            if (inputLen - offSet &gt; 118) {                cache = cipher.doFinal(encryptedData, offSet, 118);            } else {                cache = cipher.doFinal(encryptedData, offSet, inputLen - offSet);            }            out.write(cache, 0, cache.length);            i++;            offSet = i * 118;        }        byte[] decryptedData = out.toByteArray();        out.close();        return decryptedData;    }</code></pre><h4 class=pgc-h-arrow-right>4. 组合加密#</h4><p>上面介绍的3种加密技术，每一种都有自己的特点，比如散列技术用于特征值提取，对称加密速度虽快但是有私匙泄露的危险，非对称加密虽然安全但是速度却慢。基于这些情况，现在的加密技术更加趋向于将这些加密的方案组合起来使用，基于此来研发新的加密算法。</p><p>MAC（Message Authentication Code，消息认证码算法）是含有密钥散列函数算法，兼容了MD和SHA算法的特性，并在此基础上加上了密钥。因此MAC算法也经常被称作HMAC算法。MAC（Message Authentication Code，消息认证码算法）是含有密钥散列函数算法，HMAC加密可以理解为加盐的散列算法，此处的“盐”就相当于HMAC算法的秘钥。</p><p>HMAC算法的实现过程需要一个加密用的散列函数（表示为H）和一个密钥。</p><p>经过MAC算法得到的摘要值也可以使用十六进制编码表示，其摘要值得长度与实现算法的摘要值长度相同。例如 HmacSHA算法得到的摘要长度就是SHA1算法得到的摘要长度，都是160位二进制数，换算成十六进制的编码为40位。</p><p><strong>MAC算法的实现：</strong></p><p>算法摘要长度备注HmacMD5128JAVA6实现HmacSHA1160JAVA6实现HmacSHA256256JAVA6实现HmacSHA384384JAVA6实现HmacSHA512512JAVA6实现HmacMD2128BouncyCastle实现HmacMD4128BouncyCastle实现HmacSHA224224BouncyCastle实现</p><p>过程如下：</p><ol start=1><li>在密钥key后面添加0来创建一个长为B(64字节)的字符串（str）；</li><li>将上一步生成的字符串(str) 与ipad（0x36）做异或运算，形成结果字符串（istr）;</li><li>将数据流data附加到第二步的结果字符串(istr)的末尾；</li><li>做md5运算于第三步生成的数据流(istr)；</li><li>将第一步生成的字符串(str) 与opad（0x5c）做异或运算，形成结果字符串（ostr），再将第四步的结果(istr) 附加到第五步的结果字符串（ostr）的末尾做md5运算于第6步生成的数据流（ostr），最终输出结果(out)</li></ol><p>注意：如果第一步中，key的长度klen大于64字节，则先进行md5运算，使其长度klen = 16字节。</p><p>JDK中的实现：</p><pre><code>Copypublic static void jdkHmacMD5() {    try {        // 初始化KeyGenerator        KeyGenerator keyGenerator = KeyGenerator.getInstance("HmacMD5");        // 产生密钥        SecretKey secretKey = keyGenerator.generateKey();        // 获取密钥        byte[] key = secretKey.getEncoded();        //            byte[] key = Hex.decodeHex(new char[]{'1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e'});        // 还原密钥        SecretKey restoreSecretKey = new SecretKeySpec(key, "HmacMD5");        // 实例化MAC        Mac mac = Mac.getInstance(restoreSecretKey.getAlgorithm());        // 初始化MAC        mac.init(restoreSecretKey);        // 执行摘要        byte[] hmacMD5Bytes = mac.doFinal("data".getBytes());        System.out.println("jdk hmacMD5:" + new String(hmacMD5Bytes));    } catch (Exception e) {        e.printStackTrace();    }}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'加解密','算法','分析'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>