<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MySQL系列-第14篇：事务详解 | 极客快訊</title><meta property="og:title" content="MySQL系列-第14篇：事务详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d322f7b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d322f7b.html><meta property="article:published_time" content="2020-11-14T21:08:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:11+08:00"><meta name=Keywords content><meta name=description content="MySQL系列-第14篇：事务详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7d322f7b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MySQL系列-第14篇：事务详解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>打算提升sql技能的，可以加我微信itsoku，带你成为sql高手。</p><p>这是Mysql系列第14篇。</p><p>环境：mysql5.7.25，cmd命令中进行演示。</p><p><br></p><p><strong>开发过程中，会经常用到数据库</strong><strong>事务</strong><strong>，所以本章非常重要。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>本篇内容</h1><ol start=0><li>什么是事务，它有什么用？</li><li>事务的几个特性</li><li>事务常见操作指令详解</li><li>事务的隔离级别详解</li><li>脏读、不可重复读、可重复读、幻读详解</li><li>演示各种隔离级别产生的现象</li><li>关于隔离级别的选择</li></ol><p><br></p><h1 class=pgc-h-arrow-right>什么是事务？</h1><p><strong>数据库中的事务是指对数据库执行一批操作，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。</strong></p><p><strong>举个例子</strong></p><p>比如A用户给B用户转账100操作，过程如下：</p><pre><code>1.从A账户扣1002.给B账户加100</code></pre><p>如果在事务的支持下，上面最终只有2种结果：</p><ol start=0><li>操作成功：A账户减少100；B账户增加100</li><li>操作失败：A、B两个账户都没有发生变化</li></ol><p>如果没有事务的支持，可能出现错：A账户减少了100，此时系统挂了，导致B账户没有加上100，而A账户凭空少了100。</p><p><br></p><h1 class=pgc-h-arrow-right>事务的几个特性(ACID)</h1><h1 class=pgc-h-arrow-right>原子性(Atomicity)</h1><p>事务的整个过程如原子操作一样，最终要么全部成功，或者全部失败，这个原子性是从最终结果来看的，从最终结果来看这个过程是不可分割的。</p><h1 class=pgc-h-arrow-right>一致性(Consistency)</h1><p>一个事务必须使数据库从一个一致性状态变换到另一个一致性状态。</p><p>首先回顾一下一致性的定义。所谓一致性，指的是数据处于一种有意义的状态，这种状态是<strong>语义上的</strong>而不是<strong>语法上的</strong>。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。</p><p><strong>从这段话的理解来看，所谓一致性，即，从实际的业务逻辑上来说，最终结果是对的、是跟程序员的所期望的结果完全符合的</strong></p><h1 class=pgc-h-arrow-right>隔离性(Isolation)</h1><p>一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p><h1 class=pgc-h-arrow-right>持久性(Durability)</h1><p>一个事务一旦提交，他对数据库中数据的改变就应该是永久性的。当事务提交之后，数据会持久化到硬盘，修改是永久性的。</p><p><br></p><h1 class=pgc-h-arrow-right>Mysql中事务操作</h1><p>mysql中事务默认是隐式事务，执行insert、update、delete操作的时候，数据库自动开启事务、提交或回滚事务。</p><p>是否开启隐式事务是由变量autocommit控制的。</p><p>所以事务分为<strong>隐式事务</strong>和<strong>显式事务</strong>。</p><h1 class=pgc-h-arrow-right>隐式事务</h1><blockquote><p>事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。</p></blockquote><p>查看变量autocommit是否开启了自动提交</p><pre><code>mysql&gt; show variables like 'autocommit';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | ON    |+---------------+-------+1 row in set, 1 warning (0.00 sec)</code></pre><blockquote><p>autocommit为ON表示开启了自动提交。</p></blockquote><h1 class=pgc-h-arrow-right>显式事务</h1><blockquote><p>事务需要手动开启、提交或回滚，由开发者自己控制。</p></blockquote><p>2种方式手动控制事务：</p><p><strong>方式1：</strong></p><p>语法：</p><pre><code>//设置不自动提交事务set autocommit=0;//执行事务操作commit|rollback;</code></pre><p>示例1：提交事务操作，如下：</p><pre><code>mysql&gt; create table test1 (a int);Query OK, 0 rows affected (0.01 sec)mysql&gt; select * from test1;Empty set (0.00 sec)​mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)​mysql&gt; insert into test1 values(1);Query OK, 1 row affected (0.00 sec)​mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)​mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><p>示例2：回滚事务操作，如下：</p><pre><code>mysql&gt; set autocommit=0;Query OK, 0 rows affected (0.00 sec)​mysql&gt; insert into test1 values(2);Query OK, 1 row affected (0.00 sec)​mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)​mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><blockquote><p>可以看到上面数据回滚了。</p></blockquote><p>我们把autocommit还原回去：</p><pre><code>mysql&gt; set autocommit=1;Query OK, 0 rows affected (0.00 sec)</code></pre><p><strong>方式2：</strong></p><p>语法：</p><pre><code>start transaction;//开启事务//执行事务操作commit|rollback;</code></pre><p>示例1：提交事务操作，如下：</p><pre><code>mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)​mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)​mysql&gt; insert into test1 values (2);Query OK, 1 row affected (0.00 sec)​mysql&gt; insert into test1 values (3);Query OK, 1 row affected (0.00 sec)​mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)​mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)</code></pre><blockquote><p>上面成功插入了2条数据。</p></blockquote><p>示例2：回滚事务操作，如下：</p><pre><code>mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; delete from test1;Query OK, 3 rows affected (0.00 sec)mysql&gt; rollback;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    2 ||    3 |+------+3 rows in set (0.00 sec)</code></pre><blockquote><p>上面事务中我们删除了test1的数据，显示删除了3行，最后回滚了事务。</p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>savepoint关键字</h1><p>在事务中我们执行了一大批操作，可能我们只想回滚部分数据，怎么做呢？</p><p>我们可以将一大批操作分为几个部分，然后指定回滚某个部分。可以使用savepoin来实现，效果如下：</p><p>先清除test1表数据：</p><pre><code>mysql&gt; delete from test1;Query OK, 3 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)</code></pre><p>演示savepoint效果，认真看：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; savepoint part1;//设置一个保存点Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (2);Query OK, 1 row affected (0.00 sec)mysql&gt; rollback to part1;//将savepint = part1的语句到当前语句之间所有的操作回滚Query OK, 0 rows affected (0.00 sec)mysql&gt; commit;//提交事务Query OK, 0 rows affected (0.00 sec)    mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)</code></pre><blockquote><p>从上面可以看出，执行了2次插入操作，最后只插入了1条数据。</p><p>savepoint需要结合rollback to sp1一起使用，可以将保存点sp1到rollback to之间的操作回滚掉。</p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>只读事务</h1><p>表示在事务中执行的是一些只读操作，如查询，但是不会做insert、update、delete操作，数据库内部对只读事务可能会有一些性能上的优化。</p><p>用法如下：</p><pre><code>start transaction read only;</code></pre><p>示例：</p><pre><code>mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; start transaction read only;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)mysql&gt; delete from test1;ERROR 1792 (25006): Cannot execute statement in a READ ONLY transaction.mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)</code></pre><blockquote><p>只读事务中执行delete会报错。</p></blockquote><p><br></p><h1 class=pgc-h-arrow-right>事务中的一些问题</h1><p>这些问题主要是基于数据在多个事务中的可见性来说的。</p><h1 class=pgc-h-arrow-right>脏读</h1><p>一个事务在执行的过程中读取到了其他事务还没有提交的数据。 这个还是比较好理解的。</p><h1 class=pgc-h-arrow-right>读已提交</h1><p>从字面上我们就可以理解，即一个事务操作过程中可以读取到其他事务已经提交的数据。</p><p>事务中的每次读取操作，读取到的都是数据库中其他事务已提交的最新的数据（相当于当前读）</p><h1 class=pgc-h-arrow-right>可重复读</h1><p>一个事务操作中对于一个读取操作不管多少次，读取到的结果都是一样的。</p><h1 class=pgc-h-arrow-right>幻读</h1><p>脏读、不可重复读、可重复读、幻读，其中最难理解的是幻读</p><p>以mysql为例：</p><p><strong>幻读在可重复读的模式下才会出现，其他隔离级别中不会出现</strong></p><p>幻读现象例子：</p><p>可重复读模式下，比如有个用户表，手机号码为主键，有两个事物进行如下操作</p><p>事务A操作如下： 1、打开事务 2、查询号码为X的记录，不存在 3、插入号码为X的数据，插入报错（为什么会报错，先向下看） 4、查询号码为X的记录，发现还是不存在（由于是可重复读，所以读取记录X还是不存在的）</p><p>事物B操作：在事务A第2步操作时插入了一条X的记录，所以会导致A中第3步插入报错（违反了唯一约束）</p><p>上面操作对A来说就像发生了幻觉一样，明明查询X（A中第二步、第四步）不存在，但却无法插入成功</p><p><strong>幻读可以这么理解：事务中后面的操作（插入号码X）需要上面的读取操作（查询号码X的记录）提供支持，但读取操作却不能支持下面的操作时产生的错误，就像发生了幻觉一样。</strong></p><p>如果还是理解不了的，继续向下看，后面后详细的演示。</p><p><br></p><h1 class=pgc-h-arrow-right>事务的隔离级别</h1><p>当多个事务同时进行的时候，如何确保当前事务中数据的正确性，比如A、B两个事物同时进行的时候，A是否可以看到B已提交的数据或者B未提交的数据，这个需要依靠事务的隔离级别来保证，不同的隔离级别中所产生的效果是不一样的。</p><p>事务隔离级别主要是解决了上面多个事务之间数据可见性及数据正确性的问题。</p><p><strong>隔离级别分为4种：</strong></p><ol start=0><li><strong>读未提交：READ-UNCOMMITTED</strong></li><li><strong>读已提交：READ-COMMITTED</strong></li><li><strong>可重复读：REPEATABLE-READ</strong></li><li><strong>串行：SERIALIZABLE</strong></li></ol><p>上面4中隔离级别越来越强，会导致数据库的并发性也越来越低。</p><p><br></p><h1 class=pgc-h-arrow-right>查看隔离级别</h1><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p><br></p><h1 class=pgc-h-arrow-right>隔离级别的设置</h1><p>分2步骤，修改文件、重启mysql，如下：</p><p>修改mysql中的my.init文件，我们将隔离级别设置为：READ-UNCOMMITTED，如下：</p><pre><code># 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行transaction-isolation=READ-UNCOMMITTED</code></pre><p>以管理员身份打开cmd窗口，重启mysql，如下：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服务正在停止..mysql 服务已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服务正在启动 .mysql 服务已经启动成功。</code></pre><p><br></p><h1 class=pgc-h-arrow-right>各种隔离级别中会出现的问题</h1><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事务详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5><p class=pgc-img-caption></p></div><blockquote><p>表格中和网上有些不一样，主要是幻读这块，幻读只会在可重复读级别中才会出现，其他级别下不存在。</p></blockquote><p><br></p><p>下面我们来演示一下，各种隔离级别中可见性的问题，开启两个窗口，叫做A、B窗口，两个窗口中登录mysql。</p><h1 class=pgc-h-arrow-right>READ-UNCOMMITTED：读未提交</h1><p>将隔离级别置为READ-UNCOMMITTED：</p><pre><code># 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行transaction-isolation=READ-UNCOMMITTED</code></pre><p>重启mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服务正在停止..mysql 服务已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服务正在启动 .mysql 服务已经启动成功。</code></pre><p>查看隔离级别：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-UNCOMMITTED |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表数据：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按时间顺序在2个窗口中执行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事务详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7bea5002a6fc47c88a7c4e36bdedfe37><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>T2-A：无数据，T6-A：有数据，T6时刻B还未提交，此时A已经看到了B插入的数据，<strong>说明出现了脏读</strong>。</p><p>T2-A：无数据，T6-A：有数据，查询到的结果不一样，<strong>说明不可重复读</strong>。</p><p><strong>结论：读未提交情况下，可以读取到其他事务还未提交的数据，多次读取结果不一样，出现了脏读、不可重复读</strong></p><p><br></p><h1 class=pgc-h-arrow-right>READ-COMMITTED：读已提交</h1><p>将隔离级别置为READ-COMMITTED</p><pre><code># 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行transaction-isolation=READ-COMMITTED</code></pre><p>重启mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服务正在停止..mysql 服务已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服务正在启动 .mysql 服务已经启动成功。</code></pre><p>查看隔离级别：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | READ-COMMITTED |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表数据：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按时间顺序在2个窗口中执行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事务详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aefc2324fbf645e4bdf39b68d5b2bef3><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 |+------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>T5-B：有数据，T6-A窗口：无数据，A看不到B的数据，<strong>说明没有脏读</strong>。</p><p>T6-A窗口：无数据，T8-A：看到了B插入的数据，此时B已经提交了，A看到了B已提交的数据，<strong>说明可以读取到已提交的数据</strong>。</p><p>T2-A、T6-A：无数据，T8-A：有数据，多次读取结果不一样，<strong>说明不可重复读</strong>。</p><p><strong>结论：读已提交情况下，无法读取到其他事务还未提交的数据，可以读取到其他事务已经提交的数据，多次读取结果不一样，未出现脏读，出现了读已提交、不可重复读。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>REPEATABLE-READ：可重复读</h1><p>将隔离级别置为REPEATABLE-READ</p><pre><code># 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行transaction-isolation=REPEATABLE-READ</code></pre><p>重启mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服务正在停止..mysql 服务已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服务正在启动 .mysql 服务已经启动成功。</code></pre><p>查看隔离级别：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表数据：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按时间顺序在2个窗口中执行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事务详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ded27a7f0ce48dd9cfa8dfe9c5d5d3c><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; select * from test1;Empty set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into test1 values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from test1;+------+| a    |+------+|    1 ||    1 |+------+2 rows in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>T2-A、T6-A窗口：无数据，T5-B：有数据，A看不到B的数据，<strong>说明没有脏读</strong>。</p><p>T8-A：无数据，此时B已经提交了，A看不到B已提交的数据，A中3次读的结果一样都是没有数据的，<strong>说明可重复读</strong>。</p><p><strong>结论：可重复读情况下，未出现脏读，未读取到其他事务已提交的数据，多次读取结果一致，即可重复读。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>幻读演示</h1><p>幻读只会在REPEATABLE-READ（可重复读）级别下出现，需要先把隔离级别改为可重复读。</p><p>将隔离级别置为REPEATABLE-READ</p><pre><code># 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行transaction-isolation=REPEATABLE-READ</code></pre><p>重启mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服务正在停止..mysql 服务已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服务正在启动 .mysql 服务已经启动成功。</code></pre><p>查看隔离级别：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+----------------+| Variable_name         | Value          |+-----------------------+----------------+| transaction_isolation | REPEATABLE-READ |+-----------------------+----------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>准备数据：</p><pre><code>mysql&gt; create table t_user(id int primary key,name varchar(16) unique key);Query OK, 0 rows affected (0.01 sec)mysql&gt; insert into t_user values (1,'路人甲Java'),(2,'路人甲Java');ERROR 1062 (23000): Duplicate entry '路人甲Java' for key 'name'mysql&gt; select * from t_user;Empty set (0.00 sec)</code></pre><blockquote><p>上面我们创建t_user表，name添加了唯一约束，表示name不能重复，否则报错。</p></blockquote><p>按时间顺序在2个窗口中执行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事务详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/981cfba0c6ac47ec8d4905ba7c510ffd><p class=pgc-img-caption></p></div><p>A窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; select * from t_user where name='路人甲Java';Empty set (0.00 sec)mysql&gt; insert into t_user values (2,'路人甲Java');ERROR 1062 (23000): Duplicate entry '路人甲Java' for key 'name'mysql&gt; select * from t_user where name='路人甲Java';Empty set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>B窗口如下：</p><pre><code>mysql&gt; start transaction;Query OK, 0 rows affected (0.00 sec)mysql&gt; insert into t_user values (1,'路人甲Java');Query OK, 1 row affected (0.00 sec)mysql&gt; select * from t_user;+----+---------------+| id | name          |+----+---------------+|  1 | 路人甲Java    |+----+---------------+1 row in set (0.00 sec)mysql&gt; commit;Query OK, 0 rows affected (0.00 sec)</code></pre><p>看一下:</p><p>A想插入数据路人甲Java，插入之前先查询了一下（T5时刻）该用户是否存在，发现不存在，然后在T7时刻执行插入，报错了，报数据已经存在了，因为T6时刻B已经插入了路人甲Java。</p><p>然后A有点郁闷，刚才查的时候不存在的，然后A不相信自己的眼睛，又去查一次（T8时刻），发现路人甲Java还是不存在的。</p><p>此时A心里想：数据明明不存在啊，为什么无法插入呢？这不是懵逼了么，A觉得如同发生了幻觉一样。</p><p><br></p><h1 class=pgc-h-arrow-right>SERIALIZABLE：串行</h1><blockquote><p><strong>SERIALIZABLE会让并发的事务串行执行（多个事务之间读写、写读、写写会产生互斥，效果就是串行执行，多个事务之间的读读不会产生互斥）。</strong></p><p><strong>读写互斥</strong>：事务A中先读取操作，事务B发起写入操作，事务A中的读取会导致事务B中的写入处于等待状态，直到A事务完成为止。</p><p>表示我开启一个事务，为了保证事务中不会出现上面说的问题（脏读、不可重复读、读已提交、幻读），那么我读取的时候，其他事务有修改数据的操作需要排队等待，等待我读取完成之后，他们才可以继续。</p><p>写读、写写也是互斥的，读写互斥类似。</p><p>这个类似于java中的java.util.concurrent.lock.ReentrantReadWriteLock类产生的效果。</p></blockquote><p>下面演示读写互斥的效果。</p><p>将隔离级别置为SERIALIZABLE</p><pre><code># 隔离级别设置,READ-UNCOMMITTED读未提交,READ-COMMITTED读已提交,REPEATABLE-READ可重复读,SERIALIZABLE串行transaction-isolation=SERIALIZABLE</code></pre><p>重启mysql：</p><pre><code>C:\Windows\system32&gt;net stop mysqlmysql 服务正在停止..mysql 服务已成功停止。C:\Windows\system32&gt;net start mysqlmysql 服务正在启动 .mysql 服务已经启动成功。</code></pre><p>查看隔离级别：</p><pre><code>mysql&gt; show variables like 'transaction_isolation';+-----------------------+--------------+| Variable_name         | Value        |+-----------------------+--------------+| transaction_isolation | SERIALIZABLE |+-----------------------+--------------+1 row in set, 1 warning (0.00 sec)</code></pre><p>先清空test1表数据：</p><pre><code>delete from test1;select * from test1;</code></pre><p>按时间顺序在2个窗口中执行下面操作：</p><p><br></p><div class=pgc-img><img alt=MySQL系列-第14篇：事务详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f69960b79c7c433bbe1431a01b33cba7><p class=pgc-img-caption></p></div><p>按时间顺序运行上面的命令，会发现T4-B这样会被阻塞，直到T5-A执行完毕。</p><p>上面这个演示的是读写互斥产生的效果，大家可以自己去写一下写读、写写互斥的效果。</p><p><strong>可以看出来，事务只能串行执行了。串行情况下不存在脏读、不可重复读、幻读的问题了。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>关于隔离级别的选择</h1><ol start=0><li>需要对各种隔离级别产生的现象非常了解，然后选择的时候才能游刃有余</li><li>隔离级别越高，并发性也低，比如最高级别SERIALIZABLE会让事物串行执行，并发操作变成串行了，会导致系统性能直接降低。</li><li>具体选择哪种需要结合具体的业务来选择。</li><li>读已提交（READ-COMMITTED）通常用的比较多。</li></ol><p><br></p><h1 class=pgc-h-arrow-right>总结</h1><ol start=0><li>理解事务的4个特性：原子性、一致性、隔离性、持久性</li><li>掌握事务操作常见命令的介绍</li><li>set autocommit可以设置是否开启自动提交事务</li><li>start transaction：开启事务</li><li>start transaction read only：开启只读事物</li><li>commit：提交事务</li><li>rollback：回滚事务</li><li>savepoint：设置保存点</li><li>rollback to 保存点：可以回滚到某个保存点</li><li>掌握4种隔离级别及了解其特点</li><li>了解脏读、不可重复读、幻读</li></ol><p><br></p><h1 class=pgc-h-arrow-right>Mysql系列目录</h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6850349195753341451/?group_id=6850349195753341451" rel="noopener noreferrer" target=_blank>MySQL系列-第13篇：细说NULL导致的神坑，让人防不胜防</a></p><p><strong>mysql系列大概有20多篇，喜欢的请关注一下，欢迎大家加我微信itsoku或者留言交流mysql相关技术!</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'MySQL','14','事务'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>