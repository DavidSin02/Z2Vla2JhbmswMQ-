<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java实现远程服务生产与消费(RPC)的4种方法 | 极客快訊</title><meta property="og:title" content="Java实现远程服务生产与消费(RPC)的4种方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/856837d3a1b446dbbeb16994e9ed19da"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d792b58.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d792b58.html><meta property="article:published_time" content="2020-10-29T21:12:12+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:12+08:00"><meta name=Keywords content><meta name=description content="Java实现远程服务生产与消费(RPC)的4种方法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7d792b58.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java实现远程服务生产与消费(RPC)的4种方法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><em>本文将通过具体的远程服务发布与消费案例展示4种RPC远程调用方法.</em></blockquote><h1 class=ql-align-justify><strong>一. 通过rmi实现远程服务的生产与消费</strong></h1><ul><li class=ql-align-justify>Java自身提供了java.rmi包, 方便开发者进行远程服务的部署与消费, 下面将通过具体案例进行讲解.</li></ul><p class=ql-align-justify><strong>远程服务提供者实现.</strong></p><p class=ql-align-justify>创建rmi-provider项目(Maven)</p><ol><li class=ql-align-justify>创建UserService接口.</li></ol><pre class=ql-align-justify>//将要发布的服务的接口public interface UserService extends Remote { public String helloRmi(String name) throws RemoteException;}</pre><ol><li class=ql-align-justify>创建UserServiceImpl实现类</li></ol><ul><li class=ql-align-justify>注意, UserServiceImpl除了实现UserService接口外, 还要继承UnicastRemoteObject类, 你可以理解为它是一个发布出去供他人调用的类, 当UserServiceImpl实现了这个类后, UserServiceImpl就能被发布出去供别人调用.</li></ul><pre class=ql-align-justify>//将要发布的服务的实现类public class UserServiceImpl extends UnicastRemoteObject implements UserService { public UserServiceImpl() throws RemoteException { super(); } public String helloRmi(String name) throws RemoteException { return "hello " + name; }}</pre><ol><li class=ql-align-justify>发布远程服务</li></ol><pre class=ql-align-justify>public static void main(String[] args) { try { //完成远程服务的发布 LocateRegistry.createRegistry(8888);//将远程服务发布在本地的8888端口 String name = "rmi://localhost:8888/rmi";//发布的远程服务被访问的url UserService userService = new UserServiceImpl();//创建一个提供具体服务的远程对象 Naming.bind(name, userService);//给远程服务绑定一个url System.out.println("--- 已发布rmi远程服务 ---"); } catch (Exception e) { e.printStackTrace(); }}</pre><p class=ql-align-justify><strong>远程服务消费者实现</strong></p><p class=ql-align-justify>创建rmi-consumer项目</p><ol><li class=ql-align-justify>把rmi-provider项目种的UserService接口与UserServiceImpl实现类复制到本rmi-consumer项目中.(这一步可以进行优化解耦, 我们可以多创建一个rmi-resource项目, 让rmi-provider和rmi-consumer共同依赖rmi-resource项目, 然后把资源文件比如远程服务所用到的UserService等放入rmi-resource项目中)</li><li class=ql-align-justify>远程服务消费者对远程服务发起调用.</li></ol><pre class=ql-align-justify>public static void main(String[] args) { try { //发布远程服务的访问url String name = "rmi://localhost:8888/rmi"; //通过发布远程服务的url, 获取远程服务的代理对象 UserService userService = (UserService) Naming.lookup(name); System.out.println("获得的远程服务的代理对象:" + userService.getClass().getName()); String result = userService.helloRmi("rmi");//拿到远程方法调用的结果 System.out.println("result: " + result); }catch (Exception e) { e.printStackTrace(); }}//最后输出获得的远程服务的代理对象:com.sun.proxy.$Proxy0result: hello rmi</pre><ul><li class=ql-align-justify>通过最后的输出我们看到获得的远程服务对象是动态代理产生的.</li></ul><p class=ql-align-justify></p><h1 class=ql-align-justify><strong>二. 通过WebService实现远程服务的生产与消费</strong></h1><ul><li class=ql-align-justify>WebService协议是RPC的一种具体实现, 服务提供方和消费方通过http + xml进行通信.</li></ul><p class=ql-align-justify><strong>远程服务提供者实现.</strong></p><ol><li class=ql-align-justify>首先创建远程服务接口UserService及其实现类UserServiceImpl.</li></ol><ul><li class=ql-align-justify>注意, 使用WebService时需要对远程服务加上注解@WebService</li></ul><pre class=ql-align-justify>@WebServicepublic interface UserService { public String sayHello(String name);}@WebServicepublic class UserServiceImpl implements UserService { @Override public String sayHello(String name) { return "hello " + name + "~"; }}</pre><ol><li class=ql-align-justify>发布远程服务, 过程和rmi差不多, 需要提供远程服务的访问地址和具体的远程服务实现类, 使用Endpoint类的publish()方法进行发布, 这都是JDK封装好的.</li></ol><pre class=ql-align-justify>public class WsProviderApp { public static void main(String[] args) { //发布的WebService的被访问地址 String address = "http://localhost:9999/ws"; //创建远程服务对象 UserService userService = new UserServiceImpl(); //发布服务 Endpoint.publish(address, userService); System.out.println("远程服务已经发布..."); }}</pre><p class=ql-align-justify><strong>查看远程服务文档wdsl</strong></p><ul><li class=ql-align-justify>和rmi不同的是, WebService发布后, 调用者可以通过查看它的文档对远程服务发起调用.</li><li class=ql-align-justify>查看的方法是在浏览器中输入远程服务的访问地址加上?wdsl, 比如本案例中是http://localhost:9999/ws?wsdl</li><li class=ql-align-justify>注意, 在客户端调用远程方法时需要用工具对wdsl文档进行解析, 并获得调用远程方法的工具类. 具体操作见下一段.</li></ul><p class=ql-align-justify><strong>远程服务消费者实现.</strong></p><ol><li class=ql-align-justify>首先根据文档获得调用远程服务的工具类, JDK已经为我们封装好了获取的工具, 它在bin目录下, 名字是wsimport</li><li class=ql-align-justify>打开命令行, 在命令行中输入解析命令</li></ol><pre class=ql-align-justify>wsimport -keep -d C:\githubRepositories\shopping\ws-consumer\src\main\java -p com.shenghao.client http://localhost:9999/ws?wsdl解释:1. wsimport 是命令的名字2. -keep 用于保留生成的类, 如果没有该指令会只生成class文件3. -d 后面接项目中存放这些工具类的包, 填绝对路径4. -p 填wdsl文档的地址</pre><div class=pgc-img><img alt=Java实现远程服务生产与消费(RPC)的4种方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/856837d3a1b446dbbeb16994e9ed19da><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Java实现远程服务生产与消费(RPC)的4种方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ab64a65ee9e4673a89bbe69cb2474ad><p class=pgc-img-caption></p></div><p class=ql-align-justify></p><ol><li class=ql-align-justify>可以看到命令执行完后, 指定的包中出现一堆相关的类, 最直接调用到的类是UserServiceImplService. 下面演示对远程方法进行调用.</li></ol><pre class=ql-align-justify>public static void main(String[] args) { //创建服务类对象 UserServiceImplService service = new UserServiceImplService(); //获得远程服务的代理对象 UserServiceImpl userService = service.getUserServiceImplPort(); System.out.println(userService.getClass().getName()); //对远程服务对象的方法进行调用 String result = userService.sayHello("炭烧生蚝"); System.out.println(result);}//结果输出com.sun.proxy.$Proxy32hello 炭烧生蚝~</pre><h1 class=ql-align-justify><strong>三. 通过HttpClient实现远程服务的生产与消费</strong></h1><ul><li class=ql-align-justify>这里我们换一个案例进行演示. 假设现在有一套用户系统和一套订单系统, 要实现用户系统访问订单系统以获得某个用户的订单信息.</li></ul><p class=ql-align-justify><strong>远程服务提供者实现</strong></p><ul><li class=ql-align-justify>提供远程服务的过程和响应web请求很相似, 只不过响应的不是&lt;html>标签, 而是json字符串. 微信小程序前后端通信也是这个原理.</li></ul><ol><li class=ql-align-justify>创建名为order-sys的Maven项目, 指定打包为war包.</li></ol><p>点击这里查看pom.xml文件, 常规操作</p><p class=ql-align-justify></p><ol><li class=ql-align-justify>创建订单类</li></ol><pre class=ql-align-justify>public class Order { private String id; private Double total; private String date; //get / set ...}</pre><ol><li class=ql-align-justify>对外提供服务, 发布时打包发布到Tomcat上</li></ol><pre class=ql-align-justify>@Controllerpublic class OrderController { /** * 接收http请求, 响应订单集合, 异步响应 * 将list集合序列化为json串响应 * @param uid * @return */ @RequestMapping("/loadOrderList2") @ResponseBody public List&lt;Order&gt; loadOrderList2(String uid){ System.out.println("uid: " + uid); //模拟订单数据 Order o1 = new Order(); o1.setId("111"); o1.setTotal(333.33); o1.setDate("2019-4-29"); Order o2 = new Order(); o2.setId("222"); o2.setTotal(444.44); o2.setDate("2019-5-29"); Order o3 = new Order(); o3.setId("333"); o3.setTotal(555.55); o3.setDate("2019-6-29"); List&lt;Order&gt; list = new ArrayList&lt;&gt;(); list.add(o1); list.add(o2); list.add(o3); return list; }}</pre><p class=ql-align-justify><strong>远程服务消费者实现</strong></p><ol><li class=ql-align-justify>在服务消费端使用HttpClient发送请求, 可以理解为模拟浏览器发送post/get请求. HttpClient为我们封装了拼接一个请求的细节, 使得发送一个请求变得容易.</li></ol><pre class=ql-align-justify>public static void main(String[] args) throws IOException { //发送远程的http请求的地址 String url = "http://localhost:7070/order/loadOrderList2"; //创建HttpClient对象 CloseableHttpClient client = HttpClients.createDefault(); //创建HttpPost对象, 发送post请求 HttpPost method = new HttpPost(url); //封装发送到服务提供者的参数 NameValuePair id = new BasicNameValuePair("uid", "10001"); List&lt;NameValuePair&gt; params = new ArrayList&lt;&gt;(); params.add(id); //封装请求体数据 method.setEntity(new UrlEncodedFormEntity(params, "UTF-8")); //发送具体的http请求 HttpResponse response = client.execute(method); //获得服务提供者响应的具体数据 HttpEntity entity = response.getEntity(); //获得http的响应体 InputStream is = entity.getContent(); int len = 0; char[] buf = new char[1024]; //使用字符流读 InputStreamReader reader = new InputStreamReader(is); StringBuffer sb = new StringBuffer(); while((len = reader.read(buf)) != -1){ sb.append(String.valueOf(buf, 0, len)); } System.out.println(sb); //将响应回来的json字符串解析为Order集合 List&lt;Order&gt; list = JSON.parseArray(sb.toString(), Order.class); for(Order o : list){ System.out.println(o.getId() + "\t" + o.getTotal() + "\t" + o.getDate()); }}</pre><p class=ql-align-justify></p><h1 class=ql-align-justify><strong>四. 通过spring提供的RestTemplate实现远程服务的生产与消费</strong></h1><ul><li class=ql-align-justify>通过一个红包系统和订单系统进行演示, 红包系统访问订单系统, 获得某个用户的订单信息, 派发红包.</li><li class=ql-align-justify>订单系统继续沿用HttpClient中的订单系统, 通过访问loadOrderList2方法能返回一个订单集合Json字符串.</li></ul><p class=ql-align-justify><strong>远程服务消费者实现.</strong></p><pre class=ql-align-justify>@Controllerpublic class RedController { //注入由spring提供的RestTemplate对象 @Autowired private RestTemplate restTemplate; /** * 发送远程的http请求, 消费http服务 * 获得订单对象的集合 */ @RequestMapping("/loadOrderList3") @ResponseBody public List&lt;ResponseEntity&lt;Order[]&gt;&gt; loadOrderList3(String uid){ //发送远程http请求的url String url = "http://localhost:7070/order/loadOrderList2"; //发送到远程服务的参数 MultiValueMap&lt;String, Object&gt; params = new LinkedMultiValueMap&lt;&gt;(); params.add("uid", uid); //通过RestTemplate对象发送post请求 ResponseEntity&lt;Order[]&gt; entitys = restTemplate.postForEntity(url, params, Order[].class); //查看响应的状态码 System.out.println(entitys.getStatusCodeValue()); //查看响应头 HttpHeaders headMap = entitys.getHeaders(); for(Map.Entry&lt;String, List&lt;String&gt;&gt; m : headMap.entrySet()){ System.out.println(m.getKey() + ": " + m.getValue()); } return Arrays.asList(entitys); }}</pre><p>欢迎工作一到五年的Java工程师朋友们加入Java程序员开发： 721575865</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用"没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','实现','远程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>