<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>spring框架之AOP面向切面编程 | 极客快訊</title><meta property="og:title" content="spring框架之AOP面向切面编程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9b61c468edc241dda89e2ac1e5fabd74"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/7d826c93.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/7d826c93.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="spring框架之AOP面向切面编程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/7d826c93.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>spring框架之AOP面向切面编程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>今天是刘小爱自学Java的第123天。</p><p style=text-align:start>感谢你的观看，谢谢你。</p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b61c468edc241dda89e2ac1e5fabd74><p class=pgc-img-caption></p></div><p style=text-align:start>学过很多面向XX编程，比如：</p><p style=text-align:start>面向过程编程，面向对象编程，面向接口编程，现在又是面向切面编程。</p><p style=text-align:start>但是不管如何，说来说去最终都是面向搜索引擎编程：面向百度编程，面向谷歌编程。</p><p style=text-align:start>今日学习内容安排：</p><ul><li>AOP的引入，它到底是干嘛的？</li><li>AOP面向切面编程的思想概述，以及其常见术语的解释说明。</li><li>两种AOP底层实现机制，同时也是对动态代理的再一次回顾学习。</li></ul><p style=text-align:start>本来是打算将AOP知识点糅合到一篇文章中说明的，但是内容实在是太多了，写了近三千字一半都还没有学到，看来还是得慢慢来了。</p><h1 class=pgc-h-arrow-right><strong>一、AOP的引入</strong></h1><p style=text-align:start>在学它之前，我们先要搞清楚它是干嘛的？</p><p style=text-align:start>dao层的方法基本都是增删改查，现在需要将所有方法都增加打印日志的功能，怎么办？</p><p style=text-align:start>如果我们每个方法里面都实现打印日志的功能，那也太复杂了，所以选择封装：</p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f133a3263e984743879429fe2f93354d><p class=pgc-img-caption></p></div><p style=text-align:start><strong>①方法的封装</strong></p><p style=text-align:start>我们将打印日志的功能封装到一个特有方法中，只需要在其它方法中调用该方法即可。</p><p style=text-align:start>但是这样就有一个很大的问题：</p><p style=text-align:start>dao层不只有userDao这个类，还有其它的类，也需要打印日志的功能，那怎么办？</p><p style=text-align:start><strong>②继承</strong></p><p style=text-align:start>我们将打印日志的功能封装到一个类中，哪个类需要该方法就继承它即可，根据继承的原则：子类可以直接使用父类的方法。</p><p style=text-align:start>但是代码还是有问题，会出现代码的侵入。</p><p style=text-align:start>有没有方法可以不用修改类中方法的任何内容，就能实现方法的拓展？</p><p style=text-align:start>有，就是代理类的使用。</p><p style=text-align:start><strong>注意</strong>：我举的这些例子都是伪代码，并不代表本身的业务逻辑，只是为了引出AOP的概念。</p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f4aa8d2fface4ac6ae3343375233d1e8><p class=pgc-img-caption></p></div><p style=text-align:start><strong>③代码的侵入</strong></p><p style=text-align:start>我们想给方法增加功能，使用继承的话都需要在对应方法中调用一个打印日志的方法。</p><p style=text-align:start>对方法本身修改了，有代码侵入，这是不符合OCP原则的，即对扩展开放，对修改关闭：<strong>你增强我的功能可以，但你不可以修改我</strong>。</p><p style=text-align:start><strong>④使用代理</strong></p><p style=text-align:start>在被代理类方法的基础上，拓展了一个打印日志的方法，本身的方法并没有发生任何变化。</p><p style=text-align:start>当然这里也是伪代码，并没有使用到动态代理，文章后面有更详细的一步步说明。</p><p style=text-align:start>我们以继承->代理的这种代码变化过程，引出AOP面向切面编程的概念。</p><h1 class=pgc-h-arrow-right><strong>二、AOP概述及相关术语</strong></h1><p style=text-align:start>AOP全称Aspect Oriented Programing，翻译为面向切面编程，它是一种编程思想。</p><p style=text-align:start>我们都知道Java是一门面向对象编程的，即OOP全称Object Oriented Programming。</p><p style=text-align:start>AOP是OOP思想上的延续，采取<strong>横向抽取机制</strong>，取代了<strong>传统纵向继承</strong>体系重复性代码的编写。</p><p style=text-align:start>简单的理解就是，它的作用和继承很像，但是它比继承要更强，用一句来说明AOP就是：</p><p style=text-align:start>基于原有目标对象，创建代理对象，在不修改原对象代码情况下，通过代理对象调用增强功能的代码，从而对原有方法进行增强 。</p><p style=text-align:start><strong>关于AOP编程相关术语</strong></p><p style=text-align:start>这些术语太生涩难懂了，每一个概念涉及到的知识面还很广，想要完全弄懂太难了。</p><p style=text-align:start>这里用一个例子来做说明，当然说明并不是很准确，但是对于新手来说方便理解记忆。</p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1687d0f90830407ab1e30a1cbd9547d3><p class=pgc-img-caption></p></div><p style=text-align:start><strong>①目标对象Target</strong></p><p style=text-align:start>也就是需要被增强的对象。</p><p style=text-align:start><strong>②织入Weaving</strong></p><p style=text-align:start>根据目标对象来创建代理对象的整个过程。</p><p style=text-align:start><strong>③代理对象Proxy</strong></p><p style=text-align:start>即根据目标对象生成的代理对象。</p><p style=text-align:start><strong>④连接点JoinPoint</strong></p><p style=text-align:start>所谓连接点是指那些被拦截到的点。</p><p style=text-align:start>就可以理解成对象中的方法，因为在Spring中，只支持方法类型的连接点。</p><p style=text-align:start><strong>⑤切入点PointCut</strong></p><p style=text-align:start>所谓切入点就是连接点的一部分，即需要被拦截的连接点就是切入点。</p><p style=text-align:start>就可以理解成对象中需要增强的方法。</p><p style=text-align:start><strong>⑥通知Advice</strong></p><p style=text-align:start>也就是增强的方法，例子中就是记录日志。</p><p style=text-align:start>通知分为前置通知、后置通知、异常通知、最终通知、环绕通知，这些后续会讲述。</p><p style=text-align:start><strong>⑦切面Aspect</strong></p><p style=text-align:start>是通知和切入点的结合，通知和切入点共同定义了关于切面的全部内容。它的功能、在何时和何地完成其功能？说白了也就是：</p><p style=text-align:start>如何将增强方法添加到对应的方法中？</p><p style=text-align:start><strong>此外还有一个术语叫：引介Introduction</strong></p><p style=text-align:start>在不修改类代码的前提下, Introduction可以在运行期为类动态地添加一些方法或属性，这个实际开发中基本涉及不到。</p><p style=text-align:start>AOP是基于动态代理的，基于两种动态代理机制：JDK动态代理和CGLIB动态代理。</p><h1 class=pgc-h-arrow-right><strong>三、JDK动态代理实现AOP</strong></h1><p style=text-align:start>当然JDK动态代理很少使用，但是还是都写下，就当是对动态代理知识点的一个回顾。</p><p style=text-align:start>创建工厂类，该类可以获取代理类对象：</p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f54b978212054e1ba0c42bb75080d77c><p class=pgc-img-caption></p></div><p style=text-align:start><strong>①获取代理对象方法</strong></p><p style=text-align:start>通过代理工厂的该方法就可以获取一个代理对象，为了通用性将返回值设定为Object。</p><p style=text-align:start><strong>②实例化代理类对象</strong></p><p style=text-align:start>Proxy类的静态方法newProxyInstance()，根据方法名也能知道它是干嘛的，基本上动态代理的核心就是这个方法，参数有三个：</p><ul><li>目标对象的类加载器。</li><li>目标对象实现的接口有哪些。</li><li>调用处理器。</li></ul><p style=text-align:start>当然，其代码编写有更优的方式，在Cglib动态代理中会说明，此处就使用最原始的方式。</p><p style=text-align:start><strong>③调用处理器</strong></p><p style=text-align:start>InvocationHandler是一个接口，使用匿名内部类的方式获取其对象，其有一个方法叫invoke，该方法也有三个参数。</p><p style=text-align:start>如果方法名是我们需要增强的方法，那么我们给它增加一个功能，也就是④。</p><p style=text-align:start>如果不是，那么调用自己就好了，也就是method.invoke(target,args)。</p><p style=text-align:start><strong>代码写完，做个测试</strong></p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7e1d18480c594b13a29634859f10dcd1><p class=pgc-img-caption></p></div><p style=text-align:start><strong>⑤功能测试</strong></p><p style=text-align:start>因为在动态代理中我们只选择对queryAll方法增强，所以用代理对象调用queryAll方法时会额外输出“记录日志”。</p><p style=text-align:start>而update方法不增强，就只会执行本身的功能，也就是“更新数据”。</p><p style=text-align:start>当然Jdk动态代理有一个局限，就是必须要有接口才行，所以就引出了CGLIB的使用。</p><h1 class=pgc-h-arrow-right><strong>四、CGLIB动态代理</strong></h1><p style=text-align:start>CGLIB(Code Generation Library)是一个强大的，高性能的开源项目。</p><p style=text-align:start>其作用最直接的解释就是：不需要接口也可以实现动态代理。</p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0665c80522674b768e911236988c45c2><p class=pgc-img-caption></p></div><p style=text-align:start><strong>①获取代理对象生成器</strong></p><p style=text-align:start>Enhancer，增强器的意思，也就是通过它来实现方法的增强。</p><p style=text-align:start><strong>②设置目标对象的Class对象</strong></p><p style=text-align:start>该参数是目标对象的Class对象，不是类加载器，和Jdk动态代理有一定的区别。</p><p style=text-align:start><strong>③设置回调函数</strong></p><p style=text-align:start>Jdk动态代理中的三个参数：类加载器、接口以及调用处理器，Cglib中不需要接口，该参数就相当于jdk动态代理中的调用处理器。</p><p style=text-align:start>setCallback方法的参数需要该接口的实现类对象，我们可以直接使用匿名内部类的方式作为参数，就和调用处理器一样。</p><p style=text-align:start>但是在本类中实现这个接口，不就有了一个现成的实现类么？而this表示谁调用我就是谁，本类或者本类的子类都行。</p><p style=text-align:start>这里进一步优化代码的编写，上述Jdk动态代理中也可以这样优化。</p><p style=text-align:start><strong>④intercept方法</strong></p><p style=text-align:start>这是MethodInterceptor接口中的一个方法，intercept，翻译就是拦截的意思。</p><p style=text-align:start>其参数和Jdk中的调用处理器基本一样。</p><p style=text-align:start><strong>⑤生成代理对象</strong></p><p style=text-align:start>enhancer调用create()生成代理对象。</p><p style=text-align:start><strong>代码写完，做个测试</strong></p><div class=pgc-img><img alt=spring框架之AOP面向切面编程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b9f28ba43d3489e83d9f1fa4d3d92ff><p class=pgc-img-caption></p></div><p style=text-align:start><strong>⑥方法测试</strong></p><p style=text-align:start>通过运行结果我们可以发现：和Jdk动态代理能达到一样增强选定方法的效果。</p><p style=text-align:start>注意：目标对象CustomerServicePlus并没有实现接口，如果使用Jdk动态代理是不行的，得使用Cglib动态代理才可以。</p><h1 class=pgc-h-arrow-right><strong>最后</strong></h1><p style=text-align:start>谢谢你的观看。</p><p style=text-align:start>如果可以的话，麻烦帮忙点个赞，谢谢你。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'spring','AOP','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>