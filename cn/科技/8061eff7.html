<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java核心数据结构(List、Map、Set)原理与使用技巧 | 极客快訊</title><meta property="og:title" content="Java核心数据结构(List、Map、Set)原理与使用技巧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/ca0269a1e4e94f69a8f725a31086a788"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8061eff7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8061eff7.html><meta property="article:published_time" content="2020-11-14T21:02:06+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:06+08:00"><meta name=Keywords content><meta name=description content="Java核心数据结构(List、Map、Set)原理与使用技巧"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8061eff7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java核心数据结构(List、Map、Set)原理与使用技巧</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>关注Java知音，专注于Java技术文章推送</p></blockquote><h1><strong>往期推荐：</strong></h1><p><a class=pgc-link href="https://www.toutiao.com/i6470356380149629454/?group_id=6470356380149629454" target=_blank>「精选」六款JavaWeb项目源码下载</a></p><p><a class=pgc-link href="https://www.toutiao.com/i6628369933728219652/?group_id=6628369933728219652" target=_blank>漫画｜Servlet属于线程安全的吗？</a></p><p class=ql-align-center><a class=pgc-link href="https://www.toutiao.com/i6630705140611416590/?group_id=6630705140611416590" target=_blank>漫画｜你还记得原生的JDBC怎么连接数据库吗？</a></p><p>JDK提供了一组主要的数据结构实现，如List、Map、Set等常用数据结构。这些数据都继承自java.util.Collection接口，并位于java.util包内。</p><p><strong>一、List接口</strong></p><p>最重要的三种List接口实现：ArrayList、Vector、LinkedList。它们的类图如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=Java核心数据结构(List、Map、Set)原理与使用技巧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ca0269a1e4e94f69a8f725a31086a788><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>可以看到，3种List均来自AbstratList的实现。而AbstratList直接实现了List接口，并扩展自AbstratCollection。</p><p>ArrayList和Vector使用了数组实现，可以认为，ArrayList封装了对内部数组的操作。比如向数组中添加、删除、插入新的元素或数组的扩展和重定义。对ArrayList或者Vector的操作，等价于对内部对象数组的操作。</p><p>ArrayList和Vector几乎使用了相同的算法，它们的唯一区别可以认为是对多线程的支持。ArrayList没有对一个方法做线程同步，因此不是线程安全的。Vector中绝大多数方法都做了线程同步，是一种线程安全的实现。因此ArrayList和Vector的性能特性相差无几。</p><p>LinkedList使用了循环双向链表数据结构。LinkedList由一系列表项连接而成。一个表项总是包含3个部分：元素内容、前驱表项和后驱表项。如图所示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=Java核心数据结构(List、Map、Set)原理与使用技巧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af6c4f904de7471989ddc6757689352b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>LinkedList的表项源码：</p><pre>private static class Node&lt;E&gt; { E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) { this.item = element; this.next = next; this.prev = prev; }}</pre><p>无论LinkedList是否为空，链表都有一个header表项，它既是链表的开始，也表示链表的结尾。它的后驱表项便是链表的第一个元素，前驱表项便是链表的最后一个元素。如图所示：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=Java核心数据结构(List、Map、Set)原理与使用技巧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/695e4cd1d5834ac9bcf710622736e18d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>下面比较下ArrayList和LinkedList的不同。</p><p><strong>1、增加元素到列表尾端</strong></p><p>对于ArrayList来说，只要当前容量足够大，add()操作的效率是非常高的。</p><p>只有当ArrayList对容量的需求超过当前数组的大小时，才需要进行扩容。扩容会进行大量的数组复制操作。而复制时最终调用的是System.arraycopy()方法，因此，add()效率还是相当高的。</p><p>LinkedList由于使用了链表的结构，因此不需要维护容量的大小。这点比ArrayList有优势，不过，由于每次元素增加都需要新建Node对象，并进行更多的赋值操作。在频繁的系统调用中，对性能会产生一定影响。</p><p><strong>2、插入元素到列表任意位置</strong></p><p>ArrayList是基于数组实现的，而数组是一块连续的内存空间，每次插入操作，都会进行一次数组复制。大量的数组复制会导致系统性能低下。</p><p>LinkedList是基于链表实现的，在任意位置插入和在尾端增加是一样的。所以，如果系统应用需要对List对象在任意位置进行频繁的插入操作，可以考虑用LinkedList替代ArrayList。</p><p><strong>3、删除任意位置元素</strong></p><p>对ArrayList来说，每次remove()移除元素都需要进行数组重组。并且元素位置越靠前开销越大，要删除的元素越靠后，开销越小。</p><p>在LinkedList的实现中，首先需要通过循环找到要删除的元素。如果要删除的元素位置处于List的前半段，则从前往后找；若处于后半段，则从后往前找。如果要移除中间位置的元素，则需要遍历完半个List，效率很低。</p><p><strong>4、容量参数</strong></p><p>容量参数是ArrayList 和 Vector等基于数组的List的特有性能参数，它表示初始数组的大小。</p><p>合理的设置容量参数，可以减少数组扩容，提升系统性能。</p><p>默认ArrayList的数组初始大小为10。</p><pre>private static final int DEFAULT_CAPACITY = 10;</pre><p><strong>5、遍历列表</strong></p><p>常用的三种列表遍历方式：ForEach操作、迭代器和for循环。</p><p>对于ForEach操作，反编译可知实际上是将ForEach循环体作为迭代器处理。不过ForEach比自定义的迭代器多了一步赋值操作，性能不如直接使用迭代器的方式。</p><p>使用For循环通过随机访问遍历列表，ArrayList表现很好，速度最快；但是LinkedList的表现非常差，应避免使用，这是因为对LinkedList的随机访问时，总会进行一次列表的遍历操作。</p><p><strong>二、Map接口</strong></p><p>Map是一种非常常用的数据结构。围绕着Map接口，最主要的实现类有Hashtable, HashMap, LinkedHashMap 和 TreeMap，在Hashtable中，还有Properties 类的实现。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=Java核心数据结构(List、Map、Set)原理与使用技巧 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/996c4c27a31f42658defebc7dabe833c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>Hashtable和hashMap的区别在于Hashtable的大部分方法都做了线程同步，而HashMap没有，因此，Hashtable是线程安全的，HashMap不是。其次，Hashtable 不允许key或value使用null值，而HashMap可以。</p><p>第三，它们在内部对key的hash算法和hash值到内存索引的映射算法不同。</p><p>由于HashMap使用广泛，本文以HashMap为例，阐述它的实现原理。</p><p><strong>1、HashMap的实现原理</strong></p><p>简单来说，HashMap就是将key做hash算法，然后将hash值映射到内存地址，直接取得key所对应的数据。在HashMap中，底层数据结构使用的是数组。所谓的内存地址，就是数组的下标索引。</p><p>用代码简单表示如下：</p><pre>object[key_hash] = value;</pre><p><strong>2、Hash冲突</strong></p><p>当需要存放的两个元素1和2经hash计算后，发现对应在内存中的同一个地址。此时HashMap又会如何处理以保证数据的完整存放？</p><p>在HashMap的底层使用数组，但数组内的元素不是简单的值，而是一个Entity类的对象。每一个Entity表项包括key，value，next，hash几项。注意这里的next部分，它指向另外一个Entity。</p><p>当put()操作有冲突时，新的Entity会替换原有的值，为了保证旧值不丢失，会将next指向旧值。这便实现了在一个数组空间内存放多个值项。因此，HashMap实际上是一个链表的数组。</p><p>而在进行get()操作时，如果定位到的数组元素不含链表（当前entry的next指向null），则直接返回；如果定位到的数组元素包含链表，则需要遍历链表，通过key对象的equals方法逐一比对查找。</p><p><strong>3、容量参数</strong></p><p>和ArrayList一样，基于数组的结构，不可避免的需要在数组空间不足时，进行扩展。而数组的重组比较耗时，因此对其做一定的优化很有必要了。</p><p>HashMap提供了两个可以指定初始化大小的构造函数：</p><pre>HashMap(int initialCapacity)  构造一个带指定初始容量和默认负载因子 (0.75) 的空 HashMap。</pre><hr><pre>HashMap(int initialCapacity, float loadFactor)  构造一个带指定初始容量和负载因子的空 HashMap。</pre><p>其中，HashMap会使用大于等于initialCapacity并且是2的指数次幂的最小的整数作为内置数组的大小。</p><p>负载因子又叫做填充比，它是介于0和1之间的浮点数。</p><p>负载因子 = 实际元素个数 / 内部数组总大小</p><p>负载因子的作用就是决定HashMap的阈值（threshold）。</p><p>阈值 = 数组总容量 × 负载因子</p><p>当HashMap的实际容量超过阈值便会进行扩容，每次扩容将新的数组大小设置为原大小的1.5倍。</p><p>默认情况下，HashMap的初始大小是16，负载因子为0.75。</p><pre>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16static final float DEFAULT_LOAD_FACTOR = 0.75f;</pre><p><strong>4、LinkedHashMap</strong></p><p>LinkedHashMap继承自HashMap，因此，它具备了HashMap的优良特性，并在此基础上，LinkedHashMap又在内部增加了一个链表，用以存放元素的顺序。因此，LinkedHashMap可以简单理解为一个维护了元素次序表的HashMap.</p><p>LinkedHashMap提供两种类型的顺序：一是元素插入时的顺序；二是最近访问的顺序。</p><pre>LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder)  构造一个带指定初始容量、负载因子和排序模式的空 LinkedHashMap 实例</pre><p>其中accessOrder为true时，按照元素最后访问时间排序；当accessOrder为false 时，按照插入顺序排序。默认为 false 。</p><p>在内部实现中，LinkedHashMap通过继承HashMap.Entity类，实现LinkedHashMap.Entity，为HashMap.Entity增加了before和after属性用以记录某一表项的前驱和后继，并构成循环链表。</p><p><strong>5、TreeMap</strong></p><p>TreeMap可以简单理解为一种可以进行排序的Map实现。与LinkedHashMap不同，LinkedHashMap是根据元素增加或者访问的先后顺序进行排序，而TreeMap则根据元素的Key进行排序。为了确定Key的排序算法，可以使用两种方式指定：</p><p>（1）在TreeMap的构造函数中注入一个Comparator：</p><pre>TreeMap(Comparator&lt;? super K&gt; comparator) </pre><p>（2）使用一个实现了 Comparable 接口的 Key。</p><blockquote><p>TreeMap的内部实现是基于红黑树的。红黑树是一种平衡查找树，这里不做过多介绍。</p></blockquote><p>TreeMap 其它排序接口如下：</p><pre>subMap(K fromKey, K toKey)  返回此映射的部分视图，其键值的范围从 fromKey（包括）到 toKey（不包括）。</pre><hr><pre>tailMap(K fromKey)  返回此映射的部分视图，其键大于等于 fromKey。</pre><hr><pre>firstKey()  返回此映射中当前第一个（最低）键。</pre><hr><pre>headMap(K toKey)  返回此映射的部分视图，其键值严格小于 toKey。</pre><p>一个简单示例如下：</p><pre>public class MyKey implements Comparable&lt;MyKey&gt; { private int id; public MyKey(int id) { this.id = id; } @Override public int compareTo(MyKey o) { if (o.id &lt; this.id){ return 1; }else if (o.id &gt; this.id){ return -1; } return 0; } public static void main(String[] args) { MyKey myKey1 = new MyKey(1); MyKey myKey2 = new MyKey(2); MyKey myKey3 = new MyKey(3); Map&lt;MyKey,Object&gt; map = new TreeMap&lt;&gt;(); map.put(myKey1,"一号"); map.put(myKey3,"三号"); map.put(myKey2,"二号"); Iterator&lt;MyKey&gt; iterator = map.keySet().iterator(); while (iterator.hasNext()){ System.out.println(map.get(iterator.next())); } }}</pre><p><strong>三、Set接口</strong></p><p>Set并没有在Collection接口之上增加额外的操作，Set集合中的元素是不能重复的。</p><p>其中最为重要的是HashSet、LinkedHashSet、TreeSet 的实现。这里不再一一赘述，因为所有的这些Set实现都只是对应的Map的一种封装而已。</p><p><strong>四、优化集合访问代码</strong></p><p><strong>1、分离循环中被重复调用的代码</strong></p><p>举个例子，当我们要使用for循环遍历集合时</p><pre>for (int i =0;i&lt;collection.size();i++){ //.....}</pre><p>很明显，每次循环都会调用size()方法，并且每次都会返回相同的数值。分离所有类似的代码对提升循环性能有着积极地意义。因此，可以将上段代码改造成</p><pre>int size= collection.size();for (int i =0;i&lt;size;i++){ //.....}</pre><p>当元素的数量越多时，这样的处理就越有意义。</p><p><strong>2、省略相同的操作</strong></p><p>假设我们有一段类似的操作如下</p><pre>int size= collection.size();for (int i =0;i&lt;size;i++){ if (list.get(i)==1||list.get(i)==2||list.get(i)==3){ //... }}</pre><p>虽然每次循环调用get(i)的返回值不同，但在同一次调用中，结果是相同的，因此可以提取这些相同的操作。</p><pre>int size= collection.size();int k=0;for (int i =0;i&lt;size;i++){ if ((k = list.get(i))==1||k==2||k==3){ //... }}</pre><p><strong>3、减少方法调用</strong></p><p>方法调用是需要消耗系统堆栈的，如果可以，则尽量访问内部元素，而不要调用对应的接口，函数调用是需要消耗系统资源的，直接访问元素会更高效。</p><p>假设上面的代码是Vector.class的子类的部分代码，那么可以这么改写</p><pre>int size = this.elementCount;Object k=null;for (int i =0;i&lt;size;i++){ if ((k = elementData[i])=="1"||k=="2"||k=="3"){ //... }}</pre><p>可以看到，原本的 size() 和 get() 方法被直接替代为访问原始变量，这对系统性能的提升是非常有用的。</p><p><strong>五、RandomAccess接口</strong></p><p>RandomAccess接口是一个标志接口，本身并没有提供任何方法，任何实现RandomAccess接口的对象都可以认为是支持快速随机访问的对象。此接口的主要目的是标识那些可以支持快速随机访问的List实现。</p><p>在JDK中，任何一个基于数组的List实现都实现了RandomAccess接口，而基于链表的实现则没有。这很好理解，只有数组能够快速随机访问，（比如：通过 object[5]，object[6]可以直接查找并返回对象），而对链表的随机访问需要进行链表的遍历。</p><p>在实际操作中，可以根据list instanceof RandomAccess来判断对象是否实现 RandomAccess接口，从而选择是使用随机访问还是iterator迭代器进行访问。</p><p>在应用程序中，如果需要通过索引下标对 List 做随机访问，尽量不要使用 LinkedList，ArrayList和Vector都是不错的选择。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','数据','结构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>