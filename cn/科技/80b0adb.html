<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>第五章 栈和队列 | 极客快訊</title><meta property="og:title" content="第五章 栈和队列 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f539b17725974b3fb257d8e003e0edbc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/80b0adb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/80b0adb.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="第五章 栈和队列"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/80b0adb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>第五章 栈和队列</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>第五章 栈和队列</strong></h1><h1 class=pgc-h-arrow-right><strong>5.1 栈</strong></h1><h1 class=pgc-h-arrow-right><strong>5.1.2 栈概述</strong></h1><p style=text-align:start><strong>栈（stack）又名堆栈</strong>，它是一种运算受限的线性表。在计算机中栈被定义为一个特殊的容器。其限制是仅允许在表的一端进行插入和删除操作。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈（push），它是把新元素存放到栈顶元素的上面，使之成为新的栈顶元素；也可以将已经压入到栈中的元素弹出，即从一个栈删除元素又称作出栈或退栈（pop），它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><p style=text-align:start><strong>【栈结构图】</strong></p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 栈和队列" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f539b17725974b3fb257d8e003e0edbc><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>栈按照<strong>先进后出</strong> <strong>（First In Last Out，FILO）</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p><p style=text-align:start>栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈底固定，而栈顶浮动；栈中元素个数为零时称为空栈。插入一般称为进栈（push），删除则称为退栈（pop）。栈也称为后进先出表。</p><p style=text-align:start>计算机系统中，栈是一个具有以上属性的动态内存区域。程序可以将数据压入栈中，也可以将数据从栈顶弹出。压栈操作使得栈增长变大，而弹出操作使栈减短缩小。</p><h1 class=pgc-h-arrow-right><strong>5.1.2 栈的表示和实现</strong></h1><p style=text-align:start><strong>进栈（PUSH）算法：</strong></p><p style=text-align:start>① 若TOP≥n时，则给出溢出信息，作出错处理（进栈前首先检查栈是否已满，满则溢出；不满则作②）；</p><p style=text-align:start>② 置TOP=TOP+1（栈指针加1，指向进栈地址）；</p><p style=text-align:start>③ S(TOP)=X，结束（X为新进栈的元素）；</p><p style=text-align:start><strong>退栈（POP）算法：</strong></p><p style=text-align:start>① 若TOP≤0，则给出下溢信息，作出错处理（退栈前先检查是否已为空栈， 空则下溢；不空则作②）；</p><p style=text-align:start>② X=S(TOP)，（退栈后的元素赋给X）；</p><p style=text-align:start>③ TOP=TOP-1，结束（栈指针减1，指向栈顶）。</p><p style=text-align:start><strong>定义stack的简单代码：</strong></p><p style=text-align:start>stack&lt;int> myStack;</p><p style=text-align:start>入栈：myStack.push(x);</p><p style=text-align:start>出栈：myStack.pop();</p><p style=text-align:start>栈顶元素：myStack.top();</p><p style=text-align:start>判断栈的大小： myStack.size();</p><p style=text-align:start>判断栈是否为空：myStack.empty();</p><p style=text-align:start><strong>【程序实现</strong>】</p><pre><code>#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#define N 10typedef struct{    int data[N];    int top;} SqStack;    //顺序栈类型别名​//初始化栈SqStack* initStack(){    SqStack* s = (SqStack * )malloc(sizeof(SqStack));    s-&gt;top = -1;    return s;}​//取栈顶元素int getTop(SqStack * s, int* e){    if (s-&gt;top == -1) {        return -1;    }    *e = s-&gt;data[s-&gt;top];    return *e;}​//进栈int Push(SqStack * s, int e){    if (s-&gt;top == N - 1) {        return -1;    }    s-&gt;top ++;    s-&gt;data[s-&gt;top] = e;    return 1;}​//出栈int Pop(SqStack * s, int* e){    if (s-&gt;top == -1) {        return -1;    }    *e = s-&gt;data[s-&gt;top];    s-&gt;top--;    return 1;}​//销毁栈void destroyStack(SqStack * s){    free(s);}​//测试栈的初始化、入栈、出栈、获取栈顶元素等功能int main(){    printf("初始化栈...\n");    SqStack* s = initStack();        printf("入栈中...\n");    Push(s,1);    Push(s,2);    Push(s,3);    printf("入栈完成...\n");        printf("获取栈顶元素:\n");    int y;    getTop(s, &amp;y);    printf("y: %d\n",y);        printf("出栈:\n");    int x;    Pop(s,&amp;x);    printf("x:%d\n",x);    Pop(s,&amp;x);    printf("x:%d\n",x);    Pop(s,&amp;x);    printf("x:%d\n",x);        printf("销毁栈...\n");    destroyStack(s);    return 0;}</code></pre><h1 class=pgc-h-arrow-right><strong>5.2 队列</strong></h1><h1 class=pgc-h-arrow-right><strong>5.2.1 队列概述</strong></h1><p style=text-align:start>与栈相反，<strong>队列（queue）</strong>是一种<strong>先进先出</strong>（first in first out，缩写为FIFO）的线性表。它只允许在表的一端进行插入元素，而在另一端删除元素。</p><p style=text-align:start>在队列中，允许插入的一端叫做<strong>队尾</strong>（rear），允许删除的一端则称为<strong>队头</strong>（front）。</p><p style=text-align:start>队列拥有两种表示和实现方式：</p><p style=text-align:start>1、队列的链式表示和实现--<strong>链队列</strong></p><p style=text-align:start>2、队列的顺序表示和实现--循<strong>环队列</strong></p><h1 class=pgc-h-arrow-right><strong>5.2.2 链队列—队列的链式表示和实现</strong></h1><p style=text-align:start>用链表表示的队列简称为<strong>链队列</strong>。一个链队列需要两个分别指示队头和队尾的指针（分别称为头指针和尾指针）才能唯一确定。为操作方便，给链队列添加一个头结点，并令头指针指向头结点。由此，空的链队列的判断条件为头指针和尾指针均指向头结点。</p><p style=text-align:start><strong>【链队列结构图】</strong></p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 栈和队列" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/493048f1ec0040b6a7d737259835ef92><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong>【链队列操作示意图】</strong>　</p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 栈和队列" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5dada01c953745beb8802bfd29bf9716><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong>【程序实现】</strong></p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;​#define OVERFLOW -2#define ERROR 0#define OK 1​typedef int Status;​typedef int QElemType;​typedef struct QNode {    QElemType data;    struct QNode *next;    }QNode,*QueuePtr;​typedef struct {    QueuePtr front; //队头指针    QueuePtr rear; //队尾指针}LinkQueue;​/***********    初始化队列   ***********/Status InitQueue(LinkQueue * Q){    Q-&gt;front=Q-&gt;rear=(QueuePtr)malloc(sizeof(QNode));        if (!Q-&gt;front)        exit(OVERFLOW);        Q-&gt;front-&gt;next=NULL;        return OK;}​/***********    入队列    ***********/Status EnQueue(LinkQueue *Q, QElemType e){    //插入元素e为Q的新的队尾元素    QueuePtr p;        p = (QueuePtr)malloc(sizeof(QNode));        if(!p)        exit(OVERFLOW);        p-&gt;data=e;    p-&gt;next=NULL;        Q-&gt;rear-&gt;next=p;    Q-&gt;rear=p;        return OK;}​/***********    出队列    ***********/Status DeQueue(LinkQueue *Q, QElemType *e){    //若队列不空,则删除Q的头元素，用e返回其值，并返回OK。    QueuePtr p;        if(Q-&gt;front==Q-&gt;rear)        exit(ERROR);        p=Q-&gt;front-&gt;next;        *e=p-&gt;data; // 一定是*e        Q-&gt;front-&gt;next=p-&gt;next;        if(Q-&gt;rear==p)        Q-&gt;rear=Q-&gt;front;        free(p);        return OK;}​/***********    销毁队列Q   ***********/Status DestroyQueue(LinkQueue * Q){    while (Q-&gt;front) {        Q-&gt;rear = Q-&gt;front-&gt;next;                free(Q-&gt;front);                Q-&gt;front = Q-&gt;rear;    }        return OK;}​int main(){    LinkQueue *Q;    QElemType e;        /***********    初始化队列   ***********/    InitQueue(Q);        printf("请输入5个整数：");    for(int i=0; i&lt;5; i++)    {        /***********    入队列    ***********/        scanf("%d",&amp;e);        EnQueue(Q,e);    }        printf("输出结果为：\n");    while (Q-&gt;front!=Q-&gt;rear)    {        /***********    出队列    ***********/        DeQueue(Q,&amp;e);        printf("%d,",e);    }    printf("\n");        /***********    销毁队列Q   ***********/    DestroyQueue(Q);        return 0;}</code></pre><h1 class=pgc-h-arrow-right><strong>5.2.3 循环队列—队列的顺序表示和实现</strong></h1><p style=text-align:start>为充分利用向量空间，克服"<strong>假溢出</strong>"现象的方法是：将向量空间想象为一个首尾相接的圆环，并称这种向量为循环向量。存储在其中的队列称为循环队列（Circular Queue）。</p><p style=text-align:start>循环队列就是将队列存储空间的最后一个位置绕到第一个位置，形成逻辑上的环状空间，供队列循环使用。在循环队列结构中，当存储空间的最后一个位置已被使用而再要进入队运算时，只需要存储空间的第一个位置空闲，便可将元素加入到第一个位置，即将存储空间的第一个位置作为队尾。循环队列可以更简单防止伪溢出的发生，但队列大小是固定的。</p><p style=text-align:start>在循环队列中，当队列为空时，有front=rear，而当所有队列空间全占满时，也有front=rear。为了区别这两种情况，规定循环队列最多只能有MaxSize-1个队列元素，当循环队列中只剩下一个空存储单元时，队列就已经满了。因此，队列判空的条件时front=rear，而队列判满的条件时front=（rear+1）%MaxSize。</p><p style=text-align:start><strong>【循环队列结构图】</strong></p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 栈和队列" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/21aa970c665842f09a0be14455708013><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>【循环队列操作示意图】**</p><p style=text-align:start><br></p><div class=pgc-img><img alt="第五章 栈和队列" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a25292c4f4f54d6580e28911b10af459><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>【程序实现】**</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;iostream&gt;using namespace std;​#define MAXQSIZE 100#define OK 1#define ERROR 0#define OVERFLOW -1#define False 0#define True 1​typedef int Status;typedef int QElemType;​typedef struct{    QElemType *base; //存储空间的基地址    int front;      //头指针    int rear;       //尾指针}SqQueue;​//循环队列的初始化Status InitQueue(SqQueue &amp;q){    q.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为 MAXQSIZE 的数组空间        if(!q.base)        exit(OVERFLOW); //存储分配失败        q.front = q.rear = 0; //头指针和尾指针置为零，队列为空        return OK;}​//求循环队列的长度int QueueLength(SqQueue q){    return (q.rear - q.front + MAXQSIZE) % MAXQSIZE; //返回Q的元素个数，即队列长度}​//入队Status EnQueue(SqQueue &amp;q, QElemType e)//插入元素 e 为Q的新的队尾元素{    if((q.rear + 1) % MAXQSIZE == q.front) //尾指针在循环意义上加1后等于头指针，表明队满        return ERROR;        q.base[q.rear] = e; //新元素插入队尾        q.rear = (q.rear+1) % MAXQSIZE; //队尾指针加1        return OK;}​//出队Status DeQueue(SqQueue &amp;q, QElemType &amp;e)//删除 q 的队头元素，用 e 返回其值{    if(q.front==q.rear)        return ERROR; //队空        e = q.base[q.front]; //保存队头元素        q.front = (q.front+1) % MAXQSIZE;//队头指针加1        return OK;}​//取队头元素QElemType GetHead(SqQueue q)//返回  的队头元素，不修改队头指针{    if(q.front != q.rear) //队列非空        return q.base[q.front];//返回队头元素的值，队头指针不变        return ERROR;}​//队列判满bool FullQueue(SqQueue &amp;q){    if(q.rear == (q.front+1) % MAXQSIZE)        return 1;    else        return 0;}​//队列判空bool EmptyQueue(SqQueue &amp;q){    if(q.front==q.rear)        return 1;    else        return 0;}​int main(){    QElemType e;    SqQueue q;        InitQueue(q);        int count = 0;        printf("请输入要入队的元素个数:\n");    scanf("%d", &amp;count);        for (int i = 0; i &lt; count; i ++) {        printf("请输入第%d个数: ", i+1);        int iNum = 0;        scanf("%d", &amp;iNum);        EnQueue(q, iNum);    }        printf("队列长度： %d\n", QueueLength(q));        printf("获取队列头元素: %d\n", GetHead(q));        printf("输出结果为：\n");    while (q.front != q.rear)    {        /***********    出队列    ***********/        DeQueue(q, e);        printf("%d,",e);    }        printf("\n");        if(FullQueue(q))        printf("队列已满\n");        if(EmptyQueue(q))        printf("队列为空\n");        return 0;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'队列','第五章'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>