<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>到底什么是面向对象编程( OOP )？ | 极客快訊</title><meta property="og:title" content="到底什么是面向对象编程( OOP )？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/810c487e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/810c487e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/810c487e.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="到底什么是面向对象编程( OOP )？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/810c487e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>到底什么是面向对象编程( OOP )？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>全文共<strong>9402</strong>字，预计学习时长<strong>19</strong>分钟</blockquote><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c><p class=pgc-img-caption></p></div><p class=ql-align-center>图片来源：https://unsplash.com/@marcelheil</p><p class=ql-align-justify><br></p><p class=ql-align-justify>Python是数据科学中一种十分常用的编程语言。对一些人来讲，它的语言灵活、可读性强，对另一些人来讲，它简单易上手，对大多数人来讲，是由于它的多面性。</p><p>我们将Python称为多面语言，因为它允许使用四种不同的编码规范进行编码：功能性、命令性、面向对象和面向过程。这些编码风格被正式称为编程范例（https://en.wikipedia.org/wiki/Programming_paradigm），代表了一种根据语言特性对语言进行分类的方法。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/34a8ec01e0b74009ab04bd754420cce6><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>本文将对面向对象编程( OOP )（https://en.wikipedia.org/wiki/Object-oriented_programming）进行研究。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>什么是面向对象编程( OOP )？</strong></p><p>OOP是一种基于对象概念的编程范式。在计算机科学中，“对象”一词可以指代不同概念，但基本上，它是标识符所引用的内存值（https://en.wikipedia.org/wiki/Object_(computer_science)）。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>在OOP的执行环境中，对象指状态（变量）和行为（方法）的组合。面向对象方法的目标是创建可重复使用的软件，以下四个特征使其更易维护：封装、抽象、继承和多态。</p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/172bba3a7cb74a6d9e740a08e0ae1d49><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>还可以进一步区分面向对象语言，例如，基于类和基于原型。</p><p class=ql-align-justify>在基于类的OOP中，对象是类的实例。类是关于如何定义某些内容的蓝图，但它不会提供内容本身——它只是提供结构。</p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>学习策略</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>有许多方法可以用来学习和练习OOP，因必须选择其中一种，所以笔者决定采用莎士比亚的《罗密欧与朱丽叶》的故事线，制作一个简单的基于文本的游戏。具体步骤如下：</p><p class=ql-align-justify>1. 写下故事</p><p class=ql-align-justify>2. 指出问题</p><p class=ql-align-justify>3. 确定实体——这些是类别</p><p class=ql-align-justify>4. 创建实体层次结构</p><p class=ql-align-justify>5. 确定实体的功能</p><p class=ql-align-justify>6. 编写测试</p><p class=ql-align-justify>7. 检查测试是否成功——因未编写过任何代码，所以最初会出现错误！</p><p class=ql-align-justify>8. 编写代码</p><p class=ql-align-justify>9. 重复！重构！精炼！</p><p class=ql-align-justify>这个过程不是一成不变的，也不是注定要被它牵着鼻子走。这一系列步骤帮助笔者开始了编程之路。面向对象不仅仅是一种编程范式，还是一种解决问题的方法，尽管它并非没有非议，但在构建复杂系统时却是一个很好的选择。</p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>兔子洞（The Rabbit Hole）</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>请注意步骤6：编写测试。现在，这个不是笔者最初的步骤。笔者正计划给各类别编码。但在研究OOP时，笔者发现了测试驱动开发( TDD )这一概念。</p><p class=ql-align-justify>TDD是一种编程实践，开始于程序每个功能所进行的测试的设计和开发。这样，在开始编写代码之前，你就不得不考虑其规范、要求或设计。换句话说，在编写任何代码之前，都要编写代码来测试代码。</p><p class=ql-align-justify>是不是感到迷惑不解？笔者也是。但做这个练习是完全值得的。</p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>测试驱动开发和单元测试</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>TDD的过程非常简单：</p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2364032a9f4c41f6bdcd0219cd691ae4><p class=pgc-img-caption></p></div><p class=ql-align-center>图片来自Kanchan Kulkarni的TDD教程（https://www.guru99.com/test-driven-development.html）</p><p class=ql-align-justify><br></p><p class=ql-align-justify>1. 写出测试</p><p class=ql-align-justify>2. 运行测试</p><p class=ql-align-justify>3. 写下代码</p><p class=ql-align-justify>4. 运行测试</p><p class=ql-align-justify>5. 重构代码</p><p class=ql-align-justify>6. 重复步骤</p><p>在这个例子中，笔者使用单元测试（http://softwaretestingfundamentals.com/unit-testing/）进行TDD。单元测试是软件测试的第一级，其目的是验证程序中的每个单元是否按设计执行。可以使用不同的框架来执行单元测试。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>人们对于TDD持有两种不同观点。就我个人的经历而言，TDD的优点如下：</p><p class=ql-align-justify>· 在毫无方向地开始输入代码之前，TDD迫使人们必须考虑要解决的问题。</p><p class=ql-align-justify>· 在基于类别的OOP的特殊情况下，它能帮助理解每个类别内容。如职责是什么？必须知道什么？——目标是低耦合和高内聚性时，这变得更加息息相关。</p><p class=ql-align-justify>· 尽管一开始它可能会减慢速度，但从长远来看，它通过最小化调试时间来节省时间。</p><p class=ql-align-justify>· 它鼓励更好的设计，使代码更容易维护、减少冗余（不写重复代码！），并在需要时安全地重构。</p><p class=ql-align-justify>· 它是一个动态文档——只需查看测试，就能理解每个单元应该做什么，如此一来，代码就能自证其明。</p><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d0f03b8a2343e4b78462298076d919><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-center><strong>罗密欧与朱丽叶——代码与测试</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>在考虑了游戏的故事性之后，笔者决定采用两个不同的故事线：经典桥段和另类桥段。第一个是人们熟知的罗密欧与朱丽叶，第二个故事对我们来说则较为陌生。</p><p class=ql-align-justify>故事安排（创建不同类别的引用）如下：</p><p class=ql-align-justify>· 场景：蒙面舞会、阳台、决斗，安排、药剂师、卡普莱特墓和另类结局。该“场景”有两个主要职责，即为玩家描述场景，以及以是非问题提示玩家从而获取信息输入。</p><p>· 地图：地图就像一个有限状态机（https://en.wikipedia.org/wiki/Deterministic_finite_automaton）。它具有有限的状态（场景）、转换函数（从一个场景移动到另一个场景）和开始状态（第一个场景）。</p><p class=ql-align-justify><br></p><p class=ql-align-justify>· 故事线：定义两个唯一常量值。</p><p class=ql-align-justify>从场景的定义中可以看到，所有场景都有相同的职责，只有它们的内容发生了变化（场景的描述和提示）。这就是为什么要利用继承的概念。这个概念允许定义一个类，该类别从另一个类中继承了所有方法和属性；在这种情况下，不重复写代码至关重要。</p><pre>class Storyline(Enum): CLASSIC = "classic" ALTERNATIVE = "alternative"</pre><p class=ql-align-justify><br></p><p>对于故事线这一类别，笔者使用了Python’s enumeration type（https://docs.python.org/3/library/enum.html）或enum。在文档中，它们的定义为“一组绑定到唯一常量值的符号名（成员）。在枚举中，成员可以按标识进行比较，枚举本身可以循环访问。”</p><p class=ql-align-justify>接下来，我们有Sence类和MockSence类。测试代码中有两个值得注意的特征：1.使用MockMap类；2.创建TestScene类以测试Scene类。在单元测试阶段，将创建一个Test类为每个类编写测试。</p><pre>Class Scene(object): a_map = None  def __init__(self, a_map): self.a_map = a_map def get_message(self): return """ This scene is yet to be initialized """ def get_prompt(self): return """ This scene is yet to be initialized """  def enter(self): self.print_description() self.prompt_user()  def print_description(self): print(dedent(self.get_message())) def prompt_user(self): input_from_user = input(self.get_prompt()).lower() if input_from_user == "yes": self.a_map.advance_scene(Storyline.CLASSIC) elif input_from_user == "no": self.a_map.advance_scene(Storyline.ALTERNATIVE) self.a_map.play()</pre><p class=ql-align-justify><br></p><pre>import unittestfrom unittest.mock import patch, mock_openimport sysimport iofrom romeo_and_juliet import *class MockMap(Map): storyline = None play_executed = False def advance_scene(self, a_storyline): self.storyline = a_storyline def play(self): self.play_executed = True class TestScene(unittest.TestCase): def test_print_description(self): a_scene = Scene(Map()) # Capturing the standard output as a test harness. capturedOutput = io.StringIO() sys.stdout = capturedOutput a_scene.print_description() self.assertEqual(capturedOutput.getvalue(), dedent(""" This scene is yet to be initialized\n """)) # Releasing standard output. sys.stdout = sys.__stdout__  def test_prompt_user(self): a_map = MockMap() a_scene = Scene(a_map) with patch("builtins.input", return_value = "yes"): a_scene.prompt_user() self.assertEqual(a_map.storyline, Storyline.CLASSIC) with patch("builtins.input", return_value = "no"): a_scene.prompt_user() self.assertEqual(a_map.storyline, Storyline.ALTERNATIVE) self.assertTrue(a_map.play_executed)</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>最后，来看看Map类和TestMap类。和往常一样，我们会创建一个模拟测试，但在本例中，是为Scene类创建一个MockScene类。</p><pre>class Map(object): scenes = None current_scene = None def __init__(self): self.scenes = { "the_masked_ball": TheMaskedBall(self), "the_balcony": TheBalcony(self), "the_duel": TheDuel(self), "the_arrangement": TheArrangement(self), "the_apothecary": TheApothecary(self), "the_capulet_tomb": TheCapuletTomb(self), "the_alternative_ending": TheAlternativeEnding(self) } self.current_scene = self.scenes["the_masked_ball"] def get_current_scene(self): return self.current_scene def play(self): self.current_scene.enter() def advance_scene(self, storyline): if storyline == Storyline.CLASSIC: if self.current_scene == self.scenes["the_masked_ball"]: self.current_scene = self.scenes["the_balcony"] elif self.current_scene == self.scenes["the_balcony"]: self.current_scene = self.scenes["the_duel"] elif self.current_scene == self.scenes["the_duel"]: self.current_scene = self.scenes["the_arrangement"] elif self.current_scene == self.scenes["the_arrangement"]: self.current_scene = self.scenes["the_apothecary"] elif self.current_scene == self.scenes["the_apothecary"]: self.current_scene = self.scenes["the_capulet_tomb"] elif self.current_scene == self.scenes["the_capulet_tomb"]: raise Exception if storyline == Storyline.ALTERNATIVE: if self.current_scene == self.scenes["the_masked_ball"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_balcony"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_duel"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_arrangement"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_apothecary"]: self.current_scene = self.scenes["the_alternative_ending"] elif self.current_scene == self.scenes["the_alternative_ending"]: raise Exception</pre><p class=ql-align-justify><br></p><pre>class MockScene(Scene): was_entered = False def enter(self): self.was_entered = Trueclass TestMap(unittest.TestCase): def test_play(self): a_map = Map() mock_scene = MockScene(a_map) a_map.current_scene = mock_scene a_map.play() self.assertTrue(mock_scene.was_entered)  def test_initial_state(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall)  def test_advance_scene_classic(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheArrangement) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheApothecary) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheCapuletTomb) with self.assertRaises(Exception): a_map.advance_scene(Storyline.CLASSIC) def test_advance_scene_alternative_one(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE)  def test_advance_scene_alternative_two(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE) def test_advance_scene_alternative_three(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE) def test_advance_scene_alternative_four(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheArrangement) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE)  def test_advance_scene_alternative_five(self): a_map = Map() self.assertIsInstance(a_map.get_current_scene(), TheMaskedBall) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheBalcony) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheDuel) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheArrangement) a_map.advance_scene(Storyline.CLASSIC) self.assertIsInstance(a_map.get_current_scene(), TheApothecary) a_map.advance_scene(Storyline.ALTERNATIVE) self.assertIsInstance(a_map.get_current_scene(), TheAlternativeEnding) with self.assertRaises(Exception): a_map.advance_scene(Storyline.ALTERNATIVE)</pre><div class=pgc-img><img alt="到底什么是面向对象编程( OOP )？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e57cd3b4f104f2e86c45a61d3f68fbb><p class=pgc-img-caption></p></div><p class=ql-align-center><strong>留言 点赞 关注</strong></p><p class=ql-align-center><strong>我们一起分享AI学习与发展的干货</strong></p><p>编译组：余书敏、张璐瑶</p><p>相关链接：</p><p>https://towardsdatascience.com/object-oriented-programming-and-the-magic-of-test-driven-development-d377acae85fa</p><p>如需转载，请后台留言，遵守转载规范</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'什么','对象','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/cfe5e1fb.html alt=什么是面向对象的编程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be4dacb2168b48e085eec6c0640bc176 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/cfe5e1fb.html title=什么是面向对象的编程思想>什么是面向对象的编程思想</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/ab5cd3e8.html alt=你真的知道为什么要面向对象编程吗，3步彻底明白面向对象思维 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f2e808d6760462aafc6bfbb0e718954 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/ab5cd3e8.html title=你真的知道为什么要面向对象编程吗，3步彻底明白面向对象思维>你真的知道为什么要面向对象编程吗，3步彻底明白面向对象思维</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>