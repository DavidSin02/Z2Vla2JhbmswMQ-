<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入介绍和使用 Java 8 的 Collector 接口和 Collectors 工具类 | 极客快訊</title><meta property="og:title" content="深入介绍和使用 Java 8 的 Collector 接口和 Collectors 工具类 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6697a1bda5a747fc89be172989891078"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/81aba3f4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/81aba3f4.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="深入介绍和使用 Java 8 的 Collector 接口和 Collectors 工具类"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/81aba3f4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入介绍和使用 Java 8 的 Collector 接口和 Collectors 工具类</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1 概述</h1><ul><li>java.util.stream.Collector: Collector 接口用于将 Stream 流中的数据加工，转换，处理，最后返回结果。</li><li>java.util.stream.Collectors: Collectors 工具类内置了一些 Collector 接口的实现。</li></ul><p style=text-align:start>本文详解 Java 8 的 Collector 接口方法以及 Collectors 工具类的使用，具体内容如下</p><ol start=1><li>Stream api 中的 collect 方法介绍以及使用</li><li>Collector 接口的实现</li><li>Collectors 工具类介绍以及使用</li></ol><h1 class=pgc-h-arrow-right>2 Stream 接口中的 collect 方法</h1><p style=text-align:start>collect 方法的功能是将 Stream 中数据转换为最终的结果，具体如下</p><ol start=1><li>&lt;R, A> R collect(Collector&lt;? super T, A, R> collector)：参数类型为 Collector 接口</li><li>&lt;R> R collect(Supplier&lt;R> supplier, BiConsumer&lt;R, ? super T> accumulator, BiConsumer&lt;R, R> combiner)：参数类型为 Supplier， BiConsumer，BiConsumer 三个对象。</li></ol><h1 class=pgc-h-arrow-right>2.1 collect 方法使用举例</h1><p style=text-align:start>需求：将集合中的英文字符串首字母大写，下面提供两种实现的方法：</p><ol start=1><li>collect 方法接口参数为 Collector 对象实现</li><li>collect 方法接口参数为 Supplier， BiConsumer， BiConsumer 三个对象实现</li></ol><p style=text-align:start>具体实现如下</p><pre><code>@Testpublic void test_1() {    List&lt;String&gt; dataList = new ArrayList&lt;&gt;();    dataList.add("john");    dataList.add("kain");    dataList.add("mike");    dataList.add("milk");    dataList.add("kav");    // 1. 接口参数为 Collector 对象实现    // 1.1 Supplier 对象负责创建容器对象，以便容纳 stream 中分隔后的数据，这里使用 List&lt;Integer&gt; 作为数据的容器对象    // 1.2 accumulator 对象负责将 stream 中分隔后的数据放入上一步创建的容器中    // 1.3 combiner 对象负责将分隔的容器中的数据合并起来    // 1.4 finisher 对象负责将最终返回的结果进行最终的处理    // 1.5 characteristics 负责 Collector 执行效率的优化，具体要根据是否使用了 parallelStream 以及 数据是否有顺序，不会影响最终的执行结果：    List&lt;String&gt; resultList = dataList.parallelStream().collect(new Collector&lt;String, List&lt;String&gt;, List&lt;String&gt;&gt;() {        @Override        public Supplier&lt;List&lt;String&gt;&gt; supplier() {            return () -&gt; new ArrayList&lt;&gt;();        }        @Override        public BiConsumer&lt;List&lt;String&gt;, String&gt; accumulator() {            return (list, data) -&gt; list.add(data.substring(0,1).toUpperCase().concat(data.substring(1)));        }        @Override        public BinaryOperator&lt;List&lt;String&gt;&gt; combiner() {            return (list1,list2) -&gt; {                list1.addAll(list2);                return list1;            };        }        @Override        public Function&lt;List&lt;String&gt;, List&lt;String&gt;&gt; finisher() {            return list -&gt; list;        }        @Override        public Set&lt;Characteristics&gt; characteristics() {            Set&lt;Characteristics&gt; characteristicsSet = new HashSet&lt;&gt;();            characteristicsSet.add(Characteristics.CONCURRENT);            return characteristicsSet;        }    });    resultList.forEach(System.out::println);    // 2. 接口参数为 Supplier， BiConsumer， BiConsumer 三个对象    // 2.1 Supplier 对象负责创建容器对象，以便容纳 stream 中分隔后的数据，这里使用 List&lt;Integer&gt; 作为数据的容器对象    // 2.2 BiConsumer 对象负责将 stream 中分隔后的数据放入上一步创建的容器中    // 2.3 BiConsumer 对象负责将分隔的容器中的数据合并起来    List&lt;String&gt; resultList2 = dataList.parallelStream().collect(            ArrayList::new,            (list, data) -&gt; list.add(data.substring(0,1).toUpperCase().concat(data.substring(1))),            (list1,list2) -&gt; list1.addAll(list2));    resultList2.forEach(System.out::println);}</code></pre><pre><code>new supplierJohnKainMikeMilkKavJohnKainMikeMilkKav</code></pre><h1 class=pgc-h-arrow-right>2.2 collect 方法接口参数为 Collector 对象实现</h1><p style=text-align:start>在 Collector 对象实现中主要包括如下 5 个接口对象</p><ol start=1><li>Supplier 对象负责创建容器对象，以便容纳 stream 中分隔后的数据，这里使用 List&lt;Integer> 作为数据的容器对象</li><li>accumulator 对象负责将 stream 中分隔后的数据放入上一步创建的容器中</li><li>combiner 对象负责将分隔的容器中的数据合并起来</li><li>finisher 对象负责将最终返回的结果进行最终的处理</li><li>characteristics 负责 Collector 执行效率的优化，具体要根据是否使用了 parallelStream 以及 数据是否有顺序，不会影响最终的执行结果</li></ol><h1 class=pgc-h-arrow-right>2.3 collect 方法接口参数为 Supplier， BiConsumer， BiConsumer 三个对象实现</h1><p style=text-align:start>Supplier， BiConsumer， BiConsumer 三个对象的功能如下</p><ol start=1><li>Supplier 对象负责创建容器对象，以便容纳 stream 中分隔后的数据，这里使用 List&lt;Integer> 作为数据的容器对象</li><li>BiConsumer 对象负责将 stream 中分隔后的数据放入上一步创建的容器中</li><li>BiConsumer 对象负责将分隔的容器中的数据合并起来</li></ol><h1 class=pgc-h-arrow-right>2.4 Characteristics 枚举</h1><p style=text-align:start>在接口参数为 Collector 对象实现中有一个 characteristics 方法，返回的是一个 Set 集合，负责 Collector 执行效率的优化，具体要根据是否使用了 parallelStream 以及数据是否有顺序，最终不会影响执行结果。</p><p style=text-align:start>具体内容为 Collector 接口中定义的 Characteristics 泛型，具体如下</p><pre><code>enum Characteristics {    // 如果使用 parallelStream，characteristics 方法返回的 set 集合中可以加上这个枚举    CONCURRENT,    // 如果流中的数据是没有顺序的，也可以加上这个枚举    UNORDERED,    // 加上这个表示 finisher 方法中的参数和返回值完全一致，finisher 方法不会执行了    IDENTITY_FINISH}</code></pre><h1 class=pgc-h-arrow-right>2.5 parallelStream 线程安全问题</h1><ul><li>其中上面的两个例子中都使用了 parallelStream，并且使用了 collect 方法</li><li>parallelStream 可以提高数据处理效率，具体是通过将流中的数据分隔成若干端后再并行处理最后将结果合并</li><li>如果不使用 collect 方法会发生什么情况，会不会出现线程安全问题？</li></ul><p style=text-align:start>先看下面这个例子</p><pre><code>private static Lock lock = new ReentrantLock();@Testpublic void test_unsafe() {    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();    List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();    // 串行    IntStream.range(0, 10000).forEach(list1::add);    // 并行    IntStream.range(0, 10000).parallel().forEach(list2::add);    // 并行加锁    IntStream.range(0, 10000).parallel().forEach(i -&gt; {        lock.lock();        try {            list3.add(i);        } finally {            lock.unlock();        }    });    System.out.println(String.format("串行执行的大小：%s", list1.size()));    System.out.println(String.format("有线程安全的并行问题大小：%s", list2.size()));    System.out.println(String.format("并行加锁：%s", list1.size()));}</code></pre><p style=text-align:start>执行结果如下，可见在 parallelStream 中会出现线程安全问题，虽然通过锁可以避免线程安全问题，但是会降低程序处理效率，从而影响系统的吞吐率。</p><pre><code>串行执行的大小：10000有线程安全的并行问题大小：7351并行加锁：10000</code></pre><p style=text-align:start>正确的解决的方法就是通过 collect 方法和 Collector 接口，具体如下</p><pre><code>@Testpublic void test_safe() {    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();    // 串行    IntStream.range(0, 10000).forEach(list1::add);    // 通过 collect 接口解决并发问题    // 1. Supplier 对象负责创建容器对象，以便容纳 stream 中分隔后的数据，这里使用 List&lt;Integer&gt; 作为数据的容器对象    // 2. ObjIntConsumer 对象负责将 stream 中分隔后的数据放入上一步创建的容器中    // 3. BiConsumer 对象负责将分隔的容器中的数据合并起来    List&lt;Integer&gt; dataList = IntStream.range(0, 10000).parallel().collect(new Supplier&lt;List&lt;Integer&gt;&gt;() {        @Override        public List&lt;Integer&gt; get() {            System.out.println("new Supplier");            return new ArrayList&lt;&gt;();        }    }, new ObjIntConsumer&lt;List&lt;Integer&gt;&gt;() {        @Override        public void accept(List&lt;Integer&gt; dataList, int value) {            dataList.add(value);        }    }, new BiConsumer&lt;List&lt;Integer&gt;, List&lt;Integer&gt;&gt;() {        @Override        public void accept(List&lt;Integer&gt; dataList1, List&lt;Integer&gt; dataList2) {            System.out.println("merge result");            dataList1.addAll(dataList2);        }    });    List&lt;Integer&gt; dataList1 = IntStream.range(0, 10000).collect(ArrayList::new, (list, i) -&gt; list.add(i), (lista, listb) -&gt; lista.addAll(listb));    List&lt;Integer&gt; dataList2 = IntStream.range(0, 10000).parallel().collect(ArrayList::new, (list, i) -&gt; list.add(i), (lista, listb) -&gt; lista.addAll(listb));    System.out.println(String.format("串行执行的大小：%s", list1.size()));    System.out.println(String.format("线程安全的并行大小：%s", dataList.size()));    System.out.println(String.format("线程安全的并行大小：%s", dataList1.size()));    System.out.println(String.format("线程安全的并行大小：%s", dataList2.size()));}</code></pre><ul><li>通过 collect 方法解决并发问题</li></ul><ol start=1><li>Supplier 对象负责创建容器对象，以便容纳 stream 中分隔后的数据，这里使用 List&lt;Integer> 作为数据的容器对象</li><li>ObjIntConsumer 对象负责将 stream 中分隔后的数据放入上一步创建的容器中</li><li>BiConsumer 对象负责将分隔的容器中的数据合并起来</li></ol><h1 class=pgc-h-arrow-right>3 Collectors 工具类介绍以及使用</h1><p style=text-align:start>在上面的例子中都使用了 collect 方法以及自行实现了 Collector 接口。有没有 jdk 已经实现好的 Collector 接口呢？</p><h1 class=pgc-h-arrow-right>3.1 Collectors 工具类方法介绍</h1><p style=text-align:start>答案是有的，就是这里将要介绍的 Collectors 工具类：java.util.stream.Collectors，完整的方法如下：</p><div class=pgc-img><img alt="深入介绍和使用 Java 8 的 Collector 接口和 Collectors 工具类" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6697a1bda5a747fc89be172989891078><p class=pgc-img-caption></p></div><p style=text-align:start>下面来简要介绍一下，不谈具体的参数，返回类型都是 Collector 接口对象，具体如下</p><ol start=1><li>toCollection，toList，toSet：处理并将结果返回成集合对象</li><li>joining：处理并将结果返回成字符串</li><li>mapping：首先将流中的元素从 T 转成 U，然后再将含有 U 的流转给 downstream 继续处理</li><li>collectingAndThen：首先将流传给 downstream 处理，然后将 downstream 中的 R 转成 RR，最后的结果为 RR</li><li>counting：求流中元素的总数，类型为 Long</li><li>minBy: 求流中最小的元素</li><li>maxBy：求流中最大的元素</li><li>summingInt，summingLong，summingDouble：求流中元素之和，和的类型分别是 int, long, double 类型</li><li>averagingInt，averagingLong，averagingDouble：求流中元素的平均数，平均数的类型分别是 int, long, double 类型</li><li>reducing：减少流中的元素</li><li>groupingBy：将流中的元素分组处理</li><li>groupingByConcurrent：以并行的方式将流中的元素分组处理</li><li>partitioningBy：将流中的元素分区处理</li><li>toMap, toConcurrentMap：处理并将结果返回成 Map 对象</li><li>summarizingInt，summarizingLong，summarizingDouble：汇总流中的元素，汇总后的类型分别是 IntSummaryStatistics, LongSummaryStatistics, DoubleSummaryStatistics</li></ol><h1 class=pgc-h-arrow-right>3.2 Collectors 工具类使用</h1><p style=text-align:start>下面来介绍上面的 15 中方法具体使用</p><ul><li>增加 Student 实体如下</li></ul><pre><code>import org.apache.commons.lang3.builder.ToStringBuilder;public class Student {    private int age;//年龄    private String name;//姓名    private String enName;// 英文 姓名    private char gender;//性别，0未知，1男，2女    private double credit; // 学分    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getEnName() {        return enName;    }    public void setEnName(String enName) {        this.enName = enName;    }    public char getGender() {        return gender;    }    public void setGender(char gender) {        this.gender = gender;    }    public double getCredit() {        return credit;    }    public void setCredit(double credit) {        this.credit = credit;    }    public Student(int age, String name, String enName, char gender, double credit) {        this.age = age;        this.name = name;        this.enName = enName;        this.gender = gender;        this.credit = credit;    }    @Override    public String toString() {        return new ToStringBuilder(this)                .append("age", age)                .append("name", name)                .append("enName", enName)                .append("gender", gender)                .append("credit", credit)                .toString();    }    public Student() {    }}</code></pre><ul><li>具体的测试如下</li></ul><pre><code>import org.junit.After;import org.junit.Before;import org.junit.Test;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.math.BigDecimal;import java.util.*;import java.util.stream.Collectors;public class TestCollectorsApi {    private static final Logger logger = LoggerFactory.getLogger(TestCollectorsApi.class);    private static List&lt;Student&gt; userList = new ArrayList&lt;&gt;();    /**     * 初始化 Student 集合     */    @Before    public void initEveryTestBefore() {        userList.add(new Student(22, "王旭", "wang.xu", '1', 4));        userList.add(new Student(21, "孙萍", "sun.ping", '2', 3.6));        userList.add(new Student(23, "步传宇", "bu.zhuan.yu", '0', 4.1));        userList.add(new Student(18, "蔡明浩", "cai.ming.hao", '1', 3.5));        userList.add(new Student(17, "郭林杰", "guo.lin.jie", '1', 3.4));        userList.add(new Student(29, "韩凯", "han.kai", '0', 4));        userList.add(new Student(22, "韩天琪", "han.tian.qi", '1', 4));        userList.add(new Student(21, "郝玮", "hao.wei", '2', 3.9));        userList.add(new Student(19, "胡亚强", "hu.ya.qing", '1', 3.5));        userList.add(new Student(14, "季恺", "ji.kai", '2', 4.2));        userList.add(new Student(17, "荆帅", "jing.shuai", '1', 4.1));        userList.add(new Student(16, "姜有琪", "jiang.you.qi", '1', 2.5));        logger.info("initEveryTestBefore, size {}", userList.size());    }    /**     * 测试结束，清理数据     */    @After    public void destroyEveryTestAfter() {        logger.info("destroyEveryTestAfter, size {}", userList.size());        userList.clear();    }    @Test    public void toList() {        // 按照学分排序        userList = userList                .stream()                .sorted(Comparator.comparing(Student::getCredit))                .collect(Collectors.toList());        // 打印数据        userList.forEach(t -&gt; logger.info(t.toString()));    }    @Test    public void joining() {        // 将学生姓名合并成以,分隔的字符串        String names = userList                .stream()                .map(Student::getName)                .collect(Collectors.joining(","));        // 打印数据        System.out.println(names);    }    @Test    public void mapping() {        // 将学生姓名合并成以,分隔的字符串        String names = userList                .stream()                .collect(Collectors.mapping(Student::getName, Collectors.joining(",")));        // 打印数据        System.out.println(names);    }    @Test    public void collectingAndThen() {        // 将学生姓名合并成以,分隔的字符串, 再通过 Function 对象将字符串转成 String[] 对象        String[] nameArr = userList                .stream()                .map(Student::getName)                .collect(Collectors.collectingAndThen(Collectors.joining(","), data -&gt; data.split(",")));        // 打印数据        for (int i = 0; i &lt; nameArr.length; i++) {            System.out.println(nameArr[i]);        }    }    @Test    public void counting() {        // 将学生姓名合并成以,分隔的字符串, 再通过 Function 对象将字符串转成 String[] 对象        Long count = userList                .stream()                .filter(student -&gt; student.getCredit() &gt; 4)                .collect(Collectors.counting());        // 打印数据        System.out.println(String.format("学分大于 4 的学生人数为:%s", count));    }    @Test    public void minBy() {        // 先去重，然后获取学分最小的学生        Optional&lt;Student&gt; student = userList                            .stream()                            .distinct()                            .collect(Collectors.minBy((stu1, stu2) -&gt; BigDecimal.valueOf(stu1.getCredit()).compareTo(BigDecimal.valueOf(stu2.getCredit()))));        // 打印数据        System.out.println(String.format("学分最小的学生:%s", student.get().toString()));    }    @Test    public void maxBy() {        // 先去重，然后获取学分最大的学生        // 使用 Comparator.comparing        Optional&lt;Student&gt; student = userList                .stream()                .distinct()                .collect(Collectors.maxBy(Comparator.comparing(Student::getCredit)));        // 打印数据        System.out.println(String.format("学分最大的学生:%s", student.get().toString()));    }    @Test    public void summingDouble() {        double total = userList                .stream()                .distinct()                .collect(Collectors.summingDouble(Student::getCredit));        // 打印数据        System.out.println(String.format("学分总计:%s", total));    }    @Test    public void averagingDouble() {        double average = userList                .stream()                .distinct()                .collect(Collectors.averagingDouble(Student::getCredit));        // 打印数据        System.out.println(String.format("学分平均:%s", average));    }    @Test    public void reducing() {        // 1 返回学分最大的学生        // reducing 第一个参数 T identity 表示最终的返回类型或者结果的容器        Student studentMax = userList                .stream()                .collect(Collectors.reducing(new Student(), (stu1, stu2) -&gt; stu1.getCredit() &gt; stu2.getCredit() ? stu1 : stu2));        // 打印数据        System.out.println(String.format("返回学分最大的学生:%s", studentMax));        // 2 返回学分最大的学生，不需要指定 返回类型或者结果的容器        Optional&lt;Student&gt; studentMin = userList                .stream()                .collect(Collectors.reducing((stu1, stu2) -&gt; stu1.getCredit() &gt; stu2.getCredit() ? stu1 : stu2));        // 打印数据        System.out.println(String.format("返回学分最大的学生:%s", studentMin.get().toString()));        // 3 所有学生的学分之和        BigDecimal total = BigDecimal.ZERO;        BigDecimal totalCredit = userList                .stream()                .collect(Collectors.reducing(total, stu -&gt; total.add(BigDecimal.valueOf(stu.getCredit())), (data1, data2) -&gt; data1.add(data2)));        // 打印数据        System.out.println(String.format("所有学生的学分之和:%s", totalCredit));    }    @Test    public void groupingBy() {        // 按照性别分组        Map&lt;Character, List&lt;Student&gt;&gt; dataMap = userList                .stream()                .collect(Collectors.groupingBy(Student::getGender));        // 打印数据        dataMap.forEach((k,v) -&gt; {            System.out.println(String.format("性别：%s", k));            v.forEach(System.out::println);            System.out.println("---------------------------");        });    }    @Test    public void groupingByConcurrent() {        // 按照性别分组        Map&lt;Character, List&lt;Student&gt;&gt; dataMap = userList                .stream()                .collect(Collectors.groupingByConcurrent(Student::getGender));        // 打印数据        dataMap.forEach((k,v) -&gt; {            System.out.println(String.format("性别：%s", k));            v.forEach(System.out::println);            System.out.println("---------------------------");        });    }    @Test    public void partitioningBy() {        // 按照学分是否大于 4 分组        Map&lt;Boolean, List&lt;Student&gt;&gt; dataMap = userList                .stream()                .collect(Collectors.partitioningBy(stu -&gt; stu.getCredit() &gt; 4));        // 打印数据        dataMap.forEach((k,v) -&gt; {            System.out.println(k ? "学分大于4：" : "学分小于4：");            v.forEach(System.out::println);            System.out.println("---------------------------");        });    }    @Test    public void toMap() {        // 将数据转成 Map        Map&lt;String, Double&gt; dataMap = userList                .stream()                .collect(Collectors.toMap(stu -&gt; stu.getName(), stu -&gt; stu.getCredit()));        // 打印数据        dataMap.forEach((k,v) -&gt; {            System.out.println(String.format("姓名：%s， 学分：%s:", k, v));        });    }    @Test    public void summarizingDouble() {        // 数据统计        DoubleSummaryStatistics doubleSummaryStatistics = userList                .stream()                .distinct()                .collect(Collectors.summarizingDouble(Student::getCredit));        System.out.println(String.format("学生总数：%s", doubleSummaryStatistics.getCount()));        System.out.println(String.format("所有学生的平均学分：%s", doubleSummaryStatistics.getAverage()));        System.out.println(String.format("最高学分：%s", doubleSummaryStatistics.getMax()));        System.out.println(String.format("最低学分：%s", doubleSummaryStatistics.getMin()));        System.out.println(String.format("学分总和：%s", doubleSummaryStatistics.getSum()));    }}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'介绍','Java','Collector'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>