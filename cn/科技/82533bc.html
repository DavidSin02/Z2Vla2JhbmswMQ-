<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面向对象设计模式知识梳理 | 极客快訊</title><meta property="og:title" content="面向对象设计模式知识梳理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82533bc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/82533bc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/82533bc.html><meta property="article:published_time" content="2020-10-29T20:58:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:41+08:00"><meta name=Keywords content><meta name=description content="面向对象设计模式知识梳理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/82533bc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面向对象设计模式知识梳理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>一、设计模式概念： 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。设计模式是一种用于不断对软件系统不断重复设计问题的解决方案进行文档化的技术，也是一种共享专家设计经验的技术。（Design patterns are descriptions of communicating objects and classes that are customized to solve a general design problem in a partcular context.）二、设计模式的原则：我们为什么要用设计模式呢？这么多设计模式为什么要这么设计呢？ 为什么要提倡"Design Pattern"呢？根本原因是为了代码复用，增加可维护性。那么怎么才能实现代码复用呢？OO界有前辈的几个原则："开－闭"原则(Open Closed Principal)、里氏代换原则、合成复用原则。设计模式就是实现了这些原则，从而达到了代码复用、增加可维护性的目的。</p><p><strong>1、"开－闭"原则（Open-Closed Principle）OCP</strong></p><p>此原则是由"Bertrand Meyer"提出的。原文是："Software entities should be open for extension,but closed for modification"。就是说模块应对扩展开放，而对修改关闭。模块应尽量在不修改原(是"原"，指原来的代码)代码的情况下进行扩展。那么怎么扩 展呢？我们看工厂模式"factory pattern":假设中关村有一个卖盗版盘和禁片的小子，我们给他设计一"光盘销售管理软件"。我们应该先设计一"光盘"接口。而盗版盘是其子类。小子通过"DiscFactory"来管理这些光盘。代码为：public class DiscFactory{ public static 光盘 getDisc(String name){ return (光盘)Class.forName(name).getInstance(); } } 有人要买盗版盘，怎么实现呢？public class 小子{ public static void main(String[] args){ 光盘 d=DiscFactory.getDisc("盗版盘"); 光盘.卖(); } }</p><p>如果有一天，这小子良心发现了，开始卖正版软件。没关系，我们只要再创建一个"光盘"的子类"正版软件"就可以了。不需要修改原结构和代码。对扩展开发，对修改关闭。"开-闭原则" 工厂模式是对具体产品进行扩展，有的项目可能需要更多的扩展性，要对这个"工厂"也进行扩展，那就成了"抽象工厂模式"。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）LSP</strong></p><p>里氏代换原则是由"Barbara Liskov"提出的。如果调用的是父类的话，那么换成子类也完全可以运行。比如：</p><p>　　　　光盘 d=new 盗版盘();</p><p>　　　　d.卖();</p><p>现在要将"盗版盘"类改为"禁片"类，没问题，完全可以运行。Java编译程序会检查程序是否符合里氏代换原则。子类 overload方法的访问权限不能小于父类对应方法的访问权限。比如"光盘"中的方法"卖"访问权限是"public"，那么"盗版盘"和"禁片"中的 "卖"方法就不能是package或private，编译不能通过。为什么要这样呢？你想啊：如果"盗版盘"的"卖"方法是private。那么下面这段 代码就不能执行了：</p><p>　　　　光盘 d=new 盗版盘();</p><p>d.卖();</p><p>可以说：里氏代换原则是继承复用的一个基础。</p><p><strong>3、合成复用原则(Composite Reuse Principle)CRP</strong></p><p>就是说要少用继承，多用合成关系来实现。一段程序：有几个类要与数据库打交道，就写了一个数据库操作的类，然后别的跟数据库打交道的类都继承这个。结果，修改了数据库操作类的一个方法，各个类都需要改动。"牵一发而动全身"!面向对象是要把波动限制在尽量小的范围。</p><p>在Java中，应尽量针对Interface编程，而非实现类。这样，更换子类不会影响调用它方法的代码。要让各个类尽可能少的跟别人联系，"不要与陌生人说话"。这样，城门失火，才不至于殃及池鱼。扩展性和维护性才能提高</p><p>理解了这些原则，再看设计模式，只是在具体问题上怎么实现这些原则而已。张无忌学太极拳，忘记了所有招式，打倒了"玄冥二老"，所谓"心中无招"。设计模 式可谓招数，如果先学通了各种模式，又忘掉了所有模式而随心所欲，可谓OO之最高境界。呵呵</p><p><strong>4 依赖倒转原则（Dependency Inversion Principle）DIP</strong></p><p>抽象不应该依赖与细节，细节应当依赖与抽象。</p><p>要针对接口编程，而不是针对实现编程。</p><p>传递参数，或者在组合聚合关系中，尽量引用层次高的类。</p><p>主要是在构造对象时可以动态的创建各种具体对象，当然如果一些具体类比较稳定，就不必在弄一个抽象类做它的父类，这样有画蛇添足的感觉</p><p><strong>5 接口隔离原则（Interface Segregation Principle）ISP</strong></p><p>定制服务的例子，每一个接口应该是一种角色，不多不少，不干不该干的事，该干的事都要干</p><p><strong>6 抽象类</strong></p><p>抽象类不会有实例，一般作为父类为子类继承，一般包含这个系的共同属性和方法。</p><p>注意：好的继承关系中，只有叶节点是具体类，其他节点应该都是抽象类，也就是说具体类</p><p>是不被继承的。将尽可能多的共同代码放到抽象类中。</p><p><strong>7 迪米特法则(LoD)</strong></p><p>每一个软件单位对其他的单位都只有最少知识，而且局限于那些与本单位密切相关的软件单位。不要和陌生人说话。</p><p>三、一个设计模式的四个基本要素</p><p>设计模式使人们可以更加简单方便地复用成功的设计和体系结构。设计模式一般包含模式名称、问题、目的、解决方案、效果、实例代码和相关设计模式等基本要素。</p><p>1. 模式名称（pattern name）</p><p>通过一两个词来描述模式的问题、解决方案和效果，以便用户更好地理解模式并方便与开发人员交流。绝大多数模式都是根据其功能或模式结构来命名的。命名一个新的模式增加了我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。基于 一个模式词汇表，我们自己以及同事之间就可以讨论模式并在编写文档时使用它们。模式名可以帮助我们思考，便于我们与其他人交流设计思想及设计结果。找到恰 当的模式名也是我们设计模式编目工作的难点之一。</p><p>2. 问题(problem)</p><p>描述了应该在何时使用模式，包含了原始设计中存在的问题以及问题存在的原因。它解释了设计问题和问题存在的前因后果，它可能描述了特定的设计问题，如怎样用对象表示算法等。也可能描述了导致不灵活设计的类或对象结构。有时候，问题部分会包括使用模式必须满足的一系列先决条件。在对问题进行描述的同时实际上确定了模式所对应的使用环境以及模式的使用动机。</p><p>3. 解决方案(solution)</p><p>描述了设计的组成成分，它们之间的相互关系及各自的职责和协作方式。因为模式是一个通用模板，可应用于多种不同场合，解决方案并不描述一个特定而具体的 设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象组合）来解决这个问题。</p><p>4. 效果(consequences)</p><p>描述了模式应用的效果及使用模式应权衡的问题。效果主要包含模式的优缺点分析，没有一个解决方案是百分百完美的，在使用设计模式是需要进行合理的评价和选择。尽管我们描述设计决策时，并不总提到模式效果，但它们对于评价设计选择和理解使用模式的代价及好处具有重要意义。软件效果大多关注对时间和空间的衡量，它们也表述了语言和实现问题。因为复用是面向对象设计的要素之一，所以模式效果包括它对系统的灵活性、扩充性或可移植性的影响，显式地列出这些效果对理解和评价这些模式很有帮助。四、一些常见的设计模式（creational Pattern）创建型模式包含抽象工厂模式、建造者模式、工厂方法模式、原型模式和单利模式。</p><p><strong>Abstract Factory Pattern（抽象工厂模式）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p><strong>Builder Pattern（建造者模式）</strong>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>Factory Method Pattern（工厂方法模式）</strong>：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。Factory Method使一个类的实例化延迟到其子类。</p><p><strong>Prototype Pattern（原型模式）</strong>：用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。</p><p><strong>Singleton Pattern（单例模式）</strong>：保证一个类仅有一个实例，并提供一个访问它的全局访问点。 （Structural Pattern）结构型模式包含适配器模式、桥接模式、组合模式、装饰模式、外观模式、享元模式、代理模式。</p><p><strong>Adapter Pattern（适配器模式）</strong>：将一个类的接口转换成客户希望的另外一个接口。A d a p t e r模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>Bridge Pattern（桥接模式）</strong>：将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p><p><strong>Composite Pattern（组合模式）</strong>：将对象组合成树形结构以表示“部分-整体”的层次结构。它使得客户对单个对象和复合对象的使用具有一致性。</p><p><strong>Decorator Pattern（装饰模式）</strong>：动态地给一个对象添加一些额外的职责。就扩展功能而言， 它比生成子类方式更为灵活。</p><p><strong>Facade Pattern（外观模式）</strong>：为子系统中的一组接口提供一个一致的界面， F a c a d e模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p><strong>Flyweight Pattern（享元模式）</strong>：运用共享技术有效地支持大量细粒度的对象。</p><p><strong>Proxy Pattern（代理模式）</strong>：为其他对象提供一个代理以控制对这个对象的访问。（Behavioral pattern）行为型模式包含 职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式。</p><p><strong>Chain of Responsibility Pattern（职责链式模式）</strong>：为解除请求的发送者和接收者之间耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它。</p><p><strong>Command Pattern（命令模式）</strong>：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可取消的操作。</p><p><strong>Interpreter Pattern(解释器模式)</strong>：给定一个语言, 定义它的文法的一种表示，并定义一个解释器, 该解释器使用该表示来解释语言中的句子。</p><p><strong>Iterator Pattern（迭代器模式）</strong>：提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。</p><p><strong>Mediator Pattern（中介者模式）</strong>：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p><strong>Memento Pattern（备忘录模式）</strong>：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。</p><p><strong>Observer Pattern（观察者模式）</strong>：定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。</p><p><strong>State Pattern（状态模式）</strong>：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。</p><p><strong>Strategy Pattern（策略模式）</strong>：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。</p><p><strong>Template Method Pattern（模板方法模式）</strong>：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p><strong>Visitor Pattern（访问者模式）</strong>：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'对象','设计','知识'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>