<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>重磅开源｜AOP for Flutter开发利器——AspectD | 极客快訊</title><meta property="og:title" content="重磅开源｜AOP for Flutter开发利器——AspectD - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a9081cd0f8f5469dbff78c136b207e34"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/833fcd87.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/833fcd87.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="重磅开源｜AOP for Flutter开发利器——AspectD"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/833fcd87.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>重磅开源｜AOP for Flutter开发利器——AspectD</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>作者：闲鱼技术-正物</p><p>https://github.com/alibaba-flutter/aspectd</p><h1><strong>问题背景</strong></h1><p>随着Flutter这一框架的快速发展，有越来越多的业务开始使用Flutter来重构或新建其产品。但在我们的实践过程中发现，一方面Flutter开发效率高，性能优异，跨平台表现好，另一方面Flutter也面临着插件，基础能力，底层框架缺失或者不完善等问题。</p><p>举个栗子，我们在实现一个自动化录制回放的过程中发现，需要去修改Flutter框架(Dart层面)的代码才能够满足要求，这就会有了对框架的侵入性。要解决这种侵入性的问题，更好地减少迭代过程中的维护成本，我们考虑的首要方案即面向切面编程。</p><p>那么如何解决AOP for Flutter这个问题呢？本文将重点介绍一个闲鱼技术团队开发的针对Dart的AOP编程框架AspectD。</p><h1><strong>AspectD:面向Dart的AOP框架</strong></h1><p>AOP能力究竟是运行时还是编译时支持依赖于语言本身的特点。举例来说在iOS中，Objective C本身提供了强大的运行时和动态性使得运行期AOP简单易用。在Android下，Java语言的特点不仅可以实现类似AspectJ这样的基于字节码修改的编译期静态代理，也可以实现Spring AOP这样的基于运行时增强的运行期动态代理。</p><p>那么Dart呢？一来Dart的反射支持很弱，只支持了检查(Introspection)，不支持修改(Modification)；其次Flutter为了包大小，健壮性等的原因禁止了反射。</p><p>因此，我们设计实现了基于编译期修改的AOP方案AspectD。</p><h1>设计详图</h1><div class=pgc-img><img alt="重磅开源｜AOP for Flutter开发利器——AspectD" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9081cd0f8f5469dbff78c136b207e34><p class=pgc-img-caption></p></div><p><strong>典型的AOP场景</strong></p><p>下列AspectD代码说明了一个典型的AOP使用场景:</p><pre>aop.dartimport 'package:example/main.dart' as app;import 'aop_impl.dart';void main()=&gt; app.main();aop_impl.dartimport 'package:aspectd/aspectd.dart';@Aspect()@pragma("vm:entry-point")class ExecuteDemo { @pragma("vm:entry-point") ExecuteDemo(); @Execute("package:example/main.dart", "_MyHomePageState", "-_incrementCounter") @pragma("vm:entry-point") void _incrementCounter(PointCut pointcut) { pointcut.proceed(); print('KWLM called!'); }}</pre><h1>面向开发者的API设计</h1><p><strong>PointCut的设计</strong></p><pre>@Call("package:app/calculator.dart","Calculator","-getCurTime")</pre><p>PointCut需要完备表征以怎么样的方式(Call/Execute等)，向哪个Library，哪个类(Library Method的时候此项为空)，哪个方法来添加AOP逻辑。</p><p>PointCut的数据结构:</p><pre>@pragma('vm:entry-point')class PointCut { final Map&lt;dynamic, dynamic&gt; sourceInfos; final Object target; final String function; final String stubId; final List&lt;dynamic&gt; positionalParams; final Map&lt;dynamic, dynamic&gt; namedParams; @pragma('vm:entry-point') PointCut(this.sourceInfos, this.target, this.function, this.stubId,this.positionalParams, this.namedParams); @pragma('vm:entry-point') Object proceed(){ return null; }}</pre><p>其中包含了源代码信息(如库名，文件名，行号等)，方法调用对象，函数名，参数信息等。</p><p>请注意这里的@pragma('vm:entry-point')注解，其核心逻辑在于Tree-Shaking。在AOT(ahead of time)编译下，如果不能被应用主入口(main)最终可能调到，那么将被视为无用代码而丢弃。AOP代码因为其注入逻辑的无侵入性，显然是不会被main调到的，因此需要此注解告诉编译器不要丢弃这段逻辑。</p><p>此处的proceed方法，类似AspectJ中的ProceedingJoinPoint.proceed()方法，调用pointcut.proceed()方法即可实现对原始逻辑的调用。原始定义中的proceed方法体只是个空壳，其内容将会被在运行时动态生成。</p><p><strong>Advice的设计</strong></p><pre>@pragma("vm:entry-point")Future&lt;String&gt; getCurTime(PointCut pointcut) async{ ... return result;}</pre><p>此处的@pragma("vm:entry-point")效果同a中所述，pointCut对象作为参数传入AOP方法，使开发者可以获得源代码调用信息的相关信息，实现自身逻辑或者是通过pointcut.proceed()调用原始逻辑。</p><p><strong>Aspect的设计</strong></p><pre>@Aspect()@pragma("vm:entry-point")class ExecuteDemo { @pragma("vm:entry-point") ExecuteDemo(); ... }</pre><p>Aspect的注解可以使得ExecuteDemo这样的AOP实现类被方便地识别和提取，也可以起到开关的作用，即如果希望禁掉此段AOP逻辑，移除@Aspect注解即可。</p><h1>AOP代码的编译</h1><p><strong>包含原始工程中的main入口</strong></p><p>从上文可以看到，aop.dart引入import 'package:example/main.dart' as app;,这使得编译aop.dart时可包含整个example工程的所有代码。</p><p><strong>Debug模式下的编译</strong></p><p>在aop.dart中引入import 'aop_impl.dart';这使得aop_impl.dart中内容即便不被aop.dart显式依赖，也可以在Debug模式下被编译进去。</p><p><strong>Release模式下的编译</strong></p><p>在AOT编译(Release模式下),Tree-Shaking逻辑使得当aop_impl.dart中的内容没有被aop中main调用时，其内容将不会编译到dill中。通过添加@pragma("vm:entry-point")可以避免其影响。</p><p>当我们用AspectD写出AOP代码，透过编译aop.dart生成中间产物，使得dill中既包含了原始项目代码，也包含了AOP代码后，则需要考虑如何对其修改。在AspectJ中，修改是通过对Class文件进行操作实现的，在AspectD中，我们则对dill文件进行操作。</p><h1>Dill操作</h1><p>dill文件，又称为Dart Intermediate Language，是Dart语言编译中的一个概念，无论是Script Snapshot还是AOT编译，都需要dill作为中间产物。</p><p><strong>Dill的结构</strong></p><p>我们可以通过dart sdk中的vm package提供的dump_kernel.dart打印出dill的内部结构。</p><pre>dart bin/dump_kernel.dart /Users/kylewong/Codes/AOP/aspectd/example/aop/build/app.dill /Users/kylewong/Codes/AOP/aspectd/example/aop/build/app.dill.txt</pre><div class=pgc-img><img alt="重磅开源｜AOP for Flutter开发利器——AspectD" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a500a4b1cc74694b2345bff5855586e><p class=pgc-img-caption></p></div><p><strong>Dill变换</strong></p><p>dart提供了一种Kernel to Kernel Transform的方式，可以通过对dill文件的递归式AST遍历，实现对dill的变换。</p><p>基于开发者编写的AspectD注解，AspectD的变换部分可以提取出是哪些库/类/方法需要添加怎样的AOP代码，再在AST递归的过程中通过对目标类的操作，实现Call/Execute这样的功能。</p><p>一个典型的Transform部分逻辑如下所示:</p><pre> @override MethodInvocation visitMethodInvocation(MethodInvocation methodInvocation) { methodInvocation.transformChildren(this); Node node = methodInvocation.interfaceTargetReference?.node; String uniqueKeyForMethod = null; if (node is Procedure) { Procedure procedure = node; Class cls = procedure.parent as Class; String procedureImportUri = cls.reference.canonicalName.parent.name; uniqueKeyForMethod = AspectdItemInfo.uniqueKeyForMethod( procedureImportUri, cls.name, methodInvocation.name.name, false, null); } else if(node == null) { String importUri = methodInvocation?.interfaceTargetReference?.canonicalName?.reference?.canonicalName?.nonRootTop?.name; String clsName = methodInvocation?.interfaceTargetReference?.canonicalName?.parent?.parent?.name; String methodName = methodInvocation?.interfaceTargetReference?.canonicalName?.name; uniqueKeyForMethod = AspectdItemInfo.uniqueKeyForMethod( importUri, clsName, methodName, false, null); } if(uniqueKeyForMethod != null) { AspectdItemInfo aspectdItemInfo = _aspectdInfoMap[uniqueKeyForMethod]; if (aspectdItemInfo?.mode == AspectdMode.Call &amp;&amp; !_transformedInvocationSet.contains(methodInvocation) &amp;&amp; AspectdUtils.checkIfSkipAOP(aspectdItemInfo, _curLibrary) == false) { return transformInstanceMethodInvocation( methodInvocation, aspectdItemInfo); } } return methodInvocation; }</pre><p>通过对于dill中AST对象的遍历(此处的visitMethodInvocation函数)，结合开发者书写的AspectD注解(此处的_aspectdInfoMap_和aspectdItemInfo)，可以对原始的AST对象(此处methodInvocation)进行变换，从而改变原始的代码逻辑，即Transform过程。</p><h1>AspectD支持的语法</h1><p>不同于AspectJ中提供的BeforeAroundAfter三种预发，在AspectD中，只有一种统一的抽象即Around。</p><p>从是否修改原始方法内部而言，有Call和Execute两种，前者的PointCut是调用点，后者的PointCut则是执行点。</p><p><strong>Call</strong></p><pre>import 'package:aspectd/aspectd.dart';@Aspect()@pragma("vm:entry-point")class CallDemo{ @Call("package:app/calculator.dart","Calculator","-getCurTime") @pragma("vm:entry-point") Future&lt;String&gt; getCurTime(PointCut pointcut) async{ print('Aspectd:KWLM02'); print('${pointcut.sourceInfos.toString()}'); Future&lt;String&gt; result = pointcut.proceed(); String test = await result; print('Aspectd:KWLM03'); print('${test}'); return result; }}</pre><p><strong>Execute</strong></p><pre>import 'package:aspectd/aspectd.dart';@Aspect()@pragma("vm:entry-point")class ExecuteDemo{ @Execute("package:app/calculator.dart","Calculator","-getCurTime") @pragma("vm:entry-point") Future&lt;String&gt; getCurTime(PointCut pointcut) async{ print('Aspectd:KWLM12'); print('${pointcut.sourceInfos.toString()}'); Future&lt;String&gt; result = pointcut.proceed(); String test = await result; print('Aspectd:KWLM13'); print('${test}'); return result; }</pre><p><strong>Inject</strong></p><p>仅支持Call和Execute，对于Flutter(Dart)而言显然很是单薄。一方面Flutter禁止了反射，退一步讲，即便Flutter开启了反射支持，依然很弱，并不能满足需求。</p><p>举个典型的场景，如果需要注入的dart代码里，x.dart文件的类y定义了一个私有方法m或者成员变量p，那么在aop_impl.dart中是没有办法对其访问的，更不用说多个连续的私有变量属性获得。另一方面，仅仅对方法整体进行操作可能是不够的，我们可能需要在方法的中间插入处理逻辑。</p><p>为了解决这一问题，AspectD设计了一种语法Inject，参见下面的例子:</p><p>flutter库中包含了一下这段手势相关代码:</p><pre>@override Widget build(BuildContext context) { final Map&lt;Type, GestureRecognizerFactory&gt; gestures = &lt;Type, GestureRecognizerFactory&gt;{}; if (onTapDown != null || onTapUp != null || onTap != null || onTapCancel != null) { gestures[TapGestureRecognizer] = GestureRecognizerFactoryWithHandlers&lt;TapGestureRecognizer&gt;( () =&gt; TapGestureRecognizer(debugOwner: this), (TapGestureRecognizer instance) { instance ..onTapDown = onTapDown ..onTapUp = onTapUp ..onTap = onTap ..onTapCancel = onTapCancel; }, ); }</pre><p>如果我们想要在onTapCancel之后添加一段对于instance和context的处理逻辑，Call和Execute是不可行的，而使用Inject后，只需要简单的几句即可解决:</p><pre>import 'package:aspectd/aspectd.dart';@Aspect()@pragma("vm:entry-point")class InjectDemo{ @Inject("package:flutter/src/widgets/gesture_detector.dart","GestureDetector","-build", lineNum:452) @pragma("vm:entry-point") static void onTapBuild() { Object instance; //Aspectd Ignore Object context; //Aspectd Ignore print(instance); print(context); print('Aspectd:KWLM25'); }}</pre><p>通过上述的处理逻辑，经过编译构建后的dill中的GestureDetector.build方法如下所示:</p><div class=pgc-img><img alt="重磅开源｜AOP for Flutter开发利器——AspectD" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/159fb8ddc93141c39beab75a577696cf><p class=pgc-img-caption></p></div><p>此外，Inject的输入参数相对于Call/Execute而言，多了一个lineNum的命名参数，可用于指定插入逻辑的具体行号。</p><h1>构建流程支持</h1><p>虽然我们可以通过编译aop.dart达到同时编译原始工程代码和AspectD代码到dill文件，再通过Transform实现dill层次的变换实现AOP，但标准的flutter构建(即flutter_tools)并不支持这个过程，所以还是需要对构建过程做细微修改。</p><p>在AspectJ中，这一过程是由非标准Java编译器的Ajc来实现的。在AspectD中，通过对flutter_tools打上应用Patch，可以实现对于AspectD的支持。</p><pre>kylewong@KyleWongdeMacBook-Pro fluttermaster % git apply --3way /Users/kylewong/Codes/AOP/aspectd/0001-aspectd.patchkylewong@KyleWongdeMacBook-Pro fluttermaster % rm bin/cache/flutter_tools.stampkylewong@KyleWongdeMacBook-Pro fluttermaster % flutter doctor -vBuilding flutter tool...</pre><h1>实战与思考</h1><p>基于AspectD，我们在实践中成功地移除了所有对于Flutter框架的侵入性代码，实现了同有侵入性代码同样的功能，支撑上百个脚本的录制回放与自动化回归稳定可靠运行。</p><p>从AspectD的角度看，Call/Execute可以帮助我们便捷实现诸如性能埋点(关键方法的调用时长)，日志增强(获取某个方法具体是在什么地方被调用到的详细信息)，Doom录制回放(如随机数序列的生成记录与回放)等功能。Inject语法则更为强大，可以通过类似源代码诸如的方式，实现逻辑的自由注入，可以支持诸如App录制与自动化回归(如用户触摸事件的录制与回放)等复杂场景。</p><p>进一步来说，AspectD的原理基于Dill变换，有了Dill操作这一利器，开发者可以自由地对Dart编译产物进行操作，而且这种变换面向的是近乎源代码级别的AST对象，不仅强大而且可靠。无论是做一些逻辑替换，还是是Json&lt;-->模型转换等，都提供了一种新的视角与可能。</p><h1><strong>写在最后</strong></h1><p>AspectD作为闲鱼技术团队新开发的面向Flutter的AOP框架，已经可以支持主流的AOP场景并在Github开源，欢迎使用。Aspectd for Flutter</p><p>https://github.com/alibaba-flutter/aspectd</p><p>如果你在使用过程中，有任何问题或者建议，欢迎提issue或者PR.</p><p>https://github.com/alibaba-flutter/aspectd/pulls</p><p>或者直接联系作者</p><p>mailto:kang.wang1988@gmail.com</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'开源','AOP','Flutter'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>