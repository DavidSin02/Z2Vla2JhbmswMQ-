<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你需要知道的各种指针运算 | 极客快訊</title><meta property="og:title" content="你需要知道的各种指针运算 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6fbadcfef5ff41518f8978dd959a06b4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/835863c5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/835863c5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/835863c5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/835863c5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/835863c5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/835863c5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/835863c5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/835863c5.html><meta property="article:published_time" content="2020-11-14T21:00:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:22+08:00"><meta name=Keywords content><meta name=description content="你需要知道的各种指针运算"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/835863c5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你需要知道的各种指针运算</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>数组的某个成员可以用数组的基地址加上一个偏移量来表示。我们可以声明一个指针double *p;，把它作为基地址，然后就可以像数组一样在这个基地址上使用偏移量。在基地址上，我们可以找到第1个成员p[0]的内容，在基地址上前进一步可以找到第2个成员p[1]的内容，接下来以此类推。因此，只要提供一个指针以及两个相邻成员之间的距离，就可以把它作为数组使用了。</p><p>我们可以直接采用基地址加偏移量的书面形式，类似(p+1)。正如教科书所描述的那样，p[1]等同于 *(p+1)，这就解释了为什么数组的第1个成员是p[0] == *(p+0)。</p><p>这个理论提示了一些规则，用于在实际应用中表述数组和它们的成员。</p><ul><li>可以通过显式的指针形式double *p，或静态/自动形式double p[100]来声明数组。</li><li>不管是哪种情况，第n + 1个数组成员都是p[n]。不要忘了第一项是0而不是1，这样就可以采用特殊形式p[0] == *p。</li><li>如果需要第n个成员的地址（而不是实际值），使用&符号：&p[n]。当然，第1个成员的地址就是&p[0] == p。</li></ul><p>例1展示了这些规则的一些实际应用。</p><p>例1　一些简单的指针运算(arithmetic.c)</p><p><br></p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6fbadcfef5ff41518f8978dd959a06b4><p class=pgc-img-caption></p></div><p>❶ 使用特殊形式*evens写入到evens[0]。</p><p>❷ 成员1的地址，赋值给一个新指针。</p><p>❸ 引用数组第1个成员的通常方式。</p><p>下面我再送你一个很好的技巧，这个技巧建立在指针运算规则“p+1表示数组中下一个成员的地址（&p[1]）”的基础上。根据这个规则，我们不需要在遍历数组的循环中使用下标。在例2中我们就使用了一个备用指针来指向list的头部，然后用p++在数组中向前遍历，直到数组尾部的NULL标记，从而获得了整个数组值。如果你查看了接下来的指针声明的提示，会更容易理解这种用法。</p><p>例2我们可以利用p++表示“前进到下一个指针”实现循环的流水化</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/358345c3ced5487abcd66c41717fbe43><p class=pgc-img-caption></p></div><p>自己动手</p><blockquote class="提示 editing-block"><p>如果不了解p++，你打算怎样实现这个目标？</p></blockquote><p>如果目标是为了实现简洁的语法表示形式，基地址加偏移量这个技巧并不能提供太多的帮助，但它确实解释了C的许多工作原理。事实上，我们可以考虑一下使用结构，例如：</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/55114f2c93014d6e95bb63535577f03e><p class=pgc-img-caption></p></div><p>作为一种智力模型来分析，我们可以把list看成是基地址，list[0].b与基地址的距离正好用来表示b。也就是说，假设list的位置是整数(size_t)&list，b位于(size_t)&list + sizeof(int);，这样list[2].d的位置将是(size_t)&list + 6*sizeof(int) + 5*sizeof(double)。根据这种思路，结构就与数组非常相似了，区别是结构的成员是用名称而不是序号表示的，并且它们具有不同的类型和长度。</p><p>这个思路并不是非常正确，因为存在对齐这个因素，系统可能会决定数据需要位于某个特定长度的内存块中，因此字段尾部可能会填充一些额外的空间，使下一个字符从正确的位置开始，并且结构的尾部可能也会进行填充，使结构列表中的每个结构能够大致对齐[C99和C11，§6.7.2.1(15)和(17)]。stddef.h头文件定义了offsetof宏，它精确地描述了基地址加领偏移量的思路：list[2].d的实际地址是(size_t)&list + 2*sizeof(abcd_s) + offsetof(abcd_s, d)。</p><p>顺便说一下，在结构的起始处不可能出现填充，因此list[2].a肯定等于(size_t)&list+ 2*sizeof(abcd_s)。</p><p>下面是个笨拙的函数，它以递归的方式对列表中的成员进行计数，直到遇到值为0的成员。假设我们想把这个函数用于零值为合理数据的任何类型的列表，因此我们让它接受一个void指针（当然这不是一种好的思路）。</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/51cdf79c94674fa88521298b51354320><p class=pgc-img-caption></p></div><p>基地址加偏移量的规则解释了为什么这种做法是不行的。为了表示a_list[1]，编译器需要知道a_list[0]的准确长度，这样才能知道应该从基地址偏移多少。但是，由于没有与之相关联的类型，它无法计算这个长度。</p><h5 class=pgc-h-arrow-right>typedef作为一种教学工具</h5><p>任何时候当我们遇到一种复杂的类型时，类似于指向某种类型的指针的指针的指针等情况，可以考虑用typedef进行简化。</p><p>例如，下面这个常见的定义：</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/932e4ebd4fa34030b7351ce356f14f02><p class=pgc-img-caption></p></div><p>有效地减少了字符串数组的视觉混乱，使它们的意图变得清晰。</p><p>在前面的指针运算p++例子中，char *list[]这样的声明是否很清楚地告诉你它表示一个字符串列表而*p是一个字符串？</p><p>例3对例2的for循环进行了重写，用string替换了char *。</p><p>例3　添加一个typedef声明使笨拙的代码稍稍变得清晰</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/12900bfa75844cdeba5ee1974e302df0><p class=pgc-img-caption></p></div><p>list的声明行现在变得简单，很清晰地表示它是个字符串列表，并且string *p也很清晰地表示p是个指向字符串的指针。因此，*p表示一个字符串。</p><p>最后，我们仍然需要记住字符串是个指向字符的指针。例如，NULL是个合法的字符串值。</p><p>我们甚至可以更进一步，例如使用上面的typedef加上typedef stringlist string*，声明一个字符串的二维数组。这种方法有时候非常实用，但有时候只会增加记忆的负担。</p><p>从概念上讲，函数类型的语法实际上是指向一个特定类型的函数的指针。如果我们有一个头部类似下面这样的函数：</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/470b58f6443f48e782f8211332000abf><p class=pgc-img-caption></p></div><p>然后只要添加一个星号（并加上括号以保证优先级），就可以描述一个指向这种类型的函数的指针：</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/abe1eaf70307404a81547a82587ad2fb><p class=pgc-img-caption></p></div><p>然后在前面加上typedef来定义一种类型：</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bd7e9761be14e4998acf24e4e5b61b2><p class=pgc-img-caption></p></div><p>现在我们可以把它当作一种类型使用，例如声明一个接受另一个函数作为其输入参数的函数，可以这样：</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9adc54375f004da6a029759b9a822c73><p class=pgc-img-caption></p></div><p>通过对函数指针类型的重新定义，那些接受其他函数作为输入的函数的表达—其中连环星号的书写曾是令人生畏的考验变得不再可怕。</p><p>最后需要说明的是，指针实际上要比教科书所描述的简单得多，因为它实际上只是一个位置或别名，根本不需要涉及不同类型的内存管理。像指向字符串的指针的指针这样的复杂构造总是会让人感到迷惑，但这只不过是因为我们以狩猎为生的祖先从来没有见到过这玩意而已。至少，C提供了typedef这个工具来处理它们。</p><hr><p>本文节选自《C程序设计新思维》</p><div class=pgc-img><img alt=你需要知道的各种指针运算 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eef6522e1854870992d3c820dc212f5><p class=pgc-img-caption></p></div><p>内容简介</p><blockquote class="提示 editing-block"><p><br></p><p>C语言已经有40年的历史了。经过长时间的发展和普及，C语言的应用场景有了很大的变化，一些旧观念应该被淡化或者不再被推荐。</p><p>本书展现了传统C语言教科书所不具有的最新的相关技术。全书分为开发环境和语言两个部分，从编译、调试、测试、打包、版本控制等角度，以及指针、语法、文本、结构、面向对象编程、库等方面，对C程序设计的核心知识进行查缺补漏和反思。本书鼓励读者放弃那些对大型机才有意义的旧习惯，拿起新的工具来使用这门与时俱进的简洁语言。</p><p>本书适合有一定基础的C程序员或C语言学习者阅读，也适合想要深入理解C语言特性的读者参考。</p></blockquote><p><br></p><div class=tt-column-card data-content='{"url":"","content":"","thumb_url":"http://p3.pstatp.com/large/pgc-image/ff76e1fcba414763b5d25b2c03579625","title":"C Primer Plus官方视频解读","author_description":"异步社区","price":199,"share_price":15.92,"sold":5,"column_id":"6822821206685647116","new_thumb_url":"http://sf6-ttcdn-tos.pstatp.com/img/pgc-image/ff76e1fcba414763b5d25b2c03579625"}'><p class=column-placeholder></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'各种','指针','运算'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>