<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 | 极客快訊</title><meta property="og:title" content="[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/aeab4f66b92f4155b01af9f9f0c67b06"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/84a81108.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/84a81108.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/84a81108.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/84a81108.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/84a81108.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/84a81108.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/84a81108.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/84a81108.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/84a81108.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、Java集合是什么?</h1><p>Java集合实际上是一种经常被运用到的Java类库，其中提供了已经实现的的数据结构，省去了程序员再次编写数据结构的事情。在Leetcode中经常会被用到，有很重要的作用。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aeab4f66b92f4155b01af9f9f0c67b06><p class=pgc-img-caption></p></div><p><br>集合体系</p><p>我们发现，无论是Set和List都是继承于Collection接口，实现Collection之中的方法，而他们又衍生出了HashSet，LinkedList等等我们经常使用的数据结构。</p><p>但是真相并不是如此的简单。</p><p>对于Collection接口的实现,其实是由AbstractCollection类完成的。</p><p>此类提供了 Collection 接口的骨干实现，从而最大限度地减少了实现此接口所需的工作。</p><p>Collection中需要实现的的方法:</p><pre><code> boolean add(E o) 确保此 collection 包含指定的元素（可选操作）。  boolean addAll(Collection&lt;? extends E&gt; c)           将指定 collection 中的所有元素都添加到此 collection 中（可选操作）。  void clear()           移除此 collection 中的所有元素（可选操作）。  boolean contains(Object o)           如果此 collection 包含指定的元素，则返回 true。  boolean containsAll(Collection&lt;?&gt; c)           如果此 collection 包含指定 collection 中的所有元素，则返回 true。  boolean equals(Object o)           比较此 collection 与指定对象是否相等。  int hashCode()           返回此 collection 的哈希码值。  boolean isEmpty()           如果此 collection 不包含元素，则返回 true。  Iterator&lt;E&gt; iterator()           返回在此 collection 的元素上进行迭代的迭代器。  boolean remove(Object o)           从此 collection 中移除指定元素的单个实例，如果存在的话（可选操作）。  boolean removeAll(Collection&lt;?&gt; c)           移除此 collection 中那些也包含在指定 collection 中的所有元素（可选操作）。  boolean retainAll(Collection&lt;?&gt; c)           仅保留此 collection 中那些也包含在指定 collection 的元素（可选操作）。  int size()           返回此 collection 中的元素数。  Object[] toArray()           返回包含此 collection 中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a)           返回包含此 collection 中所有元素的数组；返回数组的运行时类型与指定数组的运行时类型相同。 </code></pre><p>AbstractCollection类实现的方法:</p><pre><code> boolean add(E o)           确保此 collection 包含指定的元素（可选操作）。  boolean addAll(Collection&lt;? extends E&gt; c)           将指定 collection 中的所有元素添加到此 collection 中（可选操作）。  void clear()           从此 collection 中移除所有元素（可选操作）。  boolean contains(Object o)           如果此 collection 包含指定的元素，则返回 true。  boolean containsAll(Collection&lt;?&gt; c)           如果此 collection 包含指定 collection 中的所有元素，则返回 true。  boolean isEmpty()           如果此 collection 不包含元素，则返回 true。 abstract  Iterator&lt;E&gt; iterator()           返回在此 collection 中的元素上进行迭代的迭代器。  boolean remove(Object o)           从此 collection 中移除指定元素的单个实例（如果存在）（可选操作）。  boolean removeAll(Collection&lt;?&gt; c)           从此 collection 中移除包含在指定 collection 中的所有元素（可选操作）。  boolean retainAll(Collection&lt;?&gt; c)           仅在此 collection 中保留指定 collection 中所包含的元素（可选操作）。 abstract  int size()           返回此 collection 中的元素数。  Object[] toArray()           返回包含此 collection 中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a)           返回包含此 collection 中所有元素的数组；返回数组的运行时类型是指定数组的类型。  String toString()           返 </code></pre><p>出了一个hashcode方法,AbstractCollection类实现了几乎所有的功能.</p><p>而AbstractCollection类又有三个不同的子类AbstractList，AbstractQueue，AbstractSet。我们从名字就可以知道，这就是三种不同的数据结构。于是这样基本就可以分析出来。</p><p>集合类的构建框架如下：</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ca5f3f6bb6d4a9ca828f68e809b780d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e20995d55a3d4c5c95e5e24ecedcbe8b><p class=pgc-img-caption></p></div><p>所有的集合都是依靠这种方式构建的，用一个抽象类实现接口，然后再用集合类去实现这些抽象类，来完成构建集合的目的。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3b1612ab66f4042a9d67735605e7e31><p class=pgc-img-caption></p></div><p>这是完整的构建图。</p><p>这其实是为了大家有一个思想，就是在Collection实现的方法，在继承实现他的各个集合中也都会实现。</p><p>如下是本文的目录：</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8d92f5a0c104160ad32198012dd0d2a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>二、Iterator接口——迭代器</h1><pre><code>{    Boolean hasNext()  如果仍有元素可以迭代，则返回 true。      E next()    返回迭代的下一个元素。      void remove()  删除         default void forEach 实现了迭代器接口的类才可以使用forEach}</code></pre><p>这几个方法有着很重要的意义：</p><ol start=1><li>所有实现Collection接口(也就是大部分集合)都可以使用forEach功能。</li><li>通过反复调用next()方法可以访问集合内的每一个元素。</li><li>java迭代器查找的唯一操作就是依靠调用next，而在执行查找任务的同时，迭代器的位置也在改变。</li><li>Iterator迭代器remove方法会删除上次调用next方法返回的元素，这也意味着remove方法和next有着很强的依赖性，如果在调用remove之前没有调用next是不合法的。</li></ol><p>这个接口衍生出了，java集合的迭代器。</p><p><strong>Java集合的迭代器使用</strong></p><p>下面是迭代器的一个小例子:</p><pre><code>class test {    public static void run() {        List&lt;Integer&gt; list = new LinkedList&lt;&gt;();        list.add(1);        list.add(2);        list.add(3);        list.add(3);        Iterator&lt;Integer&gt; iterator = list.iterator();//依靠这个方法生成一个java集合迭代器&lt;--在Colletion接口中的方法,被所有集合实现.//        iterator.remove();报错java.lang.IllegalStateException        iterator.next();        iterator.remove();//不报错,删掉了1        System.out.println(list);//AbstractCollection类中实现的toString让list可以直接被打印出来        while (iterator.hasNext()) {//迭代器,hasNext()集合是否为空            Integer a = iterator.next();//可以用next访问每一个元素            System.out.println(a);//2,3 ,3        }        for (int a : list) {//也可以使用foreach            System.out.println(a);//2,3,3        }    }    public static void main(String[] args) {        run();    }}</code></pre><p>当然你也会有点好奇，为什么remove方法前面必须跟着一个next方法，其实这个只能这么解释。</p><p>迭代器的next方法的运行方式并不是类似于数组的运行方式。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6fefcc69daba4461a201df8fcb428604><p class=pgc-img-caption></p></div><p>当然,这张图主要是让你理解一下。</p><p>数组的指针指向要操作的元素上面，而迭代器却是将要操作的元素放在运动轨迹中间。</p><p>本质来讲，迭代器的指针并不是指在元素上，而是指在元素和元素中间。</p><p>假设现在调用remove().被删除的就是2号元素，(被迭代器那个圆弧笼盖在其中的那个元素)，如果再次调用，就会报错，因为圆弧之中的2号元素已经消失，那里是空的，无法删除。</p><h1 class=pgc-h-arrow-right>三、Collection接口</h1><p>这个对象是一个被LIst,Set,Queue的超类，这个接口中的方法，构成了集合中主要的方法和内容。剩下的集合往往都是对这个接口的扩充。</p><p>方法如下:</p><pre><code>boolean add(E o)           确保此 collection 包含指定的元素（可选操作）。  boolean addAll(Collection&lt;? extends E&gt; c)           将指定 collection 中的所有元素添加到此 collection 中（可选操作）。  void clear()           从此 collection 中移除所有元素（可选操作）。  boolean contains(Object o)           如果此 collection 包含指定的元素，则返回 true。  boolean containsAll(Collection&lt;?&gt; c)           如果此 collection 包含指定 collection 中的所有元素，则返回 true。  boolean isEmpty()           如果此 collection 不包含元素，则返回 true。 abstract  Iterator&lt;E&gt; iterator()           返回在此 collection 中的元素上进行迭代的迭代器。  boolean remove(Object o)           从此 collection 中移除指定元素的单个实例（如果存在）（可选操作）。  boolean removeAll(Collection&lt;?&gt; c)           从此 collection 中移除包含在指定 collection 中的所有元素（可选操作）。  boolean retainAll(Collection&lt;?&gt; c)           仅在此 collection 中保留指定 collection 中所包含的元素（可选操作）。 abstract  int size()           返回此 collection 中的元素数。  Object[] toArray()           返回包含此 collection 中所有元素的数组。 &lt;T&gt; T[] toArray(T[] a)           返回包含此 collection 中所有元素的数组；返回数组的运行时类型是指定数组的类型。  String toString() &lt;--很重要          返 </code></pre><p>其实我们并不一定要把这些方法都记住</p><p>我们只要记住Collection对象实现了这些种类的方法就可以了(可以现查API,不是..</p><p>但是确实，这些方法记住了有很大的用处。</p><pre><code>添加元素(两种) 添加一个元素,添加一个集合删除元素(三种)  删除一个元素,删出一个集合,只保留一个集合判断大小变成数组是否为空清空</code></pre><p><strong>1. Java集合的泛型使用</strong></p><p>到这里我们还要讲解一个问题,就是除了Map的集合类型(看看上面的继承表,map是单独一个分支)都可以传入Collection为参数的函数里面去.</p><pre><code>public class Test {    public static void  display(Collection&lt;?&gt; a){        System.out.println(a);    }    public static void main(String[] args) {        List&lt;Integer&gt; list=new LinkedList&lt;&gt;();//链表        list.add(1);        list.add(2);        list.add(4);        list.add(3);        display(list);//[1, 2, 4, 3]        Set&lt;Integer&gt; set=new TreeSet&lt;&gt;();//树集        set.addAll(list);        //在这里之所以两者输出不同,是因为树集有着一个自动排序的功能.其原因在于对于treeset内部结构的实现和LinkedList有所不同        display(set);//[1, 2, 3, 4]            }}</code></pre><p><strong>2. Java集合中使用泛型的好处</strong></p><p>为什么在java集合中经常使用泛型。除了为了防止输入错误的数据，更重要的是如果用了泛型也会让操作更加的方便，省去了强制转化的过程。</p><p>以下两个是准备</p><pre><code>public class AppleAndOrangeWithOutGenerics {    @SuppressWarnings("unchecked")//这个只能抑制警告信息,用它就不会有警告    public static void main(String args[]) {        /**         * 不用泛型         *///        ArrayList apples=new ArrayList();//        for (int i = 0; i &lt;3 ; i++) {//            apples.add(new Apple());        //在ArrayList无论放进去之前是什么,再放进去之后都会变成Object类型,//            apples.add(new Orange());        //会报一个小小的warning,因为没有使用泛型.&lt;-只有删掉这个句子执行才不报错//        }//            for (int j = 0; j &lt;apples.size() ; j++) {//                System.out.println(((Apple)apples.get(j)).id());        //如果没有泛型的拦截,输入Orange类型根本不会被发现.非常的危险//            }        /**         * 使用泛型         */        ArrayList&lt;Apple&gt; apples = new ArrayList();        for (int i = 0; i &lt; 3; i++) {            apples.add(new Apple());//            apples.add(new Orange());//在这里直接就报错了,让这种错误在编译期就被发现        }        for (int j = 0; j &lt; apples.size(); j++) {            //用了反省之后连强制转换都不需要了            System.out.println(( apples.get(j)).id());//如果没有泛型的拦截,输入Orange类型根本不会被发现.非常的危险        }    }}</code></pre><p>所以使用泛型有很大的好处。</p><h1 class=pgc-h-arrow-right>四、List</h1><p>List是一个有序集合，元素会增加到容器中特定的位置，可以采用两种方式访问元素：使用迭代器访问或者使用一个整数索引访问。后一种方式称为随机访问。</p><p>为此List接口多定义了一些方法，来实现这一点</p><pre><code>void add(int index,E element);//这个和上面不同,带了index.void remove(int index);E get(int index);E set(int index,E element);</code></pre><p>我们知道实现LIST接口的类中有一个类叫做AbstractList，他的两个子类分别是LinkedList和ArrayList这两种。那么问题是链表可不可以使用这个add方法。</p><p>答案是可以的，实际上链表使用随机访问，只不过是慢了点而已。如果有可能，还是使用迭代器为好。</p><p>LIST主要有两种类：一个是LinkedList一个是ArrayList。</p><p><strong>1. LinkedList</strong></p><p>我们就从一个程序看一看LinkedList到底怎么用.</p><pre><code>/** * LinkedLIST也像ArrayList一扬实现了基本的List接口,但是他执行一些操作效率更高,比如插入. * LIST为空就会抛出NoSuchElement-Exception * Created by 22643 on 2020/4/17. */public class LinkedListFeatures {    public static void main(String[] args) {        LinkedList&lt;Pet&gt; pets=new LinkedList&lt;Pet&gt;(Pets.arrayList(5));//后面括号中的意思是生成五个Pets对象        System.out.println("pets = [" + pets + "]");        System.out.println("pets.getFirst() "+pets.getFirst());//取第一个        System.out.println("pets.element "+pets.element());//也是取第一个,跟first完全相同.        //如果列表为空如上两个内容返回NoSuchElement-Exception        System.out.println("pets.peek()"+pets.peek());//peek跟上面两个一扬,只是在列表为空的时候返回null        System.out.println(pets.removeFirst());        System.out.println(pets.remove());//这两个完全一样,都是移除并返回列表头,列表空的时候返回NoSuchElement-Exception        System.out.println(pets.poll());//稍有差异,列表为空的时候返回null        pets.addFirst(new Rat());//addFirst将一个元素插入头部,addLast是插到尾部        System.out.println(pets);        pets.add(new Rat());//将一个元素插入尾部        System.out.println(pets);        pets.offer(new Rat());//与上面一扬,将一个元素插入尾部        System.out.println(pets);        pets.set(2,new Rat());//将替换为指定的元素        System.out.println(pets);    }}</code></pre><p>实际上LinkedList有非常多的方法，因为LinkedList是被用来实现多中数据结构的。不但可以实现队列，甚至还有可以实现栈的相关方法。</p><p>我们对此进行分类:</p><p>栈相关的操作方法:</p><pre><code> E poll()           找到并移除此列表的头（第一个元素）。  peek()           找到但不移除此列表的头（第一个元素）。 void addFirst(E o) 加入开头可以当作add用</code></pre><p>队列操作方法：(LinkedList实现了Queue的接口，所以说可以操作用来构建队列)</p><p>注意队列是FIFO(先进先出)队列，所以按照实现，从普通队列是从队列的尾部插入，从头部移除。</p><p>所以方法如下:</p><pre><code>E element() 首元素boolean offer(E o)将指定队列插入桶E peek() 检索,但是不移除队列的头E pool()检索并移除此队列的头,为空返回null.E remove()检索并移除此队列的头</code></pre><blockquote><p>一般来讲集合中的方法在移除方法都会有一个为空的时候返回null的方法，和一个为空的时候返回null的方法。类似于pool()和remove()</p></blockquote><p>我们一会到Queue的时候还会将这些再将一次。</p><p><strong>2. ArrayList</strong></p><p>我们也从一个程序来看这个</p><pre><code>public class ListFeatures {    public static void main(String[] args) {        Random rand=new Random(47);//相同的种子会产生相同的随机序列。        List&lt;String&gt; list=new ArrayList&lt;&gt;();        list.add("demo3");        list.add("demo2");        list.add("demo1");//加入方法        System.out.println("插入元素前list集合"+list);//可以直接输出        /**         * /void add(int index, E element)在指定位置插入元素，后面的元素都往后移一个元素         */        list.add(2,"demo5");        System.out.println("插入元素前list集合"+list);        List&lt;String&gt; listtotal=new ArrayList&lt;&gt;();        List&lt;String&gt; list1=new ArrayList&lt;&gt;();        List&lt;String&gt; list2=new ArrayList&lt;&gt;();        list1.add("newdemo1");        list1.add("newdemo2");        list1.add("newdemo2");        /**         * boolean addAll(int index, Collection&lt;? extends E&gt; c)         * 在指定的位置中插入c集合全部的元素，如果集合发生改变，则返回true，否则返回false。         * 意思就是当插入的集合c没有元素，那么就返回false，如果集合c有元素，插入成功，那么就返回true。         */        boolean b=listtotal.addAll(list1);        boolean c=listtotal.addAll(2,list2);        System.out.println(b);        System.out.println(c);//插入2号位置,list2是空的        System.out.println(list1);        /**         * E get(int index)         * 返回list集合中指定索引位置的元素         */        System.out.println(list1.get(1));//list的下标是从0开始的        /**         * int indexOf(Object o)         * 返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1         */        System.out.println(list1.indexOf("demo"));        System.out.println(list1.indexOf("newdemo2"));//如果在list中有相同的数,也没有问题.        //但是如果是对象,因为每个对象都是独一无二的.所以说如果传入一个新的对象,indexof和remove都是无法完成任务的        //要是删除,可以先找到其位置,然后在进行删除.        //Pet p=pets.get(2);        //pets.remove(p);        /**         * 查看contains查看参数是否在list中         */        System.out.println(list1.contains("newdemo2"));//true        /**         * remove移除一个对象         * 返回true和false         */        //只删除其中的一个        System.out.println(list1.remove("newdemo2"));//[newdemo1, newdemo2]        System.out.println(list1);        List&lt;String&gt; pets=list1.subList(0,1);//让你从较大的一个list中创建一个片段        //containall一个list在不在另一个list中        System.out.println(pets+"在list中嘛"+list1.containsAll(pets));//[newdemo1]在list中嘛true        //因为sublist的背后就是初始化列表,所以对于sublist的修改会直接反映到原数组上面        pets.add("new add demo");        System.out.println(list1);//[newdemo1, new add demo, newdemo2]        Collections.sort(pets);        System.out.println(                pets        );//new add demo, newdemo1        System.out.println(list1.containsAll(pets));//true-----变换位置不会影响是否在list1中被找到.        list1.removeAll(pets);//移除在参数list中的全部数据        /**         * list1[newdemo1, new add demo, newdemo2]         * pets[new add demo, newdemo1]         */        System.out.println(list1);//[newdemo2]        System.out.println(list1.isEmpty());//是否为空        System.out.println(list1.toArray());//将list变为数组        //list的addAll方法有一个重载的.可以让他在中间加入    }}</code></pre><p>这个比较适合非顺序存储。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba2516197be04678bee5a19b04925a83><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>五、Set</h1><p>Set实际上也是一种映射关系的集合和Map比较像。但是它实现的依然是Collection的接口。</p><p>而且Set中的方法和Collection的方法几乎完全一样。</p><p>唯一的区别在于add方法不允许增加重复的元素，在调用equal时，如果两个Set中的元素都相等，无论两者的顺序如何，这两个Set都会相等。</p><p>set的特性</p><pre><code>Set不保存重复的元素.Set就是Collection,只是行为不同.HashSet使用了散列,它打印的时候,输出的元素不会正常排列TreeSet使用了储存在红黑树结构中,,所以输出的元素会正常排列</code></pre><p>当然Set最主要的工作就是判断存在性，目的是看一个元素到底存不存在这个集合之中。</p><p>下面放上两个Set的例子：</p><p>SortedSet（TreeSet）</p><pre><code>public class SortedSetOfInteger {    public static void main(String[] args) {        Random random=new Random(47);        SortedSet&lt;Integer&gt; intset=new TreeSet&lt;&gt;();        for (int i = 0; i &lt;100 ; i++) {            intset.add(random.nextInt(30));        }        System.out.println(intset);//set特性只能输入相同的数,别看输入了100个数,但是实际上只有30个进去了.        //这个有序了.这就是treeset的功劳,因为内部的实现时红黑树,所以来说.这就简单了一些    }}</code></pre><p>HashSet</p><pre><code>public class SetOfInteger {    public static void main(String[] args) {        Random rand=new Random(47);        Set&lt;Integer&gt; intset=new HashSet&lt;&gt;();//创建一个HashSet        for (int i = 0; i &lt;100 ; i++) {            intset.add(rand.nextInt(30));        }        System.out.println(intset);//set特性只能输入相同的数,别看输入了100个数,但是实际上只有30个进去了.    }}</code></pre><p>这里要讲一下HashSet。HashSet不在意元素的顺序，根据属性可以快速的访问所需要的对象。散列表为每个对象计算一个整数，成为散列码...散列码是实例产生的一个整数。</p><p>散列表（HashSet）散列表用链表数组实现。每个列表称为通。想要查找表中对象的位置就计算它的散列码。然后与通的总数取余，得到的数就是保存这个元素的通的索引。</p><p>但是桶总有被沾满的一刻。</p><p>为了应对这种情况，需要用新对象与桶中所有对象比较，看是否存在。</p><p>为了控制性能就要能定义初始桶数，设置为要插入元素的75%-150%，最好为素数。</p><p>这个时候就要执行再散列，让这个散列表获得更多的内容。</p><p>再散列：</p><p>需要创建一个桶数更多的表，并将全部元素插入这个新表中。装填因子绝对什么时候在执行，如果装填因子为0.75那么就是在表中75%的位置被占满时，表会给如双倍的桶数自动散列。</p><p><strong>1. Queue</strong></p><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b00031ad78c0408b9e956769669823b6><p class=pgc-img-caption></p></div><p>但是在集合中的Queue并没有单独的实现类，而是用LinkedList实现的。其实你只要看一眼LinkedList的方法就知道，他完全可以实现队列的操作。</p><pre><code>add()尾部添加removeFirst()删除头部元素peek()查看头部元素</code></pre><p>Queue主要有两种不同的类型。</p><p>分别是优先级队列和Deque队列</p><p><strong>2. PriorityQueue</strong></p><p>优先级队列中元素可以按照任意的顺序插入，却按照目标排序的顺序进行检索，也就是无论什么时候调用remove移除的都是当前最小的元素。</p><p>优先级使用了一种堆，一个可以自我调节的二叉树，对树进行执行添加和删除。它可以让最小的元素移动到跟，而不必花时间对其排序。</p><p>当然,你也可以自己对其进行排序.</p><p>举例:</p><pre><code>import java.text.DecimalFormat;import java.util.Comparator;import java.util.PriorityQueue;import java.util.Queue;/** * @Author：sks * @Description： * @Date：Created in 10:39 2018/1/11 * @Modified by： **///二维平面上一个点 class point {    //座标x    double x;    //座标y    double y;    public point(double x, double y){        this.x = x;        this.y = y;    }}//排序函数class PointComparator {    private   point pointOne;    private point pointTwo;    public double distance;    public PointComparator(point pointOne,point pointTwo)    {        this.pointOne = pointOne;        this.pointTwo = pointTwo;        computeDistance();    }    //计算两点之间距离    private void computeDistance() {        double val = Math.pow((this.pointOne.x - this.pointTwo.x),2) +                Math.pow((this.pointOne.y - this.pointTwo.y),2);        this.distance = Math.sqrt(val);    }}public class PriorityQueuep_test {    public static void main(String args[]){         Comparator&lt;PointComparator&gt; OrderDistance =  new Comparator&lt;PointComparator&gt;(){            public int compare(PointComparator one, PointComparator two) {                if (one.distance &lt; two.distance)                    return 1;                else if (one.distance &gt; two.distance)                    return -1;                else                    return 0;            }        };        //定义一个优先队列,用来排序任意两点之间的距离，从大到小排        Queue&lt;PointComparator&gt; FsQueue = new PriorityQueue&lt;PointComparator&gt;(10,OrderDistance);        for (int i=0;i&lt;6;i++){            java.util.Random r= new java.util.Random(10);            point one =new point(i*2+1,i*3+2);            point two =new point(i*5+2,i*6+3);            PointComparator nodecomp = new PointComparator(one,two);            DecimalFormat df = new DecimalFormat("#.##");            FsQueue.add(nodecomp);        }        DecimalFormat df = new DecimalFormat("#.###");        for (int i = 0;i&lt;6;i++){            System.out.println(df.format(FsQueue.poll().distance));        }    }}</code></pre><p><strong>3. Deque</strong></p><p>deque也有些复杂，它可以用ArrayDeque实现，也可以用LinkedList实现。</p><p>线性集合，支持两端的元素插入和移除。Deque是double ended queue的简称，习惯上称之为双端队列。大多数Deque 实现对它们可能包含的元素的数量没有固定的限制，但是该接口支持容量限制的deques以及没有固定大小限制的deque。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dfccc0ce769b4623be2376a48a6b7d54><p class=pgc-img-caption></p></div><p>因为本身也是LinkedList实现的，所以其本身的方法和LinkedList差不了多少。</p><p>举例:</p><pre><code>public class Main {    public static void main(String[] args) {        Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();        deque.offerLast("A"); // A        deque.offerLast("B"); // B -&gt; A        deque.offerFirst("C"); // B -&gt; A -&gt; C        System.out.println(deque.pollFirst()); // C, 剩下B -&gt; A        System.out.println(deque.pollLast()); // B        System.out.println(deque.pollFirst()); // A        System.out.println(deque.pollFirst()); // null    }}</code></pre><p><strong>4. Stack</strong></p><p>stack的名字大家都知道,就是栈.一个先进后出的数据结构,这里我并不认为应该使用java集合中提供的栈集合.</p><p>而是应该使用LinkedList来构建集合:一个小任务:</p><p>用LinkedList实现栈</p><pre><code>public class Stack&lt;T&gt; {    private LinkedList&lt;T&gt; storage=new LinkedList&lt;&gt;();//用LinkedList作为栈的核心    public void push(T v){ storage.addFirst(v);}//    public T peek(){ return storage.getFirst();}    public T pop(){return storage.removeFirst();}    public boolean empty(){return storage.isEmpty();}    public String toString(){return storage.toString();}}</code></pre><p>这样做有一个好处，就是这样的栈可以有更多种的方法，可以采用更多种的方式。无疑这样的栈会更好一些。</p><p>所以我推荐大家用栈的时候,用LinkedList来实现。</p><p><strong>5. MAP</strong></p><p>讲了Collection接口实现的各种集合，我们就要讲讲非Collection的集合。这意味着你在Collection中记住的方法在这个里面完全用不到了。</p><p>我们知道一些键的信息，想要知道与之对应的元素。映射结构就是为此设计的，映射用来存放键值对，如提供了键就能查到值。</p><div class=pgc-img><img alt=[万字长文]阿里架构师突击总结:java集合的核心知识尽揽其中 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e20d56861d624187abe78b410898f672><p class=pgc-img-caption></p></div><p>和Set一样，HashMap要比TreeMap要快上一些，但是TreeMap有序。这与Set很相似，毕竟Set其实也是映射结构。</p><p>每当往映射加入对象是，必须同时提供一个键。</p><p>键是唯一的，不能对同一个键放两个值。如果对同一个键调用两次put方法，第二次调用会取代第一个。</p><p>要想处理所有的键和值，那就应该使用foreach</p><p>列子如下:</p><pre><code>public class MapOfList {    public static Map&lt;Person, List&lt;? extends Pet&gt;&gt; people=new HashMap&lt;&gt;();    static {        people.put(new Person("dawn"), Arrays.asList(new Cymric("Molly"),new Mutt("Spot")));        //就写一个了,有点懒了.    }    public static void main(String[] args) {        System.out.println(people.keySet());//返回的是键组成的set        System.out.println(people.values());//返回的时值组成的set        for (Person person:people.keySet()             ) {            System.out.println(person+"has :");            for (Pet pet:people.get(person)                 ) {                System.out.println(pet);            }        }    }}</code></pre><p>下面还有一个HashMap使用的例子</p><pre><code>public class PetMap {    public static void main(String[] args) {        Map&lt;String, Pet&gt; petMap=new HashMap&lt;String, Pet&gt;();        petMap.put("My Cat",new Cat("MALL"));        petMap.put("My Dog",new Dog("DOGGY"));        petMap.put("My Haster",new Hamster("Bosco"));        System.out.println(petMap);        Pet dog=petMap.get("My Dog");        System.out.println(dog);        System.out.println(petMap.containsKey("My Dog"));//        System.out.println(petMap.containsValue(dog));//    }}</code></pre><h1 class=pgc-h-arrow-right>推荐阅读：</h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6821118048791953931/?group_id=6821118048791953931" rel="noopener noreferrer" target=_blank>太狠了!京东T8架构师建议吃透这40W字消息队列文档,涨薪15K不是梦</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6820415333233328648/?group_id=6820415333233328648" rel="noopener noreferrer" target=_blank>RocketMQ全貌解析，阿里不愧是阿里</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6820021097811935748/?group_id=6820021097811935748" rel="noopener noreferrer" target=_blank>为什么大厂的面试题问的都是底层原理，前阿里P7架构师是这样说的</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6819896661725151752/?group_id=6819896661725151752" rel="noopener noreferrer" target=_blank>java开发必知必会的技能,没有系统掌握Kafka,你就缺少核心竞争力</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6818550260630028811/?group_id=6818550260630028811" rel="noopener noreferrer" target=_blank>2020还不会性能调优?啃下这20W字Java性能调优笔记,随便涨薪13K!</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'万字长','构师','突击'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>