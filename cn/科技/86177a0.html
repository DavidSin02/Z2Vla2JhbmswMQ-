<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「设计模式」建造者模式：你创建对象的方式有它丝滑吗？ | 极客快訊</title><meta property="og:title" content="「设计模式」建造者模式：你创建对象的方式有它丝滑吗？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/24bf1fc955de499183243bc4f9fb6120"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/86177a0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/86177a0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/86177a0.html><meta property="article:published_time" content="2020-10-29T20:58:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:42+08:00"><meta name=Keywords content><meta name=description content="「设计模式」建造者模式：你创建对象的方式有它丝滑吗？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/86177a0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「设计模式」建造者模式：你创建对象的方式有它丝滑吗？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=pgc-h-arrow-right>目录</h3><ul><li>什么是建造者模式</li><li>为什么要使用建造者模式</li><li>构造函数创建对象</li><li>set方式构建对象</li><li>java实现建造者模式</li><ul><li>第一种实现方式</li><li>第二种方式</li></ul><li>建造者模式与构造函数的对比</li><li>建造者模式与工厂模式的对比</li><li>总结</li></ul><p><br></p><h1 class=pgc-h-arrow-right>什么是建造者模式</h1><p>建造者模式是设计模式的一种，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>其实建造者模式是被翻译过来的，他原名叫builder模式，也被称为生成器模式，这种模式的实现非常的简单，只是在使用方面可能会有点摸不着方向，它主要解决复杂的对象创建，比如参数过长、校验过多等等。</p><h1 class=pgc-h-arrow-right>为什么要使用建造者模式</h1><p>我们都知道，创建对象的方法有很多，new是我们最常见也是最熟悉的一种，我们为什么不使用我们最熟悉的而选用建造者模式呢？虽然new是我们最熟悉的，但不一定是最合适的，为什么这么说呢？我们举个例子来说明一下。</p><p>我们现在定义一个对象：ThreadConfig，ThreadConfig有5个属性：核心线程数（corePoolSize）、最大线程数（maxPoolSize）、队列数（queueCapacity）、空闲时间退出（keepAliveTime）、是否允许线程退出（allowCoreThreadTimeout）。属性有必填、有选填。</p><p>属性名必填默认值注释threadName是线程名corePoolSize否4核心线程数maxPoolSize是核心线程数queueCapacity是最大线程数keepAliveTime是当线程空闲时间达到keepAliveTime，该线程会退出allowCoreThreadTimeout是是否允许核心线程数空闲时退出</p><p>创建对象的时候要满足以下要求：1.最大线程数不传，默认为核心线程数的大小。2.最大线程数不能小于核心线程数。3.如果填写队列数，队列书不能小于等于0。4.如果填写keepAliveTime，不能小于等于0。</p><p>看到这样的一个对象，如果是你，你会怎么设计他的对象创建呢？</p><h1 class=pgc-h-arrow-right>构造函数创建对象</h1><p>大家想到的第一种创建方式可能就是构造函数，那我们先使用构造函数实现一下这个对象的创建</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心线程默认值 */    private static final   Integer CORE_POOL_SIZE = 4;    private String threadName;    /** * 核心线程数 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大线程数 */    private Integer maxPoolSize;    /** * 队列数 */    private Integer queueCapacity;    /** * 当线程空闲时间达到keepAliveTime，该线程会退出 */    private Integer keepAliveTime;    /** * 是否允许核心线程数空闲时退出 */    private boolean allowCoreThreadTimeout;    public ThreadConfig(String threadName,Integer corePoolSize,Integer maxPoolSize,Integer queueCapacity,Integer keepAliveTime) throws IllegalAccessException {        if(StringUtils.isEmpty(threadName)){            throw  new IllegalAccessException("线程名不能为空！");        }        this.threadName = threadName;        if(null != corePoolSize ){            if( corePoolSize &lt;= 0){                throw  new IllegalAccessException("核心线程数不能小于等于0！");            }            this.corePoolSize = corePoolSize;        }        if(null != maxPoolSize  ){            if(maxPoolSize &lt; this.corePoolSize){                throw  new IllegalAccessException("最大线程数不能小于核心线程数！");            }            this.maxPoolSize = corePoolSize;        }        if(null != queueCapacity ){            if( queueCapacity &lt;= 0 ){                throw  new IllegalAccessException("队列书不能小于等于0！");            }            this.queueCapacity = queueCapacity;        }        if(null != keepAliveTime  ){            if( keepAliveTime &lt;= 0 ){                throw  new IllegalAccessException("空闲时间不能小于等于0！");            }            this.keepAliveTime = keepAliveTime;        }    }}</code></pre><p>@ToString注解是lombok依赖提供的</p><pre><code>&lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;</code></pre><p>创建对象</p><pre><code>package com.ymy.builder;public class Test {    public static void main(String[] args) throws IllegalAccessException {        ThreadConfig config = new ThreadConfig("thread-1",5,2,5,10);        System.out.println(config);    }}</code></pre><p>输出结果：</p><pre><code>Exception in thread "main" java.lang.IllegalAccessException: 最大线程数不能小于核心线程数！	at com.ymy.builder.ThreadConfig.&lt;init&gt;(ThreadConfig.java:56)	at com.ymy.builder.Test.main(Test.java:6)</code></pre><p>我这里给出的核心线程数：5，但是最大线程数给的2，所以会抛出最大线程数不能小于核心线程数！这种方式看着很完美，但有一点很不友好，当参数过多的时候容易出错，为什么这么说呢？你仔细看这行代码</p><pre><code>ThreadConfig config = new ThreadConfig("thread-1",5,2,5,10);</code></pre><p>除了第一个参数，其他参数都是int类型，看着好像没啥大毛病，这是因为我的参数还不够多，如果我这里有10个参数需要传递，并且都是int类型，这时候就会存在一个问题，参数很可能会被写错，比如最大线程数写到了队列数中，而且有时候还不会报错，只有在项目运行的时候才会出现某种让人摸不着头脑的bug，所以使用构造函数创建对象的时候不太适合参数过长，不但容易出错，而且让接手代码的人也头痛，代码可读性比较差，当然当参数只有一两个的时候，构造函数的创建方式还是很不错的。</p><h1 class=pgc-h-arrow-right>set方式构建对象</h1><p>既然构造函数会导致参数错误以及可读性较差，那我们能不能使用构造函数+set方法来创建对象呢？我们可以尝试一下，由于只有线程名是必传，所以构造函数只给定线程名，其他属性都通过set赋值，改造一下代码。</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心线程默认值 */    private static final   Integer CORE_POOL_SIZE = 4;    private String threadName;    /** * 核心线程数 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大线程数 */    private Integer maxPoolSize;    /** * 队列数 */    private Integer queueCapacity;    /** * 当线程空闲时间达到keepAliveTime，该线程会退出 */    private Integer keepAliveTime;    /** * 是否允许核心线程数空闲时退出 */    private boolean allowCoreThreadTimeout;        public ThreadConfig(String threadName) throws IllegalAccessException {        if(StringUtils.isEmpty(threadName)){            throw  new IllegalAccessException("线程名不能为空！");        }        this.threadName = threadName;    }    public void setCorePoolSize(Integer corePoolSize) throws IllegalAccessException {        if(null != corePoolSize ){            if( corePoolSize &lt;= 0){                throw  new IllegalAccessException("核心线程数不能小于等于0！");            }            this.corePoolSize = corePoolSize;        }    }    public void setMaxPoolSize(Integer maxPoolSize) throws IllegalAccessException {        if(null != maxPoolSize  ){            if(maxPoolSize &lt; this.corePoolSize){                throw  new IllegalAccessException("最大线程数不能小于核心线程数！");            }            this.maxPoolSize = corePoolSize;        }    }    public void setQueueCapacity(Integer queueCapacity) throws IllegalAccessException {        if(null != queueCapacity ){            if( queueCapacity &lt;= 0 ){                throw  new IllegalAccessException("队列书不能小于等于0！");            }            this.queueCapacity = queueCapacity;        }    }    public void setKeepAliveTime(Integer keepAliveTime) throws IllegalAccessException {        if(null != keepAliveTime  ){            if( keepAliveTime &lt;= 0 ){                throw  new IllegalAccessException("空闲时间不能小于等于0！");            }            this.keepAliveTime = keepAliveTime;        }    }    public void setAllowCoreThreadTimeout(boolean allowCoreThreadTimeout) {        this.allowCoreThreadTimeout = allowCoreThreadTimeout;    }}</code></pre><p>改造完ThreadConfig之后我们创建对象的方式也会发生细微的变化，由之前构造函数传递一堆参数变成了一个参数，加上了set方法，初始值由set给定。</p><pre><code>package com.ymy.builder;public class Test {    public static void main(String[] args) throws IllegalAccessException {        ThreadConfig config = new ThreadConfig("thread-1");        config.setCorePoolSize(5);        config.setMaxPoolSize(10);        config.setQueueCapacity(2);        config.setKeepAliveTime(100);        config.setAllowCoreThreadTimeout(false);        System.out.println(config);    }}</code></pre><p>这种对象的创建方式可以有效的防止赋值属性错乱的问题，因为看上去一目了然，基本上不会出错，代码可读性也很强，完美的解决了将所有参数都放在构造函数的缺陷，那为什么还会出现建造者模式呢？可以仔细想一下，set方法这么完美，建造者模式还有必要吗？我觉得建造者模式的出现并不是偶然。</p><p>我们现在稍微修改一下需求：当corePoolSize（核心线程数）被赋值的时候，最大线程数也必须要赋值，这个时候你觉得set方法还能满足吗？我觉得应该是满足不了了吧，这是一种情况，还有一种情况set也是满足不了的，那就是我希望对象初始化的时候一次性将所有的属性都赋值，之后将不能被修改，这一点也是set做不到的，set方法就是提供给调用者的，所以调用者可以通过set随时修改ThreadConfig的属性，如果处理不当，可能会造成某种安全隐患，这个时候你可能又想到，把corePoolSize、maxPoolSize也放到构造函数中不就解决了corePoolSize赋值的时候maxPoolSize也一定要赋值的要求吗，确实是能解决这个问题，如果像这样的参数很多呢？然后又有可能出现参数传错导致诡异bug，所这时候建造者模式就闪亮登场了。</p><h1 class=pgc-h-arrow-right>java实现建造者模式</h1><h2 class=pgc-h-arrow-right>第一种实现方式</h2><p>既然构造函数和set方法无法满足我们的需求，那自然会有满足我们需求的新技术出现，按照之前的需求，线程名必填、corePoolSize（核心线程数）被赋值的时候，最大线程数也必须要赋值，我们一起使用建造模式来实现一下这个对象的创建。</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心线程默认值 */    private static final   Integer CORE_POOL_SIZE = 4;    /** * 线程名 */    private String threadName;    /** * 核心线程数 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大线程数 */    private Integer maxPoolSize;    /** * 队列数 */    private Integer queueCapacity;    /** * 当线程空闲时间达到keepAliveTime，该线程会退出 */    private Integer keepAliveTime;    /** * 是否允许核心线程数空闲时退出 */    private boolean allowCoreThreadTimeout;        private ThreadConfig(ThreadConfig.Builder builder) {        this.threadName = builder.threadName;        if(null != builder.corePoolSize){            this.corePoolSize = builder.corePoolSize;        }        this.maxPoolSize = builder.maxPoolSize;        this.queueCapacity = builder.queueCapacity;        this.keepAliveTime = builder.keepAliveTime;        this.allowCoreThreadTimeout = builder.allowCoreThreadTimeout;    }    public static class Builder {        /** * 线程名 */        private String threadName;        /** * 核心线程数 */        private Integer corePoolSize ;        /** * 最大线程数 */        private Integer maxPoolSize;        /** * 队列数 */        private Integer queueCapacity;        /** * 当线程空闲时间达到keepAliveTime，该线程会退出 */        private Integer keepAliveTime;        /** * 是否允许核心线程数空闲时退出 */        private boolean allowCoreThreadTimeout;        public ThreadConfig build() throws IllegalAccessException { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等            if (StringUtils.isEmpty(threadName)) {                throw new IllegalAccessException("线程名不能为空");            }           if(corePoolSize != null &amp;&amp; maxPoolSize == null){               throw new IllegalAccessException("最大线程数必传");           }            return new ThreadConfig(this);        }        public ThreadConfig.Builder corePoolSize(int corePoolSize) {            if (corePoolSize &lt;= 0) {                throw new IllegalArgumentException("核心线程数不能小于等于0");            }            this.corePoolSize = corePoolSize;            return this;        }        public ThreadConfig.Builder threadName(String threadName) {            this.threadName = threadName;            return this;        }        public ThreadConfig.Builder maxPoolSize(int maxPoolSize) {            if (maxPoolSize &lt; this.corePoolSize) {                throw new IllegalArgumentException("最大线程数不能小于核心线程数");            }            this.maxPoolSize = maxPoolSize;            return this;        }        public ThreadConfig.Builder queueCapacity(int queueCapacity) {            if (queueCapacity &lt;= 0) {                throw new IllegalArgumentException("队列不能小于等于0");            }            this.queueCapacity = queueCapacity;            return this;        }        public ThreadConfig.Builder keepAliveTime(int keepAliveTime) {            if (keepAliveTime &lt;= 0) {                throw new IllegalArgumentException("保持空闲线程可用的时间不能小于等于0");            }            this.keepAliveTime = keepAliveTime;            return this;        }        public ThreadConfig.Builder allowCoreThreadTimeout(boolean allowCoreThreadTimeout) {            this.allowCoreThreadTimeout = allowCoreThreadTimeout;            return this;        }    }}</code></pre><p>我们来测试，传入核心线程数不传最先线程数</p><pre><code>package com.ymy.builder;public class Test {    public static void main(String[] args) throws IllegalAccessException {        ThreadConfig config = new ThreadConfig.Builder()                .threadName("hello")                .corePoolSize(3)                .keepAliveTime(100)                .queueCapacity(2)                .allowCoreThreadTimeout(true)                .build();        System.out.println(config);    }}</code></pre><p>打印结果</p><pre><code>Exception in thread "main" java.lang.IllegalAccessException: 最大线程数必传	at com.ymy.builder.ThreadConfig$Builder.build(ThreadConfig.java:89)	at com.ymy.builder.Test.main(Test.java:12)</code></pre><p>核心线程数不传</p><pre><code> ThreadConfig config = new ThreadConfig.Builder()                .threadName("hello")                //.corePoolSize(3)                .keepAliveTime(100)                .queueCapacity(2)                .allowCoreThreadTimeout(true)                .build();        System.out.println(config);</code></pre><p>结果</p><pre><code>ThreadConfig(threadName=hello, corePoolSize=4, maxPoolSize=null, queueCapacity=2, keepAliveTime=100, allowCoreThreadTimeout=true)Process finished with exit code 0</code></pre><p>这就说明已经达到了我们的预期效果，并且赋值清晰，不容易出错，代码的可读性也比较高，但是也有一点是不足的，那就是ThreadConfig类中会出现冗余的数据Builder。</p><p>建造者模式的参数校验放在了build()方法中，这样做法的好处在于build是集中的处理参数问题，只有校验通过之后才会给ThreadConfig对象实例化，为了对象的安全性，我们可以将ThreadConfig的构造函数设置成private，同时取消set方法，强制使用builder方式创建对象，这样就大大的保证了对象的安全性。</p><h2 class=pgc-h-arrow-right>第二种方式</h2><p>上面那种方式看着是不是很爽，但是创建对象的时候还是需要new ThreadConfig.Builder()，我现在想直接ThreadConfig.Builder()就能创建对象，我不想看到new，能不能实现呢？相信java，他能，我们一起来改造一下代码</p><pre><code>package com.ymy.builder;import lombok.ToString;import org.springframework.util.StringUtils;@ToStringpublic class ThreadConfig {    /** * 核心线程默认值 */    private static final   Integer CORE_POOL_SIZE = 4;    /** * 线程名 */    private String threadName;    /** * 核心线程数 */    private Integer corePoolSize = CORE_POOL_SIZE;    /** * 最大线程数 */    private Integer maxPoolSize;    /** * 队列数 */    private Integer queueCapacity;    /** * 当线程空闲时间达到keepAliveTime，该线程会退出 */    private Integer keepAliveTime;    /** * 是否允许核心线程数空闲时退出 */    private boolean allowCoreThreadTimeout;    private ThreadConfig(ThreadConfig.Builder builder) {        this.threadName = builder.threadName;        if(null != builder.corePoolSize){            this.corePoolSize = builder.corePoolSize;        }        this.maxPoolSize = builder.maxPoolSize;        this.queueCapacity = builder.queueCapacity;        this.keepAliveTime = builder.keepAliveTime;        this.allowCoreThreadTimeout = builder.allowCoreThreadTimeout;    }    /** * 使用静态方法替代new * @return */    public static Builder builder() {        return new Builder();    }    public static class Builder {        /** * 构造函数，可以不写 */        Builder(){        }        /** * 线程名 */        private String threadName;        /** * 核心线程数 */        private Integer corePoolSize ;        /** * 最大线程数 */        private Integer maxPoolSize;        /** * 队列数 */        private Integer queueCapacity;        /** * 当线程空闲时间达到keepAliveTime，该线程会退出 */        private Integer keepAliveTime;        /** * 是否允许核心线程数空闲时退出 */        private boolean allowCoreThreadTimeout;        public ThreadConfig build() throws IllegalAccessException { // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等            if (StringUtils.isEmpty(threadName)) {                throw new IllegalAccessException("线程名不能为空");            }           if(corePoolSize != null &amp;&amp; maxPoolSize == null){               throw new IllegalAccessException("最大线程数必传");           }            return new ThreadConfig(this);        }        public ThreadConfig.Builder corePoolSize(int corePoolSize) {            if (corePoolSize &lt;= 0) {                throw new IllegalArgumentException("核心线程数不能小于等于0");            }            this.corePoolSize = corePoolSize;            return this;        }        public ThreadConfig.Builder threadName(String threadName) {            this.threadName = threadName;            return this;        }        public ThreadConfig.Builder maxPoolSize(int maxPoolSize) {            if (maxPoolSize &lt; this.corePoolSize) {                throw new IllegalArgumentException("最大线程数不能小于核心线程数");            }            this.maxPoolSize = maxPoolSize;            return this;        }        public ThreadConfig.Builder queueCapacity(int queueCapacity) {            if (queueCapacity &lt;= 0) {                throw new IllegalArgumentException("队列不能小于等于0");            }            this.queueCapacity = queueCapacity;            return this;        }        public ThreadConfig.Builder keepAliveTime(int keepAliveTime) {            if (keepAliveTime &lt;= 0) {                throw new IllegalArgumentException("保持空闲线程可用的时间不能小于等于0");            }            this.keepAliveTime = keepAliveTime;            return this;        }        public ThreadConfig.Builder allowCoreThreadTimeout(boolean allowCoreThreadTimeout) {            this.allowCoreThreadTimeout = allowCoreThreadTimeout;            return this;        }    }}</code></pre><p>其实改动很小仅仅只是加了一个static Builder builder()，使用静态方法替代new对象，这样我们创建对象的时候就不需要new了，请看创建对象代码</p><pre><code>ThreadConfig config =ThreadConfig.builder()                .threadName("hello")               // .corePoolSize(3)                .keepAliveTime(100)                .queueCapacity(2)                .allowCoreThreadTimeout(true)                .build();        System.out.println(config);</code></pre><p>是不是爽多了，看着真舒服，不过话说回来，你们看这种创建方式想不想lombok中给对象加了@Builder注解之后的创建方式？没错，就是一样的，因为lombok中的@Builder就是建造者模式，只不过他的build并没有我们这里的条件判断，他是直接将属性返回了。</p><h1 class=pgc-h-arrow-right>建造者模式与构造函数的对比</h1><p>**构造函数：**适用于参数较少，逻辑简单的对象创建，对于参数过多的对象创建可能会造成参数错乱的问题而导致诡异bug。</p><p>**建造者模式：**适用于参数较多，逻辑判断较复杂的对象创建，可以让代码简洁明了，但是对象的代码增加了，不但增加了很多冗余字段，所以有时候表面看起来光鲜亮丽，内心却是无比丑陋。</p><h1 class=pgc-h-arrow-right>建造者模式与工厂模式的对比</h1><p>对工厂模式还不太明白的朋友可以参考一下：工厂模式：你还在使用一堆的if/else创建对象吗？我们知道工厂模式主要是创建一个类型多个实现的对象，比如发送短信验证码的处理方式有很多种情况，每种情况的处理方式都不相同，还有就是创建对象的时候需要经过很多的判断，这种情况下我们就可以考虑使用工厂模式来创建对象。</p><p>如果对象的职责比较单一，没有多层含义，仅仅只是创建条件复杂，参数过多等等，使用建造者模式创建对象是首选，虽然对象中含有冗余代码，但是对象的创建真的很丝滑。</p><h1 class=pgc-h-arrow-right>总结</h1><p>如果一个类中包含着大量的属性，我们可以通过构造函数+set方法来进行对象创建，但对象如果包含一下几点特性，那么我推荐使用建造者模式。1.必填的字段很多，这样会导致构造函数参数过长的问题。<br>2.如果属性与属性之间关联性很强，比如设置了核心线程数就必须要设置最大线程数，这种情况下set方法是无法做到校验的。<br>3.如果当前对象比较重要，我们希望对象被创建之后就不能被修改，所以这时候set方法就会被屏蔽，如果利用构造函数，又会出现字段过多问题。</p><p>当然了，我们不能为了用设计模式而用设计模式，对象一共就两个属性，我们也给他弄成建造者模式，这就有点大材小用，适得其反，一定要结合的实际的项目需求，不能盲目使用。</p><div class=pgc-img><img alt=「设计模式」建造者模式：你创建对象的方式有它丝滑吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/24bf1fc955de499183243bc4f9fb6120><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'模式','设计','创建'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>