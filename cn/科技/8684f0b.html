<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>爱了爱了，这篇寄存器讲的有点意思 | 极客快訊</title><meta property="og:title" content="爱了爱了，这篇寄存器讲的有点意思 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1474850b301846588e8f1a90ce2fd818"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8684f0b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8684f0b.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="爱了爱了，这篇寄存器讲的有点意思"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8684f0b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>爱了爱了，这篇寄存器讲的有点意思</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>作 者：程序员cxuan</p><p>原文链接：https://mp.weixin.qq.com/s/Okpdf90VpbuO7XfI3N3WgQ</p></blockquote><p>下面我们就来介绍一下关于寄存器的相关内容。我们知道，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">寄存器</span>是 CPU 内部的构造，它主要用于信息的存储。除此之外，CPU 内部还有<span style="color:#3594f7;--tt-darkmode-color: #3594F7">运算器</span>，负责处理数据；<span style="color:#3594f7;--tt-darkmode-color: #3594F7">控制器</span>控制其他组件；<span style="color:#3594f7;--tt-darkmode-color: #3594F7">外部总线</span>连接 CPU 和各种部件，进行数据传输；<span style="color:#3594f7;--tt-darkmode-color: #3594F7">内部总线</span>负责 CPU 内部各种组件的数据处理。</p><p>那么对于我们所了解的汇编语言来说，我们的主要关注点就是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">寄存器</span>。</p><p>为什么会出现寄存器？因为我们知道，程序在内存中装载，由 CPU 来运行，CPU 的主要职责就是用来处理数据。那么这个过程势必涉及到从存储器中读取和写入数据，因为它涉及通过控制总线发送数据请求并进入存储器存储单元，通过同一通道获取数据，这个过程非常的繁琐并且会涉及到大量的内存占用，而且有一些常用的内存页存在，其实是没有必要的，因此出现了寄存器，存储在 CPU 内部。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">认识寄存器</span></strong></h1><p>寄存器的官方叫法有很多，Wiki 上面的叫法是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">Processing Register</span>， 也可以称为<span style="color:#3594f7;--tt-darkmode-color: #3594F7">CPU Register</span>，计算机中经常有一个东西多种叫法的情况，反正你知道都说的是寄存器就可以了。</p><p>认识寄存器之前，我们首先先来看一下 CPU 内部的构造。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1474850b301846588e8f1a90ce2fd818><p class=pgc-img-caption></p></div><p>CPU 从逻辑上可以分为 3 个模块，分别是控制单元、运算单元和存储单元，这三部分由 CPU 内部总线连接起来。</p><p>几乎所有的冯·诺伊曼型计算机的 CPU，其工作都可以分为5个阶段：<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「取指令、指令译码、执行指令、访存取数、结果写回」</span></strong>。</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">取指令</span>阶段是将内存中的指令读取到 CPU 中寄存器的过程，程序寄存器用于存储下一条指令所在的地址</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">指令译码</span>阶段，在取指令完成后，立马进入指令译码阶段，在指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">执行指令</span>阶段，译码完成后，就需要执行这一条指令了，此阶段的任务是完成指令所规定的各种操作，具体实现指令的功能。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">访问取数</span>阶段，根据指令的需要，有可能需要从内存中提取数据，此阶段的任务是：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">结果写回</span>阶段，作为最后一个阶段，结果写回（Write Back，WB）阶段把执行指令阶段的运行结果数据写回到 CPU 的内部寄存器中，以便被后续的指令快速地存取；</li></ul><h1 class=pgc-h-arrow-right><strong>计算机架构中的寄存器</strong></h1><p>寄存器是一块速度非常快的计算机内存，下面是现代计算机中具有存储功能的部件比对，可以看到，寄存器的速度是最快的，同时也是造价最高昂的。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/625fd1d0501a4351914eff653751f9ee><p class=pgc-img-caption></p></div><p>我们以 intel 8086 处理器为例来进行探讨，8086 处理器是 x86 架构的前身。在 8086 后面又衍生出来了 8088 。</p><p>在 8086 CPU 中，地址总线达到 20 根，因此最大寻址能力是 2^20 次幂也就是 1MB 的寻址能力，8088 也是如此。</p><p>在 8086 架构中，所有的内部寄存器、内部以及外部总线都是 16 位宽，可以存储两个字节，因为是完全的 16 位微处理器。8086 处理器有 14 个寄存器，每个寄存器都有一个特有的名称，即</p><p><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES」</span></strong></p><p>这 14 个寄存器有可能进行具体的划分，按照功能可以分为三种</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">通用寄存器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">控制寄存器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">段寄存器</span></li></ul><p>下面我们分别介绍一下这几种寄存器</p><h1 class=pgc-h-arrow-right><strong>通用寄存器</strong></h1><p>通用寄存器主要有四种 ，即 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「AX、BX、CX、DX」</span></strong> 同样的，这四个寄存器也是 16 位的，能存放两个字节。AX、BX、CX、DX 这四个寄存器一般用来存放数据，也被称为 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">数据寄存器</span>。它们的结构如下</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/234444186df348319db3e1db0d8e17ea><p class=pgc-img-caption></p></div><p>8086 CPU 的上一代寄存器是 8080 ，它是一类 8 位的 CPU，为了保证兼容性，8086 在 8080 上做了很小的修改，8086 中的通用寄存器 AX、BX、CX、DX 都可以独立使用两个 8 位寄存器来使用。</p><p>在细节方面，AX、BX、CX、DX 可以再向下进行划分</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">AX(Accumulator Register)</span> ：累加寄存器，它主要用于输入/输出和大规模的指令运算。</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">BX(Base Register)</span>：基址寄存器，用来存储基础访问地址</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">CX(Count Register)</span>：计数寄存器，CX 寄存器在迭代的操作中会循环计数</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">DX(data Register)</span>：数据寄存器，它也用于输入/输出操作。它还与 AX 寄存器以及 DX 一起使用，用于涉及大数值的乘法和除法运算。</li></ul><p>这四种寄存器可以分为上半部分和下半部分，用作八个 8 位数据寄存器</p><ul><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「AX 寄存器可以分为两个独立的 8 位的 AH 和 AL 寄存器；」</span></strong></li><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「BX 寄存器可以分为两个独立的 8 位的 BH 和 BL 寄存器；」</span></strong></li><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「CX 寄存器可以分为两个独立的 8 位的 CH 和 CL 寄存器；」</span></strong></li><li><strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「DX 寄存器可以分为两个独立的 8 位的 DH 和 DL 寄存器；」</span></strong></li></ul><p>除了上面 AX、BX、CX、DX 寄存器以外，其他寄存器均不可以分为两个独立的 8 位寄存器</p><p>如下图所示。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4082f09df4a3418aa8be38696d328c0c><p class=pgc-img-caption></p></div><p>合起来就是</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e0bae8c7a392491db8220c1803b86ffd><p class=pgc-img-caption></p></div><p>AX 的低位（0 - 7）位构成了 AL 寄存器，高 8 位（8 - 15）位构成了 AH 寄存器。AH 和 AL 寄存器是可以使用的 8 位寄存器，其他同理。</p><p>在认识了寄存器之后，我们通过一个示例来看一下数据的具体存储方式。</p><p>比如数据 19 ，它在 16 位存储器中所存储的表示如下</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8c0aaa6c24ca44f099f08712e10664d0><p class=pgc-img-caption></p></div><p>寄存器的存储方式是先存储低位，如果低位满足不了就存储高位，如果低位能够满足，高位用 0 补全，在其他低位能满足的情况下，其余位也用 0 补全。</p><p>8086 CPU 可以一次存储两种类型的数据</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">字节(byte)</span>：一个字节由 8 bit 组成，这是一种恒定不变的存储方式</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">字(word)</span>：字是由指令集或处理器硬件作为单元处理的固定大小的数据，对于 intel 来说，一个字长就是两个字节，字是计算机一个非常重要的特征，针对不同的指令集架构来说，计算机一次处理的数据也是不同的。也就是说，针对不同指令集的机器，一次能处理不用的字长，有字、双字（32位）、四字（64位）等。</li></ul><h1 class=pgc-h-arrow-right><strong>AX 寄存器</strong></h1><p>我们上面探讨过，AX 的另外一个名字叫做累加寄存器或者简称为累加器，其可以分为 2 个独立的 8 位寄存器 AH 和 AL；在编写汇编程序中，AX 寄存器可以说是使用频率最高的寄存器。</p><p>下面是几段汇编代码</p><pre><code>mov ax,20   /* 将 20 送入寄存器 AX*/mov ah,80   /* 将 80 送入寄存器 AH*/add ax,10   /* 将寄存器 AX 中的数值加上 8 */</code></pre><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">这里注意下：上面代码中出现的是 ax、ah ，而注释中</span><span style="color:#595959;--tt-darkmode-color: #595959">确是</span><span style="color:#595959;--tt-darkmode-color: #595959"> AX、AH ，其实含义是一样的，不区分大小写。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>AX 相比于其他通用寄存器来说，有一点比较特殊，AX 具有一种特殊功能的使用，那就是使用 DIV 和 MUL 指令式使用。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">DIV 是 8086 CPU 中的</span><span style="color:#3594f7;--tt-darkmode-color: #3594F7">除法</span>指令。</p><p><span style="color:#595959;--tt-darkmode-color: #595959">MUL 是 8086 CPU 中的</span><span style="color:#3594f7;--tt-darkmode-color: #3594F7">乘法</span>指令。</p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>BX 寄存器</strong></h1><p>BX 被称为数据寄存器，即表明其能够暂存一般数据。同样为了适应以前的 8 位 CPU ，而可以将 BX 当做两个独立的 8 位寄存器使用，即有 BH 和 BL。BX 除了具有暂存数据的功能外，还用于 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">寻址</span>，即寻找物理内存地址。BX 寄存器中存放的数据一般是用来作为<span style="color:#3594f7;--tt-darkmode-color: #3594F7">偏移地址</span> 使用的，因为偏移地址当然是在基址地址上的偏移了。偏移地址是在段寄存器中存储的，关于段寄存器的介绍，我们后面再说。</p><h1 class=pgc-h-arrow-right><strong>CX 寄存器</strong></h1><p>CX 也是数据寄存器，能够暂存一般性数据。同样为了适应以前的 8 位 CPU ，而可以将 CX 当做两个独立的 8 位寄存器使用，即有 CH 和 CL。除此之外，CX 也是有其专门的用途的，CX 中的 C 被翻译为 Counting 也就是计数器的功能。当在汇编指令中使用循环 LOOP 指令时，可以通过 CX 来指定需要循环的次数，每次执行循环 LOOP 时候，CPU 会做两件事</p><ul><li>一件事是计数器自动减 1</li><li>还有一件就是判断 CX 中的值，如果 CX 中的值为 0 则会跳出循环，而继续执行循环下面的指令，当然如果 CX 中的值不为 0 ，则会继续执行循环中所指定的指令 。</li></ul><h1 class=pgc-h-arrow-right><strong>DX 寄存器</strong></h1><p>DX 也是数据寄存器，能够暂存一般性数据。同样为了适应以前的 8 位 CPU ，DX 的用途其实在前面介绍 AX 寄存器时便已经有所介绍了，那就是支持 MUL 和 DIV 指令。同时也支持数值溢出等。</p><h1 class=pgc-h-arrow-right><strong>段寄存器</strong></h1><p>CPU 包含四个段寄存器，用作程序指令，数据或栈的基础位置。实际上，对 IBM PC 上所有内存的引用都包含一个段寄存器作为基本位置。</p><p>段寄存器主要包含</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">CS(Code Segment)</span> ：代码寄存器，程序代码的基础位置</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">DS(Data Segment)</span>：数据寄存器，变量的基本位置</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">SS(Stack Segment)</span>：栈寄存器，栈的基础位置</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">ES(Extra Segment)</span>：其他寄存器，内存中变量的其他基本位置。</li></ul><h1 class=pgc-h-arrow-right><strong>索引寄存器</strong></h1><p>索引寄存器主要包含段地址的偏移量，索引寄存器主要分为</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">BP(Base Pointer)</span>：基础指针，它是栈寄存器上的偏移量，用来定位栈上变量</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">SP(Stack Pointer)</span>: 栈指针，它是栈寄存器上的偏移量，用来定位栈顶</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">SI(Source Index)</span>: 变址寄存器，用来拷贝源字符串</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">DI(Destination Index)</span>: 目标变址寄存器，用来复制到目标字符串</li></ul><h1 class=pgc-h-arrow-right><strong>状态和控制寄存器</strong></h1><p>就剩下两种寄存器还没聊了，这两种寄存器是指令指针寄存器和标志寄存器：</p><ul><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">IP(Instruction Pointer)</span>：指令指针寄存器，它是从 Code Segment 代码寄存器处的偏移来存储执行的下一条指令</li><li><span style="color:#3594f7;--tt-darkmode-color: #3594F7">FLAG</span> : Flag 寄存器用于存储当前进程的状态，这些状态有</li><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">位置 (Direction)：用于数据块的传输方向，是向上传输还是向下传输</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">中断标志位 (Interrupt) ：1 - 允许；0 - 禁止</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">陷入位 (Trap) ：确定每条指令执行完成后，CPU 是否应该停止。1 - 开启，0 - 关闭</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">进位 (Carry) : 设置最后一个无符号算术运算是否带有进位</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">溢出 (Overflow) : 设置最后一个有符号运算是否溢出</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">符号 (Sign) : 如果最后一次算术运算为负，则设置 1 =负，0 =正</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">零位 (Zero) : 如果最后一次算术运算结果为零，1 = 零</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">辅助进位 (Aux Carry) ：用于第三位到第四位的进位</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">奇偶校验 (Parity) : 用于奇偶校验</span></li></ul></ul><h1 class=pgc-h-arrow-right><strong><span style="color:#40b8fa;--tt-darkmode-color: #40B8FA">物理地址</span></strong></h1><p>我们大家都知道， CPU 访问内存时，需要知道访问内存的具体地址，内存单元是内存的基本单位，每一个内存单元在内存中都有唯一的地址，这个地址即是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">物理地址</span>。而 CPU 和内存之间的交互有三条总线，即数据总线、控制总线和地址总线。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f0db68e6684d48dcb7b60c7969bc720f><p class=pgc-img-caption></p></div><p>CPU 通过地址总线将物理地址送入存储器，那么 CPU 是如何形成的物理地址呢？这将是我们接下来的讨论重点。</p><p>现在，我们先来讨论一下和 8086 CPU 有关的结构问题。</p><p>cxuan 和你聊了这么久，你应该知道 8086 CPU 是 16 位的 CPU 了，那么，什么是 16 位的 CPU 呢？</p><p>你可能大致听过这个回答，16 位 CPU 指的是 CPU 一次能处理的数据是 16 位的，能回答这个问题代表你的底层还不错，但是不够全面，其实，16 位的 CPU 指的是</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">CPU 内部的运算器一次最多能处理 16 位的数据</span></li></ul><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">运算器其实就是 ALU，运算控制单元，它是 CPU 内部的三大核心器件之一，主要负责数据的运算。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">寄存器的最大宽度为 16 位</span></li></ul><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">这个寄存器的最大宽度值就是通用寄存器能处理的二进制数的最大位数</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">寄存器和运算器之间的通路为 16 位</span></li></ul><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">这个指的是寄存器和运算器之间的总线，一次能传输 16 位的数据</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>好了，现在你应该知道为什么叫做 16 位 CPU 了吧。</p><p>在你知道上面这个问题的答案之后，我们下面就来聊一聊如何计算物理地址。</p><p>8086 CPU 有 20 位地址总线，每一条总线都可以传输一位的地址，所以 8086 CPU 可以传送 20 位地址，也就是说，8086 CPU 可以达到 2^20 次幂的寻址能力，也就是 1MB。8086 CPU 又是 16 位的结构，从 8086 CPU 的结构看，它只能传输 16 位的地址，也就是 2^16 次幂也就是 64 KB，那么它如何达到 1MB 的寻址能力呢？</p><p>原来，8086 CPU 的内部采用两个 16 位地址合成的方式来传输一个 20 位的物理地址，如下图所示</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c89a68cdb3649dda389b376107d0d51><p class=pgc-img-caption></p></div><p>叙述一下上图描述的过程</p><p>CPU 相关组件提供两个地址：段地址和偏移地址，这两个地址都是 16 位的，他们经由<span style="color:#3594f7;--tt-darkmode-color: #3594F7">地址加法器</span>变为 20 位的物理地址，这个地址即是输入输出控制电路传递给内存的物理地址，由此完成物理地址的转换。</p><p>地址加法器采用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「物理地址 = 段地址 * 16 + 偏移地址」</span></strong> 的方法用段地址和偏移地址合成物理地址。</p><p>下面是地址加法器的工作流程</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d61233c1cfd4caa9689fc612ca96b2b><p class=pgc-img-caption></p></div><p>其实段地址 * 16 ，就是左移 4 位。在上面的叙述中，物理地址 = 段地址 * 16 + 偏移地址，其实就是<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「基础地址 + 偏移地址 = 物理地址」</span></strong> 寻址模式的一种具体实现方案。基础地址其实就等于段地址 * 16。</p><p>你可能不太清楚 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">段</span> 的概念，下面我们就来探讨一下。</p><h1 class=pgc-h-arrow-right><strong>什么是段</strong></h1><p>段这个概念经常出现在操作系统中，比如在内存管理中，操作系统会把不同的数据分成 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">段</span>来存储，比如 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「代码段、数据段、bss 段、rodata 段」</span></strong> 等。</p><p>但是这些的划分并不是内存干的，cxuan 告诉你是谁干的，这其实是幕后 Boss CPU 搞的，内存当作了声讨的对象。</p><p>其实，内存没有进行分段，分段完全是由 CPU 搞的，上面聊过的通过基础地址 + 偏移地址 = 物理地址的方式给出内存单元的物理地址，使得我们可以分段管理 CPU。</p><p>如图所示</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9753d65d17b346658971030267256c57><p class=pgc-img-caption></p></div><p>这是两个 16 KB 的程序分别被装载进内存的示意图，可以看到，这两个程序的段地址的大小都是 16380。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">这里需要注意一点， 8086 CPU 段地址的计算方式是段地址 * 16，所以，16 位的寻址能力是 2^16 次方，所以一个段的长度是 64 KB。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>段寄存器</strong></h1><p>cxuan 在上面只是简单为你介绍了一下段寄存器的概念，介绍的有些浅，而且介绍段寄存器不介绍段也有<strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「不知庐山真面目」</span></strong>的感觉，现在为你详细的介绍一下，相信看完上面的段的概念之后，段寄存器也是手到擒来。</p><p>我们在合成物理地址的那张图提到了 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">相关部件</span> 的概念，这个相关部件其实就是<span style="color:#3594f7;--tt-darkmode-color: #3594F7">段寄存器</span>，即 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「CS、DS、SS、ES」</span></strong> 。8086 的 CPU 在访问内存时，由这四个寄存器提供内存单元的段地址。</p><h1 class=pgc-h-arrow-right><strong>CS 寄存器</strong></h1><p>要聊 CS 寄存器，那么 IP 寄存器是你绕不过去的曾经。CS 和 IP 都是 8086 CPU 非常重要的寄存器，它们指出了 CPU 当前需要读取指令的地址。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">CS 的全称是 Code Segment，即代码寄存器；而 IP 的全称是 Instruction Pointer ，即指令指针。现在知道这两个为什么一起出现了吧！</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>在 8086 CPU 中，由 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">CS:IP</span> 指向的内容当作指令执行。如下图所示</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e2da2cfc5d434875a23ec311bebbb7d1><p class=pgc-img-caption></p></div><p>说明一下上图</p><p>在 CPU 内部，由 CS、IP 提供段地址，由加法器负责转换为物理地址，输入输出控制电路负责输入/输出数据，指令缓冲器负责缓冲指令，指令执行器负责执行指令。在内存中有一段连续存储的区域，区域内部存储的是机器码、外面是地址和汇编指令。</p><p>上面这幅图的段地址和偏移地址分别是 2000 和 0000，当这两个地址进入地址加法器后，会由地址加法器负责将这两个地址转换为物理地址</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8abee60606464c2fa5a19fc95f001d39><p class=pgc-img-caption></p></div><p>然后地址加法器负责将指令输送到输入输出控制电路中</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/082d8e4e74be4f7cb5ea5f29f6df73fc><p class=pgc-img-caption></p></div><p>输入输出控制电路将 20 位的地址总线送到内存中。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b120b56cf19d4614b2928ac8dfc59c01><p class=pgc-img-caption></p></div><p>然后取出对应的数据，也就是 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「B8、23、01」</span></strong>，图中的 B8、BB 都是操作数。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ef6953aa7fb4f31a8acb099367118d3><p class=pgc-img-caption></p></div><p>控制输入/输出电路会将 B8 23 01 送入指令缓存器中。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c699f420522f4c53966c390b4fd807da><p class=pgc-img-caption></p></div><p>此时这个指令就已经具备执行条件，此时 IP 也就是指令指针会自动增加。我们上面说到 IP 其实就是从 Code Segment 也就是 CS 处偏移的地址，也就是偏移地址。它会知道下一个需要读取指令的地址，如下图所示</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cadd4be973e749738dee7b057fb43bd4><p class=pgc-img-caption></p></div><p>在这之后，指令执行执行取出的 B8 23 01 这条指令。</p><p>然后下面再把 2000 和 0003 送到地址加法器中再进行后续指令的读取。后面的指令读取过程和我们上面探讨的如出一辙，这里 cxuan 就不再赘述啦。</p><p>通过对上面的描述，我们能总结一下 8086 CPU 的工作过程</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">段寄存器提供段地址和偏移地址给地址加法器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">由地址加法器计算出物理地址通过输入输出控制电路将物理地址送到内存中</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">提取物理地址对应的指令，经由控制电路取回并送到指令缓存器中</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">IP 继续指向下一条指令的地址，同时指令执行器执行指令缓冲器中的指令</span></li></ul><h1 class=pgc-h-arrow-right><strong>什么是 Code Segment</strong></h1><p>Code Segment 即代码段，它就是我们上面聊到就是 CS 寄存器中存储的基础地址，也就是段地址，段地址其本质上就是一组内存单元的地址，例如上面的 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「mov ax,0123H 、mov bx, 0003H」</span></strong>。我们可以将长度为 N 的一组代码，存放在一组连续地址、其实地址为 16 的倍数的内存单元中，我们可以认为，这段内存就是用来存放代码的。</p><h1 class=pgc-h-arrow-right><strong>DS 寄存器</strong></h1><p>CPU 在读写一个内存单元的时候，需要知道这个内存单元的地址。在 8086 CPU 中，有一个 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">DS 寄存器</span>，通常用来存放访问数据的段地址。如果你想要读取一个 10000H 的数据，你可能会需要下面这段代码</p><pre><code>mov bx,10000Hmov ds,bxmov a1,[0]</code></pre><p>上面这三条指令就把 10000H 读取到了 a1 中。</p><p>在上面汇编代码中，mov 指令有两种传送方式</p><ul><li><span style="color:#595959;--tt-darkmode-color: #595959">一种是把数据直接送入寄存器</span></li><li><span style="color:#595959;--tt-darkmode-color: #595959">一种是将一个寄存器的内容送入另一个寄存器</span></li></ul><p>但是不仅仅如此，mov 指令还具有下面这几种表达方式</p><p><span style="color:#595959;--tt-darkmode-color: #8D8D8D"><span style="background-color:#f0f0f0;--tt-darkmode-bgcolor: #212121">描述举例</span></span><span style="color:#595959;--tt-darkmode-color: #595959">mov 寄存器，数据比如：mov ax,8</span><span style="color:#595959;--tt-darkmode-color: #8D8D8D"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">mov 寄存器，寄存器比如：mov ax,bx</span></span><span style="color:#595959;--tt-darkmode-color: #595959">mov 寄存器，内存单元比如：mov ax,[0]</span><span style="color:#595959;--tt-darkmode-color: #8D8D8D"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">mov 内存单元，寄存器比如：mov[0], ax</span></span><span style="color:#595959;--tt-darkmode-color: #595959">mov 段寄存器，寄存器比如：mov ds,ax</span></p><h1 class=pgc-h-arrow-right><strong>栈</strong></h1><p>栈我相信大部分小伙伴已经非常熟悉了，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">栈</span>是一种具有特殊的访问方式的存储空间。它的特殊性就在于，先进入栈的元素，最后才出去，也就是我们常说的 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">先入后出</span>。</p><p>它就像一个大的收纳箱，你可以往里面放相同类型的东西，比如书，最先放进收纳箱的书在最下面，最后放进收纳箱的书在最上面，如果你想拿书的话， 必须从最上面开始取，否则是无法取出最下面的书籍的。</p><p>栈的数据结构就是这样，你把书籍压入收纳箱的操作叫做<span style="color:#3594f7;--tt-darkmode-color: #3594F7">压入（push）</span>，你把书籍从收纳箱取出的操作叫做<span style="color:#3594f7;--tt-darkmode-color: #3594F7">弹出（pop）</span>，它的模型图大概是这样</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47de7857886a4a47a3fc01493ce57667><p class=pgc-img-caption></p></div><p>入栈相当于是增加操作，出栈相当于是删除操作，只不过叫法不一样。栈和内存不同，它不需要指定元素的地址。它的大概使用如下</p><pre><code>// 压入数据Push(123);Push(456);Push(789);// 弹出数据j = Pop();k = Pop();l = Pop();</code></pre><p>在栈中，LIFO 方式表示栈的数组中所保存的最后面的数据（Last In）会被最先读取出来（First Out）。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f9680889d7b4eeaa9762636eba98f16><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>栈和 SS 寄存器</strong></h1><p>下面我们就通过一段汇编代码来描述一下栈的压入弹出的过程</p><p>8086 CPU 提供入栈和出栈指令，最基本的两个是 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">PUSH(入栈)</span> 和 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">POP(出栈)</span>。比如 push ax 会把 ax 寄存器中的数据压入栈中，pop ax 表示从栈顶取出数据送入 ax 寄存器中。</p><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">这里注意一点：8086 CPU 中的入栈和出栈都是以字为单位进行的。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>我这里首先有一个初始的栈，没有任何指令和数据。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f07ec310075940d887687ba7ecade20d><p class=pgc-img-caption></p></div><p>然后我们向栈中 push 数据后，栈中数据如下</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a818eab98cb4ee49fc0e2ee8db07a92><p class=pgc-img-caption></p></div><p>涉及的指令有</p><pre><code>mov ax,2345Hpush ax</code></pre><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959">❝</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">注意，数据会用两个单元存放，高地址单元存放高 8 位地址，低地址单元存放低 8 位。</span></p><p><span style="color:#595959;--tt-darkmode-color: #595959">❞</span></p></blockquote><p>再向栈中 push 数据</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a10a908953574ac38edc75a01232d8fc><p class=pgc-img-caption></p></div><p>其中涉及的指令有</p><pre><code>mov bx,0132Hpush bx</code></pre><p>现在栈中有两条数据，现在我们执行出栈操作</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f50359ff0364a4d859c169f97a782c7><p class=pgc-img-caption></p></div><p>其中涉及的指令有</p><pre><code>pop ax/* ax = 0132H */</code></pre><p>再继续取出数据</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77e958bde3d04b34b84e554c062d6dc5><p class=pgc-img-caption></p></div><p>涉及的指令有</p><pre><code>pop bx/* bx = */</code></pre><p>完整的 push 和 pop 过程如下</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b5f1f6c92fc0418eafb26304cf449a85><p class=pgc-img-caption></p></div><p>现在 cxuan 问你一个问题，我们上面描述的是 10000H ~ 1000FH 这段空间来作为 push 和 pop 指令的存取单元。但是，你怎么知道这个栈单元就是 10000H ~ 1000FH 呢？也就是说，你如何选择指定的栈单元进行存取？</p><p>事实上，8086 CPU 有一组关于栈的寄存器 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">SS</span> 和 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">SP</span>。SS 是段寄存器，它存储的是栈的基础位置，也就是栈顶的位置，而 SP 是栈指针，它存储的是偏移地址。在任意时刻，<span style="color:#3594f7;--tt-darkmode-color: #3594F7">SS:SP</span> 都指向栈顶元素。push 和 pop 指令执行时，CPU 从 SS 和 SP 中得到栈顶的地址。</p><p>现在，我们可以完整的描述一下 push 和 pop 过程了，下面 cxuan 就给你推导一下这个过程。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e7e0820abb404a09a78e6e70ead4724d><p class=pgc-img-caption></p></div><p>上面这个过程主要涉及到的关键变化如下。</p><p>当使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「PUSH」</span></strong> 指令向栈中压入 1 个字节单元时，SP = SP - 1；即栈顶元素会发生变化；</p><p>而当使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「PUSH」</span></strong> 指令向栈中压入 2 个字节的字单元时，SP = SP – 2 ；即栈顶元素也要发生变化；</p><p>当使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「POP」</span></strong> 指令从栈中弹出 1 个字节单元时， SP = SP + 1；即栈顶元素会发生变化；</p><p>当使用 <strong><span style="color:#3594f7;--tt-darkmode-color: #3594F7">「POP」</span></strong> 指令从栈中弹出 2 个字节单元的字单元时， SP = SP + 2 ；即栈顶元素会发生变化；</p><h1 class=pgc-h-arrow-right><strong>栈顶越界问题</strong></h1><p>现在我们知道，8086 CPU 可以使用 SS 和 SP 指示栈顶的地址，并且提供 PUSH 和 POP 指令实现入栈和出栈，所以，你现在知道了如何能够找到栈顶位置，但是你如何能保证栈顶的位置不会越界呢？栈顶越界会产生什么影响呢？</p><p>比如如下是一个栈顶越界的示意图</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6356fba34ef840ee89a06cff7fd00da4><p class=pgc-img-caption></p></div><p>第一开始，SS：SP 寄存器指向了栈顶，然后向栈空间 push 一定数量的元素后，SS:SP 位于栈空间顶部，此时再向栈空间内部 push 元素，就会出现栈顶越界问题。</p><p>栈顶越界是危险的，因为我们既然将一块区域空间安排为栈，那么在栈空间外部也可能存放了其他指令和数据，这些指令和数据有可能是其他程序的，所以如此操作会让计算机<span style="color:#3594f7;--tt-darkmode-color: #3594F7">懵逼</span>。</p><p>我们希望 8086 CPU 能自己解决问题，毕竟 8086 CPU 已经是个成熟的 CPU 了，要学会自己解决问题了。</p><div class=pgc-img><img alt=爱了爱了，这篇寄存器讲的有点意思 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb9b26618e524a42a06e9b4ff16fbd3f><p class=pgc-img-caption></p></div><p>然鹅（故意的），这对于 8086 CPU 来说，这可能是它一辈子的 <span style="color:#3594f7;--tt-darkmode-color: #3594F7">夙愿</span> 了，真实情况是，8086 CPU 不会保证栈顶越界问题，也就是说 8086 CPU 只会告诉你栈顶在哪，并不会知道栈空间有多大，所以需要程序员自己手动去保证。。。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'爱了','这篇','讲的'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>