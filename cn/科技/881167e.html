<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux系统——架构浅析 | 极客快訊</title><meta property="og:title" content="Linux系统——架构浅析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/Rk0wUty1gf5VYb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/881167e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/881167e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/881167e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/881167e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/881167e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/881167e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/881167e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/881167e.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="Linux系统——架构浅析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/881167e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux系统——架构浅析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>导语：掐指一算自己从研究生开始投入到Linux的海洋也有几年的时间，即便如此依然对其各种功能模块一知半解。无数次看了Linux内核的技术文章后一头雾水，为了更系统地更有方法的学Linux，特此记录。</p><p><strong>历史</strong></p><p><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">199</i>1年，还在芬兰赫尔辛基大学上学的Linus Torvalds在自己的Intel <i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">386</i>计算机上开发了属于他自己的第一个程序，并利用Internet发布了他开发的源代码，将其命名为Linux，从而创建了Linux操作系统，并在同年公开了Linux的代码，从而开启了一个伟大的时代。在之后的将近30年的时间里，越来越多的工程师投入到Linux，帮助不断完善Linux的功能。现在的Linux系统架构凭借优秀的分层和模块化的设计，融合了大量的设备和不同的物理架构。</p><p>写这篇文章，也是对Linux系统的一个非常简单的介绍，主要讲解Linux的进程调度、内存管理、设备驱动、文件系统、网络模块。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Rk0wUty1gf5VYb><p>Linux内核架构图</p><p>上图就是Linux内核的架构图，从硬件层--->操作系统内核--->应用层，这套系统架构的设计应用于各类软硬件结合的系统上，比如物联网系统，单片机系统、机器人等领域。</p><p><strong>进程调度</strong></p><p>进程在Linux系统中称为process或task。操作系统中进程的数据结构包含很多元素，诸如：地址空间、进程优先级、进程状态、信号量、占用的文件等，往往用链表链接。</p><p>CPU在每个系统滴答（Tick）中断产生的时候检查就绪队列里边的进程（遍历链表中的进程结构体），如有符合调度算法的新进程需要切换，保存当前运行的进程的信息（包括栈、地址等）后挂起当前进程，然后运行新的进程，这就是进程调度。</p><p>CPU调度的基本依据是进程的优先级。调度的终极目标是让高优先级的进程能及时得到CPU的资源，低优先级的任务也能公平的分配到CPU资源。不过因为保存当前进程的信息所以进程的切换本身是有成本的，调度算法同样需要考虑效率。</p><p>在早期Linux内核中，就是采用轮询算法来实现的，内核在就绪的进程队列中选择高优先级的进程执行，每次运行相等时间，该算法简单直观，但仍然会导致一些低优先级的进程长时间不能执行。为了提高调度的公平性，在后来Linux内核（2.6）中，引入了CFS调度器算法。</p><p>CFS引入虚拟运行时间的概念，虚拟运行时间用task_struct->se.vruntime表示，通过它来记录和度量进程应该获得的CPU运行时间。在理想的调度情况下，任何时候所有的进程都应该有相同的task_struct->se.vruntime值。因为每个进程都是并发执行，没有进程会超过理想状态下应该占有的CPU时间。CFS选择需要运行的进程的逻辑基于task_struct->se.vruntime值，它总是选择task_struct->se.vruntime值最小的进程来运行（为了公平）。</p><p>CFS使用基于时间排序的红黑树来为将来进程的执行时间线。所有的进程按task_struct->se.vruntime关键字排序。CFS从树中选择最左边的任务执行。随着系统运行，执行过的进程会被放到树的右侧，逐步让每个任务都有机会成为最左边的进程，从而让每个进程都能获取CPU资源。</p><p>总的来说，CFS算法首先选一个进程，当进程切换时，该进程使用的CPU时间会加到该进程task_struct->se.vruntime里，当task_struct->se.vruntime的值逐渐增大到别的进程变成了红黑树最左边的进程时，最左边的进程被选中执行，当前的进程被抢占。</p><p><strong>内存管理</strong></p><p>内存，一种硬件设备，操作系统对其寻址，找到对应的内存单元，然后对其操作。CPU的字节长度决定了最大的可寻址空间，32位机器最大寻址空间是4G Bytes，<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">64</i>位机器最大寻址空间是2^<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">64</i> Bytes。</p><p>最大寻址空间和物理内存大小无关，称之为虚拟地址空间。Linux内核把虚拟地址空间分为内核空间和用户空间。每个用户进程的虚拟地址空间范围是0~TASK_SIZE。从TASK_SIZE~2^32或2^<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">64</i>的区域保留给内核，不能被用户进程访问。</p><p></p><h2 toutiao-origin=h3>虚拟地址空间与物理内存的映射</h2><p>绝大多数情况下，虚拟地址空间比实际物理内存大，操作系统需要考虑如何将实际可用的物理内存映射到虚拟地址空间。</p><p>Linux内核采用页表（page table）将虚拟地址映射到物理地址。虚拟地址和进程使用的用户&内核地址有关，物理地址用来寻址实际使用的内存。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rk0wUuJ6n1Y5BD><p>示例图</p><p>上图所示，A和B进程的虚拟地址空间被分为大小相等的等份，称为页（page）。物理内存同样被分割为大小相等的页（page frame）。</p><p>进程A第1个内存页映射到物理内存(RAM)的第4页；进程B第1个内存页映射到物理内存第5页。进程A第5个内存页和进程B第1个内存页都映射到物理内存的第5页(内核可决定哪些内存空间被不同进程共享)。页表将虚拟地址空间映射到物理地址空间。</p><blockquote><strong>文件系统</strong></blockquote><p>Linux的核心理念：everything is file。Linux系统存在很多文件系统，比如EXT2，EXT3，EXT4，rootfs，proc等等，每一种文件系统都是独立的，有自己的组织方式、操作方法。</p><p>为了支持不同的文件系统，内核在用户态和文件系统之间包含了一层虚拟文件系统（Virtual File System）。大多数内核提供的函数都能通过VFS定义的接口来访问。例如内核的子系统：字符设备、块设备，管道，socket等。另外，用于操作字符和块设备的文件是在/dev目录下真实文件，当读写操作执行的时候，其会被对应的驱动程序创建。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Rk0wUuaIPknhZn><p>VFS结构图</p><p>Linux的虚拟文件系统四大对象：</p><p>1. super block（超级块）</p><p>2. inode（节点）</p><p>3. dentry（目录）</p><p>4. block（具体的数据块）</p><p></p><h2 toutiao-origin=h3>super block</h2><p>代表一个具体的已经安装的文件系统，包含文件系统的类型、大小、状态等等。</p><p></p><h2 toutiao-origin=h3>inode</h2><p>代表一个具体的文件，在Linux文件管理中，一个文件除了自身的数据外，还有一个附属信息，即文件的元数据（metadata），这个元数据用于记录文件的许多信息比如文件大小、创建人、创建时间等，这个元数据就包含在inode中。</p><p>inode是文件从抽象--->具体的关键。inode存储了一些指针，这些指针指向存储设备的一些数据块，文件的内容就存储在这些数据块中。Linux想打开一个文件时，只需要找到文件对应的inode，然后沿着指针，将所有的数据块攒起来，就可以在内存中组成一个文件的数据了。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Rk0wUusDF7HkjU><p>inode 结构</p><p>inode并不是组织文件的唯一方式，最简单的组织文件的方式，是把文件依次顺序的放入存储设备，但如果有删除操作的话，删除造成的空余空间夹杂在正常文件之间，很难利用和管理；复杂方式可以用来链表来做，每个数据块有个指针，指向属于同一文件的下一个数据块，这样的好处是可以利用零散的空余空间，坏处是对文件的操作必须按照线性方式进行，如果随机读取就必须要遍历链表，直到目标位置。由于这一遍历不是在内存进行，所以速度很慢。</p><p>inode既可以充分利用空间，在内存占据空间不与存储设备相关，解决了上面的问题。但inode也有自己的问题。每个inode能够存储的数据块指针总数是固定的。如果一个文件需要的数据块超过这一总数，inode需要额外的空间来存储多出来的指针。</p><p></p><h2 toutiao-origin=h3>dentry</h2><p>代表一个目录项，是路径的一部分，比如一个路径/home/jackycao/hello.txt，那么目录项就有home、jackycao、hello.txt。</p><p></p><h2 toutiao-origin=h3>block</h2><p>代表具体的数据，一个文件由分散的多个block组成，组织的方式由inode来指向。</p><blockquote><strong>设备驱动</strong></blockquote><p>与外设的交互，说白了就是输入（input）、操作（operate）、输出（ouput）的操作。</p><p>内核需要完成三件事情：</p><p>1. 针对不同的设备类型实现不同的方法来寻址硬件。</p><p>2. 必须为用户空间提供操作不同硬件设备的方法，且需要一个统一的机制来确保尽量有限的编程工作。</p><p>3. 让用户空间知道在内核中有哪些设备。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Rk0wUvA5Ukyu34><p>设备通信图</p><p>内核访问外设主要有两种方式：I/O端口和I/O内存映射。具体不展开介绍了。</p><p>内核动态接收外设发来的请求（数据）主要通过两种方式：轮询和中断。</p><p>轮询：周期性的访问查询设备是否有数据，如果有，便获取数据。这种方法比较浪费CPU资源。</p><p>中断：核心思想是外设有请求时主动通知CPU，中断的优先级最高，会中断CPU的当前进程运行，每个CPU都提供了中断线，每个中断由唯一的中断号识别，内核为每个应用的中断提供一个中断处理方法。当有数据已准备好可以给内核或者间接被一个应用程序使用的时候，外设出发一个中断。使用中断确保系统只有在外设需要处理器介入的时候才会通知CPU，提高了效率。</p><p>PS：块和扇区的概念：块是一个指定大小的字节序列，用于保存在内核和设备间传输的数据，块的大小可以被设置，默认是4096 bytes，扇区是存储设备操作的最小单元，默认是512 Bytes，块是一段连续的扇区。</p><blockquote><strong>网络</strong></blockquote><p>Linux的网络子系统的模型基于ISO的OSI模型，Linux内核中会简化相应层级。下图为Linux使用的TCP/IP参考模型。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rk0wVCi1WyiHko><p>网络模型</p><p>Host-to-Host层：相当于OSI模型的物理层和数据链路层，负责将数据从一个计算机传输到另一个计算机。在Linux内核的角度来看，这一层是通过网卡的设备驱动程序实现的。</p><p>Internet层：相当于OSI模型的网络层，负责让网络中的计算机可以交换数据（这些计算机并不一定是直连的）。该层同时负责传输的包分成指定的大小，因为包在传输路径上每个计算机支持的最大网络包的大小不一样，在传输时数据被分割成不同的包，在接收端再组合。该层为网络中的计算机分配唯一的网络地址。</p><p>Transport层：相当于OSI模型的传输层，负责让两个连接的计算机上运行的应用程序之间的数据传输。比如，两台计算机上的客户端和服务端程序，通过端口号来识别通信的应用程序。</p><p>App层：相当于OSI模型的会话层、表示层、应用层，网络中不同计算机的两个应用程序建立连接后，这一层负责实际内容的传输。</p><p>Linux内核子系统的实现通过C代码实现，每个层只能和它上下层通信。</p><img alt=Linux系统——架构浅析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rk0wVD5CqN1nkY><p>Linux网络分层图</p><blockquote><strong>参考资料</strong></blockquote><p>《Linux内核设计与实现》</p><p>《Linux内核完全剖析》</p><p>《Linux设备驱动程序》</p><p>订阅我的<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">微信</i>公众号“杨建荣的学习笔记”，第一时间免费收到文章更新。别忘了加星标，以免错过新推送提示。</p><p><strong>近期热文</strong></p><p>你可能也会对以下话题感兴趣。点击链接就可以查看。</p><blockquote><ul><li><p>MySQL的主键命名挺任性，就这么定了</p></li><li><p>迁移到MySQL的业务架构演进实战</p></li><li><p>数据库修改密码风险高，如何保证业务持续，这几种密码双活方案可以参考</p></li><li><p>MySQL业务双活的初步设计方案</p></li><li><p>如何优化MySQL千万级大表，我写了6000字的解读</p></li><li><p>一道经典的MySQL面试题，答案出现三次反转</p></li><li><p>业务双活的数据切换思路设计（下）</p></li><li><p>业务双活的数据切换思路设计（一）</p></li><li><p>MySQL中的主键和rowid,看似简单,其实有一些使用陷阱需要注意</p></li><li><p>小白学MySQL要多久?我整理了10多个问题的答案</p></li></ul></blockquote><p><strong>转载热文</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','系统','架构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>