<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>用Python开发一个交互式网络和IP地址计算器 | 极客快訊</title><meta property="og:title" content="用Python开发一个交互式网络和IP地址计算器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/b68493d793384225b7976f63fa6edf9d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88861ea.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88861ea.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/88861ea.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88861ea.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88861ea.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/88861ea.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/88861ea.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88861ea.html><meta property="article:published_time" content="2020-10-29T20:52:23+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:23+08:00"><meta name=Keywords content><meta name=description content="用Python开发一个交互式网络和IP地址计算器"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/88861ea.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>用Python开发一个交互式网络和IP地址计算器</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>今天从Python的角度来聊下计算机网络这行基础中的基础的话题：网络和IP地址计算（注：本文里的IP指的是IPv4，不涉及IPv6）。相信几乎每位网工读者在平时的工作和学习中都用过类似下图的在线网络和IP地址计算器吧：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b68493d793384225b7976f63fa6edf9d><p class=pgc-img-caption></p></div><p>这类前人（或者说码农们）造出的轮子的确很好用，但是很少有网工明白它们背后的工作原理（也就是代码是怎么写出来的）。作为有志成为NetDevOps Engineer的我们有必要深入的从代码的角度来学习一下，不妨自己也用Python从零写一个交互式的网络和IP地址计算器，重新造一遍轮子，一来可以温故知新，<strong>二来可以帮助我们更深入的了解二进制和十进制在Python里是怎么玩的</strong>。该交互式计算器的作用是让用户输入一个合法的IP地址及子网掩码，然后根据用户输入的信息自动给出用户查询的网段的<strong>网络IP、广播IP、网段内可用的IP地址数、反掩码以及用户输入的子网掩码对应的“/”格式的掩码位</strong>（比如用户输入的掩码是255.255.128.0，计算器会自动在结果中给出/17的掩码位）。</p><p>因为是所有网工必须掌握的基本功，为了节约篇幅，下面我只高度概括一下网络和IP地址计算的理论要点，我们重点要关注的是如何在Python中实现它们（所有演示我都将在解释器里实时完成，让读者更清楚的看到十进制和二进制的相互转换在Python中是怎样完成的）大致可以归纳为A,B,C,D,E总共5个点，分述如下：</p><h1 class=pgc-h-arrow-right><strong>A</strong>.</h1><p>我们知道任何一个合法的IP地址和子网掩码都可以用32位的二进制（binary）表示，这32位二进制又被分为4个八位位组（octet），比如192.168.1.1用二进制可以写成11000000.10101000.00000001.00000001，这个转换步骤在Python中实现的方法如下：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/455f8b8ef282483a85513ef908726a86><p class=pgc-img-caption></p></div><ul><li>这里我们用字符串自带的split()函数将ip地址（字符串‘192.168.1.1'）转换成列表ip_octets，然后创建一个空列表ip_octets_binary，随后用for循环遍历ip_octets里的元素，将它们每个用bin()函数转换成二进制形式，然后一一写入刚才创建的空列表ip_octets_binary里面。</li><li>关于binary_octet = bin(int(octet)).lstrip('0b')，bin()只能将数据类型为整数的十进制数转换成二进制，因此这里我们要先将字符串用int()转换成整数后再来调用bin()函数，而bin()函数本身会在转化后的二进制数字前面加上'0b'，我们必须调用lstrip('0b')将其拿掉，演示如下:</li></ul><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39e210b225724bf5a400dfa0d8783e89><p class=pgc-img-caption></p></div><p><br></p><ul><li>再来看ip_octets_binary.append(binary_octet.zfill(8))中的<strong>zfill(8)</strong>，它的作用是自动帮我们填充八位数的二进制数，什么意思呢？比如我们有个IP地址192.168.0.1，它的第三个八位组为0，写成二进制的话应该为00000000，如果我们将0用bin()转换成二进制后会怎么样呢？演示如下：</li></ul><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/32eb2a28b44a4effbab5689e6276ccd9><p class=pgc-img-caption></p></div><p>是不是只得到了一位数的二进制数0？加上zfill(8)后即得到八位组的二进制00000000，效果如下：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48368164e7f14273a6c00ec0bfe6d0ea><p class=pgc-img-caption></p></div><p>同样的代码也适用于子网掩码，比如在Python中要将255.255.255.0这个掩码转换成二进制形式，代码可以这么写：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/defb297de02d489196ed96a660a5b84c><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>B.</h1><p>知道如何在Python里将十进制的IP地址和子网掩码转换成二进制后，我们再来看下如何将二进制的IP地址和子网掩码转换回十进制（代码接续前文）：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aecc0235947a44edb0a787093628a1f6><p class=pgc-img-caption></p></div><ul><li>这里只讲一点，在Python中我们可以借助int()函数里的2这个参数将<strong>数据类型为字符串的二进制数字</strong>转换成<strong>数据类型为整数的十进制数字，</strong>举例如下：</li></ul><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6273178b930c4b97b6317a0864dde792><p class=pgc-img-caption></p></div><ul><li>同样的道理，我们可以将二进制形式的子网掩码转换回十进制：</li></ul><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/225ac92a0ea64c1eb6964dfa273e71af><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>C.</h1><p>我们知道要算出一个网段内有多少可用的IP地址需要知道该网段的子网掩码以二进制表达时里面有多少个0 （number of zeros，在Python中我们将其赋值给变量no_of_zeros)，然后套用公式2 ** no_of_zeros - 2即可算出，比如这里给定的子网掩码255.255.255.0，将其转化为二进制为1111111.1111111.11111111.00000000，总共8个0， 那么2**8-2 = 254，即为我们要的结果，这个运算过程在Python中的计算方式如下（代码接前文）：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d4881ed49bdf4a158ad27cd3296cdeab><p class=pgc-img-caption></p></div><ul><li>这里我们用abs()这个绝对值函数来计算有多少可用的IP地址，原因是当子网掩码为/32 (255.255.255.255）时，no_of_zeros = 0，如果不用abs()的话， 2 ** 0 - 2 结果为负1，用abs()则可以将其转换成正1， 演示如下：</li></ul><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9591ee8239114f05aa275146f88cad18><p class=pgc-img-caption></p></div><p><br></p><p><strong>D.</strong></p><p>我们知道网络IP和广播IP是两个很重要的概念，在给定一个IP地址及其子网掩码后，计算该网段的网络IP和广播IP的方法想必大家都知道，即将IP地址和子网掩码分别转换成二进制，然后将两者对比，看子网掩码的二进制有多少个1，那么IP地址的二进制就从左至右保留多少位，剩下的部分全部以0填充，即可得到网络IP的二进制地址，如果剩下部分全部以1填充，则得到广播IP的二进制地址（这里就不画图演示了，这些都是网工最最最基础的知识点，不懂的回去把CCENT或CCNA的书重新翻出来读）。下面我们在Python中演示如何实现找出一个指定IP所在网段的网络IP和广播IP（代码接前文，以前文给定的IP地址192.168.1.1和子网掩码255.255.255.0为例）：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ceb12428a7f4ccf88242cef144a894c><p class=pgc-img-caption></p></div><ul><li>在使用上面提到的填充0的方法得到了网络IP的二进制地址（11000000101010000000000100000000）后，为了将它转换成四个八位组的十进制形式，这里我们巧用for循环配合range(0,32,8)来将该网络IP的二进制地址切成四段，每段含8个二进制数字，作为元素被依次添加进net_ip_octets这个空列表，最后使用带参数2的int()函数将它们转换成十进制，然后再将这四个十进制数字作为元素依次添加进net_ip_address这个空列表，最后配合".".join()将给列表转化为字符串，即得到了网络IP：192.168.1.0</li></ul><p>依葫芦画瓢，从下面这段代码中我们又得到了广播IP: 192.168.1.255</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e59ac34dd8174f0f808d007939fe8e11><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>E.</h1><p>最后我们来谈谈反掩码，所谓反掩码就是将子网掩码的二进制里的1换成0，将0换成1，比如255.255.255.0的二进制为11111111.11111111.11111111.00000000，它的反掩码即为00000000.00000000.00000000.11111111，也就是0.0.0.255。在Python里我们可以这样表示（代码接上文）：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76071b5fae3f4d6cbd9d8741cca40269><p class=pgc-img-caption></p></div><p><br></p><p>最后来看下该交互式的网络和IP地址计算器的最终代码：</p><pre><code>#coding=utf-8import systry:    while True: #判断用户输入的IP是否符合规范，如果不规范则while循环反复询问，直到用户输入正确IP地址为止。        ip_address = input("输入要查询的IP地址: ")                  ip_octets = ip_address.split('.') #将IP地址用split()转换成列表，该列表有4个元素，分别代表用户输入的IP地址的4个8位字段。        #0.0.0.0/8, 127.0.0.0/8, 169.254.0.0/16以及Class D这些保留IP地址均不是有效的IP        if (len(ip_octets) == 4) and (1 &lt;= int(ip_octets[0]) &lt;= 223) and (int(ip_octets[0]) != 127) and (int(ip_octets[0]) != 169 or int(ip_octets[1]) != 254) and (0 &lt;= int(ip_octets[1]) &lt;= 255 and 0 &lt;= int(ip_octets[2]) &lt;= 255 and 0 &lt;= int(ip_octets[3]) &lt;= 255):            break        else:            print("\n不是有效的IP地址，请重新输入\n")            continue    masks = [255, 254, 252, 248, 240, 224, 192, 128, 0] #将所有有效的子网掩码的十进制数字归纳进一个列表，用于验证用户输入的子网掩码是否合乎规范    while True: #判断用户输入的子网掩码是否符合规范，如果不规范则while循环反复询问，直到用户输入正确子网掩码为止。        subnet_mask = input("输入子网掩码: ")                mask_octets = subnet_mask.split('.') #将子网掩码用split()转换成列表，该列表有4个元素，分别代表用户输入的子网掩码的4个8位字段。        #支持/0 - /32所有子网掩码        if (len(mask_octets) == 4) and (int(mask_octets[0]) in masks) and (int(mask_octets[1]) in masks) and (int(mask_octets[2]) in masks) and (int(mask_octets[3]) in masks) and (int(mask_octets[0]) &gt;= int(mask_octets[1]) &gt;= int(mask_octets[2]) &gt;= int(mask_octets[3])):            break        else:            print("\n不是有效的子网掩码，请重新输入\n")            continue    mask_octets_binary = []    for octet in mask_octets:        binary_octet = bin(int(octet)).lstrip('0b')        #print(binary_octet)        mask_octets_binary.append(binary_octet.zfill(8))    #print(mask_octets_binary)    binary_mask = "".join(mask_octets_binary)    #print(decimal_mask)       no_of_zeros = binary_mask.count("0")    no_of_ones = 32 - no_of_zeros    no_of_hosts = abs(2 ** no_of_zeros - 2) #当掩码为/32时，2的0次方减1等于-1，需要用abs()函数将其转换成正数1.    #print(no_of_zeros)    #print(no_of_ones)    #print(no_of_hosts)    wildcard_octets = []    for octet in mask_octets:        wild_octet = 255 - int(octet)        wildcard_octets.append(str(wild_octet))    #print(wildcard_octets)    wildcard_mask = ".".join(wildcard_octets)    #print(wildcard_mask)    ip_octets_binary = []    for octet in ip_octets:        binary_octet = bin(int(octet)).lstrip('0b')        #print(binary_octet)        ip_octets_binary.append(binary_octet.zfill(8))    #print(ip_octets_binary)    binary_ip = "".join(ip_octets_binary)    #print(binary_ip)       network_address_binary = binary_ip[:(no_of_ones)] + "0" * no_of_zeros    #print(network_address_binary)    broadcast_address_binary = binary_ip[:(no_of_ones)] + "1" * no_of_zeros    #print(broadcast_address_binary)    net_ip_octets = []    for bit in range(0, 32, 8):        net_ip_octet = network_address_binary[bit: bit + 8]        net_ip_octets.append(net_ip_octet)    #print(net_ip_octets)    net_ip_address = []    for each_octet in net_ip_octets:        net_ip_address.append(str(int(each_octet, 2)))    #print(net_ip_address)    network_address = ".".join(net_ip_address)    #print(network_address)    bst_ip_octets = []    for bit in range(0, 32, 8):        bst_ip_octet = broadcast_address_binary[bit: bit + 8]        bst_ip_octets.append(bst_ip_octet)    #print(bst_ip_octets)    bst_ip_address = []    for each_octet in bst_ip_octets:        bst_ip_address.append(str(int(each_octet, 2)))    #print(bst_ip_address)    broadcast_address = ".".join(bst_ip_address)    #print(broadcast_address)        print("\n")    print("该网段的网络地址为: %s" % network_address)    print("该网段的广播地址为: %s" % broadcast_address)    print("该网段可用的IP地址数量为: %s" % no_of_hosts)    print("反掩码: %s" % wildcard_mask)    print("掩码位: %s" % no_of_ones)    print("\n")    print(input())except KeyboardInterrupt:    print("\n\n程序终止\n")    sys.exit()</code></pre><ul><li>代码前面用来判断用户所输入的IP地址和子网掩码是否合法的部分，我已经在相应位置做了备注帮助大家理解，这里就不再赘述了。</li></ul><p>最后运行该程序看效果：</p><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8ae61a05c4474107ab1b97b1ecdd2500><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a66595c096dc4f4883eec0665047ec9b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=用Python开发一个交互式网络和IP地址计算器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f091fe655f843eebfb6c0a6abdbfa3e><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'算器','Python','开发'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>