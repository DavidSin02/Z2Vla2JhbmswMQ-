<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高屋建瓴：Java EE7全局概览及其标准构件模块架构组成 | 极客快訊</title><meta property="og:title" content="高屋建瓴：Java EE7全局概览及其标准构件模块架构组成 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/321b00037d975849bdaa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88b25579.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88b25579.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/88b25579.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88b25579.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88b25579.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/88b25579.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/88b25579.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/88b25579.html><meta property="article:published_time" content="2020-10-29T21:10:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:30+08:00"><meta name=Keywords content><meta name=description content="高屋建瓴：Java EE7全局概览及其标准构件模块架构组成"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/88b25579.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高屋建瓴：Java EE7全局概览及其标准构件模块架构组成</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>【<strong>写在前面的</strong><strong>一点废话</strong>】</p><p>企业如今生活在一个全球化竞争的世界，他们需要应用系统来满足他们的业务需求，这些需求越来越复杂。 在这个全球化时代，公司分布不同区域，他们通过互联网实现24*7的全天侯模式下跟不同国家进行业务往来。基于多个数据中心以及必须处理不同货币和时区的国际化系统，这样以便降低成本和降低服务的响应时间，并将业务数据存储在可靠和安全的存储上，同时为其客户、员工和供应商提供移动和Web方式的多种交互形式。</p><p>大多数公司必须将这些复杂的挑战与其现有的企业信息系统（EIS）相结合，同时开发企业对企业（Business to Business）应用程序，以便基于移动和地理定位模式的应用程序与合作伙伴或企业对客户系统进行通信沟通。 这样，公司不得不协调存储在不同位置的内部数据，由多种编程语言处理，并通过不同的协议进行路由。 当然，在无损失的情况下，企业必须这样做，这意味着分布系统具有防止系统崩溃、高可用性、可扩展性和安全性等特性，同时，企业应用必须面对变化和复杂性，并且应该系统必须是健壮的。 这正是Java企业版（Java EE）创建的原因所在。</p><p>于1999年发布的Java EE的第一个版本（最初称为J2EE）侧重于企业面临的问题：分布式组件。 从那时起，软件应用程序不得不适应新的技术解决方案，如SOAP或RESTful Web服务。Java EE平台已经发展到通过提供各种标准规范的方法来满足这些技术需求。 多年来，Java EE已经发生变化，变得更加丰富、更简单、更易于使用、更便携和更加集成化。</p><p>那么，在本学习教程中，我将给出一个Java EE的总体概述，介绍其内部架构，组件和服务后等，并介绍Java EE 7中的新功能特性。</p><h1>1Java EE 简史</h1><p>图1-0总结了14年的Java EE演进。 Java EE以前称为J2EE。 J2EE 1.2是由Sun开发的，并于1999年发布，包含10个JSR的总括规范。 当时人们总在在谈论CORBA，所以J2EE 1.2是在分布式系统的基础上创建的。引入了企业Java Bean（EJB），支持远程状态和无状态服务对象，并支持持久对象（实体bean）。 它们基于使用RMI-IIOP（远程方法调用 - Internet Inter-ORB协议）作为底层协议的事务和分布式组件模型构建。Web层有servlet和JavaServer Pages（JSP）技术，JMS用于发送消息之用。</p><p><img alt="高屋建瓴：Java EE7全局概览及其标准构件模块架构组成" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/321b00037d975849bdaa></p><p class=pgc-img-caption>图1-0 Java EE简史</p><p>由J2EE 1.3开始，该规范是由Java社区进程（JCP）根据JSR 58开发的。实体bean的支持是强制性的，EJB引入了XML部署描述符来存储元数据（在EJB 1.0中的一个文件中被序列化）。 该版本解决了使用远程接口通过值传递参数的开销，即通过引用本地接口并通过引用传递参数。 引入了J2EE连接器架构（JCA）来实现Java EE连接到EIS（企业信息系统）。<br></p><p>2003年发布的J2EE 1.4（JSR 151）在包含20个规范，并增加了对Web服务的支持。 EJB 2.1允许通过SOAP / HTTP调用会话bean。 创建定时服务以允许在指定的时间或间隔调用EJB。该版本为应用程序的装配和部署提供了更好的支持。 虽然它的支持者预测了它的伟大未来，但并不是所有的J2EE的承诺都实现了。使用它创建的系统太复杂，开发时间常常与用户需求的复杂性成正比。 J2EE被视为重量级组件模型：难以测试，难以部署，难以运行。 就在那时， Struts，Spring或Hibernate等框架出现并导引出开发企业应用程序的新方法。</p><p>幸运的是，2006年第二季度发布了Java EE 5（JSR 244），带来了显著的进步。 通过从开源框架中获得了一些灵感，引入POJO编程模型。可以使用注释定义元数据，并且XML描述符成为可选的。 从开发人员的角度来看，EJB 3和新的JPA比平台的演变更具有飞跃性。JavaServer Faces（JSF）作为标准的表示层框架被引入，JAX-WS 2.0将JAX-RPC替换为 SOAP Web服务API。</p><p>在2009年，Java EE 6（JSR 316）遵循开发的方便之路，在整个平台（包括Web层）中拥抱含注解、POJO编程和例外配置机制的概念。 它拥有丰富的创新，如全新的JAX-RS 1.1，Bean Validation 1.0和CDI 1.0; 它简化了成熟的API，如EJB 3.1，并丰富了其他的，如JPA 2.0或EJB定时器服务。 但是Java EE 6的主要主题是可移植性（例如通过标准化全局JNDI命名），某些规范（通过修剪）的弃用，以及通过配置文件创建平台的子集。</p><p>今天，Java EE 7带来了许多新的规范（批量处理，websockets，JSON处理）以及改进其他规范。 Java EE 7还通过在大多数规范中采用CDI来提高技术之间的集成。 有机会，将在教程中，我想向您展示这些改进，以及Java Enterprise Edition已经变得更加容易和丰富开发模式。</p><h1>2 全局理解Java EE 7</h1><p>当想处理对的集合时，无需从开发自己的哈希表开始——集合API（应用程序编程接口）就完全满足需要了。 同样，如果您需要一个简单的Web应用程序或支持事务、安全、可互操作和分布式的应用程序，则不需要开发所有低级API：企业版Java就满足需要。 正如Java标准版（Java SE）提供的处理集合的API一样，Java EE提供了一种标准的事务API方法来处理Java 事务，使用Java消息服务（JMS）进行消息传递，或者使用持久化 API（JPA）进行数据持久化。Java EE是针对企业应用程序的一组规范，它可以被看作是Java SE的扩展，以便于开发分布式、健壮的、强大的和高可用性的应用程序。</p><p>Java EE 7是一个重要的里程碑。不仅仅是遵循Java EE 6关注一个更简单的开发模式，而且还增加了新的规范，并为现有特性增加了新的功能。另外，上下文依赖注入（CDI）正在成为所有这些新规范之间的集成点。 Java EE 7的发布与企业平台发布十三周年紧密相连，将Java语言的优势与过去13年所获得的经验结合起来.Java EE从开源社区的活力中获益，同时也得益于严格的 JCP（Java Community Process）标准化进程。</p><p>今天，Java EE早已成为经过验证的优秀平台，其拥有经验丰富的开发人员、大型社区以及部署在公司服务器上运行着的诸多应用系统。Java EE是一套规范的APIs，可用于构建基于标准组件的多层应用程序,这些组件部署在提供一系列服务的不同容器中。</p><p>接下来，我们从不同层面理解掌握Java EE 7的不同总体构成。</p><h1><strong>2.1Java EE总体架构</strong></h1><p>Java EE是由不同容器实现的一组规范。容器是为其所托管的组件提供某些服务的Java EE运行时环境，例如生命周期管理，依赖注入，并发等。这些组件使用定义良好的规约与Java EE基础架构以及其他组件进行通信。在部署之前，需要以标准方式打包（按照定义的目录结构，可压缩到归档文件中）。注意，Java EE是Java SE平台的超集，这意味着Java SE API可以由任何Java EE组件使用。</p><p>图1-1显示了容器之间的逻辑关系。箭头表示一个容器访问另一个容器所使用的协议。 例如，Web容器托管可以通过RMI-IIOP访问EJB的servlet。</p><p><img alt="高屋建瓴：Java EE7全局概览及其标准构件模块架构组成" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/321b00037ed594cfdd96></p><p class=pgc-img-caption>图1-1 标准Java EE容器架构关系</p><h1><strong>2.2Java EE构件组成</strong></h1><p>Java EE运行时环境规范定义了Java EE“实现”（可以看作为中间件）必须支持的四种类型的构件：</p><ol class=list-paddingleft-2><li><p>²<strong>Applets</strong>：浏览器小程序是在Web浏览器中执行的GUI（图形用户界面）应用程序。它们使用丰富的Swing API来提供强大的用户界面。</p></li><li><p>²<strong>Applications</strong>：应用程序（PC独立应用程序）是在客户端上执行的程序。它们通常是可以访问Java EE中间层所有设施的GUI或批处理程序。</p></li><li><p>²<strong>Web Applications</strong>：Web应用程序（由servlet、servlet过滤器、Web事件侦听器、JSP和JSF页面组成）在Web容器中执行，并响应来自Web客户端的HTTP请求。 Servlet还支持SOAP和RESTful Web服务，Web应用程序还可以包含EJB精简版（EJBs Lite）.</p></li><li><p>²<strong>Enterprise Applications</strong><strong>：</strong>企业应用程序（由企业Java Bean、Java消息服务、Java事务API、异步调用、定时服务、RMI / IIOP等构成）在EJB容器中执行。EJBs是用于处理事务性业务逻辑的容器管理组件。它们可以被本地化访问和通过RMI（或SOAP for SOAP和RESTful Web服务）远程访问。</p></li></ol><h1><strong>2.3Java EE容器</strong></h1><p>Java EE基础架构被划分为称为容器的逻辑域（见图1-1）。每个容器都有一个特定的角色，支持一组API，并为组件提供服务（如安全性，数据库访问，事务处理，命名目录，资源注入等）。容器隐藏技术复杂性并增强可移植性。根据要构建的应用程序的类型，将须了解每个容器的功能和约束，以便使用一个或多个。例如，如果您需要开发一个Web应用，将开发具有EJB Lite层的JSF层，并将其部署到Web容器中。但是，如果您希望Web应用程序能远程调用业务层并使用消息传递和异步调用，那么您将需要Web和EJB容器。</p><p><strong>Java EE标准定义了四种不同的容器：</strong></p><ol class=list-paddingleft-2><li><p>²<strong>Applet containers</strong>：大多数Web浏览器提供Applet容器来执行applet组件。 当开发applets时，在容器提供安全的环境中，可以集中精力在应用程序的可视化方面。 小应用程序容器使用沙盒安全模型，其中“沙箱”中执行的代码不允许“在沙箱外活动”。这意味着该容器可防止下载到本地计算机的任何代码访问自由本地系统资源，例如进程或文件。</p></li><li><p>²<strong>Application client container</strong><strong>：</strong>应用程序客户机容器（ACC）包括一组Java类、库和其他文件等，用于为Java SE应用程序提供注入、完全管理、命名服务（这样的应用包括Swing应用、批处理或仅使用main（）方法的类等）。ACC使用RMI-IIOP和具有HTTP的Web容器（例如，用于Web服务）与EJB容器进行通信。</p></li><li><p>²<strong>Web container</strong><strong>：</strong>Web容器提供用于管理和执行Web组件（servlet，EJB Lite，JSP，过滤器，侦听器，JSF页面和Web服务）的底层服务。它负责实例化，初始化和调用servlet并支持HTTP和HTTPS 协议。它是用于将网页反馈到客户端浏览器。</p></li><li><p>²<strong>EJB container</strong><strong>：</strong>EJB容器负责管理包含Java EE应用程序的业务逻辑层的企业bean（会话bean和消息驱动的bean）的执行。它创建EJB的新实例，管理其生命周期，并提供诸如 事务，安全性，并发性，分发，命名服务或异步调用的可能性。</p></li></ol><h1><strong>2.4Java EE服务</strong></h1><p>容器为其部署的组件提供基础服务。 作为开发人员，容器允许您集中精力实施业务逻辑，而不是解决企业应用程序中面临的技术问题。图1-2显示了每个容器提供的服务。 例如，Web和EJB容器提供连接器来访问EIS，但不提供applet容器或ACC。Java EE提供以下服务：</p><ol class=list-paddingleft-2><li><p>²<strong>Java Transaction API</strong>：此服务提供容器和应用程序使用的事务分界API。 它还提供事务管理器和服务提供者接口（SPI）级别的资源管理器之间的接口。</p></li><li><p>²<strong>Java Persistence API</strong>：用于对象关系映射（ORM）的标准API。使用其持久性查询语言（JPQL），可以查询存储在底层数据库中的对象。</p></li><li><p>²<strong>Validation:</strong> Bean验证提供类和方法级约束声明和验证功能。</p></li><li><p>²<strong>Java</strong><strong>消息服务</strong>：这允许组件通过消息异步通信。它支持可靠的点对点（P2P）消息传递以及发布订阅（pub-sub）模型。</p></li><li><p>²<strong>Java</strong><strong>命名和目录接口</strong>：此API包含在Java SE中，用于访问命名和目录系统。应用程序使用此技术将名称与对象进行关联（绑定），然后在目录中查找这些对象（以lookup方式查找）。其可以查找对象包括数据源、JMS工厂、EJB和其他资源等。直到J2EE 1.4，无所不在的JNDI可以更透明的方式通过注入使用。</p></li><li><p>²<strong>JavaMail</strong><strong>：</strong>许多应用程序需要发送电子邮件的功能，可以通过使用JavaMail API来实现。</p></li><li><p>²<strong>JavaBeans</strong><strong>激活框架</strong>：Java SE中包含的JAF API提供了一种处理不同MIME类型的数据的框架。 它被JavaMail使用。</p></li><li><p>²<strong>XML</strong><strong>处理</strong>：大多数Java EE组件可以部署可选的XML部署描述符，应用程序通常必须处理XML文档。 Java XML处理API（JAXP）提供了对使用SAX和DOM以及XSLT解析文档的支持。XML流化API（StAX）为XML提供了一个”pull-parsing”(拉式)解析API。</p></li><li><p>²<strong>JSON</strong><strong>处理</strong>：Java EE 7中新增的JSON 处理API（JSON-P）允许应用程序解析、生成、转换和查询JSON。</p></li><li><p>²<strong>Java EE</strong><strong>连接器体系结构</strong>：连接器允许您从Java EE访问EIS，EIS可以是数据库，大型机或企业资源计划（ERP）程序等。</p></li><li><p>²<strong>安全服务</strong>：Java认证和授权服务（JAAS）使服务能够对用户进行身份验证和强制访问控制。 Java授权服务提供商规约（JACC）定义了Java EE应用程序服务器和授权服务提供商之间的约束，允许将自定义授权服务提供商插入到任何Java EE产品中。 容器的Java认证服务提供程序接口（JASPIC）定义了一个标准接口，通过该标准接口可以将认证模块集成到容器中，以便这些模块可以建立容器使用的认证标识。</p></li><li><p>²<strong>Web</strong><strong>服务</strong>：Java EE为SOAP和RESTful Web服务提供支持。用于XML Web服务的Java API（JAX-WS），提供了支持SOAP/HTTP协议的web服务（用于替代基于XML的RPC即JAX-RPC的API）。 RESTful服务API（JAX-RS）提供了对使用REST风格的Web服务的支持。</p></li><li><p>²<strong>依赖注入</strong>：自Java EE 5以来，可以将一些资源（数据源，JMS工厂，持久性单元，EJBs ...）注入到托管组件中。 Java EE 7通过使用CDI以及DI（Java的依赖注入）规范实现了对依赖注入的进一步应用扩展。</p></li><li><p>²<strong>管理</strong>：Java EE使用特殊的管理企业bean定义用于管理容器和服务器的API。 Java管理扩展（JMX）API也用于提供一些管理支持。</p></li><li><p>²<strong>部署</strong>：Java EE部署规范定义了部署工具和Java EE产品之间的规约，以标准化应用程序部署。</p></li></ol><p><img alt="高屋建瓴：Java EE7全局概览及其标准构件模块架构组成" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/320e000377d0d323de8b></p><p class=pgc-img-caption>图1-2 容器提供服务支持及关系图</p><h1><strong>2.5Java EE网络协议</strong></h1><p>如图1-2所示，部署在容器中的组件可以通过不同的协议进行调用。 例如，部署在Web容器中的servlet可以使用HTTP以及在EJB容器中部署EJB端点的Web服务来调用。 以下是Java EE支持的协议列表：</p><ol class=list-paddingleft-2><li><p>²<strong>HTTP</strong><strong>：</strong>HTTP是Web协议，在现代应用程序中是普遍存在的。客户端API由Java SE中的java.net包定义。HTTP服务器端API由servlet、JSP和JSF接口定义，就像SOAP和RESTful Web服务一样。</p></li><li><p>²<strong>HTTPS</strong>：HTTPS是HTTP和安全套接字层（SSL）协议的组合。</p></li><li><p>²<strong>RMI-IIOP</strong>：远程方法调用（RMI）允许您独立于底层协议调用远程对象。Java SE本机RMI协议是Java远程方法协议（JRMP）.RMI-IIOP是用于与CORBA集成的RMI的扩展 .Java界面描述语言（IDL）允许Java EE应用程序组件使用IIOP协议调用外部CORBA对象。 CORBA对象可以用许多语言（Ada，C，C ++，Cobol等）以及Java编写。</p></li></ol><h1><strong>2.6Java EE 打包</strong></h1><p>要部署在容器中，组件首先要封装在标准的格式化存档中。 Java SE定义了Java Archive（jar）文件，用于将多个文件（Java类，部署描述符，资源或外部库）聚合到一个压缩文件（基于ZIP格式）中。 如图1-3所示，Java EE定义了基于通用jar格式的具有自己的打包格式的不同类型的模块。</p><p><img alt="高屋建瓴：Java EE7全局概览及其标准构件模块架构组成" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/322d0001d488e286ff63></p><p class=pgc-img-caption>图1-3 容器中打包归档格式</p><p>针对上述归档模式，说明如下：</p><p>其一，应用程序客户端模块包含打包在jar文件中的Java类和其他资源文件。 该jar文件可以在Java SE环境或应用程序客户端容器中执行。 像任何其他存档格式一样，jar文件包含一个可选的META-INF目录，用于描述归档的元信息。 META-INF / MANIFEST.MF文件用于定义扩展和包相关数据。 如果部署在ACC中，则部署描述符可以可选地位于META-INF / application-client.xml。</p><p>其二，EJB模块包含打包在jar文件（通常称为EJB jar文件）中的一个或多个会话和/或消息驱动的bean（MDB）。 它包含一个可选的META-INF / ejb-jar.xml部署描述符，并且只能部署在EJB容器中。</p><p>其三，Web应用程序模块包含servlet，JSP，JSF页面和Web服务，以及任何其他Web相关文件（HTML和XHTML页面，级联样式表（CSS），Java脚本，图像，视频等）。 从Java EE 6以来，Web应用程序模块还可以包含EJB Lite bean（EJB API的一个子集）。所有这些工件都封装在带有.war扩展名（通常称为war文件或Web Archive）的jar文件中。可选Web部署描述符在WEB-INF / web.xml文件中定义。 如果war包含EJB Lite bean，则可以在WEB-INF / ejb-jar.xml中设置可选的部署描述符。 Java.class文件放置在WEB-INF / classes目录和依赖的jar文件的WEB-INF / lib目录下。</p><p>其四，企业模块可以包含零个或多个Web应用程序模块，零个或多个EJB模块以及其他常用或外部库。所有这些都被打包成企业归档（具有.ear扩展名的jar文件），以便各种部署模块协同进行并发。 可选的企业模块部署描述符在META-INF / application.xml文件中定义。特殊的lib目录用于在模块之间共享公共库。</p><h1><strong>2.7注解和部署描述符</strong></h1><p>在编程范例中，有两种方法：命令式编程和声明式编程。语法编程规定了实现目标的算法（必须做的事情），而声明式编程规定了如何实现这一目标（如何完成）。 在Java EE中，通过使用元数据（即注释或/和部署描述符）完成声明式编程。</p><p>如图1-2所示，组件在容器中运行，此容器为组件提供了一组服务.Metadata用于声明和自定义这些服务，并将附加信息与Java类、接口、构造函数、方法、字段或参数相关联 。</p><p>自从Java EE 5以来，注释在企业平台上一直在增长。它们使用元数据信息来修饰代码（Java类，接口，字段，方法...）。 清单1-1显示了一个POJO（普通Java对象），它使用类和属性上的注释来声明某些行为。</p><p>@Stateless</p><p>@Remote(ItemRemote.class)</p><p>@Local(ItemLocal.class)</p><p>@LocalBean</p><p>public class ItemEJB implements ItemLocal, ItemRemote {</p><p>@PersistenceContext(unitName = "chapter01PU")</p><p>private EntityManager em;</p><p>public Book findBookById(Long id) {</p><p>return em.find(Book.class, id);</p><p>}</p><p>}</p><p>代码清单1-1：注解式EJB</p><p>声明元数据的另一种方式是使用部署描述符。部署描述符（DD）是指与容器中组件一起部署的XML配置文件.Listing 1-2显示了一个EJB部署描述符。 像大多数Java EE 7部署描述符一样，它定义了http://xmlns.jcp.org/xml/ns/javaee命名空间，幷包含版本属性</p><p>规范。</p><p>&lt;ejb-jar xmlns="http://xmlns.jcp.org/xml/ns/javaee" </p><p>xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" </p><p>xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee </p><p>http://xmlns.jcp.org/xml/ns/javaee/ejb-jar_3_2.xsd" </p><p>version="3.2"></p><p>&lt;enterprise-beans></p><p>&lt;session></p><p>&lt;ejb-name>ItemEJB&lt;/ejb-name></p><p>&lt;remote>org.agoncal.book.javaee7.ItemRemote&lt;/remote></p><p>&lt;local>org.agoncal.book.javaee7.ItemLocal&lt;/local></p><p>&lt;local-bean/></p><p>&lt;ejb-class>org.agoncal.book.javaee7.ItemEJB&lt;/ejb-class></p><p>&lt;session-type>Stateless&lt;/session-type></p><p>&lt;transaction-type>Container&lt;/transaction-type></p><p>&lt;/session></p><p>&lt;/enterprise-beans></p><p>&lt;/ejb-jar></p><p>代码清单1-2：EJB部署描述符</p><p>部署描述符需要与特殊的META-INF或WEB-INF目录中的组件打包在一起，以备参考。 表1-1显示了Java EE部署描述符和相关规范的列表</p><p>表1-1：JavaEE部署描述列表</p><table class=border><tbody><tr class=firstRow><td>文件</td><td>规范</td><td>路径</td></tr><tr><td>application.xml</td><td>Java EE</td><td>META-INF</td></tr><tr><td>application-client.xml</td><td>Java EE</td><td>META-INF</td></tr><tr><td>beans.xml</td><td>CDI</td><td>META-INF or WEB-INF</td></tr><tr><td>ra.xml</td><td>JCA</td><td>META-INF</td></tr><tr><td>ejb-jar.xml</td><td>EJB</td><td>META-INF or WEB-INF</td></tr><tr><td>faces-config.xml</td><td>JSF</td><td>WEB -INF</td></tr><tr><td>persistence.xml</td><td>JPA</td><td>META-INF</td></tr><tr><td>validation.xml</td><td>Bean Validation</td><td>META-INF or WEB-INF</td></tr><tr><td>web.xml</td><td>Servlet</td><td>WEB-INF</td></tr><tr><td>web-fragment.xml</td><td>Servlet</td><td>WEB-INF</td></tr><tr><td>webservices.xml</td><td>SOAP Web Services</td><td>META-INF or WEB-INF</td></tr></tbody></table><p>由于Java EE 5大多数部署描述符是可选的，应用可以使用注释。或使用两者中对应用程序最好的方式即可。 注释的最大优点是它们显著减少了开发人员编写的代码量，并且通过使用注释可以避免编写部署描述符的需要。 另一方面，部署描述符是可以更改的外部XML文件，而不需要修改源代码和重新编译。 如果您同时使用这两者，当部署应用程序或组件时则元数据将被部署描述符覆盖（即XML优先于注释）。</p><h1><strong>2.8编程模型</strong></h1><p>大多数Java EE 7规范使用相同的编程模型。 它通常是一个POJO，它将一些元数据（注释或XML）部署到容器中。 大多数时候，POJO甚至没有实现一个接口或者扩展一个超类。 由于元数据，容器知道应用于此已部署组件的每一个服务。</p><p>在Java EE 7中，servlet，JSF支持bean，EJB，实体，SOAP和REST Web服务是带可选XML部署描述符的注释类。 清单1-3显示了一个JSF支持bean，证明是具有单个CDI注释的Java类。</p><p>清单1-3：JSF后端Bean</p><p>@Named</p><p>public class BookController {</p><p>@Inject</p><p>private BookEJB bookEJB;</p><p>private Book book = new Book();</p><p>private List&lt;Book> bookList = new ArrayList&lt;Book>();</p><p>public String doCreateBook() {</p><p>book = bookEJB.createBook(book);</p><p>bookList = bookEJB.findBooks();</p><p>return "listBooks.xhtml";</p><p>}</p><p>// Getters, setters</p><p>}</p><p>EJB也遵循相同的模式。 如清单1-4所示，如果您需要在本地访问EJB，则没有接口的简单注释类就足够了。 EJB也可以直接部署在war文件中，而不会先前封装在jar文件中。 这使EJB成为可以从简单的Web应用程序到复杂的企业应用程序使用的最简单的事务组件。</p><p>代码清单1-4：无状态EJB</p><p>@Stateless</p><p>public class BookEJB {</p><p>@Inject</p><p>private EntityManager em;</p><p>public Book findBookById(Long id) {</p><p>return em.find(Book.class, id);</p><p>}</p><p>public Book createBook(Book book) {</p><p>em.persist(book);</p><p>return book;</p><p>}</p><p>}</p><p>RESTful Web服务已经进入现代应用程序。 Java EE 7通过改进JAX-RS规范来满足企业的需求。 如清单1-5所示，一个RESTful Web服务是一个响应HTTP操作的带有注释的Java类。</p><p>代码清单1-5：RESTFUL web服务</p><p>@Path("books")</p><p>public class BookResource {</p><p>@Inject</p><p>private EntityManager em;</p><p>@GET</p><p>@Produces({"application/xml", "application/json"})</p><p>public List&lt;Book> getAllBooks() {</p><p>Query query = em.createNamedQuery("findAllBooks");</p><p>List&lt;Book> books = query.getResultList();</p><p>return books;</p><p>}</p><p>}</p><hr><p><strong>以上，希望对你总体把握和学习Java EE7有更好的引导和帮助。如果觉得有意义，请点这个赞、转发和收藏。谢谢^_^</strong></p><p><strong>另，这篇教程是在学习Java EE7时的理解和外文翻译，如有不妥的可以给我留言。</strong></p><p><strong>【学无止境，分享快乐】</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','EE7','概览'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>