<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JavaScript 进阶教程(1)--面向对象编程 | 极客快訊</title><meta property="og:title" content="JavaScript 进阶教程(1)--面向对象编程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/891f87f008614e3fb61e0c5721b13558"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8a18904e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8a18904e.html><meta property="article:published_time" content="2020-10-29T21:10:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:38+08:00"><meta name=Keywords content><meta name=description content="JavaScript 进阶教程(1)--面向对象编程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8a18904e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JavaScript 进阶教程(1)--面向对象编程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>1 学习目标</strong></h1><blockquote><p>理解面向对象开发思想</p><p>掌握 JavaScript 面向对象开发相关模式</p></blockquote><h1 class=pgc-h-arrow-right><strong>2 </strong>面向对象介绍</h1><div class=pgc-img><img alt="JavaScript 进阶教程(1)--面向对象编程" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/891f87f008614e3fb61e0c5721b13558><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.1 什么是对象</h1><blockquote><p>Everything is object （一切皆对象）</p></blockquote><div class=pgc-img><img alt="JavaScript 进阶教程(1)--面向对象编程" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/114d6b385bcf4a80a38c67ff5da0bc75><p class=pgc-img-caption></p></div><p style=text-align:start><strong>我们可以从两个层次来理解对象：</strong></p><p style=text-align:start><strong>(1) 对象是单个事物的抽象。</strong></p><p style=text-align:start>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p><p style=text-align:start><strong>(2) 对象是一个容器，封装了属性（property）和方法（method）。</strong></p><p style=text-align:start>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p><p style=text-align:start>在实际开发中，对象是一个抽象的概念，可以将其简单理解为：<strong>数据集或功能集</strong>。ECMAScript-262 把对象定义为：<strong>无序属性的集合，其属性可以包含基本值、对象或者函数</strong>。 严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都 映射到一个值。</p><blockquote><p>提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。</p></blockquote><h1 class=pgc-h-arrow-right><strong>2.2 什么是面向对象</strong></h1><blockquote><p>面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。</p></blockquote><div class=pgc-img><img alt="JavaScript 进阶教程(1)--面向对象编程" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eab0ca1b0c24037ba8a4f9c65da6a13><p class=pgc-img-caption></p></div><p style=text-align:start><strong>面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。 它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</strong></p><p style=text-align:start>在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接收信息、处理数据、发出信息等任务。 因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p><p style=text-align:start><strong>面向对象与面向过程区别：</strong></p><ul><li>面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊。</li><li>面向对象就是找一个对象，指挥得结果。</li><li>面向对象将执行者转变成指挥者。</li><li>面向对象不是面向过程的替代，而是面向过程的封装。</li></ul><p style=text-align:start><strong>面向对象的特性：</strong></p><ul><li>封装性</li><li>继承性</li><li>多态性</li></ul><p style=text-align:start>扩展阅读：</p><ul><li>知乎：什么是面向对象编程思想？</li></ul><h1 class=pgc-h-arrow-right><strong>2.3 JavaScript 中面向对象的基本体现</strong></h1><p style=text-align:start><strong>在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。 自定义的对象数据类型就是面向对象中的类（ Class ）的概念。</strong></p><p style=text-align:start>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。</p><p style=text-align:start>假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示：</p><pre><code>var std1 = { name: '张三', score: 98 }var std2 = { name: '李四', score: 81 }</code></pre><p style=text-align:start>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p><pre><code>function printScore (student) {  console.log('姓名：' + student.name + '  ' + '成绩：' + student.score)}</code></pre><p style=text-align:start>如果采用面向对象的程序设计思想，我们首先思考的不是程序的执行流程， 而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。 如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 printScore 消息，让对象自己把自己的数据打印出来。</p><p style=text-align:start>抽象数据行为模板（Class）：</p><pre><code>function Student (name, score) {  this.name = name  this.score = score} Student.prototype.printScore = function () {  console.log('姓名：' + this.name + '  ' + '成绩：' + this.score)}</code></pre><p style=text-align:start>根据模板创建具体实例对象（Instance）：</p><pre><code>var std1 = new Student('张三', 98)var std2 = new Student('李四', 81)</code></pre><p style=text-align:start>实例对象具有自己的具体行为（给对象发消息）：</p><pre><code>std1.printScore() // =&gt; 姓名：张三  成绩：98std2.printScore() // =&gt; 姓名：李四  成绩 81</code></pre><p style=text-align:start>面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。 Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念， 而实例（Instance）则是一个个具体的 Student ，比如， 张三 和 李四 是两个具体的 Student 。</p><p style=text-align:start><strong>面向对象的设计思想是：</strong></p><ul><li>抽象出 Class</li><li>根据 Class 创建 Instance</li><li>指挥 Instance 得结果</li></ul><p style=text-align:start>面向对象的抽象程度比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。</p><h1 class=pgc-h-arrow-right><strong>3 JavaScript 如何创建对象</strong></h1><h1 class=pgc-h-arrow-right><strong>3.1 字面量方式</strong></h1><p style=text-align:start>我们可以直接通过 new Object() 创建：</p><pre><code>var person = new Object()person.name = '张三'person.age = 18person.sayName = function () {  console.log(this.name)}</code></pre><p style=text-align:start>每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建：</p><pre><code>var person = {  name: '张三',  age: 18,  sayName: function () {    console.log(this.name)  }}</code></pre><p style=text-align:start>上面的写法是没有问题的，但是假如我们要生成两个 person 实例对象呢？</p><pre><code>var person1 = {  name: '张三',  age: 18,  sayName: function () {    console.log(this.name)  }}​var person2 = {  name: '李四',  age: 16,  sayName: function () {    console.log(this.name)  }}</code></pre><p style=text-align:start>通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。</p><h1 class=pgc-h-arrow-right><strong>3.2 简单方式的改进：工厂函数</strong></h1><p style=text-align:start>我们可以写一个函数，解决上边代码重复的问题：</p><pre><code>function createPerson (name, age) {  return {    name: name,    age: age,    sayName: function () {      console.log(this.name)    }  }}</code></pre><p style=text-align:start><strong>生成实例对象：</strong></p><pre><code>var p1 = createPerson('张三', 18)var p2 = createPerson('李四', 18)</code></pre><p style=text-align:start>这样封装比上边的方式好多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题， 但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p><h1 class=pgc-h-arrow-right><strong>3.3 更优雅的工厂函数：构造函数</strong></h1><p style=text-align:start>一种更优雅的工厂函数就是下面这样，构造函数：</p><pre><code>function Person (name, age) {  this.name = name  this.age = age  this.sayName = function () {    console.log(this.name)  }}​var p1 = new Person('张三', 18)p1.sayName() // =&gt; 张三​var p2 = new Person('李四', 23)p2.sayName() // =&gt; 李四</code></pre><p style=text-align:start>在上面的示例中，Person() 函数取代了 createPerson() 函数，但是实现效果是一样的。 这是为什么呢？</p><p style=text-align:start><strong>我们注意到，Person() 中的代码与 createPerson() 有以下几点不同之处：</strong></p><ol start=1><li>没有显示的创建对象</li><li>直接将属性和方法赋给了 this 对象</li><li>没有 return 语句</li><li>函数名使用的是大写的 Person</li></ol><h1 class=pgc-h-arrow-right><strong>3.4 构造函数代码执行过程</strong></h1><p style=text-align:start><strong>要创建 Person 实例，则必须使用 new 操作符。 以这种方式调用构造函数会经历以下 4 个步骤：</strong></p><ol start=1><li>创建一个新对象。</li><li>将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）。</li><li>执行构造函数中的代码。</li><li>返回新对象。</li></ol><p style=text-align:start>下面是具体的伪代码：</p><pre><code>function Person (name, age) {  // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象  // var instance = {}  // 然后让内部的 this 指向 instance 对象  // this = instance  // 接下来所有针对 this 的操作实际上操作的就是 instance​  this.name = name  this.age = age  this.sayName = function () {    console.log(this.name)  }​  // 在函数的结尾处会将 this 返回，也就是 instance  // return this}</code></pre><h1 class=pgc-h-arrow-right><strong>3.5 </strong>构造函数和实例对象的关系</h1><p style=text-align:start>使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。 在每一个实例对象中的_<em>proto_</em>中同时有一个 constructor 属性，该属性指向创建该实例的构造函数：</p><pre><code>console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true</code></pre><p style=text-align:start>对象的 constructor 属性最初是用来标识对象类型的， 但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些：</p><pre><code>console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true</code></pre><p style=text-align:start><strong>总结：</strong></p><p style=text-align:start>1 构造函数是根据具体的事物抽象出来的抽象模板。</p><p style=text-align:start>2 实例对象是根据抽象的构造函数模板得到的具体实例对象。</p><p style=text-align:start>3 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数。（ 此处constructor 是实例的属性的说法不严谨，具体后面的原型会讲到）</p><p style=text-align:start>4 可以通过实例的 constructor 属性判断实例和构造函数之间的关系。（这种方式不严谨，推荐使用 instanceof 操作符，后面学原型会解释为什么）</p><h1 class=pgc-h-arrow-right><strong>3.6 </strong>构造函数的问题</h1><p style=text-align:start>使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题：</p><pre><code>function Person (name, age) {  this.name = name  this.age = age  this.type = '学生'  this.sayHello = function () {    console.log('hello ' + this.name)  }}​var p1 = new Person('王五', 18)var p2 = new Person('李四', 16)</code></pre><p style=text-align:start>上边的代码，从表面看上好像没什么问题，但是实际上这样做，有一个很大的弊端。 那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容， 每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。</p><pre><code>console.log(p1.sayHello === p2.sayHello) // =&gt; false</code></pre><p style=text-align:start>对于这种问题我们可以把需要共享的函数定义到构造函数外部：</p><pre><code>function sayHello = function () {  console.log('hello ' + this.name)}​function Person (name, age) {  this.name = name  this.age = age  this.type = '学生'  this.sayHello = sayHello}​var p1 = new Person('王五', 18)var p2 = new Person('李四', 16)​console.log(p1.sayHello === p2.sayHello) // =&gt; true</code></pre><p style=text-align:start>这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。如何解决这个问题呢？你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题：</p><pre><code>var fns = {  sayHello: function () {    console.log('hello ' + this.name)  },  sayAge: function () {    console.log(this.age)  }}​function Person (name, age) {  this.name = name  this.age = age  this.type = '学生'  this.sayHello = fns.sayHello  this.sayAge = fns.sayAge}​var p1 = new Person('王五', 18)var p2 = new Person('李四', 16)​console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true</code></pre><p style=text-align:start>至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。 但是代码看起来还是那么的格格不入，那有没有更好的方式呢？</p><h1 class=pgc-h-arrow-right><strong>4</strong> 原型</h1><h1 class=pgc-h-arrow-right><strong>4.1 更好的解决方案： prototype</strong></h1><p style=text-align:start><strong>Javascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。 这个对象的所有属性和方法，都会被构造函数的实例继承。</strong></p><p style=text-align:start>这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。</p><pre><code>function Person (name, age) {  this.name = name  this.age = age}​console.log(Person.prototype)​Person.prototype.type = '学生'​Person.prototype.sayName = function () {  console.log(this.name)}​var p1 = new Person(...)var p2 = new Person(...)​console.log(p1.sayName === p2.sayName) // =&gt; true</code></pre><p style=text-align:start>这时所有实例的 <strong>type 属性和 sayName() 方法</strong>， 其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。</p><p><strong>构造函数、实例、原型三者之间的关系：</strong></p><div class=pgc-img><img alt="JavaScript 进阶教程(1)--面向对象编程" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/743a6f1e232d4ce099d2f4f8c96d64a6><p class=pgc-img-caption></p></div><p style=text-align:start></p><p style=text-align:start>任何函数都有一个 <strong>prototype </strong>属性，该属性是一个对象。</p><pre><code>function F () {}console.log(F.prototype) // =&gt; object​F.prototype.sayHi = function () {  console.log('hi!')}</code></pre><p style=text-align:start>构造函数的 <strong>prototype</strong> 对象默认都有一个<strong> constructor</strong> 属性，指向<strong> prototype</strong> 对象所在函数。</p><pre><code>console.log(F.constructor === F) // =&gt; true</code></pre><p style=text-align:start>通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。</p><pre><code>var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true</code></pre><p style=text-align:start><strong>`__proto__` 是非标准属性。</strong></p><p style=text-align:start>实例对象可以直接访问原型对象成员：</p><pre><code>instance.sayHi() // =&gt; hi!</code></pre><p style=text-align:start><strong>总结：</strong></p><ol start=1><li>任何函数都具有一个 prototype 属性，该属性是一个对象。</li><li>构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。</li><li>通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。</li><li>所有实例都直接或间接继承了原型对象的成员。</li></ol><h1 class=pgc-h-arrow-right><strong>4.2 属性成员的搜索原则：原型链</strong></h1><p style=text-align:start>了解了 <strong>构造函数-实例-原型对象</strong> 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。</p><p style=text-align:start><strong>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。</strong></p><ol start=1><li>搜索首先从对象实例本身开始。</li><li>如果在实例中找到了具有给定名字的属性，则返回该属性的值。</li><li>如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。</li><li>如果在原型对象中找到了这个属性，则返回该属性的值。</li></ol><p style=text-align:start><strong>也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索：</strong></p><ol start=1><li>首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。</li><li>然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。</li><li>于是，它就读取那个保存在原型对象中的函数。</li><li>当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。</li></ol><p style=text-align:start>这就是多个对象实例共享原型所保存的属性和方法的基本原理。</p><p style=text-align:start><strong>总结：</strong></p><ol start=1><li>先在自己身上找，找到即返回。</li><li>自己身上找不到，则沿着原型链向上查找，找到即返回。</li><li>如果一直到原型链的末端还没有找到，则返回 undefined。</li></ol><h1 class=pgc-h-arrow-right><strong>4.3 实例对象读写原型对象成员</strong></h1><p style=text-align:start><strong>读取：</strong></p><ol start=1><li>先在自己身上找，找到即返回。</li><li>自己身上找不到，则沿着原型链向上查找，找到即返回。</li><li>如果一直到原型链的末端还没有找到，则返回 undefined。</li></ol><p style=text-align:start><strong>值类型成员写入（实例对象.值类型成员 = xx）：</strong></p><ol start=1><li>当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上。</li><li>也就是说该行为实际上会屏蔽掉对原型对象成员的访问。</li></ol><p style=text-align:start><strong>引用类型成员写入（实例对象.引用类型成员 = xx）：</strong>同上。</p><p style=text-align:start><strong>复杂类型修改（实例对象.成员.xx = xx）：</strong></p><ol start=1><li>同样会先在自己身上找该成员，如果自己身上找到则直接修改。</li><li>如果自己身上找不到，则沿着原型链继续查找，如果找到则修改。</li><li>如果一直到原型链的末端还没有找到该成员，则报错（实例对象.undefined.xx = xx）。</li></ol><h1 class=pgc-h-arrow-right><strong>4.4 </strong>更简单的原型语法</h1><p style=text-align:start>我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。 <strong>为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象：</strong></p><pre><code>function Person (name, age) {  this.name = name  this.age = age}​Person.prototype = {  type: '学生',  sayHello: function () {    console.log('我叫' + this.name + '，我今年' + this.age + '岁了')  }}</code></pre><p style=text-align:start>在该示例中，我们将 Person.prototype 重置到了一个新的对象。 这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。</p><p style=text-align:start><strong>所以，我们为了保持 constructor 的指向正确，建议的写法是</strong>：</p><pre><code>function Person (name, age) {  this.name = name  this.age = age} Person.prototype = {  constructor: Person, // =&gt; 手动将 constructor 指向正确的构造函数  type: '学生',  sayHello: function () {    console.log('我叫' + this.name + '，我今年' + this.age + '岁了')  }}</code></pre><h1 class=pgc-h-arrow-right><strong>4.5 </strong>原生对象的原型</h1><p style=text-align:start>所有函数都有 prototype 属性对象。</p><blockquote><p>Object.prototypeFunction.prototypeArray.prototypeString.prototypeNumber.prototypeDate.prototype...</p></blockquote><p style=text-align:start>为数组对象和字符串对象扩展原型方法：</p><pre><code>//为内置对象添加原型方法//我们在系统的对象的原型中添加方法,相当于在改变源码//我希望字符串中有一个倒序字符串的方法String.prototype.myReverse = function() {	for (var i = this.length - 1; i &gt;= 0; i--) {		console.log(this[i]);	}};var str = "abcdefg";str.myReverse();  //为Array内置对象的原型对象中添加方法Array.prototype.mySort = function() {	for (var i = 0; i &lt; this.length - 1; i++) {		for (var j = 0; j &lt; this.length - 1 - i; j++) {			if (this[j] &lt; this[j + 1]) {				var temp = this[j];				this[j] = this[j + 1];				this[j + 1] = temp;			} //end if		} // end for	} //end for}; var arr = [100, 3, 56, 78, 23, 10];arr.mySort();console.log(arr);  String.prototype.sayHi = function() {	console.log(this + "哈哈,我又变帅了");}; //字符串就有了打招呼的方法var str2 = "小杨";str2.sayHi();</code></pre><h1 class=pgc-h-arrow-right><strong>4.6 </strong>原型对象的一些问题</h1><ul><li>共享数组</li><li>共享对象</li></ul><p style=text-align:start>如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则会出现问题。一个更好的建议是，最好不要让实例之间互相共享数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。</p><p style=text-align:start><strong>原型对象使用建议：</strong></p><ol start=1><li>私有成员（一般就是非函数成员）放到构造函数中。</li><li>共享成员（一般就是函数）放到原型对象中。</li><li>如果重置了 prototype 记得修正 constructor 的指向。</li></ol><p>转自：https://blog.csdn.net/qq_23853743/article/details/108034430?utm_medium=distribute.pc_feed.none-task-blog-personrec_tag-7.nonecase&depth_1-utm_source=distribute.pc_feed.none-task-blog-personrec_tag-7.nonecase&request_id=5f439671cea070620e93ed01</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JavaScript','进阶','--'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>