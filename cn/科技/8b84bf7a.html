<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>CC++语言21｜函数模板与类模板 | 极客快訊</title><meta property="og:title" content="CC++语言21｜函数模板与类模板 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8b84bf7a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8b84bf7a.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="CC++语言21｜函数模板与类模板"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8b84bf7a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>CC++语言21｜函数模板与类模板</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>C++是一种强类型语言，它要求程序中每一个对象的类型在编译阶段就能确定。一方面，这可以在很大程度上保证程序不会出现因类型问题而导致的错误。但另一方面，这种对类型的强力约束也限制了编码的灵活性，并且有可能导致编码效率的低下。泛型编程技术的引入使得两方面得到 了很好的平衡。</p><p>C++语言中有函数重载（overload）的功用，可以让相同功能（相同函数名）的函数处理不同的数据类型：</p><pre>#include &lt;iostream&gt;using namespace std;int adder(int a, int b){	return a+b;}double adder(double a, double b) //重载adder(){	return a+b;}void main(){	cout&lt;&lt;adder(3,4)&lt;&lt;endl;	cout&lt;&lt;adder(3.3,4.4)&lt;&lt;endl;	 system("pause");}/*77.7*/</pre><p>不过这样还是会造成程序代码重复（函数体重复）的问题，这时就可以使用模板。所谓模板就是以相同程序代码处理不同数据类型的函数或类，在模板中以参数来代替数据类型（类型泛化），如此一来，就能在使用模板时，再设置数据类型来取代参数，产生一个新的函数或类。</p><p>模板根据不同的应用，分为函数模板（function template）和类模板（class tmeplate）：</p><h1><strong>1 函数模板</strong></h1><p>函数模板就是函数中的某个参数或返回值的类型是不确定的，是可变的，这些不确定的类型称为模板参数。如果给函数模板的模板参数指定了一个具体的类型，就得到了一个可以执行的函数，这个函数称为模板函数。函数模板可以节省程序员的工作量，若干个被处理的数据类型不同，但处理流程完全一样的函数可以写成一个函数模板。</p><pre>函数模板是指在函数声明之前加上模板的声明，如此一来，就能以相同的函数，使用不同的数据类型。</pre><p>函数模板的原型为：</p><pre>template &lt;数据类型参数表&gt; 返回值类型 函数名(参数表){}template &lt;class T, class U&gt; U func(T a, int b, U c){;}//class也可以用typename代替</pre><p>一般的写法：</p><pre>template &lt;class 模板参数行&gt;返回数据类型 函数名称(参数行){ 定义函数模板 return 返回值;}template &lt;class T&gt;void swap(T* a, T* b) //可以是T{ ...}</pre><p>实例1：</p><pre>#include &lt;cstdio&gt;#include &lt;cstdlib&gt;template&lt;class T&gt;T add(T m, T n){	return m + n;}int main(){	float i;	i = add&lt;float&gt;(4.1, 7);	printf("%f\n",i);	system("pause");	return 0;}//11.100000</pre><p>实例2</p><pre>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;template&lt;typename T&gt;T max(const T arr[], int size) {	T maxElem=arr[0];	for (int i=0;i&lt;size;i++)		if(arr[i]&gt;maxElem) maxElem=arr[i];		return maxElem;}int main(){	int a[] = {1,2,4,8,7};	int b = max(a,sizeof(a)/sizeof(int));	printf("最大数组元素：%d",b);	system("pause");	return 0;}//最大数组元素：8//函数模板也可显示实例化：template int max&lt;int&gt;(const int[],int);</pre><p>实例3：函数模板重载：</p><pre>#include &lt;iostream&gt;using namespace std;template&lt;class T&gt; T add(T a, T b)//模板加法函数{	return a+b;}template&lt;class T&gt; T add(T a, T b, T c)//重载模板加法函数{	return a+b+c;}void main(){	cout&lt;&lt;add(1,2)&lt;&lt;endl;//整型加法	cout&lt;&lt;add(1.2,3.4,4.5)&lt;&lt;endl;//浮点加法}</pre><h1><strong>2 类模板</strong></h1><p>类模板是先声明模板，将数据类型以模板参数取代，就可以在使用时才指定数据类型。</p><pre>template &lt;class 模板参数行&gt;class 类名称{ 定义类模板}</pre><p>类模板可以实例化成一个类，一个类才可以实例化成一个具体的对象。</p><p>类模板的产生对象的方式：</p><pre>类名称&lt;数据类型&gt; 对象名称; //声明一般对象</pre><p>或</p><pre>类名称&lt;数据类型&gt; 对象名称(); //此对象名称为对象和构造函数的合并声明</pre><p>在C++14之前的版本中，模板可以是函数模板或类模板。C++14还也可以创建变量模板。模板的一般规则，包括特化都适用于变量模板的声明和定义。</p><p>实例：</p><pre>#include &lt;iostream&gt;using namespace std;template &lt;class T&gt;class ptr{private:	T *ip;//指针public:	ptr(T *p);	~ptr();};template &lt;class T&gt;ptr&lt;T&gt;::ptr(T *p){	ip=p;//初始化	cout&lt;&lt;"调用指针管理类构造函数"&lt;&lt;endl;}template &lt;class T&gt;ptr&lt;T&gt;::~ptr(){	ip=NULL;//释放	cout&lt;&lt;"指针管理类析构函数被调用"&lt;&lt;endl;}void main(){	int a=10;//自定义变量a	int b;	{		ptr&lt;int&gt; p(&amp;b);//自定义指针类对象	}//超出作用域自动析构，释放指针	system("pause");}/*调用指针管理类构造函数指针管理类析构函数被调用*/</pre><p>实例2：</p><pre>template &lt;typename T1=int, typename T2=double&gt;class HoldsPair{private: T1 value1; T2 value2;public: HoldsPair(const T1&amp; val1, const T2&amp; val2) // constructor : value1(val1), value2(val2) {}  // Accessor functions const T1 &amp; GetFirstValue () const  { return value1; } const T2&amp; GetSecondValue () const { return value2; }}; #include &lt;iostream&gt;using namespace std;int main (){ HoldsPair &lt;&gt; pairIntDbl (300, 10.09); HoldsPair &lt;short, const char*&gt; pairShortStr(25, "Learn templates, love C++"); cout &lt;&lt; "The first object contains -" &lt;&lt; endl; cout &lt;&lt; "Value 1: " &lt;&lt; pairIntDbl.GetFirstValue () &lt;&lt; endl; cout &lt;&lt; "Value 2: " &lt;&lt; pairIntDbl.GetSecondValue () &lt;&lt; endl; cout &lt;&lt; "The second object contains -" &lt;&lt; endl;  cout &lt;&lt; "Value 1: " &lt;&lt; pairShortStr.GetFirstValue () &lt;&lt; endl; cout &lt;&lt; "Value 2: " &lt;&lt; pairShortStr.GetSecondValue () &lt;&lt; endl;	system("pause"); return 0;}/*The first object contains -Value 1: 300Value 2: 10.09The second object contains -Value 1: 25Value 2: Learn templates, love C++*/</pre><h1><strong>3 相关问题</strong></h1><p>3.1 什么是模板的实例化？</p><p>类模板只是个设计图纸，不是一个真正的类。要使得类模板变成一个真正的类，必须用真正的类型名或常量替换类模板的形式参数。这个过程称为类模板的实例化。实例化后，类模板成为了一个真正的类，可以定义这个类的对象了。</p><p>3.2 为什么要定义模板？定义类模板有什么好处？</p><p>有了类模板，可以将一组功能类似、存储方式也类似的类定义成一个类模板，可以进一步减少程序员的工作量。</p><p>3.3 同样是模板，为什么函数模板的使用与普通的函数完全一样，而类模板在使用时还必须被实例化？</p><p>在函数模板中，如果模板的形式参数出现在函数形式参数表中，那么当函数调用时，编译器可以根据函数的实际参数的类型确定模板的实际参数，然后对函数模板进行实例化。在定义类模板的对象时，无法确定模板形式参数对应的实际参数值，因此只能在程序中<strong>显式地指出模板实际参数的值</strong>。</p><p>函数模板在调用时中，会有赋值操作，而类模板对象时，没有涉及到这样的赋值操作，所以要显示指定类型，就像基本数据类型的定义或类实例化一样，前面要有类型信息。</p><p>函数模板的类型可以通过函数调用进行推断。</p><p>3.4 什么时候需要用到类模板的声明？为什么？</p><p>一般来说，当定义一个类模板是另一个类模板的友元时必须要用到类模板的声明。当类模板A声明类模板B是它的友元时，编译器必须知道有这样的一个类模板B存在。如果类模板B的定义出现在类模板A的定义前面，则没有问题。但如果类模板B定义在类模板A后面时，编译器就不知道B是什么，也无法确定类模板A中对类模板B的名是否合法，这时可以通过类模板的声明来告诉编译器B是一个类模板。</p><p>3.5 类模板继承时的语法与普通的类继承有什么不同？</p><p>类模板继承时，凡是涉及到基类的地方，都必须在基类名后面跟上模板的形式参数名。即：基类名&lt;形式参数1，形式参数2，……>。</p><p>3.6 定义了一个类模板，在编译通过后为什么还不能确保类模板的语法是正确的？</p><p>由于类模板包含有模板参数，这些模板参数对应的实际参数在编译时尚未确定，所以编译器无法确定那些类型为模板参数的数据或函数的用法是否正确，只好暂时不检查。</p><p>－End－</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'模板','C++','语言'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>