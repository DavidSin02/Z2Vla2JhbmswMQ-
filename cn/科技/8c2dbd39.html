<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ | 极客快訊</title><meta property="og:title" content="「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/bd78fffbaaf54bd79c6e463d5b69ed9f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8c2dbd39.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8c2dbd39.html><meta property="article:published_time" content="2020-11-14T21:06:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:12+08:00"><meta name=Keywords content><meta name=description content="「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8c2dbd39.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在分布式系统，尤其是微服务系统中，一次外部请求往往需要内部多个模块，多个中间件，多台机器的相互调用才能完成。在这一系列的调用中，可能有些是串行的，而有些是并行的。在这种情况下，我们如何才能确定这整个请求调用了哪些应用？哪些模块？哪些节点？以及它们的先后顺序和各部分的性能如何呢？</p><p>这就是涉及到链路追踪。</p><h1>什么是链路追踪？</h1><p>链路追踪是分布式系统下的一个概念，它的目的就是要解决上面所提出的问题，也就是将一次分布式请求还原成调用链路，将一次分布式请求的调用情况集中展示，比如，各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bd78fffbaaf54bd79c6e463d5b69ed9f></div><h1>链路追踪的原理</h1><p>衡量一个接口，我们一般会看三个指标：</p><ol><li>接口的 RT（Route-Target）你怎么知道?</li><li>接口是否有异常响应?</li><li>接口请求慢在哪里?</li></ol><p><strong>1、单体架构时代</strong></p><p>在创业初期，我们的系统一般是单体架构，如下：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bede1ea671d84203ade268f8562d2f94></div><p>对於单体架构，我们可以使用 AOP（切面编程）来统计这三个指标，如下：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/73a71704eee24a4e9acfd648e6b355e9></div><p>使用 AOP（切面编程），对原本的逻辑代码侵入更少，我们只需要在调用具体的业务逻辑前后分别打印一下时间即可计算出整体的调用时间。另外，使用 AOP（切面编程）来捕获异常也可知道是哪里的调用导致的异常。</p><p><strong>2、微服务架构</strong></p><p>随着业务的快速发展，单体架构越来越不能满足需要，我们的系统慢慢会朝微服务架构发展，如下：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/25043195c5784ec29ad2e1ad8c41845d><p class=pgc-img-caption>一个稍微复杂的微服务架构</p></div><p>在微服务价格下，当有用户反馈某个页面很慢时，虽然我们知道这个请求可能的调用链是 A -----> C -----> B -----> D，但服务这么多，而且每个服务都有好几台机器，怎么知道问题具体出在哪个服务？哪台机器呢？</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/adffd61c42dc4cb7b4c23a02d0ac5678></div><p>这也是微服务这种架构下的几个痛点：</p><ol><li>排查问题难度大，周期长</li><li>特定场景难复现</li><li>系统性能瓶颈分析较难</li></ol><p>分布式调用链就是为了解决以上几个问题而生，它主要的作用如下：</p><ol><li>自动采取数据</li><li>分析数据，产生完整调用链：有了请求的完整调用链，问题有很大概率可复现</li><li>数据可视化：每个组件的性能可视化，能帮助我们很好地定位系统的瓶颈，及时找出问题所在</li></ol><p>通过分布式追踪系统，我们能很好地定位请求的每条具体请求链路，从而轻易地实现请求链路追踪，进而定位和分析每个模块的性能瓶颈。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5d172ee73ee54365b020eb72a4924f51></div><p><strong>3、分布式调用链标准（OpenTracing）</strong></p><p>OpenTracing 是一个轻量级的标准化层，它位于应用程序/类库和追踪或日志分析程序之间。它的出现是为了解决不同的分布式追踪系统 API 不兼容的问题。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/413bdb9d43294312a0bf72c1da5d5288></div><p>OpenTracing 通过提供与平台和厂商无关的 API，使得开发人员能够方便地添加追踪系统，就像单体架构下的AOP（切面编程）一样。</p><p>说到这里，大家是否想过 Java 中类似的实现？还记得 JDBC 吧？JDBC 就是通过提供一套标准的接口让各个厂商去实现，程序员即可面对接口编程，不用关心具体的实现。这里的接口其实就是标准。所以，制定一套标准非常重要，可以实现组件的可插拔。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a511fdd67f1b44b19b01a577e4499a2f></div><p>OpenTracing 的数据模型，主要有以下三个：</p><ul><li><strong>Trace</strong>：一个完整请求链路</li><li><strong>Span</strong>：一次调用过程（需要有开始时间和结束时间）</li><li><strong>SpanContext</strong>：Trace 的全局上下文信息，如里面有traceId</li></ul><p>为了让大家更好地理解这三个概念，我特意画了一张图：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/25ca7711afd74fbfa08c4be0bb007b52></div><p>如图所示，一次下单的完整请求就是一个 Trace。TraceId是这个请求的全局标识。内部的每一次调用就称为一个 Span，每个 Span 都要带上全局的 TraceId，这样才可把全局 TraceId 与每个调用关联起来。这个 TraceId 是通过 SpanContext 传输的，既然要传输，显然都要遵循协议来调用。如图所示，如果我们把传输协议比作车，把 SpanContext 比作货，把 Span 比作路应该会更好理解一些。</p><p>理解了这三个概念，接下来我们就看看分布式追踪系统是如何采集图中的微服务调用链。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/883eeb5e59db4792b92d508939048f56></div><p>我们可以看到底层有一个 Collector 一直在默默无闻地收集数据，那么每一次调用 Collector 会收集哪些信息呢。</p><ol><li>全局 trace_id：这是显然的，这样才能把每一个子调用与最初的请求关联起来</li><li>span_id: 图中的 0，1，1.1，2，这样就能标识是哪一个调用</li><li>parent_span_id：比如 b 调用 d 的 span_id 是 1.1，那么它的 parent_span_id 即为 a 调用 b 的 span_id 即 1，这样才能把两个<strong>紧邻的调用</strong>关联起来。</li></ol><p>有了这些信息，Collector 收集的每次调用的信息如下：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b23b268bd6524213801bdde3a563759b></div><p>根据这些图表信息显然可以据此来画出调用链的可视化视图如下：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/74918584e98f42dcac3e6ae1f14cc6f6></div><p>于是一个完整的分布式追踪系统就实现了。</p><p>以上实现看起来确实简单，但有以下几个问题需要我们仔细思考一下：</p><ol><li>怎么自动采集 span 数据：自动采集，对业务代码无侵入</li><li>如何跨进程传递 context</li><li>traceId 如何保证全局唯一</li><li>请求量这么多采集会不会影响性能</li></ol><p>接下来，我们来看看链路追踪系统 SkyWalking 是如何解决以上四个问题的。</p><h1>链路追踪系统SkyWalking的原理</h1><p><strong>1、怎么自动采集 span 数据</strong></p><p>SkyWalking 采用了插件化 + javaagent 的形式来实现了 span 数据的自动采集，这样可以做到对代码的无侵入性。插件化意味着可插拔，扩展性好。如下图所示：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0ca0a9f73aa24a08bf5d902ef73e14ad></div><p><strong>2、如何跨进程传递 context</strong></p><p>我们知道数据一般分为 header 和 body，就像 http 有 header 和 body，RocketMQ 也有 MessageHeader，Message Body。body 一般放着业务数据，所以不宜在 body 中传递 context，应该在 header 中传递 context，如图所示：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7e97b184053f4821b79ba5c828b2bc25></div><p>dubbo 中的 attachment 就相当于 header，所以我们把 context 放在 attachment 中，这样就解决了 context 的传递问题。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e88109bd52f2452ebdc28180b94e503f></div><p><strong>3、traceId 如何保证全局唯一</strong></p><p>要保证全局唯一 ，我们可以采用分布式或者本地生成的 ID。使用分布式的话，需要有一个发号器，每次请求都要先请求一下发号器，会有一次网络调用的开销。所以 SkyWalking 最终采用了本地生成 ID 的方式，它采用了大名鼎鼎的 snowflow 算法，性能很高。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/109367a8ba5247d188bcf96e0a974ffd><p class=pgc-img-caption>snowflake 算法生成的 id</p></div><p>不过 snowflake 算法有一个众所周知的问题：<strong>时间回拨</strong>，这个问题可能会导致生成的 id 重复。那么 SkyWalking 是如何解决时间回拨问题的呢。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca864f7dac854eacb29859aa343cdf07></div><p>每生成一个 id，都会记录一下生成 id 的时间（lastTimestamp），如果发现当前时间比上一次生成 id 的时间（lastTimestamp）还小，那说明发生了时间回拨，此时会生成一个随机数来作为 traceId。这里可能就有同学要较真了，可能会觉得生成的这个随机数也会和已生成的全局 id 重复，是否再加一层校验会好点。</p><p>这里要说一下系统设计上的方案取舍问题了，首先如果针对产生的这个随机数作唯一性校验无疑会多一层调用，会有一定的性能损耗，但其实时间回拨发生的概率很小（发生之后由于机器时间紊乱，业务会受到很大影响，所以机器时间的调整必然要慎之又慎），再加上生成的随机数重合的概率也很小，综合考虑这里确实没有必要再加一层全局唯一性校验。对于技术方案的选型，一定要避免过度设计，过犹不及。</p><p><strong>4、请求量这么多，全部采集会不会影响性能?</strong></p><p>如果对每个请求调用都采集，那毫无疑问数据量会非常大，但反过来想一下，是否真的有必要对每个请求都采集呢？其实没有必要，我们可以设置采样频率，只采样部分数据，SkyWalking 默认设置了 3 秒采样 3 次，其余请求不采样，如图所示：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/acaefd444ef64cf2ae9fb4e7281794d0></div><p>这样的采样频率其实足够我们分析组件的性能了，按 3 秒采样 3 次，这样的频率来采样数据会有啥问题呢。理想情况下，每个服务调用都在同一个时间点，这样的话每次都在同一时间点采样确实没问题。如下图所示：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae5dbab476184d96943e22e15a7c1c53></div><p>但在生产上，每次服务调用基本不可能都在同一时间点调用，因为期间有网络调用延时等，实际调用情况很可能是下图这样：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04a453b4cc5845f59632886cd79e20f3></div><p>这样的话就会导致某些调用在服务 A 上被采样了，在服务 B，C 上不被采样，也就没法分析调用链的性能。</p><p>那么 SkyWalking 是如何解决的呢？</p><p>它是这样解决的：如果上游有携带 Context 过来（说明上游采样了），则下游将强制采集数据，这样可以保证链路完整。</p><h1>SkyWalking 的基础架构</h1><p>SkyWalking 的基础如下架构，可以说几乎所有的的分布式调用都是由以下几个组件组成的。</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/505c03bd0c91408590732a4ab8a1ecdb></div><p>首先当然是节点数据的定时采样，采样后将数据定时上报，将其存储到 ES, MySQL 等持久化层，有了数据自然而然可根据数据做可视化分析。</p><h1>SkyWalking 的性能如何</h1><p>如下是官方的测评数据：</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/171074af07af4280a0f298c39bc40574></div><p>图中蓝色代表未使用 SkyWalking 的表现，橙色代表使用了 SkyWalking 的表现，以上是在 TPS 为 5000 的情况下测出的数据，可以看出，不论是 CPU，内存，还是响应时间，使用 SkyWalking 带来的性能损耗几乎可以忽略不计。</p><p>接下来我们再来看 SkyWalking 与另一款业界比较知名的分布式追踪工具 Zipkin、Pinpoint 的对比（在采样率为 1 秒 1 个，线程数 500，请求总数为 5000 的情况下做的对比）。</p><p>可以看到在关键的响应时间上， Zipkin（117ms），PinPoint（201ms）远逊于 SkyWalking（22ms）！从性能损耗这个指标上看，SkyWalking 完胜！</p><div class=pgc-img><img alt=「系统架构」什么是链路追踪？分布式系统如何实现链路追踪？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fdd94b95b2f7469a8b39ed953cc7f833></div><p>再看下另一个指标：对代码的侵入性如何。</p><p>ZipKin 是需要在应用程序中埋点的，对代码的侵入强，而 SkyWalking 采用 javaagent + 插件化这种修改字节码的方式可以做到对代码无任何侵入。除了性能和对代码的侵入性上 SkyWaking 表现不错外，它还有以下优势几个优势：</p><ul><li>对多语言的支持，组件丰富：目前其支持 Java、 .Net Core、PHP、NodeJS、Golang、LUA 语言，组件上也支持dubbo, mysql 等常见组件，大部分能满足我们的需求。</li><li>扩展性：对于不满足的插件，我们按照 SkyWalking 的规则手动写一个即可，新实现的插件对代码无入侵。</li></ul><p>以上虽然主要以SkyWalking为例来介绍链路追踪系统，但是并不是说其他链路追踪系统一点不适用。具体选择什么样的，大家可按实际场景灵活选择。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'系统','链路','架构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>