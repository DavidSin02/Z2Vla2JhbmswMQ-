<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「正点原子STM32Mini板资料连载」第十二章 定时器中断实验 | 极客快訊</title><meta property="og:title" content="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5856d59cc4974cb9aa41181fb439c28c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8e6b468.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8e6b468.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8e6b468.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「正点原子STM32Mini板资料连载」第十二章 定时器中断实验</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1）实验平台：正点原子stm32mini 开发板</p><p>2）<strong>摘自《正点原子STM32 不完全手册(HAL 库版)》</strong>关注官方微信号公众号，获取更多资料：正点原子</p><div class=pgc-img><img alt="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5856d59cc4974cb9aa41181fb439c28c><p class=pgc-img-caption></p></div><p><strong>第十二章 定时器中断实验</strong></p><p>这一章，我们将向大家介绍如何使用 STM32 的通用定时器，STM32 的定时器功能十分强</p><p>大，有 TIME1 和 TIME8 等高级定时器，也有 TIME2~TIME5 等通用定时器，还有 TIME6 和</p><p>TIME7 等基本定时器。在《STM32 参考手册》里面，定时器的介绍占了 1/5 的篇幅，足见其重</p><p>要性。在本章中，我们将使用 TIM3 的定时器中断来控制 DS1 的翻转，在主函数用 DS0 的翻转</p><p>来提示程序正在运行。本章，我们选择难度适中的通用定时器来介绍，本章将分为如下几个部</p><p>分：</p><p>12.1 STM32 通用定时器简介</p><p>12.2 硬件设计</p><p>12.3 软件设计</p><p>12.4 下载验证</p><p><strong>12.1 STM32 通用定时器简介</strong></p><p>STM32 的通用定时器是一个通过可编程预分频器（PSC）驱动的 16 位自动装载计数器（CNT）</p><p>构成。STM32 的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波</p><p>形(输出比较和 PWM)等。 使用定时器预分频器和 RCC 时钟控制器预分频器，脉冲长度和波形</p><p>周期可以在几个微秒到几个毫秒间调整。STM32 的每个通用定时器都是完全独立的，没有互相</p><p>共享的任何资源。</p><p>STM3 的通用 TIMx (TIM2、TIM3、TIM4 和 TIM5)定时器功能包括：</p><p>1)16 位向上、向下、向上/向下自动装载计数器（TIMx_CNT）。</p><p>2)16 位可编程(可以实时修改)预分频器(TIMx_PSC)，计数器时钟频率的分频系数为 1～</p><p>65535 之间的任意数值。</p><p>3）4 个独立通道（TIMx_CH1~4），这些通道可以用来作为：</p><p>A．输入捕获</p><p>B．输出比较</p><p>C．PWM 生成(边缘或中间对齐模式)</p><p>D．单脉冲模式输出</p><p>4）可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用 1 个定时器控制另外</p><p>一个定时器）的同步电路。</p><p>5）如下事件发生时产生中断/DMA：</p><p>A．更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</p><p>B．触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</p><p>C．输入捕获</p><p>D．输出比较</p><p>E．支持针对定位的增量(正交)编码器和霍尔传感器电路</p><p>F．触发输入作为外部时钟或者按周期的电流管理</p><p>由于 STM32 通用定时器比较复杂，这里我们不再多介绍，请大家直接参考《STM32 参考</p><p>手册》第 253 页，通用定时器一章。下面我们介绍一下与我们这章的实验密切相关的几个通用</p><p>定时器的寄存器。</p><p>首先是控制寄存器 1（TIMx_CR1），该寄存器的各位描述如图 12.1.1 所示：</p><p><br></p><div class=pgc-img><img alt="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee8d1ce9a54f46348c8561a3aeedd7d8><p class=pgc-img-caption>图 12.1.1 TIMx_CR1 寄存器各位描述</p></div><p>在本实验中，我们只用到了 TIMx_CR1 的最低位（位 0），也就是计数器使能位，该位必须</p><p>置 1，才能让定时器开始计数。接下来介绍第二个与我们这章密切相关的寄存器：DMA/中断使</p><p>能寄存器（TIMx_DIER）。该寄存器是一个 16 位的寄存器，其各位描述如图 12.1.2 所示：</p><p><br></p><div class=pgc-img><img alt="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/095d35ac2f15476f94ff2b37a6793d39><p class=pgc-img-caption>图 12.1.2 TIMx_ DIER 寄存器各位描述</p></div><p>这里我们同样仅关心它的最低位，该位是更新中断允许位，本章用到的是定时器的更新中</p><p>断，所以该位要设置为 1，来允许由于更新事件所产生的中断。</p><p>接下来我们看第三个与我们这章有关的寄存器：预分频寄存器（TIMx_PSC）。该寄存器用</p><p>设置对时钟进行分频，然后提供给计数器，作为计数器的时钟。该寄存器的各位描述如图 12.1.3</p><p>所示：</p><p><br></p><div class=pgc-img><img alt="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a4e8dd219754c63b5cabf23d5676c7b><p class=pgc-img-caption>图 12.1.3 TIMx_ PSC 寄存器各位描述</p></div><p>这里，定时器的时钟来源有 4 个：</p><p>1）内部时钟（CK_INT）</p><p>2）外部时钟模式 1：外部输入脚（TIx）</p><p>3）外部时钟模式 2：外部触发输入（ETR）</p><p>4）内部触发输入（ITRx）：使用 A 定时器作为 B 定时器的预分频器（A 为 B 提供时钟）。</p><p>这些时钟，具体选择哪个可以通过 TIMx_SMCR 寄存器的相关位来设置。这里的 CK_INT</p><p>时钟是从 APB1倍频的来的，STM32 中除非APB1 的时钟分频数设置为 1，否则通用定时器TIMx</p><p>的时钟是 APB1 时钟的 2 倍，当 APB1 的时钟不分频的时候，通用定时器 TIMx 的时钟就等于</p><p>APB1 的时钟。这里还要注意的就是高级定时器的时钟不是来自 APB1，而是来自 APB2 的。</p><p>这里顺带介绍一下 TIMx_CNT 寄存器，该寄存器是定时器的计数器，该寄存器存储了当前</p><p>定时器的计数值。</p><p>接着我们介绍自动重装载寄存器（TIMx_ARR），该寄存器在物理上实际对应着 2 个寄存器。</p><p>一个是程序员可以直接操作的，另外一个是程序员看不到的，这个看不到的寄存器在《STM32</p><p>参考手册》里面被叫做影子寄存器。事实上真正起作用的是影子寄存器。根据 TIMx_CR1 寄存</p><p>器中 APRE 位的设置：APRE=0 时，预装载寄存器的内容可以随时传送到影子寄存器，此时 2</p><p>者是连通的；而 APRE=1 时，在每一次更新事件（UEV）时，才把预装在寄存器的内容传送到</p><p>影子寄存器。</p><p>自动重装载寄存器的各位描述如图 12.1.4 所示：</p><div class=pgc-img><img alt="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5580ff8964f64acc99a56e5059d0d101><p class=pgc-img-caption>图 12.1.4 TIMx_ ARR 寄存器各位描述</p></div><p>最后，我们要介绍的寄存器是：状态寄存器（TIMx_SR）。该寄存器用来标记当前与定时</p><p>器相关的各种事件/中断是否发生。该寄存器的各位描述如图 12.1.5 所示：</p><div class=pgc-img><img alt="「正点原子STM32Mini板资料连载」第十二章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/678c64bd30c94a5080d31fb76bc1c676><p class=pgc-img-caption>图 12.1.5 TIMx_ SR 寄存器各位描述</p></div><p><br></p><p>TIMx_ SR 寄存器，我们同样只用到了最低位，当计数器 CNT 被重新初始化的时候，产生</p><p>更新中断标记，通过这个中断标志位，就可以知道产生中断的类型。</p><p>关于这些位的详细描述，请参考《STM32 参考手册》第 282 页。</p><p>只要对以上几个寄存器进行简单的设置，我们就可以使用通用定时器了，并且可以产生中</p><p>断。</p><p>这一章，我们将使用定时器产生中断，然后在中断服务函数里面翻转 DS1 上的电平，来指</p><p>示定时器中断的产生。接下来我们以通用定时器 TIM3 为实例，来说明要经过哪些步骤，才能</p><p>达到这个要求，并产生中断。这里我们就对每个步骤通过库函数的实现方式来描述。首先要提</p><p>到 的 是 ， 定 时 器 相 关 的 库 函 数 主 要 集 中 在 HAL 库 文 件 stm32f1xx_hal_tim.h 和</p><p>stm32f1xx_hal_tim.c 文件中。定时器配置步骤如下：</p><p><strong>1）TIM3 时钟使能。</strong></p><p>HAL 中定时器使能是通过宏定义标识符来实现对相关寄存器操作的，方法如下：</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 时钟</p><p><strong>2）初始化定时器参数,设置自动重装值，分频系数，计数方式等。</strong></p><p>在 HAL 库中，定时器的初始化参数是通过定时器初始化函数 HAL_TIM_Base_Init 实现的：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim);</p><p>该函数只有一个入口参数，就是 TIM_HandleTypeDef 类型结构体指针，结构体类型为下面</p><p>我们看看这个结构体的定义：</p><p>typedef struct</p><p>{</p><p>TIM_TypeDef *Instance;</p><p>TIM_Base_InitTypeDef Init;</p><p>HAL_TIM_ActiveChannel</p><p>Channel;</p><p>DMA_HandleTypeDef</p><p>*hdma[7];</p><p>HAL_LockTypeDef Lock;</p><p>__IO HAL_TIM_StateTypeDef State;</p><p>}TIM_HandleTypeDef;</p><p>第一个参数 Instance 是寄存器基地址。和串口，看门狗等外设一样，一般外设的初始化结</p><p>构体定义的第一个成员变量都是寄存器基地址。这在HAL中都定义好了，比如要初始化串口1，</p><p>那么 Instance 的值设置为 TIM1 即可。</p><p>第二个参数 Init 为真正的初始化结构体 TIM_Base_InitTypeDef 类型。该结构体定义如下：</p><p>typedef struct</p><p>{</p><p>uint32_t Prescaler;</p><p>//预分频系数</p><p>uint32_t CounterMode; //计数方式</p><p>uint32_t Period;</p><p>//自动装载值 ARR</p><p>uint32_t ClockDivision; //时钟分频因子</p><p>uint32_t RepetitionCounter;</p><p>} TIM_Base_InitTypeDef;</p><p>该初始化结构体中，参数 Prescaler 是用来设置分频系数的，刚才上面有讲解。参数</p><p>CounterMode 是用来设置计数方式，可以设置为向上计数，向下计数方式还有中央对齐计数方</p><p>式 ， 比 较 常 用 的 是 向 上 计 数 模 式 TIM_CounterMode_Up 和 向 下 计 数 模 式</p><p>TIM_CounterMode_Down。参数 Period 是设置自动重载计数周期值。参数 ClockDivision 是用来</p><p>设置时钟分频因子，也就是定时器时钟频率 CK_INT 与数字滤波器所使用的采样时钟之间的分</p><p>频比。参数 RepetitionCounter 用来设置重复计数器寄存器的值，用在高级定时器中。</p><p>第三个参数 Channel 用来设置活跃通道。前面我们讲解过，每个定时器最多有四个通道可</p><p>以用来做输出比较，输入捕获等功能之用。这里的 Channel 就是用来设置活跃通道的，取值范</p><p>围为：HAL_TIM_ACTIVE_CHANNEL_1~ HAL_TIM_ACTIVE_CHANNEL_4。</p><p>第四个 hdma 是定时器的 DMA 功能时用到，为了简单起见，我们暂时不讲解太复杂。</p><p>第五个参数 Lock 和 State，是状态过程标识符，是 HAL 库用来记录和标志定时器处理过程。</p><p>定时器初始化范例如下：</p><p>TIM_HandleTypeDef TIM3_Handler;</p><p>//定时器句柄</p><p>TIM3_Handler.Instance=TIM3; //通用定时器 3</p><p>TIM3_Handler.Init.Prescaler= 7199;</p><p>//分频系数</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;</p><p>//向上计数器</p><p>TIM3_Handler.Init.Period=4999;</p><p>//自动装载值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频因子</p><p>HAL_TIM_Base_Init(&TIM3_Handler);</p><p><strong>3）使能定时器更新中断，使能定时器</strong></p><p>HAL 库 中 ， 使 能 定 时 器 更 新 中 断 和 使 能 定 时 器 两 个 操 作 可 以 在 函 数</p><p>HAL_TIM_Base_Start_IT()中一次完成的，该函数声明如下：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);</p><p>该 函 数 非 常 好 理 解 ， 只 有 一 个 入 口 参 数 。 调 用 该 定 时 器 之 后 ， 会 首 先 调 用</p><p>__HAL_TIM_ENABLE_IT 宏定义使能更新中断，然后调用宏定义__HAL_TIM_ENABLE 使能</p><p>相应的定时器。这里我们分别列出单独使能/关闭定时器中断和使能/关闭定时器方法：</p><p>__HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);//使能句柄指定的定时器更新中断</p><p>__HAL_TIM_DISABLE_IT (htim, TIM_IT_UPDATE);//关闭句柄指定的定时器更新中断</p><p>__HAL_TIM_ENABLE(htim);//使能句柄 htim 指定的定时器</p><p>__HAL_TIM_DISABLE(htim);//关闭句柄 htim 指定的定时器</p><p><strong>4）TIM3 中断优先级设置。</strong></p><p>在定时器中断使能之后，因为要产生中断，必不可少的要设置 NVIC 相关寄存器，设置中</p><p>断优先级。之前多次讲解到中断优先级的设置，这里就不重复讲解。</p><p>和串口等其他外设一样，HAL 库为定时器初始化定义了回调函数 HAL_TIM_Base_MspInit。<strong>ALIENTEK MiniSTM32</strong></p><p><strong>V3.0 开发板教程</strong></p><p>183</p><p><strong>STM32 不完全手</strong></p><p>一般情况下，与 MCU 有关的时钟使能，以及中断优先级配置我们都会放在该回调函数内部。</p><p>函数声明如下：</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim);</p><p>对于回调函数，这里我们就不做过多讲解，大家只需要重写这个函数即可。</p><p><strong>5）编写中断服务函数。</strong></p><p>在最后，还是要编写定时器中断服务函数，通过该函数来处理定时器产生的相关中断。通</p><p>常情况下，在中断产生后，通过状态寄存器的值来判断此次产生的中断属于什么类型。然后执</p><p>行相关的操作，我们这里使用的是更新（溢出）中断，所以在状态寄存器 SR 的最低位。在处</p><p>理完中断之后应该向 TIM3_SR 的最低位写 0，来清除该中断标志。</p><p>跟串口一样，对于定时器中断，HAL 库同样为我们封装了处理过程。这里我们以定时器 3</p><p>的更新中断为例来讲解。</p><p>首先，中断服务函数是不变的，定时器 3 的中断服务函数为：</p><p>TIM3_IRQHandler();</p><p>一般情况下我们是在中断服务函数内部编写中断控制逻辑。但是 HAL 库为我们定义了 新</p><p>的定时器中断共用处理函数 HAL_TIM_IRQHandler，在每个定时器的中断服务函数内部，我们</p><p>会调用该函数。该函数声明如下：</p><p>void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim);</p><p>而函数 HAL_TIM_IRQHandler 内部，会对相应的中断标志位进行详细判断，判断确定中断</p><p>来源后，会自动清掉该中断标志位，同时调用不同类型中断的回调函数。所以我们的中断控制</p><p>逻辑只用编写在中断回调函数中，并且中断回调函数中不需要清中断标志位。</p><p>比如定时器更新中断回调函数为：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);</p><p>跟串口中断回调函数一样，我们只需要重写该函数即可。对于其他类型中断，HAL 库同样</p><p>提供了几个不同的回调函数，这里我们列出常用的几个回调函数：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);//更新中断</p><p>void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);//输出比较</p><p>void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);//输入捕获</p><p>void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);//触发中断</p><p>对于这些回调函数的使用方法我们在后面用到的时候会给大家详细讲解。</p><p>通过以上几个步骤，我们就可以达到我们的目的了，使用通用定时器的更新中断，来控制</p><p>DS1 的亮灭。</p><p><strong>12.2 硬件设计</strong></p><p>本实验用到的硬件资源有：</p><p>1） 指示灯 DS0 和 DS1</p><p>2） 定时器 TIM3</p><p>本章将通过 TIM3 的中断来控制 DS1 的亮灭，DS0 和 DS1 的电路在前面已经有介绍了。而</p><p>TIM3 属于 STM32 的内部资源，只需要软件设置即可正常工作。</p><p><strong>12.3 软件设计</strong></p><p>打开我们光盘实验 7 定时器中断实验可以看到，我们的工程中的 HARDWARE 下面比以前</p><p>多了一个 time.c 文件（包括头文件 time.h），这两个文件是我们自己编写。同时还引入了定时器</p><p>相关的 HAL 库函数文件 stm32f1xx_hal_tim.c 和头文件 stm32f1xx_hal_tim.h。下面我们来看看我</p><p>们的 time.c 文件。timer.c 文件代码如下：</p><p>#include "timer.h"</p><p>#include "led.h"</p><p>TIM_HandleTypeDef TIM3_Handler; //定时器句柄</p><p>//通用定时器 3 中断初始化</p><p>//arr：自动重装值。</p><p>//psc：时钟预分频数</p><p>//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.</p><p>//Ft=定时器工作频率,单位:Mhz</p><p>//这里使用的是定时器 3!</p><p>void TIM3_Init(u16 arr,u16 psc)</p><p>{</p><p>TIM3_Handler.Instance=TIM3;</p><p>//通用定时器 3</p><p>TIM3_Handler.Init.Prescaler=psc;</p><p>//分频系数</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP; //向上计数器</p><p>TIM3_Handler.Init.Period=arr;</p><p>//自动装载值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频因子</p><p>HAL_TIM_Base_Init(&TIM3_Handler);</p><p>HAL_TIM_Base_Start_IT(&TIM3_Handler);</p><p>//使能定时器 3 和定时器 3 更新中断：TIM_IT_UPDATE</p><p>}</p><p>//定时器底册驱动，开启时钟，设置中断优先级</p><p>//此函数会被 HAL_TIM_Base_Init()函数调用</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim->Instance==TIM3)</p><p>{</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 时钟</p><p>HAL_NVIC_SetPriority(TIM3_IRQn,1,3);</p><p>//设置中断优先级，抢占优先级 1，子优先级 3</p><p>HAL_NVIC_EnableIRQ(TIM3_IRQn); //开启 ITM3 中断</p><p>}</p><p>}</p><p>//定时器 3 中断服务函数</p><p>void TIM3_IRQHandler(void)</p><p>{</p><p>HAL_TIM_IRQHandler(&TIM3_Handler);</p><p>}</p><p>//回调函数，定时器中断服务函数调用</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim==(&TIM3_Handler))</p><p>{</p><p>LED1=!LED1; //LED1 反转</p><p>}</p><p>}</p><p>该文件下包含一个中断服务函数和一个定时器 3 中断初始化函数，中断服务函数比较简单，</p><p>在每次中断后，判断 TIM3 的中断类型，如果中断类型正确，则执行 LED1（DS1）的取反。</p><p>TIM3_Int_Init 函数就是执行我们上面介绍的那 5 个步骤，使得 TIM3 开始工作，并开启中</p><p>断。该函数的 2 个参数用来设置 TIM3 的溢出时间。因为我们在 Stm32_Clock_Init 函数里面已</p><p>经初始化 APB1 的时钟为 2 分频，所以 APB1 的时钟为 36M，而从 STM32F1 的内部时钟树图</p><p>（图 5.2.2.1）得知：当 APB1 的时钟分频数为 1 的时候，TIM2~7 的时钟为 APB1 的时钟，而</p><p>如果 APB1 的时钟分频数不为 1，那么 TIM2~7 的时钟频率将为 APB1 时钟的两倍。因此，TIM3</p><p>的时钟为 72M，再根据我们设计的 arr 和 psc 的值，就可以计算中断时间了。计算公式如下：</p><p>Tout= ((arr+1)*(psc+1))/Tclk；</p><p>其中：</p><p>Tclk：TIM3 的输入时钟频率（单位为 Mhz）。</p><p>Tout：TIM3 溢出时间（单位为 us）。</p><p>我们将 timer.c 文件保存，然后加入到 HARDWARE 组下。接下来，在 timer.h 文件里，我</p><p>们输入如下代码：</p><p>#ifndef __TIMER_H</p><p>#define __TIMER_H</p><p>#include "sys.h"</p><p>extern TIM_HandleTypeDef TIM3_Handler; //定时器句柄</p><p>void TIM3_Int_Init(u16 arr,u16 psc);</p><p>#endif</p><p>此部分代码十分简单，这里不做介绍。</p><p>最后，我们在主程序里面输入如下代码：</p><p>int main(void)</p><p>{</p><p>HAL_Init();</p><p>//初始化 HAL 库</p><p>Stm32_Clock_Init(RCC_PLL_MUL9); //设置时钟,72M</p><p>delay_init(72);</p><p>//初始化延时函数</p><p>uart_init(115200);</p><p>//初始化串口</p><p>LED_Init();</p><p>//初始化 LED</p><p>KEY_Init();</p><p>//初始化按键</p><p>TIM3_Init(5000-1,7200-1);</p><p>//定时器 3 初始化，定时器时钟为 72M，</p><p>//分频系数为 7200-1，所以定时器 3 的频率为 72M/7200=10K，自动重装载为 5000-1，</p><p>//那么定时器周期就是 500ms</p><p>while(1)</p><p>{</p><p>LED0=!LED0;</p><p>delay_ms(200);</p><p>}</p><p>}</p><p>这里的代码和之前大同小异，此段代码对 TIM3 进行初始化之后，进入死循环等待 TIM3</p><p>溢出中断，当 TIM3_CNT 的值等于 TIM3_ARR 的值的时候，就会产生 TIM3 的更新中断，然</p><p>后在中断里面取反 LED1，TIM3_CNT 再从 0 开始计数。</p><p>这里定时器定时时长 500ms 是这样计算出来的，定时器的时钟为 72Mhz，分频系数为 7200,</p><p>所以分频后的计数频率为 72Mhz/7200=10KHz,然后计数到 5000，所以时长为 5000/10000=0.5s，</p><p>也就是 500ms。</p><p><strong>12.4 下载验证</strong></p><p>在完成软件设计之后，我们将编译好的文件下载到 MiniSTM32 开发板上，观看其运行结果</p><p>是否与我们编写的一致。如果没有错误，我们将看 DS0 不停闪烁（每 400ms 闪烁一次），而 DS1</p><p>也是不停的闪烁，但是闪烁时间较 DS0 慢（1s 一次）。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'正点','STM32Mini','板资料'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>