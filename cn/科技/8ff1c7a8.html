<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>解读数据库：深入分析MySQL中事务以及MVCC的实现原理 | 极客快訊</title><meta property="og:title" content="解读数据库：深入分析MySQL中事务以及MVCC的实现原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/8ff1c7a8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/8ff1c7a8.html><meta property="article:published_time" content="2020-11-14T21:08:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:11+08:00"><meta name=Keywords content><meta name=description content="解读数据库：深入分析MySQL中事务以及MVCC的实现原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/8ff1c7a8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>解读数据库：深入分析MySQL中事务以及MVCC的实现原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>推荐学习</h1><ul><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6867458116846682638/?group_id=6867458116846682638" rel="noopener noreferrer" target=_blank>真真香！耗时大半个月收整全套「Java架构进阶pdf」没白费</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6837463402219045388/?group_id=6837463402219045388" rel="noopener noreferrer" target=_blank>全网独家的“MySQL高级知识”集合，骨灰级收藏，手慢则无</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6827021630116463115/?group_id=6827021630116463115" rel="noopener noreferrer" target=_blank>阿里P8MySQL，基础/索引/锁/日志/调优都不误，一锅深扒端给你</a></li></ul><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>什么是事务</h1><p style=text-align:start>事务（Transaction)是由一系列对数据库中的数据进行访问与更新的操作所组成的一个程序执行单元。</p><p style=text-align:start>在同一个事务中所进行的操作，要么都成功，要么就什么都不做。理想中的事务必须满足四大特性，这就是大名鼎鼎的ACID。</p><h1 class=pgc-h-arrow-right>事务的ACID特性</h1><p style=text-align:start>并不是所有的事务都满足ACID特性，比如：对于Oracle和SQL Server数据库，其默认隔离级别是Read COMMITTED，就不满足I(隔离性)的要求；对于MySQL的NDB Cluster引擎来说，不满足D(持久性)的要求。</p><h1 class=pgc-h-arrow-right>A(Atomicity)-原子性</h1><p style=text-align:start>原子性指的是数据库事务是不可分割的一部分，只有一个事务中的所有操作都成功，这个事务才算执行成功，一旦有一个操作失败，那么其他成功的操作也必须回滚。<br>以转账1000元场景为例，一个转账过程就是一个事务，这个事务主要包括以下两步：<br>1、从A账户扣除1000元<br>2、将B账户中增加1000元<br>试想，如果第一步成功了，那么第二步失败了，那就等于A的1000元钱直接消失了，相信这是任何人都不能接受的事项，所以数据库事务才需要保证原子性。</p><h1 class=pgc-h-arrow-right>C(Consistent)-一致性</h1><p style=text-align:start>指的是在事务开始之前和事务结束之后，数据库的完整性约束都没有被破坏，事务执行的前后都是合法的数据状态。</p><p style=text-align:start>比如我们有一张表中有一个字段name建立了一个唯一约束，那么当我们进行事务提交或者事务回滚之后，这个name必须依然保证唯一。</p><h1 class=pgc-h-arrow-right>I(Isolation)-隔离性</h1><p style=text-align:start>隔离性就是说每个事务之间的操作应该相互隔离，互不干扰。比如说一个事务提交之前对另一个事务不可见。</p><p style=text-align:start>隔离是一个相对抽象而复杂的概念，比如说事务之间的隔离性我们到底要隔离到哪种程度呢？所以，针对隔离，SQL92标准定义了4种隔离级别，这个放在后面事务的隔离级别中介绍。</p><h1 class=pgc-h-arrow-right>D(Durable)-持久性</h1><p style=text-align:start>持久性这个概念就比较容易理解了，就是说事务一旦提交成功了，那么就应该是持久的，即使是数据库重启，服务器宕机等情况发生，数据都不会丢失(当然这个不能包括因为地震等自然灾害导致的存储数据的硬盘损发生不可逆的损坏)。</p><h1 class=pgc-h-arrow-right>事务的管理</h1><p style=text-align:start>可能很多人会说自己都感知不到MySQL的事务，其实这是因为MySQL事务是默认开启了自动提交的，因此，如果要感知到事务，我们需要关闭自动提交或者显示开启事务。</p><h1 class=pgc-h-arrow-right>事务的自动提交</h1><p style=text-align:start>查看自动提交语句：</p><pre><code>SHOW VARIABLES LIKE 'autocommit';-- ON表示开启了自动提交SELECT @@autocommit;-- 1表示开启了自动提交</code></pre><p style=text-align:start>执行如下语句关闭自动提交：</p><pre><code>SET autocommit='OFF';SET @@autocommit = 0;</code></pre><p style=text-align:start>不过需要注意的是，这种修改方式只是在当前会话窗口生效，对其他会话窗口是不生效的，MySQL几乎所有变量设置都会分成两个级别，session(会话)和global(全局)级别，默认就是session级别。</p><h1 class=pgc-h-arrow-right>常用的事务控制语句</h1><ul><li>START TRANSACTION或者BEGIN：显示的开启事务。需要注意的是在存储过程中只能用START TRANSACTION开启事务，因为存储过程本来有BEGIN…END语法，两者会冲突。</li><li>COMMIT：提交事务。也可以写成COMMIT WORK。</li><li>ROLLBACK：回滚事务。也可以写成ROLLBACK WORK。</li><li>SAVEPOINT identifier：自定义保存点，适用于长事务，可以回滚到我们自定义的位置。</li><li>RELEASE SAVEPOINT identifier：删除一定保存点，如果没有保存点的时候，会报错</li><li>ROLLBACK TO[SAVEPOINT] identifier：回滚到指定保存点。</li></ul><h1 class=pgc-h-arrow-right>COMMIT和COMMIT WORK的区别</h1><p style=text-align:start>这两个都能提交一个事务，区别就在于提交事务之后的操作，同样的还有ROLLBACK和ROLLBACK WORK，主要是通过一个变量来控制：completion_type，可以执行下面的sql来查看结果：</p><pre><code>SHOW VARIABLES LIKE '%completion_type%';</code></pre><p style=text-align:start>completion_type有如下三种结果：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cd28fddfdee743b4b144f7b716662792><p class=pgc-img-caption></p></div><p style=text-align:start>举个栗子1：</p><pre><code>SET completion_type=1; --1begin;--2INSERT test2 VALUES(1,'张1');--3commit work;--4INSERT test2 VALUES(2,'张1');--5select * from test2;--6rollback;--7select * from test2;--8</code></pre><p style=text-align:start>第4条语句中，我们提交了一个事务，第5条语句中我们又插入了一条数据，此时第六条语句可以查询出2条数据，接下来我们回滚，语句8再去查询就会发现只剩一条数据了，因为语句6倍回滚了，我们在语句4之后并没有显示的开启一个事务，这就说明语句4自动开启了一个新的事务。</p><p style=text-align:start>举个栗子2：</p><pre><code>SET completion_type=2;begin;INSERT test2 VALUES(3,'张1');commit work;select * from test2;</code></pre><p style=text-align:start>最后一条语句返回如下结果：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/21b08f9d5c774e87bbcf43bbcad06955><p class=pgc-img-caption></p></div><p style=text-align:start>先提示的断开连接，然后自动重连。测试这个例子的时候用工具比如sqlyog可能会不是很明显，因为工具会自动帮忙重连，看起来就好像没断开一样，建议用命令窗口的形式测试</p><h1 class=pgc-h-arrow-right>事务的分类</h1><p style=text-align:start>从事务的理论角度来说，我们可以把事务分为以下五大类：</p><h1 class=pgc-h-arrow-right>扁平事务</h1><p style=text-align:start>这种是最简单也是最常用的一种事务，这种事务中的所有操作都是原子的，要么全部成功，要么什么都不做。</p><h1 class=pgc-h-arrow-right>带有保存点的扁平事务</h1><p style=text-align:start>这种一般比较适合于长事务，事务处理到后面报错的时候，我们可以选择不全部回滚事务，而是回滚到我们自定义好的某一个保存点。如下例子：</p><pre><code>BEGIN;INSERT test VALUES(1,'张1');SAVEPOINT AINSERT test VALUES(2,'张2');ROLLBACK TO ACOMMIT;</code></pre><p style=text-align:start>上面示例语句中，我么你定义了一个保存点A，然后在后面又回滚到A，这时候提交事务，那么第二条插入语句是失败的，而第一条语句是成功的。</p><p style=text-align:start><strong>注意：回滚到指定保存点之后，事务仍然还在活动状态，我们依然需要执行COMMIT或者ROLLBACK语句才算结束了事务</strong></p><h1 class=pgc-h-arrow-right>链事务</h1><p style=text-align:start>在提交一个事务之后，释放掉我们不需要的数据，将必要的数据隐式的传给下一个事务。（<strong>注意：提交事务操作和开始下一个事务操作是一个原子操作</strong>）这就意味着下一个事务能看到上一个事务的结果。</p><p style=text-align:start>链事务可以看成带有保存点的特殊事务，他们的区别就是带有保存点的事务可以回滚到任意保存点，但是回滚之后事务仍然活跃，需要执行COMMIT或者ROLLBACK之后才结束事务，而链事务中只能回滚到最近的一个保存点(即开始事务的点)。</p><p style=text-align:start>链事务可以通过上面的completion_type参数来实现。上文中有举例使用方法，这里就不重复举例了。</p><h1 class=pgc-h-arrow-right>嵌套事务</h1><p style=text-align:start>嵌套事务就是说一个事务之中嵌套另一个事务，事务之间存在父子关系，子事务的提交之后并不生效，需要等到父事务提交之后才会生效。</p><p style=text-align:start>需要注意的是MySQL原生并不支持嵌套事务，但是可以通过保存点模拟嵌套事务，只是说这么模拟的话就没有真正的嵌套事务这么灵活。</p><h1 class=pgc-h-arrow-right>分布式事务</h1><p style=text-align:start>分布式事务通常就是在分布式环境下，多个数据库下运行不同的扁平事务。多个数据库环境下运行的扁平事务就合成了一个分布式事务。</p><h1 class=pgc-h-arrow-right>事务的隔离级别</h1><h1 class=pgc-h-arrow-right>Read Uncommitted(未提交读)</h1><p style=text-align:start>简称RU。这种是最低的隔离级别，等于没有隔离，基本上没有数据库会使用这个级别。一个事务可以读取到其他事务未提交的数据，这种也叫做脏读。</p><p style=text-align:start>什么是脏读？请看下面这个例子：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f07885f4962487f8c4471ae9e9572e3><p class=pgc-img-caption></p></div><p style=text-align:start>左边是事务1，先查一次，查到id为1的数据name为张三，这时候事务2又来了，把张三改成了李四，然后事务1又进行了一次查询，查出来了name为李四，那么假如这时候事务2发生了回滚，也就是name还是张三，但是事务1却读到了李四，这就是脏读。</p><h1 class=pgc-h-arrow-right>Read Committed(已提交读)</h1><p style=text-align:start>简称RC。一个事务只能读取到其他事务已提交的数据，就是说在一个事务里面，执行同样的查询，会出现两次不一样的结果。Oracle和SQL Server数据库默认的数据库隔离级别。这种隔离级别解决了脏读问题，但是会出现不可重复读的问题。</p><p style=text-align:start>什么是不可重复读？还是看上面那个例子，假设事务2更新之后马上就提交，然后事务1第二次查询查出来的结果还是李四，只是这次就不算是脏读了，因为事务2提交了，这种就叫不可重复读，因为事务1中两次查询同一条数据结果不一样。</p><h1 class=pgc-h-arrow-right>Repeatable Read(可重复读)</h1><p style=text-align:start>简称RR。这种隔离级别解决了不可重复读问题，就是说在同一个事务中，执行相同的查询，结果都是一样的，但是这种级别会出现幻读问题(InnoDB引擎例外，InnoDB引擎通过间隙锁解决了幻读问题)。</p><p style=text-align:start>什么是幻读？请看下面这个例子：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3c3f58c90a1e4e9c9e6f7b24541770e4><p class=pgc-img-caption></p></div><p style=text-align:start>上面图形中，事务1进行了一个范围查询，第一次只能查出一条记录，这时候事务2来插入了一条数据，然后事务1再次执行同一个查询，这时候就能查出来两条记录，也就是多了一条，给人一种幻觉，所以称之为幻读。</p><p>说到这里，可能有人就有疑问了，因为感觉不可重复读和幻读都是读取到已提交事务的结果，好像没什么区别？确实如此，<strong class=highlight-text>不可重复读和幻读本质上是一样的，但是不可重复读针对的是更新和删除操作，而幻读仅针对插入操作</strong><strong>。</strong></p><h1 class=pgc-h-arrow-right>Serializable(串行化)</h1><p style=text-align:start>这种是隔离的最高级别，也就是说所有的事务都是串行执行的，也就不存在并发事务，脏读，可重复读和幻读问题自然也就没有了。</p><h1 class=pgc-h-arrow-right>不同隔离级别对比</h1><p style=text-align:start>不同的隔离级别可以解决不同的问题，大致如下图：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b223aa6613e4cfa9af62f15ad071267><p class=pgc-img-caption></p></div><p>对于未提交读和已提交读大家可能都很好理解，只要控制一个事务提交之后才能对另一个事务可见，但是对于可重复读，MySQL到底是如何实现即使一个事务已经提交了，还能对另一个事务不可见呢？这就是接下来我们要讲解的MVCC了。</p><h1 class=pgc-h-arrow-right>事务隔离的实现方案</h1><p style=text-align:start>事务隔离的实现方案有两种，LBCC和MVCC</p><h1 class=pgc-h-arrow-right>LBCC</h1><p style=text-align:start>LBCC，基于锁的并发控制，英文全称Based Concurrency Control。这种方案比较简单粗暴，就是一个事务去读取一条数据的时候，就上锁，不允许其他事务来操作(当然这个锁的实现也比较重要，如果我们只锁定当前一条数据依然无法解决幻读问题)。</p><h1 class=pgc-h-arrow-right>当前读</h1><p style=text-align:start>这个概念其实很好理解，MySQL加锁之后就是当前读。假如当前事务只是加共享锁，那么其他事务就不能有排他锁，也就是不能修改数据；而假如当前事务需要加排他锁，那么其他事务就不能持有任何锁。总而言之，能加锁成功，就确保了除了当前事务之外，其他事务不会对当前数据产生影响，所以自然而然的，当前事务读取到的数据就只能是最新的，而不会是快照数据(后文MVCC会解释快照读概念)。</p><p style=text-align:start>LBCC方案中，如果我们的业务系统是读多写少的话，这种方案就会极大影响了效率，所以我们就有了另一种解决方案：MVCC。</p><h1 class=pgc-h-arrow-right>MVCC</h1><p style=text-align:start>MVCC,多版本的并发控制，英文全称：Multi Version Concurrency Control。就是当我们在修改数据的时候，可以为这条数据创建一个快照，后面就可以直接读取这个快照。</p><p style=text-align:start>那么MVCC具体到底是如何实现的呢？</p><p style=text-align:start>为了实现MVCC机制，InnoDB内部为每一行添加了两个隐藏列：DB_TRX_ID和DB_ROLL_PTR（MySQL另外还有一个隐藏列DB_ROW_ID，这是在InnoDB表没有主键的时候会用来作为主键，想详细了解可以点击这里）。</p><h1 class=pgc-h-arrow-right>DB_TRX_ID</h1><p style=text-align:start>长度为6字节，存储了插入或更新语句的最后一个事务的事务ID。</p><h1 class=pgc-h-arrow-right>DB_ROLL_PTR</h1><p style=text-align:start>长度为7字节，称之为：回滚指针。回滚指针指向写入回滚段的undo log记录，读取记录的时候会根据指针去读取undo log中的记录。</p><p style=text-align:start>正因为MySQL中undo log中会维护一个历史数据记录，所以我们应该养成定期提交事务的习惯，否则回滚段会越来越大，甚至占满了表空间。</p><h1 class=pgc-h-arrow-right>快照读</h1><p style=text-align:start>快照读是针对上文的当前读而言，指的是在RR隔离级别下，在不加锁的情况下MySQL会根据回滚指针选择从undo log记录中获取快照数据，而不总是获取最新的数据，这也就是为什么另一个事务提交了数据，在当前事务中看到的依然是另一个事务提交之前的数据。</p><h1 class=pgc-h-arrow-right>MySQL什么时候开始读取快照</h1><p style=text-align:start>我们先看看MySQL默认隔离级别RR下的一个例子（注意，test和test2两张表一开始都是空表，均只有id和name两个字段）。</p><ul><li>场景1(事务1操作数据之后再进行第一次查询)：</li></ul><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb52a459f3ff4539ad7a942bd33626c4><p class=pgc-img-caption></p></div><ul><li>场景2(事务1不进行任何操作，事务2先开始第一次查询)</li></ul><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b26674caea674df9bb4edf4f14429aa1><p class=pgc-img-caption></p></div><p>通过上面两个场景中我们可以得出结论：<br><strong>RR隔离级别快照并不是在BEGIN就开始产生了，而是要等到事务当中的第一次查询之后才会产生快照，之后的查询就只读取这个快照数据</strong></p><ul><li>场景3(事务2先进行一次t1表查询之后，事务1再去操作其他表t2)</li></ul><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88cf0f23a64b43a987ae3e5f2a16ec61><p class=pgc-img-caption></p></div><p>从场景3我们可以得出结论：<strong>RR隔离级别快照并不只是针对当前所查询的数据，而是针对当前MySQL中的所有数据(跨库也一样，只要在同一个MySQL)</strong></p><h1 class=pgc-h-arrow-right>MVCC查询机制</h1><p style=text-align:start>MVCC机制到底如何查询的呢？假设由很多个事务同时进行，那么就会产生很多快照，查询的时候又到底是怎么做的呢？</p><p style=text-align:start>接下来我们把抽象的概念具体化，假定DB_TRX_ID和DB_ROLL_PTR均为整型，接下来我们进行查询演示：</p><p style=text-align:start>1、清空原先的test表，事务A插入两条数据，此时DB_TRX_ID(事务id)为1,DB_ROLL_PTR(回滚指针为null)</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/932f62afab754d59ac3aca470b8c0cba><p class=pgc-img-caption></p></div><p style=text-align:start>2、这时候事务B进行了一次查询，会得到上面的结果，事务2还没提交的时候又来了事务C，事务C插入了id=3的数据，此时表中的数据如下：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b79919b047a49f2861d9ab845d272e6><p class=pgc-img-caption></p></div><p style=text-align:start><strong>注意，这时候第3条数据的事务id为3，因为事务2也会产生一个事务id</strong><br>3、这时候事务B再次进行查询，根据上面了解的，我们知道，这时候应该是查询不出王五的，所以实际上二次查询可能是这么查的：</p><pre><code>select * from test where 事务id&lt;=2-- 因为当前的事务id为2</code></pre><p style=text-align:start>4、假如这时候事务D又来了，把id=1的数据给删除了，这时候会把原数据的回滚指针记录为当前的事务id：4，所以此时数据如下：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/032a5c045eeb43b3a4fa4ba9752b6730><p class=pgc-img-caption></p></div><p style=text-align:start>5、回到事务B，继续查询，应该还是只有1和2两条数据，那么他可能是这么查询的：</p><pre><code>select * from test where 事务id&lt;=2 and (回滚指针 is null or 回滚指针 &gt;2)</code></pre><p style=text-align:start>6、假如这时候又来了事务E，对第2条数据进行了更新，这时候会生产一条事务id为5的数据，并把原数据的回滚指针也同时标记为当前的事务id：5，那么会得到如下数据：</p><div class=pgc-img><img alt=解读数据库：深入分析MySQL中事务以及MVCC的实现原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1ddf47fd40f64201a9166c0ed3076c74><p class=pgc-img-caption></p></div><p style=text-align:start>根据上面猜测，执行下面的查询：</p><pre><code>select * from test where 事务id&lt;=2 and (回滚指针 is null or 回滚指针 &gt;2)</code></pre><p style=text-align:start>这时候发现，查出来的数据还是只有1和2两条。</p><h1 class=pgc-h-arrow-right>MVCC查询两大规则</h1><p style=text-align:start>综上，MVCC大致查询规则如下：<br>1、<strong>只查询事务id小于等于当前事务id的数据。</strong>(这里要等于是因为假如自己的事务插入了一条数据，会生成一条当前事务id的数据，所以必须包含本事务自己插入的数据)<br>2、<strong>只查询未删除(回滚指针为空)或者回滚指针大于当前事务id的数据。</strong>(这里不能等于是因为假如自己的事务删除了一条数据，会生成数据的回滚指针为当前事务id，所以必须排除掉自己删除的数据)</p><p style=text-align:start>当然，上面规则只是简化了，实际查询远比这里复杂，只是希望借助这种简单化的概念可以帮助大家更好的理解MVCC工作机制。</p><blockquote class=pgc-blockquote-abstract><p>作者：双子孤狼</p><p>原文链接：https://blog.csdn.net/zwx900102/article/details/106544843</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'解读','数据库','MySQL'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>