<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>有限元仿真分析误差来源之边界条件，约束和point mass | 极客快訊</title><meta property="og:title" content="有限元仿真分析误差来源之边界条件，约束和point mass - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/c9f28ac564014467aa5f0677aece368f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9035f59d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9035f59d.html><meta property="article:published_time" content="2020-11-14T21:05:03+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:03+08:00"><meta name=Keywords content><meta name=description content="有限元仿真分析误差来源之边界条件，约束和point mass"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9035f59d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>有限元仿真分析误差来源之边界条件，约束和point mass</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>导读：</strong>前不久，我在这里分享了一篇</p><p>《有限元仿真分析误差来源之材料参数设置，小心为妙》</p><p>的文章，引发了同行们的关注和讨论。在此感谢仿真秀平台讲师们的批评和指正，一起认真交流技术和进步。今天我将继续带来关于<strong>边界条件设置相关讨论，希望能够抛砖引玉，</strong>激发大家的学习兴趣。</p><p>由于边界条件需要注意的点比较多，因此，我打算分多次来说明，这篇文章就<strong>从约束和point mass的角度来分析有限元计算误差来源。</strong></p><p><strong>一、约束</strong></p><p>约束是有限元仿真建模的基础，很多同学都觉得约束设置没有什么值得思考的，但是仔细推敲实际上并不简单。还是拉杆问题，一根直径为0.06m，长0.5m的杆件，受拉力 100000N，如下图所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c9f28ac564014467aa5f0677aece368f><p class=pgc-img-caption>图 1拉杆简图</p></div><p>够简单吧，一般的同学可能直接约束底面的六个自由度，在workbench中就是Fixed support。然后计算的结果如下。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/89ae1b29b103425ba63e498b8516e26a><p class=pgc-img-caption>图 2应力云图</p></div><p>从云图上看最大应力62.5MPa，比理论计算值35.3MPa大了将近77%。而且应力分布也不正常，底面周围应力值很大，中间应力值小，按理论分析应力应该是均匀的才对。</p><p>为什么会造成这种计算结果？主要是因为受拉杆件的截面是会收缩的，而Fixed support将底面的所有节点的的所有自由度都置零。这样底面就无法收缩，在底面的周围就会产生较大应力。</p><p>如果采用displacement将底面的轴向的自由度置零，看下仿真结果。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0beaf0410efe4533be7b34ee7892c325><p class=pgc-img-caption>图 3应力云图</p></div><p>从云图上看结果和理论计算一致为35.3MPa，应力分布也是均匀的。还有一种约束形式workbench中的remote point，翻译过来可以叫远点约束，可以用remote point关联相关节点的自由度，并将该节点的六个自由度置0，计算结果如下。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f121593b86f6479996a11e981ef596c0><p class=pgc-img-caption>图 4应力云图</p></div><p>可以看出和displacement约束下的计算结果相同，这个结果看似正确，但仔细推敲下，还是里面还有值得思考的问题。</p><p>笔者我以前认为remote point是将底面所有节点通过刚体单元连接到一个参考点上，但如果是这样应该和图2显示的计算结果是一样的。</p><p>我们用hyperworks来试验下。将底面的节点使用rb2也就是刚体单元，连接到一个参考点上，将该参考点的六个自由度都置0，如下所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a10e57eb6ac465baea0dd0da40cdff0><p class=pgc-img-caption>图 5约束</p></div><p>得到底面应力云图如下所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/93a673823d4e4718a8668fe4b7605aba><p class=pgc-img-caption>图 6应力云图</p></div><p>底面应力分布和图2基本一致，也呈现出周围比中间高的情况。我们看看remote point的相关菜单，我们将remote point的behavior改成rigid。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/86f5363cdfc541b7ba8ae77d8d54c7ca><p class=pgc-img-caption>图 7remote point相关菜单</p></div><p>计算结果如下。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2de767ed57c6479ba2a6a3e84e333ff5><p class=pgc-img-caption>图 8应力云图</p></div><p>计算结果和图2一致。总结下仿真计算结果，如下表所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0282a68e229460ebf91a76a6a360992><p class=pgc-img-caption></p></div><p>可以看出当采用remote point耦合底面节点的自由度时，并且将 behavior设置rigid，这样就和用hyperworks的rb2单元一样，将每个节点和参考点耦合起来，用参考点自由度代替底面的自由度，<strong>学过理论力学同学对这个描述应该不陌生，</strong>刚体运动就是这么定义的，因此将remote point的behavior设置成rigid，就会使被耦合的面变成刚体。</p><p>如果设置成deformable，参考点和被耦合面之间采用rbe3单元，这样被耦合面就是弹性体。当在remote point添加约束时，软件就会在被耦合面的节点上施加相应的反力作为约束。这样不同约束条件会造成不同计算结果，<strong>可见当约束设置的不合理，计算结果会产生较大误差。</strong></p><p><strong>二、point mass</strong></p><p>笔者在平时工作中，经常遇到这样的问题，在箱体的平板上安装着一些尺寸较小的盒体，计算模态或者应力什么的，为了减小计算的规模，经常利用质量单元来代替这些盒体。大家觉得这里应该没什么坑？但其实这里面还是有玄机的。</p><p>计算平板模态问题，问题描述如下所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d9fb2410eef4134bb3b2a169bc50ab6><p class=pgc-img-caption>图 9问题描述</p></div><p>模态计算结果如下所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c8ac4c6c96db498ba55f1447c48e0bf5><p class=pgc-img-caption>图 10模态振型图</p></div><p>得到一阶固有频率为5.53Hz。</p><p>使用point mass，进行简化，计算得到结果如下。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f2b02dcdc6b4f03a4d2b35e2595dbf3><p class=pgc-img-caption>图 11模态振型图</p></div><p>得到一阶固有频率为6.25Hz，和原模型相比有13%的偏差，明显是不正常的。我们来看看point mass的相关菜单。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ccac9cd5d1f04559a720743d970a8722><p class=pgc-img-caption>图 12point mass相关菜单</p></div><p>可以看出point mass连接采用类似remote pointe的形式，behavior为deformable，这样连接单元就为rbe3，再看pinball region为all，这样设置之后，实际上是将point mass的质量平均分配到整个平面的节点上，通过hyperworks软件仿真验证下，这个假设是否成立。在每个节点上布置一个质量单元，如下图所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e5be9a19b21f4973aea4b25519d4ea7f><p class=pgc-img-caption>图 13质量分布图</p></div><p>计算结果如下所示。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5869d351e88b43dc98abfec30bac20d9><p class=pgc-img-caption>图 14模态振型图</p></div><p>一阶固有频率为6.07Hz，和图11计算的结果6.25Hz相比，相差为2.9%，认为point mass采用如图设置之后，实际上就是讲质量平均分配到pinball region的每个节点上。因此，我们将pinball region改小，计算结果如下。</p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/620691d1fb3b465680feac28dd1fe4a5><p class=pgc-img-caption>图 15模态振型图</p></div><p>得到一阶固有频率为5.43Hz，和图10计算结果相比只减小了1.8%，但是为什么计算结果小于原模型计算结果呢？这主要是因为behavior为deformable，point mass就不会提供任何刚度。</p><p><strong>如果将behavior设置为rigid，计算结果如下。</strong></p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d545f880f3534675a491e78c2c05e857><p class=pgc-img-caption>图 16模态振型图</p></div><p>得到一阶固有频率为6.16Hz，和图10计算结果相比变大11%，这主要是因为behavior设置为rigid后，被耦合区域类似于刚体，这样整体刚度就提高了，导致计算结果偏大。</p><p><strong>总结一下计算结果，如下表所示。</strong></p><div class=pgc-img><img alt="有限元仿真分析误差来源之边界条件，约束和point mass" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/02e09fbeacc641a192cc03ec41118413><p class=pgc-img-caption></p></div><p><strong>因此，采用point mass简化时，behavior设置为deformable，pinball region减小到和原模型相同区域，可以得到较可信计算结果。</strong></p><p><strong>三、我的总结</strong></p><p>边界条件是有限元仿真建模的关键步骤，错误的边界条件设置会导致本来要解决甲问题但计算的却是乙问题。约束和point mass是边界条件设置中经常遇到的，本文将一些相关经验总结如下：</p><p>1、Fix support将一定区域的所有节点的所有自由度置为0，这样有可能导致过约束情况产生，最终导致计算误差。</p><p>2、Displacement可以约束一定区域的所有节点的部分自由度，具体问题需要具体分析</p><p>3、Remote point可以看出当采用remote point耦合底面节点的自由度时，并且将 behavior设置rigid，这样就和用hyperworks的rb2单元一样，将每个节点自由度和参考点耦合起来，用参考点自由度代替底面的自由度，被耦合的面就会变成刚体，如果设置成deformable，参考点和被约束面之间采用rbe3单元，这样被耦合面就是弹性体。</p><p>4、Point mass和Remote point类似，将 behavior设置rigid，被耦合的面就会变成刚体，将 behavior设置deformable，被耦合面是弹性体，质量会平均分配到被耦合的节点上。</p><p><strong>作者：</strong>青梅煮酒，仿真秀科普作者<br>声明：原创文章，首发仿真秀，部分图片源自网络，如有不当请联系我们，欢迎分享，禁止私自转载，转载请联系我们。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'有限元','误差','来源'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>