<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux kernelä¸­å¸¸è§çš„å®æ•´ç† | æå®¢å¿«è¨Š</title><meta property="og:title" content="Linux kernelä¸­å¸¸è§çš„å®æ•´ç† - æå®¢å¿«è¨Š"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/907ac78.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/907ac78.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/907ac78.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="Linux kernelä¸­å¸¸è§çš„å®æ•´ç†"><meta name=author content="æå®¢å¿«è¨Š"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/907ac78.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>ğŸ¤“ æå®¢å¿«è®¯ Geek Bank</a></h1><p class=description>ä¸ºä½ å¸¦æ¥æœ€å…¨çš„ç§‘æŠ€çŸ¥è¯† ğŸ§¡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>çŒœä½ å–œæ­¡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=ç§‘æŠ€>ç§‘æŠ€</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=éŠæˆ²>éŠæˆ²</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=ç§‘å­¸>ç§‘å­¸</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux kernelä¸­å¸¸è§çš„å®æ•´ç†</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>ç§‘æŠ€</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>0x00 å®çš„åŸºæœ¬çŸ¥è¯†</h1><pre>// object-like#define å®å æ›¿æ¢åˆ—è¡¨ æ¢è¡Œç¬¦//function-like#define å®å ([æ ‡è¯†ç¬¦åˆ—è¡¨]) æ›¿æ¢åˆ—è¡¨ æ¢è¡Œç¬¦</pre><p>æ›¿æ¢åˆ—è¡¨å’Œæ ‡è¯†ç¬¦åˆ—è¡¨éƒ½æ˜¯å°†å­—ç¬¦ä¸² token åŒ–ä»¥åçš„åˆ—è¡¨ã€‚åŒºåˆ«åœ¨äºæ ‡è¯†ç¬¦åˆ—è¡¨ä½¿ç”¨,ä½œä¸ºä¸åŒå‚æ•°ä¹‹é—´çš„åˆ†å‰²ç¬¦ã€‚æ¯ä¸€ä¸ªå‚æ•°éƒ½æ˜¯ä¸€ä¸ª token åŒ–çš„åˆ—è¡¨ã€‚åœ¨å®ä¸­ç©ºç™½ç¬¦åªèµ·åˆ°åˆ†å‰² token çš„ä½œç”¨ï¼Œç©ºç™½ç¬¦çš„å¤šå°‘å¯¹äºé¢„å¤„ç†å™¨æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚</p><p>å®çš„ä¸€äº›å¥‡æŠ€æ·«å·§ï¼š</p><p>https://gaomf.cn/2017/10/06/C_Macro/</p><p>ä»¥ä¸‹æ˜¯æ•´ç†çš„ä¸€äº›linux kernelä¸­çš„å¸¸è§å®ï¼Œç”±äºä¸åŒä½“ç³»æ¶æ„ï¼Œæˆ–è€…ä¸åŒæ¨¡å—çš„å®å®šä¹‰ä¸åŒï¼ŒåªæŒ‘é€‰äº†å…¶ä¸­å®¹æ˜“çœ‹æ‡‚çš„å®ä½œä¸ºè®°å½•ï¼Œå®ç°çš„åŠŸèƒ½å¤§ä½“ä¸€æ ·ã€‚</p><h1 class=pgc-h-arrow-right>Linuxå†…æ ¸ä¸­do{...}while(0)æ„ä¹‰ï¼š</h1><ul><li>è¾…åŠ©å®šä¹‰å¤æ‚çš„å®ï¼Œé¿å…å¼•ç”¨çš„æ—¶å€™å‡ºé”™ï¼Œå¦‚æœä¸ç”¨{}ï¼Œifåé¢çš„è¯­å¥åªæœ‰ç¬¬ä¸€æ¡è¿›è¡Œäº†åˆ¤æ–­ã€‚åŒæ—¶é¿å…å®å±•å¼€åâ€œ;â€é€ æˆç¼–è¯‘ä¸é€šè¿‡.</li><li>é¿å…ä½¿ç”¨gotoï¼Œå¯¹ç¨‹åºæµè¿›è¡Œç»Ÿä¸€çš„æ§åˆ¶ï¼Œä½¿ç”¨breakè·³å‡º</li><li>é¿å…ç©ºå®å¼•èµ·çš„warning</li><li>å®šä¹‰ä¸€ä¸ªå•ç‹¬çš„å‡½æ•°å—æ¥å®ç°å¤æ‚çš„æ“ä½œ</li></ul><h1 class=pgc-h-arrow-right>0x01 å¸¸è§å®æ•´ç†</h1><h1 class=pgc-h-arrow-right>__CONCATå®</h1><p>"##"ç”¨äºç²˜è´´ä¸¤ä¸ªå‚æ•°ï¼Œ"#"ç”¨äºæ›¿æ¢å‚æ•°ï¼š</p><pre>#define __CONCAT(a, b) a ## b</pre><h1 class=pgc-h-arrow-right>BUG_ON(condition)</h1><p>æ¡ä»¶ä¸ºçœŸï¼Œäº§ç”Ÿå´©æºƒï¼Œ åŸç†ï¼šæœªå®šä¹‰çš„å¼‚å¸¸ã€‚</p><p>ç›¸å¯¹åº”çš„æœ‰ WARN_ONï¼š</p><pre>#define BUG() assert(0)#define BUG_ON(x) assert(!(x)) /* Does it make sense to treat warnings as errors? */#define WARN() BUG()#define WARN_ON(x) (BUG_ON(x), false)</pre><h1 class=pgc-h-arrow-right>BUILD_BUG_ONå®</h1><pre>#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))</pre><ol start=1><li>conditionä¸ºçœŸæ—¶ï¼Œsizeof(char[-1])ï¼Œäº§ç”Ÿé”™è¯¯ï¼Œç¼–è¯‘ä¸é€šè¿‡</li><li>conditionä¸ºå‡æ—¶ï¼Œsizeof(char[1])ï¼Œç¼–è¯‘é€šè¿‡</li></ol><p>æ£€æŸ¥è¡¨è¾¾å¼eæ˜¯å¦ä¸º0ï¼Œä¸º0ç¼–è¯‘é€šè¿‡ä¸”è¿”å›0ï¼›å¦‚æœä¸ä¸º0ï¼Œåˆ™ç¼–è¯‘ä¸é€šè¿‡ã€‚</p><pre>struct { int : â€“!!(0); } -=&gt; struct { int : 0; }</pre><p>å¦‚æœeä¸º0ï¼Œåˆ™è¯¥ç»“æ„ä½“æ‹¥æœ‰ä¸€ä¸ªintå‹çš„æ•°æ®åŸŸï¼Œå¹¶ä¸”è§„å®šå®ƒæ‰€å çš„ä½çš„ä¸ªæ•°ä¸º0ã€‚</p><pre>struct { int : â€“!!(1); } -=&gt; struct { int : â€“1; }</pre><p>å¦‚æœeé0ï¼Œç»“æ„ä½“çš„intå‹æ•°æ®åŸŸçš„ä½åŸŸå°†å˜ä¸ºä¸€ä¸ªè´Ÿæ•°ï¼Œäº§ç”Ÿè¯­æ³•çš„é”™è¯¯ã€‚</p><p>typeofè·å¾—xçš„å˜é‡ç±»å‹ï¼Œæ ¹æ®ä¼ å…¥å‚æ•°ç±»å‹çš„ä¸åŒï¼Œäº§ç”Ÿä¸åŒçš„è¡Œä¸ºï¼Œå®ç°â€œç¼–è¯‘æ—¶å¤šæ€â€ã€‚å®é™…typeofæ˜¯åœ¨é¢„ç¼–è¯‘æ—¶å¤„ç†ï¼Œæœ€åå®é™…è½¬åŒ–ä¸ºæ•°æ®ç±»å‹è¢«ç¼–è¯‘å™¨å¤„ç†ã€‚</p><p>æ‰€ä»¥å…¶ä¸­çš„è¡¨è¾¾å¼åœ¨è¿è¡Œæ—¶æ˜¯ä¸ä¼šè¢«æ‰§è¡Œçš„ï¼Œæ¯”å¦‚typeof(fun())ï¼Œfun()å‡½æ•°æ˜¯ä¸ä¼šè¢«æ‰§è¡Œçš„ï¼Œtypeofåªæ˜¯åœ¨ç¼–è¯‘æ—¶åˆ†æå¾—åˆ°äº†fun()çš„è¿”å›å€¼è€Œå·²ã€‚</p><p>typeofè¿˜æœ‰ä¸€äº›å±€é™æ€§ï¼Œå…¶ä¸­çš„å˜é‡æ˜¯ä¸èƒ½åŒ…å«å­˜å‚¨ç±»è¯´æ˜ç¬¦çš„ï¼Œå¦‚staticã€externè¿™ç±»éƒ½æ˜¯ä¸è¡Œçš„ã€‚</p><h1 class=pgc-h-arrow-right>typecheckå®</h1><p>å®typecheckç”¨äºæ£€æŸ¥xæ˜¯å¦ä¸ºtypeç±»å‹ï¼Œå¦‚æœä¸æ˜¯ä¼šæŠ›å‡ºï¼ˆwarning: comparison of distinct pointer types lacks a castï¼‰ï¼Œtypecheck_fnç”¨äºæ£€æŸ¥å‡½æ•°functionæ˜¯å¦ä¸ºtypeç±»å‹ï¼Œä¸ä¸€è‡´è·‘å‡ºï¼ˆwarning: initialization from incompatible pointer typeï¼‰ã€‚</p><pre>/* * Check at compile time that something is of a particular type. * Always evaluates to 1 so you may use it easily in comparisons. */#define typecheck(type,x) \({ type __dummy; \    typeof(x) __dummy2; \    (void)(&amp;__dummy == &amp;__dummy2); \    1; \})/*GCCçš„ä¸€ä¸ªæ‰©å±•ç‰¹æ€§ï¼Œå½¢å¦‚({ ... })è¿™æ ·çš„ä»£ç å—ä¼šè¢«è§†ä¸ºä¸€æ¡è¯­å¥ï¼Œ* å…¶è®¡ç®—ç»“æœæ˜¯{ ... }ä¸­æœ€åä¸€æ¡è¯­å¥çš„è®¡ç®—ç»“æœã€‚* æ‰€ä»¥ä¸Šè¿°ä¼šè¿”å›1*//* * Check at compile time that &#39;function&#39; is a certain type, or is a pointer * to that type (needs to use typedef for the function type.) */#define typecheck_fn(type,function) \({ typeof(type) __tmp = function; \    (void)__tmp; \})</pre><h1 class=pgc-h-arrow-right>minå®</h1><p>é€šè¿‡typeè¿›è¡Œéšå¼è½¬æ¢å®‰å…¨é€šè¿‡ç¼–è¯‘ï¼Œå¦åˆ™ä¼šè·‘å‡ºwarningï¼š</p><pre>#define min(x, y) __careful_cmp(x, y, &lt;)#define __cmp(x, y, op) ((x) op (y) ? (x) : (y))#define __safe_cmp(x, y) \        (__typecheck(x, y) &amp;&amp; __no_side_effects(x, y))#define __no_side_effects(x, y) \        (__is_constexpr(x) &amp;&amp; __is_constexpr(y)) #define __cmp_once(x, y, unique_x, unique_y, op) ({ \        typeof(x) unique_x = (x); \        typeof(y) unique_y = (y); \        __cmp(unique_x, unique_y, op); })/*é‡æ–°èµ‹å€¼ä¸ºäº†é˜²æ­¢x++è¿™ç§é‡å¤+1 */#define __careful_cmp(x, y, op) \    __builtin_choose_expr(__safe_cmp(x, y), \ //æ¯”è¾ƒx, yçš„ç±»å‹        __cmp(x, y, op), \ //x,yç±»å‹ä¸€æ ·æ—¶        __cmp_once(x, y, __UNIQUE_ID(__x), __UNIQUE_ID(__y), op))          //x, yç±»å‹ä¸åŒæ—¶</pre><p>__UNIQUE_IDä¿è¯å˜é‡å”¯ä¸€ã€‚</p><h1 class=pgc-h-arrow-right>__is_constexprå®</h1><p>åˆ¤æ–­xæ˜¯å¦ä¸ºæ•´æ•°å¸¸é‡è¡¨è¾¾å¼ï¼š</p><pre>/* * This returns a constant expression while determining if an argument is * a constant expression, most importantly without evaluating the argument. * Glory to Martin Uecker &lt;Martin.Uecker@med.uni-goettingen.de&gt; */#define __is_constexpr(x) \    (sizeof(int) == sizeof(*(8 ? ((void *)((long)(x) * 0l)) : (int *)8)))</pre><p>å¦‚æœxæ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œåˆ™(void )((long)(x) 0l)æ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆå¸¸é‡ï¼Œå°±ä¼šä½¿ç”¨ç¬¬ä¸‰ä¸ªæ“ä½œæ•°å³((int *)8)çš„ç±»å‹ã€‚å¦‚æœä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼ï¼Œåˆ™ä¼šä½¿ç”¨ç¬¬äºŒä¸ªæ“ä½œæ•°voidç±»å‹ã€‚</p><p>æ‰€ä»¥ä¼šå‡ºç°ä»¥ä¸‹ä¸¤ç§æƒ…å†µï¼š</p><pre>sizeof(int) == sizeof(*((int *) (NULL))) // if `x` was an integer constant expressionsizeof(int) == sizeof(*((void *)(....))) // otherwise</pre><p>å› ä¸ºsizeof(void) = 1ï¼Œæ‰€ä»¥å¦‚æœxæ˜¯æ•´æ•°å¸¸é‡è¡¨è¾¾å¼ï¼Œåˆ™å®çš„ç»“æœä¸º1ï¼Œå¦åˆ™ä¸º0ã€‚</p><p>https://stackoverflow.com/questions/49481217/linux-kernels-is-constexpr-macro</p><p>æè¿°ï¼šæ­¤å‡½æ•°ä¸ºGNUæ‰©å±•ï¼Œç”¨æ¥åˆ¤æ–­ä¸¤ä¸ªç±»å‹æ˜¯å¦ç›¸åŒï¼Œå¦‚æœtype_aä¸ type_bç›¸åŒçš„è¯ï¼Œå°±ä¼šè¿”å›1ï¼Œå¦åˆ™çš„è¯ï¼Œè¿”å›0ã€‚</p><pre>int __builtin_choose_expr(exp, e1, e2);</pre><h1 class=pgc-h-arrow-right>maxå®</h1><p>åŒmin å®ã€‚</p><h1 class=pgc-h-arrow-right>roundupå®</h1><p>è¿”å›ä¸€ä¸ªèƒ½å¤Ÿæ•´é™¤yå¹¶ä¸”å¤§äºxï¼Œæœ€æ¥è¿‘xçš„å€¼ï¼Œå‘ä¸Šå–æ•´ï¼Œå¯ç”¨äºåœ°å€çš„å†…å­˜å¯¹é½ï¼š</p><pre>#define roundup(x, y) ( \{ \    const typeof(y) __y = y; \    (((x) + (__y - 1)) / __y) * __y; \} \)</pre><h1 class=pgc-h-arrow-right>clamp å®</h1><p>åˆ¤æ–­valæ˜¯å¦åœ¨loå’Œhiçš„èŒƒå›´å†…ï¼Œå¦‚æœå°äºloï¼Œè¿”å›loï¼Œå¦‚æœå¤§äºhiåˆ™è¿”å›hiï¼Œå¦‚æœåœ¨loå’Œhiä¹‹é—´å°±è¿”å›valï¼š</p><pre>/** * clamp - return a value clamped to a given range with strict typechecking * @val: current value * @lo: lowest allowable value * @hi: highest allowable value * * This macro does strict typechecking of @lo/@hi to make sure they are of the * same type as @val. See the unnecessary pointer comparisons. */#define clamp(val, lo, hi) min((typeof(val))max(val, lo), hi)</pre><h1 class=pgc-h-arrow-right>abså®</h1><p>å–ç»å¯¹å€¼ï¼š</p><pre>/** * abs - return absolute value of an argument * @x: the value. If it is unsigned type, it is converted to signed type first. * char is treated as if it was signed (regardless of whether it really is) * but the macro&#39;s return type is preserved as char. * * Return: an absolute value of x. */#define abs(x) __abs_choose_expr(x, long long, \        __abs_choose_expr(x, long, \        __abs_choose_expr(x, int, \        __abs_choose_expr(x, short, \        __abs_choose_expr(x, char, \        __builtin_choose_expr( \            __builtin_types_compatible_p(typeof(x), char), \            (char)({ signed char __x = (x); __x&lt;0?-__x:__x; }), \            ((void)0))))))) #define __abs_choose_expr(x, type, other) __builtin_choose_expr( \    __builtin_types_compatible_p(typeof(x), signed type) || \    __builtin_types_compatible_p(typeof(x), unsigned type), \    ({ signed type __x = (x); __x &lt; 0 ? -__x : __x; }), other)</pre><h1 class=pgc-h-arrow-right>swap å®</h1><p>åˆ©ç”¨typeofè·å–è¦äº¤æ¢å˜é‡çš„ç±»å‹ï¼š</p><pre>/* * swap - swap value of @a and @b */#define swap(a, b) \    do { typeof(a) __tmp = (a); (a) = (b); (b) = __tmp; } while (0)</pre><h1 class=pgc-h-arrow-right>container_ofå®</h1><p>æ ¹æ®ä¸€ä¸ªç»“æ„ä½“å˜é‡ä¸­çš„æˆå‘˜å˜é‡æ¥è·å–æ•´ä¸ªç»“æ„ä½“å˜é‡çš„æŒ‡é’ˆã€‚</p><pre>#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)/*ç»“æ„ä½“åœ°å€ä¸º0ï¼Œå°†memberåœ°å€è½¬æˆsize_tç±»å‹ä½œä¸ºåç§»/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */#define container_of(ptr, type, member) ({ \    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \ //*__mpträ¿å­˜è¯¥memberå˜é‡çš„æŒ‡é’ˆ    (type *)( (char *)__mptr - offsetof(type,member) );}) //å˜é‡æŒ‡é’ˆå‡å»è‡ªèº«åç§»å¾—åˆ°æŒ‡å‘ç»“æ„ä½“çš„æŒ‡é’ˆ</pre><h3 class=pgc-h-arrow-right>likelyå’Œunlikelyå®</h3><p>æŠŠåˆ†æ”¯é¢„æµ‹çš„ä¿¡æ¯æä¾›ç»™ç¼–è¯‘å™¨ï¼Œä»¥é™ä½å› ä¸ºæŒ‡ä»¤è·³è½¬å¸¦æ¥çš„åˆ†æ”¯ä¸‹é™ï¼š</p><pre>#define likely(x) __builtin_exp ect(!!(x), 1)#define unlikely(x) __builtin_exp ect(!!(x), 0)</pre><p>GCCçš„å†…å»ºæ–¹æ³•ä¼šåˆ¤æ–­ EXP == C æ˜¯å¦æˆç«‹ï¼Œæˆç«‹åˆ™å°†ifåˆ†æ”¯ä¸­çš„æ‰§è¡Œè¯­å¥ç´§è·Ÿæ”¾åœ¨æ±‡ç¼–è·³è½¬æŒ‡ä»¤ä¹‹åï¼Œå¦åˆ™å°†elseåˆ†æ”¯ä¸­çš„æ‰§è¡Œè¯­å¥ç´§è·Ÿæ±‡ç¼–è·³è½¬æŒ‡ä»¤ä¹‹åã€‚</p><p>è¿™æ ·cacheåœ¨é¢„å–æ•°æ®æ—¶å°±å¯ä»¥å°†åˆ†æ”¯åçš„æ‰§è¡Œè¯­å¥æ”¾åœ¨cacheä¸­ï¼Œæé«˜cacheçš„å‘½ä¸­ç‡ã€‚</p><h1 class=pgc-h-arrow-right>ALIGNå¯¹é½å®</h1><p>å¯¹é½æ˜¯é‡‡ç”¨ä¸Šå¯¹é½çš„æ–¹å¼ï¼Œä¾‹å¦‚0x123ä»¥16å¯¹é½ï¼Œç»“æœæ˜¯0x130ï¼Œå› ä¸ºå¯¹é½å¸¸åœ¨åˆ†é…å†…å­˜æ—¶ä½¿ç”¨ï¼Œæ‰€ä»¥åˆ†é…çš„è¦æ¯”éœ€è¦çš„å¤§ã€‚</p><pre>#define ALIGN(x, a) __ALIGN_KERNEL((x), (a))#define __ALIGN_KERNEL(x, a) __ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)#define __ALIGN_KERNEL_MASK(x, mask) (((x) + (mask)) &amp; ~(mask))#define __ALIGN_MASK(x, mask) __ALIGN_KERNEL_MASK((x), (mask))</pre><h1 class=pgc-h-arrow-right>__get_unaligned_le(ptr)å®</h1><p>è·å–æœªå¯¹é½çš„æ•°æ®ï¼Œä¸»è¦æ˜¯è¯†åˆ«æ•°æ®å¤§å°ï¼š</p><pre>#define __get_unaligned_le(ptr) ((__force typeof(*(ptr)))({ \    __builtin_choose_expr(sizeof(*(ptr)) == 1, *(ptr), \    __builtin_choose_expr(sizeof(*(ptr)) == 2, get_unaligned_le16((ptr)), \    __builtin_choose_expr(sizeof(*(ptr)) == 4, get_unaligned_le32((ptr)), \    __builtin_choose_expr(sizeof(*(ptr)) == 8, get_unaligned_le64((ptr)), \    __bad_unaligned_access_size())))); \ }))  static inline u32 get_unaligned_be32(const void *p){    return __get_unaligned_cpu32((const u8 *)p);} static inline u32 __get_unaligned_cpu32(const void *p){    const struct __una_u32 *ptr = (const struct __una_u32 *)p;    return ptr-&gt;x;} struct __una_u16 { u16 x; } __packed;struct __una_u32 { u32 x; } __packed;struct __una_u64 { u64 x; } __packed;</pre><p>ç¼–è¯‘å™¨é»˜è®¤ä¼šå¯¹ç»“æ„ä½“é‡‡ç”¨å­—èŠ‚å¯¹é½çš„æ–¹å¼ï¼Œ__packedå…³é”®å­—å¯ä»¥å–æ¶ˆå­—èŠ‚å¯¹é½ï¼Œé‡‡ç”¨1å­—èŠ‚å¯¹é½ã€‚</p><h1 class=pgc-h-arrow-right>__put_unaligned_leå®</h1><p>å†™å…¥æœªå¯¹é½çš„æ•°æ®ã€‚</p><pre>#define __put_unaligned_le(val, ptr) ({ \    void *__gu_p = (ptr); \    switch (sizeof(*(ptr))) { \    case 1: \        *(u8 *)__gu_p = (__force u8)(val); \        break; \    case 2: \        put_unaligned_le16((__force u16)(val), __gu_p); \        break; \    case 4: \        put_unaligned_le32((__force u32)(val), __gu_p); \        break; \    case 8: \        put_unaligned_le64((__force u64)(val), __gu_p); \        break; \    default: \        __bad_unaligned_access_size(); \        break; \    } \    (void)0; })  static inline void put_unaligned_be32(u32 val, void *p){    __put_unaligned_cpu32(val, p);} static inline void __put_unaligned_cpu32(u32 val, void *p){    struct __una_u32 *ptr = (struct __una_u32 *)p;    ptr-&gt;x = val;}</pre><h1 class=pgc-h-arrow-right>ACCESS_ONCE å®</h1><p>è®¿é—®ç›®æ ‡åœ°å€ä¸€æ¬¡ï¼Œå…ˆå–å¾—xçš„åœ°å€ï¼Œç„¶åæŠŠè¿™ä¸ªåœ°å€è½¬æ¢æˆä¸€ä¸ªæŒ‡å‘è¿™ä¸ªåœ°å€ç±»å‹çš„æŒ‡é’ˆï¼Œç„¶åå†å–å¾—è¿™ä¸ªæŒ‡é’ˆæ‰€æŒ‡å‘çš„å†…å®¹ï¼Œè¾¾åˆ°äº†è®¿é—®ä¸€æ¬¡çš„ç›®çš„ã€‚volatileè¡¨ç¤ºä¸è¿›è¡Œä¼˜åŒ–ï¼Œå¼ºåˆ¶è®¿é—®ä¸€æ¬¡ã€‚</p><p>åœ¨ä¸€äº›å¹¶å‘çš„åœºæ™¯ä¸­å¯¹å˜é‡è¿›è¡Œä¼˜åŒ–æœ‰å¯èƒ½å¯¼è‡´é”™è¯¯ï¼Œéœ€è¦æ—¶åˆ»å¾—åˆ°å˜é‡çš„æœ€æ–°å€¼ï¼Œæ‰€ä»¥ç”¨volatileå¼ºåˆ¶è®¿é—®ä¸€æ¬¡è¿›è¡Œæ›´æ–°ã€‚</p><p>ä½¿ç”¨ ACCESS_ONCE() çš„ä¸¤ä¸ªæ¡ä»¶æ˜¯ï¼š</p><ul><li>åœ¨æ— é”çš„æƒ…å†µä¸‹è®¿é—®å…¨å±€å˜é‡</li><li>å¯¹è¯¥å˜é‡çš„è®¿é—®å¯èƒ½è¢«ç¼–è¯‘å™¨ä¼˜åŒ–æˆåˆå¹¶æˆä¸€æ¬¡æˆ–è€…æ‹†åˆ†æˆå¤šæ¬¡</li></ul><pre>#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))</pre><p>https://blog.csdn.net/ganggexiongqi/article/details/24603363</p><h1 class=pgc-h-arrow-right>ACCESS_OKå®</h1><p>CVE-2017-5123ï¼ˆwaitidç³»ç»Ÿè°ƒç”¨ï¼‰,æ£€æŸ¥æŒ‡é’ˆæ˜¯ä¸æ˜¯å±äºç”¨æˆ·ç©ºé—´çš„ï¼Œx86æ¶æ„ä¸‹ACCESS_OKå®çš„å®ç°ï¼š</p><pre>/** * access_ok: - Checks if a user space pointer is valid * @addr: User space pointer to start of block to check * @size: Size of block to check * * Context: User context only. This function may sleep if pagefaults are * enabled. * * Checks if a pointer to a block of memory in user space is valid. * * Returns true (nonzero) if the memory block may be valid, false (zero) * if it is definitely invalid. * * Note that, depending on architecture, this function probably just * checks that the pointer is in the user space range - after calling * this function, memory access functions may still return -EFAULT. */#define access_ok(addr, size) \({ \    WARN_ON_IN_IRQ(); \    likely(!__range_not_ok(addr, size, user_addr_max())); \})/*__range_not_okè¿”å›0æ‰èƒ½éªŒè¯é€šè¿‡ #define __range_not_ok(addr, size, limit) \({ \    __chk_user_ptr(addr); \    __chk_range_not_ok((unsigned long __force)(addr), size, limit); \}) /* * Test whether a block of memory is a valid user space address. * Returns 0 if the range is valid, nonzero otherwise. */static inline bool __chk_range_not_ok(unsigned long addr, unsigned long size, unsigned long limit){    /*     * If we have used &#34;sizeof()&#34; for the size,     * we know it won&#39;t overflow the limit (but     * it might overflow the &#39;addr&#39;, so it&#39;s     * important to subtract the size from the     * limit, not add it to the address).     */    if (__builtin_constant_p(size))        return unlikely(addr &gt; limit - size);    /*__builtin_constant_påˆ¤æ–­ç¼–è¯‘æ—¶æ˜¯å¦ä¸ºå¸¸æ•°ï¼Œå¦‚æœæ˜¯åˆ™è¿”å›1 */    /* Arbitrary sizes? Be careful about overflow */    addr += size;    if (unlikely(addr &lt; size))        return true;    return unlikely(addr &gt; limit);}</pre><h1 class=pgc-h-arrow-right>mdelayå®</h1><p>å¿™ç­‰å¾…å‡½æ•°ï¼Œåœ¨å»¶è¿Ÿè¿‡ç¨‹ä¸­æ— æ³•è¿è¡Œå…¶ä»–ä»»åŠ¡ï¼Œä¼šå ç”¨CPUæ—¶é—´ï¼Œå»¶è¿Ÿæ—¶é—´æ˜¯å‡†ç¡®çš„ã€‚</p><p>msleepæ˜¯ä¼‘çœ å‡½æ•°ï¼Œå®ƒä¸æ¶‰åŠå¿™ç­‰å¾…ï¼ç”¨msleepï¼ˆ200ï¼‰çš„æ—¶å€™å®é™…ä¸Šå»¶è¿Ÿçš„æ—¶é—´ï¼Œå¤§éƒ¨åˆ†æ—¶å€™æ˜¯è¦å¤šäº200msï¼Œæ˜¯ä¸ªä¸å®šçš„æ—¶é—´å€¼ã€‚</p><pre>#define MAX_UDELAY_MS 5#define mdelay(n) (\ /*å»¶è¿Ÿæ¯«ç§’çº§*/    (__builtin_constant_p(n) &amp;&amp; (n)&lt;=MAX_UDELAY_MS) ? udelay((n)*1000) : \    ({unsigned long __ms=(n); while (__ms--) udelay(1000);})) static void udelay(int loops) /*å»¶è¿Ÿå¾®ç§’çº§ */{    while (loops--)        io_delay(); /* Approximately 1 us */} static inline void io_delay(void){    const u16 DELAY_PORT = 0x80;    asm volatile(&#34;outb %%al,%0&#34; : : &#34;dN&#34; (DELAY_PORT));}/*å¯¹ I/O ç«¯å£ 0x80 å†™å…¥ä»»ä½•çš„å­—èŠ‚éƒ½å°†å¾—åˆ° 1 us çš„å»¶æ—¶*/</pre><h3 class=pgc-h-arrow-right>ç³»ç»Ÿè°ƒç”¨å®</h3><p>linux å†…æ ¸ä¸­æœ€å¸¸è§çš„å®ä½¿ç”¨ä¹‹ä¸€ï¼Œç³»ç»Ÿè°ƒç”¨ï¼š</p><pre>#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)/*â€¦ï¼šçœç•¥å·ä»£è¡¨å¯å˜çš„éƒ¨åˆ†ï¼Œç”¨__VA_AEGS__ ä»£è¡¨çœç•¥çš„å˜é•¿éƒ¨åˆ†*/#define SYSCALL_DEFINE_MAXARGS    6  /*ç³»ç»Ÿè°ƒç”¨æœ€å¤šå¯ä»¥å¸¦6ä¸ªå‚æ•°*/</pre><p>ä»¥openç³»ç»Ÿè°ƒç”¨ä¸ºä¾‹ï¼š</p><p>SYSCALL_DEFINE</p><p>åé¢è·Ÿç³»ç»Ÿè°ƒç”¨æ‰€å¸¦çš„å‚æ•°ä¸ªæ•°nï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºç³»ç»Ÿè°ƒç”¨çš„åå­—ï¼Œç„¶åæ¥2*nä¸ªå‚æ•°ï¼Œæ¯ä¸€å¯¹æŒ‡æ˜ç³»ç»Ÿè°ƒç”¨çš„å‚æ•°ç±»å‹åŠåå­—ã€‚</p><pre>SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode){    if (force_o_largefile())        flags |= O_LARGEFILE;     return do_sys_open(AT_FDCWD, filename, flags, mode);}SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)å±•å¼€ä¹‹åæ˜¯ï¼šSYSCALL_DEFINEx(3, _open, __VA_ARGS__)</pre><p>å†æ¬¡å±•å¼€ä¸ºï¼š</p><pre>__SYSCALL_DEFINEx(3, _open, __VA_ARGS__)#define __SYSCALL_DEFINEx(x, name, ...) \    asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__)) \</pre><p>æœ€åå±•å¼€ä¸ºï¼š</p><pre>asmlinkage long sys_open(__MAP(3,__SC_DECL,__VA_ARGS__)) #define __MAP0(m,...)#define __MAP1(m,t,a) m(t,a)#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)#define __MAP(n,...) __MAP##n(__VA_ARGS__) #define __SC_DECL(t, a) t a __MAP(3,__SC_DECL,__VA_ARGS__)--&gt;__MAP3(__SC_DECL,const char __user *, filename, int, flags, umode_t, mode)--&gt;__SC_DECL(const char __user *, filename), __MAP2(__SC_DECL,__VA_ARGS__)--&gt;const char __user * filename,__SC_DECL(int, flags),__MAP1(__SC_DECL,__VA_ARGS__)--&gt;const char __user * filename, int flags, __SC_DECL(umode_t, mode)--&gt;const char __user * filename, int flags, umode_t mode</pre><p>æœ€åè°ƒç”¨asmlinkage long sys_open(const char __user *filename,int flags, umode_t mode);</p><p>ä¸ºä»€ä¹ˆè¦å°†ç³»ç»Ÿè°ƒç”¨å®šä¹‰æˆå®ï¼ŸCVE-2009-0029ï¼ŒCVE-2010-3301ï¼ŒLinux 2.6.28åŠä»¥å‰ç‰ˆæœ¬çš„å†…æ ¸ä¸­ï¼Œå°†ç³»ç»Ÿè°ƒç”¨ä¸­32ä½å‚æ•°ä¼ å…¥64ä½çš„å¯„å­˜å™¨æ—¶æ— æ³•ä½œç¬¦å·æ‰©å±•ï¼Œå¯èƒ½å¯¼è‡´ç³»ç»Ÿå´©æºƒæˆ–ææƒæ¼æ´ã€‚</p><p>å†…æ ¸å¼€å‘è€…é€šè¿‡å°†ç³»ç»Ÿè°ƒç”¨çš„æ‰€æœ‰è¾“å…¥å‚æ•°éƒ½å…ˆè½¬åŒ–æˆlongç±»å‹ï¼ˆ64ä½ï¼‰ï¼Œå†å¼ºåˆ¶è½¬åŒ–åˆ°ç›¸åº”çš„ç±»å‹æ¥è§„é¿è¿™ä¸ªæ¼æ´ã€‚</p><pre>asmlinkage long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__)) \{ \        long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\        __MAP(x,__SC_TEST,__VA_ARGS__); \        __PROTECT(x, ret,__MAP(x,__SC_ARGS,__VA_ARGS__)); \        return ret; \} \  #define __TYPE_AS(t, v) __same_type((__force t)0, v) /*åˆ¤æ–­tå’Œvæ˜¯å¦æ˜¯åŒä¸€ä¸ªç±»å‹*/#define __TYPE_IS_L(t) (__TYPE_AS(t, 0L)) /*åˆ¤æ–­tæ˜¯å¦æ˜¯long ç±»å‹,æ˜¯è¿”å›1*/#define __TYPE_IS_UL(t) (__TYPE_AS(t, 0UL)) /*åˆ¤æ–­tæ˜¯å¦æ˜¯unsigned long ç±»å‹,æ˜¯è¿”å›1*/#define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))/*æ˜¯longç±»å‹å°±è¿”å›1*/#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a/*å°†å‚æ•°è½¬æ¢æˆlongç±»å‹*/#define __SC_CAST(t, a) (__force t) a /*è½¬æˆæˆåŸæ¥çš„ç±»å‹*/# define __force __attribute__((force))</pre><p>è¡¨ç¤ºæ‰€å®šä¹‰çš„å˜é‡ç±»å‹å¯ä»¥åšå¼ºåˆ¶ç±»å‹è½¬æ¢</p><h1 class=pgc-h-arrow-right>barrier()å®</h1><p>å†…å­˜å±éšœï¼Œè¯¥è¯­å¥ä¸äº§ç”Ÿä»»ä½•ä»£ç ï¼Œä½†æ˜¯æ‰§è¡Œååˆ·æ–°å¯„å­˜å™¨å¯¹å˜é‡çš„åˆ†é…ã€‚</p><pre>/* Optimization barrier *//* The &#34;volatile&#34; is due to gcc bugs */#define barrier() __asm__ __volatile__(&#34;&#34;: : :&#34;memory&#34;)</pre><p>æ‰§è¡Œè¯¥è¯­å¥åcpuä¸­çš„å¯„å­˜å™¨å’Œcacheä¸­å·²ç¼“å­˜çš„æ•°æ®å°†ä½œåºŸï¼Œé‡æ–°è¯»å–å†…å­˜ä¸­çš„æ•°æ®ã€‚è¿™å°±é˜»æ­¢äº†cpuå°†å¯„å­˜å™¨å’Œcacheä¸­çš„æ•°æ®ç”¨äºå»ä¼˜åŒ–æŒ‡ä»¤ï¼Œè€Œé¿å…å»è®¿é—®å†…å­˜ã€‚ä¾‹å¦‚ï¼š</p><pre>int a = 5, b = 6;barrier();a = b;</pre><p>ç¬¬ä¸‰è¡Œä¸­ï¼ŒGCCä¸ä¼šç”¨å­˜æ”¾bçš„å¯„å­˜å™¨ç»™aèµ‹å€¼ï¼Œè€Œæ˜¯invalidate b çš„cache lineï¼Œé‡æ–°è¯»å–å†…å­˜ä¸­çš„bå€¼ç»™aèµ‹å€¼ã€‚</p><p>å¦å¤–çš„å†…å­˜å±éšœå®å®šä¹‰ï¼š</p><ul><li>mfenceï¼šåœ¨mfenceæŒ‡ä»¤å‰çš„è¯»å†™æ“ä½œå½“å¿…é¡»åœ¨mfenceæŒ‡ä»¤åçš„è¯»å†™æ“ä½œå‰å®Œæˆã€‚</li><li>lfenceï¼šåœ¨lfenceæŒ‡ä»¤å‰çš„è¯»æ“ä½œå½“å¿…é¡»åœ¨lfenceæŒ‡ä»¤åçš„è¯»æ“ä½œå‰å®Œæˆï¼Œä¸å½±å“å†™æ“ä½œ</li><li>sfenceï¼šåœ¨sfenceæŒ‡ä»¤å‰çš„å†™æ“ä½œå½“å¿…é¡»åœ¨sfenceæŒ‡ä»¤åçš„å†™æ“ä½œå‰å®Œæˆï¼Œä¸å½±å“è¯»æ“ä½œ</li><li>lock å‰ç¼€ï¼ˆæˆ–cpuidã€xchgç­‰æŒ‡ä»¤ï¼‰ä½¿å¾—æœ¬CPUçš„Cacheå†™å…¥å†…å­˜ï¼Œè¯¥å†™å…¥åŠ¨ä½œä¹Ÿä¼šå¼•èµ·åˆ«çš„CPU invalidateå…¶Cacheã€‚ç”¨æ¥ä¿®é¥°å½“å‰æŒ‡ä»¤æ“ä½œçš„å†…å­˜åªèƒ½ç”±å½“å‰CPUä½¿ç”¨</li></ul><p>å†…å­˜å¯¹äºç¼“å­˜æ›´æ–°ç­–ç•¥ï¼Œè¦åŒºåˆ†Write-Throughå’ŒWrite-Backä¸¤ç§ç­–ç•¥ã€‚å‰è€…æ›´æ–°å†…å®¹ç›´æ¥å†™å†…å­˜å¹¶ä¸åŒæ—¶æ›´æ–°Cacheï¼Œä½†è¦ç½®Cacheå¤±æ•ˆï¼Œåè€…å…ˆæ›´æ–°Cacheï¼Œéšåå¼‚æ­¥æ›´æ–°å†…å­˜ã€‚é€šå¸¸X86 CPUæ›´æ–°å†…å­˜éƒ½ä½¿ç”¨Write-Backç­–ç•¥ã€‚</p><h1 class=pgc-h-arrow-right>#ifdef ASSEMBLYå®</h1><p>ä¸€äº›å¸¸é‡å®åŒæ—¶åœ¨æ±‡ç¼–å’ŒCä¸­ä½¿ç”¨ï¼Œç„¶è€Œï¼Œæˆ‘ä»¬ä¸èƒ½åƒæ³¨é‡ŠCçš„å¸¸é‡å®é‚£æ ·åŠ ä¸€ä¸ªâ€œULâ€æˆ–å…¶ä»–åç¼€ã€‚æ‰€ä»¥æˆ‘ä»¬éœ€è¦ä½¿ç”¨ä»¥ä¸‹çš„å®è§£å†³è¿™ä¸ªé—®é¢˜ã€‚</p><p>ä¾‹å¦‚è°ƒç”¨ï¼š#define DEMO_MACRO _AT(1ï¼Œ UL)ï¼šåœ¨Cä¸­ä¼šè¢«è§£é‡Šä¸º #define DEMO_MACRO 1ULï¼› è€Œåœ¨æ±‡ç¼–ä¸­ä»€ä¹ˆéƒ½ä¸åšï¼Œå°±æ˜¯ï¼š#define DEMO_MACRO 1</p><pre>#ifdef __ASSEMBLY__#define _AC(X,Y) X#define _AT(T,X) X#else#define __AC(X,Y) (X##Y)#define _AC(X,Y) __AC(X,Y)#define _AT(T,X) ((T)(X))#endif #define _UL(x) (_AC(x, UL))#define _ULL(x) (_AC(x, ULL))</pre><h1 class=pgc-h-arrow-right>force_o_largefileå®</h1><p>åˆ¤æ–­æ˜¯å¦æ”¯æŒå¤§æ–‡ä»¶ã€‚</p><p>#define force_o_largefile()<br>(personality(current->personality) != PER_LINUX32)</p><p>PER_LINUX32 = 0x0008, PER_MASK = 0x00ff, /*ï¼Œ</p><ul><li>Return the base personality without flags. */ #define personality(pers) (pers & PER_MASK)</li></ul><p>é€»è¾‘åœ°å€å’Œç‰©ç†åœ°å€äº’ç›¸è½¬æ¢</p><pre>#define __pa(x) __virt_to_phys((unsigned long)(x))#define __va(x) ((void *)__phys_to_virt((unsigned long)(x)))</pre><h1 class=pgc-h-arrow-right>é”™è¯¯ç ç›¸å…³çš„å®</h1><p>linux å†…æ ¸çš„ä¸€äº›é”™è¯¯ç ï¼Œä»¥å®ƒä»¬çš„è´Ÿæ•°æ¥ä½œä¸ºå‡½æ•°è¿”å›å€¼ï¼Œç®€å•åœ°ä½¿ç”¨å¤§äºç­‰äº-4095çš„è™šæ‹Ÿåœ°å€æ¥åˆ†åˆ«è¡¨ç¤ºç›¸åº”çš„é”™è¯¯ç ã€‚</p><p>åœ¨32ä½ç³»ç»Ÿä¸Šï¼Œ-4095è½¬æ¢æˆunsigned longç±»å‹çš„å€¼ä¸º0xFFFFF001ï¼Œä¹Ÿå°±æ˜¯è¯´åœ°å€åŒºé—´[0xFFFFF001, 0xFFFFFFFF]è¢«åˆ†åˆ«ç”¨æ¥è¡¨ç¤ºé”™è¯¯ç ä»-4095åˆ°-1ã€‚</p><p>åˆ¤æ–­ä¸€ä¸ªå‡½æ•°è¿”å›çš„æŒ‡é’ˆåˆ°åº•æ˜¯æœ‰æ•ˆåœ°å€è¿˜æ˜¯é”™è¯¯ç ï¼š</p><pre>#define MAX_ERRNO 4095 #define IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO) static inline long __must_check IS_ERR(const void *ptr){    return IS_ERR_VALUE((unsigned long)ptr);}</pre><p>é”™è¯¯ç ä¸ç›¸åº”åœ°å€çš„äº’æ¢ï¼š</p><pre>static inline void * __must_check ERR_PTR(long error){    return (void *) error;}</pre><p>é•¿æ•´å‹è½¬åŒ–ä¸ºæŒ‡é’ˆ</p><pre>static inline long __must_check PTR_ERR(const void *ptr){    return (long) ptr;}</pre><p>æŒ‡é’ˆè½¬åŒ–ä¸ºé•¿æ•´å‹</p><h1 class=pgc-h-arrow-right>é¢å¤–æœ‰æ„æ€çš„å®</h1><p>é€’å½’å®ï¼Œé¢ å€’å­—èŠ‚ï¼š</p><pre>#define BSWAP_8(x) ((x) &amp; 0xff)#define BSWAP_16(x) ((BSWAP_8(x) &lt;&lt; 8) | BSWAP_8((x) &gt;&gt; 8))#define BSWAP_32(x) ((BSWAP_16(x) &lt;&lt; 16) | BSWAP_16((x) &gt;&gt; 16))#define BSWAP_64(x) ((BSWAP_32(x) &lt;&lt; 32) | BSWAP_32((x) &gt;&gt; 32))</pre><p>äº¤æ¢å®ï¼Œä¸éœ€è¦é¢å¤–å®šä¹‰å˜é‡</p><pre>#define swap(a, b) \(((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))</pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','kernel','ä¸­å¸¸'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=æœç´¢>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>ğŸ”</button></form></section><section class=widget><h3 class=widget-title>æœ€æ–°æ–‡ç«  âš¡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>å…¶ä»–</h3><ul class=widget-list><li><a href=TOS.html>ä½¿ç”¨æ¢æ¬¾</a></li><li><a href=CommentPolicy.html>ç•™è¨€æ”¿ç­–</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>è¯çµ¡æˆ‘å€‘</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>æå®¢å¿«è¨Š</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>