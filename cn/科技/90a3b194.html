<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring：AOP 面向切面编程 | 极客快訊</title><meta property="og:title" content="Spring：AOP 面向切面编程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/90a3b194.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/90a3b194.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Spring：AOP 面向切面编程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/90a3b194.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring：AOP 面向切面编程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="Spring：AOP 面向切面编程" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>转账案例</h1><p>需求：使用 spring 框架整合 DBUtils 技术，实现用户转账功能</p><h1 class=pgc-h-arrow-right><strong>基础功能</strong></h1><p>步骤分析：</p><ol start=1><li>创建 java 项目，导入座标</li><li>编写 Account 实体类</li><li>编写 AccountDao 接口和实现类</li><li>编写 AccountService 接口和实现类</li><li>编写 spring 核心配置文件</li><li>编写测试代码</li></ol><h1 class=pgc-h-arrow-right><strong>创建 java 项目，导入座标</strong></h1><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.47&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba&lt;/groupId&gt;        &lt;artifactId&gt;druid&lt;/artifactId&gt;        &lt;version&gt;1.1.15&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;commons-dbutils&lt;/groupId&gt;        &lt;artifactId&gt;commons-dbutils&lt;/artifactId&gt;        &lt;version&gt;1.6&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;​    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.13&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>编写 AccountDao 接口和实现类</strong></h1><pre><code>public interface AccountDao {    /**     * 转出操作     * @param outUser     * @param money     */    void out(String outUser,Double money);​    /**     * 转入操作     * @param inUser     * @param money     */    void in(String inUser,Double money);}@Repository("AccountDao")public class AccountDaoImpl implements AccountDao {    @Autowired    private QueryRunner queryRunner;​    @Override    public void out(String outUser, Double money) {        String sql = "update account set money = money - ? where name = ?";        try {            queryRunner.update(sql, money, outUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }​    @Override    public void in(String inUser, Double money) {        String sql = "update account set money = money + ? where name = ?";        try {            queryRunner.update(sql, money, inUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>编写 AccountService 接口和实现类</strong></h1><pre><code>public interface AccountService {        /**         * 转账方法         */        void transfer(String outUser,String inUser,Double money);}@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    /**     * 转账方法     */    @Override    public void transfer(String outUser, String inUser, Double money) {        // 编写了事务相关代码        // 调用了减钱方法        accountDao.out(outUser,money);        // 模拟出错        // int i= 1/0;        // 调用了加钱方法        accountDao.in(inUser,money);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>编写 spring 核心配置文件</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="       	http://www.springframework.org/schema/beans		http://www.springframework.org/schema/beans/spring-beans.xsd       	http://www.springframework.org/schema/context		http://www.springframework.org/schema/context/spring-context.xsd		http://www.springframework.org/schema/aop		http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;    &lt;!-- 引入 properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;    &lt;!-- 配置 DataSource --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;        &lt;property name="url" value="${jdbc.url}"/&gt;        &lt;property name="username" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;    &lt;/bean&gt;    &lt;!-- 配置 queryRunner --&gt;    &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"&gt;        &lt;constructor-arg name="ds" ref="dataSource"/&gt;    &lt;/bean&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>编写测试代码</strong></h1><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration({"classpath:applicationContext.xml"})public class AccountServiceTest {    @Autowired    private AccountService accountService;    @Test    public void testTransfer() {        accountService.transfer("tom", "jerry", 100d);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>问题分析</strong></h1><p>上面的代码事务在 Dao 层，转出转入操作都是一个独立的事务，但实际开发，应该把业务逻辑控制在一个事务中，所以应该将事务挪到 Service 层。</p><h1 class=pgc-h-arrow-right><strong>传统事务</strong></h1><p>步骤分析：</p><ol start=1><li>编写线程绑定工具类</li><li>编写事务管理器</li><li>修改 service 层代码</li><li>修改 dao 层代码</li></ol><h1 class=pgc-h-arrow-right><strong>编写线程绑定工具类</strong></h1><pre><code>@Componentpublic class ConnectionUtils {    @Autowired    private DataSource dataSource;​    private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;();​    /**     * 获取当前线程上绑定连接：如果获取到的连接为空，那么就要从数据源中获取连接，并且放到 ThreadLocal 中（绑定到当前线程）     */    public Connection getThreadConnection() {        // 1.先从 ThreadLocal 上获取连接        Connection connection = threadLocal.get();        // 2.判断当前线程中是否是有 Connection        if(connection == null){            // 3.从数据源中获取一个连接，并且存入 ThreadLocal 中            try {                // 不为 null                connection = dataSource.getConnection();                threadLocal.set(connection);            } catch (SQLException e) {                e.printStackTrace();            }        }        return  connection;    }​    /**     * 解除当前线程的连接绑定     */    public void  removeThreadConnection(){        threadLocal.remove();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>编写事务管理器</strong></h1><pre><code>@Component("transactionManager")public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;​    /**     * 开启事务     */    public void beginTransaction(){        // 获取 connection 对象        Connection connection = connectionUtils.getThreadConnection();        try {            // 开启了一个手动事务            connection.setAutoCommit(false);        } catch (SQLException e) {            e.printStackTrace();        }    }​    /**     * 提交事务     */    public void commit(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.commit();        } catch (SQLException e) {            e.printStackTrace();        }    }​    /**     * 回滚事务     */    public void rollback(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.rollback();        } catch (SQLException e) {            e.printStackTrace();        }    }​    /**     * 释放资源     */    public void release(){        // 将手动事务改回成自动提交事务        Connection connection = connectionUtils.getThreadConnection();        try {            connection.setAutoCommit(true);            // 将连接归还到连接池            connectionUtils.getThreadConnection().close();            // 解除线程绑定            connectionUtils.removeThreadConnection();        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>修改 service 层代码</strong></h1><pre><code>@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    @Autowired    private TransactionManager transactionManager;    @Override    public void transfer(String outUser, String inUser, Double money) {        try {            // 1.开启事务            transactionManager.beginTransaction();            // 2.业务操作            // 编写了事务相关代码            // 调用了减钱方法            accountDao.out(outUser, money);            // 模拟出错            // int i= 1/0;            // 调用了加钱方法            accountDao.in(inUser, money);            // 3.提交事务            transactionManager.commit();        } catch (Exception e) {            // 4.回滚事务            transactionManager.rollback();            e.printStackTrace();        } finally {            // 5.释放资源            transactionManager.release();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>修改 Dao 层代码</strong></h1><pre><code>@Repository("AccountDao")public class AccountDaoImpl implements AccountDao {    @Autowired    private QueryRunner queryRunner;    @Autowired    private ConnectionUtils connectionUtils;    /**     * 转出操作     */    @Override    public void out(String outUser, Double money) {        String sql = "update account set money = money - ? where name = ?";        try {            queryRunner.update(connectionUtils.getThreadConnection(), sql, money, outUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }    /**     * 转入操作     */    @Override    public void in(String inUser, Double money) {        String sql = "update account set money = money + ? where name = ?";        try {            queryRunner.update(connectionUtils.getThreadConnection(), sql, money, inUser);        } catch (SQLException throwables) {            throwables.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>问题分析</strong></h1><p>上面代码，通过对业务层改造，已经可以实现事务控制了，但是由于添加了事务控制，也产生了一个新的问题： 业务层方法变得臃肿了，里面充斥着很多重复代码。并且业务层方法和事务控制方法耦合了，违背了面向对象的开发思想。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>Proxy 优化转账案例</strong></h1><p>可以将业务代码和事务代码进行拆分，通过动态代理的方式，对业务方法进行事务的增强。这样就不会对业务层产生影响，解决了耦合性的问题。</p><p>常用的动态代理技术：</p><ul><li>JDK 代理，基于接口的动态代理技术 - 利用拦截器（必须实现 invocationHandler）加上反射机制生成一个代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理，从而实现方法增强</li><li>CGLIB 代理，基于父类的动态代理技术 - 动态生成一个要代理的子类，子类重写要代理的类的所有不是 final 的方法；在子类中采用方法拦截技术拦截所有的父类方法的调用，顺势织入横切逻辑，对方法进行增强</li></ul><h1 class=pgc-h-arrow-right><strong>JDK 动态代理方式</strong></h1><p>去掉 AccountServiceImpl 的事务控制代码</p><pre><code>@Service("accountService")public class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    @Override    public void transfer(String outUser, String inUser, Double money) {        accountDao.out(outUser, money);        // 模拟出错        int i= 1/0;        accountDao.in(inUser, money);    }}</code></pre><p>JDK 工厂类</p><pre><code>@Componentpublic class JDKProxyFactory {    @Autowired    private AccountService accountService;    @Autowired    private TransactionManager transactionManager;    /**     * 采用 JDK 动态代理技术来生成目标类的代理对象     * ClassLoader loader : 类加载器：借助被代理对象获取到类加载器     * Class&lt;?&gt;[] interfaces ： 被代理类所需要实现的全部接口     * InvocationHandler h ： 当代理对象调用接口中的任意方法时，那么都会执行 InvocationHandler 中 invoke 方法     */    public AccountService createAccountServiceJdkProxy() {        return (AccountService) Proxy.newProxyInstance(                accountService.getClass().getClassLoader(),                accountService.getClass().getInterfaces(),                new InvocationHandler() {                    /**                     * @param proxy 当前的代理对象引用                     * @param method 被调用的目标方法的引用                     * @param args 被调用的目标方法所用到的参数                     */                    @Override                    public Object invoke(Object proxy, Method method, Object[] args) {                        try {                            if ("transfer".equalsIgnoreCase(method.getName())) {                                System.out.println("JDK Proxy: Pre-Enhance ...");                                transactionManager.beginTransaction();                                method.invoke(accountService, args);                                System.out.println("JDK Proxy: Post-Enhance ...");                                transactionManager.commit();                            } else {                                method.invoke(accountService, args);                            }                        } catch (Exception e) {                            transactionManager.rollback();                            e.printStackTrace();                        } finally {                            transactionManager.release();                        }                        return null;                    }                });    }}</code></pre><p>测试代码</p><pre><code>@Autowiredprivate JDKProxyFactory jdkProxyFactory;@Testpublic void testTransferProxyJDK(){    // 当前返回的实际上是 AccountService 的代理对象 proxy    AccountService accountServiceJDKProxy = jdkProxyFactory.createAccountServiceJDKProxy();    // 代理对象 proxy 调用接口中的任意方法时，都会执行底层的 invoke 方法    accountServiceJDKProxy.transfer("tom", "jerry", 100d);}</code></pre><h1 class=pgc-h-arrow-right><strong>CGLIB 动态代理方式</strong></h1><p>CGLIB 工厂类</p><pre><code>@Componentpublic class CglibProxyFactory {    @Autowired    private AccountService accountService;    @Autowired    private TransactionManager transactionManager;    /**     * 编写 cglib 对应的 API 来生成代理对象进行返回     * 参数 1 ： 目标类的字节码对象     * 参数 2：  动作类，当代理对象调用目标对象中原方法时，那么会执行 intercept 方法     */    public AccountService createAccountServiceCglibProxy() {        return (AccountService) Enhancer.create(accountService.getClass(), new MethodInterceptor() {            /**             * @param o 代表生成的代理对象             * @param method 调用目标方法的引用             * @param objects 方法入参             * @param methodProxy 代理方法             */            @Override            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) {                try {                    System.out.println("CGLIB Proxy: Pre-Enhance ...");                    // 手动开启事务：调用事务管理器类中的开启事务方法                    transactionManager.beginTransaction();                    method.invoke(accountService, objects);                    System.out.println("CGLIB Proxy: Post-Enhance ...");                    transactionManager.commit();                } catch (Exception e) {                    // 手动回滚事务                    transactionManager.rollback();                    e.printStackTrace();                } finally {                    // 手动释放资源                    transactionManager.release();                }                return null;            }        });    }}</code></pre><p>测试代码</p><pre><code>@Autowiredprivate CglibProxyFactory cglibProxyFactory;@Testpublic void testTransferProxyCglib(){    AccountService accountServiceCglibProxy = cglibProxyFactory.createAccountServiceCglibProxy();    accountServiceCglibProxy.transfer("tom","jerry",100d);}</code></pre><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right><strong>初识 AOP</strong></h1><h1 class=pgc-h-arrow-right><strong>什么是 AOP</strong></h1><p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程。</p><p>AOP 是 OOP（面向对象编程） 的延续，是软件开发中的一个热点，也是 Spring 框架中的一个重要内容，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>优势：</p><ol start=1><li>在程序运行期间，在不修改源码的情况下对方法进行功能增强</li><li>逻辑清晰，开发核心业务的时候，不必关注增强业务的代码</li><li>减少重复代码，提高开发效率，便于后期维护</li></ol><h1 class=pgc-h-arrow-right><strong>AOP 底层实现</strong></h1><p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring 通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p><h1 class=pgc-h-arrow-right><strong>AOP 相关术语</strong></h1><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。</p><p>在正式讲解 AOP 的操作之前，我们必须理解 AOP 的相关术语，常用的术语如下：</p><pre><code>* Target（目标对象）：代理的目标对象；被代理类* Proxy（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类；生成代理对象* Joinpoint（连接点）：所谓连接点是指那些可以被拦截到的点；在 spring 中，这些点指的是方法，因为 spring 只支持方法类型的连接点；可以被拦截增强的方法* Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义；即真正被拦截增强的方法* Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知分类：前置通知、后置通知、异常通知、最终通知、环绕通知 - 一种可以通过代码的方式来手动控制的类型；即增强的业务逻辑* Aspect（切面）：是切入点和通知（引介）的结合* Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入</code></pre><h1 class=pgc-h-arrow-right><strong>AOP 开发明确事项</strong></h1><h1 class=pgc-h-arrow-right><strong>开发阶段</strong></h1><ol start=1><li>编写核心业务代码（目标类的目标方法） 切入点</li><li>把公用代码抽取出来，制作成通知（增强功能方法） 通知</li><li>在配置文件中，声明切入点与通知间的关系，即切面</li></ol><h1 class=pgc-h-arrow-right><strong>运行阶段（Spring 框架自动完成）</strong></h1><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。</p><h1 class=pgc-h-arrow-right><strong>底层代理实现</strong></h1><p>在 Spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式：</p><ul><li>当 bean 实现接口时，会用 JDK 代理模式</li><li>当 bean 没有实现接口，用 cglib 实现（ 可以强制使用 cglib（在 spring 配置中加入 &lt;aop:aspectj-autoproxy proxy-target-class=”true”/>）</li></ul><h1 class=pgc-h-arrow-right><strong>小结</strong></h1><pre><code>* aop - 面向切面编程* aop 底层实现：基于 JDK 的动态代理和基于 Cglib 的动态代理* aop 的重点概念：    Pointcut（切入点）：真正被增强的方法    Advice（通知/ 增强）：封装增强业务逻辑的方法    Aspect（切面）：切点 + 通知    Weaving（织入）：将切点与通知结合，产生代理对象的过程</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>基于 XML 的 AOP 开发</strong></h1><h1 class=pgc-h-arrow-right><strong>快速入门</strong></h1><p>快速入门：</p><ol start=1><li>创建 java 项目，导入 AOP 相关座标</li><li>创建目标接口和目标实现类（定义切入点）</li><li>创建通知类及方法（定义通知）</li><li>将目标类和通知类对象创建权交给 spring</li><li>在核心配置文件中配置织入关系，及切面</li><li>编写测试代码</li></ol><h1 class=pgc-h-arrow-right><strong>创建 java 项目，导入 AOP 相关座标</strong></h1><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;    &lt;java.version&gt;1.11&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.11&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- 导入 spring 的 context 座标，context 依赖 aop --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- aspectj 的织入（切点表达式需要用到该 jar 包） --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring 整合 junit --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>创建目标接口和目标实现类</strong></h1><pre><code>public interface AccountService {    /**     * 目标方法：（切入点：要进行拦截增强的方法）     */    void transfer();}public class AccountServiceImpl implements AccountService {    @Override    public void transfer() {        System.out.println("转账方法执行了....");        //int i = 1/0;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>创建通知类</strong></h1><pre><code>public class MyAdvice {    public void before(){        System.out.println("前置通知执行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>将目标类和通知类对象创建权交给 spring</strong></h1><pre><code>&lt;!-- 目标类交给 IOC 容器 --&gt;&lt;bean id="accountServcie" class="com.renda.service.impl.AccountServiceImpl"/&gt;&lt;!-- 通知类交给 IOC 容器 --&gt;&lt;bean id="myAdvice" class="com.renda.advice.MyAdvice"/&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>在核心配置文件中配置织入关系，及切面</strong></h1><p>导入 AOP 命名空间</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;        &lt;bean id="accountServcie" class="com.renda.service.impl.AccountServiceImpl"/&gt;        &lt;bean id="myAdvice" class="com.renda.advice.MyAdvice"/&gt;        &lt;aop:config&gt;        &lt;aop:aspect ref="myAdvice"&gt;            &lt;aop:before method="before" pointcut="execution(public void com.renda.service.impl.AccountServiceImpl.transfer())"/&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;​&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>编写测试代码</strong></h1><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration({"classpath:applicationContext.xml"})public class AccountServiceTest {    @Autowired    private AccountService accountService;​    @Test    public void testTransfer() {        accountService.transfer();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>XML 配置 AOP 详解</strong></h1><h1 class=pgc-h-arrow-right><strong>切点表达式</strong></h1><p>表达式语法：</p><ul><li>访问修饰符可以省略</li><li>返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意</li><li>包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</li><li>参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</li></ul><p>例子：</p><pre><code>- execution([修饰符] 返回值类型 包名.类名.方法名(参数))execution(public void com.renda.service.impl.AccountServiceImpl.transfer(java.lang.String))- 访问修饰符可以省略execution(void com.renda.service.impl.AccountServiceImpl.transfer(java.lang.String))- 返回值类型、包名、类名、方法名可以使用星号 * 代替，代表任意execution(* *.*.*.*.*.*())- 包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类execution(* *..*.*())- 参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表execution(* *..*.*(..))</code></pre><p>切点表达式抽取：当多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用抽取后的切点表达式。</p><pre><code>public class MyAdvice {    public void before(){        System.out.println("前置通知执行了....");    }    public void afterReturning(){        System.out.println("后置通知执行了....");    }    public void afterThrowing(){        System.out.println("异常通知执行了....");    }    public void after(){        System.out.println("最终通知执行了....");    }    /**     * @param pjp Proceeding JoinPoint - 正在执行的连接点：切点     */    public Object around(ProceedingJoinPoint pjp){        Object proceed = null;        try {            System.out.println("前置通知执行了");            // 切点方法执行            proceed = pjp.proceed();            System.out.println("后置通知执行了");        } catch (Throwable throwable) {            throwable.printStackTrace();            System.out.println("异常通知执行了");        }finally {            System.out.println("最终通知执行了");        }        return proceed;    }}&lt;aop:config&gt;    &lt;!-- 抽取的切点表达式 --&gt;    &lt;aop:pointcut id="myPointcut" expression="execution(* com.renda.service.impl.AccountServiceImpl.*(..))"/&gt;    &lt;!-- 配置切面：切入点 + 通知 --&gt;    &lt;aop:aspect ref="myAdvice"&gt;        &lt;aop:before method="before" pointcut-ref="myPointcut"/&gt;        &lt;aop:after-returning method="afterReturning" pointcut-ref="myPointcut"/&gt;        &lt;aop:after-throwing method="afterThrowing" pointcut-ref="myPointcut"/&gt;        &lt;aop:after method="after" pointcut-ref="myPointcut"/&gt;        &lt;!-- &lt;aop:around method="around" pointcut-ref="myPointcut"/&gt; --&gt;    &lt;/aop:aspect&gt;&lt;/aop:config&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>通知类型</strong></h1><p>通知的配置语法：</p><pre><code>&lt;aop:通知类型 method=“通知类中方法名” pointcut=“切点表达式"&gt;&lt;/aop:通知类型&gt;</code></pre><ul><li>前置通知 &lt;aop:before> - 用于配置前置通知。指定增强的方法在切入点方法之前执行</li><li>后置通知 &lt;aop:afterReturning> - 用于配置后置通知。指定增强的方法在切入点方法之后执行</li><li>异常通知 &lt;aop:afterThrowing> - 用于配置异常通知；指定增强的方法出现异常后执行</li><li>最终通知 &lt;aop:after> - 用于配置最终通知；无论切入点方法执行时是否有异常，都会执行</li><li>环绕通知 &lt;aop:around> - 用于配置环绕通知；开发者可以手动控制增强代码在什么时候执行</li></ul><p>注意：通常情况下，环绕通知都是独立使用的</p><h1 class=pgc-h-arrow-right><strong>小结</strong></h1><pre><code>* aop 织入的配置    &lt;aop:config&gt;        &lt;aop:aspect ref=“通知类”&gt;        &lt;aop:before method=“通知方法名称” pointcut=“切点表达式"&gt;&lt;/aop:before&gt;        &lt;/aop:aspect&gt;    &lt;/aop:config&gt;                                                        * 通知的类型    前置通知、后置通知、异常通知、最终通知    环绕通知    * 切点表达式    execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>基于注解的 AOP 开发</strong></h1><h1 class=pgc-h-arrow-right><strong>快速入门</strong></h1><p>步骤分析：</p><ol start=1><li>创建 java 项目，导入 AOP 相关座标</li><li>创建目标接口和目标实现类（定义切入点）</li><li>创建通知类（定义通知）</li><li>将目标类和通知类对象创建权交给 spring</li><li>在通知类中使用注解配置织入关系，升级为切面类</li><li>在配置文件中开启组件扫描和 AOP 的自动代理</li><li>编写测试代码</li></ol><h1 class=pgc-h-arrow-right><strong>创建 java 项目，导入 AOP 相关座标</strong></h1><pre><code>&lt;properties&gt;    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;    &lt;maven.compiler.encoding&gt;UTF-8&lt;/maven.compiler.encoding&gt;    &lt;java.version&gt;1.11&lt;/java.version&gt;    &lt;maven.compiler.source&gt;1.11&lt;/maven.compiler.source&gt;    &lt;maven.compiler.target&gt;1.11&lt;/maven.compiler.target&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- 导入 spring 的 context 座标，context 依赖 aop --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- aspectj 的织入 --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.13&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- spring 整合 junit --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>创建目标接口和目标实现类</strong></h1><pre><code>public interface AccountService {    void transfer();}public class AccountServiceImpl implements AccountService {    @Override    public void transfer() {        System.out.println("转账方法执行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>创建通知类</strong></h1><pre><code>public class MyAdvice {    public void before(){        System.out.println("前置通知执行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>将目标类和通知类对象创建权交给 spring</strong></h1><pre><code>@Servicepublic class AccountServiceImpl implements AccountService {    @Override    public void transfer() {        System.out.println("转账方法执行了....");    }}@Componentpublic class MyAdvice {    ...}</code></pre><h1 class=pgc-h-arrow-right><strong>在通知类中使用注解配置织入关系，升级为切面类</strong></h1><pre><code>@Component@Aspect // 升级为切面类：配置切入点和通知的关系public class MyAdvice {    @Before("execution(* com.renda.service.impl.AccountServiceImpl.*(..))")    public void before(){        System.out.println("前置通知执行了....");    }}</code></pre><h1 class=pgc-h-arrow-right><strong>在配置文件中开启组件扫描和 AOP 的自动代理</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:context="http://www.springframework.org/schema/context"       xsi:schemaLocation="http://www.springframework.org/schema/beans		http://www.springframework.org/schema/beans/spring-beans.xsd		http://www.springframework.org/schema/aop		http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt;    &lt;!-- 开启 IOC 注解扫描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;    &lt;!-- aop 的自动代理：采用动态代理完成织入增强，并且生成代理；proxy-target-class="true" 表示强制使用 cglib 动态代理--&gt;    &lt;aop:aspectj-autoproxy proxy-target-class="false"/&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>编写测试代码</strong></h1><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class AccountServiceTest {    @Autowired    private AccountService accountService;    @Test    public void testTransfer(){        accountService.transfer();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>注解配置 AOP 详解</strong></h1><h1 class=pgc-h-arrow-right><strong>切点表达式</strong></h1><p>切点表达式的抽取</p><pre><code>@Component@Aspect // 升级为切面类：配置切入点和通知的关系public class MyAdvice {    @Pointcut("execution(* com.renda.service.impl.AccountServiceImpl.*(..))")    public void myPoint(){    }    @Before("MyAdvice.myPoint()")    public void before(){        System.out.println("前置通知执行了....");    }    @AfterReturning("MyAdvice.myPoint()")    public void afterReturning(){        System.out.println("后置通知执行了....");    }    @AfterThrowing("MyAdvice.myPoint()")    public void afterThrowing(){        System.out.println("异常通知执行了....");    }    @After("MyAdvice.myPoint()")    public void after(){        System.out.println("最终通知执行了....");    }    /**     * @param pjp Proceeding JoinPoint - 正在执行的连接点：切点     */    public Object around(ProceedingJoinPoint pjp){        Object proceed = null;        try {            System.out.println("前置通知执行了");            // 切点方法执行            proceed = pjp.proceed();            System.out.println("后置通知执行了");        } catch (Throwable throwable) {            throwable.printStackTrace();            System.out.println("异常通知执行了");        }finally {            System.out.println("最终通知执行了");        }        return proceed;    }}</code></pre><h1 class=pgc-h-arrow-right><strong>通知类型</strong></h1><p>通知的配置语法：@通知注解(“切点表达式")</p><ul><li>前置通知 @Before - 用于配置前置通知；指定增强的方法在切入点方法之前执行</li><li>后置通知 @AfterReturning - 用于配置后置通知；指定增强的方法在切入点方法之后执行</li><li>异常通知 @AfterThrowing - 用于配置异常通知；指定增强的方法出现异常后执行</li><li>最终通知 @After - 用于配置最终通知；无论切入点方法执行时是否有异常，都会执行</li><li>环绕通知 @Around - 用于配置环绕通知；开发者可以手动控制增强代码在什么时候执行</li></ul><h1 class=pgc-h-arrow-right><strong>注意</strong></h1><p>当前四个通知组合在一起时，出现一个 Spring 的执行顺序的 Bug，错误的执行顺序如下：</p><pre><code>@Before -&gt; @After -&gt; @AfterReturning（如果有异常：@AfterThrowing）</code></pre><p>如果单独使用环绕通知 @Around 注解则不会有这个 Bug，执行顺序如下：</p><pre><code>@Before -&gt; @AfterReturning（如果有异常：@AfterThrowing）-&gt; @After</code></pre><h1 class=pgc-h-arrow-right><strong>纯注解配置</strong></h1><p>去掉 applicationContext.xml 配置文件，增加 SpringConfig 配置类</p><pre><code>@Configuration@ComponentScan("com.renda")@EnableAspectJAutoProxy // 开启 AOP 的自动代理，替代 xml 配置的 &lt;aop:aspectj-autoproxy /&gt;public class SpringConfig {}</code></pre><p>修改测试类</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class AccountServiceTest {​    @Autowired    private AccountService accountService;​    @Test    public void testTransfer(){        accountService.transfer();    }​}</code></pre><h1 class=pgc-h-arrow-right><strong>知识小结</strong></h1><pre><code>* 使用 @Aspect 注解，标注切面类* 使用 @Before 等注解，标注通知方法* 使用 @Pointcut 注解，抽取切点表达式* 配置 aop 自动代理 &lt;aop:aspectj-autoproxy/&gt; 或 @EnableAspectJAutoProxy</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>AOP 优化转账案例</strong></h1><p>依然使用前面的转账案例，将两个代理工厂对象直接删除，改为 spring 的 AOP 思想来实现</p><h1 class=pgc-h-arrow-right><strong>xml 配置实现</strong></h1><h1 class=pgc-h-arrow-right><strong>配置文件</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="       	http://www.springframework.org/schema/beans		http://www.springframework.org/schema/beans/spring-beans.xsd       	http://www.springframework.org/schema/context		http://www.springframework.org/schema/context/spring-context.xsd		http://www.springframework.org/schema/aop		http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;    &lt;!-- 引入 properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;    &lt;!-- 配置 DataSource --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;        &lt;property name="url" value="${jdbc.url}"/&gt;        &lt;property name="username" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;    &lt;/bean&gt;    &lt;!-- 配置 queryRunner --&gt;    &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"&gt;        &lt;constructor-arg name="ds" ref="dataSource"/&gt;    &lt;/bean&gt;    &lt;!-- AOP 配置 --&gt;      &lt;aop:config&gt;          &lt;!-- 1.切点表达式 --&gt;          &lt;aop:pointcut id="myPointcut" expression="execution(* com.renda.service.impl.AccountServiceImpl.*(..))"/&gt;          &lt;!-- 2.切面配置 --&gt;          &lt;aop:aspect ref="transactionManager"&gt;              &lt;aop:before method="beginTransaction" pointcut-ref="myPointcut"/&gt;              &lt;aop:after-returning method="commit"  pointcut-ref="myPointcut"/&gt;              &lt;aop:after-throwing method="rollback" pointcut-ref="myPointcut"/&gt;              &lt;aop:after method="release" pointcut-ref="myPointcut"/&gt;          &lt;/aop:aspect&gt;      &lt;/aop:config&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>事务管理器（通知）</strong></h1><pre><code>package com.renda.utils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import java.sql.Connection;import java.sql.SQLException;/** * 事务管理器工具类：包含：开启事务、提交事务、回滚事务、释放资源 *      Spring AOP 的通知类 * * @author Renda Zhang * @create 2020-09-04 15:31 */@Component("transactionManager")public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;    /**     * 开启事务     */    public void beginTransaction(){        // 获取 connection 对象        Connection connection = connectionUtils.getThreadConnection();        try {            // 开启了一个手动事务            connection.setAutoCommit(false);            System.out.println("开启事务");        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 提交事务     */    public void commit(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.commit();            System.out.println("提交事务");        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 回滚事务     */    public void rollback(){        Connection connection = connectionUtils.getThreadConnection();        try {            connection.rollback();            System.out.println("回滚事务");        } catch (SQLException e) {            e.printStackTrace();        }    }    /**     * 释放资源     */    public void release(){        // 将手动事务改回成自动提交事务        Connection connection = connectionUtils.getThreadConnection();        try {            connection.setAutoCommit(true);            // 将连接归还到连接池            connectionUtils.getThreadConnection().close();            // 解除线程绑定            connectionUtils.removeThreadConnection();            System.out.println("释放资源");        } catch (SQLException e) {            e.printStackTrace();        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>注解配置实现</strong></h1><h1 class=pgc-h-arrow-right><strong>配置文件</strong></h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xsi:schemaLocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd        http://www.springframework.org/schema/aop        http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;​    &lt;!-- 开启注解扫描 --&gt;    &lt;context:component-scan base-package="com.renda"/&gt;​    &lt;!-- 引入 properties --&gt;    &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt;​    &lt;!-- 配置 DataSource --&gt;    &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt;        &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;        &lt;property name="url" value="${jdbc.url}"/&gt;        &lt;property name="username" value="${jdbc.username}"/&gt;        &lt;property name="password" value="${jdbc.password}"/&gt;    &lt;/bean&gt;​    &lt;!-- 配置 queryRunner --&gt;    &lt;bean id="queryRunner" class="org.apache.commons.dbutils.QueryRunner"&gt;        &lt;constructor-arg name="ds" ref="dataSource"/&gt;    &lt;/bean&gt;​    &lt;!-- 开启 AOP 的自动代理 --&gt;    &lt;aop:aspectj-autoproxy/&gt;​&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right><strong>事务管理器（通知）</strong></h1><pre><code>@Component("transactionManager")@Aspect // 表明该类为切面类public class TransactionManager {    @Autowired    private ConnectionUtils connectionUtils;​    @Around("execution(* com.renda.service.impl.AccountServiceImpl.*(..))")    public Object around(ProceedingJoinPoint pjp) throws SQLException {        Object proceed = null;​        try {            // 开启手动事务            System.out.println("开启事务");            connectionUtils.getThreadConnection().setAutoCommit(false);​            // 切入点方法执行            proceed = pjp.proceed();​            // 手动提交事务            System.out.println("提交事务");            connectionUtils.getThreadConnection().commit();        } catch (Throwable throwable) {            throwable.printStackTrace();            // 手动回滚事务            System.out.println("回滚事务");            connectionUtils.getThreadConnection().rollback();        } finally {            System.out.println("释放资源");            // 将手动事务恢复成自动事务            connectionUtils.getThreadConnection().setAutoCommit(true);            // 将连接归还到连接池            connectionUtils.getThreadConnection().close();            // 解除线程绑定            connectionUtils.removeThreadConnection();        }​        return proceed;    }}</code></pre><blockquote class=pgc-blockquote-abstract><p>想了解更多，欢迎关注我的微信公众号：Renda_Zhang</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Spring','AOP','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面编程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面编程需要知道的事">Spring AOP 面向切面编程需要知道的事</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>