<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>第十六章 泛型 | 极客快訊</title><meta property="og:title" content="第十六章 泛型 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9155df6f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9155df6f.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="第十六章 泛型"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9155df6f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>第十六章 泛型</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=pgc-h-arrow-right><strong>16.1 概述</strong></h3><p>我们在编写程序时，经常遇到两个模块的功能非常相似，只是一个是处理int数据，另一个是处理string数据，或者其他自定义的数据类型，但我们没有办法，只能分别写多个方法处理每个数据类型，因为方法的参数类型不同。有没有一种办法，在方法中传入通用的数据类型，这样不就可以合并代码了吗？泛型的出现就是专门解决这个问题的。</p><p>泛型的意思就是Generic,它所代表的是通用类型，可以代替任意的数据类型，使得类型参数化，从而达到了只需要一个方法就可以操作多种数据的目的。</p><p>泛型不仅仅可以实现代码的重用，减少了装箱和拆箱的过程。泛型还是避免损失的有效方法。</p><h3 class=pgc-h-arrow-right><strong>16.2 泛型定义</strong></h3><p>泛型在定义时，用一个通用的数据类型<strong>[T]</strong>来作为一个占位符，等待在实例化时用一个实际的类型来代替。</p><p><strong>eg:</strong></p><pre><code>public class Stack&lt;T&gt;{}//泛型类</code></pre><p><strong>注意：</strong></p><ul><li><strong>T</strong>仅仅是一个占位符，可以使用任意你所喜欢的占位符进行替换。</li><li>泛型定义和使用时，必须引用命名空间：<strong>using System.Collections.Generic;</strong></li></ul><p><strong>【常用泛型类型集合】</strong></p><p>C#常用的泛型类型有：</p><p><strong>List&lt;T></strong>是泛型类中最常用的集合，可以动态的调整数据。</p><p><strong>stack&lt;T></strong>栈是以先进后出的方式维护数据的集合，包含pop()和push(),从栈内压入或移除数据。</p><p><strong>Quenue&lt;T></strong>队列是以先进先出的方式访问数据，使用Enqueue()和Dequeue()添加数据和移除数据。</p><p><strong>Dictionary&lt;T></strong>字典是以键值对的形式访问数据，可以动态的调整数据。</p><p><strong>以List集合为例，如下代码：</strong></p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    class MainClass    {        public static void Main(string[] args){          //存储整型数据            List&lt;int&gt; intList = new List&lt;int&gt;();            intList.Add(3);            intList.Add(4);            intList.Add(5);​            foreach (int item in intList)            {                Console.WriteLine(&#34;{0}&#34;, item);            }​          //存储字符串类型数据            List&lt;string&gt; stringList = new List&lt;string&gt;();            stringList.Add(&#34;hello&#34;);            stringList.Add(&#34;World&#34;);            stringList.Add(&#34;One&#34;);​            foreach (string item in stringList) {                Console.WriteLine(&#34;{0}&#34;, item);            }        }    }}</code></pre><h3 class=pgc-h-arrow-right><strong>16.3 泛型类</strong></h3><p>泛型类定义方式十分简单，泛型类分为【非静态泛型类】和【静态泛型类】；</p><p><strong>【非静态泛型类】</strong></p><p><strong>eg:</strong></p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    public class Compare&lt;T&gt; where T : IComparable    {        public static T compareGeneric(T t1, T t2)        {            if (t1.CompareTo(t2) &gt; 0)            {                return t1;            }            else            {                return t2;            }        }    }​    class MainClass    {        public static void Main(string[] args){            Console.WriteLine(Compare&lt;int&gt;.compareGeneric(3, 4));            Console.WriteLine(Compare&lt;string&gt;.compareGeneric(&#34;abc&#34;, &#34;a&#34;));        }    }}</code></pre><p><strong>泛型不仅仅可以实现代码的重用，减少了装箱和拆箱的过程。泛型是避免损失的有效方法。</strong></p><p>如下所示代码测试了使用泛型和不适用泛型的执行时间：</p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Diagnostics;using System.Collections;using System.Collections.Generic;​namespace MSN{    class MainClass    {        //非泛型方法        public static void TestNonGeneric()        {            Stopwatch stopwatch = new Stopwatch();            ArrayList arrayList = new ArrayList();​            stopwatch.Start();​            for (int i = 1; i &lt; 10000000; i++)            {                arrayList.Add(i);            }​            stopwatch.Stop();​            TimeSpan ts = stopwatch.Elapsed;​            string elapsedTime = String.Format(&#34;{0:00}:{1:00}:{2:00}.{3:00}&#34;,                ts.Hours,ts.Minutes, ts.Seconds, ts.Milliseconds / 10);            Console.WriteLine(&#34;非运行时间是&#34; + elapsedTime);        }​        //泛型方法        public static void TestGeneric()        {            Stopwatch stopwatch = new Stopwatch();            List&lt;int&gt; gelist = new List&lt;int&gt;();​            stopwatch.Start();​            for (int i = 0; i &lt; 10000000; i++)            {                gelist.Add(i);            }​            stopwatch.Stop();​            TimeSpan ts = stopwatch.Elapsed;​            string elapsedTime = String.Format(&#34;{0:00}:{1:00}:{2:00}.{3:00}&#34;,                ts.Hours,ts.Minutes, ts.Seconds, ts.Milliseconds / 10);​            Console.WriteLine(&#34;运行时间是&#34; + elapsedTime);​        }​        public static void Main(string[] args){            MainClass.TestGeneric();​            MainClass.TestNonGeneric();        }    }}</code></pre><p>从结果可以看出，向泛型数组中加入元素的效率远高于非泛型数组，因为非泛型的Add操作中，参数为object类型，当int传入的时候，会发生装箱操作，从而导致性能的损失，时间变长。</p><p><strong>【静态泛型类】</strong></p><p>在普通静态类中，静态数据类型是属于类型的，如果定义了一个静态字段x，则不管之后创建了多少个该类的实例，也不管派生多个实例，都只存在一个。<strong>泛型并非如此，每个封闭泛型都具有自己的静态数据。</strong></p><p><strong>eg:</strong></p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    /*静态泛型类*/    public static class GenericClass&lt;T&gt;    {        /*每个封闭类型的泛型类型都有一个静态构造函数*/        static GenericClass()        {            Console.WriteLine(&#34;泛型的静态构造函数被调用，实际类型&#34; + typeof(T));        }        public static void Print()        {        }    }​    /*普通静态类*/    public static class NoGenericClass    {        static NoGenericClass()        {            Console.WriteLine(&#34;静态构造函数被调用&#34;);        }        public static void Print()        {        }    }•​    class MainClass    {        public static void Main(string[] args){            GenericClass&lt;int&gt;.Print();            GenericClass&lt;string&gt;.Print();​            NoGenericClass.Print();            NoGenericClass.Print();        }    }}</code></pre><h3 class=pgc-h-arrow-right><strong>16.4 泛型方法</strong></h3><p>有时候，我们需要将泛型T的作用范围缩小，直接将其应用在方法上实现泛型方法无疑是一种非常明智的选择。</p><p><strong>eg：</strong></p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    public class GeneMethod    {        public GeneMethod()        {        }        public static T max&lt;T&gt;(T t1)        {            Console.WriteLine(&#34;t1={0}&#34;, t1);​            return t1;        }    }    class MainClass    {        public static void Main(string[] args){            Console.WriteLine(GeneMethod.max&lt;int&gt;(20));        }    }}</code></pre><h3 class=pgc-h-arrow-right><strong>16.4.1 泛型类中的方法重载</strong></h3><p>方法的重载在.Net Framework中被大量应用在泛型类中，由于通用类型T在类编写时并不确定，所以在重载时有些注意事项，这些事项我们通过以下的例子说明：</p><p><strong>eg:</strong></p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    public class Node&lt;T, V&gt;​    {​        public T add(T a, V b)          //第一个add​        {            Console.WriteLine(&#34;第一个add&#34;);            return a;​        }​        public T add(V a, T b)          //第二个add​        {            Console.WriteLine(&#34;第二个add&#34;);            return b;​        }​        public int add(int a, int b)    //第三个add​        {            Console.WriteLine(&#34;第三个add&#34;);            return a + b;​        }​    }•    class MainClass    {        public static void Main(string[] args){            Node&lt;int, int&gt; node = new Node&lt;int, int&gt;();            object num = node.add(2, 11);            Console.WriteLine(&#34;num = {0}&#34;, num);        }    }}​</code></pre><p><strong>注：</strong></p><p>使用如下代码进行测试时：</p><pre><code>Node&lt;int, int&gt; node = new Node&lt;int, int&gt;();​object num = node.add(2, 11);</code></pre><p>Node的实例化引起了三个add方法具有同样的签名，但却能调用成功。原因在于编译器优先匹配了第三个add方法。但如果删除了第三个add方法，上面的调用代码则无法编译通过，提示方法产生的混淆，因为运行时无法在第一个add方法和第二个add方法之间选择。</p><pre><code>Node&lt;string, int&gt; node = new Node&lt;string, int&gt;();​object x = node.add(2, &#34;11&#34;);</code></pre><p>这两行调用代码可正确编译，因为传入的string和int，使三个add方法具有不同的签名，当然能找到唯一匹配的add方法。</p><h3 class=pgc-h-arrow-right><strong>16.5 泛型全面解析</strong></h3><p>泛型分为<strong>开放泛型</strong>和<strong>封闭泛型</strong>。其中开放类型是指包含类型参数的泛型，但是未绑定的类型；封闭类型是指已经为每一个类型参数都传递了数据类型。</p><p>检测泛型类别时可使用【<strong>ContainsGenericParameters</strong>】属性来判断类型对象是否包含未被实际类型替代的类型参数。存在则返回true，表示为开放类型，不存在则返回false，表示为封闭类型。</p><p><strong>eg：</strong></p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    public class DictionaryStringKey&lt;T&gt; : Dictionary&lt;string, T&gt;    {​    }​    class MainClass    {        public static void Main(string[] args){            Type t = typeof(Dictionary&lt;,&gt;);            Console.WriteLine(&#34;是否为开放类型：&#34; + t.ContainsGenericParameters);​            t = typeof(DictionaryStringKey&lt;int&gt;);            Console.WriteLine(&#34;是否为开放类型：&#34; + t.ContainsGenericParameters);        }    }}</code></pre><h3 class=pgc-h-arrow-right><strong>16.6 泛型约束</strong></h3><p>在16.3小节实现的泛型之中，我们使用了where T:IComparable的代码，其中<strong>where</strong>语句用来使类型继承于IComparable接口，从而对类型参数进行约束。泛型约束共有六大类别，下面一一进行详解。</p><h3 class=pgc-h-arrow-right><strong>16.6.1 基类约束</strong></h3><p>基类约束有两个功能。首先，它允许在泛型类中使用自由约束指定的基类所定义的成员。通过提高基类约束，编译器将知道所有的类型实参都拥有由指定的基类所定义的成员。基类约束的第二个功能是，确保只使用支持指定基类的类型实参。这意味着对于任意给定的基类约束，类型实参必须是基类本身或者是派生于该基类的类。基类约束使用如下形式的where子句：</p><pre><code>    where T：base-class-name</code></pre><p>其中，T是类型形参的名称，base-class-name是基类的名称。只能指定一个基类。</p><h3 class=pgc-h-arrow-right><strong>16.6.2 接口约束</strong></h3><p>接口约束是指定某个类型实参必须实现的接口。它的两个主要功能与基类约束一样，允许开发人员在泛型类中使用接口的成员；确保只能使用实现了特定接口的类型实参。也就是说对任何给定的接口约束，类型实参必须是接口本身或者实现了该接口的类。接口约束使用的where子句具有以下形式：</p><pre><code>    where T:interface-name</code></pre><p>其中，T是类型形参的名称，interface-name是接口的名称。可以使用逗号分隔开指定的多个接口。若某个约束同时包含基类和接口，则需先指定基类列表，再指定接口列表。</p><h3 class=pgc-h-arrow-right><strong>16.6.3 new()构造函数约束</strong></h3><p>new()构造函数约束允许开发人员实例化一个泛型类型的对象。new()约束要求类型实参必须提供一个无参数的公有构造函数。使用new()约束时，可以通过调用该无参数的构造函数来创建对象。new()构造函数约束的形式为：</p><pre><code>    where T:new()</code></pre><p><strong>使用new()约束时应当注意3点：</strong></p><p>1.new()约束可以与其他约束一起使用，但必须位于约束列表的末端</p><p>2.new()约束仅允许开发人员使用无参数的构造函数构造一个对象，即使同时存在其他的构造函数也是如此。即不允许给类型形参的构造函数传递实参。</p><p>3.不可以同时使用new()约束和值类型约束。因为值类型都隐式的提供了一个无参公共构造函数。就如同定义接口时指定访问类型为public一样，编译器会报错，因为接口一定是public的。</p><h3 class=pgc-h-arrow-right><strong>16.6.4 引用类型约束</strong></h3><p>引用类型约束将一个类型形参限定为引用类型。引用类型一般是用户定义的类型，包含类、接口、委托、字符串和数组类型。引用类型约束使用class关键字，它的通用形式为</p><pre><code>    where T:class</code></pre><p>在这个where子句中，class关键字是指定T必须是引用类型。因此，尝试对T使用值类型，将会导致编译错误。</p><h3 class=pgc-h-arrow-right><strong>16.6.5 值类型约束</strong></h3><p>值类型约束将一个类型形参限定为值类型。值类型派生于System.ValueType类型。基元和结构都是值类型。值类型约束使用struct关键字，它的通用形式为：</p><pre><code>    where T:struct</code></pre><p>在该形式中，struct关键字指定T必须是值类型。因此，尝试对T使用引用类型，将导致编译错误。</p><h3 class=pgc-h-arrow-right><strong>16.6.6 组合约束</strong></h3><p>同一个类型形参可以使用多个约束。这种情况下，需要使用一个由逗号分隔的约束列表。在该列表中，第一个约束必须是引用类型约束或者值类型约束，或者是基类约束。指定引用类型约束或值类型约束的同时也指定基类约束是非法的。接下来必须是所有的接口约束，最后是new()约束。下面是一个合法的声明：</p><pre><code>class Test&lt;T&gt;where T:MyClass,Iinterface,new()</code></pre><p>{ }</p><p>在上述声明中，用于替换T的类型实参必须继承MyClass类，实现Iinterface接口，并且拥有一个无参数的构造函数。</p><p>在使用两个或者更多的类型形参时，可以使用多条where子句分别为它们指定约束。</p><ul><li><strong>where T: struct</strong></li></ul><p>类型参数必须为值类型。</p><ul><li><strong>where T : class</strong></li></ul><p>类型参数必须为类型。</p><ul><li>where T : new()</li></ul><p>类型参数必须有一个公有、无参的构造函数。当于其它约束联合使用时,new()约束必须放在最后。</p><ul><li><strong>where T : &lt;base class name></strong></li></ul><p>类型参数必须是指定的基类型或是派生自指定的基类型。</p><ul><li><strong>where T : &lt;interface name></strong></li></ul><p>类型参数必须是指定的接口或是指定接口的实现。可以指定多个接口约束。接口约束也可以是泛型的。</p><h3 class=pgc-h-arrow-right><strong>16.7 泛型委托</strong></h3><p>与方法一样，委托也可以是泛型的。因为泛型内在的类型安全性，无法将不兼容的方法赋给委托。<strong>声明泛型委托的形式为：</strong></p><pre><code>delegate ret-type delegate-name&lt;type-parameter-list&gt;(arg-list);</code></pre><p>类型形参的声明紧跟在委托的名称之后。泛型委托的优点在于，它允许开发人员以类型安全的方式定义一种通用形式，该形式可用于匹配任意兼容的方法。</p><pre><code>// #region &lt;&lt; 版 本 注 释 &gt;&gt;// /*----------------------------------------------------------------// // Copyright (C) 2019 极客部落// // 版权所有。 // //// // 文件名：Program.cs// // 文件功能描述：// //// // // // 创建者：GeekTribe// // 时间：14:05// //----------------------------------------------------------------*/// #endregionusing System;using System.Collections.Generic;​namespace MSN{    class MainClass    {        public delegate T MyGenericDelegate&lt;T&gt;(T obj1, T obj2);​        int AddInt(int x, int y)        {            return x + y;        }​        string AddString(string s1, string s2)        {            return s1 + s2;        }​        public static void Main(string[] args){            MainClass p = new MainClass();                       MyGenericDelegate&lt;int&gt; intDel;            intDel = p.AddInt;            Console.WriteLine(&#34;int代理的值是{0}&#34;, intDel(100, 200));                           MyGenericDelegate&lt;string&gt; stringDel;                 stringDel = p.AddString;            Console.WriteLine(&#34;string代理的值是{0}&#34;, stringDel(&#34;Hello&#34;, &#34;World&#34;));         }    }}​</code></pre><h3 class=pgc-h-arrow-right><strong>16.8 泛型接口</strong></h3><p>除了定义泛型类和泛型方法外，还可以定义泛型接口。泛型接口的定义与泛型类基本相同。<strong>泛型接口的声明形式为:</strong></p><pre><code>interface Iinterface&lt;T&gt;{   }</code></pre><p><strong>使用泛型时，要注意一下限制：</strong></p><ul><li>extern修饰符不能用于泛型方法。</li><li>属性、运算符、索引器和事件不能泛型化。这些项仍可以用作泛型中，并且可以使用类的泛型类型形参。</li><li>指针类型不能用作类型实参。</li><li>如果泛型类包含一个static字段，那么每一个构造类型都会有该字段的独立副本。这意味着同一个构造函数类型的所有实例都会共享同一个static字段。然而，不同的构造类型使用不同的字符副本。因此，static字段并不是由所有的构造类型共享。</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'泛型','第十六章'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>