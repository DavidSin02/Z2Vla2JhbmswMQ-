<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构——30行代码实现栈和模拟递归 | 极客快訊</title><meta property="og:title" content="数据结构——30行代码实现栈和模拟递归 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/961953b4a9dc45259f9980c761d358a0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/917161a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/917161a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/917161a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/917161a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/917161a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/917161a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/917161a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/917161a.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="数据结构——30行代码实现栈和模拟递归"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/917161a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构——30行代码实现栈和模拟递归</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>原本今天想给大家讲讲快速选择算法的，但是发现一连写了好几篇排序相关了，所以临时改了题目，今天聊点数据结构，来看看经典并且简单的数据结构——栈。</p><p><br></p><p>栈这个结构我想大家应该都耳熟能详，尤其是在很多地方将和堆并列在一起，称作“堆栈”就更广为人知了。但其实堆和栈本质上是两种不同的数据结构，我们不能简单地混为一谈。让我们先从比较简单的栈开始。</p><p><br></p><p>栈和队列的本质其实都是数组（严格地说是<strong>线性表</strong>）。只不过我们在数组上增加了一些限制，使得它满足一定的条件而已，所以很多对数据结构畏首畏尾的同学可以放宽心，栈没什么特别的花样，就是一种特殊的数组。</p><p><br></p><p>和其他广义上的线性表数据结构比起来，栈的特殊性只有两条，一条是<strong>先进后出</strong>，另一条是只能从<strong>数组的一侧读写</strong>。但本质上来说这两条是一样的，由于我们只能从一侧读写元素，所以进的越早出的越晚，当然是先进后出。从下面这张图应该很容易能看明白。</p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/961953b4a9dc45259f9980c761d358a0><p class=pgc-img-caption></p></div><p>栈规定了我们只能从一侧进行读写，常规上我们将能够读写的一侧称作是栈顶。不能读写的另一侧称为是栈底。从上面的图可以看到，只有栈顶的元素出栈了之后，才能访问到栈底的元素。</p><p><br></p><p>我们用Python的数组来实现栈这个数据结构，去掉注释真的只有30行不到，可以说是非常简单，我们先来看代码。</p><p><br></p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/66c354e603314e718e9c8d86f8cec9ad><p class=pgc-img-caption></p></div><p><br></p><p>本质上来说，一般的栈实现只有以上这么几个方法，可能会更少。因为有些语言当中的栈，top和弹出是合并的。意味着访问必须要弹出，不支持非弹出访问。所以栈的实现逻辑是非常简单的，甚至可以说是<strong>毫无技术含量</strong>，非常适合入门数据结构。</p><p><br></p><p>当然，从另一个方面也可以说栈的实现原理并不太重要，相比之下更重要的是栈一般会用在什么地方。</p><p><br></p><h2 class=Editable-styled><strong>栈的应用</strong></h2><p><br></p><p>栈最广泛的应用就是在操作系统当中，比如在程序执行调用方法的时候，在编译器内部，其实是记录了一个当前调用的<strong>方法栈</strong>。举个例子，比如当前调用到的方法是A，如果在A方法中又去调用了方法B，那么计算机就会在系统方法栈当中存储一个指向B方法的指针，如果B方法又调用到了C方法，那么又会新增一个C的指针。当C方法执行结束，那么C就会弹出，计算机会将C的结果带入B，继续执行之前的B，以此类推，直到栈空为止。</p><p><br></p><p>那么，问题来了，如果一个方法A<strong>自己调用自己</strong>会怎么样？</p><p><br></p><p>答案是计算机会创建一个新的A的指针填入栈中，如果A继续递归，那么系统再创建一个新的指针入栈……</p><p><br></p><p>从上面这个过程，我们可以确定两个事情。第一，我们写程序时候的递归，在编译器内部其实是以<strong>栈的形式</strong>执行的。第二，如果我们用一个死循环去不停地递归，由于<strong>栈存在大小限制</strong>，所以当栈的深度超过限制的时候，就会出现SystemStackExceed的错误。也就是说递归并不是无限的，因为除了操作系统对于运行内存的限制之外，编译器还会有最大递归深度的限制，防止递归中死循环导致系统崩溃。虽然各个语言实现机制不完全一样，但是有一点是肯定的，递归深度是有限的，我们<strong>不能无限制递归</strong>。</p><p><br></p><p>那问题来了，如果我们系统就是会存在大规模的递归怎么办？难道还要手动给机器加内存吗？</p><p><br></p><p>这是ACM玩家在赛场上经常遇到的问题之一，有经验的选手在第一天的热身赛时一定会做的事情除了配置vim或者其他IDE之外，就是会测试一下电脑的<strong>最大递归深度</strong>。在C++当中，是支持通过汇编语言强行打开递归深度限制的，但是即使如此也是有限的，并且据我所知只有C++可以这么干，对于其他语言，以及开大了递归深度还是不够用的情况，就只有一种办法，就是手动建栈模拟递归。</p><p><br></p><h2 class=Editable-styled><strong>手动递归</strong></h2><p><br></p><p>许多同学可能觉得递归痛苦，但是如果他们试着<strong>手动建栈来模拟递归</strong>的话，会发现要更加痛苦。不仅要额外增加变量存储中间状态，并且对于编程也是一个巨大的挑战。</p><p><br></p><p>我们来看一个例子：</p><p><br></p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18c26558271f4b04ad90c87eca389f2a><p class=pgc-img-caption></p></div><p><br></p><p>这是一棵简单的二叉树，画出来是这个样子：</p><p><br></p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7150042b6d8b48c4bba6d093db91dc0b><p class=pgc-img-caption></p></div><p><br></p><p>下面我们要通过栈在<strong>不使用递归的情况下来中序遍历它</strong>，中序遍历我们都知道，就是先遍历左子树，然后输出当前节点，再遍历右子树。写成递归非常方便，只有几行：</p><p><br></p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca43ac0a534b4d96b5c51bbac89f24ac><p class=pgc-img-caption></p></div><p><br></p><p>大家想想，如果不使用递归应该怎么办？如果你真的试着去写，就会发现看起来很简单的问题好像变得非常复杂。我们很容易可以想到，我们把节点存储在栈当中，但是存储数据只是表象。本质问题是当我们从栈当中拿到了一个节点之后，我们<strong>怎么判断它究竟应该做什么</strong>？应该遍历左节点吗，应该输出吗，还是应该遍历右节点？</p><p><br></p><p>对这些问题仔细分析和思考，我们可以发现它们都和递归的<strong>回溯</strong>有关。</p><p><br></p><p>在递归当中，当我们遍历完了当前节点的某棵子树之后，随着栈的弹出，还会回到这个节点。比如上面这棵树当中，在递归过程当中，我们会两次碰到1这个节点。第一次时它不会输出1，而是先去遍历了它的左子树，也就是3，之后再次回到1，由于它的左子树已经遍历过，所以会输出1。这个离开又回来的过程称为<strong>回溯</strong>。如果你把树结构想象成瀑布的话，这个过程有点像是先顺流而下，又逆流而上返回，backtracking翻译成回溯还是蛮合理的。</p><p><br></p><p>我们回到之前的问题，所有的搞不清楚的本质都来源于我们无法判断当前遇到的节点究竟是初次见面，还是回溯之后的久别重逢。而这关系到我们要对它做什么。原本在递归当中，由于程序会记录递归时的状态和代码运行的位置，递归回溯之后会回到上次调用的位置，所以我们可以忽略这个问题。而现在我们由于不再使用递归，所以<strong>需要我们自己来判断节点的状态</strong>。</p><p><br></p><p>想通了其实很简单，我们只需要在节点当中加一个状态的字段，表示这个节点是否会发生回溯。显然在一开始的时候，所有的节点状态都是True。</p><p><br></p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d5e2e43e2e69435c9342d9475553a59f><p class=pgc-img-caption></p></div><p><br></p><p>我们在Node类中加一个flag作为记录，初始化时我们默认它为True。接着就很简单了，我们就按照左中右的顺序遍历节点，只要左子树存在<strong>且还没有回溯过</strong>就往左边遍历，在一路往左的过程中遇到的这些节点的flag全部置为False，因为它们的回溯已经开始，以后不会再发生回溯了。由于<strong>往右遍历不会存在回溯的问题</strong>，所以可以忽略，想明白了，代码也就顺理成章。</p><p><br></p><div class=pgc-img><img alt=数据结构——30行代码实现栈和模拟递归 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d27ebb5de37d4aaca10684ce102e4fca><p class=pgc-img-caption></p></div><p><br></p><p>这段代码虽然短，但其实不简单，想要完全看懂需要对递归和循环有深入的理解。属于典型的看着简单实际不容易的题，我个人比较喜欢这类问题，除了锻炼思维之外也很适合用来面试，候选人的思维能力、代码驾驭能力基本上都一清二楚了。没有看懂的同学也不用担心，因为在实际场景当中并不会遇到这样的场景，以后还会推出其他关于递归和搜索算法的文章，只要你坚持阅读，我相信一定会看懂的。</p><p><br></p><p>今天的文章就是这些，如果觉得有所收获，请<strong>顺手点个关注或转发</strong>吧，你们的举手之劳对我来说很重要。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','30'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>