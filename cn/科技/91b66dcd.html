<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大道至简：Java 代码11个方面的精简之道（示例品鉴） | 极客快訊</title><meta property="og:title" content="大道至简：Java 代码11个方面的精简之道（示例品鉴） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/30747658a7ff4b3a8fc8989c80252571"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91b66dcd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91b66dcd.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="大道至简：Java 代码11个方面的精简之道（示例品鉴）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/91b66dcd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大道至简：Java 代码11个方面的精简之道（示例品鉴）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>作者： 常意(原名陈昌毅，地图技术专家)</p><p>链接：https://mp.weixin.qq.com/s/A1Z8YZyqQsFqK1TA1dTl2Q</p></blockquote><h2 class=pgc-h-arrow-right><strong>前言</strong></h2><hr><p>古语有云：</p><blockquote><p>道为术之灵，术为道之体；以道统术，以术得道。</p></blockquote><p>其中：“道”指“规律、道理、理论”，“术”指“方法、技巧、技术”。意思是：“道”是“术”的灵魂，“术”是“道”的肉体；可以用“道”来统管“术”，也可以从“术”中获得“道”。</p><p><br></p><p>在拜读大佬“孤尽”的文章《Code Review是苦涩但有意思的修行》时，感受最深的一句话就是：“优质的代码一定是少即是多的精兵原则”，这就是大佬的代码精简之“道”。</p><p><br></p><p>工匠追求“术”到极致，其实就是在寻“道”，且离悟“道”也就不远了，亦或是已经得道，这就是“工匠精神”——一种追求“以术得道”的精神。如果一个工匠只满足于“术”，不能追求“术”到极致去悟“道”，那只是一个靠“术”养家糊口的工匠而已。作者根据多年来的实践探索，总结了大量的 Java 代码精简之“术”，试图阐述出心中的 Java 代码精简之“道”。</p><p><br></p><div class=pgc-img><img alt="大道至简：Java 代码11个方面的精简之道（示例品鉴）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/30747658a7ff4b3a8fc8989c80252571><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><strong>1.利用语法</strong></h2><hr><h3 class=pgc-h-arrow-right><strong>1.1.利用三元表达式</strong></h3><p><strong>普通：</strong></p><pre><code>String title;if (isMember(phone)) {  title = "会员";} else {   title = "游客";}</code></pre><p><strong>精简：</strong></p><pre><code>String title = isMember(phone) ? "会员" : "游客";</code></pre><p>注意：对于包装类型的算术计算，需要注意避免拆包时的空指针问题。</p><h3 class=pgc-h-arrow-right><strong>1.2.利用 for-each 语句</strong></h3><p>从 Java 5 起，提供了 for-each 循环，简化了数组和集合的循环遍历。 for-each 循环允许你无需保持传统 for 循环中的索引就可以遍历数组，或在使用迭代器时无需在 while 循环中调用 hasNext 方法和 next 方法就可以遍历集合。</p><p><strong>普通：</strong></p><pre><code>double[] values = ...;for(int i = 0; i &lt; values.length; i++) {  double value = values[i];  // TODO: 处理value}List&lt;Double&gt; valueList = ...;Iterator&lt;Double&gt; iterator = valueList.iterator();while (iterator.hasNext()) {  Double value = iterator.next();   // TODO: 处理value}</code></pre><p><strong>精简：</strong></p><pre><code>double[] values = ...;for(double value : values) {  // TODO: 处理value}List&lt;Double&gt; valueList = ...;for(Double value : valueList) {  // TODO: 处理value}</code></pre><h3 class=pgc-h-arrow-right><strong>1.3.利用 try-with-resource 语句</strong></h3><p>所有实现 Closeable 接口的“资源”，均可采用 try-with-resource 进行简化。</p><p><strong>普通：</strong></p><pre><code>BufferedReader reader = null;try {  reader = new BufferedReader(new FileReader("cities.csv"));   String line;  while ((line = reader.readLine()) != null) {    // TODO: 处理line   }} catch (IOException e) {  log.error("读取文件异常", e);} finally {   if (reader != null) {     try {      reader.close();    } catch (IOException e) {      log.error("关闭文件异常", e);    }  }}</code></pre><p><strong>精简：</strong></p><pre><code>try (BufferedReader reader = new BufferedReader(new FileReader("test.txt"))) {  String line;  while ((line = reader.readLine()) != null) {    // TODO: 处理line  }} catch (IOException e) {  log.error("读取文件异常", e);}</code></pre><h3 class=pgc-h-arrow-right><strong>1.4.利用 return 关键字</strong></h3><p>利用 return 关键字，可以提前函数返回，避免定义中间变量。</p><p><strong>普通：</strong></p><pre><code>public static boolean hasSuper(@NonNull List&lt;UserDO&gt; userList) {  boolean hasSuper = false;   for (UserDO user : userList) {    if (Boolean.TRUE.equals(user.getIsSuper())) {      hasSuper = true;       break;    }  }   return hasSuper;}</code></pre><p><strong>精简：</strong></p><pre><code>public static boolean hasSuper(@NonNull List&lt;UserDO&gt; userList) {  for (UserDO user : userList) {    if (Boolean.TRUE.equals(user.getIsSuper())) {      return true;     }    }    return false;}</code></pre><h3 class=pgc-h-arrow-right><strong>1.5.利用 static 关键字</strong></h3><p>利用 static 关键字，可以把字段变成静态字段，也可以把函数变为静态函数，调用时就无需初始化类对象。</p><p><strong>普通：</strong></p><pre><code>public final class GisHelper {   public double distance(double lng1, double lat1, double lng2, double lat2) {    // 方法实现代码   }}GisHelper gisHelper = new GisHelper();double distance = gisHelper.distance(116.178692D, 39.967115D, 116.410778D, 39.899721D);</code></pre><p><strong>精简：</strong></p><pre><code>public final class GisHelper {  public static double distance(double lng1, double lat1, double lng2, double lat2) {    // 方法实现代码  }}double distance = GisHelper.distance(116.178692D, 39.967115D, 116.410778D, 39.899721D);</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>1.6.利用 lambda 表达式</strong></h3><p>Java 8 发布以后，lambda 表达式大量替代匿名内部类的使用，在简化了代码的同时，更突出了原有匿名内部类中真正有用的那部分代码。</p><p><strong>普通：</strong></p><pre><code>new Thread(new Runnable() {            public void run() {  // 线程处理代码}}).start();</code></pre><p><strong>精简：</strong></p><pre><code>new Thread(() -&gt; {   // 线程处理代码}).start();</code></pre><h3 class=pgc-h-arrow-right><strong>1.7.利用方法引用</strong></h3><p>方法引用（::），可以简化 lambda 表达式，省略变量声明和函数调用。</p><p><strong>普通：</strong></p><pre><code>Arrays.sort(nameArray, (a, b) -&gt; a.compareToIgnoreCase(b));List&lt;Long&gt; userIdList = userList.stream()  .map(user -&gt; user.getId())   .collect(Collectors.toList());</code></pre><p><br><strong>精简：</strong></p><pre><code>Arrays.sort(nameArray, String::compareToIgnoreCase);List&lt;Long&gt; userIdList = userList.stream()  .map(UserDO::getId)  .collect(Collectors.toList());</code></pre><p><br></p><h3 class=pgc-h-arrow-right><strong>1.8.利用静态导入</strong></h3><p>静态导入（import static），当程序中大量使用同一静态常量和函数时，可以简化静态常量和函数的引用。</p><p><strong>普通：</strong></p><pre><code>List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; Math.PI * Math.pow(r, 2)).collect(Collectors.toList());...</code></pre><p><strong>精简：</strong></p><pre><code>import static java.lang.Math.PI;import static java.lang.Math.pow;import static java.util.stream.Collectors.toList;List&lt;Double&gt; areaList = radiusList.stream().map(r -&gt; PI * pow(r, 2)).collect(toList());...</code></pre><p>注意：静态引入容易造成代码阅读困难，所以在实际项目中应该警慎使用。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>1.9.利用 unchecked 异常</strong></h3><p>Java 的异常分为两类：Checked 异常和 Unchecked 异常。Unchecked 异常继承了RuntimeException ，特点是代码不需要处理它们也能通过编译，所以它们称作 Unchecked 异常。利用 Unchecked 异常，可以避免不必要的 try-catch 和 throws 异常处理。</p><p><br></p><p><strong>普通：</strong></p><pre><code>@Servicepublic class UserService {  public void createUser(UserCreateVO create, OpUserVO user) throws BusinessException {    checkOperatorUser(user);     ...  }    private void checkOperatorUser(OpUserVO user) throws BusinessException {      if (!hasPermission(user)) {         throw new BusinessException("用户无操作权限");       }       ...      }      ...    }           @RestController      @RequestMapping("/user")      public class UserController {         @Autowired    private UserService userService;                @PostMapping("/createUser")         public Result&lt;Void&gt; createUser(@RequestBody @Valid UserCreateVO create, OpUserVO user) throws BusinessException {          userService.createUser(create, user);          return Result.success();        }       ...    }</code></pre><p><strong>精简：</strong></p><pre><code>@Servicepublic class UserService {   public void createUser(UserCreateVO create, OpUserVO user) {    checkOperatorUser(user);     ...  }    private void checkOperatorUser(OpUserVO user) {      if (!hasPermission(user)) {        throw new BusinessRuntimeException("用户无操作权限");      }       ...     }         ... }              @RestController@RequestMapping("/user")      public class UserController {         @Autowired        private UserService userService;         @PostMapping("/createUser")         public Result&lt;Void&gt; createUser(@RequestBody @Valid UserCreateVO create, OpUserVO user) {          userService.createUser(create, user);          return Result.success();        }      ...    }</code></pre><p><br></p><h2 class=pgc-h-arrow-right><strong>2.利用注解</strong></h2><hr><p><strong>2.1.利用 Lombok 注解</strong></p><p>Lombok 提供了一组有用的注解，可以用来消除Java类中的大量样板代码。</p><p><strong>普通：</strong></p><pre><code>public class UserVO {  private Long id;  private String name;  public Long getId() {     return this.id;   }  public void setId(Long id) {    this.id = id;  }   public String getName() {     return this.name;   }  public void setName(String name) {     this.name = name;   }   ...}</code></pre><p><strong>精简：</strong></p><pre><code>@Getter@Setter@ToStringpublic class UserVO {  private Long id;  private String name;   ...}</code></pre><h3 class=pgc-h-arrow-right><strong>2.2.利用 Validation 注解</strong></h3><p><strong>普通：</strong></p><pre><code>  @Getter@Setter@ToStringpublic class UserCreateVO {  @NotBlank(message = "用户名称不能为空")  private String name;   @NotNull(message = "公司标识不能为空")  private Long companyId;   ...}@Service@Validatedpublicclass UserService {  public Long createUser(@Valid UserCreateVO create) {    // TODO: 创建用户    return null;  }}</code></pre><p><strong>精简：</strong></p><pre><code>@Getter@Setter@ToStringpublic class UserCreateVO {  @NotBlank(message = "用户名称不能为空")  private String name;   @NotNull(message = "公司标识不能为空")  private Long companyId;   ...}@Service@Validatedpublic class UserService {    public Long createUser(@Valid UserCreateVO create) {        // TODO: 创建用户        return null;    }}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>2.3.利用 @NonNull 注解</strong></h3><p><br></p><p>Spring 的 @NonNull 注解，用于标注参数或返回值非空，适用于项目内部团队协作。只要实现方和调用方遵循规范，可以避免不必要的空值判断，这充分体现了阿里的“新六脉神剑”提倡的“因为信任，所以简单”。</p><p><strong>普通：</strong></p><pre><code>public List&lt;UserVO&gt; queryCompanyUser(Long companyId) {  // 检查公司标识  if (companyId == null) {    return null;  }   // 查询返回用户  List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);   return userList.stream().map(this::transUser).collect(Collectors.toList());}Long companyId = 1L;List&lt;UserVO&gt; userList = queryCompanyUser(companyId);if (CollectionUtils.isNotEmpty(userList)) {  for (UserVO user : userList) {    // TODO: 处理公司用户  }}</code></pre><p><strong>精简：</strong></p><pre><code>public @NonNull List&lt;UserVO&gt; queryCompanyUser(@NonNull Long companyId) {  List&lt;UserDO&gt; userList = userDAO.queryByCompanyId(companyId);  return userList.stream().map(this::transUser).collect(Collectors.toList());}Long companyId = 1L;List&lt;UserVO&gt; userList = queryCompanyUser(companyId);for (UserVO user : userList) {  // TODO: 处理公司用户}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>2.4.利用注解特性</strong></h3><p>注解有以下特性可用于精简注解声明：</p><p>1、当注解属性值跟默认值一致时，可以删除该属性赋值；</p><p>2、当注解只有value属性时，可以去掉value进行简写；</p><p>3、当注解属性组合等于另一个特定注解时，直接采用该特定注解。</p><p><br></p><p><strong>普通：</strong></p><pre><code>@Lazy(true);@Service(value = "userService")@RequestMapping(path = "/getUser", method = RequestMethod.GET)</code></pre><pre><code></code></pre><p><strong>精简：</strong></p><pre><code>@Lazy@Service("userService")@GetMapping("/getUser")</code></pre><h2 class=pgc-h-arrow-right><strong>3.利用泛型</strong></h2><hr><p><strong>3.1.泛型接口</strong></p><p>在 Java 没有引入泛型前，都是采用 Object 表示通用对象，最大的问题就是类型无法强校验并且需要强制类型转换。</p><p><strong>普通：</strong></p><pre><code>public interface Comparable {  public int compareTo(Object other);}@Getter@Setter@ToStringpublic class UserVO implements Comparable {  private Long id;   @Override    public int compareTo(Object other) {    UserVO user = (UserVO)other;    return Long.compare(this.id, user.id);  }}</code></pre><p><strong>精简：</strong></p><pre><code>public interface Comparable&lt;T&gt; {  public int compareTo(T other);}@Getter@Setter@ToStringpublic class UserVO implements Comparable&lt;UserVO&gt; {  private Long id;  @Override  public int compareTo(UserVO other) {    return Long.compare(this.id, other.id);  }}</code></pre><p><br></p><h3 class=pgc-h-arrow-right><strong>3.2.泛型类</strong></h3><p><strong>普通：</strong></p><pre><code>@Getter@Setter@ToStringpublic class IntPoint {  private Integer x;  private Integer y;}@Getter@Setter@ToStringpublic class DoublePoint {  private Double x;  private Double y;}</code></pre><p><strong>精简：</strong></p><pre><code>@Getter@Setter@ToStringpublic class Point&lt;T extends Number&gt; {  private T x;  private T y;}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>3.3.泛型方法</strong></h3><p><strong>普通：</strong></p><pre><code>public static Map&lt;String, Integer&gt; newHashMap(String[] keys, Integer[] values) {  // 检查参数非空   if (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {    return Collections.emptyMap();   }     // 转化哈希映射   Map&lt;String, Integer&gt; map = new HashMap&lt;&gt;();   int length = Math.min(keys.length, values.length);   for (int i = 0; i &lt; length; i++) {     map.put(keys[i], values[i]);  }  return map;}...</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>public static &lt;K, V&gt; Map&lt;K, V&gt; newHashMap(K[] keys, V[] values) {   // 检查参数非空   if (ArrayUtils.isEmpty(keys) || ArrayUtils.isEmpty(values)) {    return Collections.emptyMap();  }     // 转化哈希映射  Map&lt;K, V&gt; map = new HashMap&lt;&gt;();  int length = Math.min(keys.length, values.length);   for (int i = 0; i &lt; length; i++) {    map.put(keys[i], values[i]);  }   return map;}</code></pre><h2 class=pgc-h-arrow-right><strong>4.利用自身方法</strong></h2><hr><p><strong>4.1.利用构造方法</strong></p><p>构造方法，可以简化对象的初始化和设置属性操作。对于属性字段较少的类，可以自定义构造方法。</p><p><strong>普通：</strong></p><pre><code>@Getter@Setter@ToStringpublic class PageDataVO&lt;T&gt; {  private Long totalCount;  private List&lt;T&gt; dataList;}PageDataVO&lt;UserVO&gt; pageData = new PageDataVO&lt;&gt;();pageData.setTotalCount(totalCount);pageData.setDataList(userList);return pageData;</code></pre><p><strong>精简：</strong></p><pre><code>@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class PageDataVO&lt;T&gt; {  private Long totalCount;  private List&lt;T&gt; dataList;}return new PageDataVO&lt;&gt;(totalCount, userList);</code></pre><p>注意：如果属性字段被替换时，存在构造函数初始化赋值问题。比如把属性字段title替换为 nickname ，由于构造函数的参数个数和类型不变，原有构造函数初始化语句不会报错，导致把原title值赋值给 nickname 。如果采用 Setter 方法赋值，编译器会提示错误并要求修复。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>4.2.利用 Set 的 add 方法</strong></h3><p>利用 Set 的 add 方法的返回值，可以直接知道该值是否已经存在，可以避免调用 contains 方法判断存在。</p><p><strong>普通：</strong></p><p>以下案例是进行用户去重转化操作，需要先调用 contains 方法判断存在，后调用add方法进行添加。</p><pre><code>Set&lt;Long&gt; userIdSet = new HashSet&lt;&gt;();List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;();for (UserDO userDO : userDOList) {   if (!userIdSet.contains(userDO.getId())) {    userIdSet.add(userDO.getId());    userVOList.add(transUser(userDO));  }}</code></pre><p><strong>精简：</strong></p><pre><code>SSet&lt;Long&gt; userIdSet = new HashSet&lt;&gt;();List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;();for (UserDO userDO : userDOList) {  if (userIdSet.add(userDO.getId())) {    userVOList.add(transUser(userDO));  }}</code></pre><h3 class=pgc-h-arrow-right><strong>4.3.利用 Map 的 computeIfAbsent 方法</strong></h3><p>利用 Map 的 computeIfAbsent 方法，可以保证获取到的对象非空，从而避免了不必要的空判断和重新设置值。</p><p><strong>普通：</strong></p><pre><code>Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = new HashMap&lt;&gt;();for (UserDO userDO : userDOList) {  Long roleId = userDO.getRoleId();  List&lt;UserDO&gt; userList = roleUserMap.get(roleId);  if (Objects.isNull(userList)) {     userList = new ArrayList&lt;&gt;();    roleUserMap.put(roleId, userList);  }   userList.add(userDO);}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = new HashMap&lt;&gt;();for (UserDO userDO : userDOList) {   roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; new ArrayList&lt;&gt;())    .add(userDO);}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>4.4.利用链式编程</strong></h3><p>链式编程，也叫级联式编程，调用对象的函数时返回一个this对象指向对象本身，达到链式效果，可以级联调用。链式编程的优点是：编程性强、可读性强、代码简洁。</p><p><strong>普通：</strong></p><pre><code>StringBuilder builder = new StringBuilder(96);builder.append("select id, name from ");builder.append(T_USER);builder.append(" where id = ");builder.append(userId);builder.append(";");</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>StringBuilder builder = new StringBuilder(96);builder.append("select id, name from ")  .append(T_USER)  .append(" where id = ")  .append(userId)  .append(";");</code></pre><h2 class=pgc-h-arrow-right><strong>5.利用工具方法</strong></h2><hr><p><strong>5.1.避免空值判断</strong></p><p><br></p><p><strong>普通：</strong></p><pre><code>if (userList != null &amp;&amp; !userList.isEmpty()) {  // TODO: 处理代码}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>if (CollectionUtils.isNotEmpty(userList)) {    // TODO: 处理代码}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>5.2.避免条件判断</strong></h3><p><strong>普通：</strong></p><pre><code>double result;if (value &lt;= MIN_LIMIT) {  result = MIN_LIMIT;} else {  result = value;}</code></pre><p><strong>精简：</strong></p><pre><code>double result = Math.max(MIN_LIMIT, value);</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>5.3.简化赋值语句</strong></h3><p><strong>普通：</strong></p><pre><code>public static final List&lt;String&gt; ANIMAL_LIST;static {  List&lt;String&gt; animalList = new ArrayList&lt;&gt;();  animalList.add("dog");  animalList.add("cat");  animalList.add("tiger");  ANIMAL_LIST = Collections.unmodifiableList(animalList);}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>// JDK流派public static final List&lt;String&gt; ANIMAL_LIST = Arrays.asList("dog", "cat", "tiger");// Guava流派public static final List&lt;String&gt; ANIMAL_LIST = ImmutableList.of("dog", "cat", "tiger");</code></pre><p>注意：Arrays.asList 返回的 List 并不是 ArrayList ，不支持 add 等变更操作。</p><h3 class=pgc-h-arrow-right><strong>5.4.简化数据拷贝</strong></h3><p><strong>普通：</strong></p><pre><code>UserVO userVO = new UserVO();userVO.setId(userDO.getId());userVO.setName(userDO.getName());...userVO.setDescription(userDO.getDescription());userVOList.add(userVO);</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>UserVO userVO = new UserVO();BeanUtils.copyProperties(userDO, userVO);userVOList.add(userVO);</code></pre><p><br></p><p><strong>反例：</strong></p><pre><code>List&lt;UserVO&gt; userVOList = JSON.parseArray(JSON.toJSONString(userDOList), UserVO.class);</code></pre><p>精简代码，但不能以过大的性能损失为代价。例子是浅层拷贝，用不着 JSON 这样重量级的武器。</p><p><br></p><h2 class=pgc-h-arrow-right>5.5.简化异常断言</h2><p><br></p><p><strong>普通：</strong></p><pre><code>if (Objects.isNull(userId)) {    throw new IllegalArgumentException("用户标识不能为空");}</code></pre><p><strong>精简：</strong></p><pre><code>Assert.notNull(userId, "用户标识不能为空");</code></pre><p>注意：可能有些插件不认同这种判断，导致使用该对象时会有空指针警告。</p><h3 class=pgc-h-arrow-right><strong>5.6.简化测试用例</strong></h3><p>把测试用例数据以 JSON 格式存入文件中，通过 JSON 的 parseObject 和 parseArray 方法解析成对象。虽然执行效率上有所下降，但可以减少大量的赋值语句，从而精简了测试代码。</p><p><strong>普通：</strong></p><pre><code>@Testpublic void testCreateUser() {  UserCreateVO userCreate = new UserCreateVO();   userCreate.setName("Changyi");  userCreate.setTitle("Developer");  userCreate.setCompany("AMAP");   ...      Long userId  = userService.createUser(OPERATOR, userCreate);   Assert.assertNotNull(userId, "创建用户失败");}</code></pre><p><br><strong>精简：</strong></p><pre><code>@Testpublic void testCreateUser() {  String jsonText = ResourceHelper.getResourceAsString(getClass(), "createUser.json");   UserCreateVO userCreate = JSON.parseObject(jsonText, UserCreateVO.class);   Long userId  = userService.createUser(OPERATOR, userCreate);  Assert.assertNotNull(userId, "创建用户失败");}</code></pre><p>建议：JSON 文件名最好以被测试的方法命名，如果有多个版本可以用数字后缀表示。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>5.7.简化算法实现</strong></h3><p>一些常规算法，已有现成的工具方法，我们就没有必要自己实现了。</p><p><strong>普通：</strong></p><pre><code>int totalSize = valueList.size();List&lt;List&lt;Integer&gt;&gt; partitionList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; totalSize; i += PARTITION_SIZE) {  partitionList.add(valueList.subList(i, Math.min(i + PARTITION_SIZE, totalSize)));}</code></pre><p><strong>精简：</strong></p><pre><code>List&lt;List&lt;Integer&gt;&gt; partitionList = ListUtils.partition(valueList, PARTITION_SIZE);</code></pre><p><br></p><h2 class=pgc-h-arrow-right>5.8.封装工具方法</h2><p><br></p><p>一些特殊算法，没有现成的工具方法，我们就只好自己亲自实现了。</p><p><strong>普通：</strong></p><p>比如，SQL 设置参数值的方法就比较难用，setLong 方法不能设置参数值为 null 。</p><pre><code> // 设置参数值if (Objects.nonNull(user.getId())) {  statement.setLong(1, user.getId());} else {  statement.setNull(1, Types.BIGINT);}...</code></pre><p><br></p><p><strong>精简：</strong></p><p>我们可以封装为一个工具类 SqlHelper ，简化设置参数值的代码。</p><pre><code>/** SQL辅助类 */public final class SqlHelper {    /** 设置长整数值 */    public static void setLong(PreparedStatement statement, int index, Long value) throws SQLException {        if (Objects.nonNull(value)) {            statement.setLong(index, value.longValue());        } else {            statement.setNull(index, Types.BIGINT);        }    }    ...} // 设置参数值SqlHelper.setLong(statement, 1, user.getId());</code></pre><p><br></p><h2 class=pgc-h-arrow-right><strong>6.利用数据结构</strong></h2><hr><p><strong>6.1.利用数组简化</strong></p><p>对于固定上下限范围的 if-else 语句，可以用数组+循环来简化。</p><p><strong>普通：</strong></p><pre><code>public static int getGrade(double score) {  if (score &gt;= 90.0D) {    return 1;  }  if (score &gt;= 80.0D) {    return 2;  }   if (score &gt;= 60.0D) {    return 3;   }  if (score &gt;= 30.0D) {    return 4;  }  return 5;}</code></pre><p><strong>精简：</strong></p><pre><code>private static final double[] SCORE_RANGES = new double[] {90.0D, 80.0D, 60.0D, 30.0D};public static int getGrade(double score) {  for (int i = 0; i &lt; SCORE_RANGES.length; i++) {    if (score &gt;= SCORE_RANGES[i]) {      return i + 1;     }   }  return SCORE_RANGES.length + 1;}</code></pre><p><br></p><p>思考：上面的案例返回值是递增的，所以用数组简化是没有问题的。但是，如果返回值不是递增的，能否用数组进行简化呢？答案是可以的，请自行思考解决。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>6.2.利用 Map 简化</strong></h3><p>对于映射关系的 if-else 语句，可以用Map来简化。此外，此规则同样适用于简化映射关系的 switch 语句。</p><p><strong>普通：</strong></p><pre><code>public static String getBiologyClass(String name) {  switch (name) {    case "dog" :       return "animal";     case "cat" :        return "animal";      case "lavender" :       return "plant";       ...       default :       return null;  }}</code></pre><p><br><strong>精简：</strong></p><pre><code>private static final Map&lt;String, String&gt; BIOLOGY_CLASS_MAP  = ImmutableMap.&lt;String, String&gt;builder()   .put("dog", "animal")  .put("cat", "animal")  .put("lavender", "plant")   ...     .build();public static String getBiologyClass(String name) {  return BIOLOGY_CLASS_MAP.get(name);}</code></pre><p>已经把方法简化为一行代码，其实都没有封装方法的必要了。</p><p><br></p><h3 class=pgc-h-arrow-right><strong>6.3.利用容器类简化</strong></h3><p>Java 不像 Python 和 Go ，方法不支持返回多个对象。如果需要返回多个对象，就必须自定义类，或者利用容器类。常见的容器类有 Apache 的 Pair 类和 Triple 类， Pair 类支持返回 2 个对象， Triple 类支持返回 3 个对象。</p><p><strong>普通：</strong></p><pre><code>@Setter@Getter@ToString@AllArgsConstructorpublic static class PointAndDistance {  private Point point;  private Double distance;}public static PointAndDistance getNearest(Point point, Point[] points) {  // 计算最近点和距离  ...    // 返回最近点和距离  return new PointAndDistance(nearestPoint, nearestDistance);}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>public static Pair&lt;Point, Double&gt; getNearest(Point point, Point[] points) {  // 计算最近点和距离  ...   // 返回最近点和距离  return ImmutablePair.of(nearestPoint, nearestDistance);}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>6.4.利用 ThreadLocal 简化</strong></h3><p>ThreadLocal 提供了线程专有对象，可以在整个线程生命周期中随时取用，极大地方便了一些逻辑的实现。用 ThreadLocal 保存线程上下文对象，可以避免不必要的参数传递。</p><p><strong>普通：</strong></p><p>由于 DateFormat 的 format 方法线程非安全（建议使用替代方法），在线程中频繁初始化 DateFormat 性能太低，如果考虑重用只能用参数传入 DateFormat 。例子如下：</p><pre><code>public static String formatDate(Date date, DateFormat format) {  return format.format(date);}public static List&lt;String&gt; getDateList(Date minDate, Date maxDate, DateFormat format) {  List&lt;String&gt; dateList = new ArrayList&lt;&gt;();  Calendar calendar = Calendar.getInstance();  calendar.setTime(minDate);  String currDate = formatDate(calendar.getTime(), format);  String maxsDate = formatDate(maxDate, format);  while (currDate.compareTo(maxsDate) &lt;= 0) {    dateList.add(currDate);    calendar.add(Calendar.DATE, 1);    currDate = formatDate(calendar.getTime(), format);   }  return dateList;}</code></pre><p><br><strong>精简：</strong></p><p>可能你会觉得以下的代码量反而多了，如果调用工具方法的地方比较多，就可以省下一大堆 DateFormat 初始化和传入参数的代码。</p><pre><code>private static final ThreadLocal&lt;DateFormat&gt; LOCAL_DATE_FORMAT = new ThreadLocal&lt;DateFormat&gt;() {  @Override  protected DateFormat initialValue() {     return new SimpleDateFormat("yyyyMMdd");  }};public static String formatDate(Date date) {    return LOCAL_DATE_FORMAT.get().format(date);}public static List&lt;String&gt; getDateList(Date minDate, Date maxDate) {    List&lt;String&gt; dateList = new ArrayList&lt;&gt;();    Calendar calendar = Calendar.getInstance();    calendar.setTime(minDate);    String currDate = formatDate(calendar.getTime());    String maxsDate = formatDate(maxDate);    while (currDate.compareTo(maxsDate) &lt;= 0) {        dateList.add(currDate);        calendar.add(Calendar.DATE, 1);        currDate = formatDate(calendar.getTime());    }    return dateList;}</code></pre><p>注意：ThreadLocal 有一定的内存泄露的风险，尽量在业务代码结束前调用 remove 方法进行数据清除。</p><p><br></p><h2 class=pgc-h-arrow-right><strong>7.利用 Optional</strong></h2><hr><p>在 Java 8 里，引入了一个 Optional 类，该类是一个可以为 null 的容器对象。</p><h3 class=pgc-h-arrow-right><strong>7.1.保证值存在</strong></h3><p><br></p><p><strong>普通：</strong></p><pre><code>Integer thisValue;if (Objects.nonNull(value)) {  thisValue = value;} else {  thisValue = DEFAULT_VALUE;}</code></pre><p><strong>精简：</strong></p><pre><code>Integer thisValue = Optional.ofNullable(value).orElse(DEFAULT_VALUE);</code></pre><p><br></p><h3 class=pgc-h-arrow-right><strong>7.2.保证值合法</strong></h3><p><strong>普通：</strong></p><pre><code>Integer thisValue;if (Objects.nonNull(value) &amp;&amp; value.compareTo(MAX_VALUE) &lt;= 0) {  thisValue = value;} else {  thisValue = MAX_VALUE;}</code></pre><p><br><strong>精简：</strong></p><pre><code>Integer thisValue = Optional.ofNullable(value)  .filter(tempValue -&gt; tempValue.compareTo(MAX_VALUE) &lt;= 0).orElse(MAX_VALUE);</code></pre><p>7.3.避免空判断</p><p><strong>普通：</strong></p><pre><code>String zipcode = null;if (Objects.nonNull(user)) {  Address address = user.getAddress();  if (Objects.nonNull(address)) {    Country country = address.getCountry();    if (Objects.nonNull(country)) {      zipcode = country.getZipcode();     }  }}</code></pre><p><br><strong>精简：</strong></p><pre><code>tring zipcode = Optional.ofNullable(user).map(User::getAddress)  .map(Address::getCountry).map(Country::getZipcode).orElse(null);</code></pre><h2 class=pgc-h-arrow-right><strong>8.利用 Stream</strong></h2><hr><p>流（Stream）是Java 8的新成员，允许你以声明式处理数据集合，可以看成为一个遍历数据集的高级迭代器。流主要有三部分构成：获取一个数据源→数据转换→执行操作获取想要的结果。每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象，这就允许对其操作可以像链条一样排列，形成了一个管道。流（Stream）提供的功能非常有用，主要包括匹配、过滤、汇总、转化、分组、分组汇总等功能。</p><h3 class=pgc-h-arrow-right><strong>8.1.匹配集合数据</strong></h3><p><strong>普通：</strong></p><pre><code>boolean isFound = false;for (UserDO user : userList) {   if (Objects.equals(user.getId(), userId)) {    isFound = true;    break;  }}</code></pre><p><strong>精简：</strong></p><pre><code>boolean isFound = userList.stream()  .anyMatch(user -&gt; Objects.equals(user.getId(), userId));</code></pre><h2 class=pgc-h-arrow-right><br>8.2.过滤集合数据</h2><p><strong>普通：</strong></p><pre><code>List&lt;UserDO&gt; resultList = new ArrayList&lt;&gt;();for (UserDO user : userList) {  if (Boolean.TRUE.equals(user.getIsSuper())) {    resultList.add(user);  }}</code></pre><p><br><strong>精简：</strong></p><pre><code>List&lt;UserDO&gt; resultList = userList.stream()   .filter(user -&gt; Boolean.TRUE.equals(user.getIsSuper()))  .collect(Collectors.toList());</code></pre><h2 class=pgc-h-arrow-right><br>8.3.汇总集合数据</h2><p><strong>普通：</strong></p><pre><code>double total = 0.0D;for (Account account : accountList) {  total += account.getBalance();}</code></pre><p><br><strong>精简：</strong></p><pre><code>double total = accountList.stream().mapToDouble(Account::getBalance).sum();</code></pre><p><br></p><h2 class=pgc-h-arrow-right>8.4.转化集合数据</h2><p><br></p><p><strong>普通：</strong></p><pre><code>List&lt;UserVO&gt; userVOList = new ArrayList&lt;&gt;();for (UserDO userDO : userDOList) {  userVOList.add(transUser(userDO));}</code></pre><p><br><strong>精简：</strong></p><pre><code>List&lt;UserVO&gt; userVOList = userDOList.stream()  .map(this::transUser).collect(Collectors.toList());</code></pre><h3 class=pgc-h-arrow-right><strong>8.5.分组集合数据</strong></h3><p><strong>普通：</strong></p><pre><code>Map&lt;Long, List&lt;UserDO&gt;&gt; roleUserMap = new HashMap&lt;&gt;();for (UserDO userDO : userDOList) {  roleUserMap.computeIfAbsent(userDO.getRoleId(), key -&gt; new ArrayList&lt;&gt;())    .add(userDO);}</code></pre><p><br><strong>精简：</strong></p><p>Map&lt;Long, List&lt;UserDO>> roleUserMap = userDOList.stream()<br>.collect(Collectors.groupingBy(UserDO::getRoleId));</p><h2 class=pgc-h-arrow-right><br>8.6.分组汇总集合</h2><p><strong>普通：</strong></p><pre><code>Map&lt;Long, Double&gt; roleTotalMap = new HashMap&lt;&gt;();for (Account account : accountList) {  Long roleId = account.getRoleId();   Double total = Optional.ofNullable(roleTotalMap.get(roleId)).orElse(0.0D);  roleTotalMap.put(roleId, total + account.getBalance());}</code></pre><p><br><strong>精简：</strong></p><pre><code>roleTotalMap = accountList.stream()  .collect(Collectors.groupingBy(Account::getRoleId, Collectors.summingDouble(Account::getBalance)));</code></pre><p><br></p><h2 class=pgc-h-arrow-right>8.7.生成范围集合</h2><p><br></p><p>Python 的 range 非常方便，Stream 也提供了类似的方法。</p><p><strong>普通：</strong></p><pre><code>int[] array1 = new int[N];for (int i = 0; i &lt; N; i++) {  array1[i] = i + 1;}int[] array2 = new int[N];array2[0] = 1;for (int i = 1; i &lt; N; i++) {  array2[i] = array2[i - 1] * 2;}</code></pre><p><br><strong>精简：</strong></p><pre><code>int[] array1 = IntStream.rangeClosed(1, N).toArray();int[] array2 = IntStream.iterate(1, n -&gt; n * 2).limit(N).toArray();</code></pre><h2 class=pgc-h-arrow-right><strong>9.利用程序结构</strong></h2><hr><h3 class=pgc-h-arrow-right><strong>9.1.返回条件表达式</strong></h3><p>条件表达式判断返回布尔值，条件表达式本身就是结果。</p><p><strong>普通：</strong></p><pre><code>public boolean isSuper(Long userId)    UserDO user = userDAO.get(userId);if (Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper())) {  return true; } return false;}</code></pre><p><br><strong>精简：</strong></p><pre><code>public boolean isSuper(Long userId){  UserDO user = userDAO.get(userId);   return Objects.nonNull(user) &amp;&amp; Boolean.TRUE.equals(user.getIsSuper());}</code></pre><h2 class=pgc-h-arrow-right><br>9.2.最小化条件作用域</h2><p>最小化条件作用域，尽量提出公共处理代码。</p><p><strong>普通：</strong></p><pre><code>Result result = summaryService.reportWorkDaily(workDaily);if (result.isSuccess()) {  String message = "上报工作日报成功";   dingtalkService.sendMessage(user.getPhone(), message);} else {  String message = "上报工作日报失败:" + result.getMessage();  log.warn(message);  dingtalkService.sendMessage(user.getPhone(), message);}</code></pre><p><br><strong>精简：</strong></p><pre><code>String message;Result result = summaryService.reportWorkDaily(workDaily);if (result.isSuccess()) {  message = "上报工作日报成功";} else {  message = "上报工作日报失败:" + result.getMessage();  log.warn(message);}dingtalkService.sendMessage(user.getPhone(), message);}</code></pre><h3 class=pgc-h-arrow-right><strong>9.3.调整表达式位置</strong></h3><p>调整表达式位置，在逻辑不变的前提下，让代码变得更简洁。</p><p><strong>普通1：</strong></p><pre><code>String line = readLine();while (Objects.nonNull(line)) {    ... // 处理逻辑代码    line = readLine();}</code></pre><p><strong>普通2：</strong></p><pre><code>for (String line = readLine(); Objects.nonNull(line); line = readLine()) {    ... // 处理逻辑代码}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>String line;while (Objects.nonNull(line = readLine())) {    ... // 处理逻辑代码}</code></pre><p>注意：有些规范可能不建议这种精简写法。</p><h3 class=pgc-h-arrow-right><strong>9.4.利用非空对象</strong></h3><p>在比较对象时，交换对象位置，利用非空对象，可以避免空指针判断。</p><p><strong>普通：</strong></p><pre><code>private static final int MAX_VALUE = 1000;boolean isMax = (value != null &amp;&amp; value.equals(MAX_VALUE));boolean isTrue = (result != null &amp;&amp; result.equals(Boolean.TRUE));</code></pre><p><strong>精简：</strong></p><pre><code>private static final Integer MAX_VALUE = 1000;boolean isMax = MAX_VALUE.equals(value);boolean isTrue = Boolean.TRUE.equals(result);</code></pre><h2 class=pgc-h-arrow-right><strong>10.利用设计模式</strong></h2><hr><p><strong>10.1.模板方法模式</strong></p><p>模板方法模式（Template Method Pattern）定义一个固定的算法框架，而将算法的一些步骤放到子类中实现，使得子类可以在不改变算法框架的情况下重定义该算法的某些步骤。</p><p><strong>普通：</strong></p><pre><code>@Repositorypublic class UserValue {  /** 值操作 */  @Resource(name = "stringRedisTemplate")   private ValueOperations&lt;String, String&gt; valueOperations;/** 值模式 */private static final String KEY_FORMAT = "Value:User:%s";/** 设置值 */public void set(Long id, UserDO value) {  String key = String.format(KEY_FORMAT, id);  valueOperations.set(key, JSON.toJSONString(value));} /** 获取值 */ public UserDO get(Long id) {   String key = String.format(KEY_FORMAT, id);  String value = valueOperations.get(key);  return JSON.parseObject(value, UserDO.class); } ...}@Repositorypublic class RoleValue {  /** 值操作 */  @Resource(name = "stringRedisTemplate")  private ValueOperations&lt;String, String&gt; valueOperations;/** 值模式 */private static final String KEY_FORMAT = "Value:Role:%s";/** 设置值 */ public void set(Long id, RoleDO value) {  String key = String.format(KEY_FORMAT, id);  valueOperations.set(key, JSON.toJSONString(value));} /** 获取值 */ public RoleDO get(Long id) {  String key = String.format(KEY_FORMAT, id);   String value = valueOperations.get(key);  return JSON.parseObject(value, RoleDO.class);}...}</code></pre><p><br><strong>精简：</strong></p><pre><code>public abstract class AbstractDynamicValue&lt;I, V&gt; {  /** 值操作 */  @Resource(name = "stringRedisTemplate")  private ValueOperations&lt;String, String&gt; valueOperations; /** 设置值 */ public void set(I id, V value) {  valueOperations.set(getKey(id), JSON.toJSONString(value));}/** 获取值 */public V get(I id) {  return JSON.parseObject(valueOperations.get(getKey(id)), getValueClass());}... /** 获取主键 */ protected abstract String getKey(I id);/** 获取值类 */protected abstract Class&lt;V&gt; getValueClass();}@Repositorypublic class UserValue extends AbstractValue&lt;Long, UserDO&gt; {    /** 获取主键 */    @Override    protected String getKey(Long id) {        return String.format("Value:User:%s", id);    }    /** 获取值类 */    @Override    protected Class&lt;UserDO&gt; getValueClass() {        return UserDO.class;    }}@Repositorypublic class RoleValue extends AbstractValue&lt;Long, RoleDO&gt; {    /** 获取主键 */    @Override    protected String getKey(Long id) {        return String.format("Value:Role:%s", id);    }    /** 获取值类 */    @Override    protected Class&lt;RoleDO&gt; getValueClass() {        return RoleDO.class;    }}</code></pre><h3 class=pgc-h-arrow-right><strong>10.2.建造者模式</strong></h3><p>建造者模式（Builder Pattern）将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。</p><p><strong>普通：</strong></p><pre><code>public interface DataHandler&lt;T&gt; {   /** 解析数据 */  public T parseData(Record record); /** 存储数据 */public boolean storeData(List&lt;T&gt; dataList);}public &lt;T&gt; long executeFetch(String tableName, int batchSize, DataHandler&lt;T&gt; dataHandler) throws Exception {  // 构建下载会话  DownloadSession session = buildSession(tableName);  // 获取数据数量  long recordCount = session.getRecordCount();  if (recordCount == 0) {    return 0;  }  // 进行数据读取  long fetchCount = 0L;   try (RecordReader reader = session.openRecordReader(0L, recordCount, true)) {    // 依次读取数据    Record record;     List&lt;T&gt; dataList = new ArrayList&lt;&gt;(batchSize);     while ((record = reader.read()) != null) {      // 解析添加数据      T data = dataHandler.parseData(record);      if (Objects.nonNull(data)) {         dataList.add(data);        }       // 批量存储数据        if (dataList.size() == batchSize) {        boolean isContinue = dataHandler.storeData(dataList);         fetchCount += batchSize;         dataList.clear();          if (!isContinue) {          break;         }        }     }     // 存储剩余数据    if (CollectionUtils.isNotEmpty(dataList)) {      dataHandler.storeData(dataList);      fetchCount += dataList.size();       dataList.clear();    }  }   // 返回获取数量  return fetchCount;}// 使用案例long fetchCount = odpsService.executeFetch("user", 5000, new DataHandler() {                                           /** 解析数据 */                    @Override                   public T parseData(Record record) {                      UserDO user = new UserDO();                      user.setId(record.getBigint("id"));                      user.setName(record.getString("name"));                      return user;                    }                    /** 存储数据 */                    @Override                    public boolean storeData(List&lt;T&gt; dataList) {                        userDAO.batchInsert(dataList);                        return true;                    }});</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>public &lt;T&gt; long executeFetch(String tableName, int batchSize, Function&lt;Record, T&gt; dataParser, Function&lt;List&lt;T&gt;, Boolean&gt; dataStorage) throws Exception {    // 构建下载会话    DownloadSession session = buildSession(tableName);    // 获取数据数量    long recordCount = session.getRecordCount();    if (recordCount == 0) {        return 0;    }    // 进行数据读取    long fetchCount = 0L;    try (RecordReader reader = session.openRecordReader(0L, recordCount, true)) {        // 依次读取数据        Record record;        List&lt;T&gt; dataList = new ArrayList&lt;&gt;(batchSize);        while ((record = reader.read()) != null) {            // 解析添加数据            T data = dataParser.apply(record);            if (Objects.nonNull(data)) {                dataList.add(data);            }            // 批量存储数据            if (dataList.size() == batchSize) {                Boolean isContinue = dataStorage.apply(dataList);                fetchCount += batchSize;                dataList.clear();                if (!Boolean.TRUE.equals(isContinue)) {                    break;                }            }        }        // 存储剩余数据        if (CollectionUtils.isNotEmpty(dataList)) {            dataStorage.apply(dataList);            fetchCount += dataList.size();            dataList.clear();        }    }    // 返回获取数量    return fetchCount;} // 使用案例long fetchCount = odpsService.executeFetch("user", 5000, record -&gt; {        UserDO user = new UserDO();        user.setId(record.getBigint("id"));        user.setName(record.getString("name"));        return user;    }, dataList -&gt; {        userDAO.batchInsert(dataList);        return true;    });</code></pre><p><br></p><p>普通的建造者模式，实现时需要定义 DataHandler 接口，调用时需要实现 DataHandler 匿名内部类，代码较多较繁琐。而精简后的建造者模式，充分利用了函数式编程，实现时无需定义接口，直接使用 Function 接口；调用时无需实现匿名内部类，直接采用 lambda 表达式，代码较少较简洁。</p><h3 class=pgc-h-arrow-right><strong>10.3.代理模式</strong></h3><p>Spring 中最重要的代理模式就是 AOP (Aspect-Oriented Programming，面向切面的编程)，是使用 JDK 动态代理和 CGLIB 动态代理技术来实现的。</p><p><strong>普通：</strong></p><pre><code>@Slf4j@RestController@RequestMapping("/user")public class UserController {    /** 用户服务 */    @Autowired    private UserService userService;    /** 查询用户 */    @PostMapping("/queryUser")    public Result&lt;?&gt; queryUser(@RequestBody @Valid UserQueryVO query) {        try {            PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);            return Result.success(pageData);        } catch (Exception e) {            log.error(e.getMessage(), e);            return Result.failure(e.getMessage());        }    }    ...}</code></pre><p><br></p><p><strong>精简1：</strong></p><p><br></p><p>基于 @ControllerAdvice 的异常处理：</p><pre><code>@RestController@RequestMapping("/user")public class UserController {    /** 用户服务 */    @Autowired    private UserService userService;    /** 查询用户 */    @PostMapping("/queryUser")    public Result&lt;PageDataVO&lt;UserVO&gt;&gt; queryUser(@RequestBody @Valid UserQueryVO query) {        PageDataVO&lt;UserVO&gt; pageData = userService.queryUser(query);        return Result.success(pageData);    }    ...}@Slf4j@ControllerAdvicepublic class GlobalControllerAdvice {    /** 处理异常 */    @ResponseBody    @ExceptionHandler(Exception.class)    public Result&lt;Void&gt; handleException(Exception e) {        log.error(e.getMessage(), e);        return Result.failure(e.getMessage());    }}</code></pre><p><br></p><p><strong>精简2：</strong></p><p><br></p><p>基于 AOP 的异常处理：</p><pre><code>// UserController代码同"精简1"@Slf4j@Aspectpublic class WebExceptionAspect {    /** 点切面 */    @Pointcut("@annotation(org.springframework.web.bind.annotation.RequestMapping)")    private void webPointcut() {}    /** 处理异常 */    @AfterThrowing(pointcut = "webPointcut()", throwing = "e")    public void handleException(Exception e) {        Result&lt;Void&gt; result = Result.failure(e.getMessage());        writeContent(JSON.toJSONString(result));    }    ...}</code></pre><p><br></p><h2 class=pgc-h-arrow-right><strong>11.利用删除代码</strong></h2><hr><p>“少即是多”，“少”不是空白而是精简，“多”不是拥挤而是完美。删除多余的代码，才能使代码更精简更完美。</p><h3 class=pgc-h-arrow-right><strong>11.1.删除已废弃的代码</strong></h3><p>删除项目中的已废弃的包、类、字段、方法、变量、常量、导入、注解、注释、已注释代码、Maven包导入、MyBatis的SQL语句、属性配置字段等，可以精简项目代码便于维护。</p><p><strong>普通：</strong></p><pre><code>import lombok.extern.slf4j.Slf4j;@Slf4j@Servicepublic class ProductService {    @Value("discardRate")    private double discardRate;    ...    private ProductVO transProductDO(ProductDO productDO) {        ProductVO productVO = new ProductVO();        BeanUtils.copyProperties(productDO, productVO);        // productVO.setPrice(getDiscardPrice(productDO.getPrice()));        return productVO;    }    private BigDecimal getDiscardPrice(BigDecimal originalPrice) {        ...    }}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>@Servicepublic class ProductService {    ...    private ProductVO transProductDO(ProductDO productDO) {        ProductVO productVO = new ProductVO();        BeanUtils.copyProperties(productDO, productVO);        return productVO;    }}11.2.删除接口方法的public对于接口(interface)，所有的字段和方法都是public的，可以不用显式声明为public。普通：public interface UserDAO {    public Long countUser(@Param("query") UserQuery query);    public List&lt;UserDO&gt; queryUser(@Param("query") UserQuery query);}</code></pre><pre><code></code></pre><h3 class=pgc-h-arrow-right><strong>11.2.删除接口方法的public</strong></h3><p>对于接口(interface)，所有的字段和方法都是 public 的，可以不用显式声明为 public 。</p><p><strong>普通：</strong></p><pre><code>public interface UserDAO {    public Long countUser(@Param("query") UserQuery query);    public List&lt;UserDO&gt; queryUser(@Param("query") UserQuery query);}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>public interface UserDAO {    Long countUser(@Param("query") UserQuery query);    List&lt;UserDO&gt; queryUser(@Param("query") UserQuery query);}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.3.删除枚举构造方法的 private</strong></h3><p>对于枚举(menu)，构造方法都是 private 的，可以不用显式声明为 private 。</p><p><strong>普通：</strong></p><pre><code>public enum UserStatus {    DISABLED(0, "禁用"),    ENABLED(1, "启用");  private final Integer value;    private final String desc;    private UserStatus(Integer value, String desc) {        this.value = value;        this.desc = desc;    }    ...}</code></pre><p><strong>精简：</strong></p><pre><code>public enum UserStatus {    DISABLED(0, "禁用"),    ENABLED(1, "启用");    private final Integer value;    private final String desc;    UserStatus(Integer value, String desc) {        this.value = value;        this.desc = desc;    }    ...}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.4.删除 final 类方法的 final</strong></h3><p>对于 final 类，不能被子类继承，所以其方法不会被覆盖，没有必要添加 final 修饰。</p><p><strong>普通：</strong></p><pre><code>public final Rectangle implements Shape {    ...    @Override    public final double getArea() {        return width * height;    }}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>public final Rectangle implements Shape {    ...    @Override    public double getArea() {        return width * height;    }}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.5.删除基类 implements 的接口</strong></h3><p>如果基类已 implements 某接口，子类没有必要再 implements 该接口，只需要直接实现接口方法即可。</p><p><br></p><p><strong>普通：</strong></p><pre><code>public interface Shape {    ...    double getArea();}public abstract AbstractShape implements Shape {    ...}public final Rectangle extends AbstractShape implements Shape {    ...    @Override    public double getArea() {        return width * height;    }}</code></pre><p><strong>精简：</strong></p><pre><code>...public final Rectangle extends AbstractShape {    ...    @Override    public double getArea() {        return width * height;    }}</code></pre><h3 class=pgc-h-arrow-right><br></h3><h3 class=pgc-h-arrow-right><strong>11.6.删除不必要的变量</strong></h3><p>不必要的变量，只会让代码看起来更繁琐。</p><p><strong>普通：</strong></p><pre><code>public Boolean existsUser(Long userId) {    Boolean exists = userDAO.exists(userId);    return exists;}</code></pre><p><br></p><p><strong>精简：</strong></p><pre><code>public Boolean existsUser(Long userId) {    return userDAO.exists(userId);}</code></pre><h2 class=pgc-h-arrow-right><strong>后记</strong></h2><hr><p><br></p><p>古语又云：</p><blockquote><p>有道无术，术尚可求也；有术无道，止于术。</p></blockquote><p>意思是：有“道”而无“术”，“术”还可以逐渐获得；有“术”而无“道”，就可能止步于“术”了。所以，我们不要仅满足于从实践中总结“术”，因为“道”的表现形式是多变的；而应该上升到“道”的高度，因为“术”背后的道理是相通的。当遇到新的事物时，我们可以从理论中找到“道”、从实践中找出“术”，尝试着去认知新的事物。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'示例','至简','Java'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>