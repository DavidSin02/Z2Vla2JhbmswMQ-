<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构图文解析之：栈的简介及C++模板实现 | 极客快訊</title><meta property="og:title" content="数据结构图文解析之：栈的简介及C++模板实现 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c6d71c38d6d2464f972c8ec5e8f995f1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91c0357.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91c0357.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91c0357.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91c0357.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91c0357.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91c0357.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/91c0357.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/91c0357.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="数据结构图文解析之：栈的简介及C++模板实现"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/91c0357.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构图文解析之：栈的简介及C++模板实现</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>阅读目录</strong></p><ul><li>0. 数据结构图文解析系列</li><li>1. 栈的简介</li><li class=ql-indent-1>1.1栈的特点</li><li class=ql-indent-1>1.2栈的相关概念</li><li class=ql-indent-1>1.3 栈的操作</li><li class=ql-indent-1>1.4 栈的存储结构</li><li>2. 基于数组的栈实现</li><li class=ql-indent-1>2.1 栈的抽象数据类型</li><li class=ql-indent-1>2.2 栈的具体实现</li><li class=ql-indent-1>2.3 栈的代码测试</li><li>3. 基於单链表的栈</li><li class=ql-indent-1>3.1 链表节点</li><li class=ql-indent-1>3.2 栈的抽象数据类型</li><li class=ql-indent-1>3.3 栈的具体实现</li><li class=ql-indent-1>3.4 栈的代码测试</li><li>4. 栈的完整代码</li></ul><p><strong>正文</strong></p><p class=ql-align-right>回到顶部</p><h1><strong>0. 数据结构图文解析系列</strong></h1><p>数据结构系列文章数据结构图文解析之：数组、单链表、双链表介绍及C++模板实现数据结构图文解析之：栈的简介及C++模板实现数据结构图文解析之：队列详解与C++模板实现数据结构图文解析之：树的简介及二叉排序树C++模板实现.数据结构图文解析之：AVL树详解及C++模板实现数据结构图文解析之：二叉堆详解及C++模板实现数据结构图文解析之：哈夫曼树与哈夫曼编码详解及C++模板实现</p><p class=ql-align-right>回到顶部</p><h1><strong>1. 栈的简介</strong></h1><p><strong>1.1栈的特点</strong></p><p>栈(Stack)是一种线性存储结构，它具有如下特点：</p><ol><li>栈中的数据元素遵守”先进后出"(First In Last Out)的原则，简称FILO结构。</li><li>限定只能在栈顶进行插入和删除操作。</li></ol><p><strong>1.2栈的相关概念</strong></p><p>栈的相关概念：</p><ol><li>栈顶与栈底：允许元素插入与删除的一端称为栈顶，另一端称为栈底。</li><li>压栈：栈的插入操作，叫做进栈，也称压栈、入栈。</li><li>弹栈：栈的删除操作，也叫做出栈。</li></ol><p>例如我们有一个存储整型元素的栈，我们依次压栈：{1,2,3}</p><div class=pgc-img><img alt=数据结构图文解析之：栈的简介及C++模板实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6d71c38d6d2464f972c8ec5e8f995f1><p class=pgc-img-caption></p></div><p>在压栈的过程中，栈顶的位置一直在”向上“移动，而栈底是固定不变的。</p><p>如果我们要把栈中的元素弹出来：</p><div class=pgc-img><img alt=数据结构图文解析之：栈的简介及C++模板实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/260de65f01f949dea111cbef7e5ecc3f><p class=pgc-img-caption></p></div><p>出栈的顺序为3、2、1 ，顺序与入栈时相反，这就是所谓的”先入后出“。</p><p>在弹栈的过程中，栈顶位置一直在”向下“移动，而栈底一直保持不变。</p><p>如果你玩过一种称为汉诺塔的益智玩具，你就会知道游戏中小圆盘的存取就是一种先进后出的顺序，一个圆柱就是一个栈：</p><div class=pgc-img><img alt=数据结构图文解析之：栈的简介及C++模板实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e536a0f0f0d4708b2d8e8879d4c91ba><p class=pgc-img-caption></p></div><p><strong>1.3 栈的操作</strong></p><p>栈的常用操作为：</p><ol><li>弹栈，通常命名为pop</li><li>压栈，通常命名为push</li><li>求栈的大小</li><li>判断栈是否为空</li><li>获取栈顶元素的值</li></ol><p><strong>1.4 栈的存储结构</strong></p><p>栈既然是一种线性结构，就能够以数组或链表（单向链表、双向链表或循环链表）作为底层数据结构。</p><p>本文我们以数组、单向链表为底层数据结构构建栈。</p><p class=ql-align-right>回到顶部</p><h1><strong>2. 基于数组的栈实现</strong></h1><p>当以数组为底层数据结构时，通常以数组头为栈底，数组头到数组尾为栈顶的生长方向：</p><div class=pgc-img><img alt=数据结构图文解析之：栈的简介及C++模板实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6016823698554346b5420f360c3f3233><p class=pgc-img-caption></p></div><p><strong>2.1 栈的抽象数据类型</strong></p><p>栈提供了如上所述操作的相应接口。</p><pre>template&lt;typename T&gt;class ArrayStack{public: ArrayStack(int s = 10); //默认的栈容量为10 ~ArrayStack(); public: T top(); //获取栈顶元素 void push(T t); //压栈操作 T pop(); //弹栈操作 bool isEmpty(); //判空操作 int size(); //求栈的大小 private: int count; //栈的元素数量 int capacity; //栈的容量 T * array; //底层为数组};</pre><ol><li>count 为栈的元素数量，capacity为栈的容量，count&lt;=capacity，当栈满的时候，count = capacity。</li><li>本实现中不支持栈的动态扩容，栈满的时候无法再插入元素。栈的容量在定义栈的时候就需要指定，默认的栈容量为10。</li></ol><p><strong>2.2 栈的具体实现</strong></p><p>栈的实现还是相对简单的，很容易理解。这里就不再画蛇添足了。</p><pre> /*栈的判空操作*/template &lt;typename T&gt;bool ArrayStack&lt;T&gt;::isEmpty(){ return count == 0; //栈元素为0时为栈空}; /*返回栈的大小*/ template &lt;typename T&gt;int ArrayStack&lt;T&gt;::size(){ return count;}; /*插入元素*/template &lt;typename T&gt;void ArrayStack&lt;T&gt;::push(T t){ if (count != capacity) //先判断是否栈满 { array[count++] = t;  }}; /*弹栈*/template &lt;typename T&gt;T ArrayStack&lt;T&gt;::pop(){ if (count != 0) //先判断是否是空栈 { return array[--count]; }}; /*获取栈顶元素*/template &lt;typename T&gt;T ArrayStack&lt;T&gt;::top(){ if (count != 0) { return array[count - 1]; }}; </pre><p><strong>2.3 栈的代码测试</strong></p><pre>int _tmain(int argc, _TCHAR* argv[]){ ArrayStack &lt;int&gt; p(5); for (int i = 0; i &lt; 5; i++) { p.push(i); } cout &lt;&lt; "栈的大小:"&lt;&lt;p.size() &lt;&lt; endl; cout &lt;&lt; "栈是否为空:"&lt;&lt;p.isEmpty() &lt;&lt; endl; cout &lt;&lt; "栈顶元素："&lt;&lt;p.top() &lt;&lt; endl; cout &lt;&lt; "依次出栈:" &lt;&lt; endl; while (!p.isEmpty()) { cout &lt;&lt; p.pop() &lt;&lt; endl; } getchar(); return 0;}</pre><p>测试结果：</p><pre>栈的大小:5栈是否为空:0栈顶元素：4依次出栈:43210</pre><p class=ql-align-right>回到顶部</p><h1><strong>3. 基於单链表的栈</strong></h1><p>以链表为底层的数据结构时，以链表头为作为栈顶较为合适，这样方便节点的插入与删除。压栈产生的新节点将一直出现在链表的头部；</p><div class=pgc-img><img alt=数据结构图文解析之：栈的简介及C++模板实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92228037e2b94b4883ff11998a803c2b><p class=pgc-img-caption></p></div><p><strong>3.1 链表节点</strong></p><pre>/*链表节点结构*/template &lt;typename T&gt;struct Node{ Node(T t) :value(t), next(nullptr){}; Node() :next(nullptr){}; public: T value; Node&lt;T&gt;* next;};</pre><ol><li>value:栈中元素的值</li><li>next:链表节点指针，指向直接后继</li></ol><p><strong>3.2 栈的抽象数据类型</strong></p><p>基于链表的栈提供的接口与基于数组的栈一致。</p><pre> /*栈的抽象数据结构*/template &lt;typename T&gt;class LinkStack{public: LinkStack(); ~LinkStack();public:  bool isEmpty(); int size(); void push(T t); T pop(); T top(); private:  Node&lt;T&gt;* phead; int count;};</pre><p><strong>3.3 栈的具体实现</strong></p><pre>/*返回栈的大小*/template &lt;typename T&gt;int LinkStack&lt;T&gt;::size(){ return count;};/*栈的判空操作*/template &lt;typename T&gt;bool LinkStack&lt;T&gt;::isEmpty(){ return count == 0;};/*插入元素*/template&lt;typename T&gt;void LinkStack&lt;T&gt;::push(T t){ Node &lt;T&gt; *pnode = new Node&lt;T&gt;(t); pnode-&gt;next = phead-&gt;next; phead-&gt;next = pnode; count++;};/*弹栈*/template &lt;typename T&gt;T LinkStack&lt;T&gt;::pop(){ if (phead-&gt;next != nullptr) //栈空判断 { Node&lt;T&gt;* pdel = phead-&gt;next; phead-&gt;next = phead-&gt;next-&gt;next; T value = pdel-&gt;value; delete pdel; count--; return value; }};/*获取栈顶元素*/template &lt;typename T&gt;T LinkStack&lt;T&gt;::top(){ if (phead-&gt;next!=nullptr) return phead-&gt;next-&gt;value;};</pre><p><strong>3.4 栈的代码测试</strong></p><pre>int _tmain(int argc, _TCHAR* argv[]){ LinkStack &lt;string&gt; lstack; lstack.push("hello"); lstack.push("to"); lstack.push("you！");  cout &lt;&lt; "栈的大小:" &lt;&lt; lstack.size() &lt;&lt; endl; cout &lt;&lt;"栈顶元素:"&lt;&lt; lstack.top() &lt;&lt; endl;  while (!lstack.isEmpty()) { lstack.pop(); }  cout &lt;&lt; "栈的大小:" &lt;&lt; lstack.size() &lt;&lt; endl;  getchar(); return 0;}</pre><p>测试结果：</p><pre>栈的大小:3栈顶元素:you！栈的大小:0</pre><p class=ql-align-right>回到顶部</p><h1><strong>4. 栈的完整代码</strong></h1><p>基于数组的栈： https://github.com/huanzheWu/Data-Structure/blob/master/Stack/Main/Main/ArrayStack.h</p><p>基於单链表的栈：https://github.com/huanzheWu/Data-Structure/blob/master/singleList/singleList/singleList.h</p><p>原创文章，转载请注明出处：http://www.cnblogs.com/QG-whz/p/5170418.html</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','图文'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>