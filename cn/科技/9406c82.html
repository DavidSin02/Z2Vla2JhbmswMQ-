<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库 | 极客快訊</title><meta property="og:title" content="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5041331ab95f4d369c4d1e3b1bb751a1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9406c82.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9406c82.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9406c82.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9406c82.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9406c82.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9406c82.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9406c82.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9406c82.html><meta property="article:published_time" content="2020-10-29T20:52:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:48+08:00"><meta name=Keywords content><meta name=description content="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9406c82.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>什么是 SOFAJRaft？</h1><p>SOFAJRaft 是一个基于 <strong>Raft</strong> 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。 使用 SOFAJRaft 你可以专注于自己的业务领域，由 SOFAJRaft 负责处理所有与 Raft 相关的技术难题，并且 SOFAJRaft 非常易于使用，你可以通过几个示例在很短的时间内掌握它。</p><p>https://raft.github.io</p><p>SOFAJRaft 是从百度的 <strong>braft</strong> 移植而来，做了一些优化和改进，感谢百度 braft 团队开源了如此优秀的 C++ Raft 实现。</p><p>https://github.com/brpc/braft</p><h1>基础知识：分布式共识算法 (Consensus Algorithm)</h1><p>如何理解分布式共识?</p><ul><li><strong>多个参与者</strong>某一件事<strong>一致</strong> ：一件事，一个结论</li><li>已达成一致的结论，不可推翻</li></ul><p>有哪些分布式共识算法?</p><ul><li>Paxos：被认为是分布式共识算法的根本，其他都是其变种，但是 Paxos 论文中只给出了单个提案的过程，并没有给出复制状态机中需要的 multi-paxos 的相关细节的描述，实现 Paxos 具有很高的工程复杂度（如多点可写，允许日志空洞等）。</li><li>Zab：被应用在 Zookeeper 中，业界使用广泛，但没有抽象成通用的 library。</li><li>Raft：以容易理解著称，业界也涌现出很多 Raft 实现，比如大名鼎鼎的 etcd, braft, tikv 等。</li></ul><h1>什么是 Raft？</h1><p><strong>Raft</strong> 是一种更易于理解的分布式共识算法，核心协议本质上还是师承 Paxos 的精髓，不同的是依靠 Raft 模块化的拆分以及更加简化的设计，Raft 协议相对更容易实现。</p><p>https://raft.github.io/</p><p>模块化的拆分主要体现在：Raft 把一致性协议划分为 Leader 选举、MemberShip 变更、日志复制、Snapshot 等几个几乎完全解耦的模块。</p><p>更加简化的设计则体现在：Raft 不允许类似 Paxos 中的乱序提交、简化系统中的角色状态（只有 Leader、Follower、Candidate 三种角色）、限制仅 Leader 可写入、使用随机化的超时时间来设计 Leader Election 等等。</p><p>特点：Strong Leader</p><ol><li>系统中必须存在且同一时刻只能有一个 Leader，只有 Leader 可以接受 Clients 发过来的请求；</li><li>Leader 负责主动与所有 Followers 通信，负责将“提案”发送给所有 Followers，同时收集多数派的 Followers 应答；</li><li>Leader 还需向所有 Followers 主动发送心跳维持领导地位(保持存在感)。</li></ol><p>一句话总结 Strong Leader: <strong>"你们不要 BB! 按我说的做，做完了向我汇报!"</strong>。</p><p>另外，身为 Leader 必须保持一直 BB(heartbeat) 的状态，否则就会有别人跳出来想要 BB 。</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5041331ab95f4d369c4d1e3b1bb751a1><p class=pgc-img-caption></p></div><p><strong>Raft 中的基本概念</strong></p><p>篇幅有限，这里只对 Raft 中的几个概念做一个简单介绍，详细请参考 <strong>Raft paper。</strong></p><p>https://raft.github.io/raft.pdf</p><p><strong>Raft-node 的 3 种角色/状态</strong></p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e3d038ea5a1648b39d8c1811c7c4002d><p class=pgc-img-caption></p></div><ol><li>Follower：完全被动，不能发送任何请求，只接受并响应来自 Leader 和 Candidate 的 Message，每个节点启动后的初始状态一定是 Follower；</li><li>Leader：处理所有来自客户端的请求，以及复制 Log 到所有 Followers；</li><li>Candidate：用来竞选一个新 Leader （Candidate 由 Follower 触发超时而来）。</li></ol><p><strong>Message 的 3 种类型</strong></p><ol><li>RequestVote RPC：由 Candidate 发出，用于发送投票请求；</li><li>AppendEntries (Heartbeat) RPC：由 Leader 发出，用于 Leader 向 Followers 复制日志条目，也会用作 Heartbeat （日志条目为空即为 Heartbeat）；</li><li>InstallSnapshot RPC：由 Leader 发出，用于快照传输，虽然多数情况都是每个服务器独立创建快照，但是Leader 有时候必须发送快照给一些落后太多的 Follower，这通常发生在 Leader 已经丢弃了下一条要发给该Follower 的日志条目(Log Compaction 时清除掉了) 的情况下。</li></ol><p><strong>任期逻辑时钟</strong></p><ol><li>时间被划分为一个个任期 (term)，term id 按时间轴单调递增；</li><li>每一个任期的开始都是 Leader 选举，选举成功之后，Leader 在任期内管理整个集群，也就是 <strong>“选举 + 常规操作”</strong>；</li><li>每个任期最多一个 Leader，可能没有 Leader (spilt-vote 导致)。</li></ol><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/beb7bb513e9e4e5fa399263c7d1156ce><p class=pgc-img-caption></p></div><p>本图出自《Raft: A Consensus Algorithm for Replicated Logs》</p><h1>什么是 SOFAJRaft？</h1><p>SOFAJRaft 是一个基于 Raft 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。 使用 SOFAJRaft 你可以专注于自己的业务领域，由 SOFAJRaft 负责处理所有与 <strong>Raft</strong> 相关的技术难题，并且 SOFAJRaft 非常易于使用，你可以通过几个示例在很短的时间内掌握它。</p><p>https://github.com/brpc/braft</p><p>SOFAJRaft 是从百度的 braft 移植而来，做了一些优化和改进，感谢百度 braft 团队开源了如此优秀的 C++ Raft 实现。</p><h1>SOFAJRaft 整体功能&性能优化</h1><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dcf26d05bf244b6d8b5ff32090209803><p class=pgc-img-caption></p></div><p>功能支持</p><p>1.Leader election：Leader 选举，这个不多说，上面已介绍过 Raft 中的 Leader 机制。</p><p>2.Log replication and recovery：日志复制和日志恢复。</p><ol><li>Log replication 就是要保证已经被 commit 的数据一定不会丢失，即一定要成功复制到多数派。</li><li>Log recovery 包含两个方面：</li><li class=ql-indent-1>Current term 日志恢复：主要针对一些 Follower 节点重启加入集群或者是新增 Follower 节点后如何追日志；</li><li class=ql-indent-1>Prev term 日志恢复：主要针对 Leader 切换前后的日志一致性。</li></ol><p>3.Snapshot and log compaction：定时生成 snapshot，实现 log compaction 加速启动和恢复，以及 InstallSnapshot 给 Followers 拷贝数据，如下图：</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8ad3c54d6804cb0a87ed6acc99270aa><p class=pgc-img-caption></p></div><p>本图出自《In Search of an Understandable Consensus Algorithm》</p><p>4.Membership change：用于集群线上配置变更，比如增加节点、删除节点、替换节点等。</p><p>5.Transfer leader：主动变更 leader，用于重启维护，leader 负载平衡等。</p><p>6.Symmetric network partition tolerance：对称网络分区容忍性。</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fc4a25e6ad3347c28cf391c1ed911f73><p class=pgc-img-caption></p></div><p>如上图 S1 为当前 leader，网络分区造成 S2 不断增加本地 term，为了避免网络恢复后 S2 发起选举导致正在良心 工作的 leader step-down，从而导致整个集群重新发起选举，SOFAJRaft 中增加了 pre-vote 来避免这个问题的发生。</p><ol><li>SOFAJRaft 中在 request-vote 之前会先进行 pre-vote(currentTerm + 1, lastLogIndex, lastLogTerm)，多数派成功后才会转换状态为 candidate 发起真正的 request-vote，所以分区后的节点，pre-vote 不会成功，也就不会导致集群一段时间内无法正常提供服务。</li></ol><p>7.Asymmetric network partition tolerance：非对称网络分区容忍性。</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eefd277984094cc98b250645588ab737><p class=pgc-img-caption></p></div><p>如上图 S1 为当前 leader，S2 不断超时触发选主，S3 提升 term 打断当前 lease，从而拒绝 leader 的更新。</p><ol><li>在 SOFAJRaft 中增加了一个 tick 的检查，每个 follower 维护一个时间戳记录下收到 leader 上数据更新的时间(也包括心跳)，只有超过 election timeout 之后才允许接受 request-vote 请求。</li></ol><p>8.Fault tolerance：容错性，少数派故障不影响系统整体可用性，包括但不限于：</p><ol><li>机器掉电</li><li>强杀应用</li><li>慢节点(GC, OOM 等)</li><li>网络故障</li><li>其他各种奇葩原因导致 raft 节点无法正常工作</li></ol><p>9.Workaround when quorate peers are dead：多数派故障时，整个 grop 已不具备可用性，安全的做法是等待多数节点恢复，只有这样才能保证数据安全；但是如果业务更加追求系统可用性，可以放弃数据一致性的话，SOFAJRaft 提供了手动触发 reset_peers 的指令以迅速重建整个集群，恢复集群可用。</p><p>10.Metrics：SOFAJRaft 内置了基于 Metrics 类库的性能指标统计，具有丰富的性能统计指标，利用这些指标数据可以帮助用户更容易找出系统性能瓶颈。</p><p>11.Jepsen：除了几百个单元测试以及部分 chaos 测试之外, SOFAJRaft 还使用 jepsen 这个分布式验证和故障注入测试框架模拟了很多种情况，都已验证通过：</p><ol><li>随机分区，一大一小两个网络分区</li><li>随机增加和移除节点</li><li>随机停止和启动节点</li><li>随机 kill -9 和启动节点</li><li>随机划分为两组，互通一个中间节点，模拟分区情况</li><li>随机划分为不同的 majority 分组</li></ol><p>性能优化</p><p>除了功能上的完整性，SOFAJRaft 还做了很多性能方面的优化，这里有一份 KV 场景（get/put）的 Benchmark 数据, 在小数据包，读写比例为 9:1，保证线性一致读的场景下，三副本最高可以达到 40w+ 的 ops。</p><p>这里挑重点介绍几个优化点：</p><ol><li>Batch： 我们知道互联网两大优化法宝便是 Cache 和 Batch，SOFAJRaft 在 Batch 上花了较大心思，整个链路几乎都是 Batch 的，依靠 disruptor 的 MPSC 模型批量消费，对整体性能有着极大的提升，包括但不限于：</li><li class=ql-indent-1>批量提交 task</li><li class=ql-indent-1>批量网络发送</li><li>本地 IO batch 写入</li><li class=ql-indent-1>要保证日志不丢，一般每条 log entry 都要进行 fsync 同步刷盘，比较耗时，SOFAJRaft 中做了合并写入的优化。</li><li class=ql-indent-1>批量应用到状态机</li><li class=ql-indent-1>需要说明的是，虽然 SOFAJRaft 中大量使用了 Batch 技巧，但对单个请求的延时并无任何影响，SOFAJRaft 中不会对请求做延时的攒批处理。</li><li>Replication pipeline：流水线复制，通常 Leader 跟 Followers 节点的 Log 同步是串行 Batch 的方式，每个 Batch 发送之后需要等待 Batch 同步完成之后才能继续发送下一批(ping-pong)，这样会导致较长的延迟。SOFAJRaft 中通过 Leader 跟 Followers 节点之间的 pipeline 复制来改进，非常有效降低了数据同步的延迟, 提高吞吐。经我们测试，开启 pipeline 可以将吞吐提升 30% 以上，详细数据请参照 Benchmark。</li><li>Append log in parallel：在 SOFAJRaft 中 Leader 持久化 log entries 和向 Followers 发送 log entries 是并行的。</li><li>Fully concurrent replication：Leader 向所有 Follwers 发送 Log 也是完全相互独立和并发的。</li><li>Asynchronous：SOFAJRaft 中整个链路几乎没有任何阻塞，完全异步的，是一个完全的 callback 编程模型。</li><li>ReadIndex：优化 Raft read 走 Raft log 的性能问题，每次 read，仅记录 commitIndex，然后发送所有 peers heartbeat 来确认 Leader 身份，如果 Leader 身份确认成功，等到 appliedIndex >= commitIndex，就可以返回 Client read 了，基于 ReadIndex Follower 也可以很方便的提供线性一致读，不过 commitIndex 是需要从 Leader 那里获取，多了一轮 RPC；关于线性一致读文章后面会详细分析。</li><li>Lease Read：SOFAJRaft 还支持通过租约 (lease) 保证 Leader 的身份，从而省去了 ReadIndex 每次 heartbeat 确认 Leader 身份，性能更好，但是通过时钟维护 lease 本身并不是绝对的安全（时钟漂移问题，所以 SOFAJRaft 中默认配置是 ReadIndex，因为通常情况下 ReadIndex 性能已足够好。</li></ol><p>SOFAJRaft 设计</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2ca838ef502e44338a79c626aefd5448><p class=pgc-img-caption></p></div><ol><li>Node：Raft 分组中的一个节点，连接封装底层的所有服务，用户看到的主要服务接口，特别是 apply(task)用于向 raft group 组成的复制状态机集群提交新任务应用到业务状态机。</li><li>存储：上图靠下的部分均为存储相关。</li><li>Log 存储，记录 Raft 用户提交任务的日志，将日志从 Leader 复制到其他节点上。</li><li class=ql-indent-2>LogStorage 是存储实现，默认实现基于 RocksDB 存储，你也可以很容易扩展自己的日志存储实现；</li><li class=ql-indent-1>LogManager 负责对底层存储的调用，对调用做缓存、批量提交、必要的检查和优化。</li><li class=ql-indent-1>Metadata 存储，元信息存储，记录 Raft 实现的内部状态，比如当前 term、投票给哪个节点等信息。</li><li>Snapshot 存储，用于存放用户的状态机 snapshot 及元信息，可选：</li><li class=ql-indent-2>SnapshotStorage 用于 snapshot 存储实现；</li><li class=ql-indent-1>SnapshotExecutor 用于 snapshot 实际存储、远程安装、复制的管理。</li><li>状态机</li><li class=ql-indent-1>StateMachine：用户核心逻辑的实现，核心是 onApply(Iterator) 方法, 应用通过 Node#apply(task) 提交的日志到业务状态机；</li><li class=ql-indent-1>FSMCaller:封装对业务 StateMachine 的状态转换的调用以及日志的写入等,一个有限状态机的实现,做必要的检查、请求合并提交和并发处理等。</li><li>复制</li><li class=ql-indent-1>Replicator：用于 Leader 向 Followers 复制日志，也就是 Raft 中的 AppendEntries 调用，包括心跳存活检查等；</li><li class=ql-indent-1>ReplicatorGroup：用於单个 Raft group 管理所有的 replicator，必要的权限检查和派发。</li><li>RPC：RPC 模块用于节点之间的网络通讯</li><li class=ql-indent-1>RPC Server：内置于 Node 内的 RPC 服务器，接收其他节点或者客户端发过来的请求，转交给对应服务处理；</li><li class=ql-indent-1>RPC Client：用于向其他节点发起请求，例如投票、复制日志、心跳等。</li><li>KV Store：KV Store 是各种 Raft 实现的一个典型应用场景，SOFAJRaft 中包含了一个嵌入式的分布式 KV 存储实现（SOFAJRaft-RheaKV）。</li></ol><p>SOFAJRaft Group</p><p>单个节点的 SOFAJRaft-node 是没什么实际意义的，下面是三副本的 SOFAJRaft 架构图：</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bfe21b37a8804183a0405cb905af7dec><p class=pgc-img-caption></p></div><h1>SOFAJRaft Multi Group</h1><p>单个 Raft group 是无法解决大流量的读写瓶颈的，SOFAJRaft 自然也要支持 multi-raft-group。</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3ec5d3cc95ad4b139d1e1f4ad19da129><p class=pgc-img-caption></p></div><h1>SOFAJRaft 实现细节解析之高效的线性一致读</h1><p>什么是线性一致读? 所谓线性一致读，一个简单的例子就是在 t1 的时刻我们写入了一个值，那么在 t1 之后，我们一定能读到这个值，不可能读到 t1 之前的旧值 (想想 Java 中的 volatile 关键字，说白了线性一致读就是在分布式系统中实现 Java volatile 语义)。</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92ed8cb3346b4a499b0e48b7ce9b33db><p class=pgc-img-caption></p></div><p>如上图 Client A、B、C、D 均符合线性一致读，其中 D 看起来是 stale read，其实并不是，D 请求横跨了 3 个阶段，而读可能发生在任意时刻，所以读到 1 或 2 都行。</p><p><strong>重要：接下来的讨论均基于一个大前提，就是业务状态机的实现必须是满足线性一致性的，简单说就是也要具有 Java volatile 的语义</strong>。</p><ol><li>要实现线性一致读，首先我们简单直接一些，是否可以直接从当前 Leader 节点读?</li><li class=ql-indent-1>仔细一想，这显然行不通，因为你无法确定这一刻当前的 "Leader" 真的是 Leader，比如在网络分区的情况下，它可能已经被推翻王朝却不自知。</li><li>最简单易懂的实现方式：同 “写” 请求一样，“读” 请求也走一遍 Raft 协议 (Raft Log)。</li></ol><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/98de9560ec1b4a4cb8d1754ab508ae04><p class=pgc-img-caption></p></div><p>本图出自《Raft: A Consensus Algorithm for Replicated Logs》</p><p>这一定是可以的，但性能上显然不会太出色，走 Raft Log 不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 Raft “读日志” 造成的磁盘占用开销，这在读比重很大的系统中通常是无法被接受的。</p><ol><li>ReadIndex Read</li><li>这是 Raft 论文中提到的一种优化方案，具体来说：</li><li class=ql-indent-2>Leader 将自己当前 Log 的 commitIndex 记录到一个 Local 变量 ReadIndex 里面；</li><li class=ql-indent-2>接着向 Followers 发起一轮 heartbeat，如果半数以上节点返回了对应的 heartbeat response，那么 Leader 就能够确定现在自己仍然是 Leader (证明了自己是自己)；</li><li class=ql-indent-2>Leader 等待自己的状态机执行，直到 applyIndex 超过了 ReadIndex，这样就能够安全的提供 Linearizable Read 了，也不必管读的时刻是否 Leader 已飘走 (思考：为什么等到 applyIndex 超过了 ReadIndex 就可以执行读请求?)；</li><li class=ql-indent-1>Leader 执行 read 请求，将结果返回给 Client。</li><li>通过ReadIndex，也可以很容易在 Followers 节点上提供线性一致读：</li><li class=ql-indent-2>Follower 节点向 Leader 请求最新的 ReadIndex；</li><li class=ql-indent-2>Leader 执行上面前 3 步的过程(确定自己真的是 Leader)，并返回 ReadIndex 给 Follower；</li><li class=ql-indent-2>Follower 等待自己的 applyIndex 超过了 ReadIndex；</li><li class=ql-indent-1>Follower 执行 read 请求，将结果返回给 Client。（SOFAJRaft 中可配置是否从 Follower 读取，默认不打开）</li><li>ReadIndex小结：</li><li class=ql-indent-2>相比较于走 Raft Log 的方式，ReadIndex 省去了磁盘的开销，能大幅度提升吞吐，结合 SOFAJRaft 的 batch + pipeline ack + 全异步机制，三副本的情况下 Leader 读的吞吐可以接近于 RPC 的吞吐上限；</li><li class=ql-indent-1>延迟取决于多数派中最慢的一个 heartbeat response，理论上对于降低延时的效果不会非常显著。</li><li>Lease Read</li><li class=ql-indent-1>Lease Read 与 ReadIndex 类似，但更进一步，不仅省去了 Log，还省去了网络交互。它可以大幅提升读的吞吐也能显著降低延时。</li><li class=ql-indent-1>基本的思路是 Leader 取一个比 election timeout 小的租期(最好小一个数量级)，在租约期内不会发生选举，这就确保了 Leader 不会变，所以可以跳过 ReadIndex 的第二步，也就降低了延时。可以看到 Lease Read 的正确性和时间是挂钩的，因此时间的实现至关重要，如果时钟漂移严重，这套机制就会有问题。</li><li>实现方式：</li><li class=ql-indent-2>定时 heartbeat 获得多数派响应，确认 Leader 的有效性 (在 SOFAJRaft 中默认的 heartbeat 间隔是 election timeout 的十分之一)；</li><li class=ql-indent-2>在租约有效时间内，可以认为当前 Leader 是 Raft Group 内的唯一有效 Leader，可忽略 ReadIndex 中的 heartbeat 确认步骤(2)；</li><li class=ql-indent-1>Leader 等待自己的状态机执行，直到 applyIndex 超过了 ReadIndex，这样就能够安全的提供 Linearizable Read 了 。</li></ol><p>在 SOFAJRaft 中发起一次线性一致读请求的代码展示：</p><pre>// KV 存储实现线性一致读public void readFromQuorum(String key, AsyncContext asyncContext) { // 请求 ID 作为请求上下文传入 byte[] reqContext = new byte[4]; Bits.putInt(reqContext, 0, requestId.incrementAndGet()); // 调用 readIndex 方法, 等待回调执行 this.node.readIndex(reqContext, new ReadIndexClosure() { @Override public void run(Status status, long index, byte[] reqCtx) { if (status.isOk()) { try { // ReadIndexClosure 回调成功，可以从状态机读取最新数据返回 // 如果你的状态实现有版本概念，可以根据传入的日志 index 编号做读取 asyncContext.sendResponse(new ValueCommand(fsm.getValue(key))); } catch (KeyNotFoundException e) { asyncContext.sendResponse(GetCommandProcessor.createKeyNotFoundResponse()); } } else { // 特定情况下，比如发生选举，该读请求将失败 asyncContext.sendResponse(new BooleanCommand(false, status.getErrorMsg())); } } });}</pre><h1>应用场景</h1><ol><li>Leader 选举；</li><li>分布式锁服务，比如 Zookeeper，在 SOFAJRaft 中的 RheaKV 模块提供了完整的分布式锁实现；</li><li>高可靠的元信息管理，可直接基于 SOFAJRaft-RheaKV 存储；</li><li>分布式存储系统，如分布式消息队列、分布式文件系统、分布式块系统等等。</li></ol><p><strong>使用案例</strong></p><ol><li>RheaKV：基于 SOFAJRaft 实现的嵌入式、分布式、高可用、强一致的 KV 存储类库。</li><li>AntQ Streams QCoordinator：使用 SOFAJRaft 在 Coordinator 集群内做选举、使用 SOFAJRaft-RheaKV 做元信息存储等功能。</li><li>Schema Registry：高可靠 schema 管理服务，类似 kafka schema registry，存储部分基于 SOFAJRaft-RheaKV。</li><li>SOFA 服务注册中心元信息管理模块：IP 数据信息注册，要求写数据达到各个节点一致，并且在少数派节点挂掉时保证不影响数据正常存储。</li></ol><p><strong>实践</strong></p><p>一、基于 SOFAJRaft 设计一个简单的 KV Store</p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/953a397fe4024db4b91aea6b9cd22f50><p class=pgc-img-caption></p></div><p><strong>二、基于 SOFAJRaft 的 RheaKV 的设计</strong></p><div class=pgc-img><img alt="蚂蚁金服开源 SOFAJRaft：生产级 Java Raft 算法库" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d0c145c3176e4c6a87cc56fb2a5afa19><p class=pgc-img-caption></p></div><p>功能名词</p><p><strong>PD</strong></p><ul><li>全局的中心总控节点，负责整个集群的调度，不需要自管理的集群可不启用 PD (一个 PD 可管理多个集群，基于 clusterId 隔离)。</li></ul><p><strong>Store</strong></p><ul><li>集群中的一个物理存储节点，一个 Store 包含一个或多个 Region。</li></ul><p><strong>Region</strong></p><ul><li>最小的 KV 数据单元，每个 Region 都有一个左闭右开的区间 [startKey, endKey), 可根据请求流量/负载/数据量大小等指标自动分裂以及自动副本搬迁。</li></ul><p>特点</p><ul><li>嵌入式</li><li>强一致性</li><li>自驱动</li><li class=ql-indent-1>自诊断, 自优化, 自决策</li></ul><p>以上几点(尤其2、3) 基本都是依托于 SOFAJRaft 自身的功能来实现，详细介绍请参考 SOFAJRaft 文档 。</p><h1>致谢</h1><p>感谢 braft、etcd、tikv 贡献了优秀的 Raft 实现，SOFAJRaft 受益良多。</p><h1>招聘</h1><p>蚂蚁金服中间件团队持续在寻找对于基础中间件（如消息、数据中间件以及分布式计算等）以及下一代高性能面向实时分析的时序数据库等方向充满热情的小伙伴加入，有意者请联系 boyan@antfin.com。</p><h1>参考资料</h1><ul><li>SOFAJRaft 源码 https://github.com/alipay/sofa-jraft</li><li>SOFAJRaft 详细文档 https://github.com/alipay/sofa-jraft/wiki</li><li>Raft https://raft.github.io/</li><li>Raft paper https://raft.github.io/raft.pdf</li><li>Raft: A Consensus Algorithm for Replicated Logs https://raft.github.io/slides/raftuserstudy2013.pdf</li><li>Paxos/Raft：分布式一致性算法原理剖析及其在实战中的应用 https://github.com/hedengcheng/tech/tree/master/distributed</li><li>braft 文档 https://github.com/brpc/braft/blob/master/docs/cn/raft_protocol.md</li><li>线性一致性和 Raft https://pingcap.com/blog-cn/linearizability-and-raft</li><li>Strong consistency models https://aphyr.com/posts/313-strong-consistency-models</li><li>etcd raft 设计与实现《一》https://zhuanlan.zhihu.com/p/51063866</li><li>Metrics https://metrics.dropwizard.io/4.0.0/getting-started.html</li><li>jepsen https://github.com/jepsen-io/jepsen</li><li>Benchmark https://github.com/alipay/sofa-jraft/wiki/Benchmark-%E6%95%B0%E6%8D%AE</li></ul><p>作者：s潘潘</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'蚂蚁','金服','开源'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>