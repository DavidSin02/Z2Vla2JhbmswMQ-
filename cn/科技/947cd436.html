<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring Security OAuth2 入门 | 极客快訊</title><meta property="og:title" content="Spring Security OAuth2 入门 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/30b7584056744a0eb2d53d1f039f7bb7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/947cd436.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/947cd436.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/947cd436.html><meta property="article:published_time" content="2020-11-14T21:00:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:29+08:00"><meta name=Keywords content><meta name=description content="Spring Security OAuth2 入门"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/947cd436.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring Security OAuth2 入门</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><ul><li>1. 概述</li><li>2. 引入 Spring Security OAuth2 依赖</li><li>3. 配置资源服务器</li><li>4. 配置授权服务器</li><li class=ql-indent-1>4.1 授权码模式</li><li>Spring Security Setting</li><li class=ql-indent-1>4.2 密码模式</li><li class=ql-indent-1>4.3 简化模式</li><li class=ql-indent-1>4.4 客户端模式</li><li class=ql-indent-1>4.5 如何选择？</li><li class=ql-indent-1>4.6 为什么有 Client 编号和密码</li><li>5. 刷新令牌</li><li class=ql-indent-1>5.1 获取刷新令牌</li><li class=ql-indent-1>5.2 “刷新”访问令牌</li><li class=ql-indent-1>5.3 为什么需要有刷新令牌</li><li>6. 删除令牌</li><li class=ql-indent-1>6.1 删除访问令牌</li><li class=ql-indent-1>6.2 删除刷新令牌</li><li class=ql-indent-1>6.3 RFC7009 - OAuth2 Token Revocation</li><li>7. 令牌元数据</li><li>666. 彩蛋</li></ul><hr><h1><strong>1. 概述</strong></h1><p>本文，我们来入门 Spring Security OAuth2.0 的使用。通过本文，希望你对 OAuth2.0 有一次身临其境的感受。</p><p>另外，这是一篇入门的文章，所以实际场景下，需要做一些微调。当然，需要微调的地方，笔者会在示例中说明，以免误导。</p><p>如果你是 OAuth2.0 的萌新，建议先通读阮一峰大神的 《理解OAuth 2.0》。因为，本文不会去阐述 OAuth2.0 概念部分的内容。或者，也可以看看 《OAuth 2.0最简向导》 ，比较生动形象。</p><p>阅读完本文后，你想要更加深入的理解 OAuth2.0 ，可以阅读如下两本书籍：</p><ul><li>《OAuth2 in Action》 重原理</li><li>《OAuth2 2.0 Cookbook》 重实践，基于 Spring Security OAuth2 。</li></ul><p>阅读完本文后，你想要了解源码，可以阅读老徐的两篇文章：</p><ul><li>《Re：从零开始的Spring Security OAuth2（二）》</li><li>《Re：从零开始的Spring Security OAuth2（三）》</li></ul><hr><p>OK，一波安利之后，我们来一起进入正文。对于 Spring Security OAuth2 的配置，大体来说，就是<strong>两步</strong>：</p><ol><li>配置授权服务器( AuthorizationServer )</li><li>配置资源服务器( ResourceServer )</li></ol><h1><strong>2. 引入 Spring Security OAuth2 依赖</strong></h1><p>在 pom.xml 文件中，引入如下:</p><pre>&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.16.RELEASE&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;!-- for Spring MVC --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- for Spring Security --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- for OAuth 2.0 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;</pre><p>因为，我们使用的是 SpringBoot 的版本为 1.5.16.RELEASE ，所以使用的 Spring Security 的版本为 4.2.8.RELEASE ，Spring Security OAuth2 的版本为 2.2.0.15.RELEASE 。</p><h1><strong>3. 配置资源服务器</strong></h1><p>一般情况下，资源服务器指的是，我们提供 API 的应用或服务。例如，订单服务、商品服务。<strong>考虑到让整个示例更加简单，本文先将它和授权服务器放在一个 Maven 项目中</strong>。</p><p>① 创建一个 Controller 类</p><pre>/** * 示例模块 Controller */@RestController@RequestMapping("/api/example")public class ExampleController { @RequestMapping("/hello") public String hello() { return "world"; }}</pre><ul><li>非常简单，这是一个示例模块的 Controller ，提供 /api/example/hello 接口。</li></ul><p>② 配置资源服务器</p><pre>// 资源服务配置@Configuration@EnableResourceServerpublic class OAuth2ResourceServer extends ResourceServerConfigurerAdapter { @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() // 对 "/api/**" 开启认证 .anyRequest() .authenticated() .and() .requestMatchers() .antMatchers("/api/**"); }}</pre><ul><li>@Configuration 注解，保证 OAuth2ResourceServer 能够被 SpringBoot 扫描到配置。</li><li>@EnableResourceServer 注解，开启资源服务器。</li><li>继承( extends ) ResourceServerConfigurerAdapter 类，并覆写 #configure(HttpSecurity http) 方法，配置对 HTTP 请求中，匹配 /api/**" 路径，开启认证的验证。</li></ul><h1><strong>4. 配置授权服务器</strong></h1><p>在 OAuth2.0 中，定义了<strong>四种</strong>授权模式：</p><ul><li>授权码模式( authorization code )</li><li>密码模式( resource owner password credentials )</li><li>简化模式( implicit )</li><li>客户端模式( client credentials )</li></ul><p>所以，笔者在 SpringBoot-Labs/lab-02 目录下，每一种方式，都提供了一个 Maven 项目示例。</p><p><strong>4.1 授权码模式</strong></p><p>Maven 项目结构如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30b7584056744a0eb2d53d1f039f7bb7><p class=pgc-img-caption></p></div><p>Maven 项目结构</p><p>对应 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-02/authorization-code-server</p><p>① 配置授权服务器</p><pre>// 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() // &lt;1&gt; // &lt;2&gt; begin ... .withClient("clientapp").secret("112233") // Client 账号、密码。 .redirectUris("http://localhost:9001/callback") // 配置回调地址，选填。 .authorizedGrantTypes("authorization_code") // 授权码模式 .scopes("read_userinfo", "read_contacts") // 可授权的 Scope // &lt;2&gt; end ...// .and().withClient() // 可以继续配置新的 Client // &lt;3&gt; ; }}</pre><ul><li>@Configuration 注解，保证 OAuth2AuthorizationServer 能够被 SpringBoot 扫描到配置。</li><li>@EnableAuthorizationServer 注解，开启授权服务器。</li><li>&lt;1> 处，基于内存，为了方便测试。实际情况下，最好放入<strong>数据库</strong>中，方便管理。</li><li>&lt;2> 处，创建一个 Client 配置。</li><li>&lt;3> 处，可以使用 #and() 方法，继续添加另外的 Client 配置。</li></ul><p>② 配置登陆账号</p><p>创建 application.properties 文件，并配置如下：</p><pre># Spring Security Settingsecurity.user.name=yunaisecurity.user.password=1024</pre><ul><li>这里配置了一个账号为 "yunai" ，密码为 "1024" 的登陆账户。</li><li>实际生产环境下，登陆账号的数据，肯定是放在<strong>数据库</strong>中。</li></ul><p>③ 启动项目</p><pre>@SpringBootApplicationpublic class Application { public static void main(String[] args) { SpringApplication.run(Application.class, args); }}</pre><p>启动项目</p><p>④ 获取授权码</p><p>4.1 浏览器打开 http://localhost:8080/oauth/authorize?client_id=clientapp&redirect_uri=http://localhost:9001/callback&response_type=code&scope=read_userinfo</p><ul><li>client_id 参数，<strong>必传</strong>，为我们在 OAuth2AuthorizationServer 中配置的 Client 的编号。</li><li>redirect_url 参数，<strong>可选</strong>，回调地址。当然，如果 client_id 对应的 Client 未配置 redirectUris 属性，会报错。</li><li>response_type 参数，<strong>必传</strong>，返回结果为<strong>授权码</strong>。</li><li>scope 参数，<strong>可选</strong>，申请授权的 Scope 。如果多个，使用逗号分隔。</li><li>state 参数，<strong>可选</strong>，表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li><li class=ql-indent-1><em>未在上述 URL 中体现出来</em>。</li></ul><p>4.2 浏览器打开后，效果如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2c0398b6bfa446ad8f35c8a8cff08e0c><p class=pgc-img-caption></p></div><p>浏览器</p><ul><li>输入在 「② 配置登陆账号」 中配置的登陆账号 "yunai" / "1024" 。</li><li>实际生产情况下，我们以 QQ 三方登陆作为例子，如下图：</li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e54b12c8993489e9b338e0ec9cdbfbb><p class=pgc-img-caption></p></div><ul><li>QQ 示例</li></ul><p>4.3 登陆成功，选择允许所有申请的 Scope ，点击【Authorize】按钮，确认授权。如下图：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d74dc322da1462fa716502d32d37942><p class=pgc-img-caption></p></div><p>Authorize</p><p>4.4 授权完成，回调 redirect_uri 地址。如下图所示：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/583e98bb10534b13b4b33a404d7d6a91><p class=pgc-img-caption></p></div><p>回调地址</p><ul><li>code 参数，就是返回的授权码。</li></ul><p>⑤ 获取访问令牌</p><pre>curl -X POST --user clientapp:112233 http://localhost:8080/oauth/token -H "content-type: application/x-www-form-urlencoded" -d "code=UydkmV&amp;grant_type=authorization_code&amp;redirect_uri=http%3A%2F%2Flocalhost%3A9001%2Fcallback&amp;scope=read_userinfo"</pre><ul><li>--user clientapp:112233 处，填写我们在 OAuth2AuthorizationServer 中配置的 Client 的编号和密码。</li><li>code=UydkmV 处，填写在 「④ 获取授权码」 中获取的授权码( code ) 。</li></ul><p>返回结果示例如下：</p><pre>{ "access_token": "e60e41f2-2ad0-4c79-97d5-49af38e5c2e8",  "token_type": "bearer",  "expires_in": 43199,  "scope": "read_userinfo"}</pre><ul><li>access_token 属性，访问令牌。<strong>非空</strong>。</li><li>token_type 属性，令牌类型，可以是 "bearer" 或 "mac" 类型。<strong>非空</strong>。</li><li>expires_in 属性，过期时间，单位为秒。一般情况下，非空。</li><li>scope 属性，权限范围。如果与 Client 申请的范围一致，此项可省略。</li><li>refresh_token 属性，刷新令牌，用来获取下一次的访问令牌。</li><li class=ql-indent-1>在授权码模式下，<strong>允许为空</strong>。</li></ul><p>可能有部分胖友是 Windows 电脑，可以参考 《windows（64位）下使用 curl 命令》 来安装一个 curl 命令。</p><p>当然，如果胖友使用 Postman ，可以参看如下两图：</p><ul><li><br></li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac0e54ab22eb41ddae5c3dc910be6adb><p class=pgc-img-caption></p></div><ul><li>图 1</li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/db6f5dd8b9654d82978837aa59292829><p class=pgc-img-caption></p></div><ul><li>图 2</li></ul><p>⑥ 调用资源服务器的 API</p><pre>curl -X GET http://localhost:8080/api/example/hello -H "authorization: Bearer e60e41f2-2ad0-4c79-97d5-49af38e5c2e8"</pre><ul><li>authorization: Bearer e60e41f2-2ad0-4c79-97d5-49af38e5c2e8 处，填写指定的访问令牌类型和访问令牌。例如此处分别为，"Bearer"、"e60e41f2-2ad0-4c79-97d5-49af38e5c2e8" 。</li></ul><p>如果胖友使用 Postman ，可以参看如下图：</p><ul><li><br></li></ul><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1cf8acd198fa4fa0a6879e1f7fe0a231><p class=pgc-img-caption></p></div><ul><li>图</li></ul><p><strong>4.2 密码模式</strong></p><p>Maven 项目结构如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/805fda53fe80438d9185ed53ec3f9ee1><p class=pgc-img-caption></p></div><p>Maven 项目结构</p><p>对应 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/f8d701cbd9b2a4f2cee3a7f2186148bcdf859895/lab-02/resource-owner-password-credentials-server</p><p>① 配置授权服务器</p><pre>// 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { // 用户认证 @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 账号、密码。 .authorizedGrantTypes("password") // 密码模式 .scopes("read_userinfo", "read_contacts") // 可授权的 Scope// .and().withClient() // 可以继续配置新的 Client ; }}</pre><ul><li>配置 Client 的方式，和【授权码模式】基本一致。差别在于：</li><li class=ql-indent-1>无需配置 `redirectUris` 属性，因为不需要回调地址。</li><li class=ql-indent-1>配置授权模式为【<strong>密码模式</strong>】。</li><li>另外，需要引入 <strong>AuthenticationManager</strong> 来支持【密码模式】，否则会报 "Resolved [error="unsupported_grant_type", error_description="Unsupported grant type: password"]" 异常。</li></ul><p>② 配置登陆账号</p><p>和【授权码模式】<strong>一致</strong>。</p><p>③ 启动项目</p><p>和【授权码模式】<strong>一致</strong>。</p><p>④ 获取访问令牌</p><pre>curl -X POST --user clientapp:112233 http://localhost:8080/oauth/token -H "accept: application/json" -H "content-type: application/x-www-form-urlencoded" -d "grant_type=password&amp;username=yunai&amp;password=1024&amp;scope=read_userinfo"</pre><ul><li>和【授权码模式】差异比较大。</li><li>直接请求 oauth/token 接口，获得访问令牌。</li><li>请求参数带上了 username 和 password ，就用户的登陆账号和密码。</li><li>请求参数 grant_type 为 password ，表示【密码模式】。</li></ul><p>返回结果示例如下：</p><pre>{ "access_token": "68de6eb9-5672-4e47-a3e6-110404285ba9", "token_type": "bearer", "expires_in": 43199, "scope": "read_userinfo"}</pre><ul><li>和【授权码模式】一致。</li></ul><p>⑤ 调用资源服务器的 API</p><p>和【授权码模式】<strong>一致</strong>。</p><p><strong>4.3 简化模式</strong></p><p>Maven 项目结构如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/07b3cdb156354222bf76ff9c252080e4><p class=pgc-img-caption></p></div><p>Maven 项目结构</p><p>对应 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/f8d701cbd9b2a4f2cee3a7f2186148bcdf859895/lab-02/implicit-server</p><p>① 配置授权服务器</p><pre>// 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 账号、密码。 .redirectUris("http://localhost:9001/callback") // 配置回调地址，选填。 .authorizedGrantTypes("implicit") // 授权码模式 .scopes("read_userinfo", "read_contacts") // 可授权的 Scope// .and().withClient() // 可以继续配置新的 Client ; }}</pre><ul><li>和【授权码模式】基本一致。差别<strong>仅仅</strong>在于：配置授权模式为【简化模式】。</li></ul><blockquote><p>FROM 《理解 OAuth 2.0》</p><p>简化模式（implicit grant type）不通过第三方应用程序的服务器，直接在浏览器中向认证服务器申请令牌，跳过了"授权码"这个步骤，因此得名。所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。</p></blockquote><p>② 配置登陆账号</p><p>和【授权码模式】一致。</p><p>③ 启动项目</p><p>和【授权码模式】一致。</p><p>④ 获取授权码</p><p>4.1 浏览器打开 http://localhost:8080/oauth/authorize?client_id=clientapp&redirect_uri=http://localhost:9001/callback&response_type=implicit&scope=read_userinfo</p><ul><li>和【授权码模式】基本一致。差别<strong>仅仅</strong>在于：请求参数 response_type 为 "implicit" 简化模式。</li></ul><p>4.2 浏览器打开后，效果如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e12f36b8e90249cfb2ae9ea547800601><p class=pgc-img-caption></p></div><p>浏览器</p><ul><li>和【授权码模式】基本一致，输入在 「② 配置登陆账号」 中配置的登陆账号 "yunai" / "1024" 。</li></ul><p>4.3 登陆成功，直接授权完成，回调 redirect_uri 地址。如下图所示：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0fd5174469084e718cfe845c9131b93e><p class=pgc-img-caption></p></div><p>浏览器</p><ul><li>和【授权码模式】基本不一致的有<strong>两点</strong>：</li><li class=ql-indent-1>登陆成功后，<strong>无需</strong>选择允许所有申请的 Scope ，直接授权完成。</li><li class=ql-indent-1>返回的不是授权码，而是<strong>访问令牌</strong>。</li></ul><blockquote><p>总的来说，【简化模式】是【授权码模式】的简化模式。</p></blockquote><p>⑤ 调用资源服务器的 API</p><p>和【授权码模式】一致。</p><p><strong>4.4 客户端模式</strong></p><p>Maven 项目结构如下：</p><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/642724b17b7f416daebf5f9273ad8640><p class=pgc-img-caption></p></div><p>Maven 项目结构</p><p>对应 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/f8d701cbd9b2a4f2cee3a7f2186148bcdf859895/lab-02/client-credentials-server</p><p>① 配置授权服务器</p><p>和【密码模式】一致。</p><p>② 配置登陆账号</p><p>它<strong>无需</strong>配置登陆账号。因为它没有用户的概念，直接与授权服务器交互，通过 Client 的编号( client_id )和密码( client_secret )来保证安全性。</p><p>③ 启动项目</p><p>和【密码模式】一致。</p><p>④ 获取访问令牌</p><pre>curl -X POST "http://localhost:8080/oauth/token" --user clientapp:112233 -d "grant_type=client_credentials&amp;scope=read_contacts"</pre><ul><li>和【密码模式】基本一致，差别如下：</li><li class=ql-indent-1>请求参数<strong>无需</strong>带上了 `username` 和 `password` 。</li><li class=ql-indent-1>请求参数 `grant_type` 为 `client_credentials` ，表示【密码模式】。</li></ul><p>返回结果示例如下：</p><pre>{ "access_token":"cb2bdfd8-18fa-4b8f-b525-10587bd672e8", "token_type":"bearer", "expires_in":43199, "scope":"read_contacts"}</pre><ul><li>和【密码模式】一致。</li></ul><p>⑤ 调用资源服务器的 API</p><p>和【密码模式】<strong>一致</strong>。</p><blockquote><p>总的来说，【客户端模式】是【密码模式】的简化模式。</p></blockquote><p><strong>4.5 如何选择？</strong></p><p>可能很多胖友，有跟笔者一样的困惑。下面笔者引用杨波老师的一张图，相信能解决我们的困扰。如下图所示：</p><blockquote><p>FROM 《深度剖析 OAuth2 和微服务安全架构》</p></blockquote><div class=pgc-img><img alt="Spring Security OAuth2 入门" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7509a1cd750a40319046830196d1ef53><p class=pgc-img-caption></p></div><blockquote><p>授权类型选择</p></blockquote><p>当然，对于<strong>黄框</strong>部分，对于笔者还是比较困惑的。笔者认为，第三方的单页应用 SPA ，也是适合采用 Authorization Code Grant 授权模式的。例如，《微信网页授权》 ：</p><blockquote><p>具体而言，网页授权流程分为四步：</p><p>1、引导用户进入授权页面同意授权，获取code</p><p>2、通过code换取网页授权access_token（与基础支持中的access_token不同）</p><p>3、如果需要，开发者可以刷新网页授权access_token，避免过期</p><p>4、通过网页授权access_token和openid获取用户基本信息（支持UnionID机制）</p></blockquote><p>所以，笔者猜测，之所以图中画的是 Implicit Grant 的原因是，受 Google 的 《OAuth 2.0 for Client-side Web Applications》 一文中，推荐使用了 Implicit Grant 。</p><p>当然，具体使用 Implicit Grant 还是 Authorization Code Grant 授权模式，没有定论。笔者，偏向于使用 <strong>Authorization Code Grant</strong>，对于第三方客户端的场景。</p><p><strong>4.6 为什么有 Client 编号和密码</strong></p><p>我们看到上述四种授权模式，无论是哪一种，最终调用授权服务器时，都会传递 Client 编号和密码，这是为什么呢？通过 Client 编号和密码，授权服务器可以知道调用的来源以及正确性。这样，即使“坏人”拿到 Access Token ，但是没有 Client 编号和密码，也不能和授权服务器发生<strong>有效</strong>的交互。</p><h1><strong>5. 刷新令牌</strong></h1><p>在 「4. 配置授权服务器」 中，我们一直没有看到我们期盼的刷新令牌( refresh token )的身影。这是为什么呢？因为我们在配置 Spring Security OAuth2 并未配置，获取访问令牌的同时，获取刷新令牌。</p><p>那么，怎么配置开启获取刷新令牌的功能呢？我们来看看 「5.1 获取刷新令牌」 。</p><p><strong>5.1 获取刷新令牌</strong></p><p>因为【密码模式】相对简单，我们直接在原有程序上做改造。对应 GitHub 地址：https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-02/authorization-code-server-with-refresh-token 。</p><blockquote><p>在步骤上，如果和原有【密码模式】保持一致的地方，下文会进行省略，并标注“和原有<strong>一致</strong>”。</p></blockquote><p>① 配置授权服务器</p><pre>// 授权服务器配置@Configuration@EnableAuthorizationServerpublic class OAuth2AuthorizationServer extends AuthorizationServerConfigurerAdapter { // 用户认证 @Autowired private AuthenticationManager authenticationManager; @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.authenticationManager(authenticationManager); } @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 账号、密码。 .authorizedGrantTypes("password", "refresh_token") // 密码模式 // &lt;1&gt; .scopes("read_userinfo", "read_contacts") // 可授权的 Scope// .and().withClient() // 可以继续配置新的 Client ; }}</pre><ul><li>在 &lt;1> 处，我们很神奇的多配置了一个 "refresh_token" ，用于开启获取刷新令牌的功能。但是但是但是，OAuth2 的授权模式说好的是四种的么，怎么又出现了 "refresh_token" 这种授权模式？淡定，在 Spring Security OAtuh2 中，"refresh_token" 作为一种特殊的授权模式<strong>配置</strong>，用于开启获取刷新令牌的功能。所以，其它授权模式如果开启获取刷新令牌的功能，需要在 #authorizedGrantTypes(…) 设置时，多传入 "refresh_token" 方法参数。</li></ul><p>② 配置登陆账号</p><p>和原有<strong>一致</strong>。</p><p>③ 启动项目</p><p>和原有<strong>一致</strong>。</p><p>④ 获取访问令牌</p><pre>curl -X POST --user clientapp:112233 http://localhost:8080/oauth/token -H "accept: application/json" -H "content-type: application/x-www-form-urlencoded" -d "grant_type=password&amp;username=yunai&amp;password=1024&amp;scope=read_userinfo"</pre><ul><li>和原有<strong>一致</strong>。</li></ul><p>返回结果示例如下：</p><pre>{ "access_token":"092a2286-04e7-4e7d-8c20-19fbe25865ff", "token_type":"bearer", "refresh_token":"afeeb083-997f-4ea8-9334-aab6c1696cca", "expires_in":43199, "scope":"read_userinfo"}</pre><ul><li>在原有的基础上，<strong>多</strong>返回了 "refresh_token" 刷新令牌。美滋滋。</li></ul><p>⑤ 调用资源服务器的 API</p><p>和原有<strong>一致</strong>。</p><p><strong>5.2 “刷新”访问令牌</strong></p><p>因为访问访问令牌会自动过期，通过使用刷新令牌，可以获得<strong>新的</strong>访问令牌。注意，访问令牌获取到的是<strong>新的</strong>，不是老的哈。这也是为什么，在标题上，笔者对<strong>刷新</strong>加了双引号。</p><pre>curl -i -X POST -u 'clientapp:112233' http://localhost:8080/oauth/token -H "accept: application/json" -d 'grant_type=refresh_token&amp;refresh_token=afeeb083-997f-4ea8-9334-aab6c1696cca'</pre><ul><li>调用接口还是 "oauth/token" ，差别在于传入的请求参数 grant_type 为 "refresh_token"，使用刷新令牌。</li><li>请求参数 refresh_token 为上面获取到的刷新令牌 "afeeb083-997f-4ea8-9334-aab6c1696cca" 。</li></ul><p>返回结果示例如下：</p><pre>{ "access_token":"507eb761-4b25-4159-b927-ef3eff5e7eff", "token_type":"bearer", "refresh_token":"afeeb083-997f-4ea8-9334-aab6c1696cca", "expires_in":43199, "scope":"read_userinfo"}</pre><ul><li>获得的访问令牌为 "507eb761-4b25-4159-b927-ef3eff5e7eff" ，是<strong>新的</strong>。并且，过期时间也变成<strong>新的</strong>。</li></ul><hr><p>笔者在看 OAuth2.0 的刷新令牌时，一直有个疑惑：刷新令牌是否有过期时间？答案是，<strong>有</strong>。但是，笔者不太确定，在 Spring Security OAuth2 中，如果不设置刷新令牌的过期时间，刷新时间是否<strong>无限长</strong>？当然，这个貌似也并不重要。因为，在实际使用中，我们肯定是需要显示( 主动 )设置刷新令牌的过期时间，使用 ClientBuilder#refreshTokenValiditySeconds(int refreshTokenValiditySeconds) 方法，示例如下：</p><pre>@Overridepublic void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient("clientapp").secret("112233") // Client 账号、密码。 .authorizedGrantTypes("password", "refresh_token") // 密码模式 .scopes("read_userinfo", "read_contacts") // 可授权的 Scope .refreshTokenValiditySeconds(1200) // 1200 秒过期// .and().withClient() // 可以继续配置新的 Client ;}</pre><p>刷新令牌过期时，返回结果示例如下：</p><pre>{ "error":"invalid_token", "error_description":"Invalid refresh token (expired): 7139d075-c4ea-48f0-9dbb-6f65fa6dbeb0"}</pre><ul><li>如果胖友要测试这个效果，可以把刷新令牌过期时间设置为 1 秒。</li></ul><p><strong>5.3 为什么需要有刷新令牌</strong></p><p>出于<strong>安全性</strong>的考虑，访问令牌的过期时间比较短，刷新令牌的过期时间比较长。这样，如果访问令牌即使被盗用走，那么在一定的时间后，访问令牌也能在较短的时间吼过期。当然，安全也是相对的，如果使用刷新令牌后，获取到新的访问令牌，访问令牌<strong>后续</strong>又<strong>可能</strong>被盗用。</p><p>另外，刷新令牌是可选项，不一定会返回。</p><p>笔者整理了下，大家常用开放平台的令牌过期时间，让大家更好的理解：</p><ul><li>小米开放平台</li><li class=ql-indent-1>《Access Token 生命周期》</li><li class=ql-indent-1>Access Token ：90 天有效期</li><li class=ql-indent-1>Refresh Token ：10 年有效期</li><li>微信开放平台</li><li class=ql-indent-1>《网站应用微信登录开发指南》</li><li class=ql-indent-1>Access Token ：2 小时有效期</li><li class=ql-indent-1>Refresh Token ：未知有效期</li><li>腾讯开放平台</li><li class=ql-indent-1>《获取 Access_Token》</li><li class=ql-indent-1>Access Token ：90 天有效期</li><li class=ql-indent-1>Refresh Token ：未知有效期</li></ul><h1><strong>6. 删除令牌</strong></h1><p>实际在 OAuth2 时，有删除访问令牌和刷新令牌的需求。例如：用户登出系统。虽然说，可以通过客户端<strong>本地</strong>删除令牌的方式实现。但是，考虑到真正的彻底的实现删除令牌，必然服务端<strong>自身</strong>需要删除令牌。</p><p>在 Spring Security OAuth2 中，并没有提供内置的接口，所以需要自己去实现。笔者参看 《Spring Security OAuth2 – Simple Token Revocation》 文档，实现删除令牌的 API 接口。</p><p>因为【密码模式】相对简单，我们直接在原有程序上做改造。对应 GitHub 地址： 。注意，如下仅仅是 Demo ，实际生产环境下需要做改造。</p><p><strong>6.1 删除访问令牌</strong></p><p>① 新增删除访问令牌的 API 接口</p><pre>@Autowiredprivate ConsumerTokenServices tokenServices;@RequestMapping(method = RequestMethod.POST, value = "api/access_token/revoke")public String revokeToken(@RequestParam("token") String token) { tokenServices.revokeToken(token); return token;}</pre><ul><li>使用 ConsumerTokenServices#revokeToken(String tokenValue) 方法，删除访问令牌。</li></ul><p><strong>注意</strong>，实际生产环境下，授权服务器和资源服务器是不在一起的，所以此处仅仅是示例。主要是为了介绍 ConsumerTokenServices#revokeToken(String tokenValue) 方法的使用。</p><p>② 访问删除访问令牌的 API 接口。</p><pre>curl -X POST http://localhost:8080/api/access_token/revoke -H "authorization: Bearer 23874e0b-a1d8-4337-9551-7b9be1ebaebe" -d "token=23874e0b-a1d8-4337-9551-7b9be1ebaebe"</pre><p>移除成功后，在使用当前访问令牌，就会报如下错误：</p><pre>{ "error":"invalid_token", "error_description":"Invalid access token: 23874e0b-a1d8-4337-9551-7b9be1ebaebe"}</pre><hr><p>另外，也可以参考 https://github.com/geektime-geekbang/oauth2lab/blob/master/lab05/oauth-server/src/main/java/io/spring2go/config/RevokeTokenEndpoint.java 的实现。</p><p><strong>6.2 删除刷新令牌</strong></p><p>① 新增删除访问令牌的 API 接口</p><pre>@Autowired(required = false) // &lt;1&gt;private TokenStore tokenStore;@RequestMapping(method = RequestMethod.POST, value = "api/refresh_token/revoke")public String revokeRefreshToken(@RequestParam("token") String token) { tokenStore.removeRefreshToken(new DefaultOAuth2RefreshToken(token)); return token;}</pre><ul><li>&lt;1> 处，使用了 required = false 的原因是，本示例并未显示声明 TokenStore Bean 对象交给 Spring 管理，所以无法注入。 所以 「6.2 删除刷新令牌」 是一个无法<strong>跑通</strong>的示例。</li><li>重点在于，调用 TokenStore#removeRefreshToken(OAuth2RefreshToken token) 方法，删除刷新令牌。</li></ul><p>② 访问删除刷新令牌的 API 接口。</p><pre>curl -X POST http://localhost:8080/api/refresh_token/revoke -H "authorization: Bearer 52e85411-ac1d-4844-bf03-cf5633e4eecd" -d "token=ead4734a-ca5c-45bf-ac25-9a92291a9fe1"</pre><p>移除成功后，在使用当前刷新令牌，就会报如下错误：</p><pre>{ "error":"invalid_token", "error_description":"Invalid refresh token: ead4734a-ca5c-45bf-ac25-9a92291a9fe1"}</pre><hr><p>另外，也可以参考 https://github.com/geektime-geekbang/oauth2lab/blob/master/lab05/oauth-server/src/main/java/io/spring2go/config/TokenController.java 的实现。</p><p><strong>6.3 RFC7009 - OAuth2 Token Revocation</strong></p><p>在 OAuth2 中，删除令牌，标准的说法为 OAuth2 Token 撤销，对应 RFC7009 。感兴趣的胖友，可以看看。</p><blockquote><p>FROM 《OAuth2 Token 撤销（RFC7009 - OAuth2 Token Revocation）》</p></blockquote><p>简单来说，这个协议规定了一个Authorization server提供一个怎样的API来供Client撤销access_token或者refresh_token。</p><p>比如Client发起一个如下的请求：</p><blockquote><p><em>POST /revoke HTTP/1.1</em></p><p><em>Host: server.example.com</em></p><p><em>Content-Type: application/x-www-form-urlencoded</em></p><p><em>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW</em></p><p><em>token=45ghiukldjahdnhzdauz&token_type_hint=refresh_token</em></p></blockquote><p>其中各项含义如下：</p><ol><li>/revoke：是Authorization Server需要提供的API地址，Client使用Post方式请求这个地址。</li><li>Content-Type: application/x-www-form-urlencoded：固定此格式。</li><li>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW：访问受保护资源的授权凭证。</li><li>token：必选，可以是access_token或者refresh_token的内容。</li><li>token_type_hint：可选，表示token的类型，值为”access_token“或者"refresh_token"。</li></ol><p>如果撤销成功，则返回一个HTTP status code为200的响应就可以了。</p><h1><strong>7. 令牌元数据</strong></h1><blockquote><p>FROM 《OAuth2 Token 元数据（RFC7662 - OAuth2 Token Introspection）》</p></blockquote><p>简单的总结来说，这个规范是为OAuth2扩展了一个API接口（Introspection Endpoint），让第三方Client可以查询上面提到的那些信息（比如，access_token是否还有效，谁颁发的，颁发给谁的，scope又哪些等等的元数据信息）。</p><p>比如Client发起一个如下的请求：</p><blockquote><p><em>POST /introspect HTTP/1.1</em></p><p><em>Host: server.example.com</em></p><p><em>Accept: application/json</em></p><p><em>Content-Type: application/x-www-form-urlencoded</em></p><p><em>Authorization: Bearer 23410913-abewfq.123483</em></p><p><em>token=2YotnFZFEjr1zCsicMWpAA&token_type_hint=access_token</em></p></blockquote><p>看起来和上面的撤销Token的请求差不多，其中各项含义如下：</p><ol><li>/introspect：是Authorization Server需要提供的API地址，Client使用Post方式请求这个地址。</li><li>Accept:application/json：表示Authorization Server需要返回一个JSON格式的数据。</li><li>Content-Type: application/x-www-form-urlencoded：固定此格式。</li><li>Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW：访问受保护资源的授权凭证。</li><li>token：必选，可以是access_token或者refresh_token的内容。</li><li>token_type_hint：可选，表示token的类型，值为”access_token“或者"refresh_token"。</li></ol><p>如果请求成功，则会返回如下的信息：</p><pre> 1 { 2 "active": true, 3 "client_id": "l238j323ds-23ij4", 4 "token_type":"access_token", 5 "username": "jdoe", 6 "scope": "read write dolphin", 7 "sub": "Z5O3upPC88QrAjx00dis", 8 "aud": "https://protected.example.net/resource", 9 "iss": "https://server.example.com/",10 "exp": 1419356238,11 "iat": 1419350238,12 "nbf": 1419350238,13 "jti": "abcdefg"14 "extension_field": "twenty-seven"15 }</pre><p>JSON各项属性含义如下（其中有些信息是在JSON Web Token中定义的，参考链接有详细的介绍）:</p><ol><li>active：必须的。表示token是否还是有效的。</li><li>client_id：可选的。表示token所属的Client。比如上面的<strong>在线打印并且包邮的网站</strong>。</li><li>token_type：可选的。表示token的类型。对应传递的token_type_hint。</li><li>user_name：可选的。表示token的授权者的名字。比如上面的<strong>小明</strong>。</li><li>scope：可选的。和上篇5.1.1 Authorization Request中的可选参数scope对应，表示授权给Client访问的范围，比如是相册，而不是小明的日志以及其他受保护资源。</li><li>sub：可选的。token所属的资源拥有者的唯一标识，JWT定义的。也就是小明的唯一标识符。</li><li>aud：可选的。token颁发给谁的，JWT定义的。</li><li>iss：可选的。token的颁发者，JWT定义的。</li><li>exp：可选的。token的过期时间，JWT定义的。</li><li>iat：可选的。iss颁发token的时间，JWT定义的。</li><li>nbf：可选的。token不会在这个时间之前被使用，JWT定义的。</li><li>jti：可选的。token的唯一标识，JWT定义的。</li><li>extension_field：可以自己扩展相关其他属性。</li></ol><p>其中大量的信息都是可选的信息，而且可以自己扩展需要的属性信息，从这些属性中就可以解决我们上面提到的access_token对于Client不透明的问题。</p><p>我们注意到其中有很多属于JWT定义的属性，那么这个JWT是什么东西？它解决了什么问题？感兴趣的胖友，可以看看 《JSON Web Token (JWT)》 。</p><hr><p>对于令牌元数据 API 接口的实现，笔者这里就暂时不提供。如果有需要的胖友，可以看看 TokenStore 的两个 API ：</p><ul><li>#readAccessToken(String tokenValue) 方法，读取指定的访问令牌的信息。</li><li>#readRefreshToken(String tokenValue) 方法，读取指定的刷新令牌的信息。</li></ul><h1><strong>666. 彩蛋</strong></h1><p>一万个注意，本文仅仅是 Spring Security OAuth2 的入门文章。实际生产使用时，还需要做很多事情。例如：</p><ul><li>使用关系数据库，<strong>持久化</strong>存储 Client 和令牌信息。例如，使用 JdbcTokenStore 。</li><li>授权服务器和资源服务器分离。例如，使用 RemoteTokenServices 。</li><li>使用缓存服务器，提升 Client 和令牌信息的<strong>访问</strong>速度。例如，使用 RedisTokenStore 。</li></ul><p>推荐阅读文章：</p><ul><li>CatalpaFlat 《Spring Security OAuth2 深入解析》</li><li>小东子 《Spring Security OAuth2 开发指南》</li><li>聊聊架构 《轻松筹 1.6 亿注册用户的 Passport 账户体系架构设计》</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Spring','Security','OAuth2'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>