<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MMU那些事儿 | 极客快訊</title><meta property="og:title" content="MMU那些事儿 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/2f8774b161924896932f778bd5f65887"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95152b39.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95152b39.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95152b39.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95152b39.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95152b39.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95152b39.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95152b39.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95152b39.html><meta property="article:published_time" content="2020-11-14T21:04:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:11+08:00"><meta name=Keywords content><meta name=description content="MMU那些事儿"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/95152b39.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MMU那些事儿</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>最近在重新看这部分知识点，内存管理和进程调度应该是Linux下最核心的两个东西，不管你做得多牛逼了，这两点拿出来讨论，总是会让人眼前一亮，或者是可以讨论很久很久，这篇文章，读完后可能也可以让大家耳目一新。欢迎有问题的同学留言一起学习。祝大家周末快乐~</p><p>[导读]</p><p>本文从内存管理的发展历程角度层层递进，介绍 MMU 的诞生背景，工作机制。而忽略了具体处理器的具体实现细节，将 MMU 的工作原理从概念上比较清晰的梳理了一遍。</p><h2 class=pgc-h-arrow-right><strong>#MMU 诞生之前:</strong></h2><p>在传统的批处理系统如 DOS 系统,应用程序与操作系统在内存中的布局大致如下图：</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2f8774b161924896932f778bd5f65887><p class=pgc-img-caption></p></div><ul><li>应用程序直接访问物理内存，操作系统占用一部分内存区。</li><li>操作系统的职责是“加载”应用程序，“运行”或“卸载”应用程序。</li></ul><p>如果我们一直是单任务处理，则不会有任何问题，也或者应用程序所需的内存总是非常小，则这种架构是不会有任何问题的。然而随着计算机科学技术的发展，所需解决的问题越来越复杂，单任务批处理已不能满足需求了。而且应用程序需要的内存量也越来越大。而且伴随着多任务同时处理的需求，这种技术架构已然不能满足需求了，早先的多任务处理系统是怎么运作的呢？</p><p>程序员将应用程序分段加载执行，但是分段是一个苦力活。而且死板枯燥。此时聪明的计算机科学家想到了好办法，提出来虚拟内存的思想。程序所需的内存可以远超物理内存的大小，将当前需要执行的留在内存中，而不需要执行的部分留在磁盘中，这样同时就可以满足多应用程序同时驻留内存能并发执行了。</p><p>从总体上而言，需要实现哪些大的策略呢？</p><ul><li>所有的应用程序能同时驻留内存，并由操作系统调度并发执行。需要提供机制管理 I/O 重叠，CPU 资源竞争访问。</li><li>虚实内存映射及交换管理，可以将真实的物理内存，有可变或固定的分区，分页或者分段与虚拟内存建立交换映射关系，并且有效的管理这种映射，实现交换管理。</li></ul><p>这样，衍生而来的一些实现上的更具体的需求：</p><ul><li><strong>竞争访问保护管理需求</strong>：需要严格的访问保护，动态管理哪些内存页/段或区，为哪些应用程序所用。这属于资源的竞争访问管理需求。</li><li><strong>高效的翻译转换管理需求</strong>：需要实现快速高效的映射翻译转换，否则系统的运行效率将会低下。</li><li><strong>高效的虚实内存交换需求</strong>：需要在实际的虚拟内存与物理内存进行内存页/段交换过程中快速高效。</li></ul><p>总之，在这样的背景下，MMU 应运而生，也由此可见，任何一项技术的发展壮大，都必然是需求驱动的。这是技术本身发展的客观规律。</p><p><br></p><h2 class=pgc-h-arrow-right><strong>#内存管理的好处</strong></h2><ul><li>为编程提供方便统一的内存空间抽象，在应用开发而言，好似都完全拥有各自独立的用户内存空间的访问权限，这样隐藏了底层实现细节，提供了统一可移植用户抽象。</li><li>以最小的开销换取性能最大化，利用 MMU 管理内存肯定不如直接对内存进行访问效率高，为什么需要用这样的机制进行内存管理，是因为并发进程每个进程都拥有完整且相互独立的内存空间。那么实际上内存是昂贵的，即使内存成本远比从前便宜，但是应用进程对内存的寻求仍然无法在实际硬件中，设计足够大的内存实现直接访问，即使能满足，CPU 利用地址总线直接寻址空间也是有限的。</li></ul><h2 class=pgc-h-arrow-right><strong>#内存管理实现总体策略</strong></h2><p>从操作系统角度来看，虚拟内存的基本抽象由操作系统实现完成：</p><ul><li>处理器内存空间不必与真实的所连接的物理内存空间一致。</li><li>当应用程序请求访问内存时，操作系统将虚拟内存地址翻译成物理内存地址，然后完成访问。</li></ul><p>从应用程序角度来看，应用程序（往往是进程）所使用的地址是虚拟内存地址，从概念上就如下示意图所示，MMU 在<strong>操作系统</strong>的控制下负责将虚拟内存实际翻译成物理内存。</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2edf4fab5c7448ea8c5b96b19b0d66c6><p class=pgc-img-caption></p></div><p>从而这样的机制，虚拟内存使得应用程序不用将其全部内容都一次性驻留在内存中执行：</p><ul><li><strong>节省内存</strong>：很多应用程序都不必让其全部内容一次性加载驻留在内存中，那么这样的好处是显而易见，即使硬件系统配置多大的内存，内存在系统中仍然是最为珍贵的资源。所以这种技术节省内存的好处是显而易见的。</li><li><strong>使得应用程序以及操作系统更具灵活性</strong>。</li><ul><li>操作系统根据应用程序的动态运行时行为灵活的分配内存给应用程序。</li><li>使得应用程序可以使用比实际物理内存多或少的内存空间。</li></ul></ul><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right><strong>#MMU 以及 TLB</strong></h1><p><strong>MMU(Memory Management Unit)内存管理单元</strong>：</p><ul><li>一种硬件电路单元负责将虚拟内存地址转换为物理内存地址</li><li>所有的内存访问都将通过 MMU 进行转换，除非没有使能 MMU。</li></ul><p><strong>TLB(Translation Lookaside Buﬀer)转译后备缓冲器</strong>: 本质上是 MMU 用于虚拟地址到物理地址转换表的缓存</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d2fefab7b3344d89a4a7d9963855c84><p class=pgc-img-caption></p></div><p>这样一种架构，其最终运行时目的，是为主要满足下面这样运行需求：</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d522ea2f7d14cbd8ec482c0a845774c><p class=pgc-img-caption></p></div><p>多进程并发同时并发运行在实际物理内存空间中，而 MMU 充当了一个至关重要的虚拟内存到物理内存的桥梁作用。</p><p>那么，这种框架具体从高层级的概念上是怎么做到的呢？事实上，是将物理内存采用分片管理的策略来实现的，那么，从实现的角度将有两种可选的策略：</p><ul><li>固定大小分区机制</li><li>可变大小分区机制</li></ul><h1 class=pgc-h-arrow-right><strong>#固定大小区片机制</strong></h1><p>通过这样一种概念上的策略，将物理内存分成固定等大小的片：</p><ul><li>每一个片提供一个基地址</li><li>实际寻址，物理地址=某片基址+虚拟地址</li><li>片基址由操作系统在进程动态运行时动态加载</li></ul><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c3abc098648d4a33af3dc63713e39ed4><p class=pgc-img-caption></p></div><p>这种策略实现，其优势在于简易，切换快速。但是该策略也带来明显的劣势：</p><ul><li>内部碎片:一个进程不使用的分区中的内存对其他进程而言无法使用</li><li>一种分区大小并不能满足所有应用进程所需。</li></ul><h1 class=pgc-h-arrow-right><strong>#可变大小分区机制</strong></h1><p>内存被划分为可变大小的区块进行映射交换管理：</p><ul><li>需要提供基址以及可变大小边界，可变大小边界用于越界保护。</li><li>实际寻址，物理地址=某片基址+虚拟地址</li></ul><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebaa9d4124bf4273ab0ea878c700471d><p class=pgc-img-caption></p></div><p>那么这种策略其优势在于没有内部内存碎片，分配刚好够进程所需的大小。但是劣势在于，在加载和卸载的动态过程中会产生碎片。</p><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right><strong>#分页机制</strong></h1><p>分页机制采用在虚拟内存空间以及物理内存空间都使用固定大小的分区进行映射管理。</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1c1b2dffd7b74c29bdc5299583a76011><p class=pgc-img-caption></p></div><ul><li>从应用程序(进程)角度看内存是连续的 0-N 的分页的虚拟地址空间。</li><li>物理内存角度看，内存页是分散在整个物理存储中</li><li>这种映射关系对应用程序不可见，隐藏了实现细节。</li></ul><p>分页机制是如何寻址的呢？这里介绍的设计理念，具体的处理器实现各有细微差异：</p><ul><li>虚拟地址包含了两个部分：<strong>虚拟页序号 VPN（virtual paging number)以及偏移量</strong></li><li><strong>虚拟页序号 VPN</strong>是<strong>页表（Page Table）</strong>的索引</li><li><strong>页表（Page Table）维护了页框号(Page frame number PFN)</strong></li><li>物理地址由<strong>PFN::Offset</strong>进行解析。</li></ul><p>举个栗子，如下图所示：</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac48893f5f6a4264be1bffc48efac8c6><p class=pgc-img-caption></p></div><p>还没有查到具体的物理地址，憋急，再看一下完整解析示例：</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/978bd64fbe1540f89a580e849e4a82f2><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><strong>#如何管理页表</strong></h2><p>对于 32 位地址空间而言，假定 4K 为分页大小，则页表的大小为 100MB，这对于页表的查询而言是一个很大的开销。那么如何减小这种开销呢？实际运行过程中发现，事实上只需要映射实际使用的很小一部分地址空间。那么在一级页机制基础上，延伸出多级页表机制。</p><p>以二级分页机制为例：</p><div class=pgc-img><img alt=MMU那些事儿 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9087ae8b42df44f98a26de920d841cb4><p class=pgc-img-caption></p></div><p>单级页表已然有不小的开销，查询页表以及取数，而二级分页机制，因为需要查询两次页表，则将这种开销再加一倍。那么如何提高效率呢？其实前面提到一个概念一直还没有深入描述 TLB,将翻译工作由硬件缓存 cache,这就是 TLB 存在的意义。</p><ul><li>TLB 将虚拟页翻译成 PTE，这个工作可在单周期指令完成。</li><li>TLB 由硬件实现</li><ul><li>完全关联缓存(并行查找所有条目)</li><li>缓存索引是虚拟页码</li><li>缓存内容是 PTE</li><li>则由 PTE+offset，可直接计算出物理地址</li></ul></ul><h2 class=pgc-h-arrow-right><strong>#TLB 加载</strong></h2><p>谁负责加载 TLB 呢？这里可供选择的有两种策略：</p><ul><li>由操作系统加载，操作系统找到对应的 PTE，而后加载到 TLB。格式比较灵活。</li><li>MMU 硬件负责，由操作系统维护页表，MMU 直接访问页表，页表格式严格依赖硬件设计格式。</li></ul><h2 class=pgc-h-arrow-right><strong>#总结一下</strong></h2><p>从计算机大致发展历程来了解内存管理的大致发展策略，如何衍生出 MMU，以及固定分片管理、可变分片管理等不同机制的差异，最后衍生出单级分页管理机制、多级分页管理机制、TLB 的作用。从概念上相对比较易懂的角度描述了 MMU 的诞生、机制，而忽略了处理器的具体实现细节。作为从概念上更深入的理解 MMU 的工作机理的角度，还是不失为一篇浅显易懂的文章。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'MMU','事儿','那些'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>