<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++实现二叉树数据结构 | 极客快訊</title><meta property="og:title" content="C++实现二叉树数据结构 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/feeddb3a-c96d-44b6-8672-b125cf06a33c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/95d5c549.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/95d5c549.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="C++实现二叉树数据结构"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/95d5c549.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++实现二叉树数据结构</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>本人从事在线教育c++十年工作经验现在精心整理了一套从小白到项目实践开发各种学习资料如果你想学想加入我们请关注我在私信回复“编程”就可以领取学习资料！！！</p></blockquote><div class=pgc-img><img alt=C++实现二叉树数据结构 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/feeddb3a-c96d-44b6-8672-b125cf06a33c><p class=pgc-img-caption></p></div><hr><p>本文使用C++实现二叉树数据结构，与之前实现的向量、列表、栈和队列不同，树是一种分层结构，虽然树是分层结构，但若附加某种约束，如遍历次序，则树结构也可以转变成线性次序，因此树属于<strong>半线性结构</strong>。树结构具有非常多的变种，在算法理论和实际应用中，各种树结构扮演着最为关键的角色。</p><p>另外，<strong>任何有根有序的多叉树，都能转变成二叉树</strong>，因此二叉树数据结构具有非常重要的地位。</p><p><strong>两种特殊的二叉树:完全二叉树、满二叉树</strong></p><p><strong>完全二叉树: </strong>叶子结点只能出现在最底部的两层，且最底层叶节点均处于次底层叶节点的左侧。</p><p><strong>满二叉树: </strong>所有叶节点同处于最底层(非底层节点均为内部结点)。</p><p>二叉树的实现和列表数据结构有很大的相似性，都需要为相互临近的节点之间维护正确的指针指向。这里二叉树数据结构的实现包括binNode类和binTree类，前者主要描述单个二叉树的结构和对其的操作，而binTree类主要描述整个二叉树的结构和对其进行的操作。</p><p>binNode接口列表操作功能对象binNode()默认构造函数 binNode(T e, binNode* p, binNode *lc, binNode *rc, int h)构造函数，设置节点数据，父节点，孩子节点，高度 ~binNode()析构函数 insertAsLC(const T& e)作为本节点的左孩子插入二叉树节点insertAsRC(const T& e)作为本节点的右孩子插入二叉树节点succ()定位在中序遍历中节点v的直接后续二叉树节点重载运算符==相等判断运算符二叉树节点重载运算符&lt;小于运算符二叉树节点</p><p>binTree接口列表操作功能对象binTree()默认构造函数 ~binTree()析构函数 size()返回二叉树的规模二叉树empty()判断二叉树是否为空二叉树root()返回根节点的指针二叉树insertAsRoot(const T& e)将指定元素作为根节点插入二叉树insertAsLC(binNode&lt;T>* bn, const T& e)将指定元素插入作为指定节点的左孩子二叉树insertAsRC(binNode&lt;T>* bn, const T& e)将指定元素插入作为指定节点的右孩子二叉树attachAsLC(binNode&lt;T>* bn, binTree&lt;T>* &bt)将指定子树插入作为指定节点的左孩子二叉树attachAsRC(binNode&lt;T>* bn, binTree&lt;T>* &bt)将指定子树插入作为指定节点的右孩子二叉树updateHeight(binNode&lt;T>* bn)更新节点的高度二叉树updateHeightAbove(binNode&lt;T>* bn)更新此节点祖先节点的高度(插入或删除节点要执行更新)二叉树removeAt(binNode&lt;T>* bn)删除节点bn及其后代，并返回删掉的二叉树节点的总数二叉树remove(binNode&lt;T>* bn)删除以bn为根节点的子树二叉树secede(binNode&lt;T>* bn)子树分离，将节点bn及其后代从二叉树中分离出来，然后形成一个独立的二叉树二叉树travPre_R(binNode&lt;T>* bn_r, void(*func)(T& bn))先序遍历(递归版本:简洁易懂)二叉树travIn_R(binNode&lt;T>* bn_r, void(*func)(T& bn))中序遍历(递归版本:简洁易懂)二叉树travPost_R(binNode&lt;T>* bn_r, void(*func)(T& bn))后序遍历(递归版本:简洁易懂)二叉树visitAlongLeftBranch(binNode&lt;T>* bn, void(*func)(T& bn), stack&lt;binNode&lt;T>*> &s)沿着左轮廓线遍历二叉树travPre_I(binNode&lt;T>* bn_i, void(*func)(T& bn))先序遍历(迭代版本:时间、空间复杂度低)二叉树goAlongLeftBranch(binNode&lt;T>* bn, stack&lt;binNode&lt;T>*> &s)从当前节点开始，沿着左分支深入入栈二叉树travIn_I(binNode&lt;T>* bn_i, void(*func)(T& bn))中序遍历(迭代版本:时间、空间复杂度低)二叉树gotoHLVFL(stack&lt;binNode&lt;T>*> &s)在以s栈顶节点为根的子树中，找到最高左侧可见节点二叉树travPost_I(binNode&lt;T>* bn_i, void(*func)(T& bn))后序遍历(迭代版本:时间、空间复杂度低)二叉树travLevel(binNode&lt;T>* bn_i, void(*func)(T& bn))层次遍历二叉树</p><p>(1) binNode.h</p><pre>#pragma once#define stature(p) ((p)?(p)-&gt;height:-1) //宏定义不要忘记带括号#define NULL 0template&lt;typename T&gt; struct binNode{	//成员变量	T data;	binNode&lt;T&gt; *parent, *lc, *rc; //指向父类，左孩子右孩子的指针	int height; //高度	//构造函数	binNode() :data(NULL), lc(nullptr), rc(nullptr), height(0) {}	binNode(T e, binNode* p = nullptr, binNode *lc = nullptr, binNode *rc = nullptr, int h = 0) :		data(e), parent(p), lc(lc), rc(rc), height(h) {}	//析构函数	~binNode() {} 	//成员函数	binNode&lt;T&gt;* insertAsLC(const T&amp; e); //作为本节点的左孩子插入	binNode&lt;T&gt;* insertAsRC(const T&amp; e); //作为本节点的右孩子插入	int size(); //返回以本节点为root的二叉树的规模	binNode&lt;T&gt;* succ(); //定位在中序遍历中节点v的直接后续	//重载运算符	bool operator==(const binNode&lt;T&gt;&amp; bn); //等于运算符	bool operator&lt;(const binNode&lt;T&gt;&amp; bn); //小于运算符}; template&lt;typename T&gt; binNode&lt;T&gt;* binNode&lt;T&gt;::insertAsLC(const T&amp; e){	return lc = new binNode&lt;T&gt;(e, this);} template&lt;typename T&gt; binNode&lt;T&gt;* binNode&lt;T&gt;::insertAsRC(const T&amp; e){	return rc = new binNode&lt;T&gt;(e, this);} template&lt;typename T&gt; int binNode&lt;T&gt;::size(){	int n = 0;	if (lc&amp;&amp;rc)		n = 1 + lc-&gt;size() + rc-&gt;size();	if (lc &amp;&amp; (!rc))		n = 1 + lc-&gt;size();	if ((!lc) &amp;&amp; rc)		n = 1 + rc-&gt;size();	if ((!lc) &amp;&amp; (!rc))		return 1; //递归基	return n;} template&lt;typename T&gt; bool binNode&lt;T&gt;::operator==(const binNode&lt;T&gt;&amp; bn){	return data == bn.data;} template&lt;typename T&gt; bool binNode&lt;T&gt;::operator&lt;(const binNode&lt;T&gt;&amp; bn){	return data &lt; bn.data;} template&lt;typename T&gt; binNode&lt;T&gt;* binNode&lt;T&gt;::succ(){	binNode&lt;T&gt;* s = this; //记录后续的临时变量	if (rc) //若有右孩子，则直接后继一定在右子树中的最左边	{		s = rc;		while (s-&gt;lc) s = s-&gt;lc;	}	else //若没有右孩子，则直接后继是将当前节点包含在左子树中的最低祖先	{		while ((s-&gt;parent-&gt;lc) != s)			s = s-&gt;parent;		s = s-&gt;parent;	}	return s;}</pre><p>(2) binTree.h</p><pre>#pragma once#include"binNode.h"#include"stack.h"#include"queue.h" #define max(a,b) (((a)&gt;=(b))?(a):(b)) template&lt;typename T&gt; class binTree{protected:	//成员变量	int _size; //二叉树规模	binNode&lt;T&gt;* _root;//根节点指针 public:	//构造函数	binTree() :_size(0), _root(nullptr) {}		//析构函数	~binTree(); //删除掉所有的子二叉树		//成员函数	int size(); //返回二叉树规模	bool empty(); //判断二叉树是否为空 	binNode&lt;T&gt;* root(); //返回根节点的指针	binNode&lt;T&gt;* insertAsRoot(const T&amp; e); //将指定元素插入作为根节点	binNode&lt;T&gt;* insertAsLC(binNode&lt;T&gt;* bn, const T&amp; e); //将指定元素插入作为指定节点的左孩子	binNode&lt;T&gt;* insertAsRC(binNode&lt;T&gt;* bn, const T&amp; e); //将指定元素插入作为指定节点的右孩子	binNode&lt;T&gt;* attachAsLC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt); //将指定子树插入作为指定节点的左孩子	binNode&lt;T&gt;* attachAsRC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt); //将指定子树插入作为指定节点的右孩子	int updateHeight(binNode&lt;T&gt;* bn); //更新节点的高度	void updateHeightAbove(binNode&lt;T&gt;* bn); //更新此节点祖先节点的高度(插入或删除节点要执行更新) 	int removeAt(binNode&lt;T&gt;* bn); //删除节点bn及其后代，并返回删掉的二叉树节点的总数	int remove(binNode&lt;T&gt;* bn); //删除以bn为根节点的子树	binTree&lt;T&gt;* secede(binNode&lt;T&gt;* bn); //子树分离，将节点bn及其后代从二叉树中分离出来，然后形成一个独立的二叉树 	void travPre_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)); //先序遍历(递归版本:简洁易懂)	void travIn_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)); //中序遍历(递归版本:简洁易懂)	void travPost_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)); //后序遍历(递归版本:简洁易懂) 	void visitAlongLeftBranch(binNode&lt;T&gt;* bn, void(*func)(T&amp; bn), stack&lt;binNode&lt;T&gt;*&gt; &amp;s); //沿着左轮廓线遍历	void travPre_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn));//先序遍历(迭代版本:时间、空间复杂度低)	void goAlongLeftBranch(binNode&lt;T&gt;* bn, stack&lt;binNode&lt;T&gt;*&gt; &amp;s); //从当前节点开始，沿着左分支深入入栈	void travIn_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn));//中序遍历(迭代版本:时间、空间复杂度低)	void gotoHLVFL(stack&lt;binNode&lt;T&gt;*&gt; &amp;s); //在以s栈顶节点为根的子树中，找到最高左侧可见节点	void travPost_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn));//后序遍历(迭代版本:时间、空间复杂度低) 	void travLevel(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)); //层次遍历 }; template&lt;typename T&gt; binTree&lt;T&gt;::~binTree(){	if (_size)		remove(_root);} template&lt;typename T&gt; int binTree&lt;T&gt;::size(){	return _size;} template&lt;typename T&gt; bool binTree&lt;T&gt;::empty(){	return _root ? true : false;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::root(){	return _root;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::insertAsRoot(const T&amp; e){	if (_root) return nullptr;	_size = 1;	return	_root = new binNode&lt;T&gt;(e);} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::insertAsLC(binNode&lt;T&gt;* bn, const T&amp; e){	if (bn-&gt;lc) return nullptr; //若左孩子已经存在则返回	_size++;	bn-&gt;lc = new binNode&lt;T&gt;(e, bn);	updateHeightAbove(bn-&gt;lc);	return bn-&gt;lc;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::insertAsRC(binNode&lt;T&gt;* bn, const T&amp; e){	if (bn-&gt;rc) return nullptr; //若右孩子已经存在则返回	_size++;	bn-&gt;rc = new binNode&lt;T&gt;(e, bn);	updateHeightAbove(bn-&gt;rc);	return bn-&gt;rc;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::attachAsLC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt){	if (bn-&gt;lc) return nullptr;	bn-&gt;lc = bt-&gt;root();	bt-&gt;root()-&gt;parent = bn;	updateHeightAbove(bn-&gt;lc);	_size += bt-&gt;size();	//释放bt	bt-&gt;_root = nullptr;	bt-&gt;_size = 0;	//release(bt);	bt = nullptr;	return bn-&gt;lc;} template&lt;typename T&gt; binNode&lt;T&gt;* binTree&lt;T&gt;::attachAsRC(binNode&lt;T&gt;* bn, binTree&lt;T&gt;* &amp;bt){	if (bn-&gt;rc) return nullptr;	bn-&gt;rc = bt-&gt;root();	bt-&gt;root()-&gt;parent = bn;	updateHeightAbove(bn-&gt;rc);	_size += bt-&gt;size();	//释放bt	bt-&gt;_root = nullptr;	bt-&gt;_size = 0;	bt = nullptr;	return bn-&gt;rc;} template&lt;typename T&gt; int binTree&lt;T&gt;::updateHeight(binNode&lt;T&gt;* bn){	return bn-&gt;height = (1 + max(stature(bn-&gt;lc), stature(bn-&gt;rc)));} template&lt;typename T&gt; void binTree&lt;T&gt;::updateHeightAbove(binNode&lt;T&gt;* bn){	while (bn)	{		updateHeight(bn);		bn = bn-&gt;parent;	}} template&lt;typename T&gt; int binTree&lt;T&gt;::removeAt(binNode&lt;T&gt;* bn){	int n = 0;	if (bn == nullptr) return 0;	n = 1 + removeAt(bn-&gt;lc) + removeAt(bn-&gt;rc);	delete bn;	return n;} template&lt;typename T&gt; int binTree&lt;T&gt;::remove(binNode&lt;T&gt;* bn) {	if (bn != _root)	{		((bn-&gt;parent-&gt;lc) == bn) ? (bn-&gt;parent-&gt;lc) = nullptr : (bn-&gt;parent-&gt;rc) = nullptr;	}	binNode&lt;T&gt;* bp = bn-&gt;parent;	int n = removeAt(bn);	updateHeightAbove(bp);	_size -= n;	return n;} template&lt;typename T&gt; binTree&lt;T&gt;* binTree&lt;T&gt;::secede(binNode&lt;T&gt;* bn){	//首先清除原二叉树与待删除子树的关联	if (bn != _root)	{		((bn-&gt;parent-&gt;lc) == bn) ? (bn-&gt;parent-&gt;lc) = nullptr : (bn-&gt;parent-&gt;rc) = nullptr;	}	//更新height	binNode&lt;T&gt;* bp = bn-&gt;parent;	updateHeightAbove(bp); 	//封装成新二叉树	binTree&lt;T&gt;* bt = new binTree&lt;T&gt;();	bt-&gt;_root = bn;	bn-&gt;parent = nullptr;	//更新size	bt-&gt;_size = bn-&gt;size();	_size -= bt-&gt;_size; 	//特殊情况处理	if (_root = bn)		_root = nullptr;	return bt;} template&lt;typename T&gt; void binTree&lt;T&gt;::travPre_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)){	if (!bn_r) return;	func(bn_r-&gt;data);	travPre_R(bn_r-&gt;lc, func);	travPre_R(bn_r-&gt;rc, func);}  template&lt;typename T&gt; void binTree&lt;T&gt;::travIn_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)){	if (!bn_r) return;	travIn_R(bn_r-&gt;lc, func);	func(bn_r-&gt;data);	travIn_R(bn_r-&gt;rc, func);}  template&lt;typename T&gt; void binTree&lt;T&gt;::travPost_R(binNode&lt;T&gt;* bn_r, void(*func)(T&amp; bn)){	if (!bn_r) return;	travPost_R(bn_r-&gt;lc, func);	travPost_R(bn_r-&gt;rc, func);	func(bn_r-&gt;data);} template&lt;typename T&gt; void binTree&lt;T&gt;::visitAlongLeftBranch(binNode&lt;T&gt;* bn, void(*func)(T&amp; bn), stack&lt;binNode&lt;T&gt;*&gt; &amp;s){	while (bn)	{		func(bn-&gt;data);		s.push(bn-&gt;rc); //右孩子入栈		bn = bn-&gt;lc; //沿着左边沿遍历	}} template&lt;typename T&gt; void binTree&lt;T&gt;::travPre_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	stack&lt;binNode&lt;T&gt;*&gt; S;	while (true)	{		visitAlongLeftBranch(bn_i, func, S); //遍历且入栈		if (S.empty()) break;		bn_i = S.pop();	}} template&lt;typename T&gt; void binTree&lt;T&gt;::goAlongLeftBranch(binNode&lt;T&gt;* bn, stack&lt;binNode&lt;T&gt;*&gt; &amp;s){	while (bn)	{		s.push(bn);		bn = bn-&gt;lc;	}} template&lt;typename T&gt; void binTree&lt;T&gt;::travIn_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	stack&lt;binNode&lt;T&gt;*&gt; S;	while (true)	{		goAlongLeftBranch(bn_i, S);		if (S.empty()) break;		bn_i = S.pop();		func(bn_i-&gt;data);		bn_i = bn_i-&gt;rc;	}} template&lt;typename T&gt; void binTree&lt;T&gt;::gotoHLVFL(stack&lt;binNode&lt;T&gt;*&gt; &amp;s){	while (binNode&lt;T&gt;* bn_i = s.top())	{		if (bn_i-&gt;lc)		{			if (bn_i-&gt;rc)				s.push(bn_i-&gt;rc);			s.push(bn_i-&gt;lc);		}		else		{			s.push(bn_i-&gt;rc);		}	}	s.pop();} template&lt;typename T&gt; void binTree&lt;T&gt;::travPost_I(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	stack&lt;binNode&lt;T&gt;*&gt; S;	if (bn_i)		S.push(bn_i);	while (!S.empty())	{		if (S.top() != bn_i-&gt;parent)			gotoHLVFL(S);		bn_i = S.pop();		func(bn_i-&gt;data);	}}template&lt;typename T&gt; void binTree&lt;T&gt;::travLevel(binNode&lt;T&gt;* bn_i, void(*func)(T&amp; bn)){	queue&lt;binNode&lt;T&gt;*&gt; q;	q.enqueue(bn_i);	while (!q.empty()) //队列非空	{		bn_i = q.dequeue();		func(bn_i-&gt;data);		if(bn_i-&gt;lc)			q.enqueue(bn_i-&gt;lc);		if(bn_i-&gt;rc)			q.enqueue(bn_i-&gt;rc);	}}</pre><blockquote><p>本人从事在线教育c++十年工作经验现在精心整理了一套从小白到项目实践开发各种学习资料如果你想学想加入我们请关注我在私信回复“编程”就可以领取学习资料！！！</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'C++','实现','树数据'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>