<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 | 极客快訊</title><meta property="og:title" content="理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/dcec6fa5c6a046fdbc7eed5cc5dcf73d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/967407b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/967407b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/967407b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/967407b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/967407b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/967407b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/967407b2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/967407b2.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/967407b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>背景</h2><p>日常运维工作中编写shell脚本处理事务，很多时候需要一次性处理很多，需要用到循环，但是循环体内还是线性的，还是要一个个处理，这样并不会节省很多时间，只是节省了人工一次次输入的繁琐。但是对于提高处理能力，没有实质性的提高。这就需要考虑并发。但Shell中并没有真正意义的多线程，要实现多线程可以启动多个后端进程，最大程度利用cpu性能。即：多进程并发，本篇教程由浅入深详细介绍了shell中的多进程并发。</p><p><br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcec6fa5c6a046fdbc7eed5cc5dcf73d><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>范例</h2><pre><code>#!/bin/bashtrap "exec 1000&gt;&amp;-;exec 1000&lt;&amp;-;exit 0" 2mkfifo testfifoexec 1000&lt;&gt;testfiform -fr testfifofor((n=1;n&lt;=10;n++))do    echo &gt;&amp;1000donestart=`date "+%s"`for((i=1;i&lt;=100;i++))do    read -u1000    {        echo "success $i";        sleep 5        echo &gt;&amp;1000    }&amp;donewaitend=`date "+%s"`echo "Time: `expr $end - $start`"exec 1000&gt;&amp;-exec 1000&lt;&amp;-</code></pre><h2 class=pgc-h-arrow-right>实验</h2><p>所谓的多进程只不过是将多个任务放到后台执行而已，很多人都用到过，所以现在讲的主要是控制，而不是实现。</p><h4 class=pgc-h-arrow-right>实验一</h4><p>先看一个小shell：</p><p><br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aa2d255ce04745b4b69936f3333bb005><p class=pgc-img-caption></p></div><p>看执行结果：</p><p><br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d7f3dda0420f41ef986bf945cdf1f056><p class=pgc-img-caption></p></div><p>很明显是8s，这种不占处理器却有很耗时的进程，我们可以通过一种后台运行的方式<br>来达到节约时间的目的。</p><h4 class=pgc-h-arrow-right>实验二</h4><p>如下为改进：</p><p><br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c274a197956047cb8b87ddb34131865a><p class=pgc-img-caption></p></div><p>用“{}”将主执行程序变为一个块，用&放入后台，四次执行全部放入后台后，我们需要用一个wait指令，等待所有后台进程执行结束，不然 系统是不会等待的，直接继续执行后续指令，知道整个程序结束。<br>看结果：</p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/108604b9e80744a39895288fcafddf8a><p class=pgc-img-caption></p></div><p>可以看到，时间已经大大缩短了！</p><p><br></p><h4 class=pgc-h-arrow-right>实验三</h4><p>以上实验虽然达到了多线程并发的目的，但有一个缺陷，不能控制运行在后台的进程数。为了控制进程，我们引入了管道 和文件操作符。</p><p>无名管道： 就是我们经常使用的 例如： cat text | grep “abc” 那个“|”就是管道，只不过是无名的，可以直接作为两个进程的数据通道<br>有名管道： mkfilo 可以创建一个管道文件 ，例如： mkfifo　fifo_file</p><p>管道有一个特点，如果管道中没有数据，那么取管道数据的操作就会停滞，直到管道内进入数据，然后读出后才会终止这一操作，同理，写入管道的操作，如果没有读取操作，这一个动作也会停滞。</p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b646345def514fbf92e5687ceb033fb3><p class=pgc-img-caption></p></div><p>当我们试图用echo想管道文件中写入数据时，由于没有任何进程在对它做读取操作，所以它会一直停留在那里等待读取操作，此时我们在另一终端上用cat指令做读取操作</p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5e3f9d85f7104788a57b8d7ca91be798><p class=pgc-img-caption></p></div><p>你会发现读取操作一旦执行，写入操作就可以顺利完成了，同理，先做读取操作也是一样的：<br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cec3f954c4c94cc78bfaea7c945b3e0c><p class=pgc-img-caption></p></div><p>由于没有管道内没有数据，所以读取操作一直滞留在那里等待写入的数据<br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cf51b796c8249879f078fc62f830fff><p class=pgc-img-caption></p></div><p>一旦有了写入的数据，读取操作立刻顺利完成</p><p>以上实验，看以看到，仅仅一个管道文件似乎很难实现 我们的目的（控制后台线程数), 所以 接下来介绍 文件操作符，这里只做简单的介绍，如果不熟悉的可以自行查阅资料。<br>系统运行起始，就相应设备自动绑定到了 三个文件操作符 分别为 0 1 2 对应 stdin ，stdout， stderr 。<br>在 /proc/self/fd 中 可以看到 这三个三个对应文件</p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d2ec0e62961049118138e99bd4905d6e><p class=pgc-img-caption></p></div><p>输出到这三个文件的内容都会显示出来。只是因为显示器作为最常用的输出设备而被绑定。</p><p>我们可以exec 指令自行定义、绑定文件操作符，文件操作符一般从3–（n-1）都可以随便使用<br>此处的n 为 ulimit -n 的定义值得<br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddcc288d17f4462eb0e610d629f64abb><p class=pgc-img-caption></p></div><p>可以看到 我的 n值为1024 ，所以文件操作符只能使用 0-1023，可自行定义的 就只能是 3-1023 了。</p><p>直接上代码，然后根据代码分析每行代码的含义：<br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9777fff5871c4cf6bd734bdfef59f964><p class=pgc-img-caption></p></div><p><strong>代码解释</strong></p><p>第3行： 接受信号 2 （ctrl +C）做的操作。exec 1000>&-和exec 1000&lt;&- 是关闭fd1000的意思，我们生成做绑 定时 可以用 exec 1000&lt;>testfifo 来实现，但关闭时必须分开来写，> 读的绑定，&lt; 标识写的绑定 &lt;> 则 标识 对文件描述符 1000的所有操作等同于对管道文件testfifo的操作。</p><p>第5-7行：分别为 创建管道文件，文件操作符绑定，删除管道文件<br>　　　　 可能会有疑问，为什么不能直接使用管道文件呢？　<br>　　　　 事实上，这并非多此一举，刚才已经说明了管道文件的一个重要特性了，那就是读写必须同时存在<br>　　　　 缺少某一种操作，另一种操作就是滞留，而绑定文件操作符　正好解决了这个问题。</p><p>第9-12 行： 对文件操作符进行写入操作。通过一个for循环写入10个空行，这个10就是我们要定义的后台线程数 量。<br>为什么写入空行而不是10个字符呢 ？<br>这是因为，管道文件的读取 是以行为单位的。<br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0d10d76fbaa74cb4aedfc5a069af74ce><p class=pgc-img-caption></p></div><p>当我们试图用 read 读取管道中的一个字符时，结果是不成功的，而刚才我们已经证实使用cat是可以 读取的。</p><p>第17-24行：这里假定我们有100个任务，我们要实现的时 ，保证后台只有10个进程在同步运行 。read -u1000 的 作用是：读取一次管道中的一行，在这儿就是读取一个空行。减少操作附中的一个空行之后，执行一 次任务（当然是放到后台执行），需要注意的是，这个任务在后台执行结束以后会向文件操作符中写 入一个空行，这就是重点所在，如果我们不在某种情况某种时刻向操作符中写入空行，那么结果就 是：在后台放入10个任务之后，由于操作符中没有可读取的空行，导致 read -u1000 这儿 始终停顿。</p><p>后边的 就不用解释了。</p><p>贴下执行结果：<br></p><div class=pgc-img><img alt=理解Shell脚本中的多进程和多线程并发，让工作效率提升1000倍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f310a206f52948209f04e1973ad798bc><p class=pgc-img-caption></p></div><p>每次的停顿中都能看到 只有10个进程在运行<br>一共耗时50s 一共100个任务，每次10个 ，每个5s 正好50s。上边的结果图之所以这么有规律，这是因为我们所执行的100个任务耗时都是相同的。</p><p>比如，系统将第一批10个任务放入后台的过程所消耗的时间 几乎可以忽略不计，也就是说这10个任务几乎可以任务是同时运行，当然也就可以认为是同时结束了，而按照刚才的分析，一个任务结束时就会向文件描述符写入空行，既然是同时结束的，那么肯定是同时写入的空行，所以下一批任务又几乎同时运行，如此循环下去的。实际应用时，肯定不是这个样子的，比如，第一个放到后台执行的任务，是最耗时间的，那他肯定就会是最后一个执行完毕。所以，实际上来说，只要有一个任务完成，那么下一个任务就可以被放到后台并发执行了。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Shell','脚本','进程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>