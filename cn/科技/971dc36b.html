<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java集合 - TreeSet详解和使用示例 | 极客快訊</title><meta property="og:title" content="Java集合 - TreeSet详解和使用示例 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f01f6ccf89994943be8d054a21c1a3fe"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/971dc36b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/971dc36b.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Java集合 - TreeSet详解和使用示例"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/971dc36b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java集合 - TreeSet详解和使用示例</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>第1部分 TreeSet介绍<br></h1><p><strong>TreeSet简介<br></strong></p><p>TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet&lt;E>, Cloneable, java.io.Serializable接口。<br>TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。<br>TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。<br>TreeSet 实现了Cloneable接口，意味着它能被克隆。<br>TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。<br>TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。<br>TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。<br>另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。</p><p><strong>TreeSet的构造函数</strong></p><pre><code>// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。TreeSet()// 创建的TreeSet包含collectionTreeSet(Collection&lt;? extends E&gt; collection)// 指定TreeSet的比较器TreeSet(Comparator&lt;? super E&gt; comparator)// 创建的TreeSet包含setTreeSet(SortedSet&lt;E&gt; set)</code></pre><p><strong>TreeSet的API</strong></p><pre><code>Collection接口：boolean       add(E object)boolean       addAll(Collection&lt;? extends E&gt; collection)void           clear()boolean        contains(Object object)boolean        isEmpty()boolean       remove(Object object)int            size()Iterator&lt;E&gt;        iterator()SortedSet接口：E             first()E             last()E             pollFirst()E             pollLast()E             lower(E e)E             floor(E e)E             ceiling(E e)E             higher(E e)Comparator&lt;? super E&gt;   comparator()Iterator&lt;E&gt;        iterator()Iterator&lt;E&gt;        descendingIterator()NavigableSet&lt;E&gt;      descendingSet()NavigableSet&lt;E&gt;      headSet(E end, boolean endInclusive)SortedSet&lt;E&gt;       subSet(E start, E end)NavigableSet&lt;E&gt;      subSet(E start, boolean startInclusive, E end, boolean endInclusive)NavigableSet&lt;E&gt;      tailSet(E start, boolean startInclusive)新</code></pre><p><strong>说明：</strong></p><p>(01) TreeSet是有序的Set集合，因此支持add、remove、get等方法。<br>(02) 和NavigableSet一样，TreeSet的导航方法大致可以区分为两类，一类时提供元素项的导航方法，返回某个元素；另一类时提供集合的导航方法，返回某个集合。<br>lower、floor、ceiling 和 higher 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。</p><h1 class=pgc-h-arrow-right>第2部分 TreeSet数据结构</h1><p><strong>TreeSet的继承关系</strong></p><pre><code>java.lang.Object  ↳   java.util.AbstractCollection&lt;E&gt;     ↳   java.util.AbstractSet&lt;E&gt;        ↳   java.util.TreeSet&lt;E&gt; public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;      implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{}</code></pre><p>TreeSet与Collection关系如下图：</p><p><br></p><div class=pgc-img><img alt="Java集合 - TreeSet详解和使用示例" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f01f6ccf89994943be8d054a21c1a3fe><p class=pgc-img-caption></p></div><p>从图中可以看出：<br>(01) TreeSet继承于AbstractSet，并且实现了NavigableSet接口（扩展自SortedSet接口）。<br>(02) TreeSet的本质是一个"有序的，并且没有重复元素"的集合，它是通过TreeMap实现的。TreeSet中含有一个"NavigableMap类型的成员变量"m，而m实际上是"TreeMap的实例"。</p><h1 class=pgc-h-arrow-right>第3部分 TreeSet源码解析(基于JDK1.6.0_45)</h1><p>为了更了解TreeSet的原理，下面对TreeSet源码代码作出分析。</p><pre><code>package java.util; public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt;  implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable{  // NavigableMap对象  private transient NavigableMap&lt;E,Object&gt; m;   // TreeSet是通过TreeMap实现的，  // PRESENT是键-值对中的值。  private static final Object PRESENT = new Object();   // 不带参数的构造函数。创建一个空的TreeMap  public TreeSet() {    this(new TreeMap&lt;E,Object&gt;());  }   // 将TreeMap赋值给 "NavigableMap对象m"  TreeSet(NavigableMap&lt;E,Object&gt; m) {    this.m = m;  }   // 带比较器的构造函数。  public TreeSet(Comparator&lt;? super E&gt; comparator) {    this(new TreeMap&lt;E,Object&gt;(comparator));  }   // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中  public TreeSet(Collection&lt;? extends E&gt; c) {    this();    // 将集合c中的元素全部添加到TreeSet中    addAll(c);  }   // 创建TreeSet，并将s中的全部元素都添加到TreeSet中  public TreeSet(SortedSet&lt;E&gt; s) {    this(s.comparator());    addAll(s);  }   // 返回TreeSet的顺序排列的迭代器。  // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器  public Iterator&lt;E&gt; iterator() {    return m.navigableKeySet().iterator();  }   // 返回TreeSet的逆序排列的迭代器。  // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器  public Iterator&lt;E&gt; descendingIterator() {    return m.descendingKeySet().iterator();  }   // 返回TreeSet的大小  public int size() {    return m.size();  }   // 返回TreeSet是否为空  public boolean isEmpty() {    return m.isEmpty();  }   // 返回TreeSet是否包含对象(o)  public boolean contains(Object o) {    return m.containsKey(o);  }   // 添加e到TreeSet中  public boolean add(E e) {    return m.put(e, PRESENT)==null;  }   // 删除TreeSet中的对象o  public boolean remove(Object o) {    return m.remove(o)==PRESENT;  }   // 清空TreeSet  public void clear() {    m.clear();  }   // 将集合c中的全部元素添加到TreeSet中  public boolean addAll(Collection&lt;? extends E&gt; c) {    // Use linear-time version if applicable    if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp;      c instanceof SortedSet &amp;&amp;      m instanceof TreeMap) {      SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c;      TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m;      Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator();      Comparator&lt;? super E&gt; mc = map.comparator();      if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) {        map.addAllForTreeSet(set, PRESENT);        return true;      }    }    return super.addAll(c);  }   // 返回子Set，实际上是通过TreeMap的subMap()实现的。  public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,                 E toElement,  boolean toInclusive) {    return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive,                    toElement,  toInclusive));  }   // 返回Set的头部，范围是：从头部到toElement。  // inclusive是是否包含toElement的标志  public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {    return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive));  }   // 返回Set的尾部，范围是：从fromElement到结尾。  // inclusive是是否包含fromElement的标志  public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {    return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive));  }   // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。  public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {    return subSet(fromElement, true, toElement, false);  }   // 返回Set的头部，范围是：从头部到toElement(不包括)。  public SortedSet&lt;E&gt; headSet(E toElement) {    return headSet(toElement, false);  }   // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。  public SortedSet&lt;E&gt; tailSet(E fromElement) {    return tailSet(fromElement, true);  }   // 返回Set的比较器  public Comparator&lt;? super E&gt; comparator() {    return m.comparator();  }   // 返回Set的第一个元素  public E first() {    return m.firstKey();  }   // 返回Set的最后一个元素  public E first() {  public E last() {    return m.lastKey();  }   // 返回Set中小于e的最大元素  public E lower(E e) {    return m.lowerKey(e);  }   // 返回Set中小于/等于e的最大元素  public E floor(E e) {    return m.floorKey(e);  }   // 返回Set中大于/等于e的最小元素  public E ceiling(E e) {    return m.ceilingKey(e);  }   // 返回Set中大于e的最小元素  public E higher(E e) {    return m.higherKey(e);  }   // 获取第一个元素，并将该元素从TreeMap中删除。  public E pollFirst() {    Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();    return (e == null)? null : e.getKey();  }   // 获取最后一个元素，并将该元素从TreeMap中删除。  public E pollLast() {    Map.Entry&lt;E,?&gt; e = m.pollLastEntry();    return (e == null)? null : e.getKey();  }   // 克隆一个TreeSet，并返回Object对象  public Object clone() {    TreeSet&lt;E&gt; clone = null;    try {      clone = (TreeSet&lt;E&gt;) super.clone();    } catch (CloneNotSupportedException e) {      throw new InternalError();    }     clone.m = new TreeMap&lt;E,Object&gt;(m);    return clone;  }   // java.io.Serializable的写入函数  // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中  private void writeObject(java.io.ObjectOutputStream s)    throws java.io.IOException {    s.defaultWriteObject();     // 写入比较器    s.writeObject(m.comparator());     // 写入容量    s.writeInt(m.size());     // 写入“TreeSet中的每一个元素”    for (Iterator i=m.keySet().iterator(); i.hasNext(); )      s.writeObject(i.next());  }   // java.io.Serializable的读取函数：根据写入方式读出  // 先将TreeSet的“比较器、容量、所有的元素值”依次读出  private void readObject(java.io.ObjectInputStream s)    throws java.io.IOException, ClassNotFoundException {    // Read in any hidden stuff    s.defaultReadObject();     // 从输入流中读取TreeSet的“比较器”    Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject();     TreeMap&lt;E,Object&gt; tm;    if (c==null)      tm = new TreeMap&lt;E,Object&gt;();    else      tm = new TreeMap&lt;E,Object&gt;(c);    m = tm;     // 从输入流中读取TreeSet的“容量”    int size = s.readInt();     // 从输入流中读取TreeSet的“全部元素”    tm.readTreeSet(size, s, PRESENT);  }   // TreeSet的序列版本号  private static final long serialVersionUID = -2479143000061671589L;}</code></pre><p><strong>总结：</strong></p><p>(01) TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。<br>(02) TreeSet是非线程安全的。<br>(03) TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。</p><h1 class=pgc-h-arrow-right>第4部分 TreeSet遍历方式</h1><p><strong>4.1 Iterator顺序遍历</strong></p><pre><code>for(Iterator iter = set.iterator(); iter.hasNext(); ) {  iter.next();} </code></pre><p><strong>4.2 Iterator逆序遍历</strong></p><pre><code>// 假设set是TreeSet对象for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) {  iter.next();}</code></pre><p><strong>4.3 for-each遍历HashSet</strong></p><pre><code>// 假设set是TreeSet对象，并且set中元素是String类型String[] arr = (String[])set.toArray(new String[0]);for (String str:arr)  System.out.printf("for each : %s\n", str);</code></pre><p>TreeSet不支持快速随机遍历，只能通过迭代器进行遍历！</p><p>TreeSet遍历测试程序如下：</p><pre><code>import java.util.*; /** * @desc TreeSet的遍历程序 * * @author skywang * @email kuiwu-wang@163.com */public class TreeSetIteratorTest {   public static void main(String[] args) {    TreeSet set = new TreeSet();    set.add("aaa");    set.add("aaa");    set.add("bbb");    set.add("eee");    set.add("ddd");    set.add("ccc");     // 顺序遍历TreeSet    ascIteratorThroughIterator(set) ;    // 逆序遍历TreeSet    descIteratorThroughIterator(set);    // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组    foreachTreeSet(set);  }   // 顺序遍历TreeSet  public static void ascIteratorThroughIterator(TreeSet set) {    System.out.print("\n ---- Ascend Iterator ----\n");    for(Iterator iter = set.iterator(); iter.hasNext(); ) {      System.out.printf("asc : %s\n", iter.next());    }  }   // 逆序遍历TreeSet  public static void descIteratorThroughIterator(TreeSet set) {    System.out.printf("\n ---- Descend Iterator ----\n");    for(Iterator iter = set.descendingIterator(); iter.hasNext(); )      System.out.printf("desc : %s\n", (String)iter.next());  }   // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组  private static void foreachTreeSet(TreeSet set) {    System.out.printf("\n ---- For-each ----\n");    String[] arr = (String[])set.toArray(new String[0]);    for (String str:arr)      System.out.printf("for each : %s\n", str);  }}</code></pre><p>运行结果：</p><pre><code>---- Ascend Iterator ----asc : aaaasc : bbbasc : cccasc : dddasc : eee  ---- Descend Iterator ----desc : eeedesc : ddddesc : cccdesc : bbbdesc : aaa  ---- For-each ----for each : aaafor each : bbbfor each : cccfor each : dddfor each : eee</code></pre><h1 class=pgc-h-arrow-right>第5部分 TreeSet示例</h1><p>下面通过实例学习如何使用TreeSet</p><pre><code>import java.util.*; /** * @desc TreeSet的API测试 * * @author skywang * @email kuiwu-wang@163.com */public class TreeSetTest {   public static void main(String[] args) {    testTreeSetAPIs();  }     // 测试TreeSet的api  public static void testTreeSetAPIs() {    String val;     // 新建TreeSet    TreeSet tSet = new TreeSet();    // 将元素添加到TreeSet中    tSet.add("aaa");    // Set中不允许重复元素，所以只会保存一个“aaa”    tSet.add("aaa");    tSet.add("bbb");    tSet.add("eee");    tSet.add("ddd");    tSet.add("ccc");    System.out.println("TreeSet:"+tSet);     // 打印TreeSet的实际大小    System.out.printf("size : %d\n", tSet.size());     // 导航方法    // floor(小于、等于)    System.out.printf("floor bbb: %s\n", tSet.floor("bbb"));    // lower(小于)    System.out.printf("lower bbb: %s\n", tSet.lower("bbb"));    // ceiling(大于、等于)    System.out.printf("ceiling bbb: %s\n", tSet.ceiling("bbb"));    System.out.printf("ceiling eee: %s\n", tSet.ceiling("eee"));    // ceiling(大于)    System.out.printf("higher bbb: %s\n", tSet.higher("bbb"));    // subSet()    System.out.printf("subSet(aaa, true, ccc, true): %s\n", tSet.subSet("aaa", true, "ccc", true));    System.out.printf("subSet(aaa, true, ccc, false): %s\n", tSet.subSet("aaa", true, "ccc", false));    System.out.printf("subSet(aaa, false, ccc, true): %s\n", tSet.subSet("aaa", false, "ccc", true));    System.out.printf("subSet(aaa, false, ccc, false): %s\n", tSet.subSet("aaa", false, "ccc", false));    // headSet()    System.out.printf("headSet(ccc, true): %s\n", tSet.headSet("ccc", true));    System.out.printf("headSet(ccc, false): %s\n", tSet.headSet("ccc", false));    // tailSet()    System.out.printf("tailSet(ccc, true): %s\n", tSet.tailSet("ccc", true));    System.out.printf("tailSet(ccc, false): %s\n", tSet.tailSet("ccc", false));      // 删除“ccc”    tSet.remove("ccc");    // 将Set转换为数组    String[] arr = (String[])tSet.toArray(new String[0]);    for (String str:arr)      System.out.printf("for each : %s\n", str);     // 打印TreeSet    System.out.printf("TreeSet:%s\n", tSet);     // 遍历TreeSet    for(Iterator iter = tSet.iterator(); iter.hasNext(); ) {      System.out.printf("iter : %s\n", iter.next());    }     // 删除并返回第一个元素    val = (String)tSet.pollFirst();    System.out.printf("pollFirst=%s, set=%s\n", val, tSet);     // 删除并返回最后一个元素    val = (String)tSet.pollLast();    System.out.printf("pollLast=%s, set=%s\n", val, tSet);     // 清空HashSet    tSet.clear();     // 输出HashSet是否为空    System.out.printf("%s\n", tSet.isEmpty()?"set is empty":"set is not empty");  }}</code></pre><p>运行结果：</p><pre><code>TreeSet:[aaa, bbb, ccc, ddd, eee]size : 5floor bbb: bbblower bbb: aaaceiling bbb: bbbceiling eee: eeehigher bbb: cccsubSet(aaa, true, ccc, true): [aaa, bbb, ccc]subSet(aaa, true, ccc, false): [aaa, bbb]subSet(aaa, false, ccc, true): [bbb, ccc]subSet(aaa, false, ccc, false): [bbb]headSet(ccc, true): [aaa, bbb, ccc]headSet(ccc, false): [aaa, bbb]tailSet(ccc, true): [ccc, ddd, eee]tailSet(ccc, false): [ddd, eee]for each : aaafor each : bbbfor each : dddfor each : eeeTreeSet:[aaa, bbb, ddd, eee]iter : aaaiter : bbbiter : ddditer : eeepollFirst=aaa, set=[bbb, ddd, eee]pollLast=eee, set=[bbb, ddd]set is empty</code></pre><p>以上就是本文的全部内容，希望对大家的学习有所帮助，也希望大家多多支持脚本之家。</p><p>-------------------------------------------</p><p>转载自：https://www.jb51.net/article/113733.htm</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'示例','Java','TreeSet'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>