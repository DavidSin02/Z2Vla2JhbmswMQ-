<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核 | 极客快訊</title><meta property="og:title" content="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/108e64968ca9453c9f0b9ea5b2818a66"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9749d92.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9749d92.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9749d92.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9749d92.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>上一文 讨论了FIR滤波器的结构以及使用Python从两个方面（循环运算和矩阵运算）实现FIR，而文中提到的单片机，只需要按照循环运算的方法就可以实现FIR滤波器。</p><p>所以，单片机实现FIR滤波器并不复杂；奈何我手痒了，想舍弃掉FIR IP核，用Verilog自己写一个FIR。不知道大家有没有这样手痒的感觉，如果有，跟随这篇文章一起来，看完记得点赞。</p><p>本文内容涉及Verilog的语法：function，generate for，generate if， readmemb,readmemh；部分Python语法以及学习Verilog）及计算机数值表示规则。</p><hr><h3 class=pgc-h-arrow-right>设计思想</h3><p>首先需要把FIR最基本的结构实现，也就是每个FIR抽头的数据与其抽头系数相乘这个操作。由顶层文件对这个基本模块进行多次调用。</p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/108e64968ca9453c9f0b9ea5b2818a66><p class=pgc-img-caption></p></div><p>由于FIR抽头系数是中心对称的，为了减少乘法在FPGA内的出现，每个基本结构同时会输入两个信号，也是关于中心对称的。</p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63eb6b78c1284068853043555eec08d7><p class=pgc-img-caption></p></div><p><br></p><p>此外，为了防止后续相加的过程引起符号位溢出，FIR基本模块需要对乘法结果进行符号位扩展。</p><p>扩展完成后，如果同时对这些（71个）加权结果相加，肯定会使得系统运行速率上不去，而且设计的比较死板。这里需要引入流水线操作；何为流水线操作，简单地说，本来你一个人承担一桌菜，你需要洗菜，切菜，炒菜，装盘，上桌，不仅十分麻烦而且很耽误时间；这个时候有人过来帮你，一个人洗菜，一个人切菜，一个人炒菜，一个人装盘，你负责上桌，虽然费了些人，但是每个人的任务都比较轻松所以做事速度也很快，这就是流水线操作，把一件很复杂的事情划分成N个小事，虽然牺牲了面积但换取了系统运行时钟的提升。</p><h3 class=pgc-h-arrow-right>前期准备</h3><p>除了Verilog模块，我们还有几样东西需要准备。首先，需要将FIR抽头系数定点化，上一文使用的FIR抽头系数都是很小的浮点数，为此，我们直接对每个系数乘以2的15次幂，然后取整数，舍去小数位，设定FIR抽头系数位宽为16bit；因为系数本身比较小，不担心会溢出。注意，这里抽头系数的位宽尽量不超过信号位宽，否则可能会有问题。</p><p>为了方便多个模块同时调用FIR系数，这里使用Python直接将定点化的系数生成为function，输入为index，需要第N阶的FIR系数，就调用function，输入参数为N，输出为定点化的系数。</p><p><strong>所谓定点化，这里使用的方法十分粗暴，直接对所有浮点数，乘以一个2的n次幂。然后对参数向下取整，舍弃小数位。</strong></p><p>FIR浮点系数转化为定点数并生成function的代码如下：</p><pre><code>def coef2function(filename, exp, gain):    # :param filename: FIR抽头系数文件名    # :param exp:      浮点数转定点数的位宽    # :param gain:     浮点数整体的增益，增益为power(2, gain)    # :return:    	coef = set_coef(filename)    	with open('fir_coef.v', 'w') as f:		f.write('function [{}:0] get_coef;\n'.format(exp-1))        		f.write('input [7:0] index;\n')        		f.write('case (index)\n')        		for i in range(len(coef)):                	f.write('{}: get_coef = {};\n'.format(i,int(np.floor(coef[i] * np.power(2,gain)))))        		f.write('default: get_coef = 0;\n')        		f.write('endcase\nendfunction')</code></pre><p>转换生成的function示例如下：</p><pre><code>function [15:0] get_coef;input [7:0] index;case (index)0: get_coef = 0;1: get_coef = 0;2: get_coef = 2;3: get_coef = 10;...69: get_coef = 10;70: get_coef = 2;71: get_coef = 0;72: get_coef = 0;default: get_coef = 0;endcaseendfunction</code></pre><p>这样，当多个基本模块并行运行时，每个模块的系数可以通过调用function获取对应的参数。</p><p><br></p><p>仿真需要有信号源供FIR滤波，所以直接将仿真用的信号源定点化；<strong>因为Testbench中使用readmemh或者readmemb读取txt文档数据，只能读取二进制或16进制数据，所以需要对数据进行二进制或16进制转换。</strong></p><p>信号源选取上一文的信号源，由于该信号源最大值为3，设定信号源的位宽为16位，为防止数据溢出，信号源整体乘以2的12次幂，然后取整舍去小数位。为了方便后续转二进制，这里需要将数据由16bit有符号转为16bit无符号；转换的过程为，如果data[i]小于0，直接设定data[i] = 2^16 + data[i]。然后使用“{{:0>16b}}”.format(data[i])转换为16bit二进制，存入cos.txt。</p><p>浮点数转换定点数并转换二进制数据存入txt转换代码如下：</p><pre><code>def float2fix_point(data, exp, gain, size):    # '''    # :param data: 信号源数据    # :param exp:  浮点数转定点数的位宽    # :param gain: 浮点数整体乘以增益，增益为power(2,15)    # :param size: 转换多少点数    # :return:    # '''    	if size &gt; len(data):          	print("error, size &gt; len(data)")        		return    	data = [int(np.floor(data[i] * np.power(2, gain) )) for i in range(size)]      fmt = '{{:0&gt;{}b}}'.format(exp)    	n = np.power(2, exp)    	for i in range(size):          	if data[i] &gt; (n //2 - 1):                	print("error")        		if data[i] &lt; 0:                	d = n + data[i]        		else:                	d = data[i]        		data[i] = fmt.format(d)    	np.savetxt('cos.txt', data, fmt='%s')</code></pre><p><br></p><h3 class=pgc-h-arrow-right>实现方法</h3><p>为了方便看示例代码，这里假定信号位宽DATA_BITS为16，系数位宽为COEF_BITS为16，扩展符号位宽EXTEND_BITS为5， 阶数FIR_ORDER为72。</p><p>设计思路还是从底层开始设计，首先需要实现FIR的基本模块。前面提到，为了节省乘法器，每个模块输入两个信号和一个FIR抽头系数，两个参数相加，相加结果直接乘以系数，最后做符号位扩展，防止后续操作导致符号位溢出。</p><p>fir_base.v 主要代码：</p><pre><code>reg signed [DATA_BITS + COEF_BITS - 1:0]  data_mult;// 因为FIR系数是中心对称的，所以直接把中心对称的数据相加乘以系数// 相加符号位扩展一位wire signed [DATA_BITS:0]  data_in ;assign data_in = {data_in_A[DATA_BITS-1], data_in_A} + {data_in_B[DATA_BITS-1], data_in_B};// 为了防止后续操作导致符号位溢出，这里扩展符号位，设计位操作知识assign data_out = {{EXTEND_BITS{data_mult[DATA_BITS + COEF_BITS - 1]}},data_mult };always @(posedge clk or posedge rst) begin  	if (rst) begin      	// reset      	fir_busy  &lt;=  1'b0;    		data_mult  &lt;=   0 ;    		output_vld  &lt;=  1'b0;  	end    else if (en) begin          //如果coef为0，不需要计算直接得0      	data_mult  &lt;=  coef != 0 ? data_in * coef : 0;    		output_vld  &lt;=  1'b1;  	end    else begin      	data_mult  &lt;=  'd0;    		output_vld  &lt;=  1'b0;  	endend</code></pre><p><br></p><p>完成了基本模块后，顶层模块就是调用基本模块，然后对运算结果进行相加操作。但这里需要注意，顶层首先需要73个16bit的寄存器，用来保存传入的信号并实现每时钟周期上升沿，73个数据整体前移；学过数据结构的同学可以把这个想象成队列结构，每次信号上升沿时，队首信号出队，队尾补进新的信号。</p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8624f085473f4f98af066bf031f48ba2><p class=pgc-img-caption></p></div><p><br></p><p>实现方法如下：</p><pre><code>// FIR输入数据暂存寄存器组reg signed 	[DATA_BITS-1:0]	data_tmp [FIR_ORDER:0] ;always @(posedge clk or posedge rst) begin	if (rst) begin		// reset		data_tmp[0] &lt;=	0;	end	else if (data_in_vld) begin		data_tmp[0] &lt;=	data_in;	endendgenerate	genvar j;    for (j = 1; j &lt;= FIR_ORDER; j = j + 1)	begin: fir_base	//这里无法兼顾0，FIR_HALF_ORDER    always @(posedge clk or posedge rst) begin    if (rst) begin        // reset        data_tmp[j] &lt;=	0;    end    else if (data_in_vld) begin        data_tmp[j] &lt;=	data_tmp[j-1];    end	endendgenerate</code></pre><p><br></p><p>这里实现了从0-72共73个寄存器，使用了Verilog的类似二维数组的寄存器定义用法。可以从代码看到，0号data_tmp过于特殊，需要保存输入的信号，而其他data_tmp直接使用generate for语法实现前面提到的“队列”功能。generate for语法是可以综合的，<strong>其中for循环的参数必须是常数</strong>，其作用就是直接在电路上覆制循环体的内容。对于像这样需要规律性地赋值操作很方便，下面还会出现generate for语法。</p><p><br></p><p>寄存器组的问题解决后，需要与FIR参数进行乘加，这里同样适用generate for语句简化设计：</p><pre><code>localparam FIR_HALF_ORDER = FIR_ORDER / 2;  //36wire signed [OUT_BITS-1:0]	data_out_tmp [FIR_HALF_ORDER:0] ;// FIR输出数据后流水线相加的中间变量，多出部分变量，防止下一级相加过程中index越界reg signed 	[OUT_BITS-1:0]	dat_out_reg  [FIR_HALF_ORDER+4:0] ; 	//40-0always @(posedge clk or posedge rst) begin	if (rst) begin		// reset		dat_out_reg[FIR_HALF_ORDER] &lt;= 0;	end	else if (output_vld_tmp[FIR_HALF_ORDER]) begin		dat_out_reg[FIR_HALF_ORDER] &lt;= data_out_tmp[FIR_HALF_ORDER];	endendfir_base #(	.DATA_BITS(DATA_BITS),	.COEF_BITS(COEF_BITS),	.EXTEND_BITS(EXTEND_BITS)	)fir_inst_FIR_HALF_ORDER(	.clk		(clk),	.rst		(rst),    .en			(data_in_vld),    .data_in_A	(data_tmp[FIR_HALF_ORDER]),    .data_in_B	(12'd0),    .coef		(get_coef(FIR_HALF_ORDER)),    .fir_busy	(),    .data_out	(data_out_tmp[FIR_HALF_ORDER]),    .output_vld	(output_vld_tmp[FIR_HALF_ORDER])    );    generate	genvar j;	for (j = 1; j &lt; FIR_HALF_ORDER; j = j + 1)	begin: fir_base	fir_base	#(	.DATA_BITS(DATA_BITS),	.COEF_BITS(COEF_BITS),	.EXTEND_BITS(EXTEND_BITS)	)	fir_inst_NORMAL	(		.clk		(clk),		.rst		(rst),				.en			(data_in_vld),		.data_in_A	(data_tmp[j]),		.data_in_B	(data_tmp[FIR_ORDER-j]),		.coef		(get_coef(j)),				.fir_busy	(),		.data_out	(data_out_tmp[j]),		.output_vld	(output_vld_tmp[j])	);	always @(posedge clk or posedge rst) begin		if (rst) begin			// reset			dat_out_reg[j] &lt;= 0;		end		else if (output_vld_tmp[j]) begin			dat_out_reg[j] &lt;= data_out_tmp[j];		end	endendgenerate</code></pre><p>首先由于中心点（第36阶）的系数是只乘中心点，并不像其他系数可以传入关于中心对称的两个信号。所以FIR_HALF_ORDER需要单独例化。同样，dat_out_reg也需要单独复制；其他的信号在generate for循环体完成操作，由于0号系数在阶数为偶数的情况下为0，这里跳过0号系数直接从1号系数开始，所以for循环是从1 - FIR_HALF_ORDER。</p><p><br></p><p>加权结果出来后，需要对结果相加，为了提升系统运行速率，这里采用三级流水线操作。每次进行4位数据相加传递给下一级流水线，所以示例代码里FIR最高阶数为4 * 4 * 4 * 2 = 128。</p><p>流水线操作过程如下：</p><pre><code>// 流水线第一级相加，计算公式ceil(N/4)localparam FIR_ADD_ORDER_ONE = (FIR_HALF_ORDER + 3) / 4; //// 流水线第二级相加，计算公式ceil(N/4)localparam FIR_ADD_ORDER_TWO = (FIR_ADD_ORDER_ONE + 3) / 4; //3reg signed [OUT_BITS-1:0]	dat_out_A [FIR_ADD_ORDER_ONE+3:0] ;	//12-0reg signed [OUT_BITS-1:0]	dat_out_B [FIR_ADD_ORDER_TWO+3:0] ;	//6-0// 这些多余的reg直接设为0就可以了always @ (posedge clk) begin	dat_out_reg[FIR_HALF_ORDER+1] = 0;	dat_out_reg[FIR_HALF_ORDER+2] = 0;	dat_out_reg[FIR_HALF_ORDER+3] = 0;	dat_out_reg[FIR_HALF_ORDER+4] = 0;	dat_out_A[FIR_ADD_ORDER_ONE] = 0;	dat_out_A[FIR_ADD_ORDER_ONE+1] = 0;	dat_out_A[FIR_ADD_ORDER_ONE+2] = 0;	dat_out_A[FIR_ADD_ORDER_ONE+3] = 0;	dat_out_B[FIR_ADD_ORDER_TWO] = 0;	dat_out_B[FIR_ADD_ORDER_TWO + 1] = 0;	dat_out_B[FIR_ADD_ORDER_TWO + 2] = 0;	dat_out_B[FIR_ADD_ORDER_TWO + 3] = 0;end// 判定所有FIR_BASE模块完成转换assign data_out_vld = (&amp;output_vld_tmp[FIR_HALF_ORDER:1] == 1'b1) ? 1'b1 : 1'b0;//最后一级流水线always @(posedge clk or posedge rst) begin	if (rst) begin		// reset		data_out 	&lt;=	0;	end	else if (data_out_vld) begin		data_out 	&lt;= dat_out_B[0] + dat_out_B[1] + dat_out_B[2] + dat_out_B[3];	endendgenerate	genvar j;	for (j = 1; j &lt; FIR_HALF_ORDER; j = j + 1)        	if (j &lt;= FIR_ADD_ORDER_ONE)	begin	//流水线相加 第一级	//注意j 的范围是[1,FIR_HALF_ORDER]	//所以dat_out_A[j-1]		always @(posedge clk or posedge rst) begin			if (rst) begin				// reset				dat_out_A[j-1] &lt;= 0;			end			else begin				dat_out_A[j-1] &lt;= dat_out_reg[4*j-3] + dat_out_reg[4*j-2] + dat_out_reg[4*j-1] + dat_out_reg[4*j];			end		end	end        if (j &lt;= FIR_ADD_ORDER_TWO)	begin	// 流水线相加 第二级		always @(posedge clk or posedge rst) begin			if (rst) begin				// reset				dat_out_B[j-1] &lt;= 0;			end			else begin				dat_out_B[j-1] &lt;= dat_out_A[4*j - 4] + dat_out_A[4*j- 3] + dat_out_A[4*j - 2] + dat_out_A[4*j - 1];			end		end	endend	endgenerate</code></pre><p>这里第一级，第二级流水线的循环次数采用ceil(N/4)的计算方式，也就是取比N/4大的最小整数。比如5/4 = 1.25,则ceil(1.25) = 2， 而ceil(1) = 1;</p><p>定义每级寄存器组时，会多定义4个寄存器组。并且这些寄存器永远为0，这样做的原因以第一级流水线相加举例：</p><p>看第一级流水线，假定FIR_ORDER为70，FIR_HALF_ORDER为35，FIR_ADD_ORDER_ONE为9，当j为9时，dat_out_A[8] &lt;= dat_out_reg[33] + dat_out_reg[34] + dat_out_reg[35] + dat_out_reg[36];</p><p>而我们在前面设计中正好定义了dat_out_reg[36]，并且它永远为0，不影响最终结果。</p><p>可以看到，第一级，第二级流水线使用generate for, if语句。如果if条件成立，if内部的电路会被描述。最后71个数据经过三级流水线相加，结果输出。</p><p>如果想要提升FIR的最高运行频率，可以把流水线级数增加，每级流水线相加改为2个或者3个。</p><p><strong>这个结构只适合FIR阶数为偶数的情况，由于最近比较忙，没有做更大的兼容性。</strong></p><h3 class=pgc-h-arrow-right>仿真结果与资源占用对比</h3><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/939bcfc5e8874f8ba18ac00fb5a68756><p class=pgc-img-caption></p></div><p><br></p><p>VCS仿真结果</p><p><br></p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b180352ee9f9454d98a23c9192e31687><p class=pgc-img-caption></p></div><p><br></p><p>FIR滤波效果，Python</p><p><br></p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/11bf493f374a46a4a050c8b3f7b0ee2d><p class=pgc-img-caption></p></div><p><br></p><p>FIR滤波效果，Verilog</p><p><br></p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c42b12e17da40a1be905685f9582d53><p class=pgc-img-caption></p></div><p><br></p><p>FIR_IMPLE的资源占用 Quartus II 13.1</p><p><br></p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0fe0cf61f9484b9191d67b9663f7898b><p class=pgc-img-caption></p></div><p><br></p><p>FIR IP核资源占用，参数相同情况下，Quartus II 13.1</p><p><br></p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75661ddeb5c345ee80c499c245cfb907><p class=pgc-img-caption></p></div><p><br></p><p>FIR_IMPLE的Fmax Quartus II 13.1</p><p><br></p><div class=pgc-img><img alt="（探讨滤波器）2. 手把手用Verilog实现FIR滤波器，非IP核" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8fd958f5dea43fd87d8d84b427e8f59><p class=pgc-img-caption></p></div><p><br></p><p>FIR IP核，Fmax， Quartus II 13.1</p><p><br></p><h3 class=pgc-h-arrow-right>提升建议：</h3><p><strong>1. 提升最高运行速率，可以增多流水线操作</strong></p><p><strong>2. 可以修改部分代码适配阶数为奇数的情况</strong></p><p>欢迎关注留言点赞收藏我，一同探讨FPGA/电子/硬件/软件。关于本文所用的资源会在评论区给出</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'探讨滤','波器','Verilog'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>