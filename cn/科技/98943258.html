<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>带你从零学大数据之Java篇第十八章：集合(Set) | 极客快訊</title><meta property="og:title" content="带你从零学大数据之Java篇第十八章：集合(Set) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/f5c0991dc0364e098d7650153308110e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/98943258.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/98943258.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/98943258.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/98943258.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/98943258.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/98943258.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/98943258.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/98943258.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="带你从零学大数据之Java篇第十八章：集合(Set)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/98943258.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>带你从零学大数据之Java篇第十八章：集合(Set)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>课程重点:</strong></p><ul><li><strong>Set的存储特点</strong></li><li><strong>数据结构-哈希表(了解)</strong></li><li><strong>数据结构-二叉树(了解)</strong></li><li><strong>TreeSet的排序去重(了解)</strong></li><li><strong>HashSet的去重</strong></li></ul><h2 class=pgc-h-arrow-right><strong>18.1. 存储特点</strong></h2><ul><li>Set集合中，没有下标的概念。</li><li>Set集合，是一个去重复的集合。 在Set集合中不会添加重复的元素的！<br>在向一个Set集合中添加元素的时候， 会先判断这个元素是否已经存在了。 如果存在， 则不再添加。</li><li>Set集合中， 数据的存储是无序的。<br>无序： 所谓的无序， 其实指的是元素的添加顺序和存储顺序是不一致的。<br>无序， 并不意味着随机！</li></ul><p>Set接口， 是继承自Collection接口的。 Set接口中的方法， 都是从Collection接口中继承下来的， 并没有添加新的方法。</p><p><strong>18.2. 哈希表</strong></p><p>Set集合的两个实现类HashSet与LinkedHashSet，底层实现都是哈希表。</p><ul><li>Hash，一般翻译做“散列”，也有直接音译为“哈希”的，它是基于快速存取的角度设计的，也是一种典型的“空间换时间”的做法。顾名思义，该数据结构可以理解为一个线性表，但是其中的元素不是紧密排列的，而是可能存在空隙。</li><li>散列表（Hash table，也叫哈希表），是根据键值码值(Key value)而直接进行访问的数据结构。也就是说，它通过把键值码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数。</li><li>Hash表的组成是”数组+链表”这些元素是按照什么样的规则存储到数组中呢。一般情况是通过hash(key)%len获得，也就是元素的key的哈希值对数组长度取模得到。</li></ul><p>比如下图哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置</p><div class=pgc-img><img alt=带你从零学大数据之Java篇第十八章：集合(Set) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f5c0991dc0364e098d7650153308110e><p class=pgc-img-caption></p></div><p><strong>18.3. 二叉树</strong></p><ul><li>二叉树是一种非常重要的数据结构，它同时具有数组和链表各自的特点：它可以像数组一样快速查找，也可以像链表一样快速添加。但是他也有自己的缺点：删除操作复杂。</li><li>二叉树：是每个结点最多有两个子树的有序树，在使用二叉树的时候，数据并不是随便插入到节点中的，一个节点的左子节点的关键值必须小于此节点，右子节点的关键值必须大于或者是等于此节点，所以又称二叉查找树、二叉排序树、二叉搜索树。</li><li>叉树遍历分为三种</li><ul><li>先序遍历<br>首先访问根，再先序遍历左子树，最后先序遍历右子树</li><li>中序遍历<br>首先中序遍历左子树，再访问根，最后中序遍历右子树</li><li>后序遍历<br>首先后序遍历左子树，再后序遍历右子树，最后访问根</li></ul></ul><div class=pgc-img><img alt=带你从零学大数据之Java篇第十八章：集合(Set) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/865f9233dfb14b34973ebe5e08b8a48b><p class=pgc-img-caption></p></div><p><strong>18.4. TreeSet的排序</strong></p><h3 class=pgc-h-arrow-right><strong>18.4.1. TreeSet的简介</strong></h3><p>TreeSet是一个Set接口的实现类，底层实现是二叉树。这样的集合，会对添加进集合的元素进行去重的处理。 同时， 这个集合会对添加进入的元素进行自动的升序排序。</p><p><strong>18.4.2. Comparable接口</strong></p><p>如果某一个类实现这个接口， 表示自己实现了一个可以和自己的对象进行大小比较的规则。 此时， 这个类的对象就可以直接存储进TreeSet集合中了。 因为此时TreeSet集合已经知道了怎么对两个这个类的对象进行大小比较。</p><pre><code>/** * @Description */public class Person implements Comparable&lt;Person&gt; {    String name;    int age;    int score;    int height;    int weight;    public Person(String name, int age, int score, int height, int weight) {        this.name = name;        this.age = age;        this.score = score;        this.height = height;        this.weight = weight;    }    @Override    public String toString() {        return "Person{" +                "name='" + name + '\'' +                ", age=" + age +                ", score=" + score +                ", height=" + height +                ", weight=" + weight +                '}';    }    /**     * 制定了大小比较的规则     * @param o 和this进行比较的Person对象     * @return 比较结果     *      &gt; 0 :   this &gt; o     *      ==0 :   this == o     *      &lt; 0 :   this &lt; o     */    @Override    public int compareTo(Person o) {        return this.age - o.age;    }}class TreeSetUsage2 {    public static void main(String[] args) {        // 1. 实例化一个TreeSet对象        TreeSet&lt;Person&gt; sets = new TreeSet&lt;&gt;();        sets.add(new Person("xiaoming", 10, 100, 165, 50));        sets.add(new Person("xiaohong", 11, 99, 164, 50));        sets.add(new Person("xiaolan", 9, 98, 164, 51));        sets.add(new Person("xiaolv", 8, 98, 166, 48));        sets.add(new Person("xiaozi", 10, 97, 159, 46));        // 2. 遍历集合        sets.forEach(System.out::println);        System.out.println(sets.size());    }}</code></pre><h3 class=pgc-h-arrow-right><strong>18.4.3. Comparator接口</strong></h3><p>在实例化TreeSet集合对象的时候，可以通过Comparator进行实例化。 此时， 这个集合有着自己的排序的依据， 与集合中存储的元素对应的类无关。 此时集合中存储的元素对应的类， 可以不实现Comparable接口， 依然可以完成排序。 即便这个类真的实现了Comparable接口， 最终的排序结果依然以构造方法中的Comparator为准。</p><pre><code>/** * @Description 通过Comparator进行比较 */public class TreeSetUsage3 {    public static void main(String[] args) {        // 1. 实例化一个TreeSet对象        //    可以通过Comparator进行TreeSet的实例化。使用指定的规则进行大小比较。        //    此时，集合中存储的元素可以不实现Comparable接口        TreeSet&lt;Person&gt; sets = new TreeSet&lt;&gt;((p1, p2) -&gt; p1.height - p2.height);        sets.add(new Person("xiaoming", 10, 100, 165, 50));        sets.add(new Person("xiaohong", 11, 99, 164, 50));        sets.add(new Person("xiaolan", 9, 98, 164, 51));        sets.add(new Person("xiaolv", 8, 98, 166, 48));        sets.add(new Person("xiaozi", 10, 97, 159, 46));        // 2. 遍历集合        sets.forEach(System.out::println);        System.out.println(sets.size());    }}</code></pre><h3 class=pgc-h-arrow-right><strong>18.4.4. Comparable与Comparator的使用场景</strong></h3><ul><li>如果这个对象， 在项目中大多数的情况下， 都采用相同的大小比较的方式。 比如： 一个Person类， 在大多数情况下， 都是按照年龄进行大小比较的。 此时就可以让Person类实现Comparable接口。</li><li>如果某一个类的对象， 在临时进行大小比较的时候， 使用的与默认的比较不一样的规则。 比如： 一个Person类， 大多数情况下， 都是使用的年龄进行大小比较的， 但是临时需要使用身高进行一次比较， 此时就可以使用 Comparator 临时完成了。 而且， Comparator的优先级要高于Comparable。</li></ul><h2 class=pgc-h-arrow-right><strong>18.5. Set集合的去重原理</strong></h2><h3 class=pgc-h-arrow-right><strong>18.5.1. HashSet & LinkedHashSet</strong></h3><div class=pgc-img><img alt=带你从零学大数据之Java篇第十八章：集合(Set) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e967ba97b92a4c93b72a9fef9778694c><p class=pgc-img-caption></p></div><p><strong>18.5.2. TreeSet</strong></p><p>无论使用Comparator还是Comparable，如果两个对象进行大小比较的结果是0， 此时代表这两个对象是相同的对象。 在TreeSet中会完成排重的处理。</p><p><strong>注意：</strong> TreeSet中元素的去重只与对象的大小比较结果有关。 与hashCode()、equals()， 没有任何关系。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'零学大数','Java','Set'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>