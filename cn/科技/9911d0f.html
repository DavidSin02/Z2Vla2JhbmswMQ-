<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>程序，进程，线程与并发和并行设计实现 | 极客快訊</title><meta property="og:title" content="程序，进程，线程与并发和并行设计实现 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/165d54ca-9361-4365-9d4b-12a56bebfc33"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9911d0f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9911d0f.html><meta property="article:published_time" content="2020-10-29T20:59:51+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:51+08:00"><meta name=Keywords content><meta name=description content="程序，进程，线程与并发和并行设计实现"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9911d0f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>程序，进程，线程与并发和并行设计实现</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=程序，进程，线程与并发和并行设计实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/165d54ca-9361-4365-9d4b-12a56bebfc33><p class=pgc-img-caption></p></div><p><br></p><h1>前言</h1><p>关于现代程序的编写一般都是基于多处理或者多内核处理器来进行的，所以多线程并发处理设计成为提高应用程序运行效率的首选，我在前面的几篇文章中都详细介绍了Java语言对于多线程并发编程设计的一些主要内容和思想，本文将从一个整体的角度来串联一下，有关程序，进程，多任务设计以及并发编程等概念，对Java多线程编程来个总结性说明。</p><h1>基础概念</h1><p>程序（program），进程（process），多任务（multitasking），顺序编程（Sequential Programming），并发编程（concrrent programming）。</p><p>我们知道程序就是使用某种特定的编程语言将一个算法表示出来。</p><p>那么进程呢，就是这段程序在操作系统上会被读取并分配了其所定义的所有系统资源而开始运行的一个实例。</p><p>通常一个进程在操作系统上运行必须有一个唯一标识符（PID），一个程序计数器（PC），包括可执行的代码片段，还有可供使用的内存地址空间，以及能够调用操作系统资源的句柄，当然这些之外还需要一个安全不受干扰的上下文环境等等。</p><p>程序计数器又被称为指令指针，它是在CPU的寄存器里维护的一个值，用来追踪CPU执行的指令地址。CPU执行完一条指令它的值会自动增加。</p><p><br></p><div class=pgc-img><img alt=程序，进程，线程与并发和并行设计实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/fccf7d8b-00c5-49b4-8566-edf0aa7f6295><p class=pgc-img-caption></p></div><p><br></p><h1>进程与线程</h1><p>我们还可以将进程理解为操作系统中一个活动单元，或者一个工作单元，一个执行单元，或者一个执行路径。</p><p>进程概念的定义能够让一个计算机系统支持多个执行单元运行。</p><p>多任务：是指操作系统能够一次执行多个任务（即多个进程）的能力。</p><p>由于CPU每次只能执行一条指令，所以在单个CPU机器上真正意义上的多任务是不能实现的。</p><p>在这种情况下，操作系统通过将单个CPU的时间分配给所有正在运行的进程，并在进程之间进行足够快的切换来实现多任务处理，从而给人一种所有进程都在同时运行的印象。</p><p>进程之间的CPU切换称为上下文切换。</p><p>在上下文切换中，正在运行的进程被停止，它的状态被保存，将要获得CPU的进程的状态被恢复，新的进程被运行。</p><p>有必要在将CPU分配给另一个进程之前保存正在运行的进程的状态，这样当这个进程再次获得CPU时，它就可以从离开的地方开始执行。</p><p>通常，进程的状态由程序计数器、进程使用的寄存器值和其他以后恢复进程所需的任何信息组成。</p><p>操作系统存储进程状态的数据结构，被称为进程控制块（PCB）。</p><p>但要注意，线程的上下文切换是相当昂贵的操作，尽量减少强制这类切换。</p><p><br></p><h1>多任务处理</h1><p>多任务处理有两种类型:协同式和抢占式。</p><p>在协同多任务处理中，正在运行的进程决定何时释放CPU，以便其他进程可以使用CPU。</p><p>在抢占式多任务处理中，操作系统为每个进程分配一个时间片。一旦一个进程用完它的时间片，它就会被抢占，操作系统就会把CPU分配给另一个进程。</p><p>在协同多任务处理中，一个进程可能长时间独占CPU，其他进程可能没有机会运行。</p><p>在抢占式多任务处理中，操作系统确保所有进程都能获取CPU时间。</p><p>UNIX,OS/2和Windows使用抢占式的多任务处理，其中Windows 3.x使用协同式多任务处理。</p><p>多任务处理是指计算机同时使用多个处理器的能力。</p><p>并行处理是系统在多个处理器上同时执行同一任务的能力。</p><p>对于并行处理，必须将任务分解为多个子任务，以便可以在多个处理器上同时执行这些子任务。</p><p>假设我们设计一个包含六条指令的程序:</p><p>Instruction-1</p><p>Instruction-2</p><p>Instruction-3</p><p>Instruction-4</p><p>Instruction-5</p><p>Instruction-6</p><p>为了完整地执行这个程序，CPU必须执行所有六条指令，假设前三条指令相互依赖，即假设Instruction-2使用Instruction-1的结果，Instruction-3使用Instruction-2的结果。</p><p>假设后三条指令也像前三条指令一样相互依赖。而前三条指令和后三条指令作为两个组，彼此不依赖。</p><p>如果我们希望执行这六个指令以获得最佳的结果该如何执行呢?</p><p>当然，最直接能想到的其中一种方法是按顺序执行它们，遵照它们出现在程序中的顺序被执行。</p><p>这样执行的话，会为我们的程序提供一个执行序列，可以看成一个进程。</p><p>当然还可以有另一种执行方法，就是按两个序列来执行。</p><p>比如执行一个序列Instruction-1, Instruction-2和 Instruction-3,同时，另一个执行序列会执行Instruction-4，Instruction-5, Instruction-6指令组。</p><p>其实我们可以看到，这两组执行序列的“执行单位”和“执行顺序”的是相同的，完全可以互换进行。</p><p>这里要注意了，由于进程也是一个执行单元。所以，这两组指令可以作为两个进程来运行，如此我们就可以以在执行过程中实现并发性。</p><p>到目前为止，请注意我们假设这两组指令是相互独立的，执行过程中是相互无干扰的。</p><p><br></p><div class=pgc-img><img alt=程序，进程，线程与并发和并行设计实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/b1e2b4e7-1b10-4c56-903b-c9a5330675a2><p class=pgc-img-caption></p></div><p><br></p><h1>进程间通信</h1><p>这时我们要问了，如果这两组指令访问一个共享内存会怎样?</p><p>或者，当这两组指令完成运行时，我们需要合并这两组指令的结果来计算最终结果?</p><p>首先要注意，由于进程在运行时通常不允许访问另一个进程的地址空间。</p><p>进程间的通信必须必须使用诸如socket、管道等进程间通信设施进行交互。</p><p>当多个进程需要通信或共享资源时，进程的本质是一个独立于其他进程运行的代码片段，所以可能会造成问题。</p><p>所有现代操作系统都允许我们在一个进程中创建多个执行单元来解决进程间无法通信这个问题，其中所有执行单元都可以共享分配给该进程的地址空间和资源。</p><h1>关于线程</h1><p>进程中的每个执行单元称为<strong>线程</strong>，即CPU每次可执行处理的单位。</p><p>我们知道，我们编写一段代码来解决一个问题，其实就是设计一段程序，让其在操作系统上运行为一个进程，该进程至少有一个线程，这就是我们的主线程。Java编程里的Main函数启用该进程。当然如果需要通过复杂步骤来解决问题，在可以为该进程创建多个线程。</p><p>通常一个进程可以创建的最大线程数由操作系统及其可用的资源数决定。前面我在多篇文章中专门对这个问题进行了讨论，这里就不再赘述了。</p><p>一个进程中的所有线程共享该线程管理的所有资源，包括分配给该进程的内存地址空间，同一进程中的所有线程可以很容易地相互通信，因为它们在相同的进程中执行操作，并且共享相同的内存。</p><p><br></p><div class=pgc-img><img alt=程序，进程，线程与并发和并行设计实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/62496019-75d9-41c9-bfd7-db7971349f59><p class=pgc-img-caption></p></div><p><br></p><p>由于一个进程中的每个线程独立于同一进程中的其他线程运行，所以每个线程会独自维护两样东西:</p><p><strong>程序计数器</strong>和<strong>堆栈</strong>。</p><p>程序计数器让线程跟踪它当前正在执行的指令。</p><p>因为进程中的每个线程可能同时执行不同的指令，所以必须为每个线程维护单独的程序计数器。</p><p>每个线程都维护自己的堆栈来存储本地变量的值。</p><p>一个线程还可以维护它的私有内存，即使这些内存在同一个进程中它们也不能与其他线程共享私有内存。</p><p>线程维护的私有内存称为<strong>线程本地存储(TLS)</strong>。</p><p>其实现在所有的操作系统中，线程都是CPU调度执行的单位，而不是进程。也就是说CPU调度的不是进程，而是以线程为操作执行单位的。</p><p>所以，我们可以讲CPU的上下文切换都是发生在线程之间的。</p><p>当然，进程也存在着在CPU上的运行切换，比如我们给某个程序以焦点，或者激活它。</p><p>与进程之间的上下文切换相比，线程之间的上下文切换成本更低。</p><p>由于易于在进程内的线程之间进行通信、共享资源以及更便宜的上下文切换，所以最好将程序拆分为多个线程，而不是多个进程。</p><p>有时线程也被称为轻量级进程。如前所述，带有六条指令的程序也可以在一个进程中分成两个线程。</p><p>在多处理器机器上，一个进程的多个线程可能被调度在不同的处理器上，从而提供了一个程序的真正的并发执行。</p><p>所以我们可以将进程和线程之间的关系视为：</p><pre>进程 = 地址空间 + 计算资源 + 线程</pre><p>线程是进程内的执行单元，它们维护自己独特的程序计数器和堆栈或者叫私有内存空间，这些线程共享进程的地址空间和所拥有管理的资源。</p><p>每个线程都可以被单独安排在一个可用的CPU上执行。</p><p><br></p><h1>总结</h1><p>由于现在Java的高并发应用程序编写，需要对应用程序，进程，线程，并发和并行应用程序等概念有一个准确的理解，才能在程序设计实现过程中，准确的把握线程的应用，以及线程之间通信方式的选择，才能更好的理解JDK提供的并发线程池的设计理念和用途。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'进程','线程','并行'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/79e23cb7.html alt=如何理解：程序、进程、线程、并发、并行、高并发？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b101e22357854a56abf29c0745b5d9c9 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/79e23cb7.html title=如何理解：程序、进程、线程、并发、并行、高并发？>如何理解：程序、进程、线程、并发、并行、高并发？</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/b97e222b.html alt=进程、线程、并行与并发 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e04293de8fb49f19388e78a9812cce4 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/b97e222b.html title=进程、线程、并行与并发>进程、线程、并行与并发</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>