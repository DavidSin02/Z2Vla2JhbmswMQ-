<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>网络通信3：HTTP实现文本传输 | 极客快訊</title><meta property="og:title" content="网络通信3：HTTP实现文本传输 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9940ac4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9940ac4.html><meta property="article:published_time" content="2020-10-29T21:04:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:30+08:00"><meta name=Keywords content><meta name=description content="网络通信3：HTTP实现文本传输"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9940ac4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>网络通信3：HTTP实现文本传输</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>HTTP协议即超文本传送协议(Hypertext Transfer Protocol )，是Web联网的基础，HTTP协议是建立在TCP协议之上的一种应用。由于HTTP在每次请求结束后都会主动释放连接，因此HTTP连接是一种短连接。HTTP遵循请求（Request）/应答（Response）模型。所以一定需要实现请求(Gk8HttpRequest)。同时需要实现返回(Gk8HttpResponse)。在游戏研发编程中HTTP请求类型常用的就是GET和POST。框架设计中就需要实现完成HTTP请求和返回的Gk8HttpClient类。HTTP不管是文本传输还是二进制传输Gk8HttpClient类都能兼容完成响应的功能。HTTP文本传输方便简洁。实现轻量级通信的最佳方式。</p><p>libCurl作为是一个多协议的便于客户端使用的URL传输库，基于C语言，提供C语言的API接口。底层通信都是使用libCurl库来完成。具体可找相关资料和参阅相关代码。C语言封装开发的优势就是支持跨平台。Windows平台，安卓平台，IOS平台。跨平台迁移代码无需再次开发。一劳永逸的解决通信问题。为了方便开发时HTTP并发和回调。又实现了Gk8HttpServlet类(httpnet目录中)。高度封装的代码目的就是易于理解便于使用。</p><p>C++实现网络HTTP请求类：Gk8HttpRequest.h</p><pre><code>&nbsp;#ifndef __GK8HTTPREQUEST_H__&nbsp;#define __GK8HTTPREQUEST_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;Gk8BaseObj.h&#34;&nbsp;#include &#34;Gk8ByteMaker.h&#34;&nbsp;#include &#34;Gk8Str.h&#34;&nbsp;​&nbsp;typedef GK8_VOID (Gk8BaseObj::*HTTPREQUEST_CALLBACK_FUN)(GK8_LPVOID pHttpResponse);&nbsp;​&nbsp;class Gk8HttpRequest&nbsp;{&nbsp;public:&nbsp;    //[定义HTTP请求类型]&nbsp;    typedef enum&nbsp;    {&nbsp;        kHttpGet,&nbsp;        kHttpPost,&nbsp;        kHttpUnkown,&nbsp;    }HttpRequestType;&nbsp;​&nbsp;protected:&nbsp;    HttpRequestType m_eRequestType;         //[HTTP请求类型]&nbsp;    Gk8Str m_sHttpUrl;                      //[HTTP请求地址]&nbsp;    Gk8ByteMaker m_iRequestData;            //[HTTP请求数据]&nbsp;    Gk8BaseObj* m_pTarget;                  //[HTTP请求回调目标对象]&nbsp;    HTTPREQUEST_CALLBACK_FUN m_pSelector;   //[HTTP请求回调函数]&nbsp;public:&nbsp;    Gk8HttpRequest()&nbsp;    {&nbsp;        m_eRequestType=kHttpUnkown;&nbsp;        m_sHttpUrl.Empty();&nbsp;        m_iRequestData.Destroy();&nbsp;        m_pTarget=NULL;&nbsp;        m_pSelector=NULL;&nbsp;    };&nbsp;​&nbsp;    virtual ~Gk8HttpRequest()&nbsp;    {&nbsp;        ClearRequestData();&nbsp;    };&nbsp;    inline GK8_VOID ClearRequestData()&nbsp;    {&nbsp;        m_iRequestData.Destroy();&nbsp;    }&nbsp;    inline GK8_VOID SetRequestType(HttpRequestType eRequestType)&nbsp;    {&nbsp;        m_eRequestType=eRequestType;&nbsp;    };&nbsp;​&nbsp;    inline HttpRequestType GetRequestType()&nbsp;    {&nbsp;        return m_eRequestType;&nbsp;    };&nbsp;​&nbsp;    inline GK8_VOID SetHttpUrl(GK8_LPCSTR lpHttpUrl)&nbsp;    {&nbsp;        m_sHttpUrl=lpHttpUrl;&nbsp;    };&nbsp;​&nbsp;    inline GK8_LPCSTR GetHttpUrl()&nbsp;    {&nbsp;        return m_sHttpUrl;&nbsp;    };&nbsp;​&nbsp;    inline GK8_VOID SetRequestData(Gk8ByteMaker* pRequestData)&nbsp;    {&nbsp;        pRequestData-&gt;ShiftTo(m_iRequestData);&nbsp;    };&nbsp;​&nbsp;    inline Gk8ByteMaker* GetRequestData()&nbsp;    {&nbsp;        return &m_iRequestData;&nbsp;    }&nbsp;​&nbsp;    inline GK8_INT GetRequestDataSize()&nbsp;    {&nbsp;        return m_iRequestData.GetStreamSize();&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetResponseCallBack(Gk8BaseObj* pTarget,HTTPREQUEST_CALLBACK_FUN pSelector)&nbsp;    {&nbsp;        m_pTarget=pTarget;&nbsp;        m_pSelector=pSelector;&nbsp;    }&nbsp;​&nbsp;    inline Gk8BaseObj* GetTarget()&nbsp;    {&nbsp;        return m_pTarget;&nbsp;    }&nbsp;​&nbsp;    inline HTTPREQUEST_CALLBACK_FUN GetSelector()&nbsp;    {&nbsp;        return m_pSelector;&nbsp;    }&nbsp;};&nbsp;#endif</code></pre><p>C++实现网络HTTP返回类：Gk8HttpResponse.h</p><pre><code>&nbsp;#ifndef __GK8HTTPRESPONSE_H__&nbsp;#define __GK8HTTPRESPONSE_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;Gk8HttpRequest.h&#34;&nbsp;​&nbsp;​&nbsp;class Gk8HttpResponse&nbsp;{&nbsp;protected:&nbsp;    Gk8HttpRequest* m_pHttpRequest;         //[HTTP请求类]&nbsp;    GK8_BOOL m_bSucceed;                    //[HTTP请求反馈成功]&nbsp;    Gk8ByteMaker m_iResponseData;           //[HTTP请求反馈数据]&nbsp;    GK8_INT m_nResponseCode;                //[HTTP请求反馈码]&nbsp;    Gk8Str m_sErrorBuffer;                  //[HTTP请求错误信息]&nbsp;protected:&nbsp;    GK8_BOOL InitWithRequest(Gk8HttpRequest* pHttpRequest);&nbsp;​&nbsp;public:&nbsp;​&nbsp;    Gk8HttpResponse(Gk8HttpRequest* pHttpRequest)&nbsp;    {&nbsp;        m_pHttpRequest=pHttpRequest;&nbsp;        m_bSucceed=false;&nbsp;        m_iResponseData.Destroy();&nbsp;        m_sErrorBuffer.Empty();&nbsp;    }&nbsp;​&nbsp;    virtual ~Gk8HttpResponse()&nbsp;    {&nbsp;        if(m_pHttpRequest) delete m_pHttpRequest;&nbsp;        ClearResponseData();&nbsp;    }&nbsp;    inline GK8_VOID ClearResponseData()&nbsp;    {&nbsp;        m_iResponseData.Destroy();&nbsp;    }&nbsp;​&nbsp;    inline Gk8HttpRequest* GetHttpRequest()&nbsp;    {&nbsp;        return m_pHttpRequest;&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetSucceed(GK8_BOOL bSucceed)&nbsp;    {&nbsp;        m_bSucceed=bSucceed;&nbsp;    };&nbsp;​&nbsp;    inline GK8_BOOL IsSucceed()&nbsp;    {&nbsp;        return m_bSucceed;&nbsp;    };&nbsp;​&nbsp;    inline GK8_VOID SetResponseData(Gk8ByteMaker* pResponseData)&nbsp;    {&nbsp;        pResponseData-&gt;ShiftTo(m_iResponseData);&nbsp;    }&nbsp;​&nbsp;    inline Gk8ByteMaker* GetResponseData()&nbsp;    {&nbsp;        return &m_iResponseData;&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetResponseCode(GK8_INT nResponseCode)&nbsp;    {&nbsp;        m_nResponseCode=nResponseCode;&nbsp;    }&nbsp;​&nbsp;    inline GK8_INT GetResponseCode()&nbsp;    {&nbsp;        return m_nResponseCode;&nbsp;    }&nbsp;​&nbsp;    inline GK8_VOID SetErrorBuffer(GK8_LPCSTR lpErrorBuffer)&nbsp;    {&nbsp;        m_sErrorBuffer=lpErrorBuffer;&nbsp;    };&nbsp;​&nbsp;    inline GK8_LPCSTR GetErrorBuffer()&nbsp;    {&nbsp;        return m_sErrorBuffer;&nbsp;    }&nbsp;};&nbsp;​&nbsp;#endif</code></pre><p>C++实现HTTP通信类：Gk8HttpClient.h</p><pre><code>&nbsp;#ifndef __GK8HTTPCLIENT_H__&nbsp;#define __GK8HTTPCLIENT_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;Gk8HttpRequest.h&#34;&nbsp;#include &#34;Gk8HttpResponse.h&#34;&nbsp;​&nbsp;​&nbsp;class Gk8HttpClient&nbsp;{&nbsp;private:&nbsp;    GK8_INT m_nTimeOutForConnect;       //[连接超时时间]&nbsp;    GK8_INT m_nTimeOutForRead;          //[读取超时时间]&nbsp;​&nbsp;private:&nbsp;    Gk8HttpClient();&nbsp;    virtual ~Gk8HttpClient();&nbsp;​&nbsp;    GK8_BOOL InitThreadSemphore();&nbsp;public:&nbsp;​&nbsp;    inline GK8_VOID SetTimeoutForConnect(GK8_INT nTimeOutForConnect){m_nTimeOutForConnect=nTimeOutForConnect;};&nbsp;    inline GK8_INT GetTimeoutForConnect(){return m_nTimeOutForConnect;}&nbsp;​&nbsp;    inline GK8_VOID SetTimeoutForRead(GK8_INT nTimeOutForRead){m_nTimeOutForRead=nTimeOutForRead;};&nbsp;    inline GK8_INT GetTimeoutForRead(){return m_nTimeOutForRead;};&nbsp;​&nbsp;    GK8_VOID Send(Gk8HttpRequest* pHttpRequest);&nbsp;​&nbsp;    GK8_VOID HttpClientTick();&nbsp;    static Gk8HttpClient* GetInstance();&nbsp;};&nbsp;#endif</code></pre><p>C++实现HTTP通信类：Gk8HttpClient.cpp</p><pre><code>&nbsp;&nbsp;#include &#34;Gk8HttpClient.h&#34;&nbsp;#include &#34;curl/curl.h&#34;&nbsp;#include &#34;Gk8OperSys.h&#34;&nbsp;#include &#34;Gk8SetMb.cpp&#34;&nbsp;​&nbsp;#include &lt;queue&gt;&nbsp;#include &lt;pthread.h&gt;&nbsp;#include &lt;semaphore.h&gt;&nbsp;#include &lt;errno.h&gt;&nbsp;#include &lt;fcntl.h&gt;&nbsp;​&nbsp;​&nbsp;static Gk8HttpClient* sg_pHttpClient=NULL;      //[静态HTTP客户端]&nbsp;​&nbsp;static GK8_BOOL sg_bHttpClientQuit=false;       //[退出HTTP]&nbsp;static sem_t* sg_pSem=NULL;                     //[信号量的数据类型]&nbsp;static GK8_INT sg_AsyncRequestCount=0;          //[同步请求数]&nbsp;​&nbsp;//[线程及互斥定义]&nbsp;static pthread_t sg_NetWorkThread;              //[HTTP线程]&nbsp;static pthread_mutex_t sg_RequestQueueMutex;    //[HTTP请求队列互斥体]&nbsp;static pthread_mutex_t sg_ResponseQueueMutex;   //[HTTP响应队列互斥体]&nbsp;​&nbsp;static Gk8SetMb&lt;Gk8HttpRequest*&gt; sg_iRequestQueue;      //[HTTP请求队列]&nbsp;static Gk8SetMb&lt;Gk8HttpResponse*&gt; sg_iResponseQueue;    //[HTTP响应队列]&nbsp;​&nbsp;​&nbsp;static GK8_CHAR sg_szErrorBuf[CURL_ERROR_SIZE];         //[错误信息]&nbsp;static Gk8Str sg_iErrorStr;&nbsp;​&nbsp;typedef size_t (*HTTPWRITE_CALLBACK)(GK8_LPVOID lpData,size_t nSize,size_t nMemBlock,GK8_LPVOID lpResponseData);&nbsp;​&nbsp;#if (GK8_TARGET_PLATFORM==GK8_PLATFORM_IOS)&nbsp;#define GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE 1&nbsp;#else&nbsp;#define GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE 0&nbsp;#endif&nbsp;​&nbsp;#if GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE&nbsp;#define GK8_ASYNC_HTTPREQUEST_SEMAPHORE &#34;Gk8HttpAsync&#34;&nbsp;#else&nbsp;static sem_t sg_iSem;&nbsp;#endif&nbsp;​&nbsp;​&nbsp;GK8_BOOL ConfigureCURL(CURL* pCurl);&nbsp;GK8_INT ProcessGetTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode);&nbsp;GK8_INT ProcessPostTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode);&nbsp;​&nbsp;​&nbsp;//[接收HTTP数据]&nbsp;size_t WriteHttpData(GK8_LPVOID lpData,size_t nSize,size_t nMemBlock,GK8_LPVOID lpResponseData)&nbsp;{&nbsp;    Gk8ByteMaker* pResponseData=(Gk8ByteMaker*)lpResponseData;&nbsp;    size_t nLength=nSize*nMemBlock;&nbsp;    pResponseData-&gt;WriteBuf(lpData,(GK8_INT)nLength);&nbsp;    return nLength;&nbsp;}&nbsp;​&nbsp;//[设置CURL超时属性设置]&nbsp;GK8_BOOL ConfigureCURL(CURL* pCurl)&nbsp;{&nbsp;    if(!pCurl) return false;&nbsp;​&nbsp;    CURLcode nCurlCode=curl_easy_setopt(pCurl,CURLOPT_ERRORBUFFER,sg_szErrorBuf);&nbsp;    if(nCurlCode!=CURLE_OK) return false;&nbsp;​&nbsp;    nCurlCode=curl_easy_setopt(pCurl,CURLOPT_TIMEOUT,Gk8HttpClient::GetInstance()-&gt;GetTimeoutForRead());&nbsp;    if(nCurlCode!=CURLE_OK) return false;&nbsp;​&nbsp;    nCurlCode=curl_easy_setopt(pCurl,CURLOPT_CONNECTTIMEOUT,Gk8HttpClient::GetInstance()-&gt;GetTimeoutForConnect());&nbsp;    if(nCurlCode!=CURLE_OK) return false;&nbsp;    &nbsp;    curl_easy_setopt(pCurl,CURLOPT_SSL_VERIFYPEER,0L);&nbsp;    curl_easy_setopt(pCurl,CURLOPT_SSL_VERIFYHOST,0L);&nbsp;​&nbsp;    curl_easy_setopt(pCurl,CURLOPT_NOSIGNAL,1L);&nbsp;    return true;&nbsp;}&nbsp;​&nbsp;//[处理Get请求]&nbsp;GK8_INT ProcessGetTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode)&nbsp;{&nbsp;    CURLcode nCurlCode=CURL_LAST;&nbsp;    CURL* pCurl=curl_easy_init();&nbsp;    &nbsp;    do&nbsp;    {&nbsp;        if(!ConfigureCURL(pCurl)) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_URL,pHttpRequest-&gt;GetHttpUrl());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;        &nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEFUNCTION,lpCallBack);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEDATA,lpStream);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;        &nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_FOLLOWLOCATION,true);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_USERAGENT,&#34;libcurl-agent/1.0&#34;);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_perform(pCurl);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_getinfo(pCurl,CURLINFO_RESPONSE_CODE,lpResponseCode);&nbsp;        //[200:指示客服端的请求已经成功收到，解析，接受]&nbsp;        if(nCurlCode!=CURLE_OK||*lpResponseCode!=200)&nbsp;        {&nbsp;            nCurlCode=CURLE_HTTP_RETURNED_ERROR;&nbsp;        }&nbsp;    }while(0);&nbsp;    &nbsp;    if(pCurl) curl_easy_cleanup(pCurl);&nbsp;​&nbsp;    return (nCurlCode==CURLE_OK?0:1);&nbsp;}&nbsp;​&nbsp;//[处理POST请求:流的行事发出]&nbsp;GK8_INT ProcessPostTask(Gk8HttpRequest* pHttpRequest,HTTPWRITE_CALLBACK lpCallBack,GK8_LPVOID lpStream,GK8_LPINT lpResponseCode)&nbsp;{&nbsp;    CURLcode nCurlCode=CURL_LAST;&nbsp;    CURL* pCurl=curl_easy_init();&nbsp;​&nbsp;    do&nbsp;    {&nbsp;        if(!ConfigureCURL(pCurl)) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_URL,pHttpRequest-&gt;GetHttpUrl());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEFUNCTION,lpCallBack);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_WRITEDATA,lpStream);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_POST,1);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_POSTFIELDS,pHttpRequest-&gt;GetRequestData()-&gt;GetBuf());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_setopt(pCurl,CURLOPT_POSTFIELDSIZE,pHttpRequest-&gt;GetRequestDataSize());&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_perform(pCurl);&nbsp;        if(nCurlCode!=CURLE_OK) break;&nbsp;​&nbsp;        nCurlCode=curl_easy_getinfo(pCurl,CURLINFO_RESPONSE_CODE,lpResponseCode);&nbsp;        &nbsp;        if(nCurlCode!=CURLE_OK||*lpResponseCode!=200)&nbsp;        {&nbsp;            nCurlCode=CURLE_HTTP_RETURNED_ERROR;&nbsp;        }&nbsp;    }while(0);&nbsp;    if(pCurl) curl_easy_cleanup(pCurl);&nbsp;​&nbsp;    return (nCurlCode==CURLE_OK?0:1);&nbsp;}&nbsp;​&nbsp;//[创建网络线程]&nbsp;static GK8_LPVOID NetWorkThread(GK8_LPVOID lpData)&nbsp;{&nbsp;    Gk8HttpRequest* pHttpRequest=NULL;&nbsp;    Gk8HttpResponse* pHttpResponse=NULL;&nbsp;​&nbsp;    while(true)&nbsp;    {&nbsp;        //Wait for http request tasks from main thread&nbsp;        GK8_INT nSemWaitRet=sem_wait(sg_pSem);&nbsp;        if(nSemWaitRet&lt;0)&nbsp;        {&nbsp;            _GK8ERR&lt;&lt;&#34;HttpRequest async thread semaphore error:&#34;&lt;&lt;strerror(errno)&lt;&lt;CR;&nbsp;            break;&nbsp;        }&nbsp;​&nbsp;        if(sg_bHttpClientQuit) break;&nbsp;​&nbsp;        //[第一步:发送HTTP请求]&nbsp;        pHttpRequest=NULL;&nbsp;        pthread_mutex_lock(&sg_RequestQueueMutex);&nbsp;        if(0!=sg_iRequestQueue.GetSize())&nbsp;        {&nbsp;            pHttpRequest=sg_iRequestQueue.GetItemAt(0);&nbsp;            sg_iRequestQueue.RemoveItemAt(0);&nbsp;        }&nbsp;        pthread_mutex_unlock(&sg_RequestQueueMutex);&nbsp;​&nbsp;        if(NULL==pHttpRequest) continue;&nbsp;​&nbsp;        //[第二步:libCurl同步请求]&nbsp;        pHttpResponse=new Gk8HttpResponse(pHttpRequest);&nbsp;​&nbsp;        GK8_INT nResponseCode=-1;&nbsp;        GK8_INT nRetValue=0;&nbsp;​&nbsp;        switch(pHttpRequest-&gt;GetRequestType())&nbsp;        {&nbsp;            case Gk8HttpRequest::kHttpGet:&nbsp;                nRetValue=ProcessGetTask(pHttpRequest,WriteHttpData,pHttpResponse-&gt;GetResponseData(),&nResponseCode);&nbsp;                break;&nbsp;            case Gk8HttpRequest::kHttpPost:&nbsp;                nRetValue=ProcessPostTask(pHttpRequest,WriteHttpData,pHttpResponse-&gt;GetResponseData(),&nResponseCode);&nbsp;                break;&nbsp;            default:&nbsp;                _GK8ERR&lt;&lt;&#34;Gk8HttpClient:Unkown Request Type,Only GET And POST Are Supported&#34;&lt;&lt;CR;&nbsp;                break;&nbsp;        }&nbsp;        pHttpResponse-&gt;SetResponseCode(nResponseCode);&nbsp;        //[清除请求中的二进制数据]&nbsp;        pHttpRequest-&gt;ClearRequestData();&nbsp;​&nbsp;        if(nRetValue!=0)&nbsp;        {&nbsp;            pHttpResponse-&gt;SetSucceed(false);&nbsp;            sg_iErrorStr=sg_szErrorBuf;&nbsp;            pHttpResponse-&gt;SetErrorBuffer(sg_iErrorStr);&nbsp;        }else&nbsp;        {&nbsp;            pHttpResponse-&gt;SetSucceed(true);&nbsp;        }&nbsp;​&nbsp;        pthread_mutex_lock(&sg_ResponseQueueMutex);&nbsp;        sg_iResponseQueue.AddItem(pHttpResponse);&nbsp;        pthread_mutex_unlock(&sg_ResponseQueueMutex);&nbsp;    }&nbsp;​&nbsp;    sg_AsyncRequestCount-=sg_iRequestQueue.GetSize();&nbsp;    pthread_mutex_lock(&sg_RequestQueueMutex);&nbsp;    sg_iRequestQueue.Clear();&nbsp;    pthread_mutex_unlock(&sg_RequestQueueMutex);&nbsp;    &nbsp;    if(sg_pSem!=NULL)&nbsp;    {&nbsp;#if GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE&nbsp;        sem_unlink(GK8_ASYNC_HTTPREQUEST_SEMAPHORE);&nbsp;        sem_close(sg_pSem);&nbsp;#else&nbsp;        sem_destroy(sg_pSem);&nbsp;#endif&nbsp;        sg_pSem=NULL;&nbsp;​&nbsp;        pthread_mutex_destroy(&sg_RequestQueueMutex);&nbsp;        pthread_mutex_destroy(&sg_ResponseQueueMutex);&nbsp;​&nbsp;        //[依次删除数据]&nbsp;        GK8_INT nIndex;&nbsp;        for(nIndex=0;nIndex&lt;sg_iRequestQueue.GetSize();nIndex++)&nbsp;        {&nbsp;            pHttpRequest=sg_iRequestQueue.GetItemAt(nIndex);&nbsp;            delete pHttpRequest;&nbsp;        }&nbsp;        for(nIndex=0;nIndex&lt;sg_iResponseQueue.GetSize();nIndex++)&nbsp;        {&nbsp;            pHttpResponse=sg_iResponseQueue.GetItemAt(nIndex);&nbsp;            delete pHttpResponse;&nbsp;        }&nbsp;        sg_iRequestQueue.Destroy();&nbsp;        sg_iResponseQueue.Destroy();&nbsp;    }&nbsp;    pthread_exit(NULL);&nbsp;    return 0;&nbsp;}&nbsp;​&nbsp;/////////////////////////////////////////////////////////////////&nbsp;Gk8HttpClient::Gk8HttpClient()&nbsp;:m_nTimeOutForRead(60)&nbsp;,m_nTimeOutForConnect(30)&nbsp;{&nbsp;​&nbsp;}&nbsp;​&nbsp;Gk8HttpClient::~Gk8HttpClient()&nbsp;{&nbsp;    sg_bHttpClientQuit=true;&nbsp;    if(sg_pSem!=NULL)&nbsp;    {&nbsp;        sem_post(sg_pSem);&nbsp;    }&nbsp;}&nbsp;​&nbsp;//[初始化线程]&nbsp;GK8_BOOL Gk8HttpClient::InitThreadSemphore()&nbsp;{&nbsp;    if(sg_pSem!=NULL)&nbsp;    {&nbsp;        return true;&nbsp;    }else&nbsp;    {&nbsp;#if GK8_ASYNC_HTTPREQUEST_USE_NAMED_SEMAPHORE&nbsp;        sg_pSem=sem_open(GK8_ASYNC_HTTPREQUEST_SEMAPHORE,O_CREAT,0644,0);&nbsp;        if(sg_pSem==SEM_FAILED)&nbsp;        {&nbsp;            _GK8ERR&lt;&lt;&#34;Open HttpRequest Semaphore Failed&#34;&lt;&lt;CR;&nbsp;            sg_pSem=NULL;&nbsp;            return false;&nbsp;        }&nbsp;#else&nbsp;        GK8_INT nSemRet=sem_init(&sg_iSem,0,0);&nbsp;        if(nSemRet&lt;0)&nbsp;        {&nbsp;            _GK8ERR&lt;&lt;&#34;Init HttpRequest Semaphore Failed&#34;&lt;&lt;CR;&nbsp;            return false;&nbsp;        }&nbsp;        sg_pSem=&sg_iSem;&nbsp;#endif&nbsp;​&nbsp;        pthread_mutex_init(&sg_RequestQueueMutex,NULL);&nbsp;        pthread_mutex_init(&sg_ResponseQueueMutex,NULL);&nbsp;​&nbsp;        pthread_create(&sg_NetWorkThread,NULL,NetWorkThread,NULL);&nbsp;        pthread_detach(sg_NetWorkThread);&nbsp;​&nbsp;        sg_bHttpClientQuit=false;&nbsp;    }&nbsp;    return true;&nbsp;}&nbsp;​&nbsp;//[发送HTTP请求]&nbsp;GK8_VOID Gk8HttpClient::Send(Gk8HttpRequest* pHttpRequest)&nbsp;{&nbsp;    if(false==InitThreadSemphore()) return;&nbsp;    if(!pHttpRequest) return;&nbsp;​&nbsp;    ++sg_AsyncRequestCount;&nbsp;​&nbsp;    pthread_mutex_lock(&sg_RequestQueueMutex);&nbsp;    sg_iRequestQueue.AddItem(pHttpRequest);&nbsp;    pthread_mutex_unlock(&sg_RequestQueueMutex);&nbsp;​&nbsp;    sem_post(sg_pSem);&nbsp;}&nbsp;​&nbsp;//[获取HTTP单例]&nbsp;Gk8HttpClient* Gk8HttpClient::GetInstance()&nbsp;{&nbsp;    if(sg_pHttpClient==NULL) sg_pHttpClient=new Gk8HttpClient();&nbsp;    return sg_pHttpClient;&nbsp;}&nbsp;​&nbsp;//[HTTP响应帧控制]&nbsp;GK8_VOID Gk8HttpClient::HttpClientTick()&nbsp;{&nbsp;    if(sg_pSem==NULL) return;&nbsp;​&nbsp;    Gk8HttpResponse* pHttpResponse=NULL;&nbsp;​&nbsp;    pthread_mutex_lock(&sg_ResponseQueueMutex);&nbsp;    if(sg_iResponseQueue.GetSize()&gt;0)&nbsp;    {&nbsp;        pHttpResponse=sg_iResponseQueue.GetItemAt(0);&nbsp;        sg_iResponseQueue.RemoveItemAt(0);&nbsp;    }&nbsp;    pthread_mutex_unlock(&sg_ResponseQueueMutex);&nbsp;    &nbsp;    if(pHttpResponse)&nbsp;    {&nbsp;        --sg_AsyncRequestCount;&nbsp;        Gk8HttpRequest* pHttpRequest=pHttpResponse-&gt;GetHttpRequest();&nbsp;        Gk8BaseObj* pTarget=pHttpRequest-&gt;GetTarget();&nbsp;        HTTPREQUEST_CALLBACK_FUN pSelector=pHttpRequest-&gt;GetSelector();&nbsp;​&nbsp;        //[回调处理:记录数据]&nbsp;        if(pTarget&&pSelector)&nbsp;        {&nbsp;            (pTarget-&gt;*pSelector)(pHttpResponse);&nbsp;        }&nbsp;        //[销毁请求数据]&nbsp;        delete pHttpResponse;&nbsp;    }&nbsp;}</code></pre><p>C++实现Servlet类：Gk8HttpServlet.h</p><pre><code>&nbsp;#ifndef __GK8HTTPSERVICE_H__&nbsp;#define __GK8HTTPSERVICE_H__&nbsp;​&nbsp;#pragma once&nbsp;#include &#34;curl/curl.h&#34;&nbsp;#include &#34;Gk8HttpClient.h&#34;&nbsp;#include &#34;Gk8HttpRequest.h&#34;&nbsp;#include &#34;Gk8HttpResponse.h&#34;&nbsp;​&nbsp;class Gk8HttpServlet:public Gk8BaseObj&nbsp;{&nbsp;    DECLARE_TOSPP_MAP;&nbsp;private:&nbsp;    Gk8Str m_sHttpUrl;              //[HTTP请求地址]&nbsp;    Gk8ByteMaker m_iRequestData;    //[HTTP请求数据]&nbsp;    Gk8Var m_iHttpCallVar;          //[HTTP回调信息]&nbsp;​&nbsp;    GK8_VOID ServletRequestCompleted(GK8_LPVOID lpHttpResponse);&nbsp;public:&nbsp;    Gk8HttpServlet();&nbsp;    ~Gk8HttpServlet();&nbsp;​&nbsp;    GK8_VOID TOSPPFUNC SendHttpMessage(GK8_LPCSTR lpHttpData,Gk8Var& iHttpCallVar);&nbsp;};&nbsp;#endif</code></pre><p>C++实现Servlet类：Gk8HttpServlet.cpp</p><pre><code>&nbsp;#include &#34;Gk8HttpServlet.h&#34;&nbsp;#include &#34;Gk8OperSys.h&#34;&nbsp;#include &#34;Gk8Helper.h&#34;&nbsp;​&nbsp;static Gk8Str sg_iReceiveMessageEvent(&#34;OnReceiveMessage&#34;);//[接收网络信息]&nbsp;​&nbsp;#define HTTPSERVLET_FAIL        0       //[HTTP请求失败]&nbsp;#define HTTPSERVLET_SUCC        1       //[HTTP请求成功]&nbsp;​&nbsp;/////////////////////////////////////////////CLASS-TOLUA////////////////////////////////////////////////////&nbsp;TOLUA_CLASS_COLLECT_FUNC(Gk8HttpServlet)&nbsp;​&nbsp;BEGIN_TOLUA_CLASS_FUNC(Gk8HttpServlet,NewObj)&nbsp;    if(!CheckToLuaFunParam(L,&#34;NewObj&#34;,Gk8Var()&lt;&lt;ISUSERTABLE(&#34;Gk8HttpServlet&#34;)&lt;&lt;ISVABOOLEAN&lt;&lt;ISNOOBJ)) return 0;&nbsp;    Gk8HttpServlet* pHttpServlet=(Gk8HttpServlet*)Mtolua_new((Gk8HttpServlet)());&nbsp;    tolua_pushusertype(L,(GK8_LPVOID)pHttpServlet,&#34;Gk8HttpServlet&#34;);&nbsp;    if(IFBOOLEAN(2)) tolua_register_gc(L,lua_gettop(L));&nbsp;END_TOLUA_CLASS_FUNC&nbsp;​&nbsp;BEGIN_TOLUA_CLASS_FUNC(Gk8HttpServlet,SendHttpMessage)&nbsp;    if(!CheckToLuaFunParam(L,&#34;SendHttpMessage&#34;,Gk8Var()&lt;&lt;ISUSERTYPE(&#34;Gk8HttpServlet&#34;)&lt;&lt;ISSTRING&lt;&lt;ISVAFUNCTION&lt;&lt;ISNOOBJ)) return 0;&nbsp;    //TOLUAGETOBJ(Gk8HttpServlet,1)-&gt;SendHttpMessage(TOLUAGETSTRING(2),TOLUAGETFUNEX(L,3,0));&nbsp;END_TOLUA_CLASS_FUNC&nbsp;​&nbsp;//[启动注册类的全部TOLUA函数]&nbsp;BEGIN_TOLUA_FUN_MAP(Gk8HttpServlet)&nbsp;    TOLUA_CLASS(Gk8HttpServlet,Gk8BaseObj,&#34;[网络类]&#34;,&#34;[HTTP请求类]&#34;)&nbsp;    TOLUA_CLASS_FUNC(Gk8HttpServlet,NewObj,&#34;[Gk8HttpServlet* NewObj(GK8_BOOL ifLocal=false)?创建Gk8HttpServlet对象]&#34;)&nbsp;    TOLUA_CLASS_FUNC(Gk8HttpServlet,SendHttpMessage,&#34;[GK8_VOID SendHttpMessage(GK8_LPCSTR lpHttpData,iHttpCallVar)?发送HTTP请求,字符串模式]&#34;)&nbsp;END_TOLUA_FUN_MAP&nbsp;​&nbsp;/////////////////////////////////////////////CLASS-TOSPP////////////////////////////////////////////////////&nbsp;BEGIN_TOSPP_MAP(Gk8HttpServlet,Gk8BaseObj)&nbsp;    TOSPP_FUNC(Gk8HttpServlet,SendHttpMessage,&#39; &#39;,&#34;s&v&#34;,&#34;SendHttpMessage(lpHttpData,iHttpCallVar)&#34;)&nbsp;END_TOSPP_MAP()&nbsp;/////////////////////////////////////////////////////////////////////////////////////////////////&nbsp;​&nbsp;Gk8HttpServlet::Gk8HttpServlet()&nbsp;{&nbsp;​&nbsp;}&nbsp;​&nbsp;Gk8HttpServlet::~Gk8HttpServlet()&nbsp;{&nbsp;​&nbsp;}&nbsp;​&nbsp;//[发送HTTP请求注意编码问题]&nbsp;GK8_VOID Gk8HttpServlet::SendHttpMessage(GK8_LPCSTR lpHttpData,Gk8Var& iHttpCallVar)&nbsp;{&nbsp;    m_sHttpUrl=lpHttpData;&nbsp;    //[注册脚本回调消息]&nbsp;    m_iHttpCallVar=iHttpCallVar;&nbsp;    Gk8Var iEmptyVar;&nbsp;    if(m_iHttpCallVar.GetSize()==1 && m_iHttpCallVar[0].IfInt()) SetEvent(sg_iReceiveMessageEvent,m_iHttpCallVar[0],iEmptyVar);&nbsp;    Gk8HttpRequest* pHttpRequest=new Gk8HttpRequest();&nbsp;    pHttpRequest-&gt;SetRequestType(Gk8HttpRequest::kHttpGet);&nbsp;    pHttpRequest-&gt;SetHttpUrl(m_sHttpUrl);&nbsp;    pHttpRequest-&gt;SetResponseCallBack(this,(HTTPREQUEST_CALLBACK_FUN)&Gk8HttpServlet::ServletRequestCompleted);&nbsp;    pHttpRequest-&gt;SetRequestData(&m_iRequestData);&nbsp;​&nbsp;    Gk8HttpClient::GetInstance()-&gt;Send(pHttpRequest);&nbsp;}&nbsp;​&nbsp;//[HTTP请求信息回调]&nbsp;GK8_VOID Gk8HttpServlet::ServletRequestCompleted(GK8_LPVOID lpHttpResponse)&nbsp;{&nbsp;    Gk8HttpResponse* pHttpResponse=(Gk8HttpResponse*)lpHttpResponse;&nbsp;    if(!pHttpResponse) return;&nbsp;​&nbsp;    //[把服务器数据派遣到脚本中]&nbsp;    GK8_INT nFailCode=HTTPSERVLET_SUCC;&nbsp;    Gk8Str iResponstStr;&nbsp;    if(!pHttpResponse-&gt;IsSucceed())&nbsp;    {&nbsp;        _GK8ERR&lt;&lt;&#34;Gk8HttpServlet Response Failed Error Is &#34;&lt;&lt;pHttpResponse-&gt;GetErrorBuffer()&lt;&lt;CR;&nbsp;        iResponstStr=&#34;UnKown Error&#34;;&nbsp;        nFailCode=HTTPSERVLET_FAIL;&nbsp;    }else&nbsp;    {&nbsp;        Gk8ByteMaker* pResponseData=pHttpResponse-&gt;GetResponseData();&nbsp;        iResponstStr.BinToStr(pResponseData-&gt;GetBuf(),pResponseData-&gt;GetStreamSize());&nbsp;    }&nbsp;​&nbsp;    if(m_iHttpCallVar.GetSize()==1)&nbsp;    {&nbsp;        RunEventWithArgs(sg_iReceiveMessageEvent,iResponstStr);&nbsp;    }else&nbsp;    {&nbsp;        if(!m_iHttpCallVar[0].IfPtr()||!IfObjPtr(m_iHttpCallVar[0].GetPtr(),m_iHttpCallVar[0].GetPtrId())) return;&nbsp;​&nbsp;        Gk8Obj* pBindObj=m_iHttpCallVar[0].GetSafePtr();&nbsp;        Gk8Var iParamVar;&nbsp;        iParamVar&lt;&lt;nFailCode&lt;&lt;iResponstStr;&nbsp;        pBindObj-&gt;OnCall(m_iHttpCallVar[1],iParamVar);&nbsp;    }&nbsp;    //[直接删除本身]&nbsp;    SafeDeleteObj(this);&nbsp;}</code></pre><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'网络','HTTP','实现'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>