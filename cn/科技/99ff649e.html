<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python2 和 Python3 的区别及兼容技巧 | 极客快訊</title><meta property="og:title" content="Python2 和 Python3 的区别及兼容技巧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/99ff649e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/99ff649e.html><meta property="article:published_time" content="2020-11-14T21:05:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:09+08:00"><meta name=Keywords content><meta name=description content="Python2 和 Python3 的区别及兼容技巧"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/99ff649e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python2 和 Python3 的区别及兼容技巧</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>前言</p><p class=ql-align-justify>最近 Python 之父 Guido van Rossum（龟爷）终于在 Python 官方邮件组落实了 Python 2.7 的终焉之日（EOL）。</p><p class=ql-align-justify>说的是 Python 2.7 的 EOL 日期最终确定为 2020 年 1 月 1 日，之后不会有任何更新，包括源码的安全补丁。</p><p class=ql-align-justify>所以兼容Python3已经可以说非常必要了，但有些常用的库还没有升级到Python3，所以我们看下如何写出兼容2和3的代码。</p><p>Python 2 or 3 ？</p><p class=ql-align-justify>Python 3 被钦定为 Python 的未来，于 2008 年末发布，是目前正在开发的版本。旨在解决和修正 Python 2 遗留的设计缺陷、清理代码库冗余、追求有且仅有一种最佳实践方式来执行任务等问题。</p><p class=ql-align-justify>起初，由于 Python 3 不能向后兼容的事实，导致了用户采用缓慢，对初学者不友好等问题。但在 Python 社区的努力和决绝态度下，截至龟爷发出邮件之前，已经有了 21903 个 Packages 可以支持 Python 3.5，其中包括了绝大多数最受欢迎的封装库，与此同时也有越来越多的封装库（e.g. Django、Numpy）表示其新版本将不再支持 Python 2。</p><p class=ql-align-justify>Python 2.7 于 3.0 之后的 2010 年 7 月 3 日发布，计划作为 2.x 的最后一个版本。Python 2.7 的历史任务在于通过提供 2 和 3 之间的兼容性措施，使 Python 2.x 的用户更容易将代码移植到 Python 3.x 上。那么如果你希望自己的代码能够兼容两个不同的版本，首先你起码要让代码能够正常的运行在 Python 2.7 上。</p><p class=ql-align-justify>注：下文使用 P2 表示 Python 2.7；使用 P3 表示 Python 3.x。</p><p>不同与兼容</p><p class=ql-align-justify>__future__ 模块是我们首先需要了解的，该模块最主要的作用是支持在 P2 中导入那些在 P3 才生效的模块和函数。是一个非常优秀的兼容性工具库，在下文中给出的许多 兼容技巧 实例都依赖于它。</p><p class=ql-align-justify>特性 在此版本可选 在此版本内置 效果</p><p class=ql-align-justify>nested_scopes 2.1.0b1 2.2 PEP 227：静态嵌套作用域</p><p class=ql-align-justify>generators 2.2.0a1 2.3 PEP 255：简单生成器</p><p class=ql-align-justify>division 2.2.0a2 3.0 PEP 238：除法操作符改动</p><p class=ql-align-justify>absolute_import 2.5.0a1 3.0 PEP 328：Imports 多行导入与绝对相对路径</p><p class=ql-align-justify>with_statement 2.5.0a1 2.6 PEP 343：with 语句</p><p class=ql-align-justify>print_function 2.6.0a2 3.0 PEP 3105：print 语句升级为函数</p><p class=ql-align-justify>unicode_literals 2.6.0a2 3.0 PEP 3112：Bytes 类型</p><p class=ql-align-justify>(__future__ 功能列表)</p><p>统一不等于语法</p><p class=ql-align-justify>P2 支持使用 &lt;> 和 != 表示不等于。</p><p class=ql-align-justify>P3 仅支持使用 != 表示不等于。</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用 != 语法</p><p>统一整数类型</p><p class=ql-align-justify>P2 中整数类型可以细分为短整型 int 和长整型 long。</p><p class=ql-align-justify>P3 废除了短整型，并统一使用 int 表示长整型（不再有 L 跟在 repr 后面）。</p><p>兼容技巧：</p><p># Python 2 only</p><p>k <strong>=</strong> 9223372036854775808L</p><p># Python 2 and 3:</p><p>k <strong>=</strong> 9223372036854775808</p><p># Python 2 only</p><p>bigint <strong>=</strong> 1L</p><p># Python 2 and 3</p><p><strong>from</strong> future.builtins <strong>import</strong> int</p><p>bigint <strong>=</strong> int(1)</p><p>统一整数除法</p><p class=ql-align-justify>P2 的除法 / 符号实际上具有两个功能：</p><p class=ql-align-justify>当两个操作数均为整型对象时，进行的是地板除（截除小数部分），返回整型对象；</p><p class=ql-align-justify>当两个操作数存在至少一个浮点型对象时，进行的是真除（保留小数部分），返回浮点型对象。</p><p class=ql-align-justify>P3 的除法 / 符号仅仅具有真除的功能，而地板除的功能则交由 // 来完成。</p><p>兼容技巧：</p><p># Python 2 only:</p><p><strong>assert</strong> 2 <strong>/</strong> 3 <strong>==</strong> 0</p><p># Python 2 and 3:</p><p><strong>assert</strong> 2 <strong>//</strong> 3 <strong>==</strong> 0</p><p>“True division” (float division):</p><p># Python 3 only:</p><p><strong>assert</strong> 3 <strong>/</strong> 2 <strong>==</strong> 1.5</p><p># Python 2 and 3:</p><p><strong>from</strong> __future__ <strong>import</strong> division # (at top of module)</p><p>统一缩进语法</p><p class=ql-align-justify>P2 可以混合使用 tab 和 space 两种方式来进行缩进（1 个 tab == 8 个 space），但实际上这一特性并非所有 IDE 都能够支持，会因此出现同样的代码无法跨 IDE 运行的情况。</p><p class=ql-align-justify>P3 统一使用 tab 作为缩进，如果 tab 和 space 同时存在，就会触发异常：</p><p>TabError: inconsistent use of tabs and spaces <strong>in</strong> indentation.</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用 tab 作为缩进。</p><p>统一类定义</p><p class=ql-align-justify>P2 同时支持新式类（object）和老式类。</p><p class=ql-align-justify>P3 则统一使用新式类，并且只有使用新式类才能应用多重继承。</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用新式类。</p><p>统一字符编码类型</p><p class=ql-align-justify>P2 默认使用 ASCII 字符编码，但因为 ASCII 只支持数百个字符，并不能灵活的满足非英文字符，所以 P2 同时也支持 Unicode 这种更强大的字符编码。不过，由于 P2 同时支持两套字符编码，就难免多出了一些标识和转换的麻烦。</p><p class=ql-align-justify>而 P3 统一使用 Unicode 字符编码，这节省了开发者的时间，同时也可以轻松地在程序中输入和显示更多种类的字符。</p><p>兼容技巧：</p><p class=ql-align-justify>在所有的字符串赋值中均使用前缀 u，或引入 unicode_literals 字符模块。</p><p># Python 2 only</p><p>s1 <strong>=</strong> 'PythonTab'</p><p>s2 <strong>=</strong> u'PythonTab中文网'</p><p># Python 2 and 3</p><p>s1 <strong>=</strong> u'PythonTab'</p><p>s2 <strong>=</strong> u'PythonTab中文网'</p><p># Python 2 and 3</p><p><strong>from</strong> __future__ <strong>import</strong> unicode_literals # at top of module</p><p>s1 <strong>=</strong> 'PythonTab'</p><p>s2 <strong>=</strong> 'PythonTab中文网'</p><p>统一导入模块的路径搜索方式</p><p class=ql-align-justify>P2 导入一个模块时首先会搜索当前目录（cwd），若非，则搜索环境变量路径（sys.path）。这一特性时常给开发者带来困扰，相信大家都曾经碰到过，尤其当自定义模块与系统模块重名的时候；</p><p class=ql-align-justify>为了解决这个问题，默认的 P3 仅会搜索环境变量路径，当你需要搜索自定义模块时，你可以在包管理模式下将项目路径加入到环境变量中，然后再使用绝对路径和相对路径（以 . 开头）的方式来导入。</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用绝对路径进行自定义模块导入。</p><p>修正列表推导式的变量作用域泄露</p><p class=ql-align-justify>P2 的列表推倒式中的变量会泄露到全局作用域，例如：</p><p><strong>import</strong> platform</p><p>print('Python', platform.python_version())</p><p>i <strong>=</strong> 1</p><p>print('before: I = %s' <strong>%</strong> i)</p><p><strong>print</strong>('comprehension: %s' <strong>%</strong> [i <strong>for</strong> i <strong>in</strong> range(5)])</p><p>print('after: I = %s' <strong>%</strong> i)</p><p># OUT</p><p>Python 2.7.6</p><p>before: i <strong>=</strong> 1</p><p>comprehension: [0, 1, 2, 3, 4]</p><p>after: i <strong>=</strong> 4</p><p class=ql-align-justify>P3 则解决了这个问题，列表推倒式中的变量不再泄露到全局作用域。</p><p><strong>import</strong> platform</p><p>print('Python', platform.python_version())</p><p>i <strong>=</strong> 1</p><p><strong>print</strong>('before: i =', i)</p><p><strong>print</strong>('comprehension:', [i <strong>for</strong> i <strong>in</strong> range(5)])</p><p>print('after: i =', i)</p><p># OUT</p><p>Python 3.4.1</p><p>before: i <strong>=</strong> 1</p><p>comprehension: [0, 1, 2, 3, 4]</p><p>after: i <strong>=</strong> 1</p><p>修正非法比较操作异常</p><p class=ql-align-justify>P2 能够对两个数据类型并不相同的对象进行比较。</p><p><strong>import</strong> platform</p><p>print('Python', platform.python_version())</p><p>print("[1, 2] > 'foo' = ", [1, 2] > 'foo')</p><p><strong>print</strong>("(1, 2) > 'foo' = ", (1, 2) > 'foo')</p><p><strong>print</strong>("[1, 2] > (1, 2) = ", [1, 2] > (1, 2))</p><p class=ql-align-justify># OUT</p><p>Python 2.7.6</p><p>[1, 2] > 'foo' = False</p><p>(1, 2) > 'foo' = True</p><p>[1, 2] > (1, 2) = False</p><p class=ql-align-justify>不过，这种看似方便的特性，实际上却是一个定时炸弹，因为你无法唯一的确定到底是什么原因导致的返回值为 False（可能是数据比较、也可能是数据类型不一致）。</p><p class=ql-align-justify>P3 则对其进行了修正，如果比较操作数类型不一致时，会触发 TypeError 异常。</p><p>兼容技巧：</p><p class=ql-align-justify>永远不要比较数据类型不一致的对象。</p><p>统一抛出异常语法</p><p class=ql-align-justify>P2 同时支持新旧两种异常触发语法：</p><p><strong>raise</strong> IOError, "file error" # Old</p><p><strong>raise</strong> IOError("file error") # New</p><p class=ql-align-justify>P3 则统一使用新异常触发语法，否则会触发 SyntaxError 异常:</p><p><strong>raise</strong> IOError("file error")</p><p>兼容技巧：</p><p>### 抛出异常</p><p># Python 2 only:</p><p><strong>raise</strong> ValueError, "dodgy value"</p><p># Python 2 and 3:</p><p><strong>raise</strong> ValueError("dodgy value")</p><p>### 使用 traceback 抛出异常</p><p># Python 2 only:</p><p>traceback <strong>=</strong> sys.exc_info()[2]</p><p><strong>raise</strong> ValueError, "dodgy value", traceback</p><p># Python 3 only:</p><p><strong>raise</strong> ValueError("dodgy value").with_traceback()</p><p># Python 2 and 3: option 1</p><p><strong>from</strong> six <strong>import</strong> reraise as raise_</p><p># or # from future.utils import raise_</p><p>traceback <strong>=</strong> sys.exc_info()[2]</p><p>raise_(ValueError, "dodgy value", traceback)</p><p># Python 2 and 3: option 2</p><p><strong>from</strong> future.utils <strong>import</strong> raise_with_traceback</p><p>raise_with_traceback(ValueError("dodgy value"))</p><p>### 异常链处理</p><p># Setup:</p><p><strong>class</strong> DatabaseError(Exception):</p><p><strong>pass</strong></p><p># Python 3 only</p><p><strong>class</strong> FileDatabase:</p><p><strong>def</strong> __init__(self, filename):</p><p><strong>try</strong>:</p><p>self.file <strong>=</strong> open(filename)</p><p><strong>except</strong> IOError as exc:</p><p><strong>raise</strong> DatabaseError('failed to open') <strong>from</strong> exc</p><p># Python 2 and 3:</p><p><strong>from</strong> future.utils <strong>import</strong> raise_from</p><p><strong>class</strong> FileDatabase:</p><p><strong>def</strong> __init__(self, filename):</p><p><strong>try</strong>:</p><p>self.file <strong>=</strong> open(filename)</p><p><strong>except</strong> IOError as exc:</p><p>raise_from(DatabaseError('failed to open'), exc)</p><p>统一异常处理语法</p><p class=ql-align-justify>P2 实现异常处理也能够支持两种语法。</p><p><strong>try</strong>:</p><p>let_us_cause_a_NameError</p><p><strong>except</strong> NameError, err:</p><p># except NameError as err:</p><p>print err, '--> our error message'</p><p class=ql-align-justify>P3 的异常处理则强制要求使用 as 关键字的方式。</p><p><strong>try</strong>:</p><p>let_us_cause_a_NameError</p><p><strong>except</strong> NameError as err:</p><p>print(err, '--> our error message')</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用 as 关键字的异常处理方式。</p><p>统一输入函数</p><p class=ql-align-justify>P2 支持 raw_input 和 input 两个输入函数，区别在于前者仅能返回 String 类型对象，后者则支持返回数字和字符串两种数据类型对象，并且当输入为表达式时，会隐式调用 eval 函数返回其执行结果。显然的，使用 input 是更加灵活的写法。</p><p class=ql-align-justify>所以 P3 统一的使用了 input 函数进行输入处理。</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用 input 内置函数。</p><p># Python 2 only:</p><p>input("Type something safe please: ")</p><p># Python 2 and 3</p><p><strong>from</strong> future.builtins <strong>import</strong> input</p><p>eval(input("Type something safe please: "))</p><p>统一输出函数</p><p class=ql-align-justify>P2 中的 print 即是关键字又是内置函数。print 'Hello world!' 为一条语句，print('Hello world!') 则为一次函数调用。</p><p class=ql-align-justify>P3 统一使用 print 函数进行输出操作，其原型如下，这一改变让 P3 的输出处理变得更加简洁、强大而优雅，通过实参的传递就能替代 P2 中繁复的代码实现。</p><p><strong>print</strong>(<strong>*</strong>objects, sep<strong>=</strong>' ', end<strong>=</strong>'\n', file<strong>=</strong>sys.stdout, flush<strong>=</strong>False)</p><p>兼容技巧：</p><p>### 单行打印单个 String</p><p># Python 2 only:</p><p>print 'Hello'</p><p># Python 2 only:</p><p><strong>print</strong> 'Hello'</p><p>### 单行打印多个 String</p><p># Python 2 only:</p><p>print 'Hello', 'Guido'</p><p># Python 2 and 3:</p><p><strong>from</strong> __future__ <strong>import</strong> print_function # (at top of module)</p><p><strong>print</strong>('Hello', 'Guido')</p><p>### 输出重定向</p><p># Python 2 only:</p><p><strong>print</strong> >> sys.stderr, 'Hello'</p><p># Python 2 and 3:</p><p><strong>from</strong> __future__ <strong>import</strong> print_function</p><p><strong>print</strong>('Hello', file<strong>=</strong>sys.stderr)</p><p>### 换行打印</p><p># Python 2 only:</p><p><strong>print</strong> 'Hello',</p><p># Python 2 and 3:</p><p><strong>from</strong> __future__ <strong>import</strong> print_function</p><p>print('Hello', end<strong>=</strong>'')</p><p>统一文件操作函数</p><p class=ql-align-justify>P2 支持使用 file 和 open 两个函数来进行文件操作。</p><p class=ql-align-justify>P3 则统一使用 open 来进行文件操作。</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用 open 函数。</p><p># Python 2 only:</p><p>f <strong>=</strong> file(pathname)</p><p># Python 2 and 3:</p><p>f <strong>=</strong> open(pathname)</p><p>统一列表迭代器生成函数</p><p class=ql-align-justify>P2 支持使用 range 和 xrange 两个函数来生成可迭代对象，区别在于前者返回的是一个列表类型对象，后者返回的是一个类似生成器（惰性求值）的迭代对象，支持无限迭代。所以当你需要生成一个很大的序列时，推荐使用 xrange，因为它不会一上来就索取序列所需的所有内存空间。如果只对序列进行读操作的话，xrange 方法效率显然会更高，但是如果要修改序列的元素，或者往序列增删元素的话，那只能通过 range 方法生成一个 list 对象了。</p><p class=ql-align-justify>P3 则统一使用 range 函数来生成可迭代对象，但其实 P3 的 range 更像是 P2 的 xrange。所以在 P3 中如果你想得到一个可以被修改的列表对象，你需要这么做：</p><p>list(range(1,10))</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p><p>兼容技巧：</p><p class=ql-align-justify>统一使用 range 函数</p><p># Python 2 only:</p><p><strong>for</strong> i <strong>in</strong> xrange(10<strong>**</strong>8):</p><p>...</p><p># Python 2 and 3: forward-compatible</p><p><strong>from</strong> future.builtins <strong>import</strong> range</p><p><strong>for</strong> i <strong>in</strong> range(10<strong>**</strong>8):</p><p>...</p><p># Python 2 and 3: backward-compatible</p><p><strong>from</strong> past.builtins <strong>import</strong> xrange</p><p><strong>for</strong> i <strong>in</strong> xrange(10<strong>**</strong>8):</p><p>...</p><p>统一迭代器迭代函数</p><p class=ql-align-justify>P2 中支持使用内置函数 next 和迭代器对象的 .next() 实例方法这两种方式来获取迭代器对象的下一个元素。所以，在实现自定义迭代器对象类时，必须实现 .next() 实例方法：</p><p># Python 2 only</p><p><strong>class</strong> Upper(object):</p><p><strong>def</strong> __init__(self, iterable):</p><p>self._iter <strong>=</strong> iter(iterable)</p><p><strong>def</strong> next(self): # Py2-styface iterator interface</p><p><strong>return</strong> self._iter.next().upper()</p><p><strong>def</strong> __iter__(self):</p><p><strong>return</strong> self</p><p>itr <strong>=</strong> Upper('hello')</p><p><strong>assert</strong> itr.next() <strong>==</strong> 'H' # Py2-style</p><p><strong>assert</strong> list(itr) <strong>==</strong> list('ELLO')</p><p class=ql-align-justify>但在 P3 中统一了使用 next 内置函数来获取下一个元素，如果试图调用 .next() 方法则会触发 AttributeError 异常。所以，在 P3 中实现自定义迭代器所要实现的是 __next__ 特殊方法。</p><p>兼容技巧：</p><p># Python 2 and 3: option 1</p><p><strong>from</strong> future.builtins <strong>import</strong> object</p><p><strong>class</strong> Upper(object):</p><p><strong>def</strong> __init__(self, iterable):</p><p>self._iter <strong>=</strong> iter(iterable)</p><p><strong>def</strong> __next__(self): # Py3-style iterator interface</p><p><strong>return</strong> next(self._iter).upper() # builtin next() function calls</p><p><strong>def</strong> __iter__(self):</p><p><strong>return</strong> self</p><p>itr <strong>=</strong> Upper('hello')</p><p><strong>assert</strong> next(itr) <strong>==</strong> 'H' # compatible style</p><p><strong>assert</strong> list(itr) <strong>==</strong> list('ELLO')</p><p># Python 2 and 3: option 2</p><p><strong>from</strong> future.utils <strong>import</strong> implements_iterator</p><p>@implements_iterator</p><p><strong>class</strong> Upper(object):</p><p><strong>def</strong> __init__(self, iterable):</p><p>self._iter <strong>=</strong> iter(iterable)</p><p><strong>def</strong> __next__(self): # Py3-style iterator interface</p><p><strong>return</strong> next(self._iter).upper() # builtin next() function calls</p><p><strong>def</strong> __iter__(self):</p><p><strong>return</strong> self</p><p>itr <strong>=</strong> Upper('hello')</p><p><strong>assert</strong> next(itr) <strong>==</strong> 'H'</p><p><strong>assert</strong> list(itr) <strong>==</strong> list('ELLO')</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Python2','Python3','区别'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>