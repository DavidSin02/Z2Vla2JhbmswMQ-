<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>如何创建自己的Tracker | 极客快訊</title><meta property="og:title" content="如何创建自己的Tracker - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/aab1214f60164ba18b7fb459483e88ee"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9a1d9c50.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9a1d9c50.html><meta property="article:published_time" content="2020-11-14T20:59:24+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:24+08:00"><meta name=Keywords content><meta name=description content="如何创建自己的Tracker"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9a1d9c50.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>如何创建自己的Tracker</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/aab1214f60164ba18b7fb459483e88ee><p class=pgc-img-caption></p></div><p></p><h2 class=pgc-h-arrow-right>0x00 前言</h2><p>某一天，我正在浏览abuse.ch。这个网站会收集用户提交的恶意/可疑URL，我偶然发现了一些非常有趣的东西。我看到某推特用户Gandylyan1每日上传大量名为Mozi的恶意软件样本（可参阅此文)。此僵尸网络是一IoT P2P僵尸网络，似乎正在疯狂地传播着。当我撰写本文时，Gandy依然在上传样本，目前有24,709个IP上传到abuse.ch。</p><p>该恶意软件非常有趣，并且不是很复杂，同时不是很难理解。它会使用已知exp及暴力破解方式在IoT设备中传播，若它已连接到某IoT设备，则会在该设备上启动http服务，之后将自身上传到随机端口，并将其托管在该IoT设备的IP地址上。接下来该设备开始扫描并攻击网络，当它成功接管另一台设备时，新感染的设备将从先前感染的设备接收Mozi。于是我决定为此僵尸网络构建一个Tracker。</p><p>可惜我的Linux相关知识仅限于我知道ls -la命令功能。但是为僵尸网络构建一个Tracker的想法使我夜不能寐。经过短暂的搜索，我发现了Intezer创建的工具。此工具是一个小型的Python项目，可以让研究人员通过模拟OS环境来伪造出受恶意软件感染的客户端。研究人员所要关注的就是恶意软件通信协议。不需要蜜罐，不需要虚拟机，什么也不需要。之后我在GitHub上搜索了所有开源的恶意软件，发现了Quasar，一款开源RAT。研究该RAT是了解恶意软件，逆向开源恶意软件以及了解其网络相关工作原理的好方法。我们的小实验的绝佳候选人！</p><ul><li>必备知识：</li></ul><ol start=1><li>Wireshark相关的基础知识</li><li>编程相关知识</li><li>Python</li><li>C＃</li></ol><ul><li>所需工具：</li></ul><ol start=1><li>VMWare</li><li>Visual Studio Community</li><li>Python 3.8</li><li>Sublime Text Editor 3</li><li>Dnspy</li><li>De4dot</li></ol><ul><li>目标：</li></ul><ol start=1><li>我们想知道Quasar客户端是如何连接到服务器的</li><li>我们想知道Quasar是如何构造发送给服务器的消息的</li><li>我们想知道是否存在用于处理消息的加密/解密过程</li><li>我们想知道服务器如何处理客户端消息的（因为我们有Quasar的源码，所以这是可能的）</li></ol><p></p><h2 class=pgc-h-arrow-right>0x01 如何阅读Quasar源码</h2><p>我们将下载的Quasar源代码加载到Visual Studio 2019 Community(下载地址)中：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3db05670d2c3422683f011a742e1e9b6><p class=pgc-img-caption></p></div><p>我们对客户端代码，以及如何与其他对象协作都很感兴趣——Common包含各个公用程序，Server包含Server端代码。据我所知，所有C＃程序都以Program.cs开始，所以我们将从此开始，让我们打开Quasar.Client并找到Program.CS文件：</p><p>如果我们右击QuasarClient，然后单击”转到实现”，我们将在此处看到一些有趣的东西：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7147d44a3d5e4011930c1be1d2c68bd6><p class=pgc-img-caption></p></div><p>首先解释从Client类继承的QuasarClient类。其工作是管理客户端中发生的所有事件。它具有专门的函数来处理bot的注册（OnClientState），并读取事件（OnClientRead）以及处理失败事件（OnClientFail）。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed51387e29f9487ea8d42abefda2c656><p class=pgc-img-caption></p></div><p>OnClientState函数尝试发送数据包到服务器。若想了解如何创建该消息，我们可以查看ClientIdentification类的构造函数：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/31f509bb5a314665a180aa288ee62b7a><p class=pgc-img-caption></p></div><p>让我们回到Program.cs ，并查看ConnectClient.Connect：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b18a88be699544f6a543f2b17fd06a3b><p class=pgc-img-caption></p></div><p>这使我们回到了Client类：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c90ad298db342238b500ee8936a765d><p class=pgc-img-caption></p></div><p>这应该是我们第一个目标的答案！若要启动连接，客户端首先会建立一个SSL流，然后可能使用ValidateServerCertificate回调函数和AuthnticateAsClient正在进行某种形式的验证。让我们暂时先不管这些，因为我们只是在探索代码的工作方式。接下来会发生什么？如果我们通过Client基类访问OnClientState，这将导致我们进入事件处理程序本身，那么若要找到触发该事件的函数，我们必须转到QuasarClient.cs并通过其查看该函数的实现。如我们之前所见，OnClientState函数触发了client.Send函数：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de75ce25bd4c4da09d50e935210606d1><p class=pgc-img-caption></p></div><p>说实话，我不懂C＃，但是我在这里通过我的直觉看到唯一有价值的东西是ProcessSendBuffers，所以让我们查看下，看看是否能有所收获：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/015ad86647594fc2960708f2f6523e3b><p class=pgc-img-caption></p></div><p>使用与之前相同的策略，让我们查看下SafeSendMessage：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddca9ae977bd459c8493857d19f063e1><p class=pgc-img-caption></p></div><p>现在我们暂且不访问OnClientWrite，因为我担心它不会带我们到我们想要的地方去。我们可以查看位于PayloadWriter类中的WriteMessage：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/13ef36146f894d6f93d64e23f27d2deb><p class=pgc-img-caption></p></div><p>该函数会将序列化消息（我稍后会解释什么是序列化）写入SSL数据流！因此，让我们通过一张流程图来说明我们的发现：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9f1e5187a86b4f299797df3408af74c9><p class=pgc-img-caption></p></div><p>上图是非常浅显且不完整的，随着我们进行动态分析，我们可以在该图上进行扩充，因此让我们在Visual Studio中编译Quasar项目，并将编译后文件移至虚拟机并开始研究它。</p><p></p><h2 class=pgc-h-arrow-right>0x02 分析Quasar样本</h2><p>编译Quasar项目并将其移至虚拟机后，即可启动Quasar：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9dbb838ae8b242368c715508bc4a2c06><p class=pgc-img-caption></p></div><p>此时屏幕应该会弹出一消息框，该消息用于构建X509证书(非常重要)。该证书负责在客户端和服务器之间创建有效的SSL数据流。Quasar会生成一个X509证书并将该证书绑定到所有生成的客户端。可以在此处了解有关SSL的更多信息。</p><p>生成证书后，就可以构建样本了，单击Builder然后使用builder菜单进行相关配置，其中最重要的部分如下所示：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a20865afe4f947fab9b3b4c69d599850><p class=pgc-img-caption></p></div><p>这里有2个IP：一个是本机回送地址，另一个是该虚拟机IP。我建议将客户端绑定到当前虚拟机IP，因为这样可以模拟从当前虚拟机与外部主机服务器的连接（主机也是VMWare本地网络中的一员）。您可以使用任何您喜欢的端口，这里我使用了27015端口。生成客户端后，您应该可以在当前目录看到它。我们将其在dnspy中打开(dnspy是.NET反编译器)：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/82b01669f7b24da1906487aeec6911db><p class=pgc-img-caption></p></div><p>但是我们遇到了代码混淆，不用担心，我们可以使用de4dot，它是个.NET反混淆工具，运行它之后，我们可以得到一个去混淆的Quasar客户端：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b2f32be97254846bdf71073bbfaf20c><p class=pgc-img-caption></p></div><p>尽管我们的Quasar客户端代码是去混淆后的，但符号已经消失了，不用担心，因为我们拥有完整的源代码，所以接下来让我们开始调试。我只想验证我的流程图是否正确，所以让我们单击开始调试，然后在入口点设置一个断点（我强烈建议根据源代码重命名这些函数和类名，但是由于调试了许多次，我对此已经非常熟悉了）。请确保Quasar服务端正在运行中。我们将在Class0.smethod_3()遇到第一个问题，这是第二个初始化方法：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eb108d2a39ae4fa0a1416788357f1149><p class=pgc-img-caption></p></div><p>它不会返回True，从而导致客户端无法正确执行和退出。但是为什么会这样？让我们看一下源码：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57957f35ff01476986dc282de74ede00><p class=pgc-img-caption></p></div><p>上图中标红的if语句，会在初始化后通过返回true来安装并将客户端连接到服务器，但由于此时客户端正在运行的current path不等于install path，所以它不会执行。要理解上述说明，需要回到Builder：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ffe776b90f3f43cca8f9570964c28a4a><p class=pgc-img-caption></p></div><p>因此，此代码块会检查客户端当前是否正在AppdataRomaing目录下运行(于本文的情况下)，如果没有，它将执行以下代码：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8dbe3f7c279d46a9822aade4b2323e79><p class=pgc-img-caption></p></div><p>此代码会处理两个问题：其一是客户端检测到另一个Quasar实例正在运行，通过检测互斥体；其二是客户端已安装到受害主机中，但实现了持久化，此时会终止进程并删除该文件，然后将其移至我们指定的install文件夹后重新启动。您可以查看Install方法自行研究，因为源码已经给出。它使得研究人员可以真正了解如何开发恶意软件。下面让我们做两件事：</p><ol start=1><li>更新我们的流程图</li><li>将客户端移动到指定的安装目录并启动</li></ol><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8133e28dcec741718e3e039040b57d43><p class=pgc-img-caption></p></div><p>让我们从预设的安装目录中调试客户端，看看会发生什么，请确保Quasar服务端正在运行。此外，我启动了Wireshark来监视流量（下图是我自己的设置，IP地址及端口在您的计算机上将会有所不同）：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e20058fdfd54844996ea834a96a1f84><p class=pgc-img-caption></p></div><p>我将从AppdataRoaming目录重新启动客户端，然后直接跳到Client.Connect函数：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dab8fe0925544f8f8823a829e51334aa><p class=pgc-img-caption></p></div><p>这次我们恰好到达了想要的位置(专家提示：您可以右键单击dnspy对象并更改其名称) 。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/145bc6e0d4574eb681ecd7f852474fe8><p class=pgc-img-caption></p></div><p>这里有三处重点，首先是RemoteCertificationValidationCallBack——它将验证从服务器接收到的证书，数据流读取函数和OnClientState函数。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/805ea1b0bb574e8d8f225a81715883e4><p class=pgc-img-caption></p></div><p>所以socket.Connect函数应该将客户端成功连接到服务器并进行第一次TCP握手：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e142c540338243c5a7220a48c17fc07a><p class=pgc-img-caption></p></div><p>接下来，我想研究执行到第287行时发生了什么：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d7173661a3974fe8a6521c620fd680fa><p class=pgc-img-caption></p></div><p>这是一个SSL握手，但是发生的是服务器将X509证书传给了客户端，并且客户端认证了该证书，并且这是在RemoteCertificationValidationCallBack内部发生的。让我们查看一下它的源码：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d944ffc8b8d646eea0c805621918e90d><p class=pgc-img-caption></p></div><p>正如您在else语句中看到的那样(在关闭调试模式的情况下编译会进入此语句)，该函数会检查客户端证书和服务器证书是否匹配。但是，看看在调试模式下发生了什么——它只会返回true，并且发生在客户端……我们的客户端可以执行同样的操作以启动与服务器的有效SSL通信。让我们记住这一点并继续。接下来发生的事情有些棘手，在Client类的第290行中，将调用OnClientState，但是因为从Client类中调用了OnClientState，所以事件注册功能会生效，而事件处理功能将不会生效：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/faeede725ee94bf48eab5f88405e9b1c><p class=pgc-img-caption></p></div><p>我们必须手动找到QuasarClient类，然后从那里进入到OnClientState 函数(我建议读者多读几次源码并充分理解其含义，这对于理解其工作原理有相当大的帮助)。但我们应该如何找到它？答案很简单，让我们回到Class0，即Program.cs</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f465068779c4048845f66ef86b943bb><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/09b7049d6c1740caa468d025a950a8d4><p class=pgc-img-caption></p></div><p>因此，Gclass27是QuasarClient，为其重命名以便之后找到它更方便，接下来我们将通过双击该类并尝试手动查找OnClientState来访问该类：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a2bd82348d6f4ed98345b0d73ba2c06a><p class=pgc-img-caption></p></div><p>让我们在第79行设置一个断点，并在之前的PayloadWriter WriteBytes函数内设置一个断点，该函数位于Stream1的method02。在第79 行，创建Class18，然后将其传递给send函数中。Class18在Quasar源码中为ClientIdentification：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7dcfd14b52a340d18fcf490c256f67ae><p class=pgc-img-caption></p></div><p>这是消息构造函数，如果我们继续执行到 payload writer，可以看到该消息的内容：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3085ebfe826f442d825443d52994c452><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b91b9d7715ef4cb4bca6c78742c280dc><p class=pgc-img-caption></p></div><p>我们仅是截取了整个消息。但是我注意到一些奇怪的事情——ClientIdentification类中只有14个成员，为什么这里却有28个成员？</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/532eabb0018844ceaedd169524a1ea1a><p class=pgc-img-caption></p></div><p>另外，在第38行中，会将消息复制到数据流中并进行序列化，然后发送消息的长度，以及由序列化函数返回的原始字节。我尝试查看序列化后消息的内容。首先，让我们调试该程序到第40行，右键单击该变量，然后选择show memory window，以查看该数组变量的内容：</p><p>除了一些文本内容，其它的部分没有任何意义。</p><p></p><h2 class=pgc-h-arrow-right>0x03 消息序列化与Google Protocol Buffer</h2><p>为了节省读者时间，我简单解释下什么是序列化。序列化是一种压缩消息大小并提高处理效率的方法。序列化有诸多类型——其中一种是将消息压缩为json格式或XML格式，然后将其发送，接收方会按照预先约定好的协议对消息进行反序列化。可以在此处了解有关序列化的信息。</p><p>Quasar使用了由Google开发的Protobuf，Protobuf是一消息序列化程序。（希望您在看完上述视频后明白其原理）</p><p>这就是我们之前看到的这些ProtoMember：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5bbf9e278d3d4ecd92e791cb2855aa71><p class=pgc-img-caption></p></div><p>该C＃类是基于ProtoContract定义的，使得编译器在生成这14个成员时会同时生成google protobuf消息。这就是为什么每个类成员都有一个原型成员。现在，protobuf协议会以不同的方式压缩每种类型(int32，int64，字符串)，所以我们会在消息中看到很多奇怪的字节。到这里基本上已经可以回答我们之前设定的目标1-3。</p><p>很明显，下一步我们要做的是：</p><ol start=1><li>创建一个启动SSL连接的python脚本</li><li>验证客户端和服务器之间的连接</li><li>生成一个protobuf消息，并且可以与生成客户端发送的消息匹配。</li></ol><p>关于第3点，我们可以假设消息的重要部分是Tag，Signature和EncryptionKey成员，根据我进行的测试，它们必须保持不变并与生成的客户端完全匹配。因为Signature和EncrpytionKey是包含X509证书信息的成员。</p><p></p><h2 class=pgc-h-arrow-right>0x04 如何使用Python生成Protobuf消息</h2><p>幸运的是，Google提供了一个使用Python生成protobuf消息的编程接口以及教程。</p><p>我精心设计了一条消息来启动与服务器的SSL连接：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a5166575ecea4343ba12441e4b79eb27><p class=pgc-img-caption></p></div><p>首先，消息内容很简单，它包含14个成员，这些成员与Quasar客户端发送的消息完全匹配。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b47e8a1efa904178aab7c50498766768><p class=pgc-img-caption></p></div><p>该脚本会创建SSL socket，并通过始终在每个证书上返回1来来处理验证问题。尽管这是作弊，但我们是Hackers。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/88d0d7d9c5b346c3b7efd89dfa024bc1><p class=pgc-img-caption></p></div><p>接下来让我们生成一条消息并将其序列化。请记住，必须在其后附加4个little endian字节——代表消息的总长度。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fc088458ef3740c482d5ac737297a97f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/820ea2b5bf7e476ea35c7ae667329eda><p class=pgc-img-caption></p></div><p>因此，我创建了一个简单的函数，它将返回该值并将其添加到序列化消息前缀中。现在我们可以生成消息，进行序列化并输出内容，看看它是否与Quasar客户端生成的内容匹配：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7c0506003fb54692b2cd6877ac817c0d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b67a8b5857442648ca727317f7266f1><p class=pgc-img-caption></p></div><p>如您所见，生成消息有问题。Python生成的消息与客户端生成消息(除0x0A，0xCF，0x05之外)完全匹配(忽略前缀0xdf 0x02 0x00 0x00)。这些字节是什么？我不知道，所以我在stack overflow上提出了相关问题。</p><p>经过些许研究，我确定该前缀只能是消息的长度。Python生成的消息其余部分与客户端生成的消息完全匹配。另外，如果我们编辑Quasar客户端生成的消息，则随着我们增加消息的长度，该前缀字段将会改变。让我们再次调试生成的Quasar客户端，并在发送消息之前于第36行中断Payload Writer函数，于任意一个字段中添加任意数量的字符”A”来改变消息内容：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/76a99a6385f84288803054a973e4b5c3><p class=pgc-img-caption></p></div><p>如上所示，消息已更改，第二个字节从0xcf变为0xf5。0xF5与0xCF之间差38，这正是我添加的字符”A”的数量。若要准确计算出长度，我们必须了解对该字节序列进行编码的工作原理，幸运的是，Google并未对此保密(参考)，另外这里也给出了答案。</p><p>我不会详细解释整个过程的工作原理，但是理解它对于我们目标的实现是有益的。Google Protobuf是开源项目，故我们无须从头开始重新实现。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/779ad30b6817451db83c685b265ce977><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9e4dbef17673476b8538975a5d9d752b><p class=pgc-img-caption></p></div><p>在这两个代码块中，我将序列化一条消息并将其长度传递给我从protobuf项目中”借用”的函数。我对其进行了一些修改，使其始终位于最终结果的0x0A字节之前，最终结果表示字段编号和字段类型。由于该消息是我们生成的消息的前缀，因此其类型始终为2（length prefix）以及编号为1：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2fd7609c4dfa4654b896dee71f4f6c53><p class=pgc-img-caption></p></div><p>现在，我们使用python生成的消息与Quasar生成的消息完全匹配。</p><p>接下来转到连接部分：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/557cbdf8e9dc480a9aea140bb8693241><p class=pgc-img-caption></p></div><p>以上代码块将连接到我们的服务器并与其进行握手。服务器将对其进行X509认证，然后我们的验证功能将会被触发：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04126d4f82e0468eb3fc29dc15316afa><p class=pgc-img-caption></p></div><p>它始终返回True。然后，我们将生成序列化的消息，并以消息的长度加序列化后消息的长度作为前缀：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/afad34e9aeee41c9b4c7219b93ac30af><p class=pgc-img-caption></p></div><p>首先在第97行，我将消息序列化。然后，我在消息中附加一个代表消息长度的前缀。最终，我计算了包括前缀在内的消息总长度，转换为小端序格式，并将其附加在序列化消息中。发送该消息到服务器，我们可以在Wireshark中查看此消息：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba83d4208a4b43be9b3bdbeb2063b51e><p class=pgc-img-caption></p></div><p>如果检查我们的Quasar服务端，可以看到：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57800ea883224eb6bb750b2b5242519c><p class=pgc-img-caption></p></div><p>我已经发送了一条自定义消息，没有问题！现在，我开始学习Intezers工具的工作原理，以便将我的Python脚本完善成为完整的Quasar RAT Tracker。</p><p>脚本完整代码可以在这里找到。</p><p></p><h2 class=pgc-h-arrow-right>0x05 为Intezers Puppets创建Quasar插件</h2><p>由于Intezer并未在该工具上投入过多心血，所以这一部分会比较棘手，但我会尽力解释该工具的工作原理，为您节省时间，因为我相信该工具对于跟踪恶意软件具有巨大价值。</p><p>Puppets是一组Python脚本，可以模拟出一个完整的OS环境，从而节省了研究人员构建蜜罐或虚拟机环境所需要的时间和资源。现在，我们不需要构建完整的OS与内核以及引导项，因为大多数恶意软件都希望与特定的用户模式应用程序和文件系统进行交互，而这些程序很容易模拟！Puppets附带了许多实用脚本与处理程序，这些脚本和处理程序将模拟基本功能以处理恶意软件——例如连接，注册，发送，接收等等。研究人员唯一要做的工作就是为特定恶意软件创建插件，其它工作都可以交由该工具来处理。我想引导读者阅读代码，并共同创建一个图表，以帮助开发人员了解该工具的工作原理。首次下载MoP以及从这里下载我的自定义插件quasar.py，targets.yaml，utils.py。</p><p>接下来，请按照此处的安装指南进行操作。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/312bdee6256c4a6e92dded0fe3daab99><p class=pgc-img-caption></p></div><p>打开orchestrator.py，删除第一行#!/usr/bin/env python3.6，因为它会使该工具无法在Python 3.6以外的其他环境中运行。这是该工具的核心部分。来到第46行，您将看到一个command parser，在本例中，我们将使用第53行的选项–targets-config，该选项允许此工具连接到多个客户端，因此请打开targets.yaml并删除其中的相关hash。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bbcc77b3a44f44a8a341923d746e61a1><p class=pgc-img-caption></p></div><p>我已经将其设置为与我的Quasar实例一起运行，但是由于尚未设置插件，因此您可以使其保持原样。该工具会通过指定目标IP，端口和插件来设置多个目标。</p><p>让我们回到核心脚本：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e7784b1e07924401ba85f3119271db1f><p class=pgc-img-caption></p></div><p>在第54行，对targets.yaml文件进行了解析，并提取其内容。然后调用函数connect_targets()：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49ff03884f8443c189dd663c5e753ed1><p class=pgc-img-caption></p></div><p>对于targets.yaml文件中的每个目标执行connect()函数：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/95e86e21f15b4e418642f221ce1df4b2><p class=pgc-img-caption></p></div><p>connect()函数位于第22行，它使用_connect()回调函数启动线程，并将ip，port和plugin传递给该函数。_connect在第27行被调用。首先，它从plugin文件夹中导入一个插件，然后在第29行，使用插件构造函数连接到RAT，接下来调用插件的connect，register和loop函数。创建的所有插件扩展了puppet_rat.py中类的所有属性。因此，让我们查看下：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/869466b678324b74b84d9a35ef7c5576><p class=pgc-img-caption></p></div><p>于第16行，我们可以看到该类的构造函数，就像之前在核心脚本中看到的那样，于第29行被触发。第16行的构造函数设置了客户端属性——ip，端口，伪进程ID，记录所有事件的记录器和用于表示套接字的conn变量。最重要的功能是：</p><ol start=1><li>connect用来实现从客户端到服务器的连接</li><li>register用来实现注册功能</li><li>loop用来等待服务端发送命令</li></ol><p>接下来我们对该脚本进行测试。首先我们从最简单的事情开始，让我们修改target.yaml文件以满足我们的需求，可以在上文找到示例。接下来，请下载quasar.py和clientidentity_pb2.py，将它们放到plugins文件夹中。</p><p>现在，我会逐行回顾我的插件代码：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e704307388e44a08d8b7604446da670><p class=pgc-img-caption></p></div><p>首先，让我们来看下构造函数——它扩展了PuppetRat类，从而继承了其所有属性。我添加了message成员，以便可以随时对其进行编辑。用户必须自己设置的是Tag，EncryptionKey和Signature，它们在客户端之间传输。另外，我添加了一个名为message的protobuf消息成员，在第70行可以看到。它创建了未初始化的Quasar消息。</p><p>同时我增加了4个自定义函数，这些函数使研究人员可以更改tag，id，key及signature，并且可以生成和设置protobuf消息。函数__del__是一标准的Python函数，当对象被销毁时执行——它会关闭为Quasar创建的连接。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d3f47a53e22740bca026bc8977fe4dce><p class=pgc-img-caption></p></div><p>重新实现的connect函数——该函数与测试脚本中的非常相近。在我们阅读其源码 之前，请先从我的Github上下载utils.py文件，并将其放置在stage props文件夹中。在第112行，创建一个tcp套接字，然后将该套接字绑定到SSL套接字。create_ssl_sock是一个添加到utils脚本中的自定义函数。就像在我们的测试脚本，它所做的只是创建一个SSL套接字并将其绑定，以便我们可以验证Quasar证书。然后，连接到Quasar服务器并尝试进行握手。如果一切顺利，logger会显示一正确的消息。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab84c69edc5d4e169ee44fcf96eb5d3e><p class=pgc-img-caption></p></div><p>接下来，我们来看loop函数，该函数功能非常简单，它所做的只是从服务器接收消息并显示它们。</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6820daca3e3d4d19a152b163d1c8f38e><p class=pgc-img-caption></p></div><p>我们继续看register函数，这是最后一个函数，它所做的只是模仿测试脚本。它会构造一个Quasar消息并发送到服务器。正如我之前说过的，我不会对此做过多介绍。</p><p>最后，让我们看看脚本是如何运作的！</p><p>开启您的虚拟机并启动Quasar服务器，然后于MoP中打开一个Shell并输入下列命令：</p><pre><code>py orchestrator.py –targets-configtargets.yaml</code></pre><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/56ecec3566d3415192f8b87efcc718f0><p class=pgc-img-caption></p></div><p>让我们看看如果服务端命令客户端打开一消息框会发生什么：</p><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a807972c957433493f89fb4a5817d2b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=如何创建自己的Tracker onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9589b0357532418f95850cfbcc5bfcc2><p class=pgc-img-caption></p></div><p>如您所见，我们收到了一条需要反序列化的新消息。这将需要更多的努力，但根据您目前所学知识，应该不会太难。本文翻译自 0x00sec.org， 原文链接 。如若转载请注明出处。可以私信我们，有优惠大礼包和免费课程学习。<a class=tteditor-mention data-concern-id data-id data-name=安界人才培养计划 data-uid=3443310982085820>@安界人才培养计划</a><a class=tteditor-forum data-concern-id=1630858953410567 data-id=1630858953410567 data-name=网络安全在我身边 data-uid>#网络安全在我身边#</a><a class=tteditor-forum data-concern-id=1669559494056983 data-id=1669559494056983 data-name=小白入行网络安全 data-uid>#小白入行网络安全#</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'创建','Tracker','如何'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>