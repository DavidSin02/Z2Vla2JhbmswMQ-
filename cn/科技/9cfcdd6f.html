<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>《JAVA编程思想》5分钟速成：第8章（多态） | 极客快訊</title><meta property="og:title" content="《JAVA编程思想》5分钟速成：第8章（多态） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9cfcdd6f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9cfcdd6f.html><meta property="article:published_time" content="2020-11-14T21:08:07+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:07+08:00"><meta name=Keywords content><meta name=description content="《JAVA编程思想》5分钟速成：第8章（多态）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9cfcdd6f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>《JAVA编程思想》5分钟速成：第8章（多态）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>第8章 多态（Polymorphism）</strong></p><p>多态：也称作动态绑定、后期绑定或运行时绑定。</p><p>OOP编程的三个基本特征：数据抽象、继承（复用）、多态。</p><p><br></p><p><strong>8.1 方法调用绑定（Method-call binding）</strong></p><p>将一个方法调用与一个方法主体关联起来称作绑定。Connecting a mehtod call to a mehtod body is called binding.</p><ul><li><strong>方法重载（overload）实现的是编译时的多态性（也称为前绑定）；</strong></li><li><strong>方法重写（override）实现的是运行时的多态性（也称为后绑定）。</strong></li></ul><p><strong>前期绑定：</strong>在程序执行前进行绑定（如果有的话，由编译器和连接程序实现）。</p><p>它是面向过程语言中不需要选择就默认的绑定方式。例如，C只有一种方法调用，那就是前期绑定。</p><p>When binding is performed before the program is run (by the compiler and linker, if there is one), it’s called early binding. You might not have heared the term before because it has never been an option with procedural language. C compilers have only one kind of method call, and that’s early binding.</p><p><br></p><p><strong>后期绑定：</strong>就是在运行时根据对象的类型进行绑定。后期绑定也叫做动态绑定或运行时绑定。</p><p>如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。也就是说，编译器一直不知道对象的类型，但是方法调用机制能找到正确的方法体，并加以调用。</p><p>The solution is called late binding, which means that the binding occurs at run time, based on the type of object. Late binding is also called dynamic binding or runtime binding. When a language implements late binding, there must be some mechanism to determine the type of the object at run time and to call the appropriate method. That is, the compiler still doesn’t know the object type, but the mehtod-callmechanism finds out and calls the correct method body. The late-binding mechanism varies from language to language, but you can imagine that some sort of type information must be installd in the objects.</p><p><br></p><p><strong>再谈final方法（非多态）：</strong></p><p>如Chapter7所说，final方法可以防止其他人覆盖该方法。但更重要的一点是：这样做可以有效地“关闭”动态绑定，或者说，告诉编译器不需要对其进行动态绑定。</p><p>Why would you declare a method final? As noted in the last chapter, it prevents anyone from overriding that method. Perhaps more important, it effectively “turns off” dynamic binding, or rather it tells the compiler that dynamic binding isn’t necessary.This allows the compiler to generate slightly more efficient code for final method calls. However, in most cases it won’t make any overall performance diffeence in your program, so it’s best to only use final as a design decision, and not as an attempt to improve performance.</p><p><br></p><p><strong>8.2 域与静态方法（非多态）</strong></p><p><strong>域是不具有多态性的，只有普通的方法调用是多态的。</strong></p><p>如果直接访问某个域，这个访问就将在编译期进行解析，即域是静态解析的。</p><p>eg: 当Sub对象转型为Super引用时，任何域访问操作都将由编译器解析，因此不是多态的。Super.field和Sub.field分配了不同的存储空间。这样，Sub实际上包含两个称为field的域：它自己的和它从Super处得到的。</p><p><strong>静态方法也不具有多态性的</strong>。</p><p>如前文所述，静态方法是与类，而非与单个的对象相关联的。</p><p><br></p><p><strong>8.3 构造器内部的多态方法的行为（慎用！）</strong></p><p>如果在构造器内部调用正在构造的对象的某个动态绑定方法，由于动态绑定是在运行时才决定的，而此时，该对象还正在构造中，所以它不知道自己属于哪个类（父类还是自己），并且方法所操纵的成员可能还未进行初始化，这可能会产生一引起难于发现的隐藏错误。</p><p><strong>8.3.1 构造器编码原则：</strong></p><p>1. 尽可能的简单的方法，慎用重载方法；</p><p>2. 安全调用：使用final或private方法；</p><p><br></p><p><strong>8.3.2 协变返回类型（Java SE5新增）：</strong></p><p><strong>允许@override的重写方法，可以返回super.method()的return类型的派生类型。</strong></p><p><br></p><p><strong>8.4 初始化的实际顺序（由内到外&递归方式执行构造！）</strong></p><p>step1: 在其他任何事物发生之前，将分配给对象的存储空间初始化成二进制的零。</p><p>step2: 调用父类的构造过程（<strong>递归方式：同派生类的step1&2&3&4</strong>）。</p><p>step3: 按照声明的顺序调用成员变量的初始化。</p><p>step4: 调用导出类（派生类）的构造器主体。</p><p><br></p><p><strong>8.5 继承和清理的顺序</strong></p><p><strong>8.5.1 构造&普通方法的区别：</strong></p><p>构造方法：可不主动调用super.构造()，如显式调用，需要放在构造方法第一行；</p><p>普通方法：需自行主动调用super.method()，否则不会自动执行！</p><p><br></p><p><strong>8.5.1 构造&清理顺序的区别：</strong></p><p>构造初始化：先执行super.构造()，再执行派生类的构造方法；</p><p>清理（相反）：先执行派生类的清理方法，再执行基类的清理方法；（WHY？？？）</p><p><br></p><p><strong>8.6 用继承进行设计</strong></p><p>继承：编译时，已确定具体类型；</p><p><strong>组合：更灵活的编码设计（建议优先选择），非写死的代码层次结构；</strong></p><p><br></p><p><strong>8.6.1 纯继承&扩展</strong></p><p><strong>方式1：纯继承（is-a）：</strong></p><p>特征：只@override 基类已有的方法：super.method()，不新增其他方法；</p><p>优点：向上转型是安全的（子类不含额外信息）。</p><p><br></p><p><strong>方式2：扩展继承（is-like-a）：</strong></p><p>特征：派生类 新增其他方法；</p><p>优点：向上转型时会丢失子类信息（子类含额外信息）。</p><p><br></p><p><strong>8.6.2 向下&向上转型和RTTI：</strong></p><p><strong>向上转型（downcasting）：</strong>安全的，类似于基本数据类型的窄向转换；</p><p><strong>向下转型（upcasting）：</strong>不安全的，类似于基本数据类型的宽向转换（可能会调用到super中并不存在的方法）；</p><p><strong>RTTI: Runtime type indentification（运行时类型识别）</strong>，Java中所有的类型转换（casting）都会执行，异常时throws ClassCastException.</p><p><br></p><div class=pgc-img><img alt=《JAVA编程思想》5分钟速成：第8章（多态） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07><p class=pgc-img-caption></p></div><p>相关文章：</p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6789864124068135435/?group_id=6789864124068135435" target=_blank>《JAVA编程思想》5分钟速成：第9章（接口）</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JAVA','编程','分钟'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>