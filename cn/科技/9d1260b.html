<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法｜递归：参数、局部变量的顺序迭代与逆序迭代 | 极客快訊</title><meta property="og:title" content="算法｜递归：参数、局部变量的顺序迭代与逆序迭代 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d8444de81c144296961706ff110faad6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9d1260b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9d1260b.html><meta property="article:published_time" content="2020-10-29T20:52:58+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:58+08:00"><meta name=Keywords content><meta name=description content="算法｜递归：参数、局部变量的顺序迭代与逆序迭代"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9d1260b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法｜递归：参数、局部变量的顺序迭代与逆序迭代</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>迭代使用单一关系式，要考虑迭代次数或结束条件，分精确迭代（如最大公约数）和近似迭代（如求平方根）。</p><p>递推的递推变量和递推关系式（包含初始表达式，已知条件或结果，形成初始或边界条件），分为顺推（如斐波那契数列）、逆推（如五猴分桃）。</p><p>由编译器隐式实现一个函数调用栈，函数可以自己调用自己，参数之间相互迭代，所以使用递推法能解决的问题也可以通过递归法来解决，递推形成递归的一个阶段。递归调用语句前的部分，一般包含返回的边界条件及其它部分，可用一个局部变量及参数顺序迭代的循环来简单代替，即递推阶段；递归语句本身即回归阶段；递归调用语句的后面部分，可用一个局部变量及参数逆序迭代的循环来代替，但需要程序员自己维护一个显式栈来记忆参数、局部变量和返回值。</p><pre><code>#include &lt;stdio.h&gt;void counting(int n){    int lv=10;    lv*=n;    if(n&gt;3)        return;    printf("递归调用语句前面部分数据的顺序输出，参数n和局部变量lv：%d,%d\n",n,lv);    counting(n+1);    printf("递归调用语句后面部分数据的逆序输出，参数n和局部变量lv：%d,%d\n",n,lv);}int main(){    counting(1);    getchar();    return 0;}/*递归调用语句前面部分数据的顺序输出，参数n和局部变量lv：1,10递归调用语句前面部分数据的顺序输出，参数n和局部变量lv：2,20递归调用语句前面部分数据的顺序输出，参数n和局部变量lv：3,30递归调用语句后面部分数据的逆序输出，参数n和局部变量lv：3,30递归调用语句后面部分数据的逆序输出，参数n和局部变量lv：2,20递归调用语句后面部分数据的逆序输出，参数n和局部变量lv：1,10*/</code></pre><p>其顺序如下：</p><div class=pgc-img><img alt=算法｜递归：参数、局部变量的顺序迭代与逆序迭代 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8444de81c144296961706ff110faad6><p class=pgc-img-caption></p></div><p>在逆序时为什么能够记忆参数值和局部变量？</p><p>函数调用时编译器使用了一个隐式栈，每一个函数使用一个栈帧来记录需要返回的函数地址、参数值、局部变量值。为了能够在出发后经过一系列调用能回到最初的出发地，需要一个后进先出的数据结构，这就是栈。</p><p>当递归用递推的循环来实现时，对于递归调用语句后面的部分，需要由程序员使用一个显式栈来记录参数值和局部变量，并逆序输出：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stack&gt;using namespace std;typedef struct Node{     int para1;    int lv1;}node; // 用一个结构体为保存参数与局部变量void counting2(int n){    stack&lt;node&gt; sf;    int init = n;    while(n&lt;=3)    {        int lv=10;        lv*=n;        printf("数据的顺序输出，参数n和局部变量lv：%d,%d\n",n,lv);        node newnode = {n,lv};        sf.push(newnode); // 压栈操作，后面要逆序输出数据        n++;    }    while(!sf.empty())    {        node newnode = sf.top();        printf("数据的顺序输出，参数n和局部变量lv：%d,%d\n",newnode.para1,newnode.lv1);        sf.pop();     }    }int main(){    counting2(1);    getchar();    return 0;}/*数据的顺序输出，参数n和局部变量lv：1,10数据的顺序输出，参数n和局部变量lv：2,20数据的顺序输出，参数n和局部变量lv：3,30数据的顺序输出，参数n和局部变量lv：3,30数据的顺序输出，参数n和局部变量lv：2,20数据的顺序输出，参数n和局部变量lv：1,10*/</code></pre><p>如浮点数的二进制编码输出：</p><p>十进制整数部分：除二取余，逆向处理。</p><p>十进制小数部分：乘二取整，顺向处理。</p><pre><code>#include&lt;stdio.h&gt;#include&lt;math.h&gt;#define N 16void itobin(int n){	if(n==0)		return;	itobin(n/2);	printf("%d",n%2);}void ftobin(double x){	for(int i=1;i&lt;=N;i++)	{		x*=2;		if(x&gt;=1.0)		{			x-=1;			printf("1");		}		else			printf("0");	}}void main(){    int a[N+1],b[N+1],i,k=0,value;    float x;    double ipart;    for(i=0;i&lt;=N;i++)        b[i]=0;    printf("请输入一个十进制小数:");    scanf("%f",&amp;x);    x=modf(x,&amp;ipart);//x为小数部分，ipart为整数部分    value=(int)ipart;    while(value)      // 十进制整数部分：除二取余    {        b[k++]=value%2;        value/=2;    }	float d = x;    for(i=1;i&lt;=N;i++) // 十进制小数部分：乘二取整    {        x*=2;        if(x&gt;=1.0)        {            x-=1;            a[i]=1;        }        else            a[i]=0;    }    printf("二进制数:");    for(i=k;i&gt;=0;i--)     // 逆向输出整数        printf("%d",b[i]);    printf(".");    for(i=1;i&lt;=N;i++)     // 顺向输出小数    {        if(a[i]==0)            printf("0");        else            printf("1");    }    printf("\n");	itobin(ipart);	printf("\n");	ftobin(d);	getchar();getchar();}/*请输入一个十进制小数:22.62525二进制数:010110.1010000000010000101101010000000010000*/</code></pre><p><strong>附整数与浮点数的表示与存储：</strong></p><p>对于浮点数的存储，却是用记阶法表示的，如：</p><p style=text-align:start>+1001.011B = + 0.1001011B×2^ 100</p><p style=text-align:start>-0.0010101B = -0.10101B×2^－10</p><p style=text-align:start>可见，任一个二进制实数 N 均可表示为：</p><p style=text-align:start>N=±S×2^P</p><p style=text-align:start>其中， ±是该数的符号； S是N 的尾数；P是N的阶码。</p><p style=text-align:start>因此，32位的单精度浮点数在计算机中可表示为：</p><p style=text-align:start>由于指数（阶码）可以选用不同的编码（原码、补码等），尾数的格式和小数点位置也可以有不同的规定，因此早期计算机中浮点数的表示方法互不相同。</p><p style=text-align:start>现代计算机中，一般都以IEEE 754标准存储浮点数，这个标准的在内存中存储的形式为：</p><p style=text-align:start>对于不同长度的浮点数，阶码与小数位分配的数量不一样，如对于32位的单精度浮点数，数符分配是1位，阶码分配了8位，尾数分配了是23位：</p><div class=pgc-img><img alt=算法｜递归：参数、局部变量的顺序迭代与逆序迭代 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/17a385371be64d359c3ce8dd01360021><p class=pgc-img-caption></p></div><p style=text-align:start>符号位：0表示正；1表示负；</p><p style=text-align:start>偏移阶码e：e=指数的实际值+127。</p><p style=text-align:start>假有一个浮点数10110010.001，则指数是7，阶码就要用7+127的二进制数表示，也就是：111+01111111 = 10000110</p><p style=text-align:start>尾数使用原码表示，绝对值在1与2之间，其中1和小数点都是隐含的，并不直接表示。</p><div class=pgc-img><img alt=算法｜递归：参数、局部变量的顺序迭代与逆序迭代 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/84a44654ebd54952bf53b76ec2feaff0><p class=pgc-img-caption></p></div><p style=text-align:start>根据这个标准，我们来尝试把一个十进制的浮点数转换为IEEE754标准表示。</p><p style=text-align:start>例如：178.125</p><p style=text-align:start>先把浮点数分别把整数部分和小数部分转换成2进制：</p><p style=text-align:start>整数部分用除2取余的方法，求得：10110010</p><p style=text-align:start>小数部分用乘2取整的方法，求得：001</p><p style=text-align:start>合起来即是：10110010.001</p><p style=text-align:start>转换成二进制的浮点数，即把小数点移动到整数位只有1，即为：1.0110010001 * 2^111，111是二进制，由于左移了7位，所以是111</p><p style=text-align:start>把浮点数转换二进制后，这里基本已经可以得出对应3部分的值了：</p><p style=text-align:start>数符：由于浮点数是正数，故为0(负数为1)。</p><p style=text-align:start>阶码 : 阶码的计算公式：阶数 + 偏移量, 阶码是需要作移码运算，在转换出来的二进制数里，阶数是111(十进制为7)，对於单精度的浮点数，偏移值为01111111(127)[偏移量的计算是：2^(e-1)-1, e为阶码的位数，即为8，因此偏移值是127]，即：111+01111111 = 10000110</p><p style=text-align:start>尾数：小数点后面的数，即0110010001</p><p style=text-align:start>最终根据位置填到对位的位置上：</p><div class=pgc-img><img alt=算法｜递归：参数、局部变量的顺序迭代与逆序迭代 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4a14878ead8d4c09bf6b452f650eaec9><p class=pgc-img-caption></p></div><p style=text-align:start>可能有个疑问：小数点前面的1去哪里了？由于尾数部分是规格化表示的，最高位总是“1”，所以这是直接隐藏掉，同时也节省了1个位出来存储小数，提高精度。</p><p style=text-align:start>浮点数的二进制显示可以使用以下代码：</p><pre><code>//位运算结合union输出int和float的二进制位#include &lt;iostream&gt;using namespace std;union { //用于将浮点数的二进制位解析为int位输出    float input;    int output;} data;void int2binary(unsigned n)//位运算只能用于整形{    unsigned b32 = 1&lt;&lt;31;//32位二进制，最高位是1，其它位是0    cout&lt;&lt;((n&amp;b32)&gt;&gt;31)&lt;&lt;" ";//最高位与运算，移位后最高位输出    for(int i=1;i&lt;32;++i)    {        n=n&lt;&lt;1;//循环左移一位，用于最高位的与运算        cout&lt;&lt;((n&amp;b32)&gt;&gt;31);//最高位与运算，移位后最高位输出        if(i==7)            cout&lt;&lt;" ";        if(i&gt;8 &amp;&amp; (i-7)%8==0)            cout&lt;&lt;" ";    }    cout&lt;&lt;"\n";}void float2binary(unsigned n){    unsigned b32 = 1&lt;&lt;31;//32位二进制，最高位是1，其它位是0    cout&lt;&lt;((n&amp;b32)&gt;&gt;31)&lt;&lt;" ";//最高位与运算，移位后最高位输出    for(int i=1;i&lt;32;++i)    {        n=n&lt;&lt;1;//循环左移一位，用于最高位的与运算        cout&lt;&lt;((n&amp;b32)&gt;&gt;31);//最高位与运算，移位后最高位输出        if(i%8==0)            cout&lt;&lt;" ";    }    cout&lt;&lt;"\n";}void main(){    while(1)    {        int n;        cout&lt;&lt;"please input a int:";        cin&gt;&gt;n;        int2binary(n);        cout&lt;&lt;endl;        cout&lt;&lt;"please input a float:";        cin&gt;&gt;data.input;        float2binary(data.output);        cout&lt;&lt;endl;    }}/*please input a int:1780 0000000 00000000 00000000 10110010please input a float:178.6250 10000110 01100101 01000000 0000000please input a int:-1781 1111111 11111111 11111111 01001110please input a float:-178.6251 10000110 01100101 01000000 0000000please input a int:1340 0000000 00000000 00000000 10000110please input a float:10110010的阶数是7，最高位总是1，直接隐藏掉；阶码=阶数+偏移量=阶数+2^(e-1)-1=阶数+2^(8-1)-1=7+127=134(10000110) */</code></pre><p style=text-align:start>要区别整数的补码和浮点数的符号位存储，虽然两者都是以高位0表示正数，1表示负数，但两者规定的规则却是不一样的，负整数是通过正整数的二进制自然码（最高位是0）取反+1而来的。而负浮点数却是直接取1而来的，阶码、尾数都是用自然码来表示的。</p><p style=text-align:start>还需要注意的是，编码的数据在内存中的存储还要区分大头、小头，如以下小头存储：</p><div class=pgc-img><img alt=算法｜递归：参数、局部变量的顺序迭代与逆序迭代 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5e1eca6615f74444aba798ae0ad5dcea><p class=pgc-img-caption></p></div><p>对比以下二进制表示，小端存储是从低位往高位存储的：</p><p>178</p><p>0 0000000 00000000 00000000 <strong>10110010 </strong>(低8位的16进制编码是B2)</p><p>-178</p><p>1 1111111 11111111 11111111 <strong>01001110</strong>(低8位的16进制编码是4E)</p><p>178.625</p><p><strong>0 1000011</strong>0 01100101 01000000 0000000(高8位的16进制编码是43)</p><p>:-178.625</p><p><strong>1 1000011</strong>0 01100101 01000000 0000000(高8位的16进制编码是C3)</p><p>－End－</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'迭代','递归','参数'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>