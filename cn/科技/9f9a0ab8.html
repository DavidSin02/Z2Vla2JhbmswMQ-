<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>P4语言编程详解 | 极客快訊</title><meta property="og:title" content="P4语言编程详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/b0509dc83f844c6e9e133d81e9855e4b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9f9a0ab8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9f9a0ab8.html><meta property="article:published_time" content="2020-11-14T21:03:54+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:54+08:00"><meta name=Keywords content><meta name=description content="P4语言编程详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9f9a0ab8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>P4语言编程详解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>在文章《P4:开创数据平面可编程时代》中介绍了P4的架构特性、交换机结构以及P4程序的工作原理，本篇为大家介绍P4语言编码及规范，从编码角度去理解P4程序的工作流程。</p><h1>1.源码目录结构</h1><p>P4项目源码可以在github上直接获取（https://github.com/p4lang）。P4项目由很多个单独的模块组成，每个模块就是一个子项目，下面分别简单介绍一下各模块的功能。</p><p><strong>（1）behavioral-model</strong></p><p>模拟P4数据平面的用户态软件交换机，使用C++语言编写，简称bmv2。P4程序首先经过p4c-bm模块编译成JSON格式的配置文件，然后将配置文件载入到bmv2，转化成能实现交换机功能的数据结构。</p><p>behavioral-model模块是架构无关的，可以实现各种P4编程目标。该模块主要实现三个目标，其中最重要的是simple_switch,即实现P4语言标准中抽象交换机模型。另外两个目标是（simple_router,l2_switch），这两个目标是作为教学示例。</p><p><strong>（2）p4-hlir</strong></p><p>将P4代码转换成高级中间表示的前端编译器，目前的高级中间表示的展示形式与python对象的层次结构相同。该编译器的目的是使得后端编译器开发者从语法分析和目标无关的语义检查的负担中解放出来。</p><p><strong>（3）p4c-bm</strong></p><p>behavioral modal的后端编译器，建立在p4-hilr的顶部，该模块以P4程序作为输入，输出一个可以载入到behavioral model的JSON配置文件。</p><p><strong>（4）p4-build</strong></p><p>需要手动生成的基础设施库，为执行P4程序编译、安装PD库。</p><p><strong>（5）switch</strong></p><p>内含switch.p4程序样例以及通过SAI、SwitchAPI和Switchlink操作交换机所需的所有库，可独立于p4factory运行 。</p><p><strong>（6）ntf（Network Test Framework）</strong></p><p>网络测试框架，内含用以执行bmv2上应用的网络测试样例。该框架中集成了mininet和docker，方便用户进行测试。</p><p><strong>（7）p4factory</strong></p><p>内含整套用以运行和开发基于behavioral model的P4程序环境的代码，帮助用户快速开发P4程序。</p><p><strong>（8）ptf</strong></p><p>数据平面测试框架，基于unittest框架实现，内含标准Python版本。该框架中的大部分代码从floodlight项目中的OFTest框架移植而来，框架的实现和开发可参考OFTest框架文档。</p><p><strong>（9）scapy-vxlan</strong></p><p>基于Scapy项目，barefoot对其进行了定制，支持更多协议的数据包包头的伪造和解析，目前支持 VXLAN和ERSPAN-like（Scapy本身并不支持）。</p><p><strong>（10）tutorials</strong></p><p>P4语言教程，内含8个教程,覆盖了P4语言中的解析器、动作、状态存储、匹配-动作表、等基础组件。</p><p>1）cpoy_to_cpu：基本动作clone_ingress_to_egress教程</p><p>2）meter：计量表教程</p><p>3）TLV_parsing：IPv4数据包解析教程</p><p>4）register：寄存器读写状态教程</p><p>5）counter：计数器教程</p><p>6）action_profile：ECMP动作摘要教程</p><p>7）resubmit：数据包冲提交到入端口流水线教程</p><p>8）simple_nat：TCP流量的完全圆锥形NAT网络教程</p><p>注：P4语言项目库中的SAI、mininet及thrift是从其他开源项目完全fork而来，这里不展开讨论。</p><h1>2.P4语言标准</h1><p>当前P4语言标准的最新版本为《The P4 Language Specification Version1.1》（以下简称V1.1），目前版本的P4语言编译器已经基本实现了P4语言标准中的绝大部分特性 ，部分特性尚在开发之中。</p><p>2.1 基础数据类型及操作</p><p>P4语言中定义了5种基础数据类型，分别是：bool、bit、int、varbit、int。（注：此处W代表长度，通常使用十进制数字表示，如bit）通常情况下，不同的数据类型之间可以相互转换，并且所有的二目运算符都要求数据类型保持一致，除了位移操作符（shifts）。</p><p><strong>（1）布尔型（bool）</strong></p><p>布尔型（Boolean），值为true或false，非整数型。布尔类型数据可进行如表1所示运算。</p><p class=ql-align-center>运算符</p><p class=ql-align-center>描述</p><p class=ql-align-center>and</p><p class=ql-align-center>二目运算符，操作数必须都为布尔型，运算结果为布尔型。</p><p class=ql-align-center>or</p><p class=ql-align-center>二目运算符，操作数必须都为布尔型，运算结果为布尔型。</p><p class=ql-align-center>not</p><p class=ql-align-center>单目运算符，操作数必须为布尔型，运算结果为布尔型。</p><p class=ql-align-center>＝＝，！＝</p><p class=ql-align-center>测试是否相等或不等，运算结果为布尔型。</p><p class=ql-align-center>表1 布尔型支持的运算</p><p><strong>（2）无符号整型（bit）</strong></p><p>无符号整型（unsigned integers）也叫位串（bit-string）。位串是以比特位形式表示的任意长度的数（如：bit，表示长度为127比特的位串），但如果需要对位串进行某些数学运算时，位串长度必须是8的整数倍（如：16、32、64bit）。无符号整型支持如表2所示运算。</p><p class=ql-align-center>运算符</p><p class=ql-align-center>描述</p><p class=ql-align-center>＝＝，！＝</p><p class=ql-align-center>测试是否相等或不等，运算结果为布尔型。&lt;，>，&lt;=，>=</p><p class=ql-align-center>无符号数比较，操作数的长度（W）要求相同，运算结果为布尔型。&，｜，^</p><p class=ql-align-center>按位运算符，操作数的长度（W）要求相同，运算结果为无符号整型。～</p><p class=ql-align-center>运算结果为操作数的补码。&lt;&lt;，>></p><p class=ql-align-center>左移运算符操作数为无符号整型，右移运算符操作数必须是无符号数或非负整数。此运算符为逻辑位移。+（单目）</p><p class=ql-align-center>单目加运算，效果同no-op。-（单目）</p><p class=ql-align-center>单目减运算，计算结果为2W减去操作数，W为操作数长度。+（双目）</p><p class=ql-align-center>二目加运算，操作数的长度（W）要求相同。计算结果为操作数的算术和，且运算结果长度也必须为W，超过则截断。-（双目）</p><p class=ql-align-center>二目减运算，操作数的长度（W）要求相同。计算结果为操作数的算术差。*</p><p>无符号乘法运算，操作数的长度（W）要求相同，计算结果为无符号数且长度与操作数相等。</p><p class=ql-align-center>表2 无符号整型支持的运算</p><p><strong>（3）有符号整型（int（W））</strong></p><p>有符号整型（signed integers）支持如表3所示运算。</p><p class=ql-align-center>运算符</p><p class=ql-align-center>描述</p><p class=ql-align-center>＝＝，！＝</p><p class=ql-align-center>测试是否相等或不等，运算结果为布尔型。&lt;，>，&lt;=，>=</p><p class=ql-align-center>有符号数比较，操作数的长度（W）要求相同，运算结果为布尔型。&，｜，^</p><p class=ql-align-center>按位运算符，操作数的长度（W）要求相同，运算结果为无符号整型。～</p><p class=ql-align-center>运算结果为操作数的补码。&lt;&lt;，>></p><p class=ql-align-center>左移运算符操作数为有符号整型，右移运算符操作数必须是无符号数或非负整数。此运算符为逻辑位移。+（单目）</p><p class=ql-align-center>单目加运算，效果同no-op。-（单目）</p><p class=ql-align-center>单目减运算，运算结果有符号整型，且长度与操作数相等。+（双目）</p><p class=ql-align-center>二目加运算，操作数数据类型必须相同，运算结果也为同类型。-（双目）</p><p class=ql-align-center>二目减运算，操作数数据类型必须相同，运算结果也为同类型。*</p><p>有符号乘法运算，操作数的长度（W）要求相同，计算结果为有符号数且长度与操作数相等。</p><p class=ql-align-center>表3 有符号整型支持的运算</p><p><strong>（4）变长位串（varbit）</strong></p><p>变长位串（dynamically-sized bit-strings）不支持算术、比较、按位运算，甚至不支持类型转换。该数据类型在定义时会指定一个静态的最大宽度值，解析器会提取变长位串数据并设置一个值作为长度。</p><p><strong>（5）无限精度整型（int）</strong></p><p>无限精度整数（infinite-precision integers）支持如表4所示运算。</p><p class=ql-align-center>运算符</p><p class=ql-align-center>描述</p><p class=ql-align-center>＝＝，！＝</p><p class=ql-align-center>测试是否相等或不等，操作数必须都是整型（int）运算结果为布尔型。&lt;，>，&lt;=，>=</p><p class=ql-align-center>有符号数比较，操作数类型都必须是整形，运算结果为布尔型。&lt;&lt;，>></p><p class=ql-align-center>右移运算符操作数必须为正整数；左移运算结果和操作数相同。a&lt;&lt;b等价于ax2b，a>>b等价于a/2b。+（单目）</p><p class=ql-align-center>单目加运算，效果同no-op。-（单目）</p><p class=ql-align-center>单目减运算，运算结果为整型，且该运算不会导致溢出。+（双目）</p><p class=ql-align-center>二目加运算，操作数类型都必须是整型，运算结果为整型，且该运算不会导致溢出。-（双目）</p><p class=ql-align-center>二目减运算，操作数类型都必须是整型，计算结果为整型，且该运算不会导致溢出。*</p><p class=ql-align-center>无符号乘法运算，操作数必须都是整形，计算结果为整形，该运算不会导致溢出。／，％</p><p>二目有符号除法和取模运算，操作数必须是正整数，运算结果为正整数。</p><p class=ql-align-center>表4无限精度整型支持的运算</p><p>2.2 数据类型转换</p><p>再P4预研中，对数据进行运算时大多时候都要保证操作数数据类型的一致性，P4也提供了基础的数据类型转换功能，表5中列出了所有合法的数据类型转换。</p><p class=ql-align-center>From</p><p class=ql-align-center>To</p><p class=ql-align-center>描述</p><p class=ql-align-center>bit&lt;1></p><p class=ql-align-center>bool</p><p class=ql-align-center>0代表fasle，1代表true。bool</p><p class=ql-align-center>bit&lt;1></p><p class=ql-align-center>0代表fasle，1代表true。bit&lt;W></p><p class=ql-align-center>int&lt;W></p><p class=ql-align-center>保留所有比特位不变。int&lt;W></p><p class=ql-align-center>bit&lt;W></p><p class=ql-align-center>保留所有比特位不变。bit&lt;W></p><p class=ql-align-center>bit&lt;W1></p><p class=ql-align-center>当W>W1时，保留低位W1位长度的数据，当W&lt;W1时新增位补0.int&lt;W></p><p class=ql-align-center>int&lt;W1></p><p class=ql-align-center>当W>W1时，保留低位W1长度的数字，当W&lt;W1时新增位补符号位.int</p><p class=ql-align-center>bit&lt;W></p><p class=ql-align-center>将整型转化为位串，保留地位W位长度数据，溢出需要发出警告并转化为负数。int</p><p class=ql-align-center>int&lt;W></p><p>将整型转化为位串，保留地位W位长度数据，溢出需要发出警告。</p><p class=ql-align-center>表5 合法数据类型转换</p><p>在P4程序中对数据进行运算时，除了用户在编写程序是手动转换数据类型，P4编译器在某些情况下也会自动将数据进行类型转换，这种转换是强制的、自动的的隐式类型转换。如表6所示，例举了P4程序中常见的几种隐式类型转换的情况。</p><p>bit&lt;8> x;</p><p>bit&lt;6> y;</p><p class=ql-align-center>bit&lt;8> z;表达式</p><p class=ql-align-center>实际实现</p><p class=ql-align-center>x＋1</p><p class=ql-align-center>x+(bit&lt;8>)1</p><p class=ql-align-center>z&lt;0</p><p class=ql-align-center>z&lt;(int&lt;8>)0</p><p class=ql-align-center>x&lt;&lt;13</p><p class=ql-align-center>0;//溢出时发出警告</p><p class=ql-align-center>x|0xFFF</p><p class=ql-align-center>x|(bit&lt;8>)0xFF;//溢出警告</p><p class=ql-align-center>表6 隐式类型转换</p><p>2.3 基础语言组件</p><p>P4程序中有5个语言组件：首部（Headers）、解析器（parsers）、表（Tables）、动作（Action）、流控制程序。</p><p><strong>（1）首部</strong></p><p>首部类型是由成员字段组成的有序列表，每个字段都有其名称和长度，每一种首部类型都有对应的首部实例来存储具体的数据。首部分为两种，一种是包头（Packet Headers），另一种是元数据（Metadata）。</p><p>包头用以描述数据包结构，以IPv4协议为例，图1为 IPv4报文头部结构，IPv4报头有20字节固定长度部分和可选字段、填充字段的可变部分，每个字段的作用这里不再赘述。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b0509dc83f844c6e9e133d81e9855e4b><p class=pgc-img-caption></p></div><p class=ql-align-center>图1 IPv4协议报头结构</p><p>使用P4语言定义IPv4的包头类型示例如图2所示：</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c6135eff4d44807ae9dbeecd47b459b><p class=pgc-img-caption></p></div><p class=ql-align-center>图2 IPv4 包头定义</p><p>对照图1中IPv4报头结构可以比较容易理解上述P4语言代码——按照IPv4报头格式，定义了一个包头并实例化。</p><p>这里需要区分“包头”，“报头”的关系。如果没有特殊指出，本文中的“包头（Packet Header）”指的是P4语言中的术语，而“报头”指的是数据包的报文头部。</p><p>元数据用来携带数据和配置信息，元数据的申明与包头类似，但在实例化时不同，而且包头和元数据在字段值的约束上存在一定的差别。元数据分为两种，一种是用来携带P4程序运行过程中产生的数据的用户自定义元数据（User-Defined Metadata），如首部字段的运算结果等。另一种是固有元数据（Intrinsic Metadata），用于携带交换机自身的配置信息，如数据包进入交换机时的端口号等。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f33dba3778e3413ab85e34c5993a27fd><p class=pgc-img-caption></p></div><p class=ql-align-center>图3 元数据定义</p><p>用户可以使用自定义的元数据来携带任意数据，但固有元数据在编译器中具有特定的意义。V1.1中定义了8种固有元数据，这些元数据携带了数据包相关的状态信息，表7中展示8种标准固有元数据及其作用。</p><p class=ql-align-center>字段</p><p class=ql-align-center>描述</p><p class=ql-align-center>ingress_port</p><p class=ql-align-center>数据包的入端口，解析之前设置。只读。packet_length</p><p class=ql-align-center>数据包的字节数，当交换机在快速转发模式下，该元数据不能在动作（action）中匹配或引用。只读。egress_spec</p><p class=ql-align-center>在入端口流水线的匹配-动作过程之后设置，指定数据包出端口，可以是物理端口、逻辑端口或者多播组。egress_port</p><p class=ql-align-center>指定数据包的物理出端口，区别于egress_spec，只能应用于物理端口。只读。egress_instance</p><p class=ql-align-center>用于区分复制后数据包实例的标识符。只读。instance_type</p><p class=ql-align-center>数据包实例类型：正常（Normal）、入端口复制（ingress clone）、出端口复制（egress clone）、再循环（recirculated）。parser_status</p><p class=ql-align-center>解析器解析结果，0表示无错误，其实数字代表了对应的错误类型。parser_error_loaction</p><p>指向P4程序错误发生处。</p><p class=ql-align-center>表7 固有元数据</p><p>在P4语言中定义首部类型有以下几点需要注意：</p><p>1)包头类型的长度需要字节对齐，即长度必须是8bit的整数倍。</p><p>2)包头中字段长度可以是可变值（该特性在P4语言规范中规定，但当前编译器版本并为实现，后续版本会支持）也可以是首部中其他字段值计算后的值。而元数据中的字段长度只能是定值。</p><p>3)只有包头能够实例化成数组，元数据则不行。</p><p>4)实例化时，首部中已定义名称的字段的值会被初始化成程序中的指定值，如果首部中只定义字段名称而未指定值，字段的值将会被初始化成0。</p><p><strong>（3）解析器</strong></p><p>一个P4程序中往往定义了大量的首部和首部实例，但并不是所有的首部实例都会对数据包进行操作。解析器工作时会生成描述数据包进行哪些匹配+动作操作的中间表示（ Intermediate Representation），在P4中称之为解析后表示（Parsed Representation），这些解析后表示规定了对数据包生效的实例，是一组对数据包生效的实例的集合。</p><p>P4语言中解析器采用有限状态机的设计思路，每个解析器方法视为一种状态。当解析器工作时，会将当前处理的数据包头字节的偏移量记录在首部实例中，并在状态迁移（调用另一个解析器）时指向包头中下一个待处理的有效字节。以以太网帧的解析器为例，用数据包类型代对应解析器，将每个解析器作为一种状态，用箭头表示状态迁移，则可以构建出如图2 所示的以太网帧的解析器的状态迁移图。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b066736eb1da4398a42505d5972d4c48><p class=pgc-img-caption></p></div><p class=ql-align-center>图4 以太网帧解析器状态迁移图</p><p>图5展示了以太网帧和IPv4数据包解析器定义示例。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5863e938d6f34cefb9efecd817b9c22f><p class=pgc-img-caption></p></div><p class=ql-align-center>图5 解析器定义</p><p>一个解析方法/状态可以以下四种方式结束：</p><p>1）return 一个流控制程序名</p><p>2）return一个解析器名</p><p>3）发生显式错误</p><p>4）发生隐式错误</p><p>P4语言中流控制程序和解析器的命名空间是共用的，所以在定义解析器和流控制程序的时候需要注意不能重名，否则会导致P4程序错误。</p><p><strong>（3）动作</strong></p><p>P4语言中的动作主要分为两种，基本动作（Primitive Actions）和复合动作（Compound Actions）。基本动作包括：数据包处理运算符（如添加、删除或修改包头）、基本的算术运算符、哈希运算符和统计跟踪运算符（如计量、测量）。复合动作由基本动作组合而成，由用户自行定义。表8中展示了P4中定义的基本动作。</p><p class=ql-align-center>动作</p><p class=ql-align-center>描述</p><p>no_op占位符动作，不做任何操作。drop在入口流水线中将数据包丢弃。modify_field修改解析后表示中的包头字段值。modify_field_with_hash_based_index使用字段列表索引计算一个值并使用该值生成偏移量。add_header为数据包的解析后表示添加包头。remove_header为数据包的解析后表示删除包头。copy_header复制首部实例。push将所有首部实例压入一个数组，并在顶部添加一个新首部。pop将实例数组顶部的元素弹出，后续元素向顶部移位。count更新计数器。meter执行计量操作。generate_digest生成一个报文摘要并发送到接收机。truncate在出口处截断数据包。resubmit将原始数据包和元数据重新发送到解析器。Recirculate在数据包完成出口修改操作后重新发送。clone_ingress_pkt_to_ingress复制原始数据包并发送到解析器。clone_egress_pkt_to_ingress复制出口数据包并发送到解析器。clone_ingress_pkt_to_egress复制原始数据包并发送到缓存区。clone_egress_pkt_to_egress复制出口数据包并发送的缓存区。</p><p class=ql-align-center>表8 基本动作</p><p>这些动作高度抽象且与协议无关，以实现P4语言处理数据的协议无关性。同时，复杂的操作及流程可以通过组合不同基本操作（即复合操作）完成，从而保障了P4语言对各种协议的支持以及扩展性。图6展示了P4中复合动作定义的示例。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cb41d36ffd4e4e4383913d6956e1ec88><p class=pgc-img-caption></p></div><p class=ql-align-center>图6 复合动作定义</p><p><strong>（4）匹配-动作表</strong></p><p>P4语言中的匹配-动作表定义了匹配字段、动作及一些相关属性（如表容量），当匹配-动作表中定义的字段与数据包匹配成功时，则执行对应的动作；若匹配不成功则标记为“失配（miss）”，并执行默认操作。匹配动作表的定义如图7所示。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be81048399fd4f62b280db0c32f18f74><p class=pgc-img-caption></p></div><p class=ql-align-center>图7定义动作-匹配表</p><p>P4语言的匹配-动作表支持多种匹配类型，如精确匹配、最长前缀匹配、范围匹配等。如表9所示，展示了动作-匹配表支持的匹配类型。</p><p class=ql-align-center>匹配类型</p><p class=ql-align-center>描述</p><p class=ql-align-center>excat</p><p class=ql-align-center>精确匹配。ternary</p><p class=ql-align-center>三重匹配，动作-匹配表的每个表项都有一个掩码，将掩码和字段值进行逻辑与运算，再执行匹配。为了避免导致多条表项匹配成功，每条表项都需要设定一个优先级。lpm</p><p class=ql-align-center>这是三重匹配的一种特殊情况，当多个表项匹配成功时，选择掩码最长的最为最高优先级进行匹配。index</p><p class=ql-align-center>字段值作为表项索引。range</p><p class=ql-align-center>表项中确定一个范围，字段值在此范围内皆能成功匹配。valid</p><p>仅用于包头字段匹配，表项值只能为true/false。</p><p class=ql-align-center>表9 匹配类型表</p><p><strong>（4）流控制程序</strong></p><p>P4语言中匹配-动作表中规定需要匹配的字段和需要执行的操作，流控制程序则用来规定匹配-动作表的执行顺序。</p><p>以P4语言定义二层转发流程为例，数据包首先进行L2转发表（l2_fwd）匹配，然后根据数据包的以太网目的地址是否匹配路由器自身的MAC地址（通过查找所属的router_mac表）决定是否经过l3路由表（ipv4_fib_lpm和upv6_fib_lpm），再根据IP包头类型（IPv4或IPv6），数据包匹配不同的L3路由表，最后通过访问控制列表来控制数据包是否通过。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be76174eb4da4e78b2541db43ac71931><p class=pgc-img-caption></p></div><p class=ql-align-center>图8 流控制程序定义</p><p>2.4 状态存储</p><p>包头和元数据实例中的数据只能存在对某个数据包解析的过程中，解析下一个数据包时，这些实例会重新初始化。而计数器、计量器和寄存器中的数据在整个流水线中长期存在，所以称之为状态存储。</p><p><strong>（1） 计数器</strong></p><p>计数器附加在每个表项之后，并在完成一次匹配并执行对应操作后自增1。计数器中定义了7种属性，下图展示了V1.1中计数器的定义方式。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3b448cb7e3af4d34b760eab6c9c8a997><p class=pgc-img-caption></p></div><p class=ql-align-center>图9 计数器定义</p><p>1）Name</p><p>计数器名称，指向该计数器，P4编译器中通过名称+索引的方式确定一个计数器实例。</p><p>2）min_width</p><p>编译P4程序时，编译器分配给计数器的大小并不是完全固定的，该属性指定了分配给计数器的最小长度。</p><p>3）saturating</p><p>如果计数器中设定了该属性，则当计数器到达上限时停止计数，否则计数器将清零并重新开始计数。</p><p>4）direct</p><p>如果计数器中设定了该属性，则计数器绑定的匹配-动作表中无需指定count动作来更新计数器，计数器会自动更新。若在匹配动作表调用count动作更新计数器，则编译器报错。</p><p>5）static</p><p>如果计数器中设定了该属性，则必须在匹配-动作表中调用count动作更新计数器。</p><p>6）instance_count</p><p>该属性用以记录计数器实例数，如果计数器设定了direct属性，则无法在计数器中设定该属性；如果计数器中未设定direct属性，则该属性必须设定。</p><p>7）type</p><p>V1.1中的计数器类型有3种： bytes、packets、bytes_and_packets。</p><p><strong>（2） 计量器</strong></p><p>计量器的定义与计数器类似，计量器中定义了6种属性，下图展示了V1.1中计数器的定义方式。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e2c3301ef6f4c32b1e1602d7a3e0d17><p class=pgc-img-caption></p></div><p class=ql-align-center>图10 计量器定义</p><p>1）name</p><p>计量器名称，指向该计量器。</p><p>2）direct</p><p>如果计量器中设定了该属性，则计量器绑定的匹配-动作表中无需指定execute_meter动作来更新计量器，计数器会自动更新。若在匹配动作表调用execute_meter动作更新计量器，则编译器报错。</p><p>3）static</p><p>如果计数器中设定了该属性，则必须在匹配-动作表中调用execute_meter动作更新计数器。</p><p>4）instance_count</p><p>该属性用以记录计量器实例数，如果计量器设定了direct属性，则无法在计量器中设定该属性；如果计量器中未设定direct属性，则该属性必须设定。</p><p>5）type</p><p>V1.1中的计量器类型有2种： bytes、packets。</p><p>6）result</p><p>V1.1中的计量器的输出结果有3种，分别用三种颜色标记：红色（P4_METER_COLOR_RED）、黄色（P4_METER_COLOR_YELLO）和绿色（P4_METER_COLOR_GREEN），输出结果存在一个2bit长度的字段中。</p><p><strong>（3） 寄存器</strong></p><p>寄存器定义了5种属性，下图展示了V1.1中寄存器的定义方式。</p><div class=pgc-img><img alt=P4语言编程详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3f4ced6acd39430d9ade0e5cb57fe3e1><p class=pgc-img-caption></p></div><p class=ql-align-center>图11 寄存器的定义</p><p>1）name</p><p>寄存器名称，指向该寄存器，P4编译器中通过名称+索引的方式确定一个计量器实例。</p><p>2）width_or_layout</p><p>width和layout属性二选一，width为指定一个确定的长度，而 layout是直接通过名称引用已定义的包头结构。</p><p>3）direct_or_static</p><p>与计数器和计量器中的定义类似，虽然寄存器不能直接在匹配过程中使用，但是作为modify_field动作的数据源，将当前寄存器中的数据复制到数据包的元数据中，并在后续的匹配中使用。</p><p>4）instance_count</p><p>该属性用以记录寄存器实例数，如果寄存器设定了direct属性，则无法在寄存器中设定该属性；如果寄存器中未设定direct属性，则该属性必须设定。</p><h1>3 结语</h1><p>以上是参考P4语言规范标准并结合个人的理解所写，希望能让不了解P4的人能有个基本的认识，同时起到抛砖引玉的作用。对P4感兴趣的同学可以加入到P4微信交流群中与大牛们一起讨论。邮箱：lengzhiyuan@fnii.com 微信号：cool_leng</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'P4','语言','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>