<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>腾讯面试官这样问我二叉树，我刚好都会 | 原力计划 | 极客快訊</title><meta property="og:title" content="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/Rch9rkiIfHJCwl"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9fc00cce.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fc00cce.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9fc00cce.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>腾讯面试官这样问我二叉树，我刚好都会 | 原力计划</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rch9rkiIfHJCwl><p>作者 | 天才程序YUAN</p><p>责编 | 夕颜</p><p>封图 | CSDN下载自视觉中国</p><p>出品 | CSDN（ID:CSDNnews）</p><img alt="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p><strong>前记</strong></p><p>上周我投递出了简历，岗位是后端开发工程师。这周腾讯面试官给我进行了视频面试。面试过程中他问了二叉树的问题。二叉树相关算法题，在面试中出现的次数非常非常多，所以我面试之前也有所准备。今天结合面试问题详细讲一讲二叉树，结合实例分析二叉树的存储结构的建立方法和遍历过程。</p><img alt="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p><strong>面试问题</strong></p><p><strong>面试官大佬：看你的简历上写熟悉数据结构，谈谈二叉树遍历的方式？</strong></p><p>我：（这可难不倒我）</p><p><strong>先序遍历</strong></p><p>先访问根节点，后依次访问左孩子和右孩子</p><p><strong>递归算法</strong></p><pre><code>void PreOrder1(BTREE bt) //递归先根遍历 </code><code>{</code><code>if (bt)</code><code>{</code><code>if (bt-&gt;data != '#')</code><code>{</code><code>printf(" %c", bt-&gt;data);//结点不空 ，打印结点值 </code><code>}</code><code>PreOrder1(bt-&gt;lchild);//依次访问左右节点 </code><code>PreOrder1(bt-&gt;rchild);</code><code>}</code><code>}</code></pre><p><strong>非递归算法</strong></p><pre><code>void PreOrder2(BTREE p)//非递归先根遍历 ,先访问根节点，后依次访问左孩子和右孩子 </code><code>{</code><code>int top = -1;</code><code>node *Q[N];</code><code>while (p != || top != -1)</code><code>{</code><code>while (p != )</code><code>{</code><code>if (p-&gt;data != '#')</code><code>{</code><code>printf(" %c", p-&gt;data);</code><code>}</code><code>Q[++top] = p;</code><code>p = p-&gt;lchild;</code><code>}</code><code>if (top != -1)</code><code>{</code><code>p = Q[top--];</code><code>p = p-&gt;rchild;</code><code>}</code><code>}</code><code>}</code></pre><p><strong>中序遍历</strong></p><p>先访问左孩子，后依次访问根节点和右孩子</p><p><strong>递归算法</strong></p><pre><code>void InOrder1(BTREE bt)//递归中序遍历</code><code>{</code><code>if (bt)</code><code>{</code><code>InOrder1(bt-&gt;lchild);//先访问左节点 </code><code>if (bt-&gt;data != '#')</code><code>{</code><code>printf(" %c", bt-&gt;data);//结点不空 ，打印结点值 </code><code>}</code><code>InOrder1(bt-&gt;rchild);//先访问右节点 </code><code>}</code><code>}</code></pre><p><strong>非递归算法</strong></p><pre><code>void InOrder2(BTREE p)//非递归中序遍历，先访问左孩子，然后访问根节点，后访问右孩子</code><code>{</code><code>int top = -1;</code><code>node *Q[N];</code><code>while (p != || top != -1)</code><code>{</code><code>while (p != )</code><code>{</code><code>Q[++top] = p;</code><code>p = p-&gt;lchild;</code><code>}</code><code>if (top != -1)</code><code>{</code><code>p = Q[top--];</code><code>if (p-&gt;data != '#')</code><code>{</code><code>printf(" %c",p-&gt;data);</code><code>}</code><code>p = p-&gt;rchild;</code><code>}</code><code>}</code><code>}</code></pre><p><strong>后序遍历</strong></p><p>先访问左孩子孩子，后依次访问右孩子和根节点</p><p>递归算法</p><pre><code>void PostOrder1(BTREE bt)//后序遍历 </code><code>{</code><code>if (bt)</code><code>{</code><code>PostOrder1(bt-&gt;lchild);//先访问左，右孩子节点 </code><code>PostOrder1(bt-&gt;rchild);</code><code>if (bt-&gt;data != '#')</code><code>{</code><code>printf(" %c", bt-&gt;data);//后访问根节点 </code><code>}</code><code>}</code><code>}</code></pre><p><strong>非递归算法</strong></p><pre><code>void PostOrder2(BTREE p)//非递归后序遍历 ，先访问左孩子，然后访问右孩子，后访问根节点 </code><code>{</code><code>int top = -1;</code><code>node *Q[N];</code><code>int flag[N] = { 0 };</code><code>while (p != || top != -1)</code><code>{</code><code>while (p != )</code><code>{</code><code>top++;</code><code>Q[top] = p;</code><code>flag[top] = 1;</code><code>p = p-&gt;lchild;</code><code>}</code><code>while (top != -1 &amp;&amp; flag[top] == 2)</code><code>{</code><code>if (Q[top]-&gt;data != '#')</code><code>{</code><code>printf(" %c", Q[top]-&gt;data);</code><code>top--;</code><code>}</code><code>}</code><code>if (top != -1)</code><code>{</code><code>flag[top] = 2;</code><code>p = Q[top]-&gt;rchild;</code><code>}</code><code>}</code><code>}</code></pre><p><strong>面试官大佬：你回答得很好，还有其他遍历方式吗</strong></p><p>我：……</p><p>沉默了几秒，我（这可难不倒我）：还有一种层序遍历</p><p><strong>层序遍历</strong></p><p>从根开始，依次向下，对于每一层从左向右遍历</p><pre><code>//层序遍历 </code><code>void Sequense(BTREE bt)//建立栈，依次将根节点，左孩子，右孩子压栈 ，并打印栈顶元素 </code><code>{</code><code>node *Q[N];</code><code>node *p;</code><code>int front = 0, top = 0;</code><code>if (bt != )</code><code>{</code><code>Q[++top] = bt;//将根节点压栈</code><code>while (front &lt; top) //遍历栈 </code><code>{</code><code>p = Q[++front];</code><code>if (p-&gt;data != '#')</code><code>{</code><code>printf(" %c", p-&gt;data);//打印栈顶元素 </code><code>}</code><code>if (p-&gt;lchild)</code><code>{</code><code>Q[++top] = p-&gt;lchild;//将左孩子压栈</code><code>}</code><code>if (p-&gt;rchild)</code><code>{</code><code>Q[++top] = p-&gt;rchild;//将右孩子压栈</code><code>}</code><code>}</code><code>}</code><code>}</code></pre><p><strong>遍历算法总结</strong></p><img alt="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RvY5qzN2HyEb3F><p><strong>面试官大佬：如何判断是否完全二叉树呢？</strong></p><p>我：（这可难不倒我）</p><p><strong>判断完全二叉树</strong></p><ol><li><p>按层遍历二叉树, 从每层从左向右遍历所有的结点</p></li><li><p>如果当前结点有右孩子, 但没有左孩子, 那么不是完全二叉树</p></li><li><p>如果当前结点有左孩子但无右孩子, 那么它之后的所有结点都必须为叶子结点，否则不是完全二叉树</p></li><li><p>如果当前结点有左孩子和右孩子, 继续遍历</p></li></ol><pre><code>int Compnode(BTREE G)//判断是否是完全二叉树 </code><code>{</code><code>node *D[N], *p; //建立一个队列D[N]</code><code>int front = 0, last = 0; //front是队头指针,last是队尾指针</code><code>int tree_signal = 1;//tree_signal是判断是否为完全二叉树的标志</code><code>int odd_signal = 1;//odd_signal是判断是否存在无左孩子的节点的标志</code><code>if (G != )</code><code>{</code><code>last++;</code><code>D[last] = G; //将根节点压入队尾</code><code>while (front != last)</code><code>{</code><code>front++;</code><code>p = D[front];</code><code>if (p-&gt;lchild == ||(p-&gt;lchild)-&gt;data == '#') //*p节点没有左孩子</code><code>{</code><code>odd_signal = 0;</code><code>if (p-&gt;rchild != &amp;&amp; (p-&gt;rchild)-&gt;data != '#') //没有左孩子但有右孩子，不是完全二叉树</code><code>tree_signal = 0; </code><code>}</code><code>else //*p节点有左子树</code><code>{</code><code>if (odd_signal == 1) //目前不存在无左孩子的节点</code><code>{</code><code>last++; //左孩子进队</code><code>D[last] = p-&gt;lchild;</code><code>if (p-&gt;rchild == || (p-&gt;rchild)-&gt;data == '#') //*p有左孩子但没有右孩子</code><code>{</code><code>odd_signal = 0;</code><code>}</code><code>else</code><code>{</code><code>last++; //右孩子进队</code><code>D[last] = p-&gt;rchild;</code><code>}</code><code>}</code><code>else //目前存在有左孩子的节点，不是完全二叉树</code><code>{</code><code>tree_signal = 0; </code><code>}</code><code>}</code><code>}</code><code>}</code><code>else</code><code>{</code><code>tree_signal = 0;//假设空树不是完全二叉树</code><code>}</code><code>return tree_signal;</code><code>}</code></pre><img alt="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p><strong>总结</strong></p><p>咱们玩归玩，闹归闹，别拿面试开玩笑。</p><p>二叉树的遍历虽然简单，但遍历方式多样，也有递归算法和非递归算法之分。一旦问到了，大家一定要回答全面，不要丢三落四，回答到点上。二叉树相关算法题，在面试中出现的次数非常非常多，大家面试前要把二叉树等数据结构的基础打牢。</p><p>原文链接：</p><p>https://blog.csdn.net/JAck_chen0309/article/details/104843101</p><img alt="腾讯面试官这样问我二叉树，我刚好都会 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RvXPN4G8fGLh3I><p>☞斩获GitHub 2000+ Star，阿里云开源的 Alink 机器学习平台如何跑赢双11数据“博弈”？| AI 技术生态论</p><p></p><h1 toutiao-origin=h2>☞2020 年，AI 芯片内存哪家强？</h1><h1 toutiao-origin=h2>☞拜托，别再问我什么是 B+ 树了</h1><h1 toutiao-origin=h2>☞程序员为什么应该旗帜鲜明地反对“最佳实践”？</h1><p>☞半小时训练亿级规模知识图谱，亚马逊AI开源知识图谱嵌入表示框架DGL-KE</p><p>☞“出道” 5 年采用率达 78%，Kubernetes 的成功秘诀是什么？</p><p></p><h1 toutiao-origin=h2>☞警惕！新骗术出现：这些虚假二维码生成器已成功盗取 4.6 万美元！</h1><p>今日福利：评论区留言入选，可获得价值299元的「2020 AI开发者万人大会」在线<strong>直播门票一张</strong>。 快来动动手指，写下你想说的话吧。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'腾讯面','试官','这样问'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>