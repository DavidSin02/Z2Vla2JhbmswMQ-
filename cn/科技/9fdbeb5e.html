<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>探究HashMap线性不安全（二）——链表成环的详细过程 | 极客快訊</title><meta property="og:title" content="探究HashMap线性不安全（二）——链表成环的详细过程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/28a6f8f609e24e679faf365e1b4ebf57"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/9fdbeb5e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/9fdbeb5e.html><meta property="article:published_time" content="2020-10-29T21:09:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:58+08:00"><meta name=Keywords content><meta name=description content="探究HashMap线性不安全（二）——链表成环的详细过程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/9fdbeb5e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>探究HashMap线性不安全（二）——链表成环的详细过程</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>网上很多资料都详细地讲解了HashMap底层的实现，但是讲到HashMap的并发操作不是线性安全时，往往一笔带过：<strong>在多个线程并发扩容时，会在执行transfer()方法转移键值对时，造成链表成环，导致程序在执行get操作时形成死循环</strong>。</p><p>​ 对于没有研究过该过程的童鞋，很难费解这句话的含义。下面笔者分四个小节带着大家共同研究一下JDK1.7和JDK1.8版本下HashMap的线性不安全是怎么造成的，详细探究链表成环的形成过程。如果对于HashMap底层的put、get操作不清楚。</p><p>本节将详细探究HashMap扩容的键值对迁移过程，多线程并发执行transfer()方法是如何产生环形链表的。transfer()方法的代码为：</p><p>如果想学习Java工程化、高性能及分布式、深入浅出。微服务、Spring，MyBatis，Netty源码分析的朋友可以加我的Java高级交流：854630135，群里有阿里大牛直播讲解技术，以及Java大型互联网技术的视频免费分享给大家。</p><pre> 1 void transfer(Entry[] newTable, boolean rehash) { 2 int newCapacity = newTable.length; 3 //遍历table数组中键值对链 4 for (Entry&lt;K,V&gt; e : table) { 5 //遍历键值对e链上的所有键值对，当e指向null时结束 6 while(null != e) { 7 Entry&lt;K,V&gt; next = e.next;//断点一 8 //通常rehash为false，不会重新计算键值对key的hash值 9 if (rehash) {10 e.hash = null == e.key ? 0 : hash(e.key);11 }12 //根据扩容后的table数组长度计算键值对的index13 int i = indexFor(e.hash, newCapacity);14 //头插法，将后遍历的键值对存到链条的头部15 e.next = newTable[i];16 newTable[i] = e;17 //链条中的下一个键值对继续执行while循环。18 e = next;19 }20 }21 }</pre><p>情景：</p><p>​ 两个线程A、B同时向HashMap中写入键值对，某个时刻HashMap已经到了Resize的临界点。由于多线程的执行没有必然的先后顺序，存在线程A未完成扩容，而线程B又进行扩容的情况，即两个线程都可能会执行扩容方法transfer()。此时两个线程都会遍历table数组中的键值对链，对于每个链执行while循环，迁移所有键值对。</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/28a6f8f609e24e679faf365e1b4ebf57><p class=pgc-img-caption></p></div><p><em>假定HashMap中table数组的初始长度为4</em></p><p>​ 假如线程A和线程B都遍历到index为2的键值链（即Entry3->Entry2->null这条链）。由于CPU时间片分配的不确定性，线程B执行到代码中断点一的位置后暂停，<strong>此时线程B中的e指向Entry3，e.next指向Entry2。</strong>而线程A继续执行，完成了扩容操作。HashMap的数据结构为下图所示。</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1cea362cdb1c4b98aedfa1617c274425><p class=pgc-img-caption></p></div><p>​ <strong>重点！！</strong>：e和e.next为线程B中的引用变量，分别指向hashMap中的Entry3和Entry2。由于Entry3和Entry2是线程共享的，因此受线程A执行的影响，<strong>Entry3将指向null，Entry2指向Entry3</strong>。</p><p>​ 此时线程B中局部变量newTable的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e1f714dd4f940b7bd5f1f258da2e489><p class=pgc-img-caption></p></div><p><strong>执行第一次循环：</strong>e为Entry3，e.next为Entry2（线程B暂停前e和e.next引用变量的指向）</p><pre> 1 //遍历e所在链上的所有键值对 2 while(null != e) { 3 //断点1，此时线程B中的e为Entry3，e.next为Entry2 4 Entry&lt;K,V&gt; next = e.next; 5 //通常rehash为false，不会重新计算键值对key的hash值 6 if (rehash) { 7 e.hash = null == e.key ? 0 : hash(e.key); 8 } 9 //根据扩容后的table数组长度计算键值对的index10 int i = indexFor(e.hash, newCapacity);11 //头插法12 e.next = newTable[i];//将Entry3的next设置为null13 newTable[i] = e;//将Entry3放置到线程B newTable下标为3的位置14 //继续处理Entry215 e = next;16 }</pre><p>如果想学习Java工程化、高性能及分布式、深入浅出。微服务、Spring，MyBatis，Netty源码分析的朋友可以加我的Java高级交流：854630135，群里有阿里大牛直播讲解技术，以及Java大型互联网技术的视频免费分享给大家。</p><p>执行完第一次循环后线程B中局部变量newTable的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fc0c399f6be54fb3bf7244a4a0d3d48e><p class=pgc-img-caption></p></div><p>执行完第一次循环后hashMap对象的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9bc6311d91a94b838c7e35f420e162d1><p class=pgc-img-caption></p></div><p><strong>执行第二次循环：</strong>e为Entry2，e.next为Entry3（受线程A影响，e和e.next引用变量的指向发生改变）</p><pre> 1 //遍历键值对e链上的所有键值对 2 while(null != e) { 3 //断点1，e为Entry2，e.next为Entry3 4 Entry&lt;K,V&gt; next = e.next; 5 //通常rehash为false，不会重新计算键值对key的hash值 6 if (rehash) { 7 e.hash = null == e.key ? 0 : hash(e.key); 8 } 9 //由线程A的执行结果可知，Entry2的index也为310 int i = indexFor(e.hash, newCapacity);11 //头插法，12 e.next = newTable[i];//将Entry2的next设置为Entry313 newTable[i] = e; //newTable[3]设置为Entry214 //另e等于Entry3，继续执行while循环。15 e = next;16 }</pre><p>执行完第二次循环后线程B中局部变量newTable的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e6d7751bd5bb4f0991a28a6cd405b674><p class=pgc-img-caption></p></div><p>执行完第二次循环后hashMap对象的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15a1197066444c87bb0de2f3e822480f><p class=pgc-img-caption></p></div><p><strong>执行第三次循环：</strong>e变为Entry3，e.next为null</p><pre> 1 //遍历键值对e链上的所有键值对 2 while(null != e) { 3 //断点1，此时线程B中的e变为Entry3，e.next为null 4 Entry&lt;K,V&gt; next = e.next; 5 //通常rehash为false，不会重新计算键值对key的hash值 6 if (rehash) { 7 e.hash = null == e.key ? 0 : hash(e.key); 8 } 9 //由线程A的执行结果可知，Entry3的index为310 int i = indexFor(e.hash, newCapacity);11 //头插法12 e.next = newTable[i];//将Entry3的next设置为当前链条的首个键值对Entry213 newTable[i] = e;//newTable[3]设置为Entry314 //另e=next=null，结束while循环。15 e = next;16 }</pre><p>执行完第三次循环后线程B中局部变量newTable的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0ee04445a05541b091392035b09163cc><p class=pgc-img-caption></p></div><p>执行完第三次循环后hashMap对象的结构：</p><div class=pgc-img><img alt=探究HashMap线性不安全（二）——链表成环的详细过程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a4703070129f4f39a502c19b9b22da4a><p class=pgc-img-caption></p></div><p>​ 至此，线程B因为改变了Entry3的next属性，在hashMap对象中产生了环形链表。下一节，将探究环形链表是如何在hashMap查询时产生死循环的。</p><p>欢迎工作一到八年的Java工程师朋友们加入Java高级交流：854630135</p><p>本群提供免费的学习指导 架构资料 以及免费的解答</p><p>不懂得问题都可以在本群提出来 之后还会有直播平台和讲师直接交流噢</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'HashMap','线性','链表成环'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>