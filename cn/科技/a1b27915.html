<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java总结之容器家族--Collection | 极客快訊</title><meta property="og:title" content="Java总结之容器家族--Collection - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/88ce4e8325964ee3aac0b015656a3c73"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a1b27915.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1b27915.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Java总结之容器家族--Collection"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a1b27915.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java总结之容器家族--Collection</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>一、概述</h1><p>Collection是[收集品]的意思,这里称[容器],是java中的一个接口，位于java.util包下</p><p>Collection下有三大接口：List(列表)、Set(集合)、Queue(队列)</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/88ce4e8325964ee3aac0b015656a3c73><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15b117000af54bc48e38c12488f55d09><p class=pgc-img-caption>容器接口子类及方法</p></div><h1>二、List接口</h1><p>List：列表，顾名思义是一种表结构，核心方法：</p><ul><li>按索引插入元素 void add(int var1, E var2)</li><li>按索引删除元素 E remove(int var1);</li><li>按索引修改元素 E set(int var1, E var2)</li><li>按索引查询元素 E get(int var1)</li></ul><p>特点：</p><p>1.增删改查操作都可以按照索引进行精确的控制，所以是元素的有序排列</p><p>2.允许相同元素</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7977a73b3cde42d3966c0e1e5beeb3d6><p class=pgc-img-caption>List子类</p></div><p>List是java中使用频率非常高的一个接口，最要的子类：ArrayList、Vector、LinkedList</p><p>1.其中ArrayList、Vector是AbstractList-->AbstractCollection-->Collection 路线</p><p>2.LinkedList不止实现了List，还实现了Deque，就像得到两个师傅的真传，招式(方法)更多一些</p><p>Queue接口是队列(先进先出)，Deque接口(双端队列)是Queue的弟子，两头都能随意进出</p><p>所以根据需求即可当栈也可当队列，LinkedList得到了Deque的真传，所以也可以</p><p>关于抽象类：</p><p>抽象类一般是先实现接口，或者拓展一些子类公用方法，总之就是把能做的先做了。</p><p>有种天下父母心的感觉，就像AbstractList对ArrayList说：我能帮你做的尽量都做了，接下来就看你的了。</p><pre>public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt;public abstract class AbstractSequentialList&lt;E&gt; extends AbstractList&lt;E&gt; public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt;</pre><p>1.ArrayList:数组列表</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/db19b91597a149189902702137d0bb8e><p class=pgc-img-caption>ArrayList</p></div><p>2.LinkedList：链式列表</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2e7cf31f241441e3b020405918838184><p class=pgc-img-caption>LinkedList</p></div><p>3.Vector、ArrayList与 LinkedList的比较</p><blockquote><p>可以说Vector、ArrayList是亲兄弟,LinkedList算个堂兄</p></blockquote><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3f6f975203b0449f825bf61d62867761><p class=pgc-img-caption></p></div><pre>尾添加测试[add(E)]</pre><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be9e2330f7c24883890abaedddea3f7f><p class=pgc-img-caption></p></div><pre>操作数opCount=1000W:插入的位置与耗时比较</pre><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ec1d333879ce46f3b7ec27a89bbef916><p class=pgc-img-caption></p></div><pre>可见ArrayList越往后插入越快，因为要变动的元素越少LinkedList从两头到中间速度变慢，取决于链表的查询机制，总的来说，随机添加LinkedList比较有优势些,只是末尾添加ArrayList较好</pre><p>数组和双链表两种数据结构：</p><pre>数组：定点添加，后面元素都要往后挪个位，O(n)-------双链表：耗时在找到那个定点，添加很快，综合O(n)数组：定点删除，后面元素都要往前挪个位，O(n)-------双链表：耗时在找到那个定点，删除很快，综合O(n)数组：定点查询，数组自带索引光环，O(1) -------双链表：一个一个挨着找 O(n)数组：定点修改，数组自带索引光环，O(1) -------双链表：耗时在找到那个定点，修改很快，综合O(n)</pre><p>综上所属：</p><pre>随机访问、修改性能：Vector、ArrayList&gt;LinkedList 考虑到Vector、ArrayList添加或删除时： 1.可能伴随扩容/缩容， 2.当元素个数巨大时，可能造成大量空闲空间 3.数组连续开辟空间，会造成储存空间的碎片化 的这些问题，在大量添加或删除操作使用LinkedList是更好的选择 因为双链表：1.双链表的添加/删除耗时在查找工作，而双链表查询时会查看索引在前半还是后半来决定从头查询或从尾查询，从而最差情况只需size/2,而数组最差情况为size2.链表不需要开辟连续空间，从而避免储存空间的碎片化  另外在数据非常巨大的时候：LinkedList基于双链表，需要new 巨大数量的节点(Node),Vector、ArrayList只是开辟空间，所以更好一些，所以根据需求酌情处理</pre><p>4.关于 Vector</p><p>顺便提一下只有Vector容器对象可以用vector.elements()获取Enumeration对象，其他列表的需要自定义</p><p>在合并字节输入流SequenceInputStream时需要传递一个Enumeration对象，Vector有了用处</p><pre>SequenceInputStream​(Enumeration&lt;? extends InputStream&gt; e)Vector类对集合的元素操作时都加了synchronized，保证线程安全。但使得效率下降：如  public synchronized boolean add(E e) { modCount++; add(e, elementData, elementCount); return true; } 所谓同步：即当一个Iterator被正在被使用，另一个线程对Vector添加或删除元素，这时调用Iterator的方法时将抛出异常public synchronized void replaceAll(UnaryOperator&lt;E&gt; operator) { Objects.requireNonNull(operator); final int expectedModCount = modCount; final Object[] es = elementData; final int size = elementCount; for (int i = 0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) es[i] = operator.apply(elementAt(es, i)); if (modCount != expectedModCount) throw new ConcurrentModificationException(); modCount++; } 可以看到很多关于修改的方法当:modCount != expectedModCount时都会扔一个ConcurrentModificationException异常也就是期望的修改次数与真实的修改次数不一致时sa</pre><h1>三、Set接口</h1><p>集合：数学上的集合性质：</p><ol><li>确定性：给定一个集合，任给一个元素，该元素或者属于或者不属于该集合</li><li>互异性：一个集合中，任何两个元素都认为是不相同的，即每个元素只能出现一次。</li><li>无序性：一个集合中，每个元素的地位都是相同的，元素之间是无序的。</li></ol><p>Set的操作比较少，基本上也就是Collection传下来的方法</p><p>Set一般基于Map来实现：HashSet、LinkedHashSet、TreeSet的特性，根本上是HashMap、LinkedHashMap、TreeMap的特性</p><p>1.HashSet</p><p>HashSet内部有一个HashMap&lt;E,Object> map成员变量，增删实际上是使用map的方法</p><p>按照哈希的顺序:hashCode()，equals(Object obj)</p><p>底层实现：HashMap</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ca5c673cd1f442bcb3451ecc603cd353><p class=pgc-img-caption>HashSet</p></div><pre>private transient HashMap&lt;E,Object&gt; map; public HashSet() { map = new HashMap&lt;&gt;();}public boolean add(E e) { return map.put(e, PRESENT)==null;}public boolean remove(Object o) { return map.remove(o)==PRESENT;}</pre><p>2.LinkedHashSet</p><p>LinkedHashSet是HashSet的子类，源码少得可怜,基本上都是调用父类(HashSet)的构造方法</p><p>基于一个由链表实现的哈希表，保留了元素插入顺序</p><p>底层实现：LinkedHashMap</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2993d297e88940cc89a5394e023e8427><p class=pgc-img-caption>LinkedHashSet</p></div><p>LinkedHashSet中：</p><pre>public LinkedHashSet(int initialCapacity, float loadFactor) { super(initialCapacity, loadFactor, true);}</pre><p>3.TreeSet---有序集合</p><p>实现NavigableSet：使用元素的compareTo对元素进行排序,也可使用Comparator自定义比较器</p><p>TreeSet多拜了一个师傅：NavigableSet-->SortedSet 使用方法也多几个</p><p>底层实现：TreeMap</p><pre>public TreeSet() { this(new TreeMap&lt;&gt;()); }</pre><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4baaeb7ef717427b84afc271aa4accb3><p class=pgc-img-caption>TreeSet</p></div><pre>HashSet&lt;String&gt; hashSet = new HashSet&lt;&gt;(); hashSet.add("赵"); hashSet.add("钱"); hashSet.add("孙"); hashSet.add("李");  //按照哈希的顺序:hashCode()，equals(Object obj) System.out.println(hashSet);//[钱, 赵, 孙, 李]  LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;(); linkedHashSet.add("赵"); linkedHashSet.add("钱"); linkedHashSet.add("孙"); linkedHashSet.add("李"); //基于链表实现了插入的顺序 System.out.println(linkedHashSet);//[赵, 钱, 孙, 李]  TreeSet&lt;String&gt; treeSet = new TreeSet&lt;&gt;(); treeSet.add("赵"); treeSet.add("钱"); treeSet.add("孙"); treeSet.add("李"); //按照compareTo()的排序 System.out.println(treeSet);//[孙, 李, 赵, 钱]</pre><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b6a7987156a0482487ca1dc9a4895f41><p class=pgc-img-caption></p></div><h1>四、Queue</h1><p>关于队列，是一直先进先出的线性数据结构，使用场合比较狭窄</p><p>子类常见的有PriorityQueue(优先队列)和上文提到的LinkedList。</p><div class=pgc-img><img alt=Java总结之容器家族--Collection* onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3e0bb006dcf74b8c835c494a67db53d9><p class=pgc-img-caption>queue</p></div><p>PriorityQueue</p><p>PriorityQueue优先队列，是基于数组实现的二叉堆来实现的特殊队列，具有完全二叉树的性质。</p><p>每次从优先队列中取出来的元素要么是最大值或最小值（最大堆/最小堆）</p><p>Collection的简单总结就酱紫</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','总结','--'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>