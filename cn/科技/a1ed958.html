<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>CPU中的程序是怎么运行起来的 | 极客快訊</title><meta property="og:title" content="CPU中的程序是怎么运行起来的 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f503bf00044b4ccc9513d052c6ef1da7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a1ed958.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a1ed958.html><meta property="article:published_time" content="2020-10-29T21:04:04+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:04+08:00"><meta name=Keywords content><meta name=description content="CPU中的程序是怎么运行起来的"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a1ed958.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>CPU中的程序是怎么运行起来的</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>总述</strong></p><p>最近一位朋友问我，开发的代码是怎么在芯片运行起来的，我就开始给他介绍代码的预编译、汇编、编译、链接然后到一般的文件属性，再到代码运行。但是大佬问了我一句，CPU到底是怎么执行到每一个逻辑的，就讲了哈CPU的架构。这是时候真的有些迷了，虽然有模电数电的底子，但是自己都说迷糊了，汇编怎么对应到机器码再到怎么执行每一个逻辑。</p><p>所以我想了想，我自己也重新学习整理一下，写一篇文章分享给自己也分享给大家。虽然网上也有很多人讲这个过程，我也想用自己的视角去介绍一下。所以我就花了三天时间把《CODE》这本书啃完，然后又看了哈<strong>Crash Course Computer Science</strong>的视频，现在终于可以写篇文章了。</p><p>作者：良知犹存</p><p>转载授权以及围观：欢迎添加微信公众号：Conscience_Remains</p><h1 class=pgc-h-arrow-right>1、<strong>CPU的硬件最小原子</strong></h1><p>计算机从上世纪四十年代发展到现在有八十多年了，我们现在开发应用以及很少会涉及到底层的部分，硬件设计的电子专业在学校里面会学习模电数电这两门课，今天的第一部分就从这里说起。</p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f503bf00044b4ccc9513d052c6ef1da7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p><br></p><p><strong>一般我们不考虑物理的硬件底层的实现逻辑，但是</strong>为了后续的机器码的介绍，这里开始介绍CPU的基本组成部分。</p><p></p><p>我们都知道现在的CPU是无数的晶体管组成，一块很小的CPU用显微镜观察可以看到上百万个元器件，那么最早电脑是啥样的呢？<strong>感谢Crash Course Computer Science的视频，下面有</strong><strong>很好</strong><strong>照片都是从她的视频中截取。以及感谢《CODE》，好多资料也是从此书得来。</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c34c17a8f4f74e2a975e904817c4b01c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>最早的计算机，它有76万5千个组件，300多万个连接点和大约804公里长的用线，这个是真的大，而且它的核心控制还是用继电器实现控制逻辑的。</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3daf32a4b6bc413dbb9b4aa47349242d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>此外，它的性能相较于于现在的电脑来说简直微不足道。</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/73f1534c9d2a4ed388071217758ac6da><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>好了言归正传，我们直接介绍现在计算机中的CPU组成，之前用继电器、电子管进行控制计算，这些基本的元器件使得计算机体型庞大，后来半导体的出现，使得计算机的体积大大减小。没有使用半导体的时候，科学家使用继电器等进行控制电路的开关，控制电路电流的高和低，通过布尔代数组合形成我们现在经常说的逻辑门，继而实现数据的控制。</p><p></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f9f11c5340134c959a3737fab8761f0f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br>如上图所以它会出现如下情况</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/077fe532bf6f41beb63c49efbea833db><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong>这其实就是一个简单开关的与门（AND）电路，所有的变量输入是1的时候，输出才为1。相应的还有非门、或门、异或门等。</strong></p><p><br></p><p><strong>那么半导体是如何做到的呢？下面所示是三极管变化而成的与门（AND）电路，通过两个三极管连接（三极管的工作原理可以百度一哈），实现逻辑。</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3b56e3bd6a074bf793d330f1c22f6419><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p><strong>​</strong></p><p><br></p><p><strong>这是非门（NOT），输入1输出位0，输入位、为0输出为1.</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5aae46b40298401a997cdd703d54c2df><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>这是或门（OR），只有A、B两个同时输入0的时候，输出才为0，其余都为1.</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/650428475a214d809f323fd280d2f6e7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>这是常用的逻辑门的图形表示以及真值表显示，最后一栏为真值表显示，其中A、B为输入，F为输出。</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d2aa61843cf4b01bff6dc5f9f12dc10><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>基于这些逻辑的组合我们可以变成最小的11位二进制逻辑的加法器，1bit的数据锁存器，再扩展为8位加法器，256M存储器。</p><p><br></p><h1 class=pgc-h-arrow-right>2、<strong>CPU的模块组成过程</strong></h1><p>讲完了CPU组成的最小原子结构,接下来我们抽象出来了逻辑门进行</p><p><br></p><p><strong>首先我们先介绍一下CPU的基本架构</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06f889abc0b845708b88fc6aad3fa850><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>一块完整可以执行程序CPU功能部件，里面有基本的ALU算数逻辑单元、控制单元、外部储存器（储存数据和程序）。</p><p><br></p><p><strong>1970年发布的时候，它是第一个封装在单个芯片内完整的ALU。</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/891efc464d3b46e5b3a1310e29ec85cd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>ALU</strong>（算数逻辑单元）有两个单元：<strong>一个算数单元（加法器）</strong>，负责计算机里的所有数字操作，例如加减法、增量运算等；一个<strong>逻辑单元</strong>，负责一些简单的数值测试，例如检测ALU输出是否为零的的电路</p><p><br></p><hr><p><br></p><p><strong>加法器：</strong></p><p><strong>用单个晶体管一个个去拼，把这个电路做出来，到那时会很复杂很难理解。所以我们更高层面的抽象-逻辑门去实现（AND、OR、NOT、XOR）。</strong></p><p><br></p><p><strong>下面这是一个1位的加法器：</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/315b3540ad354bf5943e819a48b39057><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong>二进制数的“和”可以由异或门得到，而“进位”可以由与门得到，所以可以把异或门和与门结合起来来完成两个二进制数 A和B的加法</strong></p><p><br></p><p><strong>AB只能输入0或者1，也就是这个加法器能算0+0，1+0或者1+1。</strong></p><p><br></p><p>脱离具体的形状，我们可以把以上的一个加法器，抽象为一个符号用来显示：</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cedac7c653b42f7ad7633c8d8ddf610><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8f6874a70164d22bfd8c3e7809375b1><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8f6874a70164d22bfd8c3e7809375b1><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b2ad4647288c49829f681a1bd2cc2ebd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong>然后我们在进行扩展，把八个全加器连接，这样就变成了一个8bit的加法器。每个全加器的进位输出都是下一个全加器的进位输入：</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bb3c7bbe9daa4962b51866e033d6a18d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p>用一个抽象的框图进行表示，其中输入是A和B标识为从A0～A7及B0～B7。输出为和输出，标识为从 S0～S7：</p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9427bbb045d4d1f923bf265d3db03e1><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>这样我们就构造了一个简单8位的加法器。</strong></p><p><br></p><hr><p><br></p><p><strong>逻辑单元：</strong>同样<strong>AND、OR、NOT、XOR</strong>的执行，如下图一个简单的判断输出是否为0的电路</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d115dad5d4284562a8d58055ea55bd95><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>它用一堆OR门检查其中一位是否为1，哪怕只有一个输入的bit（位）为1，但都会被被或门到最后一个NOT（非）门进行取反，所以只有输入的数字是0，输出才能是为1。</p><p><strong>告诉ALU执行加减法，</strong>下面图片里面的的V代表<strong>ALU</strong>部分<strong>。</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9690adb3b5c49c9a6fe61b0927d844e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong>通过ALU的FLAGS进行判断，下面有三个标志一个是OVERFLOW（操作超出了总线宽度，设置为true（1））、ZERO（运算结果是否为零）、NEGATIVE（运算结果第一位为1，则设置为true（1），表示为负数）</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/07e3888dfa45411eb48876874782d226><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>这就是ALU中的一些单元，其实也是一大堆逻辑门巧妙连到一起。</strong></p><p><br></p><p><strong>此外我们还需要存储器（memory），如果ALU计算出来数据丢掉那么数据也没什么用了，所以需要内存把数据保存起来，与ALU一起组成CPU</strong></p><p><br></p><p>之前的介绍都是单向顺序执行的电路，那有什么可以返回的电路呢，通过输出来控制影响输入。</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ceb2df842a834aa9859e23ce25aa9c20><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p>进行AND 、NOT、OR组合，变成一个1位锁存器</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d07662394ed9469585770c9c790b8bd8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>输入STE为1，输出为1</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/67797fb5768f475a9816933c6f84400e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>输入RESTE为1，输出为0</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe16e9d72988425fb51ffcfede4595b4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>如果设置和置位都为0，电路会输出最后放置的状态，所以它就保存住1bit位的数据</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b4ac256b3897405fa48bacc4f146e453><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong>其中这样一个1位的锁存器，放入的动作叫做写，拿出数据的动作叫做读</strong></p><p><br></p><p><strong>为了好显示，我们使用再高一级别的抽象层，用下面的框图表示：</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6fc0c8896d074dd98213b958d365eeea><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>随着芯片锁存器大小的扩展，正常连接需要的线是非常之多，所以引入了矩阵方式：</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/446d7d81f4404f74b83bab0e9d896283><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/221e3f1f6bac483997a15084affeaf4d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong>为了将地址转化成为行和列 还要用多路复用器，这就是一个基本的SDRAM的组成结构。</strong></p><p><br></p><p><strong>SRAM DRAM FLASH NVRAM，大家功能上相似，但是用不同的电路储存单个bit的数据，比如使用不同的逻辑门、电容器、、电荷捕获或者忆阻器。但是根本上，这些技术都是矩阵层层嵌套，来储存大量的信息。</strong></p><p><br></p><h1 class=pgc-h-arrow-right>3、<strong>CPU的代码语言执行以及编程语言的变化过程</strong></h1><p><br></p><p>通过不同的逻辑门，我们逐渐搭建起了CPU的硬件部分，同时也抽象到了高层次的“微体系架构”，我们开始告诉CPU的模块进行操作，CPU里面都是101二进制数据，那怎么和CPU执行指令挂上钩呢？</p><p><br></p><p>最早执行机器使用就是穿孔卡片，通过穿孔卡片的特殊位置有没有穿孔，决定机器执行的不同步骤。</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc5f6b057b7e4091a2398700cd2f4c69><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>在计算机早期，程序员编程必须用机器码写程序，一般会在会在纸上写一个“高层次”的描述——伪代码，例如：<strong>从内存中获取当月销售额，再计算出税费。</strong></p><p><br></p><p>这里展示一个简单范例代码，一段机器码 <strong>00101110。</strong></p><p><br></p><p><strong>首先这个机器码分为前四位和后四位，前四位代表操作码，后四位代表地址。</strong></p><p><br></p><p>首先在指令表可以查到 <strong>0010 </strong>对应着执行指令是LOAD_A 意思为从内存地址取出数据，放到寄存器A中。</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/abada6a4d7a645138f4ffefcea675c96><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p>CPU看到<strong>00101110</strong>是怎么执行的呢？</p><p><br></p><p><strong>首先CPU有两个执行时候的寄存器：</strong></p><ol start=1><li>指令地址寄存器，一个追踪器，负责追踪程序运行到哪里了；</li><li>指令寄存器，负责储存当前指令</li></ol><p><br></p><p><strong>其次，CPU执行指令有三个阶段: 取指令->解码->执行</strong></p><p><br></p><p><strong>取指令：负责把指令从RAM中复制到指令寄存器中</strong></p><p><br></p><p>如下所示：<strong>CPU把0010 1110放到指令寄存器中</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/20502604be1847278e92937134a5e41d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>解码阶段：负责解析复制过来的指令对应到操作码是哪个执行，先解析0010</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/669cc3bbed034e8897a77f8cbf5c4ea2><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4e5e5970d1c41b49910d1caa45e13e5><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p>LOAD_A指令的工作：把RAM里面的值放入寄存器A中</p><p><br></p><p><strong>再解析后四位1110，为地址14</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ada3fd1d32d94cea8617d091cbb37719><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>接下来通过控制单元进行选择确认是否执行load指令</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b2e424ceacd4774b4a0d2da155e6932><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>当然控制单元也是由逻辑门连接起来的，这个时候需要一个电路，检查操作码是不是LOAD_A对应的0010</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ddf0a6ba08364ebcad664c1f4922f30e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>执行阶段：当确认了执行的操作码，我们就开始执行</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cbdd9372ae5140c3b0c2698a1f12cbbc><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>从地址1110（10进制14）读取出0000 0011的数据，　　因为是LOAD_A指令，我们把该数据放进寄存器A，不操作其他寄存器</strong></p><p><br></p><p><strong>本次执行完成，然后我们就把“指令地址寄存器”+1，执行下一条命令，一直重复到代码结束。</strong></p><p><br></p><p><strong>如果我们遇到了例如加减运算时候，就可以用到ALU了，数据寄存器把需要进行add的两个数据输入，然后在发送操作码给ALU，ALU开始执行最后输出到暂存的寄存器，关闭ALU，最后再把数据放入正确的寄存器</strong></p><p><br></p><p>除<strong>了执行动作，现代CPU还有时钟控制。</strong>很早的计算机都是用人工插拔来进行每一条指令的计算，但是对于现在的CPU执行频率来说，人工是做不到这样的速度，所以现在CPU里面有专门的<strong>时钟</strong>进行管理CPU的节奏，来告诉CPU要取指令-解码-执行。<strong>类似于练习乐器时候使用的节拍器一样。</strong></p><p><br></p><p><strong>前面介绍程序运行时候我们是假设程序已经在内存里面了，但实际上程序储存的位置不在内存，并且需要在执行时候加载到内存里面。只要内存足够，不仅可以储存要运行的程序，还可以存程序需要的数据，以及运行程序时候产生的新数据。</strong></p><p><br></p><p>不过早期编程都是专家活，不管是全职还是技术控，<strong>都需要非常了解底层硬件，要懂操作码、寄存器等才能写程序，所以编程很麻烦</strong>，哪怕是工程师和科学家都无法完全发挥计算机的能力</p><p><br></p><p>所以程序员开发出了一种新语言，更高层次，更可读性，每个操作码分配一个简单的名字——助记符。助记符后面紧跟数据，形成完整的指令。这样程序员就不用0和1去写代码，可以用load jump等助记符开始编程，<strong>这就是汇编</strong>。前面我们讲过这些助记符，应该还是比较容易理解的。但是CPU是只能识别二进制的，所以程序员又写了二进制程序来帮忙，它可以读懂文字指令，自动转化成二进制指令，这个程序就叫做——<strong>汇编器。</strong></p><p><br></p><p><strong>汇编器</strong>读取用<strong>汇编语言</strong>写的程序，然后转成<strong>机器码。LOAD_A 14 是一个典型的汇编代码。</strong></p><p><br></p><p><strong>发展到现在，就英特尔的CPU 酷睿i7有上千种指令和指令变种，长度从一个字节到15个字节。</strong></p><p><br></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ffa69c5aff8f48d4834cbee827110eb8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><strong></strong></p><p><strong>FORTRAN，是IBM1957年发布的语言，而主持FORTRAN的项目的总监John Backus说，他只是因为懒，所以就开发了新的语言，</strong><strong>是的</strong><strong>大部分新程序的开发是因为更高效率的开发，把一个月的开发时间编程一周，</strong><strong>在</strong><strong>变成一天。</strong></p><p><strong>就FORTRAN使用效果来说，确实也达到了，平均FORTRAN写的程序要比同等的汇编写的代码少二十倍。然后FORTRAN编译器会把FORTRAN代码转为机器码。</strong></p><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/094c03cbc3724046a5bb699186203cd1><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=CPU中的程序是怎么运行起来的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/62f4c72426ad402b90c45a6d5475a3f0><p class=pgc-img-caption></p></div><p>​</p><p><br></p><p><strong>然后陆续新的语言不断产生，60年代有ALGOL、LISP和BASIC等语言；70年代有Pascal、C和Smalltalk；80年代有C++、Objectivs-C和Perl；90年代有Python、Ruby和Java；2000开始出现Swift、C#、Go。未来语言还会越来越多，新的语言用新的平台和新的技术，让我们可以快速的开发使用。</strong></p><p><br></p><p>这就是我分享CPU代码是如何执行起来，里面资料如果大家又想要的，可以关注我微信号回复<strong>CPU中的程序是怎么运行起来的，</strong>后台会自动把资料获取方式发给你，关于本篇文章如果大家有什么更好的思路，欢迎分享交流哈。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'CPU','怎么','运行'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>