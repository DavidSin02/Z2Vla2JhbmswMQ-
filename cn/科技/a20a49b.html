<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM） | 极客快訊</title><meta property="og:title" content="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/44a1c6d1d405420d81a50513351efb8d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a20a49b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a20a49b.html><meta property="article:published_time" content="2020-10-29T21:01:05+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:05+08:00"><meta name=Keywords content><meta name=description content="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a20a49b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>1. K均值算法（K-Means）</h2><p>是一种无监督的聚类学习算法，它尝试找到样本数据的自然类别，分类K是由用户自己定义的，它在不需要任何其它先验知识的情况下，依据算法的迭代规则，把样本划分为K类，通过不断跌代和移动质心来完成分类。是一种硬分类的方法：即以距离为依据，离哪个点距离越近，它就应该标记为哪个编号，计算两个点之间的距离，有可能是向量（x，y）或（x，y，z）。不断的迭代，中心点不断的变换，使得逐渐接近真实的结果，最后要求取前后两次中心点的差值，或到达一定的迭代次数就结束。</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44a1c6d1d405420d81a50513351efb8d><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b4e839fb5db4edda4efa21506b32109><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c3ade0d245804f10990b4ca975709748><p class=pgc-img-caption></p></div><p><strong>API参数：</strong></p><ul><li>参数1：输入的数据集合，可以是一维或多维，它是浮点数。</li><li>参数2：K 为分类的数目。</li><li>参数3：分类的标签，分类索引编号。</li><li>参数4：停止条件，可以用迭代的次数或者我们指定的精度阈值。</li><li>参数5：attempts 尝试几次，有时候为了获得最佳的分类效果，算法要用不同的初始分类进行尝试。</li><li>参数6：flags 表示用哪一种方法进行初始化，最常用的是随机选择。</li></ul><p><strong>例子代码：</strong></p><pre><code>#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;void test(){    Mat srcImg;    srcImg = imread("toux.jpg");    if (srcImg.empty())    {        cout &lt;&lt; "could not load image...\n" &lt;&lt; endl;    }    namedWindow("Original image", CV_WINDOW_AUTOSIZE);    imshow("Original image", srcImg);    //预定义分割的一些颜色    Scalar colorTab[] = {        Scalar(0, 0, 255),        Scalar(0, 255, 0),        Scalar(0, 0, 0),        Scalar(255, 0, 0),        Scalar(255, 0, 255),    };    //首先获取图像的宽和高，每一个像素对应一个数据点，要把数据进行转换，    //kmeans 输入参数是以所有的数据点为每一行，列为数据的维度（图像为3 RGB颜色通道）    int width = srcImg.cols;    int height = srcImg.rows;    int dims = srcImg.channels();    int sampleCount = width*height;  //总像素    int clusterCount = 4;  //分为 4 类    //数据点，即把所有样本装到一个数据点（一行），每一行只有一个数据    Mat points(sampleCount, dims, CV_32F, Scalar(10));     Mat labels;    Mat centers(clusterCount, 1, points.type());  //中心点    //将 RGB 数据转换到样本数据    int index = 0;    for (int i = 0; i &lt; height; i++)  //循环把每个样本找出来    {        for (int j = 0; j &lt; width; j++)        {            index = i*width + j;            Vec3b bgr = srcImg.at&lt;Vec3b&gt;(i, j);  //获取图像上点像素的值            //把只作为样本传进去            points.at&lt;float&gt;(index, 0) = static_cast&lt;int&gt;(bgr[0]);  //把数据转换            points.at&lt;float&gt;(index, 1) = static_cast&lt;int&gt;(bgr[1]);            points.at&lt;float&gt;(index, 2) = static_cast&lt;int&gt;(bgr[2]);        }    }    //运行 kmeans     TermCriteria cirteria = TermCriteria(TermCriteria::EPS + TermCriteria::COUNT, 10, 0.1);    kmeans(points, clusterCount, labels, cirteria, 3, KMEANS_PP_CENTERS, centers);    //显示分类的结果    Mat result = Mat::zeros(srcImg.size(), srcImg.type());    for (int i = 0; i &lt; height; i++)    {        for (int j = 0; j &lt; width; j++)        {            index = i*width + j;  //把二维数组转换到一维数组，找它里面的index            //结果显示通过label 获取，根据聚类的编号            int label = labels.at&lt;int&gt;(index, 0);             result.at&lt;Vec3b&gt;(i, j)[0] = colorTab[label][0];            result.at&lt;Vec3b&gt;(i, j)[1] = colorTab[label][1];            result.at&lt;Vec3b&gt;(i, j)[2] = colorTab[label][2];        }    }    for (int i = 0; i &lt; centers.rows; i++)    {        int x = centers.at&lt;float&gt;(i, 0);        int y = centers.at&lt;float&gt;(i, 0);        cout &lt;&lt; "center =  " &lt;&lt; i &lt;&lt;"  "&lt;&lt; "c.x: " &lt;&lt; x &lt;&lt;"\t"&lt;&lt; "c.y: " &lt;&lt; y &lt;&lt; endl;    }    imshow("KMeans", result);}</code></pre><p><strong>效果图：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0940a49e9d2a4d7aa950c44609d7176b><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right>2.高斯混合模型（GMM）</h2><h3 class=pgc-h-arrow-right>2.1 一些概念理解</h3><h4 class=pgc-h-arrow-right>2.1.1 协方差</h4><p>统计学里最基本的就是样本的均值、方差和标准差。在一个含有n个样本的集合X={X1 ,…,Xn}。</p><p>均值：</p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/13a4add1f08e4ca7ae5a2e1a6620da10><p class=pgc-img-caption></p></div><p>标准差：</p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52b99a6fabe14dfe962d2656091190fb><p class=pgc-img-caption></p></div><p>方差：</p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/194f0ca39aa74114b650b1d3bb72ee88><p class=pgc-img-caption></p></div><p>均值描述的是样本集合的中间点，它告诉我们的信息是很有限的，而标准差描述的是样本集合的各个样本点到均值的距离之平均。以这两个集合为例，[0，8，12，20]和[8，9，11，12]，两个集合的均值都是10，但显然两个集合差别是很大的，计算两者的标准差，前者是8.3，后者是1.8，显然后者较为集中，所以标准差小一点，标准差描述的就是这种“散布度”。之所以除以n-1而不是除以n，是因为这样能使我们以较小的样本集更好的逼近总体的标准差，即统计上所谓的“无偏估计”。方差则仅仅是标准差的平方。</p><p><strong>为什么需要协方差？</strong>上面几个统计量看似已经描述的差不多了，但注意到，标准差和方差一般是用来描述一维数据的，现实生活我们常常遇到含有多维数据的数据集，例如要统计多个学科的考试成绩。面对这样的数据集，可以按照每一维独立的计算其方差，但是通常我们还想了解更多，比如，一个男孩子的猥琐程度跟他受女孩子欢迎程度是否存在一些联系啊，嘿嘿~协方差就是这样一种用来度量两个随机变量关系的统计量，我们可以仿照方差的定义：</p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f4918338498d49f1aabf2008aa072eaf><p class=pgc-img-caption></p></div><p>来度量各个维度偏离其均值的程度，标准差可以这么来定义：</p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ad833160331e48999ea83186dfc3d986><p class=pgc-img-caption></p></div><p>如果协方差的结果的结果为正值，则说明两者是正相关的(从协方差可以引出“相关系数”的定义)，也就是说一个人越猥琐就越受女孩子欢迎，结果为负值就说明负相关的，越猥琐女孩子越讨厌，可能吗？如果为0，也是就是统计上说的“相互独立”。</p><h4 class=pgc-h-arrow-right>2.1.2 高斯函数（模型）</h4><p>高斯一维函数：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7d3c16841a994c6b9714fb51ba097560><p class=pgc-img-caption></p></div><p>高斯概率分布函数：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7adfbd2bc432421b9dab21652de9b81f><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>2.1.3 EM 算法</h4><p>MLE 是用来求模型参数的，核心是“模型已知，求取参数”，模型的意思就是数据符合什么函数，比如我们硬币的正反就是二项分布模型，再比如我们平时随机生成的一类数据符合高斯模型,公式如下：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e0c99e492bba4a73a534263f053a4598><p class=pgc-img-caption></p></div><p><br></p><ul><li>L(Θ)：联合概率分布函数，就是每个样本出现的概率乘积。</li><li>x1,x2,x3….xn : 样本</li><li>Θ：模型的参数（比如高斯模型的两个参数：μ、σ）</li><li>p(xi ; Θ):第i个样本的概率模型</li><li>xi: 第i个样本</li></ul><p>平时使用的时候取对数，完全为了求解方便：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03af45428e864e888a4c97de42718f7f><p class=pgc-img-caption></p></div><p>ê 为平均对数似然。而我们平时所称的最大似然为最大的对数平均似然，即:</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/62d56715887c469f8de83c96dbc9e083><p class=pgc-img-caption></p></div><p><strong>举个例子：</strong>抛硬币的简单例子，现在有一个正反面不是很匀称的硬币，如果正面朝上记为H，方面朝上记为T，抛10次的结果如下：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a8d5f28dc1014384a7518329c801d7dd><p class=pgc-img-caption></p></div><p><br></p><p>求这个硬币正面朝上的概率有多大？很显然这个概率是0.2。现在我们用MLE的思想去求解它。我们知道每次抛硬币都是一次二项分布，设正面朝上的概率是μ；那么似然函数为：<br></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5dd2a9e26b294cd493969a3891833287><p class=pgc-img-caption></p></div><p>x=1表示正面朝上，x=0表示方面朝上。那么有：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f63d4282d7c44c75b80ae1114f0850f0><p class=pgc-img-caption></p></div><p><strong>求导：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ea5b115a336845c69ca8e90258cdfc12><p class=pgc-img-caption></p></div><p><strong>令导数为0，很容易得到：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f2f461453e44a259f355422b1014c82><p class=pgc-img-caption></p></div><p><br></p><p>也就是0.2 。</p><p><br></p><p><strong>再举个例子：</strong></p><p>假如我们有一组连续变量的采样值（x1,x2,…,xn），我们知道这组数据服从正态分布，标准差已知。请问这个正态分布的期望值为多少时，产生这个已有数据的概率最大？</p><p>P(Data | M) = ？</p><p>根据公式：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e8bc9fae52a473d804ae9bac188f61e><p class=pgc-img-caption></p></div><p><strong>可得:</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c90948b5694045e7892cc372b2f961ac><p class=pgc-img-caption></p></div><p><strong>对μ求导可得：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/41f8c2890baa4cc8b97d1d3d253df9ef><p class=pgc-img-caption></p></div><p>则最大似然估计的结果为μ=(x1+x2+…+xn) / n</p><p><br></p><p><strong>总结：</strong>其实我们用的很多函数都可以说是一个最大似然函数，比如符合y = x2、y = kx…都可以当做一个模型去求解一个极大似然函数，只不过我们得到的数据不符合这些模型而已。只要是求概率的问题，都会写出一个函数，这个函数其实就是最大似然函数，可以说是目标函数，也可以说是似然函数，把每个数据出现的概率相乘就是似然函数，再求对数，再求均值，再求最值，这就是极大似然了，就是一个名字而已！</p><p><strong>EM算法核心：</strong>猜（E-step）,反思（M-step）,重复；</p><p><strong>算法理解：</strong></p><p><strong>问题一：</strong></p><p>现在一个班里有50个男生，50个女生，且男生站左，女生站右。我们假定男生的身高服从正态分布:</p><p>N(μ1,σ1²)</p><p>女生的身高则服从另一个正态分布：</p><p>N(μ2,σ2²)</p><p>这时候我们可以用极大似然法（MLE），分别通过这50个男生和50个女生的样本来估计这两个正态分布的参数。</p><p><strong>问题二：</strong></p><p>但现在我们让情况复杂一点，就是这50个男生和50个女生混在一起了。我们拥有100个人的身高数据，却不知道这100个人每一个是男生还是女生。这时候情况就有点尴尬，因为通常来说，我们只有知道了精确的男女身高的正态分布参数我们才能知道每一个人更有可能是男生还是女生。但从另一方面去考量，我们只有知道了每个人是男生还是女生才能尽可能准确地估计男女各自身高的正态分布的参数。</p><p><strong>问题二需要求解两个问题：</strong></p><ul><li>假设a=（第k个样本是男生还是女生）</li><li>假设b=（高斯模型的参数）<br>如果知道a，那用问题一的方法就可以求解b，如果知道b那也就可以分类a了，但是前提是两个都不知道,比如y=x+1，现在让你求解x和y的值，怎么办？</li></ul><p><strong>解决：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1d6a01c53ce04035bc72a6a7cd20c111><p class=pgc-img-caption></p></div><p><strong>总结：</strong>其实EM算法就是先通过假设的参数把数据进行分类，然后通过分类的数据计算参数，接着对比计算的参数和假设的参数是否满足精度，不满足就返回去，满足就结束。EM是一种思想，而不是像K-means等是一种算法。</p><p><strong>高斯混合函数的原理：</strong>（1）单高斯分布模型GSM：多维变量X服从高斯分布时，它的概率密度函数为：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1e3cea77756d4a7092dab6ed2944439c><p class=pgc-img-caption></p></div><p>x是维度为d的列向量，u是模型期望，Σ是模型方差。在实际应用中u通常用样本均值来代替，Σ通常用样本方差来代替。很容易判断一个样x本是否属于类别C。因为每个类别都有自己的u和Σ，把x代入（1）式，当概率大于一定阈值时我们就认为x属于C类。从几何上讲，单高斯分布模型在二维空间应该近似于椭圆，在三维空间上近似于椭球。遗憾的是在很多分类问题中，属于同一类别的样本点并不满足“椭圆”分布的特性。这就引入了高斯混合模型。</p><p><strong>高斯混合模型GMM：</strong>GMM认为数据是从几个GSM中生成出来的，即：</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84bb8fb9994a4cc9bf7f0fe3a0b29704><p class=pgc-img-caption></p></div><p>K需要事先确定好，就像K-means中的K一样。πk是权值因子。其中的任意一个高斯分布N(x;uk,Σk)叫作这个模型的一个component。这里有个问题，为什么我们要假设数据是由若干个高斯分布组合而成的，而不假设是其他分布呢？实际上不管是什么分布，只K取得足够大，这个XX Mixture Model就会变得足够复杂，就可以用来逼近任意连续的概率密度分布。只是因为高斯函数具有良好的计算性能，所GMM被广泛地应用。</p><p><strong>样本分类已知情况下的GMM:</strong>当每个样本所属分类已知时，GMM的参数非常好确定，直接利用Maximum Likelihood。设样本容量为N，属于K个分类的样本数量分别是N1,N2,…,Nk，属于第k个分类的样本集合是L(k)。</p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4b837bf68a7e4f45a0c627ecb2985a17><p class=pgc-img-caption></p></div><p><strong>样本分类未知情况下的GMM:</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a06d51f75df40f9b88a2abe2048bf45><p class=pgc-img-caption></p></div><p><strong>EM求解：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3db1bc094004c35b9ba85a052054638><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/046c3663c8ff48eaab322b4779c826a5><p class=pgc-img-caption></p></div><p><strong>例子代码：</strong></p><pre><code>#include&lt;opencv2/opencv.hpp&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;//高斯混合方法using namespace cv::ml;void test(){    Mat srcImg;    srcImg = imread("toux.jpg");    if (srcImg.empty())    {        cout &lt;&lt; "could not load image...\n" &lt;&lt; endl;    }    namedWindow("Original image", CV_WINDOW_NORMAL);    imshow("Original image", srcImg);    //预定义分割的一些颜色    Scalar colors[] = {        Scalar(0, 0, 255),  //红        Scalar(0, 255, 0),  //绿        Scalar(255, 0, 0),  //蓝        Scalar(0, 255, 255), // 黄        Scalar(255, 0, 255),  //品红    };    //首先获取图像的宽和高，每一个像素对应一个数据点，要把数据进行转换，    //kmeans 输入参数是以所有的数据点为每一行，列为数据的维度（图像为3 RGB颜色通道）    int width = srcImg.cols;    int height = srcImg.rows;    int dims = srcImg.channels();    int numCount = width*height;  //总像素点数    int numCluster = 3;  //分为 3 类    //数据点，即把所有样本装到一个数据点（一行），每一行只有一个数据    Mat points(numCount, dims, CV_64FC1);    Mat labels;    //将图像 RGB 数据转换为样本数据    int index = 0;    for (int row = 0; row &lt; height; row++)  //这里的步骤与 KMeans 是一样的    {        for (int col = 0; col &lt; width; col++)        {            index = row*width + col;            Vec3b rgb = srcImg.at&lt;Vec3b&gt;(row, col);  //获取图像上点像素的rgb值            //把只作为样本传进去            points.at&lt;double&gt;(index, 0) = static_cast&lt;int&gt;(rgb[0]);            points.at&lt;double&gt;(index, 1) = static_cast&lt;int&gt;(rgb[1]);            points.at&lt;double&gt;(index, 2) = static_cast&lt;int&gt;(rgb[2]);        }    }    // EM 训练    Ptr&lt;EM&gt;emModel = EM::create();  //生成 EM 期望最大化，起图像分割的方式是基于机器学习的方式    emModel-&gt;setClustersNumber(numCluster);  //设置分类数    emModel-&gt;setCovarianceMatrixType(EM::COV_MAT_SPHERICAL);  //协方差矩阵的类型    //迭代条件，EM 训练比 KMeans 耗时，可能会不收敛，所以迭代次数设大点    emModel-&gt;setTermCriteria(TermCriteria(TermCriteria::EPS +        TermCriteria::COUNT, 10, 0.1));    //EM 训练，获得分类结果，参数 labels 与 KMeans 的 labels 参数意思一样，速度比 KMeans 要慢很多    emModel-&gt;trainEM(points, noArray(), labels, noArray());    //对每个像素标记颜色与显示    Mat resultNoPredict = Mat::zeros(srcImg.size(), CV_8UC3);    Mat resultPredict = Mat::zeros(srcImg.size(), CV_8UC3);    Mat sample(dims, 1, CV_64FC1);    double time = getTickCount();    int r = 0, g = 0, b = 0;  //预言会用到    for (int row = 0; row &lt; height; row++)    {        for (int col = 0; col &lt; width; col++)        {            //获取训练的分类结果，放到 result 中            index = row*width + col;  //把二维数组转换到一维数组，找它里面的index            //结果显示通过label 获取，根据聚类的编号            int label = labels.at&lt;int&gt;(index, 0);            Scalar c = colors[label];  //label 上已经有颜色了            resultNoPredict.at&lt;Vec3b&gt;(row, col)[0] = c[0];            resultNoPredict.at&lt;Vec3b&gt;(row, col)[1] = c[1];            resultNoPredict.at&lt;Vec3b&gt;(row, col)[2] = c[2];            //通过预言获得分类结果，因为 EM 训练用的是 srcImg 的颜色数据，所以用 srcImg 的颜色数据做预言，            //得到的结果与 result 是一模一样的            b = srcImg.at&lt;Vec3b&gt;(row, col)[0];            g = srcImg.at&lt;Vec3b&gt;(row, col)[1];            r = srcImg.at&lt;Vec3b&gt;(row, col)[2];            sample.at&lt;double&gt;(0) = b;            sample.at&lt;double&gt;(1) = g;            sample.at&lt;double&gt;(2) = r;            //预言            int response = cvRound(emModel-&gt;predict2(sample, noArray())[1]);            Scalar c2 = colors[response];            resultPredict.at&lt;Vec3b&gt;(row, col)[0] = c2[0];            resultPredict.at&lt;Vec3b&gt;(row, col)[1] = c2[1];            resultPredict.at&lt;Vec3b&gt;(row, col)[2] = c2[2];        }    }    //打印所需要的时间    cout &lt;&lt; "execution time(ms):" &lt;&lt; (getTickCount() - time) / getTickFrequency() * 1000 &lt;&lt; endl;    namedWindow("EM-Segmentation nopredict", CV_WINDOW_NORMAL);    imshow("EM-Segmentation nopredict", resultNoPredict);    namedWindow("EM-Segmentation predict", CV_WINDOW_NORMAL);    imshow("EM-Segmentation predict", resultPredict);}int main(){    test();    waitKey(0);    return 0;}</code></pre><p><strong>效果图：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e95c08446b9e42e683a726944df27a14><p class=pgc-img-caption></p></div><p><br></p><p><strong>遇到的问题：</strong></p><p><br></p><div class=pgc-img><img alt="图像分割实战 - K均值算法（K-Means）和高斯混合模型（GMM）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3adc59f2dd644f94be514aa01509d6d8><p class=pgc-img-caption></p></div><p><strong>我的解决办法：</strong></p><p>更换 OpenCV 版本:报错时用的是3.1版本，更换成3.3版本，这里要注意 OpenCV 版本与 VS 之间的对应版本即可。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'图像','实战','Means'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>