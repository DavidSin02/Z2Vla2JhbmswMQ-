<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 | 极客快訊</title><meta property="og:title" content="“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a33570f8a0234b9ebec6e7c7d55e341e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a2a51f04.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a2a51f04.html><meta property="article:published_time" content="2020-11-14T21:02:38+08:00"><meta property="article:modified_time" content="2020-11-14T21:02:38+08:00"><meta name=Keywords content><meta name=description content="“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a2a51f04.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>难度</strong></h1><p>初级</p><h1><strong>学习时间</strong></h1><p>30分钟</p><h1><strong>适合人群</strong></h1><p>零基础</p><h1><strong>开发语言</strong></h1><p>Java</p><h1><strong>开发环境</strong></h1><ul><li>JDK v11</li><li>IntelliJIDEA v2018.3</li></ul><h1><strong>友情提示</strong></h1><ul><li><strong>本教学属于系列教学，内容具有连贯性，本章使用到的内容之前教学中都有详细讲解。</strong></li><li><strong>本章内容针对零基础或基础较差的同学比较友好，可能对于有基础的同学来说很简单，希望大家可以根据自己的实际情况选择继续看完或等待看下一篇文章。谢谢大家的谅解！</strong></li></ul><h1><strong>1.温故知新</strong></h1><p>前面在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6678949160684618247/?group_id=6678949160684618247" target=_blank>《“全栈2019”Java原子操作第九章：atomic包下原子数组介绍与使用》</a>一章中介绍了<strong>什么是原子数组AtomicIntegerArray、AtomicLongArray和AtomicReferenceArray&lt;E></strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6679249369402704388/?group_id=6679249369402704388" target=_blank>《“全栈2019”Java原子操作第十章：atomic包下字段原子更新器介绍》</a>一章中介绍了<strong>什么是字段原子更新器AtomicIntegerFieldUpdater&lt;T>、AtomicLongFieldUpdater&lt;T>和AtomicReferenceFieldUpdater&lt;T,​V>。</strong></p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6679706985446769164/?group_id=6679706985446769164" target=_blank>《“全栈2019”Java原子操作第十一章：CAS与ABA问题介绍与探讨》</a>一章中介绍了<strong>CAS算法中存在的ABA问题</strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6680534743513039368/?group_id=6680534743513039368" target=_blank>《“全栈2019”Java原子操作第十二章：AtomicStampedReference详解》</a>一章中介绍了<strong>什么是带版本号的原子类AtomicStampedReference&lt;V></strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6680912625175364107/?group_id=6680912625175364107" target=_blank>《“全栈2019”Java原子操作第十三章：AtomicMarkableReference类》</a>一章中介绍了<strong>什么是带修改标记的原子类AtomicMarkableReference&lt;V></strong>。</p><p>在<a class=pgc-link data-content=mp href="https://www.toutiao.com/i6681250302424777224/?group_id=6681250302424777224" target=_blank>《“全栈2019”Java原子操作第十四章：高性能高效率的原子类介绍》</a>一章中介绍了<strong>高性能高效率的原子类DoubleAccumulator、DoubleAdder、LongAccumulator、LongAdder</strong>。</p><p>现在介绍<strong>高性能原子类是如何实现的</strong>。</p><h1><strong>2.通过</strong>LongAdder源码分析高性能原子类是如何实现的</h1><p>以LongAdder类为例，阅读源码了解实现原理。</p><p>LongAdder类的继承结构：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a33570f8a0234b9ebec6e7c7d55e341e><p class=pgc-img-caption></p></div><p>LongAdder的直接父类是Striped64。</p><p>Striped64是<strong>适用于于并发情况下进行累加运算的类（Java8新增的）</strong>。它是抽象的，需要子类去实现它里面的抽象方法才能使用。在高并发情况下，它不光性能强，而且效率也高。</p><p>Striped64的子类包括前一章我们介绍到的<strong>DoubleAccumulator、DoubleAdder、LongAccumulator和LongAdder四个原子类。</strong></p><p>下面我们一起来看看它内部属性有哪些。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8ba663ce706f4dd39fee74dfc5afd240><p class=pgc-img-caption></p></div><p>在Striped64类中，这四个变量值得注意：</p><ol><li>static final int NCPU = Runtime.getRuntime().availableProcessors();</li><li>transient volatile Cell[] cells;</li><li>transient volatile long base;</li><li>transient volatile int cellsBusy;</li></ol><p>依次来看：</p><p>变量NCPU是用来<strong>记录当前机器上有多少个可用的CPU</strong>。</p><p>从该变量可以看出：<strong>一旦计算任务繁重，就会充分利用CPU资源。</strong></p><p>这也就是为什么Striped64及其子类性能高效率高的原因之一。</p><p>变量cells是一个Cell数组。</p><p><strong>Cell类相当于是一个低配版的原子类。</strong></p><p>为什么这么说呢？</p><p>因为<strong>Cell类里面有一个用来记录内存值的变量和一个调用底层CAS算法的方法</strong>：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fd73af0470a847899b9cc1c283b58eaa><p class=pgc-img-caption></p></div><p>可以说，<strong>Cell类就是一个嵌入在Striped64类中的原子类。</strong></p><p>可它为什么要嵌入在Striped64类中呢？</p><p>Striped64类内部需要一个原子类数组，组成数组的原子类一定要轻量，满足基本的原子类要求即可。已有的原子类太重量级，一旦形成数组，内存就是一笔不小的开销，这时就需要一个满足原子类基本要求的且轻量的原子类，Cell类就诞生了，就在Striped64类中，以内部类的形式存在。Cell类里面只有一个用于记录内存值的变量value，和一个利用CAS算法更新值的方法cas。由于它没有过多的功能，Cell类只能在atomic包内使用，不能在包外使用。</p><p>Striped64类为什么需要一个原子类数组（Cell数组）呢？</p><p>在计算机中，单线程情况下，一个线程去执行一个原子类任务，这样的操作没有任何问题；但是在多线程情况下，三个线程共同去执行一个原子类任务，看起来也没有什么问题，却暴露出线程资源浪费现象：三个线程共同执行一个原子类任务，其中只有一个线程做的事情是有效的，其他两个线程做了无用功，这无疑是一种线程资源浪费，而且还占用了CPU资源。为了解决此类现象，Striped64类定义出原子类数组，尽可能让多线程同时完成更多的原子类任务，高效利用线程资源和CPU资源。</p><p>Striped64类中为什么还有一个long类型变量base呢？</p><p>在计算机中，计算任务不是总有那么多，也有很少的时候。10000个计算任务和1个计算任务用的线程个数和占的CPU资源是不一样的，针对上述情况，Striped64类分了两种情况：同时要计算的任务很多和同时要计算的任务不多，即高并发和非高并发。</p><p>非高并发情况：这时候需要计算的任务可能只有一两个，一个线程完全应付的来，而且也没有用原子类数组的必要，用一个变量足以，这个变量就是base。当计算任务完成直接返回base变量的值即可。</p><p>高并发情况：这时候需要计算的任务可能就有10000或者更多，一个线程可以应付的来，但是太慢，这时会支援多个线程共同来完成这些任务。多个线程共同操作一个变量必然会造成线程资源的浪费，而且CPU也被占用着。为了不让线程做没用的忙碌，有必要用原子类数组来装任务结果。当计算任务完成时，返回base与Cell数组中每个Cell对象的value之和。</p><p>以add(long x)方法为例来说具体是怎么实现的：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7bc0107756bc46cc9b70e91797241023><p class=pgc-img-caption></p></div><p>下面一步一步来看。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/601ef9fed6204fc4ba05104b1a845a02><p class=pgc-img-caption></p></div><p>这一步是判断Cell数组是否已经被初始化。</p><p>为什么要判断Cell数组是否已经被初始化？</p><p>若Cell数组已被初始化，说明计算任务很多，已启动高并发模式。</p><p>若Cell数组没有被初始化，说明计算任务很少，当前线程数量还应付得来。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36aca8a32e094bca96e78781457d0ca2><p class=pgc-img-caption></p></div><p>如果程序来到这一步，说明Cell数组没有被初始化，计算任务不是很多，当前线程数量还应付得来。但是，如果当前线程数量利用CAS算法更新base值失败的话，那就要进入高并发模式，去初始化Cell数组啦。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0cacdd9dc9c54a608062af4ef23be208><p class=pgc-img-caption></p></div><p>局部变量uncontended用来记录后面Cell对象调用cas()方法利用CAS算法更新值是否成功。</p><p>若成功，则不必进入longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法；</p><p>若不成功，则需要进入longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法。</p><p>longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法是用来继续更新值的方法。</p><p>继续往下看，if语句中条件表达式有四个：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b1f9857b0d684d4bae5761748d9b7426><p class=pgc-img-caption></p></div><ol><li>cs == null</li><li>(m = cs.length - 1) &lt; 0</li><li>(c = cs[getProbe() & m]) == null</li><li>!(uncontended = c.cas(v = c.value, v + x))</li></ol><p>这四个条件表达式它们用“||”符合连接，只要满足其中任意一个，就进入赋值阶段。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72c837107cb5472fb90a7af6536ec923><p class=pgc-img-caption></p></div><p>“cs == null”：走到这一步，说明cells数组已经不为空了，因为在它之前“(cs = cells) != null”判断过了，所以这里的cells通常来说不会为空。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b58b53e78fa64eaea1a91a3407c48270><p class=pgc-img-caption></p></div><p>“(m = cs.length - 1) &lt; 0”：既然Cell数组不为空，那么Cell数组的长度是否为0呢？该步骤就是检查Cell数组长度为0的情况。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/606ff33e7634499190eb06a4e8f4fec9><p class=pgc-img-caption></p></div><p>“(c = cs[getProbe() & m]) == null”：Cell数组不为空且Cell数组长度也不为0，接下来就该获取其中一个Cell对象，然后进行CAS赋值操作。</p><p>问题是该取哪个位置的元素呢？</p><p>这个就通过我们的getProbe()方法计算得到的：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75bc8df0e1cc430d9ab58af5e6d8ba8a><p class=pgc-img-caption></p></div><p>getProbe()方法：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ffeec1a9b4f4425fa626010327b0712e><p class=pgc-img-caption></p></div><p>通过对当前线程进行hash运算，得到一个hash值。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/818de724eb3440b2afac5b1963c4dbf9><p class=pgc-img-caption></p></div><p>然后拿着这个hash值和数组最大下标做“&”运算，运算总会得到一个0-最大下标的值，然后取到cells[前面计算好的下标]的元素，最后判断该元素是否为空。</p><p>来一个动画演示一下上述操作：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a9ca33414b374dc0adac33107ab42bd4><p class=pgc-img-caption></p></div><p>为什么还有判断该元素是否为空？</p><p>因为有可能该位置元素前面已经被其他线程算过，所以我们取到已存在的元素时，只需在此基础之上累加即可。</p><p>下面就是开始累加的操作：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/321a23ac131e452886795a6f900f683b><p class=pgc-img-caption></p></div><p>“!(uncontended = c.cas(v = c.value, v + x))”：能进行到这一步，说明Cell对象不为空，那么我们就继续在此基础之上调用cas(v = c.value, v + x)方法利用CAS算法进行赋值。并将赋值是否成功的结果用变量uncontended记录下来，以便在后面运算时做出相应的决策。</p><p>假设最后一步cas失败，我们进入到“longAccumulate(x, null, uncontended)”执行步骤中：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2555f19192d64175ba568ef2e0551406><p class=pgc-img-caption></p></div><p>longAccumulate(long x, LongBinaryOperator fn, boolean wasUncontended)方法：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2abf878ed3004e598912c0a3fa26c722><p class=pgc-img-caption></p></div><p>方法太长，我们依次分段往下说。</p><p>在此之前，了解几个参数的作用：</p><p><strong>long x</strong>：操作数，比如给原值+1，那么这个1就是操作数。</p><p><strong>LongBinaryOperator fn</strong>：二元运算，即自定义操作数与原值做什么运算，如加法、减法、乘法、除法等等。</p><p><strong>boolean wasUncontended</strong>：前面CAS赋值是否成功。</p><p>方法最开始需要给当前线程分配操作的Cell对象，待分配的Cell对象被装在Cell数组变量cells中（<strong>cells初始值为null</strong>）：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8c0e3501c5cb4399b36b7ab230f8c270><p class=pgc-img-caption></p></div><p>合理分配就成了一个问题。若分配不合理，所有线程都操作一个Cell对象，那就没必要建数组，分配Cell对象了。</p><h1>&算法</h1><p>Striped64类就采取了一种类似于取余算法的操作：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e736ba427804dd8a3b6d086f9ae4fd8><p class=pgc-img-caption></p></div><p>下面，我们就来简单模拟这一操作。</p><p>模拟100个线程和长度为8的Cell数组分配过程：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0a3a54b916894969bfdb4b18143df2c2><p class=pgc-img-caption></p></div><p>例子中“i & 7”里面的7是数组最大下标，即数组长度-1。和add(long x)方法源码中的操作一样：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c95d4e2498a148cf9000773056c98032><p class=pgc-img-caption></p></div><p>运行程序，执行结果：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fc64e075f255425fa7244b6e52d864ad><p class=pgc-img-caption></p></div><p>从运行结果来看，结果一直是0-7循环，即cells[0]-cells[7]，这样我们每个元素都会被合理取到。</p><p>不得不佩服这一设计，很巧妙。</p><h1>hash值为0时，重新计算</h1><p>在longAccumulate()方法内部用一个局部变量h来记录当前线程的hash值：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77d2f8373d3044ef9fb83fe00d325e5a><p class=pgc-img-caption></p></div><p>如果h为0的话，则会强制重新再计算一次：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8c8fcca527da42dfab0080e5ceba0208><p class=pgc-img-caption></p></div><p>顺便将变量wasUncontended置为true。</p><h1>避免hash碰撞</h1><p>用一个局部变量collide来避免hash碰撞情况，当cells数组长度大于CPU数量时，我们就要去重新算一次当前线程的hash值：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19d8a451a92b44f59b79717972fb3ab0><p class=pgc-img-caption></p></div><p>目的就是避免发生hash值相同的情况，即hash碰撞。</p><h1>外层无限循环</h1><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8bb04648437e4676abc79c54b4706092><p class=pgc-img-caption></p></div><p>外层无需循环用来做CAS赋值操作的，待会分析到里面具体操作时你就会看到。</p><h1>Cell数组、Cell对象、下标、操作数</h1><p>用四个临时变量来记录当前线程操作的Cell数组、Cell对象、下标以及操作数：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/58c6a18a01f941a99f81610c7e5a49f9><p class=pgc-img-caption></p></div><p><strong>Cell[] cs：</strong>当前线程操作的Cell数组，即cells变量;</p><p><strong>Cell c：</strong>当前线程操作的Cell对象，该对象从Cell数组分配而来的;</p><p><strong>int n：</strong>给当前线程分配的下标;</p><p><strong>long v：</strong>参与运算的操作数；</p><h1>初始化Cell数组</h1><p>最初，变量cells还没有被初始：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d7cddc5305de4f7ca7958cb050b6b613><p class=pgc-img-caption></p></div><p>所以一旦出现高并发情况，第一时间应该是先初始化cells变量：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9505ff4700074d098f3778d9c15e811a><p class=pgc-img-caption></p></div><p><strong>“cellsBusy == 0”：</strong>没有其他线程正在初始化Cell数组。</p><p><strong>“cells == cs”：</strong>cells数组为null，没有被初始化过。</p><p><strong>“casCellsBusy()”：</strong></p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f535dd1f9061475ab63d8151a0a89eab><p class=pgc-img-caption></p></div><p>cellsBusy算是一把非阻塞锁，如果没有线程正在给cells赋值，那么casCellsBusy()方法执行结果就为true；如果已有线程正在给cells赋值，那么casCellsBusy()方法执行结果为false。</p><p>当casCellsBusy()方法返回false时，<strong>因为是无限循环，所以还得再执行循环体里面的内容，直到cells变量被初始化</strong>：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64ce90b974c04e6a963d320c4468cd41><p class=pgc-img-caption></p></div><p>如果拿到给cells变量初始化的锁，那么就可以执行以下内容（即初始化cells变量）：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b2e6597a61cd443496fed90b075f5576><p class=pgc-img-caption></p></div><p><strong>“if(cs == cells){}”：</strong>在上面已经判断过了，这里如果没有问题的话，肯定为true。</p><p><strong>“Cell[] rs = new Cell[2];”：</strong>创建Cell数组，初始长度为2，默认扩容公式是2^n。</p><p><strong>“rs[h & 1] = new Cell(x);”：</strong>h为上面说过的当前线程hash值，1为Cell数组长度-1，这里利用&算法给各个线程分配元素。</p><p>此处因为是第一个元素，所以直接将操作数作为参数传入Cell对象。</p><p><strong>“cells = rs;”：</strong>将初始化好的Cell数组赋给cells变量。</p><p><strong>“break done;”：</strong>结束外层无限循环，第一次赋值到此完成。</p><p>代码结束之前，<strong>在finally代码块中将cellsBusy变量又置为0</strong>。</p><p>第一次赋值过程分析完成，下面来看后续赋值过程是怎样的。</p><p>只拿出局部代码来分析：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d5049eabece4bd7bd280e433c0d2508><p class=pgc-img-caption></p></div><p><strong>“(c = cs[(n - 1) & h]) == null”：</strong>取出给当前线程分配的Cell元素，判断当前元素是否为null。</p><p>拿上面已经初始化好的Cell数组来说，假如Cell数组情况是这样的：</p><p>cells[0] = Cell(value = 1);</p><p>cells[1] = null;</p><p>正好给当前线程分配的Cell元素为cells[1]，即当前元素为null。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f7c1d74164644298809b5f9cc86f557b><p class=pgc-img-caption></p></div><p>若当前线程持有非阻塞cellsBusy锁，那么就继续执行if语句里面的内容：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f53da70b0cf843a08da05be9049e1287><p class=pgc-img-caption></p></div><p>创建一个新的Cell对象，并指定初始值为当前操作数x。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4f12477982664f95bba1d732f710d2e7><p class=pgc-img-caption></p></div><p>这一步给cellsBusy上锁，即将cellsBusy由0变为1，这样其他线程判断cellsBusy==0结果为false，就无法获取到cellsBusy锁。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd79ef0420aa43a992d7c6d933fdc5f4><p class=pgc-img-caption></p></div><p><strong>“(rs = cells) != null”：</strong>Cell数组不能为null。</p><p><strong>“(m = rs.length) > 0”：</strong>Cell数组长度要大于0。</p><p><strong>“rs[j = (m - 1) & h] == null”：</strong>给当前线程分配位置上不能有已存在的元素。</p><p><strong>“rs[j] = r;”：</strong>将刚刚新建的Cell对象赋给Cell数组指定位置。</p><p><strong>“break done;”：</strong>结束外层无限循环。</p><p><strong>finally代码块中最后的“cellsBusy = 0;”操作是释放非阻塞锁cellsBusy。</strong></p><p>以上是取到元素为null的情况。</p><p>下面我们来看看取到元素不为null的情况。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e58617deff9c4ed2bfc0ee8b7989e627><p class=pgc-img-caption></p></div><p>直接调用取到的元素cas方法，如果执行成功，那么整个赋值过程就完成；</p><p>如果执行失败，那么重新计算当前线程的hash值：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/958258ad4bfc49588d95c04e038e8d65><p class=pgc-img-caption></p></div><p>advanceProbe(int probe)方法：</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/65568173656e4bb7aabe86ea3f2d22b1><p class=pgc-img-caption></p></div><p>advanceProbe(int probe)方法的作用是重新计算当前线程的hash值。</p><p>为什么要重新计算当前线程hash值？</p><p>因为考虑到一个hash值相同的情况，即hash碰撞，所以避免出现此类问题出现，每次循环完都要重新计算一次当前线程的hash值。</p><h1>整体流程</h1><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9806f95ee524538b7801adf3118fa1e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c1d98b5ab4664b448049fe66b7ae0fd4><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ec0606723f8a47a2a0c1c2dc0ae523e8><p class=pgc-img-caption></p></div><p>当所有值赋值完成时，最终返回结果就是：base+cells数组中每个Cell对象的value值之和。</p><p>最后，希望大家可以把这个例子照着写一遍，然后再自己默写一遍，方便以后碰到类似的面试题可以轻松应对。</p><p>祝大家编码愉快！</p><h1><strong>GitHub</strong></h1><p>本章程序GitHub地址：https://github.com/gorhaf/Java2019/tree/master/Thread/atomic/高性能原子类</p><h1><strong>总结</strong></h1><ul><li>Striped64是适用于于并发情况下进行累加运算的类（Java8新增的）。它是抽象的，需要子类去实现它里面的抽象方法才能使用。在高并发情况下，它不光性能强，而且效率也高。</li><li>Striped64的子类包括DoubleAccumulator、DoubleAdder、LongAccumulator和LongAdder四个原子类。</li><li>Cell类是一个嵌入在Striped64类中的原子类。</li><li>第一阶段：判断当前多线程情况下操作base变量是否失败，若失败则进入高并发模式。</li><li>第二阶段：初始化Cell数组。</li><li>第三阶段：根据当前线程hash值计算出当前线程所操作的Cell对象。</li><li>第四阶段：判断Cell对象元素是否为null，为null创建一个新值给Cell数组，否则利用CAS算法更新值。</li><li>从第三阶段开始，每个阶段都会重新计算当前线程的hash值。</li></ul><p>至此，Java中分析Striped64类相关内容讲解先告一段落，更多内容请持续关注。</p><h1><strong>答疑</strong></h1><p>如果大家有问题或想了解更多前沿技术，请在下方留言或评论，我会为大家解答。</p><h1><strong>上一章</strong></h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6681250302424777224/?group_id=6681250302424777224" target=_blank>“全栈2019”Java原子操作第十四章：高性能高效率的原子类介绍</a></p><h1><strong>下一章</strong></h1><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6682265473255473672/?group_id=6682265473255473672" target=_blank>“全栈2019”Java原子操作第十六章：从零手写非阻塞栈数据结构</a></p><h1><strong>学习小组</strong></h1><p>加入同步学习小组，共同交流与进步。</p><ul><li><strong>方式一：关注头条号Gorhaf，私信“Java学习小组”。</strong></li><li><strong>方式二：关注公众号Gorhaf，回复“Java学习小组”。</strong></li></ul><h1><strong>全栈工程师学习计划</strong></h1><p>关注我们，加入“全栈工程师学习计划”。</p><div class=pgc-img><img alt=“全栈2019”Java原子操作第十五章：高性能原子类实现原理分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7782c8aee3024b2f9a865e0fa40280dc><p class=pgc-img-caption></p></div><h1><strong>版权声明</strong></h1><p>原创不易，未经允许不得转载！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'原子','全栈','2019'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>