<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java堆、栈、堆栈，常量池的区别 | 极客快訊</title><meta property="og:title" content="java堆、栈、堆栈，常量池的区别 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/ab1ff19ca9dc41c6a7be34ab842d3bbc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a302434c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a302434c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a302434c.html><meta property="article:published_time" content="2020-11-14T20:59:55+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:55+08:00"><meta name=Keywords content><meta name=description content="java堆、栈、堆栈，常量池的区别"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a302434c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java堆、栈、堆栈，常量池的区别</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>先说一下栈和堆栈，我们听老一辈的程序员一般都会说堆栈，其实栈就是堆栈的意思，连着叫只是由于历史的原因。博主04年学数据结构的时候，书上都是说的堆栈，FILO（先进后出），也经常拿堆栈和队列，FIFO（先进先出）这两种数据结构拿来作比较。</p><p><strong>系统中的堆、栈 和 数据结构堆、栈</strong></p><p>系统中的堆、栈和数据结构堆、栈不是一个概念。可以说系统中的堆、栈是真实的内存物理区，数据结构中的堆、栈是抽象的数据存储结构。</p><p><strong>数据结构堆、栈</strong></p><p>1. 栈：实际上就是满足后进先出的性质，是一种数据项按序排列的数据结构，只能在一端(称为栈顶(top))对数据项进行插入和删除。</p><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ab1ff19ca9dc41c6a7be34ab842d3bbc><p class=pgc-img-caption></p></div><p>2. 堆：堆是一种完全二叉树或者近似完全二叉树，完全二叉树是效率很高的数据结构，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化。</p><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3b3b85449e1459cb60da65964561c08><p class=pgc-img-caption></p></div><p><strong>堆排序</strong>（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。详见：十大经典排序算法</p><p><strong>系统方面的堆和栈</strong></p><p>1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</p><p>2、堆区（heap）— 是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护)，在java中,所有使用new xxx()构造出来的对象都在堆中存储一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。</p><blockquote><p>堆是全局的，堆栈是每个函数进入的时候分一小块，函数返回的时候就释放了，静态和全局变量，new得到的变量，都放在堆中，局部变量放在栈中，所以函数返回，局部变量就全没了。</p></blockquote><p>我们今天重点讲的是Java里的堆和栈也就是系统方面的堆和栈。</p><p><strong>Java里的堆、栈和常量池</strong></p><p><strong>（下面以图文的方式讲解，方便大家理解）</strong></p><p>1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p><p>2. 栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。</p><p>堆的优势是可以动态地分配内存大小，所有使用new xxx()构造出来的对象都在堆中存储，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。</p><p>3. 常量池：存放字符串常量和基本类型常量（public static final）。</p><p>常量池的好处是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><blockquote><p>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><p>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</p><p>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</p></blockquote><p>4. Java中的数据类型有两种。</p><p>一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，不包含String)。</p><p>如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。</p><p>另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：</p><pre>int a = 3;int b = 3;</pre><p>编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。</p><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b9a249887d3c490f9a7e42889174e547><p class=pgc-img-caption></p></div><p>image</p><blockquote><p>特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另 一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。</p></blockquote><p>如上例，我们定义完 a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。</p><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a69fbdb2e664bc78b6079c02aec0810><p class=pgc-img-caption></p></div><p>image</p><p>另一种是包装类数据，如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p><p>4. String是一个特殊的包装类数据。</p><pre>即可以用String str = new String("abc"); 的形式来创建也可以用String str = "abc"; 的形式来创建</pre><p>前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。</p><blockquote><p>作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换。</p><p>Java 中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单 例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。</p></blockquote><p>那为什么在String str = "abc"；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。</p><p>5. 关于String str = "abc"的内部工作。Java内部将此语句转化为以下几个步骤：</p><p>(1) 先定义一个名为str的对String类的对象引用变量放入栈中。</p><p>(2) 在常量池中查找是否存在内容为"abc"字符串对象。</p><p>(3) 如果不存在则在常量池中创建"abc"，并让str引用该对象。</p><p>(4) 如果存在则直接让str引用该对象。</p><p>为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。</p><pre>String str1 = "abc"; String str2 = "abc"; System.out.println(str1==str2); //true</pre><blockquote><p>注意，我们这里并不用str1.equals(str2)；的方式，因为这将比较两个字符串的地值是否相等==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。</p><p>结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。</p></blockquote><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4553bbe91a24c52881cd7d0660708fc><p class=pgc-img-caption></p></div><p>image</p><p>我们再来更进一步，将以上代码改成：</p><pre>String str1 = "abc"; String str2 = "abc"; str1 = "bcd"; System.out.println(str1 + "," + str2); //bcd, abc System.out.println(str1==str2); //false </pre><blockquote><p>这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为"bcd"时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。</p><p>事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。</p></blockquote><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3d9208196bbb461c82a98c36d4a14e0a><p class=pgc-img-caption></p></div><p>image</p><p>再修改原来代码：</p><pre>String str1 = "abc"; String str2 = "abc"; str1 = "bcd"; String str3 = str1; System.out.println(str3); //bcd String str4 = "bcd"; System.out.println(str1 == str4); //true</pre><blockquote><p>str3这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用 str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。</p></blockquote><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8835d173c882469cbb06d827632ed8e8><p class=pgc-img-caption></p></div><p>image</p><p>6. 我们再来看看 String str = new String("abc")创建过程</p><p>(1) 先定义一个名为str的对String类的对象引用变量放入栈中。</p><p>(2) 然后在堆中（不是常量池）创建一个指定的对象，并让str引用指向该对象。</p><p>(3) 在常量池中查找是否存在内容为"abc"字符串对象。</p><p>(4) 如果不存在，则在常量池中创建内容为"abc"的字符串对象，并将堆中的对象与之联系起来。</p><p>(5) 如果存在，则将new出来的字符串对象与字符串常量池中的对象联系起来（即让那个特殊的成员变量value的指针指向它）</p><p>我们再接着看以下的代码。</p><pre>String str1 = new String("abc"); String str2 = "abc"; System.out.println(str1==str2); //false </pre><p>创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。</p><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/de880b7b9c954f66a8d0bdfa98a9f9ca><p class=pgc-img-caption></p></div><p>image</p><blockquote><p>对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。</p></blockquote><p><strong>这也就是有道面试题：String s = new String(“abc”);产生几个对象？答：一个或两个，如果常量池中原来没有”abc”,就是两个。</strong></p><p>7. 基本数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的基本数据数据类型包装类都不能更改其内部的值。</p><ol><li>String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；</li></ol><pre>String str1 = "abc"; String str2 = new String("abc"); String str3 = str2.intern();System.out.println( str1==str2 ); //falseSystem.out.println( str1==str3 ); //true</pre><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/12d4fa0f8bf64fbdb81d72530cd84762><p class=pgc-img-caption></p></div><p>image</p><ol><li>结论与建议：</li></ol><p>(1) 我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。</p><p>因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为"abc"的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。</p><p>(2) 使用String str = "abc"；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据常量池中数据的实际情况来决定是否有必要创建新对象。</p><p>而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。</p><p>(3) 当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。</p><p>(4) 由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。</p><p><strong>申请响应</strong></p><p>栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。</p><p>堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。</p><p><strong>申请限制</strong></p><p>栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。</p><p>堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。</p><div class=pgc-img><img alt=java堆、栈、堆栈，常量池的区别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ac8ef2bd5d234037b2346738ef9965f4><p class=pgc-img-caption></p></div><p>image</p><p><strong>堆和栈的区别用比喻来看：</strong></p><p>使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。</p><p>使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。</p><p><strong>堆栈缓存方式</strong></p><p>栈使用的是<strong>一级缓存</strong>， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。</p><p>堆则是存放在<strong>二级缓存</strong>中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。</p><p><strong>在JAVA中，有六个不同的地方可以存储数据：</strong></p><p>1. 寄存器（register）：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。</p><p>2. 栈（stack）：存放基本类型的变量数据和对象的引用。位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性。</p><p>3. 堆（heap）：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区 域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行 这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代价，用堆进行存储分配比用堆栈进行存储存储需要更多的时间。</p><p>4. 静态存储（static storage）：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。</p><p>5. 常量存储（constant storage）：存放字符串常量和基本类型常量（public static final）。 常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。</p><p>6. 非RAM存储：硬盘等永久存储空间。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。</p><p>就速度来说，有如下关系：</p><p>**寄存器 &lt; 堆栈 &lt; 堆 &lt; 其他 **</p><blockquote><p>作者：互扯程序</p><p>链接：https://www.jianshu.com/p/e39ab6ff17c2</p><p>来源：简书</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'java','堆栈','区别'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/ee269a56.html alt=java堆、栈、堆栈，常量池的区别，史上最全总结 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d3292cdcde741f6a466a8aa1f9cf02e style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/ee269a56.html title=java堆、栈、堆栈，常量池的区别，史上最全总结>java堆、栈、堆栈，常量池的区别，史上最全总结</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>