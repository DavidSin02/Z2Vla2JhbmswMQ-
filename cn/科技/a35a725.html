<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>透彻理解液晶显示模组LCD1602指令集与驱动编程（1） | 极客快訊</title><meta property="og:title" content="透彻理解液晶显示模组LCD1602指令集与驱动编程（1） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1aef696a1efa446b8463511f25613711"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a35a725.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a35a725.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a35a725.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a35a725.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a35a725.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a35a725.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a35a725.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a35a725.html><meta property="article:published_time" content="2020-10-29T20:54:20+08:00"><meta property="article:modified_time" content="2020-10-29T20:54:20+08:00"><meta name=Keywords content><meta name=description content="透彻理解液晶显示模组LCD1602指令集与驱动编程（1）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a35a725.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>透彻理解液晶显示模组LCD1602指令集与驱动编程（1）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>LCD1602可以说是大多数单片机工程师了解液晶显示的入门级模组，其显示原理与其它很多显示模组也是相似的，今天我们就来详细讨论一下它的指令集。所谓模组的指令集，本质上是该模组使用的控制芯片的指令集，本文主要讨论基于<strong>HD44780芯片</strong>的LCD1602。</p><p style=text-align:justify>其实在博客园的博文中，我已经整理了一篇关于LCD1602的文章（原作者已不可考），从技术角度来讲，这篇文章写得还是不错的，该讨论的地方都涉及到了，对LCD1602显示有兴趣的读者可以去阅读一下。但是大家可能都知道，曾几何时，某人曾经对兄弟夸了海口：要说写技术文章，我谁也不服（此剧情纯属虚构，如有雷同，实属巧合，哈哈～～）！所以我决定百尺竿头更进一步，使用另一种方式来探讨它们，Let's Go Go Go, Fire in Hole，不好意思，走神了。</p><p style=text-align:justify>为了本文的完整性，我们简单介绍一下HD44780中DDRAM的组织方式，如下图所示：</p><p style=text-align:justify></p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1aef696a1efa446b8463511f25613711><p class=pgc-img-caption></p></div><p style=text-align:justify></p><p style=text-align:justify>DDRAM（Display DataRAM）即“显示数据随机存取存储器”，一般我们简称为“显存”，简单的说，你往显存中写入什么，屏幕上就会显示什么。显示位置（Display position）表示DDRAM地址对应的屏幕位置。例如，显示位置1（屏幕左上角）对应DDRAM地址0x00（<strong>当然，这只是默认情况下</strong>）。</p><p style=text-align:justify>HD44780包含80个显存地址（第一行0x00～0x27、第二行0x40～0x67），也就意味可以显示最多80个字符。但是，我们使用的LCD1602只能显示2行，每行16个字符。换句话说，<strong>默认情况下</strong>，它只使用到了32个DDRAM地址（第一行0x00～0xF、第二行0x40～0x4F），相应的DDRAM地址与屏幕对应关系如下图所示（<strong>注意：两行DDRAM地址不是连续的</strong>）。</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9c82bed3b3f64c129387dcc4835b3109><p class=pgc-img-caption></p></div><p style=text-align:justify>例如，你想在LCD左上角显示内容，就应该把数据写入到DDRAM地址0x00中，如果想在LCD右下角显示内容，应该把相应的数据写入到DDRAM地址0x4F中。总之，液晶显示屏上的内容与DDRAM地址是一一对应的。</p><p style=text-align:justify>当然，我们往DDRAM中写入数据是<strong>字模的地址</strong>（而不是<strong>字模本身</strong>），具体屏幕上显示什么取决于字模地址中对应的字模。HD44780芯片已经预定义了一些字模，它们保存在一个称为CGROM（Character Generator ROM，字符生成只读存储器）的地方，简单的说，CGROM就是一个字库，相应的字模如下图所示（当然，还有一个CGRAM，它允许用户自定义字模，后续有机会再讨论）。</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f22933073008456d8e0598077df7e38c><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>使用CGROM中预定义的字模非常简单，只需要把字模对应的地址写入到DDRAM即可。例如，你要显示小写字母“j”，我们就应该写入0b0110_1010（0x6A），其中0110表示高4位地址（Upper 4 Bits），1010表示低4位地址（Lower 4 Bits）。</p><p style=text-align:justify>好的，我们已经知道如何确定字模地址，那怎么来定位DDRAM地址呢？总不能乱写一通吧！HD44780内部有一个地址计数器（<strong>AddressCount, AC</strong>），它保存的就是DDRAM（或CGRAM）的地址，我们通过指令就可以控制具体访问的DDRAM地址。</p><p style=text-align:justify>咱们来看看HD44780数据手册定义的指令集，后续的单条指令截图都可以从这里查到，如下图所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/31d91c2ce6d94e3dbae6d9bcbfb20e56><p class=pgc-img-caption></p></div><p style=text-align:justify>首先我们来看看“功能设置（Function Set）”指令，它用来设置与硬件相关的配置，功能设置不当可能会导致数据传输或显示不正常，所以“功能设置”指令通常也是发送给LCD1602的第一条指令，其中包含DL、N、F三个配置位，如下图所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbdc198b618147d38ebe20d5a2039705><p class=pgc-img-caption></p></div><p style=text-align:justify></p><p style=text-align:justify><strong>DL</strong>位（Data Length）选择数据总线的宽度为4位（DL=0）还是8位（DL=1），一般我们常用的还是8位总线。</p><p style=text-align:justify><strong>N</strong>位(Number)表示一行（N=0）还是两行（N=1）显示（它们对应的DDRAM地址是不一样的，有兴趣可以参考数据手册查阅一行显示的DDRAM组织方式），LCD1602当然应该设置为2行显示。</p><p style=text-align:justify><strong>F</strong>位（Font）表示显示的字体为5x8点阵（F=0）还是5x10（F=1），两行显示下只能显示5x8点阵，下图左侧给出了两种字体的区别（包含光标位置，右侧是光标闪烁时的状态转换）</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fab60b6ebe754e828bdd9905887b3854><p class=pgc-img-caption></p></div><p style=text-align:justify>我们决定使用8位数据总线给LCD1602发送数据，相应的指令应该为“<strong>0b11_1000（0x38）</strong>”。</p><p style=text-align:justify>然后我们可以使用<strong>显示开关控制（Display on/offcontrol）</strong>指令，之所以紧赶慢赶地先讨论它，是因为只要正确使用该指令，就可以打开显示并开启（闪烁）光标。在实际硬件调试时，能打开光标就意味着硬件的连接正常，且单片机往模组中写入的数据被正常接收（即写数据的时序正确），至此显示模组的驱动过程基本上已经完成了一半，接下来就是逐个指令调试的过程了。</p><p style=text-align:justify>显示开关控制指令可以设置D、C、B三位，HD44780数据手册对该指令的详细描述如下：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b5e751641ad948c9bf50543b39fe4d81><p class=pgc-img-caption></p></div><p style=text-align:justify><strong>D位</strong>(Display)是显示开关控制位，当D=1时显示开启，当D=0时显示关闭。当然，该位状态并不影响DDRAM中已经写入的数据，如果你反复开启与关闭显示，DDRAM中的内容仍然是不变的，因为本质上它只是控制液晶屏驱动时序是否生成。</p><p style=text-align:justify><strong>C位</strong>(Cursor)表示是否显示光标，当C=1时显示，当C=0时不显示光标。<strong>B位</strong>(Blink)表示光标是否闪烁，当B=1时表示闪烁，当B=0时不闪烁。</p><p style=text-align:justify>假设我们需要打开显示，且开启光标闪烁，需要给HD44780的指令是什么呢？我们把显示开关控制（Display on/off control）指令重新剪贴如下：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbdc198b618147d38ebe20d5a2039705><p class=pgc-img-caption></p></div><p style=text-align:justify>打开显示需要设置D=1，显示光标需要设置C=1，而让光标闪烁需要设置B=1，也就是说，我们需要给HD44780发送指令“<strong>0xF</strong>”。我们来看看VisualCom软件平台相应的仿真效果，如下图所示</p><p style=text-align:justify><br></p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ced71557d7ee408781ae107a5943c9f0><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>VisualCom软件平台中“内存”与“寄存器”窗口中的数据取决于具体的调入元器件类型，一般的显示控制芯片（这里是HD44780）都会有，而像LED、数码管、按键之类器件则无。VisualCom软件平台有一个非常实用的功能，就是<strong>预置数据</strong>，它可以给当前选择的器件预置一些数据或命令，当你运行仿真之后，器件会先执行预置数据。</p><p style=text-align:justify>我们先调入“LCD1602”仿真器件，右击后在弹出的快捷菜单中选择“预置数据”项即可打开如下图所示对话框。</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/424849eecf6146fe91302353370ebe27><p class=pgc-img-caption></p></div><p style=text-align:justify>对话框中有一个表格，你可以插入想要的数据行，“<strong>类型</strong>”栏中可以是<strong>数据</strong>或<strong>命令</strong>；“<strong>附加栏</strong>”是扩展项，对于HD44780是无效的；“<strong>十进制</strong>”与“<strong>十六进制</strong>”表示插入的具体数据或命令，两栏的数据完全一样，你往十进制写入15，十六进制中就会显示F，反之亦然，这可以方便不同的进制数据输入的场合；“<strong>自定义备注</strong>”栏可以为你插入的行做注释。</p><p style=text-align:justify>为了插入数据或命令行，你可以选择左下角的“插入数据”或“插入命令”按钮插入数据行，它们会在表格的结尾插入，你也可以右击后选择相应的选项，它可以在你点击的某行上方插入一行。当然，也可以对数据行进行移动、删除等操作，此处不再赘述</p><p style=text-align:justify>我们先插入一条“功能设置指令”（<strong>0x38</strong>），再插入了一条“显示开关控制指令”（<strong>0xF</strong>），然后点击“单步运行”按钮，就可以看到液晶显示模组的左上角出现了一个闪烁的光标。同时我们注意到，“寄存器窗口”中的B、C、D位均为1。<strong>光标的位置由地址计数器（AC）决定</strong>，由于<strong>AC</strong>=0，所以光标出现在左上角。</p><p style=text-align:justify>执行“<strong>0xF</strong>”指令后还显示了两行字符“<strong>join weixin mp XXXXX</strong>”，我们可以查看“内存窗口”中对应的字模地址。例如，0x01地址中数据为0x6A，也就是小写字母“j”的字模地址，其它依此类推。我们买到的真实LCD1602模组当然不会显示这两行字，然而即便如此，我们通常也会习惯使用一条<strong>清屏指令（Clear Display）</strong>清除屏幕的显示内容，因为上电之后DDRAM中的数据可能是乱码，相应的指令如下所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8e6951fe0e2e499fb8db5b10bfa107e6><p class=pgc-img-caption></p></div><p style=text-align:justify>清屏，顾名思义，一旦执行该指令，屏幕上不会有任何内容显示。实际上，清屏指令把所有DDRAM地址中的数据都设置为0x20。</p><p style=text-align:justify>有些人可能会想：为什么不全部设置为0x00呢？因为前面已经提过，DDRAM中的数据代表的是<strong>字模地址</strong>，而不是<strong>字模本身</strong>。我们看看前面的CGROM字模表，0x20（0b0010_0000）恰好对应一个空白的字模（实际上，0x20就是空格的ASCII码），这样也就可以清除屏幕显示。</p><p style=text-align:justify>我们在之前的预置数据后再添加了一条指令“<strong>0x1</strong>”，单步运行后的效果如下图所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be415c8cc4fa41b4bce5142bd55aab25><p class=pgc-img-caption></p></div><p style=text-align:justify>可以看到，“内存窗口”中的有DDRAM地址的数据全部都修改为0x20，但是原来光标状态还是不变的，该显示的显示，该闪烁的还是闪烁，因为光标不属于显示内容，只不过其位置总会回到左上角（如果原来没在左上角的话），数据手册对此已经明确说明，如下图所示：</p><p style=text-align:justify></p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0e29491ddd9c4624b30511d55c6c5d98><p class=pgc-img-caption></p></div><p style=text-align:justify>这段说明中还提到了<strong>I/D</strong>位(Increment/Decrement)与<strong>S</strong>位（Shift），这就要涉及到另一条“<strong>进入模式设置（Entry mode set）</strong>”，如下图所示。</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3342edbb00ee447c82d18e5ed726ab7f><p class=pgc-img-caption></p></div><p style=text-align:justify>前面我们不是说过，想往哪个DDRAM地址写数据就需要先设置<strong>AC</strong>吗？现在我们要写一行16个字符，如果每写一个字符都要使用指令设置一下DDRAM地址，是不是很麻烦？HD44780允许我们往（从）DDRAM地址写（或读）数据后，将<strong>AC</strong>自动加1（I/D=1）或减1（I/D=0），这样如果你要写一行字符，只需要确定首地址就可以了，是不是很方便？由于光标的位置取决于<strong>AC</strong>，如果光标显示已经打开，当你往DDRAM连续写入字符时，光标位置也会随之移动。</p><p style=text-align:justify><br></p><p style=text-align:justify>现在我们要从左上角开始写入字符串“dzzzzcn”，首先从CGROM字模表中找到小写字母“d”、“z”、“c”、“n”对应的字模地址分别为“<strong>0x64</strong>”、“<strong>0x7A</strong>”、“<strong>0x63</strong>”、“<strong>0x6E</strong>”、，然后在VisualCom软件中再接着添加7个预置数据，即“0x64”、“0x7A”、“0x7A”、“0x7A”、“0x7A”、“0x63”、“0x6E”，如下图所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4eccbadb74484277ba36c71ea593766d><p class=pgc-img-caption></p></div><p style=text-align:justify>运行后的效果如下图所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed2a1f0833844e1a8b943e5039932806><p class=pgc-img-caption></p></div><p style=text-align:justify>有人可能会想问：没看到你使用DDRAM地址设置指令呀？也没有使用“进入模式设置”指令设置地址增加模式，怎么它就会从左上角（0x00）开始写起呢？因为我们已经使用的清屏指令，它会把<strong>AC</strong>清零，并且它还会将<strong>I/D</strong>位设置为1（地址增加模式）。</p><p style=text-align:justify><strong>S位</strong>用来控制移屏功能的开启与否。移屏是个神马东西？其实跟卷屏差不多，只不过卷屏通常是显示内容上下卷动，而HD44780只有两行，它的移屏方向要么左（I/D=1）要么向右（I/D=0），你想要开启它，只要将S位设置为1即可，数据手册说明如下：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9f297e29af14c7b9021266786ac8e43><p class=pgc-img-caption></p></div><p style=text-align:justify>注意该段说明中有句话：<strong>如果S=1，看起来光标没有移动但屏幕移动了</strong>。这是什么意思呢？我们仿真一下不就知道了，将预置数据修改如下：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/65e687c2ae41416888eaa46cca59f5f7><p class=pgc-img-caption></p></div><p style=text-align:justify>我们只是在写数据前插入了一条“进入模式设置”指令（<strong>0x5</strong>），它打开了移屏功能，并且将I/D设置为0。也就是说，每往DDRAM写一个数据，地址会自减1，而且会往右移屏。</p><p style=text-align:justify>我们来看看相应的仿真效果，如下图所示。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c20f35f64fff4dd0a7574cdce88014d3><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>运行结果似乎有点耐人寻味？怎么会是这样的呢？其实并没有错，因为我们设置了地址自减模式，而清屏后的<strong>AC</strong>=0，那么你再写一个数据，它减到哪里去了？就跳到第一行DDRAM的尾地址0x27（而不是0xF）。我们前面已经提过，LCD1602只使用了32个DDRAM地址（第一行0x00～0xF、第二行0x40～0x4F），所以在正常情况下，当你往DDRAM地址0x27写入字模地址时，屏幕上是不会显示相应的字模，对不对？</p><p style=text-align:justify>但是由于你开启了右移屏指令，当你写第一个字母d的时候，<strong>AC</strong>指向了DDRAM地址0x27，同时往右移了一次屏，所以此时屏幕最左侧对应的DDRAM地址就是0x27（第一行）与0x67（第二行），而不再是原来的0x0与0x40，更不是正常情况下LCD1602最右侧对应的DDRAM地址0xF与0x4F。</p><p style=text-align:justify>当你全部写完“dzzzzcn”字符串后，光标所在的位置（<strong>AC</strong>）就是0x21。也就是说，你写7个字符的同时也往右移了7次屏。看到没有，光标原来的位置并没有改变就是这个意思。</p><p style=text-align:justify>如果我们把地址模式改为自加模式（“进入模式指令”为<strong>0x7</strong>），写入同样的数据会出现什么结果呢？自加模式下为左移屏，每写一次数据左移一次，所以最后的结果应该是：<strong>从显示屏上来看，相当于什么都没写</strong>。我们来看看仿真的结果，如下图所示：</p><div class=pgc-img><img alt=透彻理解液晶显示模组LCD1602指令集与驱动编程（1） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0bbf17eb52b46e292da3bc126b56f6a><p class=pgc-img-caption></p></div><p style=text-align:justify>好像跟清屏后的效果一样呀！但是请注意，现在的AC值为<strong>0x7</strong>，从“内存窗口”可以看到，DDRAM地址0x00～0x07中还是写入了“dzzzzcn”的字模，只不过由于写数据的同时往左移了7次屏，所以看起来好像什么都没写一样。</p><p style=text-align:justify>好的，剩下的指令我们后续有机会再来讨论吧，么么哒～～</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'透彻','显示','模组'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>