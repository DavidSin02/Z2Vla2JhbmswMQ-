<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据库为什么需要事务呢？ | 极客快訊</title><meta property="og:title" content="数据库为什么需要事务呢？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fd023a0548044e8f8b4c1a15240d8f0f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a4128d6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a4128d6.html><meta property="article:published_time" content="2020-10-29T20:50:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:41+08:00"><meta name=Keywords content><meta name=description content="数据库为什么需要事务呢？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a4128d6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据库为什么需要事务呢？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>为什么需要事务呢？</strong></h1><p>在<strong>数据库起源</strong>里面我们提到了事务。</p><p>数据库除了对查询等操作进行了抽象，另外一个重要的功能就是<strong>事务</strong>了。为什么需要事务呢？因为我们在操作数据的时候，可能遇到多个线程同时操作数据的问题，也可能遇到突然数据库故障了的问题，这些都可能造成数据的<strong>不一致</strong>。所以事务要保证的就是<strong>一致性</strong>。</p><p>保证一致性的第一重意思是<strong>锁</strong>，这是为了应对多个<strong>连接</strong>同时连到数据库的时候。因为我们可能为每个连接分配一个线程，而这些线程有可能同时操作同一块数据，这样将会发生<strong>不一致</strong>。所以我们只好在写的时候加上<strong>锁</strong>，也就是强行保证只有一个线程可以访问到这块数据。</p><p>另外我们还会遇到数据库崩溃的问题，所以我们要求一个事务一定是<strong>原子</strong>的，也就是 <strong>要么全部发生， 要么根本不发生。</strong>比如Bob给Smith转100块，要么Bob有100块，要么Smith有100块，不存在中间状态。</p><p>对於单机事务而言，需要保证</p><ul><li>原子性</li><li>一致性</li><li>隔离性</li><li>持久性</li></ul><p>也就是所谓的ACID，下面我们依次介绍他们是怎么实现的。</p><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fd023a0548044e8f8b4c1a15240d8f0f><p class=pgc-img-caption></p></div><h1><strong>原子性</strong></h1><p><strong>Undo日志</strong></p><p>所谓<strong>原子性</strong>指的是要么同时成功，要么同时失败。比如Bob账户里面有100块，而Smith账户里面有0元，现在我们希望Bob转100块给Smith。</p><p>所谓<strong>原子性</strong>就是要么Bob成功转给了Smith100块，此时Bob有0元、Smith有100块。要么失败了，Bob仍然有100块，Smith为0元。<strong>不会存在Bob把钱转出去了，而Smith却没有拿到钱的情况。</strong></p><p>现在我们来想想要实现这个事务，应该怎么做</p><ul><li>锁定Bob账户</li><li>锁定Smith账户</li><li>查看Bob是否有100块钱，如果有，则从账号里面减少100块</li><li>给Smith账户里面增加100块</li><li>依次解锁Bob和Smith</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f54a85e12e848fbbe500c413127e0f4><p class=pgc-img-caption></p></div><p>但是执行事务不会永远是一帆风顺的，可能出现<strong>意外</strong>，比如Bob或者Smith账户不存在怎么办？没关系，我们可以<strong>回滚</strong>到上一个状态。</p><p>但是数据库不可能把每个状态都记录下来，这就需要我们在转账之前把<strong>之前的状态</strong>记录下来。</p><p>比如我们看刚刚那个转账操作的<strong>中间状态</strong></p><ol><li>Bob：100，Smith：0</li><li>Bob：0，Smith ：0 （此时正在转账）</li><li>Bob ： 0 ， Smith ：100（转账成功）</li></ol><p>我们可以在插入两个undo段，他们记录在日志中。</p><ol><li>Bob：100，Smith：0</li><li>Bob：0，Smith ：0 （此时正在转账）</li></ol><ul><li class=ql-indent-1>上一个状态为：Bob：100，Smith：0</li></ul><ol><li>Bob ： 0 ， Smith ：100（转账成功）</li></ol><ul><li class=ql-indent-1>上一个状态为： Bob：0，Smith ：0</li></ul><p>这样如果要回滚，只需要回溯日志即可实现。这</p><p><strong>另外还有一种可能就是事务并没有进行完，系统就崩溃了怎么办？</strong>那系统重启之后就得做<strong>恢复</strong>操作啊。那怎么恢复了，同样也是通过<strong>日志</strong>。我们可以在进行真正的操作之前，需要把要做的事写下来，</p><p>我们会在事务开始之前写下：</p><blockquote><p>Bob原有100元，Smith原有0元</p></blockquote><p>如果事务执行到一半就断电，那么重启之后我们就可以按照<strong>日志来恢复</strong>，然后仍然是** Bob有100元，Smith有0元<strong>。即使恢复100次，仍然是这个结果，这就叫</strong>幂等性**，所以恢复过程中也断电了，我们仍然可以按照日志来进行恢复。</p><p>现在还有个一问题没有解决，那就是怎么知道<strong>一个事务没有完成呢？</strong></p><p>同样我们可以通过记录日志的方式来完成。比如我们在记录的时候，不但把余额记上，还把<strong>事务开始了和结束</strong>这两个动作打上标记。</p><p>比如</p><blockquote><p>[开始事务T1]</p><p>[事务T1：Bob原有100]</p><p>[事务T2：Smith原有0]</p><p>[提交事务T1]</p></blockquote><p>这样，如果在日志中看到了<strong>提交事务T1</strong>或者<strong>回滚事务T1</strong>，我们就知道这个事务已经结束了。如果只看到<strong>开始事务T1</strong>，那就得恢复。比如下面这个就得恢复</p><blockquote><p>[开始事务T1]</p><p>[事务T1：Bob原有100]</p><p>[事务T2：Smith原有0]</p></blockquote><p>而且，在<strong>恢复之后</strong>，需要在日志文件中加上一行<strong>回滚事务T1</strong>，这样下次恢复就不用再考虑T1这个事务呢，因为现在早已经回到上一个状态去了呢。</p><p><strong>Undo日志写入文件的时机</strong></p><p>上面的讨论其实我们都故意忽略了一个问题，那就是Undo日志也需要加载到内存中才能读写，但是如果日志还没写好就断电了怎么办？</p><p><strong>其实我们只要掌握好把日志写入文件的时机就OK了。</strong></p><p>最容易想到的就是在一开始就把日志写入文件，就好比写作文前把草稿打好，后面只管按着草稿誊抄一遍就可以了。</p><p>然而，现实是，一开始的时候，我们都不知道程序要操作哪个字段，怎么记录日志呢，当然也不能写入文件呢。所以肯定是一边在内存中操作Undo日志，一边找时机写入磁盘中。</p><p>比如上面的转账操作，我们其实可以这样来修改和写日志。</p><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15c323774dfc4906953a4cb909162ffb><p class=pgc-img-caption></p></div><p>总结一下就是，</p><ul><li>当余额发生改变的时候，记录之前的余额</li><li>在余额要写入硬盘之前，需要把日志先写入文件，然后日志缓冲区会清空。</li><li>提交事务的日志一定是在所有余额都写入硬盘之后才写入</li></ul><p>也就是说事务过程中，余额发生改变，在余额正式写入了硬盘以后，相当于木已成舟，所以我们也需要把日志写入硬盘。</p><p>当所有余额都稳稳当当的落到磁盘上了，我们自然也应该把日志落到磁盘上</p><p>那么我们可以攻防演练一下。</p><p>如果Bob的余额写到了硬盘，但是Smith还没修改。此时日志中落盘的只有Bob原有的余额也就是：</p><blockquote><p>[开始事务T1]</p><p>[事务T1：Bob原有100]</p></blockquote><p>恢复的时候，发现事务没有结束，所以还会把Bob的余额给恢复了。</p><p>同理，如果Bob和Smith的余额都落盘了，但是没有提交事务，此时日志是</p><blockquote><p>[开始事务T1]</p><p>[事务T1：Bob原有100]</p><p>[事务T2：Smith原有0]</p></blockquote><p>依然可以恢复两个账户的余额。</p><p>即使两个账户的最新余额都落盘了，也提交了事务，但是只要在日志写入磁盘之前崩溃，则Undo日志还是</p><blockquote><p>[开始事务T1]</p><p>[事务T1：Bob原有100]</p><p>[事务T2：Smith原有0]</p></blockquote><p>同样会把余额恢复成原样。</p><p><strong>原子性做不到的地方</strong></p><p>现在可算是把原子性说完了，但是只有原子性是不够的，为什么呢？因为它无法保证多个线程访问数据时的一致性。</p><p>比如在第2步的时候，另一个事务把把smith账户加到了300块钱，</p><ol><li>Bob：100，Smith：0</li><li>Bob：0，Smith ：0 ------------->Bob：0，Smith ：300（另一个事务干的）</li></ol><ul><li class=ql-indent-1>上一个状态为：Bob：100，Smith：0</li></ul><ol><li>Bob ： 0 ， Smith ：100（转账成功）</li></ol><ul><li class=ql-indent-1>上一个状态为： Bob：0，Smith ：0</li></ul><p>如果有另一个事务在进行到步骤2的时候把smith账户加到了300块钱，此时如果回滚，会把smith改为0，那加上的300块就丢失了。 那么我们还需要一致性。</p><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba85d4b392ce412fa33d14e0b1202308><p class=pgc-img-caption></p></div><h1><strong>一致性</strong></h1><p>上一章我们提到了如果在事务中间，有另一个事务突然插手对数据进行修改，则如果出现回退，将会出现数据不一致的问题。</p><p>那怎么解决这个问题呢？如果我们一个事务对数据操作完了以后，另一个事务再进入，这样就不会发生争抢和数据不一致了。所以核心就在于<strong>加锁</strong>。</p><p>比如</p><pre> Lock Bob , Smith</pre><ol><li>Bob：100，Smith：0</li><li>Bob：0，Smith ：0 ------------->Bob：0，Smith ：300（另一个事务干的）</li></ol><ul><li class=ql-indent-1>上一个状态为：Bob：100，Smith：0</li></ul><ol><li>Bob ： 0 ， Smith ：100（转账成功）</li></ol><ul><li class=ql-indent-1>上一个状态为： Bob：0，Smith ：0</li><li>unLock Bob and Smith</li></ul><p>在事务的开始和结束分别进行加锁和解锁。这样，其他的事务并不可知事务内部的事情。只有在<strong>事务单元内部完全成功了以后才对外可见。</strong></p><p>到现在我们“仿佛”已经解决了<strong>并发、一致</strong>两个大问题了，但是新的问题也来了，<strong>加锁</strong>以后，其他的事务无法对数据进行访问，那么<strong>系统的并发度</strong>是上不来的，这就是下面的<strong>隔离性</strong>要解决的问题。</p><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ce42f29b0fc845b59e89604d0251df67><p class=pgc-img-caption></p></div><h1><strong>隔离性</strong></h1><p>所谓<strong>隔离性</strong>，其实是以性能作为理由，在破坏<strong>一致性</strong>。何以见得？因为如果要保证强一致性，最好的方法就是不管读写，统统排队进行，这样一定不会出现数据不一致的情况。</p><p>然而此时就做不到高的并发，性能也就上不去。所以我们只要做一些妥协，比如只加写锁，不加读锁。</p><p>我们首先需要看看，两个事务单元对同一个数据，有哪几种并发模式，然后定义不同的隔离级别，看每种隔离级别可以实现哪些并发模式。</p><p><strong>4种可能</strong></p><p>同样我们以一个例子来说明</p><p>现在 T1 ：Bob要给Smith 100块，然后T2 ： Smith要给Joe 100块。</p><p>这就是两个事务，如下图所示，为了保证一致性，Smith账户会被两个事务单元锁定。也就是两个事务有共享数据，Bob在给Smith转钱的时候，另一个事务无法对Smith账户进行操作了，并发就上不去。</p><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b7c5541752245d4a1d8fcdb0043dfe4><p class=pgc-img-caption></p></div><p>此时两个事务单元T1，T2之间只有<strong>读写并发、写读并发、读读并发、写写并发</strong>4种可能。</p><ul><li>写写并行</li><li>什么时候能写写并行，只有当两个事务的数据完全没有重叠的情况下，比如如下的情况。</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f090ba0afd9349969738656277c62256><p class=pgc-img-caption></p></div><p>因为没有共享数据，所以完全可以<strong>写写</strong>并行，也就是写写都不加锁。</p><ul><li>读读并行</li><li>也就是读操作不加锁，这样读与读可以并行操作，因为读不会修改数据，所以读读可以放心的并行，而不用担心一致性的问题。</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b044d7cbee21492d8a3815afa2ec0dd8><p class=pgc-img-caption></p></div><ul><li><br></li><li>读写并行</li><li>也就是读的时候，可以并发写。我们知道，写操作会修改数据，但是写是加锁的，所以我们无法读到写未提交的结果。所以虽然两次读到的数据是不一样的，<strong>不可重复读</strong>，但是每次读到的数据都是正确的，不存在不一致。</li><li>写读并行</li><li>也就是写的时候，还可以并发读。因为数据是在不断改变的，很可能读到中间的状态，如果系统在此时崩溃了，重启的时候会恢复到修改前的值，此时自然会出现错乱。</li><li>那么我们是否无法实现写读并行了吗？并不是，可以通过Copy on Write。具体怎么做呢？每次写操作之前都把数据复制一份到log里面，在log里面进行修改。</li><li>其实就是把原来的数据复制一份，然后修改。这样读操作作用的就是原来的数据，而写作用的是备份的数据，互不干扰。</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e2a7336d37c429ba77689b8c771ceb4><p class=pgc-img-caption></p></div><p>这种方法又叫（MVCC，Multi Version content control，多版本内容控制）。那么<strong>多版本</strong>是什么意思。</p><p>我们知道数据被复制出去了一份以后，可能会被修改多次，那么<strong>下一次读应该读修改后哪个版本的数据呢？</strong>这个时候，我们可以在日志里面加上<strong>版本号</strong>。比如说，现在写入的数据版本号是10，如果要读取版本号为5的数据，则可以往前一直找，直到找到对应的位置。</p><p>所以如果读发生在写操作之后，<strong>读的版本号一定要大于写的版本号。</strong>这样就可以保证读到想要的数据。</p><p><strong>四种隔离级别</strong></p><p>上面讲了两个事务单元针对一块数据其实有4种并发的可能，接下来我们继续讨论<strong>隔离级别</strong>。不同的隔离级别可以实现<strong>读写并行、写读并行、读读并行、写写并行</strong>的一种或者几种。</p><p>串行化：</p><ul><li>就是读的时候不允许写，写的时候不允许读，这样可以保证数据强一致，但是性能最低。SQLite默认采用这种方式。</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/712a96c1c5b24acdabb585bfebfe3f98><p class=pgc-img-caption></p></div><ul><li>可重复读，也就是只能实现<strong>读读并行</strong>，<strong>读写、写读、写写</strong>等不能实现。</li><li>所以在两个都是读的时候，不加读锁，其他情况均需要加锁。</li><li>MySQL默认是这种方式。</li></ul><p>读已提交(Read Committed)：</p><ul><li>此时当数据被加上读锁了以后，一个写进来，写锁替换掉读锁，也就是<strong>可以将读锁升级为写锁。</strong></li><li>那么如果事务T1读取了数据，然后事务T2把这个数据修改了，因为事务T2也是加锁的，所以它会提交，那么事务T1<strong>再读取</strong>这个数据时，原来的数据已经发生变化了。这就是不可重复读。</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c98edd846b74afd8877529b2de581ab><p class=pgc-img-caption></p></div><ul><li>此时可以做到<strong>读写并行、读读并行</strong>，做不了<strong>写读并行</strong></li><li>Oracle , PostgreSQL, SQL Server都是使用的这种模式。</li></ul><p>读未提交：顾名思义，就是可以读到未提交的内容</p><ul><li>最低级别的隔离，此时只加上<strong>写和读是不加锁的</strong>。因为数据是在不断改变的，很可能读到中间的状态，如果系统在此时崩溃了，重启的时候会恢复到修改前的值，此时自然会出现错乱。</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a5910e9a3ec74ffa90af7ffaa629d41f><p class=pgc-img-caption></p></div><p>要解决<strong>写读并行</strong>的问题，可以使用上面说过的Copy on write，这种方法最大的好处在于可以保证写读并行，同时隔离级别还很高</p><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/074aef41a29647ba8a2b94887ae50cbd><p class=pgc-img-caption></p></div><h1><strong>持久性</strong></h1><p>现在我们来讨论最后ACID的<strong>持久性</strong>，也就是<strong>只要事务提交了，不管是崩溃还是出错，数据一定要写到磁盘上</strong></p><p>那么数据什么情况下会丢失呢？</p><ul><li>首先是磁盘损坏。所以我们可以使用RAID冗余磁盘阵列来保证可靠性。详见【大话存储】学习笔记（4，5章），RAID</li><li>还有就是内存如果掉电，里面的数据就必然丢失，持久性得不到保证。但是如果每一次提交操作完成以后，都将内存中的数据同步到硬盘上，则会造成频繁写硬盘，性能将下降。所以<strong>持久性和延迟无法兼得</strong></li><li>我们只要进行折中，比如只要把数据提交到<strong>内存</strong>，就立刻返回成功，然后将一段时间的请求<strong>打包</strong>送到磁盘上。这样就避免了每次提交都写磁盘</li></ul><div class=pgc-img><img alt=数据库为什么需要事务呢？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1295e872204848b4901d8366ede35dfd><p class=pgc-img-caption></p></div><h1><strong>参考</strong></h1><pre>如果有人问你数据库的原理，叫他看这篇文章《如果有人问你数据库的原理，叫他看这篇文章》</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据库','什么','事务'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>