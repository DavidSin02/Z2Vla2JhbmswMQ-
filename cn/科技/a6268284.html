<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C#客户端和服务端通信的几种方法：Rest和GRPC和其他 | 极客快訊</title><meta property="og:title" content="C#客户端和服务端通信的几种方法：Rest和GRPC和其他 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ce1e708de336421eb2253ae0934a235f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6268284.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6268284.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6268284.html><meta property="article:published_time" content="2020-11-14T21:03:40+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:40+08:00"><meta name=Keywords content><meta name=description content="C#客户端和服务端通信的几种方法：Rest和GRPC和其他"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a6268284.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C#客户端和服务端通信的几种方法：Rest和GRPC和其他</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>本文来自：https://michaelscodingspot.com/rest-vs-grpc-for-asp-net/</p><p><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在C＃客户端和C＃服务器之间进行通信的方法有很多。一些功能强大，而其他功能则不是很多。有些非常快，有些则不是。知道不同的选择很重要，这样您才能决定最适合自己的选择。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">本文将介绍当今最流行的技术，以及为何如此广泛地使用它们。我们将讨论REST，gRPC及其两者之间的所有内容。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最佳方案</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">让我们考虑一下我们希望如何在最佳环境中使客户端与服务器之间的通信看起来像。我在想像这样的东西：</span></p><pre><code>// on client sidepublic void Foo(){    var server = new MyServer(new Uri("https://www.myserver.com/");)    int sum = server.Calculator.SumNumbers(12,13); }</code></pre><pre><code>// on server sideclass CalculatorController : Controller{    public int SumNumbers(int a, int b)    {        return a + b;    }}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">我当然想要完整的Intellisense。当我单击 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">server</span> 并 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.</span> 希望Visual Studio显示所有控制器时。当我单击 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">CalculatorController</span> 和时 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.</span> ，我想查看所有操作。我还想要一流的性能，很少的网络负载和双向通信。而且我想要一个能够完美处理版本控制的强大系统，这样我就可以毫不费力地部署新的客户端版本和新的服务器版本。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">要求太多吗？</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">请注意，我在这里谈论的是 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">无状态</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> API。这等效于C＃项目，其中只有两种类型的类：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• 静态类，只有静态方法。 • POCO类 [1] 仅具有类型为基本类型或其他POCO类的字段和属性。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在API中使用状态会带来复杂性，而这正是万恶之源。因此，为了本文的方便，让我们保持美好和无状态。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">传统REST</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">REST API出现在2000年代初期，席卷了整个互联网。到目前为止，它是创建Web服务的最流行的方法。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">REST为客户端到服务器的请求定义了一组固定的操作 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">GET，POST，PUT</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 和 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">DELETE</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 。每个请求都将通过包含有效负载（通常为JSON）的响应来回答。请求包含在查询本身中的参数，或者在它是POST请求时包含为有效负载（通常为JSON）的参数。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有一个称为RESTful API的标准，它定义了以下规则（您实际上不必使用它）：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• GET用于检索资源 • PUT用于更改资源状态 • POST用于创建资源 • DELETE用于删除资源</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">如果您到目前为止还不熟悉REST，则上面的解释可能不会减少它，因此这里有一个示例。在.NET中，内置了对REST的支持。实际上，默认情况下，ASP.NET Web API被构建为REST Web服务。这是典型的客户端和ASP.NET服务器的外观：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在服务器中：</span></p><pre><code>[Route("People")]public class PeopleController : Controller{    [HttpGet]    public Person GetPersonById(int id)    {        Person person = _db.GetPerson(id);        return person;//Automatically serialized to JSON    }}   </code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在客户中：</span></p><pre><code>var client = new HttpClient();string resultJson =     await client.GetStringAsync("https://www.myserver.com/People/GetPersonById?id=123");Person person = JsonConvert.DeserializeObject&lt;Person&gt;(resultJson);</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">REST非常方便，但是并没有达到最佳方案。因此，让我们看看是否可以做得更好。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">ReFit</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">ReFit不能替代REST。相反，它建立在REST之上，并允许我们像调用简单方法一样调用服务器端点。这是通过在客户端和服务器之间共享接口来实现的。在服务器端，您的控制器将实现一个接口：</span></p><pre><code>public interface IMyEmployeeApi{    [Get("/employee/{id}")]    Task&lt;Employee&gt; GetEmployee(string id);}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">然后，在客户端，您需要包括相同的接口并使用以下代码：</span></p><pre><code>var api = RestService.For&lt;IMyEmployeeApi&gt;("https://www.myserver.com");var employee = await api.GetEmployee("abc");</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">就这么简单。除了几个NuGet软件包外，无需运行困难的自动化程序或使用任何第三方工具。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">这更接近最佳方案。现在，我们有了IntelliSense，并且客户端和服务器之间的合同很牢固。但是还有另一种选择，在某些方面甚至更好。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">昂首阔步</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">像ReFit一样，Swagger也建立在REST之上。 OpenAPI [2] 或 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Swagger</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 是REST API的规范。它描述了具有简单JSON文件的REST Web服务。这些文件是Web服务的API架构。它们包括：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• API中的所有路径（URL）。 • 每个路径的预期操作（GET，POST等）。每个路径可以处理不同的操作。例如，单个路径 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">https://mystore.com/Product</span> 可能接受添加产品的POST操作和返回产品的GET操作。 • 每个路径和操作的预期参数。 • 每个路径的预期响应。 • 每个参数和响应对象的类型。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">该JSON文件实质上是客户端和服务器之间的合同。这是一个描述一个称为 Swagger Petstore [3] 的Web服务的swagger文件的示例（为清楚起见，我删除了一些部分）：</span></p><pre><code>{    "swagger":"2.0",   "info":{       "version":"1.0.0",      "title":"Swagger Petstore",      "description":"A sample API that uses a petstore as an example to demonstrate features in the swagger-2.0 specification",   },   "host":"petstore.swagger.io",   "basePath":"/api",   "schemes":[       "http"   ],   "consumes":[       "application/json"   ],   "produces":[       "application/json"   ],   "paths":{       "/pets":{          "get":{             "description":"Returns all pets from the system that the user has access to",            "operationId":"findPets",            "produces":[                "application/json",               "application/xml",            ],            "parameters":[                {                   "name":"tags",                  "in":"query",                  "description":"tags to filter by",                  "required":false,                  "type":"array",                  "items":{                      "type":"string"                  },                  "collectionFormat":"csv"               },               {                   "name":"limit",                  "in":"query",                  "description":"maximum number of results to return",                  "required":false,                  "type":"integer",                  "format":"int32"               }            ],            "responses":{                "200":{                   "description":"pet response",                  "schema":{                      "type":"array",                     "items":{                         "$ref":"#/definitions/Pet"                     }                  }               },...</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">让我们考虑一下这个结果。使用上面的JSON文件，您可以潜在地创建具有完整IntelliSense的C＃客户端。毕竟，您知道所有路径，操作，它们期望的参数，什么参数类型，什么是响应等等。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有几种工具可以做到这一点。对于服务器端，可以使用 Swashbuckle.AspNetCore [4] 将Swagger添加到ASP.NET中并生成所述JSON文件。对于客户端，您可以使用 swagger-codegen [5] 和 AutoRest [6] 来使用这些JSON文件并生成客户端。让我们看一个如何做到这一点的例子：</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">将Swagger添加到ASP.NET服务器</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">首先添加NuGet包 Swashbuckle.AspNetCore [7] 。在中 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">ConfigureServices</span> ，注册Swagger生成器：</p><pre><code>services.AddSwaggerGen(options =&gt;     options.SwaggerDoc("v1", new OpenApiInfo {Title = "My Web API", Version = "v1"}));</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在添加 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Configure</span> 方法中 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Startup.cs</span> ：</p><pre><code>app.UseSwagger();</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最后，控制器内部的动作应使用 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[HttpXXX]</span> 和 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[FromXXX]</span> 属性修饰：</p><pre><code>[HttpPost]public async Task AddEmployee([FromBody]Employee employee){    //...}[HttpGet]public async Task&lt;Employee&gt; Employee([FromQuery]string id){    //...}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">就像服务器端一样简单。运行项目时， </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">swagger.json</span> 将生成一个文件，可用于生成客户端。</p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">使用AutoRest从Swagger生成客户端</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">要开始使用 AutoRest [8] ，与安装 NPM [9] ： </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">npm install -g autorest</span> 。安装后，您将需要使用AutoRest的命令行界面从该 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">swagger.json</span> 文件生成C＃客户端。这是一个例子：</p><pre><code>autorest --input-file="./swagger.json" --output-folder="GeneratedClient" --namespace="MyClient" --override-client-name="MyClient" --csharp</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">这将产生一个 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">GeneratedClient</span> 包含生成的C＃文件的文件夹。请注意，名称空间和客户端名称被覆盖。从这里，将此文件夹添加到Visual Studio中的客户端项目。</p><div class=pgc-img><img alt=C#客户端和服务端通信的几种方法：Rest和GRPC和其他 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ce1e708de336421eb2253ae0934a235f><p class=pgc-img-caption></p></div><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">您需要安装 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Microsoft.Rest.ClientRuntime</span> NuGet软件包，因为生成的代码取决于该软件包。安装后，您可以像使用常规C＃类一样使用API：</p><pre><code>var client = new MyClient();Employee employee = client.Employee(id: "abc");</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">您可以在AutoRest的 文档中 [10] 阅读一些细微之处。而且您需要使该过程自动化，因此我建议阅读Patrik Svensson的 教程， [11] 以获得一些好的建议以及Peter Jausovec的这篇 文章 [12] 。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">Swagger的问题是JSON文件是在运行时创建的，因此这使得在CI / CD流程中实现自动化有点困难。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">传统REST vs Swagger vs ReFit</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">进行选择时，请注意以下几点。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• 如果您有一个非常简单的私有REST API，则也许不必理会客户端生成和共享接口。小任务并不能证明付出额外的努力是合理的。 • Swagger支持多种语言，而ReFit仅支持.NET。Swagger还是许多工具，测试，自动化和UI工具的基础。如果您要创建一个大型的公共API，它将可能是最佳选择。 • Swagger比ReFit复杂得多。使用ReFit，只需在服务器和客户端项目中添加一个接口即可。另一方面，使用ReFit，您必须为每个控制器创建新的接口，而Swagger会自动进行处理。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">但是在决定任何事情之前，请检查与REST无关的第四个选项。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC [13] （ </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC远程过程调用</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> ）是Google开发的开源远程过程调用系统。它有点像REST，它提供了一种将请求从客户端发送到服务器的方式。但这在许多方面都不同，这是相同点和不同点：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• 像REST一样，gRPC与语言无关。有适用于所有流行语言的工具，包括C＃。 • gRPC是契约的基础，并使用 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件来定义契约。这有点类似于Swagger <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">swagger.json</span> 和ReFit的共享界面。可以从那些文件中生成任何编程语言的客户端。 • gRPC使用 协议缓冲区（Protobuf） [14] 二进制序列化。这与REST（通常序列化为JSON或XML）不同。二进制序列化较小，因此更快。 • gRPC用于使用HTTP / 2协议创建持久连接。该协议更简单，更紧凑。REST使用HTTP 1.x协议（通常为HTTP 1.1）。 • HTTP 1.1要求每个请求都进行TCP握手，而HTTP / 2则保持连接打开。 • HTTP / 2连接使用多路复用流。这意味着单个TCP连接可以支持许多流。这些流可以并行执行，而不必像HTTP 1.1中那样互相等待。 • gRPC允许双向流。</p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">有两种使用gRPC的方法。对于.NET Core 3.0，有一个完全托管的库，称为 .NET的gRPC [15] 。对于其中的任何内容，您都可以使用 gRPC C＃ [16] ，它是使用本机代码构建的。这并不意味着 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">适用于.NET的gRPC可以</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 替代 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC C＃</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 。让我们来看一个 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">用于.NET</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 的更新 </span><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC</span></strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313"> 的示例。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">.NET的gRPC的服务器端</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">这不是教程，而是更多有关预期内容的一般性想法。这是示例控制器在gRPC中的外观：</span></p><pre><code>public class GreeterService : Greeter.GreeterBase{    public override Task&lt;HelloReply&gt; SayHello(HelloRequest request,        ServerCallContext context)    {        _logger.LogInformation("Saying hello to {Name}", request.Name);        return Task.FromResult(new HelloReply         {            Message = "Hello " + request.Name        });    }}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">您需要添加以下的 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Configure</span> 在 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">Startup.cs</span> ：</p><pre><code>app.UseEndpoints(endpoints =&gt;{    endpoints.MapGrpcService&lt;GreeterService&gt;();});</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">API在 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件中描述，该文件是项目的一部分：</p><pre><code>syntax = "proto3";service Greeter {  rpc SayHello (HelloRequest) returns (HelloReply);}message HelloRequest {  string name = 1;}message HelloReply {  string message = 1;}</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">此 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件添加到 <span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.csproj</span> ：</p><pre><code>&lt;ItemGroup&gt;  &lt;Protobuf Include="Protos\greet.proto" /&gt;&lt;/ItemGroup&gt;</code></pre><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">.NET的gRPC客户端</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">客户端是从 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">.proto</span> 文件生成的。代码本身非常简单：</p><pre><code>var channel = GrpcChannel.ForAddress("https://localhost:5001");var client = new Greeter.GreeterClient(channel);var response = await client.SayHello(    new HelloRequest { Name = "World" });Console.WriteLine(response.Message);</code></pre><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC与REST</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">gRPC听起来不错。它在框架下更快，更简单。那么，我们都应该从REST变为gRPC吗？答案是，这取决于你的应用场景。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">以下是一些注意事项：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">从我的印象来看，使用gRPC和ASP.NET仍然不是很好。借助对REST的成熟支持，您会变得更好。就基于契约的通信而言，这很不错，除了在REST中有我们已经讨论过的类似替代方案：Swagger和ReFit。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">最大的优势是性能。 根据这些基准 [17] ，在大多数情况下，gRPC更快。特别是对于大型有效载荷，Protobuf序列化确实有所作为。这意味着对于高负载服务器而言，这是一个巨大的优势。</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">在大型ASP.NET应用程序中从REST过渡到gRPC将非常困难。但是，如果您具有基于微服务的体系结构，那么逐步完成此过渡就变得容易得多。</span></p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">其他沟通方式</span></strong></h1><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">还有其他一些我完全没有提及的通信方式，但是值得一提的是：</span></p><p style=text-align:start><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">• GraphQL [18] 是Facebook开发的API的查询语言。它允许客户端从服务器确切地要求它需要的数据。这样，您可以在服务器上仅创建一个端点，该端点将非常灵活，并且仅返回客户端所需的数据。近年来，GraphQL变得非常流行。 • SignalR [19] 是一项允许服务器与客户端之间进行实时双向通信的技术。SignalR不仅允许客户端始终向服务器发送请求，还允许服务器向客户端发送推送通知。这样可以查看Web应用程序中的实时更新。SignalR在ASP.NET中非常流行。 • TcpClient [20] 和 TcpListener [21] （在中 </span><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">System.Net.Sockets</span> ）提供基于TCP的低级连接。基本上，您将建立连接并传输字节数组。对于大型应用程序而言，它不是理想的选择，在大型应用程序中，您可以使用ASP.NET的控制器和操作在大型API中进行订购。 • UdpClient [22] 提供了一种通过UDP协议进行通信的方法。TCP建立连接，然后发送数据，而UDP仅发送数据。TCP确保数据中没有错误，而UDP没有。UDP可以更有效地快速传输数据，您不必担心它是否可靠且没有错误。一些示例是：视频流，实时广播和IP语音（VoIP）。 • WCF [23] 是一种较旧的技术，主要在进程之间使用基于SOAP的通信。这是一个庞大的框架，我要说的是它已不再受REST和JSON负载的欢迎。</p><h1 class=pgc-h-arrow-right><strong><span style="background-color:#fefefe;--tt-darkmode-bgcolor: #131313">References</span></strong></h1><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[1]</span> POCO类: <em>https://www.c-sharpcorner.com/UploadFile/5d065a/poco-classes-in-entity-framework/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[2]</span> OpenAPI: <em>https://swagger.io/specification/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[3]</span> Swagger Petstore: <em>https://bfanger.nl/swagger-explained/#operationObject</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[4]</span> Swashbuckle.AspNetCore: <em>https://github.com/domaindrivendev/Swashbuckle.AspNetCore</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[5]</span> swagger-codegen: <em>https://github.com/swagger-api/swagger-codegen</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[6]</span> AutoRest: <em>https://azure.github.io/autorest/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[7]</span> Swashbuckle.AspNetCore: <em>https://www.nuget.org/packages/Swashbuckle.AspNetCore</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[8]</span> AutoRest: <em>https://github.com/Azure/autorest</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[9]</span> NPM: <em>https://www.w3schools.com/nodejs/nodejs_npm.asp</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[10]</span> 文档中: <em>https://azure.github.io/autorest/client/ops.html</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[11]</span> 教程，: <em>https://www.patriksvensson.se/2018/10/generating-api-clients-using-autorest</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[12]</span> 文章: <em>https://medium.com/@pjausovec/creating-c-client-library-for-web-api-projects-be132c831f9c</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[13]</span> gRPC: <em>https://grpc.io/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[14]</span> 协议缓冲区（Protobuf）: <em>https://en.wikipedia.org/wiki/Protocol_Buffers</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[15]</span> .NET的gRPC: <em>https://github.com/grpc/grpc-dotnet</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[16]</span> gRPC C＃: <em>https://github.com/grpc/grpc/tree/master/src/csharp</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[17]</span> 根据这些基准: <em>https://www.yonego.com/nl/why-milliseconds-matter/#gref</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[18]</span> GraphQL: <em>https://graphql.org/</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[19]</span> SignalR: <em>https://github.com/SignalR/SignalR</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[20]</span> TcpClient: <em>https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcpclient?view=netframework-4.8</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[21]</span> TcpListener: <em>https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.tcplistener?view=netframework-4.8</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[22]</span> UdpClient: <em>https://docs.microsoft.com/en-us/dotnet/api/system.net.sockets.udpclient?view=netframework-4.8</em></p><p style=text-align:start><span style="background-color:#f7f7f9;--tt-darkmode-bgcolor: #BEBEBF">[23]</span> WCF: <em>https://docs.microsoft.com/en-us/dotnet/framework/wcf/whats-wcf</em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'C#','客户','务端'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>