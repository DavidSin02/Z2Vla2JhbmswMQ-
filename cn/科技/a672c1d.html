<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>我也是第一次知道，正流行的接口测试工具requests库原来这么好用 | 极客快訊</title><meta property="og:title" content="我也是第一次知道，正流行的接口测试工具requests库原来这么好用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/23f7750cba654d2087c132af3fbd6836"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a672c1d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a672c1d.html><meta property="article:published_time" content="2020-10-29T21:04:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:30+08:00"><meta name=Keywords content><meta name=description content="我也是第一次知道，正流行的接口测试工具requests库原来这么好用"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a672c1d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>我也是第一次知道，正流行的接口测试工具requests库原来这么好用</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>说到python发送HTTP请求进行接口自动化测试，脑子里第一个闪过的可能就是requests库了，当然python有很多模块可以发送HTTP请求，包括原生的模块http.client,urllib2等，但由于原生的模块过于复杂，使用繁琐，那么requests库就诞生了，它也是现阶段比较流行的接口自动化测试工具之一。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口测试工具requests库原来这么好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/23f7750cba654d2087c132af3fbd6836><p class=pgc-img-caption></p></div><p>requests是个第三方库，封装了HTTP请求的所有方法，使用方便简单，只需要根据不同的请求方式调用相对应的方法就可以完成发送网络请求的整个过程，那么今天我们就来说说requests库是如何使用的，<strong>那么在开始之前我们大致说一下今天的主要内容：</strong></p><p>1. requets如何发送get请求</p><p>2. requests如何发送post请求</p><p>3. params参数和data参数的区别</p><p>4. requests库中Session类的的妙用</p><p>5. 针对get请求和post请求，对requests进行简单封装</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口测试工具requests库原来这么好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/2b98d589-8a88-4218-8c2d-14480adab91e><p class=pgc-img-caption></p></div><p><strong>发送get请求</strong></p><p>requests是通过调用get()方法来完成发送get请求的，那么，在掌握requests库如何发送get请求之前，你还应该简单了解一下什么是get请求？</p><p>通常在我们学习一个方法如何使用之前，我们需先知道这个方法需要哪些参数？参数类型是什么？ 那么我们就先分析一下get()方法的源码：</p><p>def get(url, params=None, **kwargs):</p><p>r"""Sends a GET request.</p><p>:param url: URL for the new :class:`Request` object.</p><p>:param params: (optional) Dictionary, list of tuples or bytes to send</p><p>in the body of the :class:`Request`.</p><p>:param \*\*kwargs: Optional arguments that ``request`` takes.</p><p>:return: :class:`Response &lt;Response>` object</p><p>:rtype: requests.Response</p><p>"""</p><p>kwargs.setdefault('allow_redirects', True)</p><p>return request('get', url, params=params, **kwargs)</p><p>这就是get方法的源码了，你应该能够发现，get()方法只有一个必传的参数url，其他参数都是非必传的，那么其他的参数有什么作用呢？</p><p><strong>params</strong></p><p>对于这个参数，可以是字典，也可以是嵌套元组的列表，基于get请求的特点，请求参数是可以直接跟在URL之后的，以？号开始以key=value的形式传递(多个参数使用&符号进行分割)，但是为了明确区分URL和参数，就需要使用params参数传递。</p><p>**kwargs：其他一些关键字参数，暂时不做介绍。</p><p>接下来我们来看2个简单的实例，体会一下reauets通过get()方法发送一个不带参数的get请求和带参数的请求的过程。</p><p>通过get()方法发送get请求访问博客园首页</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/11 20:34</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests # 导入requests模块</p><p>response = requests.get('https://www.cnblogs.com/') # 发送get请求</p><p>print(response.text) # 获取响应数据</p><p>响应数据</p><p>&lt;!DOCTYPE html></p><p>&lt;html></p><p>&lt;head></p><p>&lt;meta charset="utf-8" /></p><p>&lt;meta name="viewport" content="width=device-width, initial-scale=1" /></p><p>&lt;meta name="referrer" content="always" /></p><p>&lt;title>博客园 - 代码改变世界&lt;/title></p><p>&lt;meta name="keywords" content="开发者,博客园,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,Developer,Programmer,Coder,Geek,技术社区" /></p><p>&lt;meta name="description" content="博客园是一个面向开发者的知识分享社区。自创建以来，博客园一直致力并专注于为开发者打造一个纯净的技术交流社区，推动并帮助开发者通过互联网分享知识，从而让更多开发者从中受益。博客园的使命是帮助开发者用代码改变世界。" /></p><p>&lt;link rel="shortcut icon" href="//common.cnblogs.com/favicon.ico" type="image/x-icon" /></p><p>&lt;link rel="Stylesheet" type="text/css" href="../../bundles/aggsite.css?v=IlEZk4Ic2eCzcO6r0s4bGm62FAo8VZI-US_0EqUe2Bk1" /></p><p>&lt;link id="RSSLink" title="RSS" type="application/rss+xml" rel="alternate" href="http://feed.cnblogs.com/blog/sitehome/rss" /></p><p>&lt;script src="//common.cnblogs.com/scripts/jquery-2.2.0.min.js" type="text/javascript">&lt;/script></p><p>&lt;script src="../../bundles/aggsite.js?v=cE0bqImLWsEG3gZXOupKxj5tj_ukK7pLeSd73DHZOT81" type="text/javascript">&lt;/script></p><p>&lt;script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'>&lt;/script></p><p>&lt;script></p><p>var googletag = googletag || {};</p><p>googletag.cmd = googletag.cmd || [];</p><p>&lt;/script></p><p>这里我只截取了一部分响应数据，响应数据其实是博客园的首页HTML源码。</p><p>可以看到只需要一行代码即可完成整个请求过程，通过response.text得到响应数据(其实这个过程和我们在浏览器中输入博客园地址访问是一样的)，当然你还可以使用以下的方法获取不同的响应数据。</p><p>response.headers # 获取响应头信息</p><p>response.cookies # 获取返回的cookie</p><p>response.status_code # 获取状态码</p><p>发送带params参数的get请求</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/11 20:34</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login' # 接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需参数</p><p>response = requests.get(url=login_url, params=login_data) # 发送get请求</p><p>print(response.text) # 获取响应数据</p><p>print(response.url)</p><p>响应数据</p><p>{"status":1,"code":"10001","data":null,"msg":"登录成功"}</p><p>http://***:8080/futureloan/mvc/api/member/login?mobilephone=13691579841&pwd=123456</p><p>Process finished with exit code 0</p><p>我们通过传递一个字典给params参数，即可完成带参数的get请求，并获取响应数据。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口测试工具requests库原来这么好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/9fa5f185-0ff4-48d4-806f-e38c2fa6accb><p class=pgc-img-caption></p></div><p><strong>注意</strong></p><p>1. 我们日常工作中也最好传递字典作为接口数据，如果数据类型是json则在发送请求的时候需要先转成字典。</p><p>2. 只要你发送的是get请求，且不想通过url拼接的方式直接传递接口参数，那么只能使用params参数来传递(如果你使用data，json等参数时你会发现，请求并不会成功)，因为通过params传递的参数会附加到url后，这也是get请求的特点，因此你需记住：发送get请求时参数只能使用params即可。</p><p>以上只是简单的发送get请求的方法，至于如何发送带其他参数的get请求(比如headers，cookies等)，还需对get()进一步的研究和实践。</p><p><strong>发送post请求</strong></p><p>同样，在开始学习下面的内容之前，仍建议你先了解什么是post请求及其特点，对你学习接下来的内容也会更好理解。</p><p>requests发送post请求是通过post()方法来实现的，那么我们还是先看一下它的源码：</p><p>def post(url, data=None, json=None, **kwargs):</p><p>r"""Sends a POST request.</p><p>:param url: URL for the new :class:`Request` object.</p><p>:param data: (optional) Dictionary (will be form-encoded), bytes, or file-like object to send in the body of the :class:`Request`.</p><p>:param json: (optional) json data to send in the body of the :class:`Request`.</p><p>:param \*\*kwargs: Optional arguments that ``request`` takes.</p><p>:return: :class:`Response &lt;Response>` object</p><p>:rtype: requests.Response</p><p>"""</p><p>return request('post', url, data=data, json=json, **kwargs)</p><p>通过源码我们可以发现，post()和get()一样，仅有一个url参数是必传的，其他仍然可以不传递，但是其中data和json参数却是post()方法中最重要的参数，下面就说一下何时使用data，何时使用json。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口测试工具requests库原来这么好用 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/6b3a72e9-6116-499e-972a-32d0d4614798><p class=pgc-img-caption></p></div><p><strong>data</strong></p><p>大多数post请求的接口默认支持参数类型Content-Type为application/x-www-form-urlencoded, 它告诉我们请求的接口参数需要传递一个form表单，那么我们往往是通过构造一个字典来传递form表单的，</p><p>所以当我们向服务器提交form表单时就可以使用data参数，它会接收一个字典类型的数据，存放到请求体中，然后发送给服务器(参数需是字典类型)。</p><p><strong>Json</strong></p><p>首先你访问的接口需要支持content_type为application/json格式的数据类型，那么你就可以通过json这个参数来传递接口参数（参数可以是字典也可以是json类型）。</p><p>下面我们来看一个发送post请求，使用data参数的实例：</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***.com:8080/futureloan/mvc/api/member/login' # 接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需参数</p><p>response = requests.post(url=login_url, data=login_data) # 发送post请求</p><p>print(response.text) # 获取响应数据</p><p>print(response.url)</p><p>print(response.status_code)</p><p><strong>响应数据</strong></p><p>{"status":1,"code":"10001","data":null,"msg":"登录成功"}</p><p>http://***:8080/futureloan/mvc/api/member/login</p><p>200</p><p>Process finished with exit code 0</p><p>使用json参数实例</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***monban.com:8080/futureloan/mvc/api/member/login' # 接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需参数</p><p>response = requests.post(url=login_url, json=login_data) # 发送post请求</p><p>print(response.text) # 获取响应数据</p><p>print(response.url)</p><p>print(response.status_code)</p><p><strong>响应数据</strong></p><p>{"status":0,"code":"20103","data":null,"msg":"手机号不能为空"}</p><p>http://***/futureloan/mvc/api/member/login</p><p>200</p><p>Process finished with exit code 0</p><p>可以看到使用data参数和json参数，获取到的返回结果是不一样的，因为我这里使用的接口不支持application/json数据格式，所以当你使用json参数传递参数时，服务器是无法解析数据的，也就不会返回正确的结果了。</p><p>所以对于何时使用data参数，何时使用json参数，还需要根据实际的接口所支持的数据类型进行选择。</p><p><strong>params和data区别</strong></p><p>上面已经说过get请求中的params参数和post请求中的data参数，那么这两个参数到底有什么区别呢？</p><p>1. 发送get请求时，由于get请求没有请求体，请求参数只能跟在url地址后的，而且服务器也只能通过解析url获得请求的参数，因此get()方法发送get请求时只能使用params参数，它会把请求的参数默认追加到url地址后面。</p><p>2. 通常情况下用户需要提交某些数据时，发送的请求一般都为post请求，post请求会提交一个form表单，那么我们就可以构造一个字典格式的数据，使用data参数传递，由于post请求是有请求体的，而且请求参数就存放在请求体中，服务器也只能通过解析请求体中内容而获得请求的参数，所以post请求不能使用params传递接口参数，只能使用data，json，file等, data参数会把请求参数放到请求体中。</p><p><strong>Session类的妙用</strong></p><p>实际工作中，我们会经常遇到需要保持某一个状态，才能测试后续的接口，比如说：充值接口，那么需要用户先登录，且一直保持登录状态才能进行充值，那么对于这种情况该怎么解决呢？这就要用到requests库中的Session类了，Session可以保持请求的状态，像我们访问某个网站一样，我们只要登录后就可以浏览该网站上的任意页面，先看下面实例：</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login' # 登录接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需参数</p><p>response_login = requests.post(url=login_url, data=login_data) # 发送post请求 登录</p><p>print(response_login.text)</p><p>recharge_url = r'http://***:8080/futureloan/mvc/api/member/recharge' # 充值接口地址</p><p>recharge_data = {"mobilephone": "13691579841", "amount": 10000.00} # 接口所需参数</p><p>response_recharge = requests.post(url=recharge_url, data=recharge_data) # 发送请求，开始充值</p><p>print(response_recharge.text)</p><p>执行结果</p><p>{"status":1,"code":"10001","data":null,"msg":"登录成功"}</p><p>{"status":0,"code":null,"data":null,"msg":"抱歉，请先登录。"}</p><p>Process finished with exit code 0</p><p>可以发现，我们之前都已经登录过了，但是充值时却失败了，原因就是直接使用reauests来发送请求时，并不会保持当前的状态(这也是HTTP请求的缺陷)，现在我们使用Session对像再次发送充值请求，修改代码。</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 10:22</p><p>@Auth : linux超</p><p>@File : requests_blog.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import requests</p><p>request = requests.Session() # 初始化Session</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login' # 登录接口地址</p><p>login_data = {"mobilephone": "13691579841", "pwd": 123456} # 接口所需参数</p><p>response_login = request.request(method='post', url=login_url, data=login_data) # 发送post请求 登录</p><p>print(response_login.text)</p><p>recharge_url = r'http://***:8080/futureloan/mvc/api/member/recharge' # 充值接口地址</p><p>recharge_data = {"mobilephone": "13691579841", "amount": 10000.00} # 接口所需参数</p><p>response_recharge = request.request(method='post', url=recharge_url, data=recharge_data) # 发送请求，开始充值</p><p>print(response_recharge.text)</p><p>执行结果</p><p>{"status":1,"code":"10001","data":null,"msg":"登录成功"}</p><p>{"status":1,"code":"10001","data":</p><p>{"id":5451,"regname":"test","pwd":"E10ADC3949BA59ABBE56E057F20F883E","mobilephone":"13691579841","leaveamount":"15000.00","type":"1","regtime":"2019-05-26 19:08:44.0"},</p><p>"msg":"充值成功"}</p><p>Process finished with exit code 0</p><p>可以发现，我们改用Session对象来发送充值请求就成功了。那这是什么原因呢？</p><p>简单来说，当我们第一次请求服务器时，获取的响应信息会包含一个set-cookie的字段，保存了我们登录的cookies信息，如果我们想保持这个状态，那么再次访问服务器时就需要带上这个cookies传递给服务器，才能保持这个状态。</p><p>那么我们使用Session对象发送请求时，Session会自动帮我们完成上述的过程，Session会自动把cookies的信息传递给服务器，而无需我们在请求参数中手动添加cookies，这样就保持了登录的状态，后续的依赖操作都可以正常执行了。</p><p><strong>reqests简单封装</strong></p><p>有人会问，requests库已经封装的很好了，直接用就行了，为啥还要自己封装一次？</p><p><strong>第一.</strong>通过封装，我可以直接把所有的请求参数统一使用字典来传递　<strong>　</strong></p><p>比如，我们接口请求需要的数据也就是测试数据往往会保存在excel表里面，那么我们取到后是字符串类型，字符串是无法作为请求参数传递的，所以我每次都要做数据转换，再传递给接口，为了节省这个过程，我只需要把这个过程封装到我的requests里即可，每次取数据后自动给我处理。</p><p><strong>第二.</strong>当我想保持某个状态时，不想每次都初始化一个Session对象，那么我可以把它封装到我的requests里面，以后直接调用即可。</p><p>下面来看封装的代码</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 16:14</p><p>@Auth : linux超</p><p>@File : sendrequests.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>import json</p><p>import requests</p><p>class HttpRequests(object):</p><p>"""</p><p>eg: request = HttpRequests()</p><p>response = request(method, url, data)</p><p>or</p><p>response = request.send_request(method, url, data)</p><p>print(response.text)</p><p>"""</p><p>def __init__(self):</p><p>self.session = requests.Session()</p><p>def send_request(self, method, url, params_type='form', data=None, **kwargs):</p><p>method = method.upper()</p><p>params_type = params_type.upper()</p><p>if isinstance(data, str):</p><p>try:</p><p>data = json.loads(data)</p><p>except Exception:</p><p>data = eval(data)</p><p>if 'GET' == method:</p><p>response = self.session.request(method=method, url=url, params=data, **kwargs)</p><p>elif 'POST' == method:</p><p>if params_type == 'FORM': # 发送表单数据，使用data参数传递</p><p>response = self.session.request(method=method, url=url, data=data, **kwargs)</p><p>elif params_type == 'JSON': # 如果接口支持application/json类型，则使用json参数传递</p><p>response = self.session.request(method=method, url=url, json=data, **kwargs)</p><p>else: # 如果接口需要传递其他类型的数据比如 上传文件，调用下面的请求方法</p><p>response = self.session.request(method=method, url=url, **kwargs)</p><p># 如果请求方式非 get 和post 会报错，当然你也可以继续添加其他的请求方法</p><p>else:</p><p>raise ValueError('request method "{}" error ! please check'.format(method))</p><p>return response</p><p>def __call__(self, method, url, params_type='form', data=None, **kwargs):</p><p>return self.send_request(method, url,</p><p>params_type=params_type,</p><p>data=data,</p><p>**kwargs)</p><p>def close_session(self):</p><p>self.session.close()</p><p>try:</p><p>del self.session.cookies['JSESSIONID']</p><p>except:</p><p>Pass</p><p>request = HttpRequests()</p><p>if __name__ == '__main__':</p><p>pass</p><p>这个封装只针对了get请求和post请求，当然你也可以把put，delete等请求添加在32行代码后面，实现更多的请求方式。</p><p>解释一下30-34行代码： 这几行数据是为了把json和字符串类型的数据转换为字典的格式(通过使用字典传递接口参数)且可以处理一些特殊的形式，比如下面这样的格式。</p><p>'{"mobilephone": None, "pwd": null}' # 字符串类型的，但是即不是json形式的字符串，也不是字典类型的字符串，因为字典里面没有null。</p><p><strong>封装测试</strong></p><p>现在我们使用封装好的方法来测试一下发送登录和充值接口的请求</p><p>"""</p><p>------------------------------------</p><p>@Time : 2019/7/12 16:16</p><p>@Auth : linux超</p><p>@File : test_requests.py</p><p>@IDE : PyCharm</p><p>@Motto: Real warriors,dare to face the bleak warning,dare to face the incisive error!</p><p>------------------------------------</p><p>"""</p><p>from sendrequests import request</p><p>import unittest</p><p>class TestRequests(unittest.TestCase):</p><p># 登录接口地址</p><p>login_url = r'http://***:8080/futureloan/mvc/api/member/login'</p><p># 登录接口测试数据</p><p>login_test_value = '{"mobilephone": "13691579841", "pwd": 123456}'</p><p># 充值接口地址</p><p>recharge_url = r'http://***:8080/futureloan/mvc/api/member/recharge'</p><p># 充值接口测试数据</p><p>recharge_test_value = {"mobilephone": "13691579841", "amount": 10000.00}</p><p>def test_login_api(self):</p><p>"""登录接口测试用例"""</p><p>response = request('get', url=self.login_url, data=self.login_test_value)</p><p>self.assertTrue(response.json()["code"] == "10001")</p><p>print("登录接口测试通过")</p><p>def test_recharge_api(self):</p><p>"""充值接口测试用例"""</p><p>response = request('get', url=self.login_url, data=self.login_test_value)</p><p>try:</p><p># 充值接口需要先登录，才能充值</p><p>self.assertTrue(response.json()["code"] == '10001')</p><p>except AssertionError as e:</p><p>print('登录失败!')</p><p>raise e</p><p>else:</p><p>response = request('post', url=self.recharge_url, data=self.recharge_test_value)</p><p>self.assertTrue(response.json()["code"] == "10001")</p><p>print("充值接口测试通过")</p><p>if __name__ == '__main__':</p><p>unittest.main()</p><p>测试结果</p><p>登录接口测试通过</p><p>..</p><p>充值接口测试通过</p><p>----------------------------------------------------------------------</p><p>Ran 2 tests in 0.570s</p><p>OK</p><p>Process finished with exit code 0</p><p>ok，测试代码执行通过，说明我们的封装没有啥问题， 且可以正常发送get和post请求，也可以解决测试数据问题和需要接口依赖的问题。</p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口测试工具requests库原来这么好用 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/cc576679-30ca-477e-b874-61909607c2c5><p class=pgc-img-caption></p></div><p><strong>总结</strong></p><p>最后我们再来总结一下本文涉及到的所有的知识点和你需要掌握的。</p><p>1.requests发送get请求和post请求的方法</p><p>get(url, params=None, **kwargs)</p><p>post(url, data=None, json=None, **kwargs)</p><p>2.parmas参数和data参数的区别</p><p>由于get请求无请求体，post请求有请求体。</p><p>使用params参数时，默认会把参数附加到url后面，所以发送get请求时应使用params参数。</p><p>使用data参数时，参数会存放到请求体中，所以发送post请求时不能使用params，应使用data，除非接口及支持get又支持post，同样get请求也不能使用data参数。</p><p>3.如何使用Seesion解决接口保持状态的问题</p><p>初始化Session实例，通过这个实例调用request()方法发送请求。</p><p>4.最重要的一个封装方法，并掌握这个封装该如何使用</p><p>主要针对get和post请求的接口。</p><p><strong>请关注+私信回复：“学习”就可以免费拿到软件测试学习资料</strong></p><div class=pgc-img><img alt=我也是第一次知道，正流行的接口测试工具requests库原来这么好用 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6a8aceadda87417cb7fc23b33e78c89f><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'测试','requests','库原来'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>