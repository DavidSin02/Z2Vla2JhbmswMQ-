<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MySQL事务隔离级别 | 极客快訊</title><meta property="og:title" content="MySQL事务隔离级别 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a79ba4c0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a79ba4c0.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="MySQL事务隔离级别"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a79ba4c0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MySQL事务隔离级别</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>前言</strong></h1><p>在数据库操作中，人们为了有效保证并发读取数据的正确性，所以提出了事务隔离级别。MySQL的事物隔离级别分为四种：读未提交、读已提交、可重复读、 串行化。在介绍事物隔离级别之前，我们首先介绍一下什么是事物与事物的特性。</p><h1><strong>数据库事物</strong></h1><p class=ql-align-justify><strong>一、事务是什么？</strong></p><p class=ql-align-justify>事务(Transaction)是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作；这些操作作为一个整体一起提交给系统，要么都执行、要么都不执行；事物具有四个特性分别是：原子性、 一致性、隔离性和持续性。这四个特性简称为 ACID 特性。 事务是一组不可再分割的操作集合。使用事务的好处非常明显，例如：用户想要从银行卡A转1000块钱到银行卡B。这个过程看似简单，实际上涉及了一系列的数据库操作，我们可以简单地视为两步基本操作，第一步从银行卡A帐户的金额中扣除1000元，第二步将银行卡B帐户中金额添加1000元。假设第一步数据库操作成功，在第二步在操作的过程中停电了，这就会导致卡A中的金额减少了1000元，但是卡B中的金额却不会增加，1000块钱就这样无故的“蒸发”了，这是用户不能接受的。但是使用事务机制就可以避免此类情况，以保证整个操作的完成，如果某步操作出错，之前所作的数据库操作将全部回退。</p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>二、事务的四大特性</strong></p><p class=ql-align-justify><strong>原子性（ATOMICITY）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会执行到中间某个步骤停止的。事务在执行过程中如果发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p class=ql-align-justify><strong>一致性（CONSISTENCY）</strong>：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入或更新的数据必须完全符合所有的预设规则，这包含数据的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p><p class=ql-align-justify><strong>隔离性（ISOLATION）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据不一致的问题。</p><p class=ql-align-justify><strong>持久性（DURABILITY）</strong>：又称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障都不会对其执行结果有任何影响。</p><p class=ql-align-justify><br></p><h1><strong>MySQL事务隔离级别</strong></h1><p>以上介绍完事务的四大特性(简称ACID)，现在重点来说明下事务的隔离性，当多个线程都开启事务操作数据库中的数据时，数据库系统要能进行隔离操作，以保证各个线程获取数据的准确性。MySQL事务隔离级别分为四种，包括读未提交、读已提交、可重复读、串行化。</p><p class=ql-align-justify><strong>1、读未提交（Read Uncommitted）</strong></p><p class=ql-align-justify><strong>在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。读未提交我们也称之为脏读</strong>，是指事务A读取了事务B未提交的数据。如果事务B又回滚了，则A读取到的数据就是脏数据。下面我们通过例子来看一下什么是脏读。</p><p class=ql-align-justify><strong>例：</strong></p><p class=ql-align-justify>想要验证数据库脏读的情况，就需要先设置数据库事物为非自动提交和数据库隔离级别为读未提交。首先我们要知道在MySQL命令行的默认设置下，事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如下图我们可以使用<strong> show variables like 'autocommit';</strong> 语句查询数据库是否是自动提交事务；如图1.1，ON表示开启自动提交事务。</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c><p class=pgc-img-caption>图1.1</p></div><p class=ql-align-justify>因此如果想要显示的开启一个事务并手动提交则需要把自动提交数据关闭。我们可以使用<strong> Set global autocommit = 0;</strong> 语句关闭数据库自动提交事务。如图1.2：</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a18b2097f58402ea7c7cfa64b91f097><p class=pgc-img-caption>图1.2</p></div><p class=ql-align-justify>从上面的执行的过程我们可以看到 Set global autocommit = 0 语句执行完之后查询的autocommit属性的值还是ON，因为我们设置的全局变量autocommit还没有生效，这时候我们关闭当前的客户端，重新打开就可以查询到autocommit为OFF了。如1.3我们可以看到autocommit的值已经设置成OFF，表示数据库自动提交事务已经关闭。</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/06017e46834e4412b644334db9c7a86a><p class=pgc-img-caption>图1.3</p></div><p class=ql-align-center>将数据库事务自动提交关闭之后，我们还要将数据库的隔离级别设置为<strong>读未提交</strong>，因为MySQL默认的数据库隔离级别是<strong>可重复读（Repeatable-read）</strong>，我们可以使用<strong>Select @@tx_isolation;</strong>语句查询数据库当前的数据库隔离级别。如图1.4。</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf38a49423cb422e8020b55ea1efe3a5><p class=pgc-img-caption>图1.4</p></div><p class=ql-align-justify>并通过<strong>Set global transaction isolation level read uncommitted;</strong>语句更新数据库的隔离级别，如图1.5。</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1e8504f6dd544c77bdce0e37d8aa6a42><p class=pgc-img-caption>图1.5</p></div><p class=ql-align-justify>以上是我们的准备工作，下面我们就通过一个具体的例子来看一下什么是读未提交（脏读）：</p><p class=ql-align-justify>首先我们打开客户端A，如图1.6中我们可以看到，三次查询的结果，第二次与第一次的不同，因为我们在第一次查询与第二次查询之间在另一个MySQL客户端B更新了张三的年龄为17，如图1.7，所以第二次查询的结果张三的年龄为17，之后我们并没有提交这个事务，而是把事务回滚了，所以我们第三次查询的结果张三的年龄又变成了16。所以我们第二次查询的张三的年龄为17错误的数据，即为脏读。</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/00d395480fad4688bf98564ea68613f2><p class=pgc-img-caption>客户端A 如图1.6</p></div><p class=ql-align-center><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a66cc201e932467dad596a005d559410><p class=pgc-img-caption>客户端B 图1.7</p></div><p class=ql-align-justify><strong>2、读已提交（Read Committed）</strong></p><p class=ql-align-justify><strong>读已提交是指一个事务只能看见已经提交事务所做的改变。该隔离级别可称为不可重复读（Nonrepeatable Read）</strong>，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。</p><p class=ql-align-justify><strong>例：</strong></p><p class=ql-align-justify>假设当前数据库已关闭数据库自动提交事务，且当前事务隔离级别是读已提交。如图1.8在客户端A的第一次与第二次查询过程中，我们在另一个客户端B(如图1.9)中更新了张三的年龄为20，但是因为没有提交事务，所以我们查询到的还是16。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5c41f57bff0f45ee9dd3261e0b234b13><p class=pgc-img-caption>客户端A 图1.8</p></div><p class=ql-align-justify><br></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/82fef2a8d05345c1a5ad4b4dc1b6946c><p class=pgc-img-caption>客户端B 图1.9</p></div><p class=ql-align-justify>之后我们把客户端B中更新张三年龄为20的事务提交，如图2.0，然后在客户端A中查询张三的年龄为20，如图2.1。从这个例子中我们可以看出，一个事务只能看见已经提交事务所做的改变，所以就避免了脏读。但是我们又会发现一个新的问题，如图2.1，<strong>我们在一个事务中查询张三的年龄，但是两次的查询结果却不同（前两次查询的年龄为16，第三次查询为20）。这就是不可重复读。</strong></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/865db58dcab142b5a498a157363a01dc><p class=pgc-img-caption>客户端B 图2.0</p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/39cc024d780541578863496d95ed3e6d><p class=pgc-img-caption>客户端A 图2.1</p></div><p class=ql-align-justify><strong>三、可重复读（Repeatable-Read）</strong></p><p class=ql-align-justify>我们把数据库的隔离级别设置为可重复读即可解决上述的不可重复读的问题；</p><p class=ql-align-justify><strong>例：</strong></p><p class=ql-align-justify>假设当前数据库已关闭数据库自动提交事务，且当前事务隔离级别是可重复读。如图2.2在客户端A中的第一次与第二次查询之间通过另一个客户端B(如图2.3)更新了张三的年纪，但是两次的查询结果确实相同的，这样就避免了不可重复读的问题。</p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9cda32fe4b1482587f77371dba947b9><p class=pgc-img-caption>客户端A 图2.2</p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/985d2ad3a0cc4e37953b913f0a4629c6><p class=pgc-img-caption>客户端B 图2.3</p></div><p class=ql-align-justify>然后我们在客户端A中将张三的年纪加10，如图2.4，然后查询到的张三的年纪为40，这说明在客户B中将张三的年纪更新为30的语句已经生效了。由此可以看出</p><p class=ql-align-justify>数据的一致性是没有被破坏，且避免了脏读与不可重复读的问题。<strong>可重复读是MySQL默认的隔离级别，也是我们最常用的隔离级别。</strong></p><div class=pgc-img><img alt=MySQL事务隔离级别 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e2312d1dfd349008ed3f4c1e3e01312><p class=pgc-img-caption>客户端A 图2.4</p></div><p class=ql-align-justify><strong>4、串行化（Seriallzable）</strong></p><p class=ql-align-justify>串行化隔离级别也可以完全避免脏读和可重复读且能保证数据库的一致性，但是如果数据库使用了可串行化隔离级别时，在一个事务没有被提交之前其他的线程，只能等到当前操作完成之后，才能进行其他操作。因为事务隔离级别为串行化时，读写数据都会锁住整张表， 这样会非常耗时，而且影响数据库的性能，通常情况下，一般不会使用这种隔离级别。</p><p class=ql-align-justify>假设当前数据库已关闭数据库自动提交事务，且当前事务隔离级别是串行化，在客户端A中开启一个事物查询用户信息，之后在客户端B中插入用户信息会抛出异常。提示ERROR <strong>1205</strong> (HY000): Lock wait timeout exceeded; try restarting transaction错误。 因为客户端A中的事物获取了表锁，所以客户端B中的事物获取不到锁。</p><p class=ql-align-justify>总的来说，数据库隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。</p><p class=ql-align-center><strong>更多文章可关注微信公众号：IT鸡窝</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'MySQL','事务隔','离级别'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>