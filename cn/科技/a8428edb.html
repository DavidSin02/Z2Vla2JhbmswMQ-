<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>区块链相关算法总结 | 极客快訊</title><meta property="og:title" content="区块链相关算法总结 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a995b7f6e492417a96648cdbd04265dd"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a8428edb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a8428edb.html><meta property="article:published_time" content="2020-10-29T21:12:22+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:22+08:00"><meta name=Keywords content><meta name=description content="区块链相关算法总结"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a8428edb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>区块链相关算法总结</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>本文总结了区块链常用算法，帮助更多有志研究区块链技术的大牛们更好的理解区块链技术。希望各位小伙伴多多点赞~欢迎交流~</p><div class=pgc-img><img alt=区块链相关算法总结 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a995b7f6e492417a96648cdbd04265dd><p class=pgc-img-caption></p></div><p class=ql-align-center>区块链</p><p><strong>目录</strong></p><p><strong>共识算法</strong></p><p>1 POW（工作量证明算法）</p><p>1.1算法过程</p><p>1.2 优缺点</p><p>2 PoS（股权证明算法）</p><p>2.1算法过程</p><p>2.2 优缺点</p><p>3 DPOS（委托权益证明算法）</p><p>3.1算法过程</p><p>3.2 优缺点</p><p>4 PBFT（实用拜占庭容错算法）</p><p>4.1算法过程</p><p>4.2 优缺点</p><p>5 PAXOS</p><p>5.1算法过程</p><p>5.2 优缺点</p><p>6 Raft</p><p>6.1算法过程</p><p>6.2 优缺点</p><p><strong>加密算法</strong></p><p>1 对称加密算法</p><p>2 非对称加密算法</p><p>3 混合加密机制</p><p><strong>哈希算法</strong></p><p>1 SHA256</p><p>2 RIPEMD-160. 11</p><div class=pgc-img><img alt=区块链相关算法总结 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/10eed4ee95b648e789122ae5fd870ffd><p class=pgc-img-caption></p></div><p class=ql-align-center>区块链的大同世界</p><p><strong>共识算法</strong></p><p><strong>1 POW（工作量证明算法）</strong></p><p><strong>1.1算法过程</strong></p><p>工作量证明（ PoW ）通过计算一个数值（ nonce ），使得拼揍上交易数据后内容的 Hash值满足规定的上限。在节点成功找到满足的target值之后，会马上对全网进行广播打包区块，网络的节点收到广播打包区块，会立刻对其进行验证。所需的前导0的数量称为难度值（difficulty）。nonce 值会一直迭代，直到target值有效为止。找到nonce 值以满足合适条件的target值的过程就叫做挖矿。</p><ul><li>target =Hash( index, previous block hash, timestamp, block data , nonce ) //target值的计算公式</li><li>target &lt;difficulty //成功找到满足条件的target值</li><li>new_ difficulty = prev_ difficulty * 前2015个区块生成所用的时间/ 1209600 （按标准每10分钟出一个块，2016个块所需要的秒数） //difficulty调整公式</li></ul><p>花费的CPU就是工作量证明。要修改一个区块需要重做这个区块以及这个区块之后所有区块的工作量证明。</p><p><strong>1.2 优缺点</strong></p><p>优点：</p><p>1) 完全去中心化，节点自由进出；</p><p>缺点：</p><p>2) 目前bitcoin已经吸引全球大部分的算力，其它再用Pow共识机制的区块链应用很难获得相同的算力来保障自身的安全；挖矿造成大量的资源浪费；共识达成的周期较长，不适合商业应用；</p><p><strong>2 PoS（股权证明算法）</strong></p><p><strong>2.1算法过程</strong></p><p>PoS并不是指某一个算法，而是一类算法，而且，这类算法目前各有优劣。目前为止，没有一个PoS算法的可靠性通过了实践的检验。PoS类似于财产储存在银行，这种模式会根据你持有数字货币的量和时间，分配给你相应的利息。</p><p>简单来说，就是一个根据你持有货币的量和时间，给你发利息的一个制度，在PoS模式下，有一个名词叫币龄，每个币每天产生1币龄，比如你持有100个币，总共持有了30天，那么，此时你的币龄就为3000，这个时候，如果你发现了一个PoS区块，你的币龄就会被清空为0。你每被清空365币龄，你将会从区块中获得0.05个币的利息(假定利息可理解为年利率5%)，那么在这个案例中，利息 = 3000 * 5% / 365 = 0.41个币。</p><p><strong>2.2 优缺点</strong></p><p>优点：</p><p>1) 不需要浪费算力；进行51%攻击的代价更高，因为想要进行51%攻击，需要先拥有51%的货币；</p><p>缺点：</p><p>1) 权益粉碎攻击（nothing-at-the-stake attack），上面有人说POS是社会主义，我是不赞同的。我觉得POS就是完全的资本主义——你钱越多，你拥有的权力就越大。当然，这个也并不是没有道理，因为在其中利益越多的人，就更愿意去维护这个币的系统，于是他们手中的币才能更有价值。因此，他们并不愿意去进行恶意攻击，因为那样实际上他们手中的币也会受害，这就是POS能够更有效地防御51%攻击的原因。换句话说，钱越多责任越大。但反过来讲，钱越少责任越小。假设你只有1%的钱，你成功的概率只有1%，但是你尽可以去尝试分叉，因为这并不消耗任何资源。也就是你在最长链上挖矿的同时，也去创造一个只在自己的区块上挖矿的分支。放在POW里，创建这个分支完全得不偿失因为你浪费了大量的算力。然而在POS里，如果这个分支不被接收，实际上你什么都没损失。于是，即便是诚实的矿工也可能回去偷偷地进行这种分叉尝试。尽管他们知道这种尝试会造成整个币的价值降低，但是他们的钱很少，他们并不在乎，这就是所谓的平凡人悲剧（tragedy of the commons）。对于这种攻击，基本上所有的新的POS算法都有应对的机制，例如以太坊的casper里的slasher，基本概念就是如果有人尝试了这种攻击，其他人发现了可以公布证据然后对这个人进行惩罚；</p><p>2) 理性分叉。权益粉碎攻击是主动的，而这个是被动的——假设有人做了权益粉碎攻击进行了分叉尝试，诚实节点理应不予理会，因为他们能看到这种分叉被接受的机率小。对于PoW来说，你不会在被接收机率小的分叉（例如不是最长链的分叉）上挖矿，因为那样浪费算力。但对于PoS来说，在那上面挖矿没任何损失，反而是不在那上面挖矿，万一这条链被接收了，你就会受到损失。于是，即便是诚实节点，如果它足够理性，那么它也会在所有它收到的链上同时挖矿。PoW里，没人挖的分支很快就会变成孤块被丢弃，但在PoS里，如果整个网络足够理性，会出现的情况反而是每条分支都会永远存在因为理性的矿工会同时在所有分支上挖矿。我觉得这是PoS最大的缺陷，就是如果只用最长链共识的话，PoS本身是没法应对分叉的，必须通过惩罚。而这种惩罚不光是基于作恶，而是违反节点逐利本性的；</p><p><strong>3 DPOS（委托权益证明算法）</strong></p><p><strong>3.1算法过程</strong></p><p>DPoS共识算法，区块链的正常运转依赖于受托人，这些受托人是完全等价的。受托人的职责主要有：</p><p>1) 提供一台服务器节点，保证节点的正常运行；</p><p>2) 节点服务器收集网络里的交易；</p><p>3) 节点验证交易，把交易打包到区块；</p><p>4) 节点广播区块，其他节点验证后把区块添加到自己的数据库；</p><p>5) 带领并促进区块链项目的发展；</p><p>受托人的节点服务器相当于比特币网络里的矿机，在完成本职工作的同时可以领取区块奖励和交易的手续费。</p><p>一个区块链项目的受托人个数由项目发起方决定。任何一个持币用户都可以参与到投票和竞选受托人这两个过程中。用户可以随时投票、撤票，每个用户投票的权重和自己的持币量成正比。投票和撤票可以随时进行，在每一轮选举结束后，得票率最高的21（也可以是其他数字，具体由区块链项目方决定）个用户则成为该项目的受托人，负责打包区块、维持系统的运转并获得相应的奖励。</p><p>选举的根本目的，是通过每个人的投票选举出社区里对项目发展和运行最有利的21个用户。这21个用户的服务器节点既可以高效维护系统的运转，而他们也会贡献自己的能力促进区块链项目的发展，这有点类似于我国的‘人民代表大会’制度（但是周期更短、效率更高）。通过这种方式，既达到了去中心化的选举共识，又保证了整个系统的运行效率和减少能源浪费。</p><p><strong>3.2 优缺点</strong></p><p>优点：</p><p>1) 能耗更低：DPoS机制将节点数量进一步减少，在保证网络安全的前提下，整个网络的能耗进一步降低，网络运行成本更低；</p><p>2) 更快的确认速度：每个区块的时间为10秒，一笔交易（在得到6-10个确认后）大概1分钟，一个完整的区块的周期大概仅仅需要数分钟。</p><p>缺点：</p><p>1) 投票的积极性不高：绝大多数持股人从未参与投票。这是因为投票需要时间、精力以及技能，而这恰恰是大多数投资者所缺乏的；</p><p>2) 垄断性高：PoW下几乎没有门槛，任何人都可以投入算力，通过竞争获得区块奖励。而DPoS延续了PoS的弊端，只有持币者才可以获得区块链奖励，其实这就带来了一种制度性门槛，最终导致DPoS币的流动性大大减少，穷者越穷，富者越富；</p><p>3) 整个共识机制还是依赖于代币，很多商业应用是不需要代币存在的；</p><p><strong>4 PBFT（实用拜占庭容错算法）</strong></p><p><strong>4.1算法过程</strong></p><p>PBFT算法解决的是在网络通信可靠，但节点可能故障情况下如何达成共识的问题。PBFT 算法采用密码学相关技术（RSA 签名算法、消息验证编码和摘要）确保消息传递过程无法被篡改和破坏。算法整体的基本过程如下：</p><p>1) 通过轮换或随机算法选出某个节点为主节点，此后只要主节点不切换，则称为一个视图（View）；</p><p>2) 在某个视图中，客户端将请求 &lt;REQUEST,operation,timestamp,client> 发送给主节点，主节点负责广播请求到所有其它副本节点；</p><p>3) 所有节点处理完成请求，将处理结果 &lt;REPLY,view,timestamp,client,id_node, response> 返回给客户端。客户端检查是否收到了至少 f+1 个来自不同节点的相同结果，作为最终结果；</p><p>主节点广播过程包括三个阶段的处理：预准备（Pre-Prepare）、准备（Prepare） 和 提交（Commit）。预准备和准备阶段确保在同一个视图内请求发送的顺序正确；准备和提交阶段则确保在不同视图之间的确认请求是保序的。</p><p>预准备阶段：主节点为从客户端收到的请求分配提案编号，然后发出预准备消息 &lt;&lt;PRE-PREPARE,view,n,digest>,message> 给各副本节点，其中 message 是客户端的请求消息，digest 是消息的摘要。</p><p>准备阶段：副本节点收到预准备消息后，检查消息。如消息合法，则向其它节点发送准备消息 &lt;PREPARE,view,n,digest,id>，带上自己的 id 信息，同时接收来自其它节点的准备消息。收到准备消息的节点对消息同样进行合法性检查。验证通过则把这个准备消息写入消息日志中。集齐至少 2f+1 个验证过的消息才进入准备状态。</p><p>提交阶段：广播 commit 消息，告诉其它节点某个提案 n 在视图 v 里已经处于准备状态。如果集齐至少 2f+1 个验证过的 commit 消息，则说明提案通过。</p><p><strong>4.2 优缺点</strong></p><p>优点：</p><p>1) 系统运转可以脱离币的存在，pbft算法共识各节点由业务的参与方或者监管方组成，安全性与稳定性由业务相关方保证；</p><p>2) 共识的时延大约在2~5秒钟，基本达到商用实时处理的要求；</p><p>缺点：</p><p>1) 当有1/3或以上记账人停止工作后，系统将无法提供服务；</p><p>2) 当有1/3或以上记账人联合作恶，且其它所有的记账人被恰好分割为两个网络孤岛时，恶意记账人可以使系统出现分叉，但是会留下密码学证据；</p><p><strong>5 PAXOS</strong></p><p><strong>5.1算法过程</strong></p><p>1990 年由 Leslie Lamport 在论文《The Part-time Parliament》中提出的 Paxos 共识算法，在工程角度实现了一种最大化保障分布式系统一致性（存在极小的概率无法实现一致）的机制。</p><p>算法中存在三种逻辑角色的节点，在实现中同一节点可以担任多个角色。</p><p>1) 提案者（Proposer）：提出一个提案，等待大家批准为结案。系统中提案都拥有一个自增的唯一提案号。往往由客户端担任该角色；</p><p>2) 接受者（Acceptor）：负责对提案进行投票，接受提案。往往由服务端担任该角色；</p><p>3) 学习者（Learner）：获取批准结果，并帮忙传播，不参与投票过程。可为客户端或服务端；</p><p>Paxos 算法主要有分为准备（Prepare）和提交（Commit）阶段。准备阶段通过锁来解决对哪个提案内容进行确认的问题，提交阶段解决大多数确认最终值的问题。</p><p>1) 准备阶段：提案者发送自己计划提交的提案的编号到多个接受者，试探是否可以锁定多数接受者的支持。接受者时刻保留收到过提案的最大编号和接受的最大提案。如果收到提案号比目前保留的最大提案号还大，则返回自己已接受的提案值（如果还未接受过任何提案，则为空）给提案者，更新当前最大提案号，并说明不再接受小于最大提案号的提案。</p><p>2) 提交阶段：提案者如果收到大多数的回复（表示大部分人听到它的请求），则可准备发出带有刚才提案号的接受消息。如果收到的回复中不带有新的提案，说明锁定成功。则使用自己的提案内容；如果返回中有提案内容，则替换提案值为返回中编号最大的提案值。如果没收到足够多的回复，则需要再次发出请求。接受者收到接受消息后，如果发现提案号不小于已接受的最大提案号，则接受该提案，并更新接受的最大提案。一旦多数接受者接受了共同的提案值，则形成决议，成为最终确认。</p><p><strong>5.2 优缺点</strong></p><p>优点：</p><p>1) paxos可以在节点失效、网络分区、网络延迟等各种异常情况下保证所有节点都处于同一状态；</p><p>缺点：</p><p>1) 算法难以理解；</p><p>2) 算法工程实现困难；</p><p><strong>6 Raft</strong></p><p><strong>6.1算法过程</strong></p><p>Raft 算法由斯坦福大学的 Diego Ongaro 和 John Ousterhout 于 2014 年在论文《In Search of an Understandable Consensus Algorithm》中提出。Raft算法面向多个决策达成一致的问题，分解了领导者选举、日志复制和安全方面的考虑，并通过约束减少了不确定性的状态空间。</p><p>算法包括三种角色：领导者（Leader）、候选者（Candidate）和跟随者（Follower），决策前通过选举一个全局的领导者来简化后续的决策过程。领导者角色十分关键，决定日志（log）的提交。日志只能由领导者向跟随者单向复制。典型的过程包括两个主要阶段：</p><p>1) 领导者选举：开始所有节点都是跟随者，在随机超时发生后未收到来自领导者或候选者消息，则转变角色为候选者，提出选举请求。最近选举阶段（Term）中得票超过一半者被选为领导者；如果未选出，随机超时后进入新的阶段重试。领导者负责从客户端接收 log，并分发到其他节点；</p><p>2) 同步日志：领导者会找到系统中日志最新的记录，并强制所有的跟随者来刷新到这个记录，数据的同步是单向的；</p><p><strong>6.2 优缺点</strong></p><p>优点：</p><p>1) 容易理解，且节点间通信次数比较少；</p><p>缺点：</p><p>1) 如果主节点为作恶节点，无法检查出来；</p><p><strong>加密算法</strong></p><p>根据加解密过程中所使用的密钥是否相同，加密算法可以分为对称加密（Symmetric Cryptography）和非对称加密（Asymmetric Cryptography）。两种模式适用于不同的需求，形成互补。某些场景下可以组合使用，形成混合加密机制。</p><p><strong>1 对称加密算法</strong></p><p>对称加密算法，加密和解密过程的密钥是相同的。该类算法优点是加解密效率（速度快，空间占用小）和加密强度都很高。缺点是参与方需要提前持有密钥，一旦有人泄露则系统安全性被破坏；另外如何在不安全通道中提前分发密钥也是个问题，需要借助额外的 Diffie–Hellman 协商协议或非对称加密算法来实现。对称加密算法适用于大量数据的加解密过程；不能用于签名场景；并且需要提前安全地分发密钥。</p><p>对称加密算法从实现原理上可以分为两种：分组密码和序列密码。前者将明文切分为定长数据块作为基本加密单位，应用最为广泛。后者则每次只对一个字节或字符进行加密处理，且密码不断变化，只用在一些特定领域（如数字媒介的加密）。</p><p>分组对称加密代表算法包括 DES、3DES、AES、IDEA 等。</p><p>2) DES（Data Encryption Standard）：经典的分组加密算法，最早为1977 年美国联邦信息处理标准（FIPS）采用，将64位明文加密为64位的密文。其密钥长度为64位（包括8位校验码），现在已经很容易被暴力破解；</p><p>3) 3DES：三重DES操作：加密 --> 解密 --> 加密，处理过程和加密强度优于DES，但现在也被认为不够安全；</p><p>4) AES（Advanced Encryption Standard）：由美国国家标准研究所（NIST）采用，取代DES成为对称加密实现的标准，1997~2000年NIST从15个候选算法中评选出Rijndael算法（由比利时密码学家 Joan Daemon 和 Vincent Rijmen 发明）作为 AES。AES也是分组算法，分组长度为128、192、256位三种。AES的优势在于处理速度快，整个过程可以数学化描述，目前尚未有有效的破解手段；</p><p>5) IDEA（International Data Encryption Algorithm）：1991年由密码学家James Massey与来学嘉共同提出。设计类似于3DES，密钥长度增加到128位，具有更好的加密强度。</p><p>序列加密算法，又称流加密。1949 年，Claude Elwood Shannon（信息论创始人）首次证明，要实现绝对安全的完善保密性（Perfect Secrecy），可以通过“一次性密码本”的对称加密处理。即通信双方每次使用跟明文等长的随机密钥串对明文进行加密处理。序列密码采用了类似的思想，每次通过伪随机数生成器来生成伪随机密钥串。代表算法包括RC4等。</p><p><strong>2 非对称加密算法</strong></p><p>非对称加密算法有效解决了对称加密需要安全分发密钥的问题。非对称加密中，加密密钥和解密密钥是不同的，分别被称为公钥（Public Key）和私钥（Private Key）。私钥一般通过随机数算法生成，公钥可以根据私钥生成。其中，公钥一般是公开的，他人可获取的；私钥则是个人持有并且要严密保护，不能被他人获取。</p><p>非对称加密算法优点是公私钥分开，无需安全通道来分发密钥。缺点是处理速度（特别是生成密钥和解密过程）往往比较慢，一般比对称加解密算法慢 2~3 个数量级；同时加密强度也往往不如对称加密。</p><p>非对称加密算法的安全性基于数学问题，包括大数质因子分解、离散对数、椭圆曲线等经典数学难题。代表算法包括：RSA、ElGamal、椭圆曲线（ECC）、SM2等系列算法。</p><p>1) RSA：经典的公钥算法，1978 年由 Ron Rivest、Adi Shamir、Leonard Adleman 共同提出，三人于 2002 年因此获得图灵奖。算法利用了对大数进行质因子分解困难的特性，但目前还没有数学证明两者难度等价，或许存在未知算法可以绕过大数分解而进行解密。</p><p>2) ElGamal：由 Taher ElGamal 设计，利用了模运算下求离散对数困难的特性，比 RSA 产生密钥更快。被应用在 PGP 等安全工具中。</p><p>3) 椭圆曲线算法（Elliptic Curve Cryptography，ECC）：现代备受关注的算法系列，基于对椭圆曲线上特定点进行特殊乘法逆运算难以计算的特性。最早在 1985 年由 Neal Koblitz 和 Victor Miller 分别独立提出。ECC 系列算法一般被认为具备较高的安全性，但加解密过程比较费时。</p><p>4) SM2（ShangMi 2）：中国国家商用密码系列算法标准，由中国密码管理局于 2010 年 12 月 17 日发布，同样基于椭圆曲线算法，一般认为其安全强度优于RSA系列算法。</p><p>非对称加密算法适用于签名场景或密钥协商过程，但不适于大量数据的加解密。</p><p><strong>3 混合加密机制</strong></p><p>混合加密机制同时结合了对称加密和非对称加密的优点。该机制的主要过程为：先用非对称加密（计算复杂度较高）协商出一个临时的对称加密密钥（或称会话密钥），然后双方再通过对称加密算法（计算复杂度较低）对所传递的大量数据进行快速的加密处理。</p><p>典型的应用案例是网站中使用越来越普遍的通信协议 -- 安全超文本传输协议（Hyper Text Transfer Protocol Secure，HTTPS）。与以明文方式传输数据的 HTTP 协议不同，HTTPS 在传统的 HTTP 层和 TCP 层之间引入 Transport Layer Security/Secure Socket Layer（TLS/SSL）加密层来实现安全传输。</p><p><strong>哈希算法</strong></p><p>Hash（哈希或散列）算法，又常被称为指纹（fingerprint）或摘要（digest）算法，是非常基础也非常重要的一类算法。可以将任意长度的二进制明文串映射为较短的（通常是固定长度的）二进制串（Hash 值），并且不同的明文很难映射为相同的 Hash 值。</p><p>一个优秀的 Hash 算法，将能满足：</p><p>1) 正向快速：给定原文和 Hash 算法，在有限时间和有限资源内能计算得到 Hash 值；</p><p>2) 逆向困难：给定（若干）Hash 值，在有限时间内无法（基本不可能）逆推出原文；</p><p>3) 输入敏感：原始输入信息发生任何改变，新产生的 Hash 值都应该发生很大变化；</p><p>4) 碰撞避免：很难找到两段内容不同的明文，使得它们的 Hash 值一致（即发生碰撞）；</p><p>目前常见的 Hash 算法包括国际上的 Message Digest（MD）系列和 Secure Hash Algorithm（SHA）系列算法，以及国内的 SM3 算法。</p><p>1) MD 算法主要包括MD4和MD5两个算法。MD4（RFC 1320）是MIT的Ronald L. Rivest 在 1990 年设计的，其输出为128位。MD4 已证明不够安全。MD5（RFC 1321）是 Rivest于1991年对MD4的改进版本。它对输入仍以512位进行分组，其输出是128位。MD5比MD4更加安全，但过程更加复杂，计算速度要慢一点。MD5已于2004年被成功碰撞，其安全性已不足应用于商业场景；</p><p>2) SHA 算法由美国国家标准与技术院（National Institute of Standards and Technology，NIST）征集制定。首个实现SHA-0算法于1993年问世，1998年即遭破解。随后的修订版本SHA-1算法在 1995年面世，它的输出为长度160位，安全性更好。SHA-1设计采用了 MD4算法类似原理。SHA-1已于2005年被成功碰撞，意味着无法满足商用需求。为了提高安全性，NIST后来制定出更安全的SHA-224、SHA-256、SHA-384和SHA-512算法（统称为SHA-2算法）。新一代的SHA-3相关算法也正在研究中；</p><p>3) SM3算法始于中国密码管理局2010年12月17日发布的GM/T 0004-2012《SM3 密码杂凑算法》，建立了国内商用密码体系中的公开Hash算法标准，已经被广泛应用在数字签名和认证等场景中。</p><p>大多数 Hash 算法都是计算敏感型算法，在强大的计算芯片上完成的更快。因此要提升 Hash计算的性能可以考虑硬件加速，例如采用普通FPGA来计算SHA-256值，可以轻易达到数Gbps的吞吐量，使用专用芯片甚至会更高；也有一些Hash算法不是计算敏感型的。例如 scrypt算法，计算过程需要大量的内存资源，因此很难通过选用高性能芯片来加速Hash计算。这样的算法可以有效防范采用专用芯片进行算力攻击。</p><p><strong>1 SHA256</strong></p><p>SHA256是构造区块链所用的主要密码哈希函数。无论是区块的头部信息还是交易数据，都使用这个哈希函数去计算相关数据的哈希值，以保证数据的完整性。同时，在比特币系统中，基于寻找给定前缀的SHA256哈希值，设计了工作量证明的共识机制；SHA256也被用于构造比特币地址，即用来识别不同的用户。对于任意长度（按bit计算）的消息，SHA256都会产生一个32个字节长度数据，称作消息摘要。当接收到消息的时候，这个消息摘要可以用来验证数据是否发生改变，即验证其完整性。</p><p><strong>2 RIPEMD-160</strong></p><p>RIPEMD（RACE Integrity Primitives Evaluation Message Digest），即RACE原始完整性校验消息摘要。RIPEMD使用MD4的设计原理，并针对MD4的算法缺陷进行改进。</p><p>RIPEMD-160使用160位的缓存区来存放算法的中间结果和最终的Hash值。算法的核心是一个有10个循环的压缩函数模块，其中每个循环由16个处理步骤组成。在每个循环中使用不同的原始逻辑函数，算法的处理分为两种不同的情况，在这两种情况下，分别以相反的顺序使用5个原始逻辑函数。每一个循环都以当前分组的消息字和160位的缓存值A、B、C、D、E为输入得到新的值。每个循环使用一个额外的常数，在最后一个循环结束后，两种情况的计算结果A、B、C、D、E和A′、B′、C′、D′、E′及链接变量的初始值经过一次相加运算产生最终的输出。对所有的512位的分组处理完成之后，最终产生的160位输出即为消息摘要。</p><p>除了128位和160位的版本之外，RIPEMD算法也存在256位和320位的版本，它们共同构成RIPEMD家族的四个成员：RIPEMD-128、RIPEMD-160、RIPEMD-256、RIPEMD-320。其中128位版本的安全性已经受到质疑，256位和320位版本减少了意外碰撞的可能性，但是相比于RIPEMD-128和RIPEMD-160，它们不具有较高水平的安全性，因为他们只是在128位和160位的基础上，修改了初始参数和s-box来达到输出为256位和320位的目的。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'区块','相关','总结'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>