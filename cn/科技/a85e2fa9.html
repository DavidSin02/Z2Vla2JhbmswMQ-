<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 | 极客快訊</title><meta property="og:title" content="数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a85e2fa9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a85e2fa9.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a85e2fa9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>上篇<a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6868556093346447880/?group_id=6868556093346447880" rel="noopener noreferrer" target=_blank>数据结构系列：树？二叉树？有一说一，这俩货你不会真的不行</a> ，我们简单的分享了树结构的一般特点和二叉树结构相关的特性和实现，本篇将基于二叉树分享相关的遍历方法(前序，中序，后序，层序)，以及部分应用的算法。</p></blockquote><p><br></p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17><p class=pgc-img-caption></p></div><h1 class=pgc-h-decimal data-index=01>了解二叉树的遍历</h1><p>我们知道，线性表的遍历，我们可以通过for循环或者迭代器。而树的遍历，明显不太可能以相同的方式进行，毕竟<strong>树结构抽象的是层级结构</strong>。</p><p>二叉树的遍历从宏观的大角度看，分为<strong>深度优先遍历</strong>(前序，中序，后序)，<strong>广度优先遍历</strong>(层级)，如图</p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9d7cf83424af4230a508292f4ceebbe3><p class=pgc-img-caption></p></div><p>概括地说：<strong>深度优先遍历主要包括前序遍历，中序遍历，以及后序遍历，广度优先遍历主要是指层级遍历</strong>(每遍历完整层再遍历下一层，这里都是以从左往右的顺序进行元素的遍历)。</p><p>对于3种深度优先遍历来讲，最简单的理解方法就是：<strong>将当前节点，当前节点的父节点，当前节点的子节点当作一个整体看，分别判断左中右的顺序</strong>，这样其实就很好理解。</p><p>比如说：中序遍历（左中右的顺序），也就是<strong>先从最左边的最左节点开始，然后此子树的中间节点（当前树的根节点），然后此子树的右节点，此时这棵左子树已经遍历完成，把当前遍历完成的左子树看作一个整体，找到这棵树是哪个节点的左子节点，然后遍历此左子节点的中间节点</strong>，以此类推。</p><p>下面分享这几种不同的遍历方法及实现</p><h1 class=pgc-h-decimal data-index=02>前序遍历(根->左->右)</h1><p><strong>前序理解</strong></p><p>若二叉树为空，则直接返回；否则按照根节点，然后左子树，右子树的顺序依次访问(解释：每访问一个节点，就把当前节点当作根节点，然后找左右子节点，如果有左节点，则把左节点当作当前树的根结点，继续找左右子节点……)</p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/759ee72bf4fa40e989f711b89856d488><p class=pgc-img-caption></p></div><p><strong>前序实现</strong></p><pre><code># 递归实现def pre_order(tree):    if tree:        print(tree.get_root())        pre_order(tree.get_left_child())        pre_order(tree.get_right_child())        # 利用栈的思想def pre_order(tree_node):    s = Stack()    while tree_node or (not s.is_empty):        while tree_node != None:            print(tree_node.get_root())            s.push(tree_node)            tree_node = tree_node.get_left_child()        if not s.is_empty():            tree_node = s.pop()            tree_node = tree_node.get_right_child()</code></pre><h1 class=pgc-h-decimal data-index=03>中序遍历(左->根->右)</h1><p><strong>中序理解</strong></p><p>树为空，直接返回；否则就从根节点开始(但并不是以根节点开始访问)，找到最最最左子节点开始，然后当前左子节点的父节点，然后右节点，结果如下</p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc6b569dc9654472bd51007d863e252d><p class=pgc-img-caption></p></div><p><strong>中序实现(基于递归)</strong></p><pre><code>def in_order(tree):    if tree != None:        in_order(tree.get_left_child())        print(tree.get_root())        in_order(tree.get_right_child())</code></pre><h1 class=pgc-h-decimal data-index=04>后序遍历</h1><p><strong>后序理解</strong></p><p>若树为空，则直接返回；否则先遍历左子树，然后右子树，最后访问根节点，结果如下</p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbb2e001e133460fb99e66c2ffa2fa65><p class=pgc-img-caption></p></div><p><strong>后序</strong><strong>实现(基于递归)</strong></p><pre><code>def post_order(tree):    if tree != None:    	post_order(tree.get_left_child())        post_order(tree.get_right_child())        print(tree.get_root())</code></pre><h1 class=pgc-h-decimal data-index=05>层序遍历</h1><p><strong>层序理解</strong></p><p>这个最简单：从每一层开始，按照从左往右的顺序遍历结点</p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddc21e81c3fd46a0860debd6cc03a9df><p class=pgc-img-caption></p></div><p><strong>层序实现</strong></p><pre><code># 利用队列的数据结构def level_order(root):    q = queue()    q.enqueue(root)    while not q.is_empty():        current_root = q.dequeue()        print(current_root.get_root())        if current_root.left_child != None:            q.enqueue(current.left)        if current_root.right_child != None:            q.enqueue(current.right)</code></pre><p>说到这，二叉树的几种遍历就差不多结束了，接下来我们分享几个重要的基于二叉树的应用</p><h1 class=pgc-h-decimal data-index=06>堆(heap)</h1><p><strong>概念</strong></p><p>堆排序是高效排序算法的一个解决方案，它的主要优点是，无论输入数据如何，它的最坏情况运行时间都是O(n*logn)。</p><p>堆排序是优先队列最主要的实现方法</p><p><strong>特点</strong></p><p>有这样一个特点（堆次序）：任何一条路径都是已经排好序的有序数列</p><ul><li><strong>最小堆</strong>: 每个节点的数据项都小于或等于其两个子节点数据，最小的项位于根节点</li></ul><ul><li><strong>最大堆</strong>: 每个节点的数据项都大于等于其两个子节点的数据，最大的项位于根节点</li></ul><p><strong>堆结构一般有如下几个接口</strong></p><blockquote><p>heap.is_empty() - 堆是否为空堆，返回布尔值</p><p>heap.heappush(item) - 增加数据到堆结构</p><p>heap.heappop() - 返回heap最顶部的数据，并删除</p><p>heap.peek() - 返回heap最顶端的项</p></blockquote><p>我们这里都基于数组实现堆结构，因为对于数组(这里引申为python的列表)来讲，在一个列表中，父节点和子节点的索引存在着一定的关系(如果专门保存一个空元素给列表的第一个位置，那么子节点的索引永远等于父节点地板除2的值)</p><div class=pgc-img><img alt=数据结构系列：面试常问的二叉树的遍历和基本应用，不进来看看吗 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/50bedaf8ca7049f1b487a02a459dad98><p class=pgc-img-caption></p></div><p><strong>实现</strong></p><pre><code># 最小堆实现（python标准库也自带heapq模块，这里为自己实现的逻辑）class BinHeap(object):    def __init__(self):        # 这里给一个初始元素占位，是为了下面的计算方便(parent_index = 2 * left_child_index = 2 * right_child_index + 1)        self._heap = [0]        self.current_size = 0    # 有序的添加数据    def heappush(self, data):        self._heap.append(data)        self.current_size += 1        # 避免current_size的变化,用新的变量引用        child_index = self.current_size        while child_index // 2 &gt; 0:            if self._heap[child_index] &lt; self._heap[child_index // 2]:                self._heap[child_index], self._heap[child_index // 2] = self._heap[child_index // 2], self._heap[child_index]            child_index = child_index // 2        # 删除堆中最小元素并返回    def heappop(self):        # 将最小值抛出,并将当前最后的一个值填充给抛出的位置        rm_data = self._heap[1]        self._heap[1] = self._heap[self.current_size]        self.current_size -= 1        self._heap.pop(1)        current_index = 1        while current_index * 2 &lt;= self.current_size:            min_index = self.min_child(current_index)            if self._heap[current_index] &gt; self._heap[min_index]:                self._heap[current_index], self._heap[min_index] = self._heap[min_index], self._heap[current_index]                current_index = min_index        return rm_data    # 辅助函数,帮助pop_data选择子结点的最小索引并返回最小索引    def min_child(self, current_index):        # 如果只有一个子节点的情况，因为是完全二叉树，必然有左子节点的存在        if 2 * current_index + 1 &gt; self.current_size:            return 2 * current_index        if self._heap[2 * current_index] &gt; self._heap[2 * current_index + 1]:            return 2 * current_index + 1        return 2 * current_index</code></pre><h1 class=pgc-h-decimal data-index=07>表达式树</h1><p>表达式树是包含了表达式的运算数和运算符的二叉树。这里主要是<strong>将中缀表达式转换为解析树结构</strong></p><p><strong>大概的思路</strong></p><ol start=1><li>将中缀转换为全括号表达式来进行操作 ，exp: 3+5*3-2 -> ( ( 3 + ( 5 * 3 ) ) - 2 )</li><li>将所有数据存入列表，准备利用栈结构</li><li>从左到右扫描全括号表达式的每个单词</li><li>创建一个空树，当前结点就为根结点</li><li>如果是"("：为当前结点添加一个新的左结点，当前结点下降为这个新结点</li><li>如果是"±*/"，将当前结点的值赋值为此符号，同时为当前结点添加一个新结点作为其右子结点，当前结点下降为这个新结点</li><li>如果当前是操作数，将当前结点的值设为此数，当前结点上升到父结点</li><li>如果当前结点是")"，则当前结点上升到父结点</li></ol><p><strong>具体实现</strong></p><pre><code># 将中缀表达式转换为解析树结构表示def build_parse_tree(tokens):    token_list = tokens.split(" ")    # 栈用来保存当前结点    s = Stack()    # 最开始构建一个空树    root = BinaryTree("")    s.push(root)    current_root = root    for i in token_list():        if i == "(":            current_root.insert_left("")            s.push(current_root)            current_root = current_root.get_left_child()        elif isinstance(i, int):            current_root.set_root(int(i))            parent = s.pop()            current_root = parent        elif i in ["+", "-", "*", "/"]:            current_root.set_root(i)            current_root.insert_right("")            s.push(current_root)            current_root = current_root.get_right_child()        elif i == ")":            current_root = s.pop()        else:            raise ValueError("wrong")    return root</code></pre><p><br></p><blockquote><p>我是一名奋战在编程界的pythoner，工作中既要和数据打交道，也要和erp系统，web网站保持友好的沟通……时不时的会分享一些提高效率的编程小技巧，在实际应用中遇到的问题以及解决方案，或者源码的阅读等等，欢迎大家一起来讨论！如果觉得写得还不错，欢迎关注点赞，谢谢。</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','面试'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>