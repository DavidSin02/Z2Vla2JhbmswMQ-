<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>多线程之ThreadLocal的那些事 | 极客快訊</title><meta property="og:title" content="多线程之ThreadLocal的那些事 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a915e749.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a915e749.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a915e749.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a915e749.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a915e749.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a915e749.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/a915e749.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/a915e749.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="多线程之ThreadLocal的那些事"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/a915e749.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>多线程之ThreadLocal的那些事</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>ThreadLocal我确实从来没用过，前段时间面试官曰：“知道ThreadLocal吗？讲讲你对ThreadLocal的理解”</p><p>懵了，故今天总结一下。</p><p>在多线程环境下，如何防止自己的变量被其它线程篡改？ThreadLocal解决的就是这个问题。</p><p><strong>一、什么是ThreadLocal?</strong></p><p>ThreadLocal实现线程封闭，是Java里一种特殊的变量。</p><p>它是一个线程级别变量，每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了，在并发模式下是绝对安全的变量。</p><p>ThreadLocal提供了线程的局部变量，每个线程都可以通过set()和get()来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，实现了线程的数据隔离。</p><p>一个ThreadLocal在一个线程中是共享的，在不同线程之间又是隔离的（每个线程都只能看到自己线程的值）</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246><p class=pgc-img-caption>ThreadLocal是什么</p></div><p><strong>二、深入解析ThreadLocal类</strong></p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f62cf64de174ff985df0bb7541401ec><p class=pgc-img-caption>ThreadLocal内部结构</p></div><p>1.从上面的结构图，我们可以看到ThreadLocal的核心机制：</p><p>每个Thread线程内部都有一个Map。</p><p>Map里面存储线程本地对象（key）和线程的变量副本（value）</p><p>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。</p><p>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰</p><p>2.了解一下ThreadLocal类提供的几个方法：</p><pre>	public T get() {}	public void set(T value) {}	public void remove() {}	protected T initialValue() {}</pre><p>get()方法用于获取当前线程的副本变量值。</p><p>set()方法用于保存当前线程的副本变量值。</p><p>initialValue()为当前线程初始副本变量值。</p><p>remove()方法移除当前前程的副本变量值。</p><p><strong>get()方法</strong></p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9a12af04e364f52b02d7c2c829df150><p class=pgc-img-caption>get()方法</p></div><p>步骤：</p><p>1>获取当前线程的ThreadLocalMap对象threadLocals</p><p>2>从map中获取线程存储的K-V Entry节点。</p><p>3>从Entry节点获取存储的Value副本值返回。</p><p>4>map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</p><p><strong>set()方法</strong></p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45b2aa032b214d1b924a6fdf826a3006><p class=pgc-img-caption>set()方法</p></div><p>步骤：</p><p>1>获取当前线程的成员变量map</p><p>2>map非空，则重新将ThreadLocal和新的value副本放入到map中。</p><p>3>map空，则对线程的成员变量ThreadLocalMap进行初始化创建，并将ThreadLocal和value副本放入map中。</p><p><strong>remove()方法</strong></p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f71d562563fa49c69b2282d60b36db7f><p class=pgc-img-caption>remove()方法</p></div><p>步骤：</p><p>1>获取当前线程的ThreadLocalMap对象threadLocals</p><p>2>不为空，直接移除掉</p><p><strong>initialValue()方法</strong></p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2e2921f9c644af8854894529bf2db29><p class=pgc-img-caption>initialValue()方法</p></div><p>1>实际就是get()初始化值</p><p>3.ThreadLocalMap</p><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d362ee3fef5642928fa6f12292edddf3><p class=pgc-img-caption>ThreadLocalMap类图</p></div><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a45d3472483346e9b7db3645624c79bd><p class=pgc-img-caption>ThreadLocal对象</p></div><p>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</p><p>ThreadLocalMap的成员变量：</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5e13ffbf962b4c03a8d9589f197fd555><p class=pgc-img-caption>ThreadLocalMap的成员变量</p></div><p>Hash冲突怎么解决</p><p>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p><p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71402fe9aeee4a4e802e9b8244c5db7a><p class=pgc-img-caption>Hash冲突</p></div><p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。</p><p><strong>所以这里引出的良好建议是：每个线程只存一个变量，这样的话所有的线程存放到map中的Key都是相同的ThreadLocal，如果一个线程要保存多个变量，就需要创建多个ThreadLocal，多个ThreadLocal放入Map中时会极大的增加Hash冲突的可能。</strong></p><p>ThreadLocalMap的问题</p><p>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露。</p><p><strong>如何避免泄漏</strong></p><p>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。</p><p>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fed54ee3b97b4784917f9ddc3b8dcfde><p class=pgc-img-caption>remove</p></div><p><strong>三、ThreadLocal原理总结</strong></p><p>每个Thread维护着一个ThreadLocalMap的引用;</p><p>ThreadLocalMap是ThreadLocal的内部类，用Entry来进行存储;</p><p>调用ThreadLocal的set()方法时，实际上就是往ThreadLocalMap设置值，key是ThreadLocal对象，值是传递进来的对象;</p><p>调用ThreadLocal的get()方法时，实际上就是往ThreadLocalMap获取值，key是ThreadLocal对象;</p><p>ThreadLocal本身并不存储值，它只是作为一个key来让线程从ThreadLocalMap获取value。</p><p>实在难以理解的，可以理解为，JVM维护了一个Map&lt;Thread, T>，每个线程要用这个T的时候，用当前的线程去Map里面取。</p><p><strong>四、ThreadLocal的应用场景</strong></p><p>最常见的ThreadLocal使用场景为 用来解决 数据库连接、Session管理等。(我自己真的没用过)</p><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e6d3a89f7f0b40169bc022bae3b84f92><p class=pgc-img-caption>数据库连接</p></div><div class=pgc-img><img alt=多线程之ThreadLocal的那些事 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/10603ff3085f4894aabb5f780205e817><p class=pgc-img-caption>Session管理</p></div><p>自己也没用过，本文大部分来源网络。</p><p>欢迎指正留言</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'多线程','ThreadLocal','那些'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>