<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java集合Set 集合、List和Collections类 | 极客快訊</title><meta property="og:title" content="Java集合Set 集合、List和Collections类 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e1ec4b6968944a9aba6a970e3792728c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aa2e8109.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aa2e8109.html><meta property="article:published_time" content="2020-11-14T21:05:52+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:52+08:00"><meta name=Keywords content><meta name=description content="Java集合Set 集合、List和Collections类"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/aa2e8109.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java集合Set 集合、List和Collections类</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、前言</h1><p>在 Java 集合（一） 中我们已经讲了 <strong>Collection 集合接口</strong>、<strong>Iterator 迭代器</strong>和<strong>泛型</strong>，今天我们来讲 <strong>Set 集合</strong>、<strong>List 集合</strong> 和 <strong>Collections 工具类</strong>。</p><h1 class=pgc-h-arrow-right>二、Set 集合</h1><p>Set 接口继承自 Collection 接口，它与 Collection 接口中地方法基本一致，并没有对 Collection 接口进行功能上的扩展，只是比 Collection 接口更加严格了，与 List 集合不同的是，Set 集合不允许存储重复的元素，而且 Set 集合是没有索引的。</p><p>Set 集合有多个子类，这里我们介绍其中的 HashSet 与 LinkedHashSet 这两个集合。</p><h1 class=pgc-h-arrow-right>2.1、HashSet 集合</h1><p>HashSet 集合实现了 Set 接口，首先 Set 集合有的特点它都有，同时它还有以下特点：</p><ol start=1><li>是一个无序的集合，存储元素和取出元素的顺序有可能不一致。</li><li>底层是一个哈希表结构，查询的速度非常的快。</li></ol><blockquote><p>HashSet 集合代码演示如下所示:</p></blockquote><pre><code>public class SetDemo01 {    public static void main(String[] args) {        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        // 使用 add() 方法添加元素        set.add(1);        set.add(3);        set.add(2);        set.add(1);        // 使用迭代器遍历集合        Iterator&lt;Integer&gt; iterator = set.iterator();        while (iterator.hasNext()) {            System.out.println(iterator.next());        }                // 使用增强 for 循环遍历        for (Integer integer : set) {            System.out.println(integer);        }    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>2.2、哈希值</h1><p>哈希值是一个十进制的整数，由系统随机给出，实际上就是对象的地址值，是一个逻辑地址，是模拟出来的地址，不是数据实际存储的物理地址。在 Object 类有一个方法 hashCode()，可以获取对象的哈希值。</p><p>hashCode() 方法源码如下：（native 代表该方法调用的是本地操作系统的方法）</p><pre><code>public native int hashCode();复制代码</code></pre><p>toString() 的源码如下：</p><pre><code>public String toString() {    return getClass().getName() + "@" + Integer.toHexString(hashCode());}复制代码</code></pre><p>可以看出 toString() 也调用了 hashCode() 并将其转化为十六进制。</p><blockquote><p>哈希值代码演示如下所示:</p></blockquote><pre><code>public class Person extends Object {    public static void main(String[] args) {        Person p1 = new Person();        int h1 = p1.hashCode();        System.out.println(h1); // 1163157884        Person p2 = new Person();        int h2 = p2.hashCode();        System.out.println(h2); // 1956725890        /**         * toString() 的源码         * public String toString() {         *         return getClass().getName() + "@" + Integer.toHexString(hashCode());         *     }         */        System.out.println(p1); // com.zjgsu.Set.Person@4554617c        System.out.println(p2); // com.zjgsu.Set.Person@74a14482        /**         * String 类的哈希值         * String 类重写了 hashCode() 所以下面两个哈希值是一样的         */        String s1 = new String("abc");        String s2 = new String("abc");        System.out.println(s1.hashCode());        System.out.println(s2.hashCode());    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>2.3、哈希表</h1><p>在 <strong>JDK1.8 之前哈希表 =数组 + 链表</strong>，但是在<strong>JDK1.8之后</strong>，<strong>哈希表 = 数组 + 链表 + 红黑树</strong>（提高查询效率）。具体如下图所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections类" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e1ec4b6968944a9aba6a970e3792728c><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>2.4、Set 集合存储元素不重复的原理</h1><p>我们先来执行以下下面的代码：</p><pre><code>public class SetDemo02 {    public static void main(String[] args) {        HashSet&lt;String&gt; set = new HashSet&lt;String&gt; ();        String s1 = new String("abc");        String s2 = new String("abc");        set.add(s1);        set.add(s2);        set.add("重地");        set.add("通话");        set.add("abc");        System.out.println(set); // [重地, 通话, abc]    }}复制代码</code></pre><p>打印结果如下所示：（可以看到 "abc" 只有一个）</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections类" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/366b3dd8b26943a0b2a5c49411f04424><p class=pgc-img-caption></p></div><p><br></p><p>我们根据代码来分析一下：</p><ol start=1><li>HashSet set = new HashSet ()：现在我们已经知道hashSet 底层是一个哈希表，所以这句代码会创建一个哈希表。</li><li>set.add(s1)：add() 方法会调用 s1 的 hashCode() 方法。计算字符串 “abc” 的哈希值，哈希值是 <strong>96354</strong>，在集合中找有没有 <strong>96354</strong> 这个哈希值的元素，发现<strong>没有</strong>，<strong>就把 s1 存储到集合中</strong>。</li><li>set.add(s2)：add() 方法会调用 s2 的 hashCode() 方法。计算字符串 “abc” 的哈希值，哈希值是 <strong>96354</strong>，在集合中找有没有 <strong>96354</strong> 这个哈希值的元素，发现<strong>有（哈希冲突）</strong>，s2 会调用 equals() 方法和哈希值相同的元素进行比较，<strong>s2.equals(s1) 返回 true</strong>，两个元素相同，就不会把 s2 存储到集合中。</li><li>set.add("重地");：add() 方法会调用 <strong>"重地"</strong> 的 hashCode() 方法。计算字符串 “重地” 的哈希值，哈希值是 <strong>1179395</strong>，在集合中找有没有 <strong>1179395</strong> 这个哈希值的元素，发现 <strong>没有</strong>，<strong>就把"重地"存储到集合中</strong>。</li><li>set.add("通话");：add() 方法会调用 <strong>"通话"</strong> 的 hashCode() 方法。计算字符串 “通话” 的哈希值，哈希值是 <strong>1179395</strong>，在集合中找有没有 <strong>1179395</strong> 这个哈希值的元素，发现<strong>有（哈希冲突）</strong>，"通话" 会调用 equals() 方法和哈希值相同的元素进行比较，<strong>"通话".equals("重地") 返回 false</strong>，两个元素不同，就把"通话"存储到集合中。</li></ol><p>最后哈希表中的元素如下所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections类" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24bb9e3dc0144ffca6f276ac624a5262><p class=pgc-img-caption></p></div><p><br></p><p>通过上述步骤的分析，已经很明了的说明了 Set 集合元素不重复的原理，前提就是存储的元素必须重写 hashCode() 方法 和 equals() 方法。</p><h1 class=pgc-h-arrow-right>2.5、HashSet 集合存储自定义类型元素</h1><p>给 HashSet 中存放自定义类型元素时，需要重写对象中的hashCode() 方法和 equals() 方法，建立自己的比较方式，才能保证 HashSet 集合中的对象唯一。我们来看个例子，如下所示：</p><pre><code>public class Student {    private String name;    private int age;    public Student() {    }    public Student(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public String toString() {        return "Student{" +                "name='" + name + '\'' +                ", age=" + age +                '}';    }    public static void main(String[] args) {        HashSet&lt;Student&gt; set = new HashSet&lt;&gt;();        Student s1 = new Student("张三", 18);        Student s2 = new Student("张三", 18);        Student s3 = new Student("张三", 30);        System.out.println(s1.hashCode());        System.out.println(s2.hashCode());        System.out.println(s3.hashCode());        set.add(s1);        set.add(s2);        set.add(s3);        System.out.println(set);    }}复制代码</code></pre><p>打印结果如下所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections类" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cdcfe5c32a043bbaad7dd42b42d7956><p class=pgc-img-caption></p></div><p><br></p><p>可以看到，如果没有重写 hashCode() 方法 和 equals() 方法，那么三个人是都会打印出来的，因为这时候他们的哈希值是不同的。</p><hr><p>给 Student 类重写 hashCode() 方法和 equals() 方法，具体如下所示：</p><pre><code>@Overridepublic int hashCode() {    return Objects.hash(name, age);}@Overridepublic boolean equals(Object o) {    if (this == o) return true;    if (o == null || getClass() != o.getClass()) return false;    Student student = (Student) o;    return age == student.age &amp;&amp;            Objects.equals(name, student.name);}复制代码</code></pre><p>打印结果如下所示：</p><div class=pgc-img><img alt="Java集合Set 集合、List和Collections类" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4fd9d2da4d74f568bbc9f251d69a4ef><p class=pgc-img-caption></p></div><p><br></p><p>可以看到，重写了 hashCode() 方法 和 equals() 方法之后，就把重复的 Student 对象去掉了。</p><h1 class=pgc-h-arrow-right>2.6、LinkedHashSet 集合</h1><p>我们知道 HashSet 保证元素唯一，可是元素存放进去是没有顺序的，那么我们要保证有序，怎么办呢？在 HashSet 下面有一个子类 LinkedHashSet，它是链表和哈希表组合的一个数据存储结构，它多了一条链表用来记录元素的存储顺序，所以 LinkedHashSet 是有序的。</p><blockquote><p>LinkedHashSet 集合代码演示如下所示:</p></blockquote><pre><code>public class LinkedHashSetDemo01 {    public static void main(String[] args) {        HashSet&lt;String&gt; set = new HashSet&lt;&gt;();        set.add("abc");        set.add("www");        set.add("zz");        set.add("qq");        set.add("it");        System.out.println(set);        LinkedHashSet&lt;String&gt; linkedSet = new LinkedHashSet&lt;&gt;();        linkedSet.add("abc");        linkedSet.add("www");        linkedSet.add("zz");        linkedSet.add("qq");        linkedSet.add("it");        System.out.println(linkedSet);    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>三、List 集合</h1><h1 class=pgc-h-arrow-right>3.1、List 接口介绍</h1><p>List 接口继承自 Collection 接口，我们会将实现了 List 接口的对象称为 List 集合。在 List 集合中允许出现重复的元素，所有的元素是以一种线性的方式进行存储的，在程序中可以通过索引来访问集合中的指定元素。另外，List 集合还有一个特点就是元素有序，即元素的存储和取出顺序一致。</p><h1 class=pgc-h-arrow-right>3.2、List 接口常用方法</h1><p>List 不但继承了 Collection 接口的全部方法，而且还增加了一些根据元素索引来操作集合的特有方法，如下：</p><ul><li>public void add(int index, E element)：将指定的元素添加到指定位置上。</li><li>public E get(int index)：返回集合中指定位置的元素。</li><li>public E remove(int index)：将指定位置上的元素移除并返回该元素。</li><li>public E set(int index, E element)：用指定元素替换集合中指定位置的元素，并返回被替换的元素。</li></ul><blockquote><p>List 接口常用方法代码演示如下所示:</p></blockquote><pre><code>public class ListDemo01 {    public static void main(String[] args) {        // 创建一个 List 集合对象        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add("a");        list.add("b");        list.add("c");        list.add("d");        list.add("a");        System.out.println(list);        // public void add(int index, E element)        // 在 c 和 d 之间添加一个 Test        list.add(3, "Test");        System.out.println(list);        // public E remove(int index)        // 移除 c 元素        String removeE = list.remove(2);        System.out.println(removeE);        System.out.println(list);        // public E set(int index, E element)        // 把最后一个 a 替换成 A        String setE = list.set(4, "A");        System.out.println(setE);        System.out.println(list);        // public E get(int index)        // List 集合遍历有三种方式        // 1、使用普通 for 循环        for (int i = 0; i &lt; list.size(); i++) {            System.out.print(list.get(i) + ", ");        }        System.out.println("\n");        System.out.println("----------------------------分割线--------------------------");        // 2、使用迭代器循环        Iterator&lt;String&gt; iterator = list.iterator();        while (iterator.hasNext()) {            System.out.print(iterator.next() + ", ");        }        System.out.println("\n");        System.out.println("----------------------------分割线--------------------------");        // 3、使用增强 for 循环        for (String s : list) {            System.out.print(s + ", ");        }    }}复制代码</code></pre><p>注意\color{red}{注意}<span style="color:red;--tt-darkmode-color: #FF0C00">注意</span>：操作索引的时候一定要放置索引越界异常。</p><h1 class=pgc-h-arrow-right>3.3、List 接口的子类</h1><h1 class=pgc-h-arrow-right>3.3.1、ArrayList 集合</h1><p>ArrayList 集合的底层数据结构是<strong>数组结构</strong>，其特点是<strong>元素增删慢，查询快</strong>，由于日常开发中使用最多的功能就算查询数据，所以 ArrayList 是最常用的集合。但是呢，我们不能在开发中随意的使用 ArrayList 完成任何需求，只有当 ArrayList 适合我们的开发需求时（查询多，增删少），我们才去使用它。</p><h1 class=pgc-h-arrow-right>3.3.2、LinkedList 集合</h1><p>LinkedList 集合的底层数据结构是<strong>链表结构</strong>，其特点是<strong>元素增删快，查询慢</strong>，但是链表结构的首尾元素查找速度跟数组的查找是一样快的，所以 LinkedList 中包含了大量操作首尾元素的方法。所以当我们需要实现的需求增删操作很多，查询很少或者查询很多但都是查询手尾的时候，我们就可以使用 LinkedList 集合。</p><blockquote><p>LinkedList 集合操作首尾元素方法代码演示如下所示:</p></blockquote><pre><code>public class LinkedListDemo02 {    public static void main(String[] args) {        // show01();        // show02();        show03();    }    // 增加元素    private static void show01() {        // 创建LinkedList集合对象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        System.out.println(linkedList);        // addFirst()        linkedList.addFirst("www");        System.out.println(linkedList);        // push() 等效于 addFirst()        linkedList.push("ccc");        System.out.println(linkedList);        // addLast() 等效于 add()        linkedList.addLast("com");        System.out.println(linkedList);    }    // 获取元素    private static void show02() {        // 创建LinkedList集合对象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        System.out.println(linkedList);        if (!linkedList.isEmpty()) {            String first = linkedList.getFirst();            System.out.println(first);            String last = linkedList.getLast();            System.out.println(last);        }    }    // 移除元素    private static void show03() {        // 创建LinkedList集合对象        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add("a");        linkedList.add("b");        linkedList.add("c");        System.out.println(linkedList);        // pop() 相当于 removeFirst()        String first = linkedList.removeFirst();        System.out.println(first);        String last = linkedList.removeLast();        System.out.println(last);        System.out.println(linkedList);    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>3.3.3、Vector 集合</h1><p>Vector 集合的底层数据结构也是<strong>数组结构</strong>，但是与List和LinkedList 不同的是，Vector 集合是单线程的，速度慢，目前已经被 ArrayList 所取代。</p><h1 class=pgc-h-arrow-right>四、Collections 集合工具类</h1><h1 class=pgc-h-arrow-right>4.1、常用功能</h1><p>Collections 是集合工具类，用来对集合进行操作，部分方法如下：</p><ul><li>public static &lt;泛型> boolean addAll(Collections, c, T...elements)：往集合中添加一些元素。</li><li>public static void shuffle(List&lt;?> list)：打乱集合顺序。</li><li>public static &lt;泛型> void sort(List&lt;?> list)：将集合中元素按照默认规则排序。</li><li>public static &lt;泛型> void sort(List&lt;?> list, Comparator&lt;? super T>)：将集合中元素按照指定规则排序。</li></ul><h1 class=pgc-h-arrow-right>4.2、sort(List&lt;?> list) 方法</h1><p>sort(List&lt;?> list) 方法的使用前提是被排序的集合里面存储的元素必须实现 Comparable 接口，并重写接口中的 compareTo() 方法定义排序的规则。</p><blockquote><p>sort(List&lt;?> list) 方法代码演示如下所示:</p></blockquote><pre><code>public class CollectionsDemo01 {    public static void main(String[] args) {        ArrayList&lt;Student&gt; list = new ArrayList&lt;&gt;();        list.add(new Student("张三", 18));        list.add(new Student("李四", 20));        list.add(new Student("王五", 15));        System.out.println(list);        Collections.sort(list);        System.out.println(list);    }    static class Student implements Comparable&lt;Student&gt; {            private String name;        private int age;        public Student() {        }        public Student(String name, int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        @Override        public String toString() {            return "Student{" +                    "name='" + name + '\'' +                    ", age=" + age +                    '}';        }        @Override        public int compareTo(Student o) {            // 自定义比较规则            // 比较两个人的年龄            return this.getAge() - o.getAge();   // 按照年龄升序            //return o.getAge() - this.getAge();  // 按照年龄降序        }    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>4.3、sort(list, Comparator) 方法</h1><p>Comparator 和 Comparable 的区别：</p><ol start=1><li>Comparable 是排序接口，若一个类实现了 Comparable 接口，就意味着“该类支持排序”。</li><li>Comparator 是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li><li>Comparable 相当于“内部比较器”，而 Comparator 相当于“外部比较器”。</li></ol><p>一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较</p><blockquote><p>sort(list, Comparator) 方法代码演示如下所示:</p></blockquote><pre><code>public class ComparatorDemo01 {    public static void main(String[] args) {        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(1);        list.add(3);        list.add(2);        System.out.println(list);        Collections.sort(list, new Comparator&lt;Integer&gt;() {            // 重写比较的规则            @Override            public int compare(Integer o1, Integer o2) {                return o1 - o2; // 升序                //return o2 - o1; // 降序            }        });        System.out.println(list);        ArrayList&lt;CollectionsDemo01.Student&gt; list2 = new ArrayList&lt;&gt;();        list2.add(new CollectionsDemo01.Student("张三", 18));        list2.add(new CollectionsDemo01.Student("李四", 20));        list2.add(new CollectionsDemo01.Student("b王五", 15));        list2.add(new CollectionsDemo01.Student("a李六", 15));        System.out.println(list2);        Collections.sort(list2, new Comparator&lt;CollectionsDemo01.Student&gt;() {            @Override            public int compare(CollectionsDemo01.Student o1, CollectionsDemo01.Student o2) {                int result = o1.getAge() - o2.getAge();                // 如果两个人的年龄是一样的，就用姓名的第一字比较规则                if (result == 0) {                    return o1.getName().charAt(0) - o2.getName().charAt(0);                }                return result;            }        });        System.out.println(list2);    }    static class Student {        private String name;        private int age;        public Student() {        }        public Student(String name, int age) {            this.name = name;            this.age = age;        }        public String getName() {            return name;        }        public void setName(String name) {            this.name = name;        }        public int getAge() {            return age;        }        public void setAge(int age) {            this.age = age;        }        @Override        public String toString() {            return "Student{" +                    "name='" + name + '\'' +                    ", age=" + age +                    '}';        }    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>五、小结</h1><p>集合第二部分中我们讲了 <strong>List 集合</strong>、 <strong>Set 集合</strong>和 <strong>Collections 集合工具类</strong>，下一节我们讲 <strong>Map 集合</strong>和<strong>一个综合案例</strong>。</p><p><br>作者：萌果爱吃柠檬<br>链接：https://juejin.im/post/6889596397943816199<br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'集合','Java','Set'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>