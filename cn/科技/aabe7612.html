<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「推荐阅读」C语言中内存的管理与使用—堆与栈 | 极客快訊</title><meta property="og:title" content="「推荐阅读」C语言中内存的管理与使用—堆与栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/0dd69fd4ecb0474e955dbf37110fd824"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aabe7612.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aabe7612.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="「推荐阅读」C语言中内存的管理与使用—堆与栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/aabe7612.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「推荐阅读」C语言中内存的管理与使用—堆与栈</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=「推荐阅读」C语言中内存的管理与使用—堆与栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0dd69fd4ecb0474e955dbf37110fd824><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>C语言中内存的管理与使用—堆与栈</h1><p>内存管理是计算机学习编程的一个重要知识，也是令大多数程序员比较头疼的一个知识。由于在目前的嵌入式系统中资源仍然是有限的，所以对内存的管理就显得尤为重要。C语言程序的内存接口简单，内存管理灵活，所以是初学者容易出错的知识，下面就让我们分三篇文章进行讲解，这篇文章主要讲解的是内存管理中的堆与栈。</p><p></p><h1 class=pgc-h-arrow-right>1、堆与栈的区别</h1><p>栈：由系统自动分配的释放，用来存放函数的参数、局部变量的值。有先进先出的特点</p><p>堆：由程序员分配释放，若程序员未进行释放会由OS进行回收</p><p></p><h1 class=pgc-h-arrow-right>2、什么是堆？</h1><p>通过上面的两句话只是简单的概括了一下堆栈的特点，并不能解释什么是堆和栈，下面就让我们详细的看一下C语言中的堆是如何解释的。</p><p></p><p>一个为计算机程序可以分为两个部分：存放代码的代码段和存放变量的和数据的数据段数据段中又增加了全局初始化数据区和未初始化数据区。其中全局初始化数据区包含程序中明确被初始化的全局变量和静态变量以及常量。</p><p></p><p>其中堆是一个位于未初始化数据区（BSS）段和栈之间，用来动态分配内存。这段区域由程序员管理，程序员利用操作系统提供的分配和释放函数可以使用堆区的内存，每个程序员会进行扫描未用空间，当一个空间的大小符合申请空间时，就会将此空间返回给程序员，同时把申请加入到链表，操作系统就是通过此链表来维护一个堆的使用。</p><p></p><p>为避免程序员频繁申请小的堆，我们在申请的时候需要遵守以下几点</p><p>• 临时数据放在栈区，生命周期短</p><p>• 全局数据和静态数据在程序中都能被访问，因此单独储存管理</p><p>• 程序运行是按顺序进行的，虽有跳转，数据需要多次访问，开辟单独的数据空间方便数据的访问与分分类。</p><p>• 用户需要自己分配内存在堆区，便于用户管理内存以及操作系统监控</p><p></p><h1 class=pgc-h-arrow-right>3、什么是栈？</h1><p>栈是由编译器自己分配和释放空间的一个区域，用来存储函数的参数、局部变量等。当函数被调用时，被调用的函数参数和返回值被储存在当前函数栈区之后调用函数再为自身的自动变量和临时变量在栈区分配空间。当函数调用返回时，在栈区内的参数返回值、自动变量和临时变量等会被自动释放。</p><p></p><p>函数的调用和栈的使用方式保证了函数内部定义相同名字的变量不会混淆。栈的管理方式为先进先出，学过C语言的应该知道这个特点。</p><p></p><h1 class=pgc-h-arrow-right>4、 实例中的堆与栈</h1><p>在实际编程过程中，可以通过两种形式来实现：数组的形式实现栈，称为静态栈；以链表的形式来实现栈，称为动态栈；</p><p></p><p>相对于栈“先进先出”的特点，堆则为一种经过排序后形成树形数据结构，常用来实现优先队列等。由此可见堆是一种特殊的二叉树。其中节点从左到右填满，并且最后一个树叶在最左边。</p><p>由此可见，内存分配的堆栈与数据结构中所阐述的堆栈有着本质的区别，这一点千万不要混淆。同样，在内存分配中的堆和栈也存在着很大的区别，也不要混淆这两者的概念。为了加深理解，看下面一段示例代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;int main(void){/*在栈上分配*/int i1=0;int i2=0;int i3=0;int i4=0;printf("栈：向下\n");printf("i1=0x%08x\n",&amp;i1);printf("i2=0x%08x\n",&amp;i2);printf("i3=0x%08x\n",&amp;i3);printf("i4=0x%08x\n\n",&amp;i4);printf("--------------------\n\n");/*在堆上分配*/char *p1 = (char *)malloc(4);char *p2 = (char *)malloc(4);char *p3 = (char *)malloc(4);char *p4 = (char *)malloc(4);printf("p1=0x%08x\n",p1);printf("p2=0x%08x\n",p2);printf("p3=0x%08x\n",p3);printf("p4=0x%08x\n",p4);printf("堆：向上\n\n");/*释放堆内存*/free(p1);p1=NULL;free(p2);p2=NULL;free(p3);p3=NULL;free(p4);p4=NULL;return 0;} </code></pre><p>该示例代码主要演示了在内存分配中的堆和栈的区别，其运行结果为：</p><p><br></p><pre><code>i1=0x0060fefci2=0x0060fef8i3=0x0060fef4i4=0x0060fef0--------------------p1=0x00bd14e0p2=0x00bd3148p3=0x00bd3158p4=0x00bd3168 </code></pre><h1 class=pgc-h-arrow-right>5、内存分配中的堆与栈</h1><p>在C语言中，内存分配的方式一般有以下三种，分别是静态存储区域分配；在栈上分配；从栈上分配；</p><p></p><p>从静态存储区分配：由编译器自动分配和释放的，在程序的整个运行期间都存在，直到整个程序运行结束时才被释放，比如常见的全局变量与 static 变量。</p><p></p><p>在栈上分配：它同样也是由编译器自动分配和释放的，即在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元将被自动释放。需要注意的是，栈内存分配运算内置于处理器的指令集中，它的运行效率一般很高，但是分配的内存容量有限。</p><p></p><p>从堆上分配：也被称为动态内存分配，它是由程序员手动完成申请和释放的。即程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完之后再由程序员自己负责使用内存释放函数（如 free 函数）来释放内存。也就是说，动态内存的整个生存期是由程序员自己决定的，使用非常灵活。需要注意的是，如果在堆上分配了内存空间，就必须及时释放它，否则将会导致运行的程序出现内存泄漏等错误。</p><p></p><h1 class=pgc-h-arrow-right>6、内存栈和堆深度讲解</h1><p>栈和堆的分配方式的差别造成对栈内存的自动释放而言，虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果一旦忘记了释放堆内存，那么将会造成内存泄漏，导致程序出现致命的潜在错误。</p><p></p><p>对堆来说，频繁分配和释放（malloc / free）不同大小的堆空间势必会造成内存空间的不连续，从而造成大量碎片，导致程序效率降低；而对栈来讲，则不会存在这个问题。</p><p></p><p>栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，而堆则不同，它是由 C/C++ 函数库提供的，它的机制也相当复杂。很显然，堆的分配效率比栈要低得多。</p><p></p><p>由于操作系统是用链表来存储空闲内存地址（内存区域不连续）的，同时链表的遍历方向是由低地址向高地址进行的。因此，堆内存的申请大小受限于计算机系统中有效的虚拟内存。</p><p>而栈则不同，它是一块连续的内存区域，其地址的增长方向是向下进行的，向内存地址减小的方向增长。由此可见，栈顶的地址和栈的最大容量一般都是由系统预先规定好的，如果申请的空间超过栈的剩余空间时，将会提示溢出错误。由此可见，相对于堆，能够从栈中获得的空间相对较小。</p><p></p><h1 class=pgc-h-arrow-right>7、变量类型</h1><p>最后介绍一下 C 语言中各类型变量的存储位置和作用域。</p><p>全局变量：从静态存储区域分配，其作用域是全局作用域，也就是整个程序的生命周期内都可以使用。与此同时，如果程序是由多个源文件构成的，那么全局变量只要在一个文件中定义，就可以在其他所有的文件中使用，但必须在其他文件中通过使用extern关键字来声明该全局变量。</p><p></p><p>全局静态变量：从静态存储区域分配，其生命周期也是与整个程序同在的，从程序开始到结束一直起作用。但是与全局变量不同的是，全局静态变量作用域只在定义它的一个源文件内，其他源文件不能使用。</p><p></p><p>局部变量。从栈上分配，其作用域只是在局部函数内，在定义该变量的函数内，只要出了该函数，该局部变量就不再起作用，该变量的生命周期也只是和该函数同在。</p><p></p><p>局部静态变量。从静态存储区域分配，其在第一次初始化后就一直存在直到程序结束，该变量的特点是其作用域只在定义它的函数内可见，出了该函数就不可见了。</p><div class=pgc-img><img alt=「推荐阅读」C语言中内存的管理与使用—堆与栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/958467d4111146808ac6816bd5299ac0><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>欢迎大家关注微信公众号【零基础玩嵌入式】和我们一起学习嵌入式知识，关注公众号回复加群进百人嵌入式交流群，回复32即领取全套stm32资料，快来和我们一起学习吧</h1><p><a class=tteditor-forum data-concern-id=1629739223355405 data-id=1629739223355405 data-name=嵌入式 data-uid>#嵌入式#</a><a class=tteditor-forum data-concern-id=1673830784548920 data-id=1673830784548920 data-name=嵌入式公众号 data-uid>#嵌入式公众号#</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'推荐','阅读','内存'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>