<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>正则表达式在Java中的使用 | 极客快訊</title><meta property="og:title" content="正则表达式在Java中的使用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/aae5ff48.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/aae5ff48.html><meta property="article:published_time" content="2020-11-14T21:07:13+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:13+08:00"><meta name=Keywords content><meta name=description content="正则表达式在Java中的使用"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/aae5ff48.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>正则表达式在Java中的使用</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>正则表达式一般用于字符串匹配, 字符串查找和字符串替换. 别小看它的作用, 在工作学习中灵活运用正则表达式处理字符串能够大幅度提高效率, 编程的快乐来得就是这么简单。</p><p>一下子给出一堆匹配的规则可能会让人恐惧, 下面将由浅入深讲解正则表达式的使用。</p><h1 class=pgc-h-arrow-right>从简单例子认识正则表达式匹配</h1><p>先上代码</p><pre><code>public class Demo1 {    public static void main(String[] args) {        //字符串abc匹配正则表达式&#34;...&#34;, 其中&#34;.&#34;表示一个字符        //&#34;...&#34;表示三个字符        System.out.println(&#34;abc&#34;.matches(&#34;...&#34;));        System.out.println(&#34;abcd&#34;.matches(&#34;...&#34;));    }}//输出结果truefalse</code></pre><p>String类中有个matches(String regex)方法, 返回值为布尔类型, 用于告诉这个字符串是否匹配给定的正则表达式。</p><p>在本例中我们给出的正则表达式为..., 其中每个.表示一个字符, 整个正则表达式的意思是三个字符, 显然当匹配abc的时候结果为true, 匹配abcd时结果为false。</p><h1 class=pgc-h-arrow-right>Java中对正则表达式的支持(各种语言有相应的实现)</h1><p>在java.util.regex包下有两个用于正则表达式的类, 一个是Matcher类, 另一个Pattern。</p><p>Java官方文档中给出对这两个类的典型用法, 代码如下:</p><pre><code>public class Demo2 {    public static void main(String[] args) {        //[a-z]表示a~z之间的任何一个字符, {3}表示3个字符, 意思是匹配一个长度为3, 并且每个字符属于a~z的字符串        Pattern p = Pattern.compile(&#34;[a-z]{3}&#34;);        Matcher m = p.matcher(&#34;abc&#34;);        System.out.println(m.matches());    }}//输出结果true</code></pre><p>如果要深究正则表达式背后的原理, 会涉及编译原理中自动机等知识, 此处不展开描述. 为了达到通俗易懂, 这里用较为形象的语言描述。</p><p>Pattern可以理解为一个模式, 字符串需要与某种模式进行匹配. 比如Demo2中, 我们定义的模式是一个长度为3的字符串, 其中每个字符必须是a~z中的一个。</p><p>我们看到创建Pattern对象时调用的是Pattern类中的compile方法, 也就是说对我们传入的正则表达式编译后得到一个模式对象. 而这个经过编译后模式对象, 会使得正则表达式使用效率会大大提高, 并且作为一个常量, 它可以安全地供多个线程并发使用。</p><p>Matcher可以理解为模式匹配某个字符串后产生的结果. 字符串和某个模式匹配后可能会产生很多个结果, 这个会在后面的例子中讲解。</p><p>最后当我们调用m.matches()时就会返回完整字符串与模式匹配的结果。</p><p>上面的三行代码可以简化为一行代码</p><p>System.out.println("abc".matches("[a-z]{3}"));</p><p>但是如果一个正则表达式需要被重复匹配, 这种写法效率较低。</p><h1 class=pgc-h-arrow-right>初步认识 . + * ?</h1><p>在介绍之前首先要说明的是, 正则表达式的具体含义不用强背, 各个符号的含义在Java官方文档的Pattern类描述中或网上有详细的定义. 当然能熟用就更好了。</p><pre><code>public class Demo3 {    /**     * 为了省略每次写打印语句, 这里把输出语句封装起来     * @param o     */    private static void p(Object o){        System.out.println(o);    }    /**     * .	Any character (may or may not match line terminators), 任意字符     * X?	X, once or not at all       零个或一个     * X*	X, zero or more times       零个或多个     * X+	X, one or more times        一个或多个     * X{n}	X, exactly n times          x出现n次     * X{n,}	X, at least n times     x出现至少n次     * X{n,m}	X, at least n but not more than m times 出现n~m次     * @param args     */    public static void main(String[] args) {        p(&#34;a&#34;.matches(&#34;.&#34;));        p(&#34;aa&#34;.matches(&#34;aa&#34;));        p(&#34;aaaa&#34;.matches(&#34;a*&#34;));        p(&#34;aaaa&#34;.matches(&#34;a+&#34;));        p(&#34;&#34;.matches(&#34;a*&#34;));        p(&#34;a&#34;.matches(&#34;a?&#34;));        // \d	A digit: [0-9], 表示数字, 但是在java中对&#34;\&#34;这个符号需要使用\进行转义, 所以出现\d        p(&#34;2345&#34;.matches(&#34;\d{2,5}&#34;));        // \.用于匹配&#34;.&#34;        p(&#34;192.168.0.123&#34;.matches(&#34;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}&#34;));        // [0-2]指必须是0~2中的一个数字        p(&#34;192&#34;.matches(&#34;[0-2][0-9][0-9]&#34;));    }}//输出结果//全为true</code></pre><h1 class=pgc-h-arrow-right>范围</h1><p>[]用于描述一个字符的范围, 下面是一些例子：</p><pre><code>public class Demo4 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        //[abc]指abc中的其中一个字母        p(&#34;a&#34;.matches(&#34;[abc]&#34;));        //[^abc]指除了abc之外的字符        p(&#34;1&#34;.matches(&#34;[^abc]&#34;));        //a~z或A~Z的字符, 以下三个均是或的写法        p(&#34;A&#34;.matches(&#34;[a-zA-Z]&#34;));        p(&#34;A&#34;.matches(&#34;[a-z|A-Z]&#34;));        p(&#34;A&#34;.matches(&#34;[a-z[A-Z]]&#34;));        //[A-Z&amp;&amp;[REQ]]指A~Z中并且属于REQ其中之一的字符        p(&#34;R&#34;.matches(&#34;[A-Z&amp;&amp;[REQ]]&#34;));    }}//输出结果全部为true</code></pre><h1 class=pgc-h-arrow-right>认识\s \w \d \</h1><p>下面介绍数字和字母的正则表达, 这是编程中使用最多的字符了.</p><h2 class=pgc-h-arrow-right>关于\</h2><p>这里重点介绍最不好理解的\. 在Java中的字符串中, 如果要用到特殊字符, 必须通过在前面加\进行转义。</p><p>举个例子, 考虑这个字符串"老师大声说:"同学们,快交作业!"". 如果我们没有转义字符, 那么开头的双引号的结束应该在说:"这里, 但是我们的字符串中需要用到双引号, 所以需要用转义字符。</p><p>使用转义字符后的字符串为"老师大声说:\"同学们,快交作业!\"", 这样我们的原意才能被正确识别。</p><p>同理如果我们要在字符串中使用\, 也应该在前面加一个\, 所以在字符串中表示为"\\"。</p><p>那么如何在正则表达式中表示要匹配\呢, 答案为"\\\\"。</p><p>我们分开考虑: 由于正则式中表示\同样需要转义, 所以前面的\\表示正则表达式中的转义字符\, 后面的\\表示正则表达式中\本身, 合起来在正则表达式中表示\.</p><p>如果感觉有点绕的话请看下面代码：</p><pre><code>public class Demo5 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        /**         * \d	A digit: [0-9]          数字         * \D	A non-digit: [^0-9]     非数字         * \s	A whitespace character: [ \t\n0B\f\r] 空格         * \S	A non-whitespace character: [^\s]       非空格         * \w	A word character: [a-zA-Z_0-9]          数字字母和下划线         * \W	A non-word character: [^\w]             非数字字母和下划线         */        // \s{4}表示4个空白符        p(&#34; \n\r\t&#34;.matches(&#34;\s{4}&#34;));        // \S表示非空白符        p(&#34;a&#34;.matches(&#34;\S&#34;));        // \w{3}表示数字字母和下划线        p(&#34;a_8&#34;.matches(&#34;\w{3}&#34;));        p(&#34;abc888&amp;^%&#34;.matches(&#34;[a-z]{1,3}\d+[%^&amp;*]+&#34;));        // 匹配 \        p(&#34;\&#34;.matches(&#34;\\&#34;));    }}//输出结果全部为true</code></pre><h1 class=pgc-h-arrow-right>边界处理</h1><p>^在中括号内表示取反的意思[^], 如果不在中括号里则表示字符串的开头</p><pre><code>public class Demo6 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        /**         * ^	The beginning of a line 一个字符串的开始         * $	The end of a line       字符串的结束         * \b	A word boundary         一个单词的边界, 可以是空格, 换行符等         */        p(&#34;hello sir&#34;.matches(&#34;^h.*&#34;));        p(&#34;hello sir&#34;.matches(&#34;.*r$&#34;));        p(&#34;hello sir&#34;.matches(&#34;^h[a-z]{1,3}o\b.*&#34;));        p(&#34;hellosir&#34;.matches(&#34;^h[a-z]{1,3}o\b.*&#34;));    }}</code></pre><h2 class=pgc-h-arrow-right>练习:匹配空白行合email地址</h2><p>拿到一篇文章, 如何判断里面有多少个空白行? 用正则表达式能方便地进行匹配, 注意空白行中可能包括空格, 制表符等。</p><pre><code>p(&#34; \n&#34;.matches(&#34;^[\s&amp;&amp;[^\n]]*\n$&#34;));</code></pre><p>解释: ^[\\s&&[^\n]]*是空格符号但不是换行符, \\n$最后以换行符结束</p><p>下面是匹配邮箱：</p><pre><code>p(&#34;liuyj24@126.com&#34;.matches(&#34;[\w[.-]]+@[\w[.-]]+\.[\w]+&#34;));</code></pre><p>解释: [\\w[.-]]+以一个或多个数字字母下划线.或-组成, @接着是个@符号, 然后同样是[\\w[.-]]+, 接着\\.匹配., 最后同样是[\\w]+</p><h1 class=pgc-h-arrow-right>Matcher类的matches(),find()和lookingAt()</h1><p>matches()方法会将整个字符串与模板进行匹配.</p><p>find()则是从当前位置开始进行匹配, 如果传入字符串后首先进行find(), 那么当前位置就是字符串的开头, 对当前位置的具体分析可以看下面的代码示例</p><p>lookingAt()方法会从字符串的开头进行匹配.</p><pre><code>public class Demo8 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        Pattern pattern = Pattern.compile(&#34;\d{3,5}&#34;);        String s = &#34;123-34345-234-00&#34;;        Matcher m = pattern.matcher(s);        //先演示matches(), 与整个字符串匹配.        p(m.matches());        //结果为false, 显然要匹配3~5个数字会在-处匹配失败        //然后演示find(), 先使用reset()方法把当前位置设置为字符串的开头        m.reset();        p(m.find());//true 匹配123成功        p(m.find());//true 匹配34345成功        p(m.find());//true 匹配234成功        p(m.find());//false 匹配00失败        //下面我们演示不在matches()使用reset(), 看看当前位置的变化        m.reset();//先重置        p(m.matches());//false 匹配整个字符串失败, 当前位置来到-        p(m.find());// true 匹配34345成功        p(m.find());// true 匹配234成功        p(m.find());// false 匹配00始边        p(m.find());// false 没有东西匹配, 失败        //演示lookingAt(), 从头开始找        p(m.lookingAt());//true 找到123, 成功    }}</code></pre><h1 class=pgc-h-arrow-right>Matcher类中的start()和end()</h1><p>如果一次匹配成功的话start()用于返回匹配开始的位置, end()用于返回匹配结束字符的后面一个位置</p><pre><code>public class Demo9 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        Pattern pattern = Pattern.compile(&#34;\d{3,5}&#34;);        String s = &#34;123-34345-234-00&#34;;        Matcher m = pattern.matcher(s);        p(m.find());//true 匹配123成功        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        p(m.find());//true 匹配34345成功        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        p(m.find());//true 匹配234成功        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        p(m.find());//false 匹配00失败        try {            p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());        }catch (Exception e){            System.out.println(&#34;报错了...&#34;);        }        p(m.lookingAt());        p(&#34;start: &#34; + m.start() + &#34; - end:&#34; + m.end());    }}//输出结果truestart: 0 - end:3truestart: 4 - end:9truestart: 10 - end:13false报错了...truestart: 0 - end:3</code></pre><h1 class=pgc-h-arrow-right>替换字符串</h1><p>想要替换字符串首先要找到被替换的字符串, 这里要新介绍Matcher类中的一个方法group(), 它能返回匹配到的字符串.</p><p>下面我们看一个例子, 把字符串中的java转换为大写.</p><pre><code>public class Demo10 {    private static void p(Object o){        System.out.println(o);    }    public static void main(String[] args) {        Pattern p = Pattern.compile(&#34;java&#34;);        Matcher m = p.matcher(&#34;java Java JAVA JAva I love Java and you&#34;);        p(m.replaceAll(&#34;JAVA&#34;));//replaceAll()方法会替换所有匹配到的字符串    }}//输出结果JAVA Java JAVA JAva I love Java and you</code></pre><h2 class=pgc-h-arrow-right>升级: 不区分大小写查找并替换字符串</h2><p>为了在匹配的时候不区分大小写, 我们要在创建模板模板时指定大小写不敏感</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;java&#34;, Pattern.CASE_INSENSITIVE);//指定为大小写不敏感的    Matcher m = p.matcher(&#34;java Java JAVA JAva I love Java and you&#34;);    p(m.replaceAll(&#34;JAVA&#34;));}//输出结果JAVA JAVA JAVA JAVA I love JAVA and you</code></pre><h2 class=pgc-h-arrow-right>再升级: 不区分大小写, 替换查找到的指定字符串</h2><p>这里演示把查找到第奇数个字符串转换为大写, 第偶数个转换为小写</p><p>这里会引入Matcher类中一个强大的方法appendReplacement(StringBuffer sb, String replacement), 它需要传入一个StringBuffer进行字符串拼接.</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;java&#34;, Pattern.CASE_INSENSITIVE);    Matcher m = p.matcher(&#34;java Java JAVA JAva I love Java and you ?&#34;);    StringBuffer sb = new StringBuffer();    int index = 1;    while(m.find()){        //m.appendReplacement(sb, (index++ &amp; 1) == 0 ? &#34;java&#34; : &#34;JAVA&#34;); 较为简洁的写法        if((index &amp; 1) == 0){//偶数            m.appendReplacement(sb, &#34;java&#34;);        }else{            m.appendReplacement(sb, &#34;JAVA&#34;);        }        index++;    }    m.appendTail(sb);//把剩余的字符串加入    p(sb);}//输出结果JAVA java JAVA java I love JAVA and you ?</code></pre><h1 class=pgc-h-arrow-right>分组</h1><p>先从一个问题引入, 看下面这段代码</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;\d{3,5}[a-z]{2}&#34;);    String s = &#34;123aa-5423zx-642oi-00&#34;;    Matcher m = p.matcher(s);    while(m.find()){        p(m.group());    }}//输出结果123aa5423zx642oi</code></pre><p>其中正则表达式"\\d{3,5}[a-z]{2}"表示3~5个数字跟上两个字母, 然后打印出每个匹配到的字符串</p><p>如果想要打印每个匹配串中的数字, 如何操作呢.</p><p>首先你可能想到把匹配到的字符串再进行匹配, 但是这样太麻烦了, 分组机制可以帮助我们在正则表达式中进行分组.</p><p>规定使用()进行分组, 这里我们把字母和数字各分为一组"(\\d{3,5})([a-z]{2})"</p><p>然后在调用m.group(int group)方法时传入组号即可</p><p>注意, 组号从0开始, 0组代表整个正则表达式, 从0之后, 就是在正则表达式中从左到右每一个左括号对应一个组. 在这个表达式中第1组是数字, 第2组是字母.</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;(\d{3,5})([a-z]{2})&#34;);//正则表达式为3~5个数字跟上两个字母    String s = &#34;123aa-5423zx-642oi-00&#34;;    Matcher m = p.matcher(s);    while(m.find()){        p(m.group(1));    }}//输出结果1235423642</code></pre><h1 class=pgc-h-arrow-right>实战1: 抓取网页中的email地址(爬虫)</h1><p>假设我们手头上有一些优质的资源, 打算分享给网友, 于是便到贴吧上发出一个留邮箱发资源的帖子. 没想到网友热情高涨, 留下了近百个邮箱. 但逐个复制发送太累了, 我们考虑用程序实现.</p><p>这里不展开讲发邮件部分, 重点应用已经学到的正则表达式从网页中截取所有的邮箱地址.</p><p>首先获取一个帖子的html代码随便找了一个, 点击跳转, 在浏览器中点击右键保存html文件</p><p>接下来看代码:</p><pre><code>public class Demo12 {    public static void main(String[] args) {        BufferedReader br = null;        try {            br = new BufferedReader(new FileReader(&#34;C:\emailTest.html&#34;));            String line = &#34;&#34;;            while((line = br.readLine()) != null){//读取文件的每一行                parse(line);//解析其中的email地址            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        }finally {            if(br != null){                try {                    br.close();                    br = null;                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    private static void parse(String line){        Pattern p = Pattern.compile(&#34;[\w[.-]]+@[\w[.-]]+\.[\w]+&#34;);        Matcher m = p.matcher(line);        while(m.find()){            System.out.println(m.group());        }    }}//输出结果2819531636@qq.com2819531636@qq.com2405059759@qq.com2405059759@qq.com1013376804@qq.com...</code></pre><h1 class=pgc-h-arrow-right>实战2: 代码统计小程序</h1><p>最后的一个实战案例: 统计一个项目中一共有多少行代码, 多少行注释, 多少个空白行. 不妨对自己做过的项目进行统计, 发现不知不觉中也是个写过成千上万行代码的人了…</p><p>我在github上挑选了一个项目, 是纯java写的小项目, 方便统计. 点击跳转</p><p>下面是具体的代码, 除了判断空行用了正则表达式外, 判断代码行和注释行用了String类的api</p><pre><code>public class Demo13 {    private static long codeLines = 0;    private static long commentLines = 0;    private static long whiteLines = 0;    private static String filePath = &#34;C:\TankOnline&#34;;    public static void main(String[] args) {        process(filePath);        System.out.println(&#34;codeLines : &#34; + codeLines);        System.out.println(&#34;commentLines : &#34; + commentLines);        System.out.println(&#34;whiteLines : &#34; + whiteLines);    }    /**     * 递归查找文件     * @param pathStr     */    public static void process(String pathStr){        File file = new File(pathStr);        if(file.isDirectory()){//是文件夹则递归查找            File[] fileList = file.listFiles();            for(File f : fileList){                String fPath = f.getAbsolutePath();                process(fPath);            }        }else if(file.isFile()){//是文件则判断是否是.java文件            if(file.getName().matches(&#34;.*\.java$&#34;)){                parse(file);            }        }    }    private static void parse(File file) {        BufferedReader br = null;        try {            br = new BufferedReader(new FileReader(file));            String line = &#34;&#34;;            while((line = br.readLine()) != null){                line = line.trim();//清空每行首尾的空格                if(line.matches(&#34;^[\s&amp;&amp;[^\n]]*$&#34;)){//注意不是以\n结尾, 因为在br.readLine()会去掉\n                    whiteLines++;                }else if(line.startsWith(&#34;/*&#34;) || line.startsWith(&#34;*&#34;) || line.endsWith(&#34;*/&#34;)){                    commentLines++;                }else if(line.startsWith(&#34;//&#34;) || line.contains(&#34;//&#34;)){                    commentLines++;                }else{                    if(line.startsWith(&#34;import&#34;) || line.startsWith(&#34;package&#34;)){//导包不算                        continue;                    }                    codeLines++;                }            }        } catch (FileNotFoundException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            if(null != br){                try {                    br.close();                    br = null;                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }}//输出结果codeLines : 1139commentLines : 124whiteLines : 172</code></pre><h1 class=pgc-h-arrow-right>贪婪模式与非贪婪模式</h1><p>经过两个实战后, 相信大家已经掌握了正则表达式的基本使用了, 下面介绍贪婪模式与非贪婪模式.</p><p>通过查看官方api我们发现Pattern类中有如下定义:</p><pre><code>Greedy quantifiers 贪婪模式X?	X, once or not at allX*	X, zero or more timesX+	X, one or more timesX{n}	X, exactly n timesX{n,}	X, at least n timesX{n,m}	X, at least n but not more than m times Reluctant quantifiers 非贪婪模式(勉强的, 不情愿的)X??	X, once or not at allX*?	X, zero or more timesX+?	X, one or more timesX{n}?	X, exactly n timesX{n,}?	X, at least n timesX{n,m}?	X, at least n but not more than m times Possessive quantifiers  独占模式X?+	X, once or not at allX*+	X, zero or more timesX++	X, one or more timesX{n}+	X, exactly n timesX{n,}+	X, at least n timesX{n,m}+	X, at least n but not more than m times</code></pre><p>这三种模式表达的意思是一样的, 在前面的讲解中我们全部使用的是贪婪模式. 那么其他两种模式的写法有什么区别呢? 通过下面的代码示例进行讲解.</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;.{3,10}[0-9]&#34;);    String s = &#34;aaaa5bbbb6&#34;;//10个字符    Matcher m = p.matcher(s);    if(m.find()){        System.out.println(m.start() + &#34; - &#34; + m.end());    }else {        System.out.println(&#34;not match!&#34;);    }}//输出结果0 - 10</code></pre><p>正则表达式的意思是3~10个字符加一个数字. 在贪婪模式下匹配时, 系统会先吞掉10个字符, 这时检查最后一个是否时数字, 发现已经没有字符了, 于是吐出来一个字符, 再次匹配数字, 匹配成功, 得到0-10.</p><p>下面是非贪婪模式演示(勉强的, 不情愿的)</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;.{3,10}?[0-9]&#34;);//添加了一个?    String s = &#34;aaaa5bbbb6&#34;;    Matcher m = p.matcher(s);    if(m.find()){        System.out.println(m.start() + &#34; - &#34; + m.end());    }else {        System.out.println(&#34;not match!&#34;);    }}//输出结果0 - 5</code></pre><p>在非贪婪模式下, 首先只会吞掉3个(最少3个), 然后判断后面一个是否是数字, 结果不是, 在往后吞一个字符, 继续判断后面的是否数字, 结果是, 输出0-5</p><p>最后演示独占模式, 通常只在追求效率的情况下这么做, 用得比较少</p><pre><code>public static void main(String[] args) {    Pattern p = Pattern.compile(&#34;.{3,10}+[0-9]&#34;);//多了个+    String s = &#34;aaaa5bbbb6&#34;;    Matcher m = p.matcher(s);    if(m.find()){        System.out.println(m.start() + &#34; - &#34; + m.end());    }else {        System.out.println(&#34;not match!&#34;);    }}//输出结果not match!</code></pre><p>独占模式会一下吞进10个字符, 然后判断后一个是否是数字, 不管是否匹配成功它都不会继续吞或者吐出一个字符.</p><h1 class=pgc-h-arrow-right>结束</h1><p>愿正则表达式给你带来更愉快的编程体验.</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'正则','表达式','Java'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/d02df1d6.html alt=Java正则表达式入坑指南：正则表达式使用的类有哪些吗？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/00407db6c5d544f8aeb61c83d3f974eb style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/d02df1d6.html title=Java正则表达式入坑指南：正则表达式使用的类有哪些吗？>Java正则表达式入坑指南：正则表达式使用的类有哪些吗？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>