<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>这6种编码方法，你掌握了几个？ | 极客快訊</title><meta property="og:title" content="这6种编码方法，你掌握了几个？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e653c34233a14fc7a0e54773a773af97"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ab527964.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ab527964.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ab527964.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ab527964.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ab527964.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ab527964.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ab527964.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ab527964.html><meta property="article:published_time" content="2020-11-14T21:06:06+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:06+08:00"><meta name=Keywords content><meta name=description content="这6种编码方法，你掌握了几个？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ab527964.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>这6种编码方法，你掌握了几个？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=这6种编码方法，你掌握了几个？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e653c34233a14fc7a0e54773a773af97><p class=pgc-img-caption></p></div><p><strong>阿里妹导读</strong>：Don Roberts 提出的一条重构准则：第一次做某件事时只管去做；第二次做类似的事时会产生反感，但无论如何还是可以去做；第三次再做类似的事时，你就应该重构。</p><p>编码也是如此，当多次编写类似的代码时，我们需要考虑是否有一种方法能够提高编码速度，让编码速度“起飞”？高德地图技术专家陈昌毅（常意）多年来致力于敏捷开发，总结了一套编码的方法论，有助于程序员"快速、优质、高效"地进行编码。</p><h1><strong>方法1：手工编写代码</strong></h1><p>大多数刚学习 Java 的程序员，都会怀着一种崇敬的仪式感，一字一句地在开发工具上敲出以下代码：</p><pre>public class Test { public static void main(String[] args) { System.out.println("Hello world!"); }}</pre><p>没错，这就是经典的"Hello world"，这也是大多数人手工编写的第一个程序。</p><p>手工编写代码，更能体现一个程序员的基本素质。有很多公司，都把上机编程考试作为面试的重要手段之一。面试者需要根据题目的要求，挑选一款熟悉的编程工具（比如Eclipse），手工编写代码并调试运行通过。在整个过程中，不能通过网络搜索答案，不能查看联机帮助文档，要求面试者必须手工编写代码，主要是考察面试者手工编写代码的能力——语法、函数、逻辑、思维、算法以及动手能力。</p><p>手工编写代码，是一个优秀程序员必须具备的基础能力。手工编写代码正如提笔写文章，语法就是遣词造句的方法、函数就是组成文章的词句、类库就是据经引典的掌故、架构就是行文表述的体裁、功能就是写作文章的主旨、算法就是组织语言的逻辑……所以，只要掌握一门程序语言的语法、学习一堆基础类库的函数、引用一些所需的第三方类库、选择一款成熟稳定的架构、明确一下产品需求的功能、挑选一种实现逻辑的算法……手工编写代码就会像写文章一样手到擒来。</p><h1><strong>方法2：复制粘贴代码</strong></h1><p>常言道："熟读唐诗三百首，不会作诗也会吟。"编码也是同样的道理，编码的第一步就是模仿，简单地说就是"抄代码"——复制粘贴代码。复制粘贴代码是一门艺术，用好了编码会事半功倍。但是，没有检验过的东西，终究是不可全信的。当看到需要的代码时，在复制粘贴前，我们都需要仔细研读、认真思考、详细甄别……很多东西，都是仁者见仁、智者见智的东西，适合别的场景但不一定适合你的场景。作为一名合格的程序员，切不可一味地"拿来主义"。</p><p>1.为什么要复制粘贴代码</p><ul><li>复制粘贴现有代码，可以节省开发时间；</li><li>复制粘贴稳定代码，可以降低系统故障风险；</li><li>复制粘贴网络代码，可以把别人的成果化为己用。</li></ul><p>2.复制粘贴代码带来问题</p><ul><li>你对复制的代码理解程度是多少？实现逻辑是否合理？能不能稳定运行？存在多少潜在的 Bug?</li><li>这个代码在项目中已经复制粘贴了多少次？根据“三则重构”原则，你是否需要对这些相同代码进行重构？</li><li>代码被复制粘贴次数越多，带来的代码维护问题越多。多个代码版本的更改和修正，要保持这些代码的同步，就必须需要在每一处进行同样的修改，增加了维护的成本和风险。</li></ul><p>总之，复制粘贴代码，跟其它编码方法一样，没有优劣对错之分。它只是一种方法，你可以善用，也可以滥用。如果我们用到了复制粘贴，我们就必须为结果负责。</p><h1><strong>方法3：用文本替换生成代码</strong></h1><p>1.生成代码样例</p><p>已经编写好的用户查询相关代码：</p><pre>/** 查询用户服务函数 */public PageData&lt;UserVO&gt; queryUser(QueryUserParameterVO parameter) { Long totalCount = userDAO.countByParameter(parameter); List&lt;UserVO&gt; userList = null; if (Objects.nonNull(totalCount) &amp;&amp; totalCount.compareTo(0L) &gt; 0) { userList = userDAO.queryByParameter(parameter); } return new PageData&lt;&gt;(totalCount, userList);}/** 查询用户控制器函数 */@RequestMapping(path = "/queryUser", method = RequestMethod.POST)public Result&lt;PageData&lt;UserVO&gt;&gt; queryUser(@Valid @RequestBody QueryUserParameterVO parameter) { PageData&lt;UserVO&gt; pageData = userService.queryUser(parameter); return Result.success(pageData);}</pre><p>如果我们要编写公司查询相关代码，其代码形式与用户查询类似，整理出替换关系如下：</p><ul><li>把"用户"替换为"公司";</li><li>把"User"替换为"Company";</li><li>把"user"替换为"company"。</li></ul><p>利用 Notepad、EditPlus 等文本编辑器，选择区分大小写，进行普通文本替换，最终得到结果如下：</p><pre>/** 查询公司服务函数 */public PageData&lt;CompanyVO&gt; queryCompany(QueryCompanyParameterVO parameter) { Long totalCount = companyDAO.countByParameter(parameter); List&lt;CompanyVO&gt; companyList = null; if (Objects.nonNull(totalCount) &amp;&amp; totalCount.compareTo(0L) &gt; 0) { companyList = companyDAO.queryByParameter(parameter); } return new PageData&lt;&gt;(totalCount, companyList);}/** 查询公司控制器函数 */@RequestMapping(path = "/queryCompany", method = RequestMethod.POST)public Result&lt;PageData&lt;CompanyVO&gt;&gt; queryCompany(@Valid @RequestBody QueryCompanyParameterVO parameter) { PageData&lt;CompanyVO&gt; pageData = companyService.queryCompany(parameter); return Result.success(pageData);}</pre><p>利用文本替换生成代码，整段代码生成时间不会超过1分钟。</p><p>2.主要优缺点</p><p>主要优点：</p><ul><li>生成代码速度较快。</li></ul><p>主要缺点：</p><ul><li>必须编写样例代码；</li><li>只适用于文本替换的情景。</li></ul><h1><strong>方法4：用Excel公式生成代码</strong></h1><p>Excel 的公式非常强悍，可以用于编写一些公式化的代码。</p><p>1.利用 Excel 公式生成模型类</p><p>从 WIKI 上拷贝接口模型定义到 Excel 里，样例数据内容如下：</p><div class=pgc-img><img alt=这6种编码方法，你掌握了几个？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc625a07f5564bf39461eafdeacb339e><p class=pgc-img-caption></p></div><p>编写 Excel 公式如下：</p><pre>= "/** "&amp;D6&amp;IF(ISBLANK(F6), "", "("&amp;F6&amp;")")&amp;" */ "&amp;IF(E6 = "否", IF(C6 = "String", "@NotBlank", "@NotNull"), "")&amp;" private "&amp;C6&amp;" "&amp;B6&amp;";"</pre><p>利用公式生成代码如下：</p><pre>/** 用户标识 */ @NotNull private Long id;/** 用户名称 */ @NotBlank private String name;/** 用户性别(0:未知;1:男;2:女) */ @NotNull private Integer sex;/** 用户描述 */ private String description;</pre><p>创建模型类，整理代码如下：</p><pre>/** 用户DO类 */public class UserDO { /** 用户标识 */ @NotNull private Long id; /** 用户名称 */ @NotBlank private String name; /** 用户性别(0:未知;1:男;2:女) */ @NotNull private Integer sex; /** 用户描述 */ private String description; ......}</pre><p>2.利用 Excel 公式生成枚举类</p><p>从 WIKI 上拷贝枚举定义到 Excel 里，样例数据内容如下：</p><div class=pgc-img><img alt=这6种编码方法，你掌握了几个？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ad6ffb16c1f41dc910307dc288a2162><p class=pgc-img-caption></p></div><p>编写 Excel 公式如下：</p><pre>="/** "&amp;D2&amp;"("&amp;B2&amp;") */"&amp;C2&amp;"("&amp;B2&amp;", """&amp;D2&amp;"""),"</pre><p>利用公式生成代码如下：</p><pre>/** 空(0) */NONE(0, "空"),/** 男(1) */MAN(1, "男"),/** 女(2) */WOMAN(2, "女"),</pre><p>创建枚举类，整理代码如下：</p><pre>/** 用户性别枚举 */public enum UserSex { /** 枚举定义 */ /** 空(0) */ NONE(0, "空"), /** 男(1) */ MAN(1, "男"), /** 女(2) */ WOMAN(2, "女"); ......}</pre><p>3.利用 Excel 公式生成数据库语句</p><p>用 Excel 整理的公司列表如下，需要整理成 SQL 语句直接插入数据库：</p><div class=pgc-img><img alt=这6种编码方法，你掌握了几个？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/41a49b79d7c34653b852512d71d9a0ee><p class=pgc-img-caption></p></div><p>编写 Excel 公式如下：</p><pre>= "('"&amp;B2&amp;"', '"&amp;C2&amp;"', '"&amp;D2&amp;"', '"&amp;E2&amp;"'),"</pre><p>利用公式生成 SQL 如下：</p><pre>('高德', '首开大厦', '(010)11111111', 'gaode@xxx.com'),('阿里云', '绿地中心', '(010)22222222', 'aliyun@xxx.com'),('菜鸟', '阿里中心', '(010)33333333', 'cainiao@xxx.com'),</pre><p>添加 into 语句头，整理 SQL 如下：</p><pre>insert into t_company(name, address, phone, email) values('高德', '首开大厦', '(010)11111111', 'gaode@xxx.com'),('阿里云', '绿地中心', '(010)22222222', 'aliyun@xxx.com'),('菜鸟', '阿里中心', '(010)33333333', 'cainiao@xxx.com');</pre><p>4.主要优缺点</p><p>主要优点：</p><ul><li>适用于表格化数据的代码生成；</li><li>写好公式后，拖拽生成代码，生成速度较快。</li></ul><p>主要缺点：</p><ul><li>不适用于复杂功能的代码生成。</li></ul><h1><strong>方法5：用工具生成代码</strong></h1><p>用工具生成代码，顾名思义就是借用已有的工具生成代码。很多开发工具都提供一些工具生成代码，比如：生成构造函数，重载基类/接口函数，生成 Getter/Setter 函数，生成 toString 函数……能够避免很多手敲代码。还有一些生成代码插件，也可以生成满足某些应用场景的代码。</p><p>这里以 mybatis-generator 插件生成代码为例，介绍如何利用工具生成代码。</p><p>1.安装运行插件</p><p>具体方法这里不再累述，自行上网搜索文档了解。</p><p>2.生成代码样例</p><p>| 2.1.生成模型类代码</p><p>文件 User.java 内容：</p><pre>......public class User { private Long id; private String user; private String password; private Integer age; ......}</pre><p>| 2.2.生成映射接口代码</p><p>文件 UserMapper.java 内容：</p><pre>......public interface UserMapper { User selectByPrimaryKey(Long id); ......}</pre><p>| 2.3.生成映射XML代码</p><p>文件 UserMapper.xml 内容：</p><pre>......&lt;mapper namespace="com.test.dao.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.test.pojo.User" &gt; &lt;id column="id" property="id" jdbcType="BIGINT" /&gt; &lt;result column="user" property="user" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="age" property="age" jdbcType="INTEGER" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; id, user, password, age &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Long" &gt; select &lt;include refid="Base_Column_List" /&gt; from test_user where id = #{id,jdbcType=BIGINT} &lt;/select&gt; ......&lt;/mapper&gt;</pre><p>3.主要优缺点</p><p>主要优点：</p><ul><li>利用生成代码插件，生成代码速度较快；</li><li>利用插件配置文件，控制生成想要的功能代码。</li></ul><p>主要缺点：</p><ul><li>需要时间研究和熟悉生成代码插件的使用；</li><li>生成的代码不一定满足代码规范，每次生成后需进行代码合规；</li><li>重新生成代码后，容易覆盖自定义代码（建议维护单独的生成代码库，通过DIFF 工具比较代码差异，然后再赋值粘贴差异代码）。</li></ul><h1><strong>方法6：用代码生成代码</strong></h1><p>用代码生成代码，就是自己编写代码，按照自己的格式生成代码。下面，以生成基于 MyBatis 的数据库访问代码为例说明。</p><p>1.查询表格信息</p><p>首先，我们要从数据库中拿到我们生成代码所需要的表和列相关信息。</p><p>| 1.1.查询表信息</p><p>查询表信息语句：</p><pre>select t.table_name as '表名称', t.table_comment as '表备注'from information_schema.tables twhere t.table_schema = ?and t.table_type = 'BASE TABLE'and t.table_name = ?;</pre><p>其中，第1个问号赋值数据库名称，第2个问号赋值表名称。</p><p>查询表信息结果：</p><div class=pgc-img><img alt=这6种编码方法，你掌握了几个？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b8d46c70f2334c8eb8ddcfe0c3c4ffb7><p class=pgc-img-caption></p></div><p>| 1.2.查询列信息</p><p>查询列信息语句：</p><pre>select c.column_name as '列名称', c.column_comment as '列备注', c.data_type as '数据类型', c.character_maximum_length as '字符长度', c.numeric_precision as '数字精度', c.numeric_scale as '数字范围', c.column_default as '', c.is_nullable as '是否可空', c.column_key as '列键名'from information_schema.columns cwhere c.table_schema = ?and c.table_name = ?order by c.ordinal_position;</pre><p>其中，第1个问号赋值数据库名称，第2个问号赋值表名称。</p><p>查询列信息结果：</p><div class=pgc-img><img alt=这6种编码方法，你掌握了几个？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/85390954434b4d23b53c41f188ec7a2c><p class=pgc-img-caption></p></div><p>2.编写生成代码</p><p>| 2.1.编写生成模型类代码</p><pre>/** 生成模型类文件函数 */private void generateModelClassFile(File dir, Table table, List&lt;Column&gt; columnList) throws Exception { try (PrintWriter writer = new PrintWriter(new File(dir, className + "DO.java"))) { String className = getClassName(table.getTableName()); String classComments = getClassComment(table.getTableComment()); writer.println("package " + groupName + "." + systemName + ".database;"); ...... writer.println("/** " + classComments + "DO类 */"); writer.println("@Getter"); writer.println("@Setter"); writer.println("@ToString"); writer.println("public class " + className + "DO {"); for (Column column : columnList) { String fieldType = getFieldType(column); String fieldName = getFieldName(column.getColumnName()); String fieldComment = getFieldComment(column); writer.println("\t/** " + fieldComment + " */"); writer.println("\tprivate " + fieldType + " " + fieldName + ";"); } writer.println("}"); }}</pre><p>| 2.2.编写生成 DAO 接口代码</p><pre>/** 生成DAO接口文件函数 */private void generateDaoInterfaceFile(File dir, Table table, List&lt;Column&gt; columnList, List&lt;Column&gt; pkColumnList) throws Exception { try (PrintWriter writer = new PrintWriter(new File(dir, className + "DAO.java"))) { String className = getClassName(table.getTableName()); String classComments = getClassComment(table.getTableComment()); writer.println("package " + groupName + "." + systemName + ".database;"); ...... writer.println("/** " + classComments + "DAO接口 */"); writer.println("public interface " + className + "DAO {"); writer.println("\t/** 获取" + classComments + "函数 */"); writer.print("\tpublic " + className + "DO get("); boolean isFirst = true; for (Column pkColumn : pkColumnList) { if (!isFirst) { writer.print(", "); } else { isFirst = false; } String fieldType = getFieldType(pkColumn); String fieldName = getFieldName(pkColumn.getColumnName()); writer.print("@Param(\"" + fieldName + "\") " + fieldType + " " + fieldName); } writer.println(");"); ...... writer.println("}"); }}</pre><p>| 2.3.编写生成 DAO 映射代码</p><pre>/** 生成DAO映射文件函数 */private void generateDaoMapperFile(File dir, Table table, List&lt;Column&gt; columnList, List&lt;Column&gt; pkColumnList) throws Exception { try (PrintWriter writer = new PrintWriter(new File(dir, className + "DAO.xml"))) { String className = getClassName(table.getTableName()); String classComments = getClassComment(table.getTableComment()); writer.println("&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"); ...... writer.println("&lt;!-- " + classComments + "映射 --&gt;"); writer.println("&lt;mapper namespace=\"" + groupName + "." + systemName + ".database." + className + "DAO\"&gt;"); writer.println("\t&lt;!-- 所有字段语句 --&gt;"); writer.println("\t&lt;sql id=\"fields\"&gt;"); if (CollectionUtils.isNotEmpty(columnList)) { boolean isFirst = true; String columnName = getColumnName(pkColumn.getColumnName()); for (Column column : columnList) { if (isFirst) { isFirst = false; writer.println("\t\t" + columnName); } else { writer.println("\t\t, " + columnName); } } } writer.println("\t&lt;/sql&gt;"); writer.println("\t&lt;!-- 获取" + classComments + "函数语句 --&gt;"); writer.println("\t&lt;select id=\"get\" resultType=\"" + groupName + "." + systemName + ".database." + className + "DO\"&gt;"); writer.println("\t\tselect"); writer.println("\t\t&lt;include refid=\"fields\"/&gt;"); writer.println("\t\tfrom " + table.getTableName()); boolean isFirst = true; for (Column pkColumn : pkColumnList) { String columnName = getColumnName(pkColumn.getColumnName()); String fieldName = getFieldName(pkColumn.getColumnName()); writer.print("\t\t"); if (isFirst) { writer.print("where"); isFirst = false; } else { writer.print("and"); } writer.println(" " + columnName + " = #{" + fieldName + "}"); } writer.println("\t&lt;/select&gt;"); writer.println("&lt;/mapper&gt;"); }}</pre><p>3.生成相关代码</p><p>| 3.1.生成的模型类代码</p><pre>/** 组织公司DO类 */@Getter@Setter@ToStringpublic class OrgCompanyDO { /** 公司标识 */ private Long id; /** 公司名称 */ private String name; /** 联系地址 */ private String address; /** 公司描述 */ private String description;}</pre><p>| 3.2.生成的 DAO 接口代码</p><pre>/** 组织公司DAO接口 */public interface OrgCompanyDAO { /** 获取组织公司函数 */ public OrgCompanyDO get(@Param("id") Long id);}</pre><p>| 3.3.生成的 DAO 映射代码</p><pre>&lt;!-- 组织公司映射 --&gt;&lt;mapper namespace="xxx.database.OrgCompanyDAO"&gt; &lt;!-- 所有字段语句 --&gt; &lt;sql id="fields"&gt; id , name , address , description &lt;/sql&gt; &lt;!-- 获取组织公司函数语句 --&gt; &lt;select id="get" resultType="xxx.database.OrgCompanyDO"&gt; select &lt;include refid="fields"/&gt; from org_company where id = #{id} &lt;/select&gt;&lt;/mapper&gt;</pre><p>3.主要优缺点</p><p>主要优点：</p><ul><li>代码格式可以定制，保证生成代码合规；</li><li>代码功能可以定制，只生成需要的代码；</li><li>经过前期代码沉淀后，后期能够直接使用。</li></ul><p>主要缺点：</p><ul><li>需要研究数据来源，保证能获取到生成代码所需的数据；</li><li>需要建立数据模型、编写生成代码，耗费时间比较长。</li></ul><h1><strong>终极方法：无招胜有招</strong></h1><p>编码的终极方法，是不是直接对着电脑说需求，然后电脑就自动生成代码了？未来科技发展到一定水平后，这种情况或许会变成现实。但是，目前这种情况是不现实的。现实中，想要做到"大口一张、代码就来"，除非你是老板、产品经理或者技术管理者。</p><p>编码的终极方法是“无招胜有招”，"无招"并不是不讲究"招式"，而是不拘泥于某一"招式"，信手拈来合适的"招式"为宜。本文中列举的各种编码方法，没有高低优劣之分，只有合不合适之说。所以，灵活地运用各种编码方法，就是编码的终极方法。</p><h1><strong>代码规范化</strong></h1><p>在上面的各种编码方法中，很多方法都需要手工编写样例代码。如果你的代码不遵循代码规范，就很难发现代码之间的共性，并抽象出能够作为标准的样例代码；如果作为标准的样例代码不满足代码规范，必然导致生成的代码也不满足代码规范，于是把这些不规范放大了十倍、百倍甚至千倍。所以，代码规范化是编码的重中之重。</p><p>作者：陈昌毅</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'种编码','几个','掌握'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>