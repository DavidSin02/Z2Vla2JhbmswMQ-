<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java8的Stream全解析 | 极客快訊</title><meta property="og:title" content="java8的Stream全解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/85c2842d59284b6bbc86952a03632c60"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/abf54574.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/abf54574.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/abf54574.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/abf54574.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/abf54574.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/abf54574.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/abf54574.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/abf54574.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="java8的Stream全解析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/abf54574.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java8的Stream全解析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=rich_media_title>Lambda表达式</h2><p>先从基础的lamda表达式开始讲起</p><p>java8新增的语言级特性,和javascript等函数式编程语言不同。在java中，lambda表达式依然是一个对象。它必须依附于一种特殊的对象类型functional interface。（称为方法引用或者函数式接口）</p><h4 class=rich_media_title>语法</h4><pre><code>(arg1, arg2...) -&gt; { body }(type1 arg1, type2 arg2...) -&gt; { body }</code></pre><ol start=0><li>简单的说，可以看成是没有访问修饰符、返回值声明和名字的方法</li><li>参数类型可以省略，自动推断</li><li>只有一个参数时，（）可以省略</li><li>匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li><li>函数体，只有一条语句时，可省略{}</li><li>每个 Lambda 表达式都能隐式地赋值给函数式接口比如 Runnable就是一个函数式接口(用@FunctionalInterface注解修饰)Runnable r = () -> System.out.println("hello world");</li><li>当不指明函数式接口时，编译器会自动解释这种转化new Thread( () -> System.out.println("hello world")).start();</li></ol><h4 class=rich_media_title>双冒号(::)操作符</h4><p>另一种将常规方法转化为 Lambda 表达式的方法</p><h4 class=rich_media_title>与匿名类的区别</h4><p>一大区别在于关键词的使用。</p><p>对于匿名类，关键词 this 解读为匿名类，而对于 Lambda 表达式，关键词 this 解读为使用 Lambda 的外部类。</p><p>另一不同在于两者的编译方法。</p><p>Java 编译器编译 Lambda 表达式并将他们转化为类里面的私有函数，它使用 Java 7 中新加的 invokedynamic 指令动态绑定该方法</p><p><br></p><h3 class=rich_media_title>方法引用或函数接口</h3><p>上面提到了一个注解FunctionalInterface,可翻译为方法引用或函数接口.</p><p>java8新增,用于指明该接口类型声明是根据 Java 语言规范定义的函数式接口。函数式接口只能有一个抽象方法</p><pre><code>//定义一个函数式接口@FunctionalInterfacepublic interface WorkerInterface {  public void doSomeWork();}public class WorkerInterfaceTest {public static void execute(WorkerInterface worker) {  worker.doSomeWork();}public static void main(String [] args) {  //使用匿名类的写法  execute(new WorkerInterface() {      @Override      public void doSomeWork() {          System.out.println("Worker invoked using Anonymous class");      }  });  //使用lambda表达式  execute( () -&gt; System.out.println("Worker invoked using Lambda expression") );}}</code></pre><p><br></p><div class=pgc-img><img alt=java8的Stream全解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/85c2842d59284b6bbc86952a03632c60><p class=pgc-img-caption></p></div><p><br></p><h3 class=rich_media_title>常用API</h3><h4 class=rich_media_title>Collection接口的</h4><p>Collection接口提供了 stream()方法</p><p>我们执行的任何操作都不会对源集合造成影响，你可以同时在一个集合上提取出多个 stream 进行操作。</p><h4 class=rich_media_title>静态方法</h4><h6 class=rich_media_title>of</h6><p>构造一个Stream对象</p><pre><code>Stream&lt;String&gt; s1 = Stream.of("a", "b");</code></pre><h6 class=rich_media_title>empty</h6><p>创建一个空的 Stream 对象。</p><h6 class=rich_media_title>contact</h6><p>连接两个 Stream ，不改变其中任何一个 Steam 对象，返回一个新的 Stream 对象。</p><pre><code>Stream&lt;String&gt; s1 = Stream.of("a", "b");Stream&lt;String&gt; s2 = Stream.of("c", "d");Stream&lt;String&gt; s3 = Stream.concat(s1, s2);</code></pre><h6 class=rich_media_title>generate</h6><p>创建一个无限Stream，一般用于随机数生成</p><pre><code>Stream&lt;Double&gt; s5 = Stream.generate(Math::random);</code></pre><h6 class=rich_media_title>iterate</h6><p>创建一个无限Stream。可以添加初始元素和生产规则</p><pre><code>Stream&lt;Integer&gt; s4 = Stream.iterate(1, n -&gt; n + 2);</code></pre><p><br></p><h4 class=rich_media_title>实例方法</h4><h5 class=rich_media_title>返回Stream的</h5><h6 class=rich_media_title>peek</h6><p>对其中每个元素进行处理，返回的是一个新的Stream</p><p>主要用于debug使用，打印下当前元素</p><h6 class=rich_media_title>map</h6><p>一般用这个对每个元素进行处理。比如从一个类型，转换为另一个类型</p><pre><code>List&lt;String&gt; stringList = integerStream.map(n -&gt; "我是" + n).collect(Collectors.toList());</code></pre><h6 class=rich_media_title>peek和map的区别</h6><p>peek一般只用于debug，打印一下信息使用</p><p>peek的参数的Consumer接口,它是没有返回值的</p><pre><code>@FunctionalInterfacepublic interface Consumer&lt;T&gt; {  void accept(T t);</code></pre><p>map的参数是Function接口,必须给返回值</p><pre><code>@FunctionalInterfacepublic interface Function&lt;T, R&gt; {  R apply(T t);</code></pre><h6 class=rich_media_title>还有一个疑问</h6><pre><code>integerStream.peek或者map(item -&gt;        System.out.println("========="));</code></pre><p>这一句话的打印是不会执行的，没有后面的collect等终止就不会执行.</p><p>也就是说，流方法真正执行是在终止方法触发</p><h6 class=rich_media_title>mapToInt</h6><p>将元素转换成int类型，后面一般跟sum,max，min,average</p><h6 class=rich_media_title>mapToLong</h6><p>略</p><h6 class=rich_media_title>mapToDouble</h6><p>略</p><h6 class=rich_media_title>limit</h6><p>限制个数</p><h6 class=rich_media_title>distinct</h6><p>去重功能。判断是根据元素的equals方法和hashCode方法。(两个都需要重写)</p><p>基本元素</p><pre><code>Stream&lt;Integer&gt; integerStream = Stream.of(2, 5, 100, 5);List&lt;Integer&gt; collect = integerStream.distinct().collect(Collectors.toList());System.out.println(JSONUtil.toJsonStr(collect));</code></pre><p>[2,5,100]</p><p>对象</p><pre><code>@Getter@Setterclass User {  private String name;  private int age;}@Testpublic void distinct() {  User a = new User();  a.setName("yun");  a.setAge(20);  User b = new User();  b.setName("yun");  b.setAge(20);  Stream&lt;User&gt; userStream = Stream.of(a, b);  List&lt;User&gt; userList = userStream.distinct().collect(Collectors.toList());  System.out.println(JSONUtil.parse(userList));}</code></pre><p>只写了getter/setter方法时</p><blockquote><p>[{"name":"yun","age":20},{"name":"yun","age":20}]</p></blockquote><p>加上@EqualsAndHashCode</p><blockquote><p>[{"name":"yun","age":20}]</p></blockquote><p><br></p><h6 class=rich_media_title>sorted</h6><p>排序,基本元素可以使用默认排序方法</p><pre><code>Stream&lt;String&gt; strStream = Stream.of("ba", "bb", "aa", "ab");strStream.sorted().forEach(item -&gt; System.out.println(item));</code></pre><blockquote><p>aa ab ba bb</p></blockquote><p>也可自定义排序方法</p><p>自定义根据第二个字母排序</p><pre><code>      Stream&lt;String&gt; strStream = Stream.of("ba", "bb", "aa", "ab");      Comparator&lt;String&gt; comparator = (x, y) -&gt; x.substring(1).compareTo(y.substring(1));      strStream.sorted(comparator).forEach(item -&gt; System.out.println(item));</code></pre><blockquote><p>ba aa bb ab</p></blockquote><h6 class=rich_media_title>filter</h6><p>过滤</p><pre><code>Stream&lt;Integer&gt; integerStream = Stream.of(2, 5, 100, 5);integerStream.filter(item -&gt; item &gt; 10).forEach(item -&gt; System.out.println(item));</code></pre><blockquote><p>100</p></blockquote><p><br></p><h5 class=rich_media_title>终止类型的方法</h5><h6 class=rich_media_title>max</h6><p>获取Stream中的最大值</p><pre><code>Stream&lt;Integer&gt; integerStream = Stream.of(2, 5, 100, 5);Integer max = integerStream.max(Integer::compareTo).get();</code></pre><h6 class=rich_media_title>min</h6><p>获取最小值</p><h6 class=rich_media_title>findFirst</h6><p>获取第一个元素</p><pre><code>Integer i = integerStream.findFirst().get();</code></pre><h6 class=rich_media_title>findAny</h6><p>随机获取一个元素。串行情况下，就是第一个。并行不一定，先获取谁就是谁。</p><h6 class=rich_media_title>count</h6><p>返回流中元素个数</p><pre><code>long count = integerStream.count();</code></pre><p><br></p><h6 class=rich_media_title>collection</h6><p>将最终的Stream汇总为collection,Collectors已经为我们提供了很多拿来即用的收集器。经常用到Collectors.toList()、Collectors.toSet()、Collectors.toMap()。</p><p>另外高级用法还有比如Collectors.groupingBy()用来分组</p><pre><code>// 返回 userId:List&lt;User&gt;Map&lt;String,List&lt;User&gt;&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId));// 返回 userId:每组个数Map&lt;String,Long&gt; map = user.stream().collect(Collectors.groupingBy(User::getUserId,Collectors.counting()));</code></pre><h6 class=rich_media_title>toArray</h6><p>collection是返回列表、map 等，toArray是返回数组</p><pre><code>      Stream&lt;Integer&gt; integerStream = Stream.of(2, 5, 100, 5);      // Object[] objects = integerStream.toArray();      Integer[] toArray = integerStream.toArray(Integer[]::new);</code></pre><p>如果无参,是返回Object数组.可以加参数Integer[]::new,可以返回Integer数组</p><h6 class=rich_media_title>forEach</h6><p>也是对每一个元素进行处理</p><p>和map的区别是，forEach不会返回Stream，直接消费掉了</p><h6 class=rich_media_title>forEachOrdered</h6><p>功能与 forEach是一样的，不同的是，forEachOrdered是有顺序保证的，也就是对 Stream 中元素按插入时的顺序进行消费。</p><p>在使用并行的时候，两者会有区别。</p><h6 class=rich_media_title>reduce</h6><p>具体可以学习map/reduce计算模型.</p><pre><code>Stream&lt;Integer&gt; integerStream = Stream.of(1,2,3);      Integer sum = integerStream.reduce(100, (x, y) -&gt; x + y);      System.out.println(sum);</code></pre><p>提供初始值100,然后开始累加</p><blockquote><p>106</p></blockquote><p>我们直接使用reduce较少,但是Collectors好多方法都用到了 reduce，比如 groupingBy、minBy、maxBy等等。</p><p><br></p><h4 class=rich_media_title>并行方法</h4><p>创建并行Stream</p><pre><code>Stream.of(1,2,3).parallel();或List&lt;Integer&gt; src = Arrays.asList(1, 2, 3);Stream&lt;Integer&gt; integerStream = src.parallelStream();</code></pre><p>并行 Stream和普通Stream支持的api基本一样</p><p>并行 Stream 默认使用 ForkJoinPool线程池，当然也支持自定义，不过一般情况下没有必要。ForkJoin 框架的分治策略与并行流处理正好契合。</p><p>虽然并行这个词听上去很厉害，但并不是所有情况使用并行流都是正确的，很多时候完全没这个必要。</p><p>比如</p><pre><code>      Stream&lt;Integer&gt; integerStream = Stream.of(1,2,3).parallel();      Integer sum = integerStream.reduce(100, (x, y) -&gt; x + y);      System.out.println(sum);</code></pre><p>这个结果就变成306了</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'java8','Stream','解析'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>