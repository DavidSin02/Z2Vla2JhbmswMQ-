<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据库技术：MySQL 基础和 SQL 入门，单表、约束和事务 | 极客快訊</title><meta property="og:title" content="数据库技术：MySQL 基础和 SQL 入门，单表、约束和事务 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ad3f3a1e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ad3f3a1e.html><meta property="article:published_time" content="2020-11-14T21:08:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:11+08:00"><meta name=Keywords content><meta name=description content="数据库技术：MySQL 基础和 SQL 入门，单表、约束和事务"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ad3f3a1e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据库技术：MySQL 基础和 SQL 入门，单表、约束和事务</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="数据库技术：MySQL 基础和 SQL 入门，单表、约束和事务" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>Introduction to MySQL and SQL</h1><p><br></p><h1 class=pgc-h-arrow-right>Basic Concepts</h1><h1 class=pgc-h-arrow-right>What is Database?</h1><ul><li>数据库就是存储和管理数据的仓库。</li><li>数据库是一个文件系统。它以文件的方式将数据保存在电脑上。</li></ul><blockquote class=pgc-blockquote-abstract><p>想了解更多，欢迎关注我的微信公众号：Renda_Zhang</p></blockquote><h1 class=pgc-h-arrow-right>Why Should We Use Database?</h1><p>Comparison among different ways of storing data：</p><p>内存</p><ul><li>优点：速度快。</li><li>缺点：不能永久保存，数据是临时状态的。</li></ul><p>文件</p><ul><li>优点：数据是可以永久保存。</li><li>缺点：使用 IO 流操作文件，所以不方便。</li></ul><p>数据库</p><ul><li>优点：1. 数据可以永久保存；2. 方便存储和管理数据；3. 使用统一的方式操作数据库。</li><li>缺点：占用资源，有些数据库需要付费，如 Oracle 数据库。</li></ul><p>Conclusion: By using Database, it greatly improves user experience for Data Manipulations, such as Adding, Deleting, or Querying data.</p><h1 class=pgc-h-arrow-right>Common Database Software</h1><p>MySQL 数据库：开源免费的数据库。操作简单，常作为中小型的项目的数据库首选，但是被 Oracle 公司收购后，MySQL 6.x 开始收费。</p><p>Oracle 数据库：收费的大型数据库，Oracle 公司的核心产品。安全性高。</p><p>DB2：收费的超大型数据库，IBM 公司的数据库产品。常在银行系统使用。</p><p>SQL Server：收费的中型数据库，微软公司的产品。常用在 C#，.net 等语言。该数据库只能运行在 Windows 机器上；扩展性，稳定性，安全性，性能都表现平平。</p><h1 class=pgc-h-arrow-right>Why Do We Choose MySQL as the Database Software?</h1><ul><li>功能强大，可以用于 Web 应用开发。</li><li>开源，免费。</li></ul><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right>使用 MySQL</h1><h1 class=pgc-h-arrow-right>下载安装 MySQL，并配置好相应的环境变量</h1><h1 class=pgc-h-arrow-right>使用 Windows 服务或者 DOS 命令方式启动 MySQL 服务</h1><h1 class=pgc-h-arrow-right>使用命令行管理数据库</h1><pre><code>mysql -u用户名 -p密码mysql -h主机IP -u用户名 -p密码</code></pre><h1 class=pgc-h-arrow-right>使用 SQLyog 图形化软件管理登录 MySQL 数据库</h1><h1 class=pgc-h-arrow-right>MySQL Directory Structure</h1><h1 class=pgc-h-arrow-right>MySQL Installation Directory</h1><ul><li>bin：放置一些可执行文件</li><li>docs: 文档</li><li>include: 包含（头）文件</li><li>lib: 依赖库</li><li>share: 用于存放字符集、语言等信息</li></ul><h1 class=pgc-h-arrow-right>MySQL Configuration File and the Directory of Databases and Data Tables</h1><ul><li>my.ini 文件：是 MySQL 的配置文件，一般不建议去修改。</li><li>Data 目录：MySQL 管理的数据库文件所在的目录，保存的就是数据库（文件夹）与数据表（文件）的信息。</li></ul><h1 class=pgc-h-arrow-right>Database Management System</h1><p>数据库管理系统指一种操作和管理维护数据库的大型软件。</p><p>MySQL 就是一个 数据库管理系统软件，安装了 MySQL 的电脑，我们叫它数据库服务器。</p><p>数据库管理系统用于建立、使用和维护数据库，对数据库进行统一的管理。</p><p>MySQL 中管理着很多数据库，在实际开发环境中 一个数据库一般对应了一个的应用，数据库当中保存着多张表，每一张表对应着不同的业务，表中保存着对应业务的数据。</p><ul><li>安装了 MySQL 软件的电脑被称为 MySQL 服务器</li><li>MySQL 中管理着多个数据库</li><li>数据库中包含多张表</li><li>表中包含多条数据</li><li>客户端（命令行或 SQLyog）通过网络访问（服务器地址 : 端口）MySQL 服务器</li></ul><h1 class=pgc-h-arrow-right>Database Tables</h1><h1 class=pgc-h-arrow-right>数据库中以表为组织单位存储数据</h1><h1 class=pgc-h-arrow-right>表类似 Java 中的类,每个字段都有对应的数据类型</h1><h1 class=pgc-h-arrow-right>对比 Java 程序与关系型数据库</h1><ul><li>类 = 表</li><li>类中属性 = 表中字段</li><li>对象 = 数据记录</li></ul><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right>SQL</h1><h1 class=pgc-h-arrow-right>SQL Concept</h1><p>SQL - Structured Query Language，是一种特殊目的的编程语言，是一种数据库查询和程序设计语言，用于存取数据以及查询、更新和管理关系数据库系统。</p><p>Functions of SQL:</p><ul><li>是所有关系型数据库的统一查询规范，不同的关系型数据库都支持 SQL</li><li>所有的关系型数据库都可以使用 SQL</li><li>不同数据库之间的 SQL 有一些区别方言</li></ul><h1 class=pgc-h-arrow-right>SQL Syntax</h1><p>SQL 语句可以单行或者多行书写，以分号结尾 ; （Sqlyog 中可以不用写分号，但建议加上）</p><p>可以使用空格和缩进来增加语句的可读性。</p><p>MySQL 中使用 SQL 不区分大小写，一般关键字大写，数据库名表名列名小写。</p><p>MySQL 注释方式：</p><pre><code># show databases;  单行注释-- show databases; 单行注释/*    多行注释    show databases;*/</code></pre><h1 class=pgc-h-arrow-right>SQL 的分类</h1><p>DDL - Data Deﬁnition Language：数据定义语言，用来定义数据库对象：数据库，表，列等。</p><p>DML - Data Manipulation Language：数据操作语言，用来对数据库中表的记录进行更新。</p><p>DQL - Data Query Language：数据查询语言，用来查询数据库中表的记录。</p><p>DCL - Date Control Language：数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户。</p><pre><code>/*     CRUD    C - create    R - retrieve    U - update    D - delete*/</code></pre><h1 class=pgc-h-arrow-right>DDL - Define Database</h1><h1 class=pgc-h-arrow-right>MySQL Built-in Database</h1><p>information_schema：信息数据库，保存的是其它数据库的信息</p><p>mysql：MySQL 核心数据库，保存的是用户和权限</p><p>performance_schema：保存性能相关的数据，监控 MySQL 的性能</p><p>sys：记录了 DBA（Database Administrator） 所需要的一些信息，更方便地让 DBA 快速了解数据库的运行情况。</p><h1 class=pgc-h-arrow-right>Create Database</h1><pre><code>/*    方式1 直接指定数据库名进行创建    默认数据库字符集为：latin1*/CREATE DATABASE db1; /*    方式2 指定数据库名称，指定数据库的字符集    一般都指定为 utf8,与Java中的编码保持一致*/CREATE DATABASE db1_1 CHARACTER SET utf8;</code></pre><p>create database 数据库名; -- 创建指定名称的数据库。</p><p>create database 数据库名 character set 字符集; -- 创建指定名称的数据库，并且指定字符集（一般都指定 UTF-8）。</p><h1 class=pgc-h-arrow-right>Show Database</h1><pre><code>-- 切换数据库 从db1 切换到 db1_1USE db1_1;-- 查看当前正在使用的数据库SELECT DATABASE();-- 查看Mysql中有哪些数据库SHOW DATABASES;-- 查看一个数据库的定义信息SHOW CREATE DATABASE db1_1;</code></pre><p>use 数据库; -- 切换数据库</p><p>select database(); -- 查看当前正在使用的数据库</p><p>show databases; -- 查看 MySQL 中都有哪些数据库</p><p>show create database 数据库名; -- 查看一个数据库的定义信息</p><h1 class=pgc-h-arrow-right>Alter Database</h1><pre><code>-- 将数据库db1 的字符集 修改为 utf8ALTER DATABASE db1 CHARACTER SET utf8;-- 查看当前数据库的基本信息，发现编码已更改SHOW CREATE DATABASE db1;</code></pre><p>alter database 数据库名 character set 字符集; -- 数据库的字符集修改操作</p><h1 class=pgc-h-arrow-right>Drop Database</h1><pre><code>-- 删除某个数据库DROP DATABASE db1_1;</code></pre><p>drop database 数据库名; -- 从 MySQL 中永久的删除某个数据库</p><h1 class=pgc-h-arrow-right>DDL - Define Table</h1><h1 class=pgc-h-arrow-right>MySQL Data Type</h1><p>常用数据类型</p><ul><li>int（整型），double（浮点型）</li><li>char（字符串型 固定长度），varchar（字符串型 只使用字符串长度所需的空间），text（字符串型 存储文本）</li><li>date（日期类型 yy-MM-dd），datetime（日期类型 yyyy-MM-dd HH:mm:ss），timestamp（日期类型 自动存储记录修改时间）</li></ul><h1 class=pgc-h-arrow-right>Create Table</h1><pre><code>-- 创建测试表CREATE TABLE test1(    tid INT,    tname VARCHAR(20),    tdate DATE -- 注意最后不要加逗号);-- 创建一个表结构与 test1 相同的 test2表CREATE TABLE test2 LIKE test1;-- 查看表结构DESC test2;</code></pre><h1 class=pgc-h-arrow-right>Show Table</h1><pre><code>-- 查看当前数据库中的所有表名SHOW TABLES;-- 显示当前数据表的结构DESC test1;-- 查看创建表的 SQL 语句SHOW CREATE TABLE test1;</code></pre><h1 class=pgc-h-arrow-right>Drop Table</h1><pre><code>-- 直接删除 test1 表DROP TABLE test1;-- 先判断 再删除 test2 表DROP TABLE IF EXISTS test2;</code></pre><h1 class=pgc-h-arrow-right>Alter Table</h1><pre><code>--  将 category 表改为 category1RENAME TABLE category TO category1;-- 将 category 表的字符集 修改为 gbkalter table category character set gbk;-- 为分类表添加一个新的字段为分类描述 cdesc varchar(20)ALTER TABLE category ADD cdesc VARCHAR(20);-- 对分类表的描述字段进行修改，类型 varchar(50) ALTER TABLE category MODIFY cdesc VARCHAR(50);-- 对分类表中的 desc 字段进行更换, 更换为 cdesc2 varchar(30)ALTER TABLE category CHANGE cdesc cdesc2 VARCHAR(30);--  删除分类表中 cdesc2 列ALTER TABLE category DROP cdesc2;</code></pre><h1 class=pgc-h-arrow-right>Data Manipulation Language</h1><pre><code># 创建学生表CREATE TABLE student(    sid INT, # 学员ID    sname VARCHAR(20), # 姓名    age INT, # 年龄    sex CHAR(1), # 性别    address VARCHAR(40) # 地址);</code></pre><h1 class=pgc-h-arrow-right>Insert Data</h1><pre><code>-- 插入全部字段，将所有字段名都写出来INSERT INTO student (sid,sname,age,sex,address)     VALUES(1,'张人大',20,'男','广州');-- 插入全部字段，不写字段名INSERT INTO student     VALUES(2,'李小明',10,'男','上海');-- 插入指定字段的值，必须要写上列名INSERT INTO student (sid, sname)     VALUES(3,'周小红');-- 如果插入空值，可以忽略不写或者写 nullINSERT INTO student (sid,sname)     VALUES(4,'赵四');INSERT INTO student (sid,sname,age,sex,address)     VALUES(5,'钱五',NULL,NULL,NULL);</code></pre><h1 class=pgc-h-arrow-right>Update Data</h1><pre><code>-- 不带条件修改，将所有的性别改为女，慎用UPDATE student SET sex = '女';-- 带条件的修改，将 sid 为 3 的学生，性别改为女UPDATE student SET sex = '女' WHERE sid = 3;-- 一次修改多个列， 将 sid 为 2 的学员，年龄改为 18，地址改为北京UPDATE student     SET age = 18, address = '北京' WHERE sid = 2;</code></pre><h1 class=pgc-h-arrow-right>Delete Data</h1><pre><code>-- 删除 sid 为 1 的数据DELETE FROM student WHERE sid = 1;-- 删除所有数据方法一：有多少条记录，就执行多少次删除操作，效率低DELETE FROM student;-- 删除所有数据方法二：先删除整张表，然后再重新创建一张一模一样的表，效率高truncate table student;</code></pre><h1 class=pgc-h-arrow-right>Data Query Language</h1><pre><code>-- 创建员工表CREATE TABLE emp(    eid INT,    ename VARCHAR(20),    sex CHAR(1),    salary DOUBLE,    hire_date DATE,    dept_name VARCHAR(20));-- 添加数据...</code></pre><h1 class=pgc-h-arrow-right>Simple Query</h1><pre><code>-- 查询 emp 中的所有数据，使用 * 表示所有列SELECT * FROM emp;-- 查询 emp 表中的所有记录，仅显示 id 和 name 字段SELECT eid, ename FROM emp;-- 别名查询，使用关键字 as 为列起别名SELECT     eid AS '编号',    ename AS '姓名' ,    sex AS '性别',    salary AS '薪资',    hire_date '入职时间', -- AS 可以省略    dept_name '部门名称'FROM emp;-- 使用distinct 关键字,去掉重复部门信息SELECT DISTINCT dept_name FROM emp;-- 运算查询，查询结果参与运算SELECT ename, salary + 1000 FROM emp;SELECT     ename AS '姓名',     salary + 1000 AS '薪资' FROM emp;</code></pre><h1 class=pgc-h-arrow-right>Conditional Query</h1><p>比较运算符</p><ul><li>> &lt; &lt;= >= = 大于、小于、小于等于、大于等于、等于</li><li>&lt;>，!= 不等于</li><li>BETWEEN ... AND ... 显示在某一区间的值</li><li>IN (集合) 集合表示多个值，使用逗号分隔，in 中的每个数据都会作为一次条件，只要满足条件就会显示</li><li>LIKE '%张%' 模糊查询</li><li>IS NULL 查询某一列为 NULL 的值，注：不能写 = NULL</li></ul><p>逻辑运算符</p><ul><li>And && 多个条件同时成立</li><li>Or || 多个条件任一成立</li><li>Not 不成立，取反</li></ul><p>模糊查询</p><ul><li>% 表示匹配任意多个字符串</li><li>_ 表示匹配 一个字符</li></ul><pre><code>-- 查询员工姓名为'张人大'的员工信息SELECT * FROM emp WHERE ename = '张人大';-- 查询薪水价格为 3000 的员工信息SELECT * FROM emp WHERE salary = 3000;-- 查询薪水价格不是 5000 的所有员工信息SELECT * FROM emp WHERE salary != 5000;SELECT * FROM emp WHERE salary &lt;&gt; 5000;-- 查询薪水价格大于 6000 元的所有员工信息SELECT * FROM emp WHERE salary &gt; 6000;-- 查询薪水价格在 5000 到 10000 之间所有员工信息SELECT * FROM emp WHERE salary     BETWEEN 5000 AND 10000;-- 查询薪水价格是 3000 或 8000 或者 20000 的所有员工信息# 方法 1: orSELECT * FROM emp WHERE salary = 3000     OR salary = 8000     OR salary = 20000;# 方法 2: in() 匹配括号中指定的参数SELECT * FROM emp WHERE salary IN(3000, 8000, 20000);-- 查询含有'人'字的所有员工信息SELECT * FROM emp WHERE ename LIKE '%人%';-- 查询以'张'开头的所有员工信息SELECT * FROM emp WHERE ename LIKE '张%';-- 查询第二个字为'莱'的所有员工信息SELECT * FROM emp WHERE ename LIKE '_莱%';-- 查询没有部门的员工信息SELECT * FROM emp WHERE dept_name IS NULL;-- 错误方式，不可以用 = 来判断是否为空# SELECT * FROM emp WHERE dept_name = NULL; -- 查询有部门的员工信息SELECT * FROM emp WHERE dept_name IS NOT NULL;</code></pre><p><br></p><hr><h1 class=pgc-h-arrow-right>MySQL: Single Table，Constraint and Transaction</h1><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right>Single Table Operation</h1><h1 class=pgc-h-arrow-right>Sorting</h1><h1 class=pgc-h-arrow-right>单列排序</h1><p>只按照某一个字段进行排序，就是单列排序</p><pre><code>-- 使用 salary 字段，对 emp 表数据进行排序 (升序/降序)# 默认升序排序 ASCSELECT * FROM emp ORDER BY salary;# 降序排序SELECT * FROM emp ORDER BY salary DESC;</code></pre><h1 class=pgc-h-arrow-right>组合排序</h1><p>同时对多个字段进行排序，如果第一个字段相同就按照第二个字段进行排序，以此类推</p><pre><code>-- 在薪水排序的基础上, 再使用 eid 进行排序, 如果薪水相同就以 eid 做降序排序# 组合排序SELECT * FROM emp ORDER BY salary DESC, eid DESC;</code></pre><h1 class=pgc-h-arrow-right>Aggregate Function</h1><h1 class=pgc-h-arrow-right>count (字段) -- 统计指定列不为 NULL 的记录行数</h1><pre><code>-- 查询员工的总数# 统计表中的记录条数SELECT COUNT(eid) FROM emp;SELECT COUNT(*) FROM emp;# 使用 1，与 * 效果一样SELECT COUNT(1) FROM emp;-- 查询薪水大于 4000 员工的个数SELECT COUNT(*) FROM emp WHERE salary &gt; 4000;-- 查询部门为'教学部'的所有员工的个数SELECT COUNT(*) FROM emp WHERE dept_name = '教学部';</code></pre><h1 class=pgc-h-arrow-right>sum (字段) -- 计算指定列的数值和</h1><h1 class=pgc-h-arrow-right>max (字段) -- 计算指定列的最大值</h1><h1 class=pgc-h-arrow-right>min (字段) -- 计算指定列的最小值</h1><h1 class=pgc-h-arrow-right>avg (字段) -- 计算指定列的平均值</h1><pre><code>-- 查看员工总薪水、最高薪水、最小薪水、薪水的平均值SELECT     SUM(salary) AS '总薪水',    MAX(salary) AS '最高薪水',    MIN(salary) AS '最低薪水',    AVG(salary) AS '平均薪水'   FROM emp;-- 查询部门为'市场部'所有员工的平均薪水SELECT     AVG(salary) AS '市场部平均薪资' FROM emp WHERE dept_name = '市场部';</code></pre><h1 class=pgc-h-arrow-right>Query by Group</h1><p>分组查询指的是使用 GROUP BY 语句，对查询的信息进行分组，相同数据作为一组。分组时可以查询要分组的字段，或者使用聚合函数进行统计操作。</p><pre><code>-- 按照性别进行分组操作。# 使用 * 会让所有字段显示SELECT * FROM emp GROUP BY sex;-- 通过性别字段进行分组，求各组的平均薪资SELECT sex, AVG(salary) FROM emp GROUP BY sex;-- 查询有几个部门SELECT dept_name AS '部门名称' FROM emp GROUP BY dept_name;-- 查询每个部门的平均薪资SELECT dept_name AS '部门名称',AVG(salary) AS '平均薪资' FROM emp GROUP BY dept_name;-- 查询每个部门的平均薪资, 且部门名称不为 nullSELECT     dept_name AS '部门名称',    AVG(salary) AS '平均薪资' FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name;</code></pre><p>分组操作中的 having 子语句，是用于在分组后对数据进行过滤的，作用类似于 where 条件。where 与 having 的区别：1. where 进行分组前的过滤，having 是分组后的过滤；2. where 后面不能写聚合函数，having 后面可以写。</p><pre><code>-- 查询平均薪资大于6000的部门# 需要在分组后再次进行过滤，使用 havingSELECT     dept_name,    AVG(salary)FROM emp  WHERE dept_name IS NOT NULL GROUP BY dept_name HAVING AVG(salary) &gt; 6000 ;</code></pre><h1 class=pgc-h-arrow-right>Limit</h1><p>Limit 关键字用于限制返回的查询结果的行数 (可以通过 limit 指定查询多少行数据)，是 MySQL 的方言，用来完成分页。分页公式：起始索引 = (当前页 - 1) * 每页条数。</p><pre><code>-- 查询 emp 表中的前 5 条数据# 参数 1 是起始值，默认为 0；参数 2 是要查询的条数SELECT * FROM emp LIMIT 5;SELECT * FROM emp LIMIT 0, 5;-- 查询 emp 表中从第 4 条开始，查询 6 条# 起始值默认是从 0 开始的SELECT * FROM emp LIMIT 3, 6;-- 分页操作：每页显示 3 条数据# 第 1 页SELECT * FROM emp LIMIT 0, 3;# 第 2 页 (2-1)*3=3SELECT * FROM emp LIMIT 3, 3;# 第 3 页SELECT * FROM emp LIMIT 6, 3;</code></pre><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right>Constraint</h1><p>SQL 的约束对表中的数据进行进一步的限制，从而保证数据的正确性、有效性、完整性。违反约束的不正确数据，将无法插入到表中。</p><h1 class=pgc-h-arrow-right>Primary Key -- 主键约束</h1><p>主键约束是不可重复的、唯一的、非空的，用来表示数据库中的每一条记录。通常针对业务去设计主键，每张表都设计一个主键 id。主键是给数据库和程序使用的，与客户的要求无关，所以只要能够保证主键不重复即可。</p><pre><code>-- 方式 1：直接设置主键CREATE TABLE emp1(    #     eid INT PRIMARY KEY,    ename VARCHAR(20),    sex CHAR(1));-- 方式 2：指定主键为 eid 字段CREATE TABLE emp2(    eid INT,    ename VARCHAR(20),    sex CHAR(1),    PRIMARY KEY(eid));-- 方式 3：通过数据定义语言进行主键设置CREATE TABLE emp3(    eid INT,    ename VARCHAR(20),    sex CHAR(1))ALTER TABLE emp3 ADD PRIMARY KEY(eid);DESC emp3;-- 测试主键的唯一性和非空性# 正常插入一条数据INSERT INTO emp3 VALUES(1,'张人大','男');# 错误：主键不能为空INSERT INTO emp3 VALUES(NULL,'布莱尔','女');# 错误：主键不能重复INSERT INTO emp3 VALUES(1,'李小明','男');-- 使用数据定义语言语句删除表中的主键ALTER TABLE emp3 DROP PRIMARY KEY;DESC emp3;-- 创建主键自增的表# 关键字 AUTO_INCREMENT，类型必须是整数类型CREATE TABLE emp4(    eid INT PRIMARY KEY AUTO_INCREMENT,    ename VARCHAR(20),    sex CHAR(1));#  添加数据观察主键的自增，默认开始值为 1。INSERT INTO emp4(ename,sex) VALUES('张人大','男');INSERT INTO emp4(ename,sex) VALUES('李小明','男');INSERT INTO emp4 VALUES(NULL,'布莱尔','女');INSERT INTO emp4 VALUES(NULL,'周小红','女');-- 自定义自增其实值CREATE TABLE emp5(    eid INT PRIMARY KEY AUTO_INCREMENT,    ename VARCHAR(20),    sex CHAR(1)) AUTO_INCREMENT = 100;# 插入数据,观察主键的起始值INSERT INTO emp5(ename,sex) VALUES('张人大','男');INSERT INTO emp5(ename,sex) VALUES('布莱尔','女');-- 使用 delete 删除表中所有数据# 目前最后的主键值是 101SELECT * FROM emp5;# delete 删除表中数据，对自增没有影响DELETE FROM emp5;# 插入数据，发现主键从 102 继续自增INSERT INTO emp5(ename,sex) VALUES('张人大','男');INSERT INTO emp5(ename,sex) VALUES('布莱尔','女');-- 使用 truncate 删除表中所有数据,TRUNCATE TABLE emp5;-- 插入数据，发现主键从 1 重新自增INSERT INTO emp5(ename,sex) VALUES('张人大','男');INSERT INTO emp5(ename,sex) VALUES('布莱尔','女');</code></pre><h1 class=pgc-h-arrow-right>Not Null -- 非空约束</h1><p>非空约束的特点：某一列不予许为空。</p><pre><code>-- 添加非空约束, ename 字段不能为空CREATE TABLE emp6(    eid INT PRIMARY KEY AUTO_INCREMENT,    ename VARCHAR(20) NOT NULL,    sex CHAR(1));</code></pre><h1 class=pgc-h-arrow-right>Unique -- 唯一约束</h1><p>唯一约束的特点：表中的某一列的值不能重复（对 null 不做唯一的判断）。</p><p>主键约束与唯一约束的区别：1. 主键约束是唯一的且不能够为空，唯一约束是唯一的但可以为空；2. 一个表中只能有一个主键，但是可以有多个唯一约束。</p><pre><code>-- 创建 emp3 表 为 ename 字段添加唯一约束CREATE TABLE emp7(    eid INT PRIMARY KEY AUTO_INCREMENT,    ename VARCHAR(20) UNIQUE,    sex CHAR(1));-- 测试唯一约束# 添加一条数据INSERT INTO emp7(ename,sex) VALUES('布莱尔','男');# 错误：ename 不能重复INSERT INTO emp7(ename,sex) VALUES('布莱尔','女');</code></pre><h1 class=pgc-h-arrow-right>Foreign Key -- 外键约束</h1><p>外键约束将在多表中介绍。</p><h1 class=pgc-h-arrow-right>Default -- 默认值约束</h1><p>默认值约束用来指定某列的默认值</p><pre><code>-- 为 ename 字段添加默认值CREATE TABLE emp8(    eid INT PRIMARY KEY AUTO_INCREMENT,    ename VARCHAR(20) DEFAULT '无名氏',    sex CHAR(1));-- 测试默认值INSERT INTO emp8(ename,sex) VALUES(DEFAULT,'男');INSERT INTO emp8(sex) VALUES('女');# 不使用默认值，则覆盖默认值。INSERT INTO emp8(ename,sex) VALUES('布莱尔','女');</code></pre><h1 class=pgc-h-arrow-right><br></h1><h1 class=pgc-h-arrow-right>Database Transaction</h1><h1 class=pgc-h-arrow-right>What is Database Transaction?</h1><p>数据库事务：是一个整体，由一条或者多条 SQL 语句组成，这些 SQL 语句要么都执行成功，要么都执行失败，只要有一条 SQL 出现异常，整个操作就会回滚，整个业务执行失败。</p><h1 class=pgc-h-arrow-right>Database Rollback</h1><p>数据库回滚：即在事务运行的过程中发生了某种故障，事务不能继续执行，系统将事务中对数据库的所有已完成的操作全部撤销，滚回到事务开始时的状态（在提交之前执行）。</p><h1 class=pgc-h-arrow-right>Account Transfer Example</h1><pre><code>-- 创建账户表CREATE TABLE account(    # 主键    id INT PRIMARY KEY AUTO_INCREMENT,    # 姓名    NAME VARCHAR(10),    # 余额    money DOUBLE);-- 添加两个用户INSERT INTO account(NAME, money) VALUES ('张人大', 1000), ('布莱尔', 1000);-- 模拟张人大给布莱尔转 500 元钱# 张人大账户减去 500 元UPDATE account SET money = money - 500 WHERE NAME = '张人大';# 布莱尔账户增加 500 元UPDATE account SET money = money + 500 WHERE NAME = '布莱尔';-- 假设当张人大减去了钱，然后服务器崩溃。-- 布莱尔的账号并没有收到钱，数据就出现问题。-- 所以要保证整个事务执行的完整性，要么都成功，要么都失败。</code></pre><h1 class=pgc-h-arrow-right>MySQL Transaction Operations</h1><p>MySQL 中可以有两种方式进行事务的操作：手动或自动提交事务。</p><h1 class=pgc-h-arrow-right>手动提交事务</h1><p>开启事务 - start transaction; 或 BEGIN;</p><p>提交事务 - commit;</p><p>回滚事务 - rollback;</p><pre><code>-- 执行成功的情况：开启事务 -&gt; 执行多条 SQL 语句 -&gt; 成功提交事务# 开启事务start transaction;# 张人大账户减去 500 元UPDATE account SET money = money - 500 WHERE NAME = '张人大';# 布莱尔账户增加 500 元，此时使用 SQLyog 查看表，发现数据并没有改变UPDATE account SET money = money + 500 WHERE NAME = '布莱尔';# 执行 commit 提交事务，此时发现数据发生改变commit;-- 执行失败的情况：开启事务 -&gt; 执行多条 SQL 语句 -&gt; 事务的回滚start transaction;INSERT INTO account VALUES(NULL,'张人大',3000);INSERT INTO account VALUES(NULL,'张人大',3500);# 此时不去提交事务直接退出程序，发生回滚操作，数据没有改变rollback;</code></pre><h1 class=pgc-h-arrow-right>自动提交事务</h1><p>MySQL 默认是自动提交事务：每一条增删改语句都是一个单独的事务，每条语句都会自动开启一个事务，语句执行完毕会自动提交事务。</p><pre><code>-- 查看 autocommit 状态SHOW VARIABLES LIKE 'autocommit';-- 取消自动提交，再次修改，则需要提交之后才生效 SET @@autocommit = off;# 修改数据update account set money = money - 500 where name = '张人大';# 手动提交commit;-- 开启自动提交SET @@autocommit = on;</code></pre><h1 class=pgc-h-arrow-right>The Four ACID Attributes of Database Transaction</h1><p>Atomicity -- 原子性。每个事务都是一个整体，不可再拆分，事务中所有的 SQL 语句要么都执行成功， 要么都失败。</p><p>Consistency -- 一致性。事务在执行前数据库的状态与执行后数据库的状态保持一致。如：转账前2个人的 总金额是 2000，转账后 2 个人总金额也是 2000。</p><p>Isolation -- 隔离性。事务与事务之间不应该相互影响，执行时保持隔离的状态。</p><p>Durability -- 持久性。一旦事务执行成功，对数据库的修改是持久的。就算关机，数据也是要保存下来的。</p><h1 class=pgc-h-arrow-right>Transaction Isolation Level</h1><h1 class=pgc-h-arrow-right>Data Concurrency</h1><p>数据并发访问：一个数据库可能拥有多个访问客户端，这些客户端都可以并发方式访问数据库。数据库的相同数据可能被多个事务同时访问，如果不采取隔离措施，就会导致各种问题，破坏数据的完整性。</p><h1 class=pgc-h-arrow-right>Data Concurrency Problems</h1><p>Dirty Reads -- 脏读：一个事务读取到了另一个事务中尚未提交的数据</p><p>Unrepeatable Reads -- 不可重复读：一个事务中多次读取的数据内容不一致。这是进行 update 操作时引发的问题。注意这里的重点是同一个事务中的多次读取，比如开启事务后，第一次读取有 1000 块钱，在事务还未结束时，第二次读取就可能变成 500 块钱了。又比如银行系统的程序在一个事务中要读取两次数据然后发到文件和电脑屏幕上，这时候就需要保证不可重复读的问题不会发生，否则会导致文件和电脑屏幕的数据不一致。</p><p>Phantom Reads -- 幻读：一个事务中，某一次的 select 操作得到的结果所表征的数据状态，无法支撑后续的业务操作。查询得到的数据状态不准，导致幻读。为什么会出现幻读？首先，为了解决不可重复读问题，只能底层设置一个缓存机制来保证一个事务中每次读取到的值会一样；基于解决了不可重复读问题的前提下，假设一个事务 A 查询了数据 x 是否存在并基于查询结果进行数据 x 的增加，但同时有另一个事务 B 提交了数据 x 的增加 ，那么事务 A 的增加就会因为重复而报错；这时候，在事务 A 中就会出现报错信息提示数据 x 已经存在，但是查询结果提示数据 x 不存在，就像出现幻觉一样。</p><h1 class=pgc-h-arrow-right>The Four Isolation Level</h1><p>Read Uncommitted -- 读未提交：没有解决问题。只要数据被修改，就立即持久化修改后的值。</p><p>Read Committed -- 读已提交：解决脏读问题。如果数据修改没有被提交，就不会持久化修改后的值。这是 Oracle 和 SQL 的默认隔离级别。</p><p>Repeatable Read -- 可重复读：解决不可重复读问题。底层设置了缓存保证一个事务内的每次读取都是一样的。这是 MySQL 的默认隔离级别。</p><p>Serializable -- 串行化：解决幻读问题。解决幻读问题只能通过取消数据并发访问，变成串行访问。但是串行化非常耗时，而且，影响数据库的性能，所以，数据库不会使用这种隔离级别。</p><pre><code>-- 查看隔离级别select @@tx_isolation;-- 修改隔离级别为读未提交set global transaction isolation level read uncommitted;</code></pre><hr></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据库','技术','MySQL'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>