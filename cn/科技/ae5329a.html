<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「每周FPGA案例」 SDRAM读写控制器（二） | 极客快訊</title><meta property="og:title" content="「每周FPGA案例」 SDRAM读写控制器（二） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/01017b3cb6b744ca9e316182a69a95a9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ae5329a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ae5329a.html><meta property="article:published_time" content="2020-10-29T20:51:12+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:12+08:00"><meta name=Keywords content><meta name=description content="「每周FPGA案例」 SDRAM读写控制器（二）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ae5329a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「每周FPGA案例」 SDRAM读写控制器（二）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">1.5.2SDRAM工作流程</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">SDRAM初始化</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><span style="color:#444;--tt-darkmode-color: #A2A2A2">在</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">SDRAM内部有一个逻辑控制单元，并且有一个模式寄存器为其提供控制参数。每次开机时SDRAM都要先对这个控制逻辑核心进行初始化。SDRAM必须以预定义的方式启动和初始化。</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">在</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">电源同时作用于Vdd和Vddq后开始初始化SDRAM，此时的时钟稳定并且将数据掩码和时钟使能信号拉高。在向SDRAM发送命令之前需要有100us的延时，此时SDRAM不执行任何操作。在100us延时满足后，需要对Bank进行预充电，在此期间所有的Bank处于空闲状态。预充电之后会有至少两个自刷新操作，完成自刷新便可以对SDRAM进行模式寄存器配置。下面是初始化的时序图<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01017b3cb6b744ca9e316182a69a95a9><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>从上图中可以看出，上电后等待时间为T=100us，预充电操作需要的时间为TRP，一次自刷新需要的时间是TRC，加载模式寄存器需要的时间为TMRD。<br>在初始化中的预充电期间，地址线A10定义自动预充电，以确定是否所有Bank都被预充电，也可以通过Bank地址选择信号BA0和BA1来决定进行预充电的Bank地址。在加载模式寄存器期间，地址线A0到A11一起组成命令码。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">SDRAM行激活</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>初始化完成之后，在向SDRAM发送读或者写命令之前必须打开该Bank中的一行，通过ACTIVE命令来确定要激活的Bank和行。要想对一个Bank中的阵列进行寻址，首先要确定行（Row），然后确定列。片选信号与Bank选择信号与行有效同时进行，下面是激活的时序图</span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/44eac32d8d0048bfaefdd3138e26f253><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>从上图中可以看出，在片选信号、Bank地址选定的同时，行地址选通信号RAS也处于有效状态，此时An地址线发送具体的行地址。行地址位宽为12，共可以指示2^12=4096个具体的行地址。当行地址被激活后，相应的Bank也被激活，因此行激活又叫L-Bank激活。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">列</span></strong><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">选择</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>行地址确定后，就要对列地址进行寻址，地址线仍使用A0~A11，即行地址与列地址共用地址线。当列地址选通后，就需要对SDRAM进行</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">读写</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">，而给SDRAM读命令还是写命令由WE信号决定。当WE信号拉低时，SDRAM接收到的是写命令；当WE拉高，SDRAM接收读命令。列寻址信号与读写命令是同时发出的。虽然地址线与行寻址共用，但列地址选通脉冲CAS则可以区分开行与列寻址的不同，配合A0~A9、A11来确定具体的地址。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>在发送列读写命令时必须要与有效命令有一个时间间隔，这个时间间隔被定义为TRCD。<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f56afffd10b4573b70fedcd555932f6><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">读操作</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>读命令从输入信号BA0、BA1中选取要进行读数据操作的BANK，并在已激活的行中进行突发读写操作。输入的A0~A7用来进行列寻址。在选定列地址后，就已经确定了具体的存储单元，剩下的事情就是数据通过dq输出到内存总线上了。但是</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">再</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">CAS发出之后，仍要经过一定的时间才能有数据输出，从CAS与读取命令发出到第一个数据输出的这段时间，被定义为CALLatency（CAS潜伏期）。由于此现象只在读的时候出现，所以又称作读潜伏期</span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a31d09c268d44e8c9c707b858e89a5aa><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>由于存储体中晶体管存在反应时间，从而造成数据不可能与CAS 在同一上升沿触发，因此要延后至少一个时钟周期。考虑到芯片体积较小的因素，存储单元中的电容容量很小，所以信号要经过放大来保证其有效的识别性，这个放大/驱动工作由 S-AMP 负责，一个存储体对应一个 S-AMP 通道。但它要有一个准备时间才能保证信号的发送强度（事前还要进行电压比较以进行逻辑电平的判断），因此从数据 I/O 总线上有数据输出之前的一个时钟上升沿开始，数据即已传向 S-AMP，也就是说此时数据已经被触发，经过一定的驱动时间最终传向数据 I/O 总线进行输出，这段时间我们称之为 tAC（Access-Time-from-CLK，时钟触发后的访问时间），单位是 ns。在突发读操作完成后，如果选择了自动预充电模式，那么该行就会直接进入充电。如果没有选择此模式，那么该行将保持打开状态，供后续访问。自动预充电模式的选择与 A10的值有关，A10 为高时为自动预充电命令模式。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">写操作</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>数据写入的操作也是在 tRCD 之后进行，但此时没有 CL（CL 只出现在读取操作中），行寻址与列寻址的时序一样致，只是在列寻址时，WE#为有效状态。由于数据信号由控制端发出，输入时芯片无需做任何调校，只需直接传到数据输入寄存器中，然后再由写入驱动器进行对存储电容的充电操作，因此数据可以与 CAS 同时发送，也就是说写入延迟为 0。不过，数据并不是即时地写入存储电容，因为选通三极管（就如读取时一样）与电容的充电必须要有一段时间，所以数据的真正写入需要一定的周期。</span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">突发</span></strong><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">读写</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>突发（Burst）是指在同一行中相邻的存储单元连续进行数据传输的方式，连续传输所涉及到存储单元（列）的数量就是突发长度（Burst Lengths，简称 BL）。前文讲到的读/写操作，都是一次对一个存储单元进行寻址，如果想要连续的向 SDRAM 中读数据或者写数据，就需要对当前存储单元的下一个单元进行寻址，也即是需要不停给 SDRAM 列激活信号以及读/写命令（行地址不变，所以不用再对行寻址）。虽然由于读/写延迟相同可以让数据的传输在 I/O 端是连续的，但它占用了大量的内存控制资源，在数据进行连续传输时无法输入新的命令，效率很低。为此，人们开发了突发传输技术，只要指定起始列地址与突发长度，SDRAM 就会不再需要控制器连续地提供列地址，依次地自动对后面相应数量的存储单元进行读/写操作。这样，在突发模式读写中，除了第一个数据的传输需要若干个周期（主要是之前的延迟，一般的是tRCD+CL），其后每个数据只需一个周期的即可获</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">。至于突发长度 BL 的数值，也是不能随便设或在数据进行传输前临时决定，而是在上文讲到的 SDRAM 初始化过程中模式寄存器配置阶段就要对突发长度进行设置。目前可用的选项是 1、2、4、8、全页（FullPage），常见的突发长度设定是 BL=4、BL=8 或者全页突发模式。<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/930a10d626074f5d80c17833fce26dfd><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span><strong><span style="color:#444;--tt-darkmode-color: #A2A2A2">1.5.3设计思路</span></strong><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>经过上面对SDRAM工作流程的介绍，可以采用状态机作为本工程的一个架构，根据指令的不同，划分为8个状态，分别为空操作（NOP）、预充电（PER）、自刷新（REF）、加载模式寄存器（MOD）、空闲（IDL）、激活（ACT）、读数据（RED）和写数据（WIR）。由于每个操作需要的时间都不同，因此需要一个计数器来对每个操作需要的时间进行计数。<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb0295691f274e4fa0908921d8dbc06c><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>该计数器加一条件为state_c!=IDL，表示只要不是处于空闲状态，就进行计数；结束条件为数x个，x根据目前所处的状态的不同而不同，具体数据可以看下面的表格。 当前状态 计数器数多少个空操作（NOP）20000预充电（PER）2自刷新（REF）7加载模式寄存器（MOD）2激活（ACT）2读/写数据（RED/WIR）512<br>由于再初始化阶段，自刷新需要连续进行两次，因此需要将初始化阶段区分出来，设计一个初始化指示信号init_flag：该信号初始状态为高电平，表示上电之后SDRAM处于初始化阶段；当初始化完成之后变为低电平，因此从高变低的条件为mod2idl_start。<br>自刷新计数器cnt1：该计数器表示初始化阶段进行自刷新的次数。加一条件为(init_flag && state_c==REF && end__cnt)，表示在初始化阶段，如果当前状态为自刷新，则时钟计数器数完一次就加一；结束条件为数两个，初始化阶段共进行两次自刷新，因此只需要数两个即可。<br>在初始化完成之后，需要进行自刷新、读数据和写数据等操作，由于自刷新是必须进行的，因此自刷新请求的优先级是最高的，那么读请求和写请求的优先级怎么确定呢？假设设置读请求的优先级高于写请求，读请求和写请求一起来的时候，总是先执行读请求，如果读请求一直有效的话，便不会执行写操作。反之设置写请求的优先级高于读请求，也会出现这样的问题，这当然是不可以的。因此我们设置为如果两个请求不是同时有效，则哪一个有效便执行哪一个。如果同时来的时候，第一次同时来，先执行写操作，第二次同时有效的时候在执行写操作，如此交替进行即可。通过两个信号进行控制：<br>读操作指示信号flag_rd：初始状态为低电平，表示上一次执行的写操作；从低变高的条件为state_c==RED，表示如果执行的是读操作，则置为高电平；当执行的是写操作的时候，该信号置为0，所以变0的条件是state_c==WIR。<br>读写同步指示信号flag_syn：初始状态为0，表示读写请求没有同时有效，如果当前处于激活状态，并且读写请求同时有效，则置为1，当激活状态结束，重新变为0。<br>设计中的辅助信号已经完成的差不多了，下面开始进行状态机的架构，架构图如下图所示：<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9d7183138a424d51ad2a9981709c2e3f><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>下面介绍一个各个状态之间的跳转条件。<br>上电之后，先进入空操作状态，在空操作状态下：<br>1、 延时100us之后，进入到预充电状态。<br>当处于预充电状态的时候：<br>1、 如果处于初始化阶段，两个时钟周期之后，跳转到自刷新状态。2、 如果不是初始化阶段，两个时钟周期之后，跳转到空闲状态。<br>当处于自刷新状态时：<br>1、 如果处于初始化状态，7个时钟周期之后，跳转到自刷新状态。2、 如果处于初始化状态，并且已经进行过一次初始化，7个时钟周期之后，跳转到加载模式寄存器状态。3、 如果不是初始化阶段，7个时钟周期之后，跳转到空闲状态。<br>当处于加载模式寄存器状态时：<br>1、 2个时钟周期之后，进入到空闲状态。当处于空闲状态时：<br>1、 如果收到自刷新请求，则跳转到自刷新状态。2、 如果自刷新请求无效，收到读/写请求，则跳转到激活状态。<br>当处于处于激活状态时：<br>1、 当读写请求不同时的时候，接收到读请求，则跳转到读状态。2、 当读写请求不同时的时候，接收到写请求，则跳转到写状态3、 当读写请求同时到达的时候，第一次来的时候，首先响应读请求，跳转到读状态4、 当读写请求同时到达，但不是第一次同时有效的时候，则根据上一次执行的操作进行判断，如果上一次执行的读操作，则这次执行写操作，跳转到写状态；如果上一次执行的写操作，则这次执行读操作，跳转到读状态。当处于写状态的时候：<br>1、 写数据完成，就进入到预充电状态。<br>当处于读状态的时候：<br>1、 读数据完成，就进入到预充电状态。<br>指令集信号conmand：该信号共4bit，从最高位到最低位分别表示cs、ras、cas、we。在空操作阶段，指令为4’b0111；在预充电阶段，指令为4’b0010；在自刷新阶段，指令为4’b0001；在加载模式寄存器阶段，指令为4’b0000；在激活阶段，指令为4’b0011；在读数据阶段，指令为4’b0101；在写数据阶段，指令为4’b0100。这些操作对应的指令码都是从图中的表格中查找得来。<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8513a96b5c1448b298caeee29e2680b7><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br></span></p><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>数据掩码dqm：初始状态为2’b11，表示输入得两个字节数据无效。当初始化完成之后，变为2’b00，表示输入</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">两个字节数据有效。<br>时钟使能cke：复位时为0，表示输入时钟无效，复位结束之后为1，表示输入时钟有效。<br>Bank选择信号sd_bank：初始状态为2’b00，表示选择Bank0；在激活阶段、读阶段和写阶段，该信号由输入得bank信号决定。<br>SDRAM地址选择信号sd_addr：由于本工程采用的预充电模式为全Bnak自动预充电，该模式由地址线A10控制，因此在预充电</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">时候，地址指令为13’b001_0_00_000_0_000；在激活的时候提供</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">行</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">地址；在加载模式寄存器得时候，地址线提供运算码，这时每个地址表示得意思</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">入</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">下图所示，A9决定读模式，A6、A5、A4决定读数据得潜伏期，A3决定突发类型，A2、A1、A0决定突发长度。<br></span></p><div class=pgc-img><img alt="「每周FPGA案例」 SDRAM读写控制器（二）" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a1bb5d9db4f4e069c89c07d781335c1><p class=pgc-img-caption></p></div><p><span style="color:#444;--tt-darkmode-color: #A2A2A2"><br>由于MP801开发板使用得SDRAM有两种型号，一种是W9812G6KH，共4096行，自刷新周期为1562，另一种是H57V2562GTR，共8192行，自刷新周期为780。在使用</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">时候需要注意开发板型号，这里我们以H57V2562GTR为例。自刷新需要以下信号：<br>时钟计数器cnt_780：该计数器主要得作用是初始化结束之后，</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">数自</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">刷新得周期；加一条件为init_flag==0，表示初始化结束就开始计数；结束条件为数780个，数完就清零。<br>自刷新请求ref_req：初始状态为0，表示不需要进行自刷新，当时钟计数器cnt_780数完</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">时候，ref_req拉高，请求进行自刷新，如果当前处于空闲状态，则进行自刷新，如果不是，则等待。<br>可能有人会想，如果不是空闲状态，就要等待，这样会不会对数据保存造成影响？其实不会得，存储器要求64ms全部刷新一遍，但不需要每一行刷新</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">间隔都一样。当时钟计数器cnt_780数完之后，产生自刷新请求，同时时钟计数器又会开始计数，所以可能自刷新</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">得</span><span style="color:#444;--tt-darkmode-color: #A2A2A2">间隔不同，但每一行肯定能在64ms内刷新1次。写SDRAM数据信号dq_out：该信号直接等于写数据wdata（注意，需要用组合逻辑实现）。<br>三态门使能信号dq_out_en：初始状态为0，表示使能无效，在写数据期间，变为高电平，表示使能有效。<br>读SDRAM数据信号rdata：直接将sdram输出数据dq_in连接即可。<br>读数据有效指示信号rdata_vld：由于存在读数据潜伏期，根据设置得潜伏期得长度，将rdata_vld进行相应得延时。<br></span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'每周','FPGA','SDRAM'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/4ca6277.html alt="「每周FPGA案例」 SDRAM读写控制器设计（一）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f670d48a5dc24f91b7dee7524a810099 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/4ca6277.html title="「每周FPGA案例」 SDRAM读写控制器设计（一）">「每周FPGA案例」 SDRAM读写控制器设计（一）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>