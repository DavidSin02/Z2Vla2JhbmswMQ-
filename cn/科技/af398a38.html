<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Spring—面向切面编程（AOP）详解 | 极客快訊</title><meta property="og:title" content="Spring—面向切面编程（AOP）详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af398a38.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af398a38.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af398a38.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Spring—面向切面编程（AOP）详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/af398a38.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Spring—面向切面编程（AOP）详解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre>作者：我要进阿里！原文：https://www.cnblogs.com/liuhongchen/p/11580319.html?utm_source=tuicool&amp;utm_medium=referral</pre><p>声明：本问仅仅是一个初学者的学习记录、心得总结，其中肯定有许多错误，不具有参考价值，欢迎大佬指正，谢谢！</p><div class=pgc-img><img alt=Spring—面向切面编程（AOP）详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570><p class=pgc-img-caption></p></div><p><strong>一、问题引入</strong></p><p>​ 在日常写项目的时候，肯定少不了要打印日志。例如，要向数据库中insert一个用户，我想在插入前输出一下相关信息，怎么实现呢？最基本的做法是：在insert方法中写日志输出语句。这样写完全能实现功能，但是会不会显得很冗余？耦合度是不是很高？编程的准则是“高内聚，低耦合”，低耦合的意思就是类与类之间的依赖关系尽量少、关联程度尽量小。</p><p>​ 而如果在上述情景中使用面向切面编程（AOP），就可以不在insert方法中写日志输出语句却能实现日志输出功能。当然，AOP不止如此。</p><p><strong>二、概念引入</strong></p><p><strong>1.AOP</strong></p><p>在软件业，AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方 式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个 热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑 的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高 了开发的效率。</p><p><strong>2.几个基本概念</strong></p><pre>- 切入点：所有要操作的方法定义，要求业务层方法风格统一- 分离点：将不可分割的组件单独提取出去定义为单独的操作功能- 横切关注点：将所有与开发无关的程序组成类单独提取后组织运行- 织入：将所有切入点、关注点的代码组成在一张完整的程序结构中</pre><p><strong>3.通知（Advice）</strong></p><p>​ AOP是通过通知来实现功能的，有如下五种：</p><ul><li>前置通知（BeforeAdvice）</li><li>后置通知（AfterAdvice）</li><li>后置返回通知（AfterReturningAdvice）</li><li>后置异常通知（AfterThrowingAdvice）</li><li>环绕通知（AroundAdvice）</li></ul><p><strong>三、Pointcut与Execution表达式</strong></p><p>​ pointcut使用execution表达式表示要被切入的方法（即定义切入点）。</p><p>​ execution表达式，功能类似于正则表达式，都是用来匹配筛选，只不过正则表达式用来筛选字符串，而execution表达式用来筛选要被切入的方法。</p><p>​ execution表达式的格式为：</p><p>​ execution(&lt;注解>? &lt;修饰符>? &lt;返回值类型> &lt;方法名模式>(&lt;参数模式>) &lt;异常>?)) &lt;and args()>?)</p><p>​ 例： execution(@Deprecated public Void aop.MyAspect.hello(int,String) throws Exception))')</p><pre>package aop;public class AspectDemo { @Deprecated public void hello(int i,String s) throws Exception{ }}</pre><p>​ 其实不难发现，这个表达式和我们声明的方法的各个部分一一对应</p><ul><li>注解：（可省略）例如上面代码中的 @Deprecated ，就是筛选带有该注解的方法</li><li>修饰符（可省略）</li><li class=ql-indent-1>public</li><li class=ql-indent-1>protected</li><li class=ql-indent-1>private</li><li>当然一般用通配符 *</li><li>返回值类型</li><li>写各种返回值，一般用通配符 *</li><li>方法名模式</li><li>包名部分：在上例中，AspectDemo是位于aop包中的，所以可以通过包名.包名.类名的格式来定位到某个类，例如aop.AspectDemo 中aop. 就是包名部分;</li><li>当然也可以用通配符</li><li class=ql-indent-2>*：匹配任何数量字符，例如service.*.UserService 表示的是service的直接子包</li><li class=ql-indent-2>..：匹配任何数量字符的重复，如在类型模式中匹配任何数量子包，例如service..代表着匹配service及其包含的所有包；而在方法参数模式中匹配任何数量参数。</li><li class=ql-indent-1><strong>+：</strong> 匹配指定类型的子类型；仅能作为后缀放在类型模式后边，例如java.lang.Number+ 表示的是lang包下Numer的子类</li><li class=ql-indent-1>类名部分：在上例中aop.AspectDemo中aop.是包名部分，AspectDemo就是类名部分，可以用通配符来表示，*用的比较多</li><li>参数模式</li><li class=ql-indent-1>写法1:直接按照方法的参数列表写具体类型，上例的方法中参数列表(int i,String s),就可以直接在表达式中写(int,String)</li><li>写法2:使用通配符:</li><li class=ql-indent-2>“()”表示方法没有任何参数；</li><li class=ql-indent-2>“(..)”表示匹配接受任意个参数的方法</li><li class=ql-indent-2>“(..,java.lang.String)”表示匹配接受java.lang.String类型的参数结束，且其前边可以接受有任意个参数的方法</li><li class=ql-indent-2>“(java.lang.String,..)” 表示匹配接受java.lang.String类型的参数开始，且其后边可以接受任意个参数的方法</li><li class=ql-indent-1>“(*,java.lang.String)” 表示匹配接受java.lang.String类型的参数结束，且其前边接受有一个任意类型参数的方法；</li><li>异常模式（可省略）</li><li>throws Exception1，Exception2.。。。</li><li>传入参数（可省略）</li><li>​ and args(arg-name),一般用于AfterAdvice和Around通知</li></ul><p><strong>四、前期准备</strong></p><ol><li>创建项目，导入相关jar包，参考Spring——IOC，此外还需导入aop和aspectj的jar包</li><li>创建applicationContext.xml文件</li></ol><pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt;</pre><p>​ 注意：新增了</p><p>​ xmlns:aop="http://www.springframework.org/schema/aop"</p><p>​ http://www.springframework.org/schema/aop</p><p>​ http://www.springframework.org/schema/beans/spring-aop.xsd</p><p>​ &lt;aop:aspectj-autoproxy/> 不加这个可能会报错，可坑了</p><ol><li>创建UserService这个类，内部有insert方法用来注册用户</li></ol><pre>public class UserService {  public void insert(){ System.out.println("UserService正在注册用户……"); }}</pre><ol><li>创建MyAspect类</li></ol><pre>public class MyAspect {}</pre><p><strong>五、基于XML配置的AOP</strong></p><p><strong>1.BeforeAdvice</strong></p><p>​ (1)在MyAspect类中创建方法beforeAdvice</p><pre>public void beforeAdvice(){ System.out.println("【AOP】Before Advice正在执行……"); }</pre><p>​ (2)在applicationContext.xml中配置</p><p>​ <em>关于pointcut和execution表达式见下文</em></p><pre>&lt;!--首先要引入myAspect这个bean，备用--&gt; &lt;bean id="myAspect" class="aop.MyAspect"/&gt; &lt;bean id="userService" class="aop.UserService"/&gt; &lt;aop:config&gt; &lt;!--配置切面，一个aop:aspect标签对应一个Aspect类--&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;!--配置通知 method对应MyAspect类中定义的方法，pointcut是切入点表达式用于筛选需要被 切入的方法--&gt; &lt;aop:before method="beforeAdvice" pointcut="execution(* aop..*.*(..)))"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;</pre><p>​ (3)编写测试类</p><pre>public class UserServiceTest { public static void main(String[] args) { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert(); }}</pre><p>​ (4)输出结果</p><pre>【AOP】Before Advice正在执行…… UserService正在注册用户……</pre><p>​ 可以发现，BeforeAdvice就已经实现了</p><p><strong>2.AfterAdvice（相当于异常里面的finally语句）</strong></p><p>​ (1)UserService类同上</p><p>​ (2)在MyAspect中创建方法afterAdvice</p><pre>public void afterAdvice(){ System.out.println("【AOP】after Advice…… 不管怎样我都会执行");}</pre><p>​ (3)修改applicationContext.xml</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:after method="afterAdvice" pointcut="execution(* aop.*.insert(..)))" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ (4)编写测试类（同上）</p><p>​ (5)输出结果</p><pre>UserService正在注册用户……【AOP】after Advice…… 不管怎样我都会执行</pre><p><strong>3.AfterReturningAdvice</strong></p><p>​ (1)修改UserService的insert方法，使其有返回值</p><pre>public class UserService { public int insert(){ System.out.println("UserService正在注册用户……"); return 1; }}</pre><p>​ (2)在MyAspect中新增afterReturningAdvice方法</p><pre>public void afterReturningAdvice(int result) { System.out.println("【AOP】after advice……返回值为"+result); }</pre><p>​ (3)在applicationContext.xml中配置</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:after-returning method="afterReturningAdvice" pointcut="execution(* aop.*.insert(..)))" returning="result"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ 注意：这里这个returning="result"与MyAspect类中对应方法的参数名必须保持一致，本例中都为result</p><p>​ (4)编写测试类(代码同1.)</p><p>​ (5)输出结果</p><pre>UserService正在注册用户…… 【AOP】after advice……返回值为1</pre><p><strong>4.AfterThrowingAdvice</strong></p><p>​ (1)修改UserService使其抛异常</p><pre>public int insert() throws Exception { try { System.out.println("UserService开始注册用户……"); int i=1/0; }catch (Exception e){ throw new Exception("insert方法遇到异常……"); } return 1;}</pre><p>​ (2)在MyAspect中新增方法 afterThrowingAdvice</p><pre>//这里传入的这个Exception就是捕获到的异常对象public void afterThrowingAdvice(Exception e){ System.out.println("【AOP】得到异常信息："+e.getMessage());}</pre><p>​ (3)修改applicationContext.xml</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:after-throwing method="afterThrowingAdvice" pointcut="execution(* aop.*.insert(..)))" throwing="e"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ 注意：这里的throwing="e”就是跑出的异常对象的名字，要与MyAspect中afterThrowingAdvice方法中传入的参数Exception e的名字保持一致。</p><p>​ (4)编写测试类</p><pre>public static void main(String[] args) throws Exception { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert();}</pre><p>​ (5)输出结果</p><pre>UserService开始注册用户……【AOP】得到异常信息insert方法遇到异常……Exception in thread "main" java.lang.Exception: insert方法遇到异常…… at aop.UserService.insert(UserService.java:12) at aop.UserService$$FastClassBySpringCGLIB$$7e3b8e5e.invoke(&lt;generated&gt;) ...</pre><p><strong>5.AroundAdvice</strong></p><p>​ (1)修改UserService中的insert方法</p><pre>public int insert(int arg) throws Exception { try { int i = 1 / 0; } catch (Exception e) { throw new Exception("insert方法遇到异常……"); } return 1;}</pre><p>​ (2)在MyAspect中添加方法AroundAdvice</p><pre>//这里这个ProceedingJointPoint可以理解为切入点对象，可以通过它获取切入点（被切入的方法）的参数、返回值、抛出的异常，并且可以通过pjp.proceed(args);为该切入点设置参数public int aroundAdvice(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); System.out.println("【AOP】before Advice,获取到insert方法传入的参数为："+args[0]); Object result; try { result=pjp.proceed(args);//这里是我们手动执行切入点，并传入参数 System.out.println("【AOP】after Returning Advice,返回值为："+result); }catch (Exception e){ //这里捕获的就是切入点运行时抛出的异常 System.out.println("【AOP】after Throwing Advice,错误信息为："+e.getMessage()); } System.out.println("【AOP】after advice……不管异常不异常我都执行"); //这个就跟着这样写吧。。如果不写返回值的话会报 null return value does not match... return 1;}</pre><p>​ (3)修改applicationContext.xml文件</p><pre>&lt;aop:config&gt; &lt;aop:aspect id="beforeAdvice" ref="myAspect"&gt; &lt;aop:around method="aroundAdvice" pointcut="execution(* aop.*.insert(..)))" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt;</pre><p>​ (4)编写测试类</p><pre>public static void main(String[] args) throws Exception { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert(2);}</pre><p>​ (5)输出结果</p><pre>【AOP】before Advice,获取到insert方法传入的参数为：2【AOP】after Throwing Advice,错误信息为：insert方法遇到异常……【AOP】after advice……不管异常不异常我都执行</pre><p><strong>六、基于注解配置的AOP</strong></p><p>​ 先把项目状态恢复到 “四、前期准备”的状态,然后在applicationContext.xml中添加下面的语句开启注解和包扫描。</p><pre>&lt;context:annotation-config/&gt;&lt;context:component-scan base-package="aop"/&gt;</pre><p>​ 注意，这个base-package可以配置多个包，以半角（英文）逗号隔开，例如“aop,mvc,dao,service”，当然，为了省事，可以直接配一个顶级包，他会自动遍历扫描所有的子包及子包的子包等等。</p><p>​ 然后为MyAspect类和UserService类加上注解</p><pre>@Component@Aspectpublic class MyAspect {}@Servicepublic class UserService {}</pre><p><strong>1.BeforeAdvice</strong></p><p>​ (1)在MyAspect类中创建beforeAdvice方法，并写好注解</p><pre>@Before(value = "execution(* aop..*.*(..)))")public void beforeAdvice(){ System.out.println("【AOP】Before Advice正在执行……");}</pre><p>​ 不需要配任何bean，是不是很爽</p><p>​ (2)编写测试类</p><pre>public static void main(String[] args) { ApplicationContext context= new ClassPathXmlApplicationContext("applicationContext.xml"); UserService userService = context.getBean("userService", UserService.class); userService.insert();}</pre><p>​ (3)输出结果</p><pre>【AOP】Before Advice正在执行…… UserService正在注册用户……</pre><p><strong>2.AfterService(我就不写测试了)</strong></p><p>​ (1)在MyAspect类中创建afterAdvice方法，并写好注解</p><pre>@After(value = "execution(* aop..*.*(..)))")public void afterAdvice(){ System.out.println("【AOP】after Advice正在执行……");}</pre><p><strong>3.AfterReturningAdvice</strong></p><p>​ (1)修改UserService中的insert方法</p><pre>public int insert(){ System.out.println("UserService正在注册用户……"); return 1;}</pre><p>​ (2)在MyAspect类中创建afterReturningAdvice方法，并写好注解</p><pre>@AfterReturning(value = "execution(* aop..*.*(..))&amp;&amp; args(result))")public void afterReturningAdvice(int result){ System.out.println("【AOP】after Returning Advice正在执行……返回值为："+result);}</pre><p>​ (3)不写测试了</p><p><strong>4.AfterThrowingAdvice</strong></p><p>​ (1)修改UserService中的insert方法</p><pre>public int insert() throws Exception { try { int i=1/0; }catch (Exception e){ throw new Exception("【UserService】的insert遇到了错误……"); } return 1;}</pre><p>​ (2)在MyAspect类中创建afterThrowingAdvice方法，并写好注解</p><pre>@AfterThrowing(value = "execution(* aop..*.*(..)))",throwing = "e")public void afterThrowingAdvice(Exception e){ System.out.println("【AOP】after Throwing Advice正在执行……错误信息为："+e.getMessage());}</pre><p>​ (3)不测试了。。</p><p><strong>5.AroundAdvice</strong></p><p>​ (1)把MyAspect中之前写的方法注释掉，不然会影响观察结果</p><p>​ (2)修改insert方法</p><pre>public int insert(int arg) throws Exception { try { int i=1/0; }catch (Exception e){ throw new Exception("【UserService】的insert遇到了错误……"); } return 1;}</pre><p>​ (3)在MyAspect类中创建aroundAdvice方法，并写好注解</p><pre>@Around(value = "execution(* aop..*.*(..)))")public int aroundAdvice(ProceedingJoinPoint pjp) throws Throwable { Object[] args = pjp.getArgs(); System.out.println("【AOP】before Advice,获取到insert方法传入的参数为："+args[0]); Object result; try { result=pjp.proceed(args); System.out.println("【AOP】after Returning Advice,返回值为："+result); }catch (Exception e){ System.out.println("【AOP】after Throwing Advice,错误信息为："+e.getMessage()); } System.out.println("【AOP】after advice……不管异常不异常我都执行"); return 1;}</pre><p><strong>关注作者：JAVA高级程序员</strong></p><p>专注分享：（高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty，Redis，Kafka，Mysql，Zookeeper，Tomcat，Docker，Dubbo，Nginx等技术...）</p><p>欢迎转发，评论~~~每天Java一下，成为架构师！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Spring','编程','AOP'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面编程AOP的初步了解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面编程AOP的初步了解>Spring面向切面编程AOP的初步了解</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用注解方式配置Spring中的面向切面编程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用注解方式配置Spring中的面向切面编程AOP>使用注解方式配置Spring中的面向切面编程AOP</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>