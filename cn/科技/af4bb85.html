<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java基础系列：理解Java多态的实现机制 | 极客快訊</title><meta property="og:title" content="Java基础系列：理解Java多态的实现机制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af4bb85.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af4bb85.html><meta property="article:published_time" content="2020-10-29T20:58:49+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:49+08:00"><meta name=Keywords content><meta name=description content="Java基础系列：理解Java多态的实现机制"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/af4bb85.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java基础系列：理解Java多态的实现机制</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多态性是面向对象程序设计代码重用的一个重要机制，我们曾不只一次的提到Java多态性。在Java运行时多态性：继承和接口的实现一文中，我们曾详细介绍了Java实现运行时多态性的动态方法调度；今天我们再次深入Java核心，一起学习Java中多态性的实现。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">“polymorphism(多态）”一词来自希腊语，意为“多种形式”。多数Java程序员是多态看作对象的一种能力，使其能调用正确的方法版本。尽管如此，这种面向实现的观点导致了多态的神奇功能，胜于仅仅把多态看成纯粹的概念。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Java中的多态总是子类型的多态。几乎是机械式产生了一些多态的行为，使我们不去考虑其中涉及的类型问题。本文研究了一种面向类型的对象观点，分 析了如何将对象能够 表现的行为和对象即将表现的行为分离开来。抛开Java中的多态度是来自继承的概念，我们仍让可以感到，Java中的接口是一组没有公共代码的对象共享实现。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多态的分类</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多态在面向对象语言中是个很普遍的概念.虽然我们经常把多态混为一谈，但实际上 有四种不同类型的多态。在开始正式的子类型多态的细节讨论前，然我们先来看看普通面向对象中的多态。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Luca Cardelli和Peter Wegner（"On Understanding Types, Data Abstraction, and Polymorphism"一文的作者， 文章参考资源链接）把多态分为两大类----特定的和通用的----四小类：强制的，重载的，参数的和包含的。他们的结构如下：</span></p><p><br></p><div class=pgc-img><img alt=Java基础系列：理解Java多态的实现机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9><p class=pgc-img-caption></p></div><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">在这样一个体系中，多态表现出多种形式的能力。通用多态引用有 相同结构类型的大量对象，他们有着共同的特征。特定的多态涉及的是小部分没有相同特征的对象。四种多态可做以下描述：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆强制的：一种隐 式做类型转换的方法。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆重载的：将一个标志符用作多个意义。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆参数的：为不同类型的参数提供相同的操作。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">◆包含的：类包含关系的抽象操作。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">我将在讲述子类型多态前简单介绍一下这几种多态。</span></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">强制的多态</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">强制多态隐式的将参数按某种方法，转换成编译器认为正确的类型以避免错误。在以下的表达式中，编译器必须决定二元运算符‘+’所应做的工作：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">2.0 + 2.0</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">2.0 + 2</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">2.0 + "2"</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">第一个表达式将两个double的 操作数相加；Java中特别声明了这种用法。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">第二个表达式将double型和int相加。Java中没有明确定义这种运算。不过，编 译器隐式的将第二个操作数转换为double型，并作double型的加法。做对程序员来说十分方便，否则将会抛出一个编译错误，或者强制程序员显式的将 int转换为double。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">第三个表达式将double与一个String相加。Java中同样没有定义这样的操作。所以，编译器将 double转换成String类型，并将他们做串联。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">强制多态也会发生在方法调用中。假设类Derived继承了类Base，类C 有一个方法，原型为m(Base)，在下面的代码中，编译器隐式的将Derived类的对象derived转化为Base类的对象。这种隐式的转换使 m(Base)方法使用所有能转换成Base类的所有参数。</span></p><p><br></p><ol start=1><li><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">C c = new C();</span></li><li><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Derived derived = new Derived();</span></li><li><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">c.m( derived );</span></li></ol><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">并且，隐式的强制转换，可以避免 类型转换的麻烦，减少编译错误。当然，编译器仍然会优先验证符合定义的对象类型。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">重载的多态</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">重载 允许用相同的运算符或方法，去表示截然不同的意义。‘+’在上面的程序中有两个意思：两个double型的数相加；两个串相连。另外还有整型相加，长整 型，等等。这些运算符的重载，依赖于编译器根据上下文做出的选择。以往的编译器会把操作数隐式转换为完全符合操作符的类型。虽然Java明确支持重载，但 不支持用户定义的操作符重载。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Java支持用户定义的函数重载。一个类中可以有相同名字的方法，这些方法可以有不同的意义。这些重载 的方法中，必须满足参数数目不同，相同位置上的参数类型不同。这些不同可以帮助编译器区分不同版本的方法。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">编译器以这种唯一表示的特 用来表示不同的方法，比用名字表示更为有效。据此，所有的多态行为都能编译通过。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">强制和重载的多态都被分类为特定的多态，因为这些多 态都是在特定的意义上的。这些被划入多态的特性给程序员带来了很大的方便。强制多态排除了麻烦的类型和编译错误。重载多态像一块糖，允许程序员用相同的名 字表示不同的方法，很方便。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">参数的多态</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">参数多态允许把许多类型抽象成单一的表示。例如，List 抽象类中，描述了一组具有同样特征的对象，提供了一个通用的模板。你可以通过指定一种类型以重用这个抽象类。这些参数可以是任何用户定义的类型，大量的用 户可以使用这个抽象类，因此参数多态毫无疑问的成为最强大的多态。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">乍一看，上面抽象类好像是java.util.List的功能。然 而，Java实际上并不支持真正的安全类型风格的参数多态，这也是java.util.List和java.util的其他集合类是用原始的 java.lang.Object写的原因（参考我的文章"A Primordial Interface?" 以获得更多细节）。Java的单根继承方式解决了部分问题，但没有发挥出参数多态的全部功能。Eric Allen有一篇精彩的文章“Behold the Power of Parametric Polymorphism”，描述了Java通用类型的需求，并建议给Sun的Java规格需求#000014号文档"Add Generic Types to the Java Programming Language."（参考资源链接）</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">包含的多态</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">包含多态通过值的类型和集合的包含关系实现了多态的行为.在包括Java在内的众多面向对象语言中，包含关系是子类型的。所以，Java的包含多态是子 类型的多态。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">在早期，Java开发者们所提及的多态就特指子类型的多态。通过一种面向类型的观点，我们可以看到子类型多态的强大功 能。以下的文章中我们将仔细探讨这个问题。为简明起见，下文中的多态均指包含多态。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">面向类型观点</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图1的UML类图给出了类和类型的简单继承关系，以便于解释多 态机制。模型中包含5种类型，4个类和一个接口。虽然UML中称为类图，我把它看成类型图。如"Thanks Type and Gentle Class," 一文中所述，每个类和接口都是一种用户定义的类型。按独立实现的观点（如面向类型的观点），下图中的每个矩形代表一种类型。从实现方法看，四种类型运用了 类的结构，一种运用了接口的结构。</span></p><p><br></p><div class=pgc-img><img alt=Java基础系列：理解Java多态的实现机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81a9ff3721f34cf6ac24f4b5b1f67de3><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图1：示范代码的UML类图</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">以下的代码实现了每个用户 定义的数据类型，我把实现写得很简单。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">用这样的类型声明和类的定义，图2从概念的观点描述了Java指令。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Derived2 derived2 = new Derived2();</span></p><p><br></p><div class=pgc-img><img alt=Java基础系列：理解Java多态的实现机制 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3d752940017f40948cccfbe6f58644dc><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图2 ：Derived2 对象上的引用</span></span></strong></p><p style=text-align:start><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">上文中声明了 derived2这个对象，它是Derived2类的。图2中的最顶层把Derived2引用描述成一个集合的窗口，虽然其下的Derived2对象是可 见的。这里为每个Derived2类型的操作留了一个孔。Derived2对象的每个操作都去映射适当的代码，按照上面的代码所描述的那样。例 如，Derived2对象映射了在Derived中定义的m1()方法。而且还重载了Base类的m1()方法。一个Derived2的引用变量无权访问 Base类中被重载的m1()方法。但这并不意味着不可以用super.m1()的方法调用去使用这个方法。关系到derived2这个引用的变量，这个 代码是不合适的。Derived2的其他的操作映射同样表明了每种类型操作的代码执行。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">既然你有一个Derived2对象，可以用任 何一个Derived2类型的变量去引用它。如图1所示，Derived, Base和IType都是Derived2的基类。所以，Base类的引用是很有用的。图3描述了以下语句的概念观点。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Base base = derived2;</span></p><p><br></p><div class=pgc-img><img alt=Java基础系列：理解Java多态的实现机制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5c42911d743a460db6ef51de02e93c04><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图3：Base类引用附于Derived2对象之上</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">虽然Base类的引用不用再访问m3()和m4()，但是却不会改变它Derived2对象的任何特征及操作映射。无论是变量derived2还是 base，其调用m1()或m2(String)所执行的代码都是一样的。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">两个引用之所以调用同一个行为，是因为Derived2对象并不知道去调用哪个方法。对 象只知道什么时候调用，它随着继承实现的顺序去执行。这样的顺序决定了Derived2对象调用Derived里的m1()方法，并调用Derived2 里的m2(String)方法。这种结果取决于对象本身的类型，而不是引用的类型。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">尽管如此，但不意味着你用derived2和 base引用的效果是完全一样的。如图3所示，Base的引用只能看到Base类型拥有的操作。所以，虽然Derived2有对方法m3()和m4()的 映射，但是变量base不能访问这些方法。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">运行期的Derived2对象保持了接受m3()和m4()方法的能力。类型的限制使 Base的引用不能在编译期调用这些方法。编译期的类型检查像一套铠甲，保证了运行期对象只能和正确的操作进行相互作用。换句话说，类型定义了对象间相互 作用的边界。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多态的依附性</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">类型的一致性是多态的核心。对象上的每一个引用，静态的类型检查器都要确认这样的依附和其对象的层次是一致的。当一个引用成功的依附于另一个不同的 对象 时，有趣的多态现象就产生了。（严格的说，对象类型是指类的定义。）你也可以把几个不同的引用依附于同一个对象。在开始更有趣的场景前，我们先来看一下下 面的情况为什么不会产生多态。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多个引用依附于一个对象</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图2和图3描述的例子是把两个及两个以上的 引用依附于一个对象。虽然Derived2对象在被依附之后仍保持了变量的类型，但是，图3中的Base类型的引用依附之后，其功能减少了。结论很明显：把一个基类的引用依附于派生类的对象之上会减少其能力。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">一个开发者怎么会选择减少对象能力的方案呢？这种选择是间接的。假设有一个名 为ref的引用依附于一个包含如下方法的类的对象：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">用一个Derived2的参数调用poly(Base)是符合参数类型检查的：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">方法调用把一个本地Base类型的变量依附在一个引入的对象上。所以，虽然这个方法直接 受Base类型的参数，但Derived2对象仍是允许的。开发者就不必选择丢失功能的方案。从人眼在通过Derived2对象时所看到的情况，Base 类型引用的依附导致了功能的丧失。但从执行的观点看，每一个传入poly1(Base)的参数都认为是Base的对象。执行机并不在乎有多个引用指向同一 个对象，它只注重把指向另一个对象的引用传给方法。这些对象的类型不一致并不是主要问题。执行器只关心给运行时的对象找到适当的实现。面向类型的观点展示 了多态的巨大能力。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">附于多个对象的引用</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">让我们来看一下发生在poly1(Base)中的多态行 为。下面的代码创建了三个对象，并通过引用传给poly1(Base):</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">poly1(Base)的实现代码是调用传进来的参数的m1()方法。图3和图4展示了 把三个类的对象传给方法时，面向类型的所使用的体系结构。</span></p><p><br></p><div class=pgc-img><img alt=Java基础系列：理解Java多态的实现机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0858e8a58b4e4bfbb5706522a9bee45f><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图4：将Base引用指向Derived类，以及Base对象</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">请注意每个图中方法m1()的映射。图3中，m1()调用了Derived类的代码；上面代码中的注释标明了ploy1(Base)调用 Derived.m1()。图4中Derived对象调用的仍然是Derived类的m1()方法。最后，图4中，Base对象调用的m1()是Base 类中定义的代码。</span></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多态的魅力何在？再来看一下poly1(Base)的代码，它可以接受任何属于Base类范畴的参数。然而，当他收 到一个Derived2的对象时，它实际上却调用了Derived版本的方法。当你根据Base类派生出其他类时，如 Derived，Derived2，poly1(Base)都可以接受这些参数，并作出选择调用合适的方法。多态允许你在完成poly1(Base)后扩 展它的用途。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">这看起来当然很神奇。基本的理解展示了多态的内部工作原理。在面向类型的观点中，底层的对象所实现的代码是非实质性的。重要的是，类型检查器会在编译期间为每个引用选择合适的代码以实现其方法。多态使开发者运用面向类型的观点，不考虑实现的细节。这样有助于把类型和实现分 离（实际用处是把接口和实现分离）。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">对象接口</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">多态依赖于类型和实现的分离，多用来把接口和实现分离。但下面的观点好像把Java的关键字 interface搞得很糊涂。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">更为重要的是开发者们怎样理解短语“the interface to an object"，典型地，根据上下文，这个短语的意思是指一切对象类中所定义的方法，指一切对象公开的方法。这种倾向于以实现为中心的观点较之于面向类型 的观点来说，使我们更加注重于对象在运行期的能力。图3中，引用面板的对象表面被标志成"Derived2 Object"。这个面板上列出了Derived2对象的所有可用的方法。但是要理解多态，我们必须从实现这一层次上解放出来，并注意面向类型的透视图中 被标为"Base Reference"的面板。在这一层意思上，引用变量的类型指明了一个对象的表面。这只是一个表面，不是接口。在类型一致的原则下，我们可以用面向类型 的观点，为一个对象依附多个引用。对interface to an object这个短语的理解没有确定的理解。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">该类型概念 中，the interface to an object refers 引用了面向类型观点的最大可能----如图2的情形。把一个基类的引用指向相同的对象缩小了这样的观点----如图3所示。类型概念能使人获得把对象间的 相互作用同实现细节分离的要领。相对于一个对象的接口，面向类型的观点更鼓励人们去使用一个对象的引用。引用类型规定了对象间的相互作用。当你考虑一个对 象能做什么的时候，只需搞明白他的类型，而不需要去考虑他的实现细节。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">Java接口</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">以上所谈到的 多态行为用到了类的继承关系所建立起来的子类型关系。Java接口同样支持用户定义的类型，相对地，Java的接口机制启动了建立在类型层次结构上的多态 行为。假设一个名为ref的引用变量，并使其指向一个包含以下方法的类对象：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">为了弄明白poly2(IType)中的多态，以下的代码从不同的类创建两个对象，并分别把他们传给 poly2(IType)：</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">上面的代码类似于关于poly1(Base)中的多态的讨论。poly2(IType)的实现代码是调 用每个对象的 本地版本的m3()方法。如同以前，代码的注释表明了每次调用所返回的CString类型的结果。图5表明了两次调用poly2(IType)的概念结构：</span></p><p><br></p><div class=pgc-img><img alt=Java基础系列：理解Java多态的实现机制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e4899ea21b3b4355a582594de6028772><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">图5：指向Derived2和Separate对象的IType引用</span></span></strong></p><p style=text-align:start><strong><span style="color:#666;--tt-darkmode-color: #666666"><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">方法poly1(Base)和poly2(IType)中所表现的多态行为的相似之处可以从透视图中直接看出来。把我们在实现在一层上的理解再提高 一 层，就可以看到这两段代码的技巧。基类的引用指向了作为参数传进的类，并且按照类型的限制调用对象的方法。引用既不知道也不关心执行哪一段代码。编译期间 的子类型关系检查保证了通过的对象有能力在被调用的时候选择合适的实现代码。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">然而，他们在实现层上有一个重要的差别。在 poly1(Base)的例子中（图3和图4），Base-Derived-Derived2的类继承结构为子类型关系的建立提供了条件，并决定了方法去 调用哪段代码。在poly2(IType)的例子中（如图5），则是完全不同的动态发生的。Derived2和Separate不共享任何实现的层次，但 是他们还是通过IType的引用展示了多态的行为。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">这样的多态行为使Java的接口的功能的重大意义显得很明显。图1中的UML类图 说明了Derived是Base和IType的子类型。通过完全脱离实现细节的类型的定义方法，Java实现了多类型继承，并且不存在Java所禁止的多 继承所带来的烦人的问题。完全脱离实现层次的类可以按照Java接口实现分组。在图1中，接口IType和Derived,Separate以及这类型的 其他子类型应该划为一组。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">按照这种完全不同于实现层次的分类方法，Java的接口机制是多态变得很方便，哪怕不存在任何共享的实现或 者复写的方法。如图5所示，一个IType的引用，用多态的方法访问到了Derived2和Separate对象的m3()方法。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">再次探讨对象的接口</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">注意图5中的Derived2和Separate对象的对m1()的映射方法。如前所述，每一个对象的接 口都包含方法m1()。但却没有办法用这两个对象使方法m1()表现出多态的行为。每一个对象占有一个m1()方法是不够的。必须存在一个可以操作 m1()方法的类型，通过这个类型可以看到对象。这些对象似乎是共享了m1()方法，但在没有共同基类的条件下，多态是不可能的。通过对象的接口来看多 态，会把这个概念搞混。</span></p><p><br></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">结论</span></strong></p><p><strong><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F"><br></span></strong></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">从全文所述的面向对象多态所建立起来的子类型多态，你可以清楚地认识到这种面向类型的观点。如果你想理解子类型多态的思想，就应该把注意力从实现的细节转移到类型的上。类型把对象分成组，并且管理着这些对象的接口。类型的 继承层次结构决定了实现多态所需的类型关系。</span></p><p><br></p><p><span style="background-color:#f2f2f2;--tt-darkmode-bgcolor: #1F1F1F">有趣的是，实现的细节并不影响子类型多态的层次结构。类型决定了对象调用什么方法，而是 现则决定了对象怎么执行这个方法。也就是说，类型表明了责任，而负责实施的则是具体的实现。将实现和类型分离后，我们好像看到了这两个部分在一起跳舞，类 型决定了他的舞伴和舞蹈的名字，而实现则是舞蹈动作的设计师。</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','基础','多态'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/892ce3a.html alt=Java基础（多态的理解与应用) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/892ce3a.html title=Java基础（多态的理解与应用)>Java基础（多态的理解与应用)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>