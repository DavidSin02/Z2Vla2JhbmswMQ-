<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>限定性数据结构-栈 | 极客快訊</title><meta property="og:title" content="限定性数据结构-栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/c95bc715a6da49bc869c24536b755a05"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/af66f5e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/af66f5e.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="限定性数据结构-栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/af66f5e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>限定性数据结构-栈</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1. 栈的定义</p><h3 class=pgc-h-arrow-right>1.1 定义</h3><p>栈是限定仅在表尾进行插入和删除操作的线性表。</p><p>栈顶：把允许插入和删除的一端称为栈顶。</p><p>栈底：把和栈顶对应的另一端称为栈底。</p><p>空栈：不含任何数据元素的栈称为空栈。</p><p>栈的特性：先进后出，也叫做后进先出。</p><p>栈是一种特殊的线性表，栈内元素具有线性关系，即前驱和后继关系，定义中所说的仅在表尾进行插入和删除操作，即在栈顶进行插入和删除，而不是栈底。</p><h3 class=pgc-h-arrow-right>1.2 插入与删除概念</h3><p>栈的插入操作，叫做进栈，也叫压栈、入栈，如下图所示：</p><div class=pgc-img><img alt=限定性数据结构-栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c95bc715a6da49bc869c24536b755a05><p class=pgc-img-caption></p></div><p>栈的删除操作，叫做出站，也叫弹栈，如下图所示：</p><div class=pgc-img><img alt=限定性数据结构-栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b2c8b1961db34ea78794039cc51930ff><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>2. 栈的顺序存储结构</h2><h3 class=pgc-h-arrow-right>2.1 栈的顺序存储结构定义</h3><p>栈是特殊的线性表，如果采用顺序存储结构，我们称这种栈为顺序栈，我们用数组来实现顺序存储。</p><p>在顺序存储结构中，如果在数组的头部位置进行插入和删除，会涉及到后续元素的移位工作，所以我们在数组的末尾进行插入和删除操作，会更加便利，因此我们将数组的头部（即下标为0的位置）称为栈底，数组的尾部称为栈顶。</p><p>我们定义top指针（这里的指针并非实际意义上的指针，只是一种称呼）用来记录栈顶元素在数组中的位置，若栈的长度为MAXSIZE，那么栈顶位置top必须小于MAXSIZE，当栈存在一个元素时，top等于0，若为空栈，则top等于-1。</p><h4 class=pgc-h-arrow-right>顺序栈的结构定义：</h4><pre><code>#define OK 1#define ERROR 0#define TRUE 1#define FALSE 0#define MAXSIZE 20 /* 存储空间初始分配量 */typedef int Status;typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int *//* 顺序栈结构 */typedef struct{    SElemType data[MAXSIZE];    int top; /* 用于指向栈顶位置 */}SqStack;</code></pre><h3 class=pgc-h-arrow-right>2.2 顺序栈初始化</h3><p>顺序栈的结构比较简单，我们使用一段地址连续的存储单元来存储数据，所以在创建栈对象的时候，即申请了存储空间，因此初始化只需要设置初始值即可。</p><h4 class=pgc-h-arrow-right>代码实现：</h4><pre><code>//构建一个空栈SStatus InitStack(SqStack *S){    // 若栈不存在，返回error。    if (S == NULL) {        return ERROR;    }    // 设置top为-1，此时为空栈。    S-&gt;top = -1;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>2.3 顺序栈进栈操作——插入元素</h3><p>进栈即为在栈顶插入元素。</p><p>思路</p><ol start=1><li>判断栈是否已满，如果满了，则无法插入数据，返回error。</li><li>将栈顶指针top++。</li><li>将新插入的元素赋值给栈顶空间。</li><li>返回OK。</li></ol><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>// 插入元素e为新栈顶元素Status PushData(SqStack *S, SElemType e){    //栈已满    if (S-&gt;top == MAXSIZE -1) {        return ERROR;    }    //栈顶指针+1;    S-&gt;top ++;    //将新插入的元素赋值给栈顶空间    S-&gt;data[S-&gt;top] = e;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>2.4 顺序栈出栈操作——删除元素</h3><h4 class=pgc-h-arrow-right>思路</h4><ol start=1><li>判断栈是否为空栈，如果是空栈，则无法进行操作，返回error。</li><li>将删除元素赋值给e，并带回调用函数。</li><li>将栈顶指针top--。</li><li>返回OK。</li></ol><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>// 删除S栈顶元素,并且用e带回Status Pop(SqStack *S,SElemType *e){    //空栈,则返回error;    if (S-&gt;top == -1) {        return ERROR;    }    //将要删除的栈顶元素赋值给e    *e = S-&gt;data[S-&gt;top];    //栈顶指针--;    S-&gt;top--;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>2.5 顺序栈置空与判断</h3><p>置空</p><p>将栈置空，我们不需要将顺序栈的元素都清空，只需要修改top指针即可。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>// 将栈置空Status ClearStack(SqStack *S){    S-&gt;top = -1;    return OK;}</code></pre><p>判断</p><p>上面我们说过，当栈的top指针为-1的时候，则栈为空栈。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>// 判断顺序栈是否为空;Status StackEmpty(SqStack S){    if (S.top == -1)        return TRUE;    else        return FALSE;}</code></pre><h3 class=pgc-h-arrow-right>2.6 获取顺序栈栈顶元素</h3><p>获取顺序栈栈顶元素即获取数组最后一个元素。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>// 获取栈顶Status GetTop(SqStack S,SElemType *e){    if (S.top == -1)        return ERROR;    else        *e = S.data[S.top];    return OK;}</code></pre><h3 class=pgc-h-arrow-right>2.7 遍历顺序栈元素</h3><p>遍历顺序栈元素即遍历数组的每个元素。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>// 从栈底到栈顶依次对栈中的每个元素打印Status StackTraverse(SqStack S){    int i = 0;    printf("此栈中所有元素");    while (i&lt;=S.top) {        printf("%d ",S.data[i++]);    }    printf("\n");    return OK;}</code></pre><h2 class=pgc-h-arrow-right>3. 栈的链式存储结构</h2><h3 class=pgc-h-arrow-right>3.1 栈的链式存储结构定义</h3><p>上面我们了解的栈的顺序存储结构，那么如果栈用链表结构进行存储，即为栈的链式存储结构，我们成为链式栈，或链栈。</p><p>在链式栈中，我们采用单链表的形式存储栈的每个元素，那么我们如何定义栈顶和栈底呢，如果将单链表的表尾当做栈顶，那么每次插入和删除的时候，我们则需要遍历找到尾部元素，这样很麻烦，每个链表都有自己的头指针，因此，将链表的头部当做栈顶，我们只需要修改一下链表元素前后关系即可。</p><p>链式栈中，我们只会在链表的头部进行操作，所以链表的头结点的意思荡然无存，因此链表的第一个元素即为首元结点。</p><p>顺序栈中，我们需要考虑栈的溢出情况，因为我们每次申请的空间是固定的，但是在链式栈中，无需考虑溢出情况，除非计算机的内存不够了。</p><p>在链式栈中，当top指针为NULL的时候，则认为这是一个空链式栈。</p><h4 class=pgc-h-arrow-right>链式栈的结构定义：</h4><pre><code>/* 链式栈结点结构 */typedef struct StackNode{    SElemType data;    struct StackNode *next;}StackNode,*LinkStackPtr;/* 链式栈结构 */typedef struct{    LinkStackPtr top;    int count;}LinkStack;</code></pre><p>链式栈示意图</p><div class=pgc-img><img alt=限定性数据结构-栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5884eb1fdde84c0c8e17a90e5a8118f1><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>3.2 链式栈初始化</h3><p>链式栈中没有采用头结点，因此初始化时只需要设置初始值，不需要开辟空间。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>/* 构造一个空栈S */Status InitStack(LinkStack *S){    S-&gt;top=NULL;    S-&gt;count=0;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>3.3 链式栈进栈操作——插入元素</h3><h4 class=pgc-h-arrow-right>思路</h4><ol start=1><li>创建新增的结点temp，并对新增结点进行赋值。</li><li>将新增结点temp的后继指向当前栈顶结点S->top。</li><li>修改栈顶指针S->top为temp。</li><li>栈元素数量加1。</li><li>返回OK。</li></ol><div class=pgc-img><img alt=限定性数据结构-栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/97b8d34b097e4813ab49d423201f778c><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>/* 插入元素e到链栈S (成为栈顶新元素)*/Status Push(LinkStack *S, SElemType e){    //创建新结点temp    LinkStackPtr temp = (LinkStackPtr)malloc(sizeof(StackNode));    //赋值    temp-&gt;data = e;    //把当前的栈顶元素赋值给新结点的直接后继, 参考上图第①步骤;    temp-&gt;next = S-&gt;top;    //将新结点temp 赋值给栈顶指针,参考图例第②步骤;    S-&gt;top = temp;    S-&gt;count++;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>3.4 链式栈出栈操作——删除元素</h3><h4 class=pgc-h-arrow-right>思路</h4><ol start=1><li>若栈内已无元素，则无法删除元素，返回error。</li><li>将栈顶元素值赋值给e，并带回调用函数。</li><li>创建临时变量p指向栈顶元素。</li><li>将栈顶指针向下移动一位。</li><li>释放原栈顶元素p。</li><li>栈元素数量减1.</li><li>返回OK。</li></ol><div class=pgc-img><img alt=限定性数据结构-栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/64f0c24c34184679939236b8f90adfe2><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>/* 若栈不为空,则删除S的栈顶元素,用e返回其值. 并返回OK,否则返回ERROR*/Status Pop(LinkStack *S,SElemType *e){    LinkStackPtr p;    if ((*S).count == 0) {        return ERROR;    }    //将栈顶元素赋值给*e    *e = S-&gt;top-&gt;data;    //将栈顶结点赋值给p,参考图例①    p = S-&gt;top;    //使得栈顶指针下移一位, 指向后一结点. 参考图例②    S-&gt;top= S-&gt;top-&gt;next;    //释放p    free(p);    //个数--    S-&gt;count--;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>3.5 链式栈置空与判断</h3><h4 class=pgc-h-arrow-right>置空</h4><ol start=1><li>创建结点指针p,q，将p指向栈顶。</li><li>循环遍历链表，将p赋值给q，p指向下一个结点，释放q。</li><li>当遍历到末尾时，即链表所有结点都已经释放，设置栈元素数量为0.</li><li>返回OK。</li></ol><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>/* 把链栈S置为空栈*/Status ClearStack(LinkStack *S){    LinkStackPtr p,q;    p = S-&gt;top;    while (p) {        q = p;        p = p-&gt;next;        free(q);    }    S-&gt;count = 0;    return OK;}</code></pre><p>判断</p><p>判断是否为空栈，只需要判断count是否为0即可。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>/* 若栈S为空栈,则返回TRUE, 否则返回FALSE*/Status StackEmpty(LinkStack S){    if (S.count == 0)        return TRUE;    else        return FALSE;}</code></pre><h3 class=pgc-h-arrow-right>3.6 链式栈获取栈顶元素</h3><p>获取链式栈栈顶元素即获取链表的第一个结点元素。</p><h4 class=pgc-h-arrow-right>代码实现</h4><pre><code>/* 若链栈S不为空,则用e返回栈顶元素,并返回OK ,否则返回ERROR*/Status GetTop(LinkStack S,SElemType *e){    if(S.top == NULL)        return ERROR;    else        *e = S.top-&gt;data;    return OK;}</code></pre><h3 class=pgc-h-arrow-right>3.7 遍历链式栈元素</h3><p>遍历链式栈元素即遍历链表的每个元素。</p><p>代码实现</p><pre><code>/* 遍历链栈*/Status StackTraverse(LinkStack S){    LinkStackPtr p;    p = S.top;    while (p) {        printf("%d ",p-&gt;data);        p = p-&gt;next;    }    printf("\n");    return OK;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','限定性'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>