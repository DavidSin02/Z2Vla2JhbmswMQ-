<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>赛尔笔记 | 自然语言处理中的迁移学习(下) | 极客快訊</title><meta property="og:title" content="赛尔笔记 | 自然语言处理中的迁移学习(下) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RfXcGOlHDeeb4s"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b4547cff.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b4547cff.html><meta property="article:published_time" content="2020-11-14T21:01:58+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:58+08:00"><meta name=Keywords content><meta name=description content="赛尔笔记 | 自然语言处理中的迁移学习(下)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b4547cff.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>赛尔笔记 | 自然语言处理中的迁移学习(下)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>作者：哈工大SCIR 徐啸</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGOlHDeeb4s><p><strong>本文小结：</strong>本文为教程的第二篇，包含教程的 3-6 部分。</p><p><strong>相关链接：</strong>赛尔笔记 | 自然语言处理中的迁移学习(上)</p><p></p><h1 toutiao-origin=h2>提纲</h1><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfRw76fAlAwY3S><ol><li><p>介绍：本节将介绍本教程的主题：迁移学习当前在自然语言处理中的应用。在不同的迁移学习领域中，我们主要定位于顺序迁移学习 sequential transfer learning 。</p></li><li><p>预训练：我们将讨论无监督、监督和远程监督的预训练方法。</p></li><li><p>表示捕获了什么：在讨论如何在下游任务中使用预训练的表示之前，我们将讨论分析表示的方法，以及观察到它们捕获了哪些内容。</p></li><li><p>调整：在这个部分，我们将介绍几种调整这些表示的方法，包括特征提取和微调。我们将讨论诸如学习率安排、架构修改等的实际考虑。</p></li><li><p>下游应用程序：本节，我们将重点介绍预训练的表示是如何被用在不同的下游任务中的，例如文本分类、自然语言生成、结构化预测等等。</p></li><li><p>开放问题和方向：在最后一节中，我们将提出对未来的展望。我们将突出待解决的问题以及未来的研究方向。</p></li></ol><p></p><h1 toutiao-origin=h2>3. 表示捕获了什么</h1><p><strong>为什么要关心表示捕获了什么？</strong></p><p>Swayamdipta, 2019</p><ul><li><p>在下游任务进行的外部评估</p></li><ul><li><p>复杂多样，随特定任务而不同</p></li></ul><li><p>Language-aware representations 语言感知表示</p></li><ul><li><p>泛化到其他任务的新的输入</p></li><li><p>作为可能改进预训练工作的中间步骤</p></li></ul><li><p>可解释！</p></li><ul><li><p>我们得到结果的原因是否正确?</p></li><li><p>发现偏见……</p></li></ul></ul><p><strong>分析什么？</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGP08Fo1zqO><ul><li><p>嵌入</p></li><ul><li><p>单词</p></li><li><p>上下文的</p></li></ul><li><p>网络激活</p></li><li><p>变化</p></li><ul><li><p>结构 (RNN / Transformer)</p></li><li><p>层</p></li><li><p>预训练目标</p></li></ul></ul><p><strong>分析方法 1：</strong><strong>可视化</strong></p><p>保持嵌入/网络激活静态或冻结</p><p><strong>可视化嵌入</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGPK7mQkpd4><ul><li><p>在低维(2D/3D)空间内绘制嵌入</p></li><ul><li><p>t-SNE (van der Maaten & Hinton, 2008)</p></li><li><p>PCA projections</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGPZ77VJa0n><p>可视化单词类比 (Mikolov et al. 2013)</p><p>空间关联</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGrRDX8ZB69><p>词汇语义的高级视图</p><p>只有有限的例子</p><p>与其他任务的连接尚不清楚 (Goldberg, 2017)</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGrg1nRoaqK><p>Radford et al., 2017</p><ul><li><p>神经元激活值与特征/标签相关</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGrr3RHC9e8><p>Karpathy et al., 2016</p><ul><li><p>标识学习可识别的功能</p></li><ul><li><p>如何选择某个神经元？难以扩展！</p></li><li><p>可解释 != 重要(Morcos et al., 2018)</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGs3JAmLgR2><ul><li><p>流行于机器翻译，或其他seq2seq架构:</p></li><ul><li><p>源字与目标字之间的对齐。</p></li><li><p>长距离词与词之间的依赖(句内注意)</p></li></ul><li><p>结构上的亮点</p></li><ul><li><p>拥有复杂的注意力机制可能是一件好事!</p></li><li><p>分层的</p></li></ul><li><p>解释可能很棘手</p></li><ul><li><p>只有几个例子？</p></li><li><p>Robust corpus-wide trends? Next !</p></li></ul></ul><p>Attention is not explanation | Attention is not not explanation</p><p><strong>分析方法 2: 行为探测器</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcGsLGL8Nj0J><ul><li><p>RNN-based 语言模型</p></li><ul><li><p>主谓关系中的数字一致性 number agreement in subject-verb dependencies</p></li><li><p>自然的、不自然的或不合语法的句子</p></li><li><p>对输出困惑度进行评估</p></li></ul><li><p>RNNs优于其他非神经方法的 Baseline</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcHOV3YvkBvg><ul><li><p>当显式地使用语法训练时，性能会提高(Kuncoro et al. 2018)</p></li></ul><p>Linzen et al., 2016; Gulordava et al. 2018; Marvin et al., 2018</p><ul><li><p>这种 probe 可能易受共现偏差的影响</p></li><ul><li><p>“dogs in the neighborhood bark(s)”</p></li><li><p>以前的句子可能和原来的太不一样了…</p></li></ul></ul><p><strong>分析方法 3: Classifier Probes</strong></p><p>保持嵌入/网络激活并在顶部训练一个简单的监督模型</p><p><strong>探测表层特征</strong></p><ul><li><p>给定一个句子，预测属性如</p></li><ul><li><p>长度</p></li><li><p>这个句子里有一个单词吗？</p></li></ul><li><p>给出句子中的单词的预测属性，例如：</p></li><ul><li><p>以前见过的词，与语言模型形成对比</p></li><li><p>词在句子中的位置</p></li></ul><li><p>检查记忆的能力</p></li><ul><li><p>训练有素的、更丰富的体系结构往往运行得更好</p></li><li><p>在语言数据上训练能记忆的更好</p></li></ul></ul><p>Zhang et al. 2018; Liu et al., 2018; Conneau et al., 2018</p><p><strong>探测词法，句法，语义</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcHOuBdg8irN><ul><li><p>词法学</p></li><li><p>词级别的语法</p></li><ul><li><p>POS tags, CCG supertags</p></li><li><p>Constituent parent, grandparent</p></li></ul><li><p>部分语法</p></li><ul><li><p>依赖关系</p></li></ul><li><p>部分语义</p></li><ul><li><p>实体关系</p></li><li><p>共指</p></li><li><p>角色</p></li></ul></ul><p>Adi et al., 2017; Conneau et al., 2018; Belinkov et al., 2017; Zhang et al., 2018; Blevins et al., 2018; Tenney et al. 2019; Liu et al., 2019</p><p><strong>探测分类结果</strong></p><ul><li><p>Contextualized > non-contextualized</p></li><ul><li><p>尤其是在句法任务上</p></li><li><p>更紧密的语义任务表现</p></li><li><p>双向上下文很重要</p></li></ul><li><p>BERT (large) 几乎总是获得最佳效果</p></li><ul><li><p>Grain of salt: 不同的上下文表示在不同的数据上训练，使用不同的架构……</p></li></ul></ul><p><strong>探测网络各层</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcHP7IBigaU6><p>Fig. from Liu et al. (NAACL 2019)</p><p>李如 对该篇文章做了简洁的总结</p><ul><li><p>CWRs（上下文词表征）编码了语言的哪些特征？</p></li><ul><li><p>在各类任务中，BERT>ELMo>GPT，发现“bidirectional”是这类上下文编码器的必备要素</p></li><li><p>相比于其他任务，编码器们在NER和纠错任务表现较差 => 没有捕获到这方面信息</p></li><li><p>在获得CWRs编码后，再针对任务增加MLP(relu)或者LSTM会提升效果</p></li><li><p>引出了问题：什么时候直接fine-tune编码器？什么时候freeze编码器，增加task-specific layer？</p></li></ul><li><p>编码器中不同层的迁移性是怎样变化的？</p></li><ul><li><p>对于ELMo(LSTM)来说，靠前的层更 transferable，靠后的层更 task-specific</p></li><li><p>对于 Transformer 来说，靠中间的层更 transferable ，但是把各个层加权起来的效果会更好</p></li><li><p>模型需要进行 trade off ，在任务上表现越好，迁移性越差</p></li></ul><li><p>预训练任务会对任务和迁移性有怎样的影响？</p></li><ul><li><p>双向语言模型预训练出来平均效果越好</p></li><li><p>预训练任务越接近特定任务，在特定任务的表现越好</p></li><li><p>预训练数据越多，表现越好</p></li></ul></ul><p>以上引用其总结的三点并稍作修改</p><ul><li><p>RNN 的各层：通用语言属性</p></li><ul><li><p>最低层：形态学</p></li><li><p>中间层：语法</p></li><li><p>最高层次：特定于任务的语义</p></li></ul><li><p>Transformer 的各层</p></li><ul><li><p>不同任务的不同趋势；mi<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">dd</i>le-heavy</p></li><li><p>参见Tenney et. al., 2019</p></li></ul></ul><p><strong>探测预训练目标</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcHPiCjSapJm><p>Zhang et al., 2018; Blevins et al., 2018; Liu et al., 2019;</p><ul><li><p>语言建模优于其他非监督和监督目标。</p></li><ul><li><p>机器翻译</p></li><li><p>依存分析</p></li><li><p>Skip-thought 预测上下文的句子</p></li></ul><li><p>低资源时(训练数据的大小)可能导致相反的趋势。</p></li></ul><p><strong>迄今为止我们学到了什么？</strong></p><ul><li><p>表征是对某些语言现象的预测:</p></li><ul><li><p>翻译中的对齐，句法层次结构</p></li></ul><li><p>有语法和没有语法的预训练:</p></li><ul><li><p>有语法的预训练具有更好的性能</p></li><li><p>但是如果没有语法，至少还是会学到些语法概念 (Williams et al. 2018)</p></li></ul><li><p>网络架构决定了表示中的内容</p></li><ul><li><p>句法与Bert Transformer (Tenney et al., 2019; Goldberg, 2019)</p></li><li><p>跨架构的不同的逐层趋势</p></li></ul></ul><p><strong>关于探测器的开放问题</strong></p><ul><li><p>一个好的探测器应该寻找什么信息?</p></li><ul><li><p>Probing a probe！</p></li></ul><li><p>探测性能告诉我们什么？</p></li><ul><li><p>很难综合各种基线的结果…</p></li></ul><li><p>它本身会带来一些复杂性吗</p></li><ul><li><p>线性或非线性分类</p></li><li><p>行为：输入句子的设计</p></li></ul><li><p>我们应该使用 probe 作为评估指标吗?</p></li><ul><li><p>可能会破坏目的…</p></li></ul></ul><p><strong>分析方法 4：</strong><strong>改变模型</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcHQ045Mdqk8><p>Li et al., 2016</p><ul><li><p>逐步删除或屏蔽网络组件</p></li><ul><li><p>词嵌入维度</p></li><li><p>隐藏单位</p></li><li><p>输入——单词/短语</p></li></ul></ul><p><strong>表示捕捉到了什么</strong><strong>？</strong></p><ul><li><p>这要看你怎么看了!</p></li><ul><li><p>可视化：</p></li><ul><li><p>鸟瞰</p></li><li><p>很少的样本——可能会让人想起 cherry-picking (最佳选择)</p></li></ul><li><p>调查：</p></li><ul><li><p>发现语料层面的特定属性</p></li><li><p>可能会引入自己的偏见…</p></li></ul><li><p>网络修改：</p></li><ul><li><p>对改进建模很有帮助</p></li><li><p>可以是特定于任务的</p></li></ul></ul><li><p>分析方法作为辅助模型开发的工具！</p></li></ul><p><strong>可解释性和可迁移性对下游任务而言是重要的。</strong></p><p></p><h1 toutiao-origin=h2>4. 调整</h1><p><strong>如何调整预训练模型</strong></p><p>我们可以在几个方向上做决定:</p><ul><li><p>结构的修改？</p></li><ul><li><p>为了适应，需要对预训练的模型体系结构进行多大的更改</p></li></ul><li><p>优化方案？</p></li><ul><li><p>在适应过程中需要训练哪些权重以及遵循什么时间表</p></li></ul><li><p>更多信号：弱监督、多任务和集成</p></li><ul><li><p>如何为目标任务获取更多的监督信号</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.1 结构</h2><p>两个通用选项：</p><ul><li><p>保持预训练模型内部不变</p></li><ul><li><p>在顶部添加分类器，在底部添加嵌入，将输出作为特征</p></li></ul><li><p>修改预训练模型的内部架构</p></li><ul><li><p>初始化编码器-解码器、特定于任务的修改、适配器</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.1.1 – 结构：保持模型不变</h2><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcHrB3CG5ZWJ><p>常规工作流：</p><ul><li><p>如果对目标任务无效，则删除预训练的任务头</p></li><ul><li><p>示例：从预训练语言模型中删除softmax分类器</p></li><li><p>不总是需要：一些调整方案重用了预训练的目标/任务，例如用于多任务学习</p></li></ul><li><p>在预训练模型的顶部/底部添加特定于任务的目标层</p><br></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcHrbCX9TV5s><ul><li><p>简单：在预训练的模型上添加线性层</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcHrt2GZLxcL><ul><li><p>更复杂的：将模型输出作为单独模型的输入</p></li><li><p>当目标任务需要预训练嵌入中所没有的交互时，通常是有益的</p></li></ul><p></p><h2 toutiao-origin=h3>4.1.2 – 结构：修改模型内部</h2><p>各种各样的原因:</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcHs7IDChibj><ul><li><p>适应结构上不同的目标任务</p></li><ul><li><p>例如：使用单个输入序列(例如:语言建模)进行预训练，但是适应多个输入序列的任务(例如:翻译、条件生成……)</p></li><li><p>使用预训练的模型权重尽可能初始化结构不同的目标任务模型</p></li><li><p>例如：使用单语语言模型初始化机器翻译的编码器和解码器参数 (Ramachandran et al., EMNLP 2017; Lample & Conneau, 2019)</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcHsZ7E76kUn><ul><li><p>特定于任务的修改</p></li><ul><li><p>提供对目标任务有用的预训练模型</p></li><li><p>例如：添加跳过/残差连接，注意力(Ramachandran et al., EMNLP 2017)</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcIJnIl1CYbC><ul><li><p>使用较少的参数进行调整:</p></li><ul><li><p>更少的参数进行微调</p></li><li><p>在模型参数不断增大的情况下，非常有用</p></li><li><p>例如:在预训练模型的层之间添加瓶颈模块(“适配器”) (Rebuffi et al., NIPS 2017;CVPR 2018)</p></li></ul></ul><p>Adapters</p><ul><li><p>通常使用剩余连接与现有层并行的层相连</p></li><li><p>每层之间都放置时效果最佳(底层效果较小)</p></li><li><p>不同的操作(卷积，自我注意)是可能的</p></li><li><p>特别适合 Transformer 等模块化架构 (Houlsby et al., ICML 2019; Stickland and Murray, ICML 2019</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcIKA8m8D2ul><p>Adapters (Stickland & Murray, ICML 2019)</p><ul><li><p>多头的<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">关注</i>(MH；跨层共享)与BERT的 self-attention (SA)层并行使用</p></li><li><p>两者都被加在一起，并输入到 Layer-norm (LN)中</p></li></ul><p></p><h2 toutiao-origin=h3>4.2 优化</h2><p>涉及到优化本身的几个方向:</p><ul><li><p>选择我们应该更新的权重</p></li><ul><li><p>Feature extraction, fine-tuning, adapters</p></li></ul><li><p>选择如何以及何时更新权重</p></li><ul><li><p>From top to bottom, gradual unfreezing, discriminative fine-tuning</p></li></ul><li><p>考虑实事求是的权衡</p></li><ul><li><p>Space and time comple<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">xi</i>ty, performance</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.2.1 – 优化: 什么权重？</h2><p>主要问题:调整还是不调整(预先训练好的重量)?</p><ul><li><p>不改变预先训练的重量</p></li><ul><li><p>Feature extraction</p></li><ul><li><p>(预训练的)权重被冻结</p></li></ul></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcIKf8mQiyuE><ul><ul><li><p>线性分类器是在预训练的表示上进行训练的</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcIKvGVwf8um><ul><ul><li><p>不要只使用顶层的特性!</p></li><li><p>学习层的线性组合 (Peters et al., NAACL 2018, Ruder et al., AAAI 2019)</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcIL932JYblQ><ul><ul><ul><li><p>或者，在下游模型中使用预先训练的表示作为特性</p></li></ul><li><p>Adapters</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcIqm93Z8euG><ul><ul><li><p>在现有层之间添加的特定于任务的模块</p></li><li><p>只有 adapters 被训练</p></li></ul><li><p>改变预训练权重</p></li><ul><li><p>fine-tuning</p></li><ul><li><p>采用预训练的权重作为下游模型参数的初始化</p></li><li><p>整个预训练的体系结构在适应阶段进行训练</p></li></ul></ul></ul><p><strong>4.2.2 – 优化：</strong><strong>什么方式？</strong></p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcIr1191T4wR><p>我们已经决定要更新哪些权重，但是以什么顺序以及如何更新它们？</p><p>动机：我们希望避免覆盖有用的预训练信息，并最大化积极的知识迁移</p><p>相关概念：灾难遗忘 (McCloskey＆Cohen, <i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">198</i>9; French, <i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">199</i>9) :一个模型忘记了它最初受过训练的任务</p><p><strong>指导原则：</strong><strong>从上到下更新</strong></p><ul><li><p>时间上逐步更新：冻结</p></li><li><p>强度上逐步更新：改变学习速度</p></li><li><p>Progressively vs. the pretrained model 逐步更新 vs 预训练模型：正则化</p></li></ul><p><strong>优化：</strong><strong>冻结</strong></p><ul><li><p>主要直觉：在不同分布和任务的数据上同时训练所有层可能导致不稳定的不良解决方案</p></li><li><p>解决方案：单独训练每一层，使他们有时间适应新的任务和数据。</p></li><li><p>回到早期深度神经网络的分层训练（Hinton et al., 2006; Bengio et al., 2007）</p></li></ul><p>相关实例</p><ul><li><p>冻结顶层以外的所有层 (Long et al., ICML 2015)</p></li><li><p>Chain-thaw (Felbo et al., EMNLP 2017):每次训练一层</p></li><ul><li><p>先训练新增的层</p></li><li><p>再自底向上，每次训练一层（不再训练新增的那一层，其余层以会在不训练时被同时冻结）</p></li><li><p>训练所有层（包括新增层）</p></li></ul><li><p>Gradually unfreezing (Howard & Ruder, ACL 2018): 逐层解冻（自顶向下）</p></li><li><p>Sequential unfreezing (Chronopoulou et al., NAACL 2019): 超参数控制微调轮数</p></li><ul><li><p>微调 n 轮次新增参数（冻结除了新增层以外的层）</p></li><li><p>微调 k 轮次嵌入层以外的预训练层</p></li><li><p>训练所有层直到收敛</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.2.2 – 优化：学习率</h2><p><strong>主要想法：使用更低的学习率来避免覆盖掉有用的信息</strong></p><p>在哪里以及在什么时候？</p><ul><li><p>低层(捕获一般信息)</p></li><li><p>训练初期(模型仍需适应目标分布)</p></li><li><p>训练后期(模型接近收敛)</p></li></ul><p>相关实例 (Howard & Ruder, ACL 2018)</p><p>较低层捕获一般信息 → 对较低层使用较低的学习速率</p><p>Discriminative fine-tuning</p><p>较低的层捕获一般信息对较低的层次使用较低的学习率</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcIrH3QxQFxi><p>Triangular learning rates</p><p>快速移动到一个合适的区域，然后随着时间慢慢收敛</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcIrUFm13ezA><ul><ul><li><p>也被称为 “learning rate warm-up”</p></li><li><p>用于 Transformer (Vaswani et al., NIPS 2017) 和 Transformer-based methods (BERT, GPT) 等</p></li><li><p>有利于优化；更容易摆脱次优局部极小值</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.2.2 – 优化：正则化</h2><p>主要思想：通过使用正则化项 ，鼓励目标模型参数接近预先训练的模型参数，将灾难性遗忘最小化。</p><p>简单的方法:将新参数正则化，不要与预训练的参数偏离太多 (Wiese et al., CoNLL 2017)</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcIrg8PG7k2o><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJB3BvwAHpj><p>更高级(elastic weight consolidation; EWC)(Kirkpatrick et al., PNAS 2017)</p><p>基于 Fisher 信息矩阵 F ，<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">关注</i>对预训练任务重要的参数</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJBJ2W0TLVy><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJBX1wT4tGw><p>EWC在持续学习方面有缺点:</p><p>可能过度约束参数</p><p>计算成本与任务数量成线性关系(Schwarz et al., ICML 2018)</p><p>如果任务相似，我们也可以鼓励基于交叉熵的源和目标预测接近，类似于蒸馏:</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcJBuAZH9AZw><p></p><h2 toutiao-origin=h3>4.2.3 – 优化：权衡</h2><p>在选择更新哪些权重时，需要权衡以下几个方面：</p><p>A. 空间复杂度</p><ul><li><p>特定于任务的修改、附加参数、参数重用</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJC8Demze43><p>B. 时间复杂度</p><ul><li><p>训练时间</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcJX8EvPThrN><p>C. 性能</p><ul><li><p>经验法则：如果任务源和目标任务不相似*，使用特征提取 (Peters et al., 2019)</p></li><li><p>否则，特征提取和微调常常效果类似（此时用微调更好）</p></li><li><p>在文本相似性任务上对 BERT 进行微调，效果明显更好</p></li><li><p>适配器实现了与微调相比具有竞争力的性能</p></li><li><p>有趣的是，Transformer 比 LSTMs 更容易微调(对超参数不那么敏感)</p></li></ul><p>*不相似：某些能力(例如句子间关系建模)对目标任务是有益的，但预训练的模型缺乏这些能力能(参见后面的更多内容)</p><p></p><h2 toutiao-origin=h3>4.3 – 获得更多信号</h2><p>目标任务通常是低资源任务。我们经常可以通过组合不同的信号，提高迁移学习的效果：</p><ul><li><p>在单个适应任务上微调单个模型</p></li><ul><li><p>基本原理：用一个简单的分类目标对模型进行微调</p></li></ul><li><p>其他数据集和相关任务中收集信号</p></li><ul><li><p>微调与弱监督，多任务和顺序调整</p></li></ul><li><p>集成模型</p></li><ul><li><p>结合几个微调模型的预测</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.3.1 – 获得更多信号：基本的 fine-tuning</h2><p>微调文本分类任务的简单例子：</p><ul><li><p>从模型中提取单个定长向量</p></li><ul><li><p>第一个/最后一个令牌的隐藏状态，或者是隐藏状态的平均值/最大值</p></li></ul><li><p>使用附加的分类器投影到分类空间</p></li><li><p>用分类目标函数训练</p></li></ul><p></p><h2 toutiao-origin=h3>4.3.2 – 获得更多信号：相关数据集/任务</h2><ul><li><p>顺序调整 Sequential adaptation</p></li><ul><li><p>对相关数据集和任务进行中间微调</p></li></ul><li><p>与相关任务进行多任务微调</p></li><ul><li><p>如 GLUE 中的 NLI 任务</p></li></ul><li><p>数据集分割</p></li><ul><li><p>当模型在特定的数据片上始终表现不佳时</p></li></ul><li><p>半监督学习</p></li><ul><li><p>使用未标记的数据来提高模型的一致性</p></li></ul></ul><p></p><h2 toutiao-origin=h3>4.3.2 – 获得更多信号：顺序调整</h2><p>在相关高资源数据集进行微调</p><ol><li><p>在拥有更多的数据的相关任务对模型进行微调</p></li><li><p>在目标任务上微调数据集</p></li></ol><ul><li><p>对于数据有限并且有类似任务的任务尤其有用(Phang et al., 2018)</p></li><li><p>提高目标任务的样本复杂度(Yogatama et al., 2019)</p></li></ul><p></p><h2 toutiao-origin=h3>4.3.2 – 获得更多信号：多任务 fine-tuning</h2><p>在相关任务上共同微调模型</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJXPCXHYiAk><ul><li><p>对于每个优化步骤，取样一个任务和一批数据进行训练</p></li><li><p>通过多任务学习训练多轮</p></li><li><p>只在最后几个阶段对目标任务进行微调</p></li></ul><p>使用无监督的辅助任务微调模型</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcJXd6GmZby2><p>语言建模是一个相关的任务！</p><p>微调语言模型有助于将预训练的参数调整到目标数据集</p><p>即使没有预训练，也会起到帮助 (Rei et al., ACL 2017)</p><p>可选退火比</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcJXvCpYMCCK><p>(Chronopoulou et al., NAACL 2019)</p><p>作为 ULMFiT 中的一个单独步骤使用</p><p></p><h2 toutiao-origin=h3>4.3.2 – 获得更多信号：数据集切分</h2><p>使用仅在数据的特定子集上训练的辅助头</p><ul><li><p>分析模型误差</p></li><li><p>使用启发式方法自动识别训练数据的挑战性子集</p></li><li><p>与主头一起联合训练辅助头</p></li></ul><p>See also Massive Multi-task Learning with Snorkel MeTaL</p><p></p><h2 toutiao-origin=h3>4.3.2 – 获得更多信号：半监督学习</h2><p>使用未标记的数据可以使模型预测更加一致</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJY9F7Uvq3D><ul><li><p>主要思想:使对原始输入 x 和扰动输入 x' 的预测之间的距离最小化</p></li><li><p>扰动可以是噪声、掩蔽(Clark et al., EMNLP 2018)、数据增强，例如 back-translation (Xie et al., 2019)</p></li></ul><p></p><h2 toutiao-origin=h3>4.3.3 – 获得更多信号：集成</h2><p>通过集成独立的微调模型达到最先进水平</p><ul><li><p>集成模型：使用各种超参数微调模型预测的组合</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJw411ql39t><ul><ul><li><p>在不同的任务</p></li><li><p>在不同的数据集分块</p></li><li><p>使用不同的参数(dropout, initializations…)</p></li><li><p>来自预训练模型的变体(例如 cased/uncased )</p></li></ul><li><p>知识蒸馏：在一个更小的模型中提取一组调优模型</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJwYGqVYAtZ><ul><ul><li><p>知识蒸馏：在教师（集成模型）制作的软目标上训练学生模型</p></li><li><p>教师标签的相对概率包含教师如何概括的信息</p></li></ul></ul><p></p><h1 toutiao-origin=h2>5. 下游应用程序</h1><p>在本节中，我们将沿两个方向探索下游的应用和实际考虑:</p><ul><li><p>迁移学习在自然语言处理中的各种应用是什么</p></li><ul><li><p>文档/句子分类、令牌级分类、结构化预测和语言生成</p></li></ul><li><p>如何利用多个框架和库来实现实际应用</p></li><ul><li><p>Tensorflow、PyTorch、Keras和第三方库，例如 fast.ai, HuggingFace……</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJwq3XuwzOq><ul><li><p>句子和文档级分类</p></li><ul><li><p>动手实践：文档级分类(fast.ai)</p></li></ul><li><p>令牌分类</p></li><ul><li><p>实践：问答(谷歌BERT & Tensorflow/TF Hub)</p></li></ul><li><p>语言生成</p></li><ul><li><p>实践：对话生成(OpenAI GPT & HuggingFace/PyTorch Hub)</p></li></ul></ul><p>本部分内容偏向编程实践，将在本教程的第三篇中进行补充</p><p></p><h2 toutiao-origin=h3>5.1 – 句子和文档级别分类</h2><p>使用 fast.ai 库完成文档分类的迁移学习</p><ul><li><p>目标任务</p></li><ul><li><p>IMDB：一个二元情绪分类数据集，包含用于训练的25k个高度极性的电影评论，用于测试的25k个，以及其他未标记的数据。https://ai.stanford.edu/~amaas/data/sentiment/</p></li><li><p>Fast.ai 特别提供了:</p></li><ul><li><p>一个预先训练的英文模型可供下载</p></li><li><p>一个标准化的数据块API</p></li><li><p>易于访问标准数据集，如IMDB</p></li></ul><li><p>fast.ai 基于 PyTorch</p></li></ul></ul><p>fast.ai 为视觉、文本、表格数据和协同过滤提供了许多开箱即用的高级API</p><p>库的设计是为了加快实验的速度，例如在互动计算环境中一次导入所有必需的模块，例如:</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJxP3nZliRd><p>Fast.ai 包含快速设置迁移学习实验所需的所有高级模块。</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcJxcINZAcho><ul><li><p>加载数据集</p></li><li><p>使用语言模型和分类器的 DataBunch</p></li><li><p>使用语言模型损失函数，在 WikiText-103 上预训练的 AWD-LSTM 并在 IMDB 数据集上微调</p></li></ul><p>一旦我们有了微调的语言模型(AWD-LSTM)，我们可以创建一个文本分类器，添加一个分类头:</p><ul><li><p>将RNN的最终输出的最大值与所有中间输出(沿着序列长度)的平均值连接起来的层</p></li><li><p>Two blocks of nn.BatchNorm1d ⇨ nn.Dropout ⇨ nn.Linear ⇨ nn.ReLU 的隐藏维度为50</p></li><li><p>分两步微调</p></li><ul><li><p>只训练分类头，同时保持语言模型不变</p></li><li><p>微调整个结构</p></li></ul><li><p>Colab: tiny.cc/NAACLTransferFastAiColab</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcKSs3uFSnpX><p></p><h2 toutiao-origin=h3>5.2 – Token 级别分类: BERT & Tensorflow</h2><p>用于令牌级分类的迁移学习：谷歌的 BERT in TensorFlow</p><ul><li><p>目标任务:</p></li><ul><li><p>SQuAD: 回答问题的数据集 https://rajpurkar.github.io/SQuAD-explorer/</p></li></ul><li><p>在本例中，我们将直接使用 Tensorflow checkpoint</p></li><ul><li><p>例如：https://github<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-6">.com</i>/google-research/bert/</p></li><li><p>我们使用通常的Tensorflow工作流：创建包含核心模型和添加/修改元素的模型图</p></li><li><p>加载检查点时要注意变量分配</p></li></ul></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RfXcKTDFGbvS3n><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcKTcuEoRPv><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcKTp4fJVj7Y><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcKUBApFqyOx><p>语言生成迁移学习：OpenAI GPT 和 HuggingFace 库</p><ul><li><p>目标任务</p></li><ul><li><p>ConvAI2 -第二届会话智能挑战，用于训练和评估非目标导向对话系统的模型，例如闲聊</p></li><ul><li><p>http://convai.io</p></li></ul></ul><li><p>预训练模型的 HuggingFace 仓库</p></li><ul><li><p>大型预先训练模型 BERT, GPT, GPT-2, Transformer-XL 的仓库</p></li><li><p>提供一个简单的方法来下载、实例化和训练PyTorch中预先训练好的模型</p></li></ul><li><p>HuggingFace的模型现在也可以通过PyTorch Hub访问</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcL3bDwVuMC6><p>语言生成任务接近语言建模训练前的目标，但是:</p><ul><li><p>语言建模前的训练只需要一个输入：一系列单词</p></li><li><p>在对话框设置中：提供了几种类型的上下文来生成输出序列</p></li><ul><li><p>知识库：角色句</p></li><li><p>对话的历史：至少是用户的最后一句话</p></li><li><p>已生成的输出序列的标记</p></li></ul></ul><p>我们应该如何适应这种模式？</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcL3yE9cvTvm><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcL4HIkhkfTr><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RfXcL4W6VZSbFh><p></p><h1 toutiao-origin=h2>6. 开放问题和方向</h1><p>预训练的语言模型的缺点</p><ul><li><p>概述：语言模型可视为一般的预训练任务；有了足够的数据、计算和容量，LM可以学到很多东西</p></li><li><p>在实践中，许多在文本中表示较少的东西更难学习</p></li><li><p>预先训练好的语言模型并不擅长</p></li><ul><li><p>细粒度语言任务 (Liu et al., NAACL 2019)</p></li><li><p>常识(当你真的让它变得困难 Zellers et al., ACL 2019)；自然语言生成(维护长期依赖、关系、一致性等)</p></li><li><p>当微调时，倾向于过度适应表面形成的信息；‘rapid surface learners’</p></li></ul></ul><p>大型的、预训练的语言模型很难优化。</p><ul><li><p>微调通常是不稳定的，并且有很高的方差，特别是在目标数据集非常小的情况下</p></li><li><p>Devlin et al. (NAACL 2019) 指出，BERT的大版本(24层)特别容易导致性能退化；多次随机重启有时是必要的，这在(Phang et al., 2018)中也有详细的研究</p></li></ul><p>当前的预训练语言模型非常大</p><ul><li><p>我们真的需要所有这些参数吗？</p></li><li><p>最近的研究表明，BERT中只需要几个注意力头(Voita et al., ACL 2019)</p></li><li><p>需要做更多的工作来理解模型参数</p></li><li><p>修剪和蒸馏是两种处理方法</p></li><li><p>参见：彩票假说(Frankle et al., ICLR 2019)</p></li></ul><p><strong>预训练任务</strong></p><p>语言建模目标的不足</p><ul><li><p>并不适用于所有模型</p></li><ul><li><p>如果我们需要更多的输入，就需要对这些部件进行预培训</p></li><li><p>例如序列到序列学习中的解码器(Song et al., ICML 2019)</p></li></ul><li><p>从左到右的偏见并不总是最好的</p></li><ul><li><p>考虑更多上下文(如屏蔽)的目标似乎有用(采样效率较低)</p></li><li><p>可能组合不同LM变种(Dong et al., 2019)</p></li></ul><li><p>语义和长期上下文的弱信号与语法和短期单词共存的强信号</p></li><ul><li><p>需要激励机制来促进我们所关心的编码，例如语义</p></li></ul></ul><p>更加多样化的自我监督目标</p><ul><li><p>从计算机视觉中获得灵感</p></li><li><p>语言中的自我监督主要基于词的共现(Ando and Zhang, 2005)</p></li><li><p>不同层次意义上的监督</p></li><ul><li><p>论述、文件、句子等</p></li><li><p>使用其他信号，例如元数据</p></li></ul><li><p>强调语言的不同性质</p></li></ul><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RfXcL4vGZnKyHw><p>抽样一个补丁和一个邻居，并预测它们的空间配置(Doersch et al., ICCV 2015)</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RfXcLW5FApR9xt><p>图片着色 (Zhang et al., ECCV 2016)</p><p>专门的预训练任务来教我们的模型缺少的东西</p><ul><li><p>制定专门的预训练任务，明确学习这些关系</p></li><ul><li><p>获取背景知识的单词对关系 (Joshi et al., NAACL 2019)</p></li><li><p>范围级表示(Swayamdipta et al., EMNLP 2018)</p></li><li><p>不同的预训练词嵌入是有用的(Kiela et al., EMNLP 2018)</p></li></ul><li><p>其他预训练的任务可以明确地学习推理或理解</p></li><ul><li><p>算术、时间、因果等；话语、叙述、谈话等。</p></li></ul><li><p>预训练的表示可以以稀疏和模块化的方式连接</p></li><ul><li><p>基于语言子结构(Andreas et al., NAACL 2016) 或专家 (Shazeer et al., ICLR 2017)</p></li></ul></ul><p>需要更加合理的表示</p><ul><li><p>分布式假设的局限性——很难从原始文本中学习特定类型的信息</p></li><ul><li><p>人类报告偏见：不陈述显而易见的(Gordon and Van Durme, AKBC 2013)</p></li><li><p>常识不是写下来的</p></li><li><p>关于命名实体的事实</p></li><li><p>没有其他模式的基础</p></li></ul><li><p>可能的解决方式:</p></li><ul><li><p>吸收其他结构化知识(e.g. knowledge bases like ERNIE, Zhang et al 2019)</p></li><li><p>多模态学习(e.g. with visual representations like VideoBERT, Sun et al. 2019)</p></li><li><p>交互式/human-in-the-loop 的方法(e.g. dialog, Hancock et al. 2018)</p></li></ul></ul><p><strong>任务和任务的相似性</strong></p><p>许多任务可以表示为语言建模的变体</p><ul><li><p>语言本身可以直接用于指定任务、输入和输出，例如，通过构建QA (McCann et al., 2018)</p></li><li><p>基于对话的学习，不受正向预测的监督 (Weston, NIPS 2016)</p></li><li><p>将NLP任务制定为完形填空预测目标 (Children Book Test, LAMBADA, Winograd, ...)</p></li><li><p>通过提示触发任务行为，例如翻译提示 (Radford, Wu et al. 2019); 使zero-shot适应</p></li><li><p>质疑NLP中的“任务”概念</p></li><li><p>预训练和目标任务(NLI，分类)的直觉相似性与较好的下游性能相关</p></li><li><p>不清楚两个任务在什么时候以及如何相似和相关</p></li><li><p>获得更多理解的方法之一：大规模的迁移实证研究，如 Taskonomy (Zamir et al., CVPR 2018)</p></li><li><p>是否有助于设计更好和更专业的预训练任务</p></li></ul><p><strong>持续和元学习</strong></p><ul><li><p>当前迁移学习只进行一次适应。</p></li><li><p>最终，我们希望拥有能够在许多任务中持续保留和积累知识的模型(Yogatama et al., 2019)</p></li><li><p>预训练和适应之间没有区别；只有一个任务流</p></li><li><p>主要的挑战是:灾难性的遗忘</p></li><li><p>不同的研究方法：</p></li><ul><li><p>记忆、正则化、任务特定权重等</p></li></ul><li><p>迁移学习的目的：学习一种对许多任务都通用且有用的表示方法</p></li><li><p>客观因素不会刺激适应的易用性(通常不稳定)；没有学会如何适应它</p></li><li><p>元学习与迁移学习相结合可以使这一方法更加可行</p></li><li><p>然而，大多数现有的方法都局限于few-shot场景，并且只学习了几个适应步骤</p></li></ul><p><strong>偏见</strong></p><ul><li><p>偏见已经被证明普遍存在於单词嵌入和一般的神经模型中</p></li><li><p>大型预训练的模型必然有自己的一套偏见</p></li><li><p>常识和偏见之间的界限很模糊</p></li><li><p>我们需要在适应过程中消除这种偏见</p></li><li><p>一个小的微调模型应该更不易被误用</p></li></ul><p></p><h1 toutiao-origin=h2>结论</h1><ul><li><p>主题：语境中的词汇，语言模型预培训，深度模型</p></li><li><p>预训练具有较好的 sample-efficiency ，可按比例放大</p></li><li><p>对某些特性的预测——取决于您如何看待它</p></li><li><p>性能权衡，自顶向下</p></li><li><p>迁移学习易于实现，实用性强</p></li><li><p>仍然存在许多不足和尚未解决的问题</p></li></ul><p>本期责任编辑：崔一鸣</p><p>本期编辑：顾宇轩</p><img alt="赛尔笔记 | 自然语言处理中的迁移学习(下)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/R69F3rGCWOEqko></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'赛尔','笔记','语言'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>