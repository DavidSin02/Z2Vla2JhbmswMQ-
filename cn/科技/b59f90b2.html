<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SQL Server——游标详解 | 极客快訊</title><meta property="og:title" content="SQL Server——游标详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/456cfc0b6fb0444c87e68098345fa638"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b59f90b2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b59f90b2.html><meta property="article:published_time" content="2020-11-14T21:00:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:22+08:00"><meta name=Keywords content><meta name=description content="SQL Server——游标详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b59f90b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SQL Server——游标详解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/456cfc0b6fb0444c87e68098345fa638><p class=pgc-img-caption></p></div><h1>游标的应用</h1><p>查询语句可能返回多条记录，如果数据量非常大，需要使用游标来逐条读取查询结果集中的记录。应用程序可以根据需要滚动或者浏览其中的数据。</p><h1>游标的定义</h1><p>游标是一种数据访问机制，一种处理数据的方法，它允许用户访问单独的数据行。主要用于存储过程、触发器和Transac-SQL脚本中，他们使结果集的内容可用于其他Transac-SQL语句。在查看或处理结果集中的数据时，游标可以提供在结果集中向前或者向后浏览数据的功能。类似于C语言中的指针，他可以指向结果集中的任意位置。当要对结果集进行逐行单独处理时，必须声明一个指向该结果集的游标变量。</p><p>Sql Server中的数据操作结果都是面向集合的，并没有一种描述biao单一记录的表达形式。</p><h1>游标的优点</h1><p>1.用户可以对每一行进行单独处理，从而降低系统开销和潜在的阻隔情况，用户也可以使用这些数据生成SQL代码并立即执行或输出。</p><p>2.允许程序对有select查询语句返回的行集中地每行执行相同或不同的操作，而不是对整个集合执行同一个操作。</p><p>3.提供对基于游标位置的表中的行进行删除和更新的能力。</p><p>4.游标作为数据库管理系统和应用程序设计之间的桥梁，将两种处理方式连接起来。</p><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6353454a466e4fcfb22bc0a81b4ad9b8><p class=pgc-img-caption></p></div><h1>游标类型</h1><p><strong>1.Transac-SQL游标</strong></p><p>基于declare cursor语法，主要用于Transact-SQL脚本、存储过程和触发器。Transact-SQL游标在服务器上实现，并由从客户端发送到服务器的Transact-SQL语句管理。他们还可能包含在批处理、存储古城或触发器中。</p><p><strong>2.应用程序编程接口（API）服务器游标</strong></p><p>支持OLEDB和ODBC中的API游标函数，API服务器游标在服务器上实现。每次客户端应用程序调用API游标函数时，SQL Server Native ClientOLEDB 访问接口或者ODBC驱动程序会把请求传输到服务器，以便对API服务器游标进行操作。</p><p><strong>3.客户端游标</strong></p><p>由SQL Server Native Client ODBC 驱动程序和实现ADO API 的DLL在内部实现。 客户端游标通过在客户端高速缓存所有结果集中的行来实现。每次客户端应用程序调用API游标函数时，SQL Server Native Client ODBC驱动程序 或ADO DLL 会对客户端上高速缓存的结果集中的行执行游标操作。</p><p>由于Transact-SQL游标和API服务器游标都在服务器上实现，所以他们统称为服务器游标。ODBC 和ADO 定义了Microsoft SQL Server 支持的4种游标类型。</p><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5dee5155d04145b0a229c432fb75add3><p class=pgc-img-caption></p></div><h1>SQL Server 支持的4种API服务器游标类型</h1><blockquote><p>1.只进游标</p></blockquote><p>只进游标不支持滚动，他只支持游标从头到尾顺序提取。由于游标无法向后滚动，因此在提取行后对数据库中的行进行的大多数更改通过游标均不可见。</p><blockquote><p>2.静态游标</p></blockquote><p>SQL Server 静态游标始终是只读的。其完整结果集在打开游标时建立在tempdb中。静态游标总是按照打开游标时的原样显示结果集。</p><blockquote><p>3.由键集驱动的游标</p></blockquote><p>该游标中各行的成员身份和顺序是固定的。由键集驱动的游标由一组唯一标识符（键）控制，这组键成为键集。键是根据以唯一方式标识结果集中各行的一组列生成的。键集是打开游标时来自负荷select语句要求的所有行中的一组键值。由键集驱动的游标对应的键集是打开该游标时在tempdb中生成的。</p><blockquote><p>4.动态游标</p></blockquote><p>动态游标与静态游标相对。当滚动游标时，动态游标反映结果集中所做的所有更改。结果集中的行数据值、顺序和成员在每次提取时都会改变。所有用户做的全部update、insert和delete语句均通过游标可见。如果API函数（如SQLSetPos）或者Transact-SQL where current of 子句通过游标进行更新，他们将立即可见。在游标外部所做的更新知道提交时才可见，除非将游标的事务隔离级别设置为未提交读。</p><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8040c7b62b3e49f4a5f3089ee9412449><p class=pgc-img-caption></p></div><h1>声明游标</h1><blockquote><p>游标主要包括<strong>游标结果集</strong>和<strong>游标位置</strong>两部分，游标结果集是由定义游标的select语句返回的行集合，游标位置则是指向这个结果集中的某一行的指针。</p></blockquote><p><strong>语法格式：</strong></p><pre>declare cursor_name cursor [ local | global ]  [ forward_only | scroll ]  [ static | keyset | dynamic | fast_forward ]  [ read_only | scroll_locks | optimistic ]  [ type_warning ]  for select_statement  [ for update [ of column_name [ ,...n ] ] ]</pre><p><strong>注：</strong></p><ol><li><strong>cursor_name: </strong>是所定义的Transact-SQL 服务器游标的名称。</li><li><strong>Local：</strong>对于其中创建的批处理、存储过程或触发器来说，该游标的作用域是局部的。[Local | Global]:默认为local。</li><li><strong>Global：</strong>作用域为全局，由连接执行的任何存储过程或批处理中，都可以引用该游标。</li><li><strong>Forward_Only:</strong>指定游标智能从第一行滚到最后一行。Fetch Next是唯一支持的提取选项。如果在指定Forward_Only是不指定Static、KeySet、Dynamic关键字，默认为Dynamic游标。如果Forward_Only和Scroll没有指定，Static、KeySet、Dynamic游标默认为Scroll，Fast_Forward默认为Forward_Only</li><li><strong>Static:</strong>静态游标</li><li><strong>KeySet：</strong>键集游标</li><li><strong>Dynamic：</strong>动态游标，不支持Absolute提取选项</li><li><strong>Fast_Forward：</strong>指定启用了性能优化的Forward_Only、Read_Only游标。如果指定啦Scroll或For_Update，就不能指定他啦。</li><li><strong>Read_Only:</strong>不能通过游标对数据进行删改。</li><li><strong>Scroll_Locks：</strong>将行读入游标是，锁定这些行，确保删除或更新一定会成功。如果指定啦Fast_Forward或Static，就不能指定他啦。</li><li><strong>Optimistic：</strong>指定如果行自读入游标以来已得到更新，则通过游标进行的定位更新或定位删除不成功。当将行读入游标时，sqlserver不锁定行，它改用timestamp列值的比较结果来确定行读入游标后是否发生了修改，如果表不行timestamp列，它改用校验和值进行确定。如果已修改改行，则尝试进行的定位更新或删除将失败。如果指定啦Fast_Forward,则不能指定他。</li><li><strong>Type_Warning:</strong>指定将游标从所请求的类型隐式转换为另一种类型时向客户端发送警告信息。</li><li><strong>select_statement: </strong>是定义游标结果集的标准select语句。</li><li><strong>For Update[of column_name ,....] :</strong>定义游标中可更新的列。</li></ol><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1501fde772b4ca7b917c0c17063bb7b><p class=pgc-img-caption></p></div><h1>声明静态游标</h1><pre>--声明静态游标use TestSchoolgodeclare cursor_Adress cursor forselect Id,PCity ,Pcode from Adress;</pre><h1>声明动态游标</h1><pre>--声明动态游标declare TestData_cursor cursor localscrollDynamicread_onlyfor select Value from TestData where Id=111;</pre><h1>打开游标</h1><p><strong>语法：</strong></p><pre>open [ Global ] cursor_name | cursor_variable_name</pre><p><strong>注：</strong></p><ul><li><strong>Global：</strong>指定cursor_name是全局游标。</li><li><strong>cursor_name：</strong>已声明的游标名称。</li><li><strong>cursor_variable_name：</strong>游标变量的名称，该变量引用一个游标。</li></ul><h1>打开静态游标cursor_Adress</h1><pre>--打开静态游标cursor_Adressuse TestSchool;go open cursor_Adress;</pre><h1>打开动态游标cursor_TestData</h1><pre>--打开动态游标cursor_TestDatause TestSchool;goopen TestData_cursor;</pre><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9c503cfb188d420c932c89759d105451><p class=pgc-img-caption></p></div><h1>读取游标中的数据</h1><p>fetch命令可以读取游标中的某一行数据。</p><p><strong>fetch语法：</strong></p><pre>Fetch [ [ Next | prior | Frist | Last | Absoute {n | @nvar } | Relative {n | @nvar }] from ]{ { [ Global ] cursor_name } | @cursor_variable_name } [ into @variable_name [,....] ]</pre><p><strong>注：</strong></p><ul><li><strong>Frist：</strong>结果集的第一行</li><li><strong>Prior：</strong>当前位置的上一行</li><li><strong>Next：</strong>当前位置的下一行</li><li><strong>Last：</strong>最后一行</li><li><strong>Absoute { n | @nvar }：</strong>从游标的第一行开始数，第n行。</li><li><strong>Relative {n | @nvar} ：</strong>从当前位置数，第n行。</li><li><strong>Into @variable_name[,...] : </strong>将提取到的数据存放到变量variable_name中。</li></ul><h1>检索Adress表中数据</h1><pre>--检索Adress表中的记录。use TestSchool;Gofetch next from cursor_Adress while @@FETCH_STATUS =0 --提取成功，进行下一条数据的提取操作begin		fetch next from cursor_Adressend</pre><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e9c2623e4154ea9a1a201dbdcbe6777><p class=pgc-img-caption></p></div><p><strong>取数据：</strong></p><pre>fetch next from cursor_Adressfetch next from cursor_Adressselect * from Adress where Id=25</pre><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b6100286445e41dfad978a130f149348><p class=pgc-img-caption></p></div><h1>关闭游标</h1><p>游标打开后，服务器会专门为游标分配一定的内存空间存放游标操作的数据结果集，同时使用游标也会对某些数据进行封锁。所以游标一旦用过，应及时关闭，避免服务器资源浪费。</p><p><strong>语法：</strong></p><pre>close [ Global ] cursor_name | cursor_variable_name</pre><p><strong>注：</strong></p><ul><li><strong>Global：</strong>指定cursor_name是全局游标。</li><li><strong>cursor_name：</strong>已声明的游标名称。</li><li><strong>cursor_variable_name：</strong>游标变量的名称，该变量引用一个游标。</li></ul><p><strong>关闭游标实例：</strong></p><pre>close cursor_Adress;</pre><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f74c1b133aaf49e481c8776b503c9a74><p class=pgc-img-caption></p></div><h1>释放游标（删除游标）</h1><p>游标操作的结果集控件虽然被释放了，但是游标结构本身也会占用一定的计算机资源，所以在使用完游标之后，为了收回被游标占用的资源，应该将游标释放。</p><p><strong>语法：</strong></p><pre>--释放游标语法deallocate [ Global ] cursor_name | cursor_variable_name</pre><p><strong>释放游标实例:</strong></p><pre>--释放游标deallocate cursor_Adress;deallocate cursor_TestData;</pre><h1>游标的使用步骤</h1><ol><li>声明游标变量</li><li>创建游标</li><li>打开游标</li><li>为游标变量赋值</li><li>从游标变量中读取值</li><li>判断fetch语句是否执行成功</li><li>读取游标变量中的数据</li><li>关闭游标</li><li>释放游标</li></ol><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8998065c1ea84598a36eda13b3cad4af><p class=pgc-img-caption></p></div><h1>游标实例</h1><pre>--使用游标变量use TestSchoolgodeclare @varcursor Cursor --声明游标变量declare cursor_Adress cursor for --创建游标select Id,PCity ,Pcode from Adress;open cursor_Adress; --打开游标set @varcursor = cursor_Adress --为游标变量赋值fetch next from @varcursor --从游标变量中读取值while @@FETCH_STATUS = 0 --判断fetch 语句是否执行成功begin		fetch next from @varcursor --读取游标变量中的数据endclose @varcursor --关闭游标deallocate @varcursor --释放游标</pre><p><strong>结果：</strong></p><div class=pgc-img><img alt="SQL Server——游标详解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd0f93a067bd46f3897a37965d602c3f><p class=pgc-img-caption></p></div><p>本文部分内容参考至网络，如有错误，敬请指正，如有侵权，请联系修改。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SQL','Server','游标'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>