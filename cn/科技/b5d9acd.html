<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android 上哪个更好：除以 2 还是位移 1？ | 极客快訊</title><meta property="og:title" content="Android 上哪个更好：除以 2 还是位移 1？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/RzDApJ2446C0Cb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b5d9acd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b5d9acd.html><meta property="article:published_time" content="2020-10-29T21:00:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:27+08:00"><meta name=Keywords content><meta name=description content="Android 上哪个更好：除以 2 还是位移 1？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b5d9acd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android 上哪个更好：除以 2 还是位移 1？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="Android 上哪个更好：除以 2 还是位移 1？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RzDApJ2446C0Cb><p>作者 | Jake Wharton</p><p>译者 | 孙薇，责编 | 夕颜</p><p>头图 | CSDN下载自视觉中国</p><p>出品 | CSDN（ID:CSDNnews）</p><p><strong>以下为译文：</strong></p><p>我一直在将AndroidX集合库移植到Kotlin multiplatform上，以试验二进制兼容性、性能、工具以及不同的内存模型。库中的某些数据结构使用了基于数组的二叉树来存储元素。Java代码中有大量位移来替代2的幂的乘除法。当移植到Kotlin之后，这些就成了略微有点别扭的中缀运算符，导致代码意图进一步被混淆。</p><p>我找了些人来调查对按位移位（bitwise shifts）与乘除法的看法，很多人听说过移位性能更好的传闻，但每个人对其真实性仍持怀疑态度。一些人认为，代码在CPU上运行之前所见过的一个编译器可用来优化这个案例。</p><p>为了满足我的好奇心（部分也是为了避免Kotlin的中缀按位运算符），我打算回答哪个更优的问题，以及一些相关的问题。那么这就开始吧。</p><img alt="Android 上哪个更好：除以 2 还是位移 1？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p></p><h1 toutiao-origin=h3>有人优化吗？</h1><p>在代码进入CPU之前，主要经过三个编译器：`javac`/`kotlinc`，D8/R8，以及ART。</p><img alt="Android 上哪个更好：除以 2 还是位移 1？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RzEPVHu8hK92pI><p>它们都有机会对代码进行优化，但它们会这样做吗？</p><p></p><h1 toutiao-origin=h3>javac</h1><pre><code>class Example {</code><code> static int multiply(int value) {</code><code> return value * 2;</code><code> }</code><code> static int divide(int value) {</code><code> return value / 2;</code><code> }</code><code> static int shiftLeft(int value) {</code><code> return value &lt;&lt; 1;</code><code> }</code><code> static int shiftRight(int value) {</code><code> return value &gt;&gt; 1;</code><code> }</code><code>}</code></pre><p>可以使用JDK14中的javac来编译这段Java代码，并通过javap来显示生成的字节码。</p><pre><code>$ javac Example.java</code><code>$ javap -c Example</code><code>Compiled from "Example.java"</code><code>class Example {</code><code> static int multiply(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: imul</code><code> 3: ireturn</code><br><br><code> static int divide(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: idiv</code><code> 3: ireturn</code><br><br><code> static int shiftLeft(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishl</code><code> 3: ireturn</code><br><br><code> static int shiftRight(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishr</code><code> 3: ireturn</code></pre><p>以 `iload_0` 开头的每个方法会加载第一个实参值，之后乘法和除法都包含 `iconst_2` ，它们加载常量2，然后分别运行 `imul` 或者 `idiv` ，以执行整数乘法或整数除法。移位方法在`ishl`或`ishr`之前加载常量1，分别执行整数向左移位和整数向右移位。</p><p>这里没有优化，但如果你有对Java有所了解，就知道这并不意外。`javac`并不是一个优化编译器，它将大部分工作留给了JVM上的运行时编译器或者提前编译器。</p><p></p><h1 toutiao-origin=h3>kotlinc</h1><pre><code>fun multiply(value: Int) = value * 2</code><code>fun divide(value: Int) = value / 2</code><code>fun shiftLeft(value: Int) = value shl 1</code><code>fun shiftRight(value: Int) = value shr 1</code></pre><p>使用Kotlin 1.4-M1中的`Kotlinc`将Kotlin编译为Java字节码，这样`javap`工具就能再次使用。</p><pre><code>$ kotlinc Example.kt</code><code>$ javap -c ExampleKt</code><code>Compiled from "Example.kt"</code><code>public final class ExampleKt {</code><code> public static final int multiply(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: imul</code><code> 3: ireturn</code><br><br><code> public static final int divide(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: idiv</code><code> 3: ireturn</code><br><br><code> public static final int shiftLeft(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishl</code><code> 3: ireturn</code><br><br><code> public static final int shiftRight(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_1</code><code> 2: ishr</code><code> 3: ireturn</code></pre><p>与Java的输出结果完全一致。这是运用了Kotlin原始的JVM后端，但使用基于IR的后端（通过`-Xuse-ir`）也能产生同样的输出。</p><p></p><h1 toutiao-origin=h3>D8</h1><p>我们使用Kotlin示例中的Java字节码输出作为由 `master`（在文本撰写时是SHA `2a2bf622d`）所构建的最新D8的输入。</p><pre><code>$ java -jar $R8_HOME/build/libs/d8.jar \</code><code> --release \</code><code> --output . \</code><code> ExampleKt.class</code><code>$ dexdump -d classes.dex</code><code>Opened 'classes.dex', DEX version '035'</code><code>Class #0 -</code><code> Class descriptor : 'LExampleKt;'</code><code> Access flags : 0x0011 (PUBLIC FINAL)</code><code> Superclass : 'Ljava/lang/Object;'</code><code> Direct methods -</code><code> #0 : (in LExampleKt;)</code><code> name : 'divide'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000118: |[000118] ExampleKt.divide:(I)I</code><code>000128: db00 0102 |0000: div-int/lit8 v0, v1, #int 2 // #02</code><code>00012c: 0f00 |0002: return v0</code><br><br><code> #1 : (in LExampleKt;)</code><code> name : 'multiply'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000130: |[000130] ExampleKt.multiply:(I)I</code><code>000140: da00 0102 |0000: mul-int/lit8 v0, v1, #int 2 // #02</code><code>000144: 0f00 |0002: return v0</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000148: |[000148] ExampleKt.shiftLeft:(I)I</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1, #int 1 // #01</code><code>00015c: 0f00 |0002: return v0</code><br><br><code> #3 : (in LExampleKt;)</code><code> name : 'shiftRight'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000160: |[000160] ExampleKt.shiftRight:(I)I</code><code>000170: e100 0101 |0000: shr-int/lit8 v0, v1, #int 1 // #01</code><code>000174: 0f00 |0002: return </code><br></pre><p>(注：输出略微修剪)</p><p>Dalvik字节码是基于寄存器的，而不是像Java字节码那样基于堆栈。因此，每种方法只有一个实字节码来执行相关的整数运算。每个寄存器都使用v1寄存器，也是第一个实参值，以及2或1的整型常量。</p><p>因此没有更改行为，但D8也不是一个优化编辑器（尽管它可以执行局部方法的优化）。</p><p></p><h1 toutiao-origin=h3>R8</h1><p>要运行R8，我们需要定义一项规则，以防止我们的方法被删除。</p><pre><code>-keep,allowoptimization class ExampleKt {</code><code> &lt;methods&gt;;</code><code>}</code></pre><p>这些规则通过 `--pg-conf` 来传递，我们还提供了Android API来链接使用 `--lib`。</p><pre><code>$ java -jar $R8_HOME/build/libs/r8.jar \</code><code> --lib $ANDROID_HOME/platforms/android-29/android.jar \</code><code> --release \</code><code> --pg-conf rules.txt \</code><code> --output . \</code><code> ExampleKt.class</code><code>$ dexdump -d classes.dex</code><code>Opened 'classes.dex', DEX version '035'</code><code>Class #0 -</code><code> Class descriptor : 'LExampleKt;'</code><code> Access flags : 0x0011 (PUBLIC FINAL)</code><code> Superclass : 'Ljava/lang/Object;'</code><code> Direct methods -</code><code> #0 : (in LExampleKt;)</code><code> name : 'divide'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000118: |[000118] ExampleKt.divide:(I)I</code><code>000128: db00 0102 |0000: div-int/lit8 v0, v1, #int 2 // #02</code><code>00012c: 0f00 |0002: return v0</code><br><br><code> #1 : (in LExampleKt;)</code><code> name : 'multiply'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000130: |[000130] ExampleKt.multiply:(I)I</code><code>000140: da00 0102 |0000: mul-int/lit8 v0, v1, #int 2 // #02</code><code>000144: 0f00 |0002: return v0</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000148: |[000148] ExampleKt.shiftLeft:(I)I</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1, #int 1 // #01</code><code>00015c: 0f00 |0002: return v0</code><br><br><code> #3 : (in LExampleKt;)</code><code> name : 'shiftRight'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000160: |[000160] ExampleKt.shiftRight:(I)I</code><code>000170: e100 0101 |0000: shr-int/lit8 v0, v1, #int 1 // #01</code><code>000174: 0f00 |0002: return </code></pre><p>与D8的输出完全相同。</p><p></p><h1 toutiao-origin=h3>ART</h1><p>我们使用R8示例中的Dalvik字节码输出，作为在x86模拟器上的Android 10系统运行的ART的输入。</p><pre><code>$ adb push classes.dex /sdcard/classes.dex</code><code>$ adb shell</code><code>generic_x86:/ $ su</code><code>generic_x86:/ # dex2oat --dex-file=/sdcard/classes.dex --oat-file=/sdcard/classes.oat</code><code>generic_x86:/ # oatdump --oat-file=/sdcard/classes.oat</code><code>OatDexFile:</code><code>0: LExampleKt; (offset=0x000003c0) (type_idx=1) (Initialized) (OatClassAllCompiled)</code><code> 0: int ExampleKt.divide(int) (dex_method_idx=0)</code><code> CODE: (code_offset=0x00001010 size_offset=0x0000100c size=15)...</code><code> 0x00001010: 89C8 mov eax, ecx</code><code> 0x00001012: 8D5001 lea edx, [eax + 1]</code><code> 0x00001015: 85C0 test eax, eax</code><code> 0x00001017: 0F4DD0 cmovnl/ge edx, eax</code><code> 0x0000101a: D1FA sar edx</code><code> 0x0000101c: 89D0 mov eax, edx</code><code> 0x0000101e: C3 ret</code><code> 1: int ExampleKt.multiply(int) (dex_method_idx=1)</code><code> CODE: (code_offset=0x00001030 size_offset=0x0000102c size=5)...</code><code> 0x00001030: D1E1 shl ecx</code><code> 0x00001032: 89C8 mov eax, ecx</code><code> 0x00001034: C3 ret</code><code> 2: int ExampleKt.shiftLeft(int) (dex_method_idx=2)</code><code> CODE: (code_offset=0x00001030 size_offset=0x0000102c size=5)...</code><code> 0x00001030: D1E1 shl ecx</code><code> 0x00001032: 89C8 mov eax, ecx</code><code> 0x00001034: C3 ret</code><code> 3: int ExampleKt.shiftRight(int) (dex_method_idx=3)</code><code> CODE: (code_offset=0x00001040 size_offset=0x0000103c size=5)...</code><code> 0x00001040: D1F9 sar ecx</code><code> 0x00001042: 89C8 mov eax, ecx</code><code> 0x00001044: C3 ret</code></pre><pre> (注意：输出有大幅修剪)</pre><p>x86汇编显示，ART确实介入并规范化了算术运算符以使用移位。</p><p>首先，现在`multiply`和`shiftLeft的`实现完全一致。它们都使用`shl`来执行向左按位移位1，此外如果查看文件夹中的偏移量（最左边的列），会发现它们是完全一致的。ART认识到这些函数在编译到x86汇编时具有相同的主体，并已经删除了重复的数据。</p><p>下一步，尽管`divide`和`shiftRight`不一样，其对`sar`的用法是一样的，都是向右按位移位1，在`divide`中的四条附加指令通过给值加1，先于`sar`处理输入为负的情况（注释1）。</p><p>在Android 10系统的Pixel 4上运行相同的命令，会显示ART如何将此代码编译到ARM汇编中（注释2）。</p><pre><code>OatDexFile:</code><code>0: LExampleKt; (offset=0x000005a4) (type_idx=1) (Verified) (OatClassAllCompiled)</code><code> 0: int ExampleKt.divide(int) (dex_method_idx=0)</code><code> CODE: (code_offset=0x00001009 size_offset=0x00001004 size=10)...</code><code> 0x00001008: 0fc8 lsrs r0, r1, #31</code><code> 0x0000100a: 1841 adds r1, r0, r1</code><code> 0x0000100c: 1049 asrs r1, #1</code><code> 0x0000100e: 4608 mov r0, r1</code><code> 0x00001010: 4770 bx lr</code><code> 1: int ExampleKt.multiply(int) (dex_method_idx=1)</code><code> CODE: (code_offset=0x00001021 size_offset=0x0000101c size=4)...</code><code> 0x00001020: 0048 lsls r0, r1, #1</code><code> 0x00001022: 4770 bx lr</code><code> 2: int ExampleKt.shiftLeft(int) (dex_method_idx=2)</code><code> CODE: (code_offset=0x00001021 size_offset=0x0000101c size=4)...</code><code> 0x00001020: 0048 lsls r0, r1, #1</code><code> 0x00001022: 4770 bx lr</code><code> 3: int ExampleKt.shiftRight(int) (dex_method_idx=3)</code><code> CODE: (code_offset=0x00001031 size_offset=0x0000102c size=4)...</code><code> 0x00001030: 1048 asrs r0, r1, #1</code><code> 0x00001032: 4770 bx lr</code></pre><p>同样，`multiply`和`shiftLeft`都使用`lsls`来执行向左位移，因此被去重了。`shiftRight`用`asrs`来执行向右位移。`divide`也使用`asrs`来执行向右位移，但它使用另一个向右位移`lsrs`来处理负值加一的操作（注释3）。</p><p>这样一来，我们现在可以肯定地说，用`value &lt;&lt; 1`来替代`value * 2`没有任何好处，不要再为了算术运算而这么做了，仅保留用于严格的按位运算。</p><p>然而，`value / 2` 和`value >> 1`仍会产生不同的汇编指令，因而可能具有不同的性能特征。幸运的是，使用`value / 2`可避免使用通用除法，并且仍旧主要基于向右位移，因此它们在性能方面差异可能不大。</p><p></p><h1 toutiao-origin=h3>位移会比除法快一些吗？</h1><p>为了确定除法快还是位移更快，我们可以使用Jetpack benchmark库。</p><pre><code>class DivideOrShiftTest {</code><code> @JvmField @Rule val benchmark = BenchmarkRule</code><br><br><code> @Test fun divide {</code><code> val value = "4".toInt // Ensure not a constant.</code><code> var result = 0</code><code> benchmark.measureRepeated {</code><code> result = value / 2</code><code> }</code><code> println(result) // Ensure D8 keeps computation.</code><code> }</code><br><br><code> @Test fun shift {</code><code> val value = "4".toInt // Ensure not a constant.</code><code> var result = 0</code><code> benchmark.measureRepeated {</code><code> result = value shr 1</code><code> }</code><code> println(result) // Ensure D8 keeps computation.</code><code> }</code></pre><p>我没有x86设备，但有一台运行Android 10系统的基于ARM的Pixel 3，结果如下：</p><pre><code>android.studio.display.benchmark=4 ns DivideOrShiftTest.divide</code><code>count=4006</code><code>mean=4</code><code>median=4</code><code>min=4</code><code>standardDeviation=0</code><br><br><code>android.studio.display.benchmark=3 ns DivideOrShiftTest.shift</code><code>count=3943</code><code>mean=3</code><code>median=3</code><code>min=3</code><code>standardDeviation=0</code></pre><p>对如此小的数字使用除法或位移之间的区别几近于无，毕竟差异太小了。使用负数显示结果并无差异。</p><p>这样一来，我们现在可以肯定，用`value >> 1`代替`value / 2`并无好处，不要再为算术运算这么做了，仅保留用于严格的按位运算。</p><p></p><h1 toutiao-origin=h3>D8/R8能用这些信息来保存APK大小吗？</h1><p>针对两个操作相同的表达方式，我们应该选择性能更佳的。但如果两者性能相同的话，则应选择APK更小的。</p><p>我们知道，ART中`value * 2`和`value &lt;&lt; 1`会产生相同的汇编，因此如果在Dalvik字节码中，一个比另一个更省空间，我们应该无条件地以更小的形式将其重写。查看D8中的输出，它们产生的字节码大小相同：</p><pre><code> #1 : (in LExampleKt;) name : 'multiply'</code><code> ⋮</code><code>000140: da00 0102 |0000: mul-int/lit8 v0, v1, #int 2 // #02</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> ⋮</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1, #int 1 // #01</code></pre><p>尽管使用2的幂没有收益，但在移位以存储常量值之前，乘法用完了字节码空间，下面是`value * 32_768`与`value &lt;&lt; 15`的对比：</p><pre><code> #1 : (in LExampleKt;) name : 'multiply'</code><code> ⋮</code><code>000128: 1400 0080 0000 |0000: const v0, #float 0.000000 // #00008000</code><code>00012e: 9201 0100 |0003: mul-int v1, v1, v0</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> ⋮</code><code>00015c: e000 000f |0000: shl-int/lit8 v0, v0, #int 15 // #0f</code></pre><p>我在D8上提了个问题以调查如何自动优化此问题，但我强烈怀疑这种适用情况接近于零，因此很可能并不值得。</p><p>D8和R8的输出也告诉我们，在Dalvik字节码方面，`value / 2`和`value >> 1`的代价是相同的。</p><pre><code> #0 : (in LExampleKt;) name : 'divide'</code><code> ⋮</code><code>000128: db00 0102 |0000: div-int/lit8 v0, v1, #int 2 // #02</code><br><br><code> #2 : (in LExampleKt;)</code><code> name : 'shiftLeft'</code><code> ⋮</code><code>000158: e000 0101 |0000: shl-int/lit8 v0, v1,#int 1 // #01</code></pre><p>当常量达到32768时，其字节码大小也会有所不同。无条件地将2的幂除法换成向右位移永远不是安全的选项，这是因为负数的存在。如果能保证其值非负，那我们可以这样替换，但此时D8和R8并不会追踪可能的整数值范围。</p><p></p><h1 toutiao-origin=h3>无符号的“2的幂除法”使用位移吗？</h1><p>Java字节码缺少无符号的数字，但使用符号的对应部分是可以模拟的。在Java中，有一些将符号类型当作无符号值运算的静态辅助方法。Kotlin提供了类似 `UInt` 这样的类型完成类似的功能，但在类型后完全抽象了。可以想象的是，当使用除以2的幂时，应当以移位方式重写。</p><p>我们可以使用Kotlin来为两种情况建模。</p><pre><code>fun javaLike(value: Int) = Integer.divideUnsigned(value, 2)</code><code>fun kotlinLike(value: UInt) = value / 2U</code></pre><p>在某些情况下，仅需考虑代码的编译方式。我们从普通的 `kotlinc`开始（还是从Kotlin 1.4-M1开始）。</p><pre><code>$ kotlinc Example.kt</code><code>$ javap -c ExampleKt</code><code>Compiled from "Example.kt"</code><code>public final class ExampleKt {</code><code> public static final int javaLike(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: invokestatic #12 // Method java/lang/Integer.divideUnsigned:(II)I</code><code> 5: ireturn</code><br><br><code> public static final int kotlinLike-WZ4Q5Ns(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: istore_1</code><code> 2: iconst_2</code><code> 3: istore_2</code><code> 4: iconst_0</code><code> 5: istore_3</code><code> 6: iload_1</code><code> 7: iload_2</code><code> 8: invokestatic #20 // Method kotlin/UnsignedKt."uintDivide-J1ME1BU":(II)I</code><code> 11: ireturn</code><code>}</code></pre><p>Kotlin无法将其识别为可使用`iushr`字节码的“2的幂除法”，我提交了KT-38493以追踪此行为的添加。</p><p>使用`-Xuse-ir`不会有任何改变（除非移除某些负载/存储噪音），然而以Java 8为目标则会有变化。</p><pre><code>$ kotlinc -jvm-target 1.8 Example.kt</code><code>$ javap -c ExampleKt</code><code>Compiled from "Example.kt"</code><code>public final class ExampleKt {</code><code> public static final int javaLike(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: invokestatic #12 // Method java/lang/Integer.divideUnsigned:(II)I</code><code> 5: ireturn</code><br><br><code> public static final int kotlinLike-WZ4Q5Ns(int);</code><code> Code:</code><code> 0: iload_0</code><code> 1: iconst_2</code><code> 2: invokestatic #12 // Method java/lang/Integer.divideUnsigned:(II)I</code><code> 5: ireturn</code><code>}</code></pre><p>`Integer.divideUnsigned`方法在Java 8中可以使用，因此在1.8或更高版本中较多使用，由于这会使得两个函数体完全相同，我们还是返回旧输出，对比看看会发生什么。</p><p>接下来是R8，与上面调用明显不同，我们将Kotlin stdlib作为输入引入，同时由于 `Integer.divideUnsigned` 仅在API 24和更高版本中可用，也传递了`--min-api 24`。</p><pre><code>$ java -jar $R8_HOME/build/libs/r8.jar \</code><code> --lib $ANDROID_HOME/platforms/android-29/android.jar \</code><code> --min-api 24 \</code><code> --release \</code><code> --pg-conf rules.txt \</code><code> --output . \</code><code> ExampleKt.class kotlin-stdlib.jar</code><code>$ dexdump -d classes.dex</code><code>Opened 'classes.dex', DEX version '039'</code><code>Class #0 -</code><code> Class descriptor : 'LExampleKt;'</code><code> Access flags : 0x0011 (PUBLIC FINAL)</code><code> Superclass : 'Ljava/lang/Object;'</code><code> Direct methods -</code><code> #0 : (in LExampleKt;)</code><code> name : 'javaLike'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>0000f8: |[0000f8] ExampleKt.javaLike:(I)I</code><code>000108: 1220 |0000: const/4 v0, #int 2 // #2</code><code>00010a: 7120 0200 0100 |0001: invoke-static {v1, v0}, Ljava/lang/Integer;.divideUnsigned:(II)I // method@0002</code><code>000110: 0a01 |0004: move-result v1</code><code>000112: 0f01 |0005: return v1</code><br><br><code> #1 : (in LExampleKt;)</code><code> name : 'kotlinLike-WZ4Q5Ns'</code><code> type : '(I)I'</code><code> access : 0x0019 (PUBLIC STATIC FINAL)</code><code> code -</code><code>000114: |[000114] ExampleKt.kotlinLike-WZ4Q5Ns:(I)I</code><code>000124: 8160 |0000: int-to-long v0, v6</code><code>000126: 1802 ffff ffff 0000 0000 |0001: const-wide v2, #double 0.000000 // #00000000ffffffff</code><code>000130: c020 |0006: and-long/2addr v0, v2</code><code>000132: 1226 |0007: const/4 v6, #int 2 // #2</code><code>000134: 8164 |0008: int-to-long v4, v6</code><code>000136: c042 |0009: and-long/2addr v2, v4</code><code>000138: be20 |000a: div-long/2addr v0, v2</code><code>00013a: 8406 |000b: long-to-int v6, v0</code><code>00013c: 0f06 |000c: return v6</code></pre><p>Kotlin有自己的无符号整数除法的实现方式，已经与我们的函数内联。它会将输入实参和常量转化为longs，执行longs除法，然后再转回整数。当我们最终通过ART来运行时，它们会转成等效的x86，因此我们将保留此函数，这里优化的机会已经失去了。</p><p>对于Java版本，R8无法将`divideUnsigned`调用替换成位移，我针对D8和R8提交了issue 154712996来跟踪这个问题。</p><p>最后一个优化的机会是ART。</p><pre><code>$ adb push classes.dex /sdcard/classes.dex</code><code>$ adb shell</code><code>generic_x86:/ $ su</code><code>generic_x86:/ # dex2oat --dex-file=/sdcard/classes.dex --oat-file=/sdcard/classes.oat</code><code>generic_x86:/ # oatdump --oat-file=/sdcard/classes.oat</code><code>OatDexFile:</code><code>0: LExampleKt; (offset=0x000003c0) (type_idx=1) (Initialized) (OatClassAllCompiled)</code><code> 0: int ExampleKt.javaLike(int) (dex_method_idx=0)</code><code> CODE: (code_offset=0x00001010 size_offset=0x0000100c size=63)...</code><code> 0x00001010: 85842400E0FFFF test eax, [esp + -8192]</code><code> StackMap[0] (native_pc=0x1017, dex_pc=0x0, register_mask=0x0, stack_mask=0b)</code><code> 0x00001017: 55 push ebp</code><code> 0x00001018: 83EC18 sub esp, 24</code><code> 0x0000101b: 890424 mov [esp], eax</code><code> 0x0000101e: 6466833D0000000000 cmpw fs:[0x0], 0 ; state_and_flags</code><code> 0x00001027: 0F8519000000 jnz/ne +25 (0x00001046)</code><code> 0x0000102d: E800000000 call +0 (0x00001032)</code><code> 0x00001032: 5D pop ebp</code><code> 0x00001033: BA02000000 mov edx, 2</code><code> 0x00001038: 8B85CE0F0000 mov eax, [ebp + 4046]</code><code> 0x0000103e: FF5018 call [eax + 24]</code><code> StackMap[1] (native_pc=0x1041, dex_pc=0x1, register_mask=0x0, stack_mask=0b)</code><code> 0x00001041: 83C418 add esp, 24</code><code> 0x00001044: 5D pop ebp</code><code> 0x00001045: C3 ret</code><code> 0x00001046: 64FF15E0020000 call fs:[0x2e0] ; pTestSuspend</code><code> StackMap[2] (native_pc=0x104d, dex_pc=0x0, register_mask=0x0, stack_mask=0b)</code><code> 0x0000104d: EBDE jmp -34 (0x0000102d)</code><code> 1: int ExampleKt.kotlinLike-WZ4Q5Ns(int) (dex_method_idx=1)</code><code> CODE: (code_offset=0x00001060 size_offset=0x0000105c size=67)...</code><code> ⋮</code></pre><p>ART内化调用 `divideUnsigned`，因此我们让机器跳至常规方法的实现。我提交了issue 154693569以跟踪为无符号除法添加ART内化的问题。</p><p>好吧，这确实费了不少劲。恭喜你到达此步（或只是快速翻到这里），我们总结一下：</p><ol><li><p>ART将2的幂乘法重写为向左位移，将2的幂除法重写为向右位移（通过一些额外的指令来处理负数）；</p></li><li><p>向右位移和2的幂除法之间没有明显的性能差异；</p></li><li><p>Dalvik字节码中，位移和乘法/除法之间没有大小差异；</p></li><li><p>截至目前还没有人优化无签名除法，但也许你也不会用到。</p></li></ol><p>通过以上事实，我们可以回答本文题目中提出的问题了：</p><blockquote><p>Android上哪个更好：除以2还是位移1？</p></blockquote><p>都不好！因此将除法用于算术运算中，对于真实的按位操作只使用位移，我会将AndroidX集合端口从位移切换到乘除法。下次见！</p><p>注释：</p><p>1. 二进制中的-3为0b11111101，如果我们尝试仅向右位移来实现除以2，结果是0b11111110，即-2，这是错误的结果。通过给-3加1，首先我们会得到-2，二进制表达是0b11111110，向右位移则得出0b11111111，也就是-1，这是正确的结果。</p><p>根据实际中的指令：</p><ul><li><p>`mov eax, ecx` 将原始输入实参值保存在`eax`中；</p></li><li><p>`lea edx, [eax + 1]` 给输入实参加1，并将结果存储在`edx`中，即我们要位移的寄存器；</p></li><li><p>`test eax, eax`对自身的输入实参进行按位操作，导致一些寄存器会根据输入实参的属性来设置；</p></li><li><p>之后`cmovnl/ge edx, eax`可能会基于`test`的结果，以`eax` (值)重写`edx` (值+1)。</p></li></ul><p>之后指令会执行普通的向右位移，与 `(value &lt; 0 ? value + 1 : value) >> 1`. ↩基本相同。</p><p>2. 感谢Sergey Vasilinets提供的相关内容，`dex2oat`只能在现代Android版本中以root身份来运行，因此普通的Android（如在Pixel3上的）就无法运行。↩</p><p>3. 就实际指令而言：</p><ul><li><p>`lsrs r0, r1, #31` 对输入实参进行逻辑（即不对符号进行扩展）31位的位移到`r0`，导致负数结果为1，正数结果为0。</p></li><li><p>`adds r1, r0, r1` 会将前一条指令的结果与输入实参相加，实际上是给负值输入加1。</p></li></ul><p>自此指令会执行普通的向右位移，基本上等同于`(value + (value >>> 31)) >> 1`。</p><p>原文链接：</p><p>https://jakewharton.com/which-is-better-on-android-divide-by-two-or-shift-by-one/</p><p>本文为CSDN翻译文章，转载请注明出处。</p><img alt="Android 上哪个更好：除以 2 还是位移 1？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R69FpRH4d90a7d><img alt="Android 上哪个更好：除以 2 还是位移 1？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rz2ij7Q6pwhZWh><pre><p>☞潘石屹 Python 考试成绩 99 分，网友：还有一分怕你骄傲</p><pre><p>☞赠书 | 程序员修炼的务实哲学</p><p>☞JavaScript 流行度最高，Java 屈居第三！| 2020 最新软件开发状况报告</p><p>☞深度学习基础总结，无一句废话（附完整思维导图）</p><p>☞震惊！阿里的程序员竟被一个简单的 SQL 查询难住了！</p><p>☞大学生程序员被勒索比特币后，绝地反击！</p></pre></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Android','哪个','还是'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>