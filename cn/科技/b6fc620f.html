<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>这一次搞懂Spring代理创建+AOP链式调用过程 | 极客快訊</title><meta property="og:title" content="这一次搞懂Spring代理创建+AOP链式调用过程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e1c7c82fff674a01b49573f34eb5dc1b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="这一次搞懂Spring代理创建+AOP链式调用过程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b6fc620f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>这一次搞懂Spring代理创建+AOP链式调用过程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=line>前言</h1><p>AOP，也就是面向切面编程，它可以将公共的代码抽离出来，动态的植入到目标类、目标方法中，大大提高我们编程的效率，也使程序变得更加优雅。如事务、操作日志等都可以使用AOP实现。这种织入可以是<strong>在运行期动态生成代理对象</strong>实现，也可以在<strong>编译期</strong>、<strong>类加载时期</strong>静态织入到代码中。而Spring正是通过第一种方法实现，且在代理类的生成上也有两种方式：JDK Proxy和CGLIB，默认当类实现了接口时使用前者，否则使用后者；另外Spring AOP只能实现对方法的增强。</p><h1 class=line>正文</h1><h2 class=line>基本概念</h2><p>AOP的术语很多，虽然不清楚术语我们也能很熟练地使用AOP，但是要理解分析源码，术语就需要深刻体会其含义。</p><ul><li>增强（Advice）：就是我们想要额外增加的功能</li><li>目标对象（Target）：就是我们想要增强的目标类，如果没有AOP，我们需要在每个目标对象中实现日志、事务管理等非业务逻辑</li><li>连接点（JoinPoint）：程序执行时的特定时机，如方法执行前、后以及抛出异常后等等。</li><li>切点（Pointcut）：连接点的导航，我们如何找到目标对象呢？切点的作用就在于此，在Spring中就是匹配表达式。</li><li>引介（Introduction）：引介是一种特殊的增强，它为类添加一些属性和方法。这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，我们可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类。</li><li>织入（Weaving）：即如何将增强添加到目标对象的连接点上，有动态（运行期生成代理）、静态（编译期、类加载时期）两种方式。</li><li>代理（Proxy）：目标对象被植入增强后，就会产生一个代理对象，该对象可能是和原对象实现了同样的一个接口（JDK），也可能是原对象的子类（CGLIB）。</li><li>切面（Aspect、Advisor）：切面由切点和增强组成，包含了这两者的定义。</li></ul><h2 class=line>代理对象的创建</h2><p>在熟悉了AOP术语后，下面就来看看Spring是如何创建代理对象的，是否还记得上一篇提到的AOP的入口呢？在<strong>AbstractAutowireCapableBeanFactory</strong>类的<strong>applyBeanPostProcessorsAfterInitialization</strong>方法中循环调用了<strong>BeanPostProcessor</strong>的<strong>postProcessAfterInitialization</strong>方法，其中一个就是我们创建代理对象的入口。这里是Bean实例化完成去创建代理对象，理所当然应该这样，但实际上在Bean实例化之前调用了一个<strong>resolveBeforeInstantiation</strong>方法，这里实际上我们也是有机会可以提前创建代理对象的，这里放到最后来分析，先来看主入口，进入到<strong>AbstractAutoProxyCreator</strong>类中：</p><pre><code>    public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {        if (bean != null) {            Object cacheKey = getCacheKey(bean.getClass(), beanName);            if (!this.earlyProxyReferences.contains(cacheKey)) {                return wrapIfNecessary(bean, beanName, cacheKey);            }        }        return bean;    }    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {        //创建当前bean的代理，如果这个bean有advice的话，重点看        // Create proxy if we have advice.        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);        //如果有切面，则生成该bean的代理        if (specificInterceptors != DO_NOT_PROXY) {            this.advisedBeans.put(cacheKey, Boolean.TRUE);            //把被代理对象bean实例封装到SingletonTargetSource对象中            Object proxy = createProxy(                    bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));            this.proxyTypes.put(cacheKey, proxy.getClass());            return proxy;        }        this.advisedBeans.put(cacheKey, Boolean.FALSE);        return bean;    }</code></pre><p>先从缓存中拿，没有则调用<strong>wrapIfNecessary</strong>方法创建。在这个方法里面主要看两个地方：<strong>getAdvicesAndAdvisorsForBean</strong>和<strong>createProxy</strong>。简单一句话概括就是先扫描后创建，问题是扫描什么呢？你可以先结合上面的概念思考下，换你会怎么做。进入到子类<strong>AbstractAdvisorAutoProxyCreator</strong>的<strong>getAdvicesAndAdvisorsForBean</strong>方法中：</p><pre><code>    protected Object[] getAdvicesAndAdvisorsForBean(            Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {        //找到合格的切面        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);        if (advisors.isEmpty()) {            return DO_NOT_PROXY;        }        return advisors.toArray();    }    protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {        //找到候选的切面,其实就是一个寻找有@Aspectj注解的过程，把工程中所有有这个注解的类封装成Advisor返回        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();        //判断候选的切面是否作用在当前beanClass上面，就是一个匹配过程。现在就是一个匹配        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);        extendAdvisors(eligibleAdvisors);        if (!eligibleAdvisors.isEmpty()) {            //对有@Order@Priority进行排序            eligibleAdvisors = sortAdvisors(eligibleAdvisors);        }        return eligibleAdvisors;    }</code></pre><p>在<strong>findEligibleAdvisors</strong>方法中可以看到有两个步骤，第一先找到所有的切面，即扫描所有带有@Aspect注解的类，并将其中的<strong>切点（表达式）</strong>和<strong>增强</strong>封装为<strong>切面</strong>，扫描完成后，自然是要判断哪些<strong>切面</strong>能够连接到当前Bean实例上。下面一步步来分析，首先是扫描过程，进入到<strong>AnnotationAwareAspectJAutoProxyCreator</strong>类中：</p><pre><code>    protected List&lt;Advisor&gt; findCandidateAdvisors() {        // 先通过父类AbstractAdvisorAutoProxyCreator扫描，这里不重要        List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();        // 主要看这里        if (this.aspectJAdvisorsBuilder != null) {            advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());        }        return advisors;    }</code></pre><p>这里委托给了<strong>BeanFactoryAspectJAdvisorsBuilderAdapter</strong>类，并调用其父类的<strong>buildAspectJAdvisors</strong>方法创建切面对象：</p><pre><code>    public List&lt;Advisor&gt; buildAspectJAdvisors() {        List&lt;String&gt; aspectNames = this.aspectBeanNames;        if (aspectNames == null) {            synchronized (this) {                aspectNames = this.aspectBeanNames;                if (aspectNames == null) {                    List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();                    aspectNames = new ArrayList&lt;&gt;();                    //获取spring容器中的所有bean的名称BeanName                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(                            this.beanFactory, Object.class, true, false);                    for (String beanName : beanNames) {                        if (!isEligibleBean(beanName)) {                            continue;                        }                        Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);                        if (beanType == null) {                            continue;                        }                        //判断类上是否有@Aspect注解                        if (this.advisorFactory.isAspect(beanType)) {                            aspectNames.add(beanName);                            AspectMetadata amd = new AspectMetadata(beanType, beanName);                            if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {                                // 当@Aspect的value属性为""时才会进入到这里                                // 创建获取有@Aspect注解类的实例工厂，负责获取有@Aspect注解类的实例                                MetadataAwareAspectInstanceFactory factory =                                        new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);                                //创建切面advisor对象                                List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);                                if (this.beanFactory.isSingleton(beanName)) {                                    this.advisorsCache.put(beanName, classAdvisors);                                }                                else {                                    this.aspectFactoryCache.put(beanName, factory);                                }                                advisors.addAll(classAdvisors);                            }                            else {                                MetadataAwareAspectInstanceFactory factory =                                        new PrototypeAspectInstanceFactory(this.beanFactory, beanName);                                this.aspectFactoryCache.put(beanName, factory);                                advisors.addAll(this.advisorFactory.getAdvisors(factory));                            }                        }                    }                    this.aspectBeanNames = aspectNames;                    return advisors;                }            }        }        return advisors;    }</code></pre><p>这个方法里面首先从IOC中拿到所有Bean的名称，并循环判断该类上是否带有@Aspect注解，如果有则将BeanName和Bean的Class类型封装到<strong>BeanFactoryAspectInstanceFactory</strong>中，并调用<strong>ReflectiveAspectJAdvisorFactory.getAdvisors</strong>创建切面对象：</p><pre><code>    public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {        //从工厂中获取有@Aspect注解的类Class        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();        //从工厂中获取有@Aspect注解的类的名称        String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();        validate(aspectClass);        // 创建工厂的装饰类，获取实例只会获取一次        MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =                new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);        List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();        //这里循环没有@Pointcut注解的方法        for (Method method : getAdvisorMethods(aspectClass)) {            //非常重要重点看看            Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);            if (advisor != null) {                advisors.add(advisor);            }        }        if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {            Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);            advisors.add(0, instantiationAdvisor);        }        //判断属性上是否有引介注解，这里可以不看        for (Field field : aspectClass.getDeclaredFields()) {            //判断属性上是否有DeclareParents注解，如果有返回切面            Advisor advisor = getDeclareParentsAdvisor(field);            if (advisor != null) {                advisors.add(advisor);            }        }        return advisors;    }    private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) {        final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();        ReflectionUtils.doWithMethods(aspectClass, method -&gt; {            // Exclude pointcuts            if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {                methods.add(method);            }        });        methods.sort(METHOD_COMPARATOR);        return methods;    }</code></pre><p>根据Aspect的Class拿到所有不带@Pointcut注解的方法对象（为什么是不带@Pointcut注解的方法？仔细想想不难理解），另外要注意这里对method进行了排序，看看这个<strong>METHOD_COMPARATOR</strong>比较器：</p><pre><code>    private static final Comparator&lt;Method&gt; METHOD_COMPARATOR;    static {        Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(                new InstanceComparator&lt;&gt;(                        Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),                (Converter&lt;Method, Annotation&gt;) method -&gt; {                    AspectJAnnotation&lt;?&gt; annotation =                        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);                    return (annotation != null ? annotation.getAnnotation() : null);                });        Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);        METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);    }</code></pre><p>关注<strong>InstanceComparator</strong>构造函数参数，记住它们的顺序，这就是AOP链式调用中同一个@Aspect类中Advice的<strong>执行顺序</strong>。接着往下看，在<strong>getAdvisors</strong>方法中循环获取到的methods，分别调用<strong>getAdvisor</strong>方法，也就是根据方法逐个去创建切面：</p><pre><code>    public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,            int declarationOrderInAspect, String aspectName) {        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());        //获取pointCut对象，最重要的是从注解中获取表达式        AspectJExpressionPointcut expressionPointcut = getPointcut(                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());        if (expressionPointcut == null) {            return null;        }        //创建Advisor切面类，这才是真正的切面类，一个切面类里面肯定要有1、pointCut 2、advice        //这里pointCut是expressionPointcut， advice 增强方法是 candidateAdviceMethod        return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,                this, aspectInstanceFactory, declarationOrderInAspect, aspectName);    }    private static final Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = new Class&lt;?&gt;[] {            Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};    private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) {        //从候选的增强方法里面 candidateAdviceMethod  找有有注解        //Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class        //并把注解信息封装成AspectJAnnotation对象        AspectJAnnotation&lt;?&gt; aspectJAnnotation =                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        if (aspectJAnnotation == null) {            return null;        }        //创建一个PointCut类，并且把前面从注解里面解析的表达式设置进去        AspectJExpressionPointcut ajexp =                new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);        ajexp.setExpression(aspectJAnnotation.getPointcutExpression());        if (this.beanFactory != null) {            ajexp.setBeanFactory(this.beanFactory);        }        return ajexp;    }</code></pre><p>之前就说过<strong>切面</strong>的定义，是切点和增强的组合，所以这里首先通过<strong>getPointcut</strong>获取到注解对象，然后new了一个Pointcut对象，并将表达式设置进去。然后在<strong>getAdvisor</strong>方法中最后new了一个<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>对象：</p><pre><code>    public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,            Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {        this.declaredPointcut = declaredPointcut;        this.declaringClass = aspectJAdviceMethod.getDeclaringClass();        this.methodName = aspectJAdviceMethod.getName();        this.parameterTypes = aspectJAdviceMethod.getParameterTypes();        this.aspectJAdviceMethod = aspectJAdviceMethod;        this.aspectJAdvisorFactory = aspectJAdvisorFactory;        this.aspectInstanceFactory = aspectInstanceFactory;        this.declarationOrder = declarationOrder;        this.aspectName = aspectName;        if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {            // Static part of the pointcut is a lazy type.            Pointcut preInstantiationPointcut = Pointcuts.union(                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);            // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.            // If it's not a dynamic pointcut, it may be optimized out            // by the Spring AOP infrastructure after the first evaluation.            this.pointcut = new PerTargetInstantiationModelPointcut(                    this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);            this.lazy = true;        }        else {            // A singleton aspect.            this.pointcut = this.declaredPointcut;            this.lazy = false;            //这个方法重点看看，创建advice对象            this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);        }    }</code></pre><p>这个就是我们的切面类，在其构造方法的最后通过<strong>instantiateAdvice</strong>创建了<strong>Advice</strong>对象。注意这里传进来的<strong>declarationOrder</strong>参数，它就是循环method时的序号，其作用就是赋值给这里的<strong>declarationOrder</strong>属性以及Advice的<strong>declarationOrder</strong>属性，在后面排序时就会通过这个序号来比较，因此Advice的执行顺序是<strong>固定</strong>的，至于为什么要固定，后面分析完AOP链式调用过程自然就明白了。</p><pre><code>    public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {        //获取有@Aspect注解的类        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();        validate(candidateAspectClass);        //找到candidateAdviceMethod方法上面的注解，并且包装成AspectJAnnotation对象，这个对象中就有注解类型        AspectJAnnotation&lt;?&gt; aspectJAnnotation =                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        if (aspectJAnnotation == null) {            return null;        }        AbstractAspectJAdvice springAdvice;        //根据不同的注解类型创建不同的advice类实例        switch (aspectJAnnotation.getAnnotationType()) {            case AtPointcut:                if (logger.isDebugEnabled()) {                    logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");                }                return null;            case AtAround:                //实现了MethodInterceptor接口                springAdvice = new AspectJAroundAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtBefore:                //实现了MethodBeforeAdvice接口，没有实现MethodInterceptor接口                springAdvice = new AspectJMethodBeforeAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtAfter:                //实现了MethodInterceptor接口                springAdvice = new AspectJAfterAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtAfterReturning:                //实现了AfterReturningAdvice接口，没有实现MethodInterceptor接口                springAdvice = new AspectJAfterReturningAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();                if (StringUtils.hasText(afterReturningAnnotation.returning())) {                    springAdvice.setReturningName(afterReturningAnnotation.returning());                }                break;            case AtAfterThrowing:                //实现了MethodInterceptor接口                springAdvice = new AspectJAfterThrowingAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();                if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());                }                break;            default:                throw new UnsupportedOperationException(                        "Unsupported advice type on method: " + candidateAdviceMethod);        }        // Now to configure the advice...        springAdvice.setAspectName(aspectName);        springAdvice.setDeclarationOrder(declarationOrder);        String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);        if (argNames != null) {            springAdvice.setArgumentNamesFromStringArray(argNames);        }        //计算argNames和类型的对应关系        springAdvice.calculateArgumentBindings();        return springAdvice;    }</code></pre><p>这里逻辑很清晰，就是拿到方法上的注解类型，根据类型创建不同的增强Advice对象：AspectJAroundAdvice、AspectJMethodBeforeAdvice、AspectJAfterAdvice、AspectJAfterReturningAdvice、AspectJAfterThrowingAdvice。完成之后通过<strong>calculateArgumentBindings</strong>方法进行参数绑定，感兴趣的可自行研究。这里主要看看几个Advice的继承体系：</p><div class=pgc-img><img alt=这一次搞懂Spring代理创建+AOP链式调用过程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1c7c82fff674a01b49573f34eb5dc1b><p class=pgc-img-caption></p></div><p>可以看到有两个Advice是没有实现<strong>MethodInterceptor</strong>接口的：AspectJMethodBeforeAdvice和AspectJAfterReturningAdvice。而<strong>MethodInterceptor</strong>有一个<strong>invoke</strong>方法，这个方法就是<strong>链式调用</strong>的核心方法，但那两个没有实现该方法的Advice怎么处理呢？稍后会分析。到这里切面对象就创建完成了，接下来就是判断当前创建的Bean实例是否和这些切面匹配以及对<strong>切面</strong>排序。匹配过程比较复杂，对理解主流程也没什么帮助，所以这里就不展开分析，感兴趣的自行分析（AbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply()）。下面看看排序的过程，回到AbstractAdvisorAutoProxyCreator.findEligibleAdvisors方法：</p><pre><code>    protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {        //找到候选的切面,其实就是一个寻找有@Aspectj注解的过程，把工程中所有有这个注解的类封装成Advisor返回        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();        //判断候选的切面是否作用在当前beanClass上面，就是一个匹配过程。。现在就是一个匹配        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);        extendAdvisors(eligibleAdvisors);        if (!eligibleAdvisors.isEmpty()) {            //对有@Order@Priority进行排序            eligibleAdvisors = sortAdvisors(eligibleAdvisors);        }        return eligibleAdvisors;    }</code></pre><p><strong>sortAdvisors</strong>方法就是排序，但这个方法有两个实现：当前类<strong>AbstractAdvisorAutoProxyCreator</strong>和子类<strong>AspectJAwareAdvisorAutoProxyCreator</strong>，应该走哪个呢？</p><div class=pgc-img><img alt=这一次搞懂Spring代理创建+AOP链式调用过程 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/419537d02465492990aed14903ddda42><p class=pgc-img-caption></p></div><p>通过类图我们可以肯定是进入的<strong>AspectJAwareAdvisorAutoProxyCreator</strong>类，因为<strong>AnnotationAwareAspectJAutoProxyCreator</strong>的父类是它。</p><pre><code>    protected List&lt;Advisor&gt; sortAdvisors(List&lt;Advisor&gt; advisors) {        List&lt;PartiallyComparableAdvisorHolder&gt; partiallyComparableAdvisors = new ArrayList&lt;&gt;(advisors.size());        for (Advisor element : advisors) {            partiallyComparableAdvisors.add(                    new PartiallyComparableAdvisorHolder(element, DEFAULT_PRECEDENCE_COMPARATOR));        }        List&lt;PartiallyComparableAdvisorHolder&gt; sorted = PartialOrder.sort(partiallyComparableAdvisors);        if (sorted != null) {            List&lt;Advisor&gt; result = new ArrayList&lt;&gt;(advisors.size());            for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) {                result.add(pcAdvisor.getAdvisor());            }            return result;        }        else {            return super.sortAdvisors(advisors);        }    }</code></pre><p>这里排序主要是委托给<strong>PartialOrder</strong>进行的，而在此之前将所有的切面都封装成了<strong>PartiallyComparableAdvisorHolder</strong>对象，注意传入的<strong>DEFAULT_PRECEDENCE_COMPARATOR</strong>参数，这个就是比较器对象：</p><pre><code>    private static final Comparator&lt;Advisor&gt; DEFAULT_PRECEDENCE_COMPARATOR = new AspectJPrecedenceComparator();</code></pre><p>所以我们直接看这个比较器的<strong>compare</strong>方法：</p><pre><code>    public int compare(Advisor o1, Advisor o2) {        int advisorPrecedence = this.advisorComparator.compare(o1, o2);        if (advisorPrecedence == SAME_PRECEDENCE &amp;&amp; declaredInSameAspect(o1, o2)) {            advisorPrecedence = comparePrecedenceWithinAspect(o1, o2);        }        return advisorPrecedence;    }    private final Comparator&lt;? super Advisor&gt; advisorComparator;    public AspectJPrecedenceComparator() {        this.advisorComparator = AnnotationAwareOrderComparator.INSTANCE;    }</code></pre><p>第一步先通过<strong>AnnotationAwareOrderComparator</strong>去比较，点进去看可以发现是对实现了<strong>PriorityOrdered</strong>和<strong>Ordered</strong>接口以及标记了<strong>Priority</strong>和<strong>Order</strong>注解的<strong>非同一个@Aspect类中的切面</strong>进行排序。这个和之前分析<strong>BeanFacotryPostProcessor</strong>类是一样的原理。而对<strong>同一个@Aspect类中的切面</strong>排序主要是<strong>comparePrecedenceWithinAspect</strong>方法：</p><pre><code>    private int comparePrecedenceWithinAspect(Advisor advisor1, Advisor advisor2) {        boolean oneOrOtherIsAfterAdvice =                (AspectJAopUtils.isAfterAdvice(advisor1) || AspectJAopUtils.isAfterAdvice(advisor2));        int adviceDeclarationOrderDelta = getAspectDeclarationOrder(advisor1) - getAspectDeclarationOrder(advisor2);        if (oneOrOtherIsAfterAdvice) {            // the advice declared last has higher precedence            if (adviceDeclarationOrderDelta &lt; 0) {                // advice1 was declared before advice2                // so advice1 has lower precedence                return LOWER_PRECEDENCE;            }            else if (adviceDeclarationOrderDelta == 0) {                return SAME_PRECEDENCE;            }            else {                return HIGHER_PRECEDENCE;            }        }        else {            // the advice declared first has higher precedence            if (adviceDeclarationOrderDelta &lt; 0) {                // advice1 was declared before advice2                // so advice1 has higher precedence                return HIGHER_PRECEDENCE;            }            else if (adviceDeclarationOrderDelta == 0) {                return SAME_PRECEDENCE;            }            else {                return LOWER_PRECEDENCE;            }        }    }    private int getAspectDeclarationOrder(Advisor anAdvisor) {        AspectJPrecedenceInformation precedenceInfo =            AspectJAopUtils.getAspectJPrecedenceInformationFor(anAdvisor);        if (precedenceInfo != null) {            return precedenceInfo.getDeclarationOrder();        }        else {            return 0;        }    }</code></pre><p>这里就是通过<strong>precedenceInfo.getDeclarationOrder</strong>拿到在创建<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>对象时设置的<strong>declarationOrder</strong>属性，这就验证了之前的说法（实际上这里排序过程非常复杂，不是简单的按照这个属性进行排序）。当上面的一切都进行完成后，就该创建代理对象了，回到<strong>AbstractAutoProxyCreator.wrapIfNecessary</strong>，看关键部分代码：</p><pre><code>    //如果有切面，则生成该bean的代理    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        //把被代理对象bean实例封装到SingletonTargetSource对象中        Object proxy = createProxy(                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }</code></pre><p>注意这里将被代理对象封装成了一个<strong>SingletonTargetSource</strong>对象，它是<strong>TargetSource</strong>的实现类。</p><pre><code>    protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,            @Nullable Object[] specificInterceptors, TargetSource targetSource) {        if (this.beanFactory instanceof ConfigurableListableBeanFactory) {            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);        }        //创建代理工厂        ProxyFactory proxyFactory = new ProxyFactory();        proxyFactory.copyFrom(this);        if (!proxyFactory.isProxyTargetClass()) {            if (shouldProxyTargetClass(beanClass, beanName)) {                //proxyTargetClass 是否对类进行代理，而不是对接口进行代理，设置为true时，使用CGLib代理。                proxyFactory.setProxyTargetClass(true);            }            else {                evaluateProxyInterfaces(beanClass, proxyFactory);            }        }        //把advice类型的增强包装成advisor切面        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);        proxyFactory.addAdvisors(advisors);        proxyFactory.setTargetSource(targetSource);        customizeProxyFactory(proxyFactory);        ////用来控制代理工厂被配置后，是否还允许修改代理的配置,默认为false        proxyFactory.setFrozen(this.freezeProxy);        if (advisorsPreFiltered()) {            proxyFactory.setPreFiltered(true);        }        //获取代理实例        return proxyFactory.getProxy(getProxyClassLoader());    }</code></pre><p>这里通过<strong>ProxyFactory</strong>对象去创建代理实例，这是<strong>工厂模式</strong>的体现，但在创建代理对象之前还有几个准备动作：需要判断是JDK代理还是CGLIB代理以及通过<strong>buildAdvisors</strong>方法将扩展的<strong>Advice</strong>封装成<strong>Advisor</strong>切面。准备完成则通过<strong>getProxy</strong>创建代理对象：</p><pre><code>    public Object getProxy(@Nullable ClassLoader classLoader) {        //根据目标对象是否有接口来判断采用什么代理方式，cglib代理还是jdk动态代理        return createAopProxy().getProxy(classLoader);    }    protected final synchronized AopProxy createAopProxy() {        if (!this.active) {            activate();        }        return getAopProxyFactory().createAopProxy(this);    }    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {            Class&lt;?&gt; targetClass = config.getTargetClass();            if (targetClass == null) {                throw new AopConfigException("TargetSource cannot determine target class: " +                        "Either an interface or a target is required for proxy creation.");            }            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {                return new JdkDynamicAopProxy(config);            }            return new ObjenesisCglibAopProxy(config);        }        else {            return new JdkDynamicAopProxy(config);        }    }</code></pre><p>首先通过配置拿到对应的代理类：ObjenesisCglibAopProxy和JdkDynamicAopProxy，然后再通过<strong>getProxy</strong>创建Bean的代理，这里以<strong>JdkDynamicAopProxy</strong>为例：</p><pre><code>    public Object getProxy(@Nullable ClassLoader classLoader) {        //advised是代理工厂对象        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);    }</code></pre><p>这里的代码你应该不陌生了，就是JDK的原生API，<strong>newProxyInstance</strong>方法传入的<strong>InvocationHandler</strong>对象是<strong>this</strong>，因此，最终AOP代理的调用就是从该类中的<strong>invoke</strong>方法开始。至此，代理对象的创建就完成了，下面来看下整个过程的时序图：</p><div class=pgc-img><img alt=这一次搞懂Spring代理创建+AOP链式调用过程 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/692f7c1d1455426a8f4b2c6d119f7d0c><p class=pgc-img-caption></p></div><h2 class=line>小结</h2><p>代理对象的创建过程整体来说并不复杂，首先找到所有带有@Aspect注解的类，并获取其中没有@Pointcut注解的方法，循环创建切面，而创建切面需要<strong>切点</strong>和<strong>增强</strong>两个元素，其中切点可简单理解为我们写的表达式，增强则是根据@Before、@Around、@After等注解创建的对应的Advice类。切面创建好后则需要循环判断哪些切面能对当前的Bean实例的方法进行增强并排序，最后通过ProxyFactory创建代理对象。</p><h2 class=line>AOP链式调用</h2><p>熟悉JDK动态代理的都知道通过代理对象调用方法时，会进入到<strong>InvocationHandler</strong>对象的<strong>invoke</strong>方法，所以我们直接从<strong>JdkDynamicAopProxy</strong>的这个方法开始：</p><pre><code>    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        MethodInvocation invocation;        Object oldProxy = null;        boolean setProxyContext = false;        //从代理工厂中拿到TargetSource对象，该对象包装了被代理实例bean        TargetSource targetSource = this.advised.targetSource;        Object target = null;        try {            //被代理对象的equals方法和hashCode方法是不能被代理的，不会走切面            .......            Object retVal;            // 可以从当前线程中拿到代理对象            if (this.advised.exposeProxy) {                // Make invocation available if necessary.                oldProxy = AopContext.setCurrentProxy(proxy);                setProxyContext = true;            }            //这个target就是被代理实例            target = targetSource.getTarget();            Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);            //从代理工厂中拿过滤器链 Object是一个MethodInterceptor类型的对象，其实就是一个advice对象            List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);            //如果该方法没有执行链，则说明这个方法不需要被拦截，则直接反射调用            if (chain.isEmpty()) {                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);            }            else {                invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);                retVal = invocation.proceed();            }            // Massage return value if necessary.            Class&lt;?&gt; returnType = method.getReturnType();            if (retVal != null &amp;&amp; retVal == target &amp;&amp;                    returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;                    !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {                retVal = proxy;            }            return retVal;        }        finally {            if (target != null &amp;&amp; !targetSource.isStatic()) {                // Must have come from TargetSource.                targetSource.releaseTarget(target);            }            if (setProxyContext) {                // Restore old proxy.                AopContext.setCurrentProxy(oldProxy);            }        }    }</code></pre><p>这段代码比较长，我删掉了不关键的地方。首先来看<strong>this.advised.exposeProxy</strong>这个属性，这在@EnableAspectJAutoProxy注解中可以配置，当为true时，会将该代理对象设置到<strong>当前线程的ThreadLocal对象</strong>中，这样就可以通过<strong>AopContext.currentProxy</strong>拿到代理对象。这个有什么用呢？我相信有经验的Java开发都遇到过这样一个BUG，在Service实现类中调用本类中的另一个方法时，事务不会生效，这是因为直接通过this调用就不会调用到代理对象的方法，而是原对象的，所以事务切面就没有生效。因此这种情况下就可以从<strong>当前线程的ThreadLocal对象</strong>拿到代理对象，不过实际上直接使用@Autowired注入自己本身也可以拿到代理对象。接下来就是通过<strong>getInterceptorsAndDynamicInterceptionAdvice</strong>拿到执行链，看看具体做了哪些事情：</p><pre><code>    public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(            Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) {        AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();        //从代理工厂中获得该被代理类的所有切面advisor，config就是代理工厂对象        Advisor[] advisors = config.getAdvisors();        List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length);        Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());        Boolean hasIntroductions = null;        for (Advisor advisor : advisors) {            //大部分走这里            if (advisor instanceof PointcutAdvisor) {                // Add it conditionally.                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;                //如果切面的pointCut和被代理对象是匹配的，说明是切面要拦截的对象                if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();                    boolean match;                    if (mm instanceof IntroductionAwareMethodMatcher) {                        if (hasIntroductions == null) {                            hasIntroductions = hasMatchingIntroductions(advisors, actualClass);                        }                        match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);                    }                    else {                        //接下来判断方法是否是切面pointcut需要拦截的方法                        match = mm.matches(method, actualClass);                    }                    //如果类和方法都匹配                    if (match) {                        //获取到切面advisor中的advice，并且包装成MethodInterceptor类型的对象                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);                        if (mm.isRuntime()) {                            for (MethodInterceptor interceptor : interceptors) {                                interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));                            }                        }                        else {                            interceptorList.addAll(Arrays.asList(interceptors));                        }                    }                }            }            //如果是引介切面            else if (advisor instanceof IntroductionAdvisor) {                IntroductionAdvisor ia = (IntroductionAdvisor) advisor;                if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {                    Interceptor[] interceptors = registry.getInterceptors(advisor);                    interceptorList.addAll(Arrays.asList(interceptors));                }            }            else {                Interceptor[] interceptors = registry.getInterceptors(advisor);                interceptorList.addAll(Arrays.asList(interceptors));            }        }        return interceptorList;    }</code></pre><p>这也是个长方法，看关键的部分，因为之前我们创建的基本上都是<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>对象，该类是<strong>PointcutAdvisor</strong>的实现类，所以会进入第一个if判断里，这里首先进行匹配，看<strong>切点</strong>和<strong>当前对象</strong>以及该对象的哪些<strong>方法</strong>匹配，如果能匹配上，则调用<strong>getInterceptors</strong>获取执行链：</p><pre><code>    private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;&gt;(3);    public DefaultAdvisorAdapterRegistry() {        registerAdvisorAdapter(new MethodBeforeAdviceAdapter());        registerAdvisorAdapter(new AfterReturningAdviceAdapter());        registerAdvisorAdapter(new ThrowsAdviceAdapter());    }    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {        List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3);        Advice advice = advisor.getAdvice();        //如果是MethodInterceptor类型的，如：AspectJAroundAdvice        //AspectJAfterAdvice        //AspectJAfterThrowingAdvice        if (advice instanceof MethodInterceptor) {            interceptors.add((MethodInterceptor) advice);        }        //处理 AspectJMethodBeforeAdvice  AspectJAfterReturningAdvice        for (AdvisorAdapter adapter : this.adapters) {            if (adapter.supportsAdvice(advice)) {                interceptors.add(adapter.getInterceptor(advisor));            }        }        if (interceptors.isEmpty()) {            throw new UnknownAdviceTypeException(advisor.getAdvice());        }        return interceptors.toArray(new MethodInterceptor[0]);    }</code></pre><p>这里我们可以看到如果是<strong>MethodInterceptor</strong>的实现类，则直接添加到链中，如果不是，则需要通过<strong>适配器</strong>去包装后添加，刚好这里有<strong>MethodBeforeAdviceAdapter</strong>和<strong>AfterReturningAdviceAdapter</strong>两个适配器对应上文两个没有实现<strong>MethodInterceptor</strong>接口的类。最后将<strong>Interceptors</strong>返回。</p><pre><code>if (chain.isEmpty()) {    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);}else {    // We need to create a method invocation...    invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);    // Proceed to the joinpoint through the interceptor chain.    retVal = invocation.proceed();}</code></pre><p>返回到<strong>invoke</strong>方法后，如果执行链为空，说明该方法不需要被增强，所以直接反射调用原对象的方法（注意传入的是TargetSource封装的被代理对象）；反之，则通过<strong>ReflectiveMethodInvocation</strong>类进行链式调用，关键方法就是<strong>proceed</strong>：</p><pre><code>    private int currentInterceptorIndex = -1;    public Object proceed() throws Throwable {        //如果执行链中的advice全部执行完，则直接调用joinPoint方法，就是被代理方法        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {            return invokeJoinpoint();        }        Object interceptorOrInterceptionAdvice =                this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {            InterceptorAndDynamicMethodMatcher dm =                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;            Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());            if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {                return dm.interceptor.invoke(this);            }            else {                return proceed();            }        }        else {            //调用MethodInterceptor中的invoke方法            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);        }    }</code></pre><p>这个方法的核心就在两个地方：<strong>invokeJoinpoint</strong>和<strong>interceptorOrInterceptionAdvice.invoke(this)</strong>。当增强方法调用完后就会通过前者调用到被代理的方法，否则则是依次调用<strong>Interceptor</strong>的<strong>invoke</strong>方法。下面就分别看看每个<strong>Interceptor</strong>是怎么实现的。</p><ul><li>AspectJAroundAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        if (!(mi instanceof ProxyMethodInvocation)) {            throw new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);        }        ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;        ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);        JoinPointMatch jpm = getJoinPointMatch(pmi);        return invokeAdviceMethod(pjp, jpm, null, null);    }</code></pre><ul><li>MethodBeforeAdviceInterceptor -> AspectJMethodBeforeAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());        return mi.proceed();    }    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {        invokeAdviceMethod(getJoinPointMatch(), null, null);    }</code></pre><ul><li>AspectJAfterAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        try {            return mi.proceed();        }        finally {            invokeAdviceMethod(getJoinPointMatch(), null, null);        }    }</code></pre><ul><li>AfterReturningAdviceInterceptor -> AspectJAfterReturningAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        Object retVal = mi.proceed();        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());        return retVal;    }    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {        if (shouldInvokeOnReturnValueOf(method, returnValue)) {            invokeAdviceMethod(getJoinPointMatch(), returnValue, null);        }    }</code></pre><ul><li>AspectJAfterThrowingAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        try {            return mi.proceed();        }        catch (Throwable ex) {            if (shouldInvokeOnThrowing(ex)) {                invokeAdviceMethod(getJoinPointMatch(), null, ex);            }            throw ex;        }    }</code></pre><p>这里的调用顺序是怎样的呢？其核心就是通过<strong>proceed</strong>方法控制流程，每执行完一个Advice就会回到<strong>proceed</strong>方法中调用下一个Advice。可以思考一下，怎么才能让调用结果满足如下图的<strong>执行顺序</strong>。</p><div class=pgc-img><img alt=这一次搞懂Spring代理创建+AOP链式调用过程 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b56c9dee30924620b3ed4175efd82096><p class=pgc-img-caption></p></div><p><br></p><p>以上就是AOP的链式调用过程，但是这只是只有一个切面类的情况，如果有多个@Aspect类呢，这个调用过程又是怎样的？其核心思想和“栈”一样，就是“<strong>先进后出，后进先出</strong>”。</p><h2 class=line>AOP扩展知识</h2><h3 class=line>一、自定义全局拦截器Interceptor</h3><p>在上文创建代理对象的时候有这样一个方法：</p><pre><code>    protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {        //自定义MethodInterceptor.拿到setInterceptorNames方法注入的Interceptor对象        Advisor[] commonInterceptors = resolveInterceptorNames();        List&lt;Object&gt; allInterceptors = new ArrayList&lt;&gt;();        if (specificInterceptors != null) {            allInterceptors.addAll(Arrays.asList(specificInterceptors));            if (commonInterceptors.length &gt; 0) {                if (this.applyCommonInterceptorsFirst) {                    allInterceptors.addAll(0, Arrays.asList(commonInterceptors));                }                else {                    allInterceptors.addAll(Arrays.asList(commonInterceptors));                }            }        }        Advisor[] advisors = new Advisor[allInterceptors.size()];        for (int i = 0; i &lt; allInterceptors.size(); i++) {            //对自定义的advice要进行包装，把advice包装成advisor对象，切面对象            advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));        }        return advisors;    }</code></pre><p>这个方法的作用就在于我们可以扩展我们自己的Interceptor，首先通过<strong>resolveInterceptorNames</strong>方法获取到通过<strong>setInterceptorNames</strong>方法设置的Interceptor，然后调用<strong>DefaultAdvisorAdapterRegistry.wrap</strong>方法将其包装为<strong>DefaultPointcutAdvisor</strong>对象并返回：</p><pre><code>    public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {        if (adviceObject instanceof Advisor) {            return (Advisor) adviceObject;        }        if (!(adviceObject instanceof Advice)) {            throw new UnknownAdviceTypeException(adviceObject);        }        Advice advice = (Advice) adviceObject;        if (advice instanceof MethodInterceptor) {            return new DefaultPointcutAdvisor(advice);        }        for (AdvisorAdapter adapter : this.adapters) {            if (adapter.supportsAdvice(advice)) {                return new DefaultPointcutAdvisor(advice);            }        }        throw new UnknownAdviceTypeException(advice);    }    public DefaultPointcutAdvisor(Advice advice) {        this(Pointcut.TRUE, advice);    }</code></pre><p>需要注意<strong>DefaultPointcutAdvisor</strong>构造器里面传入了一个<strong>Pointcut.TRUE</strong>，表示这种扩展的Interceptor是全局的拦截器。下面来看看如何使用：</p><pre><code>public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object invoke(MethodInvocation invocation) throws Throwable {        System.out.println("自定义拦截器");        return invocation.proceed();    }}</code></pre><p>首先写一个类实现<strong>MethodInterceptor 接口，在invoke</strong>方法中实现我们的拦截逻辑，然后通过下面的方式测试，只要<strong>UserService 有AOP拦截就会发现自定义的MyMethodInterceptor</strong>也生效了。</p><pre><code>    public void costomInterceptorTest() {        AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);        bean.setInterceptorNames("myMethodInterceptor ");        UserService userService = applicationContext.getBean(UserService.class);        userService.queryUser("dark");    }</code></pre><p>但是如果换个顺序，像下面这样：</p><pre><code>    public void costomInterceptorTest() {        UserService userService = applicationContext.getBean(UserService.class);        AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);        bean.setInterceptorNames("myMethodInterceptor ");        userService.queryUser("dark");    }</code></pre><p>这时自定义的全局拦截器就没有作用了，这是为什么呢？因为当执行<strong>getBean</strong>的时候，如果有切面匹配就会通过<strong>ProxyFactory</strong>去创建代理对象，注意<strong>Interceptor</strong>是存到这个Factory对象中的，而这个对象和代理对象是<strong>一一对应</strong>的，因此调用<strong>getBean</strong>时，还没有<strong>myMethodInterceptor</strong>这个对象，自定义拦截器就没有效果了，也就是说要想自定义拦截器生效，就必须在代理对象生成之前注册进去。</p><h3 class=line>二、循环依赖三级缓存存在的必要性</h3><p>在上一篇文章我分析了Spring是如何通过三级缓存来解决循环依赖的问题的，但你是否考虑过<strong>第三级缓存</strong>为什么要存在？我直接将bean存到二级不就行了么，为什么还要存一个<strong>ObjectFactory</strong>对象到<strong>第三级缓存</strong>中？这个在学习了AOP之后就很清楚了，因为我们在@Autowired对象时，想要注入的不一定是Bean本身，而是想要注入一个<strong>修改</strong>过后的对象，如<strong>代理对象</strong>。在<strong>AbstractAutowireCapableBeanFactory.getEarlyBeanReference</strong>方法中循环调用了<strong>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</strong>方法，<strong>AbstractAutoProxyCreator</strong>对象就实现了该方法：</p><pre><code>    public Object getEarlyBeanReference(Object bean, String beanName) {        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (!this.earlyProxyReferences.contains(cacheKey)) {            this.earlyProxyReferences.add(cacheKey);        }        // 创建代理对象        return wrapIfNecessary(bean, beanName, cacheKey);    }</code></pre><p>因此，当我们想要对循坏依赖的Bean做出<strong>修改</strong>时，就可以像AOP这样做。</p><h3 class=line>三、如何在Bean创建之前提前创建代理对象</h3><p>Spring的代理对象基本上都是在Bean实例化完成之后创建的，但在文章开始我就说过，Spring也提供了一个机会在创建Bean对象之前就创建代理对象，在<strong>AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation</strong>方法中：</p><pre><code>    protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {        Object bean = null;        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {            // Make sure bean class is actually resolved at this point.            if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {                Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);                if (targetType != null) {                    bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);                    if (bean != null) {                        bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);                    }                }            }            mbd.beforeInstantiationResolved = (bean != null);        }        return bean;    }    protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) {                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);                if (result != null) {                    return result;                }            }        }        return null;    }</code></pre><p>主要是<strong>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</strong>方法中，这里又会进入到<strong>AbstractAutoProxyCreator</strong>类中：</p><pre><code>    public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);        if (targetSource != null) {            if (StringUtils.hasLength(beanName)) {                this.targetSourcedBeans.add(beanName);            }            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);            this.proxyTypes.put(cacheKey, proxy.getClass());            return proxy;        }        return null;    }    protected TargetSource getCustomTargetSource(Class&lt;?&gt; beanClass, String beanName) {        // We can't create fancy target sources for directly registered singletons.        if (this.customTargetSourceCreators != null &amp;&amp;                this.beanFactory != null &amp;&amp; this.beanFactory.containsBean(beanName)) {            for (TargetSourceCreator tsc : this.customTargetSourceCreators) {                TargetSource ts = tsc.getTargetSource(beanClass, beanName);                if (ts != null) {                    return ts;                }            }        }        // No custom TargetSource found.        return null;    }</code></pre><p>看到这里大致应该明白了，先是获取到一个<strong>自定义的TargetSource</strong>对象，然后创建代理对象，所以我们首先需要自己实现一个<strong>TargetSource</strong>类，这里直接继承一个抽象类，<strong>getTarget</strong>方法则返回原始对象：</p><pre><code>public class MyTargetSource extends AbstractBeanFactoryBasedTargetSource {    @Override    public Object getTarget() throws Exception {        return getBeanFactory().getBean(getTargetBeanName());    }}</code></pre><p>但这还不够，上面首先判断了<strong>customTargetSourceCreators!=null</strong>，而这个属性是个数组，可以通过下面这个方法设置进来：</p><pre><code>    public void setCustomTargetSourceCreators(TargetSourceCreator... targetSourceCreators) {        this.customTargetSourceCreators = targetSourceCreators;    }</code></pre><p>所以我们还要实现一个<strong>TargetSourceCreator</strong>类，同样继承一个抽象类实现，并只对<strong>userServiceImpl</strong>对象进行拦截：</p><pre><code>public class MyTargetSourceCreator extends AbstractBeanFactoryBasedTargetSourceCreator {    @Override    protected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(Class&lt;?&gt; beanClass, String beanName) {        if (getBeanFactory() instanceof ConfigurableListableBeanFactory) {            if(beanName.equalsIgnoreCase("userServiceImpl")) {                return new MyTargetSource();            }        }        return null;    }}</code></pre><p><strong>createBeanFactoryBasedTargetSource</strong>方法是在<strong>AbstractBeanFactoryBasedTargetSourceCreator.getTargetSource</strong>中调用的，而<strong>getTargetSource</strong>就是在上面<strong>getCustomTargetSource</strong>中调用的。以上工作做完后，还需要将其设置到<strong>AnnotationAwareAspectJAutoProxyCreator</strong>对象中，因此需要我们注入这个对象：</p><pre><code>@Configurationpublic class TargetSourceCreatorBean {    @Autowired    private BeanFactory beanFactory;   @Bean    public AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator() {        AnnotationAwareAspectJAutoProxyCreator creator = new AnnotationAwareAspectJAutoProxyCreator();        MyTargetSourceCreator myTargetSourceCreator = new MyTargetSourceCreator();        myTargetSourceCreator.setBeanFactory(beanFactory);        creator.setCustomTargetSourceCreators(myTargetSourceCreator);        return creator;    }}</code></pre><p>这样，当我们通过getBean获取<strong>userServiceImpl</strong>的对象时，就会优先生成代理对象，然后在调用执行链的过程中再通过<strong>TargetSource.getTarget</strong>获取到被代理对象。但是，为什么我们在<strong>getTarget</strong>方法中调用<strong>getBean</strong>就能拿到被代理对象呢？继续探究，通过断点我发现从<strong>getTarget</strong>进入时，在<strong>resolveBeforeInstantiation</strong>方法中返回的bean就是null了，而<strong>getBeanPostProcessors</strong>方法返回的<strong>Processors</strong>中也没有了<strong>AnnotationAwareAspectJAutoProxyCreator</strong>对象，也就是没有进入到<strong>AbstractAutoProxyCreator.postProcessBeforeInstantiation</strong>方法中，所以不会再次获取到代理对象，那<strong>AnnotationAwareAspectJAutoProxyCreator</strong>对象是在什么时候移除的呢？带着问题，我开始反推，发现在<strong>AbstractBeanFactoryBasedTargetSourceCreator</strong>类中有这样一个方法<strong>buildInternalBeanFactory</strong>：</p><pre><code>    protected DefaultListableBeanFactory buildInternalBeanFactory(ConfigurableBeanFactory containingFactory) {        DefaultListableBeanFactory internalBeanFactory = new DefaultListableBeanFactory(containingFactory);        // Required so that all BeanPostProcessors, Scopes, etc become available.        internalBeanFactory.copyConfigurationFrom(containingFactory);        // Filter out BeanPostProcessors that are part of the AOP infrastructure,        // since those are only meant to apply to beans defined in the original factory.        internalBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -&gt;                beanPostProcessor instanceof AopInfrastructureBean);        return internalBeanFactory;    }</code></pre><p>在这里移除掉了所有<strong>AopInfrastructureBean</strong>的子类，而<strong>AnnotationAwareAspectJAutoProxyCreator</strong>就是其子类，那这个方法是在哪里调用的呢？继续反推：</p><pre><code>    protected DefaultListableBeanFactory getInternalBeanFactoryForBean(String beanName) {        synchronized (this.internalBeanFactories) {            DefaultListableBeanFactory internalBeanFactory = this.internalBeanFactories.get(beanName);            if (internalBeanFactory == null) {                internalBeanFactory = buildInternalBeanFactory(this.beanFactory);                this.internalBeanFactories.put(beanName, internalBeanFactory);            }            return internalBeanFactory;        }    }    public final TargetSource getTargetSource(Class&lt;?&gt; beanClass, String beanName) {        AbstractBeanFactoryBasedTargetSource targetSource =                createBeanFactoryBasedTargetSource(beanClass, beanName);        // 创建完targetSource后就移除掉AopInfrastructureBean类型的BeanPostProcessor对象，如AnnotationAwareAspectJAutoProxyCreator        DefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName);        ......        return targetSource;    }</code></pre><p>至此，关于<strong>TargetSource</strong>接口扩展的原理就搞明白了。</p><h1 class=line>总结</h1><p>本篇篇幅比较长，主要搞明白Spring代理对象是如何创建的以及AOP链式调用过程，而后面的扩展则是对AOP以及Bean创建过程中一些疑惑的补充，可根据实际情况学习掌握。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'搞懂','Spring','创建'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>