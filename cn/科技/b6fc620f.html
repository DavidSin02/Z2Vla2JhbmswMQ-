<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ | æå®¢å¿«è¨Š</title><meta property="og:title" content="è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ - æå®¢å¿«è¨Š"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/e1c7c82fff674a01b49573f34eb5dc1b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b6fc620f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b6fc620f.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹"><meta name=author content="æå®¢å¿«è¨Š"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b6fc620f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>ğŸ¤“ æå®¢å¿«è®¯ Geek Bank</a></h1><p class=description>ä¸ºä½ å¸¦æ¥æœ€å…¨çš„ç§‘æŠ€çŸ¥è¯† ğŸ§¡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>çŒœä½ å–œæ­¡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=ç§‘æŠ€>ç§‘æŠ€</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=éŠæˆ²>éŠæˆ²</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=ç§‘å­¸>ç§‘å­¸</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>ç§‘æŠ€</a></span></div><div class=post-content><h1 class=line>å‰è¨€</h1><p>AOPï¼Œä¹Ÿå°±æ˜¯é¢å‘åˆ‡é¢ç¼–ç¨‹ï¼Œå®ƒå¯ä»¥å°†å…¬å…±çš„ä»£ç æŠ½ç¦»å‡ºæ¥ï¼ŒåŠ¨æ€çš„æ¤å…¥åˆ°ç›®æ ‡ç±»ã€ç›®æ ‡æ–¹æ³•ä¸­ï¼Œå¤§å¤§æé«˜æˆ‘ä»¬ç¼–ç¨‹çš„æ•ˆç‡ï¼Œä¹Ÿä½¿ç¨‹åºå˜å¾—æ›´åŠ ä¼˜é›…ã€‚å¦‚äº‹åŠ¡ã€æ“ä½œæ—¥å¿—ç­‰éƒ½å¯ä»¥ä½¿ç”¨AOPå®ç°ã€‚è¿™ç§ç»‡å…¥å¯ä»¥æ˜¯<strong>åœ¨è¿è¡ŒæœŸåŠ¨æ€ç”Ÿæˆä»£ç†å¯¹è±¡</strong>å®ç°ï¼Œä¹Ÿå¯ä»¥åœ¨<strong>ç¼–è¯‘æœŸ</strong>ã€<strong>ç±»åŠ è½½æ—¶æœŸ</strong>é™æ€ç»‡å…¥åˆ°ä»£ç ä¸­ã€‚è€ŒSpringæ­£æ˜¯é€šè¿‡ç¬¬ä¸€ç§æ–¹æ³•å®ç°ï¼Œä¸”åœ¨ä»£ç†ç±»çš„ç”Ÿæˆä¸Šä¹Ÿæœ‰ä¸¤ç§æ–¹å¼ï¼šJDK Proxyå’ŒCGLIBï¼Œé»˜è®¤å½“ç±»å®ç°äº†æ¥å£æ—¶ä½¿ç”¨å‰è€…ï¼Œå¦åˆ™ä½¿ç”¨åè€…ï¼›å¦å¤–Spring AOPåªèƒ½å®ç°å¯¹æ–¹æ³•çš„å¢å¼ºã€‚</p><h1 class=line>æ­£æ–‡</h1><h2 class=line>åŸºæœ¬æ¦‚å¿µ</h2><p>AOPçš„æœ¯è¯­å¾ˆå¤šï¼Œè™½ç„¶ä¸æ¸…æ¥šæœ¯è¯­æˆ‘ä»¬ä¹Ÿèƒ½å¾ˆç†Ÿç»ƒåœ°ä½¿ç”¨AOPï¼Œä½†æ˜¯è¦ç†è§£åˆ†ææºç ï¼Œæœ¯è¯­å°±éœ€è¦æ·±åˆ»ä½“ä¼šå…¶å«ä¹‰ã€‚</p><ul><li>å¢å¼ºï¼ˆAdviceï¼‰ï¼šå°±æ˜¯æˆ‘ä»¬æƒ³è¦é¢å¤–å¢åŠ çš„åŠŸèƒ½</li><li>ç›®æ ‡å¯¹è±¡ï¼ˆTargetï¼‰ï¼šå°±æ˜¯æˆ‘ä»¬æƒ³è¦å¢å¼ºçš„ç›®æ ‡ç±»ï¼Œå¦‚æœæ²¡æœ‰AOPï¼Œæˆ‘ä»¬éœ€è¦åœ¨æ¯ä¸ªç›®æ ‡å¯¹è±¡ä¸­å®ç°æ—¥å¿—ã€äº‹åŠ¡ç®¡ç†ç­‰éä¸šåŠ¡é€»è¾‘</li><li>è¿æ¥ç‚¹ï¼ˆJoinPointï¼‰ï¼šç¨‹åºæ‰§è¡Œæ—¶çš„ç‰¹å®šæ—¶æœºï¼Œå¦‚æ–¹æ³•æ‰§è¡Œå‰ã€åä»¥åŠæŠ›å‡ºå¼‚å¸¸åç­‰ç­‰ã€‚</li><li>åˆ‡ç‚¹ï¼ˆPointcutï¼‰ï¼šè¿æ¥ç‚¹çš„å¯¼èˆªï¼Œæˆ‘ä»¬å¦‚ä½•æ‰¾åˆ°ç›®æ ‡å¯¹è±¡å‘¢ï¼Ÿåˆ‡ç‚¹çš„ä½œç”¨å°±åœ¨äºæ­¤ï¼Œåœ¨Springä¸­å°±æ˜¯åŒ¹é…è¡¨è¾¾å¼ã€‚</li><li>å¼•ä»‹ï¼ˆIntroductionï¼‰ï¼šå¼•ä»‹æ˜¯ä¸€ç§ç‰¹æ®Šçš„å¢å¼ºï¼Œå®ƒä¸ºç±»æ·»åŠ ä¸€äº›å±æ€§å’Œæ–¹æ³•ã€‚è¿™æ ·ï¼Œå³ä½¿ä¸€ä¸ªä¸šåŠ¡ç±»åŸæœ¬æ²¡æœ‰å®ç°æŸä¸ªæ¥å£ï¼Œé€šè¿‡AOPçš„å¼•ä»‹åŠŸèƒ½ï¼Œæˆ‘ä»¬å¯ä»¥åŠ¨æ€åœ°ä¸ºè¯¥ä¸šåŠ¡ç±»æ·»åŠ æ¥å£çš„å®ç°é€»è¾‘ï¼Œè®©ä¸šåŠ¡ç±»æˆä¸ºè¿™ä¸ªæ¥å£çš„å®ç°ç±»ã€‚</li><li>ç»‡å…¥ï¼ˆWeavingï¼‰ï¼šå³å¦‚ä½•å°†å¢å¼ºæ·»åŠ åˆ°ç›®æ ‡å¯¹è±¡çš„è¿æ¥ç‚¹ä¸Šï¼Œæœ‰åŠ¨æ€ï¼ˆè¿è¡ŒæœŸç”Ÿæˆä»£ç†ï¼‰ã€é™æ€ï¼ˆç¼–è¯‘æœŸã€ç±»åŠ è½½æ—¶æœŸï¼‰ä¸¤ç§æ–¹å¼ã€‚</li><li>ä»£ç†ï¼ˆProxyï¼‰ï¼šç›®æ ‡å¯¹è±¡è¢«æ¤å…¥å¢å¼ºåï¼Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªä»£ç†å¯¹è±¡ï¼Œè¯¥å¯¹è±¡å¯èƒ½æ˜¯å’ŒåŸå¯¹è±¡å®ç°äº†åŒæ ·çš„ä¸€ä¸ªæ¥å£ï¼ˆJDKï¼‰ï¼Œä¹Ÿå¯èƒ½æ˜¯åŸå¯¹è±¡çš„å­ç±»ï¼ˆCGLIBï¼‰ã€‚</li><li>åˆ‡é¢ï¼ˆAspectã€Advisorï¼‰ï¼šåˆ‡é¢ç”±åˆ‡ç‚¹å’Œå¢å¼ºç»„æˆï¼ŒåŒ…å«äº†è¿™ä¸¤è€…çš„å®šä¹‰ã€‚</li></ul><h2 class=line>ä»£ç†å¯¹è±¡çš„åˆ›å»º</h2><p>åœ¨ç†Ÿæ‚‰äº†AOPæœ¯è¯­åï¼Œä¸‹é¢å°±æ¥çœ‹çœ‹Springæ˜¯å¦‚ä½•åˆ›å»ºä»£ç†å¯¹è±¡çš„ï¼Œæ˜¯å¦è¿˜è®°å¾—ä¸Šä¸€ç¯‡æåˆ°çš„AOPçš„å…¥å£å‘¢ï¼Ÿåœ¨<strong>AbstractAutowireCapableBeanFactory</strong>ç±»çš„<strong>applyBeanPostProcessorsAfterInitialization</strong>æ–¹æ³•ä¸­å¾ªç¯è°ƒç”¨äº†<strong>BeanPostProcessor</strong>çš„<strong>postProcessAfterInitialization</strong>æ–¹æ³•ï¼Œå…¶ä¸­ä¸€ä¸ªå°±æ˜¯æˆ‘ä»¬åˆ›å»ºä»£ç†å¯¹è±¡çš„å…¥å£ã€‚è¿™é‡Œæ˜¯Beanå®ä¾‹åŒ–å®Œæˆå»åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œç†æ‰€å½“ç„¶åº”è¯¥è¿™æ ·ï¼Œä½†å®é™…ä¸Šåœ¨Beanå®ä¾‹åŒ–ä¹‹å‰è°ƒç”¨äº†ä¸€ä¸ª<strong>resolveBeforeInstantiation</strong>æ–¹æ³•ï¼Œè¿™é‡Œå®é™…ä¸Šæˆ‘ä»¬ä¹Ÿæ˜¯æœ‰æœºä¼šå¯ä»¥æå‰åˆ›å»ºä»£ç†å¯¹è±¡çš„ï¼Œè¿™é‡Œæ”¾åˆ°æœ€åæ¥åˆ†æï¼Œå…ˆæ¥çœ‹ä¸»å…¥å£ï¼Œè¿›å…¥åˆ°<strong>AbstractAutoProxyCreator</strong>ç±»ä¸­ï¼š</p><pre><code>    public Object postProcessAfterInitialization(@Nullable Object bean, String beanName) {        if (bean != null) {            Object cacheKey = getCacheKey(bean.getClass(), beanName);            if (!this.earlyProxyReferences.contains(cacheKey)) {                return wrapIfNecessary(bean, beanName, cacheKey);            }        }        return bean;    }    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {        //åˆ›å»ºå½“å‰beançš„ä»£ç†ï¼Œå¦‚æœè¿™ä¸ªbeanæœ‰adviceçš„è¯ï¼Œé‡ç‚¹çœ‹        // Create proxy if we have advice.        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);        //å¦‚æœæœ‰åˆ‡é¢ï¼Œåˆ™ç”Ÿæˆè¯¥beançš„ä»£ç†        if (specificInterceptors != DO_NOT_PROXY) {            this.advisedBeans.put(cacheKey, Boolean.TRUE);            //æŠŠè¢«ä»£ç†å¯¹è±¡beanå®ä¾‹å°è£…åˆ°SingletonTargetSourceå¯¹è±¡ä¸­            Object proxy = createProxy(                    bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));            this.proxyTypes.put(cacheKey, proxy.getClass());            return proxy;        }        this.advisedBeans.put(cacheKey, Boolean.FALSE);        return bean;    }</code></pre><p>å…ˆä»ç¼“å­˜ä¸­æ‹¿ï¼Œæ²¡æœ‰åˆ™è°ƒç”¨<strong>wrapIfNecessary</strong>æ–¹æ³•åˆ›å»ºã€‚åœ¨è¿™ä¸ªæ–¹æ³•é‡Œé¢ä¸»è¦çœ‹ä¸¤ä¸ªåœ°æ–¹ï¼š<strong>getAdvicesAndAdvisorsForBean</strong>å’Œ<strong>createProxy</strong>ã€‚ç®€å•ä¸€å¥è¯æ¦‚æ‹¬å°±æ˜¯å…ˆæ‰«æååˆ›å»ºï¼Œé—®é¢˜æ˜¯æ‰«æä»€ä¹ˆå‘¢ï¼Ÿä½ å¯ä»¥å…ˆç»“åˆä¸Šé¢çš„æ¦‚å¿µæ€è€ƒä¸‹ï¼Œæ¢ä½ ä¼šæ€ä¹ˆåšã€‚è¿›å…¥åˆ°å­ç±»<strong>AbstractAdvisorAutoProxyCreator</strong>çš„<strong>getAdvicesAndAdvisorsForBean</strong>æ–¹æ³•ä¸­ï¼š</p><pre><code>    protected Object[] getAdvicesAndAdvisorsForBean(            Class&lt;?&gt; beanClass, String beanName, @Nullable TargetSource targetSource) {        //æ‰¾åˆ°åˆæ ¼çš„åˆ‡é¢        List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);        if (advisors.isEmpty()) {            return DO_NOT_PROXY;        }        return advisors.toArray();    }    protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {        //æ‰¾åˆ°å€™é€‰çš„åˆ‡é¢,å…¶å®å°±æ˜¯ä¸€ä¸ªå¯»æ‰¾æœ‰@Aspectjæ³¨è§£çš„è¿‡ç¨‹ï¼ŒæŠŠå·¥ç¨‹ä¸­æ‰€æœ‰æœ‰è¿™ä¸ªæ³¨è§£çš„ç±»å°è£…æˆAdvisorè¿”å›        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();        //åˆ¤æ–­å€™é€‰çš„åˆ‡é¢æ˜¯å¦ä½œç”¨åœ¨å½“å‰beanClassä¸Šé¢ï¼Œå°±æ˜¯ä¸€ä¸ªåŒ¹é…è¿‡ç¨‹ã€‚ç°åœ¨å°±æ˜¯ä¸€ä¸ªåŒ¹é…        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);        extendAdvisors(eligibleAdvisors);        if (!eligibleAdvisors.isEmpty()) {            //å¯¹æœ‰@Order@Priorityè¿›è¡Œæ’åº            eligibleAdvisors = sortAdvisors(eligibleAdvisors);        }        return eligibleAdvisors;    }</code></pre><p>åœ¨<strong>findEligibleAdvisors</strong>æ–¹æ³•ä¸­å¯ä»¥çœ‹åˆ°æœ‰ä¸¤ä¸ªæ­¥éª¤ï¼Œç¬¬ä¸€å…ˆæ‰¾åˆ°æ‰€æœ‰çš„åˆ‡é¢ï¼Œå³æ‰«ææ‰€æœ‰å¸¦æœ‰@Aspectæ³¨è§£çš„ç±»ï¼Œå¹¶å°†å…¶ä¸­çš„<strong>åˆ‡ç‚¹ï¼ˆè¡¨è¾¾å¼ï¼‰</strong>å’Œ<strong>å¢å¼º</strong>å°è£…ä¸º<strong>åˆ‡é¢</strong>ï¼Œæ‰«æå®Œæˆåï¼Œè‡ªç„¶æ˜¯è¦åˆ¤æ–­å“ªäº›<strong>åˆ‡é¢</strong>èƒ½å¤Ÿè¿æ¥åˆ°å½“å‰Beanå®ä¾‹ä¸Šã€‚ä¸‹é¢ä¸€æ­¥æ­¥æ¥åˆ†æï¼Œé¦–å…ˆæ˜¯æ‰«æè¿‡ç¨‹ï¼Œè¿›å…¥åˆ°<strong>AnnotationAwareAspectJAutoProxyCreator</strong>ç±»ä¸­ï¼š</p><pre><code>    protected List&lt;Advisor&gt; findCandidateAdvisors() {        // å…ˆé€šè¿‡çˆ¶ç±»AbstractAdvisorAutoProxyCreatoræ‰«æï¼Œè¿™é‡Œä¸é‡è¦        List&lt;Advisor&gt; advisors = super.findCandidateAdvisors();        // ä¸»è¦çœ‹è¿™é‡Œ        if (this.aspectJAdvisorsBuilder != null) {            advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors());        }        return advisors;    }</code></pre><p>è¿™é‡Œå§”æ‰˜ç»™äº†<strong>BeanFactoryAspectJAdvisorsBuilderAdapter</strong>ç±»ï¼Œå¹¶è°ƒç”¨å…¶çˆ¶ç±»çš„<strong>buildAspectJAdvisors</strong>æ–¹æ³•åˆ›å»ºåˆ‡é¢å¯¹è±¡ï¼š</p><pre><code>    public List&lt;Advisor&gt; buildAspectJAdvisors() {        List&lt;String&gt; aspectNames = this.aspectBeanNames;        if (aspectNames == null) {            synchronized (this) {                aspectNames = this.aspectBeanNames;                if (aspectNames == null) {                    List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();                    aspectNames = new ArrayList&lt;&gt;();                    //è·å–springå®¹å™¨ä¸­çš„æ‰€æœ‰beançš„åç§°BeanName                    String[] beanNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(                            this.beanFactory, Object.class, true, false);                    for (String beanName : beanNames) {                        if (!isEligibleBean(beanName)) {                            continue;                        }                        Class&lt;?&gt; beanType = this.beanFactory.getType(beanName);                        if (beanType == null) {                            continue;                        }                        //åˆ¤æ–­ç±»ä¸Šæ˜¯å¦æœ‰@Aspectæ³¨è§£                        if (this.advisorFactory.isAspect(beanType)) {                            aspectNames.add(beanName);                            AspectMetadata amd = new AspectMetadata(beanType, beanName);                            if (amd.getAjType().getPerClause().getKind() == PerClauseKind.SINGLETON) {                                // å½“@Aspectçš„valueå±æ€§ä¸º""æ—¶æ‰ä¼šè¿›å…¥åˆ°è¿™é‡Œ                                // åˆ›å»ºè·å–æœ‰@Aspectæ³¨è§£ç±»çš„å®ä¾‹å·¥å‚ï¼Œè´Ÿè´£è·å–æœ‰@Aspectæ³¨è§£ç±»çš„å®ä¾‹                                MetadataAwareAspectInstanceFactory factory =                                        new BeanFactoryAspectInstanceFactory(this.beanFactory, beanName);                                //åˆ›å»ºåˆ‡é¢advisorå¯¹è±¡                                List&lt;Advisor&gt; classAdvisors = this.advisorFactory.getAdvisors(factory);                                if (this.beanFactory.isSingleton(beanName)) {                                    this.advisorsCache.put(beanName, classAdvisors);                                }                                else {                                    this.aspectFactoryCache.put(beanName, factory);                                }                                advisors.addAll(classAdvisors);                            }                            else {                                MetadataAwareAspectInstanceFactory factory =                                        new PrototypeAspectInstanceFactory(this.beanFactory, beanName);                                this.aspectFactoryCache.put(beanName, factory);                                advisors.addAll(this.advisorFactory.getAdvisors(factory));                            }                        }                    }                    this.aspectBeanNames = aspectNames;                    return advisors;                }            }        }        return advisors;    }</code></pre><p>è¿™ä¸ªæ–¹æ³•é‡Œé¢é¦–å…ˆä»IOCä¸­æ‹¿åˆ°æ‰€æœ‰Beançš„åç§°ï¼Œå¹¶å¾ªç¯åˆ¤æ–­è¯¥ç±»ä¸Šæ˜¯å¦å¸¦æœ‰@Aspectæ³¨è§£ï¼Œå¦‚æœæœ‰åˆ™å°†BeanNameå’ŒBeançš„Classç±»å‹å°è£…åˆ°<strong>BeanFactoryAspectInstanceFactory</strong>ä¸­ï¼Œå¹¶è°ƒç”¨<strong>ReflectiveAspectJAdvisorFactory.getAdvisors</strong>åˆ›å»ºåˆ‡é¢å¯¹è±¡ï¼š</p><pre><code>    public List&lt;Advisor&gt; getAdvisors(MetadataAwareAspectInstanceFactory aspectInstanceFactory) {        //ä»å·¥å‚ä¸­è·å–æœ‰@Aspectæ³¨è§£çš„ç±»Class        Class&lt;?&gt; aspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();        //ä»å·¥å‚ä¸­è·å–æœ‰@Aspectæ³¨è§£çš„ç±»çš„åç§°        String aspectName = aspectInstanceFactory.getAspectMetadata().getAspectName();        validate(aspectClass);        // åˆ›å»ºå·¥å‚çš„è£…é¥°ç±»ï¼Œè·å–å®ä¾‹åªä¼šè·å–ä¸€æ¬¡        MetadataAwareAspectInstanceFactory lazySingletonAspectInstanceFactory =                new LazySingletonAspectInstanceFactoryDecorator(aspectInstanceFactory);        List&lt;Advisor&gt; advisors = new ArrayList&lt;&gt;();        //è¿™é‡Œå¾ªç¯æ²¡æœ‰@Pointcutæ³¨è§£çš„æ–¹æ³•        for (Method method : getAdvisorMethods(aspectClass)) {            //éå¸¸é‡è¦é‡ç‚¹çœ‹çœ‹            Advisor advisor = getAdvisor(method, lazySingletonAspectInstanceFactory, advisors.size(), aspectName);            if (advisor != null) {                advisors.add(advisor);            }        }        if (!advisors.isEmpty() &amp;&amp; lazySingletonAspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {            Advisor instantiationAdvisor = new SyntheticInstantiationAdvisor(lazySingletonAspectInstanceFactory);            advisors.add(0, instantiationAdvisor);        }        //åˆ¤æ–­å±æ€§ä¸Šæ˜¯å¦æœ‰å¼•ä»‹æ³¨è§£ï¼Œè¿™é‡Œå¯ä»¥ä¸çœ‹        for (Field field : aspectClass.getDeclaredFields()) {            //åˆ¤æ–­å±æ€§ä¸Šæ˜¯å¦æœ‰DeclareParentsæ³¨è§£ï¼Œå¦‚æœæœ‰è¿”å›åˆ‡é¢            Advisor advisor = getDeclareParentsAdvisor(field);            if (advisor != null) {                advisors.add(advisor);            }        }        return advisors;    }    private List&lt;Method&gt; getAdvisorMethods(Class&lt;?&gt; aspectClass) {        final List&lt;Method&gt; methods = new ArrayList&lt;&gt;();        ReflectionUtils.doWithMethods(aspectClass, method -&gt; {            // Exclude pointcuts            if (AnnotationUtils.getAnnotation(method, Pointcut.class) == null) {                methods.add(method);            }        });        methods.sort(METHOD_COMPARATOR);        return methods;    }</code></pre><p>æ ¹æ®Aspectçš„Classæ‹¿åˆ°æ‰€æœ‰ä¸å¸¦@Pointcutæ³¨è§£çš„æ–¹æ³•å¯¹è±¡ï¼ˆä¸ºä»€ä¹ˆæ˜¯ä¸å¸¦@Pointcutæ³¨è§£çš„æ–¹æ³•ï¼Ÿä»”ç»†æƒ³æƒ³ä¸éš¾ç†è§£ï¼‰ï¼Œå¦å¤–è¦æ³¨æ„è¿™é‡Œå¯¹methodè¿›è¡Œäº†æ’åºï¼Œçœ‹çœ‹è¿™ä¸ª<strong>METHOD_COMPARATOR</strong>æ¯”è¾ƒå™¨ï¼š</p><pre><code>    private static final Comparator&lt;Method&gt; METHOD_COMPARATOR;    static {        Comparator&lt;Method&gt; adviceKindComparator = new ConvertingComparator&lt;&gt;(                new InstanceComparator&lt;&gt;(                        Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class),                (Converter&lt;Method, Annotation&gt;) method -&gt; {                    AspectJAnnotation&lt;?&gt; annotation =                        AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(method);                    return (annotation != null ? annotation.getAnnotation() : null);                });        Comparator&lt;Method&gt; methodNameComparator = new ConvertingComparator&lt;&gt;(Method::getName);        METHOD_COMPARATOR = adviceKindComparator.thenComparing(methodNameComparator);    }</code></pre><p>å…³æ³¨<strong>InstanceComparator</strong>æ„é€ å‡½æ•°å‚æ•°ï¼Œè®°ä½å®ƒä»¬çš„é¡ºåºï¼Œè¿™å°±æ˜¯AOPé“¾å¼è°ƒç”¨ä¸­åŒä¸€ä¸ª@Aspectç±»ä¸­Adviceçš„<strong>æ‰§è¡Œé¡ºåº</strong>ã€‚æ¥ç€å¾€ä¸‹çœ‹ï¼Œåœ¨<strong>getAdvisors</strong>æ–¹æ³•ä¸­å¾ªç¯è·å–åˆ°çš„methodsï¼Œåˆ†åˆ«è°ƒç”¨<strong>getAdvisor</strong>æ–¹æ³•ï¼Œä¹Ÿå°±æ˜¯æ ¹æ®æ–¹æ³•é€ä¸ªå»åˆ›å»ºåˆ‡é¢ï¼š</p><pre><code>    public Advisor getAdvisor(Method candidateAdviceMethod, MetadataAwareAspectInstanceFactory aspectInstanceFactory,            int declarationOrderInAspect, String aspectName) {        validate(aspectInstanceFactory.getAspectMetadata().getAspectClass());        //è·å–pointCutå¯¹è±¡ï¼Œæœ€é‡è¦çš„æ˜¯ä»æ³¨è§£ä¸­è·å–è¡¨è¾¾å¼        AspectJExpressionPointcut expressionPointcut = getPointcut(                candidateAdviceMethod, aspectInstanceFactory.getAspectMetadata().getAspectClass());        if (expressionPointcut == null) {            return null;        }        //åˆ›å»ºAdvisoråˆ‡é¢ç±»ï¼Œè¿™æ‰æ˜¯çœŸæ­£çš„åˆ‡é¢ç±»ï¼Œä¸€ä¸ªåˆ‡é¢ç±»é‡Œé¢è‚¯å®šè¦æœ‰1ã€pointCut 2ã€advice        //è¿™é‡ŒpointCutæ˜¯expressionPointcutï¼Œ advice å¢å¼ºæ–¹æ³•æ˜¯ candidateAdviceMethod        return new InstantiationModelAwarePointcutAdvisorImpl(expressionPointcut, candidateAdviceMethod,                this, aspectInstanceFactory, declarationOrderInAspect, aspectName);    }    private static final Class&lt;?&gt;[] ASPECTJ_ANNOTATION_CLASSES = new Class&lt;?&gt;[] {            Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class};    private AspectJExpressionPointcut getPointcut(Method candidateAdviceMethod, Class&lt;?&gt; candidateAspectClass) {        //ä»å€™é€‰çš„å¢å¼ºæ–¹æ³•é‡Œé¢ candidateAdviceMethod  æ‰¾æœ‰æœ‰æ³¨è§£        //Pointcut.class, Around.class, Before.class, After.class, AfterReturning.class, AfterThrowing.class        //å¹¶æŠŠæ³¨è§£ä¿¡æ¯å°è£…æˆAspectJAnnotationå¯¹è±¡        AspectJAnnotation&lt;?&gt; aspectJAnnotation =                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        if (aspectJAnnotation == null) {            return null;        }        //åˆ›å»ºä¸€ä¸ªPointCutç±»ï¼Œå¹¶ä¸”æŠŠå‰é¢ä»æ³¨è§£é‡Œé¢è§£æçš„è¡¨è¾¾å¼è®¾ç½®è¿›å»        AspectJExpressionPointcut ajexp =                new AspectJExpressionPointcut(candidateAspectClass, new String[0], new Class&lt;?&gt;[0]);        ajexp.setExpression(aspectJAnnotation.getPointcutExpression());        if (this.beanFactory != null) {            ajexp.setBeanFactory(this.beanFactory);        }        return ajexp;    }</code></pre><p>ä¹‹å‰å°±è¯´è¿‡<strong>åˆ‡é¢</strong>çš„å®šä¹‰ï¼Œæ˜¯åˆ‡ç‚¹å’Œå¢å¼ºçš„ç»„åˆï¼Œæ‰€ä»¥è¿™é‡Œé¦–å…ˆé€šè¿‡<strong>getPointcut</strong>è·å–åˆ°æ³¨è§£å¯¹è±¡ï¼Œç„¶ånewäº†ä¸€ä¸ªPointcutå¯¹è±¡ï¼Œå¹¶å°†è¡¨è¾¾å¼è®¾ç½®è¿›å»ã€‚ç„¶ååœ¨<strong>getAdvisor</strong>æ–¹æ³•ä¸­æœ€ånewäº†ä¸€ä¸ª<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>å¯¹è±¡ï¼š</p><pre><code>    public InstantiationModelAwarePointcutAdvisorImpl(AspectJExpressionPointcut declaredPointcut,            Method aspectJAdviceMethod, AspectJAdvisorFactory aspectJAdvisorFactory,            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {        this.declaredPointcut = declaredPointcut;        this.declaringClass = aspectJAdviceMethod.getDeclaringClass();        this.methodName = aspectJAdviceMethod.getName();        this.parameterTypes = aspectJAdviceMethod.getParameterTypes();        this.aspectJAdviceMethod = aspectJAdviceMethod;        this.aspectJAdvisorFactory = aspectJAdvisorFactory;        this.aspectInstanceFactory = aspectInstanceFactory;        this.declarationOrder = declarationOrder;        this.aspectName = aspectName;        if (aspectInstanceFactory.getAspectMetadata().isLazilyInstantiated()) {            // Static part of the pointcut is a lazy type.            Pointcut preInstantiationPointcut = Pointcuts.union(                    aspectInstanceFactory.getAspectMetadata().getPerClausePointcut(), this.declaredPointcut);            // Make it dynamic: must mutate from pre-instantiation to post-instantiation state.            // If it's not a dynamic pointcut, it may be optimized out            // by the Spring AOP infrastructure after the first evaluation.            this.pointcut = new PerTargetInstantiationModelPointcut(                    this.declaredPointcut, preInstantiationPointcut, aspectInstanceFactory);            this.lazy = true;        }        else {            // A singleton aspect.            this.pointcut = this.declaredPointcut;            this.lazy = false;            //è¿™ä¸ªæ–¹æ³•é‡ç‚¹çœ‹çœ‹ï¼Œåˆ›å»ºadviceå¯¹è±¡            this.instantiatedAdvice = instantiateAdvice(this.declaredPointcut);        }    }</code></pre><p>è¿™ä¸ªå°±æ˜¯æˆ‘ä»¬çš„åˆ‡é¢ç±»ï¼Œåœ¨å…¶æ„é€ æ–¹æ³•çš„æœ€åé€šè¿‡<strong>instantiateAdvice</strong>åˆ›å»ºäº†<strong>Advice</strong>å¯¹è±¡ã€‚æ³¨æ„è¿™é‡Œä¼ è¿›æ¥çš„<strong>declarationOrder</strong>å‚æ•°ï¼Œå®ƒå°±æ˜¯å¾ªç¯methodæ—¶çš„åºå·ï¼Œå…¶ä½œç”¨å°±æ˜¯èµ‹å€¼ç»™è¿™é‡Œçš„<strong>declarationOrder</strong>å±æ€§ä»¥åŠAdviceçš„<strong>declarationOrder</strong>å±æ€§ï¼Œåœ¨åé¢æ’åºæ—¶å°±ä¼šé€šè¿‡è¿™ä¸ªåºå·æ¥æ¯”è¾ƒï¼Œå› æ­¤Adviceçš„æ‰§è¡Œé¡ºåºæ˜¯<strong>å›ºå®š</strong>çš„ï¼Œè‡³äºä¸ºä»€ä¹ˆè¦å›ºå®šï¼Œåé¢åˆ†æå®ŒAOPé“¾å¼è°ƒç”¨è¿‡ç¨‹è‡ªç„¶å°±æ˜ç™½äº†ã€‚</p><pre><code>    public Advice getAdvice(Method candidateAdviceMethod, AspectJExpressionPointcut expressionPointcut,            MetadataAwareAspectInstanceFactory aspectInstanceFactory, int declarationOrder, String aspectName) {        //è·å–æœ‰@Aspectæ³¨è§£çš„ç±»        Class&lt;?&gt; candidateAspectClass = aspectInstanceFactory.getAspectMetadata().getAspectClass();        validate(candidateAspectClass);        //æ‰¾åˆ°candidateAdviceMethodæ–¹æ³•ä¸Šé¢çš„æ³¨è§£ï¼Œå¹¶ä¸”åŒ…è£…æˆAspectJAnnotationå¯¹è±¡ï¼Œè¿™ä¸ªå¯¹è±¡ä¸­å°±æœ‰æ³¨è§£ç±»å‹        AspectJAnnotation&lt;?&gt; aspectJAnnotation =                AbstractAspectJAdvisorFactory.findAspectJAnnotationOnMethod(candidateAdviceMethod);        if (aspectJAnnotation == null) {            return null;        }        AbstractAspectJAdvice springAdvice;        //æ ¹æ®ä¸åŒçš„æ³¨è§£ç±»å‹åˆ›å»ºä¸åŒçš„adviceç±»å®ä¾‹        switch (aspectJAnnotation.getAnnotationType()) {            case AtPointcut:                if (logger.isDebugEnabled()) {                    logger.debug("Processing pointcut '" + candidateAdviceMethod.getName() + "'");                }                return null;            case AtAround:                //å®ç°äº†MethodInterceptoræ¥å£                springAdvice = new AspectJAroundAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtBefore:                //å®ç°äº†MethodBeforeAdviceæ¥å£ï¼Œæ²¡æœ‰å®ç°MethodInterceptoræ¥å£                springAdvice = new AspectJMethodBeforeAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtAfter:                //å®ç°äº†MethodInterceptoræ¥å£                springAdvice = new AspectJAfterAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                break;            case AtAfterReturning:                //å®ç°äº†AfterReturningAdviceæ¥å£ï¼Œæ²¡æœ‰å®ç°MethodInterceptoræ¥å£                springAdvice = new AspectJAfterReturningAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                AfterReturning afterReturningAnnotation = (AfterReturning) aspectJAnnotation.getAnnotation();                if (StringUtils.hasText(afterReturningAnnotation.returning())) {                    springAdvice.setReturningName(afterReturningAnnotation.returning());                }                break;            case AtAfterThrowing:                //å®ç°äº†MethodInterceptoræ¥å£                springAdvice = new AspectJAfterThrowingAdvice(                        candidateAdviceMethod, expressionPointcut, aspectInstanceFactory);                AfterThrowing afterThrowingAnnotation = (AfterThrowing) aspectJAnnotation.getAnnotation();                if (StringUtils.hasText(afterThrowingAnnotation.throwing())) {                    springAdvice.setThrowingName(afterThrowingAnnotation.throwing());                }                break;            default:                throw new UnsupportedOperationException(                        "Unsupported advice type on method: " + candidateAdviceMethod);        }        // Now to configure the advice...        springAdvice.setAspectName(aspectName);        springAdvice.setDeclarationOrder(declarationOrder);        String[] argNames = this.parameterNameDiscoverer.getParameterNames(candidateAdviceMethod);        if (argNames != null) {            springAdvice.setArgumentNamesFromStringArray(argNames);        }        //è®¡ç®—argNameså’Œç±»å‹çš„å¯¹åº”å…³ç³»        springAdvice.calculateArgumentBindings();        return springAdvice;    }</code></pre><p>è¿™é‡Œé€»è¾‘å¾ˆæ¸…æ™°ï¼Œå°±æ˜¯æ‹¿åˆ°æ–¹æ³•ä¸Šçš„æ³¨è§£ç±»å‹ï¼Œæ ¹æ®ç±»å‹åˆ›å»ºä¸åŒçš„å¢å¼ºAdviceå¯¹è±¡ï¼šAspectJAroundAdviceã€AspectJMethodBeforeAdviceã€AspectJAfterAdviceã€AspectJAfterReturningAdviceã€AspectJAfterThrowingAdviceã€‚å®Œæˆä¹‹åé€šè¿‡<strong>calculateArgumentBindings</strong>æ–¹æ³•è¿›è¡Œå‚æ•°ç»‘å®šï¼Œæ„Ÿå…´è¶£çš„å¯è‡ªè¡Œç ”ç©¶ã€‚è¿™é‡Œä¸»è¦çœ‹çœ‹å‡ ä¸ªAdviceçš„ç»§æ‰¿ä½“ç³»ï¼š</p><div class=pgc-img><img alt=è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1c7c82fff674a01b49573f34eb5dc1b><p class=pgc-img-caption></p></div><p>å¯ä»¥çœ‹åˆ°æœ‰ä¸¤ä¸ªAdviceæ˜¯æ²¡æœ‰å®ç°<strong>MethodInterceptor</strong>æ¥å£çš„ï¼šAspectJMethodBeforeAdviceå’ŒAspectJAfterReturningAdviceã€‚è€Œ<strong>MethodInterceptor</strong>æœ‰ä¸€ä¸ª<strong>invoke</strong>æ–¹æ³•ï¼Œè¿™ä¸ªæ–¹æ³•å°±æ˜¯<strong>é“¾å¼è°ƒç”¨</strong>çš„æ ¸å¿ƒæ–¹æ³•ï¼Œä½†é‚£ä¸¤ä¸ªæ²¡æœ‰å®ç°è¯¥æ–¹æ³•çš„Adviceæ€ä¹ˆå¤„ç†å‘¢ï¼Ÿç¨åä¼šåˆ†æã€‚åˆ°è¿™é‡Œåˆ‡é¢å¯¹è±¡å°±åˆ›å»ºå®Œæˆäº†ï¼Œæ¥ä¸‹æ¥å°±æ˜¯åˆ¤æ–­å½“å‰åˆ›å»ºçš„Beanå®ä¾‹æ˜¯å¦å’Œè¿™äº›åˆ‡é¢åŒ¹é…ä»¥åŠå¯¹<strong>åˆ‡é¢</strong>æ’åºã€‚åŒ¹é…è¿‡ç¨‹æ¯”è¾ƒå¤æ‚ï¼Œå¯¹ç†è§£ä¸»æµç¨‹ä¹Ÿæ²¡ä»€ä¹ˆå¸®åŠ©ï¼Œæ‰€ä»¥è¿™é‡Œå°±ä¸å±•å¼€åˆ†æï¼Œæ„Ÿå…´è¶£çš„è‡ªè¡Œåˆ†æï¼ˆAbstractAdvisorAutoProxyCreator.findAdvisorsThatCanApply()ï¼‰ã€‚ä¸‹é¢çœ‹çœ‹æ’åºçš„è¿‡ç¨‹ï¼Œå›åˆ°AbstractAdvisorAutoProxyCreator.findEligibleAdvisorsæ–¹æ³•ï¼š</p><pre><code>    protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {        //æ‰¾åˆ°å€™é€‰çš„åˆ‡é¢,å…¶å®å°±æ˜¯ä¸€ä¸ªå¯»æ‰¾æœ‰@Aspectjæ³¨è§£çš„è¿‡ç¨‹ï¼ŒæŠŠå·¥ç¨‹ä¸­æ‰€æœ‰æœ‰è¿™ä¸ªæ³¨è§£çš„ç±»å°è£…æˆAdvisorè¿”å›        List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();        //åˆ¤æ–­å€™é€‰çš„åˆ‡é¢æ˜¯å¦ä½œç”¨åœ¨å½“å‰beanClassä¸Šé¢ï¼Œå°±æ˜¯ä¸€ä¸ªåŒ¹é…è¿‡ç¨‹ã€‚ã€‚ç°åœ¨å°±æ˜¯ä¸€ä¸ªåŒ¹é…        List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);        extendAdvisors(eligibleAdvisors);        if (!eligibleAdvisors.isEmpty()) {            //å¯¹æœ‰@Order@Priorityè¿›è¡Œæ’åº            eligibleAdvisors = sortAdvisors(eligibleAdvisors);        }        return eligibleAdvisors;    }</code></pre><p><strong>sortAdvisors</strong>æ–¹æ³•å°±æ˜¯æ’åºï¼Œä½†è¿™ä¸ªæ–¹æ³•æœ‰ä¸¤ä¸ªå®ç°ï¼šå½“å‰ç±»<strong>AbstractAdvisorAutoProxyCreator</strong>å’Œå­ç±»<strong>AspectJAwareAdvisorAutoProxyCreator</strong>ï¼Œåº”è¯¥èµ°å“ªä¸ªå‘¢ï¼Ÿ</p><div class=pgc-img><img alt=è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/419537d02465492990aed14903ddda42><p class=pgc-img-caption></p></div><p>é€šè¿‡ç±»å›¾æˆ‘ä»¬å¯ä»¥è‚¯å®šæ˜¯è¿›å…¥çš„<strong>AspectJAwareAdvisorAutoProxyCreator</strong>ç±»ï¼Œå› ä¸º<strong>AnnotationAwareAspectJAutoProxyCreator</strong>çš„çˆ¶ç±»æ˜¯å®ƒã€‚</p><pre><code>    protected List&lt;Advisor&gt; sortAdvisors(List&lt;Advisor&gt; advisors) {        List&lt;PartiallyComparableAdvisorHolder&gt; partiallyComparableAdvisors = new ArrayList&lt;&gt;(advisors.size());        for (Advisor element : advisors) {            partiallyComparableAdvisors.add(                    new PartiallyComparableAdvisorHolder(element, DEFAULT_PRECEDENCE_COMPARATOR));        }        List&lt;PartiallyComparableAdvisorHolder&gt; sorted = PartialOrder.sort(partiallyComparableAdvisors);        if (sorted != null) {            List&lt;Advisor&gt; result = new ArrayList&lt;&gt;(advisors.size());            for (PartiallyComparableAdvisorHolder pcAdvisor : sorted) {                result.add(pcAdvisor.getAdvisor());            }            return result;        }        else {            return super.sortAdvisors(advisors);        }    }</code></pre><p>è¿™é‡Œæ’åºä¸»è¦æ˜¯å§”æ‰˜ç»™<strong>PartialOrder</strong>è¿›è¡Œçš„ï¼Œè€Œåœ¨æ­¤ä¹‹å‰å°†æ‰€æœ‰çš„åˆ‡é¢éƒ½å°è£…æˆäº†<strong>PartiallyComparableAdvisorHolder</strong>å¯¹è±¡ï¼Œæ³¨æ„ä¼ å…¥çš„<strong>DEFAULT_PRECEDENCE_COMPARATOR</strong>å‚æ•°ï¼Œè¿™ä¸ªå°±æ˜¯æ¯”è¾ƒå™¨å¯¹è±¡ï¼š</p><pre><code>    private static final Comparator&lt;Advisor&gt; DEFAULT_PRECEDENCE_COMPARATOR = new AspectJPrecedenceComparator();</code></pre><p>æ‰€ä»¥æˆ‘ä»¬ç›´æ¥çœ‹è¿™ä¸ªæ¯”è¾ƒå™¨çš„<strong>compare</strong>æ–¹æ³•ï¼š</p><pre><code>    public int compare(Advisor o1, Advisor o2) {        int advisorPrecedence = this.advisorComparator.compare(o1, o2);        if (advisorPrecedence == SAME_PRECEDENCE &amp;&amp; declaredInSameAspect(o1, o2)) {            advisorPrecedence = comparePrecedenceWithinAspect(o1, o2);        }        return advisorPrecedence;    }    private final Comparator&lt;? super Advisor&gt; advisorComparator;    public AspectJPrecedenceComparator() {        this.advisorComparator = AnnotationAwareOrderComparator.INSTANCE;    }</code></pre><p>ç¬¬ä¸€æ­¥å…ˆé€šè¿‡<strong>AnnotationAwareOrderComparator</strong>å»æ¯”è¾ƒï¼Œç‚¹è¿›å»çœ‹å¯ä»¥å‘ç°æ˜¯å¯¹å®ç°äº†<strong>PriorityOrdered</strong>å’Œ<strong>Ordered</strong>æ¥å£ä»¥åŠæ ‡è®°äº†<strong>Priority</strong>å’Œ<strong>Order</strong>æ³¨è§£çš„<strong>éåŒä¸€ä¸ª@Aspectç±»ä¸­çš„åˆ‡é¢</strong>è¿›è¡Œæ’åºã€‚è¿™ä¸ªå’Œä¹‹å‰åˆ†æ<strong>BeanFacotryPostProcessor</strong>ç±»æ˜¯ä¸€æ ·çš„åŸç†ã€‚è€Œå¯¹<strong>åŒä¸€ä¸ª@Aspectç±»ä¸­çš„åˆ‡é¢</strong>æ’åºä¸»è¦æ˜¯<strong>comparePrecedenceWithinAspect</strong>æ–¹æ³•ï¼š</p><pre><code>    private int comparePrecedenceWithinAspect(Advisor advisor1, Advisor advisor2) {        boolean oneOrOtherIsAfterAdvice =                (AspectJAopUtils.isAfterAdvice(advisor1) || AspectJAopUtils.isAfterAdvice(advisor2));        int adviceDeclarationOrderDelta = getAspectDeclarationOrder(advisor1) - getAspectDeclarationOrder(advisor2);        if (oneOrOtherIsAfterAdvice) {            // the advice declared last has higher precedence            if (adviceDeclarationOrderDelta &lt; 0) {                // advice1 was declared before advice2                // so advice1 has lower precedence                return LOWER_PRECEDENCE;            }            else if (adviceDeclarationOrderDelta == 0) {                return SAME_PRECEDENCE;            }            else {                return HIGHER_PRECEDENCE;            }        }        else {            // the advice declared first has higher precedence            if (adviceDeclarationOrderDelta &lt; 0) {                // advice1 was declared before advice2                // so advice1 has higher precedence                return HIGHER_PRECEDENCE;            }            else if (adviceDeclarationOrderDelta == 0) {                return SAME_PRECEDENCE;            }            else {                return LOWER_PRECEDENCE;            }        }    }    private int getAspectDeclarationOrder(Advisor anAdvisor) {        AspectJPrecedenceInformation precedenceInfo =            AspectJAopUtils.getAspectJPrecedenceInformationFor(anAdvisor);        if (precedenceInfo != null) {            return precedenceInfo.getDeclarationOrder();        }        else {            return 0;        }    }</code></pre><p>è¿™é‡Œå°±æ˜¯é€šè¿‡<strong>precedenceInfo.getDeclarationOrder</strong>æ‹¿åˆ°åœ¨åˆ›å»º<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>å¯¹è±¡æ—¶è®¾ç½®çš„<strong>declarationOrder</strong>å±æ€§ï¼Œè¿™å°±éªŒè¯äº†ä¹‹å‰çš„è¯´æ³•ï¼ˆå®é™…ä¸Šè¿™é‡Œæ’åºè¿‡ç¨‹éå¸¸å¤æ‚ï¼Œä¸æ˜¯ç®€å•çš„æŒ‰ç…§è¿™ä¸ªå±æ€§è¿›è¡Œæ’åºï¼‰ã€‚å½“ä¸Šé¢çš„ä¸€åˆ‡éƒ½è¿›è¡Œå®Œæˆåï¼Œå°±è¯¥åˆ›å»ºä»£ç†å¯¹è±¡äº†ï¼Œå›åˆ°<strong>AbstractAutoProxyCreator.wrapIfNecessary</strong>ï¼Œçœ‹å…³é”®éƒ¨åˆ†ä»£ç ï¼š</p><pre><code>    //å¦‚æœæœ‰åˆ‡é¢ï¼Œåˆ™ç”Ÿæˆè¯¥beançš„ä»£ç†    if (specificInterceptors != DO_NOT_PROXY) {        this.advisedBeans.put(cacheKey, Boolean.TRUE);        //æŠŠè¢«ä»£ç†å¯¹è±¡beanå®ä¾‹å°è£…åˆ°SingletonTargetSourceå¯¹è±¡ä¸­        Object proxy = createProxy(                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));        this.proxyTypes.put(cacheKey, proxy.getClass());        return proxy;    }</code></pre><p>æ³¨æ„è¿™é‡Œå°†è¢«ä»£ç†å¯¹è±¡å°è£…æˆäº†ä¸€ä¸ª<strong>SingletonTargetSource</strong>å¯¹è±¡ï¼Œå®ƒæ˜¯<strong>TargetSource</strong>çš„å®ç°ç±»ã€‚</p><pre><code>    protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,            @Nullable Object[] specificInterceptors, TargetSource targetSource) {        if (this.beanFactory instanceof ConfigurableListableBeanFactory) {            AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);        }        //åˆ›å»ºä»£ç†å·¥å‚        ProxyFactory proxyFactory = new ProxyFactory();        proxyFactory.copyFrom(this);        if (!proxyFactory.isProxyTargetClass()) {            if (shouldProxyTargetClass(beanClass, beanName)) {                //proxyTargetClass æ˜¯å¦å¯¹ç±»è¿›è¡Œä»£ç†ï¼Œè€Œä¸æ˜¯å¯¹æ¥å£è¿›è¡Œä»£ç†ï¼Œè®¾ç½®ä¸ºtrueæ—¶ï¼Œä½¿ç”¨CGLibä»£ç†ã€‚                proxyFactory.setProxyTargetClass(true);            }            else {                evaluateProxyInterfaces(beanClass, proxyFactory);            }        }        //æŠŠadviceç±»å‹çš„å¢å¼ºåŒ…è£…æˆadvisoråˆ‡é¢        Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);        proxyFactory.addAdvisors(advisors);        proxyFactory.setTargetSource(targetSource);        customizeProxyFactory(proxyFactory);        ////ç”¨æ¥æ§åˆ¶ä»£ç†å·¥å‚è¢«é…ç½®åï¼Œæ˜¯å¦è¿˜å…è®¸ä¿®æ”¹ä»£ç†çš„é…ç½®,é»˜è®¤ä¸ºfalse        proxyFactory.setFrozen(this.freezeProxy);        if (advisorsPreFiltered()) {            proxyFactory.setPreFiltered(true);        }        //è·å–ä»£ç†å®ä¾‹        return proxyFactory.getProxy(getProxyClassLoader());    }</code></pre><p>è¿™é‡Œé€šè¿‡<strong>ProxyFactory</strong>å¯¹è±¡å»åˆ›å»ºä»£ç†å®ä¾‹ï¼Œè¿™æ˜¯<strong>å·¥å‚æ¨¡å¼</strong>çš„ä½“ç°ï¼Œä½†åœ¨åˆ›å»ºä»£ç†å¯¹è±¡ä¹‹å‰è¿˜æœ‰å‡ ä¸ªå‡†å¤‡åŠ¨ä½œï¼šéœ€è¦åˆ¤æ–­æ˜¯JDKä»£ç†è¿˜æ˜¯CGLIBä»£ç†ä»¥åŠé€šè¿‡<strong>buildAdvisors</strong>æ–¹æ³•å°†æ‰©å±•çš„<strong>Advice</strong>å°è£…æˆ<strong>Advisor</strong>åˆ‡é¢ã€‚å‡†å¤‡å®Œæˆåˆ™é€šè¿‡<strong>getProxy</strong>åˆ›å»ºä»£ç†å¯¹è±¡ï¼š</p><pre><code>    public Object getProxy(@Nullable ClassLoader classLoader) {        //æ ¹æ®ç›®æ ‡å¯¹è±¡æ˜¯å¦æœ‰æ¥å£æ¥åˆ¤æ–­é‡‡ç”¨ä»€ä¹ˆä»£ç†æ–¹å¼ï¼Œcglibä»£ç†è¿˜æ˜¯jdkåŠ¨æ€ä»£ç†        return createAopProxy().getProxy(classLoader);    }    protected final synchronized AopProxy createAopProxy() {        if (!this.active) {            activate();        }        return getAopProxyFactory().createAopProxy(this);    }    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {        if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {            Class&lt;?&gt; targetClass = config.getTargetClass();            if (targetClass == null) {                throw new AopConfigException("TargetSource cannot determine target class: " +                        "Either an interface or a target is required for proxy creation.");            }            if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {                return new JdkDynamicAopProxy(config);            }            return new ObjenesisCglibAopProxy(config);        }        else {            return new JdkDynamicAopProxy(config);        }    }</code></pre><p>é¦–å…ˆé€šè¿‡é…ç½®æ‹¿åˆ°å¯¹åº”çš„ä»£ç†ç±»ï¼šObjenesisCglibAopProxyå’ŒJdkDynamicAopProxyï¼Œç„¶åå†é€šè¿‡<strong>getProxy</strong>åˆ›å»ºBeançš„ä»£ç†ï¼Œè¿™é‡Œä»¥<strong>JdkDynamicAopProxy</strong>ä¸ºä¾‹ï¼š</p><pre><code>    public Object getProxy(@Nullable ClassLoader classLoader) {        //advisedæ˜¯ä»£ç†å·¥å‚å¯¹è±¡        Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);        findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);        return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);    }</code></pre><p>è¿™é‡Œçš„ä»£ç ä½ åº”è¯¥ä¸é™Œç”Ÿäº†ï¼Œå°±æ˜¯JDKçš„åŸç”ŸAPIï¼Œ<strong>newProxyInstance</strong>æ–¹æ³•ä¼ å…¥çš„<strong>InvocationHandler</strong>å¯¹è±¡æ˜¯<strong>this</strong>ï¼Œå› æ­¤ï¼Œæœ€ç»ˆAOPä»£ç†çš„è°ƒç”¨å°±æ˜¯ä»è¯¥ç±»ä¸­çš„<strong>invoke</strong>æ–¹æ³•å¼€å§‹ã€‚è‡³æ­¤ï¼Œä»£ç†å¯¹è±¡çš„åˆ›å»ºå°±å®Œæˆäº†ï¼Œä¸‹é¢æ¥çœ‹ä¸‹æ•´ä¸ªè¿‡ç¨‹çš„æ—¶åºå›¾ï¼š</p><div class=pgc-img><img alt=è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/692f7c1d1455426a8f4b2c6d119f7d0c><p class=pgc-img-caption></p></div><h2 class=line>å°ç»“</h2><p>ä»£ç†å¯¹è±¡çš„åˆ›å»ºè¿‡ç¨‹æ•´ä½“æ¥è¯´å¹¶ä¸å¤æ‚ï¼Œé¦–å…ˆæ‰¾åˆ°æ‰€æœ‰å¸¦æœ‰@Aspectæ³¨è§£çš„ç±»ï¼Œå¹¶è·å–å…¶ä¸­æ²¡æœ‰@Pointcutæ³¨è§£çš„æ–¹æ³•ï¼Œå¾ªç¯åˆ›å»ºåˆ‡é¢ï¼Œè€Œåˆ›å»ºåˆ‡é¢éœ€è¦<strong>åˆ‡ç‚¹</strong>å’Œ<strong>å¢å¼º</strong>ä¸¤ä¸ªå…ƒç´ ï¼Œå…¶ä¸­åˆ‡ç‚¹å¯ç®€å•ç†è§£ä¸ºæˆ‘ä»¬å†™çš„è¡¨è¾¾å¼ï¼Œå¢å¼ºåˆ™æ˜¯æ ¹æ®@Beforeã€@Aroundã€@Afterç­‰æ³¨è§£åˆ›å»ºçš„å¯¹åº”çš„Adviceç±»ã€‚åˆ‡é¢åˆ›å»ºå¥½ååˆ™éœ€è¦å¾ªç¯åˆ¤æ–­å“ªäº›åˆ‡é¢èƒ½å¯¹å½“å‰çš„Beanå®ä¾‹çš„æ–¹æ³•è¿›è¡Œå¢å¼ºå¹¶æ’åºï¼Œæœ€åé€šè¿‡ProxyFactoryåˆ›å»ºä»£ç†å¯¹è±¡ã€‚</p><h2 class=line>AOPé“¾å¼è°ƒç”¨</h2><p>ç†Ÿæ‚‰JDKåŠ¨æ€ä»£ç†çš„éƒ½çŸ¥é“é€šè¿‡ä»£ç†å¯¹è±¡è°ƒç”¨æ–¹æ³•æ—¶ï¼Œä¼šè¿›å…¥åˆ°<strong>InvocationHandler</strong>å¯¹è±¡çš„<strong>invoke</strong>æ–¹æ³•ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥ä»<strong>JdkDynamicAopProxy</strong>çš„è¿™ä¸ªæ–¹æ³•å¼€å§‹ï¼š</p><pre><code>    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        MethodInvocation invocation;        Object oldProxy = null;        boolean setProxyContext = false;        //ä»ä»£ç†å·¥å‚ä¸­æ‹¿åˆ°TargetSourceå¯¹è±¡ï¼Œè¯¥å¯¹è±¡åŒ…è£…äº†è¢«ä»£ç†å®ä¾‹bean        TargetSource targetSource = this.advised.targetSource;        Object target = null;        try {            //è¢«ä»£ç†å¯¹è±¡çš„equalsæ–¹æ³•å’ŒhashCodeæ–¹æ³•æ˜¯ä¸èƒ½è¢«ä»£ç†çš„ï¼Œä¸ä¼šèµ°åˆ‡é¢            .......            Object retVal;            // å¯ä»¥ä»å½“å‰çº¿ç¨‹ä¸­æ‹¿åˆ°ä»£ç†å¯¹è±¡            if (this.advised.exposeProxy) {                // Make invocation available if necessary.                oldProxy = AopContext.setCurrentProxy(proxy);                setProxyContext = true;            }            //è¿™ä¸ªtargetå°±æ˜¯è¢«ä»£ç†å®ä¾‹            target = targetSource.getTarget();            Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);            //ä»ä»£ç†å·¥å‚ä¸­æ‹¿è¿‡æ»¤å™¨é“¾ Objectæ˜¯ä¸€ä¸ªMethodInterceptorç±»å‹çš„å¯¹è±¡ï¼Œå…¶å®å°±æ˜¯ä¸€ä¸ªadviceå¯¹è±¡            List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);            //å¦‚æœè¯¥æ–¹æ³•æ²¡æœ‰æ‰§è¡Œé“¾ï¼Œåˆ™è¯´æ˜è¿™ä¸ªæ–¹æ³•ä¸éœ€è¦è¢«æ‹¦æˆªï¼Œåˆ™ç›´æ¥åå°„è°ƒç”¨            if (chain.isEmpty()) {                Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);                retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);            }            else {                invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);                retVal = invocation.proceed();            }            // Massage return value if necessary.            Class&lt;?&gt; returnType = method.getReturnType();            if (retVal != null &amp;&amp; retVal == target &amp;&amp;                    returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;                    !RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {                retVal = proxy;            }            return retVal;        }        finally {            if (target != null &amp;&amp; !targetSource.isStatic()) {                // Must have come from TargetSource.                targetSource.releaseTarget(target);            }            if (setProxyContext) {                // Restore old proxy.                AopContext.setCurrentProxy(oldProxy);            }        }    }</code></pre><p>è¿™æ®µä»£ç æ¯”è¾ƒé•¿ï¼Œæˆ‘åˆ æ‰äº†ä¸å…³é”®çš„åœ°æ–¹ã€‚é¦–å…ˆæ¥çœ‹<strong>this.advised.exposeProxy</strong>è¿™ä¸ªå±æ€§ï¼Œè¿™åœ¨@EnableAspectJAutoProxyæ³¨è§£ä¸­å¯ä»¥é…ç½®ï¼Œå½“ä¸ºtrueæ—¶ï¼Œä¼šå°†è¯¥ä»£ç†å¯¹è±¡è®¾ç½®åˆ°<strong>å½“å‰çº¿ç¨‹çš„ThreadLocalå¯¹è±¡</strong>ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥é€šè¿‡<strong>AopContext.currentProxy</strong>æ‹¿åˆ°ä»£ç†å¯¹è±¡ã€‚è¿™ä¸ªæœ‰ä»€ä¹ˆç”¨å‘¢ï¼Ÿæˆ‘ç›¸ä¿¡æœ‰ç»éªŒçš„Javaå¼€å‘éƒ½é‡åˆ°è¿‡è¿™æ ·ä¸€ä¸ªBUGï¼Œåœ¨Serviceå®ç°ç±»ä¸­è°ƒç”¨æœ¬ç±»ä¸­çš„å¦ä¸€ä¸ªæ–¹æ³•æ—¶ï¼Œäº‹åŠ¡ä¸ä¼šç”Ÿæ•ˆï¼Œè¿™æ˜¯å› ä¸ºç›´æ¥é€šè¿‡thisè°ƒç”¨å°±ä¸ä¼šè°ƒç”¨åˆ°ä»£ç†å¯¹è±¡çš„æ–¹æ³•ï¼Œè€Œæ˜¯åŸå¯¹è±¡çš„ï¼Œæ‰€ä»¥äº‹åŠ¡åˆ‡é¢å°±æ²¡æœ‰ç”Ÿæ•ˆã€‚å› æ­¤è¿™ç§æƒ…å†µä¸‹å°±å¯ä»¥ä»<strong>å½“å‰çº¿ç¨‹çš„ThreadLocalå¯¹è±¡</strong>æ‹¿åˆ°ä»£ç†å¯¹è±¡ï¼Œä¸è¿‡å®é™…ä¸Šç›´æ¥ä½¿ç”¨@Autowiredæ³¨å…¥è‡ªå·±æœ¬èº«ä¹Ÿå¯ä»¥æ‹¿åˆ°ä»£ç†å¯¹è±¡ã€‚æ¥ä¸‹æ¥å°±æ˜¯é€šè¿‡<strong>getInterceptorsAndDynamicInterceptionAdvice</strong>æ‹¿åˆ°æ‰§è¡Œé“¾ï¼Œçœ‹çœ‹å…·ä½“åšäº†å“ªäº›äº‹æƒ…ï¼š</p><pre><code>    public List&lt;Object&gt; getInterceptorsAndDynamicInterceptionAdvice(            Advised config, Method method, @Nullable Class&lt;?&gt; targetClass) {        AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();        //ä»ä»£ç†å·¥å‚ä¸­è·å¾—è¯¥è¢«ä»£ç†ç±»çš„æ‰€æœ‰åˆ‡é¢advisorï¼Œconfigå°±æ˜¯ä»£ç†å·¥å‚å¯¹è±¡        Advisor[] advisors = config.getAdvisors();        List&lt;Object&gt; interceptorList = new ArrayList&lt;&gt;(advisors.length);        Class&lt;?&gt; actualClass = (targetClass != null ? targetClass : method.getDeclaringClass());        Boolean hasIntroductions = null;        for (Advisor advisor : advisors) {            //å¤§éƒ¨åˆ†èµ°è¿™é‡Œ            if (advisor instanceof PointcutAdvisor) {                // Add it conditionally.                PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;                //å¦‚æœåˆ‡é¢çš„pointCutå’Œè¢«ä»£ç†å¯¹è±¡æ˜¯åŒ¹é…çš„ï¼Œè¯´æ˜æ˜¯åˆ‡é¢è¦æ‹¦æˆªçš„å¯¹è±¡                if (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) {                    MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();                    boolean match;                    if (mm instanceof IntroductionAwareMethodMatcher) {                        if (hasIntroductions == null) {                            hasIntroductions = hasMatchingIntroductions(advisors, actualClass);                        }                        match = ((IntroductionAwareMethodMatcher) mm).matches(method, actualClass, hasIntroductions);                    }                    else {                        //æ¥ä¸‹æ¥åˆ¤æ–­æ–¹æ³•æ˜¯å¦æ˜¯åˆ‡é¢pointcutéœ€è¦æ‹¦æˆªçš„æ–¹æ³•                        match = mm.matches(method, actualClass);                    }                    //å¦‚æœç±»å’Œæ–¹æ³•éƒ½åŒ¹é…                    if (match) {                        //è·å–åˆ°åˆ‡é¢advisorä¸­çš„adviceï¼Œå¹¶ä¸”åŒ…è£…æˆMethodInterceptorç±»å‹çš„å¯¹è±¡                        MethodInterceptor[] interceptors = registry.getInterceptors(advisor);                        if (mm.isRuntime()) {                            for (MethodInterceptor interceptor : interceptors) {                                interceptorList.add(new InterceptorAndDynamicMethodMatcher(interceptor, mm));                            }                        }                        else {                            interceptorList.addAll(Arrays.asList(interceptors));                        }                    }                }            }            //å¦‚æœæ˜¯å¼•ä»‹åˆ‡é¢            else if (advisor instanceof IntroductionAdvisor) {                IntroductionAdvisor ia = (IntroductionAdvisor) advisor;                if (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) {                    Interceptor[] interceptors = registry.getInterceptors(advisor);                    interceptorList.addAll(Arrays.asList(interceptors));                }            }            else {                Interceptor[] interceptors = registry.getInterceptors(advisor);                interceptorList.addAll(Arrays.asList(interceptors));            }        }        return interceptorList;    }</code></pre><p>è¿™ä¹Ÿæ˜¯ä¸ªé•¿æ–¹æ³•ï¼Œçœ‹å…³é”®çš„éƒ¨åˆ†ï¼Œå› ä¸ºä¹‹å‰æˆ‘ä»¬åˆ›å»ºçš„åŸºæœ¬ä¸Šéƒ½æ˜¯<strong>InstantiationModelAwarePointcutAdvisorImpl</strong>å¯¹è±¡ï¼Œè¯¥ç±»æ˜¯<strong>PointcutAdvisor</strong>çš„å®ç°ç±»ï¼Œæ‰€ä»¥ä¼šè¿›å…¥ç¬¬ä¸€ä¸ªifåˆ¤æ–­é‡Œï¼Œè¿™é‡Œé¦–å…ˆè¿›è¡ŒåŒ¹é…ï¼Œçœ‹<strong>åˆ‡ç‚¹</strong>å’Œ<strong>å½“å‰å¯¹è±¡</strong>ä»¥åŠè¯¥å¯¹è±¡çš„å“ªäº›<strong>æ–¹æ³•</strong>åŒ¹é…ï¼Œå¦‚æœèƒ½åŒ¹é…ä¸Šï¼Œåˆ™è°ƒç”¨<strong>getInterceptors</strong>è·å–æ‰§è¡Œé“¾ï¼š</p><pre><code>    private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList&lt;&gt;(3);    public DefaultAdvisorAdapterRegistry() {        registerAdvisorAdapter(new MethodBeforeAdviceAdapter());        registerAdvisorAdapter(new AfterReturningAdviceAdapter());        registerAdvisorAdapter(new ThrowsAdviceAdapter());    }    public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException {        List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;&gt;(3);        Advice advice = advisor.getAdvice();        //å¦‚æœæ˜¯MethodInterceptorç±»å‹çš„ï¼Œå¦‚ï¼šAspectJAroundAdvice        //AspectJAfterAdvice        //AspectJAfterThrowingAdvice        if (advice instanceof MethodInterceptor) {            interceptors.add((MethodInterceptor) advice);        }        //å¤„ç† AspectJMethodBeforeAdvice  AspectJAfterReturningAdvice        for (AdvisorAdapter adapter : this.adapters) {            if (adapter.supportsAdvice(advice)) {                interceptors.add(adapter.getInterceptor(advisor));            }        }        if (interceptors.isEmpty()) {            throw new UnknownAdviceTypeException(advisor.getAdvice());        }        return interceptors.toArray(new MethodInterceptor[0]);    }</code></pre><p>è¿™é‡Œæˆ‘ä»¬å¯ä»¥çœ‹åˆ°å¦‚æœæ˜¯<strong>MethodInterceptor</strong>çš„å®ç°ç±»ï¼Œåˆ™ç›´æ¥æ·»åŠ åˆ°é“¾ä¸­ï¼Œå¦‚æœä¸æ˜¯ï¼Œåˆ™éœ€è¦é€šè¿‡<strong>é€‚é…å™¨</strong>å»åŒ…è£…åæ·»åŠ ï¼Œåˆšå¥½è¿™é‡Œæœ‰<strong>MethodBeforeAdviceAdapter</strong>å’Œ<strong>AfterReturningAdviceAdapter</strong>ä¸¤ä¸ªé€‚é…å™¨å¯¹åº”ä¸Šæ–‡ä¸¤ä¸ªæ²¡æœ‰å®ç°<strong>MethodInterceptor</strong>æ¥å£çš„ç±»ã€‚æœ€åå°†<strong>Interceptors</strong>è¿”å›ã€‚</p><pre><code>if (chain.isEmpty()) {    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);    retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);}else {    // We need to create a method invocation...    invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);    // Proceed to the joinpoint through the interceptor chain.    retVal = invocation.proceed();}</code></pre><p>è¿”å›åˆ°<strong>invoke</strong>æ–¹æ³•åï¼Œå¦‚æœæ‰§è¡Œé“¾ä¸ºç©ºï¼Œè¯´æ˜è¯¥æ–¹æ³•ä¸éœ€è¦è¢«å¢å¼ºï¼Œæ‰€ä»¥ç›´æ¥åå°„è°ƒç”¨åŸå¯¹è±¡çš„æ–¹æ³•ï¼ˆæ³¨æ„ä¼ å…¥çš„æ˜¯TargetSourceå°è£…çš„è¢«ä»£ç†å¯¹è±¡ï¼‰ï¼›åä¹‹ï¼Œåˆ™é€šè¿‡<strong>ReflectiveMethodInvocation</strong>ç±»è¿›è¡Œé“¾å¼è°ƒç”¨ï¼Œå…³é”®æ–¹æ³•å°±æ˜¯<strong>proceed</strong>ï¼š</p><pre><code>    private int currentInterceptorIndex = -1;    public Object proceed() throws Throwable {        //å¦‚æœæ‰§è¡Œé“¾ä¸­çš„adviceå…¨éƒ¨æ‰§è¡Œå®Œï¼Œåˆ™ç›´æ¥è°ƒç”¨joinPointæ–¹æ³•ï¼Œå°±æ˜¯è¢«ä»£ç†æ–¹æ³•        if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {            return invokeJoinpoint();        }        Object interceptorOrInterceptionAdvice =                this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);        if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {            InterceptorAndDynamicMethodMatcher dm =                    (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;            Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());            if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {                return dm.interceptor.invoke(this);            }            else {                return proceed();            }        }        else {            //è°ƒç”¨MethodInterceptorä¸­çš„invokeæ–¹æ³•            return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);        }    }</code></pre><p>è¿™ä¸ªæ–¹æ³•çš„æ ¸å¿ƒå°±åœ¨ä¸¤ä¸ªåœ°æ–¹ï¼š<strong>invokeJoinpoint</strong>å’Œ<strong>interceptorOrInterceptionAdvice.invoke(this)</strong>ã€‚å½“å¢å¼ºæ–¹æ³•è°ƒç”¨å®Œåå°±ä¼šé€šè¿‡å‰è€…è°ƒç”¨åˆ°è¢«ä»£ç†çš„æ–¹æ³•ï¼Œå¦åˆ™åˆ™æ˜¯ä¾æ¬¡è°ƒç”¨<strong>Interceptor</strong>çš„<strong>invoke</strong>æ–¹æ³•ã€‚ä¸‹é¢å°±åˆ†åˆ«çœ‹çœ‹æ¯ä¸ª<strong>Interceptor</strong>æ˜¯æ€ä¹ˆå®ç°çš„ã€‚</p><ul><li>AspectJAroundAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        if (!(mi instanceof ProxyMethodInvocation)) {            throw new IllegalStateException("MethodInvocation is not a Spring ProxyMethodInvocation: " + mi);        }        ProxyMethodInvocation pmi = (ProxyMethodInvocation) mi;        ProceedingJoinPoint pjp = lazyGetProceedingJoinPoint(pmi);        JoinPointMatch jpm = getJoinPointMatch(pmi);        return invokeAdviceMethod(pjp, jpm, null, null);    }</code></pre><ul><li>MethodBeforeAdviceInterceptor -> AspectJMethodBeforeAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        this.advice.before(mi.getMethod(), mi.getArguments(), mi.getThis());        return mi.proceed();    }    public void before(Method method, Object[] args, @Nullable Object target) throws Throwable {        invokeAdviceMethod(getJoinPointMatch(), null, null);    }</code></pre><ul><li>AspectJAfterAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        try {            return mi.proceed();        }        finally {            invokeAdviceMethod(getJoinPointMatch(), null, null);        }    }</code></pre><ul><li>AfterReturningAdviceInterceptor -> AspectJAfterReturningAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        Object retVal = mi.proceed();        this.advice.afterReturning(retVal, mi.getMethod(), mi.getArguments(), mi.getThis());        return retVal;    }    public void afterReturning(@Nullable Object returnValue, Method method, Object[] args, @Nullable Object target) throws Throwable {        if (shouldInvokeOnReturnValueOf(method, returnValue)) {            invokeAdviceMethod(getJoinPointMatch(), returnValue, null);        }    }</code></pre><ul><li>AspectJAfterThrowingAdvice</li></ul><pre><code>    public Object invoke(MethodInvocation mi) throws Throwable {        try {            return mi.proceed();        }        catch (Throwable ex) {            if (shouldInvokeOnThrowing(ex)) {                invokeAdviceMethod(getJoinPointMatch(), null, ex);            }            throw ex;        }    }</code></pre><p>è¿™é‡Œçš„è°ƒç”¨é¡ºåºæ˜¯æ€æ ·çš„å‘¢ï¼Ÿå…¶æ ¸å¿ƒå°±æ˜¯é€šè¿‡<strong>proceed</strong>æ–¹æ³•æ§åˆ¶æµç¨‹ï¼Œæ¯æ‰§è¡Œå®Œä¸€ä¸ªAdviceå°±ä¼šå›åˆ°<strong>proceed</strong>æ–¹æ³•ä¸­è°ƒç”¨ä¸‹ä¸€ä¸ªAdviceã€‚å¯ä»¥æ€è€ƒä¸€ä¸‹ï¼Œæ€ä¹ˆæ‰èƒ½è®©è°ƒç”¨ç»“æœæ»¡è¶³å¦‚ä¸‹å›¾çš„<strong>æ‰§è¡Œé¡ºåº</strong>ã€‚</p><div class=pgc-img><img alt=è¿™ä¸€æ¬¡ææ‡‚Springä»£ç†åˆ›å»º+AOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b56c9dee30924620b3ed4175efd82096><p class=pgc-img-caption></p></div><p><br></p><p>ä»¥ä¸Šå°±æ˜¯AOPçš„é“¾å¼è°ƒç”¨è¿‡ç¨‹ï¼Œä½†æ˜¯è¿™åªæ˜¯åªæœ‰ä¸€ä¸ªåˆ‡é¢ç±»çš„æƒ…å†µï¼Œå¦‚æœæœ‰å¤šä¸ª@Aspectç±»å‘¢ï¼Œè¿™ä¸ªè°ƒç”¨è¿‡ç¨‹åˆæ˜¯æ€æ ·çš„ï¼Ÿå…¶æ ¸å¿ƒæ€æƒ³å’Œâ€œæ ˆâ€ä¸€æ ·ï¼Œå°±æ˜¯â€œ<strong>å…ˆè¿›åå‡ºï¼Œåè¿›å…ˆå‡º</strong>â€ã€‚</p><h2 class=line>AOPæ‰©å±•çŸ¥è¯†</h2><h3 class=line>ä¸€ã€è‡ªå®šä¹‰å…¨å±€æ‹¦æˆªå™¨Interceptor</h3><p>åœ¨ä¸Šæ–‡åˆ›å»ºä»£ç†å¯¹è±¡çš„æ—¶å€™æœ‰è¿™æ ·ä¸€ä¸ªæ–¹æ³•ï¼š</p><pre><code>    protected Advisor[] buildAdvisors(@Nullable String beanName, @Nullable Object[] specificInterceptors) {        //è‡ªå®šä¹‰MethodInterceptor.æ‹¿åˆ°setInterceptorNamesæ–¹æ³•æ³¨å…¥çš„Interceptorå¯¹è±¡        Advisor[] commonInterceptors = resolveInterceptorNames();        List&lt;Object&gt; allInterceptors = new ArrayList&lt;&gt;();        if (specificInterceptors != null) {            allInterceptors.addAll(Arrays.asList(specificInterceptors));            if (commonInterceptors.length &gt; 0) {                if (this.applyCommonInterceptorsFirst) {                    allInterceptors.addAll(0, Arrays.asList(commonInterceptors));                }                else {                    allInterceptors.addAll(Arrays.asList(commonInterceptors));                }            }        }        Advisor[] advisors = new Advisor[allInterceptors.size()];        for (int i = 0; i &lt; allInterceptors.size(); i++) {            //å¯¹è‡ªå®šä¹‰çš„adviceè¦è¿›è¡ŒåŒ…è£…ï¼ŒæŠŠadviceåŒ…è£…æˆadvisorå¯¹è±¡ï¼Œåˆ‡é¢å¯¹è±¡            advisors[i] = this.advisorAdapterRegistry.wrap(allInterceptors.get(i));        }        return advisors;    }</code></pre><p>è¿™ä¸ªæ–¹æ³•çš„ä½œç”¨å°±åœ¨äºæˆ‘ä»¬å¯ä»¥æ‰©å±•æˆ‘ä»¬è‡ªå·±çš„Interceptorï¼Œé¦–å…ˆé€šè¿‡<strong>resolveInterceptorNames</strong>æ–¹æ³•è·å–åˆ°é€šè¿‡<strong>setInterceptorNames</strong>æ–¹æ³•è®¾ç½®çš„Interceptorï¼Œç„¶åè°ƒç”¨<strong>DefaultAdvisorAdapterRegistry.wrap</strong>æ–¹æ³•å°†å…¶åŒ…è£…ä¸º<strong>DefaultPointcutAdvisor</strong>å¯¹è±¡å¹¶è¿”å›ï¼š</p><pre><code>    public Advisor wrap(Object adviceObject) throws UnknownAdviceTypeException {        if (adviceObject instanceof Advisor) {            return (Advisor) adviceObject;        }        if (!(adviceObject instanceof Advice)) {            throw new UnknownAdviceTypeException(adviceObject);        }        Advice advice = (Advice) adviceObject;        if (advice instanceof MethodInterceptor) {            return new DefaultPointcutAdvisor(advice);        }        for (AdvisorAdapter adapter : this.adapters) {            if (adapter.supportsAdvice(advice)) {                return new DefaultPointcutAdvisor(advice);            }        }        throw new UnknownAdviceTypeException(advice);    }    public DefaultPointcutAdvisor(Advice advice) {        this(Pointcut.TRUE, advice);    }</code></pre><p>éœ€è¦æ³¨æ„<strong>DefaultPointcutAdvisor</strong>æ„é€ å™¨é‡Œé¢ä¼ å…¥äº†ä¸€ä¸ª<strong>Pointcut.TRUE</strong>ï¼Œè¡¨ç¤ºè¿™ç§æ‰©å±•çš„Interceptoræ˜¯å…¨å±€çš„æ‹¦æˆªå™¨ã€‚ä¸‹é¢æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨ï¼š</p><pre><code>public class MyMethodInterceptor implements MethodInterceptor {    @Override    public Object invoke(MethodInvocation invocation) throws Throwable {        System.out.println("è‡ªå®šä¹‰æ‹¦æˆªå™¨");        return invocation.proceed();    }}</code></pre><p>é¦–å…ˆå†™ä¸€ä¸ªç±»å®ç°<strong>MethodInterceptor æ¥å£ï¼Œåœ¨invoke</strong>æ–¹æ³•ä¸­å®ç°æˆ‘ä»¬çš„æ‹¦æˆªé€»è¾‘ï¼Œç„¶åé€šè¿‡ä¸‹é¢çš„æ–¹å¼æµ‹è¯•ï¼Œåªè¦<strong>UserService æœ‰AOPæ‹¦æˆªå°±ä¼šå‘ç°è‡ªå®šä¹‰çš„MyMethodInterceptor</strong>ä¹Ÿç”Ÿæ•ˆäº†ã€‚</p><pre><code>    public void costomInterceptorTest() {        AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);        bean.setInterceptorNames("myMethodInterceptor ");        UserService userService = applicationContext.getBean(UserService.class);        userService.queryUser("dark");    }</code></pre><p>ä½†æ˜¯å¦‚æœæ¢ä¸ªé¡ºåºï¼Œåƒä¸‹é¢è¿™æ ·ï¼š</p><pre><code>    public void costomInterceptorTest() {        UserService userService = applicationContext.getBean(UserService.class);        AnnotationAwareAspectJAutoProxyCreator bean = applicationContext.getBean(AnnotationAwareAspectJAutoProxyCreator.class);        bean.setInterceptorNames("myMethodInterceptor ");        userService.queryUser("dark");    }</code></pre><p>è¿™æ—¶è‡ªå®šä¹‰çš„å…¨å±€æ‹¦æˆªå™¨å°±æ²¡æœ‰ä½œç”¨äº†ï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºå½“æ‰§è¡Œ<strong>getBean</strong>çš„æ—¶å€™ï¼Œå¦‚æœæœ‰åˆ‡é¢åŒ¹é…å°±ä¼šé€šè¿‡<strong>ProxyFactory</strong>å»åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œæ³¨æ„<strong>Interceptor</strong>æ˜¯å­˜åˆ°è¿™ä¸ªFactoryå¯¹è±¡ä¸­çš„ï¼Œè€Œè¿™ä¸ªå¯¹è±¡å’Œä»£ç†å¯¹è±¡æ˜¯<strong>ä¸€ä¸€å¯¹åº”</strong>çš„ï¼Œå› æ­¤è°ƒç”¨<strong>getBean</strong>æ—¶ï¼Œè¿˜æ²¡æœ‰<strong>myMethodInterceptor</strong>è¿™ä¸ªå¯¹è±¡ï¼Œè‡ªå®šä¹‰æ‹¦æˆªå™¨å°±æ²¡æœ‰æ•ˆæœäº†ï¼Œä¹Ÿå°±æ˜¯è¯´è¦æƒ³è‡ªå®šä¹‰æ‹¦æˆªå™¨ç”Ÿæ•ˆï¼Œå°±å¿…é¡»åœ¨ä»£ç†å¯¹è±¡ç”Ÿæˆä¹‹å‰æ³¨å†Œè¿›å»ã€‚</p><h3 class=line>äºŒã€å¾ªç¯ä¾èµ–ä¸‰çº§ç¼“å­˜å­˜åœ¨çš„å¿…è¦æ€§</h3><p>åœ¨ä¸Šä¸€ç¯‡æ–‡ç« æˆ‘åˆ†æäº†Springæ˜¯å¦‚ä½•é€šè¿‡ä¸‰çº§ç¼“å­˜æ¥è§£å†³å¾ªç¯ä¾èµ–çš„é—®é¢˜çš„ï¼Œä½†ä½ æ˜¯å¦è€ƒè™‘è¿‡<strong>ç¬¬ä¸‰çº§ç¼“å­˜</strong>ä¸ºä»€ä¹ˆè¦å­˜åœ¨ï¼Ÿæˆ‘ç›´æ¥å°†beanå­˜åˆ°äºŒçº§ä¸å°±è¡Œäº†ä¹ˆï¼Œä¸ºä»€ä¹ˆè¿˜è¦å­˜ä¸€ä¸ª<strong>ObjectFactory</strong>å¯¹è±¡åˆ°<strong>ç¬¬ä¸‰çº§ç¼“å­˜</strong>ä¸­ï¼Ÿè¿™ä¸ªåœ¨å­¦ä¹ äº†AOPä¹‹åå°±å¾ˆæ¸…æ¥šäº†ï¼Œå› ä¸ºæˆ‘ä»¬åœ¨@Autowiredå¯¹è±¡æ—¶ï¼Œæƒ³è¦æ³¨å…¥çš„ä¸ä¸€å®šæ˜¯Beanæœ¬èº«ï¼Œè€Œæ˜¯æƒ³è¦æ³¨å…¥ä¸€ä¸ª<strong>ä¿®æ”¹</strong>è¿‡åçš„å¯¹è±¡ï¼Œå¦‚<strong>ä»£ç†å¯¹è±¡</strong>ã€‚åœ¨<strong>AbstractAutowireCapableBeanFactory.getEarlyBeanReference</strong>æ–¹æ³•ä¸­å¾ªç¯è°ƒç”¨äº†<strong>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</strong>æ–¹æ³•ï¼Œ<strong>AbstractAutoProxyCreator</strong>å¯¹è±¡å°±å®ç°äº†è¯¥æ–¹æ³•ï¼š</p><pre><code>    public Object getEarlyBeanReference(Object bean, String beanName) {        Object cacheKey = getCacheKey(bean.getClass(), beanName);        if (!this.earlyProxyReferences.contains(cacheKey)) {            this.earlyProxyReferences.add(cacheKey);        }        // åˆ›å»ºä»£ç†å¯¹è±¡        return wrapIfNecessary(bean, beanName, cacheKey);    }</code></pre><p>å› æ­¤ï¼Œå½“æˆ‘ä»¬æƒ³è¦å¯¹å¾ªåä¾èµ–çš„Beanåšå‡º<strong>ä¿®æ”¹</strong>æ—¶ï¼Œå°±å¯ä»¥åƒAOPè¿™æ ·åšã€‚</p><h3 class=line>ä¸‰ã€å¦‚ä½•åœ¨Beanåˆ›å»ºä¹‹å‰æå‰åˆ›å»ºä»£ç†å¯¹è±¡</h3><p>Springçš„ä»£ç†å¯¹è±¡åŸºæœ¬ä¸Šéƒ½æ˜¯åœ¨Beanå®ä¾‹åŒ–å®Œæˆä¹‹ååˆ›å»ºçš„ï¼Œä½†åœ¨æ–‡ç« å¼€å§‹æˆ‘å°±è¯´è¿‡ï¼ŒSpringä¹Ÿæä¾›äº†ä¸€ä¸ªæœºä¼šåœ¨åˆ›å»ºBeanå¯¹è±¡ä¹‹å‰å°±åˆ›å»ºä»£ç†å¯¹è±¡ï¼Œåœ¨<strong>AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation</strong>æ–¹æ³•ä¸­ï¼š</p><pre><code>    protected Object resolveBeforeInstantiation(String beanName, RootBeanDefinition mbd) {        Object bean = null;        if (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) {            // Make sure bean class is actually resolved at this point.            if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) {                Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);                if (targetType != null) {                    bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);                    if (bean != null) {                        bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);                    }                }            }            mbd.beforeInstantiationResolved = (bean != null);        }        return bean;    }    protected Object applyBeanPostProcessorsBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {        for (BeanPostProcessor bp : getBeanPostProcessors()) {            if (bp instanceof InstantiationAwareBeanPostProcessor) {                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;                Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName);                if (result != null) {                    return result;                }            }        }        return null;    }</code></pre><p>ä¸»è¦æ˜¯<strong>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</strong>æ–¹æ³•ä¸­ï¼Œè¿™é‡Œåˆä¼šè¿›å…¥åˆ°<strong>AbstractAutoProxyCreator</strong>ç±»ä¸­ï¼š</p><pre><code>    public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) {        TargetSource targetSource = getCustomTargetSource(beanClass, beanName);        if (targetSource != null) {            if (StringUtils.hasLength(beanName)) {                this.targetSourcedBeans.add(beanName);            }            Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);            Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);            this.proxyTypes.put(cacheKey, proxy.getClass());            return proxy;        }        return null;    }    protected TargetSource getCustomTargetSource(Class&lt;?&gt; beanClass, String beanName) {        // We can't create fancy target sources for directly registered singletons.        if (this.customTargetSourceCreators != null &amp;&amp;                this.beanFactory != null &amp;&amp; this.beanFactory.containsBean(beanName)) {            for (TargetSourceCreator tsc : this.customTargetSourceCreators) {                TargetSource ts = tsc.getTargetSource(beanClass, beanName);                if (ts != null) {                    return ts;                }            }        }        // No custom TargetSource found.        return null;    }</code></pre><p>çœ‹åˆ°è¿™é‡Œå¤§è‡´åº”è¯¥æ˜ç™½äº†ï¼Œå…ˆæ˜¯è·å–åˆ°ä¸€ä¸ª<strong>è‡ªå®šä¹‰çš„TargetSource</strong>å¯¹è±¡ï¼Œç„¶ååˆ›å»ºä»£ç†å¯¹è±¡ï¼Œæ‰€ä»¥æˆ‘ä»¬é¦–å…ˆéœ€è¦è‡ªå·±å®ç°ä¸€ä¸ª<strong>TargetSource</strong>ç±»ï¼Œè¿™é‡Œç›´æ¥ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»ï¼Œ<strong>getTarget</strong>æ–¹æ³•åˆ™è¿”å›åŸå§‹å¯¹è±¡ï¼š</p><pre><code>public class MyTargetSource extends AbstractBeanFactoryBasedTargetSource {    @Override    public Object getTarget() throws Exception {        return getBeanFactory().getBean(getTargetBeanName());    }}</code></pre><p>ä½†è¿™è¿˜ä¸å¤Ÿï¼Œä¸Šé¢é¦–å…ˆåˆ¤æ–­äº†<strong>customTargetSourceCreators!=null</strong>ï¼Œè€Œè¿™ä¸ªå±æ€§æ˜¯ä¸ªæ•°ç»„ï¼Œå¯ä»¥é€šè¿‡ä¸‹é¢è¿™ä¸ªæ–¹æ³•è®¾ç½®è¿›æ¥ï¼š</p><pre><code>    public void setCustomTargetSourceCreators(TargetSourceCreator... targetSourceCreators) {        this.customTargetSourceCreators = targetSourceCreators;    }</code></pre><p>æ‰€ä»¥æˆ‘ä»¬è¿˜è¦å®ç°ä¸€ä¸ª<strong>TargetSourceCreator</strong>ç±»ï¼ŒåŒæ ·ç»§æ‰¿ä¸€ä¸ªæŠ½è±¡ç±»å®ç°ï¼Œå¹¶åªå¯¹<strong>userServiceImpl</strong>å¯¹è±¡è¿›è¡Œæ‹¦æˆªï¼š</p><pre><code>public class MyTargetSourceCreator extends AbstractBeanFactoryBasedTargetSourceCreator {    @Override    protected AbstractBeanFactoryBasedTargetSource createBeanFactoryBasedTargetSource(Class&lt;?&gt; beanClass, String beanName) {        if (getBeanFactory() instanceof ConfigurableListableBeanFactory) {            if(beanName.equalsIgnoreCase("userServiceImpl")) {                return new MyTargetSource();            }        }        return null;    }}</code></pre><p><strong>createBeanFactoryBasedTargetSource</strong>æ–¹æ³•æ˜¯åœ¨<strong>AbstractBeanFactoryBasedTargetSourceCreator.getTargetSource</strong>ä¸­è°ƒç”¨çš„ï¼Œè€Œ<strong>getTargetSource</strong>å°±æ˜¯åœ¨ä¸Šé¢<strong>getCustomTargetSource</strong>ä¸­è°ƒç”¨çš„ã€‚ä»¥ä¸Šå·¥ä½œåšå®Œåï¼Œè¿˜éœ€è¦å°†å…¶è®¾ç½®åˆ°<strong>AnnotationAwareAspectJAutoProxyCreator</strong>å¯¹è±¡ä¸­ï¼Œå› æ­¤éœ€è¦æˆ‘ä»¬æ³¨å…¥è¿™ä¸ªå¯¹è±¡ï¼š</p><pre><code>@Configurationpublic class TargetSourceCreatorBean {    @Autowired    private BeanFactory beanFactory;   @Bean    public AnnotationAwareAspectJAutoProxyCreator annotationAwareAspectJAutoProxyCreator() {        AnnotationAwareAspectJAutoProxyCreator creator = new AnnotationAwareAspectJAutoProxyCreator();        MyTargetSourceCreator myTargetSourceCreator = new MyTargetSourceCreator();        myTargetSourceCreator.setBeanFactory(beanFactory);        creator.setCustomTargetSourceCreators(myTargetSourceCreator);        return creator;    }}</code></pre><p>è¿™æ ·ï¼Œå½“æˆ‘ä»¬é€šè¿‡getBeanè·å–<strong>userServiceImpl</strong>çš„å¯¹è±¡æ—¶ï¼Œå°±ä¼šä¼˜å…ˆç”Ÿæˆä»£ç†å¯¹è±¡ï¼Œç„¶ååœ¨è°ƒç”¨æ‰§è¡Œé“¾çš„è¿‡ç¨‹ä¸­å†é€šè¿‡<strong>TargetSource.getTarget</strong>è·å–åˆ°è¢«ä»£ç†å¯¹è±¡ã€‚ä½†æ˜¯ï¼Œä¸ºä»€ä¹ˆæˆ‘ä»¬åœ¨<strong>getTarget</strong>æ–¹æ³•ä¸­è°ƒç”¨<strong>getBean</strong>å°±èƒ½æ‹¿åˆ°è¢«ä»£ç†å¯¹è±¡å‘¢ï¼Ÿç»§ç»­æ¢ç©¶ï¼Œé€šè¿‡æ–­ç‚¹æˆ‘å‘ç°ä»<strong>getTarget</strong>è¿›å…¥æ—¶ï¼Œåœ¨<strong>resolveBeforeInstantiation</strong>æ–¹æ³•ä¸­è¿”å›çš„beanå°±æ˜¯nulläº†ï¼Œè€Œ<strong>getBeanPostProcessors</strong>æ–¹æ³•è¿”å›çš„<strong>Processors</strong>ä¸­ä¹Ÿæ²¡æœ‰äº†<strong>AnnotationAwareAspectJAutoProxyCreator</strong>å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯æ²¡æœ‰è¿›å…¥åˆ°<strong>AbstractAutoProxyCreator.postProcessBeforeInstantiation</strong>æ–¹æ³•ä¸­ï¼Œæ‰€ä»¥ä¸ä¼šå†æ¬¡è·å–åˆ°ä»£ç†å¯¹è±¡ï¼Œé‚£<strong>AnnotationAwareAspectJAutoProxyCreator</strong>å¯¹è±¡æ˜¯åœ¨ä»€ä¹ˆæ—¶å€™ç§»é™¤çš„å‘¢ï¼Ÿå¸¦ç€é—®é¢˜ï¼Œæˆ‘å¼€å§‹åæ¨ï¼Œå‘ç°åœ¨<strong>AbstractBeanFactoryBasedTargetSourceCreator</strong>ç±»ä¸­æœ‰è¿™æ ·ä¸€ä¸ªæ–¹æ³•<strong>buildInternalBeanFactory</strong>ï¼š</p><pre><code>    protected DefaultListableBeanFactory buildInternalBeanFactory(ConfigurableBeanFactory containingFactory) {        DefaultListableBeanFactory internalBeanFactory = new DefaultListableBeanFactory(containingFactory);        // Required so that all BeanPostProcessors, Scopes, etc become available.        internalBeanFactory.copyConfigurationFrom(containingFactory);        // Filter out BeanPostProcessors that are part of the AOP infrastructure,        // since those are only meant to apply to beans defined in the original factory.        internalBeanFactory.getBeanPostProcessors().removeIf(beanPostProcessor -&gt;                beanPostProcessor instanceof AopInfrastructureBean);        return internalBeanFactory;    }</code></pre><p>åœ¨è¿™é‡Œç§»é™¤æ‰äº†æ‰€æœ‰<strong>AopInfrastructureBean</strong>çš„å­ç±»ï¼Œè€Œ<strong>AnnotationAwareAspectJAutoProxyCreator</strong>å°±æ˜¯å…¶å­ç±»ï¼Œé‚£è¿™ä¸ªæ–¹æ³•æ˜¯åœ¨å“ªé‡Œè°ƒç”¨çš„å‘¢ï¼Ÿç»§ç»­åæ¨ï¼š</p><pre><code>    protected DefaultListableBeanFactory getInternalBeanFactoryForBean(String beanName) {        synchronized (this.internalBeanFactories) {            DefaultListableBeanFactory internalBeanFactory = this.internalBeanFactories.get(beanName);            if (internalBeanFactory == null) {                internalBeanFactory = buildInternalBeanFactory(this.beanFactory);                this.internalBeanFactories.put(beanName, internalBeanFactory);            }            return internalBeanFactory;        }    }    public final TargetSource getTargetSource(Class&lt;?&gt; beanClass, String beanName) {        AbstractBeanFactoryBasedTargetSource targetSource =                createBeanFactoryBasedTargetSource(beanClass, beanName);        // åˆ›å»ºå®ŒtargetSourceåå°±ç§»é™¤æ‰AopInfrastructureBeanç±»å‹çš„BeanPostProcessorå¯¹è±¡ï¼Œå¦‚AnnotationAwareAspectJAutoProxyCreator        DefaultListableBeanFactory internalBeanFactory = getInternalBeanFactoryForBean(beanName);        ......        return targetSource;    }</code></pre><p>è‡³æ­¤ï¼Œå…³äº<strong>TargetSource</strong>æ¥å£æ‰©å±•çš„åŸç†å°±ææ˜ç™½äº†ã€‚</p><h1 class=line>æ€»ç»“</h1><p>æœ¬ç¯‡ç¯‡å¹…æ¯”è¾ƒé•¿ï¼Œä¸»è¦ææ˜ç™½Springä»£ç†å¯¹è±¡æ˜¯å¦‚ä½•åˆ›å»ºçš„ä»¥åŠAOPé“¾å¼è°ƒç”¨è¿‡ç¨‹ï¼Œè€Œåé¢çš„æ‰©å±•åˆ™æ˜¯å¯¹AOPä»¥åŠBeanåˆ›å»ºè¿‡ç¨‹ä¸­ä¸€äº›ç–‘æƒ‘çš„è¡¥å……ï¼Œå¯æ ¹æ®å®é™…æƒ…å†µå­¦ä¹ æŒæ¡ã€‚</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'ææ‡‚','Spring','åˆ›å»º'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=æœç´¢>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>ğŸ”</button></form></section><section class=widget><h3 class=widget-title>æœ€æ–°æ–‡ç«  âš¡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>å…¶ä»–</h3><ul class=widget-list><li><a href=TOS.html>ä½¿ç”¨æ¢æ¬¾</a></li><li><a href=CommentPolicy.html>ç•™è¨€æ”¿ç­–</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>è¯çµ¡æˆ‘å€‘</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>æå®¢å¿«è¨Š</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>