<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>GoF之适配器模式、策略模式详解 | 极客快訊</title><meta property="og:title" content="GoF之适配器模式、策略模式详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b78c987.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b78c987.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b78c987.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b78c987.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b78c987.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b78c987.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b78c987.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b78c987.html><meta property="article:published_time" content="2020-10-29T20:53:45+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:45+08:00"><meta name=Keywords content><meta name=description content="GoF之适配器模式、策略模式详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b78c987.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>GoF之适配器模式、策略模式详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify><strong>适配器模式(Adapter Pattern)</strong></p><p class=ql-align-justify>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p class=ql-align-justify><strong>优点</strong></p><p class=ql-align-justify>1、可以让任何两个没有关联的类一起运行。</p><p class=ql-align-justify>2、提高了类的复用。</p><p class=ql-align-justify>3、增加了类的透明度。</p><p class=ql-align-justify>4、灵活性和扩展性都非常好，符合“开闭原则”。</p><p class=ql-align-justify><strong>缺点：</strong></p><p class=ql-align-justify>1、过多地使用适配器，会让系统变复杂。比如，明明看到调用的是A 接口，其实内部被适配成了 B 接口的实现。如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</p><p class=ql-align-justify>2.由于 JAVA至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><p class=ql-align-justify><strong>使用场景：</strong>有动机地修改一个正常运行的系统的接口，这时应该考虑使用适配器模式。</p><p class=ql-align-justify><strong>注意事项：</strong>适配器不是在详细设计时添加的，而是解决正在服役的项目的问题。</p><p class=ql-align-justify></p><p class=ql-align-justify>类适配器模式（adapter pattern）</p><p class=ql-align-justify>具体实现：通过电源适配器，将电源输入220V（适配者）转换为5V输出（目标）。</p><pre>//目标角色public interface PowerTarget{ public int output5V();}//适配者角色public class PowerAdaptee{ private int output = 220; public int output220V() { System.out.println("电源输出电压：" + output); return output; }} //适配器角色public class PowerAdapterextends PowerAdapteeimplements PowerTarget{ @Override public int output5V() { int output =output220V(); System.out.println("电源适配器开始工作，此时输出电压是：" + output); output = 5; System.out.println("电源适配器工作完成，此时输出电压是：" + output); return output; }}电源适配器类实现了电源目标，继承了适配者。//类适配器模式测试public class ClassAdapterPatternTest{ public static void main(String[] args) { PowerTargettarget = new PowerAdapter(); target.output5V(); }} </pre><p class=ql-align-justify>对象适配器模式（object adapter pattern）</p><p class=ql-align-justify>对象适配器模式在运行时实现target（目标）接口。在这种适配器模式中，适配器包装了一个类实例。适配器通过调用包装对象实例的方法实现适配。</p><p class=ql-align-justify></p><p class=ql-align-justify>代码示例和类适配器模式只有Adapter类有不同，其他都一样，只贴上Adapter类。</p><pre>//适配器角色public class PowerAdapterimplements PowerTarget{ private PowerAdaptee powerAdaptee; public PowerAdapter(PowerAdapteepowerAdaptee) { super(); this.powerAdaptee = powerAdaptee; } @Override public int output5V() { int output = powerAdaptee.output220V(); System.out.println("电源适配器开始工作，此时输出电压是：" + output); output = 5; System.out.println("电源适配器工作完成，此时输出电压是：" + output); return output; }}</pre><p class=ql-align-justify>实现了PowerTarget（目标角色），在创建对象时引入PowerAdaptee（适配者角色）。</p><p class=ql-align-justify></p><p class=ql-align-justify>缺省适配器模式（defaultadapter pattern）（客户端，继承b，调用b中的方法，不必直接实现a（直接实现a需要实现a中的所有的方法））</p><p class=ql-align-justify>当不需要全部实现接口提供的方法时，可以设计一个适配器抽象类实现接口，并为接口中的每个方法提供默认方法，抽象类的子类就可以有选择的覆盖父类的某些方法实现需求，它适用于一个接口不想使用所有的方法的情况。</p><p class=ql-align-justify>在java8后，接口中可以有default方法，就不需要这种缺省适配器模式了。接口中方法都设置为default，实现为空，这样同样同样可以达到缺省适配器模式同样的效果。</p><p class=ql-align-justify></p><p class=ql-align-justify>策略模式（Strategy Pattern）也叫 政策模式（Policy Pattern）。</p><p class=ql-align-justify>指的是对象具备某个行为，但是在不同的场景中，该行为有不同的实现算法。比如一个人的交税比率与他的工资有关，不同的工资水平对应不同的税率。</p><p class=ql-align-justify><strong>优点：</strong></p><p class=ql-align-justify>1、算法可以自由切换。</p><p class=ql-align-justify>2、避免使用多重条件判断。</p><p class=ql-align-justify>3、扩展性良好。</p><p class=ql-align-justify><strong>缺点：</strong></p><p class=ql-align-justify>1、策略类会增多。</p><p class=ql-align-justify>2、所有策略类都需要对外暴露。</p><p class=ql-align-justify>具体实现：建立加减乘算法族，解决在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。</p><pre>//创建一个接口，定策略或算法的行为。public interface Strategy{ public int doOperation(int num1, int num2);} //创建实现接口的实体类，里面包含具体的策略或算法实现。利用多态，使行为在不同场景下产生不同结果。public class OperationAddimplements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; }} public class OperationSubstractimplements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 - num2; }} public class OperationMultiplyimplements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 * num2; }} //创建Context类，用来操作策略的上下文环境，屏蔽高层模块（客户端）对策略，算法的直接访问，封装可能存在的变化；public class Context { private Strategy strategy; public Context(){ } public SetStrategy(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); }} //使用 Context 来查看当它改变策略 Strategy 时的行为变化。public class StrategyPatternClient{ public static void main(String[] args) { Contextcontext = new Context(); context.SetStrategy(new OperationAdd()); System.out.println("10 + 5 =" + context.executeStrategy(10, 5)); context.SetStrategy(new OperationSubstract()); System.out.println("10 - 5 =" + context.executeStrategy(10, 5)); context.SetStrategy(new OperationMultiply()); System.out.println("10 * 5 =" + context.executeStrategy(10, 5)); }}</pre><p class=ql-align-justify>输出结果：</p><p class=ql-align-justify>10 + 5 = 15</p><p class=ql-align-justify>10 - 5 = 5</p><p class=ql-align-justify>10 * 5 =50</p><p class=ql-align-justify><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><blockquote><p>原文：https://mp.weixin.qq.com/s/g20WQyzJNmvkH-kLPZRYBA</p><p>作者：专注一行代码</p><p>来源：微信公众号</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'模式','GoF','之适'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>