<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>mysql数据库主从复制拓扑结构 | 极客快訊</title><meta property="og:title" content="mysql数据库主从复制拓扑结构 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/6c3e00007aa0307b6043"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b923e71e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b923e71e.html><meta property="article:published_time" content="2020-11-14T21:04:04+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:04+08:00"><meta name=Keywords content><meta name=description content="mysql数据库主从复制拓扑结构"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b923e71e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>mysql数据库主从复制拓扑结构</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>MYSQL是一种很不错的数据库，适用于大中小型的网站，并被越来越多的人群接受，主从复制是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，目的是减轻主数据库的负担。</strong></h1><p>1、主从复制的常用拓扑结构<br></p><p>主从复制的体系结构有以下一些基本原则：</p><ul class=list-paddingleft-2><li><p>每个slave只能有一个master；</p></li><li><p>每个slave只能有一个唯一的服务器ID；</p></li><li><p>每个master可以有很多slave；</p></li><li><p>如果你设置log_slave_updates，slave可以是其它slave的master，从而扩散master的更新。</p></li></ul><p>MySQL不支持多主服务器复制(Multimaster Replication)——即一个slave可以有多个master。但是通过一些简单的组合，我们却可以建立灵活而强大的复制体系结构，到底是哪些组合呢，我们一一来学习下。</p><p><strong>1.1、单一master和多slave</strong></p><p>由一个master和一个slave组成复制系统是最简单的情况。Slave之间并不相互通信，只能与master进行通信。在实际应用场景中，MySQL复制90%以上都是一个Master复制到一个或者多个Slave的架构模式，主要用于读压力比较大的应用的数据库端廉价扩展解决方案。因为只要Master和Slave的压力不是太大（尤其是Slave端压力）的话，异步复制的延时一般都很少很少。尤其是自从Slave端的复制方式改成两个线程处理之后，更是减小了Slave端的延时问题。而带来的效益是，对于数据实时性要求不是特别Critical的应用，只需要通过廉价的pcserver来扩展Slave的数量，将读压力分散到多台Slave的机器上面，即可通过分散单台数据库服务器的读压力来解决数据库端的读性能瓶颈，毕竟在大多数数据库应用系统中的读压力还是要比写压力大很多。这在很大程度上解决了目前很多中小型网站的数据库压力瓶颈问题，甚至有些大型网站也在使用类似方案解决数据库瓶颈。</p><p>如图：</p><p><img alt=mysql数据库主从复制拓扑结构 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c3e00007aa0307b6043></p><p>如果写操作较少，而读操作很时，可以采取这种结构。你可以将读操作分布到其它的slave，从而减小master的压力。但是，当slave增加到一定数量时，slave对master的负载以及网络带宽都会成为一个严重的问题。</p><p>这种结构虽然简单，但它却非常灵活，足够满足大多数应用需求，特点如下：</p><ul class=list-paddingleft-2><li><p>不同的slave扮演不同的作用(例如使用不同的索引，或者不同的存储引擎)；</p></li><li><p>用一个slave作为备用master，只进行复制；</p></li><li><p>用一个远程的slave，用于灾难恢复；</p></li></ul><p>大家应该都比较清楚，从一个Master节点可以复制出多个Slave节点，可能会联想，那一个Slave节点是否可以从多个Master节点上面进行复制呢？至少在目前来看，MySQL是做不到的，以后是否会支持就不清楚了。</p><p>MySQL不支持一个Slave节点从多个Master节点来进行复制的架构，主要是为了避免冲突的问题，防止多个数据源之间的数据出现冲突，而造成最后数据的不一致性。不过听说已经有人开发了相关的patch，让MySQL支持一个Slave节点从多个Master结点作为数据源来进行复制，这也正是MySQL开源的性质所带来的好处。</p><p><strong>1.2、主动模式的Master-Master(Master-Master in Active-Active Mode)</strong></p><p>Master-Master复制的两台服务器，既是master，又是另一台服务器的slave。这样任何一方所做的变更，都会通过复制应用到另外一方的数据库中。可能有些读者会有一个担心，这样搭建复制环境之后，难道不会造成两台MySQL之间的循环复制么？实际上MySQL自己早就想到了这一点，所以在MySQL的BinaryLog中记录了当前MySQL的server-id，而且这个参数也是我们搭建MySQLReplication的时候必须明确指定，而且Master和Slave的server-id参数值比需要不一致才能使MySQLReplication搭建成功。一旦有了server-id的值之后，MySQL就很容易判断某个变更是从哪一个MySQLServer最初产生的，所以就很容易避免出现循环复制的情况。而且如果我们不打开记录Slave的BinaryLog的选项（--log-slave-update）的时候，MySQL根本就不会记录复制过程中的变更到BinaryLog中，就更不用担心可能会出现循环复制的情形了。</p><p>如图：</p><p><img alt=mysql数据库主从复制拓扑结构 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c3c0000e900660a61da></p><p>主动的Master-Master复制有一些特殊的用处。例如地理上分布的两个部分都需要自己的可写的数据副本。这种结构最大的问题就是更新冲突。假设一个表只有一行(一列)的数据，其值为1，如果两个服务器分别同时执行如下语句：</p><p>在第一个服务器上执行：</p><blockquote><p>mysql> UPDATE tbl SET col=col + 1;</p></blockquote><p>在第二个服务器上执行：</p><blockquote><p>mysql> UPDATE tbl SET col=col * 2;</p></blockquote><p>那么结果是多少呢？一台服务器是4，另一个服务器是3，但是这并不会产生错误。</p><p>实际上MySQL并不支持其它一些DBMS支持的多主服务器复制(Multimaster Replication)，这是MySQL的复制功能很大的一个限制(多主服务器的难点在于解决更新冲突)，但是如果你实在有这种需求，你可以采用MySQL Cluster，以及将Cluster和Replication结合起来，可以建立强大的高性能的数据库平台。但是可以通过其它一些方式来模拟这种多主服务器的复制。</p><p><strong>1.3、主动-被动模式的Master-Master(Master-Master in Active-Passive Mode)</strong></p><p>这是master-master结构变化而来的，它避免了M-M的缺点，这是一种具有容错和高可用性的系统。它的不同点在于其中一个服务只能进行只读操作。如图：</p><p><img alt=mysql数据库主从复制拓扑结构 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6c380005a532026d7951></p><p><strong>1.4、级联复制架构 Master –Slaves - Slaves</strong></p><p>在有些应用场景中，可能读写压力差别比较大，读压力特别的大，一个Master可能需要上10台甚至更多的Slave才能够支撑注读的压力。这时候Master就会比较吃力了，因为仅仅连上来的SlaveIO线程就比较多了，这样写的压力稍微大一点的时候，Master端因为复制就会消耗较多的资源，很容易造成复制的延时。</p><p>遇到这种情况如何解决呢？这时候我们就可以利用MySQL可以在Slave端记录复制所产生变更的BinaryLog信息的功能，也就是打开—log-slave-update选项。然后通过二级（或者是更多级别）复制来减少Master端因为复制所带来的压力。也就是说，我们首先通过少数几台MySQL从Master来进行复制，这几台机器我们姑且称之为第一级Slave集群，然后其他的Slave再从第一级Slave集群来进行复制。从第一级Slave进行复制的Slave，我称之为第二级Slave集群。</p><p>如果有需要，我们可以继续往下增加更多层次的复制。这样我们很容易就控制了每一台MySQL上面所附属Slave的数量。这种架构我称之为Master-Slaves-Slaves架构。这种多层级联复制的架构，很容易就解决了Master端因为附属Slave太多而成为瓶颈的风险，下图展示了多层级联复制的Replication架构。</p><p><img alt=mysql数据库主从复制拓扑结构 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6c3c0000e90170b46814></p><p>需要注意的是Slave并没有减少写的量，所有Slave实际上仍然还是应用了所有的数据变更操作，没有减少任何写IO，相反Slave越多，整个集群的写IO总量也就会越多，我们没有非常明显的感觉的原因是因为分散到了多台机器上面，所以不是很容易表现出来，但是同一个变更传到最底层的Slave所需要经过的MySQl服务器也会更多，会造成较长延时的风险。</p><p><strong>1.5、带从服务器的Master-Master结构(Master-Master with Slaves)</strong><strong><br></strong></p><p>这种结构的优点就是提供了冗余。在地理上分布的复制结构，它不存在单一节点故障问题，而且还可以将读密集型的请求放到slave上。</p><p><img alt=mysql数据库主从复制拓扑结构 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6c3c0000e902358f8092></p><p>级联复制在一定程度上面确实解决了Master因为所附属的Slave过多而成为瓶颈的问题，但并不能解决人工维护和出现异常需要切换后可能存在重新搭建Replication的问题。这样就很自然的引申出了DualMaster与级联复制结合的Replication架构，我称之为Master-Master-Slaves架构，和Master-Slaves-Slaves架构相比，区别仅仅只是将第一级Slave集群换成了一台单独的Master，作为备用Master，然后再从这个备用的Master进行复制到一个Slave集群。</p><p>这种DualMaster与级联复制结合的架构，最大的好处就是既可以避免主Master的写入操作不会受到Slave集群的复制所带来的影响，同时主Master需要切换的时候也基本上不会出现重搭Replication的情况。但是这个架构也有一个弊端，那就是备用的Master有可能成为瓶颈，因为如果后面的Slave集群比较大的话，备用Master可能会因为过多的SlaveIO线程请求而成为瓶颈。当然该备用Master不提供任何的读服务的时候，瓶颈出现的可能性并不是特别高，如果出现瓶颈，也可以在备用Master后面再次进行级联复制，架设多层Slave集群。当然级联复制的级别越多，Slave集群可能出现的数据延时也会更为明显，所以考虑使用多层级联复制之前，也需要评估数据延时对应用系统的影响。</p><p>这些就是常见的mysql主从复制拓扑结构，你学到了吗。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'mysql','数据','库主'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>