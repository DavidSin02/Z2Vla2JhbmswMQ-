<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux系统移植之——在 U-BOOT 对 Nand Flash 的支持，先收藏 | 极客快訊</title><meta property="og:title" content="Linux系统移植之——在 U-BOOT 对 Nand Flash 的支持，先收藏 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3fbc533d28464dae828bdfd33c49046d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b977a02.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/b977a02.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/b977a02.html><meta property="article:published_time" content="2020-10-29T20:53:12+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:12+08:00"><meta name=Keywords content><meta name=description content="Linux系统移植之——在 U-BOOT 对 Nand Flash 的支持，先收藏"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/b977a02.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux系统移植之——在 U-BOOT 对 Nand Flash 的支持，先收藏</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>上章节讲了Nand flash驱动的编写与移植，本章节主要讲在 U-BOOT 对 Nand Flash 的支持，学linux的建议收藏，以后工作中会遇到。</p><pre><code>说明：本人作为一名工作多年的程序员，给大家都是精心挑选的资料，希望对大家的学习有帮助。</code></pre><p>本章主要内容如下：</p><p>3 在 U­BOOT 对 Nand Flash 的支持</p><p>3.1 U­BOOT 对从 Nand Flash 启动的支持</p><p>3.1.1 从 Nand Flash 启动 U­BOOT 的基本原理</p><p>3.1.2 支持 Nand Flash 启动代码说明</p><p>3.2 U­BOOT 对 Nand Flash 命令的支持</p><p>3.2.1 主要数据结构介绍</p><p>3.2.2 支持的命令函数说明</p><p>4 在 Linux 对 Nand Flash 的支持</p><p>4.1 Linux 下 Nand Flash 调用关系</p><p>4.1.1 Nand Flash 设备添加时数据结构包含关系</p><p>4.1.2 Nand Flash 设备注册时数据结构包含关系</p><p>4.2 Linux 下 Nand Flash 驱动主要数据结构说明</p><p>4.2.1 s3c2410 专有数据结构</p><p>4.2.2 Linux 通用数据结构说明</p><p>4.3.1 注册 driver_register</p><p>4.3.2 探测设备 probe</p><p>4.3.3 初始化 Nand Flash 控制器</p><p>4.3.4 移除设备</p><p>4.3.5 Nand Flash 芯片初始化</p><p>4.3.6 读 Nand Flash</p><p>4.3.7 写 Nand Flash</p><p><br></p><div class=pgc-img><img alt="Linux系统移植之——在 U-BOOT 对 Nand Flash 的支持，先收藏" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3fbc533d28464dae828bdfd33c49046d><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.1 U-BOOT 对从 Nand Flash 启动的支持</strong></p><p><strong>3.1.1 从 Nand Flash 启动 U-BOOT 的基本原理</strong></p><p>1. 前 4K 的问题</p><p>如果 S3C2410 被配置成从 Nand Flash 启动(配置由硬件工程师在电路板设置), S3C2410 的 Nand Flash 控制器</p><p>有一个特殊的功能, 在 S3C2410 上电后, Nand Flash 控制器会自动的把 Nand Flash 上的前 4K 数据搬移到 4K 内部</p><p>RAM 中, 并把 0x00000000 设置内部 RAM 的起始地址, CPU 从内部 RAM 的 0x00000000 位置开始启动。这个过</p><p>程不需要程序干涉。</p><p>程序员需要完成的工作，是把最核心的启动程序放在 Nand Flash 的前 4K 中。</p><p>2. 启动程序的安排</p><p>由于 Nand Flash 控制器从 Nand Flash 中搬移到内部 RAM 的代码是有限的,所以, 在启动代码的前 4K 里,我</p><p>们必须完成 S3C2410 的核心配置以及把启动代码(UBOOT)剩余部分搬到 RAM 中运行。以 UBOOT 为例, 前 4K</p><p>完成的主要工作, 见第四部分的 2.2 节。</p><p><strong>3.1.2 支持 Nand Flash 启动代码说明</strong></p><p>首先在 include/configs/crane2410.h 中加入 CONFIG_S3C2410_NAND_BOOT, 如下：</p><p>#define CONFIG_S3C2410_NAND_BOOT 1</p><p>支持从 Nand Flash 中启动.</p><p>1. 执行 Nand Flash 初始化</p><p>下面代码在 cpu/arm920t/start.S 中</p><p>#ifdef CONFIG_S3C2410_NAND_BOOT</p><p>copy_myself:</p><p>mov r10, lr</p><p>ldr sp, DW_STACK_START @安装栈的起始地址</p><p>mov fp, #0 @初始化帧指针寄存器</p><p>bl nand_reset @跳到复位 C 函数去执行</p><p>...</p><p>DW_STACK_START:</p><p>.word STACK_BASE+STACK_SIZE­4</p><p>2. nand_reset C 代码</p><p>下面代码被加在/board/crane2410/crane2410.c 中</p><p>void nand_reset(void)</p><p>{</p><p>int i;</p><p>/* 设置 Nand Flash 控制器 */</p><p>rNFCONF=(1&lt;&lt;15)|(1&lt;&lt;14)|(1&lt;&lt;13)|(1&lt;&lt;12)|(1&lt;&lt;11)|(TACLS&lt;&lt;8)|(TWRPH0&lt;&lt;4)|(TWRPH1&lt;&lt;0);</p><p>/* 给 Nand Flash 芯片发送复位命令 */</p><p>NF_nFCE_L();</p><p>NF_CMD(0xFF);</p><p>for(i=0; i&lt;10; i++);</p><p>NF_WAITRB(); NF_nFCE_H();</p><p>}</p><p>3. 从 Nand Flash 中把 UBOOT 拷贝到 RAM</p><p>@read U­BOOT from Nand Flash to RAM</p><p>ldr r0, =UBOOT_RAM_BASE @ 设置第 1 个参数: UBOOT 在 RAM 中的起始地址</p><p>mov r1, #0x0 @ 设置第 2 个参数:Nand Flash 的起始地址</p><p>mov r2, #0x20000 @ 设置第 3 个参数: UBOOT 的长度(128KB)</p><p>bl nand_read_whole @ 调用 nand_read_whole(), 该函数在 board/crane2410/crane2410.c 中</p><p>tst r0, #0x0 @ 如果函数的返回值为 0,表示执行成功.</p><p>beq ok_nand_read @ 执行内存比较</p><p>4. 从 Nand Flash 中把数据读入到 RAM 中</p><p>int nand_read_whole(unsigned char *buf, unsigned long start_addr, int size)</p><p>{</p><p>int i, j;</p><p>/* 如果起始地址和长度不是 512 字节(1 页)的倍数, 则返回错误代码 */</p><p>if ((start_addr & NAND_BLOCK_MASK) || (size & NAND_BLOCK_MASK)) {</p><p>return ­1;</p><p>}</p><p>/* 激活 Nand Flash */</p><p>NF_nFCE_L();</p><p>for(i=0; i&lt;10; i++);</p><p>i = start_addr;</p><p>while(i &lt; start_addr + size) {</p><p>/* 读 A 区 */</p><p>rNFCMD = 0;</p><p>/* 写入读取地址 */</p><p>rNFADDR = i & 0xff;</p><p>rNFADDR = (i >> 9) & 0xff;</p><p>rNFADDR = (i >> 17) & 0xff;</p><p>rNFADDR = (i >> 25) & 0xff;</p><p>NF_WAITRB();</p><p>/* 读出一页(512 字节) */</p><p>for(j=0; j &lt; NAND_SECTOR_SIZE; j++, i++) {</p><p>*buf = (rNFDATA & 0xff);</p><p>buf++;</p><p>}</p><p>}</p><p>/* 停止驱动 Nand Flash */</p><p>NF_nFCE_H();</p><p>return 0;</p><p>}5. 校查搬移后的数据</p><p>把 RAM 中的前 4K 与内部中前 4K 进行比较, 如果完全相同, 则表示搬移成功.</p><p>ok_nand_read:</p><p>mov r0, #0x00000000 @内部 RAM 的起始地址</p><p>ldr r1, =UBOOT_RAM_BASE @UBOOT 在 RAM 中的起始地址</p><p>mov r2, #0x400 @比较 1024 次, 每次 4 字节, 4 bytes * 1024 = 4K­bytes</p><p>go_next: @ 比较 1024 次, 每次 4 个字节</p><p>ldr r3, [r0], #4</p><p>ldr r4, [r1], #4</p><p>teq r3, r4</p><p>bne notmatch</p><p>subs r2, r2, #4</p><p>beq done_nand_read</p><p>bne go_next</p><p>notmatch:</p><p>1:b 1b</p><p>done_nand_read:</p><p>mov pc, r10</p><p><strong>3.2 U-BOOT 对 Nand Flash 命令的支持</strong></p><p>在 U­BOOT 下对 Nand Flash 的支持主要是在命令行下实现对 nand flash 的操作。对 nand flash 实现的命令</p><p>为：nand info、nand device、nand read、nand write、nand erease、nand bad。</p><p>用到的主要数据结构有：struct nand_flash_dev、struct nand_chip。前者包括主要的芯片型号、存储容量、</p><p>设备 ID、I/O 总线宽度等信息；后者是具体对 nand flash 进行操作时用到的信息。</p><p><strong>3.2.1 主要数据结构介绍</strong></p><p>1. struct nand_flash_dev 数据结构</p><p>该数据结构在 include/linux/mtd/nand.h 中定义，在 include/linux/mtd/nand_ids.h 中赋初值。</p><p>struct nand_flash_dev {</p><p>char *n<strong>ame;</strong></p><p><strong>/* 芯片名称 */</strong></p><p>int manufacture_id; /* 厂商 ID */</p><p>int model_id; /* 模式 ID */</p><p>int chipshift; /* Nand Flash 地址位数 */</p><p>char page256; /* 表明是否时 256 字节一页。1：是；0：否。*/</p><p>char pageadrlen; /* 完成一次地址传送需要往 NFADDR 中传送几次。*/</p><p>unsigned long erasesize; /* 一次块擦除可以擦除多少字节 */</p><p>int bus16; /* 地址线是否是 16 位，1：是；0：否 */</p><p>};</p><p>2. struct nand_chip 数据结构</p><p>该数据结构在 include/linux/mtd/nand.h 中定义. 该结构体定义出一个 Nand Flash 设备数组:</p><p>struct nand_chip nand_dev_desc[CFG_MAX_NAND_DEVICE];</p><p>该数组在 nand_probe()中对其进行初始化.</p><p>struct nand_chip {</p><p>int</p><p>page_shift; /* Page 地址位数 */</p><p>u_char *data_buf; /* 本次读出的一页数据 */</p><p>u_char *data_cache; /* 读出的一页数据 */</p><p>int cache_page; /* 上次操作的页号 */u_char ecc_code_buf[6]; /* ECC 校验码 */</p><p>u_char reserved[2];</p><p>char ChipID;</p><p>/* 芯片 ID 号 */</p><p>struct Nand *chips; /* Nand Flash 芯片列表, 表示支持几个芯片为一个设备*/</p><p>int chipshift;</p><p>char* chips_name; /* Nand Flash 芯片名称 */</p><p>unsigned long erasesize; /* 块擦写的大小 */</p><p>unsigned long mfr; /* 厂商 ID */</p><p>unsigned long id; /* 模式 ID */</p><p>char* name; /* 设备名称 */</p><p>int numchips; /* 有几块 Nand Flash 芯片 */</p><p>char page256; /* 一页是 256 字节, 还是 512 字节 */</p><p>char pageadrlen; /* 页地址的长度 */</p><p>unsigned long IO_ADDR; /* 用于对 nand flash 进行寻址的地址值存放处 */</p><p>unsigned long totlen; /* Nand Flash 总共大小 */</p><p>uint oobblock; /* 一页的大小。本款 nand flash 为 512 */</p><p>uint oobsize;</p><p>/* spare array 大小。本款 nand flash 为 16 */</p><p>uint eccsize; /* ECC 大小 */</p><p>int bus16; /* 地址线是否是 16 位，1：是；0：否 */</p><p>};</p><p><strong>3.2.2 支持的命令函数说明</strong></p><p>1. nand info/nand device</p><p>功能：显示当前 nand flash 芯片信息。</p><p>函数调用关系如下(按先后顺序)：</p><p>static void nand_print(struct nand_chip *nand) ;</p><p>2. nand erase</p><p>功能：擦除指定块上的数据。</p><p>函数调用关系如下(按先后顺序)：</p><p>int nand_erase(struct nand_chip* nand, size_t ofs, size_t len, int clean);</p><p>3. nand bad</p><p>功能：显示坏块。</p><p>函数调用关系如下(按先后顺序)：</p><p>static void nand_print_bad(struct nand_chip* nand);</p><p>int check_block (struct nand_chip *nand, unsigned long pos);</p><p>4. nand read</p><p>功能：读取 nand flash 信息到 SDRAM。</p><p>函数调用关系如下(按先后顺序)：</p><p>int nand_rw (struct nand_chip* nand, int cmd,size_t start, size_t len, size_t * retlen, u_char * buf);</p><p>static int nand_read_ecc(struct nand_chip *nand, size_t start, size_t len,</p><p>size_t * retlen, u_char *buf, u_char *ecc_code);</p><p>static void NanD_ReadBuf (struct nand_chip *nand, u_char * data_buf, int cntr);</p><p>READ_NAND(adr);</p><p>5. nand write</p><p>功能：从 SDRAM 写数据到 nand flash 中。</p><p>函数调用关系如下(按先后顺序)：int nand_rw (struct nand_chip* nand, int cmd,size_t start, size_t len, size_t * retlen, u_char * buf);</p><p>static int nand_write_ecc (struct nand_chip* nand, size_t to, size_t len,</p><p>size_t * retlen, const u_char * buf, u_char * ecc_code);</p><p>static int nand_write_page (struct nand_chip *nand, int page, int col, int last, u_char * ecc_code);</p><p>WRITE_NAND(d , adr);</p><p><strong>3.2.3 U-BOOT 支持 Nand Flash 命令移植说明</strong></p><p>1. 设置配置选项</p><p>在 CONFIG_COMMANDS 中, 打开 CFG_CMD_NAND 选项.</p><p>#define CONFIG_COMMANDS \</p><p>(CONFIG_CMD_DFL</p><p>| \</p><p>CFG_CMD_CACHE</p><p>| \</p><p>CFG_CMD_NAND</p><p>| \</p><p>/*CFG_CMD_EEPROM |*/ \</p><p>/*CFG_CMD_I2C</p><p>|*/ \</p><p>/*CFG_CMD_USB</p><p>|*/ \</p><p>CFG_CMD_PING | \</p><p>CFG_CMD_REGINFO | \</p><p>CFG_CMD_DATE</p><p>| \</p><p>CFG_CMD_ELF)</p><p>#if (CONFIG_COMMANDS & CFG_CMD_NAND)</p><p>#define CFG_NAND_BASE 0x4E000000 /* Nand Flash 控制器在 SFR 区中起始寄存器地址 */</p><p>#define CFG_MAX_NAND_DEVICE 1 /* 支持的最在 Nand Flash 数据 */</p><p>#define SECTORSIZE 512 /* 1 页的大小 */</p><p>#define NAND_SECTOR_SIZE SECTORSIZE</p><p>#define NAND_BLOCK_MASK (NAND_SECTOR_SIZE – 1) /* 页掩码 */</p><p>#define ADDR_COLUMN 1 /* 一个字节的 Column 地址 */</p><p>#define ADDR_PAGE 3 /* 3 字节的页块地址, A9­A25*/</p><p>#define ADDR_COLUMN_PAGE 4 /* 总共 4 字节的页块地址 */</p><p>#define NAND_ChipID_UNKNOWN 0x00 /* 未知芯片的 ID 号 */</p><p>#define NAND_MAX_FLOORS 1</p><p>#define NAND_MAX_CHIPS 1</p><p>/* Nand Flash 命令层底层接口函数 */</p><p>#define WRITE_NAND_COMMAND(d, adr) do {rNFCMD = d;} while(0)</p><p>#define WRITE_NAND_ADDRESS(d, adr) do {rNFADDR = d;} while(0)</p><p>#define WRITE_NAND(d, adr) do {rNFDATA = d;} while(0)</p><p>#define READ_NAND(adr) (rNFDATA)</p><p>#define NAND_WAIT_READY(nand) {while(!(rNFSTAT&(1&lt;&lt;0)));}</p><p>#define NAND_DISABLE_CE(nand) {rNFCONF |= (1&lt;&lt;11);}</p><p>#define NAND_ENABLE_CE(nand) {rNFCONF &= ~(1&lt;&lt;11);}</p><p>/* 下面一组操作对 Nand Flash 无效 */</p><p>#define NAND_CTL_CLRALE(nandptr)</p><p>#define NAND_CTL_SETALE(nandptr)</p><p>#define NAND_CTL_CLRCLE(nandptr)</p><p>#define NAND_CTL_SETCLE(nandptr)/* 允许 Nand Flash 写校验 */</p><p>#define CONFIG_MTD_NAND_VERIFY_WRITE 1</p><p>#endif /* CONFIG_COMMANDS & CFG_CMD_NAND*/</p><p>2. 加入自己的 Nand Flash 芯片型号</p><p>在 include/linux/mtd/ nand_ids.h 中的对如下结构体赋值进行修改:</p><p>static struct nand_flash_dev nand_flash_ids[] = {</p><p>......</p><p>{"Samsung K9F1208U0B", NAND_MFR_SAMSUNG, 0x76, 26, 0, 4, 0x4000, 0},</p><p>.......</p><p>}</p><p>这样对于该款 Nand Flash 芯片的操作才能正确执行。</p><p>3. 编写自己的 Nand Flash 初始化函数</p><p>在 board/crane2410/crane2410.c 中加入 nand_init()函数.</p><p>void nand_init(void)</p><p>{</p><p>/* 初始化 Nand Flash 控制器, 以及 Nand Flash 芯片 */</p><p>nand_reset();</p><p>/* 调用 nand_probe()来检测芯片类型 */</p><p>printf ("%4lu MB\n", nand_probe(CFG_NAND_BASE) >> 20);</p><p>}</p><p>该函数在启动时被 start_armboot()调用.</p><p><strong>4 在 Linux 对 Nand Flash 的支持</strong></p><p><strong>4.1 Linux 下 Nand Flash 调用关系</strong></p><p><strong>4.1.1 Nand Flash 设备添加时数据结构包含关系</strong></p><p>struct mtd_partition <strong>partition_info[]</strong></p><p>--> struct s3c2410_nand_<strong>set nandset</strong></p><p>--> struct s3c2410_platform_nand <strong>superlpplatfrom</strong></p><p>--> struct platform_device <strong>s3c_device_nand</strong></p><p><strong>在该数据结构的 name字段的初始化值"s3c2410-nand",必须与 Nand Flash设备驱动注册时</strong></p><p><strong>struct device_driver结构中的 name字段相同,因为 platfrom bus 是依靠名字来匹配的.</strong></p><p><strong>-</strong>-> struct platform_device <strong>*smdk2410_devices[]</strong></p><p><strong>4.1.2 Nand Flash 设备注册时数据结构包含关系</strong></p><p>struct device_driver s3c2410_nand_driver</p><p>-->struct device *dev</p><p>该数据构由系统分配.</p><p>-->struct platform_device *pdev</p><p>-->struct s3c2410_platform_nand *plat</p><p>-->struct s3c2410_nand_set nset</p><p>-->struct mtd_partition</p><p><strong>4.1.3 当发生系统调用时数据结构调用关系</strong></p><p>struct mtd_info它的*priv指向 chip</p><p>-->struct nand_chip</p><p>它的*priv指向 nmtd</p><p>-->struct s3c2410_nand_mtd</p><p>它是 s3c2410_nand_info 的一个字段</p><p>-->s3c2410_nand_info</p><p>它被设为 Nand Flash设备驱动的私有数据结构,在 Nand Flash设备驱动注册时分配空间.</p><p>-->struct device</p><p><strong>4.2 Linux 下 Nand Flash 驱动主要数据结构说明</strong></p><p><strong>4.2.1 s3c2410 专有数据结构</strong></p><p>1. s3c2410_nand_set</p><p>struct s3c2410_nand_set {</p><p>int nr_chips; /* 芯片的数目 */</p><p>int nr_partitions; /* 分区的数目 */</p><p>char *name; /* 集合名称 */</p><p>int <strong>nr_map; /* 可选, 底层逻辑到物理的芯片数目 */</strong></p><p>struct mtd_partition <strong>partitions; /* 分区列表 */</strong></p><p>};</p><p>2. s3c2410_platform_and</p><p>struct s3c2410_platform_nand {</p><p>/* timing information for controller, all times in nanoseconds */</p><p>int tacls; /* 从 CLE/ALE有效到 nWE/nOE 的时间 */</p><p>int twrph0; /* nWE/nOE 的有效时间 */</p><p>int twrph1; /* 从释放 CLE/ALE到 nWE/nOE 不活动的时间 */</p><p>int nr_sets; /* 集合数目 */</p><p>struct s3c2410_nand_set <strong>sets; /* 集合列表 */</strong></p><p><strong>/* 根据芯片编号选择有效集合 */</strong></p><p>void (*select_chip)(struct s3c2410_nand_set <strong>, int chip);</strong></p><p>};</p><p>3. s3c2410_nand_mtd</p><p>在 drivers/mtd/nand/s3c2410.c 中,</p><p>struct s3c2410_nand_mtd {</p><p>struct mtd_info mtd; /* MTD 信息 */</p><p>struct nand_chip chip; /* nand flash 芯片信息 */</p><p>struct s3c2410_nand_set <strong>set; /*</strong> nand flash 集合 */</p><p>struct s3c2410_nand_info *info; /* nand flash 信息 */</p><p>int scan_res;</p><p>};</p><p>4. s3c2410_nand_info</p><p>struct s3c2410_nand_info {</p><p>/* mtd info */</p><p>struct nand_hw_control controller; /* 硬件控制器 */</p><p>struct s3c2410_nand_mtd *mtds; /* MTD 设备表 */</p><p>struct s3c2410_platform_nand <strong>platform; /* Nand 设备的平台 */</strong> /* device info */</p><p>struct device *device; /* 设备指针 */</p><p>struct resource *area; /* 资源指针 */</p><p>struct clk *clk; /* Nand Flash 时钟 */</p><p>void __iomem *regs; /* 寄存器基地址(map后的逻辑地址) */</p><p>int mtd_count; /* MTD的数目 */</p><p>unsigned char is_s3c2440;</p><p>};</p><p>5. struct clk</p><p>在 arch/arm/mach­s3c2410/clock.h 中</p><p>struct clk {</p><p>struct list_head list; /* clock 列表结点 */</p><p>struct module *owner; /* 所属模块 */</p><p>struct clk *parent; /* 父结点 */</p><p>const char *name; /* 名称 */</p><p>int id; /* 编号 */</p><p>atomic_t used; /* 使用者计数 */</p><p>unsigned long rate; /* 时钟速率 */</p><p>unsigned long ctrlbit; /* 控制位 */</p><p>int (*enable)(struct clk *, int enable); /* Clock 打开方法 */</p><p>};</p><p><strong>4.2.2 Linux 通用数据结构说明</strong></p><p>1. device_driver</p><p>include/linux/device.h</p><p>struct device_driver {</p><p>const char * name; <strong>/* 驱动名称 */</strong></p><p>struct bus_type * bus; /* 总线类型 */</p><p>struct completion unloaded; /* 卸载事件通知机制 */</p><p>struct kobject kobj; /* sys中的对象 */</p><p>struct klist klist_devices; /* 设备列表 */</p><p>struct klist_node knode_bus; /* 总线结点列表 */</p><p>struct module * owner;/* 所有者 */</p><p>/* 设备驱动通用方法 */</p><p>int (*probe) (struct device * dev); /* 探测设备 */</p><p>int (*remove) (struct device * dev); /* 移除设备 */</p><p>void (*shutdown) (struct device * dev); /* 关闭设备 */</p><p>/* 挂起设备 */</p><p>int (*suspend) (struct device * dev, pm_message_t state, u32 level);</p><p>int (*resume) (struct device * dev, u32 level); /* 恢复 */</p><p>};</p><p>2. platform_device</p><p>include/linux/device.h</p><p>struct platform_device {</p><p>const char * name; /* 名称 */</p><p>u32 id; /* 设备编号, -1表示不支持同类多个设备 */</p><p>struct device dev; /* 设备 */</p><p>u32 num_resources; /* 资源数 */</p><p>struct resource * resource; /* 资源列表 */};</p><p>3. resource</p><p>struct resource {</p><p>const char <strong>name; /* 资源名称 */</strong></p><p>unsigned long start, end; /* 开始位置和结束位置 */</p><p>unsigned long flags; /* 资源类型 */</p><p>/* 资源在资源树中的父亲,兄弟和孩子 */</p><p>struct resource *parent, *sibling, *child;</p><p>};</p><p>4. device</p><p>include/linux/device.h</p><p>struct device {</p><p>struct klist klist_children; /* 在设备列表中的孩子列表 */</p><p>struct klist_node knode_parent; /* 兄弟结点 */</p><p>struct klist_node knode_driver; /* 驱动结点 */</p><p>struct klist_node knode_bus; /* 总线结点 */</p><p>struct device <strong>parent; /* 父亲 */</strong></p><p>struct kobject kobj; /* sys结点 */</p><p>char bus_id[BUS_ID_SIZE];</p><p>struct semaphore sem; /* 同步驱动的信号量 */</p><p>struct bus_type * bus; /* 总线类型 */</p><p>struct device_driver *driver; /* 设备驱动 */</p><p>void *driver_data; /* 驱动的私有数据 */</p><p>void *platform_data; /* 平台指定的数据,为 device核心驱动保留 */</p><p>void *firmware_data; /* 固件指定的数据,为 device核心驱动保留 */</p><p>struct dev_pm_info power; /* 设备电源管理信息 */</p><p>u64 *dma_mask; /* DMA掩码 */</p><p>u64 coherent_dma_mask;</p><p>struct list_head dma_pools; /* DMA缓冲池 */</p><p>struct dma_coherent_mem *dma_mem; /* 连续 DMA 内存的起始位置 */</p><p>void (*release)(struct device * dev); /* 释放设置方法 */</p><p>};</p><p>5. nand_hw_control</p><p>include/linux/mtd/nand.h</p><p>struct nand_hw_control {</p><p>spinlock_t lock; /* 自旋锁,用于硬件控制 */</p><p>struct nand_chip *active; /* 正在处理 MTD 设备 */</p><p>wait_queue_head_t wq; /* 等待队列 */</p><p>};</p><p>6. nand_chip</p><p>include/linux/mtd/nand.h</p><p>struct nand_chip {</p><p>void __iomem *IO_ADDR_R; /* 读地址 */</p><p>void __iomem *IO_ADDR_W; /* 写地址 */ /* 字节操作 */</p><p>u_char (*read_byte)(struct mtd_info *mtd); /* 读一个字节 */</p><p>void (*write_byte)(struct mtd_info *mtd, u_char byte); /* 写一个字节 */</p><p>/* 双字节操作 */</p><p>u16 (*read_word)(struct mtd_info <strong>mtd); /* 读一个字 */</strong></p><p>void (*write_word)(struct mtd_info *mtd, u16 word); /* 写一个字 */</p><p>/* buffer操作 */</p><p>void (*write_buf)(struct mtd_info *mtd, const u_char *buf, int len);</p><p>void (*read_buf)(struct mtd_info *mtd, u_char *buf, int len);</p><p>int (*verify_buf)(struct mtd_info *mtd, const u_char *buf, int len);</p><p>/* 选择一个操作芯片 */</p><p>void (*select_chip)(struct mtd_info *mtd, int chip);</p><p>/* 坏块检查操作 */</p><p>int (*block_bad)(struct mtd_info *mtd, loff_t ofs, int getchip);</p><p>/* 坏块标记操作 */</p><p>int (*block_markbad)(struct mtd_info *mtd, loff_t ofs);</p><p>/* 硬件控制操作 */</p><p>void (*hwcontrol)(struct mtd_info *mtd, int cmd);</p><p>/* 设备准备操作 */</p><p>int (*dev_ready)(struct mtd_info *mtd);</p><p>/* 命令发送操作 */</p><p>void (*cmdfunc)(struct mtd_info *mtd, unsigned command, int column, int</p><p>page_addr);</p><p>/* 等待命令完成 */</p><p>int (*waitfunc)(struct mtd_info *mtd, struct nand_chip *this, int state);</p><p>/* 计算 ECC 码操作 */</p><p>int (*calculate_ecc)(struct mtd_info *mtd, const u_char *dat, u_char</p><p>*ecc_code);</p><p>/* 数据纠错操作 */</p><p>int (*correct_data)(struct mtd_info *mtd, u_char *dat, u_char *read_ecc,</p><p>u_char *calc_ecc);</p><p>/* 开启硬件 ECC */</p><p>void (*enable_hwecc)(struct mtd_info *mtd, int mode);</p><p>/* 擦除操作 */</p><p>void (*erase_cmd)(struct mtd_info *mtd, int page);</p><p>/* 检查坏块表 */</p><p>int (*scan_bbt)(struct mtd_info *mtd);</p><p>int eccmode; /* ECC 模式 */</p><p>int eccsize; /* ECC 计算时使用的字节数 */</p><p>int eccbytes; /* ECC 码的字节数 */</p><p>int eccsteps; /* ECC 码计算的步骤数 */</p><p>int chip_delay; /* 芯片的延迟时间 */</p><p>spinlock_t chip_lock; /* 芯片访问的自旋锁 */</p><p>wait_queue_head_t wq; /* 芯片访问的等待队列 */</p><p>nand_state_t state; /* Nand Flash状态 */</p><p>int page_shift; /* 页右移的位数,即 column地址位数 */</p><p>int phys_erase_shift; /* 块右移的位数, 即 column和页一共的地址位数 */</p><p>int bbt_erase_shift; /* 坏块页表的位数 */</p><p>int chip_shift; /* 该芯片总共的地址位数 */</p><p>u_char *data_buf; /* 数据缓冲区 */</p><p>u_char *oob_buf; /* oob 缓冲区 */</p><p>int oobdirty; /* oob 缓冲区是否需要重新初始化 */</p><p>u_char *data_poi; /* 数据缓冲区指针 */</p><p>unsigned int options; /* 芯片专有选项 */</p><p>int badblockpos;/* 坏块标示字节在 OOB 中的位置 */</p><p>int numchips; /* 芯片的个数 */ unsigned long chipsize; /* 在多个芯片组中, 一个芯片的大小 */</p><p>int pagemask; /* 每个芯片页数的屏蔽字, 通过它取出每个芯片包含多少个页 */</p><p>int pagebuf; /* 在页缓冲区中的页号 */</p><p>struct nand_oobinfo *autooob; /* oob 信息 */</p><p>uint8_t *bbt; /* 坏块页表 */</p><p>struct nand_bbt_descr *bbt_td; /* 坏块表描述 */</p><p>struct nand_bbt_descr *bbt_md; /* 坏块表镜像描述 */</p><p>struct nand_bbt_descr *badblock_pattern; /* 坏块检测模板 */</p><p>struct nand_hw_control *controller; /* 硬件控制 */</p><p>void *priv; /* 私有数据结构 */</p><p>/* 进行附加错误检查 */</p><p>int (*errstat)(struct mtd_info *mtd, struct nand_chip *this, int state, int</p><p>status, int page);</p><p>};</p><p>7. mtd_info</p><p>include/linux/mtd/mtd.h</p><p>struct mtd_info {</p><p>u_char type; /* 设备类型 */</p><p>u_int32_t flags; /* 设备标志位组 */</p><p>u_int32_t size; /* 总共设备的大小 */</p><p>u_int32_t erasesize; /* 擦除块的大小 */</p><p>u_int32_t oobblock; /* OOB块的大小,如：512 个字节有一个 OOB */</p><p>u_int32_t oobsize; /* OOB数据的大小,如:一个 OOB 块有 16 个字节 */</p><p>u_int32_t ecctype; /* ECC 校验的类型 */</p><p>u_int32_t eccsize; /* ECC 码的大小 */</p><p>char *name; /* 设备名称 */</p><p>int index; /* 设备编号 */</p><p>/* oobinfo 信息,它可以通过 MEMSETOOBINFO ioctl 命令来设置 */</p><p>struct nand_oobinfo oobinfo;</p><p>u_int32_t oobavail; /* OOB区的有效字节数,为文件系统提供 */</p><p>/* 数据擦除边界信息 */</p><p>int numeraseregions;</p><p>struct mtd_erase_region_info *eraseregions;</p><p>u_int32_t bank_size; /* 保留 */</p><p>/* 擦除操作 */</p><p>int (*erase) (struct mtd_info *mtd, struct erase_info *instr);</p><p>/* 指向某个执行代码位置 */</p><p>int (*point) (struct mtd_info *mtd, loff_t from,</p><p>size_t len, size_t *retlen, u_char **mtdbuf);</p><p>/* 取消指向 */</p><p>void (*unpoint) (struct mtd_info *mtd, u_char * addr, loff_t from, size_t len);</p><p>/* 读/写操作 */</p><p>int (*read) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);</p><p>int (*write) (struct mtd_info *mtd, loff_t to, size_t len,</p><p>size_t *retlen, const u_char *buf);</p><p>/* 带 ECC 码的读/写操作 */</p><p>int (*read_ecc) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,</p><p>u_char *buf, u_char *eccbuf, struct nand_oobinfo *oobsel);</p><p>int (*write_ecc) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,</p><p>const u_char *buf, u_char *eccbuf, struct nand_oobinfo *oobsel); /* 带 OOB 码的读/写操作 */</p><p>int (*read_oob) (struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen,</p><p>u_char *buf);</p><p>int (*write_oob) (struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen,</p><p>const u_char *buf);</p><p>/* 提供访问保护寄存器区的方法 */</p><p>int (*get_fact_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);</p><p>int (*read_fact_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len,</p><p>size_t *retlen, u_char *buf);</p><p>int (*get_user_prot_info) (struct mtd_info *mtd, struct otp_info *buf, size_t len);</p><p>int (*read_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len,</p><p>size_t *retlen, u_char *buf);</p><p>int (*write_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len,</p><p>size_t *retlen, u_char *buf);</p><p>int (*lock_user_prot_reg) (struct mtd_info *mtd, loff_t from, size_t len);</p><p>/* 提供 readv和 writev 方法 */</p><p>int (*readv) (struct mtd_info *mtd, struct kvec *vecs, unsigned long count,</p><p>loff_t from, size_t *retlen);</p><p>int (*readv_ecc) (struct mtd_info *mtd, struct kvec *vecs, unsigned long count,</p><p>loff_t from, size_t *retlen, u_char *eccbuf,</p><p>struct nand_oobinfo *oobsel);</p><p>int (*writev) (struct mtd_info *mtd, const struct kvec *vecs,</p><p>unsigned long count, loff_t to, size_t *retlen);</p><p>int (*writev_ecc) (struct mtd_info *mtd, const struct kvec *vecs,</p><p>unsigned long count, loff_t to, size_t *retlen,</p><p>u_char *eccbuf, struct nand_oobinfo *oobsel);</p><p>/* 同步操作 */</p><p>void (*sync) (struct mtd_info *mtd);</p><p>/* 芯片级支持的加/解锁操作 */</p><p>int (*lock) (struct mtd_info *mtd, loff_t ofs, size_t len);</p><p>int (*unlock) (struct mtd_info *mtd, loff_t ofs, size_t len);</p><p>/* 电源管理操作 */</p><p>int (*suspend) (struct mtd_info *mtd);</p><p>void (*resume) (struct mtd_info *mtd);</p><p>/* 坏块管理操作 */</p><p>int (*block_isbad) (struct mtd_info *mtd, loff_t ofs);</p><p>int (*block_markbad) (struct mtd_info *mtd, loff_t ofs);</p><p>/* 重启前的通知事件 */</p><p>struct notifier_block reboot_notifier;</p><p>void *priv; /* 私有数据结构 */</p><p>struct module *owner; /* 模块所有者 */</p><p>int usecount; /* 使用次数 */</p><p>};</p><p><strong>4.3 Linux 下 Nand Flash 驱动说明4.3.1 注册 driver_register</strong></p><p>通过 module_init(s3c2410_nand_init);注册 Nand Flash 驱动. 在 s3c2410_nand_init ()中通过 driver_register()注册</p><p>s3c2410_nand_driver驱动程序,如下所示:</p><p>static struct device_driver s3c2410_nand_driver = {</p><p>.name = "s3c2410-nand",</p><p>.bus = &platform_bus_type, /* 在 drivers/base/platform.c中定义 */</p><p>.probe = s3c2410_nand_probe,</p><p>.remove = s3c2410_nand_remove,</p><p>};</p><p><strong>4.3.2 探测设备 probe</strong></p><p>在注册的 Nand Flash驱动程序中, probe 方法为 s3c2410_nand_probe(). s3c2410_nand_probe()再调用</p><p>s3c24xx_nand_probe(). 在该函数中, 把*info 作为 Nand Flash 驱动的私有数据结构, 并通过 dev_set_drvdata(dev,</p><p>info)把*info 保存在*device 的*driver_data 字段中.然后通过 clk_get(dev, "nand")获取 Nand Flash的时钟资</p><p>源, clk_use(info->clk)增加时钟资源的使用计数, clk_enable(info->clk)开启资源.填写*info 的其它字段,</p><p>其中包括:</p><p>1. 通过 request_mem_region()为 Nand Flash 寄存器区申请 I/O 内存地址空间区,并通过 ioremap()把它映射到虚</p><p>拟地址空间.</p><p>2. 调用 s3c2410_nand_inithw()初始化 Nand Flash 控制器.</p><p>3. 为 mtd 设备分配设备信息的存储空间.</p><p>4. 对当前 mtd 设备,调用 s3c2410_nand_init_chip()进行初始化.</p><p>5. 对当前 mtd 设备, 调用 nand_scan()检测 Nand Flash 芯片, nand_scan()函数在 drivers/mtd/nand/nand_base.c 中</p><p>定义.该函数的作用是初始化 struct nand_chip 中一些方法, 并从 Nand Flash 中读取芯片 ID, 并初始化 struct</p><p>mtd_info 中的方法.</p><p>6. 对当前 mtd 设备,加入其分区信息.</p><p>7. 如果还有更多 mtd 设备,到 4 执行.</p><p><strong>4.3.3 初始化 Nand Flash 控制器</strong></p><p>s3c2410_nand_inithw()函数会初始化 Nand Flash 控制器, 通过设置 Nand Flash 控制寄存器(S3C2410_NFCONF)来</p><p>完成, 这里最重要的是根据 S3C2410 的 PCLK 计算出 tacls, twrph0 以及 twrph1 值.</p><p><strong>4.3.4 移除设备</strong></p><p>s3c2410_nand_remove()当设备被移除时,被 device 核心驱动调用.它完成的主要工作如下:</p><p>1. 把*device 的*driver_data 字段置空.</p><p>2. 释放 mtd 设备信息.</p><p>3. 释放 clk 资源.</p><p>4. 通过 iounmap()取消映地址空间.</p><p>5. 释放申请的 I/O 内存资源.</p><p>6. 释放设备私有数据*info 的空间.</p><p><strong>4.3.5 Nand Flash 芯片初始化</strong></p><p>s3c2410_nand_init_chip()初始化 struct nand_chip 中的一些主要字段以及方法.其中主要包括的方法有：</p><p>1. s3c2410_nand_hwcontrol(); 硬件控制</p><p>2. s3c2410_nand_devready(); 设备是否准备好</p><p>3. s3c2410_nand_write_buf(); 写一个 buffer 到 nand flash</p><p>4. s3c2410_nand_read_buf(); 读一个 buffer 到 nand flash</p><p>5. s3c2410_nand_select_chip(); 选择操作芯片</p><p>如果支持 ECC 硬件校验,还设置如下方法： 1. s3c2410_nand_correct_data(); 通过 ECC 码校正数据</p><p>2. s3c2410_nand_enable_hwecc(); 开启硬件 ECC 检查</p><p>3. s3c2410_nand_calculate_ecc(); 计算 ECC 码</p><p><strong>4.3.6 读 Nand Flash</strong></p><p>当对 nand flash 的设备文件(nand flash 在/dev 下对应的文件)执行系统调用 read(),或在某个文件系统中对该</p><p>设备进行读操作时. 会调用 struct mtd_info 中的 read方法,他们缺省调用函数为 nand_read(),在</p><p>drivers/mtd/nand/nand_base.c中定义.nand_read()调用 nand_do_read_ecc(),执行读操作. 在</p><p>nand_do_read_ecc()函数中,主要完成如下几项工作：</p><p>1. 会调用在 nand flash驱动中对 struct nand_chip 重载的 select_chip 方法,即</p><p>s3c2410_nand_select_chip()选择要操作的 MTD 芯片.</p><p>2. 会调用在 struct nand_chip 中系统缺省的方法 cmdfunc 发送读命令到 nand flash.</p><p>3. 会调用在 nand flash驱动中对 struct nand_chip 重载的 read_buf(),即 s3c2410_nand_read_buf()</p><p>从 Nand Flash的控制器的数据寄存器中读出数据.</p><p>4. 如果有必要的话,会调用在 nand flash驱动中对 struct nand_chip 重载的</p><p>enable_hwecc,correct_data 以及 calculate_ecc方法,进行数据 ECC 校验。</p><p><strong>4.3.7 写 Nand Flash</strong></p><p>当对 nand flash 的设备文件(nand flash 在/dev 下对应的文件)执行系统调用 write(),或在某个文件系统中对该设备</p><p>进行读操作时, 会调用 struct mtd_info 中 write 方法,他们缺省调用函数为 nand_write(),这两个函数在</p><p>drivers/mtd/nand/nand_base.c中定义. nand_write()调用 nand_write_ecc(),执行写操作.在</p><p>nand_do_write_ecc()函数中,主要完成如下几项工作：</p><p>1. 会调用在 nand flash驱动中对 struct nand_chip 重载的 select_chip 方法,即</p><p>s3c2410_nand_select_chip()选择要操作的 MTD 芯片.</p><p>2. 调用 nand_write_page()写一个页.</p><p>3. 在 nand_write_page()中,会调用在 struct nand_chip 中系统缺省的方法 cmdfunc 发送写命令</p><p>到 nand flash.</p><p>4. 在 nand_write_page()中,会调用在 nand flash驱动中对 struct nand_chip 重载的</p><p>write_buf(),即 s3c2410_nand_write_buf()从 Nand Flash的控制器的数据寄存器中写入数据.</p><p>5. 在 nand_write_page()中,会调用在 nand flash驱动中对 struct nand_chip 重载 waitfunc 方法,</p><p>该方法调用系统缺省函数 nand_wait(),该方法获取操作状态,并等待 nand flash操作完成.等</p><p>待操作完成,是调用 nand flash驱动中对 struct nand_chip 中重载的 dev_ready方法,即</p><p>s3c2410_nand_devready()函数.</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','系统','BOOT'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>