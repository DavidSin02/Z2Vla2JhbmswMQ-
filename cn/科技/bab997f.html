<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>【JDK并发基础】Java内存模型详解 | 极客快訊</title><meta property="og:title" content="【JDK并发基础】Java内存模型详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8d7aa911ada04b3498fa2ececb4b7ab8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bab997f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bab997f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bab997f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bab997f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bab997f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bab997f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bab997f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bab997f.html><meta property="article:published_time" content="2020-10-29T21:04:05+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:05+08:00"><meta name=Keywords content><meta name=description content="【JDK并发基础】Java内存模型详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/bab997f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>【JDK并发基础】Java内存模型详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>无论你是Java还是C，或者其他编程语言编写高并发程序时，都或多或少的会涉及内存模型。高并发程序下数据访问的一致性和安全性受到挑战，为了保证程序正确执行，Java内存模型（以下简称JMM）由此而诞生。如果不理解JMM，就会对内存可见性，有序性等问题出现时无从下手。本文将从以下几个方面进行JMM的说明：</p><p>1.内存模型的相关概念</p><p>2.可见性</p><p>3.有序性</p><p>4.原子性</p><p><strong>1.内存模型的相关概念</strong></p><p><strong>1.1 Java虚拟机运行时数据区</strong></p><p>在共享内存模型里，线程间的是通过读-写内存中的公共状态进行隐式通信的，那线程在Java虚拟机里是什么位置呢?Java虚拟机运行时数据区：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8d7aa911ada04b3498fa2ececb4b7ab8><p class=pgc-img-caption></p></div><p>堆：解决的是对象数据存储问题。</p><p><strong></strong>方法区：是先决条件，储存已经被虚拟机加载过的类信息，常量，静态变量等信息。它和堆描述的是Java共享数据（主）内存模型。</p><p>虚拟机栈：栈解决的是程序运行的问题，即程序如何处理数据。从图中可以看栈是线程私有的，函数的调用要用栈实现，函数运算并改变栈中存放数据的引用。所以虚拟机栈描述的是Java执行的内存模型： 每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、 操作数栈、 动态链接、 方法出口等信息。</p><p>本地方法栈：和虚拟机栈类似，虚拟机栈为Java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。程序计数器：cpu中的寄存器，它包含当前正在执行的指令的地址（位置）。（寄存器是cpu组成部分，暂存指令、数据和地址--百度百科）。</p><p><strong>1.2 缓存一致性协议</strong></p><p>CPU在执行指令过程中，势必会牵扯到变量的读和写。共享变量存储到内存中，CPU通过高速缓存(Cache)与内存进行通信，但是CPU执行指令比CPU从内存读写共享变量要快的多。而且在多核CPU时代，每条线程可能运行在不同的CPU里。比如：</p><pre>i=i+1;</pre><p>两个线程读取i的值并在自己的CPU的高速缓存中+1操作，当第一个线程运算完了存到高速缓存还没有刷新到内存中，线程二读取到i还是0，也做了+1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p><p>最终结果i的值是1，而不是2。这就是缓存一致性问题。怎么解决呢?当CPU写数据时，发现其他CPU也在操作这个共享变量，会让其他CPU的缓存无效且从内存中重新获取。这个缓存一致性协议最出名的就是Intel 的MESI协议。</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f3030f89cef14fd0b2c49f1311996cb0><p class=pgc-img-caption></p></div><p><strong>2.可见性</strong></p><ul><li>可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改。</li></ul><p>程序在执行过程中任何时候都可能产生可见性问题，这里只讨论JMM相关的可见性问题。Java线程之间的通信由JMM控制，JMM的抽象示意图如下：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/10ef33e77bba4adeb37334366cd6201b><p class=pgc-img-caption></p></div><p>本地内存A和B有主内存中共享变量x的副本。假设初始时三个内存中的x值都为0。线程A修改x=1后-->主内存修改为x=1-->最后由B修改x=1。这些步骤实质上就是A在给B发消息，且要通过主内存，及JMM通过控制主内存在控制线程之间的内存可见性。</p><p>我们来看一个Java虚拟机层面产生的可见性问题：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5697decf981543e5a596ee10a58bbafa><p class=pgc-img-caption></p></div><p>运行结果:</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/36b5528a6c2a4a0393ac3851f506b2e1><p class=pgc-img-caption></p></div><p>为什么循环没停止，且没有打印System.out.println("end and print,i=" + i);这句话？原因是主线程调用把isStoped值修改为true对visibility线程并不可见，所以主线程走完了，而visibility线程一直在做i++操作。解决上述变量不可见性的方法：用volatile关键字修饰isStoped变量，它会强制性的从主内存中取值，从而避免本地内存变量不可见问题。</p><p><strong>3.有序性</strong></p><ul><li>即程序执行的顺序按照代码的先后顺序执行。</li></ul><p>很奇怪？其实我们写代码时只是看上去有序，代码在编译成指令执行时会进行重排序保证程序运行的高效率。 因为下面的语句1和语句2没有什么数据依赖性，可能会打乱顺序执行：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18348819f478407b90ffecd6a9e87cdc><p class=pgc-img-caption></p></div><p>CPU执行一条指令的时候一般有：取指IF-->译码和读取寄存器操作数ID-->执行或者有效地址计算EX(用到CPU中逻辑运算单元)-->存储器访问MEM-->写回WB(用到寄存器)</p><p>比如两条指令执行顺序由上到下：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/02c4bceff02a4e34b3b2a5d16d9ed083><p class=pgc-img-caption></p></div><p>当我们运行语句1和语句2时有：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2ca24c970bfa4725a475966e7d803e85><p class=pgc-img-caption></p></div><p>上图产生气泡X会严重影响效率，所以会把没有相关性的操作加入到有气泡操作里，这就是处理器为了提高程序运行效率，对输入代码进行优化：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b2f9c90188145b28addeb2fe8665944><p class=pgc-img-caption></p></div><p>一般认为CPU的指令都是原子操作，虽然重排序不会影响单个线程内程序执行的结果，但是多线程会有影响：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1389eb74a5be4697a89da09e51db4d61><p class=pgc-img-caption></p></div><p>一个线程执行write方法，另一个线程检查flag=true时，a=1还未执行，会导致程序运算错误。解决方法还是使用volatile关键字修饰变量。</p><p><strong>4.原子性</strong></p><ul><li>原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其它线程干扰，要么直接就不执行。</li></ul><p>volatile关键字最致命的缺点是不支持原子性。比如count++这样的操作就不是原子性的：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c6640ec5e94045b69776186e9da238ec><p class=pgc-img-caption></p></div><p>count++其实有三个操作：读取count-->做count+1操作-->然后把count+1后的值写回到count里。</p><p>假设有两个线程，当第一个线程读取count=1时，还没进行+1操作，切换到第二个线程，此时第二个线程也读取的是count=1。随后两个线程进行后续+1操作，再赋值回去以后，count不是3，而是2。显然数据出现了不一致性，可以使用上面代码的方法一和方法二加锁或原子类操作：</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b32aca3bd6840e7bdd07ecc7b546621><p class=pgc-img-caption></p></div><p>其实前面或多或少提到了volatile关键字，这里做一些扩展，volatile是如何保证可见性的呢？</p><div class=pgc-img><img alt=【JDK并发基础】Java内存模型详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/22a81008b68d4b58b1a91d968f259804><p class=pgc-img-caption></p></div><p>上述代码在x86处理器通过工具获取JIT编译器生成的汇编指令如下：</p><p>0x01a3deld：movb 》$0×0，0×1104800(%esi)；0x01a3de4>：<strong>lock</strong> add1 $0×0，(%esp)；</p><p>lock指令在多核处理器会引发两件事:</p><p>1.将当前缓存行的数据写回到系统内存。</p><p>2.这个写回内存操作会使其他CPU里缓存了该内存地址的数据无效。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JDK','发基础','Java'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>