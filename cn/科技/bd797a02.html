<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>360技术团队：300行Go代码玩转RPC | 极客快訊</title><meta property="og:title" content="360技术团队：300行Go代码玩转RPC - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bd797a02.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bd797a02.html><meta property="article:published_time" content="2020-10-29T21:09:08+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:08+08:00"><meta name=Keywords content><meta name=description content="360技术团队：300行Go代码玩转RPC"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/bd797a02.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>360技术团队：300行Go代码玩转RPC</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>在本篇文章中将通过用300行纯Golang编写简单的RPC框架来解释RPC。希望能帮助大家梳理RPC相关知识点。</p></blockquote><p>我们通过从头开始在Golang中构建一个简单的RPC框架来学习RPC基础构成。</p><h1><strong>什么是RPC</strong></h1><p>简单地说，服务A想调用服务B的函数。但是这两个服务不在同一个内存空间中。所以不能直接调用它。</p><p>因此，为了实现这个调用，我们需要表达如何调用以及如何通过网络传递通信的语义。</p><p>让我们考虑一下，当我们可以在相同的内存空间（本地调用）中运行时，我们要怎么做。</p><pre>type User struct {	Name string	Age int}var userDB = map[int]User{	1: User{"Ankur", 85},	9: User{"Anand", 25},	8: User{"Ankur Anand", 27},}func QueryUser(id int) (User, error) {	if u, ok := userDB[id]; ok {		return u, nil	}	return User{}, fmt.Errorf("id %d not in user db", id)}func main() {	u , err := QueryUser(8)	if err != nil {		fmt.Println(err)		return	}	fmt.Printf("name: %s, age: %d \n", u.Name, u.Age)}</pre><p>现在我们如何在网络上进行相同的函数调用</p><p>客户端将通过网络调用 QueryUser(id int) 函数，并且将有一个服务端提供对该函数的调用，并返回响应 User{"Name", id}, nil。</p><h1><strong>网络传输数据格式</strong></h1><p>我们将采用TLV（定长报头+变长消息体）编码方案来规范 tcp 上的数据传输。稍后会详细介绍</p><p>在通过网络发送数据之前，我们需要定义如何通过网络发送数据的结构。</p><p>这有助于我们定义一个通用协议，客户端和服务端都可以理解这个协议。（protobuf IDL定义了服务端和客户端都能理解的内容）。</p><p>因此，服务端接收到的数据、要调用的函数名和参数列表，或者来自客户端的数据都需要传递这些参数。</p><p>另外，让我们约定第二个返回值的类型为 error，表示RPC调用结果。</p><pre>// RPC数据传输格式type RPCdata struct {	Name string // name of the function	Args []interface{} // request's or response's body expect error.	Err string // Error any executing remote server}</pre><p>现在我们有了一个格式，我们需要序列化它以便我们可以通过网络发送它。在本例中，我们将使用 go 默认的二进制序列化协议进行编码和解码。</p><pre>// be sent over the network.func Encode(data RPCdata) ([]byte, error) {	var buf bytes.Buffer	encoder := gob.NewEncoder(&amp;buf)	if err := encoder.Encode(data); err != nil {		return nil, err	}	return buf.Bytes(), nil}// Decode the binary data into the Go structfunc Decode(b []byte) (RPCdata, error) {	buf := bytes.NewBuffer(b)	decoder := gob.NewDecoder(buf)	var data RPCdata	if err := decoder.Decode(&amp;data); err != nil {		return Data{}, err	}	return data, nil}</pre><h1>网络传输</h1><p>选择 TLV 协议的原因是由于其非常容易实现，同时也完成了我们需要识别的数据读取的长度，因为我们需要确定这个请求读取的字节数的传入请求流。发送和接收都执行相同的操作。</p><pre>// Transport will use TLV protocoltype Transport struct {	conn net.Conn // Conn is a generic stream-oriented network connection.}// NewTransport creates a Transportfunc NewTransport(conn net.Conn) *Transport {	return &amp;Transport{conn}}// Send TLV data over the networkfunc (t *Transport) Send(data []byte) error {	// we will need 4 more byte then the len of data	// as TLV header is 4bytes and in this header	// we will encode how much byte of data	// we are sending for this request.	buf := make([]byte, 4+len(data))	binary.BigEndian.PutUint32(buf[:4], uint32(len(data)))	copy(buf[4:], data)	_, err := t.conn.Write(buf)	if err != nil {		return err	}	return nil}// Read TLV sent over the wirefunc (t *Transport) Read() ([]byte, error) {	header := make([]byte, 4)	_, err := io.ReadFull(t.conn, header)	if err != nil {		return nil, err	}	dataLen := binary.BigEndian.Uint32(header)	data := make([]byte, dataLen)	_, err = io.ReadFull(t.conn, data)	if err != nil {		return nil, err	}	return data, nil}</pre><p>现在我们已经定义了数据格式和传输协议。下面我们还需要RPC服务器和RPC客户端的实现。</p><h1>RPC函数</h1><p>RPC服务器将接收具有函数名的 RPCData。因此，我们需要维护和映射包含函数名到实际函数映射的函数</p><pre>// RPCServer ...type RPCServer struct {	addr string	funcs map[string] reflect.Value}// Register the name of the function and its entriesfunc (s *RPCServer) Register(fnName string, fFunc interface{}) {	if _,ok := s.funcs[fnName]; ok {		return	}	s.funcs[fnName] = reflect.ValueOf(fFunc)}</pre><p>现在我们已经注册了 func，当我们收到请求时，我们将检查函数执行期间传递的func的名称是否存在。然后执行相应的操作</p><pre>// Execute the given function if presentfunc (s *RPCServer) Execute(req RPCdata) RPCdata {	// get method by name	f, ok := s.funcs[req.Name]	if !ok {		// since method is not present		e := fmt.Sprintf("func %s not Registered", req.Name)		log.Println(e)		return RPCdata{Name: req.Name, Args: nil, Err: e}	}	log.Printf("func %s is called\n", req.Name)	// unpackage request arguments	inArgs := make([]reflect.Value, len(req.Args))	for i := range req.Args {		inArgs[i] = reflect.ValueOf(req.Args[i])	}	// invoke requested method	out := f.Call(inArgs)	// now since we have followed the function signature style where last argument will be an error	// so we will pack the response arguments expect error.	resArgs := make([]interface{}, len(out) - 1)	for i := 0; i &lt; len(out) - 1; i ++ {		// Interface returns the constant value stored in v as an interface{}.		resArgs[i] = out[i].Interface()	}	// pack error argument	var er string	if e, ok := out[len(out) - 1].Interface().(error); ok {		// convert the error into error string value		er = e.Error()	}	return RPCdata{Name: req.Name, Args: resArgs, Err: er}}</pre><h1>RPC客户端</h1><p>由于函数的具体实现在服务器端，客户端只有函数的原型，所以我们需要调用函数的完整原型，这样我们才能调用它。</p><pre>func (c *Client) callRPC(rpcName string, fPtr interface{}) {	container := reflect.ValueOf(fPtr).Elem()	f := func(req []reflect.Value) []reflect.Value {		cReqTransport := NewTransport(c.conn)		errorHandler := func(err error) []reflect.Value {			outArgs := make([]reflect.Value, container.Type().NumOut())			for i := 0; i &lt; len(outArgs)-1; i++ {				outArgs[i] = reflect.Zero(container.Type().Out(i))			}			outArgs[len(outArgs)-1] = reflect.ValueOf(&amp;err).Elem()			return outArgs		}		// Process input parameters		inArgs := make([]interface{}, 0, len(req))		for _, arg := range req {			inArgs = append(inArgs, arg.Interface())		}		// ReqRPC		reqRPC := RPCdata{Name: rpcName, Args: inArgs}		b, err := Encode(reqRPC)		if err != nil {			panic(err)		}		err = cReqTransport.Send(b)		if err != nil {			return errorHandler(err)		}		// receive response from server		rsp, err := cReqTransport.Read()		if err != nil { // local network error or decode error			return errorHandler(err)		}		rspDecode, _ := Decode(rsp)		if rspDecode.Err != "" { // remote server error			return errorHandler(errors.New(rspDecode.Err))		}		if len(rspDecode.Args) == 0 {			rspDecode.Args = make([]interface{}, container.Type().NumOut())		}		// unpackage response arguments		numOut := container.Type().NumOut()		outArgs := make([]reflect.Value, numOut)		for i := 0; i &lt; numOut; i++ {			if i != numOut-1 { // unpackage arguments (except error)				if rspDecode.Args[i] == nil { // if argument is nil (gob will ignore "Zero" in transmission), set "Zero" value					outArgs[i] = reflect.Zero(container.Type().Out(i))				} else {					outArgs[i] = reflect.ValueOf(rspDecode.Args[i])				}			} else { // unpackage error argument				outArgs[i] = reflect.Zero(container.Type().Out(i))			}		}		return outArgs	}	container.Set(reflect.MakeFunc(container.Type(), f))}</pre><h1>测试一下我们的框架</h1><pre>package mainimport (	"encoding/gob"	"fmt"	"net")type User struct {	Name string	Age int}var userDB = map[int]User{	1: User{"Ankur", 85},	9: User{"Anand", 25},	8: User{"Ankur Anand", 27},}func QueryUser(id int) (User, error) {	if u, ok := userDB[id]; ok {		return u, nil	}	return User{}, fmt.Errorf("id %d not in user db", id)}func main() {	// new Type needs to be registered	gob.Register(User{})	addr := "localhost:3212"	srv := NewServer(addr)	// start server	srv.Register("QueryUser", QueryUser)	go srv.Run()	// wait for server to start.	time.Sleep(1 * time.Second)	// start client	conn, err := net.Dial("tcp", addr)	if err != nil {		panic(err)	}	cli := NewClient(conn)	var Query func(int) (User, error)	cli.callRPC("QueryUser", &amp;Query)	u, err := Query(1)	if err != nil {		panic(err)	}	fmt.Println(u)	u2, err := Query(8)	if err != nil {		panic(err)	}	fmt.Println(u2)}</pre><p>执行：go run main.go</p><p>输出内容</p><pre>2019/07/23 20:26:18 func QueryUser is called{Ankur 85}2019/07/23 20:26:18 func QueryUser is called{Ankur Anand 27}</pre><h1>总结</h1><p>致此我们简单的RPC框架就实现完成了，旨在帮大家理解RPC的原理及上手简单实践。</p><blockquote><p><strong>原文来自：</strong>360技术团队</p><p><strong>关注TechTree，关注互联网一线大厂技术干货。</strong></p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'360','技术','团队'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>