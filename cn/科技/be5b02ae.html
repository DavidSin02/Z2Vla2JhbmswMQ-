<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Go：Goroutine 的切换过程实际上涉及了什么 | 极客快訊</title><meta property="og:title" content="Go：Goroutine 的切换过程实际上涉及了什么 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/57e063b10f50450190fde2fe07d4d666"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/be5b02ae.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/be5b02ae.html><meta property="article:published_time" content="2020-10-29T21:12:23+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:23+08:00"><meta name=Keywords content><meta name=description content="Go：Goroutine 的切换过程实际上涉及了什么"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/be5b02ae.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Go：Goroutine 的切换过程实际上涉及了什么</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57e063b10f50450190fde2fe07d4d666><p class=pgc-img-caption></p></div><p style=text-align:start>本文基于 Go 1.13 版本。</p><p style=text-align:start>Goroutine 很轻，它只需要 2Kb 的内存堆栈即可运行。另外，它们运行起来也很廉价，将一个 Goroutine 切换到另一个的过程不牵涉到很多的操作。在深入 Goroutine 切换过程之前，让我们回顾一下 Goroutine 的切换在更高的层次上是如何进行的。</p><p style=text-align:start>在继续阅读本文之前，我强烈建议您阅读我的文章 Go：Goroutine、操作系统线程和 CPU 管理 以了解本文中涉及的一些概念。</p><h1 class=pgc-h-arrow-right><strong>案例</strong></h1><p style=text-align:start>Go 根据两种断点将 Goroutine 调度到线程上：</p><ul><li>当 Goroutine 因为系统调用、互斥锁或通道而被阻塞时，goroutine 将进入睡眠模式（等待队列），并允许 Go 调度运行另一个处于就绪状态的 goroutine；</li><li>在函数调用时，如果 Goroutine 必须增加其堆栈，这会使 Go 调度另一个 Goroutine 以避免运行中的 Goroutine 独占 CPU 时间片；</li></ul><p style=text-align:start>在这两种情况下，运行调度程序的 g0 会替换当前的 goroutine，然后选出下一个将要运行的 Goroutine 替换 g0 并在线程上运行。</p><p style=text-align:start>有关 g0 的更多信息，建议您阅读我的文章 Go：特殊的 Goroutine g0 。</p><p style=text-align:start>将一个运行中的 Goroutine 切换到另一个的过程涉及到两个切换：</p><ul><li>将运行中的 g 切换到 g0 ：</li><li>将 g0 切换到下一个将要运行的 g ：</li></ul><p style=text-align:start>在 Go 中，goroutine 的切换相当轻便，其中需要保存的状态仅仅涉及以下两个：</p><ul><li>Goroutine 在停止运行前执行的指令，程序当前要运行的指令是记录在程序计数器（ PC ）中的， Goroutine 稍后将在同一指令处恢复运行；</li><li>Goroutine 的堆栈，以便在再次运行时还原局部变量；</li></ul><p style=text-align:start>让我们看看实际情况下的切换是怎样进行的。</p><h1 class=pgc-h-arrow-right><strong>程序计数器</strong></h1><p style=text-align:start>这里通过基于通道的 生产者/消费者模式 来举例说明，其中一个 Goroutine 产生数据，而另一些则消费数据，代码如下：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/423f4c467b3741f99597abc6a50677f4><p class=pgc-img-caption></p></div><p style=text-align:start>消费者仅仅是打印从 0 到 99 的偶数。我们将注意力放在第一个 goroutine（生产者）上，它将数字添加到缓冲区。当缓冲区已满时，它将在发送消息时被阻塞。此时，Go 必须切换到 g0 并调度另一个 Goroutine 来运行。</p><p style=text-align:start>如前所述，Go 首先需要保存当前执行的指令，以便稍后在同一条指令上恢复 goroutine。程序计数器（ PC ）保存在 Goroutine 的内部结构中：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2678bef3bbb47378088a5599a84642c><p class=pgc-img-caption></p></div><p style=text-align:start>可以通过 go tool objdump 命令找到对应的指令及其地址，这是生产者的指令：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a8fcc0fb28284ec6854c337c11013717><p class=pgc-img-caption></p></div><p style=text-align:start>程序逐条指令的执行直到在函数 runtime.chansend1 处阻塞在通道上。 Go 将当前程序计数器保存到当前 Goroutine 的内部属性中。在我们的示例中，Go 使用运行时的内部地址 0x4268d0 和方法 runtime.chansend1 保存程序计数器：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/732b346b9bb04742ab8d3fd08705953f><p class=pgc-img-caption></p></div><p style=text-align:start>然后，当 g0 唤醒 Goroutine 时，它将在同一指令处继续执行，继续将数值循环的推入通道。现在，让我们将视线移到 Goroutine 切换期间堆栈的管理。</p><h1 class=pgc-h-arrow-right><strong>堆栈</strong></h1><p style=text-align:start>在被阻塞之前，正在运行的 Goroutine 具有其原始堆栈，该堆栈包含临时存储器，例如变量 i ：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/315f670707fa46a3847f684a7210bce2><p class=pgc-img-caption></p></div><p style=text-align:start>然后，当它在通道上阻塞时，goroutine 将切换到 g0 及其堆栈（更大的堆栈）：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/54501ab8668e425bbe198e6874ad1430><p class=pgc-img-caption></p></div><p style=text-align:start>在切换之前，堆栈将被保存，以便在 Goroutine 再次运行时进行恢复：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a7dcd567843a44718fc3d7170b47a5ec><p class=pgc-img-caption></p></div><p style=text-align:start>现在，我们对 Goroutine 切换中涉及的不同操作有了一个完整的了解，让我们继续看看它是如何影响性能的。</p><p style=text-align:start>我们应该注意，诸如 arm 等 CPU 架构需要再保存一个寄存器，即 LR 链接寄存器。</p><h1 class=pgc-h-arrow-right><strong>性能</strong></h1><p style=text-align:start>我们仍然使用上述的程序来测量一次切换所需的时间。但是，由于切换时间取决于寻找下一个要调度的 Goroutine 所花费的时间，因此无法提供完美的性能视图。在函数调用情况下进行的切换要比阻塞在通道上的切换执行更多的操作，这也会影响到性能。</p><p style=text-align:start>让我们总结一下我们将要测量的操作：</p><ul><li>当前 g 阻塞在通道上并切换到 g0 ：PC g0 g0</li><li>g0 寻找新的 Goroutine 来运行；</li><li>g0 使用所选的 Goroutine 进行切换：PC PC</li></ul><p style=text-align:start>结果如下：</p><div class=pgc-img><img alt="Go：Goroutine 的切换过程实际上涉及了什么" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/31c3a0250d80491fa87a9b80f8acbedc><p class=pgc-img-caption></p></div><p style=text-align:start>从 g 到 g0 或从 g0 到 g 的切换是相当迅速的，它们只包含少量固定的指令。相反，对于调度阶段，调度程序需要检查许多资源以便确定下一个要运行的 goroutine，根据程序的不同，此阶段可能会花费更多的时间。</p><p style=text-align:start>该基准测试给出了性能的数量级估计，由于没有标准的工具可以衡量它，所以我们并不能完全依赖于这个结果。此外，性能也取决于 CPU 架构、机器（本文使用的机器是 Mac 2.9 GHz 双核 Intel Core i5）以及正在运行的程序。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Go','Goroutine','切换'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>