<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 代码自动生成器 auto-code | 极客快訊</title><meta property="og:title" content="Java 代码自动生成器 auto-code - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d60ae1d716bd4e22babd7a068ccc3577"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf6235db.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf6235db.html><meta property="article:published_time" content="2020-11-14T20:55:22+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:22+08:00"><meta name=Keywords content><meta name=description content="Java 代码自动生成器 auto-code"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/bf6235db.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 代码自动生成器 auto-code</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>auto-code</h1><p>欢迎使用auto-code代码自动生成引擎, 2.0重大升级.支持单表, 一对一, 一对多 ,多对多代码生成 源码地址</p><div class=pgc-img><img alt="Java 代码自动生成器 auto-code" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d60ae1d716bd4e22babd7a068ccc3577><p class=pgc-img-caption></p></div><p>项目介绍</p><p>项目的优势在哪里</p><blockquote><p>1.目前市面上的代码生成工具绝大多数仅仅支持生成单表,该项目支持 单表, 一对一, 一对多 ,多对多 代码生成.大大简化了开发的工作量</p><p>2.只要目前你的项目采用 springMVC+spring+mybatis架构的项目都适用(传统工程和springBoot工程都适用). 不管一次开发还是二次开发.该项目仅仅只是帮你生成单表以及多表的增删改查,不做任何底层的改动.</p></blockquote><p>什么情况选择该项目</p><blockquote><p>1.该项目只生成接口(controller,service,serviceImpl,dao,xml), 不生成页面.所以如果项目是采用前后台分离,不需要写页面.该项目会适合你</p><p>2.如果还想生成页面请看该项目,这个项目基于本项目.扩展了页面生成.适合后台使用 源码地址 演示地址 账号 ztp 密码 111111</p></blockquote><p>为何会发起该项目?</p><blockquote><p>绝大多数时候我们都是在做增删改查.每次创建一张表.然后我们需要重新写一次增删改查, 写虽然简单,不过极度耗时(controller,server,serverImpl,dao,xml) 所以才有了该项目,该项目能帮助你减少70%的工作量,让你专注于业务的实现.</p></blockquote><p>项目地址</p><div class=pgc-img><img alt="Java 代码自动生成器 auto-code" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01e824540f3b487e8bfc0ee035d2ba5b><p class=pgc-img-caption></p></div><p>集成教程</p><blockquote><p>集成非常简单,只需要在自己的web工程或者spring-boot工程引入jar包即可. 请在pom写上</p></blockquote><pre> &lt;dependency&gt; &lt;groupId&gt;com.zengtengpeng&lt;/groupId&gt; &lt;artifactId&gt;auto-code&lt;/artifactId&gt; &lt;version&gt;2.0.1&lt;/version&gt; &lt;/dependency&gt;</pre><p>使用教程</p><p>准备工作</p><blockquote><p>1 首先先准备数据库(理论上支持所有关系型数据库,目前只做了mysql的测试)</p><p>2 创建数据库 auto_code (可以随意取名称,只要和下面yaml里面的数据库名称对应上就行)</p><p>3 准备完毕,开始进入正题</p></blockquote><p>单表生成</p><blockquote><p>假设我们要生成一张单表</p></blockquote><pre>CREATE TABLE `test_code` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '测试生成代码', `name` varchar(50) DEFAULT NULL COMMENT '名称', `age` int(3) DEFAULT NULL COMMENT '年龄', `status` int(2) DEFAULT NULL COMMENT '{"name":"状态","1":"启用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '备注', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='测试生成代码';</pre><blockquote><p>1.先在资源根路径(src/main/resources)创建 auto-code_simple.yaml 文件,具体内容如下</p></blockquote><pre>datasourceConfig: #驱动名称 driverClassName: com.mysql.jdbc.Driver #数据库名称 name: auto_code #jdbc链接 url: jdbc:mysql://127.0.0.1:3306/auto_code #数据库用户名 username: root #数据库密码 password: 111111globalConfig: #数据库表配置 tableNames: #表名称 - dataName: test_code #别名 不写默认采用驼峰命名法 test_code-&gt;TestCode# aliasName: SysLoginLog #如果用多张表,请按照如下写法,继续往下写.# - dataName: test_code2# aliasName: DDDDDDD #生成代码的项目路径 parentPath: f:/core #生成代码的父包 如父包是com.zengtengpeng.test controller将在com.zengtengpeng.test.controller下 bean 将在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆盖生成文件 如果为true将会把以前的文件覆盖掉 cover: false #xml存放的文件夹默认 mybatisMapper xmlPath: mybatisMapper</pre><blockquote><p>2.执行代码生成语句</p></blockquote><pre>import com.zengtengpeng.autoCode.StartCode;public class Demo1simple { public static void main(String[] args) { //lambda表达式写法 二选一 StartCode startCode=t-&gt;{}; //普通写法 二选一// StartCode startCode=new StartCode() {// @Override// public void custom(AutoCodeConfig autoCodeConfig) {//// }// }; startCode.start(StartCode.saxYaml("auto-code_simple.yaml")); }}</pre><blockquote><p>3.生成完毕 主要生成六个接口</p></blockquote><pre>//根据id删除记录deleteByPrimaryKey//保存(主键为空则增加 否则 修改)save //根据主键查询selectByPrimaryKey//根据条件查询(所有的实体属性都是条件,如果为空则忽略该字段)selectByCondition//分页查询 (所有的实体属性都是条件,如果为空则忽略该字段) 详见Page类.所以的实体都继承该类 默认page=1 pageSize=10selectAllByPaging//导出excelexport</pre><p>生成的文件如下:</p><div class=pgc-img><img alt="Java 代码自动生成器 auto-code" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cd2d3104444d471da3c162e612320fdf><p class=pgc-img-caption></p></div><p>一对一代码生成 one-to-one (代码采用追加的方式.无需担心代码被覆盖)</p><blockquote><p>假如 一个用户 test_user 一个用户 对应 test_class 一个班级</p></blockquote><pre> CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) DEFAULT NULL COMMENT '名称', `age` int(3) DEFAULT NULL COMMENT '年龄', `status` int(2) DEFAULT NULL COMMENT '{"name":"状态","1":"启用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '备注', `mun` decimal(20,2) DEFAULT NULL COMMENT '数字', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='测试用户'; CREATE TABLE `test_class` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '班级id', `user_id` int(11) DEFAULT NULL COMMENT '用户id', `class_name` varchar(50) DEFAULT NULL COMMENT '班级名称', `quantity` int(11) DEFAULT NULL COMMENT '班级人数', `create_time` datetime DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='班级'</pre><blockquote><p>1.同理先在 资源根路径(src/main/resources)创建 auto-code_one-to-one.yaml 文件(名字随意定默认使用 auto-code.yaml),具体内容如下</p></blockquote><pre>请注意relationConfig这里描述的是关系配置, 注意generate和existParentPackage字段.如果该表已经生成了.请将 generate置为 false 同时填写 existParentPackage 该表所对应的父包(一对多,多对多有实例)datasourceConfig: #驱动名称 driverClassName: com.mysql.jdbc.Driver #数据库名称 name: auto_code #jdbc链接 url: jdbc:mysql://127.0.0.1:3306/auto_code #数据库用户名 username: root #数据库密码 password: 111111globalConfig: #生成代码的项目路径 parentPath: E:\resource\workspaceJDB\auto-code-springboot-demo #生成代码的父包 如父包是com.zengtengpeng.test controller将在com.zengtengpeng.test.controller下 bean 将在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆盖生成文件 如果为true将会把以前的文件覆盖掉 cover: false #xml存放的文件夹默认 mybatisMapper xmlPath: mybatisMapper # 表关系配置 一对一 一对多 多对多 代码生成 采用追加的方式 relationConfig: #主表 primary: #数据库表名 dataName: test_user #别名: 如果不设置将采用驼峰命名法 test_user=TestUser beanName: User #主键名称 primaryKey: id #是否生成单表代码# generate: false#如果单表代码已经生成,请填写代码的父包,没有则generate置为true 如 com.zengtengpeng.test.bean.TestUser 请填写 com.zengtengpeng.test# existParentPackage: com.zengtengpeng.test #备注 remark: "用户" #外表 foreign: #数据库表名 dataName: test_class #别名: 如果不设置将采用驼峰命名法 test_user=TestUser beanName: Clazz #外键名称 就是已哪个字段和主表关联 填写数据库字段名称 foreignKey: user_id #是否生成单表代码# generate: false#如果单表代码已经生成,请填写代码的父包,没有则generate置为true 如 com.zengtengpeng.test.bean.TestUser 请填写 com.zengtengpeng.test# existParentPackage: com.zengtengpeng.test #备注 remark: "班级"</pre><blockquote><p>2.执行代码</p></blockquote><pre>import com.zengtengpeng.autoCode.StartCode;import com.zengtengpeng.autoCode.config.AutoCodeConfig;import com.zengtengpeng.relation.oneToOne.BuildOneToOne;import com.zengtengpeng.relation.utils.RelationUtils;import com.zengtengpeng.autoCode.StartCode;import com.zengtengpeng.relation.utils.RelationUtils;public class Demo2OneToOne { public static void main(String[] args) { //普通写法// RelationUtils.oneToOne(StartCode.saxYaml(), new StartCode() {// @Override// public void custom(AutoCodeConfig autoCodeConfig) {// }// }, new BuildOneToOne() {// @Override// public void custom(AutoCodeConfig autoCodeConfig) {// }// }); //lambda表达式写法 二选一 RelationUtils.oneToOne(StartCode.saxYaml("auto-code_one-to-one.yaml"), t-&gt;{}, rt -&gt; {}); }}</pre><ul><li>生成完毕 一对多会在单表的基础上再增加6个接口(采用追加代码的方式,不用担心代码覆盖问题) 主表3个 外表3个 ClazzController 新增</li></ul><pre> /** * 级联查询(带分页) 用户--班级 */ @ResponseBody @RequestMapping("clazz/selectUserAndClazz") public DataRes selectUserAndClazz(Clazz clazz,HttpServletRequest request,HttpServletResponse response){ return DataRes.success(clazzService.selectUserAndClazz(clazz)); } /** 	 * 级联条件查询 用户--班级 	 */ 	@ResponseBody 	@RequestMapping("clazz/selectUserAndClazzByCondition") 	public DataRes selectUserAndClazzByCondition(Clazz clazz,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(clazzService.selectUserAndClazzByCondition(clazz)); 	} 	/** 	 * 级联删除(根据主键删除) 用户--班级 	 */ 	@ResponseBody 	@RequestMapping("clazz/deleteUserAndClazz") 	public DataRes deleteUserAndClazz(Clazz clazz,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(clazzService.deleteUserAndClazz(clazz)); 	}</pre><p>UserController 增加</p><pre> /** 	 * 级联查询(带分页) 用户--班级 	 */ 	@ResponseBody 	@RequestMapping("user/selectUserAndClazz") 	public DataRes selectUserAndClazz(User user,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(userService.selectUserAndClazz(user)); 	}   	/** 	 * 级联条件查询 用户--班级 	 */ 	@ResponseBody 	@RequestMapping("user/selectUserAndClazzByCondition") 	public DataRes selectUserAndClazzByCondition(User user,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(userService.selectUserAndClazzByCondition(user)); 	}   	/** 	 * 级联删除(根据主键删除) 用户--班级 	 */ 	@ResponseBody 	@RequestMapping("user/deleteUserAndClazz") 	public DataRes deleteUserAndClazz(User user,HttpServletRequest request,HttpServletResponse response){ 		return DataRes.success(userService.deleteUserAndClazz(user)); 	}</pre><p>生成的文件如下</p><div class=pgc-img><img alt="Java 代码自动生成器 auto-code" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5f6373752c34e8cadb16453fc75c025><p class=pgc-img-caption></p></div><p>一对多 代码生成 one-to-Many (代码采用追加的方式.无需担心代码被覆盖)</p><blockquote><p>假如 test_user 一个用户 对应 test_addr 多个收货地址</p></blockquote><pre> CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) DEFAULT NULL COMMENT '名称', `age` int(3) DEFAULT NULL COMMENT '年龄', `status` int(2) DEFAULT NULL COMMENT '{"name":"状态","1":"启用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '备注', `mun` decimal(20,2) DEFAULT NULL COMMENT '数字', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='测试用户'; CREATE TABLE `test_addr` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户收货地址id', `user_id` int(11) DEFAULT NULL COMMENT '用户id', `addr_name` varchar(10) DEFAULT NULL COMMENT '姓名', `phone` varchar(30) DEFAULT NULL COMMENT '手机号码', `addr` varchar(30) DEFAULT NULL COMMENT '收货地址', `status` int(11) DEFAULT NULL COMMENT '{"name":"状态","1":"启用","2":"删除"}', `create_time` datetime DEFAULT NULL COMMENT '创建时间', `update_time` datetime DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='用户收货地址'</pre><blockquote><p>1.同理先在 资源根路径(src/main/resources)创建 auto-code_one-to-many.yaml 文件,具体内容如下</p></blockquote><pre>由于TestUser已经在一对一生成过代码了.所以 generate: false同时写上已经存在的父包 existParentPackage: com.zengtengpeng.test datasourceConfig: #驱动名称 driverClassName: com.mysql.jdbc.Driver #数据库名称 name: auto_code #jdbc链接 url: jdbc:mysql://127.0.0.1:3306/auto_code #数据库用户名 username: root #数据库密码 password: 111111 globalConfig: #生成代码的项目路径 parentPath: E:\resource\workspaceJDB\auto-code-springboot-demo #生成代码的父包 如父包是com.zengtengpeng.test controller将在com.zengtengpeng.test.controller下 bean 将在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆盖生成文件 如果为true将会把以前的文件覆盖掉 cover: false #xml存放的文件夹默认 mybatisMapper xmlPath: mybatisMapper # 表关系配置 一对一 一对多 多对多 代码生成 采用追加的方式 relationConfig: #主表 primary: #数据库表名 dataName: test_user #别名: 如果不设置将采用驼峰命名法 test_user=TestUser beanName: User #主键名称 primaryKey: id #是否生成单表代码 generate: false #如果单表代码已经生成,请填写代码的父包,没有则不填写 如 com.zengtengpeng.test.bean.TestUser 请填写 com.zengtengpeng.test existParentPackage: com.zengtengpeng.test #备注 remark: "用户" #外表 foreign: #数据库表名 dataName: test_addr #别名: 如果不设置将采用驼峰命名法 test_user=TestUser beanName: Addr #外键名称 就是已哪个字段和主表关联 填写数据库字段名 foreignKey: user_id #是否生成单表代码 默认是true # generate: true #如果单表代码已经生成,请填写代码的父包,没有则不填写 如 com.zengtengpeng.test.bean.TestUser 请填写 com.zengtengpeng.test # existParentPackage: com.zengtengpeng.test #备注 remark: "收货地址" </pre><blockquote><p>2.执行生成代码</p></blockquote><pre> import com.zengtengpeng.autoCode.StartCode; import com.zengtengpeng.relation.utils.RelationUtils; /** * 一对多生成实例 test_user 一个用户 对应 test_addr 多个收货地址 */ public class Demo3OneToMany { public static void main(String[] args) { //普通写法 二选一 // RelationUtils.oneToMany(StartCode.saxYaml(), new StartCode() { // @Override // public void custom(AutoCodeConfig autoCodeConfig) { // // } // }, new BuildOneToMany() { // @Override // public void custom(AutoCodeConfig autoCodeConfig) { // // } // }); //lambda表达式写法 二选一 RelationUtils.oneToMany(StartCode.saxYaml("auto-code_one-to-many.yaml"), t -&gt; {}, rt -&gt; {}); } }</pre><blockquote><p>3.生成完毕 接口和一对一一样</p></blockquote><p>多对多 代码生成 many-to-many (代码采用追加的方式.无需担心代码被覆盖)</p><blockquote><p>假如 test_user 多个用户 对应 test_role 多个角色</p></blockquote><pre> CREATE TABLE `test_user` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'id', `name` varchar(50) DEFAULT NULL COMMENT '名称', `age` int(3) DEFAULT NULL COMMENT '年龄', `status` int(2) DEFAULT NULL COMMENT '{"name":"状态","1":"启用","0":"禁用"}', `birthday` date DEFAULT NULL COMMENT '生日', `remarks` text COMMENT '备注', `mun` decimal(20,2) DEFAULT NULL COMMENT '数字', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8 COMMENT='测试用户'; CREATE TABLE `test_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '测试角色', `name` varchar(100) NOT NULL COMMENT '角色名称', `status` int(2) DEFAULT '0' COMMENT '{"name":"状态","0":"启用","1":"禁用"}', `create_user_id` int(11) DEFAULT NULL COMMENT '创建者', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', `update_user_id` int(11) DEFAULT NULL COMMENT '更新者', `update_time` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间', `dels` int(2) DEFAULT '0' COMMENT '{"name":"是否删除","0":"正常","1":"删除"}', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COMMENT='测试角色';  CREATE TABLE `test_user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户角色关系表', `user_id` int(11) DEFAULT NULL COMMENT '用户id', `role_id` int(11) DEFAULT NULL COMMENT '角色id', `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=55 DEFAULT CHARSET=utf8 COMMENT='测试用户角色';</pre><blockquote><p>1.同理先在 资源根路径(src/main/resources)创建 auto-code.yaml 文件,具体内容如下</p></blockquote><pre> 1.由于TestUser已经在一对一生成过代码了.所以 generate: false 同时写上 TestUser存在的父包 existParentPackage: com.zengtengpeng.test 2.注意多对多的外表的 foreignKey 同样是该表的主键 3.thirdparty为多对多的第三表primaryKey对应主表(primary)的primaryKey.  foreignKey对应外表(foreign)的foreignKey datasourceConfig: #驱动名称 driverClassName: com.mysql.jdbc.Driver #数据库名称 name: auto_code #jdbc链接 url: jdbc:mysql://127.0.0.1:3306/auto_code #数据库用户名 username: root #数据库密码 password: 111111 globalConfig: #生成代码的项目路径 parentPath: E:\resource\workspaceJDB\auto-code-springboot-demo #生成代码的父包 如父包是com.zengtengpeng.test controller将在com.zengtengpeng.test.controller下 bean 将在com.zengtengpeng.test.bean下 ,service,dao同理 parentPack: com.zengtengpeng.test #是否覆盖生成文件 如果为true将会把以前的文件覆盖掉 cover: false #xml存放的文件夹默认 mybatisMapper xmlPath: mybatisMapper # 表关系配置 一对一 一对多 多对多 代码生成 采用追加的方式 relationConfig: #主表 primary: #数据库表名 dataName: test_user #别名: 如果不设置将采用驼峰命名法 test_user=TestUser beanName: User #主键名称 primaryKey: id #是否生成 单表 代码 generate: false #如果单表代码已经生成,请填写代码的父包 如 com.zengtengpeng.test.bean.TestUser 请填写 com.zengtengpeng.test existParentPackage: com.zengtengpeng.test #备注 remark: "用户" #外表 foreign: #数据库表名 dataName: test_role #别名: 如果不设置将采用驼峰命名法 test_user=TestUser beanName: Role #外键名称 就是已哪个字段和主表关联 填写数据库字段名 foreignKey: id #备注 remark: "角色" #第三表 -当生成多对多代码时该参数必填.否则会忽略该参数 thirdparty: #数据库表名 dataName: test_user_role #主键名称 该字段将和主表关联起来 primaryKey: user_id #外键名称 该字段将和外表配置关联起来 foreignKey: role_id #备注 remark: "用户角色"</pre><blockquote><p>2 .执行代码</p></blockquote><pre>import com.zengtengpeng.autoCode.StartCode;import com.zengtengpeng.relation.utils.RelationUtils;/** * 多对多生成实例 test_user 多个用户 对应 test_role 多个角色 */public class Demo4ManyToMany { public static void main(String[] args) { //普通写法 /*RelationUtils.manyToMany(StartCode.saxYaml(), new StartCode() { @Override public void custom(AutoCodeConfig autoCodeConfig) { } }, new BuildManyToMany() { @Override public void custom(AutoCodeConfig autoCodeConfig) { } });*/ //lambda表达式写法 二选一 RelationUtils.manyToMany(StartCode.saxYaml("auto-code_many-to-many.yaml"), t-&gt;{}, rt -&gt; {}); }}</pre><blockquote><p>3.生成完毕 接口在一对一的基础上增加了2个方法 主表</p></blockquote><pre>//根据外表id查询主表表所有数据(带分页)@RequestMapping("testUs/selectTestUsByTestRo")	@ResponseBody	public DataRes selectTestUsByTestRo(HttpServletRequest request,HttpServletResponse response,TestUs testUs){		return DataRes.success(testUsService.selectTestUsByTestRo(testUs));	}</pre><p>外表</p><pre> /** 	 * 根据主表id查询外表所有数据(带分页) 	 */ 	@Auth("testRo/selectAllByPaging") 	@RequestMapping("testRo/selectTestRoByTestUs") 	@ResponseBody 	public DataRes selectTestRoByTestUs(HttpServletRequest request,HttpServletResponse response,TestRo testRo){ 		return DataRes.success(testRoService.selectTestRoByTestUs(testRo)); 	}</pre><p>生成代码注意事项</p><pre>1.创建表结构时如果写上表与字段的注释将大大增加程序的可读性.我会将注释写到bean上面.2.配置文件 auto-code.yaml名称随意定.默认使用 auto-code.yaml 当使用 auto-code.yaml时StartCode.saxYaml("auto-code_many-to-many.yaml") 可以直接写成 StartCode.saxYaml().4.如果注释为json键值对字符串我将会在实体类生成一个字典方法如: {"1":"启用","0":"禁用"} 将会在实体类里面生成: public String getStatus_(){		if(MyStringUtils.isEmpty(status)){			 return "";		}else if(status.equals("1")){			return "启用";		}else if(status.equals("0")){			return "禁用";		}		return "";	}</pre><p>spring-boot如何使用 实例地址</p><blockquote><p>1.集成mybatis-spring-boot-starter,spring-boot-starter-web 这里就不再阐述</p><p>2.由于分页插件使用了 pageHelper 所以需要集成下,不集成将导致分页失效,集成非常简单 官方SpringBoot集成地址</p></blockquote><pre>1.加入pom.xml jar包&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.10&lt;/version&gt;&lt;/dependency&gt;2.在application.properties加入配置#pagehelper插件#logging.level.com.example.demo.dao=DEBUGpagehelper.helperDialect=mysqlpagehelper.reasonable=truepagehelper.supportMethodsArguments=truepagehelper.params=count=countSqlpagehelper.page-size-zero=true3.至此集成完毕</pre><p>java-web 实例地址</p><blockquote><p>由于分页插件使用了 pageHelper 所以需要集成下,不集成将导致分页失效 官方传统web工程集成地址</p></blockquote><pre>1.由于工程中以及引入pageHelper的jar包所以直接在MyBatis-Configuration.xml中加入&lt;plugins&gt; &lt;plugin interceptor="com.github.pagehelper.PageInterceptor"&gt; &lt;/plugin&gt;&lt;/plugins&gt;2.集成完毕</pre><p>进阶篇 如何自定义方法 代码地址</p><p>单表如何自定义</p><blockquote><p>在 com.zengtengpeng.autoCode.create包下,有6个接口类 BuildBean,BuildController,BuildDao,BuildService,BuildServiceImpl,BuildXml.每个接口底下都有个未实现的 custom 方法. 实现custom就可以,如下代码就是自定义Controller代码,其他的接口同理</p></blockquote><pre>import com.zengtengpeng.autoCode.bean.BuildJavaField;import com.zengtengpeng.autoCode.bean.BuildJavaMethod; import com.zengtengpeng.autoCode.config.AutoCodeConfig;import com.zengtengpeng.autoCode.config.BuildJavaConfig;import com.zengtengpeng.autoCode.create.BuildController;import java.util.ArrayList;import java.util.List;/** * 重写controller 自定义配置 */public class TestBuildController implements BuildController { @Override public BuildJavaConfig custom(AutoCodeConfig autoCodeConfig) { BuildJavaConfig buildJavaConfig=new BuildJavaConfig(); List&lt;String&gt; imports=new ArrayList&lt;&gt;(); imports.add("java.util.HashMap"); imports.add("java.util.Hashtable"); imports.add("java.util.Collections"); //自定义需要导入的类 buildJavaConfig.setImports(imports); List&lt;BuildJavaMethod&gt; methods=new ArrayList&lt;&gt;(); BuildJavaMethod method=new BuildJavaMethod(); method.setContent("\nSystem.out.println(\"生成完毕\");"); method.setMethodName("test"); method.setMethodType("public"); method.setReturnType("void"); List&lt;String&gt; params=new ArrayList&lt;&gt;(); params.add("String test"); method.setParams(params); method.setRemark("测试生成方法"); List&lt;String&gt; ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); method.setAnnotation(ann); methods.add(method); //自定义方法 将在类生成如下方法 //@SuppressWarnings("") //	public void test(String test){ // //System.out.println("生成完毕"); //	} buildJavaConfig.setBuildJavaMethods(methods); List&lt;BuildJavaField&gt; fileds=new ArrayList&lt;&gt;(); BuildJavaField jf=new BuildJavaField(); jf.setFiledType("private"); jf.setReturnType("String"); jf.setFiledName("test"); jf.setRemark("测试生成字段"); jf.setInit("\"初始化字段\""); ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); jf.setAnnotation(ann); fileds.add(jf); //自定义字段 将在类生成如下字段 //@SuppressWarnings("") //	private String test ="初始化字段"; buildJavaConfig.setBuildJavaFields(fileds); //自定义继承 类单继承 接口多继承 List&lt;String&gt; ex=new ArrayList&lt;&gt;(); ex.add("Object"); buildJavaConfig.setExtend(ex); //自定义 实现 类多实现, 接口没有实现// buildJavaConfig.setImplement(null); return buildJavaConfig; }}</pre><blockquote><p>StartCode 为生成单表的总开关,里面有 BuildBean,BuildController,BuildDao,BuildService, BuildServiceImpl,BuildXml 几个接口的默认实现.如需自定义,重写默认实现的方法.</p></blockquote><pre>/** * 自定义单表方法 */public class CustomSimple { public static void main(String[] args) { StartCode startCode=new StartCode() { @Override public void custom(AutoCodeConfig autoCodeConfig) { }  @Override public BuildController BuildController() { //自定义Controller方法 return new TestBuildController(); } }; startCode.start(StartCode.saxYaml("auto-code_simple.yaml")); }}</pre><p>表关系自定义</p><blockquote><p>表关系在单表的基础上扩展了 主表,外表 代码在 com.zengtengpeng.relation 下的 manyToMany(多对多),oneToMany(一对多),oneToOne(一对一)子包,每个子包有六个生成类的接口.重写也是只需要实现对应的接口的 custom 方法就行.下面举例重写一对一的controller方法</p></blockquote><pre>import com.zengtengpeng.autoCode.bean.BuildJavaField;import com.zengtengpeng.autoCode.bean.BuildJavaMethod;import com.zengtengpeng.autoCode.config.AutoCodeConfig;import com.zengtengpeng.autoCode.config.BuildJavaConfig;import com.zengtengpeng.relation.oneToOne.BuildOneToOneController;import java.util.ArrayList;import java.util.List;/** * 自定义one-to-one controller */public class TestBuildOneToOneController implements BuildOneToOneController { @Override public void custom(AutoCodeConfig autoCodeConfig, BuildJavaConfig primaryBuildJavaConfig, BuildJavaConfig foreignBuildJavaConfig) { List&lt;String&gt; imports=new ArrayList&lt;&gt;(); imports.add("java.util.HashMap"); imports.add("java.util.Hashtable"); imports.add("java.util.Collections"); //自定义需要导入的类 primaryBuildJavaConfig.setImports(imports); List&lt;BuildJavaMethod&gt; methods=new ArrayList&lt;&gt;(); BuildJavaMethod method=new BuildJavaMethod(); method.setContent("\nSystem.out.println(\"生成完毕\");"); method.setMethodName("test"); method.setMethodType("public"); method.setReturnType("void"); List&lt;String&gt; params=new ArrayList&lt;&gt;(); params.add("String test"); method.setParams(params); method.setRemark("测试生成方法"); List&lt;String&gt; ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); method.setAnnotation(ann); methods.add(method); //自定义方法 将在类生成如下方法 //@SuppressWarnings("") //	public void test(String test){ // //System.out.println("生成完毕"); //	} primaryBuildJavaConfig.setBuildJavaMethods(methods); List&lt;BuildJavaField&gt; fileds=new ArrayList&lt;&gt;(); BuildJavaField jf=new BuildJavaField(); jf.setFiledType("private"); jf.setReturnType("String"); jf.setFiledName("test"); jf.setRemark("测试生成字段"); jf.setInit("\"初始化字段\""); ann=new ArrayList&lt;&gt;(); ann.add("@SuppressWarnings(\"\")"); jf.setAnnotation(ann); fileds.add(jf); //自定义字段 将在类生成如下字段 //@SuppressWarnings("") //	private String test ="初始化字段"; primaryBuildJavaConfig.setBuildJavaFields(fileds); //自定义继承 类单继承 接口多继承 List&lt;String&gt; ex=new ArrayList&lt;&gt;(); ex.add("Object"); primaryBuildJavaConfig.setExtend(ex); }}</pre><blockquote><p>BuildManyToMany(构建多对多),BuildOneToMany(构建一对多),BuildOneToOne(构建一对一) 是各个表关系实现的总开关. 里面有 Build...Controller Build...Bean 等六个相关接口的具体实现.我们也是只要重写对应的方法就行 如下重写一对一的controller.只需要重写 BuildOneToOne下的 buildOneToOneController具体实现即可.其他的同理</p></blockquote><pre> import com.zengtengpeng.autoCode.StartCode; import com.zengtengpeng.autoCode.config.AutoCodeConfig; import com.zengtengpeng.demo.test.TestBuildOneToOneController; import com.zengtengpeng.relation.oneToOne.BuildOneToOne; import com.zengtengpeng.relation.oneToOne.BuildOneToOneController; import com.zengtengpeng.relation.utils.RelationUtils;  /** * 多表自定义 */ public class CustomRelation { public static void main(String[] args) { //如果单表想要自定义请参见 CustomSimple 类. 里面是如果定义单表的 StartCode startCode = t -&gt; { };  //多表自定义 BuildOneToOne buildOneToOne = new BuildOneToOne() { @Override public void custom(AutoCodeConfig autoCodeConfig) {  } @Override public BuildOneToOneController buildOneToOneController() { //Controller autoCodeConfig 全局配置 primaryBuildJavaConfig主表的自定义配置 foreignBuildJavaConfig 外表的自定义配置 return new TestBuildOneToOneController(); } }; RelationUtils.oneToOne(StartCode.saxYaml("auto-code_one-to-one.yaml"), startCode, buildOneToOne); } }</pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'生成器','Java','代码'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/ef985079.html alt="Java 通用代码生成器光 1.5.0 Kama (顿悟)发布，内含开发者手册" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/00f13030-6d86-4a2f-9ba4-698b919cf0fa style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/ef985079.html title="Java 通用代码生成器光 1.5.0 Kama (顿悟)发布，内含开发者手册">Java 通用代码生成器光 1.5.0 Kama (顿悟)发布，内含开发者手册</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>