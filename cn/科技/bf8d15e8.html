<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>百度技术架构师总结：微服务架构之访问安全 | 极客快訊</title><meta property="og:title" content="百度技术架构师总结：微服务架构之访问安全 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/00e834ec35f24d80b2925124dda1ff41"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/bf8d15e8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/bf8d15e8.html><meta property="article:published_time" content="2020-11-14T21:00:28+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:28+08:00"><meta name=Keywords content><meta name=description content="百度技术架构师总结：微服务架构之访问安全"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/bf8d15e8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>百度技术架构师总结：微服务架构之访问安全</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre class=ql-align-justify>来源：不止思考</pre><p class=ql-align-justify>应用程序的访问安全又是我们每一个研发团队都必须关注的重点问题。尤其是在我们采用了微服务架构之后，项目的复杂度提升了N个级别，相应的，微服务的安全工作也就更难更复杂了。并且我们以往擅长的单体应用的安全方案对于微服务来说已经不再适用了。我们必须有一套新的方案来保障微服务架构的安全。</p><p class=ql-align-justify>在探索微服务访问安全之前，我们还是先来回顾一下单体应用的安全是如何实现的。</p><p class=ql-align-justify><strong>一、传统单体应用如何实现「访问安全」？</strong></p><p class=ql-align-justify>下图就是一个传统单体应用的访问示意图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/00e834ec35f24d80b2925124dda1ff41><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>（图片来自WillTran在slideshare分享）</p><p class=ql-align-justify>在应用服务器里面，我们有一个auth模块（一般采用过滤来实现），当有客户端请求进来时，所有的请求都必须首先经过这个auth来做身份验证，验证通过后，才将请求发到后面的业务逻辑。</p><p class=ql-align-justify>通常客户端在第一次请求的时候会带上身份校验信息（用户名和密码），auth模块在验证信息无误后，就会返回Cookie存到客户端，之后每次客户端只需要在请求中携带Cookie来访问，而auth模块也只需要校验Cookie的合法性后决定是否放行。</p><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/ff3d4803-6175-4ff9-8acf-aca563d8f2ce><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>可见，在传统单体应用中的安全架构还是蛮简单的，对外也只有一个入口，通过auth校验后，内部的用户信息都是内存/线程传递，逻辑并不是复杂，所以风险也在可控范围内。</p><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/43908004-0fa5-4a16-a7e4-6b96669e78ae><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>那么，当我们的项目改为微服务之后，「访问安全」又该怎么做呢。</p><p class=ql-align-justify><strong>二、微服务如何实现「访问安全」？</strong></p><p class=ql-align-justify>在微服务架构下，有以下三种方案可以选择，当然，用的最多的肯定还是OAuth模式。</p><ul><li class=ql-align-justify><strong>网关鉴权模式（API Gateway）</strong></li><li class=ql-align-justify><strong>服务自主鉴权模式</strong></li><li class=ql-align-justify><strong>API Token模式（OAuth2.0）</strong></li></ul><p class=ql-align-justify>下面分别来讲一下这三种模式：</p><ol><li class=ql-align-justify><strong>网关鉴权模式（API Gateway）</strong></li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b5fe0e250a4e4bbbab99f68fc1aa7da2><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>（图片来自WillTran在slideshare分享）</li><li class=ql-align-justify>通过上图可见，因为在微服务的最前端一般会有一个API网关模块（API Gateway），所有的外部请求访问微服务集群时，都会首先通过这个API Gateway，所以我们可以在这个模块里部署auth逻辑，实现统一集中鉴权，鉴权通过后，再把请求转发给后端各个服务。</li><li class=ql-align-justify>这种模式的优点就是，由API Gateway集中处理了鉴权的逻辑，使得后端各微服务节点自身逻辑就简单了，只需要关注业务逻辑，无需关注安全性事宜。</li><li class=ql-align-justify>这个模式的问题就是，API Gateway适用于身份验证和简单的路径授权（基于URL的），对于复杂数据/角色的授权访问权限，通过API Gateway很难去灵活的控制，毕竟这些逻辑都是存在后端服务上的，并非存储在API Gateway里。</li><li class=ql-align-justify><strong>服务自主鉴权模式</strong></li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0266a928ba647b28f184dfd0f2c6bdc><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>（图片来自WillTran在slideshare分享）</li><li class=ql-align-justify>服务自主鉴权就是指不通过前端的API Gateway来控制，而是由后端的每一个微服务节点自己去鉴权。</li><li class=ql-align-justify>它的优点就是可以由更为灵活的访问授权策略，并且相当于微服务节点完全无状态化了。同时还可以避免API Gateway 中 auth 模块的性能瓶颈。</li><li class=ql-align-justify>缺点就是由于每一个微服务都自主鉴权，当一个请求要经过多个微服务节点时，会进行重复鉴权，增加了很多额外的性能开销。</li><li class=ql-align-justify><strong>API Token模式（OAuth2.0）</strong></li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37d2e647286e4b9ab0bf47504cb1fd6d><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>（图片来自网络）</li><li class=ql-align-justify>如图，这是一种采用基于令牌Token的授权方式。在这个模式下，是由授权服务器（图中Authorization Server）、API网关（图中API Gateway）、内部的微服务节点几个模块组成。</li><li class=ql-align-justify>流程如下：</li><li class=ql-align-justify>第一步：客户端应用首先使用账号密码或者其它身份信息去访问授权服务器（Authorization Server）获取 访问令牌（Access Token）。</li><li class=ql-align-justify>第二步：拿到访问令牌（Access Token）后带着它再去访问API网关（图中API Gateway），API Gateway自己是无法判断这个Access Token是否合法的，所以走第三步。</li><li class=ql-align-justify>第三步：API Gateway去调用Authorization Server校验一下Access Token的合法性。</li><li class=ql-align-justify>第四步：如果验证完Access Token是合法的，那API Gateway就将Access Token换成JWT令牌返回。</li><li class=ql-align-justify>（注意：此处也可以不换成JWT而是直接返回原Access Token。但是换成JWT更好，因为Access Token是一串不可读无意义的字符串，每次验证Access Token是否合法都需要去访问Authorization Server才知道。但是JWT令牌是一个包含JOSN对象，有用户信息和其它数据的一个字符串，后面微服务节点拿到JWT之后，自己就可以做校验，减少了交互次数）。</li><li class=ql-align-justify>第五步：API Gateway有了JWT之后，就将请求向后端微服务节点进行转发，同时会带上这个JWT。</li><li class=ql-align-justify>第六步：微服务节点收到请求后，读取里面的JWT，然后通过加密算法验证这个JWT，验证通过后，就处理请求逻辑。</li><li class=ql-align-justify>这里面就使用到了OAuth2.0的原理，不过这只是OAuth2.0各类模式中的一种。</li></ol><p class=ql-align-justify>由于OAuth2.0目前最为常用，所以接下来我再来详细讲解一下OAuth2.0的原理和各类用法。</p><p class=ql-align-justify><strong>三、详解 OAuth2.0 的「 访问安全 」？</strong></p><p class=ql-align-justify>OAuth2.0是一种访问授权协议框架。它是基于Token令牌的授权方式，在不暴露用户密码的情况下，使 应用方 能够获取到用户数据的访问权限。</p><p class=ql-align-justify>例如：你开发了一个视频网站，可以采用第三方微信登陆，那么只要用户在微信上对这个网站授权了，那这个网站就可以在无需用户密码的情况下获取用户在微信上的头像。</p><p class=ql-align-justify>OAuth2.0 的流程如下图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1075fa96a3804cd7bd3312deaab944a5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>OAuth2.0 里的主要名词有：</p><ul><li class=ql-align-justify><strong>资源服务器：</strong>用户数据/资源存放的地方，在微服务架构中，服务就是资源服务器。在上面的例子中，微信头像存放的服务就是资源服务器。</li><li class=ql-align-justify><strong>资源拥有者：</strong>是指用户，资源的拥有人。在上面的例子中某个微信头像的用户就是资源拥有者。</li><li class=ql-align-justify><strong>授权服务器：</strong>是一个用来验证用户身份并颁发令牌的服务器。</li><li class=ql-align-justify><strong>客户端应用：</strong>想要访问用户受保护资源的客户端/Web应用。在上面的例子中的视频网站就是客户端应用。</li><li class=ql-align-justify><strong>访问令牌：</strong>Access Token，授予对资源服务器的访问权限额度令牌。</li><li class=ql-align-justify><strong>刷新令牌：</strong>客户端应用用于获取新的 Access Token 的一种令牌。</li><li class=ql-align-justify><strong>客户凭证：</strong>用户的账号密码，用于在 授权服务器 进行验证用户身份的凭证。</li></ul><p class=ql-align-justify>OAuth2.0有四种授权模式，也就是四种获取令牌的方式：授权码、简化式、用户名密码、客户端凭证。</p><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/6b5dabdc-a270-4254-98ed-d4cac6ab4449><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>下面来分别讲解一下：</p><ol><li class=ql-align-justify><strong>授权码（Authorization Code）</strong></li><li class=ql-align-justify>授权码模式是指：客户端应用先去申请一个授权码，然后再拿着这个授权码去获取令牌的模式。这也是目前最为常用的一种模式，安全性比较高，适用于我们常用的前后端分离项目。通过前端跳转的方式去访问 授权服务器 获取授权码，然后后端再用这个授权码访问 授权服务器 以获取 访问令牌。</li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc82c2439c254d80a965e5c8b819d2fc><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>流程如上图。</li><li class=ql-align-justify>第一步，客户端的前端页面(图中UserAgent)将用户跳转到 授权服务器(Authorization Server)里进行授权，授权完成后，返回 授权码(Authorization Code)</li><li class=ql-align-justify>第二步，客户端的后端服务(图中Client)携带授权码(Authorization Code)去访问 授权服务器，然后获得正式的 访问令牌(Access Token)</li><li class=ql-align-justify>页面的前端和后端分别做不同的逻辑，前端接触不到Access Token，保证了Access Token的安全性。</li><li class=ql-align-justify><strong>简化式（Implicit）</strong></li><li class=ql-align-justify>简化模式是在项目是一个纯前端应用，在没有后端的情况下，采用的一种模式。</li><li class=ql-align-justify>因为这种方式令牌是直接存在前端的，所以非常不安全，因此令牌的有限期设置就不能太长。</li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0d587aed24644744ae154290cf62bcb8><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>其流程就是：</li><li class=ql-align-justify>第一步：应用（纯前端的应用）将用户跳转到 授权服务器(Authorization Server)里进行授权，授权完成后，授权服务器 直接将 Access Token 返回给 前端应用，令牌存储在前端页面。</li><li class=ql-align-justify>第二步：应用（纯前端的应用）携带 访问令牌(Access Token) 去访问资源，获取资源。</li><li class=ql-align-justify>在整个过程中，虽然令牌是在前端URL中直接传递，但注意，令牌在HTTP协议中不是放在URL参数字段中的，而是放在URL锚点里。因为锚点数据不会被浏览器发到服务器，因此有一定的安全保障。</li><li class=ql-align-justify><strong>用户名密码（Resource Owner Credentials）</strong></li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc4a2c29aa844d89b05ed91c224b7b44><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>这种方式最容易理解了，直接使用用户的用户名/密码作为授权方式去访问 授权服务器，从而获取Access Token，这个方式因为需要用户给出自己的密码，所以非常的不安全性。一般仅在客户端应用与授权服务器、资源服务器是归属统一公司/团队，互相非常信任的情况下采用。</li><li class=ql-align-justify><strong>客户端凭证（Client Credentials）</strong></li></ol><div class=pgc-img><img alt=百度技术架构师总结：微服务架构之访问安全 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/39ffdf5fedc54161a2e6d5e2f5ed835a><p class=pgc-img-caption></p></div><ol><li class=ql-align-justify>这是适用于服务器间通信的场景。客户端应用拿一个用户凭证去找授权服务器获取Access Token。</li></ol><p class=ql-align-justify>以上，就是对微服务架构中「访问安全」的一些思考。</p><p><strong>end：如果你觉得本文对你有帮助的话，记得点赞转发，你的支持就是我更新动力。</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'技术架','构师','总结'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>