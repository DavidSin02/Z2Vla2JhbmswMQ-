<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 | 极客快訊</title><meta property="og:title" content="大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c15b9453.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c15b9453.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c15b9453.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de><p class=pgc-img-caption></p></div><p><strong>List和Set比较，各自的子类比较</strong></p><p><strong>对比一：</strong> <strong>Arraylist与LinkedList的比较</strong></p><p>1、ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。</p><p>2、因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。</p><p>3、LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。</p><p>4、因为LinkedList要移动指针,所以查询操作性能比较低。</p><p><strong>适用场景分析：</strong></p><p>当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时采用LinkedList。</p><p><strong>对比二：</strong> <strong>ArrayList与Vector的比较</strong></p><p>1、Vector的方法都是同步的，是线程安全的，而ArrayList的方法不是，由于线程的同步必然要影响性能。因此，ArrayList的性能比Vector好。</p><p>2、当Vector或ArrayList中的元素超过它的初始大小时，Vector会将它的容量翻倍，而ArrayList只增加50%的大小，这样。ArrayList就有利于节约内存空间。</p><p>3、大多数情况不使用Vector，因为性能不好，但是它支持线程的同步，即某一时刻只有一个线程能够写Vector，避免多线程同时写而引起的不一致性。</p><p>4、Vector可以设置增长因子，而ArrayList不可以。</p><p><strong>适用场景分析：</strong></p><p>1、Vector是线程同步的，所以它也是线程安全的，而ArrayList是线程异步的，是不安全的。如果不考虑到线程的安全因素，一般用ArrayList效率比较高。</p><p>2、如果集合中的元素的数目大于目前集合数组的长度时，在集合中使用数据量比较大的数据，用Vector有一定的优势。</p><p><strong>对比三：</strong> <strong>HashSet与TreeSet的比较</strong></p><p>1.TreeSet 是二叉树实现的，Treeset中的数据是自动排好序的，不允许放入null值 。</p><p>2.HashSet 是哈希表实现的，HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束 。</p><p>3.HashSet要求放入的对象必须实现HashCode()方法，放入的对象，是以hashcode码作为标识的，而具有相同内容的String对象，hashcode是一样，所以放入的内容不能重复。但是同一个类的对象可以放入不同的实例。</p><p><strong>适用场景分析：</strong></p><p>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。我们通常都应该使用HashSet，在我们需要排序的功能时，我们才使用TreeSet。</p><p><strong>HashMap和ConcurrentHashMap的区别</strong></p><p>1、HashMap不是线程安全的，而ConcurrentHashMap是线程安全的。</p><p>2、ConcurrentHashMap采用锁分段技术，将整个Hash桶进行了分段segment，也就是将这个大的数组分成了几个小的片段segment，而且每个小的片段segment上面都有锁存在，那么在插入元素的时候就需要先找到应该插入到哪一个片段segment，然后再在这个片段上面进行插入，而且这里还需要获取segment锁。</p><p>3、ConcurrentHashMap让锁的粒度更精细一些，并发性能更好。</p><p>至于两者的底层实现，你如果想通过一篇文章就理解了，那就too young了，好好找些博文+看源码去吧。</p><p><strong>HashTable和ConcurrentHashMap的区别</strong></p><p>它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p><p><strong>String,StringBuffer和StringBuilder的区别</strong></p><p>1、运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder > StringBuffer > String。</p><p>2、线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。</p><p><strong>适用场景分析：</strong></p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用於单线程下在字符缓冲区进行大量操作的情况</p><p>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/553805eb-fd78-4117-a341-72f82467334c><p class=pgc-img-caption></p></div><hr><p><strong>wait和sleep的区别</strong></p><p>1、sleep()方法是属于Thread类中的，而wait()方法，则是属于Object类中的。</p><p>2、sleep()方法导致了程序暂停执行指定的时间，让出cpu给其他线程，但是他的监控状态依然保持着，当指定的时间到了又会自动恢复运行状态。所以在调用sleep()方法的过程中，线程不会释放对象锁。</p><p>3、调用wait()方法的时候，线程会放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备获取对象锁进入运行状态。</p><p><strong>JVM的内存结构</strong></p><p>根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><p><strong>1、Java虚拟机栈：</strong></p><p>线程私有；每个方法在执行的时候会创建一个栈帧，存储了局部变量表，操作数栈，动态连接，方法返回地址等；每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。</p><p><strong>2、堆：</strong></p><p>线程共享；被所有线程共享的一块内存区域，在虚拟机启动时创建，用于存放对象实例。</p><p><strong>3、方法区：</strong></p><p>线程共享；被所有线程共享的一块内存区域；用于存储已被虚拟机加载的类信息，常量，静态变量等。</p><p><strong>4、程序计数器：</strong></p><p>线程私有；是当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器，这类内存也称为“线程私有”的内存。</p><p><strong>5、本地方法栈：</strong></p><p>线程私有；主要为虚拟机使用到的Native方法服务。</p><p><strong>强引用，软引用和弱引用的区别</strong></p><p><strong>强引用：</strong></p><p>只有这个引用被释放之后，对象才会被释放掉，只要引用存在，垃圾回收器永远不会回收，这是最常见的New出来的对象。</p><p><strong>软引用：</strong></p><p>内存溢出之前通过代码回收的引用。软引用主要用户实现类似缓存的功能，在内存足够的情况下直接通过软引用取值，无需从繁忙的真实来源查询数据，提升速度；当内存不足时，自动删除这部分缓存数据，从真正的来源查询这些数据。</p><p><strong>弱引用：</strong></p><p>第二次垃圾回收时回收的引用，短时间内通过弱引用取对应的数据，可以取到，当执行过第二次垃圾回收时，将返回null。弱引用主要用于监控对象是否已经被垃圾回收器标记为即将回收的垃圾，可以通过弱引用的isEnQueued方法返回对象是否被垃圾回收器标记。</p><p><strong>数组在内存中如何分配</strong></p><p>1、简单的值类型的数组，每个数组成员是一个引用（指针），引用到栈上的空间（因为值类型变量的内存分配在栈上）</p><p>2、引用类型，类类型的数组，每个数组成员仍是一个引用（指针），引用到堆上的空间（因为类的实例的内存分配在堆上）</p><p><strong>springmvc的核心是什么，请求的流程是怎么处理的，控制反转怎么实现的</strong></p><p><strong>核心：</strong></p><p>控制反转和面向切面</p><p><strong>请求处理流程：</strong></p><p>1、首先用户发送请求到前端控制器，前端控制器根据请求信息（如URL）来决定选择哪一个页面控制器进行处理并把请求委托给它，即以前的控制器的控制逻辑部分；</p><p>2、页面控制器接收到请求后，进行功能处理，首先需要收集和绑定请求参数到一个对象，并进行验证，然后将命令对象委托给业务对象进行处理；处理完毕后返回一个ModelAndView（模型数据和逻辑视图名）；</p><p>3、前端控制器收回控制权，然后根据返回的逻辑视图名，选择相应的视图进行渲染，并把模型数据传入以便视图渲染；</p><p>4、前端控制器再次收回控制权，将响应返回给用户。</p><p><strong>控制反转如何实现：</strong></p><p>我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。</p><p>spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。</p><p>因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。</p><p>A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。</p><p><strong>mybatis如何处理结果集</strong></p><p>MyBatis的结果集是通过反射来实现的。并不是通过get/set方法。在实体类中无论是否定义get/set()方法，都是可以接收到的。</p><p>如果面试只是考你这个点的话就恭喜了。如果继续深问流程，那就需要自己找一些源码来阅读了。</p><p><strong>java的多态表现在哪里</strong></p><p>主要有两种表现形式：重载和重写</p><p><strong>重载：</strong></p><p>是发生在同一类中，具有相同的方法名，主要是看参数的个数，类型，顺序不同实现方法的重载的，返回值的类型可以不同。</p><p><strong>重写：</strong></p><p>是发生在两个类中（父类和子类），具有相同的方法名，主要看方法中参数，个数，类型必须相同，返回值的类型必须相同。</p><hr><p><strong>接口有什么用</strong></p><p>1、通过接口可以实现不相关类的相同行为，而不需要了解对象所对应的类。</p><p>2、通过接口可以指明多个类需要实现的方法。</p><p>3、通过接口可以了解对象的交互界面，而不需了解对象所对应的类。</p><p>另：Java是单继承，接口可以使其实现多继承的功能。</p><hr><p><strong>说说http,https协议</strong></p><p><strong>HTTP：</strong></p><p>是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p><p><strong>HTTPS：</strong></p><p>是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p><strong>区别：</strong></p><p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p><p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p><p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p><p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><hr><p><strong>说说tcp/ip协议族</strong></p><p>TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。</p><p>1、数据链路层负责帧数据的传递。</p><p>2、网络层责数据怎样传递过去。</p><p>3、传输层负责传输数据的控制（准确性、安全性）</p><p>4、应用层负责数据的展示和获取。</p><hr><p><strong>tcp五层网络协议</strong></p><p><strong>物理层：</strong></p><p>为数据端设备提供传送数据的通路，数据通路可以是一个物理媒体，也可以是多个物理媒体连接而成。</p><p><strong>数据链路层：</strong></p><p>为网络层提供数据传送服务。</p><p><strong>网络层：</strong></p><p>路由选择和中继、激活,终止网络连接、在一条数据链路上覆用多条网络连接,多采取分时复用技术 、差错检测与恢复、排序,流量控制、服务选择、网络管理 。</p><p><strong>传输层：</strong></p><p>传输层是两台计算机经过网络进行数据通信时,第一个端到端的层次，具有缓冲作用。</p><p><strong>应用层：</strong></p><p>应用层向应用程序提供服务</p><hr><p><strong>TCP与UDP的区别</strong></p><p>1、基于连接与无连接</p><p>2、TCP要求系统资源较多，UDP较少；</p><p>3、UDP程序结构较简单</p><p>4、流模式（TCP）与数据报模式(UDP);</p><p>5、TCP保证数据正确性，UDP可能丢包</p><p>6、TCP保证数据顺序，UDP不保证</p><hr><p><strong>cookie和session的区别，分布式环境怎么保存用户状态</strong></p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p><strong>分布式环境下的session（举例两种）：</strong></p><p><strong>服务器session复制</strong></p><p>原理：任何一个服务器上的session发生改变（增删改），该节点会把这个 session的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要session，以此来保证Session同步。</p><p>优点：可容错，各个服务器间session能够实时响应。</p><p>缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。</p><p><strong>session共享机制</strong></p><p>使用分布式缓存方案比如memcached、redis，但是要求Memcached或Redis必须是集群。</p><hr><p><strong>GIT和SVN的区别</strong></p><p>1、GIT是分布式的，SVN不是。</p><p>2、GIT把内容按元数据方式存储，而SVN是按文件。</p><p>3、GIT分支和SVN的分支不同。</p><p>4、GIT没有一个全局的版本号，而SVN有。</p><p>5、GIT的内容完整性要优于SVN。</p><p>（一般问会不会用，知道这些区别貌似也没卵用）</p><p><strong>请写一段栈溢出、堆溢出的代码</strong></p><p>递归调用可以导致栈溢出</p><p>不断创建对象可以导致堆溢出</p><p>代码如下：</p><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/57c03a8954874240a88b9a0a4b99e666><p class=pgc-img-caption></p></div><p><strong>BIO、NIO和AIO的区别</strong></p><p>Java BIO ： 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。</p><p>Java NIO ： 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。</p><p>Java AIO： 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。</p><p><em>NIO比BIO的改善之处是把一些无效的连接挡在了启动线程之前，减少了这部分资源的浪费（因为我们都知道每创建一个线程，就要为这个线程分配一定的内存空间）</em></p><p><em>AIO比NIO的进一步改善之处是将一些暂时可能无效的请求挡在了启动线程之前，比如在NIO的处理方式中，当一个请求来的话，开启线程进行处理，但这个请求所需要的资源还没有就绪，此时必须等待后端的应用资源，这时线程就被阻塞了。</em></p><p><strong>适用场景分析：</strong></p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解，如之前在Apache中使用。</p><p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持，如在 Nginx，Netty中使用。</p><p>AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持，在成长中，Netty曾经使用过，后来放弃。</p><hr><p><strong>java中常说的堆和栈，分别是什么数据结构；另外，为什么要分为堆和栈来存储数据</strong></p><p>栈是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。</p><p>堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的。</p><p><strong>为什么要划分堆和栈</strong></p><p>1、从软件设计的角度看，栈代表了处理逻辑，而堆代表了数据。这样分开，使得处理逻辑更为清晰。</p><p>2、堆与栈的分离，使得堆中的内容可以被多个栈共享。一方面这种共享提供了一种有效的数据交互方式(如：共享内存)，另一方面，堆中的共享常量和缓存可以被所有栈访问，节省了空间。</p><p>3、栈因为运行时的需要，比如保存系统运行的上下文，需要进行地址段的划分。由于栈只能向上增长，因此就会限制住栈存储内容的能力。而堆不同，堆中的对象是可以根据需要动态增长的，因此栈和堆的拆分，使得动态增长成为可能，相应栈中只需记录堆中的一个地址即可。</p><p>4、体现了Java面向对象这一核心特点（也可以继续说一些自己的理解）</p><hr><p><strong>为什么要用</strong></p><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/fdfeee7f-450c-47cf-9565-ed77702661ae><p class=pgc-img-caption></p></div><p><strong>那先要明白什么是线程池</strong></p><p>线程池是指在初始化一个多线程应用程序过程中创建一个线程集合，然后在需要执行新的任务时重用这些线程而不是新建一个线程。</p><p><strong>使用线程池的好处</strong></p><p>1、线程池改进了一个应用程序的响应时间。由于线程池中的线程已经准备好且等待被分配任务，应用程序可以直接拿来使用而不用新建一个线程。</p><p>2、线程池节省了CLR 为每个短生存周期任务创建一个完整的线程的开销并可以在任务完成后回收资源。</p><p>3、线程池根据当前在系统中运行的进程来优化线程时间片。</p><p>4、线程池允许我们开启多个任务而不用为每个线程设置属性。</p><p>5、线程池允许我们为正在执行的任务的程序参数传递一个包含状态信息的对象引用。</p><p>6、线程池可以用来解决处理一个特定请求最大线程数量限制问题。</p><hr><p><strong>msyql优化经验</strong></p><p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2、应尽量避免在 where 子句中使用!=或&lt;>操作符，否则引擎将放弃使用索引而进行全表扫描。</p><p>3、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。</p><p>4、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>5、避免频繁创建和删除临时表，以减少系统表资源的消耗。诸如此类，等等等等......</p><p><strong>悲观锁和乐观锁的区别，怎么实现</strong></p><p>悲观锁：一段执行逻辑加上悲观锁,不同线程同时执行时,只能有一个线程执行,其他的线程在入口处等待,直到锁被释放。</p><p>乐观锁：一段执行逻辑加上乐观锁,不同线程同时执行时,可以同时进入执行,在最后更新数据的时候要检查这些数据是否被其他线程修改了(版本和执行初是否相同),没有修改则进行更新,否则放弃本次操作。</p><p>悲观锁的实现：</p><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5417a560f15d4fcd90e6e3c5403c0b41><p class=pgc-img-caption></p></div><p>乐观锁的实现：</p><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5dabdbe7e9064720918e6481f8fac7ac><p class=pgc-img-caption></p></div><p><strong>最后</strong></p><p>针对于互联网公司java程序员涉及到的绝大部分难题我做成了文档和架构视频资料免费分享给大家（包括Dubbo、Redis、Netty、zookeeper、Spring cloud、分布式、高并发等架构技术资料），希望能帮助到且找到一个好的工作，也节省大家在网上搜索资料的时间来学习，也可以关注我一下以后会有更多干货分享。</p><p><strong>领取方式：关注+转发+收藏后私信我【面试资料】即可免费获取哦！</strong></p><p><strong>关注+转发+收藏后在私信哦！</strong></p><div class=pgc-img><img alt=大佬分享：京东阿里Java面试题：List和Set比较，各自的子类比较 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99442bb9a16e4f8dbd5f63716b1f70f2><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'京东','Java','面试题'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>