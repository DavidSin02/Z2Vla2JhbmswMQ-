<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>在Chrome中使用WebRTC ICE服务进行端口扫描 | 极客快訊</title><meta property="og:title" content="在Chrome中使用WebRTC ICE服务进行端口扫描 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/d9e657e72bff4b279a7dcf246a977c2f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c1dbffb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1dbffb.html><meta property="article:published_time" content="2020-10-29T21:08:07+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:07+08:00"><meta name=Keywords content><meta name=description content="在Chrome中使用WebRTC ICE服务进行端口扫描"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c1dbffb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>在Chrome中使用WebRTC ICE服务进行端口扫描</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><pre><code>WebRTC，名称源自网页即时通信（英语：Web Real-Time Communication）的缩写，是一个支持网页浏览器进行实时语音对话或视频对话的API。它于2011年6月1日开源并在Google、Mozilla、Opera支持下被纳入万维网联盟的W3C推荐标准。——百度百科</code></pre><p>使用浏览器扫描局域网并不是一种新想法，目前已有许多利用XHR请求、websockets或存粹的HTML代码来发现和识别局域网设备的例子。但在这篇博客中，我将介绍一种使用WebRTC ICE服务进行扫描的技术。该技术扫描速度较快，并且与其他方法不同的是，它可以绕过blocked ports list。但不幸的是，它只能在Chrome上才能生效。</p><p>你可以跳过我的解释，直接进入代码或演示页面。如果想详细了解，先让我们从PoC视频开始，主要是扫描我的192.168.88.0/24网络。</p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d9e657e72bff4b279a7dcf246a977c2f><p class=pgc-img-caption></p></div><p><br></p><pre><code>视频地址：https://youtu.be/M6lBVhkzUmM</code></pre><h2 class=pgc-h-arrow-right>什么是ICE Server？</h2><p>如前所述，扫描技术使用WebRTC ICE服务。ICE服务是WebRTC RTCPeerConnection用于自我发现、NAT遍历和中继的STUN或TURN服务，通过将服务器列表传递到RTCPeerConnection的构造器来实现。下面是一个和谷歌公共STUN服务器有关的构造器之一：</p><pre><code>var rtc = new RTCPeerConnection({    iceServers:[{“urls”:”stun:stun.l.google.com:19302”}]});</code></pre><p>当上述RTCPeerConnection进入ICE收集状态时，它将尝试连接到所提供的服务器。</p><h2 class=pgc-h-arrow-right>协议</h2><p>ICE服务可以绑定到UDP或TCP端口。但是，除非特别设定，Chrome似乎只尝试通过UDP进行通信。下面是一个Wireshark截图，显示了Chrome发送数据到一个不存在的TURN服务器，一切都基于UDP。</p><p><br></p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d11bfbe707943b0a4b9f391f3e1f082><p class=pgc-img-caption></p></div><p><br></p><p>如果你知道一些关于ICE服务器的URL，可以强迫Chrome通过TCP进行连接。传递给RTCPeerConnection构造器的URL必须符合RFC 7064（STUN）或RFC 7065（TURN）。TURN URI的方案如下：</p><p><br></p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ae732435c74b459db7adff36202bc75c><p class=pgc-img-caption></p></div><p><br></p><p>对于扫描来说最重要的是“?transport=”字段。它可以通过“?transport=TCP”强制ICE使用TCP。</p><p>现在，我们有了一种方法来向我们选择的任何IP和端口发出TCP连接。但是，由于我们要扫描的所有主机几乎都和TURN服务无关，那么如何确定主机是否处于活动状态呢？</p><h2 class=pgc-h-arrow-right>确定目标是否存活</h2><p>为了找到192.168.[0-255].1范围内的活动地址，下面的JSFiddle会生成256个TURN URI。</p><pre><code>var brute_array = [];for (i = 0; i &lt; 256; i++) {  brute_address = "turn:192.168." + i + ".1:445?transport=tcp";  brute_array.push({    urls: brute_address,    credential: "lobster",    username: "albino"  });}var rtc_brute = new RTCPeerConnection({  iceServers: brute_array,  iceCandidatePoolSize: 0});rtc_brute.createDataChannel('', {  reliable: false});rtc_brute.onicecandidateerror = function(e) {  if (e.url == null) {    return;  }  url_split = e.url.split(":");  host_div = document.createElement('div');  host_div.id = url_split[1];  host_div.innerHTML = url_split[1];  document.getElementById('hosts').appendChild(host_div);}// trigger the gathering of ICE candidatesrtc_brute.createOffer(function(offerDesc) {  rtc_brute.setLocalDesc ription(offerDesc);}, function(e) {  console.log("Create offer failed callback.");});</code></pre><p>当icecandidateerror事件生成时，这个地址就被确定为“活动的”。如果主机以某种形式拒绝连接，Chrome就会将生成错误事件。理想情况下，在Chrome发送初始信息后，会立刻有RST回复或一个快速拒绝。虽然服务可能只是保持连接打开，但错误事件将需要大约30秒来生成。</p><p>这就是为什么JSFiddle使用端口445进行扫描。我实现的SMB完成了TCP握手，然后在Chrome的非SMB通信之后关闭连接。445端口的另一个理想之处在于它和Windows关系紧密。</p><p>如果Chrome没有响应，则不会生成事件。这可能是因为防火墙进行了处理，也可能是不存在可用主机。</p><p>我遇到的唯一一个极端情况回复中存在一个ICMP响应。这导致Chrome生成一个icecandidateerror，形成了一定程度的干扰。</p><h2 class=pgc-h-arrow-right>端口扫描</h2><p>JSFiddle会扫描192.168.88.1上的21、22、23、25、53、80、443、445、5900和8080端口。</p><pre><code>var ports = [21, 22, 23, 25, 53, 80, 443, 445, 5900, 8080];var target = "192.168.88.1";address_div = document.createElement('div');address_div.id = target;address_div.innerHTML = target;document.getElementById("hosts").appendChild(address_div);var scan_array = [];for (i = 0; i &lt; ports.length; i++) {  probe_address = "turn:" + target + ":" + ports[i] + "?transport=tcp";  scan_array.push({urls: probe_address,credential: "lobster",username: "albino"  });  port_div = document.createElement('div');  port_div.id = ports[i]  port_div.innerHTML = "   -&gt; Port " + ports[i] + " - ?"  document.getElementById(target).appendChild(port_div);}var port_scan = new RTCPeerConnection({  iceServers: scan_array,  iceCandidatePoolSize: 0});port_scan.createDataChannel('', {  reliable: false});port_scan.onicecandidateerror = function(e) {  if (e.url == null) {return;  }  url_split = e.url.split(":");  port_split = url_split[2].split("?");  if (e.hostCandidate != "0.0.0.x:0") {    document.getElementById(port_split[0]).innerHTML = "   -&gt; Port " + port_split[0] + " - &lt;b&gt;&lt;i&gt;Open&lt;/i&gt;&lt;b&gt;"  } else {    document.getElementById(port_split[0]).innerHTML = "   -&gt; Port " + port_split[0] + " - Closed"  }}setTimeout(function() {  if (port_scan.iceGatheringState === "gathering") {    port_scan.close();  }}, 60000);port_scan.onicegatheringstatechange = function(e) {  if (port_scan.iceGatheringState == "complete") {    port_scan.close();  }}port_scan.createOffer(function(offerDesc) {    port_scan.setLocalDesc ription(offerDesc);  },  function(e) {    console.log("Create offer failed callback.");  });</code></pre><p>以下本地网络扫描结果：</p><p><br></p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f19dda1052864426a87c4a2123d5eb7b><p class=pgc-img-caption></p></div><p><br>基于Chrome生成的icecandidateerror事件，脚本能够将端口分类为“打开”或“关闭”。每个icecandidateerror都有一个hostCandidate变量。任何完成TCP三次握手的ICE服务器都将在hostCandidate中列出本地IP和端口（例如192.168.88.x:51688）。无法访问的ICE服务器以“0.0.0.x:0”的形式生成hostCandidates。因此，判断一个端口是否打开很简单。</p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/216a6358580c43ff8ecb8f40862da1b0><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>只适用于Chrome？</h2><p>目前我无法在任何其他浏览器中重现扫描，其他浏览器似乎没有实现onicecandidateerror。这个特性在Chrome中存在的时间也不长，因为MDN显示“不支持”：</p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c8e08e0513a43b5970e9c3949f70a06><p class=pgc-img-caption></p></div><p><br>其他浏览器似乎对RTCPeerConnection的使用也不太灵活。虽然Chrome很乐意接受255个不同的ICE服务器，但Firefox就不行。</p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a20487ecd0744f9a8849c9439295e262><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right>关于PoC代码</h2><p>Chrome最近已修复因WebRTC而泄露的本地地址这一问题。当“Experimental”功能的“Anonymize local IPs exposed by WebRTC”标志被启用时，Chrome将尝试使用mDNS.local主机名，而不是本地IP。</p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4a5e6b7f6f034661b3ea469765617724><p class=pgc-img-caption></p></div><p><br>我觉得这真是一个很好的安全加固，肯定能阻止不少潜在的攻击者。</p><p>不过我在PoC也考虑到了IP无法获取这一点，此时它将尝试搜索192.168.[0–255].1上的某个活动IP。</p><h2 class=pgc-h-arrow-right>这是一个弱点吗？</h2><p>起初，我觉得这是一个弱点。攻击者（有争议地）绕过Chrome的受限端口列表，能够搜索受害者的局域网。但谷歌似乎认为这是一个“隐私”问题，而不是安全漏洞。</p><div class=pgc-img><img alt="在Chrome中使用WebRTC ICE服务进行端口扫描" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a1bffd74887452286a73caeb51564ff><p class=pgc-img-caption></p></div><p>不过，现在有各种各样的插件可以禁用WebRTC，你也可以选择其他浏览器。</p><p><br></p><p>本文由白帽汇整理并翻译，不代表白帽汇任何观点和立场</p><p>来源：https://nosec.org/home/detail/3595.html</p><p>原文：https://medium.com/tenable-techblog/using-webrtc-ice-servers-for-port-scanning-in-chrome-ce17b19dd474</p><p>白帽汇从事信息安全，专注于安全大数据、企业威胁情报。</p><p>公司产品：FOFA-网络空间安全搜索引擎、FOEYE-网络空间检索系统、NOSEC-安全讯息平台。</p><p>为您提供：网络空间测绘、企业资产收集、企业威胁情报、应急响应服务</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Chrome','WebRTC','ICE'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>