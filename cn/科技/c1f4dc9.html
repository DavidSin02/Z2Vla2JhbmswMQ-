<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>二 linux操作系统复习笔记 | 极客快訊</title><meta property="og:title" content="二 linux操作系统复习笔记 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/66bc00032a43fdf87a92"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c1f4dc9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c1f4dc9.html><meta property="article:published_time" content="2020-10-29T20:59:05+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:05+08:00"><meta name=Keywords content><meta name=description content="二 linux操作系统复习笔记"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c1f4dc9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>二 linux操作系统复习笔记</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>内存管理</h1><ul class=list-paddingleft-2><li><p>内核空间：1GB（对32位操作系统来说）</p></li><li><p>用户空间：3GB（对32位操作系统来说）</p><p>比如一个程序经过编译的形成的地址空间是一个虚拟地址的空间，但是程序最终还是要运行在物理内存中的，虚地址转换成物理地址需要分页操作。如果给出的页表不同，那么虚拟地址由MMU转换成物理地址就会不同。所以我们对每个进程都建立不同的页表，在某一时刻一个CPU中只能有一个进程在运行，当进程发生切换的时候，将页表更换成相应的页表，这就形成了各个进程都有自己的虚拟空间而相互不影响。所以在任意时刻，对于一个CPU来说只需要有当前的页表就能实现从虚地址到物理地址的转换。</p><p>内核空间从3G---4G，但映射到物理内存空间却是从0x00000000开始的。</p></li></ul><p><strong>虚存区中的页会与磁盘发生关系</strong></p><ul class=list-paddingleft-2><li><p>1.磁盘交互区：当内存不够用时候，一些久未使用的页就会交换到磁盘的交换区，腾出物理页给那些急需的进程使用（交换机制）</p><p>2.虚存映射：Linux提供mmap函数，这个系统调用可以将一个打开的文件映射到进程的用户空间，此后就可以像访问内存一样来访问这个文件。</p></li></ul><p><strong>mmap函数</strong></p><ul class=list-paddingleft-2><li><p>1.需要映射的文件通过mmap函数映射到用户空间（虚拟地址），然后虚拟地址通过MMU地址转换到物理内存地址。</p><p>2.逻辑地址MMU机制转换成物理地址（逻辑地址通过分段机制转换成虚拟地址，虚拟地址通过分页机制转换成物理地址）</p><p>3.4当进程第一次访问页时候，页没有在内存中，这就需要请页机制，当内存不够用时候，一些久未使用的页就会交换到磁盘的交换区，腾出物理页给那些急需的进程使用（交换机制）</p></li></ul><p><img alt="二 linux操作系统复习笔记" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66bc00032a43fdf87a92></p><p class=pgc-img-caption>mmap</p><blockquote><p>void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);</p><p>addr：指定映射的起始地址, 通常设为NULL, 由系统指定</p><p>length：映射到内存的文件长度</p><p>prot：映射区的保护方式, 可以是:</p><p>PROT_EXEC: 映射区可被执行</p><p>PROT_READ: 映射区可被读取</p><p>PROT_WRITE: 映射区可被写入</p><p>flags：映射区的特性, 可以是:</p><p>MAP_SHARED:写入映射区的数据会复制回文件, 且允许其他映射该文件的进程共享。</p><p>MAP_PRIVATE:对映射区的写入操作会产生一个映射区的复制(copy-on-write), 对此区域所做的修改不会写回原文件</p><p>fd：由open返回的文件描述符, 代表要映射的文件</p><p>offset：以文件开始处的偏移量, 必须是分页大小的整数倍, 通常为0, 表示从文件头开始映射。</p></blockquote><blockquote><p>#include &lt;stdio.h></p><p>#include &lt;stdlib.h></p><p>#include &lt;string.h></p><p>#include &lt;error.h></p><p>#include &lt;fcntl.h></p><p>#include &lt;sys/mman.h></p><p>#include &lt;unistd.h></p><p>int main(int argc,char *argv[]){</p><p>int fd;</p><p>char *ptr;</p><p>if(argc &lt; 2){</p><p>printf("please enter the file\n");</p><p>return 0;</p><p>}</p><p>if((fd = open(argv[1],O_RDWR)) &lt; 0){</p><p>perror("opent file error\n");</p><p>return -1;</p><p>}</p><p>ptr = mmap(0,12,PROT_READ,MAP_PRIVATE,fd,0);</p><p>for(int i = 0;i&lt;12;i++)</p><p>printf("%c\n",ptr[i]);</p><p>}</p></blockquote><ul class=list-paddingleft-2><li><p><strong>lseek函数</strong></p></li></ul><blockquote><p>一个用于改变读写一个文件时读写指针位置的一个系统调用</p><p>off_t lseek(int fd, off_t offset, int whence);</p><p>fd：由open返回的文件描述符</p><p>offset：偏移量，该值可正可负，负值为向前移</p><p>whence：搜索的起始位置，有三个选项：</p><p>(1).SEEK_SET: 当前位置为文件的开头，新位置为偏移量大小</p><p>(2).SEEK_CUR: 当前位置为文件指针位置，新位置为当前位置加上偏移量大小</p><p>(3).SEEK_END: 当前位置为文件结尾，新位置为偏移量大小whence：</p></blockquote><blockquote><p>#include &lt;fcntl.h></p><p>#include &lt;stdlib.h></p><p>#include &lt;errno.h></p><p>int main(void){</p><p>int fd;</p><p>int ret;</p><p>fd = open("hole.txt",O_WRONLY|O_CREAT|O_TRUNC,0644);</p><p>if(fd == -1){</p><p>perror("open error");</p><p>}</p><p>write(fd,"hello",5);</p><p>ret = lseek(fd,1024*1024,SEEK_CUR);</p><p>if(ret == -1){</p><p>perror("lseek error");</p><p>}</p><p>write(fd,"world",5);</p><p>close(fd);</p><p>return 0;</p><p>}</p></blockquote><p><img alt="二 linux操作系统复习笔记" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/66bc00032b9c68bfa6fb></p><p class=pgc-img-caption>lseek函数</p><p>内存分配和回收</p><ul class=list-paddingleft-2><li><p><strong>伙伴算法工作原理</strong></p><p>Linux把空闲页面分为10个链表，每个链表包含2的幂次这样的页面，第0个链表中包含的都是2^0大小的页面，依次类推。假设要求分配的块大小为128个页面，该算法首先会在2^7这个链表里面查找，如果找到就分配，如果找不到就向2^8（256）链表寻找，如果找到就把256平分，一个分配一个128的页面，另一个128大小的页面插入到2^7（128）的链表；如果2^8（256）链表也没有，还继续往上寻找2^9（512），如果找到就把512分成128和384,128分配，把384再分成128和256，然后把128和256依次插入到2^7和2^8链表中；如果512也没找到，该算法就放弃分配，并发出出错信号。（上面的数字代表多少个页面）</p></li><li><p><strong>物理页面的回收</strong></p><p>page_idx：是page结构在mem_map数组中的索引（mem_map是一个全局变量，描述系统中的全部的物理页面）</p><p>order：指出要回收的页块的大小为2的order次幂个物理页（2^order）</p><p>1.如果page_idx+1不能被2^(order+1)整除，那么page_idx+2^order就是buddy_idx（其伙伴）</p><p>2.如果page_idx+1能被2^(order+1)整除，那么page_idx-2^order就是buddy_idx（其伙伴）</p></li><li><p><strong>vmalloc和kmalloc区别</strong></p><p>内核空间分布（3G-4G）：</p><p>PAGE_OFFSET-------->high_memory--------->VMALLOC_START-------->4G</p><p>CPU访问的都是虚拟内存，其中PAGE_OFFSET为3G，high_memory为保存物理地址最高值的变量，VMALLOC_START为非连续区的起始地址。</p><p>vmalloc和kmalloc都是在内核代码中用来分配内存的函数</p><p>kmalloc分配的是从3G----high_memory之间，这一段内核空间和物理内存映射是一一对应的（保证分配的内存在物理上是连续的）</p><p>vmalloc分配的是从VMALLOC_START----4G之间，这一段内核空间和物理内存映射可能是非连续的（保证在虚拟地址空间上的连续）</p></li></ul><h1>中断和异常</h1><ul class=list-paddingleft-2><li><p>linux对256个向量分配如下</p><p>1-31 的向量对应异常和非屏蔽中断</p><p>32-47 的向量（由I/O设备引起的终端）分配给屏蔽中断</p><p>48-255 的向量用来标识软中断，linux用了128即0x80用于系统调用</p></li><li><p>中断向量表</p><p>也叫中断描述符表IDT，其中每个表项叫做一个门描述符，主要的门描述符有三种</p><p>中断门：类型码为110，请求特权级为0，用户态不能访问</p><p>陷阱门：类型码为111，不关中断</p><p>系统门：请求特权级为3，系统调用就是通过系统门进入内核的</p></li><li><p>中断和异常的硬件处理</p><p>CPL是当前执行任务的特权等级，存储在cs和ss的第0位和第1位（0~3）四个等级</p><p>DPL表示门或者段的特权等级，存储在门（中断描述符IDT）和段描述符GDT的DPL字段中</p><p>1.确定发生中断或异常的向量i（0~255之间）</p><p>2.读取IDTR寄存器找到IDT表，读取IDT的第i项</p><p>3.分两步进行有效性检查，“段”级检查和“门”级检查</p><p>4.检查是否发生特权级的变化，当中断发生在用户态（特权级为3），中断处理程序运行在内核态（特权级为0），所以会引起堆栈的更换，从用户态切换到内核态。如果中断发生在内核态级不会发生堆栈的切换</p></li><li><p>中断上下部处理机制</p><p>下半部运行时是允许中断请求的，上半部运行时是关中断的</p></li><li><p>小任务机制</p><p>是指对要推迟执行的函数进行的函数进行组织的一种机制</p></li><li><p>工作队列</p><p>是另外一种将工作推后执行的一种形式，工作队列可以把工作推后，交由一个内核线程去执行，也就是说这个下半部分可以在进程上下文中执行。什么时候用小任务机制什么时候用工作队列呢？如果推迟的任务需要睡眠那就使用工作队列，如果不需要睡眠就使用小任务机制</p></li><li><p>linux的时间基准</p><p>1970年1月1日凌晨0点</p></li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'linux','系统','习笔记'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/09027003.html alt="一 linux操作系统复习笔记" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66b900045bf5657b4d3a style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/09027003.html title="一 linux操作系统复习笔记">一 linux操作系统复习笔记</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>