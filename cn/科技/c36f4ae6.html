<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>手推公式：LSTM单元梯度的详细的数学推导 | 极客快訊</title><meta property="og:title" content="手推公式：LSTM单元梯度的详细的数学推导 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/68dcd30ac0c0469a9bb85ea2bc9f3e8c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c36f4ae6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c36f4ae6.html><meta property="article:published_time" content="2020-11-14T21:08:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:22+08:00"><meta name=Keywords content><meta name=description content="手推公式：LSTM单元梯度的详细的数学推导"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c36f4ae6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>手推公式：LSTM单元梯度的详细的数学推导</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><p>长短期记忆是复杂和先进的神经网络结构的重要组成部分。本文的主要思想是解释其背后的数学原理，所以阅读本文之前，建议首先对LSTM有一些了解。</p><h1 class=pgc-h-arrow-right>介绍</h1><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/68dcd30ac0c0469a9bb85ea2bc9f3e8c><p class=pgc-img-caption></p></div><p><br></p><p>上面是单个LSTM单元的图表。我知道它看起来可怕，但我们会通过一个接一个的文章,希望它会很清楚。</p><h1 class=pgc-h-arrow-right>解释</h1><p>基本上一个LSTM单元有4个不同的组件。忘记门、输入门、输出门和单元状态。我们将首先简要讨论这些部分的使用，然后深入讨论数学部分。</p><p><strong>忘记门</strong></p><p>顾名思义，这部分负责决定在最后一步中扔掉或保留哪些信息。这是由第一个s型层完成的。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf9a6bfca62044e49661c257a6e748f4><p class=pgc-img-caption></p></div><p><br></p><p>根据ht-1(以前的隐藏状态)和xt(时间步长t的当前输入)，它为单元格状态C_t-1中的每个值确定一个介于0到1之间的值。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c3f5be80f4de4d1cb881540bbf19f941><p class=pgc-img-caption></p></div><p><br></p><p>遗忘门和上一个状态</p><p>如果为1，所有的信息保持原样，如果为0，所有的信息都被丢弃，对于其他的值，它决定有多少来自前一个状态的信息被带入下一个状态。</p><p><strong>输入门</strong></p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/092e349b381a4f1f9822569269746eec><p class=pgc-img-caption></p></div><p><br></p><p>Christopher Olah博客的解释在输入门发生了什么：</p><p>下一步是决定在单元格状态中存储什么新信息。这包括两部分。首先，一个称为"输入门层"的sigmoid层决定我们将更新哪些值。接下来，一个tanh层创建一个新的候选值的向量，C~t，可以添加到状态中。在下一步中，我们将结合这两者来创建对状态的更新。</p><p>现在这两个值i。e i_t和c~t结合决定什么新的输入是被输入到状态。</p><p><strong>单元状态</strong></p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b5d1fed8b19f4a0a89f3bf6e957adfe6><p class=pgc-img-caption></p></div><p><br></p><p>单元状态充当LSTM的内存。这就是它们在处理较长的输入序列时比普通RNN表现得更好的地方。在每一个时间步长，前一个单元状态(Ct-1)与遗忘门结合，以决定什么信息要被传送，然后与输入门(it和c~t)结合，形成新的单元状态或单元的新存储器。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f53dcd72df3a4c1095f5dcb6b404ab68><p class=pgc-img-caption></p></div><p><br></p><p>状态的计算公式</p><p><strong>输出门</strong></p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e85410c575a40519853af40bdc66a44><p class=pgc-img-caption></p></div><p><br></p><p>最后，LSTM单元必须给出一些输出。从上面得到的单元状态通过一个叫做tanh的双曲函数，因此单元状态值在-1和1之间过滤。</p><p>LSTM单元的基本单元结构已经介绍完成，继续推导在实现中使用的方程。</p><h1 class=pgc-h-arrow-right>推导先决条件</h1><p>推导方程的核心概念是基于反向传播、成本函数和损失。除此以外还假设您对高中微积分(计算导数和规则)有基本的了解。</p><p>变量:对于每个门，我们有一组权重和偏差，表示为:</p><p>· Wf,bf->遗忘门的权重和偏差</p><p>· Wi,bi->输入门的权重和偏差</p><p>· Wc,bc->单元状态的权重和偏差</p><p>· Wo,bo->输出门的权重和偏差</p><p>· Wv ,bv -> 与Softmax层相关的权重和偏差</p><p>· ft, it,ctiledet, o_t -> 输出使用的激活函数</p><p>· af, ai, ac, ao -> 激活函数的输入</p><p>J是成本函数，我们将根据它计算导数。注意(下划线(_)后面的字符是下标)</p><h1 class=pgc-h-arrow-right>前向传播推导</h1><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a43a1899d68244899751f42c70f2a077><p class=pgc-img-caption></p></div><p><br></p><p>门的计算公式</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8e26df11ab484cc7b8965168d55482d2><p class=pgc-img-caption></p></div><p><br></p><p>状态的计算公式</p><p>以遗忘门为例说明导数的计算。我们需要遵循下图中红色箭头的路径。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/799e456ca7e84f03b8e91df85aa4205d><p class=pgc-img-caption></p></div><p><br></p><p>我们画出一条从f_t到代价函数J的路径，也就是</p><p>ft→Ct→h_t→J。</p><p>反向传播完全发生在相同的步骤中，但是是反向的</p><p>ft←Ct←h_t←J。</p><p>J对ht求导，ht对Ct求导，Ct对f_t求导。</p><p>所以如果我们在这里观察，J和ht是单元格的最后一步，如果我们计算dJ/dht，那么它可以用于像dJ/dC_t这样的计算，因为:</p><p>dJ/dCt = dJ/dht * dht/dCt(链式法则)</p><p>同样，对第一点提到的所有变量的导数也要计算。</p><p>现在我们已经准备好了变量并且清楚了前向传播的公式，现在是时候通过反向传播来推导导数了。我们将从输出方程开始因为我们看到在其他方程中也使用了同样的导数。这时就要用到链式法则了。我们现在开始吧。</p><h1 class=pgc-h-arrow-right>反向传播推导</h1><p>lstm的输出有两个值需要计算。</p><p>Softmax:对于交叉熵损失的导数，我们将直接使用最终的方程。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/28b53cd64f2540ca88c318b4c75e3c34><p class=pgc-img-caption></p></div><p><br></p><p>隐藏状态是ht。ht是w.r的微分。根据链式法则，推导过程如下图所示。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d924539a4bdd48c8b6a027ffce699028><p class=pgc-img-caption></p></div><p><br></p><p>输出门相关变量:ao和ot，微分的完整方程如下:</p><p>dJ/dVt * dVt/dht * dht/dO_t</p><p>dJ/dVt * dVt/dht可以写成dJ/dht(我们从隐藏状态得到这个值)。</p><p>ht的值= ot * tanh(ct) ->所以我们只需要对ht w.r求导。t o_t。其区别如下:</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/deb71d0b53ae4ecd8124919a4802bcca><p class=pgc-img-caption></p></div><p><br></p><p>同样，a_o和J之间的路径也显示出来。微分的完整方程如下:</p><p>dJ/dVt * dVt/dht * dt /da_o</p><p>dJ/dVt * dVt/dht * dht/dOt可以写成dJ/dOt(我们从上面的o_t得到这个值)。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/550df23d02ba4f92ba09bea760bf6e9d><p class=pgc-img-caption></p></div><p><br></p><p>Ct是单元的单元状态。除此之外，我们还处理候选单元格状态ac和c~_t。</p><p>Ct的推导很简单，因为从Ct到J的路径很简单。Ct→ht→Vt→j，因为我们已经有了dJ/dht，我们直接微分ht w.r。t Ct。</p><p>ht = ot * tanh(ct) ->所以我们只需要对ht w.r求导。t C_t。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6872a076835645dc924c07ce6e4ee322><p class=pgc-img-caption></p></div><p><br></p><p>微分的完整方程如下:</p><p>dJ/dht * dht/dCt * dCt/dc~_t</p><p>可以将dJ/dht * dht/dCt写成dJ/dCt(我们在上面有这个值)。</p><p>Ct的值如图9公式5所示(下图第3行最后一个Ct缺少波浪号(~)符号->书写错误)。所以我们只需要对C_t w.r求导。t c ~ _t。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4cfee728105f4b66befc5b47d2d834d0><p class=pgc-img-caption></p></div><p><br></p><p>ac:如下图所示为ac到J的路径。根据箭头，微分的完整方程如下:</p><p>dJ/dht * dht/dCt * dCt/ da_c</p><p>dJ/dht * dht/dCt * dCt/dc_t可以写成dJ/dc_t(我们在上面有这个值)。</p><p>所以我们只需要对c~t w.r求导。t ac。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/08ca3fc8ce1246f19d79d50e0b332633><p class=pgc-img-caption></p></div><p><br></p><p>输入门相关变量:it和ai</p><p>微分的完整方程如下:</p><p>dt / dt * dt /dit</p><p>可以将dJ/dht * dht/dCt写入为dJ/dCt(我们在单元格状态中有这个值)。所以我们只需要对Ct w.r求导。t it。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ff5bc57723c64ec3875869e0311951bf><p class=pgc-img-caption></p></div><p><br></p><p>a_i:微分的完整方程如下:</p><p>dJ/dht * dht/dCt * dt /da_i</p><p>dJ/dht * dht/dCt * dCt/dit可以写成dJ/dit(我们在上面有这个值)。所以我们只需要对i_t w.r求导。t ai。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8fbba2f8e13c4ef8abe1e16609c0fd83><p class=pgc-img-caption></p></div><p><br></p><p>遗忘门相关变量:ft和af</p><p>微分的完整方程如下:</p><p>dJ/dht * dht/dCt * dCt/df_t</p><p>可以将dJ/dht * dht/dCt写入为dJ/dCt(我们在单元格状态中有这个值)。所以我们只需要对Ct w.r求导。t ft。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f27f9f60c7541b288e687de7f6af64a><p class=pgc-img-caption></p></div><p><br></p><p>a_f:微分的完整方程如下:</p><p>dJ/dht * dht/dCt * dft/da_t</p><p>dJ/dht * dht/dCt * dCt/dft可以写成dJ/dft(我们在上面有这个值)。所以我们只需要对ftw.r求导。t af。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d84179c00b4641f383b2e7d37a0d9f4b><p class=pgc-img-caption></p></div><p><br></p><p>Lstm的输入</p><p>每个单元格i有两个与输入相关的变量。前一个单元格状态C_t-1和前一个隐藏状态与当前输入连接，即</p><p>[ht-1,xt] > Z_t</p><p>C_t-1:这是Lstm单元的内存。图5显示了单元格状态。c - t-1的推导很简单因为只有c - t和c - t。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45400ce33c614d9d80f7c2541868986a><p class=pgc-img-caption></p></div><p><br></p><p>Zt:如下图所示，Zt进入四个不同的路径，af,ai,ao,ac。</p><p>Zt→af→ft→Ct→h_t→J。- >遗忘门</p><p>Zt→ai→it→Ct→h_t→J。- >输入门</p><p>Zt→ac→c~t→Ct→h_t→J。->单元状态</p><p>Zt→ao→ot→Ct→h_t→J。- >输出门</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e8116039cef405eba2dd551a3bb32f3><p class=pgc-img-caption></p></div><p><br></p><p>权重和偏差</p><p>W和b的推导很简单。下面的推导是针对Lstm的输出门的。对于其余的门，对权重和偏差也进行了类似的处理。</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/65c8ac3574d7443994ecf1092112eaed><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/753994fd02a5418f8343a8977ca7ffa3><p class=pgc-img-caption></p></div><p><br></p><p>输入和遗忘门的权重和偏差</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9424d410eb57415db30747e6d54ca8e1><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfe469afa5ba404abfaa707ab6acd50f><p class=pgc-img-caption></p></div><p><br></p><p>输出和输出门的权重和偏差</p><p>J/dWf = dJ/daf。daf / dWf ->遗忘门</p><p>dJ/dWi = dJ/dai。dai / dWi ->输入门</p><p>dJ/dWv = dJ/dVtdVt/ dWv ->输出门</p><p>dJ/dWo = dJ/dao。dao / dWo ->输出门</p><p>我们完成了所有的推导。但是有两点需要强调</p><p>到目前为止，我们所做的只是一个时间步长。现在我们要让它只进行一次迭代。</p><p>所以如果我们有总共T个时间步长，那么每一个时间步长的梯度会在T个时间步长结束时相加，所以每次迭代结束时的累积梯度为:</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f48b1709e5764dd189788852cebe1ece><p class=pgc-img-caption></p></div><p><br></p><p>每次迭代结束时的累积梯度用来更新权重</p><div class=pgc-img><img alt=手推公式：LSTM单元梯度的详细的数学推导 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/713a704001644bd48667681633eebce8><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>总结</h1><p>LSTM是非常复杂的结构，但它们工作得非常好。具有这种特性的RNN主要有两种类型:LSTM和GRU。</p><p>训练LSTMs也是一项棘手的任务，因为有许多超参数，而正确地组合通常是一项困难的任务。</p><p>作者：Rahuljha</p><p>deephub翻译组</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'LSTM','单元','详细'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>