<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>数据结构与算法（5）栈 | 极客快訊</title><meta property="og:title" content="数据结构与算法（5）栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/64b8a77987c34980862b62b33586c54e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c3e3bf2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c3e3bf2.html><meta property="article:published_time" content="2020-10-29T21:05:31+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:31+08:00"><meta name=Keywords content><meta name=description content="数据结构与算法（5）栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c3e3bf2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>数据结构与算法（5）栈</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=数据结构与算法（5）栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64b8a77987c34980862b62b33586c54e><p class=pgc-img-caption></p></div><p class=ql-align-justify><strong>前言</strong></p><p class=ql-align-justify><strong>栈</strong>（<strong>stack</strong>）又称为<strong>堆栈或堆叠</strong>，栈作为一种数据结构，是一种只能在一端进行插入和删除操作的特殊<strong>线性表</strong>，也就是栈是一种<strong>操作受限</strong>的线性表。它按照<strong>先进后出</strong>的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。栈具有记忆作用，对栈的插入与删除操作中，不需要改变栈底指针。</p><p class=ql-align-justify><strong>基本概念</strong></p><p class=ql-align-justify>栈是允许在同一端进行插入和删除操作的特殊线性表。允许进行插入和删除操作的一端称为<strong>栈顶(top)</strong>，另一端为<strong>栈底(bottom)</strong>；栈底固定，而栈顶浮动；栈中元素个数为零时称为<strong>空栈</strong>。插入一般称为<strong>进栈（PUSH）</strong>，删除则称为<strong>退栈（POP）</strong>。</p><p class=ql-align-justify>由于堆叠数据结构只允许在一端进行操作，因而按照<strong>后进先出</strong>（<strong>LIFO</strong>, Last In First Out）的原理运作。<strong>栈也称为后进先出表</strong>。</p><p class=ql-align-justify>生活中使用栈的场景很多，这里以羽毛球筒为例，羽毛球筒就是一个栈，刚开始羽毛球筒是空的，也就是空栈，然后我们一个一个放入羽毛球，也就是一个一个<strong>push进栈</strong>，当我们需要使用羽毛球的时候，从筒里面拿，也就是<strong>pop出栈</strong>，但是第一个拿到的羽毛球是我们最后放进去的。</p><p class=ql-align-justify><strong>与内存中栈的区别</strong></p><ul><li class=ql-align-justify>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。</li><li class=ql-align-justify>内存空间在逻辑上分为三部分：<strong>代码区</strong>、<strong>静态数据区</strong>和<strong>动态数据区</strong>，动态数据区又分为<strong>栈区</strong>和<strong>堆区</strong>。</li><li class=ql-align-justify>代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。</li><li class=ql-align-justify>静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。</li><li class=ql-align-justify>栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。</li><li class=ql-align-justify>堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</li></ul><p class=ql-align-justify><strong>栈的实现</strong></p><p class=ql-align-justify>首先我们需要了解下栈都有哪些操作：</p><p class=ql-align-justify>通过查看JDK中栈的源代码<strong>java.util.Stack&lt;E></strong>，我们知道栈至少有下面几个操作：</p><ul><li class=ql-align-justify><strong>push 入栈</strong></li><li class=ql-align-justify><strong>pop 出栈</strong></li><li class=ql-align-justify><strong>peek 访问栈顶元素</strong></li><li class=ql-align-justify><strong>empty 判断栈是否为空</strong></li><li class=ql-align-justify><strong>search 查找站内元素</strong></li></ul><p class=ql-align-justify>栈即可用数组实现，也可以用链表实现，用数组实现的栈，叫做<strong>顺序栈</strong>，用链表实现的栈，叫做<strong>链式栈</strong>。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶数据的操作，所以时间复杂度都是<strong>O(1)</strong>。</p><p class=ql-align-justify><strong>乞丐版（固定大小）</strong></p><p class=ql-align-justify><strong>数组实现栈</strong></p><pre>//基于数组实现的顺序栈public class ArrayStack { private String[] items; // 数组 private int count; // 栈中元素个数 private int n; // 栈的大小 // 初始化数组，申请一个大小为 n 的数组空间 public ArrayStack(int n) { this.items = new String[n]; this.n = n; this.count = 0; } // 入栈操作 public boolean push(String item) { // 数组空间不够了，直接返回 false，入栈失败。 if (count == n) return false; // 将 item 放到下标为 count 的位置，并且 count 加一 items[count] = item; ++count; return true; } // 出栈操作 public String pop() { // 栈为空，则直接返回 null if (count == 0) return null; // 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一 String tmp = items[count - 1]; --count; return tmp; }}</pre><p class=ql-align-justify><strong>链表实现栈</strong></p><pre>public static class LinkedListBasedStack { private int size; private Node top;  static Node createNode(String data, Node next) { return new Node(data, next); } public void clear() { this.top = null; this.size = 0; } public void push(String data) { Node node = createNode(data, this.top); this.top = node; this.size++; } public String pop() { Node popNode = this.top; if (popNode == null) { System.out.println("Stack is empty."); return null; } this.top = popNode.next; if (this.size &gt; 0) { this.size--; } return popNode.data; } public String getTopData() { if (this.top == null) { return null; } return this.top.data; } public int size() { return this.size; } public void print() { System.out.println("Print stack:"); Node currentNode = this.top; while (currentNode != null) { String data = currentNode.getData(); System.out.print(data + "\t"); currentNode = currentNode.next; } System.out.println(); } public static class Node { private String data; private Node next; public Node(String data) { this(data, null); } public Node(String data, Node next) { this.data = data; this.next = next; } public void setData(String data) { this.data = data; } public String getData() { return this.data; } public void setNext(Node next) { this.next = next; } public Node getNext() { return this.next; } }}</pre><p><strong>增强版（动态扩容）</strong></p><p>上面我们实现的栈，都是固定大小的，也就是说，在初始化栈时需要制定栈的大小，而且一旦初始化，后边是不能扩容的，当栈满了以后，就不能再往栈里添加数据了。尽管链式栈的大小不受限，但是需要存储指针，内存消耗会比较多。</p><p>在学习数组的时候，我们实现了一个支持动态扩容的数组，就是当数组空间不够用时，重新申请一块更大的内存，将原来数组汇总的数据拷贝进去，这样就实现了一个支持动态扩容的数组。同理，动态扩容的栈也可以这样做，当栈满了以后，就申请一个更大的数组将原来的数据搬移到新的数据中，我们可以看下JDK源码中对栈进行扩容的部分：</p><pre>/** * This implements the unsynchronized semantics of ensureCapacity. * Synchronized methods in this class can internally call this * method for ensuring capacity without incurring the cost of an * extra synchronization. * * @see #ensureCapacity(int) */private void ensureCapacityHelper(int minCapacity) { // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);}/** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);}private static int hugeCapacity(int minCapacity) { if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;}</pre><p>是不是很熟悉，链表就是这么干的，其实底层都是用的数组拷贝。现在我们已经知道如何实现一个动态扩容的栈了：</p><pre>import java.util.Arrays;import java.util.EmptyStackException;public class ArrayBasedStackUp { // 存储元素的数组,声明为Object类型能存储任意类型的数据 private Object[] elementData; // 指向栈顶的指针 private int top; // 栈的总容量 private int size; // 默认构造一个容量为10的栈 public ArrayBasedStackUp() { this.elementData = new Object[10]; this.top = -1; this.size = 10; } public ArrayBasedStackUp(int initialCapacity) { if (initialCapacity &lt; 0) { throw new IllegalArgumentException("栈初始容量不能小于0: " + initialCapacity); } this.elementData = new Object[initialCapacity]; this.top = -1; this.size = initialCapacity; } // 压入元素 public Object push(Object item) { // 是否需要扩容 isGrow(top + 1); elementData[++top] = item; return item; } // 弹出栈顶元素 public Object pop() { Object obj = peek(); remove(top); return obj; } // 获取栈顶元素 public Object peek() { if (top == -1) { throw new EmptyStackException(); } return elementData[top]; } // 判断栈是否为空 public boolean isEmpty() { return (top == -1); } // 删除栈顶元素 public void remove(int top) { // 栈顶元素置为null elementData[top] = null; this.top--; } /** * 是否需要扩容，如果需要，则扩大一倍并返回true，不需要则返回false *  * @param minCapacity * @return */ public boolean isGrow(int minCapacity) { int oldCapacity = size; // 如果当前元素压入栈之后总容量大于前面定义的容量，则需要扩容 if (minCapacity &gt;= oldCapacity) { // 定义扩大之后栈的总容量 int newCapacity = 0; // 栈容量扩大两倍(左移一位)看是否超过int类型所表示的最大范围 if ((oldCapacity &lt;&lt; 1) - Integer.MAX_VALUE &gt; 0) { newCapacity = Integer.MAX_VALUE; } else { newCapacity = (oldCapacity &lt;&lt; 1);// 左移一位，相当于*2 } this.size = newCapacity; elementData = Arrays.copyOf(elementData, size); return true; } else { return false; } }}</pre><p class=ql-align-justify>我们来分析下支持动态扩容的顺序栈的入栈、出栈操作的时间复杂度。对于出栈操作来说，不会涉及内存的重新申请和数据的搬移，所以时间复杂度还是O(1)，但是，对于入栈来说就不一样了，当栈中有空余空间时，入栈的操作时间复杂度就是O(1)，但是当空间不够时，就需要重新申请内存和数据搬移，时间复杂度就成了O(n)。因为只有极少数情况才会进行数据搬移（只有栈满才会搬移），少数服从多数，所以平均时间复杂度就是O(1)。</p><p class=ql-align-justify><strong>栈的应用</strong></p><p class=ql-align-justify><strong>函数调用栈</strong></p><p class=ql-align-justify>函数调用栈是非常经典的应用场景，我们知道，操作系统给每个线程分配了一块独立的内存空间，这块内存空间被组织成栈这种结构，用来存储函数调用时的临时变量，每进入一个函数，会将临时变量作为一个栈帧入栈，函数调用完成后，将这个函数对应的栈帧出栈。来看下边这段代码：</p><pre>public static void main(String[] args) { int a = 1; int ret = 0; int res = 0; ret = add(3, 5); res = a + ret; System.out.println(res);}public static int add(int x, int y) { int sum = 0; sum = x + y; return sum;}</pre><p>main函数调用add函数，获取到add函数的计算结果，并且与临时变量a相加，然后打印res的值。下图是执行到add函数时，函数调用栈的使用情况：</p><div class=pgc-img><img alt=数据结构与算法（5）栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b154bb72493f44cfa7a0217669720bac><p class=pgc-img-caption></p></div><p>为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</p><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><p><strong>表达式求值</strong></p><p>20世纪50年代，波兰逻辑学家Jan Łukasiewicz想到了一种不需要括号的后缀表达法，即<strong>逆波兰</strong>（Reverse Polish Notation）表示，这一表示方式，巧妙地解决了程序实现四则运算的难题。</p><p>在计算机中，表达式求值是利用两个栈来实现的，一个栈保存操作数，一个栈保存运算符，我们从左到右遍历表达式，当遇到数字时，就直接压入操作数栈，当遇到运算符时，就与运算符栈的栈顶元素进行比较，如果比运算符栈的栈顶元素优先级高，就将当前运算符压入栈，如果比运算符栈的栈顶元素优先级相同，从运算符栈中取出栈顶运算符，从操作数栈中取栈顶两个操作数，然后进行计算，再把计算的结果压入操作数栈，继续比较。</p><p>我们以3+5*8-6为例，理解下上面的过程：</p><div class=pgc-img><img alt=数据结构与算法（5）栈 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/071f8bb8b25f47e5baa36e29ab2b9152><p class=pgc-img-caption></p></div><pre>import java.util.Scanner;import java.util.Stack;/** * 程序代码来源于：https://blog.csdn.net/guying_2016/article/details/82348464 * 思路参考：https://blog.csdn.net/u011446177/article/details/42389511?locationNum=15&amp;fps=1 * 四则运算的两个操作过程及其他辅助判断 *  * 使用栈实现四则运算 * 1.中缀表达式 --&gt; 后缀表达式  * 思路：从左到右遍历中缀表达式的每个数字和符号  * 若是数字，直接输出（或保存到某一链表中） * 若是符号，则判断其与栈顶符号的优先级 是 右括号 或 优先级不高于 栈顶符号的优先级，则栈顶元素依次出栈并输出 并将当前符号进栈，一直到最终输出后缀表达式为止。 * 注意：栈顶元素与当前符号优先级相同也要输出！ * 2.后缀表达式进行四则运算 * 思路：把数字压入堆栈，遇到操作符就从栈中取出两个数进行相关运算，把结果在存放入栈中直到最后操作完成，输出最终结果 */public class ArithmeticExp { // 成员变量 private String prefixExp; // 前缀表达式 private String infixExp; // 中缀表达式 private String postfixExp; // 后缀表达式 /** * 构造方法 */ public ArithmeticExp() { } public ArithmeticExp(String infixExp) { this.infixExp = infixExp; } public String getPrefixExp() { return prefixExp; } public void setPrefixExp(String prefixExp) { this.prefixExp = prefixExp; } public String getInfixExp() { return infixExp; } public void setInfixExp(String infixExp) { this.infixExp = infixExp; } public String getPostfixExp() { return postfixExp; } public void setPostfixExp(String postfixExp) { this.postfixExp = postfixExp; } /** * 1.转化成后缀表达式（逆波兰表达式） */ public void cover2PostfixExp() { // 创建堆栈 Stack&lt;Character&gt; ls = new Stack&lt;Character&gt;(); this.postfixExp = ""; // 遍历表达式的每一个字符 for (int i = 0; this.infixExp != null &amp;&amp; i &lt; this.infixExp.length(); i++) { char ch = this.infixExp.charAt(i); if (' ' != ch) { // 当前字符不为空 时的操作 if (isLeftBracket(ch)) { // 是左括号，压栈 ls.push(ch); } else if (isRightBracket(ch)) { // 是右括号，将所有操作符出栈，直到遇到一个左括号，并将这个左括号丢弃 char topOperator = ls.pop(); while (!isLeftBracket(topOperator)) { postfixExp += (topOperator + " "); // 使用空格 隔开 topOperator = ls.pop(); } } else if (isOperator(ch)) { // 是操作符，要判断优先级，再决定是否需要入栈 /** * 如果栈为空，直接进栈。如果栈非空，则需要将栈顶运算符的优先级和要入栈的运算符的优先级进行比较 * 将栈中比要入栈的运算符优先级高的运算符都出栈，然后将该运算符入栈 */ if (!ls.isEmpty()) { // 如果栈非空 // 获取栈顶的运算符 Character topOperator = ls.peek(); while (topOperator != null &amp;&amp; priority(topOperator.charValue()) &gt;= priority(ch)) { postfixExp += (ls.pop() + " "); if (!ls.isEmpty()) { topOperator = ls.peek(); } else { break; } } } // 将当前操作符 压栈 ls.push(ch); } else { if (i &gt; 0 &amp;&amp; isNumber(infixExp.charAt(i - 1))) { postfixExp = postfixExp.substring(0, postfixExp.length() - 1) + ch + " "; } else { postfixExp += ch + " "; } } } } while (!ls.isEmpty()) { postfixExp += (ls.pop() + " "); } // 去除表达式中的最后一个空格 // postfixExp = postfixExp.substring(0, postfixExp.length() - 1); postfixExp = postfixExp.trim(); } /** * 运算符优先级比较 *  * @param charValue * @return */ public int priority(char charValue) { switch (charValue) { case '+': case '-': return 1; case '*': case '/': case '%': return 2; case '^': return 3; } return 0; } /** * 判断是否是操作符 *  * @param ch * @return */ public boolean isOperator(char ch) { if (ch == '+' || ch == '-' || ch == '*' || ch == '/' || ch == '^' || ch == '%') { return true; } return false; } /** * 2.使用后缀表达式 进行 四则运算 */ public int calculateExpResult() { String[] strs = this.postfixExp.split(" "); Stack&lt;Integer&gt; ls = new Stack&lt;Integer&gt;(); for (int i = 0; i &lt; strs.length; i++) { // 如果是操作符，从堆栈获取两个值，进行运算 if (strs[i].length() == 1 &amp;&amp; isOperator(strs[i].charAt(0))) { int num2 = ls.pop(); int num1 = ls.pop(); ls.push(calculate2Numbers(num1, num2, strs[i].charAt(0))); } else { // 如果是数字，压入堆栈 ls.push(Integer.parseInt(strs[i])); } } return ls.pop(); } /** * 两数的运算操作 *  * @param num1 * @param num2 * @param operator * @return */ public Integer calculate2Numbers(int num1, int num2, char operator) { switch (operator) { case '+': return num1 + num2; case '-': return num1 - num2; case '*': return num1 * num2; case '/': return num1 / num2; case '%': return num1 % num2; case '^': return num1 ^ num2; } return null; } /** * 判断是否是左括号 *  * @param ch * @return 布尔值 */ public boolean isLeftBracket(char ch) { if (ch == '(') { return true; } return false; } /** * 判断是否是右括号 *  * @param ch * @return 布尔值 */ public boolean isRightBracket(char ch) { if (ch == ')') { return true; } return false; } /** * 判断是否是数字 *  * @param ch * @return */ public boolean isNumber(char ch) { if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') { return true; } return false; } // 中缀表达式：9+(3-1)*3+10/2 public static void main(String[] args) { // 从控制台获取中缀表达式 Scanner sc = new Scanner(System.in); String infixExp = sc.nextLine(); sc.close(); // 创建对象，进行后续操作 ArithmeticExp ae = new ArithmeticExp(infixExp); System.out.println("中缀表达式：" + ae.getInfixExp()); // 转化为后缀表达式 ae.cover2PostfixExp(); System.out.println("后缀表达式：" + ae.getPostfixExp()); System.out.println(ae.getPostfixExp().length()); // 使用后缀表达式 进行 四则运算 int calculateExpResult = ae.calculateExpResult(); // 结果输出 System.out.println("计算结果：" + calculateExpResult); }}</pre><p><strong>栈实现字符串逆序</strong></p><p>我们知道栈是后进先出，我们可以将一个字符串分隔为单个的字符，然后将字符一个一个push()进栈，在一个一个pop()出栈就是逆序显示了。如下：</p><pre>// 利用栈反转字符串public void testStringReversal() { ArrayBasedStackUp stack = new ArrayBasedStackUp(); String str = "how are you"; char[] cha = str.toCharArray(); for (char c : cha) { stack.push(c); } while (!stack.isEmpty()) { System.out.print(stack.pop()); }}</pre><p><strong>判断括号匹配</strong></p><p>写XML或者HTML标签时，括号都是成对出现的，比如&lt;和>就是匹配的一对，对于 12&lt;a[b{c}]>，我们可以将字符一次入栈，遇到匹配正确的就消除，最后栈中的内容为空则匹配成功，否则匹配失败。如下图所示：</p><div class=pgc-img><img alt=数据结构与算法（5）栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4bc39ff76fdd4d48bd8cebc143798bcf><p class=pgc-img-caption></p></div><pre>// 利用栈判断括号是否匹配public void testMatch() { ArrayBasedStackUp stack = new ArrayBasedStackUp(3); String str = "12&lt;a[b{c}]&gt;"; char[] cha = str.toCharArray(); for (char c : cha) { switch (c) { case '{': case '[': case '&lt;': stack.push(c); break; case '}': case ']': case '&gt;': if (!stack.isEmpty()) { char ch = stack.pop().toString().toCharArray()[0]; if (c == '}' &amp;&amp; ch != '{' || c == ']' &amp;&amp; ch != '[' || c == ')' &amp;&amp; ch != '(') { System.out.println("Error:" + ch + "-" + c); } } break; default: break; } }}</pre><p><strong>栈实现浏览器前进后退</strong></p><p>实现浏览器的前进后退功能，需要用两个栈，栈X和栈Y，我们把首次浏览的页面依次加入栈X，当点击后退按钮时，再依次从栈X中出栈，将出栈的数据依次放入栈Y，当按前进按钮时，依次从栈Y中取出数据，放入栈X中，当栈X中没有数据时，说明没有页面可以进行后退了，当Y中没有数据时，说明没有页面可以前进浏览了。如果在回退浏览的过程中，跳入了栈中不存在的页面，这时候就要清空栈Y中的数据。</p><pre>public class SampleBrowser { public static void main(String[] args) { SampleBrowser browser = new SampleBrowser(); browser.open("http://www.baidu.com"); browser.open("http://news.baidu.com/"); browser.open("http://news.baidu.com/ent"); browser.goBack(); browser.goBack(); browser.goForward(); browser.open("http://www.qq.com"); browser.goForward(); browser.goBack(); browser.goForward(); browser.goBack(); browser.goBack(); browser.goBack(); browser.goBack(); browser.checkCurrentPage(); } private String currentPage; private LinkedListBasedStack backStack; private LinkedListBasedStack forwardStack; public SampleBrowser() { this.backStack = new LinkedListBasedStack(); this.forwardStack = new LinkedListBasedStack(); } public void open(String url) { if (this.currentPage != null) { this.backStack.push(this.currentPage); this.forwardStack.clear(); } showUrl(url, "Open"); } public boolean canGoBack() { return this.backStack.size() &gt; 0; } public boolean canGoForward() { return this.forwardStack.size() &gt; 0; } public String goBack() { if (this.canGoBack()) { this.forwardStack.push(this.currentPage); String backUrl = this.backStack.pop(); showUrl(backUrl, "Back"); return backUrl; } System.out.println("* Cannot go back, no pages behind."); return null; } public String goForward() { if (this.canGoForward()) { this.backStack.push(this.currentPage); String forwardUrl = this.forwardStack.pop(); showUrl(forwardUrl, "Foward"); return forwardUrl; } System.out.println("** Cannot go forward, no pages ahead."); return null; } public void showUrl(String url, String prefix) { this.currentPage = url; System.out.println(prefix + " page == " + url); } public void checkCurrentPage() { System.out.println("Current page is: " + this.currentPage); }}</pre><div class=pgc-img><img alt=数据结构与算法（5）栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec3bc67eb8864ca9ad6cd22b6c583016><p class=pgc-img-caption>微信公众号：行知老王</p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'数据','结构','算法'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E5%AD%A6/ef6637be.html alt=数据结构与算法——最小生成树 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/36b27200eb7c41258d8210393c3e09bf style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E5%AD%A6/ef6637be.html title=数据结构与算法——最小生成树>数据结构与算法——最小生成树</a></li><hr><li><a href=../../cn/%E7%A7%91%E6%8A%80/2a4da90.html alt=数据结构与算法系列——栈 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0d4a7d6b37a44c58a0ea25dcacf791fe style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/2a4da90.html title=数据结构与算法系列——栈>数据结构与算法系列——栈</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>