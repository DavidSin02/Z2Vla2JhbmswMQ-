<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JS开发的你，真的会用console吗？ | 极客快訊</title><meta property="og:title" content="JS开发的你，真的会用console吗？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/cc21d382d2af414db102bbf1b7fa3420"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c5018ab7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c5018ab7.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="JS开发的你，真的会用console吗？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c5018ab7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JS开发的你，真的会用console吗？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在我们的日常前端开发中，使用最频繁的莫过于使用console.log在浏览器的控制台中打印出我们需要调试的信息，但是大部分人可能跟之前的我一样，没有意识到其实console除了log方法以外，还有很多实用的方法，这些方法可以使我们的调试过程更加容易，也表达得更加直观，更加丰富多彩，下面我们就来看看有哪些实用的方法吧！</p><h1>1、console.log()</h1><p>我们经常会使用console.log来打印出某个变量的值或者某个实体对象，也可以传入多个变量参数，它会按照传入顺序进行打印：</p><pre>1. 传入一个变量const a = 1;console.log(a); // -&gt; 12. 传入一个对象const foo = {a: 1};console.log(foo); // -&gt; {a: 1}3. 传入多个变量console.log(a, foo); // -&gt; 1 {a: 1} 复制代码</pre><p>除此之外，它还支持<strong>格式化打印</strong>的功能，传入特定的<strong>占位符</strong>来对参数进行格式化处理，常见的占位符有以下几种：</p><ol start=1><li>%s：字符串占位符</li><li>%d：整数占位符</li><li>%f：浮点数占位符</li><li>%o：对象占位符(注意是字母o，不是数字0)</li><li>%c: CSS样式占位符</li></ol><pre>const string = 'Glory of Kings';const number = 100;const float = 9.5;const obj = {name: 'daji'};1、%s 字符串占位符console.log('I do like %s', string); // -&gt; I do like Golry of Kings.2、%d 整数占位符console.log('I won %d times', number);// -&gt; I won 100 times.3、%f 浮点数占位符console.log('My highest score is %f', float);// -&gt; My highest score is 9.54、%o 对象占位符console.log('My favorite hero is %o', obj);// -&gt; My favorite hero is {name: 'daji'}.5、%c CSS样式占位符console.log('I do like %c%s',  'padding: 2px 4px;background: orange;color: white;border-radius: 2px;', string);</pre><p>其中CSS样式占位符效果如下：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc21d382d2af414db102bbf1b7fa3420><p class=pgc-img-caption></p></div><p><br></p><h1>2、console.warn()</h1><p>你可以完全使用console.warn来代替console.log方法，但前提是该条打印信息是属于警告级别而不是普通信息级别，因此浏览器遇到一条警告级别的信息会区别对待，最明显的是它的左侧会有一个警告图标，并且背景色和文字颜色也会不一样。</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6f9e165425374d829777a40cfa904bd5><p class=pgc-img-caption></p></div><p>相比于普通信息，警告信息会出现在上图左侧的warning面板中，而不是info面板中，这样也有助于我们在一堆打印信息中快速筛选出警告信息，方便查看。</p><p><br></p><h1>3、console.dir()</h1><p>在大多数情况下，console.dir方法的作用和console.log作用相似，但是有一点细微的差别。</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/78fd336bf34b472ca4476f104e7c704a><p class=pgc-img-caption></p></div><p>在上图中，我们可以看到，console.log方法会将打印结果的详细信息显示完整，但是console.dir方法只会打印出对象，不会展开详细信息，当然点击之后看到的信息和前者一样。 唯一差异比较大的地方是当我们打印HTML文档中的节点时，会有完全不一样的表现形式。例如我们使用console.log来打印body标签：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6f4d174c82114a598443678211d6e336><p class=pgc-img-caption></p></div><p>我们会方便地看到DOM结构，并且鼠标移上去能够帮我们自动定位到对应的DOM节点。但是在某些情况下，其实这并不是你想要看到的效果，或许你想看到的是该DOM节点下的所有属性信息，那么你可以尝试使用console.dir方法来试试：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1ba63c7c982e4ec2a3eb0b834d3aaebd><p class=pgc-img-caption></p></div><p><br></p><h1>4、console.table()</h1><p>在我们的项目开发中经常会遇到对象数组形式的列表数据，在调试过程中我们可能会使用console.log方法打印出这些数据来进行查看，但比起前者，还可以使用一种比较可视化的方式来进行打印。例如，这里准备一些列表数据：</p><pre>const response = [ { id: 1, name: 'Marry', age: 18, sex: 0 }, { id: 2, name: 'John', age: 20, sex: 1 }];</pre><p>然后我们使用console.log来进行打印：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9bfe6fd2b5f045f6974bd222724c4ea3><p class=pgc-img-caption></p></div><p>可以看出，我们打印出的结果并不够直接，没有给人一种一目了然的效果，接着换着使用console.table来打印：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5da9249de0ca4110a5ba24cd9c16fca6><p class=pgc-img-caption></p></div><p>可以看到，我们的列表数据被清晰完整地展现在了表格当中，同时console.table提供第二个可选参数用于筛选表格需要显示的列，默认为全部列都显示。</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf68c435352143318e0837cb86b303b1><p class=pgc-img-caption></p></div><p>上图我们通过添加第二个参数，数组中为需要在表格中显示的字段名，这样就很方便地在结果数据中过滤掉我们不需要关心的信息。</p><p><br></p><h1>5、console.assert()</h1><p>assert即断言，该方法接收多个参数，其中第一个参数为输入的表达式，只有在该表达式的值为false时，才会将剩余的参数输出到控制台中。</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c9eecada394f4604a8596572a74f9574><p class=pgc-img-caption></p></div><p>上图中的第二行因为arr.length > 5值为false，因此打印出后面的信息。如果在某些场景下你需要评估当前的数据是否满足某个条件，那么不妨使用console.assert()方法来在控制台中查看断言信息。</p><p><br></p><h1>6、console.trace()</h1><p>该方法用于在控制台中显示当前代码在堆栈中的调用路径，通过这个调用路径我们可以很容易地在发生错误时找到原始错误点，示例如下：</p><pre>function foo(data) { if (data === null) { console.trace(); return []; } return [data.a, data.b];}function bar1(data) { return foo(data);}function bar2(data) { return foo(data);}bar1({a: 1, b: 2}); // -&gt; [1, 2]bar2(null); // -&gt; []</pre><p>在上面代码中，我们分别在bar1和bar2函数中调用foo函数并传入不同的参数，很显然bar2函数在执行时会进入if语句并执行console.trace()方法，以下是控制台中打印结果：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/12afd8da34e7416ba33fdb6cb95aa79d><p class=pgc-img-caption></p></div><p>可以看到自下而上的一条调用路径，并可以快速判定是在bar2函数中传入了不合适的参数null而导致出错，方便我们跟踪发生错误的原始位置。</p><p><br></p><h1>7、console.count()</h1><p>该方法相当于一个计数器，用于记录调用次数，并将记录结果打印到控制台中。其接收一个可选参数console.count(label)，label表示指定标签，该标签会在调用次数之前显示，示例如下：</p><pre>for (let i = 1;i &lt;= 5;i++) { if (!(i % 2)) { console.count('even'); } else { console.count('odd'); }}</pre><p>代码中如果i是偶数，则会对even计数器进行计数，否则对odd计数器进行计数，执行后我们会在控制台中看到如下列表：</p><pre>odd: 1even: 1odd: 2even: 2odd: 3</pre><h1>8、console.time() & console.timeEnd()</h1><p>这两个方法一般配合使用，是JavaScript中用于跟踪程序执行时间的专用函数，console.time方法是作为计算的起始时间，console.timeEnd是作为计算的结束时间，并将执行时长显示在控制台。如果一个页面有多个地方需要使用到计算器，则可以为方法传入一个可选参数label来指定标签，该标签会在执行时间之前显示。在以往我们计算程序的执行时间时，我们一般会采用如下方式：</p><pre>const startTime = performance.now();let sum = 0;for(let i = 0;i &lt; 100000;i++) { sum += i;}const diffTime = performance.now() - startTime;console.log(`Execution time: ${ diffTime }`);</pre><p>这是一种比较传统的做法，我们还可以使用console.time来实现：</p><pre>console.time('sum');let sum = 0;for(let i = 0;i &lt; 100000;i++) { sum += i;}console.timeEnd('sum');</pre><p>控制台效果如下：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/db62152d992145d198cfb386efba9c6d><p class=pgc-img-caption></p></div><p>相比于第一种实现方式，我们没有设置任何临时变量并且没有做任何计算。</p><p><br></p><h1>9、console.group() & console.groupEnd()</h1><p>顾名思义，对数据信息进行分组，其中console.group()方法用于设置分组信息的起始位置，该位置之后的所有信息将写入分组，console.groupEnd()方法用于结束当前的分组，示例如下：</p><pre>class MyClass { constructor() { console.group('Constructor'); console.log('Constructor executed'); this.init(); console.groupEnd(); } init() { console.group('init'); console.log('init executed'); console.groupEnd(); }}const myClass = new MyClass();</pre><p>控制台效果如下：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e137661d40d4d83a1f7592428a18c32><p class=pgc-img-caption></p></div><p>该方法的作用主要是让我们在控制台打印的日志更加清晰可读。</p><p><br></p><h1>10、浏览器转为编辑器</h1><p>在大部分情况下，我们在浏览器中调试DOM结构或者编辑一些文本时，会在Chrome Developer Tools的Elements选项中对DOM节点进行编辑，但是一旦节点过多，会很容易增加调试过程的困难，这里我们可以使用一种方式来将浏览器直接转换为编辑器模式：</p><pre>document.body.contentEditable = true;</pre><p>在控制台中输入以上代码后，可以将浏览器中的所有内容变为可编辑状态，效果图如下：</p><p><br></p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1ceda609e3da4f6696b1ab13eff5a5f5><p class=pgc-img-caption></p></div><p><br></p><h1>11、Chrome Command Line API</h1><p>Google的Chrome Command Line API包含了一个用于执行以下常见任务的便捷函数集合：选择和检查DOM元素，以可读格式显示数据，停止和启动分析器，以及监控DOM事件。</p><blockquote><p>注意：此API只能通过浏览器控制台获取，无法通过网页脚本来进行访问。</p></blockquote><p>11.1 选择DOM元素</p><p>当我们使用jQuery的时候，我们可以通过各种选择器例如$('#id')和$('.class')来选择匹配的DOM元素，但是如果我们没有引入jQuery时，我们仍然可以在Chrome的控制台中进行同样的操作。Chrome Command Line API提供了以下几种选择DOM元素的方式：</p><ul><li>$(selector)：返回匹配指定CSS选择器的DOM元素的第一个引用，相当于document.querySelector()函数。</li><li>$$(selector)：返回匹配指定CSS选择器的DOM元素数组，相当于document.querySelectorAll()函数。</li><li>$x(path)：返回一个与给定XPath表达式匹配的DOM元素数组。</li></ul><blockquote><p>$x('//p[a]')表示返回包含&lt;a>元素的所有&lt;p>元素。</p></blockquote><p>11.2 检索最后一个结果的值</p><p>在控制台中我们经常会进行一些计算，某些情况下你可能需要跟踪你之前的计算结果来用于后面的计算，使用$_标记可用于返回最近评估的表达式的值，示例如下：</p><pre>1 + 2 + 3 + 4 // -&gt; 10$_ // -&gt; 10$_ * $_ // -&gt; 100Math.sqrt($_) // -&gt; 10$_ // -&gt; 10</pre><p>11.3 查找与指定DOM元素关联的事件</p><p>当我们需要查找DOM中与某个元素关联的所有事件时，控制台提供了getEventListeners方法来帮助我们找到这些关联的事件。<br>getEventListeners($('selector'))返回在指定DOM元素上注册的事件监听器。返回值是一个对象，对象的key为对应的事件类型(例如click，focus)，对象的value为一个数组，其包含了对应事件类型下的所有事件监听器。例如，下面列出了在document上注册的所有事件监听器：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/edc39abd20c043fe978f719d0fe7ed86><p class=pgc-img-caption></p></div><p>如果我们需要找到某个特定的事件监听器，可以通过如下方式进行访问：</p><p><br></p><pre>// eventName表示对应的事件类型// index表示该事件类型下的事件监听器数组的索引getEventListeners($('selector')).eventName[index].listener// 例如获取document下click事件监听器数组的第一项getEventListeners(document).click[0].listener</pre><p>11.4 监控事件</p><p>如果你希望在执行绑定到DOM中特定元素的事件时监视它们，控制台提供了monitorEvents方法来帮助你使用不同的命令来监控其中的一些或者所有事件：</p><ul><li>monitorEvents($('selector'))：将监视与选择器匹配的元素关联的所有事件，当这些事件被触发时会将它们打印到控制台。例如monitorEvents($('#content'))将监视id为content的元素关联的所有事件。</li><li>monitorEvents($('selector'), 'eventName')：将监视选择器匹配的元素的某个特定的事件。 例如，monitorEvents($('#content'), 'click')将监视id为content的元素关联的click事件。</li><li>monitorEvents($('selector'), [eventName1, eventName2, ...])：将监视选择器匹配的元素的某些特定的事件。与上述不同的是，第二项可以传入一个字符串数组，包含所有需要监听的事件类型名称，以此达到自定义监听的目的。例如monitorEvents($('#content'), ['click', 'focus'])将监视id为content的元素关联的click和focus事件。</li><li>unmonitorEvents($('selector'))：将停止监视选择器匹配的元素关联的所有事件。例如unmonitorEvents($('#content'))将停止监视id为content的元素关联的所有事件。</li></ul><p>效果图如下：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/17ce362fd2834a0b97dd8726861bb23e><p class=pgc-img-caption></p></div><p><br></p><p>11.5 检查DOM元素</p><p>控制台提供了inspect()方法让我们可以直接从控制台中检查一个DOM元素。</p><ul><li>inspect($('selector'))：将检查与选择器匹配的元素，并且会自动跳转到Chrome Developer Tools的Elements选项卡中。例如inspect($('#content'))将检查id为content的元素。</li></ul><p>效果图如下：</p><div class=pgc-img><img alt=JS开发的你，真的会用console吗？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e46a26f6be044c7ca9b30acdc54608bf><p class=pgc-img-caption></p></div><p><br></p><h1>总结</h1><p>这篇主要是分享了几个笔者觉得不错的console调试技巧，希望在你的前端代码调试过程中能对你有所帮助</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JS','开发','会用'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>