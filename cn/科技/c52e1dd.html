<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>计算机科学史上伟大的成就之一：Dijkstra最短路径算法 | 极客快訊</title><meta property="og:title" content="计算机科学史上伟大的成就之一：Dijkstra最短路径算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/34d453e5890040df90f58c905190d656"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c52e1dd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c52e1dd.html><meta property="article:published_time" content="2020-10-29T21:08:28+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:28+08:00"><meta name=Keywords content><meta name=description content="计算机科学史上伟大的成就之一：Dijkstra最短路径算法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c52e1dd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>计算机科学史上伟大的成就之一：Dijkstra最短路径算法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>现在，我们准备介绍计算机科学史上伟大的成就之一：Dijkstra最短路径算法[1]。这个算法适用于边的长度均不为负数的有向图，它计算从一个起始顶点到其他所有顶点的最短路径的长度。在正式定义这个问题（3.1节）之后，我们讲解这个算法（3.2节）以及它的正确性证明（3.3节），然后介绍一个简单直接的实现（3.4节）。在第4章中，我们将看到这种算法的一种令人惊叹的快速实现，它充分利用了堆这种数据结构。</p><h1 class=pgc-h-arrow-right>3.1　单源最短路径问题</h1><h1 class=pgc-h-arrow-right>3.1.1　问题定义</h1><p style=text-align:start>Dijkstra算法解决了单源最短路径问题。[2]</p><blockquote><p><strong>问题：单源最短路径</strong></p><p><strong>输入：</strong>有向图<em>G</em>=(<em>V</em>, <em>E</em>)，起始顶点<em>s</em>∈<em>V</em>，并且每条边<em>e</em>∈<em>E</em>的长度<em>e</em>均为非负值。</p><p><strong>输出：</strong>每个顶点<em>v</em>∈<em>V</em>的<em>dist</em>(<em>s</em>,<em>v</em>)。</p></blockquote><p style=text-align:start>注意，<em>dist</em>(<em>s</em>,<em>v</em>)这种记法表示从<em>s</em>到<em>v</em>的最短路径的长度（如果不存在从<em>s</em>到<em>v</em>的路径，<em>dist</em>(<em>s</em>,<em>v</em>)就是+∞）。所谓路径的长度，就是组成这条路径的各条边的长度之和。例如，在一个每条边的长度均为1的图中，路径的长度就是它所包含的边的数量。从顶点<em>v</em>到顶点<em>w</em>的最短路径就是所有从<em>v</em>到<em>w</em>的路径中长度最短的。</p><p style=text-align:start>例如，如果一个图表示道路网，每条边的长度表示从一端到另一端的预期行车时间，那么单源最短路径问题就成为计算从一个起始顶点到所有可能的目的地的行车时间的问题。</p><blockquote><p><strong>小测验3.1</strong></p><p>考虑单源最短路径问题的下面这个输入，起始顶点为<em>s</em>，每个边都有一个标签标识了它的长度：</p><p>从<em>s</em>出发到<em>s</em>、<em>v</em>、<em>w</em>和<em>t</em>的最短距离分别是多少？</p><p>（a）0，1，2，3</p><p>（b）0，1，3，6</p><p>（c）0，1，4，6</p><p>（d）0，1，4，7</p><p>（正确答案和详细解释参见3.1.4节。）</p></blockquote><h1 class=pgc-h-arrow-right>3.1.2　一些前提条件</h1><p style=text-align:start>方便起见，我们假设本章中的输入图是有向图。经过一些微小的戏剧性修改之后，Dijkstra算法同样适用于无向图（可以进行验证）。</p><p style=text-align:start>另一个前提条件比较重要。问题陈述已经清楚地表明：我们假设每条边的长度是非负的。在许多应用中（例如计算行车路线），边的长度天然就是非负的（除非涉及时光机器），完全不需要担心这个问题。但是，我们要记住，图的路径也可以表示抽象的决策序列。例如，也许我们希望计算涉及购买和销售的金融交易序列的利润。这个问题相当于在一个边的长度可能为正也可能为负的图中寻找最短路径。在边的长度可能为负的应用中，我们不应该使用Dijkstra算法，具体原因可以参考3.3.1节。[3]</p><h1 class=pgc-h-arrow-right>3.1.3　为什么不使用宽度优先的搜索</h1><p style=text-align:start>如2.2节所述，宽度优先的搜索的一个“杀手”级应用就是计算从一个起始顶点出发的最短路径。我们为什么需要另一种最短路径算法呢？</p><p style=text-align:start>记住，宽度优先的搜索计算的是从起始顶点到每个其他顶点的边数最少的路径，这是单源最短路径问题中每条边的长度均为1这种特殊情况。我们在小测验3.1中看到，对于通用的非负长度边，最短路径并不一定是边数最少的路径。最短路径的许多应用，例如计算行车路线或金融交易序列，不可避免地涉及不同长度的边。</p><p style=text-align:start>但是，读者可能会觉得，通用的最短路径问题与这种特殊情况真的存在这么大的区别吗？如图3.1所示，我们不能把一条更长的边看成3条长度为1的边组成的路径吗？</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34d453e5890040df90f58c905190d656><p class=pgc-img-caption></p></div><p style=text-align:center>图3.1　路径</p><p>事实上，“一条长度为正整数</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b27f151295a84b19becca32490248d49><p class=pgc-img-caption></p></div><p>的边”和“一条由</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b27f151295a84b19becca32490248d49><p class=pgc-img-caption></p></div><p>条长度为1的边所组成的路径”之间并没有本质的区别。在原则上，我们可以把每条边展开为由多条长度为1的边组成的路径，然后应用宽度优先的搜索对图进行展开来解决单源最短路径问题。</p><p style=text-align:start>这是把一个问题简化为另一个问题的一个例子。在这个例子中，就是从边的长度为正整数的单源最短路径问题简化为每条边的长度均为1的特殊情况。</p><p style=text-align:start>这种简化所存在的主要问题是它扩大了图的规模。如果所有边的长度都是小整数，那么这种扩张并不是严重的问题。但在实际应用中，情况并不一定如此。某条边的长度很可能比原图中顶点和边的总数还要大很多！宽度优先的搜索在扩张后的图中的运行效率是线性时间，但这种线性时间并不一定接近原图长度的线性时间。</p><p style=text-align:start>Dijkstra算法可以看成是在扩张后的图上执行宽度优先的搜索的一种灵活模拟，它只对原始输入图进行操作，其运行时间为近似线性。</p><blockquote><p><strong>关于简化</strong></p><p>如果一种能够解决问题<em>B</em>的算法可以方便地经过转换解决问题<em>A</em>，那么问题<em>A</em>就可以简化为问题<em>B</em>。例如，计算数组的中位元素的问题可以简化为对数组进行排序的问题。简化是算法及其限制的研究中非常重要的概念，具有极强的实用性。</p><p>我们总是应该寻求问题的简化。当我们遇到一个似乎是新的问题时，总是要问自己：这个问题是不是一个我们已经知道怎样解决的问题的伪装版本呢？或者，我们是不是可以把这个问题的通用版本简化为一种特殊情况呢？</p></blockquote><h1 class=pgc-h-arrow-right>3.1.4　小测验3.1的答案</h1><p style=text-align:start><strong>正确答案：（b）。</strong>从<em>s</em>到本身的最短路径的长度为0以及从<em>s</em>到<em>v</em>的最短路径的长度为1不需要讨论。顶点<em>w</em>稍微有趣一点。从<em>s</em>到<em>w</em>的其中一条路径是有向边(<em>s</em>,<em>w</em>)，它的长度是4。但是，通过更多的边可以减少总长度：路径<em>s</em>→<em>v</em>→<em>w</em>的长度只有1+2=3，它是最短的<em>s</em>−<em>w</em>路径。类似地，从<em>s</em>到<em>t</em>的每条经过两次跳跃的路径的长度为7，而那条更迂回的路径的长度只有1+2+3=6。</p><h1 class=pgc-h-arrow-right>3.2　Dijkstra算法</h1><h1 class=pgc-h-arrow-right>3.2.1　伪码</h1><p style=text-align:start>Dijkstra算法的高层结构与第2章的图搜索算法相似。[4]它的主循环的每次迭代处理一个新的顶点。这个算法的高级之处在于它采用了一种非常“聪明”的规则选择接下来处理哪个顶点：就是尚未处理的顶点中看上去最靠近起始顶点的那一个。下面的优雅伪码精确地描述了这个思路。</p><blockquote><p><strong>Dijkstra算法</strong></p><p><strong>输入：</strong>邻接列表表示形式的有向边<em>G</em>=(<em>V</em>,<em>E</em>)，对于每条边<em>e</em>∈<em>E</em>，它的长度都大于或等于0。</p><p><strong>完成状态：</strong>对于每个顶点<em>v</em>，<em>len</em>(<em>v</em>)的值等于真正的最短路径长度<em>dist</em>(<em>s</em>,<em>v</em>)。</p><p>// 初始化 1 <em>X</em> := {<em>s</em>} 2 <em>len</em>(<em>s</em>) := 0, <em>len</em>(<em>v</em>) := +∞ for每个<em>v</em>≠<em>s</em> // 主循环 3 <strong>while</strong> 存在一条边(<em>v</em>,<em>w</em>)，<em>v</em>∈<em>X</em>,<em>w</em>∉<em>X</em> <strong>do</strong> 4 (<em>v</em>*, <em>w</em>*) := 具有最小的<em>len</em>(<em>v</em>)+ 的边 5 把<em>w</em>*加到<em>X</em>中 6 <em>len</em>(<em>w*</em>):=<em> len</em>(<em>v*</em>)+</p></blockquote><p>集合<em>X</em>包含了这个算法已经处理过的顶点。一开始，<em>X</em>只包含了起始顶点（当然，<em>len</em>(<em>s</em>)=0），然后这个集合不断增长，直到它覆盖了从<em>s</em>可以到达的所有顶点。当这个算法把一个顶点添加到<em>X</em>时，它同时为这个顶点的<em>len</em>值赋一个有限的值。主循环的每次迭代向<em>X</em>添加一个新顶点，即某条从<em>X</em>跨越到<em>V</em>−<em>X</em>的边(<em>v</em>,<em>w</em>)的头顶点（图3.2）。（如果不存在这样的边，算法就会终止，对于所有的</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8de17a7b3f7d4bab9addacd422e813b2><p class=pgc-img-caption></p></div><p>，都有<em>len</em>(<em>v</em>)=+∞。）符合条件的边可能有多条，Dijkstra算法选择Dijkstra得分最低的那条边(<em>v</em>*,<em>w</em>*)，它被定义为</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/733f8c7affbd4ab6bc56ca54c25e64fe><p class=pgc-img-caption></p></div><p style=text-align:right>（3.1）</p><p style=text-align:start>注意，Dijkstra得分是根据边进行定义的，顶点<em>w</em>∉<em>X</em>可能是许多不同的从<em>X</em>跨越到<em>V</em>−<em>X</em>的边的头顶点，这些边一般具有不同的Dijkstra得分。</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/176159291f93496fab5cb0c089b83bbc><p class=pgc-img-caption></p></div><p style=text-align:center>图3.2　Dijkstra算法的每次迭代处理一个新顶点，即一条从<em>X</em>跨越到<em>V</em>−<em>X</em>的边的头顶点</p><p>我们可以把一条边(<em>v</em>,<em>w</em>)（<em>v</em>∈<em>X</em>,<em>w</em>∉<em>X</em>）的Dijkstra得分与一个假想相关联。这个假想就是：从<em>s</em>到<em>w</em>的最短路径是由一条从<em>s</em>到<em>v</em>的最短路径（其长度应该是<em>len</em>(<em>v</em>)）和一条紧随其后的边(<em>v</em>,<em>w</em>)（其长度为</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57654aaaa9724acba5698ebb25459583><p class=pgc-img-caption></p></div><p>）所组成的。因此，Dijkstra算法根据已经计算的最短路径的长度，并根据从<em>X</em>跨越到<em>V</em>−<em>X</em>的各条边的长度，在尚未处理的顶点中选择添加看上去最靠近<em>s</em>的那个顶点。在把<em>w</em>*添加到<em>X</em>时，这个算法把<em>len</em>(<em>w</em>*)作为从<em>s</em>出发的假想最短路径的长度，也就是边(<em>v</em>*,<em>w</em>*)的Dijkstra得分<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p>。后面的定理3.1规范描述的Dijkstra算法的神奇之处就在于这个假想保证是正确的，即使这个算法目前只是观察了整个图的很小一部分。[5]</p><h1 class=pgc-h-arrow-right>3.2.2　一个例子</h1><p style=text-align:start>让我们根据小测验3.1的例子对Dijkstra算法进行试验：</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a2f8181eb78a4c83ba69478ed7e58954><p class=pgc-img-caption></p></div><p>一开始，集合<em>X</em>只包含了顶点<em>s</em>，且<em>len</em>(<em>s</em>)=0。在主循环的第1次迭代中，有(<em>s</em>,<em>v</em>)和(<em>s</em>,<em>w</em>)两条边从<em>X</em>跨越到<em>V</em>−<em>X</em>（因此它们均可以扮演(<em>v</em>*,<em>w</em>*)的角色）。这两条边的Dijkstra得分（由式（3.1）所定义）分别是<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2e46f7ce69e43b0a53572e6026973dd><p class=pgc-img-caption></p></div><p>= 0+1=1和<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/20de1e52ee6a46a99a8d52c90c2f8f9c><p class=pgc-img-caption></p></div><p>=0+4=4。由于前者的得分更低，因此它的头顶点<em>v</em>就被添加到<em>X</em>中，并且<em>len</em>(<em>v</em>)被赋值为边(<em>s</em>,<em>v</em>)的Dijkstra得分，其值为1。在第2次迭代时，<em>X</em>={<em>s</em>,<em>v</em>}，有(<em>s</em>,<em>w</em>)、(<em>v</em>,<em>w</em>)和(<em>v</em>,<em>t</em>)共3条边可以扮演(<em>v</em>*,<em>w</em>*)的角色。它们的Dijkstra得分分别是0+4=4、1+2=3和1+6=7。由于(<em>v</em>,<em>w</em>)具有最低的Dijkstra得分，因此<em>w</em>被添加到<em>X</em>中，<em>len</em>(<em>w</em>)被赋值为3（(<em>v</em>,<em>w</em>)的Dijkstra得分）。我们已经知道哪个顶点会在最后一次迭代中被添加到<em>X</em>（唯一未被处理的顶点<em>t</em>），但仍然需要确定它是因为哪条边而被添加（为了计算<em>len</em>(<em>t</em>)）。由于(<em>v</em>,<em>t</em>)和(<em>w</em>,<em>t</em>)的Dijkstra得分分别是1+6=7和3+3=6，因此<em>len</em>(<em>t</em>)被设置为较小的值6。现在，集合<em>X</em>包含了所有的顶点，不再有任何边从<em>X</em>跨越到<em>V</em>−<em>X</em>，因此算法就宣告结束。<em>len</em>(<em>s</em>)=0，<em>len</em>(<em>v</em>)=1，<em>len</em>(<em>w</em>)=3，<em>len</em>(<em>t</em>)=6这几个值与我们在小测验3.1中所验证的真正最短路径的长度是匹配的。</p><p style=text-align:start>当然，一个算法在一个特定的例子上是正确的并不能就此说明它在所有情况下都是正确的！[6]事实上，Dijkstra算法并不能正确地计算边的长度可能为负时的最短路径长度（如3.3.1节所述）。我们在一开始就应该对Dijkstra算法保持怀疑，要求给出它的证明，至少要证明对于边的长度非负的图，它能够正确地解决单源最短路径问题。</p><h1 class=pgc-h-arrow-right>*3.3　为什么Dijkstra算法是正确的</h1><h1 class=pgc-h-arrow-right>3.3.1　一种虚假的简化</h1><p style=text-align:start>读者可能会觉得奇怪，边的长度是否为负为什么会有影响呢？难道不能把每条边的长度都加上同一个很大的数字，让所有边的长度都为非负吗？</p><p style=text-align:start>这是一个很好的问题，我们总是应该寻求是否能够把待解决的问题简化为已经知道怎样解决的问题。可惜的是，我们不能按照这种方式把通用边长的单源最短路径问题简化为非负边长的特殊情况。问题在于从一个顶点到另一个顶点的不同路径并不一定具有相同数量的边。如果我们把每条边的长度都加上一个数，不同路径所增加的数量可能并不相同，新图的最短路径可能与原图并不相同。图3.3所示的是一个简单的例子。</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f349d049ec44b9cb8d332b0f6a0676e><p class=pgc-img-caption></p></div><p style=text-align:center>图3.3　单源最短路径问题举例</p><p style=text-align:start>从<em>s</em>到<em>t</em>共有两条路径：直接路径（长度为-2）和经过两次跳跃的路径<em>s</em>→<em>v</em>→<em>t</em>（长度为1+(-5)=4）。</p><p style=text-align:start>后者的长度更长（即绝对值更大的负值），因此是最短的<em>s</em>-<em>t</em>路径。</p><p style=text-align:start>为了使这张图具有非负的边长，我们可以把每条边的长度都加上5，结果如图3.4所示。</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed0e60f288a5472b86ecc445f546158b><p class=pgc-img-caption></p></div><p style=text-align:center>图3.4　每条边长度加5后的路径</p><p style=text-align:start>从<em>s</em>到<em>t</em>的最短路径发生了变化，现在是直达的<em>s</em>−<em>t</em>边（长度为3，小于另一条长度为6的路径）。在转换后的图中运行最短路径算法所产生的结果与原图不同。</p><h1 class=pgc-h-arrow-right>3.3.2　Dijkstra算法的一个糟糕例子</h1><p>如果我们在一个某些边的长度为负的图（例如3.3.1节中的图）上运行Dijkstra算法，那么会发生什么情况呢？一开始，<em>X</em>={<em>s</em>}且<em>len</em>(<em>s</em>)=0，此时一切正常。但是，在主循环的第1次迭代中，这个算法计算边(<em>s</em>,<em>v</em>)和(<em>s</em>,<em>t</em>)的Dijkstra得分，其值分别是<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2e46f7ce69e43b0a53572e6026973dd><p class=pgc-img-caption></p></div><p>= 0+1=1和<em>len</em>(<em>s</em>)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76d4155ec0d64ecfbcb3bf2ea1a39448><p class=pgc-img-caption></p></div><p>=0+(−2) = −2。后者的得分更低，因此这个算法把顶点<em>t</em>添加到<em>X</em>中，并把<em>len</em>(<em>t</em>)赋值为−2。我们已经注意到，从<em>s</em>到<em>t</em>的实际最短路径（路径<em>s</em>→<em>v</em>→<em>t</em>）的长度是−4。因此，我们可以得出结论，如果图中某些边的长度为负，Dijkstra就无法计算正确的最短路径长度。</p><h1 class=pgc-h-arrow-right>3.3.3　非负边长时的正确性</h1><p style=text-align:start>算法的正确性证明多少带有一点学究气。对于学生们在直觉上强烈地认为是正确的算法，我常常会略过它们的正确性证明。Dijkstra算法并不是这样。首先，它不适用于边的长度为负的图（即使是非常简单的图，如3.3.1节所述）的情况已经让我们心生疑虑。其次，Dijkstra得分这个概念（见3.1节）看上去有点神秘甚至有点随意，它为什么非常重要呢？由于这些疑虑，并且由于它是一种非常重要的基本算法，因此我们需要花点时间仔细地证明它的正确性（在边的长度非负的图中）。</p><p style=text-align:start><strong>定理3.1（Dijkstra算法的正确性）　</strong>对于每个有向图<em>G </em>= (<em>V</em>, <em>E</em>)、每个起始顶点<em>s</em>并且所有边长均为非负值，对于每个顶点<em>v</em>∈<em>V</em>，Dijkstra算法的结论<em>len</em>(<em>v</em>) = <em>dist</em>(<em>s</em>,<em>v</em>)都成立。</p><h1 class=pgc-h-arrow-right><strong>归纳之旅</strong></h1><p style=text-align:start>我们的计划是根据主循环的迭代数量进行归纳，逐个计算Dijkstra算法的最短路径长度的正确性。记住，根据数学归纳法所进行的证明采用了一个相对刻板的模板，它的目的是建立一个对于每个正整数<em>k</em>都成立的断言<em>P</em>(<em>k</em>)。在定理3.1的证明中，我们把<em>P</em>(<em>k</em>)定义为：“在Dijkstra算法中，对于第<em>k</em>个添加到<em>X</em>中的顶点<em>v</em>，存在<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)。”</p><p style=text-align:start>与递归算法类似，通过数学归纳法所进行的证明分为一个基本条件和一个归纳步骤两个部分。基本条件直接证明了<em>P</em>(1)是正确的。在归纳步骤中，我们假设<em>P</em>(1),…,<em>P</em>(<em>k</em>-1)都是正确的，这称为归纳假设。我们使用这个假设证明<em>P</em>(<em>k</em>)也是正确的。如果基本条件和归纳步骤得到了证明，那么<em>P</em>(<em>k</em>)对于每个正整数<em>k</em>肯定也是正确的。根据基本条件，<em>P</em>(1)是正确的。不断地应用归纳步骤显示了对于任意大的<em>k</em>值，<em>P</em>(<em>k</em>)都是正确的。</p><blockquote><p><strong>关于证明的阅读</strong></p><p>数学论证根据前提条件推导出结论。在阅读证明的时候，总是要保证理解了论证中的每个前提条件的用法，并理解为什么缺少任何一个前提条件就会导致论证失败。</p><p>记住这一点之后，仔细观察定理3.1的证明中两个关键的前提条件所扮演的角色：边的长度是非负的以及算法总是会选择具有最低Dijkstra得分的边。在证明定理3.1时，如果不能支持这两个前提条件，那么证明过程必然是失败的。</p></blockquote><h1 class=pgc-h-arrow-right><strong>定理3.1的证明</strong></h1><p style=text-align:start>我们继续进行归纳，<em>P</em>(<em>k</em>)表示Dijkstra算法可以正确地计算添加到集合<em>X</em>的第<em>k</em>个顶点的最短路径的长度。对于基本条件（<em>k </em>=1），我们知道添加到<em>X</em>的第1个顶点是起始顶点<em>s</em>。Dijkstra算法把0赋值给<em>len</em>(<em>s</em>)。由于每条边都具有非负的长度，因此从<em>s</em>到它本身的最短路径是一条空路径，长度为0。因此，<em>len</em>(<em>s</em>)=0=<em>dist</em>(<em>s</em>,<em>s</em>)，这就证明了<em>P</em>(1)是成立的。</p><p>对于归纳步骤，选择<em>k</em> >1并假设<em>P</em>(1),…,<em>P</em>(<em>k</em>−1)都是正确的，对于Dijkstra算法添加到<em>X</em>的前<em>k</em>−1个顶点，<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)。设<em>w</em>*表示添加到<em>X</em>的第<em>k</em>个顶点，并用(<em>v</em>*,<em>w</em>*)表示在对应的那次迭代中（此时<em>v</em>*必然已经在<em>X</em>中）所选择的边。算法把<em>len</em>(<em>w</em>*)赋值为这条边的Dijkstra得分，即<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p>。我们希望这个值与真正的最短路径长度<em>dist</em>(<em>s</em>,<em>w</em>*)相同，但事实确实如此吗？</p><p style=text-align:start>我们分两个部分论证这个结论的正确性。首先，我们证明真正的长度<em>dist</em>(<em>s</em>,<em>w</em>*)只可能小于算法所推测的<em>len</em>(<em>w</em>*)，即<em>dist</em>(<em>s</em>,<em>w</em>*)≤<em>len</em>(<em>w</em>*)。由于当边(<em>v</em>*,<em>w</em>*)被选中时，<em>v</em>*已经在<em>X</em>中，因此它是添加到<em>X</em>的前<em>k</em>−1个顶点之一。根据归纳假设，Dijkstra算法正确地计算了<em>v</em>*的最短路径长度：<em>len</em>(<em>v</em>*)=<em>dist</em>(<em>s</em>,<em>v</em>*)。</p><p>具体地说，存在一条从<em>s</em>到<em>v</em>*的路径<em>P</em>，它的长度正好是<em>len</em>(<em>v</em>*)。在<em>P</em>的末端添加边(<em>v</em>*,<em>w</em>*)就产生了一条从<em>s</em>到<em>w</em>*的路径<em>P</em>*，它的长度是<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p>=<em>len</em>(<em>w</em>*)（图3.5）。<em>s</em>−<em>w</em>*路径的最短路径除了候选路径<em>P</em>*之外不会再有其他路径，因此<em>dist</em>(<em>s</em>,<em>w</em>*)不可能大于<em>len</em>(<em>w</em>*)。</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23acc03edce746f5844f1a4ad4d1e1ef><p class=pgc-img-caption></p></div><p>图3.5　在<em>s</em>−<em>v</em>*最短路径的末尾添加边(<em>v</em>*, <em>w</em>*)，产生一条<em>s</em>到<em>w</em>*的最短路径<em>P</em>*，其长度为<em>len</em>(<em>v</em>*)+</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/24026d5f4a9449e39fe4b5d07fc0bb50><p class=pgc-img-caption></p></div><p style=text-align:start>现在，我们讨论反方向的不等式<em>dist</em>(<em>s</em>,<em>w</em>*)≥<em>len</em>(<em>w</em>*)（证明这一点之后就可以满足<em>len</em>(<em>w</em>*)=<em>dist</em>(<em>s</em>,<em>w</em>*)）。换而言之，我们希望证明图3.2中的路径<em>P</em>*确实是<em>s</em>−<em>w</em>*的最短路径，每条与之竞争的<em>s</em>−<em>w</em>*路径的长度都不会小于<em>len</em>(<em>w</em>*)。</p><p style=text-align:start>我们随意选择一条<em>s</em>−<em>w</em>*的竞争路径<em>P'</em>。我们对<em>P'</em>所知甚少。但是，我们知道它源于<em>s</em>，终于<em>w</em>*。在迭代之初，<em>s</em>属于集合<em>X</em>但<em>w</em>*不属于<em>X</em>。由于它是从<em>X</em>中开始并在<em>X</em>之外结束，因此路径<em>P'</em>跨越了<em>X</em>和<em>V</em>−<em>X</em>的边界1次（图3.6）。设(<em>y</em>, <em>z</em>)表示跨越边界的<em>P'</em>的第1条边（<em>y</em>∈<em>X</em>且<em>z</em>∉<em>X</em>）。[7]</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e1ffd39f88ec4392b010882e15a3969b><p class=pgc-img-caption></p></div><p style=text-align:center>图3.6　每条<em>s</em>−<em>w</em>*路径从<em>X</em>跨越到<em>V</em>−<em>X</em>至少1次</p><p>为了论证<em>P'</em>的长度不会小于<em>len</em>(<em>w</em>*)，我们独立地考虑它的3个片段：<em>P'</em>从<em>s</em>到<em>y</em>的起始部分、边(<em>y</em>, <em>z</em>)以及从<em>z</em>到<em>w</em>*的最终部分。起始部分不可能短于从<em>s</em>到<em>y</em>的最短路径，因此它的长度至少是<em>dist</em>(<em>s</em>, <em>y</em>)。边(<em>y</em>, <em>z</em>)的长度是</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c768d1c2bf304ce5bae22e05149a9081><p class=pgc-img-caption></p></div><p>。我们对路径的最终部分并不十分了解，它掩藏在算法尚未观察的顶点之中。但是，我们知道所有边的长度都是非负的！也就是说，它的总长度至少是0，如图3.7所示。</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30a89f0066434f46963ef88096ba846e><p class=pgc-img-caption></p></div><p style=text-align:center>图3.7　总长度计算</p><p style=text-align:start>把这3个部分的长度下界相加，可以得出：</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22c91794ffe14171b987b921243f3a0f><p class=pgc-img-caption></p></div><p style=text-align:right>（3.2）</p><p style=text-align:start>最后一个任务是把式（3.2）中的长度下界与指导算法决策的Dijkstra得分进行关联。由于<em>y</em>∈<em>X</em>，因此它是前<em>k</em>−1个添加到<em>X</em>的顶点之一，归纳假设表明了该算法会正确地计算它的最终路径长度：<em>dist</em>(<em>s</em>, <em>y</em>)=<em>len</em>(<em>y</em>)。因此，不等式（3.2）可以转换为</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/321f71a58f6e4fe496b4e1799fdd5e62><p class=pgc-img-caption></p></div><p style=text-align:right>（3.3）</p><p style=text-align:start>式（3.3）的右边正是边(<em>y</em>, <em>z</em>)的Dijkstra得分。由于这个算法总是会选择具有最低Dijkstra得分的边，并且因为它在这次迭代中选择了(<em>v</em>*,<em>w</em>*)而不是(<em>y</em>, <em>z</em>)，所以前者的Dijkstra得分更低：</p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/288078fbf7634c27a9f69b608ae3099f><p class=pgc-img-caption></p></div><p style=text-align:start>这样，我们就完成了归纳步骤的第二部分，并得出结论：对于添加到集合<em>X</em>的每个顶点<em>v</em>，存在<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)。</p><p style=text-align:start>为了进行最终的验证，考虑一个从来没有被添加到<em>X</em>的顶点<em>v</em>。当这个算法结束时，<em>len</em>(<em>v</em>) = +∞并且没有任何边从<em>X</em>跨越到<em>V</em>−<em>X</em>。这意味着输入图中不存在从<em>s</em>到<em>v</em>的路径，因为这样的路径肯定会在某一处跨越边界。因此，<em>dist</em>(<em>s</em>,<em>v</em>)= +∞。我们可以得出结论，对于每个顶点<em>v</em>，如果<em>len</em>(<em>v</em>)=<em>dist</em>(<em>s</em>,<em>v</em>)，算法就会终止，不管<em>v</em>是否被添加到<em>X</em>。至此，我们就完成了整个证明过程。</p><h1 class=pgc-h-arrow-right>3.4　算法的实现及其运行时间</h1><p style=text-align:start>Dijkstra的最短路径算法让我们回想起第2章所讨论的线性时间的图搜索算法。宽度优先和深度优先的搜索算法能够以线性时间运行（定理2.1和定理2.4）的关键原因是它们在决定下一步应该探索哪个顶点时只需要耗费常数级的时间（从队列或堆栈的头部移除一个顶点）。需要警惕的是，Dijkstra算法的每次迭代必须在所有跨越边界的边中选择具有最低Dijkstra得分的边。我们仍然能在线性时间内实现该算法吗？</p><blockquote><p><strong>小测验3.2</strong></p><p>下面哪个运行时间最好地描述了应用于邻接列表表示形式的图的Dijkstra算法的简单实现？与往常一样，<em>n</em>和<em>m</em>分别表示输入图的顶点数和边数。</p><p>（a）<em>O</em>(<em>m</em>+<em>n</em>)</p><p>（b）<em>O</em>(<em>m </em>log <em>n</em>)</p><p>（c）<em>O</em>(<em>n</em>2)</p><p>（d）<em>O</em>(<em>mn</em>)</p><p>（正确答案和详细解释如下。）</p></blockquote><p style=text-align:start><strong>正确答案：（d）。</strong>Dijkstra算法的简单实现通过把一个布尔变量与每个顶点相关联，记录哪些顶点在<em>X</em>中。在每次迭代中，它对所有的边执行一次穷尽式的搜索，计算每条尾顶点在<em>X</em>中且头顶点在<em>X</em>之外的边的Dijkstra得分（每条边需要常数级的时间），并返回具有最低得分值的那条跨越边界的边（或确认不存在跨越边界的边）。在经过最多<em>n </em>−1次迭代之后，Dijkstra算法已经把所有需要添加的新顶点添加到集合<em>X</em>中。由于迭代的数量是<em>O</em>(<em>n</em>)并且每次迭代需要<em>O</em>(<em>m</em>)的时间，因此整体运行时间是<em>O</em>(<em>mn</em>)。</p><p style=text-align:start><strong>命题3.1（Dijkstra的运行时间（简单实现））　</strong>对于有向图<em>G</em>=(<em>V</em>, <em>E</em>)、起始顶点<em>s</em>并且每条边的长度均为非负值，Dijkstra算法的简单实现的运行时间为<em>O</em>(<em>mn</em>)，其中<em>m</em>=|<em>E</em>|、<em>n</em>=|<em>V </em>|。</p><p style=text-align:start>这种简单实现的运行时间还不错，但不够优秀。如果顶点的数量只有几百个或者一两千个，它的效率还算不错。但是，对于那些极为庞大的图，这种实现的效率就不能尽如人意。我们能不能做得更好？算法设计的至高荣誉就是实现线性时间的算法（或近似于它），我们希望单源最短路径问题也能够实现这样的目标。这样的算法在一台家用笔记本计算机上就可以处理具有数百万个顶点的图。</p><p style=text-align:start>我们并不需要一种更好的算法实现该问题近似线性时间的解决方案，而是只需要Dijkstra算法的一种更好实现。在宽度优先和深度优先的搜索的线性时间实现中，数据结构（队列和堆栈）扮演了一个关键的角色。类似地，Dijkstra算法也可以在正确的数据结构的帮助下，在它的主循环中实现反复的最小值计算，从而实现近似线性的运行时间。这种数据结构称为堆，它是第4章的主题。</p><h1 class=pgc-h-arrow-right>3.5　本章要点</h1><ul><li>在单源最短路径问题中，问题的输入由一个图、一个起始顶点和每条边的长度所组成。它的目标是计算从起始顶点到其他每个顶点的最短路径的长度。</li><li>Dijkstra算法逐个处理顶点，总是在尚未处理的顶点中选择看上去最靠近起始顶点的那个顶点。</li><li>通过数学归纳法可以证明Dijkstra算法能够正确地解决当输入图的边长都为非负值时的单源最短路径问题。</li><li>当输入图中有些边的长度为负值时，Dijkstra算法就无法正确地解决单源最短路径问题。</li><li>Dijkstra算法的简单实现的运行时间是<em>O</em>(<em>mn</em>)，其中<em>m</em>和<em>n</em>分别表示输入图的边数和顶点数。</li></ul><p><strong>本文摘自《算法详解 卷2 图算法和数据结构(异步图书出品)》</strong></p><div class=pgc-img><img alt=计算机科学史上伟大的成就之一：Dijkstra最短路径算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8791714a92cb4ed3bebf16a9882cbbbe><p class=pgc-img-caption></p></div><p>本书将帮助读者熟悉几种不同的数据结构，它们用于维护不断变化的具有键的对象集合。我们的基本目标是培养一种能力，也就是能够判断哪种数据结构比较适合自己的应用。选读的高级章节对如何从头实现这些数据结构提供了一些指导方针。</p><p style=text-align:start>我们首先讨论堆，它可以快速识别它所存储对象中具有最小键值的对象，适用于排序、实现优先队列以及以线性时间实现Dijkstra算法。搜索树可以维护它所存储对象的整体键顺序，并支持更丰富的数组操作。散列表对超级快速的查找方式进行了优化，在现代程序中具有极其广泛的应用。我们还将讨论布隆过滤器，它是散列表的“近亲”。布隆过滤器的空间需求较散列表更低，但它偶尔会出现错误。</p><p style=text-align:start>关于本书内容的更详细介绍，可以阅读每章的“本章要点”，它对每一章的内容，特别是那些重要的概念进行了总结。书中带星号的章节是难度较高的章节。时间较为紧张的读者在第一遍阅读时可以跳过这些章节，这并不会影响本书阅读的连续性。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'计算机','科学史','上伟大'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>