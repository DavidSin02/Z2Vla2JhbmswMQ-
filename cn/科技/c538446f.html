<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试必备：HashMap源码解析 | 极客快訊</title><meta property="og:title" content="面试必备：HashMap源码解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c538446f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c538446f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c538446f.html><meta property="article:published_time" content="2020-10-29T21:09:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:20+08:00"><meta name=Keywords content><meta name=description content="面试必备：HashMap源码解析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c538446f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试必备：HashMap源码解析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><pre><code>认真写文章，用心做分享。公众号：Java耕耘者</code></pre><p>整个HashMap示意图：</p><div class=pgc-img><img alt=面试必备：HashMap源码解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e><p class=pgc-img-caption></p></div><p>HashMap的源码中，充斥个各种位运算代替常规运算的地方，以提升效率：</p><ul><li>与运算替代模运算。用 hash & (table.length-1) 替代 hash % (table.length)</li><li>用if ((e.hash & oldCap) == 0)判断扩容后，节点e处于低区还是高区。</li></ul><h2 class=pgc-h-arrow-right>3 链表节点Node</h2><p>在开始之前，我们先看一下挂载在哈希表上的元素，链表的结构：</p><pre><code>    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;//哈希值        final K key;//key        V value;//value        Node&lt;K,V&gt; next;//链表后置节点        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        }        public final K getKey()        { return key; }        public final V getValue()      { return value; }        public final String toString() { return key + "=" + value; }        //每一个节点的hash值，是将key的hashCode 和 value的hashCode 亦或得到的。        public final int hashCode() {            return Objects.hashCode(key) ^ Objects.hashCode(value);        }        //设置新的value 同时返回旧value        public final V setValue(V newValue) {            V oldValue = value;            value = newValue;            return oldValue;        }        public final boolean equals(Object o) {            if (o == this)                return true;            if (o instanceof Map.Entry) {                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;                if (Objects.equals(key, e.getKey()) &amp;&amp;                    Objects.equals(value, e.getValue()))                    return true;            }            return false;        }    }</code></pre><p><strong>由此可知，这是一个单链表~。<br>每一个节点的hash值，是将key的hashCode 和 value的hashCode 亦或得到的。</strong></p><h2 class=pgc-h-arrow-right>4 构造函数</h2><pre><code>    //最大容量 2的30次方    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;    //默认的加载因子    static final float DEFAULT_LOAD_FACTOR = 0.75f;    //哈希桶，存放链表。 长度是2的N次方，或者初始化时为0.    transient Node&lt;K,V&gt;[] table;    //加载因子，用于计算哈希表元素数量的阈值。  threshold = 哈希桶.length * loadFactor;    final float loadFactor;    //哈希表内元素数量的阈值，当哈希表内元素数量超过阈值时，会发生扩容resize()。    int threshold;    public HashMap() {        //默认构造函数，赋值加载因子为默认的0.75f        this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted    }    public HashMap(int initialCapacity) {        //指定初始化容量的构造函数        this(initialCapacity, DEFAULT_LOAD_FACTOR);    }    //同时指定初始化容量 以及 加载因子， 用的很少，一般不会修改loadFactor    public HashMap(int initialCapacity, float loadFactor) {        //边界处理        if (initialCapacity &lt; 0)            throw new IllegalArgumentException("Illegal initial capacity: " +                                               initialCapacity);        //初始容量最大不能超过2的30次方        if (initialCapacity &gt; MAXIMUM_CAPACITY)            initialCapacity = MAXIMUM_CAPACITY;        //显然加载因子不能为负数        if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))            throw new IllegalArgumentException("Illegal load factor: " +                                               loadFactor);        this.loadFactor = loadFactor;        //设置阈值为  》=初始化容量的 2的n次方的值        this.threshold = tableSizeFor(initialCapacity);    }    //新建一个哈希表，同时将另一个map m 里的所有元素加入表中    public HashMap(Map&lt;? extends K, ? extends V&gt; m) {        this.loadFactor = DEFAULT_LOAD_FACTOR;        putMapEntries(m, false);    }</code></pre><pre><code>    //根据期望容量cap，返回2的n次方形式的 哈希桶的实际容量 length。 返回值一般会&gt;=cap     static final int tableSizeFor(int cap) {    //经过下面的 或 和位移 运算， n最终各位都是1。        int n = cap - 1;        n |= n &gt;&gt;&gt; 1;        n |= n &gt;&gt;&gt; 2;        n |= n &gt;&gt;&gt; 4;        n |= n &gt;&gt;&gt; 8;        n |= n &gt;&gt;&gt; 16;        //判断n是否越界，返回 2的n次方作为 table（哈希桶）的阈值        return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;    }</code></pre><pre><code>    //将另一个Map的所有元素加入表中，参数evict初始化时为false，其他情况为true    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {        //拿到m的元素数量        int s = m.size();        //如果数量大于0        if (s &gt; 0) {            //如果当前表是空的            if (table == null) { // pre-size                //根据m的元素数量和当前表的加载因子，计算出阈值                float ft = ((float)s / loadFactor) + 1.0F;                //修正阈值的边界 不能超过MAXIMUM_CAPACITY                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                //如果新的阈值大于当前阈值                if (t &gt; threshold)                    //返回一个 》=新的阈值的 满足2的n次方的阈值                    threshold = tableSizeFor(t);            }            //如果当前元素表不是空的，但是 m的元素数量大于阈值，说明一定要扩容。            else if (s &gt; threshold)                resize();            //遍历 m 依次将元素加入当前表中。            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            }        }    }</code></pre><div class=pgc-img><img alt=面试必备：HashMap源码解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/071243af-fdce-413e-bf2e-c572a9263352><p class=pgc-img-caption></p></div><pre><code>    //将另一个Map的所有元素加入表中，参数evict初始化时为false，其他情况为true    final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {        //拿到m的元素数量        int s = m.size();        //如果数量大于0        if (s &gt; 0) {            //如果当前表是空的            if (table == null) { // pre-size                //根据m的元素数量和当前表的加载因子，计算出阈值                float ft = ((float)s / loadFactor) + 1.0F;                //修正阈值的边界 不能超过MAXIMUM_CAPACITY                int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?                         (int)ft : MAXIMUM_CAPACITY);                //如果新的阈值大于当前阈值                if (t &gt; threshold)                    //返回一个 》=新的阈值的 满足2的n次方的阈值                    threshold = tableSizeFor(t);            }            //如果当前元素表不是空的，但是 m的元素数量大于阈值，说明一定要扩容。            else if (s &gt; threshold)                resize();            //遍历 m 依次将元素加入当前表中。            for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {                K key = e.getKey();                V value = e.getValue();                putVal(hash(key), key, value, false, evict);            }        }    }</code></pre><p>先看一下扩容函数： 这是一个重点！重点！重点！<br><strong>初始化或加倍哈希桶大小。如果是当前哈希桶是null,分配符合当前阈值的初始容量目标。<br>否则，因为我们扩容成以前的两倍。<br>在扩容时，要注意区分以前在哈希桶相同index的节点，现在是在以前的index里，还是index+oldlength 里</strong></p><pre><code>final Node&lt;K,V&gt;[] resize() {        //oldTab 为当前表的哈希桶        Node&lt;K,V&gt;[] oldTab = table;        //当前哈希桶的容量 length        int oldCap = (oldTab == null) ? 0 : oldTab.length;        //当前的阈值        int oldThr = threshold;        //初始化新的容量和阈值为0        int newCap, newThr = 0;        //如果当前容量大于0        if (oldCap &gt; 0) {            //如果当前容量已经到达上限            if (oldCap &gt;= MAXIMUM_CAPACITY) {                //则设置阈值是2的31次方-1                threshold = Integer.MAX_VALUE;                //同时返回当前的哈希桶，不再扩容                return oldTab;            }//否则新的容量为旧的容量的两倍。             else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)//如果旧的容量大于等于默认初始容量16                //那么新的阈值也等于旧的阈值的两倍                newThr = oldThr &lt;&lt; 1; // double threshold        }//如果当前表是空的，但是有阈值。代表是初始化时指定了容量、阈值的情况        else if (oldThr &gt; 0) // initial capacity was placed in threshold            newCap = oldThr;//那么新表的容量就等于旧的阈值        else {}//如果当前表是空的，而且也没有阈值。代表是初始化时没有任何容量/阈值参数的情况               // zero initial threshold signifies using defaults            newCap = DEFAULT_INITIAL_CAPACITY;//此时新表的容量为默认的容量 16            newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//新的阈值为默认容量16 * 默认加载因子0.75f = 12        }        if (newThr == 0) {//如果新的阈值是0，对应的是  当前表是空的，但是有阈值的情况            float ft = (float)newCap * loadFactor;//根据新表容量 和 加载因子 求出新的阈值            //进行越界修复            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                      (int)ft : Integer.MAX_VALUE);        }        //更新阈值         threshold = newThr;        @SuppressWarnings({"rawtypes","unchecked"})        //根据新的容量 构建新的哈希桶            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];        //更新哈希桶引用        table = newTab;        //如果以前的哈希桶中有元素        //下面开始将当前哈希桶中的所有节点转移到新的哈希桶中        if (oldTab != null) {            //遍历老的哈希桶            for (int j = 0; j &lt; oldCap; ++j) {                //取出当前的节点 e                Node&lt;K,V&gt; e;                //如果当前桶中有元素,则将链表赋值给e                if ((e = oldTab[j]) != null) {                    //将原哈希桶置空以便GC                    oldTab[j] = null;                    //如果当前链表中就一个元素，（没有发生哈希碰撞）                    if (e.next == null)                        //直接将这个元素放置在新的哈希桶里。                        //注意这里取下标 是用 哈希值 与 桶的长度-1 。 由于桶的长度是2的n次方，这么做其实是等于 一个模运算。但是效率更高                        newTab[e.hash &amp; (newCap - 1)] = e;                        //如果发生过哈希碰撞 ,而且是节点数超过8个，转化成了红黑树（暂且不谈 避免过于复杂， 后续专门研究一下红黑树）                    else if (e instanceof TreeNode)                        ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                    //如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。                    else { // preserve order                        //因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位=  low位+原哈希桶容量                        //低位链表的头结点、尾节点                        Node&lt;K,V&gt; loHead = null, loTail = null;                        //高位链表的头节点、尾节点                        Node&lt;K,V&gt; hiHead = null, hiTail = null;                        Node&lt;K,V&gt; next;//临时节点 存放e的下一个节点                        do {                            next = e.next;                            //这里又是一个利用位运算 代替常规运算的高效点： 利用哈希值 与 旧的容量，可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，应该存放在低位，否则存放在高位                            if ((e.hash &amp; oldCap) == 0) {                                //给头尾节点指针赋值                                if (loTail == null)                                    loHead = e;                                else                                    loTail.next = e;                                loTail = e;                            }//高位也是相同的逻辑                            else {                                if (hiTail == null)                                    hiHead = e;                                else                                    hiTail.next = e;                                hiTail = e;                            }//循环直到链表结束                        } while ((e = next) != null);                        //将低位链表存放在原index处，                        if (loTail != null) {                            loTail.next = null;                            newTab[j] = loHead;                        }                        //将高位链表存放在新index处                        if (hiTail != null) {                            hiTail.next = null;                            newTab[j + oldCap] = hiHead;                        }                    }                }            }        }        return newTab;    }</code></pre><p>再看一下 往哈希表里插入一个节点的putVal函数,如果参数onlyIfAbsent是true，那么不会覆盖相同key的值value。如果evict是false。那么表示是在初始化时调用的</p><pre><code>    final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {        //tab存放 当前的哈希桶， p用作临时链表节点          Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        //如果当前哈希表是空的，代表是初始化        if ((tab = table) == null || (n = tab.length) == 0)            //那么直接去扩容哈希表，并且将扩容后的哈希桶长度赋值给n            n = (tab = resize()).length;        //如果当前index的节点是空的，表示没有发生哈希碰撞。 直接构建一个新节点Node，挂载在index处即可。        //这里再啰嗦一下，index 是利用 哈希值 &amp; 哈希桶的长度-1，替代模运算        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else {//否则 发生了哈希冲突。            //e            Node&lt;K,V&gt; e; K k;            //如果哈希值相等，key也相等，则是覆盖value操作            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;//将当前节点引用赋值给e            else if (p instanceof TreeNode)//红黑树暂且不谈                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else {//不是覆盖操作，则插入一个普通链表节点                //遍历链表                for (int binCount = 0; ; ++binCount) {                    if ((e = p.next) == null) {//遍历到尾部，追加新节点到尾部                        p.next = newNode(hash, key, value, null);                        //如果追加节点后，链表数量》=8，则转化为红黑树                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    }                    //如果找到了要覆盖的节点                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                }            }            //如果e不是null，说明有需要覆盖的节点，            if (e != null) { // existing mapping for key                //则覆盖节点值，并返回原oldValue                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                //这是一个空实现的函数，用作LinkedHashMap重写使用。                afterNodeAccess(e);                return oldValue;            }        }        //如果执行到了这里，说明插入了一个新的节点，所以会修改modCount，以及返回null。        //修改modCount        ++modCount;        //更新size，并判断是否需要扩容。        if (++size &gt; threshold)            resize();        //这是一个空实现的函数，用作LinkedHashMap重写使用。        afterNodeInsertion(evict);        return null;    }</code></pre><p>newNode如下：构建一个链表节点</p><pre><code>    // Create a regular (non-tree) node    Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) {        return new Node&lt;&gt;(hash, key, value, next);    }</code></pre><pre><code>    // Callbacks to allow LinkedHashMap post-actions    void afterNodeAccess(Node&lt;K,V&gt; p) { }    void afterNodeInsertion(boolean evict) { }</code></pre><p>小结：</p><ul><li>运算尽量都用<strong>位运算</strong>代替<strong>，更高效</strong>。</li><li>对于<strong>扩容</strong>导致需要新建数组存放更多元素时，除了要将老数组中的元素迁移过来，也记得将<strong>老数组中的引用置null</strong>，以便<strong>GC</strong></li><li>取下标 是用 <strong>哈希值 与运算 （桶的长度-1）</strong> i = (n - 1) & hash。 由于桶的长度是2的n次方，这么做其实是等于 一个<strong>模运算</strong>。但是<strong>效率更高</strong></li><li>扩容时，如果发生过哈希碰撞，节点数小于8个。则要根据链表上每个节点的哈希值，依次放入新哈希桶对应下标位置。</li><li>因为扩容是容量翻倍，所以原链表上的每个节点，现在可能存放在原来的下标，即low位， 或者扩容后的下标，即high位。 high位= low位+原哈希桶容量</li><li>利用<strong>哈希值 与运算 旧的容量</strong> ，if ((e.hash & oldCap) == 0),可以得到哈希值去模后，是大于等于oldCap还是小于oldCap，等于0代表小于oldCap，<strong>应该存放在低位，否则存放在高位</strong>。这里又是一个利用位运算 代替常规运算的高效点</li><li>如果追加节点后，链表数量》=8，则转化为红黑树</li><li>插入节点操作时，有一些空实现的函数，用作LinkedHashMap重写使用。</li></ul><div class=pgc-img><img alt=面试必备：HashMap源码解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/e4da6289-875b-4f33-92d6-c5449e91eadb><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>5 增、改</h2><h3 class=pgc-h-arrow-right>1往表中插入或覆盖一个key-value</h3><pre><code>    public V put(K key, V value) {        //先根据key，取得hash值。 再调用上一节的方法插入节点        return putVal(hash(key), key, value, false, true);    }</code></pre><p>这个根据key取hash值的函数也要关注一下，它称之为“扰动函数”，关于这个函数的用处 开头已经总结过了：</p><pre><code>    static final int hash(Object key) {        int h;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);    }</code></pre><p>而key的hash值，并不仅仅只是key对象的hashCode()方法的返回值，还会经过<strong>扰动函数</strong>的扰动，以使hash值更加均衡。<br>因为hashCode()是int类型，取值范围是40多亿，只要哈希函数映射的比较均匀松散，碰撞机率是很小的。<br>但就算原本的hashCode()取得很好，每个key的hashCode()不同，但是由于HashMap的哈希桶的长度远比hash取值范围小，默认是16，所以当对hash值以桶的长度取余，以找到存放该key的桶的下标时，由于取余是通过与操作完成的，会忽略hash值的高位。因此只有hashCode()的低位参加运算，发生不同的hash值，但是得到的index相同的情况的机率会大大增加，这种情况称之为<strong>hash碰撞。</strong> 即，碰撞率会增大。</p><p><strong>扰动函数</strong>就是为了解决hash碰撞的。它会综合hash值高位和低位的特征，并存放在低位，因此在与运算时，相当于高低位一起参与了运算，以减少hash碰撞的概率。（在JDK8之前，扰动函数会扰动四次，JDK8简化了这个操作）</p><h3 class=pgc-h-arrow-right>2往表中批量增加数据</h3><pre><code>    public void putAll(Map&lt;? extends K, ? extends V&gt; m) {        //这个函数上一节也已经分析过。//将另一个Map的所有元素加入表中，参数evict初始化时为false，其他情况为true        putMapEntries(m, true);    }</code></pre><h3 class=pgc-h-arrow-right>3 只会往表中插入 key-value, 若key对应的value之前存在，不会覆盖。（jdk8增加的方法）</h3><pre><code>    @Override    public V putIfAbsent(K key, V value) {        return putVal(hash(key), key, value, true, true);    }</code></pre><h2 class=pgc-h-arrow-right>6 删</h2><h3 class=pgc-h-arrow-right>以key为条件删除</h3><p>如果key对应的value存在，则删除这个键值对。 并返回value。如果不存在 返回null。</p><pre><code>    public V remove(Object key) {        Node&lt;K,V&gt; e;        return (e = removeNode(hash(key), key, null, false, true)) == null ?            null : e.value;    }</code></pre><p>//从哈希表中删除某个节点， 如果参数matchValue是true，则必须key 、value都相等才删除。<br>//如果movable参数是false，在删除节点时，不移动其他节点</p><pre><code>    final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                               boolean matchValue, boolean movable) {        // p 是待删除节点的前置节点        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;        //如果哈希表不为空，则根据hash值算出的index下 有节点的话。        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (p = tab[index = (n - 1) &amp; hash]) != null) {            //node是待删除节点            Node&lt;K,V&gt; node = null, e; K k; V v;            //如果链表头的就是需要删除的节点            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                node = p;//将待删除节点引用赋给node            else if ((e = p.next) != null) {//否则循环遍历 找到待删除节点，赋值给node                if (p instanceof TreeNode)                    node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);                else {                    do {                        if (e.hash == hash &amp;&amp;                            ((k = e.key) == key ||                             (key != null &amp;&amp; key.equals(k)))) {                            node = e;                            break;                        }                        p = e;                    } while ((e = e.next) != null);                }            }            //如果有待删除节点node，  且 matchValue为false，或者值也相等            if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                                 (value != null &amp;&amp; value.equals(v)))) {                if (node instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);                else if (node == p)//如果node ==  p，说明是链表头是待删除节点                    tab[index] = node.next;                else//否则待删除节点在表中间                    p.next = node.next;                ++modCount;//修改modCount                --size;//修改size                afterNodeRemoval(node);//LinkedHashMap回调函数                return node;            }        }        return null;    }</code></pre><pre><code>    void afterNodeRemoval(Node&lt;K,V&gt; p) { }复制代码</code></pre><h3 class=pgc-h-arrow-right>以key value 为条件删除</h3><pre><code>    @Override    public boolean remove(Object key, Object value) {        //这里传入了value 同时matchValue为true        return removeNode(hash(key), key, value, true, true) != null;    }</code></pre><h2 class=pgc-h-arrow-right>7 查</h2><h3 class=pgc-h-arrow-right>以key为条件，找到返回value。没找到返回null</h3><pre><code>    public V get(Object key) {        Node&lt;K,V&gt; e;        //传入扰动后的哈希值 和 key 找到目标节点Node        return (e = getNode(hash(key), key)) == null ? null : e.value;    }</code></pre><pre><code>    //传入扰动后的哈希值 和 key 找到目标节点Node    final Node&lt;K,V&gt; getNode(int hash, Object key) {        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;        //查找过程和删除基本差不多， 找到返回节点，否则返回null        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;            (first = tab[(n - 1) &amp; hash]) != null) {            if (first.hash == hash &amp;&amp; // always check first node                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))                return first;            if ((e = first.next) != null) {                if (first instanceof TreeNode)                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);                do {                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        return e;                } while ((e = e.next) != null);            }        }        return null;    }</code></pre><h3 class=pgc-h-arrow-right>判断是否包含该key</h3><pre><code>    public boolean containsKey(Object key) {        return getNode(hash(key), key) != null;    }</code></pre><h3 class=pgc-h-arrow-right>判断是否包含value</h3><pre><code>    public boolean containsValue(Object value) {        Node&lt;K,V&gt;[] tab; V v;        //遍历哈希桶上的每一个链表        if ((tab = table) != null &amp;&amp; size &gt; 0) {            for (int i = 0; i &lt; tab.length; ++i) {                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next) {                    //如果找到value一致的返回true                    if ((v = e.value) == value ||                        (value != null &amp;&amp; value.equals(v)))                        return true;                }            }        }        return false;    }</code></pre><h3 class=pgc-h-arrow-right>java8新增，带默认值的get方法</h3><p>以key为条件，找到了返回value。否则返回defaultValue</p><pre><code>    @Override    public V getOrDefault(Object key, V defaultValue) {        Node&lt;K,V&gt; e;        return (e = getNode(hash(key), key)) == null ? defaultValue : e.value;    }</code></pre><h3 class=pgc-h-arrow-right>遍历</h3><pre><code>    //缓存 entrySet    transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;     */    public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {        Set&lt;Map.Entry&lt;K,V&gt;&gt; es;        return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;    }</code></pre><pre><code>    final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {        public final int size()                 { return size; }        public final void clear()               { HashMap.this.clear(); }        //一般我们用到EntrySet，都是为了获取iterator        public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {            return new EntryIterator();        }        //最终还是调用getNode方法        public final boolean contains(Object o) {            if (!(o instanceof Map.Entry))                return false;            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;            Object key = e.getKey();            Node&lt;K,V&gt; candidate = getNode(hash(key), key);            return candidate != null &amp;&amp; candidate.equals(e);        }        //最终还是调用removeNode方法        public final boolean remove(Object o) {            if (o instanceof Map.Entry) {                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;                Object key = e.getKey();                Object value = e.getValue();                return removeNode(hash(key), key, value, true, true) != null;            }            return false;        }        //。。。    }</code></pre><p>//EntryIterator的实现：</p><pre><code>    final class EntryIterator extends HashIterator        implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {        public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }    }</code></pre><pre><code>    abstract class HashIterator {        Node&lt;K,V&gt; next;        // next entry to return        Node&lt;K,V&gt; current;     // current entry        int expectedModCount;  // for fast-fail        int index;             // current slot        HashIterator() {            //因为hashmap也是线程不安全的，所以要保存modCount。用于fail-fast策略            expectedModCount = modCount;            Node&lt;K,V&gt;[] t = table;            current = next = null;            index = 0;            //next 初始时，指向 哈希桶上第一个不为null的链表头            if (t != null &amp;&amp; size &gt; 0) { // advance to first entry                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);            }        }        public final boolean hasNext() {            return next != null;        }        //由这个方法可以看出，遍历HashMap时，顺序是按照哈希桶从低到高，链表从前往后，依次遍历的。属于无序集合。        final Node&lt;K,V&gt; nextNode() {            Node&lt;K,V&gt;[] t;            Node&lt;K,V&gt; e = next;            //fail-fast策略            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            if (e == null)                throw new NoSuchElementException();            //依次取链表下一个节点，            if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {                //如果当前链表节点遍历完了，则取哈希桶下一个不为null的链表头                do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);            }            return e;        }        public final void remove() {            Node&lt;K,V&gt; p = current;            if (p == null)                throw new IllegalStateException();            ////fail-fast策略            if (modCount != expectedModCount)                throw new ConcurrentModificationException();            current = null;            K key = p.key;            //最终还是利用removeNode 删除节点            removeNode(hash(key), key, null, false, false);            expectedModCount = modCount;        }    }</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','必备','HashMap'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>