<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>同步请求和异步请求 | 极客快訊</title><meta property="og:title" content="同步请求和异步请求 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/37b36c91e46045098266d0264cb7f6e8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c6fa5bc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c6fa5bc.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="同步请求和异步请求"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c6fa5bc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>同步请求和异步请求</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=postTitle>同步请求和异步请求的区别</h1><ul><li>同步是指：发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。</li></ul><ul><li>异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。</li></ul><p>即同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。</p><p>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p><p>异步的概念和同步相对。当一个同步调用发出后，调用者要一直等待返回消息（结果）通知后，才能进行后续的执行；当一个异步过程调用发出后，调用者不能立刻得到返回消息（结果）。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><p>针对以上描述，实际工程编程中，具体我们如何根据场景选择和使用同步和异步：</p><p>异步的使用场景：</p><ul><li>不涉及共享资源，或对共享资源只读，即非互斥操作</li><li>没有时序上的严格关系</li><li>不需要原子操作，或可以通过其他方式控制原子性</li><li>常用于IO操作等耗时操作，因为比较影响客户体验和使用性能</li><li>不影响主线程逻辑</li></ul><p>同步的使用场景：不使用异步的时候</p><p>同步的好处：</p><ul><li>同步流程对结果处理通常更为简单，可以就近处理。</li><li>同步流程对结果的处理始终和前文保持在一个上下文内。</li><li>同步流程可以很容易捕获、处理异常。</li><li>同步流程是最天然的控制过程顺序执行的方式。</li></ul><p>异步的好处：</p><ul><li>异步流程可以立即给调用方返回初步的结果。</li><li>异步流程可以延迟给调用方最终的结果数据，在此期间可以做更多额外的工作，例如结果记录等等。</li><li>异步流程在执行的过程中，可以释放占用的线程等资源，避免阻塞，等到结果产生再重新获取线程处理。</li><li>异步流程可以等多次调用的结果出来后，再统一返回一次结果集合，提高响应效率。</li></ul><p>接下来基于http请求分别实现同步和异步获取天气信息的编程：</p><p>贴出来一个http请求格式，代码需要按照这个格式拼接相关的字符串。</p><div class=pgc-img><img alt=同步请求和异步请求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37b36c91e46045098266d0264cb7f6e8><p class=pgc-img-caption></p></div><p>一个获取天气信息的网站API说明：https://docs.seniverse.com/api/weather/now.html</p><div class=pgc-img><img alt=同步请求和异步请求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3266c0f2fa0246c4a80e57d3b2ca2ab7><p class=pgc-img-caption></p></div><p>http请求sync的代码实现：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/time.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;		/* close */#include &lt;netdb.h&gt; #include &lt;sys/epoll.h&gt;#define HTTP_VERSION    "HTTP/1.1"#define USER_AGENT		"User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2\r\n"#define ENCODE_TYPE		"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"//设置连接类型，由于是短连接，不需要设置为keep-alive#define CONNECTION_TYPE "Connection: close\r\n"#define BUFFER_SIZE		4096struct http_request {	char *hostname;	char *resource;};struct http_request reqs[] = {	{"api.seniverse.com", "/v3/weather/now.json?key=0pyd8z7jouficcil&amp;location=beijing&amp;language=zh-Hans&amp;unit=c" },	{"api.seniverse.com", "/v3/weather/now.json?key=0pyd8z7jouficcil&amp;location=shenzhen&amp;language=zh-Hans&amp;unit=c" },};char *host_to_ip(const char *hostname) {	struct hostent *host_entry = gethostbyname(hostname);  /*******************************************************************************************************  由于gethostbyname这个函数不可重入，并不适用于多线程环境以及其它对DNS解析速度要求较高的程序  后来又增加一个函数gethostbyname_r，解决gethostbyname的问题，但是又由于该函数对ipv6的支持不好，  最后目前推荐使用getaddrinfo  *********************************************************************************************************/  if (host_entry) {		return inet_ntoa(*(struct in_addr*)*host_entry-&gt;h_addr_list);	} else {		return NULL;	}}int http_create_socket( char *ip) {	int sockfd = socket(AF_INET, SOCK_STREAM, 0);	struct sockaddr_in sin = {0};	sin.sin_addr.s_addr = inet_addr(ip);	sin.sin_port = htons(80);	sin.sin_family = AF_INET;	if (-1 == connect(sockfd, (struct sockaddr*)&amp;sin, sizeof(struct sockaddr_in))) {		return -1;	}	fcntl(sockfd, F_SETFL, O_NONBLOCK);	return sockfd;}char *http_send_request(int sockfd, const char *hostname, const char *resource) {	char buffer[BUFFER_SIZE] = {0};		int len = sprintf(buffer, "GET %s %s\r\n\Host: %s\r\n\%s\r\n\\r\n",		 resource, HTTP_VERSION,		 hostname,		 CONNECTION_TYPE		 );//拼接http请求	send(sockfd, buffer, strlen(buffer), 0);	struct timeval tv;	tv.tv_sec = 5;	tv.tv_usec = 0;	fd_set fdread;	FD_ZERO(&amp;fdread);	FD_SET(sockfd, &amp;fdread);	char *result = malloc(sizeof(int));	result[0] = '\0';	while (1) {		int selection = select(sockfd+1, &amp;fdread, NULL, NULL, &amp;tv);		if (!selection || !(FD_ISSET(sockfd, &amp;fdread))) {			break;		} else {			len = recv(sockfd, buffer, BUFFER_SIZE, 0);			if (len == 0) break;			result = realloc(result, (strlen(result) + len + 1) * sizeof(char));			strncat(result, buffer, len);		}	}	return result;}int http_sync_client_commit(const char *hostname, const char *resource) {	char *ip = host_to_ip(hostname);//根据域名获取IP地址	int sockfd = http_create_socket(ip);//创建socket，并使用select监听查询fd	char *content =  http_send_request(sockfd, hostname, resource);//发送请求	if (content == NULL) {		printf("have no data\n");	}	puts(content);	close(sockfd);	free(content);}int main(int argc, char *argv[]) {	int count = sizeof(reqs) / sizeof(reqs[0]);	int i = 0;	for (i = 0;i &lt; count;i ++) {		http_client_commit(reqs[i].hostname, reqs[i].resource);	}</code></pre><p>运行结果：</p><p><br></p><div class=pgc-img><img alt=同步请求和异步请求 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2e77b43d06ec4505abf702d85bc9296b><p class=pgc-img-caption></p></div><p>http请求async的代码实现：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;time.h&gt;#include &lt;fcntl.h&gt;#include &lt;errno.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt;#include &lt;sys/time.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;		/* close */#include &lt;netdb.h&gt; #include &lt;sys/epoll.h&gt;#define HTTP_VERSION    "HTTP/1.1"#define USER_AGENT		"User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2\r\n"#define ENCODE_TYPE		"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n"#define CONNECTION_TYPE "Connection: close\r\n"#define BUFFER_SIZE		4096#define ASYNC_CLIENT_NUM		1024#define HOSTNAME_LENGTH			128typedef void (*async_result_cb)(const char *hostname, const char *result);struct ep_arg {	int sockfd;	char hostname[HOSTNAME_LENGTH];	async_result_cb cb;};struct async_context {	int epfd;	pthread_t thread_id;};struct http_request {	char *hostname;	char *resource;};struct http_request reqs[] = {	{"api.seniverse.com", "/v3/weather/now.json?key=0pyd8z7jouficcil&amp;location=beijing&amp;language=zh-Hans&amp;unit=c" },	{"api.seniverse.com", "/v3/weather/now.json?key=0pyd8z7jouficcil&amp;location=shenzhen&amp;language=zh-Hans&amp;unit=c" },};char *host_to_ip(const char *hostname) {	struct hostent *host_entry = gethostbyname(hostname);	if (host_entry) {		return inet_ntoa(*(struct in_addr*)*host_entry-&gt;h_addr_list);	} else {		return NULL;	}}int http_async_client_commit(struct async_context *ctx, const char *hostname, const char *resource, async_result_cb cb) {	char *ip = host_to_ip(hostname);	if (ip == NULL) return -1;		int sockfd = socket(AF_INET, SOCK_STREAM, 0);	struct sockaddr_in sin = {0};	sin.sin_addr.s_addr = inet_addr(ip);	sin.sin_port = htons(80);	sin.sin_family = AF_INET;	if (-1 == connect(sockfd, (struct sockaddr*)&amp;sin, sizeof(struct sockaddr_in))) {		return -1;	}	fcntl(sockfd, F_SETFL, O_NONBLOCK);	char buffer[BUFFER_SIZE] = {0};		int len = sprintf(buffer, "GET %s %s\r\n\Host: %s\r\n\%s\r\n\\r\n",		 resource, HTTP_VERSION,		 hostname,		 CONNECTION_TYPE		 );//拼接http请求	int slen = send(sockfd, buffer, strlen(buffer), 0);//发送请求		struct ep_arg *eparg = (struct ep_arg*)calloc(1, sizeof(struct ep_arg));//创建一个结构体，把fd和回调函数放进去，方便epoll返回的时候，就可以取到对应fd和回调函数，用于客户端同一个线程处理数据	if (eparg == NULL) return -1;	eparg-&gt;sockfd = sockfd;	eparg-&gt;cb = cb;	struct epoll_event ev;	ev.data.ptr = eparg;//传递参数给epoll	ev.events = EPOLLIN;	int ret = epoll_ctl(ctx-&gt;epfd, EPOLL_CTL_ADD, sockfd, &amp;ev); //把http请求的fd加入到epoll的事件注册函数	return ret;}int http_async_client_uninit(struct async_context *ctx) {	close(ctx-&gt;epfd);	pthread_cancel(ctx-&gt;thread_id);	return 0;}static void *http_async_client_callback(void *arg) {	struct async_context *ctx = (struct async_context*)arg;	int epfd = ctx-&gt;epfd;	while (1) {		struct epoll_event events[ASYNC_CLIENT_NUM] = {0};		int nready = epoll_wait(epfd, events, ASYNC_CLIENT_NUM, -1);//等待准备就绪的fd		if (nready &lt; 0) {			if (errno == EINTR || errno == EAGAIN) {				continue;			} else {				break;			}		} else if (nready == 0) {			continue;		}		printf("nready:%d\n", nready);		int i = 0;		for (i = 0;i &lt; nready;i ++) {			struct ep_arg *data = (struct ep_arg*)events[i].data.ptr;//http请求的fd加入epoll的事件注册函数时候ev.data.ptr = eparg，现在通过ptr获取当时传递的参数			int sockfd = data-&gt;sockfd;						char buffer[BUFFER_SIZE] = {0};			struct sockaddr_in addr;			size_t addr_len = sizeof(struct sockaddr_in);			int n = recv(sockfd, buffer, BUFFER_SIZE, 0);//读取数据			data-&gt;cb(data-&gt;hostname, buffer); //调用回调，处理返回的数据						int ret = epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, NULL);//完成之后需要移除相应的fd			//printf("epoll_ctl DEL --&gt; sockfd:%d\n", sockfd);			close(sockfd); /////			free(data);		}			}}struct async_context *http_async_client_init(void) {	int epfd = epoll_create(1); // 创建一个epoll的句柄	if (epfd &lt; 0) return NULL;	struct async_context *ctx = calloc(1, sizeof(struct async_context));	if (ctx == NULL) {		close(epfd);		return NULL;	}	ctx-&gt;epfd = epfd;	int ret = pthread_create(&amp;ctx-&gt;thread_id, NULL, http_async_client_callback, ctx);//创建线程，注册回调用于异步epoll fd events的监听查询	if (ret) {		perror("pthread_create");		return NULL;	}	usleep(1); 	return ctx;}static void http_async_client_result_callback(const char *hostname, const char *result) {		printf("hostname:%s, result:%s\n\n\n\n", hostname, result);}int main(int argc, char *argv[]) {	struct async_context *ctx = http_async_client_init();//创建epoll和一个线程用于异步处理	if (ctx == NULL) return -1;	int count = sizeof(reqs) / sizeof(reqs[0]);	int i = 0;	for (i = 0;i &lt; count;i ++) {		http_async_client_commit(ctx, reqs[i].hostname, reqs[i].resource, http_async_client_result_callback);	}	getchar();}</code></pre><p>运行结果：</p><div class=pgc-img><img alt=同步请求和异步请求 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1d9cf327ccd94a3ba0edf295cf79bb7f><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异步','请求','求和'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>