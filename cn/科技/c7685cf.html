<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一怒之下我自己写了个PageHelper分页插件 | 极客快訊</title><meta property="og:title" content="一怒之下我自己写了个PageHelper分页插件 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/50426602d0764e93a53961830b578346"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c7685cf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c7685cf.html><meta property="article:published_time" content="2020-10-29T20:58:00+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:00+08:00"><meta name=Keywords content><meta name=description content="一怒之下我自己写了个PageHelper分页插件"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c7685cf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一怒之下我自己写了个PageHelper分页插件</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">前言</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">提到插件，相信大家都知道，插件的存在主要是用来改变或者增强原有的功能，MyBatis中也一样。然而如果我们对MyBatis的工作原理不是很清楚的话，最好不要轻易使用插件，否则的话如果因为使用插件导致了底层工作逻辑被改变，很可能会出现很多意料之外的问题。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">本文主要会介绍MyBatis插件的使用及其实现原理，相信读完本文，我们也可以写出自己的PageHelper分页插件了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">MyBatis中插件是如何实现的</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在MyBatis中插件</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">式</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通过拦截器来实现的，那么既然是通过拦截器来实现的，就会有一个问题，哪些对象才允许被拦截呢？</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">回想前面我们介绍Executor的文章中提到，真正执行Sql的是四大对象：Executor，StatementHandler，ParameterHandler，ResultSetHandler。而MyBatis的插件正是基于拦截这四大对象来实现的。需要注意的是，虽然我们可以拦截这四大对象，但是并不是这四大对象中的所有方法都能被拦截，下面就是官网提供的可拦截的对象和方法汇总：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/50426602d0764e93a53961830b578346><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">MyBatis插件的使用</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">首先我们先来通过一个例子来看看如何使用插件。<br>1、首先建立一个MyPlugin实现接口Interceptor，然后重写其中的三个方法(注意，这里必须要实现Interceptor接口，否则无法被拦截)。</span></p><pre><code>package com.lonelyWolf.mybatis.plugin;import org.apache.ibatis.executor.Executor;import org.apache.ibatis.mapping.MappedStatement;import org.apache.ibatis.plugin.*;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.RowBounds;import java.util.Properties;@Intercepts({@Signature(type = Executor.class,method = "query",args = {MappedStatement.class,Object.class, RowBounds.class, ResultHandler.class})})public class MyPlugin implements Interceptor {    /**     * 这个方法会直接覆盖原有方法     * @param invocation     * @return     * @throws Throwable     */    @Override    public Object intercept(Invocation invocation) throws Throwable {        System.out.println("成功拦截了Executor的query方法，在这里我可以做点什么");        return invocation.proceed();//调用原方法    }    @Override    public Object plugin(Object target) {        return Plugin.wrap(target,this);//把被拦截对象生成一个代理对象    }    @Override    public void setProperties(Properties properties) {//可以自定义一些属性        System.out.println("自定义属性:userName-&gt;" + properties.getProperty("userName"));    }}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">@Intercepts是声明当前类是一个拦截器，后面的@Signature是标识需要拦截的方法签名，通过以下三个参数来确定</span></p><ul><li>type：被拦截的类名。</li><li>method：被拦截的方法名</li><li>args：标注方法的参数类型</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2、我们还需要在mybatis-config中配置好插件。</span></p><pre><code>&lt;plugins&gt;        &lt;plugin interceptor="com.lonelyWolf.mybatis.plugin.MyPlugin"&gt;            &lt;property name="userName" value="张三"/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这里如果配置了property属性，那么我们可以在setProperties获取到。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">完成以上两步，我们就完成了一个插件的配置了，接下来我们运行一下：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b2842024f2e4c60af3a028a0ede8d43><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>可以看到，setProperties方法在加载配置文件阶段就会被执行了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">MyBatis插件实现原理</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">接下来让我们分析一下从插件的加载到初始化到运行整个过程的实现原理。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">插件的加载</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">既然插件需要在配置文件中进行配置，那么肯定就需要进行解析，我们看看插件式如何被解析的。我们进入XMLConfigBuilder类看看<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2e757fa536454deebf7af7b8740f988e><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>解析出来之后会将插件存入InterceptorChain对象的list属性<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b690200bcb4149839295df94a9256966><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>看到InterceptorChain我们是不是可以联想到，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">MyBatis的插件就是通过责任链模式实现的</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">插件如何进行拦截</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">既然插件类已经被加载到配置文件了，那么接下来就有一个问题了，插件类何时会被拦截我们需要拦截的对象呢？</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其实插件的拦截是和对象有关的，不同的对象进行拦截的时间也会不一致，接下来我们就逐一分析一下。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">拦截Executor对象</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">我们知道，SqlSession对象是通过openSession()方法返回的，而Executor又是属于SqlSession内部对象，所以让我们跟随openSession方法去看一下Executor对象的初始化过程。<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2b4fbdbae3e4cdab2f41b57332567b2><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>可以看到，当初始化完成Executor之后，会调用interceptorChain的pluginAll方法，pluginAll方法本身非常简单，就是把我们存到list中的插件进行循环，并调用Interceptor对象的plugin方法：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c0fcf7e6170344e18ccc58927d8ce00f><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>再次点击进去：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d90fe91337cc4200afb4712bc9a10c43><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>到这里我们是不是发现很熟悉，没错，这就是我们上面示例中重写的方法，而plugin方法是接口中的一个默认方法。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这个方法是关键，我们进去看看：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c27a2fb91784acfa87eac4415d7fc8a><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>可以看到这个方法的逻辑也很简单，但是需要注意的是MyBatis插件是通过JDK动态代理来实现的，而JDK动态代理的条件就是被代理对象必须要有接口，这一点和Spring中不太一样，Spring中是如果有接口就采用JDK动态代理，没有接口就是用CGLIB动态代理。<br></span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">关于动态代理，想详细了解的可以点击这里</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">正因为MyBatis的插件只使用了JDK动态代理，所以我们上面才强调了一定要实现Interceptor接口。<br>而代理之后汇之星Plugin的invoke方法，我们最后再来看看invoke方法：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/598f405806c446748929e0eea67de618><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>而最终执行的intercept方法，就是我们上面示例中重写的方法。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">其他对象插件解析</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">接下来我们再看看StatementHandler，StatementHandler是在Executor中的doQuery方法创建的，其实这个原理就是一样的了，找到初始化StatementHandler对象的方法：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30a07174a5424d7896d1f1bcd9509712><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>进去之后里面执行的也是pluginAll方法：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc49819fe7994065aabd23ef01139599><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>其他两个对象就</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">不在</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">举例了，其实搜一下全局就很明显了：<br>PS:<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06370677bc6b490fa5ae0d6fb42541e8><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>四个对象初始化的时候都会调用pluginAll来进行判定是否有被代理。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">插件执行流程</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">下面就是实现了插件之后的执行时序图：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/980634d3191643f7b2b8b8f5bc3f583b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">假如一个对象被代理很多次</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一个对象是否可以被多个代理对象进行代理？也就是说同一个对象的同一个方法是否可以被多个拦截器进行拦截？</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">答案是肯定的，因为被代理对象是被加入到list，所以我们</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">配置在最前面的拦截器最先被代理，但是执行的时候却是最外层的先执行</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。<br>具体点：<br>假如依次定义了三个插件：插件A，插件B和插件C。<br>那么List中就会按顺序存储：插件A，插件B和插件C，而解析的时候是遍历list，所以解析的时候也是按照：插件A，插件B和插件C的顺序，但是执行的时候就要反过来了，执行的时候是按照：插件C，插件B和插件A的顺序进行执行。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">PageHelper插件的使用</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">上面我们了解了在MyBatis中的插件是如何定义以及MyBatis中是如何处理插件的，接下来我们就以经典分页插件PageHelper为例来进一步加深理解。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">首先我们看看PageHelper的用法：</span></p><pre><code>package com.lonelyWolf.mybatis;import com.alibaba.fastjson.JSONObject;import com.github.pagehelper.Page;import com.github.pagehelper.PageHelper;import com.github.pagehelper.PageInfo;import com.lonelyWolf.mybatis.mapper.UserMapper;import com.lonelyWolf.mybatis.model.LwUser;import org.apache.ibatis.executor.result.DefaultResultHandler;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.ResultHandler;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;import java.util.List;public class MyBatisByPageHelp {    public static void main(String[] args) throws IOException {        String resource = "mybatis-config.xml";        //读取mybatis-config配置文件        InputStream inputStream = Resources.getResourceAsStream(resource);        //创建SqlSessionFactory对象        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        //创建SqlSession对象        SqlSession session = sqlSessionFactory.openSession();        PageHelper.startPage(0,10);        UserMapper userMapper = session.getMapper(UserMapper.class);        List&lt;LwUser&gt; userList = userMapper.listAllUser();        PageInfo&lt;LwUser&gt; pageList = new PageInfo&lt;&gt;(userList);        System.out.println(null == pageList ? "": JSONObject.toJSONString(pageList));    }}</code></pre><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">输出如下结果：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/83d4148fb5ce42dbab0d83990aa39c4d><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>可以看到对象已经被分页，那么这是如何做到的呢？</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">PageHelper插件原理</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">我们上面提到，要实现插件必须要实现MyBatis提供的Interceptor接口，所以我们去找一下，发现PageHeler实现了Interceptor：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/feeeca4b16ac421ab5fb121e7d1b3df7><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>经过上面的介绍这个类应该一眼就能看懂，我们关键要看看SqlUtil的intercept方法做了什么：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/209baf973f894947897270a7c9fa15fc><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>这个方法的逻辑比较多，因为要考虑到不同的数据库方言的问题，所以会有很多判断，我们主要是关注PageHelper在哪里改写了sql语句，上图中的红框就是改写了sql语句的地方：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/58ce1e0ba6404294ab01d3329507df92><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>这里面会获取到一个Page对象，然后在爱写sql的时候也会将一些分页参数设置到Page对象，我们看看Page对象是从哪里获取的：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1391dba30b2a42f88158389d9d721dc2><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">我们看到对象是从LOCAL_PAGE对象中获取的，这个又是什么呢？<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5988773549604ac2b659b20e35c60947><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>这是一个本地线程池变量，那么这里面的Page又是什么时候存进去的呢？<br>这就要回到我们的示例上了，分页的开始必须要调用：</span></p><pre><code>PageHelper.startPage(0,10);</code></pre><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/382de90bab614b8eb341f02d0fef6afb><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>这里就会构建一个Page对象，并设置到ThreadLocal内。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">为什么PageHelper只对startPage后的第一条select语句有效</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">这个其实也很简单哈，但是可能会有人有这个</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以为</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，我们还是要回到上面的intercept方法：<br></span></p><div class=pgc-img><img alt=一怒之下我自己写了个PageHelper分页插件 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/89fd2c041ea84d8c8007d67261caffeb><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>在finally内把ThreadLocal中的分页数据给清除掉了，所以只要执行一次查询语句就会清除分页信息，故而后面的select语句自然就无效了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">不通过插件能否改变MyBatis的核心行为</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">上面我们介绍了通过插件来改变MyBatis的核心行为，那么不通过插件是否也可以实现呢？</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">答案是肯定的，官网中提到，我们可以通过覆盖配置类来实现改变MyBatis核心行为，也就是我们自己写一个类继承Configuration类，然后实现其中的方法，最后构建SqlSessionFactory对象的时候传入自定义的Configuration方法：</span></p><pre><code>SqlSessionFactory build(MyConfiguration)</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">当然，这种方法是非常不建议使用的，因为这种方式就相当于在建房子的时候把地基抽出来重新建了，稍有不慎，房子就要塌了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">总结</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">本文主要会介绍MyBatis插件的使用及MyBatis其实现原理，最后我们也大致介绍了PageHelper插件的主要实现原理，相信读完本文学会MyBatis插件原理之后，我们也可以写个自己的PageHelper分页插件了。</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'插件','PageHelper','分页'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/9a900bc.html alt=PageHelper分页插件源码及原理剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7be33d442f35419cbb3709ec81b6fb94 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/9a900bc.html title=PageHelper分页插件源码及原理剖析>PageHelper分页插件源码及原理剖析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>