<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>静态检查工具的探索之路 | 极客快訊</title><meta property="og:title" content="静态检查工具的探索之路 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/868e0a0566c24b569700e069a3a025ee"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c769ab2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c769ab2.html><meta property="article:published_time" content="2020-10-29T20:52:09+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:09+08:00"><meta name=Keywords content><meta name=description content="静态检查工具的探索之路"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c769ab2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>静态检查工具的探索之路</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>TSLint为TypeScript提供了代码检查能力，对使用TypeScript的React Native工程，在规范性、安全性、可靠性、可维护性等方面起到重要作用。本文主要对TSLint相关知识进行分享，并对自定义TSLint规则进行介绍。</p></blockquote><p>建立的代码规范没人遵守，项目中遍地风格迥异的代码，你会不会抓狂？</p><p>通过测试用例的程序还会出现Bug，而原因仅仅是自己犯下的低级错误，你会不会抓狂？</p><p>某种代码写法存在问题导致崩溃时，只能全工程检查代码，这需要人工花费大量时间Review代码，你会不会抓狂？</p><p>以上这些问题，可以通过静态检查有效地缓解！</p><p>静态检查（Static Program Analysis）主要是以不运行程序的方式对于程序源代码进行检查分析的技术，而与之相反的就是动态检查（Dynamic Program Analysis），通过实际运行程序输入测试数据产生预期结果的技术。通过代码静态检查，我们可以快速定位代码的错误与缺陷，可以减少逐行阅读代码浪费的时间，可以（根据需要）快速扫描代码中可能存在的漏洞等。代码静态检查可以在代码的规范性、安全性、可靠性、可维护性等方面起到重要作用。</p><p>在客户端中，Android可以使用CheckStyle、Lint、Findbugs、PMD等工具，iOS可以使用Clang Static Analyzer、OCLint等工具。而在React Native的开发过程中，针对于JavaScript的ESLint，与TypeScript的TSLint，则成为了主要代码静态检查的工具。本文将按照使用TSLint的原因、使用TSLint的方法、自定义TSLint的步骤进行探究分析。</p><p><strong>一、使用TSLint的原因</strong></p><p>在客户端团队进入React Native项目的开发过程中，面临着如下问题：</p><ol><li class=ql-align-justify>由于大家从客户端转入到React Native开发过程中，容易出现低级语法错误；</li><li class=ql-align-justify>开发者之前从事Android、iOS、前端等工作，因此代码风格不同，导致项目代码风格不统一；</li><li class=ql-align-justify>客户端效果不一致，有可能Android端显示正常、iOS端显示异常，或者相反的情况出现。</li></ol><p>虽然以上问题可以通过多次不断将雷点标记出，并不断地分享经验与强化代码Review过程等方式来进行缓解，但是仍面临着React Native开发者掌握的技术水平千差万别，知识分享传播的速度缓慢等问题，既导致了开发成本的不断增加和开发效率持续低下的问题，还难以避免一个坑被踩了多次的情况出现。这时急需一款可以满足以下目标的工具：</p><ol><li class=ql-align-justify>可检测代码低级语法错误；</li><li class=ql-align-justify>规范项目代码风格；</li><li class=ql-align-justify>根据需要可自定义检查代码的逻辑；</li><li class=ql-align-justify>工具使用者可以“傻瓜式”的接入部署到开发IDE环境；</li><li class=ql-align-justify>可以快速高效地将检查工具最新检查逻辑同步到开发IDE环境中；</li><li class=ql-align-justify>对于检查出的问题可以快速定位。</li></ol><p>根据上述要求的描述，静态检查工具TSLint可以较为有效地达成目标。</p><p><strong>二、TSLint介绍</strong></p><p>TSLint是硅谷企业Palantir的一个项目，它是一款可以检查TypeScript代码可读性、可维护性以及功能性错误的静态检查工具，当前许多编辑器（Editors）和构建系统（Build Systems）支持这一工具，同时支持自定义编写Lint规则、配置、格式化等。</p><p>当前TSLint已经包含了上百条规则，这些规则构筑了当前TSLint检查的基础。在代码开发阶段中，通过这些配置好的规则可以给工程一个完整的检查，并随时可以提示出可能存在的问题。本文内容参考了TSLint官方文档https://palantir.github.io/tslint/。</p><p><strong>2.1 TSLint常见规则</strong></p><p>以下规则主要来源于TSLint规则，是某些规则的简单介绍。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/868e0a0566c24b569700e069a3a025ee><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>2.2 常用TSLint规则包</strong></p><p>上述2.1所列出的规则来源于Palantir官方TSLint规则。实际还有多种，可能会用到的有以下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f4a5132633844c12ba418e3d548df96c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>我们在项目的规则配置过程中，一般采用上述规则包其中一种或者若干种同时配置，那如何配置呢？请看下文。</p><p><strong>三、如何进行TSLint规则配置与检查</strong></p><p>首先，在工程package.json文件中配置TSLint包：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2776d45e6ac54afd9e7a0e8bdc2dd4e5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>在根目录中的tslint.json文件中可以根据需要配置已有规则，例如：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9f743185813147a898496c9faa0b44d1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>其中extends数组内放置继承的TSLint规则包，上图包括了airbnb配置的规则包、tslint-react的规则包，而rules用于配置规则的开关。</p><p>TSLint规则目前只有true和false的选项，这导致了结果要么正常，要么报错ERROR，而不会出现WARNING等警告。</p><p>有些时候，虽然配置某些规则开启，但是某个文件内可能会关闭某些甚至全部规则检查，这时候可以通过规则注释来配置，如：</p><pre>/* tslint:disable */</pre><p>上述注释表示本文件自此注释所在行开始，以下的所有区域关闭TSLint规则检查。</p><pre>/* tslint:enable */</pre><p>上述注释表示本文件自此注释所在行开始，以下的所有区域开启TSLint规则检查。</p><pre>/* tslint:disable:rule1 rule2 rule3... */</pre><p>上述注释表示本文件自此注释所在行开始，以下的所有区域关闭规则rule1 rule2 rule3...的检查。</p><pre>/* tslint:enable:rule1 rule2 rule3... */</pre><p>上述注释表示本文件自此注释所在行开始，以下的所有区域开启规则rule1 rule2 rule3...的检查。</p><pre>// tslint:disable-next-line</pre><p>上述注释表示此注释所在行的下一行关闭TSLint规则检查。</p><pre>someCode(); // tslint:disable-line</pre><p>上述注释表示此注释所在行关闭TSLint规则检查。</p><pre>// tslint:disable-next-line:rule1 rule2 rule3...</pre><p>上述注释表示此注释所在行的下一行关闭规则rule1 rule2 rule3...的检查检查。</p><p>以上配置信息，这里具体参考了https://palantir.github.io/tslint/usage/rule-flags/。</p><p><strong>3.1 本地检查</strong></p><p>在完成工程配置后，需要下载所需要依赖包，要在工程所在根目录使用npm install命令完成下载依赖包。</p><p><strong>IDE环境提示</strong></p><p>在完成下载依赖包后，IDE环境可以根据对应配置文件进行提示，可以实时地提示出存在问题代码的错误信息，以VSCode为例：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4eecbcc9f2564d0a9c9015fb5134cff3><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>本地命令检查</strong></p><p>VSCode目前还有继续完善的空间，如果部分文件未在窗口打开的情况下，可能存在其中错误未提示出的情况，这时候，我们可以通过本地命令进行全工程的检查，在React Native工程的根目录下，通过以下命令行执行：</p><pre>tslint --project tsconfig.json --config tslint.json</pre><p>（此命令如果不正确运行，可在之前加入./node_modules/.bin/）即为：</p><pre>./node_modules/.bin/tslint --project tsconfig.json --config tslint.json</pre><p>从而会提示出类似以下错误的信息：</p><pre>src/Components/test.ts[1, 7]: Class name must be in pascal case</pre><p><strong>3.2 在线CI检查</strong></p><p>本地进行代码检查的过程也会存在被人遗忘的可能性，通过技术的保障，可以避免人为遗忘，作为代码提交的标准流程，通过CI检查后再合并代码，可以有效避免代码错误的问题。CI系统可以为理解为一个云端的环境，环境配置与本地一致，在这种情况下，可以生成与本地一致的报告，在美团内部可以使用基于Jenkins的Castle CI系统， 生成结果与本地结果一致：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b14003c13ac4d67bc39b602a77ac0ca><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>3.3 其他方式</strong></p><p>代码检查不止局限上述阶段，在代码commit、pull request、打包等阶段均可触发。</p><ul><li class=ql-align-justify>代码commit阶段，通过Hook方式可以触发代码检查，可以有效地将在线CI检查阶段强制提前，基本保证了在线CI检查的完全正确性。</li><li class=ql-align-justify>代码pull request阶段，通过在线CI检查可以触发代码检查，可以有效保证合入分支尤其是主分支的正确性。</li><li class=ql-align-justify>代码打包阶段，通过在线CI检查可以触发代码检查，可以有效保证打包代码的正确性。</li></ul><p><strong>四、自定义编写TSLint规则</strong></p><p><strong>4.1 为什么要自定义TSLint规则</strong></p><p>当前的TSLint规则虽然涵盖了比较普遍问题的一些代码检查，但是实践中还是存在一些问题的：</p><ol><li class=ql-align-justify>团队中的个性化需求难以满足。例如，saga中的异步函数需要在最外层加try-catch，且catch块中需要加异常上报，这个明显在官方的TSLint规则无法实现，为此需要自定义的开发。</li><li class=ql-align-justify>官方规则的开启与配置不符合当前团队情况。</li></ol><p>基于以上原因其他团队也有自定义TSLint的先例，例如上文提到的tslint-microsoft-contrib、tslint-eslint-rules等。</p><p><strong>4.2 自定义规则步骤</strong></p><p>那自定义TSLint大概需要什么步骤呢，首先规则文件根据规范进行按部就班的编写规则信息，然后根据代码检查逻辑对语法树进行分析并编写逻辑代码，这也是自定义规则的核心部分了，最后就是自定义规则的使用了。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/11a79ba842014c01aba23ee8149235f9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>自定义规则的示例直接参考官方的规则是最直接的，我们能这里参考一个比较简单的规则"class-name"。</p><p>"class-name"规则上文已经提到，它的意思是对类命名进行规范，当团队中类相关的命名不规范，会导致项目代码风格不统一甚至其他出现的问题，而"class-name"规则可以有效解决这个问题。我们可以看下具体的源码文件：https://github.com/palantir/tslint/blob/master/src/rules/classNameRule.ts。</p><p>然后将分步对此自定义规则进行讲解。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1a99f75559594755972aafbadc359bbc><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>第一步，文件命名</strong></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e91b8b32099740b683c584094bb6d990><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>规则命名必须是符合以下2个规则：</p><ol><li class=ql-align-justify>驼峰命名。</li><li class=ql-align-justify>以'Rule'为后缀。</li></ol><p><strong>第二步，类命名</strong></p><p>规则的类名是Rule，并且要继承Lint.Rules.AbstractRule这个类型，当然也可能有继承TypedRule这个类的时候，但是我们通过阅读源码发现，其实它也是继承自Lint.Rules.AbstractRule这个类。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/de1ddc0d3f6e458d9d8909e01d4c7b44><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>第三步，填写metadata信息</strong></p><p>metadata包含了配置参数，定义了规则的信息以及配置规则的定义。</p><ul><li class=ql-align-justify>ruleName 是规则名，使用烤串命名法，一般是将类名转为烤串命名格式。</li><li class=ql-align-justify>description 一个简短的规则说明。</li><li class=ql-align-justify>descriptionDetails 详细的规则说明。</li><li class=ql-align-justify>rationale 理论基础。</li><li class=ql-align-justify>options 配置参数形式，如果没有可以配置为null。</li><li class=ql-align-justify>optionExamples 参数范例 ，如没有参数无需配置。</li><li class=ql-align-justify>typescriptOnly true/false 是否只适用于TypeScript。</li><li class=ql-align-justify>hasFix true/false 是否带有修复方式。</li><li class=ql-align-justify>requiresTypeInfo 是否需要类型信息。</li><li class=ql-align-justify>optionsDescrition options的介绍。</li><li class=ql-align-justify>type 规则的类型。</li></ul><p>规则类型有四种，分别为："functionality"、"maintainability"、"style"、"typescript"。</p><ul><li class=ql-align-justify>functionality ： 针对于语句问题以及功能问题。</li><li class=ql-align-justify>maintainability：主要以代码简洁、可读、可维护为目标的规则。</li><li class=ql-align-justify>style：以维护代码风格基本统一的规则。</li><li class=ql-align-justify>typescript：针对于TypeScript进行提示。</li></ul><p><strong>第四步，定义错误提示信息</strong></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2184280623314a199faac1f254fc081e><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>这个主要是在检查出问题的时候进行提示的文字，并不局限于使用一个静态变量的形式，但是大部分官方规则都是这么编写，这里对此进行介绍，防止引起歧义。</p><p><strong>第五步，实现apply方法</strong></p><p>apply主要是进行静态检查的核心方法，通过返回applyWithFunction方法或者返回applyWithWalker来进行代码检查，其实applyWithFunction方法与applyWithWalker方法的主要区别在于applyWithWalker可以通过IWalker实现一个自定义的IWalker类，区别如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f035fa59a3564e7b8c3aacae62cd5c1b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>其中实现IWalker的抽象类AbstractWalker里面也继承了WalkContext，</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/17bff4e40a534209a736c6fdafee2877><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>而这个WalkContext就是上面提到的applyWithFunction的内部实现类。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/805d974b606c420887674ddb7dd3147f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>第六步，语法树解析</strong></p><p>无论是applyWithFunction方法还是applyWithWalker方法中的IWalker实现都传入了sourceFile这个参数，这个相当于文件的根节点，然后通过ts.forEachChild方法遍历整个语法树节点。</p><p>这里有两个查看AST语法树的工具：</p><ul><li class=ql-align-justify>AST Explorer：</li><li class=ql-align-justify>https://astexplorer.net/</li><li class=ql-align-justify>对应源码：</li><li class=ql-align-justify>https://github.com/fkling/astexplorer</li><li class=ql-align-justify>TypeScript AST Viewer：</li><li class=ql-align-justify>https://ts-ast-viewer.com/</li><li class=ql-align-justify>对应源码：</li><li class=ql-align-justify>https://github.com/dsherret/ts-ast-viewer</li></ul><p><strong>AST Explorer</strong></p><p><strong>优点：</strong></p><p>在AST Explorer可以高亮显示所选中代码对应的AST语法树信息。</p><p><strong>缺点：</strong></p><p class=ql-align-justify>1. 不能选择对应版本的解析器，导致显示的语法树代码版本固定。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b22e4484a2e46eca72af247e7623fb9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>2. 语法树显示的信息相对较少。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fae47e39fa784c58b0341141888c2eb8><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>TypeScript AST Viewer</strong></p><p><strong>优点：</strong></p><p class=ql-align-justify>1. 解析器对应版本可以动态选择：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab33c3a8c3fe40b1bfa643d464e6e1b9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>2. 语法树显示的信息不仅显示对应的数字代码，还可为对应的实际信息：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5b123ac00c594f2d9673f3abcc2906a4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>每个版本对应对kind信息数值可能会变动，但是对应的枚举名字是固定的，如下图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/358d70744d9a4ad6a98250ad998e041c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>从而这个工具可以避免频繁根据其数值查找对应信息。</p><p><strong>缺点：</strong>不能高亮显示代码对应的AST语法树区域，定位效率较低。</p><p>综上，通过同时使用上述两个工具定位分析，可以有效地提高分析效率。</p><p><strong>第七步，规则代码编写</strong></p><p>通过ts.forEachChild方法对于语法树所有的节点进行遍历，在遍历的方法里可以实现自己的逻辑，其中节点的类为ts.Node：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7f6747a8104c4b00bf39d797fda00a5b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>其中kind为当前节点的类型，当然Node是所有节点的基类，它的实现还包括Statement、Expression、Declaration等，回到开头这个"class-name"规则，我们的所有声明类主要是class与interface关键字，分别对应ClassExpression、ClassDeclaration、InterfaceDeclaration，</p><p>我们可以通过上步提到的AST语法树工具，在语法树中看到其为一一对应的。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c358f6fb9deb427a8edc85c16eb8c245><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>在规则代码中主要通过isClassLikeDeclaration、isInterfaceDeclaration这两个方法进行判断的。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/49a86873961e45b897f7b0e61914dcfa><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>其中isClassLikeDeclaration、isInterfaceDeclaration对应的方法我们可以在node.js文件中找到：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/66a4da11fe1142ae9a917b0fac33e82d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e7d42b091d1e4c8e8c6c3314c79d90e1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>判断是对应的类型时，调用addFailureAtNode方法把错误信息和节点传入，当然还可以调用addFailureAt、addFailure方法。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6df7054fb63f4acea403d36b321e8be1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>最终这个规则编写结束了，有一点再次强调下，因为每个版本所对应的类型代码可能不相同，当判断kind的时候，一定不要直接使用各个类型对应的数字。</p><p><strong>第八步，规则配置使用</strong></p><p>完成规则代码后，是ts后缀的文件，而ts规则文件实际还是要用js文件，这时候我们需要用命令将ts转化为js文件：</p><pre>tsc ./src/*.ts --outDir dist</pre><p>将ts规则生成到dist文件夹（这个文件夹命名用户自定），然后在tslint.json文件中配置生成的规则文件即可。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7ee271ad47d149cb9b4f5cc9c98de377><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>之后在项目的根目录里面，使用以下命令既可进行检查：</p><pre>tslint --project tsconfig.json --config tslint.json</pre><p>同时为了未来新增规则以及规则配置的更好的操作性，建议可以封装到自己的规则包，以便与规则的管理与传播。</p><p><strong>总结</strong></p><p><strong>TSLint的优点：</strong></p><ol><li class=ql-align-justify>速度快。相对于动态代码检查，检查速度较快，现有项目无论是在本地检查，还是在CI检查，对于由十余个页面组成的React Native工程，可以在1到2分钟内完成；</li><li class=ql-align-justify>灵活。通过配置规则，可以有效地避免常见代码错误与潜在的Bug；</li><li class=ql-align-justify>易扩展。通过编写配置自定义规则，可以及时准确快速查找出代码中特定风险点。</li></ol><p><strong>TSLint缺点：</strong></p><ol><li class=ql-align-justify>规则的结果只有对与错两种等级结果，没有警告等级的的提示结果；</li><li class=ql-align-justify>无法直接报告规则报错数量，只能依赖其他手段统计；</li><li class=ql-align-justify>TSLint规则针对于当前单一文件可以有效地通过语法树进行分析判定，但对于引用到的其他文件中的变量、类、方法等，则难以通过AST语法树进行判定。</li></ol><p><strong>使用结果及分析</strong></p><p>在美团，有十余个页面的单个工程首次接入TSLint后，检查出的问题有近百条。但是由于开启的规则不同，配置规则包的差异，检查后的数量可能为几十条到几千条甚至更多。现在已开发十余条自定义规则，在单个工程内，处理优化了数百处可能存在问题的代码。最终TSLint接入了相关React Native开发团队，成为了代码提交阶段的必要步骤。</p><p>通过团队内部的验证，文章开头遇到的问题得到了有效地缓解，目标基本达到预期。TSLint在React Native开发过程中既保证了代码风格的统一，又保证了React Native开发人员的开发质量，避免了许多低级错误，有效地节省了问题排查和人员沟通的成本。</p><p>同时利用自定义规则，能够将一些兼容性问题在内的个性化问题进行总结与预防，提高了开发效率，不用花费大量时间查找问题代码，又避免了在一个问题上跌倒多次的情况出现。对于不同经验的开发者而言，不仅可以进行友好的提示，也可以帮助快速地定位问题，将一个人遇到的经验教训，用极低的成本扩散到其他团队之中，将开发状态从“亡羊补牢”进化到“防患未然”。</p><p><strong>作者简介</strong></p><p>家正，美团点评Android高级工程师。2017 年加入美团点评，负责美团大交通的业务开发。</p><blockquote><p>欢迎加入<strong>美团Web前端技术交流群</strong>，跟项目维护者零距离交流。进群方式：请加美美同学微信（<strong>微信号：MTDPtech02</strong>），回复：<strong>前端</strong>，美美会自动拉你进群。</p></blockquote><div class=pgc-img><img alt=静态检查工具的探索之路 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/73632f9f78be4b84a17bc9e358626a5c><p class=pgc-img-caption>微信扫码关注，阅读更多技术干货</p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'静态','检查','探索'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>