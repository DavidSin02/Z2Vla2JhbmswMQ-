<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>HashMap的底层实现 | 极客快訊</title><meta property="og:title" content="HashMap的底层实现 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c78a6fe2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c78a6fe2.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="HashMap的底层实现"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c78a6fe2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>HashMap的底层实现</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><ol start=1><li>存储结构</li></ol><ul><li>Node[]为哈希桶数组，本质是键值对映射，当链表长度大于8时，采用红黑树存储，TreeNode表示一个节点；</li><li>HashMap是基于哈希表存储，HashMap采用链地址法解决hash冲突；</li></ul><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc><p class=pgc-img-caption></p></div><ol start=2><li>元素查找（index）</li></ol><ul><li>步骤：取key的hashCode：任意给定的对象，进行多次hashCode()返回值相同高位运算：取高16位取模运算：对数组长度取模；</li></ul><p><span style="color:#a50;--tt-darkmode-color: #AA5500">//方法一：</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">static</span> <span style="color:#708;--tt-darkmode-color: #E844FF">final</span> int hash(Object key) { <span style="color:#a50;--tt-darkmode-color: #AA5500">//jdk1.8 & jdk1.7</span><br>int h;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// h = key.hashCode() 为第一步 取hashCode值</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">// h ^ (h >>> 16) 为第二步 高位参与运算</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> (key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span> 0 : (h <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> key.hashCode()) ^ (h <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>>></span> 16);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//方法二：</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">static</span> int indexFor(int h, int length) { <span style="color:#a50;--tt-darkmode-color: #AA5500">//jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> h <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> (length<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span>1); <span style="color:#a50;--tt-darkmode-color: #AA5500">//第三步 取模运算</span><br>}</p><ul><li>示例，n为table的长度：</li></ul><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee4a0cff50e54acd92665f89259ea33d><p class=pgc-img-caption></p></div><ol start=3><li>元素存放（put）</li></ol><ul><li>步骤：</li></ul><p>①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</p><p>②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</p><p>③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</p><p>④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p><p>⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</p><p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容 ；</p><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a960cee3d7b44c2b63403a0769a708c><p class=pgc-img-caption></p></div><p><span style="color:#708;--tt-darkmode-color: #E844FF">public</span> V put(K key, V value) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 对key的hashCode()做hash</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> putVal(hash(key), key, value, false, true);<br>}<br><br><span style="color:#708;--tt-darkmode-color: #E844FF">final</span> V putVal(int hash, K key, V value, boolean onlyIfAbsent,<br>boolean evict) {<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] tab; Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> p; int n, i;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步骤①：tab为空则创建</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((tab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> table) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> (n <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> tab.length) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0)<br>n <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (tab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> resize()).length;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步骤②：计算index，并对null做处理</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((p <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> tab[i <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (n <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span> 1) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> hash]) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>tab[i] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newNode(hash, key, value, null);<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> {<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> e; K k;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步骤③：节点key存在，直接覆盖value</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (p.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>((k <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> p.key) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> (key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> key.equals(k))))<br>e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> p;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步骤④：判断该链为红黑树</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (p <span style="color:#708;--tt-darkmode-color: #E844FF">instanceof</span> TreeNode)<br>e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> ((TreeNode<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>)p).putTreeVal(<span style="color:#708;--tt-darkmode-color: #E844FF">this</span>, tab, hash, key, value);<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步骤⑤：该链为链表</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> {<br><span style="color:#708;--tt-darkmode-color: #E844FF">for</span> (int binCount <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> 0; ; <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>binCount) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> p.next) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null) {<br>p.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newNode(hash, key,value,null);<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//链表长度大于8转换为红黑树进行处理</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (binCount <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> TREEIFY_THRESHOLD <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span> 1) <span style="color:#a50;--tt-darkmode-color: #AA5500">// -1 for 1st</span><br>treeifyBin(tab, hash);<br><span style="color:#708;--tt-darkmode-color: #E844FF">break</span>;<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// key已经存在直接覆盖value</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>((k <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e.key) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> (key <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> key.equals(k)))) <span style="color:#708;--tt-darkmode-color: #E844FF">break</span>;<br>p <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>}<br>}<br><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) { <span style="color:#a50;--tt-darkmode-color: #AA5500">// existing mapping for key</span><br>V oldValue <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e.value;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!</span>onlyIfAbsent <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">||</span> oldValue <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>e.value <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> value;<br>afterNodeAccess(e);<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> oldValue;<br>}<br><br><span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>modCount;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 步骤⑥：超过最大容量 就扩容</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>size <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> threshold)<br>resize();<br>afterNodeInsertion(evict);<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> null;<br>}</p><ol start=4><li>扩容机制（resize）</li></ol><ul><li>步骤：</li></ul><p>1）扩容数组：如果超过了数组的最大容量，那么就直接将阈值设置为整数最大值，然后如果没有超过，那就扩容为原来的2倍；</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">//第一部分：扩容</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> MAXIMUM_CAPACITY) {<br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> Integer.MAX_VALUE;<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> oldTab;<br>}<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> DEFAULT_INITIAL_CAPACITY)<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1; <span style="color:#a50;--tt-darkmode-color: #AA5500">// double threshold</span><br>}</p><p>2）设置阈值：第一个else if表示如果阈值已经初始化过了，那就直接使用旧的阈值，然后第二个else表示如果没有初始化，那就初始化一个新的数组容量和新的阈值；</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">//第二部分：设置阈值</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) <span style="color:#a50;--tt-darkmode-color: #AA5500">//阈值已经初始化了，就直接使用</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> { <span style="color:#a50;--tt-darkmode-color: #AA5500">// 没有初始化阈值那就初始化一个默认的容量和阈值</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> DEFAULT_INITIAL_CAPACITY;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (int)(DEFAULT_LOAD_FACTOR <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> DEFAULT_INITIAL_CAPACITY);<br>}<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">float</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> loadFactor;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span><br>(int)ft : Integer.MAX_VALUE);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//为当前的容量阈值赋值</span><br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newThr;<br><span style="color:#555;--tt-darkmode-color: #555555">@SuppressWarnings</span>({<span style="color:#a11;--tt-darkmode-color: #E92727">"rawtypes"</span>,<span style="color:#a11;--tt-darkmode-color: #E92727">"unchecked"</span>})<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] newTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[])<span style="color:#708;--tt-darkmode-color: #E844FF">new</span> Node[newCap];<br>table <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newTab;</p><p>3）将旧数据复制到新数组里面，设计rehash过程（详情见3））：</p><p>A：扩容后，若hash值新增参与运算的位=0，那么元素在扩容后的位置=原始位置</p><p>B：扩容后，若hash值新增参与运算的位=1，那么元素在扩容后的位置=原始位置+扩容后的旧位置；</p><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0c11e6ed68be4f518da773500a05d14a><p class=pgc-img-caption></p></div><p><span style="color:#708;--tt-darkmode-color: #E844FF">final</span> Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] resize() {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//先将老的Table取别名，这样利于后面的操作。</span><br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] oldTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> table;<br>int oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (oldTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span> 0 : oldTab.length;<br>int oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> threshold;<br>int newCap, newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> 0;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示之前的数组容量不为空。</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 如果 此时的数组容量大于最大值</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> MAXIMUM_CAPACITY) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 扩容 阙值为 Int类型的最大值，这种情况很少出现</span><br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> Integer.MAX_VALUE;<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> oldTab;<br>}<br><br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示 old数组的长度没有那么大，进行扩容，两倍（这里也是有讲究的）对阙值也进行扩容</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span><br>oldCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">>=</span> DEFAULT_INITIAL_CAPACITY)<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;&lt;</span> 1; <span style="color:#a50;--tt-darkmode-color: #AA5500">// double threshold</span><br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示之前的容量是0 但是之前的阙值却大于零， 此时新的hash表长度等于此时的阙值</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> 0) <span style="color:#a50;--tt-darkmode-color: #AA5500">// initial capacity was placed in threshold</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldThr;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> { <span style="color:#a50;--tt-darkmode-color: #AA5500">// zero initial threshold signifies using defaults</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示是初始化时候，采用默认的 数组长度* 负载因子</span><br>newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> DEFAULT_INITIAL_CAPACITY;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (int)(DEFAULT_LOAD_FACTOR <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> DEFAULT_INITIAL_CAPACITY);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//此时表示若新的阙值为0 就得用 新容量* 加载因子重新进行计算。</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">float</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">*</span> loadFactor;<br>newThr <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&&</span> ft <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> (<span style="color:#708;--tt-darkmode-color: #E844FF">float</span>)MAXIMUM_CAPACITY <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">?</span><br>(int)ft : Integer.MAX_VALUE);<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 开始对新的hash表进行相对应的操作。</span><br>threshold <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newThr;<br><span style="color:#555;--tt-darkmode-color: #555555">@SuppressWarnings</span>({<span style="color:#a11;--tt-darkmode-color: #E92727">"rawtypes"</span>,<span style="color:#a11;--tt-darkmode-color: #E92727">"unchecked"</span>})<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[] newTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>[])<span style="color:#708;--tt-darkmode-color: #E844FF">new</span> Node[newCap];<br>table <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> newTab;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (oldTab <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//遍历旧的hash表，将之内的元素移到新的hash表中。</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">for</span> (int j <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> 0; j <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span> oldCap<span style="color:#a50;--tt-darkmode-color: #AA5500">/***此时旧的hash表的阙值*/</span>; <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">++</span>j) {<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> oldTab[j]) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br><span style="color:#a50;--tt-darkmode-color: #AA5500">//表示这个格子不为空</span><br>oldTab[j] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 表示当前只有一个元素，重新做hash散列并赋值计算。</span><br>newTab[e.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> (newCap <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">-</span> 1)] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> <span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (e <span style="color:#708;--tt-darkmode-color: #E844FF">instanceof</span> TreeNode)<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 如果在旧哈希表中，这个位置是树形的</span><span style="color:#a50;--tt-darkmode-color: #AA5500">结果</span><span style="color:#a50;--tt-darkmode-color: #AA5500">，就要把新hash表中也变成树形结构，</span><br>((TreeNode<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span>)e).split(<span style="color:#708;--tt-darkmode-color: #E844FF">this</span>, newTab, j, oldCap);<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> { <span style="color:#a50;--tt-darkmode-color: #AA5500">// preserve order</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">//保留 旧hash表中是链表的顺序</span><br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> loHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null, loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> hiHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null, hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>Node<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&lt;</span>K,V<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">></span> next;<br><span style="color:#708;--tt-darkmode-color: #E844FF">do</span> {<span style="color:#a50;--tt-darkmode-color: #AA5500">// 遍历当前Table内的Node 赋值给新的Table。</span><br>next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e.next;<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> ((e.hash <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">&</span> oldCap) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> 0) {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>loHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span><br>loTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引+oldCap</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span> {<br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">==</span> null)<br>hiHead <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br><span style="color:#708;--tt-darkmode-color: #E844FF">else</span><br>hiTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> e;<br>}<br>} <span style="color:#708;--tt-darkmode-color: #E844FF">while</span> ((e <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> next) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null);<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引放到bucket里面</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (loTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br>loTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>newTab[j] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> loHead;<br>}<br><span style="color:#a50;--tt-darkmode-color: #AA5500">// 原索引+oldCap 放到bucket里面</span><br><span style="color:#708;--tt-darkmode-color: #E844FF">if</span> (hiTail <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">!=</span> null) {<br>hiTail.next <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> null;<br>newTab[j <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">+</span> oldCap] <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> hiHead;<br>}<br>}<br>}<br>}<br>}<br><span style="color:#708;--tt-darkmode-color: #E844FF">return</span> newTab;<br>}</p><ul><li>示例：假设哈希桶数组长度为2，依次插入key为5、7、3，负载因子为1：</li></ul><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00a8f9a0f9df4b398867dd0184a29f3d><p class=pgc-img-caption></p></div><ul><li>JDK1.8对rehash的优化</li></ul><p>1）n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果，key2元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化；</p><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fa355e394d2429383b8b18ec6a17998><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/456194205a8345f8a492ea74c822c021><p class=pgc-img-caption></p></div><p>2）JDK1.8扩充HashMap的时候，<strong>不需要像JDK1.7的实现那样重新计算hash</strong>，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2e470e8a163e4fc8aca55283b5c7e620><p class=pgc-img-caption></p></div><ul><li>解决hash冲突的方法开放</li></ul><p>1）地址法</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">#H(key)为哈希函数，m为哈希表表长，di为增量序列，i为已发生冲突的次数</span><br>Hi <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> (H(key) <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">+</span> di) MOD m，其中i<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span>1,2,…,k(k&lt;<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span>m-1)</p><p>A：线性探查法（Linear Probing）：di = 1,2,3,…,m-1</p><p>B：平方探测法（Quadratic Probing）：di = ±12, ±22，±32，…，±k2（k≤m/2）</p><p>C：伪随机探测法：di = 伪随机数序列</p><p>2）再哈希法</p><p><span style="color:#a50;--tt-darkmode-color: #AA5500">#RHi()函数是不同于H()的哈希函数，用于同义词发生地址冲突时，计算出另一个哈希函数地址，直到不发生冲突位置；</span><br><span style="color:#a50;--tt-darkmode-color: #AA5500">#这种方法不容易产生</span><span style="color:#a50;--tt-darkmode-color: #AA5500">堆集</span><span style="color:#a50;--tt-darkmode-color: #AA5500">，但是会增加计算时间</span><br>Hi <span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span> RHi(key), 其中i<span style="color:#981a1a;--tt-darkmode-color: #DE3B3B">=</span>1,2,…,k</p><p>3）建立公共溢出区</p><p>假设哈希函数的值域为[0, m-1]，设向量HashTable[0,…,m-1]为基本表，每个分量存放一个记录，另外还设置了向量OverTable[0,…,v]为溢出表。基本表中存储的是关键字的记录，一旦发生冲突，不管他们哈希函数得到的哈希地址是什么，都填入溢出表；缺点：查找冲突数据的时候，需要遍历溢出表才能得到数据；</p><p>4）<strong>链地址法（拉链法）</strong></p><p>将冲突位置的元素构造成链表；在添加数据的时候，如果哈希地址与哈希表上的元素冲突，就放在这个位置的链表上；优点：平均查找长度较短、适合造表前无法确定表长的情况、删除结点操作易于实现；缺点：需要额外的存储空间；</p><ul><li>HashMap的加载因子为什么是0.75</li></ul><p>1）冲突：填充程度高，空间利用率高，但是哈希冲突频繁；填充程度低，冲突发生率减少，但是空间利用率不高；加载因子表示Hash表的元素填充程度；</p><p>2）泊松分布：描述单位时间内随机事件发生的次数的概率分布；</p><p>3）在理想情况下，使用随机哈希码，在扩容阈值（加载因子）为0.75的情况下，节点出现在频率在Hash桶（表）中遵循参数平均为0.5的泊松分布；当一个Node中的链表长度达到8个元素的时候，概率为0.00000006，几乎是一个不可能事件；</p><p>4）加载因子是特别重要因素，应严格限制在0.7-0.8以下。超过0.8，查表时的CPU缓存不命中（cache missing）按照指数曲线上升；</p><ul><li>为什么HashMap的长度是2的整数次幂</li></ul><p>①加快哈希计算</p><p>&lt;1>为了找打key的位置，需要进行hash(key)%length操作，但是%计算比&慢很多；</p><p>&lt;2>使用&代替%有两个条件：求&的length比%的length要减一，即hash(KEY) & (length - 1)、length需要为2的整数次幂；</p><p>&lt;3>根据&计算方法，元素哈希值不变；而通过 % 计算的方式会因为 length 的变化导致计算出来的 hash 桶的位置不断变化，数据一致在漂移，影响性能</p><p>②减少冲突</p><p>&lt;1>length 为偶数时，length-1 为奇数，奇数的二进制最后一位是 1，这样便保证了 hash &(length-1) 的最后一位可能为 0，也可能为 1，即 & 运算后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性；</p><p>&lt;2>length 为奇数时，length-1 为偶数，它的最后一位是 0，这样 hash & (length-1) 的最后一位肯定为 0，即只能为偶数，这样任何 hash 值都只会被散列到数组的偶数下标位置上，这浪费了近一半的空间；</p><ul><li>JDK8对HshMap的优化</li></ul><p>1）链表的长度超过了8，那么链表将转换为红黑树（桶的数量必须大于64，小于64的时候只会扩容）；</p><p>2）发生hash碰撞时，java 1.7会在链表的头部插入，而java 1.8会在链表的尾部插入；</p><p>3）java 1.7的Entry被java 1.8的Node替代；</p><p>4）在插入时，java 1.7先判断是否需要扩容，再插入，java 1.8先进行插入，插入完成再判断是否需要扩容；</p><ul><li>JDK1.7头插法扩容的问题</li></ul><p>1）头插法会使链表发生反转，多线程环境下会产生环；</p><p>2）A线程在插入节点B，B线程也在插入，遇到容量不够开始扩容，重新hash，放置元素，采用头插法，后遍历到的B节点放入了头部，这样形成了环；</p><div class=pgc-img><img alt=HashMap的底层实现 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa1439011e074207b97cee38fc89bc88><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'HashMap','底层','实现'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>