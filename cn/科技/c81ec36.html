<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>异步编程提升服务性能 | 极客快訊</title><meta property="og:title" content="异步编程提升服务性能 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/15260210063976700d35c2d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c81ec36.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c81ec36.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="异步编程提升服务性能"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c81ec36.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>异步编程提升服务性能</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>庞大复杂的系统通常会采用服务化组件来实现。系统越复杂，组件之间的依赖和调用关系也会越复杂。对于处于底层的基础服务，直接和间接的调用所带来的流量压力非常大。处于中间层的聚合型服务，面对的挑战则是依赖的服务太多，后端个别服务的性能延迟就会影响其吞吐量。性能优化是我们系统稳定性中的重要一环，这其中，调用所依赖的RPC服务或后端数据是重点之一。</p><p>目前，除了传统JDBC这样从API到主流驱动实现就是阻塞式的类库之外，其他常用的RPC/HTTP服务、MQ、Redis、Mongodb、Kafka等系统都提供了成熟的基于NIO的客户端库，也有相应的异步API。</p><p>但是目前交易平台的大多数中台服务系统，还在习惯性使用着这些库的同步API，并不能充分的利用CPU，这也给我们带来了一定的优化空间。从16年开始我们在一些核心的但是服务逻辑相对简单的系统中使用异步方式来实现，虽然暂时还做不到完全的异步化，但是也取得了比较好的效果。这篇文章虽然更多是一个简介性质，但是也涵盖了我们在异步编程中需要关注的要点。希望大家能够习惯和拥抱异步编程。</p><p><strong>一、相关概念介绍</strong></p><p>同步(Synchronous)/异步(Asynchronous)，通常是指函数调用中的消息通信的两种不同模式。</p><p><strong>1、异步和同步的区别</strong></p><p>函数调用发生时，消息(参数)从caller传递到callee，控制权(指令执行)从caller转移到callee。调用返回时，控制权从callee转移到caller。两者的区别在于，callee是否需要等待执行完成才将控制权转移给caller。</p><p>在RPC这种更复杂的场景下，本质上并没有不同。</p><p>◆ 同步</p><p><img alt=异步编程提升服务性能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15260210063976700d35c2d></p><p>1.callee执行完成才返回</p><p>2.返回值即结果</p><p>◆ 异步</p><p><img alt=异步编程提升服务性能 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1526021006860927b1feca3></p><p>1.callee不需要执行完成就可返回</p><p>2.caller要获取结果，需要通过轮询、回调等机制</p><p>◆ 同步RPC</p><p><img alt=异步编程提升服务性能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15260210065070b97e26186></p><p>◆ 异步RPC</p><p><img alt=异步编程提升服务性能 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152602100651271869c2752></p><p>可以看到，在异步RPC的场景下，客户端和服务端用于处理IO的CPU能得到充分利用，通常只需要远低于caller请求数量的线程就可以了，这就是多路复用。</p><p><strong>2、callee执行机制</strong></p><p>上图中callee的background execute通常是采用池化线程来完成的，比如ThreadPoolExecutor或EventLoop1。</p><p><strong>3、caller获取执行结果</strong></p><p>caller调用callee时，如果需要获取执行结果（消息双向传递），或者获知执行是否完成（消息单向传递无返回值），在异步模式下，主要依靠下面两种机制。</p><p>◆ 轮询(Polling)</p><p>比如Java的Future就提供了isDone()这种询问机制。</p><pre>1.//Caller.java2.void call() {3. Future&lt;Void&gt; f = callee.asyncCall(param);4. // do some other things5. while(true) {6. if (f.isDone()) break;7. //do some other things or sleep or timeout8. }9.}</pre><p>或阻塞版本</p><pre>1.//Caller.java2.void call() {3. Future&lt;Void&gt; f = callee.asyncCall(param);4. // do some other things5. f.get(timeout, TimeUnit.SECONDS);6.}</pre><p>轮询的控制逻辑在caller端。</p><p>◆ 回调(Callback)</p><p>caller设置一个回调函数，供callee执行完成后调用这个函数。回调的控制是反转的，通常由callee端控制。</p><pre>1.//Caller.java2.void call() {3. callee.asyncCall(param, new AsyncHandler&lt;Response&lt;Message&gt;&gt;() {4. @Override public void handleResponse(Response&lt;Message&gt; response) {5. msg = response.get();6. // process the msg...7. }8. });9. // do some other things10.}</pre><p><strong>4、异步模式的场景</strong></p><p>◆ 阻塞</p><p>阻塞(Blocking)/非阻塞(Non-Blocking)是用来描述，在等待调用结果时caller线程的状态。阻塞，通常意味着caller线程不再使用CPU时间，处于可被OS调度的状态(注意与Java线程状态2的区别)。 磁盘IO和网络IO是常见的会引起线程阻塞的场景3。受制于底层OS的同步阻塞式IO系统函数，调用Java OIO(Old blocking IO) API无疑是会阻塞的。对于DiskIO，Java NIO2提供了异步API。对于SocketIO，Java NIO2以及NIO框架Netty，都提供了异步API。</p><blockquote><p>◆ Linux提供了异步IO系统函数，只能用于DiskIO，还有一些限制4，Java NIO2 AsynchronousFileChannel内部仍然使用线程池+阻塞式API的实现。</p><p>◆ Linux为SocketIO准备就绪阶段提供了非阻塞式API(select/poll/epoll)，但是IO执行阶段仍然是同步阻塞的，因此主流的Java NIO框架的Reactor模式内部实现使用了线程池。</p></blockquote><p>◆ 并行</p><p>比如需要调用多个没有依赖关系的服务，或者访问分散在多个存储分片中的数据，如果服务接口或数据访问接口实现了异步API，那么就很方便实现并行调用，减少总体调用耗时。</p><p>◆ 速度不匹配</p><p>使用中间队列解偶caller和callee的速度不匹配问题，削峰填谷。</p><p>◆ 批量</p><p>使用中间队列解偶caller和callee的速度不匹配问题，削峰填谷。</p><p><strong>二、异步API的几种风格</strong></p><p><strong>1、Callback</strong></p><p>这个比较传统，比如zookeeper客户端提供的基于回调的异步API:</p><pre>1.try {2. zookeeper.create(path, data, acl, createMode, new StringCallback() {3. public void processResult(int rc, String path, Object ctx, String name) {4. if (rc != KeeperException.Code.OK.intValue()) {5. // error handle6. } else {7. // success process8. // 如果需要在成功后再发起基于回调的异步调用，会形成callback hell9. }10. }11. }, ctx);12.} catch( Throwable e) {13. // error handle</pre><blockquote><p>◆ Callback通常是无状态的</p><p>◆ 要获取Callback的计算结果，通常需要closure</p><p>◆ 异常处理比较分散</p><p>◆ 在有多个异步调用链的时候，容易造成Callback hell</p></blockquote><p><strong>2、Future/Promise</strong></p><p>Promise是callee给caller的凭证，代表未完成但承诺完成（成功或失败）的结果。Promise本身是有状态的，通常由callee端维护。其状态转移如下（术语参考Promise/A+和ES6）：</p><blockquote><p>Promise的状态只能转移一次，因此如果有callback，那么.then(callback)或.catch(callback)也只被执行一次。</p></blockquote><p>JDK5的Future只能用轮询或者阻塞的方式获取结果，caller端处理比较繁琐。Guava的ListenableFuture，特别是JDK8的CompletableFuture，则是完整实现了Promise风格的异步API。 个人认为Promise是更好的Callback，ListenableFuture接口只是比Future多了一个void addListener(Runnable, Executor)方法。 Promise提供了比Callback更易用更清晰的编程模式，尤其是涉及多个异步API的串行调用（chaining或pipelining )、组合调用（并行、合并）、异常处理等方面有很大的优势。</p><blockquote><p><strong>引申阅读</strong></p><p>◆ 这篇文章谈到了Future和Promise的细微区别、相关历史和技术。</p><p>◆ 这里有一些讨论：Aren’t promises just callbacks?,Is there really a fundamental difference between callbacks and Promises?。</p><p>◆ Promise借鉴了函数式中的一些概念: 从函数式编程到Promise。</p><p>◆ 这篇文章简要对比了几种语言中的Promise框架。</p></blockquote><p><strong>3、ReactiveX</strong></p><p>其官方网站的介绍</p><blockquote><p>An API for asynchronous programming with observable streams</p></blockquote><p>其关键的概念Observable比较Promise来说：</p><p>◆ Promise代表一个异步计算值，而Observable代表着一系列值(stream)。</p><p>◆ Promise的值只能产生一次，而Observable的事件可以不断产生。因此Rx首先流行在前端UI场景：事件来源多，数据变化影响多个UI组件的变更。</p><p>Rx的学习曲线比Promise要高得多，而且目前Promise风格的异步编程能够满足我们大部分的服务端开发场景，因此我们这里主要关注Promise。</p><p><strong>三、Promise在服务端的应用</strong></p><p>下面穿插着以JDK8的CompletableFuture和Guava的ListenableFuture（适用JDK6）为例介绍Promise的用法。</p><p><strong>1、符合Promise风格的方法签名</strong></p><p>Promise风格的方法签名，有个不成文的规则是不抛出异常，因为异常是Promise对象本身就能携带的两种状态之一。比如我们想把一个Callback风格的异步API包装成Promise风格的（通常在使用一个较老的类库时需要这样的包装），可以这样：</p><pre>1.//caller.java2.CompletableFuture&lt;String&gt; asyncCall(final String msg) {3. CompletableFuture&lt;String&gt; promise = new CompletableFuture&lt;&gt;();4. try {5. callee.asyncCall(msg, new Callback&lt;String&gt;() {6. public void onSuccess(String r) { promise.complete(r); }7. public void onFail(Throwable t) { promise.completeExceptionally(t); }8. });9. } catch (Throwable e) {10. promise.completeExceptionally(t);11. }12. return promise;13.}</pre><p>下面是使用ListenableFuture的实现异步发送消息的API。</p><pre>1.//LocalMessageEngine.java2.static class WriteTask {3. // SettableFuture是Guava中一种可设置状态的Promise类型。4. final SettableFuture&lt;Boolean&gt; promise = SettableFuture.create();5. final byte[] message;6. WriteTask(byte[] message) {7. this.message = message;8. }9.}10.public Producer createProducer() {11. return new Producer() {12. public ListenableFuture&lt;Boolean&gt; asyncProduce(byte[] message) {13. if (!Engine.this.started) {14. // 返回前已完成15. return Futures.immediateFailedFuture(new IllegalStateException("Message engine was stopped or not started"));16. }17.18. WriteTask task = new WriteTask(message);19. boolean queued = writeTaskQueue.offer(task);20. if (!queued) {21. task.promise.set(Boolean.FALSE);22. }23. return task.promise;24. }25. };26.}</pre><p>上面两个例子，描述了如何创建一个Promise对象返回给caller，以及如何在callee端fulfill或reject这个Promise。你可能会发现，返回给caller之前Promise是可以处于完成状态的。在继续下面的使用介绍前，先简单的看下ListenableFuture和CompletableFuture的几个主要API。</p><p><img alt=异步编程提升服务性能 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15260210065997b2aa4be68></p><p><strong>2、串行调用</strong></p><p>ListenableFuture没有提供then方法，而是通过Futures的一系列静态方法来实现Promise风格的API。由于两者有大部分的API是可以相互转化的，限于篇幅下面就不全部演示了。Promse的callback就是其then或catch方法的函数型参数，当Promise被resolve时执行这个callback函数。这个callback函数的输入，就是Promise的resolved值。根据callback函数的输出的不同，需要采取不同的then方法。</p><p>◆ callback无输出</p><p>Futures.addCallback和CompletableFuture.thenAccept接受无输出的callback。</p><pre>1.// Guava2.ListenableFuture&lt;QueryResult&gt; promise1 = ...;3.Futures.addCallback(promise1, new FutureCallback&lt;QueryResult&gt;() {4. public void onSuccess(QueryResult result) {5. storeInLocalCache(result);6. }7. public void onFailure(Throwable t) {8. reportError(t);9. }10.});</pre><pre>1.// CompletableFuture2.CompletableFuture&lt;QueryResult&gt; promise1 = ...;3.CompletableFuture&lt;Void&gt; promise2 = promise1.thenAccept(result -&gt; storeInLocalCache(result));4.return promise2;5.//return promise1.thenAccept(result -&gt; storeInLocalCache(result));//thenAccept返回另一个Promise实例</pre><p>先忽略异常处理。对比下这种场景下的ListenableFuture和CompletableFuture：前者采取了更传统的callback风格，后者则返回一个新的Promise实例，callback计算完毕则promise2被fulfilled，很容易通过promise2来获取callback执行完毕与否，不需要closure。</p><p>◆ callback输出一个普通计算值</p><p>这种情况下callback就是一个转换函数，输入是前一个Promise的fulfilled值，输出则作为新Promise的fulfilled值。Futures.transform和CompletableFuture.thenApply接收这样的callback函数。</p><pre>1.// CompletableFuture2.CompletableFuture&lt;QueryResult&gt; queryFuture = ...;3.CompletableFuture&lt;List&lt;Row&gt;&gt; rowsFuture = queryFuture.thenApply(result -&gt; result.getRows());4.return rowsFuture;</pre><p>◆ callback输出一个异步计算值，即一个Promise</p><p>乍一看，这种情况下的输出跟上一种好像没什么区别。但实际上，输出一个Promise值和输出一个普通的值有根本的区别。还记得吧，Promise代表着一个未完成的并且承诺完成的值。通常这种情况下，意味着callback里调用了另外一个Promise风格的异步API。比如下面的例子中indexService.lookUp和dataService.read方法，由于涉及到IO，都设计为异步API。</p><pre>1.//Guava2.ListenableFuture&lt;RowKey&gt; rowKeyFuture = indexService.lookUp(query);3.AsyncFunction&lt;RowKey, QueryResult&gt; queryFunction = new AsyncFunction&lt;RowKey, QueryResult&gt;() {4. public ListenableFuture&lt;QueryResult&gt; apply(RowKey rowKey) {5. return dataService.read(rowKey);6. }7.};8.ListenableFuture&lt;QueryResult&gt; queryFuture = Futures.transformAsync(rowKeyFuture, queryFunction);9.return queryFuture;</pre><p>Futures.transformAsync和CompletableFuture.thenCompose接收这样的callback函数。</p><p>设想一下，如果某个逻辑中需要调用的多个Promise风格的异步方法（比如多个RPC调用），并且有先后依赖关系，即上一个方法的执行结果作为下一个方法的输入。就可以用thenCompose把他们串起来。</p><pre>1.//CompletableFuture2.CompletableFuture&lt;RPC4Result&gt; promise4 = rpc1.call(input) //promise13. .thenCompose(rpc1Result -&gt; rpc2.call(rpc1Result)) //promise24. .thenCompose(rpc2Result -&gt; rpc3.call(rpc2Result)) //promise35. .thenCompose(rpc3Result -&gt; rpc4.call(rpc3Result)) //promise46.return promise4;</pre><p>不要被链式调用给忽悠了，你还是可以正常使用普通的风格。</p><p>单纯看来，上述的串行调用场景下使用Promise风格的API好像只是消除了Callback hell。那么采用同步API就既没有Callback hell的问题，又符合数据依赖关系。可是，你会发现，上面的举例中结尾都返回了Promise，就是说，包含这段代码的方法被设计为异步API。而使用同步API，则会强制这个方法的调用者只能使用同步方式调用。</p><p><strong>3、并行调用</strong></p><p>异步API很适合并行调用。caller在调用多个没有依赖关系的异步API时，可以先依次发起调用而不用等待每个调用真正执行完成，从callee的角度来讲，执行是并行的。caller可以对调用结果进行合并处理，关键是，合并也是异步风格的。</p><pre>1.//Guava2.List&lt;ListenableFuture&lt;QueryResult&gt;&gt; partialPromises = new ArrayList&lt;ListenableFuture&lt;QueryResult&gt;&gt;(nodes.size());3.for (Node node : nodes) {4. partialPromises.add(lookupHandler(node).query());5.}6.ListenableFuture&lt;List&lt;Row&gt;&gt; mergedPromise = Futures.transform(Futures.allAsList(partialPromises), new Function&lt;List&lt;List&lt;Row&gt;&gt;, List&lt;Row&gt;&gt;() {7. @Override public Long apply(List&lt;List&lt;Row&gt;&gt; input) {8. return merge(input);9. }10.})11.return mergedPromise;</pre><p>Futures.allAsList是并行执行所有的promises，若有一个promise异常完成则尝试reject尚未resolved的promise。也可以使用Futures.successfulAsList，区别在于后者并不会reject尚未resolved的promise。CompletableFuture的对应物是allOf和anyOf。</p><p><strong>4、调用编排</strong></p><p>合并结果设计为异步风格的好处在于，很方便做合并、串行混合调用编排，比如某个逻辑中需要调用四个个RPC服务A、B、C、D，其中：A的输出作为B、C的输入，B、C可并行，B、C的输出合并后作为D的输入。</p><pre>1.//CompletableFuture2.CompletableFuture&lt;AResult&gt; promiseA = rpcA.call(input);3.CompletableFuture&lt;DResult&gt; promiseD = promiseA.thenCompose(aResult -&gt; {4. CompletableFuture&lt;BResult&gt; promiseB = rpcB.call(aResult);5. CompletableFuture&lt;CResult&gt; promiseC = rpcC.call(aResult);6. CompletableFuture&lt;MergedResult&gt; mergedPromise = promiseB.thenCombine(promiseC, (bResult, cResult) -&gt; {7. return merge(bResult, cResult)8. });9. return mergedPromise;10.}).thenCompose(mergedResult -&gt; rpcD.call(mergedResult));11.return promiseD;</pre><p><strong>5、异常处理</strong></p><p>上面提到过Callback风格的异步API，异常处理比较分散。而Promise风格的异常处理则优雅得多。我们需要记住，异常是Promise携带的两种状态之一。那么异常可以作为callback函数的输入。</p><p>◆ 通用异常处理</p><p>Futures.catching和CompletableFuture.exceptionally接收异常值为参数的callback函数。</p><pre>1.//Guava2.ListenableFuture&lt;Integer&gt; fetchCounterPromise = ...;3.// Falling back to a zero counter in case an exception happens when4.// processing the RPC to fetch counters.5.ListenableFuture&lt;Integer&gt; faultTolerantPromise = Futures.catching(6. fetchCounterPromise, FetchException.class,7. new Function&lt;FetchException, Integer&gt;() {8. public Integer apply(FetchException e) {9. return 0;10. }11. });</pre><p>我们再看一个更复杂的例子。</p><pre>1.//CompletableFuture2.CompletableFuture&lt;FaultTolerantResult&gt; faultTolerantPromise = rpc1.call(input) //promise13. .thenCompose(rpc1Result -&gt; rpc2.call(rpc1Result)) //promise24. .thenCompose(rpc2Result -&gt; rpc3.call(rpc2Result)) //promise35. .thenCompose(rpc3Result -&gt; rpc4.call(rpc3Result)) //promise46. .exceptionally(err -&gt; {7. // process err8. return faultTolerantValue;9. }); //faultTolerantPromise10.return faultTolerantPromise;</pre><p>再提醒一遍，不要被链式调用迷惑了。这个例子里面，rpc1/rpc2/rpc3/rpc4都有可能发生异常，但我们只需要在最后统一处理（返回异常值或转换为一个默认正常值）。比如rpc2发生异常，那么rpc3/rpc4的逻辑（接收正常值的callback函数）都不会执行，但是rpc2的异常会传递给promise3/promise4。</p><p>◆ 恢复</p><p>假设在读取某个数据存储发生异常，我们需要某种恢复机制，比如读取另一个backup的数据存储（某种重试），那么可以使用Futures.cachingAsync和CompletableFuture.handle。</p><pre>1.//CompletableFuture2.public &lt;V&gt; CompletableFuture&lt;V&gt; dispatch(final Command&lt;V&gt; command) {3. final CompletableFuture&lt;V&gt; dispatched = loadbalance.selectHandler().dispatch(command);4. if (maxTries &gt; 0) {5. final AtomicInteger leftTries = new AtomicInteger(maxTries);6. final BiFunction&lt;CompletableFuture&lt;V&gt;, Throwable, CompletableFuture&lt;V&gt;&gt; fallback = new BiFunction&lt;CompletableFuture&lt;V&gt;, Throwable, CompletableFuture&lt;V&gt;&gt;() {7. @Override8. public CompletableFuture&lt;V&gt; apply(CompletableFuture&lt;V&gt; input, Throwable cause) {9. if (cause == null) return input;10. if (cause instanceof RecoverableException &amp;&amp; leftTries.getAndDecrement() &gt; 0) {11. final CompletableFuture&lt;V&gt; next = loadbalance.selectHandler().dispatch(new Command&lt;V&gt;(command.type, command.args));12. return next.handle((v, err) -&gt; err).thenCompose(err -&gt; apply(next, err));13. }14. CompletableFuture&lt;V&gt; errFuture = new CompletableFuture&lt;&gt;();15. errFuture.completeExceptionally(cause);16. return errFuture;17. }18. };19. return dispatched.handle((v, err) -&gt; err).thenCompose(err -&gt; fallback.apply(dispatched, err));20. }21. return dispatched;22.}</pre><p>◆ 超时</p><p>Promise是一个承诺完成（成功或失败）的结果，但是并不承诺完成时间。所以，通常需要一种超时机制，幸运的是ListenableFuture和CompletableFuture都实现了Future接口。</p><pre>1.CompletableFuture&lt;FaultTolerantResult&gt; faultTolerantPromise = ...;2.try {3. FaultTolerantResult result = faultTolerantPromise.get(1000, TimeUnit.SECONDS);4. // process result5.} catch (TimeoutException e) {6. //尝试取消执行尚未开始的callback函数7. faultTolerantPromise.cancel(false); 8.}</pre><p><strong>四、Promise异步编程的注意点</strong></p><p>异步编程比同步编程困难。异步编程通常主要解决一小部分问题，比如阻塞。Promise借鉴了函数式编程的风格，大量的逻辑会分散在各种callback函数来实现。因此对于习惯了同步编程的OO式或命令式编程风格的开发人员，需要一定的习惯时间。</p><p>上面谈到callee执行机制的时候，谈到了线程池，那么callee计算完成时，callback函数的执行通常是池中resolve Promise的线程执行。但是，如果caller在设置callback的时候，Promise已经完成，那么callback的执行线程则是caller线程。因此，请特别关注callback函数的执行线程的差别。请遵循：</p><p>◆ callback尽量轻量</p><p>◆ callback避免阻塞</p><p>◆ 否则请指定执行线程</p><p>如果callback执行了大量的计算，甚至执行了阻塞式操作，那么就很有可能阻塞住Promise的resolve线程，通常这类线程都是极少的，比如执行IO的EventLoop线程，有可能造成其他Promise得不到执行。</p><blockquote><p>摘自ListenableFuture的文档：</p><p>Note: For fast, lightweight listeners that would be safe to execute in any thread, consider MoreExecutors.directExecutor. Otherwise, avoid it. Heavyweight directExecutor listeners can cause problems, and these problems can be difficult to reproduce because they depend on timing. For example:</p><p>◆ The listener may be executed by the caller of addListener. That caller may be a UI thread or other latency-sensitive thread. This can harm UI responsiveness.</p><p>◆ The listener may be executed by the thread that completes this Future. That thread may be an internal system thread such as an RPC network thread. Blocking that thread may stall progress of the whole system. It may even cause a deadlock.</p><p>◆ The listener may delay other listeners, even listeners that are not themselves directExecutor listeners.</p></blockquote><p>我们也的确碰到过使用MoreExecutors.directExecutor时，由于编写了太过复杂的callback链，导致线程死锁的问题。</p><p>CompletableFuture和ListenableFuture都有指定callback执行线程的方法：</p><pre>1.//使用内置的通用ForkJoin线程池2.completableFuture.thenAcceptAsync(callback);3.//使用指定的线程执行器4.completableFuture.thenAcceptAsync(callback, executor);5.//使用指定的线程执行器6.Futures.transform(input, callback, executor);</pre><p>正因为异步编程的复杂性，因此目前我们也尽量在业务逻辑相对简单的应用上进行异步化改造。后续，我们也会评估Quasar等协程框架。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异步','编程','服务'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>