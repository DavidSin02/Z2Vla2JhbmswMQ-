<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>VC｜窗口对象句柄、指针、ID的获取及它们之间的转换 | 极客快訊</title><meta property="og:title" content="VC｜窗口对象句柄、指针、ID的获取及它们之间的转换 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/733b9485020f44f38abe82b3f7648f55"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/c926ca0e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/c926ca0e.html><meta property="article:published_time" content="2020-11-14T21:00:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:21+08:00"><meta name=Keywords content><meta name=description content="VC｜窗口对象句柄、指针、ID的获取及它们之间的转换"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/c926ca0e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>VC｜窗口对象句柄、指针、ID的获取及它们之间的转换</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>SDK的WIN32 API用句柄HANDLE操作Windows窗口，而VC将HANDLE封装为CWnd类的一个成员变量m_hWnd，可以取此对象的m_hWnd属性来得到句柄。同时，VC中每一个窗口类都可以声明为一个窗口指针来调用窗口类的成员属性和成员变量。</p><h1><strong>1 窗口</strong></h1><p>窗口是Windows应用程序中一个非常重要的元素，一个Windows应用程序至少要有一个窗口，称为主窗口，窗口是指现在是屏幕上面的一快矩形区域，是Windows应用程序与用户进行交互的接口。利用窗口，可以接收用户的输入及显示输出。</p><p>一个应用程序窗口通常包含标题栏、菜单栏、系统菜单、最小化框、最大化框、可调边框、滚动条等</p><p>窗口可以分为客户区和非客户区，客户区是窗口的一部分，应用程序通常在客户区中显示文字或绘制图形。而标题栏、菜单栏、系统菜单、最小化和最大化，可调系统边框为窗口的非客户区，他们由windows来管理，而应用程序则主要管理客户区的外观及操作。</p><p>窗口可以有一个父窗口，有父窗口的窗口称为子窗口，另外，对话框和消息框也是一种窗口，在对话框上面还包含许多子窗口，这些子窗口的形式有按钮、单选按钮、复选框、组框、文本编辑框等。</p><p>此外，在我们启动Windows系统后，我们的桌面也是一个窗口，称为桌面窗口，是位于最上层的窗口，由Windows系统创建和管理。</p><h1><strong>2 窗口句柄</strong></h1><p>当用你CreateWindow创建了一个窗口，这个窗口其实并不是你创建的，而是系统替你的创建的，系统为创建这个窗口，它必须要保留很多的和这个窗口相关的数据，这些数据并不是给你用的，而是系统用来维护窗口用的，而句柄就是系统用来找到这个窗口相关数据的一人索引。你向一个API提供一个句柄，比如ShowWindow（HWND）；要显示这个窗口，这个工作还是系统替你做的，它根据你提供的索引，也就是句柄，找到窗口，然后进行相关的处理。所以说，句柄是相关对象的唯一索引。从这一点上看，有点像指针，但是指针的内容是对象的地址，而句柄并不是地址，句柄只是一个索引，一个整数。</p><blockquote><p>句柄的实质就是一个结构体的实例。</p><p>Windows系统中有许多内核对象（这里的对象不完全等价于"面向对象程序设计"一词中的"对象"，虽然实质上还真差不多），比如打开的文件，创建的线程，程序的窗口，等等。这些重要的对象肯定不是4个字节或者8个字节足以完全描述的，他们拥有大量的属性。为了保存这样一个"对象"的状态，往往需要上百甚至上千字节的内存空间，那么怎么在程序间或程序内部的子过程（函数）之间传递这些数据呢？拖着这成百上千的字节拷贝来拷贝去吗？显然会浪费效率。那么怎么办？当然传递这些对象的首地址是一个办法，但这至少有两个缺点：</p><p>I 暴露了内核对象本身，使得程序（而不是操作系统内核）也可以任意地修改对象地内部状态（首地址都知道了，还有什么不能改的？），这显然是操作系统内核所不允许的；</p><p>II 操作系统有定期整理内存的责任，如果一些内存整理过一次后，对象被搬走了怎么办？</p><p>所以，Windows操作系统就采用进一步的间接：在进程的地址空间中设一张表，表里头专门保存一些编号和由这个编号对应一个地址，而由那个地址去引用实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射而已。</p><p>在Windows系统中，这个编号就叫做"句柄"。</p></blockquote><p>在Windows应用程序中，窗口是通过句柄HWND来标识的，我们要对某个窗口进行操作，首先就要获取到这个窗口的句柄。</p><p>每个窗口在被创建出来之后就会被赋予一个句柄，该句柄指向一个数据结构体，结构体里明确表示着该窗口的各种信息，窗口大小，窗口名等，当我们得到这个句柄时就可以请求操作系统对它做一系列操作，列如：移动窗口，关闭窗口，最小化最大化等，这些都是通过窗口句柄来告诉操作系统的，我们要对哪个窗口进行操作，而消息则是告诉操作系统要做什么样的操作，消息的附加参数就是操作值，列如移动窗口，会有附加的xy座标参数！</p><blockquote><p>句柄有Windows句柄，文件句柄，分配内存句柄，图形句柄等，系统在创建这次资源的时候回为其分配内存，并返回标识这些资源的标识号，这个标识号就是句柄，实际上，我们可以将句柄看做是指针。</p><p>在使用句柄之前，必须先创建他们，当不在使用时，应当及时销毁，如果不销毁他们，最终将到时资源泄露，资源泄露有可能导致系统崩溃，所以，务必确保在适当的时候销毁不在使用的句柄。</p><p>另外，程序运行时也是以进程存在，进程也是用ID或句柄去标识。</p><p>进程创建时，windows系统为进程构造了一个句柄表。当该进程希望获得一个内核对象句柄或者创建一个内核对象从而获得该对象句柄时。系统会将在句柄表中增加一个表项，表项的内容中存储了指向目标内核对象的指针。同时，系统返回这个表项在句柄表中的索引作为句柄。这样，进程就通过句柄查询句柄表得到对象指针，从而可以访问该对象。同时又由于有了句柄表的保护，可以防止对内核对象的非法操作。</p></blockquote><h1><strong>3 Windows对象和MFC对象的区别</strong></h1><p>windows对象并不是我们平时所说的“面向对象”程序设计中的“类的对象”，而是一种windows资源实体，如画笔、字体等。</p><p>如果想要去使用这些windows对象我们需要用句柄来标识它们。</p><p>而MFC对象则是真正的“面向对象”思想中的“类的对象”(必须用构造函数去创建)。</p><p>在windows编程中，除了普通的“类的对象”外，用得最多的“C++类的对象”应该是MFC对象了（如果你是用MFC编程的话），</p><p>MFC对象是指“封装了windows对象的C++对象”（也就是MFC对象中有一个控制window对象的控制器，那么控制器想工作就得和一个window对象链接起来，这样就能控制器就能控制这个对象了）。</p><blockquote><p>所谓Windows对象是Win32下用句柄表示的Windows操作系统对象；</p><p>所谓MFC对象就是C++对象，是一个C++类的实例.</p><p>一个MFC窗口对象是一个C++ CWnd类（或派生类）的实例，是程序直接创建的。</p><p>在程序执行中它随着窗口类构造函数的调用而生成，随着析构函数的调用而消失。</p><p>而Windows窗口则是Windows系统的一个内部数据结构的实例，由一个“窗口句柄”标识，Windows系统创建它并给它分配系统资源。</p></blockquote><p>Windows窗口在MFC窗口对象创建之后，由CWnd类的Create成员函数创建，“窗口句柄”保存在MFC窗口对象的m_hWnd成员变量中。</p><p>Windows窗口可以被一个程序销毁，也可以被用户的动作销毁。</p><p>MFC中的窗口类，就是C++类与Windows窗口的句柄的结合。在基于CWnd继承而来的所有类中，都有一个公有的成员变量m_hWnd，这个成员变量就是窗口对象关联的windows窗口句柄。我们在类中可以直接使用这个窗口句柄成员变量。这个窗口对象就是标准的C++对象。其实MFC窗口类并不神奇，就是包装了一下API而已。<strong>m_hWnd的类型就是HWND</strong>。 MFC给CWnd提供了两个成员函数Attach(HWND hWndNew )和Detach()。前者传入一个窗口句柄，<strong>将该窗口关联到C++对象</strong>，后者则是将当前关联的窗口解关联。而关联就是给m_hWnd赋值，解关联就是将m_hWnd设置为NULL。解关联后，窗口对象就不关联任何窗口了，此时就不能执行窗口相关的任何操作，都会失败。如果要关联新的窗口，只要执行Attach函数即可。</p><h1><strong>4 对话框控件消息响应函数中可以直接调用的函数</strong></h1><p>4.1 MFC全局函数，如：</p><blockquote><p>AfxMessageBox 显示一个消息框</p><p>AfxGetApp 返回应用程序对象CWinApp的一个指针</p><p>AfxGetAppName 返回应用程序的名称</p><p>AfxInitRichEdit 为应用程序初始化RichEdit控件</p></blockquote><p>4.2 API函数，如：</p><blockquote><p>SendMessage()，调用一个窗口的窗口函数，将一条消息发给那个窗口；</p><p>OpenFile() 这个函数能执行大量不同的文件操作；</p><p>RegCreateKey() 在指定的项下创建或打开一个项；</p><p>GetCaretPos() 判断插入符的当前位置；</p><p>ShellExecute() 用指定程序打开指定路径下的文件；</p></blockquote><p>4.3 其父类定义的成员函数，如CWnd类：</p><blockquote><p>PreSubclassWindow()</p><p>在调用SubclassWindow之前，允许其它必要的子类化工作</p><p>FromHandle()</p><p>当给定一个窗口的句柄时，返回CWnd对象的指针。如果没有CWnd对象与这个句柄相连接，则创建一个临时的CWnd对象并与之相连接</p><p>GetSafeHwnd</p><p>返回m_hWnd，如果该指针为NULL，则返回NULL</p><p>etFocus()</p><p>要求输入焦点</p><p>SetWindowPos()</p><p>改变子窗口、弹出窗口和顶层窗口的大小、位置以及顺序</p><p>GetClientRect</p><p>获得CWnd客户区域的大小</p><p>GetDlgItem()，</p><p>获得指定的对话框中具有指定ID的控件</p><p>UpdateData()</p><p>初始化对话框或获得对话框中的数据</p><p>SetWindowText()</p><p>将窗口的文本或标题文字（如果有）设为指定的文本</p><p>SetWindowText</p><p>将窗口的文本或标题文字（如果有）设为指定的文本</p><p>SetTimer()</p><p>安装一个系统定时器，当它被激活时，发送一个WM_TIMER消息</p><p>MessageBox()</p><p>创建并显示一个窗口，其中包含了应用程序提供的消息和标题</p><p>SendMessage()</p><p>向CWnd对象发送一个消息，直到这条消息被处理之后才返回</p><p>OnPaint()</p><p>调用这个函数以重画窗口的一部分</p><p>OnLButtonDown()</p><p>当用户按下鼠标左键时调用这个函数</p><p>OnTimer()</p><p>当达到SetTimer指定的时间间隔时调用这个函数</p></blockquote><div class=pgc-img><img alt=VC｜窗口对象句柄、指针、ID的获取及它们之间的转换 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/733b9485020f44f38abe82b3f7648f55><p class=pgc-img-caption></p></div><p>4.4 继承关系不同的GetDlgItem()</p><pre>1) CWindow::GetDlgItemHWND GetDlgItem(int nID)const;2) CWnd::GetDlgItemCWnd* GetDlgItem(int nID) const;void CWnd::GetDlgItem( int nID, HWND *phWnd) const;3）Windows SDKHWND GetDlgItem(HWND hDlg,int nIDDlgItem);</pre><h1><strong>5 窗口句柄和指针使用的场合</strong></h1><p>先看下面的两行代码，简单了解一下窗口句柄和指针的一个使用场合：</p><p>5.1 API函数以句柄为参数</p><pre>CString str = "在编辑框上显示给定文本。";SendMessage(GetActiveWindow()-&gt;GetDlgItem(IDC_textbox)-&gt;m_hWnd, WM_SETTEXT , 0 , (LPARAM)str.GetBuffer(0));</pre><p>此代码可以在当前活动窗口的IDC_textbox文本框控件中显示一个字符串str。</p><p>① API函数SendMessage()功能： 将指定的消息发送到一个或多个窗口。</p><p>LRESULT SendMessage（HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam）</p><blockquote><p>hWnd：其窗口程序将接收消息的窗口的句柄。如果此参数为HWND_BROADCAST，则消息将被发送到系统中所有顶层窗口，包括无效或不可见的非自身拥有的窗口、被覆盖的窗口和弹出式窗口，但消息不被发送到子窗口。</p><p>Msg：指定被发送的消息。</p><p>wParam：指定附加的消息特定信息。</p><p>IParam：指定附加的消息特定信息。</p><p>返回值：指定消息处理的结果，依赖于所发送的消息。</p></blockquote><p>② CWnd类方法GetDlgItem(IDC_textbox)，能够返回一个MFC指针*CWnd；</p><p>③ CWnd类方法GetActiveWindow()，可以返回当前窗口的一个HWND句柄；</p><p>④ “->m_hWnd”是将一个指针转换为句柄。一般窗口对象都会有一个其对应的句柄变量，所以我们可以取此对象的m_hWnd属性来得到句柄。</p><p>5.2 MFC对象指针调用成员函数</p><p>下面的的代码也是在编辑框上显示给定文件：</p><pre>CString str = "在编辑框上显示给定文本。";CEdit *edit1=(CEdit*)GetDlgItem(IDC_EDIT2);edit1-&gt;SetWindowText(str);</pre><p>GetDlgItem()可以返回一个MFC指针*CWnd，并用(CEdit*)做了下类型转换，然后就可以使用CEdit类的成员函数，例如SetWindowText()。</p><p>5.3 API函数使用句柄作为参数</p><pre>CString str = "F:\\help\\list.html";API函数ShellExecute(this-&gt;m_hWnd, "open", str,"", NULL, SW_SHOW);	</pre><p>this->m_hWnd; //返回的就是窗口类自己的句柄呢，也可以用MFC全局函数：</p><p>AfxGetMainWnd()->m_hWnd;</p><h1><strong>6 窗口ID和指针</strong></h1><p>对MFC编程来说，对话框和控件都可以理解为一个子窗口，都有对应的一个ID和类。可以返回对应的对象指针。</p><h1><strong>7 获得窗口句柄的方法</strong></h1><p>HWND <strong>FindWindow</strong>(LPCTSTR lpClassName, LPCTSTR lpWindowName)</p><p>HWND <strong>FindWindowEx</strong>(HWND hwndParent, HWND hwndChildAfter,LPCTSTR lpClassName, LPCTSTR lpWindowName)</p><p>HWND <strong>WindowFromPoint</strong>(POINT& Point)//获得当前鼠标光标位置的窗口HWND</p><p>在任何类中获得应用程序类</p><p>HWND AfxGetInstanceHandle()</p><p>获取当前活动窗口句柄</p><p>HWND GetActiveWindow(VOID)</p><p>获取前台窗口句柄</p><p>HWND GetForegroundWindow( void );</p><p>获得对话框中某控件的句柄</p><p>HWND GetDlgItem(m_hDLG,m_nID_DlgItem);</p><p>获得GDI对象的句柄</p><p>HWND m_hGDIObj = m_pGDIObj->GetSafeHanle();</p><h1>8 获取窗口指针的办法</h1><p>① 获取当前应用进程的指针</p><p>AfxGetApp();</p><p>② 获得主框架窗口指针(任何时候都可以用，只要是MFC程序中)</p><p>CWnd* pWnd = AfxGetMainWnd();</p><p>③ 获得对话框中控件指针</p><p>CWnd* pWnd = GetDlgItem(IDC_xxx);</p><p>可以强制转换为具体类型，如CEdit *edit1 = (*CEdit)GetDlgItem(IDC_xxx);</p><p>④ 获得工具栏指针</p><p>CToolBar * pToolBar=(CtoolBar*)AfxGetMainWnd()->GetDescendantWindow(AFX_IDW_TOOLBAR);</p><h1><strong>9 窗口、控件的指针和句柄的相互转化</strong></h1><p>① 指针转化为句柄</p><p>在MFC应用程序中首先要获得窗口的指针，然后将其转化为句柄</p><pre>CWnd *pwnd = FindWindow(“ExploreWClass”,NULL); //希望找到资源管理器HWND hwnd = pwnd-&gt;m_hwnd; //得到它的HWND</pre><p>这样的代码当开始得到的pwnd为空的时候就会出现一个“General protection error”,并关闭应用程序，因为一般不能对一个NULL指针访问其成员，如果用下面的代码：</p><pre>CWnd *pwnd = FindWindow(“ExploreWClass”,NULL); //希望找到资源管理器HWND hwnd = pwnd-&gt;GetSafeHwnd(); //得到它的HWND</pre><p>就不会出现问题，因为尽管当pwnd是NULL时，GetSafeHwnd仍然可以用，只是返回NULL</p><p>② 句柄转化为指针</p><p>在MFC应用程序中首先用GetDlgItem()获得对话框控件的句柄，然后获得其指针：</p><pre>HANDLE hWnd;GetDlgItem(IDC_xxx,&amp;hWnd);CWnd *pWnd=CWnd::FromHandle(hWnd);pWnd-&gt;Attach(hWnd); //Attaches a Windows to a CWnd object</pre><p>// 用FindWindow()得到一个窗口句柄，然后转换为容器指针</p><pre>HWND hWnd=::FindWindow(NULL,_T("IDD_Assistants")); //得到对话框的句柄CAssistantsDialog* pWnd= (CAssistantsDialog*)CAssistantsDialog::FromHandle(hWnd); //由句柄得到对话框的对象指针pWnd- &gt;xxx( ); //调用C***Dialog中的函数xxx();</pre><h1>10 <strong>窗口、控件的指针和句柄与其ID的相互转化</strong></h1><p>ID->句柄，hWnd = ::GetDlgItem(hParentWnd,id);</p><p>ID->指针，CWnd::GetDlgItem();</p><p>句柄->ID，id = GetWindowLong(hWnd,GWL_ID);</p><p>指针->ID，id = GetWindowLong(pWnd->GetSafeHwnd,GWL_ID);</p><p>HICON->ID，HICON hIcon = AfxGetApp()->LoadIcon(nIconID);</p><p>ID->HICON，HICON hIcon = LoadIcon(AfxGetApp()->m_hInstance, MAKEINTRESOURCE(nIconID));</p><p>-End-</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'句柄','VC','对象'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>