<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>渗透测试——内存攻击原理 | 极客快訊</title><meta property="og:title" content="渗透测试——内存攻击原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ae687b82fd824bafafb7c6792c260a98"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca0627f9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca0627f9.html><meta property="article:published_time" content="2020-11-14T21:05:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:09+08:00"><meta name=Keywords content><meta name=description content="渗透测试——内存攻击原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ca0627f9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>渗透测试——内存攻击原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>什么是内存攻击</strong></h1><p><strong>内存攻击</strong>指的是攻击者利用软件安全漏洞，构造恶意输入导致软件在处理输入数据时出现非预期错误，将输入数据写入内存中的某些特定敏感位置，从而劫持软件控制流，转而执行外部输入的指令代码，造成目标系统被获取远程控制或拒绝服务。</p><p>内存攻击的<strong>表面原因</strong>是软件编写错误，诸如过滤输入的条件设置缺陷、变量类型转换错误、逻辑判断错误、指针引用错误等；但究其<strong>根本原因</strong>，是现代电子计算机在实现图灵机模型时，<strong>没有在内存中严格区分数据和指令</strong>，这就存在外部输入数据成为指令代码从而被执行的可能。任何操作系统级别的防护措施都不可能完全根除现代计算机体系结构上的这个弊端，只能试图去阻止攻击者利用 (Exploit)。</p><h1><strong>缓冲区溢出漏洞机理</strong></h1><p><strong>缓冲区溢出</strong> (Buffer Overflow 或 Buffer Overrun) 漏洞是程序由于缺乏对缓冲区边界条件检查而引起的一种异常行为。通常是程序向缓冲区中写数据，但内容超过了程序员设定的缓冲区边界，从而覆盖了相邻的内存区域，造成覆盖程序中的其他变量甚至影响控制流的敏感数据，造成程序的非预期行为。而 C 和 C++ 语言由于缺乏内在安全的内存分配与管理机制，因此很容易导致缓冲区溢出的相关问题。</p><p>如下图：内存中保存了相邻的两个变量。A 是 char[] 字符串类型，作为缓冲区用于存储外部输入的字符串，长度为 8 字节；而变量 B 是短整数型。</p><p>在程序执行时，某指令向 A 中写入了长度大于 8 的字符串，越过了 A 的边界覆盖了 B 中的内容，造成变量 B 的值被修改。如：写入的字符串是 “abcdefghi”，长度为 9，加上结束符 “\0” 之后将修改 B 的值，从原先的 65535 修改为 0x0069 (十六进制)，即105。</p><div class=pgc-img><img alt=渗透测试——内存攻击原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae687b82fd824bafafb7c6792c260a98><p class=pgc-img-caption></p></div><p>一般根据缓冲区溢出的内存位置不同，将缓冲区溢出又分为 <strong>栈溢出 (Stack Overflow)</strong> 与 <strong>堆溢出 (Heap Overflow)</strong>。</p><h1><strong>栈溢出利用原理</strong></h1><p>程序执行过程中的栈，是由操作系统创建和维护的，同时也支持了程序内的函数调用功能。在进行函数调用时，程序会将返回地址压入栈中，而执行完被调用的函数代码后，则会通过 ret 指令从栈中弹出返回地址，装载到 EIP 指令寄存器，从而继续程序运行。</p><p>然而这种将<strong>控制程序流程的敏感数据与程序变量同时保存在同一段内存空间</strong>中的冯诺依曼体系，必然会给缓冲区溢出攻击带来本质上的可行性。</p><p>栈溢出发生在程序向位于栈中的内存地址写数据时，当<strong>写入的数据长度超过栈分配给缓冲区的空间</strong>时，就会造成栈溢出。从栈溢出的原理出发，攻击者可以找到如下三种方式来利用这种类型的漏洞：</p><ul><li><strong>覆盖缓冲区附近的程序变量</strong>：改变程序的执行流程和结果</li><li><strong>覆盖栈中保存的函数返回地址</strong>：修改为攻击者指定的地址，当程序返回时，程序流程将跳转到攻击者指定地址，理想情况下可以执行任意代码</li><li><strong>覆盖某个函数指针或程序异常处理结构</strong>：只要溢出之后目标函数或异常处理例程被执行，同样可以让程序流程跳转到任意地址</li></ul><p>而其中最常见的利用方式就是覆盖栈中的函数返回地址。</p><p><strong>1. 覆盖函数返回地址利用方式</strong></p><p>函数调用是程序中最常见的命令，程序调用函数时，程序流程将暂时转到被调用的函数，函数执行完之后再跳转回原来的位置，所以在执行调用函数前需要保存下一跳指令的地址，让程序在执行完函数调用后能够从这个指令地址处继续执行。若程序将该函数返回地址和函数的调用参数、局部变量异同保存在栈中，这就给了攻击者溢出栈缓冲区从而达到修改函数返回地址的机会。</p><p><strong>栈溢出代码示例：</strong></p><pre>#inclide &lt;string.h&gt;void foo(char *bar){	char c[8];	strcpy(c, bar);	//没有进行边界检查，从而存在栈溢出漏洞}int main(){	char array[] = "ABCDABCDABCD18FF1800"	foo(array);	//调用函数	return 0;}</pre><p>主程序执行了一次对自定义函数 foo 的调用，在子函数中执行了一次字符串复制操作 (strcpy)，执行结果是字符串 array 中的内容被复制到局部变量字符串 c 中。</p><p>编译执行这一段代码，当调用 strcpy 函数时，进程栈布局如下图左侧所示，从地地址到高地址分别是未分配的栈内存空间、局部变量字符串 c 分配的空间、进入子函数时自动保存的 EBP 寄存器值、返回地址、调用自定义函数 foo 的参数、父函数栈空间。执行 strcpy 函数之后的栈布局如下图右侧所示，上述代码中，源字符串 array 中的16 个字符将复制到 c 中，其中最后 4 个字符覆盖了栈中返回地址，该为字符串 c 的起始地址 0x0018FF18。所以当函数 foo 返回时，程序就会跳转到该地址处，将字符串中的数据作为指令执行。因此，如果攻击者可以控制源字符串，那么他就可以将其替换为 Shellcode 并复制到栈中，然后利用该漏洞执行 Shellcode。</p><div class=pgc-img><img alt=渗透测试——内存攻击原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01ccf458c7c74ee2933bae9e694a41ed><p class=pgc-img-caption></p></div><p>由于程序每次运行时，栈中变量的地址都会发生变化，即上述字符串 c 在栈中位置往往不固定，所以一般会通过一些跳转寄存器的指令作为跳板，使得程序能够执行到栈中的 Shellcode。最常见的是以 JMP ESP 的地址来覆盖返回地址，从而使得程序执行该指令之后重新跳转回栈中，来执行缓冲区溢出之后的数据。</p><p><strong>2. 覆盖异常处理结构利用方式</strong></p><p>程序在运行过程中可能会发生一些异常，比如除 0 计算、访问无效内存地址等，此时就需要正常指令序列之外的代码处理这些异常。Windows 提供结构化异常处理机制 SEH，可以利用程序自定义的异常处理函数或者操作系统默认的处理函数处理异常。异常处理结构以<strong>链表</strong>形式春促在栈中，寄存器 FS 指向当前活动线程的 TEB (线程环境块) 结构。结构体有两个 DWORD (双字变量，4字节) 类型的变量：</p><ul><li>指向下一异常处理结构体的指针</li><li>异常处理函数 SEH 例程的地址</li></ul><p>程序在执行生产指令序列出现异常时，会由异常处理过程接管，操作系统从链表头到尾寻找能处理此异常的函数，由找到的第一个函数进行处理。如果没有任何合适的处理函数，则由最后一个函数即系统默认的处理函数来负责处理，通常弹出错误对话框，强制关闭程序。</p><p>栈溢出之后覆盖异常处理结构的利用方式，就是<strong>用特定地址覆盖栈中异常处理结构体中的异常处理函数指针，并处罚异常，导致去加载篡改之后的处理函数指针。</strong></p><p>覆盖异常处理结构的栈溢出利用方式，与覆盖栈中函数返回地址利用方式并没有本质区别。一般来说，异常处理结构接近栈底，所以从缓冲区头部到异常处理结构之间的内存空间很大，利用起来可能更方便。最关键的是，有时缓冲区溢出之后到程序执行到函数返回之前就不可避免地处罚异常，这种情况下，就必须使用覆盖异常处理结构的利用方式，于此同时，这种利用方式也可以绕过操作系统的栈保护机制。</p><h1><strong>堆溢出利用原理</strong></h1><p>不同于栈，堆是程序运行时<strong>动态分配</strong>的内存，用户通过 malloc、new 等函数申请内存，通过返回的起始地址指针对分配的内存进行操作，使用完后要通过 free、delete 等函数释放这部分内存，否则会造成内存泄露。对的操作分为分配、释放、合并三种。因为堆在内存中位置不固定，大小比较自由，多次申请、释放后可能会更加凌乱，系统从性能、空间利用率还有越来越受到重视的安全角度出发，来管理堆，具体实现比较复杂。只简介最常见的<strong>空闲块堆操作引起的缓冲区溢出</strong>。</p><p>系统根据大小不同维护一系列的堆块，如下图所示：堆块分为块首和数据区，其中空闲堆块数据区的前两个双字 (DWORD) 分别是<strong>双向链表</strong>的两个指针。通常同样大小的空闲堆块通过双向链表连接在一起，分配与释放堆，分别对应插入与删除双向链表节点的操作，而合并则会同时进行着两种操作。空闲堆块中两个指针 “Previous block” 和 “Next block”，分别指向双向链表中此堆块的前后两个堆块的数据部分。分配一个堆块时，将分配堆块从空闲堆块双链表中删除，会有如下所示的操作：</p><div class=pgc-img><img alt=渗透测试——内存攻击原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/99a4d339ecc64c049c37bcfba3c4b97d><p class=pgc-img-caption></p></div><p>同一个堆中的堆块在内存中通常是连续的，由此可能发生的状况是：在向一个已分配堆块中写入数据时，由于数据长度超出了该堆块的大小，导致数据溢出覆盖堆块后方 (高地址处) 的相邻空闲堆块，而包含的两个堆块指针 (即 Previous block 和 Next block) 会被覆盖。</p><p>假设有空闲堆块 *p，则 p->previous 是指向双向链表中的 p 的前一堆块的前向指针，p->next 是后向指针。若 p 的两个堆块指针被覆盖，即 <strong>p->previous = X</strong>，<strong>p->next = Y</strong>。如果这个空闲堆块被分配出去，需要将这个节点从空闲堆块链表中删除，那么分配过程中的 DeleteBlock 函数 (上述函数) 就会将 p 下一个空闲的前向指针 (p->next->previous)指向 p 之前的空闲块前向指针 (p->previous)。需要注意的是：<strong>每个堆块指针指向的就是堆块的 Previous block</strong>。所以 p->next->previous 相当于对 Y 进行解引用，即 *Y，因此执行的效果就是 *Y=X。从而<strong>可以利用超长数据覆盖空闲堆块的这两个指针，达到向 Y 指向的任意地址处写入 X 包含的任意内容的目的。</strong></p><p>涉及内存链表操作的堆内存分配、释放、合并操作都可能实现这一效果，即向攻击者任意指定地址写入 4 字节的任意内容，业内人士称之为 “arbitrary DWORD reset” 或者 “DWORD shoot” 攻击。在得到一个将指定内存地址改写为任意值的机会后，攻击者可以写出利用的程序，用于覆盖内存堆中的一些函数指针地址、C++ 类对象虚函数表、GOT 全局偏移表入口地址或者 DTORS 地址等，而改写的值就是指向内存中的 Shellcode 的地址。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'渗透','测试','内存'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>