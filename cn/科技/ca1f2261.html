<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>经常用 HashMap？这 6 个问题回答下 | 极客快訊</title><meta property="og:title" content="经常用 HashMap？这 6 个问题回答下 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RacA10eJBQSfiV"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca1f2261.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca1f2261.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="经常用 HashMap？这 6 个问题回答下"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ca1f2261.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>经常用 HashMap？这 6 个问题回答下</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>一、HashMap的实现原理 ?</strong></p><p>此题可以组成如下连环炮来问</p><ul><li><p>你看过HashMap源码嘛，知道原理嘛?</p></li><li><p>为什么用数组+链表？</p></li><li><p>hash冲突你还知道哪些解决办法？</p></li><li><p>我用LinkedL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t代替数组结构可以么?</p></li><li><p>既然是可以的,为什么HashMap不用LinkedL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t,而选用数组?</p></li></ul><p></p><h3><strong>1. 你看过HashMap源码嘛，知道原理嘛?</strong></h3><p>针对这个问题，嗯，当然是必须看过HashMap源码。至于原理，下面那张图很清楚了:</p><img alt="经常用 HashMap？这 6 个问题回答下" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RacA10eJBQSfiV><p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。</p><p>只是在JDK1.8中，链表长度大于8的时候，链表会转成红黑树！</p><p></p><h3><strong>2. 为什么用数组+链表？</strong></h3><p>数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到.</p><p>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。ps:这里的hash值并不是指hashcode，而是将hashcode高低十六位异或过的。至于为什么要这么做，继续往下看。</p><p></p><h3><strong>3.hash冲突你还知道哪些解决办法？</strong></h3><p>比较出名的有四种(1)开放定址法(2)链地址法(3)再哈希法(4)公共溢出区域法</p><p>ps:大家有兴趣拓展的，自己去<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-6">搜一下</i>就懂了，这个就不拓展了！</p><p></p><h3><strong>4.我用LinkedL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t代替数组结构可以么?</strong></h3><p>这里我稍微说明一下，此题的意思是，源码中是这样的</p><pre><pre><code>Entry table = new Entry[capacity];</code></pre></pre><p>ps：Entry就是一个链表节点。</p><p>那我用下面这样表示</p><pre><pre><code>L<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t&lt;Entry&gt; table = new LinkedL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t&lt;Entry&gt;;</code></pre></pre><p>是否可行?</p><p>答案很明显，必须是可以的。</p><p></p><h3><strong>5.既然是可以的,为什么HashMap不用LinkedL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t,而选用数组?</strong></h3><p>因为用数组效率最高！</p><p>在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t大。</p><p>那ArrayL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t，底层也是数组，查找也快啊，为啥不用ArrayL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t?</p><p>(烟哥写到这里的时候，不禁觉得自己真有想法，自己把自己问死了，还好我灵机一动想出了答案)</p><p>因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。</p><p>而ArrayL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t的扩容机制是1.5倍扩容，那ArrayL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t为什么是1.5倍扩容这就不在本文说明了。</p><p></p><h2><strong>二、HashMap在什么条件下扩容?</strong></h2><p>此题可以组成如下连环炮来问</p><ul><li><p>HashMap在什么条件下扩容?</p></li><li><p>为什么扩容是2的n次幂?</p></li><li><p>为什么为什么要先高16位异或低16位再取模运算?</p></li></ul><p></p><h3><strong>1. HashMap在什么条件下扩容?</strong></h3><p>如果bucket满了(超过load factor*current capacity)，就要resize。</p><p>load factor为0.75，为了最大程度避免哈希冲突</p><p>current capacity为当前数组大小。</p><p></p><h3><strong>2. 为什么扩容是2的次幂?</strong></h3><p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length。</p><p>但是，大家都知道这种运算不如位移运算快。</p><p>因此，源码中做了优化hash&(length-1)。</p><p>也就是说hash%length==hash&(length-1)</p><p>那为什么是2的n次方呢？</p><p>因为2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1。</p><p>例如长度为8时候，3&(8-1)=3 2&(8-1)=2 ，不同位置上，不碰撞。</p><p>而长度为5的时候，3&(5-1)=0 2&(5-1)=0，都在0上，出现碰撞了。</p><p>所以，保证容积是2的n次方，是为了保证在做(length-1)的时候，每一位都能&1 ，也就是和1111……1111111进行与运算。</p><p></p><h3><strong>3.为什么为什么要先高16位异或低16位再取模运算?</strong></h3><p>我先晒一下，jdk1.8里的hash方法。1.7的比较复杂，咱就不看了。</p><img alt="经常用 HashMap？这 6 个问题回答下" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RacA10yEXgBKoq><p>hashmap这么做，只是为了降低hash冲突的机率。</p><p>打个比方，当我们的length为16的时候，哈希码(字符串“abcabcabcabcabc”的key对应的哈希码)对(16-1)与操作，对于多个key生成的hashCode，只要哈希码的后4位为0，不论不论高位怎么变化，最终的结果均为0。</p><p>如下图所示</p><img alt="经常用 HashMap？这 6 个问题回答下" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RacA11DDIB36at><p>而<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">加上</i>高16位异或低16位的“扰动函数”后，结果如下</p><img alt="经常用 HashMap？这 6 个问题回答下" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RacA11T2UV6xJP><p>可以看到: 扰动函数优化前：1954974080 % 16 = 1954974080 & (16 - 1) = 0 扰动函数优化后：1955003654 % 16 = 1955003654 & (16 - 1) = 6 很显然，减少了碰撞的机率。</p><p></p><h2><strong>三、讲讲hashmap的get/put的过程?</strong></h2><p>此题可以组成如下连环炮来问</p><ul><li><p>知道hashmap中put元素的过程是什么样么?</p></li><li><p>知道hashmap中get元素的过程是什么样么？</p></li><li><p>你还知道哪些hash算法？</p></li><li><p>说说String中hashcode的实现?(此题很多大厂问过)</p></li></ul><p></p><h3><strong>1. 知道hashmap中put元素的过程是什么样么?</strong></h3><p>对key的hashCode做hash运算，计算index;</p><p>如果没碰撞直接放到bucket里；</p><p>如果碰撞了，以链表的形式存在buckets后；</p><p>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树(JDK1.8中的改动)；</p><p>如果节点已经存在就替换old value(保证key的唯一性)</p><p>如果bucket满了(超过load factor*current capacity)，就要resize。</p><p></p><h3><strong>2. 知道hashmap中get元素的过程是什么样么?</strong></h3><p>对key的hashCode做hash运算，计算index;</p><p>如果在bucket里的第一个节点里直接命中，则直接返回；</p><p>如果有冲突，则通过key.equals(k)去查找对应的Entry;</p><ul><li><p>若为树，则在树中通过key.equals(k)查找，O(logn)；</p><br></li><li><p>若为链表，则在链表中通过key.equals(k)查找，O(n)。</p></li></ul><p></p><h3><strong>3. 你还知道哪些hash算法？</strong></h3><p>先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。</p><p>比较出名的有MurmurHash、MD4、MD5等等</p><p></p><h3><strong>4. 说说String中hashcode的实现?(此题频率很高)</strong></h3><pre><pre><code>public int hashCode {</code><code> int h = hash;</code><code> if (h == 0 &amp;&amp; value.length &gt; 0) {</code><code> char val = value;</code><code> for (int i = 0; i &lt; value.length; i++) { // 欢迎<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">关注</i><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">微信</i><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">公众号</i> Web项目聚集地 </code><code> h = 31 * h + val[i];</code><code> }</code><code> hash = h;</code><code> }</code><code> return h;</code><code>}</code></pre></pre><p>String类中的hashCode计算方法还是比较简单的，就是以31为权，每一位为字符的ASCII值进行运算，用自然溢出来等效取模。</p><p>哈希计算公式可以计为<strong>s[0]31^(n-1) + s[1]31^(n-2) + … + s[n-1]</strong></p><p>那为什么以31为质数呢?</p><p>主要是因为31是一个奇质数，所以31*i=32*i-i=(i&lt;&lt;5)-i，这种位移与减法<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">结合</i>的计算相比一般的运算快很多。</p><p></p><h2><strong>四、为什么hashmap的在链表元素数量超过8时改为红黑树?</strong></h2><p>此题可以组成如下连环炮来问</p><ul><li><p>知道jdk1.8中hashmap改了啥么?</p></li><li><p>为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?</p></li><li><p>我不用红黑树，用二叉查找树可以么?</p></li><li><p>那为什么阀值是8呢?</p></li><li><p>当链表转为红黑树后，什么时候退化为链表?</p></li></ul><p></p><h3><strong>1. 知道jdk1.8中hashmap改了啥么?</strong></h3><ul><li><p>由<strong>数组+链表</strong>的结构改为<strong>数组+链表+红黑树</strong>。</p></li><li><p>优化了高位运算的hash算法：h^(h>>>16)</p></li><li><p>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</p></li></ul><p>最后一条是重点，因为最后一条的变动，hashmap在1.8中，不会在出现死循环问题。</p><p></p><h3><strong>2. 为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树?</strong></h3><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。</p><p>当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。</p><p>因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><p></p><h3><strong>3. 我不用红黑树，用二叉查找树可以么?</strong></h3><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><p></p><h3><strong>4. 那为什么阀值是8呢?</strong></h3><p>不知道，等jdk作者来回答。</p><p>这道题，网上能找到的答案都是扯淡。</p><p>我随便贴一个牛客网的答案，如下图所示</p><img alt="经常用 HashMap？这 6 个问题回答下" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RacA11jG1xJsLC><p>看出bug没？交点是6.<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">64</i>？交点分明是4，好么。</p><p>log4=2，4/2=2。</p><p>jdk作者选择8，一定经过了严格的运算，觉得在长度为8的时候，与其保证链表结构的查找开销，不如转换为红黑树，改为维持其平衡开销。</p><p></p><h3><strong>5. 当链表转为红黑树后，什么时候退化为链表?</strong></h3><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><p></p><h2><strong>五、HashMap的并发问题?</strong></h2><p>此题可以组成如下连环炮来问</p><ul><li><p>HashMap在并发编程环境下有什么问题啊?</p></li><li><p>在jdk1.8中还有这些问题么?</p></li><li><p>你一般怎么解决这些问题的？</p></li></ul><p>HashMap在并发编程环境下有什么问题啊?</p><ul><li><p>(1)多线程扩容，引起的死循环问题</p></li><li><p>(2)多线程put的时候可能导致元素丢失</p></li><li><p>(3)put非元素后get出来的却是</p></li></ul><p>在jdk1.8中还有这些问题么?</p><p>在jdk1.8中，死循环问题已经解决。其他两个问题还是存在。</p><p>你一般怎么解决这些问题的？</p><p>比如ConcurrentHashmap，Hashtable等线程安全等集合类。</p><p></p><h2><strong>六、你一般用什么作为HashMap的key?</strong></h2><p>此题可以组成如下连环炮来问</p><ul><li><p>健可以为值么?</p></li><li><p>你一般用什么作为HashMap的key?</p></li><li><p>我用可变类当HashMap的key有什么问题?</p></li><li><p>如果让你实现一个自定义的class作为HashMap的key该如何实现？</p></li></ul><p></p><h3><strong>1. 健可以为值么?</strong></h3><p>必须可以，key为的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</p><img alt="经常用 HashMap？这 6 个问题回答下" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RacA1RJ1ZMnqOx><p></p><h3><strong>2. 你一般用什么作为HashMap的key?</strong></h3><p>一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</p><p>(1)因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。</p><p>这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。</p><p>这就是HashMap中的键往往都使用字符串。</p><p>(2)因为获取对象的时候要用到equals和hashCode方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode以及equals方法。</p><p></p><h3><strong>3. 我用可变类当HashMap的key有什么问题?</strong></h3><p>hashcode可能发生改变，导致put进去的值，无法get出，如下所示</p><pre><pre><code>HashMap&lt;L<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;;</code><code>L<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t&lt;String&gt; l<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t = new ArrayL<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t&lt;&gt;;</code><code>l<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t.add("hello");</code><code>Object objectValue = new Object;</code><code>changeMap.put(l<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t, objectValue);</code><code>System.out.println(changeMap.get(l<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t));</code><code>l<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t.add("hello world");//hashcode发生了改变 </code><code>System.out.println(changeMap.get(l<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>t));</code></pre></pre><p>输出值如下</p><pre><pre><code>java.lang.Object@74a14482</code></pre></pre><p></p><h3><strong>4.如果让你实现一个自定义的class作为HashMap的key该如何实现？</strong></h3><p>此题考察两个知识点</p><ul><li><p>重写hashcode和equals方法注意什么?</p></li><li><p>如何设计一个不变类</p></li></ul><p>针对问题一，记住下面四个原则即可</p><p>(1)两个对象相等，hashcode一定相等</p><p>(2)两个对象不等，hashcode不一定不等</p><p>(3)hashcode相等，两个对象不一定相等</p><p>(4)hashcode不等，两个对象一定不等</p><p>针对问题二，记住如何写一个不可变类</p><p>(1)类添加final修饰符，保证类不被继承。</p><p>如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。</p><p>(2)保证所有成员变量必须私有，并且<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">加上</i>final修饰</p><p>通过这种方式保证成员变量不可改变。但只做到这一步还不够，因为如果是对象成员变量有可能再外部改变其值。所以第4点弥补这个不足。</p><p>(3)不提供改变成员变量的方法，包括setter</p><p>避免通过其他接口改变成员变量的值，破坏不可变特性。</p><p>(4)通过构造器初始化所有成员，进行深拷贝(deep copy)</p><p>如果构造器传入的对象直接赋值给成员变量，还是可以通过对传入对象的修改进而导致改变内部变量的值。例如：</p><pre><pre><code>public final class ImmutableDemo { </code><code> private final int myArray; </code><code> public ImmutableDemo(int[] array) { </code><code> th<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>.myArray = array; // wrong。 欢迎<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">关注</i><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">微信</i><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-4">公众号</i> Web项目聚集地 </code><code> } </code><code>}</code></pre></pre><p>这种方式不能保证不可变性，myArray和array指向同一块内存地址，用户可以在ImmutableDemo之外通过修改array对象的值来改变myArray内部的值。</p><p>为了保证内部的值不被修改，可以采用深度copy来创建一个新内存保存传入的值。正确做法：</p><pre><pre><code>public final class MyImmutableDemo { </code><code> private final int myArray; </code><code> public MyImmutableDemo(int[] array) { </code><code> th<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">is</i>.myArray = array.clone;</code><code> } </code><code>}</code></pre></pre><p>(5) 在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝</p><p>这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。</p><p>本文章由Web项目聚集地(<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-5">id：</i>web_resource)排版整理，转载文章请联系原作者，使用排版请著名出处。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'HashMap','问题','常用'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>