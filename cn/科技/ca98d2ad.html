<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java后端精选技术：Spring框架简介 | 极客快訊</title><meta property="og:title" content="Java后端精选技术：Spring框架简介 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/620bc0cc7a034056bbea96274d000c01"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ca98d2ad.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ca98d2ad.html><meta property="article:published_time" content="2020-10-29T21:12:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:37+08:00"><meta name=Keywords content><meta name=description content="Java后端精选技术：Spring框架简介"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ca98d2ad.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java后端精选技术：Spring框架简介</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify><strong>1、使用框架的意义与Spring的主要内容</strong></p><p class=ql-align-justify>随着软件结构的日益庞大，软件模块化趋势出现，软件开发也需要多人合作，随即分工出现。如何划分模块，如何定义接口方便分工成为软件工程设计中越来越关注的问题。良好的模块化具有以下优势：可扩展、易验证、易维护、易分工、易理解、代码复用。</p><p class=ql-align-justify>优良的模块设计往往遵守“低耦合高内聚”的原则。而“框架”是对开发中良好设计的总结，把设计中经常使用的代码独立出来，所形成的一种软件工具。用户遵守它的开发规则，就可以实现良好的模块化，避免软件开发中潜在的问题。广义上的框架无处不再，一个常见的例子就是PC硬件体系结构，人们只要按照各自需要的主板、显卡、内存等器件就可以任意组装成自己想要的电脑。而做主板的厂商不用关心做显卡厂商的怎么实现它的功能。软件框架也是如此，开发人员只要在Spring框架中填充自己的业务逻辑就能完成一个模块划分清晰纷的系统。</p><p class=ql-align-justify>这里主要通过一个银行通知用户月收支记录的小例子来介绍轻型J2EE框架Spring的主要内容、它所解决的问题和实现的方法。</p><p class=ql-align-justify><strong>Spring框架主要可以分为3个核心内容：</strong></p><ol><li class=ql-align-justify>容器</li><li class=ql-align-justify>控制反转（IoC ，Inversion of Control）</li><li class=ql-align-justify>面向切面编程（AOP ，Aspect-Oriented Programming）</li></ol><p class=ql-align-justify>例子中依次对这些特性进行介绍，描述了软件模块化后存在的依赖与问题，以及Spring框架如何解决这些问题。</p><p class=ql-align-justify><strong>2、一个简单的例子程序</strong></p><p class=ql-align-justify>假设有一个如下应用场景：（1）一个银行在每月的月初都需要向客户发送上个月的账单，账单发送的方式可以为纸质邮寄、或者短信方式。（2）还有一个潜在的需求：为了安全起见，在每个函数操作过程中都需要记录日志，记录参数传入是否正常，函数是否正常结束，以便出错时系统管理员查账。</p><p class=ql-align-justify>那么对这个需求进行简单实现。系统框图如下所示：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/620bc0cc7a034056bbea96274d000c01><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>首先定义一个账单输出的接口：</p><pre>//接口public interface ReportGenerator{ public void generate(String[][] table) ;}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>实现“打印纸质账单”与“发送短信”两个具体功能：</p><pre>//账单报表实现类 public class PageReportGenerator implement ReportGenerator { public void generate(String[][] table) { log4j.info( ... ); //输出日志  ...打印操作，以便工作人员邮递给客户 log4j.info( ... ); //输出日志  } }</pre><p class=ql-align-justify><br></p><pre>//短信报表实现类 public class SMSReportGenerator implement ReportGenerator { public void generate(String[][] table) { log4j.info( ... ); ...短信发送操作 log4j.info( ... ); }}</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>上层业务逻辑对上个月的账目进行统计并调用接口产生纸质或者短信结果：</p><pre>//上层业务中的服务类 public class ReportService{  private ReportGenerator reportGenerator = new SMSReportGenerator();  public void generateMonthlyReport(int year, int month) {  log4j.info( ... );  String[][] statistics = null ;  ...  reportGenerator.generate(statistics);  }}</pre><blockquote>这个实现源代码请查看文章结尾附录中的"BankOld"。源代码中与例子中程序略有区别：由于使用log4j需要引用外部的包，并且需要写配置文件，为了方便，源代码中的日志输出用system.out.println()代替。</blockquote><p class=ql-align-justify><strong>3、Spring中的容器</strong></p><p class=ql-align-justify><strong>A、模块化后出现的问题与隐患</strong></p><p class=ql-align-justify>假设随着工程的复杂化，上面的例子需要分成两个模块，以便开发时分工，一般会以如下结构划分：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18a3014cb90c4ebcadd035935b990d6f><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>划分后再看原来的代码：</p><pre>//上层业务中的服务类 public class ReportService{  private ReportGenerator reportGenerator = new SMSReportGenerator(); //隐患  public void generateMonthlyReport(int year, int month) {  ...  } }</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>在服务类有private ReportGenerator reportGenerator = new SMSReportGenerator();这么一行代码，ReportService类与SMSReportGenerator类不属于同一个模块，当开发人员B对内部实现进行修改时，由于存在依赖，开发人员A也要进行修改（比如之前喜欢短信收账单的客户感觉短信不够详细，希望以后改用邮件收账单，那么开发人员B需要实现一个MailReportGenerator类，在开发人员B修改代码时，开发人员A也需要改代码------声明部分修改）。如果系统庞大new</p><p class=ql-align-justify>SMSReportGenerator()大量使用的话，修改就会十分复杂，一个声明没有修改就会出现大的BUG。</p><p class=ql-align-justify>所以需要一种划分，让各个模块尽可能独立，当开发人员B修改自己的模块时，开发人员A不需要修改任何代码。</p><p class=ql-align-justify><strong>B、问题出现的原因</strong></p><p class=ql-align-justify>为例子中的程序画一个UML依赖图：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b60df4ddb3574646a63b79b5859126a8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>可以发现上述问题出现的原因主要是：模块A与模块B不但存在接口依赖，还存在实现依赖。ReportGenerator每次修改它的实现，都会对ReportService产生影响。那么需要重构消除这种实现依赖。</p><p class=ql-align-justify><strong>C、用容器解决问题</strong></p><p class=ql-align-justify>消除实现依赖一般可以通过添加一个容器类来解决。在例子程序容器代码如下：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8fbec70a2cb149f2aacdccf93fc2dd79><p class=pgc-img-caption></p></div><p>使用容器后，模块A的ReportService的属性实现方法也发生了变化。</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0b284eb051e74c24906ff678dd04d2ff><p class=pgc-img-caption></p></div><p class=ql-align-justify>这样的话，class都在容器中实现，使用者只需要在容器中查找需要的实例，开发人员修改模块B后（在模块中增加邮件报表生成类MailReportGenerator），只需要在容器类中修改声明（把ReportGenertor</p><p class=ql-align-justify>reportGenertor = new SMSReportGenertor();改为ReportGenertor reportGenertor = new</p><p class=ql-align-justify>MailReportGenertor();）即可，模块A不需要修改任何代码。一定程度上降低了模块之间的耦合。</p><p class=ql-align-justify><strong>4、Spring中的控制反转</strong></p><p class=ql-align-justify><strong>A、还存在的耦合</strong></p><p class=ql-align-justify>使用容器后模块A与模块B之间的耦合减少了，但是通过UML依赖图可以看出模块A开始依赖于容器类：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fb09dc1aaf2b44718b40c9e7638765ee><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>之前的模块A对模块B的实现依赖通过容器进行传递，在程序中用(ReportGenerator) Container.instance.getComponent(“reportGenerator”)的方法取得容器中SMSReportGenertor的实例，这种用字符(“reportGenerator”)指代具体实现类SMSReportGenertor 的方式并没有完全的解决耦合。所以在银行账单的例子中我们需要消除ReportService对容器Container的依赖。</p><p class=ql-align-justify><strong>B、控制反转与依赖注入</strong></p><p class=ql-align-justify>在我们常规的思维中，ReportService需要初始化它的属性private ReportGenerator reportGenerator就必须进行主动搜索需要的外部资源。不使用容器时，它需要找到SMSReportGenertor()的构造函数；当使用容器时需要知道SMSReportGenertor实例在容器中的命名。无论怎么封装，这种主动查找外部资源的行为都必须知道如何获得资源，也就是肯定存在一种或强或弱的依赖。那是否存在一种方式，让ReportService不再主动初始化reportGenerator，被动的接受推送的资源?</p><p class=ql-align-justify>这种反转资源获取方向的思想被称为控制反转（IoC，Inversion of Control），使用控制反转后，容器主动地将资源推送给需要资源的类（或称为bean）ReportService，而ReportService需要做的只是用一种合适的方式接受资源。控制反转的具体实现过程用到了依赖注入（DI，Dependecncy Injection）的设计模式，ReportService类接受资源的方式有多种，其中一种就是在类中定义一个setter方法，让容器将匹配的资源注入：setter的写法如下：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8346f8ec08754777941f357984b546b2><p class=pgc-img-caption></p></div><p>在容器中把依赖注入：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d47788162baf4cd98472e7833e4e819c><p class=pgc-img-caption></p></div><p class=ql-align-justify>这样一来ReportService就不用管SMSReportGenertor在容器中是什么名字，模块A对于模块B只有接口依赖，做到了松耦合。</p><p class=ql-align-justify><strong>C、Spring IoC容器的XML配置</strong></p><p class=ql-align-justify>每个使用Spring框架的工程都会用到容器与控制反转，为了代码复用，Spring把通用的代码独立出来形成了自己的IoC容器供开发者使用：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/155c5f1f071e4621ac38b285918a80ec><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>与上面例子中实现的容器相比，Spring框架提供的IoC容器要远远复杂的多，但用户不用关心Spring</p><p class=ql-align-justify>IoC容器的代码实现，Spring提供了一种简便的bean依赖关系配置方式------使用XML文件，在上面的例子中，配置依赖关系只要在工程根目录下的“application.xml”编辑如下内容：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/459fd7e5ce9341b4a94c96db3e138dd8><p class=pgc-img-caption></p></div><p class=ql-align-justify>&lt;?xml version="1.0" encoding="UTF-8"?>是标准的XML头，xmlns引用的是一些命名空间，两个一般在工程中自动生成。后面的内容由用户输入，主要表示实例化SMSReportGenerator，实例化ReportService并把SMSReportGenerator的对象smsReportGenerator赋值给ReportService的属性reportGenerator，完成依赖注入。</p><p class=ql-align-justify><strong>5、Spring中的面向切面编程</strong></p><p class=ql-align-justify><strong>A、日志问题以及延伸</strong></p><p class=ql-align-justify>在例子的需求中有一条是：需要记录日志，以便出错时系统管理员查账。回顾例子中的代码，在每个方法中都加了日志操作：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1a8bf3856943432c89424baa5a2b3f8d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d18f1c2d67a4252b35fc03cee3e682e><p class=pgc-img-caption></p></div><p class=ql-align-justify>可以看出在每个方法的开始与结尾都调用了日志输出，这种零散的日志操作存在着一些隐患，会导致维护的困难。比如日志输出的格式发送了变化，那么无论模块A还是模块B的程序员都要对每个方法每个输出逐条修改，极容易遗漏，造成日志输出风格的不一致。又比如不用Log4j日志输出工具更换其他工具，如果遗漏一个将会出现严重BUG。</p><p class=ql-align-justify>与日志输出相似的问题在编程中经常遇到，这种跨越好几个模块的功能和需求被称为横切关注点，典型的有日志、验证、事务管理等。</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/318232eebef146e2b947d41949f092c2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>横切关注点容易导致代码混乱、代码分散的问题。而如何将很切关注点模块化是本节的重点。</p><p class=ql-align-justify></p><p class=ql-align-justify><strong>B、代理模式</strong></p><p class=ql-align-justify>传统的面向对象方法很难实现很切关注点的模块化。一般的实现方式是使用设计模式中的代理模式。代理模式的原理是使用一个代理将对象包装起来，这个代理对象就取代了原有对象，任何对原对象的调用都首先经过代理，代理可以完成一些额外的任务，所以代理模式能够实现横切关注点。</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc38e9752da94b689f71965434377994><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>可能在有些程序中有很多横切关注点，那么只需要在代理外再加几层代理即可。以银行账单为例介绍一个种用Java Reflection API动态代理实现的横切关注点模块化方法。系统提供了一个InvocationHandler接口：</p><pre>//系统提供的代理接口 public interface InvocationHandler {  public Object invoke(Object proxy, Method method, Object[] args) throw Throwable; }</pre><p class=ql-align-justify><br></p><p class=ql-align-justify>我们需要实现这个接口来创建一个日志代理，实现代码如下：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/578c7d20bbb24198bebfed0bb6ebc051><p class=pgc-img-caption></p></div><p>这样既可以使得日志操作不再零散分布于各个模块，易于管理。调用者可以通过如下方式调用：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/732aaa71eefb405f97190b41b26f6d6b><p class=pgc-img-caption></p></div><p class=ql-align-justify>代理模式很好的实现了横切关注点的模块化，解决了代码混乱代码分散问题，但是我们可以看出用 Java Reflection API 实现的动态代理结构十分复杂，不易理解，Spring框架利用了代理模式的思想，提出了一种基于JAVA注解（Annotation）和XML配置的面向切面编程方法（AOP ，Aspect-Oriented Programming）简化了编程过程。</p><p class=ql-align-justify><strong>C、Spring AOP 使用方法</strong></p><p class=ql-align-justify>Spring AOP使用中需要为横切关注点（有些时候也叫切面）实现一个类，银行账单的例子中，切面的实现如下：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a754d1bd2f594cb38e5d40f349815912><p class=pgc-img-caption></p></div><p class=ql-align-justify>注解1表示这个类是一个切面，注解2中" * *.*(..)* "是一个通配符，表示在容器中所有类里有参数的方法。@Before(“execution(* *.*(..))”)表示在所有类里有参数的方法前调用切面中德 LogBefore() 方法。同理，注解3中@After(“execution(* *.*(..))”)表示在所有类里有参数的方法执行完后调用切面中的LogAfter()方法。</p><p class=ql-align-justify>实现完切面类后，还需要对Spring工程中的application.xml进行配置以便实现完整的动态代理：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4c2d2a5247c646288cdb2d2f16ca5345><p class=pgc-img-caption></p></div><p class=ql-align-justify>这比之前IoC依赖关系配置的XML文件多了：xmlns:aop=http://www.springframework.org/schema/aop；http://www.springframework.org/schema/aop；http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</p><p class=ql-align-justify>这3个主要是声明XML中用于AOP的一些标签， &lt;bean class="bank.LogAspect" /> 是在容器中声明LogAspect切面，&lt;aop:aspectj-autoproxy />用于自动关联很切关注点（LogAspect）与核心关注点（SMSReportGenerator，ReportService）。不难发现Spring AOP的方法实现横切关注点得模块化要比用Java Reflection API简单很多。</p><p class=ql-align-justify><strong>6、Spring总结</strong></p><p class=ql-align-justify>银行月账单报表例子通过使用Spring框架后变成了如下结构：</p><div class=pgc-img><img alt=Java后端精选技术：Spring框架简介 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/137f1cb5bdd248a78ab55e5dbc2deaf8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>在Spring框架的基础上原来存在耦合的程序被分成松耦合的三个模块。无论那个模块修改，对其他模块不需要额外改动。这就完成了一种良好的架构，使软件易理解，模块分工明确，为软件的扩展、验证、维护、分工提供了良好基础。这就是Spring框架作用。当然Spring除了容器、控制反转、面向切面之外还有许多其他功能，但都是在这三个核心基础上实现的。</p><blockquote>原文地址：https://dwz.cn/jjyn15fQ作者： Day</blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','精选技术','Spring'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>