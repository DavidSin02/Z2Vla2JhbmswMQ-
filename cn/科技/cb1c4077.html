<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法设计之分治策略 | 极客快訊</title><meta property="og:title" content="算法设计之分治策略 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/15394979629303da8548ffa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb1c4077.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb1c4077.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="算法设计之分治策略"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cb1c4077.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法设计之分治策略</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>算法</h1><p>算法(Algorithm)是一系列解决问题的清晰指令。通过算法我们可以高效的解决一些复杂的问题。算法对于程序员十分重要，如果你不懂算法，那么你只能是半生都是普通程序员，而能够熟练掌握算法的人才是晋升的对象，才是在编程世界里游刃有余的人。李开复先生也说过：“算法是计算机科学领域最重要的基石之一，但却受到了国内一些程序员的冷落。许多学生看到一些公司在招聘时要求的编程语言五花八门就产生了一种误解，认为学计算机就是学各种编程语言，或者认为，学习最新的语言、技术、标准就是最好的铺路方法。其实大家都被这些公司误导了。编程语言虽然该学，但是学习计算机算法和理论更重要，因为计算机算法和理论更重要，因为计算机语言和开发平台日新月异，但万变不离其宗的是那些算法和理论，例如数据结构、算法、编译原理、计算机体系结构、关系型数据库原理等等。在“开复学生网”上，有位同学生动地把这些基础课程比拟为“内功”，把新的语言、技术、标准比拟为“外功”。整天赶时髦的人最后只懂得招式，没有功力，是不可能成为高手的。”所以我们可以看出算法，数据结构等等是有多么重要，要想在计算机界吃上一口热饭，就必须要掌握算法。至少我们要掌握最基本的算法，如分治法，贪婪算法，回溯法，动态规划等等。现在我们就初步了解一下算法之一的分治策略。</p><p>学过编程的肯定听说过查找中的二分法，排序中的归并法，快速排序，这些都是蕴含有分治思想的算法。</p><h1>分治法的基本思想</h1><p>分治法的基本思想：</p><p>1.大问题分解为子问题，这些子问题互相独立且与原问题相同。</p><p>2.分别求解子问题。如果子问题的规模不够小，那就再继续往下划分，一直划分下去，直到问题的规模足够小，很容易求出问题的解为止。</p><p>3.合并解，自底向上求出原来问题的解。</p><p>分治法的设计思想就是：将一个难以解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>分治法的适用条件：</p><p>1.问题的规模缩小到一定程度就可以很容易地解决；</p><p>2.问题具有最有子结构，当问题的最优解包含其子问题的最优解时，称该问题就有最优子结构性质；</p><p>3.分解出来的问题能够合并成该问题的解；</p><p>4.问题所分解出来的各个子问题是相互独立的，即子问题之间不包含公共的子问题。</p><p>如果各个子问题不是独立的，使用分治法要重复的解很多公共子问题，此时不如使用动态规划。</p><h1>分治法的应用</h1><p><strong>二分搜索算法：</strong></p><p>在一个按升序排序的数组a1，a2，a3......，an，判定某个给定元素x是否在数组中出现，并找出位置。</p><p>对于这个问题最简单明了的办法就是将数组遍历一遍，依次对比是否相等。这种方法是最常用的方法，我们可以直到这种方法的时间复杂度为O（n）；然而如果使用二分法，时间复杂度就会大大降低。</p><p>二分法的思路就是，先让x和数组中间的数比较如果x比较大，那么与之相等的数肯定在数组后半段，然后让x再和后半段的中间数比较，进而可以确定x在更小的区间里，再取此区间的中间数比较，这样循环就可以找到与x相等的数。这样我们可以思考一下此算法的时间复杂度，假设最坏情况下我们查找了k个数，数组总共有n个数，那么可以知道2的k次方等于n，所以k等于log（n），以2为底，所以时间复杂度为log（n），其中log以2为底。</p><p>二分法的代码</p><div class=pgc-img><img alt=算法设计之分治策略 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15394979629303da8548ffa><p class=pgc-img-caption>c++实现二分法</p></div><p>上述程序输出结果为4。</p><p><strong>归并排序：</strong></p><p>归并排序是将待排序的元素分成大小大致相等的2个子集合；分别对2个子集合进行排序（递归）；最终将排好序的子集合合并成为所要求的排好序的集合。</p><div class=pgc-img><img alt=算法设计之分治策略 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539498610661996b60dbd3><p class=pgc-img-caption>归并排序的主要流程</p></div><p>归并排序的算法描述：</p><pre>#include&lt;iostream&gt;using namespace std;void merge_sort(int[],int ,int);void merge(int[],int ,int ,int );int main(){	int a[9]={9,8,7,6,5,4,3,2,1};	merge_sort(a,0,8); for(int i=0;i&lt;9;i++) { 	cout&lt;&lt;a[i];	} }  void merge_sort(int data[],int left,int right) { 	if(left&lt;right) 	{ 		int mid=(left+right)/2; 		merge_sort(data,left,mid);//递归  		merge_sort(data,mid+1,right);//递归  		merge(data,left,mid,right);//对数组进行排序 	 } } void merge(int array[],int p,int q,int r) { 	int i,k;int begin1,begin2,end1,end2;//begin1，end1，begin2，end2，分别为第一个序列的起始点，结束点，第二个序列的起始点，结束点  	int *temp=new int[r-p+1];//temp用来存放合并后的序列；  	begin1=p;end1=q;begin2=q+1;end2=r; 	k=0; 	while(begin1&lt;=end1&amp;&amp;begin2&lt;=end2) 	{ 		if(array[begin1]&lt;array[begin2]) 		{ 			temp[k]=array[begin1];begin1++;		 }		 else {		 	temp[k]=array[begin2];begin2++;		 }		 k++;	 } 	while(begin1&lt;=end1)//如果第一个序列有剩余，则放在序列尾部  	{ 		temp[k]=array[begin1]; 		begin1++;k++;	 }	 while(begin2&lt;=end2)//如果第二个序列有剩余则放在尾部  	{ 		temp[k]=array[begin2]; 		begin2++;k++;	 }	 for(int i=0;i&lt;r-p+1;i++)//将合并后的序列temp赋值给array 	 {	 	array[p+i]=temp[i];	 }	 delete [](temp);//释放temp的内存  </pre><p>此程序输出结果为123456789。可以看到其中使用了递归。</p><p>复杂度上为O（nlogn）。这种方法相比于堆排序和快速排序的最大特点是它是一种稳定的排序方法。</p><p><strong>快速排序：</strong></p><p>快速排序是对冒泡排序的改进算法。冒泡排序就是依次遍历整个数组，找出最大的放在最后一位，然后再遍历，把次大的放在倒数第二位，就这样遍历n-1遍才能把n个数排好序。其时间复杂度为（n*n）。而快速排序则要比冒泡排序更加高效快速。其基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都要比另外一部分的所有数据小，然后再按此方法对这两部分分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>总结为一点就是挖坑填数。</p><p>快速排序步骤：</p><p>1.设置两个变量left=0，right=N-1.</p><p>2.以第0个数为基准，作为一个坑。</p><p>3.从后向前找比坑小的数，right开始减小，找到后交换两者的位置，此时坑就到了被找到的数的位置，</p><p>4.从前向后找比坑大的数，left开始增大，找到后并交换位置，此时坑又到了前边。</p><p>5.重复3.4.步骤直到left和right相碰。</p><pre>代码：int main(){	int array[9]={9,8,7,6,5,4,3,2,1};	quicksort(array,0,8);	for(int i=0;i&lt;9;i++)	{		cout&lt;&lt;array[i];	}}void quicksort(int number[],int left,int right){	int q;	if(left&lt;right)	{		q=partition(number,left,right);//将数组分成两部分，并返回作为基准的数的位置。 		quicksort(number,left,q-1);//对左半部分进行递归； 		quicksort(number,q+1,right);//对右半部分进行递归 	}}int partition(int a[],int left,int right){	int i=left;	int j=right;	int s=a[i];	while(i&lt;j)	{		while(i&lt;j&amp;&amp;a[j]&gt;=s)j--;		if(i&lt;j) a[i]=a[j];		while(i&lt;j&amp;&amp;a[i]&lt;=s)i++;		if(i&lt;j) a[j]=a[i];	}	a[i]=s;	return i;}</pre><p>快速排序的时间复杂度为O(n*logn)，要优于冒泡排序。快速排序是很重要的排序方法。</p><p>许多问题都可以通过分治法进行解决，通过分治和递归的结合，能够大大简化问题的思考量和复杂度。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'设计','分治','算法'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>