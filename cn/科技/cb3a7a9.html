<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Kali Linux 秘籍之BASH+Ping轻松搞定跨三层网络自动IP存活检测 | 极客快訊</title><meta property="og:title" content="Kali Linux 秘籍之BASH+Ping轻松搞定跨三层网络自动IP存活检测 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/15279909101092ffdd61501"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cb3a7a9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cb3a7a9.html><meta property="article:published_time" content="2020-10-29T20:54:13+08:00"><meta property="article:modified_time" content="2020-10-29T20:54:13+08:00"><meta name=Keywords content><meta name=description content="Kali Linux 秘籍之BASH+Ping轻松搞定跨三层网络自动IP存活检测"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cb3a7a9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Kali Linux 秘籍之BASH+Ping轻松搞定跨三层网络自动IP存活检测</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="Kali Linux 秘籍之BASH+Ping轻松搞定跨三层网络自动IP存活检测" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15279909101092ffdd61501><p class=pgc-img-caption></p></div><p><strong>本秘籍简介：</strong></p><p>第三层的发现可能是网络管理员和技术人员中最常用的工具。 第三层的发现使用著名的ICMP ping 来识别活动主机。 此秘籍演示了如何使用ping 工具在远程主机上执行第三层发现。</p><p><strong>准备</strong></p><p>使用ping 执行第三层发现不需要实验环境，因为Internet 上的许多系统都将回复ICMP 回显请求。 但是，强烈建议你只在您自己的实验环境中执行任何类型的网络扫描，除非你完全熟悉您受到任何管理机构施加的法律法规。 如果你希望在实验环境中执行此技术，你需要至少有一个响应ICMP 请求的系统。</p><p><strong>操作步骤</strong></p><p>大多数在IT 行业工作的人都相当熟悉ping 工具。 要使用ping 确定主机是否处于活动状态，你只需要向命令传递参数来定义要测试的IP 地址：</p><blockquote><p>root@kali:~# ping 172.16.155.1</p><p>PING 172.16.155.1 (172.16.155.1) 56(84) bytes of data.</p><p>64 bytes from 172.16.155.1: icmp_seq=1 ttl=64 time=0.209 ms</p><p>64 bytes from 172.16.155.1: icmp_seq=2 ttl=64 time=0.230 ms</p><p>64 bytes from 172.16.155.1: icmp_seq=3 ttl=64 time=0.351 ms</p><p>^C</p><p>--- 172.16.155.1 ping statistics ---</p><p>3 packets transmitted, 3 received, 0% packet loss, time 2055ms</p><p>rtt min/avg/max/mdev = 0.209/0.263/0.351/0.063 ms</p></blockquote><p>发出此命令时，ICMP 回显请求将直接发送到提供的IP 地址。 为了接收对此ICMP回显请求的回复，必须满足几个条件。 这些条件如下：测试的IP 地址必须分配给系统系统必须处于活动状态并在线必须存在从扫描系统到目标IP 的可用路由系统必须配置为响应ICMP 流量扫描系统和配置为丢弃ICMP 流量的目标IP 之间没有基于主机或网络防火墙你可以看到， 有很多变量成为ICMP 发现的成功因素。 正是由于这个原因，ICMP可能有点不可靠，但与ARP 不同，它是一个可路由的协议，可用于发现局域网外的主机。 请注意，在前面的示例中，在ping 命令显示的输出中出现^ C 。 这表示使用了转义序列（具体来说，Ctrl + C ）来停止进程。 与Windows 不同，默认情况下，集成到Linux 操作系统的ping 命令会无限ping 目标主机。 但是，-c 选项可用于指定要发送的ICMP 请求数。 使用此选项，一旦达到超时或每个发送的数据包的回复已接收，过程将正常结束。 看看下面的命令：</p><blockquote><p>root@kali:~# ping 172.16.155.1 -c 2</p><p>PING 172.16.155.1 (172.16.155.1) 56(84) bytes of data.</p><p>64 bytes from 172.16.155.1: icmp_seq=1 ttl=64 time=0.342 ms</p><p>64 bytes from 172.16.155.1: icmp_seq=2 ttl=64 time=0.147 ms</p><p>--- 172.16.155.1 ping statistics ---</p><p>2 packets transmitted, 2 received, 0% packet loss, time 1009ms</p><p>rtt min/avg/max/mdev = 0.147/0.244/0.342/0.098 ms</p></blockquote><p>与ARPing 相同的方式可以在bash 脚本中使用，通过并行地循环遍历多个IP，ping 可以与bash 脚本结合使用，来在多个主机上并行执行第三层发现。 为了编写脚本，我们需要确定与成功和失败的ping 请求相关的各种响应。 为此，我们应该首先ping 一个我们知道它活动并响应ICMP 的主机，然后使用ping 请求跟踪一个无响应的地址。 以下命令演示了这一点：</p><blockquote><p>root@kali:~# ping 172.16.155.1 -c 1</p><p>PING 172.16.155.1 (172.16.155.1) 56(84) bytes of data.</p><p>64 bytes from 172.16.155.1: icmp_seq=1 ttl=64 time=0.403 ms</p><p>--- 172.16.155.1 ping statistics ---</p><p>1 packets transmitted, 1 received, 0% packet loss, time 0ms</p><p>rtt min/avg/max/mdev = 0.403/0.403/0.403/0.000 ms</p><p>root@kali:~# ping 172.16.155.100 -c 1</p><p>PING 172.16.155.100 (172.16.155.100) 56(84) bytes of data.</p><p>From 172.16.155.150 icmp_seq=1 Destination Host Unreachable</p><p>--- 172.16.155.100 ping statistics ---</p><p>1 packets transmitted, 0 received, +1 errors, 100% packet loss, time 0ms</p></blockquote><p>与ARPing 请求一样，来自唯一字符串的字节只存在在与活动IP 地址相关的输出中，并且也位于包含此地址的行上。 使用同样的方式，我们可以使用grep 和cut 的组合,从任何成功的ping 请求中提取IP 地址：</p><blockquote><p>root@kali:~# ping 172.16.155.1 -c 1 |grep 'bytes from'</p><p>64 bytes from 172.16.155.1: icmp_seq=1 ttl=64 time=0.248 ms</p><p>root@kali:~# ping 172.16.155.1 -c 1 |grep 'bytes from'|cut -d ' ' -f 4</p><p>172.16.155.1:</p><p>root@kali:~# ping 172.16.155.1 -c 1 |grep 'bytes from'|cut -d ' ' -f 4|cut -d ':' -f 1</p><p>172.16.155.1</p><p>root@kali:~#</p></blockquote><p>通过在包含一系列目标IP 地址的循环中使用此任务序列，我们可以快速识别响应ICMP 回显请求的活动主机。 输出是一个简单的的活动IP 地址列表。 使用此技术的示例脚本如下所示：</p><blockquote><p>#!/bin/bash</p><p>if [ "$#" -ne 1 ]; then</p><p>echo "Usage - ./ping_sweep.sh [/24 network address]"</p><p>echo "Example - ./ping_sweep.sh 172.16.155.0"</p><p>echo "Example will perform an ICMP ping sweep of the 172.16.155.0/24 network"</p><p>exit</p><p>fi</p><p>prefix=$(echo $1 | cut -d '.' -f 1-3)</p><p>for addr in $(seq 1 254); do</p><p>ping -c 1 $prefix.$addr | grep "bytes from" | cut -d ' ' -f 4 |cut -d ":" -f 1 &</p><p>done</p></blockquote><p>在提供的bash脚本中，第一行定义了bash 解释器的位置。 接下来的代码块执行测试来确定是否提供了预期的一个参数。 这通过评估提供的参数的数量是否不等于1来确定。 如果未提供预期参数，则输出脚本的用法，并且退出脚本。 用法输出表明，脚本接受/ 24 网络地址作为参数。 下一行代码从提供的网络地址中提取网络前缀。 例如，如果提供的网络地址是192.168.11.0 ，则前缀变量将被赋值为192.168.11 。 然后使用for 循环遍历最后一个字节的值，来在本地/ 24 网络中生成每个可能的IP 地址。 对于每个可能的IP 地址，执行单个ping 命令。 然后通过管道传输每个请求的响应，然后使用grep 来提取带有短语bytes 的行。 这只会提取包含活动主机的IP 地址的行。 最后，使用一系列cut 函数从该输出中提取IP 地址。 请注意，在for 循环任务的末尾使用& 符号，而不是分号。 该符号能够并行执行任务，而不是顺序执行。 这极大地减少了扫描IP 范围所需的时间。 然后，可以使用句号和斜杠，并带上是可执行脚本的名称来执行脚本：</p><blockquote><p>root@kali:~# chmod +x ./ping.sh #给脚本文件增加执行权限</p><p>root@kali:~# ls -al ./ping.sh</p><p>-rwxr-xr-x 1 root root 382 May 29 06:27 ./ping.sh</p><p>root@kali:~# ./ping.sh</p><p>Usage - ./ping_sweep.sh [/24 network address]</p><p>Example - ./ping_sweep.sh 172.16.155.0</p><p>Example will perform an ICMP ping sweep of the 172.16.155.0/24 network</p><p>root@kali:~# ./ping.sh 172.16.155.0</p><p>172.16.155.2</p><p>172.16.155.1</p><p>172.16.155.150</p><p>root@kali:~#</p></blockquote><p>当在没有提供任何参数的情况下执行时，脚本会返回用法。 但是，当使用网络地址值执行时，任务序列开始执行，并返回活动IP 地址的列表。 如前面的脚本中所讨论的那样，此脚本的输出也可以重定向到文本文件，来供将来使用。 这可以使用尖括号，后跟输出文件的名称来实现。</p><blockquote><p>root@kali:~# ./ping.sh 172.16.155.0 > output.txt</p><p>root@kali:~# ls output.txt</p><p>output.txt</p><p>root@kali:~# cat output.txt</p><p>172.16.155.2</p><p>172.16.155.1</p><p>172.16.155.150</p></blockquote><p>在提供的示例中，ls 命令用于确认输出文件已创建。 通过将文件名作为参数传递给cat 命令，可以查看此输出文件的内容。</p><p><strong>工作原理</strong></p><p>Ping 是IT 行业中众所周知的工具，其现有功能能用于识别活动主机。 然而，它的目的是为了发现单个主机是否存活，而不是作为扫描工具。 这个秘籍中的bash 脚本基本上与在/ 24 CIDR范围中对每个可能的IP 地址使用ping 相同。 但是，我们不需要手动执行这种繁琐的任务，bash 允许我们通过循环传递任务序列来快速，轻松地执行此任务。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Kali','Linux','BASH'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>