<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 | 极客快訊</title><meta property="og:title" content="极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/7227b6203bd743bc90c8a3373d290911"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cbf52ea.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cbf52ea.html><meta property="article:published_time" content="2020-10-29T20:53:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:41+08:00"><meta name=Keywords content><meta name=description content="极客算法训练笔记(三)，链表详细图解，别再逃避了朋友"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cbf52ea.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>极客算法训练笔记(三)，链表详细图解，别再逃避了朋友</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>目录</p><ul><li>缓存引爆链表</li><li>链表单链表双向链表循环链表双向循环链表</li><li>LinkedHashMap实现LRU缓存，源码解析（JDK1.8）</li><li>算法 爬楼梯</li><li>算法 反转链表</li><li>算法 链表环检测</li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>缓存引爆链表</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7227b6203bd743bc90c8a3373d290911><p class=pgc-img-caption></p></div><p>存储结构</p><p>上一篇说的是数组，然后现在来说说链表。链表有个经典应用，就是实现LRU缓存淘汰算法，缓存的作用大家肯定都知道，常见的Redis缓存，CPU缓存，数据库缓存，浏览器缓存，预热缓存等等缓存技术。缓存大小有限，当缓存满了，需要淘汰策略来决定哪些数据出局，常见缓存算法有三种，这里以缓存中数据命中率来评判缓存算法的优劣来看三种淘汰算法：</p><ol start=1><li>FIFO（First in, First out），先进先出策略，不管你是谁，排好队一个一个来，这种做法简单粗暴公平，但是显然是没有考虑缓存数据的使用频率问题了，所以这种算法使用不多；</li><li>LFU（Least Frequently Used），最近最不频繁使用策略，即最近最少使用到的数据出局，是从时间和数据使用频率来决定的，</li></ol><ul><li>实现：LFU的每个数据块都有一个引用计数，所有数据块按照引用计数排序，具有相同引用计数的数据块则按照时间排序；</li><li>缺点：需要记录所有数据的访问记录，内存消耗较高；需要基于引用计数排序，时间消耗较高；</li></ul><ol start=3><li>LRU（Least Recently Used），最近最久未使用策略，主要是从时间来进行淘汰，如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小，把这些数据淘汰掉。</li></ol><ul><li>实现： 不就是需要根据时间来淘汰嘛，最容易想到的就是 数组+时间戳，但是这样实现不用想也知道效率贼低。因此java 中的 <strong>「LinkedHashMap」</strong> 源码就是使用这种缓存算法，底层用 双向链表（LinkedList）+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），下面我会把这部分源码进行剖析；</li><li>应用：现在使用最广泛的分布式缓存系统如Redis，Memchached，容器如LinkedHashMap 就使用了这种缓存算法，</li></ul><ol start=4><li>LRU 和LFU 区别：</li></ol><p>LRU:活在当下。比如在公司中，一个新员工做出新业绩，马上会得到重用。</p><p>LFU:以史为镜。还是比如在公司中，新员工必须做出比老员工累计更多更好的业绩才可以受到老板重视，这样的方式比较尊重“前辈”。</p><p>因此，我们可以就知道链表的伟大贡献了，看到了作用我才去学你懂你，这是我一贯的作风，要不然我学你做什么。</p><h1 class=pgc-h-arrow-right><strong>链表</strong></h1><p>上一节说数组的时候，我一直强调要一段连续的空间，链表就不需要，他是通过“指针”将一组零散的内存块串联起来使用，不需要连续只要有空间就够了。所以链表结点除了数据之外，比数组多存储了个“指针”，数组是靠数组下标偏移量（计算出地址偏移位）找数据，链表是靠指针（直接存储地址）找数据。</p><p>在操作链表的时候，要格外注意二点：</p><ol start=1><li>边界问题，例如插入有头插尾插中间插入，要注意额外的操作；</li><li>代码顺序，防止丢失指针</li></ol><h1 class=pgc-h-arrow-right><strong>单链表</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a77dd78786a44e2bb95ad8886b11e3bf><p class=pgc-img-caption></p></div><p>链表</p><p>首先理解两个概念：</p><ul><li>头指针：通常使用“头指针”来标识一个链表，如单链表L，头指针为NULL的时表示一个空链表。</li><li>头结点：在单链表的第一个结点之前附加一个结点，称为头结点。头结点的Data域可以不设任何信息，也可以记录表长等相关信息。</li></ul><p>不管你有没有头结点，头指针始终是有的，代表了链表的基地址，有基地址才能遍历。头指针始终指向第一个结点，有头结点就指向头结点。</p><p><strong>「带头结点好处」</strong></p><ol start=1><li>方便第一个位置的插入和删除</li><li>统一空表和非空表的处理</li></ol><p>有头结点可以简化很多边界问题的考虑，将边界问题转化为正常的结点处理。</p><p>最后一个是尾结点，尾结点不指向下一个结点，而是指向空地址NULL，代表这个链表结束了。</p><h1 class=pgc-h-arrow-right><strong>中间插入</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6b1c5a9d28cb466087061311a85ca147><p class=pgc-img-caption></p></div><p>中间插入</p><p>注意点： 防止指针丢失和内存泄漏</p><p>“=”是赋值，习惯性从右往左读，例插入之前是 p->next = q，q 赋值给 p->next。</p><p>错误实现：</p><pre><code>p-&gt;next = x; // 将p的next指针指向x结点;x-&gt;next = p-&gt;next; // 将x的结点的next指针指向b结点;</code></pre><p>第一步之后p->next = x，p->next指向了x结点，第二步相当于将 x赋值给 x->next，即相当于x->next = x，自己指向自己，显而易见的问题：q 的地址丢失了，从 q 往后的结点都访问不到，链表断成了两截。后面的地址弄丢了，JAVA有垃圾回收机制还好，C这样的语言程序员如果没有手动释放那些结点占的内存，就产生了内存泄漏，同时删除结点的时候如果不把结点的空间释放也会内存泄漏。</p><p>正确实现：</p><pre><code>x-&gt;next = p-&gt;next; // 将x的结点的next指针指向b结点;p-&gt;next = x; // 将p的next指针指向x结点;</code></pre><p>顺序调换一下，先将q的地址存储好放到x结点，然后x结点再链接到p结点就好了。</p><p>这个问题开始重视起来是在大三找实习一家游戏公司总监问到，让我把这个地方再说一遍，我暗地里虎躯一震菊花一紧表面上却稳如泰山，最后用温柔的微笑让他如沐春风从而化解了这个尴尬，马上改口。</p><h1 class=pgc-h-arrow-right><strong>头插入</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/225b99217c9c4edea0f0671834d37a1e><p class=pgc-img-caption></p></div><p>头插法</p><pre><code>x-&gt;next = head-&gt;next; // 将x的结点的next指针指向b结点;head-&gt;next = x; // 将p的next指针指向x结点;</code></pre><p>可知有了头结点，头插入代码和中间插入代码是一样的，只不过上一个p结点变成了head 结点。</p><h1 class=pgc-h-arrow-right><strong>尾插入</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7f573ea62dab478d88f43e2c2864131e><p class=pgc-img-caption></p></div><p>尾插法</p><pre><code>x.next = null;tail.next = x;</code></pre><h1 class=pgc-h-arrow-right><strong>头插法 VS 尾插法</strong></h1><p>HashMap 源码中，jdk8之前hash冲突时候用的都是头插法，jdk1.8之后用的尾插法，不知道你是否还有印象，主要原因是防止扩容的时候头插法造成链表环化，具体的读者有兴趣看看扩容源码。</p><p>头插法：遍历时候得到的数据顺序和插入的时候是相反的，原因是你第一次插进去的数据实际上成为了链表的尾巴；</p><p>尾插法：遍历得到的数据和插入的顺序是一致的。</p><h1 class=pgc-h-arrow-right><strong>删除结点</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4e0683cdab4e4deab238b6b8a867e6d6><p class=pgc-img-caption></p></div><p>删除中间结点</p><p>p->next = p->next->next; 一行代码就可以</p><h1 class=pgc-h-arrow-right><strong>双向链表</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45c9425990e74b329e6d11a97f2d99a9><p class=pgc-img-caption></p></div><p>双向链表</p><p>单链表的插入、删除操作的时间复杂度已经是O(1)了，为什么还要双向链表呢？优点在哪里。</p><p>还是从插入，删除，查找来看，拿删除操作来分析，无非两种情况：</p><ol start=1><li>删除给定指针指向的结点</li><li>删除结点中值等于xxx的结点</li></ol><p>第二种，对於单链表和双链表都需要先进行遍历，直到找到值等于给定值的结点，然后删除；</p><p>第一种，区别就来了，我们已经找到了要删除的结点，但是删除某个结点q需要知道其前驱结点，单链表找前驱结点还是需要遍历先找到前驱结点，双链表就可以直接拿到前驱结点；</p><p>然后实际应用中，例如容器 HashMap，都是知道指针，第一种操作比较多，删除插入操作就是指针的操作，值都是动态变得不可能告诉你一个值再让你删除，所以这种结构的重要性不言而喻了，插入操作这里不再分析了。</p><h1 class=pgc-h-arrow-right><strong>循环链表</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4b5a4a5df3c41c98c70ece6718cb390><p class=pgc-img-caption></p></div><p>循环链表</p><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的约瑟夫问题。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><blockquote><p>❝</p><p>约瑟夫问题 据说著名犹太历史学家Josephus有过以下的故事：在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。</p><p>❞</p></blockquote><h1 class=pgc-h-arrow-right><strong>双向循环链表</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9d21916b4ef4659aef74cbddfec2182><p class=pgc-img-caption></p></div><p>双向循环链表</p><h1 class=pgc-h-arrow-right><strong>LinkedHashMap实现LRU缓存，源码解析（JDK1.8）</strong></h1><pre><code>/** * A cache implementing a least recently used policy. */public class LRUCache&lt;K, V&gt; implements Cache&lt;K, V&gt; {    private final LinkedHashMap&lt;K, V&gt; cache;    public LRUCache(final int maxSize) {        cache = new LinkedHashMap&lt;K, V&gt;(16, .75f, true) {            @Override            protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) {                return size() &gt; maxSize;            }        };    }    方法伪代码：    public V get(K key)    public void put(K key, V value)    public boolean remove(K key)    public long size()    }</code></pre><p>可以得知 LRUCache 缓存就是使用 LinkedHashMap 结构实现的。</p><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec625a29e480413492c2d11d98bac4f2><p class=pgc-img-caption></p></div><p>LinkedHashMap结构图</p><p>LinkedHashMap 继承了 HashMap（jdk1.8），总的结构还是 数据+链表+红黑树，为了简化思想图里面没有红黑树的，就这样看哦；</p><pre><code>public class LinkedHashMap&lt;K,V&gt;    extends HashMap&lt;K,V&gt;    implements Map&lt;K,V&gt;{    /**     * HashMap.Node subclass for normal LinkedHashMap entries.     */    static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {        Entry&lt;K,V&gt; before, after;        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {            super(hash, key, value, next);        }    }    private static final long serialVersionUID = 3801124242820219131L;    //双向链表头结点    transient LinkedHashMap.Entry&lt;K,V&gt; head;    //双向链表尾结点    transient LinkedHashMap.Entry&lt;K,V&gt; tail;       //如果accessOrder为flase的话，则按插入顺序来遍历，默认fasle    /**     true  基于访问顺序    当accessOrder设置为true时，被访问的数据，将会被移到链表的尾部，put使用的也是尾插法；同时get是从尾部开始访问，所以等于越常使用的数据，遍历的时间越短。    **/    final boolean accessOrder;</code></pre><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc1eb8a4d61d42c98c680519beb85cc3><p class=pgc-img-caption></p></div><p>LRU 初始化启动 true</p><p>LRU 缓存初始化的时候，就用了这个 accessOrder，设置为true，从而最近被访问到的数据放到了链表末尾，链表前面的数据是长时间没有使用的，从链表末尾开始访问的话，链表头部开始的长久没有访问的数据就被淘汰掉了，从而实现LRU缓存。</p><pre><code>Map 的 Entry 结点内容static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {        final int hash;        final K key;        V value;        Node&lt;K,V&gt; next;        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {            this.hash = hash;            this.key = key;            this.value = value;            this.next = next;        }        ·······}// LinkedHashMap 的 Entry，可以看到比Map的结点多了两个指针 before,afterstatic class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {        Entry&lt;K,V&gt; before, after;        Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {            super(hash, key, value, next);        }}</code></pre><pre><code>//生成一个新的结点Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {        LinkedHashMap.Entry&lt;K,V&gt; p =            new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);        //结点尾插法放入链表最后        linkNodeLast(p);        return p;    }    //尾插法，把新结点插入链表末尾private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {    // 尾结点赋值给 last 指针    LinkedHashMap.Entry&lt;K,V&gt; last = tail;    // P 结点赋值给尾结点    tail = p;    // 如果尾部节点为空，说明是空链表，那么插入的就是第一个节点。这个时候新加入的数据赋给头部节点    if (last == null)        head = p;    // 不是空链表，将新结点放到末尾        else {        p.before = last;        last.after = p;    }}</code></pre><p>LinkedHashMap是继承的HashMap，插入删除都是直接用的HashMap的插入删除方法，只不过它重写了三个回调方法，来实现他需要的额外操作，如下：</p><pre><code>// 在hashmap正常删除一个结点之后进行回调void afterNodeRemoval(Node&lt;K,V&gt; e) {         /**定义了一个结点p，将传递进来的的e结点赋值给p，把传进来的e结点赋值给p结点，并且定义p的前驱结点b，后继结点a **/        LinkedHashMap.Entry&lt;K,V&gt; p =            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;        p.before = p.after = null;        // 如果前一个结点是null，那么这是个空链表        if (b == null)            head = a;        else            b.after = a;        if (a == null)            tail = b;        else            a.before = b;    }</code></pre><pre><code>//在hashmap正常插入一个结点之后进行回调，插入一个结点可能缓存满了，因此需要移除最久没有使用的结点即第一个结点（前面讲了LRU的调度算法，不明白的可以回头去看）/**//根据evict,也就是前文linkedHashMap构造函数中的accessOrder，来判断是否删除双向链表中最老的元素，这个是实现lru需要用到的。**/void afterNodeInsertion(boolean evict) { // possibly remove eldest        LinkedHashMap.Entry&lt;K,V&gt; first;        if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) {            K key = first.key;            // hashmap的移除结点方法，传key第一个结点过去进行删除            removeNode(hash(key), key, null, false, true);        }    }</code></pre><pre><code>// 最常用是hashmap正常putVal之后调用，将新加入的结点移动到链表末尾void afterNodeAccess(Node&lt;K,V&gt; e) { // move node to last        LinkedHashMap.Entry&lt;K,V&gt; last;        if (accessOrder &amp;&amp; (last = tail) != e) {        // 把传进来的e结点赋值给p结点，并且定义p的前驱结点b，后继结点a            LinkedHashMap.Entry&lt;K,V&gt; p =                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;            p.after = null;            if (b == null)                head = a;            else                b.after = a;            if (a != null)                a.before = b;            else                last = b;            if (last == null)                head = p;            else {                p.before = last;                last.after = p;            }            // 把p结点赋值给尾结点            tail = p;            ++modCount;        }    }</code></pre><p>afterNodeAccess()方法图解：</p><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/76575c327db840e1afdda0727926a1bd><p class=pgc-img-caption></p></div><p>afterNodeAccess 方法图解</p><p>还是挺复杂的，画了一个多小时这张图。</p><h1 class=pgc-h-arrow-right><strong>算法 爬楼梯</strong></h1><p>上一篇的遗留算法：</p><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/77ad256f001745d8b80f0c25b3273e69><p class=pgc-img-caption></p></div><p>爬楼梯</p><p>超哥说，<strong>「解决所有问题的法则」</strong>：</p><ol start=1><li>找最近重复的子问题；</li><li>为什么？因为写程序我们只能写if，else，for，while，recursion（递归）；</li><li>计算机是人类发明的，计算机肯定是没有人脑那么强的，它其实就是一个简单的重复式机器那么计算机运行的程序也是同理，它是用重复的东西来解决问题的；</li><li>如果我们遇到算法题的时候，就是需要我们用程序去解决的问题，那问题的本身就是可重复的；</li><li>无论是算法中的回溯、分治、动态规划、递归等，全部都是在找重复性的原理所以重点都是“找规律”；</li></ol><p>分析问题：</p><ol start=1><li>刚刚拿到，没有思路，先暴力举例 一阶（1种）：1</li></ol><p>二阶（2种）：1+1，2</p><p>三阶（3种）：1+1+1，2+1，1+2 即二阶的走法+1和一阶的走法+2</p><p>四阶（5种）：1+1+1+1，1+2+1，2+1+1，1+1+2，2+2，即三阶的走法+1和二阶的走法+2，共五种</p><p>五阶（8种）：1+1+1+1+1，1+2+1，2+1+1，1+1+2+1，2+2+1，1+1+1+2，2+1+2，1+2+2 即四阶的走法+1和三阶的走法+2，共八种</p><p>......</p><p>思想：例如一共10阶，那么有两种方法，要不就是你走到了第八阶跨2步，或者走到第九阶了跨1步，再也没有别的实现了，因为你一次性只能跨两步或者一步，所以最终次数就是到达第八阶次数+到达第九阶的次数，f(10)=f(9)+f(8),每一层都是如此情况，即在上一个台阶走2步或者走1步到达终点，可知这其实是个斐波拉契问题。</p><p><strong>「实现：」</strong></p><ol start=1><li>斐波拉契，递归</li></ol><pre><code>    public static int climbStairs(int n) {        if (n &lt;= 1)            return 1;        if (n &lt; 3)            return n;        return climbStairs(n - 1) + climbStairs(n - 2);    }</code></pre><p>但是这种方法，会一直递归，重复计算很多，例如我再代码里面打印一下就能看到：</p><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fa9010378358405395470f3b8661b853><p class=pgc-img-caption></p></div><p>重复计算</p><p>图解：</p><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d72f2c6b161042ce9afdd285cecae3a4><p class=pgc-img-caption></p></div><p>Fib6</p><p>由图解可知，很多都被重复计算了多次，下面进行优化</p><ol start=2><li>循环</li></ol><pre><code> public int climbStairs(int n) {        if (n &lt;= 1)            return 1;        int[] dp = new int[n + 1];        dp[1] = 1;        dp[2] = 2;        for (int i = 3; i &lt;= n; i++) {            dp[i] = dp[i - 1] + dp[i - 2];        }        return dp[n];    }</code></pre><p>用数组将每一阶的到达次数给存储，直接拿前面两个数据的和即可。</p><ol start=3><li>循环优化</li></ol><p>可以不用数组存储每一阶的到达次数，直接定义两个变量就可以，节省了空间</p><ol start=4><li>公式实现</li></ol><p>这个需要推导公式，非大佬不行，感兴趣自行百科。</p><h1 class=pgc-h-arrow-right><strong>算法 反转链表</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92e6c09d84bc4802be1329ec0645a00d><p class=pgc-img-caption></p></div><p>反转链表</p><h1 class=pgc-h-arrow-right><strong>算法 链表环检测</strong></h1><div class=pgc-img><img alt=极客算法训练笔记(三)，链表详细图解，别再逃避了朋友 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b4befbbfd5714117b79e51cf53214936><p class=pgc-img-caption></p></div><p>链表环检测</p><p>拿到题感觉是题目意图都很清晰，没有那么多花里胡哨的，但是真正要动笔还得掉些发，写这些用了洪荒之力了，下一篇再写这两题。</p><p><strong>「链表重要练习汇总：」</strong></p><ol start=1><li>单链表反转</li><li>链表中环的检测</li><li>两个有序的链表合并</li><li>删除链表倒数第n个结点</li><li>求链表的中间结点</li></ol><p>公众号《阿甘的码路》关注我，一起成长～</p><p>参考资料： 数据结构与算法之美 极客算法训练营视频</p><p>往期推荐： 极客算法训练笔记(二)，你所不知道的数组</p><p>极客算法训练笔记(一)，算法学习方法篇</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'极客','训练','笔记'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>