<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>《UNIX环境高级编程》-简单摘要 | 极客快訊</title><meta property="og:title" content="《UNIX环境高级编程》-简单摘要 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/66b200050c65468c3b28"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cc5b2fc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cc5b2fc.html><meta property="article:published_time" content="2020-10-29T20:50:39+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:39+08:00"><meta name=Keywords content><meta name=description content="《UNIX环境高级编程》-简单摘要"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cc5b2fc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>《UNIX环境高级编程》-简单摘要</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>1.标准IO和不带缓存的IO</p><p>open 、read 、 write 、lseek以及close提供了不用缓存的I/O</p><p>2.信号</p><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66b200050c65468c3b28></p><p class=pgc-img-caption>信号</p><p>3.进程控制</p><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66af0005d1711f9c6536></p><p class=pgc-img-caption>c程序启动和终止</p><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66b100059096714213a6></p><p>有三个用于进程控制的主要函数: fork 、exec和waitpid(exec函数有6种变体,但是经常统称他们为exec函数)</p><p>多进程下的文件共享,原子操作,dup和dup2和fcntl以及/dev/fd/</p><p>fifo进程间通信(命名管道)</p><p>符号链接 ln -s</p><p>查找3天前修改过的文件</p><p>find /var/log/ -mtime +3 -type f -print</p><p>mkfifo</p><p>http://blog.csdn.net/qq_34409701/article/details/52488964</p><p>mkdir常见目录 和 rmdir删除空目录 rm -rf 删除目录</p><p>sync和fsync</p><p>linux-c中exit和_exit都是正常终止一个程序,但是区别是:</p><p>_exit 立即进入内核,而exit则是先执行一些清理,比如调用各种终止处理程序,关闭所有标准IO流等,然后再进入内核</p><p>int main(int argc,char argv[])</p><p>argc 表示的是参数的个数,指向参数的各个指针所构成的数组</p><p>getpid 当前进程Id</p><p>getppid 当前进程的父Id</p><p>getuid 调用进程的实际用户ID</p><p>geteuid 调用进程的有效用户ID</p><p>getgid 调用进程的实际组ID</p><p>getegid 调用进程的有效组ID</p><p>由fork创建的新进程被称为子进程(childprocess)该函数被调用一次,但返回两次。</p><p>两次返回的区别是子进程的返回值是0,而父进程的返回值则是新子进程的进程ID。</p><p>将子进程ID返回给父进程的理由是:因为一个进程的子进程可以多于一个,所以没有一个函数使一个进程可以获得其所有子进程的进程ID 。</p><p>fork使子进程得到返回值0的理由是:一个进程只会有一个父进程,所以子进程总是可以调用gitppid以获得其父进程的进程ID(进程ID 0总是由交换进程使用, 所以一个子进程的进程ID不可能为0) 。</p><p>子进程和父进程继续执行fork之后的指令。子进程是父进程的复制品。 例如,</p><p>子进程获得父进程数据空间、堆和栈的复制品。注意，这是子进程所拥有的拷贝。父、子进程并不共享这些存储空间部分。如果正文段是只读的，则父、子进程共享正文段。 现在很多的实现并不做一个父进程数据段和堆的完全拷贝，因为在fork之后经常跟随着exec。作为替代,使用了在写时复制(Copy-On-Write,COW)</p><p>的技术。这些区域由父、子进程共享,而且内核将它们的存取许可权改变为只读的。如果有进程试图修改这些区域，则内核为有关部分,典 型的是虚存系统中的"页 ",做一个拷贝。</p><p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的。这取决于内核所使用 的调度算法。如果要求父、子进程之间相互同步，则要求某种形式的进程间通信。</p><p>程序中可以使父进程使自己睡眠2秒钟,以此使子进程先执行.但并不保证2秒钟已经足够</p><p>竞态条件</p><p>setgid 、setuid</p><p>进程组</p><p>每个进程除了有一进程ID之外，还属于一个进程组,进程组是一个或多个进程的集合。每个进程组有一个唯一的进程组ID。</p><p>进程组ID类似于进程ID,它是一个正整数,并可存放在pid_t 数据类型,函数getpgrp返回调用进程的进程组ID。</p><p>每个进程组有一个组长进程。组长进程的标识是,其进程组ID等于其进程ID。</p><p>进程组组长可以创建一个进程组,创建该组中的进程,然后终止。只要在某个进程组中有 一个进程存在,则该进程组就存在,这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止,也可以参加另一个进程组。</p><p>进程调用setpgid可以参加一个现存的组或者创建一个心得进程组(使用setsid可以创建一个新的进程组）</p><p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用了exec后,它就不再能改变该子进程的进程组ID</p><p>对话期:一个或者多个进程组的集合</p><p>作业控制</p><p>shell执行程序的过程,前台进程组 后台进程组</p><p>shell实现一条管道中执行三个进程</p><p>ps -xj | cat readme.md | cat pcntl_do.php</p><p>pgid</p><p>孤儿进程组</p><p>父进程已终止的进程称为孤儿进程,这种进程又init进程收养</p><p>整个进程组也可成为孤儿</p><p>考虑一个进程在fork一个子进程后然后终止,并无异常现象,但是在父进程终止时，如果该子进程停止(用作业控制)又将如何呢?子进程如何继续?</p><p>以及子进程是否知道它已经是孤儿进程?</p><p>对孤儿进程组的另一种描述可以是:一个进程组不是孤儿进程组的条件是:该组中有 一个进程，其父进程在属于同一对话期的另一个组中。如果进程组不是孤儿进程组，那么在属 于同一对话期的另一个组中的父进程就有机会重新起动该组中停止的进程</p><p>kill 函数将信号发送给进程或者进程组,raise函数则允许进程向自身发送信号</p><p>kill的pid参数有四种不同的情况:</p><p>• pid > 0 将信号发送给进程ID为pid的进程。</p><p>• pid == 0 将信号发送给其进程组ID等于发送进程的进程组ID,而且发送进程有许可权向其发送信号的所有进程。 这里用的术语“所有进程”不包括实现定义的系统进程集。</p><p>对于大多数UNIX系统,系统进程集包括:交换进程(pid 0),init(pid 1)以及页精灵进程(pid 2)。</p><p>• pid &lt; 0 将信号发送给其进程组ID等于pid的绝对值,而且发送进程有许可权向其发送信号</p><p>的所有进程。如上所述一样，“所有进程”并不包括系统进程集中的进程。</p><p>• pid == -1 POSIX.1未定义此种情况。</p><p>精灵进程(也叫守护进程)</p><p>精灵进程(daemon)是生存期长的一种进程。它们常常在系统引导装入时起动,在系统关闭时终止。因为它们没有控制终端，所以说它们是在后台运行的。</p><p>因为精灵没有控制终端</p><p>ps -ajx</p><p>选择项-a显示由其他用户所拥有的进程的状态</p><p>-x显示没有控制终端的进程的状态</p><p>-j显示与作业有关的信息:对话期ID、进程组ID、控制终端以及终端进程组ID</p><p>Tenlu :: ~ » ps -ajx|head -n 4</p><p>USER PID PPID PGID SESS JOBC STAT TT TIME COMMAND</p><p>root 1 0 1 0 0 Ss ?? 6:27.43 /sbin/launchd</p><p>root 55 1 55 0 0 Ss ?? 0:36.92 /usr/libexec/UserEventAgent (System)</p><p>root 56 1 56 0 0 Ss ?? 0:15.20 /usr/sbin/syslogd</p><p>进程:控制终端</p><p>显示进程树,进程对应的关系</p><p>pstree -p查看进程树，并打印每个进程的PID</p><p>pstree -p 20445 查看指定进程的进程树结构</p><p>记录锁</p><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66b00005c02394f22dac></p><p class=pgc-img-caption>锁</p><p>当两个人同时编辑一个文件时,其后果将如何呢?在很多UNIX系统中,该文件的最后状态 取决于写该文件的最后一个进程。</p><p>但是对于有些应用程序,例如数据库,有时进程需要确保它正在单独写一个文件,用到了记录锁</p><p>记录锁(record locking)的功能是:一个进程正在读或修改文件的某个部分时，可以阻止</p><p>其他进程修改同一文件区。对于UNIX,"记录"这个定语也是误用,因为UNIX内核根本没有使用文件记录这种概念。一个更适合的术语可能是“区域锁”，因为它锁定的只是文件的一个区域(也可能是整个文件)。</p><p>fcntl记录锁</p><p>flock结构说明:</p><p>• 所希望的锁类型: F_RDLCK(共享读锁)、F_WRLCK(独占性写锁)或F_UNLCK(解锁一个区域)</p><p>多个进程在一个给定的字节上可以有一把共享的读锁，但是在一个给定字节上的写锁则只能由一个进程独用。更进一步而言，如果在一个给定字节上已 经有一把或多把读锁，则不能在该字节上再加写锁;如果在一个字节上已经有一把 独占性的写锁，则不能再对它加任何读锁</p><p>死锁:</p><p>如果两个进程相互等待对方持有并且不释放(锁定)的资源时，则这两个进程就处于死锁 状态。如果一个进程已经控制了文件中的一个加锁区域，然后它又试图对另一个进程控制的区域加锁，则它就会睡眠，在这种情况下，有发生死锁的可能性。</p><p>关于记录锁的自动继承和释放有三条规则:</p><p>(1) 锁与进程、文件两方面有关。这有两重含意:第一重很明显，当一个进程终止时，它 所建立的锁全部释放;第二重意思就不很明显，任何时候关闭一个描述符时，则该进程通过这 一描述符可以存访的文件上的任何一把锁都被释放(这些锁都是该进程设置的)。这就意味着如果执行下列四步:</p><p>fd1=open(pathname, ...);</p><p>read_lock(fd1, ...);</p><p>fd2 = dup(fd1);</p><p>close(fd2);</p><p>则在close(fd2)后，在fd1上设置的锁被释放。</p><p>如果将dup代换为open,其效果也一样:</p><p>fd1=open(pathname, ...);</p><p>read_lock(fd1, ...);</p><p>fd2=open(pathname, ...);</p><p>close(fd2);</p><p>(2)由fork产生的子进程不继承父进程所设置的锁,这意味着,若一个进程得到一把锁,然后调用fork,那么对于父进程获得的锁而言,子进程被视为另一个进程</p><p>对于从父进程处继承过来的任意描述符,子进程要调用fcntl以获得自己的锁,这与锁的作用是一致的,锁的作用就是阻止多个进程同时写同一个文件(或者同一个区域),如果子进程继承父进程的锁,则父、 子进程就可以同时写同一个文件。</p><p>(3) 在执行exec后，新程序可以继承原执行程序的锁。</p><p>getmsg/getpmsg、putmsg/putpmsg</p><p>io多路转接</p><p>select和poll和epoll</p><p>查看进程占用的内存</p><p>ps aux</p><p>Tenlu :: ~ » ps aux</p><p>USER PID %CPU %MEM VSZ RSS TT STAT STARTED TIME COMMAND</p><p>LuKun 347 14.7 2.7 8639196 224004 ?? S 五02下午 335:36.47 /Applications/WeChat.app/Contents/MacOS/WeChat -psn_0_53261</p><p>其中:</p><p>VSZ：表示进程占用多少虚拟内存（kb）</p><p>RSS：表示进程占用多少物理内存（kb）</p><p>Tenlu :: ~ » ps aux | grep php | grep -v grep | awk -F ' ' '{print "进程ID"$2.":",",占用虚拟内存(VSZ):"$5"kb",",进程占用物理内存(RSS):"$6"kb"}'</p><p>进程ID350: ,占用虚拟内存(VSZ):7872892kb ,进程占用物理内存(RSS):413456kb</p><p>进程ID22311: ,占用虚拟内存(VSZ):2483920kb ,进程占用物理内存(RSS):2352kb</p><p>进程ID12957: ,占用虚拟内存(VSZ):2483920kb ,进程占用物理内存(RSS):2372kb</p><p>进程ID12956: ,占用虚拟内存(VSZ):2483920kb ,进程占用物理内存(RSS):2760kb</p><p>进程ID12955: ,占用虚拟内存(VSZ):2480176kb ,进程占用物理内存(RSS):240kb</p><p>或者</p><p>root@iZ257v6fpmnZ ~]# pmap -d 17710</p><p>17710: php-fpm: master process (/usr/local/php/etc/php-fpm.conf)</p><p>Address Kbytes Mode Offset Device Mapping</p><p>0000000000400000 11724 r-x-- 0000000000000000 0ca:00001 php-fpm</p><p>0000000001172000 768 rw--- 0000000000b72000 0ca:00001 php-fpm</p><p>0000000001232000 152 rw--- 0000000000000000 000:00000 [ anon ]</p><p>000000000300a000 1768 rw--- 0000000000000000 000:00000 [ anon ]</p><p>....</p><p>命令输出第一行：执行程序以及参数。</p><p>Address: 内存开始地址</p><p>Kbytes: 占用内存的字节数（KB）</p><p>RSS: 保留内存的字节数（KB）</p><p>Dirty: 脏页的字节数（包括共享和私有的）（KB）</p><p>Mode: 内存的权限：read、write、execute、shared、private (写时复制)</p><p>Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）</p><p>Offset: 文件偏移</p><p>Device: 设备名 (major:minor)</p><p>pmap -dq 17710 | awk -F ' ' 'BEGIN{sum=0}{sum+=$2}END{print sum}'</p><p>pmap -dq 17710 | awk -F ' ' 'BEGIN{sum=0}{if($6!~/\.so/)sum+=$2}END{print sum}'</p><p>进程之间通信</p><ol class=list-paddingleft-2><li><p>管道</p></li><li><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/66b10005930c42a8a082></p><p class=pgc-img-caption>管道</p></li></ol><p>管道是UNIX IPC的最老形式，并且所有UNIX系统都提供此种通信机制</p><p>(1) 它们是半双工的。数据只能在一个方向上流动。</p><p>(2) 它们只能在具有公共祖先的进程之间使用。通常，一个管道由一个进程创建，然后该进程调用fork,此后父、子进程之间就可应用该管道 。</p><p>popen 创建管道</p><p>pclose</p><p>因为常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其发送输入。</p><p>所以标准I/O库为实现这些操作提供了两个函数popen和pclose。这两个函数实现的操作是:创建一个管道,fork一个子进程,关闭管道的不使用端,exec一</p><p>个sh ell以执行命令,等待命令终止</p><p>协同进程</p><p>UNIX过滤程序从标准输入读取数据,对其进行适当处理后写到标准输出. 几个过滤进程通常在shell管道命令中线性地连接。当同一个程序产生某个过滤程序的输 入,同时又读取该过滤程序的输出时,则该过滤程序就成为协同进程(coprocess)</p><p>FIFO命名管道</p><p>消息队列 信号量</p><p>共享存储</p><p>大多数数据库访问的函数库使用两个文件来存储信息:一个索引文件和一个数据文件。索 引文件包括索引值(关键字)和一个指向数据文件中对应数据记录的指针。有许多技术可用来 组织索引文件以提高按关键字查询的速度和效率，散列表和 B +树 是 两 种 常 用 的 技 术 。 我 们 采 用固定大小的散列表来组织索引文件结构，并采用链表法解决散列冲突。在介绍 d b _ o p e n 时， 曾 提 到 将 建 立 两 个 文 件 : 一 个 以 . i d x为 后 缀 的 索 引 文 件 和 一 个 以 . d a t 为 后 缀 的 数 据 文 件 。</p><p>我们将关键字和索引以 N U L L 结 尾 的 字 符 串 形 式 存 储 — — 它 们 不 能 包 含 任 一 的 二 进 制 数 据 。 有些数据库系统用二进制的形式存储数值数据(如用 1、2或4个字节存储一个整数)以节省空 间，这样一来使函数复杂化，也使数据库文件在不同的平台间移植比较困难。比方说，网络上 有两个系统使用不同的二进制格式存储整数，如果想要这两个系统都能够访问数据库就必须解 决这个问题(今天不同体系结构的系统共享文件已经很常见了)。按照字符串形式存储所有的 记录，包括关键字和数据，能使这一切变得简单。这确实会需要更多的磁盘空间，但随着磁盘 技术的发展，这渐渐不再构成问题。</p><p>d b _ s t o r e要 求 对 每 个 关 键 字 ,最 多 只 有 一 个 对 应 的 记 录 。 有 些 数 据 库 系 统 允 许 多 条 记 录 使 用同样的关键字，并提供方法访问与一个关键字相关的所有记录。另外，我们只有一个索引文 件，这意味着每个数据记录只能有一个关键字。有些数据库允许一条记录拥有多个关键字，并 且对每一个关键字使用一个索引文件。当加入或删除一条记录时，要对所有的索引文件进行相 应的修改。(一个有多个索引的例子是雇员库文件，可以将雇员号作为关键字，也可以将雇员 的社会保险号作为关键字。由于一般雇员的名字并不保证唯一，所以名字不能作为关键字。)</p><p>图 1 6 - 1 是数据库实现的基本结构。索引文件由三部分组成:空闲链表指针、散列表和索引 记录。图 1 6 - 1 p t r 字段中实际存储的是以 A S C I I字 符 串 形 式 记 录 的 文 件 中 的 位 移 量 。</p><p>图 16-1 见印象笔记</p><p>当给定一个关键字要在数据库中寻找一条记录时， d b _ f e t c h 根 据 关 键 字 计 算 散 列 值 ， 由 此 散列值可确定一条散列链( chain ptr(链表指针)字段可以为0，表示一条空的散列链)。沿着这 条散列链，我们可以找到所有有同样散列值的索引记录。当遇到一个索引记录的 chain ptr字段 为0时，表示到达了此散列链的末尾</p><p>数据库函数库：</p><p>粗锁和细锁</p><p>伪终端</p><p>进程切换,消耗资源</p><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/66af0005d8880d90fdcc></p><p class=pgc-img-caption>进程状态</p><p><img alt=《UNIX环境高级编程》-简单摘要 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/66b2000515d7f0e27580></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'UNIX','环境','高级'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>