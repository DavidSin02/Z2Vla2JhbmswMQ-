<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>西门子S7程序结构与程序设计：老知识，新讲解 | 极客快訊</title><meta property="og:title" content="西门子S7程序结构与程序设计：老知识，新讲解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/153552396273392518361e4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd244e3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd244e3.html><meta property="article:published_time" content="2020-10-29T20:59:51+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:51+08:00"><meta name=Keywords content><meta name=description content="西门子S7程序结构与程序设计：老知识，新讲解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cd244e3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>西门子S7程序结构与程序设计：老知识，新讲解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>S7程序结构与程序设计：老知识，新讲解</p></blockquote><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/153552396273392518361e4><p class=pgc-img-caption></p></div><p><strong>1 S7 CPU中的程序</strong></p><p><strong>a 用户程序中的块结构</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535524228806fd22103b38><p class=pgc-img-caption></p></div><p><strong>b 用户程序结构</strong></p><p><strong>（1） 线性程序（线性编程）</strong></p><p><strong>将整个用户程序连续放置在一个循环程序块（OB1）中，块中的程序按顺序执行，CPU通过反复执行OB1来实现自动化控制任务。这种结构和PLC所代替的硬接线继电器控制类似，CPU逐条地处理指令。事实上所有的程序都可以用线性结构实现，不过，线性结构一般适用于相对简单的程序编写。</strong></p><p><strong>（2）分部式程序（分部编程、分块编程）</strong></p><p><strong>将整个程序按任务分成若干个部分，并分别放置在不同的功能（FC）、功能块（FB）及组织块中，在一个块中可以进一步分解成段。在组织块OB1中包含按顺序调用其他块的指令，并控制程序执行。在分部程序中，既无数据交换，也不存在重复利用的程序代码。功能（FC）和功能块（FB）不传递也不接收参数，分部程序结构的编程效率比线性程序有所提高，程序测试也较方便，对程序员的要求也不太高。对不太复杂的控制程序可考虑采用这种程序结构。</strong></p><p><strong>（3）结构化程序（结构化编程或模块化编程）</strong></p><p><strong>处理复杂自动化控制任务的过程中，为了使任务更易于控制，常把过程要求类似或相关的功能进行分类，分割为可用于几个任务的通用解决方案的小任务，这些小任务以相应的程序段表示，称为块（FC或FB）。OB1通过调用这些程序块来完成整个自动化控制任务。结构化程序的特点是每个块（FC或FB）在OB1中可能会被多次调用，以完成具有相同过程工艺要求的不同控制对象。这种结构可简化程序设计过程、减小代码长度、提高编程效率，比较适合于较复杂自动化控制任务的设计。</strong></p><p><strong></strong></p><p><strong>c I/O过程映像</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15355242446962aecc6907c><p class=pgc-img-caption></p></div><p><strong>d 程序循环执行</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15355242583932f686e3fef><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>2 数据块中的数据存储</strong></p><p><strong>a 数据存储区</strong></p><p><strong>数据以用户程序变量的形式存储，且具有唯一性。数据可以存储在输入过程映像存储器（PII）、输出过程映像存储器（PIQ）、位存储器（M）、局部数据堆栈（L堆栈）及数据块（DB）中。可以采用基本数据类型、复杂数据类型或参数类型。根据访问方式的不同，这些数据可以在全局符号表或共享数据块中声明，称为全局变量；也可以在OB、FC和FB的变量声明表中声明，称为局部变量。当块被执行时，变量将固定地存储在过程映像区（PII或PIQ）、位存储器区（M）、数据块（DB）或局部堆栈（L）中。</strong></p><p><strong></strong></p><p><strong>b 数据块</strong></p><p><strong>数据块定义在S7 CPU的存储器中，用户可在存储器中建立一个或多个数据块。每个数据块可大可小，但CPU对数据块数量及数据总量有限制。数据块（DB）可用来存储用户程序中逻辑块的变量数据（如：数值）。与临时数据不同，当逻辑块执行结束或数据块关闭时，数据块中的数据保持不变。用户程序可以位、字节、字或双字操作访问数据块中的数据，可以使用符号或绝对地址。</strong></p><p><strong>（1）数据块的分类</strong></p><p><strong>共享数据块又称全局数据块。用于存储全局数据，所有逻辑块（OB、FC、FB）都可以访问共享数据块存储的信。背景数据块用作“私有存储器区”，即用作功能块（FB）的“存储器”。FB的参数和静态变量安排在它的背景数据块中。背景数据块不是由用户编辑的，而是由编辑器生成的。用户定义数据块（DB of Type）是以UDT为模板所生成的数据块。创建用户定义数据块（DB of Type）之前，必须先创建一个用户定义数据类型，如UDT1，并在LAD/STL/FBD S7程序编辑器内定义。</strong></p><p><strong>（2）数据块寄存器</strong></p><p><strong>CPU有两个数据块寄存器：DB和DI寄存器。这样，可以同时打开两个数据块。</strong></p><p><strong></strong></p><p><strong>c 数据块的数据结构</strong></p><p><strong>在STEP 7中数据块的数据类型可以采用基本数据类型、复杂数据类型或用户定义数据类型（UDT）。</strong></p><p><strong>（1）基本数据类型</strong></p><p><strong>根据IEC1131-3定义，长度不超过32位，可利用STEP 7基本指令处理，能完全装入S7处理器的累加器中。基本数据类型包括：</strong></p><p><strong>位数据类型：BOOL、BYTE、WORD、DWORD、CHAR</strong></p><p><strong>数字数据类型：INT、DINT、REAL</strong></p><p><strong>定时器类型：S5TIME、TIME、DATE、TIME_OF_DAY</strong></p><p><strong></strong></p><p><strong>（2）复杂数据类型</strong></p><p><strong>复杂数据类型只能结合共享数据块的变量声明使用。复杂数据类型可大于32位，用装入指令不能把复杂数据类型完全装入累加器，一般利用库中的标准块（“IEC”S7程序）处理复杂数据类型。复杂数据类型包括：</strong></p><p><strong>时间（DATE_AND_TIME）类型</strong></p><p><strong>矩阵（ARRAY）类型</strong></p><p><strong>结构（STRUCT）类型</strong></p><p><strong>字符串（STRING）类型</strong></p><p><strong></strong></p><p><strong>（3）用户定义数据类型</strong></p><p><strong>STEP 7允许利用数据块编辑器，将基本数据类型和复杂数据类型组合成长度大于32位用户定义数据类型（UDT：User-Defined dataType）。用户定义数据类型不能存储在PLC中，只能存放在硬盘上的UDT块中。可以用用户定义数据类型作“模板”建立数据块，以节省录入时间。可用于建立结构化数据块、建立包含几个相同单元的矩阵、在带有给定结构的FC和FB中建立局部变量。</strong></p><p><strong>创建用户定义数据类型</strong></p><p><strong>创建一个名称为UDT1的用户定义数据类型，数据结构如下，则可按以下几个步骤完成。</strong></p><p><strong>STRUCT</strong></p><p><strong>Speed:INT</strong></p><p><strong>Current:REAL</strong></p><p><strong>END_STRUCT</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535524280679580b4a901c><p class=pgc-img-caption></p></div><p><strong>打开UDT1，并编辑：</strong></p><p><strong></strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15355242902409ecb87d3e5><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong></strong></p><p><strong>d 建立数据块</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535524302652c78d7df1e3><p class=pgc-img-caption></p></div><p><strong>在STEP 7中，为了避免出现系统错误，在使用数据块之前，必须先建立数据块，并在块中定义变量（包括变量符号名、数据类型以及初始值等）。数据块中变量的顺序及类型决定了数据块的数据结构，变量的数量决定了数据块的大小。数据块建立后，还必须同程序块一起下载到CPU中，才能被程序块访问。</strong></p><p><strong>（1）建立数据块</strong></p><p><strong>（2）定义变量并下载数据块</strong></p><p><strong>在DB1中声明5个变量：</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1535524316147ff78550a4d><p class=pgc-img-caption></p></div><p><strong>变量定义完成后，应单击保存按钮保存并编译（测试）。如果没有错误则需要单击下载按钮，像逻辑块一样，将数据块下载到CPU。</strong></p><p><strong></strong></p><p><strong>e 访问数据块</strong></p><p><strong>在用户程序中可能存在多个数据块，而每个数据块的数据结构并不完全相同，因此在访问数据块时，必须指明数据块的编号、数据类型与位置。如果访问不存在的数据单元或数据块，而且没有编写错误处理OB块，CPU将进入STOP模式。</strong></p><p><strong>（1）寻址数据块</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535524327542d9e33b5b84><p class=pgc-img-caption></p></div><p><strong></strong></p><p><strong>（2）访问数据块</strong></p><p><strong>在STEP 7中可以采用传统访问方式，即先打开后访问；也可以采用完全表示的直接访问方式。</strong></p><p><strong></strong></p><p><strong>举例1：打开并访问共享数据块：</strong></p><p>OPN “My_DB” //打开数据块DB1，作为共享数据块</p><p>L DBW2 //将DB1的数据字DBW2装入累加器1的低字中</p><p>T MW0 //将累加器1低字中的内容传送到存储字MW0</p><p>OPN DB2 //打开数据块DB2，作为共享数据块，同时关闭数据块DB1</p><p>L DB10 //装入共享数据块DB2的长度</p><p>L MD10 //将MD10装入累加器</p><p>&lt;D //比较数据块DB2的长度是否足够长</p><p>JC ERRO //如果长度小于存储双字MD10中的数值，则跳转到ERRO</p><p><strong></strong></p><p><strong>用指令“OPN DB...”打开共享数据块（自动关闭之前打开的共享数据块），如果DB已经打开，则可用装入（L）或传送（T）指令访问数据块。</strong></p><p><strong>举例2：打开并访问背景数据块:</strong></p><p>OPN DB1 //打开数据块DB1，作为共享数据块</p><p>L DBW2 //将DB1的数据字DBW2装入累加器1的低字中</p><p>T MW0 //将累加器1低字中的内容传送到存储字MW0</p><p>T DBW4 //将累加器1低字中的内容传送到DB1的数据字DBW4</p><p>OPN DI2 //打开数据块DB2，作为背景数据块</p><p>L DIB2 //将DB2的数据字节DBB2装入累加器1低字的低字节中</p><p>L DIB10 //累加器1低字节的内容传送到DB2的数据字节DBB10</p><p><strong>（3）直接访问数据块</strong></p><p><strong>在指令中同时给出数据块的编号和数据在数据块中的地址。可以用绝对地址，也可以用符号地址直接访问数据块。</strong></p><p><strong>用绝对地址直接访问数据块，如：</strong></p><p>L DB1.DBW2 //打开数据块DB1，并装入地址为2字数据单元</p><p>T DB1.DBW4 //将数据传送到数据块DB1的数据字单元DBW4</p><p><strong>用符号地址直接访问数据块 ，如：</strong></p><p>L “My_DB”.V1 //打开符号名为“My_DB”的数据块</p><p>//并装入名为V1的数据单元</p><p><strong></strong></p><p><strong>3 逻辑块（FC和FB）的结构及编程</strong></p><p><strong>功能（FC）、功能块（FB）和组织块（OB）统称为逻辑块（或程序块）。功能块（FB）有一个数据结构与该功能块的参数完全相同的数据块，称为背景数据块，背景数据块依附于功能块，它随着功能块的调用而打开，随着功能块的结束而关闭。存放在背景数据块中的数据在功能块结束时继续保持。而功能（FC）则不需要背景数据块，功能调用结束后数据不能保持。组织块（OB）是由操作系统直接调用的逻辑块。</strong></p><p><strong>a 逻辑块（FC和FB）的结构</strong></p><p><strong>逻辑块（OB、FB、FC）由变量声明表、代码段及其属性等几部分组成。</strong></p><p><strong>（1）局部变量声明表（局部数据）</strong></p><p><strong>每个逻辑块前部都有一个变量声明表，称为局部变量声明表。</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153552435612235e04a4c73><p class=pgc-img-caption></p></div><p><strong>局部数据分为参数和局部变量两大类，局部变量又包括静态变量和临时变量（暂态变量）两种。</strong></p><p><strong>对于功能块（FB），操作系统为参数及静态变量分配的存储空间是背景数据块。这样参数变量在背景数据块中留有运行结果备份。在调用FB时，若没有提供实参，则功能块使用背景数据块中的数值。操作系统在L堆栈中给FB的临时变量分配存储空间。</strong></p><p><strong>对于功能（FC），操作系统在L堆栈中给FC的临时变量分配存储空间。由于没有背景数据块，因而FC不能使用静态变量。输入、输出、I/O参数以指向实参的指针形式存储在操作系统为参数传递而保留的额外空间中。</strong></p><p><strong>对于组织块（OB）来说，其调用是由操作系统管理的，用户不能参与。因此，OB只有定义在L堆栈中的临时变量。</strong></p><p><strong></strong></p><p><strong>（2）逻辑块局部变量的数据类型</strong></p><p><strong>局部变量可以是基本数据类型或复式数据类型，也可以是专门用于参数传递的所谓的“参数类型”。参数类型包括定时器、计数器、块的地址或指针等。</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15355243751414c56a2fcd4><p class=pgc-img-caption></p></div><p><strong>（3）逻辑块的调用过程及内存分配</strong></p><p><strong>CPU提供块堆栈（B堆栈）来存储与处理被中断块的有关信息。</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535524388941a4462d316a><p class=pgc-img-caption></p></div><p><strong>用户程序使用的堆栈：</strong></p><p><strong>局部数据堆栈简称L堆栈，是CPU中单独的存储器区，可用来存储逻辑块的局部变量（包括OB的起始信息）、调用功能（FC）时要传递的实际参数、梯形图程序中的中间逻辑结果等。可以按位、字节、字和双字来存取。</strong></p><p><strong>块堆栈简称B堆栈，是CPU系统内存中的一部分，用来存储被中断的块的类型、编号、优先级和返回地址；中断时打开的共享数据块和背景数据块的编号；临时变量的指针（被中断块的L堆栈地址）。</strong></p><p><strong>中断堆栈简称I堆栈，用来存储当前累加器和地址寄存器的内容、数据块寄存器DB和DI的内容、局域数据的指针、状态字、MCR（主控继电器）寄存器和B堆栈的指针。</strong></p><p><strong></strong></p><p><strong>调用功能块（FB）时的堆栈操作</strong></p><p><strong>当调用功能块（FB）时，会有以下事件发生：</strong></p><p><strong>①调用块的地址和返回位置存储在块堆栈中，调用块的临时变量压入L堆栈；②数据块DB寄存器内容与DI寄存器内容交换；③新的数据块地址装入DI寄存器；④被调用块的实参装入DB和L堆栈上部；⑤当功能块FB结束时，先前块的现场信息从块堆栈中弹出，临时变量弹出L堆栈；⑥DB和DI寄存器内容交换。</strong></p><p><strong>当调用功能块（FB）时，STEP 7并不一定要求给FB形参赋予实参，除非参数是复式数据类型的I/O形参或参数类型形参。如果没有给FB的形参赋予实参，则功能块（FB）就调用背景数据块内的数值，该数值是在功能块（FB）的变量声明表或背景数据块内为形参所设置初始数值。</strong></p><p><strong></strong></p><p><strong>调用功能（FC）时的堆栈操作</strong></p><p><strong>当调用功能（FC）时会有以下事件发生：</strong></p><p><strong>功能（FC）实参的指针存到调用块的L堆栈；调用块的地址和返回位置存储在块堆栈，调用块的局部数据压入L堆栈；功能（FC）存储临时变量的L堆栈区被推入L堆栈上部；当被调用功能（FC）结束时，先前块的信息存储在块堆栈中，临时变量弹出L堆栈。 因为功能（FC）不用背景数据块，不能分配初始数值给功能（FC）的局部数据，所以必须给功能（FC）提供实参。</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535524420448e7c43c8d0c><p class=pgc-img-caption>以功能（FC）调用为例，L堆栈操作示意如图所示。</p></div><p><strong>b 逻辑块（FC和FB）的编程</strong></p><p><strong>对逻辑块编程时必须编辑下列三个部分：</strong></p><p><strong>变量声明：分别定义形参、静态变量和临时变量（FC块中不包括静态变量）；确定各变量的声明类型（Decl.）、变量名（Name）和数据类型（Data Type），还要为变量设置初始值（Initial Value）。如果需要还可为变量注释（Comment）。在增量编程模式下，STEP 7将自动产生局部变量地址（Address）。</strong></p><p><strong>代码段：对将要由PLC进行处理的块代码进行编程。</strong></p><p><strong>块属性：块属性包含了其它附加的信息，例如由系统输入的时间标志或路径。此外，也可输入相关详细资料。</strong></p><p><strong>（1）临时变量的定义和使用</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535524457715a0ed520e06><p class=pgc-img-caption></p></div><p><strong>（2）查看局部数据堆栈的占用</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15355244699629a12925656><p class=pgc-img-caption></p></div><p><strong>（3）查看块所需字节数</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535524490235bdeb89a8c3><p class=pgc-img-caption></p></div><p><strong>（4）定义形式参数</strong></p><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15355245010220522286fab><p class=pgc-img-caption></p></div><p><strong>（5）编写控制程序</strong></p><p><strong>编写逻辑块（FC和FB）程序时，可以用以下两种方式使用局部变量：</strong></p><p><strong>①使用变量名，此时变量名前加前缀“#”，以区别于在符号表中定义的符号地址。增量方式下，前缀会自动产生。</strong></p><p><strong>②直接使用局部变量的地址，这种方式只对背景数据块和L堆栈有效。</strong></p><p><strong>在调用FB块时，要说明其背景数据块。背景数据块应在调用前生成，其顺序格式与变量声明表必须保持一致。</strong></p><p><strong></strong></p><p><strong></strong></p><p><strong></strong></p><blockquote><p><strong>更多PLC设计案例，关注头条号：溪谷公众号。</strong></p><p><strong></strong></p><p><strong>觉得有用就点击关注吧~</strong></p><p><strong>享受更多最新实用PLC干货知识！</strong></p><p><strong>（溪谷公众号）</strong></p></blockquote><div class=pgc-img><img alt=西门子S7程序结构与程序设计：老知识，新讲解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1535524568431bcb137b681><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'程序','西门子','S7'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>