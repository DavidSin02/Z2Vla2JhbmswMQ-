<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文搞定9大经典的算法思想 | 极客快訊</title><meta property="og:title" content="一文搞定9大经典的算法思想 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/ac893ead-1741-4d35-bc74-d6df13d7de85"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cd9b6420.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cd9b6420.html><meta property="article:published_time" content="2020-11-14T21:00:20+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:20+08:00"><meta name=Keywords content><meta name=description content="一文搞定9大经典的算法思想"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cd9b6420.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文搞定9大经典的算法思想</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>《数据结构与算法分析》一书中，除了分篇章介绍的不同类型数据结构及其具体实现算法。不同类型的常用算法思想贯通了全书，本文予以汇总并逐一介绍。</p><p>1. 递推法</p><p>2. 递归法</p><p>3. 穷举法（枚举法）</p><p>4. 贪心算法（贪婪算法）</p><p>5. 分治法(Divide and Conquer)</p><p>6. 动态规划法</p><p>7. 迭代法</p><p>8. 分支界限法</p><p>9. 回溯法</p><hr><h1 class=pgc-h-arrow-right>1. 递推法</h1><p>递推是序列计算机中的一种常用算法。它是按照一定的规律来计算序列中的每个项，通常是通过计算机前面的一些项来得出序列中的指定项的值。</p><p>其思想是把一个复杂的庞大的计算过程转化为简单过程的多次重复，该算法利用了计算机速度快和不知疲倦的机器特点。</p><p><br></p><p><strong>使用场景：</strong></p><ul><li>统计算法的时间复杂度（比如多层嵌套遍历时）；</li><li>现实场景，如下列示例所示：</li></ul><p>题：植树节那天，有五位同学参加了植树活动，他们完成植树的棵树都不相同。问第一位同学植了多少棵时，他指着旁边的第二位同学说比他多植了两棵；追问第二位同学，他又说比第三位同学多植了两棵；... 如此，都说比另一位同学多植两棵。最后问到第五位同学时，他说自己植了10棵。到底第一位同学植了多少棵树？</p><p>答：本程序的递推运算可用下图示表示：</p><p>初始值a:=10 ----- i=1,a=a+2(12) ----- i=2,a=a+2(14) ------ i=3,a=a+2(16) ----- i=4,a=a+2(18) ---- 输出a值18</p><p><br></p><h1 class=pgc-h-arrow-right>2. 递归法</h1><ul><li>程序调用自身的编程技巧称为递归（recursion）。一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法。</li><li>递归法是设计和描述算法的一种有力的工具，由于它在复杂算法的描述中被经常采用，为此在进一步介绍其他算法设计方法之前先讨论它。</li></ul><p><strong>递归算法特性：</strong></p><ul><li>它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</li><li>递归的能力在于用有限的语句来定义对象的无限集合。</li><li>一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</li></ul><p><strong>算法设计的注意事项：</strong></p><p>(1) 递归就是在过程或函数里调用自身;</p><p>(2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</p><p><strong>使用场景：</strong></p><ul><li>磁盘目录&文件遍历（File，B树结构）</li><li>更宽泛的树遍历</li><li>斐波那契数列的计算</li></ul><p>【问题】 编写计算斐波那契（Fibonacci）数列的第n项函数fib（n）。斐波那契数列为：0、1、1、2、3、……，即：</p><p>fib(0)=0;</p><p>fib⑴=1;</p><p>fib(n)=fib(n-1）+fib(n-2） （当n>1时）。</p><p>写成递归函数有：</p><pre><code>int fib(int n){if (n==0) return 0;if (n==1） return 1;if (n&gt;1） return fib(n-1）+fib(n-2）；}</code></pre><p><br></p><h1 class=pgc-h-arrow-right>3. 穷举法（枚举法）</h1><p>穷举法，或称为暴力破解法，其基本思路是：对于要解决的问题，列举出它的所有可能的情况，逐个判断有哪些是符合问题所要求的条件，从而得到问题的解。</p><p>穷举法是利用计算机运算速度快、精确度高的特点，对要解决问题的所有可能情况，一个不漏地进行检验，从中找出符合要求的答案，因此枚举法是通过牺牲时间来换取答案的全面性。</p><p><br></p><p><strong>算法结构：</strong></p><p>一般使用while循环。</p><p><br></p><p><strong>使用场景：</strong></p><ul><li>密码的破译，即将密码进行逐个推算直到找出真正的密码为止。</li><li>例如一个已知是四位并且全部由数字组成的密码，其可能共有10000种组合，因此最多尝试10000次就能找到正确的密码。理论上利用这种方法可以破解任何一种密码，问题只在于如何缩短试误时间。因此有些人运用计算机来增加效率，有些人辅以字典来缩小密码组合的范围。</li></ul><p><br></p><h1 class=pgc-h-arrow-right>4. 贪心算法（贪婪算法）</h1><ul><li>贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。</li><li>用贪心法设计算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，它省去了为找最优解要穷尽所有可能而必须耗费的大量时间，它采用自顶向下,以迭代的方法做出相继的贪心选择,每做一次贪心选择就将所求问题简化为一个规模更小的子问题。</li><li>通过每一步贪心选择,可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。</li></ul><p><br></p><p><strong>量度标准的选择：</strong></p><ul><li>对于一个给定的问题，往往可能有好几种量度标准。</li><li>初看起来，这些量度标准似乎都是可取的，但实际上，用其中的大多数量度标准作贪婪处理所得到该量度意义下的最优解并不是问题的最优解，而是次优解。</li><li>因此，选择能产生问题最优解的最优量度标准是使用贪婪算法的核心。</li><li>一般情况下，要选出最优量度标准并不是一件容易的事，但对某问题能选择出最优量度标准后，用贪婪算法求解则特别有效。</li></ul><p><br></p><p><strong>贪婪算法&动态规划算法的区别：</strong></p><ul><li>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。运用贪心策略在每一次转化时都取得了最优解。</li><li>问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。</li><li>贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。</li><li>贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。</li><li>动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</li></ul><p><br></p><p><strong>使用场景：</strong></p><ul><li>密码的破译，即将密码进行逐个推算直到找出真正的密码为止。</li><li>辅币找零钱，比如中如何找到17美元61美分的零钱（10美元+5美元+2张1美元+2个25分币+10分币+1分币）。</li></ul><p><br></p><p><strong>5. 分治法(Divide and Conquer)</strong></p><ul><li>分：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</li><li>治：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题；</li><li>合：将各个子问题的解合并为原问题的解。</li></ul><p><strong>分治法所能解决的问题一般具有以下几个特征：</strong></p><ul><li>该问题的规模缩小到一定的程度就可以容易地解决；</li><li>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质；</li><li>利用该问题分解出的子问题的解可以合并为该问题的解；</li><li>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</li></ul><p><strong>使用场景：</strong></p><ul><li>二分搜索（折半查找）</li><li>合并排序</li><li>快速排序</li><li>大整数乘法</li><li>Strassen矩阵乘法</li><li>棋盘覆盖</li><li>线性时间选择</li><li>最接近点对问题</li><li>循环赛日程表</li><li>汉诺塔</li></ul><p><br></p><h1 class=pgc-h-arrow-right>6. 动态规划法</h1><ul><li>动态规划是一种在数学和计算机科学中使用的，用于求解包含重叠子问题的最优化问题的方法。其基本思想是，将原问题分解为相似的子问题，在求解的过程中通过子问题的解求出原问题的解。</li><li>动态规划的思想是多种算法的基础，被广泛应用于计算机科学和工程领域。</li><li>动态规划程序设计是对解最优化问题的一种途径、一种方法，而不是一种特殊算法。</li></ul><p><br></p><p><strong>动态规划算法特性：</strong></p><ul><li>不象前面所述的那些搜索或数值计算那样，具有一个标准的数学表达式和明确清晰的解题方法。</li><li>动态规划程序设计往往是针对一种最优化问题，由于各种问题的性质不同，确定最优解的条件也互不相同，因而动态规划的设计方法对不同的问题，有各具特色的解题方法，而不存在一种万能的动态规划算法，可以解决各类最优化问题。</li><li>因此读者在学习时，除了要对基本概念和方法正确理解外，必须具体问题具体分析处理，以丰富的想象力去建立模型，用创造性的技巧去求解。</li></ul><p><br></p><p>动态规划一般可分为线性动规，区域动规，树形动规，揹包动规四类。</p><ul><li>线性动规：拦截导弹，合唱队形，挖地雷，建学校，剑客决斗等；</li><li>区域动规：石子合并， 加分二叉树，统计单词个数，炮兵布阵等；</li><li>树形动规：贪吃的九头龙，二分查找树，聚会的欢乐，数字三角形等；</li><li>揹包问题：01揹包问题，完全揹包问题，分组揹包问题，二维揹包，装箱问题，挤牛奶（同济ACM第1132题）等；</li></ul><p><br></p><p><strong>使用场景：</strong></p><ul><li>最短路径问题 ；</li><li>项目管理；</li><li>网络流优化；</li><li>POJ动态规划题目列表：</li></ul><p><br></p><h1 class=pgc-h-arrow-right>7. 迭代法</h1><ul><li>迭代法也称辗转法，是一种不断用变量的旧值递推新值的过程，跟迭代法相对应的是直接法（或者称为一次解法），即一次性解决问题。</li><li>迭代法又分为精确迭代和近似迭代。“二分法”和“牛顿迭代法”属于近似迭代法。迭代算法是用计算机解决问题的一种基本方法。</li><li>它利用计算机运算速度快、适合做重复性操作的特点，让计算机对一组指令（或一定步骤）进行重复执行，</li><li>在每次执行这组指令（或这些步骤）时，都从变量的原值推出它的一个新值。</li></ul><p><br></p><p><strong>算法特性：</strong></p><p>利用迭代算法解决问题，需要做好以下三个方面的工作：</p><ul><li>确定迭代变量：在可以用迭代算法解决的问题中，至少存在一个直接或间接地不断由旧值递推出新值的变量，这个变量就是迭代变量。</li><li>建立迭代关系式：所谓迭代关系式，指如何从变量的前一个值推出其下一个值的公式（或关系）。迭代关系式的建立是解决迭代问题的关键，通常可以顺推或倒推的方法来完成。</li><li>对迭代过程进行控制：在什么时候结束迭代过程？这是编写迭代程序必须考虑的问题。不能让迭代过程无休止地重复执行下去。迭代过程的控制通常可分为两种情况：一种是所需的迭代次数是个确定的值，可以计算出来；另一种是所需的迭代次数无法确定。对于前一种情况，可以构建一个固定次数的循环来实现对迭代过程的控制；对于后一种情况，需要进一步分析出用来结束迭代过程的条件。</li></ul><p><br></p><p><strong>使用场景：</strong></p><ul><li>举例：验证谷角猜想。</li></ul><p>日本数学家谷角静夫在研究自然数时发现了一个奇怪现象：对于任意一个自然数 n ，若 n 为偶数，则将其除以 2 ；若 n 为奇数，则将其乘以 3 ，然后再加 1。如此经过有限次运算后，总可以得到自然数 1。人们把谷角静夫的这一发现叫做“谷角猜想”。</p><p>要求：编写一个程序，由键盘输入一个自然数 n ，把 n 经过有限次运算后，最终变成自然数 1 的全过程打印出来。</p><p>分析：定义迭代变量为 n ，按照谷角猜想的内容，可以得到两种情况下的迭代关系式：当 n 为偶数时， n=n/2 ；当 n 为奇数时， n=n*3+1。用 QBASIC 语言把它描述出来就是：</p><pre><code>if n 为偶数 thenn=n/2elsen=n*3+1end if</code></pre><p>这就是需要计算机重复执行的迭代过程。这个迭代过程需要重复执行多少次，才能使迭代变量 n 最终变成自然数 1 ，这是我们无法计算出来的。</p><p><br></p><h1 class=pgc-h-arrow-right>8. 分支界限法</h1><ul><li>分枝界限法是一个用途十分广泛的算法，运用这种算法的技巧性很强，不同类型的问题解法也各不相同。</li><li>分支定界法的基本思想是对有约束条件的最优化问题的所有可行解（数目有限）空间进行搜索。</li><li>该算法在具体执行时，把全部可行的解空间不断分割为越来越小的子集（称为分支），并为每个子集内的解的值计算一个下界或上界（称为定界）。</li><li>在每次分支后，对凡是界限超出已知可行解值那些子集不再做进一步分支，这样，解的许多子集（即搜索树上的许多结点）就可以不予考虑了，从而缩小了搜索范围。</li><li>这一过程一直进行到找出可行解为止，该可行解的值不大于任何子集的界限。因此这种算法一般可以求得最优解。</li></ul><p><strong>常见两种方法：</strong></p><ul><li>队列式(FIFO)分支限界法：按照队列先进先出（FIFO）原则选取下一个节点为扩展节点。</li><li>优先队列式分支限界法：按照优先队列中规定的优先级选取优先级最高的节点成为当前扩展节点。</li></ul><p><strong>分支限界法的特性：</strong></p><ul><li>与贪心算法一样，这种方法也是用来为组合优化问题设计求解算法的，所不同的是它在问题的整个可能解空间搜索，所设计出来的算法虽其时间复杂度比贪婪算法高。</li><li>它的优点是与穷举法类似，都能保证求出问题的最佳解，而且这种方法不是盲目的穷举搜索，而是在搜索过程中通过限界，可以中途停止对某些不可能得到最优解的子空间进一步搜索（类似于人工智能中的剪枝），故它比穷举法效率更高。</li></ul><p><strong>分支限界法与回溯法的区别：</strong></p><ul><li>求解目标：回溯法的求解目标是找出解空间树中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出在某种意义下的最优解。</li><li>搜索方式的不同：回溯法以深度优先的方式搜索解空间树，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。</li></ul><p><strong>使用场景：</strong></p><ul><li>解空间树的动态搜索：分支限界法首先确定一个合理的限界函数，并根据限界函数确定目标函数的界[down, up]；然后按照广度优先策略遍历问题的解空间树，在某一分支上，依次搜索该结点的所有孩子结点，分别估算这些孩子结点的目标函数的可能取值（对最小化问题，估算结点的down，对最大化问题，估算结点的up）。如果某孩子结点的目标函数值超出目标函数的界，则将其丢弃（从此结点生成的解不会比如今已得的更好），否则入待处理表 。</li></ul><p><br></p><h1 class=pgc-h-arrow-right>9. 回溯法</h1><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p><strong>算法的基本思想：</strong></p><ul><li>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。</li><li>其实回溯法就是对隐式图的深度优先搜索算法。</li><li>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</li></ul><p><strong>使用场景：</strong></p><p>回溯算法其实是一种穷举算法，将所有可能发生的情况都列举一遍，选择可行解或最优解。 用于搜索算法中，比如：</p><ul><li>数独；</li><li>八皇后问题；</li><li>全排列；</li><li>0-1 揹包；</li><li>正则表达式匹配；</li><li>编译原理中语法分析等</li></ul><p><br></p><div class=pgc-img><img alt=一文搞定9大经典的算法思想 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/ac893ead-1741-4d35-bc74-d6df13d7de85><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'大经典','搞定','算法'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>