<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SpringBoot｜第二十章：异步开发之异步请求 | 极客快訊</title><meta property="og:title" content="SpringBoot｜第二十章：异步开发之异步请求 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/06812bbf96624d6a94aad8694d5f523e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ced5638.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ced5638.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ced5638.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="SpringBoot｜第二十章：异步开发之异步请求"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ced5638.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SpringBoot｜第二十章：异步开发之异步请求</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>前言</p><blockquote><p><em>关于web开发的相关知识点，后续有补充时再开续写了。比如webService服务、发邮件等，这些一般上觉得不完全属于web开发方面的，而且目前webService作为一个接口来提供服务的机会应该比较小了吧。所以本章节开始，开始讲解关于异步开发过程中会使用到的一些知识点。本章节就来讲解下异步请求相关知识点。</em></p></blockquote><p>一点知识</p><p>何为异步请求</p><p>在Servlet 3.0之前，Servlet采用Thread-Per-Request的方式处理请求，即每一次Http请求都由某一个线程从头到尾负责处理。如果一个请求需要进行IO操作，比如访问数据库、调用第三方服务接口等，那么其所对应的线程将<strong>同步地等待<em>**</em></strong>IO操作完成， 而IO操作是<strong>非常慢</strong>的，所以此时的线程并不能及时地释放回线程池以供后续使用，在并发量越来越大的情况下，这将带来严重的性能问题。其请求流程大致为：</p><div class=pgc-img><img alt=SpringBoot｜第二十章：异步开发之异步请求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/06812bbf96624d6a94aad8694d5f523e><p class=pgc-img-caption></p></div><p>而在Servlet3.0发布后，提供了一个新特性：<strong>异步处理请求</strong>。可以<strong>先释放</strong>容器分配给请求的线程与相关资源，减轻系统负担，释放了容器所分配线程的请求，其<strong>响应将被延后</strong>，可以在耗时处理完成（例如长时间的运算）时再对客户端进行响应。其请求流程为：</p><div class=pgc-img><img alt=SpringBoot｜第二十章：异步开发之异步请求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e8151d8ab8e54bb192e6a7e9e3c021b4><p class=pgc-img-caption></p></div><p>在Servlet 3.0后，我们可以从HttpServletRequest对象中获得一个<strong>AsyncContext</strong>对象，该对象构成了异步处理的上下文，Request和Response对象都可从中获取。AsyncContext可以从当前线程传给另外的线程，并在新的线程中完成对请求的处理并返回结果给客户端，初始线程便可以还回给容器线程池以处理更多的请求。如此，通过将请求从一个线程传给另一个线程处理的过程便构成了Servlet 3.0中的异步处理。</p><hr><p><strong>多说几句：</strong></p><p>随着Spring5发布，提供了一个响应式Web框架：Spring WebFlux。之后可能就不需要Servlet容器的支持了。以下是其先后对比图：</p><div class=pgc-img><img alt=SpringBoot｜第二十章：异步开发之异步请求 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0ad197fa49a84a0cab3c4fbe2110d30b><p class=pgc-img-caption></p></div><p>左侧是传统的基于Servlet的Spring Web MVC框架，右侧是5.0版本新引入的基于Reactive Streams的Spring WebFlux框架，从上到下依次是<strong>Router Functions</strong>，<strong>WebFlux</strong>，<strong>Reactive Streams</strong>三个新组件。</p><p>对于其发展前景还是拭目以待吧。有时间也该去了解下Spring5了。</p><hr><p>原生异步请求API说明</p><p>在编写实际代码之前，我们来了解下一些关于异步请求的api的调用说明。</p><ul><li>获取AsyncContext：根据HttpServletRequest对象获取。</li></ul><p class=ql-align-right>AsyncContext asyncContext = request.startAsync();</p><ul><li>设置监听器:可设置其开始、完成、异常、超时等事件的回调处理</li></ul><p>其监听器的接口代码：</p><p><strong>public</strong> <strong>interface</strong> AsyncListener <strong>extends</strong> EventListener {</p><p><strong>void</strong> onComplete(AsyncEvent event) <strong>throws</strong> IOException;</p><p><strong>void</strong> onTimeout(AsyncEvent event) <strong>throws</strong> IOException;</p><p><strong>void</strong> onError(AsyncEvent event) <strong>throws</strong> IOException;</p><p><strong>void</strong> onStartAsync(AsyncEvent event) <strong>throws</strong> IOException;</p><p>}</p><p><strong>说明：</strong></p><ol><li>onStartAsync：异步线程开始时调用</li><li>onError：异步线程出错时调用</li><li>onTimeout：异步线程执行超时调用</li><li>onComplete：异步执行完毕时调用</li></ol><p>一般上，我们在超时或者异常时，会返回给前端相应的提示，比如说超时了，请再次请求等等，根据各业务进行自定义返回。同时，在异步调用完成时，一般需要执行一些清理工作或者其他相关操作。</p><p>需要注意的是只有在调用request.startAsync前将监听器添加到AsyncContext，监听器的onStartAsync方法才会起作用，而调用startAsync前AsyncContext还不存在，所以第一次调用startAsync是不会被监听器中的onStartAsync方法捕获的，只有在超时后又重新开始的情况下onStartAsync方法才会起作用。</p><ul><li>设置超时：通过setTimeout方法设置，单位：毫秒。</li></ul><p><strong>一定要设置超时时间</strong>，不能无限等待下去，不然和正常的请求就一样了。。</p><p>Servlet方式实现异步请求</p><p>前面已经提到，可通过HttpServletRequest对象中获得一个<strong>AsyncContext</strong>对象，该对象构成了异步处理的上下文。所以，我们来实际操作下。</p><p>0.编写一个简单控制层</p><p>/**</p><p>* 使用servlet方式进行异步请求</p><p>* @author oKong</p><p>*</p><p>*/</p><p>@Slf4j</p><p>@RestController</p><p><strong>public</strong> <strong>class</strong> ServletController {</p><p>@RequestMapping("/servlet/orig")</p><p><strong>public</strong> <strong>void</strong> todo(HttpServletRequest request,</p><p>HttpServletResponse response) <strong>throws</strong> Exception {</p><p>//这里来个休眠</p><p>Thread.sleep(100);</p><p>response.getWriter().println("这是【正常】的请求返回");</p><p>}</p><p>@RequestMapping("/servlet/async")</p><p><strong>public</strong> <strong>void</strong> todoAsync(HttpServletRequest request,</p><p>HttpServletResponse response) {</p><p>AsyncContext asyncContext = request.startAsync();</p><p>asyncContext.addListener(<strong>new</strong> AsyncListener() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onTimeout(AsyncEvent event) <strong>throws</strong> IOException {</p><p>log.info("超时了：");</p><p>//做一些超时后的相关操作</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onStartAsync(AsyncEvent event) <strong>throws</strong> IOException {</p><p>// TODO Auto-generated method stub</p><p>log.info("线程开始");</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onError(AsyncEvent event) <strong>throws</strong> IOException {</p><p>log.info("发生错误：",event.getThrowable());</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> onComplete(AsyncEvent event) <strong>throws</strong> IOException {</p><p>log.info("执行完成");</p><p>//这里可以做一些清理资源的操作</p><p>}</p><p>});</p><p>//设置超时时间</p><p>asyncContext.setTimeout(200);</p><p>//也可以不使用start 进行异步调用</p><p>// new Thread(new Runnable() {</p><p>//</p><p>// @Override</p><p>// public void run() {</p><p>// 编写业务逻辑</p><p>//</p><p>// }</p><p>// }).start();</p><p>asyncContext.start(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p><strong>try</strong> {</p><p>Thread.sleep(100);</p><p>log.info("内部线程：" + Thread.currentThread().getName());</p><p>asyncContext.getResponse().setCharacterEncoding("utf-8");</p><p>asyncContext.getResponse().setContentType("text/html;charset=UTF-8");</p><p>asyncContext.getResponse().getWriter().println("这是【异步】的请求返回");</p><p>} <strong>catch</strong> (Exception e) {</p><p>log.error("异常：",e);</p><p>}</p><p>//异步请求完成通知</p><p>//此时整个请求才完成</p><p>//其实可以利用此特性 进行多条消息的推送 把连接挂起。。</p><p>asyncContext.complete();</p><p>}</p><p>});</p><p>//此时之类 request的线程连接已经释放了</p><p>log.info("线程：" + Thread.currentThread().getName());</p><p>}</p><p>}</p><p><strong>注意：异步请求时，可以利用ThreadPoolExecutor自定义个线程池。</strong></p><p>1.启动下应用，查看控制台输出就可以获悉是否在同一个线程里面了。同时，可设置下等待时间，之后就会调用超时回调方法了。大家可自己试试。</p><p>2018-08-15 23:03:04.082 INFO 6732 --- [nio-8080-exec-1] c.l.l.s.controller.ServletController : 线程：http-nio-8080-exec-1</p><p>2018-08-15 23:03:04.183 INFO 6732 --- [nio-8080-exec-2] c.l.l.s.controller.ServletController : 内部线程：http-nio-8080-exec-2</p><p>2018-08-15 23:03:04.190 INFO 6732 --- [nio-8080-exec-3] c.l.l.s.controller.ServletController : 执行完成</p><p><strong>使用过滤器时，需要加入asyncSupported为true配置，开启异步请求支持。</strong></p><p class=ql-align-right>1</p><p class=ql-align-right>2</p><p>@WebServlet(urlPatterns = "/okong", asyncSupported = <strong>true</strong> )</p><p><strong>public</strong> <strong>class</strong> AsyncServlet <strong>extends</strong> HttpServlet ...</p><p><strong>题外话：</strong>其实我们可以利用在未执行asyncContext.complete()方法时请求未结束这特性，可以做个简单的文件上传进度条之类的功能。但注意请求是会超时的，需要设置超时的时间下。</p><p>Spring方式实现异步请求</p><blockquote><p><em>在Spring中，有多种方式实现异步请求，比如callable、DeferredResult或者WebAsyncTask。每个的用法略有不同，可根据不同的业务场景选择不同的方式。以下主要介绍一些常用的用法</em></p></blockquote><p>Callable</p><blockquote><p><em>使用很简单，直接返回的参数包裹一层callable即可。</em></p></blockquote><p>用法</p><p>@RequestMapping("/callable")</p><p><strong>public</strong> Callable&lt;String> callable() {</p><p>log.info("外部线程：" + Thread.currentThread().getName());</p><p><strong>return</strong> <strong>new</strong> Callable&lt;String>() {</p><p>@Override</p><p><strong>public</strong> String call() <strong>throws</strong> Exception {</p><p>log.info("内部线程：" + Thread.currentThread().getName());</p><p><strong>return</strong> "callable!";</p><p>}</p><p>};</p><p>}</p><p>控制台输出：</p><p>2018-08-15 23:32:22.317 INFO 15740 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : 外部线程：http-nio-8080-exec-2</p><p>2018-08-15 23:32:22.323 INFO 15740 --- [ MvcAsync1] c.l.l.s.controller.SpringController : 内部线程：MvcAsync1</p><p>超时、自定义线程设置</p><p>从控制台可以看见，异步响应的线程使用的是名为：MvcAsync1的线程。第一次再访问时，就是MvcAsync2了。若采用默认设置，会无限的创建新线程去处理异步请求，所以正常都需要配置一个线程池及超时时间。</p><p>编写一个配置类：CustomAsyncPool.java</p><p class=ql-align-right><br></p><p>@Configuration</p><p><strong>public</strong> <strong>class</strong> CustomAsyncPool <strong>extends</strong> WebMvcConfigurerAdapter{</p><p>/**</p><p>* 配置线程池</p><p>* @return</p><p>*/</p><p>@Bean(name = "asyncPoolTaskExecutor")</p><p><strong>public</strong> ThreadPoolTaskExecutor getAsyncThreadPoolTaskExecutor() {</p><p>ThreadPoolTaskExecutor taskExecutor = <strong>new</strong> ThreadPoolTaskExecutor();</p><p>taskExecutor.setCorePoolSize(20);</p><p>taskExecutor.setMaxPoolSize(200);</p><p>taskExecutor.setQueueCapacity(25);</p><p>taskExecutor.setKeepAliveSeconds(200);</p><p>taskExecutor.setThreadNamePrefix("callable-");</p><p>// 线程池对拒绝任务（无线程可用）的处理策略，目前只支持AbortPolicy、CallerRunsPolicy；默认为后者</p><p>taskExecutor.setRejectedExecutionHandler(<strong>new</strong> ThreadPoolExecutor.CallerRunsPolicy());</p><p>taskExecutor.initialize();</p><p><strong>return</strong> taskExecutor;</p><p>}</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> configureAsyncSupport(<strong>final</strong> AsyncSupportConfigurer configurer) {</p><p>//处理 callable超时</p><p>configurer.setDefaultTimeout(60*1000);</p><p>configurer.registerCallableInterceptors(timeoutInterceptor());</p><p>configurer.setTaskExecutor(getAsyncThreadPoolTaskExecutor());</p><p>}</p><p>@Bean</p><p><strong>public</strong> TimeoutCallableProcessor timeoutInterceptor() {</p><p><strong>return</strong> <strong>new</strong> TimeoutCallableProcessor();</p><p>}</p><p>}</p><p>自定义一个超时异常处理类：CustomAsyncRequestTimeoutException.java</p><p>/**</p><p>* 自定义超时异常类</p><p>* @author oKong</p><p>*</p><p>*/</p><p><strong>public</strong> <strong>class</strong> CustomAsyncRequestTimeoutException <strong>extends</strong> RuntimeException {</p><p>/**</p><p>*</p><p>*/</p><p><strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 8754629185999484614L;</p><p><strong>public</strong> CustomAsyncRequestTimeoutException(String uri){</p><p><strong>super</strong>(uri);</p><p>}</p><p>}</p><p>同时，在<strong>统一异常</strong>处理加入对CustomAsyncRequestTimeoutException类的处理即可，这样就有个统一的配置了。</p><p>之后，再运行就可以看见使用了自定义的线程池了，超时的可以自行模拟下：</p><p>2018-08-15 23:48:29.022 INFO 16060 --- [nio-8080-exec-1] c.l.l.s.controller.SpringController : 外部线程：http-nio-8080-exec-1</p><p>2018-08-15 23:48:29.032 INFO 16060 --- [ oKong-1] c.l.l.s.controller.SpringController : 内部线程：oKong-1</p><p>DeferredResult</p><p>相比于callable，DeferredResult可以处理一些相对复杂一些的业务逻辑，最主要还是可以在另一个线程里面进行业务处理及返回，即可在两个完全不相干的线程间的通信。</p><p>/**</p><p>* 线程池</p><p>*/</p><p><strong>public</strong> <strong>static</strong> ExecutorService FIXED_THREAD_POOL = Executors.newFixedThreadPool(30);</p><p>@RequestMapping("/deferredresult")</p><p><strong>public</strong> DeferredResult&lt;String> deferredResult(){</p><p>log.info("外部线程：" + Thread.currentThread().getName());</p><p>//设置超时时间</p><p>DeferredResult&lt;String> result = <strong>new</strong> DeferredResult&lt;String>(60*1000L);</p><p>//处理超时事件 采用委托机制</p><p>result.onTimeout(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>log.error("DeferredResult超时");</p><p>result.setResult("超时了!");</p><p>}</p><p>});</p><p>result.onCompletion(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>//完成后</p><p>log.info("调用完成");</p><p>}</p><p>});</p><p>FIXED_THREAD_POOL.execute(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>//处理业务逻辑</p><p>log.info("内部线程：" + Thread.currentThread().getName());</p><p>//返回结果</p><p>result.setResult("DeferredResult!!");</p><p>}</p><p>});</p><p><strong>return</strong> result;</p><p>}</p><p>控制台输出：</p><p>2018-08-15 23:52:27.841 INFO 12984 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : 外部线程：http-nio-8080-exec-2</p><p>2018-08-15 23:52:27.843 INFO 12984 --- [pool-1-thread-1] c.l.l.s.controller.SpringController : 内部线程：pool-1-thread-1</p><p>2018-08-15 23:52:27.872 INFO 12984 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : 调用完成</p><p><strong>注意：返回结果时记得调用下setResult方法。</strong></p><p><strong>题外话：利用DeferredResult可实现一些长连接的功能，比如当某个操作是异步时，我们可以保存这个DeferredResult对象，当异步通知回来时，我们在找回这个DeferredResult对象，之后在setResult会结果即可。提高性能。</strong></p><p>WebAsyncTask</p><p>使用方法都类似，只是WebAsyncTask是直接返回了。觉得就是写法不同而已，更多细节希望大神解答！</p><p>@RequestMapping("/webAsyncTask")</p><p><strong>public</strong> WebAsyncTask&lt;String> webAsyncTask() {</p><p>log.info("外部线程：" + Thread.currentThread().getName());</p><p>WebAsyncTask&lt;String> result = <strong>new</strong> WebAsyncTask&lt;String>(60*1000L, <strong>new</strong> Callable&lt;String>() {</p><p>@Override</p><p><strong>public</strong> String call() <strong>throws</strong> Exception {</p><p>log.info("内部线程：" + Thread.currentThread().getName());</p><p><strong>return</strong> "WebAsyncTask!!!";</p><p>}</p><p>});</p><p>result.onTimeout(<strong>new</strong> Callable&lt;String>() {</p><p>@Override</p><p><strong>public</strong> String call() <strong>throws</strong> Exception {</p><p>// TODO Auto-generated method stub</p><p><strong>return</strong> "WebAsyncTask超时!!!";</p><p>}</p><p>});</p><p>result.onCompletion(<strong>new</strong> Runnable() {</p><p>@Override</p><p><strong>public</strong> <strong>void</strong> run() {</p><p>//超时后 也会执行此方法</p><p>log.info("WebAsyncTask执行结束");</p><p>}</p><p>});</p><p><strong>return</strong> result;</p><p>}</p><p>控制台输出：</p><p>2018-08-15 23:55:02.568 INFO 2864 --- [nio-8080-exec-1] c.l.l.s.controller.SpringController : 外部线程：http-nio-8080-exec-1</p><p>2018-08-15 23:55:02.587 INFO 2864 --- [ oKong-1] c.l.l.s.controller.SpringController : 内部线程：oKong-1</p><p>2018-08-15 23:55:02.615 INFO 2864 --- [nio-8080-exec-2] c.l.l.s.controller.SpringController : WebAsyncTask执行结束</p><p>参考资料</p><ol><li>https://blog.csdn.net/paincupid/article/details/52266905</li><li>https://docs.spring.io/spring/docs/4.3.18.RELEASE/spring-framework-reference/htmlsingle/#mvc-ann-async</li></ol><p>总结</p><blockquote><p><em>本章节主要是讲解了异步请求的使用及相关配置，如超时，异常等处理。设置异步请求时，记得不要忘记设置超时时间。</em><strong><em>异步请求只是提高了服务的吞吐量，提高单位时间内处理的请求数，并不会加快处理效率的，这点需要注意。</em></strong><em>。下一章节，讲讲使用@Async进行异步调用相关知识。</em></p></blockquote><p>最后</p><blockquote><p><em>目前互联网上很多大佬都有SpringBoot系列教程，如有雷同，请多多包涵了。若文中有所错误之处，还望提出，谢谢。</em></p></blockquote><div class=pgc-img><img alt=SpringBoot｜第二十章：异步开发之异步请求 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a8cdeaee49e4ff48025779c5de9a619><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'异步','SpringBoot','开发'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>