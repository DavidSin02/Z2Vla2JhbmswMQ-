<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>我对 MySQL 锁、事务、MVCC 的一些认识 | 极客快訊</title><meta property="og:title" content="我对 MySQL 锁、事务、MVCC 的一些认识 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf061a5c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf061a5c.html><meta property="article:published_time" content="2020-11-14T21:08:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:11+08:00"><meta name=Keywords content><meta name=description content="我对 MySQL 锁、事务、MVCC 的一些认识"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cf061a5c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>我对 MySQL 锁、事务、MVCC 的一些认识</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>单条SQL语句执行时，会被当成一个事务提交吗？</h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">以下内容摘自 《高性能MySQL》(第3版)</span></p><blockquote><p><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#f5f5f5;--tt-darkmode-bgcolor: #1C1C1C">“</span></span></p><p><span style="background-color:#f5f5f5;--tt-darkmode-bgcolor: #1C1C1C">MySQL默认采用自动提交（AUTOCOMMIT）模式。也就是说，如果不是显式地开始一个事务，则每个查询都被当作一个事务执行提交操作。在当前连接中，可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式</span></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#f5f5f5;--tt-darkmode-bgcolor: #1C1C1C">”</span></span></p></blockquote><div class=pgc-img><img alt="我对 MySQL 锁、事务、MVCC 的一些认识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>MySQL 是如何实现事务的 ACID 的？<br></strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">事务具有 ACID 四大特性，那么 MySQL 是如何实现事务的这四个属性的呢？</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">原子性 要么全部成功，要么全部失败。MySQL是通过记录 undo_log 的方式来实现的原子性。undo_log 即</span><span style="color:#f83929;--tt-darkmode-color: #F83929">回滚日志</span>，在真正的SQL执行之前先将 undo_log 写入磁盘，然后再对数据库的数据进行操作。如果发生异常或回滚，就可以依据 undo_log 进行反向操作，恢复数据在事务执行之前的样子。</li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">持久性 事务一旦被正常提交，它对数据库的影响就应该是永久的。此时即使系统崩溃，修改的数据也不会丢失。InnoDB 作为 MySQ L的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB 提供了缓存(Buffer Pool)，作为访问数据库的缓冲：当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool ；当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中。这样的设计也带来了相应的问题：如果数据提交了，这时数据还在缓冲池里（还没刷盘），此时MySQL宕机、断电了怎么办？数据会不会丢失？答案是不会，MySQL 通过 redo_log 的机制，保证了持久性。redo_log 即</span><span style="color:#f83929;--tt-darkmode-color: #F83929">重做日志</span>，简单说就是当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo_log 记录这次操作；当事务提交时，会调用 fsync 接口对 redo_log 进行刷盘。如果MySQL宕机，重启时可以读取 redo_log 中的数据，对数据库进行恢复。</li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">隔离性隔离性是 ACID 里面最复杂的一个，这里面涉及到隔离级别的概念，一共有四个</span><span style="color:#f83929;--tt-darkmode-color: #F83929">简单说隔离级别就是规定了：一个事务中数据的修改，哪些事务之间可见，哪些不可见。而隔离性就是要管理多个并发读写请求的访问顺序。</span>MySQL 对于隔离性的具体实现我们后面会展开说。</li><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Read uncommitted</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Read committed</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Repeatable read</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Serializable</span></li></ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">一致性通过回滚、恢复和在并发环境下的隔离做到一致性。</span></li></ul><h1 class=pgc-h-arrow-right><strong>事务并发可能导致的问题</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">通过上个问题我知道单条 DDL 执行也会被当成一个事务自动提交，那么无论是多条SQL并发，还是多个自己手动组织的包含多条SQL的事务并发，都会导致事务并发问题。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">具体来说有：</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">脏写 （一个事务提交的数据覆盖了另一个事务未提交的数据）</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">脏读 （一个事务读取到另一个事务未提交的数据）</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">不可重复读 （重点在于update和delete 一个事务内多次读取的数据不一样）</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">幻读 （重点在于insert 一个事务内多次读取的记录数不一样）</span></li></ul><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">上面我们提到了事务的隔离级别，MySQL 的所有隔离级别都能保证不产生脏写，所以就剩下脏读、不可重复读和幻读的问题了。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">下面具体看下各隔离级别是如何解决或未解决上面这些问题的：</span></p><div class=pgc-img><img alt="我对 MySQL 锁、事务、MVCC 的一些认识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c525f4cbf1ad4bfabd6c9b5e42fb0c2f><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>Read uncommitted<br></strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">未提交读，这个级别在读的过程中不会加任何锁，只在写请求时加锁，所以写操作在读的过程中修改数据，就会造成脏读。也自然会产生不可重复读和幻读。</span></p><h1 class=pgc-h-arrow-right><strong>Read committed</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">已提交读，与未提交读一样也是读不加锁，写加锁。不一样的是利用了 MVCC 机制避免了脏读的问题，同样会有不可重复读和幻读的问题。关于 MVCC 我们后面会详细说。</span></p><h1 class=pgc-h-arrow-right><strong>Repeatable read</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">MySQL 默认的隔离级别，在这个级别 MySQL利用两种方式解决问题</span></p><ol start=1><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">读写锁 读读并行时加读锁，读读是共享锁的。只要有写请求就加写锁，这样读写是串行的。读取数据时加锁，其它事务无法修改这些数据。所以不会产生不可重复读。修改删除数据时也要加锁，其它事务无法读取这些数据，所以不会产生脏读。第一种方式就是我们常说的 </span><span style="color:#f83929;--tt-darkmode-color: #F83929">“悲观锁”</span>，数据在整个事务处理过程中处于锁定状态，比较保守，性能开销比较大。</li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">MVCC （后面讲）</span></li></ol><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">此外还利用了Next-Key锁 在一定程度上解决了幻读的问题。关于这个我们后面再说。</span></p><h1 class=pgc-h-arrow-right><strong>Serializable</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">在该隔离级别下事务都是串行顺序执行的。如果禁用了自动提交，则 InnoDB 会将所有普通的 SELECT 语句隐式转换为 SELECT ... LOCK IN SHARE MODE。即给读操作隐式加一把读共享锁，从而避免了脏读、不可重读复读和幻读问题。</span></p><h1 class=pgc-h-arrow-right><strong>MVCC</strong></h1><blockquote><p><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#f5f5f5;--tt-darkmode-bgcolor: #1C1C1C">“</span></span></p><p><span style="background-color:#f5f5f5;--tt-darkmode-bgcolor: #1C1C1C">Multiversion concurrency control (MCC or MVCC), is a concurrency control method commonly used by database management systems to provide concurrent access to the database and in programming languages to implement transactional memory</span></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#f5f5f5;--tt-darkmode-bgcolor: #1C1C1C">”</span></span></p></blockquote><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">翻译过来就是：多版本并发控制（MCC或MVCC）是一种并发控制方法，通常被数据库管理系统用来提供对数据库的并发访问，并以编程语言来实现事务存储。</span></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">简单来说就是数据库用来控制并发的一种方法。每个数据库对于 MVCC 的实现可能不一样。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">以我们常用的 MySQL 来说，MySQL 的 InnoDB 引擎实现了 MVCC 。</span></p><h1 class=pgc-h-arrow-right><strong>MVCC 能解决什么问题</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">从上面的定义我们能看出，MVCC 主要解决事务并发时数据一致性的问题</span></p><h1 class=pgc-h-arrow-right><strong>InnoDB 是如何实现的 MVCC</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">下面这个图来自《高性能MySQL》(第3版)</span></p><div class=pgc-img><img alt="我对 MySQL 锁、事务、MVCC 的一些认识" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6ba7e479aef044cea8d61379aab1dabf><p class=pgc-img-caption></p></div><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">这本书写的很好，翻译的也不错，我对于 MySQL 最初的系统性认识也是因为读了这本书，然而在对于 MVCC 是如何实现的讲述上，个人认为是有些问题的。</span></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">来看下哪里有问题</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">首先看下 MySQL 的官方文档，我对比了 5.1、5.6、5.7 三个版本的 </span><span style="color:#f83929;--tt-darkmode-color: #F83929">文档[1]</span> ，对 MVCC 这部分的描述，几乎是相同的。</li></ul><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">根据文档很明显是在每条数据增加三个隐藏列：</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">6字节的 DB_TRX_ID 字段，表示最近一次插入或者更新该记录的事务ID。</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">7字节的 DB_ROLL_PTR 字段，指向该记录的 rollback segment 的 undo log 记录。</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">6字节的 DB_ROW_ID，当有新数据插入的时候会自动递增。当表上没有用户主键的时候，InnoDB会自动产生聚集索引，包含DB_ROW_ID字段。</span></li></ul><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">这里我补充一张包含 rollback segment 的 MySQL 内部结构图</span></p><div class=pgc-img><img alt="我对 MySQL 锁、事务、MVCC 的一些认识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/116176c8a3cc4a4ea9f77d3b282860f9><p class=pgc-img-caption></p></div><p><span style="color:#f83929;--tt-darkmode-color: #F83929">版本链</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">之前我们讲过 undo_log 的概念，每条 undo日志都有一个 roll_pointer 属性，那么所有的版本都会被 roll_pointer 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。</span></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">ReadView</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">通过隐藏列和版本链，MySQL 可以将数据恢复到指定版本；但是具体要恢复到哪个版本，则需要根据 ReadView 来确定。所谓 ReadView，是指事务（记作事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行读操作时，会将读取到的数据中的事务 id 与 trx_sys 快照比较，从而判断数据对该 ReadView 是否可见，即对事务A是否可见。（</span><span style="color:#f83929;--tt-darkmode-color: #F83929">参考[2]</span>）</p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">至此我们发现 MVCC 就是基于隐藏字段、undo_log 链和 ReadView 来实现的。</span></p><h1 class=pgc-h-arrow-right><strong>Read committed 中的 MVCC</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">前面我们讲过 Read committed 隔离级别中使用 MVCC 解决脏读问题。这里我参考了两篇文章：</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">https://cloud.tencent.com/developer/article/1150633</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">https://cloud.tencent.com/developer/article/1150630</span></li></ul><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">InnoDB只会查找版本早于当前事务版本的数据行（也就是，行的版本号小于或是等于事务的系统版本号），这样可以确保数据读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或修改过的。</span><span style="color:#f83929;--tt-darkmode-color: #F83929">因此不会产生脏读</span>。</p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Read committed 隔离级别下出现不可重复读是由于 read view 的生成机制造成的。在 Read committed 级别下，只要当前语句执行前已经提交的数据都是可见的。在每次语句执行的过程中，都关闭 read view, 重新创建当前的一份 read view。这样就可以根据当前的全局事务链表创建 read view 的事务区间。简单说就是在 Read committed 隔离级别下，MVCC 在每次 select 时生成一个快照版本，所以每次 select 都会读到不同的版本数据，</span><span style="color:#f83929;--tt-darkmode-color: #F83929">所以会产生不可重复读</span>。</p><h1 class=pgc-h-arrow-right><strong>Repeatable read 中的 MVCC</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Repeatable read 隔离级别解决了不可重复读的问题，一个事务中多次读取不会出现不同的结果，保证了可重复读。前文中我们说 Repeatable read 有两种实现方式，一种是悲观锁的方式，相对的 MVCC 就是乐观锁的方式。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Repeatable read 隔离级别能解决不可重复读根本原因其实就是 read view 的生成机制和 Read committed 不同。</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Read committed ：只要是当前语句执行前已经提交的数据都是可见的。</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Repeatable read ：只要是当前事务执行前已经提交的数据都是可见的。</span></li></ul><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">不像 Read committed，在 Repeatable read 的隔离级别下，创建事务的时候，就生成了当前的 global read view,一直维持到事务结束。这样就能实现可重复读。</span></p><h1 class=pgc-h-arrow-right><strong>幻读与 Next-Key 锁</strong></h1><h1 class=pgc-h-arrow-right><strong>当前读与快照读</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">通过 MVCC 机制，虽然让数据变得可重复读，但我们读到的数据可能是历史数据，是不及时的数据，不是数据库当前的数据！对于这种读取历史数据的方式，我们叫它</span><span style="color:#f83929;--tt-darkmode-color: #F83929">快照读</span> (snapshot read)，而读取数据库当前版本数据的方式，叫<span style="color:#f83929;--tt-darkmode-color: #F83929">当前读</span> (current read) <span style="color:#f83929;--tt-darkmode-color: #F83929">参考[3]</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">快照读：就是select</span></li><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">select * from table ….;</span></li></ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。</span></li><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">select * from table where ? lock in share mode;</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">select * from table where ? for update;</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">insert;</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">update ;</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">delete;</span></li></ul></ul><h1 class=pgc-h-arrow-right><strong>解决幻读</strong></h1><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">为了解决</span><span style="color:#f83929;--tt-darkmode-color: #F83929">当前读</span>中的幻读问题，MySQL事务使用了 next-key lock 。</p><div class=pgc-img><img alt="我对 MySQL 锁、事务、MVCC 的一些认识" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/293f77e55e714ddf86fd0f62d0f2d214><p class=pgc-img-caption></p></div><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Repeatable read 通过 next-key lock 机制避免了幻读现象。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">InnoDB存储引擎有3种行锁的算法，分别是：</span></p><ul><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Record Lock: 单个记录上的锁</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Gap Lock: 间隙锁，锁定一个范围，但不包括记录本上</span></li><li><span style="color:#353535;--tt-darkmode-color: #A3A3A3">Next-Key Lock: Gap Lock + Record Lock</span></li></ul><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">next-key lock 是行锁的一种，实现相当于 record lock(记录锁) + gap lock(间隙锁)；其特点是不仅会锁住记录本身( record lock 的功能)，还会锁定一个范围( gap lock 的功能)。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">当InnoDB扫描索引记录的时候，会首先对索引记录加上行锁（Record Lock），再对索引记录两边的间隙加上间隙锁（Gap Lock）。加上间隙锁之后，其他事务就不能在这个间隙修改或者插入记录。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">当查询的索引含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。</span></p><p><span style="color:#353535;--tt-darkmode-color: #A3A3A3">下图引用自 </span><span style="color:#f83929;--tt-darkmode-color: #F83929">云栖社区[4]</span></p><div class=pgc-img><img alt="我对 MySQL 锁、事务、MVCC 的一些认识" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/810815a5ed9040e89361a730c79a3f83><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#f83929;--tt-darkmode-color: #F83929">参考资料</span></strong></h1><p><span style="color:#f83929;--tt-darkmode-color: #F83929">[1]</span></p><p>mysql 5.7文档:<em><span style="color:#353535;--tt-darkmode-color: #A3A3A3">https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html</span></em></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">[2]</span></p><p>参考博客:<em><span style="color:#353535;--tt-darkmode-color: #A3A3A3">https://www.cnblogs.com/kismetv/p/10331633.html</span></em></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">[3]</span></p><p>美团技术博客:<em><span style="color:#353535;--tt-darkmode-color: #A3A3A3">https://tech.meituan.com/2014/08/20/innodb-lock.html</span></em></p><p><span style="color:#f83929;--tt-darkmode-color: #F83929">[4]</span></p><p>云栖社区:<em><span style="color:#353535;--tt-darkmode-color: #A3A3A3">https://yq.aliyun.com/articles/108095</span></em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'MySQL','事务','MVCC'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>