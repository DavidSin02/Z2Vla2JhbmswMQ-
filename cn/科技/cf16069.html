<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 | 极客快訊</title><meta property="og:title" content="架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/be3198d6b6434788b6b4caf468fda2d2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf16069.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf16069.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf16069.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf16069.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf16069.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf16069.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf16069.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf16069.html><meta property="article:published_time" content="2020-10-29T20:53:45+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:45+08:00"><meta name=Keywords content><meta name=description content="架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cf16069.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、适配器模式的应用场景</h1><p>我们在现实生活见识到的电源插头转换器、手机充电转换头、显示器转接头等都是适配器模式的体现。适配器模式（Adapter Pattern）是指一个类的接口转换成客户期望的另一个接口，使原本的接口不兼容的类可以一起工作。</p><div class=pgc-img><img alt=架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be3198d6b6434788b6b4caf468fda2d2><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a33d44c251af4c59a4bd8819219cc38f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/08eba25d25a84ae9a799459c2db0c100><p class=pgc-img-caption></p></div><p>适配器模式适用于以下几种应用场景：</p><ul><li>已经存在的类，它的方法和需求不匹配（方法结果相同或相似）的情况。</li><li>适配器模式不是在软件初始阶段考虑的设计模式，它是随着软件的发展，由于不同的产品、不同的厂家造成功能类似而接口不同的问题的解决方案，有点亡羊补牢的感觉。</li></ul><h2 class=pgc-h-arrow-right>1.1 中国与日本交流电压兼容性问题</h2><p>大家都知道，我国民用电电压是220V，而日本的电压为100V，如果去过日本旅游的朋友应该会知道，我们在入住酒店时使用电源来给手机充电的时候就需要使用电源插头转换器来进行转换电压，这样才能给自己的手机进行充电。</p><p>首先创建AC220类 ，表示220V交流电中国标准：</p><pre><code>public class AC220 {    public BigDecimal outputAC220V(){        BigDecimal output = new BigDecimal(220);        System.out.println("中国输出交流电" + output + "V");        return output;    }}</code></pre><p>创建 DC100 接口，表示 100V 直流电的日本标准：</p><pre><code>public interface DC100 {    BigDecimal outputDC100V();}</code></pre><p>创建电源适配器 PowerAdapter 类：</p><pre><code>public class PowerAdapter implements DC100 {    private AC220 ac220;    public PowerAdapter(AC220 ac220) {        this.ac220 = ac220;    }    @Override    public BigDecimal outputDC100V() {        BigDecimal adapterInput = ac220.outputAC220V();        BigDecimal adapterOutput = adapterInput.divide(new BigDecimal(2.2), 2, BigDecimal.ROUND_HALF_UP)  ;        System.out.println("使用 PowerAdapter 输入 AC: " + adapterInput.intValue() +                "V" + "，日本输出 DC: " + adapterOutput.intValue() + "V");        return  adapterOutput;    }}</code></pre><p>测试main方法：</p><pre><code>public static void main(String[] args) {    DC100 dc100 = new PowerAdapter(new AC220());    dc100.outputDC100V(); }</code></pre><p>上面的案例中，通过增加 PowerAdapter电源适配器，实现了中国与日本交流电压二者的兼容性问题。</p><h2 class=pgc-h-arrow-right>1.2 第三方登录自由适配的问题</h2><p>现在浏览一些网站、博客、论坛以及手机APP的时候，我们可以以QQ、微信、新浪微博等多种方式进行系统登录。虽然登录形式丰富了，但是登录后的逻辑不用修改，同样是保存登录状态到session，遵循开闭原则。</p><p>首先创建统一的结果返回类：</p><pre><code>public class ResultMsg {    private int code;    private String msg;    private Object data;    public ResultMsg(int code, String msg, Object data) {        this.code = code;        this.msg = msg;        this.data = data;    }    public int getCode() {        return code;    }    public void setCode(int code) {        this.code = code;    }    public String getMsg() {        return msg;    }    public void setMsg(String msg) {        this.msg = msg;    }    public Object getData() {        return data;    }    public void setData(Object data) {        this.data = data;    }    @Override    public String toString() {        return "ResultMsg{" +                "code=" + code +                ", msg='" + msg + '\'' +                ", data=" + data +                '}';    }}</code></pre><p>创建用户类：</p><pre><code>public class User {    private String id;    private String username;    private String password;    private String info;    public String getId() {        return id;    }    public void setId(String id) {        this.id = id;    }    public String getUsername() {        return username;    }    public void setUsername(String username) {        this.username = username;    }    public String getPassword() {        return password;    }    public void setPassword(String password) {        this.password = password;    }    public String getInfo() {        return info;    }    public void setInfo(String info) {        this.info = info;    }}</code></pre><p>之前老的登录逻辑类是这样子的：</p><pre><code>public class SignService {    /**     * 注册     * @param username     * @param password     * @return     */    public ResultMsg register(String username, String password) {        User user = new User();        user.setUsername(username);        user.setPassword(password);        return new ResultMsg(0, "注册成功", user);    }    /**     * 登录     * @param username     * @param password     * @return     */    public ResultMsg login(String username, String password) {        return null;    }}</code></pre><p>我们会创建一个新的类继承原来的登录逻辑类，之前的代码我们无需做任何改动：</p><pre><code>public class Sign4ThirdpartyService extends SignService {    public ResultMsg login4Register(String username,String password){        super.register(username,password);        return super.login(username,password);    }    public ResultMsg login4Phone(String phone,String code){        return null;    }    public ResultMsg login4Token(String token){        //通过 token 拿到用户信息，然后再重新登陆了一次        return null;    }    public ResultMsg login4QQ(String openId){        //1、openId 是全局唯一        //2、密码默认为 QQ_EMPTY        //3、注册（在原有系统里面创建一个用户）        //4、调用原来的登录方法        return login4Register(openId,null);    }    public ResultMsg login4Wechat(String openId){        return null;    }}</code></pre><p>main方法：</p><pre><code> public static void main(String[] args) {    Sign4ThirdpartyService service = new Sign4ThirdpartyService();    service.login4QQ("qwqwqweyrtyrt13234");}</code></pre><p>当然我们还可以根据不同的登录方式创建不同的Adapter适配器，接着改造代码：</p><p>首先，创建 LoginAdapter 接口：</p><pre><code>public interface LoginAdapter {    boolean support(Object adapter);    ResultMsg login(String id, Object adapter);}</code></pre><p>分别实现不同的登录适配，QQ 登录 LoginForQQAdapter：</p><pre><code>public class Login4QQAdapter implements LoginAdapter {    @Override    public boolean support(Object adapter) {        return adapter instanceof Login4QQAdapter;    }    @Override    public ResultMsg login(String id, Object adapter) {        return null;    }}</code></pre><p>微信登录 LoginForWechatAdapter：</p><pre><code>public class Login4WechatAdapter implements LoginAdapter {    @Override    public boolean support(Object adapter) {        return adapter instanceof Login4WechatAdapter;    }    @Override    public ResultMsg login(String id, Object adapter) {        return null;    }}</code></pre><p>token登录 Login4TokenAdapter：</p><pre><code>public class Login4TokenAdapter implements LoginAdapter {    @Override    public boolean support(Object adapter) {        return adapter instanceof Login4TokenAdapter;    }    @Override    public ResultMsg login(String id, Object adapter) {        return null;    }}</code></pre><p>手机号码登录 Login4TelphoneAdapter：</p><pre><code>public class Login4TelphoneAdapter implements LoginAdapter {    @Override    public boolean support(Object adapter) {        return adapter instanceof Login4TelphoneAdapter;    }    @Override    public ResultMsg login(String id, Object adapter) {        return null;    }}</code></pre><p>创建与第三方兼容接口 IPassport4Thirdparty：</p><pre><code>public interface IPassport4Thirdparty {    /**     * QQ 登录     * @param id     * @return    23     */    ResultMsg login4QQ(String id);    /**     * 微信登录     * @param id     * @return     */    ResultMsg login4Wechat(String id);    /**     * 记住登录状态后自动登录     * @param token     * @return     */    ResultMsg login4Token(String token);    /**     * 手机号登录     * @param telphone     * @param code     * @return     */    ResultMsg login4Telphone(String telphone, String code);    /**     * 注册后自动登录     * @param username     * @param passport     * @return     */    ResultMsg login4Register(String username, String passport);}</code></pre><p>实现兼容适配器 Passport4ThirdpartyAdapter：</p><pre><code>public class Passport4ThirdpartyAdapter extends SignService implements IPassport4Thirdparty {    private ResultMsg processLogin(String key, Class&lt;? extends LoginAdapter&gt; clazz) {        try {            LoginAdapter loginAdapter = clazz.newInstance();            if(loginAdapter.support(loginAdapter)) {                return loginAdapter.login(key, loginAdapter);            }else {                return null;            }        } catch (InstantiationException e) {            e.printStackTrace();        } catch (IllegalAccessException e) {            e.printStackTrace();        }        return null;    }    @Override    public ResultMsg login4QQ(String id) {        return processLogin(id, Login4QQAdapter.class);    }    @Override    public ResultMsg login4Wechat(String id) {        return processLogin(id, Login4WechatAdapter.class);    }    @Override    public ResultMsg login4Token(String token) {        return processLogin(token, Login4TokenAdapter.class);    }    @Override    public ResultMsg login4Telphone(String telphone, String code) {        return processLogin(telphone, Login4TelphoneAdapter.class);    }    @Override    public ResultMsg login4Register(String username, String passport) {        super.register(username,null);        return super.login(username,null);    }}</code></pre><p>最后来看一下类图：</p><div class=pgc-img><img alt=架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2db21526f8384846bc2d1d97741e10f4><p class=pgc-img-caption></p></div><p>至此，我们在遵循开闭原则的前提下，完整地实现了一个兼容多平台登录的业务场景。当然，目前的这个设计也并不完美，仅供参考。上面的代码可以说是<strong>策略模式、简单工厂模式和适配器模式的综合运用。</strong></p><h1 class=pgc-h-arrow-right>二、适配器模式在源码中的体现</h1><h2 class=pgc-h-arrow-right>2.1 Spring中的AdvisorAdapter接口</h2><p>Spring 中适配器模式也应用得非常广泛，例如：SpringAOP 中的 <strong>AdvisorAdapter</strong> 类，它有三个实现类 <strong>MethodBeforeAdviceAdapter</strong>、<strong>AfterReturningAdviceAdapter</strong> 和<strong>ThrowsAdviceAdapter</strong>，先来看顶层接口 AdvisorAdapter 的源代码：</p><pre><code>public interface AdvisorAdapter {    boolean supportsAdvice(Advice var1);    MethodInterceptor getInterceptor(Advisor var1);}</code></pre><p>再看 MethodBeforeAdviceAdapter 类：</p><pre><code>class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable {    MethodBeforeAdviceAdapter() {    }    public boolean supportsAdvice(Advice advice) {        return advice instanceof MethodBeforeAdvice;    }    public MethodInterceptor getInterceptor(Advisor advisor) {        MethodBeforeAdvice advice = (MethodBeforeAdvice)advisor.getAdvice();        return new MethodBeforeAdviceInterceptor(advice);    }}</code></pre><p>然后来看 AfterReturningAdviceAdapter 类：</p><pre><code>class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {    AfterReturningAdviceAdapter() {    }    public boolean supportsAdvice(Advice advice) {        return advice instanceof AfterReturningAdvice;    }    public MethodInterceptor getInterceptor(Advisor advisor) {        AfterReturningAdvice advice = (AfterReturningAdvice)advisor.getAdvice();        return new AfterReturningAdviceInterceptor(advice);    }}</code></pre><p>最后来看 ThrowsAdviceAdapter 类：</p><pre><code>class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable {    ThrowsAdviceAdapter() {    }    public boolean supportsAdvice(Advice advice) {        return advice instanceof ThrowsAdvice;    }    public MethodInterceptor getInterceptor(Advisor advisor) {        return new ThrowsAdviceInterceptor(advisor.getAdvice());    }}</code></pre><p>Spring 会根据不同的 AOP 配置来确定使用对应的 Advice，跟策略模式不同的一个方法可以同时拥有多个 Advice。</p><h2 class=pgc-h-arrow-right>2.2 Spring中的HandlerAdapter</h2><p>下面再来看一个 SpringMVC 中的 <strong>HandlerAdapter</strong> 类，它也有多个子类，类图如下：</p><div class=pgc-img><img alt=架构师内功心法，中国与日本交流电压兼容性问题的适配器模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6b7c5966d4d4582a1faa2ab8e1ef6c0><p class=pgc-img-caption></p></div><p>三、适配器模式的优缺点</p><p>优点：</p><ul><li>能提高类的透明性和复用性，现有的类复用但不需要改变；</li><li>目标类和适配器类解耦，提高程序的扩展性；</li><li>在很多业务场景中符合开闭原则。</li></ul><p>缺点：</p><ul><li>适配器编写过程需要全面考虑，可能会增加系统的复杂性；</li><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'架构','师内功','中国'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>