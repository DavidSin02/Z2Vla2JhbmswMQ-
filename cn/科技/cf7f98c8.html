<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试阿里，美团都会被问到的Spring ,从基础到源码统统帮你搞定 | 极客快訊</title><meta property="og:title" content="面试阿里，美团都会被问到的Spring ,从基础到源码统统帮你搞定 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/0ca013e258664cbb94ab2d6883b0fd97"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cf7f98c8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cf7f98c8.html><meta property="article:published_time" content="2020-11-14T21:04:30+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:30+08:00"><meta name=Keywords content><meta name=description content="面试阿里，美团都会被问到的Spring ,从基础到源码统统帮你搞定"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cf7f98c8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试阿里，美团都会被问到的Spring ,从基础到源码统统帮你搞定</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1 前言</h1><ol start=1><li>Spring是一个轻量级开源框架，它是为了解决企业应用开发的复杂性而创建的。框架的主要优势之一就是其分层架构，分层架构允许使用者选择使用哪一个组件，同时为 J2EE 应用程序开发提供集成的框架。</li><li>Spring是众多优秀设计模式的组合（工厂、单例、代理、适配器、包装器、观察者、模板、策略）。</li><li>Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合的角度而言，任何Java应用都可以从Spring中受益。</li><li>Spring并未替代现有框架产品，而是将众多框架进行有机整合，简化企业级开发，俗称"胶水框架"。</li></ol><h1 class=pgc-h-arrow-right>2 Spring架构组成</h1><p>Spring架构由诸多模块组成，可分类为</p><ul><li>核心技术：依赖注入，事件，资源，i18n，验证，数据绑定，类型转换，SpEL，AOP。</li><li>测试：模拟对象，TestContext框架，Spring MVC测试，WebTestClient。</li><li>数据访问：事务，DAO支持，JDBC，ORM，封送XML。</li><li>Spring MVC和 Spring WebFlux Web框架。</li><li>集成：远程处理，JMS，JCA，JMX，电子邮件，任务，调度，缓存。</li><li>语言：Kotlin，Groovy，动态语言。</li><li>List item</li></ul><p>Spring架构组成如下图</p><p><br></p><div class=pgc-img><img alt="面试阿里，美团都会被问到的Spring ,从基础到源码统统帮你搞定" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0ca013e258664cbb94ab2d6883b0fd97><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>3 Spring环境搭建</h1><h1 class=pgc-h-arrow-right>3.1 pom.xml中引入Spring常用依赖</h1><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"         xsi:schemaLocation=         "http://maven.apache.org/POM/4.0.0           http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;com.qf&lt;/groupId&gt;    &lt;artifactId&gt;hello-spring&lt;/artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;dependencies&gt;        &lt;!-- Spring常用依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;&lt;/project&gt;</code></pre><h1 class=pgc-h-arrow-right>3.2 创建Spring配置文件</h1><p>命名无限制，约定俗成命名有：spring-context.xml、applicationContext.xml、beans.xml</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right>4 Spring工厂编码（入门程序）</h1><h1 class=pgc-h-arrow-right>4.1 定义目标Bean类型</h1><pre><code>public class MyClass{    public void show(){        System.out.println("HelloWorld");    }}</code></pre><h1 class=pgc-h-arrow-right>4.2spring-context.xml中的&lt; beans >内部配置bean</h1><p>在spring-context.xml中配置MyClass的bean后，当项目启动时，spring容器会自动创建MyClass实例，这个实例名字叫mc</p><pre><code>&lt;!-- 配置实例（id:“唯一标识”  class="需要被创建的目标对象全限定名"） --&gt;&lt;bean id="mc" class="com.qf.spring.part1.factory.MyClass" /&gt;</code></pre><p>测试代码</p><pre><code>public class TestFactory{    /**     * 程序中的对象都交由Spring的ApplicationContext工厂进行创建。     */    public static void main(String[] args){        //1\. 读取配置文件中所需创建的bean对象，并获得工厂对象        ApplicationContext ctx = new ClassPathXmlApplicationContext("spring-context.xml");        //2\. 通过id获取bean对象        MyClass mc = (MyClass) ctx.getBean("mc");        //3\. 使用对象        mc.show();    }}</code></pre><h1 class=pgc-h-arrow-right>5 IoC（Inversion of Control ）控制反转</h1><p>控制反转是Spring框架的核心，所谓控制反转就是应用本身不负责依赖对象的创建及维护，依赖对象的创建及维护是由外部容器负责的， 这样控制权就由应用转移到了外部容器，控制权的转移就是所谓反转。这样就由之前的自己创建依赖对象，变为由spring容器创建。(变主动为被动，即反转)。控制反转解决了具有依赖关系的组件之间的强耦合，使得项目形态更加稳健。</p><h1 class=pgc-h-arrow-right>5.1 项目中强耦合问题</h1><pre><code>public class UserDAOImpl implements UserDAO{....}</code></pre><pre><code>public class UserServiceImpl implements UserService {    // 通过传统的new方式强耦合了UserDAOImpl!!!,使得UserServiceImpl变得不稳健!!    private UserDAO userDAO= new UserDAOImpl();    @Override    public User queryUser() {        return userDAO.queryUser();    }    ....}</code></pre><h1 class=pgc-h-arrow-right>5.2 解决方案</h1><pre><code>// 不引用任何一个具体的组件(实现类)，在需要其他组件的位置预留存取值入口(set/get)public class UserServiceImpl implements UserService {    // !!!不再耦合任何DAO实现!!!,消除不稳健因素!!    private UserDAO userDAO；    // 为userDAO定义set/get,允许userDAO属性接收spring赋值    //Getters And Setters    @Override    public User queryUser() {        return userDAO.queryUser();    }    ....}</code></pre><p>在spring配置文件中配置UserDAO和UserService对应的bean</p><pre><code>&lt;bean id="userDAO" class="com.qf.spring.part1.injection.UserDaoImpl"&gt;&lt;/bean&gt;&lt;!-- UserServiceImpl组件 --&gt;&lt;bean id="userService" class="com.qf.spring.part1.injection.UserServiceImpl"&gt;    &lt;!-- 由spring为userDAO属性赋值，值为id="userDAO"的bean --&gt;    &lt;property name="userDAO" ref="userDAO"/&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6 DI（Dependency Injection）依赖注入</h1><h1 class=pgc-h-arrow-right>6.1 概念</h1><p>在Spring创建对象的同时，为其属性赋值，称之为依赖注入,注入方式主要有以下2种</p><ul><li>构造函数注入</li><li>Setter方法注入</li></ul><h1 class=pgc-h-arrow-right>6.2 Setter方法注入</h1><p>创建对象时，Spring工厂会通过Setter方法为对象的属性赋值。</p><h1 class=pgc-h-arrow-right>6.2.1 定义目标Bean类型</h1><pre><code>public class User {    private Integer id;    private String password;    private String sex;    private Integer age;    private Date bornDate;    private String[] hobbys;    private Set&lt;String&gt; phones;    private List&lt;String&gt; names;    private Map&lt;String,String&gt; countries;    private Properties files;    //Getters And Setters}</code></pre><h1 class=pgc-h-arrow-right>6.2.2 基本类型 + 字符串类型 + 日期类型</h1><pre><code>&lt;bean id="u1" class="com.qf.spring.part1.injection.User"&gt;    &lt;!--base field--&gt;    &lt;property name="id" value="1001" /&gt;    &lt;property name="password" value="123456" /&gt;    &lt;property name="sex" value="male" /&gt;    &lt;property name="age" value="20" /&gt;    &lt;property name="bornDate" value="1990/1/1" /&gt;&lt;!--注意格式"/"--&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6.2.3 容器类型（list,set,map,Properties）</h1><pre><code>&lt;bean id="u1" class="com.qf.spring.part1.injection.User"&gt;       &lt;!--Array--&gt;    &lt;property name="hobbys"&gt;        &lt;array&gt;            &lt;value&gt;Run&lt;/value&gt;            &lt;value&gt;Swim&lt;/value&gt;            &lt;value&gt;Climb&lt;/value&gt;        &lt;/array&gt;    &lt;/property&gt;    &lt;!--Set--&gt;    &lt;property name="phones"&gt;        &lt;set&gt;            &lt;value&gt;13777777777&lt;/value&gt;            &lt;value&gt;13888888888&lt;/value&gt;            &lt;value&gt;13999999999&lt;/value&gt;        &lt;/set&gt;    &lt;/property&gt;    &lt;!--List--&gt;    &lt;property name="names"&gt;        &lt;list&gt;            &lt;value&gt;tom&lt;/value&gt;            &lt;value&gt;jack&lt;/value&gt;            &lt;value&gt;marry&lt;/value&gt;        &lt;/list&gt;    &lt;/property&gt;    &lt;!--Map--&gt;    &lt;property name="countries"&gt;        &lt;map&gt;            &lt;entry key="CN" value="China" /&gt;            &lt;entry key="US" value="America" /&gt;            &lt;entry key="KR" value="Korea" /&gt;        &lt;/map&gt;    &lt;/property&gt;    &lt;!--Properties--&gt;    &lt;property name="files"&gt;        &lt;props&gt;            &lt;prop key="first"&gt;One&lt;/prop&gt;            &lt;prop key="second"&gt;Two&lt;/prop&gt;            &lt;prop key="third"&gt;Three&lt;/prop&gt;        &lt;/props&gt;    &lt;/property&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6.2.4 自定义类型</h1><pre><code>&lt;!--次要bean，被作为属性--&gt;&lt;bean id="addr" class="com.qf.spring.part1.injection.Address"&gt;    &lt;property name="position" value="北京市海淀区" /&gt;    &lt;property name="zipCode" value="100001" /&gt;&lt;/bean&gt;&lt;!--主要bean，操作的主体--&gt;&lt;bean id="u2" class="com.qf.spring.part1.injection.User"&gt;    &lt;property name="address" ref="addr" /&gt;&lt;!--address属性引用addr对象--&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>6.3 构造注入</h1><p>创建对象时，Spring工厂会通过构造方法为对象的属性赋值。</p><h1 class=pgc-h-arrow-right>6.3.1 定义目标Bean类型</h1><pre><code>public class Student {    private Integer id;    private String name;    private String sex;    private Integer age;    //Constructors    public Student(Integer id , String name , String sex , Integer age){        this.id = id;        this.name = name;        this.sex = sex;        this.age = age;    }}复制代码</code></pre><h1 class=pgc-h-arrow-right>6.3.2 注入</h1><pre><code> &lt;!--构造注入--&gt;&lt;bean id="u3" class="com.qf.zcg.spring.day1.t2.ioc.Student"&gt;    &lt;constructor-arg name="id" value="1234" /&gt; &lt;!-- 除标签名称有变化，其他均和Set注入一致 --&gt;    &lt;constructor-arg name="name" value="tom" /&gt;    &lt;constructor-arg name="age" value="20" /&gt;    &lt;constructor-arg name="sex" value="male" /&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>7 Spring工厂特性</h1><h1 class=pgc-h-arrow-right>7.1 饿汉式创建优势</h1><p>工厂创建之后，会将Spring配置文件中的所有对象都创建完成（饿汉式），提高程序运行效率，避免多次IO，减少对象创建时间。（概念接近连接池，一次性创建好，使用时直接获取）</p><h1 class=pgc-h-arrow-right>7.2 生命周期方法</h1><ul><li>自定义初始化方法：添加“init-method”属性，Spring则会在创建对象之后，调用此方法。</li><li>自定义销毁方法：添加“destroy-method”属性，Spring则会在销毁对象之前，调用此方法。</li><li>销毁：工厂的close()方法被调用之后，Spring会毁掉所有已创建的单例对象。</li><li>分类：Singleton对象由Spring容器销毁、Prototype对象由JVM销毁。</li></ul><h1 class=pgc-h-arrow-right>7.3 生命周期注解</h1><pre><code>import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;@PostConstruct //初始化 public void init(){    System.out.println("init method executed");}@PreDestroy //销毁public void destroy(){    System.out.println("destroy method executed");}</code></pre><h1 class=pgc-h-arrow-right>7.4 生命周期阶段</h1><p>单例bean：singleton</p><p>随工厂启动创建 ==》 构造方法 ==》 set方法(注入值) ==》 init(初始化) ==》 构建完成 ==》随工厂关闭销毁</p><p>多例bean：prototype</p><p>被使用时创建 ==》 构造方法 ==》 set方法(注入值) ==》 init(初始化) ==》 构建完成 ==》JVM垃圾回收销毁</p><h1 class=pgc-h-arrow-right>8 代理设计模式</h1><h1 class=pgc-h-arrow-right>8.1 概念</h1><p>将核心功能与辅助功能（事务、日志、性能监控代码）分离，达到核心业务功能更纯粹、辅助业务功能可复用。</p><p><br></p><div class=pgc-img><img alt="面试阿里，美团都会被问到的Spring ,从基础到源码统统帮你搞定" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1c33a6fb3c684f86912ca073acada557><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>8.2 静态代理设计模式</h1><p>通过代理类的对象，为原始类的对象（目标类的对象）添加辅助功能，更容易更换代理实现类、利于维护。</p><ul><li>代理类 = 实现原始类相同接口 + 添加辅助功能 + 调用原始类的业务方法。</li><li>静态代理的问题 代理类数量过多，不利于项目的管理。 多个代理类的辅助功能代码冗余，修改时，维护性差。</li></ul><h1 class=pgc-h-arrow-right>8.3 动态代理设计模式</h1><h1 class=pgc-h-arrow-right>8.3.1 JDK动态代理实现（基于接口）</h1><pre><code>//目标final OrderService os = new OrderServiceImpl();//额外功能InvocationHandler handler = new InvocationHandler(){//1.设置回调函数（额外功能代码）    @Override    public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable {        System.out.println("start...");        method.invoke(os, args);         System.out.println("end...");        return null;    }};//2.创建动态代理类Object proxyObj = Proxy.newProxyInstance(ClassLoader , Interfaces , InvocationHandler);</code></pre><h1 class=pgc-h-arrow-right>8.3.2 CGlib动态代理实现（基于继承）</h1><pre><code>final OrderService os = new OrderServiceImpl();Enhancer cnh = new Enhancer();//1.创建字节码曾强对象enh.setSuperclass(os.getClass());//2.设置父类（等价于实现原始类接口）enh.setCallback(new InvocationHandler(){//3.设置回调函数（额外功能代码）    @Override    public Object invoke(Object proxy , Method method, Object[] args) throws Throwable{        System.out.println("start...");        Object ret = method.invoke(os,args);        System.out.println("end...");        return ret;    }});OrderService proxy = (OrderService)enh.create();//4.创建动态代理类proxy,createOrder();</code></pre><h1 class=pgc-h-arrow-right>9 面向切面编程</h1><h1 class=pgc-h-arrow-right>9.1 概念</h1><p>AOP（Aspect Oriented Programming），即面向切面编程，利用一种称为"横切"的技术，剖开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为"Aspect"，即切面。所谓"切面"，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p><p>通俗的概念来讲，所谓的面向切面编程就是针对被代理对象的方法在某个特定的执行时机(方法调用之前、方法调用之后、方法抛出异常)，做出一些额外的横向的处理。好处在于：1. 可以在不修改原有代码基础上横向扩展我们的内容；2. 将一些方法中的通用逻辑进行统一化的处理。</p><p>OOP(面向对象编程)和AOP(面向切面编程)的区别：oop是对类纵向的扩展；aop是横向的扩展。</p><h1 class=pgc-h-arrow-right>9.2 AOP开发术语</h1><ul><li>连接点(Joinpoint)：连接点是程序类中客观存在的方法，可被Spring拦截并切入内容。</li><li>切入点(Pointcut)：被切入连接点。</li><li>通知、增强(Advice)：可以为切入点添加额外功能，分为：前置通知、后置通知、异常通知、环绕通知等。</li><li>目标对象(Target)：代理的目标对象</li><li>织入(Weaving)：把通知应用到具体的类，进而创建新的代理类的过程。</li><li>代理(Proxy)：被AOP织入通知后，产生的结果类。</li><li>切面(Aspect)：由切点和通知组成，将横切逻辑织入切面所指定的连接点中。</li></ul><h1 class=pgc-h-arrow-right>9.3 作用</h1><p>Spring的AOP编程即是通过动态代理类为原始类的方法添加辅助功能。</p><h1 class=pgc-h-arrow-right>9.4 环境搭建</h1><p>引入AOP相关依赖</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;    &lt;version&gt;5.1.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>spring-context.xml引入AOP命名空间</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xsi:schemaLocation="       http://www.springframework.org/schema/beans       http://www.springframework.org/schema/beans/spring-beans.xsd       http://www.springframework.org/schema/aop       http://www.springframework.org/schema/aop/spring-aop.xsd       "&gt;&lt;/beans&gt;</code></pre><h1 class=pgc-h-arrow-right>9.5 开发流程</h1><p>定义原始类</p><pre><code>package com.qf.aaron.aop.basic;public interface UserService {    public void save();}复制代码</code></pre><pre><code>package com.qf.aaron.aop.basic;public class UserServiceImpl implements UserService {    public void save() {        System.out.println("save method executed...");    }}</code></pre><p>定义通知类（添加额外功能</p><pre><code>package com.qf.aaron.aop.basic;import org.springframework.aop.MethodBeforeAdvice;import java.lang.reflect.Method;public class MyAdvice implements MethodBeforeAdvice { //实现前置通知接口    public void before(Method method, Object[] args, Object target) throws Throwable {        System.out.println("before advice executed...");    }}</code></pre><p>定义bean标签</p><pre><code>&lt;!--原始对象--&gt;&lt;bean id="us" class="com.qf.aaron.aop.basic.UserServiceImpl" /&gt;&lt;!--辅助对象--&gt;&lt;bean id="myAdvice" class="com.qf.aaron.aop.basic.MyAdvice" /&gt;</code></pre><p>定义切入点（PointCut）</p><p>形成切面（Aspect）</p><pre><code>&lt;aop:config&gt;    &lt;!--切点--&gt;    &lt;aop:pointcut id="myPointCut" expression="execution(* save())" /&gt;&lt;/aop:config&gt;```java&lt;aop:config&gt;    &lt;!--组装切面 --&gt;    &lt;aop:advisor advice-ref="myAdvice" pointcut-ref="myPointCut" /&gt;&lt;/aop:config&gt;</code></pre><h1 class=pgc-h-arrow-right>9.6 通知类</h1><p>可定义的通知类有6种，可以按需求选择通知类。</p><pre><code>前置通知：MethodBeforeAdvice后置通知：AfterAdvice后置通知：AfterReturningAdvice //有异常不执行，方法会因异常而结束，无返回值异常通知：ThrowsAdvice环绕通知：MethodInterceptor</code></pre><h1 class=pgc-h-arrow-right>9.7 JDK动态代理和CGLIB动态代理的选择</h1><ul><li>spring底层，包含了jdk代理和cglib代理两种动态代理生成机制</li><li>基本规则是：目标业务类如果有接口则用JDK代理，没有接口则用CGLib代理</li></ul><p>但是spring中默认开启JDK动态代理，当需要使用CGLIB动态代理时，需要在spring配置文件中配置。</p><pre><code>&lt;!--  使用cglib的方式实现aop --&gt;    &lt;aop:aspectj-autoproxy proxy-target-class="true"/&gt;</code></pre><h1 class=pgc-h-arrow-right>10 基于aspectJ的AOP实现</h1><p>编写aspectJ通知代码:</p><pre><code>@Aspectpublic class AspectJAdvisor {    // 环绕通知    @Around("execution(* org.example.service.impl.*.*(..))")    public Object timer(ProceedingJoinPoint pjp) throws Throwable{        System.out.println("前置通知");        Object o = pjp.proceed();        System.out.println("【后置通知】");        return o;    }    // 后置通知    @After("execution(* org.example.service.impl.*.*(..))")    public void after(JoinPoint jp) throws Throwable{        System.out.println("====After method invokded====");    }    // 前置通知    @Before("execution(* org.example.service.impl.*.*(..))")    public void before(JoinPoint jp){        System.out.println("====before method invoked====");    }    // 正常返回的通知    @AfterReturning("execution(* org.example.service.impl.*.*(..))")    public void afterReturning(JoinPoint jp){        System.out.println("====after value return====");    }    // 抛出异常后的通知，方法的异常必须与代理类抛出的异常一致，throwing的值要与异常的形参名保持一致    @AfterThrowing(value = "execution(* org.example.service.impl.*.*(..))", throwing="npe")    public void afterThrowException(JoinPoint jp, NullPointerException npe){        System.out.println("====after exception throwing====");    }}</code></pre><p>配置</p><pre><code>&lt;bean id="userService" class="org.example.service.impl.UserServiceImpl"&gt;&lt;/bean&gt;&lt;bean id="throwsAdvisor" class="org.example.advisor.AspectJAdvisor"&gt;&lt;/bean&gt;&lt;!--- aspectJ是使用cglib来实现动态代理的 --&gt;&lt;aop:aspectj-autoproxy proxy-target-class="true"&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><h1 class=pgc-h-arrow-right>11 基于注解开发</h1><h1 class=pgc-h-arrow-right>11.1 声明bean</h1><p>用于替换自建类型组件的 &lt;bean…>标签；可以更快速的声明bean</p><ul><li>@Service 业务类专用 @Repository dao实现类专用 @Controller web层专用</li><li>@Component 通用</li><li>@Scope 用户控制bean的创建模式</li></ul><pre><code>// @Service说明 此类是一个业务类，需要将此类纳入工厂  等价替换掉 &lt;bean class="xxx.UserServiceImpl"&gt;// @Service默认beanId == 首字母小写的类名"userServiceImpl"// @Service("userService") 自定义beanId为"userService"@Service //声明bean，且id="userServiceImpl"@Scope("singleton") //声明创建模式，默认为单例模式 ；@Scope("prototype")即可设置为多例模式public class UserServiceImpl implements UserService {    ...   }</code></pre><h1 class=pgc-h-arrow-right>11.2 注入(DI)</h1><p>用于完成bean中属性值的注入</p><ul><li>@Autowired 基于类型自动注入</li><li>@Resource 基于名称自动注入</li><li>@Qualifier(“userDAO”) 限定要自动注入的bean的id，一般和@Autowired联用</li><li>@Value 注入简单类型数据 (jdk8种+String)</li></ul><pre><code>@Servicepublic class UserServiceImpl implements UserService {    @Autowired //注入类型为UserDAO的bean    @Qualifier("userDAO2") //如果有多个类型为UserDAO的bean，可以用此注解从中挑选一个    private UserDAO userDAO;}</code></pre><pre><code>@Servicepublic class UserServiceImpl implements UserService {    @Resource("userDAO3") //注入id=“userDAO3”的bean    private UserDAO userDAO;    /*    @Resource //注入id=“userDAO”的bean    private UserDAO userDAO;    */}</code></pre><pre><code>public class XX{    @Value("100") //注入数字    private Integer id;    @Value("shine") //注入String    private String name;}</code></pre><h1 class=pgc-h-arrow-right>11.3 事务控制</h1><p>用于控制事务切入</p><ul><li>@Transactional</li><li>工厂配置中的 &lt;tx:advice… 和 &lt;aop:config… 可以省略 !!</li></ul><pre><code>//类中的每个方法都切入事务(有自己的事务控制的方法除外)@Transactional(isolation=Isolation.READ_COMMITTED,propagation=Propagation.REQUIRED,readOnly=false,rollbackFor=Exception.class,timeout = -1)public class UserServiceImpl implements UserService {    ...    //该方法自己的事务控制，仅对此方法有效    @Transactional(propagation=Propagation.SUPPORTS)    public List&lt;User&gt; queryAll() {        return userDao.queryAll();    }    public void save(User user){        userDao.save(user);    }}</code></pre><h1 class=pgc-h-arrow-right>11.4 注解所需配置</h1><pre><code>&lt;!-- 告知spring，哪些包中 有被注解的类、方法、属性 --&gt;&lt;!-- &lt;context:component-scan base-package="com.qf.a,com.xx.b"&gt;&lt;/context:component-scan&gt; --&gt;&lt;context:component-scan base-package="com.qf"&gt;&lt;/context:component-scan&gt;&lt;!-- 告知spring，@Transactional在定制事务时，基于txManager=DataSourceTransactionManager --&gt;&lt;tx:annotation-driven transaction-manager="txManager"/&gt;</code></pre><h1 class=pgc-h-arrow-right>11.5 AOP开发</h1><h1 class=pgc-h-arrow-right>11.5.1 注解使用</h1><pre><code>import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Aspect // 声明此类是一个切面类：会包含切入点(pointcut)和通知(advice)@Component //声明组件，进入工厂public class MyAspect {    // 定义切入点    @Pointcut("execution(* com.qf.spring.service.UserServiceImpl.*(..))")    public void pc(){}    @Before("pc()") // 前置通知    public void mybefore(JoinPoint a) {        System.out.println("target:"+a.getTarget());        System.out.println("args:"+a.getArgs());        System.out.println("method's name:"+a.getSignature().getName());        System.out.println("before~~~~");    }    @AfterReturning(value="pc()",returning="ret") // 后置通知    public void myAfterReturning(JoinPoint a,Object ret){        System.out.println("after~~~~:"+ret);    }    @Around("pc()") // 环绕通知    public Object myInterceptor(ProceedingJoinPoint p) throws Throwable {        System.out.println("interceptor1~~~~");        Object ret = p.proceed();        System.out.println("interceptor2~~~~");        return ret;    }    @AfterThrowing(value="pc()",throwing="ex") // 异常通知    public void myThrows(JoinPoint jp,Exception ex){        System.out.println("throws");        System.out.println("===="+ex.getMessage());    }}</code></pre><h1 class=pgc-h-arrow-right>11.5.2 配置</h1><pre><code>&lt;!-- 添加如下配置,启用aop注解 --&gt;&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><h1 class=pgc-h-arrow-right>12 Spring单元测试</h1><h1 class=pgc-h-arrow-right>12.1 导入依赖</h1><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;    &lt;version&gt;4.3.6.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt;</code></pre><h1 class=pgc-h-arrow-right>12.2 测试编码</h1><p>可以免去工厂的创建过程；</p><p>可以直接将要测试的组件注入到测试类。</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class) //由SpringJUnit4ClassRunner启动测试@ContextConfiguration("classpath:applicationContext.xml") //spring的配置文件位置public class SpringTest{//当前测试类也会被纳入工厂中，所以其中属性可以注入    @Autowired // 注入要测试的组件    @Qualifier("userDAO")    private UserDAO userDAO;    @Test    public void test(){        // 测试使用userDAO        userDAO.queryUser();        ....    }}最后</code></pre><h1 class=pgc-h-arrow-right>内容就先写到这里。</h1><h1 class=pgc-h-arrow-right>最后觉得文章对你有帮助的话记得给我点个赞。</h1><h1 class=pgc-h-arrow-right>欢迎大家<strong>关注</strong>和<strong>转发</strong>文章！</h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','美团','问到'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>