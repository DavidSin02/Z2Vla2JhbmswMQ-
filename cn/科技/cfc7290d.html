<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>OpenCV项目实战---人脸检测 | 极客快訊</title><meta property="og:title" content="OpenCV项目实战---人脸检测 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f267e46946554437b5ffe48234f3b78d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/cfc7290d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/cfc7290d.html><meta property="article:published_time" content="2020-11-14T21:08:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:21+08:00"><meta name=Keywords content><meta name=description content="OpenCV项目实战---人脸检测"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/cfc7290d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>OpenCV项目实战---人脸检测</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>OpenCV是一个强大的图像处理库，包含各种功能。人脸识别只是其众多应用的其中一个。</p><p style=text-align:justify><br></p><p style=text-align:justify>本篇文章与上一篇所讲述的知识有很大的重合 ，请按需观看。</p><p style=text-align:justify><br></p><p style=text-align:justify><strong>理论知识</strong></p><p style=text-align:justify><br></p><p style=text-align:justify>计算机的视觉系统，计算机通过摄像头看到的，简单来说，就是一堆由数字组成的矩阵。这些数字表明了物体发出的光的强弱，摄像头的光敏元件将光信号转化成数字信号，将其量化为矩阵。</p><p><br></p><p><br>计算机中的彩色图片都是由若干个色彩通道累积出来的，比如RGB模式的图片，这三个通道都是灰度图，比如一个点由8位来表示，则一 个通道可以表示2^8=256个灰度。那样三个通道进行叠加以后可以表3*8=24位种色彩。</p><p><br></p><p><br>对这样的图片做处理，无疑是一件很复杂的事，所以有必要先<strong>将彩色图转为灰度图</strong>，那样可以减少数据量(比如RGB模式，可以减少到原图片的1/3)，同时可 以去掉一些噪声信号。先将图片转化为灰度图，然后将这个灰度图的<strong>对比度</strong>增高，这样可以使得图片本来暗的地方更暗，亮的地方更亮一些。这样处理以后，图片就更容易被算法识别出来了。</p><p><br></p><p style=text-align:justify>Haar特征</p><p style=text-align:justify><br></p><p>Haar特征包含三种：边缘特征、线性特征、和中心围绕特征。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f267e46946554437b5ffe48234f3b78d><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ce6dce6b4dd6499f8ad379f6410a9706><p class=pgc-img-caption></p></div><p>Haar特征提取流程图</p><p>在OpenCV人脸检测中，Haar特征分类器就是一个XML文件，该文件中会描述人体各个部位的Haar特征值。包括人脸、眼睛、嘴唇等等。</p><p><br></p><p><strong>HOG （</strong>Histograms of Oriented Gradients<strong>）</strong></p><p>对于一张待检测图片，我们分析每个像素以及其周围的像素，根据明暗度画一个箭头，箭头的指向代表了像素逐渐变暗的方向，如果我们重复操作每一个像素，最终像素会被箭头取代。这些箭头被称为<strong>梯度(gradients)，它们能显示出图像从明亮到黑暗流动的过程。</strong></p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/48ef51a7f8c2467eab3dd59efacf19a7><p class=pgc-img-caption></p></div><p>分析每个像素对我们来说太过细节化了，像素过多不利于整体的分析，我们应该从更高的角度观察明暗的流动。为此我们<strong>将图像分割成16x16像素的小方块</strong>。在每个小方块中，计算出每个主方向有多少个梯度（有多少指向上，指向右上，指向右等）。然后<strong>用指向性最强的那个方向箭头来代替原来那个小方块</strong>。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fbeaa125d5dc401897b43101c2018eea><p class=pgc-img-caption></p></div><p>最终结果，我们把<strong>原始图像转换成非常简单的HOG图像</strong>，它可以很轻松的捕获面部的基本结构。为了在HOG图像中找到脸部，我们需要做的是，与<strong>已知的一些HOG图案中</strong>，来寻找看起来最相似的部分。</p><p>这些<strong>HOG图案都是从其他面部训练数据中提取出来</strong>的。</p><p><br></p><p><strong>级联分类器</strong></p><p style=text-align:justify>对于本次的设计人脸检测，可以说是一次机器学习的过程。级联分类器中有一个级联分类函数，此函数当中的一些参数就是由机器训练得到的。对于人脸识别，计算机通过大量带人脸和不带人脸的图片，对人脸上的几万个特征，通过机器学习找出人脸<strong>分类效果最好、错误率最小的特征</strong>。训练开始时，所有训练集中的图片具有相同的权重，对于被分类<strong>错误的图片，提升权重</strong>，重新计算出新的错误率和新的权重。直到错误率或迭代次数达到要求。这种<strong>训练方法叫做Adaboost</strong>。</p><p style=text-align:justify>上文提到的hog图像，正是由adaboost训练方法对大量图片进行训练后所提取出来的。</p><p style=text-align:justify><br></p><p><strong>Cascade级联分类器</strong></p><p style=text-align:justify>Cascade 译为级联，阶梯。cascade级联分类器是一种基于Haar特征的有效的物体检测方法。</p><p style=text-align:justify><br></p><p>一张图片绝大部分的区域都不是人脸。如果对一张图片的每个角落都提取6000个特征，将会浪费巨量的计算资源。</p><p>如果能找到一个简单的方法能够检测某个窗口是不是人脸区域，如果该窗口不是人脸区域，那么就只看一眼便直接跳过，也就不用进行后续处理了，这样就能集中精力判别那些可能是人脸的区域。为此，有人引入了Cascade 分类器。它不是将6000个特征都用在一个窗口，而是将特征分为不同的阶段，然后一个阶段一个阶段的应用这些特征(通常情况下，前几个阶段只有很少量的特征）。如果窗口在第一个阶段就检测失败了，那么就直接舍弃它，无需考虑剩下的特征。如果检测通过，则考虑第二阶段的特征并继续处理。如果所有阶段的都通过了，那么这个窗口就是人脸区域。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a0b12d8521744d31b72cd5059b8eb0ab><p class=pgc-img-caption></p></div><p>比如上图中，横的黑道将人脸中较暗的双眼提取了出来，而竖的白道将人脸中较亮的鼻梁提取了出来。</p><p>由于事先不太可能知道要检测的目标的大小，这就要求我们的级联表中的分类器具有按比例增大(或者缩小)的能力，这样，当小的窗口移动完整个待检测图片没有发现目标时，我们可以调整分类器的大小，然后继续检测，直到检测到目标或者窗口与待检测图片的大小相当为止。人脸检测流程图见图</p><p><br></p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/413474fa35704022a97a2dd17e9914ce><p class=pgc-img-caption></p></div><p><br></p><p><strong>人脸检测具体实现</strong></p><p><strong>环境搭建</strong></p><p style=text-align:justify>本项目采用python作为编辑器，pycharm作为解释器。</p><p style=text-align:justify>OpenCV是一个可跨平台的计算机视觉和机器学习的软件库，实现了图像处理和计算机视觉方面的很多通用算法。</p><p style=text-align:justify>安装OpenCV时，有以下几种方法。</p><p style=text-align:justify>一，首先可以利用的是pycharm来进行引入</p><p style=text-align:justify>file -- settings --project interpreter-- +</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b43690d5661419f956d52f84cec64f2><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>选择OpenCV--python ---install</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ae0e899d7bb4772b6dadc009f3335d8><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>如果安装成功，随后你可以在project interpreter里来进行版本的查看。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84e8cd6626bf495486f8f967477ade1a><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>二，利用常规命令</p><p style=text-align:justify>Win+r后输入cmd，随后输入pip install OpenCV-python</p><p style=text-align:justify>如果显示install successfully，则安装完成。</p><p style=text-align:justify><br></p><p style=text-align:justify>如果报错，read time error ，则可能是库在下载时有延迟的问题，需要在命令里加入一个代理，这里用到的是豆瓣的，在install 后面加入以下命令即可。</p><p style=text-align:justify>- -index-url https://pypi.douban.com/simple opencv-python</p><p style=text-align:justify><br></p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/79cc7faec083411ab89dc9c151fecda2><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p style=text-align:justify>OpenCV可以说是人脸物体检测识别中比较常用的一个库，利用import cv2来进行调用。</p><p style=text-align:justify><br></p><p><strong>项目代码</strong></p><p>对于识别本地图片中的人脸，我们需要进行以下几个步骤的操作：</p><p>1）把图像转换为灰度图，这样可以去除色彩对目标检测的影响。同时可以降低图像的噪声。</p><pre><code>import cv2  #引入OpenCV模块</code></pre><pre><code> #规定图像的路径。filepath = "./image1.png" </code></pre><pre><code> # ./为当前文件夹下的相对路径，我们需要将检测图片与程序文件放于同一文件夹下。</code></pre><pre><code>img = cv2.imread(filepath)</code></pre><pre><code>#cv2.IMread就是利用OpenCV模块来读取此路径下的图片文件   imread=image-read</code></pre><pre><code>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</code></pre><pre><code>#img为原始彩色图片，这里我们用到了cv2模块的图像颜色转换功能，将转换后的图像命名为gray</code></pre><pre><code>cv2.imshow("Image", gray)</code></pre><pre><code>#显示灰色图像</code></pre><pre><code></code></pre><p>2）在灰色图像上进行矩形框的绘制</p><pre><code>cv2.imshow("Image-gray", img)x = y = 100  # 任意规定一个座标w =h= 135  # 矩形的宽、高color = (0,255,0)  # 定义绘制颜色，遵循bgr模式cv2.rectangle(img, (x, y), (x + w, y + h),color , 3)  #调用cv2里的rectangle来 绘制矩形，rectangle（图像，左上角座标，右下角座标，颜色，线粗）cv2.imshow("Image-gray-square", img)  # 显示灰色方框图像</code></pre><p><br></p><p>3）使用分类器查找人脸</p><p>CascadeClassifier是Opencv中做人脸检测时候的一个级联分类器。数据结构包括Data和FeatureEvaluator两个主要部分。Data中存储的是从训练获得的xml文件中载入的分类器数据；而FeatureEvaluator中是关于特征的载入、存储和计算。这里采用的训练文件是OpenCV中默认提供的haarcascade_frontalface_default.xml。至于Haar，LBP的具体原理，可以参考opencv的相关文档，简单地，可以理解为人脸的特征数据。</p><pre><code>face_engine=cv2.CascadeClassifier(cv2.data.haarcascades+'haarcascade_frontalface_default.xml')</code></pre><pre><code># 导入人脸级联分类器引擎，'.xml'文件里包含已经训练出来的人脸特征</code></pre><pre><code></code></pre><pre><code>faces=face_engine.detectMultiScale(img,scaleFactor=1.3,minNeighbors=5)</code></pre><pre><code># 用人脸级联分类器引擎进行人脸识别，返回的faces为人脸座标列表，1.3是放大比例，5是重复识别次数</code></pre><pre><code></code></pre><p><br></p><p>整体代码如下：</p><pre><code>importcv2</code></pre><pre><code>img=cv2.imread('image1.jpg',1)</code></pre><pre><code>face_engine=cv2.CascadeClassifier(cv2.data.haarcascades+'haarcascade_frontalface_default.xml')</code></pre><pre><code>faces=face_engine.detectMultiScale(img,scaleFactor=1.3,minNeighbors=5)</code></pre><pre><code>for(x,y,w,h)infaces:</code></pre><pre><code>    img =cv2.rectangle(img,(x,y),(x+w,y+h),(255,0,0),2)</code></pre><pre><code>cv2.imshow('img2',img)</code></pre><pre><code>cv2.waitKey(0)</code></pre><pre><code>cv2.destroyAllWindows()</code></pre><pre><code>cv2.imwrite('output.jpg',img)</code></pre><pre><code></code></pre><p><br></p><p>注：</p><p>* cv2.waitKey等待键盘输入，单位为毫秒，即等待指定的毫秒数看是否有键盘输入，若在等待时间内按下任意键则返回按键的ASCII码，程序继续运行。若没有按下任何键，超时后返回-1。参数为0表示无限等待。不调用waitKey的话，窗口会一闪而逝，看不到显示的图片。</p><p>* cv2.destroyAllWindow()销毁所有窗口</p><p>* cv2.destroyWindow(wname)销毁指定窗口</p><p><br></p><p>运行结果图</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b20290ad7d9432391ff11acb8af4dea><p class=pgc-img-caption></p></div><p>由此可以看出此代码运行结果良好，符合预期结果。</p><p><br></p><p><strong>代码改进</strong></p><p>上述代码为引入本地图片来进行人脸测量。现在改进下代码，可以通过摄像头进行实时的人脸检测。</p><p>在源代码的基础上，增加以下语句：</p><pre><code>cap=cv2.VideoCapture(0)</code></pre><pre><code>while(True):</code></pre><pre><code>   # 获取摄像头拍摄到的画面</code></pre><pre><code>    ret, frame=cap.read()</code></pre><pre><code>faces=face_cascade.detectMultiScale(frame,1.3,5)</code></pre><pre><code>#frame是摄像头捕捉到的画面</code></pre><pre><code></code></pre><pre><code>.....</code></pre><pre><code></code></pre><pre><code>   #每隔5毫秒监听一次键盘，当按下q键时退出摄像窗口</code></pre><pre><code>ifcv2.waitKey(5)&amp;0xFF==ord('q'):</code></pre><pre><code>   break</code></pre><pre><code># 关闭所有窗口</code></pre><pre><code>cap.release()</code></pre><pre><code>cv2.destroyAllWindows()</code></pre><p><br></p><p>利用手机播放视频，可进行实时人脸检测，运行结果良好。结果如图</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dae4b85bb0584305a8d63b9743331de0><p class=pgc-img-caption></p></div><p><br></p><p><strong>注</strong>：</p><p>1）在用cv2.rectangle进行画框时，原始定义为（图像，左上角，右下角）。但由于疏忽，有一次我将左上角和右下角的座标顺序写反，即（右下角，左上角）。但是结果却依然正确。在后来我将数据改为（右上角，左下角）（左下角，右上角），<strong>结果依然一样。因此得知，rectangle是利用对角线来进行矩形的框定。</strong></p><p>在此附上此次验证的相关代码：</p><pre><code></code></pre><pre><code>import cv2# filepath = "./men-face.jpg"image = cv2.imread('./men-face.jpg',cv2.IMREAD_GRAYSCALE)h, w = image.shape[:2]h, w = map(int, [h/4, w/4])draw_0 = cv2.rectangle(image, (2*w, 2*h), (3*w, 3*h), (255, 0, 0), 2)draw_1 = cv2.rectangle(image, (2*w, 3*h), (3*w, 2*h), (255, 0, 0), 2)draw_2 = cv2.rectangle(image, (3*w, 2*h), (2*w, 3*h), (255, 0, 0), 2)draw_3 = cv2.rectangle(image, (3*w, 3*h), (2*w, 2*h), (255, 0, 0), 2)cv2.imshow("origin.jpg", draw_0)cv2.imshow("change1.jpg", draw_1)cv2.imshow("change2.jpg", draw_2)cv2.imshow("change3.jpg", draw_3)cv2.waitKey(0)cv2.destroyAllWindows()</code></pre><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6777500c9f754771878a8e06e2739ea5><p class=pgc-img-caption></p></div><p><br></p><p>2）HOG的发明者是Navneet Dalal，在2005年其在CVPR上发表了Histograms of Oriented Gradients forHuman Detection这一篇论文。</p><p><strong>HOG算法思想</strong>：</p><p>在计算机视觉以及数字图像处理中梯度方向直方图(HOG)是一种能对物体进行检测的基于形状边缘特征的描述算子，它的基本思想是利用梯度信息能很好的反映图像目标的边缘信息并通过局部梯度的大小将图像局部的外观和形状特征化。一些研究者利用梯度HOG特征并结合其他特征对人体进行检测得到了较好的结果。</p><p>HOG特征的提取可以用下图所示的过程表示: <strong>颜色空间的归一化</strong>是为了减少光照以及背景等因素的影响；划分检测窗口成大小相同的细胞单元(cell)，并分别<strong>提取相应的梯度信息</strong>；组合相邻的细胞单元成大的相互有<strong>重叠的块(block)</strong>，这样能有效的利用重叠的边缘信息，以统计整个块的直方图；并对<strong>每个块内的梯度直方图进行归一化</strong>，从而进一步减少背景颜色及噪声的影响；最后将整个窗口中所有块的<strong>HOG特征收集起来</strong>，并使用特征向量来表示其特征。在这一过程中，不同尺度的参数模板、梯度方向的选择、重叠块及单元格的大小还有归一化因子等因素都会影响最终的检测结果。最终<strong>通过SVM或cascade分类器</strong>分离出正确的行人目标。</p><p>HOG的整体流程图如下所示。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/16786406efb249feb1c8c98ef675a2a3><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81a7562451de489289ff4f7bcd696232><p class=pgc-img-caption></p></div><p><strong>颜色空间归一化：</strong></p><p>在现实的情况，图像目标会出现在不同的环境中，光照也会有所不一样，颜色空间归一化就是对整幅图像的颜色信息作归一化处理从而减少不同光照及背景的影响，也为了提高检测的鲁棒性，<strong>引入图像Gamma校正和颜色空间归一化来作为特征提取的预处理手段</strong>。ND等人也对不同的图像像素点的表达方式包括灰度空间等进行了评估，最终验证<strong>RGB还有LAB</strong>色彩空间能使检测结果大致相同且能起到积极的影响，且另一方面，ND等人在研究中分别在每个颜色通道上使用了两种不同的Gamma归一化方式，取平方根或者使用对数法，最终验证这一预处理对检测的结果几乎没有影响，而<strong>不能对图像进行高斯平滑处理</strong>，因平滑处理会降低图像目标边缘信息的辨识度，影响检测结果。</p><p><br></p><p><strong>梯度计算：</strong></p><p><strong>边缘是由图像局部特征包括灰度、颜色和纹理的突变导致的。</strong>一幅图像中相邻的像素点之间变化比较少，区域变化比较平坦，则梯度幅值就会比较小，反之，则梯度幅值就会比较大。梯度在图像中对应的就是其一阶导数。模拟图像f(x,y)中任一像素点（x,y）的梯度是一个矢量：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/029a1301baf2455db270074b47ee8792><p class=pgc-img-caption></p></div><p>其中，Gx是沿x方向上的梯度，Gy是沿y方向上的梯度，梯度的幅值及方向角可表示如下：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f16554bace4d498c9a48e2489e62175f><p class=pgc-img-caption></p></div><p>数字图像中像素点的梯度是用差分来计算的：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8d854404a7a34495a96b7b0f3a82b76f><p class=pgc-img-caption></p></div><p><br></p><p>一维离散微分模板在将图像的梯度信息简单、快速且有效地计算出来，其公式如下：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b92813a467f24a1db52f1e32d1d27553><p class=pgc-img-caption></p></div><p>式中，Gx，Gy，H(x,y)分别表示的是像素点（x,y）在水平方向上及垂直方向上的梯度以及像素的灰度值，其梯度的幅值及方向计算公式如下：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c414d11da99a495bbbe3bf989132566c><p class=pgc-img-caption></p></div><p>ND等人也验证，不同的梯度运算模板在其检测效果上也不一样，如下表，可以看出，<strong>使用简单的一维离散微分模板[-1,0,1]</strong>进行的梯度运算得到的检测效果是最好的，而使用其他形式的梯度运算模板如Prewitt和Sobel等算子，如下图所示，不仅增加运算量而同时也降低了其检测效果。</p><p><br></p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4fdf302548ca4146905c88f4c1c8d303><p class=pgc-img-caption></p></div><p><br></p><p><strong>计算细胞单元的梯度直方图：</strong></p><p>对于整个目标窗口，我们需要<strong>将其分成</strong><em><strong>互不重叠</strong></em><strong>大小相同的细胞单元（cell）</strong>，然后分别计算出每个cell的梯度信息，包括梯度大小和梯度方向。ND大神等人实验指出，将像素的梯度方向在0-180°区间内<strong>平均划分为9个bins</strong>，超过9个时不仅检测性能没有明显的提高反而增加了检测运算量, <strong>每个cell内的像素为其所在的梯度方向直方图进行加权投票</strong>，加权的权值可以是像素本身的梯度幅值，也可以是幅值的平方或平方根等，而若使用平方或平方根，实验的检测性能会有所降低，ND等人也验证，<strong>使用梯度幅值的实验效果更可靠</strong>。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e132356bf1b54bb8ba5db5d603680717><p class=pgc-img-caption></p></div><p style=text-align:center>梯度直方图的计算</p><p><br></p><p><strong>对组合成块的梯度直方图作归一化：</strong></p><p>从梯度计算公式中可以看出，梯度幅值绝对值的大小容易受到前景与背景对比度及局部光照的影响，要减少这种影响得到较准确的检测效果就<strong>必须对局部细胞单元进行归一化处理</strong>。归一化方法多种多样，但整体思想基本上是一致的：<strong>将几个细胞单元（cell）组合成更大的块（block）</strong>，这时整幅图像就可看成是待检测窗口，将<strong>更大的块看成是滑动窗口，依次</strong><em><strong>从左到右从上到下进行滑动</strong></em>，得到一些有重复细胞单元的块及一些相同细胞单元（cell）在不同块（block）中的梯度信息，再对这些块（block）信息分别作归一化处理，不同的细胞单元尺寸大小及不同块的尺寸大小会影响最终的检测效果。</p><p><br></p><p>假设64×64像素是检测的窗口的尺寸，分成 4×4=16 个细胞单元(cell)，如下图中黑色的小框(1-16),16×16 像素是每个细胞单元的大小，块（block）是由相邻的 2×2=4 个细胞单元组成的，如图紫色的小框，滑动窗口的大小为一个块的大小，依次<strong>将滑动窗口从左到右从上到下进行滑动来获得整个待测窗口的边缘信息</strong>，得到9个块，<strong>统计这9个块在9个不同方向上的梯度信息</strong>，在整个窗口中得到的梯度特征是9×9=81 维的向量。在实际情况中我们的检测窗口的大小为128×64像素，一个细胞单元的大小为8×8像素，由2×2个细胞单元组成大小为16×16像素的块，一个细胞单元的梯度直方图化成9个bins，块的移动步长是8个像素，则检测窗口在图像中移动的步长也为8个像素，这样检测窗口就有((128-16)/8+1)×((64-16)/8+1)= 105个块，一<strong>个块有4个细胞单元，每个细胞单元的HOG特征向量长度是9，则最终的HOG特征描述符大小就是105×4×9 = 3780维</strong>。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7b81e3a864a34f61953254c85d71882c><p class=pgc-img-caption></p></div><p>对于块的梯度直方图向量的归一化，ND等人使用了不同方法，并对结果进行了比较，假设V是未归一化的向量，是一个很小的必要的常数，下式是定义的范数的函数表达式：</p><p>L1范数：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/54f949e82ff642adb4828cc3f0bb6061><p class=pgc-img-caption></p></div><p>L2范数：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a2870503f0144f4a88c9814678d28001><p class=pgc-img-caption></p></div><p>归一化计算公式为：</p><p>L2常规：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75f14d7fe87b4b75bc2a7a14b3df5b39><p class=pgc-img-caption></p></div><p>L1常规：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/102a5bf066994d3ba8cde20cfaa80ff9><p class=pgc-img-caption></p></div><p>L1平方根：</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de700fb6b5c041c4a703818c00a44c85><p class=pgc-img-caption></p></div><p>ND等人指出，用L1常规方法进行向量归一化比用L2常规和L1平方根方法而得到的检测效果降低5%。</p><div class=pgc-img><img alt=OpenCV项目实战---人脸检测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4aae31212fe241499f845fe2ac7db8c7><p class=pgc-img-caption></p></div><p style=text-align:justify><em>来源：六月的日记 作者：小胖鸭</em></p><p><strong>End</strong></p><p><br></p><p>声明：部分内容来源于网络，仅供读者学习、交流之目的。文章版权归原作者所有。如有不妥，请联系删除。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'OpenCV','项目','实战'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>