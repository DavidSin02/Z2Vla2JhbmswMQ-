<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C标准库思维导图、C++关键字概览 | 极客快訊</title><meta property="og:title" content="C标准库思维导图、C++关键字概览 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9c45ebbd6db7482dbe471cbd165610e6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d086d136.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d086d136.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d086d136.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d086d136.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d086d136.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d086d136.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d086d136.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d086d136.html><meta property="article:published_time" content="2020-10-29T21:12:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:29+08:00"><meta name=Keywords content><meta name=description content="C标准库思维导图、C++关键字概览"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d086d136.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C标准库思维导图、C++关键字概览</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>1 C标准库思维导图</p><p>https://wwuhn.github.io/shared/C标准库思维导图.png</p><div class=pgc-img><img alt=C标准库思维导图、C++关键字概览 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9c45ebbd6db7482dbe471cbd165610e6><p class=pgc-img-caption></p></div><p><br></p><p>2 C++关键字概览</p><p>https://wwuhn.github.io/shared/cppKeywords.html</p><div class=pgc-img><img alt=C标准库思维导图、C++关键字概览 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a16e694d56a3498bb481ed2d0c6f2986><p class=pgc-img-caption></p></div><p>1 asm</p><p>asm (assembly)</p><p><br></p><p>允许在 C++ 程序中嵌入汇编代码。</p><pre><code>    int a=5;      int b=4;    __asm    {          mov eax, a  ;可以像这样直接对eax赋值          mov ebx, b;          add eax, ebx         mov a, eax ;可以直接将eax的值赋给a      }</code></pre><h4 class=pgc-h-arrow-right>2 auto</h4><p>auto（自动，automatic）</p><p>① 是存储类型标识符，表明变量"自动"具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。（until C++11）</p><p>② 对于变量，指定将从其初始值自动推断声明的变量的类型。(since C++11)</p><p>③ 对于函数，指定将从其返回语句推导返回类型。(since C++14)</p><p>④ 对于非类型模板参数，指定将从参数派生类型。(since C++17)</p><h4 class=pgc-h-arrow-right>3 bool</h4><p>bool（布尔）</p><p>bool表示逻辑类型，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。</p><h4 class=pgc-h-arrow-right>4 break</h4><p>break（中断、跳出）</p><p>用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。</p><p>通常和if、case语句配合使用。</p><h4 class=pgc-h-arrow-right>5 case</h4><p>用于 switch 语句中，用于判断不同的条件类型。</p><p>标签语句，提供执行入口，符合条件时进入，直至break或default:或switch结束。</p><h4 class=pgc-h-arrow-right>6 catch</h4><p>catch 和 try 语句一起用于异常处理。在try中（包括其调用的函数）抛出异常，catch按抛出的数据类型匹配异常。</p><h4 class=pgc-h-arrow-right>7 char</h4><p>char（字符，character）</p><p>C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ' 括起来。</p><h4 class=pgc-h-arrow-right>8 class</h4><p>class（类）是 C++ 面向对象设计的基础。① 使用 class 关键字声明一个类。</p><p>② 用于声明一个强类型的enum。(since C++11)</p><pre><code>enum class Color { red, green = 20, blue };</code></pre><p>③ 在模板函数或模板类中，用来声明一个类型参数，此时可用typename代替。</p><h4 class=pgc-h-arrow-right>9 const</h4><p>const（常量的，constant）</p><p>表示所修饰的对象或变量不能被改变，① 修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。② 用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如:</p><pre><code>const double pi(3.14159);或 const double pi = 3.14159;</code></pre><p>用于修饰指针时要考虑修饰的是指针本身还是指针所指向的内存单元：</p><pre><code>const int* p;       // 修饰int，表示不能用p更新其指向的内存单元int const* p;       // 同上int* const p;       // 修饰p，表示指针p本身是常量，不能被更新                    // 区别其实就是以*为分隔，看const是在*前还在*后const int* const p; // 综合上述，两者同为const</code></pre><h4 class=pgc-h-arrow-right>10 const_cast</h4><p>const_cast&lt;type_to> (expression)</p><p>该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_to 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。</p><pre><code>    int i = 3;                 // i is not declared const    const int&amp; rci = i;     const_cast&lt;int&amp;&gt;(rci) = 4; // OK: modifies i</code></pre><h4 class=pgc-h-arrow-right>11 continue</h4><p>continue（继续）</p><p>用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是"继续循环"之意，不是 break（跳出）。常和if语句配合使用。</p><h4 class=pgc-h-arrow-right>12 default</h4><p>default（默认、缺省）</p><p>① 用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。</p><p>② explicitly-defaulted function definition: as an explicit instruction to the compiler to generate special member function(since C++11) or a comparison operator (since C++20) for a class.</p><h4 class=pgc-h-arrow-right>13 delete</h4><p>delete（删除）</p><p>① 释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。</p><p><br></p><pre><code>Complex* pc = new Complex(1,2);// ...delete pc;// 编译器转化为：Complex::~Complex(pc); // ① 调用析构函数operator delete(pc);   // ② 释放内存，内部调用free(pc)</code></pre><p>② deleted functions (since C++11)</p><h4 class=pgc-h-arrow-right>14 do</h4><p>do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。</p><h4 class=pgc-h-arrow-right>15 double</h4><p>double（双精度）</p><p>C++ 中的基本数据类型，以双精度形式存储一个浮点数。（IEEE-754）</p><h4 class=pgc-h-arrow-right>16 dynamic_cast</h4><p>dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。</p><pre><code>struct V {    virtual void f() {};  // must be polymorphic to use runtime-checked dynamic_cast};struct A : virtual V {};struct B : virtual V {  B(V* v, A* a) {    // casts during construction (see the call in the constructor of D below)    dynamic_cast&lt;B*&gt;(v); // well-defined: v of type V*, V base of B, results in B*    dynamic_cast&lt;B*&gt;(a); // undefined behavior: a has type A*, A not a base of B  }};</code></pre><h4 class=pgc-h-arrow-right>17 else</h4><p>else 紧跟在 if 后面，用于对 if 不成立的情况的选择。</p><p>else与if按最近原则匹配，if后尽量不要省略else，避免悬挂。</p><h4 class=pgc-h-arrow-right>18 enum</h4><p>enum（枚举，enumeration）</p><p>对于一个整型变量，如果只有几种有限的取值可能时，可以把这些值枚举出来，并用符号常量代替之。</p><h4 class=pgc-h-arrow-right>19 explicit</h4><p>explicit（显式的）</p><p>禁止单参数构造函数被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。</p><h4 class=pgc-h-arrow-right>20 export</h4><p>① 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。</p><p>Used to mark a template definition exported, which allows the same template to be declared, but not defined, in other translation units. (until C++11)</p><p>② Marks a declaration, a group of declarations, or another module as exported by the current module. (since C++20)</p><h4 class=pgc-h-arrow-right>21 extern</h4><p>extern（外部的）</p><p>① 声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。② 指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式：</p><pre><code>extern "C" 声明语句extern "C" { 声明语句块 }</code></pre><p>③ explicit template instantiation declaration (or "extern template")</p><pre><code>extern template class|struct template-name &lt; argument-list &gt; ;	(2)	(since C++11)</code></pre><h4 class=pgc-h-arrow-right>22 false</h4><p>false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。</p><h4 class=pgc-h-arrow-right>23 float</h4><p>float（浮点数）</p><p>C++ 中的基本数据类型，精度小于 double。（IEEE754）</p><h4 class=pgc-h-arrow-right>24 for</h4><p>① for 是 C++ 中的循环结构之一，一般用于重复次数确定的循环，在for()的()内写三个表达式（用分号“;”分隔，分别表示循环变量的初始化、取逻辑值的判断语句，循环变量更新语句），第一个语句可以写到for前面，第二、三个语句可以写到循环体中，但两个分号“;”都不能被省略。</p><p>② range-based for loop: as the declaration of the loop (since C++11)</p><h4 class=pgc-h-arrow-right>25 friend</h4><p>friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。</p><h4 class=pgc-h-arrow-right>26 goto</h4><p>goto（转到）</p><p>用于无条件跳转到某一标号处开始执行。对应语言的jmp或jp系列条件跳转命令。在没有语句块和控制结构语句之前，通常通过goto语句实现跳转。往后跳可形成循环，往前跳可形成条件分支。</p><h4 class=pgc-h-arrow-right>27 if</h4><p>if（如果）</p><p>C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。</p><h4 class=pgc-h-arrow-right>28 inline</h4><p>inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。</p><h4 class=pgc-h-arrow-right>29 int</h4><p>int（整型，integer）</p><p>C++ 中的基本数据类型，用于表示整数，数据范围（内存单元数量）小于 long。</p><h4 class=pgc-h-arrow-right>30 long</h4><p>long（长整型，long integer）</p><p>C++ 中的基本数据类型，用于表示长整数。</p><h4 class=pgc-h-arrow-right>31 mutable</h4><p>mutable（易变的）</p><p>C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对象的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。</p><h4 class=pgc-h-arrow-right>32 namespace</h4><p>namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。用于包裹变量、自定义类型声明、函数声明，形成一个定义域。</p><h4 class=pgc-h-arrow-right>33 new</h4><p>用于新建一个对象。new 运算符总是返回一个指针。</p><p>new、delete在C++中定义为操作符函数，用于动态分配堆上内存。C++编译器对new、delete的底层实现还是调用了malloc()和free()，但做了封装，且C++编译器对new、delete语句在编译时做了一些额外的工作。</p><p><br></p><pre><code>Complex* pc = new Complex(1,2);            // 在堆上new一个对象：                                           // 编译器转化为：Complex *pc;void* mem = operator new(sizeof(Complex)); // ① 分配内存，内部调用malloc(n)pc = static_cast&lt;Complex*&gt;(mem);           // ② 转型pc-&gt;Complex::Copmlex(1,2);                 // ③ 调用构造函数</code></pre><h4 class=pgc-h-arrow-right>34 operator</h4><p>operator（操作符）</p><p>用于操作符重载。这是 C++ 中的一种特殊的函数。</p><pre><code>operator op	(1)	operator type	(2)	operator newoperator new []	(3)	operator deleteoperator delete []	        (4)	operator "" suffix-identifier	(5) (since C++11)operator co_await	        (6) (since C++20)</code></pre><h4 class=pgc-h-arrow-right>35 private</h4><p>private（私有的）</p><p>C++ 中的访问控制符。被标明为 private 的字段只能在本类成员函数以及友元函数或友元类的成员函数中访问。</p><p>如果是B是private继承自A，则A的全部成员虽是A的一部分，但不能被访问(因为private部分只能由其成员函数访问，因为其private继承，成员函数也成了私有)。</p><h4 class=pgc-h-arrow-right>36 protected</h4><p>protected（受保护的）</p><p>C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。</p><p>如果是B是protected继承自A，则A的public和protected成员在B中变成了protected。</p><h4 class=pgc-h-arrow-right>37 public</h4><p>public（公有的）</p><p>C++ 中的访问控制符。被标明为 public 的字段可以在任何类</p><h4 class=pgc-h-arrow-right>38 register</h4><p>register（寄存器）</p><p>声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。</p><h4 class=pgc-h-arrow-right>39 reinterpret_cast</h4><p>reinpreter_cast&lt;type_to> (expression)</p><p>type_to 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。</p><h4 class=pgc-h-arrow-right>40 return</h4><p>return（返回）</p><p>用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。</p><h4 class=pgc-h-arrow-right>41 short</h4><p>short（短整型，short integer）</p><p>C++ 中的基本数据类型，用于表示整数，数值范围（或内存单元大小）小于 int。</p><h4 class=pgc-h-arrow-right>42 signed</h4><p>signed（有符号）</p><p>表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。</p><h4 class=pgc-h-arrow-right>43 sizeof</h4><p>由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 sizeof 运算符获得该数据类型占用的字节数。</p><h4 class=pgc-h-arrow-right>44 static</h4><p>static（静态的）</p><p>① 存续期：静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为 0，使用时可改变其值。</p><p>② 文件链接性：静态变量或静态函数，只有本文件内的代码才可访问它，它的名字（变量名或函数名）在其它文件中不可见。因此也称为"文件作用域"。</p><p>③ 静态成员：在 C++ 类的成员变量被声明为 static（称为静态成员变量），意味着它被该类的所有实例所共享，也就是说当某个类的实例修改了该静态成员变量，其修改值为该类的其它所有实例所见；而类的静态成员函数也只能访问静态成员（变量或函数）。类的静态成员变量必须在声明它的文件范围内进行初始化才能使用，private 类型的也不例外。</p><h4 class=pgc-h-arrow-right>45 static_cast</h4><p>static_cast&lt;type_to>(expression)</p><p>该运算符把 expression 转换为 type_to 类型，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：</p><p>① 用于类层次结构中基类和子类之间指针或引用的转换。进行上行转换（把子类的指针或引用转换成基类表示）是安全的；进行下行转换（把基类指针或引用转换成子类表示）时，由于没有动态类型检查，所以是不安全的。</p><p>② 用于基本数据类型之间的转换，如把 int 转换成 char，把 int 转换成 enum。这种转换的安全性也要开发人员来保证。</p><p>③ 把空指针转换成目标类型的空指针。</p><p>④ 把任何类型的表达式转换成void类?</p><p>注意 static_cast 不能转换掉 expression 的 const、volitale、或者 __unaligned 属性。</p><h4 class=pgc-h-arrow-right>46 struct</h4><p>struct（结构）</p><p>类似于 class 关键字，与 C 语言兼容（class 关键字是不与 C 语言兼容的），可以实现面向对象程序设计。</p><p>enum struct|class name { enumerator = constexpr , enumerator = constexpr , ... }</p><h4 class=pgc-h-arrow-right>47 switch</h4><p>switch（转换）</p><p>类似于 if-else-if 语句，是一种多分枝语句。它提供了一种简洁的书写，并且能够生成效率更好的代码。但是，switch 后面的判断只能是int（char也可以，但char本质上也是一种int类型）。switch 语句最后的 default 分支是可选的。</p><h4 class=pgc-h-arrow-right>48 template</h4><p>template（模板）</p><p>C++ 中泛型机制的实现。</p><h4 class=pgc-h-arrow-right>49 this</h4><p>关键字this是一个prvalue（纯右值）表达式，其值是调用成员函数的对象的地址。</p><p><br></p><pre><code>#include&lt;iostream&gt;class T{    int x;public:    void foo()       // implicitly including a pointer: void foo(T* this)    {        x = 6;       // same as this-&gt;x = 6;        this-&gt;x = 5; // explicit use of this-&gt;		std::cout&lt;&lt;x;    }};void main(){    T obj;	obj.foo();      // obj. as obj* this;}</code></pre><p>this指针有时可以显式使用，有时不能。</p><h4 class=pgc-h-arrow-right>50 throw</h4><p>throw（抛出）</p><p>用于实现 C++ 的异常处理机制，可以通过 throw 关键字"抛出"一个异常。</p><p>try或try调用的函数中throw exception。</p><h4 class=pgc-h-arrow-right>51 true</h4><p>true（真的）</p><p>C++ 的基本数据结构 bool 类型的值之一。等同于 int 的非 0 值。</p><h4 class=pgc-h-arrow-right>52 try</h4><p>try（尝试）</p><p>用于实现 C++ 的异常处理机制。可以在 try 中调用可能抛出异常的函数，然后在 try 后面的 catch 中捕获并进行处理。</p><p>try或try调用的函数中throw exception。</p><p><br></p><pre><code>try {   std::string("abc").substr(10);   // throws std::length_error} catch (const std::exception&amp; e) { // reference to the base of a polymorphic object     std::cout &lt;&lt; e.what();         // information from length_error printed}</code></pre><h4 class=pgc-h-arrow-right>53 typedef</h4><p>typedef（类型定义，type define）</p><p>typedef typeDeclaration newTypeName;</p><p>类型说明定义了一个数据类型的新名字而不是定义一种新的数据类型。定义名表示这个类型的新名字。</p><p><br></p><pre><code>// simple typedeftypedef unsigned long ulong; // common C idiom to avoid having to write "struct S"typedef struct {int a; int b;} S, *pS;// function pointertypedef void (*pf)(int,double);// std::add_const, like many other metafunctions, use member typedefstemplate&lt; class T&gt;struct add_const {    typedef const T type;};</code></pre><h4 class=pgc-h-arrow-right>54 typeid</h4><p>指出指针或引用指向的对象的实际派生类型。</p><h4 class=pgc-h-arrow-right>55 typename</h4><p>在模板函数或模板类中，typename（类型名字）关键字告诉编译器把一个特殊的名字解释成一个类型。在下列情况下必须对一个 name 使用 typename 关键字：</p><p>55.1 一个唯一的name（可以作为类型理解），它嵌套在另一个类型中的。</p><p>55.2 依赖于一个模板参数，就是说：模板参数在某种程度上包含这个name。当模板参数使编译器在指认一个类型时产生了误解。</p><p>In a template declaration, typename can be used as an alternative to class to declare type template parameters and template template parameters (since C++17).</p><p>Inside a declaration or a definition of a template, typename can be used to declare that a dependent qualified name is a type.</p><p>Inside a declaration or a definition of a template, (until C++11) typename can be used before a non-dependent qualified type name. It has no effect in this case.</p><p>Inside a requirements for type requirements (since C++20)</p><h4 class=pgc-h-arrow-right>56 union</h4><p>union（联合）</p><p>不同的数据成员共用一段内存单元空间，使用相同的地址，其内存的大小取决于所有成员中占用空间最大的成员。</p><p>A union is a struct in which all members are allocated at the same address so that the union occupies only as much space as its largest member. Naturally, a union can hold a value for only one member at a time.</p><p>使用场合：当两个结构体的成员只有一个不同时，两个结构体可以通过一个union合并成一个结构体：</p><pre><code>struct staff{        int num;        char name[10];        char sex;        char job;        union        {                int banji;                char position[10];        }category;    }staff[12];</code></pre><h4 class=pgc-h-arrow-right>57 unsigned</h4><p>unsigned（无符号）</p><p>表明该类型是无符号数，和 signed 相反。</p><h4 class=pgc-h-arrow-right>58 using</h4><p>表明使用 namespace。</p><h4 class=pgc-h-arrow-right>59 virtual</h4><p>virtual（虚的）</p><p>① C++ 中用来实现多态机制，声明虚函数（包括虚析构函数，不能是虚构造函数）。</p><p>② 虚继承其类，解决菱形继承问题。</p><h4 class=pgc-h-arrow-right>60 void</h4><p>void（空的）</p><p>可以作为函数返回值，表明不返回任何数据；可以作为参数，表明没有参数传入（C++中不是必须的）；void*可以作为指针使用。</p><p>void通常用于表示类型暂定，对于强类型语言，为了实现一些运算符或函数的通用性，通常首先将类型表示为void，最终类型转换为具体类型。如malloc()、new、qsort()等。</p><h4 class=pgc-h-arrow-right>61 volatile</h4><p>volatile（不稳定的）</p><p>① 限定一个对象可被外部进程（操作系统、硬件或并发线程等）改变，声明时的语法如下：</p><p>int volatile nVint;</p><p>这样的声明是不能达到最高效的，因为它们的值随时会改变，系统在需要时会经常读写这个对象的值。因此常用于像中断处理程序之类的异步进程进行内存单元访问。</p><p>② volatile-qualified member functions。</p><h4 class=pgc-h-arrow-right>62 wchar_t</h4><p>wchar_t（wide character typedef）是宽字符类型，每个 wchar_t 类型占 2 个字节，16 位宽。汉字的表示就要用到 wchar_t。</p><p>Required to be large enough to represent any supported character code point (32 bits on systems that support Unicode. A notable exception is Windows, where wchar_t is 16 bits and holds UTF-16 code units) It has the same size, signedness, and alignment as one of the integer types, but is a distinct type.</p><h4 class=pgc-h-arrow-right>63 while</h4><p>while用于表示一个循环，相对于for的重复次数相对确定，while常用于表示一些重复次数不确定的循环。</p><p>－End－</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'标准','库思维导','C++'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>