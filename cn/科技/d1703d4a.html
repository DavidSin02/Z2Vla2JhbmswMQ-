<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>网络内核之TCP是如何发送和接收消息的 | 极客快訊</title><meta property="og:title" content="网络内核之TCP是如何发送和接收消息的 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/d1b708de7db2403cbc70a570db2177f0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d1703d4a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d1703d4a.html><meta property="article:published_time" content="2020-11-14T21:05:04+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:04+08:00"><meta name=Keywords content><meta name=description content="网络内核之TCP是如何发送和接收消息的"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d1703d4a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>网络内核之TCP是如何发送和接收消息的</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-center><strong>网络内核之TCP是如何发送和接收消息的</strong></p><p>老规矩，带着问题阅读：</p><ul><li>三次握手中服务端做了什么？</li><li>为什么要将accept()单独一个线程而不是和读写的io线程共用一个线程池？netty分为boss和worker</li><li>当调用send()返回后数据就一定到对方或者在网线中传输了呢？</li></ul><p>我们先来回顾一下，我们编写一个网络程序有哪些步骤？基于socket的编程：</p><p>代码如下：</p><pre>public class Server { public static void main(String[] args) throws Exception { //创建一个socket套接字，开始监听某个端口 对应了 socket() bind() listen() ServerSocket serverSocket = new ServerSocket(8080); // (1) 接收新连接线程 new Thread(() -&gt; { while (true) { try { // 等待客户端连接，accept() 获取一个新连接 Socket socket = serverSocket.accept(); new Thread(() -&gt; { try { byte[] data = new byte[1024]; InputStream inputStream = socket.getInputStream(); while (true) { int len; // 读取字节数组 对应read() while ((len = inputStream.read(data)) != -1) { System.out.println(new String(data, 0, len)); } } } catch (IOException e) { } }).start(); } catch (IOException e) {} } }).start(); }}public class Client { public static void main(String[] args) { try { //对应 socket() 和 connect() 发起连接 Socket socket = new Socket("127.0.0.1", 8000); while (true) { try { //对应 write() 方法 socket.getOutputStream().write((new Date() + ": hello world").getBytes()); socket.getOutputStream().flush(); Thread.sleep(2000); } catch (Exception e) { } } } catch (IOException e) { } }}</pre><p>服务端我们首先会创建一个监听套接字，然后给这个套接字绑定一个ip和端口，这一步对应的方法就是bind(),之后就是调用listen()来监听端口，端口是和应用程序对应的，网卡收到一个数据包的时候后需要知道这个包是给哪个程序用的，当然一个应用程序可以监听多个端口。之后客户端发起连接内核会分配一个随机端口，然后tcp在经历三次握手成功后，客户端会创建一个套接字由connect()方法返回，而服务端的accept()方法也会返回一个套接字，之后双方都会基于这个套接字进行读写操作。所以服务端会维护两种类型的套接字，一种用于监听，另一种用于和客户端进行读写。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=网络内核之TCP是如何发送和接收消息的 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/d1b708de7db2403cbc70a570db2177f0><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>而在linux内核中，socket其实是一个文件，挂载于SocketFS文件类型下，有点类似于/proc，不过该文件不能像磁盘上的文件一样进行正常的访问和读写。既然是文件，就会有inode来表示索引，有具体的地方存储数据不管是磁盘还是内存，而socket的数据是存储在内存中的，每个报文的数据是存放在一个叫 sk_buff 的结构体里，要访问文件我们一般会对应一个文件描述符，每个文件描述符都会有一个id，在jdk中也有相关定义。</p><pre>public final class FileDescriptor { private int fd;</pre><p>jvm启动后就是一个独立进程，每个进程会维护一个数组，这个数组存放该进程已经打开的文件的描述符，数组前三个分别是标准输入，标准输出，错误输出三个文件描述符，从第4个开始为用户打开的文件，或者创建的socket，而数组的下标就是文件描述符的id，内核通过文件描述符可以找到对应的inode，然后在通过vfs找到对应的文件，进行read和write操作。</p><p class=ql-align-center><strong>三次握手</strong></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=网络内核之TCP是如何发送和接收消息的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6045026de1d34148bc5d8b862858974b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>linux内核中会维护两个队列，这两个队列的长度都是有限制且可以配置的，当客户端发起connect()请求后，服务端收到syn包后将该信息放入sync队列，之后客户端回复ack后从sync队列取出，放到accept队列，之后服务端调用accept()方法会从accept队列取出生成socket。</p><p>如果客户端发起sync请求，但是不回复ack，将导致sync队列满载，之后会拒接新的连接。如果客户端发起ack请求后，服务端一直不调用，或者调用accept队列太慢，将导致accept队列满载，accept队列满了则收到ack后无法从syn队列移出去，导致syn队列也会堆积，最终拒绝连接。所以服务端一般会将accept单独起一个线程执行，避免accept太慢导致数据丢弃。当然accept()方法也有阻塞和非阻塞两种，当accept队列为空的时候阻塞方法会一直等待，非阻塞方法会直接返回一个错误码。</p><p class=ql-align-center><strong>消息发送</strong></p><p>连接建立好后，客户端和服务端都有一个socket套接字，双方都可以通过各自的套接字进行发送和接收消息，socket里面维护了两个队列，一个发送队列，一个接收队列。</p><p>发送的时候数据在用户空间的内存中，当调用send()或者write()方法的时候，会将待发送的数据按照MSS进行拆分，然后将拆分好的数据包拷贝到内核空间的发送队列，这个队列里面存放的是所有已经发送的数据包，对应的数据结构就是sk_buff，每一个数据包也就是sk_buff都有一个序号，以及一个状态，只有当服务端返回ack的时候，才会把状态改为发送成功，并且会将这个ack报文的序号之前的报文都确认掉，如果长期没有确认，会重新调用tcp_push继续发送，如果发送队列慢了，则从用户空间拷贝到内核空间的操作就会阻塞，并触发清理队列中已确认发送成功的数据包。tcp层会将数据包加上ip头然后发给ip层处理，ip层将数据包加入到一个qdisc队列，网卡驱动程序检测到qdisc队列有数据就会调用DMA Engine将sk_buff拷贝到网卡并发送出去，网卡驱动通过ringbuffer来指向内核中的数据，所以qdisc的长度也会影响到网络发送的吞吐量。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=网络内核之TCP是如何发送和接收消息的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47c56c96c1cc41dd8874c08a9c79996f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=网络内核之TCP是如何发送和接收消息的 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/6ccdf1d0e4524fa3ad74147f9d615674><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>关于mss分片：mtu是数据链路层的最大传输单元，一般为1500字节，而一个ip包的最大长度为65535，所以ip层在发送数据前会根据mtu分片，这样一个tcp包本来对应一个ip包，分片后将对应多个ip包，每个包都有一个ip头,在接收端需要等到所有的ip包到达后，才能确定这个tcp收到然后才发送ack，这种方式无疑是低效的，所以tcp层会尽量阻止ip层进行分片，他会在从用户空间拷贝的时候就会按照mtu进行拆分，将一个数据包拆分成多个数据包。但是链路中mtu是会改变的，为了完全避免ip层进行分片，可以在ip层设置一个df标记，如果一定要分片就慧慧一个icmp报文。</p><p>关于流控：</p><ul><li>滑动窗口：接收方返回的一个最大发送序号。这个不是报文大小，而是一个序号，接收方每次会返回一个下次报文发送的序号不要超过的值。这个值主要和接收方内部缓存大小有关。</li><li>阻塞窗口：发送方根据网络拥堵情况，根据已经发送到网络但是还未确认的数据包的数量来计算。由于广域网络的复杂所以拥塞控制有一系列算法，如慢启动等。</li><li>nagle算法：为了避免机器发了大量的小数据包，nagle算法限制每次将多个小数据包达到一定大小后在发送。</li></ul><p>由于tcp发送的时候会进行各种分片和合并，所以接收方会出现粘包现象，需要应用层进行处理。</p><p class=ql-align-center><strong>消息接收</strong></p><p>当服务端网卡收到一个报文后，网卡驱动调用DMA engine将数据包通过ringbuffer拷贝到内核缓冲区中，拷贝成功后，发起中断通知中断处理程序，这时候ip层会处理该数据包，之后交给tcp层，最终到达tcp层的recv buffer（接收队列）,这时候就会返回ack给客户端，并没有等到客户端调用read将数据从内核拷贝到用户空间，所以应用层也应该有相关的确认机制。如果recv buffer设置的太小，或者应用层一直不来取，那么也将阻塞数据接收，从而影响到滑动窗口大小，导致吞吐量降低。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=网络内核之TCP是如何发送和接收消息的 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/52c8866c103f45e4a2df887741c58c3a><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center></p><p>tcp在收到数据包后会获取序号，并且看是否应该正好放入接收队列，如果此时收到一个大序号的报文，会将该报文缓存直到接收队列中之前的报文已经插入。</p><p>另外如果网卡支持多队列，可以将多个队列绑定到不同的cpu上，这样网卡收到报文后，不同的队列就会通过中断触发不同的cpu，从而可以提高吞吐量。</p><p class=ql-align-center><strong>c10k问题</strong></p><p>c10k问题是指怎么支持单机1万的并发请求，我们想到通过select的多路复用模式，用一个单独的线程去扫描需要监听的文件描述符，如果这些文件描述符里面有可读或者可写的就返回（tcp层在收到报文拷贝到内存后会修改这个文件描述符的状态），没有就阻塞，不过这种方式需要对文件描述符进行扫描，效率不高。而epoll方式采用红黑树去管理文件描述符，当文件可读或者可写的时候会通过一个回调函数通知用户进行具体的io操作。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'网络','内核','TCP'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>