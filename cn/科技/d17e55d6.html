<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>干货｜Spring核心机制之依赖注入（建议收藏） | 极客快訊</title><meta property="og:title" content="干货｜Spring核心机制之依赖注入（建议收藏） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/51887a9e50dc4be4af17b22398f6a901"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d17e55d6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d17e55d6.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="干货｜Spring核心机制之依赖注入（建议收藏）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d17e55d6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>干货｜Spring核心机制之依赖注入（建议收藏）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=干货｜Spring核心机制之依赖注入（建议收藏） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/51887a9e50dc4be4af17b22398f6a901><p class=pgc-img-caption></p></div><p>Java应用（从applets的小范围到全套n层服务端企业应用）是一种典型的依赖型应用，它就是由一些互相适当地协作的对象构成的。因此，我们说这些对象间存在依赖关系。加入A组件调用了B组件的方法，我们就可以称A组件依赖于B组件。我们通过使用依赖注入，Java EE应用中的各种组件不需要以硬编码方式耦合在一起，甚至无需使用工厂模式。当某个Java 实例需要其他Java 实例时，系统自动提供所需要的实例，无需程序显示获取，这种自动提供java实例我们谓之为依赖注入，也可以称之为控制反转（Inversion of Control IoC）。</p><p>其实不管是控制反转还是依赖注入，他们都可以这样理解：当某个Java实例（调用者）需要另一个Java实例（被调用者）时，在传统的程序设计过程中，通常有调用者来创建被调用者的实例。但是在依赖注入/控制反转模式下，创建被调用者的工作不再是有调用者来完成，而是由Spring容器来完成，然后注入调用者。</p><p>对于Spring而言，Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现都是透明的。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理。</p><p>依赖注入通常有如下两种：</p><p>1、 设置注入：IoC容器使用属性的setter方法来注入被依赖的实例。</p><p>2、 构造注入：IoC容器使用构造器来注入被依赖的实例。</p><p>一、设值注入</p><p>设值注入是指IoC容器使用属性的setter方法来注入被依赖的实例。这种注入方式比较简单、直观。</p><p>下面是Person接口，该接口定义了一个Person规范。</p><p>public interface Person {</p><p>//定义使用斧子的方法</p><p>public void useAxe();</p><p>}</p><p>Axe接口：</p><p>public interface Axe {</p><p>//Axe接口里面有个砍的方法</p><p>public String chop();</p><p>}</p><p>Person的实现类。</p><p>public class Chinese implements Person {</p><p>private Axe axe;</p><p>private String name;</p><p>// 设值注入所需的setter方法</p><p>public void setAxe(Axe axe) {</p><p>this.axe = axe;</p><p>}</p><p>public void setName(String name) {</p><p>this.name = name;</p><p>}</p><p>// 实现Person接口的userAxe方法</p><p>public void useAxe() {</p><p>// 调用axe的chop方法，表明Person对象依赖于Axe对象</p><p>System.out.println("我是"+name+"用"+axe.chop());</p><p>}</p><p>}</p><p>上面的代码实现了Person接口的userAxe()方法，实现该方法时调用了axe的的chop()方法，这就是典型的依赖关系。</p><p>在这里Spring容器的作用就是已松耦合的方式来管理这种调用关系。在上面的Chinese类中，Chinese类并不知道它要调用的axe实例在哪里，也不知道axe实例是如何实现的，它只是需要调用一个axe实例，这个Axe实例将由Spring容器负责注入。</p><p>Axe的实现类：StoneAxe类</p><p>public class StoneAxe implements Axe{</p><p>public String chop() {</p><p>return "石斧砍柴好慢啊!!!";</p><p>}</p><p>}</p><p>直到这里，程序依然不知道Chinese类和Axe实例耦合，Spring也不知道！实际上，Spring需要使用XML配置文件来指定实例之间的依赖关系。</p><p>Spring采用了XML文件作为配置文件。</p><p>对于本应用的XML配置文件如下：</p><p>&lt;?xml version="1.0" encoding="UTF-8"?></p><p>&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p><p>xmlns="http://www.springframework.org/schema/beans"</p><p>xsi:schemaLocation="http://www.springframework.org/schema/beans</p><p>http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"></p><p>&lt;!-- 配置Chinese实例，其实现类是Chinese --></p><p>&lt;bean id="chinese" class="com.spring.service.impl.Chinese"></p><p>&lt;!-- 将StoneAxe注入给axe属性 --></p><p>&lt;property name="axe" ref="stoneAxe" /></p><p>&lt;property name="name" value="孙悟空"/></p><p>&lt;/bean></p><p>&lt;!-- 配置stoneAxe实例 --></p><p>&lt;bean id="stoneAxe" class="com.spring.service.impl.StoneAxe" /></p><p>&lt;/beans></p><p>在配置文件中，Spring配置Bean实例通常会指定两个属性：</p><p>id：指定该Bean的唯一标识，程序会通过id属性值来访问该Bean实例。</p><p>class：指定该Bean的实现类，此处不可再用接口，必须是实现类，Spring容器会使用XML解析器读取该属性值，并利用反射来创建该实现类的实例。</p><p>从上面可以看出Bean于Bean之间的依赖关系放在配置文件里组织，而不是写在代码里。通过配置文件的指定，Spring能够精确地为每个Bean注入属性。因此，配置文件里的&lt;bean…/>元素的class属性值不能是接口，而必须是真正的实现类。</p><p>Spring会自动接管每个&lt;bean…/>定义里的&lt;property …/>元素定义，Spring会在调用无参数的构造器、创建默认的Bean实例后，调用相应的setter方法为程序注入属性值。&lt;property…/>定义的属性值将不再有该Bean来主动设置、管理，而是接受Spring的注入。</p><p>每个Bean的id属性是该Bean的唯一标识，程序通过id属性访问Bean，Bean与Bean的依赖关系也是通过id属性关联。</p><p>测试程序：</p><p>public class BeanTest {</p><p>public static void main(String[] args) {</p><p>//创建Spring容器</p><p>ApplicationContext ctx = new ClassPathXmlApplicationContext("bean.xml");</p><p>//获取Chinese实例</p><p>Person person = ctx.getBean("chinese",Person.class);</p><p>person.useAxe();</p><p>}</p><p>}</p><p>执行上面的程序，执行结果如下：</p><div class=pgc-img><img alt=干货｜Spring核心机制之依赖注入（建议收藏） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9bf27827351a4a31a43f34936dece6ee><p class=pgc-img-caption></p></div><p>主程序调用Person的userAxe()方法时，该方法的方法体内需要使用Axe实例，但程序没有任何地方将特定的Person实例和Axe实例耦合在一起，也就是说程序没有为Person实例传入Axe实例,Axe实例有Spring在运行期间注入。</p><p>Person实例不仅不需要了解Axe实例的具体实现，甚至无须了解Axe的创建过程。Spring容器根据配置文件的指定，创建Person实例时，不仅创建了Person的默认实例，同时也为该实例依赖注入其所依赖的Axe实例。</p><p>Bean与Bean之间的依赖关系有Spring管理，Spring采用setter方法为目标Be阿玛尼注入所依赖的Bean，这种方式被称之为设值注入。</p><p>从上面的实例我们可以看出，依赖注入以配置文件管理Bean实例之间的耦合，让Bean实例之间的耦合从代码层次分离出来。</p><p>Spring IoC容器有如下3个基本要点：</p><p>1、 应用程序的各个组件面向接口编程。面向接口编程可以将各个组件的耦合提升到接口层次，从而有利于项目后期的扩展。</p><p>2、 应用程序的各组件不再由程序主动产生，而是由Spring容器来负责产生，并初始化。</p><p>3、 Spring采用配置文件、或者Annotation来管理Bean的实现类、依赖关系，Spring容器则根据配置文件，利用反射机制来创建时间，并为之注入依赖关系。</p><p>二、构造注入</p><p>构造注入就是利用构造器来设置依赖关系的方式。</p><p>Japanese类：</p><p>public class Japanese implements Person{</p><p>private Axe axe;</p><p>//默认构造器</p><p>public Japanese(){</p><p>}</p><p>//构造注入所需的带参数构造器</p><p>public Japanese(Axe axe){</p><p>this.axe = axe;</p><p>}</p><p>public void useAxe() {</p><p>System.out.println(axe.chop());</p><p>}</p><p>上面的Chinese类并没有setter方法，仅仅只是提供了一个带Axe属性的构造器，Spring将通过该构造器为Chinese注入所依赖的Bean实例。</p><p>构造注入的配置文件需要做一些修改。为了使用构造注入，使用&lt;constructor-arg…/>元素来指定构造器的参数。如下</p><p>&lt;?xml version="1.0" encoding="UTF-8"?></p><p>&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</p><p>xmlns="http://www.springframework.org/schema/beans"</p><p>xsi:schemaLocation="http://www.springframework.org/schema/beans</p><p>http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"></p><p>&lt;!-- 配置Japanese实例 --></p><p>&lt;bean id="japanese" class="com.spring.service.impl.Japanese"></p><p>&lt;!-- 使用构造注入 ，为Japanese实例注入SteelAxe实例--></p><p>&lt;constructor-arg ref="stoneAxe"/></p><p>&lt;/bean></p><p>&lt;!-- 配置stoneAxe实例 --></p><p>&lt;bean id="stoneAxe" class="com.spring.service.impl.StoneAxe" /></p><p>&lt;/beans></p><p>上面的配置文件使用&lt;contructor-arg…/>元素指定了一个构造器参数，该参数类型是Axe，这指定Spring调用Chinese类里带一个Axe参数的构造器来创建chinese实例，因为使用了有参数的构造器创建实例，所以当Bean实例被创建完成后，该Bean的依赖关系也就已经设置完成。</p><p>他的执行效果与设值注入的执行效果一样。但是还是有点却别：创建Person实例中Axe的属性时机不同—设值注入式先通过无参数的构造器创建一个Bean实例，然后调用它的setter方法注入依赖关系，而构造注入则是直接调用有参数的构造器，当Bean实例创建完成后，依赖关系也已经完成。</p><p>三、两种注入方式的对比</p><p>Spring支持两种依赖注入方式，这两种依赖注入方式并没有好坏之分，只是适合的场景有所不同。</p><p>设值注入有如下优点：</p><p>1、 与传统的JavaBean的写法更相似，程序开发人员更加容易理解，接受。通过setter方法设定依赖关系显得更加直观、自然。</p><p>2、 对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因此导致性能下降。而设值注入，则可以避免这些问题。</p><p>3、 尤其是在某些属性可选的情况下，多参数的构造器更加笨重。</p><p>但是构造器也有如下优势：</p><p>1、 构造注入可以再构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</p><p>2、 对于依赖关系无须变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器中设定，因此，无须担心后续的代码对依赖关系产生破坏。</p><p>3、 依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更加符合高内聚的原则。</p><p>通过上面的对比。所以建议用以设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他的依赖关系，则考虑设值注入。</p><p>欢迎工作一到五年的Java工程师朋友们加入Java技术交流群：659270626</p><p>群内提供免费的Java架构学习资料（里面有高可用、高并发、高性能及分布式、Jvm性能调优、Spring源码，MyBatis，Netty,Redis,Kafka,Mysql,Zookeeper,Tomcat,Docker,Dubbo,Nginx等多个知识点的架构资料）合理利用自己每一分每一秒的时间来学习提升自己，不要再用"没有时间“来掩饰自己思想上的懒惰！趁年轻，使劲拼，给未来的自己一个交代！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'干货','Spring','机制'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>