<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>不怕面试被问了！二叉树算法大盘点 | 原力计划 | 极客快訊</title><meta property="og:title" content="不怕面试被问了！二叉树算法大盘点 | 原力计划 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d2fb2eaa.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d2fb2eaa.html><meta property="article:published_time" content="2020-11-14T21:06:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:34+08:00"><meta name=Keywords content><meta name=description content="不怕面试被问了！二叉树算法大盘点 | 原力计划"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d2fb2eaa.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>不怕面试被问了！二叉树算法大盘点 | 原力计划</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH><p>作者 | BoCong-Deng</p><p>责编 | 伍杏玲</p><p>头图 | CSDN 下载自视觉中国</p><p>出品 | CSDN博客</p><p>树结构对于程序员来说应该不陌生，特别是二叉树，基本只要接触算法这一类的都一定会碰到的，所以我打算通过一篇文章，对二叉树结构的相关算法进行总结汇总，思路和代码实现相结合，让你不在惧怕二叉树。（ps：后面我还想写一篇树结构的高级篇，就是多叉数，就是对我平时看算法论文碰到的一些新奇的算法，比如B树、B+树，还有我一种叫做Bed树的新奇算法等等）</p><p>单纯就是想分享技术博文，还想说一句就是，如果觉得有用，请点个关注、给个赞吧，也算对我来说是个宽慰，毕竟也得掉不少头发，嘿嘿嘿。</p><p>下面的思路讲解中，我会给出一个类伪代码的思路，然后进行相关说明，也就是一种思路框架，有了思路框架，以后碰到问题就直接交给框架完成。本文主要说一下二叉搜索树（Binary Search Tree，简称 BST），BST是一种很常用的的二叉树。它的定义是：一个二叉树中，任意节点的值要大于等于左子树所有节点的值，且要小于等于右边子树的所有节点的值。如下就是一个符合定义的 BST：</p><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RseEOHIsZ2XJl><p>后面如果遇到特殊的思路结构，如多叉树，我会特别说明。首先我们先给出二叉树的节点定义（这个定义应该不陌生吧，有刷算法题都会碰到）。</p><pre><p>public class TreeNode {</p><p>int val;</p><p>TreeNode left;</p><p>TreeNode right;</p><p>TreeNode(int x) { val = x; }</p><p>}</p></pre><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p><strong>递归</strong></p><p>不过这里要说明一点的是，在伪代码中的“进行想要的操作”的位置，不一定就在我放置的位置，具体位置还需要我们根据不同的实际需求进行判断。不过因为前中后序的遍历，递归进入的时机应该需要和我的一样。</p><p><strong>先序遍历</strong></p><p>遍历根节点，如果根节点为空，返回；否则，遍历根节点，然后先序遍历左子树，再先序遍历右子树。</p><pre>public void preorderTraverse(TreeNode root){<br><br>System.out.print(node.val+" ");<br><br>preorderTraverse(root.left);<br><br>preorderTraverse(root.right);<br><br>}<br></pre><p><strong>中序遍历</strong></p><p>路过根节点，如果根节点为空，返回；否则，中序遍历左子树，然后遍历根节点，再中序遍历右子树。</p><pre>public void inorderTraverse(TreeNode root){<br><br>inorderTraverse(root.left);<br><br>System.out.print(node.val+" ");<br><br>inorderTraverse(root.right);<br><br>}</pre><p><strong>后序遍历</strong></p><p>路过根节点，如果根节点为空，返回；否则，后序遍历左子树，再后序遍历右子树，最后遍历根节点。</p><pre>public void postorderTraverse(TreeNode root){<br><br>postorderTraverse(root.left);<br><br>postorderTraverse(root.right);<br><br>System.out.print(node.val+" ");<br><br>}<br></pre><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p><strong>迭代（非递归）</strong></p><p>我们使用迭代的思想，其实就是利用循环和栈来模拟递归的操作，上面递归的操作，其实就是一个不断将自己以及左右子节点进行压栈和出栈的过程，如果理解了上面的算法下面的算法就好理解了</p><p><strong>前序遍历</strong></p><pre>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {<br><br>List&lt;Integer&gt; list = new ArrayList&lt;&gt;;<br><br>if(root==){<br><br>return list;<br><br>}<br><br>Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;;<br><br>stack.push(root);<br><br>while(!stack.isEmpty){<br><br>TreeNode res = stack.pop;<br><br>if(res.right != )<br><br>stack.push(res.right);<br><br>if(res.left != )<br><br>stack.push(res.left);<br><br>list.add(res.val);<br><br><br><br>}<br><br>return list;<br><br>}</pre><p><strong>中序遍历</strong></p><pre>public List&lt;Integer&gt; inorderTraversal(TreeNode root) {<br><br>List&lt;Integer&gt; list = new ArrayList&lt;&gt;;<br><br>if(root==){<br><br>return list;<br><br>}<br><br>Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;;<br><br>TreeNode curr = root;<br><br>while(curr != || !(stack.isEmpty)){<br><br>if(curr!= ){<br><br>stack.push(curr);<br><br>curr = curr.left;<br><br>}else{<br><br>curr = stack.pop;<br><br>list.add(curr.val);<br><br>curr = curr.right;<br><br>}<br><br>}<br><br>return list;<br><br>}</pre><p><strong>后序遍历</strong></p><p>我们可以很简单的实现另一种遍历：”根->右->左“遍历。虽然这种遍历没有名字，但是他是后序遍历的反序。所以我们可以利用两个栈，利用栈的LIFO特点，来实现后续遍历。</p><pre>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {<br><br>List&lt;Integer&gt; list = new ArrayList&lt;&gt;;<br><br>if(root==){<br><br>return list;<br><br>}<br><br>Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;;<br><br>stack.push(root);<br><br>while(!stack.isEmpty){<br><br>TreeNode res = stack.pop;<br><br>if(res.left != )<br><br>stack.push(res.left);<br><br>if(res.right != )<br><br>stack.push(res.right);<br><br>list.add(res.val);<br><br><br><br>}<br><br>list.reserve;<br><br>return list;<br><br>}<br></pre><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p><strong>深度优先搜索（DFS）</strong></p><p>其实，二叉树的先序遍历，中序遍历，后序遍历，都是深度优先搜索，深搜是一种思想，并不具体指代实现方式，你可以使用递归，也可以使用栈来实现，所以上面提到的都是深度优先搜索的实现方式，毕竟“深度优先”嘛。</p><p>那在这里我就是提几个实际的应用的例子，加深一下印象。</p><p><strong>二叉树的最大深度</strong></p><pre>public int maxDepth(TreeNode root) {<br><br>if(root==){<br><br>return 0;<br><br>}<br><br>int left = maxDepth(root.left);<br><br>int right = maxDepth(root.right);<br><br>return Math.max(left,right)+1;<br><br>}</pre><p><strong>二叉树的镜像</strong></p><pre>public void Mirror(TreeNode root) {<br><br>if(root!=){<br><br>if(root.left!= || root.right!= ){<br><br>TreeNode temp =root.left;<br><br>root.left=root.right;<br><br>root.right=temp;<br><br>}<br><br>Mirror(root.left);<br><br>Mirror(root.right);<br><br>}<br><br>}</pre><p><strong>对称二叉树</strong></p><pre>boolean isSymmetrical(TreeNode pRoot){<br><br>if(pRoot == )<br><br>return true;<br><br>return real(pRoot.left,pRoot.right);<br><br>}<br><br>public boolean real(TreeNode root1,TreeNode root2){<br><br>if(root1 == &amp;&amp; root2 == ){<br><br>return true;<br><br>}<br><br>if(root1 == || root2 == ){<br><br>return false;<br><br>}<br><br>if(root1.val != root2.val){<br><br>return false;<br><br>}<br><br>return real(root1.left,root2.right)&amp;&amp;real(root1.right,root2.left);<br><br>}</pre><p><strong>路径总和</strong></p><pre>public class Solution {<br><br>private ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;;<br><br>private ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;;<br><br>public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) {<br><br>if(root == )<br><br>return listAll;<br><br>list.add(root.val);<br><br>target -= root.val;<br><br>if(target == 0 &amp;&amp; root.left== &amp;&amp; root.right == ){<br><br>listAll.add(new ArrayList&lt;Integer&gt;(list));<br><br>}<br><br>FindPath(root.left,target);<br><br>FindPath(root.right,target);<br><br>list.remove(list.size-1);<br><br>return listAll;<br><br>}<br><br>}</pre><p><strong>重建二叉树</strong></p><pre>public TreeNode reConstructBinaryTree(int [] pre,int [] in) {<br><br>return reConstructBinaryTree(pre,0,pre.length-1,in,0,in.length-1);<br><br>}<br><br>public TreeNode reConstructBinaryTree(int [] pre,int startpre,int endpre,int [] in,int startin,int endin){<br><br>if(startpre &gt; endpre || startin &gt; endin){<br><br>return ;<br><br>}<br><br>TreeNode root = new TreeNode(pre[startpre]);<br><br>for(int i =startin;i&lt;=endin;i++){<br><br>if(in[i] == pre[startpre]){<br><br>root.left = reConstructBinaryTree(pre,startpre+1,startpre+i-startin,in,startin,i-1);<br><br>root.right = reConstructBinaryTree(pre,startpre+i-startin+1,endpre,in,i+1,endin);<br><br>}<br><br>}<br><br>return root;<br><br>}</pre><p><strong>二叉搜索树的最近公共祖先</strong></p><pre>class Solution {<br><br>public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {<br><br>if(root == || root == p || root == q){<br><br>return root;<br><br>}<br><br>TreeNode left = lowestCommonAncestor(root.left,p,q);<br><br>TreeNode right = lowestCommonAncestor(root.right,p,q);<br><br>if(left!= &amp;&amp; right!=){<br><br>return root;<br><br>}<br><br>return left!=?left:right;<br><br>}<br><br>}</pre><p><strong>二叉树的序列化和反序列化</strong></p><pre>序列化：<br><br>public String serialize(TreeNode root) {<br><br>if (root == ) {<br><br>return ;<br><br>}<br><br>// 利用二叉树的层次遍历方式进行序列化<br><br>StringBuilder res = new StringBuilder;<br><br>LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;;<br><br>queue.add(root);<br><br>while (!queue.isEmpty) {<br><br>TreeNode node = queue.remove;<br><br>if (node != ) {<br><br>res.append(node.val).append(",");<br><br>queue.add(node.left);<br><br>queue.add(node.right);<br><br>} else {<br><br>res.append(",");<br><br>}<br><br>}<br><br>return res.toString;<br><br>}<br><br>反序列化：<br><br>public TreeNode deserialize(String data) {<br><br>if (data == || data.length == 0) {<br><br>return ;<br><br>}<br><br>String dataArr = data.split(",");<br><br>// 层次遍历逆向还原二叉树<br><br>int index = 0;<br><br>TreeNode root = toNode(dataArr[index]);<br><br>LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;;<br><br>queue.add(root);<br><br>while (index &lt; dataArr.length - 2 &amp;&amp; !queue.isEmpty) {<br><br>TreeNode cur = queue.remove;<br><br>// 添加左子节点<br><br>TreeNode leftNode = toNode(dataArr[++index]);<br><br>cur.left = leftNode;<br><br>// 队列中的节点用于为其赋值孩子节点，若该节点本身为 ，<br><br>// 没有孩子节点，便不再添加到队列中，下同理<br><br>if (leftNode != ) {<br><br>queue.add(leftNode);<br><br>}<br><br>// 添加右子节点<br><br>TreeNode rightNode = toNode(dataArr[++index]);<br><br>cur.right = rightNode;<br><br>if (rightNode != ) {<br><br>queue.add(rightNode);<br><br>}<br><br>}<br><br>return root;<br><br>}<br><br><br><br>private TreeNode toNode(String val) {<br><br>if (!"".equals(val)) {<br><br>return new TreeNode(Integer.parseInt(val));<br><br>} else {<br><br>return ;<br><br>}<br><br>}<br></pre><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7YR5xGDl><p><strong>广度优先搜索（BFS）</strong></p><ol><li><p>首先将根节点放入队列中。</p></li><li><p>从队列中取出第一个节点，并检验它是否为目标。</p></li><li><p>如果找到目标，则结束搜索并回传结果。</p></li><li><p>否则将它所有尚未检验过的直接子节点加入队列中。</p></li><li><p>若队列为空，表示整张图都检查过了——亦即图中没有欲搜索的目标。结束搜索并回传“找不到目标”。</p></li><li><p>重复步骤2。</p></li></ol><pre>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {<br><br>List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;;<br><br>List&lt;TreeNode&gt; quene = new ArrayList&lt;TreeNode&gt;;<br><br>if(root == ){<br><br>return res;<br><br>}<br><br>quene.add(root);<br><br>while(quene.size!=0){<br><br>int count = quene.size;<br><br>List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;;<br><br>while(count&gt;0){<br><br>TreeNode temp =quene.remove(0);<br><br>list.add(temp.val);<br><br>if(temp.left!=){<br><br>quene.add(temp.left);<br><br>}<br><br>if(temp.right!=){<br><br>quene.add(temp.right);<br><br>}<br><br>count--;<br><br>}<br><br>res.add(list);<br><br>}<br><br>return res;<br><br>}<br></pre><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7uHXU5GZc><p><strong>莫里斯遍历（Morris）</strong></p><p>通常我们对于二叉树进行遍历时，使用递归遍历或是基于栈来遍历，这两种方法都拥有最差为O(n)的空间复杂度(递归方法会在递归调用上浪费更多的时间)，以及O(n)的时间复杂度。对于时间复杂度来说，由于需要遍历每个元素一次，所以O(n)已是最优情况。如此只能对空间进行优化。Morris遍历如何做到的呢？首先我们需要分析递归和基于栈的遍历它们为什么有O(n)的空间占用。以下图这个简单的二叉树遍历为例：</p><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/RseEOx9ABsW9ym><p>例如进行中序遍历(LDR)，从1开始：</p><ul><li><p>1有左孩子2，将1放入栈中，移动到节点2；</p></li><li><p>2有左孩子4，将2放入栈中，移动到节点4；</p></li><li><p>4左孩子为空，输出节点4，此时节点4右孩子也为空，弹栈回到节点2；</p></li><li><p>输出节点2，节点2有右孩子5，移动到节点5；</p></li><li><p>5左孩子为空，输出节点5，此时节点5右孩子也为空，弹栈回到节点1；</p></li></ul><p>…</p><p>从上面分析可以得知，传统遍历利用空间存储未实现全部操作的父节点，比如对于1节点，一开始进行L操作，没有进行D、R操作所以需要存储起来。为解决这一问题，Morris算法用到了”线索二叉树”的概念，利用叶节点的左右空指针指向某种遍历顺序的前驱节点或后继节点。Morris算法中序遍历流程：</p><ul><li><p>设置节点1为Current节点；</p></li><li><p>Current节点不为空，且有左孩子，于是找到节点1左子树中的最右侧节点，即节点5，使其右孩子指针指向自己，即link1；</p></li><li><p>Current节点移动到左孩子节点2，并删除父节点的左指针，使其指向为，即删除erase1；</p></li><li><p>节点2不为空，且有左孩子，于是找到节点2左子树中最右侧节点，即节点4，使其右孩子指针指向自己，即link2；</p></li><li><p>Current节点移动到左孩子节点4，并删除父节点的左指针，使其指向为，即删除erase2；</p></li><li><p>节点4左孩子为空，输出节点4，移动到右孩子节点2；</p></li><li><p>节点2无左孩子(指针指向)，输出节点2，移动到右孩子节点5；</p></li><li><p>节点5无左孩子，输出节点5，移动到右孩子节点1；</p></li><li><p>节点2无左孩子(指针指向)，输出节点1，移动到右孩子节点3；</p></li><li><p>…</p></li></ul><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RseEOxZUcKDgO><p>代码实现：</p><pre>void Morris_inorderTraversal(TreeNode root) {<br><br>TreeNode curr = root;<br><br>TreeNode pre;<br><br>while (curr != ) {<br><br>if (curr.left == ) { // 左孩子为空<br><br>System.out.print(curr.val+" ");<br><br>curr = curr.right;<br><br>}<br><br>else { // 左孩子不为空<br><br>// 找左子树中的最右节点<br><br>pre = curr.left;<br><br>while (pre.right != ) {<br><br>pre = pre.right;<br><br>}<br><br>// 删除左孩子，防止循环<br><br>pre.right = curr;<br><br>TreeNode temp = curr;<br><br>curr = curr.left;<br><br>temp.left = ;<br><br>}<br><br>}<br><br>}<br></pre><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTLSNam5ZxLDlM><p><strong>AVL树</strong></p><p>AVL 树是一种平衡二叉树，平衡二叉树递归定义如下：</p><ul><li><p>左右子树的高度差小于等于 1。</p></li><li><p>其每一个子树均为平衡二叉树。</p></li></ul><p>为了保证二叉树的平衡， AVL 树引入了所谓监督机制，就是在树的某一部分的不平衡度超过一个阈值后触发相应的平衡操作。保证树的平衡度在可以接受的范围内。既然引入了监督机制，我们必然需要一个监督指标，以此来判断是否需要进行平衡操作。这个监督指标被称为“平衡因子（Balance Factor）”。定义如下：</p><ul><li><p>平衡因子：某个结点的左子树的高度减去右子树的高度得到的差值。</p></li></ul><p>基于平衡因子，我们就可以这样定义 AVL 树。</p><ul><li><p>AVL 树：所有结点的平衡因子的绝对值都不超过 1 的二叉树。</p></li></ul><p>为了计算平衡因子，我们自然需要在节点中引入高度这一属性。在这里，我们把节点的高度定义为其左右子树的高度的最大值。因此，引入了高度属性的 AVL 树的节点定义如下：</p><pre>public class TreeNode {<br><br>int val;<br><br>int height;<br><br>TreeNode left;<br><br>TreeNode right;<br><br>TreeNode(int x) { val = x; }<br><br>}</pre><p>这里的节点和上面的不同的地方在于，我们多加了一个高度，用来记录每个节点的高度，如何得到每个节点的高度很简单，前面讲的算法中任何一种思路都可以实现，我这里就不赘述了，不过这里要多说一点的是，与之对应地，我们在进行如下操作时需要更新受影响的所有节点的高度：</p><ul><li><p>在插入结点时， 沿插入的路径更新结点的高度值</p></li><li><p>在删除结点时（delete），沿删除的路径更新结点的高度值</p></li></ul><p>我们重新定义了节点之后，有了高度属性，计算平衡因子的操作就得以很简单的实现，也就是某个节点的平衡因子=左节点高度-右节点高度。</p><p>当平衡因子的绝对值大于 1 时，就会触发树的修正，或者说是再平衡操作。</p><p><strong>树的平衡化操作</strong></p><p>二叉树的平衡化有两大基础操作：左旋和右旋。左旋，即是逆时针旋转；右旋，即是顺时针旋转。这种旋转在整个平衡化过程中可能进行一次或多次，这两种操作都是从失去平衡的最小子树根结点开始的(即离插入结点最近且平衡因子超过1的祖结点)。其中，右旋操作示意图如下</p><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RseEPH38FLy1Rw><p>所谓右旋操作，就是把上图中的 B 节点和 C 节点进行所谓“父子交换”。在仅有这三个节点时候，是十分简单的。但是当 B 节点处存在右孩子时，事情就变得有点复杂了。我们通常的操作是：抛弃右孩子，将之和旋转后的节点 C 相连，成为节点 C 的左孩子。这样，对应的代码如下。</p><pre>TreeNode treeRotateRight(TreeNode root) {<br><br>TreeNode left = root.left;<br><br><br><br>root.left = left.right; // 将将要被抛弃的节点连接为旋转后的 root 的左孩子<br><br>left.right = root; // 调换父子关系<br><br><br><br>left.height = Math.max(treeHeight(left.left), treeHeight(left.right))+1;<br><br>right.height = Math.max(treeHeight(right.left), treeHeight(right.right))+1;<br><br><br><br>return left;<br><br>}</pre><p>而左旋操作示意图如下</p><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RseEPHb3bx6HZ8><p>左旋操作和右旋操作十分类似，唯一不同的就是需要将左右互换下。我们可以认为这两种操作是对称的。代码如下：</p><pre>TreeNode treeRotateLeft(TreeNode root) {<br><br>TreeNode right = root.ight;<br><br><br><br>root.right = right.left;<br><br>right.left = root;<br><br><br><br>left.height = Math.max(treeHeight(left.left), treeHeight(left.right))+1;<br><br>right-&gt;height = Math.max(treeHeight(right.left), treeHeight(right.right))+1;<br><br><br><br>return right;<br><br>}</pre><p><strong>需要平衡的四种情况</strong></p><ul><li><p><strong>LL 型</strong></p></li></ul><p>所谓 LL 型就是上图左边那种情况，即因为在根节点的左孩子的左子树添加了新节点，导致根节点的平衡因子变为 +2，二叉树失去平衡。对于这种情况，对节点 n 右旋一次即可。</p><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RseEPIA5r3qF3u><ul><li><p><strong>RR 型</strong></p></li></ul><p>RR 型的情况和 LL 型完全对称。只需要对节点 n 进行一次左旋即可修正。</p><ul><li><p><strong>LR 型</strong></p></li></ul><img alt="不怕面试被问了！二叉树算法大盘点 | 原力计划" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RseEPITCAxgkUf><p>LR 就是将新的节点插入到了 n 的左孩子的右子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次左旋再对 n 进行一次右旋。</p><ul><li><p><strong>RL 型</strong></p></li></ul><p>RL 就是将新的节点插入到了 n 的右孩子的左子树上导致的不平衡的情况。这时我们需要的是先对 i 进行一次右旋再对 n 进行一次左旋。</p><p>这四种情况的判断很简单。我们根据破坏树的平衡性（平衡因子的绝对值大于 1）的节点以及其子节点的平衡因子来判断平衡化类型。</p><p>平衡化操作的实现如下：</p><pre>int treeGetBalanceFactor(TreeNode root) {<br><br>if(root == )<br><br>return 0;<br><br>else<br><br>return x.left.height - x.right.height;<br><br>}<br><br><br><br>TreeNode treeRebalance(TreeNode root) {<br><br>int factor = treeGetBalanceFactor(root);<br><br>if(factor &gt; 1 &amp;&amp; treeGetBalanceFactor(root.left) &gt; 0) // LL<br><br>return treeRotateRight(root);<br><br>else if(factor &gt; 1 &amp;&amp; treeGetBalanceFactor(root.left) &lt;= 0) { //LR<br><br>root.left = treeRotateLeft(root.left);<br><br>return treeRotateRight(temp);<br><br>} else if(factor &lt; -1 &amp;&amp; treeGetBalanceFactor(root.right) &lt;= 0) // RR<br><br>return treeRotateLeft(root);<br><br>else if((factor &lt; -1 &amp;&amp; treeGetBalanceFactor(root.right) &gt; 0) { // RL<br><br>root.right = treeRotateRight(root.right);<br><br>return treeRotateLeft(root);<br><br>} else { // Nothing happened.<br><br>return root;<br><br>}<br><br>}</pre><p>这里推荐一个AVL树动态化的网站，可以通过动态可视化的方式理解AVL：</p><p>https://www.cs.usfca.edu/~galles/visualization/AVLtree.html</p><p>原文链接：https://blog.csdn.net/DBC_121/article/details/104584060</p><p>声明：本文系CSDN博主原创文章，版权归作者所有。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','问了','大盘点'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>