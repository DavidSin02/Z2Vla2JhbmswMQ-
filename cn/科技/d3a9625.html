<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>vlan详解之二层三层转发原理 | 极客快訊</title><meta property="og:title" content="vlan详解之二层三层转发原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/2d71c8de68654968976708295c4191da"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d3a9625.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d3a9625.html><meta property="article:published_time" content="2020-10-29T21:05:40+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:40+08:00"><meta name=Keywords content><meta name=description content="vlan详解之二层三层转发原理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d3a9625.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>vlan详解之二层三层转发原理</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>前言</strong></h1><p style=text-align:start>曾经开发了二层交换机，对交换芯片的vlan处理比较熟悉，对vlan的原理自认为也是理解深刻；但是当进行到防火墙时，突然发现又不理解vlan了！</p><p style=text-align:start>于是开始重新学习linux的vlan和桥接，更是发现不了解其含义和实现了；于是有了下面的学习结果。</p><p style=text-align:start>关于一些基本的概念（如广播域 冲突域 vlan）就不做说明了。</p><p style=text-align:start>以下内容摘抄自网上资料，出处用参考标记出来，方便大家参考，网上内容相对零散，为了方便由浅入深的方便理解，根据我自己学习过程，做了梳理。</p><h1 class=pgc-h-arrow-right><strong>第一回 基于vlan的二层交换转发原理</strong></h1><p>参考： https://www.jianshu.com/p/c930913948a8</p><h1 class=pgc-h-arrow-right><strong>普通转发流程</strong></h1><p>交换机的二层转发涉及到两个关键的线程：MAC地址学习流程和报文转发流程。</p><p><strong>MAC地址学习流程</strong>：</p><ol start=1><li><strong>MAC的学习：</strong>交换机接收网段上的所有数据帧，利用接收数据帧中的源MAC地址来建立MAC地址表；</li><li><strong>MAC的漂移：</strong>交换机如果发现一个包文的入端口和报文中源MAC地址的所在端口不同，就产生端口移动，将MAC地址重新学习到新的端口；</li><li><strong>MAC的老化：</strong> 如果交换机在很长一段时间之内没有收到某台主机发出的报文，在该主机对应的MAC地址就会被删除，等下次报文来的时候会重新学习。</li></ol><p><strong>二层报文转发流程:</strong></p><ol start=1><li><strong>已知单播-转发：</strong>交换机在MAC地址表中查找数据帧中的目的MAC地址，如果找到，就将该数据帧发送到相应的端口</li><li><strong>未知单播-泛洪：</strong>如果找不到，就向入端口以外的其它所有端口发送；</li><li><strong>同端口-不转发：</strong>如果交换机收到的报文中源MAC地址和目的MAC地址所在的端口相同，则丢弃该报文；</li><li><strong>组播和广播-泛洪：</strong>交换机向入端口以外的其它所有端口转发广播报文。</li></ol><p>上面流程是简单的桥交换流程，增加了VLAN以后，所有流量都在VLAN内部交换。目前的二层交换芯片都支持vlan，如果想对二层转发有更深入了解，当然是阅读某些二层交换芯片的手册。</p><p>参考：https://blog.csdn.net/weixin_42096901/article/details/104802047</p><h1 class=pgc-h-arrow-right><strong>基于vlan转发流程</strong></h1><p>基于Vlan的二层转发流程主要包括：确定和查找Vlan、查找和学习源MAC、查找目的MAC并转发数据帧。</p><p><strong>1) 确定和查找Vlan</strong>：交换机端口接收到一个数据帧时，首先通过TPID值判断该帧是否带标签。</p><p>若是tagged帧，且Vid≠0，则在端口所属的Vlan表中查找该帧标签中的Vid是否存在，若存在，则进入下一步，否则丢弃该帧(或提交CPU处理);</p><p>若是tagged帧，且Vid=0(即priority帧)，则对该帧附加端口PVid（默认vlan）使之成为tagged帧;</p><p>若是untagged帧，则对该帧附加端口PVid并指定优先级使之成为tagged帧。</p><p>注：</p><p>①为提高处理效率，交换机内部所有数据帧均携带Vlan标签，以统一方式处理。故需对输入交换机的数据帧进行标签检查并按需加上标签。</p><p>②802.1Q Vlan环境下，帧可分为tagged、untagged和priority-tagged三种。Tagged帧根据其携带的标签Vid进行MAC学习转发。Untagged和Priority-tagged帧进入交换机端口后根据PVid进行MAC学习转发。</p><p><strong>2) 查找和学习源MAC</strong>：交换机在MAC转发表(Mac+Vid+Port)中查找收帧Vid对应的源MAC表项，未找到则学习收帧源MAC (将“源MAC+Vid+Port”添加到MAC表中); 若找到则更新该表项的老化时间。</p><p>注：MAC地址学习只学习单播地址，对于广播和组播地址不进行学习。组播MAC表项通过CPU配置建立。</p><p><strong>3) 查找目的MAC</strong>：若目的MAC是广播或组播，则在所属的Vlan中广播或组播;否则在MAC表中查找是否存在Vid对应的目的MAC表项。</p><p><strong>4) 转发数据帧</strong>：若在MAC表中查找到完全匹配的DMAC+Vid表项，则将该帧转发到表项中的相应端口(若相应端口为收帧端口，则应丢弃该帧);否则向所属Vlan内除收包端口外的其他所有端口洪泛该帧(洪泛广播的是未知单播帧而不是广播帧)。</p><p><br></p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2d71c8de68654968976708295c4191da><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>二层交换机转发流程实例</strong></h1><p>数据帧从PC1经过一台交换机转发到与另一台交换机相连的PC2并得到响应，如下图所示。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ea78d2bea36644cdb878fcb833be9e81><p class=pgc-img-caption></p></div><p>PC1向PC2发送信息</p><p>假设两台交换机刚刚开机(此时MAC地址表为空)，其具体的转发过程如下：</p><p>①PC1发出的数据帧进入交换机SW1的Access端口后，按照端口PVid加上Vid=100的标签。交换机将该帧源MAC地址存入MAC地址表(学习)，并将该帧洪泛到Vid=100的所有端口(除入端口外);</p><p>②SW1的Trunk端口属于Vid=100的Vlan，故接受这个标记为100的Tagged数据帧;而该端口在Vid=100上为Tagged port，因此在发送数据帧出交换机SW1时，不改变Tagged帧的结构;</p><p>③Tagged帧到达交换机SW2的Trunk端口，由于Trunk端口拥有VID=100的Vlan，故接受该帧;该Trunk端口不改变Tagged帧的结构，而是学习源MAC地址后把该数据帧洪泛给所有Vid=100的端口(除入端口外);</p><p>④SW2的Access端口接收到该帧，剥除该帧的Tag标签后发送给PC2。</p><p>⑤PC2收到PC1发送的数据帧，并发送响应帧给PC1。</p><p>⑥经过与前述过程类似的转发，响应帧到达交换机SW1。交换机发现该帧的目的MAC地址已在MAC地址表中，则仅转发给PC1。</p><p>可见，收发双方同属一个Vlan的通信，一切处理均在二层网络内完成。</p><h1 class=pgc-h-arrow-right><strong>第二回 vlan技术续</strong></h1><p>参考： https://blog.csdn.net/z429831417/article/details/50498072</p><h1 class=pgc-h-arrow-right><strong>vlan技术及产生背景</strong></h1><p>在交换式以太网出现后，同一交换机的所有端口处于不同的冲突域，工作效率得到了很大的提高，但是所有端口处于同一广播域，导致一台计算机发出广播帧，局域网中所有的计算机都能够接受到，使局域网中有限的网络资源被无用的广播信息所占用。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75798f9f43ea49d9b0887038f574f66f><p class=pgc-img-caption></p></div><p>在如上图中的网络拓扑，PCA发出一个广播帧，二层交换机所有的端口处于同一广播域，那么交换机会把该数据帧从除收到该数据帧的端口以外的所有端口都进行发送，导致全网充斥这广播报文，如果一台计算机发出的广播报文是100Kbps，那么10台将会达到1000Kbps，那么100台1000台呢？是不是导致无用信息大量的占用着网络资源，严重的时候可能会导致交换机死机，从而影响该局域网的通信，所以如何限制广播域的传播范围成了一个急需解决的问题。</p><p>以太网处于TCP/IP协议栈的第二层，二层上的本地广播帧是不能被三层设备路由器转发的，使用路由器可以解决广播帧的传播范围，但是路由器也存在着弊端，一个是路由器的价格比交换机的价格昂贵，是种不经济的解决方案；二个路由器的端口较少，一个局域网一个端口，如果需要隔离的局域网较多，那么路由器会应付不过来；三个是在大部分中低端路由器上使用软件转发，转发性能并不高，容易造成性能瓶颈，所以用路由来隔离广播是个高成本低性能的方案。</p><p>后来IEEE协会专门制定了一个<strong>802.1Q的协议标准</strong>，这就是VLAN技术，VLAN就是在一物理LAN内划分出多个虚拟LAN的，每个VLAN是一个广播域，这就缩小了广播域的范围，各个VLAN之间不能直接通信</p><p>我们现在来说一下VLAN有哪一些优点，</p><p>一是可以有效的控制广播域的范围，前面说了每个VLAN是一个广播域，VLAN之间隔离广播域；</p><p>二是VLAN 不受物理位置的闲置，可以灵活的构建工作组；</p><p>三是各个VLAN之间不能直接进行通信，增强了局域网的安全性；</p><p>四是增强了网络的健壮性，各个VLAN是独立了，一个VLAN出了问题不会影响其他的VLAN，缩小了故障范围</p><p>VLAN的作用是用来隔离广播域，那我们在实际的操作中是如何来划分VLAN呢？</p><p>下面我们就逐一来讲四个基本的VLAN 划分方法；</p><p>第一个是利用端口来划分VLAN，这个是我们现在最常用的VLAN 划分方法，该方法就是把交换机的各个端口按照需要划分到不同VLAN 里面去，这是最简单也是最有效的划分方法；二层交换机基本是使用改方法；</p><p>第二个是利用MAC地址来划分VLAN，该方法就是利用主机的MAC地址建立一个与VLAN的映射关系，形成一个映射表，这种方法的优点就是当用户的物理位置移动时，其所处的VLAN 不会发生变化，灵活性比较高，但是前期的工作量非常大，技术人员得一一去收集MAC地址，然后建立一个映射关系；这种方法在现在的网络环境里，好像不会见到了。</p><p>第三个是利用协议来划分VLAN，不同的协议处于不同的VLAN，比如IP协议映射到vlan1，ipx协议映射到vlan2，交换机通过识别协议标签来自动划分到不同的VLAN，但是在现在的网络环境中用的最多的还是IP协议，运行其他协议已经非常少了；所以这种方法，在现在网络环境里应该不会见到了。</p><p>第四个方法就是基于子网划分，基于子网划分的就是利用报文中源IP地址以及子网掩码作为划分依据，交换机根据收到的报文中的源IP地址找到交换机已经存在的对应关系，然后自动转发到对应的的VLAN中，这种方法的划分方式比较灵活，用户移动位置也不需要重新配置，但是这种方法也不是很完美，因为为了判断用户的属性，必须逐一检查数据包网络层的地址，这建耗费交换机不少资源；综合以上几种划分方法的优缺点来看，基于端口划分是普遍的也是目前所有交换机都支持的VLAN 划分方法。</p><h1 class=pgc-h-arrow-right><strong>vlan转发技术原理</strong></h1><p>我们现在来看一下VLAN的转发技术原理，在以太网交换机中是根据目的MAC地址来查MAC地址表进行数据帧的转发，MAC地址表中包含了MAC地址与端口的一个对应的关系，当交换机收到一个数据帧的时候，交换机会查看该数据帧中的目的MAC地址，如果是一个单播帧，交换机会查表从对应的端口转发出去，如果是广播地址，那么交换机会从除收到该广播帧的以外的所有端口发送出去；但是在VLAN 技术中，交换机在数据帧中加上一个标签，然后交换机在查表的过程之外还要检查端口上的标签是否匹配，交换机只会在属于这个标签的端口上进行转发，如果不是就不进行转发操作</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d8c82b3d85ea4e01bf202eee844dd135><p class=pgc-img-caption></p></div><p>上图就是一个带IEEE802.1Q标记的以太网帧格式，我们现在重点来看中间的tag字段，tag字段总共占四个字节，其中TPID（标签协议标识）和TCI（标签控制信息）各占两个字节；TPID是什么？TPID是IEEE定义的新的类型，标识这是一个封装了802.1Q标签的帧，其中就包含了一个固定的值0x8100。后面的TCI又包含了三个字段。分别是priority（优先级）、CFI、VLAN ID；priority占3位，指定帧的优先级，一共有8种优先级，从0-7；CFI占1为，当这个值为0时说明这是一个规范格式，为1时是非规范格式，它在令牌环网、FDDI网络中来指示封装帧中所带的地址的比特次序；VLAN ID字段占12位，指明该数据帧所在的vlan编号，VLAN的编号共4096个，但是0和4096两个值保留，所以可用的也就4094个，其中的vlan 1是交换机的默认vlan</p><p>我们看完了802.1Q的帧格式，现在再来看看vlan的标签是怎么打上去的。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f702adf1a9174c97840a8b100176eccb><p class=pgc-img-caption></p></div><p>当PCA发送一个数据帧到交换机时，这个时候是不带标签的，当这个数据帧到达交换机的端口时，交换机给这个数据帧打上一个<strong>默认的标签（默认vid）</strong>，等这个数据帧要离开这台交换机的时候，交换机又会把这个标签去掉，这就是一个单标签的操作过程，在整个数据转发的过程中对终端主机来说是透明的，交换机如何进行vlan划分主机是不知道的，也不需要主机去了解，所有的打标签和去标签都交由交换机处理，这就是单标签的一个操作过程</p><p>看完标签操作过程后我们来了解下三种链路类型，分别是<strong>access、trunk、hybrid</strong></p><p><strong>Access</strong>一般是用在连接用户设备的那一端，<u>只允许缺省vlan通过</u>，仅接收和发送一个vlan的数据帧，这也就是我们前面所说的单标签交换过程；看上图，PCA发送一个数据帧个PCC，交换机收到该数据的时候把这个数据帧打上vlan 10的标签，然后进行查表操作，把数据帧发送到与PCC连接的端口的时候就会把这个VLAN 10的标签去掉。</p><p>访问链接（Access Link，或者Access类型端口），指的是“只属于一个VLAN，且仅向该VLAN转发数据帧”的端口。在大多数情况下，访问链接所连的是客户机。</p><p><u>在access链路类型中是不是一次只能允许一个vlan通过？</u>那我如果一次要允许多个vlan通过，那么这个access链路类型是不是就行不通了？这也就有了我们第二个链路类型，trunk链路类型</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a8321bd1d96643918d4d8fe095bb6f97><p class=pgc-img-caption></p></div><p><strong>Trunk</strong>，汇聚链接（Trunk Link），指的是能够转发多个不同VLAN的通信的端口；汇聚链路上流通的数据帧，都被附加了用于识别分属于哪个VLAN的标签。</p><p>看上图，两台交换机中间只有一条链路，但是两个交换机之间要同时传递vlan10和vlan20两个标签，我们现在用前面的access肯定不行了吧，这个时候我们用trunk来看是怎么操作的，PCA发送一个数据帧给SWA，SWA收到后打上10的标签，然后查表通过E1/0/24端口发送SWB，在发送给SWB的时候不做任何操作，原封不动的传给SWB，SWB收到后再进行查表，然后发送到vlan10对应的端口E1/0/1进行去标签的操作，最后把去掉标签的数据帧发送给PCC，PCB和PCD进行通信也进行相同的操作，不过<u>默认帧是个例外</u>，<strong>发送默认帧时</strong>，trunk会去掉默认vlan的标签；同样，交换机从trunk收到不带标签的帧时会打上默认vlan标签；我们除了学完access链路类型和trunk类型以外，还有第三种链路类型hybrid，</p><p><strong>Hybrid</strong>，混合链路（Hybrid Link）这是华三的一个私有的链路类型，hybrid端口可以接收和发送多个VLAN的数据帧，同时还能对任何vlan帧进行去标签的操作</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8aaef86c80c3468e946019399a0ae22c><p class=pgc-img-caption></p></div><p>看上图，PCA发送一个数据帧给PCC，当交换机收到PCA发来的数据帧时会打上10的标签，然后交换机进行查表操作，发送到PCC的端口，交换机进行去标签的操作的时候会检查untag，在untag表项中可以去掉带标签10、20、30的数据帧，所以很方便的就去掉了数据帧；这时PCA又发送一个数据帧给PCB；当交换机收到PCA发来的数据帧时会打上10的标签，然后交换机进行查表操作，然后发送到PCB的端口，交换机进行去标签的操作的时候会检查untag，但是此时untag表项中只有20和30，也就意味着该端口只能去掉带标签20和30的数据帧，这是交换机无法去掉标签，所以只能把该数据帧丢弃</p><p>通过本回的学习我们知道了vlan的作用就是在局域网中限制广播的传送范围，以及如何划分vlan，我们可以基于端口、子网、协议、MAC四种vlan划分方法来划分vlan，还有access、trunk、hybrid三种链路类型的应用场景，以及它们是怎么对标签操作的，access是进口打标出口解标；trunk可以同时允许多个VLAN帧通过，不对标签做任何操作，但是发送带默认标签的数据帧时会解标，收到不带标签的数据帧会打上默认标签；hybrid可以同时接收和发送多个VLAN的数据帧，同时还能对任何vlan帧进行去标签的操作</p><p>参考：https://www.cnblogs.com/xieyunc/p/9784041.html</p><p>注意，Access、Trunk和Hybrid端口是厂家对某种端口的称谓，并非IEEE802.1Q协议标准定义。</p><p>Access端口只属于一个Vlan，PVid就是其所在Vlan，故不用设置;Trunk和Hybrid端口属于多个Vlan，故需要设置PVid(缺省为1)。若设置端口PVid，则当端口收到不带Vlan Tag的数据帧时，对该帧加上Tag标记(Vid设置为端口所属的默认Vlan编号)并转发到属于PVid的端口;当端口发送Vlan Tag的数据帧时，若收帧的Vlan Tag和端口PVid相同，剥除Vlan Tag后再发送该帧。</p><p>Hybrid端口与Trunk端口在接收数据时处理方法相同，区别在于发送数据时：Hybrid端口允许多个Vlan的数据帧发送时不带标签，而Trunk端口只允许默认Vlan的数据帧发送时不带标签。在同一交换机上Hybrid端口和Trunk端口不能并存，实际使用中可用Hybrid代替Trunk。</p><p>本Hybrid端口的PVid和相连的对端交换机Hybrid端口的PVid必须一致。</p><p>由于端口类型不同，交换机对帧的处理过程也不同。下表根据不同的端口类型分别介绍。</p><p>表2 不同端口类型的Vlan帧处理方式</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/56e829c6d5bc4d3d97559909122f86b9><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>第三回 vlan间路由和三层交换转发原理</strong></h1><h1 class=pgc-h-arrow-right><strong>简单的vlan间路由流程</strong></h1><p><br></p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/38a2e20b883c4154a53ebe5ac6d41164><p class=pgc-img-caption></p></div><p><br></p><p>每一个VLAN有一个端口连接到路由器，所有终端以该路由器为默认网关。并由该路由器完成VLAN间报文的转发过程。比如10.1.1.1要与11.1.1.1终端通讯。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/78610ccc88f94e48b4c1d49ceca590d1><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>单臂路由工作原理</strong></h1><p>从上面我们看到，如果要通过路由器转发三层流量，在交换机和路由器之间，每一个VLAN需要有一个链路连接，当VLAN很多的时候，这将耗费大量的路由器接口，而路由器接口成本是非常高的。为了节约路由器接口，一个解决方案是路由器支持VLAN子接口。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1c39dae99ca54e96a6b017fafe922f1f><p class=pgc-img-caption></p></div><p><br></p><pre><code>VLAN子接口（这里的vlan子接口，后面linux的vlan实现中也会见到）1. 所谓子接口，就是是通过协议和技术将一个物理接口（interface）虚拟出来的多个逻辑接口。2. VLAN子接口，就是通过VLAN技术，将一个物理接口，虚拟出多个逻辑接口，   VLAN子接口上发送的报文，会打上Vlan-tag，用于区分不同的VLAN链路。</code></pre><p>通过配置路由器上的VLAN子接口，路由器和交换机物理上只需要一个端口连接，通过报文上的VLAN-tag区分不同的逻辑链路。这样节省了大量的端口资源。</p><p>参考：https://blog.csdn.net/weixin_42096901/article/details/104802047</p><p>将用于连接路由器的交换机端口设为Trunk汇聚端口，而路由器上的端口也必须支持汇聚链路。双方用于汇聚链路的协议也必须相同。接着在路由器上定义对应各Vlan的“子接口(Sub Interface)”。尽管实际与交换机连接的物理端口只有一个，但在理论上可将其分割为多个虚拟端口。如下图所示。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/343f473101e741409850577fd459178a><p class=pgc-img-caption></p></div><p>使用这种Vlan Trunking技术，可使多个Vlan的业务流共享相同的物理连接，通过在汇聚链路上传递带标签的帧来区分各Vlan的流量。通常情况下，Vlan间路由的流量不足以达到链路的线速度，使用Vlan Trunking的配置，可提高链路的带宽利用率，节省端口资源以及简化管理(网络新增Vlan时只需在路由器上新设一个对应新Vlan的子接口，无需重新布线)</p><p>【例】不同Vlan间通信时数据的流程，如下图所示。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49079ee3c00f411588a0caf5ab8c5f1a><p class=pgc-img-caption></p></div><p><strong>不同Vlan间通信流程</strong></p><p>主机PC1通过通信目标IP地址(192.168.2.1) 与子网掩码计算比较发现PC2与本机不属于同一网段，不能直接访问。根据IP通信规则，PC1查找本机路由表寻找相应的网关。在实际网络中，主机通常只配置默认网关(Default Gateway，GW)，故PC1找到默认网关。然后，PC1在本机ARP高速缓存中查找默认网关(即路由器)的MAC地址，若没有则向外广播发送一个ARP请求帧，其目的MAC地址为全1，源MAC地址为本机MAC地址，请求的IP地址为网关192.168.1.100。从路由器返回的ARP单播应答帧中得到路由器MAC地址R后，接下来就按图中所示的步骤向PC2发送数据帧①，其目的MAC地址是路由器地址R、但目的IP地址仍是最终要通信的对象PC2的地址。</p><p>交换机在端口1上收到数据帧①后，检索MAC地址表中与端口1同属一个Vlan的表项。汇聚链路被视为属于所有的Vlan，因此端口6也属于检索对象。检索后交换机得知往MAC地址R发送数据帧时，需经过端口6转发。</p><p><em>从汇聚端口6发送数据帧时，会附加Vlan识别信息。图中数据帧②被加上原属的红色Vlan标签后，进入汇聚链路。路由器收到数据帧②后，确认其Vlan标签，交由负责红色Vlan的子接口接收。</em></p><p>接着，根据路由器内部的路由表，判断该向哪里转发。由于目标网络192.168.2.0/24属于蓝色Vlan，且该网络通过子接口与路由器直连，因此只需从负责蓝色Vlan的子接口转发即可。此时数据帧的目的MAC地址被改成PC2的MAC地址;由于需要经过汇聚链路转发，故附加属于蓝色Vlan的识别信息(数据帧③)。</p><p>交换机收到数据帧③后，根据Vlan标签从MAC地址表中检索属于蓝色Vlan的表项。由于通信目标PC2连接在端口3上且该端口为接入端口，因此交换机剥除数据帧的Vlan标签后(数据帧④)转发给端口3，最终PC2成功收到PC1发来的数据帧。</p><p>可见，Vlan间通信时，即使双方都连接在同一台交换机上，也必须经过<strong>“发送方→交换机→路由器→交换机→接收方”</strong>这样一个流程。在进行三层路由转发时，<strong>数据包IP地址保持不变，MAC地址则在每个节点都会改变</strong>。</p><h1 class=pgc-h-arrow-right><strong>三层交换机</strong></h1><p style=text-align:start>三层交换机的原理模型可以认为是：三层交换机 = 二层交换机+三层路由器 三层交换机既有二层交换单元，内部还有一个三层路由模块。（原理上可以认为三层交换机就是把一个交换机和一个路由器装在一个盒子里。虽然原理上我们可以这样简单认为，但在具体实现上，特别是报文的转发流程上，还是有很大差异的。所以三层交换机在转发性能和成本上都有很大的优势）</p><p style=text-align:start><br></p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c86d1591d7847a7b31254ee7cc117c3><p class=pgc-img-caption></p></div><p style=text-align:start>在三层交换机上，可以在一个VLAN配置三层接口（cisco成为交换机虚拟接口 SVI:switch virtual interface），这个SVI接口就是上面原理模型中的那个路由模块对应的接口。它具备普通路由器接口的基本特性，比如：</p><ul><li>该接口有自己的MAC地址；</li><li>在该SVI接口上，我们可以进行标准的三层协议的配置，包括IP地址，路由协议等等。</li></ul><h1 class=pgc-h-arrow-right><strong>三层交换机转发流程</strong></h1><p style=text-align:start>使用VLAN Trunking后，用传统路由器进行Vlan间路由在性能上存在一定的不足：由于路由器采用通用CPU，转发完全依靠软件处理，同时支持各种通信接口，给软件带来较大负担。软件要处理包括报文接收、校验、查找路由、选项处理、报文分片等，导致性能不可能很高。就Vlan间路由而言，流量会集中到路由器和交换机互联的汇聚链路部分，该部分容易成为速度瓶颈。</p><p style=text-align:start>由于Vlan间通信比较简单，只需查下路由表，所以可将交换机集成查路由表的专用芯片(ASIC)，实现二层交换和三层路由的功能集成，即三层交换机(Layer 3 Switch)。</p><p style=text-align:start>三层交换机的设计基于对IP路由的仔细分析，提取出IP路由中每个报文都必经的简化过程：</p><p style=text-align:start>IP路由中绝大多数报文不包含IP选项，因此多数情况下无需处理报文IP选项;</p><p style=text-align:start>不同的网络报文长度不同，为支持各种异构网络的互连，IP实现了报文分片功能，但在全以太网环境中，数据帧(报文)长度固定，因此可裁减报文分片功能;</p><p style=text-align:start>三层交换机采用与路由器最长地址掩码匹配不同的方法，使用精确地址匹配的方式处理，有利于硬件实现快速查找;</p><p style=text-align:start>三层交换机采用Cache方法，将最近经常使用的主机路由放入硬件查找表。只有在该Cache中无法匹配到的条项才通过软件转发。这样，只有每个流的第一个报文通过软件转发，其后的大量数据流则在硬件中得以完成，极大提升转发性能。</p><p style=text-align:start>三层交换机的内部结构可参照下面的简图。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fe41bdc30f7249daa7d7ffb17ea3e5c3><p class=pgc-img-caption></p></div><p style=text-align:start>如图，内置的路由模块与交换模块相同，使用ASIC硬件处理路由。因此，与传统的路由器相比，可实现高速路由。并且，路由与交换模块由内部汇聚链路连接，可确保相当大的带宽。</p><p style=text-align:start>对应到IP网络模型中，每个Vlan对应一个IP网段，三层交换机中的三层转发引擎在各网段(Vlan)间转发报文，实现Vlan之间的互通，因此三层交换机的路由功能通常叫做Vlan间路由(Inter-VLAN Routing)。</p><p style=text-align:start>使用路由器连接时，一般需要在LAN接口上设置对应各Vlan的子接口;三层交换机则是在内部生成“VLAN接口(VLAN Interface)”，用于各Vlan收发数据。在Cisco的Catalyst系列交换机上，VLAN接口被称为SVI(Switched Virtual Interface，交换虚拟接口)。三层交换机每创建一个Vlan就会自动生成一个SVI。在SVI接口设置默认网关后，并将主机网关配置成与交换机SVI相同，即可实现不同Vlan间的路由。</p><p style=text-align:start>使用三层交换机进行Vlan间路由与使用汇聚链路连接路由器与交换机相似，即需经过“发送方→交换模块→路由模块→交换模块→接收方”的流程。</p><p style=text-align:start>交换机的转发行为主要借助于下面几张表：</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d47423b9bb9b4689859db124601171e3><p class=pgc-img-caption></p></div><p style=text-align:start>三层主机路由表相当于【网段路由表+ARP表】的组合，用于加快交换流程。三层主机路由表的生成有两种方式：</p><ul><li>预先生成： 也有些设备只要学习到ARP条目，就自动生成主机路由，并保持主机路由与ARP条目之间的同步与一致性。这种方式对主机路由硬件资源开销会大一些，但第一个报文就能采用交换方式，性能更高。</li><li>按需生成：到达该目的地的第一个报文转发时，有软件进行三层转发后生成。并且该目的地址一定时间内没有流量将被老化。这就是所谓的“一次路由，多次交换”。</li></ul><ol start=1><li><strong>准备工作：</strong> 三层交换机为VLAN配置三层接口IP后，会在交换芯片的<strong>MAC地址表</strong>中添加三层接口MAC＋VID的表项，并且为表项的<strong>三层转发标志(Route标志)置位</strong>。</li><li><strong>转发流程</strong></li></ol><ul><li>硬件二层交换：</li></ul><p>报文进入三层交换机后，首先在交换模块进行标准的二层交换处理：</p><p>根据报文的目的MAC（精确匹配查找），查找二层MAC转发表： 如果不存在该MAC条目，则在所有端口上进行泛洪处理（广播组播也会泛洪）。 如果存在该MAC条目，并且该条目没有Route标志，则进行标准交换转发 如果该MAC条目上有Route标记，则进行硬件三层转发。</p><ul><li>硬件三层转发：</li></ul><p>根据报文的目的IP地址（精确匹配查找），查找三层主机路由表： 如果存在，直接转发（TTL--，目的MAC地址进行替换） 如果不存在，则进行标准的软件三层报文转发。</p><ul><li>软件三层转发：</li></ul><p>查找目的IP的网段路由（最佳匹配查找）， 如果路由不存在，报文丢弃。 如果存在，查找下一跳的ARP表，如果ARP不存在，进行ARP学习。 学习到ARP后，进行报文转发，并将转发信息写入硬件主机路由表， 以后该目的IP的报文就可以通过硬件进行三层转发了。（这就是所谓的一次路由，多次交换）</p><h1 class=pgc-h-arrow-right><strong>实例</strong></h1><p style=text-align:start>假设网络按图19连接好后，所有设备均为初始状态，也未向外发送过任何报文。若PC1已知PC2的IP地址，则可通过ping命令发送ICMP报文来获知PC1能否到达PC2。以下分析该过程。</p><div class=pgc-img><img alt=vlan详解之二层三层转发原理 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3b2a22f24f68492ea8b6c40db2425f05><p class=pgc-img-caption></p></div><p style=text-align:start>ping流程网络拓扑</p><ol start=1><li>PC1将自身IP和子网掩码255.255.255.0相与得到网络号1.1.1.0，将PC2的IP与子网掩码相与得到网络号2.2.2.0，得知PC2与自己不在同一网段。于是PC1检索路由表得到默认网关。PC1欲向网关传递信息，但此时PC1中ARP表为空，所以向默认网关(交换机三层接口)发出ARP请求帧，请求网关MAC地址。该帧目的MAC地址为全1，源MAC地址为本机MAC地址，请求的IP地址为网关1.1.1.1;</li><li>SW收到ARP请求帧，对其附加端口PVid(10)的标签;</li><li>SW用ARP请求帧的Mac1和Vid10查找MAC转发表，发现没有该项，则进行学习，即在表中添加“Mac1—Vid10—Port1”的记录;并将源IP和MAC的对应关系(“1.1.1.2—Mac1”)记录到ARP表，表明目的IP为1.1.1.2的数据帧转发时目的MAC为Mac1，同时需路由到端口Port1;</li><li>ARP请求的目的地址是广播地址，SW将其洪泛到该Vlan的每个端口(除入端口);同时SW自身截获一份上送CPU(网关)，发现是询问自己的MAC，于是回复ARP单播应答帧，目的MAC为PC1的Mac1，源MAC为网关的MAC地址GwMac1，源IP为1.1.1.1，目的IP为PC1的1.1.1.2;</li><li>PC1收到SW发来的ARP应答帧，得到SW三层网关MAC地址，将“1.1.1.1—GwMac1”记录到ARP表。PC1向SW发送ICMP请求帧，目的IP为PC2的IP(2.2.2.2)，目的MAC为网关MAC，源IP和源MAC为PC1的;</li><li>SW收到ICMP请求帧，对其附加端口PVid(10)的标签，然后进行源MAC地址学习，发现二层转发表有该条目，更新老化时间。因该帧目的MAC地址是网关，SW送交三层路由处理。</li><li>在三层首先检查IP报文的版本、IP首部检验和TTL是否正确，若不正确则标记丢弃并交由CPU处理;正确则在三层主机路由表(又称L3表)中查找目的IP(即PC2的IP 2.2.2.2)。此时L3表中只包含与自己直连的32位地址(包括自身接口)及步骤⑶中ARP表学习后下发的PC1信息，而找不到PC2的信息。进而按最长前缀匹配算法查找子网路由表(又称Longest Prefix Match即LPM表)得到2.2.2.1目的网段的条目，下一跳的IP地址为 2.2.2.1;</li><li>索引回L3表查找2.2.2.1，得到该条目，发现要提交CPU处理(CPU也需要看作是一个端口);</li><li>CPU没有到PC2的路由，但PC2的目的IP属于自己接口地址2.2.2.1的网段，故向接口Vlan20所包含的所有物理端口广播一个ARP请求帧，源MAC地址为交换机接口的三层MAC地址GwMac2，源IP地址为2.2.2.1，请求IP地址2.2.2.2的MAC地址;</li><li>PC2收到ARP请求，学习“2.2.2.1—GwMac2”加入ARP表;并回复ARP应答帧，目的IP为交换机接口Vlan20的IP地址2.2.2.1，目的MAC为交换机接口Vlan20的MAC地址GwMac2;</li><li>SW收到PC2发送的ARP应答帧，附加端口PVid(20)后在MAC表中查找“Mac2+Vid20”，没找到则学习源地址，在MAC转发表中添加PC2相关记录。因该帧目的MAC为网关地址，故提交三层处理;</li><li>三层首先检查报文正确性，无误则在L3表中查找目的IP。由于目的IP为本机，故上送CPU处理。CPU对报文处理后得到“2.2.2.2—Mac2”将相关信息加入ARP表(CPU下发给L3表进行记录)。</li><li>PC1向SW发送的第一个ICMP请求帧存储在内存中，此时交由CPU进行IP报文头部修改(TTL减1,FCS重新计算封装)和MAC封装(目的MAC地址改为PC2的MAC地址，源MAC地址改为SW三层MAC地址)并发送给PC2，如果超时则丢弃，CPU发送ICMP超时给PC1;</li><li>PC2收到PC1发来的ICMP请求后，回复ICMP应答帧，目的IP为PC1的IP 1.1.1.2，同样PC2发现该地址和自己不在同一子网，需要网关进行转发。之前PC2已学习到交换机接口Vlan20的ARP，此时根据该ARP将ICMP应答帧目的MAC地址填为网关MAC地址GwMac2发送出去。交换机收到帧后，发现目的MAC地址是网关地址，取出帧中的目的IP地址1.1.1.1查找路由。之前交换机已学习到该IP的路由，所以会查找到主机路由表中相应的路由并将帧目的MAC地址换成Mac1，源MAC地址换成网关MAC地址GwMac2，发送到端口Port1上。最终，PC1就收到PC2的ICMP应答。</li><li>经过以上流程后，PC1和PC2分别学到各自网关接口的ARP，交换机也有了分别到达PC1和PC2的路由。后续的报文不再通过路由，而直接由L3表中对应的表项进行硬件转发。</li></ol><p style=text-align:start><br></p><p style=text-align:start>至此，基于vlan的二层三层转发原理就基本清楚了，后面将开始研究linux的vlan实现了！linux的vlan原理，明白了linux的实现思路，大有益处。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'vlan','详解','层三层'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>