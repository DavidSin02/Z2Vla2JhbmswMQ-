<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>STM32单片机程序之面向'接口'编程 | 极客快訊</title><meta property="og:title" content="STM32单片机程序之面向'接口'编程 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e631e7f0750b4b948eed2205040227c1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d40f1c0c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d40f1c0c.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="STM32单片机程序之面向'接口'编程"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d40f1c0c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>STM32单片机程序之面向'接口'编程</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><a class=tteditor-forum data-concern-id=6215497899594222081 data-id data-name=科技 data-uid=false>#科技#</a> <a class=tteditor-forum data-concern-id=1653768779301895 data-id data-name=科技V计划 data-uid=false>#科技V计划#</a></p><p><strong>前言</strong>：在网上有很多面向接口编程的文章与例子，特别是在面向对象编程方面的，比如JAVA里面的接口，C++里面的接口，还有C语言的函数指针类的接口。但是我这里的讲的面向"接口"编程与其不一样，所以我这里加了双引号，避免大家说我偷换概念。我这里的面向"接口"编程这个接口是在嵌入式中实际存在的一个物理接口。</p><p>关键点：面向接口编程，相当于透过现象看本质，抓住事务的共性；在程序实现中应该依赖于抽象，而不依赖于具体。</p><p>为了更加容易理解面向接口编程的思想，现在假设有一个简单的灯光控制系统（娱乐室内灯控系统）：由一个主控设备与三个子设备组成。主控设备有三个接口，每个接口由24VDC电源输出与一个串口组成，一共4根线。每个子设备由一个接口（串口及电源共4根线）及其控制的一种灯组成，图示如下：</p><div class=pgc-img><img alt='STM32单片机程序之面向"接口"编程' onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e631e7f0750b4b948eed2205040227c1><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p><strong>重点来了</strong></p><p><strong>方案1</strong>、不同种类子设备子固定插入到主控固定接口（LED类固定插入接口1，普通照明类固定插入接口2，激光灯类固定插入接口3）。</p><p><strong>方案2</strong>、不同种类子设备子插入主控的接口不固定，随便插。</p><p>任务是：实现主控的程序功能。</p><p>针对方案1，得出的设计极有可能是面向具体对象的设计实现，即灯光类型这个对象。针对方案2得到的必定是高度抽象的面向接口方式的设计实现。从方案的优劣来看，应该极大部分人都会选择方案2。但是对一般设计实现者（码农）极有可能选择方案1，因为"看起来"实现的难度小，都是固定的不是很容易吗。下面我选择方案2来实现这个设计。由上面假设的内容可见，它们的物理接口是一样的四根线，分别为24V+GND+TXD+RXD，这样子设备插入任意接口的物理基础有了。（假如采用方案1还需要实现物理防呆的设计）</p><h1>1、抽象出模块的接口</h1><p>为了适应需求的灵魂性需要对主控模块的接口进行抽象出去基本功能需求，得到下图所示的样子。</p><div class=pgc-img><img alt='STM32单片机程序之面向"接口"编程' onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/af8d6fd9724e4734b73b9556ef5f6cd2><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>由上图及需求很容易想象到：对接口进行编程才是唯一出路，不可能针对某种类型的具体设备进行编程，否则需要对每个接口进行适配三种类型的灯控功能（因为方案2的需求）。此即为依赖于抽象，而不依赖于具体（灯光类型）。此处的抽象为主控的接口，而此处的具体的某个类型的子设备。所以要实现这个主控的程序，必须对子设备进行一定程度的抽象，其共性一定要认识得非常透切。</p><h1>2、实现接口描述</h1><p>现在看看每个接口的共性有那些属性：给出代码如下（此处给出简单的共同属性）</p><p>typedef struct</p><p>{</p><p>bool Inserted; //插入标志</p><p>char name[10]; //名称</p><p>u8 LampType; //类型</p><p>u8 Sn[10]; //序列号</p><p>u8 WorkFunc; //工作</p><p>u8 Status; //状态</p><p>u8 NeedPower; //需求功率</p><p>u8 FuncList[10]; //功能列表</p><p>}LampInfo_t;</p><p>再给出灯类型定义（代码如下）：</p><p>typedef enum</p><p>{</p><p>eLampTypeNone=0, //类型不确定（初始类型）</p><p>eLampTypeLed=1, //LED类</p><p>eLampTypeLaser, //激光类</p><p>eLampTypeNormal, //普通类（普通照明）</p><p>}eLampType_t;</p><p>给出接口类型定义</p><p>typedef enum</p><p>{</p><p>eLampIFNone=0, //接口类型</p><p>eLampIF1=1, //接口1</p><p>eLampIF2, //接口2</p><p>eLampIF3, //接口3</p><p>}eLampIF_t;</p><p>现在再给出三个接口的描述</p><p>typedef struct</p><p>{</p><p>u8 OnlineDevAmount; //在线子设备数量</p><p>LampInfo_t IF1; //接口1</p><p>LampInfo_t IF2; //接口2</p><p>LampInfo_t IF3; //接口3</p><p>}LampIfInfo_t;</p><p>现在抽象出这几种类型的灯光控制效果，给出代码如下</p><p>typedef enum</p><p>{</p><p>eLampFuncNone=0, //功能</p><p>eLampFuncOpen=1, //打开</p><p>eLampFuncClose, //关闭</p><p>eLampFuncFlicker05HZ, //0.5Hz闪烁</p><p>eLampFuncFlicker1HZ, //1Hz闪烁</p><p>eLampFuncFlicker2HZ, //2Hz闪烁</p><p>eLampFuncFlicker3HZ, //3Hz闪烁</p><p>eLampFuncFlicker5HZ, //5Hz闪烁</p><p>eLampFuncFlicker10HZ, //10Hz闪烁</p><p>//其他灯光效果（子设备是这个功能列表的子集）</p><p>}eLampFuncList_t;</p><h1>3、 实现接口描述功能初始化</h1><p>//灯描述初始化</p><p>Static void LampInfoInit(LampInfo_t *LampInfo)</p><p>{</p><p>LampInfo->Inserted=FALSE; //插入标志</p><p>memcpy(LampInfo->name,"default",10); //名称</p><p>LampInfo->LampType=eLampTypeNone; //类型</p><p>memset(LampInfo->Sn,0,10); //序列号</p><p>LampInfo->WorkFunc=eLampFuncNone; //工作</p><p>LampInfo->Status=0; //状态</p><p>LampInfo->NeedPower=0; //需求功率</p><p>memset(LampInfo->FuncList,0,10); //功能列表</p><p>}</p><p>//灯接口描述初始</p><p>void LampIfInfoInit(LampIfInfo_t *Lamp)</p><p>{</p><p>Lamp->OnlineDevAmount=0; //在线子设备数量</p><p>LampInfoInit(&Lamp->IF1); //接口1</p><p>LampInfoInit(&Lamp->IF2); //接口2</p><p>LampInfoInit(&Lamp->IF3); //接口3</p><p>}</p><h1>4、实现接口常规功能</h1><p>4.1、设置与获取子设备插入接口标志</p><p>void SetLampInterFaceInsertedFlag(LampIfInfo_t *Lamp,eLampIF_t IfNumber,bool FLAG)</p><p>{</p><p>switch(IfNumber)</p><p>{</p><p>case eLampIF1:Lamp->IF1.Inserted=FLAG; //设置接口1插入标志</p><p>break;</p><p>case eLampIF2:Lamp->IF2.Inserted=FLAG; //设置接口2插入标志</p><p>break;</p><p>case eLampIF3:Lamp->IF3.Inserted=FLAG; //设置接口3插入标志</p><p>break;</p><p>default:</p><p>break;</p><p>}</p><p>}</p><p>bool GetLampInterFaceInsertedFlag(LampIfInfo_t *Lamp,eLampIF_t IfNumber,bool FLAG)</p><p>{</p><p>bool result=FALSE;</p><p>switch(IfNumber)</p><p>{</p><p>case eLampIF1:result=Lamp->IF1.Inserted;</p><p>break;</p><p>case eLampIF2:result=Lamp->IF2.Inserted;</p><p>break;</p><p>case eLampIF3:result=Lamp->IF3.Inserted;</p><p>break;</p><p>default:</p><p>break;</p><p>}</p><p>return result;</p><p>}</p><p>4.2、获取子设备在线数量</p><p>u8 GetLampOnlineAmount(LampIfInfo_t *Lamp)</p><p>{</p><p>Lamp->OnlineDevAmount=0; //在线设备数量清零</p><p>if(Lamp->IF1.Inserted==TRUE)Lamp->OnlineDevAmount+=1; //接口1在线总数+1</p><p>if(Lamp->IF2.Inserted==TRUE)Lamp->OnlineDevAmount+=1; //接口2在线总数+1</p><p>if(Lamp->IF3.Inserted==TRUE)Lamp->OnlineDevAmount+=1; //接口3在线总数+1</p><p>return Lamp->OnlineDevAmount; //返回在线子设备数量</p><p>}</p><p>4.3、设置与获取接口上子设备的名称</p><p>void SetLampDeviceName(LampIfInfo_t *Lamp,eLampIF_t IfNumber,char *DevName)</p><p>{</p><p>switch(IfNumber)</p><p>{</p><p>case eLampIF1:memcpy(Lamp->IF1.name,DevName,strlen(DevName)); //拷贝接口1名称</p><p>break;</p><p>case eLampIF2:memcpy(Lamp->IF2.name,DevName,strlen(DevName)); //拷贝接口2名称</p><p>break;</p><p>case eLampIF3:memcpy(Lamp->IF3.name,DevName,strlen(DevName)); //拷贝接口3名称</p><p>break;</p><p>default:</p><p>break;</p><p>}</p><p>}</p><p>bool GetLampDeviceName(LampIfInfo_t *Lamp,eLampIF_t IfNumber,char *DevName)</p><p>{</p><p>bool result=TRUE;</p><p>switch(IfNumber)</p><p>{</p><p>case eLampIF1:memcpy(DevName,Lamp->IF1.name,10); //拷贝接口1名称</p><p>break;</p><p>case eLampIF2:memcpy(DevName,Lamp->IF2.name,10); //拷贝接口2名称</p><p>break;</p><p>case eLampIF3:memcpy(DevName,Lamp->IF3.name,10); //拷贝接口3名称</p><p>break;</p><p>default:result=FALSE;</p><p>break;</p><p>}</p><p>return result;</p><p>}</p><p>4.4、设置与获取子设备类型</p><p>void SetLampDeviceType(LampIfInfo_t *Lamp,eLampIF_t IfNumber,eLampType_t Type)</p><p>{</p><p>switch(IfNumber)</p><p>{</p><p>case eLampIF1:Lamp->IF1.LampType=Type;</p><p>break;</p><p>case eLampIF2:Lamp->IF2.LampType=Type;</p><p>break;</p><p>case eLampIF3:Lamp->IF3.LampType=Type;</p><p>break;</p><p>default:</p><p>break;</p><p>}</p><p>}</p><p>eLampType_t GetLampDeviceType(LampIfInfo_t *Lamp,eLampIF_t IfNumber)</p><p>{</p><p>eLampType_t Type;</p><p>switch(IfNumber)</p><p>{</p><p>case eLampIF1:Type=Lamp->IF1.LampType;</p><p>break;</p><p>case eLampIF2:Type=Lamp->IF2.LampType;</p><p>break;</p><p>case eLampIF3:Type=Lamp->IF3.LampType;</p><p>break;</p><p>default:Type=eLampTypeNone;</p><p>break;</p><p>}</p><p>return Type;</p><p>}</p><p>4.5、其他功能</p><p>忽略部分代码：包括子设备序列号，需求功率，功能列表，当前工作模式（功能列表中的一项），设备状态。</p><h1>5、工作流程</h1><p>以上模块代码是主控模块对于子设备的功能抽象描述，此为面向“接口”编程的基础。其他工作流程均依据这个基础。现在看看面向“接口”编程的主控工作流程。如下图所示。</p><div class=pgc-img><img alt='STM32单片机程序之面向"接口"编程' onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/353aaaa8d48b4aa1a725e52f256d20eb><p class=pgc-img-caption>面向接口描述字的流程</p><div class=pgc-img-handler><div class="pgc-img-button editorImage fix-android"><section></section></div><div class="pgc-img-button setImageCover fix-android"><section></section></div><div class="pgc-img-button deleteImage fix-android"><section></section></div></div><div class=pgc-img-border></div></div><p>由上图可见接口描述字是面向“接口”编程的关键，只有高度抽象出其描述字才能设计出好的产品。实现了接口描述字相关功能，方案2的设计基本就实现了。</p><p>总结：</p><p>面向“接口”编程是一个编程思想，它依赖的是对象抽象出来的共同属性部分，它不依赖于具体的某一个对象。就如上面的例子一样，只有这样高度抽象出子设备的共同属性，才能实现子设备插入任意物理接口的需求。当然实际产品中的物理接口可能还有其他形式，比如增加一个插拔检测引脚，或者其他IO信号。无论物理接口形式如何变化，只要心里有面向“接口”编程的思想，就能抽象出实物的共同属性。另外面向“接口”编程可以演化为面向“接口”设计，包括硬件设计，结构设计。只有硬件与结构按照面向“接口”设计之后，才能给编程实现面向“接口”编程提供实现基础。</p><p>大家有什么不同看法可以留言交流，再次谢谢。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'STM32','单片机','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>