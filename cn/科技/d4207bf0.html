<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基于Spring Boot搭建应用开发框架——基础架构 | 极客快訊</title><meta property="og:title" content="基于Spring Boot搭建应用开发框架——基础架构 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/afeba6d083bb4e78ada213e1b6cd513c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d4207bf0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d4207bf0.html><meta property="article:published_time" content="2020-11-14T20:59:18+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:18+08:00"><meta name=Keywords content><meta name=description content="基于Spring Boot搭建应用开发框架——基础架构"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d4207bf0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基于Spring Boot搭建应用开发框架——基础架构</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>一、创建项目</strong></h1><p style=text-align:start>这一节创建项目的基础结构，按照spring boot的思想，将各个不同的功能按照starter的形式拆分开来，做到灵活组合，并简单介绍下Spring Boot相关的东西。</p><h1 class=pgc-h-arrow-right><strong>1、创建工程</strong></h1><p style=text-align:start>① 通过File > New > Project，新建工程，选择Spring Initializr，然后Next。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/afeba6d083bb4e78ada213e1b6cd513c><p class=pgc-img-caption></p></div><p style=text-align:start>② 尽量为自己的框架想个好点的名字，可以去申请个自己的域名。我这里项目名称为Sunny，项目路径为com.lyyzoo.sunny。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6fa8dd68fbe849a299f374092faca7ec><p class=pgc-img-caption></p></div><p style=text-align:start>③ 这里先什么都不选，后面再去集成。注意我的Spring Boot版本为1.5.9。Next</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92cc9fdf32b4482fad8b6c5a2ff21858><p class=pgc-img-caption></p></div><p style=text-align:start>④ 定义好工程的目录，用一个专用目录吧，不要在一个目录下和其它东西杂在一起。之后点击Finish。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1c3567321a87411abb5f2074b4317f9b><p class=pgc-img-caption></p></div><p style=text-align:start>上面说的这么详细，只有一个目的，从一个开始就做好规范。</p><p style=text-align:start>⑤ 生成的项目结构如下，可以自己去看下pom.xml里的内容。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5624772bbcc04c4b8e0556e9e2909adf><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、创建Starter</strong></h1><p style=text-align:start>先创建一个core核心、cache缓存、security授权认证，其它的后面再集成进去。</p><p style=text-align:start>跟上面一样的方式，在Sunny下创建sunny-starter-core、sunny-starter-cache、sunny-starter-security子模块。</p><p style=text-align:start>这样分模块后，我们以后需要哪个模块就引入哪个模块即可，如果哪个模块不满足需求，还可以重写该模块。</p><p style=text-align:start>最终的项目结构如下：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b12e1cd5f28a4714afb95ac7e3a56846><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3、启动项目</strong></h1><p style=text-align:start>首先在core模块下来启动并了解SpringBoot项目。</p><p style=text-align:start>① 在com.lyyzoo.core根目录下，有一个SunnyStarterCoreApplication，这是SpringBoot的入口类，通常是*Application的命名。</p><p style=text-align:start>入口类里有一个main方法，其实就是一个标准的Java应用的入口方法。在main方法中使用SpringApplication.run启动Spring Boot项目。</p><p style=text-align:start>然后看看@SpringBootApplication注解，@SpringBootApplication是Spring Boot的核心注解，是一个组合注解。</p><p style=text-align:start>@EnableAutoConfiguration让Spring Boot根据类路径中的jar包依赖为当前项目进行自动配置。</p><p style=text-align:start>Spring Boot会自动扫描@SpringBootApplication所在类的同级包以及下级包里的Bean。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bebb443c477b480eada9bcc1f27a08df><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f5acdcd55b1449718ff6f4acd2ac8cf8><p class=pgc-img-caption></p></div><p style=text-align:start>② 先启动项目，这里可以看到有一个Spring Boot的启动程序，点击右边的按钮启动项目。看到控制台Spring的标志，就算是启动成功了。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/080f6f714cb64da1b0559f324e88efad><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a378d372bc684260a84a38cbaf63883d><p class=pgc-img-caption></p></div><p style=text-align:start>③ 替换默认的banner</p><p style=text-align:start>可以到http://patorjk.com/software/taag/这个网站生成一个自己项目的banner。创建banner.txt并放到resources根目录下。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/017c9b97717b4003a0e9fd1d41061619><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>4、Spring Boot 配置</strong></h1><p style=text-align:start>① 配置文件</p><p style=text-align:start>Spring Boot使用一个全局的配置文件application.properties或application.yaml，放置在src/main/resources目录下。我们可以在这个全局配置文件中对一些默认的配置值进行修改。</p><p style=text-align:start>具体有哪些配置可到官网查找，有非常多的配置，不过大部分使用默认即可。Common application properties</p><p style=text-align:start>然后，需要为不同的环境配置不同的配置文件，全局使用application-{profile}.properties指定不同环境配置文件。</p><p style=text-align:start>我这里增加了开发环境(dev)和生产环境(prod)的配置文件，并通过在application.properties中设置spring.profiles.active=dev来指定当前环境。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5f96ac354f944314b22d28d49d398794><p class=pgc-img-caption></p></div><p style=text-align:start>② starter pom</p><p style=text-align:start>Spring Boot为我们提供了简化开发绝大多数场景的starter pom，只要使用了应用场景所需的starter pom，无需繁杂的配置，就可以得到Spring Boot为我们提供的自动配置的Bean。</p><p style=text-align:start>后面我们将会通过加入这些starter来一步步集成我们想要的功能。具体有哪些starter，可以到官网查看：Starters</p><p style=text-align:start>③ 自动配置</p><p style=text-align:start>Spring Boot关于自动配置的源码在spring-boot-autoconfigure中如下：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9dd1e00f0c3442dcacc087d67043dce0><p class=pgc-img-caption></p></div><p style=text-align:start>我们可以在application.properties中加入debug=true，查看当前项目中已启用和未启用的自动配置。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aa0933c119d34ee2b24c0b0c6689b0ad><p class=pgc-img-caption></p></div><p style=text-align:start>我们在application.properties中的配置其实就是覆盖spring-boot-autoconfigure里的默认配置，比如web相关配置在web包下。</p><p style=text-align:start>常见的如HttpEncodingProperties配置http编码，里面自动配置的编码为UTF-8。</p><p style=text-align:start>MultipartProperties，上传文件的属性，设置了上传最大文件1M。</p><p style=text-align:start>ServerProperties，配置内嵌Servlet容器，配置端口、contextPath等等。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ac3b6dc92d9746d9b5fa48aa5293d131><p class=pgc-img-caption></p></div><p style=text-align:start>之前说@SpringBootApplication是Spring Boot的核心注解，但他的核心功能是由@EnableAutoConfiguration注解提供的。</p><p style=text-align:start>@EnableAutoConfiguration注解通过@Import导入配置功能，在AutoConfigurationImportSelector中，通过SpringFactoriesLoader.loadFactoryNames扫描META-INF/spring.factories文件。</p><p style=text-align:start>在spring.factories中，配置了需要自动配置的类，我们也可以通过这种方式添加自己的自动配置。</p><p style=text-align:start>在spring-boot-autoconfigure下就有一个spring.factories，如下：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a1da94117b741e8aac34ee5c81f8f0e><p class=pgc-img-caption></p></div><p style=text-align:start>说了这么多，只为说明一点，Spring Boot为我们做了很多自动化的配置，搭建快速方便。</p><p style=text-align:start>但是，正因为它为我们做了很多事情，就有很多坑，有时候，出了问题，我们可能很难找出问题所在，这时候，我们可能就要考虑下是否是自动配置导致的，有可能配置冲突了，或者没有使用上自定义的配置等等。</p><h1 class=pgc-h-arrow-right><strong>5、项目结构划分</strong></h1><p style=text-align:start>core是项目的核心模块，结构初步规划如下：</p><p style=text-align:start>　base是项目的基础核心，定义一些基础类，如BaseController、BaseService等；</p><p style=text-align:start>cache是缓存相关；<br></p><p style=text-align:start>config是配置中心，模块所有的配置放到config里统一管理；</p><p style=text-align:start>constants里定义系统的常量。<br></p><p style=text-align:start>exception里封装一些基础的异常类；</p><p style=text-align:start>　system是系统模块；</p><p style=text-align:start>util里则是一些通用工具类；</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c58b67900e5489ba3739bdb9fd5d9d1><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>二、基础结构功能</strong></h1><h1 class=pgc-h-arrow-right><strong>1、web支持</strong></h1><p style=text-align:start>只需在pom.xml中加入spring-boot-starter-web的依赖即可。</p><p style=text-align:start>之后，查看POM的依赖树(插件：Maven Helper)，可以看到引入了starter、tomcat、web支持等。可以看出，Sping Boot内嵌了servlet容器，默认tomcat。</p><p style=text-align:start>自动配置在WebMvcAutoConfiguration和WebMvcProperties里，可自行查看源码，一般我们不需添加其他配置就可以启动这个web项目了。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87d5fa67f78f4671aabc1dacd96b185c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7fff38eeea2d4e29b71f3ec5c6713087><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、基础功能</strong></h1><p style=text-align:start>在core中添加一些基础的功能支持。</p><p style=text-align:start>① 首先引入一些常用的依赖库，主要是一些常用工具类，方便以后的开发。</p><p>View Code</p><p style=text-align:start>版本号如下：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e2cc51b1851a475d9ad766bffcb1d55d><p class=pgc-img-caption></p></div><p style=text-align:start>② 在base添加一个Result类，作为前端的返回对象，Controller的直接返回对象都是Result。</p><p>View Code</p><p style=text-align:start>之后在util添加生成Result的工具类Results，用于快速方便的创建Result对象。</p><p>View Code</p><p style=text-align:start>③ 在base添加BaseEnum&lt;K, V>枚举接口，定义了获取值和描述的接口。</p><p>View Code</p><p style=text-align:start>然后在constants下定义一个基础枚举常量类，我们把一些描述信息维护到枚举里面，尽量不要在代码中直接出现魔法值(如一些编码、中文等)，以后的枚举常量类也可以按照这种模式来写。</p><p>View Code</p><p style=text-align:start>④ 再添加一个常用的日期工具类对象，主要包含一些常用的日期时间格式化，后续可再继续往里面添加一些公共方法。</p><p>View Code</p><p style=text-align:start>⑤ Constants定义系统级的通用常量。</p><p>View Code</p><p style=text-align:start>⑥ 在base添加空的BaseController、BaseDTO、Service、Mapper，先定义好基础结构，后面再添加功能。</p><p style=text-align:start>BaseDTO：标准的who字段、版本号、及10个扩展字段。</p><p style=text-align:start>因为这里用到了@Transient注解，先引入java持久化包：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74ab01d4f6c14329887418e3f9bee2be><p class=pgc-img-caption></p></div><p>View Code</p><p style=text-align:start>同时，重写了toString方法，增加了toJsonString方法，使得可以格式化输出DTO的数据：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6179fed5ce71402f8c683962cb3dde8e><p class=pgc-img-caption></p></div><p style=text-align:start>直接打印DTO，输出的格式大概就是这个样子：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b0f9e73eb5d4bf39bd4ba18964c05d1><p class=pgc-img-caption></p></div><p style=text-align:start>⑦ 在exception添加BaseException，定义一些基础异常类</p><p style=text-align:start>基础异常类都继承自运行时异常类(RunntimeException)，尽可能把受检异常转化为非受检异常，更好的面向接口编程，提高代码的扩展性、稳定性。</p><p style=text-align:start>BaseException：添加了一个错误编码，其它自定义的异常应当继承该类。</p><p>View Code</p><p style=text-align:start>ServiceException：继承BaseException，Service层往Controller抛出的异常。</p><p>View Code</p><h1 class=pgc-h-arrow-right><strong>3、添加系统用户功能，使用Postman测试接口</strong></h1><p style=text-align:start>① 在system模块下，再分成dto、controller、service、mapper、constants子包，以后一个模块功能开发就是这样一个基础结构。</p><p style=text-align:start>User：系统用户</p><p>View Code</p><p style=text-align:start>UserController：用户控制层；用@RestController注解，前后端分离，因为无需返回视图，采用Restful风格，直接返回数据。</p><p>View Code</p><p style=text-align:start>② Postman请求：请求成功，基础的HTTP服务已经实现了。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3794fb206e3642eebbf53359ae82a536><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/296da66f81a84edd9475dc0548c25c4e><p class=pgc-img-caption></p></div><p style=text-align:start></p><p>回到顶部</p><h1 class=pgc-h-arrow-right><strong>三、集成MyBatis，实现基础Mapper和Service<br></strong></h1><h1 class=pgc-h-arrow-right><strong>1、添加JDBC、配置数据源</strong></h1><p style=text-align:start>添加spring-boot-starter-jdbc以支持JDBC访问数据库，然后添加MySql的JDBC驱动mysql-connector-java；</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/68dc677552554238b7f74dbc2b594d24><p class=pgc-img-caption></p></div><p style=text-align:start>在application.properties里配置mysql的数据库驱动</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/41d3b5f0e08a42f081c7c44fc7c66095><p class=pgc-img-caption></p></div><p style=text-align:start>之后在application-dev.properties里配置开发环境数据库的连接信息，添加之后，Springboot就会自动配置数据源了。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2060a60e90e84e02824eb8c305eaadf9><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、集成MyBatis</strong></h1><p style=text-align:start>MyBatis官方为了方便Springboot集成MyBatis，专门提供了一个符合Springboot规范的starter项目，即mybatis-spring-boot-starter。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bf7132c543d4c50bd975b587105f45c><p class=pgc-img-caption></p></div><p style=text-align:start>在application.properties里添加mybatis映射配置：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/83d5253648a74d69bfd39464dcd231d5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3、添加MyBatis通用Mapper</strong></h1><p style=text-align:start>通用Mapper可以极大的简化开发，极其方便的进行单表的增删改查。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ded6f170aae34da89873040098e5195f><p class=pgc-img-caption></p></div><p style=text-align:start>关于通用Mapper，参考网站地址：</p><p style=text-align:start>　　MyBatis通用Mapper</p><p style=text-align:start>　　MyBatis 相关工具</p><p style=text-align:start>之后，在core.base下创建自定义的Mapper，按需选择接口。</p><p style=text-align:start>具体可参考：根据需要自定义接口</p><p>View Code</p><p style=text-align:start>定义好基础Mapper后，就具有下图中的基本通用方法了。每个实体类对应的*Mapper继承Mapper&lt;T>来获得基本的增删改查的通用方法。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44c6b1d48ad74bdb899286fec2911192><p class=pgc-img-caption></p></div><p style=text-align:start>在application.properties里配置自定义的基础Mapper</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e4c6eb71ff284f619ba27c7a4dba96f8><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>4、添加分页插件PageHelper</strong></h1><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1099bc49a5f84a5188cd2e9bc4cd9102><p class=pgc-img-caption></p></div><p style=text-align:start>参考地址：</p><p style=text-align:start>　　MyBatis 分页插件 - PageHelper</p><p style=text-align:start>　　分页插件使用方法</p><p style=text-align:start>分页插件配置，一般情况下，不需要做任何配置。</p><p style=text-align:start>之后，我们就可以在代码中使用 PageHelper.startPage(1, 10) 对紧随其后的一个查询进行分页查询，非常方便。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a46c694715de487ea929316700da77ba><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>5、配置自动扫描Mapper</strong></h1><p style=text-align:start>在config下创建MyBatisConfig配置文件，通过mapperScannerConfigurer方法配置自动扫描Mapper文件。</p><p>View Code</p><p style=text-align:start>注意这里的 MapperScannerConfigurer 是tk.mybatis.spring.mapper.MapperScannerConfigurer，而不是org.mybatis，否则使用通用Mapper的方法时会报类似下面的这种错误</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c81b3c4056354486a0aa17c29e763a70><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>6、定义基础Service</strong></h1><p style=text-align:start>一般来说，我们不能在Controller中直接访问Mapper，因此我们需要加上Service，通过Service访问Mapper。</p><p style=text-align:start>首先定义基础Service&lt;T>接口，根据Mapper定义基本的增删改查接口方法。</p><p>View Code</p><p style=text-align:start>然后是实现类BaseService，以后的开发中，Service接口实现Service&lt;T>，Service实现类继承BaseService&lt;T>。</p><p>View Code</p><p style=text-align:start>BaseService的实现用到了反射工具类Reflections：</p><p>View Code</p><h1 class=pgc-h-arrow-right><strong>7、获取AOP代理</strong></h1><p style=text-align:start>Spring 只要引入aop则是默认开启事务的，一般我们只要在需要事务管理的地方加上@Transactional注解即可支持事务，一般我们会加在Service的类或者具体的增加、删除、更改的方法上。</p><p style=text-align:start>我这里要说的是获取代理的问题。Service的事务管理是AOP实现的，AOP的实现用的是JDK动态代理或CGLIB动态代理。所以，如果你想在你的代理方法中以 this 调用当前接口的另一个方法，另一个方法的事务是不会起作用的。因为事务的方法是代理对象的，而 this 是当前类对象，不是一个代理对象，自然事务就不会起作用了。这是我在不久前的开发中遇到的实际问题，我自定义了一个注解，加在方法上，使用AspectJ来拦截该注解，却没拦截到，原因就是这个方法是被另一个方法以 this 的方式调用的，所以AOP不能起作用。</p><p style=text-align:start>更详细的可参考：Spring AOP无法拦截内部方法调用</p><p style=text-align:start>所以添加一个获取自身代理对象的接口，以方便获取代理对象来操作当前类方法。Service接口只需要继承该接口，T为接口本身即可，就可以通过self()获取自身的代理对象了。</p><p>View Code</p><p style=text-align:start>还需要开启开启 exposeProxy = true，暴露代理对象，否则 AopContext.currentProxy() 会抛出异常。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1657e42500e843259f7dedbe90b3bf1c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>8、数据持久化测试</strong></h1><p style=text-align:start>① 实体映射</p><p style=text-align:start>实体类按照如下规则和数据库表进行转换，注解全部是JPA中的注解：</p><ul><li>表名默认使用类名，驼峰转下划线(只对大写字母进行处理)，如UserInfo默认对应的表名为user_info</li><li>表名可以使@Table(name = "tableName")进行指定，对不符合第一条默认规则的可以通过这种方式指定表名。</li><li>字段默认和@Column一样，都会作为表字段，表字段默认为Java对象的Field名字驼峰转下划线形式。</li><li>可以使用@Column(name = "fieldName")指定不符合第3条规则的字段名。</li><li><strong>使用@Transient注解可以忽略字段，添加该注解的字段不会作为表字段使用，注意，如果没有与表关联，一定要用@Transient标注。</strong></li><li><strong>建议一定是有一个@Id注解作为主键的字段,可以有多个@Id注解的字段作为联合主键。</strong></li><li><strong>默认情况下，实体类中如果不存在包含@Id注解的字段,所有的字段都会作为主键字段进行使用(这种效率极低)。</strong></li><li>由于基本类型，如int作为实体类字段时会有默认值0，而且无法消除，所以实体类中建议不要使用基本类型。</li></ul><p style=text-align:start>User实体主要加了@Table注解，映射表名；然后在userId上标注主键注解；其它字段如果没加@Transient注解的默认都会作为表字段。</p><p>View Code</p><p style=text-align:start>② 创建表结构</p><p>View Code</p><p style=text-align:start>③ 创建UserMapper</p><p style=text-align:start>在system.mapper下创建UserMapper接口，继承Mapper&lt;User>：</p><p>View Code</p><p style=text-align:start>④ 创建UserService</p><p style=text-align:start>在system.service下创建UserService接口，只需继承Service&lt;User>接口即可。</p><p>View Code</p><p style=text-align:start>在system.service.impl下创建UserServiceImpl实现类，继承BaseService&lt;User>类，实现UserService接口。同时加上@Service注解。</p><p>View Code</p><p style=text-align:start>⑤ 修改UserController，注入UserService，增加一些测试API</p><p>View Code</p><p style=text-align:start>⑥ 测试结果</p><p style=text-align:start>查询所有：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/db225fc7f24c4b6896bbc5678917e5b9><p class=pgc-img-caption></p></div><p style=text-align:start>批量保存/修改：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab18afa74b2948dd9d7fce39cd0f1669><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>9、代码生成器</strong></h1><p style=text-align:start>使用代码生成器来生成基础的代码结构，生成DTO、XML等等。</p><p style=text-align:start>MyBatis官方提供了代码生成器MyBatis Generator，但一般需要定制化。MyBatis Generator</p><p style=text-align:start>我这里从网上找了一个使用起来比较方便的界面工具，可生成DTO、Mapper、Mapper.xml，生成之后还需做一些小调整。另需要自己创建对应的Service、Controller。之后有时间再重新定制化一个符合本项目的代码生成器。</p><p style=text-align:start>mybatis-generator界面工具</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/755e220fe07643df85eb28345ce18d73><p class=pgc-img-caption></p></div><p style=text-align:start></p><p>回到顶部</p><h1 class=pgc-h-arrow-right><strong>四、日志及全局异常处理</strong></h1><p style=text-align:start>在前面的测试中，会发现控制台输出的日志不怎么友好，有很多日志也没有输出，不便于查找排查问题。对于一个应用程序来说日志记录是必不可少的一部分。线上问题追踪，基于日志的业务逻辑统计分析等都离不日志。</p><p style=text-align:start>先贴出一些参考资料：</p><p style=text-align:start>　　logback 配置详解</p><p style=text-align:start>　　日志组件slf4j介绍及配置详解</p><p style=text-align:start>　　Java常用日志框架介绍</p><h1 class=pgc-h-arrow-right><strong>1、日志框架简介</strong></h1><p style=text-align:start>Java有很多常用的日志框架，如Log4j、Log4j 2、Commons Logging、Slf4j、Logback等。有时候你可能会感觉有点混乱，下面简单介绍下。</p><ul><li>Log4j：Apache Log4j是一个基于Java的日志记录工具，是Apache软件基金会的一个项目。</li><li>Log4j 2：Apache Log4j 2是apache开发的一款Log4j的升级产品。</li><li>Commons Logging：Apache基金会所属的项目，是一套Java日志接口。</li><li>Slf4j：类似于Commons Logging，是一套简易Java日志门面，本身并无日志的实现。（Simple Logging Facade for Java，缩写Slf4j）。</li><li>Logback：一套日志组件的实现(slf4j阵营)。</li></ul><p style=text-align:start>Commons Logging和Slf4j是日志门面，提供一个统一的高层接口，为各种loging API提供一个简单统一的接口。log4j和Logback则是具体的日志实现方案。可以简单的理解为接口与接口的实现，调用者只需要关注接口而无需关注具体的实现，做到解耦。</p><p style=text-align:start>比较常用的组合使用方式是Slf4j与Logback组合使用，Commons Logging与Log4j组合使用。</p><p style=text-align:start>基于下面的一些优点，选用Slf4j+Logback的日志框架：</p><ul><li>更快的执行速度，Logback重写了内部的实现，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小了</li><li>自动清除旧的日志归档文件，通过设置TimeBasedRollingPolicy 或者 SizeAndTimeBasedFNATP的 maxHistory 属性，你就可以控制日志归档文件的最大数量</li><li>Logback拥有远比log4j更丰富的过滤能力，可以不用降低日志级别而记录低级别中的日志。</li><li>Logback必须配合Slf4j使用。由于Logback和Slf4j是同一个作者，其兼容性不言而喻。</li><li>默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。</li></ul><h1 class=pgc-h-arrow-right><strong>2、配置日志</strong></h1><p style=text-align:start>可以看到，只要集成了spring-boot-starter-web，就引入了spring-boot-starter-logging，即slf4j和logback。</p><p style=text-align:start>其它的几个包：jcl-over-slf4j，代码直接调用common-logging会被桥接到slf4j；jul-to-slf4j，代码直接调用java.util.logging会被桥接到slf4j；log4j-over-slf4j，代码直接调用log4j会被桥接到slf4j。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e649f2778b2e44d8b354706200efd382><p class=pgc-img-caption></p></div><p style=text-align:start>还需引入janino，如果不加入这个包会报错。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/72f2f98c70ec4e21bbb52f01c98dbfa9><p class=pgc-img-caption></p></div><p style=text-align:start>在resources下添加logback.xml配置文件，Logback默认会查找classpath下的logback.xml文件。<br></p><p style=text-align:start>具体配置如下，有较详细的注释，很容易看懂。可以通过application.properties配置日志记录级别、日志输出文件目录等。<br></p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44a6db0ff9e14f9093ed709eceaac45a><p class=pgc-img-caption></p></div><p>View Code</p><p style=text-align:start>加入配置文件后，就可以看到控制台格式化后的日志输出，还可以看到具体代码行数等，比之前的友好多了。</p><p style=text-align:start>同时，将日志滚动输出到日志文件，保留历史记录。可通过logback.rolling=false控制是否需要输出日志到文件。</p><h1 class=pgc-h-arrow-right><strong>3、使用Logger</strong></h1><p style=text-align:start>配置好之后，就可以使用Logger来输出日志了，使用起来也是非常方便。</p><p style=text-align:start>* 可以看到引入的包是slf4j.Logger，代码里并没有引用任何一个跟 Logback 相关的类，这便是使用 Slf4j的好处，在需要将日志框架切换为其它日志框架时，无需改动已有的代码。</p><p style=text-align:start>* LoggerFactory 的 getLogger() 方法接收一个参数，以这个参数决定 logger 的名字，比如第二图中的日志输出。在为 logger 命名时，用类的全限定类名作为 logger name 是最好的策略，这样能够追踪到每一条日志消息的来源</p><p style=text-align:start>* 可以看到，可以通过提供占位符，以参数化的方式打印日志，避免字符串拼接的不必要损耗，也无需通过logger.isDebugEnabled()这种方式判断是否需要打印。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/56b7dadeee6f4c0aa22354a06300ea5d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f75041d629e43e6863654d93eceec5a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>4、全局异常处理</strong></h1><p style=text-align:start>现在有一个问题，当日志级别设置到INFO级别后，只会输出INFO以上的日志，如INFO、WARN、ERROR，这没毛病，问题是，程序中抛出的异常堆栈(运行时异常)都没有打印了，不利于排查问题。</p><p style=text-align:start>而且，在某些情况下，我们在Service中想直接把异常往Controller抛出不做处理，但我们不能直接把异常信息输出到客户端，这是非常不友好的。</p><p style=text-align:start>所以，在config下建一个GlobalExceptionConfig作为全局统一异常处理。主要处理了自定义的ServiceException、AuthorityException、BaseException，以及系统的NoHandlerFoundException和Exception异常。</p><p>View Code</p><p style=text-align:start>看上面的代码，@ControllAdvice(@RestControllerAdvice可以返回ResponseBody)，可看做Controller增强器，可以在@ControllerAdvice作用类下添加@ExceptionHandler，@InitBinder，@ModelAttribute注解的方法来增强Controller，都会作用在被 @RequestMapping 注解的方法上。</p><p style=text-align:start>使用@ExceptionHandler 拦截异常，我们可以通过该注解实现自定义异常处理。在每个处理方法中，封装Result，返回对应的消息及状态码等。</p><p style=text-align:start>通过Logger打印对应级别的日志，也可以看到控制台及日志文件中有异常堆栈的输出了。注意除了BaseException、Exception，其它的都只是打印了简单信息，且为INFO级别。Exception是ERROR级别，且打印了堆栈信息。</p><p style=text-align:start>NoHandlerFoundException 是404异常，这里注意要先关闭DispatcherServlet的NotFound默认异常处理。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/db0f0f1b17224dbb87fde7ee1ef3e8ec><p class=pgc-img-caption></p></div><p style=text-align:start>测试如下：这种返回结果就比较友好了。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/80356e09da404b949e072a75f3ee0a45><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/687ff4443a9545a88f88729c7773fbd5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>五、数据库乐观锁</strong></h1><h1 class=pgc-h-arrow-right><strong>1、乐观</strong><strong>锁</strong></h1><p style=text-align:start>在并发修改同一条记录时，为避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存层加锁，要么在数据库层使用乐观锁，使用version作为更新依据【强制】。 —— 《阿里巴巴Java开发手册》</p><p style=text-align:start>乐观锁，基于数据版本(version)记录机制实现，为数据库表增加一个"version"字段。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。提交数据时，提交的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p style=text-align:start>因此，这节就来处理BaseDTO中的"version"字段，通过增加一个mybatis插件来实现更新时版本号自动+1。</p><h1 class=pgc-h-arrow-right><strong>2、MyBatis插件介绍</strong></h1><p style=text-align:start>MyBatis 允许在己映射语句执行过程中的某一点进行拦截调用。默认情况下， MyBatis 允许使用插件来拦截的接口和方法包括以下几个：<br></p><ul><li>Executor (update 、query 、flushStatements 、commit 、rollback 、getTransaction 、close 、isClosed)</li><li>ParameterHandler (getParameterObject 、setParameters)</li><li>ResultSetHandler (handleResul tSets 、handleCursorResultSets、handleOutputParameters)</li><li>StatementHandler (prepare 、parameterize 、batch update 、query)<br></li></ul><p style=text-align:start>MyBatis 插件实现拦截器接口Interceptor，在实现类中对拦截对象和方法进行处理 。<br></p><ul><li>setProperties：传递插件的参数，可以通过参数来改变插件的行为。</li><li>plugin：参数 target 就是要拦截的对象，作用就是给被拦截对象生成一个代理对象，并返回。</li><li>intercept：会覆盖所拦截对象的原方法，Invocation参数可以反射调度原来对象的方法，可以获取到很多有用的东西。</li></ul><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04d66f7ce11e4b1dad9679d0cf27a6c4><p class=pgc-img-caption></p></div><p style=text-align:start>除了需要实现拦截器接口外，还需要给实现类配置拦截器签名。 使用 @Intercepts 和 @Signature 这两个注解来配置拦截器要拦截的接口的方法，接口方法对应的签名基本都是固定的。</p><p style=text-align:start>@Intercepts 注解的属性是一个 ＠Signature 数组，可以在同 一个拦截器中同时拦截不同的接口和方法。</p><p style=text-align:start>@Signature 注解包含以下三个属性。</p><ul><li>type：设置拦截的接口，可选值是前面提到的4个接口 。</li><li>method：设置拦截接口中的方法名， 可选值是前面4个接口对应的方法，需要和接口匹配 。</li><li>args：设置拦截方法的参数类型数组，通过方法名和参数类型可以确定唯一一个方法 。<br></li></ul><h1 class=pgc-h-arrow-right><strong>3、数据版本插件</strong></h1><p style=text-align:start>要实现版本号自动更新，我们需要在SQL被执行前修改SQL，因此我们需要拦截的就是 StatementHandler 接口的 prepare 方法，该方法会在数据库执行前被调用，优先于当前接口的其它方法而被执行。</p><p style=text-align:start>在 core.plugin 包下新建一个VersionPlugin插件，实现Interceptor拦截器接口。</p><p style=text-align:start>该接口方法签名如下：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/745773dfb8a54c51a9565e987e72c9fb><p class=pgc-img-caption></p></div><p style=text-align:start>在 interceptor 方法中对 UPDATE 类型的操作，修改原SQL，加入version，修改后的SQL类似下图，更新时就会自动将version+1。同时带上version条件，如果该版本号小于数据库记录版本号，则不会更新。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72628d69c1d04d69875c344602225073><p class=pgc-img-caption></p></div><p style=text-align:start>VersionInterceptor插件：</p><p>View Code</p><p style=text-align:start>之后还需配置该插件，只需要在MyBatisConfig中加入该配置即可。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee6465562b324b0481f6578815425cd7><p class=pgc-img-caption></p></div><p style=text-align:start>最后，如果版本不匹配，更新失败，需要往外抛出异常提醒，所以修改BaseService的update方法，增加检查更新是否失败。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/37a205be5fcd4cec95714f8737b98925><p class=pgc-img-caption></p></div><p style=text-align:start>最后，能不用插件尽量不要用插件，因为它将修改MyBatis的底层设计。插件生成的是层层代理对象的责任链模式，通过反射方法运行，会有一定的性能消耗。</p><p style=text-align:start>我们也可以修改 tk.mapper 生成SQL的方法，加入version，这里通过插件方式实现乐观锁主要是不为了去修改 mapper 的底层源码，比较方便。</p><h1 class=pgc-h-arrow-right><strong>六、Druid数据库连接池</strong></h1><p style=text-align:start>创建数据库连接是一个很耗时的操作，也很容易对数据库造成安全隐患。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响程序的性能指标。</p><p style=text-align:start>数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。数据库连接池能明显提高对数据库操作的性能。</p><p style=text-align:start>参考：</p><p style=text-align:start>　　Druid常见问题集锦</p><p style=text-align:start>　　常用数据库连接池 (DBCP、c3p0、Druid) 配置说明</p><h1 class=pgc-h-arrow-right><strong>1、Druid</strong></h1><p style=text-align:start>Druid首先是一个数据库连接池，但它不仅仅是一个数据库连接池，它还包含一个ProxyDriver，一系列内置的JDBC组件库，一个SQLParser。Druid支持所有JDBC兼容的数据库，包括Oracle、MySql、Derby、Postgresql、SQLServer、H2等等。 Druid针对Oracle和MySql做了特别优化，比如Oracle的PSCache内存占用优化，MySql的ping检测优化。Druid在监控、可扩展性、稳定性和性能方面都有明显的优势。Druid提供了Filter-Chain模式的扩展API，可以自己编写Filter拦截JDBC中的任何方法，可以在上面做任何事情，比如说性能监控、SQL审计、用户名密码加密、日志等等。</p><h1 class=pgc-h-arrow-right><strong>2、配置</strong></h1><p style=text-align:start>Druid配置到core模块下，只需在application.properties中添加如下配置即可，大部分配置是默认配置，可更改。有详细的注释，比较容易理解。</p><p>View Code</p><p style=text-align:start>之后启动项目在地址栏输入/druid/index.html并登录就可以看到Druid监控页面：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c3bb76819f934cddbc468ee048a80e3c><p class=pgc-img-caption></p></div><p style=text-align:start></p><p>回到顶部</p><h1 class=pgc-h-arrow-right><strong>七、Redis缓存</strong></h1><p style=text-align:start>对于如今的一个中小型系统来说，至少也需要一个缓存来缓存热点数据，加快数据的访问数据，这里选用Redis做缓存数据库。在以后可以使用Redis做分布式缓存、做Session共享等。</p><h1 class=pgc-h-arrow-right><strong>1、SpringBoot的缓存支持</strong></h1><p style=text-align:start>Spring定义了org.springframework.cache.CacheManager和org.springframework.cache.Cache接口来统一不同的缓存技术。CacheManager是Spring提供的各种缓存技术抽象接口，Cache接口包含缓存的各种操作。</p><p style=text-align:start>针对不同的缓存技术，需要实现不同的CacheManager，Redis缓存则提供了RedisCacheManager的实现。</p><p style=text-align:start>我将redis缓存功能放到sunny-starter-cache模块下，cache模块下可以有多种缓存技术，同时，对于其它项目来说，缓存是可插拔的，想用缓存直接引入cache模块即可。</p><p style=text-align:start>首先引入Redis的依赖：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/489b4c2728c44e92abfb426a3290be1a><p class=pgc-img-caption></p></div><p style=text-align:start>SpringBoot已经默认为我们自动配置了多个CacheManager的实现，在autoconfigure.cache包下。在Spring Boot 环境下，使用缓存技术只需在项目中导入相关的依赖包即可。</p><p style=text-align:start>在 RedisCacheConfiguration 里配置了默认的 CacheManager；SpringBoot提供了默认的redis配置，RedisAutoConfiguration 是Redis的自动化配置，比如创建连接池、初始化RedisTemplate等。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4ede4c6d778e496cbb8d94161859a1bf><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/396ca36c024d4afc99e47871713c0d97><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、Redis 配置及声明式缓存支持</strong></h1><p style=text-align:start>Redis 默认配置了 RedisTemplate 和 StringRedisTemplate ，其使用的序列化规则是 JdkSerializationRedisSerializer，缓存到redis后，数据都变成了下面这种样式，非常不易于阅读。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f252ee7117d498791378fed59f079d7><p class=pgc-img-caption></p></div><p style=text-align:start>因此，重新配置RedisTemplate，使用 Jackson2JsonRedisSerializer 来序列化 Key 和 Value。同时，增加HashOperations、ValueOperations等Redis数据结构相关的操作，这样比较方便使用。</p><p>View Code</p><p style=text-align:start>同时，使用@EnableCaching开启声明式缓存支持，这样就可以使用基于注解的缓存技术。注解缓存是一个对缓存使用的抽象，通过在代码中添加下面的一些注解，达到缓存的效果。</p><ul><li>@Cacheable：在方法执行前Spring先查看缓存中是否有数据，如果有数据，则直接返回缓存数据；没有则调用方法并将方法返回值放进缓存。</li><li>@CachePut：将方法的返回值放到缓存中。</li><li>@CacheEvict：删除缓存中的数据。</li></ul><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/089252fe31fe43b8915319bbf6184377><p class=pgc-img-caption></p></div><p></p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4f6eb29e15ba4cc3bd6ca1e77d799a0f><p class=pgc-img-caption></p></div><p style=text-align:start>Redis服务器相关的一些配置可在application.properties中进行配置：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b67920b985ad48aaa8ea018bfc32646a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3、Redis工具类</strong></h1><p style=text-align:start>添加一个Redis的统一操作工具，主要是对redis的常用数据类型操作类做了一个归集。</p><p style=text-align:start>ValueOperations用于操作String类型，HashOperations用于操作hash数据，ListOperations操作List集合，SetOperations操作Set集合，ZSetOperations操作有序集合。</p><p style=text-align:start>关于redis的key命令和数据类型可参考我的学习笔记：</p><p style=text-align:start>Redis 学习(一) —— 安装、通用key操作命令</p><p style=text-align:start>Redis 学习(二) —— 数据类型及操作</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/44a6db0ff9e14f9093ed709eceaac45a><p class=pgc-img-caption></p></div><p>View Code</p><p style=text-align:start></p><p>回到顶部</p><h1 class=pgc-h-arrow-right><strong>八、Swagger支持API文档</strong></h1><h1 class=pgc-h-arrow-right><strong>1、Swagger</strong></h1><p style=text-align:start>做前后端分离，前端和后端的唯一联系，变成了API接口；API文档变成了前后端开发人员联系的纽带，变得越来越重要，swagger就是一款让你更好的书写API文档的框架。</p><p style=text-align:start>Swagger是一个简单又强大的能为你的Restful风格的Api生成文档的工具。在项目中集成这个工具，根据我们自己的配置信息能够自动为我们生成一个api文档展示页，可以在浏览器中直接访问查看项目中的接口信息，同时也可以测试每个api接口。</p><h1 class=pgc-h-arrow-right><strong>2、配置</strong></h1><p style=text-align:start>我这里直接使用别人已经整合好的swagger-spring-boot-starter，快速方便。</p><p style=text-align:start>参考：spring-boot-starter-swagger</p><p style=text-align:start>新建一个sunny-starter-swagger模块，做到可插拔。</p><p style=text-align:start>根据文档，一般只需要做些简单的配置即可：</p><p style=text-align:start>但如果想要显示swagger-ui.html文档展示页，还必须注入swagger资源：</p><p>View Code</p><h1 class=pgc-h-arrow-right><strong>3、使用</strong></h1><p>一般只需要在Controller加上swagger的注解即可显示对应的文档信息，如@Api、@ApiOperation、@ApiParam等。</p><p>常用注解参考：swagger-api-annotations</p><p>View Code</p><p>之后访问swagger-ui.html页面就可以看到API文档信息了。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/599344da23fc4cd4a518ee1a22e71ddb><p class=pgc-img-caption></p></div><p>如果不需要swagger，在配置文件中配置swagger.enabled=false，或移除sunny-starter-swagger的依赖即可。</p><h1 class=pgc-h-arrow-right><strong>九、项目优化调整</strong></h1><p>到这里，项目最基础的一些功能就算完成了，但由于前期的一些设计不合理及未考虑周全等因素，对项目做一些调整。并参考《阿里巴巴Java开发手册》对代码做了一些优化。</p><h1 class=pgc-h-arrow-right><strong>1、项目结构</strong></h1><p>目前项目分为5个模块：</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/10ee19cb93fb4b13ac6853798858e2f2><p class=pgc-img-caption></p></div><p>最外层的Sunny作为聚合模块负责管理所有子模块，方便统一构建。并且继承 spring-boot-starter-parent ，其它子模块则继承该模块，方便统一管理 Spring Boot 及本项目的版本。这里已经把Spring Boot的版本升到 1.5.10.RELEASE。</p><p>View Code</p><p>sunny-starter 则引入了其余几个模块，在开发项目时，只需要继承或引入sunny-starter即可，而无需一个个引入各个模块。</p><p>View Code</p><p>对于一个Spring Boot项目，应该只有一个入口，即 @SpringBootApplication 注解的类。经测试，其它的模块的配置文件application.properties的配置不会生效，应该是引用了入口模块的配置文件。</p><p>所以为了让各个模块的配置文件都能生效，只需使用 @PropertySource 引入该配置文件即可，每个模块都如此。在主模块定义的配置会覆盖其它模块的配置。</p><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/70e87c9209e0405ab2d27e95b59702f8><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、开发规范</strong></h1><div class=pgc-img><img alt="基于Spring Boot搭建应用开发框架——基础架构" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/eb3f52f4e9c649918aaba36d64ee6f68><p class=pgc-img-caption></p></div><p></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Spring','Boot','应用'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>