<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SPL 的集合思维 | 极客快訊</title><meta property="og:title" content="SPL 的集合思维 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b0cab605feda44bbab62157c98769c56"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d461e468.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d461e468.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d461e468.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d461e468.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d461e468.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d461e468.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d461e468.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d461e468.html><meta property="article:published_time" content="2020-11-14T21:07:40+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:40+08:00"><meta name=Keywords content><meta name=description content="SPL 的集合思维"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d461e468.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SPL 的集合思维</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>和传统的程序设计语言不同，SPL中集合的应用非常普遍，实际上最常见的序列和序表等本质上都是集合，可以对它们进行真正的集合运算，从而大幅度提高开发效率和代码性能。因此，在使用SPL时，需要特别重视对集合概念的理解。</p><p><strong>1 SPL中的序列与集合</strong></p><p>SPL中，序列如同整数、字符串一样是非常常用的基本数据类型，也能进行相应的基本运算。从集合角度出发，SPL提供了两个集合A、B的交、并、联、差等基本运算符：A^B，A|B，A&B，A\B等。如果能够从这些运算开始深刻理解并熟练运用，解决问题时就能更主动地采用集合思维，从而充分利用已知的数据，思路更直接和简洁，方法也更加简易清晰。</p><p>下面的例子显示了如何利用集合运算来简化代码：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0cab605feda44bbab62157c98769c56><p class=pgc-img-caption></p></div><p>代码中，A4、A6、A8采用了集合运算，分别统计了California州的男员工、所有男性或者位于California州的员工、不在California州的男员工，形式上和A5、A7、A9的传统统计方式相比，明显简洁了很多。</p><p>但是，需要注意的是，A6与A7中虽然获得的员工资料一致，但结果中记录的顺序不同，如下所示：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d5c83a453ae443f8b95192eb4ccd331><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c9a485e8b67e4c34bf9bcd1934e4bd38><p class=pgc-img-caption></p></div><p>造成这种情况的原因是，与数学上的集合不完全相同，SPL中的集合称为有序集合，是有次序的，同时也可以有重复的成员。序列、序表、排列等全都是这种有序集合。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ff217e8e240b48779e5d8c7be3133fa1><p class=pgc-img-caption></p></div><p>上表中，A2中的序列有重复的成员，而A3中两个序列中成员顺序不同，直接比较时会认为它们不相等，结果为false：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/55d62f35ad064cbd8f496793ab2249af><p class=pgc-img-caption></p></div><p>另外，数学上集合的交并运算是可交换的，即A∩BºB∩A和A∪B º B∪A，但由于SPL中的集合是有序集合，因此交换律并不成立，交并运算的结果集合将以左操作数的次序为准。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1a337d4701aa4505bcef58dadfe4c6e0><p class=pgc-img-caption></p></div><p>A3,A4,A5和A6中的计算结果依次如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/114270062b1a462790196aa3761d2e67><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0cda15c286234df79eaa7f285cdc4fc7><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/83ced6554b5440f88f8bc6e1ef332db6><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e863df1ac0b4cb7bf2166e1f3c047c2><p class=pgc-img-caption></p></div><p>由于SPL中的序列是有序集合，因此判断两个序列是否有同样成员不能简单地用比较符==，而要用函数<strong>A</strong>.eq(<strong>B</strong>)：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3481e706619c44fba2359a6744f58970><p class=pgc-img-caption></p></div><p>A1与A2中判断两个序列是否相同，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/55d62f35ad064cbd8f496793ab2249af><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/624f9f53a9624cbbac541c3e438abd5f><p class=pgc-img-caption></p></div><p>这是因为A2中[3,2,1]执行sort函数排序后，得到的结果是[1,2,3]，次序也和A1一样了。</p><p>A3、A4、A5和A6分别都使用函数A.eq(B)来判断两个序列是否有着同样的成员，结果依次如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/624f9f53a9624cbbac541c3e438abd5f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/55d62f35ad064cbd8f496793ab2249af><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/624f9f53a9624cbbac541c3e438abd5f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/55d62f35ad064cbd8f496793ab2249af><p class=pgc-img-caption></p></div><p>如果两个序列中的所有成员全相同，则称这两个序列互为置换列。特别的，如果序列中出现了重复的成员，那么它的置换列中，这个成员也需要有同样的重复数量。</p><p><strong>2 循环函数</strong></p><p>有了集合数据类型，许多针对集合中成员的运算就可以方便地一句写出来，不再需要编写循环代码了。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/487307395a7143cb8e12e4cea5f475dc><p class=pgc-img-caption></p></div><p>上表用到了4个循环函数，A2中的sum()计算序列中成员的总和，A3中的avg()计算序列成员的平均值，A4中的max()和min()计算序列中最大值与最小值的差。它们的计算结果依次如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5373a47ca2404fb2beaf5acccb4175c2><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0c1268aacba34360b903ea2f6b0376a5><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/104e745a77434dacb0bcfbbac680ada1><p class=pgc-img-caption></p></div><p>循环函数计算时不仅可以使用集合成员本身的值，而且可以使用成员计算出来的值，包括成员值的计算结果，以及具有结构的集合成员的属性值。这时可以在函数的参数中指明计算式，其中用符号~表示循环计算中的当前成员。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b68d33019c2a4e58b5742f8149da9c91><p class=pgc-img-caption></p></div><p>上表中的A2计算序列中成员的平方和，即循环累加每个成员值的平方，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8011462e0e5749f280fac2b3f06122a5><p class=pgc-img-caption></p></div><p>而A4、A5和A6则对A3生成的集合中的每个成员的属性值进行循环计算。A3对员工信息序表进行查询后生成集合，其中每个成员是一个员工的信息。A4中计算员工最早的生日，即成员生日的最小值，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ad89df7cfef447bab38688a8f18997d2><p class=pgc-img-caption></p></div><p>A4表达式中的~.可以省略，写成A5的样子，因此计算结果与A4相同。</p><p>A6中计算所有员工平均入职年龄，即每个成员入职时间和生日时间的年份差的平均值，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/46474d5c106340dd846ad927fe99369d><p class=pgc-img-caption></p></div><p>执行带有参数的聚合函数可以被理解为如下两步：</p><p>1) 先根据参数表达式对集合中的每个成员进行计算，结果称为计算列</p><p>2) 再对计算列做聚合计算。</p><p>形式上可以表示为：A.f(x)=A.(x).f()，如A1.sum(~*~) 相当于A1.(~*~).sum()，其中A1.(~*~) 为计算列函数，即计算出A1中每个成员的平方，并返回为序列。</p><p>上面例子中A5、A6省略了符号~，这是因为只使用了一层循环函数，省略~不会引起歧义。如果嵌套使用循环函数，~将被解释为内层序列的成员，这时如果想引用外层序列成员，就必须在~前加上外层序列名。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/85e578636ea2437aa8626fc9dba2e9fe><p class=pgc-img-caption></p></div><p>这个例子中用到了字符串拼接运算/。A3中，在循环中用/拼接两个字母，但只用~就只能取到内层序列A2的成员，所以得到的字串只是两个重复的小写字母。而A4在循环时指明前一个~所对应的是外层序列，因此得到的是A1大写字母在前、A2小写字母在后拼接的结果。A5的表达式中，内层循环即便用了A1.~，但无法识别究竟是哪一层的A1，因此无法引用外层A1成员，所以计算时只能使用内层序列中的成员，因此得到的结果就是重复的大写字母。这种情况下，如果需要引用外层的成员，就需要采用A6的方法，先将外层成员值赋给临时变量，再通过临时变量引用，这样就可以得到大写字母交叉拼接的结果了。A3~A6中的计算结果依次如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ec5db1e3cc694439b7f952f2f878b262><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4129813b32a649ae8156eba1840c6b9c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5ad01d92356440bd859769bac7d8889e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dc211300982d4c2fae8136f23908fa6f><p class=pgc-img-caption></p></div><p>关于~的这个规则同样适用于序表或排列的循环计算，省略~的字段引用写法，字段将被优先解释为内层排列的字段，如果在内层排列找不到指定的属性字段才会再向外层找。</p><p><strong>3 循环次序</strong></p><p>简单地说，循环函数在计算时将按原序列的次序依次计算，而我们在使用时可以充分利用这一特点。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bdcfc8fa592442d79553b503b094e365><p class=pgc-img-caption></p></div><p>A3中，通过循环，计算出A1中成员累积和序列：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dc47683738e34801a7939c873cec3779><p class=pgc-img-caption></p></div><p>A6中，计算出序列A4中，成员0连续出现的最长个数：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a326a0776be45dd8a93a9171a84c5b4><p class=pgc-img-caption></p></div><p>类似的情况很多，我们可以只用一个表达式就写出等同于简单循环代码的效果。</p><p><strong>4 计算序列</strong></p><p>除了上面这些返回单个聚合值的循环函数（如sum, avg），很多情况我们还需要继续对集合进行计算，除了采用基本的集合并、交、差等运算能够生成一个新集合外，使用计算序列函数<strong>A</strong>.(<strong>x</strong>)返回一个集合，也是很常用的方法。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3f398728be484a5abfa2122fe2754afd><p class=pgc-img-caption></p></div><p>例子中的A2~A6根据序列A1计算，生成不同的新序列：A2计算每个成员的平方；A3与A4都是用原序列的成员生成新序列；A5循环生成和原序列数量相同的序列，但其中的成员都是1；A6略为复杂些，在循环计算对A1中的成员逐个判断，如果为奇数，则得到0，否则获得对应成员的值。A2~A6的计算结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4047e5b2294c40e7817039688f09824d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/98a7913c10554436835f3290b8faa3d9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/98a7913c10554436835f3290b8faa3d9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f0f302aaac8c489ea86f603f0a4f173f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0743d8292c2a4e709ef9d29bc0db7e98><p class=pgc-img-caption></p></div><p>A8的完整写法是=to(len(A7)).(mid(A7,~,1))，其中to(n)函数生成一个从1到n的数字组成的新序列（熟练后和前面的符号 ~ 一样，有些情况可以省略），对这个序列进行循环，逐个取出A7中的字符串，从而展开为单字符构成的序列；A9计算出其中字母o出现的次数。A8与A9中的结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90e1b72dc30b477eb7ee8a55a05c4a2b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49b595fc8d624ee6bd7312085a06b81f><p class=pgc-img-caption></p></div><p>除了返回序列，我们还可以对序列计算后返回序表，这时需要用new函数。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b7ec9630c8d942269717913dfc2725ea><p class=pgc-img-caption></p></div><p>A2根据A1循环计算返回新的序表，其中包含两个字段，一个是A1中的成员，另一个则是该成员的平方值。表达式中的 ~ 前面已经介绍过了，表示当前循环到的序列成员，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8ea2dfef70614937ad895260a7c3ca6d><p class=pgc-img-caption></p></div><p>A3从数据表EMPLOYEE中取出数据产生一个序表，A4从中获取NAME和BIRTHDAY两个字段，并根据BIRTHDAY计算出该职员的年龄，形成一个新字段Age，最终生成包含了NAME和Age两个字段的新序表。结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/778ac438bba64fd3839e8dfac2ced03e><p class=pgc-img-caption></p></div><p>A5和A6看上去类似，但实际上却有区别，A5从A3序表中取出NAME字段，然后直接生成包含了一个NAME字段的新序表；而A6则是根据A3中序表循环计算出由NAME字段构成的序列，两个结果的不同在于，序表有数据结构而序列无数据结构：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b8eb44039fa74687948d4b94e036b9dc><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c18285bbea5144bbbdc02ef524498849><p class=pgc-img-caption></p></div><p>另外，还有一个仅用于计算的run函数，它直接修改原序列本身，而不是对位计算后返回新的结果序列，一般用于针对排列（序表）修改字段值。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae0be35f2b6e47bba0dc88e72b82f819><p class=pgc-img-caption></p></div><p>例子中，A2中生成新序表，列出员工的名字并计算出他们的年龄。而在A3中针对新序表A2进行计算，将每位员工的年龄加1。run函数改变的是原序表A2中的数据，因此A2与A3中结果是相同的，将一同返回修改后的结果。使用分步执行可以看到A2中序表的变化：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b266edd3310a40ad8f8e7e3cabe93993><p class=pgc-img-caption></p></div><p><strong>5 不纯的集合</strong></p><p>SPL不要求序列成员的数据类型一致，因此完全可以把数值、字串以及复杂的记录作为同一个序列的成员。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3d82be8c012f48edb13dc545f3a6a833><p class=pgc-img-caption></p></div><p>A1中包含多种数据类型的成员，而A2中的序列是由序列A1与整数成员构成的，A1与A2中的数据如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/071aebfe7de74d419085ca1a27aa9da3><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3cf01e1cf5524a7799b8edb5930f5768><p class=pgc-img-caption></p></div><p>不过，对于一般的序列，在大多数情况下，将不同类型的数据置于同一序列中并没有多少实际的业务意义，因此不必过于关注。</p><p>但是，对于排列，即以记录构成的序列，允许由来自不同序表的记录构成，这一点会有实实在在的方便性。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/edd25b6fa28844eeb3b25dfaac9cf939><p class=pgc-img-caption></p></div><p>A4计算员工和家属中，女性一共有多少人。即使员工表和家属表结构不同，但只要其中都包含GENDER字段，就可以正常计算。</p><p>从这个例子可以看出，SPL并不关心排列中的记录是否来自同一序表，只要它们有名称相同的字段就可以对其执行一致的操作，而不必象SQL那样必须将两个不同结构的表先用UNION语句联合成一个新表才能操作。这样不仅思路清楚、书写简单，而且不会占用多余的内存，同时运算效率更高。</p><p><strong>6 集合的集合</strong></p><p>特别地，集合成员的任意性还允许集合本身作为成员。同时，当A是集合的集合时，还可以进一步使用<strong>A</strong>.conj()，<strong>A</strong>.union()，<strong>A</strong>.diff()，<strong>A</strong>.isect()这些函数，计算A中各个集合的和列、并列、差列和交列。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ffc6ca23b4a247d589d6c79e64876929><p class=pgc-img-caption></p></div><p>A1中是一个序列构成的序列。A2,A3,A4和A5分别计算A1中序列成员的和序列、交集序列、各个序列求和的结果以及各个系列每个成员的平方构成的序列。计算后，A2~A5中的结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/49611842f2a64b3c8538f999135e7ef3><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bf11948f178e442b95cf910a30a54657><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e7c5b1afe4f44a795196725f53c3979><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/10932ee418f44952ab0a75dc23e3a2da><p class=pgc-img-caption></p></div><p>类似的，排列也可以作为序列的成员。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d8a896053a1e4d45aa5a4ae5efa5f6a4><p class=pgc-img-caption></p></div><p>A2,A3与A4中分别取出California,Indiana和Florida这3个州的员工数据。A5中获得的就是由A2~A4这3个排列构成的序列，是个集合的集合：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f07069384ba44b4fa94d096d1c24b53c><p class=pgc-img-caption></p></div><p>A6分别计算各州员工数，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f1976b3dee148428395c53307f3052e><p class=pgc-img-caption></p></div><p>A7中取出各个州的名称，表达式中的~(1)是可以省略的，也就是说A8与A7是等价的，结果也一样：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e45b8f441b4f4db7a92b93d2e61d0a91><p class=pgc-img-caption></p></div><p>A9效果看上去和A6一样，也是统计3个州的员工数，但通过new生成了一个新的序表，看上去更加清晰，也方便以后根据州名检索使用：：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2d7b538165c34ec0a909fd8059b50cc5><p class=pgc-img-caption></p></div><p><strong>7 理解分组</strong></p><p>分组是SQL中很常用的运算，但未必所有人都能深刻理解它。</p><p>从集合的角度看，分组运算的实质是将一个集合按某种规则拆分成若干子集，也就是说，其返回值应当是若干个集合构成的集合。只不过人们经常不需要直接察看集合中的这些子集，而是对子集的某些汇总值更感兴趣，因此，分组常常伴随着对子集的进一步汇总计算。</p><p>SQL正是这样处理的，它的GROUP BY语句总是配合相应的汇总计算。当然，这也是因为SQL自身没有显式的集合数据类型，所以无法直接返回“集合的集合”这类数据，只能把汇总计算强加到分组计算之后。</p><p>久而久之，人们习惯了分组总是需要配合后续的汇总计算，而忘记了分组和汇总其实是两个独立的步骤。</p><p>但是无论如何，我们仍然会有对这些分组子集感兴趣的时候。而且退一步讲，即使只对汇总值有兴趣，保持住这些子集也有价值，因为如果可以重复利用，不必每次都重新生成，那么无论在代码的简洁还是性能的提升方面都会有很大的帮助。</p><p>而对于SPL来说，因为它充分实现了集合思维，所以就能够做到还原分组运算的本意。事实上，SPL中的基本分组函数就是只做纯粹的分组，而把汇总计算剥离出去了。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a4a30f673e044af9378fc639af189f4><p class=pgc-img-caption></p></div><p>分组的结果本身是一个集合的集合，因此当然还可以继续分组。而分组结果集合中的各个成员也是集合，各自也能够再继续分组。这是两种不同的操作，但都会形成多层集合。</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c0980cdff432434f953c9ca67dbbac6e><p class=pgc-img-caption></p></div><p>如果集合运算结果的层次太深，那么现实的业务含义可能不是很大，但可以用来体会集合的思维方式及运算的实质。</p><p>在分组的同时，group函数会同时将各个组按照分组表达式的结果排序，如：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dfca59f1557b4a8388b27acdfec1545b><p class=pgc-img-caption></p></div><p>A1中得到的序表如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0de605d1099444278f4eed5a137c0b0a><p class=pgc-img-caption></p></div><p>A2中按部门名称将员工数据分组，默认情况下，A2中的分组结果就会按照部门名称升序排序。在B列中统计了各种分组情况下各部门的人数，以便通过DEPT列直接查看排序情况。A2和B2中结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0ba5bdd56e684265a5ea0484dc7bdacd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7352a0b4765541b3877925a09e62d1cd><p class=pgc-img-caption></p></div><p>A3将A2中的分组结果改为按照部门降序排序，效果可以在B3中看到，结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c6de629ee51a4ab3b13ad635f77f480b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c11a538f35ef48da93ca7ed4c3a6103d><p class=pgc-img-caption></p></div><p>除了将分组结果重新排序，还可以在执行group时添加选项来调整分组顺序。</p><p>A4中添加通过@u选项在分组时保持各部门在员工表中出现的原始顺序。</p><p>A5中添加的@o选项指定分组时不对记录做整体排序，而只会将分组表达式相等的相邻记录分为一组，因此更像是“相邻合并”。显然，这种情况可能会出现的“重复”分组。B4和B5显示了这两种情况的效果：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7db6737f6864e5ea0e03bfe00058d32><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/01329531037a4f168cbe88a918427076><p class=pgc-img-caption></p></div><p><strong>8 非等值分组</strong></p><p>除了常规的group函数，SPL还提供了处理对齐分组的<strong>A</strong>.align@a()函数和处理枚举分组的<strong>A</strong>.enum()函数。</p><p>我们称通过group函数完成的分组为等值分组，它具有这样的特点：</p><p>1) 原集合中任何成员都必须在且只能在某一个子集中，也就是分组后的子集成员完全覆盖原集合，并且子集之间没有重叠；</p><p>2) 没有空子集</p><p>而对齐分组和枚举分组则不一定满足这两点。</p><p>对齐分组是指，用集合中成员计算分组表达式，根据计算结果与事先指定的一个序列中的值一一对应，完成分组。对齐分组需要如下几步：</p><p>1) 事先指定一组值</p><p>2) 将待分组集合中某个表达式计算结果和指定值相同的成员划分到同一个子集</p><p>3) 结果的每个子集将和事先指定的值一一对应。</p><p>在这种分组规则下，可能有某个成员不在任何一个子集中，也可能出现空集，或者某成员在两个子集中都存在。</p><p>如下面的例子，将员工按指定的州序列分组：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8197205a244342dbb3f0b51e6d659700><p class=pgc-img-caption></p></div><p>在A3中，将集合A1根据A2对齐分组，将A1成员的州名称与A2的成员做对应。在这样的分组过程中，有可能有些员工不在任何一个分组中（其他州的员工），也有可能出现没有任何成员的空组（Chicago不是州名称，根本没有对应的员工）。例如，在某种数据情况下，A3结果：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e923171ad55847a1b8ab8103909a1f33><p class=pgc-img-caption></p></div><p>枚举分组是指，事先指定一组条件，将待分组集合中成员作为参数计算该条件，条件成立者将被划分到对应的子集。这时也可能有某个成员不在任何一个子集中，以及出现空集，还可能有成员同时在两个子集中。</p><p>如下面的例子，将员工按照指定的年龄段分组：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6daec3b0e6144bad87438f355d0c0a11><p class=pgc-img-caption></p></div><p>A3中，根据A2中的年龄条件序列进行枚举分组。enum()函数不指定选项时，不允许分组结果出现重复，也就是说A1中某个员工的记录可以不在任何分组中（不过例子中的条件是全覆盖的），但是不会同时出现在两个分组中（也就是不会重叠）。A3结果如下：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b38408e6525142809e983f1599e5d128><p class=pgc-img-caption></p></div><p>此时，某个年轻的（35岁以下）员工会被分配到第1个分组中。而由于不允许重叠，因此即便他也满足第二个条件，45岁以下，仍不会再被重复分配到第2组中。</p><p>A5也是根据A4中的条件序列进行枚举分组，不过这里使用enum函数时添加了@r选项，表示分组时可重复。此时，某个员工的记录有可能同时出现在多个分组中了。例如：</p><div class=pgc-img><img alt="SPL 的集合思维" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/af1c584dff1a4688933f29976146aef5><p class=pgc-img-caption></p></div><p>可以看到，某些员工记录会同时存在于前两个分组中。</p><p>align@a函数和enum函数虽然看起来和group函数相差很大，不过在理解了分组运算的本质后，就能明白它们其实都是在做同一件事：即把一个集合拆分成若干个子集，所不同的只是拆分的具体条件和规则不同罢了。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'SPL','思维','集合'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>