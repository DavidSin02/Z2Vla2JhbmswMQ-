<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Android绘制函数图象及正弦函数的介绍 | 极客快訊</title><meta property="og:title" content="Android绘制函数图象及正弦函数的介绍 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/14098a102e71458db6459ef6dc5ddaec"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d512692b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d512692b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d512692b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d512692b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d512692b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d512692b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d512692b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d512692b.html><meta property="article:published_time" content="2020-10-29T21:08:51+08:00"><meta property="article:modified_time" content="2020-10-29T21:08:51+08:00"><meta name=Keywords content><meta name=description content="Android绘制函数图象及正弦函数的介绍"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d512692b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Android绘制函数图象及正弦函数的介绍</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>零、前言</p><blockquote><p>这篇是为了下一篇做点铺垫，也是来复习一些数学基础，本篇属于休闲娱乐，不要太较真，小科普一下，不喜勿喷。本文知识点前 4 点你可以随便看看，但 第5点非常重要,本文源码见 捷文规范</p><p>本文知识点：</p></blockquote><ul><li>数学函数的概念</li><li>直角座标系的下函数图形</li><li>极座标下的函数图象</li><li>参数方程下的函数图形</li><li>正弦函数的详细分析(为下一篇文章做铺垫)</li></ul><p>一、数学函数的概念：</p><p>1.高中数学必修1：</p><pre>设A,B为非空的数集，如果按照某种确定的对应关系f, 使对于集合A中的任意的任意一个数x,在集合B中都有唯一确定的数f(x)和它对应，那么就称"f:A→B"为从集合A到集合B的一个函数，记作：y=f(x),x∈A其中，x叫做自变量，x的取值范围叫做函数的[定义域]与x的值对应的y值叫做函数值，函数值的集合{f(x)|x∈A}叫做函数的[值域]</pre><hr><p>2.大学高等数学</p><pre>设数集D⊂ R,则称映射f:D→R为定义在D上的函数，通常简记为y=f(x),x∈ D其中x称自变量，y称因变量，D称定义域，记作Df,即Df=D.值域：Rf=f(D)={y|y=f(x),x∈ D}</pre><hr><p>3.映射：</p><pre>设X,Y是两个非集合，如果存在一个法则f，使的对X中的每个元素x,按法则f,在Y中有唯一确定的元素y与之对应，则称f为X到Y的映射，记作f:X→Y其中y称为元素x(在映射f下)的像，并记作f(x),即y=f(x)而元素x称为元素y(在映射f下)的原像</pre><hr><p>二、直角座标系的下函数图形</p><blockquote><p>这里只是模拟函数，然后绘制出可视的图象</p><p>数学中的实数是连续的，这里在屏幕中将像素作为基本的单元</p><p>绘图核心：点集成线，单点半径1px</p><p>自变量：x</p><p>定义域：Df用集合Set表示</p><p>函数关系：函数f(x)</p><p>点集用Map表示，x→y</p></blockquote><hr><p>0.网格与座标系的绘制</p><blockquote><p>网格和座标系我已经封装，初始View如下：</p></blockquote><pre>public class MathView extends View { private Point mCoo = new Point(500, 700);//座标系 private Picture mCooPicture;//座标系canvas元件 private Picture mGridPicture;//网格canvas元件 private Paint mHelpPint;//辅助画笔 private Paint mPaint;//主画笔 private Path mPath;//主路径 public MathView(Context context) { this(context, null); } public MathView(Context context, @Nullable AttributeSet attrs) { super(context, attrs); init();//初始化 } private void init() { //初始化主画笔 mPaint = new Paint(Paint.ANTI_ALIAS_FLAG); mPaint.setColor(Color.BLUE); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.STROKE); mPaint.setStrokeCap(Paint.Cap.ROUND); //初始化主路径 mPath = new Path(); //初始化辅助 mHelpPint = HelpDraw.getHelpPint(Color.RED); mCooPicture = HelpDraw.getCoo(getContext(), mCoo); mGridPicture = HelpDraw.getGrid(getContext()); } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); HelpDraw.draw(canvas, mGridPicture, mCooPicture); canvas.save(); canvas.translate(mCoo.x, mCoo.y); canvas.scale(1, -1);//y轴向上 canvas.restore(); }</pre><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/14098a102e71458db6459ef6dc5ddaec><p class=pgc-img-caption></p></div><blockquote><p>具体细节这里不说了，详见：Android关于Canvas你所知道的和不知道的一切,或源码</p></blockquote><hr><p>1.一次函数：y=x,定义域[-200,300]</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/62e2e2ebff674f63a86ba54c54a60e57><p class=pgc-img-caption></p></div><hr><p>1.1：几个成员变量</p><pre>private TreeSet&lt;Float&gt; Df = new TreeSet&lt;&gt;();//定义域private Map&lt;Float, Float&gt; funMap = new HashMap&lt;&gt;();//映射表private Paint mTextPaint;//文字画笔</pre><hr><p>1.2:初始化定义域</p><pre>/** * 初始化定义域 */private void initDf() { for (float i = -200; i &lt;= 300; i++) { Df.add(i);//初始化定义域 }}</pre><hr><p>1.3：对应法则fx</p><pre>/** * 对应法则 * @param x 原像(自变量) * @return 像(因变量) */private float f(Float x) { float y = x; return y;}</pre><hr><p>1.4:遍历定义域,将原像x和像f(x)加入映射表</p><pre>/** * 遍历定义域,将原像x和像f(x)加入映射表 */private void map() { Df.forEach(x -&gt; { funMap.put(x, f(x)); }); //添加所有点}</pre><hr><p>1.5:绘制映射表</p><pre>/** * 绘制映射表 * @param canvas 画笔 * @param map 点集映射表 */private void drawMap(Canvas canvas, Map&lt;Float, Float&gt; map) { map.forEach((k, v) -&gt; { canvas.drawPoint(k, v, mPaint); });}</pre><hr><p>2.绝对值函数：y=|x|,定义域[-200,300]</p><blockquote><p>只需改一点</p></blockquote><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cae348516fdc4faf8c4932db2e47198c><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * @param x 原像(自变量) * @return 像(因变量) */private float f(Float x) { float y=Math.abs(x); return y;}</pre><hr><p>3.二次函数,定义域[-200,300]</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d5287d4414724d9a98b97b6188a97c5c><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * @param x 原像(自变量) * @return 像(因变量) */private float f(Float x) { float y=(x - 100) * (x - 100) / 200 + 100; return y;}</pre><hr><p>4.对数函数：log10(x)为例,定义域[1,1000]</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ecd82b05d4245898108011291d8d932><p class=pgc-img-caption></p></div><pre>/** * 初始化定义域 */private void initDf() { for (float i = 1; i &lt;= 1000; i++) { Df.add(i);//初始化定义域 }}/** * 对应法则 * * @param x 原像(自变量) * @return 像(因变量) */private float f(Float x) { float y = (float) (100.f * Math.log10(x)); return y;}</pre><hr><p>5.指数函数：定义域[-400,500]</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1e9542e2349c4f81887d8cc127d928c4><p class=pgc-img-caption></p></div><pre>/** * 初始化定义域 */private void initDf() { for (float i = -400; i &lt;= 500; i++) { Df.add(i);//初始化定义域 }}/** * 对应法则 * * @param x 原像(自变量) * @return 像(因变量) */private float f(Float x) { float y= 100*(float) Math.pow(Math.E,x/300f); return y;}</pre><hr><p>6.正弦函数：定义域[-360°,450°]</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/73490ec9b0434961a392a29f90785a53><p class=pgc-img-caption></p></div><pre>/** * 初始化定义域 */private void initDf() { for (float i =-360; i &lt;= 450; i++) { Df.add(i);//初始化定义域 }}/** * 对应法则 * * @param x 原像(自变量) * @return 像(因变量) */private float f(Float x) { float y= (float) (100*Math.sin(Math.PI/180*x)); return y;}</pre><blockquote><p>经历过上面几个函数的绘制，不难发现，只有更改对应法则，即函数关系式就可以了</p></blockquote><hr><p>三、极座标下的函数图象</p><blockquote><p>1).寻找角度thta和长度p的函数关系</p><p>2).使用极座标与直角座标系的转换关系来绘制点集</p></blockquote><hr><p>1.笛卡尔心型线： ρ=100*(1-cosθ)</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4f9fb154ff924b4d97e503bd78eae76a><p class=pgc-img-caption></p></div><pre>/** * 初始化定义域 */private void initDf() { for (float i = 1; i &lt;= 360; i++) { Df.add(i);//初始化定义域 }}/** * 绘制映射表 * * @param canvas 画笔 * @param map 点集映射表 */private void drawMap(Canvas canvas, Map&lt;Float, Float&gt; map) { map.forEach((thta, p) -&gt; { Log.e(TAG, "drawMap: "+p+thta); canvas.drawPoint((float) (p * Math.cos(thta)), (float) (p * Math.sin(thta)), mPaint); });}/** * 对应法则 * * @param thta 原像(自变量) * @return 像(因变量) */private float f(Float thta) { float p = (float) (100 * (1 - Math.cos(thta))); return p;}/** * 遍历定义域,将原像x和像f(x)加入映射表 */private void map() { Df.forEach(x -&gt; { float thta = (float) (Math.PI / 180 * x); funMap.put(thta, f(thta)); }); //添加所有点}</pre><hr><p>2.四叶草： ρ=100*(1-4*sinθ)</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ec8b23ecedd484b833fd6996cb6aec4><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * * @param thta 原像(自变量) * @return 像(因变量) */private float f(Float thta) { float p = (float) (100 * (1 - Math.sin(4 * thta))); return p;}</pre><hr><p>3.画着玩： ρ=(e^(cosθ)-2cos(4θ)+[sin(θ/12)]^5)*100</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/64e740dcc2c64304bd3b46a60b478787><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * * @param thta 原像(自变量) * @return 像(因变量) */private float f(Float thta) { float p = (float) (100f*(Math.pow(Math.E,Math.cos(thta)) - 2 * Math.cos(4 * thta) + Math.pow(Math.sin(thta / 12), 5)));; return p;}</pre><hr><p>4.涡旋线： ρ=a*θ</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c48d2210534e4c3db5f42a403e949337><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * * @param thta 原像(自变量) * @return 像(因变量) */private float f(Float thta) { float p = 30*thta; return p;}</pre><hr><p>5.极座标下的圆</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a962b8d0bf804781bbb4f512419a0c88><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * * @param thta 原像(自变量) * @return 像(因变量) */private float f(Float thta) { float p = 200; return p;}</pre><hr><p>四、参数方程下的函数图象</p><p>1.双曲线： x=a/cosα, y=btanα</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4fd4c81e75fb49d2a15251de83991e27><p class=pgc-img-caption></p></div><pre> /** * 初始化定义域 */ private void initDf() { for (float i = 0; i &lt;= 360 ; i++) { Df.add(i);//初始化定义域 } } /** * 绘制映射表 * * @param canvas 画笔 * @param map 点集映射表 */ private void drawMap(Canvas canvas, Map&lt;Float, Float&gt; map) { map.forEach((k, v) -&gt; { canvas.drawPoint(k, v, mPaint); }); } /** * 对应法则 * * @param thta 原像(自变量) * @return y像(因变量) */ private float y(Float thta) { float y = (float) (100 * Math.tan(thta)); return y; } /** * 对应法则 * * @param thta 原像(自变量) * @return x像(因变量) */ private float x(Float thta) { float x = (float) (200 / Math.cos(thta)); return x; } /** * 遍历定义域,将原像x和像f(x)加入映射表 */ private void map() { Df.forEach(x -&gt; { float thta = (float) (Math.PI / 180 * x); funMap.put(x(thta), y(thta)); }); //添加所有点 }</pre><hr><p>2.椭圆： x=a*cosα, y=bsinα</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ecb400adae5a47f9a57dc9d8c92e88f0><p class=pgc-img-caption></p></div><pre>/** * 对应法则 * * @param thta 原像(自变量) * @return y像(因变量) */private float y(Float thta) { float y = (float) (300 * Math.sin(thta)); return y;}/** * 对应法则 * * @param thta 原像(自变量) * @return x像(因变量) */private float x(Float thta) { float x = (float) (400 * Math.cos(thta)); return x;}</pre><hr><p>3.参数方程:双钮线 x=a√(cos2θ)cosθ, y=a√(cos2θ)sinθ</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5a9d8f8341504700a211a4f3a8d43595><p class=pgc-img-caption></p></div><pre>/** * 对应法则:y=a√(cos2θ)sinθ * * @param thta 原像(自变量) * @return y像(因变量) */private float y(Float thta) { float y = (float) (200 * Math.sqrt(Math.cos(2*thta))*Math.sin(thta)); return y;}/** * 对应法则:x=a√(cos2θ )cosθ * * @param thta 原像(自变量) * @return x像(因变量) */private float x(Float thta) { float x = (float) (200 * Math.sqrt(Math.cos(2*thta))*Math.cos(thta)); return x;}</pre><hr><p>五、分析与优化</p><p>1.分析</p><blockquote><p>你可能已经吐槽了:什么鬼，怎么后面都是断断续续的点拼成的</p><p>等等...先别急，我们来看看这幅图能说明什么?</p><p>先看一下定义域: [-360,450]，共810个点，每个点半径1px，每个点横向距离1px</p><p>点密集则说明相邻两点间的dy很小，相反，稀疏则说明相邻两点间的dy很大</p><p>也就是密集说明函数变化的幅度小，稀疏说明函数变化的幅度大</p><p>当相邻两点距离大于圆的直径（2px）时，视觉上会看出两个点，即不连续。</p></blockquote><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f90565732734060924a0c0af5370c4c><p class=pgc-img-caption></p></div><hr><p>2.分析总结</p><blockquote><p>为了方便描述，这里定义了几个概念</p></blockquote><pre>如果把一条完美的函数曲线看作P，那所有现实中(纸、屏幕)的函数图象P'都是对P的取点模拟，从P上取点的行为称为[取样]，采样的个数称为[取样总数]，取样的相邻两点xn,xn+1间的距离称为[取样距离dxn]当每个dxn值都相等的时，称为[等距采样]两个样本点pn,pn+1之间的距离称为[样本距离dpn]</pre><hr><p>3.看一下连续的点有哪些</p><blockquote><p>在加入点集时过滤掉相邻两点间距离大于直径的点</p></blockquote><pre>/** * 两点间的距离 * @return */private float dis(float x0, float y0, float x1, float y1) { return (float) Math.sqrt((x0 - x1) * (x0 - x1) + (y0 - y1) * (y0 - y1));}/** * 遍历定义域,将原像x和像f(x)加入映射表 */private void map() { Df.forEach(x -&gt; { float dis = dis(x, f(x), x + 1, f(x + 1));//每相邻两点间距离 if (dis &lt; mLineWidth &amp;&amp; dis &gt; mLineWidth / 2) { funMap.put(x, f(x)); } });</pre><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c8be34f35fb4e82b9d3aa132c33027f><p class=pgc-img-caption></p></div><hr><p>4.不行连续的点处理思路：</p><blockquote><p>思路也就是在间距处再取样</p></blockquote><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37ee78cfe72b427697145657b24da68c><p class=pgc-img-caption></p></div><pre>/** * 遍历定义域,将原像x和像f(x)加入映射表 */private void map() { Df.forEach(x -&gt; { float dis = dis(x, f(x), x + 1, f(x + 1));//每相邻两点间距离 if (dis &lt; mLineWidth &amp;&amp; dis &gt; mLineWidth / 2) { funMap.put(x, f(x)); } else if (dis &gt; mLineWidth) { float num = dis / mLineWidth;//在切割数 for (float di = 0; di &lt;= num; di += (1.f / num)) { x += di; funMap.put(x, f(x)); } } }); //添加所有点}</pre><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f38c57efeca34246ab0b0e486cec3277><p class=pgc-img-caption></p></div><hr><p>六、正弦函数的详细分析</p><p>1.正弦函数简介</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4183691cfaab4bd6b951222340ad9572><p class=pgc-img-caption></p></div><pre>其中A，ω，φ，k是常数，且ω≠0振幅:A角频率:ω周期:T=2π/ω 频率:f=1/T=ω/2π相位:ωx+φ初相:φ平衡线：y=k波峰：最大值|A|波谷：最小值-|A|</pre><hr><p>2.振幅A: 离开平衡位置的最大距离</p><blockquote><p>下面横轴的每格代表90°,化为弧度制表示即：π/2,每四格是360°,即2π</p></blockquote><p>2.1： A=300</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcd88a8cfdb040bd829c2d62d74b7122><p class=pgc-img-caption></p></div><hr><p>2.2： A=100</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a69c6ef71acf4b438b8d9930b110c88f><p class=pgc-img-caption></p></div><hr><p>2.3:振幅的作用</p><pre>决定正弦曲线的波峰与波谷，形象来说就是"高矮" 振幅越大，波峰越高，波谷越低，每个周期的图象显得"高"</pre><hr><p>3.角频率ω: 单位时间内变化的相角弧度值</p><p>3.1： ω=2</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c44817fc51d442a9fb4356d94eb44a2><p class=pgc-img-caption></p></div><hr><p>3.2： ω=5</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c8d95829fb2446ec8c3624b522843215><p class=pgc-img-caption></p></div><hr><p>3.3：角频率的作用</p><pre>决定正弦曲线的周期，形象来说就是"胖瘦" 角频率越大，周期越小，每个周期的图象显得"瘦"ω=2 周期：T = 2π/ω = π 从图中看，每两格一周期,即π 频率：f = 1/T = 1/π</pre><hr><p>4.初相φ： x=0时的相位</p><p>4.1: φ=π/6</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/558c72ddd01644d5a5a7f891cee19401><p class=pgc-img-caption></p></div><hr><p>4.2: φ=π/2</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e8e02e7494c6459ba209a13bdd5dec55><p class=pgc-img-caption></p></div><hr><p>4.3:振幅的作用</p><pre>相位决定了标准正弦函数的左右偏移:正左偏，负右偏，偏移量：φ/ω</pre><hr><p>5.平衡值k： 决定平衡线的位置</p><p>5.1: k=100</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a3445fa8b91c413fb4329b594d830131><p class=pgc-img-caption></p></div><hr><p>5.2: k=200</p><div class=pgc-img><img alt=Android绘制函数图象及正弦函数的介绍 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74e944a384344807988e8e1a484496a2><p class=pgc-img-caption></p></div><p>5.3:平衡值的作用</p><pre>平衡值决定标准正弦函数的上下偏移：正上偏，负下偏，偏移量：k</pre><blockquote><p>现在对于几个正弦函数的参数值已经有了一点了解,本篇结束</p></blockquote><hr><p>附录：一些常用符号：</p><p>←↑→↓∪∩⊂⊃∈∝⊆⊇∞θρφπαβγημζΩ</p><p>后记：捷文规范</p><p>1.本文成长记录及勘误表</p><p>项目源码日期备注V0.1-github2018-1-2Android绘制函数图象及正弦函数的介绍</p><p>2.更多关于我</p><p>笔名QQ微信爱好张风捷特烈1981462002zdl1994328语言我的github我的简书我的掘金个人网站</p><p>3.声明</p><blockquote><p>1----本文由张风捷特烈原创,转载请注明</p><p>2----欢迎广大编程爱好者共同交流</p><p>3----个人能力有限，如有不正之处欢迎大家批评指证，必定虚心改正</p><p>4----看到这里，我在此感谢你的喜欢与支持</p></blockquote><hr><hr></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Android','函数','介绍'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>