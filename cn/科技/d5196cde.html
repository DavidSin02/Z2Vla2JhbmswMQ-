<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Bash技巧：介绍重定向输入输出等十种重定向操作符的用法 | 极客快訊</title><meta property="og:title" content="Bash技巧：介绍重定向输入输出等十种重定向操作符的用法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/b97eed16-d976-4a57-8da4-a79915edd56a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d5196cde.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5196cde.html><meta property="article:published_time" content="2020-10-29T21:09:47+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:47+08:00"><meta name=Keywords content><meta name=description content="Bash技巧：介绍重定向输入输出等十种重定向操作符的用法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d5196cde.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Bash技巧：介绍重定向输入输出等十种重定向操作符的用法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Bash技巧：介绍重定向输入输出等十种重定向操作符的用法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/b97eed16-d976-4a57-8da4-a79915edd56a><p class=pgc-img-caption></p></div><p>在 Linux bash shell 中，执行一个命令之前，可以使用重定向操作符对该命令的输入、输出进行重定向，从其他文件获取输入，把命令输出写到其他文件。<br>具体说明可以查看 man bash 的 REDIRECTION 小节。下面举例说明十种重定向操作符的具体用法。</p><h1 class=pgc-h-arrow-right>重定向的概念</h1><p>在 REDIRECTION 小节对重定向概念说明如下：</p><blockquote class=pgc-blockquote-abstract><p>Before a command is executed, its input and output may be redirected using a special notation interpreted by the shell.</p><p><br>Redirection allows commands' file handles to be duplicated, opened, closed, made to refer to different files, and can change the files the command reads from and writes to.</p><p><br></p><p>If the file descriptor number is omitted, and the first character of the redirection operator is &lt;, the redirection refers to the standard input (file descriptor 0).</p><p><br>If the first character of the redirection operator is >, the redirection refers to the standard output (file descriptor 1).</p><p><br></p><p>Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.</p></blockquote><p><strong>即，在执行一个命令之前，可以使用重定向操作符对该命令的输入、输出进行重定向。<br>从其他文件获取输入，把命令输出写到其他文件。</strong></p><p>在 Linux 中，打开文件后，会得到一个文件描述符（file descriptor）。<br>文件描述符的有效值是大于或等于 0 的整数，可以使用这个整数值来读写对应的文件。</p><p><strong>重定向可以修改文件描述符对应的文件，从而在读写同一个文件描述符时，可以读写到其他文件。</strong></p><p>重定向输入会把指定的文件描述符关联到以读模式打开的文件。<br>那么读取指定文件描述符，就会读取文件内容。</p><p>重定向输出会把指定的文件描述符关联到以写模式打开的文件。<br>那么写入内容到指定文件描述符，就会写入文件。</p><p>即，重定向前后会关联两个文件。<br>在重定向之前，指定的文件描述符对应一个已经打开的文件。<br>重定向之后，该文件描述符会对应另一个文件、或者对应另一个文件描述符。<br>而另一个文件描述符也是对应另一个已经打开的文件。</p><p>当下面文件名用于重定向时，bash 会进行特殊处理：</p><ul><li><strong>/dev/fd/fd</strong>：如果 fd 是一个已经打开的文件描述符整数值，则 /dev/fd/fd 文件会复制到文件描述符 fd</li><li><strong>/dev/stdin</strong>：复制到文件描述符 0，也可以写为 /dev/fd/0。文件描述符 0 一般对应标准输入</li><li><strong>/dev/stdout</strong>：复制到文件描述符 1，也可以写为 /dev/fd/1。文件描述符 1 一般对应标准输入</li><li><strong>/dev/stderr</strong>：复制到文件描述符 2，也可以写为 /dev/fd/2。文件描述符 2 一般对应标准错误输出</li></ul><p>基于上面说明，可以使用 /dev/fd/5 来复制到文件描述符 5。<br>文件描述符 5 必须对应一个打开的文件，否则会报错。<br>也就是要有某个已打开文件的文件描述符是 5，/dev/fd/5 才能复制到文件描述符 5。</p><p>当使用大于 9 的文件描述符时，要特别小心。<br>shell 自身可能也使用了某个大于 9 的文件描述符，会导致冲突。</p><h1 class=pgc-h-arrow-right>重定向的先后顺序</h1><p>在使用重定向，要注意重定向的先后顺序，这是很重要的点，REDIRECTION 小节的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>Redirections are processed in the order they appear, from left to right.<br>Note that the order of redirection is significant. For example, the command</p></blockquote><pre><code>    ls &gt; dirlist 2&gt;&amp;1</code></pre><blockquote class=pgc-blockquote-abstract><p>directs both standard output and standard error to the file dirlist, while the command</p></blockquote><pre><code>    ls 2&gt;&amp;1 &gt; dirlist</code></pre><blockquote class=pgc-blockquote-abstract><p>directs only the standard output to file dirlist, because the standard error was duplicated from the standard output before the standard output was redirected to dirlist.</p></blockquote><p>即，当指定了多个重定向操作时，按照重定向出现的顺序，从左到右处理。</p><p>对 <strong class=highlight-text>ls > dirlist 2>&1</strong> 命令来说，第一个 <strong class=highlight-text>></strong> 表示重定向 ls 命令的标准输出到 dirlist 文件。<br>第二个 <strong class=highlight-text>2>&1 </strong>表示复制标准错误输出到标准输出。<br>由于标准输出已经被重定向到 dirlist 文件，所以 dirlist 文件会包含 ls 命令的标准输出和标准错误输出。</p><p>而 <strong class=highlight-text>ls 2>&1 > dirlist</strong> 命令只重定向标准输出到 dirlist 文件，标准错误输出只会打印到终端。具体说明如下：</p><ul><li>第一个 <strong>2>&1 </strong>表示复制标准错误输出的文件描述符 2 到标准输出的文件描述符 1。<br>实际上是把标准错误输出写入到标准输出对应的文件。<br>此时标准输出还没有重定向，会关联到终端，所以标准错误输出会写入到终端。</li><li>第二个 <strong>></strong> 表示把标准输出重定向到 dirlist 文件，会把文件描述符 1 指向 dirlist 文件。<br>这不会影响文件描述符 2，标准错误输出的文件描述符 2 还是指向终端。<br>所以， 标准错误输出没有重定向到 dirlist 文件。</li></ul><p>具体举例测试如下：</p><blockquote class=pgc-blockquote-abstract><p>$ ls not_exist 2>&1 > dirlist</p><p>ls: cannot access not_exist: No such file or directory</p><p>$ ls not_exist > dirlist 2>&1</p><p>$ cat dirlist</p><p>ls: cannot access not_exist: No such file or directory</p></blockquote><p>在当前目录下，没有 not_exist 文件。那么 ls not_exist 会报错，提示找不到该文件。</p><p>如前面说明，<strong class=highlight-text>ls not_exist 2>&1 > dirlist</strong> 命令不能把标准错误输出重定向到 dirlist 文件，所以报错信息直接打印在终端上。</p><p><strong class=highlight-text>ls not_exist > dirlist 2>&1 </strong>命令可以把标准错误输出重定向到 dirlist 文件，终端上没有看到报错信息。<br>用 cat dirlist 命令输出 dirlist 文件内容，可以看到报错信息写入到了该文件。</p><h1 class=pgc-h-arrow-right>使用 exec 命令对当前 shell 进行重定向</h1><p>在 bash 中执行命令，会启动子 shell 来执行。此时的重定向只影响执行命令的子 shell，不影响当前 shell。<br>如果要对当前 shell 进行重定向，可以使用 bash 的 <strong class=highlight-text>exec</strong> 内置命令。</p><p>查看 man bash 里面对 exec 命令的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>Note that the exec builtin command can make redirections take effect in the current shell.</p><p><br></p><p><strong>exec [-cl] [-a name] [command [arguments]]</strong><br>If command is specified, it replaces the shell. No new process is created. The arguments become the arguments to command.<br>If command is not specified, any redirections take effect in the current shell, and the return status is 0.<br>If there is a redirection error, the return status is 1.</p></blockquote><p>即，当 exec 没有指定要执行的命令时，可以直接在当前 shell 进行重定向。<br>例如，把当前的 shell 标准输入重定向到文件，不再从键盘读取输入。</p><p>下面具体举例说明如何使用 exec 命令来进行重定向。</p><ul><li>重定向当前 shell 的标准输出到文件（如果终端自身不支持保存log功能，可以使用这个方法来把命令输出都保存到文件）：</li></ul><blockquote class=pgc-blockquote-abstract><p>$ exec 1>output.txt</p><p>$ ls</p><p>$ cat output.txt</p><p>cat: output.txt: input file is output file</p><p>$ exec 1>/dev/stdin</p><p>$ cat output.txt</p><p>testfile</p></blockquote><p>在这个例子中，<strong class=highlight-text>exec 1>output.txt</strong> 命令把当前 shell 的标准输出重定向到 output.txt 文件。<br>那么标准输出不再关联到终端。<br>执行 ls 命令，终端上看不到任何输出，ls 命令的输出结果被写入到 output.txt 文件。</p><p>此时，无法在当前 shell 上输出 output.txt 文件的内容。<br>执行 cat output.txt 命令，提示输入文件是输出文件，会形成循环，不会在终端上输出 output.txt 文件内容。</p><p>此时要查看 output.txt 文件的内容，可以在另外的终端上查看，或者取消重定向当前 shell 的标准输出到 output.txt 文件。<br><strong class=highlight-text>exec 1>/dev/stdin </strong>命令把当前 shell 的标准输出重定向到 /dev/stdin 文件，会关联到终端。<br>执行 cat output.txt 命令，就能输出 output.txt 文件内容到终端上。</p><p><strong>注意</strong>：这里有一个比较古怪的地方，需要执行 <strong class=highlight-text>exec 1>/dev/stdin</strong> 命令把对应标准输入的 /dev/stdin 文件关联到文件描述符 1，才能重新输出到终端上。<br>执行 <strong class=highlight-text>exec 1>/dev/stdout</strong> 命令并不能重定向标准输出到终端上。</p><p>在重定向中使用 /dev/stdout 文件，会复制到文件描述符 1。<br>而文件描述符 1 之前已经重定向到 output.txt 文件。<br>所以 exec 1>/dev/stdout 命令还是让文件描述符 1 关联到 output.txt 文件，并不是关联到终端。</p><p>在重定向中使用 /dev/stdin 文件，会复制到文件描述符 0。<br>而文件描述符 0 没有重定向，关联到终端。<br>所以 exec 1>/dev/stdin 命令会让文件描述符 1 关联到终端。</p><ul><li>重定向当前 shell 的标准输入到文件：</li></ul><blockquote class=pgc-blockquote-abstract><p>$ cat input.txt</p><p>date</p><p>sleep 2</p><p>$ exec 0&lt;input.txt</p><p>$ date</p><p>2019年 11月 28日 星期四 13:14:11 CST</p></blockquote><p>可以看到，用 cat input.txt 命令打印 input.txt 文件内容。<br>这个文件里面有两行，分别是 date 命令和 sleep 2 命令。<br>这个 sleep 命令用于延迟终端退出，否则执行后面命令，终端会很快关闭，终端窗口一闪而过。</p><p>执行 <strong class=highlight-text>exec 0&lt;input.txt</strong> 命令，会把当前 shell 的标准输入重定向到 input.txt 文件。<br>则 shell 会开始逐行读取该文件内容，并把每行内容当作命令来执行。<br>所以后面看到执行了 date 命令，这个命令并不是通过键盘手动输入。</p><p>自动执行 date 命令后，会再执行 sleep 2 命令，等秒 2 秒，接着就会退出当前 shell。</p><p>这是因为 bash shell 遇到 EOF 就会退出。<br>例如打开一个 shell，输入 CTRL-D，就会退出 shell。<br>重定向标准输入到 input.txt 文件后，当前 shell 读取完该文件内容，就会遇到 EOF，所以会退出 shell。</p><h1 class=pgc-h-arrow-right>重定向输入</h1><p>查看重定向输入（Redirecting Input）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>Redirection of input causes the file whose name results from the expansion of word to be opened for reading on file descriptor n, or the standard input (file descriptor 0) if n is not specified.<br>The general format for redirecting input is:</p></blockquote><pre><code>    [n]&lt;word</code></pre><p>即，<strong class=highlight-text>[n]&lt;word</strong> 用读模式打开 word 文件，并关联到文件描述符 n 上。<br>如果没有提供文件描述符 n，默认关联到文件描述符 0 上，也就是标准输入。<br>重定向输入后，从文件描述符 n 读取内容，会读取到所关联的 word 文件内容。</p><p>例如，重定向标准输入后，word 文件关联到文件描述符 0。<br>被执行的命令读取标准输入，也就是读取文件描述符 0，从而读取到 word 文件的内容，不需要从键盘进行输入。</p><p>重定向输入的例子说明如下：</p><blockquote class=pgc-blockquote-abstract><p>$ cat &lt; input.txt</p><p>date</p><p>sleep 2</p><p>$ exec 3&lt; input.txt</p><p>$ cat /dev/fd/3</p><p>date</p><p>sleep 2</p><p>$ read -u 3 line</p><p>$ echo $line</p><p>date</p></blockquote><p>在 <strong class=highlight-text>cat &lt; input.txt</strong> 命令中，执行 cat 命令且没有提供文件名参数，那么 cat 命令默认读取标准输入。<br><strong class=highlight-text>&lt; input.txt</strong> 表示把 input.txt 文件关联到文件描述符 0，也就是关联到被执行命令的标准输入。<br>cat 命令读取标准输入时，读取的就是 input.txt 文件的内容。<br>这只影响被执行命令的标准输入，不影响当前 shell 的标准输入。</p><p>执行 <strong class=highlight-text>exec 3&lt; input.txt </strong>命令把 input.txt 文件关联到文件描述符 3 的输入。<br>之后，读取文件描述符 3，读取的就是 input.txt 文件的内容。<br>用 cat /dev/fd/3 命令读取文件描述符 3，获取到的内容确实和 input.txt 文件内容一致。</p><p>read -u 3 line 命令使用 -u 选项指定从文件描述符 3 读取一行，保存到 line 变量。<br>打印 line 变量值，读取到的内容就是 input.txt 文件的第一行。</p><h1 class=pgc-h-arrow-right>重定向输出</h1><p>查看重定向输出（Redirecting Output）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>Redirection of output causes the file whose name results from the expansion of word to be opened for writing on file descriptor n, or the standard output (file descriptor 1) if n is not specified.<br>If the file does not exist it is created; if it does exist it is truncated to zero size.<br>The general format for redirecting output is:</p></blockquote><pre><code>    [n]&gt;word</code></pre><p>即，<strong class=highlight-text>[n]>word</strong> 用写模式打开 word 文件，并关联到文件描述符 n 上。<br>如果没有提供文件描述符 n，默认关联到文件描述符 1 上，也就是标准输出。<br>重定向输出后，往文件描述符 n 写入内容，会写入到所关联的 word 文件。</p><p>如果 word 文件不存在，会创建该文件。<br>如果 word 文件已经存在，则把它的文件大小截断成 0，会丢弃原有的内容。</p><p>重定向标准输出是重定向最常见的用法之一。<br>重定向输出的例子说明如下：</p><blockquote class=pgc-blockquote-abstract><p>$ echo "redirection output" > output.txt</p><p>$ cat output.txt</p><p>redirection output</p><p>$ exec 5> output.txt</p><p>$ cat input.txt > /dev/fd/5</p><p>$ cat output.txt</p><p>date</p><p>sleep 2</p></blockquote><p><strong class=highlight-text>echo "redirection output" > output.txt</strong> 命令把 echo 命令的标准输出重定向到 output.txt 文件。<br>那么 echo 命令的输出结果就是写入到该文件。</p><p>用 cat output.txt 命令查看 output.txt 文件内容，可以看到重定向标准输出写入的字符串。</p><p><strong class=highlight-text>exec 5> output.txt </strong>命令把 output.txt 文件关联到文件描述符 5 的输出。<br>之后，往文件描述符 5 写入内容，就是写入到 output.txt 文件。</p><p><strong class=highlight-text>cat input.txt > /dev/fd/5 </strong>命令把标准输出重定向到文件描述符 5。<br>那么所输出的 input.txt 文件内容会被写入到文件描述符 5。</p><p>用 cat output.txt 命令输出 output.txt 文件内容，已经不再是 "redirection output" 字符串。<br>而是跟 input.txt 文件的内容一致。</p><h1 class=pgc-h-arrow-right>追加重定向输出</h1><p>查看追加重定向输出（Appending Redirected Output）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>Redirection of output in this fashion causes the file whose name results from the expansion of word to be opened for appending on file descriptor n, or the standard output (file descriptor 1) if n is not specified.<br>If the file does not exist it is created.<br>The general format for appending output is:</p></blockquote><pre><code>    [n]&gt;&gt;word</code></pre><p>即，<strong class=highlight-text>[n]>>word </strong>命令用追加写入模式打开 word 文件，并关联到文件描述符 n 上。<br>如果没有提供文件描述符 n，默认关联到文件描述符 1 上，也就是标准输出。<br>重定向输出后，往文件描述符 n 写入内容，会追加写入到所关联的 word 文件。</p><p>如果 word 文件不存在，会创建该文件。<br>如果 word 文件已经存在，会把内容追加写入到文件末尾，不会丢弃原有的内容。</p><p>追加重定向输出的例子说明如下：</p><blockquote class=pgc-blockquote-abstract><p>$ cat output.txt</p><p>date</p><p>sleep 2</p><p>$ echo "append" >> output.txt</p><p>$ cat output.txt</p><p>date</p><p>sleep 2</p><p>append</p></blockquote><p>先用 cat output.txt 命令查看 output.txt 文件的内容。<br>然后使用 <strong class=highlight-text>echo "append" >> output.txt</strong> 命令追加重定向标准输出到 output.txt 文件。</p><p>再次查看 output.txt 文件，原有的内容还在，并在文件末尾追加了写入的 "append" 字符串。</p><p>当重定向的输出文件不存在时，<strong class=highlight-text>></strong> 和 <strong class=highlight-text>>> </strong>都会新建该文件。<br>当输出文件已经存在时，> 会清空该文件的内容，然后再写入新的内容（如果有的话）。<br>而 >> 会将新写入的内容追加到该文件的末尾，文件原来的内容还会保留。</p><h1 class=pgc-h-arrow-right>同时重定向标准输出和标准错误输出</h1><p>查看同时重定向标准输出和标准错误输出（Redirecting Standard Output and Standard Error）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to be redirected to the file whose name is the expansion of word.<br>There are two formats for redirecting standard output and standard error:</p></blockquote><pre><code>    &amp;&gt;word</code></pre><blockquote class=pgc-blockquote-abstract><p>and</p></blockquote><pre><code>    &gt;&amp;word</code></pre><blockquote class=pgc-blockquote-abstract><p>Of the two forms, the first is preferred. This is semantically equivalent to</p></blockquote><pre><code>    &gt;word 2&gt;&amp;1</code></pre><blockquote class=pgc-blockquote-abstract><p>When using the second form, word may not expand to a number or -.<br>If it does, other redirection operators apply (see Duplicating File Descriptors below) for compatibility reasons.</p></blockquote><p>即，可以使用 <strong class=highlight-text>&>word</strong>、或者 <strong class=highlight-text>>&word</strong> 来同时重定向标准输出和标准错误输出。</p><p>建议采用 &>word 这个写法。<br>在语义上，这个写法等同于 <strong class=highlight-text>>word 2>&1</strong>。<br><strong class=highlight-text>2>&1 </strong>这个写法表示复制文件描述符。后面会具体说明。</p><p>如果使用 <strong class=highlight-text>>&word </strong>这种形式来同时重定向标准输出和标准错误输出，那么 word 文件名不能是数字，也不能是连字符 -。<br>因为这种写法是复制文件描述符，而复制文件描述符时，数字和 - 具有特殊含义，不会当成文件名处理。</p><p>当重定向标准输出到文件后，如果命令执行出错，错误信息会打印到标准错误输出，会在终端上看到这些打印。<br>如果确实需要把标准错误输出也重定向到文件，就可以使用 <strong class=highlight-text>&>word</strong> 来同时重定向标准输出和标准错误输出。这里不再举例。</p><h1 class=pgc-h-arrow-right>同时追加重定向标准输出和标准错误输出</h1><p>查看同时追加重定向标准输出和标准错误输出（Appending Standard Output and Standard Error）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>This construct allows both the standard output (file descriptor 1) and the standard error output (file descriptor 2) to the appended to the file whose name is the expansion of word.<br>The format for appending standard output and standard error is:</p></blockquote><pre><code>    &amp;&gt;&gt;word</code></pre><blockquote class=pgc-blockquote-abstract><p>This is semantically equivalent to</p></blockquote><pre><code>    &gt;&gt;word 2&gt;&amp;1</code></pre><p>即，可以使用 <strong class=highlight-text>&>>word</strong> 来同时追加重定向标准输出和标准错误输出。<br>这个命令在语义上，等同于 >>word 2>&1。</p><h1 class=pgc-h-arrow-right>Here Documents</h1><p>前面说明的重定向输入需要提供文件名，会有一个单独的文件。<br><strong>编写 shell 脚本时，如果需要进行重定向输入，这个脚本就会依赖一个外部的文件，增加耦合。</strong></p><p><strong>我们可以使用 Here Documents 机制来重定向标准输入为指定的字符串，不需要提供外部文件名。</strong><br>查看 Here Documents 的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>This type of redirection instructs the shell to read input from the current source until a line containing only delimiter (with no trailing blanks) is seen.<br>All of the lines read up to that point are then used as the standard input for a command. The format of here-documents is:</p><p><br></p><p>&lt;&lt;[-]word</p><p>here-document</p><p>delimiter</p><p><br></p><p>No parameter expansion, command substitution, arithmetic expansion, or pathname expansion is performed on word.<br>If any characters in word are quoted, the delimiter is the result of quote removal on word, and the lines in the here-document are not expanded.<br>If word is unquoted, all lines of the here-document are subjected to parameter expansion, command substitution, and arithmetic expansion.<br>In the latter case, the character sequence \&lt;newline> is ignored, and \ must be used to quote the characters , $, and `.<br>If the redirection operator is &lt;&lt;-, then all leading tab characters are stripped from input lines and the line containing delimiter.<br>This allows here-documents within shell scripts to be indented in a natural fashion.</p></blockquote><p>即，可以使用 here-documents 格式来重定向标准输入：</p><ul><li><strong>word</strong> 指定一个字符串。如果字符串带有空格，需要用引号括起来。</li><li><strong>here-document </strong>内容会被重定向到标准输入。<br>当某一行内容完全等于 word 指定的字符串时（行首、行末的空白字符也会用来比较），则停止重定向。</li><li><strong>delimiter</strong> 对应 word 指定的字符串，会去掉 word 中的引号。<br>所给的 delimiter 不会被重定向到标准输入。</li></ul><p>这里的 word 字符串不会进行参数扩展、命令替换、算法括号、或路径名扩展，意味着不能用 $var 的形式来获取 var 变量值。<br>如果 word 写为 $var，对应的 delimiter 字符串就是 $var。</p><p>当 word 字符串的任意字符被引号括起来时，对应的 delimiter 字符串不会包含这些引号。<br>而且中间的 here-document 字符串不会进行扩展。<br>例如，不能在 here-document 中用 $var 的形式来获取 var 变量值。</p><p>当 word 字符串中没有引号时，中间的 here-document 字符串可以进行参数扩展、命令替换、算法括号，不进行路径名扩展。</p><p>对 <strong class=highlight-text>&lt;&lt;word</strong> 这个写法来说，中间 here-document 字符串的任意字符都会被保留，包括行首、行末的空白字符。<br>而写为 &lt;&lt;-word 时，中间 here-document 字符串行首的 tab 字符会被去掉，行首的空格还是会保留。</p><p>下面举例说明各种情况的 here-documents 格式写法。</p><ul><li>在 here-document 中不进行扩展</li></ul><p>假设有一个 testhere.sh 脚本文件，内容如下：</p><p><strong class=highlight-text>（不好意思，近期网页版文章的代码块排版错乱，后台咨询确认网页版不支持。下面用四个 ‘----’ 代替四个空格来进行缩进和隔行显示。后面的代码块会类似处理。如果需要复制代码到本地验证，麻烦以四个 ‘----’为单位，替换成四个空格。非常抱歉。）</strong></p><blockquote class=pgc-blockquote-abstract><p>#!/bin/bash</p><p>cat -A &lt;&lt;"The end"</p><p>This is a here-document.</p><p><strong class=highlight-text>----</strong>The end</p><p>The end</p><p>$((3+7))</p><p>The end</p></blockquote><p>该脚本执行 cat -A 命令，-A 选项会在输出的行末打印一个 $ 字符，以便看到行末结尾。<br>这里用 &lt;&lt;"The end" 指定 here-documents 类型的重定向输入。<br>cat 命令会从 here-documents 获取标准输入，直到读取 "The end" 字符串为止。</p><p>在 &lt;&lt; 后面的 "The end" 字符串带有空格，要用引号括起来。<br>如果不加引号，会执行报错。</p><p>在 $((3+7)) 上一行的 "The end " 字符串后面有两个空格。<br>在测试的时候要注意在行末加上空格。</p><p>执行 testhere.sh 脚本，打印结果如下：</p><blockquote class=pgc-blockquote-abstract><p>$ ./testhere.sh</p><p>This is a here-document.$</p><p><strong class=highlight-text>----</strong>The end$</p><p>The end $</p><p>$((3+7))$</p></blockquote><p>可以看到，here-documents 的第二行 " The end"，在行首带有空格。<br>这一行不完全匹配 "The end"，没有停止重定向。</p><p>第三行内容是 "The end "，在行末有两个空格，也是不完全匹配 "The end"，没有停止重定向。</p><p>第四行内容是 "$((3+7))"，这是一个算术扩展表达式。<br>但是这里的 word 参数值是 "The end"，带有引号，不会进行算术扩展，会原样输出 "$((3+7))" 字符串。</p><p>第五行内容是 "The end"，完全匹配 "The end"，停止重定向。</p><p>停止重定向后，cat -A 命令会打印从标准输入读取到的所有内容，并在行末打印 $ 字符。</p><p>最后一行的 "The end" 字符串没有被重定向输入到 cat 命令。</p><ul><li>在 here-document 中进行扩展</li></ul><p>前面提到，如果 <strong class=highlight-text>&lt;&lt;word</strong> 的 word 没有包含引号，则 here-document 中的内容可以进行参数扩展、命令替换、算术扩展，不进行路径名扩展。<br>修改 testhere.sh 脚本为下面的内容，测试这种情况：</p><blockquote class=pgc-blockquote-abstract><p>#!/bin/bash</p><p>number="1234567"</p><p>cat &lt;&lt;end</p><p>number = $number</p><p>$(date)</p><p>$((3+7))</p><p>test*</p><p>end</p></blockquote><p>这里的停止重定向字符串是 end，没有加引号。<br>里面的 here-document 用 $number 获取 number 变量值。<br>用 $(date) 执行 date 命令并获取改命令的输出，也就是命令替换。<br>用 $((3+7)) 进行算术扩展。</p><p>执行修改后的 testhere.sh 脚本，打印结果如下：</p><blockquote class=pgc-blockquote-abstract><p>$ ./testhere.sh</p><p>number = 1234567</p><p>2019年 11月 28日 星期四 16:38:36 CST</p><p>10</p><p>test*</p></blockquote><p>可以看到，打印结果里面确实获取到了 number 变量值，打印了 date 命令的执行结果，并进行算术扩展。<br>但是 test* 没有进行路径名扩展，没有扩展成当前目录下以 "test" 开头的文件名。</p><ul><li>word 参数不进行扩展</li></ul><p>在 <strong class=highlight-text>&lt;&lt;word </strong>中，word 本身不进行参数扩展、命令替换、算法括号、或路径名扩展，所给的字符串会保持不变。<br>无法通过获取变量值的方式来指定停止重定向的字符串。</p><p>修改 testhere.sh 脚本内容为下面的内容：</p><blockquote class=pgc-blockquote-abstract><p>#!/bin/bash</p><p>number="12345"</p><p>cat &lt;&lt;$name</p><p>What is the name?</p><p>12345</p><p>$name</p></blockquote><p>这里指定停止重定向的字符串为 $name，name 变量值是 "12345"。<br>在 here-document 中提供了 "12345" 这一行，之后是 $name 这一行。</p><p>执行修改后的 testhere.sh 脚本，打印结果如下：</p><blockquote class=pgc-blockquote-abstract><p>$ ./testhere.sh</p><p>What is the name?</p><p>12345</p></blockquote><p>可以看到，输出结果里面包含了 "12345" 这一行，说明这一行没有停止重定向。<br>&lt;&lt;$name 并不会获取 name 变量值来作为停止重定向的字符串，而是保持停止重定向的字符串为 $name 不变。</p><h1 class=pgc-h-arrow-right>Here Strings</h1><p>前面说明的 here-documents 可以重定向多行到标准输入。如果只需要重定向一行，也可以使用 Here Strings。<br>查看 Here Strings 的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>A variant of here documents, the format is:</p></blockquote><pre><code>    &lt;&lt;&lt;word</code></pre><blockquote class=pgc-blockquote-abstract><p>The word undergoes brace expansion, tilde expansion, parameter and variable expansion, command substitution, arithmetic expansion, and quote removal. Pathname expansion and word splitting are not performed.<br>The result is supplied as a single string to the command on its standard input.</p></blockquote><p>即，here-strings 会把所给的 word 重定向到命令的标准输入，word 可以进行扩展。</p><p>跟 here-documents 不同，here-strings 的 word 无论是否加引号，都会进行参数扩展、命令替换、算术扩展、大括号扩展、波浪号扩展，并移除引号。<br>但是不进行路径名扩展和单词拆分。</p><p>如果 word 带有空格，需要用引号括起来，否则可能会报错。<br>对 <strong class=highlight-text>&lt;&lt;&lt;here strings</strong> 这种写法来说，其实是 &lt;&lt;&lt;、here、strings 三个参数。<br>如果被执行命令不能处理这三个参数，就会报错。<br>如果想要把 here strings 当成一个参数，需要用引号括起来，例如 &lt;&lt;&lt;"here strings"。</p><p>具体举例说明如下：</p><blockquote class=pgc-blockquote-abstract><p>$ number=1 2 3 4 5</p><p>$ grep 2 &lt;&lt;&lt;$number</p><p>12345</p><p>$ grep t &lt;&lt;&lt;test string</p><p>grep: string: No such file or directory</p></blockquote><p>这里的 <strong class=highlight-text>&lt;&lt;&lt;$number </strong>会获取 number 变量值来重定向到标准输入。<br>grep 命令没有提供文件名参数时，默认读取标准输入。<br>经过重定向，读取到 number 变量值。</p><p>在 <strong class=highlight-text>grep t &lt;&lt;&lt;test string</strong> 命令中，test string 中带有空格，没有用引号括起来。<br>那么 &lt;&lt;&lt;test 是 here-strings 类型的重定向输入，后面的 string 是另外的参数，会被 grep 命令当成文件名处理。<br>当前目录下没有该文件，执行报错。</p><p>在 &lt;word、&lt;&lt;word、&lt;&lt;&lt;word 这三种形式中，word 的类型有如下差异：</p><ul><li>在 <strong>&lt;word </strong>中，word 是文件名，读取文件内容作为重定向输入的来源。即使用引号把 word 括起来，也还是当成文件名，不会当成字符串处理。</li><li>在 <strong>&lt;&lt;word </strong>中，word 是字符串，不会被当成文件名处理，也不会进行扩展。</li><li>在 <strong>&lt;&lt;&lt;word </strong>中，word 是字符串，不会被当成文件名处理，会进行扩展。具体扩展类型如前面说明。</li></ul><h1 class=pgc-h-arrow-right>复制文件描述符</h1><p>查看复制文件描述符（Duplicating File Descriptors）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>The redirection operator</p></blockquote><pre><code>    [n]&lt;&amp;word</code></pre><blockquote class=pgc-blockquote-abstract><p>is used to duplicate input file descriptors. If word expands to one or more digits, the file descriptor denoted by n is made to be a copy of that file descriptor.<br>If the digits in word do not specify a file descriptor open for input, a redirection error occurs.<br>If word evaluates to -, file descriptor n is closed. If n is not specified, the standard input (file descriptor 0) is used.</p><p>The operator</p></blockquote><pre><code>    [n]&gt;&amp;word</code></pre><blockquote class=pgc-blockquote-abstract><p>is used similarly to duplicate output file descriptors. If n is not specified, the standard output (file descriptor 1) is used.<br>If the digits in word do not specify a file descriptor open for output, a redirection error occurs.<br>If word evaluates to -, file descriptor n is closed.<br>As a special case, if n is omitted, and word does not expand to one or more digits or -, the standard output and standard error are redirected as described previously.</p></blockquote><p>即，<strong class=highlight-text>[n]&lt;&word</strong> 把文件描述符 n 复制到文件描述符 word。<br>如果文件描述符 word 没有对应以写模式打开的文件，则重定向报错。<br>如果 word 的值是连字符 -，则会关闭文件描述符 n。<br>如果没有提供文件描述符 n，默认会使用文件描述符 0，也就是标准输入。</p><p>类似的，<strong class=highlight-text>[n]>&word</strong> 把文件描述符 n 复制到文件描述符 word。<br>如果文件描述符 word 没有对应以读模式打开的文件，则重定向报错。<br>如果 word 的值是连字符 -，则会关闭文件描述符 n。<br>如果没有提供文件描述符 n，默认会使用文件描述符 1，也就是标准输出。</p><p>有一种特别情况是，当 [n]>&word 中的 word 扩展结果不是数字、也不是连字符 - 时，word 会被当成文件名处理。<br>也就是前面说明的“同时重定向标准输出和标准错误输出”这种场景。</p><p>这个复制文件描述符的行为类似于 Linux 的 dup() 系统调用函数。<br>这两个文件描述符会指向同一个文件表（file table），共享文件偏移指针。<br>所以它们写入的内容是交错开的，不会发生覆盖的现象。</p><p>在编译大型项目代码时，就经常用到 <strong class=highlight-text>2>&1 </strong>这个写法。<br>例如可以使用下面命令全编译 Android 源码：</p><pre><code>make -j16 2&gt;&amp;1 | tee build_android.log</code></pre><p>这个命令使用 2>&1，把标准错误输入复制到标准输出。<br>那么写入到标准错误输出的内容也会写入到标准输出，然后通过管道 | 把标准输出重定向给下一个命令。</p><p>当使用管道 <strong class=highlight-text>| </strong>来重定向前一个命令的输出到后一个命令的输入时，只会重定向标准输出，不会重定向标准错误输出。<br>如果想重定向标准错误输出，可以写为 <strong class=highlight-text>2>&1 |</strong>。<br>这种写法会先将标准错误输出重定向到标准输出上，然后再一起输出到管道上。</p><p>实际上，更简单的写法是 <strong class=highlight-text>|&</strong>。<br>查看 man bash 的 Pipelines 小节提到了这一点，具体描述如下：</p><blockquote class=pgc-blockquote-abstract><p>If |& is used, the standard error of command is connected to command2's standard input through the pipe; it is shorthand for 2>&1 |.<br>This implicit redirection of the standard error is performed after any redirections specified by the command.</p></blockquote><h1 class=pgc-h-arrow-right>移动文件描述符</h1><p>查看移动文件描述符（Moving File Descriptors）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>The redirection operator</p></blockquote><pre><code>    [n]&lt;&amp;digit-</code></pre><blockquote class=pgc-blockquote-abstract><p>moves the file descriptor digit to file descriptor n, or the standard input (file descriptor 0) if n is not specified. digit is closed after being duplicated to n.</p><p>Similarly, the redirection operator</p></blockquote><pre><code>    [n]&gt;&amp;digit-</code></pre><blockquote class=pgc-blockquote-abstract><p>moves the file descriptor digit to file descriptor n, or the standard output (file descriptor 1) if n is not specified.</p></blockquote><p>即，<strong class=highlight-text>[n]&lt;&digit-</strong> 把文件描述符 digit 复制到文件描述符 n，然后关闭文件描述符 digit。<br>后面的连字符 - 必须提供。<br>如果没有提供文件描述符 n，默认使用文件描述符 0，也就是标准输入。</p><p>类似的，<strong class=highlight-text>[n]>&digit-</strong> 把文件描述符 digit 复制到文件描述符 n，然后关闭文件描述符 digit。<br>后面的连字符 - 必须提供。<br>如果没有提供文件描述符 n，默认使用文件描述符 1，也就是标准输出。</p><p>这个移动文件描述符的行为和 Linux 的 dup2() 系统调用函数有所区别。<br>dup2() 函数将老的文件描述符（后面称之为 oldfd）复制到新的文件描述符（后面称之为 newfd）。<br>如果 newfd 之前是打开的，会先关闭 newfd，但是这个函数不会关闭 oldfd。<br>而 [n]&lt;&digit-、[n]>&digit- 会在复制文件描述符之后，关闭 digit 对应的文件描述符。</p><p><strong>注意</strong>：在 [n]&lt;&digit-、[n]>&digit- 中，如果省略了 digit，就变成 [n]&lt;&-、[n]>&-。<br>这是前面“复制文件描述符”的写法，会关闭文件描述符 n。</p><h1 class=pgc-h-arrow-right>以读写模式打开文件描述符</h1><p>前面说明的文件描述符都对应到一个已经打开的文件。例如，n>word 是把 word 文件关联到已经打开的文件描述符 n 上。<br>而下面介绍的重定向方式会打开一个新的文件描述符。</p><p>查看以读写模式打开文件描述符（Opening File Descriptors for Reading and Writing）的说明如下：</p><blockquote class=pgc-blockquote-abstract><p>The redirection operator</p></blockquote><pre><code>    [n]&lt;&gt;word</code></pre><blockquote class=pgc-blockquote-abstract><p>causes the file whose name is the expansion of word to be opened for both reading and writing on file descriptor n, or on file descriptor 0 if n is not specified.<br>If the file does not exist, it is created.</p></blockquote><p>即，<strong class=highlight-text>[n]&lt;>word</strong> 会以读写模式打开 word 文件，且打开后的文件描述符为 n。<br>如果没有文件描述符 n，默认会打开到文件描述符 0 上。</p><p>如果 word 文件不存在，会创建该文件。<br>如果 word 文件已经存在，且往文件描述符 n 写入内容，则会把清空 word 文件原有的内容，然后写入新的内容。</p><p>具体举例说明如下：</p><blockquote class=pgc-blockquote-abstract><p>$ cat output.txt</p><p>date</p><p>sleep 2</p><p>$ echo "new string" 3&lt;> output.txt > /dev/fd/3</p><p>$ cat output.txt</p><p>new string</p></blockquote><p>这里先用 cat output.txt 命令查看 output.txt 文件内容，说明该文件存在，且自身内容不为空。</p><p>在 <strong class=highlight-text>echo "new string" 3&lt;> output.txt > /dev/fd/3 </strong>命令里面，<strong class=highlight-text>3&lt;> output.txt </strong>以读写模式打开 output.txt 文件，并关联到文件描述符 3 上。<br>后面的 <strong class=highlight-text>> /dev/fd/3</strong> 表示把 echo 的输出结果重定向到 /dev/fd/3 文件，也就是重定向到文件描述符 3，那么会写入到 output.txt 文件。</p><p>之后再次用 cat output.txt 命令查看 output.txt 文件内容。可见文件原有内容已经丢失，变成 echo 命令输出的字符串。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'定向操作符','Bash','介绍'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>