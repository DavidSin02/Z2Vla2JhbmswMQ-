<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>关于DSL和状态机引擎，看这篇就够了 | 极客快訊</title><meta property="og:title" content="关于DSL和状态机引擎，看这篇就够了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ae05864d5df040a19de9a727fd5c052d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d5a2007.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d5a2007.html><meta property="article:published_time" content="2020-10-29T20:59:15+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:15+08:00"><meta name=Keywords content><meta name=description content="关于DSL和状态机引擎，看这篇就够了"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d5a2007.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>关于DSL和状态机引擎，看这篇就够了</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>最近在一个项目中，因为涉及很多状态的流转，我们选择使用状态机引擎来表达状态流转。因为状态机DSL（Domain Specific Languages）带来的表达能力，相比较于if-else的代码，要更优雅更容易理解。另一方面，状态机很简单，不像流程引擎那么华而不实。</p><p>一开始我们选用了一个开源的状态机引擎，但我觉得不好用，就自己写了一个能满足我们要求的简洁版状态机，这样比较KISS（Keep It Simple and Stupid）。</p><p>作为COLA开源的一部分，我已经将该状态机（cola-statemachine）开源，你可以访问https://github.com/alibaba/COLA获取。</p><p>在实现状态机的过程中，有幸看到Martin Fowler写的《Domain Specific Languages》。书中的内容让我对DSL有了不一样的认知。</p><p>这也是为什么会有这边文章的原因，希望你看完这边文章以后，<strong>可以对什么是DSL、如何使用DSL、如何使用状态机都能有一个不一样的体会</strong>。</p><h1 class=pgc-h-arrow-right>DSL</h1><p>在介绍如何实现状态机之前，不妨让我们先来看一下什么是DSL，在Martin Fowler的《Domain Specific Languages》书中。开篇就是以State Machine来作为引子介绍DSL的。有时间的话，强烈建议你去读读这本书。没时间的话，看看下面的内容也能掌握个大概了。</p><p>下面就让我提炼一下书中的内容，带大家深入了解下DSL。</p><h2 class=pgc-h-arrow-right>什么是DSL</h2><p><strong>DSL是一种工具，它的核心价值在于，它提供了一种手段，可以更加清晰地就系统某部分的意图进行沟通。</strong></p><p>这种清晰并非只是审美追求。一段代码越容易看懂，就越容易发现错误，也就越容易对系统进行修改。因此，我们鼓励变量名要有意义，文档要写清楚，代码结构要写清晰。基于同样的理由，我们应该也鼓励采用DSL。</p><p>按照定义来说，DSL是针对某一特定领域，具有受限表达性的一种计算机程序设计语言。这一定义包含3个关键元素：</p><ul><li>语言性（language nature）：DSL是一种程序设计语言，因此它必须具备连贯的表达能力——不管是一个表达式还是多个表达式组合在一起。</li><li>受限的表达性（limited expressiveness）：通用程序设计语言提供广泛的能力：支持各种数据、控制，以及抽象结构。这些能力很有用，但也会让语言难于学习和使用。DSL只支持特定领域所需要特性的最小集。使用DSL，无法构建一个完整的系统，相反，却可以解决系统某一方面的问题。</li><li>针对领域（domain focus）：只有在一个明确的小领域下，这种能力有限的语言才会有用。这个领域才使得这种语言值得使用。</li></ul><p>比如正则表达式， /\d{3}-\d{3}-\d{4}/就是一个典型的DSL，解决的是字符串匹配这个特定领域的问题。</p><h2 class=pgc-h-arrow-right>DSL的分类</h2><p>按照类型，DSL可以分为三类：内部DSL（Internal DSL）、外部DSL（External DSL）、以及语言工作台（Language Workbench）。</p><ul><li><strong>Internal DSL是一种通用语言的特定用法</strong>。用内部DSL写成的脚本是一段合法的程序，但是它具有特定的风格，而且只用到了语言的一部分特性，用于处理整个系统一个小方面的问题。 用这种DSL写出的程序有一种自定义语言的风格，与其所使用的宿主语言有所区别。例如我们的状态机就是Internal DSL，<strong>它不支持脚本配置，使用的时候还是Java语言，但并不妨碍它也是DSL。</strong></li></ul><pre><code>     builder.externalTransition()                .from(States.STATE1)                .to(States.STATE2)                .on(Events.EVENT1)                .when(checkCondition())                .perform(doAction());</code></pre><ul><li><strong>External DSL是一种“不同于应用系统主要使用语言”的语言</strong>。外部DSL通常采用自定义语法，不过选择其他语言的语法也很常见（XML就是一个常见选 择）。比如像Struts和Hibernate这样的系统所使用的XML配置文件。</li><li><strong>Workbench是一个专用的IDE</strong>，简单点说，工作台是DSL的产品化和可视化形态。</li></ul><p>三个类别DSL从前往后是有一种递进关系，Internal DSL最简单，实现成本也低，但是不支持“外部配置”。Workbench不仅实现了配置化，还实现了可视化，但是实现成本也最高。他们的关系如下图所示：</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ae05864d5df040a19de9a727fd5c052d><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>不同DSL该如何选择</h2><p>几种DSL类型各有各的使用场景，选择的时候，可以这样去做一个判断。</p><ol start=1><li>Internal DSL：假如你只是为了增加代码的可理解性，不需要做外部配置，我建议使用Internal DSL，简单、方便、直观。</li><li>External DSL：如果你需要在Runtime的时候进行配置，或者配置完，不想重新部署代码，可以考虑这种方式。比如，你有一个规则引擎，希望增加一条规则的时候，不需要重复发布代码，那么可以考虑External。</li><li>Workbench：配置也好，DSL Script也好，这东西对用户不够友好。比如在淘宝，各种针对商品的活动和管控规则非常复杂，变化也快。我们需要一个给运营提供一个workbench，让他们自己设置各种规则，并及时生效。这时的workbench将会非常有用。</li></ol><p><strong>总而言之，在合适的地方用合适的解决方案，不能一招鲜吃遍天</strong>。就像最臭名昭著的DSL——流程引擎，就属于那种严重的被滥用和过渡设计的典型，是把简单的问题复杂化的典型。</p><p>最好不要无端增加复杂性。然而，想做简单也不是一件容易的事，特别是在大公司，我们不仅要写代码，还要能沉淀“NB的技术”，最好是那种可以把老板说的一愣一愣的技术，就像尼古拉斯在《反脆弱》里面说的：</p><blockquote><p>在现代生活中，简单的做法一直难以实现，因为它有违某些努力寻求复杂化以证明其工作合理性的人所秉持的精神。</p></blockquote><h2 class=pgc-h-arrow-right>Fluent Interfaces</h2><p>在编写软件库的时候，我们有两种选择。一种是提供Command-Query API，另一种是Fluent Interfaces。比如Mockito的API when(mockedList.get(anyInt())).thenReturn("element")就是一种典型连贯接口的用法。</p><p><strong>连贯接口（fluent interfaces）是实现Internal DSL的重要方式</strong>，为什么这么说呢？</p><p>因为Fluent的这种连贯性带来的可读性和可理解的提升，其本质不仅仅是在提供API，更是一种领域语言，是一种Internal DSL。</p><p>比如Mockito的API when(mockedList.get(anyInt())).thenReturn("element")就非常适合用Fluent的形式，实际上，它也是单元测试这个特定领域的DSL。</p><p>如果把这个Fluent换成是Command-Query API，将很难表达出测试框架的领域。</p><pre><code>String element = mockedList.get(anyInt());boolean isExpected = "element".equals(element);</code></pre><p>这里需要注意的是，连贯接口不仅仅可以提供类似于method chaining和builder模式的方法级联调用，比如OkHttpClient中的Builder</p><pre><code>OkHttpClient.Builder builder=new OkHttpClient.Builder();        OkHttpClient okHttpClient=builder                .readTimeout(5*1000, TimeUnit.SECONDS)                .writeTimeout(5*1000, TimeUnit.SECONDS)                .connectTimeout(5*1000, TimeUnit.SECONDS)                .build();</code></pre><p>他更重要的作用是，限定方法调用的顺序。比如，在构建状态机的时候，我们只有在调用了from方法后，才能调用to方法，Builder模式没有这个功能。</p><p>怎么做呢？我们可以使用Builder和Fluent接口结合起来的方式来实现，下面的状态机实现部分，我会进一步介绍。</p><h1 class=pgc-h-arrow-right>状态机</h1><p>好的，关于DSL的知识我就介绍这么多。接下来，让我们看看应该如何实现一个Internal DSL的状态机引擎。</p><h2 class=pgc-h-arrow-right>状态机选型</h2><p>我反对滥用流程引擎，但并不排斥状态机，主要有以下两个原因：</p><ul><li>首先，状态机的实现可以非常的轻量，最简单的状态机用一个Enum就能实现，基本是零成本。</li><li>其次，<strong>使用状态机的DSL来表达状态的流转，语义会更加清晰，会增强代码的可读性和可维护性</strong>。</li></ul><p>然而，我们的业务场景虽然也不是特别复杂，但还是超出了Enum仅支持线性状态流转的范畴。因此不得不先向外看看。</p><h3 class=pgc-h-arrow-right>开源状态机太复杂</h3><p>和流程引擎一样，开源的状态机引擎不可谓不多，我着重看了两个状态机引擎的实现，一个是Spring Statemachine，一个是Squirrel statemachine。这是目前在github上的Top 2 状态机实现，<strong>他们的优点是功能很完备，缺点也是功能很完备。</strong></p><p>当然，这也不能怪开源软件的作者，你好不容易开源一个项目，至少要把UML State Machine上罗列的功能点都支持掉吧。</p><p>就我们的项目而言（其实大部分项目都是如此）。我实在不需要那么多状态机的高级玩法：<strong>比如状态的嵌套（substate），状态的并行（parallel，fork，join）、子状态机等等</strong>。</p><h3 class=pgc-h-arrow-right>开源状态机性能差</h3><p>除此之外，还有一个我不能容忍的问题是，这些开源的状态机都是有状态的（Stateful）的，表面上来看，状态机理所当然是应该维持状态的。但是深入想一下，这种状态性并不是必须的，因为有状态，状态机的实例就不是线程安全的，而我们的应用服务器是分布式多线程的，所以在每一次状态机在接受请求的时候，都不得不重新build一个新的状态机实例。</p><p>以电商交易为例，用户下单后，我们调用状态机实例将状态改为“Order Placed”。当用户支付订单的时候，可能是另一个线程，也可能是另一台服务器，所以我们必须重新创建一个状态机实例。因为原来的instance不是线程安全的。</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/66d5793c7f2c4d71b747cc3e924f0351><p class=pgc-img-caption></p></div><p>这种new instance per request的做法，耗电不说。倘若状态机的构建很复杂，QPS又很高的话，肯定会遇到性能问题。</p><p>鉴于复杂性和性能（公司电费）的考虑，我们决定自己实现一个状态机引擎，设计的目标很明确，有两个要求：</p><ol start=1><li>简洁的仅支持状态流转的状态机，不需要支持嵌套、并行等高级玩法。</li><li>状态机本身需要是Stateless（无状态）的，这样一个Singleton Instance就能服务所有的状态流转请求了。</li></ol><h2 class=pgc-h-arrow-right>状态机实现</h2><h3 class=pgc-h-arrow-right>状态机领域模型</h3><p>鉴于我们的诉求是实现一个仅支持简单状态流转的状态机，该状态机的核心概念如下图所示，主要包括：</p><ol start=1><li>State：状态</li><li>Event：事件，状态由事件触发，引起变化</li><li>Transition：流转，表示从一个状态到另一个状态</li><li>External Transition：外部流转，两个不同状态之间的流转</li><li>Internal Transition：内部流转，同一个状态之间的流转</li><li>Condition：条件，表示是否允许到达某个状态</li><li>Action：动作，到达某个状态之后，可以做什么</li><li>StateMachine：状态机</li></ol><p>整个状态机的核心语义模型（Semantic Model）也很简单，就是如下图所示：</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0e3c0c02c5b0477f84a663cb9005c86b><p class=pgc-img-caption></p></div><p>Note：这里之所以叫Semantic Model，用的是《DSL》书里的术语，你也可以理解为是状态机的领域模型。Martin用Semantic这个词，是想说，外部的DSL script代表语法（Syntax），里面的model代表语义（Semantic），我觉得这个隐喻还是很恰当的。</p><p>OK，状态机语义模型的核心代码如下所示：</p><pre><code>//StateMachinepublic class StateMachineImpl&lt;S,E,C&gt; implements StateMachine&lt;S, E, C&gt; {    private String machineId;    private final Map&lt;S, State&lt;S,E,C&gt;&gt; stateMap;    ...}//Statepublic class StateImpl&lt;S,E,C&gt; implements State&lt;S,E,C&gt; {    protected final S stateId;    private Map&lt;E, Transition&lt;S, E,C&gt;&gt; transitions = new HashMap&lt;&gt;();    ...}//Transitionpublic class TransitionImpl&lt;S,E,C&gt; implements Transition&lt;S,E,C&gt; {    private State&lt;S, E, C&gt; source;    private State&lt;S, E, C&gt; target;    private E event;    private Condition&lt;C&gt; condition;    private Action&lt;S,E,C&gt; action;    ...}</code></pre><h3 class=pgc-h-arrow-right>状态机的Fluent API</h3><p>实际上，我用来写Builder和Fluent Interface的代码甚至比核心代码还要多，比如我们的TransitionBuilder是这样写的</p><pre><code>class TransitionBuilderImpl&lt;S,E,C&gt; implements ExternalTransitionBuilder&lt;S,E,C&gt;, InternalTransitionBuilder&lt;S,E,C&gt;, From&lt;S,E,C&gt;, On&lt;S,E,C&gt;, To&lt;S,E,C&gt; {    ...    @Override    public From&lt;S, E, C&gt; from(S stateId) {        source = StateHelper.getState(stateMap, stateId);        return this;    }    @Override    public To&lt;S, E, C&gt; to(S stateId) {        target = StateHelper.getState(stateMap, stateId);        return this;    }   ...}</code></pre><p>通过这种Fluent Interface的方式，我们确保了Fluent调用的顺序，如下图所示，在externalTransition的后面你只能调用from，在from的后面你只能调用to，从而保证了状态机构建的语义正确性和连贯性。</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4432c1eeb7a7477f845a71b5ec0ffa61><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>状态机的无状态设计</h3><p>至此，状态机的核心模型和Fluent接口我已经介绍完了。<strong>我们还需要解决一个性能问题，也就是我前面说的，要把状态机变成无状态的</strong>。</p><p>分析一下市面上的开源状态机引擎，不难发现，它们之所以有状态，主要是在状态机里面维护了两个状态：初始状态（initial state）和当前状态（current state），如果我们能把这两个实例变量去掉的话，就可以实现无状态，从而实现一个状态机只需要有一个instance就够了。</p><p>关键是这两个状态可以不要吗？当然可以，唯一的副作用是，我们没办法获取到状态机instance的current state。然而，我也不需要知道，因为我们使用状态机，仅仅是接受一下source state，check一下condition，execute一下action，然后返回target state而已。它只是实现了一个状态流转的DSL表达，仅此而已，全程操作完全可以是无状态的。</p><p>采用了无状态设计之后，我们就可以使用一个状态机Instance来响应所有的请求了，性能会大大的提升。</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d4ebfe22e5dc43ddb987ef33f1ea40d5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>使用状态机</h1><p>状态机的实现很简单，同样，他的使用也不难。如下面的代码所示，它展现了cola状态机支持的全部三种transition方式。</p><pre><code>StateMachineBuilder&lt;States, Events, Context&gt; builder = StateMachineBuilderFactory.create();        //external transition        builder.externalTransition()                .from(States.STATE1)                .to(States.STATE2)                .on(Events.EVENT1)                .when(checkCondition())                .perform(doAction());        //internal transition        builder.internalTransition()                .within(States.STATE2)                .on(Events.INTERNAL_EVENT)                .when(checkCondition())                .perform(doAction());        //external transitions        builder.externalTransitions()                .fromAmong(States.STATE1, States.STATE2, States.STATE3)                .to(States.STATE4)                .on(Events.EVENT4)                .when(checkCondition())                .perform(doAction());        builder.build(machineId);</code></pre><p>可以看到，这种Internal DSL的状态机显著的提升了代码的可读性和可理解性。特别是在相对复杂的业务状态流转中，比如下图就是我们用cola-statemachine生成的我们实际项目中的plantUML图。如果没有状态机的支持，像这样的业务代码将会很难看懂和维护。</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d4b70676191341c9abf74c38b004e954><p class=pgc-img-caption></p></div><p><strong>这就是DSL的核心价值——更加清晰地表达系统中，某一部分的设计意图和业务语义。</strong> 当然External DSL所带来的可配置性和灵活性也很有价值，只是cola-statemachine还没有支持，原因很简单，暂时用不上。</p><h1 class=pgc-h-arrow-right>最后</h1><p>最后，如果你觉得这边文章对你有用，也顺便支持下我的新书——《代码精进之路》</p><div class=pgc-img><img alt=关于DSL和状态机引擎，看这篇就够了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/259eb447e4ce4afda91f6746b66643bf><p class=pgc-img-caption></p></div><p>最后的最后，<strong>我团队正在招贤纳士，如果你在技术发展道路上有些迷茫，不妨来我团队看看</strong>。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'关于','DSL','状态机'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>