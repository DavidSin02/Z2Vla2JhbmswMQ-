<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>ICML 2018｜模型层面的对偶学习 | 极客快訊</title><meta property="og:title" content="ICML 2018｜模型层面的对偶学习 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/15254155590772a5cdbae00"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d617997.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d617997.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d617997.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d617997.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d617997.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d617997.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d617997.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d617997.html><meta property="article:published_time" content="2020-10-29T20:51:27+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:27+08:00"><meta name=Keywords content><meta name=description content="ICML 2018｜模型层面的对偶学习"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d617997.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>ICML 2018｜模型层面的对偶学习</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15254155590772a5cdbae00><p>编者按：很多人工智能任务都具有对偶的性质，例如中文到英文翻译和英文到中文翻译、语音识别和语音合成等。基于此，微软亚洲研究院在2016年提出了对偶学习，利用任务互为对偶的特点从无标注的数据中进行学习。事实上，对偶性不仅存在于数据层面，也存在于模型的层面。因此微软亚洲研究院在ICML 2018上提出了一个全新的角度——在模型层面来研究对偶学习。模型层面的对偶学习能够利用一个模型来解决一组对偶任务，该方法在神经机器翻译和文本分析两个任务上都被验证了其有效性。</p><p>多个任务联合学习被机器学习领域广泛地接受，特别是在数据不足，或者任务之间关联性很强的场景下。研究人员提出了多种不同的学习框架，例如多任务学习（multi-task learning）、迁移学习、对偶学习等。多任务学习的思想是让多个相关任务之间通过参数共享的方式实现特征表述，或是关系表述的共享，其能够成功的原因在于<strong>多个任务之间知识能够互相传递，从而提升了模型的泛化能力</strong>。迁移学习是另一种将知识在任务之间互相迁移的学习方法，目的是将一个已经学习好的模型迁移到另一个任务中。</p><p>微软亚洲研究院机器学习组在NIPS 2016上提出的<strong>对偶学习事实上也是多个任务之间通过互相协作提高模型性能的工作</strong>。最初的对偶学习方法可以总结为数据层面的对偶，也就是所有的对偶信息都是通过数据为媒介传递的。而在很多任务中（例如神经机器翻译、对话生成等），模型的不同部分已经具备了对偶的性质，以神经机器翻译为例：通常的神经机器翻译模型都是利用了编码器-解码器（encoder-decoder）的结构，我们在下图抽象了以递归神经网络（LSTM）为例的神经机器翻译过程。</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1531243508116c9f32acb5f><p>图1 标准的基于编码器-解码器神经机器翻译的结构（黑色框表示一个单位时间的延迟）</p><p>神经机器翻译过程可以用如下数学公式描述：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153124350795638fb1ec7b0><p>在原始任务中，编码器</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15312435079848748932ba3><p>服务于编码<em>x</em>而不需要任何外部条件；在对偶任务中，解码器</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1531243508194d7a7ea80a5><p>用于解码<em>x</em>，基于得到的文本信息Z<sup>Y</sup>。也就是说，给定一对对偶任务，原始任务的编码器和对偶任务的解码器高度相关，因为它们都是为了处理同一种语言，只是依赖的条件不同。</p><p>受到多任务学习中共享表述的启发，我们提出共享对偶任务中相关的模型参数，即对于神经机器翻译，做如下设置：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243508209b3bf1a5747><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243508723980b3155c1><p>我们将这种方法称为<strong>模型层面的对偶学习</strong>（model-level dual learning，缩写为MDL）。</p><p>除了类似于神经机器翻译这种严格对称的模型，模型层面的对偶学习同样适用于非对称的机器学习任务。以情感分类为例，原始任务是判断一个句子具有积极情感还是消极情感，解决这个任务的网络结构是：输入的句子会被长短期记忆网络（LSTM）逐词编码得到隐状态，而后这些隐状态会被输入到一个全连接网络进行分类。对偶任务是给定一个标签，生成具有特定感情色彩的回复。在对偶任务中，标签首先会被单词嵌入投射到一个特定的空间，而后，另一个LSTM会基于这个标签产生一个句子。在这个非对称的任务中，原始任务的编码器和对偶任务的解码器可以被共享。这可以视为我们提出的模型的一种退化形式——只需要设置</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243508706d602af8fbb><p>。</p><p><strong>模型框架</strong></p><p>我们考虑建立在两个空间<em>x</em>和<em>y</em>之间的对偶任务，其中，原始任务是学习映射<em>f:x</em>→<em>y</em>，对偶任务是学习反向的映射<em>g : y</em>→<em>x。</em></p><p>对于对称的场景，<em>x</em>和<em>y</em>中的元素形式相同，因而有可能使用相同的模型结果来对对偶学习中的两个任务进行建模。例如，在神经机器翻译和Q&A中，<em>x</em>和<em>y</em>中元素都是自然语言的句子，因此我们都可以用LSTM来为<em>f</em>和<em>g</em>进行建模。</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243508680d7aa0c9fe4><p><em>X</em>-元素和<em>Y</em>-元素示意图</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153124350887927537705a9><p>原始模型，其中</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1531243508896e118331ac4><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15312435092964991ca45b6><p>对偶模型，其中</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153124350931484201cbfcd><p>图2 对称条件下，模型层面的对偶学习模型结构的有向图（黑色的框表示一个单位的延迟，图中结点对应变量，有向边对应算子，其中箭头指向的点为输出，另一端为输入）</p><p>在非对称的场景中，<em>x</em>和<em>y</em>中的元素不对等，甚至语义空间也不同，因此，原始和对偶任务的模型也不尽相同。例如，在情感分类的任务中，<em>x</em>是自然语言的集合，而<em>y</em>是标签的集合，例如，<em>y</em>={0,1}。<em>x</em>和<em>y</em>的异质性使得我们要使用不同的模型结构。</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1531243509489f44cee9565><p>图3 非对称条件下模型层面对偶学习的框架</p><p>在模型层面的对偶学习中，<strong>原始模型和对偶模型的参数是共享的，意味着模型有着更少的参数</strong>，因此这种方法也可以看作是一种全新的模型压缩的办法。另外，对于给定的一对有标数据(x, y)，模型的每一部分都被更新两次，分别来自原始任务和对偶任务。因此，<strong>相比于标准的有监督学习，数据会被利用的更加充分</strong>。最后，<strong>由于参数的共享，两个模型的复杂度被降低了，因此会有更好的泛化能力</strong>。</p><p><strong>模型层面对偶学习在神经机器翻译中的应用</strong></p><p>我们在神经机器翻译任务中对模型层面的对偶学习方法进行测试，选用Transformer作为实验的模型，Transformer是由一个基本模块不断堆叠得到的一个完整模型。一个基本模块包括三个部分：（1）自我注意力机制，用于将底层的隐藏表达自适应地线性加权并提交给上一层；（2）编码器-解码器注意力机制：用于自适应地将编码器端的隐藏表达加权得到相应地文本信息；（3）非线性变换层，用于对自我注意力机制和编码器-解码器注意力机制的输出进行非线性变换。</p><p>下图展示了Transformer中的基本模块和前面介绍的模型的对应关系。</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15312435097024a40c5d170><p>图4 模型层面的对偶学习在神经机器翻译任务中的模型结构</p><p>该实验中，我们选择了三个广泛应用的数据集作为训练数据：</p><ul><li><p>IWSLT 2014的德英互译的任务 (153k训练数据)，简记为IWSLT De↔En；</p></li><li><p>LDC的中英互译任务(1.25M训练数据)，简记为Zh↔En；</p></li><li><p>WMT14的英德互译任务(4.5M训练数据)，简记为WMT En↔De。</p></li></ul><p>测试数据：</p><ul><li><p>对于IWSLT De↔En，我们选用和表1列出的对比算法一样的测试集；</p></li><li><p>对于Zh↔En，我们选用NIST2004、2005、2006、2008和2012作为测试集；</p></li><li><p>对于WMT En↔De，我们选取newstest14为测试集。</p></li></ul><p>我们将所有的实验模型设置为6个模块。对于IWSLTDe↔En任务，我们选择transformer_small参数配置办法，其余两个任务选择的配置均为transformer_big。同时，我们使用对偶有监督学习作为对比算法。</p><p>IWSLT De↔En的实验结果如下表：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153124350989779cdef5b4d><p>表1 IWSLT De↔En的实验结果</p><p>在IWSLT De↔En任务中，我们得到了德文到英文的最佳结果34.71。相比于基准算法Transformer，我们在原始任务德文到英文和对偶任务英文到德文上分别提高了1.85和0.90个点。相比于对偶有监督学习，我们的方法能够分别获得1.13和0.73个点的提升。</p><p>为了进一步探索新模型如何随着模型复杂度变化而工作，我们研究了随着网络模块数的变化，BLEU值的变化。我们分别测试了含有2、4、6、8个模块的模型的BLEU值（注意每个模块含有3层）。测试的结果如下图所示：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243510920627a065102><p>图5 BLEU随着模型模块数的变化</p><p>通过实验，我们发现：</p><p>（1）对于不同的模块数目以及不同的任务，我们提出的算法都能够提高模型的性能；</p><p>（2）当模型的模块数小于6的时候，在两个方向的翻译任务上，随着模块数的增加，模型层面的对偶学习提升的性能（图中绿色部分）会提升。这说明，虽然更深的模型有更强的表达力，但可能会受到过拟合的影响，特别是在数据量比较小的IWSLT数据集上。我们提出的方法能将对偶性引入模型中约束模型空间，并且能够更加充分地利用数据；</p><p>（3）即便是对于具有8个模块的网络，我们的方法仍然能够提升模型性能，尽管没有6个模块带来的提升明显。在这种情况下，为了带来更大的提升，我们需要引入更强的泛化性能的约束，例如采用对偶有监督学习。</p><p>中英互译的结果如下表：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243511155c7b871015b><p>表2 中英互译的实验结果</p><p>在中文到英文的翻译任务中，模型层面的对偶学习利用更简单的模型和更少的数据，再一次取得了最好的效果。在Transformer的算法之上，我们的方法平均给每个数据集带来1.21个点的性能提升，同时也超越了对偶有监督学习算法的表现。对于英文到中文的翻译任务，相比于基准算法，我们的方法在每个数据集上平均取得0.69个点的增益。</p><p>最后，在WMT英德互译的任务上，模型层面的对偶学习能够在Transformer的基础上将模型的性能进一步提升0.5个点。实验结果如下表：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243510681bcfd645442><p>表3 WMT英德互译的实验结果</p><p><strong>模型层面的对偶学习在情感分析中的应用</strong></p><p>在情感分析中，原始任务是情感分类，对偶任务是带有情感的句子生成<em>。x</em>是自然语言的集合，<em>y</em>是标签的集合。因此，两个空间的数据形式和语言完全不同。所以，我们要采用非对称形式的模型层面的对偶学习。</p><p>我们在IMDB数据集上进行了验证。我们选用标准的LSTM网络作为原始任务和对偶任务模型的基本单元。模型的单词嵌入和情感标签的嵌入表达均为500维，隐藏层节点数为1024，词表的大小是10k，Dropout的值设置为0.5。我们将softmax矩阵和单词嵌入矩阵（包括单词的和情感标签的）共享。实验结果如下表：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15312435105148813f29f75><p>表4 情感分析的实验结果</p><p>在原始任务中，相比于标准的LSTM，模型层面的对偶学习能够将错误率下降2.69个百分点；相比于对偶有监督学习，我们的方法也能将错误率下降1.79个百分点。在对偶任务中，模型层面的对偶学习能够比对偶有监督学习下降3.19个点。</p><p><strong>与对偶推断的结合</strong></p><p>对偶推断是我们在IJCAI 2017上提出的将对偶性应用到推断的过程中，用来提升已有对偶模型推断/预测准确度的方法。为了进一步提升模型效果，我们将对偶推断和模型层面对偶学习进行结合。</p><p>模型层面的对偶学习和对偶推断结合的结果如下：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153124351071908f1ef5286><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243511652f7bd54b8eb><p>和</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153124351177266e1665f51><p>分别对应原始任务和对偶任务的损失函数，</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1531243511719f1d607b6dc><p>和</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153124351159049d829544a><p>是经过验证集确定的参数。</p><p>我们在IWSLT德英互译任务上验证了模型层面的对偶学习和对偶推断结合的性能，实验结果如下表：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15312435119061a7deaa82c><p>表5 模型层面对偶学习和对偶推断结合在IWSLT德英互译任务上的实验结果（第三行表示标准的Transformer在标准推断和对偶推断的结果；第四行表示模型层面的对偶学习在标准推断和对偶推断下的结果）</p><p>可以看出，对偶推断可以将我们提出的算法在两个任务上分别提升0.48个点（德文到英文）和0.19个点（英文到德文）。对偶推断也能为标准Transformer分别带来0.66和0.10个点的提升。</p><p>我们同样在情感分类任务中测试了模型层面对偶学习和对偶推断结合的性能。下表展示了对偶推断在IMDB数据集的分类错误率：</p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1531243512480fe87440cab><p>表6 模型层面对偶学习和对偶推断结合在情感分类任务上的实验结果</p><p>从表格中可以看出，在使用了对偶推断之后，我们可以将错误率下降0.45个点。</p><p>总结来说，模型层面的对偶学习可以与数据层面的对偶学习形成互补。这种新的方法利用模型层面的对偶性来设计网络结构，进而提升网络性能。同时，模型层面的对偶学习可以用一个模型解决一组对偶任务，能够起到节省参数量的作用。</p><p>了解更多细节，请访问下面链接或点击<strong>阅读原文</strong>访问我们的论文：</p><p>论文链接：</p><p>http://proceedings.mlr.press/v80/xia18a.html</p><p><strong>作者简介</strong></p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153124351237220a9d14a85><p>夏应策，中国科技大学2015博士生，在微软亚洲研究院机器学习组实习。主要研究方向为对偶学习、神经机器翻译以及深度学习算法设计。</p><p><strong>你也许还想看</strong><strong>：</strong></p><img alt="ICML 2018｜模型层面的对偶学习" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15257688659625afe8005d1><p>感谢你关注“微软研究院AI头条”，我们期待你的留言和投稿，共建交流平台。来稿请寄：msraai@microsoft.com。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'ICML','2018','层面'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>