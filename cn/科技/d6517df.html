<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JDK容器学习之HashMap（二）：读写逻辑详解 | 极客快訊</title><meta property="og:title" content="JDK容器学习之HashMap（二）：读写逻辑详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/3f240002ded777fce419"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6517df.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6517df.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6517df.html><meta property="article:published_time" content="2020-10-29T20:58:37+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:37+08:00"><meta name=Keywords content><meta name=description content="JDK容器学习之HashMap（二）：读写逻辑详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d6517df.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JDK容器学习之HashMap（二）：读写逻辑详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>jdk map学习之HashMap (二) ： 读写逻辑详解</strong></h1><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f240002ded777fce419></p><h1><strong>Map读写实现逻辑说明</strong></h1><blockquote><p>前一篇博文<a href=http://www.toutiao.com/i6475452022651879950/>JDK容器学习之HashMap (一) ： 底层存储结构分析</a>分析了HashMap的底层存储数据结构通过 put(k,v) 方法的分析，说明了为什么Map底层用数组进行存储，为什么 Node 内部有一个 next 节点，这篇则将集中在读写方法的具体实现上</p></blockquote><p><strong>本片博文将关注的重点：</strong></p><p>- 通过key获取 value的实现逻辑</p><p>- 新增一个kv对的实现逻辑</p><p>- table 数组如何自动扩容</p><p>- 如何删除一个kv对（删除kv对之后，数组长度是否会缩水 ？）</p><hr><h1>1. 根据key索引</h1><blockquote><p>get(key) 作为map最常用的方法之一，根据key获取映射表中的value，通常时间复杂度为 o(1)<br></p></blockquote><p>在分析之前，有必要再把 HashMap 的数据结构捞出来看一下</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f260000bd5bb9e35240></p><p>根据上面的结构，如果让我们自己来实现这个功能，对应的逻辑应该如下：</p><ul class=list-paddingleft-2><li><p>计算key的hash值</p></li><li><p>根据hash确定在 table 数组中的位置</p></li><li><p>判断数组的Node对象中key是否等同与传入的key</p></li><li><p>若不是，则一次扫描 next节点的key，直到找到为止</p></li></ul><p>jdk实现如下</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3ecf00040dff296844ef></p><p>上面的逻辑算是比较清晰，再简单的划一下重点</p><p>1. 通过key定位table数组中索引的具体逻辑</p><ul class=list-paddingleft-2><li><p>hash(key) & (table.length - 1)</p></li><li><p>key的hash值与(数组长度-1)进行按位与，计算得到下标</p></li></ul><p>2. 判断Node是否为所查找的目标逻辑</p><ul class=list-paddingleft-2><li><p>node.hash == hash(key) && (node.key == key || (key!=null && key.equals(node.key))</p></li><li><p>首先是hash值必须相等</p></li><li><p>然后是 == or equals</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>== 表示key为同一个对象</p></li><li><p>equals 表示Node的key等价于传入的key</p></li></ul></ul><p>3. TreeNode 是个什么鬼</p><blockquote><p>上面的逻辑中，当出现hash碰撞时，会判断数组中的Node对象是否为TreeNode，如果是则调用TreeNode.getTreeNode(hash,key)方法</p></blockquote><p><strong>那么这个TreeNode有什么特殊的地方呢？</strong></p><hr><h1>2.TreeNode分析</h1><blockquote><p>TreeNode依然是HashMap的内部类, 不同于Node的是，它继承自LinkedHashMap.Entry，相比较与Node对象而言，多了两个属性before, after</p></blockquote><p>1. 数据结构</p><p>TreeNode对象中，包含的数据如下（将父类中的字段都集中在下面了）</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f240003eb0929bc1255></p><p>2. 内部方法</p><p>方法比较多，实现也不少，但是看看方法名以及注释，很容易猜到这是个什么东西了</p><p><strong>红黑树</strong></p><p>具体方法实现身略（对红黑树实现有兴趣的，就可以到这里来膜拜教科书的实现方式）</p><p>3. TreeNode 方式的HashMap存储结构</p><p>普通的Node就是一个单向链表，因此HashMap的结构就是上面哪种</p><p>TreeNode是一颗红黑树的结构，所以对上面的图走一下简单的改造，将单向链表改成红黑树即可</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/3ed00002d7dc408bc288></p><hr><h1>3. 添加kv对</h1><p>博文 《JDK容器学习之HashMap (一) ： 底层存储结构分析 》对于添加kv对的逻辑进行了说明，因此这里将主要集中在数组的扩容上</p><p>扩容的条件：<strong>默认扩容加载因子为(0.75)，临界点在当HashMap中元素的数量等于table数组长度*加载因子,长度扩为原来的2倍</strong></p><p>数组扩容方法, 实现比较复杂，先撸一把代码，并加上必要注释</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f2400047103ddd5ed07></p><p>上面的逻辑主要划分为两块</p><ul class=list-paddingleft-2><li><p>新的数组长度确定，并初始化新的数组</p></li><li><p>将原来的数据迁移到新的数组中</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>遍历旧数组元素</p></li><li><p>若Node没有尾节点(Next为null)，则直接塞入新的数组</p></li><li><p>判断Node的数据结构，红黑树和链表逻辑有区分</p></li><li><p>对于链表格式，新的座标要么是原来的位置，要么是原来的位置+原数组长度，链表顺序不变</p></li></ul></ul><p><strong>说明</strong></p><p>这个扩容的逻辑还是比较有意思的，最后面给一个测试case，来看一下扩容前后的数据位置</p><hr><h1>4. 删除元素</h1><p>删除的逻辑和上面的大致类似，显示确定节点，然后从整个数据结构中移除引用</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3ed0000491b61b8c19af></p><hr><h1>测试</h1><p>上面的几个常用方法的逻辑大致相同，核心都是在如何找到目标Node节点，其中比较有意思的一点是数组的扩容，旧元素的迁移逻辑，下面写个测试demo来演示一下</p><p>首先定义一个Deom对象，覆盖hashCode方法，确保第一次重新分配数组时，正好需要迁移</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/3ece0002f5a9508da6fe></p><p>实际演示示意图</p><p><img alt=JDK容器学习之HashMap（二）：读写逻辑详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3ece0002e411567a9cc2></p><hr><h1>小结</h1><p><strong>1. 根据Key定位Node节点</strong></p><ul class=list-paddingleft-2><li><p>key计算hash，hash值对数组长度取余即为数组中的下标</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>即hash & (len - 1) === hash % len</p></li></ul></ul><ul class=list-paddingleft-2><li><p>以数组中Node为链表头or红黑树根节点遍历，确认目标节点</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>判断逻辑：</p></li><li><p>hash值相同</p></li><li><p>key1 == key2 or key1.quals(key2)<br></p></li></ul></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul><p><strong>2. 扩容逻辑</strong></p><ul class=list-paddingleft-2><li><p>当添加元素后，数组的长度超过阀值，实现扩容</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>初始容量为16，阀值为12</p></li></ul></ul><ul class=list-paddingleft-2><li><p>计算新的数组长度，并初始化</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>新的长度为原来的长度 * 2</p></li><li><p>新的阀值为 新的长度 * loadFactor； loadFactory 一般为 0.75</p></li></ul></ul><ul class=list-paddingleft-2><li><p>将原来的数据迁移到新的数组</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>原位置不变 (hash % 原长度 == 0)</p></li><li><p>原位置 + 原数组长度 (hash % 原长度 == 1)<br></p></li></ul></ul><ul class=list-paddingleft-2></ul><ul class=list-paddingleft-2></ul><p><strong>3. 其他</strong></p><ul class=list-paddingleft-2><li><p>jdk1.8 之后，当链表长度超过阀值（8）后，转为红黑树</p></li><li><p>新增元素，在添加完毕之后，再判断是否需要扩容</p></li><li><p>删除元素不会改变Node对象本身，只是将其从Map的数据结构中<strong>摘</strong>出来</p></li><li><p>Map如何退化为链表</p></li></ul><ul class=list-paddingleft-2><ul class=list-paddingleft-2><li><p>一个糟糕的hashCode方法即可模拟实现，如我们上面的测试用例</p></li><li><p>红黑树会使这种退化的效果不至于变得那么糟糕</p></li></ul></ul><hr><h1>相关博文</h1><ul class=list-paddingleft-2><li><p><a href=http://www.toutiao.com/i6475452022651879950/>JDK容器学习之HashMap（一）：底层存储结构分析</a><br></p></li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JDK','学习','HashMap'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>