<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Map接口概述 | 极客快訊</title><meta property="og:title" content="Map接口概述 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/7e955e46020b4afc85b3d83a8cbd92ca"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d6745bcd.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d6745bcd.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Map接口概述"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d6745bcd.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Map接口概述</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1.1Map接口概述</strong></p><p>我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同，如下图。</p><ul><li>Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储。</li><li>Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li>Collection中的集合称为单列集合，Map中的集合称为双列集合。</li><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li><li>Map中常用的集合为HashMap集合、LinkedHashMap集合。</li></ul><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7e955e46020b4afc85b3d83a8cbd92ca><p class=pgc-img-caption></p></div><p><strong>1.1Map接口中常用集合概述</strong></p><p>通过查看Map接口描述，看到Map有多个子类，这里我们主要讲解常用的HashMap集合、LinkedHashMap集合。</p><ul><li><strong>HashMap\</strong>：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>LinkedHashMap\</strong>：HashMap下有个子类LinkedHashMap，存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</li><li><strong>注意</strong>：Map接口中的集合都有两个泛型变量\,在使用时，要为两个泛型变量赋予数据类型。两个泛型变量\的数据类型可以相同，也可以不同。</li></ul><p><strong>1.1Map接口中的常用方法</strong></p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e2b98c721323458e9a8c3c210991aecd><p class=pgc-img-caption></p></div><ul><li>put方法：将指定的键与值对应起来，并添加到集合中方法返回值为键所对应的值</li></ul><blockquote><p>使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中；</p><p>使用put方法时，若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</p></blockquote><ul><li>get方法：获取指定键(key)所对应的值(value)</li><li>remove方法：根据指定的键(key)删除元素，返回被删除元素的值(value)。</li></ul><blockquote><p>Map接口的方法演示</p></blockquote><p><strong>public class</strong> MapDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//创建Map对象</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//给map中添加元素</p><p>map.put("星期一", "Monday");</p><p>map.put("星期日", "Sunday");</p><p>System.out.println(map); // {星期日=Sunday, 星期一=Monday}</p><p>//当给Map中添加元素，会返回key对应的原来的value值，若key没有对应的值，返回null</p><p>System.out.println(map.put("星期一", "Mon")); // Monday</p><p>System.out.println(map); // {星期日=Sunday, 星期一=Mon}</p><p>//根据指定的key获取对应的value</p><p>String en = map.get("星期日");</p><p>System.out.println(en); // Sunday</p><p>//根据key删除元素,会返回key对应的value值</p><p>String value = map.remove("星期日");</p><p>System.out.println(value); // Sunday</p><p>System.out.println(map); // {星期一=Mon}</p><p>}</p><p>}</p><p><strong>1.1Map集合遍历键找值方式</strong></p><blockquote><p>键找值方式：即通过元素中的键，获取键所对应的值</p><p>操作步骤与图解：</p><p>1.获取Map集合中所有的键，由于键是唯一的，所以返回一个Set集合存储所有的键</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ddd9c098c2c742eaad76ae0a19ba47f8><p class=pgc-img-caption></p></div><blockquote><p>2.遍历键的Set集合，得到每一个键</p><p>3.根据键，获取键所对应的值</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fd3eb988565b40adb922b962d3140d3a><p class=pgc-img-caption></p></div><p>代码演示：</p><p><strong>public class</strong> MapDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//创建Map对象</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//给map中添加元素</p><p>map.put("邓超", "孙俪");</p><p>map.put("李晨", "范冰冰");</p><p>map.put("刘德华", "柳岩");</p><p>//获取Map中的所有key</p><p>Set\ keySet = map.keySet();</p><p>//遍历存放所有key的Set集合</p><p>Iterator\ it =keySet.iterator();</p><p><strong>while</strong>(it.hasNext()){</p><p>//得到每一个key</p><p>String key = it.next();</p><p>//通过key获取对应的value</p><p>String value = map.get(key);</p><p>System.out.println(key+"="+value);</p><p>}</p><p>}</p><p>}</p><p><strong>1.1Entry键值对对象</strong></p><p>在Map类设计时，提供了一个嵌套接口：Entry。Entry将键值对的对应关系封装成了对象。即键值对对象，这样我们在遍历Map集合时，就可以从每一个键值对（Entry）对象中获取对应的键与对应的值。</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c5849e5713de40adb8d8179f5abce6b6><p class=pgc-img-caption></p></div><ul><li>Entry是Map接口中提供的一个静态内部嵌套接口。</li></ul><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b96bd7f318f49afb293ecf4eee15cd4><p class=pgc-img-caption></p></div><ul><li>getKey()方法：获取Entry对象中的键</li><li>getValue()方法：获取Entry对象中的值</li></ul><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0f060a694fa4695bc0a6308083fae3d><p class=pgc-img-caption></p></div><ul><li>entrySet()方法：用于返回Map集合中所有的键值对(Entry)对象，以Set集合形式返回。</li></ul><p><strong>1.1Map集合遍历键值对方式</strong></p><blockquote><p>键值对方式：即通过集合中每个键值对(Entry)对象，获取键值对(Entry)对象中的键与值。</p><p>操作步骤与图解：</p></blockquote><p>1.获取Map集合中，所有的键值对(Entry)对象，以Set集合形式返回。</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ca91ae086c1476c871ce101bb184a96><p class=pgc-img-caption></p></div><p>2.遍历包含键值对(Entry)对象的Set集合，得到每一个键值对(Entry)对象</p><p>3.通过键值对(Entry)对象，获取Entry对象中的键与值。</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/855123c7b70c4246a10c547ab09c3e6e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5658ecb863f5434e81c6fe004cf5a07c><p class=pgc-img-caption></p></div><p><strong>public class</strong> MapDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//创建Map对象</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//给map中添加元素</p><p>map.put("邓超", "孙俪");</p><p>map.put("李晨", "范冰冰");</p><p>map.put("刘德华", "柳岩");</p><p>//获取Map中的所有key与value的对应关系</p><p>Set\> entrySet = map.entrySet();</p><p>//遍历Set集合</p><p>Iterator\> it =entrySet.iterator();</p><p><strong>while</strong>(it.hasNext()){</p><p>//得到每一对对应关系</p><p>Map.Entry\ entry = it.next();</p><p>//通过每一对对应关系获取对应的key</p><p>String key = entry.getKey();</p><p>//通过每一对对应关系获取对应的value</p><p>String value = entry.getValue();</p><p>System.out.println(key+"="+value);</p><p>}</p><p>}</p><p>}</p><p>注意：Map集合不能直接使用迭代器或者foreach进行遍历。但是转成Set之后就可以使用了。</p><p><strong>1.1HashMap存储自定义类型键值</strong></p><p>练习：每位学生（姓名，年龄）都有自己的家庭住址。那么，既然有对应关系，则将学生对象和家庭住址存储到map集合中。学生作为键, 家庭住址作为值。</p><p>注意，学生姓名相同并且年龄相同视为同一名学生。</p><ul><li>学生类</li></ul><p><strong>public class</strong> Student {</p><p><strong>private</strong> String name;</p><p><strong>private int</strong> age;</p><p>//编写构造方法，文档中已省略</p><p>//编写get,set方法，文档中已省略</p><p>//编写toString方法，文档中已省略</p><p>}</p><ul><li>测试类</li></ul><p><strong>public class</strong> HashMapTest {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//1,创建hashmap集合对象。</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//2,添加元素。</p><p>map.put(<strong>new</strong> Student("lisi",28), "上海");</p><p>map.put(<strong>new</strong> Student("wangwu",22), "北京");</p><p>map.put(<strong>new</strong> Student("zhaoliu",24), "成都");</p><p>map.put(<strong>new</strong> Student("zhouqi",25), "广州");</p><p>map.put(<strong>new</strong> Student("wangwu",22), "南京");</p><p>//3,取出元素。键找值方式</p><p>Set\ keySet = map.keySet();</p><p><strong>for</strong>(Student key : keySet){</p><p>String value = map.get(key);</p><p>System.out.println(key.toString()+"....."+value);</p><p>}</p><p>//取出元素。键值对方式</p><p>Set\> entrySet = map.entrySet();</p><p><strong>for</strong> (Map.Entry\ entry : entrySet) {</p><p>Student key = entry.getKey();</p><p>String value = entry.getValue();</p><p>System.out.println(key.toString()+"....."+value);</p><p>}</p><p>}</p><p>}</p><ul><li>当给HashMap中存放自定义对象时，如果自定义对象作为key存在，这时要保证对象唯一，必须复写对象的hashCode和equals方法(如果忘记，请回顾HashSet存放自定义对象)。</li><li>如果要保证map中存放的key和取出的顺序一致，可以使用LinkedHashMap集合来存放。</li></ul><p><strong>1.1静态导入</strong></p><p>在导包的过程中我们可以直接导入静态部分，这样某个类的静态成员就可以直接使用了。在源码中经常会出现静态导入。</p><blockquote><p>静态导入格式：</p></blockquote><p>import static XXX.YYY; 导入后YYY可直接使用。</p><p>例如：Map.Entry的访问，简化后为Entry</p><p>import static java.util.Map.Entry;</p><p><strong>public class</strong> HashMapTest {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//1,创建hashmap集合对象。</p><p>Map\ map = <strong>new</strong> HashMap\();</p><p>//取出元素。键值对方式</p><p>//Set\> entrySet = map.entrySet();</p><p>Set\> entrySet = map.entrySet();</p><p>//for (Map.Entry\ entry : entrySet) {</p><p><strong>for</strong> (Entry\ entry : entrySet) {</p><p>Student key = entry.getKey();</p><p>String value = entry.getValue();</p><p>System.out.println(key.toString()+"....."+value);</p><p>}</p><p>}</p><p>}</p><p><strong>1.1可变参数</strong></p><p>在JDK1.5之后，如果我们定义一个方法需要接受多个参数，并且多个参数类型一致，我们可以对其简化成如下格式：</p><p>修饰符 返回值类型 方法名(参数类型<strong>...</strong> 形参名){ }</p><p>其实这个书写完全等价与</p><p>修饰符 返回值类型 方法名(参数类型[] 形参名){ }</p><p>只是后面这种定义，在调用时必须传递数组，而前者可以直接传递数据即可。</p><p>jdk1.5以后。出现了简化操作。<strong>...</strong> 用在参数上，称之为可变参数。</p><p>同样是代表数组，但是在调用这个带有可变参数的方法时，不用创建数组(这就是简单之处)，直接将数组中的元素作为实际参数进行传递，其实编译成的class文件，将这些元素先封装到一个数组中，在进行传递。这些动作都在编译.class文件时，自动完成了。</p><p>代码演示：</p><p><strong>public class</strong> ParamDemo {</p><p><strong>public static void</strong> main(String[] args) {</p><p><strong>int</strong>[] arr = {21,89,32};</p><p><strong>int</strong> sum = add(arr);</p><p>System.out.println(sum);</p><p>sum = add(21,89,32);//可变参数调用形式</p><p>System.out.println(sum);</p><p>}</p><p>//JDK1.5之后写法</p><p><strong>public static int</strong> add(<strong>int</strong>...arr){</p><p><strong>int</strong> sum = 0;</p><p><strong>for</strong> (<strong>int</strong> i = 0; i \&lt; arr.length; i++) {</p><p>sum += arr[i];</p><p>}</p><p><strong>return</strong> sum;</p><p>}</p><p>//原始写法</p><p>/*</p><p>public static int add(int[] arr) {</p><p>int sum = 0;</p><p>for (int i = 0; i \&lt; arr.length; i++) {</p><p>sum += arr[i];</p><p>}</p><p>return sum;</p><p>}</p><p>*/</p><p>}</p><ul><li>上述add方法在同一个类中，只能存在一个。因为会发生调用的不确定性</li></ul><p>注意：如果在方法书写时，这个方法拥有多参数，参数中包含可变参数，可变参数一定要写在参数列表的末尾位置。</p><p><strong>1.1Collections集合工具类</strong></p><p>Collections是集合工具类，用来对集合进行操作。部分方法如下：</p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/45ff50b979f8440e856522141253908b><p class=pgc-img-caption></p></div><ul><li>public static \ void sort(List\ list) // 集合元素排序</li></ul><blockquote><p>//排序前元素list集合元素 [33,11,77,55]</p><p>Collections.sort( list );</p><p>//排序后元素list集合元素 [11,33,55,77]</p></blockquote><ul><li>public static void shuffle(List\&lt;?> list) // 集合元素存储位置打乱</li></ul><blockquote><p>//list集合元素 [11,33,55,77]</p><p>Collections.shuffle( list );</p><p>//使用shuffle方法后，集合中的元素为[77,33,11,55]，每次执行该方法，集合中存储的元素位置都会随机打乱</p><p><strong>1.1集合嵌套</strong></p></blockquote><p>集合嵌套并不是一个新的知识点，仅仅是集合内容又是集合，如Collection集合嵌套、Collection集合与Map集合相互嵌套、Map集合嵌套。</p><ul><li>ArrayList嵌套 ArrayList</li></ul><p>ArrayList\&lt; ArrayList\ ></p><p>Collection\&lt; ArrayList\ ></p><ul><li>Map嵌套 ArrayList</li></ul><p>HashMap\></p><p>ArrayList\&lt; HashMap\></p><ul><li>Map集合嵌套</li></ul><p>HashMap\></p><p>HashMap\></p><p><strong>1.1集合继承体系的面向对象思想</strong></p><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c2fdd8606c2a4d37bad0268d97e1dd1c><p class=pgc-img-caption></p></div><ul><li>接口：用来明确所有集合中该具有的功能，相当于在定义集合功能标准；</li><li>抽象类：把多个集合中功能实现方式相同的方法，抽取到抽象类实现，具体集合不再遍写，继承使用即可；</li><li>具体类：继承抽象类，实现接口，重写所有抽象方法，达到具备指定功能的集合。每个具体集合类，根据自身的数据存储结构方式，对接口中的功能方法，进行不同方式的实现。</li></ul><p><strong>第2章模拟斗地主洗牌发牌</strong></p><p><strong>2.1案例介绍</strong></p><blockquote><p>按照斗地主的规则，完成洗牌发牌的动作。</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dd627c4cff0743bb8298dc933eab5d16><p class=pgc-img-caption></p></div><blockquote><p>具体规则：</p><p>组装54张扑克牌</p><p>将54张牌顺序打乱</p><p>三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。</p><p>查看三人各自手中的牌（按照牌的大小排序）、底牌</p></blockquote><ul><li>手中扑克牌从大到小的摆放顺序：大王,小王,2,A,K,Q,J,10,9,8,7,6,5,4,3</li></ul><p><strong>2.1案例需求分析</strong></p><ul><li>准备牌：</li></ul><blockquote><p>完成数字与纸牌的映射关系：</p><p>使用双列Map(HashMap)集合，完成一个数字与字符串纸牌的对应关系(相当于一个字典)。</p></blockquote><ul><li>洗牌：</li></ul><blockquote><p>通过数字完成洗牌发牌</p></blockquote><ul><li>发牌：</li></ul><blockquote><p>将每个人以及底牌设计为ArrayList\,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。</p><p>存放的过程中要求数字大小与斗地主规则的大小对应。</p><p>将代表不同纸牌的数字分配给不同的玩家与底牌。</p></blockquote><ul><li>看牌：</li></ul><blockquote><p>通过Map集合找到对应字符展示。</p><p>通过查询纸牌与数字的对应关系，由数字转成纸牌字符串再进行展示。</p></blockquote><div class=pgc-img><img alt=Map接口概述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/18a34b7a85aa43809507702b8600a07d><p class=pgc-img-caption></p></div><p><strong>2.1实现代码步骤</strong></p><p>首先，要修改java文件编码，由GBK修改为UTF-8，因为默认的字符编码GBK没有我们要的梅花、方片、黑桃、红桃(♠♥♦♣)等特殊字符。</p><p><strong>import</strong> java.util.ArrayList;</p><p><strong>import</strong> java.util.Collections;</p><p><strong>import</strong> java.util.HashMap;</p><p>/*</p><p>* 斗地主洗牌发牌排序</p><p>*/</p><p><strong>public class</strong> Poker {</p><p><strong>public static void</strong> main(String[] args) {</p><p>//准备花色</p><p>ArrayList\ color = <strong>new</strong> ArrayList\();</p><p>color.add("♠");</p><p>color.add("♥");</p><p>color.add("♦");</p><p>color.add("♣");</p><p>//准备数字</p><p>ArrayList\ number = <strong>new</strong> ArrayList\();</p><p>Collections.addAll(number,"3","4","5","6","7","8","9","10","J","Q","K","A","2");</p><p>//定义一个map集合：用来将数字与每一张牌进行对应</p><p>HashMap\ map = <strong>new</strong> HashMap\();</p><p><strong>int</strong> index = 0;</p><p><strong>for</strong> (String thisNumber : number) { //1-13</p><p><strong>for</strong> (String thisColor : color) { //1-4</p><p>map.put(index++, thisColor+thisNumber);</p><p>}</p><p>}</p><p>//加入大小王</p><p>map.put(index++, "小☺");</p><p>map.put(index++, "大☻");</p><p>//一副54张的牌 ArrayList里边为0-53的数的新牌</p><p>ArrayList\ cards = <strong>new</strong> ArrayList\();</p><p><strong>for</strong> (<strong>int</strong> i = 0; i \&lt;= 53; i++) {</p><p>cards.add(i);</p><p>}</p><p>//洗牌</p><p>Collections.shuffle(cards);</p><p>//创建三个玩家和底牌</p><p>ArrayList\ iPlayer = <strong>new</strong> ArrayList\();</p><p>ArrayList\ iPlayer2 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ iPlayer3 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ itCards = <strong>new</strong> ArrayList\();</p><p>//遍历这副洗好的牌，遍历过程中，将牌发到三个玩家和底牌中</p><p><strong>for</strong> (<strong>int</strong> i = 0; i \&lt; cards.size(); i++) {</p><p><strong>if</strong>(i>=51) {</p><p>iCards.add(cards.get(i));</p><p>} <strong>else</strong> {</p><p><strong>if</strong>(i%3==0) {</p><p>iPlayer.add(cards.get(i));</p><p>}<strong>else if</strong>(i%3==1) {</p><p>iPlayer2.add(cards.get(i));</p><p>}<strong>else</strong> {</p><p>iPlayer3.add(cards.get(i));</p><p>}</p><p>}</p><p>}</p><p>//对每个人手中的牌排序</p><p>Collections.sort(iPlayer);</p><p>Collections.sort(iPlayer2);</p><p>Collections.sort(iPlayer3);</p><p>//对应数字形式的每个人手中的牌，定义字符串形式的牌</p><p>ArrayList\ sPlayer = <strong>new</strong> ArrayList\();</p><p>ArrayList\ sPlayer2 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ sPlayer3 = <strong>new</strong> ArrayList\();</p><p>ArrayList\ sCards = <strong>new</strong> ArrayList\();</p><p><strong>for</strong> (Integer key : iPlayer) {</p><p>sPlayer.add(map.get(key));</p><p>}</p><p><strong>for</strong> (Integer key : iPlayer2) {</p><p>sPlayer2.add(map.get(key));</p><p>}</p><p><strong>for</strong> (Integer key : iPlayer3) {</p><p>sPlayer3.add(map.get(key));</p><p>}</p><p><strong>for</strong> (Integer key : iCards) {</p><p>sCards.add(map.get(key));</p><p>}</p><p>//看牌</p><p>System.out.println(sPlayer);</p><p>System.out.println(sPlayer2);</p><p>System.out.println(sPlayer3);</p><p>System.out.println(sCards);</p><p>}</p><p>}</p><p><strong>第3章总结</strong></p><p><strong>3.1知识点总结</strong></p><p>3.HashMap和Hashtable有什么区别？</p><p>HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不 同点：</p><p>HashMap允许键和值是null，而Hashtable不允许键或者值是null。</p><p>Hashtable是同步的，而HashMap不是。因此，HashMap更适合於单线程环境，而Hashtable 适合于多线程环境。</p><p>HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面， Hashtable提供了对键的列举(Enumeration)。</p><p>一般认为Hashtable是一个遗留的类。</p><ul><li>Map集合:</li></ul><p>map集合中的元素都是成对出现，成对存储的</p><p>map集合中的元素都是以一对键和值的形式组成存在的，称为键值对，理解为夫妻对</p><p>map集合中的键不能重复存储，值可以重复</p><p>map集合中的每一个键 对应着一个值</p><ul><li>方法：</li></ul><blockquote><p>V put(K key, V value) 把指定的键与指定的值添加到Map集合中</p><p>V remove(Object key) 把指定的键 所对应的键值对元素 在Map集合中删除，返回被删除元素的值</p><p>Set\> entrySet() 获取到Map集合中所有的键值对对象的集合(Set集合)</p><p>V get(Object key) 根据指定的键，在Map集合中获取对应的值</p><p>Set\ keySet() 获取Map集合中所有的键，存储到Set集合中</p></blockquote><ul><li>Map集合遍历的两种方式方式1：根据键找值的方式</li></ul><p>//a, 获取到Map集合中所有的键，返回对应的Set集合</p><p>//b, 遍历键的集合，获取到每一个键</p><p>//c, 通过键，找到对应的值</p><p>//获取到Map集合中所有的键，返回对应的Set集合</p><p>Set\ keys = map.keySet();</p><p>//遍历键的集合，获取到每一个键</p><p>for (String key : keys) {</p><p>//通过键，找到对应的值</p><p>Student s = map.get(key);</p><p>System.out.println( key + "..." + s.getName() + "..." + s.getAge() );</p><p>}</p><ul><li>方式2：根据键值对对象找键和值的方式</li></ul><p>//a, 获取Map集合中所有的键值对元素,返回对应的Set集合</p><p>//b, 遍历键值对元素集合，获取到每一个键值对元素对象</p><p>//c, 通过键值对元素对象，获取对应的键，和对应的值</p><p>//获取Map集合中所有的键值对元素,返回对应的Set集合</p><p>Set\&lt; Map.Entry\> entrySet = map.entrySet();</p><p>//遍历键值对元素集合，获取到每一个键值对元素对象</p><p>for (Map.Entry\ entry : entrySet) {</p><p>//通过键值对元素对象，获取对应的键，和对应的值</p><p>//找键</p><p>String key = entry.getKey();</p><p>//找值</p><p>Student s = entry.getValue();</p><p>//打印</p><p>System.out.println( key+"..."+s.getName()+"..."+s.getAge() );</p><p>}</p><ul><li>HashMap:特点：</li></ul><p>是Map集合的子集合</p><p>底层采用哈希表结构</p><p>HashMap集合中的key不能重复，通过重写hashCode() 与 equals()方法来保证键的唯一。</p><p>不能保证元素存与取的顺序完全一致</p><ul><li>LinkedHashMap:特点：</li></ul><blockquote><p>是HashMap集合的子集合</p><p>底层采用哈希表+链表结构</p><p>LinkedHashMap集合中的key不能重复，通过重写hashCode() 与 equals()方法来保证键的唯一。</p></blockquote><ul><li>Collections中的方法：</li></ul><p>public static \ void sort(List\ list) 排序</p><p>public static void shuffle(List\&lt;?> list) 集合中的元素存储位置随机打乱</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Map','接口','概述'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>