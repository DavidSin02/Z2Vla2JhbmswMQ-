<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>ä½ çš„redisåˆ†å¸ƒå¼å¯é‡å…¥é”æ˜¯æ€ä¹ˆè®¾è®¡çš„(pythonå®ç°ï¼‰ | æå®¢å¿«è¨Š</title><meta property="og:title" content="ä½ çš„redisåˆ†å¸ƒå¼å¯é‡å…¥é”æ˜¯æ€ä¹ˆè®¾è®¡çš„(pythonå®ç°ï¼‰ - æå®¢å¿«è¨Š"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/19325eb39de0464e81ae82d3555d1126"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="ä½ çš„redisåˆ†å¸ƒå¼å¯é‡å…¥é”æ˜¯æ€ä¹ˆè®¾è®¡çš„(pythonå®ç°ï¼‰"><meta name=author content="æå®¢å¿«è¨Š"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d7f6ac99.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>ğŸ¤“ æå®¢å¿«è®¯ Geek Bank</a></h1><p class=description>ä¸ºä½ å¸¦æ¥æœ€å…¨çš„ç§‘æŠ€çŸ¥è¯† ğŸ§¡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>çŒœä½ å–œæ­¡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=ç§‘æŠ€>ç§‘æŠ€</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=éŠæˆ²>éŠæˆ²</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=ç§‘å­¸>ç§‘å­¸</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>ä½ çš„redisåˆ†å¸ƒå¼å¯é‡å…¥é”æ˜¯æ€ä¹ˆè®¾è®¡çš„(pythonå®ç°ï¼‰</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>ç§‘æŠ€</a></span></div><div class=post-content><h1 class=pgc-h-center-line>åŸºæœ¬æ¦‚å¿µ</h1><p><br></p><ul><li>åˆ†å¸ƒå¼é”</li></ul><p><br></p><p>åˆ†å¸ƒå¼é”æ˜¯æ§åˆ¶åˆ†å¸ƒå¼ç³»ç»Ÿä¹‹é—´åŒæ­¥è®¿é—®å…±äº«èµ„æºçš„ä¸€ç§æ–¹å¼ã€‚åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­ï¼Œå¸¸å¸¸éœ€è¦åè°ƒä»–ä»¬çš„åŠ¨ä½œã€‚å¦‚æœä¸åŒçš„ç³»ç»Ÿæˆ–æ˜¯åŒä¸€ä¸ªç³»ç»Ÿçš„ä¸åŒä¸»æœºä¹‹é—´å…±äº«äº†ä¸€ä¸ªæˆ–ä¸€ç»„èµ„æºï¼Œé‚£ä¹ˆè®¿é—®è¿™äº›èµ„æºçš„æ—¶å€™ï¼Œå¾€å¾€éœ€è¦äº’æ–¥æ¥é˜²æ­¢å½¼æ­¤å¹²æ‰°æ¥ä¿è¯ä¸€è‡´æ€§ï¼Œåœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œä¾¿éœ€è¦ä½¿ç”¨åˆ°åˆ†å¸ƒå¼é”ã€‚</p><p>åˆ†å¸ƒå¼é”ä¸€èˆ¬æœ‰ä¸‰ç§å®ç°æ–¹å¼ï¼š1. æ•°æ®åº“ä¹è§‚é”ï¼›2. åŸºäºRedisçš„åˆ†å¸ƒå¼é”ï¼›3. åŸºäºZooKeeperçš„åˆ†å¸ƒå¼é”ã€‚æœ¬æ–‡ä¸»è¦ä»‹ç»åŸºäºredisæ–¹å¼ã€‚</p><p><br></p><ul><li>å¯é‡å…¥</li></ul><p><br></p><p>å¯é‡å…¥é”æŒ‡çš„æ˜¯åŒä¸€çº¿ç¨‹ä¸­å¯é‡å¤å¯é€’å½’è°ƒç”¨çš„é”ï¼Œåœ¨å¤–å±‚ä½¿ç”¨é”ä¹‹åï¼Œåœ¨å†…å±‚ä»ç„¶å¯ä»¥ä½¿ç”¨ï¼Œå¦‚æœæ²¡æœ‰å¯é‡å…¥é”çš„æ”¯æŒï¼Œåœ¨ç¬¬äºŒæ¬¡å°è¯•è·å¾—é”æ—¶å°†ä¼šè¿›å…¥æ­»é”çŠ¶æ€ã€‚</p><p>å¯é‡å…¥é”çš„è¦ç‚¹æ˜¯å¯¹äºåŒä¸€çº¿ç¨‹å¯ä»¥å¤šæ¬¡è·å–é”ï¼Œä¸åŒçº¿ç¨‹ä¹‹é—´åŒä¸€æŠŠé”ä¸èƒ½é‡å¤è·å–ï¼Œå› æ­¤ç†è®ºä¸Šéœ€è¦ä¿å­˜é”æ‹¥æœ‰è€…çš„çº¿ç¨‹æ ‡è¯†ã€‚åœ¨Javaå’Œpythonä¸­éƒ½å¯ä»¥ç”¨ threadlocalå˜é‡åŒæ¥åŒæ­¥åŒä¸€çº¿ç¨‹ä¹‹é—´çš„èµ„æºã€‚</p><p><br></p><h1 class=pgc-h-center-line>åˆ†å¸ƒå¼é”è®¾è®¡è¦ç‚¹</h1><p><br></p><p>ä¸€ä¸ªå®Œæ•´çš„åˆ†å¸ƒå¼é”ï¼Œéœ€è¦æ»¡è¶³ä»¥ä¸‹å‡ ä¸ªæ¡ä»¶ï¼š</p><ul><li>äº’æ–¥æ€§ã€‚åœ¨ä»»æ„æ—¶åˆ»ï¼Œåªæœ‰ä¸€ä¸ªå®¢æˆ·ç«¯èƒ½æŒæœ‰é”ã€‚</li><li>ä¸ä¼šå‘ç”Ÿæ­»é”ã€‚å³ä½¿æœ‰ä¸€ä¸ªå®¢æˆ·ç«¯åœ¨æŒæœ‰é”çš„æœŸé—´å´©æºƒè€Œæ²¡æœ‰ä¸»åŠ¨è§£é”ï¼Œä¹Ÿèƒ½ä¿è¯åç»­å…¶ä»–å®¢æˆ·ç«¯èƒ½åŠ é”ã€‚è¿™å°±è¦æ±‚å¿…é¡»ä¸ºé”åŠ ä¸Šè¶…æ—¶æ—¶é—´ã€‚</li><li>å…·æœ‰å®¹é”™æ€§ã€‚åªè¦å¤§éƒ¨åˆ†çš„RedisèŠ‚ç‚¹æ­£å¸¸è¿è¡Œï¼Œå®¢æˆ·ç«¯å°±å¯ä»¥åŠ é”å’Œè§£é”ã€‚è¿™ç‚¹æ˜¯è¦æ±‚å¿…é¡»èƒ½å¤Ÿä¿è¯ç›¸å…³æ“ä½œçš„åŸå­æ€§ã€‚</li><li>è§£é“ƒè¿˜é¡»ç³»é“ƒäººã€‚åŠ é”å’Œè§£é”å¿…é¡»æ˜¯åŒä¸€ä¸ªå®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯è‡ªå·±ä¸èƒ½æŠŠåˆ«äººåŠ çš„é”ç»™è§£äº†ã€‚è¿™å°±è¦æ±‚æ¯æŠŠé”å¿…é¡»æœ‰è‡ªå·±çš„æ ‡è¯†ï¼Œåœ¨è§£é”æ—¶é€šè¿‡åˆ¤æ–­æ ‡è¯†æ¥ä¿è¯æ˜¯é‡Šæ”¾çš„è‡ªå·±çš„é”ã€‚</li></ul><p><br></p><h1 class=pgc-h-center-line>ä»£ç å®ç°</h1><p><br></p><p>Talk is cheap, show me the codeã€‚ä¸‹é¢æ˜¯ä¸€ä¸ªåˆ†å¸ƒå¼é”çš„åŸºæœ¬å®ç°ï¼š</p><pre><code>class DistributedLock(object): Â  Â """ Â   This is not a 100% reliable distributed lock implementation. It is a try best one. Â   And this distributed lock algorithm is based on the time synchronization between Â   each node. Â   But it should be enough for our project. Â   """â€‹ Â  Â def __init__(self, lock_name, expire_time=3): Â  Â  Â  Â self.name = lock_name + '_distributed_lock' Â  Â  Â  Â self.expire_time = expire_time Â  Â  Â  Â self.uuid = str(uuid.uuid4())â€‹ Â  Â @redis_exc Â  Â def __enter__(self): Â  Â  Â  Â """ Â  Â  Â   If driver is not redis, nothing will happen. Â  Â  Â   """ Â  Â  Â  Â redis_conn = driver_manager.get_global_redis_conn() Â  Â  Â  Â while True: Â  Â  Â  Â  Â  Â if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1: Â  Â  Â  Â  Â  Â  Â  Â LOG.debug('Get lock %s' % self.name) Â  Â  Â  Â  Â  Â  Â  Â break Â  Â  Â  Â  Â  Â LOG.debug('Sleep 0.1s to try to get lock %s' % self.name) Â  Â  Â  Â  Â  Â time.sleep(0.1) Â  Â  Â  Â return selfâ€‹ Â  Â @redis_exc Â  Â def __exit__(self, exc_type, exc_val, exc_tb): Â  Â  Â  Â redis_conn = driver_manager.get_global_redis_conn() Â  Â  Â  Â owner_id = redis_conn.get(self.name) Â  Â  Â  Â if owner_id == self.uuid: Â  Â  Â  Â  Â  Â redis_conn.delete(self.name) Â  Â  Â  Â  Â  Â LOG.debug('Release lock %s' % self.name) Â  Â  Â  Â else: Â  Â  Â  Â  Â  Â LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name) Â  Â  Â  Â return</code></pre><p><br></p><p>å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬åŠ é”å°±ä¸€è¡Œä»£ç ï¼šredis_conn.set(self.name, self.uuid, ex=self.expire_time, nx=True)ï¼Œè¿™ä¸ªset()æ–¹æ³•ä¸€å…±æœ‰äº”ä¸ªå½¢å‚ï¼š</p><ul><li>ç¬¬ä¸€ä¸ªä¸ºkeyï¼Œè¡¨ç¤ºé”çš„å”¯ä¸€æ€§æ ‡è¯†ã€‚</li><li>ç¬¬äºŒä¸ªä¸ºvalueï¼Œæˆ‘ä»¬ä¼ çš„æ˜¯uuidï¼Œå¾ˆå¤šç«¥é‹å¯èƒ½ä¸æ˜ç™½ï¼Œæœ‰keyä½œä¸ºé”ä¸å°±å¤Ÿäº†å—ï¼Œä¸ºä»€ä¹ˆè¿˜è¦ç”¨åˆ°valueï¼ŸåŸå› å°±æ˜¯æˆ‘ä»¬åœ¨ä¸Šé¢è®²åˆ°å¯é æ€§æ—¶ï¼Œåˆ†å¸ƒå¼é”è¦æ»¡è¶³ç¬¬å››ä¸ªæ¡ä»¶è§£é“ƒè¿˜é¡»ç³»é“ƒäººï¼Œé€šè¿‡ç»™valueèµ‹å€¼ä¸ºuuidï¼Œæˆ‘ä»¬å°±çŸ¥é“è¿™æŠŠé”æ˜¯å“ªä¸ªè¯·æ±‚åŠ çš„äº†ï¼Œåœ¨è§£é”çš„æ—¶å€™å°±å¯ä»¥æœ‰ä¾æ®ã€‚</li><li>ç¬¬ä¸‰ä¸ªè¡¨ç¤ºé”çš„è¿‡æœŸæ—¶é—´ï¼Œå¦‚æœç¨‹åºå‘ç”Ÿæ„å¤–æ²¡æœ‰åŠæ—¶è§£é”ï¼Œä¹Ÿèƒ½ä¿è¯åœ¨è¶…æ—¶åå…¶ä»–è¯·æ±‚èƒ½å¤Ÿæ­£å¸¸åŠ é”</li><li>ç¬¬å››ä¸ªnx=Trueï¼Œæ„æ€æ˜¯SET IF NOT EXISTï¼Œå³å½“keyä¸å­˜åœ¨æ—¶ï¼Œæˆ‘ä»¬è¿›è¡Œsetæ“ä½œï¼›è‹¥keyå·²ç»å­˜åœ¨ï¼Œåˆ™ä¸åšä»»ä½•æ“ä½œï¼›</li></ul><p>æ€»çš„æ¥è¯´ï¼Œæ‰§è¡Œä¸Šé¢çš„set()æ–¹æ³•å°±åªä¼šå¯¼è‡´ä¸¤ç§ç»“æœï¼š1. å½“å‰æ²¡æœ‰é”ï¼ˆkeyä¸å­˜åœ¨ï¼‰ï¼Œé‚£ä¹ˆå°±è¿›è¡ŒåŠ é”æ“ä½œï¼Œå¹¶å¯¹é”è®¾ç½®ä¸ªæœ‰æ•ˆæœŸï¼ŒåŒæ—¶valueè¡¨ç¤ºåŠ é”çš„å®¢æˆ·ç«¯ã€‚2. å·²æœ‰é”å­˜åœ¨ï¼Œä¸åšä»»ä½•æ“ä½œã€‚</p><p>å¿ƒç»†çš„ç«¥é‹å°±ä¼šå‘ç°äº†ï¼Œæˆ‘ä»¬çš„åŠ é”ä»£ç æ»¡è¶³æˆ‘ä»¬å¯é æ€§é‡Œæè¿°çš„ä¸‰ä¸ªæ¡ä»¶ã€‚é¦–å…ˆï¼Œset()åŠ å…¥äº†NXå‚æ•°ï¼Œå¯ä»¥ä¿è¯å¦‚æœå·²æœ‰keyå­˜åœ¨ï¼Œåˆ™å‡½æ•°ä¸ä¼šè°ƒç”¨æˆåŠŸï¼Œä¹Ÿå°±æ˜¯åªæœ‰ä¸€ä¸ªå®¢æˆ·ç«¯èƒ½æŒæœ‰é”ï¼Œæ»¡è¶³äº’æ–¥æ€§ã€‚å…¶æ¬¡ï¼Œç”±äºæˆ‘ä»¬å¯¹é”è®¾ç½®äº†è¿‡æœŸæ—¶é—´ï¼Œå³ä½¿é”çš„æŒæœ‰è€…åç»­å‘ç”Ÿå´©æºƒè€Œæ²¡æœ‰è§£é”ï¼Œé”ä¹Ÿä¼šå› ä¸ºåˆ°äº†è¿‡æœŸæ—¶é—´è€Œè‡ªåŠ¨è§£é”ï¼ˆå³keyè¢«åˆ é™¤ï¼‰ï¼Œä¸ä¼šå‘ç”Ÿæ­»é”ã€‚æœ€åï¼Œå› ä¸ºæˆ‘ä»¬å°†valueèµ‹å€¼ä¸ºuuidï¼Œä»£è¡¨åŠ é”çš„å®¢æˆ·ç«¯è¯·æ±‚æ ‡è¯†ï¼Œé‚£ä¹ˆåœ¨å®¢æˆ·ç«¯åœ¨è§£é”çš„æ—¶å€™å°±å¯ä»¥è¿›è¡Œæ ¡éªŒã€‚</p><p>ä¸Šé¢åˆ†å¸ƒå¼é”è§£é”é˜¶æ®µåˆ†äº†ä¸¤æ­¥ï¼Œå…ˆè·å–é”çš„owner_idï¼Œç„¶åæ ¹æ®owner_idè¿›è¡Œè§£é”åˆ¤æ–­ï¼Œå®é™…ä¸Šï¼Œä¸€èˆ¬æ¨èçš„éƒ½æ˜¯å°†ä¸¤æ­¥æ“ä½œåŸå­åŒ–ï¼Œä½¿ç”¨LUAè„šæœ¬è¿›è¡Œæ‰§è¡Œï¼Œæ­¤å¤„æš‚æ—¶æœªå¯¹æ­¤åšç›¸åº”ä¼˜åŒ–ã€‚</p><p><br></p><h1 class=pgc-h-center-line>åˆ†å¸ƒå¼é”æ”¯æŒå¯é‡å…¥</h1><p><br></p><p>ä¸Šé¢ä»‹ç»äº†ä¸€ä¸ªå®Œæ•´çš„åŸºäºredisçš„åˆ†å¸ƒå¼é”pythonå®ç°ç‰ˆæœ¬å’Œæ€è·¯ï¼Œåœ¨å®é™…åœºæ™¯ä¸­ï¼Œå¯¹åŒä¸€ä¸ªçº¿ç¨‹æˆ–è€…åç¨‹çš„åŒä¸€æŠŠé”éœ€è¦æ”¯æŒå¯é‡å…¥ï¼Œå¦‚é€’å½’è°ƒç”¨æ—¶ä¸å‘ç”Ÿæ­»é”ï¼Œä¸‹é¢å®ç°ç‰ˆæœ¬åœ¨ä¸Šè¿°çš„åˆ†å¸ƒå¼é”ä¸­è¿›è¡Œäº†ç›¸å…³ä»£ç ä¿®æ”¹ã€‚</p><pre><code>_request_store = threading.local()â€‹â€‹def _add_locker_info(lock_name, owner_uuid): Â  Â setattr(_request_store, lock_name, owner_uuid)â€‹â€‹def _get_locker_info(lock_name): Â  Â return getattr(_request_store, lock_name, None)â€‹â€‹class DistributedLock(object): Â  Â """ Â   This is not a 100% reliable distributed lock implementation. It is a try best one. Â   And this distributed lock algorithm is based on the time synchronization between Â   each node. Â   But it should be enough for our project. Â   """â€‹ Â  Â def __init__(self, lock_name, expire_time=3): Â  Â  Â  Â self.name = lock_name + '_distributed_lock' Â  Â  Â  Â self.expire_time = expire_time Â  Â  Â  Â self.uuid = str(uuid.uuid4())â€‹ Â  Â @redis_exc Â  Â def __enter__(self): Â  Â  Â  Â """ Â  Â  Â   If driver is not redis, nothing will happen. Â  Â  Â   """ Â  Â  Â  Â redis_conn = driver_manager.get_global_redis_conn() Â  Â  Â  Â while True: Â  Â  Â  Â  Â  Â if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1: Â  Â  Â  Â  Â  Â  Â  Â _add_locker_info(self.name, self.uuid) Â  Â  Â  Â  Â  Â  Â  Â LOG.debug('Get lock %s' % self.name) Â  Â  Â  Â  Â  Â  Â  Â break Â  Â  Â  Â  Â  Â if _get_locker_info(self.name): Â  Â  Â  Â  Â  Â  Â  Â LOG.debug('Get re-entrant lock %s' % self.name) Â  Â  Â  Â  Â  Â  Â  Â break Â  Â  Â  Â  Â  Â LOG.debug('Sleep 0.1s to try to get lock %s' % self.name) Â  Â  Â  Â  Â  Â time.sleep(0.1) Â  Â  Â  Â return selfâ€‹ Â  Â @redis_exc Â  Â def __exit__(self, exc_type, exc_val, exc_tb): Â  Â  Â  Â redis_conn = driver_manager.get_global_redis_conn() Â  Â  Â  Â owner_id = redis_conn.get(self.name) Â  Â  Â  Â if owner_id == self.uuid: Â  Â  Â  Â  Â  Â redis_conn.delete(self.name) Â  Â  Â  Â  Â  Â LOG.debug('Release lock %s' % self.name) Â  Â  Â  Â elif owner_id == _get_locker_info(self.name): Â  Â  Â  Â  Â  Â LOG.debug('Quit from re-entrant lock %s, do nothing ' % self.name) Â  Â  Â  Â else: Â  Â  Â  Â  Â  Â LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name) Â  Â  Â  Â return</code></pre><p>python çš„threadlocalå˜é‡å’ŒJavaä¸­ç±»ä¼¼ï¼Œå¯¹åŒä¸€ä¸ªçº¿ç¨‹ä¸­çš„å˜é‡è¿›è¡Œéš”ç¦»ï¼Œå› æ­¤å¯¹å¯é‡å…¥é”çš„æ”¯æŒåªéœ€è¦åˆ¤æ–­ä¸‹å½“å‰çº¿ç¨‹ä¸­æ˜¯å¦å·²ç»æœ‰è¿™æŠŠé”ï¼Œå¦‚æœæœ‰ï¼Œåˆ™ç›´æ¥è¿”å›ï¼Œå¦åˆ™è¿›è¡Œç­‰å¾…é”é‡Šæ”¾æˆ–è€…è¶…æ—¶ã€‚</p><p><br></p><h1 class=pgc-h-center-line>æ³¨æ„ç‚¹</h1><p><br></p><ul><li>threadlocalä¸­çš„å†…å­˜ä¸ä¸»åŠ¨é‡Šæ”¾ï¼Œä¼šä¸ä¼šå†…å­˜æ³„æ¼ï¼Ÿ</li></ul><p>ä¸ä¼šï¼Œå› ä¸ºæ¯ä¸ªçº¿ç¨‹å¯¹åº”ä¸€ä¸ªå‰¯æœ¬å­—å…¸ï¼Œå½“åœ¨è¯¥çº¿ç¨‹ä¸­ è·å–ã€è®¾ç½®ã€åˆ é™¤ ThreadLocalå¯¹è±¡çš„å±æ€§æ—¶ï¼Œä¼šå…ˆé€šè¿‡_patchå‡½æ•°ï¼Œå°†çº¿ç¨‹çš„å‰¯æœ¬å­—å…¸ï¼Œè®¾ç½®æˆThreadLocalå¯¹è±¡çš„å±æ€§å­—å…¸ï¼Œç„¶åå¯¹ThreadLocalå¯¹è±¡çš„å±æ€§çš„æ“ä½œï¼Œå®é™…ä¸Šå°±æ˜¯å¯¹å‰¯æœ¬å­—å…¸çš„æ“ä½œã€‚å½“çº¿ç¨‹ç»“æŸï¼Œçº¿ç¨‹å¯¹è±¡è¢«é”€æ¯æ—¶ï¼Œå‰¯æœ¬å­—å…¸çš„å¼•ç”¨è®¡æ•°ä¹Ÿä¼šéšä¹‹å‡å°‘ï¼Œæœ€åè¢«GCæ‰ã€‚</p><ul><li>å¯é‡å…¥é”çš„counterè®¡æ•°</li></ul><p>ä¸€èˆ¬çš„è®¾è®¡ä¸­éƒ½ä¼šå¯¹å¯é‡å…¥é”ç»´æŠ¤ä¸€ä¸ªcounterè®¡æ•°ï¼Œä¹Ÿå°±æ˜¯åœ¨counterå°äºç­‰äº0æ—¶è¿›è¡Œé‡Šæ”¾ï¼Œç”±äºè€ƒè™‘åˆ°è‡ªå¢è‡ªå‡æ“ä½œçš„éåŸå­æ€§ï¼Œæ²¡æœ‰é€šè¿‡counterå€¼è¿›è¡Œé”é‡Šæ”¾ï¼Œè€Œæ˜¯é‡‡ç”¨è°ä¸€å¼€å§‹åˆ›å»ºé”ï¼Œå°±æœ€ååˆ é™¤é”ã€‚å¯é‡å…¥é”çš„å¤šæ¬¡é‡å…¥è¡¨ç°ä¸ºå †æ ˆï¼Œåå…¥å…ˆå‡ºï¼Œä¹Ÿå°±æ˜¯è¯´æœ‰ä¸€å¼€å§‹åŠ é”çš„å¯¹è±¡è¿›è¡Œé”åˆ é™¤å³å¯ã€‚</p><ul><li>å…³äºthreadlocalçš„çº¿ç¨‹éš”ç¦»</li></ul><p>å¾ˆå¤šæƒ…å†µä¸‹éƒ½æ˜¯åœ¨åŒä¸€ä¸ªè¿›ç¨‹ä¸­èµ·ä¸åŒçš„åç¨‹å»å¤„ç†APIè¯·æ±‚ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸åŒçš„APIè¯·æ±‚æ˜¯æœ‰å¯èƒ½åœ¨åŒä¸€ä¸ªçº¿ç¨‹ä¸­çš„ï¼Œå®é™…æµ‹è¯•ä¹ŸéªŒè¯äº†è¿™ä¸€ç‚¹ã€‚å¦‚ä¸‹æ‰“å°çš„æ—¥å¿—ï¼Œæ€»å…±æœ‰ä¸‰æ¬¡APIè¯·æ±‚ï¼Œä½†æ˜¯çº¿ç¨‹å·æ˜¯ä¸€æ ·çš„ã€‚</p><pre><code>classÂ DistributedLock(object):Â  Â """Â  This is not a 100% reliable distributed lock implementation. It is a try best one.Â  And this distributed lock algorithm is based on the time synchronization betweenÂ  each node.Â  But it should be enough for our project.Â  """Â  Â defÂ __init__(self,Â lock_name,Â expire_time=3):Â  Â  Â  Â self.nameÂ =Â lock_nameÂ +Â '_distributed_lock'Â  Â  Â  Â self.expire_timeÂ =Â expire_timeÂ  Â  Â  Â self.uuidÂ =Â str(uuid.uuid4())Â  Â @redis_excÂ  Â defÂ __enter__(self):Â  Â  Â  Â """Â  Â  Â  If driver is not redis, nothing will happen.Â  Â  Â  """Â  Â  Â  Â redis_connÂ =Â driver_manager.get_global_redis_conn()Â  Â  Â  Â whileÂ True:Â  Â  Â  Â  Â  Â ifÂ redis_conn.set(self.name,Â self.uuid,Â ex=self.expire_time*2,Â nx=True) ==Â 1:Â  Â  Â  Â  Â  Â  Â  Â LOG.debug('Get lock %s'Â %Â self.name)Â  Â  Â  Â  Â  Â  Â  Â breakÂ  Â  Â  Â  Â  Â LOG.debug('Sleep 0.1s to try to get lock %s'Â %Â self.name)Â  Â  Â  Â  Â  Â time.sleep(0.1)Â  Â  Â  Â returnÂ selfÂ  Â @redis_excÂ  Â defÂ __exit__(self,Â exc_type,Â exc_val,Â exc_tb):Â  Â  Â  Â redis_connÂ =Â driver_manager.get_global_redis_conn()Â  Â  Â  Â owner_idÂ =Â redis_conn.get(self.name)Â  Â  Â  Â ifÂ owner_idÂ ==Â self.uuid:Â  Â  Â  Â  Â  Â redis_conn.delete(self.name)Â  Â  Â  Â  Â  Â LOG.debug('Release lock %s'Â %Â self.name)Â  Â  Â  Â else:Â  Â  Â  Â  Â  Â LOG.warning('Transaction locked by distributed lock %s need larger expire time'Â %Â self.name)Â  Â  Â  Â return</code></pre><p>å¦‚æœä»çº¿ç¨‹å‡ºå‘ï¼Œthreadlocalçš„è¡¨ç°åº”è¯¥æ˜¯åœ¨åŒä¸€ä¸ªçº¿ç¨‹å†…æ•°æ®å…±äº«ï¼Œå¦‚æœæ²¡æœ‰ä¸»åŠ¨åˆ é™¤æ•°æ®ï¼Œåˆ™åœ¨çº¿ç¨‹æ¶ˆäº¡æ—¶é‡Šæ”¾å†…å­˜ã€‚ç”±äºåœ¨åŠ é”å’Œè§£é”æ—¶å¹¶æ²¡æœ‰ä¸»åŠ¨åˆ é™¤threadlocalä¸­çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯è¯´åŒä¸€ä¸ªçº¿ç¨‹ä¸­çš„æ•°æ®åº”è¯¥æ˜¯ä¼šç´¯åŠ çš„ï¼Œä½†æ˜¯å®é™…ä¸Šæ²¡æœ‰ï¼Œæ—¥å¿—å¦‚ä¸‹ï¼š</p><pre><code>2020-05-14 08:29:06.808 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-7abbea26-d87b-4804-8003-36b723471c6e 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': '7ccfe267-6fce-4ada-9b88-c85de4da8f76', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '073547c0-53d1-477d-ae64-d41dfe992d5b'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.006 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.122 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '32eb9ab3-7e54-4439-bbd0-1ee183aac29d'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.199 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'e840a917-c2d5-414a-8ad1-a9965d654e12_vgw01_distributed_lock': 'b5b14883-9786-484a-860c-82a1a5672744', 'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '32eb9ab3-7e54-4439-bbd0-1ee183aac29d'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:42:33.291 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-4bfc56b5-c3db-4288-a1c3-a993bcf7a3a3 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'fa7ed1b1-a9dc-416b-8419-3043a1c92100'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:42:33.424 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-4bfc56b5-c3db-4288-a1c3-a993bcf7a3a3 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'e840a917-c2d5-414a-8ad1-a9965d654e12_vgw01_distributed_lock': '67741a6a-b89b-4c7f-ad4e-9ae40455f20a', 'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'fa7ed1b1-a9dc-416b-8419-3043a1c92100'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:104</code></pre><p><strong>threadlocalåç¨‹éš”ç¦»</strong></p><p>è¡¨ç°çš„è¡Œä¸ºæ˜¯åç¨‹éš”ç¦»ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸¤ä¸ªAPIè¯·æ±‚è™½ç„¶å¤„äºåŒä¸€ä¸ªçº¿ç¨‹å†…ï¼Œä½†æ˜¯å¹¶æ²¡æœ‰å…±äº«threadlocalçš„æ•°æ®ã€‚</p><p>é€šè¿‡å®šä½åå‘ç°åœ¨é¡¹ç›®çš„eventletæ¨¡å—ä¸­å¯¹é€šè¿‡monkey_patchæ–¹å¼å¯¹åŸç”Ÿçš„threading.localè¿›è¡Œäº†æ”¹å†™ï¼Œåœ¨åŸç”Ÿçš„threading.local é€šè¿‡å¦‚ä¸‹çš„å‡½æ•°è·å–å½“å‰çš„çº¿ç¨‹å·</p><pre><code>def currentThread(): Â  Â """Return the current Thread object, corresponding to the caller's thread of control.â€‹ Â   If the caller's thread of control was not created through the threading Â   module, a dummy thread object with limited functionality is returned.â€‹ Â   """ Â  Â try: Â  Â  Â  Â return _active[_get_ident()] Â  Â except KeyError: Â  Â  Â  Â ##print "current_thread(): no current thread for", _get_ident() Â  Â  Â  Â return _DummyThread()# è·å–çº¿ç¨‹å·å‡½æ•° Â  Â  Â  Â _get_ident = thread.get_ident</code></pre><p>åœ¨eventletåº“ä¸­å¯¹è¯¥å‡½æ•°è¿›è¡Œäº†æ”¹å†™ï¼Œå‡½æ•°currentThreadè·å–åˆ°çš„æ˜¯åç¨‹å·ï¼Œå¦‚ä¸‹ï¼š</p><pre><code>def current_thread(): Â  Â g = greenlet.getcurrent() Â  Â if not g: Â  Â  Â  Â # Not currently in a greenthread, fall back to standard function Â  Â  Â  Â return _fixup_thread(__orig_threading.current_thread())â€‹ Â  Â try: Â  Â  Â  Â active = __threadlocal.active Â  Â except AttributeError: Â  Â  Â  Â active = __threadlocal.active = {}â€‹ Â  Â try: Â  Â  Â  Â t = active[id(g)] Â  Â except KeyError: Â  Â  Â  Â # Add green thread to active if we can clean it up on exit Â  Â  Â  Â def cleanup(g): Â  Â  Â  Â  Â  Â del active[id(g)] Â  Â  Â  Â try: Â  Â  Â  Â  Â  Â g.link(cleanup) Â  Â  Â  Â except AttributeError: Â  Â  Â  Â  Â  Â # Not a GreenThread type, so there's no way to hook into Â  Â  Â  Â  Â  Â # the green thread exiting. Fall back to the standard Â  Â  Â  Â  Â  Â # function then. Â  Â  Â  Â  Â  Â t = _fixup_thread(__orig_threading.currentThread()) Â  Â  Â  Â else: Â  Â  Â  Â  Â  Â t = active[id(g)] = _GreenThread(g)â€‹ Â  Â return t</code></pre><p>æœ€ç»ˆè°ƒç”¨çš„å¦‚ä¸‹greenletåº“ä¸­çš„getcurrentè·å–å½“å‰åç¨‹æ ‡è¯†</p><pre><code> greenlet.getcurrent() ã€€ã€€Returns the current greenlet (i.e. the one which called this function).ã€€ã€€è¿”å›å½“å‰greenletï¼Œä¹Ÿå°±æ˜¯è°åœ¨è°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚</code></pre><p>ç›¸å…³patchå‡½æ•°åœ¨/neutron/common/eventlet_utils.pyã€‚</p><p><br></p><h1 class=pgc-h-center-line>é™„å½•ï¼špython threading.RLockæºç </h1><p><br></p><pre><code>_allocate_lock = thread.allocate_lock_get_ident = thread.get_identLock = _allocate_lockâ€‹def RLock(*args, **kwargs): Â  Â """Factory function that returns a new reentrant lock.â€‹ Â   A reentrant lock must be released by the thread that acquired it. Once a Â   thread has acquired a reentrant lock, the same thread may acquire it again Â   without blocking; the thread must release it once for each time it has Â   acquired it.â€‹ Â   """ Â  Â return _RLock(*args, **kwargs)â€‹class _RLock(_Verbose): Â  Â """A reentrant lock must be released by the thread that acquired it. Once a Â  Â  Â  thread has acquired a reentrant lock, the same thread may acquire it Â  Â  Â  again without blocking; the thread must release it once for each time it Â  Â  Â  has acquired it. Â   """â€‹ Â  Â def __init__(self, verbose=None): Â  Â  Â  Â _Verbose.__init__(self, verbose) Â  Â  Â  Â self.__block = _allocate_lock() Â  Â  Â  Â self.__owner = None Â  Â  Â  Â self.__count = 0â€‹ Â  Â def __repr__(self): Â  Â  Â  Â owner = self.__owner Â  Â  Â  Â try: Â  Â  Â  Â  Â  Â owner = _active[owner].name Â  Â  Â  Â except KeyError: Â  Â  Â  Â  Â  Â pass Â  Â  Â  Â return "&lt;%s owner=%r count=%d&gt;" % ( Â  Â  Â  Â  Â  Â  Â  Â self.__class__.__name__, owner, self.__count)â€‹ Â  Â def acquire(self, blocking=1): Â  Â  Â  Â """Acquire a lock, blocking or non-blocking.â€‹ Â  Â  Â   When invoked without arguments: if this thread already owns the lock, Â  Â  Â   increment the recursion level by one, and return immediately. Otherwise, Â  Â  Â   if another thread owns the lock, block until the lock is unlocked. Once Â  Â  Â   the lock is unlocked (not owned by any thread), then grab ownership, set Â  Â  Â   the recursion level to one, and return. If more than one thread is Â  Â  Â   blocked waiting until the lock is unlocked, only one at a time will be Â  Â  Â   able to grab ownership of the lock. There is no return value in this Â  Â  Â   case.â€‹ Â  Â  Â   When invoked with the blocking argument set to true, do the same thing Â  Â  Â   as when called without arguments, and return true.â€‹ Â  Â  Â   When invoked with the blocking argument set to false, do not block. If a Â  Â  Â   call without an argument would block, return false immediately; Â  Â  Â   otherwise, do the same thing as when called without arguments, and Â  Â  Â   return true.â€‹ Â  Â  Â   """ Â  Â  Â  Â me = _get_ident() Â  Â  Â  Â if self.__owner == me: Â  Â  Â  Â  Â  Â self.__count = self.__count + 1 Â  Â  Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â  Â  Â self._note("%s.acquire(%s): recursive success", self, blocking) Â  Â  Â  Â  Â  Â return 1 Â  Â  Â  Â rc = self.__block.acquire(blocking) Â  Â  Â  Â if rc: Â  Â  Â  Â  Â  Â self.__owner = me Â  Â  Â  Â  Â  Â self.__count = 1 Â  Â  Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â  Â  Â self._note("%s.acquire(%s): initial success", self, blocking) Â  Â  Â  Â else: Â  Â  Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â  Â  Â self._note("%s.acquire(%s): failure", self, blocking) Â  Â  Â  Â return rcâ€‹ Â  Â __enter__ = acquireâ€‹ Â  Â def release(self): Â  Â  Â  Â """Release a lock, decrementing the recursion level.â€‹ Â  Â  Â   If after the decrement it is zero, reset the lock to unlocked (not owned Â  Â  Â   by any thread), and if any other threads are blocked waiting for the Â  Â  Â   lock to become unlocked, allow exactly one of them to proceed. If after Â  Â  Â   the decrement the recursion level is still nonzero, the lock remains Â  Â  Â   locked and owned by the calling thread.â€‹ Â  Â  Â   Only call this method when the calling thread owns the lock. A Â  Â  Â   RuntimeError is raised if this method is called when the lock is Â  Â  Â   unlocked.â€‹ Â  Â  Â   There is no return value.â€‹ Â  Â  Â   """ Â  Â  Â  Â if self.__owner != _get_ident(): Â  Â  Â  Â  Â  Â raise RuntimeError("cannot release un-acquired lock") Â  Â  Â  Â self.__count = count = self.__count - 1 Â  Â  Â  Â if not count: Â  Â  Â  Â  Â  Â self.__owner = None Â  Â  Â  Â  Â  Â self.__block.release() Â  Â  Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â  Â  Â self._note("%s.release(): final release", self) Â  Â  Â  Â else: Â  Â  Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â  Â  Â self._note("%s.release(): non-final release", self)â€‹ Â  Â def __exit__(self, t, v, tb): Â  Â  Â  Â self.release()â€‹ Â  Â # Internal methods used by condition variablesâ€‹ Â  Â def _acquire_restore(self, count_owner): Â  Â  Â  Â count, owner = count_owner Â  Â  Â  Â self.__block.acquire() Â  Â  Â  Â self.__count = count Â  Â  Â  Â self.__owner = owner Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â self._note("%s._acquire_restore()", self)â€‹ Â  Â def _release_save(self): Â  Â  Â  Â if __debug__: Â  Â  Â  Â  Â  Â self._note("%s._release_save()", self) Â  Â  Â  Â count = self.__count Â  Â  Â  Â self.__count = 0 Â  Â  Â  Â owner = self.__owner Â  Â  Â  Â self.__owner = None Â  Â  Â  Â self.__block.release() Â  Â  Â  Â return (count, owner)â€‹ Â  Â def _is_owned(self): Â  Â  Â  Â return self.__owner == _get_ident()</code></pre><p><br></p><ul><li>ç®€å•åˆ†æ</li></ul><p>pythonæºç ä¸­çš„å¯é‡å…¥é”ç›¸å¯¹ç®€å•ï¼ŒåŠ é”éƒ¨åˆ†ï¼Œç¬¬ä¸€æ¬¡è·å–é”æ—¶ä¿å­˜é”çš„çº¿ç¨‹æ ‡è¯†ï¼Œåç»­å†æ¬¡è·å–é”ï¼Œå…ˆçœ‹æ˜¯å¦æ˜¯åŒä¸€ä¸ªçº¿ç¨‹ï¼Œå¦‚æœæ˜¯çš„è¯åªå¯¹é”è®¡æ•°è¿›è¡Œé€’å¢ã€‚è§£é”æ—¶ï¼Œå¯¹é”è®¡æ•°è¿›è¡Œé€’å‡ï¼Œå¦‚æœè®¡æ•°ä¸º0ï¼Œæœ€ç»ˆé‡Šæ”¾é”ã€‚</p><p>éœ€è¦æ³¨æ„çš„æ˜¯éœ€è¦å…ˆåˆå§‹åŒ–ç±»ï¼Œåç»­åŠ é”è§£é”éƒ½åº”ä½¿ç”¨åŒä¸€ä¸ªå¯¹è±¡ï¼Œè€Œä¸èƒ½æ¯æ¬¡åŠ é”å’Œè§£é”ä½¿ç”¨æ–°çš„RLockå¯¹è±¡ï¼Œè¿™æ ·ä¼šå¯¼è‡´ownerä¿¡æ¯å’Œcountä¿¡æ¯æ²¡æœ‰åˆå§‹åŒ–ã€‚è¿™ä¸ªé—®é¢˜æœ¬è´¨ä¸Šæ˜¯çº¿ç¨‹å˜é‡åŒæ­¥çš„é—®é¢˜ã€‚</p><p><br></p><h1 class=pgc-h-center-line>å‚è€ƒæ–‡æ¡£</h1><ul><li>https://www.cnblogs.com/linjiqin/p/8003838.html</li><li>https://segmentfault.com/a/1190000021199037</li><li>https://github.com/yangfeixxx/python_redis</li><li>https://leaveslm.github.io/2018/08/08/2018-2018-08-08-åŸºäº-Redis-å®ç°å¯é‡å…¥åˆ†å¸ƒå¼é”/</li><li>https://www.cnblogs.com/xybaby/p/6420873.html</li></ul><p><br></p><div class=pgc-img><img alt=ä½ çš„redisåˆ†å¸ƒå¼å¯é‡å…¥é”æ˜¯æ€ä¹ˆè®¾è®¡çš„(pythonå®ç°ï¼‰ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19325eb39de0464e81ae82d3555d1126><p class=pgc-img-caption>å…³äºå¾®ä¿¡æœ‰æ›´å¤šç²¾å½©</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'redis','é‡å…¥é”','æ€ä¹ˆ'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=æœç´¢>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>ğŸ”</button></form></section><section class=widget><h3 class=widget-title>æœ€æ–°æ–‡ç«  âš¡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>å…¶ä»–</h3><ul class=widget-list><li><a href=TOS.html>ä½¿ç”¨æ¢æ¬¾</a></li><li><a href=CommentPolicy.html>ç•™è¨€æ”¿ç­–</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>è¯çµ¡æˆ‘å€‘</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>æå®¢å¿«è¨Š</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>