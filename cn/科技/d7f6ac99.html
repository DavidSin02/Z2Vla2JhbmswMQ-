<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你的redis分布式可重入锁是怎么设计的(python实现） | 极客快訊</title><meta property="og:title" content="你的redis分布式可重入锁是怎么设计的(python实现） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/19325eb39de0464e81ae82d3555d1126"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d7f6ac99.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d7f6ac99.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="你的redis分布式可重入锁是怎么设计的(python实现）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d7f6ac99.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你的redis分布式可重入锁是怎么设计的(python实现）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-center-line>基本概念</h1><p><br></p><ul><li>分布式锁</li></ul><p><br></p><p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</p><p>分布式锁一般有三种实现方式：1. 数据库乐观锁；2. 基于Redis的分布式锁；3. 基于ZooKeeper的分布式锁。本文主要介绍基于redis方式。</p><p><br></p><ul><li>可重入</li></ul><p><br></p><p>可重入锁指的是同一线程中可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，如果没有可重入锁的支持，在第二次尝试获得锁时将会进入死锁状态。</p><p>可重入锁的要点是对于同一线程可以多次获取锁，不同线程之间同一把锁不能重复获取，因此理论上需要保存锁拥有者的线程标识。在Java和python中都可以用 threadlocal变量同来同步同一线程之间的资源。</p><p><br></p><h1 class=pgc-h-center-line>分布式锁设计要点</h1><p><br></p><p>一个完整的分布式锁，需要满足以下几个条件：</p><ul><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。这就要求必须为锁加上超时时间。</li><li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。这点是要求必须能够保证相关操作的原子性。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。这就要求每把锁必须有自己的标识，在解锁时通过判断标识来保证是释放的自己的锁。</li></ul><p><br></p><h1 class=pgc-h-center-line>代码实现</h1><p><br></p><p>Talk is cheap, show me the code。下面是一个分布式锁的基本实现：</p><pre><code>class DistributedLock(object):    """    This is not a 100% reliable distributed lock implementation. It is a try best one.    And this distributed lock algorithm is based on the time synchronization between    each node.    But it should be enough for our project.    """​    def __init__(self, lock_name, expire_time=3):        self.name = lock_name + '_distributed_lock'        self.expire_time = expire_time        self.uuid = str(uuid.uuid4())​    @redis_exc    def __enter__(self):        """        If driver is not redis, nothing will happen.        """        redis_conn = driver_manager.get_global_redis_conn()        while True:            if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1:                LOG.debug('Get lock %s' % self.name)                break            LOG.debug('Sleep 0.1s to try to get lock %s' % self.name)            time.sleep(0.1)        return self​    @redis_exc    def __exit__(self, exc_type, exc_val, exc_tb):        redis_conn = driver_manager.get_global_redis_conn()        owner_id = redis_conn.get(self.name)        if owner_id == self.uuid:            redis_conn.delete(self.name)            LOG.debug('Release lock %s' % self.name)        else:            LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name)        return</code></pre><p><br></p><p>可以看到，我们加锁就一行代码：redis_conn.set(self.name, self.uuid, ex=self.expire_time, nx=True)，这个set()方法一共有五个形参：</p><ul><li>第一个为key，表示锁的唯一性标识。</li><li>第二个为value，我们传的是uuid，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为uuid，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。</li><li>第三个表示锁的过期时间，如果程序发生意外没有及时解锁，也能保证在超时后其他请求能够正常加锁</li><li>第四个nx=True，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p><p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为uuid，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验。</p><p>上面分布式锁解锁阶段分了两步，先获取锁的owner_id，然后根据owner_id进行解锁判断，实际上，一般推荐的都是将两步操作原子化，使用LUA脚本进行执行，此处暂时未对此做相应优化。</p><p><br></p><h1 class=pgc-h-center-line>分布式锁支持可重入</h1><p><br></p><p>上面介绍了一个完整的基于redis的分布式锁python实现版本和思路，在实际场景中，对同一个线程或者协程的同一把锁需要支持可重入，如递归调用时不发生死锁，下面实现版本在上述的分布式锁中进行了相关代码修改。</p><pre><code>_request_store = threading.local()​​def _add_locker_info(lock_name, owner_uuid):    setattr(_request_store, lock_name, owner_uuid)​​def _get_locker_info(lock_name):    return getattr(_request_store, lock_name, None)​​class DistributedLock(object):    """    This is not a 100% reliable distributed lock implementation. It is a try best one.    And this distributed lock algorithm is based on the time synchronization between    each node.    But it should be enough for our project.    """​    def __init__(self, lock_name, expire_time=3):        self.name = lock_name + '_distributed_lock'        self.expire_time = expire_time        self.uuid = str(uuid.uuid4())​    @redis_exc    def __enter__(self):        """        If driver is not redis, nothing will happen.        """        redis_conn = driver_manager.get_global_redis_conn()        while True:            if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1:                _add_locker_info(self.name, self.uuid)                LOG.debug('Get lock %s' % self.name)                break            if _get_locker_info(self.name):                LOG.debug('Get re-entrant lock %s' % self.name)                break            LOG.debug('Sleep 0.1s to try to get lock %s' % self.name)            time.sleep(0.1)        return self​    @redis_exc    def __exit__(self, exc_type, exc_val, exc_tb):        redis_conn = driver_manager.get_global_redis_conn()        owner_id = redis_conn.get(self.name)        if owner_id == self.uuid:            redis_conn.delete(self.name)            LOG.debug('Release lock %s' % self.name)        elif owner_id == _get_locker_info(self.name):            LOG.debug('Quit from re-entrant lock %s, do nothing ' % self.name)        else:            LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name)        return</code></pre><p>python 的threadlocal变量和Java中类似，对同一个线程中的变量进行隔离，因此对可重入锁的支持只需要判断下当前线程中是否已经有这把锁，如果有，则直接返回，否则进行等待锁释放或者超时。</p><p><br></p><h1 class=pgc-h-center-line>注意点</h1><p><br></p><ul><li>threadlocal中的内存不主动释放，会不会内存泄漏？</li></ul><p>不会，因为每个线程对应一个副本字典，当在该线程中 获取、设置、删除 ThreadLocal对象的属性时，会先通过_patch函数，将线程的副本字典，设置成ThreadLocal对象的属性字典，然后对ThreadLocal对象的属性的操作，实际上就是对副本字典的操作。当线程结束，线程对象被销毁时，副本字典的引用计数也会随之减少，最后被GC掉。</p><ul><li>可重入锁的counter计数</li></ul><p>一般的设计中都会对可重入锁维护一个counter计数，也就是在counter小于等于0时进行释放，由于考虑到自增自减操作的非原子性，没有通过counter值进行锁释放，而是采用谁一开始创建锁，就最后删除锁。可重入锁的多次重入表现为堆栈，后入先出，也就是说有一开始加锁的对象进行锁删除即可。</p><ul><li>关于threadlocal的线程隔离</li></ul><p>很多情况下都是在同一个进程中起不同的协程去处理API请求，也就是说不同的API请求是有可能在同一个线程中的，实际测试也验证了这一点。如下打印的日志，总共有三次API请求，但是线程号是一样的。</p><pre><code>class DistributedLock(object):   """  This is not a 100% reliable distributed lock implementation. It is a try best one.  And this distributed lock algorithm is based on the time synchronization between  each node.  But it should be enough for our project.  """   def __init__(self, lock_name, expire_time=3):       self.name = lock_name + '_distributed_lock'       self.expire_time = expire_time       self.uuid = str(uuid.uuid4())   @redis_exc   def __enter__(self):       """      If driver is not redis, nothing will happen.      """       redis_conn = driver_manager.get_global_redis_conn()       while True:           if redis_conn.set(self.name, self.uuid, ex=self.expire_time*2, nx=True) == 1:               LOG.debug('Get lock %s' % self.name)               break           LOG.debug('Sleep 0.1s to try to get lock %s' % self.name)           time.sleep(0.1)       return self   @redis_exc   def __exit__(self, exc_type, exc_val, exc_tb):       redis_conn = driver_manager.get_global_redis_conn()       owner_id = redis_conn.get(self.name)       if owner_id == self.uuid:           redis_conn.delete(self.name)           LOG.debug('Release lock %s' % self.name)       else:           LOG.warning('Transaction locked by distributed lock %s need larger expire time' % self.name)       return</code></pre><p>如果从线程出发，threadlocal的表现应该是在同一个线程内数据共享，如果没有主动删除数据，则在线程消亡时释放内存。由于在加锁和解锁时并没有主动删除threadlocal中的数据，也就是说同一个线程中的数据应该是会累加的，但是实际上没有，日志如下：</p><pre><code>2020-05-14 08:29:06.808 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-7abbea26-d87b-4804-8003-36b723471c6e 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': '7ccfe267-6fce-4ada-9b88-c85de4da8f76', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '073547c0-53d1-477d-ae64-d41dfe992d5b'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.006 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.122 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '32eb9ab3-7e54-4439-bbd0-1ee183aac29d'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:29:10.199 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-1570d840-244a-4373-b95e-03a799331e9a 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'e840a917-c2d5-414a-8ad1-a9965d654e12_vgw01_distributed_lock': 'b5b14883-9786-484a-860c-82a1a5672744', 'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'c4a99ed2-9afd-452f-b24d-e0cbd37c331b', 'eip_59715e2f-a30e-46c8-9ee8-1f882e43e745_distributed_lock': '32eb9ab3-7e54-4439-bbd0-1ee183aac29d'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:42:33.291 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-4bfc56b5-c3db-4288-a1c3-a993bcf7a3a3 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'fa7ed1b1-a9dc-416b-8419-3043a1c92100'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:1042020-05-14 08:42:33.424 6745 DEBUG neutron.services.vpc.common.vpc_utils [req-4bfc56b5-c3db-4288-a1c3-a993bcf7a3a3 0d1b6b9e31fa455cab2e865740ebd6e7 df68d52f6ce94bd7a152fc16d96fa6a8 - - -] show threadlocal :{'e840a917-c2d5-414a-8ad1-a9965d654e12_vgw01_distributed_lock': '67741a6a-b89b-4c7f-ad4e-9ae40455f20a', 'vif_42212f87-005c-c608-b043-14beb2214e9f_distributed_lock': 'fa7ed1b1-a9dc-416b-8419-3043a1c92100'} _add_locker_info /opt/ksc_lbaas/.venv/lib/python2.7/site-packages/neutron/services/vpc/common/vpc_utils.py:104</code></pre><p><strong>threadlocal协程隔离</strong></p><p>表现的行为是协程隔离，也就是说两个API请求虽然处于同一个线程内，但是并没有共享threadlocal的数据。</p><p>通过定位后发现在项目的eventlet模块中对通过monkey_patch方式对原生的threading.local进行了改写，在原生的threading.local 通过如下的函数获取当前的线程号</p><pre><code>def currentThread():    """Return the current Thread object, corresponding to the caller's thread of control.​    If the caller's thread of control was not created through the threading    module, a dummy thread object with limited functionality is returned.​    """    try:        return _active[_get_ident()]    except KeyError:        ##print "current_thread(): no current thread for", _get_ident()        return _DummyThread()# 获取线程号函数        _get_ident = thread.get_ident</code></pre><p>在eventlet库中对该函数进行了改写，函数currentThread获取到的是协程号，如下：</p><pre><code>def current_thread():    g = greenlet.getcurrent()    if not g:        # Not currently in a greenthread, fall back to standard function        return _fixup_thread(__orig_threading.current_thread())​    try:        active = __threadlocal.active    except AttributeError:        active = __threadlocal.active = {}​    try:        t = active[id(g)]    except KeyError:        # Add green thread to active if we can clean it up on exit        def cleanup(g):            del active[id(g)]        try:            g.link(cleanup)        except AttributeError:            # Not a GreenThread type, so there's no way to hook into            # the green thread exiting. Fall back to the standard            # function then.            t = _fixup_thread(__orig_threading.currentThread())        else:            t = active[id(g)] = _GreenThread(g)​    return t</code></pre><p>最终调用的如下greenlet库中的getcurrent获取当前协程标识</p><pre><code> greenlet.getcurrent() 　　Returns the current greenlet (i.e. the one which called this function).　　返回当前greenlet，也就是谁在调用这个函数。</code></pre><p>相关patch函数在/neutron/common/eventlet_utils.py。</p><p><br></p><h1 class=pgc-h-center-line>附录：python threading.RLock源码</h1><p><br></p><pre><code>_allocate_lock = thread.allocate_lock_get_ident = thread.get_identLock = _allocate_lock​def RLock(*args, **kwargs):    """Factory function that returns a new reentrant lock.​    A reentrant lock must be released by the thread that acquired it. Once a    thread has acquired a reentrant lock, the same thread may acquire it again    without blocking; the thread must release it once for each time it has    acquired it.​    """    return _RLock(*args, **kwargs)​class _RLock(_Verbose):    """A reentrant lock must be released by the thread that acquired it. Once a       thread has acquired a reentrant lock, the same thread may acquire it       again without blocking; the thread must release it once for each time it       has acquired it.    """​    def __init__(self, verbose=None):        _Verbose.__init__(self, verbose)        self.__block = _allocate_lock()        self.__owner = None        self.__count = 0​    def __repr__(self):        owner = self.__owner        try:            owner = _active[owner].name        except KeyError:            pass        return "&lt;%s owner=%r count=%d&gt;" % (                self.__class__.__name__, owner, self.__count)​    def acquire(self, blocking=1):        """Acquire a lock, blocking or non-blocking.​        When invoked without arguments: if this thread already owns the lock,        increment the recursion level by one, and return immediately. Otherwise,        if another thread owns the lock, block until the lock is unlocked. Once        the lock is unlocked (not owned by any thread), then grab ownership, set        the recursion level to one, and return. If more than one thread is        blocked waiting until the lock is unlocked, only one at a time will be        able to grab ownership of the lock. There is no return value in this        case.​        When invoked with the blocking argument set to true, do the same thing        as when called without arguments, and return true.​        When invoked with the blocking argument set to false, do not block. If a        call without an argument would block, return false immediately;        otherwise, do the same thing as when called without arguments, and        return true.​        """        me = _get_ident()        if self.__owner == me:            self.__count = self.__count + 1            if __debug__:                self._note("%s.acquire(%s): recursive success", self, blocking)            return 1        rc = self.__block.acquire(blocking)        if rc:            self.__owner = me            self.__count = 1            if __debug__:                self._note("%s.acquire(%s): initial success", self, blocking)        else:            if __debug__:                self._note("%s.acquire(%s): failure", self, blocking)        return rc​    __enter__ = acquire​    def release(self):        """Release a lock, decrementing the recursion level.​        If after the decrement it is zero, reset the lock to unlocked (not owned        by any thread), and if any other threads are blocked waiting for the        lock to become unlocked, allow exactly one of them to proceed. If after        the decrement the recursion level is still nonzero, the lock remains        locked and owned by the calling thread.​        Only call this method when the calling thread owns the lock. A        RuntimeError is raised if this method is called when the lock is        unlocked.​        There is no return value.​        """        if self.__owner != _get_ident():            raise RuntimeError("cannot release un-acquired lock")        self.__count = count = self.__count - 1        if not count:            self.__owner = None            self.__block.release()            if __debug__:                self._note("%s.release(): final release", self)        else:            if __debug__:                self._note("%s.release(): non-final release", self)​    def __exit__(self, t, v, tb):        self.release()​    # Internal methods used by condition variables​    def _acquire_restore(self, count_owner):        count, owner = count_owner        self.__block.acquire()        self.__count = count        self.__owner = owner        if __debug__:            self._note("%s._acquire_restore()", self)​    def _release_save(self):        if __debug__:            self._note("%s._release_save()", self)        count = self.__count        self.__count = 0        owner = self.__owner        self.__owner = None        self.__block.release()        return (count, owner)​    def _is_owned(self):        return self.__owner == _get_ident()</code></pre><p><br></p><ul><li>简单分析</li></ul><p>python源码中的可重入锁相对简单，加锁部分，第一次获取锁时保存锁的线程标识，后续再次获取锁，先看是否是同一个线程，如果是的话只对锁计数进行递增。解锁时，对锁计数进行递减，如果计数为0，最终释放锁。</p><p>需要注意的是需要先初始化类，后续加锁解锁都应使用同一个对象，而不能每次加锁和解锁使用新的RLock对象，这样会导致owner信息和count信息没有初始化。这个问题本质上是线程变量同步的问题。</p><p><br></p><h1 class=pgc-h-center-line>参考文档</h1><ul><li>https://www.cnblogs.com/linjiqin/p/8003838.html</li><li>https://segmentfault.com/a/1190000021199037</li><li>https://github.com/yangfeixxx/python_redis</li><li>https://leaveslm.github.io/2018/08/08/2018-2018-08-08-基于-Redis-实现可重入分布式锁/</li><li>https://www.cnblogs.com/xybaby/p/6420873.html</li></ul><p><br></p><div class=pgc-img><img alt=你的redis分布式可重入锁是怎么设计的(python实现） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19325eb39de0464e81ae82d3555d1126><p class=pgc-img-caption>关于微信有更多精彩</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'redis','重入锁','怎么'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>