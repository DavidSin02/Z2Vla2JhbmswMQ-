<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>69个Python所有的内置函数 , 都帮你整理好了 | 极客快訊</title><meta property="og:title" content="69个Python所有的内置函数 , 都帮你整理好了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b0d0f214f39c4e9bb44b8f5a542ebdf6"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d88fcbe4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d88fcbe4.html><meta property="article:published_time" content="2020-10-29T21:09:15+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:15+08:00"><meta name=Keywords content><meta name=description content="69个Python所有的内置函数 , 都帮你整理好了"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d88fcbe4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>69个Python所有的内置函数 , 都帮你整理好了</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="69个Python所有的内置函数 , 都帮你整理好了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b0d0f214f39c4e9bb44b8f5a542ebdf6><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">1. abs()<br></span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">abs(x), 返回一个数的绝对值。参数可以是一个整数或浮点数。如果参数是一个复数，则返回它的模</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">示例</span></strong></h1><div class=pgc-img><img alt="69个Python所有的内置函数 , 都帮你整理好了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/db116eb76e0f4c80b9804b49ebed8cad><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">2. all()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">all(iterable), 如果 iterable 的</span><strong>所有元素</strong>均为 True（或 iterable 为空）则返回 True</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">等价代码如下:</span></p><pre><code>def all(iterable):    for element in iterable:        if not element:            return False    return True</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">3. any()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">any(iterable), 如果 iterable 的</span><strong>任一元素</strong>为 True, 则返回 True 如果可迭代对象为空，返回 False</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">等价代码如下:</span></p><pre><code>def any(iterable):    for element in iterable:        if element:            return True    return False</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">4. ascii()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">ascii(object), 返回对象的纯 ASCII 表示形式。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">ascii() 函数类似 repr() 函数, 返回一个表示对象的字符串, 但是对于字符串中的非 ASCII 字符则返回通过 repr() 函数使用 , \u 或 \U 编码的字符。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">生成字符串类似 Python2 版本中 </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">repr()</span></span> 函数的返回值。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">5. bin()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">bin(x), 将一个整数转变为一个前缀为“0b”的二进制字符串</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">6.bool()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回一个布尔值，True 或者 False，如果没有参数，也是返回 False</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">bool 是 int 的子类</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">7. breakpoint()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">breakpoint(*args, **kws)，它调用 </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">sys.breakpointhook()</span></span> ，直接传递 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">args</span></span> 和 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">kws</span></span>，进入 pdb 调试器</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">这个用的很少，几乎没用过..</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">8.bytearray()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>class bytearray([source[, encoding[, errors]]])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果 source 为整数，则返回一个长度为 source 的初始化数组；</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果 source 为字符串，则必须提供 encoding 参数。并按照指定的 encoding 将字符串转换为字节序列；</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果 source 为可迭代类型，则元素必须为[0 ,255] 中的整数；</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果 source 为与 buffer 接口一致的对象，则此对象也可以被用于初始化 bytearray。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果没有输入任何参数，则创建大小为 0 的数组。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">9.bytes()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">bytes() 函数返回一个新的 bytes 对象，该对象是一个 0 &lt;= x &lt; 256 区间内的整数不可变序列。它是 bytearray 的不可变版本。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">10.callable()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">callable(object), 用于检查一个对象是否可调用，可调用返回 True,否则返回 False</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">但是返回 True，调用对象 object 仍可能失败，但如果返回 False, 则调用 object 肯定不会成功</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">另外，类是可调用的，调用类将返回一个新的实例</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果实例所属的类有 </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">__call__()</span></span> 方法，则也是可调用的。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">11.chr()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">chr(i), 返回参数对应的 ASCII 字符，i：可以是 10 进制也可以是 16 进制的形式的数字，数字范围为 0 到 1,114,111 (16 进制为 0x10FFFF)。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">12.classmethod()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将一个方法封装成类方法，该方法不需要实例化，不需要 self 参数，第一个参数是表示自身类的 cls 参数</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">可以用来调用类的属性，类的方法等</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">13.compile()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>compile(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将 </span><em>source</em> 编译成代码或 AST 对象。代码对象可以被 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">exec()</span></span>或 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">eval()</span></span> 执行。</p><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">source</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF"> :可以是常规的字符串、字节字符串，或者 AST 对象</span></p></blockquote><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">filename</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">：代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。</span></p></blockquote><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">mode</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">：指定编译代码的种类。可以指定为 exec, eval, single。</span></p></blockquote><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">flags</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</span></p></blockquote><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">flags</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">和</span><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">dont_inherit</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">是用来控制编译源码时的标志。</span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">14.complex()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>class complex([real[, imag]])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回值为 real + imag*1j 的复数，或将字符串或数字转换为复数。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果第一个形参是字符串，则它被解释为一个复数，并且函数调用时不能有第二个形参</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">参数</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">_real_：int, long, float 或字符串。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">_imag_：int, long, float 不能为字符串</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">15. delattr()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>delattr(object, name)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">实参是一个对象和一个字符串。该字符串必须是对象的某个属性。如果对象允许，该函数将删除指定的属性。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">16. dict()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>class dict(**kwarg)class dict(mapping, **kwarg)class dict(iterable, **kwarg)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">创建一个新的字典</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">参数</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">**kwargs：关键字 mapping：元素的容器。iterable：可迭代对象。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">17. dir()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">dir([object]), 如果没有参数调用，则返回当前范围中的名称。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">带参数时，返回参数的属性、方法列表</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">18.divmod()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">divmod(a, b)，函数接收两个数字类型（非复数）参数，返回一个包含商和余数的元组(a // b, a % b)。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">19.enumerate()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">enumerate(iterable, start=0)，返回一个枚举对象。</span><em>iterable</em> 必须是一个序列，或 iterator，或其他支持迭代的对象</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">示例</span></strong></h1><pre><code>&gt;&gt;&gt; codes = ['Python', 'Java', 'GO', 'C++']&gt;&gt;&gt; list(enumerate(codes, start=2))[(2, 'Python'), (3, 'Java'), (4, 'GO'), (5, 'C++')]</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">20.eval()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>eval(expression[, globals[, locals]])</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">参数</span></strong></h1><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">expression</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">：Python 表达式。</span></p></blockquote><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">globals</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">：必须是一个字典对象。</span></p></blockquote><blockquote><p><em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">locals</span></em><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">：变量作用域，局部命名空间，如果被提供，可以是任何映射对象。</span></p></blockquote><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">执行一个字符串表达式，并返回表达式的值</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">21.exec()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>exec(object[, globals[, locals]])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">exec 执行储存</span><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">在</span><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">字符串或文件中的 Python 语句，相比于 eval，exec 可以执行更复杂的 Python 代码。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">参数</span></strong></h1><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">object：必选参数，必须是字符串或 code 对象。如果 object 是一个字符串，该字符串会先被解析为一组 Python 语句，然后在执行（除非发生语法错误）。如果 object 是一个 code 对象，那么它只是被简单的执行。</span></span></p></blockquote><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">globals：可选参数，表示全局命名空间（存放全局变量）必须是一个字典对象。</span></span></p></blockquote><blockquote><p><span style="color:#595959;--tt-darkmode-color: #595959"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">locals：可选参数，表示当前局部命名空间（存放局部变量）可以是任何映射对象。如果该参数被忽略，那么它将会取与 globals 相同的值。</span></span></p></blockquote><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">22.filter()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>filter(function, iterable)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 list() 来转换。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">23.float()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将整数和字符串转换成浮点数。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">24.format()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">format(value[, format_spec])，该函数主要作用是增强字符串格式化的功能，基本语法是通过 {} 和 : 来代替以前的 %</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">format 函数可以接受不限个参数，位置可以不按顺序。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">25.frozenset()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>class frozenset([iterable])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">frozenset() 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">26.getattr()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>getattr(object, name[, default])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回对象命名属性的值。</span><em>name</em> 必须是字符串。如果该字符串是对象的属性之一，则返回该属性的值。</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">例如， </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">getattr(x, 'foobar')</span></span> 等同于 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">x.foobar</span></span>。如果指定的属性不存在，且提供了 <em>default</em> 值，则返回它，否则触发 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">AttributeError</span></span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">27.globals()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回包含当前作用域的全局变量的字典。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">28.hasattr()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">hasattr(object, name)，该实参是一个对象和一个字符串。如果字符串是对象的属性之一的名称，则返回 </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">True</span></span>，否则返回 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">False</span></span>。</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">此功能是通过调用 </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">getattr(object, name)</span></span> 看是否有 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">AttributeError</span></span>异常来实现的。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">29.hash()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">hash(object), 返回对象 object 的哈希值</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">hash() 函数可以应用于数字、字符串和对象，不能直接应用于 list、set、dictionary。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">30.help()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">为你提供帮助的函数，查看某个函数的帮助信息</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">31.hex()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">hex(x), 将整数转换为以“0x”为前缀的小写十六进制字符串。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">32.id()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">id(object), 返回该对象的内存地址</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">33.input()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">input() 函数接受一个标准输入数据，返回为 string 类型。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">在 Python3.x 中 raw_input() 和 input() 进行了整合，去除了 raw_input( )，仅保留了 input( )函数，其接收任意输入，将所有输入默认为字符串处理，并返回字符串类型。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">34.int()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将一个字符串或数字转换为整型。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">35.isinstance()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>isinstance(object, classinfo)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">isinstance() 函数来判断一个对象是否是一个已知的类型，类似 type()。i sinstance() 与 type() 区别：type() 不会认为</span><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">子类</span><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">是一种父类类型，不考虑继承关系。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">isinstance() 会认为子类是一种父类类型，考虑继承关系。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果要判断两个类型是否相同推荐使用 isinstance()。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">36.issubclass()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>issubclass(class, classinfo)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">issubclass() 方法用于判断参数 class 是否是类型参数 classinfo 的子类。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">37.iter()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>iter(object[, sentinel])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回一个 </span><em>iterator</em> 对象</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果传递了第二个参数，则参数 object 必须是一个可调用的对象，此时，iter 创建了一个迭代器对象，每次调用这个迭代器对象的 next()方法时，都会调用 object。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">38.len()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回对象的长度</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">39.list()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将元组或字符串转换成列表</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">40.locals()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">locals() 函数会以字典类型返回当前位置的全部局部变量。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">41.map()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>map(function, iterable, ...)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回一个将 function 应用于 iterable 中每一项并输出其结果的迭代器</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">42.max()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回可迭代对象中最大的元素</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">43.memoryview()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回给定参数的内存视图</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">44. min()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回可迭代对象中最小的元素，或者返回两个及以上实参中最小的。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">45.next()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">通过调用 </span><em>iterator</em> 的 <strong><span style="color:#ffb11b;--tt-darkmode-color: #E39D18">`__next__()`</span><span style="color:#dda52d;--tt-darkmode-color: #D6A02C">[1]</span></strong> 方法获取下一个元素。如果迭代器耗尽，则返回给定的 <em>default</em>，如果没有默认值则触发 <strong><span style="color:#ffb11b;--tt-darkmode-color: #E39D18">`StopIteration`</span><span style="color:#dda52d;--tt-darkmode-color: #D6A02C">[2]</span></strong>。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">46.object()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回一个没有特征的新对象。</span><strong><span style="color:#ffb11b;--tt-darkmode-color: #E39D18">`object`</span><span style="color:#dda52d;--tt-darkmode-color: #D6A02C">[3]</span></strong> 是所有类的基类。</p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">它具有所有 Python 类实例的通用方法。这个函数不接受任何实参。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">47. oct()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回整数的八进制表示形式</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">48.open()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>open(file, mode='r', buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">open() 函数用于打开一个文件，并返回文件对象，在对文件进行处理过程都需要使用到这个函数，如果该文件无法被打开，会抛出 </span><em>OSError</em></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">49.ord()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">对单个字符的字符串，返回它的 Unicode 编码的整数</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">例如 </span><span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">ord('a')</span></span> 返回整数 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">97</span></span>， <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">ord('€')</span></span> （欧元符号）返回 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">8364</span></span> 。是 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">chr()</span></span> 的逆函数。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">50. pow()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>pow(base, exp[, mod])</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">函数</span><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">是</span><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">计算 base 的 exp 次方，如果 mod 存在，则再对结果进行取模，其结果等效于 pow(base,exp) %mod。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">51.print()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>print(*objects, sep=' ', end='\n', file=sys.stdout, flush=False)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将 objects 打印到 file 指定的文本流, 默认为 </span><em>sys.stdout</em></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">52.property()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">property() 函数的作用是在新式类中返回属性值。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">53.range()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">range() 函数返回一个可迭代对象</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">54.repr()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回包含一个对象的可打印表示形式的字符串。对于大多数的类型，eval(repr(obj)) == obj</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">55.reversed()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回给定序列值的反向迭代器</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">56.round()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回 number 四舍五入到小数点后 ndigits 位精度的值。如果 ndigits 被省略或为 None，则返回最接近输入值的整数</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">对精度要求高的，不减少使用该函数</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">57.set()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">set() 函数创建一个无序不重复元素集，删除重复数据，可以用于计算交集、差集、并集等。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">58.setattr()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>setattr(object, name, value)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">其参数为一个对象、一个字符串和一个任意值，将给定对象上的命名属性设置为指定值。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">例如，setattr(python, 'name', 123) 等价于 python.name= 123</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">59.slice()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">slice() 函数实现切片对象，主要用在切片操作函数里的参数传递。</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">60.sorted()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>sorted(iterable, key=None, reverse=False)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">对所有可迭代的对象进行排序操作,默认为升序</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">sort 与 sorted 区别：sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">sort 方法返回的是对已经存在的列表进行操作</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">而 sorted 方法返回的是一个新的 list</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">61.staticmethod()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将方法转换为静态方法, 该方法不要钱传递参数</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">62.str()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回一个对象的 string 格式</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">63.sum()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">sum(iterable[, start]), 从 start 开始自左向右对 iterable 的项求和并返回总计值</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">64.super()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">用于调用父类的一个方法, 用来解决多重继承问题的</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">示例</span></strong></h1><div class=pgc-img><img alt="69个Python所有的内置函数 , 都帮你整理好了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0dab548d287443db8191907ea6dba8ce><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">65. tuple()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">将可迭代系列（如列表）转换为元组</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">66.type()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">传入一个参数时，返回 </span><em>object</em> 的类型, 传入三个参数时，返回一个新的 <em>type</em> 对象</p><pre><code>&gt;&gt;&gt; class X:          a = 1&gt;&gt;&gt; X = type('X', (object,), dict(a=1))&gt;&gt;&gt; X&lt;class '__main__.X'&gt;</code></pre><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">67.vars()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">返回模块、类、实例或任何其它具有 </span><strong><span style="color:#ffb11b;--tt-darkmode-color: #E39D18">`__dict__`</span><span style="color:#dda52d;--tt-darkmode-color: #D6A02C">[4]</span></strong> 属性的对象的 <span style="color:#9b6e23;--tt-darkmode-color: #9B6E23"><span style="background-color:#fff5e3;--tt-darkmode-bgcolor: #C5BDAF">__dict__</span></span> 属性。</p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">68. zip()</span></strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">可以使用 list() 转换来输出列表, 如果各个迭代器的元素个数不一致，则返回的列表长度以最短的对象为准</span></p><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">示例</span></strong></h1><div class=pgc-img><img alt="69个Python所有的内置函数 , 都帮你整理好了" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/332788c09732478495edeb58ef966aa0><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">69. _</span></strong><em><strong>import</strong></em><strong>_()</strong></h1><h1 class=pgc-h-arrow-right><strong><span style="color:#515151;--tt-darkmode-color: #959595">语法</span></strong></h1><pre><code>__import__(name, globals=None, locals=None, fromlist=(), level=0)</code></pre><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">_import()_ 函数用于动态加载类和函数 。</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">如果一个模块经常变化就可以使用 _import()_ 来动态载入</span></p><p><span style="color:#3a3a3a;--tt-darkmode-color: #A3A3A3">以上便是 Python 全部的 69 个内置函数，语法规则基于 Python3.8.6。</span></p><p style=text-align:start><strong><span style="color:#3e3e3e;--tt-darkmode-color: #A3A3A3">如果觉得本篇不错，欢迎在留言区点评，给个三连哦！</span></strong></p><p style=text-align:justify><br></p><p><span style="color:#3e3e3e;--tt-darkmode-color: #A3A3A3"><br></span></p><div class=pgc-img><img alt="69个Python所有的内置函数 , 都帮你整理好了" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0731b4c2d8d646d5a38f27a7e6fd4983><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'69','Python','内置'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>