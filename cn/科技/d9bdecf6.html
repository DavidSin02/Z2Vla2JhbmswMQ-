<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法连载之散列表 | 极客快訊</title><meta property="og:title" content="算法连载之散列表 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c9323a98b84a4165a88fc30ed2f2a422"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/d9bdecf6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/d9bdecf6.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="算法连载之散列表"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/d9bdecf6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法连载之散列表</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>散列表</h1><p>散列表（hash table）是实现字典操作的有效数据结构。在最坏情况下，查找一个元素的时间复杂度是O(n)；而在合理假设情况下，查找一个元素的时间复杂度是O(1)。因此，散列表查找元素的性能是极好的。</p><p>常用于作为在常量时间范围内辅助查找一个元素。</p><p>对于普通数组，可以直接寻址，即可以直接通过数组下标访问一个元素。如果空间允许的话，可以将元素的key作为数组下标映射。但是，如果实际存储的元素要比实际可存储的元素小很多时，仍使用直接寻址法，会带来很大的空间浪费。主要缺点：</p><p>1、空间浪费；</p><p>2、一次申请庞大的空间，内存容量限制。</p><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c9323a98b84a4165a88fc30ed2f2a422><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/84316d5b68464cc8a823d4255fb71739><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/716fed668b9047f38dd88515c4f9eb67><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6edd418a21854e739f3f7d45941ef728><p class=pgc-img-caption></p></div><p>因此，散列表是作为对普通数组的扩展。在散列表中，不是通过关键字作为数组下标，而是根据关键字来计算出数组下标。如果多个关键字计算出同一个下标，就会出现“冲突”。所以，在理想情况下，如果完全可以避免冲突的话，散列表的元素查找时间就是O(1)。</p><p>在直接寻址方式下，元素是放在关键字为K的槽中；而散列方式下，元素是放在f(K)的槽中，其中，函数f()称为散列函数，通过散列函数来计算出槽的位置。</p><h1>散列函数</h1><ul><li>除法散列法</li></ul><p>f(k) = k % m</p><p>其中，k是关键字，m是所映射的槽数。假设：m = 10，k = 99，则f(99) = 99 % 10 = 9</p><p>m不要取2<sup>的幂。为什么？</sup></p><p>假设k是0~1000范围内数值，m为8，即2的3次幂。</p><p>96 % 8 = 0110 0000 % 2³ = (1*2³*2³ + 1*2²*2³) % 2³ = 0</p><p>97 % 8 = 0110 0001 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2º) % 2³ = 1*2º= 1</p><p>98 % 8 = 0110 0010 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2¹) % 2³ = 2¹= 2</p><p>99 % 8 = 0110 0011 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2¹ + 1*2º) % 2³ = 2¹+ 2º = 3</p><p>100 % 8 = 0110 0100 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2²) % 2³ = 2² = 4</p><p>101 % 8 = 0110 0101 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2² + 1*2º) % 2³ = 2² + 2º = 5</p><p>102 % 8 = 0110 0110 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2² + 1*2¹) % 2³ = 2² + 2¹ = 6</p><p>103 % 8 = 0110 0111 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2² + 1*2¹+ 1*2º) % 2³ = 2² + 2¹ + 2º = 7</p><p>104 % 8 = 0110 1000 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2³) % 2³ = 0</p><p>105 % 8 = 0110 1001 % 2³ = (1*2³*2³ + 1*2²*2³ + 1*2³ + 1*2º) % 2³ = 2º = 1</p><p>以上分析可知，余数在0~7范围内，不会超过8，也就是k的后三位就可以完全表示余数。如果关键字均匀分布在后三位，此方法可行。但如果遇到：</p><p>0000 0000（0）</p><p>0000 1000（8）</p><p>0001 0000（16）</p><p>0001 1000（24）</p><p>如上后三位均为0的情况，这些关键字都处于同一个槽中，无法很好的避免冲突。所以，好的散列函数为了尽可能的避免冲突的发生，应该尽量考虑所有位。</p><p>一个不接近2的幂次的素数是一个好的选择。</p><p>假设一个存放2000个字符的hash表，可以接受的冲突是3次，则2000/3 ≈ 667，m的选择是接近667，但不接近2的幂次的素数，因此m可以选择为673，或677，或683，或691，或701。</p><ul><li>乘法散列法</li></ul><p>f(k) = ⎣m(kA % 1)⎦</p><p>其中：</p><p>1、0&lt;A&lt;1</p><p>2、kA % 1得到的是kA结果的小数部分</p><p>3、m是槽数，一般取2的p次</p><p>假设k=123_456，p=14，m=2^14=16_384，w=32（每个关键字占32位）</p><p>∵ 0&lt;A&lt;1，每个关键字占32位，2^32=4.294967296E9</p><p>∴ A=s / 2^32，其中 0 &lt; s &lt; 2^32，当A ≈(√5 - 1)/2时，是个比较理想的值</p><p>s = A * 2^32</p><p>s=2.6544357694972305E9</p><p>∵ k和s都是32位</p><p>∴ ks = r1 * 2^32 + r2 &lt;1></p><p>kA = ks / 2^32，相当于将ks右移32位 &lt;2></p><p>∵ kA % 1 取小数部分</p><p>∴ 其中r2即为小数部分 &lt;3></p><p>∵ m(kA % 1)，m=2^14</p><p>∴ 即将r2左移14位 &lt;4></p><p>r2的高14位即是f(k)的结果，f(123_456) = 67</p><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/00139e9d230b4d5da9208cad2855f6e8><p class=pgc-img-caption></p></div><ul><li>实现</li></ul><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/91451d08c81a46b0bb7d741b75048cbd><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b3181f0707f4ede8e1095df8407ddb5><p class=pgc-img-caption></p></div><h1>解决冲突</h1><ul><li>链接法</li></ul><p>把散列在同一个槽中的所有元素都放在一个链表中。</p><p>1、插入最坏情况时间复杂度是O(1)，因为在发生冲突时，始终插入到链表头位置；</p><p>2、查找平均情况是O(1)，最坏情况是O(n)，即所有元素都散列到同一个槽中。</p><p>假设有n个元素，放到m个槽位中，则α=n/m，α称为装载因子。在简单均匀散列假设下：</p><p>1）一次不成功查找平均时间为O(1+α)；</p><p>2）一次成功查找平均时间为O(1+α)；</p><p>3、删除，对于双向链表最坏情况O(1)，而对於单向链表删除和查找渐进相同。</p><p>全部字典操作都可以在平均情况O(1)时间内完成。</p><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/4954e69587d04f5d8f6b4c4f07859b60><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/979ecbe97fab4bdd9c340360de374d74><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ccef072112841ce8516faab23b6339b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0d46c0dacf7843909701aed1d6f6bb6d><p class=pgc-img-caption></p></div><ul><li>开放寻址法</li></ul><p>所有元素都放在散列表中，当插入元素发生冲突时，通过线性探查（二次探查/双重散列）将元素放入到槽位为NULL的位置。查找和插入都可以在线性时间O(1)内完成。</p><p>开放寻址法不需要额外的空间存储冲突元素，而是通过计算出存放的槽位提高检索速度，从而提高了空间的利用率。</p><p>α绝对不会超过1，因为当散列表被填满时，不能再插入任何元素，此时n和槽数m相等。</p><p>假设有n个元素，放到m个槽位中，则α=n/m&lt;1。在简单均匀散列假设下：</p><p>1）一次不成功查找平均时间为1/(1-α)；</p><p>2）一次成功查找平均时间为(1/α)㏑(1/(1-α))；</p><p>1、线性探查</p><p>h(k, i) = (h'(k) + i) % m</p><p>1）i = 0, 1, 2, ... m-1</p><p>2）共有m中不同的探查序列</p><p>3）会造成一次群集（重度），连续槽被占用（查找是顺序自增），相应的查找时间也会相应增加。</p><p>2、二次探查</p><p>h(k, i) = (h'(k) + c1i+c2i²) % m</p><p>1）i = 0, 1, 2, ... m-1</p><p>2）共有m中不同的探查序列</p><p>3）会造成二次群集（轻度），当初始位置相同时，探查序列也就相同了。</p><p>3、双重散列</p><p>h(k, i) = (h1(k) + ih2(k)) % m</p><p>1）开放寻址的最好方法之一，所产生的探查序列具有随机性。</p><p>2）为了可以探查整个散列表，要求h2(k)同m必须互素（公约数为1）</p><p>a、m是2的幂次，h2(k)总返回基数</p><p>b、m是素数，h2(k)总返回比m小的正整数</p><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cbc49ef3649c404a82f32c92d3bf0375><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5efa02b441904c24b47434fbb7c5cb72><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f77fa3941f764af1a7f26cefa5d41365><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34e2c9d5f046488bb1159e125ffe9fba><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b7c7c4bbfeac47eb9ce2f405e7491e2d><p class=pgc-img-caption></p></div><ul><li>完全散列（perfect hashing）</li></ul><p>能够在O(1)最坏情况时间内完成关键字的查找。要求关键字集合是静态的，各个关键字一旦进入散列表，就不会再变化了。如：cd-rom的文件名，程序设计语言的关键字。</p><h1>Java集合框架中的HashSet和HashMap</h1><p>HashSet</p><p>1、基于Hash表，实际上是基于HashMap实例。每一个元素对应HashMap的key。</p><p>2、无序（基于hash表），元素不可重复。</p><p>3、对于基本操作，如add、remove、contains、size提供了时间复杂度是O(1)的性能。对于iterate，同Hash表的容量相关，因此为保证性能，初始容量不要太大或负载因子不要太小。</p><p>HashMap</p><p>1、与Hashtable大致一致，除了它是不同步、key和value接受null值。</p><p>2、无序，特别是不能保证一直保持不变。</p><p>3、对于基本操作，如get、put提供了时间复杂度是O(1)的性能。对于iterate，同Hash表的容量相关，因此为保证性能，初始容量不要太大或负载因子不要太小。</p><p>4、有两个参数影响其性能</p><p>1）初始容量，Hash表的槽数。</p><p>2）负载因子，一个度量散列表在自动增加其容量之前被允许达到的容量占比的程度。当哈希表的长度超过了负载因子和当前的容量的乘积，哈希表会重建（重新散列），最后的容量是原来容量的两倍。</p><p>5、默认情况容量是16，负载因子是0.75。</p><p>6、HashMap使用链接法解决冲突（相同hash值），当链表长度大于等于TREEIFY_THRESHOLD（默认为8）时，将链表转换为红黑树，当小于等于UNTREEIFY_THRESHOLD（默认为6）时，又会将红黑树转换为链表以达到最佳性能。</p><div class=pgc-img><img alt=算法连载之散列表 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/762fcfbaee0c489c88e927d24b36dede><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'连载','之散','列表'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>