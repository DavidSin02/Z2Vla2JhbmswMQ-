<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 | 极客快訊</title><meta property="og:title" content="Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d592f2f032a44c71a5eda9e833eef9fc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/da0a9f77.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/da0a9f77.html><meta property="article:published_time" content="2020-10-29T21:09:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:37+08:00"><meta name=Keywords content><meta name=description content="Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/da0a9f77.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>前面几节，我们主要分析和讨论了 Linux 内核中常用的几种数据结构（链表、队列、映射、二叉树、红黑树）以及相关C语言代码实现，这是研究 Linux 内核其他内容的基础，本节将介绍一下内核中的“中断”机制。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d592f2f032a44c71a5eda9e833eef9fc><p class=pgc-img-caption></p></div><h1><strong>中断的基本概念</strong></h1><p class=ql-align-justify>现在来设想一个简单，但是又很常见的场景：当用户按下键盘时，Linux 内核是如何响应的呢？如果采取始终监测键盘的方法，效率就太低了，因为用户可能几分钟，甚至几小时都不会按下键盘。就算用户正在使用键盘写文章，手指的速度相对于 cpu 的速度也差了好几个数量级。</p><blockquote>cpu 每秒运算次数以亿计，但是用户能一秒按键盘 100 次吗？</blockquote><p class=ql-align-justify>那么内核该如何响应键盘的输入，而又同时不会降低机器的整体性能呢？如果键盘在被敲击的时候，能够<strong>主动</strong>向 Linux 内核发送信号，就好办了。这样 Linux 内核就无需关心键盘，安心做自己的事就可以了，反正若是有人按下键盘，键盘会<strong>主动</strong>通知内核的。这其实就是<strong>中断机制</strong>。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2bf9e8c67b1b4c29a111e610e8f823f8><p class=pgc-img-caption></p></div><p class=ql-align-justify>中断本质上是一种电信号，由硬件设备（如键盘鼠标）产生，并直接送到中断控制器的输入口，经复用处理后，中断控制器会向 cpu 发送一个电信号。cpu 接收到该信号后，会<strong>中断</strong>自己当前的工作，并通知 Linux 内核，这时内核就能做出适当的处理了（例如处理键盘输入的字符）。</p><p class=ql-align-justify>现代计算机一般都较为复杂，硬件外设也非常多，不仅仅有键盘，还有声卡，显卡，硬盘等。这么多硬件设备都产生中断的话，Linux 内核怎么知道某个中断是谁产生的呢？所以，内核为每个中断都设定了一个唯一的数字标志（中断号）。这么一来，有中断产生时，只需对比中断号就能知道是哪个硬件设备产生的了。</p><blockquote>这里再提一下“异常”的概念。中断是由硬件主动产生的，它才不会管 cpu，随时可能发生。而异常则是由 cpu 主动产生的，一般是遇到无法处理，必须求助内核的情况时才会产生，例如某个数被 0 除。</blockquote><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5b3e439cd15e42c380539c60dcbda56c><p class=pgc-img-caption></p></div><h1><strong>Linux 内核中的中断处理程序</strong></h1><p class=ql-align-justify>上面我们提到，Linux 内核为了分辨中断是哪个硬件设备产生的，为每个中断都定义了独一无二的中断号，其实，内核还为每个中断都定义了中断处理程序。中断处理程序运行在中断上下文中，而不是进程上下文中，这就要求中断处理程序应尽可能简洁，以便能快速完成工作，尽快恢复中段代码的执行。</p><p class=ql-align-justify>但有时需求是矛盾的，即：想中断处理程序运行的快，又想中断处理程序干得活多。例如网络设备的中断处理程序，它需要对硬件做出应答，把网络数据从硬件设备拷贝到内存，还要把数据送往合适的协议栈分析，这样的工作量显然不小，但是又要求系统快速做出响应的同时，不影响其他设备。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/80cabd9dc6f548b789632f72968f7ff4><p class=pgc-img-caption></p></div><p class=ql-align-justify>针对这种情况，Linux 内核将中断处理程序分为两部分（上半部，下半部），上半部只做必须快速完成的工作，例如对硬件设备做出应答，下半部则负责完成余下的较为耗时的工作。上半部的工作一般都是“现在立刻马上做”，而下半部的工作则可以暂缓到 cpu 没那么忙的时候再做。</p><p class=ql-align-justify>现在知道了 Linux 内核关于中断的总体设计了，来看看具体的 C语言代码是怎样实现的吧。</p><h1><strong>注册中断处理程序</strong></h1><p class=ql-align-justify>每一个中断都对应一个中断处理程序，那么这个“对应”关系 Linux 内核是如何实现的呢？上面我们提到，每个中断都有独一无二的中断号，所以将中断处理程序与中断号对应起来可以了。因此，Linux 内核定义了 request_irq() 函数用于注册中断处理程序，它的C语言代码如下，请看：</p><pre> 536 int request_irq(unsigned int irq, irq_handler_t handler, 537 unsigned long irqflags, const char *devname, void *dev_id)- 538 {| 539 struct irqaction *action;| 540 int retval;  ...|| 586 local_irq_save(flags);|| 587 handler(irq, dev_id);|| 588 local_irq_restore(flags);|| 589 }| 590 #endif| 591 | 592 retval = setup_irq(irq, action);| 593 if (retval)| 594 kfree(action);| 595 | 596 return retval;| 597 }</pre><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9a1478e2925441a99585b5314da9d207><p class=pgc-img-caption></p></div><p class=ql-align-justify>其中 irq 是分配给中断的中断号，这个值有的设备是预先设定好的，有些则可以通过C语言编程动态获取。handler 就是指向中断处理函数的指针了，它的原型如下：</p><pre>typedef irqreturn_t (*irq_handler_t)(int, void *);</pre><p class=ql-align-justify>irqflags 是标志位，常用的主要有以下几个：</p><ul><li>IRQF_DISABLED，使用该标志位注册的中断处理程序运行时，会禁止其他中断。</li><li>IRQF_SAMPLE_RANDOM，Linux 内核维护一个熵池，用于实现随机功能，该标志位表明中断会对熵池有贡献。</li><li>IRQF_SHARED，每个中断线都可以有不止一个中断处理程序，此标志位则决定是否使用多个中断程序复用一条中断线。</li></ul><p class=ql-align-justify>request_irq() 函数的 devname 参数则是用于描述中断名字的，dev_id 在使用了 IRQF_SHARED 标志位时非常有用，它是区分共享一个中断线的中断处理程序们的重要参数，这一点从 request_irq() 函数的C语言源代码可以看出：</p><pre>| 554 if ((irqflags &amp; IRQF_SHARED) &amp;&amp; !dev_id)| 555 return -EINVAL;| 556 if (irq &gt;= NR_IRQS)| 557 return -EINVAL;| 558 if (irq_desc[irq].status &amp; IRQ_NOREQUEST)| 559 return -EINVAL;| 560 if (!handler)| 561 return -EINVAL;</pre><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/37a00e74a03b4c0ebe8b5fbf9ce91dfa><p class=pgc-img-caption></p></div><blockquote>如果没有使用 IRQF_SHARED 位，dev_id 参数可以赋值为 NULL。</blockquote><p class=ql-align-justify>request_irq() 函数的其他部分就比较简单了，它的主要工作就是保存传递给它的参数，请看如下C语言代码：</p><pre>| 563 action = kmalloc(sizeof(struct irqaction), GFP_ATOMIC);| 564 if (!action)| 565 return -ENOMEM;| 566 | 567 action-&gt;handler = handler;| 568 action-&gt;flags = irqflags;| 569 cpus_clear(action-&gt;mask);| 570 action-&gt;name = devname;| 571 action-&gt;next = NULL;| 572 action-&gt;dev_id = dev_id;</pre><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a1763eaef2a04e108978fb1b4cc23ede><p class=pgc-img-caption></p></div><p class=ql-align-justify>最后再将 action 传递给 setup_irq() 函数，我们继续跟踪，分析它的C语言源代码，容易看出它的功能也是非常简单的：</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5fa120014f3944c19a0a8a7fcb3a6ca4><p class=pgc-img-caption></p></div><p class=ql-align-justify>这一步清楚的说明了 IRQF_SAMPLE_RANDOM 的作用。 setup_irq() 函数的其他主要工作就是检查标志位，设置标志位，如果一切符合要求，就把中断处理函数挂到 irq 队列的最后：</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d09975a203b4ddd927b86fda1ef3cd0><p class=pgc-img-caption></p></div><p class=ql-align-justify>最后，Linux 内核会将相关信息注册，请看如下C语言代码：</p><pre>new-&gt;irq = irq;register_irq_proc(irq);new-&gt;dir = NULL;register_handler_proc(irq, new);</pre><p class=ql-align-justify>这两个函数执行后，我们可以在 Linux 系统中的 /proc 目录下看到</p><pre>/proc/irq/1234.../proc/irq/1234.../handler/...</pre><p class=ql-align-justify>这里面就记载着中断的相关信息。现在知道了 Linux 内核是如何注册中断处理程序的了，再来看看内核是如何执行中断处理程序的。</p><h1><strong>Linux 内核是如何执行中断处理程序的</strong></h1><p class=ql-align-justify>内核中大多中断处理程序都是在 do_IRQ() 中完成执行的，它的 C语言源代码如下：</p><pre> 69 unsigned int do_IRQ(struct pt_regs *regs)- 70 { | 71 struct pt_regs *old_regs;| 72 /* high bit used in ret_from_ code */| 73 int irq = ~regs-&gt;orig_ax;| 74 struct irq_desc *desc = irq_desc + irq;...| 143 irq_exit();| 144 set_irq_regs(old_regs);| 145 return 1;| 146 }</pre><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf1c83cd80eb49dbbe982b49f625294e><p class=pgc-img-caption></p></div><p class=ql-align-justify>能够看出，do_IRQ() 函数是从全局变量 irq_desc 获取中断信息的，irq_desc 的内容则来自 request_irq() 函数。这就非常清楚了，Linux 内核通过 request_irq() 函数注册中断处理程序，并将相关信息保存在 irq_desc，do_IRQ() 函数则负责从 irq_desc 中获取中断处理程序，在合适的时候执行。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/101ba7387d1f41068d3bf7b8502de8d8><p class=pgc-img-caption></p></div><p class=ql-align-justify>从上图中的C语言代码可以看出，do_IRQ() 函数首先把当前的寄存器信息保存下来，然后检查栈空间是否够用。然后确保进入了中断栈，否则就手动新建一个栈帧供中断处理程序使用。Linux 内核执行中断处理程序是通过在注册中断处理程序时传递给 irq_desc 结构体成员 handle_irq 的函数指针实现的。这一过程可以从下图C语言代码看出。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/187f1971325c42c0a0533211a6527b2b><p class=pgc-img-caption></p></div><p class=ql-align-justify>在 do_IRQ() 函数的最后，内核恢复了之前保存的寄存器信息，以便其他程序恢复运行。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/40ff4efa1408469289c1c57328a458f7><p class=pgc-img-caption></p></div><h1><strong>Linux 内核是如何释放中断处理程序的</strong></h1><p class=ql-align-justify>既然有注册，就应该有释放。当 Linux 卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线，这一过程由 free_irq() 函数完成，它的C语言代码原型如下：</p><pre>void free_irq(unsigned int irq, void *dev_id);</pre><p class=ql-align-justify>free_irq() 函数会根据 dev_id 遍历整个 irq_desc，查找到要释放的中断处理程序后，就将其释放，并且设置 IRQ_DISABLED 标志位。</p><div class=pgc-img><img alt=Linux学习第23节，什么是中断？从C源码分析内核如何设计和实现它 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/959c4a03ee0d4eafbdb00a2c98b05d9b><p class=pgc-img-caption></p></div><p class=ql-align-justify>不过对于以 IRQF_SHARED 标志位注册的中断处理程序，还要特殊处理一下：</p><pre>if (action-&gt;flags &amp; IRQF_SHARED) { local_irq_save(flags); action-&gt;handler(irq, dev_id); local_irq_restore(flags);}</pre><p class=ql-align-justify>至此，Linux 内核是如何注册中断处理程序，又是如何执行如何释放的，相信大家已经比较清楚了。</p><p class=ql-align-justify>欢迎在评论区一起讨论，质疑。文章都是手打原创（本文部分参考linux内核原理和设计），每天最浅显的介绍C语言、linux等嵌入式开发，喜欢我的文章就关注一波吧，可以看到最新更新和之前的文章哦。</p><p class=ql-align-justify><br></p><div class=tt-column-card data-content='{"thumb_url":"http://p5a.pstatp.com/large/ffda00000ee3830eecc2","title":"手把手教你学Linux C语言编程","author_description":"嵌入式时代-深入浅出的介绍嵌入式开发，c语言编程，智能传感器制作。","price":38.88,"share_price":0,"sold":6,"column_id":"1623634872421383","distribution_user_id":1595369703749639}'><p class=column-placeholder></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Linux','学习','23'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>