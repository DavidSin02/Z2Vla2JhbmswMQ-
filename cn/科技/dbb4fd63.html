<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Mysql --09 Innodb核心特性——事务 | 极客快訊</title><meta property="og:title" content="Mysql --09 Innodb核心特性——事务 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/47618d6931fd4518a4d78c0e13623b98"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dbb4fd63.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dbb4fd63.html><meta property="article:published_time" content="2020-11-14T21:08:11+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:11+08:00"><meta name=Keywords content><meta name=description content="Mysql --09 Innodb核心特性——事务"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/dbb4fd63.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Mysql --09 Innodb核心特性——事务</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>Innodb核心特性——事务</strong></h1><h1 class=pgc-h-arrow-right><strong>1.什么是事务</strong></h1><p style=text-align:start><em>主要针对DML语句（update，delete，insert）</em></p><blockquote><p>一组数据操作执行步骤，这些步骤被视为一个工作单元:<br>1）用于对多个语句进行分组<br>2）可以在多个客户机并发访问同一个表中的数据时使用</p></blockquote><hr><blockquote><p>所有步骤都成功或都失败<br>1）如果所有步骤正常，则执行<br>2）如果步骤出现错误或不完整，则取消</p></blockquote><h1 class=pgc-h-arrow-right><strong>2.事务的通俗理解</strong></h1><p style=text-align:start><em>伴随着“交易”出现的数据库概念。</em></p><blockquote><p>我们理解的“交易”是什么？<br>1）物与物的交换（古代）<br>2）货币现金与实物的交换（现代1）<br>3）虚拟货币与实物的交换（现代2）<br>4）虚拟货币与虚拟实物交换（现代3）</p></blockquote><hr><blockquote><p>数据库中的“交易”是什么？<br>1）事务又是如何保证“交易”的“和谐”？<br>2）ACID</p></blockquote><h1 class=pgc-h-arrow-right><strong>3.事务ACID特性</strong></h1><hr><p style=text-align:start>Atomic（原子性）<br>所有语句作为一个单元,要么全部成功执行或全部取消。</p><p style=text-align:start>Consistent（一致性）<br>如果数据库在事务开始时处于一致状态，则在执行该事务结束时也是一致状态。事务期间将保留一致状态。</p><p style=text-align:start>Isolated（隔离性）<br>事务之间不会被其他事务影响。</p><p style=text-align:start>Durable（持久性）<br>事务成功完成后，所做的所有更改都会准确地记录在数据库中。所做的更改不会丢失。</p><hr><h1 class=pgc-h-arrow-right>4.事务流程举例</h1><div class=pgc-img><img alt="Mysql --09 Innodb核心特性——事务" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47618d6931fd4518a4d78c0e13623b98><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>5.事务的控制语句</strong></h1><blockquote><p>如下:<br>START TRANSACTION（或 BEGIN）：显式开始一个新事务<br>SAVEPOINT：分配事务过程中的一个位置，以供将来引用（存档）<br>COMMIT：永久记录当前事务所做的更改<br>ROLLBACK：取消当前事务所做的更改<br>ROLLBACK TO SAVEPOINT：取消在 savepoint 之后执行的更改 （读档）<br>RELEASE SAVEPOINT：删除 savepoint 标识符 （删档）<br>SET AUTOCOMMIT：为当前连接禁用或启用默认 autocommit 模式</p></blockquote><p style=text-align:start><strong>一个成功事务的生命周期</strong><br>begin;<br>sql1<br>sql2<br>sql3<br>...<br>commit;</p><p style=text-align:start><strong>一个失败事务的生命周期</strong><br>begin;<br>sql1<br>sql2<br>sql3<br>...<br>rollback;</p><p style=text-align:start>**结束事务的控制语句： commit 和 rollback **</p><p style=text-align:start><em><strong>注意：其实事务开启，不需要执行 begin 或者 start transaction ，只要执行DML 语句，自动开启事务。</strong></em></p><ul><li><strong>3.自动提交</strong></li></ul><pre><code>#查看自动提交mysql&gt; show variables like 'autocommit';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | ON    |+---------------+-------+1 row in set (0.01 sec)#临时关闭自动提交mysql&gt; set autocommit=0;mysql&gt; show variables like 'autocommit';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | OFF   |+---------------+-------+1 row in set (0.01 sec)#永久关闭自动提交（在配置文件修改，修改后重启mysqld）[root@db01 world]# vim /etc/my.cnf[mysqld]autocommit=0mysql&gt; show variables like 'autocommit';+---------------+-------+| Variable_name | Value |+---------------+-------+| autocommit    | OFF   |+---------------+-------+1 row in set (0.00 sec)</code></pre><p><em><strong>注意：自动提交关闭后，数据不会立即提交，还可以执行rollback回滚回来。</strong></em></p><ul><li><strong>4.事务演示</strong></li></ul><p style=text-align:start>1）成功事务</p><pre><code>mysql&gt; create table stu(id int,name varchar(10),sex enum('f','m'),money int);mysql&gt; begin;mysql&gt; insert into stu(id,name,sex,money) values(1,'zhang3','m',100), (2,'zhang4','m',110);mysql&gt; commit;#查看mysql&gt; select * from stu;                         +------+--------+------+-------+| id   | name   | sex  | money |+------+--------+------+-------+|    1 | zhang3 | m    |   100 ||    2 | zhang4 | m    |   110 |+------+--------+------+-------+2 rows in set (0.00 sec)</code></pre><p>2）事务回滚</p><pre><code>mysql&gt; begin;mysql&gt; update stu set name='zhang3';mysql&gt; delete from stu;mysql&gt; rollback;</code></pre><div class=pgc-img><img alt="Mysql --09 Innodb核心特性——事务" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5320328e5dd3431e9c181163d17a8160><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>6.事务隐式提交情况</strong></h1><p style=text-align:start>1）现在版本在开启事务时，不需要手工begin，只要你输入的是DML语句，就会自动开启事务。<br>2）有些情况下事务会被隐式提交</p><blockquote><p>例如:</p><p>１．在事务运行期间，手工执行begin的时候会自动提交上个事务</p><p>２．在事务运行期间，加入DDL、DCL操作会自动提交上个事务</p><p>３．在事务运行期间，执行说定语句（lock tables、unlock tables）</p><p>４．load data infile</p><p>５．select for update</p><p>６．在autocommit=1的时候</p></blockquote><p style=text-align:start>示例：</p><pre><code># 执行了多少个成功的事务？ 7个begin; sql1sql2 begin; #提交了一个begin； #提交了一个create database xxx; #提交了一个update; #提交了一个begin; #提交了一个select * from xxx;begin;   #提交了一个commit;   #提交了一个rollback;   #算是一个失败的事务</code></pre><h1 class=pgc-h-arrow-right><strong>7.事务日志redo基本功能</strong></h1><p style=text-align:start><strong>1）Redo是什么？</strong></p><p style=text-align:start>redo,顾名思义“重做日志”，是事务日志的一种。</p><p style=text-align:start><strong>2）作用是什么？</strong></p><p style=text-align:start>在事务ACID过程中，实现的是“D”持久化的作用。</p><p style=text-align:start><strong>特性:WAL(Write Ahead Log)日志优先写</strong><br><strong>REDO：记录的是，内存数据页的变化过程</strong></p><p style=text-align:start><strong>3）REDO工作过程</strong></p><pre><code>#执行步骤#查询mysql&gt; select * from course;+-----+--------+-----+| cno | cname  | tno |+-----+--------+-----+|   1 | 英语   | 1   ||   2 | 语文   | 2   ||   3 | 数学   | 3   |+-----+--------+-----+3 rows in set (0.00 sec)#执行步骤mysql&gt; update course set cno=6 where cno=1;Query OK, 1 row affected (0.00 sec)Rows matched: 1  Changed: 1  Warnings: 0#再次查询mysql&gt; select * from course;+-----+--------+-----+| cno | cname  | tno |+-----+--------+-----+|   2 | 语文   | 2   ||   3 | 数学   | 3   ||   6 | 英语   | 1   |+-----+--------+-----+3 rows in set (0.00 sec)</code></pre><p>1）首先将t1表中num=1的行所在数据页加载到内存中buffer page<br>2）MySQL实例在内存中将num=1的数据页改成num=2<br>3）num=1变成num=2的变化过程会记录到，redo内存区域，也就是redo buffer page中</p><pre><code>#提交事务执行步骤commit; </code></pre><p>1）当敲下commit命令的瞬间，MySQL会将redo buffer page写入磁盘区域redo log<br>2）当写入成功之后，commit返回ok</p><h1 class=pgc-h-arrow-right>8.redo数据实例恢复过程</h1><div class=pgc-img><img alt="Mysql --09 Innodb核心特性——事务" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/119f066e924b4f4081034bd779648526><p class=pgc-img-caption></p></div><p><em><strong>恢复过程的几个步骤：</strong></em></p><blockquote><p><strong>1.首先将t1表中 id=1 的行所在数据页加载到内存中buffer page中</strong></p><p><strong>2.实时写入数据undo</strong></p><p><strong>3.修改过程加载到redo中</strong></p><p><strong>4.redo缓冲区的内容读入数据缓冲区</strong></p><p><strong>5.undo找事务日志有没有最后执行commit</strong></p><p><strong>6.没有commit, undo会回滚到原数据</strong></p></blockquote><p style=text-align:start><em><strong>注意：不同情况下的恢复结果</strong></em></p><blockquote><p>1.还没有commit的时候，数据也没有定时写入，断电了</p><p>　　数据缓冲区和redo缓冲区都是原状态，undo找不到commit， 会回滚事务日志到原数据。结果：保持不变，不会修改。</p><p>2.还没有commit,数据定时写入了，断电了</p><p>　　数据缓冲区是原状态，redo缓冲区是修改后的状态， undo 找不到commit , 会回滚到事务日志到原数据。 结果： 保持不变，不会修改。</p><p>3.commit了，但是数据还没有写入到ibd文件中，断电了</p><p>　　数据缓冲区是原状态，redo缓冲区是修改后的状态， undo 找到commit , 会认为要修改数据。 结果：修改。</p></blockquote><h1 class=pgc-h-arrow-right><strong>9.事务日志undo</strong></h1><p style=text-align:start><strong>1）undo是什么？</strong></p><p style=text-align:start>undo,顾名思义“回滚日志”，是事务日志的一种。</p><p style=text-align:start><strong>2）作用是什么？</strong></p><p style=text-align:start>在事务ACID过程中，实现的是“A”原子性的作用。当然CI的特性也和undo有关</p><h1 class=pgc-h-arrow-right>10.redo和undo的存储位置</h1><pre><code>#redo位置[root@db01 data]# ll /application/mysql/data/-rw-rw---- 1 mysql mysql 50331648 Aug 15 06:34 ib_logfile0-rw-rw---- 1 mysql mysql 50331648 Mar  6  2017 ib_logfile1#undo位置[root@db01 data]# ll /application/mysql/data/-rw-rw---- 1 mysql mysql 79691776 Aug 15 06:34 ibdata1-rw-rw---- 1 mysql mysql 79691776 Aug 15 06:34 ibdata2</code></pre><p>在MySQL5.6版本中undo是在ibdata文件中，在MySQL5.7版本会独立出来。</p><h1 class=pgc-h-arrow-right><strong>11.事务中的锁</strong></h1><p style=text-align:start><strong>1）什么是“锁”？</strong></p><p style=text-align:start>“锁”顾名思义就是锁定的意思。</p><p style=text-align:start><strong>2）“锁”的作用是什么？</strong></p><p style=text-align:start>在事务ACID特性过程中，“锁”和“隔离级别”一起来实现“I”隔离性的作用。</p><div class=pgc-img><img alt="Mysql --09 Innodb核心特性——事务" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d5181bac762a48b4a309bc79bc2eb5fe><p class=pgc-img-caption></p></div><p>排他锁：保证在多事务操作时，数据的一致性。</p><p style=text-align:start>共享锁：保证在多事务工作期间，仍然允许被查询，数据查询时不会被阻塞。</p><p style=text-align:start>乐观锁：谁先提交谁为准（例如：以前买火车票，提交订单，在指定时间还未付款时，票的信息还是谁都能看到，谁抢到算谁的）</p><p style=text-align:start>悲观锁：谁先修改谁为准（例如：现在买火车票，提交订单，在指定时间还未付款时，票的信息别人看不到，自己优先。除非超过时间）</p><h1 class=pgc-h-arrow-right><strong>12.多版本并发控制（MVCC）</strong></h1><p style=text-align:start>1）只阻塞修改类操作，不阻塞查询类操作（排它锁和共享锁）<br>2）乐观锁的机制（谁先提交谁为准）</p><h1 class=pgc-h-arrow-right><strong>13.锁的粒度</strong></h1><p style=text-align:start>MyIsam：低并发锁（表级锁），不支持事务。<br>Innodb：高并发锁（行级锁），必须要有聚集索引才能做到行级锁</p><h1 class=pgc-h-arrow-right><strong>14.事务的隔离级别</strong></h1><p style=text-align:start><em>四种隔离级别：</em></p><p style=text-align:start>READ UNCOMMITTED（独立提交） RU级别<br>允许事务查看其他事务所进行的未提交更改</p><p style=text-align:start>READ COMMITTED RC级别<br>允许事务查看其他事务所进行的已提交更改</p><p style=text-align:start>REPEATABLE READ RR级别<br>确保每个事务的 SELECT 输出一致<br>InnoDB 的默认级别</p><p style=text-align:start>SERIALIZABLE 串行化级别<br>将一个事务的结果与其他事务完全隔离</p><pre><code>#查看隔离级别mysql&gt; show variables like '%iso%';+---------------+-----------------+| Variable_name | Value           |+---------------+-----------------+| tx_isolation  | REPEATABLE-READ |+---------------+-----------------+1 row in set (0.00 sec)#修改隔离级别为RU  vim /etc/my.cnf[mysqld]transaction_isolation=read-uncommitmysql&gt; use oldboymysql&gt; select * from stu;mysql&gt; insert into stu(id,name,sex,money) values(2,'li4','f',123);#修改隔离级别为RCvim /etc/my.cnf[mysqld]transaction_isolation=read-commit</code></pre><h1 class=pgc-h-arrow-right><strong>15.脏读 幻读 重复读 查询原因，和解决办法 (RR级别)</strong></h1><p style=text-align:start><strong>1.脏读</strong></p><p style=text-align:start>一个事务读到另一个事务，尚未提交的修改，就是脏读。这里所谓的修改，除了Update操作,还包括Insert和Delete操作。<br>脏读的后果：如果后一个事务回滚，那么它所做的修改，统统都会被撤销。前一个事务读到的数据，就是垃圾数据。</p><p style=text-align:start>示例：</p><pre><code>例子：预订房间。有一张Reservation表，往表中插入一条记录，来订购一个房间。事务1：在Reservation表中插入一条记录，用于预订99号房间。事务2：查询，尚未预定的房间列表，因为99号房间，已经被事务1预订。所以不在列表中。事务1：信用卡付款。由于付款失败，导致整个事务回滚。所以插入到Reservation 表中的记录并不置为持久（即它将被删除）。现在99号房间则为可用。所以，事务2所用的是一个无效的房间列表，因为99号房间，已经可用。如果它是最后一个没有被预定的房间，那么这将是一个严重的失误。注：脏读的后果很严重。</code></pre><p><strong>2.不可重复读</strong></p><p style=text-align:start>在同一个事务中，再次读取数据时【就是你的select操作】，所读取的数据，和第1次读取的数据，不一样了。就是不可重复读。</p><p style=text-align:start>示例：</p><pre><code>举个例子：事务1：查询99号房间是否为双人床房间。结果99号是。事务2：将99号房间，改成单人床房间。事务1：再次执行查询，99号房间不是双人房了。也就是说， 事务1，可以看到其他事务所做的修改。在不可重复读，里面，可以看到其他事务所做的修改，而导致2次的查询结果不再一样了。这里的修改，是提交过的。也可以是没有提交的，这种情况同时也是脏读。如果，数据库系统的隔离级别。允许，不可重复读。那么你启动一个事务，并做一个select查询操作。查询到的数据，就有可能，和你第2次，3次...n次，查询到的数据不一样。一般情况下，你只会做一次，select查询，并以这一次的查询数据，作为后续计算的基础。因为允许出现，不可重复读。那么任何时候，查询到的数据，都有可能被其他事务更新，查询的结果将是不确定的。注：如果允许，不可重复读，你的查询结果，将是不确定的。一个不确定的结果，你能容忍吗？</code></pre><p><strong>3.幻读</strong><br>事务1读取指定的where子句所返回的一些行。然后，事务2插入一个新行，这个新行也满足事务1使用的查询<br>where子句。然后事务1再次使用相同的查询读取行，但是现在它看到了事务2刚插入的行。这个行为被称为幻象，<br>因为对事务1来说，这一行的出现是不可思议的。</p><p style=text-align:start>示例：</p><pre><code>事务1：请求没有预定的，双人床房间列表。99号在其中。事务2：向Reservation表中插入一个新纪录，以预订99号房间，并提交。事务1：再次请求有双人床的未预定的房间列表，99号房间，不再位于列表中。注：幻读，针对的是，Insert操作。如果事务2，插入的记录，没有提交。那么同时也是脏读。</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Mysql','--','09'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>