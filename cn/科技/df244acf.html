<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>了解 JavaScript 的 rest参数与扩展运算符 (ES6) | 极客快訊</title><meta property="og:title" content="了解 JavaScript 的 rest参数与扩展运算符 (ES6) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/96f6a301-9c86-48d2-8018-7e600bb152c9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df244acf.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df244acf.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df244acf.html><meta property="article:published_time" content="2020-11-14T21:01:00+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:00+08:00"><meta name=Keywords content><meta name=description content="了解 JavaScript 的 rest参数与扩展运算符 (ES6)"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/df244acf.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>了解 JavaScript 的 rest参数与扩展运算符 (ES6)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-center-line>引言</h1><p>我们知道，许多 JavaScript 内置函数在调用它们的时候，可以传入任意数量的参数。</p><p>例如：</p><ul><li>Math.max(arg1, arg2, ..., argN) - 返回最大的那个参数。</li><li>Object.assign(obj, src1, ..., srcN) - 将 src1 .. srcN 这些属性拷贝到对象 obj<strong> </strong>中。</li><li>诸如此类，还有很多 ... 。</li></ul><p>在本篇文章中，就说说我们自己声明的函数如何去接收任意多数量的参数，以及如何将一个现成的数组打散成一个参数列表。最后还会讨论一下数组及对象的拷贝问题。</p><div class=pgc-img><img alt="了解 JavaScript 的 rest参数与扩展运算符 (ES6)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/96f6a301-9c86-48d2-8018-7e600bb152c9><p class=pgc-img-caption></p></div><h1 class=pgc-h-center-line>思考</h1><p>首先，我们先思考一个问题。</p><p>假如我们有一个需求，需要一个函数，通过传参，返回一个基本的用户信息组成的一个数组，这个需求目前很简单，只需要通过参数收集用户ID和姓名就行了：</p><pre><code>function user(id, username) {  let userArr = [];  userArr.push(id);  userArr.push(username);  return userArr;}console.log(user(1, 'Tom')); // [1, 'Tom']</code></pre><p>这段代码没有任何问题，但现在需求改了，我们还需要一个用户的年龄，于是我可以这么调用这个函数：</p><pre><code>user(1, 'Tom', 18); // 发现结果还是 [1, 'Tom']</code></pre><p>虽然结果没有把年龄加进去，但这至少可以肯定一个问题：<strong>“函数可以使用任意数量的参数调用，无论函数的参数是如何定义的，它不会因为 “过剩” 的参数调用而出现错误” </strong>，但只有函数声明中出现在形参位置的参数才会在函数体内被计算。</p><p>这时候要想把年龄也返回，我们必须还要经历 2 步：</p><ul><li>在声明函数的时候将它作为形参传入函数体。</li><li>在函数体内进行一个 push 操作。</li></ul><pre><code>function user(id, username, age) {  let userArr = [];  userArr.push(id);  userArr.push(username);  userArr.push(age);  returnuserArr;}console.log(user(1, 'Tom', 18)); // [1, "Tom", 18]</code></pre><p>这回我们成功了，结果正确了，但现在需求又变了，我们还要添加性别并返回，于是我们还要手动的去重复上面添加年龄的 2 个步骤。随着业务的发展，我们还要添加诸如职位，工资，保险 ... 等一系列的参数。</p><p>可以说每添加一个参数，就需要我们重复修改函数定义。</p><h1 class=pgc-h-center-line>rest 参数 "..."</h1><p>上面提出的问题该如何解决呢？</p><p>于是 <strong>rest 参数 </strong>的概念出现了，正如我们上面提到的：</p><blockquote><p>随着业务的发展，我们还要添加诸如职位，工资，保险 ... 等一系列的参数。</p></blockquote><p>引用中的 “诸如 ...” ，这个省略号非常的形象，于是我们的 <strong>rest 参数</strong> 也非常尽如人意，用 <strong>...省略的那些参数</strong> 的表现形式呈现了。</p><p>具体来讲，<strong>rest 参数</strong> 可以当作函数的参数使用，它使用 '<strong>...</strong>' 后面接跟着一个保存你所有参数的数组名称，'<strong>...</strong>' 的意思就是 <strong>将我剩余的参数收集到一个数组中</strong> 。</p><p>还是我们上面的需求，改成 <strong>rest 参数</strong> 的时候，可以是这样：</p><pre><code>function user(...userInfos) {  let userArr = [];  for(let info of userInfos) {    userArr.push(info);  }  returnuserArr;}console.log(user(1, 'Tom')); // [1, "Tom"]console.log(user(1, 'Tom', 18)); // [1, "Tom", 18]console.log(user(1, 'Tom', 18, '男')); // [1, "Tom", 18, "男"]</code></pre><p>上面的示例，我们将调用时传的实参收集到了 userInfos<strong> </strong>的数组中了，函数内部我们可以直接操作这个数组了。</p><p>这个示例和最文章开头的示例相比，优点不言而喻，最重要的是，如果你这么做了，你根本不用修改你定义好的数组 (包括声明的形参与函数体)。</p><p>当然，我们的 <strong>rest 参数</strong> 还可以这么用：</p><pre><code>function user(userId, username, ...userInfos) {  let userArr = [];  let obj = {    '编号': userId,    '姓名': username  }  // 因为 userInfos是数组，所以可以  // 用 for ... of 循环  for(let info of userInfos) {    userArr.push(info);  }  // 因为 userInfos是数组，所以  // 有 length 属性  if(userInfos.length) {    obj['备注信息'] = userArr;  }  return obj}console.log(user(1, 'Tom'));console.log(user(2, 'James', 18));console.log(user(3, 'Kylin', 22, '前端开发'));/*  result: 1  {    '编号': 1,    '姓名': 'Tom'  }  result: 2  {    '编号': 2,    '姓名': 'James',    '备注信息': [18]  }  result: 3  {    '编号': 3,    '姓名': 'Kylin',    '备注信息': [22, '前端开发']  }*/</code></pre><p>上面的示例，你可以这样理解，假如一条用户记录有某些字段，在业务需求上是必要的信息，例如上例中函数的形参 userId ，username 等，那么你就可以将它们作为形参变量，而其余的参数作为备注信息收集到 userInfos 中。</p><p>这里关于 <strong>rest 参数</strong> 有一个必须注意的问题：</p><blockquote><p>rest 参数 只能是函数形参的最后一个。</p></blockquote><p>好比这样的代码，<strong>rest 参数</strong> 收集了所有剩余的参数，在 <strong>rest 参数</strong> 后面的参数，就显得没有任何意义了。因此下面的操作会导致错误：<strong>Rest parameter must be last formal parameter </strong>：</p><pre><code>function user(userId,  ...userInfos, username) {}</code></pre><p>最后一个值得注意的问题，在函数内部，我们可以往<strong> rest 参数 </strong>中增加元素或修改吗？</p><pre><code>function user(...userInfo) {  let userArr = [];  userInfo.push('男'); // 增加性别  userInfo[0] = 999; // 修改 ID  for(let info of userInfo) {    userArr.push(info);  }  console.log(userArr);}user(1, 'Tom'); // [999, "Tom", "男"]</code></pre><p>上例运行结果，证实，你完全可以这么做，因为：</p><blockquote><p><strong>rest 参数</strong> 可以当作函数的参数使用，它使用 '<strong>...</strong>' 后面接跟着一个保存你所有参数的数组名称，'<strong>...</strong>' 的意思就是 <strong>将我剩余的参数收集到一个数组中</strong> 。</p></blockquote><p><strong>rest 参数 </strong>就是一个数组啊，所以可以用数组的操作方法。</p><h1 class=pgc-h-center-line>"arguments" 对象</h1><p>在 <strong>rest 参数</strong> 出现之前，还有一个名为 <strong>arguments</strong> 的特殊类数组对象，它根据参数的索引包含所有参数：</p><pre><code>function user() {  let userArr = [];  for(let arg of arguments) {    userArr.push(arg);  }  console.log(userArr);}user(1, 'Tom'); // [1, "Tom"]user(1, 'Tom', 18); // [1, "Tom", 18]</code></pre><p>在过去，JavaScript 语言中并不存在 <strong>rest 参数</strong> ，使用 arguments 是获得函数所有参数的唯一方法。它仍然有效，我们依然可以在一些旧代码中找到它的踪迹。</p><p>但 arguments<strong> </strong>也有缺点，例如我们上面提到的：</p><blockquote><p>假如一条用户记录有某些字段，在业务需求上是必要的信息，例如上例中函数的形参 userId ，username 等</p></blockquote><p>1、所以，你无法从业务角度出发，从代码可读性的视角定义你所需要的必要参数，因为 arguments 总包含所有的参数，它并不像 <strong>rest 参数 </strong>可以部分地捕获参数。</p><p>2、其次，尽管参数既像数组又可迭代，但它确实不是数组。它不支持数组特有的方法，因此我们不能调用 <strong>arguments.map(…) </strong>、<strong>arguments.every(...) </strong>，这些数组特有的方法，如果你想使用它们，则必须借助 <strong>call</strong> 、<strong>apply</strong> 这些函数，例如，输出一组数的平方根，你可以这样：</p><pre><code>function sqr() {  console.log([].map.call(arguments, Math.sqrt)); }sqr(4, 9, 16, 25); // [2, 3, 4, 5]</code></pre><p>3、再思考一下，arguments 对象可以添加或修改元素自身元素吗？</p><pre><code>function user() {  // arguments.push('男'); // 增加性别  arguments[0] = 999;  console.log(arguments);}user(1, 'Tom'); // 999</code></pre><p>可以看到，增加不可以，因为它并不是数组，而修改却可以，如果你确定需要增加元素，请使用 [].push.call(arguments, '男');<strong> 。</strong></p><p>我们再看一下带参数的情况下我们要想修改元素的值会怎样？</p><pre><code>function user(id) {  arguments[0] = 999;  console.log([id, arguments[0]]);}user(1);</code></pre><p>上面的代码，在非严格模式下输出 [999, 999] ，在严格模式下输出 [1, 999] ，这是因为严格模式下，arguments 不再追踪参数的变化了。可见 arguments<strong> </strong>在严格模式与非严格模式下存在着很多差异，这仅仅是你所看到的其中一点。</p><p>基于以上 3 点原因，如果你还在用 JavaScript 编写具有此特性的代码，那么我极力推荐你将 <strong>rest 参数</strong> 作为你的首选。</p><p>既然谈到了 arguments 对象，我们还要说一个话题：箭头函数中，没有 arguments<strong> </strong>对象，如果你试图在箭头函数中使用 arguments<strong> </strong>对象，程序将报错：</p><pre><code>function normalFun() {  console.log(arguments[0]);}let arrowFun = () =&gt; {  console.log(arguments[0]);}normalFun('demo'); // demoarrowFun('demo'); // ReferenceError: arguments is not defined</code></pre><p>可以看到，全局中箭头函数是没有 arguments 对象的，但如果你试图在普通的 function<strong> </strong>中声明的箭头函数内使用 arguments 对象，那么它将会从包含它的外部 function 定义的函数获取，就像下面的代码一样：</p><pre><code>function normalFun() {  console.log(arguments[0]);  let arrowFun = () =&gt; {    console.log(arguments[0]); // normalFun 的 arguments对象  }  arrowFun();}normalFun('demo'); // demo demo</code></pre><p>好了，现在我们知道，关于箭头函数，不仅没有 this ，而且也没有 arguments 对象。</p><h1 class=pgc-h-center-line>扩展运算符</h1><p>我们已经了解了<strong> rest 参数 </strong>，即如何从函数参数列表中获取数组。</p><p>但是，有时候我们正好需要一个恰恰相反的操作，即我们要从数组中把元素逐个展开，形成一个列表，这就是 <strong>扩展运算符</strong> 的用途。</p><blockquote><p>学习知识要善于思考，思考，再思。我就是靠这个方法成为科学家的。</p><p><br></p><p>爱因斯坦</p></blockquote><p>好了，再继续思考，在 JavaScript 中，有一个内置的函数 Math.max ，它用于在一个数字列表中返回最大的那个数：</p><pre><code>console.log(Math.max(1, 2, 3)); // 3</code></pre><p>没错，输出了数字 3 ，好了，我们现在要定义这么一个列表，这个列表包含很多数字，没办法，我们只能使用数组去定义它：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];</code></pre><p>现在，我们把这个列表传给 Math.max 函数，看看它如何计算我们的列表：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];console.log(Math.max(nums)); // NaN</code></pre><div class=pgc-img><img alt="了解 JavaScript 的 rest参数与扩展运算符 (ES6)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/8db9304e-4251-4b24-a952-bc4ef7294761><p class=pgc-img-caption></p></div><p>我以为会执行成功，可结果为 NaN ，Math.max<strong> </strong>无法正常工作，因为 Math.max 需要的是一个数字列表，而不是一个数组，好吧，修改一下：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];// 10console.log(Math.max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]));</code></pre><p>这回，正常了，可是这些代码简直是太糟糕了，可读性是一方面，更关键的是，现实中，手动输入一个数字列表并不现实，我们的数字列表可不止就这些数字，它也许有很多，也许就一个，又或许一个都没有，这会让我们的实际情况变得非常糟糕。</p><p><strong>展开运算符 </strong>可以很好的解决这个问题，它和 <strong>rest 参数</strong> 非常相似，也是使用 '<strong>...</strong>' ，但用途恰恰相反。</p><div class=pgc-img><img alt="了解 JavaScript 的 rest参数与扩展运算符 (ES6)" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/831153eb-1ff9-4678-b6bd-605021c4b96a><p class=pgc-img-caption></p></div><p>当 ...args<strong> </strong>作为一个实参，用于函数调用的参数的时候，它可以遍历 args 中的所有元素，并将它们转化为调用函数所需的参数列表，而 <strong>rest 参数</strong> 则用于声明函数的形参，将剩余的参数收集成一个数组：</p><pre><code>// rest 参数 用于形参的声明function user(...rest) {  // rest 是形参组成的数组}// 扩展运算符，用于函数的调用Math.max(...args);// args 是一个数组，但它作为函数调用的实参// 就变成了，将这个数组拆开成一个普通的列表// 这个列表就是 Math.max 的各个参数，如：// Math.max(1,2,3) // ...args =&gt; 1, 2, 3</code></pre><p>还是上面的例子：</p><pre><code>let nums = [1, 2, 6, 4, 3, 10];console.log(Math.max(...nums)); // 10</code></pre><p>我们再也不用手动输入这个数字列表了。</p><p>不光如此，你还可以传递多个 <strong>扩展运算符 </strong>，这也很强大：</p><pre><code>let nums1 = [1, 2, 6, 4, 3, 10];let nums2 = [12, -2, 16, 34, -3, 100];console.log(Math.max(...nums1, ...nums2)); // 100</code></pre><p>我们甚至可以将 <strong>扩展运算符</strong> 与正常值一起使用：</p><pre><code>let nums1 = [1, 2, 6, 4, 3, 10];let nums2 = [12, -2, 16, 34, -3, 100];console.log(Math.max(-200, ...nums1, 88, ...nums2, 888)); // 888</code></pre><p>除此之外，我们也可以利用 <strong>扩展运算符</strong> 将两个数组合并成一个数组：</p><pre><code>let nums1 = [1,2];let nums2 = [3,4];let merged = [-100, ...nums1, ...nums2, 100];console.log(merged); // [-100, 1, 2, 3, 4, 100]</code></pre><p>其实，任何可遍历的元素，都可以利用 <strong>扩展运算符 </strong>，比如说，字符串可以转换成字符数组：</p><pre><code>let str = 'hello';console.log([...str]); // ["h", "e", "l", "l", "o"]</code></pre><p>基于 <strong>扩展运算符</strong> 的特性，我们也可以把 <strong>扩展运算符</strong> 叫做 <strong>展开运算符</strong> 。</p><p><strong>扩展运算符</strong> 用途不止如此，你还可以扩展一个对象：</p><pre><code>let person = {name: 'Tom', age: 18};let personCopy = {...person, sex: '男'};console.log(personCopy); // {name: "Tom", age: 18, sex: "男"}</code></pre><p>关于 <strong>扩展运算符</strong> ，还有一点值得注意：</p><pre><code>let nums = [1, 2, 3];let numsCopy = ...nums; // 报错了</code></pre><p>上面的写法报错了，你应该这么写：</p><pre><code>let nums = [1, 2, 3];let numsCopy = [...nums];</code></pre><p>像这种在赋值运算符右侧的 '<strong>...</strong>' ，也应该当作 <strong>扩展运算符</strong> 使用。</p><h1 class=pgc-h-center-line>数组和对象的拷贝</h1><p>先解释一下浅拷贝与深拷贝，简单说：</p><ul><li><strong>浅拷贝</strong>：拷贝对象里的基本类型，而不拷贝对象里的引用类型。</li><li><strong>深拷贝</strong>：完全克隆出一个对象，数据相同，但整体拷贝出来的对象与原来的对象具有不同的引用，且修改任何一个对象的子对象不会影响另一个对象。</li></ul><p>好了，首先，有这么一段代码：</p><pre><code>let arr1 = [1,2]let arr2 = [...arr1];console.log(arr1 === arr2); // falsearr1[0] = 100;console.log(arr1); // [100, 2]console.log(arr2); // [1, 2]</code></pre><p>很好，完成拷贝了，但它算深拷贝吗？看一下深拷贝的定义，arr1 与 arr2 的引用确实不同，似乎是深拷贝吧？别急，再看一个例子：</p><pre><code>let arr1 = [1, 2, [3, 4]];let arr2 = [...arr1];console.log(arr1 === arr2); // falsearr1[2][1] = 100;console.log(arr1); // [1, 2, [3, 100]]console.log(arr2); // [1, 2, [3, 100]]</code></pre><p>引用地址虽然不同，但修改了 arr1[2][1] ，结果 arr2<strong> </strong>的结果也变了，这说明 arr2<strong> </strong>数组并没有拷贝 arr1 数组的子数组引用，因此，这是一个浅拷贝，用图例看一下在 let arr2 = [...arr1]; 之后的情形：</p><div class=pgc-img><img alt="了解 JavaScript 的 rest参数与扩展运算符 (ES6)" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/802749b0a438497c8ebce958134f95f0><p class=pgc-img-caption>数组拷贝</p></div><p>就像图中看到的那样，即使 arr1<strong> </strong>和 arr2<strong> </strong>各自保存自己的引用，但它们索引为 2 的子元素却指向了共同的位置，所以，修改它们其中一个，结果也会反映在另一个数组中。</p><p>那如何进行进行数组的深拷贝呢？现在我们来看看：</p><pre><code>let arr1 = [1,2,[3,4]]let arr2 = JSON.parse(JSON.stringify(arr1));console.log([typeof JSON.stringify(arr1), JSON.stringify(arr1)]);console.log([typeof JSON.parse(JSON.stringify(arr1)), JSON.parse(JSON.stringify(arr1))]);console.log(arr1 === arr2); // falsearr1[2][1] = 100;console.log(arr1); // [1, 2, [3, 100]]console.log(arr2); // [1, 2, [3, 4]]</code></pre><p>关键在第 2 行代码，我们先利用 JSON.stringify(arr1); 将数组转换成一个 JSON 字符串，这样它就是一个静态的东西了，不管它里面写的什么，它就是一个静态的文本，所以不存在引用问题。然后通过 JSON.parse() 方法将这个字符串转换成 JavaScript 对象，而这个转换好的 JavaScript 对象就是 arr1 的一个副本了。</p><p>例如，代码中的第 3 行的显示是一个字符串：["string", "[1,2,[3,4]]"] ，代码第 4 行，显示的是将字符串转换成 JavaScript 对象的结果：["object", Array(3)] 。</p><p>对象的拷贝与数组类似：</p><pre><code>let person1 = {  name: '张三',  info: {    sex: '男',    age: 18,    score:[70,100,66]  }}let person2 = JSON.parse(JSON.stringify(person1));person2.info.sex = '女';person2.info.age = 26;person2.info.work = '前端开发';person2.info.score[0] = 99;console.log(person1); // {sex: "男", age: 18, score: [70, 100, 66]}console.log(person2); // {sex: "女", age: 26, score: [99, 100, 66], work: "前端开发"}</code></pre><h1 class=pgc-h-center-line>总结</h1><p>当我们在代码中看到 '…' 时，它要么是 <strong>rest 参数</strong> ，要么是 <strong>扩展运算符</strong> 。</p><p>有一个简单的方法来区别它们：</p><ul><li>当 '<strong>...</strong>' 在函数参数的末尾，它就是一个 <strong>rest 参数 </strong>，它将参数列表的其余部分收集到一个数组中。</li><li>当 '<strong>…</strong>' 发生在函数调用或赋值运算符右侧的情况下，它就是一个 <strong>扩展运算符</strong> ，将数组或对象扩展为一个列表。<strong>扩展运算符 </strong>一般用于将数组传递给通常需要多个参数的函数，如 Math.max() 函数。</li></ul><p>文章中的图片来源于网络，若有侵权行为，请在后台与我联系。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'算符','了解','JavaScript'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>