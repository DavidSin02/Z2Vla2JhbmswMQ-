<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>在Python中实现SIFT | 极客快訊</title><meta property="og:title" content="在Python中实现SIFT - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/4d54a888a82a417f9de8881a364524ef"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df36780.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df36780.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df36780.html><meta property="article:published_time" content="2020-10-29T20:51:13+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:13+08:00"><meta name=Keywords content><meta name=description content="在Python中实现SIFT"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/df36780.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>在Python中实现SIFT</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>关于SIFT有很多内容。有很多很好的教程，但每个都似乎缺少一些东西，无论是关于算法还是实现的细节。因此，当我决定为自己实施SIFT时，我发现自己很难从许多来源中提取内容。我完成了一部分任务，现在分享我的过程以及其他教程未提及的一些细节。</p><p><strong>介绍</strong></p><p>对于初学者来说，SIFT是什么？SIFT是尺度不变特征变换，是一种用于提取描述图像的局部斑块的特征向量的方法。这些特征向量不仅具有尺度不变性，而且对于平移，旋转和光照度也是不变的。几乎是描述符的圣杯。</p><p>这些描述符对于匹配对象是图像之间的补丁非常有用。例如，考虑创建全景图。假设每个图像都有一些重叠的部分，你需要一些方法来对齐它们，这样我们就可以将它们拼接在一起。如果我们知道每个图像中有一些点对应，我们可以使用单应性来扭曲其中一个图像。SIFT不仅可以自动查找每个图像中的对应点，还可以自动查找易于匹配的点。</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4d54a888a82a417f9de8881a364524ef><p class=pgc-img-caption>两个图像具有重叠区域</p></div><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7705b63956514d88b71dc2e07d36a437><p class=pgc-img-caption>使用SIFT特征点的单应性转换一个图像后的结果</p></div><p><strong>算法描述</strong></p><p>SIFT算法有五个主要步骤：</p><ol><li>尺度空间极值检测</li><li>关键点本地化</li><li>消除边缘响应</li><li>方向分配</li><li>本地描述符创建</li></ol><p>尺度空间极值检测</p><p>可以使用标度归一化的拉普拉斯高斯（LoG）滤波器来检测特征的特征尺度。这就是LoG过滤器的样子：</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27e9d3b8b67640e3862a3b836294e2b2><p class=pgc-img-caption></p></div><p><strong>负面的</strong></p><p>LoG滤波器在中心处具有高峰值，同时变为略微负的，然后在距离中心一定距离处为零，其特征在于高斯的标准偏差sigma（∑，σ）。</p><p>因此，LoG滤波器由圆或blob最高度激活，半径与sigma成比例。然而，高斯是标准化的分布，即如果你将它整合到所有空间，它总和为1。因此，对于更高的sigma并因此更宽的高斯，LoG滤波器对该高斯的响应将低于较小的sigma。因此，SIFT使用<strong>标准归一化的</strong> LoG滤波器，它是常规LoG乘以方差（sigma平方）。</p><p>DoG（Difference of Gaussian）近似</p><p>虽然规模标准化的LoG很好，但计算成本很高，特别是因为我们需要在许多不同的尺度上进行计算。不过，SIFT的作者提出了一种巧妙的方法来有效地计算许多尺度的LoG。</p><p>事实证明，具有相似方差的两个高斯的差异产生的滤波器非常接近于尺度标准化的LoG：</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7ff08a5cd79d4805b93c2ff9306fab2a><p class=pgc-img-caption>两个高斯的差异近似于高斯的拉普拉斯算子</p></div><p>DoG（Difference of Gaussian）金字塔</p><p>既然我们有一种有效的方法来逼近LoG，我们需要在多个尺度上进行计算。SIFT使用多个Octave来计算DoG。大多数人会认为计算八个图像需要八个Octave来使用。然而，Octave实际上是一组图像，其中最后一个图像的模糊是第一个图像的模糊的<strong>两倍</strong>。</p><p>要创建这个Octave，我们首先需要选择每个Octave中想要的图像数量。这由s表示。然后选择高斯滤波器的sigma为2 ^（1 / s）。由于模糊累积累加，当我们使用此滤镜s次模糊原始图像时，结果将具有模糊= 2 *原始模糊。</p><p>我很少看到的其他内容中的一个细节是，在每个Octave中，你实际上需要产生s + 3个图像（包括原始图像）。这是因为当减去相邻级别以获得近似的LoG Octave时，我们将获得比Gaussian octave少一个的图像：</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/41425698049946cf831a239b5d9dad21><p class=pgc-img-caption>用于SIFT的高斯金字塔</p></div><p>现在我们在DoG Octave中有s + 2个图像。但是，稍后当我们在DoG中查找极值时，我们将查找当前和相邻级别指定的邻域的最小值或最大值。显然，这个邻域不能在顶层或底层获得，所以我们有这两个额外的层次，以便在缩放空间中定义一个完整的Octave。</p><p>在我们生成Gaussian octave之后，我们将顶级下采样2并将其用作新Octave的底层。这些Octave组成了我所说的高斯金字塔。</p><p>履行</p><p>最后我们得到了一些代码。首先，我们显然需要一个高斯滤波器来创建Gaussian octave：</p><pre>def gaussian_filter(sigma):size = 2*np.ceil(3*sigma)+1x, y = np.mgrid[-size//2 + 1:size//2 + 1, -size//2 + 1:size//2 + 1] g = np.exp(-((x**2 + y**2)/(2.0*sigma**2))) / (2*np.pi*sigma**2)return g/g.sum() </pre><p>这假设numpy已经作为np导入（因为它总是应该）。我也把它放在一个名为的文件中gaussian_filter.py。接下来，为了生成Gaussian octave，我们只需要选择sigma并用这个高斯滤波器重复卷积：</p><pre>from scipy.ndimage.filters import convolvefrom gaussian_filter import gaussian_filter  def generate_octave(init_level, s, sigma):octave = [init_level]k = 2**(1/s)kernel = gaussian_filter(k * sigma)  for _in range(s+2):next_level = convolve(octave[-1], kernel)octave.append(next_level) return octave</pre><p>正如在文中，我使用的是5。另一个需要注意的是sigma参数。此参数用于缩放k，以便每个DoG octave中的模糊来自sigma - > 2 * sigma。我为sigma使用值1.6。然后生成整个高斯金字塔：</p><pre> def generate_gaussian_pyramid(im, num_octave, s, sigma):pyr = [] for _ in range(num_octave):octave = generate_octave(im, s, sigma)pyr.append(octave)im = octave[-3][::2, ::2] return pyr</pre><p>由于我们每个Octave生成s + 3个图像，我们使用第三个到最后一个图像作为下一个Octave的基础，因为那是一个模糊为2 * sigma的图像。</p><p>现在我们有了高斯金字塔，创建DoG金字塔是很简单的：</p><pre> def generate_DoG_octave(gaussian_octave):octave = [] for i in range(1, len(gaussian_octave)):octave.append(gaussian_octave[i] — gaussian_octave[i-1]) return np.concatenate([o[:,:,np.newaxis] for o in octave], axis=2） def generate_DoG_pyramid(gaussian_pyramid):pyr = [] for gaussian_octave in gaussian_pyramid:pyr.append(generate_DoG_octave(gaussian_octave)) return pyr</pre><p>现在我们有四个DoG octave，每个都有s + 2级模糊。我们现在可以继续检测尺度空间中的极值。</p><p>极值检测</p><p>极值检测的第一步是扫描每个标度空间DoG octave的 D值，并将每个3x3x3邻域的中心作为关键点，如果它是邻域中的最小值或最大值。</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e4070c372c6d452a9e6ae55c1d72e3e0><p class=pgc-img-caption>初始尺度空间极值检测的邻域</p></div><p>这就是为什么我们在DoG octave中生成s + 2级别的原因，因为我们无法扫描顶部或底部的点，但我们仍然想要在整个Octave模糊点上获得关键点。</p><p>履行</p><p>给定DoG octave，我们获得初始候选关键点：</p><pre> def get_candidate_keypoints(D, w=16):candidates = []D[:,:,0] = 0D[:,:,-1] = 0 for i in range(w//2+1, D.shape[0]-w//2–1):for j in range(w//2+1, D.shape[1]-w//2–1):for k in range(1, D.shape[2]-1):patch = D[i-1:i+2, j-1:j+2, k-1:k+2]if np.argmax(patch) == 13 or np.argmin(patch) == 13:candidates.append([i, j, k]) return candidates</pre><p>这段代码的内容解释：</p><p>我将顶部和底部的额外级别设置为0，因为我最初只是在这些级别中获得极值。这可能是因为DoG octave的构造不正确，但却运行得还可以。</p><ol><li>我们有一个w / 2的填充，而不是在每个级别上使用一个填充进行扫描，其中w是创建局部描述符时使用的补丁的边长。没有这个，就会出错误。</li><li>调用argmax或argmin不调用轴参数在展平的数组上运行。由于我们的邻域是3x3x3或27个元素长，当极值是我们检查的像素时，argmax或argmin的值将是13。</li></ol><p>这些候选关键点会产生许多糟糕的选择和噪声，因此在下一节中我们将选择好的关键点并抛弃部分不好的点。</p><p>关键点定位</p><p>我们将执行三个步骤来获得更好的关键点：</p><ol><li>计算每个关键点的子像素位置</li><li>如果子像素处的比例空间值低于阈值，则丢弃该关键点</li><li>使用围绕每个子像素关键点的Hessian消除边缘上的关键点</li></ol><p>子像素定位</p><p>在许多图像中，在分辨率不够精确的时候很难找到稳定的关键点，即在多个条件下在多个图像中的相同位置。因此，SIFT的创建者使用DoG octave的二阶Taylor展开来进一步定位每个关键点。</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a23102a79fed48f890482e07047e3844><p class=pgc-img-caption>DoG octave的二阶Taylor展开</p></div><p>这里，x是与备选关键点的像素位置对应的三维矢量[x，y，sigma]。将该等式的导数相对于x并将其设置为等于零，得到关键点的子像素偏移：</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99b0dd8272db43a19961885f74056026><p class=pgc-img-caption>备选关键点偏移（二阶）</p></div><p>将此偏移添加到原始关键点位置以实现子像素精度。</p><p><strong>实现</strong></p><p>我们需要围绕每个候选关键点计算Jacobian和Hessian以获得偏移量：</p><pre>def localize_keypoint(D, x, y, s):dx = (D[y,x+1,s]-D[y,x-1,s])/2.dy = (D[y+1,x,s]-D[y-1,x,s])/2.ds = (D[y,x,s+1]-D[y,x,s-1])/2. dxx = D[y,x+1,s]-2*D[y,x,s]+D[y,x-1,s] dxy = ((D[y+1,x+1,s]-D[y+1,x-1,s]) — (D[y-1,x+1,s]-D[y-1,x-1,s]))/4. dxs = ((D[y,x+1,s+1]-D[y,x-1,s+1]) — (D[y,x+1,s-1]-D[y,x-1,s-1]))/4. dyy = D[y+1,x,s]-2*D[y,x,s]+D[y-1,x,s]dys = ((D[y+1,x,s+1]-D[y-1,x,s+1]) — (D[y+1,x,s-1]-D[y-1,x,s-1]))/4.dss = D[y,x,s+1]-2*D[y,x,s]+D[y,x,s-1] J = np.array([dx, dy, ds])HD = np.array([ [dxx, dxy, dxs], [dxy, dyy, dys], [dxs, dys, dss]]) offset = -LA.inv(HD).dot(J)return offset, J, HD[:2,:2], x, y, s</pre><p>首先，计算雅可比行列式的一阶导数。然后，我们计算Hessian的二阶导数。Hessian是对称的，所以我们只需计算六个导数而不是九个。我们返回J和H因为我们以后会需要它们。</p><p>作为旁注，当偏移的维度大于0.5时，这意味着它实际上更接近另一个像素级关键点。</p><p><strong>丢弃低对比度关键点</strong></p><p>现在可以将每个子像素关键点的对比度计算为：</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e58678d970304374821c292894431d8a><p class=pgc-img-caption>子像素关键点对比度</p></div><p>哪个子像素偏移添加到像素级位置。如果绝对值低于阈值，我们就会抛出这一点。我们这样做是因为我们想要极端，极端，极端。</p><p>消除边缘响应</p><p>尺度标准化的LoG将在角落和边缘处创建高对比度响应。但是，边缘上的关键点应该被丢弃，因为它们的方向是模糊的。为此，我们使用计算子像素偏移时计算的Hessian。这个过程非常类似于使用Harris角点探测器寻找角点。</p><p>我们返回的Hessian localize_keypoint的形式如下：</p><div class=pgc-img><img alt=在Python中实现SIFT onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/390ca2d7b19344338b2c787548646359><p class=pgc-img-caption>Hessian在规模空间与曲率成比例</p></div><p>如果你熟悉Harris探测器，如果H的特征值（比如A和B）都很​​大，那么关键点很可能是一个角。相反，如果一个大得多，那么它很可能是边缘。</p><p>即使计算这个矩阵的特征值是很便宜的，还有另一种方法可以用来获取H的跟踪和行列式。我们将放弃在这里讨论。</p><p>实现</p><p>我们在以下功能中执行上述步骤：</p><pre> def find_keypoints_for_DoG_octave(D, R_th, t_c, w):candidates = get_candidate_keypoints(D, w)keypoints = [] for i, cand in enumerate(candidates):y, x, s = cand[0], cand[1], cand[2]offset, J, H, x, y, s = localize_keypoint(D, x, y, s) contrast = D[y,x,s] + .5*J.dot(offset)if abs(contrast) &lt; t_c: continue w, v = LA.eig(H)r = w[1]/w[0] R = (r+1)**2 / rif R &gt; R_th: continue kp = np.array([x, y, s]) + offsetkeypoints.append(kp) return np.array(keypoints)</pre><p>我使用来自paper的值t_c和R_th即分别为0.03和（10 + 1）2/10。</p><p>现在计算整个DoG金字塔的关键点是微不足道的：</p><pre> def get_keypoints(DoG_pyr, R_th, t_c, w):kps = [] for D in DoG_pyr:kps.append(find_keypoints_for_DoG_octave(D, R_th, t_c, w)) return kps</pre><p><strong>方向分配</strong></p><p>获得关键点只是成功的一半。现在我们必须获得实际的描述符。但在我们这样做之前，我们需要确保另一种不变性：旋转。</p><p>我们有平移不变性，因为我们在图像上对滤波器进行卷积。由于我们使用了标度归一化的LoG滤波器，因此我们也具有尺度不变性。现在为了施加旋转不变性，我们在每个关键点周围分配一个与其主要梯度方向相对应的方向。当我们使用梯度直方图描述符来描述每个补丁时，这会有点用的。</p><p>为了分配方向，我们在每个关键点周围采用一个补丁，其大小与该关键点的比例成正比。然后，我们为该补丁中的每个像素创建渐变的直方图。</p><p>直方图是在角度上创建的（梯度在极座标中指定）并且具有36个箱（每个箱具有10度的宽度）。当计算像素处的梯度的大小和角度时，我们的直方图中的对应区间增长了由高斯窗口加权的梯度大小。</p><p>一旦我们得到直方图，我们就为该关键点指定最大直方图bin的方向。</p><p>实现</p><pre> def assign_orientation(kps, octave, num_bins=36):new_kps = []bin_width = 360//num_bins for kp in kps:cx, cy, s = int(kp[0]), int(kp[1]), int(kp[2])s = np.clip(s, 0, octave.shape[2]-1)sigma = kp[2]*1.5w = int(2*np.ceil(sigma)+1)kernel = gaussian_filter(sigma)L = octave[…,s]hist = np.zeros(num_bins, dtype=np.float32) for oy in range(-w, w+1):for ox in range(-w, w+1):x, y = cx+ox, cy+oyif x &lt; 0 or x &gt; octave.shape[1]-1: continueelif y &lt; 0 or y &gt; octave.shape[0]-1: continue m, theta = get_grad(L, x, y)weight = kernel[oy+w, ox+w] * mbin = quantize_orientation(theta, num_bins)hist[bin] += weight max_bin = np.argmax(hist)new_kps.append([kp[0], kp[1], kp[2], max_bin])max_val = np.max(hist) for binno, val in enumerate(hist):if binno == max_bin: continueif .8 * max_val &lt;= val:new_kps.append([kp[0], kp[1], kp[2], binno*bin_width]) return np.array(new_kps)</pre><p>关于这个函数我想提到的一件事是最后一个循环。本文规定，对于任何直方图bin，其值大于最大值的80％，以在该位置创建新关键点并进行缩放但具有新方向。</p><p>此外，本文还说您应该将抛物线拟合到最接近最大值的三个直方图值，但在此实现中省略了这一点。</p><p>此代码中还包含一些功能。首先get_grads ，它获得L中像素的极座标梯度：</p><pre> def cart_to_polar_grad(dx, dy):m = np.sqrt(dx**2 + dy**2)theta = (np.arctan2(dy, dx)+np.pi) * 180/np.pireturn m, theta def get_grad(L, x, y):dy = L[min(L.shape[0]-1, y+1),x] — L[max(0, y-1),x]dx = L[y,min(L.shape[1]-1, x+1)] — L[y,max(0, x-1)]return cart_to_polar_grad(dx, dy)</pre><p>然后有quantize_orientation，它只是将渐变的连续角度转换为直方图箱：</p><pre> </pre><p>def quantize_orientation(theta, num_bins):</p><p>bin_width = 360//num_bins</p><p>return int(np.floor(theta)//bin_width)</p><p>定位描述符创建</p><p><em>最后</em>，我们可以为每个关键点创建定位描述符。如前所述，我们使用“梯度直方图”方法从每个关键点的周围创建一个特征向量。</p><p>具体来说，在每个关键点周围检查16x16补丁。然后将该补丁分成16个4x4子区域。然后将每个子区域的梯度（在极座标中）分箱成8箱直方图。最后，所有这些直方图被连接成4x4x8 = 128个元素的长特征向量。</p><p>然后对该最终特征向量进行归一化，阈值化和重新归一化以尝试并确保对次要光照变化的不变性。</p><p>实现</p><pre> def get_local_descriptors(kps, octave, w=16, num_subregion=4, num_bin=8):descs = [] for kp in kps:cx, cy, s = int(kp[0]), int(kp[1]), int(kp[2])s = np.clip(s, 0, octave.shape[2]-1)kernel = gaussian_filter(w/6) # gaussian_filter multiplies sigma by 3 L = octave[…,s] t, l = max(0, cy-w//2), max(0, cx-w//2) b, r = min(L.shape[0], cy+w//2+1), min(L.shape[1], cx+w//2+1) patch = L[t:b, l:r] dx, dy = get_patch_grads(patch) if dx.shape[0] &lt; w+1:if t == 0: kernel = kernel[kernel.shape[0]-dx.shape[0]:]else: kernel = kernel[:dx.shape[0]]if dx.shape[1] &lt; w+1:if l == 0: kernel = kernel[kernel.shape[1]-dx.shape[1]:]else: kernel = kernel[:dx.shape[1]]if dy.shape[0] &lt; w+1:if t == 0: kernel = kernel[kernel.shape[0]-dy.shape[0]:]else: kernel = kernel[:dy.shape[0]]if dy.shape[1] &lt; w+1:if l == 0: kernel = kernel[kernel.shape[1]-dy.shape[1]:]else: kernel = kernel[:dy.shape[1]] m, theta = cart_to_polar_grad(dx, dy)dx, dy = dx*kernel, dy*kernel subregion_w = w//num_subregion featvec = np.zeros(num_bin * num_subregion**2, dtype=np.float32) for i in range(0, subregion_w):for j in range(0, subregion_w):t, l = i*subregion_w, j*subregion_wb, r = min(L.shape[0], (i+1)*subregion_w), min(L.shape[1], (j+1)*subregion_w) hist = get_histogram_for_subregion(m[t:b, l:r].ravel(), theta[t:b, l:r].ravel(), num_bin, kp[3]) featvec[i*subregion_w*num_bin + j*num_bin:i*subregion_w*num_bin + (j+1)*num_bin] = hist.flatten()descs.append(featvec) return np.array(descs)</pre><p>对中间形状dx和dy中间形状的检查是为了避免我之前遇到的越界错误。如果其中一个/或小于w+1那么相应地切断高斯窗口以避免形状不匹配。</p><p>首先，计算整个贴片的极性梯度。然后为每个子区域创建直方图。</p><p>要计算补丁中的渐变：</p><pre> def get_patch_grads(p):r1 = np.zeros_like(p)r1[-1] = p[-1]r1[:-1] = p[1:] r2 = np.zeros_like(p)r2[0] = p[0]r2[1:] = p[:-1] dy = r1-r2 r1[:,-1] = p[:,-1]r1[:,:-1] = p[:,1:]r2[:,0] = p[:,0]r2[:,1:] = p[:,:-1] dx = r1-r2 return dx, dy</pre><p>只需获取前一个和当前像素之间的差异。这比以前做双面衍生更容易。然后为每个子区域创建直方图：</p><pre> def get_histogram_for_subregion(m, theta, num_bin, reference_angle):hist = np.zeros(num_bin, dtype=np.float32) for mag, angle in zip(m, theta):binno = quantize_orientation(angle-reference_angle, num_bin)hist[binno] += mag hist /= max(1e-6, LA.norm(hist)) hist[hist&gt;0.2] = 0.2 hist /= max(1e-6, LA.norm(hist))return hist</pre><p>这段代码与前面的HoG代码非常相似，但是我们对直方图中的每个条目执行三线性插值。这个插值是为了提供鲁棒性，当一个像素的梯度从一个箱子到另一个或在一个子区域的边缘进入一个不同的子区域。</p><p>因此，对于x和y方向，条目的权重与1-(到容器中心的距离)和1-(到子区域中心的距离)成正比。</p><p><strong>把它放在一起</strong></p><p>我们现在可以创建一个SIFT对象来封装所有上述操作：</p><pre> class SIFT(object):def __init__(self, im, s=3, num_octave=4, s0=1.3, sigma=1.6, r_th=10, t_c=0.03, w=16):self.im = convolve(rgb2gray(im), gaussian_filter(s0))self.s = sself.sigma = sigmaself.num_octave = num_octaveself.t_c = t_cself.R_th = (r_th+1)**2 / r_thself.w = w def get_features(self):gaussian_pyr = generate_gaussian_pyramid(self.im, self.num_octave, self.s, self.sigma)DoG_pyr = generate_DoG_pyramid(gaussian_pyr)kp_pyr = get_keypoints(DoG_pyr, self.R_th, self.t_c, self.w)feats = [] for i, DoG_octave in enumerate(DoG_pyr): kp_pyr[i] =assign_orientation(kp_pyr[i], DoG_octave)feats.append(get_local_descriptors(kp_pyr[i], DoG_octave)) self.kp_pyr = kp_pyrself.feats = feats return feats</pre><p>最后一个小细节是我用1.3的sigma模糊初始图像。</p><p>结论</p><p>文章讲的可能并不是那么清楚，但我希望你能学到一些关于理论和如何实现SIFT的知识。</p><p>只是个人学习文章。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Python','中实现','SIFT'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>