<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java知识回顾之堆和栈 | 极客快訊</title><meta property="og:title" content="Java知识回顾之堆和栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b3918ad3587341f085b704da5702c28e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/df9e1516.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/df9e1516.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="Java知识回顾之堆和栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/df9e1516.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java知识回顾之堆和栈</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在日常程序开发中，我们都知道Java程序都是运行在Java虚拟机上（JVM）的，程序中所有的方法、变量、常量、实例、静态存储都是由JVM在<strong><span style="color:#f04142;--tt-darkmode-color: #F04142">内存</span></strong>中进行分配的。</p><p><strong>一、栈内存</strong></p><p>主要用来存储线程执行过程中的局部变量（<strong><span style="color:#00abab;--tt-darkmode-color: #00ABAB">能否储存成员变量？</span></strong>），方法的返回值，以及方法调用上下文(对象的引用)，是一种只能在一端（称为栈顶）对数据项进行插入和删除，它遵循<strong>先进后出</strong>的规则来存储数据。</p><p><span style="color:#ff7528;--tt-darkmode-color: #FF7528">疑问一：网上看了好多说栈数据可以共享。我的理解是：栈是线程私有的内存区域，每个线程都有一个栈，线程执行函数的时候，就会往这个栈里面压入一个栈帧，这个栈帧包含局部变量表和操作数栈，它是怎么做到数据共享的？</span></p><div class=pgc-img><img alt=Java知识回顾之堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b3918ad3587341f085b704da5702c28e><p class=pgc-img-caption></p></div><p>通俗一点来讲先进后出：比如我们买的羽毛球筒，工厂加工完成后，会一个一个将羽毛球压到筒中（最后压进的羽毛球会在最上部）（进栈），最后羽毛球达到我们手中后，我们会从上往下一个一个的取出（最上面的会先被我们给取出）（出栈）。这样说的话，大家应该能听的明白一点吧。</p><div class=pgc-img><img alt=Java知识回顾之堆和栈 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1f3c316ad11c486396acfa89b985dac7><p class=pgc-img-caption></p></div><p>我们再用程序运行看下是否如我们上述描述的先进后出：</p><div class=pgc-img><img alt=Java知识回顾之堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2074dd7a6f76447db63ae191874c02c4><p class=pgc-img-caption></p></div><p>当我们在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，就会自动释放掉为该变量分配的内存空间（栈的作用域），它不会被GC管理。</p><p><strong>栈内存中的数据(局部变量)，没有默认初始化值，需要给赋值，不然在调用该变量的时候会提示</strong></p><p><strong>Initialize variable的错误。</strong></p><p><strong>二、堆内存</strong></p><p>是在JVM启动时候自动分配的（看上一篇JVM内容），用来存放由new创建的对象和数组，用完后靠垃圾回收机制（GC）不定期自动销毁。</p><p>虚拟机中只有且只有一个堆，程序中所有线程都共享它，它的存取类型为管道类型，先进先出。</p><p>用例子简单说下栈和堆的关系（这方面可能理解不是很到位，大家若有意见可以下方评论共同探讨）</p><p>public static void main(String[] args) {</p><p>Car car = new Car();</p><p>car.wheel = "4";</p><p>Car car1 = new Car();</p><p>car1.seat = "12";</p><p>}</p><div class=pgc-img><img alt=Java知识回顾之堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b7ff2c548de4961846ba9926141326c><p class=pgc-img-caption></p></div><p>主函数先进栈，会在栈内存中开辟一个空间，存放car变量,同时在堆内存中也开辟一个空间，存放new Car()对象。我们知道内存存储数据的时候都是通过地址来体现的，所以会给Car这个实体分配一个内存地址：0x0011，把堆这个地址赋给栈中的car（引用变量），car就通过地址指向了Car这个实体。</p><p>在我们日常开发或面试的时候，经常会碰到java中equals和==的区别：</p><div class=pgc-img><img alt=Java知识回顾之堆和栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a030aa7cbdd24212a91904ef32d4beb3><p class=pgc-img-caption></p></div><p>从上图，我们可以看到程序运行的结果：</p><p>1）对于==，int类型（8大基本数据类型）的比较结果输出为true，String类型的输出结果为false;</p><p>2）String类型通过equals比较结果为true.</p><p>m == n为true这个结果结果我们应该能容易理解，基本数据类型的变量在栈内存中存储的是实际的值，而a == b为false，是因为a和b是String类型的变量，是引用类型的变量，为非基本数据类型的变量，它存储的是对象的堆内存地址。a==b的比较实际上比较的是a和b对应的堆内存地址，它们指向的是不同对象。</p><p>equals操作表示的两个变量是否是对同一个对象的引用，即堆中的内容是否相同。</p><p><strong><span style="color:#00abab;--tt-darkmode-color: #00ABAB">栈内存中能否储存成员变量？</span></strong></p><p>不能，因为当对象创建出来，实体存在于堆，对象的成员变量已经在堆上分配空间，但对象里面的方法是没有出现的，只出现方法的声明，方法里面的局部变量并没有创建。等到对象调用此方法时，方法中的局部变量才会在栈中创建，所以，方法中的局部变量是在栈内的。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','知识','回顾'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>