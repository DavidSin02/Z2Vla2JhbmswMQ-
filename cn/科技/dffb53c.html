<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>消息队列之事务消息，RocketMQ 和 Kafka是如何做的？ | 极客快訊</title><meta property="og:title" content="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/S2XWraJF1wHo8F"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/dffb53c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/dffb53c.html><meta property="article:published_time" content="2020-10-29T20:50:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:41+08:00"><meta name=Keywords content><meta name=description content="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/dffb53c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>消息队列之事务消息，RocketMQ 和 Kafka是如何做的？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S2XWraJF1wHo8F><p>作者 | 是Yes呀</p><p>责编 | 郑丽媛</p><p>来源 | yes的练级攻略（ID：yes_java）</p><blockquote class=pgc-blockquote-abstract toutiao-origin=blockquote><div><p>每个时代，都不会亏待会学习的人。</p></div></blockquote><p>大家好，我是 yes。</p><p>今天我们来谈一谈消息队列的事务消息，一说起事务相信大家都不陌生，脑海里蹦出来的就是 ACID。</p><p>通常我们理解的事务就是为了一些更新操作要么都成功，要么都失败，不会有中间状态的产生，而 ACID 是一个严格的事务实现的定义，不过在单体系统时候一般都不会严格的遵循 ACID 的约束来实现事务，更别说分布式系统了。</p><p><strong>分布式系统往往只能妥协到最终一致性</strong>，保证数据最终的完整性和一致性，主要原因就是实力不允许...因为可用性为王。</p><p>而且要保证完全版的事务实现代价很大，你想想要维护这么多系统的数据，不允许有中间状态数据可以被读取，所有的操作必须不可分割，这意味着一个事务的执行是阻塞的，资源是被长时间锁定的。</p><p>在高并发情况下资源被长时间的占用，就是致命的伤害，举一个有味道的例子，如厕高峰期，好了懂得都懂。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItqPGBYi2qcM><p>对了， ACID是什么还不太清楚的同学，赶紧去查一查，这里我就不展开说了。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p></p><h1 toutiao-origin=h2>分布式事务</h1><p>那说到分布式事务，常见的有 2PC、TCC 和事务消息，这篇文章重点就是事务消息，不过 2PC 和 TCC 我稍微提一下。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p></p><h1 toutiao-origin=h2>2PC</h1><p>2PC就是二阶段提交，分别有协调者和参与者两个角色，二阶段分别是准备阶段和提交阶段。</p><p>准备阶段就是协调者向各参与者发送准备命令，这个阶段参与者除了事务的提交啥都做了，而提交阶段就是协调者看看各个参与者准备阶段都 o 不 ok，如果有ok那么就向各个参与者发送提交命令，如果有一个不ok那么就发送回滚命令。</p><p>这里的重点就是 <strong>2PC 只适用于数据库层面的事务</strong>，什么意思呢？就是你想在数据库里面写一条数据同时又要上传一张图片，这两个操作 2PC 无法保证两个操作满足事务的约束。</p><p>而且 2PC 是一种<strong>强一致性</strong>的分布式事务，它是<strong>同步阻塞</strong>的，即在接收到提交或回滚命令之前，所有参与者都是互相等待，特别是执行完准备阶段的时候，此时的资源都是锁定的状态，假如有一个参与者卡了很久，其他参与者都得等它，<strong>产生长时间资源锁定状态下的阻塞</strong>。</p><p>总体而言效率低，并且存在单点故障问题，协调者是就是那个单点，并且在极端条件下存在数据不一致的风险，例如某个参与者未收到提交命令，此时宕机了，恢复之后数据是回滚的，而其他参与者其实都已经执行了提交事务的命令了。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p></p><h1 toutiao-origin=h2>TCC</h1><p><strong>TCC能保证业务层面的事务</strong>，也就是说它不仅仅是数据库层面，上面的上传图片这种操作它也能做。</p><p>TCC 分为三个阶段 try - confirm - cancel，简单的说就是每个业务都需要有这三个方法，先都执行try方法，这一阶段不会做真正的业务操作，只是先占个坑，什么意思呢？比如打算加10个积分，那先在预添加字段加上这10积分，这个时候用户账上的积分其实是没有增加的。</p><p>然后如果都try成功了那么就执行confirm方法，大家都来做真正的业务操作，如果有一个try失败了那么大家都执行cancel操作，来撤回刚才的修改。</p><p>可以看到<strong>TCC其实对业务的耦合性很大</strong>，因为业务上需要做一定的改造才能完成这三个方法，这其实就是TCC的缺点，<strong>并且confirm和cancel操作要注意幂等</strong>，因为到执行这两步的时候没有退路，是务必要完成的，因此需要有重试机制，所以需要保证方法幂等。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7YR5xGDl><p></p><h1 toutiao-origin=h2>事务消息</h1><p>事务消息就是今天文章的主角了，它<strong>主要是适用于异步更新的场景，并且对数据实时性要求不高的地方</strong>。</p><p>它的目的是为了<strong>解决消息生产者与消息消费者的数据一致性问题</strong>。</p><p>比如你点外卖，我们先选了炸鸡加入购物车，又选了瓶可乐，然后下单，付完款这个流程就结束了。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9ItqzS7Qsy7KT><p>而购物车里面的数据就很适合用消息通知异步删除，因为一般而言我们下完单不会再去点开这个店家的菜单，而且就算点开了购物车里还有这些菜品也没有关系，影响不大。</p><p>我们希望的就是下单成功之后购物车的菜品最终会被删除，所以要点就是<strong>下单和发消息这两个步骤要么都成功要么都失败</strong>。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7uHXU5GZc><p></p><h1 toutiao-origin=h2>RocketMQ 事务消息</h1><p>我们先来看一下 RocketMQ 是如何实现事务消息的。</p><p>RocketMQ 的事务消息也可以被认为是一个两阶段提交，简单的说就是在事务开始的时候会先发送一个半消息给 Broker 。</p><p>半消息的意思就是这个消息此时对 Consumer 是不可见的，而且也不是存在真正要发送的队列中，而是一个特殊队列。</p><p>发送完半消息之后再执行本地事务，再根据本地事务的执行结果来决定是向 Broker发送提交消息，还是发送回滚消息。</p><p>此时有人说这一步发送提交或者回滚消息失败了怎么办？</p><p>影响不大，<strong>Broker 会定时的向 Producer 来反查这个事务是否成功</strong>，具体的就是 Producer 需要暴露一个接口，通过这个接口 Broker 可以得知事务到底有没有执行成功，没成功就返回未知，因为有可能事务还在执行，会进行多次查询。</p><p>如果成功那么就将半消息恢复到正常要发送的队列中，这样消费者就可以消费这条消息了。</p><p>我们再来简单的看下如何使用，我根据官网示例代码简化了下。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itr0aE69UsgH><p>可以看到使用起来还是很简便直观的，无非就是多加个反查事务结果的方法，然后把本地事务执行的过程写在 TransationListener 里面。</p><p>至此 RocketMQ 事务消息大致的流程已经清晰了，我们画一张整体的流程图来过一遍，其实到第四步这个消息要么就是正常的消息，要么就是抛弃什么都不存在，此时这个事务消息已经结束它的生命周期了。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itr16Gqpmd7U><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTLSNam5ZxLDlM><p></p><h1 toutiao-origin=h2>RocketMQ 事务消息源码分析</h1><p>然后我们再从源码的角度来看看到底是怎么做的，首先我们看下<strong toutiao-origin=span>sendMessageInTransaction</strong>方法，方法有点长，不过没有关系结构还是很清晰的。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItruDIDTYP7><p>流程也就是我们上面分析的，将消息塞入一些属性，标明此时这个消息还是半消息，然后发送至 Broker ，然后执行本地事务，然后将本地事务的执行状态发送给 Broker ，我们现在<strong>再来看下 Broker 到底是怎么处理这个消息的</strong>。</p><p>在 Broker 的 SendMessageProcessor#sendMessage 中会处理这个半消息请求，因为今天主要分析的是事务消息，所以其他流程不做分析，我大致的说一下原理。</p><p>简单的说就是sendMessage中查到接受来的消息的属性里面</p><blockquote toutiao-origin=span>MessageConst.PROPERTY_TRANSACTION_PREPARED</blockquote><p>是true，那么可以得知这个消息是事务消息，然后再判断一下这条消息是否超过最大消费次数，是否要延迟，Broker 是否接受事务消息等操作后，将这条消息真正的topic和队列存入属性中，然后重置消息的 topic 为<strong toutiao-origin=span>RMQ_SYS_TRANS_HALF_TOPIC</strong>，并且队列是 0 的队列中，使得消费者无法读取这个消息。</p><p>以上就是整体处理半消息的流程，我们来看一下源码。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itruz5IdIfCg><p>就是来了波狸猫换太子，其实延时消息也是这么实现的，最终将换了皮的消息入盘。</p><p>Broker处理提交或者回滚消息的处理方法是</p><blockquote toutiao-origin=span>EndTransactionProcessor#processRequest</blockquote><p>，我们来看一看它做了什么操作。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9ItrvT6Fbc4dj><p>可以看到，如果是提交事务就是把皮再换回来写入真正的topic所属的队列中，供消费者消费，如果是回滚则是将半消息记录到一个 half_op 主题下，到时候后台服务扫描半消息的时候就依据其来判断这个消息已经处理过了。</p><p>那个后台服务就是<strong toutiao-origin=span>TransactionalMessageCheckService</strong>服务，它会定时的扫描半消息队列，去请求反查接口看看事务成功了没，具体执行的就是</p><blockquote toutiao-origin=span>TransactionalMessageServiceImpl#check</blockquote><p>方法。</p><p>我大致说一下流程，这一步骤其实涉及到的代码很多，我就不贴代码了，有兴趣的同学自行了解。不过我相信用语言也是能说清楚的。</p><p>首先取半消息 topic 即<strong toutiao-origin=span>RMQ_SYS_TRANS_HALF_TOPIC</strong>下的所有队列，如果还记得上面内容的话，就知道半消息写入的队列是 id 是 0 的这个队列，然后取出这个队列对应的half_op主题下的队列，即<strong toutiao-origin=span>RMQ_SYS_TRANS_OP_HALF_TOPIC</strong>主题下的队列。</p><p>这个 half_op 主要是为了记录这个事务消息已经被处理过，也就是说已经得知此事务消息是提交的还是回滚的消息会被记录在 half_op 中。</p><p>然后调用 fillOpRemoveMap 方法，从half_op取一批已经处理过的消息来去重，将那些没有记录在half_op里面的半消息调用<strong toutiao-origin=span>putBackHalfMsgQueue</strong>又写入了commitlog中，然后发送事务反查请求，这个反查请求也是oneWay，即不会等待响应。当然此时的半消息队列的消费 offset 也会推进。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9Itrw7GyIETzV><p>然后<strong>producer</strong>中的 ClientRemotingProcessor#processRequest 会处理这个请求，会把任务扔到 TransactionMQProducer 的线程池中进行，最终会调用上面我们发消息时候定义的<strong toutiao-origin=span>checkLocalTransactionState</strong>方法，然后将事务状态发送给Broker，也是用oneWay的方式。</p><p>看到这里相信大家会有一些疑问，比如为什么要有个half_op，为什么半消息处理了还要再写入commitlog中别急听我一一道来。</p><p>首先<strong>RocketMQ的设计就是顺序追加写入，所以说不会更改已经入盘的消息</strong>，那事务消息又需要更新反查的次数，超过一定反查失败就判定事务回滚。</p><p>因此每一次要反查的时候就将以前的半消息再入盘一次，并且往前推进消费进度。而half_op又会记录每一次反查的结果，不论是提交还是回滚都会记录，因此下一次还循环到处理此半消息的时候，可以从 half_op 得知此事务已经结束了，因此就被过滤掉不需要处理了。</p><p>如果得到的反查的结果是 UNKNOW，那 half_op 中也不会记录此结果，因此还能再次反查，并且更新反查次数。</p><p>到现在整个流程已经清晰了，我再画个图总结一下 Broker 的事务处理流程。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItrwSFc1sIUq><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTRIuPNI7JPB03><p></p><h1 toutiao-origin=h2>Kafka 事务消息</h1><p>Kafka的事务消息和RocketMQ的事务消息又不一样了，RocketMQ解决的是本地事务的执行和发消息这两个动作满足事务的约束。</p><p>而Kafka事务消息则是用在一次事务中需要发送多个消息的情况，保证多个消息之间的事务约束，即多条消息要么都发送成功，要么都发送失败，就像下面代码所演示的。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItuIGCDCjxg5><p><strong>Kafka 的事务基本上是配合其幂等机制来实现 Exactly Once 语义的</strong>，所以说 Kafka 的事务消息不是我们想的那种事务消息 RocketMQ 的才是。</p><p>讲到这我就想扯一下了，说到这个Exactly Once 其实不太清楚的同学很容易会误解。</p><p>我们知道消息可靠性有三种，分别是最多一次、恰好一次、最少一次，之前在消息队列连环问的文章我已经提到了基本上我们都是用最少一次然后配合消费者端的幂等来实现恰好一次。</p><p>消息恰好被消费一次当然我们所有人追求的，但是之前文章我已经从各方面已经分析过了，基本上难以达到。</p><p>而 Kafka 竟说它能实现 Exactly Once？这么牛啤吗？这其实是 Kafka 的一个噱头，你要说他错，他还真没错，你要说他对但是他实现的 Exactly Once 不是你心中想的那个 Exactly Once。</p><p>它的恰好一次只能存在一种场景，就是从<strong>Kafka 作为消息源，然后做了一番操作之后，再写入 Kafka 中</strong>。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S9ItuJbACmaken><p>那他是如何实现恰好一次的？就是通过幂等，和我们在业务上实现的一样通过一个唯一 Id， 然后记录下来，如果已经记录过了就不写入，这样来保证恰好一次。</p><p>所以说 <strong>Kafka 实现的是在特定场景下的恰好一次，不是我们所想的利用 Kafka 来发送消息，那么这条消息只会恰巧被消费一次</strong>。</p><p>这其实和 Redis 说他实现事务了一样，也不是我们心想的事务。</p><p>所以开源软件说啥啥特性开发出来了，我们一味的相信，因此其往往都是残血的或者在特殊的场景下才能满足，不要被误导了，不能相信表面上的描述，还得详细的看看文档或者源码。</p><p>不过从另一个角度看也无可厚非，作为一个开源软件肯定是想更多的人用，我也没说谎呀，我文档上写的很清楚的，这标题也没骗人吧？</p><p>确实，比如你点进震惊xxxx标题的文章，人家也没骗你啥，他自己确实震惊的呢。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9ItuJw9Atr89T><p>再回来谈 Kafka 的事务消息，所以说这个事务消息不是我们想要的那个事务消息，其实不是今天的主题了，不过我还是简单的说一下。</p><p>Kafka 的事务有事务协调者角色，事务协调者其实就是 Broker 的一部分。</p><p>在开始事务的时候，生产者会向事务协调者发起请求表示事务开启，事务协调者会将这个消息记录到特殊的日志-事务日志中，然后生产者再发送真正想要发送的消息，这里 Kafka 和 RocketMQ 处理不一样，Kafka 会像对待正常消息一样处理这些事务消息，<strong>由消费端来过滤这个消息</strong>。</p><p>然后发送完毕之后生产者会向事务协调者发送提交或者回滚请求，由事务协调者来进行两阶段提交，如果是提交那么会先执行预提交，即把事务的状态置为预提交然后写入事务日志，然后再向所有事务有关的分区写入一条类似事务结束的消息，这样消费端消费到这个消息的时候就知道事务好了，可以把消息放出来了。</p><p>最后协调者会向事务日志中再记一条事务结束信息，至此 Kafka 事务就完成了，我拿 confluent.io 上的图来总结一下这个流程。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S9ItuKO2iywlmV><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTRIuPaahjHjS><p></p><h1 toutiao-origin=h2>最后</h1><p>至此我们已经知道了 RocketMQ 和 Kakfa 的事务消息全流程，可以看到 RocketMQ 的事务消息才是我们想要的，当然你要是用的流式计算那么 Kakfa 的事务消息也是你想要的。</p><p>需要贴代码的文章其实很难受，这贴的多不好，贴的少又怕不清晰，真的难，如果觉得文章不错记得点个在看哟。</p><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R69FpRH4d90a7d><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S8GRksHDcXZIUf><pre><div><div><div><div><div><div><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpbJ0CLyq7></div></div><p><strong toutiao-origin=span>点分享</strong></p></div><div><div><div><div><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S3Y8EjO3S3jH6O></div></div></div><div><div><div><img alt="消息队列之事务消息，RocketMQ 和 Kafka是如何做的？" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpwDUoK9Jv></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'队列','之事务','RocketMQ'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>