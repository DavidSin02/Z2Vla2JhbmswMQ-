<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「原创」Java并发编程系列36 | FutureTask | 极客快訊</title><meta property="og:title" content="「原创」Java并发编程系列36 | FutureTask - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/SAZA4S9I6wzJm7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e0ee178.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e0ee178.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="「原创」Java并发编程系列36 | FutureTask"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e0ee178.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「原创」Java并发编程系列36 | FutureTask</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>★★★</strong><strong class=highlight-text toutiao-origin=span>建议</strong><strong>星标</strong><strong class=highlight-text toutiao-origin=span>我们</strong><strong>★★★</strong></p><p><strong>Java进阶架构师</strong><strong>★</strong>“<strong>星标</strong>”！这样才不会错过每日进阶架构文章呀。</p><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAZA4S9I6wzJm7><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ryxcguy98OEq9e><p><strong>2020年Java原创面试题库连载中</strong></p><p>【000期】Java最全面试题库思维导图</p><p>【001期】JavaSE面试题（一）：面向对象</p><p>【002期】JavaSE面试题（二）：基本数据类型与访问修饰符</p><p>【003期】JavaSE面试题（三）：JavaSE语法（1）</p><p>【004期】JavaSE面试题（四）：JavaSE语法（3）</p><p>【005期】JavaSE面试题（五）：String类</p><p>【006期】JavaSE面试题（六）：泛型</p><p>【007期】JavaSE面试题（七）：异常</p><p>【008期】JavaSE面试题（八）：集合之List</p><p>【009期】JavaSE面试题（九）：集合之Set</p><p>【010期】JavaSE面试题（十）：集合之Map</p><p>【011期】JavaSE面试题（十一）：多线程（1）</p><p>【012期】JavaSE面试题（十二）：多线程（2）</p><p>【013期】JavaSE面试题（十三）：多线程（3）</p><p>【014期】JavaSE面试题（十四）：基本IO流</p><p>【015期】JavaSE面试题（十五）：网络IO流</p><p>【016期】JavaSE面试题（十六）：反射</p><p>【017期】JavaSE面试题（十七）：JVM之内存模型</p><p>【018期】JavaSE面试题（十八）：JVM之垃圾回收</p><p>【020期】JavaSE系列面试题汇总（共18篇）</p><p>【019期】JavaWeb面试题（一）：JDBC</p><p>【021期】JavaWeb面试题（二）：HTTP协议</p><p>【022期】JavaWeb面试题（三）：Cookie和Session</p><p>【023期】JavaWeb面试题（四）：JSP</p><p>【024期】JavaWeb面试题（五）：Filter和Listener</p><p>【025期】Java工具面试题（一）：版本控制工具</p><p>【026期】Java工具面试题（二）：项目管理工具</p><p>【027期】Java设计模式面试题</p><p>【028期】JavaWeb系列面试题汇总（共10篇）</p><p>【029期】JavaEE面试题（一）Web应用服务器</p><p>【030期】JavaEE面试题（二）SpringMVC</p><p>【031期】JavaEE面试题（三）Spring（1）</p><p>【032期】JavaEE面试题（四）Spring（2）</p><p>【033期】JaveEE面试题（五）MyBatis</p><p>【034期】JavaEE面试题（六）Hibernate</p><p>【035期】JavaEE面试题（七）SpringBoot（1）</p><p>更多内容，点击上面蓝字查看</p><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ryxcguy98OEq9e><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RyGixJJ21nOJYN><p>线程池源码中出现了很多Callable、Future、FutureTask等以前没介绍过的接口，尤其是线程池提交任务时总是把任务封装成FutureTask，今天就来为大家解惑：</p><ol><li><p>Runnable、Callable、Future、FutureTask</p></li><li><p>FutureTask类结构</p></li><li><p>FutureTask状态</p></li><li><p>执行任务 run方法</p></li><li><p>获取任务返回值 get方法</p></li><li><p>取消任务 cancel方法</p></li></ol><p><strong toutiao-origin=span>1. Runnable、Callable、Future、FutureTask</strong></p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.1 Runnable</strong></h2><p>Runnable接口只有一个run方法，而run方法的返回值是void，所以线程执行完之后没有返回值。</p><pre><code>public interface Runnable {<br>public abstract void run;<br>}<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.2 Callable</strong></h2><p>在很多场景下，我们通过线程来异步执行任务之后，希望获取到任务的执行结果。比如RPC框架中，需要异步获取任务返回值。这种情况下，Runnable无法获取返回值就无法满足需求了，因此Callable就出现了。</p><p>Callable也是一个接口，也只有一个call方法，不同的是Callable的call方法有是有返回值的，返回值的类型是一个泛型，泛型由创建Callable对象时指定。</p><pre><code>public interface Callable&lt;V&gt; {<br>V call throws Exception;<br>}<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.3 Future</strong></h2><p>要想获得Callable的返回值就需要用到Future接口。Futrue可以监视和控制Callable任务的执行情况，如对执行结果进行取消、查询是否完成、获取结果等。</p><p>如：当一个任务通过线程池的submit方法提交到线程池后，线程池会返回一个Future类型的对象，我们可以通过Future对象来获取任务在线程池中的状态。</p><pre><code>public interface Future&lt;V&gt; {<br>boolean cancel(boolean mayInterruptIfRunning);<br>boolean isCancelled;<br>boolean isDone;<br>V get throws InterruptedException, ExecutionException;<br>V get(long timeout, TimeUnit unit)<br>throws InterruptedException, ExecutionException, TimeoutException;<br>}<br></code></pre><ul><li><div><p>cancel方法：用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。</p><p>mayInterruptIfRunning参数用来表示是否需要中断线程，如果传true，表示需要中断线程，那么就会将任务的状态设置为INTERRUPTING；如果为false，那么就会将任务的状态设置为CANCELLED（关于任务的状态INTERRUPTING和CANCELLED后面会说明）</p></div></li><li><p>isCancelled方法：表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true</p></li><li><p>isDone方法：表示任务是否已经完成，若任务完成，则返回true</p></li><li><p>get方法：用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回。</p></li><li><p>get(long timeout, TimeUnit unit)方法：获取执行结果，如果在指定时间内，还没获取到结果，就直接返回。</p></li></ul><p>举例：Future获取Callable任务的返回值</p><pre><code>public class FutureExample {<br>public static void main(String[] args) throws InterruptedException, ExecutionException {<br>ExecutorService threadPool = Executors.newCachedThreadPool;<br>Future&lt;String&gt; future = threadPool.submit(new Callable&lt;String&gt; {<br>@Override<br>public String call throws Exception {<br>Thread.sleep(2000);<br>return "结果";<br>}<br>});<br>System.out.println("Callable返回值=" + future.get);<br>}<br>}<br></code></pre><p>输出结果：</p><pre><code>Callable返回值=结果<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=h2>1.4 FutureTask</strong></h2><p>FutureTask是Runnable和Future的实现类，既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAZA4Tj8Flk2sq><p>当线程池调用submit方法来向线程池中提交任务时，无论提交的是Runnable类型的任务，还是提交的是Callable类型的任务，最终都是将任务封装成一个FutureTask对象，我们可以通过这个FutureTask对象来获取任务在线程池中的状态。</p><pre><code> public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {<br>if (task == ) throw new PointerException;<br>// 调用newTaskFor将Callable任务封装成一个FutureTask<br>RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>// 执行任务<br>execute(ftask);<br>return ftask;<br>}<br><br>// newTaskFor<br>protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {<br>// 直接new一个FutureTask对象<br>return new FutureTask&lt;T&gt;(callable);<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>2. FutureTask类结构</h2><pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {<br>/** state变量用来保存任务的状态 */<br>private volatile int state;<br>private static final int NEW = 0;<br>private static final int COMPLETING = 1;<br>private static final int NORMAL = 2;<br>private static final int EXCEPTIONAL = 3;<br>private static final int CANCELLED = 4;<br>private static final int INTERRUPTING = 5;<br>private static final int INTERRUPTED = 6;<br><br>/** 提交的任务，Runnable类型的任务会通过Executors.callable来转变为Callable */<br>private Callable&lt;V&gt; callable;<br>/** 用来保存Callable的call方法的返回值 */<br>private Object outcome;<br>/** 执行Callable任务的线程 **/<br>private volatile Thread runner;<br>/**<br>* 任务未完成时，调用get方法获取结果的线程会阻塞等待<br>* waiters用于保存这些线程<br>*/<br>private volatile WaitNode waiters;<br><br>static final class WaitNode {<br>volatile Thread thread;<br>volatile WaitNode next;<br>WaitNode { thread = Thread.currentThread; }<br>}<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>3. FutureTask状态</h2><p>FutureTask任务的状态如下：</p><pre><code> // 任务的初始状态，当新建一个FutureTask任务时，state值默认为NEW<br>private static final int NEW = 0;<br>// 任务处于完成中，也就是正在执行还未设置返回值<br>private static final int COMPLETING = 1;<br>// 任务正常被执行完成，并将任务的返回值赋值给outcome属性之后<br>private static final int NORMAL = 2;<br>// 任务出了异常，并将异常对象赋值给outcome属性之后<br>private static final int EXCEPTIONAL = 3;<br>// 调用cancle(false)，任务被取消了<br>private static final int CANCELLED = 4;<br>// 调用cancle(true)，任务中断，但是在线程中断之前<br>private static final int INTERRUPTING = 5;<br>// 调用cancle(true)，任务中断，但是在线程中断之后<br>private static final int INTERRUPTED = 6;<br></code></pre><p>状态变化如下图：</p><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAZA7SU938gfW8><p></p><h2 toutiao-origin=h2>4. 执行任务run</h2><ol><li><p>执行future.callable.call，执行任务；</p></li><li><p>执行成功，设置结果outcome；</p></li><li><p>逐个唤醒waiters中的线程去获取执行结果。</p></li></ol><pre><code>public void run {<br>/*<br>* 1. 不是NEW状态，不能执行<br>* 2. 设置runner失败，不能执行<br>*/<br>if (state != NEW ||<br>!UNSAFE.compareAndSwapObject(this, runnerOffset,<br>, Thread.currentThread))<br>return;<br>try {<br>Callable&lt;V&gt; c = callable;<br>if (c != &amp;&amp; state == NEW) {<br>V result;<br>boolean ran;<br>try {<br>result = c.call;// 真正执行任务<br>ran = true;// 执行成功，设置执行成功标志<br>} catch (Throwable ex) {<br>result = ;<br>ran = false;// 有异常，执行失败<br>setException(ex);// 设置异常<br>}<br>// 如果执行成功，则设置返回结果<br>if (ran)<br>set(result);<br>}<br>} finally {<br>runner = ;// 无论是否执行成功，把runner设置为<br>int s = state;<br>// 处理中断<br>if (s &gt;= INTERRUPTING)<br>handlePossibleCancellationInterrupt(s);<br>}<br>}<br><br>/**<br>* 设置执行结果<br>*/<br>protected void set(V v) {<br>if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {// 执行完成，设置COMPLETING状态<br>outcome = v;// 设置执行结果<br>UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // 设置完结果，设置NORMAL状态<br>finishCompletion;// 逐个唤醒waiters中的线程去获取执行结果<br>}<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>5. 获取任务返回值get方法</h2><ol><li><p>任务状态为NORMAL，直接返回执行结果；</p></li><li><p>任务状态为COMPLETING，线程yield让出CPU，因为COMPLETING到NORMAL只需要很短的时间，get线程让出CPU的短暂时间，任务状态就是从COMPLETING变成了NORMAL；</p></li><li><p>任务状态为NEW，将get线程阻塞，如果设置了超时，阻塞至超时时间；如果没有设置超时，会一直阻塞直到任务完成后唤醒。</p></li></ol><pre><code>public V get throws InterruptedException, ExecutionException {<br>int s = state;<br>// 如果状态处于NEW或者COMPLETING状态，表示任务还没有执行完成，awaitDone等待<br>if (s &lt;= COMPLETING)<br>s = awaitDone(false, 0L);// 下文详解<br>// 返回结果，下文详解<br>return report(s);<br>}<br><br>/**<br>* 返回执行结果<br>*/<br>private V report(int s) throws ExecutionException {<br>Object x = outcome;<br>// 任务正常结束时，返回outcome<br>if (s == NORMAL)<br>return (V)x;<br>// 任务被取消了，抛出CancellationException<br>if (s &gt;= CANCELLED)<br>throw new CancellationException;<br>// 这里只能第EXCEPTIONAL状态，表示在执行过程中出现了异常，抛出ExecutionException。<br>throw new ExecutionException((Throwable)x);<br>}<br><br>/**<br>* 处于NEW或者COMPLETING状态时，get线程等待<br>*/<br>private int awaitDone(boolean timed, long nanos)<br>throws InterruptedException {<br>// ......<br>for (;;) {<br>// ......<br>// 任务处于COMPLETING中，就让当前线程先暂时放弃CPU的执行权<br>else if (s == COMPLETING) // cannot time out yet<br>Thread.yield;<br>// ......<br>// 如果设置了超时，阻塞至超时时间<br>else if (timed) {<br>nanos = deadline - System.nanoTime;<br>if (nanos &lt;= 0L) {<br>removeWaiter(q);<br>return state;<br>}<br>// 等待一段时间<br>LockSupport.parkNanos(this, nanos);<br>}<br>else<br>// 如果没有设置超时，会一直阻塞，直到被中断或者被唤醒<br>LockSupport.park(this);<br>}<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>6. 取消任务 cancel</h2><p>将任务状态设置成INTERRUPTING/INTERRUPTED/CANCELLED状态就表示取消了线程，因为在这些状态下任务的run方法是不能执行的。</p><pre><code>public boolean cancel(boolean mayInterruptIfRunning) {<br>/*<br>* 以下情况不能取消任务：<br>* 1. 当前任务不是NEW状态，已经被执行了，不能取消<br>* 2. 当前任务还没有执行，state == NEW，但是CAS设置状态失败，不能取消<br>*/<br>if (!(state == NEW &amp;&amp;<br>UNSAFE.compareAndSwapInt(this, stateOffset, NEW,<br>mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>return false;<br>try { // in case call to interrupt throws exception<br>// 中断<br>if (mayInterruptIfRunning) {<br>try {<br>Thread t = runner;<br>if (t != )<br>t.interrupt;// 中断线程<br>} finally { // final state<br>// 中断之后，设置INTERRUPTED状态<br>UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);<br>}<br>}<br>} finally {<br>finishCompletion;// 唤醒waiters中的线程去获取执行结果<br>}<br>return true;<br>}<br></code></pre><p></p><h2 toutiao-origin=h2>并发系列文章汇总</h2><p>【原创】01|开篇获奖感言</p><p>【原创】02|并发编程三大核心问题</p><p>【原创】03|重排序-可见性和有序性问题根源</p><p>【原创】04|Java 内存模型详解</p><p>【原创】05|深入理解 volatile</p><p>【原创】06|你不知道的 final</p><p>【原创】07|synchronized 原理</p><p>【原创】08|synchronized 锁优化</p><p>【原创】09|基础干货</p><p>【原创】10|线程状态</p><p>【原创】11|线程调度</p><p>【原创】12|揭秘 CAS</p><p>【原创】13|LockSupport</p><p>【原创】14|AQS 源码分析</p><p>【原创】15|重入锁 ReentrantLock</p><p>【原创】16|公平锁与非公平锁</p><p>【原创】17|读写锁八讲（上）</p><p>【原创】18|读写锁八讲（下）</p><p>【原创】19|JDK8新增锁StampedLock</p><p>【原创】20|StampedLock源码解析</p><p>【原创】21|Condition-Lock的等待通知</p><p>【原创】22|倒计时器CountDownLatch</p><p>【原创】22|倒计时器CountDownLatch</p><p>【原创】23|循环屏障CyclicBarrier</p><p>【原创】24|信号量Semaphore</p><p>【原创】25|交换器Exchangere</p><p>【原创】26|ConcurrentHashMap（上）</p><p>【原创】27|ConcurrentHashMap（下）</p><p>【原创】28|Copy-On-Write容器</p><p>【原创】29|ConcurrentLinkedQueue</p><p>【原创】30 | ThreadLocal</p><p>【原创】31 | 阻塞队列（上）</p><p>【原创】32 | 阻塞队列（下）</p><p>【原创】33 | 深入理解线程池（上）</p><p>【原创】34 | 深入理解线程池（下）</p><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R6Aez96HF10BZ3><pre><div><p><strong class=highlight-text toutiao-origin=span>之前，给大家发过</strong><strong class=highlight-text toutiao-origin=strong>三份Java</strong><strong class=highlight-text toutiao-origin=span>面试宝典，这次新增了一份，目前总共是</strong><strong class=highlight-text toutiao-origin=strong>四份</strong><strong class=highlight-text toutiao-origin=span>面试宝典，相信在跳槽前一个月按照面试宝典准备准备，基本没大问题。</strong></p><ul><li><p><strong class=highlight-text toutiao-origin=strong>《java面试宝典5.0》</strong><strong class=highlight-text toutiao-origin=span>(初中级)</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《350道Java面试题：整理自100+公司》</strong><strong class=highlight-text toutiao-origin=span>（中高级）</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《资深java面试宝典-视频版》</strong><strong class=highlight-text toutiao-origin=span>（资深）</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《Java[BAT]面试必备》</strong><strong class=highlight-text toutiao-origin=span>（资深）</strong></p></li></ul><p><strong class=highlight-text toutiao-origin=span>分别适用于</strong><strong class=highlight-text toutiao-origin=span>初中级，中高级</strong><strong class=highlight-text toutiao-origin=span>，</strong><strong class=highlight-text toutiao-origin=span>资深</strong><strong class=highlight-text toutiao-origin=span>级工程师</strong><strong class=highlight-text toutiao-origin=span>的面试复习。</strong></p><p><strong class=highlight-text toutiao-origin=span>内容包含</strong><strong class=highlight-text toutiao-origin=span>java基础、javaweb、mysql性能优化、JVM、锁、百万并发、消息队列，高性能缓存、反射、Spring全家桶原理、微服务、Zookeeper、数据结构、限流熔断降级等等。</strong></p><div><div><div><div><div><div><div><img alt="「原创」Java并发编程系列36 | FutureTask" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RFppAnaHsaFKbv></div><div><p><strong class=highlight-text toutiao-origin=span>看到这里，证明有所收获</strong></p></div></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'原创','Java','发编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>