<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>动图演示：手撸堆栈的两种实现方法 | 极客快訊</title><meta property="og:title" content="动图演示：手撸堆栈的两种实现方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/SBtWP0tC3xr2Y5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e1ce789.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e1ce789.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="动图演示：手撸堆栈的两种实现方法"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e1ce789.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>动图演示：手撸堆栈的两种实现方法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SBtWP0tC3xr2Y5><p>作者 | 王磊</p><p>来源 | Java中文社群（ID：Javacn666）</p><p>头图 | CSDN 下载自东方IC</p><p>随着软件开发行业竞争的日益激烈，面试的难度也在逐渐增加，因为企业要从众多的面试人中选出最优秀的人，只能提高面试的难度，而算法和数据结构比较烧脑的硬核技能之一，自然也就成了面试的首选科目。并且随着时间的推移，算法和数据结构出现的频率和占比也会不断增加，因此为了顺应时代发展的潮流，我们也要做一些调整，所以在后面的一些文章中，我会陆续更新一些关于算法和数据结构的文章，希望大家能够喜欢。</p><blockquote><p>PS：当然随着智能系统的普及（如今日头条和抖音），算法和数据结构在企业中应用也越来越多，因此学习算法和数据结构也是迫在眉睫的事了。</p></blockquote><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p><strong>栈定义</strong></p><p>栈（Stack）又叫堆栈（简称栈），它是在同一端进行插入和删除数据的线性表。</p><p>栈是最基础也是最常见的数据结构之一，它的数据结构和操作流程如下图所示：</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SBtWP1QCy8x8bV><p>其中，允许进行插入和删除的一端叫作栈顶（Top），另一端叫作栈底（Bottom），栈底固定，栈顶浮动。</p><p>当栈中的元素为零时，该栈叫作空栈。添加数据时一般叫作入栈或进栈（Push），删除数据叫作出栈或退栈（Pop）。<strong>栈是后进先出（Last In First Out，LIFO）的线性表。</strong></p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SBtWP2n8THBZyp><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p><strong>物理结构&逻辑结构</strong></p><p>在手撸算法之前，我们先来认识一下数据结构中的两个重要概念：<strong>物理结构和逻辑结构。</strong></p><p>当谈到“物理”和“逻辑”一词时，我们可以会想到数据库中的逻辑删除和物理删除。</p><p>所谓的<strong>物理删除是指通过删除命令真实的将数据从物理结构中删除的过程；而逻辑删除是指通过修改命令将数据更改为“已删除”的状态，并非真实的删除数据。</strong></p><p>这里的逻辑结构和物理结构和上面的概念类似，所谓的<strong>物理结构是指可以将数据存储在物理空间中</strong>，比如数组和链表都属于物理数据结构；<strong>而逻辑结构则是用于描述数据间的逻辑关系的，</strong>比如本文要讲的栈就属于逻辑结构。</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SBtWP3MF0rM3ki><p>可能有些人看到这里就蒙了，没关系，我这里举一个例子你就明白了。</p><p>如果用人来表示物理结构和逻辑结构的话，那么<strong>真实存在的有血有肉的人就属于物理结构，而人的思想和信念就属于逻辑结构了。</strong></p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SBtWPdsFCBR1zf><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p><strong>自定义栈I：数组实现</strong></p><p>通过上面的内容，我们知道了栈属于逻辑结构，因此它的实现方式就可以有很多种了，比如数组的实现方式或者是链表的实现方式。那么我们就先用数组实现一下，栈的主要方法有：</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/SBtWPeRClebZc5><p></p><h2 toutiao-origin=h4>1、定义结构</h2><p>那么我们先来定义它的结构：</p><pre><code>public class MyStack&lt;E&gt; {</code><code> private Object value = ; // 栈存储容器</code><code> private int top = -1; // 栈顶（的指针）</code><code> private int maxSize = 0; // 栈容量</code><br><code> // 构造函数（初始化默认容量）</code><code> MyStack {</code><code> this.maxSize = 10;value=new Object[9];</code><code> }</code><br><code> // 有参构造函数</code><code> MyStack(int initSize) throws Exception {</code><code> if (initSize &lt;= 0) {</code><code> throw new Exception("栈容量必须大于 0");</code><code> } else {</code><code> value = new Object[initSize];</code><code> maxSize = initSize;</code><code> top = -1;</code><code> }</code><code> }</code><code>}</code></pre><p>其中栈中数据会存储在 <strong>Object value</strong>数组中，<strong>top </strong>变量代表栈顶的指针，它其实存储的是栈顶元素的下标，会随着入栈不断变化（后进先出），<strong>maxSize </strong>表示栈的最大容量。</p><p></p><h2 toutiao-origin=h4>2、入栈</h2><p>此方法是给栈添加数据的，实现代码如下：</p><pre><code>// 入栈（数据添加）</code><code>public boolean push(E e) throws Exception {</code><code> if (maxSize - 1 == top) {</code><code> throw new Exception("入栈失败，栈已满");</code><code> } else {</code><code> value[++top] = e;</code><code> return true;</code><code> }</code><code>}</code></pre><p>每次当有数据插入时，只需在数组中添加一个值，并将栈顶的下标 +1 即可。</p><p>入栈操作如下图所示：</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SBtWPes2ZItvAz><p></p><h2 toutiao-origin=h4>3、出栈</h2><p>此方法是删除栈中的数据的，实现代码如下：</p><pre><code>// 数据移除（出栈）</code><code>public E pop throws Exception {</code><code> if (top &lt;= -1) {</code><code> throw new Exception("移除失败，栈中已无数据");</code><code> } else {</code><code> return (E) value[top--];</code><code> }</code><code>}</code></pre><p>出栈只需删除数组中栈顶数据（最后加入的数据），并修改栈顶下标 -1 即可。</p><p>出栈操作如下图所示：</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SBtWPfF1nSLT9A><p></p><h2 toutiao-origin=h4>4、数据查询</h2><p>除了以上操作方法之外，我们还需要添加一个查询栈顶数据的方法：</p><pre><code>// 数据查询</code><code>public E peep throws Exception {</code><code> if (top &lt;= -1) {</code><code> throw new Exception("移除失败，栈中已无数据");</code><code> } else {</code><code> return (E) value[top];</code><code> }</code><code>}</code></pre><p></p><h2 toutiao-origin=h4>5、代码测试</h2><p>到此为止栈的数据结构就已经实现完了，接下来我们来测试一下：</p><pre><code>// 代码测试</code><code>public static void main(String[] args) throws Exception {</code><code> MyStack stack = new MyStack(10);</code><code> stack.push("Hello");</code><code> stack.push("Java");</code><code> System.out.println(stack.peep);</code><code> stack.pop;</code><code> System.out.println(stack.pop);</code><code>}</code></pre><p>以上程序的执行结果为：</p><blockquote><p>Java</p><p>Hello</p></blockquote><p>从上述代码可以看出，我们添加栈的顺序是 <strong>Hello</strong>、<strong>Java</strong>而输出的顺序是<strong>Java</strong>、<strong>Hello</strong>符合栈的定义（<strong>后进先出</strong>）。</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7YR5xGDl><p></p><h1 toutiao-origin=h3>自定义栈II：链表实现</h1><p>除了数组之外，我们可以还可使用链表来实现栈结构，它的实现稍微复杂一些，我们先来看链表本身的数据结构：</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SBtWQEIDAYqpX8><p>使用链表实现栈的流程如下：</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SBtWQEoCMP9Mkq><p>也就是说，入栈时我们将数据存储在链表的头部，出栈时我们从头部进行移除，并将栈顶指针指向原头部元素的下一个元素，实现代码如下。</p><p>我们先来定义一个链表节点：</p><pre><code>public class Node {</code><code> Object value; // 每个节点的数据</code><code> Node next; // 下一个节点</code><br><code> public Node(Object value) {</code><code> this(value, );</code><code> }</code><br><code> /**</code><code> * 创建新节点</code><code> * @param value 当前节点数据</code><code> * @param next 指向下一个节点（头插法）</code><code> */</code><code> public Node(Object value, Node next) {</code><code> this.value = value;</code><code> this.next = next;</code><code> }</code><code>}</code></pre><p>接下来我们使用链表来实现一个完整的栈：</p><pre><code>public class StackByLinked {</code><br><code> private Node top = ; // 栈顶数据</code><code> private int maxSize = 0; // 栈最大容量</code><code> private int leng = 0; // 栈实际容量</code><br><code> public StackByLinked(int initSize) throws Exception {</code><code> if (initSize &lt;= 0) {</code><code> throw new Exception("栈容量不能小于等于0");</code><code> }</code><code> top = ;</code><code> maxSize = initSize;</code><code> leng = 0;</code><code> }</code><br><code> /**</code><code> * 容量是否已满</code><code> * @return</code><code> */</code><code> public boolean isFull {</code><code> return leng &gt;= maxSize;</code><code> }</code><br><code> /**</code><code> * 是否为空</code><code> * @return</code><code> */</code><code> public boolean isEmpty {</code><code> return leng &lt;= 0;</code><code> }</code><br><code> /**</code><code> * 入栈</code><code> * @param val</code><code> * @return</code><code> * @throws Exception</code><code> */</code><code> public boolean push(Object val) throws Exception {</code><code> if (this.isFull) {</code><code> // 容量已满</code><code> throw new Exception("容量已满");</code><code> }</code><code> top = new Node(val, top); // 存入信息，并将当前节点设置为头节点</code><code> leng++;</code><code> return true;</code><code> }</code><br><code> /**</code><code> * 出栈（移除）</code><code> * @return</code><code> * @throws Exception</code><code> */</code><code> public Node pop throws Exception {</code><code> if (this.isEmpty) {</code><code> throw new Exception("栈为空，无法进行移除操作");</code><code> }</code><code> Node item = top; // 返回当前元素</code><code> top = top.next;</code><code> leng--;</code><code> return item;</code><br><code> }</code><br><code> /**</code><code> * 查询栈顶信息</code><code> * @return</code><code> */</code><code> public Node peek throws Exception {</code><code> if (isEmpty) {</code><code> throw new Exception("你操作的是一个空栈");</code><code> }</code><code> return top;</code><code> }</code><br><code> // 代码测试</code><code> public static void main(String[] args) throws Exception {</code><code> StackByLinked stack = new StackByLinked(10);</code><code> stack.push("Hello");</code><code> stack.push("Java");</code><code> System.out.println(stack.peek.value);</code><code> stack.pop;</code><code> System.out.println(stack.pop.value);</code><code> }</code><code>}</code></pre><p>以上程序的执行结果是：</p><blockquote><p>Java</p><p>Hello</p></blockquote><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7uHXU5GZc><p></p><h1 toutiao-origin=h3>总结</h1><p>本文我们使用了数组和链表等物理结构来实现了栈，当然我们也可以使用其他容器来实现，比如 Java 中的<strong> List</strong>，我们只需要保证在操作栈时是后进先出的执行顺序，并且至少包含 3 个重要方法：入栈、出栈和查询栈顶元素就可以了。</p><p><strong>算法和数据结构的学习是 3 分学 7 分练</strong>，只看不练是没办法学好算法的，而且<strong>学习算法和数据结构是一个循序渐进的过程，短时间内不会有明显的收效。</strong>因为这些算法经过了几百年的发展和积累才得以流传下来的，所以想要“玩得转”还需要一点耐心。</p><p>这里给你讲一个学习算法的“秘诀”：<strong>看不懂的知识要反复看，如果反复看还是看不懂，那么别着急，休息一下再继续看！</strong>相信我，对于学习算法这件事，所有人的过程都是一样的。</p><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R69FpRH4d90a7d><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SBE53i38S5mkOQ><pre><div><div><div><div><div><div><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpbJ0CLyq7></div></div><p><strong toutiao-origin=span>点分享</strong></p></div><div><div><div><div><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S3Y8EjO3S3jH6O></div></div></div><div><div><div><img alt=动图演示：手撸堆栈的两种实现方法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S3V0kpwDUoK9Jv></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'动图','堆栈','两种'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>