<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java Jvm虚拟机的内存模型概述 | 极客快訊</title><meta property="og:title" content="Java Jvm虚拟机的内存模型概述 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e85477348c3c4028898c813b77362920"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e211bb9e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e211bb9e.html><meta property="article:published_time" content="2020-11-14T20:59:55+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:55+08:00"><meta name=Keywords content><meta name=description content="Java Jvm虚拟机的内存模型概述"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e211bb9e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java Jvm虚拟机的内存模型概述</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="Java Jvm虚拟机的内存模型概述" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e85477348c3c4028898c813b77362920><p class=pgc-img-caption></p></div><p>1 程序计算器</p><p style=text-align:start>程序计数器是一块较小的内存空间<br>每一个线程都有一个独立的程序计数器，用于记录下一条要运行的指令，各个线程间的程序计算器互不影响，是一块线程私有的内存空间</p><p style=text-align:start>2 Java虚拟机栈</p><p style=text-align:start>是线程私有的内存空间，它和Java线程在同一时间创建，它保存方法的局部变量，部分结果，并参与方法的调用与返回，也就是说生命周期与线程相同，描述的是Java方法执行的内存模型</p><p style=text-align:start>每一个方法执行的同时都会创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法的执行就对应着栈帧在虚拟机栈中的入栈，出栈过程，后进先出（LIFO）栈。</p><p style=text-align:start>2.1 局部变量表</p><ul><li>存放编译期可知的各种基本数据类型、对象引用类型和returnAddress类型（指向一条字节码指令的地址：函数返回地址）</li><li>局部变量表所需的内存空间在编译期确定，当进入一个方法时，方法在栈帧中所需要分配的局部变量控件是完全确定的，不可动态改变大小。</li></ul><pre><code>变量槽 （Variable Slot）是局部变量表的最小单位，没有强制规定大小为 32 位，虽然32位足够存放大部分类型的数据。一个 Slot 可以存放 boolean、byte、char、short、int、float、reference 和 returnAddress 8种类型。其中 reference 表示对一个对象实例的引用，通过它可以得到对象在Java 堆中存放的起始地址的索引和该数据所属数据类型在方法区的类型信息。returnAddress 则指向了一条字节码指令的地址。 对于64位的 long 和 double 变量而言，虚拟机会为其分配两个连续的 Slot 空间。虚拟机通过索引定位的方式使用局部变量表。之前我们知道，局部变量表存放的是方法参数和局部变量。当调用方法是非static 方法时，局部变量表中第0位索引的 Slot 默认是用于传递方法所属对象实例的引用，即 “this” 关键字指向的对象。分配完方法参数后，便会依次分配方法内部定义的局部变量。为了节省栈帧空间，局部变量表中的 Slot 是可以重用的。当离开了某些变量的作用域之后，这些变量对应的 Slot 就可以交给其他变量使用。这种机制有时候会影响垃圾回收行为。 </code></pre><p style=text-align:start>2.2 操作数栈</p><ul><li>后进先出LIFO，最大深度由编译期确定。栈帧刚建立使，操作数栈为空，执行方法操作时，操作数栈用于存放JVM从局部变量表复制的常量或者变量，提供提取，及结果入栈，也用于存放调用方法需要的参数及接受方法返回的结果。</li><li>操作数栈可以存放一个jvm中定义的任意数据类型的值。</li><li>在任意时刻，操作数栈都一个固定的栈深度，基本类型除了long、double占用两个深度，其它占用一个深度</li></ul><p style=text-align:start>2.3 动态连接</p><p style=text-align:start>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。Class文件的常量池中存在有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用为参数。这些符号引用，一部分会在类加载阶段或第一次使用的时候转化为直接引用（如final、static域等），称为静态解析，另一部分将在每一次的运行期间转化为直接引用，这部分称为动态连接</p><p style=text-align:start>2.4 方法返回地址</p><ul><li>当一个方法开始执行以后，只有两种方法可以退出当前方法：• 当执行遇到返回指令，会将返回值传递给上层的方法调用者，这种退出的方式称为正常完成出口（Normal Method Invocation Completion），一般来说，调用者的PC计数器可以作为返回地址。<br>• 当执行遇到异常，并且当前方法体内没有得到处理，就会导致方法退出，此时是没有返回值的，称为异常完成出口（Abrupt Method Invocation Completion），返回地址要通过异常处理器表来确定。</li><li>当方法返回时，可能进行3个操作：• 恢复上层方法的局部变量表和操作数栈<br>• 把返回值压入调用者调用者栈帧的操作数栈<br>• 调整 PC 计数器的值以指向方法调用指令后面的一条指令</li></ul><p style=text-align:start>3 本地方法栈</p><p style=text-align:start>与java虚拟机栈的功能很相似，Java虚拟机栈用于管理Java函数的调用，而本地方法栈用于管理本地方法的调用。<br>本地方法是用C实现的</p><p style=text-align:start>4 java 的堆</p><p style=text-align:start>java堆可以说是Java运行时内存中最为重要的部分，几乎所有的对象和数组都是在堆中分配空间的，<br>java堆可分为新生代和老年代两个部分,</p><p>分类说明新生代用于存放刚刚产生的对象和年轻的对象老年代用于存放存活时间长的对象</p><p style=text-align:start></p><p style=text-align:start>5 java 方法区</p><ul><li>在一个jvm实例的内部，类型信息被存储在一个称为方法区的内存逻辑区中。类型信息是由类加载器在类加载时从类文件中提取出来的。类(静态)变量也存储在方法区中。</li><li>方法区又叫静态区，跟堆一样，被所有的线程共享。方法区包含所有的class和static变量</li><li>方法区中包含的都是在程序中永远的唯一的元素</li></ul><hr><p style=text-align:start>6 在JAVA中，有六个不同的地方可以存储数据</p><p style=text-align:start>6.1 寄存器（register）</p><p style=text-align:start>　　这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。</p><p style=text-align:start>6.2 堆栈（stack)</p><ul><li>位于通用RAM中，但通过它的“堆栈指针”可以从处理器那里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些 内存</li><li>这是一种快速有效的分配存储方法，仅次于寄存器。</li><li>创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成 相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活　　　　　　 　　　　性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其 中。</li></ul><p style=text-align:start>6.3 堆（heap)</p><p style=text-align:start>一种通用性的内存池（也存在于RAM中），用于存放已创建的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区 域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行 这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。</p><p style=text-align:start>6.4 静态存储（static storage）</p><p style=text-align:start>这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字<br>static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。</p><p style=text-align:start>6.5 常量存储（constant storage)</p><p style=text-align:start>常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中</p><p style=text-align:start>6.6非RAM存储</p><p style=text-align:start>如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。<br>运行类过程：方法区找到方法–堆中实例化对象–调用栈（指向堆中实例）</p><hr><p>完毕</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','Jvm','虚拟机'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>