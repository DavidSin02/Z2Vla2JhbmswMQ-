<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>源码分析：Java集合类的AbstractCollection源码解析 | 极客快訊</title><meta property="og:title" content="源码分析：Java集合类的AbstractCollection源码解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e275511c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e275511c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e275511c.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="源码分析：Java集合类的AbstractCollection源码解析"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e275511c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>源码分析：Java集合类的AbstractCollection源码解析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote class=pgc-blockquote-abstract><p>作者： liuxiaopeng</p><p>链接：https://www.cnblogs.com/paddix/p/5560933.html</p></blockquote><p><strong>一、Collection接口</strong></p><p>　　从《Java集合：整体结构》一文中我们知道所有的List和Set都继承自Collection接口，该接口类提供了集合最基本的方法，虽然List接口和Set等都有一些自己独有的方法，但是基本的操作类似。我们先看下Collection接口提供的方法：</p><p>　　</p><div class=pgc-img><img alt=源码分析：Java集合类的AbstractCollection源码解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671><p class=pgc-img-caption></p></div><p>总体上可以将Collection的方法分为以下几大类：</p><p>1、增加（add/addAll）</p><p>2、删除（remove/removeAll/clear/retainAll）</p><p>3、查询（contain/containAll/iterator/size/isEmpty）</p><p>4、转数组（toArray/toArray(T[])）</p><p>　　直接实现该接口的类只有AbstractCollection类，该类也只是一个抽象类，提供了对集合类操作的一些基本实现。List和Set的具体实现类基本上都直接或间接的继承了该类。为了方便以后更清晰的理解这些类的实现，我们先看下AbstractCollection的实现。</p><p><strong>二、AbstractCollection源码解析</strong></p><p><br></p><pre><code>package java.util; public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; {     protected AbstractCollection() {    }     public abstract Iterator&lt;E&gt; iterator();     public abstract int size();     //判断集合中是否有数据    public boolean isEmpty() {        return size() == 0;    }     /**     * 判断是否包含指定的元素     * （1）如果参数为null，查找值为null的元素，如果存在，返回true，否则返回false。     * （2）如果参数不为null，则根据equals方法查找与参数相等的元素，如果存在，则返回true，否则返回false。     * 注意：这里必须对null单独处理，否则null.equals会报空指针异常     */    public boolean contains(Object o) {        Iterator&lt;E&gt; it = iterator();        if (o==null) {            while (it.hasNext())                if (it.next()==null)                    return true;        } else {            while (it.hasNext())                if (o.equals(it.next()))                    return true;        }        return false;    }     /**     * 功能：将集合元素转换为数组     * 实现：     * （1）创建一个数组，大小为集合中元素的数量     * （2）通过迭代器遍历集合，将当前集合中的元素复制到数组中（复制引用）     * （3）如果集合中元素比预期的少，则调用Arrays.copyOf()方法将数组的元素复制到新数组中，并返回新数组，Arrays.copyOf的源码在后续文章中会分析.     * （4）如果集合中元素比预期的多，则调用finishToArray方法生成新数组，并返回新数组，否则返回（1）中创建的数组     */    public Object[] toArray() {        Object[] r = new Object[size()];        Iterator&lt;E&gt; it = iterator();        for (int i = 0; i &lt; r.length; i++) {            if (! it.hasNext()) // fewer elements than expected                return Arrays.copyOf(r, i);            r[i] = it.next();        }        return it.hasNext() ? finishToArray(r, it) : r;    }     /**     * 功能：通过泛型约束返回指定类型的数组     * 实现：     * （1）如果传入数组的长度的长度大于等于集合的长度，则将当前集合的元素复制到传入的数组中     * （2）如果传入数组的长度小于集合的大小，则将创建一个新的数组来进行集合元素的存储     */    public &lt;T&gt; T[] toArray(T[] a) {        // Estimate size of array; be prepared to see more or fewer elements        int size = size();        T[] r = a.length &gt;= size ? a :                  (T[])java.lang.reflect.Array                  .newInstance(a.getClass().getComponentType(), size);        Iterator&lt;E&gt; it = iterator();         for (int i = 0; i &lt; r.length; i++) {            //集合元素大小小于数组的长度            if (! it.hasNext()) { // fewer elements than expected                if (a == r) {//如果数组是参数中的数组，则将剩余部分的值都设置为null                    r[i] = null; // null-terminate                } else if (a.length &lt; i) {//如果传入的数组长度小于集合长度，则通过Arrays.copyOf将之前数组中的元素复制到新数组中                    return Arrays.copyOf(r, i);                } else {//如果传入数组的长度比集合大，则将多的元素设置为空                    System.arraycopy(r, 0, a, 0, i);                    if (a.length &gt; i) {                        a[i] = null;                    }                }                return a;            }            r[i] = (T)it.next();        }        // more elements than expected        //集合元素大小大于数组的长度        return it.hasNext() ? finishToArray(r, it) : r;    }     private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;     /**     *  功能：数组扩容     *  （1）当数组索引指向最后一个元素+1时，对数组进行扩容：即创建一个更长的数组，然后将原数组的内容复制到新数组中     *  （2）扩容大小：cap + cap/2 +1     *  （3）扩容前需要先判断是否数组长度是否溢出     *  注意：这里的迭代器是从上层的方法（toArray）传过来的，并且这个迭代器已执行了一部分，而不是从头开始迭代的     */    private static &lt;T&gt; T[] finishToArray(T[] r, Iterator&lt;?&gt; it) {        int i = r.length;        while (it.hasNext()) {            int cap = r.length;            if (i == cap) {                int newCap = cap + (cap &gt;&gt; 1) + 1;                // overflow-conscious code                if (newCap - MAX_ARRAY_SIZE &gt; 0)                    newCap = hugeCapacity(cap + 1);                r = Arrays.copyOf(r, newCap);            }            r[i++] = (T)it.next();        }        // trim if overallocated        return (i == r.length) ? r : Arrays.copyOf(r, i);    }     /**     * 判断数组容量是否溢出，最大为整型数据的最大值     */    private static int hugeCapacity(int minCapacity) {        if (minCapacity &lt; 0) // overflow            throw new OutOfMemoryError                ("Required array size too large");        return (minCapacity &gt; MAX_ARRAY_SIZE) ?            Integer.MAX_VALUE :            MAX_ARRAY_SIZE;    }     /**     * 未实现     */    public boolean add(E e) {        throw new UnsupportedOperationException();    }     /**     * 功能：移除指定元素     * （1）如果参数为null，则找到第一个值为null的元素，并将其删除，返回true，如果不存在null的元素，返回false。     * （2）如果参数不为null，则根据equals方法找到第一个与参数相等的元素，并将其删除，返回true，如果找不到，返回false。     */    public boolean remove(Object o) {        Iterator&lt;E&gt; it = iterator();        if (o==null) {            while (it.hasNext()) {                if (it.next()==null) {                    it.remove();                    return true;                }            }        } else {            while (it.hasNext()) {                if (o.equals(it.next())) {                    it.remove();                    return true;                }            }        }        return false;    }     /**     * 遍历参数集合，依次判断参数集合中的元素是否在当前集合中，     * 只要有一个不存在，则返回false     * 如果参数集合中所有的元素都在当前集合中，则返回true     */    public boolean containsAll(Collection&lt;?&gt; c) {        for (Object e : c)            if (!contains(e))                return false;        return true;    }     /**     * 遍历参数集合，依次将参数集合中的元素添加当前集合中     */    public boolean addAll(Collection&lt;? extends E&gt; c) {        boolean modified = false;        for (E e : c)            if (add(e))                modified = true;        return modified;    }     /**     * 功能：移除参数集合的元素     * （1）获取当前集合的迭代器进行遍历     * （2）如果当前集合中的元素包含在参数集合中，则删除当前集合中的元素     *  注：只要参数集合中有任何一个元素在当前元素中，则返回true，表示当前集合有发送变化，否则返回false。     */    public boolean removeAll(Collection&lt;?&gt; c) {        boolean modified = false;        Iterator&lt;?&gt; it = iterator();        while (it.hasNext()) {            if (c.contains(it.next())) {                it.remove();                modified = true;            }        }        return modified;    }     /***     * 功能：求参数集合与当前集合的交集     * （1）获取当前集合的迭代器进行遍历     * （2）如果当前集合中的元素不在参数集合中，则将其移除。     *  注意：如果当前集合是参数集合中的子集，则返回false，表示当前集合未发送变化，否则返回true。     */    public boolean retainAll(Collection&lt;?&gt; c) {        boolean modified = false;        Iterator&lt;E&gt; it = iterator();        while (it.hasNext()) {            if (!c.contains(it.next())) {                it.remove();                modified = true;            }        }        return modified;    }     //删除所有元素    public void clear() {        Iterator&lt;E&gt; it = iterator();        while (it.hasNext()) {            it.next();            it.remove();        }    }      public String toString() {        Iterator&lt;E&gt; it = iterator();        if (! it.hasNext())            return "[]";         StringBuilder sb = new StringBuilder();        sb.append('[');        for (;;) {            E e = it.next();            sb.append(e == this ? "(this Collection)" : e);            if (! it.hasNext())                return sb.append(']').toString();            sb.append(',').append(' ');        }    } }</code></pre><p>　　整体上来说，AbstractCollection的源码还是比较容易理解，尤其是集合增、删、查等操作都非常简单。比较复杂的是关于集合转数组的操作，有几个点不是特别好理解，这里解释一下：</p><p>　　（1）MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8，为什么最大长度要减8，根据官方的解释：</p><p>/**</p><p>* The maximum size of array to allocate.</p><p>* Some VMs reserve some header words in an array.</p><p>* Attempts to allocate larger arrays may result in</p><p>* OutOfMemoryError: Requested array size exceeds VM limit</p><p>*/</p><p>　　这段话的意思就是有的虚拟机实现，数组对象的头部会占用这8个字节。</p><p>　　（2）转换为数组的操作时，为什么长度会比size()长或者短？这个的原因还是考虑到并发情况下，当然，在并发环境上面的机制不一定可行，如在ArrayList中就重写了该方法，遇到size()与hasNext不一致的情况会直接报错。不过有些场景下可以通过这种方式保持弱一致性，具体后续遇到这种情况的时候再具体说明。</p><p>　　（3）这里面执行数组拷贝时，用到两个方法，一个是Arrays.copyOf，另一个是System.arraycopy(r, 0, a, 0, i)方法，这两个方法的区别也会在后续文章中讨论，这里暂不细说。</p><p><strong>三、总结</strong></p><p>　　本文主要分析了AbstractCollection类的源码，很多实现类会重写AbstractCollection中已实现的方法。但是弄明白AbstractCollection源码之后，再看其子类的实现，会更容易理解其源码实现背后的设计原因，其实，很多源码本身不难理解，难理解的地方在于其背后的设计思想和原因，这也是我们去看源码和真正要学习的东西。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'源码','Java','类的'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>