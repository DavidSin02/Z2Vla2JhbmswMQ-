<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>给JAVA开发人员的正则表达式入门课 | 极客快訊</title><meta property="og:title" content="给JAVA开发人员的正则表达式入门课 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e2ad303f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e2ad303f.html><meta property="article:published_time" content="2020-11-14T21:07:13+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:13+08:00"><meta name=Keywords content><meta name=description content="给JAVA开发人员的正则表达式入门课"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e2ad303f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>给JAVA开发人员的正则表达式入门课</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>"不会正则表达式，就算写遍代码也嘛不是"。说到正则表达式，可能动态语言的码农Perl，Python，JS甚至是Golang的开发人员可能都熟悉。对Java码农来说，可能CURD手到擒来，Spring Stuts Hibernat耳闻能详，但是说到Regex RE模式，可能熟练的少。</p><p><br></p><p>那么，今天虫虫就来给广大Java码农来补补正则的课。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>正则基础</h1><p>正则表达式（Regex，简称RE）是一种根据字符串集中的每个字符串的共同特征来描述字符串集的方法。可用于搜索，编辑或处理文本和数据。简单来说，正则表达式是帮助我们根据特定格式验证或匹配字符串的方式。可以类比数据库的SQL语言，sql是搜索数据，RE是搜索字符串。正则表达式和SQL语言是开发界的两个伟大发明。</p><p>正则表达式可以用于：</p><p>验证用户的输入。</p><p>搜索给定数据中的文本。（可在文本编辑器中使用）</p><p>编译器中的解析器</p><p>语法突显，数据包嗅探器等。</p><p>要全面了解Regex，我们要理解基本知识,下面我们分别介绍，示例中我们用到在线正则解析网站regex101。</p><h1 class=pgc-h-arrow-right>基本量词（*+？和{n}）</h1><p>正则表示式子中（各语言通用）中的数量词由*，+.? 和{n}组成。</p><p>* 表示匹配零个或多个其先前模式的实例。例如，abc*表示文本必须与'ab'相匹配，后跟零个或多个'c'，即文本可能没有附加'c'并且文本也可能有一个或多个'c'。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cbea7d466fd84b05b26bc8123cfadab9><p class=pgc-img-caption></p></div><p>+ 匹配其先前模式的一个或多个实例，例如abc+表示文本必须带有"ab"，后跟一个或多个"c"。所以abc是您可以拥有的至少是正确的，而abcc也是正确的。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2dfae6bd8e044361aef020e2017d799d><p class=pgc-img-caption></p></div><p>?匹配零个或一个出现的模式，例如abc？表示文本可以是abc或ab。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f7797820e27e47b38c4b60b1d305d679><p class=pgc-img-caption></p></div><p>{n}表示与表达式中指定的确切数字（n）匹配。例如a{2}bc表示只能有两个"a"，然后是一个"bc"和一个"c"。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36cc29673a9f4f79a3d976098190f5d1><p class=pgc-img-caption></p></div><p>{n,}至少匹配指定的数字。必须具有n个或更多个前面的表达式，例如ab{2,}c表示必须具有个a，然后是两个或多个'b'，然后是c。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/74e3dce761874cee8991b19e787f28c8><p class=pgc-img-caption></p></div><p>{n，m}表示在模式的n和m（含）之间匹配。这意味着您可以在前至后之间出现m到m个事件。例如ab{2,5}c表示abbc，abbbc，abbbbc，abbbbbc都是正确的。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/178bcfad401c4c199dc972a89f07f922><p class=pgc-img-caption></p></div><p>'.' 匹配所有非空格字符</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22e95fdeb5b74c40a65a14d090917a96><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>运算符（|| [] ^和()）</h1><p>|表示"或"。表示与左侧的表达式或右侧的表达式匹配。例如abc|abd表示文本应为abc或abd。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d699bbe85d5744729eb579a1e5a21a31><p class=pgc-img-caption></p></div><p>[]表示文本应与尖括号中的任何字符匹配，例如a[bc]表示文本应为"a"，后跟"b"或"c"。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9437f301d06248d2bdc3260aa7070af1><p class=pgc-img-caption></p></div><p>[0-9]%表示文本应为0到9之间的任何数字，后跟'%'</p><p>[a-zA-Z]表示匹配任何一个英文字母，只要介于az或AZ之间即可。</p><p>[abc]表示文本或字符串应为a或b或c。</p><p>在任何表达式中添加"^"会否定该表达式的含义，例如[^abc]表示匹配任何除abc外的任何字符。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6270a39a496243d6b0a0a2f97569a4b8><p class=pgc-img-caption></p></div><p>()表示分组，分组后可以在后续反向引用。反向引用存储与组匹配的字符串部分。可以使用符号$来引用特定的组。$1，$2…代表第一组1，第2组等。默认组为$0，表示字符串本身。例如，我们要删除行中的所有空格。此示例的正则表达式为以下代码片段：</p><pre><code>private static String backReference(String text) {String pattern = "(\\w+)([\\s])";return text.replaceAll(pattern, "$1");}</code></pre><p>上面代码中的正则表达式有2组：（\\w+）和（[\\s]）。表示字串是一系列单词字符（\w+）后跟空格（\s+）。后面一句，我们用组1（$1）来替换整个文本，这样就删除了空格。</p><p>注意：在Java中，我们需要用一个斜杠对字符类（\w和\s）进行转义，否则会出现语法错误。</p><h1 class=pgc-h-arrow-right>环视</h1><p>环视一种排除模式的方法。因此，可以说只有在特定字符串之前没有改符号时字符串才是有效的，反之亦然。例如，abc（?= d）只要与'd'相符，就会匹配'abc'。 "d"不会被匹配。这叫正向环视或者顺序环视。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d05df7274bd48e28a0a30276638a5e5><p class=pgc-img-caption></p></div><p>环视不是所有语言都支持，不是通用的语法，但是妙用可以解决很多问题，比如我们要解析HTML语法：</p><p>例如，对html中的一个连接</p><pre><code>&lt;a href='ijz.me'&gt; chognchong&lt;/a &gt;</code></pre><p>我们要取其中的连接地址</p><pre><code>(?=')(.*(?='))</code></pre><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9417bb8830074e209a0081f28b96c8ff><p class=pgc-img-caption></p></div><p>还有一个表示对顺序环视的否定表达式,（?!pattern），表示如果'ab'后面没有'c'，则ab（?c）将匹配ab。</p><p>注意还有一个逆序环视，java中不支持，我们不介绍。</p><h1 class=pgc-h-arrow-right>贪婪和懒惰</h1><p>正则表达式中的的量词默认贪婪的，匹配时候会尽可能多的匹配，这样才能减少递归回溯搜索的次数，因而效率最高。例如，对于正则表达式a.+c，希望它表示文本应为'a'，后跟一个或多个非空格字符。可能的匹配匹配项为"abcccd"，"abcc"或"abbc"，都是可以的，但是由于贪婪的缘故，它将把所有文本（abcccd abcc abbc）作为一个并返回"abcccd abcc abbc"作为一个结果，因为如果您注意到，第一个字符是"a"，然后是任何其他字符中的一个或多个，它现在以与a.+c完全匹配的c结尾。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/240136d3de114abb8797379171af6eb1><p class=pgc-img-caption></p></div><p>为了修改默认的，贪婪模式，只需在量词前面添加问号（?），这样使量词就会只要匹配最少匹配的模式。这时，ab.+?c就会单独匹配各个字串，而不是整个字符串。</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9bb5e13de90f4bbc899b06d8bde3f4ac><p class=pgc-img-caption></p></div><p>对此的更好应用是：假设您只想从&lt;h1> Chongchong &lt;/h1>中单独获得标签&lt;h1>和&lt;/h1>，则希望它的正则表达式为&lt;.+>但实际上，它将捕获整个文本（&lt;h1> Hello Chongchong&lt;/h1>）并将其作为一个整体处理。 这时候用？就可以解决</p><div class=pgc-img><img alt=给JAVA开发人员的正则表达式入门课 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3cf7928957d54be1a154839ab1815e29><p class=pgc-img-caption></p></div><p>加'?'在量词前面有时被称为懒惰模式。</p><p>简而言之，贪婪模式表示匹配尽可能长的字符串，而懒惰模式表示匹配尽可能短的字符串。</p><h1 class=pgc-h-arrow-right>字符类</h1><p>字符类是代表一组字符的转义序列。下面列出了Java中的一些预定义字符：</p><p>\d 表示任意数字；</p><p>\s表示空格字符（tab 空格等）；</p><p>\w 任意单词字符；</p><p>\D表示任意非数字；</p><p>\S 表示任意非空格字符；</p><p>\W表示任意非单词字符。</p><h1 class=pgc-h-arrow-right>Java中使用正则表达式</h1><p>好，学习了基础正则知识后，我们来转入到Java。来学习在Java中正则表达式的使用。在Java世界Java中的字符串类带有一个内置的布尔方法，该方法称为matchs，该方法用来对字符串进行正则匹配。</p><p>public static void main(String[] args) {</p><p>String value = "12345";</p><p>System.out.println("The Result is: "+value.matches("\\d{5}"));</p><p>}</p><p>上面的代码段将返回"结果为：true"，因为值（12345）恰好匹配5个字符。除5以外的任何其他值都将返回"结果为：false"。</p><h1 class=pgc-h-arrow-right>Pattern/Matcher匹配</h1><p>除了String类的matchs方法之外，java.util.regex包中也有正则表达式所需的类。它们由三类组成：</p><p><strong>Pattern</strong>：这是正则表达式的编译表示。要使用此功能，必须首先在模式类中调用静态方法（编译），该方法返回一个模式对象。</p><p><strong>Matcher</strong>：这是解释模式并针对输入字符串执行匹配操作的引擎。要获得一个对象，必须在Pattern对象上调用matcher方法。</p><p><strong>PatternSyntaxException</strong>：这表示正则表达式模式中的错误</p><p>可以使用用模式Pattern/Matcher匹配字符串，一个例子是：</p><pre><code>public static void main(String[] args) {String value = "12345";String regex = "\\d{5}";Pattern pattern = Pattern.compile(regex);Matcher matcher = pattern.matcher(value);System.out.println("The Result is: "+matcher.matches());}</code></pre><h1 class=pgc-h-arrow-right>获取匹配的字符</h1><p>Matcher支持find和方法lookingAt()获取匹配的字符，一个例子：</p><p><br></p><pre><code>Pattern p=Pattern.compile("\\d+");Matcher m=p.matcher("aaa2223bb");m.find();//2223m.start();//3m.end();//7,这是2223后的索引号m.group();//2223</code></pre><p>也可以使用lookingAt()方法，只匹配之前的字符串：</p><pre><code>Mathcer m2=m.matcher("2223bb");m.lookingAt(); // 2223m.start(); // 0,由于lookingAt()只能匹配前面的字符串, start()方法总是返回0m.end(); // 4m.group(); // 2223</code></pre><h1 class=pgc-h-arrow-right>性能问题</h1><p>这样需要每次都先创建 Pattern/Matcher对象耗费资源太大，性能不行。使用Pattern/Matcher是在String类中实现了方法匹配。因此，对于匹配的每个字符串，它都会在匹配之前创建一个Pattern对象。为了解决这个问题，我们可以使用预编译方法,下面是一个实例：</p><p><br></p><pre><code>{"nozzle","punjabi","waterlogged","guardrooms","roast","wattage","shortcuts","confidential","reprint","foxtrot","disposseslogsion","floodgate","unfriendliest","semimonthlies","dwellers","walkways","wastrels","dippers","engrlogossing","undertakings"};List&lt;String&gt; resultStringMatches = matchUsingStringMatches(texts);List&lt;String&gt; resultsPatternMatcher = matchUsingPatternMatcher(texts);System.out.println("The Result for String matches is: "+resultStringMatches.toString());System.out.println("The Result for pattern/matcher is: "+resultStringMatches.toString());}private static List&lt;String&gt; matchUsingPatternMatcher(String[] texts) {List&lt;String&gt; matchedList = new ArrayList&lt;&gt;();String pattern = "[a-zA-Z]*log[a-zA-Z]*";Pattern regexPattern = Pattern.compile(pattern);Matcher matcher;for (int i = 0; i &lt; texts.length; i++) {matcher = regexPattern.matcher(texts[i]);if (matcher.matches()) {matchedList.add(texts[i]);}}return matchedList;}private static List&lt;String&gt; matchUsingStringMatches(String[] texts) {String pattern = "[a-zA-Z]*log[a-zA-Z]*";List&lt;String&gt; matchedList = new ArrayList&lt;&gt;();for (int i = 0; i &lt; texts.length; i++) {//每次循环调用matches(pattern),都会创建一个pattern对象if (texts[i].matches(pattern)) {matchedList.add(texts[i]);}}return matchedList;}}</code></pre><p>上面的代码将数组中的所有元素与特定的正则表达式（[a-zA-Z]*log[a-zA-Z]*）进行匹配。正则表达式用来获取所有带有"log"一词的文本。在与正则表达式匹配之前，必须先编译该表达式（Pattern.compile）；</p><p>第一个方法matchUsingPatternMatcher()在寻找匹配项之前先编译模式，而第二个方法matchUsingStringMatches()创建一个新的模式对象</p><p>数组中每个元素的镜像（Pattern.compile()）操作比较耗费内存，并且当数据/文本过多时，还可能会导致内存泄漏</p><p>因此，如果在处理大量数据比较关心性能时，请使用Pattern/Matcher类先进行编译，然后使用实例来匹配文本。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JAVA','开发','人员'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>