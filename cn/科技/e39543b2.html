<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读 | 极客快訊</title><meta property="og:title" content="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/S4RDmAJA74o9GY"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e39543b2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e39543b2.html><meta property="article:published_time" content="2020-11-14T20:59:53+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:53+08:00"><meta name=Keywords content><meta name=description content="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e39543b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>Flink 从入门到精通 系列文章</p><p>作者：<strong class=highlight-text toutiao-origin=span>逍凯</strong>，阿里云数据库实习开发工程师</p><p>注：以下分析基于开源 v19.15.2.2-stable 版本进行，社区最新版本代码改动较大，但是总体思路是不变的。</p><p>01</p><p></p><h1 toutiao-origin=h2>用户提交一条查询SQL背后发生了什么</h1><p>在传统关系型数据库中，SQL处理器的组件主要包括以下几种：</p><p><strong>• Query Parsing</strong></p><p>负责进行词法和语法分析,把程序从人类高可读的格式(即SQL)转化成机器高可读的格式(AST,抽象语法树)。</p><p>词法分析指的是把SQL中的字符序列分解成一个个独立的词法单元——Token(&lt;类型，值>)。</p><p>语法分析指的是从词法分析器输出的token中识别各类短语，并构造出一颗抽象语法树。而按照构造抽象语法树的方向，又可以把语法分析分成自顶向下和自底向上分析两种。而ClickHouse采用的则是手写一个递归下降的语法分析器。</p><p><strong>• Query Rewrite</strong></p><p>即通常我们说的"Logical Optimizer"或基于规则的优化器(Rule-Based Optimizer,即RBO)。</p><p>其负责应用一些启发式规则，负责简化和标准化查询，无需改变查询的语义。</p><p>常见操作有:谓词和算子下推，视图展开，简化常量运算表达式，谓词逻辑的重写，语义的优化等。</p><p><strong>• Query Optimizer</strong></p><p>即通常我们所说的"Physical Optimizer"，负责把内部查询表达转化成一个高效的查询计划，指导DBMS如何去取表，如何进行排序，如何Join。如下图所示，一个查询计划可以被认为是一个数据流图，在这个数据流图中，表数据会像在管道中传输一样，从一个查询操作符(operator)传递到另一个查询操作符。</p><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S4RDmAJA74o9GY><p>一个查询计划</p><p><strong>• Query Executor</strong></p><p>查询执行器，负责执行具体的查询计划，从存储引擎中获取数据并且对数据应用查询计划得到结果。</p><p>执行引擎也分为很多种，如经典的火山模型(Volcano Model)，还有ClickHouse采用的向量化执行模型(Vectorization Model)。</p><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S4RDmBB8AKErrl><p>(图来自经典论文 Architecture Of Database System)</p><p>但不管是传统的关系型数据库，还是非关系型数据库，SQL的解析和生成执行计划过程都是大同小异的，而纵览ClickHouse的源代码，可以把用户提交一条查询SQL背后的过程总结如下：</p><p>1.服务端接收客户端发来的SQL请求，具体形式是一个网络包，Server的协议层需要拆包把SQL解析出来</p><p>2.Server负责初始化上下文与Network Handler，然后 Parser 对Query做词法和语法分析，解析成AST</p><p>3.Interpreter的 SyntaxAnalyzer 会应用一些启发式规则对AST进行优化重写</p><p>4.Interpreter的<strong toutiao-origin=span> ExpressionAnalyzer </strong>根据上下文信息以及优化重写后的AST生成物理执行计划</p><p>5.物理执行计划分发到本地或者分布式的executor,各自从存储引擎中获取数据,应用执行计划</p><p>6.Server把执行后的结果以Block流的形式输出到Socket缓冲区,Client从Socket中读取即可得到结果</p><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S4RDmCJBLj2cxQ><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=span>01 接收客户端请求</strong></h2><p>我们要以服务端的视角来出发，首先来看server.cpp大概做什么事情:</p><p>下面只挑选重要的逻辑:</p><p>• 初始化上下文</p><p>• 初始化Zookeeper(ClickHouse的副本复制机制需要依赖ZooKeeper)</p><p>• 常规配置初始化</p><p>• 绑定服务端的端口，根据网络协议初始化Handler，对客户端提供服务</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>int Server::main<br>{<br>// 初始化上下文<br>global_context = std::make_unique&lt;Context&gt;(Context::createGlobal);<br>global_context-&gt;setApplicationType(Context::ApplicationType::SERVER);<br><br>// zk初始化<br>zkutil::ZooKeeperNodeCache main_config_zk_node_cache([&amp;] { return global_context-&gt;getZooKeeper; });<br><br>//其他config的初始化<br>//...<br><br>//绑定端口,对外提供服务<br>auto address = make_socket_address(host, port);<br>socket.bind(address, /* reuseAddress = */ true);<br><br>//根据网络协议建立不同的server类型<br>//现在支持的server类型有：HTTP,HTTPS,TCP,Interserver,mysql<br>//以TCP版本为例:<br>create_server("tcp_port", [&amp;](UInt16 port)<br>{<br>Poco::Net::ServerSocket socket;<br>auto address = socket_bind_listen(socket, listen_host, port);<br>servers.emplace_back(std::make_unique&lt;Poco::Net::TCPServer&gt;(<br>new TCPHandlerFactory(*this),<br>server_pool,<br>socket,<br>new Poco::Net::TCPServerParams));<br>});<br><br>//启动server<br>for (auto &amp; server : servers)<br>server-&gt;start;<br><br>}</code></p></pre><p>客户端发来的请求是由各自网络协议所对应的 Handler 来进行的，server在启动的时候 Handler 会被初始化并绑定在指定端口中。我们以TCPHandler为例，看看服务端是如何处理客户端发来的请求的，重点关注 <strong toutiao-origin=span>TCPHandler::runImpl</strong>的函数实现:</p><p>• 初始化输入和输出流的缓冲区</p><p>• 接受请求报文，拆包</p><p>• 执行Query(包括整个词法语法分析，Query重写，物理计划生成和生成结果)</p><p>• 把Query结果保存到输出流，然后发送到Socket的缓冲区，等待发送回客户端</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>void TCPHandler::runImpl<br>{<br>//实例化套接字对应的输入和输出流缓冲区<br>in = std::make_shared&lt;ReadBufferFromPocoSocket&gt;(socket);<br>out = std::make_shared&lt;WriteBufferFromPocoSocket&gt;(socket);<br><br>while (1){<br>// 接收请求报文<br>receivePacket;<br><br>// 执行Query<br>state.io = executeQuery(state.query, *query_context, false, state.stage, may_have_embedded_data);<br><br>//根据Query种类来处理不同的Query<br>//处理insert Query<br>processInsertQuery;<br>//并发处理普通Query<br>processOrdinaryQueryWithProcessors;<br>//单线程处理普通Query<br>processOrdinaryQuery;<br>}<br><br>}</code></p></pre><p>那CK处理客户端发送过来的Query的具体逻辑是怎样的呢?</p><p>我们可以在</p><blockquote toutiao-origin=span>dbms/src/Interpreters/executeQuery.cpp</blockquote><p>中一探究竟:</p><p>具体逻辑在 executeQueryImpl 函数中,挑选核心的逻辑进行讲解:</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>static std::tuple&lt;ASTPtr, BlockIO&gt; executeQueryImpl<br>{<br>//构造Parser<br>ParserQuery parser(end, settings.enable_debug_queries);<br>ASTPtr ast;<br><br>//把Query转化为抽象语法树<br>ast = parseQuery(parser, begin, end, "", max_query_size);<br><br>//生成interpreter实例<br>auto interpreter = InterpreterFactory::get(ast, context, stage);<br><br>// interpreter解析AST,结果是BlockIO<br>res = interpreter-&gt;execute;<br><br>//返回结果是抽象语法树和解析后的结果组成的二元组<br>return std::make_tuple(ast, res);<br>}</code></p></pre><p>该函数所做的事情：</p><p>• 构建Parser,把Query解析成AST(抽象语法树)</p><p>• InterpreterFactory根据AST生成对应的Interpreter实例</p><p>• AST是由Interpreter来解析的，执行结果是一个BlockIO,BlockIO是对 BlockInputStream 和 BlockOutputStream 的一个封装。</p><p>总结:</p><p>• 服务端调用 executeQuery 来处理client发送的Query，执行后的结果保存在state这个结构体的io成员中。</p><p>每一条Query都会对应一个state结构体，记录了这条Query的id，处理状态，压缩算法，Query的文本和Query所处理数据对应的IO流等元信息。</p><p>• 然后服务端调用 <strong toutiao-origin=span>processOrdinaryQuery </strong>等方法把输出流结果封装成异步的IO流，发送到回client。</p><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S4RDmCtDHj5504><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=span>02 解析请求(Parser)</strong></h2><p>CK选择采用手写一个递归下降的Parser来对SQL进行解析，生成的结果是这个SQL对应的抽象语法树(AST),抽象语法树由表示各个操作的节点(IAST)表示。而本节主要介绍Parser背后的核心逻辑:</p><p>词法分析和语法分析的核心逻辑可以在parseQuery.cpp的 tryParseQuery 中一览无余。</p><p>该函数利用lexer将扫描Query字符流，将其分割为一个个的Token， token_iterator 即一个Token流迭代器，然后parser再对Token流进行解析生成AST抽象语法树。</p><pre><p><code>ASTPtr tryParseQuery<br>{<br>//Token为lexer词法分析后的基本单位,词法分析后生成的是Token流<br>Tokens tokens(pos, end, max_query_size);<br>IParser::Pos token_iterator(tokens);<br>ASTPtr res;<br>//Token流经过语法分析生成AST抽象语法树<br>bool parse_res = parser.parse(token_iterator, res, expected);<br>return res;<br><br>}</code></p></pre><p>我们可以看到,语法分析的核心就在于parser执行的parse方法。parse 方法具体的实现在 ParserQuery.cpp 的 parseImpl 中。</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>bool ParserQuery::parseImpl(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)<br>{<br>ParserQueryWithOutput query_with_output_p(enable_explain);<br>ParserInsertQuery insert_p(end);<br>ParserUseQuery use_p;<br>ParserSetQuery set_p;<br>ParserSystemQuery system_p;<br><br>bool res = query_with_output_p.parse(pos, node, expected)<br>|| insert_p.parse(pos, node, expected)<br>|| use_p.parse(pos, node, expected)<br>|| set_p.parse(pos, node, expected)<br>|| system_p.parse(pos, node, expected);<br><br>return res;<br>}</code></p></pre><p>我们可以看到,这个方法粗略地把Query分为了五种,但是本质上可以归纳为两种(第一种为有结果输出,对应show,select,create等语句;第二种为无结果输出,对应insert,use,set和与系统相关的语句(如exit))</p><p>• QueryWithOutput</p><p>• InsertQuery</p><p>• UseQuery</p><p>• SetQuery</p><p>• SystemQuery</p><p>每一种Query都自定义了其专属的Parser,所以代码逻辑是当接收到一个Query输入的时候，会尝试各种Query的Parser，直到成功为止。</p><p>我们可以select语句对应的parser进行分析:</p><p>核心逻辑可以总结为：</p><p>1.先给出select语句中可能出现的关键词</p><p>2.在词法分析生成的Token流中爬取这些关键词</p><p>3.如果成功爬取，则 setExpression 函数会组装该关键字对应的AST节点</p><p>每一种SQL语句(如select,drop,insert,create)都有对应的AST类，并且分别包含了这些语句中特有的关键字。</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>bool ParserSelectQuery::parseImpl(Pos &amp; pos, ASTPtr &amp; node, Expected &amp; expected)<br>{<br>//创建AST树节点<br>auto select_query = std::make_shared&lt;ASTSelectQuery&gt;;<br>node = select_query;<br><br>//select语句中会出现的关键词<br>ParserKeyword s_select("SELECT");<br>ParserKeyword s_distinct("DISTINCT");<br>ParserKeyword s_from("FROM");<br>ParserKeyword s_prewhere("PREWHERE");<br>ParserKeyword s_where("WHERE");<br>ParserKeyword s_group_by("GROUP BY");<br>ParserKeyword s_with("WITH");<br>ParserKeyword s_totals("TOTALS");<br>ParserKeyword s_having("HAVING");<br>ParserKeyword s_order_by("ORDER BY");<br>ParserKeyword s_limit("LIMIT");<br>ParserKeyword s_settings("SETTINGS");<br>ParserKeyword s_by("BY");<br>ParserKeyword s_rollup("ROLLUP");<br>ParserKeyword s_cube("CUBE");<br>ParserKeyword s_top("TOP");<br>ParserKeyword s_with_ties("WITH TIES");<br>ParserKeyword s_offset("OFFSET");<br><br>//...<br>//依次对Token流爬取上述关键字<br>ParserTablesInSelectQuery.parse(pos, tables, expected)<br><br>//根据语法分析结果设置AST的Expression属性,可以理解为如果SQL存在该关键字,这个关键字都会转化为AST上的一个节点<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::WITH, std::move(with_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::SELECT, std::move(select_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::TABLES, std::move(tables));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::PREWHERE, std::move(prewhere_expression));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::WHERE, std::move(where_expression));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::GROUP_BY, std::move(group_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::HAVING, std::move(having_expression));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(order_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_BY_OFFSET, std::move(limit_by_offset));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_BY_LENGTH, std::move(limit_by_length));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_BY, std::move(limit_by_expression_list));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_OFFSET, std::move(limit_offset));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::LIMIT_LENGTH, std::move(limit_length));<br>select_query-&gt;setExpression(ASTSelectQuery::Expression::SETTINGS, std::move(settings));<br><br>}</code></p></pre><p>整个Parser的流程图：</p><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S4RDmDP1wXvGlS><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=strong>03 执行请求(Interpreter)</strong></h2><p>解释器(Interpreter)负责从抽象语法树中创建查询执行的流水线，整条流水线以 BlockInputStream 和 BlockOutputStream 进行组织。比方说"select"是基于"from"的Block输出流来进行选择的，选择后的结果也会以Block输出流的形式输出到结果。首先我们来看:</p><blockquote toutiao-origin=span>dbms/src/Interpreters/InterpreterFactory.cpp</blockquote><p>每一种Query都会有对应的Interpreter，这个工厂方法就是根据AST的种类来实例化其对应的Interpreter,由其来具体执行对应AST的执行计划:</p><pre><p><code>std::unique_ptr&lt;IInterpreter&gt; InterpreterFactory::get(ASTPtr &amp; query, Context &amp; context, QueryProcessingStage::Enum stage)<br>{<br>//举个例子,如果该AST是由select语句转化过来,<br>if (query-&gt;as&lt;ASTSelectQuery&gt;)<br>{<br>/// This is internal part of ASTSelectWithUnionQuery.<br>/// Even if there is SELECT without union, it is represented by ASTSelectWithUnionQuery with single ASTSelectQuery as a child.<br>return std::make_unique&lt;InterpreterSelectQuery&gt;(query, context, SelectQueryOptions(stage));<br>}<br>}</code></p></pre><p>我们就以 <strong toutiao-origin=span>InterpreterSelectQuery</strong>为例，了解其实例化的核心逻辑:</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>InterpreterSelectQuery::InterpreterSelectQuery<br>{<br>//获取AST<br>auto &amp; query = getSelectQuery;<br><br>//对AST做进一步语法分析，对语法树做优化重写<br>syntax_analyzer_result = SyntaxAnalyzer(context, options).analyze(<br>query_ptr, source_header.getNamesAndTypesList, required_result_column_names, storage, NamesAndTypesList);<br><br>//每一种Query都会对应一个特有的表达式分析器,用于爬取AST生成执行计划(操作链)<br>query_analyzer = std::make_unique&lt;SelectQueryExpressionAnalyzer&gt;(<br>query_ptr, syntax_analyzer_result, context,<br>NameSet(required_result_column_names.begin, required_result_column_names.end),<br>options.subquery_depth, !options.only_analyze);<br>}</code></p></pre><p>语法分析直接生成的AST转化成执行计划可能性能上并不是最优的，因此需要SyntaxAnalyzer 对其进行优化重写，在其源码中可以看到其涉及到非常多 <strong>基规则</strong><strong>优化(rule based optimization)</strong>的trick。</p><p>SyntaxAnalyzer 会逐个针对这些规则对查询进行检查，确定其是否满足转换规则，一旦满足就会对其进行转换。</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze<br>{<br>// 剔除冗余列<br>removeDuplicateColumns(result.source_columns);<br><br>// 根据settings中enable_optimize_predicate_expression配置判断是否进行谓词下移<br>replaceJoinedTable(node);<br><br>// 根据settings中distributed_product_mode配置重写IN 与 JOIN 表达式<br>InJoinSubqueriesPreprocessor(context).visit(query);<br><br>// 优化Query内部的布尔表达式<br>LogicalExpressionsOptimizer.perform;<br><br>// 创建一个从别名到AST节点的映射字典<br>QueryAliasesVisitor(query_aliases_data, log.stream).visit(query);<br><br>// 公共子表达式的消除<br>QueryNormalizer(normalizer_data).visit(query);<br><br>// 消除select从句后的冗余列<br>removeUnneededColumnsFromSelectClause(select_query, required_result_columns, remove_duplicates);<br><br>// 执行标量子查询，并且用常量替代标量子查询结果<br>executeScalarSubqueries(query, context, subquery_depth);<br><br>// 如果是select语句还会做下列优化:<br><br>// 谓词下移优化<br>PredicateExpressionsOptimizer(select_query, settings, context).optimize;<br><br>/// GROUP BY 从句的优化<br>optimizeGroupBy(select_query, source_columns_set, context);<br><br>/// ORDER BY 从句的冗余项剔除<br>optimizeOrderBy(select_query);<br><br>/// LIMIT BY 从句的冗余列剔除<br>optimizeLimitBy(select_query);<br><br>/// USING语句的冗余列剔除<br>optimizeUsing(select_query);<br><br>}</code></p></pre><p>这里挑选几个简单介绍一下:</p><p>• 公共子表达式消除(Common Subexpression Elimination)</p><p>如果表达式 x op y 先前被计算过，并且从先前的计算到现在其计算表达式对应的值没有改变，那么 x op y 就称为公共子表达式。公共子表达式消除会搜索所有相同计算表达式的实例，并分析是否值得用保存计算值的单个变量来替换它们，以减少计算的开销。</p><p>• 标量子查询(Scala Subquery)的常量替换</p><p>标量子查询就是返回单一值的子查询，和公共子表达式消除相似，可以用常量来替换SQL中所有的标量子查询结果以减少计算开销。</p><p>• 谓词下移(Predicate Pushdown)</p><p>把外层查询块中的WHERE子句的谓词下移到较低层查询块如视图，以尽可能把过滤数据的操作移动到靠近数据源的位置。提前进行数据过滤能够大幅减少网络传输或者内存读取访问的数据量，以提高查询效率。</p><p>而 query_analyzer 的作用可以理解为解析优化重写后的AST，然后对所要进行的操作组成一条操作链，即物理执行计划，如:</p><pre><p><code>ExpressionActionsChain chain;<br>analyzer.appendWhere(chain);<br>chain.addStep;<br>analyzer.appendSelect(chain);<br>analyzer.appendOrderBy(chain);<br>chain.finalize;</code></p></pre><p>上述代码把where,select,orderby操作都加入到操作链中，接下来就可以从Storage层读取Block，对Block数据应用上述操作链的操作。而执行的核心逻辑，就在对应Interpreter的 executeImpl 方法实现中,这里以select语句的Interpreter来了解下读取Block数据并且对block数据进行相应操作的流程。</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>void InterpreterSelectQuery::executeImpl(TPipeline &amp; pipeline, const BlockInputStreamPtr &amp; prepared_input)<br>{<br>// 对应Query的AST<br>auto &amp; query = getSelectQuery;<br><br>AnalysisResult expressions;<br>// 物理计划，判断表达式是否有where,aggregate,having,order_by,litmit_by等字段<br>expressions = analyzeExpressions(<br>getSelectQuery,<br>*query_analyzer,<br>QueryProcessingStage::FetchColumns,<br>options.to_stage,<br>context,<br>storage,<br>true,<br>filter_info);<br><br>// 从Storage读取数据<br>executeFetchColumns(from_stage, pipeline, sorting_info, expressions.prewhere_info, expressions.columns_to_remove_after_prewhere);<br><br>// eg:根据SQL的关键字在BlockStream流水线中执行相应的操作, 如where,aggregate,distinct都分别由一个函数负责执行<br>executeWhere(pipeline, expressions.before_where, expressions.remove_where_filter);<br><br>executeAggregation(pipeline, expressions.before_aggregation, aggregate_overflow_row, aggregate_final);<br><br>executeDistinct(pipeline, true, expressions.selected_columns);<br><br>}</code></p></pre><p>既然我们知道了执行计划AnalysisResult(即物理执行计划)，接下来就需要从storage层中读取数据来执行对应的操作，核心逻辑在<strong toutiao-origin=span> executeFetchColumns </strong>中: 核心操作就是从storage层读取所要处理列的Block，并组织成BlockStream。</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>void InterpreterSelectQuery::executeFetchColumns(<br>QueryProcessingStage::Enum processing_stage, TPipeline &amp; pipeline,<br>const SortingInfoPtr &amp; sorting_info, const PrewhereInfoPtr &amp; prewhere_info, const Names &amp; columns_to_remove_after_prewhere)<br>{<br>// 实例化Block Stream<br>auto streams = storage-&gt;read(required_columns, query_info, context, processing_stage, max_block_size, max_streams)<br>// 读取列对应的Block,并且组织成Block Stream<br>streams = {std::make_shared&lt;BlockInputStream&gt;(storage-&gt;getSampleBlockForColumns(required_columns))};<br>streams.back = std::make_shared&lt;ExpressionBlockInputStream&gt;(streams.back, query_info.prewhere_info-&gt;remove_columns_actions);<br>}</code></p></pre><p>读取完Block Stream之后就是对其执行各种execute操作如 executeAggregation , executeWhere 操作，详见</p><blockquote toutiao-origin=span>InterpreterSelectQuery::executeImpl</blockquote><p>的代码。</p><p>因此Interpreter的处理过程可以总结为:</p><p>• 对AST进行优化重写</p><p>• 解析重写后的AST并生成操作链(执行计划)</p><p>• 从存储引擎中读取要处理的Block数据</p><p>• 对读取的Block数据应用操作链上的操作</p><p>那我们读取Block Stream并进行处理后，生成的结果如何写回到storage层呢? 我们这里以insert语句的Interpreter来了解下:</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>BlockIO InterpreterInsertQuery::execute<br>{<br>// table为存储引擎接口<br>StoragePtr table = getTable(query);<br>BlockOutputStreamPtr out;<br><br>// 从存储引擎读取Block Stream<br>auto query_sample_block = getSampleBlock(query, table);<br>out = std::make_shared&lt;AddingDefaultBlockOutputStream&gt;(<br>out, query_sample_block, out-&gt;getHeader, table-&gt;getColumns.getDefaults, context);<br><br>//执行结果封装成BlockIO<br>BlockIO res;<br>res.out = std::move(out);<br>}</code></p></pre><p>上面代码中的StoragePtr实际上就是IStorage这个存储引擎的接口</p><pre><p><code>using StoragePtr = std::shared_ptr&lt;IStorage&gt;;</code></p></pre><p>无论是写入还是读取操作都是依靠底层存储引擎(如MergeTree)的write和read接口来实现的，关于存储引擎的细节实现这里暂时不赘述，这里我们只需要知道我们从存储引擎接口中以流方式读取Block数据，而结果组织成BlockIO流输出。Interpreter的流程总结如下:</p><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S4RDmlD5SJPGhe><p></p><h2 toutiao-origin=h3><strong class=highlight-text toutiao-origin=span>04 返回请求结果</strong></h2><p><strong toutiao-origin=span>TCPHandler::runImpl</strong>中，执行完 executeQuery 之后需要调用各种processQuery的方法来给client返回执行SQL后的结果。</p><p>我们以 <strong toutiao-origin=span>TCPHandler::processOrdinaryQuery</strong>为例做简单分析:</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>void TCPHandler::processOrdinaryQuery<br>{<br>//把BlockStream封装成异步的Stream,那么从流中读取数据将会是异步操作<br>AsynchronousBlockInputStream async_in(state.io.in);<br><br>while(true){<br>Block block;<br>//从IO流读取block数据<br>block = async_in.read;<br>//发送block数据<br>sendData(block);<br>}<br>}</code></p></pre><p>Server负责在 sendData 函数中把输出结果写入到套接字输出缓冲区中,client只要从这个输出缓冲区读取就能够得到结果。</p><p><strong class=highlight-text toutiao-origin=span>左右滑动阅览</strong></p><pre><p><code>void TCPHandler::sendData(const Block &amp; block)<br>{<br>//初始化OutputStream的参数<br>initBlockOutput(block);<br><br>// 调用BlockOutputStream的write函数,把Block写到输出流<br>state.block_out-&gt;write(block);<br>state.maybe_compressed_out-&gt;next;<br>out-&gt;next;<br>}</code></p></pre><p>02</p><p></p><h1 toutiao-origin=h2>结语</h1><p>了解ClickHouse背后SQL的查询整个流程，不仅能让数据库使用者更清晰地认识到如何编写最优化的SQL，也能够让数据库内核开发者加深对数据库体系结构的理解，提高开发效率。</p><p>本文并没有涉及到太深入的技术细节，诸如向量化执行引擎，SIMD，基于llvm的动态代码生成，类MergeTree存储引擎等CK的技术细节也没有提及，只是从宏观角度给读者介绍了执行SQL背后内核到底发生了什么。后续我们会推出更多内核源码解读文章，敬请关注。</p><p><strong toutiao-origin=span>END</strong></p><pre><div><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RdIEj9hARSR1DD></div><br><div><ul><li><p>基于 Apache Flink 的实时监控告警系统</p></li><li><p>关于数据中台的深度思考与总结（干干货）</p></li><li><p>日志收集Agent，阴暗潮湿的地底世界</p></li><li><p>2020 继续踏踏实实的做好自己</p></li></ul></div></pre><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S0FUMtl41NrEMK><img alt="深度 | 一条查询SQL的前世今生——ClickHouse 源码阅读" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S0FUNTDJBxRdKz><pre><div><div><div><div><div><div><div><div><div><div><div><div><div><div><p>你点的每个赞，我都当成了喜欢</p></div></div></div></div></div></div></div></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'一条','查询','SQL'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>