<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>PHP进阶教程-一文理解和实现现代PHP框架里的IOC容器 | 极客快訊</title><meta property="og:title" content="PHP进阶教程-一文理解和实现现代PHP框架里的IOC容器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/423ce7eefc5d433f86a14589b1ba0043"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e3b6719c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e3b6719c.html><meta property="article:published_time" content="2020-11-14T21:07:27+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:27+08:00"><meta name=Keywords content><meta name=description content="PHP进阶教程-一文理解和实现现代PHP框架里的IOC容器"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e3b6719c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>PHP进阶教程-一文理解和实现现代PHP框架里的IOC容器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=pgc-h-arrow-right><strong>​容器是什么？</strong></h3><p>相信很多人听说过依赖注入，依赖注入实现的基础条件离不开容器，容器就是用来管理类依赖和注入的，负责服务的管理和解耦组件，最简单的理解我们可以把容器理解成一个超级大、专门存对象的数组。</p><div class=pgc-img><img alt=PHP进阶教程-一文理解和实现现代PHP框架里的IOC容器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/423ce7eefc5d433f86a14589b1ba0043><p class=pgc-img-caption></p></div><p>图1</p><p>如图所示调用者通过容器的标示获取到对象实例，图里可以看出来，可以通过 ::class 的方式来获取也可以直接通过对象标示获取实例对象。</p><p><br></p><p><strong>IOC是什么？</strong></p><p>大家可能都听说过IOC容器，IOC的全称是：(Inversion Of Control，反转控制)。</p><p>我们来理解一下什么是反转控制，在我们传统编码中我们在类与类之间的依赖通常是我们通过编码的方式new出来对象再传递的，而使用控制反转我们可以把对象的控制权交给容器或者框架去实现。目的是为了让我们不需要硬编码去创建对象，看图1可以知道，容器里面存放着很多对象，当我们要使用的时候可以直接去用。而容器里面的对象不需要我们在代码中编码创建。在需要某个类对象的时候会去容器里面获取对象，如果对象不存在则会自动创建。这就是省略了我们在代码里面去创建对象的过程，由容器去帮我们实现这个创建的过程，这就叫反转控制。一句话总结IOC：把创建对象的控制权转移给容器实现类的实例化。</p><p>例如：没有使用IOC的情况下，我们想要创建类</p><pre><code>&lt;?phpclass Sunny{}$sunny = new Sunny();</code></pre><p>我们需要手动去new一个类，这种情况就是硬编码在代码里面去实现的。</p><p>而使用IOC容器的代码则可以这样写。</p><pre><code>&lt;?phpclass Sunny{}$sunny = Container::getBean(Sunny::class);</code></pre><p>在容器的内部去帮我们实现这个类，有同学看到这里可能会有疑问，我使用 new Sunny 不是代码写得更短更简单吗？我们看完依赖注入再看一个例子。</p><p><strong>依赖注入</strong></p><p>现在知道了IOC是什么，那么一个新的问题出来了，我们在创建类的时候有些类的构造方法会需要我们传递参数怎么办？通过IOC的学习我们知道了IOC容器会帮我们解决这个对象实例创建的问题，那么在容器里面创建对象的时候发现类有其他依赖则会进行依赖查找，容器寻找需要对象的过程，称为DL(Dependency Lookup, 依赖查找)。而把需要的依赖注入到代码片段中这个称为DI(Dependency Injection,依赖注入)。</p><p>例如IOC里面说到的 new Sunny 这个例子。如果在类与类之间有多重依赖。</p><pre><code>&lt;?phpclass Computer{    public function run(){        echo "编程中....\n";    }}class Sunny{    private $computer;    public function __construct(Computer $computer){        $this-&gt;computer = $computer;    }    public function program(){        $this-&gt;computer-&gt;run();    }}$sunny = new Sunny(new Computer());$sunny-&gt;program();</code></pre><p>这里可以看到 Sunny 这个类想要编程依赖类 Computer 这个类，而如果使用IOC容器实现依赖注入的话，代码就简单了。</p><pre><code>&lt;?phpclass Computer{    public function run(){        echo "编程中....\n";    }}class Sunny{    private $computer;    public function __construct(Computer $computer){        $this-&gt;computer = $computer;    }    public function program(){        $this-&gt;computer-&gt;run();    }}$sunny = Container::getBean(Sunny::class);$sunny-&gt;program();</code></pre><h3 class=pgc-h-arrow-right>一句话总结：解决创建类实例当中对其他类的依赖，动态的向某个对象提供它所需要的其他对象。</h3><h3 class=pgc-h-arrow-right><strong>依赖倒置</strong></h3><p>依赖倒置解决的问题是松耦各个模块之间的重度依赖，上层模块不应该依赖底层模块，它们都应该依赖于抽象。通常简单的理解依赖倒置就是面向接口或者面向抽象来进行编程。我们通过下面的例子来看看面向接口编程。</p><pre><code>class Cache{    public function set($key,$value){        $redis = new CFile();        $redis-&gt;set($key,$value);    }}class CFile{    public function set($key,$value){        echo "file:{$key}-&gt;{$value}\n";    }}$cache = new Cache();$cache-&gt;set("name","sunny");</code></pre><p>上面的这段代码看似没有什么大问题，但是如果有一天把文件缓存改成Redis缓存呢？</p><pre><code>class Cache{    public function set($key,$value){        $redis = new CRedis();        $redis-&gt;set($key,$value);    }}class CRedis{    public function set($key,$value){        echo "redis:{$key}-&gt;{$value}\n";    }}$cache = new Cache();$cache-&gt;set("name","sunny");</code></pre><p>通过这段代码可以看出来当一个缓存使用的驱动改变了的时候，Cache的代码也必须作出相应的改变，因为代码写死在调用者身上了，耦合度变得高了。再对代码进行改造一样，让程序员面向interface编程，让代码变得更通用，更规范。</p><pre><code>interface ICache{    public function set($key,$value);}class CRedis implements ICache {    public function set($key,$value){        echo "redis:{$key}-&gt;{$value}\n";    }}class CFile implements ICache{    public function set($key,$value){        echo "file:{$key}-&gt;{$value}\n";    }}class Cache{    private $drive;    public function __construct(ICache $drive){        $this-&gt;drive = $drive;    }    public function set($key,$value){        $this-&gt;drive-&gt;set($key,$value);    }}$cache = new Cache(new CFile());$cache-&gt;set("name","sunny");</code></pre><p>很多人看到这段代码的时候想着，那我在构造方法直接把要的对象传进去不就好了吗？为什么还要定义一个interface呢？其实定义interface是为了规范代码，不管你使用哪个驱动，只要实现了我这个interface的都可以用，没有interface开发者在开发驱动的时候就会不知道这个驱动里面该有什么方法。当我们使用interface之后大家只要面向接口编程，Cache完全不管类是怎么实现的，Cache只是根据interface的方法进行操作。</p><p>一句话总结：依赖倒置实现松耦合</p><p><br></p><h1 class=pgc-h-arrow-right><strong>实战：根据容器原理实现容器</strong></h1><pre><code>&lt;?phpclass Container{    // 当前容器对象    private static $instance;    // 存放在容器里面到实例    protected $instances = [];    private function __construct(){    }    public static function getInstance(){        if (!self::$instance) {            self::$instance = new static();        }        return self::$instance;    }    /**     * 获取对象实例     * @param $key     * @return mixed     */    public function get($key){        if (isset($this-&gt;instances[$key])) {            return $this-&gt;instances[$key];        }    }    /**     * 绑定对象、闭包、类到容器     * @param $key     * @param null $concrete     * @return Container     */    public function bind($key, $concrete = null){        if ($concrete instanceof Closure) {            $this-&gt;instances[$key] = $concrete;        } elseif (is_object($concrete)) {            $this-&gt;instances[$key] = $concrete;        }        return $this;    }}class Sunny{    public function getName(){        echo time() . "\n";    }}$app = Container::getInstance();$sunny = $app-&gt;bind(Sunny::class,new Sunny());$sunny = $app-&gt;get(Sunny::class);$sunny-&gt;getName();</code></pre><p><br></p><h1 class=pgc-h-arrow-right><strong>实战：实现依赖注入</strong></h1><h3 class=pgc-h-arrow-right>Container.php</h3><pre><code>&lt;?phpclass Container{    // 当前容器对象    private static $instance;    // 存放在容器里面到实例    protected $instances = [];    private function __construct(){    }    public static function getInstance(){        if (!self::$instance) {            self::$instance = new static();        }        return self::$instance;    }    /**     * 获取对象实例     * @param $key     * @return mixed     * @throws ReflectionException     */    public function get($key){        if (isset($this-&gt;instances[$key])) {            return $this-&gt;instances[$key];        }        return $this-&gt;make($key);    }    /**     * 绑定对象、闭包、类到容器     * @param $key     * @param null $concrete     * @return Container     * @throws ReflectionException     */    public function bind($key, $concrete = null){        if ($concrete instanceof Closure) {            $this-&gt;instances[$key] = $concrete;        } elseif (is_object($concrete)) {            $this-&gt;instances[$key] = $concrete;        } else {            $this-&gt;make($key, $concrete);        }        return $this;    }    /**     * 创建类绑定到类实例     * @param $abstract     * @param null $atgs     * @return mixed     * @throws ReflectionException     */    public function make($abstract, $atgs = null){        if (isset($this-&gt;instances[$abstract])) {            return $this-&gt;instances[$abstract];        }        $object = $this-&gt;invokeClass($abstract);        $this-&gt;instances[$abstract] = $object;        return $object;    }    /**     * 反射解析类     * @param $abstract     * @return object     * @throws ReflectionException     */    public function invokeClass($abstract){        $reflectionClass = new \ReflectionClass($abstract);        // 获取构造方法        $construct = $reflectionClass-&gt;getConstructor();        // 获取参数得到实例        $params = $construct ? $this-&gt;parserParams($construct) : [];        $object = $reflectionClass-&gt;newInstanceArgs($params);        return $object;    }    /**     * 解析构造方法参数     * @param $reflect     * @return array     * @throws ReflectionException     */    public function parserParams(ReflectionMethod $reflect){        $args = [];        $params = $reflect-&gt;getParameters();        if (!$params) {            return $args;        }        if (count($params) &gt; 0) {            foreach ($params as $param) {                $class = $param-&gt;getClass();                if ($class) {                    $args[] = $this-&gt;make($class-&gt;getName());                    continue;                }                // 获取变量的名称                $name = $param-&gt;getName();                // 默认值                $def = null;                // 如果有默认值，从默认值获取类型                if ($param-&gt;isOptional()) {                    $def = $param-&gt;getDefaultValue();                }                $args[] = $_REQUEST[$name] ?? $def;            }        }        return $args;    }}</code></pre><h3 class=pgc-h-arrow-right>Test.php</h3><pre><code>&lt;?phpclass Test{    public $name;    private $test1;    public function __construct(Test1 $test1){        $this-&gt;test1 = $test1;        $this-&gt;name = $this-&gt;test1-&gt;getName();    }}</code></pre><h3 class=pgc-h-arrow-right>Test1.php</h3><pre><code>&lt;?phpclass Test1{    public function getName(){        return "test1返回的名字";    }}</code></pre><h3 class=pgc-h-arrow-right>Sunny.php</h3><pre><code>&lt;?phprequire_once "./Container.php";require_once "./Test.php";require_once "./Test1.php";class Sunny{    private $test;    public function __construct(Test $test){        $this-&gt;test = $test;    }    public function getName(){        echo "获取test里面的name：{$this-&gt;test-&gt;name}\n";    }}$app = Container::getInstance();$sunny = $app-&gt;get(Sunny::class);$sunny-&gt;getName();</code></pre><p>如果喜欢我们的文章请关注 + 转发 让更多人看到，我们也会持续提供更多原创的好文章。</p><div class=pgc-img><img alt=PHP进阶教程-一文理解和实现现代PHP框架里的IOC容器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/379e095c9bd843c3b958f1b161a81130><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'PHP','进阶','实现'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/fe9184d7.html alt=PHP进阶教程-实现一个简单的MySQL连接池 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/aa2df096a4274ba1b5c8540bcb5b5c73 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/fe9184d7.html title=PHP进阶教程-实现一个简单的MySQL连接池>PHP进阶教程-实现一个简单的MySQL连接池</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>