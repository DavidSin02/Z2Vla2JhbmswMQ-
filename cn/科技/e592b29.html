<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看 | 极客快訊</title><meta property="og:title" content="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/dcd9e3b969124f1297a6bc7627747e80"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e592b29.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e592b29.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e592b29.html><meta property="article:published_time" content="2020-10-29T21:05:31+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:31+08:00"><meta name=Keywords content><meta name=description content="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e592b29.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcd9e3b969124f1297a6bc7627747e80><p class=pgc-img-caption></p></div><h1><strong>链表</strong></h1><p>链表是最基本的数据结构，面试官也常常用链表来考察面试者的基本能力，而且链表相关的操作相对而言比较简单，也适合考察写代码的能力。链表的操作也离不开指针，指针又很容易导致出错。</p><blockquote><p>综合多方面的原因，链表题目在面试中占据着很重要的地位。</p></blockquote><pre>public class ListNode { int val; ListNode next; ListNode(int x) { val = x; next = null; }}</pre><hr><p><strong>删除节点</strong></p><p><strong>思路：</strong></p><ul><li>将下一个节点复制到当前</li></ul><pre>public void deleteNode(ListNode node) { if (node.next == null){ node = null; return; } // 取缔下一节点 node.val = node.next.val node.next = node.next.next}</pre><hr><p><strong>翻转链表</strong></p><p><strong>思路</strong></p><p>思路：每次都将原第一个结点之后的那个结点放在新的表头后面。</p><p>比如1,2,3,4,5</p><ul><li>第一次：把第一个结点1后边的结点2放到新表头后面，变成2,1,3,4,5</li><li>第二次：把第一个结点1后边的结点3放到新表头后面，变成3,2,1,4,5</li><li>……</li><li>直到： 第一个结点1，后边没有结点为止。</li></ul><p><strong>视频</strong></p><p>大圣算法 翻转链表(Reverse Linked List ) -- LeetCode 206</p><pre>public ListNode reverse(ListNode head) { //prev表示前继节点 ListNode prev = null; while (head != null) { //temp记录下一个节点，head是当前节点 ListNode temp = head.next; head.next = prev; prev = head; head = temp; } return prev;}</pre><hr><p><strong>中间元素</strong></p><p><strong>思路</strong></p><p>我总结了一下，可以称为 田忌赛马’法</p><pre>public ListNode findMiddle(ListNode head){ if(head == null){ return null; }  ListNode slow = head; ListNode fast = head;  // fast.next = null 表示 fast 是链表的尾节点 while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; } return slow;}</pre><hr><p><strong>合并两个已排序链表</strong></p><p><strong>思路</strong></p><ul><li>递归方法：首先比较给新链表接上一个结点，然后这个结点的next就是剩下的两条链表合并的结果。</li></ul><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/54012a6eeb6545808e624531fb8e4639><p class=pgc-img-caption></p></div><pre>public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode lastNode = dummy;  while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { lastNode.next = l1; l1 = l1.next; } else { lastNode.next = l2; l2 = l2.next; } lastNode = lastNode.next; }  if (l1 != null) { lastNode.next = l1; } else { lastNode.next = l2; }  return dummy.next;}</pre><hr><p><strong>链表排序</strong></p><p><strong>归并排序</strong></p><ul><li>归并排序的也是基于分治的思想，但是与快排不同的是归并是先划分，然后从底层开始向上合并。</li><li>归并排序的主要思想是将两个已经排好序的分段合并成一个有序的分段。除了找到中间节点的操作必须遍历链表外，其它操作与数组的归并排序基本相同。</li><li><strong>视频</strong></li></ul><p>合并两个排序链表</p><pre>public ListNode sortList(ListNode head) { if (head == null || head.next == null) { return head; } // 取得中间节点，将链表一分为二 ListNode mid = findMiddle(head); ListNode right = sortList(mid.next); mid.next = null; ListNode left = sortList(head); return mergeTwoLists(left, right);}// 查找中间元素算法public ListNode findMiddle(ListNode head){ if(head == null){ return null; }  ListNode slow = head; ListNode fast = head;  // fast.next = null 表示 fast 是链表的尾节点 while(fast != null &amp;&amp; fast.next != null){ fast = fast.next.next; slow = slow.next; } return slow;}// 合并两个有序链表public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode lastNode = dummy;  while (l1 != null &amp;&amp; l2 != null) { if (l1.val &lt; l2.val) { lastNode.next = l1; l1 = l1.next; } else { lastNode.next = l2; l2 = l2.next; } lastNode = lastNode.next; }  if (l1 != null) { lastNode.next = l1; } else { lastNode.next = l2; }  return dummy.next;}</pre><hr><p><strong>快速排序</strong></p><p>快速排序的主要思想是：</p><ol><li>选定一个基准元素</li><li>经过一趟排序，将所有元素分成两部分</li><li>分别对两部分重复上述操作，直到所有元素都已排序成功</li></ol><p>因为单链表只能从链表头节点向后遍历，没有prev指针，因此必须选择头节点作为基准元素。这样第二步操作的时间复杂度就为O(n)。由于之后都是分别对两部分完成上述操作，因此会将链表划分为lgn个段，因此时间复杂度为O(nlgn）</p><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/93834ca9475d4897b63345d7be8e99b6><p class=pgc-img-caption></p></div><pre>public ListNode sortList(ListNode head) { quickSort(head, null); return head;}private void quickSort(ListNode start, ListNode end) { if (start == end) { return; }  ListNode pt = partition(start, end); quickSort(start, pt); quickSort(pt.next, end);}// 快排 轮状法private ListNode partition(ListNode start, ListNode end) { int pivotKey = start.val; ListNode p1 = start, p2 = start.next; while (p2 != end) { if (p2.val &lt; pivotKey) { p1 = p1.next; swapValue(p1, p2); } p2 = p2.next; }  swapValue(start, p1); return p1;}private void swapValue(ListNode node1, ListNode node2) { int tmp = node1.val; node1.val = node2.val; node2.val = tmp;}</pre><hr><p><strong>两个链表是否相交</strong></p><p><strong>思路</strong></p><ol><li>如果两个单链表有共同的节点</li><li>那么从第一个节点开始，后面的节点都会重叠，直至链表结束</li><li>因为两个链表中有一个共同节点</li><li>则从这个节点里的指针域指向下一个节点的地址就相同</li><li>所以相交以后的节点就会相同，直至链表结束，总的模型就像一个“Y”</li></ol><p><strong>视频</strong></p><p>【一起玩算法】交叉链表练习题讲解</p><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7ecb08deafca4985b436d6ab6f0a415b><p class=pgc-img-caption></p></div><pre>public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if (headA == null || headB == null) { return null; } ListNode currA = headA; ListNode currB = headB; int lengthA = 0; int lengthB = 0; // 让长的先走到剩余长度和短的一样 while (currA != null) { currA = currA.next; lengthA++; } while (currB != null) { currB = currB.next; lengthB++; } currA = headA; currB = headB; while (lengthA &gt; lengthB) { currA = currA.next; lengthA--; } while (lengthB &gt; lengthA) { currB = currB.next; lengthB--; }  // 然后同时走到第一个相同的地方 while (currA != currB) { currA = currA.next; currB = currB.next; }  // 返回交叉开始的节点 return currA;}</pre><h1><strong>栈 / 队列</strong></h1><ul><li>栈（stack）又名堆栈：</li></ul><p>它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。</p><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/027f14f5c02142f7abbcbb073b20cb71><p class=pgc-img-caption></p></div><ul><li>队列是一种特殊的线性表</li></ul><p>特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。</p><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/63caa1e6aeb74b0b99aa6af23e50bb32><p class=pgc-img-caption></p></div><p><strong>带最小值操作的栈</strong></p><p>这道面试题主要考察我们对于辅助栈的使用。</p><p>常见的辅助栈包括两种：</p><ol><li>辅助栈和数据栈同步</li><li>辅助栈和数据栈不同步</li></ol><p>我们这里采用辅助栈和数据栈同步的方式：</p><blockquote><p>特点：编码简单，不用考虑一些边界情况，就有一点不好：辅助栈可能会存一些“不必要”的元素。</p></blockquote><ol><li>辅助栈为空的时候，必须放入新进来的数；</li><li>新来的数小于或者等于辅助栈栈顶元素的时候，才放入，特别注意这里“等于”要考虑进去，因为出栈的时候，连续的、相等的并且是最小值的元素要同步出栈；</li><li>出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈。</li></ol><blockquote><p>总结一下：出栈时，最小值出栈才同步；入栈时，最小值入栈才同步。</p></blockquote><pre>public class MinStack { private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack; // 维护一个辅助栈，传入当前栈的最小值  public MinStack() { stack = new Stack&lt;Integer&gt;(); minStack = new Stack&lt;Integer&gt;(); } public void push(int number) { stack.push(number); if (minStack.isEmpty()) { minStack.push(number); } else { minStack.push(Math.min(number, minStack.peek())); } } public int pop() { minStack.pop(); return stack.pop(); } public int min() { return minStack.peek(); }}</pre><p><strong>有效括号</strong></p><p><strong>思路：</strong></p><ol><li>初始化栈 S。</li><li>一次处理表达式的每个括号。</li><li>如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处4理它，让我们简单地转到前面的 子表达式。</li><li>如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。</li><li>如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</li></ol><div class=pgc-img><img alt="高频算法题汇总「 链表 + 栈 + 队列」高级架构师必看" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/98cb334e5f7f41fbac47e7471eb2453a><p class=pgc-img-caption></p></div><pre>public boolean isValidParentheses(String s) { Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (Character c : s.toCharArray()) { if ("({[".contains(String.valueOf(c))) { stack.push(c); } else { if (!stack.isEmpty() &amp;&amp; isValid(stack.peek(), c)) { stack.pop(); } else { return false; } } } return stack.isEmpty();}private boolean isValid(char c1, char c2) { return (c1 == '(' &amp;&amp; c2 == ')') || (c1 == '{' &amp;&amp; c2 == '}') || (c1 == '[' &amp;&amp; c2 == ']');}</pre><p><strong>用栈实现队列</strong></p><p><strong>思路：</strong></p><ol><li>思路是有两个栈，一个用来放数据（数据栈），一个用来辅助（辅助栈）。</li><li>数据添加时，会依次压人栈，取数据时肯定会取栈顶元素，但我们想模拟队列的先进先出，所以就得取栈底元素，那么辅助栈就派上用场了</li><li>把数据栈的元素依次弹出到辅助栈，但保留最后一个元素，最后数据栈就剩下了最后一个元素，直接把元素返回，这时数据栈已经没有了数据。</li><li>最后呢，把辅助栈的元素依次压人数据栈，这样，我们成功取到了栈底元素。</li></ol><p><strong>视频</strong></p><p>图解「剑指Offer」之使用栈实现队列</p><pre>public class MyQueue { private Stack&lt;Integer&gt; outStack; private Stack&lt;Integer&gt; inStack; public MyQueue() { outStack = new Stack&lt;Integer&gt;(); inStack = new Stack&lt;Integer&gt;(); }  private void in2OutStack(){ while(!inStack.isEmpty()){ outStack.push(inStack.pop()); } }  public void push(int element) { inStack.push(element); } public int pop() { if(outStack.isEmpty()){ this.in2OutStack(); } return outStack.pop(); } public int top() { if(outStack.isEmpty()){ this.in2OutStack(); } return outStack.peek(); }}</pre><p><strong>逆波兰表达式求值 (后缀)</strong></p><p><strong>思路：</strong></p><ol><li>逆波兰表达式求解,定义一个栈辅助计算</li><li>当遇到运算符"+"、"-"、"*"、"/"时,从栈中pop出两个数字计算,否则将数字入栈;</li></ol><pre>public int evalRPN(String[] tokens) { Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); String operators = "+-*/"; for (String token : tokens) { if (!operators.contains(token)) { s.push(Integer.valueOf(token)); continue; } // 这里有个坑 int a = s.pop(); int b = s.pop(); // 先出的在运算符后 // 后出的在运算符前 if (token.equals("+")) { s.push(b + a); } else if(token.equals("-")) { s.push(b - a); } else if(token.equals("*")) { s.push(b * a); } else { s.push(b / a); } } return s.pop();}</pre><hr><h1><strong>Attention</strong></h1><p>为了提高文章质量，防止冗长乏味</p><p><strong>下一部分算法题</strong></p><ul><li>本片文章篇幅总结越长。我一直觉得，一片过长的文章，就像一场超长的 会议/课堂，体验很不好，所以打算再开一篇文章来总结其余的考点</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'高频','链表','队列'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>