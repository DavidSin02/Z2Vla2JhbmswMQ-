<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>动态规划基础篇之最长公共子序列问题 | 极客快訊</title><meta property="og:title" content="动态规划基础篇之最长公共子序列问题 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1534911245031e5c09c7696"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e5b7f2a6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e5b7f2a6.html><meta property="article:published_time" content="2020-11-14T21:04:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:21+08:00"><meta name=Keywords content><meta name=description content="动态规划基础篇之最长公共子序列问题"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e5b7f2a6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>动态规划基础篇之最长公共子序列问题</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>一些概念：</p><p>（1）子序列： 一个序列A ＝ a1,a2,……an,中任意删除若干项，剩余的序列叫做A的一个子序列。也可以认为是从序列A按原顺序保留任意若干项得到的序列。</p><p>例如：</p><p>对序列 1,3,5,4,2,6,8,7来说，序列3,4,8,7 是它的一个子序列。</p><p>对于一个长度为n的序列，它一共有2^n 个子序列，有(2^n – 1)个非空子序列。</p><p>请注意：子序列不是子集，它和原始序列的元素顺序是相关的。</p><p>（2）公共子序列 ： 顾名思义，如果序列C既是序列A的子序列，同时也是序列B的子序列，则称它为序列A和序列B的公共子序列。</p><p>例如：</p><p>对序列 1,3,5,4,2,6,8,7和序列 1,4,8,6,7,5 来说</p><p>序列1,8,7是它们的一个公共子序列。</p><p>请注意： 空序列是任何两个序列的公共子序列。</p><p>例如： 序列1,2,3和序列4,5,6的公共子序列只有空序列。</p><p>（3）最长公共子序列</p><p>A和B的公共子序列中长度最长的（包含元素最多的）叫做A和B的公共子序列。</p><p>仍然用序列1,3,5,4,2,6,8,7和序列1,4,8,6,7,5</p><p>它们的最长公共子序列是：</p><p>1,4,8,7</p><p>1,4,6,7</p><p>最长公共子序列的长度是4 。</p><p>请注意: 最长公共子序列不唯一。</p><p>请大家用集合的观点来理解这些概念，子序列、公共子序列以及最长公共子序列都不唯一，所以我们通常说一个最长公共子序列，但显然最长公共子序列的长度是一定的。</p><p>最长公共子序列问题就是求序列A= a1,a2,……an, 和B = b1,b2,……bm,的一个最长公共子序列。</p><p>因为最长公共子序列不唯一，让我们把问题简化，如何求出两个序列的最长公共子序列长度呢？</p><p>你首先能想到的恐怕是暴力枚举？那我们先来看看：序列A有 2^n 个子序列，序列B有 2^m 个子序列，如果任意两个子序列一一比较，比较的子序列高达 2^(n+m) 对，这还没有算具体比较的复杂度。</p><p>或许你说，只有长度相同的子序列才会真正进行比较。那么忽略空序列，我们来看看：对于A长度为1的子序列有C(n,1)个，长度为2的子序列有C(n,2)个，……长度为n的子序列有C(n,n)个。对于B也可以做类似分析，即使只对序列A和序列B长度相同的子序列做比较，那么总的比较次数高达：</p><p>C(n,1)*C(m,1)*1 + C(n,2) * C(m,2) * 2+ …+C(n,p) * C(m,p)*p</p><p>其中p = min(m, n)。</p><p>吓着了吧？怎么办？试试使用动态规划算法！</p><p>我们用Ax表示序列A的连续前x项构成的子序列，即Ax= a1,a2,……ax, By= b1,b2,……by, 我们用LCS(x, y)表示它们的最长公共子序列长度，那原问题等价于求LCS(m,n)。为了方便我们用L(x, y)表示Ax和By的一个最长公共子序列。</p><p>让我们来看看如何求LCS(x, y)。我们令x表示子序列考虑最后一项</p><p>（1） Ax ＝ By</p><p>那么它们L(Ax, By)的最后一项一定是这个元素！</p><p>为什么呢？为了方便，我们令t = Ax = By, 我们用反证法：假设L(x,y)最后一项不是t，</p><p>则要么L(x,y)为空序列（别忘了这个），要么L(x,y)的最后一项是Aa＝Bb ≠ t, 且显然有a &lt; x, b &lt; y。无论是哪种情况我们都可以把t接到这个L(x,y)后面,从而得到一个更长的公共子序列。矛盾！</p><p>如果我们从序列Ax中删掉最后一项ax得到Ax-1,从序列By中也删掉最后一项by得到By-1，(多说一句角标为0时，认为子序列是空序列)，则我们从L(x,y)也删掉最后一项t得到的序列是L(x – 1, y - 1)。为什么呢？和上面的道理相同，如果得到的序列不是L(x - 1, y - 1)，则它一定比L(x - 1, y - 1)短（注意L（，）是个集合！），那么它后面接上元素t得到的子序列L(x,y)也比L(x - 1, y - 1)接上元素t得到的子序列短，这与L(x, y)是最长公共子序列矛盾。</p><p>因此L(x, y) = L(x - 1, y - 1) 最后接上元素t</p><p>LCS(Ax, By) = LCS(x - 1, y - 1) + 1</p><p>（2） Ax ≠ By</p><p>仍然设t = L(Ax, By), 或者L(Ax, By)是空序列（这时t是未定义值不等于任何值）。</p><p>则t ≠ Ax和t ≠ By至少有一个成立，因为t不能同时等于两个不同的值嘛！</p><p>（2.1） 如果t ≠ Ax，则有L(x, y)= L(x - 1, y)，因为根本没Ax的事嘛。</p><p>LCS(x,y) = LCS(x – 1, y)</p><p>（2.2） 如果t ≠ By,l类似L(x, y)= L(x , y - 1)</p><p>LCS(x,y) = LCS(x, y – 1)</p><p>可是，我们事先并不知道t，由定义，我们取最大的一个，因此这种情况下,有LCS(x,y) = max(LCS(x – 1, y) , LCS(x, y – 1))。</p><p>看看目前我们已经得到了什么结论：</p><p>LCS(x,y) =</p><p>(1) LCS(x - 1,y - 1) + 1 如果Ax ＝ By</p><p>(2) max(LCS(x – 1, y) , LCS(x, y – 1)) 如果Ax ≠ By</p><p>这时一个显然的递推式，光有递推可不行，初值是什么呢？</p><p>显然，一个空序列和任何序列的最长公共子序列都是空序列！所以我们有:</p><p>LCS(x,y) =</p><p>(1) LCS(x - 1,y - 1) + 1 如果Ax ＝ By</p><p>(2) max(LCS(x – 1, y) , LCS(x, y – 1)) 如果Ax ≠ By</p><p>(3) 0 如果x = 0或者y = 0</p><p>到此我们求出了计算最长公共子序列长度的递推公式。我们实际上计算了一个(n + 1)行(m + 1)列的表格（行是0..n，列是0..m)，也就这个二维度数组LCS(,)。</p><p>大概的伪代码如下：</p><p>输入序列A, B长度分别为n，m,计算二维表 LCS(int,int):</p><ol><li><br></li><li>for x = 0 to n do</li><li>for y = 0 to m do</li><li>if (x == 0 || y == 0) then</li><li>LCS(x, y) = 0</li><li>else if (Ax == By) then</li><li>LCS(x, y) = LCS(x - 1,y - 1) + 1</li><li>else</li><li>LCS(x, y) = ) max(LCS(x – 1, y) , LCS(x, y – 1))</li><li>endif</li><li>endfor</li><li>endfor</li></ol><p>注意： 我们这里使用了循环计算表格里的元素值，而不是递归，如果使用递归需要已经记录计算过的元素，防止子问题被重复计算。</p><p>现在问题来了，我们如何得到一个最长公共子序列而仅仅不是简单的长度呢？其实我们离真正的答案只有一步之遥！</p><p>仍然考虑那个递推式，我们LCS(x,y)的值来源的三种情况：</p><p>（1） LCS(x – 1, y – 1) + 1如果Ax ＝ By</p><p>这对应L(x,y) = L(x,- 1 y- 1)末尾接上Ax</p><p>（2.1） LCS(x – 1, y) 如果Ax ≠ By且LCS(x – 1, y) ≥LCS(x, y – 1)</p><p>这对应L(x,y)= L(x – 1, y)</p><p>（2.2） LCS(x, y – 1) 如果Ax ≠ By且LCS(x – 1, y) &lt;LCS(x, y – 1)</p><p>这对应L(x,y) = L(x, y – 1)</p><p>（3） 0 如果 x =0或者y = 0</p><p>这对应L(x,y)=空序列</p><p>注意(2.1)和(2.2) ，当LCS(x – 1, y) ＝ LCS(x, y – 1)时，其实走哪个分支都一样，虽然长度时一样的，但是可能对应不同的子序列，所以最长公共子序列并不唯一。</p><p>神奇吧？又一个类似的递推公式。可见我们在计算长度LCS(x,y)的时候只要多记录一些信息，就可以利用这些信息恢复出一个最长公共子序列来。就好比我们在迷宫里走路，走到每个位置的时候记录下我们时从哪个方向来的，就可以从终点回到起点一样。</p><div class=pgc-img><img alt=动态规划基础篇之最长公共子序列问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1534911245031e5c09c7696><p class=pgc-img-caption></p></div><p>另外，说一下复杂度？</p><p>时间复杂度时O(n * m)，空间也是O(n * m)</p><p>今天对LCS的讲解就到这里，聪明的你是不是已经蠢蠢欲动要AC问题啦？ 心动不如行动，赶快吧。</p><p>在这里，本宝宝找到了两个模板，先收藏着，等过段在细细琢磨琢磨，有新的收获再补充。</p><p>代码一是让你输入两个序列，然后输出最长公共子序列和长度。</p><p>代码二是让你输入三个序列，然后输出最长公共子序列的长度。</p><p>代码一：</p><ol><li><br></li><li>#include &lt;stdio.h></li><li>#include &lt;string.h></li><li>#include &lt;stdlib.h></li><li>int LCSLength(char* str1, char* str2, int **b)</li><li>{</li><li>int i,j,length1,length2,len;</li><li>length1 = strlen(str1);</li><li>length2 = strlen(str2);</li><li></li><li>//双指针的方法申请动态二维数组</li><li>int **c = new int*[length1+1]; //共有length1+1行</li><li>for(i = 0; i &lt; length1+1; i++)</li><li>c[i] = new int[length2+1];//共有length2+1列</li><li></li><li>for(i = 0; i &lt; length1+1; i++)</li><li>c[i][0]=0; //第0列都初始化为0</li><li>for(j = 0; j &lt; length2+1; j++)</li><li>c[0][j]=0; //第0行都初始化为0</li><li></li><li>for(i = 1; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 1; j &lt; length2+1; j++)</li><li>{</li><li>if(str1[i-1]==str2[j-1])//由于c[][]的0行0列没有使用，c[][]的第i行元素对应str1的第i-1个元素</li><li>{</li><li>c[i][j]=c[i-1][j-1]+1;</li><li>b[i][j]=0; //输出公共子串时的搜索方向</li><li>}</li><li>else if(c[i-1][j]>c[i][j-1])</li><li>{</li><li>c[i][j]=c[i-1][j];</li><li>b[i][j]=1;</li><li>}</li><li>else</li><li>{</li><li>c[i][j]=c[i][j-1];</li><li>b[i][j]=-1;</li><li>}</li><li>}</li><li>}</li><li>/*</li><li>for(i= 0; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length2+1; j++)</li><li>printf("%d ",c[i][j]);</li><li>printf("\n");</li><li>}</li><li>*/</li><li>len=c[length1][length2];</li><li>for(i = 0; i &lt; length1+1; i++) //释放动态申请的二维数组</li><li>delete[] c[i];</li><li>delete[] c;</li><li>return len;</li><li>}</li><li>void PrintLCS(int **b, char *str1, int i, int j)</li><li>{</li><li>if(i==0 || j==0)</li><li>return ;</li><li>if(b[i][j]==0)</li><li>{</li><li>PrintLCS(b, str1, i-1, j-1);//从后面开始递归，所以要先递归到子串的前面，然后从前往后开始输出子串</li><li>printf("%c",str1[i-1]);//c[][]的第i行元素对应str1的第i-1个元素</li><li>}</li><li>else if(b[i][j]==1)</li><li>PrintLCS(b, str1, i-1, j);</li><li>else</li><li>PrintLCS(b, str1, i, j-1);</li><li>}</li><li></li><li>int main(void)</li><li>{</li><li>char str1[100],str2[100];</li><li>int i,length1,length2,len;</li><li>printf("请输入第一个字符串：");</li><li>gets(str1);</li><li>printf("请输入第二个字符串：");</li><li>gets(str2);</li><li>length1 = strlen(str1);</li><li>length2 = strlen(str2);</li><li>//双指针的方法申请动态二维数组</li><li>int **b = new int*[length1+1];</li><li>for(i= 0; i &lt; length1+1; i++)</li><li>b[i] = new int[length2+1];</li><li>len=LCSLength(str1,str2,b);</li><li>printf("最长公共子序列的长度为：%d\n",len);</li><li>printf("最长公共子序列为：");</li><li>PrintLCS(b,str1,length1,length2);</li><li>printf("\n");</li><li>for(i = 0; i &lt; length1+1; i++)//释放动态申请的二维数组</li><li>delete[] b[i];</li><li>delete[] b;</li><li>system("pause");</li><li>return 0;</li><li>}</li></ol><p>代码二：</p><ol><li><br></li><li>#include &lt;stdio.h></li><li>#include &lt;string.h></li><li>#include &lt;stdlib.h></li><li>int max1(int m,int n)</li><li>{</li><li>if(m>n)</li><li>return m;</li><li>else</li><li>return n;</li><li>}</li><li>int max2(int x,int y,int z,int k,int m,int n)</li><li>{</li><li>int max=-1;</li><li>if(x>max)</li><li>max=x;</li><li>if(y>max)</li><li>max=y;</li><li>if(z>max)</li><li>max=z;</li><li>if(k>max)</li><li>max=k;</li><li>if(m>max)</li><li>max=m;</li><li>if(n>max)</li><li>max=n;</li><li>return max;</li><li>}</li><li>int LCSLength(char* str1, char* str2, char* str3) //求得三个字符串的最大公共子序列长度并输出公共子序列</li><li>{</li><li>int i,j,k,length1,length2,length3,len;</li><li>length1 = strlen(str1);</li><li>length2 = strlen(str2);</li><li>length3 = strlen(str3);</li><li></li><li>//申请动态三维数组</li><li>int ***c = new int**[length1+1]; //共有length1+1行</li><li>for(i = 0; i &lt; length1+1; i++)</li><li>{</li><li>c[i] = new int*[length2+1]; //共有length2+1列</li><li>for(j = 0; j&lt;length2+1; j++)</li><li>c[i][j] = new int[length3+1];</li><li>}</li><li></li><li>for(i = 0; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length2+1; j++)</li><li>c[i][j][0]=0;</li><li>}</li><li>for(i = 0; i &lt; length2+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length3+1; j++)</li><li>c[0][i][j]=0;</li><li>}</li><li>for(i = 0; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 0; j &lt; length3+1; j++)</li><li>c[i][0][j]=0;</li><li>}</li><li></li><li>for(i = 1; i &lt; length1+1; i++)</li><li>{</li><li>for(j = 1; j &lt; length2+1; j++)</li><li>{</li><li>for(k = 1; k &lt; length3+1; k++)</li><li>{</li><li>if(str1[i-1]==str2[j-1] && str2[j-1]==str3[k-1])</li><li>c[i][j][k]=c[i-1][j-1][k-1]+1;</li><li>else if(str1[i-1]==str2[j-1] && str1[i-1]!=str3[k-1])</li><li>c[i][j][k]=max1(c[i][j][k-1],c[i-1][j-1][k]);</li><li>else if(str1[i-1]==str3[k-1] && str1[i-1]!=str2[j-1])</li><li>c[i][j][k]=max1(c[i][j-1][k],c[i-1][j][k-1]);</li><li>else if(str2[j-1]==str3[k-1] && str1[i-1]!=str2[j-1])</li><li>c[i][j][k]=max1(c[i-1][j][k],c[i][j-1][k-1]);</li><li>else</li><li>{</li><li>c[i][j][k]=max2(c[i-1][j][k],c[i][j-1][k],c[i][j][k-1],c[i-1][j-1][k],c[i-1][j][k-1],c[i][j-1][k-1]);</li><li>}</li><li>}</li><li>}</li><li>}</li><li>len=c[length1][length2][length3];</li><li>for(i = 1; i &lt; length1+1; i++) //释放动态申请的三维数组</li><li>{</li><li>for(j = 1; j &lt; length2+1; j++)</li><li>delete[] c[i][j];</li><li>delete[] c[i];</li><li>}</li><li>delete[] c;</li><li>return len;</li><li>}</li><li></li><li>int main(void)</li><li>{</li><li>char str1[100],str2[100],str3[100];</li><li>int len;</li><li></li><li>printf("请输入第一个字符串：");</li><li>gets(str1);</li><li>printf("请输入第二个字符串：");</li><li>gets(str2);</li><li>printf("请输入第三个字符串：");</li><li>gets(str3);</li><li>len=LCSLength(str1,str2,str3);</li><li>printf("最长公共子序列的长度为：%d\n",len);</li><li>system("pause");</li><li>return 0;</li><li>}</li></ol><div class=pgc-img><img alt=动态规划基础篇之最长公共子序列问题 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1534911259487118c56b5a9><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'动态','规划','基础'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>