<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>聊聊Java中的异常及处理 | 极客快訊</title><meta property="og:title" content="聊聊Java中的异常及处理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5071dd69a38e408697a9767a6c4bc352"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e619a68c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e619a68c.html><meta property="article:published_time" content="2020-11-14T21:06:59+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:59+08:00"><meta name=Keywords content><meta name=description content="聊聊Java中的异常及处理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e619a68c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>聊聊Java中的异常及处理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h3 class=pgc-h-arrow-right>前言</h3><p>在编程中异常报错是不可避免的。特别是在学习某个语言初期，看到异常报错就抓耳挠腮，常常开玩笑说编程1分钟，改bug1小时。今天就让我们来看看什么是异常和怎么合理的处理异常吧！</p><h3 class=pgc-h-arrow-right>异常与error介绍</h3><p>下面还是先让我们来看一下基本概念吧！</p><p>​ <strong>异常</strong>指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需要处理的文件不存在、数组下标越界等。异常机制本质就是当程序出现错误，程序安全退出的机制。在Java的异常处理机制中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。</p><p>​ Java是采用面向对象的方式来处理异常的。处理过程：</p><ol start=1><li>抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE。</li><li>捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止。</li></ol><p>让我们来看看前面所讲到的异常类究竟是个什么东西!</p><p>其实所有的异常对象都是派生于Throwable类的一个实例。如果内置的异常类不能够满足需要，还可以创建自己的异常类。所有异常的根类为java.lang.Throwable。看看它的家族长什么样。</p><div class=pgc-img><img alt=聊聊Java中的异常及处理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5071dd69a38e408697a9767a6c4bc352><p class=pgc-img-caption></p></div><p>Throwable类下面主要是两大门派。<strong>Error</strong>和<strong>Exception</strong>。</p><ul><li><strong>Error</strong>是程序无法处理的错误，表示运行应用程序中较严重问题，系统JVM已经处于不可恢复的崩溃状态中。例如，说内存溢出和线程死锁等系统问题。</li><li><strong>Exception</strong>是程序本身能够处理的异常。Exception类是所有异常类的父类，其子类对应了各种各样可能出现的异常事件。 通常Java的异常可分为：RuntimeException 运行时异常CheckedException 已检查异常下面我们来研究研究这两个异常。</li></ul><h3 class=pgc-h-arrow-right>RuntimeException和 CheckedException异同</h3><p>首先我们先来看看什么是<strong>运行时异常</strong>。</p><p>这类异常通常是由编程错误导致的，所以在编写程序时，并不要求必须使用异常处理机制来处理这类异常,而是经常需要通过增加“逻辑处理来避免这些异常”。</p><p>比如以下常见的几种异常：</p><p>ArithmeticException异常</p><pre><code> int b=0; System.out.println(1/b); //解决：   if(b!=0){      System.out.println(1/b);   }</code></pre><p>NumberFormatException异常</p><pre><code>String str = "1234abcf";System.out.println(Integer.parseInt(str));//解决： Pattern p = Pattern.compile("^\\d+$");Matcher m = p.matcher(str);if (m.matches()) { // 如果str匹配代表数字的正则表达式,才会转换    System.out.println(Integer.parseInt(str));}</code></pre><p>ClassCastException异常</p><pre><code>Animal a=new Dog();Cat c=(Cat)a;//解决：    if (a instanceof Cat) {    Cat c = (Cat) a;}</code></pre><p>这里再补充两点，方便大家更好的理解java异常的机制和处理过程。</p><ol start=1><li>在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器(exception handler)。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。</li><li>运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。</li></ol><p>上面我们讲述了什么是运行时异常以及一些处理方式，下面就再来看看什么是<strong>已检查异常</strong>吧！</p><p>所有不是RuntimeException的异常，统称为Checked Exception，又被称为“已检查异常”，如IOException、SQLException等以及用户自定义的Exception异常。 这类异常在编译时就必须做出处理， 否则无法通过编译。</p><p>通常异常的处理方式有两种：</p><ol start=1><li>使用“try/catch”捕获异常</li><li>使用“throws”声明异常。</li></ol><p>下面就来详细的聊聊吧!</p><h3 class=pgc-h-arrow-right>异常的处理</h3><p>上面已经提了，异常处理通常有2种方式。先看看捕获异常吧。</p><p><strong>捕获异常</strong>是通过3个关键词来实现的：try-catch-finally。用try来执行一段程序，如果出现异常，系统抛出一个异常，可以通过它的类型来捕捉(catch)并处理它，最后一步是通过finally语句为异常处理提供一个统一的出口，finally所指定的代码都要被执行。</p><p>这个捕获异常其实也是我们在面试的时候会经常碰到的问题。下面我们分别再来对各个部分做一个简单的提示吧!</p><ul><li>try</li></ul><p>一个try语句必须带有至少一个catch语句块或一个finally语句块 。当异常处理的代码执行结束以后，不会再回到try语句去执行尚未执行的代码。</p><ul><li>catch</li></ul><p>每个try语句块可以伴随一个或多个catch语句，用于处理可能产生的不同类型的异常对象。在此介绍一些常用的方法，这些方法均继承自Throwable类 。</p><ol start=1><li>toString ()方法，显示异常的类名和产生异常的原因。</li><li>getMessage()方法，只显示产生异常的原因，但不显示类名。</li><li>printStackTrace()方法，用来跟踪异常事件发生时堆栈的内容。</li></ol><p>这里有一个需要特别注意的地方，那就是catch捕获异常时的捕获顺序：</p><p>如果异常类之间有继承关系，在顺序安排上就需注意。越是顶层的类，越放在下面，再不然就直接把多余的catch省略掉。 也就是说先捕获子类异常再捕获父类异常。</p><ul><li>finally</li></ul><p>finally语句块中始终都要执行，除了遇到了System.exit(0)结束程序运行。针对这个特性，所以我们通常在finally中关闭程序块已打开的资源，比如：关闭文件流、释放数据库连接等。</p><p>即使try和catch块中存在return语句，finally语句也会执行。是在执行完finally语句后再通过return退出。</p><p>在这里就有一道非常经典的一个面试题。</p><pre><code>public class Test {    public static void main(String[]args) {       System.out.println(new Test().test());;    }    static int test(){       int x = 1;       try{          retun x;       }finally{          System.out.print("jdbk"+ ++x);       }    }}// 问输出结果？</code></pre><p>先解释哈这里存在的玄妙吧!</p><p>看了上面的讲述，我们都知道了当try和catch中有return时，finally仍然会执行，所以正常逻辑来说此题的答案应该是“jdbk2 2”,但这里存在一个陷阱，那就是：</p><p>finally是在return后面的表达式运算后执行的（<strong>此时并没有返回运算后的值，而是先把要返回的值保 存起来，不管finally中的代码怎么样，返回的值都不会改变，</strong><strong>任然</strong><strong>是之前保存的值</strong>），所以函数返回值是 在finally执行前确定的。因此正确答案应该是：“jdbk2 1”。</p><p>还有一点需要注意的就是：finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><p>接下来再来讲讲<strong>声明异常</strong>吧，它相对来说就比较简单了。</p><p>在一些情况下，当前方法并不需要处理发生的异常，而是向上传递给调用它的方法处理。如果一个方法抛出多个已检查异常，就必须在方法的首部列出所有的异常，之间以逗号隔开。</p><pre><code>public static void readFile(String fileName) throws FileNotFoundException,IOException {}</code></pre><p>需要注意的地方就是：</p><ol start=1><li>在方法重写中声明异常时：子类重写父类方法时，如果父类方法有声明异常，那么子类声明的异常范围不能超过父类声明的范围。</li><li>声明异常我们一般在server层中。在controller层或则数据访问层一般是捕获异常。</li></ol><h3 class=pgc-h-arrow-right>自定义异常</h3><p>我们为什么要自定义异常？还不是因为在程序中，可能会遇到JDK提供的任何标准异常类都无法充分描述清楚我们想要表达的问题。此时我们就可以创建自己的异常类，即自定义异常类。</p><p>那我们怎么自定义异常类呢？相信你看了上面的异常类的家族图应该就猜到了。不错，自定义异常类只需从Exception类或者它的子类派生一个子类即可。如果你继承Exception类，则为受检查异常，必须对其进行处理;如果不想处理，可以让自定义异常类继承运行时异常RuntimeException类。通常我们自定义异常类应该包含2个构造器：一个是默认的构造器，另一个是带有详细信息的构造器。这里举一个例子。</p><pre><code>/**IllegalAgeException：非法年龄异常，继承Exception类*/class IllegalAgeException extends Exception {    //默认构造器    public IllegalAgeException() {    }    //带有详细信息的构造器，信息存储在message中    public IllegalAgeException(String message) {        super(message);    }}   public void setAge(int age) throws IllegalAgeException {        if (age &lt; 0) {            throw new IllegalAgeException("人的年龄不应该为负数");        }        this.age = age;    }</code></pre><p>最后给大家讲述一点使用异常机制的建议：</p><p>1.要避免使用异常处理代替错误处理，这样会降低程序的清晰性，并且效率低下。</p><p>2.处理异常不可以代替简单测试---只在异常情况下使用异常机制。</p><p>3.不要进行小粒度的异常处理---应该将整个任务包装在一个try语句块中。</p><p>4.异常往往在高层处理。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','异常及','处理'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>