<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>时域卷积网络TCN详解：使用卷积进行序列建模和预测 | 极客快訊</title><meta property="og:title" content="时域卷积网络TCN详解：使用卷积进行序列建模和预测 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d7a0cea6243e43c4bf1756bbc29f76c2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e6e28dd8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e6e28dd8.html><meta property="article:published_time" content="2020-11-14T21:03:07+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:07+08:00"><meta name=Keywords content><meta name=description content="时域卷积网络TCN详解：使用卷积进行序列建模和预测"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e6e28dd8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>时域卷积网络TCN详解：使用卷积进行序列建模和预测</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><p>CNN经过一些简单的调整就可以成为序列建模和预测的强大工具</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d7a0cea6243e43c4bf1756bbc29f76c2><p class=pgc-img-caption></p></div><p><br></p><p>尽管卷积神经网络(CNNs)通常与图像分类任务相关，但经过适当的修改，它已被证明是进行序列建模和预测的有价值的工具。在本文中，我们将详细探讨时域卷积网络(TCN)所包含的基本构建块，以及它们如何结合在一起创建一个强大的预测模型。使用我们的开源Darts TCN实现，我们展示了只用几行代码就可以在真实数据集上实现准确预测。</p><p>以下对时间卷积网络的描述基于以下论文:https://arxiv.org/pdf/1803.01271.pdf。本文引用用(*)表示。</p><h1 class=pgc-h-arrow-right>动机</h1><p>到目前为止，深度学习背景下的序列建模主题主要与递归神经网络架构(如LSTM和GRU)有关。S. Bai等人(*)认为，这种思维方式已经过时，在对序列数据进行建模时，应该将卷积网络作为主要候选者之一加以考虑。他们能够表明，在许多任务中，卷积网络可以取得比RNNs更好的性能，同时避免了递归模型的常见缺陷，如梯度爆炸/消失问题或缺乏内存保留。此外，使用卷积网络而不是递归网络可以提高性能，因为它允许并行计算输出。他们提出的架构称为时间卷积网络(TCN)，将在下面的部分中进行解释。为了便于理解TCN体系结构及其Darts实现，本文将尽可能使用与库中看到的相同的模型参数名称。</p><h1 class=pgc-h-arrow-right>基本模型</h1><p><strong>概述</strong></p><p>TCN是时域卷积网络（Temporal Convolutional Network）的简称，它由具有相同输入和输出长度的扩张的、因果的1D卷积层组成。下面几节将详细介绍这些术语的实际含义。</p><p><strong>一维卷积网络</strong></p><p>一维卷积网络以一个三维张量作为输入，也输出一个三维张量。我们的TCN实现的输入张量具有形状(batch<em>size、input</em>length、input<em>size)，输出张量具有形状(batch</em>size、input<em>length、output</em>size)。由于TCN中的每一层都有相同的输入和输出长度，所以只有输入和输出张量的第三维是不同的。在单变量情况下，input<em>size和output</em>size都等于1。在更一般的多变量情况下，input<em>size和output</em>size可能不同，因为我们可能不希望预测输入序列的每个组件。</p><p>单个1D卷积层接收一个shape的输入张量(batch<em>size, input</em>length, nr<em>input</em>channels)并输出一个shape张量(batch<em>size, input</em>length, nr<em>output</em>channels)。为了了解单个层如何将其输入转换为输出，让我们看一下批处理的一个元素(对批处理中的每个元素都进行相同的处理)。让我们从最简单的例子开始，其中nr<em>input</em>channels和nr<em>output</em>channels都等于1。在这种情况下，我们看到的是一维输入和输出张量。下图显示了输出张量的一个元素是如何计算的。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0ea62f26afba426ab84d340dbbe561ec><p class=pgc-img-caption></p></div><p><br></p><p>我们可以看到，要计算输出的一个元素，我们需要查看输入的一系列长度为kernel<em>size的连续元素。在上面的例子中，我们选择了一个3的kernel</em>size。为了得到输出，我们取输入的子序列和相同长度的已学习权值的核向量的点积。输出的下一个元素,相同的应用程序,但kernel_size-sized窗口的输入序列是由一个元素转移到正确的(对于本预测模型,stride 总是设置为1)。请注意,相同的一组内核权重将被用来计算每输出一个卷积层。下图显示了两个连续的输出元素及其各自的输入子序列。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/806810afc5e34d3bbda752414a2bef97><p class=pgc-img-caption></p></div><p><br></p><p>为了使可视化更简单，与核向量的点积不再显示，而是对每个具有相同核权重的输出元素发生。</p><p>为了确保输出序列与输入序列具有相同的长度，将应用一些零填充。这意味着在输入张量的开始或结束处添加额外的零值项，以确保输出具有所需的长度。后面的部分将详细解释如何做到这一点。</p><p>现在让我们看看有多个输入通道的情况，即nr<em>input</em>channels大于1。在本例中，上述过程对每个单独的输入通道都重复，但每次都使用不同的内核。这将导致nr<em>input</em>channels中间输出向量和kernel<em>size * nr</em>input<em>channels的一些内核权重。然后将所有中间输出向量相加，得到最终输出向量。在某种意义上，这相当于与一个形状的输入张量(input</em>size, nr<em>input</em>channels)和一个形状的内核张量(kernel<em>size, nr</em>input_channels)进行2D卷积，如下图所示。它仍然是一维的因为窗口只沿着一个轴移动，但是我们在每一步都有一个二维卷积因为我们使用的是一个二维核矩阵。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b563674888b44ab6b244de246f34e05b><p class=pgc-img-caption></p></div><p><br></p><p>对于本例，我们选择nr<em>input</em>channels等于2。现在，我们使用nr<em>input</em>channels by kernel<em>size内核矩阵沿着nr</em>input<em>channels宽系列长度input</em>length来代替在一维输入序列上滑动的核向量。</p><p>如果nr<em>input</em>channels和nr<em>output</em>channels都大于1，那么对每个具有不同内核矩阵的输出通道重复上述过程。然后将输出向量堆叠在一起，得到一个形状的输出张量(input<em>length, nr</em>output<em>channels)。本例中的内核权重数等于kernel</em>size<em>nrinputchannels</em>nr<em>output</em>channels。</p><p>nr<em>input</em>channels和nr<em>output</em>channels这两个变量取决于该层在网络中的位置。第一层是nr<em>input</em>channels = input<em>size，最后一层是nr</em>output<em>channels = output</em>size。所有其他层将使用由num_filters提供的中间通道号。</p><p><strong>因果卷积</strong></p><p>对于因果关系，对于{0，…，input<em>length - 1}中的每一个i，输出序列的第i个元素可能只依赖于索引为{0，…，i}的输入序列中的元素。换句话说，输出序列中的元素只能依赖于输入序列中在它之前的元素。如前所述，为了确保一个输出张量与输入张量具有相同的长度，我们需要进行零填充。如果我们只在输入张量的左侧填充零，那么就可以保证因果卷积。要理解这一点，请考虑最右边的输出元素。假设输入序列的右边没有填充，它所依赖的最后一个元素就是输入的最后一个元素。现在考虑输出序列中倒数第二个输出元素。与最后一个输出元素相比，它的内核窗口向左移动了1，这意味着它在输入序列中最右边的依赖项是输入序列中倒数第二个元素。根据归纳，对于输出序列中的每个元素，其在输入序列中的最新依赖项与其本身具有相同的索引。下图展示了一个input</em>length为4,kernel_size为3的示例。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/66d682c92ac24d8d9dc07b7bb0df1928><p class=pgc-img-caption></p></div><p><br></p><p>我们可以看到，在两个条目的左填充为零的情况下，我们可以获得相同的输出长度，同时遵守因果关系规则。事实上，在没有扩展的情况下，维持输入长度所需的零填充条目的数量总是等于kernel_size - 1。</p><p><strong>扩张</strong></p><p>预测模型的一种理想质量是输出中特定条目的值取决于输入中所有先前的条目，即索引小于或等于其自身的所有条目。当接受野(指影响输出的特定条目的原始输入的一组条目)的大小为input<em>length时，就可以实现这一点。我们也称其为"完整的历史记录"。正如我们以前看到的，一个传统的卷积层在输出中创建一个依赖于输入的kernel</em>size项的条目，这些条目的索引小于或等于它自己。例如，如果我们的kernel<em>size为3，那么输出中的第5个元素将依赖于输入中的元素3、4和5。当我们将多个层叠加在一起时，这个范围就会扩大。在下面的图中我们可以看到，通过kernel</em>size 3叠加两层，我们得到的接受野大小为5。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e5550620c6c04544ac8c542f3179e95e><p class=pgc-img-caption></p></div><p><br></p><p>一般而言，具有n层且kernel_size为k的一维卷积网络的接收场r为</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9957f2a0b63c444ba1947b0e6f6e2b3a><p class=pgc-img-caption></p></div><p><br></p><p>为了知道需要多少层才能完全覆盖，我们可以将接受野大小设为input_length l，然后求解层数n(非整数值需要进行四舍五入):</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cc48b002d6fd47b0a6593cbff5809702><p class=pgc-img-caption></p></div><p><br></p><p>这意味着,kernel_size固定,完整的历史覆盖所需的层数是线性的输入长度的张量,这将导致网络变得非常深非常快,导致模型与大量的参数,需要更长的时间来训练。此外，大量的层已被证明会导致与损失函数梯度相关的退化问题。在保持层数相对较小的情况下，增加感受野大小的一种方法是向卷积网络引入膨胀概念。</p><p>卷积层上下文中的膨胀是指输入序列的元素之间的距离，该元素用于计算输出序列的一个条目。 因此，传统的卷积层可以看作是dilated为1的扩散层，因为1个输出值的输入元素是相邻的。 下图显示了一个dilated为2的扩散层的示例，其input<em>length为4，kernel</em>size为3。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9611432043eb44e9b8f8bb9437360a87><p class=pgc-img-caption></p></div><p><br></p><p>与dilated-1扩散的情况相比，该层的接收场沿5而不是3的长度扩展。更普遍地，具有内核大小k的d扩散层的接收场沿1 + d的长度扩展。 *（k-1）。 如果d是固定的，那么仍然需要输入张量的长度为线性的数字才能实现完全的接收场覆盖（我们只是减小了常数）。</p><p>这个问题可以通过在层中向上移动时d的值呈指数增加来解决。 为此，我们选择一个常数dilation<em>base整数b，它将使我们根据其下的层数i来计算特定层的膨胀d，即d = b ** i。 下图显示了一个网络，其中input</em>length为10，kernel<em>size为3，dilation</em>base为2，这将导致3个膨胀的卷积层完全覆盖。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81360652806947aa8de3a77035991773><p class=pgc-img-caption></p></div><p><br></p><p>这里我们只显示影响输出最后一个值的输入的影响。同样，只显示最后一个输出值所必需的补零项。显然，最后的输出值依赖于整个输入覆盖率。实际上，给定超参数，input_length最多可以使用15，同时保持完全的接收野覆盖。一般来说，每增加一层，当前接受野宽度就增加一个d*(k-1)值，其中d计算为d=b**i, i表示新层下面的层数。因此，给出了基b指数膨胀时TCN的感受场宽度w、核大小k和层数n为</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ce494e600c5c4665a32d7d71324897b1><p class=pgc-img-caption></p></div><p><br></p><p>然而，根据b和k的值，这个接受野可能会有"洞"。考虑以下网络，其dilation_base为3，内核大小为2:</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0873efd21a85402fb22f97718d3c67e0><p class=pgc-img-caption></p></div><p><br></p><p>接受野的范围确实大于输入的大小(即15)。然而，接受野是有洞的;也就是说，在输入序列中有输出值不依赖的条目(如上面红色所示)。为了解决这个问题，我们需要将内核大小增加到3，或者将膨胀基数减小到2。一般来说，对于没有孔的感受野，核的大小k至少要与膨胀基b一样大。</p><p>考虑到这些观察结果，我们可以计算出我们的网络需要多少层才能覆盖整个历史。给定核大小k，膨胀基b，其中k≥b，输入长度l，为了实现全历史覆盖，必须满足以下不等式:</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f1c45c56f9c4f6ba50606837aca4364><p class=pgc-img-caption></p></div><p><br></p><p>我们可以求解n，得到所需的最小层数</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0b6dfefe3c64b568e07161cccf3dde3><p class=pgc-img-caption></p></div><p><br></p><p>我们可以看到，在输入长度方面，层数现在是对数的，而不是线性的。这是一个显著的改进，可以在不牺牲接受野覆盖率的情况下实现。</p><p>现在，唯一需要指定的是每一层所需的零填充项的数量。假设膨胀基为b，核大小为k，当前层以下有i个层，则当前层所需的补零项数p计算如下:</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f93d006ce62d41b291617e934f63d0e9><p class=pgc-img-caption></p></div><p><br></p><p><strong>基本TCN概述</strong></p><p>给定input<em>length, kernel</em>size, dilation_base和覆盖整个历史所需的最小层数，基本的TCN网络看起来像这样:</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/23a359863a5c40b1ac0a02426f555e1c><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>预测</h1><p>到目前为止，我们只讨论了'输入序列'和'输出序列'，而没有深入了解它们之间是如何相互关联的。在预测方面，我们希望预测未来时间序列的下一个条目。为了训练我们的TCN网络进行预测，训练集将由给定时间序列的等大小子序列对(输入序列、目标序列)组成。目标序列将是相对于其各自的输入序列向前移动一定数量output<em>length的序列。这意味着长度input</em>length的目标序列包含其各自输入序列的最后(input<em>length - output</em>length)元素作为第一个元素，位于输入序列最后一个条目之后的output<em>length元素作为它的最后一个元素。在预测方面，这意味着该模型所能预测的最大预测视界等于output</em>length。使用滑动窗口的方法，许多重叠的输入和目标序列可以创建出一个时间序列。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cfc21d01f834c0c950f782348f55f4b><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>模型的改进</h1><p>S. Bai等人(*)建议对基本的TCN体系结构进行一些添加，以提高本节将讨论的性能，即残差连接、正则化和激活函数。</p><p><strong>残差块</strong></p><p>我们对之前介绍的基本模型做的最大的修改是将模型的基本构建块从简单的一维因果卷积层改为由相同膨胀因子和残差连接的2层组成的残差块。</p><p>让我们从基本模型中考虑一个膨胀系数d为2、内核大小k为3的层，看看这是如何转化为改进模型的剩余块的。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/822ace57e86a4df881d2d68efac21c43><p class=pgc-img-caption></p></div><p><br></p><p>变为</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/98f18e7b5bb244beb7422c624923c499><p class=pgc-img-caption></p></div><p><br></p><p>这两个卷积层的输出将被添加到残差块的输入中，从而产生下一个块的输入。对于网络的所有内部块，即除了第一个和最后一个之外的所有内部块，输入和输出通道宽度是相同的，即num_filters。由于第一个残块的第一卷积层和最后一个残块的第二卷积层可能有不同的输入和输出通道宽度，所以可能需要调整残差张量的宽度，这是通过1x1卷积来完成的</p><p>此更改会影响对完整覆盖所需的最小层数的计算。现在我们必须考虑需要多少残差块才能实现接收域的完全覆盖。在TCN中添加一个残差块所增加的接受野宽度是添加一个基本因果层时的两倍，因为它包含两个这样的层。因此，扩张基为b的TCN的感受场总大小r、k≥b的核大小k和剩余块数n可计算为</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a3159bfcd31d4bf99000fe3545e03e9f><p class=pgc-img-caption></p></div><p><br></p><p>这保证了最小的残差块数n为input_length l的完整历史覆盖</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/94e17d54acaa41f0848dcf878cf8fee1><p class=pgc-img-caption></p></div><p><br></p><p><strong>激活,规范化、正规化</strong></p><p>为了使我们的TCN不仅仅是一个过于复杂的线性回归模型，需要在卷积层的顶部添加激活函数来引入非线性。ReLU激活被添加到两个卷积层之后的残差块中。</p><p>为了规范化隐含层的输入(抵消了梯度爆发的问题)，权值规范化应用于每一个卷积层。</p><p>为了防止过拟合，在每个剩余块的每个卷积层之后通过dropout引入正则化。下图显示了最终的剩余块。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2916501fef1c403fa92ccf0f739af710><p class=pgc-img-caption></p></div><p><br></p><p>第二个ReLU单元中的星号表示该层存在于除最后一层之外的所有层中，因为我们希望最终输出也能够具有负值（这与本文中概述的体系结构不同）。</p><h1 class=pgc-h-arrow-right>模型</h1><p>下图显示了我们最终的TCN模型，其中l等于input<em>length，k等于kernel</em>size，b等于dilation_base，k≥b，并且对于完整的历史覆盖n为最小数量的残差块，其中n可以从其他值计算得出 如上所述。</p><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc4b6a1020de433aa374122c3c2f47af><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>示例</h1><p>让我们看一个示例，该示例说明如何使用Darts库使用TCN架构预测时间序列。</p><p>首先，我们需要一个时间序列来训练和评估我们的模型。 为此，我们使用了Kaggle数据集，其中包含来自西班牙的每小时能源生产数据。 更具体地说，我们选择预测"河流上游水电"的产量。 此外，为了使问题的计算量减少，我们将每天的平均能源生产量取平均以获得每日的时间序列。</p><pre><code>from darts import TimeSeriesfrom darts.dataprocessing.transformers import MissingValuesFillerimport pandas as pddf = pd.read_csv('energy_dataset.csv', delimiter=",")df['time'] = pd.to_datetime(df['time'], utc=True)df['time']= df.time.dt.tz_localize(None)df_day_avg = df.groupby(df['time'].astype(str).str.split(" ").str[0]).mean().reset_index()value_filler = MissingValuesFiller()series = value_filler.transform(TimeSeries.from_dataframe(df_day_avg, 'time', ['generation hydro run-of-river and poundage']))series.plot()</code></pre><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1e24cb97353e47318697c722c845a41c><p class=pgc-img-caption></p></div><p><br></p><p>我们可以看到，除了每年的季节性之外，每月还会定期出现能源生产中的"峰值"。 由于TCN模型支持多个输入通道，因此我们可以在当前时间序列中添加其他时间序列分量，以对当月的当前日期进行编码。 这可以帮助我们的TCN模型更快地收敛。</p><pre><code>series = series.add_datetime_attribute('day', one_hot=True)</code></pre><p>现在，我们将数据分为训练和验证组件并执行标准化。</p><pre><code>from darts.dataprocessing.transformers import Scalertrain, val = series.split_after(pd.Timestamp('20170901'))scaler = Scaler()train_transformed = scaler.fit_transform(train)val_transformed = scaler.transform(val)series_transformed = scaler.transform(series)</code></pre><p>现在是时候创建和训练我们的TCN模型了。 注意，上面对体系结构的描述中出现的所有变量名都可以用作Darts TCN实现的构造函数的参数。 由于我们要执行每周预测，因此output<em>length参数设置为7。 在训练模型时，我们仅将训练系列的第一部分指定为target</em>series，因为我们不想预测我们之前添加的助手时间序列。 我们尝试了几种不同的超参数组合，但是大多数值是任意选择的。</p><pre><code>from darts.models import TCNModelmodel = TCNModel(    input_size=train.width,    n_epochs=20,     input_length=365,    output_length=7,     dropout=0,     dilation_base=2,     weight_norm=True,    kernel_size=7,    num_filters=4,    random_state=0)model.fit(    training_series=train_transformed,    target_series=train_transformed['0'],    val_training_series=val_transformed,    val_target_series=val_transformed['0'], verbose=True)</code></pre><p>为了评估我们的模型，我们希望使用7天的预测范围在验证集中的许多不同时间点测试其性能。 为此，我们使用了Darts的历史回测功能。 请注意，该模型为每个前提提供了新的输入数据，但从未对其进行过重新训练。 为了节省时间，我们将跨度设置为5。</p><pre><code>pred_series = model.backtest(    series_transformed,    target_series=series_transformed['0'],    start=pd.Timestamp('20170901'),     forecast_horizon=7,    stride=5,    retrain=False,    verbose=True,    use_full_output_length=True)</code></pre><p>让我们根据地面真实数据点将TCN模型的历史预测预测可视化，并计算R2得分。</p><pre><code>from darts.metrics import r2_scoreimport matplotlib.pyplot as pltseries_transformed[900:]['0'].plot(label='actual')pred_series.plot(label=('historic 7 day forecasts'))r2_score_value = r2_score(series_transformed['0'], pred_series)plt.title('R2:' + str(r2_score_value))plt.legend()</code></pre><div class=pgc-img><img alt=时域卷积网络TCN详解：使用卷积进行序列建模和预测 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d0ce974d722343d5b59ba30a5e1b3bc6><p class=pgc-img-caption></p></div><p><br></p><p>有关更多详细信息和其他示例，请在GitHub上查看 https://github.com/unit8co/darts/blob/develop/examples/TCN-examples.ipynb</p><h1 class=pgc-h-arrow-right>结论</h1><p>在大多数情况下，序列建模中的深度学习仍与递归神经网络架构广泛相关。 但是研究表明，在预测性能和效率方面，TCN可以在许多任务中胜过这些类型的模型。 在本文中，我们探讨了如何通过简单的构建块（例如一维卷积层，膨胀和残差连接）理解这种有前途的模型，以及它们如何融合在一起。 此外，我们成功地应用了TCN体系结构的当前Darts实现来预测实际时间序列。</p><p><br></p><p>作者:Francesco Lässig</p><p>deephub翻译组</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'卷积','时域','网络'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>