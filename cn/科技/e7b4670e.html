<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>来看看CALayer那些牛逼的子类 | 极客快訊</title><meta property="og:title" content="来看看CALayer那些牛逼的子类 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/322c0001962a9d0a3860"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7b4670e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7b4670e.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="来看看CALayer那些牛逼的子类"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e7b4670e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>来看看CALayer那些牛逼的子类</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/322c0001962a9d0a3860></p><p><strong>CATransformLayer</strong></p><p>我们先看一下系统有没有像之前讲过的几个子类一样，给它一些特殊的属性或者方法：</p><p><code>@interface CATransformLayer : CALayer</code></p><p><code>@end</code></p><p>啥都没有，我擦嘞，但是上面好像有一段描述我们看一下：</p><p><code>/* "Transform" layers are used to create true 3D layer hierarchies.</code></p><p><code></code><code>*</code></p><p><code></code><code>* Unlike normal layers, transform layers do not project (i.e. flatten)</code></p><p><code></code><code>* their sublayers into the plane at Z=0. However due to this neither</code></p><p><code></code><code>* do they support many features of the 2D compositing model:</code></p><p><code></code><code>*</code></p><p><code></code><code>* - only their sublayers are rendered (i.e. no background, contents,</code></p><p><code></code><code>* border)</code></p><p><code></code><code>*</code></p><p><code></code><code>* - filters, backgroundFilters, compositingFilter, mask, masksToBounds</code></p><p><code></code><code>* and shadow related properties are ignored (they all assume 2D</code></p><p><code></code><code>* image processing of the projected layer)</code></p><p><code></code><code>*</code></p><p><code></code><code>* - opacity is applied to each sublayer individually, i.e. the transform</code></p><p><code></code><code>* layer does not form a compositing group.</code></p><p><code></code><code>*</code></p><p><code></code><code>* Also, the -hitTest: method should never be called on transform</code></p><p><code></code><code>* layers (they do not have a 2D coordinate space into which to map the</code></p><p><code></code><code>* supplied point.) CALayer will pass over transform layers directly to</code></p><p><code></code><code>* their sublayers, applying the effects of the transform layer's</code></p><p><code></code><code>* geometry when hit-testing each sublayer. */</code></p><p>我们从中可以看出它作为父Layer时，对他的sublayers会有3D效果，也就是说不平面化它的子图层，大家一提到3D效果，就会想到一个神奇的东西景深，先说一下景深是个什么东西，提到景深，那我们就一定要说CATransform3D，它定义了一个4x4 的 CGFloat值的矩阵，就是这样的：</p><p><code>struct CATransform3D</code></p><p><code>{</code></p><p><code></code><code>CGFloat m11, m12, m13, m14;</code></p><p><code></code><code>CGFloat m21, m22, m23, m24;</code></p><p><code></code><code>CGFloat m31, m32, m33, m34;</code></p><p><code></code><code>CGFloat m41, m42, m43, m44;</code></p><p><code>}</code></p><p>其中的m34，就是上面提到的景深效果的源头，我们写一段代码看一下：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>CALayer *layer_ = [CALayer layer];</code></p><p><code></code><code>layer_.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer_.position = CGPointMake(self.view.center.x, 200);</code></p><p><code></code><code>layer_.opacity = 0.6;</code></p><p><code></code><code>layer_.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer_.borderWidth = 5;</code></p><p><code></code><code>layer_.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer_.cornerRadius = 20;</code></p><p><code></code><code>layer_.masksToBounds = YES;</code></p><p><code></code><code>[self.view.layer addSublayer:layer_];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D fromValue_ = CATransform3DIdentity;</code></p><p><code></code><code>fromValue_ = CATransform3DRotate(fromValue_, M_PI_2 / 2, 0, 1, 0);</code></p><p><code></code><code>layer_.transform = fromValue_;</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.position = self.view.center;</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor blueColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor orangeColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>[self.view.layer addSublayer:layer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue.m34 = 1.0 / -500;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2 / 2, 0, 1, 0);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code>}</code></p><p>运行结果：</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/322d00042e798384e986></p><p>是不是明显发现蓝色的layer3D效果更强烈一些。</p><p>下面我们试一下这样的代码：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>CALayer *layer_2 = [CALayer layer];</code></p><p><code></code><code>layer_2.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer_2.opacity = 0.6;</code></p><p><code></code><code>layer_2.backgroundColor = [UIColor blueColor].CGColor;</code></p><p><code></code><code>layer_2.borderWidth = 5;</code></p><p><code></code><code>layer_2.borderColor = [[UIColor orangeColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer_2.cornerRadius = 20;</code></p><p><code></code><code>layer_2.masksToBounds = YES;</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *containerLayer = [CALayer layer];</code></p><p><code></code><code>containerLayer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>containerLayer.position = self.view.center;</code></p><p><code></code><code>layer.position = CGPointMake(50, 50);</code></p><p><code></code><code>layer_2.position = CGPointMake(50, 50);</code></p><p><code></code><code>[containerLayer addSublayer:layer];</code></p><p><code></code><code>[containerLayer addSublayer:layer_2];</code></p><p><code></code><code>[self.view.layer addSublayer:containerLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D containerTransform = CATransform3DIdentity;</code></p><p><code></code><code>containerTransform.m34 = -1.0 / 500.0;</code></p><p><code></code><code>containerLayer.transform = containerTransform;</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>fromValue = CATransform3DTranslate(fromValue, 0, 0, -10);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code></code><code>CATransform3D fromValue_2 = CATransform3DIdentity;</code></p><p><code></code><code>fromValue_2 = CATransform3DRotate(fromValue_2, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>fromValue_2 = CATransform3DTranslate(fromValue_2, 0, 0, -50);</code></p><p><code></code><code>layer_2.transform = fromValue_2;</code></p><p><code>}</code></p><p>运行结果，一片空白，啥都没有。</p><p>我们做一处改动：</p><p>1</p><p><code>CATransformLayer *containerLayer = [CATransformLayer layer];</code></p><p>运行结果：</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/32100004d63d26bbca87></p><p>??：所以有人说CATransformLayer便是给他的子图层添加了景深的效果。瞎搞，把设置景深的代码containerTransform.m34 = -1.0 / 500.0;去掉，运行，你会发现还是一片空白。这就说明CATransformLayer并不是这么个作用。那这个东西的特殊之处究竟是什么呢？</p><p>其实就是上面说的：CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级分明的3D结构。</p><p>上代码：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>CALayer *containerLayer = [CALayer layer];</code></p><p><code></code><code>containerLayer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>containerLayer.position = self.view.center;</code></p><p><code></code><code>layer.position = CGPointMake(50, 50);</code></p><p><code></code><code>layer_2.position = CGPointMake(50, 50);</code></p><p><code></code><code>[containerLayer addSublayer:layer];</code></p><p><code></code><code>[self.view.layer addSublayer:containerLayer];</code></p><p><code></code><code>CATransform3D containerTransform = CATransform3DIdentity;</code></p><p><code></code><code>containerLayer.transform = containerTransform;</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code>}</code></p><p>运行结果：不出所料，一片空白。</p><p>于是，我们把containerLayer由CALayer改成CATransformLayer ，结果，还是一片空白。</p><p>现在，你肯定觉的我也是在扯淡，下面精彩的部分来了：</p><p>我们给containerLayer添加一个新的transform，代码也就是这样的：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>layer.opacity = 0.6;</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.borderWidth = 5;</code></p><p><code></code><code>layer.borderColor = [[UIColor greenColor] colorWithAlphaComponent:0.4].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.masksToBounds = YES;</code></p><p><code></code><code>CALayer *containerLayer = [CALayer layer];</code></p><p><code></code><code>containerLayer.bounds = CGRectMake(0, 0, 100, 100);</code></p><p><code></code><code>containerLayer.position = self.view.center;</code></p><p><code></code><code>layer.position = CGPointMake(50, 50);</code></p><p><code></code><code>layer_2.position = CGPointMake(50, 50);</code></p><p><code></code><code>[containerLayer addSublayer:layer];</code></p><p><code></code><code>[self.view.layer addSublayer:containerLayer];</code></p><p><code></code><code>CATransform3D containerTransform = CATransform3DIdentity;</code></p><p><code></code><code>//看这，我是新加的</code></p><p><code></code><code>containerTransform = CATransform3DRotate(containerTransform, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>//</code></p><p><code></code><code>containerLayer.transform = containerTransform;</code></p><p><code></code><code>CATransform3D fromValue = CATransform3DIdentity;</code></p><p><code></code><code>fromValue = CATransform3DRotate(fromValue, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>layer.transform = fromValue;</code></p><p><code>}</code></p><p>运行结果：</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/32100004d63cb1ed7d8d></p><p>现在，我们再把containerLayer由CATransformLayer改成CALayer ，结果，一片空白！你是不是明白了呢？其实还是上面那句话！</p><p>我们利用它来做一个立方体：</p><p><code>#import "ViewController.h"</code></p><p><code>@interface ViewController (){</code></p><p><code></code><code>CGPoint startPoint;</code></p><p><code></code><code>CATransformLayer *s_Cube;</code></p><p><code></code><code>float pix, piy;</code></p><p><code>}</code></p><p><code>@end</code></p><p><code>@implementation ViewController</code></p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>//</code></p><p><code></code><code>CATransform3D c1t = CATransform3DIdentity;</code></p><p><code></code><code>CALayer *cube1 = [self cubeWithTransform:c1t];</code></p><p><code></code><code>s_Cube = (CATransformLayer *)cube1;</code></p><p><code></code><code>[self.view.layer addSublayer:cube1];</code></p><p><code>}</code></p><p><code>- (CALayer *)faceWithTransform:(CATransform3D)transform color:(UIColor*)color</code></p><p><code>{</code></p><p><code></code><code>CALayer *face = [CALayer layer];</code></p><p><code></code><code>face.frame = CGRectMake(-50, -50, 100, 100);</code></p><p><code></code><code>face.backgroundColor = color.CGColor;</code></p><p><code></code><code>face.transform = transform;</code></p><p><code></code><code>return</code> <code>face;</code></p><p><code>}</code></p><p><code>- (CALayer *)cubeWithTransform:(CATransform3D)transform</code></p><p><code>{</code></p><p><code></code><code>//容器</code></p><p><code></code><code>CATransformLayer *cube = [CATransformLayer layer];</code></p><p><code></code><code>//前</code></p><p><code></code><code>CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor redColor]]];</code></p><p><code></code><code>//右</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(50, 0, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor yellowColor]]];</code></p><p><code></code><code>//上</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(0, -50, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor blueColor]]];</code></p><p><code></code><code>//下</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(0, 50, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor brownColor]]];</code></p><p><code></code><code>//左</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(-50, 0, 0);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor greenColor]]];</code></p><p><code></code><code>//后</code></p><p><code></code><code>ct = CATransform3DMakeTranslation(0, 0, -50);</code></p><p><code></code><code>ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);</code></p><p><code></code><code>[cube addSublayer:[self faceWithTransform:ct color:[UIColor orangeColor]]];</code></p><p><code></code><code>//</code></p><p><code></code><code>CGSize containerSize = self.view.bounds.size;</code></p><p><code></code><code>cube.position = CGPointMake(containerSize.width / 2.0,</code></p><p><code></code><code>containerSize.height / 2.0);</code></p><p><code></code><code>cube.transform = transform;</code></p><p><code></code><code>return</code> <code>cube;</code></p><p><code>}</code></p><p><code>- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</code></p><p><code>{</code></p><p><code></code><code>UITouch *touch = [touches anyObject];</code></p><p><code></code><code>startPoint = [touch locationInView:self.view];</code></p><p><code>}</code></p><p><code>- (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event</code></p><p><code>{</code></p><p><code></code><code>UITouch *touch = [touches anyObject];</code></p><p><code></code><code>CGPoint currentPosition = [touch locationInView:self.view];</code></p><p><code></code><code>CGFloat deltaX = startPoint.x - currentPosition.x;</code></p><p><code></code><code>CGFloat deltaY = startPoint.y - currentPosition.y;</code></p><p><code></code><code>CATransform3D c1t = CATransform3DIdentity;</code></p><p><code></code><code>c1t = CATransform3DRotate(c1t, pix + M_PI_2 * deltaY / 100, 1, 0, 0);</code></p><p><code></code><code>c1t = CATransform3DRotate(c1t, piy - M_PI_2 * deltaX / 100, 0, 1, 0);</code></p><p><code></code><code>s_Cube.transform = c1t;</code></p><p><code>}</code></p><p><code>- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</code></p><p><code>{</code></p><p><code></code><code>UITouch *touch = [touches anyObject];</code></p><p><code></code><code>CGPoint currentPosition = [touch locationInView:self.view];</code></p><p><code></code><code>CGFloat deltaX = startPoint.x - currentPosition.x;</code></p><p><code></code><code>CGFloat deltaY = startPoint.y - currentPosition.y;</code></p><p><code></code><code>pix = M_PI_2 * deltaY / 100;</code></p><p><code></code><code>piy = -M_PI_2 * deltaX / 100;</code></p><p><code>}</code></p><p><code>- (void)didReceiveMemoryWarning {</code></p><p><code></code><code>[</code><code>super</code> <code>didReceiveMemoryWarning];</code></p><p><code></code><code>// Dispose of any resources that can be recreated.</code></p><p><code>}</code></p><p><code>@end</code></p><p>运行结果：</p><p>如果针对上面的解释你还不是很理解，那么你可以把这个立方体的CATransformLayer换成CALayer，试试看喽。</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/321f0000b8b81b7e7f69></p><p><strong>CAReplicatorLayer</strong></p><p>通过这个名字，我就确定它和图层复制有关，你信不信？</p><p>我们看一下系统提供的API：</p><p><code>@interface CAReplicatorLayer : CALayer</code></p><p><code>@property NSInteger instanceCount; </code><code>//复制图层的个数，包括加到上面的</code></p><p><code>@property BOOL preservesDepth; </code><code>// 子图层是否平面化（看上面那个CATransformLayer）</code></p><p><code>@property CFTimeInterval instanceDelay; </code><code>// 复制层动画延迟时间</code></p><p><code>@property CATransform3D instanceTransform; </code><code>//子图层的transform变换，一般用来决定复制图层的初始位置以及初始试图变换</code></p><p><code>@property(nullable) CGColorRef instanceColor; </code><code>// 复制层颜色，该颜色是与本体元素色值相乘，鬼知道是什么颜色</code></p><p><code>@property float instanceRedOffset; </code><code>// 复制层红色偏移量</code></p><p><code>@property float instanceGreenOffset; </code><code>// 复制层绿色偏移量</code></p><p><code>@property float instanceBlueOffset; </code><code>// 复制层蓝色偏移量</code></p><p><code>@property float instanceAlphaOffset; </code><code>// 复制层透明度偏移量</code></p><p><code>@end</code></p><p>属性虽少，变化很大，主要是于核心动画的强强联合，他就有无限的可能性，三种效果，您上眼：</p><p>NO.1：深夜电台广播</p><p><code>-(void)lineWave{</code></p><p><code></code><code>CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</code></p><p><code></code><code>replicatorLayer.bounds = self.view.frame;</code></p><p><code></code><code>replicatorLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:replicatorLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 10, 40);</code></p><p><code></code><code>layer.position = CGPointMake(50, self.view.center.y);</code></p><p><code></code><code>[replicatorLayer addSublayer:layer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CABasicAnimation *basicAni = [CABasicAnimation animationWithKeyPath:@</code><code>"transform.scale.y"</code><code>];</code></p><p><code></code><code>basicAni.toValue = @(0.1);</code></p><p><code></code><code>basicAni.duration = 0.3;</code></p><p><code></code><code>basicAni.autoreverses = YES;</code></p><p><code></code><code>basicAni.repeatCount = NSIntegerMax;</code></p><p><code></code><code>[layer addAnimation:basicAni forKey:@</code><code>"layerPosition"</code><code>];</code></p><p><code></code><code>replicatorLayer.instanceCount = 8;</code></p><p><code></code><code>CATransform3D transform = CATransform3DIdentity;</code></p><p><code></code><code>transform = CATransform3DTranslate(transform, 40, 0, 0);</code></p><p><code></code><code>replicatorLayer.instanceTransform = transform;</code></p><p><code></code><code>replicatorLayer.instanceDelay = 0.3;</code></p><p><code>}</code></p><p>运行结果：</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/320c0000bb013503c633></p><p>NO. 2：催眠等待小圈圈</p><p><code>-(void)lineRoundRoll{</code></p><p><code></code><code>CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</code></p><p><code></code><code>replicatorLayer.bounds = self.view.frame;</code></p><p><code></code><code>replicatorLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:replicatorLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 20;</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 40, 40);</code></p><p><code></code><code>layer.position = CGPointMake(50, self.view.center.y);</code></p><p><code></code><code>[replicatorLayer addSublayer:layer];</code></p><p><code></code><code>layer.transform = CATransform3DMakeScale(0.01, 0.01, 0.01);</code></p><p><code></code><code>//</code></p><p><code></code><code>CABasicAnimation *basicAni = [CABasicAnimation animationWithKeyPath:@</code><code>"transform.scale"</code><code>];</code></p><p><code></code><code>basicAni.fromValue = @(1);</code></p><p><code></code><code>basicAni.toValue = @(0.1);</code></p><p><code></code><code>basicAni.duration = 0.75;</code></p><p><code></code><code>basicAni.repeatCount = NSIntegerMax;</code></p><p><code></code><code>[layer addAnimation:basicAni forKey:@</code><code>"layerPosition"</code><code>];</code></p><p><code></code><code>replicatorLayer.instanceCount = 15;</code></p><p><code></code><code>replicatorLayer.preservesDepth = YES;</code></p><p><code></code><code>CATransform3D transform = CATransform3DIdentity;</code></p><p><code></code><code>transform = CATransform3DRotate(transform, M_PI * 2 / 15.0, 0, 0, 1);</code></p><p><code></code><code>replicatorLayer.instanceTransform = transform;</code></p><p><code></code><code>replicatorLayer.instanceDelay = 0.05;</code></p><p><code></code><code>replicatorLayer.instanceAlphaOffset = -1.0 / 15.0;</code></p><p><code></code><code>//replicatorLayer.instanceBlueOffset = 1.0 / 15;</code></p><p><code></code><code>//replicatorLayer.instanceColor = [UIColor redColor].CGColor;</code></p><p><code>}</code></p><p>运行结果：</p><p>NO.3：路径跟随</p><p><code>-(void)followPathLayer{</code></p><p><code></code><code>UIBezierPath *path = [self followPath];</code></p><p><code></code><code>//</code></p><p><code></code><code>CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];</code></p><p><code></code><code>replicatorLayer.bounds = self.view.frame;</code></p><p><code></code><code>replicatorLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:replicatorLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CALayer *layer = [CALayer layer];</code></p><p><code></code><code>layer.backgroundColor = [UIColor redColor].CGColor;</code></p><p><code></code><code>layer.cornerRadius = 5;</code></p><p><code></code><code>layer.bounds = CGRectMake(0, 0, 10, 10);</code></p><p><code></code><code>layer.position = CGPointMake(20, self.view.center.y);</code></p><p><code></code><code>[replicatorLayer addSublayer:layer];</code></p><p><code></code><code>//</code></p><p><code></code><code>CAKeyframeAnimation *basicAni = [CAKeyframeAnimation animationWithKeyPath:@</code><code>"position"</code><code>];</code></p><p><code></code><code>basicAni.path = path.CGPath;</code></p><p><code></code><code>basicAni.duration = 3;</code></p><p><code></code><code>basicAni.repeatCount = NSIntegerMax;</code></p><p><code></code><code>[layer addAnimation:basicAni forKey:@</code><code>"layerPosition"</code><code>];</code></p><p><code></code><code>//</code></p><p><code></code><code>replicatorLayer.instanceCount = 15;</code></p><p><code></code><code>replicatorLayer.instanceDelay = 0.3;</code></p><p><code>}</code></p><p><code>-(UIBezierPath*)followPath{</code></p><p><code></code><code>//CAShapeLayer *shapeLayer = [CAShapeLayer layer];</code></p><p><code></code><code>UIBezierPath *path = [UIBezierPath bezierPath];</code></p><p><code></code><code>[path moveToPoint:CGPointMake(20, self.view.center.y)];</code></p><p><code></code><code>[path addCurveToPoint:CGPointMake(self.view.bounds.size.width - 20, self.view.center.y) controlPoint1:CGPointMake(130, self.view.center.y - 100) controlPoint2:CGPointMake(240, self.view.center.y + 100)];</code></p><p><code></code><code>[path closePath];</code></p><p><code></code><code>//shapeLayer.path = path.CGPath;</code></p><p><code></code><code>//shapeLayer.lineWidth = 5;</code></p><p><code></code><code>//shapeLayer.strokeColor = [UIColor grayColor].CGColor;</code></p><p><code></code><code>//shapeLayer.fillColor = [UIColor clearColor].CGColor;</code></p><p><code></code><code>//[self.view.layer addSublayer:shapeLayer];</code></p><p><code></code><code>return</code> <code>path;</code></p><p><code>}</code></p><p>运行结果：</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/32130002934cf1c3fb6d></p><p>这几个效果只是提供几个思路，抛砖引玉啦。（这鬼录屏卡帧加模糊，大家将就着看。)</p><p><strong>CAScrollLayer</strong></p><p>一看到这个你一定想到了UIScrollView，其实它们并没有什么卵关系，并且我个人觉得这个东西好像没有太大的用处。首先，他没有提供有关边界的相关思路，另外，也不能响应交互。只有一下滚到这，滚到那的方法。</p><p>同样我们可以看到在这个文件下，还有个CALayer的CALayerScrolling的分类，不要以为它给CALayer添加了可滑动的方法，其实只是查找第一个可用的CAScrollLayer，并将制定点或者指定区域滚动到可视范围。</p><p>不过为了看一下它的效果，使它响应时间，我们可以用UIView的子类来自己写一个简单的ScrollView：</p><p><code>//</code></p><p><code>// YSScrollView.m</code></p><p><code>// CAScrollLayerDemo</code></p><p><code>//</code></p><p><code>// Created by ys on 2017/3/13.</code></p><p><code>// Copyright ? 2017年 ys. All rights reserved.</code></p><p><code>//</code></p><p><code>#import "YSScrollView.h"</code></p><p><code>@implementation YSScrollView</code></p><p><code>+ (Class)layerClass</code></p><p><code>{</code></p><p><code></code><code>return</code> <code>[CAScrollLayer class];</code></p><p><code>}</code></p><p><code>- (void)setUp</code></p><p><code>{</code></p><p><code></code><code>self.layer.masksToBounds = YES;</code></p><p><code></code><code>//</code></p><p><code></code><code>UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panAction:)];</code></p><p><code></code><code>[self addGestureRecognizer:panGes];</code></p><p><code>}</code></p><p><code>- (id)initWithFrame:(CGRect)frame</code></p><p><code>{</code></p><p><code></code><code>if</code> <code>((self = [</code><code>super</code> <code>initWithFrame:frame])) {</code></p><p><code></code><code>[self setUp];</code></p><p><code></code><code>}</code></p><p><code></code><code>return</code> <code>self;</code></p><p><code>}</code></p><p><code>- (void)panAction:(UIPanGestureRecognizer *)pan</code></p><p><code>{</code></p><p><code></code><code>CGPoint offset = self.bounds.origin;</code></p><p><code></code><code>offset.x -= [pan translationInView:self].x;</code></p><p><code></code><code>offset.y -= [pan translationInView:self].y;</code></p><p><code></code><code>//</code></p><p><code></code><code>[(CAScrollLayer *)self.layer scrollToPoint:offset];</code></p><p><code></code><code>//</code></p><p><code></code><code>[pan setTranslation:CGPointZero inView:self];</code></p><p><code>}</code></p><p><code>@end</code></p><p><code>然后调用加载一张大图：</code></p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>YSScrollView *ysSView = [[YSScrollView alloc] initWithFrame:self.view.bounds];</code></p><p><code></code><code>UIImageView* imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 700, 1040)];</code></p><p><code></code><code>imageView.image = [UIImage imageNamed:@</code><code>"0101010.jpg"</code><code>];</code></p><p><code></code><code>[self.view addSubview:ysSView];</code></p><p><code></code><code>[ysSView addSubview:imageView];</code></p><p><code>}</code></p><p>运行结果：</p><p>我们发现，其实他并没有滑动区域的限制，本人才疏学浅，望高人指点什么时候用这个东西。</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/321200046199b2f9e67e></p><p>CATiledLayer</p><p>一个大神必备的Layer子类，为节省内存渲染开销提供了途径。比如我们要去加载一个世界地图，精确到你们村的那种，如果全部一次性加载到内存中，这无疑是吃不消的，所以我们可以把地图一片片切开，然后按部分加载，大家联想一下地图应用，应该就知道大致是什么效果。我们直接上代码：</p><p><code>#import "ViewController.h"</code></p><p><code>@interface ViewController ()</code></p><p><code>@property (nonatomic, strong) UIScrollView *scrollView;</code></p><p><code>@end</code></p><p><code>@implementation ViewController</code></p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>//</code></p><p><code></code><code>CATiledLayer *tileLayer = [CATiledLayer layer];</code></p><p><code></code><code>tileLayer.frame = CGRectMake(0, 0, self.view.frame.size.width * 4, self.view.frame.size.height * 4);</code></p><p><code></code><code>tileLayer.tileSize = self.view.frame.size;</code></p><p><code></code><code>tileLayer.delegate = self;</code></p><p><code></code><code>//</code></p><p><code></code><code>self.scrollView = [[UIScrollView alloc] initWithFrame:self.view.bounds];</code></p><p><code></code><code>[self.view addSubview:_scrollView];</code></p><p><code></code><code>self.scrollView.contentSize = tileLayer.frame.size;</code></p><p><code></code><code>[self.scrollView.layer addSublayer:tileLayer];</code></p><p><code></code><code>//</code></p><p><code></code><code>[tileLayer setNeedsDisplay];</code></p><p><code>}</code></p><p><code>-(void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx{</code></p><p><code></code><code>CGRect bounds = CGContextGetClipBoundingBox(ctx);</code></p><p><code></code><code>NSInteger x = floor(bounds.origin.x / layer.tileSize.width);</code></p><p><code></code><code>NSInteger y = floor(bounds.origin.y / layer.tileSize.height);</code></p><p><code></code><code>//</code></p><p><code></code><code>NSString *imageName = [NSString stringWithFormat: @</code><code>"image_%@_%@"</code><code>, @(x), @(y)];</code></p><p><code></code><code>NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@</code><code>"jpg"</code><code>];</code></p><p><code></code><code>UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];</code></p><p><code></code><code>//</code></p><p><code></code><code>UIGraphicsPushContext(ctx);</code></p><p><code></code><code>[tileImage drawInRect:bounds];</code></p><p><code></code><code>UIGraphicsPopContext();</code></p><p><code>}</code></p><p><code>- (void)didReceiveMemoryWarning {</code></p><p><code></code><code>[</code><code>super</code> <code>didReceiveMemoryWarning];</code></p><p><code></code><code>// Dispose of any resources that can be recreated.</code></p><p><code>}</code></p><p>@end</p><p>运行结果：</p><p>其实新加载的图像碎片都是淡入到界面的（万恶的录屏软件，根本看不出来）。这是系统自己带的默认效果，你可以通过调节fadeDuration属性来修改改淡入动画的时长。</p><p><strong>CATextLayer</strong></p><p>我们还是从系统提供的API入手：</p><p><code>@property(nullable, copy) id string; </code><code>//显示内容</code></p><p><code>@property(nullable) CFTypeRef font; </code><code>//字体</code></p><p><code>@property CGFloat fontSize; </code><code>//字号</code></p><p><code>@property(nullable) CGColorRef foregroundColor; </code><code>//文字颜色</code></p><p><code>@property(getter=isWrapped) BOOL wrapped;</code><code>//是否自适应layer的bounds的大小</code></p><p><code>@property(copy) NSString *truncationMode;</code><code>//文字省略方式，其实就是显示不下时省略号的位置</code></p><p><code>@property(copy) NSString *alignmentMode;</code><code>// 对齐方式</code></p><p>我们来用它显示一段文字，你可以自由修改一下它的属性来熟悉每个属性的作用：</p><p><code>- (void)viewDidLoad {</code></p><p><code></code><code>[</code><code>super</code> <code>viewDidLoad];</code></p><p><code></code><code>// Do any additional setup after loading the view, typically from a nib.</code></p><p><code></code><code>//</code></p><p><code></code><code>CATextLayer *textLayer = [CATextLayer layer];</code></p><p><code></code><code>textLayer.bounds = CGRectMake(0, 0, 200, 200);</code></p><p><code></code><code>textLayer.position = self.view.center;</code></p><p><code></code><code>[self.view.layer addSublayer:textLayer];</code></p><p><code></code><code>textLayer.foregroundColor = [UIColor blackColor].CGColor;</code></p><p><code></code><code>textLayer.alignmentMode = kCAAlignmentLeft;</code></p><p><code></code><code>textLayer.wrapped = YES;</code></p><p><code></code><code>//以Retina方式来渲染，防止画出来的文本模糊</code></p><p><code></code><code>textLayer.contentsScale = [UIScreen mainScreen].scale;</code></p><p><code></code><code>textLayer.truncationMode = kCATruncationEnd;</code></p><p><code></code><code>UIFont *font = [UIFont systemFontOfSize:15];</code></p><p><code></code><code>CFStringRef fontName = (__bridge CFStringRef)font.fontName;</code></p><p><code></code><code>CGFontRef fontRef = CGFontCreateWithFontName(fontName);</code></p><p><code></code><code>textLayer.font = fontRef;</code></p><p><code></code><code>textLayer.fontSize = font.pointSize;</code></p><p><code></code><code>CGFontRelease(fontRef);</code></p><p><code></code><code>NSString *text = @</code><code>"Age has reached the end of the beginning of a word. May be guilty in his seems to passing a lot of different life became the appearance of the same day; May be back in the past, to oneself the paranoid weird belief disillusionment, these days, my mind has been very messy, in my mind constantly. Always feel oneself should go to do something, or write something. Twenty years of life trajectory deeply shallow, suddenly feel something, do it."</code><code>;</code></p><p><code></code><code>textLayer.string = text;</code></p><p><code>}</code></p><p>运行结果：</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/32130002934bdf39797d></p><p><strong>CAEAGLLayer，AVPlayerLayer</strong></p><p>CAEAGLLayer看起来就很高大上，其实真的挺高大上的，没有OpenGL知识基础的很难理解更不用说使用了，哪天，等我学会freeStyle，我唱给你听，呦，呦。（你写代码有freeStyle吗？）</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/322d00042e7740b57f57></p><p>AVPlayerLayer它属于AVFoundation框架，不用怀疑，它就是用来播放视频的，+ (AVPlayerLayer *)playerLayerWithPlayer:(nullable AVPlayer *)player;它的初始化依赖于AVPlayer，当然，它既然是CALayer的子类，我们就可以对它进行酷炫的效果变换，同样也克服了系统提供的播放器由于高度的封装性， 使得自定义播放器变的很难的问题。改天，你有需求，我有时间，不如我们写一个播放器啊。</p><p><img alt=来看看CALayer那些牛逼的子类 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/32120004619be2ebaf72></p><p><strong>总结</strong></p><p>CALayer的所有子类都说完了，希望在一定的程度上能给你的开发带来方便，仅此而已，我们下期再见。</p><p>刚才说到的播放器的需求大概应该必需就是这样的！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'CALayer','子类','看看'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>