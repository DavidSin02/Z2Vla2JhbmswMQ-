<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>典型算法思想与应用8｜回溯法与分书问题 | 极客快訊</title><meta property="og:title" content="典型算法思想与应用8｜回溯法与分书问题 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/22cf0000774f33967078"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e7e7e7a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e7e7e7a.html><meta property="article:published_time" content="2020-10-29T21:04:52+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:52+08:00"><meta name=Keywords content><meta name=description content="典型算法思想与应用8｜回溯法与分书问题"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e7e7e7a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>典型算法思想与应用8｜回溯法与分书问题</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>回溯法也叫试探法，试探法的处事方式比较委婉，它先暂时放弃关于问题规模大小的限制，并将问题的候选解按某种顺序逐一进行枚举和检验。当发现当前候选解不可能是正确的解时，就选择下一个候选解。如果当前候选解除了不满足问题规模要求外能够满足所有其他要求时，则继续扩大当前候选解的规模，并继续试探。如果当前候选解满足包括问题规模在内的所有要求时，该候选解就是问题的一个解。在试探算法中，放弃当前候选解，并继续寻找下一个候选解的过程称为回溯。扩大当前候选解的规模，并继续试探的过程称为向前试探。</p><h1 class=pgc-h-arrow-right>1 基本概念</h1><p>回溯算法实际上一个<strong>类似枚举</strong>的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>回溯法是一种<strong>选优搜索</strong>法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“<strong>通用解题方法</strong>”的美称。</p><h1 class=pgc-h-arrow-right>2 基本思想</h1><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则<strong>逐层向其祖先结点回溯</strong>。</p><p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><h1 class=pgc-h-arrow-right>3 解题步骤</h1><p>① 针对所给问题，确定问题的解空间，问题的解空间应至少包含问题的一个（最优）解；</p><p>② 确定易于搜索的解空间结构，确定结点的扩展搜索规则；</p><p>③ 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p><p>试探法为了求得问题的正确解，会先委婉地试探某一种可能的情况。在进行试探的过程中，一旦发现原来选择的假设情况是不正确的，立即会自觉地退回一步重新选择，然后继续向前试探，如此这般反复进行，直至得到解或证明无解时才死心。</p><h1 class=pgc-h-arrow-right>4 算法框架</h1><p>（1）问题框架</p><p>设问题的解是一个n维向量(a1,a2,………,an)，约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</p><p>（2）非递归回溯框架</p><pre><code>int a[n],i;	初始化数组a[];	i = 1;	while(i&gt;0(有路可走) and (未达到目标)) //还未回溯到头	{	    if(i &gt; n) //搜索到叶结点	    {	        搜索到一个解，输出；	    }	    else //处理第i个元素	    {	        a[i]第一个可能的值；	        while(a[i]在不满足约束条件且在搜索空间内)	        {	            a[i]下一个可能的值；	        }	        if(a[i]在搜索空间内)	        {	            标识占用的资源；	            i = i+1; //扩展下一个结点	        }	        else	        {	            清理所占的状态空间； //回溯	            i = i–1;	        }	    }}	</code></pre><p>（3）递归的算法框架</p><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p><pre><code>int a[n];	try(int i)	{	    if(i&gt;n)	        输出结果;	    else	    {	        for(j =下界; j &lt;= 上界; j=j+1) //枚举i所有可能的路径	        {	            if(fun(j)) //满足限界函数和约束条件	            {	                a[i] = j;	                ... //其他操作	                try(i+1);	                回溯前的清理工作（如a[i]置空值等）;	            }	        }	    }	}	</code></pre><h1 class=pgc-h-arrow-right>5 典型问题应用：分书问题</h1><p>有编号为0，1，2，3，4的5本书，准备分给5个人A，B，C，D，E，写一个程序，输出所有皆大欢喜的分书方案。</p><p>每个人的阅读兴趣用一个二维数组like描述：</p><p>Like[i][j] = true i喜欢书j</p><p>Like[i][j] = false i不喜欢书j</p><div class=pgc-img><img alt=典型算法思想与应用8｜回溯法与分书问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/22cf0000774f33967078><p class=pgc-img-caption></p></div><p>设计一个函数trynext(int i)给第i个人分书。</p><p>用一个一维数组take表示某本书分给了某人。take[j]=i+1;//把第j本书分配给第i个人</p><p>依次尝试把书j分给人i。</p><p>如果第i个人不喜欢第j本书，则尝试下一本书，如果喜欢，并且第j本书尚未分配，则把书j分配给i。</p><p>如果i是最后一个人，则方案数加1，输出该方案。否则调用trynext(i+1)为第i+1个人分书。</p><p>如果对第i个人枚举了他喜欢的所有的书，都没有找到可行的方案，那就回到前一个状态i-1，让i-1把分到的书退回去，重新找喜欢的书，再递归调用函数，寻找可行的方案。</p><p>代码：</p><div class=pgc-img><img alt=典型算法思想与应用8｜回溯法与分书问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d7a555608034594874aa2f0e6f74853><p class=pgc-img-caption></p></div><p>运行结果：</p><pre><code>分配方案1:书本0→B书本1→C书本2→A书本3→D书本4→E分配方案2:书本0→B书本1→E书本2→A书本3→D书本4→C分配方案3:书本0→D书本1→B书本2→C书本3→A书本4→E分配方案4:书本0→D书本1→E书本2→C书本3→A书本4→B</code></pre><p>递归与回溯就一步之遥，但正因为这一步，导致的是一个解和全部解的区别（如果不考虑回溯，也就是把倒数第四行代码take[j]=0;去掉，则可得到单一解决方案）。</p><p>这就是递归函数后面有没有代码可执行的区别，如果后面（回归阶段）没有代码可执行，称为尾递归，如果后面（回归阶段）有代码可执行，称为非尾递归。</p><p>附代码：</p><pre><code>#include &lt;iostream&gt;using namespace std;int like[5][5]={    {0,0,1,1,0},    {1,1,0,0,1},    {0,1,1,0,1},    {1,0,0,1,0},    {0,1,0,0,1}};int take[5]={0,0,0,0,0};  // 记录每一本书的分配情况int n = 0;                // n表示分书方案数void trynext(int i);int main(){    trynext(0);    cin.get();    return 0;}void trynext(int i)        // 对第 i 个人进行分配{    for(int j=0;j&lt;5;j++)   // 穷举    {        if(like[i][j]&amp;&amp;take[j]==0)        {            take[j]=i+1;// 把第j本书分配给第i个人            if(i==4)    // 第5个人分配结束，也即所有的书已经分配完毕，                        // 可以将方案进行输出            {                n++;                cout&lt;&lt;"分配方案"&lt;&lt;n&lt;&lt;":"&lt;&lt;endl;                for(int k=0;k&lt;5;k++)                    cout&lt;&lt;"书本"&lt;&lt;k&lt;&lt;"→"&lt;&lt;static_cast&lt;char&gt;(take[k]+'A'-1)&lt;&lt;endl;                cout&lt;&lt;endl;            }            else                trynext(i+1);    // 递归，对下一个人进行分配，直到形成一种方案            take[j]=0;           // 回溯，以j为回溯点，寻找下一种方案        }    }}</code></pre><p>－End－</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'应用','分书','问题'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>