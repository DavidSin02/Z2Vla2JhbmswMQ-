<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试官问我什么是「栈」，我随手画了10张图来解释 | 极客快訊</title><meta property="og:title" content="面试官问我什么是「栈」，我随手画了10张图来解释 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/0277ae9951df4d8483fc21ce4d8d17fe"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e803c28.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e803c28.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e803c28.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e803c28.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e803c28.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e803c28.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e803c28.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e803c28.html><meta property="article:published_time" content="2020-10-29T21:05:31+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:31+08:00"><meta name=Keywords content><meta name=description content="面试官问我什么是「栈」，我随手画了10张图来解释"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e803c28.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试官问我什么是「栈」，我随手画了10张图来解释</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br>ID：技术让梦想更伟大</p><p>作者:李肖遥</p><h1 class=pgc-h-arrow-right>栈的概念</h1><p>栈（stack）是限定仅在表的一端进行操作的数据结构，且栈是一种先进后出的数据结构，允许操作的一端称为<strong>栈顶</strong>，不允许操作的称为<strong>栈底</strong>，如下图所示：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0277ae9951df4d8483fc21ce4d8d17fe><p class=pgc-img-caption></p></div><p>之前我们讲到了链表，我们只能够对其链表的表尾结点进行操作，并且只能进行插入一个新的结点与删除最末尾的这个结点两个操作，而这样<strong>强限制性的‘链表’</strong>，就是我们所说的<strong>栈</strong>。</p><p>就像是一个死胡同一样，只有一个出口，如图所示，有个概念：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0c008533db64466cb667a929ba4056a5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>栈的结点设计</h1><p>栈分为<strong>数组栈</strong>和<strong>链表栈</strong>，其区别如下：</p><ul><li>数组栈使用数组进行功能的模拟，实现较为快速和便利；</li><li>链表栈使用链表的思路去设计，实现相比较说较为麻烦，但是其稳定，且不易出错；</li></ul><p>在链表栈中又分为<strong>静态链表栈和动态链表栈</strong>，其区别如下：</p><ul><li>静态链表栈给定栈的空间大小，不允许超过存储超过给定数据大小的元素；</li><li>动态栈使用的是自动创建空间的方法进行创建，只要符合机器的硬件要求以及编译器的控制，其理论上是极大的。</li></ul><h1 class=pgc-h-arrow-right>数组栈</h1><p>其实际就是用一段连续的存储空间来存储栈中的数据元素，有以下特点：</p><ol start=1><li>元素所占的存储空间必须连续，这里的连续是指的逻辑连续，而不是物理连续。</li><li>元素在存储空间的位置是按逻辑顺序存放的</li></ol><p>我们来举例说明，鉴于C语言数组下标都是0开始，并且栈的使用需要的空间大小难以估计，所以初始化空栈的时候，不应该设定栈的最大容量。</p><p>我们先为栈设定一个基本容量，在应用过STACK_程当中，当栈的空间不够用时，再逐渐扩大。</p><p>设定2个常量，STACK_INIT_SIZE(存储空间初始化分配量)和STACK_INCREMENT(存储空间分配增量),宏定义如下</p><pre><code>#define STACK_INIT_SIZE 1000 //数值可以根据实际情况确定#define STACK_INCREMENT 10   //数值可以根据实际情况确定</code></pre><p>栈的定义如下</p><pre><code>typedef struct      {    void *base;     void *top;    int stackSize;} SqSTACK;</code></pre><ul><li>base 表示栈底指针</li><li>top 表示栈顶指针</li><li>stackSize 表示栈当前可以使用的最大容量</li></ul><p>若base的值是NULL，表示栈结构不存在;top初始值指向栈底，即top = base;</p><p>每当插入新的元素时，指针top就增1，反之删除就减1，<strong>非空栈中的栈顶指针</strong>始终在<strong>栈顶元素的下一个指针</strong>上面。</p><p>数据元素和栈顶指针的关系如下图所示：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67dcec851c15407cb1b6e4f596fc7f20><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>链表栈</h1><p>我们以链表栈的动态链表栈为例子，进行栈的设计。</p><p>首先是栈的结点，设计出两个结构体，一个结构体Node表示结点，其中包含有一个data域和next指针，如图所示：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/842c1c4e912f456c926dc1e49631a0d3><p class=pgc-img-caption></p></div><p>Node</p><p>其中data表示数据，next指针表示下一个的指针，其指向下一个结点，通过next指针将各个结点链接。</p><p>接下来是我们设计的重点，为这个进行限制性的设计，我们需要额外添加一个结构体，其包括了一个<strong>永远指向栈头的指针top</strong>和<strong>一个计数器count</strong>记录元素个数。</p><p><strong>其主要功效</strong>就是设定<strong>允许操作元素的指针</strong>以及<strong>确定栈何时为空</strong>，如图所示：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/036f1a8b31d349eab5b09acf20814f1c><p class=pgc-img-caption></p></div><p>Stack</p><p>这里我采用的是<strong>top和count组合的方法</strong>。其代码可以表示为：</p><pre><code>//栈的结点设计//单个结点设计，数据和下一个指针typedef struct node     {    int data;     struct node *next;} Node;</code></pre><p>利用上面的结点创建栈，分为指向头结点的top指针和计数用的count</p><pre><code>typedef struct stack    {    Node *top;    int count;} Link_Stack;</code></pre><h1 class=pgc-h-arrow-right>栈的基本操作—入栈（压栈）</h1><p>入栈的基本顺序可以用以下图所示：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7d05972cc52a4950bc9746649cd993c3><p class=pgc-img-caption></p></div><p>入栈(push)操作时，我们只需要找到top所指向的空间，创建一个新的结点，将<strong>新的结点的next指针</strong>指向<strong>top指针指向的空间</strong>，再将top指针转移，并且指向新的结点，这就是是<strong>入栈操作</strong>。</p><p>其代码可以表示为：</p><pre><code>//入栈 pushLink_Stack *Push_stack(Link_Stack *p, int elem){    if (p == NULL)        return NULL;    Node *temp;    temp=(Node*)malloc(sizeof(Node));    //temp = new Node;    temp-&gt;data = elem;    temp-&gt;next = p-&gt;top;    p-&gt;top = temp;    p-&gt;count++;    return p;}</code></pre><h1 class=pgc-h-arrow-right>栈的基本操作—出栈</h1><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dad143ae5b6444149f04445fdd68ce9b><p class=pgc-img-caption></p></div><p>出栈（pop）操作，是在栈不为空的情况下，重复说一次，<strong>一定要进行判空操作</strong>，将栈顶的元素删除，同时top指针，next向下进行移动即可的操作。</p><p>其代码可以表示为：</p><pre><code>//出栈 popLink_Stack *Pop_stack(Link_Stack *p){    Node *temp;    temp = p-&gt;top;    if (p-&gt;top == NULL)    {        printf("错误：栈为空");        return p;    }    else    {        p-&gt;top = p-&gt;top-&gt;next;        free(temp);        //delete temp;        p-&gt;count--;        return p;    }}</code></pre><h1 class=pgc-h-arrow-right>栈的基本操作—遍历</h1><p>这个就很常见了，也是我们调试必须的手段。</p><p>栈的遍历相对而言比较复杂，由于栈的特殊性质，其只允许在一端进行操作，所以<strong>遍历操作操作永远都是逆序的</strong>。</p><p>简单一点描述，其过程为，在栈不为空的情况下，一次从栈顶元素向下访问，直到指针指向空（即到栈尾）为结束。</p><p>其代码可以表示为：</p><pre><code>//遍历栈：输出栈中所有元素int show_stack(Link_Stack *p){    Node *temp;    temp = p-&gt;top;    if (p-&gt;top == NULL)    {        printf("");        printf("错误：栈为空");        return 0;    }    while (temp != NULL)    {        printf("%d\t", temp-&gt;data);        temp = temp-&gt;next;    }    printf("\n");    return 0;}</code></pre><h1 class=pgc-h-arrow-right>栈数组与栈链表的代码实现</h1><p>最后呢，我们使用代码来帮助我们了解一下：</p><h1 class=pgc-h-arrow-right>栈数组</h1><p>数组栈是一种更为快速的模拟实现栈的方法，这里我们不多说。</p><p>模拟，就是不采用真实的链表设计，转而采用数组的方式进行<strong>模拟操作</strong>。</p><p>也就是说这是一种仿真类型的操作，其可以快速的帮助我们构建代码，分析过程，相应的实现起来也更加的便捷。</p><p>其代码如下:</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#define maxn 10000 //结点设计typedef struct stack{    int data[maxn];    int top;}stack; //创建stack *init(){    stack *s=(stack *)malloc(sizeof(stack));    if(s==NULL){        printf("分配内存空间失败");        exit(0);    }    memset(s-&gt;data,0,sizeof(s-&gt;data));    //memset操作来自于库文件string.h，其表示将整个空间进行初始化    //不理解可以查阅百度百科https://baike.baidu.com/item/memset/4747579?fr=aladdin    s-&gt;top=0;     //栈的top和bottom均为0（表示为空）    return s;} //入栈pushvoid push(stack *s,int data){    s-&gt;data[s-&gt;top]=data;    s-&gt;top++;} //出栈popvoid pop(stack *s){    if(s-&gt;top!=0){        s-&gt;data[s-&gt;top]=0;  //让其回归0模拟表示未初始化即可        s-&gt;top--;    }} //模拟打印栈中元素void print_stack(stack *s){    for(int n=s-&gt;top-1;n&gt;=0;n--){        printf("%d\t",s-&gt;data[n]);    }    printf("\n");   //习惯性换行} int main(){    stack *s=init();    int input[5]={11,22,33,44,55};  //模拟五个输入数据    for(int i=0;i&lt;5;i++){        push(s,input[i]);    }    print_stack(s);    /////////////    pop(s);    print_stack(s);    return 0;}</code></pre><p>其编译结果如下：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f8851b0b2f294f8495443b8b982fdf59><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>栈链表</h1><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;//栈的结点设计//单个结点设计，数据和下一个指针typedef struct node     {    int data;     struct node *next;} Node;//利用上面的结点创建栈，分为指向头结点的top指针和计数用的counttypedef struct stack    {    Node *top;    int count;} Link_Stack; //创建栈Link_Stack *Creat_stack(){    Link_Stack *p;    //p = new Link_Stack;    p=(Link_Stack*)malloc(sizeof(Link_Stack));    if(p==NULL){        printf("创建失败，即将退出程序");        exit(0);    } else {printf("创建成功\n"); }    p-&gt;count = 0;    p-&gt;top = NULL;    return p;} //入栈 pushLink_Stack *Push_stack(Link_Stack *p, int elem){    if (p == NULL)        return NULL;    Node *temp;    temp=(Node*)malloc(sizeof(Node));    //temp = new Node;    temp-&gt;data = elem;    temp-&gt;next = p-&gt;top;    p-&gt;top = temp;    p-&gt;count++;    return p;} //出栈 popLink_Stack *Pop_stack(Link_Stack *p){    Node *temp;    temp = p-&gt;top;    if (p-&gt;top == NULL)    {        printf("错误：栈为空");        return p;    }    else    {   printf("\npop success");        p-&gt;top = p-&gt;top-&gt;next;        free(temp);        //delete temp;        p-&gt;count--;        return p;    }} //遍历栈：输出栈中所有元素int show_stack(Link_Stack *p){    Node *temp;    temp = p-&gt;top;    if (p-&gt;top == NULL)    {        printf("");        printf("错误：栈为空");        return 0;    }    while (temp != NULL)    {        printf("%d\t", temp-&gt;data);        temp = temp-&gt;next;    }    printf("\n");    return 0;} int main(){ //用主函数测试一下功能 int i;    Link_Stack *p;    p = Creat_stack();    int n = 5;    int input[6] = {10,20,30,40,50,60};    /////////////以依次入栈的方式创建整个栈//////////////    for(i=0;i&lt;n;i++){        Push_stack(p, input[i]);    }    show_stack(p);    ////////////////////出栈///////////////////////    Pop_stack(p);    show_stack(p);    return 0;}</code></pre><p>编译结果如下：</p><div class=pgc-img><img alt=面试官问我什么是「栈」，我随手画了10张图来解释 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f8adfc56de524de3b88c77209c77c7b2><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>关于栈的总结</h1><p>栈-它是一种运算受限的线性表，在数制转换，括号匹配的检验，表达式求值等方面都可以使用，并且较为简便的解决问题。</p><p>今天栈基础就讲到这里，下一期，我们再见！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'面试','官问','什么'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/60d9c491.html alt=面试官问：什么是协议？你会吗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f33f88f61cb40d0bfec0a8818d08eb8 style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/60d9c491.html title=面试官问：什么是协议？你会吗>面试官问：什么是协议？你会吗</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>