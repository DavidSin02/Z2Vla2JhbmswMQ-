<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java工程师成神之路（问题&答案4） | 极客快訊</title><meta property="og:title" content="Java工程师成神之路（问题&答案4） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/9006a749af324eb9bfbb0637d9a0d54f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e884df72.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e884df72.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e884df72.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e884df72.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e884df72.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e884df72.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/e884df72.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/e884df72.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Java工程师成神之路（问题&答案4）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/e884df72.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java工程师成神之路（问题&答案4）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>Collection 和 Collections 区别？</strong></p><p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</p><p>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p><p><strong>Arrays.asList 获得的 List 使用时需要注意什么？</strong></p><p>1、asList 方法的参数必须是对象或者对象数组，而原生数据类型不是对象——这也正是包装类出现的一个主要原因。当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组。</p><p>2、返回一个由指定数组生成的固定大小的 List。</p><div class=pgc-img><img alt=Java工程师成神之路（问题&答案4） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9006a749af324eb9bfbb0637d9a0d54f><p class=pgc-img-caption></p></div><p><strong>Enumeration 和 Iterator 区别？</strong></p><p>Enumeration速度是Iterator的2倍，同时占用更少的内存。但是，Iterator远远比Enumeration安全，因为其他线程不能够修改正在被iterator遍历的集合里面的对象。同时，Iterator允许调用者删除底层集合里面的元素，这对Enumeration来说是不可能的。</p><p>(01) 函数接口不同</p><p>Enumeration 只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。</p><p>Iterator 只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。</p><p>(02) Iterator 支持 fail-fast 机制，而 Enumeration 不支持</p><p>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。</p><p>而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</p><p><strong>fail-fast 和 fail-safe？</strong></p><p>快速失败（fail-fast)和安全失败（fail-safe）是对迭代器而言的。快速失败：当在迭代一个集合的时候，如果有另外一个线程在修改这个集合，就会抛出ConcurrentModification异常，java.util下都是快速失败。安全失败：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。在java.util.concurrent下都是安全失败</p><p><strong>介绍下concurrent 并发包？</strong></p><p><strong>BlockingQueue</strong></p><p>此接口是一个线程安全的 存取实例的队列。</p><p><strong>使用场景</strong></p><p>BlockingQueue通常用于一个线程生产对象，而另外一个线程消费这些对象的场景。</p><p><strong>注意事项</strong>：</p><p>此队列是有限的,如果队列到达临界点，Thread1就会阻塞，直到Thread2从队列中拿走一个对象。</p><p>若果队列是空的，Thread2会阻塞，直到Thread1把一个对象丢进队列。</p><p>相关方法</p><p>BlockingQueue中包含了如下操作方法：</p><p>Throws Exception Special Value Blocks Times Out</p><p>Insert add(o) offer(o) put(o) offer(o, timeout, timeunit)</p><p>Remove remove(o) poll() take() poll(timeout, timeunit)</p><p>Examine element() peek()</p><p>名词解释：</p><p>Throws Exception: 如果试图的操作无法立即执行，抛一个异常。</p><p>Special Value: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</p><p>Blocks: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</p><p>Times Out: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</p><p><strong>注意事项</strong>：</p><p>无法插入 null，否则会抛出一个 NullPointerException。</p><p>队列这种数据结构，导致除了获取开始和结尾位置的其他对象的效率都不高，虽然可通过remove(o)来移除任一对象。</p><p>实现类</p><p>因为是一个接口，所以我们必须使用一个实现类来使用它，有如下实现类：</p><p><strong>ArrayBlockingQueue</strong>： 数组阻塞队列</p><p><strong>DelayQueue</strong>： 延迟队列</p><p><strong>LinkedBlockingQueue</strong>： 链阻塞队列</p><p><strong>PriorityBlockingQueue</strong>： 具有优先级的阻塞队列</p><p><strong>SynchronousQueue</strong>： 同步队列</p><p><strong>ArrayBlockingQueue</strong> 是一个有界的阻塞队列内部实现是将对象放到一个数组里。数组有个特性：一旦初始化，大小就无法修改。因此无法修改ArrayBlockingQueue初始化时的上限。</p><p>ArrayBlockingQueue 内部以 FIFO(先进先出)的顺序对元素进行存储。队列中的头元素在所有元素之中是放入时间最久的那个，而尾元素则是最短的那个。</p><p><strong>DelayQueue </strong>对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现 java.util.concurrent.Delayed 接口:</p><pre>public interface Delayed extends Comparable&lt;Delayed&lt; { public long getDelay(TimeUnit timeUnit); // 返回将要延迟的时间段}</pre><p>在每个元素的 getDelay() 方法返回的值的时间段之后才释放掉该元素。如果返回的是 0 或者负值，延迟将被认为过期，该元素将会在 DelayQueue 的下一次 take 被调用的时候被释放掉。</p><p>Delayed 接口也继承了 java.lang.Comparable 接口，Delayed对象之间可以进行对比。这对DelayQueue 队列中的元素进行排序时有用，因此它们可以根据过期时间进行有序释放。</p><p><strong>LinkedBlockingQueue</strong>内部以一个链式结构(链接节点)对其元素进行存储 。可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。</p><p>内部以 FIFO(先进先出)的顺序对元素进行存储。</p><p><strong>PriorityBlockingQueue</strong>一个无界的并发队列，它使用了和类 java.util.PriorityQueue 一样的排序规则。</p><p>无法向这个队列中插入 null 值。</p><p>插入到 其中的元素必须实现 java.lang.Comparable 接口。</p><p>对于具有相等优先级(compare() == 0)的元素并不强制任何特定行为。</p><p>从一个 PriorityBlockingQueue 获得一个 Iterator 的话，该 Iterator 并不能保证它对元素的遍历是以优先级为序的。</p><div class=pgc-img><img alt=Java工程师成神之路（问题&答案4） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/baeefb9da8c74255a0e22da6586fd796><p class=pgc-img-caption></p></div><p><strong>SynchronousQueue</strong>一个特殊的队列，它的内部同时只能够容纳单个元素。</p><p>如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。</p><p>如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。</p><p><strong>BlockingDeque</strong>此接口表示一个线程安全放入和提取实例的双端队列。</p><p>使用场景</p><p>通常用在一个线程既是生产者又是消费者的时候。</p><p>注意事项</p><p>如果双端队列已满，插入线程将被阻塞，直到一个移除线程从该队列中移出了一个元素。</p><p>如果双端队列为空，移除线程将被阻塞，直到一个插入线程向该队列插入了一个新元素。</p><p>相关方法</p><p>Throws Exception Special Value Blocks Times Out</p><p>Insert addFirst(o) offerFirst(o) putFirst(o) offerFirst(o, timeout, timeunit)</p><p>Remove removeFirst(o) pollFirst(o) takeFirst(o) pollFirst(timeout, timeunit)</p><p>Examine getFirst(o) peekFirst(o)</p><p>Throws Exception Special Value Blocks Times Out</p><p>Insert addLast(o) offerLast(o) putLast(o) offerLast(o, timeout, timeunit)</p><p>Remove removeLast(o) pollLast(o) takeLast(o) pollLast(timeout, timeunit)</p><p>Examine getLast(o) peekLast(o)</p><p>注意事项</p><p>关于方法的处理方式和上节一样。</p><p><strong>BlockingDeque </strong>接口继承自 BlockingQueue 接口，可以用其中定义的方法。</p><p>实现类</p><p>LinkedBlockingDeque ： 链阻塞双端队列</p><p>LinkedBlockingDeque 是一个双端队列，可以从任意一端插入或者抽取元素的队列。</p><p>在它为空的时候，一个试图从中抽取数据的线程将会阻塞，无论该线程是试图从哪一端抽取数据。</p><p><strong>ConcurrentMap</strong></p><p>一个能够对别人的访问(插入和提取)进行并发处理的 java.util.Map接口。</p><p>ConcurrentMap 除了从其父接口 java.util.Map 继承来的方法之外还有一些额外的原子性方法。</p><p>实现类</p><p>因为是接口，必须用实现类来使用它，其实现类为</p><p><strong>ConcurrentHashMap</strong></p><p>ConcurrentHashMap与HashTable比较</p><p>更好的并发性能，在你从中读取对象的时候 ConcurrentHashMap 并不会把整个 Map 锁住，只是把 Map 中正在被写入的部分进行锁定。</p><p>在被遍历的时候，即使是 ConcurrentHashMap 被改动，它也不会抛 ConcurrentModificationException。</p><p>ConcurrentNavigableMap</p><p>一个支持并发访问的 java.util.NavigableMap，它还能让它的子 map 具备并发访问的能力。</p><p>headMap</p><p>headMap(T toKey) 方法返回一个包含了小于给定 toKey 的 key 的子 map。</p><p>tailMap</p><p>tailMap(T fromKey) 方法返回一个包含了不小于给定 fromKey 的 key 的子 map。</p><p>subMap</p><p>subMap() 方法返回原始 map 中，键介于 from(包含) 和 to (不包含) 之间的子 map。</p><p>更多方法</p><p>descendingKeySet()</p><p>descendingMap()</p><p>navigableKeySet()</p><p><strong>CountDownLatch</strong></p><p>CountDownLatch 是一个并发构造，它允许一个或多个线程等待一系列指定操作的完成。</p><p>CountDownLatch 以一个给定的数量初始化。countDown() 每被调用一次，这一数量就减一。</p><p>通过调用 await() 方法之一，线程可以阻塞等待这一数量到达零。</p><p><strong>CyclicBarrier</strong></p><p>CyclicBarrier 类是一种同步机制，它能够对处理一些算法的线程实现同步。</p><p>Exchanger 类表示一种两个线程可以进行互相交换对象的会和点。</p><p>Semaphore 类是一个计数信号量。具备两个主要方法：</p><p>每调用一次 acquire()，一个许可会被调用线程取走。</p><p>每调用一次 release()，一个许可会被返还给信号量。</p><p>Semaphore 用法</p><p>保护一个重要(代码)部分防止一次超过 N 个线程进入。</p><p>在两个线程之间发送信号。</p><p>保护重要部分</p><p>如果你将信号量用于保护一个重要部分，试图进入这一部分的代码通常会首先尝试获得一个许可，然后才能进入重要部分(代码块)，执行完之后，再把许可释放掉。</p><pre>Semaphore semaphore = new Semaphore(1); //critical section semaphore.acquire(); ... semaphore.release();</pre><p>在线程之间发送信号</p><p>如果你将一个信号量用于在两个线程之间传送信号，通常你应该用一个线程调用 acquire() 方法，而另一个线程调用 release() 方法。</p><p>如果没有可用的许可，acquire() 调用将会阻塞，直到一个许可被另一个线程释放出来。</p><p>如果无法往信号量释放更多许可时，一个 release() 调用也会阻塞。</p><p>公平性</p><p>无法担保掉第一个调用 acquire() 的线程会是第一个获得一个许可的线程。</p><p>可以通过如下来强制公平：</p><pre>Semaphore semaphore = new Semaphore(1, true);</pre><p>需要注意，强制公平会影响到并发性能，建议不使用。</p><p>欢迎与作者大伟交流互动，获取更多java职场经验，技术干货</p><p>微信公众号请关注：程序秘籍</p><p>今日头条号请关注：程序秘籍</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','师成','神之路'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>