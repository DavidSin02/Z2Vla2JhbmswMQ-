<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验 | 极客快訊</title><meta property="og:title" content="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebbd53b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebbd53b.html><meta property="article:published_time" content="2020-10-29T20:50:02+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:02+08:00"><meta name=Keywords content><meta name=description content="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ebbd53b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1）实验平台：【正点原子】 NANO STM32F103 开发板</strong></p><p><strong>2）摘自《正点原子STM32 F1 开发指南(NANO 板-HAL 库版)》关注官方微信号公众号，获取更多资料：正点原子</strong></p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f><p class=pgc-img-caption>第十三章 定时器中断实验</p></div><p><strong>第十三章 定时器中断实验</strong></p><p>这一章，我们将向大家介绍如何使用 STM32F1 的通用定时器，STM32F1 的定时器功能十分强大，在中容量的 STM32 中有 TIME1 高级定时器，也有 TIME2~TIME4 等通用定时器，在《STM32 参考手册》里面，定时器的介绍占了 1/5 的篇幅，足见其重要性。在本章中，我们将利用 TIM3 的定时器中断来控制 DS1 的翻转，在主函数用 DS0 的翻转来提示程序正在运行。本章，我们选择难度适中的通用定时器来介绍，本章将分为如下几个部分：</p><p>13.1 STM32F1 通用定时器简介</p><p>13.2 硬件设计</p><p>13.3 软件设计</p><p>13.4 下载验证</p><p>13.5 STM32CubeMX 配置定时器更新中断功能</p><p><strong>13.1 STM32 通用定时器简介</strong></p><p>STM32F1 的通用定时器是一个通过可编程预分频器（PSC）驱动的 16 位自动装载计数器（CNT）构成。STM32 的通用定时器可以被用于：测量输入信号的脉冲长度(输入捕获)或者产生输出波形(输出比较和 PWM)等。 使用定时器预分频器和 RCC 时钟控制器预分频器，脉冲长度和波形周期可以在几个微秒到几个毫秒间调整。STM32 的每个通用定时器都是完全独立的，没有互相共享的任何资源。</p><p>STM32F1 的通用 TIMx (TIM2、TIM3、TIM4)定时器功能包括：</p><p>1)16 位向上、向下、向上/向下自动装载计数器（TIMx_CNT）。</p><p>2)16 位可编程(可以实时修改)预分频器(TIMx_PSC)，计数器时钟频率的分频系数为 1～</p><p>65535 之间的任意数值。</p><p>3）4 个独立通道（TIMx_CH1~4），这些通道可以用来作为：</p><p>A．输入捕获</p><p>B．输出比较</p><p>C．PWM 生成(边缘或中间对齐模式)</p><p>D．单脉冲模式输出</p><p>4）可使用外部信号（TIMx_ETR）控制定时器和定时器互连（可以用 1 个定时器控制另外</p><p>一个定时器）的同步电路。</p><p>5）如下事件发生时产生中断/DMA：</p><p>A．更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发)</p><p>B．触发事件(计数器启动、停止、初始化或者由内部/外部触发计数)</p><p>C．输入捕获</p><p>D．输出比较</p><p>E．支持针对定位的增量(正交)编码器和霍尔传感器电路</p><p>F．触发输入作为外部时钟或者按周期的电流管理</p><p>由于 STM32 通用定时器比较复杂，这里我们不再多介绍，请大家直接参考《STM32 参考</p><p>手册》第 253 页，通用定时器一章。为了深入了解 STM32 的通用寄存器，下面我们先介绍一</p><p>下与我们这章的实验密切相关的几个通用定时器的寄存器。</p><p>首先是控制寄存器 1（TIMx_CR1），该寄存器的各位描述如图 13.1.1 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cea3165049db4f8e806cacb7627dc917><p class=pgc-img-caption>图 13.1.1 TIMx_CR1 寄存器各位描述</p></div><p>首先我们来看看 TIMx_CR1 的最低位，也就是计数器使能位，该位必须置 1，才能让定时</p><p>器开始计数。从第 4 位 DIR 可以看出默认的计数方式是向上计数，同时也可以向下计数，第 5,6</p><p>位是设置计数对齐方式的。从第 8 和第 9 位可以看出，我们还可以设置定时器的时钟分频因子</p><p>为 1,2,4。接下来介绍第二个与我们这章密切相关的寄存器：DMA/中断使能寄存器</p><p>（TIMx_DIER）。该寄存器是一个 16 位的寄存器，其各位描述如图 13.1.2 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fe6e3a42d808485ea5af6b025d82e7f9><p class=pgc-img-caption>图 13.1.2 TIMx_ DIER 寄存器各位描述</p></div><p>这里我们同样仅关心它的第 0 位，该位是更新中断允许位，本章用到的是定时器的更新中</p><p>断，所以该位要设置为 1，来允许由于更新事件所产生的中断。</p><p>接下来我们看第三个与我们这章有关的寄存器：预分频寄存器（TIMx_PSC）。该寄存器</p><p>用设置对时钟进行分频，然后提供给计数器，作为计数器的时钟。该寄存器的各位描述如图</p><p>13.1.3 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/dd19a63d29b348c9b6606dcb4987e264><p class=pgc-img-caption>图 13.1.3 TIMx_ PSC 寄存器各位描述</p></div><p>这里，定时器的时钟来源有 4 个：</p><p>1）内部时钟（CK_INT）</p><p>2）外部时钟模式 1：外部输入脚（TIx）</p><p>3）外部时钟模式 2：外部触发输入（ETR）</p><p>4）内部触发输入（ITRx）：使用 A 定时器作为 B 定时器的预分频器（A 为 B 提供时钟）。</p><p>这些时钟，具体选择哪个可以通过 TIMx_SMCR 寄存器的相关位来设置。这里的 CK_INT</p><p>时钟是从 APB1 倍频的来的，除非 APB1 的时钟分频数设置为 1，否则通用定时器 TIMx 的时钟</p><p>是 APB1 时钟的 2 倍，当 APB1 的时钟不分频的时候，通用定时器 TIMx 的时钟就等于 APB1</p><p>的时钟。这里还要注意的就是高级定时器的时钟不是来自 APB1，而是来自 APB2 的。</p><p>这里顺带介绍一下 TIMx_CNT 寄存器，该寄存器是定时器的计数器，该寄存器存储了当前</p><p>定时器的计数值。</p><p>接着我们介绍自动重装载寄存器（TIMx_ARR），该寄存器在物理上实际对应着 2 个寄存</p><p>器。一个是程序员可以直接操作的，另外一个是程序员看不到的，这个看不到的寄存器在</p><p>《STM32 参考手册》里面被叫做影子寄存器。事实上真正起作用的是影子寄存器。根据</p><p>TIMx_CR1 寄存器中 APRE 位的设置：APRE=0 时，预装载寄存器的内容可以随时传送到影子</p><p>寄存器，此时 2 者是连通的；而 APRE=1 时，在每一次更新事件（UEV）时，才把预装在寄存</p><p>器的内容传送到影子寄存器。</p><p>自动重装载寄存器的各位描述如图 13.1.4 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f91ed97afae7469fa9d168a9f0e5b78d><p class=pgc-img-caption>图 13.1.4 TIMx_ ARR 寄存器各位描述</p></div><p>最后，我们要介绍的寄存器是：状态寄存器（TIMx_SR）。该寄存器用来标记当前与定时</p><p>器相关的各种事件/中断是否发生。该寄存器的各位描述如图 13.1.5 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0804dd2540504c4196eaf3ddba2bd52b><p class=pgc-img-caption>图 13.1.5 TIMx_ SR 寄存器各位描述</p></div><p>关于这些位的详细描述，请参考《STM32 参考手册》第 282 页。</p><p>只要对以上几个寄存器进行简单的设置，我们就可以使用通用定时器了，并且可以产生中</p><p>断。</p><p>这一章，我们将使用定时器产生中断，然后在中断服务函数里面翻转 DS1 上的电平，来指</p><p>示定时器中断的产生。接下来我们以通用定时器 TIM3 为实例，来说明要经过哪些步骤，才能</p><p>达到这个要求，并产生中断。这里我们就对每个步骤通过库函数的实现方式来描述。首先要提</p><p>到 的 是 ， 定 时 器 相 关 的 库 函 数 主 要 集 中 在 HAL 库文件 stm32f1xx_hal_tim.h 和</p><p>stm32f1xx_hal_tim.c 文件中。定时器配置步骤如下：</p><p><strong>1）TIM3 时钟使能。</strong></p><p>HAL 中定时器使能是通过宏定义标识符来实现对相关寄存器操作的，方法如下：</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 时钟</p><p><strong>2）初始化定时器参数,设置自动重装值，分频系数，计数方式等。</strong></p><p>在 HAL 库中，定时器的初始化参数是通过初始化函数 HAL_TIM_Base_Init 实现的：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim);</p><p>该函数只有一个入口参数，就是 TIM_HandleTypeDef 类型结构体指针，结构体类型为下面</p><p>我们看看这个结构体的定义：</p><p>typedef struct</p><p>{</p><p>TIM_TypeDef *Instance;</p><p>TIM_Base_InitTypeDef Init;</p><p>HAL_TIM_ActiveChannel Channel;</p><p>DMA_HandleTypeDef *hdma[7U];</p><p>HAL_LockTypeDef Lock;</p><p>__IO HAL_TIM_StateTypeDef State;</p><p>}TIM_HandleTypeDef;</p><p>第一个参数 Instance 是寄存器基地址。和串口，看门狗等外设一样，一般外设的初始化结</p><p>构体定义的第一个成员变量都是寄存器基地址。这在 HAL 中都定义号了，比如要初始化定时</p><p>器 1，那么的值设置为 TIM1 即可。</p><p>第二个参数 Init 为真正的初始化结构体 TIM_Base_InitTypeDef 类型，给结构体定义如下：</p><p>typedef struct</p><p>{</p><p>uint32_t Prescaler;//预分频系数</p><p>uint32_t CounterMode; //计数方式</p><p>uint32_t Period;//自动装载值 ARR</p><p>uint32_t ClockDivision;//时钟分频因子</p><p>uint32_t RepetitionCounter;</p><p>uint32_t AutoReloadPreload;</p><p>}TIM_Base_InitTypeDef;;</p><p>该初始化结构体中，参数 Prescaler 是用来设置分频系数的，刚才上面有讲解。参数</p><p>CounterMode 是用来设置计数方式，可以设置为向上计数，向下计数方式还有中央对齐计数方</p><p>式 ， 比 较 常 用 的 是 向 上 计 数 模 块 TIM_CouterMode_Up 和 向 上 计 数 模 式</p><p>TIM_CounterMode_Down。参数 Period 是设置自动重载计数周期值。参数 ClockDivision 是用来</p><p>设置时钟分频因子，也就是定时器时钟频率 CK_INT 与数字滤波器所使用的采样时钟之间的分</p><p>频比。参数 RepetitionCounter 用来设置活跃通道。用在高级定时器中。参数 AutoReloadPerload</p><p>用来设置自动重新加载预载。</p><p>第三个参数 Channel 用来设置活跃通道。前面我们讲解过，每个定时器最多有四个通道可</p><p>以用来做输出比较，输入捕获等功能之用。这里的 Channel 就是用来设置活跃通道的，取值范</p><p>围内：HAL_TIM_ACTIVE_CHANNEL_1 ~ HAL_TIM_ACTIVE_CHANNEL_4。</p><p>第四个 hdma 是是定时器的 DMA 功能时用到，为了简单起见，我们暂时不讲解太复杂。</p><p>第五个参数 Lock 和 State，是状态过程标识符，是 HAL 库用来记录和标志定时器处理过程。</p><p>定时器初始化范例如下：</p><p>TIM_HandleTypeDef TIM3_Handler; //定时器句柄</p><p>TIM3_Handler.Instance=TIM3; //通用定时器 3</p><p>TIM3_Handler.Init.Prescaler=7199; //分频系数</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP;//向上计数器</p><p>TIM3_Handler.Init.Period=4999; //自动装载值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频因子</p><p>TIM3_Handler.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;</p><p>//使能自动重载</p><p>HAL_TIM_Base_Init(&TIM3_Handler);</p><p><strong>3）使能定时器更新中断，使能定时器</strong></p><p>HAL 库 中 ， 使 能 定 时 器 更 新 中 断 和 使 能 定 时 器 两 个 操 作 可 以 在 函 数</p><p>HAL_TIME_Base_Start_IT()中一次完成的，该函数声明如下：</p><p>HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)；</p><p>该 函 数 非 常 好 理 解 ， 只 有 一 个 入 口 参 数 。 调 用 该 定 时 器 之 后 ， 会 首 先 调 用</p><p>__HAL_TIM_ENABLE_IT 宏定义使能更新中断，然后调用宏定义__HAL_TIM_ENABLE 使能</p><p>相应的定时器。这里我们分别列出单独使能/关闭定时器中断和使能/关闭定时器方法：</p><p>__HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);//使能句柄制定的定时器更新中断</p><p>__HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);//关闭句柄指定的定时器更新中断</p><p>__HAL_TIM_ENABLE(htim);//使能句柄 htim 制订的定时器</p><p>__HAL_TIM_DISABLE(htim);//关闭句柄 htim 制定的定时器</p><p><strong>4）TIM3 中断优先级设置</strong></p><p>在定时器中断使能之后，因为要产生中断，必不可少的要设置 NVIC 的相关寄存器，设置</p><p>中断优先级。之前多次讲解到中断优先级的设置，这里就不重复讲解。</p><p>和串口等其他外设一样，HAL 库为定时器初始化定义了回调函数 HAL_TIM_Base_MspInit。</p><p>一般情况下，与 MCU 有关的使能使能，以及中断优先级配置我们都会放在该回调函数内部。</p><p>函数声明如下：</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)；</p><p>对于回调函数，这里我们就不做过多讲解，大家只需要重写这个函数即可。</p><p><strong>5）编写中断服务函数</strong></p><p>在最后，还是要编写定时器中断服务函数，通过该函数来处理定时器产生的相关中断。通</p><p>常情况下，在中断产生后，通过状态寄存器的值来判断此次产生的中断属于什么类型。然后执</p><p>行相关的操作，我们这里使用的是更新（溢出）中断，所以在状态寄存器 SR 的最低位。在处</p><p>理完中断之后应该向 TIM3_SR 的最低位写 0，来清除该中断标志。</p><p>跟串口一样，对于定时器中断，HAL 库同样为我们封装了处理过程。这里我们以定时器 3</p><p>的更新中断为例来讲解。</p><p>首先，中断服务函数是不变的，定时器 3 的中断服务函数为：</p><p>void TIM3_IRQHandler(void)；</p><p>一般情况下我们是在中断服务函数内部编写中断控制逻辑。到那时 HAL 库为我们定义了</p><p>新的定时器中断共用处理函数 HAL_TIM_IRQHandler，在每个定时器的中断服务函数内部，我</p><p>们会调用该函数。该函数声明如下：</p><p>void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)；</p><p>而函数 HAL_TIM_IRQHandler 内部，会对相应的中断标志进行详细判断，判断确定中断来</p><p>源后，会自动清掉该中断标志位，同时调用不同类型中孤单的回调函数。所以我们的中断控制</p><p>逻辑只用编写在中断回调函数中，并且中断回调函数中不需要清中断标志位。</p><p>比如定时器更新中断回调函数为：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)；</p><p>跟串口中断回调函数一样，我们只需要重写该函数即可。对于其他类型中断，HAL 库同样</p><p>提供几个不同的回调函数，这里我们列出常用的几个回调函数：</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim);//更新中断</p><p>void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim);//输出比较</p><p>void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim);//输入捕获</p><p>void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim);//触发中断</p><p>对于这些回调函数的使用方法我们在后面用到的时候会给大家详细讲解。</p><p>通过以上几个步骤，我们就可以达到我们的目的了，使用通用定时器的更新中断，来控制</p><p>DS1 的亮灭。</p><p><strong>13.2 硬件设计</strong></p><p>本实验用到的硬件资源有：</p><p>1） 指示灯 DS0 和 DS1</p><p>2） 定时器 TIM3</p><p>本章将通过 TIM3 的中断来控制 DS1 的亮灭，DS1 在前面已经有介绍了。而 TIM3 属于</p><p>STM32 的内部资源，只需要软件设置即可正常工作。</p><p><strong>13.3 软件设计</strong></p><p>软件设计我们直接打开我们光盘实验 8 定时器中断实验即可。我们可以看到我们的工程中</p><p>的 HARDWARE 下面比以前多了一个 time.c 文件（包括头文件 time.h），这两个文件是我们自</p><p>己编写。同时还引入了定时器相关的固件库函数文件 stm32f1xx_hal_tim.c 和 头文 件</p><p>stm32f1xx_hal_tim.h。下面我们来看看我们的 time.c 文件。</p><p>time.c 文件代码：</p><p>TIM_HandleTypeDef TIM3_Handler; //定时器句柄</p><p>//通用定时器 3 中断初始化</p><p>//arr：自动重装值。</p><p>//psc：时钟预分频数</p><p>//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.</p><p>//Ft=定时器工作频率,单位:Mhz</p><p>//这里使用的是定时器 3!</p><p>void TIM3_Init(u16 arr,u16 psc)</p><p>{</p><p>TIM3_Handler.Instance=TIM3; //通用定时器 3</p><p>TIM3_Handler.Init.Prescaler=psc; //分频系数</p><p>TIM3_Handler.Init.CounterMode=TIM_COUNTERMODE_UP; //向上计数器</p><p>TIM3_Handler.Init.Period=arr; //自动装载值</p><p>TIM3_Handler.Init.ClockDivision=TIM_CLOCKDIVISION_DIV1;//时钟分频因子</p><p>TIM3_Handler.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;</p><p>//使能自动重载</p><p>HAL_TIM_Base_Init(&TIM3_Handler);//初始化定时器 3</p><p>HAL_TIM_Base_Start_IT(&TIM3_Handler);</p><p>//使能定时器 3 更新中断：TIM_IT_UPDATE</p><p>}</p><p>//定时器底册驱动，开启时钟，设置中断优先级</p><p>//此函数会被 HAL_TIM_Base_Init()函数调用</p><p>void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim->Instance==TIM3)</p><p>{</p><p>__HAL_RCC_TIM3_CLK_ENABLE(); //使能 TIM3 时钟</p><p>HAL_NVIC_SetPriority(TIM3_IRQn,1,3);</p><p>//设置中断优先级，抢占优先级 1，子优先级 3</p><p>HAL_NVIC_EnableIRQ(TIM3_IRQn); //开启 ITM3 中断</p><p>}</p><p>}</p><p>//定时器 3 中断服务函数</p><p>void TIM3_IRQHandler(void)</p><p>{</p><p>HAL_TIM_IRQHandler(&TIM3_Handler);</p><p>}</p><p>//回调函数，定时器中断服务函数调用</p><p>void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)</p><p>{</p><p>if(htim==(&TIM3_Handler))</p><p>{</p><p>LED1=!LED1; //LED1 反转</p><p>}</p><p>}</p><p>该文件一共有 4 个函数。第一个函数 TIM3_Init 用来初始化定时器 3，使能定时器 1 更新中</p><p>断以及使能定时器，实现的是 13.1 小节讲解的步骤 2 和步骤 3 配置功能。该函数的 2 个参数用</p><p>来设置 TIM3 的溢出时间。因为我们在 Stm32_Clock_Init 函数里面已经初始化 APB1 的时钟为 2</p><p>分频，所以 APB1 的时钟为 36M，而从 STM32 的内部时钟树图得知：当 APB1 的时钟分频数</p><p>为 1 的时候，TIM2~7 的时钟为 APB1 的时钟，而如果 APB1 的时钟分频数不为 1，那么 TIM2~7</p><p>的时钟频率将为 APB1 时钟的两倍。因此，TIM3 的时钟为 72M，再根据我们设计的 arr 和 psc</p><p>的值，就可以计算中断时间了。计算公式如下：</p><p>Tout= ((arr+1)*(psc+1))/Tclk；</p><p>其中：</p><p>Tclk：TIM3 的输入时钟频率（单位为 Mhz）。</p><p>Tout：TIM3 溢出时间（单位为 us）。</p><p>第二个函数 HAL_TIM_Base_MspInit 是定时器初始化回调函数，主要是使能定时器 3 时钟</p><p>以及定时器 3 的 NVIC 配置，实现的是 13.1 小节讲解的步骤 1 和步骤 4 功能。第三个函数</p><p>TIM3_IRQHandler 是中断服务入口函数，该函数内部只有一行代码就是调用定时器中断共用处</p><p>理函数 HAL_TIM_IRQHandler。根据前面的讲解，函数 HAL_TIM_IRQHandler 内部会判断中断</p><p>来源，根据中断来源调用不同的中断处理回调函数。这里我们开启的是定时器 3 的更新中断，</p><p>所以我们需要重定义更新中断回调函数 HAL_TIM_PeriodElapsedCallback。第四个函数</p><p>HAL_TIM_PeriodElapsedCallback 就是更新中断回调函数，也就是真正的中断处理函数，该函数</p><p>内部通过判断中断时定时器 3 之后，然后控制 LED1 翻转。</p><p>time.h 头文件内容比较简单，这里我们就不做讲解了。</p><p>最后，我们看看主函数代码如下：</p><p>int main(void)</p><p>{</p><p>HAL_Init(); //初始化 HAL 库</p><p>Stm32_Clock_Init(RCC_PLL_MUL9); //设置时钟,72M</p><p>delay_init(72); //初始化延时函数</p><p>uart_init(9600);</p><p>//初始化串口</p><p>LED_Init(); //初始化 LED</p><p>TIM3_Init(5000-1,7200-1); //定时器 3 初始化，定时器时钟为 72M，分频系数为 7199，</p><p>//所以定时器 3 的频率为 72M/7200=10K，自动重装载为 4999，那么定时器周期就是 500ms</p><p>while(1)</p><p>{</p><p>LED0=!LED0; //LED0 翻转</p><p>delay_ms(200); //延时 200ms</p><p>}</p><p>}</p><p>这里的代码和之前大同小异，此段代码对 TIM3 进行初始化之后，进入死循环等待 TIM3</p><p>溢出中断，当 TIM3_CNT 的值等于 TIM3_ARR 的值的时候，就会产生 TIM3 的更新中断，然</p><p>后在中断里面取反 LED1，TIM3_CNT 再从 0 开始计数。根据上面的公式，我们可以算出中断</p><p>溢出时间为 500ms，即 Tout= ((4999+1)*( 7199+1))/72=500000us=500ms。</p><p><strong>13.4 下载验证</strong></p><p>在完成软件设计之后，我们将编译好的文件下载到 NANO STM32 开发板上，观看其运行</p><p>结果是否与我们编写的一致。如果没有错误，我们将看 DS0 不停闪烁（每 400ms 闪烁一次），</p><p>而 DS1 也是不停的闪烁，但是闪烁时间较 DS0 慢（1s 一次）。</p><p><strong>13.5 STM32CubeMX 配置定时器更新中断功能</strong></p><p>我们将列出 STM32CubeMx 配置的关键点，然后生成工程，大家自行与光盘中提供的实验</p><p>代码对照学习。</p><p>定时器 3 中断配置非常简单。配置步骤如下：</p><p>① 在 Pinout->TIM3 配置项中，配置 Clock Source 为 Internal Clock，如下图 13.5.1 所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f2c61f0b08243b19da5341178be15fd><p class=pgc-img-caption>图 13.5.1 TIM3 配置</p></div><p>② 进入 Configuration->TIM3 配置项，在弹出的界面中点击 Parameter Settings 选项卡，Counter</p><p>Settings 配置栏下面的五个选项就是用来配置定时器的预分频系数，自动预装载值，计数模式、时钟分频因子，以及使能自动装载功能。操作方法如下图所示：</p><div class=pgc-img><img alt="「正点原子NANO STM32F103开发板资料连载 第13章 定时器中断实验" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48be5d5496dc48f1a22546647c41fbe8><p class=pgc-img-caption>图 13.5.2 TIM3 参数设置界面</p></div><p>③ 进入 Configuration->NVIC 配置页，在弹出的界面中点击 NVIC 选项卡，配置 Interput Table</p><p>中 TIM3 global interupt，使能中断，配置抢占优先级和相应优先级。</p><p>经过上面三个步骤，生成代码，大家对比生成的代码和实验工程的区别。这里需要说明的</p><p>时，默认情况下，TIM3 的时钟来源时内部时钟 CK_INT，所以在我们实验中使用的时默认配置，</p><p>没有额外在程序中体现。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'正点','NANO','STM32F103'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>