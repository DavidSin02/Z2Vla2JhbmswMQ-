<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>在JAVA中六个不同的储存点 | 极客快訊</title><meta property="og:title" content="在JAVA中六个不同的储存点 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/152359106448326be9391ba"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ebea16f5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ebea16f5.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="在JAVA中六个不同的储存点"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ebea16f5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>在JAVA中六个不同的储存点</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt=在JAVA中六个不同的储存点 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/152359106448326be9391ba></p><p><strong>1. 堆栈(stack)——存放基本类型的变量数据和对象。</strong></p><p>驻留于常规 RAM（随机访问存储器）区域中,但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动,则分配新的内存;若向上移动,则释放那些内存.这是一种快速有效的分配存储方法,仅次于寄存器。创建程序时候,JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期,因为它必须生成 相应的代码,以便上下移动堆栈指针。这一约束限制了程序的灵活性,所以虽然某些JAVA数据存储在堆栈中——特别是对象引用,但是JAVA对象不存储其中。数组的引用,但对象本身不存放在栈中,而是存放在堆(new 出来的对象)或者常量池中(字符串常量对象存放在常量池中)</p><p><strong>2.寄存器(register)——最快的存储区。</strong><br></p><p>这是最快的存储区,因为它位于和其他所有保存方式不同的地方：处理器内部。然而，寄存器的数量十分有限，所以寄存器是根据需要由编译器分配。我们对此没有直接的控制权，也不可能在自己的程序里找到寄存器存在的任何踪迹。但是寄存器的数量极其有限,所以寄存器由编译器根据需求进行分配。你不能直接控制,也不能在程序中感觉到寄存器存在的任何迹象，<span>由编译器根据需求进行分配,我们在程序中无法控制.</span></p><p><strong><span>3. 静态存储(static storage)——</span><span>存放静态成员(static定义的) </span></strong><span>。</span><br></p><p>这里的“静态（Static）”是指“在固定的位置”（尽管也在RAM 里）。程序运行期间,静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的,但JAVA对象本身从来不会存放在静态存储空间里。程序运行期间，静态存储的数据将随时等候调用。可用 static 关键字指出一个对象的特定元素是静态的</p><p><strong>4. 堆(heap)——存放所有new出来的对</strong>象。</p><p>一种通用性的内存池(也存在于RAM中),用于存放所以的JAVA对象。堆不同于堆栈的好处是:编译器不需要知道要从堆里分配多少存储区 域,也不必知道存储的数据在堆里存活多长时间。因此,在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候,只需要new写一行简单的代码,当执行 这行代码时,会自动在堆里进行存储分配。必然会付出一定的代价,在堆里分配存储空间时会花掉更长的时间.</p><p><strong>5.非RAM储存——独立于一个程序之外</strong></p><p>若数据完全独立于一个程序之外，则程序不运行时仍可存在， 并在程序的控制范围之外。 其中两个最主要的例子便是 “流式对象” 和 “固定对象” 。对于流式对象，对象会变成字节流，通常会发给另一台机器。而对于固定对象，对象保存在磁盘中。即使程序中止运行，它们仍可保持自己的状态不变。对于这些类型的数据存储，一个特别有用的技巧就是它们能存在于其他媒体中。一旦需要，甚至能将它们恢复成普通的、基于 RAM 的对象。Java 1.1 提供了对 Lightweight persistence 的支持。未来的版本甚至可能提供更完整的方案。</p><p><strong><span>6. 常量存储(constant storage)——存放字符串常量和基本类型常量(public static final) 。</span></strong></p><p><span>常量值通常直接存放在程序代码内部,这样做是安全的,因为它们永远不会被改变。有时,在嵌入式系统中,常量本身会和其他部分分割离开,所以在这种情况下,可以选择将其放在ROM中 </span><span>6. 非RAM存储——硬盘等永久存储空间。</span></p><p>如果数据完全存活于程序之外,那么它可以不受程序的任何控制,在程序没有运行时也可以存在，<span>硬盘等永久存储空间 就速度来说,有如下关系</span></p><p>寄存器 >堆栈 > 堆 > 其它</p><p>而在这里我们主要关心的是栈,堆和常量池,对于栈和常量池中的对象可以共享,对于堆中的对象不可以共享。 <span>栈中的数据大小和生命周期是可以确定的,当没有引用指向数据时,这个数据就会消失。堆中的对象的由垃圾回收器负责回收,因此大小和生命周期不需要确定,具有很大的灵活性。</span></p><p>对于字符串:其对象的引用都是存储在栈中的,如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中,如果是运行期(new出来的)才能确定的就存储在堆中。对于equals相等的字符串,在常量池中永远只有一份,在堆中有多份。</p><p>如以下代码: Java代码</p><p>String s1 = "china";</p><p>String s2 = "china";</p><p>String s3 = "china";</p><p>String ss1 = new String("china");</p><p>String ss2 = new String("china");</p><p>String ss3 = new String("china");</p><p>这里解释一下,对于通过 new 产生一个字符串(假设为 ”china” )时,会先去常量池中查找是否已经有了 ”china” 对象,如果没有则在常量池中创建一个此字符串对象,然后堆中再创建一个常量池中此 ”china” 对象的拷贝对象。</p><p>也就是有道面试题: String s = new String(“xyz”); 产生几个对象?</p><p>一个或两个。如果常量池中原来没有 ”xyz”, 就是两个。如果原来的常量池中存在“xyz”时,就是一个。</p><p>对于基础类型的变量和常量:变量和引用存储在栈中,常量存储在常量池中。</p><p>如以下代码: Java代码</p><p>int i1 = 9;</p><p>int i2 = 9;</p><p>int i3 = 9;</p><p>public static final int INT1 = 9;</p><p>public static final int INT2 = 9;</p><p>public static final int INT3 = 9;</p><p>对于成员变量和局部变量:成员变量就是方法外部,类的内部定义的变量;</p><p>局部变量就是方法或语句块内部定义的变量。局部变量必须初始化。 形式参数是局部变量,局部变量的数据存在于栈内存中。栈内存中的局部变量随着方法的消失而消失。 成员变量存储在堆中的对象里面,由垃圾回收器负责回收。</p><p>如以下代码: Java代码</p><p>class BirthDate {</p><p>private int day;</p><p>private int month;</p><p>private int year;</p><p>public BirthDate(int d, int m, int y) {</p><p>day = d;</p><p>month = m;</p><p>year = y;</p><p>}</p><p>// 省略get,set方法………</p><p>}</p><p>public class Test{</p><p>public static void main(String args[]){</p><p>int date = 9;</p><p>Test test = new Test();</p><p>test.change(date);</p><p>BirthDate d1= new BirthDate(7,7,1970);</p><p>}</p><p>public void change1(int i){</p><p>i = 1234;</p><p>}</p><p>对于以上这段代码,date为局部变量,i,d,m,y都是形参为局部变量,day,month,year为成员变量。</p><p>下面分析一下代码执行时候的变化:</p><p>1. main方法开始执行:int date = 9; date局部变量,基础类型,引用和值都存在栈中。</p><p>2. Test test = new Test(); test为对象引用,存在栈中,对象(new Test())存在堆中。</p><p>3. test.change(date); i为局部变量,引用和值存在栈中。当方法change执行完成后,i就会从栈中消失。</p><p>4. BirthDate d1= new BirthDate(7,7,1970); d1 为对象引用,存在栈中,对象(new BirthDate())存在堆中,其中d,m,y为局部变量存储在栈中,且它们的类型为基础类型,因此它们的数据也存储在栈中。 day,month,year为成员变量,它们存储在堆中(new BirthDate()里面)。当BirthDate构造方法执行完之后,d,m,y将从栈中消失。</p><p>5.main方法执行完之后,date变量,test,d1引用将从栈中消失,new Test(),new BirthDate()将等待垃圾回收。</p><p><img alt=在JAVA中六个不同的储存点 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/152359105056948f3435a13></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JAVA','中六个','储存点'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>