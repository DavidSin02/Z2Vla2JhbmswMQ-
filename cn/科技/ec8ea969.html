<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>存储类别，链接，内存管理 | 极客快訊</title><meta property="og:title" content="存储类别，链接，内存管理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ec8ea969.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ec8ea969.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="存储类别，链接，内存管理"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ec8ea969.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>存储类别，链接，内存管理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>c提供了多种模型，或者说存储类别，在内存存储数据</p><p>从硬件层面看，被存储的每个值，都占用一定的物理的内存，c语言成这个一块内存称为对象</p><p>对象可以存储一个或者多个值，一个对象也可能并未存储实际的值</p><p>从软件层面看，程序需要一种方法访问对象，可以通过声明变量来完成</p><p>标识符可以用来指定，特定对象的内容</p><p>标识符即是软件，指定硬件内存中对象的一种方式</p><p>变量名，不是指定对象的唯一方式</p><p>变量名不是指定对象的唯一方式</p><p>int * pt = &entity</p><p>int ranks[10]</p><p>该声明，在内存上创建一个可以容纳十个int元素的对象</p><p>pt 是一个标识符，指定一个内存上存储地址的对象</p><p>表达式 *pt 不是标识符， 它指定了存储地址的对象</p><p>*pt 不是一个标识符，因为他不是一个名称，然而它确实指定了一个对象，它跟entity相同</p><p>那些指定对象的表达式，称为左值</p><p>entity 即是标识符也是左值</p><p>*pt 即使表达式也是左值</p><p>所有这些事例中，如果可以通过左值，修改内存上对象的值，该值就称为一个可以修改的左值（modifiable lvalue)</p><p>const char * pc = "Behond a string literal"</p><p>程序根据该声明把字符串字面量，存储在内存中，内含这些字符串的数组就是一个对象</p><p>由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象</p><p>该声明还创建了一个标识符为 pc的对象， 存储着字符串的地址</p><p>由于可以设置pc 从新指向其他的字符，所以pc 是一个可以修改的左值</p><p>const 只能保证pc 指向的字符串不被修改</p><p>由于*pc 指定了存储 'B'字符的数据对象</p><p>所以 *pc 是一个左值， 但是是一个不可以修改的左值</p><p>因为字符串字面量本身指定了存储字符串的对象，所以它也是一个左值，但是一个不可以修改的左值</p><p>可以用存储期（</p><p>storage</p><p>[ˈstɔːrɪdʒ]</p><p>duration</p><p>[djuˈreɪʃn]</p><p>)描述对象， 所谓存储期就是对象在内存上保留了多长时间</p><p>标示符用于访问对象</p><p>可以用作用域（scop)和链接（linkage</p><p>[ˈlɪŋkɪdʒ])描述标识符</p><p>标识符的 链接和作用域，表明了程序中那些地方可以使用它</p><p>不同存储类别，具有不同的存储期，作用域，链接</p><p>标识符，可以在源代码多个文件中共享，可以用于特定代码的特定函数，可仅限于函数使用，甚至函数中的某个部分</p><p>对象可以存在于程序的执行期，也可以仅存在于函数的执行期</p><p>对于并发编程 对象也可以存在特定线程的执行期间</p><p>可以通过函数调用，显示的的分配释放内存</p><p>作用域：</p><p>用来描述程序中标识符可以访问的区域</p><p>一个C变量的作用域，可以分为块作用域， 函数作用域， 函数原型， 文件作用域</p><p>本程序中使用的变量几乎都具有块作用域</p><p>block scope</p><p>块： 一对花括号，括起来的代码区域， 整个函数体是一个块，函数中的任意复合句也是一个块</p><p>定义在块中变量具有块级作用域</p><p>块作用域变量的可见范围，从定义处开始，到包含这块定义末尾</p><p>虽然函数的， 形式参数， 在函数的左花括号之前，但它具有块级，作用域，属于函数体这个块</p><p>声明在内层块中变量，期作用域仅限于该声明所在的块</p><p>for (int i = 0 ; i &lt; 10; i ++) {</p><p>}</p><p>上面for 循环中的变量i , 被视为for 循环的一部分， 它的作用域仅限于for 循环，一旦离开for 循环，将不能被访问</p><p>为了适应新特性，c99 把块的概念扩大到了，包括for循环，while 循环， do while 和if 语句的控制代码， 即使这些代码没在花括号块中， 也算块的一部分。</p><p>函数作用域（function scope)</p><p>函数原型作用域（function prototype scope) 用于函数原型中的形参</p><p>int mighty(int mouse, double large)</p><p>函数原型作用域范围， 从形参定义处，到原型声明结束</p><p>编译器在处理函数原型的形参时，只关心它的类型， 形参名，无关紧要</p><p>即使有形参名，也不必要与函数定义时候一样</p><p>在变长数组中， 形参名才有用。</p><p>void use_a_VLA(int n, int m , ar[n][m])</p><p>方括号中，必须使用函数原型中声明的名字</p><p>file scope</p><p>变量定义在函数外面，具有文件作用域</p><p>具有文件作用域的变量，从它的定义到文件末尾均可见</p><p>int units = 0;</p><p>void critic(void)</p><p>int main (void) {</p><p>}</p><p>void critic (void) {</p><p>}</p><p>这里变量 untils 具有文件作用域 main critic 函数都可以使用它</p><p>（更准确的说 untils 具有外部链接文件作用域）由于这样变量可以用多个函数，所以文件作用域变量也称全局变量</p><p>翻译单元文件：</p><p>你以为的多个文件在编译器中可能以一个文件出现</p><p>通常在源代码 .c 中，包含一个或者多个头文件，头文件一次包含其他的头文件，所以会包含多个单独的物理文件。</p><p>c预处理器 实际上是用包含了 头文件的内容替换了#inclue 指令</p><p>所以编译器源代码文件和所有头文件，都看成一个包含信息的单独文件，这个文件被称为翻译单元</p><p>描述一个具有文件作用域的变量，实际上是整个翻译单元</p><p>如果程序有多个源代码文件组成，那么该程序有多个翻译单元组成</p><p>每个翻译单元均对应一个源代码文件和它的头文件</p><p>链接：</p><p>c变量有三种链接属性：无链接， 内部链接， 外部链接</p><p>无链接： 具有块作用域 函数作用域 函数原型作用域变量 都是无链接变量，变量属于他们块 或者函数 私有</p><p>具有文件作用域的变量：</p><p>外部链接（外部链接变量，可以在多个文件程序使用）</p><p>内部链接（只能在一个翻译单元使用）</p><p>c标准用 内部链接的文件作用域 （文件作用域）</p><p>描述仅限一个翻译单元的作用域（即一个源代码文件，和它所包含的头文件）</p><p>外部链接的文件作用域 （全局作用域，程序作用域）</p><p>描述可以延伸到其他单元的作用域</p><p>如果知道文件作用域的变量，是内部链接或者是外部链接</p><p>可以查看外部定义中是否使用了存储类别说明符 static</p><p>int giants = 5 // 文件作用域， 外部链接</p><p>static int doggers = 3 // 文件作用域，内部链接</p><p>存储期</p><p>作用域和链接 描述了 标识符 可见性</p><p>存储期 则是描述了通过标识符，访问对象的生存期</p><p>c对象有四种存储期</p><p>静态存储期</p><p>程序执行期间一致存在</p><p>文件作用域的变量具有静态存储期</p><p>关键字 static 表明了其链接属性，而非存储期</p><p>所以static 声明的文件作用域变量具有内部链接属性，但是无论是内部链接还是外部链接</p><p>所有文件作用域变量都具有静态存储器</p><p>线程存储期</p><p>用于并发程序设计，程序执行可以分为多个线程</p><p>具有线程存储期的对象，从被声明到线程结束一直存在</p><p>以关键字 _Thread_local[θred] 声明的一个对象时，每个线程都能获得该变量的私有备份</p><p>自动存储期</p><p>块作用域的变量通常具有 自动存储期， 当程序进入定义这些变量块时，为这些变量分配 内存，当退出这些块，释放刚才分配内存</p><p>这种做法相当于把自动变量占用的内存视为一个可以重复利用的工作区或暂存区</p><p>一个函数调用结束后，其变量占用的内存可以存储下一个函数的变量</p><p>块作用域变量也可以拥有静态存储期，为了创建这样的变量，要把变量声明在块中，且 加 上static 关键字</p><p>void more(int number) {</p><p>int index;</p><p>static int ct = 0;</p><p>}</p><p>这里的变量 ct ，存储在静态内存中，它从程序被载入，到程序结束期间都存在，</p><p>它的作用域定义在more函数中，只有执行该函数时， 程序使用ct 访问它所指定对象</p><p>c 使用作用域 链接和存储期为变量定义了多种存储方案</p><p>动态分配存储期</p><p>存储类别 存储期 作用域 链接 声明方式</p><p>自动 自动 块 无 块内</p><p>寄存器 自动 块 无 块内，使用关键字 register[ˈredʒɪstə(r)]</p><p>静态外部链接 静态 文件 外部 所有函数外</p><p>静态内部链接 静态 文件 内部 所有函数外，使用关键字 static</p><p>静态无链接 静态 块 无 块内， 使用关键字 static</p><p>自动变量</p><p>属于自动存储类别的变量，拥有自动存储期，块作用域 且无链接</p><p>为了强调不把变量改为别的存储类别 ，可以显试的使用关键字 auto</p><p>auto int plox</p><p>关键字 auto 是存储类别说明符</p><p>//块作用域无链接，只有在变量所定义的块中能够通过变量名访问变量</p><p>// 参数用于传递变量的值，或者变量的地址，给另外一个函数，这是间接的方法</p><p>// 另一个函数可以使用同名的变量，但是该变量是存储不同内存位置上的另外变量</p><p>// 变量具有自动存储期，意味进入该变量所在块，该变量被创建，程序退出该变量所在块，</p><p>//原来变量所占得到空间可做他用</p><p>int loop(int n)</p><p>{</p><p>int m;</p><p>scanf("%d", &m);</p><p>{</p><p>int i;</p><p>for ( i = m; i &lt; n ; i++) {</p><p>puts(" i is local to sub-block\n")</p><p>}</p><p>}</p><p></p><p>return m</p><p></p><p>}</p><p>循环体是整个循环块的子块</p><p>if 语句是一个块，与其关联的子语句是if块的子块</p><p>自动变量不会初始化</p><p>寄存器变量</p><p>变量通常存储在内存中， 如果幸运的话，寄存器变量存储在cpu的寄存器中</p><p>块作用域的静态变量</p><p>静态变量 意思是该变量在内存中，原地不动</p><p>具有文件作用域的变量，必须具有静态存储期</p><p>可以创建静态存储期，块作用域的局部变量</p><p>这些变量 和自动变量一样， 具有相同的作用域，但是程序离开离开他们的函数后不会消失</p><p>也就是说变量具有块作用域，无链接，但是具有静态存储期</p><p>计算机在多次函数调用期间会记录他们的值 在块中用存储类别说明符， static 声明这种变量</p><p>外部链接的静态变量</p><p>具有文件作用域</p><p>外部链接</p><p>静态存储期</p><p></p><p>该类别有时也称为静态存储类别</p><p>属于该类别的变量有时也称为外部变量</p><p>把变量声明放在所有函数外面创建了外部变量</p><p>为了在函数中指出使用了外部变量</p><p>可以使用extern[ˈekstɜːn]</p><p>再次声明</p><p>如果一个源文件，使用外部变量，定义中另外的文件中，必须使用extern 再次声明</p><p>int Errup</p><p>double Up[100]</p><p>extern char Coal //如果 Coal 被定义在另一个文件中， 必须这样声明</p><p>void next(void);</p><p></p><p>int mian() {</p><p>extern int Eurrp;//可选声明</p><p></p><p>extern double Up[];//可选声明</p><p><br></p><p>}</p><p>初始化外部变量</p><p>如果未初始化外部变量 ，他们会自动初始化位 0</p><p>只能使用常量表达式初始化 文件作用域变量</p><p>int x = 10;</p><p>int y = 3 + 20;</p><p>size_t z = sizeof(int)</p><p>int x2 = 2 * x // 不行 x是变量</p><p>定义和声明区别</p><p>int tern = 1 //定义变量</p><p>main()</p><p>{</p><p>extern int tern //</p><p>}</p><p>tern 被声明了两次 ， 第一次位变量预留了存储空间，该声明构成了变量的定义</p><p>第二次声明告诉编译器使用之前创建的变量 tern</p><p>1.定义式的声明</p><p>2.引用式的声明</p><p>外部变量只能初始化一次，且必须在该变量定义的时候</p><p>内部链接的静态变量</p><p>该存储类别的变量， 具有静态存储期， 文件作用域 内部链接</p><p>int traveler = 1;//外部链接</p><p>static int stayhome = 1; // 内部链接</p><p>复杂的C程序， 通常有多个单独的源文件组成，有时候zhe这些文件要共享一个外部变量</p><p>c 通过在一个文件中定义声明，在其它文件中，引用声明，来实现引用共享</p><p>除了一个定义声明外，其它通过 extern 只有定义声明时，才可以初始化</p><p>如果将变量定义在外部文中，其它文件在使用变量之前，必须先声明</p><p>在某文件中对外部变量进行定义声明，只是但方面允许其它文件使用该变量</p><p>其它文件在用extern 声明前不能使用</p><p>存储类别说明符</p><p>static extern 含义取决于上下文</p><p>c 语言6个关键字，存储类别说明符</p><p>auto</p><p>register</p><p>static</p><p>extern</p><p>_Thread_local</p><p>在绝大数的情况下，不能使用多个存储类别说明符，</p><p>auto 说明符，表示变量是自动存储期，只能用块作用域的变量声明</p><p>由于在块中声明的变量本身就是自动存储期 ，所以在块中使用auto,</p><p>主要是为了明确的表示使用了与外部同名的变量</p><p>register 也只能用于块作用域，它把变量归寄存器存储类别，请求最快速度访问变量，同时该保护了该变量</p><p>内存地址不被获取</p><p>static 说明符 创建的对象具有静态存储期，载入程序时候创建对象</p><p>当程序结束时候对象消失</p><p>如static 用于文件作用域的声明，作用域受限于该文件</p><p>如果static 用于块作用域声明，作用域受限于该块</p><p>只要程序运行对象就存在并保留其值，但只有执行块内代码时候，才能通过标识符访问，</p><p>块作用域的变量，无链接</p><p>extern 说明符 表明声明的变量在别处</p><p>如果包含extern 声明，具有文件作用域，则引用的变量，必须具有外部链接</p><p>如果包含extern 声明具有块作用域，则引用的变量可能具有外部链接</p><p>存储类别小结：</p><p>自动变量：</p><p>具有块作用域，自动存储期</p><p>他们是局部变量，属于其所定义的块私有</p><p><br></p><p>寄存器变量：</p><p>和自动变量相同，但是编译器会用更快内存或者寄存器存储他们</p><p>不能获得寄存器的地址</p><p><br></p><p>具有静态存储期的变量</p><p>可以有外部链接</p><p>可以有内部链接</p><p>无链接</p><p></p><p>在同一个文件所有函数之外声明的变量是外部变量</p><p>具有文件作用域</p><p>外部链接</p><p>静态存期</p><p><br></p><p>如果在函数中使用static 声明一个变量</p><p>则该变量</p><p>具有块作用域</p><p>静态存储器</p><p>无链接</p><p><br></p><p>具有自动存储期的变量</p><p>程序进入该变量所在的块，才为其分配内存</p><p>在退出该块时候时候，释放之前分配的内存</p><p>如果未初始化，自动变量中是垃圾值</p><p><br></p><p>程序在编译的时候，为具有静态存储期的变量分配内存，并在程序运行过程中，一直保留这块内存</p><p>如果未初始化，这块变量会被设置未0</p><p><br></p><p>具有块作用域变量是局部的，属于该块私有</p><p><br></p><p>具有文件作用域变量，位于其声明后的所有函数可见</p><p><br></p><p>具有外部链接的文件作用域变量，可以用于该程序的其它，编译单元</p><p></p><p>具有内部链接的文件作用变量， 只能用于其声明所在的文件</p><p><br></p><p>存储类别和函数</p><p></p><p>函数也有存储类别：</p><p>可以外部函数</p><p>可以被其它文件的函数访问</p><p>静态函数</p><p>只能用于定义的文件</p><p>内联函数</p><p><br></p><p>dobule grama(double) //该函数默认为外部函数</p><p>static double beta(int , int)</p><p>extern double delta(double, int)</p><p>其它文件中函数可以调用 grama delta 不能调用 beta</p><p></p><p>应为static 存储类别说明符，创建的函数属于特定模块私有，</p><p>这样避免了名称冲突问题，由于beta 受限于它所在的文件</p><p>所以其它文件可以使用与其同名的函数</p><p><br></p><p>用extern 声明定义在其它文件中的函数</p><p>这样做是为了声明当前使用的函数定义在外部</p><p></p><p>除非使用static 关键字，否则函数默认声明为extern</p><p><br></p><p>存储类别的选择</p><p>对于使用那种存储类别，答案是自动存储类别</p><p></p><p>默认的存储类别就是自动存储类别</p><p><br></p><p>为何不把所有变量都设置为外部变量，这样就不必要使用参数，或者指针</p><p></p><p>在函数间传递信息了，</p><p><br></p><p>然而这背后隐藏着一个陷进，A函数可能违揹你意图修改B函数使用的变量</p><p><br></p><p>多年来无数程序员经验表明，随意使用外部存储类别的变量导致的后果远远超过它带来的便利</p><p><br></p><p>唯一例外的是const 数据， 因为它在初始化后，就不会被修改</p><p></p><p>const int DAYS = 7;</p><p></p><p>const char * MSGS [3] = {"yes", "no", "maybe"}</p><p>保护性程序设计的法则是， 按需知道 尽量在函数内部解决函数任务</p><p>只共享那些需要共享的变量</p><p>除了自动存储类别外，其它存储类别也很有用， 在使用某个类别前要考虑一下，是否有必要</p><p>分配内存malloc free</p><p>我们前面选的存储类别有一个共通之处，</p><p>在确定了存储类别后，</p><p>根据已经制定好的内存管理规则</p><p>将自动选择其存储期和作用域</p><p>还有更灵活的地选择</p><p>用函数库管理和分配内存</p><p>所有程序都需要预留足够的内存来存储程序需要的数据，</p><p>这些内存有些是自动分配</p><p>float x;</p><p>char place[] = "Dance Oxen Creek"</p><p>为一个float 类型的值，和一个字符串预留足够的空间</p><p>或者可以显式指定分配一定数量的内存</p><p>int plates[100]</p><p>该声明预留100个内存位置，每个位置都用来存int型， 声明还为内存提供一个标识符</p><p>因此可以用 x place 识别数据</p><p>静态数据在程序载入内存时候分配</p><p>动态数据在程序执行时分配</p><p>并在程序离开块的时候销毁</p><p>malloc 会找到合适空闲内存块，这样的内存是匿名的</p><p>malloc 分配的内存不会为其赋名</p><p>它返回动态分配内存块的，首地址</p><p>可以把该定制赋给一个指针，同过该指针访问这块内存</p><p>指向void的指针，该类型相当于一个通用类型</p><p>malloc可以用于返回指向数据的指针，指向结构的指针</p><p>所以该函数的返回值通常会被转换为匹配的类型</p><p>把指向void 类型的指针，赋给任意类型的指针，完全不用考虑类型匹配的问题</p><p>坚持类型转换，提高代码可读性</p><p>malloc 分配内存失败返回空指针</p><p>动态分配的存储期，从调用调用malloc开始 直到free() 释放为止</p><p>设想malloc 和free 管理着一个内存池，每次调用malloc 的时候，分配内存</p><p>给程序使用，free的时候释放内存给池子</p><p>这样便可以重复使用内存</p><p>不能用free() 释放其它方式分配的内存</p><p>malloc free 原型都在 stdlib.h 头文件中</p><p>如果内存失败可以调用 exit() 结束程序</p><p>EXIT_FAILURE的值也被定义在stlib.h</p><p>标准提供了两个值，保证所有系统正常工作</p><p>EXIT_SUCESS 表示普通程序结束</p><p>EXIT_FAILURE 表示程序异常终止</p><p>使用动态数组给程序带来了更多灵活性，</p><p>静态内存的数量在编译的时候固定的，程序运行期间也不会改变</p><p>自动变量使用的内存，在程序执行期间自动增减或减少</p><p>但是动态分配的内存数量只会增减，除非用free进行释放</p><p>存储类别和动态内存的分配</p><p>程序把它可用的内存分为三个部分</p><p>1.一部分供具有外部链接，内部链接和无链接的静态变量</p><p></p><p>2. 一部分供自动变量</p><p></p><p>3. 一部分供动态内存分配</p><p><br></p><p>静态存储类别所使用内存数量在编译的时候确定</p><p>只要程序还在运行，就可以访问存在该部分的数据</p><p>该类型的变量在程序执行时候被创建，在程序结束的时候被销毁</p><p>自动存储类别的变量，在程序进入变量定义所在的块时候创建，在程序离开的时候销毁</p><p>随着程序调用函数和函数结束自动变量所使用的内存数量相应增加或者减少</p><p>这部分内存通常作为栈来处理， 这意味着新创建的变量按顺序加入内存，然后按相反的方式销毁</p><p>动态分配的内存在调用malloc 或相关函数的时候存在，在调用free后释放</p><p>这部分内存有程序员管理</p><p>而不是一套规则</p><p>所以内存块可以在一个函数中创建，在另外一个函数中销毁</p><p>正是因为这样，这部分内存用于动态内存分配的时候会支离破碎</p><p>也就是说未使用的内存块，分散在已使用的内存块之间</p><p>另外使用动态内存，通常比使用栈内存慢</p><p>总而言之，程序把静态对象 自动对象 动态分配的对象存储在不同区域</p><p>如上所示 静态数据（包括字符串字面量）占用一个区域</p><p>自动数据占用一个区域</p><p>动态分配的数据占用第三个区域（通常被称为内存堆，或自由内存）</p><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'存储类','链接','内存'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>