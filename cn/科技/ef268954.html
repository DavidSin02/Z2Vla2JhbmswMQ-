<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>代码复用神器，模板模式实操分享 | 极客快訊</title><meta property="og:title" content="代码复用神器，模板模式实操分享 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/381d99faa50f4646b7d969af58092c17"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef268954.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef268954.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef268954.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef268954.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef268954.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef268954.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef268954.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef268954.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="代码复用神器，模板模式实操分享"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ef268954.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>代码复用神器，模板模式实操分享</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>一、介绍</strong></h1><p>模板模式，顾名思义，定义一个模板，将部分逻辑以具体方法或者具体构造函数的形式实现，在抽象类中声明一些抽象方法来迫使子类实现剩余的逻辑。</p><p>不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现，这就是模板方法模式的用意。</p><p>模板模式涉及到三个角色：</p><ul><li>抽象类（AbstractClass）：实现了模板方法，定义了算法的骨架；</li><li>具体类（ConcreteClass）：实现抽象类中的抽象方法，已完成完整的算法；</li><li>客户角色：客户类提出使用具体类的请求；</li></ul><h1 class=pgc-h-arrow-right><strong>二、示例</strong></h1><p>举个例子，以早上起床到上班所需要的操作为例，大致流程可以分为以下几步：穿衣服、刷牙、洗脸、吃早餐等。男生和女生的操作可能有些区别。</p><p>我们创建一个抽象的类，定义好大致的操作流程，如下：</p><pre><code>/** * 抽象类 */public abstract class AbstractPerson {    /**     * 定义操作流程     */    public void prepareGoWorking(){        dressing();//穿衣服        brushTeeth();//刷牙        washFace();//洗脸        eatBreakFast();//吃早餐    }    /**穿衣服*/    protected abstract void dressing();    /**刷牙*/    protected void brushTeeth(){        System.out.println("刷牙");    }    /**洗脸*/    protected void washFace(){        System.out.println("洗脸");    }    /**吃早餐*/    protected abstract void eatBreakFast();}</code></pre><p>因为男生和女生的行为不一样，我们分别创建两个具体类，如下：</p><pre><code>/** * 男生 * 具体实现类 */public class ManPerson extends AbstractPerson{    @Override    protected void dressing() {        System.out.println("穿西装");    }    @Override    protected void eatBreakFast() {        System.out.println("直接在公司吃早餐");    }}</code></pre><pre><code>/** * 女生 * 具体实现类 */public class WomanPerson extends AbstractPerson{    @Override    protected void dressing() {        System.out.println("穿休闲衣服");    }    @Override    protected void eatBreakFast() {        System.out.println("在家弄点吃的，或者在外面买一点小吃");    }}</code></pre><p>创建一个客户端，实现如下：</p><pre><code>public class TemplateClient {    public static void main(String[] args) {        //男生起床步骤        ManPerson manPerson = new ManPerson();        System.out.println("-----男生起床步骤----");        manPerson.prepareGoWorking();        System.out.println("-----女生起床步骤----");        //女生起床步骤        WomanPerson womanPerson = new WomanPerson();        womanPerson.prepareGoWorking();    }}</code></pre><p>输出结果：</p><pre><code>-----男生起床步骤----穿西装刷牙洗脸直接在公司吃早餐-----女生起床步骤----穿休闲衣服刷牙洗脸在家弄点吃的，或者在外面买一点小吃</code></pre><p>当然，模版模式的玩法，还不仅仅只有这些，还可以<strong>在模版模式中使用挂钩(hook)</strong>。</p><p>什么是hook呢？<strong>存在一个空实现的方法，我们称这种方法为hook</strong>。子类可以视情况来决定是否要覆盖它。</p><p>还是以上面为例子，比如吃完早餐就要出门上班，选择什么交通工具呢？</p><p>抽象类新增方法hook()，内容如下：</p><pre><code>/** * 抽象类 */public abstract class AbstractPerson {    /**     * 定义操作流程     */    public void prepareGoWorking(){        dressing();//穿衣服        brushTeeth();//刷牙        washFace();//洗脸        eatBreakFast();//吃早餐        hook();//挂钩    }    /**穿衣服*/    protected abstract void dressing();    /**刷牙*/    protected void brushTeeth(){        System.out.println("刷牙");    }    /**洗脸*/    protected void washFace(){        System.out.println("洗脸");    }    /**吃早餐*/    protected abstract void eatBreakFast();    /**挂钩*/    protected void hook(){};}</code></pre><p>男生具体实现类，重写hook()方法，内容如下：</p><pre><code>/** * 男生 * 具体实现类 */public class ManPerson extends AbstractPerson{    @Override    protected void dressing() {        System.out.println("穿西装");    }    @Override    protected void eatBreakFast() {        System.out.println("直接在公司吃早餐");    }    @Override    protected void hook() {        System.out.println("乘地铁上班");    }}</code></pre><p>运行测试类，男生具体实现类，输出结果：</p><pre><code>-----男生起床步骤----穿西装刷牙洗脸直接在公司吃早餐乘地铁上班</code></pre><p>当然，还有其他的玩法，比如女生洗完脸之后，可能需要化妆，我们再次将抽象类进行处理，内容如下：</p><pre><code>/** * 抽象类 */public abstract class AbstractPerson {    /**     * 定义操作流程     */    public void prepareGoWorking(){        dressing();//穿衣服        brushTeeth();//刷牙        washFace();//洗脸        //是否需要化妆，默认不化妆        if(isMakeUp()){            System.out.println("进行化妆");        }        eatBreakFast();//吃早餐        hook();//挂钩    }    /**是否需要化妆方法*/    protected boolean isMakeUp(){        return false;    }    /**穿衣服*/    protected abstract void dressing();    /**刷牙*/    protected void brushTeeth(){        System.out.println("刷牙");    }    /**洗脸*/    protected void washFace(){        System.out.println("洗脸");    }    /**吃早餐*/    protected abstract void eatBreakFast();    /**挂钩*/    protected void hook(){};}</code></pre><p>女生具体实现类，重写isMakeUp()方法，内容如下：</p><pre><code>/** * 女生 * 具体实现类 */public class WomanPerson extends AbstractPerson{    @Override    protected void dressing() {        System.out.println("穿休闲衣服");    }    @Override    protected void eatBreakFast() {        System.out.println("在家弄点吃的，或者在外面买一点小吃");    }    @Override    protected boolean isMakeUp() {        return true;    }}</code></pre><p>运行测试类，女生具体实现类，输出结果：</p><pre><code>-----女生起床步骤----穿休闲衣服刷牙洗脸进行化妆在家弄点吃的，或者在外面买一点小吃</code></pre><h1 class=pgc-h-arrow-right><strong>三、应用</strong></h1><p>模版设计模式，应用非常广泛，比如javaEE中的servlet，当我们每创建一个servlet的时候，都会继承HttpServlet，其实HttpServlet已经为我们提供一套操作流程，我们只需要重写里面的方法即可！</p><div class=pgc-img><img alt=代码复用神器，模板模式实操分享 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/381d99faa50f4646b7d969af58092c17><p class=pgc-img-caption></p></div><p>HttpServlet 的部分源码如下：</p><pre><code>public abstract class HttpServlet extends GenericServlet {    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doHead(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doDelete(HttpServletRequest req,  HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doOptions(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }    protected void doTrace(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        // ...    }        protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        String method = req.getMethod();        if (method.equals(METHOD_GET)) {            long lastModified = getLastModified(req);            if (lastModified == -1) {                // servlet doesn't support if-modified-since, no reason                // to go through further expensive logic                doGet(req, resp);            } else {                long ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);                if (ifModifiedSince &lt; lastModified) {                    // If the servlet mod time is later, call doGet()                    // Round down to the nearest second for a proper compare                    // A ifModifiedSince of -1 will always be less                    maybeSetLastModified(resp, lastModified);                    doGet(req, resp);                } else {                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);                }            }        } else if (method.equals(METHOD_HEAD)) {            long lastModified = getLastModified(req);            maybeSetLastModified(resp, lastModified);            doHead(req, resp);        } else if (method.equals(METHOD_POST)) {            doPost(req, resp);                    } else if (method.equals(METHOD_PUT)) {            doPut(req, resp);                    } else if (method.equals(METHOD_DELETE)) {            doDelete(req, resp);                    } else if (method.equals(METHOD_OPTIONS)) {            doOptions(req,resp);                    } else if (method.equals(METHOD_TRACE)) {            doTrace(req,resp);                    } else {            //            // Note that this means NO servlet supports whatever            // method was requested, anywhere on this server.            //            String errMsg = lStrings.getString("http.method_not_implemented");            Object[] errArgs = new Object[1];            errArgs[0] = method;            errMsg = MessageFormat.format(errMsg, errArgs);                        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);        }    }        // ...省略...}</code></pre><p>自定义一个 HelloWorld 的 Servlet 类，如下：</p><pre><code>import java.io.*;import javax.servlet.*;import javax.servlet.http.*;public class HelloWorld extends HttpServlet {  public void init() throws ServletException {    // ...  }  public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {      response.setContentType("text/html");      PrintWriter out = response.getWriter();      out.println("&lt;h1&gt;Hello World!&lt;/h1&gt;");  }    public void destroy() {      // ...  }}</code></pre><h1 class=pgc-h-arrow-right><strong>四、总结</strong></h1><p><strong>模版模式有着许多的优点：</strong></p><p>1、模板方法模式通过把不变的行为搬移到超类，去除了子类中的重复代码；</p><p>2、子类实现算法的某些细节，有助于算法的扩展；</p><p>3、通过一个父类调用子类实现的操作，通过子类扩展增加新的行为，符合开放-封闭原则；</p><p><strong>也有些缺点：</strong>每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象如果某些类有一些共同的行为，可以使用模版设计模式，创建一个抽象类，将共同的行为定义在抽象类中，可以有效的减少子类重复的代码。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'代码','实操','模板'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>