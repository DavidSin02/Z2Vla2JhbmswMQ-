<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>从源码角度来剖析ThreadLocal到底有没有内存泄漏？ | 极客快訊</title><meta property="og:title" content="从源码角度来剖析ThreadLocal到底有没有内存泄漏？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/ef5bd4a5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/ef5bd4a5.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="从源码角度来剖析ThreadLocal到底有没有内存泄漏？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/ef5bd4a5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>从源码角度来剖析ThreadLocal到底有没有内存泄漏？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>1. 前言</h1><p>ThreadLocal 也是一个使用频率较高的类，在框架中也经常见到，比如 Spring。</p><p>有关 ThreadLocal 源码分析的文章不少，其中有个问题常被提及：ThreadLocal 是否存在内存泄漏？</p><p>不少文章对此讲述比较模糊，经常让人看完脑子还是一头雾水，我也有此困惑。因此找时间跟小伙伴讨论了一番，总算对这个问题有了一定的理解，这里记录和分享一下，希望对有同样困惑的朋友们有所帮助。当然，若有理解不当的地方也欢迎指正。</p><p>啰嗦就到这里，下面先从 ThreadLocal 的一个应用场景开始分析吧。</p><h1 class=pgc-h-arrow-right><strong>2. 应用场景</strong></h1><p>ThreadLocal 的应用场景不少，这里举个简单的例子：单点登录拦截。</p><p>也就是在处理一个 HTTP 请求之前，判断用户是否登录：</p><ul><li>若未登录，跳转到登录页面；</li><li>若已登录，获取并保存用户的登录信息。</li></ul><p>先定义一个 UserInfoHolder 类保存用户的登录信息，其内部用 ThreadLocal 存储，示例如下：</p><pre><code>public class UserInfoHolder {    private static final ThreadLocal&lt;Map&lt;String, String&gt;&gt; USER_INFO_THREAD_LOCAL = new ThreadLocal&lt;&gt;();    public static void set(Map&lt;String, String&gt; map) {        USER_INFO_THREAD_LOCAL.set(map);    }        public static Map&lt;String, String&gt; get() {        return USER_INFO_THREAD_LOCAL.get();    }        public static void clear() {        USER_INFO_THREAD_LOCAL.remove();    }        // ...}</code></pre><p>通过 UserInfoHolder 可以存储和获取用户的登录信息，以便在业务中使用。</p><p>Spring 项目中，如果我们想在处理一个 HTTP 请求之前或之后做些额外的处理，通常定义一个类继承 HandlerInterceptorAdapter，然后重写它的一些方法。举例如下（仅供参考，省略了一些代码）：</p><pre><code>public class LoginInterceptor extends HandlerInterceptorAdapter {    // ...        @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {                // ...        // 请求执行前，获取用户登录信息并保存        Map&lt;String, String&gt; userInfoMap = getUserInfo();        UserInfoHolder.set(userInfoMap);        return true;    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) {        // 请求执行后，清理掉用户信息        UserInfoHolder.clear();    }}</code></pre><p>在本例中，我们在处理一个请求之前获取用户的信息，在处理完请求之后，将用户信息清空。应该有朋友在框架或者自己的项目中见过类似代码。</p><p>下面我们深入 ThreadLocal 的内部，来分析这些方法做了些什么，跟内存泄漏又是怎么扯上关系的。</p><h1 class=pgc-h-arrow-right><strong>3. 源码剖析</strong></h1><h1 class=pgc-h-arrow-right>3.1 类签名</h1><p>先从头开始，也就是类签名：</p><pre><code>public class ThreadLocal&lt;T&gt; {}</code></pre><p>可见它就是一个普通的类，并没有实现任何接口、也无父类继承。</p><h1 class=pgc-h-arrow-right>3.2 构造器</h1><p>ThreadLocal 只有一个无参构造器：</p><pre><code>public ThreadLocal() {}</code></pre><p>此外，JDK 1.8 引入了一个使用 lambda 表达式初始化的静态方法 withInitial，如下：</p><pre><code>public static &lt;S&gt; ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier) {    return new SuppliedThreadLocal&lt;&gt;(supplier);}</code></pre><p>该方法也可以初始化一个对象，和构造器也比较接近。</p><h1 class=pgc-h-arrow-right>3.3 ThreadLocalMap</h1><h1 class=pgc-h-arrow-right>3.3.1 主要代码</h1><p>ThreadLocalMap 是 ThreadLocal 的一个内部嵌套类。</p><p>由于 ThreadLocal 的主要操作实际都是通过 ThreadLocalMap 的方法实现的，因此先分析 ThreadLocalMap 的主要代码：</p><pre><code>public class ThreadLocal&lt;T&gt; {    // 生成 ThreadLocal 的哈希码，用于计算在 Entry 数组中的位置    private final int threadLocalHashCode = nextHashCode();    private static final int HASH_INCREMENT = 0x61c88647;    private static int nextHashCode() {        return nextHashCode.getAndAdd(HASH_INCREMENT);    }    // ...        static class ThreadLocalMap {        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {            Object value;            Entry(ThreadLocal&lt;?&gt; k, Object v) {                super(k);                value = v;            }        }            // 初始容量，必须是 2 的次幂        private static final int INITIAL_CAPACITY = 16;            // 存储数据的数组        private Entry[] table;        // table 中的 Entry 数量        private int size = 0;        // 扩容的阈值        private int threshold; // Default to 0            // 设置扩容阈值        private void setThreshold(int len) {            threshold = len * 2 / 3;        }                // 第一次添加元素使用的构造器        ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) {            table = new Entry[INITIAL_CAPACITY];            int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);            table[i] = new Entry(firstKey, firstValue);            size = 1;            setThreshold(INITIAL_CAPACITY);        }                // ...    }}</code></pre><p>ThreadLocalMap 的内部结构其实跟 HashMap 很类似，可以对比前面「JDK源码分析-HashMap(1)」对 HashMap 的分析。</p><p>二者都是「键-值对」构成的数组，对哈希冲突的处理方式不同，导致了它们在结构上产生了一些区别：</p><ol start=1><li>HashMap 处理哈希冲突使用的「链表法」。也就是当产生冲突时拉出一个链表，而且 JDK 1.8 进一步引入了红黑树进行优化。</li><li>ThreadLocalMap 则使用了「开放寻址法」中的「线性探测」。即，当某个位置出现冲突时，从当前位置往后查找，直到找到一个空闲位置。</li></ol><p>其它部分大体是类似的。</p><h1 class=pgc-h-arrow-right>3.3.2 注意事项</h1><ul><li>弱引用</li></ul><p>有个值得注意的地方是：ThreadLocalMap 的 Entry 继承了 WeakReference 类，也就是弱引用类型。</p><p>跟进 Entry 的父类，可以看到 ThreadLocal 最终赋值给了 WeakReference 的父类 Reference 的 referent 属性。即，可以认为 Entry 持有了两个对象的引用：ThreadLocal 类型的「弱引用」和 Object 类型的「强引用」，其中 ThreadLocal 为 key，Object 为 value。如图所示：</p><div class=pgc-img><img alt=从源码角度来剖析ThreadLocal到底有没有内存泄漏？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c><p class=pgc-img-caption></p></div><p>ThreadLocal 在某些情况可能产生的「内存泄漏」就跟这个「弱引用」有关，后面再展开分析。</p><ul><li>寻址</li></ul><p>Entry 的 key 是 ThreadLocal 类型的，它是如何在数组中散列的呢？</p><p>ThreadLocal 有个 threadLocalHashCode 变量，每次创建 ThreadLocal 对象时，这个变量都会增加一个固定的值 HASH_INCREMENT，即 0x61c88647，这个数字似乎跟黄金分割、斐波那契数有关，但这不是重点，有兴趣的朋友可以去深入研究下，这里我们知道它的目的就行了。与 HashMap 的 hash 算法的目的近似，就是为了散列的更均匀。</p><p>下面分析 ThreadLocal 的主要方法实现。</p><h1 class=pgc-h-arrow-right>3.4 主要方法</h1><p>ThreadLocal 主要有三个方法：set、get 和 remove，下面分别介绍。</p><h1 class=pgc-h-arrow-right>3.4.1 set 方法</h1><ul><li>set 方法：新增/更新 Entry</li></ul><pre><code>public void set(T value) {    // 获取当前线程    Thread t = Thread.currentThread();    // 从 Thread 中获取 ThreadLocalMap    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);}ThreadLocalMap getMap(Thread t) {    return t.threadLocals;}</code></pre><p>threadLocals 是 Thread 持有的一个 ThreadLocalMap 引用，默认是 null：</p><pre><code>public class Thread implements Runnable {    // 其他代码...    ThreadLocal.ThreadLocalMap threadLocals = null;}</code></pre><ul><li>执行流程</li></ul><p>若从当前 Thread 拿到的 ThreadLocalMap 为何，表示该属性并未初始化，执行 createMap 初始化：</p><pre><code>void createMap(Thread t, T firstValue) {    t.threadLocals = new ThreadLocalMap(this, firstValue);}</code></pre><p>若已存在，则调用 ThreadLocalMap 的 set 方法：</p><pre><code>private void set(ThreadLocal&lt;?&gt; key, Object value) {        Entry[] tab = table;    int len = tab.length;    // 1. 计算 key 在数组中的下标 i    int i = key.threadLocalHashCode &amp; (len-1);        // 1.1 若数组下标为 i 的位置有元素    // 判断 i 位置的 Entry 是否为空；不为空则从 i 开始向后遍历数组    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) {        ThreadLocal&lt;?&gt; k = e.get();                // 索引为 i 的元素就是要查找的元素，用新值覆盖旧值，到此返回        if (k == key) {            e.value = value;            return;        }                // 索引为 i 的元素并非要查找的元素，且该位置中 Entry 的 Key 已经是 null        // Key 为 null 表明该 Entry 已经过期了，此时用新值来替换这个位置的过期值        if (k == null) {            // 替换过期的 Entry，            replaceStaleEntry(key, value, i);            return;        }    }        // 1.2 若数组下标为 i 的位置为空，将要存储的元素放到 i 的位置    tab[i] = new Entry(key, value);    int sz = ++size;    // 若未清理过期的 Entry，且数组的大小达到阈值，执行 rehash 操作    if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)        rehash();}</code></pre><p>先总结下 set 方法主要流程：</p><p>首先根据 key 的 threadLocalHashCode 计算它的数组下标：</p><ol start=1><li>如果数组下标的 Entry 不为空，表示该位置已经有元素。由于可能存在哈希冲突，因此这个位置的元素可能并不是要找的元素，所以遍历数组去比较</li><ol start=1><li>如果找到等于当前 key 的 Entry，则用新值替换旧值，返回。</li><li>如果遍历过程中，遇到 Entry 不为空、但是 Entry 的 key 为空的情况，则会做一些清理工作。</li></ol><li>如果数组下标的 Entry 为空，直接将元素放到这里，必要时进行扩容。</li></ol><ul><li>replaceStaleEntry：替换过期的值，并清理一些过期的 Entry</li></ul><pre><code>private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value,                               int staleSlot) {    Entry[] tab = table;    int len = tab.length;    Entry e;        // 从 staleSlot 开始向前遍历，若遇到过期的槽（Entry 的 key 为空），更新 slotToExpunge    // 直到 Entry 为空停止遍历    int slotToExpunge = staleSlot;    for (int i = prevIndex(staleSlot, len);         (e = tab[i]) != null;         i = prevIndex(i, len))        if (e.get() == null)            slotToExpunge = i;        // 从 staleSlot 开始向后遍历，若遇到与当前 key 相等的 Entry，更新旧值，并将二者换位置    // 目的是把它放到「应该」在的位置    for (int i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) {        ThreadLocal&lt;?&gt; k = e.get();                if (k == key) {            // 更新旧值            e.value = value;                        // 换位置            tab[i] = tab[staleSlot];            tab[staleSlot] = e;                        // Start expunge at preceding stale entry if it exists            if (slotToExpunge == staleSlot)                slotToExpunge = i;            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);            return;        }                if (k == null &amp;&amp; slotToExpunge == staleSlot)            slotToExpunge = i;    }        // If key not found, put new entry in stale slot    // 若未找到 key，说明 Entry 此前并不存在，新增    tab[staleSlot].value = null;    tab[staleSlot] = new Entry(key, value);        // If there are any other stale entries in run, expunge them    if (slotToExpunge != staleSlot)        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);}</code></pre><p>replaceStaleEntry 的主要执行流程如下：</p><ol start=1><li>从 staleSlot 向前遍历数组，直到 Entry 为空时停止遍历。这一步的主要目的是查找 staleSlot 前面过期的 Entry 的数组下标 slotToExpunge。</li><li>从 staleSlot 向后遍历数组</li><ol start=1><li>若 Entry 的 key 与给定的 key 相等，将该 Entry 与 staleSlot 下标的 Entry 互换位置。目的是为了让新增的 Entry 放到它「应该」在的位置。</li><li>若找不到相等的 key，说明该 key 对应的 Entry 不在数组中，将新值放到 staleSlot 位置。该操作其实就是处理哈希冲突的「线性探测」方法：当某个位置已被占用，向后探测下一个位置。</li></ol><li>若 staleSlot 前面存在过期的 Entry，则执行清理操作。</li></ol><blockquote><p>PS: 所谓 Entry「应该」在的位置，就是根据 key 的 threadLocalHashCode 与数组长度取余计算出来的位置，即 k.threadLocalHashCode & (len - 1) ，或者哈希冲突之后的位置，这里只是为了方便描述。</p></blockquote><ul><li>expungeStaleEntry：清理过期的 Entry</li></ul><pre><code>// staleSlot 表示过期的槽位（即 Entry 数组的下标）private int expungeStaleEntry(int staleSlot) {    Entry[] tab = table;    int len = tab.length;        // 1. 将给定位置的 Entry 置为 null    tab[staleSlot].value = null;    tab[staleSlot] = null;    size--;        // Rehash until we encounter null    Entry e;    int i;    // 遍历数组    for (i = nextIndex(staleSlot, len);         (e = tab[i]) != null;         i = nextIndex(i, len)) {        // 获取 Entry 的 key        ThreadLocal&lt;?&gt; k = e.get();        if (k == null) {            // 若 key 为 null，表示 Entry 过期，将 Entry 置空            e.value = null;            tab[i] = null;            size--;        } else {            // key 不为空，表示 Entry 未过期            // 计算 key 的位置，若 Entry 不在它「应该」在的位置，把它移到「应该」在的位置            int h = k.threadLocalHashCode &amp; (len - 1);            if (h != i) {                tab[i] = null;                // Unlike Knuth 6.4 Algorithm R, we must scan until                // null because multiple entries could have been stale.                while (tab[h] != null)                    h = nextIndex(h, len);                tab[h] = e;            }        }    }    return i;}</code></pre><p>该方法主要做了哪些工作呢？</p><ol start=1><li>清空给定位置的 Entry</li><li>从给定位置的下一个开始向后遍历数组</li><ol start=1><li>若遇到 Entry 为 null，结束遍历</li><li>若遇到 key 为空的 Entry（即过期的），就将该 Entry 置空</li><li>若遇到 key 不为空的 Entry，而且经过计算，该 Entry 并不在它「应该」在的位置，则将其移动到它「应该」在的位置</li></ol><li>返回 staleSlot 后面的、Entry 为 null 的索引下标</li></ol><ul><li>cleanSomeSlots：清理一些槽（Slot）</li></ul><pre><code>private boolean cleanSomeSlots(int i, int n) {    boolean removed = false;    Entry[] tab = table;    int len = tab.length;    do {        i = nextIndex(i, len);        Entry e = tab[i];        // Entry 不为空、key 为空，即 Entry 过期        if (e != null &amp;&amp; e.get() == null) {            n = len;            removed = true;            // 清理 i 后面连续过期的 Entry，直到 Entry 为 null，返回该 Entry 的下标            i = expungeStaleEntry(i);        }    } while ( (n &gt;&gt;&gt;= 1) != 0);    return removed;}</code></pre><p>该方法做了什么呢？从给定位置的下一个开始扫描数组，若遇到 key 为空的 Entry（过期的），则清理该位置及其后面过期的槽。</p><p>值得注意的是，该方法循环执行的次数为 log(n)。由于该方法是在 set 方法内部被调用的，也就是新增/更新时：</p><ol start=1><li>如果不扫描和清理，set 方法执行速度很快，但是会存在一些垃圾（过期的 Entry）；</li><li>如果每次都扫描清理，不会存在垃圾，但是插入性能会降低到 O(n)。</li></ol><p>因此，这个次数其实就一种平衡策略：Entry 数组较小时，就少清理几次；数组较大时，就多清理几次。</p><ul><li>rehash：调整 Entry 数组</li></ul><pre><code>private void rehash() {    // 清理数组中过期的 Entry    expungeStaleEntries();    // Use lower threshold for doubling to avoid hysteresis    if (size &gt;= threshold - threshold / 4)        resize();}// 从头开始清理整个 Entry 数组private void expungeStaleEntries() {    Entry[] tab = table;    int len = tab.length;    for (int j = 0; j &lt; len; j++) {        Entry e = tab[j];        if (e != null &amp;&amp; e.get() == null)            expungeStaleEntry(j);    }}</code></pre><p>该方法主要作用：</p><ol start=1><li>清理数组中过期的 Entry</li><li>若清理后 Entry 的数量大于等于 threshold 的 3/4，则执行 resize 方法进行扩容</li></ol><ul><li>resize 方法：Entry 数组扩容</li></ul><pre><code>/** * Double the capacity of the table. */private void resize() {    Entry[] oldTab = table;    int oldLen = oldTab.length;    int newLen = oldLen * 2; // 新长度为旧长度的两倍    Entry[] newTab = new Entry[newLen];    int count = 0;        // 遍历旧的 Entry 数组，将数组中的值移到新数组中    for (int j = 0; j &lt; oldLen; ++j) {        Entry e = oldTab[j];        if (e != null) {            ThreadLocal&lt;?&gt; k = e.get();            // 若 Entry 的 key 已过期，则将 Entry 清理掉            if (k == null) {                e.value = null; // Help the GC            } else {                // 计算在新数组中的位置                int h = k.threadLocalHashCode &amp; (newLen - 1);                // 哈希冲突，线性探测下一个位置                while (newTab[h] != null)                    h = nextIndex(h, newLen);                newTab[h] = e;                count++;            }        }    }        // 设置新的阈值    setThreshold(newLen);    size = count;    table = newTab;}</code></pre><p>该方法的作用是 Entry 数组扩容，主要流程：</p><ol start=1><li>创建一个新数组，长度为原数组的 2 倍；</li><li>从下标 0 开始遍历旧数组的所有元素</li><ol start=1><li>若元素已过期（key 为空），则将 value 也置空</li><li>将未过期的元素移到新数组</li></ol></ol><h1 class=pgc-h-arrow-right>3.4.2 get 方法</h1><p>分析完了 set 方法，再看 get 方法就相对容易了不少。</p><ul><li>get 方法：获取 ThreadLocal 对应的 Entry</li></ul><pre><code>public T get() {    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null) {        ThreadLocalMap.Entry e = map.getEntry(this);        if (e != null) {            @SuppressWarnings("unchecked")            T result = (T)e.value;            return result;        }    }    return setInitialValue();}</code></pre><p>get 方法首先获取当前线程的 ThreadLocalMap 并判断：</p><ol start=1><li>若 Map 已存在，从 Map 中取值</li><li>若 Map 不存在，或者 Map 中获取的值为空，执行 setInitialValue 方法</li></ol><ul><li>setInitialValue 方法：获取/设置初始值</li></ul><pre><code>private T setInitialValue() {    // 获取初始值    T value = initialValue();    Thread t = Thread.currentThread();    ThreadLocalMap map = getMap(t);    if (map != null)        map.set(this, value);    else        createMap(t, value);    return value;}protected T initialValue() {    return null;}</code></pre><p>选取初始值，这个初始值默认为空（该方法是 protected，可以由子类初始化）。</p><ol start=1><li>若 Thread 的 ThreadLocalMap 已初始化，则将初始值存入 Map</li><li>否则，创建 ThreadLocalMap</li><li>返回初始值</li></ol><p>除了初始值，其他逻辑跟 set 方法是一样的，这里不再赘述。</p><blockquote><p>PS: 可以看到初始值是惰性初始化的。</p></blockquote><ul><li>getEntry：从 Entry 数组中获取给定 key 对应的 Entry</li></ul><pre><code>private Entry getEntry(ThreadLocal&lt;?&gt; key) {    // 计算下标    int i = key.threadLocalHashCode &amp; (table.length - 1);    Entry e = table[i];    // 查找命中    if (e != null &amp;&amp; e.get() == key)        return e;    else        return getEntryAfterMiss(key, i, e);}// key 未命中private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) {    Entry[] tab = table;    int len = tab.length;        // 遍历数组    while (e != null) {        ThreadLocal&lt;?&gt; k = e.get();        if (k == key)            return e; // 是要找的 key，返回        if (k == null)            expungeStaleEntry(i); // Entry 已过期，清理 Entry        else            i = nextIndex(i, len); // 向后遍历        e = tab[i];    }    return null;}</code></pre><h1 class=pgc-h-arrow-right>3.4.3 remove 方法</h1><ul><li>remove 方法：移除 ThreadLocal 对应的 Entry</li></ul><pre><code>public void remove() {    ThreadLocalMap m = getMap(Thread.currentThread());    if (m != null)        m.remove(this);}</code></pre><p>这里调用了 ThreadLocalMap 的 remove 方法：</p><pre><code>private void remove(ThreadLocal&lt;?&gt; key) {    Entry[] tab = table;    int len = tab.length;    int i = key.threadLocalHashCode &amp; (len-1);    for (Entry e = tab[i];         e != null;         e = tab[i = nextIndex(i, len)]) {        if (e.get() == key) {            e.clear();            expungeStaleEntry(i);            return;        }    }}</code></pre><p>其中 e.clear 调用的是 Entry 的父类 Reference 的 clear 方法：</p><pre><code>public void clear() {    this.referent = null;}</code></pre><p>其实就是将 Entry 的 key 置空。</p><p>remove 方法的主要执行流程如下：</p><ol start=1><li>获取当前线程的 ThreadLocalMap</li><li>以当前 ThreadLocal 作为 key，从 Map 中查找相应的 Entry，将 Entry 的 key 置空</li><li>将该 ThreadLocal 对应的 Entry 置空，并向后遍历清理 Entry 数组，也就是 expungeStaleEntry 方法的操作，前面已经分析过了，这里不再赘述。</li></ol><h1 class=pgc-h-arrow-right>3.4.4 主要方法小结</h1><p>ThreadLocal 的主要方法 set、get 和 remove 前面已经分析过，这里简单做个小结。</p><p><strong>set 方法</strong></p><ul><li>以当前 ThreadLocal 为 key、新增的 Object 为 value 组成一个 Entry，放入 ThreadLocalMap，也就是 Entry 数组中。</li><li>计算 Entry 的位置后</li><ul><li>若该槽为空，直接放到这里；并清理一些过期的 Entry，必要时进行扩容。</li><li>当遇到散列冲突时，线性探测向后查找数组中为空的、或者已经过期的槽，用新值替换。</li></ul></ul><p><strong>get 方法</strong></p><ul><li>以当前 ThreadLocal 为 key，从 Entry 数组中查找对应 Entry 的 value</li><ul><li>若 ThreadLocalMap 未初始化，则用给定初始值将其初始化</li><li>若 ThreadLocalMap 已初始化，从 Entry 数据查找 key</li></ul></ul><p><strong>remove 方法</strong>：以当前 ThreadLocal 为 key，从 Entry 数组清理掉对应的 Entry，并且在清理该位置后面的、过期的 Entry</p><p>方法虽少，但是稍微有点绕，除了做本身的功能，都执行了一些额外的清理操作。</p><p>分析了这几个方法的源码之后，下面就来研究一下内存泄漏的问题。</p><h1 class=pgc-h-arrow-right><strong>4. 内存泄漏分析</strong></h1><p>首先说明一点，ThreadLocal 通常作为成员变量或静态变量来使用（也就是共享的），比如前面应用场景中的例子。因为局部变量已经在同一条线程内部了，没必要使用 ThreadLocal。</p><p>为便于理解，这里先给出了 Thread、ThreadLocal、ThreadLocalMap、Entry 这几个类在 JVM 的内存示意图：</p><div class=pgc-img><img alt=从源码角度来剖析ThreadLocal到底有没有内存泄漏？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dba5231875bc4d2ab20e9a14db35bfc8><p class=pgc-img-caption></p></div><p>简单说明：</p><ul><li>当一个线程运行时，栈中存在当前 Thread 的栈帧，它持有 ThreadLocalMap 的强引用。</li><li>ThreadLocal 所在的类持有一个 ThreadLocal 的强引用；同时，ThreadLocalMap 中的 Entry 持有一个 ThreadLocal 的弱引用。</li></ul><h1 class=pgc-h-arrow-right>4.1 场景一</h1><p>若方法执行完毕、线程正常消亡，则 Thread 的 ThreadLocalMap 引用将断开，如图：</p><div class=pgc-img><img alt=从源码角度来剖析ThreadLocal到底有没有内存泄漏？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c67c517fbb87439a8773efe787506a13><p class=pgc-img-caption></p></div><p>以后 GC 发生时，弱引用也会断开，整个 ThreadLocalMap 都会被回收掉，不存在内存泄漏。</p><h1 class=pgc-h-arrow-right>4.2 场景二</h1><p>如果是线程池中的线程呢？也就是线程一直存活。经过 GC 后 Entry 持有的 ThreadLocal 引用断开，Entry 的 key 为空，value 不为空，如图所示：</p><div class=pgc-img><img alt=从源码角度来剖析ThreadLocal到底有没有内存泄漏？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/979e33306e154bcf8a4b1523223ba434><p class=pgc-img-caption></p></div><p>此时，如果没有任何 remove 或者 get 等清理 Entry 数组的动作，那么该 Entry 的 value 持有的 Object 就不会被回收掉。这样就产生了内存泄漏。</p><p>这种情况其实也很容易避免，使用完执行 remove 方法就行了。</p><h1 class=pgc-h-arrow-right><strong>5. 小结</strong></h1><p>本文分析了 ThreadLocal 的主要方法实现，并分析了它可能存在内存泄漏的场景。</p><ol start=1><li>ThreadLocal 主要用于当前线程从共享变量中保存一份「副本」，常用的一个场景就是单点登录保存用户的登录信息。</li><li>ThreadLocal 将数据存储在 ThreadLocalMap 中，ThreadLocalMap 是由 Entry 构成的数组，结构有点类似 HashMap。</li><li>ThreadLocal 使用不当可能会造成内存泄漏。避免内存泄漏的方法是在方法调用结束前执行 ThreadLocal 的 remove 方法。</li></ol></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'从源码','ThreadLocal','内存'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>