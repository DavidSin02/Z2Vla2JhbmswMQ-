<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SysML 2019论文解读：推理优化 | 极客快訊</title><meta property="og:title" content="SysML 2019论文解读：推理优化 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/aec50a880ead4851ab2b50759d749720"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/efd74a95.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/efd74a95.html><meta property="article:published_time" content="2020-10-29T21:11:12+08:00"><meta property="article:modified_time" content="2020-10-29T21:11:12+08:00"><meta name=Keywords content><meta name=description content="SysML 2019论文解读：推理优化"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/efd74a95.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SysML 2019论文解读：推理优化</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote>推理优化是机器学习领域的核心问题之一，本文将解读 SysML 会议上两篇与推理优化有关的论文，其中一篇提出了准确高效的二位量化神经网络，另一篇则试图用宽松化图替代优化深度神经网络的计算过程。</blockquote><p class=ql-align-justify><br></p><p class=ql-align-justify>声明：本文的所有图片和公式都来自于原论文。</p><ul><li class=ql-align-justify>论文1：Accurate and Efficient 2-Bit Quantized Neural Netowrks</li><li class=ql-align-justify>地址：https://www.sysml.cc/doc/2019/168.pdf</li></ul><p class=ql-align-justify><br></p><p class=ql-align-center><strong>引言</strong></p><p class=ql-align-justify>随着机器学习和人工智能领域的持续发展，神经网络及其代表性的算法通过提升计算成本而实现了越来越高的准确度。量化（quantization）是一种以准确度为代价旨在降低计算成本的方法。为了在尽可能小地损失准确度的同时尽可能多地减少计算，研究者们已经提出了多种不同的量化方案。</p><p class=ql-align-justify>通常来说，量化可用在两个地方，即神经网络的权重和激活。在学习机器学习时，这一类工作往往会被忽视，但如果考虑到实用性，这又非常重要。因此，我决定解读这篇论文。</p><p class=ql-align-justify>为了单独实现各个权重和激活的量化，进而得到整体的量化神经网络（QNN），这篇论文提出了一些新技术。其中用于激活量化的技术为「PArameterized Clipping acTivation（PACT）」，用于权重量化的技术则为「Statistics-Aware Weight Binning（SAWB）」。</p><p class=ql-align-justify>这篇论文声称，组合使用 PACT 与 SAWB 可以得到一种二位量化神经网络（2-bit QNN），其分类准确度在一些常见的模型和数据集上能达到当前最佳水平。</p><p class=ql-align-center><strong>量化研究</strong></p><p class=ql-align-justify>简单来说，量化是指降低表示一个数值的位数的过程。在机器学习领域，之前研究主要使用的数值格式是 32 位浮点数，或根据 CPU 不同甚至还会使用 64 位（虽然实际中不会有人用这么多 bits 来训练网络）。</p><p class=ql-align-justify>但是，为了实现机器学习模型的实际部署，有必要降低模型所需的带宽和计算量。这有助于降低计算成本和功耗，并提升速度。很多研究结果已经表明，使用 8 位整型数表示权重和激活不会显著影响准确度。</p><p class=ql-align-center><strong>参数化截略式激活（PACT）</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>激活量化</strong></p><p class=ql-align-justify>卷积神经网络（CNN）常使用 ReLU 作为激活函数。ReLU 的困难之处在于其输出没有限界，这意味着量化需要较大的输出范围（即更大的位宽）。当目标位宽有限时，这就成问题了。图 1 给出了使用 ReLU 的 ResNet10 在 CIFAR10 数据集上的训练和验证误差；当 ReLU 激活被量化为 2 位时，准确度明显下降。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/aec50a880ead4851ab2b50759d749720><p class=pgc-img-caption>图 1：当使用 ReLU 或截略函数的 CIFAR10 ResNet10 的激活被量化到 2 位时，</p></div><p class=ql-align-justify>截略（clipping）是一种为解决大输出范围问题而开发的方法。其会在输出激活的幅度上加一个上界。我们也可以在图 1 中看到网络使用了截略方法时的训练和验证误差。这个误差比没使用截略时更低，但这是不可接受的。这就引出了这篇论文的贡献。</p><p class=ql-align-justify>PACT 技术基于以上见解，这是一种使用了一个参数化元素的截略方法。现在，激活函数有一个参数化的截略水平 α。α 可在训练阶段通过随机梯度下降（SGD）进行动态调整，以最小化准确度下降。PACT ReLU 输出的形式化定义如下：</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/af501ab1cb944d2989a42ae381079f33><p class=pgc-img-caption></p></div><p class=ql-align-justify>α 将激活函数的输出范围限制到了 [0, α]。本质上讲，这只是为损失函数的优化引入一个新参数 α，并在反向传播步骤中选出 α 的最优值。图 2 给出了带有参数化截略的 PACT 激活函数。随着 α→∞，该函数会向 ReLU 函数收敛。因此，α 让人可根据实际情况灵活地调整输出范围。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7ae6c83fc7854cdbaa09d0151002da75><p class=pgc-img-caption>图 2：PACT 激活函数及其梯度</p></div><p class=ql-align-justify>如前所述，α 的值可通过 SGD 更新。设 L 为损失函数，y 为网络的输出。在每次迭代时，α 遵循以下更新规则：</p><ol><li class=ql-align-justify>如果 x ≤ α，则 PACT 的行为类似常规 ReLU，α 不更新。</li><li class=ql-align-justify>如果 x > α，则 α 通过以下公式使用 SGD 更新。</li></ol><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/184a620a76e44e1592868c6029ffa785><p class=pgc-img-caption></p></div><p class=ql-align-justify>其中 η 是学习率。∂L/∂α = ∂L/∂y 的原因是 ∂L/∂y = 1（参见图 2）。</p><p class=ql-align-justify>注意，这里一个网络仅有一个 α。也就是说，PACT 会整体考虑所有输出神经元并更改 α 参数。所得到的 PACT 的训练和验证误差如图 3 所示。可以看到，PACT 的误差会收敛到使用常规 ReLU 的网络的误差。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0a04c9bc33bd4c4299cf7e34ff8c801c><p class=pgc-img-caption>图 3：使用 PACT 的 CIFAR10 ResNet20 的训练误差（a）和验证误差（b）。注意</p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>截略误差与量化误差的平衡</strong></p><p class=ql-align-justify>如前所见，参数化截略式 ReLU 函数的表现仍可比肩常规的不限界的 ReLU 函数。较大的 α 可得到较大的输出范围，但需要量化的比特也更多。因此，α 和量化位宽之间存在一个权衡。</p><p class=ql-align-justify>PACT 可以有效找到截略误差和量化误差之间的平衡点，其方法是基于输出与目标的相近程度来调整输出的范围，即如果目标输出有较大的幅度，PACT 会调整到更高的 α 值。截略误差和量化误差都会使输出偏离目标，PACT 会在训练期间增大或降低输出范围，以尽力最小化这两个误差。</p><p>在图 4 中，(a) 当使用 2 位量化时，截略和量化相对于参数 α 的归一化均方误差（MSE）之间的权衡。(b) 展示了 PACT 为 QNN 找到截略和量化误差的平衡的方式。在训练中，CIFAR10 ResNet20 的截略式激活函数使用了 1 到 16 的不同截略水平。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b4d3aa59b19e410687fb7631651e8f90><p class=pgc-img-caption>图 4</p></div><p class=ql-align-justify><em>(a) 截略和量化相对于 α 的归一化 MSE。(b) 在一个 2 位量化的模型上，PACT 的最低验证误差和截略的验证误差在不同 α 上的比较。</em></p><p class=ql-align-justify>可以看到，当激活被量化为 2 位时，使用截略式激活函数的网络的准确度会随 α 增大而显著下降。总结一下，PACT 的目标是选出最优的 α，从而同时最小化量化误差和截略误差，其结果是能实现相对较低的截略误差和可能最低的量化误差。</p><p class=ql-align-center><br></p><p class=ql-align-center><strong>统计感知式权重分箱（SAWB）</strong></p><p class=ql-align-justify>这篇论文的另一个贡献是权重的量化。其主要思想是利用权重分布的统计情况，即一阶矩和二阶矩。量化比例的确定方式是使权重的分散情况能在训练过程中更好地得到。</p><p class=ql-align-justify>这种量化方法是均匀的和对称的，因此也是对硬件友好的。此外，量化水平可由 α 确定。图 5 给出了一个 2 位量化的示例，其量化水平参数为 α_w。权重的均值 E(|w|) 应该在 [-α_w, α_w] 范围内。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d6e455ac5f2460c97e185cb3d0441cb><p class=pgc-img-caption>图 5：(a) 根据参数α_w 选出量化的 4 个点。(b) 根据 6 个不同的分布执行最优比例的线</p></div><p class=ql-align-justify>图 5(a) 中假设权重统计分布近似一个高斯分布，但通常观察到的情况是：权重分布的形状会在训练过程中随反向传播通路的集合而变化，从而变得不同于高斯分布。这就使得整个基础假设无效了，这又反过来会增大量化误差。</p><p>这篇论文提出不仅要考虑 E(|w|)，而且还要考虑 E(w^2)。直观而言，二阶矩 E(w^2) 能体现分布的整体形状，而一阶矩 E(|w|) 则会给出有代表性的值。研究者根据经验推导了一个简单公式，可为更多不同的分布求取一个通用的最优比例 α_w*；该公式如下：</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bedc9aa5b248404398c355c9b4973424><p class=pgc-img-caption></p></div><p class=ql-align-justify>系数 c1 和 c2 是根据在不同分布（即高斯分布、均匀分布、拉普拉斯分布等）上的线性回归而预先确定的。这可能看起来有些令人质疑，因此我会尝试概括这里的研究，并解释每一个步骤。和这篇论文中所有研究一样，其量化是 2 位式的（4 级）。</p><ol><li class=ql-align-justify>问题是这样的：「我们如何设置权重值的 4 个量化层级，使得我们可将权重值映射到其最近的量化层级并且准确度的降低最小？」一种最简单方法是设置量化层级时使得均值在其中心。（见图 5(a)）</li><li class=ql-align-justify>不只是使用均值，我们还使用权重值的二阶矩来提供有关分布的整体形状的见解。</li><li class=ql-align-justify>α_w* 是一阶矩和二阶矩的函数，因此作者研究了最优比例与一阶矩和二阶矩在不同相关分布上的关系。图 5(b) 给出了 α_w*/E(|w|)（X 轴）与 √ E(w2)/E(|w|)（Y 轴）在六种分布（用不同颜色表示）上的相对情况。每个点都表示通过在 α_w 上扫描而得到的分布的最优比例。</li><li class=ql-align-justify>执行简单的线性回归以学习参数 c1 和 c2，本质上就是 6 个点（6 个不同分布假设）的线性拟合，从而找到 c1 和 c2 的最优值。（见图 5(b)）</li><li class=ql-align-justify>一旦确定了 c1 和 c2，在训练新模型时就可直接使用 c1 和 c2 来计算 α_w*，无需再完整扫描整个 α_w。</li></ol><p class=ql-align-justify><br></p><p>表 1 给出了在使用 2 位权重量化时，CIFAR10 ResNet20 的第 11 层在不同 epoch 的最优平方误差（SE）和 SAWB 估计的比例因子的平方误差。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c2a682ff02eb4ef2901199102e923706><p class=pgc-img-caption>表 1：最优和 SAWB 的平方误差（SE）</p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>可以看到，SAWB 的误差略高于最优 α_w* 的误差。因此，这能激励人们使用这个封闭解来计算 α_w，这会比在 α_w 上执行完整扫描快很多，而且准确度损失也很小。</p><p class=ql-align-center><strong>实验</strong></p><p class=ql-align-justify><strong>CIFAR10 实验</strong></p><p class=ql-align-justify>PACT 和 SAWB 都在 TensorFlow（Abadi et al., 2015）中用 Tensorpack (Zhou et al., 2016) 实现，并且论文中也研究了多种著名的 CNN：在 CIFAR10 数据集上的 ResNet20/32/44/56 (He et al., 2016b)。</p><p>该论文估计了带有 (20,32,44,56) 层的 CIFAR10 ResNet 的激活和权重量化方案。表 3 总结了仅进行激活量化、仅进行权重量化、进行激活量化且权重量化后的准确度。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f016abebea004030bcb5ba83c117494f><p class=pgc-img-caption></p></div><p class=ql-align-justify><em>表 3：CIFAR10 ResNet20/32/44/56 仅进行激活量化、仅进行权重量化、进行激活量化且权重量化后的验证误差。小写字母 s 和 p 分别表示 SAWB 和 PACT。这两种量化方案仅会导致准确度少量下降。当同时部署了 PACT 和 SAWB 时，PACT-SAWB 能在各种变体的 CIFAR10 ResNet 上保证 3% 以内的准确度损失。</em></p><p class=ql-align-justify><strong>ImageNet 实验</strong></p><p>研究者还在 ImageNet 数据集上执行了另一组测试 PACT 和 SAWB 的实验。研究者也比较了 PACT-SAWB 与其它 2 位量化方案。结果见表 2。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c80962a46f0425286b2e35b45f0d8a8><p class=pgc-img-caption>表 2：ImageNet：top-1 测试准确度（%）和准确度下降情况比较</p></div><p class=ql-align-justify>可以看到，对于在所有三个网络（AlexNet、ResNet18 和 ResNet50）上的 2 位 QNN，PACT-SAWB 都实现了较高的准确度，准确度损失也都最低。注意，我们之前讨论的 PACT-SAWB 和 PACT-SAWB-fpsc 之间有些许不同。PACT-SAWB-fpsc 是指带有全精度快捷连接（full-precision shortcut connections）的 PACT-SAWB。</p><p class=ql-align-justify>不多说细节，快捷连接就是跳过一层或多层的路径，对 ResNet 等一些神经网络的架构而言很关键。有观察发现，当使用快捷连接进行训练时，2 位 QNN 的训练误差的下降速度更慢。因此，对于这些类型的网络，快捷连接将保持不量化，也由此得名全精度快捷连接。这可被视为 PACT-SAWB 的一种变体，其中由于没有量化，以计算成本为代价能实现准确度的提升。</p><p class=ql-align-center><strong>总结和讨论</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>这篇论文介绍了两种分别针对权重量化和激活量化的技术，并且进而能得到整体的量化神经网络（QNN）。其中，激活量化技术是参数化截略式激活（PACT），这是一种在训练期间使用 ReLU 函数的参数化截略来确定量化的输出范围的方案。权重量化方案名为统计感知式权重分箱（SAWB），可基于权重分布的统计特性确定能最小化量化误差的最优比例因子，无需执行穷举搜索。</p><p class=ql-align-justify>在我看来，PACT 中的动态范围自动调节是一个很有趣的概念，可以实现大规模量化神经网络的稳健训练。但是，我主要担心的是仅使用二位量化能否有效得到大的输出范围。正如之前提到的那样，量化是降低表示一个数值的位数的过程。这对降低计算成本而言很关键，尤其是对于当今的手持设备而言。</p><p class=ql-align-justify>就我所知，当前移动设备的最小位数是使用 8 位量化执行推理计算（我没找到任何有关训练的数据）。如果读者感兴趣，也许可以查找一下是否有任何产品在其机器学习框架中使用了低于 8 位量化的方案（不管是训练还是推理）。</p><p class=ql-align-justify>至于权重量化方案，在我看来，为什么通过不同分布生成的「最佳」数据点的线性回归得到的系数 c1 和 c2 是一组优解，这一点没能说清。我希望读者也能思考一下这个问题，究竟为什么我们不能把权重看作高斯分布呢？</p><p class=ql-align-justify>我同意作者说的权重分布的形状会在训练过程中随反向传播通路的集合而变化，从而变得不同于高斯分布。但是，如果我们将每次反向传播通路视为一个「样本」并计算每个样本的汇总统计信息，则可以预见这些汇总统计情况遵循正态分布——即使你不知道你的样本的分布。这不过就是应用中心极限定理而已。</p><p class=ql-align-justify>因此，为什么作者会无视这在准确度劣化方面所表现出的潜力呢？这个问题很有意思。我讨论这个问题的另一个原因是想问读者：预先确定 c1 和 c2 并在整个训练阶段使用它们的做法是否合理？使用固定参数似乎有碍「学习」的目的。</p><p class=ql-align-justify>总体而言，这两项新提出的方案是很有趣的，也带来了一些富有成效的讨论以及一些不错的结果。我认为这是一篇值得一读的好论文，因为随着手持式移动设备变得越来越重要，量化问题必然会成为一个至关重要的研究领域。</p><ul><li class=ql-align-justify><strong>论文2：Optimizing DNN Computation With Relaxed Graph Substitution</strong></li><li class=ql-align-justify>地址：https://www.sysml.cc/doc/2019/22.pdf</li></ul><p class=ql-align-justify><br></p><p class=ql-align-center><strong>引言</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>深度神经网络（DNN）已在很多实际问题中取得了进展，比如图像分类、机器翻译和游戏。这些进展往往伴随着 DNN 越来越大、越来越深的代价，也由此带来了更高的计算成本需求。因此，缓解越来越高的计算需求问题是一个亟需关注的领域。</p><p class=ql-align-justify>最简单形式的 DNN 可被视为由（数学）算子组成的计算图。TensorFlow、PyTorch 和 TVM 等已有的深度学习软件全都会将计算表达为有状态的数据流图。这些图会在训练期间得到优化，并会在整个过程中变换。</p><p class=ql-align-justify>在每次迭代（或变换）时，新图相比于迭代前的图通常会有严格更好的运行时间性能。这种「严格更好」会得到深度学习框架的非常受限的搜索空间，也是高计算成本的一大原因。直观地说，可以认为优化问题存在诸多约束。约束越多，算法得到解的时间就会越长。</p><p class=ql-align-justify>因此为了降低计算成本，这篇论文提出了一种宽松化的图替代方法，可通过放松每个迭代约束的「严格更好」来实现复杂图优化的探索。这能增大问题的可行空间，并能在每次迭代时更快找到解。此外，研究者还引入了回溯方法（backtracking），可搜索一组宽松化图替代来寻找每次迭代的最优解（没有严格更好的约束）。</p><p class=ql-align-center><strong>术语和符号</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>我们用 G 表示计算图，I 表示输入张量，O 表示输出张量。三者之间的关系可写为 O = G(I)。如果两个图 G 和 G' 在输入一样时得到的输出也一样，则认为这两个图等价，即 G(I) = G'(I)。寻找图 G 的等价图 G' 的过程在一个名为 MetaFlow 的系统中实现，其可被用于优化已有的深度学习框架的 DNN 计算图，即 MetaFlow 是用于 DNN 的宽松化图替代优化器。</p><p class=ql-align-justify>下一个术语是源图（source graph）。源图是指定义了可用作替代的可用子图的结构的图。</p><ul><li class=ql-align-justify>源图中的每个节点都关联了一种类型，并且仅可被映射到同种类型的算子，即卷积必须映射到卷积，仅有核、步幅、填充等参数的差异。</li><li class=ql-align-justify>源图中的每条边都描述了算子之间的数据依赖性。替代要求新图的数据依赖性与源图的一样。</li></ul><p class=ql-align-justify><br></p><p>下一个术语是目标图（target graph）。目标图描述的是如何构建新的子图来替换当前的子图。图 1 给出了一个示例，其中给出了一组等价的源图和目标替换图。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/52df5ef3616343df8d400883eb2140c2><p class=pgc-img-caption>图 1：源图和目标图，两者执行一样的运算</p></div><p class=ql-align-justify>可以看到，目标图是将两个卷积「融合」为了一个运算，之后再分开。注意 op1 和 op2 有同样的输出 op1.out，通过拆分 conv3 的结果，我们可以得到 conv1.out 和 conv2.out，它们分别等价于 conv1 和 conv2 的输出。</p><p class=ql-align-justify>在 conv1 和 conv2 上的约束确保它们仅可映射到同样核大小、步幅和填充的卷积。此外，虚线被称为外部边（external edge）。外部边只是表示算子的输出可由外部算子读取，并且必须被保留。</p><p class=ql-align-justify>所有这些可能看起来相当抽象，难以理解，但我认为其类似于以下直觉理解。如果 conv3 是一个 3×3 卷积，其核为</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/79145317fce24dad87c05be34731e31c><p class=pgc-img-caption></p></div><p class=ql-align-justify>可分解为</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6de5eb6f00724426a1ed13ac425d59f0><p class=pgc-img-caption></p></div><p class=ql-align-justify>因此，我们可以不用 3×3 大小的核执行卷积（9 次乘法），而是使用两个 1×3 核执行卷积（6 次乘法）。结果还是一样，但从计算角度看，每次卷积的成本更低了。此外，通过将卷积分为两个可以并行执行的更小卷积，执行整个卷积的速度也可能会更快。</p><p class=ql-align-justify>尽管图 1 是用一个卷积替换两个卷积，但这个示例是将一个卷积拆分为两个。我认为这一思路两个方向都有效，而且这正是图替换思想背后的基本直觉。如果源图和目标图计算出的输出在外部边上是数学上等价的，则图替代就是有效的。</p><p class=ql-align-justify>最后说明一点，宽松化的思路可按如下方式展示。考虑以下等价表达式以及从上面的表达式到下面的表达式所采取的步骤。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3391b0a2946044b9864b54edbe618026><p class=pgc-img-caption></p></div><p class=ql-align-justify>最后的表达式仅有 3 个算子，说明实现了优化。但是，如果系统每次迭代时都有约束——新子图必须严格优于当前子图；则第二个表达式就不会被允许，因此也就无法得到最终的表达式。这就体现了放松约束条件（宽松化）的重要性。</p><p class=ql-align-center><strong>MetaFlow 搜索算法</strong></p><p class=ql-align-justify><br></p><p class=ql-align-justify>图替代的难点在于在搜索空间中找到最优的图。原因是搜索空间可能非常大，因此穷举搜索空间中的所有图是不可行的。MetaFlow 搜索算法的设计目的就是为替代在大搜索空间中有效找到经过优化的图（但不必是最优的）。</p><p class=ql-align-justify><strong>成本函数</strong></p><p class=ql-align-justify>与任何优化一样，首先必须定义一个成本。这个案例中的成本模型计算的是 FLOPs、内存使用量以及核启动次数等指标。对于图中的每个算子，都有针对这些指标的关联成本，而且这些指标可以组合起来得到图的总成本。</p><p class=ql-align-justify>一个关键的观察是，大多数 DNN 算子都涉及到线性代数，如果给定一样的参数，其在硬件上会有一致的且可预测的性能表现。这使得成本计算更容易，因为如果我们已经测量并保存了带有特定参数的算子的执行时间，我们就可以为图中其它部分的具有同样参数的同样算子使用该执行时间。</p><p class=ql-align-justify><strong>回溯搜索</strong></p><p class=ql-align-justify>这篇论文提出了一种回溯搜索方法，用于寻找一个成本模型下最优的计算图。算法 1 给出了其伪代码。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9cba923d60fb40f29af93c7824fd6605><p class=pgc-img-caption></p></div><p class=ql-align-justify>可以看到，所有的潜在图都排列成一个全局优先级队列，并且按照它们的成本以递增顺序移出队列。对于每个被移出队列的图 G，搜索算法都会通过在 G 上应用新的潜在图替代来生成和排列新的图。参数 α（算法 1 的第 13 行）被用于缩放当前最优 G 的损失。更近一步，我们可以直观地理解三种情况中的 α：</p><ul><li class=ql-align-justify>(0&lt; α &lt;1)：这可以被认为是「鼓励」算法保持当前的解。只有当新图 G' 的成本有明显改善时，算法才会更新当前最优的图。这有希望实现算法加速。</li><li class=ql-align-justify>(α = 1)：这与实现一个贪婪算法一样，且仅考虑严格降低成本的图替代。</li><li class=ql-align-justify>(α > 1) ：这可被视为「扩展」搜索空间，因为条件更加宽松。这个算法有希望找到最终能得到更优解的中间解。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>回溯到思想出现在算法 1 的第 14 行。假设 α > 1，如果当前图 G' 有更低的成本，这会被加回到队列中。这是因为未来的迭代有可能将 G' 替换为另一个解 G''，而 G'' 有可能最终得到更差的解。因此，将 G' 留在队列中能为算法提供追溯能力，从而防止当前路径不佳的问题。</p><p class=ql-align-justify><strong>基于流的递归式图拆分</strong></p><p class=ql-align-justify>很多当前最佳的 DNN 模型都太大了，难以直接使用回溯搜索来优化。但是，为了解决这个问题，可以使用一个有用的观察。也即，图替代可以在少量局部相连的算子上独立地执行。</p><p class=ql-align-justify>因此，将计算图拆分为更小的单个子图并单个地检查它们能让问题变得更小，同时还能保证所得到的图替代有效。基于这一见解，作者提出了一种基于流的图拆分算法，以递归式地将计算图分为更小的可使用回溯搜索的不相交子图。</p><p class=ql-align-justify>当将一个图拆分为两个图时，目标是这样的两个不相交的子图会有最小数量的图替代。对于每个算子，将其容量 Cap(o_i) 定义为至少映射到了算子 o_i 的一个内边（in-edge）和一个外边（out-edge）的图替代的数量。</p><p class=ql-align-justify>直观而言，每个算子的容量即是被替代的「潜力」。我们最终得到了一个由节点和边构成的图，每个边都有一个描述其容量的权重。这个图拆分问题就变成了最小顶点切割问题。</p><p class=ql-align-justify>从整数规划（integer programming）的角度看，图的最小顶点切割问题是寻找一个顶点的子集（称为顶点切割），其中移除操作会将图分成两个组件。这通常使用标准的 max-flow 算法求解。</p><p class=ql-align-justify>可能大部分读者并不了解 min-cut / max-flow 这些术语，但如果你有兴趣，通常可在整数规划教科书/课程中找到它们。我不会深入这些问题的细节，只说一下这些类型的问题的目标以及它们与当前问题的关联。</p><p class=ql-align-justify>术语「切割（cut）」用于描述将图分为两个集合 (S, S_b) 的操作。切割的表示方法是两个独立的集合 (S, S_b)。因此，使用在计算图上定义好的容量，目标是切割图以使得被切掉的边有最小的容量，进而将图一分为二。</p><p class=ql-align-justify>总结一下，该算法首先是将图分成单个的子图，然后再运行回溯搜索算法来优化单个子图，最后，MetaFlow 将优化后的子图再组合到一起，组合得到整个计算图。</p><p class=ql-align-center><strong>实验结果</strong></p><p class=ql-align-justify>这篇论文使用了 MetaFlow 来测试比较一些著名的图像分类神经网络。这包括用于图像分类的 Inception-v3 (Szegedy et al., 2016)、SqueezeNet (Iandola et al., 2016) 和 ResNet50 (He et al., 2016) CNN。这三种不同的神经网络使用了不同的 DNN 模块来实现优良的模型准确度，并展现出了不同的图架构。</p><p class=ql-align-justify>除了图像分类，研究者还评估了在文本分类和机器翻译上的表现。RNNTC 和 NMT 是两个来自（Lei et al., 2017）的分别用于文本分类和神经机器翻译的模型。</p><p class=ql-align-justify>RNNTC 使用了一个嵌入层、一个隐藏大小为 1024 的循环层和一个 softmax 层。NMT 包括一个编码器和一个解码器，两者都由一个嵌入层和两个各有 1024 隐藏大小的循环层构成。表 1 提供了这些网络的概况。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3dc53588bcfc450d9afc87658f3f284a><p class=pgc-img-caption>表 1：实验所用的神经网络</p></div><p class=ql-align-justify>这些实验将 MetaFlow 加到了 TensorFlow、TensorFlow XLA 和 TensorRT 上。TensorFlow XLA 是一个用于 TensorFlow 图的编译器，可用于加速 TensorFlow ML 模型；TensorRT 是一个用于高性能深度学习推理的平台，由英伟达开发。TensorRT 包含一个深度学习推理优化器和优化时间，能为深度学习推理应用提供低延迟和高吞吐量。</p><p class=ql-align-justify>在所有实验中，所使用的成本模型都是最小化执行时间。此外，参数 α 设置为 1.05，作为回溯搜索算法的剪枝参数。</p><p class=ql-align-justify><strong>推理性能</strong></p><p class=ql-align-justify>第一个比较是端到端的性能。MetaFlow 会自动将优化过的计算图变换成基准框架会接受的标准格式，因此可以与基准比较测试。图 2 给出了比较的结果。蓝线是没使用 MetaFlow 的优化图的三个基准框架得到的最佳结果，红线是 MetaFlow 结果。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/abf9410543f246cc96d774b77a2a4f9a><p class=pgc-img-caption>图 2：MetaFlow、TensorFlow、TensorFlow XLA 和 TensorRT</p></div><p class=ql-align-justify>可以看到，MetaFlow 速度更快，优于已有的深度学习推理引擎。每条红线上的数字都是相对于最佳基准的相对提速。注意 MetaFlow 并不能唯一能执行图替代的框架。事实上，所有已有的系统在执行计算图之前都会根据自己的规则在内部执行图变换。</p><p class=ql-align-justify>因此，性能表现也可能因为所执行的图优化而不同。论文没有明确说明 MetaFlow 是否在准确度表现上也优于其它框架，但我认为推理时间（和其它指标）的结果是在所有框架的准确度表现相对接近的前提下得到的。</p><p class=ql-align-justify><strong>额外的指标比较</strong></p><p class=ql-align-justify>除了端到端的推理时间外，作者还在成本模型中包含了不同的指标，其中包括内存访问、启动的核、FLOPs 数量和设备利用率。表 2 给出了 MetaFlow 和 TensorRT 在这些指标上的比较。</p><div class=pgc-img><img alt="SysML 2019论文解读：推理优化" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5fa65503f81b4eb9a8eead64bf5eef4c><p class=pgc-img-caption>表 2：MetaFlow 和 TensorRT 在不同指标上的性能比较</p></div><p class=ql-align-justify>相比于 TensorRT，MetaFlow 能够减少整体的内存访问量以及核启动的数量。但是，在一个计算图中，MetaFlow 实现的推理性能提升是以 FLOPs 增长为代价的。我相信 FLOPs 的增长可通过以下案例进行解释。</p><p class=ql-align-justify>回想一下之前的章节，我们可用两个 1×3 核替代一个 3×3 卷积核。反过来也一样，如果我们有两个 1×3 核，我们也许可将它们组合（扩大）成一个 3×3 核。这种更大的操作更加复杂，也可能会有更高的 FLOP 量，但可能会减少内存访问和核启动，我相信这能够解释表 2 中的数据。</p><p class=ql-align-justify><strong>其它一些说明</strong></p><p class=ql-align-justify>作者还在子图性能等其它指标上进行了实验。子图性能指标是用于确定 MetaFlow 能否提升 DNN 中单个子图的性能。实验中测试比较了不同的设备，以确定给定一个输入图时，MetaFlow 能否在不同设备上发现不同的优化图。此外，论文也检查了搜索算法的性能。因为这些指标并不与推理优化直接相关，所以这篇解读不会介绍这些内容。感兴趣的读者请参阅原论文了解全部细节。</p><p class=ql-align-center><strong>总结与结语</strong></p><p class=ql-align-justify>这篇论文介绍了宽松化的图替代，能实现已有深度学习框架（使用的是贪婪方法）中未实现的复杂图优化的探索。宽松化图替代在数学形式上被构建成了一个基于成本的搜索算法，其涉及到一个或多个指标。回溯搜索的实现方式使得算法可在宽松化图替代生成的搜索空间中自动找到经过优化的计算图。</p><p class=ql-align-justify>最后，作者在 MetaFlow 中实现了该方法，这是一种用于 DNN 的宽松化图替代优化器。通过与几种标准 DNN 比较，研究表明 MetaFlow 相比于已有框架能在保证相近网络准确度的同时改善运行时间性能——能实现高达 1.6 倍的提升。</p><p class=ql-align-justify>我选择解读这两篇论文的原因是它们都涉及推理优化这一主题。这两篇论文是从不同角度实现推理优化，而我认为这两个角度都很重要。Choi et al. 的第一篇论文关注的是用量化来提升推理。这更多是一种面向硬件的方法。</p><p class=ql-align-justify>通过使用仅 2 位且准确度损失不太多的优良量化方法，网络速度相比于 8 位的（当前移动设备常用的配置）能实现极大的提升。鉴于学术界的大多数研究都着眼于网络准确度，所以这是一项很重要的研究。在现实世界应用中，硬件尺寸、功耗和速度等因素往往比准确度更重要，在探讨机器学习时我们应始终记得这一点。</p><p class=ql-align-justify>第二篇论文来自 Jia et al.，是从算法角度求解推理优化问题。我很喜欢这个框架，因为其涉及到将该问题表达为一个整数规划（min-cut / max-flow）问题。现如今，人们常常将机器学习作为单个领域来进行思考探索。</p><p class=ql-align-justify>但是，机器学习的核心是数学和优化，因此我认为在数学知识投入精力也是很重要的。拥有坚实的数学技能能帮助你更有效地分析机器学习问题，并也许能让你有能力以可能有更优解决方案的不同数学方式表达你的问题。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'文解','SysML','2019'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>