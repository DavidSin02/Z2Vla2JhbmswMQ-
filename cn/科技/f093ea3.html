<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你还不明白多态实现原理，你都不好意思说自己是Java程序员 | 极客快訊</title><meta property="og:title" content="你还不明白多态实现原理，你都不好意思说自己是Java程序员 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/78ed0be9d0c34e4da9a1c3dca789c45a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f093ea3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f093ea3.html><meta property="article:published_time" content="2020-10-29T20:58:49+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:49+08:00"><meta name=Keywords content><meta name=description content="你还不明白多态实现原理，你都不好意思说自己是Java程序员"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f093ea3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你还不明白多态实现原理，你都不好意思说自己是Java程序员</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p style=text-align:start>多态是Java语言重要的特性之一，它允许基类的指针或引用指向派生类的对象，而在具体访问时实现方法的动态绑定。<strong>Java对于方法调用动态绑定的实现主要依赖于方法表，但通过引用调用（invokevitual）和接口引用调用（invokeinterface）的实现则有所不同。</strong></p><p style=text-align:start>Java多态实现原理的大致过程：首先是Java编译器将Java源代码编译成class文件。在编译过程中，会根据静态类型将调用的符号引用写到class文件中。在执行时，JVM根据class文件找到调用方法的符号引用，然后在静态类型的方法表中找到偏移量，然后再根据this指针确定对象的实际类型，使用实际类型的方法表（偏移量跟静态类型中的偏移量一样是指 就是用的静态类型中的偏移量，因为符号引用在静态类型的方法表中找到的偏移量是同一个），如果在实际的方法中找到该方法（说明参数值对上了）则直接调用，否则认为没有重写父类的方法则按照继承关系从下往上搜索来调用方法。</p><div class=pgc-img><img alt=你还不明白多态实现原理，你都不好意思说自己是Java程序员 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/78ed0be9d0c34e4da9a1c3dca789c45a><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start><br></p><div class=pgc-img><img alt=你还不明白多态实现原理，你都不好意思说自己是Java程序员 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/543018348b9141fd936ce8da93f97f94><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=你还不明白多态实现原理，你都不好意思说自己是Java程序员 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8ab609c8ff548dab68a85cb17bb89a9><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>程序运行时，需要某个类是，类载入系统会将相应的class文件载入到JVM中，并在内部建立该类的 类型信息 （这个类型信息其实就是class文件在JVM中存储的一种数据结构），包含java类定义的所有信息（方法代码、类和成员变量、以及实现动态调用的核心 - 方法表 ）。这个类型信息存储在方法区。</p><p style=text-align:start>注意：这个方法去中的类型信息跟在堆中存放的class对象是不同的。在方法区中，这个class的类型信息只有唯一的实例（所以是各个线程共享的内存区域），而在堆中可以有多个该class对象。可以通过堆中的class对象访问到方法去中的类型信息（像Java的反射机制，通过class对象可以访问到该类的所有信息）。</p><p style=text-align:start><strong>【重点】</strong></p><p style=text-align:start>方法表是实现动态调用的核心。上面讲过方法表存放在方法区中的类型信息中。为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表，方法表中的每一个项都是对应方法的指针。<br>这些方法中包括从父类继承的所有方法以及自身重写（override）的方法。</p><p style=text-align:start><strong>【拓展】</strong></p><p style=text-align:start>方法区：方法区和JAVA堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>运行时常量池：它是方法区的一部分，Class文件中除了有类的版本、方法、字段等描述信息外，还有一项信息是常量池，用于存放编译器生成的各种符号引用，这部分信息在类加载时进入方法区的运行时常量池中。<br>方法区的内存回收目标是针对常量池的回收及对类型的卸载。</p><h1 class=pgc-h-arrow-right>Java 的方法调用方式</h1><p style=text-align:start>Java 的方法调用有两类，动态方法调用与静态方法调用。</p><ul><li>静态方法调用是指对于类的静态方法的调用方式，是静态绑定的</li><li>动态方法调用需要有方法调用所作用的对象，是动态绑定的。</li></ul><p style=text-align:start>类调用 (invokestatic) 是在编译时就已经确定好具体调用方法的情况。</p><p style=text-align:start>实例调用 (invokevirtual)则是在调用的时候才确定具体的调用方法，这就是动态绑定，也是多态要解决的核心问题。</p><p style=text-align:start>JVM 的方法调用指令有四个，分别是 invokestatic，invokespecial，invokesvirtual 和 invokeinterface。前两个是静态绑定，后两个是动态绑定的。本文也可以说是对于JVM后两种调用实现的考察。</p><p style=text-align:start><strong>方法表与方法调用</strong></p><p style=text-align:start>如有类定义 Person, Girl, Boy</p><pre><code>class Person {    public String toString() {        return "I'm a person.";    }    public void eat() {    }    public void speak() {    }}class Boy extends Person {    public String toString() {        return "I'm a boy";    }    public void speak() {    }    public void fight() {    }}class Girl extends Person {    public String toString() {        return "I'm a girl";    }    public void speak() {    }    public void sing() {    }}</code></pre><p style=text-align:start>当这三个类被载入到 Java 虚拟机之后，方法区中就包含了各自的类的信息。Girl 和 Boy 在方法区中的方法表可表示如下：</p><div class=pgc-img><img alt=你还不明白多态实现原理，你都不好意思说自己是Java程序员 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/19a87fb2b85f45e7891546b099d023c1><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>可以看到，Girl 和 Boy 的方法表包含继承自 Object 的方法，继承自直接父类 Person 的方法及各自新定义的方法。注意方法表条目指向的具体的方法地址，如 Girl 继承自 Object 的方法中，只有 toString() 指向自己的实现（Girl 的方法代码），其余皆指向 Object 的方法代码；其继承自于 Person 的方法 eat() 和 speak() 分别指向 Person 的方法实现和本身的实现。</p><p style=text-align:start>如果子类改写了父类的方法，那么子类和父类的那些同名的方法共享一个方法表项。</p><p style=text-align:start>因此，方法表的偏移量总是固定的。所有继承父类的子类的方法表中，其父类所定义的方法的偏移量也总是一个定值。<br>Person 或 Object中的任意一个方法，在它们的方法表和其子类 Girl 和 Boy 的方法表中的位置 (index) 是一样的。这样 JVM 在调用实例方法其实只需要指定调用方法表中的第几个方法即可。</p><p style=text-align:start>如调用如下：</p><pre><code>class Party {    void happyHour() {        Person girl = new Girl();        girl.speak();    }}</code></pre><p style=text-align:start>当编译 Party 类的时候，生成 girl.speak()的方法调用假设为： Invokevirtual #12</p><p style=text-align:start>设该调用代码对应着 girl.speak(); #12 是 Party 类的常量池的索引。JVM 执行该调用指令的过程如下所示：</p><div class=pgc-img><img alt=你还不明白多态实现原理，你都不好意思说自己是Java程序员 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ba4a230cc1ac46868df8d45986b0e27f><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>（这里有个错误，上图为ClassReference常量池而非Party的常量池）<br><strong>【再次拓展】</strong></p><p style=text-align:start>常量池在逻辑上可以分成多个表，每个表包含一类的常量信息，本文只探讨对于 Java 调用相关的常量池表。</p><p style=text-align:start>CONSTATNT_Method_info<strong>：</strong>类方法引用表；包含引用的任何类型方法的描述信息，主要包括类信息索引和名字类型索引。</p><p style=text-align:start>CONSTATNT_Class_info<strong>：</strong>类信息表；包含任何被引用的类或接口的 ‘符号引用’ ，每一个条目主要包含一个索引，指向&lt;u style="box-sizing: inherit;">CONSTA_Utf8_info&lt;/u>表，表示该类或接口的全限定名。</p><p style=text-align:start>CONSTATNT_NameAndType_info：名字类型表；包含引用的任意方法或字段的名称和描述符信息在字符串常量中的索引。</p><p style=text-align:start>CONSTATNT_Utf8_info：字符串常量表； 该表包含该类所使用的所有字符串常量，比如代码中的字符串引用、引用的类名、方法的名字、其他引用的类与方法的字符串描述等等。其余常量池表中所涉及到的任何常量字符串都被索引至该表。</p><p style=text-align:start>可以看到，给定任意一个方法的索引，在常量池中找到对应的条目后，可以得到该方法的类索引（classindex）和名字类型索引 (nameandtypeindex), 进而得到该方法所属的类型信息和名称及描述符信息（参数，返回值等）——从而通过对方法的类型信息和名称及描述符信息（参数，返回值等）来确定具体是调用哪一个方法。</p><p style=text-align:start><strong>JVM执行 &lt;u style="box-sizing: inherit;">Invokevirtual #12&lt;/u> 指令的过程：</strong></p><p style=text-align:start>（1）在常量池中找到方法调用的符号引用。 JVM 首先查看 Party（应为ClassReference常量池） 的常量池索引为 12 的条目 （此条目即指 - 查看常量池中的CONSTATNT_Method_info表，即类方法引用表），再 进一步查看常量池中的（CONSTANTClassinfo，CONSTANTNameAndTypeinfo ，CONSTANTUtf8info） 三个表。</p><p style=text-align:start>（2） 可得出要调用的方法是 Person 的 speak 方法， 查看 Person 的方法表，得出 speak 方法在该方法表中的偏移量 15，这就是该方法调用的直接引用。</p><p style=text-align:start>（3） 根据this指针得到具体的对象（即girl所指向位与堆中的对象）</p><p style=text-align:start>（4）根据对象得到该对象对应的方法表，根据偏移量15查看有无重写（override）该方法，如果重写，则可以直接调用（Girl的方法表的speak项指向自身的方法而非父类）；如果没有重写，则需要拿到按照继承关系从下往上的基类（这里是Person类）的方法表，同样按照这个偏移量15查看有无该方法。</p><h1 class=pgc-h-arrow-right>最后</h1><p style=text-align:start>以上，是对Java多态实现原理翻阅两篇博文后为便于理解而整理而出。<br>参考博文：<br>https://www.cnblogs.com/kaleidoscope/p/9790766.html<br>https://zhuanlan.zhihu.com/p/94086109<br>大家看完有什么不懂的可以在下方留言讨论.<br>谢谢你的观看。<br>觉得文章对你有帮助的话记得关注我点个赞支持一下！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'还不','多态','实现'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>