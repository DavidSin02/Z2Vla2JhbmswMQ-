<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 | 极客快訊</title><meta property="og:title" content="面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/53ecc71093ef411499a588ebbe940a1c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f1086463.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f1086463.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f1086463.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f1086463.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f1086463.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f1086463.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f1086463.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f1086463.html><meta property="article:published_time" content="2020-11-14T21:04:04+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:04+08:00"><meta name=Keywords content><meta name=description content="面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f1086463.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>今天来分享一下Redis几道常见的面试题：</p><ul><li>如何解决缓存雪崩？</li><li>如何解决缓存穿透？</li><li>如何保证缓存与数据库双写时一致的问题？</li></ul><h1>一、缓存雪崩</h1><p>1.1什么是缓存雪崩？</p><p>回顾一下我们为什么要用缓存(Redis)：</p><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/53ecc71093ef411499a588ebbe940a1c><p class=pgc-img-caption></p></div><p>image</p><p>&lt;figcaption style="margin: 10px 0px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;">为什么要缓存&lt;/figcaption></p><p>现在有个问题，<strong>如果我们的缓存挂掉了，这意味着我们的全部请求都跑去数据库了</strong>。</p><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/97519146e47c4a969663d0ff70a2d8c0><p class=pgc-img-caption></p></div><p>image</p><p>&lt;figcaption style="margin: 10px 0px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;">如果缓存挂掉了，全部请求跑去数据库了&lt;/figcaption></p><p>在前面学习我们都知道Redis不可能把所有的数据都缓存起来(<strong>内存昂贵且有限</strong>)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。Redis对过期键的策略+持久化</p><p>如果缓存数据<strong>设置的过期时间是相同</strong>的，并且Redis恰好将这部分数据全部<span>删光</span>了。这就会导致在这段时间内，这些缓存<strong>同时失效</strong>，全部请求到数据库中。</p><p><strong>这就是缓存雪崩</strong>：</p><ul><li>Redis挂掉了，请求全部走数据库。</li><li>对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。</li></ul><p>缓存雪崩如果发生了，很可能就把我们的数据库<strong>搞垮</strong>，导致整个服务瘫痪！</p><p>1.2如何解决缓存雪崩？</p><p>对于“对缓存数据设置相同的过期时间，导致某段时间内缓存失效，请求全部走数据库。”这种情况，非常好解决：</p><ul><li>解决方法：在缓存的时候给过期时间加上一个<strong>随机值</strong>，这样就会大幅度的<strong>减少缓存在同一时间过期</strong>。</li></ul><p>对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：</p><ul><li>事发前：实现Redis的<strong>高可用</strong>(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。</li><li>事发中：万一Redis真的挂了，我们可以设置<strong>本地缓存(ehcache)+限流(hystrix)</strong>，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)</li><li>事发后：redis持久化，重启后自动从磁盘上加载数据，<strong>快速恢复缓存数据</strong>。</li></ul><h1>二、缓存穿透</h1><p>2.1什么是缓存穿透</p><p>比如，我们有一张数据库表，ID都是从1开始的(<strong>正数</strong>)：</p><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6826d3125c2846e083903a1ebfdf4a87><p class=pgc-img-caption></p></div><p>image</p><p>&lt;figcaption style="margin: 10px 0px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;">随便找了一张数据库表&lt;/figcaption></p><p>但是可能有黑客想把我的数据库搞垮，每次请求的ID都是<strong>负数</strong>。这会导致我的缓存就没用了，请求全部都找数据库去了，但数据库也没有这个值啊，所以每次都返回空出去。</p><blockquote><p>缓存穿透是指查询一个一定<strong>不存在的数据</strong>。由于缓存不命中，并且出于容错考虑，如果从<strong>数据库查不到数据则不写入缓存</strong>，这将导致这个不存在的数据<strong>每次请求都要到数据库去查询</strong>，失去了缓存的意义。</p></blockquote><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3faeb6c25d4a407392f0c2f9fe997fda><p class=pgc-img-caption></p></div><p>image</p><p>&lt;figcaption style="margin: 10px 0px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;">缓存穿透&lt;/figcaption></p><p><strong>这就是缓存穿透</strong>：</p><ul><li>请求的数据在缓存大量不命中，导致请求走数据库。</li></ul><p>缓存穿透如果发生了，也可能把我们的数据库<strong>搞垮</strong>，导致整个服务瘫痪！</p><p>2.1如何解决缓存穿透？</p><p>解决缓存穿透也有两种方案：</p><ul><li>由于请求的参数是不合法的(每次都请求不存在的参数)，于是我们可以使用布隆过滤器(BloomFilter)或者压缩filter<strong>提前拦截</strong>，不合法就不让这个请求到数据库层！</li><li>当我们从数据库找不到的时候，我们也将这个<strong>空对象设置到缓存里边去</strong>。下次再请求的时候，就可以从缓存里边获取了。</li><li>这种情况我们一般会将空对象设置一个<strong>较短的过期时间</strong>。</li></ul><h1>三、缓存与数据库双写一致</h1><p>3.1对于读操作，流程是这样的</p><p>上面讲缓存穿透的时候也提到了：如果从数据库查不到数据则不写入缓存。</p><p>一般我们对<strong>读操作</strong>的时候有这么一个<strong>固定的套路</strong>：</p><ul><li>如果我们的数据在缓存里边有，那么就直接取缓存的。</li><li>如果缓存里没有我们想要的数据，我们会先去查询数据库，然后<strong>将数据库查出来的数据写到缓存中</strong>。</li><li>最后将数据返回给请求</li></ul><p>3.2什么是缓存与数据库双写一致问题？</p><p>如果仅仅查询的话，缓存的数据和数据库的数据是没问题的。但是，当我们要<strong>更新</strong>时候呢？各种情况很可能就<strong>造成数据库和缓存的数据不一致</strong>了。</p><ul><li>这里不一致指的是：<strong>数据库的数据跟缓存的数据不一致</strong></li></ul><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/977e0d582d3c44c194df1609af34f370><p class=pgc-img-caption></p></div><p>image</p><pre>padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;"&gt;数据库和缓存的数据不一致&lt;/figcaption&gt; </pre><p>从理论上说，只要我们设置了<strong>键的过期时间</strong>，我们就能保证缓存和数据库的数据<strong>最终是一致</strong>的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。</p><p>除了设置过期时间，我们还需要做更多的措施来<strong>尽量避免</strong>数据库与缓存处于不一致的情况发生。</p><p>3.3对于更新操作</p><p>一般来说，执行更新操作时，我们会有两种选择：</p><ul><li>先操作数据库，再操作缓存</li><li>先操作缓存，再操作数据库</li></ul><p>首先，要明确的是，无论我们选择哪个，我们都希望这<strong>两个操作要么同时成功，要么同时失败</strong>。所以，这会演变成一个<strong>分布式事务</strong>的问题。</p><p>所以，<strong>如果原子性被破坏了</strong>，可能会有以下的情况：</p><ul><li><strong>操作数据库成功了，操作缓存失败了</strong>。</li><li><strong>操作缓存成功了，操作数据库失败了</strong>。</li></ul><blockquote><p>如果第一步已经失败了，我们直接返回Exception出去就好了，第二步根本不会执行。</p></blockquote><p>下面我们具体来分析一下吧。</p><p>3.3.1操作缓存</p><p>操作缓存也有两种方案：</p><ul><li>更新缓存</li><li>删除缓存</li></ul><p>一般我们都是采取<strong>删除缓存</strong>缓存策略的，原因如下：</p><ol><li>高并发环境下，无论是先操作数据库还是后操作数据库而言，如果加上更新缓存，那就<strong>更加容易</strong>导致数据库与缓存数据不一致问题。(删除缓存<strong>直接和简单</strong>很多)</li><li>如果每次更新了数据库，都要更新缓存【这里指的是频繁更新的场景，这会耗费一定的性能】，倒不如直接删除掉。等再次读取时，缓存里没有，那我到数据库找，在数据库找到再写到缓存里边(体现<strong>懒加载</strong>)</li></ol><p>基于这两点，对于缓存在更新时而言，都是建议执行<strong>删除</strong>操作！</p><p>3.3.2先更新数据库，再删除缓存</p><p>正常的情况是这样的：</p><ul><li>先操作数据库，成功；</li><li>再删除缓存，也成功；</li></ul><p>如果原子性被破坏了：</p><ul><li>第一步成功(操作数据库)，第二步失败(删除缓存)，会导致<strong>数据库里是新数据，而缓存里是旧数据</strong>。</li><li>如果第一步(操作数据库)就失败了，我们可以直接返回错误(Exception)，不会出现数据不一致。</li></ul><p>如果在高并发的场景下，出现数据库与缓存数据不一致的<strong>概率特别低</strong>，也不是没有：</p><ul><li>缓存<strong>刚好</strong>失效</li><li>线程A查询数据库，得一个旧值</li><li>线程B将新值写入数据库</li><li>线程B删除缓存</li><li>线程A将查到的旧值写入缓存</li></ul><p>要达成上述情况，还是说一句<strong>概率特别低</strong>：</p><blockquote><p>因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，<strong>而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存</strong>，所有的这些条件都具备的概率基本并不大。</p></blockquote><p>对于这种策略，其实是一种设计模式：Cache Aside Pattern</p><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/51d9daa6f0c749fa807e0d6ba2b90861><p class=pgc-img-caption></p></div><p>image</p><p>&lt;figcaption style="margin: 10px 0px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;">先修改数据库，再删除缓存&lt;/figcaption></p><p><strong>删除缓存失败的解决思路</strong>：</p><ul><li>将需要删除的key发送到消息队列中</li><li>自己消费消息，获得需要删除的key</li><li><strong>不断重试删除操作，直到成功</strong></li></ul><p>3.3.3先删除缓存，再更新数据库</p><p>正常情况是这样的：</p><ul><li>先删除缓存，成功；</li><li>再更新数据库，也成功；</li></ul><p>如果原子性被破坏了：</p><ul><li>第一步成功(删除缓存)，第二步失败(更新数据库)，数据库和缓存的数据还是一致的。</li><li>如果第一步(删除缓存)就失败了，我们可以直接返回错误(Exception)，数据库和缓存的数据还是一致的。</li></ul><p>看起来是很美好，但是我们在并发场景下分析一下，就知道还是有问题的了：</p><ul><li>线程A删除了缓存</li><li>线程B查询，发现缓存已不存在</li><li>线程B去数据库查询得到旧值</li><li>线程B将旧值写入缓存</li><li>线程A将新值写入数据库</li></ul><p>所以也会导致数据库和缓存不一致的问题。</p><p><strong>并发下解决数据库与缓存不一致的思路</strong>：</p><ul><li>将删除缓存、修改数据库、读取缓存等的操作积压到<strong>队列</strong>里边，实现<strong>串行化</strong>。</li></ul><div class=pgc-img><img alt=面试必知Redis面试题—缓存雪崩+穿透+缓存与数据库双写一致问题 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f6060456ea37458f9dbc409c24091ab1><p class=pgc-img-caption></p></div><p>image</p><p>&lt;figcaption style="margin: 10px 0px 0px; padding: 0px; max-width: 100%; box-sizing: border-box !important; word-wrap: break-word !important; line-height: inherit; text-align: center; color: rgb(153, 153, 153); font-size: 0.7em;">将操作积压到队列中&lt;/figcaption></p><p>3.4对比两种策略</p><p>我们可以发现，两种策略各自有优缺点：</p><ul><li>先删除缓存，再更新数据库</li><li>在高并发下表现不如意，在原子性被破坏时表现优异</li><li>先更新数据库，再删除缓存(Cache Aside Pattern设计模式)</li><li>在高并发下表现优异，在原子性被破坏时表现不如意#总结</li></ul><h1>总结【精华】</h1><p>针对于上面的Redis面试题我总结出了互联网公司java程序员面试涉及到的绝大部分面试题及答案做成了文档和架构视频资料免费分享给大家（还包括Dubbo、Redis、Netty、zookeeper、Spring cloud、分布式、高并发等架构技术资料），希望能帮助到您面试前的复习且找到一个好的工作，也节省大家在网上搜索资料的时间来学习，也可以关注我一下以后会有更多干货分享。</p><p class=ql-align-center><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'缓存','面试','必知'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>