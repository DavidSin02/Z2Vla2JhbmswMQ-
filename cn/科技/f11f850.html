<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>先进后出的数据结构——栈 | 极客快訊</title><meta property="og:title" content="先进后出的数据结构——栈 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/b557bfb4-d65c-4a3d-833f-984dbd8cc08a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f11f850.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f11f850.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f11f850.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f11f850.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f11f850.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f11f850.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f11f850.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f11f850.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="先进后出的数据结构——栈"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f11f850.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>先进后出的数据结构——栈</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=先进后出的数据结构——栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/b557bfb4-d65c-4a3d-833f-984dbd8cc08a><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>一、栈的概述</h1><p>和队列一样，栈是一种操作受限的线性表，和队列不同的是栈只允许从一端插入和删除数据。</p><p>因此，栈的特点是：</p><ul><li>栈中的数据元素遵守“<strong>先进后出</strong>"(First In Last Out)的原则，简称FILO结构。</li><li>限定只能在栈顶进行插入和删除操作，栈最重要的特征</li></ul><p>一些需要了解的概念：</p><p>栈顶与栈底：允许元素插入与删除的一端称为栈顶，另一端称为栈底。</p><p style=text-align:start>压栈：栈的插入操作，叫做进栈，也称压栈、入栈。</p><p style=text-align:start>弹栈：栈的删除操作，也叫做出栈。</p><p style=text-align:start><br></p><div class=pgc-img><img alt=先进后出的数据结构——栈 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/99adcd06ec65463fa61f15a73bc2afdd><p class=pgc-img-caption></p></div><p>就像生活中我们取放盘子，当一摞盘子在桌子上时候，我们总是会取最上边的盘子，同时，我们在放盘子时，也会放在最上面。其实，每个栈都有一个栈顶指针，它初始值为-1，且总是指向最后一个入栈的元素，栈有两种处理方式，即进栈（push）和出栈（pop），因为在进栈只需要移动一个变量存储空间，所以它的时间复杂度为O(1)，但是对于出栈分两种情况，栈未满时，时间复杂度也为O(1)，但是当栈满时，需要重新分配内存，并移动栈内所有数据，所以此时的时间复杂度为O(n)。</p><p>栈有两种存储方式，即线性存储和链接存储（链表）。</p><h1 class=pgc-h-arrow-right>二、栈的常用操作和实现</h1><p>栈的常用操作有：</p><ul><li>pop弹栈，向栈底添加一个元素</li><li>pop 压栈，从栈顶取出一个元素</li><li>size 判定栈中所含元素的个数</li><li>isEmpty 判断栈是否为空</li><li>peek 获取栈顶元素的值，复制栈顶元素返回，但不进行删除</li></ul><p><strong>1、线性存储</strong><br>线性存储的方式和线性表基本一致，不同的是添加了后进先出的限制，并且是静态分配的，即使用前，它的内存就已经以数组的形式分配好了，所以在初始化时，需要指明栈的节点最大个数。基于数组的栈是以数组为底层数据结构的，通常以数组头为栈底，数组头到数组尾为栈顶的生长方向。</p><pre><code>public class MyStack {  //大小  private int size;    //栈的最大容量  private int maxSize;    //默认最大容量10  private static final int DEFAULT_MAX_SIZE =10;/数组(用来保存数据)String[] stack;                                                             //有参初始化,设置栈的最大容量                               public MyStack(int maxSize) {                                      this.maxSize=maxSize;                                      stack =new String[maxSize];                               }                                                             //无参初始化,设置栈的默认容量                               public MyStack() {                                      this(DEFAULT_MAX_SIZE);                               }                                                             //进行入栈操作                               public void push(String s) {                                      if(size &gt;=  maxSize) {                                              throw new IndexOutOfBoundsException("栈已经满了!");                                      }                                      stack[size] =s;                                      size++;                                      look();                               }                                                             //出栈操作                               public String pop() {                                      String rs=stack[size-1];                                      //从后往前将做高位的值赋为null                                      stack[size-1]=null;                                      size--;                                      look();                                      return rs;                               }                                                             //清栈操作                               public void clear() {                                      for(int i=0;i&lt;size;i++) {                                              stack[i] =null;                                      }                                      size =0;                                      look();                               }                                                             //获取栈的长度                               public int getSize() {                                      return size;                               }                                                             //动态显示栈中的数据                               private void look() {                                      System.out.println("");                                      for(int i=0;i&lt;maxSize;i++) {                                              System.out.print(stack[i] + " ");                                      }                                        }                                        }测试</code></pre><p>2、链接存储<br>对於单链表类，只要做适当的修改，限制其插入、删除、修改和访问结点的行为，使其符合栈先进后出的规则即可，另外需要单独提供栈访问的接口函数，例如进栈、出栈、获取栈大小等。基於单链表的栈是以链表为底层的数据结构的，以链表头为栈顶，便于节点的插入与删除，压栈产生的新节点将一直出现在链表的头部</p><pre><code>/ * 栈的实现 * */public class MyStackNode {                               //大小                               private int size;                               //栈的最大容量                               private int maxSize;                               //默认最大容量10                               private static final int DEFAULT_MAX_SIZE =10;                               //栈顶的节点                               private Node top;                                                             //有参初始化,设置栈的最大容量                               public MyStackNode(int maxSize) {                                      this.maxSize=maxSize;                               }                                                             //无参初始化,设置栈的默认容量                               public MyStackNode() {                                      this(DEFAULT_MAX_SIZE);                               }                                                             //进行入栈操作                               public void push(String s) {                                      if(size &gt;=  maxSize) {                                              throw new IndexOutOfBoundsException("栈已经满了!");                                      }                                      Node node=new Node(s,top);                                      top=node;                                      look();                                      size++;                               }                                                             //移除栈顶的元素                               public String pop() {                                      if(top == null)                                              return null;                                      Node oldTop=top;                                      Node newTop=top.next;                                      String rs=oldTop.s;                                      oldTop.next=null;                                      oldTop.s=null;                                      oldTop=null;                                      top=newTop;                                      look();                                      size--;                                      return rs;                               }                                                             //清栈操作                               public void clear() {                                      Node node=top;                                      while(node !=null) {                                              Node newTop=node.next;                                              node.next=null;                                              node.s=null;                                              node =newTop;                                      }                                      look();                                      size =0;                               }                                                             //添加一个Node内部类                               class Node{                                      public String s;                                      public Node next;                                                                           public Node(String s,Node next) {                                              this.s=s;                                              this.next=next;                                      }                                                                           public void setNext(Node next) {                                              this.next=next;                                      }                               }                                                             //获取栈的长度                               public int getSize() {                                      return size;                               }                                                             //动态显示栈中的数据                               private void look() {                                      System.out.println("");                                      Node node=top;                                      while(node !=null) {                                              System.out.print(node.s + " ");                                               node=node.next;                                      }                               }                               public static void main(String[] args) {                                      MyStackNode stack=new MyStackNode(4);                                      //MyStack stack=new MyStack();                                      stack.push("壹");                                      stack.push("贰");                                      stack.push("叁");                                      stack.push("肆");                                      stack.pop();                                      stack.pop();                                      stack.push("money");                                      stack.push("money");                                      System.out.println("当前栈的容量为:" + stack.getSize());                                      stack.clear();                               }}测试:</code></pre><h1 class=pgc-h-arrow-right>三、栈的应用场景</h1><ul><li>数制转换</li><li>字符匹配</li><li>数据反转</li><li>括号匹配检验</li><li>平衡符号的判断</li></ul><h1 class=pgc-h-arrow-right>四、栈和队列的区别</h1><p style=text-align:start>栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。</p><p style=text-align:start>栈是先进后出，队列是先进先出。</p><p style=text-align:start>栈只允许在表尾一端进行插入和删除，队列只允许在表尾一端进行插入，在表头一端进行删除。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'进后出','数据','结构'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>