<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>发号器-达达分布式ID生成系统 | 极客快訊</title><meta property="og:title" content="发号器-达达分布式ID生成系统 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/02a28bb87a924ca69ab60c8f1f17e2e9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f35558f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f35558f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f35558f.html><meta property="article:published_time" content="2020-10-29T21:00:54+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:54+08:00"><meta name=Keywords content><meta name=description content="发号器-达达分布式ID生成系统"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f35558f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>发号器-达达分布式ID生成系统</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>背景</strong></p><p>在分布式系统中，经常需要对大量的数据、消息、http请求等进行唯一标识，例如：对于分布式系统，服务间相互调用需要唯一标识，调用链路分析的时候需要使用这个唯一标识。这个时候数据库自增主键已经不能满足需求，需要一个能够生成全局唯一ID的系统，这个系统需要满足以下需求：</p><ul><li>全局唯一：不能出现重复ID。</li><li>高可用：ID生成系统是基础系统，被许多关键系统调用，一旦宕机，会造成严重影响。</li></ul><p><strong>经典方案介绍</strong></p><p>1. UUID</p><p>UUID是Universally Unique Identifier的缩写，它是在一定的范围内(从特定的名字空间到全球)唯一的机器生成的标识符，UUID是16字节128位长的数字，通常以36字节的字符串表示，比如：3F2504E0-4F89-11D3-9A0C-0305E82C3301。</p><p>UUID经由一定的算法机器生成，为了保证UUID的唯一性，规范定义了包括网卡MAC地址、时间戳、名字空间(Namespace)、随机或伪随机数、时序等元素，以及从这些元素生成UUID的算法。UUID的复杂特性在保证了其唯一性的同时，意味着只能由计算机生成。</p><p>优点：</p><ul><li>本地生成ID，不需要进行远程调用，时延低，性能高。</li></ul><p>缺点：</p><ul><li>UUID过长，16字节128位，通常以36长度的字符串表示，很多场景不适用，比如用UUID做数据库索引字段。</li><li>没有排序，无法保证趋势递增。</li></ul><p>2. Flicker方案</p><p>这个方案是由Flickr团队提出，主要思路采用了MySQL自增长ID的机制(auto_increment + replace into)</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/02a28bb87a924ca69ab60c8f1f17e2e9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>replace into 跟 insert 功能类似，不同点在于：replace into 首先尝试插入数据到表中，如果发现表中已经有此行数据(根据主键或者唯-索引判断)则先删除此行数据，然后插入新的数据， 否则直接插入新数据。</p><p>为了避免单点故障，最少需要两个数据库实例，通过区分auto_increment的起始值和步长来生成奇偶数的ID。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/de10b8aadb62432d87a6644a19d83884><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>优点：</p><ul><li>充分借助数据库的自增ID机制，可靠性高，生成有序的ID。</li></ul><p>缺点：</p><ul><li>ID生成性能依赖单台数据库读写性能。</li><li>依赖数据库，当数据库异常时整个系统不可用。</li></ul><p>对于依赖MySql性能问题，可用如下方案解决：</p><p>在分布式环境中我们可以部署多台，每台设置不同的初始值，并且步长为机器台数，比如部署N台，每台的初始值就为0，1，2，3…N-1，步长为N。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ea21f64af4d947f793bbbf8f830c9ed5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>以上方案虽然解决了性能问题，但是也存在很大的局限性：</p><ul><li>系统扩容困难：系统定义好步长之后，增加机器之后调整步长困难。</li><li>数据库压力大：每次获取一个ID都必须读写一次数据库。</li></ul><p>3. 类snowflake方案</p><p>这种方案生成一个64bit的数字，64bit被划分成多个段，分别表示时间戳、机器编码、序号。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/90b01ddb99e94ba3807ffd32e7bc8d52><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>ID为64bit 的long 数字，由三部分组成：</p><ul><li>41位的时间序列(精确到毫秒，41位的长度可以使用69年)。</li><li>10位的机器标识(10位的长度最多支持部署1024个节点)。</li><li>12位的计数顺序号(12位的计数顺序号支持每个节点每毫秒产生4096个ID序号)。</li></ul><p>优点：</p><ul><li>时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序。</li><li>性能高，每秒可生成几百万ID。</li><li>可以根据自身业务需求灵活调整bit位划分，满足不同需求。</li></ul><p>缺点：</p><ul><li>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。</li><li>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。</li></ul><p>4. TDDL序列生成方式</p><p>TDDL是阿里的分库分表中间件，它里面包含了全局数据库ID的生成方式，主要思路：</p><ul><li>使用数据库同步ID信息。</li><li>每次批量取一定数量的可用ID在内存中，使用完后，再请求数据库重新获取下一批可用ID，每次获取的可用ID数量由步长控制，实际业务中可根据使用速度进行配置。</li><li>每个业务可以给自己的序列起个唯一的名字，隔离各个业务系统的ID。</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/8e98597ad9c84a3f9228d94d969ce4cb><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>优点：</p><ul><li>相比flicker方案，大大降低数据库写压力，数据库不再是性能瓶颈。</li><li>相比flicker方案，生成ID性能大幅度提高，因为获取一个可用号段后在内存中直接分配，相对于每次读取数据库性能提高了几个量级。</li><li>不同业务不同的ID需求可以用seqName字段区分，每个seqName的ID获取相互隔离，互不影响。</li></ul><p>缺点：</p><ul><li>强依赖数据库，当数据库异常时整个系统不可用。</li></ul><p>发号器实现方案</p><p>综合对比以上四种实现方案，以及我们的业务需求，最后决定采用第三种方案。</p><p><strong>主要原因：</strong></p><ul><li>业务需求：业务要求生成的ID要有递增趋势，全局唯一，并且为数字。</li><li>系统考虑：第三种方案性能高，稳定性高，对外部资源依赖少。</li></ul><p>依据实际业务需求和系统规划，对算法进行局部调整，实现了发号器snowflake方案。</p><p>发号器snowflake方案</p><p>发号器snowflake方案中对bit的划分做了如下调整：</p><ul><li>36 bit 时间戳，使用时间秒</li><li>5 bit 机器编码</li><li>22 bit 序号</li></ul><p>机器编码维护：</p><p>机器编码是不同机器之间产生唯一ID的重要依据，不能重复，一旦重复，就会导致有相同机器编码的服务器生成的ID大量重复。 如果部署的机器只是少量的，可以人工维护，如果大量，手动维护成本高，考虑到自动部署、运维等等问题，机器编码最好由系统自动维护，有以下两个方案可供选择:</p><ul><li>使用mysql自增ID特性，用数据表，存储机器的mac地址或者ip来维护。</li><li>使用ZooKeeper持久顺序节点的特性。</li></ul><p>这里我们使用ZooKeeper持久顺序节点特性来配置维护WORKID.发号器的启动顺序如下：</p><ul><li>启动发号器服务，连接ZooKeeper， 检查根节点id_generator是否存在，如果不存在就创建系统根节点。</li><li>检查根节点下当前机器是否已经注册过(是否有该顺序子节点)。</li><li>如果有注册，直接取回自己的WORKID。如果没注册，在根节点下创建一个持久顺序节点，取回顺序号做WORKID。</li></ul><p>一旦取回WORKID，缓存在本地文件中，后续直接使用，不再与ZooKeeper进行任何交互，此方案对ZooKeeper依赖极小。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14192c11a6234c1f9c614c4549b13bfa><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>时钟问题：</p><p>snowflake方案依赖系统时钟，如果机器时钟回拨，就有可能生成重复ID，为了保证ID唯一性，必须解决时钟回拨问题。</p><p>可以采取以下几种方案解决时钟问题：</p><ul><li>关闭系统NTP同步，这样就不会产生时钟调整。</li><li>系统做出判断，在时钟回拨这段时间，不生成ID，直接返回ERROR_CODE，直到时钟追上，恢复服务。</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca9da9ea8e47444d9f55951837ac89c4><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ul><li>系统做出判断，如果遇到超过容忍限度的回拨，上报报警系统，并把自身从集群节点中摘除</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/901915f0d82446058a5d1fae39fad3b2><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ul><li>系统做兼容处理，由于nfp网络回拨都是几十毫秒到几百毫秒，极少数到秒级别，这种回拨会产生以下几种结果：</li><li>系统中缓存最近几秒内最后的发号序号(具体范围请根据实际需要确定)，存储格式为：时间秒-序号。</li><li>当前秒数不变： 当前是8:30秒100毫秒，ntp回拨50毫秒，当前时间变成8:30秒50毫秒，这个时候秒数没变，我们算法的时间戳部分不会产生重复，就不影响系统继续发号</li><li class=ql-indent-1><br></li><li>当前秒数向前：当前是8:30秒800毫秒，ntp 向前调整300毫秒，当前时间变成8:31秒100毫秒，由于这个时间还没发过号，不会生成重复的ID</li><li class=ql-indent-1><br></li><li class=ql-indent-1>当前秒数向后：当前是8:30秒100毫秒，ntp回拨150毫秒，当前时间变成8:29秒950毫秒，这个时候秒发生回退，就可能产生重复ID。产生重复的原因在于秒回退后，算法的时间戳部分使用了已经用过的时间戳，但是算法的序号部分，并没有回退到29秒那个时间对应的序号，依然使用当前的序号，如果序号也同时回退到29秒时间戳所对应的最后序号，就不会重复发号。解决方案如下：</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/81ec7a3d74f84cb1aa4b577b3df4c356><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>闰秒处理：</p><p>闰秒，是指为保持协调世界时接近于世界时时刻，由国际计量局统一规定在年底或年中(也可能在季末)对协调世界时增加或减少1秒的调整。由于地球自转的不均匀性和长期变慢性(主要由潮汐摩擦引起的)，会使世界时(民用时)和原子时之间相差超过到±0.9秒时，就把协调世界时向前拨1秒(负闰秒，最后一分钟为59秒)或向后拨1秒(正闰秒，最后一分钟为61秒)，闰秒一般加在公历年末或公历六月末。</p><p>在闰秒产生的时候系统会出现秒级时间调整，下面我们来分析闰秒对发号器的影响：</p><ul><li>负闰秒：当前23:59:58的下一秒就是第二天的00:00:00，00:00:00 这个时间我们还没产生过ID，不会产生重复的，对发号器没影响。</li><li>正闰秒：当天23:59:59的下一秒当记为23:59:60，然后才是第二天的00:00:00。由于我们系统时间戳部分取的从某个时间点(1970年1月1日)到现在的秒数，是一个数字，只要这个数字不重复，就不会产生重复的ID。如果在闰秒发生一段时间后ntp时间同步(为了规避闰秒风险，很多公司闰秒前关闭ntp同步，闰秒后打开ntp同步)，这个时候系统时钟回拨,可以使用解决时钟回拨的方案进行处理。</li></ul><p>服务部署优化</p><ul><li>部署结构</li><li>为了实现高可用，避免单点故障，系统部署采用集群水平部署，前置使用nginx做负载均衡，发号器使用springboot框架，web服务器使用springboot内嵌tomcat， 发号器和nginx之间进行心跳检测。</li><li class=ql-align-center><br></li></ul><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f3f88a2760dc49c588549d63b6b6292a><p class=pgc-img-caption></p></div><ul><li class=ql-align-center><br></li><li>tomcat调优</li><li>使用APR</li><li>Tomcat支持三种接收请求的处理方式：BIO、NIO、APR， 性能 BIO&lt;NIO&lt;APR。APR简单理解，就是从操作系统级别解决异步IO问题，大幅度的提高服务器的处理和响应性能，也是Tomcat运行高并发应用的首选模式。使用APR首先要安装系统依赖库，参考APR安装</li><li>在springBoot程序中增加apr配置开启APR(这里有一个配置变量来控制是否开启)</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/78b2f37622f74533badc27ed0c388d95><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>开发中遇到的问题</p><hr><p>整个开发过程都非常顺利，测试的时候tps也很高，心情很愉快，世界很美好，突然一个意外出现，发现存在full gc现象，有内存溢出？ 于是分析了好几遍程序，也没找到明显的线索，只能开始jvm调试旅程。</p><p>pingpoint 监控图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9538507cc6db427d998a39b15bff7618><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>（上图中红色部署表示full gc）</strong></p><p>JVM调试最直接的就是获取full gc时的jvm dump文件，以及gc log进行分析：</p><p>为了获取dump文件，在jvm参数中加上：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8fa9acd69e5449c8ba3be152323ecda><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p><strong>参数介绍：</strong></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be94030d10b4447aaa21c1f71df4a2d1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>配置上面的虚拟机参数后，虚拟机gc的时候会把gc相关信息输出到文件gc.log中，full gc前后，会生成当时虚拟机的内存dump文件。从pingpoint监控图中可以看出full gc是发生在持久区域。</p><p>使用jmap 工具，获取JVM堆内存信息如下：</p><p>jmap -heap pid</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/be3446be29ef4a9786c622f9a758cf5c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>从上图可以看出，使用的堆内存很少，总的堆内存只有0.84% 使用，其它使用指标也都在正常范围，系统装载的类也不多，没有内存泄露。</p><p>继续分析gc log：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2647521d94954effb0296444b6ebcc5c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>从gc log 中寻找线索：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/666961e1b03542d7966ab3811c5d3548><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>这里发现了以下线索：</p><ul><li>从 [Full GC (Metadata GC Threshold)看出，的确产生了full gc，原因 Metadata GC Threshold。</li><li>[Metaspace: 34773K->34773K(1081344K)] full gc前后metaspace的size没有变化说明此区域已经满了，释放不出内存。</li><li>仔细分析gc log，发现2次full gc记录，第一次full gc [Metaspace: 20897K->20897K(1069056K)，这个值比第2次的要小很多。</li></ul><p class=ql-align-center><br></p><div class=pgc-img><img alt=发号器-达达分布式ID生成系统 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/af73721ac48d4e72b15a99de6c15cba9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>两次full gc原因都是 Metadata GC Threshold类型，说明pingpoint监控到的full gc是元空间引发的full gc，并非内存泄露引起，但是这个值才34m，距离最大值1081m，还有很大空间，为什么会full gc?</p><p>经过查阅官方资料，发现MetaspaceSize的默认大小是21807104b，也就是21296k，而发生GC的时候，元空间已经使用了34722K，从而产生full gc。</p><p>方法区:</p><p>方法区也是所有线程共享。主要用于存储类的信息、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。其实，移除永久代的工作从JDK1.7就开始了。JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，譬如符号引用(Symbols)转移到了native heap，字符串常量转移到了java heap，类的静态变量(class statics)转移到了java heap。</p><p>在JDK8中，classe metadata(the virtual machines internal presentation of Java class)，被存储在叫做Metaspace的native memory。一些新的flags被加入：-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，就会在不超过MaxMetaspaceSize(如果设置了的话)的情况下，适当的提高该值。</p><p>在虚拟机参数中增加MetaspaceSize初始化大小，-XX:MetaspaceSize=128m，重新启动项目，不再有full gc出现。</p><p>总结</p><p>发号器-达达分布式ID生成系统，是以snowflake算法为基础，实现了生成全局唯一ID的功能，解决了在分布式系统唯一ID生成问题。在实现高可用性方面，采用水平集群部署、心跳检测等方案为系统保驾护航。该系统目前已在达达商城等项目中使用，每天提供大量服务。</p><p>参考</p><ul><li>Snowflake (https://github.com/twitter/snowflake)</li><li>TDDL</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'发号器','达达分','ID'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>