<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java EE 5：强大的功能、高生产率和低复杂性 | 极客快訊</title><meta property="og:title" content="Java EE 5：强大的功能、高生产率和低复杂性 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1f8b1aa109964f528444ddc4d6748ae2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f54ed79c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f54ed79c.html><meta property="article:published_time" content="2020-10-29T21:12:38+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:38+08:00"><meta name=Keywords content><meta name=description content="Java EE 5：强大的功能、高生产率和低复杂性"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f54ed79c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java EE 5：强大的功能、高生产率和低复杂性</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>概述 Java EE 5 特性和提高开发人员生产率的改进</strong></p><p><strong>简介</strong></p><p>Java EE 技术是 Java 语言平台的扩展，支持开发人员创建可伸缩的强大的可移植企业应用程序。它为应用程序组件定义了四种容器：Web、Enterprise JavaBean（EJB）、应用程序客户机和 applet。一个应用服务器规范详细描述了这些容器和它们必须支持的 Java API，这促使 Java EE 产品相互竞争，同时保证符合这个规范的应用程序可以在服务器之间移植（参见 Java EE 简史）。</p><p>这个平台的最新版本 Java EE 5 已经于 2006 年 5 月发布。Java EE 5 主要关注提高开发人员的生产率，它提供了更简单的编程模型，而没有牺牲平台的任何功能。更简单的开发模型主要由两个机制提供 —— Java 注解和更好的默认行为。主要的功能性改进包括改进了 Web 服务支持以及在平台中集成了 JavaServer Faces（JSF）和 Java Standard Tag Library（JSTL）。</p><p><strong>Java EE 简史</strong></p><p>Java EE 5 由 Java Community Process 通过 Java Specification Request 244 发布，这个 “总纲” JSR 指出了详细描述 Java EE 5 中各种技术的其他规范（参见 参考资料）。Sun Microsystems 的 Bill Shannon 领导一个专家组制订了这个规范，这个专家组包括从 IT 行业重量级人物到个人专家的 31 位成员。以前的 Java EE 版本有：</p><ul><li><strong>J2EE 1.2</strong>（于 1999 年 12 月发布）：这是第一个 J2EE 版本，随着 Java 2 Standard Edition（J2SE） 发布。它包含 10 个规范和 API，针对企业应用程序所需的常用的 Web 层、业务逻辑、表示层和消息传递服务。</li><li><strong>J2EE 1.3</strong>（于 2001 年 9 月发布）：通过 JSR 58 发布，这个版本改进了半数 J2EE 1.2 规范并引入了 XML API、连接器架构和安全框架。</li><li><strong>J2EE 1.4</strong>（于 2003 年 11 月发布）：这个版本改进了 J2EE 1.3 中 13 种技术中的 9 种，并引入了新的 Web 服务和安全支持。</li></ul><p>J2EE 1.4 之后就是 Java EE 5，因为 Sun 已经从名称中去掉了 “2”（这是从 Java 1.2 被称为 “Java 2” 时开始的做法），而且现在在技术的简写名中使用单词 “Java” 而不是 “J”。现在的标准版是 Java SE 6（而不是 J2SE 1.6），企业版是 Java EE 5（而不是 J2EE 1.5）。</p><p>本文介绍 Java EE 5 中的特性，重点介绍自上一个 J2EE 版本以来的变化。（超出本文范围的改进包括 StAX API — 一个用来解析 XML 的 API — 和跨许多 API 的中小程度的改进。）我将全面讨论四个特性类别：Web 服务、Web 应用程序、企业应用程序以及管理和安全性。然后，为了避免读者觉得厌烦，我们讨论一个使用 Java EE 5 特性的小应用程序，以此说明新的开发模型如何简化面向服务架构（SOA） Web 应用程序的开发。</p><p>本文假设读者熟悉企业级软件系统，并希望全面了解 Java EE 5 的概况。了解 Java 编程和 J2EE 对于理解特性的意义会有帮助，但不是必需的。对示例应用程序的讨论涉及一些技术细节，有 J2EE（至少是 Java 编程）背景可能比较容易理解。</p><p><strong>Web 服务技术</strong></p><p>在 Java EE 5 中引入了注解（annotation）特性，这简化了复杂 Web 服务端点和客户机的开发，与以前的 Java EE 版本相比，代码更少，学习过程更短了。注解（最早在 Java SE 5 中引入）是可以作为元数据添加到代码中的修饰性代码。它们并不直接影响程序的语义，但是编译器、开发工具和运行时库可以通过处理它们生成额外的 Java 语言源文件、XML 文档或其他工件和行为，这些对包含注解的程序起辅助作用（参见 参考资料）。在本文后面，会看到如何通过添加简单的注解，将常规的 Java 类转换为 Web 服务。</p><p><strong>Web 服务支持方面的飞跃</strong></p><p>Java EE 5 中 Web 服务支持的基础是 JAX-WS 2.0，它是一种替代 JAX-RPC 1.1 的技术。这两种技术都支持创建 REST 风格和基于 SOAP 的 Web 服务，而不必直接处理 Web 服务固有的 XML 处理和数据绑定细节。开发人员可以继续使用 JAX-RPC（这仍然需要 Java EE 5 容器），但是强烈建议迁移到 JAX-WS。刚开始学习 Java Web 服务的开发人员可以跳过 JAX-RPC，直接使用 JAX-WS。它们都支持 SOAP 1.1 over HTTP 1.1，所以完全兼容：JAX-WS Web 服务客户机可以访问 JAX-RPC Web 服务端点，反之亦然。</p><p>与 JAX-RPC 相比，JAX-WS 有许多优点。JAX-WS：</p><ul><li>支持 SOAP 1.2 标准（以及 SOAP 1.1）。</li><li>支持 XML over HTTP。如果愿意，可以不使用 SOAP。（更多信息参见文章 “Use XML directly over HTTP for Web services (where appropriate)”。）</li><li>使用 Java Architecture for XML Binding（JAXB）作为数据映射模型。JAXB 完全支持 XML 模式，而且性能更好（更多信息见下文）。</li><li>为客户机和服务器引入了一个动态编程模型。客户机模型支持面向消息方式和异步方式。</li><li>支持 Message Transmission Optimization Mechanism（MTOM），这是一个用于优化 SOAP 消息传输和格式的 W3C 建议规范。</li><li>升级了 Web services interoperability（WS-I）支持。（它支持 Basic Profile 1.1；JAX-WS 只支持 Basic Profile 1.0。）</li><li>升级了 SOAP 附件支持。（它支持 Attachments API for Java [SAAJ] 1.3：JAX-WS 只支持 SAAJ 1.2。）</li></ul><p>通过阅读文章 “Web 服务提示与技巧: JAX-RPC 与 JAX-WS 的比较”，可以进一步了解这些差异。</p><p>JAX-WS 中的 wsimport 工具自动地处理 Web 服务开发的许多细节，并以跨平台方式集成到构建过程中，这让开发人员可以将注意力集中于实现或使用服务的应用程序逻辑。它生成各种工件，包括服务、服务端点接口（SEI）、异步响应代码、基于 WSDL 错误的异常以及通过 JAXB 绑定到模式类型的 Java 类。</p><p>JAX-WS 还能够提高 Web 服务的性能。在文章 “Implementing High Performance Web Services Using JAX-WS 2.0”（参见 参考资料 中的链接）中，对基于 JAX-WS 的 Web 服务实现（使用了 Java EE 5 中的另外两个 Web 服务特性 — JAXB 和 StAX）和基于 J2EE 1.4 中的 JAX-RPC 的服务实现做了性能对比。这项研究发现在不同负载下 JAX-WS 在各个功能领域产生了 40% 到 1000% 的性能改进。</p><p><strong>Web 应用程序技术</strong></p><p>除了现有的 JavaServer Pages 和 Servlet 规范，Java EE 5 引入了两种前端技术 — JSF 和 JSTL。JSF 是一组 API，支持以基于组件的方式开发用户界面。JSTL 是一组标记库，支持在 JSP 中嵌入过程式逻辑、对 JavaBean 的访问方法、SQL 命令、本地化格式指令和 XML 处理。JSF、JSTL 和 JSP 的最新版本支持一种统一表达式语言（expression language，EL），这使这些技术更容易集成在一起（参见 参考资料）。</p><p><strong>JSF 1.2</strong></p><p>JSF 为常见的 UI 问题提供了内置支持，比如组件状态管理、事件处理、导航、用户输入检验和国际化。有经验的开发人员可以创建定制的强大的可重用组件，还可以为 Web 浏览器之外的其他客户机设备创建定制的组件。技术经验不足的用户可以在 Sun Java Studio Creator 等可视编程环境中重用定制组件，包括用于 HTML 界面的默认 JSF 标记库。这让编程新手也能够创建复杂的 Web 表示层。</p><p>在开放源码领域和受许可协议限制的软件领域中，第三方 JSF 组件越来越多了。在 Web 上搜索 “JSF components” 或 “JSF component libraries” 会找到几十种组件。许多组件都依赖于 Asynchronous JavaScript + XML（Ajax）技术，这种技术是 “Web 2.0” 运动背后的主要驱动力。Web 程序员可以使用它们创建出比传统 Web 应用程序更好的用户体验，同时避免了从头编写 Ajax 组件的麻烦。</p><p><strong>JSP 2.1</strong></p><p>JSP 技术是从 J2EE 2.1 开始出现的。它使用 Java Servlet 规范支持声明式的 UI 编程。它支持以文档形式编写 UI，Web 应用程序容器将这些文档转换为 Java servlet 并编译，然后调用它们来响应请求。这些文档通常将 JSP 指令和脚本片段与某种标记语言（比如 HTML）混在一起。JSP 可以使用老式语法（使用以 &lt;% 开头、以 %> 结束的特殊标记），也可以使用新的语法（良构的 XML）。它们通常作为 Model-View-Controller（MVC） UI 框架的 “View” 部分。</p><p>与以前的版本相比，JSP 2.1 和 JSF 1.2 之间的兼容性更好，这主要是因为它们的 EL 语法已经集成为统一 EL。EL 支持的操作包括：</p><ul><li>在请求、会话和应用程序上下文中访问 JavaBean 的属性。</li><li>执行逻辑测试来做出各种选择，比如隐藏还是显示某个元素。</li><li>通过计算生成在 UI 中显示的数字和字符串。</li></ul><p>过去，JSP 和 JSF EL 语法有差异，而且容器计算它们的方式也不一样。统一 EL 消除了这些差异，还增加了一些特性，比如：</p><ul><li>一个可插入的框架，支持对 EL 的解释进行定制。</li><li>支持延期执行的表达式，JSP 标记处理器可以根据需要执行它们。</li><li>支持赋值操作，例如可以在 JSP 代码中用 EL 表达式设置 JavaBean 的属性。</li></ul><p>对于 JSP 标记库开发人员来说，好消息是标记处理器现在支持用注解注入资源，所以大大简化了执行 Java Naming and Directory Interface（JNDI）所需的资源配置和代码。</p><p><strong>JSTL 1.2</strong></p><p>JSTL 已经存在多年了，但是在 Java EE 5 之前，Java EE 还不包含它。JSTL 标记支持在 JSP 中嵌入以下类型的元素：</p><ul><li><strong>过程式逻辑</strong>，比如循环和 if/else 结构。</li><li><strong>对 JavaBean 的访问方法</strong>，这可以向 UI 提供动态数据并允许 UI 代码修改数据。</li><li>执行数据库访问的 <strong>SQL 命令</strong>。</li><li><strong>格式化指令</strong>，可以根据特定的地区对 UI 输出进行格式化。</li><li><strong>XML 处理</strong>，比如 Document Object Model（DOM）解析或 Extensible Stylesheet Language（XSL）转换。</li></ul><p>JSTL 1.2 是一个维护版本，它支持统一 EL 并解决了在同一个 JSP 页面中混用 JSF 标记和 JSTL 迭代标记时遇到的问题。</p><p><strong>Java Servlet 2.5</strong></p><p>Java Servlet 规范是 Java Web 层技术的核心，它的历史与 Java EE 技术本身一样长。设计这个规范是为了提供一种高效率的基于组件的 Web 应用程序开发方法，并确保 Web 应用程序可以移植到实现这个规范的任何服务器上。</p><p>Java EE 5 所需的 Servlet 2.5 规范是一个维护版本，它对 2.4 版做了一些次要的改进。它在 Java 5 平台上引入了一些依赖项，还引入了一些注解，它们可以减少对 Web 应用程序部署描述符配置文件（web.xml）的配置需求。还增加了一些方便的配置特性，例如可以用通配符和多个 url-pattern 元素更灵活地配置 servlet。</p><p><strong>企业应用程序技术</strong></p><p>有大量技术属于企业应用程序的范围，其中许多在 Java EE 5 中没有变化或者不适合在本文中详细讨论。这里主要关注两个改进：对 EJB 开发的简化和新的持久化特性。</p><p><strong>EJB 3.0</strong></p><p>EJB 规范是 Java EE 平台的核心。它定义如何封装应用程序的业务逻辑，并以高度可伸缩、可靠且感知事务的方式分布业务逻辑，确保并发的数据访问不会破坏数据。</p><p>EJB 有三种基本类型：</p><ul><li><strong>会话 bean</strong> 分成两类：<em>无状态</em> 和<em>有状态</em>。无状态会话 bean 用于那些为单一客户机请求提供服务的业务逻辑任务。有状态会话 bean 维护客户机的 “会话状态”，适合处理那些跨越多个客户机请求的任务。会话 bean 不能在客户机之间共享。会话 bean 通常会操作一个或多个实体 bean。</li><li><strong>实体 bean</strong> 代表持久化数据，数据通常是从数据库中装载的。实体 bean 可以在客户机之间共享，而且 EJB 规范提供了事务安全的机制，确保实体 bean 可以可靠地为多个并发客户机请求提供服务，而不会被破坏。实体 bean 可以自己管理持久化，也可以让容器来管理它（<em>容器管理的持久化（container-managed persistence，CMP）</em> ）。</li><li><strong>消息驱动 bean（MDB）</strong> 用来处理那些不要求客户机等待响应的客户机请求。它们通常与一个 Java Message Service（JMS）队列 — Java EE 5 中的另一种企业应用程序技术 — 进行交互，但是也可以以其他方式为异步客户机提供服务，客户机甚至可以不是用 Java 编写的。</li></ul><p>在过去，EJB 的开发很复杂很麻烦，开发人员常常不得不依靠工具来管理实现 EJB 所需的所有接口和部署描述符。规范为业务逻辑代码规定了许多限制，要求扩展特定的类或实现特定的接口。为了获得一个简单的 EJB 引用，就需要许多样板代码。这些问题使 EJB 在开发社区中名声很差；在许多情况中，EJB 确实很糟糕。</p><p>EJB 3.0 大大改进了 EJB 编程模型，这是提高 Java EE 5 开发人员生产率的主要因素之一。EJB 现在可以是一个加了注解的 “普通 Java 对象（plain old Java object，POJO）”，它不需要扩展特定的类。它只需要实现一个远程接口，您可以自己定义这个接口，也可以让 IDE 自动生成它。不再需要部署描述符了，因为 EJB 容器可以从 EJB 上的注解提取出所需的所有信息。</p><p>本文的 实践：RideSynergy 应用程序 一节通过示例代码给出这些改进的具体示例。如果需要了解更深入的细节，可以在 参考资料 中找到两篇文章的链接，这两篇文章提供了更有说服力的示例，说明了这个最新版本对 EJB 开发的改进是多么显著。</p><p><strong>Java Persistence API（JPA 1.0）</strong></p><p>JPA 引入了一个用于 Java 对象持久化的对象-关系映射（object-relational mapping，ORM）框架。在开发它时主要考虑 EJB 的需要，但是它可以用于任何 Java 对象。可以使用注解指定哪些对象和字段应该持久化，以及它们应该映射到哪些数据库表和字段。JPA 支持一种与 SQL 相似的查询语言。这种查询语言可以：</p><ul><li>定义参数化的查询，这种查询可以以有序列表形式接收参数（按索引号引用参数），也可以采用按名称引用的命名参数。</li><li>按照持久化实体之间的关系执行查询，而不需要 JOIN 语句（但是，如果您愿意，也可以使用 JOIN 语句）。</li><li>按照与 SQL 相似的方式指定搜索条件（比较操作符、LIKE 语句、BETWEEN 语句等等），定义如何对待结果集（使用 DISTINCT、ORDER BY、GROUP BY 等操作符）。</li></ul><p>JPA 给 Java EE 平台提供了新功能，解决了与手工持久化和容器持久化相关的许多麻烦。文章 “使用 EJB 3.0 Java Persistence API 设计企业应用程序” 提供了更多信息。</p><p><strong>管理和安全性</strong></p><p>Java EE 5 需要三个与以前版本相同的管理和安全性规范：</p><ul><li><strong>Application Deployment</strong> 提供一个用于将组件和应用程序部署到 Java EE 容器的 API。工具可以通过这个 API 将代码部署到 Java EE 5 容器中，而不需要重新启动容器。在开发期间，IDE 常常使用这个 API 支持快速的编写/测试/纠正循环。</li><li><strong>Application Management</strong> 为容器管理的对象指定必需的属性和操作。它与多种行业标准管理协议兼容。</li><li><strong>Authorization Contract for Containers</strong>（Java ACC）定义安全策略提供者的语义，以及如何授予对这个合约中的操作的访问权。它要求容器实现一些接口，使部署工具能够管理授权角色。</li></ul><p>在 Java EE 5 中，这些规范都是维护版本（版本号都从 J2EE 1.4 中的 1.0 版升到 1.1 版），做了一些次要改进，这些超出了本文的范围。更多信息参见 参考资料 中的 Java EE Management and Security Technologies 链接。</p><p><strong>实践：RideSynergy 应用程序</strong></p><p>本节通过几个示例展示 Java EE 5 中的简化编程模型，说明这些模型如何提高开发人员的生产率。您可以看到如何通过这些模型快速开发一个示例应用程序，这个程序包含一个 Web 服务端点和客户机，使用 EJB 实现业务逻辑，使用 JSF 作为 Web 前端。</p><p><strong>WAS CE 2.0 上的 Java EE 5</strong></p><p>WebSphere® Application Server, Community Edition（WAS CE）2.0 已经通过 Java EE 5 认证。了解关于 WAS CE 的更多信息并免费下载。</p><p>我将使用一个简单的 Web 应用程序演示 Java EE 5 技术，这个程序是一个称为 RideSynergy 的虚构的服务（下载 中提供了源代码）。RideSynergy 服务帮助人们在网上安排合作用车。我使用 NetBeans 5.5 开发这个服务，并在 Sun Application Server 9.0_01 和 WebSphere Application Server（Community Edition）2.0 上测试过。</p><p>RideSynergy 的工作方式如下：</p><ul><li>它通过一个 Web 页面接受车辆供应和请求。</li><li>如果用户提供车辆，它会显示匹配的车辆请求列表。</li><li>如果用户请求车辆，它会显示匹配的车辆供应列表。</li><li>为了方便用户，它会在显示车辆供应和请求结果时显示天气预报，因为天气可能影响用户的决定。</li><li>它以 Web 服务的形式向第三方应用程序提供关于供应和请求的统计数据。</li></ul><p>访问 RideSynergy 的用户使用图 1 所示的页面提供或请求车辆，需要指定旅行起点和终点的 ZIP 编码并输入一个电子邮件地址。这个页面还提供查看当地天气报告的选项。</p><p>图 1. RideSynergy 供应和请求页面</p><div class=pgc-img><img alt="Java EE 5：强大的功能、高生产率和低复杂性" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1f8b1aa109964f528444ddc4d6748ae2><p class=pgc-img-caption></p></div><p>如果提交一个车辆供应，结果页面（见图 2）会列出匹配的所有车辆请求。如果提交一个车辆请求，会列出匹配的供应。只有在供应和请求页面上选择 Check weather 复选框，才会显示天气预报（注意，在实际的应用程序中，显示五天的天气预报数据。为了简单，图 2 被截短了）。天气预报数据是从一个公共 Web 服务（http://www.webservicex.net）获得的。</p><p>图 2. RideSynergy 结果页面</p><div class=pgc-img><img alt="Java EE 5：强大的功能、高生产率和低复杂性" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0a5f81e1ccfc49a8aedd575159e2df80><p class=pgc-img-caption></p></div><p>RideSynergy 背后的代码展示了 Java EE 5 的简单 Web 服务编程模型：它使用 JAX-WS 建立一个 Web 服务端点定义（其中包含一个注解），并用 wsimport 特性创建一个 Web 服务客户机。它还展示了 Java EE 5 中的简单 EJB 编程模型和 JSF 的基本原理。</p><p><strong>注解：用更少的代码做更多工作</strong></p><p>RideSynergy 以 Web 服务的形式提供统计数据，这个特性很好地说明了 Java EE 5 让我们能够用更少的代码做更多工作。这个特性是在 RideStatistics 类中实现的，它演示了最简单的 Java EE 5 注解形式。但是，简单并不意味着功能不强：它们说明，与 J2EE 1.4 方式相比，用 Java EE 5 方式实现这些特性要简单得多。</p><p>清单 1 中的 RideStatistics 类实现一个 Web 服务，它使用无状态 RideManagerBean 会话 bean，根据 Web 服务客户机指定的起点和终点 ZIP 编码查询匹配的车辆供应数量。RideManagerRemote 接口定义 RideManagerBean 上可供客户机代码使用的操作，客户机代码可以在同一个 JVM 中运行，也可以在其他 JVM 中运行。</p><p>清单 1. RideStatistics Web 服务</p><pre>package com.ridesynergy; import java.util.Set;import javax.ejb.EJB;import javax.jws.WebService; /** * Web Service that exposes a count of ride offers made to and from specific * ZIP codes. * * @author smoore */@WebServicepublic class RideStatistics {  @EJB RideManagerRemote rideManager;  /** Creates a new instance of RideStatistics */ public RideStatistics() { }  public Integer rideOffersFromZipCode(Integer zipCode) { Set&lt;Ride&lt; results = rideManager.findCloseOfferMatches(zipCode, 0); return new Integer(results.size());}  public Integer rideOffersToZipCode(Integer zipCode) { Set&lt;Ride&lt; results = rideManager.findCloseOfferMatches(0, zipCode); return new Integer(results.size()); }}</pre><p>清单 1 包含两个注解：@WebService 和 @EJB。首先，我要讨论如何通过 @EJB 注解用<em>依赖项注入（dependency injection）</em> 技术访问 EJB。然后讨论如何通过 @WebService 注解将一个 POJO 变成完整的 Web 服务端点。</p><p><strong>依赖项注入</strong></p><p>如果您熟悉 J2EE 1.4 中的 EJB 编程，那么在看到 清单 1 时可能会问：<em>真的</em> 这么容易就获得了一个 EJB 的引用吗？是的，因为 @EJB 注解提供了一种基于依赖项注入的简单编程模型。</p><p>有了 @EJB 注解，就不再需要编写 J2EE 1.4 中的那些复杂代码（比如清单 2 中的代码）：</p><p>清单 2. Java EE 5 之前的 RideManagerBean 客户机</p><pre>. . . Context initial = new InitialContext(); Context myEnv = (Context) initial.lookup("java:comp/env"); Object obj = myEnv.lookup("ejb/RideManager"); RideManagerHome home = (RideManagerHome) PortableRemoteObject.narrow( obj, RideManagerRemote.class); RideManager manager = home.create();. . .</pre><p>在 Java EE 5 支持的 EJB 3.0 编程模型中，这个 @EJB 注解<em>注入</em>RideStatistics 对 RideManagerRemote的依赖项，这样 RideStatistics 就不需要用 JNDI 查找引用。</p><p>它还避免了直接依赖于包含 RideManagerRemote 的包。看一下 import 语句；这里没有针对 RideManagerRemote 的 import 语句（但是，它却可以通过编译）。所以，可以将 RideManagerRemote重构到另一个包中，而不需要更新和重新编译 RideStatistics。</p><p>注解还给依赖项的另一方面带来许多好处：实际 EJB 提供 RideManagerRemote 背后的实现并告诉 Java EE 5 容器用它做什么。我将稍后解释。</p><p><strong>复杂的运行时行为</strong></p><p>当部署到 Java EE 5 容器时，JAX-WS 处理 清单 1 中的 @WebService 注解，并将 RideStatistics 类转换为一个完整的 Web 服务端点，这个端点包含两个操作：rideOffersFromZipCode 和 rideOffersFromToZipCode。JAX-WS 处理提供 Web 服务所需的所有工作，包括生成 Web Services Description Language（WSDL），让 Web 上的其他应用程序能够发现并使用这个 Web 服务，还提供机制响应对 Web 服务的客户机请求。</p><p>JAX-WS 为 RideStatistics Web 服务生成 WSDL 的默认位置是 http://<em>server</em>:<em>port</em>/ridesynergy2-war/RideStatisticsService?WSDL。按照以下步骤查看这个 WSDL：</p><ol><li>下载 RideSynergy 企业存档文件 ridesynergy2.ear（见 下载）并将它部署到 Java EE 5 容器中。</li><li>将默认位置中的 <em>server</em> 和 <em>port</em> 值替换为容器的主机名和端口。</li><li>在浏览器中访问这个位置。</li></ol><p><strong>更复杂的注解</strong></p><p>清单 1 中的注解只是简单的注解。注解还可以接受<em>命名元素（named element）</em>，这种元素与方法参数相似，但是参数的次序和数量不重要，因为每个参数都有名称。使用命名元素就像是将一个映射传递给注解，其中包含的键/值对可以决定处理注解的方式。</p><p>WeatherForecastSoap 接口（见清单 3）是由 JAX-WS 中的 wsimport 工具创建的，其中包含接受命名元素的注解。清单 3 给出 WeatherForecastSoap 接口：</p><p>清单 3. WeatherForecastSoap 接口</p><pre>. . .  @WebMethod(operationName = "GetWeatherByZipCode",  action = "http://www.webservicex.net/GetWeatherByZipCode") public WeatherForecasts getWeatherByZipCode( @WebParam(name = "ZipCode",  targetNamespace = "http://www.webservicex.net") String zipCode);. . .</pre><p>在清单 3 中，getWeatherByZipCode() 方法上有一个 @WebMethod 注解，这个注解有两个命名元素：operationName 和 action。getWeatherByZipCode() 的 zipCode 参数上有一个 @WebParam 注解，这个注解包含命名元素 name 和 targetNamespace（注意在实际应用程序中，getWeatherByZipCode() 还有其他注解，这里省略掉了）。</p><p>定义注解的代码指定注解接受哪些命名元素（如果有的话）。细节参见 参考资料 中的注解初级教程链接。</p><p><strong>声明无状态会话 bean</strong></p><p>清单 4 给出 RideManagerBean 的类声明，这个无状态会话 bean 实现了 清单 1 所示的 RideManagerRemote 接口：</p><p>清单 4. 无状态会话 bean 声明</p><pre>. . .@Statelesspublic class RideManagerBean implements RideManagerRemote {. . .</pre><p>在 J2EE 1.4 中，EJB 必须实现 SessionBean 接口，这个接口要求实现六个方法。在许多情况下，这些方法实现都是空的，它们之所以存在只是为了满足接口的要求，让代码能够通过编译，这使代码很杂乱。EJB 3.0 通过提供生命周期注解 @PostConstruct、@PreDestroy、@PostActivate 和 @PrePassivate 消除了这种混乱。可以根据需要将这些注解添加到适当的方法上，从而实现对生命周期事件的响应；只要求这些方法是公共方法，没有参数并返回 void。</p><p><strong>用注解替代部署描述符</strong></p><p>Java EE 5 中的注解还可以消除以前的 Java EE 版本所需的大量配置代码。例如，清单 4 中的 @Stateless 注解可以替代 EJB 部署描述符，EJB 部署描述符是一个 XML 配置文件，它向容器提供 EJB 的细节。在以前的 Java EE 平台中，必须在一个符合 EJB 2.1 模式的 XML 文件中包含这样的描述符。清单 5 给出配置 RideManagerBean 和所需接口的代码片段：</p><p>清单 5. Java EE 5 以前的部署描述符</p><pre>&lt;display-name&gt;RideManagerJAR&lt;/display-name&gt;&lt;enterprise-beans&gt; &lt;session&gt; &lt;ejb-name&gt;RideManagerBean&lt;/ejb-name&gt; &lt;home&gt;com.ridesynergy.RideManagerHome&lt;/home&gt; &lt;remote&gt;com.ridesynergy.RideManager&lt;/remote&gt; &lt;ejb-class&gt;com.ridesynergy.RideManagerBean&lt;/ejb-class&gt; &lt;session-type&gt;Stateless&lt;/session-type&gt; &lt;transaction-type&gt;Bean&lt;/transaction-type&gt; &lt;security-identity&gt; &lt;use-caller-identity/&gt; &lt;/security-identity&gt; &lt;/session&gt;&lt;/enterprise-beans&gt;</pre><p>Java EE 5 向后兼容以前的 EJB 部署描述符。如果愿意，甚至可以混合使用这两种方式，让遗留代码用描述符指定 EJB，而用注解声明新的 EJB。</p><p>除了减少所需的代码量之外，注解还在维护方面有好处，因为配置信息就放在源代码中，Sun 的架构师 Graham Hamilton 将这称为 “truth-in-source-code”（参见 参考资料）：对于正确地加上注解的类，不需要同时查看源代码和配置文件，就能够理解其运行方式，因为注解在源代码中直接定义了特殊行为。</p><p>在 Roland Barcia 的文章 “了解 Java EE 5” 中，通过许多示例展示了 Java EE 5 中的注解如何简化应用程序开发。</p><p><strong>合理的默认行为</strong></p><p>我们只添加了一个简单的注解，就把 RideStatistics 变成了一个 Web 服务，这也展示了另一个 Java EE 5 设计原则：提供合理的默认行为，从而使编程模型更简单。</p><p>在这个示例中，JAX-WS 假设在带 @WebService 注解的类中所有公共方法都应该转换为 Web 服务操作，并以方法名作为操作名。在处理这些方法的输入参数和输出参数时，也会做相似的假设。如果默认行为不适合您的需要，那么可以通过在方法上加注解来修改。但是在许多情况下，都希望 Web 服务中使用的名称与实现 Web 服务的类匹配，所以 JAX-WS 的默认行为是很合理的，这大大简化了 Web 服务的开发。</p><p><strong>结束语</strong></p><p>在过去，Java EE 技术虽然很强大，但是也很麻烦；开发人员必须忍受它的复杂性，或者使用开发工具 “驯服” 它，才能享受到它的好处。这让大家觉得使用 Java EE 非常累人，只有在大型的企业级平台确实需要它的强大特性，而且组织拥有能够应付 Java EE 开发的资源的情况下，才会考虑使用这种平台。</p><p>Java EE 5 试图消除这种坏名声，使它成为适合企业应用程序开发的强大且易用的平台，采取的措施包括提供注解等新的语言特性，采用合理的默认行为等设计目标，以及强调更简单的编程模型。另外，更简单的编程模型减少了不必要的复杂性，降低了开发人员对第三方工具的需求。因此，开发强大的企业应用程序的成本现在显著降低了。开发人员花在与平台 “搏斗” 上的时间更少了，可以集中更多精力开发需要的实际功能，开发速度大大提高了。</p><p>以前被 Java EE 技术吓退的开发团队应该重新审视 Java EE 5，现有 J2EE 应用程序的开发人员和维护人员应该研究 Java EE 5 中的众多特性，从而使自己的工作更轻松。</p><div class=pgc-img><img alt="Java EE 5：强大的功能、高生产率和低复杂性" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/5da1aa9c-13cc-4bab-9693-ecf1eb808318><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','EE','强大'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>