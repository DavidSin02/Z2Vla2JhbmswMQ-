<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>10分钟，掌握C语言指针 | 极客快訊</title><meta property="og:title" content="10分钟，掌握C语言指针 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/S25kjOh6BBFiP3"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f5e3e293.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f5e3e293.html><meta property="article:published_time" content="2020-11-14T21:00:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:21+08:00"><meta name=Keywords content><meta name=description content="10分钟，掌握C语言指针"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f5e3e293.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>10分钟，掌握C语言指针</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>说到指针，估计还是有很多小伙伴都还是云里雾里的，有点“知其然，而不知其所以然”。但是，不得不说，学了指针，C语言才能算是入门了。指针是C语言的<strong>「精华」</strong>，可以说，对对指针的掌握程度，<strong>「直接决定」</strong>了你C语言的编程能力。</p><p>在讲指针之前，我们先来了解下变量在<strong>「内存」</strong>中是如何存放的。</p><p>在程序中定义一个变量，那么在程序编译的过程中，系统会根据你定义变量的类型来分配<strong>「相应尺寸」</strong>的内存空间。那么如果要使用这个变量，只需要用变量名去访问即可。</p><p>通过变量名来访问变量，是一种<strong>「相对安全」</strong>的方式。因为只有你定义了它，你才能够访问相应的变量。这就是对内存的基本认知。但是，如果光知道这一点的话，其实你还是不知道内存是如何存放变量的，因为底层是如何工作的，你依旧不清楚。</p><p>那么如果要继续深究的话，你就需要把变量在内存中真正的样子是什么搞清楚。内存的最小索引单元是<code>1字节</code>，那么你其实可以把内存比作一个超级大的<strong>「字符型数组」</strong>。在上一节我们讲过，数组是有下标的，我们是通过数组名和下标来访问数组中的元素。那么内存也是一样，只不过我们给它起了个新名字：<code>地址</code>。每个地址可以存放<strong>「1字节」</strong>的数据，所以如果我们需要定义一个整型变量，就需要占据4个内存单元。</p><p>那么，看到这里你可能就明白了：其实在程序运行的过程中，完全不需要变量名的参与。变量名只是方便我们进行代码的编写和阅读，只有程序员和编译器知道这个东西的存在。而编译器还知道具体的变量名对应的<strong>「内存地址」</strong>，这个是我们不知道的，因此编译器就像一个桥梁。当读取某一个变量的时候，编译器就会找到变量名所对应的地址，读取对应的值。</p><p></p><h1 toutiao-origin=h2>初识指针和指针变量</h1><p>那么我们现在就来切入正题，指针是个什么东西呢？</p><p>所谓指针，就是内存地址（下文简称地址）。C语言中设立了专门的<strong>「指针变量」</strong>来存储指针，和<strong>「普通变量」</strong>不一样的是，指针变量存储的是<strong>「地址」</strong>。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>定义指针</strong></h2><p>指针变量也有类型，实际上取决于地址指向的值的类型。那么如何定义指针变量呢：</p><p>很简单：<code>类型名* 指针变量名</code></p><pre><code>char* pa;//定义一个字符变量的指针，名称为pa<br>int* pb;//定义一个整型变量的指针，名称为pb<br>float* pc;//定义一个浮点型变量的指针，名称为pc<br></code></pre><p>注意，指针变量一定要和指向的变量的类型一样，不然类型不同可能在内存中所占的位置不同，如果定义错了就可能导致出错。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>取地址运算符和取值运算符</strong></h2><p>获取某个变量的地址，使用取地址运算符<code>&</code>，如：</p><pre><code>char* pa = &amp;a;<br>int* pb = &amp;f;<br></code></pre><p>如果反过来，你要访问指针变量指向的数据，那么你就要使用取值运算符<code>*</code>，如：</p><pre><code>printf("%c, %d\n", *pa, *pb);<br></code></pre><p>这里你可能发现，定义指针的时候也使用了<code>*</code>，这里属于符号的<strong>「重用」</strong>，也就是说这种符号在不同的地方就有不同的用意：在定义的时候表示<strong>「定义一个指针变量」</strong>，在其他的时候则用来<strong>「获取指针变量指向的变量的值」</strong>。</p><p>直接通过变量名来访问变量的值称之为<code>直接访问</code>，通过指针这样的形式访问称之为<code>间接访问</code>，因此取值运算符有时候也成为<strong>「间接运算符」</strong>。</p><p>比如：</p><pre><code>//Example 01<br>//代码来源于网络，非个人原创<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char a = 'f';<br>int f = 123;<br>char* pa = &amp;a;<br>int* pf = &amp;f;<br><br>printf("a = %c\n", *pa);<br>printf("f = %d\n", *pf);<br><br>*pa = 'c';<br>*pf += 1;<br><br>printf("now, a = %c\n", *pa);<br>printf("now, f = %d\n", *pf);<br><br>printf("sizeof pa = %d\n", sizeof(pa));<br>printf("sizeof pf = %d\n", sizeof(pf));<br><br>printf("the addr of a is: %p\n", pa);<br>printf("the addr of f is: %p\n", pf);<br><br>return 0;<br>}<br></code></pre><p>程序实现如下：</p><pre><code>//Consequence 01<br>a = f<br>f = 123<br>now, a = c<br>now, f = 124<br>sizeof pa = 4<br>sizeof pf = 4<br>the addr of a is: 00EFF97F<br>the addr of f is: 00EFF970<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>避免访问未初始化的指针</strong></h2><pre><code>void <strong class=highlight-text toutiao-origin=span>f</strong><br>{<br>int* a;<br>*a = 10;<br>}<br></code></pre><p>像这样的代码是十分危险的。因为指针a到底指向哪里，我们不知道。就和访问未初始化的普通变量一样，会返回一个<strong>「随机值」</strong>。但是如果是在指针里面，那么就有可能覆盖到<strong>「其他的内存区域」</strong>，甚至可能是系统正在使用的<strong>「关键区域」</strong>，十分危险。不过这种情况，系统一般会驳回程序的运行，此时程序会被<strong>「中止」</strong>并<strong>「报错」</strong>。要是万一中奖的话，覆盖到一个合法的地址，那么接下来的赋值就会导致一些有用的数据被<strong>「莫名其妙地修改」</strong>，这样的bug是十分不好排查的，因此使用指针的时候一定要注意初始化。</p><p></p><h1 toutiao-origin=h2>指针和数组</h1><p>有些读者可能会有些奇怪，指针和数组又有什么关系？这俩货明明八竿子打不着井水不犯河水。别着急，接着往下看，你的观点有可能会改变。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>数组的地址</strong></h2><p>我们刚刚说了，指针实际上就是变量在<strong>「内存中的地址」</strong>，那么如果有细心的小伙伴就可能会想到，像数组这样的一大摞变量的集合，它的地址是啥呢？</p><p>我们知道，从标准输入流中读取一个值到变量中，用的是<code>scanf</code>函数，一般貌似在后面都要加上<code>&</code>，这个其实就是我们刚刚说的<strong>「取地址运算符」</strong>。如果你存储的位置是指针变量的话，那就不需要。</p><pre><code>//Example 02<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int a;<br>int* p = &amp;a;<br><br>printf("请输入一个整数：");<br>scanf("%d", &amp;a);//此处需要&amp;<br>printf("a = %d\n", a);<br><br>printf("请再输入一个整数：");<br>scanf("%d", p);//此处不需要&amp;<br>printf("a = %d\n", a);<br><br>return 0;<br>}<br></code></pre><p>程序运行如下：</p><pre><code>//Consequence 02<br>请输入一个整数：1<br>a = 1<br>请再输入一个整数：2<br>a = 2<br></code></pre><p>在普通变量读取的时候，程序需要知道这个变量在内存中的地址，因此需要<code>&</code>来取地址完成这个任务。而对于指针变量来说，本身就是<strong>「另外一个」</strong>普通变量的<strong>「地址信息」</strong>，因此直接给出指针的值就可以了。</p><p>试想一下，我们在使用<code>scanf</code>函数的时候，是不是也有不需要使用<code>&</code>的时候？就是在读取<strong>「字符串」</strong>的时候：</p><pre><code>//Example 03<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char url[100];<br>url[99] = '\0';<br>printf("请输入TechZone的域名：");<br>scanf("%s", url);//此处也不用&amp;<br>printf("你输入的域名是：%s\n", url);<br>return 0;<br>}<br></code></pre><p>程序执行如下：</p><pre><code>//Consequence 03<br>请输入TechZone的域名：www.techzone.ltd<br>你输入的域名是：www.techzone.ltd<br></code></pre><p>因此很好推理：数组名其实就是一个<strong>「地址信息」</strong>，实际上就是数组<strong>「第一个元素的地址」</strong>。咱们试试把第一个元素的地址和数组的地址做个对比就知道了：</p><pre><code>//Example 03 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char url[100];<br>printf("请输入TechZone的域名：");<br>url[99] = '\0';<br>scanf("%s", url);<br>printf("你输入的域名是：%s\n", url);<br><br>printf("url的地址为：%p\n", url);<br>printf("url[0]的地址为：%p\n", &amp;url[0]);<br><br>if (url == &amp;url[0])<br>{<br>printf("两者一致！");<br>}<br>else<br>{<br>printf("两者不一致！");<br>}<br>return 0;<br>}<br></code></pre><p>程序运行结果为：</p><pre><code>//Comsequense 03 V2<br>请输入TechZone的域名：www.techzone.ltd<br>你输入的域名是：www.techzone.ltd<br>url的地址为：0063F804<br>url[0]的地址为：0063F804<br>两者一致！<br></code></pre><p>这么看，应该是实锤了。那么数组后面的元素也就是依次往后放置，有兴趣的也可以自己写代码尝试把它们输出看看。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指向数组的指针</strong></h2><p>刚刚我们验证了数组的地址就是数组第一个元素的地址。那么指向数组的指针自然也就有两种定义的方法：</p><pre><code>...<br>char* p;<br>//方法1<br>p = a;<br>//方法2<br>p = &amp;a[0];<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指针的运算</strong></h2><p>当指针指向数组元素的时候，可以对指针变量进行<strong>「加减」</strong>运算，<code>+n</code>表示指向p指针所指向的元素的<strong>「下n个元素」</strong>，<code>-n</code>表示指向p指针所指向的元素的<strong>「上n个元素」</strong>。并不是将地址加1。</p><p>如：</p><pre><code>//Example 04<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int a = { 1,2,3,4,5 };<br>int* p = a;<br>printf("*p = %d, *(p+1) = %d, *(p+2) = %d\n", *p, *(p + 1), *(p + 2));<br>printf("*p -&gt; %p, *(p+1) -&gt; %p, *(p+2) -&gt; %p\n", p, p + 1, p + 2);<br>return 0;<br>}<br></code></pre><p>执行结果如下：</p><pre><code>//Consequence 04<br>*p = 1, *(p+1) = 2, *(p+2) = 3<br>*p -&gt; 00AFF838, *(p+1) -&gt; 00AFF83C, *(p+2) -&gt; 00AFF840<br></code></pre><p>有的小伙伴可能会想，编译器是怎么知道访问下一个元素而不是地址直接加1呢？</p><p>其实就在我们定义指针变量的时候，就已经告诉编译器了。如果我们定义的是整型数组的指针，那么指针加1，实际上就是加上一个<code>sizeof(int)</code>的距离。相对于标准的下标访问，使用指针来间接访问数组元素的方法叫做<code>指针法</code>。</p><p>其实使用指针法来访问数组的元素，不一定需要定义一个指向数组的单独的指针变量，因为数组名自身就是指向数组<strong>「第一个元素」</strong>的指针，因此指针法可以直接作用于数组名：</p><pre><code>...<br>printf("p -&gt; %p, p+1 -&gt; %p, p+2 -&gt; %p\n", a, a+1, a+2);<br>printf("a = %d, a+1 = %d, a+2 = %d", *a, *(a+1), *(a+2));<br>...<br></code></pre><p>执行结果如下：</p><pre><code>p -&gt; 00AFF838, p+1 -&gt; 00AFF83C, p+2 -&gt; 00AFF840<br>b = 1, b+1 = 2, b+2 = 3<br></code></pre><p>现在你是不是感觉，数组和指针有点像了呢？不过笔者先提醒，数组和指针虽然非常像，但是绝对<strong>「不是」</strong>一种东西。</p><p>甚至你还可以直接用指针来定义字符串，然后用下标法来读取每一个元素：</p><pre><code>//Example 05<br>//代码来源于网络<br>#include &lt;stdio.h&gt;<br>#include &lt;string.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char* str = "I love TechZone!";<br>int i, length;<br><br>length = strlen(str);<br><br>for (i = 0; i &lt; length, i++)<br>{<br>printf("%c", str[i]);<br>}<br>printf("\n");<br><br>return 0;<br>}<br></code></pre><p>程序运行如下：</p><pre><code>//Consequence 05<br>I love TechZone!<br></code></pre><p>在刚刚的代码里面，我们定义了一个<strong>「字符指针」</strong>变量，并且初始化成指向一个字符串。后来的操作，不仅在它身上可以使用<strong>「字符串处理函数」</strong>，还可以用<strong>「下标法」</strong>访问字符串中的每一个字符。</p><p>当然，循环部分这样写也是没毛病的：</p><pre><code>...<br>for (i = 0, i &lt; length, i++)<br>{<br>printf("%c", *(str + i));<br>}<br></code></pre><p>这就相当于利用了指针法来读取。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指针和数组的区别</strong></h2><p>刚刚说了许多指针和数组相互替换的例子，可能有的小伙伴又开始说：“这俩货不就是一个东西吗？”</p><p>随着你对指针和数组越来越了解，你会发现，C语言的创始人不会这么无聊去创建两种一样的东西，还叫上不同的名字。指针和数组终究是<strong>「不一样」</strong>的。</p><p>比如笔者之前看过的一个例子：</p><pre><code>//Example 06<br>//代码来源于网络<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char str = "I love TechZone!";<br>int count = 0;<br><br>while (*str++ != '\0')<br>{<br>count++;<br>}<br>printf("总共有%d个字符。\n", count);<br><br>return 0;<br>}<br></code></pre><p>当编译器报错的时候，你可能会开始怀疑你学了假的C语言语法：</p><pre><code>//Error in Example 06<br>错误(活动)E0137表达式必须是可修改的左值<br>错误C2105“++”需要左值<br></code></pre><p>我们知道，<code>*str++ != ‘\0’</code>是一个复合表达式，那么就要遵循<strong>「运算符优先级」</strong>来看。具体可以回顾《C语言运算符优先级及ASCII对照表》。</p><p><code>str++</code>比<code>*str</code>的优先级<strong>「更高」</strong>，但是自增运算符要在<strong>「下一条语句」</strong>的时候才能生效。所以这个语句的理解就是，先取出<code>str</code>所指向的值，判断是否为<code>\0</code>，若是，则跳出循环，然后<code>str</code>指向下一个字符的位置。</p><p>看上去貌似没啥毛病，但是，看看编译器告诉我们的东西：<code>表达式必须是可修改的左值</code></p><p><code>++</code>的操作对象是<code>str</code>，那么<code>str</code>到底是不是<strong>「左值」</strong>呢？</p><p>如果是左值的话，那么就必须满足左值的条件。</p><blockquote><strong toutiao-origin=span>❝</strong><ol><li><p>拥有用于识别和定位一个存储位置的标识符</p></li><li><p>存储值可修改</p></li></ol>❞</blockquote><p>第一点，数组名<code>str</code>是可以满足的，因为数组名实际上就是定位数组第一个元素的位置。但是第二点就不满足了，数组名实际上是一个地址，地址是<strong>「不可以」</strong>修改的，它是一个常量。如果非要利用上面的思路来实现的话，可以将代码改成这样：</p><pre><code>//Example 06 V2<br>//代码来源于网络<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char str = "I love TechZone!";<br>char* target = str;<br>int count = 0;<br><br>while (*target++ != '\0')<br>{<br>count++;<br>}<br>printf("总共有%d个字符。\n", count);<br><br>return 0;<br>}<br></code></pre><p>这样就可以正常执行了：</p><pre><code>//Consequence 06 V2<br>总共有16个字符。<br></code></pre><p>这样我们就可以得出：数组名只是一个<strong>「地址」</strong>，而指针是一个<strong>「左值」</strong>。</p><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指针数组？数组指针？</strong></h2><p>看下面的例子，你能分辨出哪个是指针数组，哪个是数组指针吗？</p><pre><code>int* p1[5];<br>int(*p2)[5];<br></code></pre><p>单个的我们都可以判断，但是组合起来就有些难度了。</p><p>答案：</p><pre><code>int* p1[5];//指针数组<br>int(*p2)[5];//数组指针<br></code></pre><p>我们挨个来分析。</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>指针数组</strong></h2><p>数组下标<code></code>的优先级是最高的，因此<code>p1</code>是一个有5个元素的<strong>「数组」</strong>。那么这个数组的类型是什么呢？答案就是<code>int*</code>，是<strong>「指向整型变量的指针」</strong>。因此这是一个<strong>「指针数组」</strong>。</p><p>那么这样的数组应该怎么样去初始化呢？</p><p>你可以定义5个变量，然后挨个取地址来初始化。</p><p>不过这样太繁琐了，但是，并不是说指针数组就没什么用。</p><p>比如：</p><pre><code>//Example 07<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>char* p1[5] = {<br>"人生苦短，我用Python。",<br>"PHP是世界上最好的语言！",<br>"One more thing...",<br>"一个好的程序员应该是那种过单行线都要往两边看的人。",<br>"C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。"<br>};<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%s\n", p1[i]);<br>}<br>return 0;<br>}<br></code></pre><p>结果如下：</p><pre><code>//Consequence 07<br>人生苦短，我用Python。<br>PHP是世界上最好的语言！<br>One more thing...<br>一个好的程序员应该是那种过单行线都要往两边看的人。<br>C语言很容易让你犯错误；C++看起来好一些，但当你用它时，你会发现会死的更惨。<br></code></pre><p>这样是不是比二维数组来的更加直接更加通俗呢？</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>数组指针</strong></h2><p><code></code>和<code></code>在优先级里面属于<strong>「同级」</strong>，那么就按照<strong>「先后顺序」</strong>进行。</p><p><code>int(*p2)</code>将<code>p2</code>定义为<strong>「指针」</strong>， 后面跟随着一个5个元素的<strong>「数组」</strong>，<code>p2</code>就指向这个数组。因此，数组指针是一个<strong>「指针」</strong>，它指向的是一个数组。</p><p>但是，如果想对数组指针初始化的时候，千万要小心，比如：</p><pre><code>//Example 08<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int(*p2)[5] = {1, 2, 3, 4, 5};<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%d\n", *(p2 + i));<br>}<br>return 0;<br>}<br></code></pre><p>Visual Studio 2019报出以下的错误：</p><pre><code>//Error and Warning in Example 08<br>错误(活动)E0146初始值设定项值太多<br>错误C2440“初始化”: 无法从“initializer list”转换为“int (*)[5]”<br>警告C4477“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”<br></code></pre><p>这其实是一个非常典型的错误使用指针的案例，编译器提示说这里有一个<strong>「整数」</strong>赋值给<strong>「指针变量」</strong>的问题，因为<code>p2</code>归根结底还是指针，所以应该给它传递一个<strong>「地址」</strong>才行，更改一下：</p><pre><code>//Example 08 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int temp[5] = {1, 2, 3, 4, 5};<br>int(*p2)[5] = temp;<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%d\n", *(p2 + i));<br>}<br>return 0;<br>}<br></code></pre><pre><code>//Error and Warning in Example 08 V2<br>错误(活动)E0144"int *" 类型的值不能用于初始化 "int (*)[5]" 类型的实体<br>错误C2440“初始化”: 无法从“int [5]”转换为“int (*)[5]”<br>警告C4477“printf”: 格式字符串“%d”需要类型“int”的参数，但可变参数 1 拥有了类型“int *”<br></code></pre><p>可是怎么还是有问题呢？</p><p>我们回顾一下，指针是如何指向数组的。</p><pre><code>int temp[5] = {1, 2, 3, 4, 5};<br>int* p = temp;<br></code></pre><p>我们原本以为，指针<code>p</code>是指向数组的指针，但是实际上<strong>「并不是」</strong>。仔细想想就会发现，这个指针实际上是指向的数组的<strong>「第一个元素」</strong>，而不是指向数组。因为数组里面的元素在内存中都是挨着个儿存放的，因此只需要知道第一个元素的地址，就可以访问到后面的所有元素。</p><p>但是，这么来看的话，指针<code>p</code>指向的就是一个<strong>「整型变量」</strong>的指针，并不是指向<strong>「数组」</strong>的指针。而刚刚我们用的数组指针，才是指向数组的指针。因此，应该将<strong>「数组的地址」</strong>传递给数组指针，而不是将第一个元素的地址传入，尽管它们值相同，但是<strong>「含义」</strong>确实不一样：</p><pre><code>//Example 08 V3<br>//Example 08 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int temp[5] = {1, 2, 3, 4, 5};<br>int(*p2)[5] = &amp;temp;//此处取地址<br>int i;<br>for (i = 0; i &lt; 5; i++)<br>{<br>printf("%d\n", *(*p2 + i));<br>}<br>return 0;<br>}<br></code></pre><p>程序运行如下：</p><pre><code>//Consequence 08<br>1<br>2<br>3<br>4<br>5<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指针和二维数组</strong></h2><p>在上一节《C语言之数组》我们讲过<strong>「二维数组」</strong>的概念，并且我们也知道，C语言的二维数组其实在内存中也是<strong>「线性存放」</strong>的。</p><p>假设我们定义了：<code>int array[4][5]</code></p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>array</strong></h2><p>array作为数组的名称，显然应该表示的是数组的<strong>「首地址」</strong>。由于二维数组实际上就是一维数组的<strong>「线性拓展」</strong>，因此array应该就是指的<code>指向包含5个元素的数组的指针</code>。</p><p>如果你用<code>sizeof</code>去测试<code>array</code>和<code>array+1</code>的话，就可以测试出来这样的结论。</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>*(array+1)</strong></h2><p>首先从刚刚的问题我们可以得出，<code>array+1</code>同样也是指的<code>指向包含5个元素的数组的指针</code>，因此<code>*(array+1)</code>就是相当于<code>array[1]</code>，而这刚好相当于<code>array[1][0]</code>的数组名。因此<code>*(array+1)</code>就是指第二行子数组的第一个元素的地址。</p><p></p><h2 toutiao-origin=h4><strong toutiao-origin=span>*(*(array+1)+2)</strong></h2><p>有了刚刚的结论，我们就不难推理出，这个实际上就是<code>array[1][2]</code>。是不是感觉非常简单呢？</p><p>总结一下，就是下面的这些结论，记住就好，理解那当然更好：</p><pre><code>*(array + i) == array[i]<br>*(*(array + i) + j) == array[i][j]<br>*(*(*(array + i) + j) + k) == array[i][j][k]<br>...<br></code></pre><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>数组指针和二维数组</strong></h2><p>我们在上一节里面讲过，在初始化二维数组的时候是可以偷懒的：</p><pre><code>int array[3] = {<br>{1, 2, 3},<br>{4, 5, 6}<br>};<br></code></pre><p>刚刚我们又说过，定义一个数组指针是这样的：</p><pre><code>int(*p)[3];<br></code></pre><p>那么组合起来是什么意思呢？</p><pre><code>int(*p)[3] = array;<br></code></pre><p>通过刚刚的说明，我们可以知道，<code>array</code>是指向一个3个元素的数组的<strong>「指针」</strong>，所以这里完全可以将<code>array</code>的值赋值给<code>p</code>。</p><p>其实C语言的指针非常灵活，同样的代码用不同的角度去解读，就可以有不同的应用。</p><p>那么如何使用指针来访问二维数组呢？没错，就是使用<strong>「数组指针」</strong>：</p><pre><code>//Example 09<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int array[3][4] = {<br>{0, 1, 2, 3},<br>{4, 5, 6, 7},<br>{8, 9, 10, 11}<br>};<br>int(*p)[4];<br>int i, j;<br>p = array;<br>for (i = 0, i &lt; 3, i++)<br>{<br>for (j = 0, j &lt; 4, j++)<br>{<br>printf("%2d ", *(*(p+i) + j));<br>}<br>printf("\n");<br>}<br>return 0;<br>}<br></code></pre><p>运行结果：</p><pre><code>//Consequence 09<br>0 1 2 3<br>4 5 6 7<br>8 9 10 11<br></code></pre><p></p><h1 toutiao-origin=h2>void指针</h1><p><code>void</code>实际上是<code>无类型</code>的意思。如果你尝试用它来定义一个变量，编译器肯定会<strong>「报错」</strong>，因为不同类型所占用的内存有可能<strong>「不一样」</strong>。但是如果定义的是一个指针，那就没问题。<code>void</code>类型中指针可以指向<strong>「任何一个类型」</strong>的数据，也就是说，任何类型的指针都可以赋值给<code>void</code>指针。</p><p>将任何类型的指针转换为<code>void</code>是没有问题的。但是如果你要反过来，那就需要<strong>「强制类型转换」</strong>。此外，不要对<code>void</code>指针<strong>「直接解引用」</strong>，因为编译器其实并不知道<code>void</code>指针会存放什么样的类型。</p><pre><code>//Example 10<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int num = 1024;<br>int* pi = &amp;num;<br>char* ps = "TechZone";<br>void* pv;<br><br>pv = pi;<br>printf("pi:%p,pv:%p\n", pi, pv);<br>printf("*pv:%d\n", *pv);<br><br>pv = ps;<br>printf("ps:%p,pv:%p\n", ps, pv);<br>printf("*pv:%s\n", *pv);<br>}<br></code></pre><p>这样会报错：</p><pre><code>//Error in Example 10<br>错误C2100非法的间接寻址<br>错误C2100非法的间接寻址<br></code></pre><p>如果一定要这么做，那么可以用<strong>「强制类型转换」</strong>：</p><pre><code>//Example 10 V2<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int num = 1024;<br>int* pi = &amp;num;<br>char* ps = "TechZone";<br>void* pv;<br><br>pv = pi;<br>printf("pi:%p,pv:%p\n", pi, pv);<br>printf("*pv:%d\n", *(int*)pv);<br><br>pv = ps;<br>printf("ps:%p,pv:%p\n", ps, pv);<br>printf("*pv:%s\n", pv);<br>}<br></code></pre><p>当然，使用void指针一定要小心，由于void指针几乎可以<strong>「通吃」</strong>所有类型，所以间接使得不同类型的指针转换变得合法，如果代码中存在不合理的转换，编译器也不会报错。</p><p>因此，void指针能不用则不用，后面讲函数的时候，还可以解锁更多新的玩法。</p><p></p><h1 toutiao-origin=h2>指针</h1><p>在C语言中，如果一个指针不指向任何数据，那么就称之为<strong>「空指针」</strong>，用<strong>「」</strong>来表示。其实是一个宏定义：</p><pre><code><strong class=highlight-text toutiao-origin=span>#define ((void *)0)</strong><br></code></pre><p>在大部分的操作系统中，地址0通常是一个<strong>「不被使用」</strong>的地址，所以如果一个指针指向，就意味着不指向任何东西。为什么一个指针要指向呢？</p><p>其实这反而是一种比较指的推荐的<strong>「编程风格」</strong>——当你暂时还不知道该指向哪儿的时候，就让它指向，以后不会有太多的麻烦，比如：</p><pre><code>//Example 11<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int* p1;<br>int* p2 = ;<br>printf("%d\n", *p1);<br>printf("%d\n", *p2);<br>return 0;<br>}<br></code></pre><p>第一个指针未被初始化。在有的编译器里面，这样未初始化的变量就会被赋予<strong>「随机值」</strong>。这样指针被称为<strong>「迷途指针」</strong>，<strong>「野指针」</strong>或者<strong>「悬空指针」</strong>。如果后面的代码对这类指针解引用，而这个地址又刚好是合法的话，那么就会产生莫名其妙的结果，甚至导致程序的崩溃。因此养成良好的习惯，在暂时不清楚的情况下使用，可以节省大量的后期调试的时间。</p><p></p><h1 toutiao-origin=h2>指向指针的指针</h1><p>开始套娃了。其实只要你理解了指针的概念，也就没什么大不了的。</p><pre><code>//Example 12<br>#include &lt;stdio.h&gt;<br>int<strong class=highlight-text toutiao-origin=span>main</strong>(void)<br>{<br>int num = 1;<br>int* p = &amp;num;<br>int** pp = &amp;p;<br><br>printf("num: %d\n", num);<br>printf("*p: %d\n", *p);<br>printf("**p: %d\n", **pp);<br>printf("&amp;p: %p, pp: %p\n", &amp;p, pp);<br>printf("&amp;num: %p, p: %p, *pp: %p\n", &amp;num, p, *pp);<br>return 0;<br>}<br></code></pre><p>程序结果如下：</p><pre><code>//Consequence 12<br>num: 1<br>*p: 1<br>**p: 1<br>&amp;p: 004FF960, pp: 004FF960<br>&amp;num: 004FF96C, p: 004FF96C, *pp: 004FF96C<br></code></pre><p>当然你也可以无限地套娃，一直指下去。不过这样会让代码可读性变得<strong>「很差」</strong>，过段时间可能你自己都看不懂你写的代码了。</p><p></p><h1 toutiao-origin=h2>指针数组和指向指针的指针</h1><p>那么，指向指针的指针有什么用呢？</p><p>它可不是为了去创造混乱代码，在一个经典的实例里面，就可以体会到它的用处：</p><pre><code>char* Books = {<br>"《C专家编程》",<br>"《C和指针》",<br>"《C的陷阱与缺陷》",<br>"《C Primer Plus》",<br>"《Python基础教程（第三版）》"<br>};<br></code></pre><p>然后我们需要将这些书进行分类。我们发现，其中有一本是写Python的，其他都是C语言的。这时候指向指针的指针就派上用场了。首先，我们刚刚定义了一个指针数组，也就是说，里面的所有元素的类型<strong>「都是指针」</strong>，而数组名却又可以用指针的形式来<strong>「访问」</strong>，因此就可以使用<strong>「指向指针的指针」</strong>来指向指针数组：</p><pre><code>...<br>char** Python;<br>char** CLang[4];<br><br>Python = &amp;Books[5];<br>CLang[0] = &amp;Books[0];<br>CLang[1] = &amp;Books[1];<br>CLang[2] = &amp;Books[2];<br>CLang[3] = &amp;Books[3];<br>...<br></code></pre><p>因为字符串的取地址值实际上就是其<strong>「首地址」</strong>，也就是一个<strong>「指向字符指针的指针」</strong>，所以可以这样赋值。</p><p>这样，我们就利用指向指针的指针完成了对书籍的分类，这样既避免了浪费多余的内存，而且当其中的书名要修改，只需要改一次即可，代码的灵活性和安全性都得到了提升。</p><p></p><h1 toutiao-origin=h2>常量和指针</h1><p>常量，在我们目前的认知里面，应该是这样的：</p><pre><code>520, 'a'<br></code></pre><p>或者是这样的：</p><pre><code><strong class=highlight-text toutiao-origin=span>#define MAX 1000</strong><br><strong class=highlight-text toutiao-origin=span>#define B 'b'</strong><br></code></pre><p>常量和变量最大的区别，就是前者<strong>「不能够被修改」</strong>，后者可以。那么在C语言中，可以将变量变成像具有常量一样的特性，利用<code>const</code>即可。</p><pre><code>const int max = 1000;<br>const char a = 'a';<br></code></pre><p>在<code>const</code>关键字的作用下，变量就会<strong>「失去」</strong>本来具有的可修改的特性，变成“只读”的属性。</p><p></p><h1 toutiao-origin=h2>指向常量的指针</h1><p>强大的指针当然也是可以指向被<code>const</code>修饰过的变量，但这就意味着<strong>「不能通过」</strong>指针来修改它所引用的值。总结一下，就是以下4点：</p><blockquote><strong toutiao-origin=span>❝</strong><ol><li><p>指针可以修改为指向不同的变量</p></li><li><p>指针可以修改为指向不同的常量</p></li><li><p>可以通过解引用来读取指针指向的数据</p></li><li><p>不可以通过解引用来修改指针指向的数据</p></li></ol>❞</blockquote><p></p><h1 toutiao-origin=h2>常量指针</h1><h2 toutiao-origin=h3><strong toutiao-origin=span>指向非常量的常量指针</strong></h2><p>指针本身作为一种<strong>「变量」</strong>，也是可以修改的。因此，指针也是可以被<code>const</code>修饰的，只不过位置稍稍<strong>「发生了点变化」</strong>：</p><pre><code>...<br>int* const p = &amp;num;<br>...<br></code></pre><p>这样的指针有如下的特性：</p><blockquote><strong toutiao-origin=span>❝</strong><ol><li><p>指针自身不能够被修改</p></li><li><p>指针指向的值可以被修改</p></li></ol>❞</blockquote><p></p><h2 toutiao-origin=h3><strong toutiao-origin=span>指向常量的常量指针</strong></h2><p>在定义普通变量的时候也用<code>const</code>修饰，就得到了这样的指针。不过由于限制太多，一般很少用到：</p><pre><code>...<br>int num = 100;<br>const int cnum = 200;<br>const int* const p = &amp;cnum;<br>...</code></pre><p>http://www.techzone.ltd/post/CPointer/</p><img alt=10分钟，掌握C语言指针 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S25kjOh6BBFiP3></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'10','分钟','语言'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>