<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>八、适配器模式与桥接模式详解 | 极客快訊</title><meta property="og:title" content="八、适配器模式与桥接模式详解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d055f9ada84b4227bc9c9f892143df3f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f6bba30.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f6bba30.html><meta property="article:published_time" content="2020-10-29T20:53:45+08:00"><meta property="article:modified_time" content="2020-10-29T20:53:45+08:00"><meta name=Keywords content><meta name=description content="八、适配器模式与桥接模式详解"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f6bba30.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>八、适配器模式与桥接模式详解</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>11.适配器模式</p><h3 class="md-end-block md-heading">11.1.定义</h3><p><strong>适配器模式</strong>是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p><p>适配器模式的英文翻译是 <strong>Adapter Design Pattern</strong>。顾名思义，这个模式就是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。</p><p><strong>示意图</strong></p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d055f9ada84b4227bc9c9f892143df3f><p class=pgc-img-caption></p></div><p><strong>生活场景：</strong>电源插转换头、手机充电转换头、显示器转接头。</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7d2dd6539ec843cc916f12a14446d9ff><p class=pgc-img-caption></p></div><p>你可以创建一个<strong>适配器</strong>。 这是一个特殊的对象， 能够<strong>转换对象接口</strong>， 使其能<strong>与其他对象进行交互</strong>。</p><p>适配器模式通过封装对象<strong>将复杂的转换过程藏于幕后</strong>。 被封装的对象甚至察觉不到适配器的存在。</p><p>适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下：</p><ol start=0><li>适配器实现与其中一个现有对象兼容的接口。</li><li>现有对象可以使用该接口安全地调用适配器方法。</li><li>适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。</li></ol><p>有时你甚至可以创建一个双向适配器来实现双向转换调用。</p><h3 class="md-end-block md-heading">11.2.应用场景</h3><ol start=0><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li></ol><h3 class="md-end-block md-heading">11.3.适配器角色</h3><p>Adaptee 是一组不兼容 ITarget 接口定义的接口。</p><p>ITarget 表示要转化成的接口定义。</p><p>Adapter/Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口。</p><p>适配器有3中形式：类适配器、对象适配器、接口适配器</p><h3 class="md-end-block md-heading">11.4.类适配器</h3><p>类适配器: 基于继承。</p><p>做法：让Adaptor实现ITarget接口，并且继承Adaptee，这样Adaptor就具备ITarget和Adaptee的特性，就可以将两者进行转化。</p><p>UML类图：</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5ff8fdba5fc6449da83b4fa0595e8512><p class=pgc-img-caption></p></div><pre><code> // 类适配器: 基于继承 ​ // ITarget 表示要转化成的接口定义 public interface ITarget {   void f1();   void f2();   void fc(); } ​ // Adaptee 是一组不兼容 ITarget 接口定义的接口 public class Adaptee {   public void fa() { //... }   public void fb() { //... }   public void fc() { //... } } ​ // Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口       public class Adaptor extends Adaptee implements ITarget {   public void f1() {     super.fa();   }      public void f2() {     //...重新实现f2()...   }      // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点 }</code></pre><h3 class="md-end-block md-heading">11.5.对象适配器</h3><p>对象适配器：基于组合。</p><p>做法：让Adaptor 实现ITarget 接口，然后内部持有Adaptee实例，然后在ITarget接口规定的方法内转换Adaptee。</p><p>URL类图：</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92485d340cd440d5bfecd87140f4169c><p class=pgc-img-caption></p></div><pre><code> // 对象适配器：基于组合 ​ // ITarget 表示要转化成的接口定义 public interface ITarget {   void f1();   void f2();   void fc(); } ​ // Adaptee 是一组不兼容 ITarget 接口定义的接口 public class Adaptee {   public void fa() { //... }   public void fb() { //... }   public void fc() { //... } } ​ // Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口             public class Adaptor implements ITarget {   private Adaptee adaptee;      public Adaptor(Adaptee adaptee) {     this.adaptee = adaptee;   }      public void f1() {     adaptee.fa(); //委托给Adaptee   }      public void f2() {     //...重新实现f2()...   }      public void fc() {     adaptee.fc();   } }</code></pre><h3 class="md-end-block md-heading">11.5.接口适配器</h3><p>使用接口适配器让我们只实现我们所需要的接口方法</p><pre><code> public class CD { //这个类来自外部sdk，我们无权修改它的代码   //...   public static void staticFunction1() { //... }      public void uglyNamingFunction2() { //... } ​   public void tooManyParamsFunction3(int paramA, int paramB, ...) { //... }      public void lowPerformanceFunction4() { //... } } ​ // 使用适配器模式进行重构 public class ITarget {   void function1();   void function2();   void fucntion3(ParamsWrapperDefinition paramsWrapper);   void function4();   //... } // 注意：适配器类的命名不一定非得末尾带Adaptor public class CDAdaptor extends CD implements ITarget {   //...   public void function1() {      super.staticFunction1();   }      public void function2() {     super.uglyNamingFucntion2();   }      public void function3(ParamsWrapperDefinition paramsWrapper) {      super.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);   }      public void function4() {     //...reimplement it...   } }</code></pre><h3 class="md-end-block md-heading">11.6.实战</h3><p>重构第三方登录自由适配场景</p><p>首先创建统一登陆结果ResultMsg类：</p><pre><code> @Data public class ResultMsg { ​     private int code;     private String msg;     private Object data; ​     public ResultMsg(int code, String msg, Object data) {         this.code = code;         this.msg = msg;         this.data = data;     } }</code></pre><p>假设老系统的的登录逻辑PasswordService：</p><pre><code> public class PassportService { ​     /**      * 注册方法      * @param username      * @param password      * @return      */     public ResultMsg regist(String username,String password){         return  new ResultMsg(200,"注册成功",new Member());     } ​     /**      * 登录的方法      * @param username      * @param password      * @return      */     public ResultMsg login(String username,String password){         return null;     } }</code></pre><p>遵循开闭原则，老代码我们不修改。开启代码重构之路，创建Member类：</p><pre><code> @Data public class Member { ​     private String username;     private String password;     private String mid;     private String info; }</code></pre><p>运行稳定的代码不改动。创建ITarget角色IPassportForThird接口。</p><pre><code> public interface IPassportForThird { ​     ResultMsg loginForQQ(String openId); ​     ResultMsg loginForWechat(String openId); ​     ResultMsg loginForToken(String token); ​     ResultMsg loginForTelphone(String phone, String code); }</code></pre><p>创建适配器兼容Adaptor角色PassportForThirdAdapter类</p><pre><code> public class PassportForThirdAdapter implements IPassportForThird { ​     public ResultMsg loginForQQ(String openId) {         return processLogin(openId, LoginForQQAdapter.class);     } ​     public ResultMsg loginForWechat(String openId) {         return processLogin(openId, LoginForWechatAdapter.class);     } ​     public ResultMsg loginForToken(String token) {         return processLogin(token, LoginForTokenAdapter.class);     } ​     public ResultMsg loginForTelphone(String phone, String code) {         return processLogin(phone, LoginForTelAdapter.class);     } ​     private ResultMsg processLogin(String id,Class&lt;? extends ILoginAdapter&gt; clazz){         try {             ILoginAdapter adapter = clazz.newInstance();             if (adapter.support(adapter)){                 return adapter.login(id,adapter);             }         } catch (Exception e) {             e.printStackTrace();         }         return null;     } }</code></pre><p>根据不同登录方式，创建不同登录Adaptor。首先，创建LoginAdapter接口：</p><pre><code>public interface ILoginAdapter {    boolean support(Object object);    ResultMsg login(String id,Object adapter);}</code></pre><p>创建一个抽象类AbstraceAdapter继承PassportService原有功能，同时实现ILoginAdapter接口，然后分别实现不同的登录适配。</p><p>QQ登录</p><pre><code>public class LoginForQQAdapter extends AbstraceAdapter{    public boolean support(Object adapter) {        return adapter instanceof LoginForQQAdapter;    }    public ResultMsg login(String id, Object adapter) {        if(!support(adapter)){return null;}        //accesseToken        //time        return super.loginForRegist(id,null);    }}</code></pre><p>微信登录</p><pre><code>public class LoginForWechatAdapter extends AbstraceAdapter{    public boolean support(Object adapter) {        return adapter instanceof LoginForWechatAdapter;    }    public ResultMsg login(String id, Object adapter) {        return super.loginForRegist(id,null);    }}</code></pre><p>手机登录</p><pre><code>public class LoginForTelAdapter extends AbstraceAdapter{    public boolean support(Object adapter) {        return adapter instanceof LoginForTelAdapter;    }    public ResultMsg login(String id, Object adapter) {        return super.loginForRegist(id,null);    }}</code></pre><p>Token登录</p><pre><code>public class LoginForTokenAdapter extends AbstraceAdapter {    public boolean support(Object adapter) {        return adapter instanceof LoginForTokenAdapter;    }    public ResultMsg login(String id, Object adapter) {        return super.loginForRegist(id,null);    }}</code></pre><p>创建适配器PassportForThirdAdapter类，实现目标接口IPassportForThird兼容。</p><pre><code>public class PassportForThirdAdapter implements IPassportForThird {    public ResultMsg loginForQQ(String openId) {        return processLogin(openId, LoginForQQAdapter.class);    }    public ResultMsg loginForWechat(String openId) {        return processLogin(openId, LoginForWechatAdapter.class);    }    public ResultMsg loginForToken(String token) {        return processLogin(token, LoginForTokenAdapter.class);    }    public ResultMsg loginForTelphone(String phone, String code) {        return processLogin(phone, LoginForTelAdapter.class);    }    private ResultMsg processLogin(String id,Class&lt;? extends ILoginAdapter&gt; clazz){        try {            ILoginAdapter adapter = clazz.newInstance();            if (adapter.support(adapter)){                return adapter.login(id,adapter);            }        } catch (Exception e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>客户端测试代码</p><pre><code>public class Test {    public static void main(String[] args) {        IPassportForThird adapter = new PassportForThirdAdapter();        adapter.loginForQQ("sdfasdfasfasfas");    }}</code></pre><p>类图</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/159ef15e18c94b68badfa664f99f1035><p class=pgc-img-caption></p></div><p>我们为每一个适配器加上了support()方法，用来判断是否兼容，参数是Object，来源于接口。ILoginAdapter接口是为了代码规范。上面的代码综合了策略模式、简单工厂和适配器模式。</p><h3 class="md-end-block md-heading">11.7.源码</h3><p>Spring AOP中的AdvisorAdapter。有三个实现类MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter、ThrowsAdviceAdapter。</p><p>顶层接口AdvisorAdapter类</p><pre><code>public interface AdvisorAdapter {    boolean supportsAdvice(Advice var1);    MethodInterceptor getInterceptor(Advisor var1);}</code></pre><p>MethodBeforeAdviceAdapter实现。其余两个不贴了。</p><pre><code>class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable {    AfterReturningAdviceAdapter() {    }    public boolean supportsAdvice(Advice advice) {        return advice instanceof AfterReturningAdvice;    }    public MethodInterceptor getInterceptor(Advisor advisor) {        AfterReturningAdvice advice = (AfterReturningAdvice)advisor.getAdvice();        return new AfterReturningAdviceInterceptor(advice);    }}</code></pre><p>Spring 根据不同的AOP配置确定使用相应的Advice。</p><p>下面看SpringMVC的HandlerAdapter类，它也有多个子类。</p><p>类图：</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/860311ff5b5c4d4b8e5df465d66e4b6c><p class=pgc-img-caption></p></div><p><br></p><p>他的适配关键代码在DispatcherServlet的doDispatch()方法中，我们看源码：</p><pre><code>protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {    HttpServletRequest processedRequest = request;    HandlerExecutionChain mappedHandler = null;    boolean multipartRequestParsed = false;    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);    try {        try {            ModelAndView mv = null;            Object dispatchException = null;            try {                processedRequest = this.checkMultipart(request);                multipartRequestParsed = processedRequest != request;                mappedHandler = this.getHandler(processedRequest);                if (mappedHandler == null) {                    this.noHandlerFound(processedRequest, response);                    return;                }                HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());                String method = request.getMethod();                boolean isGet = "GET".equals(method);                if (isGet || "HEAD".equals(method)) {                    long lastModified = ha.getLastModified(request, mappedHandler.getHandler());                    if (this.logger.isDebugEnabled()) {                        this.logger.debug("Last-Modified value for [" + getRequestUri(request) + "] is: " + lastModified);                    }                    if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) {                        return;                    }                }                if (!mappedHandler.applyPreHandle(processedRequest, response)) {                    return;                }                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());                if (asyncManager.isConcurrentHandlingStarted()) {                    return;                }                this.applyDefaultViewName(processedRequest, mv);                mappedHandler.applyPostHandle(processedRequest, response, mv);            } catch (Exception var20) {                dispatchException = var20;            } catch (Throwable var21) {                dispatchException = new NestedServletException("Handler dispatch failed", var21);            }            this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);        } catch (Exception var22) {            this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);        } catch (Throwable var23) {            this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));        }    } finally {        if (asyncManager.isConcurrentHandlingStarted()) {            if (mappedHandler != null) {                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);            }        } else if (multipartRequestParsed) {            this.cleanupMultipart(processedRequest);        }    }}</code></pre><p>doDispatch方法调用了getHandlerAdaper方法</p><pre><code>@Nullableprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {    if (this.handlerMappings != null) {        Iterator var2 = this.handlerMappings.iterator();        while(var2.hasNext()) {            HandlerMapping hm = (HandlerMapping)var2.next();            if (this.logger.isTraceEnabled()) {                this.logger.trace("Testing handler map [" + hm + "] in DispatcherServlet with name '" + this.getServletName() + "'");            }            HandlerExecutionChain handler = hm.getHandler(request);            if (handler != null) {                return handler;            }        }    }    return null;}</code></pre><p>getHandlerAdapter方法循环调用supports方法判断是否兼容，循环迭代集合中的Adapter是在初始化时早就赋了值的。只有源码专题继续讲解。</p><h3 class="md-end-block md-heading">11.8.适配器与装饰器的对比</h3><p>两者都是包装模式</p><p><strong>适配器装饰器</strong>形式适配器没有层级关系，装饰器有层级关系。特殊的适配器定义适配器与被适配者没有必然联系，通常通过继承或代理进行包装装饰器与被装饰者实现同一个接口，目的是为了扩展后保留OOP关系关系has-a的关系is-a的关系功能注重兼容、转换注重复盖、扩展设计后置考虑前置考虑</p><h3 class="md-end-block md-heading">11.9.适配器模式的优缺点</h3><p>优点：</p><ul class=ul-list><li><strong>单一职责原则</strong>。你可以将接口或数据转换代码从程序主要业务逻辑中分离。</li><li><strong>开闭原则</strong>。只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。</li></ul><p>缺点：</p><ul class=ul-list><li><strong>代码整体复杂度增加</strong>， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。</li></ul><h3 class="md-end-block md-heading">11.10.总结</h3><p>一般来说，适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷。应用这种模式算是“无奈之举”，如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。那在实际的开发中，什么情况下才会出现接口不兼容呢？我总结下了下面这样 5 种场景：</p><ul class=ul-list><li>封装有缺陷的接口设计</li><li>统一多个类的接口设计</li><li>替换依赖的外部系统</li><li>兼容老版本接口</li><li>适配不同格式的数据</li></ul><h2 class="md-end-block md-heading">12.桥接模式</h2><p>先复习代理模式。它在不改变原始类（或者叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。代理模式在平时的开发经常被用到，常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。</p><p>今天学习桥接模式。桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相当于代理模式来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以，并不是我们学习的重点。</p><h3 class="md-end-block md-heading">12.1.原理解析</h3><p>桥接模式，也叫作桥梁模式，英文是 Bridge Design Pattern。这个模式可以说是 23 种设计模式中最难理解的模式之一了。我查阅了比较多的书籍和资料之后发现，对于这个模式有两种不同的理解方式。</p><p><strong>示意图</strong></p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bffad490149e4871a49e5dd95cece3e6><p class=pgc-img-caption></p></div><p>当然，这其中“最纯正”的理解方式，当属 GoF 的《设计模式》一书中对桥接模式的定义。毕竟，这 23 种经典的设计模式，最初就是由这本书总结出来的。在 GoF 的《设计模式》一书中，桥接模式是这么定义的：“Decouple an abstraction from its implementation so that the two can vary independently。”翻译成中文就是：“将抽象和实现解耦，让它们可以独立变化。”</p><p>关于桥接模式，很多书籍、资料中，还有另外一种理解方式：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”通过组合关系来替代继承关系，避免继承层次的指数级爆炸。这种理解方式非常类似于，我们之前讲过的“组合优于继承”设计原则，所以，这里我就不多解释了。我们重点看下 GoF 的理解方式。</p><p>桥接模式通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p><h3 class="md-end-block md-heading">12.2.角色</h3><p>类图：</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8971327982bf4c7d8cae7b806f38e3bc><p class=pgc-img-caption></p></div><p><br></p><p>桥接模式有四个角色：</p><p>抽象（Abstraction)：该类持有一个对实现角色的引用，抽象角色中的方法需要实现角色。该类一般为抽象类。</p><p>修正抽象角色（RefinedAbstraction）：Abstraction的具体实现，对Abstraction方法进行完善与扩展。</p><p>抽象实现角色（Implementor）：确定实现维度的基本操作，提供给Abstraction使用。该类一般为接口或抽象类。</p><p>具体实现角色（ConcreteImplementor）：Implementor的具体实现。</p><h3 class="md-end-block md-heading">12.3.通用写法</h3><p>创建抽象角色</p><pre><code>// 抽象public abstract class Abstraction {    protected IImplementor mImplementor;    public Abstraction(IImplementor implementor) {        this.mImplementor = implementor;    }    public void operation() {        this.mImplementor.operationImpl();    }}</code></pre><p>修正抽象角色</p><pre><code>// 修正抽象public class RefinedAbstraction extends Abstraction {    public RefinedAbstraction(IImplementor implementor) {        super(implementor);    }    @Override    public void operation() {        super.operation();        System.out.println("refined operation");    }}</code></pre><p>抽象实现角色</p><pre><code>// 抽象实现public interface IImplementor {    void operationImpl();}</code></pre><p>具体实现角色</p><pre><code>// 具体实现public class ConcreteImplementorA implements IImplementor {    public void operationImpl() {        System.out.println("I'm ConcreteImplementor A");    }}</code></pre><p>测试代码</p><pre><code>public class Test {    public static void main(String[] args) {        // 来一个实现化角色        IImplementor imp = new ConcreteImplementorA();        // 来一个抽象化角色，聚合实现        Abstraction abs = new RefinedAbstraction(imp);        // 执行操作        abs.operation();    }}</code></pre><p>运行结果</p><pre><code>I'm ConcreteImplementor Arefined operation</code></pre><h3 class="md-end-block md-heading">12.4.应用场景</h3><ul class=ul-list><li><strong>拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类），可以使用桥接模式。</strong></li><li><strong>如果你希望在几个独立维度上扩展一个类，可使用该模式。</strong></li><li><strong>如果你需要在运行时切换不同实现方法，可使用桥接模式。</strong></li></ul><h3 class="md-end-block md-heading">12.5.业务场景中的运用</h3><p>办公发送邮件、短信消息或者系统消息。紧急程度分为普通消息、紧急消息、特急消息。</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05e9710013ee4e25b7ee7e19e3aa9bd7><p class=pgc-img-caption></p></div><p>使用继承的话，情况复杂，也不利于扩展。通过桥接来解决。</p><p>创建一个IMessage接口担任桥接角色：</p><pre><code>public interface IMessage {    //发送消息的内容和接收人    void send(String message,String toUser);}</code></pre><p>创建邮件消息实现EmailMessage类：</p><pre><code>public class EmailMessage implements IMessage {    public void send(String message, String toUser) {        System.out.println("使用邮件消息发送" + message + "给" + toUser);    }}</code></pre><p>创建手机消息实现SmsMessage类：</p><pre><code>public class SmsMessage implements IMessage {    public void send(String message, String toUser) {        System.out.println("使用短信消息发送" + message + "给" + toUser);    }}</code></pre><p>创建桥接抽象角色AbastractMessage类</p><pre><code>public abstract class AbastractMessage {    private IMessage message;    public AbastractMessage(IMessage message) {        this.message = message;    }    void sendMessage(String message,String toUser){        this.message.send(message,toUser);    }}</code></pre><p>创建具体实现普通消息类NormalMessage：</p><pre><code>public class NomalMessage extends AbastractMessage {    public NomalMessage(IMessage message) {        super(message);    }}</code></pre><p>创建短信消息类SmsMessage：</p><pre><code>public class SmsMessage implements IMessage {    public void send(String message, String toUser) {        System.out.println("使用短信消息发送" + message + "给" + toUser);    }}</code></pre><p>创建紧急消息UrgencyMessage类：</p><pre><code>public class UrgencyMessage extends AbastractMessage {    public UrgencyMessage(IMessage message) {        super(message);    }    void sendMessage(String message, String toUser){        message = "【加急】" + message;        super.sendMessage(message,toUser);    }    public Object watch(String messageId){        return null;    }}</code></pre><p>代码测试</p><pre><code>public class Test {    public static void main(String[] args) {        IMessage message = new SmsMessage();        AbastractMessage abastractMessage = new NomalMessage(message);        abastractMessage.sendMessage("加班申请","王总");        message = new EmailMessage();        abastractMessage = new UrgencyMessage(message);        abastractMessage.sendMessage("加班申请","王总");    }}</code></pre><p>运行效果：</p><pre><code>使用短信消息发送加班申请给王总使用邮件消息发送【加急】加班申请给王总</code></pre><h3 class="md-end-block md-heading">12.6.源码</h3><p>JDBC API，其中Driver类就是桥接对象。使用Class.forName方法动态加载各个数据库厂商的Driver类。</p><p>以MySQL的实现为例：</p><pre><code>//1.加载驱动Class.forName("com.mysql.jdbc.Driver");  //反射机制加载驱动类// 2.获取连接Connection//主机:端口号/数据库名Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test", "root", "root");// 3.得到执行sql语句的对象StatementStatement stmt = conn.createStatement();// 4.执行sql语句，并返回结果</code></pre><p>我们看一下Driver接口定义：</p><pre><code>public interface Driver {    Connection connect(String url, java.util.Properties info)        throws SQLException;    boolean acceptsURL(String url) throws SQLException;    DriverPropertyInfo[] getPropertyInfo(String url, java.util.Properties info)                         throws SQLException;    int getMajorVersion();    int getMinorVersion();    boolean jdbcCompliant();    public Logger getParentLogger() throws SQLFeatureNotSupportedException;}</code></pre><p>Driver在JDBC中没有做任何实现，具体的功能由各个厂商完成，以MySQL的实现为例。</p><pre><code>public class Driver extends NonRegisteringDriver implements java.sql.Driver {    public Driver() throws SQLException {    }    static {        try {            DriverManager.registerDriver(new Driver());        } catch (SQLException var1) {            throw new RuntimeException("Can't register driver!");        }    }}</code></pre><p>当我们执行Class.forName("com.mysql.jdbc.Driver")方法的时候，就会执行com.mysql.jdbc.Drvier这个类的静态块中的代码。静态块中的代码只是调用了一下DriverManager的referisterDriver()方法，然后将Driver对象注册到DriverMananger中。我们继续跟进到DriverManager这个类中，来看相关代码：</p><pre><code>public class DriverManager {     // List of registered JDBC drivers    private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = new CopyOnWriteArrayList&lt;&gt;();        /* Prevent the DriverManager class from being instantiated. */    private DriverManager(){}        /**     * Load the initial JDBC drivers by checking the System property     * jdbc.properties and then use the {@code ServiceLoader} mechanism     */    static {        loadInitialDrivers();        println("JDBC DriverManager initialized");    }        public static synchronized void registerDriver(java.sql.Driver driver)        throws SQLException {        registerDriver(driver, null);    }    public static synchronized void registerDriver(java.sql.Driver driver,            DriverAction da)        throws SQLException {        /* Register the driver if it has not already been added to our list */        if(driver != null) {            registeredDrivers.addIfAbsent(new DriverInfo(driver, da));        } else {            // This is for compatibility with the original DriverManager            throw new NullPointerException();        }        println("registerDriver: " + driver);    }}</code></pre><p>在注册之前，将传过来的Driver对象，封装成了一个DriverInfo对象。接下来继续执行客户端代码的第二部，调用DriverManager的getConnection方法获取链接对象，跟进源码：</p><pre><code>     @CallerSensitive     public static Connection getConnection(String url,         java.util.Properties info) throws SQLException { ​         return (getConnection(url, info, Reflection.getCallerClass()));     } ​     @CallerSensitive     public static Connection getConnection(String url,         String user, String password) throws SQLException {         java.util.Properties info = new java.util.Properties(); ​         if (user != null) {             info.put("user", user);         }         if (password != null) {             info.put("password", password);         } ​         return (getConnection(url, info, Reflection.getCallerClass()));     } ​     @CallerSensitive     public static Connection getConnection(String url)         throws SQLException { ​         java.util.Properties info = new java.util.Properties();         return (getConnection(url, info, Reflection.getCallerClass()));     } ​     //  Worker method called by the public getConnection() methods.     private static Connection getConnection(         String url, java.util.Properties info, Class&lt;?&gt; caller) throws SQLException {         /*          * When callerCl is null, we should check the application's          * (which is invoking this class indirectly)          * classloader, so that the JDBC driver class outside rt.jar          * can be loaded from here.          */         ClassLoader callerCL = caller != null ? caller.getClassLoader() : null;         synchronized(DriverManager.class) {             // synchronize loading of the correct classloader.             if (callerCL == null) {                 callerCL = Thread.currentThread().getContextClassLoader();             }         } ​         if(url == null) {             throw new SQLException("The url cannot be null", "08001");         } ​         println("DriverManager.getConnection(\"" + url + "\")"); ​         // Walk through the loaded registeredDrivers attempting to make a connection.         // Remember the first exception that gets raised so we can reraise it.         SQLException reason = null; ​         for(DriverInfo aDriver : registeredDrivers) {             // If the caller does not have permission to load the driver then             // skip it.             if(isDriverAllowed(aDriver.driver, callerCL)) {                 try {                     println("    trying " + aDriver.driver.getClass().getName());                     Connection con = aDriver.driver.connect(url, info);                     if (con != null) {                         // Success!                         println("getConnection returning " + aDriver.driver.getClass().getName());                         return (con);                     }                 } catch (SQLException ex) {                     if (reason == null) {                         reason = ex;                     }                 } ​             } else {                 println("    skipping: " + aDriver.getClass().getName());             } ​         } ​         // if we got here nobody could connect.         if (reason != null)    {             println("getConnection failed: " + reason);             throw reason;         } ​         println("getConnection: no suitable driver found for "+ url);         throw new SQLException("No suitable driver found for "+ url, "08001");     }</code></pre><p>在getConnection()中又会调用各个厂商实现的Driver的connect()方法获得链接对象。这样的话，就巧妙地避开了使用继承，为不同数据库提供相同接口。JDBC API中DriverManager就是桥，如下图所示：</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cc52f173e32443ba57f04ace0ec36c9><p class=pgc-img-caption></p></div><h3 class="md-end-block md-heading">12.7.桥接模式优缺点</h3><p>优点</p><ul class=ul-list><li>你可以创建与平台无关的类和程序。</li><li>客户端代码仅与高层抽象部分进行互动， 不会接触到平台的详细信息。</li><li>开闭原则。 你可以新增抽象部分和实现部分， 且它们之间不会相互影响。</li><li>单一职责原则。 抽象部分专注于处理高层逻辑， 实现部分处理平台细节。</li></ul><p>缺点</p><ul class=ul-list><li>对高内聚的类使用该模式可能会让代码更加复杂。</li></ul><h3 class="md-end-block md-heading">12.8.代理、桥接、装饰器、适配器 4 种设计模式的区别</h3><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类。</p><p>###</p><p><strong>代理模式：</strong>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。</p><p><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p><p><strong>装饰器模式：</strong>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。</p><p><strong>适配器模式：</strong>适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。</p><h3 class="md-end-block md-heading">12.9.作业</h3><p>1、完善第三方登录接口，完成不修改接口也能实现自动适配的功能。</p><p>通过在接口ILoginForThird的方法参数添加泛型约束。</p><pre><code> /**  * 第三方登录的接口，方法限制适配器的Class  */ public interface ILoginForThird {     ResultMsg loginForThird(String id, Class&lt;? extends ILoginAdapter&gt; clazz); } ​ /**  * 第三方登录适配器实现，通过适配器对象判断是否兼容  */ public class LoginForThirdAdapter implements ILoginForThird {     @Override     public ResultMsg loginForThird(String id, Class&lt;? extends ILoginAdapter&gt; clazz) {         try {             ILoginAdapter adapter = clazz.newInstance();             if (adapter.support(adapter)) {                 return adapter.login(id, adapter);             }         } catch (Exception e) {             e.printStackTrace();         }         return null;     } } ​ /**  * 登录适配器接口  */ public interface ILoginAdapter {     Boolean support(Object object);     ResultMsg login(String id, Object adapter); } ​ /**  * 微博登录适配器  */ public class LoginForWeiboAdapter extends AbstractAdapter {     @Override     public Boolean support(Object adapter) {         return adapter instanceof LoginForWeiboAdapter;     } ​     @Override     public ResultMsg login(String id, Object adapter) {         if (! support(adapter)) {             return null;         }         return super.loginForRegist(id, null);     } } ​ /**  * 抽象适配器  */ public abstract class AbstractAdapter extends PassportService implements ILoginAdapter {     protected ResultMsg loginForRegist(String username, String password) {         if(null == password){             password = "THIRD_EMPTY";         }         super.regist(username,password);         return super.login(username,password);     } } ​ // 原有的注册与登录方法 public class PassportService {     // 注册方法     public ResultMsg regist(String username, String password) {         return new ResultMsg(200, "注册成功", new Member());     } ​     // 登录的方法     public ResultMsg login(String username, String password) {         return new ResultMsg(200, "登录成功", new Member());     } }</code></pre><p>测试代码</p><pre><code> public class Test {     public static void main(String[] args) {         // 新增微博登录         ILoginForThird loginForThird = new LoginForThirdAdapter();         ResultMsg resultMsg = loginForThird.loginForThird("微博账号", LoginForWeiboAdapter.class);         System.out.println(resultMsg.toString());     } }</code></pre><p>运行效果</p><pre><code> ResultMsg(code=200, msg=登录成功, data=Member(username=null, password=null, mid=null, info=null))</code></pre><p>类图</p><div class=pgc-img><img alt=八、适配器模式与桥接模式详解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/68c636735b48427882086eeba8122392><p class=pgc-img-caption></p></div><p>2、说说你对桥接模式的理解。</p><p><strong>桥接模式</strong>是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。</p><p><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。</p><p>在 GoF 的《设计模式》一书中，桥接模式被定义为：“将抽象和实现解耦，让它们可以独立变化。”</p><p>定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。</p><p>而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系，组装在一起。</p><p>简单的理解：“一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行扩展。”</p><p>遵循“组合优于继承”设计原则，通过组合关系来替代继承关系，避免继承层次的指数级爆炸。</p><p><br></p><hr><p>参考资料</p><ol start=0><li>Alexan­der Shvets《Dive into Design Patterns》</li><li>极客时间《设计模式之美》</li><li>咕泡学院《适配器模式与桥接模式详解》</li></ol><p><br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'模式','桥接','详解'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>