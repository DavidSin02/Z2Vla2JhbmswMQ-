<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「必需知道」实用，完整的HTTP cookie指南 | 极客快訊</title><meta property="og:title" content="「必需知道」实用，完整的HTTP cookie指南 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8a4624de47524aa69601b3047226a318"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7005116.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f7005116.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f7005116.html><meta property="article:published_time" content="2020-11-14T21:00:34+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:34+08:00"><meta name=Keywords content><meta name=description content="「必需知道」实用，完整的HTTP cookie指南"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f7005116.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「必需知道」实用，完整的HTTP cookie指南</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>Web 开发中的 cookie 是什么?</strong></h1><p><strong>cookie 是后端可以存储在用户浏览器中的小块数据。</strong> Cookie 最常见用例包括用户跟踪，个性化以及身份验证。</p><p><strong>Cookies</strong> 具有很多隐私问题，多年来一直受到严格的监管。</p><p>在本文中，主要侧重于技术方面：学习如何在前端和后端创建，使用 HTTP cookie。</p><h1 class=pgc-h-arrow-right><strong>后端配置</strong></h1><p>后端示例是<strong>Flask</strong>编写的。如果你想跟着学习，可以创建一个新的Python虚拟环境，移动到其中并安装Flask</p><pre><code>mkdir cookies &amp;&amp; cd $_python3 -m venv venvsource venv/bin/activatepip install Flask</code></pre><p>在项目文件夹中创建一个名为flask app.py的新文件，并使用本文的示例在本地进行实验。</p><h1 class=pgc-h-arrow-right><strong>谁创建 cookies ?</strong></h1><p>首先，cookies 从何而来？谁创建 cookies ？</p><p>虽然可以使用document.cookie在浏览器中创建 cookie，但大多数情况下，后端的责任是在将响应客户端请求之前在请求中设置 cookie。</p><p>后端是指可以通过以下方式创建 Cookie：</p><ul><li>后端实际应用程序的代码(Python、JavaScript、PHP、Java)</li><li>响应请求的Web服务器（Nginx，Apache）</li></ul><p>后端可以在 HTTP 请求求中 Set-Cookie 属性来设置 cookie，它是由键/值对以及可选属性组成的相应字符串：</p><pre><code>Set-Cookie: myfirstcookie=somecookievalue</code></pre><p>什么时候需要创建 cookie？这取决于需求。</p><p>cookie 是简单的字符串。在项目文件夹中创建一个名为flask_app.py的Python文件，并输入以下内容：</p><pre><code>from flask import Flask, make_responseapp = Flask(__name__)@app.route("/index/", methods=["GET"])def index():    response = make_response("Here, take some cookie!")    response.headers["Set-Cookie"] = "myfirstcookie=somecookievalue"    return response</code></pre><p>然后运行应用程序:</p><pre><code>FLASK_ENV=development FLASK_APP=flask_app.py flask run</code></pre><p>当该应用程序运行时，用户访问http://127.0.0.1:5000/index/，后端将设置一个具有键/值对的名为Set-Cookie的响应标头。</p><p>（127.0.0.1:5000是开发中的 Flask 应用程序的默认侦听地址/端口）。</p><p>Set-Cookie标头是了解如何创建cookie的关键：</p><pre><code>response.headers["Set-Cookie"] = "myfirstcookie=somecookievalue"</code></pre><p>大多数框架都有自己设置 cookie 的方法，比如Flask的set_cookie()。</p><h1 class=pgc-h-arrow-right><strong>如何查看 cookies ？</strong></h1><p>访问http://127.0.0.1:5000/index/后，后端将在浏览器中设置cookie。要查看此cookie，可以从浏览器的控制台调用document.cookie：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a4624de47524aa69601b3047226a318><p class=pgc-img-caption></p></div><p>或者可以在开发人员工具中选中Storage选项卡。单击cookie,会看到 cookie 具体的内容：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/61a36d7e7fae49ecabbb7c65b5c868bb><p class=pgc-img-caption></p></div><p>在命令行上，还可以使用curl查看后端设置了哪些 cookie</p><pre><code>curl -I http://127.0.0.1:5000/index/</code></pre><p>可以将 Cookie 保存到文件中以供以后使用：</p><pre><code>curl -I http://127.0.0.1:5000/index/ --cookie-jar mycookies</code></pre><p>在 stdout 上显示 cookie:</p><pre><code>curl -I http://127.0.0.1:5000/index/ --cookie-jar -</code></pre><p>请注意，没有HttpOnly属性的cookie，在浏览器中可以使用document.cookie上访问，如果设置了 HttpOnly 属性，document.cookie就读取不到。</p><pre><code>Set-Cookie: myfirstcookie=somecookievalue; HttpOnly</code></pre><p>现在，该cookie 仍将出现在 Storage 选项卡中，但是 document.cookie返回的是一个空字符串。</p><p>从现在开始，为方便起见，使用Flask的 response.set_cookie() 在后端上创建 cookie。</p><h1 class=pgc-h-arrow-right><strong>我有一个 cookie，现在怎么办？</strong></h1><p>你的浏览器得到一个 cookie。现在怎么办呢?一旦有了 cookie，浏览器就可以将cookie发送回后端。</p><p>这有许多用途发如：用户跟踪、个性化，以及最重要的身份验证。</p><p>例如，一旦你登录网站，后端就会给你一个cookie：</p><pre><code>Set-Cookie: userid=sup3r4n0m-us3r-1d3nt1f13r</code></pre><p>为了在每个后续请求中正确识别 我们的身份，后端会检查来自请求中浏览器的 cookie</p><p>要发送Cookie，浏览器会在请求中附加一个Cookie标头：</p><pre><code>Cookie: userid=sup3r4n0m-us3r-1d3nt1f13r</code></pre><h1 class=pgc-h-arrow-right><strong>cookie 可以设置过期时间: Max-Age 和 expires</strong></h1><p>默认情况下，cookie 在用户关闭会话时即关闭浏览器时过期。要持久化cookie，我们可以通过expires或Max-Age属性</p><pre><code>Set-Cookie: myfirstcookie=somecookievalue; expires=Tue, 09 Jun 2020 15:46:52 GMT; Max-Age=1209600</code></pre><p>注意：<strong>Max-Age</strong>优先于<strong>expires</strong>。</p><h1 class=pgc-h-arrow-right><strong>cookie的作用域是网站路径: path 属性</strong></h1><p>考虑该后端，该后端在访问http://127.0.0.1:5000/时为其前端设置了一个新的 cookie。相反，在其他两条路径上，我们打印请求的cookie：</p><pre><code>from flask import Flask, make_response, requestapp = Flask(__name__)@app.route("/", methods=["GET"])def index():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d", path="/about/")    return response@app.route("/about/", methods=["GET"])def about():    print(request.cookies)    return "Hello world!"@app.route("/contact/", methods=["GET"])def contact():    print(request.cookies)    return "Hello world!"</code></pre><p>运行该应用程序:</p><pre><code>FLASK_ENV=development FLASK_APP=flask_app.py flask run</code></pre><p>在另一个终端中，如果我们与根路由建立连接，则可以在Set-Cookie中看到cookie：</p><pre><code>curl -I http://127.0.0.1:5000/ --cookie-jar cookiesHTTP/1.0 200 OKContent-Type: text/html; charset=utf-8Content-Length: 23Set-Cookie: id=3db4adj3d; Path=/about/Server: Werkzeug/1.0.1 Python/3.8.3Date: Wed, 27 May 2020 09:21:37 GMT</code></pre><p>请注意，此时 cookie 具有Path属性：</p><pre><code>Set-Cookie: id=3db4adj3d; Path=/about/</code></pre><p>/about/ 路由并保存 cookit</p><pre><code>curl -I http://127.0.0.1:5000/about/ --cookie cookies</code></pre><p>在 Flask 应用程序的终端中运行如下命令，可以看到：</p><pre><code>ImmutableMultiDict([('id', '3db4adj3d')])127.0.0.1 - - [27/May/2020 11:27:55] "HEAD /about/ HTTP/1.1" 200 -</code></pre><p>正如预期的那样，cookie 返回到后端。现在尝试访问 /contact/ 路由：</p><pre><code>url -I http://127.0.0.1:5000/contact/ --cookie cookies</code></pre><p>在 Flask 应用程序的终端中运行如下命令，可以看到：</p><pre><code>ImmutableMultiDict([])127.0.0.1 - - [27/May/2020 11:29:00] "HEAD /contact/ HTTP/1.1" 200 -</code></pre><p>这说明啥?cookie 的作用域是Path 。具有给定路径属性的cookie不能被发送到另一个不相关的路径，即使这两个路径位于同一域中。</p><p><strong>这是cookie权限的第一层。</strong></p><p>在cookie创建过程中省略Path时，浏览器默认为/。</p><h1 class=pgc-h-arrow-right><strong>cookie 的作用域是域名: domain 属性</strong></h1><p>cookie 的 Domain 属性的值控制浏览器是否应该接受cookie以及cookie返回的位置。</p><p>让我们看一些例子。</p><h1 class=pgc-h-arrow-right><strong>主机不匹配（错误的主机）</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-wrong-domain-cookie/设置的cookie：</p><pre><code>Set-Cookie: coookiename=wr0ng-d0m41n-c00k13; Domain=api.valentinog.com</code></pre><p>这里的 cookie 来自<strong>serene-bastion-01422.herokuapp.com</strong>，但是Domain属性具有<strong>api.valentinog.com</strong>。</p><p>浏览器没有其他选择来拒绝这个 cookie。比如 Chrome 会给出一个警告(Firefox没有)</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7c81fe6e3a2446dbb6b576bfad0f481e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>主机不匹配（子域名）</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-wrong-subdomain-cookie/设置的cookie：</p><pre><code>Set-Cookie: coookiename=wr0ng-subd0m41n-c00k13; Domain=secure-brushlands-44802.herokuapp.com</code></pre><p>这里的 Cookie 来自serene-bastion-01422.herokuapp.com，但**“Domain”**属性是secure-brushlands-44802.herokuapp.com。</p><p>它们在相同的域上，但是子域名不同。同样，浏览器也拒绝此cookie：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a96594e351b44a6be4a707ee00506bf><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>主机匹配（整个域）</strong></h1><p>查看 https://www.valentinog.com/get-domain-cookie.html设置的cookie：</p><pre><code>set-cookie: cookiename=d0m41n-c00k13; Domain=valentinog.com</code></pre><p>此cookie是使用 Nginx add_header在Web服务器上设置的：</p><pre><code>add_header Set-Cookie "cookiename=d0m41n-c00k13; Domain=valentinog.com";</code></pre><p>这里使用 Nginx 中设置cookie的多种方法。Cookie 是由 Web 服务器或应用程序的代码设置的，对于浏览器来说无关紧要。</p><p>重要的是 cookie 来自哪个域。</p><p>在此浏览器将愉快地接受cookie，因为Domain中的主机包括cookie所来自的主机。</p><p>换句话说，valentinog.com包括子域名www.valentinog.com。</p><p>同时，对valentinog.com的新请求,cookie 都会携带着，以及任何对valentinog.com子域名的请求。</p><p>这是一个附加了Cookie的 www 子域请求：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9dc2184e57334a21b7116989b14435cb><p class=pgc-img-caption></p></div><p>下面是对另一个自动附加cookie的子域的请求</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/220b42278e584c89b7a7d7081dcd9cb5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>Cookies 和公共后缀列表</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-domain-cookie/:设置的 cookie：</p><pre><code>Set-Cookie: coookiename=d0m41n-c00k13; Domain=herokuapp.com</code></pre><p>这里的 cookie 来自serene-bas-01422.herokuapp.com，Domain 属性是herokuapp.com。浏览器在这里应该做什么</p><p>你可能认为serene-base-01422.herokuapp.com包含在herokuapp.com域中，因此浏览器应该接受cookie。</p><p>相反，它拒绝 cookie，因为它来自<strong>公共后缀列表</strong>中包含的域。</p><p>Public Suffix List（公共后缀列表）。此列表列举了顶级域名和开放注册的域名。浏览器禁止此列表上的域名被子域名写入Cookie。</p><h1 class=pgc-h-arrow-right><strong>主机匹配（子域）</strong></h1><p>查看 https://serene-bastion-01422.herokuapp.com/get-subdomain-cookie/:设置的 cookie：</p><pre><code>Set-Cookie: coookiename=subd0m41n-c00k13</code></pre><p>当域在cookie创建期间被省略时，浏览器会默认在地址栏中显示原始主机，在这种情况下，我的代码会这样做:</p><pre><code>response.set_cookie(key="coookiename", value="subd0m41n-c00k13")</code></pre><p>当 Cookie 进入浏览器的 Cookie 存储区时，我们看到已应用Domain ：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6e523e434ec47de96940fcf5fa3d1ea><p class=pgc-img-caption></p></div><p>现在，我们有来自serene-bastion-01422.herokuapp.com 的 cookie, 那 cookie 现在应该送到哪里?</p><p>如果你访问https://serene-bastion-01422.herokuapp.com/，则 cookie 随请求一起出现：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14758019996745419eb718a261cde202><p class=pgc-img-caption></p></div><p>但是，如果访问herokuapp.com，则 cookie 不会随请求一起出现：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f38726407a5d46afa1acd29b16c93669><p class=pgc-img-caption></p></div><p>概括地说，浏览器使用以下启发式规则来决定如何处理cookies(这里的发送者主机指的是你访问的实际网址):</p><ul><li>如果“Domain”中的域或子域与访问的主机不匹配，则完全拒绝 Cookie</li><li>如果 Domain 的值包含在公共后缀列表中，则拒绝 cookie</li><li>如果Domain 中的域或子域与访问在主机匹配，则接受 Cookie</li></ul><p>一旦浏览器接受了cookie，并且即将发出请求，它就会说：</p><ul><li>如果请求主机与我在Domain中看到的值完全匹配，则会回传 cookie</li><li>如果请求主机是与我在“Domain”中看到的值完全匹配的子域，则将回传 cookie</li><li>如果请求主机是sub.example.dev之类的子域，包含在example.dev之类的 Domain 中，则将回传 cookie</li><li>如果请求主机是例如example.dev之类的主域，而 Domain 是sub.example.dev之类，则不会回传cookie。</li></ul><p><strong>Domain 和 Path 属性一直是 cookie 权限的第二层。</strong></p><h1 class=pgc-h-arrow-right><strong>Cookies可以通过AJAX请求传递</strong></h1><p>Cookies 可以通过AJAX请求传播。<strong>AJAX 请求</strong>是使用 JS （XMLHttpRequest或Fetch）进行的异步HTTP请求，用于获取数据并将其发送回后端。</p><p>考虑 Flask的另一个示例，其中有一个模板，该模板又会加载 JS 文件：</p><pre><code>from flask import Flask, make_response, render_templateapp = Flask(__name__)@app.route("/", methods=["GET"])def index():    return render_template("index.html")@app.route("/get-cookie/", methods=["GET"])def get_cookie():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d")    return response</code></pre><p>以下是 templates/index.html 模板：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;FETCH&lt;/button&gt;&lt;/body&gt;&lt;script src="{{ url_for('static', filename='index.js') }}"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><p>下面是 static/index.js 的内容：</p><pre><code>const button = document.getElementsByTagName("button")[0];button.addEventListener("click", function() {  getACookie();});function getACookie() {  fetch("/get-cookie/")    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.text();    })    .then(text =&gt; console.log(text));}</code></pre><p>当访问http://127.0.0.1:5000/时，我们会看到一个按钮。通过单击按钮，我们向/get-cookie/发出获取请求并获取Cookie。正如预期的那样，cookie 落在浏览器的 Cookie storage中。</p><p>对 Flask 应用程序进行一些更改，多加一个路由：</p><pre><code>from flask import Flask, make_response, request, render_template, jsonifyapp = Flask(__name__)@app.route("/", methods=["GET"])def index():    return render_template("index.html")@app.route("/get-cookie/", methods=["GET"])def get_cookie():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d")    return response@app.route("/api/cities/", methods=["GET"])def cities():    if request.cookies["id"] == "3db4adj3d":        cities = [{"name": "Rome", "id": 1}, {"name": "Siena", "id": 2}]        return jsonify(cities)    return jsonify(msg="Ops!")</code></pre><p>另外，调整一下 JS 代码，用于下请求刚新增的路由：</p><pre><code>const button = document.getElementsByTagName("button")[0];button.addEventListener("click", function() {  getACookie().then(() =&gt; getData());});function getACookie() {  return fetch("/get-cookie/").then(response =&gt; {    // make sure to check response.ok in the real world!    return Promise.resolve("All good, fetch the data");  });}function getData() {  fetch("/api/cities/")    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.json();    })    .then(json =&gt; console.log(json));</code></pre><p>当访问http://127.0.0.1:5000/时，我们会看到一个按钮。通过单击按钮，我们向/get-cookie/发出获取请求以获取Cookie。Cookie出现后，我们就会对/api/cities/再次发出Fetch请求。</p><p>在浏览器的控制台中，可以看到请求回来 的数据。另外，在开发者工具的Network选项卡中，可以看到一个名为Cookie的头，这是通过AJAX请求传给后端。</p><p>只要前端与后端在同一上下文中，在前端和后端之间来回交换cookie就可以正常工作：我们说它们来自同源。</p><p>这是因为默认情况下，Fetch 仅在请求到达触发请求的来源时才发送凭据，即 Cookie。</p><h1 class=pgc-h-arrow-right><strong>cookie 不能总是通过AJAX请求传递</strong></h1><p>考虑另一种情况，在后端独立运行，可以这样启动应用程序:</p><pre><code>FLASK_ENV=development FLASK_APP=flask_app.py flask run</code></pre><p>现在，在 Flask 应用程序之外的其他文件夹中，创建index.html：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;FETCH&lt;/button&gt;&lt;/body&gt;&lt;script src="index.js"&gt;&lt;/script&gt;&lt;/html&gt;</code></pre><p>使用以下代码在同一文件夹中创建一个名为index.js的 JS 文件：</p><pre><code>button.addEventListener("click", function() {  getACookie().then(() =&gt; getData());});function getACookie() {  return fetch("http://localhost:5000/get-cookie/").then(response =&gt; {    // make sure to check response.ok in the real world!    return Promise.resolve("All good, fetch the data");  });}function getData() {  fetch("http://localhost:5000/api/cities/")    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.json();    })    .then(json =&gt; console.log(json));}</code></pre><p>在同一文件夹中，从终端运行：</p><pre><code>npx serve</code></pre><p>此命令为您提供了要连接的本地地址/端口，例如http://localhost:42091/。访问页面并尝试在浏览器控制台打开的情况下单击按钮。在控制台中，可以看到：</p><pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:5000/get-cookie/. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing)</code></pre><p>因为 http://localhost:5000/ 与http://localhost:42091/.不同。它们是不同的域，因此会 CORS 的限制。</p><h1 class=pgc-h-arrow-right><strong>处理 CORS</strong></h1><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制。</p><p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p><p>默认情况下，除非服务器设置了Access-Control-Allow-Origin的特定HTTP标头，否则浏览器将阻止AJAX对非相同来源的远程资源的请求。</p><p>要解决此第一个错误，我们需要为Flask配置CORS：</p><pre><code>pip install flask-cors</code></pre><p>然后将 CORS 应用于 Flask：</p><pre><code>from flask import Flask, make_response, request, render_template, jsonifyfrom flask_cors import CORSapp = Flask(__name__)CORS(app=app)@app.route("/", methods=["GET"])def index():    return render_template("index.html")@app.route("/get-cookie/", methods=["GET"])def get_cookie():    response = make_response("Here, take some cookie!")    response.set_cookie(key="id", value="3db4adj3d")    return response@app.route("/api/cities/", methods=["GET"])def cities():    if request.cookies["id"] == "3db4adj3d":        cities = [{"name": "Rome", "id": 1}, {"name": "Siena", "id": 2}]        return jsonify(cities)    return jsonify(msg="Ops!")</code></pre><p>现在尝试在浏览器控制台打开的情况下再次单击按钮。在控制台中你应该看到</p><pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:5000/api/cities/. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing)</code></pre><p>尽管我们犯了同样的错误，但这次的罪魁祸首是第二个路由。</p><p>你可以通过查看 “Network” 标签中的请求来确认,没有发送此类Cookie：</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b32b26734f34c2490259a7785b8d6c4><p class=pgc-img-caption></p></div><p>为了在不同来源的Fetch请求中包含cookie，我们必须提credentials 标志（默认情况下，它是相同来源）。</p><p>如果没有这个标志，Fetch 就会忽略 cookie，可以这样修复：</p><pre><code>const button = document.getElementsByTagName("button")[0];button.addEventListener("click", function() {  getACookie().then(() =&gt; getData());});function getACookie() {  return fetch("http://localhost:5000/get-cookie/", {    credentials: "include"  }).then(response =&gt; {    // make sure to check response.ok in the real world!    return Promise.resolve("All good, fetch the data");  });}function getData() {  fetch("http://localhost:5000/api/cities/", {    credentials: "include"  })    .then(response =&gt; {      // make sure to check response.ok in the real world!      return response.json();    })    .then(json =&gt; console.log(json));}</code></pre><p>credentials: "include" 必须在第一个 Fetch 请求中出现，才能将Cookie保存在浏览器的Cookie storage 中：</p><pre><code>fetch("http://localhost:5000/get-cookie/", {    credentials: "include"  })</code></pre><p>它还必须在第二个请求时出现，以允许将cookie传输回后端</p><pre><code>  fetch("http://localhost:5000/api/cities/", {    credentials: "include"  })</code></pre><p>再试一次，我们还需要在后端修复另一个错误：</p><pre><code>Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at http://localhost:5000/get-cookie/. (Reason: expected ‘true’ in CORS header ‘Access-Control-Allow-Credentials’).</code></pre><p>为了允许在CORS请求中传输cookie，后端还需要设置 Access-Control-Allow-Credentials标头。</p><pre><code>CORS(app=app, supports_credentials=True)</code></pre><p>要点：为了使Cookie在不同来源之间通过AJAX请求传递，可以这样做：</p><ul><li>credentials: "include" 用于前端的 fetch 请求中</li><li>Access-Control-Allow-Credentials 和 Access-Control-Allow-Origin 用于后端</li></ul><p>cookie可以通过AJAX请求传递，但是它们必须遵守我们前面描述的域规则。</p><h1 class=pgc-h-arrow-right><strong>Cookie 的 Secure 属性</strong></h1><p>Secure 属性是说如果一个 cookie 被设置了Secure=true，那么这个cookie只能用https协议发送给服务器，用 http 协议是不发送的。换句话说，cookie 是在https的情况下创建的，而且他的Secure=true，那么之后你一直用https访问其他的页面（比如登录之后点击其他子页面），cookie会被发送到服务器，你无需重新登录就可以跳转到其他页面。但是如果这时你把url改成http协议访问其他页面，你就需要重新登录了，因为这个cookie不能在http协议中发送。</p><p>可以这样设置 Secure 属性</p><pre><code>response.set_cookie(key="id", value="3db4adj3d", secure=True)</code></pre><p>如果要在真实环境中尝试，请可以运行以下命令，并注意curl在此处是不通过HTTP保存cookie：</p><pre><code>curl -I http://serene-bastion-01422.herokuapp.com/get-secure-cookie/ --cookie-jar -</code></pre><p>相反，通过HTTPS，cookie 出现在cookie jar中：</p><pre><code>curl -I https://serene-bastion-01422.herokuapp.com/get-secure-cookie/ --cookie-jar -</code></pre><p>cookie jar 文件：</p><pre><code>serene-bastion-01422.herokuapp.com      FALSE   /       TRUE    0</code></pre><p>不要被Secure欺骗：浏览器通过HTTPS接受cookie，但是一旦cookie进入浏览器，就没有任何保护。</p><p>因为带有 Secure 的 Cookie 一般也不用于传输敏感数据.</p><h1 class=pgc-h-arrow-right><strong>Cookie 的 HttpOnly 属性</strong></h1><p>如果cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击，窃取cookie内容，这样就增加了cookie的安全性，即便是这样，也不要将重要信息存入cookie。</p><blockquote><p>XSS 全称Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有XSS漏洞的网站中输入(传入)恶意的HTML代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如，盗取用户Cookie、破坏页面结构、重定向到其它网站等。</p></blockquote><p>如果有设置 HttpOnly 看起来是这样的：</p><pre><code>Set-Cookie: "id=3db4adj3d; HttpOnly"</code></pre><p>在 Flask 中</p><pre><code>response.set_cookie(key="id", value="3db4adj3d", httponly=True)</code></pre><p>这样，cookie 设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息。如果在控制台中进行检查，则document.cookie将返回一个空字符串。</p><p>何时使用HttpOnly？cookie 应该始终是HttpOnly的，除非有特定的要求将它们暴露给运行时 JS。</p><h1 class=pgc-h-arrow-right><strong>可怕的 SameSite 属性</strong></h1><h1 class=pgc-h-arrow-right><strong>first-party cookie 和 third-party cookie</strong></h1><p>查看https://serene-bastion-01422.herokuapp.com/get-cookie/ 中所携带的 Cookie</p><pre><code>Set-Cookie: simplecookiename=c00l-c00k13; Path=/</code></pre><p>first-party是指你登录或使用的网站所发行的 cookie，而third-party cookie 常为一些广告网站，有侵犯隐私以及安全隐患。</p><p>我们将这类 Cookie 称为 first-party。也就是说，我在浏览器中访问该URL，并且如果我访问相同的URL或该站点的另一个路径（假设Path为/），则浏览器会将cookie发送回该网站。</p><p>现在考虑在https://serene-bastion-01422.herokuapp.com/get-frog/上的另一个网页。该页面设置了一个cookie，此外，它还从https://www.valentinog.com/cookie-frog.jpg托管的远程资源中加载图像。</p><p>该远程资源又会自行设置一个cookie:</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1b74edbd458949768cb0dcbf91765f8c><p class=pgc-img-caption></p></div><p>我们将这种 cookie 称为third-party(第三方) Cookie。</p><p><strong>第三方 Cookie</strong> 除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。</p><pre><code>&lt;img src="facebook.com" style="visibility:hidden;"&gt;</code></pre><p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p><h1 class=pgc-h-arrow-right><strong>使用 SameSite 属性</strong></h1><p>Cookie 的SameSite 属性用来限制third-party Cookie，从而减少安全风险。它可以设置三个值。</p><ul><li>Strict</li><li>Lax</li><li>None</li></ul><p>Strict最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p><pre><code>Set-Cookie: CookieName=CookieValue; SameSite=Strict;</code></pre><p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p><p>Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><pre><code>Set-Cookie: CookieName=CookieValue; SameSite=Lax;</code></pre><p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p><div class=pgc-img><img alt="「必需知道」实用，完整的HTTP cookie指南" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f8c4f74cd6444e6f9bf8b6f044e6d646><p class=pgc-img-caption></p></div><p>设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p><p>Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p><p>下面的设置无效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None</code></pre><p>下面的设置有效。</p><pre><code>Set-Cookie: widget_session=abc123; SameSite=None; Secure</code></pre><h1 class=pgc-h-arrow-right><strong>Cookies 和 认证</strong></h1><p>身份验证是 web 开发中最具挑战性的任务之一。关于这个主题似乎有很多困惑，因为JWT中的基于令牌的身份验证似乎要取代“旧的”、可靠的模式，如基于会话的身份验证。</p><p>来看看 cookie 在这里扮演什么角色。</p><h1 class=pgc-h-arrow-right><strong>基于会话的身份验证</strong></h1><p>身份验证是 cookie 最常见的用例之一。</p><p>当你访问一个请求身份验证的网站时，后端将通过<strong>凭据</strong>提交（例如通过表单）在后台发送一个Set-Cookie标头到前端。</p><p>型的会话 cookie 如下所示:</p><pre><code>Set-Cookie: sessionid=sty1z3kz11mpqxjv648mqwlx4ginpt6c; expires=Tue, 09 Jun 2020 15:46:52 GMT; HttpOnly; Max-Age=1209600; Path=/; SameSite=Lax</code></pre><p>这个Set-Cookie头中，服务器可以包括一个名为session、session id或类似的cookie。</p><p>这是浏览器可以清楚看到的唯一标识符。每当通过身份验证的用户向后端请求新页面时，浏览器就会发回会话cookie。</p><p>基于会话的身份验证是有状态的，因为后端必须跟踪每个用户的会话。这些会话的存储可能是：</p><ul><li>数据库</li><li>像 Redis 这样的键/值存储</li><li>文件系统</li></ul><p>在这三个会话存储中，Redis 之类应优先于数据库或文件系统。</p><p>请注意，基于会话的身份验证与浏览器的会话存储无关。</p><p>之所以称为<strong>基于会话</strong>的会话，是因为用于用户识别的相关数据存在于后端的会话存储中，这与浏览器的会话存储不同。</p><h1 class=pgc-h-arrow-right><strong>何时使用基于会话的身份验证</strong></h1><p>只要能使用就使用它。基于会话的身份验证是一种最简单、安全、直接的网站身份验证形式。默认情况下，它可以在Django等所有流行的web框架上使用。</p><p>但是，它的状态特性也是它的主要缺点，特别是当网站是由负载均衡器提供服务时。在这种情况下，像粘贴会话，或者在集中的Redis存储上存储会话这样的技术会有所帮助。</p><h1 class=pgc-h-arrow-right><strong>关于 JWT 的说明</strong></h1><p><strong>JWT</strong>是 JSON Web Tokens的缩写，是一种身份验证机制，近年来越来越流行。</p><p>JWT 非常适合单页和移动应用程序，但它带来了一系列新挑战。想要针对API进行身份验证的前端应用程序的典型流程如下：</p><ul><li>前端将凭证发送到后端</li><li>后端检查凭证并发回令牌</li><li>前端在每个后续请求上带上该令牌</li></ul><p>这种方法带来的主要问题是：为了使用户保持登录状态，我将该令牌存储在前端的哪个地方？</p><p>对于前端开发来说，最自然的事情是将令牌保存在localStorage中。由于许多原因，这很糟糕。</p><p>localStorage很容易从 JS 代码访问，而且它很容易成为<strong>XSS</strong>攻击的目标。</p><p>为了解决此问题，大多数开发人员都将<strong>JWT</strong>令牌保存在cookie中，以为HttpOnly和Secure可以保护cookie，至少可以免受XSS攻击。</p><p>将 SameSite 设置为 strict 就可以完全保护 JWT免受CSRF攻击</p><p>设置为SameSite = Strict的新SameSite属性还将保护你的“熟化” JWT免受CSRF攻击。但是，由于SameSite = Strict不会在跨域请求上发送cookie，因此，这也完全使JWT的用例无效。</p><p>那SameSite=Lax呢？此模式允许使用安全的HTTP方法（即GET，HEAD，OPTIONS和TRACE）将 cookie发送回去。POST 请求不会以任何一种方式传输 cookie。</p><p>实际上，将JWT标记存储在cookie或localStorage中都不是好主意。</p><p>如果你确实要使用JWT而不是坚持使用基于会话的身份验证并扩展会话存储，则可能要使用带有刷新令牌的JWT来保持用户登录。</p><h1 class=pgc-h-arrow-right><strong>总结</strong></h1><p>自1994年以来，HTTP cookie一直存在，它们无处不在。</p><p>Cookies是简单的文本字符串，但可以通过<strong>Domain</strong>和Path对其权限进行控制，具有Secure的Cookie，只能通过 HTTP S进行传输，而可以使用 HttpOnly从 JS隐藏。</p><p>但是，对于所有预期的用途，cookie都可能使用户暴露于攻击和漏洞之中。</p><p>浏览器的供应商和Internet工程任务组（Internet Engineering Task Force）年复一年地致力于提高cookie的安全性，最近的一步是SameSite。</p><p>那么，什么才算是比较安全cookie？，如下几点：</p><ul><li>仅使用 HTTPS</li><li>尽可能带有 HttpOnly 属性</li><li>正确的SameSite配置</li><li>不携带敏感数据</li></ul><p>人才们的 <strong>【三连】</strong> 就是小智不断分享的最大动力，如果本篇博客有任何错误和建议，欢迎人才们留言，最后，谢谢大家的观看。</p><hr><p>作者：valentinog 译者：前端小智 来源：valentinog</p><p>原文：https://gizmodo.com/the-complete-guide-to-cookies-and-all-the-stuff-w-1794247382</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'实用','HTTP','cookie'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>