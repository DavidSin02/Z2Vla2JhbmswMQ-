<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑 | 极客快訊</title><meta property="og:title" content="Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/59cd9f0d205a4bbe942f8ded03e8789e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f749bd22.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f749bd22.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f749bd22.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>本文是“Java秒杀系统实战系列文章”的第十五篇，本文我们将借助综合中间件Redisson优化“秒杀系统中秒杀的核心业务逻辑”，解决Redis的原子操作在优化秒杀逻辑过程中出现的部分瑕疵。</p><p>Redisson，字如其名，是搭建在缓存中间件Redis的基础之上的一款综合中间件，除了拥有Redis本身提供的强大功能之外，还提供了诸如分布式锁、分布式服务、延迟队列、远程调用等强大的功能（从名字就可以看出来了：Redis + son，犹如Redis的儿子，儿子不仅继承了老爸强大的血脉，而且还自己修炼、发展出了属于自己的一套本领）。</p><div class=pgc-img><img alt=Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/59cd9f0d205a4bbe942f8ded03e8789e><p class=pgc-img-caption></p></div><p class=ql-align-justify>在本篇文章中，我们将使用Redisson中间件其中一个强大的功能组件“分布式锁”，用以解决秒杀系统中高并发产生的多线程对于共享资源/代码块的访问所导致的“并发安全”问题！</p><p class=ql-align-justify>而之所以需要Redisson这一组件，是因为在上一篇文章中，我们在采用Redis解决秒杀系统中出现的“库存超卖”、“重复秒杀”等问题时所对应的代码存在着瑕疵，即在使用Redis的SetNX操作之前、而还没来得及执行Expire操作的时候，Redis的节点如果恰好出现宕机或者服务不能用的情况，那将会导致相应的Key永远存在于缓存中，而处于“被锁死”的状态！</p><p class=ql-align-justify>Redisson分布式锁的出现可以很好地解决这种问题，其底层的实现机制在于“Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期”，除此之外，Redisson还通过加锁的方法提供了leaseTime的参数来指定加锁的时间，即超过这个时间后锁便自动解开了。</p><p class=ql-align-justify>接下来，我们将基于SpringBoot搭建的秒杀系统整合Redisson，加入其相关的依赖以及配置，并使用其“分布式锁”组件彻底解决秒杀过程中出现的“库存超卖”以及“重复秒杀”等问题。</p><p class=ql-align-justify>（1）首先，需要加入Redisson的依赖，版本号为3.8.2，如下所示：</p><ul><li><br></li></ul><pre>&lt;!--redisson--&gt;&lt;dependency&gt; &lt;groupId&gt;org.redisson&lt;/groupId&gt; &lt;artifactId&gt;redisson&lt;/artifactId&gt; &lt;version&gt;${redisson.version}&lt;/version&gt;&lt;/dependency&gt;</pre><p class=ql-align-justify>然后需要在配置文件application.properties中加入Redis服务所在的Host、Port等信息，如下所示：</p><ul><li><br></li></ul><pre>#spring.redis.password=redis.config.host=redis://127.0.0.1:6379</pre><p class=ql-align-justify>（2）紧接着，是基于Spring Boot自定义注入Redisson相关操作的Bean组件，其中，主要是RedissonClient 操作组件的自定义注入，其完整源代码如下所示：</p><ul><li><br></li></ul><pre>/** * redisson通用化配置 * @Author:debug (SteadyJack) * @Date: 2019/7/2 10:57 **/@Configurationpublic class RedissonConfig { @Autowired private Environment env; @Bean public RedissonClient redissonClient(){ Config config=new Config(); config.useSingleServer() .setAddress(env.getProperty("redis.config.host")) .setPassword(env.getProperty("spring.redis.password")); RedissonClient client=Redisson.create(config); return client; }}</pre><p class=ql-align-justify>（3）前期工作已经准备完毕，接下来我们需要将其应用到秒杀系统中 秒杀的核心操作逻辑，在KillService服务类中我们开辟了一个新的处理方法，即killItemV4，其完整的源代码如下所示：</p><ul><li><br></li></ul><pre>@Autowiredprivate RedissonClient redissonClient;//商品秒杀核心业务逻辑的处理-redisson的分布式锁@Overridepublic Boolean killItemV4(Integer killId, Integer userId) throws Exception { Boolean result=false; final String lockKey=new StringBuffer().append(killId).append(userId).append("-RedissonLock").toString(); RLock lock=redissonClient.getLock(lockKey); try { //TODO:第一个参数30s=表示尝试获取分布式锁，并且最大的等待获取锁的时间为30s //TODO:第二个参数10s=表示上锁之后，10s内操作完毕将自动释放锁 Boolean cacheRes=lock.tryLock(30,10,TimeUnit.SECONDS); if (cacheRes){ //TODO:核心业务逻辑的处理 if (itemKillSuccessMapper.countByKillUserId(killId,userId) &lt;= 0){ ItemKill itemKill=itemKillMapper.selectByIdV2(killId); if (itemKill!=null &amp;&amp; 1==itemKill.getCanKill() &amp;&amp; itemKill.getTotal()&gt;0){ int res=itemKillMapper.updateKillItemV2(killId); if (res&gt;0){ commonRecordKillSuccessInfo(itemKill,userId); result=true; } } }else{ throw new Exception("redisson-您已经抢购过该商品了!"); } } }finally { //TODO:释放锁 lock.unlock(); } return result;}</pre><p class=ql-align-justify>从该源代码中，我们主要是使用了Redisson分布式锁中的“可重入锁”组件，其使用需要经过如下几个步骤：</p><p class=ql-align-justify>A．需要尝试去获取锁，其对应的代码以及注释如下所示：</p><ul><li><br></li></ul><pre>//TODO:第一个参数30s=表示尝试获取分布式锁，并且最大的等待获取锁的时间为30s//TODO:第二个参数10s=表示上锁之后，10s内操作完毕将自动释放锁Boolean cacheRes=lock.tryLock(30,10,TimeUnit.SECONDS);</pre><p class=ql-align-justify>B.在获取到锁之后，即cacheRes=true，即可进入秒杀核心业务逻辑的处理；同时在处理完成之后，需要释放锁，如下所示：</p><ul><li><br></li></ul><pre>//TODO:释放锁lock.unlock();</pre><p class=ql-align-justify>（4）至此，基于Redisson的分布式锁解决高并发业务场景下，并发多线程对于共享资源/共享代码块的并发访问所出现的并发安全的问题的代码实战已经完毕了！</p><p class=ql-align-justify>我们接下来进入压测环节，仍然以之前的测试用例为例，即killId=3的待秒杀商品的可秒杀数量total=6，可以随机选取的用户Id列表的总数为10个，其取值为10040~10049，则理论上最好的结果是：total最终变为=0，同时item_kill_success有6条用户秒杀成功后生成的订单记录。</p><p class=ql-align-justify>这个时候，我们尝试将线程组中并发的线程数调整为10w，点击启动按钮，稍等片刻，观察控制台的输出信息以及item_kill和item_kill_success的数据库表，查看其最终的记录结果，如下图所示：</p><div class=pgc-img><img alt=Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/21ca5c66d94e4308804ee1a58d41b559><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><div class=pgc-img><img alt=Java秒杀系统实战系列-基于Redisson的分布式锁优化秒杀逻辑 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cfc688265171438f895f7ebedcec1fce><p class=pgc-img-caption></p></div><p class=ql-align-justify>对于这一结果，其实可以说是预料之中了！Redisson的分布式锁确实可以在高并发业务场景/多线程高并发 场景下起到举足轻重的作用。而在现实生活中，其实Debug也是建议各位小伙伴可以去研究这一综合中间件，它完全可以替代Redis在项目中的使用，而且其提供的数据结构以及使用方式跟JavaSE中的数据结构很类似，比如List、Set、Map、Queue等等都可以在Java中找到相应的踪影（而事实上Redisson的许多分布式组件跟数据结构正是基于Java中相应的数据结构来实现的）！</p><p class=ql-align-justify><strong>相关视频教程可私信咨询。</strong></p><p><strong>推荐阅读：</strong></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6713874877717152259/?group_id=6713874877717152259" target=_blank>Java商城秒杀系统的设计与实战教程（SpringBoot版）</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6714285446257443331/?group_id=6714285446257443331" target=_blank>Java秒杀系统实战系列-构建SpringBoot多模块项目</a></p><p><a class=pgc-link data-content=mp href="https://www.toutiao.com/i6724300749322338830/?group_id=6724300749322338830" target=_blank>Java秒杀系统实战系列-基于Redis的原子操作优化秒杀逻辑</a></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','系统','实战'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>