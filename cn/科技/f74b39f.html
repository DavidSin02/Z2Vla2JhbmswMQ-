<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 异步编程导论 | 极客快訊</title><meta property="og:title" content="Java 异步编程导论 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/3c356b1aa9b4416ca7b35a07f3033e13"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f74b39f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f74b39f.html><meta property="article:published_time" content="2020-10-29T20:59:18+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:18+08:00"><meta name=Keywords content><meta name=description content="Java 异步编程导论"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f74b39f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 异步编程导论</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>异步编程是可以让程序并行运行的一种手段，其可以让程序中的一个工作单元与主应用程序线程分开独立运行，并且等工作单元运行结束后通知主应用程序线程它的运行结果或者失败原因。使用它有许多好处，例如改进的应用程序性能和减少用户等待时间等。</p><p>在日常开发中我们经常会遇到这样的情况，就是需要异步的处理一些事情，而主线程不需要知道异步任务的结果，最常见的是在调用线程里面异步打日志，在高并发系统中为了不让日志打印阻塞调用线程，会把日志设置为异步方式，也就是使用一个队列把日志打印异步化，这种情况下调用线程把日志任务放入队列后就继续去干自己的事情了，而不再关心日志任务具体是什么时候入盘的。在Spring框架中提供的@Async注解就可以把一个任务异步化来进行处理，这个后面章节会具体讲解。</p><p>另外有时候我们还需要开启异步任务执行后，在主线程等待异步任务的执行结果，这时候Future就排上用场了，比如线程A要做从数据库I和数据库II查询一条记录，并且把两者结果拼接起来作为前端展示使用，如线程A是同步调用两次查询，则整个过程耗时时间为访问数据库I的耗时加上访问数据库II的耗时，如下图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 异步编程导论" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3c356b1aa9b4416ca7b35a07f3033e13><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>image.png</p><p>如果为异步调用则可以在线程A内开启一个异步运行单元来从数据库I获取数据，然后线程A本身来从数据库II获取数据，并且等两者结果都返回后，在拼接两者结果，这时候整个过程耗时为max(线程A从数据库II获取数据耗时，异步运行单元从数据库I获取数据耗时），如下图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 异步编程导论" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d676a4ccf114aff8bf3fed45082a0bd><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>image.png</p><p>可见整个过程耗时有显著缩短，对于用户来说页面响应时间会更短，对用户体验会更好，其中异步单元的执行一般是线程池中的线程。</p><p>使用Future确实可以获取异步任务的执行结果，但是获取其结果还是会阻塞调用线程的，并没有实现完全异步化处理，在JDK8中提供了CompletableFuture来弥补了其缺点，实现了实际意义上的异步处理。</p><p>Java 8引入了lambdas和CompletableFuture，Lambdas允许编写简洁的回调，而CompletionStage接口和CompletableFuture类最终允许以非阻塞方式和基于推送的方式处理结果，其通过设置回调函数方式，让主线程彻底解放出来，做自己的事情。</p><p>Java 8还引入了Stream，它旨在有效地处理数据流（包括原始类型），这些数据流可以在没有延迟或很少延迟的情况下访问，其使用声明式编程让我们可以写出可读性可维护性很强的代码，其结合CompletableFuture可以完美的实现异步编程。但是它是基于拉的，只能使用一次，缺少与时间相关的操作，虽然可以执行并行计算，但无法指定要使用的线程池。它还没有设计用于处理延迟的操作，例如I / O操作。这就是Reactor或RxJava等Reactive API的用武之地。</p><p>Reactor或RxJava等反应性API也提供Java 8 Stream等运算符，但它们更适用于任何流序列（不仅仅是集合），并允许定义一个转换操作的管道，该管道将应用于通过它的数据，这要归功于方便的流畅API和使用lambdas。它们旨在处理同步或异步操作，并允许您缓冲，合并，连接或对数据应用各种转换。</p><p>另外对于网络传输来说，同步调用时比较直截了当的，但是同步调用意味着当前发起请求的机器中的线程在远端机器返回结果前必须阻塞等待，这明显很浪费资源，好的做法应该是发起请求的机器发起调用线程发起请求后，注册一个回调函数，然后马上返回去做其他事情，当远端把结果返回后在使用IO线程执行回调函数，也就是发起方实现了异步调用，调用线程不会被阻塞。</p><p>比如在使用rpc(远程过程调用)发起请时候，使用异步编程也可以提高系统的性能，比如我们在一个线程A中通过rpc请求获取服务B和服务C的数据然后基于两者结果做一些事情。在同步rpc调用情况下，线程A需要调用服务B后需要等待服务B结果返回后，才可以对服务C发起调用，然后等服务C结果返回后才可以结合服务B和C的结果做一件事,如下图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 异步编程导论" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d1ada746628e4be0a1d77223f4c9a9cc><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>image.png</p><p>线程A同步获取服务B结果后，在同步调用服务C获取结果，可见在同步调用情况下线程A必须顺序的对多个服务请求进行调用。</p><p>而在异步调用情况下，当线程A调用服务B时候，服务B直接会返回一个异步的futureB对象，然后线程A可以继续访问服务C，服务C也会返回一个futureC对象，然后线程A就可以基于futureB和futureC来获取最终的返回结果，然后基于结果做一些事情，如下图：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt="Java 异步编程导论" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e0ea543705584c5f969a7d1e97ffb0a1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>image.png</p><p>可知异步调用情况下线程A可以并发的调用服务B和服务C，而不再是顺序的，由于服务B和服务C是并发运行，所以相比线程A同步调用，线程A获取到服务B和服务C结果的时间会缩短很多（同步调用情况下耗时时间为服务B和服务C返回结果耗时的和，异步调用时候耗时为max(服务B耗时，服务C耗时）），后面章节我们会以Dubbo框架为例其借助Netty的非阻塞异步API实现了服务消费端的异步调用。</p><p>在Web应用中Servlet占有一席之地，在Servlet3.0规范前，Servlet容器对Servlet的处理都是每个请求对应一个线程这种1：1的模式进行处理的，每当来一个请求时候都会开启一个Servlet容器内的线程来进行处理，如果Servlet内处理比较耗时，则会把Servlet容器内线程使用耗尽，然后就不能再处理新的请求；Servlet3.0中则提供了异步处理的能力，让Servlet容器中的线程可以及时释放，具体Servlet业务处理逻辑是在业务自己线程池内来处理；虽然Servlet3.0规范让Servlet的执行变为了异步，但是其IO还是阻塞式的，IO阻塞是说在Servlet处理请求时候从ServletInputStream中读取请求体时候是阻塞的，而我们想要的是当数据已经就绪时候通知我们去读取就可以了，因为这可以避免占用我们自己的线程来进行阻塞读取，Servlet3.1规范则提供了非阻塞IO来解决这个问题。</p><p>虽然Servlet技术栈的不断发展实现了异步处理与非阻塞IO，但是其异步是不彻底的，因为受制于Servlet规范本身，比如其规范是同步的（Filter，Servlet）或阻塞（getParameter，getPart）。所以新的使用少量线程和较少的硬件资源来处理并发非阻塞Web技术栈应运而生-WebFlux,其是与Servlet技术栈并行存在的一种新的技术，其基于JDK8函数式编程与Netty实现天然的异步、非阻塞处理。</p><p>另外为了更好的处理异步执行，一些框架也应运而生，比如高性能线程间消息传递库Disruptor，其通过为事件（events）预先分配内存、无锁CAS算法、缓冲行填充、两阶段协议提交来实现多线程并发的处理不同的元素，从而实现高性能的异步处理,关于并发编程相关知识可以参考《Java并发编程之美》一书；比如Akka其基于Actor模式实现了天然支持分布式的使用消息进行异步处理的服务。</p><p>一些新兴的语言对异步处理的支持能力让我们忍不住称赞，golang就是其中之一，其通过goroutine与channel可以轻松的实现复杂的异步处理能力。</p><div class=tt-column-card data-content='{"new_thumb_url": "http://sf1-ttcdn-tos.pstatp.com/img/pgc-image/156154482609605e3db01c4", "title": "\u5206\u5e03\u5f0fRPC\u6846\u67b6Dubbo\u5185\u6838\u539f\u7406\u5256\u6790", "distribution_user_id": 1624358660504589, "price": 29.9, "column_id": "6706788500336804110", "share_price": 2.39, "author_description": "\u683c\u5c40\u591a", "thumb_url": "http://p4.pstatp.com/large/pgc-image/156154482609605e3db01c4", "sold": 34}'></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java','异步','编程'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>