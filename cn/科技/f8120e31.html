<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>大牛笔记：iOS开发之单元测试避雷指南 | 极客快訊</title><meta property="og:title" content="大牛笔记：iOS开发之单元测试避雷指南 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/cecee5c2-2893-4ce1-8241-540cd5788edb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f8120e31.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f8120e31.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="大牛笔记：iOS开发之单元测试避雷指南"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f8120e31.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>大牛笔记：iOS开发之单元测试避雷指南</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=大牛笔记：iOS开发之单元测试避雷指南 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/cecee5c2-2893-4ce1-8241-540cd5788edb><p class=pgc-img-caption></p></div><p><br></p><p><strong>前言：</strong>本文侧重讲述如何在iOS程序的开发过程中使用单元测试。使用Xcode自带的OCUnit作为测试框架。</p><p>一、单元测试概述</p><p>单元测试作为敏捷开发实践的组成之一，其目的是提高软件开发的效率，维持代码的健康性。其目标是证明软件能够正常运行，而不是发现bug（发现bug这一目的与开发成本是正相关的，虽然发现bug是保证软件质量的一种手段，但是很显然这与降低软件开发成本这一目的背道而驰）。它是对软件质量的一种保证，例如重构之后我们需要保证软件产品的正常运行。</p><p>很多人认为编写单元测试没有用是认为单元测试并不能保证一定能减少bug发生的机率，而由于编写单元测试一定会花费一定的时间与精力，因而必然的会增加成本。客观的说，造成这种原因很大的程度上是程序员的水平不够高。我认为使用使用单元测试带来巨大好处的必要条件如下所示：</p><ul><li>程序员本身的编程水平--是否有较多的代码经验，是否熟练掌握重构</li><li>程序员对项目的认知--是否能正确理解软件或模块的需求</li><li>项目质量--是否稳定，是否长期多版本，是否需要应对较多变化</li></ul><p>如果程序员水平较高，对需求理解较为清晰，项目需要面对较多的变化，那么毫无疑问单元测试对于软件非常有益。假如软件功能简单且开发周期短，不需要进行复杂的维护工作，那么单元测试的意义并不大。</p><p>优秀的单元测试好处很多。但最重要的一点，就是保证了软件质量的同时，由于减少bug和应对变化造成的回归bug的产生等，提高了劳动生产率。</p><p>而且，在敏捷流程中，使用单元测试是必须掌握的手段，否则就没法保证重构的正确性，从而造成代码无法面对变化。</p><p>二、iOS的单元测试概述</p><p>刚接触客户端编程时，我在很长一段时间内都想不通对于客户端程序如何编写单元测试。单元测试本质上说白了就是用一些断言来判定结果，而这种方式是如何应用到具有复杂交互的界面测试上来的呢？</p><p>我们要做的就是将客户端代码转化为易于测试的代码。什么样的代码易于测试呢？它至少是这样的：</p><p><strong>1、被测方法需要产生可测量的结果。</strong></p><p><strong>2、类之间的关系应该是松耦合的。</strong></p><p>其中第一条是必要条件。使用断言这种形式指明了测试的方法最终要造成某些可以度量的结果。因而，我们需要尽量的将展示和业务逻辑分离开来。展示的代码是没法测试的，例如有的方法只是播放动画。而业务逻辑最终都会造成一些数据的改变，这是容易测试的。</p><p>大略的讲，作为一个iOS程序员来说，首先要了解一个叫做MVC的模式。这个模式定义了Cocoa Touch框架的总体结构。在iOS程序中，我们也需要按照这种模式进行界面代码的编写。这样设计出来的类具有较好的结构，且比较适合于做单元测试。</p><p>然后一定要懂得不停重构代码，这样我们才能使代码不停地改善，不停地变得更加适合单元测试。</p><p>有一些框架可以帮助大家更好的测试，分别是OCUnit、GTM、GHUnit、CATCH、OCMock，但目前对我来说，OCUnit足够用了。作为苹果官方提供的测试框架，它最大的优点就是简单易用。</p><p>三、单元测试实践</p><p>下面是一些我所理解的单元测试中比较好的实践。</p><p>顾名思义，单元测试面向的对象是单元，这个专有名词源自编译器领域的术语“编译单元”。在面向过程中，指的是函数，而在面向对象中，指的通常就是“类”。因而，每个功能类都应该提供对应的单元测试。</p><p><strong>实践1 ：每个功能类都应提供单元测试，且每一个测试类，只依赖于其要测试的受测类。使用伪造对象可以避免对其他类的依赖。</strong></p><p>解释 保证一个测试类只关注一个被测类，当测试不通过时，就能迅速的定位到是谁发生了错误，而不会受到其他类的干扰。</p><p>简单的数据类等可以不提供，但是要保证该测试的都要覆盖到。并不存在一种合适的度量指标可以量化地判断某种单元测试方案是否成功。常用的标准（代码覆盖率和成功执行的测试用例数）都可以在受测软件的质量不变的情况下人为的修改（作假）。当然，在无法确保程序员素质的情况下，作为没有办法的办法，使用这种标准也是可以的（或者无奈的说，必须的）。单元测试需要程序员自己把关，关注哪些功能确实需要测试覆盖。这也就是前面所说的一些程序员不相信单元测试可以提高生产率的理由--它更多的依赖于程序员的素质，这是没有保证的。但同样的，由于敏捷是一种以人为本的思想实践，因而这种行为似乎又是一种必然。</p><p>实践1.1 使用伪造类避免对其他类的依赖。</p><p>解释 避免依赖的一种手段。</p><p>例如，某个被测的方法声明是这样的：</p><p>-(void)xxxx:(Person *)person;</p><p>如果测试时传入Person的话，就造成了测试类依赖于两个类。当由于person中的错误引发测试不通过时，就不能迅速的定位到受测类中是否有问题。遇到这种情况，就可以使用伪造类。假如方法中只使用了person的一个属性name，那么可以将方法名重构为</p><p>-(void)xxxx:(id)person;（此处id有待商榷，只是这样做最简单）</p><p>然后在单元测试的target中添加只包含name属性的fakePerson来作为伪造类。这样，一旦发生错误就可以迅速的推测出错误的来源。</p><p>实践1.2 使用伪造环境避免其他环境的干扰。</p><p>解释 适合于异步的方法测试。</p><p>很经常遇到的一种情况是测试有网络环境的代码。由于异步的存在，这会造成测试代码不好写。一种简单的解决方法是，我们假定网络一定是通畅的，则我们测试的代码将分为两部分，即拼装发送功能和接收解析功能。假如发送和接收功能各自都能通过测试，那么我们大约可以确定这个异步方法的正确性。另一种方法是使用GHUnit，它支持异步代码的测试。</p><p>实践2：测试用例（方法）名应该是自解释的且是独立的。<br>解释 基本功。</p><p>如果被测试类的名称是XXX，那么测试类可以命名为XXXTests。而对于其中要测试的功能，命名应该是自解释的。这可以在发现错误时尽快的定位问题所在。例如，如果某个属性obj应该是非空的，那么我们可以将其命名为：</p><p>-(void)testObjNotNil{}</p><p>每个方法目标应该是单一的，大多数情况下每个方法内都只有一个断言语句；方法不应该依赖于其他方法的结果作为输入，保证原子性。</p><p>实践3：断言语句需要解释测试者的意图。</p><p>解释 基本功</p><p>每种单元测试框架都提供了很多断言语句，从根本上来说它们都是一样的。但是测试者需要根据自己的目的选择适当的语句，这样才可以让别人阅读测试代码时理解用例设计的目的。例如对于STAssertNil和STAssertNotNil等等。</p><p>实践4：<strong>判断某个意图有没有达到的很好的方法是检测方法影响的数据有没有合理的变化。</strong></p><p>解释 基本功</p><p>由於单元测试是使用断言语句来做判断的，因而最容易做的就是判断数据的变化。这也就限定了单元测试能测试的方法范围，即引起数据变化的方法。对于一些纯展示的方法，例如播放一段特效，这种方法是无法靠单元测试来进行约束的。测试数据的特性包括取值范围（int、float等），排列顺序（NSArray等），类型等等。</p><p>实践5：运用重构的手段使方法变得易于被测试。</p><p>解释 单元测试是保障重构安全的手段，重构也可以使代码易于被测试。</p><p>什么样的代码是容易进行单元测试的？最简单的一点就是，每个被测方法都应该是功能单一的。当然，这也是代码规范中应该做到的。方法的功能单一，则测试方法的断言也会比较好确定。如果你发现某个方法很难进行测试，则就应该对这个方法进行拆分重构。</p><p>实践5.1 面向抽象设计类之间的关系。</p><p>解释 利于伪造类的实现。</p><p>类之间通讯如果依赖于抽象（接口），则可以较容易的使用伪造类。参照实践1.1。</p><p>实践6：运用自上而下的方式构建类。</p><p>解释 自上而下的方式可以使类的功能明确，类的构成将会清晰紧凑，不会出现一些废方法。</p><p>先确定类需要负担的责任，以此来确定类具有的公有方法以及属性。通过重构将公有方法中的代码转化为私有方法，以使方法尽量短小紧凑。</p><p>实践6.1 应对所有暴露的属性和方法提供测试，私有方法则不必。</p><p>解释 如果运用自上而下的方式构建类，则理论上私有方法应该都是公有方法重构而得到的。实际上测试公有方法时这些私有方法都应该被测试到了。而且，由于私有方法相对公有方法来说发生变动的可能性很大，会造成不必要的修改测试代码的成本。</p><p>回调方法不属于私有方法，也需要进行测试。</p><p>实践6.2 测试私有的方式，KVC、子类化和类别。</p><p>解释 基本功。</p><p>遇到需要通过验证私有数据才能编写的测试时，可以考虑使用KVC和子类化。子类继承于被测类，只包含於单元测试target，其作用就是在不改变受测类的情况下，使受测类具有某些易于被测的能力。</p><p>实践7：变化需要新测试的支持。</p><p>解释：保证测试的覆盖度。</p><p>就像敏捷中提到的“改变需要抽象”一样，在测试中改变需要新的测试。当然，度依然由程序员自己掌控。</p><p>四、一般流程</p><p>使用OCUnit最大的好处就是流程非常的简单，简单到让你觉得非常愉悦。由于有XCode的支持，添加测试变得异常简单。只要在新建工程时勾选“Include Unit Tests”，就会自动的加入一个示例。然后再需要添加新的单元测试时，新建一个“Objective-C test case class”就可以了。</p><p>测试文件中，只要知道setUp是初始化的地方，tearDown是结束清理的地方，而且它们在每个用例方法执行时都会重新执行--这保证了测试用例的原子性。然后知道每个测试用例都是以test作为前缀的，并且无返回值。然后在方法中编写断言语句就可以了。输入STAssertxxxxx就可以看到它们的联想提示。编写完成后，执行菜单Product->Test，单元测试就完成了！</p><p>五、总结</p><p>单元测试的代码如此简单，但是想写好单元测试却并不是一件简单的事情。它需要程序员比较深的功底。由于个人水平所限，有一些东西说的比较啰嗦。把复杂问题简单化是本事，任重而道远。希望大家可以在日常开发中运用好这种简洁高效的技术。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'避雷','笔记','iOS'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>