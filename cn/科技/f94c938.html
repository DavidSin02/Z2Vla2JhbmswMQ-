<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一个简单的8位处理器完整设计过程及verilog代码 | 极客快訊</title><meta property="og:title" content="一个简单的8位处理器完整设计过程及verilog代码 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RigBB9h5J4TrYJ"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f94c938.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f94c938.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f94c938.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f94c938.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f94c938.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f94c938.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f94c938.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f94c938.html><meta property="article:published_time" content="2020-10-29T21:04:05+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:05+08:00"><meta name=Keywords content><meta name=description content="一个简单的8位处理器完整设计过程及verilog代码"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f94c938.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一个简单的8位处理器完整设计过程及verilog代码</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong class=highlight-text toutiao-origin=span>蓝字</strong><strong class=highlight-text toutiao-origin=span><i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-2">关注</i>我们</strong></p><p><strong>邀请函</strong></p><p><strong>上海临港-集成电路产学研技术论坛</strong></p><p>【12月13日 上海临港】</p><p>（免费VIP参观、免费午餐、免费地铁接送）</p><p><strong class=highlight-text toutiao-origin=span>来源：EETOP BBS 作者：weiboshe</strong></p><p><em>一个简单的8位处理器完整设计过程及verilog代码,适合入门学习参考，并含有作者个人写的指令执行过程（点击下方 <i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-1">阅读原文</i> 到论坛可下载源码）</em></p><p></p><h1 toutiao-origin=h4>1. CPU定义</h1><p>我们按照应用的需求来定义计算机，本文介绍一个非常简单的CPU的设计，它仅仅用来教学使用的。我们规定它可以存取的存储器为<i class="chrome-extension-mutihighlight chrome-extension-mutihighlight-style-3">64</i>byte，其中1byte=8bits。所以这个CPU就有6位的地址线A[5：0]，和8位的数据线D[7：0]。</p><p>我们仅定义一个通用寄存器AC（8bits寄存器），它仅仅执行4条指令如下：</p><table><tbody><tr><td><p>Instruction</p></td><td><p>Instruction Code</p></td><td><p>Operation</p></td></tr><tr><td><p>ADD</p></td><td><p>00AAAAAA</p></td><td><p>AC&lt;—AC+M[AAAAAA]</p></td></tr><tr><td><p>AND</p></td><td><p>01AAAAAA</p></td><td><p>AC&lt;—AC^M[AAAAAA]</p></td></tr><tr><td><p>JMP</p></td><td><p>10AAAAAA</p></td><td><p>GOTO AAAAAA</p></td></tr><tr><td><p>INC</p></td><td><p>11XXXXXX</p></td><td><p>AC&lt;—AC+1</p></td></tr></tbody></table><p>除了寄存器AC外，我们还需要以下几个寄存器：</p><p>地址寄存器 A[5：0]， 保存6位地址。</p><p>程序计数器 PC[5：0]，保存下一条指令的地址。</p><p>数据寄存器 D[7：0]，接受指令和存储器来的数据。</p><p>指令寄存器 IR[1：0]，存储指令操作码。</p><p></p><h1 toutiao-origin=h4>2. 取指设计</h1><p>在处理器执行指令之前，必须从存储器取出指令。其中取指执行以下操作：</p><p>1〉 通过地址端口A[5：0]从地址到存储器</p><p>2〉 等待存储器准备好数据后，读入数据。</p><p>由于地址端口数据A[5：0]是从地址寄存器中读出的，所以取指第一个执行的状态是</p><p>Fetch1： AR&lt;—PC</p><p>接下来cpu发出read信号，并把数据从存储器M中读入数据寄存器DR中。同时pc加一。</p><p>Fetch2： DR&lt;—M，PC&lt;—PC+1</p><p>接下来把DR[7：6]送IR，把DR[5：0]送AR</p><p>Fetch3： IR&lt;—DR[7：6]，AR&lt;—DR[5：0]</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RigBB9h5J4TrYJ><p></p><h1 toutiao-origin=h4>3. 指令译码</h1><p>Cpu在取指后进行译码一边知道执行什么指令，对于本文中的CPU来说只有4条指令也就是只有4个执行例程，状态图如下：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RigBB9sEAy0DXa><p></p><h1 toutiao-origin=h4>4. 指令执行</h1><p>对译码中调用的4个例程我们分别讨论：</p><p><strong>4.1 ADD</strong><strong>指令</strong></p><p>ADD指令需要CPU做以下两件事情：</p><p>1〉 从存储器取一个操作数</p><p>2〉 把这个操作数加到AC上，并把结果存到AC</p><p>所以需要以下操作：</p><p>ADD1：DR&lt;—M</p><p>ADD2：AC&lt;—AC+DR</p><p><strong>4.2 AND</strong><strong>指令</strong></p><p>AND指令执行过程和ADD相似，需要以下操作：</p><p>AND1：DR&lt;—M</p><p>AND2：AC&lt;—AC^DR</p><p><strong>4.3 JMP</strong><strong>指令</strong></p><p>JMP指令把CPU要跳转的指令地址送PC，执行以下操作</p><p>JMP1： PC&lt;—DR[5：0]</p><p><strong>4.4INC</strong><strong>指令</strong></p><p>INC指令执行AC+1操作</p><p>INC1： AC&lt;—AC+1</p><p>总的状态图如下：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RigBBA69kSBzUZ><p></p><h1 toutiao-origin=h4>5 建立数据路径</h1><p>这一步我们来实现状态图和相应的寄存器传输。首先看下面的状态及对应的寄存器传输：</p><p>Fetch1： AR&lt;—PC</p><p>Fetch2： DR&lt;—M，PC&lt;—PC+1</p><p>Fetch3： IR&lt;—DR[7：6]，AR&lt;—DR[5：0]</p><p>ADD1： DR&lt;—M</p><p>ADD2： AC&lt;—AC+DR</p><p>AND1： DR&lt;—M</p><p>AND2： AC&lt;—AC^DR</p><p>JMP1： PC&lt;—DR[5：0]</p><p>INC1： AC&lt;—AC+1</p><p>为了设计数据路径，我们可以采用两种办法：</p><p>1〉创造直接的两个要传输组件之间的直接路径</p><p>2〉在CPU内部创造总线来传输不同组件之间的数据</p><p>首先我们回顾一下可能发生的数据传输，以便确定各个组件的功能。特别的我们要注意把数据载入组件的各个操作。首先我们按照他们改变了那个寄存器的数据来重组这些操作。得到如下的结果：</p><p>AR：AR&lt;—PC；AR&lt;—DR[5：0]</p><p>PC：PC&lt;—PC+1；PC&lt;—DR[5：0]</p><p>DR：DR&lt;—M</p><p>IR：IR&lt;—DR[7：6]</p><p>AC：AC&lt;—AC+DR；</p><p>AC&lt;—AC^DR；</p><p>AC&lt;—AC+1</p><p>现在我们来看每个操作来决定每个组件执行什么样的功能，AR，DR，IR三个组件经常从其他的组件载入数据（从总线），所以只需要执行一个并行输入的操作。PC和AC能够载入数据同时也能够自动加一操作。</p><p>下一步我们把这些组件连接到总线上来，如图所示：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RigBBAGAgWkkMC><p>如上图所示，各个组件与总线之间通过三态连接，防止出现总线竞争。AR寄存器送出存储器的地址，DR寄存器用于暂存存数起来的数据。到现在为止我们还没有讨论有关的控制信号，我们现在只是保证了所有的数据传输能够产生，我们将在后面章节来使这些数据传输正确的产生---控制逻辑。</p><p>现在我们来看以下者写数据传输中有没有不必要的传输：</p><p>1〉 AR仅仅提供数据给存储器，所以他不需要连接到总线上。</p><p>2〉 IR不通过总线提供数据给任何组件，所以他可以直接输出到控制单元（后面章节）。</p><p>3〉 AC不提供数据到任何的组件，可以不连接到总线上。</p><p>4〉 总线是8bit宽度的，但是有些传输是6bit或者2bit的，我们必须制定寄存器的那几位送到总线的那几位。</p><p>5〉 AC要可以载入AC和DR的和或者逻辑与的值，数据路径中还需要进行运算的ALU。</p><p>由此我们做以下工作：</p><p>1〉 去掉AR，IR， AC与总线的连接。</p><p>2〉 我们约定寄存器连接是从总线的低位开始的。AR，PC连接到Bus[5：0]，由于IR是接受DR[7：6]的，所以可以连接到总线的Bus[7：6]。</p><p>3〉 我们设定，AC作为ALU的一个输入，另一个输入来自总线Bus。</p><p>下面我们检查是否有争用总线的情况，幸运的是这里没有。修改后的CPU内部组织图如下：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RigBBAW4tKXXcZ><p></p><h1 toutiao-origin=h4>6. ALU设计</h1><p>这个CPU的ALU执行的功能就是两个操作数相加、逻辑与。这里不作详细介绍。电路如如下：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RigBBUE1pmAMCj><p></p><h1 toutiao-origin=h4>7. 控制单元</h1><p>现在我们来考虑如何产生数据路径所需的控制信号，有两种方法：硬布线逻辑和为程序控制。这里我们用硬布线逻辑来实现。</p><p>这个简单的CPU需要的控制逻辑由三个部件组成：</p><p>1〉计数器：用于保存现在的状态</p><p>2〉译码器：生成各个状态的控制信号</p><p>3〉其他的组合逻辑来产生控制信号</p><p>一个通用的控制单元原理图如下：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RigBBUX33ooNNw><p>对于这个CPU来说，一共有9个状态。所以需要一个4bit的计数器和一个4-16的译码器。接下来的工作就是按照前面的状态转换图来对状态进行赋值。</p><p>首先考虑如何的对译码输出状态进行赋值才能达到最佳状态。我们按照以下规则：</p><p>1〉给Fetch1赋计数器的0值，并用计数器的清零端来达到这个状态。由这个CPU的状态图可以看出，除了Fetch1状态外的状态都只能由一个状态转化而来，Fetch1需要从4个分支而来，这4个分支就可以发出清零信号（CLR）来转移到Fetch1。</p><p>2〉把连续的状态赋连续的计数器值，这样就可以用计数器的INC输入来达到状态的转移。</p><p>3〉给每个例程的开始状态赋值时，要基于指令的操作码和这个例程的最大状态数。这样就可以用操作码来生成计数器的LD信号达到正确的状态转移。首先，在Fetch3状态发出LD信号，然后要把正确的例程地址放到计数器的输入端。对这个CPU来说，我们考虑以地址1 [IR] 0作为计数器的预置输入。则得到状态编码如下：</p><br><br><br><br><br><br><br><table><tbody><tr><td><p>Instruction</p></td><td><p>State</p></td><td><p>IR</p></td><td><p>counter</p></td></tr><tr><td><p>Fetch</p></td><td><p>Fetch1</p></td><td><p>0000</p></td></tr><tr><td><p>Fetch2</p></td><td><p>0001</p></td></tr><tr><td><p>Fetch3</p></td><td><p>0010</p></td></tr><tr><td><p>ADD</p></td><td><p>ADD1</p></td><td><p>00</p></td><td><p>1000</p></td></tr><tr><td><p>ADD2</p></td><td><p>00</p></td><td><p>1001</p></td></tr><tr><td><p>AND</p></td><td><p>AND1</p></td><td><p>01</p></td><td><p>1010</p></td></tr><tr><td><p>AND2</p></td><td><p>01</p></td><td><p>1011</p></td></tr><tr><td><p>INC</p></td><td><p>INC1</p></td><td><p>10</p></td><td><p>1100</p></td></tr><tr><td><p>JMP</p></td><td><p>JMP1</p></td><td><p>11</p></td><td><p>1110</p></td></tr></tbody></table><p>如上表所示，下面我们需要设计产生计数器的LD、INC、CLR等信号，总的控制单元的逻辑如下图：</p><img alt=一个简单的8位处理器完整设计过程及verilog代码 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RigBBUoV7Jr9O><p>下面我们用这些译码信号来产生数据路径控制所必需的AR、PC、DR、IR、M和ALU的控制信号。首先考虑寄存器AR，他在Fetch1状态取PC的值，并在Fetch3状态取DR[5：0]的值，所以我们得到ARLOAD=Fetch1 or Fetch3。以此类推我们可以得到如下结果：</p><p>PCLOAD=JMP1</p><p>PCINC=Fetch2</p><p>DRLOAD=Fetch1or ADD1 or AND1</p><p>ACLOAD=ADD2 or AND2</p><p>IRLOAD=Fetch3</p><p>对于ALU的控制信号ALUSEL是用来控制ALU做逻辑或者算数运算的，所以有：</p><p>ALUSEL=AND2</p><p>对于片内总线的控制较为复杂，我们先来看DR，对于DR他只在Fetch3、AND2 、ADD2和JMP1状态占用总线进行相信的数据传输，所以有：</p><p>DRBUS=Fetch3 or AND2 or ADD2 or JMP1</p><p>其他类似有：</p><p>MEMBUS=Fetch2or ADD1 or AND1</p><p>PCBUS=Fetch1</p><p>最后，控制单元需要产生存储器的读信号（READ），它发生在Fetch2、ADD1、AND1三个状态：</p><p>READ=Fetch2or ADD1 or AND1</p><p>这样我们得到了总的控制逻辑，完成了整个CPU的设计。</p><p></p><h1 toutiao-origin=h4>8. 设计验证</h1><p>我们执行如下指令进行设计验证，</p><p>0：ADD4</p><p>1：AND5</p><p>2：INC</p><p>3：JMP0</p><p>4：27H</p><p>5：39H</p><p>指令执行过程如下（初始化所有寄存器为全零态）：</p><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><table><tbody><tr><td><p>Instruction</p></td><td><p>State</p></td><td><p>Active Signals</p></td><td><p>Operations</p></td><td><p>Next State</p></td></tr><tr><td rowspan=5><p>ADD 4</p></td><td><p>Fetch1</p></td><td><p>PCBUS、ARLOAD</p></td><td><p>AR&lt;—0</p></td><td><p>Fetch2</p></td></tr><tr><td><p>Fetch2</p></td><td><p>READ、MEMBUS</p><p>DRLOAD、PCINC</p></td><td><p>DR&lt;—04H</p><p>PC&lt;—PC+1</p></td><td><p>Fetch3</p></td></tr><tr><td><p>Fetch3</p></td><td><p>DRBUS、ARLOAD</p><p>IRLOAD</p></td><td><p>IR&lt;—00</p><p>AR&lt;—04H</p></td><td><p>ADD1</p></td></tr><tr><td><p>ADD1</p></td><td><p>READ、MEMBUS</p><p>DRLOAD</p></td><td><p>DR&lt;—27H</p></td><td><p>ADD2</p></td></tr><tr><td><p>ADD2</p></td><td><p>DRBUS、ACLOAD</p></td><td><p>AC&lt;—0+27H</p></td><td><p>Fetch1</p></td></tr><tr><td rowspan=5><p>AND 5</p></td><td><p>Fetch1</p></td></tr><tr><td><p>Fetch2</p></td></tr><tr><td><p>Fetch3</p></td></tr><tr><td><p>ADD1</p></td></tr><tr><td><p>ADD2</p></td></tr><tr><td rowspan=4><p>INC</p></td><td><p>Fetch1</p></td></tr><tr><td><p>Fetch2</p></td></tr><tr><td><p>Fetch3</p></td></tr><tr><td><p>INC1</p></td></tr><tr><td rowspan=4><p>JMP 0</p></td><td><p>Fetch1</p></td></tr><tr><td><p>Fetch2</p></td></tr><tr><td><p>Fetch3</p></td></tr><tr><td><p>JMP1</p></td></tr></tbody></table></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'一个','简单','位处'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>