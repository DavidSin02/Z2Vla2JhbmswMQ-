<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>阿里巴巴开发规约中为什么要禁用Executors创建线程池？ | 极客快訊</title><meta property="og:title" content="阿里巴巴开发规约中为什么要禁用Executors创建线程池？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/426a8b5e6bdd45b8b1fcc7d5bed44acb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f98ab0a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f98ab0a.html><meta property="article:published_time" content="2020-10-29T21:01:27+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:27+08:00"><meta name=Keywords content><meta name=description content="阿里巴巴开发规约中为什么要禁用Executors创建线程池？"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f98ab0a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>阿里巴巴开发规约中为什么要禁用Executors创建线程池？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>引言：阿里巴巴开发手册中强制禁止使用Executors创建线程池，禁止使用原因为使用不当容易导致OOM。至于为什么会这样，本文则从源码层面分析的比较清晰，希望对你有所帮助。</p><h1><strong>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样</strong></h1><h1><strong>的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 说明:Executors 返回的线程池对象的弊端如下:<br>1)FixedThreadPool 和 SingleThreadPool:</strong></h1><h1><strong>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 2)CachedThreadPool 和 ScheduledThreadPool:</strong></h1><h1><strong>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</strong></h1><p>线程池的定义</p><p>管理一组工作线程。通过线程池复用线程有以下几点优点：</p><ul><li>减少资源创建 => 减少内存开销，创建线程占用内存</li><li>降低系统开销 => 创建线程需要时间，会延迟处理的请求</li><li>提高稳定稳定性 => 避免无限创建线程引起的OutOfMemoryError【简称OOM】</li></ul><p>Executors创建线程池的方式</p><p>根据返回的对象类型创建线程池可以分为三类：</p><ul><li>创建返回ThreadPoolExecutor对象</li><li>创建返回ScheduleThreadPoolExecutor对象</li><li>创建返回ForkJoinPool对象</li></ul><p>本文只讨论创建返回ThreadPoolExecutor对象</p><p>ThreadPoolExecutor对象</p><p>在介绍Executors创建线程池方法前先介绍一下ThreadPoolExecutor，因为这些创建线程池的静态方法都是返回ThreadPoolExecutor对象，和我们手动创建ThreadPoolExecutor对象的区别就是我们不需要自己传构造函数的参数。ThreadPoolExecutor的构造函数共有四个，但最终调用的都是同一个：</p><pre>public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)复制代码</pre><p>构造函数参数说明：</p><ul><li>corePoolSize => 线程池核心线程数量</li><li>maximumPoolSize => 线程池最大数量</li><li>keepAliveTime => 空闲线程存活时间</li><li>unit => 时间单位</li><li>workQueue => 线程池所使用的缓冲队列</li><li>threadFactory => 线程池创建线程使用的工厂</li><li>handler => 线程池对拒绝任务的处理策略</li></ul><p>线程池执行任务逻辑和线程池参数的关系</p><div class=pgc-img><img alt=阿里巴巴开发规约中为什么要禁用Executors创建线程池？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/426a8b5e6bdd45b8b1fcc7d5bed44acb><p class=pgc-img-caption></p></div><p>执行逻辑说明：</p><ul><li>判断核心线程数是否已满，核心线程数大小和corePoolSize参数有关，未满则创建线程执行任务</li><li>若核心线程池已满，判断队列是否满，队列是否满和workQueue参数有关，若未满则加入队列中</li><li>若队列已满，判断线程池是否已满，线程池是否已满和maximumPoolSize参数有关，若未满创建线程执行任务</li><li>若线程池已满，则采用拒绝策略处理无法执执行的任务，拒绝策略和handler参数有关</li></ul><p>Executors创建返回ThreadPoolExecutor对象</p><p>Executors创建返回ThreadPoolExecutor对象的方法共有三种：</p><ul><li>Executors#newCachedThreadPool => 创建可缓存的线程池</li><li>Executors#newSingleThreadExecutor => 创建单线程的线程池</li><li>Executors#newFixedThreadPool => 创建固定长度的线程池</li></ul><p>Executors#newCachedThreadPool方法</p><pre>public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());}复制代码</pre><p>CachedThreadPool是一个根据需要创建新线程的线程池</p><ul><li>corePoolSize => 0，核心线程池的数量为0</li><li>maximumPoolSize => Integer.MAX_VALUE，线程池最大数量为Integer.MAX_VALUE，可以认为可以无限创建线程</li><li>keepAliveTime => 60L</li><li>unit => 秒</li><li>workQueue => SynchronousQueue</li></ul><p>当一个任务提交时，corePoolSize为0不创建核心线程，SynchronousQueue是一个不存储元素的队列，可以理解为队里永远是满的，因此最终会创建非核心线程来执行任务。对于非核心线程空闲60s时将被回收。<strong>因为Integer.MAX_VALUE非常大，可以认为是可以无限创建线程的，在资源有限的情况下容易引起OOM异常</strong></p><p>Executors#newSingleThreadExecutor方法</p><pre>public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));}复制代码</pre><p>SingleThreadExecutor是单线程线程池，只有一个核心线程</p><ul><li>corePoolSize => 1，核心线程池的数量为1</li><li>maximumPoolSize => 1，线程池最大数量为1，即最多只可以创建一个线程，唯一的线程就是核心线程</li><li>keepAliveTime => 0L</li><li>unit => 毫秒</li><li>workQueue => LinkedBlockingQueue</li></ul><p>当一个任务提交时，首先会创建一个核心线程来执行任务，如果超过核心线程的数量，将会放入队列中，<strong>因为LinkedBlockingQueue是长度为Integer.MAX_VALUE的队列，可以认为是无界队列，因此往队列中可以插入无限多的任务，在资源有限的时候容易引起OOM异常</strong>，同时因为无界队列，maximumPoolSize和keepAliveTime参数将无效，压根就不会创建非核心线程</p><p>Executors#newFixedThreadPool方法</p><pre>public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());}复制代码</pre><p>FixedThreadPool是固定核心线程的线程池，固定核心线程数由用户传入</p><ul><li>corePoolSize => nThreads，核心线程池的数量为1</li><li>maximumPoolSize => nThreads，线程池最大数量为nThreads，即最多只可以创建nThreads个线程</li><li>keepAliveTime => 0L</li><li>unit => 毫秒</li><li>workQueue => LinkedBlockingQueue 它和SingleThreadExecutor类似，唯一的区别就是核心线程数不同，并且由于<strong>使用的是LinkedBlockingQueue，在资源有限的时候容易引起OOM异常</strong></li></ul><p>总结：</p><ul><li>FixedThreadPool和SingleThreadExecutor => 允许的请求队列长度为Integer.MAX_VALUE，可能会堆积大量的请求，从而引起OOM异常</li><li>CachedThreadPool => 允许创建的线程数为Integer.MAX_VALUE，可能会创建大量的线程，从而引起OOM异常</li></ul><p>这就是为什么禁止使用Executors去创建线程池，而是推荐自己去创建ThreadPoolExecutor的原因</p><p>OOM异常测试</p><p>理论上会出现OOM异常，必须测试一波验证之前的说法： 测试类：TaskTest.java</p><pre>public class TaskTest { public static void main(String[] args) { ExecutorService es = Executors.newCachedThreadPool(); int i = 0; while (true) { es.submit(new Task(i++)); } }}复制代码</pre><p>使用Executors创建的CachedThreadPool，往线程池中无限添加线程 在启动测试类之前先将JVM内存调整小一点，不然很容易将电脑跑出问题【别问我为什么知道，是铁憨憨甜没错了！！！】，在idea里：Run -> Edit Configurations</p><div class=pgc-img><img alt=阿里巴巴开发规约中为什么要禁用Executors创建线程池？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d85977eea69e4ef993b1cdb1ad926490><p class=pgc-img-caption></p></div><p>JVM参数说明：</p><ul><li>-Xms10M => Java Heap内存初始化值</li><li>-Xmx10M => Java Heap内存最大值</li></ul><p>运行结果：</p><pre>Exception: java.lang.OutOfMemoryError thrown from the UncaughtExceptionHandler in thread "main"Disconnected from the target VM, address: '127.0.0.1:60416', transport: 'socket'复制代码</pre><p>创建到3w多个线程的时候开始报OOM错误<br>另外两个线程池就不做测试了，测试方法一致，只是创建的线程池不一样</p><p>如何定义线程池参数</p><ul><li><strong>CPU密集型</strong> => 线程池的大小推荐为CPU数量 + 1，CPU数量可以根据Runtime.availableProcessors方法获取</li><li><strong>IO密集型</strong> => CPU数量 * CPU利用率 * (1 + 线程等待时间/线程CPU时间)</li><li><strong>混合型</strong> => 将任务分为CPU密集型和IO密集型，然后分别使用不同的线程池去处理，从而使每个线程池可以根据各自的工作负载来调整</li><li><strong>阻塞队列</strong> => 推荐使用有界队列，有界队列有助于避免资源耗尽的情况发生</li><li><strong>拒绝策略</strong> => 默认采用的是AbortPolicy拒绝策略，直接在程序中抛出RejectedExecutionException异常【因为是运行时异常，不强制catch】，这种处理方式不够优雅。处理拒绝策略有以下几种比较推荐： 在程序中捕获RejectedExecutionException异常，在捕获异常中对任务进行处理。针对默认拒绝策略 使用CallerRunsPolicy拒绝策略，该策略会将任务交给调用execute的线程执行【一般为主线程】，此时主线程将在一段时间内不能提交任何任务，从而使工作线程处理正在执行的任务。此时提交的线程将被保存在TCP队列中，TCP队列满将会影响客户端，这是一种平缓的性能降低 自定义拒绝策略，只需要实现RejectedExecutionHandler接口即可 如果任务不是特别重要，使用DiscardPolicy和DiscardOldestPolicy拒绝策略将任务丢弃也是可以的</li></ul><p>如果使用Executors的静态方法创建ThreadPoolExecutor对象，可以通过使用Semaphore对任务的执行进行限流也可以避免出现OOM异常</p><p>结论：创建线程本身是非常消耗资源的，这也是池化的主要原因。创建线程池时注意根据自己的业务场景选择合适的参数配置，合适的拒绝策略，这也是一个调优的过程。当然在使用的时候，保证系统的稳定性为大原则，宁可丢掉部分请求而通过补偿的方式保证数据的最终一致性。</p><p><br>本文来源：https://juejin.im/post/5dc41c165188257bad4d9e69</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'开发','规约','中为'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>