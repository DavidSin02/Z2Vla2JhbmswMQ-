<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一文搞定分布式文件系统FastDFS | 极客快訊</title><meta property="og:title" content="一文搞定分布式文件系统FastDFS - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/c4fc524877574c51905170a1f43effdb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9a6017f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9a6017f.html><meta property="article:published_time" content="2020-11-14T21:03:23+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:23+08:00"><meta name=Keywords content><meta name=description content="一文搞定分布式文件系统FastDFS"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f9a6017f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一文搞定分布式文件系统FastDFS</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>必须先转发，转发，转发，加“大数据java架构师”关注，关注，然后私信我“DFS”即可免费获取更多资料下载地址</strong></p><p>概述</p><p>分布式文件系统：Distributed file system, DFS，又叫做网络文件系统：Network File System。一种允许文件通过网络在多台主机上分享的文件系统，可让多机器上的多用户分享文件和存储空间。</p><p>FastDFS是用c语言编写的一款开源的分布式文件系统，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合中小文件（建议范围：4KB &lt; file_size &lt;500MB），对以文件为载体的在线服务，如相册网站、视频网站等。</p><p>FastDFS 架构</p><p>FastDFS架构包括Tracker server和Storage server。客户端请求Tracker server进行文件上传、下载，通过Tracker server调度最终由Storage server完成文件上传和下载。</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c4fc524877574c51905170a1f43effdb><p class=pgc-img-caption></p></div><p>跟踪服务器Tracker Server</p><p>主要做调度工作，起到均衡的作用；负责管理所有的 storage server和 group，每个 storage 在启动后会连接 Tracker，告知自己所属 group 等信息，并保持周期性心跳。tracker根据storage的心跳信息，建立group==>[storage serverlist]的映射表。</p><p>Tracker需要管理的元信息很少，会全部存储在内存中；另外tracker上的元信息都是由storage汇报的信息生成的，本身不需要持久化任何数据，这样使得tracker非常容易扩展，直接增加tracker机器即可扩展为tracker cluster来服务，cluster里每个tracker之间是完全对等的，所有的tracker都接受stroage的心跳信息，生成元数据信息来提供读写服务。</p><p>存储服务器Storage Server</p><p>主要提供容量和备份服务；以 group 为单位，每个 group 内可以有多台 storage server，数据互为备份。以group为单位组织存储能方便的进行应用隔离、负载均衡、副本数定制（group内storage server数量即为该group的副本数），比如将不同应用数据存到不同的group就能隔离应用数据，同时还可根据应用的访问特性来将应用分配到不同的group来做负载均衡；缺点是group的容量受单机存储容量的限制，同时当group内有机器坏掉时，数据恢复只能依赖group内地其他机器，使得恢复时间会很长。</p><p>group内每个storage的存储依赖于本地文件系统，storage可配置多个数据存储目录，比如有10块磁盘，分别挂载在/data/disk1-/data/disk10，则可将这10个目录都配置为storage的数据存储目录。storage接受到写文件请求时，会根据配置好的规则选择其中一个存储目录来存储文件。为了避免单个目录下的文件数太多，在storage第一次启动时，会在每个数据存储目录里创建2级子目录，每级256个，总共65536个文件，新写的文件会以hash的方式被路由到其中某个子目录下，然后将文件数据作为本地文件存储到该目录中。</p><p>FastDFS的存储策略</p><p>为了支持大容量，存储节点（服务器）采用了分卷（或分组）的组织方式。存储系统由一个或多个卷组成，卷与卷之间的文件是相互独立的，所有卷的文件容量累加就是整个存储系统中的文件容量。一个卷可以由一台或多台存储服务器组成，一个卷下的存储服务器中的文件都是相同的，卷中的多台存储服务器起到了冗余备份和负载均衡的作用。</p><p>在卷中增加服务器时，同步已有的文件由系统自动完成，同步完成后，系统自动将新增服务器切换到线上提供服务。当存储空间不足或即将耗尽时，可以动态添加卷。只需要增加一台或多台服务器，并将它们配置为一个新的卷，这样就扩大了存储系统的容量。</p><p>FastDFS的上传过程</p><p>FastDFS向使用者提供基本文件访问接口，比如upload、download、append、delete等，以客户端库的方式提供给用户使用。</p><p>Storage Server会定期的向Tracker Server发送自己的存储信息。当Tracker Server Cluster中的Tracker Server不止一个时，各个Tracker之间的关系是对等的，所以客户端上传时可以选择任意一个Tracker。</p><p>当Tracker收到客户端上传文件的请求时，会为该文件分配一个可以存储文件的group，当选定了group后就要决定给客户端分配group中的哪一个storage server。当分配好storage server后，客户端向storage发送写文件请求，storage将会为文件分配一个数据存储目录。然后为文件分配一个fileid，最后根据以上的信息生成文件名存储文件。</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/01f99f6d91f94b6b8b31e47feb7e2c6d><p class=pgc-img-caption></p></div><p>选择tracker server</p><p>当集群中不止一个tracker server时，由于tracker之间是完全对等的关系，客户端在upload文件时可以任意选择一个trakcer。</p><p>选择存储的group</p><p>当tracker接收到upload file的请求时，会为该文件分配一个可以存储该文件的group，支持如下选择group的规则： 1. Round robin，所有的group间轮询 2. Specified group，指定某一个确定的group 3. Load balance，剩余存储空间多多group优先</p><p>选择storage server</p><p>当选定group后，tracker会在group内选择一个storage server给客户端，支持如下选择storage的规则： 1. Round robin，在group内的所有storage间轮询 2. First server ordered by ip，按ip排序 3. First server ordered by priority，按优先级排序（优先级在storage上配置）</p><p>选择storage path</p><p>当分配好storage server后，客户端将向storage发送写文件请求，storage将会为文件分配一个数据存储目录，支持如下规则： 1. Round robin，多个存储目录间轮询 2. 剩余存储空间最多的优先</p><p>生成Fileid</p><p>选定存储目录之后，storage会为文件生一个Fileid，由storage server ip、文件创建时间、文件大小、文件crc32和一个随机数拼接而成，然后将这个二进制串进行base64编码，转换为可打印的字符串。</p><p>选择两级目录</p><p>当选定存储目录之后，storage会为文件分配一个fileid，每个存储目录下有两级256*256的子目录，storage会按文件fileid进行两次hash（猜测），路由到其中一个子目录，然后将文件以fileid为文件名存储到该子目录下。</p><p>生成文件名</p><p>当文件存储到某个子目录后，即认为该文件存储成功，接下来会为该文件生成一个文件名，文件名由group、存储目录、两级子目录、fileid、文件后缀名（由客户端指定，主要用于区分文件类型）拼接而成。</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/32867cb165b0459bb46f06c0a825cd82><p class=pgc-img-caption></p></div><p>FastDFS的文件同步</p><p>写文件时，客户端将文件写至group内一个storage server即认为写文件成功，storage server写完文件后，会由后台线程将文件同步至同group内其他的storage server。</p><p>每个storage写文件后，同时会写一份binlog，binlog里不包含文件数据，只包含文件名等元信息，这份binlog用于后台同步，storage会记录向group内其他storage同步的进度，以便重启后能接上次的进度继续同步；进度以时间戳的方式进行记录，所以最好能保证集群内所有server的时钟保持同步。</p><p>storage的同步进度会作为元数据的一部分汇报到tracker上，tracke在选择读storage的时候会以同步进度作为参考。</p><p>比如一个group内有A、B、C三个storage server，A向C同步到进度为T1 (T1以前写的文件都已经同步到B上了），B向C同步到时间戳为T2（T2 > T1)，tracker接收到这些同步进度信息时，就会进行整理，将最小的那个做为C的同步时间戳，本例中T1即为C的同步时间戳为T1（即所有T1以前写的数据都已经同步到C上了）；同理，根据上述规则，tracker会为A、B生成一个同步时间戳。</p><p>FastDFS的文件下载</p><p>客户端uploadfile成功后，会拿到一个storage生成的文件名，接下来客户端根据这个文件名即可访问到该文件。</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/010c054136f84170900a3d04086edd24><p class=pgc-img-caption></p></div><p>跟upload file一样，在downloadfile时客户端可以选择任意tracker server。tracker发送download请求给某个tracker，必须带上文件名信息，tracke从文件名中解析出文件的group、大小、创建时间等信息，然后为该请求选择一个storage用来服务读请求。</p><p>FastDFS性能方案</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ccf74326f11d4bb0a37cfd1885433b76><p class=pgc-img-caption></p></div><p>FastDFS 安装</p><p>软件包版本FastDFSv5.05libfastcommonv1.0.7</p><p>下载安装libfastcommon</p><ul><li>下载</li></ul><pre>wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz</pre><ul><li>解压</li></ul><pre>tar -xvf V1.0.7.tar.gzcd libfastcommon-1.0.7</pre><ul><li>编译、安装</li></ul><pre>./make.sh./make.sh install</pre><ul><li>创建软链接</li></ul><pre>ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.soln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.soln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.soln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so </pre><p>下载安装FastDFS</p><ul><li>下载FastDFS</li></ul><pre> wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz</pre><ul><li>解压</li></ul><pre>tar -xvf V5.05.tar.gzcd fastdfs-5.05</pre><ul><li>编译、安装</li></ul><pre>./make.sh./make.sh install</pre><p>配置 Tracker 服务</p><p>上述安装成功后，在/etc/目录下会有一个fdfs的目录，进入它。会看到三个.sample后缀的文件，这是作者给我们的示例文件，我们需要把其中的tracker.conf.sample文件改为tracker.conf配置文件并修改它：</p><pre>cp tracker.conf.sample tracker.confvi tracker.conf</pre><p>编辑tracker.conf</p><pre># 配置文件是否不生效，false 为生效disabled=false# 提供服务的端口port=22122# Tracker 数据和日志目录地址base_path=//home/data/fastdfs# HTTP 服务端口http.server_port=80</pre><p>创建tracker基础数据目录，即base_path对应的目录</p><pre>mkdir -p /home/data/fastdfs</pre><p>使用ln -s 建立软链接</p><pre>ln -s /usr/bin/fdfs_trackerd /usr/local/binln -s /usr/bin/stop.sh /usr/local/binln -s /usr/bin/restart.sh /usr/local/bin</pre><p>启动服务</p><pre>service fdfs_trackerd start</pre><p>查看监听</p><pre>netstat -unltp|grep fdfs</pre><p>如果看到22122端口正常被监听后，这时候说明Tracker服务启动成功啦！</p><p>tracker server 目录及文件结构 Tracker服务启动成功后，会在base_path下创建data、logs两个目录。目录结构如下：</p><pre>${base_path} |__data | |__storage_groups.dat：存储分组信息 | |__storage_servers.dat：存储服务器列表 |__logs | |__trackerd.log： tracker server 日志文件 </pre><p>配置 Storage 服务</p><p>进入 /etc/fdfs 目录，复制 FastDFS 存储器样例配置文件 storage.conf.sample，并重命名为 storage.conf</p><pre># cd /etc/fdfs# cp storage.conf.sample storage.conf# vi storage.conf</pre><p>编辑storage.conf</p><pre># 配置文件是否不生效，false 为生效disabled=false# 指定此 storage server 所在 组(卷)group_name=group1# storage server 服务端口port=23000# 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳)heart_beat_interval=30# Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)base_path=/home/data/fastdfs/storage# 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。store_path_count=1# 逐一配置 store_path_count 个路径，索引号基于 0。# 如果不配置 store_path0，那它就和 base_path 对应的路径一样。store_path0=/home/data/fastdfs/storage# FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 # 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。subdir_count_per_path=256# tracker_server 的列表 ，会主动连接 tracker_server# 有多个 tracker server 时，每个 tracker server 写一行tracker_server=192.168.1.190:22122# 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。sync_start_time=00:00sync_end_time=23:59</pre><p>使用ln -s 建立软链接</p><pre>ln -s /usr/bin/fdfs_storaged /usr/local/bin</pre><p>启动服务</p><pre>service fdfs_storaged start</pre><p>查看监听</p><pre>netstat -unltp|grep fdfs</pre><p>启动Storage前确保Tracker是启动的。初次启动成功，会在 /home/data/fastdfs/storage 目录下创建 data、 logs 两个目录。如果看到23000端口正常被监听后，这时候说明Storage服务启动成功啦！</p><p>查看Storage和Tracker是否在通信</p><pre>/usr/bin/fdfs_monitor /etc/fdfs/storage.conf</pre><p>FastDFS 配置 Nginx 模块</p><p>软件包版本openrestyv1.13.6.1fastdfs-nginx-modulev1.1.6</p><p>FastDFS 通过 Tracker 服务器，将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进行文件复制，有同步延迟的问题。</p><p>假设 Tracker 服务器将文件上传到了 192.168.1.190，上传成功后文件 ID已经返回给客户端。此时 FastDFS 存储集群机制会将这个文件同步到同组存192.168.1.190，在文件还没有复制完成的情况下，客户端如果用这个文件 ID 在 192.168.1.190 上取文件,就会出现文件无法访问的错误。而 fastdfs-nginx-module 可以重定向文件链接到源服务器取文件，避免客户端由于复制延迟导致的文件无法访问错误。</p><p>下载 安装 Nginx 和 fastdfs-nginx-module：</p><p>推荐您使用yum安装以下的开发库:</p><pre>yum install readline-devel pcre-devel openssl-devel -y</pre><p>下载最新版本并解压：</p><pre>wget https://openresty.org/download/openresty-1.13.6.1.tar.gztar -xvf openresty-1.13.6.1.tar.gzwget https://github.com/happyfish100/fastdfs-nginx-module/archive/master.zipunzip master.zip</pre><p>配置 nginx 安装，加入fastdfs-nginx-module模块：</p><pre>./configure --add-module=../fastdfs-nginx-module-master/src/</pre><p>编译、安装：</p><pre>make &amp;&amp; make install</pre><p>查看Nginx的模块：</p><pre>/usr/local/openresty/nginx/sbin/nginx -v</pre><p>有下面这个就说明添加模块成功</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a79861202b6542259f8e45e474232e2b><p class=pgc-img-caption></p></div><p>复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改：</p><pre>cp /fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/# 连接超时时间connect_timeout=10# Tracker Servertracker_server=192.168.1.190:22122# StorageServer 默认端口storage_server_port=23000# 如果文件ID的uri中包含/group**，则要设置为trueurl_have_group_name = true# Storage 配置的store_path0路径，必须和storage.conf中的一致store_path0=/home/data/fastdfs/storage</pre><p>复制 FastDFS 的部分配置文件到/etc/fdfs 目录：</p><pre>cp /fastdfs-nginx-module/src/http.conf /etc/fdfs/cp /fastdfs-nginx-module/src/mime.types /etc/fdfs/</pre><p>配置nginx，修改nginx.conf：</p><pre>location ~/group([0-9])/M00 { ngx_fastdfs_module;}</pre><p>启动Nginx：</p><pre>[root@iz2ze7tgu9zb2gr6av1tysz sbin]# ./nginxngx_http_fastdfs_set pid=9236</pre><p>测试上传：</p><pre>[root@iz2ze7tgu9zb2gr6av1tysz fdfs]# /usr/bin/fdfs_upload_file /etc/fdfs/client.conf /etc/fdfs/4.jpggroup1/M00/00/00/rBD8EFqVACuAI9mcAAC_ornlYSU088.jpg</pre><p>部署结构图：</p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee55bfdb87f6471498455185dfd98de9><p class=pgc-img-caption></p></div><p>JAVA 客户端集成</p><p>pom.xml引入：</p><pre>&lt;!-- fastdfs --&gt;&lt;dependency&gt;	&lt;groupId&gt;org.csource&lt;/groupId&gt;	&lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt;	&lt;version&gt;1.27&lt;/version&gt;&lt;/dependency&gt;</pre><p>fdfs_client.conf配置：</p><pre>#连接tracker服务器超时时长connect_timeout = 2 #socket连接超时时长network_timeout = 30#文件内容编码 charset = UTF-8 #tracker服务器端口http.tracker_http_port = 8080http.anti_steal_token = nohttp.secret_key = FastDFS1234567890#tracker服务器IP和端口（可以写多个）tracker_server = 192.168.1.190:22122 </pre><p>FastDFSClient上传类：</p><pre>public class FastDFSClient{	private static final String CONFIG_FILENAME = "D:\\itstyle\\src\\main\\resources\\fdfs_client.conf";	private static final String GROUP_NAME = "market1";	private TrackerClient trackerClient = null; private TrackerServer trackerServer = null; private StorageServer storageServer = null; private StorageClient storageClient = null; static{ 	try {			ClientGlobal.init(CONFIG_FILENAME);		} catch (IOException e) {			e.printStackTrace();		} catch (MyException e) {			e.printStackTrace();		} } public FastDFSClient() throws Exception {	 trackerClient = new TrackerClient(ClientGlobal.g_tracker_group);	 trackerServer = trackerClient.getConnection();	 storageServer = trackerClient.getStoreStorage(trackerServer);;	 storageClient = new StorageClient(trackerServer, storageServer); } /** * 上传文件 * @param file 文件对象 * @param fileName 文件名 * @return */ public String[] uploadFile(File file, String fileName) { return uploadFile(file,fileName,null); } /** * 上传文件 * @param file 文件对象 * @param fileName 文件名 * @param metaList 文件元数据 * @return */ public String[] uploadFile(File file, String fileName, Map&lt;String,String&gt; metaList) { try { byte[] buff = IOUtils.toByteArray(new FileInputStream(file)); NameValuePair[] nameValuePairs = null; if (metaList != null) { nameValuePairs = new NameValuePair[metaList.size()]; int index = 0; for (Iterator&lt;Map.Entry&lt;String,String&gt;&gt; iterator = metaList.entrySet().iterator(); iterator.hasNext();) { Map.Entry&lt;String,String&gt; entry = iterator.next(); String name = entry.getKey(); String value = entry.getValue(); nameValuePairs[index++] = new NameValuePair(name,value); } } return storageClient.upload_file(GROUP_NAME,buff,fileName,nameValuePairs); } catch (Exception e) { e.printStackTrace(); } return null; } /** * 获取文件元数据 * @param fileId 文件ID * @return */ public Map&lt;String,String&gt; getFileMetadata(String groupname,String fileId) { try { NameValuePair[] metaList = storageClient.get_metadata(groupname,fileId); if (metaList != null) { HashMap&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); for (NameValuePair metaItem : metaList) { map.put(metaItem.getName(),metaItem.getValue()); } return map; } } catch (Exception e) { e.printStackTrace(); } return null; } /** * 删除文件 * @param fileId 文件ID * @return 删除失败返回-1，否则返回0 */ public int deleteFile(String groupname,String fileId) { try { return storageClient.delete_file(groupname,fileId); } catch (Exception e) { e.printStackTrace(); } return -1; } /** * 下载文件 * @param fileId 文件ID（上传文件成功后返回的ID） * @param outFile 文件下载保存位置 * @return */ public int downloadFile(String groupName,String fileId, File outFile) { FileOutputStream fos = null; try { byte[] content = storageClient.download_file(groupName,fileId); fos = new FileOutputStream(outFile); InputStream ips = new ByteArrayInputStream(content);  IOUtils.copy(ips,fos); return 0; } catch (Exception e) { e.printStackTrace(); } finally { if (fos != null) { try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } return -1; } public static void main(String[] args) throws Exception { 	FastDFSClient client = new FastDFSClient(); 	File file = new File("D:\\23456.png"); String[] result = client.uploadFile(file, "png"); System.out.println(result.length); System.out.println(result[0]); System.out.println(result[1]); }}</pre><p>执行main方法测试返回：</p><pre>2group1M00/00/00/rBD8EFqTrNyAWyAkAAKCRJfpzAQ227.png</pre><p><strong>必须先转发，转发，转发，加“大数据java架构师”关注，关注，然后私信我“DFS”即可免费获取更多资料下载地址</strong></p><div class=pgc-img><img alt=一文搞定分布式文件系统FastDFS onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b061b0d4ad4f4b04880908202540b791><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'系统','FastDFS','搞定'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>