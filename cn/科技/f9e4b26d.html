<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java8并发教程 - Thread和Executors | 极客快訊</title><meta property="og:title" content="Java8并发教程 - Thread和Executors - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a5ff673dd9df46ac97966318964a561b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/f9e4b26d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/f9e4b26d.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="Java8并发教程 - Thread和Executors"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/f9e4b26d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java8并发教程 - Thread和Executors</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>Thread and Runnable</p><p>现代操作系统,都支持通过进程和线程来实现并发.进程是程序的运行时的实例.程序是静态的,而进程是动态的.进程与进程之间,相互独立.例如,如果你运行一个Java程序,操作系统就会生成一个和其他进程并行运行的进程.而在进程内部,我们又可以通过使用线程来并发的执行操作,并充分利用现代机器多核的优势.</p><p>Java从JDK1.0开始,便开始支持线程了.我们在启动一个线程之前,必须告诉它要它执行什么操作.我们可以通过实现** Runnable**接口来告诉线程它要执行的操作,如下图所示:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5ff673dd9df46ac97966318964a561b></div><p>我们通过lambda表达式来实现了** Runnable<strong>接口.我们让它做的事是,将线程的名称输出到控制台.在我们启动线程之前,我们先直接启动</strong> Runnable**,看看会发生什么.</p><p>结果应该是这样:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4db9da976f6149c69bd62c4375816fc6></div><p>或者是这样:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cbc60f1cae0748a68cc90272b3b2d037></div><p>因为新创建的线程和主线程现在是并行运行,所以我们并不能确定最后的那两行输出的顺序.而且因为这种顺序的不确定性,导致并发编程比单线程编程要困难的多.</p><p>我们可以让线程暂停一段时间.我们一般用这来模拟需要执行很长时间的任务的线程.</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0787e5f8efe43879887cad4f0bbd3de></div><p>如果你运行上面的代码,你会看到,第一条输出和第二条输出中间,间隔了一秒. ** TimeUnit**是一个很有用的枚举,它简化了对时间单元的处理.</p><p>使用Thread类来编程,很容易产生错误.所以,Java在2004年发布的JAVA5引入了** Concurrency API<strong>.这些API位于</strong> java.util.concurrent<strong>包中,并且包含很多有用的类.从那之后,这些</strong> Concurrency API**就包含在每个Java版本中了.甚至在Java8中,又为并发引入了新的类和方法.</p><p>下面我们来看一下** Concurrency API**中,最重要的那部分- executor services.</p><p>Executors</p><p>** Concurrency API<strong>打算用</strong> ExecutorService<strong>来取代</strong> Thread<strong>.Executor能够运行异步任务,并且管理着一个线程池.线程池中的线程都可以被复用.所以我们只需要通过一个</strong> executor service**,就能运行很多的需要并发执行的任务.</p><p>下面这个例子演示了如何使用** ExecutorService**:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cff8f49cfe704051b28797fbd325dfad></div><p>** Executors<strong>是一个工厂类,我们可以用它来创建各种各样的</strong> Executor Service<strong>.这里创建了一个只有一个线程的</strong> Executor Service**.</p><p>输出的结果很容易理解.你可能会注意到,这个程序一直在运行,一直都不停止.实际上,我们需要手动停掉** Executor**,否则它会一直运行,来监听新的任务.</p><p>** ExecutorService<strong>提供了两个方法,让我们停掉</strong> Executor<strong>.一个是</strong> shutdown()<strong>,它会等待当前正在运行的任务停止.另一个是</strong> shutdownNow()<strong>,它会中断全部的正在运行的任务,并让</strong> Executor**立即停止.</p><p>我们使用如下图所示的这种方式,来停掉** Executor**更好:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/702976a8784842f9b9243a7436c76337></div><p>** Executor**会等待一段时间,让正在运行的任务运行完.超过五秒之后,就停掉全部的正在运行的task.</p><p>Callables和Futures</p><p>除了** Runnable<strong>,</strong> Executor<strong>还接受</strong> Callable<strong>作为参数.</strong> Callable<strong>和</strong> Runnable<strong>的区别在于,</strong> Callable**是有返回值的.</p><p>下图中的** Callable**,会先暂停一秒钟,然后输出一个整数:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/997f11e1ba9945b89e64ecd11311b8ca></div><p>通过** Callable<strong>来创建</strong> Executor<strong>的方式,和通过</strong> Runnable<strong>来创建</strong> Executor<strong>的方式一样.那么我们如何来获取</strong> Callable<strong>的返回值呢?我们可以通过</strong> Future<strong>对象来获取.因为</strong> submit()<strong>方法是非阻塞的,它不会等待任务完成,然后直接返回任务的返回值.而是通过返回一个</strong> Future<strong>对象,其中会封装任务的返回值.等任务完成后,我们就能通过这个</strong> Future<strong>对象,来获取</strong> Callable**的返回值.</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a150d1f3bcd44b909c43e359e40c5c6e></div><p>在通过** submit()<strong>方法提交完任务之后,我们通过</strong> isDone()<strong>方法,来查看</strong> Future**对象是否完成.这里当然不会,因为线程会在返回值之前,先暂停一秒.</p><p>调用** get()<strong>方法,会阻塞当前线程,直到</strong> callable<strong>执行完毕.现在</strong> Future**对象完成了,我们可以在控制台中,看到如下结果:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/bc985709719f4aaf9d95f77fd9d2a7a7></div><p>** Future<strong>对象和</strong> Executor Service<strong>之间,有轻微的耦合.需要注意的是,如果你在</strong> Future<strong>完成之前,结束</strong> Executor**,那么它会抛出异常.</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e9a6f84a035847a084c79551e97673a3></div><p>你可能已经注意到了,这里我们是通过** newFixedThreadPool(1)<strong>方法,来创建的</strong> ExecutorService<strong>,它会创建一个只有一个线程的线程池.其等价与</strong> newSingleThreadExecutor**.但是我们可以通过调整其参数来改变该线程池的大小.</p><p>Timeouts</p><p>** future.get()<strong>方法,会阻塞当前线程,直到</strong> Callable<strong>执行完毕.那如果</strong>Callable**执行的是一个死循环呢?这会导致我们的程序失去响应.我们可以通过设置超时时间,来解决这个问题:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5fde1cc38d574c92b76034b6c9c7cdd3></div><p>上面的代码会抛出** TimeoutException**:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5abf8ce5937b4a9d9f5d26096c9ce872></div><p>你应该知道为何抛出这个异常:我们设置其最多等待1秒,但是** Callable**执行却需要两秒.</p><p>InvokeAll</p><p>** Executor Service<strong>支持通过调用</strong> invokeAll()<strong>方法,来传入多个</strong> Callable<strong>,实现一次执行多个任务的目的.这个方法,其参数是</strong> Callable<strong>的集合,其返回值,是</strong> Future**对象的集合.</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a89bdcc005a54d1980e54200ff6f1ddf></div><p>InvokeAny</p><p>另一个一次执行多个任务的方法是** invokeAny()<strong>方法,这个方法和</strong> invokeAll()<strong>方法,有一些不同.这个方法不会返回</strong> Future<strong>对象,它会一直等到第一个</strong> Callable**运行结束,然后返回其返回值.</p><p>我们使用下面的帮助类,来生成** Callable**.</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba4dc26625904be8b981fd6c9b3deb57></div><p>然后执行下面的代码,它会返回需要执行的时间最短的任务的返回值:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a8e000470f64559a37b96875b7875ad></div><p>上面的代码中,通过** newWorkStealingPool()<strong>来创建了另一种</strong> ExecutorService<strong>.这种</strong> ExecutorService**,其线程池中的线程的数量,默认为我们的机器的核数.</p><p>Scheduled Executors</p><p>我们现在已经知道如何来通过** Executor Service**启动线程了.那如果有一个任务,需要重复运行很多次,或者定时执行,那我们该怎么办呢?</p><p>我们可以使用** Scheduled Executors**.</p><p>下面的代码,会在三秒后,启动一个线程来执行任务:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bdb1fb8ae5cd4f0aae218ad36bf68f55></div><p>** schedule()<strong>方法,会返回一个</strong> ScheduleFuture<strong>,相对于普通的</strong> Future<strong>来说,它增加了一个</strong> getDelay**方法,来查看还剩多少时间来启动线程执行任务.</p><p>** ScheduleExecutorService<strong>提供了</strong> scheduleAtFixedRate()<strong>和</strong> scheduleWithFixedDelay()**这两个方法.前者会按一定的频率来执行任务.下面的例子会每秒执行一次任务:</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed7448d4a7a3436cb65b81ada1b61fe5></div><p>** scheduleAtFixedRate()**方法指定的间隔,不包括任务执行的时间.所以,如果你让那些需要两秒来执行的任务,每隔一秒执行一次,线程池会很快达到容量上限.</p><p>针对上面的那种情况,你应当使用** scheduleWithFixedDelay()**方法.这个方法的参数,是一个任务完成后,再过多久才执行下一个任务.</p><div class=pgc-img><img alt="Java8并发教程 - Thread和Executors" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8e68d87ec2974ee0a42c42ba6a9ff1f6></div><p>作者：AlstonWilliams</p><p>链接：https://www.jianshu.com/p/590cd048c11c</p><p>来源：简书</p><p>简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Java8','Thread','Executors'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>