<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>延迟任务调度系统（技术选型与设计） | 极客快訊</title><meta property="og:title" content="延迟任务调度系统（技术选型与设计） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1540896640003cd27a1bb00"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fb6f75b4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fb6f75b4.html><meta property="article:published_time" content="2020-10-29T21:09:57+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:57+08:00"><meta name=Keywords content><meta name=description content="延迟任务调度系统（技术选型与设计）"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/fb6f75b4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>延迟任务调度系统（技术选型与设计）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1>延迟任务调度系统（技术选型与设计）</h1><ul><li class=ql-indent-1>延迟任务调度系统（技术选型与设计）延迟任务的场景是？</li><li class=ql-indent-1>现有的解决方案是？</li><li class=ql-indent-1>存在的问题是什么？</li><li class=ql-indent-1>希望达到的目标是？</li><li class=ql-indent-3>可以实现的方案有？RabbitMQ实现通过死信和死信路由实现</li><li class=ql-indent-2>通过延迟消息插件来实现</li><li class=ql-indent-2>Redis实现</li><li class=ql-indent-2>DelayQueue实现</li><li class=ql-indent-3>时间轮实现单表时间轮</li><li class=ql-indent-2>分层时间轮</li><li class=ql-indent-2>之前的设计（DB/DelayQueue/ZooKeeper）</li><li class=ql-indent-1>另一种方案（DB/DelayQueue/ZooKeeper/MQ</li></ul><p>延迟任务的场景是？</p><ul><li>习题考试截止前3天，给未提交用户发送消息</li><li>学习项目开课前2小时，给参与用户发送通知</li><li>问卷开始收集时，才对用户可见</li><li>问卷结束收集时，触发一些操作</li><li>指定时间发布课件</li><li>课程结束时，开始计算用户结业信息</li><li>直播时间到了，给用户发送消息</li><li>用户下单后，30分钟内未付款，关闭订单</li><li>用户付款后，24小时内未发货，提示发货</li><li>用户打车后，48小时后自动评价为5星</li><li>这类业务的特点是：延迟执行。一种比较简单的方法是使用后台线程扫描符合条件的业务数据，逐一处理。 这种方法扫描间隔时间不好设置，间隔时间过大影响精确度，过小则影响效率和性能。</li></ul><blockquote></blockquote><p>现有的解决方案是？</p><ul><li>通过linux的crontab触发定时任务</li><li>扫描业务表，筛选出符合条件的数据对其进行操作</li></ul><p>存在的问题是什么？</p><ul><li>由于每种类型的任务都设有扫描间隔，任务不能精确处理</li><li>扫描业务库，影响业务正常操作</li><li>任务的执行过于密集，容易导致服务器间隔性压力</li><li>存在系统单点，触发定时调度的服务挂了，所有任务都不会执行</li><li>系统不具容错能力，一旦错过了，任务就不会再被执行</li><li>没有统一的视图来查看任务的执行情况</li><li>没有告警来提示失败的任务</li></ul><p>希望达到的目标是？</p><ul><li>精确性(可在指定时间触发任务处理)</li><li>通用性</li><li>高性能(集群能力不少于1000TPS)</li><li>高可用(支持多实例部署)</li><li>可伸缩(增加和减少服务时，任务会重新分配)</li><li>可重试(任务失败可重试)</li><li>多协议(支持http\dubbo调用)</li><li>可管理(业务使用方可修改、删除任务)</li><li>能告警(失败次数达到阈值可触发告警)</li><li>统一视图(方便查看任务执行情况,可手动干预任务执行)</li></ul><p>下面所讨论技术方案的前提是精确触发，所以我们不讨论目前业界的一些分布式调度系统如：elastic-job,xxl-job,tbschedule等, 这些系统解决不了延迟任务精确触发问题。</p><p>可以实现的方案有？</p><p>RabbitMQ实现</p><p>通过死信和死信路由实现</p><p><strong>原理如下:</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540896640003cd27a1bb00><p class=pgc-img-caption></p></div><p><strong>何为死信:</strong></p><ul><li>消息被拒绝</li><li>消息已过期</li><li>队列达到最大长度</li></ul><p>RabbitMQ可以对队列和消息设置x-message-tt、expiration来控制消息的存活时间，如果超时，消息变为死信。</p><p><strong>何为死信路由:</strong></p><p>RabbitMQ可以对队列设置x-dead-letter-exchange和x-dead-letter-routing-key两个参数。</p><p>当消息在一个队列中变成死信后会按这两个参数路由，消息就可以重新被消费。</p><p><strong>实例操作:</strong></p><ol><li>创建延迟队列(设置死信路由)</li><li>创建就绪队列</li><li>创建死信路由</li><li>绑定死信路由与就绪队列</li><li>发送延迟消息</li><li>消息过期后进入就绪队列</li></ol><p><strong>优点：</strong></p><ul><li>高效，可以利用RabbitMQ的分布式特性轻易进行横向扩展，且支持持久化</li></ul><p><strong>缺点：</strong></p><ul><li>不支持对已发送的消息进行管理</li><li>一个消息比在同一队列中的其他消息提前过期，提前过期的消息也不会优先进入死信队列。</li></ul><p>所以需要确保业务上每个任务的延迟时间是一致的。如果有不同延时的任务，需要为每种不同延迟的任务单独创建消息队列，缺乏灵活性。</p><p>通过延迟消息插件来实现</p><p><strong>原理如下：</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15408966404587109c904dc><p class=pgc-img-caption></p></div><p><strong>核心代码流程：</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1540896640205e9b09fb2a8><p class=pgc-img-caption></p></div><p>其原理是延迟消息会被保存到Mnesia表，在Exchange中根据每个message头设置的延迟时间x-delay，消息过期后才路由到对应队列。</p><p><strong>实例操作:</strong></p><ol><li>下载插件</li><li><u>https://bintray.com/rabbitmq/community-plugins/download_file?file_path=rabbitmq_delayed_message_exchange-0.0.1.ez</u></li><li>安装插件</li></ol><pre> docker-compose.xml(将插件安装到容器中) version: '2' services: rabbitmq: hostname: rabbitmq image: rabbitmq:3.6.8-management mem_limit: 200m ports: - "5672:5672" - "15672:15672" volumes: - ~/dockermapping/rabbitmq/lib:/var/lib/rabbitmq/ - /Users/oldlu/workspace/document/docker-compose/rabbitmq/rabbitmq_delayed_message_exchange-0.0.1.ez:/usr/lib/rabbitmq/lib/rabbitmq_server-3.6.8/plugins/rabbitmq_delayed_message_exchange-0.0.1.ez 启用插件 rabbitmq-plugins enable rabbitmq_delayed_message_exchange</pre><ol><li>创建类型为x-delayed-message的路由</li><li>创建就绪队列</li><li>绑定队列和路由</li><li>发布延迟消息(设置x-delay=延迟的毫秒数)</li></ol><p><strong>源码分析</strong></p><p><u>https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/blob/master/src/rabbit_delayed_message.erl</u></p><pre>核心函数消息入队：internal_delay_message启动Timer：maybe_delay_first消息处理：handle_info</pre><p><strong>优点：</strong></p><ul><li>一个消息比其他消息提前过期，提前过期的消息会被提前路由到队列，不需要为不同延迟的消息创建单独的消息队列。</li></ul><p><strong>缺点：</strong></p><ul><li>不支持对已发送的消息进行管理</li><li>集群中只有一个数据副本(保存在当前节点下的Mnesia表中)，如果节点不可用或关闭插件会丢失消息。</li><li>目前该插件只支持disk节点，不支持RAM节点</li><li>性能比原生差一点(普通的Exchange收到消息后直接路由到队列，而延迟队列需要判断消息是否过期，未过期的需要保存在表中，时间到了再捞出来路由)</li></ul><p>Redis实现</p><p>有序集合(Sorted Set)是Redis提供的一种数据结构，具有set和hash的特点。</p><p>其中每个元素都关联一个score，并以这个score来排序。</p><p>其内部实现用到了两个数据结构:hash table和 skip list(跳跃表)</p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1540896640031c28fb364f5><p class=pgc-img-caption></p></div><p><strong>skip list的特点</strong></p><ul><li>由很多层结构组成，level是通过一定的概率随机产生的</li><li>每一层都是一个有序的链表，默认是升序</li><li>最底层的链表包含所有元素</li><li>如果一个元素出现在Level i的链表中，则它在Level i之下的链表也都会出现</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素</li><li>插入和删除的时间复杂度是O(logn)，当达到了一定的数据规模之后，它的效率与红黑树差不多</li></ul><p><strong>主要命令</strong></p><ul><li>zadd:向Sorted Set中添加元素</li><li>zrem:删除Sorted Set中的指定元素</li><li>zrange:按照从小到大的顺序返回指定区间内的元素</li></ul><p><strong>实现延迟队列</strong></p><ol><li>将延迟任务加到Sorted Set，将延迟时间设为score</li><li>启动一个线程不断判断Sorted Set中第一个元素的score是否大于当前时间</li><li>如果大于，从Sorted Set中移除任务并添加到执行队列中</li><li>如果小于，进行短暂休眠后重试</li></ol><p><strong>实例操作</strong></p><pre>root@redis:/usr/local/bin# redis-cli127.0.0.1:6379&gt; zadd delayqueue 1 task1(integer) 1127.0.0.1:6379&gt; zadd delayqueue 2 task2(integer) 1127.0.0.1:6379&gt; zadd delayqueue 4 task4(integer) 1127.0.0.1:6379&gt; zadd delayqueue 3 task3(integer) 1127.0.0.1:6379&gt;127.0.0.1:6379&gt; zrange delayqueue 0 0 withscores1) "task1"</pre><p><strong>优点：</strong></p><ul><li>实现简单</li><li>任务可管理（可删除、修改任务）</li></ul><p><strong>缺点：</strong></p><ul><li>需要有短轮询线程不断判断第一个元素是否过期，造成CPU空耗</li><li>分布式场景中，容易引起多个节点读取到相同任务</li></ul><p>DelayQueue实现</p><p>DelayQueue是一个使用优先队列实现的BlockingQueue，优先队列比较的是时间，内部存储的是实现Delayed接口的对象。 只有在对象过期后才能从队列中获取对象。</p><p><strong>内部结构</strong></p><ul><li>可重入锁</li><li>用于根据delay时间排序的优先级队列</li><li>用于优化阻塞通知的线程leader</li><li>用于实现阻塞和通知的Condition对象</li></ul><p><strong>Leader/Followers</strong></p><p>Leader/Followers是多个工作线程轮流进行事件监听、分发、处理的一种模式。 该模式最大的优点在于，它是自己监听事件并处理客户请求，从接收到处理都是在同一线程中完成， 所以不需要在线程之间传递数据，解决线程频繁切换带来的开销。</p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540896640181dc91e1fdc1><p class=pgc-img-caption></p></div><p>该模式工作的任何时间点，只有一个线程成为Leader ，负责事件监听，而其他线程都是Follower，在休眠中等待成为Leader。 该模式的工作线程存在三种状态，工作线程同一时间只能处于一种状态，这三种状态为：</p><ul><li>Leading:线程处于领导者状态，负责事件监听。Leader监听到事件后，有两种处理方式:</li><li class=ql-indent-1>可以转移至Processing状态，自己处理该事件，并调用方法推选新领导者。</li><li class=ql-indent-1>也可以指定其他Follower来处理事件，此时Leader状态不变。</li><li>Processing:线程正在处理事件，处理完事件如果当前线程集中没有领导者，它将成为新领导者，否则转为追随者。</li><li>Following:线程处于追随者状态，等待成为新的领导者也可能被领导者指定来处理新的事件。</li></ul><p><strong>核心源码分析：</strong></p><ul><li>入队</li></ul><pre>public boolean offer(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { q.offer(e); if (q.peek() == e) {//入队对象延迟时间是队列中最短的 leader = null;//重置leader available.signal();//唤醒一个线程去监听新加入的对象 } return true; } finally { lock.unlock(); }}</pre><ul><li>出队</li></ul><pre>public E take() throws InterruptedException { final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try { for (;;) { E first = q.peek(); if (first == null) available.await();//队列为空，无限等待 else { long delay = first.getDelay(TimeUnit.NANOSECONDS); if (delay &lt;= 0)//延迟时间已过，直接返回 return q.poll(); else if (leader != null)//已有leader在监听了，无限等待 available.await(); else { Thread thisThread = Thread.currentThread(); leader = thisThread;//当前线程成为leader try { available.awaitNanos(delay);//在delay纳秒后唤醒 } finally { if (leader == thisThread)// 入队一个最小延迟时间的对象时leader会被清空 leader = null; } } } } } finally { if (leader == null &amp;&amp; q.peek() != null)//leader不存在且队列不为空，唤醒一个follower去成为leader去监听 available.signal(); lock.unlock(); }}</pre><p><strong>优点：</strong></p><ul><li>效率高，任务触发时间延迟低</li></ul><p><strong>缺点：</strong></p><ul><li>数据是保存在内存，需要自己实现持久化</li><li>不具备分布式能力，需要自己实现高可用</li></ul><p>时间轮实现</p><p>时间轮是一种环形的数据结构，分成多个格。</p><p>每个格代表一段时间，时间越短，精度越高。</p><p>每个格上用一个链表保存在该格的过期任务。</p><p>指针随着时间一格一格转动，并执行相应格子中的到期任务。</p><p><strong>名词解释：</strong></p><ul><li>时间格：环形结构中用于存放延迟任务的区块</li><li>指针：指向当前操作的时间格，代表当前时间</li><li>格数：时间轮中时间格的个数</li><li>间隔：每个时间格之间的间隔，代表时间轮能达到的精度</li><li>总间隔：当前时间轮总间隔，等于格数*间隔，代表时间轮能表达的时间范围</li></ul><p>单表时间轮</p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/154089664001764d68c70a2><p class=pgc-img-caption></p></div><p>以上图为例，假设一个格子是1秒，则整个时间轮能表示的时间段为8s， 如果当前指针指向2，此时需要调度一个3s后执行的任务，需要放到第5个格子(2+3)中，指针再转3次就可以执行了。</p><p><strong>单表时间轮存在的问题是：</strong></p><p>格子的数量有限,所能代表的时间有限,当要存放一个10s后到期的任务怎么办？这会引起时间轮溢出。</p><p>有个办法是把轮次信息也保存到时间格链表的任务上。</p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540896640291c2b3293a96><p class=pgc-img-caption></p></div><p>如果任务要在10s后执行，算出轮次10/8 round等1，格子10%8等于2，所以放入第二格。</p><p>检查过期任务时应当只执行round为0的任务，链表中其他任务的round减1。</p><p><strong>带轮次单表时间轮存在的问题是：</strong></p><p>如果任务的时间跨度很大，数量很大，单层时间轮会造成任务的round很大，单个格子的链表很长，每次检查的量很大，会做很多无效的检查。怎么办?</p><p>分层时间轮</p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15408966403516efba1d379><p class=pgc-img-caption></p></div><p>过期任务一定是在底层轮中被执行的，其他时间轮中的任务在接近过期时会不断的降级进入低一层的时间轮中。</p><p>分层时间轮中每个轮都有自己的格数和间隔设置，当最低层的时间轮转一轮时，高一层的时间轮就转一个格子。</p><p>分层时间轮大大增加了可表示的时间范围，同时减少了空间占用。</p><p><strong>举个例子：</strong></p><p>上图的分层时间轮可表达8 <em>8</em> 8=512s的时间范围，如果用单表时间轮可能需要512个格子， 而分层时间轮只要8+8+8=24个格子，如果要设计一个时间范围是1天的分层时间轮，三个轮的格子分别用24、60、60即可。</p><p><strong>工作原理：</strong></p><p>时间轮指针转动有两种方式：</p><ul><li>根据自己的间隔转动（秒钟轮1秒转1格；分钟轮1分钟转1格；时钟轮1小时转1格）</li><li>通过下层时间轮推动（秒钟轮转1圈，分钟轮转1格；分钟轮转1圈，时钟轮转1格）</li></ul><p>指针转到特定格子时有两种处理方式：</p><ul><li>如果是底层轮，指针指向格子中链表上的元素均表示过期</li><li>如果是其他轮，将格子上的任务移动到精度细一级的时间轮上，比如时钟轮的任务移动到分钟轮上</li></ul><p><strong>举个例子：</strong></p><ul><li>添加1个5s后执行的任务</li></ul><ol><li class=ql-indent-1>算出任务应该放在秒钟轮的第5个格子</li><li class=ql-indent-1>在秒钟轮指针进行5次转动后任务会被执行</li></ol><ul><li>添加一个50s后执行的任务</li></ul><ol><li class=ql-indent-1>算出该任务的延迟时间已经溢出秒钟轮</li><li class=ql-indent-1>50/8=6,所以该任务会被保存在分钟轮的第6个格子</li><li class=ql-indent-1>在秒钟轮走了6圈(6*8s=48s)之后，分钟轮的指针指向第6个格子</li><li class=ql-indent-1>此时该格子中的任务会被降级到秒钟轮，并根据50%8=2，任务会被移动到秒钟轮的第2个格子</li><li class=ql-indent-1>在秒钟轮指针又进行2次转动后(50s)任务会被执行</li></ol><ul><li>添加一个250s后执行的任务</li></ul><ol><li class=ql-indent-1>算出该任务的延迟时间已经溢出分钟轮</li><li class=ql-indent-1>250/8/8=3,所以该任务会被保存在时钟轮的第3个格子</li><li class=ql-indent-1>在分钟轮走了3圈(3*64s=192s)之后，时钟轮的指针指向第3个格子</li><li class=ql-indent-1>此时该格子中的任务会被降级到分钟轮，并根据(250-192)/8=7，任务会被移动到分钟轮的第7个格子</li><li class=ql-indent-1>在秒钟轮走了7圈(7*8s=56s)之后，分钟轮的指针指向第7个格子</li><li class=ql-indent-1>此时该格子中的任务会被降级到秒钟轮，并根据(250-192-56)=2，任务会被移动到秒钟轮的第2个格子</li><li class=ql-indent-1>在秒钟轮指针又进行2次转动后任务会被执行</li></ol><p><strong>优点：</strong></p><ul><li>高性能（插入任务、删除任务的时间复杂度均为O(1)，DelayQueue由于涉及到排序，插入和移除的复杂度是O(logn)）</li></ul><p><strong>缺点：</strong></p><ul><li>数据是保存在内存，需要自己实现持久化</li><li>不具备分布式能力，需要自己实现高可用</li><li>延迟任务过期时间受时间轮总间隔限制</li></ul><p>对于超出范围的任务可放在一个缓冲区中(可用队列、redis或数据库实现)，等最高时间轮转到下一格子就从缓冲中取出符合范围的任务落到时间轮中。</p><p><strong>比如：</strong></p><ul><li>添加一个600s后执行的任务A</li></ul><ol><li class=ql-indent-1>算出该任务的延迟时间已经溢出时间轮</li><li class=ql-indent-1>所以任务被保存到缓冲队列中</li><li class=ql-indent-1>在时钟轮走了1格之后，会从缓冲队列中取满足范围的任务落到时间轮中</li><li class=ql-indent-1>缓冲队列中的所有任务延迟时间均需减去64s，任务A减去64s后是536s，依然大于时间轮范围，所以不会被移出队列</li><li class=ql-indent-1>在时钟轮又走了1格之后，任务A减去64s是536-64=472s，在时间轮范围内，会被落入时钟轮</li></ol><p>之前的设计（DB/DelayQueue/ZooKeeper）</p><p>调度系统提供任务操作接口供业务系统提交任务、取消任务、反馈执行结果等。</p><p>针对dubbo调用,将任务抽象成JobCallbackService接口，由业务系统实现并注册成服务。</p><p><strong>整体架构</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540896641001a9fd8dd8c8><p class=pgc-img-caption></p></div><p><strong>数据库：</strong></p><ul><li>负责保存所有的任务数据</li></ul><p><strong>内存队列：</strong></p><ul><li>实际为DelayQueue，延迟任务精确触发的机制由它保证</li><li>只存储未来N分钟内过期且最多1000个任务</li></ul><p><strong>ZooKeeper：</strong></p><ul><li>管理整个调度集群</li><li>存储调度节点信息</li><li>存储节点分片信息</li></ul><p><strong>主节点：</strong></p><ul><li>有新的节点上下线时对数据重新分片</li></ul><p><strong>调度节点：</strong></p><ul><li>提供dubbo、http接口供业务系统调用，用于提交任务、取消任务、反馈执行结果等</li><li>从ZK注册中心获取当前节点的分片信息，再从数据库拉取即将过期的数据放到DelayQueue</li><li>调用业务系统注册的回调服务接口，发起调度请求</li><li>接收业务系统的反馈结果，更新执行结果，移除任务或发起重试</li></ul><p><strong>业务系统：</strong></p><ul><li>作为被调度的服务需要实现回调接口JobCallbackService，并注册为dubbo服务提供者</li><li>在需要延迟任务的场景调用调度系统接口操作任务</li></ul><p><strong>数据库设计</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1540896640484ca73a92097><p class=pgc-img-caption></p></div><p><strong>表说明</strong></p><ul><li>job_callback_service:服务配置表，配置业务回调服务，包括服务协议、回调服务、重试次数</li><li>job_delay_task:延迟任务表，用于存储延迟任务，包括任务分片号、回调服务、调用总次数、失败数、任务状态、回调参数等</li><li>job_delay_task_execlog:延迟任务执行表，记录调度系统发起的每一次回调</li><li>job_delay_task_backlog:延迟任务调度结果表，记录任务最终状态等信息</li></ul><p><strong>主从切换</strong></p><p>利用ZooKeeper临时序列节点特性，序号最小的节点为主节点，其他节点为从节点。</p><p>主节点监听集群状态，集群状态发生变化时重新分片。</p><p>从节点监听序号比它小的兄弟节点，兄弟节点发生变化重新寻找和建立监听关系。</p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/154089664059024e439b94a><p class=pgc-img-caption></p></div><p><strong>数据分片</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15408966407017044b00d13><p class=pgc-img-caption></p></div><p><strong>任务状态</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1540896640867af0f44257a><p class=pgc-img-caption></p></div><ul><li>delay：延迟任务提交后的初始状态</li><li>ready：过期时间已到，消息推入就绪队列的状态</li><li>running：业务订阅消息，收到消息开始处理的状态</li><li>finished：业务处理成功</li><li>failed：业务处理失败</li></ul><p><strong>主要流程</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1540896641007778acc40ed><p class=pgc-img-caption></p></div><p><strong>服务加载</strong></p><ol><li>从DB读取服务配置</li><li>根据配置动态构造Consumer对象并添加到Spring容器中</li></ol><p><strong>提交任务</strong></p><ol><li>业务系统通过dubbo或http接口提交任务</li><li>判断任务过期时间是否在一个扫描周期内</li><li>如果是，</li><li class=ql-indent-1>设置分片号(从当前节点所负责的分片随机获取)</li><li class=ql-indent-1>添加到内存队列</li><li class=ql-indent-1>任务保存到job_delay_task表</li><li>如果否,</li><li class=ql-indent-1>设置分片号(根据分片总数和随机算法算出分片号)</li><li class=ql-indent-1>任务保存到delay_task表</li></ol><p><strong>定时器</strong></p><ol><li>由一个线程管理</li><li>根据配置的扫描间隔设置定时器的执行周期</li><li>根据当前时间和扫描间隔算出该时段的过期时间X-Delay</li><li>从DB获取过期时间在X-Delay之前的所有任务，并放到DelayQueue</li></ol><p><strong>调度任务</strong></p><ol><li>由一个线程池管理</li><li>所有线程都阻塞在DelayQueue的方法take</li><li>take到任务，从DB中获取任务，判断是否存在</li><li>如果不在，什么也不做(任务已执行成功或已被删除)</li><li>如果存在，判断调用次数是否超过设置</li><li>如果不超</li><li>调用业务回调服务</li><li class=ql-indent-2>从任务中取出调用的服务配置</li><li class=ql-indent-2>从容器中获取对应的Consumer对象</li><li class=ql-indent-1>异步调用业务回调服务</li><li class=ql-indent-1>设置下次重试时间，记录调用日志job_delay_task_execlog</li><li>如果超过，将任务转移到job_delay_task_backlog</li></ol><p><strong>任务反馈</strong></p><ol><li>更新任务调用结果</li></ol><p><strong>优点</strong></p><ul><li>功能全面，高可用、易伸缩、可重试</li></ul><p><strong>缺点</strong></p><ul><li>略微复杂</li><li class=ql-indent-1>需要将服务配置动态生成为Consumer对象</li><li class=ql-indent-1>增加新的服务需要通知所有调度节点刷新</li><li class=ql-indent-1>存在一定的耦合性(直接调用业务服务，协议耦合)，如果接入系统是thrift协议呢？</li><li>需要处理任务的重试</li><li>调度系统直接回调业务服务，如果业务服务不可用可能会造成盲目重试，不能很好的控制流量(调度系统不知道业务服务的处理能力)</li></ul><p>如果引入MQ，使用MQ来解耦服务调用的协议，保证任务的重试，并由消费方根据自己的处理能力控制流量会不会更好呢？</p><p>另一种方案（DB/DelayQueue/ZooKeeper/MQ）</p><p><strong>整体架构</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1540896640919ca9bf39f1e><p class=pgc-img-caption></p></div><p><strong>数据库设计</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1540896640856b2eb8308af><p class=pgc-img-caption></p></div><p><strong>主要流程</strong></p><div class=pgc-img><img alt=延迟任务调度系统（技术选型与设计） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/154089664101535d6ba9cc4><p class=pgc-img-caption></p></div><p><strong>调度任务</strong></p><ol><li>由一个线程池管理</li><li>所有线程都阻塞在DelayQueue的take方法</li><li>take到任务，从DB中获取任务，判断是否存在</li><li>如果不在，什么也不做(任务已执行成功或已被删除)</li><li>如果存在，将任务转移到job_delay_task_execlog；往消息队列投递消息</li></ol><p><strong>缺点</strong></p><p>需要业务系统依赖于MQ</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'延迟','任务','调度'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>