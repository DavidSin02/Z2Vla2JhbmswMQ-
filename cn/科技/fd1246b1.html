<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JVM—深入理解内存模型与垃圾收集机制 | 极客快訊</title><meta property="og:title" content="JVM—深入理解内存模型与垃圾收集机制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/574c706db69f4c53802c093d6e7023d4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd1246b1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd1246b1.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="JVM—深入理解内存模型与垃圾收集机制"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/fd1246b1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JVM—深入理解内存模型与垃圾收集机制</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p><strong>为了感谢支持我的朋友！整理了一份Java高级架构资料、Spring源码分析、Dubbo、Redis、Netty、zookeeper、Spring cloud、分布式等资。关注私信回复：555领取</strong></p></blockquote><p>前言</p><p>Java是一种跨平台的语言，当初其设计初衷也是为了解决各个平台编译环境具有差异，对程序移植性问题造成困难这一痛点，于是推出了Java语言。这么多年Java受业界追捧的原因除了其面向对象的特性以外就是其可移植性强，而可移植性这一特性正式建立在JVM虚拟机这一基础上的，JVM在其内存模型和垃圾回收机制的设计上堪称神作，了解JVM虚拟机是每一个Java开发工程师必备的技能。</p><p>你了解Java的内存模型吗</p><ul><li>内存简介</li></ul><p>要说清楚内存，首先要提计算机程序是如何运行的。计算机<strong>程序</strong>指的就是可以让计算机运行的一些指令集合，简单地说就是我们平时写的代码，而真正在计算机中运行的是<strong>进程</strong>，<strong>进程=代码+数据</strong>，而要操作数据，则应该先将数据加载进内存中，才能对其进行进一步的操作。而内存就是一系列<strong>地址空间</strong>，地址空间又分为<strong>内核空间</strong>和<strong>用户空间</strong>，<strong>内核空间</strong>是计算机操作系统运行时所需的空间，如虚拟内存、联网、操作系统调度等所需的空间，而Java进程实际运行时使用的空间是我们的<strong>用户空间</strong>。</p><ul><li>JVM架构图</li></ul><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/574c706db69f4c53802c093d6e7023d4><p class=pgc-img-caption></p></div><ul><li><br></li><li>类装载器(ClassLoader):依据特定格式，class文件加载到内存。</li><li>执行引擎(Execution Engine):对命令进行解析。</li><li>本地库接口(Native Interface):融合不同开发语言的原生库为Java所用。</li><li><strong>内存区域(Runtime Data Area)</strong>:JVM内存空间结构模型。</li><li>划分</li><li>从Java的内存区域中可以看到，其分为五个区，分别是 <strong>1.程序计数器、2.虚拟机栈、3.本地方法栈、4.堆区、5.方法区</strong>(<strong>元空间</strong>)而在这五个区中，分为<strong>线程私有</strong>和<strong>共享区域</strong>。</li><li>线程私有</li></ul><p><strong>1.程序计数器（Program Counter Register）</strong>：当前线程所执行字节码（class文件）行号指示器（逻辑），它改变自身的计数器的值来选取下一条需要执行的字节码指令，为了程序执行不互相冲突，所以每个线程必须私有程序计数器，保证程序运行不冲突。<strong>注：如果是执行Native方法，则计数器值为Undefined。</strong> 程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变， 所以此区域不会出现 OutOfMemoryError 的情况。</p><p><strong>2.Java虚拟机栈（Stack）</strong>：Java虚拟机栈即我们平时所说的Java内存模型里的栈内存，其存放的最小单位为<strong>栈帧</strong>，Java虚拟机栈中的每个栈帧主要存储<strong>局部变量表、操作数栈、动态链接、返回地址</strong>，当方法调用结束时，该栈帧随机被销毁，栈帧内的局部变量也随机被销毁。这里说一下<strong>局部变量表</strong>和<strong>操作栈</strong>，<strong>局部变量表</strong>包含了方法执行过程中的所有变量，而<strong>操作数栈</strong>主要实现入栈、出栈、复制、交换、产生消费变量等。该区域会产生两种异常，即 当线程请求的栈大小超过栈的总深度，抛出StackOverflowError异常（例如递归），当栈进行扩展时无法得到足够的内存，则抛出OutOfMemoryError异常。</p><p>3.<strong>本地方法栈（Native Method Stack）</strong>：与虚拟机栈相似，主要存非Java语言的方法。同样会抛出StackOverflowError和OutOfMemoryError异常</p><ul><li>所有线程共享</li></ul><p><strong>1.方法区（Method Area）</strong>：方法区主要存储Class的相关信息，包括Method和field等等，说这个之前首先说<strong>元空间（MetaSpace）和永久代（PermGen）的区别，在Java1.7后，将方法区中的字符串常量池移动到Java堆中，并且Java1.7之后将永久代变为元空间，它们两个最大的区别就是元空间使用本地内存</strong>而永久代使用<strong>JVM内存</strong>，这一改变最大的变化就是，不会再看到ParmGen出现内存溢出的异常了，而且字符串常量池存在永久代中，容易出现性能问题和内存溢出，类和方法的信息大小难以确定，给永久代的大小指定带来困难。</p><p><strong>2.Java堆（Heap）</strong>：该区域是Java内存模型中最大的一块，该区域<strong>存储所有对象的实例</strong>，即我们在写代码时new出来的对象，都存在堆区，当堆无法再分配内存时，将会抛出OutOfMemoryError异常。该区域<strong>是GC管理的主要区域</strong>，因此Java堆又被称为GC堆，由于GC在垃圾回收的时候使用分代收集，所以堆内存也可以被分为<strong>新生代</strong>和<strong>老年代</strong>，老年代占堆内存的2/3，新生代占1/3，新生代又可以细分为<strong>Eden区</strong>、<strong>From区</strong>、<strong>To区</strong>，Eden区的<strong>Eden</strong>即<strong>伊甸园</strong>的意思，<strong>圣经记载，亚当和夏娃在伊甸园偷食禁果</strong>，所以伊甸区是人类的起源地，名字也就来源于此，我们在程序中new出的对象（除大对象，大对象直接进入老年代），都存在于Eden区，<strong>当多次GC后没有被回收，则会进入老年代</strong>，这一块在说垃圾回收机制的时候会细说，这里只要知道Java堆大概分为这几个区域即可。</p><p>关于Java内存模型的面试题</p><ul><li>JVM三大性能调优参数-Xms -Xmx -Xss的含义</li><li>答： 1.-Xss：规定了每个线程虚拟机栈（堆栈）的大小。</li><li>2.-Xms：堆的初始值。</li><li>3.-Xmx：堆能达到的最大值。通常将堆的初始值和最大值设为相同值，防止堆扩容时产生内存抖动问题。</li><li>Java内存模型中堆和栈的区别——内存分配策略</li><li>静态存储：编译时确定每个数据目标在运行时的存储空间需求。</li><li>栈式存储：数据区需求在编译时未知，运行时模块入口前确定。</li><li>堆式存储：编译时或运行时模块入口都无法确定，动态存储。</li><li>堆和栈的联系，引用对象、数组时，栈里定义变量保存堆中对象目标的首地址。</li><li>堆和栈的不同，栈中的变量在方法运行结束后立即被清除（自动释放），而堆中的对象即使失去引用变为不可达对象，也需等待GC才会被清除，即清除时间时不确定的（需要GC）。</li><li>栈的空间较堆空间小，且栈产生的碎片远小于堆。</li><li>栈的效率比堆高。</li></ul><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d70e0a1afa2843f0a9f8a5e3f2a33bab><p class=pgc-img-caption></p></div><ul><li><br></li><li>JDK6和JDK6之后的版本对intern()方法的区别</li></ul><blockquote><p>JDK6:当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用。否则，将此字符串对象添加到字符串常量池中，并且返回该字符串对象的引用。JDK6+：当调用intern方法时，如果字符串常量池先前已创建出该字符串对象，则返回池中的该字符串的引用，否则，如果该字符串对象已经存在于Java堆中，则将堆中对此对象的引用添加到字符串常量池中，并且返回该引用；如果堆中不存在，则在池中创建该字符串并返回其引用。</p></blockquote><ul><li><strong>注：Java1.8中 已经将字符串常量池已经从方法区移动到堆中</strong>。</li></ul><p>Java垃圾回收机制</p><p>对象被判定为垃圾的标准</p><p>在垃圾回收机制中，把<strong>没有被其它对象引用的对象</strong>判定为垃圾，而垃圾回收机制的各种算法也是基于这一标准，主要的中心即放在<strong>如何判定一个对象是否被引用</strong>和<strong>如何被回收</strong>。</p><p>引用计数算法</p><p>在<strong>引用计数算法</strong>中，主要是通过<strong>计算一个对象的引用数量</strong>来判断对象是否为垃圾，是否应该被回收。其实现方式是对存在于堆中的每一个对象都置一个<strong>引用数量计数器</strong>。当创建一个对象时，将该对象实例分配给一个引用对象，则将该对象的引用数量计数器的值<strong>加一</strong>，完成引用则<strong>减一</strong>。因此，当该实例对象的引用计数器值为0时，则可以将该对象视为垃圾，在GC调用时，则将会回收该对象的空间。</p><p><strong>引用计数算法</strong>的优劣：引用计数算法其<strong>优点</strong>是执行效率高，程序执行受影响较小，因为其运行时只需将引用数量计数器的值加一或减一，运算量极小，效率极高，可以交织在程序运行中。其<strong>缺点</strong>也是十分明显的，引用计数算法有一个致命的缺陷，就是它无法处理<strong>循环引用</strong>的情况，所谓循环引用就是<strong>当A引用B，B又引用A，两个对象互相引用</strong>，实际上这两个对象是可以被回收的，但由于其引用计数器的值均为1，所以造成了此种算法判定这两个对象为不可回收，导致内存泄漏。所以Java中的GC并不会采用此种算法。</p><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/263833c06b2f4970873c29b3111072ad><p class=pgc-img-caption></p></div><p>可达性分析算法</p><p><strong>可达性分析算法</strong>是通过判断对象的<strong>引用链是否可达</strong>，来决定对象是否可以被回收，该算法从离散数学中的图论引入，程序之间的引用关系可以看作是一个十分复杂的图，通过一系列的名为<strong>GC Root</strong>的节点作为起始点，向下搜索，搜索中走过的路径就被称为<strong>引用链（Reference Chain）</strong>，当一个对象从GC Root没有任何的引用链，则证明该对象是<strong>不可达</strong>的，该对象就会被标记为垃圾。</p><p>例如图中Object5、Object6、Object7均为<strong>不可达</strong>，所以这三个对象将会在下一次GC中被清除。</p><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f560d6d7ac1b4257895ac09e851c6b3b><p class=pgc-img-caption></p></div><ul><li>可作为GC Root的对象： 1.虚拟机栈中引用的对象（栈帧中的局部变量表）</li><li>2.方法区中常量引用的对象</li><li>3.方法区中类静态属性引用的对象</li><li>4.本地方法栈中Native方法中的引用对象</li><li>5.活跃线程的引用对象</li><li>简单来说：就是所有被引用的对象（包括静态对象和非静态对象）+线程+Native方法中的对象，都可以作为GC Root的对象。</li></ul><p>垃圾回收算法</p><p>这里可能有人会蒙，刚才不是谈了垃圾回收算法了吗，怎么又开始说垃圾回收算法了，其实从这里开始，才是真正的垃圾回收算法，上面的两个算法可以算是垃圾回收前的准备工作，即<strong>对要回收的对象进行标记判断</strong>。这个对象是否应该被回收，是上面那两个算法的工作，而这个对象应该怎么被回收，回收后要对内存做哪些工作，这就是<strong>垃圾回收算法</strong>所要考虑的事情。</p><p>标记-清除算法（Mark and Sweep）</p><p><strong>标记-清除算法</strong>将算法分为两个步骤，即<strong>标记</strong>和<strong>清除</strong>，所谓标记，就是<strong>从根节点进行扫描，对存活的对象进行标记。所谓清除，就是对堆内存中从头到尾进行线性遍历，回收未被标记的对象内存，即不可达对象内存，最后将原来做过标记对象的标记清空，为下一次GC做准备</strong>。</p><p>标记-清除算法的<strong>优缺点</strong>：标记-清除算法的优势是其效率高，仅需扫描一遍内存即可将所有的垃圾进行回收。但是其缺陷也是十分的明显，在标记-清除算法中，只要某对象被标记为垃圾，则调用GC时就会直接进行回收，这势必会带来一个问题，就是<strong>内存的碎片化</strong>。所谓内存碎片化，即在GC过程中，由于垃圾所处的内存空间并不连续，导致回收过后会存在很多的不连续的内存空间。</p><p>举个例子，<strong>有两个对象A and B，A占用1B内存，B占用1B内存，他们两个所处的位置并不连续，而当它们被同时标记为垃圾并被回收了之后，就会产生两块1B的内存，此时来了一个2B的对象，但是它就无法使用这两块不连续的1B存储空间了</strong>。如果此时内存已满，将会抛出OutOfMemoryException，这就是内存碎片所造成的后果。</p><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b31c45410eaf476d91cf4eadaf13e8c6><p class=pgc-img-caption></p></div><p>复制算法（Copying）</p><p><strong>复制算法</strong>，将内存分为<strong>对象面</strong>和<strong>空闲面</strong>，对象只存在于对象面上。当复制算法运行时，首先会像标志-清除算法一样，对<strong>存在引用的对象</strong>做标记，然后将<strong>带有标记的对象</strong>复制到<strong>空闲面</strong>上，并且按照内存顺序存储，当全部带标记的对象都被移动到空闲面上后，将对象面的所有对象一并清除，然后将空闲面和对象面进行互相转换，即此时对象面变为空闲面，空闲面变为对象面。由于复制操作也存在效率问题，所以这种算法适用于<strong>对象存活率低</strong>的场景，因为这样就不会有很多的对象需要复制。实际上这种算法是应用在<strong>堆内存中的新生代</strong>中的，因为在大量的实践中证明，在新生代区的对象，最后存活下来的比例大概只有10%，所以相当适合这种算法。至于在新生代中这种算法的运行步骤是怎样的，放在下文中说。</p><p>由于复制算法对复制后的对象按照内存顺序存储，所以它解决了标记-清除算法中内存碎片化的问题。</p><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4839027206684753b67d76db97005169><p class=pgc-img-caption></p></div><p>标记-整理算法（Compacting）</p><p><strong>标记-整理算法</strong>采用和标记-清除算法一样的步骤，从根集合进行扫描，对存活的对象进行标记，但在<strong>清除时</strong>，这个算法会移动所有存活的对象，且按照内存地址次序依次进行排列，然后将末端内存地址以后的内存全部进行回收。由于此种算法在标记-清除的基础上，加之对对象进行整理，所以其效率更低，但解决了内存碎片化的问题。</p><p>该算法由于一次GC会有较高的资源消耗，所以该算法适用于存活率高的场景，例如堆内存中的<strong>老年代</strong>。</p><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d2753a9b2fa4e9d8c699fb45bd16d2a><p class=pgc-img-caption></p></div><p>分代收集算法（Generational Collector）</p><p>有了上述三种的垃圾回收算法，有些同学可能心存疑虑，到底JVM中使用的是哪一种算法来对垃圾进行回收呢？其实JVM使用了上述几种算法的<strong>组合拳</strong>，即<strong>分代收集算法</strong>。从严格意义上来说，分代收集算法并不是一种新的算法，它只是将上述几种算法进行了一个整合。按照对象生命周期的不同划分区域，采用不同的垃圾回收算法。</p><p>这里先说一下<strong>JVM内存模型</strong>和<strong>对象生命周期</strong>之间的关系，在我们new一个普通对象时，这个对象会在<strong>Eden</strong>区被创建，假如在一次GC过后，这个对象没有被清除，则称这个对象是幸存者，将其<strong>年龄</strong>属性加一，而后将会移动到From 区或To区，这两个区域也被统称为Servivor区，（<strong>Eden区：From区：To区=8：1：1</strong>），当一个对象经历了15次GC后都没有被回收，则会直接被移动到堆区中的<strong>老年代</strong>，老年代中的对象被认为是<strong>回收可能性不大</strong>的对象，因为经历了15次GC都没有被回收的对象，经历150次GC被回收的可能性也不大。</p><p>所以了解了这个原理之后，再说分代收集算法就将会变得简单。上文提到，<strong>复制算法</strong>由于其复制对象到空闲区需要消耗资源，所以适合对象存活率不高的场景，而<strong>新生代</strong>就很好地满足了这个条件，所以新<strong>新生代</strong>通常使用<strong>复制算法</strong>进行垃圾回收。在多次的实践中证明，一批被新建的对象，最终存活率大概在10%左右，所以这一批对象将会被复制到Servivor区，而复制完成后立即回收Eden区。而新生代中的From区和To区又和复制算法中的空闲区和对象区相对应。这就对复制算法的施行制造了很好的环境。</p><p><strong>老年代</strong>由于其存储的对象具有<strong>不易被GC</strong>这个特点，所以上文中提到的<strong>标记-整理算法</strong>将会变得十分合适，标记-整理算法由于需要在清除后对存活的对象进行一次整理以消除内存碎片化，所以如果有大量的内存碎片，将非常不利于这种算法的运行，而老年代则给了适合这种算法的土壤。</p><p>在分代收集算法中还有两个重要的概念是未曾提到的<strong>Minor GC</strong> 和 <strong>Full GC</strong>，存在于新生代的GC由于其垃圾回收范围较小，被称为MinorGC，而在老年代的GC中通常伴随着所有内存的GC，所以其又被称为Full GC。Full GC效率低，但是不常被触发。</p><ul><li><strong>触发Full GC的条件</strong></li><li>1.老年代空间不足</li><li>2.永久代空间不足（已移除）</li><li>3.CMS GC时出现Promotion failed，concurrent mode failure</li><li>4.Minor GC晋升到老年代的平均大小大于老年代的剩余空间</li><li>5.调用System.gc()</li><li>6.使用RMI进行RPC或管理的JDK应用，每小时执行一次Full GC</li><li><strong>常用的调优参数</strong>：</li><li>1.-XX：SurvivalRatio:Eden和Servivor的比值，默认8:1</li><li>2.-XX：NewRatio：老年代和年轻代的内存大小的比例</li><li>3.-XX:MaxTenuriingThreshold：对象从年轻代晋升到老年代经过GC的最大阈值</li></ul><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f8876575d4a442048fae18cd602430aa><p class=pgc-img-caption></p></div><p>常用的垃圾收集器</p><p>在说垃圾收集器之前，先得明白两个概念</p><ul><li>Stop-the-World</li><li>什么是Stop-the-World？JVM由于要执行GC，而停止应用程序的执行，这就是Stop-the-World，这种现象在任何一种GC算法中都会发生，所以如何让Stop-the-World发生的次数越来越少，以优化GC性能，是大多数垃圾收集器优化GC的策略。</li><li>Safe Point</li><li>这个词相对来说很好理解，在GC过程中，会有程序不断地产生垃圾对象，这会造成<strong>一边打扫一边扔</strong>的效果，所以GC是以快照方式进行垃圾回收的，在程序运行到特定位置时，例如跳转，会生成一个Safe Point，而GC将会根据这个Safe Point中的垃圾进行回收。</li></ul><p>垃圾收集器</p><div class=pgc-img><img alt=JVM—深入理解内存模型与垃圾收集机制 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0dd8f268a0af4e19b4dc09c80675788f><p class=pgc-img-caption></p></div><p>上图中上半部分为新生代垃圾收集器，下半部分为老年代垃圾收集器。</p><p>两个垃圾收集器之间如果有连线，代表可以配合使用。</p><p><strong>新生代垃圾收集器</strong></p><p><strong>Serial收集器</strong>是目前JVM运行在Client模式下的默认收集器，使用复制算法。因为它是单线程收集的，进行垃圾收集时必须暂停所有工作线程。</p><p><strong>ParNew收集器</strong> 是多线程垃圾收集器，除了多线程这个特点，其余的行为、特点和Serial收集器一样。它是Server模式下JVM默认的垃圾收集器。</p><p><strong>老年代垃圾收集器</strong></p><p><strong>Serial Old收集器</strong> 使用标记-整理算法，单线程收集，进行垃圾收集时，必须暂停所有工作线程。简单高效，是Client模式下默认的老年代垃圾收集器。</p><p><strong>CMS收集器</strong> 使用标记-整理算法，多线程收集，GC线程几乎可以和工作线程同时工作。</p><p>GC相关面试题</p><ul><li><strong>Object的finalize()方法作用是否与C++的析构函数作用相同</strong></li><li>答：Object的finalize()方法不能保证在调用时立即回收目标对象，而是要等一次GC才能开始回收，因此它是不确定的。而C++中的析构函数是确定的。</li><li><strong>Java中的强引用、软引用、弱引用、虚引用有什么用。</strong></li><li><strong>强引用</strong>：指该对象存在至少一个引用对象引用的情况，这时GC绝不会回收该对象，当内存不足时，即使报OutOfMemoryException也不会回收该对象。</li><li><strong>软引用</strong>：对象处于有用但非必须的状态，只有当内存不足时，GC才会回收该引用的内存。可用来实现内存敏感的高速缓存，因为在内存不足就被回收这一特性，我们不用太担心OutOfMenoryException这一异常 用法：</li></ul><pre>String str = new String("abc");//强引用SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(str);//软引用</pre><ul><li><strong>弱引用</strong>：非必须的对象，比软引用更弱一些，GC时会被回收。被回收的概率也不大，因为GC线程优先级比较低，适用于偶尔被使用且不影响垃圾收集的对象。</li><li>用法：</li></ul><pre>String str = new String("abc");//强引用WeakReference&lt;String&gt; weakRef = new WeakReferences&lt;String&gt;(str);//弱引用</pre><ul><li><strong>虚引用</strong>：不会决定对象的生命周期，在任何时候都可能被垃圾收集器回收，它可以跟踪对象被垃圾收集器回收的活动。必须与ReferenceQueue联用。</li><li>用法：</li></ul><pre>String str = new String("abc");ReferenceQueue queue = new ReferenceQueue();PhantomReference ref = new PhantomReference(str,queue);</pre><ul><li>综上，强引用>软引用>弱引用>虚引用</li></ul><p>结语</p><p>关注公众号领资料</p><p>搜索公众号【Java耕耘者】,回复【Java】，即可获取大量优质电子书和一份Java高级架构资料、Spring源码分析、Dubbo、Redis、Netty、zookeeper、Spring cloud、分布式等视频资料</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'JVM','内存','机制'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>