<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python零基础入门-数据类型与变量 | 极客快訊</title><meta property="og:title" content="Python零基础入门-数据类型与变量 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/1aa53d697d75447bb17efe260f3193cb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd65393.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd65393.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd65393.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd65393.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd65393.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd65393.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fd65393.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fd65393.html><meta property="article:published_time" content="2020-10-29T21:04:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:29+08:00"><meta name=Keywords content><meta name=description content="Python零基础入门-数据类型与变量"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/fd65393.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python零基础入门-数据类型与变量</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>数据类型与变量</h1><h1 class=pgc-h-arrow-right>大纲</h1><ul><li>前言</li><li>基本数据类型</li><ul><li>数字(Number)</li><li>字符串(String)</li><li>列表(List)</li><li>元组(Tuple)</li><li>字典(Dictionary)</li><li>集合(Set)</li><li>可变与不可变类型</li></ul><li>再论变量</li><ul><li>多个变量赋值</li><li>变量的命名法</li></ul><li>总结</li></ul><h1 class=pgc-h-arrow-right>前言</h1><blockquote><p>python各种基本数据类型就相当于厨房里的柴米油盐，只要我们用溜了，米其林大厨也不在话下一大波概念正在接近，不要被吓怕，我们阳光足、豌豆射手够猛</p></blockquote><div class=pgc-img><img alt=Python零基础入门-数据类型与变量 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1aa53d697d75447bb17efe260f3193cb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>基本数据类型</h1><h1 class=pgc-h-arrow-right>数字(Number)</h1><p style=text-align:start>在python中，数字(number)分为<strong>四类</strong>:</p><ol start=1><li>整型(integer)，其实就是整数，例如 520</li><li>浮点型(float)，其实就是小数，例如圆周率 3.1415926</li><li>布尔值(boolean)，布尔值就是真假值，它有且只有两个值 真True 与 假False，您可以把True和False想象成两个变量，他们的值分别为 1 和 0</li><li>复数(complex)，用的很少，例如 1+2j</li></ol><h1 class=pgc-h-arrow-right>例子</h1><pre><code>a = 520 # 整型b = 3.1415926 # 浮点型c = True # 布尔值d = 1+2j # 复数# 您可以用python内置函数type来查看一个变量指向的类型print(type(a)) # &lt;class 'int'&gt; int是integer的简写print(type(b)) # &lt;class 'float'&gt;print(type(c)) # &lt;class 'bool'&gt; bool是boolean的简写print(type(d)) # &lt;class 'complex'&gt;</code></pre><h1 class=pgc-h-arrow-right>常用数值运算</h1><pre><code>&gt;&gt;&gt; 1 + 1 # 加法2&gt;&gt;&gt; 3 - 1.5 # 减法1.5&gt;&gt;&gt; 2 * 5 # 乘法10&gt;&gt;&gt; 10 / 3 # 除法, 注意无论是否能整除，得到的都是一个浮点数3.3333333333333335&gt;&gt;&gt; 10 / 52.0&gt;&gt;&gt; 10 // 5 # 两个斜杠来表示整除，这样会得到一个整数2&gt;&gt;&gt; 10 % 3 # 百分号表示取余运算1&gt;&gt;&gt; 2 ** 3 # 两个星号表示乘方运算，这里表示2的3次方8</code></pre><p style=text-align:start><strong>注意，如果您以整数与浮点数作运算，那么会得到一个浮点数</strong></p><pre><code>&gt;&gt;&gt; 1 + 1.02.0</code></pre><blockquote><p>如果您之前学过某种编程语言，您可能会疑惑，布尔值是数字类型？是的，在python3中， True和False都是其保留字，它们值还是1和0，可以与数字相加</p></blockquote><p style=text-align:start>不信来试试</p><pre><code>&gt;&gt;&gt; 1 + True2&gt;&gt;&gt; True + True # 1 + 1 = 22&gt;&gt;&gt; False == 0 # False等于数值0True&gt;&gt;&gt; type(True) # True是bool类的一个实例&lt;class 'bool'&gt;&gt;&gt;&gt; issubclass(bool, int) # bool类是int类的子类，内置方法issubclass用于查看一个类是否为另一个类的子类True&gt;&gt;&gt; bool.__base__ # bool类是int类的子类，__base__是魔法属性，其指向父类&lt;class 'int'&gt;&gt;&gt;&gt; isinstance(True, int) # True是int类的实例，内置方法isinstance用于查看一个值是否为某个类的实例True</code></pre><div class=pgc-img><img alt=Python零基础入门-数据类型与变量 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/881915717b4845b5ada5a15bea5886ec><p class=pgc-img-caption></p></div><p style=text-align:start>如果上面的示例不太懂，没关系，只需要知道True或False就是数字1和0，它们可以与数字进行运算就可以了</p><h1 class=pgc-h-arrow-right>字符串(String)</h1><blockquote><p>从HelloWorld程序开始，我们就已经接触过字符串(string)了，现在重新回顾一下，就像偶然在街上遇见一个好久未见的旧朋友，必须要啤酒撸串走一转加深感情一样</p></blockquote><p style=text-align:start>字符串可以用四种方法来表示:</p><ol start=1><li>用单引号 ' 括住表示</li><li>用双引号 " 括住表示</li><li>用三个单引号 ''' 括住表示(多行字符串、多行注释)</li><li>用三个双引号 """ 括住表示(多行字符串、多行注释)</li></ol><h1 class=pgc-h-arrow-right>例子</h1><pre><code># 单个单引号表示a = '你真帅'# 单个双引号表示b = "你真漂亮"# 三个单引号表示多行字符串c = '''你怎么这么好看'''# 三个双引号表示多行字符串d = """是天生的吗是的"""</code></pre><p style=text-align:start>结果</p><pre><code>&gt;&gt;&gt; print(a)你真帅&gt;&gt;&gt; print(b)你真漂亮&gt;&gt;&gt; print(c)你怎么这么好看&gt;&gt;&gt; print(d)是天生的吗是的</code></pre><p style=text-align:start><strong>推荐使用单引号来表示，因为双引号还得多按一个Shift键</strong></p><h1 class=pgc-h-arrow-right>字符串换行</h1><p style=text-align:start>您可能注意到了，在上面的例子中，在print出变量c与d时，显示是两行，那么能不能用一个单引号或双引号来做到换行效果呢</p><p style=text-align:start>可以的，您只需要在字符串里加上 \n ，它表示一个换行符</p><pre><code>&gt;&gt;&gt; a = '你怎么\n这么好看' # 在字符串内加上\n表示换行&gt;&gt;&gt; a'你怎么\n这么好看'&gt;&gt;&gt; print(a)你怎么这么好看&gt;&gt;&gt; b = '''你怎么... 这么好看'''&gt;&gt;&gt; b # 下面的结果揭示了多行字符串只不过是当您回车时，解释器自动帮您添加上\n符号而已'你怎么\n这么好看'</code></pre><h1 class=pgc-h-arrow-right>字符串基础操作</h1><blockquote><p>您可以通过索引来获取字符串中的某一个字符，亦可以用切片来获取字符串的某段子串</p></blockquote><h1 class=pgc-h-arrow-right>索引</h1><p style=text-align:start><strong>在编程的世界中，一切都从0开始计数，比如字符串'abc'，那我们会说第0个字符是a、第1个字符才是b</strong></p><p style=text-align:start>如果这个让您困惑，不妨可以举如下例子，帮助理解</p><blockquote><p>假如您家里电梯总共有三楼按<strong>1</strong>楼按钮，电梯鸟都不鸟您，就不会移动，所以为<strong>0</strong>按<strong>2</strong>楼按钮，它往上移动了1楼，所以为<strong>1</strong>按<strong>3</strong>楼按钮，它往上移动了2楼，所以为<strong>2</strong>所以<strong>这个计数其实是移动的步数</strong></p></blockquote><div class=pgc-img><img alt=Python零基础入门-数据类型与变量 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0fbc269ee35b436a9e72261f3d93fe1b><p class=pgc-img-caption></p></div><p style=text-align:start>所以如果我们企图获取字符串中的某一个字符，指针也要作相应<strong>移动</strong>，我们使用字符串[移动步数]来获取某一个字符，比如字符串[0]获取第一个、字符串[1]获取第二个</p><pre><code>&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a[0]'a'&gt;&gt;&gt; a[1]'b'&gt;&gt;&gt; a[2]'c'&gt;&gt;&gt; a[3] # 注意如果您超过它的长度，将会报错，提示字符串的索引超出了范围Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: string index out of range&gt;&gt;&gt; length = len(a) # 我们可以用python内置函数len来查看字符串的长度，len是英文length的简写&gt;&gt;&gt; print(length) # 字符串a的最后一个字符的索引是2，所以这里如果我们的索引超过2，就会报错3</code></pre><h1 class=pgc-h-arrow-right>切片</h1><p style=text-align:start>切片用于获取字符串中的某一部份，就像切三文鱼一样，我们用锋利的刀切出最好吃的部份; 我们使用字符串[开始步数:结束步数]来获取字符串中的某段</p><p style=text-align:start><strong>注意：切片的结果并不会包含结束步数处的元素</strong></p><pre><code>&gt;&gt;&gt; a = 'abcd'&gt;&gt;&gt; a[0:1] # 第一个字符，相当于a[0]'a'&gt;&gt;&gt; a[0:2] # 第一个字符至第二个字符'ab'&gt;&gt;&gt; a[0:3] # 第一个字符至第三个字符'abc'</code></pre><h1 class=pgc-h-arrow-right>字符串运算</h1><p style=text-align:start>与数字一样，字符串也有专属于它的运算 +、*、in</p><pre><code>&gt;&gt;&gt; a = '帅'&gt;&gt;&gt; b = '哥'&gt;&gt;&gt; c = 'abcd'&gt;&gt;&gt; a + b　# 字符串加法，表示将左右两个字符串顺序粘连在一起'帅哥'&gt;&gt;&gt; a * 3 # 字符串加法，表示将目标字符串重复Ｎ次'帅帅帅'</code></pre><p style=text-align:start>可以用in操作符，来查看字符串是否包含某段字符串，返回值是布尔值</p><pre><code>&gt;&gt;&gt; 'a' in c # 字符串'a'在字符串'abcd'里面吗True&gt;&gt;&gt; 'bc' in c # 字符串'bc'在字符串'abcd'里面吗True&gt;&gt;&gt; 'ac' in c # 字符串'ac'在字符串'abcd'里面吗False</code></pre><p style=text-align:start>为什么最后一个是False！ac明明在'abcd'里面有啊？</p><p style=text-align:start>因为必须要连续的，a位置是0，c位置是2，所以是非连续的，这里要特别注意</p><h1 class=pgc-h-arrow-right>列表(List)</h1><blockquote><p>在python中，列表(list)是被使用的最频繁的一种数据类型，所以掌握它，很重要您可以把列表想象成超市里的储物柜，其每一个格子都可以存任意的东西，甚至您可以往格子里再放一个储物柜，无线嵌套，就像盗梦空间一样列表是<strong>可变的</strong>，就像格子可以先后放入不同客人的物品一样我们以中括号 [、] 括住来表示一个储物柜，并以逗号 , 分隔其中每一个格子</p></blockquote><h1 class=pgc-h-arrow-right>例子</h1><pre><code>&gt;&gt;&gt; a = [1,'揹包','雨伞',3.14] # 创建了一个有4个元素的列表，我们在里面存了数字和字符串&gt;&gt;&gt; print(a) # 打印看看[1, '揹包', '雨伞', 3.14]&gt;&gt;&gt; a[1] # 支持索引，第二格存了什么'揹包'&gt;&gt;&gt; a[3] # 支持索引，第四格存了什么3.14&gt;&gt;&gt; a[1:3] # 也支持切片，第二格到第二格存了什么['揹包', '雨伞']</code></pre><p style=text-align:start>列表的切片与字符串的切片有一丢丢的区别</p><pre><code>&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; b = ['a','b','c']&gt;&gt;&gt; a[0]'a'&gt;&gt;&gt; a[0:1] # 这里注意到字符串的切片[0:1]与索引[0]是一样的效果，无论是索引还是切片得到的都是字符串'a'&gt;&gt;&gt; b[0]'a'&gt;&gt;&gt; b[0:1] # 但是列表的切片得到的永远是列表，索引就是得到其对应元素的类型['a']</code></pre><h1 class=pgc-h-arrow-right>列表基础操作</h1><pre><code>&gt;&gt;&gt; a = [1,2,3,4,5]&gt;&gt;&gt; print(a)[1, 2, 3, 4, 5]&gt;&gt;&gt; a[2] = '中间' # 用字符串'中间'来替换列表的第三个元素&gt;&gt;&gt; print(a)[1, 2, '中间', 4, 5]&gt;&gt;&gt; a[0:2] = ['第一','第二'] # 用切片来替换列表中第一、二个元素&gt;&gt;&gt; print(a)['第一', '第二', '中间', 4, 5]&gt;&gt;&gt; a[0:2] = [1,2,3] # 如果切片赋值两边的长度不一致，左边的列表长度将会发生变化&gt;&gt;&gt; print(a) # 现在它的长度变为6[1, 2, 3, '中间', 4, 5]&gt;&gt;&gt; a[0:2] = [] # 切片赋值给空列表，将导致原来的列表长度减2&gt;&gt;&gt; print(a)[3, '中间', 4, 5]</code></pre><p style=text-align:start>列表也同样支持+、*、in操作符，但是它的in与字符串的in，有些许不同</p><pre><code>&gt;&gt;&gt; print(a)[3, '中间', 4, 5]&gt;&gt;&gt; '中间' in a # 字符串'中间'在列表a里面吗True&gt;&gt;&gt; 4 in a # 数字4在列表a里面吗True&gt;&gt;&gt; [4, 5] in 列表[4, 5]在列表a里面吗False</code></pre><p style=text-align:start>结果是False，区别就在这里了</p><p style=text-align:start>对于字符串来说，in操作符可以检测单个或多个元素是否在其内，但是列表，只能检测单个元素是否在列表内</p><pre><code>&gt;&gt;&gt; b = [1,2]&gt;&gt;&gt; c = b + a # 列表同样支持加号+运算符，表示将左右两边列表按顺序粘连在一起&gt;&gt;&gt; print(c)[1, 2, 3, '中间', 4, 5]&gt;&gt;&gt; b * 2 # 列表用样支持星号*运算符，表示将目标列表重复N次[1, 2, 1, 2]</code></pre><h1 class=pgc-h-arrow-right>嵌套列表</h1><blockquote><p>上面说过，列表它里面可以存任意的类型，甚至列表里面可以再存个列表，那要怎样操作列表中的列表呢？</p></blockquote><pre><code>&gt;&gt;&gt; a = [[1,2,3],[4,5,6],[7,8,9]] # 定义一个两层嵌套列表&gt;&gt;&gt; print(a) # 看看它长什么样[[1, 2, 3], [4, 5, 6], [7, 8, 9]]&gt;&gt;&gt; len(a) # 我们可以用python内置函数len，来查看列表的长度3</code></pre><p style=text-align:start>居然是3，来看看这三个元素都长啥样</p><pre><code>&gt;&gt;&gt; a[0][1, 2, 3]&gt;&gt;&gt; a[1][4, 5, 6]&gt;&gt;&gt; a[2][7, 8, 9]</code></pre><p style=text-align:start>懂了，嵌套列表不就是一个列表里的元素也是一个列表嘛</p><p style=text-align:start>如果我要获取9这个数字，要怎么做？</p><p style=text-align:start>方法一:</p><pre><code>&gt;&gt;&gt; b = a[2]&gt;&gt;&gt; print(b[2])9</code></pre><p style=text-align:start>方法二:</p><pre><code>&gt;&gt;&gt; print(a[2][2])9</code></pre><p style=text-align:start>把上面两个步骤合并为一个，就不需要再创建一个变量b了</p><p style=text-align:start>相当于左边a[2]先结合为一个整体，然后再和[2]结合在一起</p><h1 class=pgc-h-arrow-right>元组(Tuple)</h1><blockquote><p>元组(tuple)和列表，它俩的关系就像孪生兄弟，长相和操作都很相似，但虽然是孪生兄弟，终归还是有些不一样，元组和列表的区别就是元组是<strong>不可变的</strong>(immutable)如果非要拉元组做个比喻，元组也可以是个储物柜，但是只要您把东西存进去了，储物柜也不会把取物票给您，您只能通过透明玻璃看到格子里面有些啥，但是您永远不能再替换里面的东西了(哪有这么不合理的设计啊！)我们以小括号 (、) 来表示一个元组，并以逗号 , 分隔其中每一个元素</p></blockquote><h1 class=pgc-h-arrow-right>例子</h1><ol start=1><li>元组同样支持列表的+、*和in操作符</li><li>元组同样支持索引与切片操作</li><li>只是<strong>元组是不可变的</strong>，<strong>列表是可变的</strong></li></ol><pre><code>a = (1,2,3)print(a) # (1, 2, 3)print(a*2) # (1, 2, 3, 1, 2, 3)print(a+a+a) # (1, 2, 3, 1, 2, 3, 1, 2, 3)print(2 in a) # Trueprint(4 in a) # Falseprint(a[0]) # 1print(a[0:2]) # (1, 2)</code></pre><p style=text-align:start>但是如果您重新赋值元组的元素，将会报异常，比如</p><pre><code>&gt;&gt;&gt; a[0] = 'do it' # 报错，提示元组不支持元素赋值Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment&gt;&gt;&gt; a[0:2] = (100, 200) # 报错，提示元组不支持元素赋值Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment</code></pre><h1 class=pgc-h-arrow-right>元组的两个天坑</h1><h1 class=pgc-h-arrow-right><strong>情景1</strong>: 某天您定义了一个<strong>只有一个元素的元组</strong></h1><pre><code>&gt;&gt;&gt; a = (1) # 定义一个单元素的元组，貌似没毛病&gt;&gt;&gt; a[0] # 查看元组第一个元素，讲道理结果肯定是1Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: 'int' object is not subscriptable</code></pre><p style=text-align:start>什么？ 报错是咋回事... 为啥提示整型不能进行索引操作？我的a明明是元组啊</p><pre><code>&gt;&gt;&gt; print(a) # 先看看变量a里是啥东西好了1</code></pre><p style=text-align:start>1是什么鬼？ 我可爱的小括号呢？</p><pre><code>&gt;&gt;&gt; print(type(a)) # 通过内置函数type看看a的类型是啥&lt;class 'int'&gt;</code></pre><p style=text-align:start>类型居然是整型，怪不得会报错</p><p style=text-align:start>原来(1)被解释器认为是整数1了，傻逼解释器！！</p><p style=text-align:start><strong>那要怎样才能定义一个单元素元组呢？ 只需要在1后面再加一个逗号,</strong></p><pre><code>&gt;&gt;&gt; a = (1,) # 在1后面多加个逗号试试&gt;&gt;&gt; print(a) # 好像没毛病哦(1,)&gt;&gt;&gt; print(type(a)) # 看看类型，果然是tuple元组了!&lt;class 'tuple'&gt;</code></pre><p style=text-align:start>但是列表却不会有这种问题</p><pre><code>&gt;&gt;&gt; b = [1]&gt;&gt;&gt; print(b)[1]&gt;&gt;&gt; print(type(b))&lt;class 'list'&gt;</code></pre><p style=text-align:start>难道元组不是python亲生的吗？ 为啥它哥没有这种问题，它却有？ 真是个弟弟！</p><p style=text-align:start>其实学到后面的<strong>运算符的优先级</strong>时候，就知道为什么了，小括号也被python解释器认作最高优先级的运算符</p><p style=text-align:start>例如我们计算1+1*2的时候，结果是3还是4呢？</p><p style=text-align:start>从小学我们就知道，先乘除后加减，所以结果毫无疑问会是3</p><p style=text-align:start>那么要怎么先计算1+1，然后再让它们的结果跟2相乘呢？</p><p style=text-align:start>数学老师会教您先用小括号()括住1+1就行了，(1+1)*2这样结果就是4了</p><pre><code>&gt;&gt;&gt; 1+1*23&gt;&gt;&gt; (1+1)*24</code></pre><p style=text-align:start>所以当您写出(1+1)这样的表达式的时候，别说python解释器了，我们人都不知道()到底在表示元组还是运算符，所以单个元素时必须要多加个逗号,来告诉解释器，这是一个元组</p><pre><code>&gt;&gt;&gt; (1+1)2&gt;&gt;&gt; (1+1,)(2,)</code></pre><div class=pgc-img><img alt=Python零基础入门-数据类型与变量 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0d8851a39e4445e4b35dfd2f526949e8><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>情景2</strong>: 某天您在定义赋值一个变量时，不小心<strong>在结尾多加了一个逗号</strong>,</h1><pre><code>&gt;&gt;&gt; a = 1, # 本意是定义一个整数1，结果不小心在结尾多加了个逗号&gt;&gt;&gt; b = 2&gt;&gt;&gt; a + b # 当您信心满满，认为结果肯定是3的时候Traceback (most recent call last):  File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: can only concatenate tuple (not "int") to tuple</code></pre><p style=text-align:start>报错了，提示元组只能与元组相加...</p><div class=pgc-img><img alt=Python零基础入门-数据类型与变量 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1b2a3972cfd141afb189796b41bd3c33><p class=pgc-img-caption></p></div><p style=text-align:start>为啥又报错了，傻逼解释器吧，我这哪来的元组？ 还能愉快的玩耍吗？</p><pre><code>&gt;&gt;&gt; print(a) # 看看a是啥(1,)&gt;&gt;&gt; type(a) # 看了看a的类型，居然是元组！&lt;class 'tuple'&gt;</code></pre><p style=text-align:start><strong>原来没有小括号()括住，用逗号,分隔的几个元素，也会被python视作元组!</strong></p><pre><code>&gt;&gt;&gt; a = '原','来','如','此'&gt;&gt;&gt; a('原', '来', '如', '此')&gt;&gt;&gt; print(type(a))&lt;class 'tuple'&gt;</code></pre><p style=text-align:start><strong>尽管如此，您必须始终坚持以小括号()括住、以逗号,分隔的语法来定义一个元组，因为这样更加明确</strong></p><h1 class=pgc-h-arrow-right>字典(Dictionary)</h1><blockquote><p>字典(dictionary)，同样是python中被使用频率最高的一种数据类型，说到字典，您可能会联想到新华字典、英汉字典，没错，它们确实很相似字典有两个重要的概念，分别是键(key)与值(value)，一个键对应一个值，就像一本书的页码对应其中某一页内容字典可以说是一种映射类型，它用花括号 {} 来表示，里面每一项键值对用 key:value 表示，并以逗号 , 分隔其中每一个键值对</p></blockquote><h1 class=pgc-h-arrow-right>例子</h1><p style=text-align:start>新建</p><pre><code># 创建一个字典a# 其中字符串'a'为键，对应着值整数1# 字符串'b'为另一个键，对应着值整数2a = {'a': 1, 'b': 2}print(a) # {'a': 1, 'b': 2}# 或者可以这样达到同样的目的b = {} # 创建一个空字典b['a'] = 1 # 将字符串'a'作为字典b新的键，对应着值整数1b['b'] = 2 # 将字符串'b'作为字典b新的键，对应着值整数2print(b) # {'a': 1, 'b': 2}</code></pre><p style=text-align:start>删除(delete)</p><pre><code>a = {'a': 1, 'b': 2}# 您可以用del(delete的简写)标识符来删除字典的一个键del a['a'] # 删除键'a'print(a) # {'b': 2}</code></pre><p style=text-align:start>修改</p><pre><code>a = {'a': 1, 'b': 2}a['a'] = 'hello' # 将键'a'指向了新的值字符串'hello'print(a) # {'a': 'hello', 'b': 2}</code></pre><p style=text-align:start>查看</p><pre><code>a = {'a': 1, 'b': 2}print(a['a']) # 查看键'a'对应的值，为1print(a['b']) # 查看键'b'对应的值，为2# 您可以通过.号来调用字典的方法(函数)，如果您暂时不理解，先记住# 查看字典a的所有键，可以调用字典的方法keysprint(a.keys()) # dict_keys(['a', 'b'])# 查看字典a的所有值，可以调用字典的方法valuesprint(a.values()) # dict_values([1, 2])# 查看字典a的所有键值对，可以调用字典的方法itemsprint(a.items()) # dict_items([('a', 1), ('b', 2)])</code></pre><p style=text-align:start>不单单可以将字符串作为字典的键，实际上您<strong>可以将所有不可变的类型作为字典的键</strong></p><pre><code># 在这个例子中，我们先以字符串作为键、再以数字作为键，最后以元组作为键# 在本文后面的篇章，您会知道字符串、数字和元组都是不可变的数据类型a = {'1': 'a', 2: 'b', (3,): 'c'}print(a) # {'1': 'a', 2: 'b', (3,): 'c'}print(a['1']) # 'a'print(a[2]) # 'b'print(a[(3,)] # 'c'</code></pre><p style=text-align:start><strong>字典的键是唯一(同样的键只能出现一次)的，值可以重复</strong></p><pre><code># 检验键的唯一性，我们先后定义了键'a'，并把它们对应了不同的值a = {'a':1, 'a':2}print(a) # {'a': 2}# 可以看到字典只保留了最后一个键值对'a':2# 就像书一样，它不可能出现两个页码相同的书页# 检验值的可重复b = {'a':1, 'b':1}print(b) # {'a':1, 'b':1}# 没问题，在字典中，值是可以相同的# 就像书的不同目录可以指向同一页书一样</code></pre><p style=text-align:start><strong>字典不支持+、*号操作符，但支持in，不同的是in是用来检测某个值是否存在于字典的键中，而不是值</strong></p><pre><code>a = {'a':1, 'a':2}# 字符串'a'在字典a的键中吗'a' in a # True# 字符串'c'在字典a的键中吗'c' in a # False</code></pre><p style=text-align:start>仰望未来，听说在<strong>python3.9</strong>版本中，字典的合并支持以竖线|操作符来实现</p><p style=text-align:start>或利用|=进行原地更新，效果与字典的update方法有点类似</p><pre><code># | 操作符会构建一个新的字典a = {'a':1}b = {'b':2}c = a | bprint(c) # {'a': 1, 'b': 2}# |= 操作符会原地更新至aa|=bprint(a) # {'a': 1, 'b': 2}</code></pre><p style=text-align:start>如果在python3.9以前的版本，比如python3.8.3，一般这样来达到同样目的</p><pre><code># 以下效果相当于py39中的|a = {}b = {'a':1}c = {'b':2}a.update(b)a.update(c)print(a) # {'a': 1, 'b': 2}# 以下效果相当于py39中的|=b.update(c)print(b) # {'a': 1, 'b': 2}</code></pre><p style=text-align:start><strong>如果您看不懂上述py39的新特性，无需理会，因为暂时并不重要，我们专注于py3.8.3就可以了</strong></p><h1 class=pgc-h-arrow-right>集合(Set)</h1><blockquote><p>python的集合(set)与数学概念上的集合同样具有三个特性，确定性、互异性、无序性在python中，集合一般用于删除重复元素或进行成员关系测试集合的表示，与字典有点相似，都是用花括号 {} 括住，然后逗号 , 分隔其中每一个成员</p></blockquote><h1 class=pgc-h-arrow-right>集合的创建与特性</h1><pre><code>a = {1,2,3} # 创建一个长度为3的集合print(a) # {1,2,3}# 集合的确定性: 一个元素要么属于一个集合，要么不属于，只有这两种情况# 利用in操作符来查看一个元素是否属于该集合print(1 in a) # Trueprint(4 in a) # False# 集合的互异性: 一个集合内的元素必定不会重复b = {1,1,1,2,2,3,3} # 创建时包含重复元素# 可以看到多余的1、2、3已被去除print(b) # {1, 2, 3}# 集合的无序性: 元素之间是无序的c = {3, 1, 2}# 顺序已发生变化print(c) # {1, 2, 3}# 看看集合a与集合c是否相等，==是相等比较符，它用于比较左右两边是否相等，返回True或Falseprint(a == c) # True</code></pre><p style=text-align:start><strong>有一种集合叫空集，您不能以{}来定义空集，因为{}会被python解释器认为是空字典，只能用内置函数set来定义空集</strong></p><pre><code>a = set() # 创建一个空集合print(a) # 输出: set()，以表示其为一个空集# 可以把字符串、列表、元组等可迭代类型传递给内置函数set，来创建一个集合b = [1,2,3]c = set(a)print(c) # {1, 2, 3}d = set('hello,world')print(d) # {'w', 'e', 'o', ',', 'h', 'r', 'l', 'd'}</code></pre><h1 class=pgc-h-arrow-right>集合的基本操作</h1><p style=text-align:start>增加元素</p><pre><code>a = {1, 2}# 利用集合的add方法，增加一个元素a.add(3)print(a) # {1, 2, 3}# 利用集合的update方法，增加多个元素# update方法接受一个可迭代类型a.update([4,5])print(a) # {1, 2, 3, 4, 5}</code></pre><p style=text-align:start>删除元素</p><pre><code>a = {1, 2, 3}# 利用集合remove方法，删除值等于所给值的元素a.remove(3)print(a) # {1, 2}# 利用集合的pop方法，随机删除其中一个元素a.pop()print(a) # {2}# 利用集合的clear方法，来让其变为空集a.clear()print(a) # set()</code></pre><h1 class=pgc-h-arrow-right>集合的基本运算</h1><blockquote><p>集合不支持+与*号操作符，但是它有它自己独有的运算</p></blockquote><pre><code>a = {1,2,3}b = {3,4,5}# 交集: 你有我也有# 求交集用&amp;符号print(a &amp; b) # {3}# 并集: 我有的加上你有的# 求并集用|符号print(a | b) # {1, 2, 3, 4, 5}# 差集: 我有你没有# 求差集用-减号print(a - b) # {1, 2}# 异或集：去掉大家都有的，然后再加起来# 求异或用^符号print(a ^ b) # {1, 2, 4, 5}# 子集: 我有的，你全都有，那我就是你的子集，你就是我的超集# 判断一个集合是否为另一个集合的子集，用大于等于&gt;=或小于等于&lt;=符号print({1,2} &lt;= {1,2,3}) # Trueprint({1,2,3} &gt;= {1,2,3}) # True# 真子集: 我有的，你全都有，而且还有我没有的，那我就是你的真子集，你就是我的真超集# 判断一个集合是否为另一个集合的真子集，用大于&gt;或小于&lt;符号print({1,2,3} &lt; {1,2,3}) # Falseprint({1,2} &lt; {1,2,3}) # True</code></pre><h1 class=pgc-h-arrow-right>可变与不可变类型</h1><p style=text-align:start>在以上6种基本数据类型，如果以是否可变来分类，可以分为两类</p><h1 class=pgc-h-arrow-right>可变类型(mutable)</h1><blockquote><p>它元素的值是可以改变的，也叫做<strong>引用类型</strong></p></blockquote><ul><li>列表(list)</li><li>字典(dictionary)</li><li>集合(set)</li></ul><h1 class=pgc-h-arrow-right>不可变类型(immutable)</h1><blockquote><p>元素是不可改变的，要改变只能重新赋值来覆盖，也叫做<strong>值类型</strong></p></blockquote><ul><li>数字(number)</li><li>字符串(string)</li><li>元组(tuple)</li></ul><p style=text-align:start>我们可以用python内置函数id来获取目标对象存放在内存中的地址</p><pre><code># 可变a = [1, 2]b = {'a':1}c = {1, 2}# 不可变d = 3.14e = 'hello'f = (1, 2)# 利用id来获取目标在内存中的地址# 注意不同的运行环境，会有不同的结果，但是效果一样print(id(a)) # 140042188515456# 改变a内元素的值a[0] = 100print(a) # [100, 2]# 再次查看其内存地址，如果没有变化，证明还是同一个数据，但是它的内容却变化了，所以说是可变类型print(id(a)) # 140042188515456# 看看字符串的idprint(id(e)) # 140042188516848# 尝试改变字符串内的某个字符# &gt;&gt;&gt; e[0]='f'# Traceback (most recent call last):#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;# TypeError: 'str' object does not support item assignment# 会报错，提示字符串不能被改变# 重新赋值变量e另外一个字符串e = 'i see'# 看看id，已经发生变化，所以不再是同一个数据了，所以叫不可变类型print(id(e)) # 140042188516272</code></pre><h1 class=pgc-h-arrow-right>再论变量</h1><blockquote><p>如果您之前学过别的编程语言，比如C或C++，您会发现，在python中，不需要事先声明变量，只需要在使用前给变量赋值即可，所以我们把python称作弱类型语言，而把C或C++等称作强类型语言变量并不等于以上各种基本数据类型，如果您把一个数据类型赋值给一个变量，变量所做的工作只是帮您找到那个类型而已，如果把数据类型比作一栋建筑，那么变量只是指向它的路标用一个等号=来给变量赋值，它的左边是变量的命名，右边是变量指向的类型，要注意两个等号==是比较运算符</p></blockquote><p style=text-align:start>可以用多个变量指向同一个数据</p><pre><code># 变量a指向字符串a = '我是一个字符串'# 也令变量b指向同一个字符串b = a# 现在有两个变量指向同一个字符串了# 相等比较运算符，它的作用是比较变量指向的值是否相等print(a == b) # True</code></pre><p style=text-align:start><strong>与==不同，它是比较值是否相等，如果要查看是否同一个数据，可以用is操作符</strong></p><p style=text-align:start><strong>事实上，is操作符是比较两者内置函数id的结果是否相等</strong></p><pre><code>a = 'abc'b = 'abc'c = a# 值都相等print(a == b) # Trueprint(a == c) # True# 但a与b并不是同一个数据print(a is b) # False# a与c是同一个数据print(a is c) # True# 又比如d = [1,2]e = [1,2]f = d# 变量d与f是指向同一个数据，且它们指向的是引用类型(可变类型)# 如果改变dd[0] = 100print(d) # [100, 2]# f会发生变化，因为它们指向的是同一个数据print(f) # [100, 2]# 改变ee[0] = 200print(e) # [200, 2]# d还是原样print(d) # [100, 2]# 因为一开始赋值时，d与e的值虽然相等，但它们并不是同一个数据print(d is e) # Falseprint(id(d) == id(e)) # False</code></pre><p style=text-align:start>如果把一个数据类型比作一栋建筑，变量比作找到它的方式，假如现在有两个变量指向那栋建筑，其中一个变量是高德地图，另外一个变量是祖传指南针，通过它们俩，我们都能找到那栋建筑</p><p style=text-align:start>如果出了啥意外，两个变量都找不到那栋建筑了，会怎样？</p><p style=text-align:start>我们一开始只有两种方法找到那栋建筑，通过高德地图或祖传指南针，现在它们都失灵了，那我们人类也就再也找不到那栋建筑了，久而久之，那栋建筑就会因为风化、年久失修而被摧毁，就没了...没了...</p><p style=text-align:start><strong>我们可以通过del来删除一个变量</strong></p><pre><code># 1是那栋建筑a = 1b = a# 现在有两种方式找到它# 通过aprint(a) # 1# 或是通过bprint(b) # 1# 把变量a给弄没del a# print(a) 将会报错，提示没有该变量# 现在还能通过b来找到那栋建筑1print(b) # 1# 把变量b也给弄没del b# 好了，再也找不到建筑1了# 它迟早会被风化毁掉!!</code></pre><h1 class=pgc-h-arrow-right>多个变量赋值</h1><blockquote><p>您可以通过两种方式给多个变量赋值</p></blockquote><pre><code># 可以同时为多个变量赋给同一值a = b = c = 1# print函数用逗号分隔多个，可以同时打印输出多个值print(a, b, c) # 1 1 1print(a is b) # Trueprint(a is c) # Trueprint(b is c) # True# 可以同时为多个变量赋给不同值d, e, f = 1, 2, 3print(d, e, f) # 1 2 3</code></pre><h1 class=pgc-h-arrow-right>变量的命名法</h1><blockquote><p>变量的命名法也可以叫做变量的命名规范，它与变量的命名规则不一样，规则就像法律，你必须遵守，但规范就像道德，只是建议最好这样做</p></blockquote><p style=text-align:start>经典命名法一览</p><pre><code># 驼峰命名法：首字母小写，其余首字母大写handsomeMan = 'you'# 帕斯卡命名法：首字母皆为大写HandsomeMan = 'you'# 匈牙利命名法# 匈牙利命名法是早期的规范，由微软的一个匈牙利人发明的，是 IDE 还十分智障的年代的产物。那个年代，当代码量很多的时候，想要确定一个变量的类# 型是很麻烦的，不像现在 IDE 都会给提示，所以才产生了这样一个命名规范，估计现在已经没啥人用了吧……一个十分系统却又琐碎的命名规范。# 该命名规范，要求前缀字母用变量类型的缩写，其余部分用变量的英文或英文的缩写，单词第一个字母大写。iMyAge = 18 # "i": intfMyHeight = 180  # "f": float# 蛇型命名法：以下划线_连接单词handsome_man = 'you'</code></pre><p style=text-align:start><strong>python推荐蛇型命名法，因为python的中文名叫蟒蛇，它的图标就是一条蛇</strong></p><div class=pgc-img><img alt=Python零基础入门-数据类型与变量 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f015d2cb5860441186ce1d55d39f641e><p class=pgc-img-caption></p></div><p style=text-align:start>学到后面，您会发现，python很多魔法属性都有下划线的踪影</p><h1 class=pgc-h-arrow-right>总结</h1><ol start=1><li>初步掌握python的6种基本类型</li><li>了解变量的本质</li><li>了解各种变量命名规范</li></ol></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'Python','零基','入门'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../cn/%E7%A7%91%E6%8A%80/4ffeb1fa.html alt=Python零基础入门之Python变量与字符串 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ef4cc11e47994781bc4789061c903fcd style=border-radius:25px></a>
<a href=../../cn/%E7%A7%91%E6%8A%80/4ffeb1fa.html title=Python零基础入门之Python变量与字符串>Python零基础入门之Python变量与字符串</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>