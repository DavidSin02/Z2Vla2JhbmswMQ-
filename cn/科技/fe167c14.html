<!doctype html><html lang=cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>bash中常见特殊字符使用大全 | 极客快訊</title><meta property="og:title" content="bash中常见特殊字符使用大全 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="cn"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/fe167c14.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/fe167c14.html><meta property="article:published_time" content="2020-11-14T21:01:00+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:00+08:00"><meta name=Keywords content><meta name=description content="bash中常见特殊字符使用大全"><meta name=author content="极客快訊"><meta property="og:url" content="/cn/%E7%A7%91%E6%8A%80/fe167c14.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快讯 Geek Bank</a></h1><p class=description>为你带来最全的科技知识 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>bash中常见特殊字符使用大全</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=cn/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>#</p><p class=ql-align-justify>注释符号(Hashmark)</p><p class=ql-align-justify>1.在shell文件的行首，作为shell调用解释器标记，#!/bin/bash;</p><p class=ql-align-justify>2. 在配置文件中作为注释使用，在一行中，#后面的内容并不会被执行</p><p class=ql-align-justify>;</p><p class=ql-align-justify>作为多命令的分隔符(Command separator [semicolon])。</p><p class=ql-align-justify>多个命令要放在同一行的时候，可以使用分号分隔。</p><p class=ql-align-justify>;;</p><p class=ql-align-justify>连续分号(Terminator [double semicolon])。</p><p class=ql-align-justify>在使用case选项的时候，作为每个选项的终结符。</p><p class=ql-align-justify>.</p><p class=ql-align-justify>点号(dot command)。</p><p class=ql-align-justify>1. 执行当前目录文件</p><p class=ql-align-justify>#!/bin/bash</p><p class=ql-align-justify>.pythontab-file</p><p class=ql-align-justify>2. 作为文件名的一部分，在文件名的开头，表示该文件为隐藏文件</p><p class=ql-align-justify>3. 作为目录名，一个点代表当前目录，两个点号代表上层目录（当前目录的父目录）。注意，两个以上的点不出现，除非你用引号（单/双）包围作为点号字符本身；</p><p class=ql-align-justify>4. 正则表达式中，点号表示任意一个字符。</p><p class=ql-align-justify>"</p><p class=ql-align-justify>双引号（double quotation marks）。</p><p class=ql-align-justify>部分引用。双引号包围的内容可以允许变量扩展，也允许转义字符的存在。</p><p class=ql-align-justify>'</p><p class=ql-align-justify>单引号(full quoting [single quote])。</p><p class=ql-align-justify>单引号括住的内容，所有字符均作为字符本身处理,</p><p class=ql-align-justify>逗号(comma operator [comma])。</p><p class=ql-align-justify>1. 用在连接一连串的数学表达式中，这串数学表达式均被求值，但只有最后一个求值结果被返回。如：</p><p class=ql-align-justify>#!/bin/bash</p><p class=ql-align-justify>lett1=((a=5+1, b=7+2))</p><p class=ql-align-justify>echot1=$t1, a=$a, b=$b</p><p class=ql-align-justify>##这个$t1=$b；</p><p class=ql-align-justify>\</p><p class=ql-align-justify>反斜线，反斜杆(escape [backslash])。</p><p class=ql-align-justify>1. 放在特殊符号之前，转义特殊符号的作用，仅表示特殊符号本身，这在字符串中常用；</p><p class=ql-align-justify>2. 放在一行指令的最末端，表示紧接着的回车无效（其实也就是转义了Enter），后继新行的输入仍然作为当前指令的一部分。</p><p class=ql-align-justify>/</p><p class=ql-align-justify>斜线，斜杆（Filename path separator [forward slash]）。</p><p class=ql-align-justify>1.作为路径的分隔符，路径中仅有一个斜杆表示根目录，以斜杆开头的路径表示从根目录开始的路径；</p><p class=ql-align-justify>2.在作为运算符的时候，表示除法符号。如：a=4/2</p><p class=ql-align-justify>`</p><p class=ql-align-justify>反引号，后引号（Command substitution[backquotes])。</p><p class=ql-align-justify>命令替换。这个引号包围的为命令，可以执行包围的命令，并将执行的结果赋值给变量。如：a=`dirname '/tmp/x.log'` 。后面dirname返回的结果会赋值给a，注意，此处Mitchell特地使用了反引号和单引号，注意区别。</p><p class=ql-align-justify>:</p><p class=ql-align-justify>冒号(null command [colon])。</p><p class=ql-align-justify>空命令，这个命令什么都不做，但是有返回值，返回值为0（即：true）。这个命令的作用非常奇妙。</p><p class=ql-align-justify>1. 可做while死循环的条件；</p><p class=ql-align-justify>2. 在if分支中作为占位符（即某一分支什么都不做的时候）；</p><p class=ql-align-justify>3. 放在必须要有两元操作的地方作为分隔符，如：:${username=`whoami`}</p><p class=ql-align-justify>4. 在参数替换中为字符串变量赋值，在重定向操作(>)中，把一个文件长度截断为0（:>>这样用的时候，目标存在则什么都不做），这个只能在普通文件中使用，不能在管道，符号链接和其他特殊文件中使用；</p><p class=ql-align-justify>5. 甚至你可以用来注释（#后的内容不会被检查，但:后的内容会被检查，如果有语句如果出现语法错误，则会报错）；</p><p class=ql-align-justify>6. 你也可以作为域分隔符，比如环境变量$PATH中，或者passwd中，都有冒号的作为域分隔符的存在；</p><p class=ql-align-justify>7. 你也可以将冒号作为函数名，不过这个会将冒号的本来意义转变（如果你不小心作为函数名，你可以使用unset -f : 来取消function的定义）。</p><p class=ql-align-justify>!</p><p class=ql-align-justify>感叹号（reverse (or negate) [bang],[exclamation mark])。</p><p class=ql-align-justify>取反一个测试结果或退出状态。</p><p class=ql-align-justify>1. 表示反逻辑，比如后面的!=,这个是表示不等于；</p><p class=ql-align-justify>2. 表示取反，如：ls a[!0-9] #表示a后面不是紧接一个数字的文件；</p><p class=ql-align-justify>3. 在不同的环境里面，感叹号也可以出现在间接变量引用里面；</p><p class=ql-align-justify>4. 在命令行中，可以用于历史命令机制的调用，你可以试试!$,!#，或者!-3看看，不过要注意，这点特性不能在脚本文件里面使用（被禁用）。</p><p class=ql-align-justify>*</p><p class=ql-align-justify>星号（wildcard/arithmetic operator[asterisk])。</p><p class=ql-align-justify>1. 作为匹配文件名扩展的一个通配符，能自动匹配给定目录下的每一个文件；</p><p class=ql-align-justify>2. 正则表达式中可以作为字符限定符，表示其前面的匹配规则匹配任意次；</p><p class=ql-align-justify>3. 算术运算中表示乘法。</p><p class=ql-align-justify>**</p><p class=ql-align-justify>双星号(double asterisk)。算术运算中表示求幂运算。</p><p class=ql-align-justify>?</p><p class=ql-align-justify>问号（test operator/wildcard[Question mark])。</p><p class=ql-align-justify>1. 表示条件测试；</p><p class=ql-align-justify>2. 在双括号内表示C风格的三元操作符((condition?true-result:false-result))；</p><p class=ql-align-justify>3. 参数替换表达式中用来测试一个变量是否设置了值；</p><p class=ql-align-justify>4. 作为通配符，用于匹配文件名扩展特性中，用于匹配单个字符；</p><p class=ql-align-justify>5. 正则表达式中，表示匹配其前面规则0次或者1次。</p><p class=ql-align-justify>$</p><p class=ql-align-justify>美元符号(Variable substitution[Dollar sign])。</p><p class=ql-align-justify>1. 作为变量的前导符，用作变量替换，即引用一个变量的内容，比如：echo $PATH；</p><p class=ql-align-justify>2. 在正则表达式中被定义为行末（End ofline）。</p><p class=ql-align-justify>${}</p><p class=ql-align-justify>参数替换(Variable substitution)。</p><p class=ql-align-justify>用于在字符串中表示变量。</p><p class=ql-align-justify>$‘...’</p><p class=ql-align-justify>引用内容展开，执行单引号内的转义内容（单引号原本是原样引用的），这种方式会将引号内的一个或者多个[\]转义后的八进制，十六进制值展开到ASCII或Unicode字符。</p><p class=ql-align-justify>$*</p><p class=ql-align-justify>$@</p><p class=ql-align-justify>位置参数(Positional Parameters)。</p><p class=ql-align-justify>这个在使用脚本文件的时候，在传递参数的时候会用到。两者都能返回调用脚本文件的所有参数，但$*是将所有参数作为一个整体返回（字符串），而$@ 是将每个参数作为单元返回一个参数列表。注意，在使用的时候需要用双引号将$*,$@括住。这两个变量受到$IFS的影响，如果在实际应用中，要考虑其中的一些细节。</p><p class=ql-align-justify>$#</p><p class=ql-align-justify>表示传递给脚本的参数数量。</p><p class=ql-align-justify>$?</p><p class=ql-align-justify>此变量值在使用的时候，返回的是最后一个命令、函数、或脚本的退出状态码值，如果没有错误则是0，如果为非0，则表示在此之前的最后一次执行有错误。</p><p class=ql-align-justify>$$</p><p class=ql-align-justify>进程ID变量，这个变量保存了运行当前脚本的进程ID值。</p><p class=ql-align-justify>()</p><p class=ql-align-justify>圆括号(parentheses)。</p><p class=ql-align-justify>1， 命令组（Command group）。由一组圆括号括起来的命令是命令组，命令组中的命令实在子shell（subshell）中执行。因为是在子shell内运行，因此在括号外面是没有办法获取括号内变量的值，但反过来，命令组内是可以获取到外面的值，这点有点像局部变量和全局变量的关系，在实作中，如果碰到要cd到子目录操作，并在操作完成后要返回到当前目录的时候，可以考虑使用subshell来处理；</p><p class=ql-align-justify>2. 用于数组的初始化。</p><p class=ql-align-justify>{x,y,z,...}</p><p class=ql-align-justify>花括号扩展(Brace Expansion)。</p><p class=ql-align-justify>在命令中可以用这种扩展来扩展参数列表，命令将会依照列表中的括号分隔开的模式进行匹配扩展。注意的一点是，这花括号扩展中不能有空格存在，如果确实有必要空格，则必须被转义或者使用引号来引用。例子：echo {a,b,c}-{\ d," e",' f'}</p><p class=ql-align-justify>{a..z}</p><p class=ql-align-justify>在Bash version 3时添加了这种花括号扩展的扩展，可以使用{A..Z}表示A-Z的所有字符列表，这种方式的扩展Mitchell测试了一下，好像仅适用于A-Z，a-z，还有数字{最小..最大}的这种方式扩展。</p><p class=ql-align-justify>{}</p><p class=ql-align-justify>代码块(curly brackets)。</p><p class=ql-align-justify>这个是匿名函数，但是又与函数不同，在代码块里面的变量在代码块后面仍能访问。注意：花括号内侧需要有空格与语句分隔。另外，在xargs -i中的话，还可以作为文本的占位符，用以标记输出文本的位置。</p><p class=ql-align-justify>{} \;</p><p class=ql-align-justify>这个{}是表示路径名，这个并不是shell内建的，现在接触到的情况看，好像只用在find命令里。注意后面的分号，这个是结束find命令中-exec选项的命令序列，在实际使用的时候，要转义一下以免被shell理解错误。</p><p class=ql-align-justify>[]</p><p class=ql-align-justify>中括号（brackets）。</p><p class=ql-align-justify>1. 测试的表示，Shell会测试在[]内的表达式，需要注意的是，[]是Shell内建的测试的一部分，而非使用外部命令/usr/bin/test的链接；</p><p class=ql-align-justify>2. 在数组的上下文中，表示数组元素，方括号内填上数组元素的位置就能获得对应位置的内容，如：</p><p class=ql-align-justify>1. Array[1]=xxx</p><p class=ql-align-justify>2. echo${Array[1]};</p><p class=ql-align-justify>3. 表示字符集的范围，在正表达式中，方括号表示该位置可以匹配的字符集范围。</p><p class=ql-align-justify>[[]]</p><p class=ql-align-justify>双中括号(double brackets)。</p><p class=ql-align-justify>这个结构也是测试，测试[[]]之中的表达式(Shell的关键字)。这个比单中括号更能防止脚本里面的逻辑错误，比如：&&,||,&lt;,>操作符能在一个[[]]里面测试通过，但是在[]却不能通过。[[]]里面没有文件名扩展(filename expansion）或是词分隔符(Word splitting)，但是可以用参数扩展(Parameter expansion)和命令替换(command substitution)。不用文件名通配符和像空白这样的分隔符。注意，这里面如果出现了八进制，十六进制等，shell会自动执行转换比较。</p><p class=ql-align-justify>$[...]</p><p class=ql-align-justify>词表达表示整数扩展(integer expansion)。</p><p class=ql-align-justify>在方括号里面执行整数表达式。例：</p><p class=ql-align-justify>1. a=3</p><p class=ql-align-justify>2. b=7</p><p class=ql-align-justify>3. echo$[$a+$b]</p><p class=ql-align-justify>4. echo$[$a*$b]</p><p class=ql-align-justify>5. ##返回是10和21</p><p class=ql-align-justify>(())</p><p class=ql-align-justify>双括号(double parentheses)。</p><p class=ql-align-justify>表示整数扩展（integer expansion）。</p><p class=ql-align-justify>在双括号结构中，所有表达式可以像c语言一样，如：a++,b--等。</p><p class=ql-align-justify>在双括号结构中，所有变量可以不加入：“$”符号前缀。</p><p class=ql-align-justify>双括号可以进行逻辑运算，四则运算</p><p class=ql-align-justify>双括号结构扩展了for，while,if条件测试运算</p><p class=ql-align-justify>支持多个表达式运算，各个表达式之间用“，”分开</p><p class=ql-align-justify></p><p class=ql-align-justify>></p><p class=ql-align-justify>&&lt;</p><p class=ql-align-justify>>&</p><p class=ql-align-justify>>></p><p class=ql-align-justify>&lt;</p><p class=ql-align-justify>&lt;></p><p class=ql-align-justify>重定向(redirection)。</p><p class=ql-align-justify>scriptname >filename 重定向scriptname的输出到文件filename中去，如果filename文件存在则覆盖原来文件；</p><p class=ql-align-justify>command &>filename 重定向command的标准输出(stdout)和标准错误(stderr)到文件filename中；</p><p class=ql-align-justify>command >&2 把command的标准输出(stdout)重定向到标准错误(stderr)中；</p><p class=ql-align-justify>scriptname >>filename 把scriptname的输出（同>)追加到文件filename中，如果文件不存在则创建。一个>表示文件存在就覆盖，不存在就创建，两个>>表示不存在就创建，存在就在原有基础上增加</p><p class=ql-align-justify>[i]&lt;>filename 打开filename这个文件用来读或者写，并且给文件指定i为它的文件描述符(file descriptor)，文件不存在就会创建。</p><p class=ql-align-justify>&lt;&lt;</p><p class=ql-align-justify>双小于号(here-document[double less then marks])。</p><p class=ql-align-justify>这个也被称为Here-document，用来将后继的内容重定向到左侧命令的stdin中。&lt;&lt;可以节省格式化时间，别且使命令执行的处理更容易。在实作的时候只需要输入&lt;&lt;和终止标志符，而后（一般是回车后）你就可以输入任何内容，只要在最后的新行中输入终止标志符，即可完成数据的导入。使用here-document的时候，你可以保留空格，换行等。如果要让shell脚本更整洁一点，可以在&lt;&lt;和终止符之间放上一个连字符(-)。</p><p class=ql-align-justify>&lt;&lt;&lt;</p><p class=ql-align-justify>三个小于号(here-strings)。Here-字串和Here-document类似，here-strings语法：command [args] &lt;&lt;&lt;["]$word["]；$word会展开并作为command的stdin。</p><p class=ql-align-justify>\&lt;...\></p><p class=ql-align-justify>词界符(word boundary)。</p><p class=ql-align-justify>这个是用在正则表达式中的一个特殊分隔符，用来标记单词的分界。比如：the会匹配there，another，them等等，如果仅仅要匹配the，就可以使用这个词界符，\&lt;the\>就只能匹配the了。</p><p class=ql-align-justify>|</p><p class=ql-align-justify>管道(pipe)。管道是Linux，Unix都有的概念，是非常基础，也是非常重要的一个概念。它的作用是将管道前（左边）的命令产生的输出(stdout)作为管道后（右边）的命令的输入(stdin)。如：ls | wc l，使用管道就可以将命令连接在一起。注意：管道是每一个进程的标准输出都会作为下一个命令的标准输入，期间的标准输出不能跨越管道作为后继命令的标准输入，如： cat filename | ls -al | sort 。想想这个的输出? 同时，管道是以子进程来运行的，所以管道并不能引起变量改变。</p><p class=ql-align-justify>>|</p><p class=ql-align-justify>强制重定向(force redirection)。</p><p class=ql-align-justify>这会强制重写已经存在的文件。</p><p class=ql-align-justify>&</p><p class=ql-align-justify>与号(Run job in background[ampersand])。</p><p class=ql-align-justify>如果命令后面跟上一个&符号，这个命令将会在后台运行。</p><p class=ql-align-justify>&&</p><p class=ql-align-justify>||</p><p class=ql-align-justify>逻辑操作符(logical operator)。</p><p class=ql-align-justify>在测试结构中，可以用这两个操作符来进行连接两个逻辑值。||是当测试条件有一个为真时返回0（真），全假为假；&&是当测试条件两个都为真时返回真(0)，有假为假。</p><p class=ql-align-justify>-</p><p class=ql-align-justify>减号，连字符(Hyphen/minus/dash)。</p><p class=ql-align-justify>1. 作为选项，前缀[option,prefix]使用。</p><p class=ql-align-justify>2. 用于stdin或者stdout的重定向的源或目的[dash].在tar没有bunzip2的程序补丁时，我们可以这样： bunzip2 linux-2.6.13.tar.bz2 | tar xvf - 。将前面解压的数据作为tar的标准输入（这里使用一个-表示）</p><p class=ql-align-justify>注意：在实作的时候，如果文件名是以[-]开头的，那么在加上这个作为定向操作符的时候，可能会出错，此时应该为文件加上合适的前缀路径，以避免这种情况发生，同样的，在echo变量的时候，如果变量是以[-]开始，那么可能也会产生意想不到的结果，为了保险起见，可以使用双引号引用标量：</p><p class=ql-align-justify>var="-n"</p><p class=ql-align-justify>echo$var</p><p class=ql-align-justify>##试试看有什么输出？</p><p class=ql-align-justify>还有，这种表示方法不是Bash内建的，要达到此点的这种效果，需要看你使用的软件是否支持这种操作；</p><p class=ql-align-justify>3. 表示先前的工作目录(previousworking directory)，因此，如果你cd到其他目录下要放回前一个路径的时候，可以使用cd -来达到目的，其实，这里的[-]使用的是环境变量的$OLDPWD，注意：这里的[-]和前一点是不同的；</p><p class=ql-align-justify>4. 减号或者负号，用在算术操作中。</p><p class=ql-align-justify>=</p><p class=ql-align-justify>等号(Equals)。</p><p class=ql-align-justify>1. 赋值操作，给变量赋值，么有空格在等号两侧；</p><p class=ql-align-justify>2. 在比较测试中作为比较符出现，这里要注意，如果在中括号中作为比较出现，需要有空格符在等号左右两侧。</p><p class=ql-align-justify>+</p><p class=ql-align-justify>加号(Plus)。</p><p class=ql-align-justify>1. 算术操作符，表示加法；</p><p class=ql-align-justify>2. 在正则表达式中，表示的是其前的这个匹配规则匹配最少一次;</p><p class=ql-align-justify>3.在命令或过滤器中作为选项标记，在某些命令或者内置命令中使用+来启用某些选项，使用-来禁止；</p><p class=ql-align-justify>4. 在参数替换(parametersubstitution)中，+前缀表示替代值(当变量为空的时候，使用+后面的值)</p><p class=ql-align-justify>%</p><p class=ql-align-justify>百分号(modulo[percent sign])。</p><p class=ql-align-justify>1.在算术运算中，这个是求模操作符，即两个数进行除法运算后的余数；</p><p class=ql-align-justify>2. 在参数替换(parametersubstitution)中，可以作为模式匹配。例子：</p><p class=ql-align-justify>p=b*9</p><p class=ql-align-justify>var="abcd12345abc479"</p><p class=ql-align-justify>echo${var%p}, ${var%%p}</p><p class=ql-align-justify>##从右边开始查找(想想从左是那个符号?)</p><p class=ql-align-justify>##任何在b和9之间的内容（含）</p><p class=ql-align-justify>##第一个是找到最短的符合匹配项</p><p class=ql-align-justify>##后一个是找最大符合的匹配项（贪婪匹配?)</p><p class=ql-align-justify>~</p><p class=ql-align-justify>波浪号(Home directory[tilde])。</p><p class=ql-align-justify>这个和内部变量$HOME是一样的。默认表示当前用户的家目录（主目录），这个和~/效果一致，如果波浪号后面跟用户名，表示是该用户的家目录。</p><p class=ql-align-justify>^</p><p class=ql-align-justify>脱字符(caret)。</p><p class=ql-align-justify>1. 在正则表达式中，作为一行的行首(beginning-of-line)位置标志符；</p><p class=ql-align-justify>2. 在参数替换(Parametersubstitution)中，这个用法有两种，一个脱字符(${var^})，或两个(${var^^})，分别表示第一个字母大写，全部大写的意思(Bash version >=4)。</p><p class=ql-align-justify>空白</p><p class=ql-align-justify>空白符(Whitespace)。</p><p class=ql-align-justify>空白符不仅仅是指空格(spaces)，还包括制表符(tabs)，空行(blank lines)，或者这几种的组合。可用做函数的分隔符,分隔命令或变量，空行不会影响脚本的行为，因此可以用它来规划脚本代码，以增加可读性，在内置的特殊变量$IFS可以用来针对某些命令进行输入的参数进行分割，其默认就是空白符。在字符串或变量中如果有空白符，可以使用引号来规避可能的错误。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>'bash','特殊字符','大全'</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;ga('create','UA-146415161-2','auto');ga('send','pageview');}</script><script async src=https://www.google-analytics.com/analytics.js></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>