<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux內核學習014——進程調度(三) | 极客快訊</title><meta property="og:title" content="Linux內核學習014——進程調度(三) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/955a771b-0d01-4f97-8b1f-8575d578bd06"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/0a7b85a7.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/0a7b85a7.html><meta property="article:published_time" content="2020-11-14T20:53:31+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:31+08:00"><meta name=Keywords content><meta name=description content="Linux內核學習014——進程調度(三)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/0a7b85a7.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux內核學習014——進程調度(三)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Linux內核學習014——進程調度(三) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/955a771b-0d01-4f97-8b1f-8575d578bd06><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>Linux調度算法</h1><p>在Linux中，調度器是以模塊方式提供的，這樣可以允許不同類型的進程有針對性地選擇調度算法。這種模塊化結構稱為調度器類，其允許多種不同的可動態添加的調度算法並存，調度屬於自己範疇的進程。每個調度器有一個優先級，基礎調度器會依優先級遍歷調度類，擁有最高優先級的調度器類選擇將要執行的程序。</p><p>CFS就是一個調度器類，在Linux中稱為SCHED_NORMAL，其具體定義在Linux2.6.34/kernel/sched_fair.c中。</p><p>CFS的理念很簡單：進程調度的效果應如同系統具備一個理想中的完美多任務處理器。即每個進程可獲得1/n的處理器時間(n為可運行的進程數量)。但是，由於調度時進程搶佔的開銷，比如：進程換入、進程換出、緩存影響等，理想模型是無法實現的。因此，CFS充分考慮了額外開銷，確保了系統性能不受影響。CFS的做法是：允許每個進程運行一段時間，循環輪轉，選擇運行最少的進程作為下一個運行進程，而不是分配每個進程以時間片。nice值在CFS中被作為進程獲得處理器運行比得權重(高nice值，低優先級，低處理器使用權重)。當可運行進程數量過多時，它們各自所獲得的處理器使用比和時間片都趨於0，CFS為此設立了最小粒度，默認值為1ms。</p><p>總結：任何進程所獲得的處理器時間是由它自己和其他所有可運行進程nice值的相對比例決定的。</p><h1 class=pgc-h-arrow-right>Linux調度的實現</h1><p>CFS具體實現位於kernel/schde_fair.c，其中需要重點關注的是四個組成部分：</p><ol start=1><li>時間記賬</li><li>進程選擇</li><li>調度器入口</li><li>睡眠和喚醒</li></ol><h1 class=pgc-h-arrow-right>時間記賬</h1><p>顯然，所有的調度器都必須記錄進程的運行時間。CFS中使用一個結構體sched_entity來記錄進程運行信息，其定義在Linux2.6.34/include/linux/sched.h#L1090：</p><pre><code>/* * CFS stats for a schedulable entity (task, task-group etc) * * Current field usage histogram: * *     4 se-&gt;block_start *     4 se-&gt;run_node *     4 se-&gt;sleep_start *     6 se-&gt;load.weight */struct sched_entity {    struct load_weight  load;       /* for load-balancing */    struct rb_node      run_node;    struct list_head    group_node;    unsigned int        on_rq;    u64         exec_start;    u64         sum_exec_runtime;    u64         vruntime;    u64         prev_sum_exec_runtime;    u64         last_wakeup;    u64         avg_overlap;    u64         nr_migrations;    u64         start_runtime;    u64         avg_wakeup;#ifdef CONFIG_SCHEDSTATS    u64         wait_start;    u64         wait_max;    u64         wait_count;    u64         wait_sum;    u64         iowait_count;    u64         iowait_sum;    u64         sleep_start;    u64         sleep_max;    s64         sum_sleep_runtime;    u64         block_start;    u64         block_max;    u64         exec_max;    u64         slice_max;    u64         nr_migrations_cold;    u64         nr_failed_migrations_affine;    u64         nr_failed_migrations_running;    u64         nr_failed_migrations_hot;    u64         nr_forced_migrations;    u64         nr_wakeups;    u64         nr_wakeups_sync;    u64         nr_wakeups_migrate;    u64         nr_wakeups_local;    u64         nr_wakeups_remote;    u64         nr_wakeups_affine;    u64         nr_wakeups_affine_attempts;    u64         nr_wakeups_passive;    u64         nr_wakeups_idle;#endif#ifdef CONFIG_FAIR_GROUP_SCHED    struct sched_entity *parent;    /* rq on which this entity is (to be) queued: */    struct cfs_rq       *cfs_rq;    /* rq "owned" by this entity/group: */    struct cfs_rq       *my_q;#endif};</code></pre><p>下半部分的成員變量需要設置了CONFIG_SCHEDSTATS和CONFIG_FAIR_GROUP_SCHED時才會啟用，重點關注前半部分即可。</p><p>調度器實體結構是作為一個名為se的成員變量，嵌入在進程描述符struct task_struct中的。</p><div class=pgc-img><img alt=Linux內核學習014——進程調度(三) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ddbf236434348f2bad9b0d6e701eb41><p class=pgc-img-caption></p></div><p>2019-02-10_203619.png</p><p><strong>虛擬實時</strong></p><p>sched_entity中的u64 vruntime成員記錄進程的虛擬運行時間，單位為ns。CFS使用vruntime變量來記錄一個程序運行了多久以及還能運行多久，定義在Linux2.6.34/kernel/sched_fair.c#L518的函數update_curr實現了該記賬功能：</p><pre><code>static void update_curr(struct cfs_rq *cfs_rq){    struct sched_entity *curr = cfs_rq-&gt;curr;    u64 now = rq_of(cfs_rq)-&gt;clock;    unsigned long delta_exec;    if (unlikely(!curr))        return;    /*     * Get the amount of time the current task was running     * since the last time we changed load (this cannot     * overflow on 32 bits):     */    delta_exec = (unsigned long)(now - curr-&gt;exec_start);    if (!delta_exec)        return;    __update_curr(cfs_rq, curr, delta_exec);    curr-&gt;exec_start = now;    if (entity_is_task(curr)) {        struct task_struct *curtask = task_of(curr);        trace_sched_stat_runtime(curtask, delta_exec, curr-&gt;vruntime);        cpuacct_charge(curtask, delta_exec);        account_group_exec_runtime(curtask, delta_exec);    }}</code></pre><p>update_curr()計算了當前進程的執行時間，並將其存放在變量delta_exec總，然後將與運行時間傳遞給__update_curr()，由其根據當前可運行進程總數對運行時間進行加權計算，最終將權重值與當前進程的vruntime相加。</p><p>注：__update_curr()函數定義在update_curr()函數上方</p><pre><code>/* * Update the current task's runtime statistics. Skip current tasks that * are not in our scheduling class. */static inline void__update_curr(struct cfs_rq *cfs_rq, struct sched_entity *curr,          unsigned long delta_exec){    unsigned long delta_exec_weighted;    schedstat_set(curr-&gt;exec_max, max((u64)delta_exec, curr-&gt;exec_max));    curr-&gt;sum_exec_runtime += delta_exec;    schedstat_add(cfs_rq, exec_clock, delta_exec);    delta_exec_weighted = calc_delta_fair(delta_exec, curr);    curr-&gt;vruntime += delta_exec_weighted;    update_min_vruntime(cfs_rq);}</code></pre><p>update_curr()是由系統定時器週期性調用的，因此vruntime可以準確地測量給定進程的運行時間，且可以知道下一額運行的進程。</p><h1 class=pgc-h-arrow-right>進程選擇</h1><p>CFS需要選擇下一個進程運行時，它會挑選一個具有最小vruntime的進程。CFS使用了紅黑樹來組織可運行進程隊列，關於紅黑樹可以參考這篇文章。紅黑樹是一個自平衡二叉搜索樹，以樹節點形式存儲數據，這些數據對應一個鍵值，可通過鍵值快速檢索節點上的數據。</p><p>假設存在一個紅黑樹存儲了系統中所有的可運行進程，其中的節點鍵值為可運行進程的虛擬運行時間。CFS選擇vruntime最小的，即樹中最左側的葉子節點，可以從樹的根節點一直沿左側子節點向下找直到葉子節點。實現該過程的函數為__pick_next_entity()，其定義在Linux2.6.34/source/kernel/sched_fair.c#L377。</p><pre><code>static struct sched_entity *__pick_next_entity(struct cfs_rq *cfs_rq){    struct rb_node *left = cfs_rq-&gt;rb_leftmost;    if (!left)        return NULL;    return rb_entry(left, struct sched_entity, run_node);}</code></pre><p>注：其實__pick_next_entity()函數本身並不會遍歷樹找到最左子節點，因為該值已經緩存在rb_leftmost中了。</p><p><strong>加入進程</strong></p><p>CFS先rbtree(紅黑樹)中加入可執行進程發生在進程變為可執行狀態或者是通過fork()調用第一次創建進程是，enqueue_entity()函數實現了該過程：</p><pre><code>static voidenqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags){    /*     * Update the normalized vruntime before updating min_vruntime     * through callig update_curr().     */    if (!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATE))        se-&gt;vruntime += cfs_rq-&gt;min_vruntime;    /*     * Update run-time statistics of the 'current'.     */    update_curr(cfs_rq);    account_entity_enqueue(cfs_rq, se);    if (flags &amp; ENQUEUE_WAKEUP) {        place_entity(cfs_rq, se, 0);        enqueue_sleeper(cfs_rq, se);    }    update_stats_enqueue(cfs_rq, se);    check_spread(cfs_rq, se);    if (se != cfs_rq-&gt;curr)        __enqueue_entity(cfs_rq, se);}</code></pre><p>該函數更新運行時間和其他一些統計數據，然後調用__enqueue_entity()進行插入操作：</p><pre><code>/* * Enqueue an entity into the rb-tree: */static void __enqueue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){    struct rb_node **link = &amp;cfs_rq-&gt;tasks_timeline.rb_node;    struct rb_node *parent = NULL;    struct sched_entity *entry;    s64 key = entity_key(cfs_rq, se);    int leftmost = 1;    /*     * Find the right place in the rbtree:     */    while (*link) {        parent = *link;        entry = rb_entry(parent, struct sched_entity, run_node);        /*         * We dont care about collisions. Nodes with         * the same key stay together.         */        if (key &lt; entity_key(cfs_rq, entry)) {            link = &amp;parent-&gt;rb_left;        } else {            link = &amp;parent-&gt;rb_right;            leftmost = 0;        }    }    /*     * Maintain a cache of leftmost tree entries (it is frequently     * used):     */    if (leftmost)        cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_node;    rb_link_node(&amp;se-&gt;run_node, parent, link);    rb_insert_color(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);}</code></pre><p><strong>刪除進程</strong></p><p>刪除進程發生在進程堵塞或者終止時：</p><pre><code>static voiddequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int sleep){    /*     * Update run-time statistics of the 'current'.     */    update_curr(cfs_rq);    update_stats_dequeue(cfs_rq, se);    if (sleep) {#ifdef CONFIG_SCHEDSTATS        if (entity_is_task(se)) {            struct task_struct *tsk = task_of(se);            if (tsk-&gt;state &amp; TASK_INTERRUPTIBLE)                se-&gt;sleep_start = rq_of(cfs_rq)-&gt;clock;            if (tsk-&gt;state &amp; TASK_UNINTERRUPTIBLE)                se-&gt;block_start = rq_of(cfs_rq)-&gt;clock;        }#endif    }    clear_buddies(cfs_rq, se);    if (se != cfs_rq-&gt;curr)        __dequeue_entity(cfs_rq, se);    account_entity_dequeue(cfs_rq, se);    update_min_vruntime(cfs_rq);    /*     * Normalize the entity after updating the min_vruntime because the     * update can refer to the -&gt;curr item and we need to reflect this     * movement in our normalized position.     */    if (!sleep)        se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;}</code></pre><p>實際刪除工作由__dequeue_entity()完成。</p><pre><code>static void __dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se){    if (cfs_rq-&gt;rb_leftmost == &amp;se-&gt;run_node) {        struct rb_node *next_node;        next_node = rb_next(&amp;se-&gt;run_node);        cfs_rq-&gt;rb_leftmost = next_node;    }    rb_erase(&amp;se-&gt;run_node, &amp;cfs_rq-&gt;tasks_timeline);}</code></pre><h1 class=pgc-h-arrow-right>調度器入口</h1><p>調度器入口時函數schedule()，該函數定義在Linux2.6.34/kernel/sched.c#L3698中。schedule()時內惡化其他部分調用進程調度器的入口，其通常和一個具體的調度類相關聯。</p><pre><code>/* * schedule() is the main scheduler function. */asmlinkage void __sched schedule(void){    struct task_struct *prev, *next;    unsigned long *switch_count;    struct rq *rq;    int cpu;need_resched:    preempt_disable();    cpu = smp_processor_id();    rq = cpu_rq(cpu);    rcu_sched_qs(cpu);    prev = rq-&gt;curr;    switch_count = &amp;prev-&gt;nivcsw;    release_kernel_lock(prev);need_resched_nonpreemptible:    schedule_debug(prev);    if (sched_feat(HRTICK))        hrtick_clear(rq);    raw_spin_lock_irq(&amp;rq-&gt;lock);    update_rq_clock(rq);    clear_tsk_need_resched(prev);    if (prev-&gt;state &amp;&amp; !(preempt_count() &amp; PREEMPT_ACTIVE)) {        if (unlikely(signal_pending_state(prev-&gt;state, prev)))            prev-&gt;state = TASK_RUNNING;        else            deactivate_task(rq, prev, 1);        switch_count = &amp;prev-&gt;nvcsw;    }    pre_schedule(rq, prev);    if (unlikely(!rq-&gt;nr_running))        idle_balance(cpu, rq);    put_prev_task(rq, prev);    next = pick_next_task(rq);    if (likely(prev != next)) {        sched_info_switch(prev, next);        perf_event_task_sched_out(prev, next);        rq-&gt;nr_switches++;        rq-&gt;curr = next;        ++*switch_count;        context_switch(rq, prev, next); /* unlocks the rq */        /*         * the context switch might have flipped the stack from under         * us, hence refresh the local variables.         */        cpu = smp_processor_id();        rq = cpu_rq(cpu);    } else        raw_spin_unlock_irq(&amp;rq-&gt;lock);    post_schedule(rq);    if (unlikely(reacquire_kernel_lock(current) &lt; 0)) {        prev = rq-&gt;curr;        switch_count = &amp;prev-&gt;nivcsw;        goto need_resched_nonpreemptible;    }    preempt_enable_no_resched();    if (need_resched())        goto need_resched;}</code></pre><h1 class=pgc-h-arrow-right>睡眠和喚醒</h1><p>睡眠(被阻塞)的進程無法執行，原因是其在等待一些時間發生，比如：文件I/O，網絡請求等。休眠中的進程有兩個相關的進程狀態：TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE。區別在於處於TASK_UNINTERRUPTIBLE的進程會忽略信號，而處於TASK_INTERRUPTIBLE的進程會被信號喚醒並響應信號。此外，兩種狀態的進程都位於一個等待隊列上等待事件發生，不能運行。</p><p><strong>喚醒</strong></p><p>喚醒通過wake_up()函數完成，它會喚醒指定的等待隊列上的所有進程。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>核學習</a></li><li><a>014</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html alt=Linux系統常用命令大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html title=Linux系統常用命令大全>Linux系統常用命令大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47743f68.html alt=嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/44355de4180a4af4beeda86cd1696601 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47743f68.html title=嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》>嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2f8e01a.html alt="Linux C 字符串函數 sprintf()、snprintf() 詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2f8e01a.html title="Linux C 字符串函數 sprintf()、snprintf() 詳解">Linux C 字符串函數 sprintf()、snprintf() 詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html alt=Linux高級網絡編程篇-UDP丟包問題總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html title=Linux高級網絡編程篇-UDP丟包問題總結>Linux高級網絡編程篇-UDP丟包問題總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b95dde80.html alt=Linux技巧：在代碼中設置終端字符顯示顏色和移動光標位置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9bde2c83315847498e4b848f524e429c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b95dde80.html title=Linux技巧：在代碼中設置終端字符顯示顏色和移動光標位置>Linux技巧：在代碼中設置終端字符顯示顏色和移動光標位置</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>