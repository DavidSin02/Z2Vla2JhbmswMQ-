<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>圖論的各種基本算法 | 极客快訊</title><meta property="og:title" content="圖論的各種基本算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/30080011575364d6b24c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/160a8715.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/160a8715.html><meta property="article:published_time" content="2020-11-14T20:53:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:56+08:00"><meta name=Keywords content><meta name=description content="圖論的各種基本算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/160a8715.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>圖論的各種基本算法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/30080011575364d6b24c><p><strong>本篇主要涉及到圖論的基本算法</strong>，不包含有關最大流的內容。圖論的大部分算法都是由性質或推論得出來的，想樸素想出來確實不容易。</p><p><strong>二分圖(Is-Bipartite)</strong></p><p>一個圖的所有頂點可以劃分成兩個子集，使所有的邊的入度和出度頂點分別在這兩個子集中。</p><p>這個問題可以轉換為上篇提到過的圖的著色問題，只要看圖是否能著2個顏色就行了。當然，可以回溯解決這個問題，不過對於著2個顏色可以BFS解決。</p><p>同樣，一維數組colors表示節點已著的顏色。</p><blockquote><p>偽代碼：</p><p>IS-BIPARTITE(g,colors)</p><p>let queue be new Queue</p><p>colors[0] = 1</p><p>queue.push(0)</p><p>while queue.empty == false</p><p>let v = queue.top</p><p>queue.pop</p><p>for i equal to every vertex in g</p><p>if colors[i] == 0</p><p>colors[i] = 3 - colors[v]</p><p>queue.push(i)</p><p>else if colors[i] == colors[v]</p><p>return false</p><p>end</p><p>end</p><p>return true</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>DFS改良(DFS-Improve)</strong></p><p>上篇文章提到過，搜索解空間是樹形的，也就是在說BFS和DFS。那麼在對圖進行BFS和DFS有什麼區別呢，這個問題要從解空間角度去理解。對圖進行BFS的解空間是一顆樹，可叫廣度優先樹。而DFS是多棵樹構成的森林，可叫深度優先森林。</p><p>這裡要對DFS進行小小的改良，它的性質會對解多個問題會很有幫助。原版DFS搜索的時候，會先遍歷本頂點，再遞歸遍歷臨接的頂點。DFS改良希望能先遞歸遍歷臨接的頂點，再遍歷本頂點，並且按遍歷順序逆序存儲起來。</p><blockquote><p>偽代碼：</p><p>DFS-IMPROVE(v,visited,stack)</p><p>visited[v] = true</p><p>for i equal to every vertex adjacent to v</p><p>if visited[i] == false</p><p>DFS-IMPROVE(i,visited,stack)</p><p>end</p><p>stack.push(v)</p></blockquote><p>這個改良版DFS有個很有用的性質就是，對於兩個頂點A、B，存在A到B的路徑，而不存在B到A的路徑，則從記錄的順序中取出的時候，一定會先取出頂點A，再取出頂點B。以下為這個性質的證明。</p><p>假設：有兩個頂點A和B，存在路徑從A到B，不存在路徑從B到A。</p><p>證明：分為兩種情況，情況一，先搜索到A頂點，情況二，先搜索到B頂點。對於情況一，由命題可得，A一定存儲在B之後，那麼取出時先取出的是頂點A。對於情況二，先搜索到B頂點，由於B頂點搜索不到A頂點，則A一定存儲在B之後，那麼取出時仍先取出的是頂點A，命題得證。</p><p>DFS改良性質：對於兩個頂點A、B，存在A到B的路徑，而不存在B到A的路徑，則從記錄的順序中取出的時候，一定會先取出頂點A，再取出頂點B。</p><p><strong>歐拉回路(Eulerian-Path-And-Circuit)</strong></p><p>在無向圖中，歐拉路徑定義為，一條路徑經過所有的邊，每個邊只經過一次。歐拉回路定義為，存在一條歐拉路徑且路徑的起點和終點為同一個頂點。可以看到只有連通圖才能有歐拉回路和歐拉路徑。</p><p>這個算法很巧。如果一條路徑要經過一個頂點，本質是從一條邊到達一個頂點，然後從這個頂點通過另一條邊出去。歐拉回路就是要求路徑要經過所有的點，起點和終點還都是同一個頂點。那麼就等價於要求所有頂點連接的邊是2個。實際上，路徑還可以經過頂點多次，那麼就等價於要求所有頂點連接的邊是偶數個。歐拉路徑的要求就等價於所有頂點連接的邊是偶數個，除了起點和終點兩個頂點可以是奇數個。</p><p>先判斷圖是否是連通圖。返回0代表沒有歐拉回路或者歐拉路徑，返回1代表有歐拉路徑，返回2代表有歐拉回路。</p><blockquote><p>偽代碼：</p><p>EULERIAN-PATH-AND-CIRCUIT(g)</p><p>if isConnected(g) == false</p><p>return 0</p><p>let odd = 0</p><p>for v equal to every vertex in g</p><p>if v has not even edge</p><p>odd = odd + 1</p><p>end</p><p>if odd > 2</p><p>returon 0</p><p>if odd == 1</p><p>return 1</p><p>if odd == 0</p><p>return 2</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>拓撲排序(Topological-Sorting)</strong></p><p>將一張有向無環圖的頂點排序，排序規則是所有邊的入度頂點要在出度頂點之前。可以看到，無向和有環圖都不存在拓撲排序，並且拓撲排序可能存在多種解。</p><p>拓撲排序有兩種解法，一種是從搜索角度。</p><p>如果我能保障先遞歸遍歷臨接的頂點，再遍歷本頂點的話，那麼遍歷的順序的逆序就是一個拓撲排序。那麼就可以直接用DFS改良求解出拓撲排序。</p><blockquote><p>偽代碼：</p><p>TOPOLOGICAL-SORTING-DFS(g)</p><p>let visited be new Array</p><p>let result be new Array</p><p>let stack be new Stack</p><p>for v equal to every vertex in g</p><p>if visited[v] == false</p><p>DFS-IMPROVE(v,visited,stack)</p><p>end</p><p>while stack.empty == false</p><p>result.append(stack.top)</p><p>stack.pop</p><p>end</p><p>return result</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p>另一種是貪心選擇。</p><p>直覺上，既然要所有邊的出度頂點在入度頂點之前，可以從入度和出度角度來解決問題。可以讓入度最小的排序在前，也可以讓出度最大的排序在後，排序後，這個頂點的邊都不會再影響問題了，可以去掉。去掉後再重新加入新的頂點，直到加入所有頂點。</p><p>這個問題還有個隱含條件，挑選出、入度最小的頂點就等價於挑選出、入度為0的頂點。這是因為圖必須是無環圖，所以肯定存在出、入度為0的頂點，那麼出、入度最小的頂點就是出、入度為0的頂點。</p><p>直覺上這是一個可行的策略，細想一下，按出度最大排序和按入度為零排序是否等價。實際上是不等價的，按入度為零排序，如果出現了多個入度為零的頂點，這多個頂點排序的順序是無關的，可以任意排序。而按出度最大排序，出現了多個入度最大的頂點，這多個頂點排序是有關的，不能任意排序。所以，只能按入度為零排序。實際上，這個想法就是貪心選擇。下面以挑選入度為零的邊作為貪心選擇解決問題，同樣地，還是先證明這個貪心選擇的正確性。</p><p>命題：入度為零的頂點v排序在前。</p><p>假設：S為圖的一個拓撲排序，l為此排序的首個頂點。</p><p>證明：如果l=v，則命題得證。如果l不等於v，將l頂點從S中去除，然後加入頂點v得到新的排序S‘。因為S去除l以後l以後的排序沒有變，仍為拓撲排序，v入度為零，v前面可以沒有頂點，所以S’也為圖的一個拓撲排序，命題得證。</p><blockquote><p>偽代碼：</p><p>TOPOLOGICAL-SORTING-GREEDY(g)</p><p>let inDegree be every verties inDegree Array</p><p>let stack be new Stack</p><p>let result be new Array</p><p>for v equal to every vertex in g</p><p>if inDegree[v] == 0</p><p>stack.push(v)</p><p>end</p><p>while stack.empty == false</p><p>vertex v = stack.top</p><p>stack.pop</p><p>result.append(v)</p><p>for i equal to every vertex adjacent to v</p><p>inDegree[i] = inDegree[i] - 1</p><p>if inDegree[i] == 0</p><p>stack.push(i)</p><p>end</p><p>end</p><p>return result.reverse</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>強連通分量(Strongly-Connected-Components)</strong></p><p>圖中的一個頂點與另一個頂點互相都有路徑可以抵達，就說這兩個頂點強連通。圖中有多個頂點兩兩之間都強連通，則這多個頂點構成圖的強連通分量。</p><p>樸素的想法是，假如從一個頂點A可以搜索到另一個頂點B，如果從B頂點再能搜索回A頂點的話，A、B就在一個強連通分量中。不過，這樣每兩個頂點要進行兩次DFS，複雜度肯定會很高。這裡可以引入轉置圖(將有向邊的方向翻轉)的性質。這樣問題就轉換成了，從A頂點搜索到B頂點，將圖轉置後，如果再A頂點還能搜索到B頂點，A、B頂點就在一個強連通分量中。用算法表述出來就是先從A頂點DFS，然後將圖轉置，再從A頂點DFS，兩次DFS都能搜索到B頂點的話，B頂點就與A頂點在同一個強連通分量中。然而樸素想法只能想到這裡了。</p><p>有多個算法被研究出來解決這個問題，下面先介紹Kosaraju算法。</p><p><strong>Kosaraju</strong></p><p>Kosaraju算法使用了DFS改良的性質去解決問題，想法很有趣。Kosaraju算法現將圖進行DFS改良，然後將圖轉置，再進行DFS。第二次DFS每個頂點能夠搜索到的點就是一個強連通分量。算法正確性和說明如下。</p><p>通過DFS改良性質可以得出定理，一個強連通分量C如果有到達另一個強連通分量C’的路徑，則C’比C先被搜索完，這個定理很明顯，如果C中有路徑到C’，那麼根據DFS改良性質一定會先搜索到C，再搜索完C’，再搜索完C。將這個定理做定理1。</p><p>定理1：一個強連通分量C如果有到達另一個強連通分量C’的路徑，則C’比C先被搜索完。</p><p>定理1還可以再進行推論，如果一個強連通分量C有到達另一個強連通分量C’的路徑，則將圖轉置後，C比C’先被搜索完，這個推論也很明顯，將圖轉置後，不存在C到C’的路徑，存在C’到C的路徑，而仍是先搜索C再搜索C‘，所以C比C‘先被搜索完，這個推論作為推論1。</p><p>推論1：如果一個強連通分量C有到達另一個強連通分量C’的路徑，則將圖轉置後，C比C’先被搜索完。</p><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6eb9000c3e462e812c41><p>以下為用結構歸納法對算法正確性進行證明。</p><p>命題：第二次DFS每個頂點能夠搜索到的點就是一個強連通分量。</p><p>假設：n代表圖中有多少個強連通分量。</p><p>證明：如果n=1，則第二次DFS就是搜索一遍所有頂點，命題得證。現在假設n=k時，命題成立。現證明n=k+1時，是否成立。假設搜索到第k+1個強連通分量的第一個頂點為u，u肯定能搜索到所有k+1個強連通分量的頂點。並且根據推論1，此時被轉置後的圖，所有從第k+1個強連通分量能到達的其他強連通分量都已經被搜索過了。所以u只能搜索到所有第k+1個強連通分量的頂點，即第二次DFS每個頂點只能夠搜索到包含此頂點的強連通分量中的頂點，命題得證。</p><blockquote><p>偽代碼：</p><p>KOSARAJU-STRONGLY-CONNECTED-COMPONENTS(g)</p><p>let visited be new Array</p><p>let stack be new Stack</p><p>for v equal to every vertex in g</p><p>if visited[v] == false</p><p>DFS-IMPROVE(v,visited,stack)</p><p>end</p><p>let gt = transpose of g</p><p>for v equal to every vertex in g</p><p>visited[v] = false</p><p>end</p><p>while stack.empty == false</p><p>vertex v = stack.top</p><p>stack.pop</p><p>if visited[v] == false</p><p>DFS(v,visited)</p><p>print ' Found a Strongly Connected Components '</p><p>end</p><p>DFS(v,visited)</p><p>visited[v] = true</p><p>print v</p><p>for i equal to every vertex adjacent to v</p><p>if visited[i] == false</p><p>DFS(i,visited,stack)</p><p>end</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p>Kosaraju算法需要進行兩次DFS，那麼可不可以只進行一次DFS，邊遍歷邊找強連通分量？Tarjan就是這樣的算法。</p><p><strong>Tarjan</strong></p><p>同樣，還是要基於DFS搜索性質來思考問題。DFS創建出的深度優先搜索樹會先被訪問根節點再被訪問子孫節點。什麼時候會出現強連通分量？只有子孫節點有連通祖先節點的邊的時候。如果從某個節點，其子孫節點都只有指向自己子孫節點的邊的時候，這是明顯沒有構成強連通分量的。那麼，出現了子孫節點指向其祖先節點的時候，從被指向的祖先節點一直搜索到指向的子孫節點所經過所有頂點就構成了一個強連通分量。如果出現了多個子孫節點都指向了祖先節點怎麼辦？最早被指向、訪問的祖先節點到最晚指向、訪問的子孫節點構成了“最大“的強連通分量，這才是想要找的強連通分量。如果遇到了一個指向祖先節點的子孫節點，就算構成一個強連通分量，會導致找到多個互相嵌套的強連通分量。那麼，要記錄訪問順序就要為每個節點設置一個被訪問順序的編號，讓屬於同一個強連通分量的頂點編號一致。上面討論的是構成了一個強連通分量怎麼處理，如果沒有多個節點構成的強連通分量怎麼處理？在搜索節點之前，為這個節點默認設置上被訪問的順序編號，這樣如果沒有搜索到多個節點構成的強連通分量，每個節點就是自己的強連通分量。</p><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6ebe0009d9bf98c27e7d><p>算法表述為，從某個節點開始搜索，默認設置自己為一個強連通分量。只要節點有子孫節點，就要等待子孫節點都搜索完，再更新自己強連通分量信息。只要節點有指向祖先節點，也要更新自己的強連通分量。判斷子孫節點構成的強連通分量”大“還是自己構成的強連通分量”大“，自己屬於最”大“的強連通分量。也就是說，算法找出了所有頂點的所屬的最“大”強連通分量。</p><p>數組disc表示頂點被訪問順序的編號，數組low表示頂點所在的強連通分量編號。最後當頂點在disc和low中編號一致時，代表頂點是所在強連通分量中第一個被搜索到的頂點。此時，輸出所在的強連通分量所包括的頂點。</p><blockquote><p>偽代碼：</p><p>TARJAN-STRONGLY-CONNECTED-COMPONENTS(g)</p><p>let disc be new Array</p><p>let low be new Array</p><p>let stack be new Stack</p><p>let isInStack be new Array</p><p>for i from 1 to the number of vertex in g</p><p>disc [i] = -1</p><p>low [i] = -1</p><p>end</p><p>for u from 1 to the number of vertex in g</p><p>if disc[i] != -1</p><p>TARJAN-STRONGLY-CONNECTED-COMPONENTS-UTIL(u,disc,low,stack,isInStack)</p><p>end</p><p>TARJAN-STRONGLY-CONNECTED-COMPONENTS-UTIL(u,disc,low,stack,isInStack)</p><p>let time be static</p><p>time = time + 1</p><p>disc[u] = low[u] = time</p><p>stack.push(u)</p><p>isInStack[u] = true</p><p>for v equal to every vertex adjacent to u</p><p>if disc[v] == -1</p><p>TARJAN-STRONGLY-CONNECTED-COMPONENTS-UTIL(v,disc,low,stack,isInStack)</p><p>low[u] = min(low[u],low[v])</p><p>else if isInStack[v] == true</p><p>low[u] = min(low[u],disc[v])</p><p>end</p><p>let w = 0</p><p>if low[u] == disc[u]</p><p>while stack.top != u</p><p>w = stack.top</p><p>isInStack[w] = false</p><p>stack.pop</p><p>print w</p><p>end</p><p>w = stack.top</p><p>isInStack[w] = false</p><p>stack.pop</p><p>print w</p><p>print ' Found a Strongly Connected Components '</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>圖的割點(Articulation Points)、橋(Bridge)、雙連通分量(Biconnected Components)</strong></p><p><strong>圖的割點(Articulation-Points)</strong></p><p>圖的割點也叫圖的關節點，定義為無向圖中分割兩個連通分量的點，或者說去掉這個點，圖中的連通分量數增加了。可以看到如果求出了連通分量，那麼不同連通分量中間的頂點就是割點。什麼時候某個頂點不是這樣的割點？如果這個頂點的子孫頂點有連接這個頂點祖先頂點的邊，那麼去掉這個頂點，這個頂點的子孫頂點和祖先頂點仍然連通。那麼，尋找割點的過程就等價於尋找子孫頂點沒有連接祖先頂點的頂點。這個問題的求解過程類似於Tarjan強連通分量的求解過程。</p><p>不過，這個問題有個例外就是根頂點，對一般頂點的處理方式處理根頂點行得通嗎？根頂點肯定沒有子孫頂點指向祖先頂點，但是根頂點可以是割點。所以，根頂點需要特殊處理。根頂點什麼時候是割點？當根頂點有多顆子樹，且之間無法互相到達的時候。那麼，存不存在根頂點有多顆子樹，且之間可以互相到達？不存在，如果互相之間可以到達，那在根頂點搜索第一顆子樹的時候，就會搜索到可到達的子樹，就不會存在多顆子樹了。所以，根頂點有多顆子樹，那麼這多顆子樹之間一定無法互相到達。根頂點有多顆子樹，且之間無法互相到達的時候就等價於根頂點有多顆子樹。所以，只要根頂點有多顆子樹，那麼根頂點就是割點。</p><p>同樣地，數組disc表示頂點被訪問順序的編號，數組low表示頂點所在的強連通分量編號。數組parent找出根頂點。</p><blockquote><p>偽代碼：</p><p>ARTICULATION-POINTS(g)</p><p>let disc be new Array</p><p>let low be new Array</p><p>let result be new Array</p><p>let parent be new Array</p><p>let visited be new Array</p><p>for i from 1 to the number of vertex in g</p><p>result [i] = false</p><p>visited [i] = false</p><p>parent [i] = -1</p><p>end</p><p>for u from 1 to the number of vertex in g</p><p>if visited[i] == false</p><p>ARTICULATION-POINTS-UTIL(u,disc,low,result,parent,visited)</p><p>end</p><p>for i from 1 to the number if vertex in g</p><p>if result[i] == true</p><p>print ' Found a Articulation Points i '</p><p>end</p><p>ARTICULATION-POINTS-UTIL(u,disc,low,result,parent,visited)</p><p>let time be static</p><p>time = time + 1</p><p>let children = 0</p><p>disc[u] = low[u] = time</p><p>visited[u] = true</p><p>for v equal to every vertex adjacent to u</p><p>if visited[v] == false</p><p>children = children + 1</p><p>parent[v] = u</p><p>ARTICULATION-POINTS-UTIL(u,disc,low,result,parent,visited)</p><p>low[u] = min(low[u],low[v])</p><p>if parnet[u] == -1 and children > 1</p><p>result[u] = true</p><p>if parent[u] != -1 and low[v] >= disc[u]</p><p>result[u] = true</p><p>else if v != parent[u]</p><p>low[u] = min(low[u],disc[v])</p><p>end</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>橋(Bridge)</strong></p><p>橋定義為一條邊，且去掉這個邊，圖中的連通分量數增加了。類似於尋找割點，尋找橋就是尋找這樣一條，一端的頂點的子孫頂點沒有連接這個頂點和其祖先頂點的邊。求解過程和求割點基本一致。</p><blockquote><p>偽代碼：</p><p>BRIDGE(g)</p><p>let disc be new Array</p><p>let low be new Array</p><p>let parent be new Array</p><p>let visited be new Array</p><p>for i from 1 to the number of vertex in g</p><p>visited [i] = false</p><p>parent [i] = -1</p><p>end</p><p>for u from 1 to the number of vertex in g</p><p>if visited[i] == false</p><p>BRIDGE-UTIL(u,disc,low,parent,visited)</p><p>end</p><p>BRIDGE-UTIL(u,disc,low,parent,visited)</p><p>let time be static</p><p>time = time + 1</p><p>disc[u] = low[u] = time</p><p>for v equal to every vertex adjacent to u</p><p>if visited[v] == false</p><p>parent[v] = u</p><p>BRIDGE-UTIL(u,disc,low,parent,visited)</p><p>low[u] = min(low[u],low[v])</p><p>if low[v] > disc[u]</p><p>print ' Found a Bridge u->v '</p><p>else if v != parent[u]</p><p>low[u] = min(low[u],disc[v])</p><p>end</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>雙連通分量(Biconnected-Components)</strong></p><p>雙連通圖定義為沒有割點的圖。雙連通圖的極大子圖就為雙連通分量。雙連通分量就是在割點分割成多個連通分量處，共享割點。也就是說雙連通分量是去掉割點後構成的連通分量，加上割點和到達割點的邊。可以看出，雙連通分量可分為不含有割點、一個割點、兩個割點三種情況。對於不含有割點，說明圖為雙連通圖。對於含有一個割點，可能為初始搜索的頂點到第一個割點之間的邊構成的雙連通分量，可能為遇到一個割點後到不再遇到割點之間的邊構成雙連通分量。對於含有兩個割點，兩個割點之間的邊構成了一個雙連通分量。</p><p>求解此問題，只要在求割點的算法上做更改就可以了。按照求割點的算法求解割點，找到一個割點，輸出找到的邊，然後刪除找到的邊的記錄，再去搜索下一個割點。每搜索完圖某個頂點的可達頂點，輸出找到的邊。這樣就涵蓋了所有的情況。</p><blockquote><p>偽代碼：</p><p>BICONNECTED-COMPONENTS(g)</p><p>let disc be new Array</p><p>let low be new Array</p><p>let stack be new Stack</p><p>let parent be new Array</p><p>for i from 1 to the number of vertex in g</p><p>disc [i] = -1</p><p>low [i] = -1</p><p>parent [i] = -1</p><p>end</p><p>for u from 1 to the number of vertex in g</p><p>if disc[i] == -1</p><p>BICONNECTED-COMPONENTS-UTIL(u,disc,low,stack,parent)</p><p>let flag = flase</p><p>while stack.empty == false</p><p>flag = true</p><p>print stack.top.src -> stack.top.des</p><p>stack.pop</p><p>end</p><p>if flag == true</p><p>print ' Found a Bioconnected-Components '</p><p>end</p><p>BICONNECTED-COMPONENTS-UTIL(u,disc,low,stack,parent)</p><p>let time be static</p><p>time = time + 1</p><p>let children = 0</p><p>disc[u] = low[u] = time</p><p>for v equal to every vertex adjacent to u</p><p>if disc[v] == -1</p><p>children = children + 1</p><p>parent[v] = u</p><p>stack.push(u->v)</p><p>BICONNECTED-COMPONENTS-UTIL(u,disc,low,stack,parent)</p><p>low[u] = min(low[u],low[v])</p><p>if (parnet[u] == -1 and children > 1) or (parent[u] != -1 and low[v] >= disc[u])</p><p>while stack.top.src != u or stack.top.des != v</p><p>print stack.top.src -> stack.top.des</p><p>stack.pop</p><p>end</p><p>print stack.top.src -> stack.top.des</p><p>stack.pop</p><p>print ' Found a Bioconnected-Components '</p><p>else if v != parent[u] and disc[v] &lt; low[u]</p><p>low[u] = min(low[u],disc[v])</p><p>stack.push(u->v)</p><p>end</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p><strong>最小生成樹(Minimum-Spanning-Tree)</strong></p><p>生成樹是指，在一個連通、無向、有權的圖中，所有頂點構成的一顆樹。圖中可以有多顆生成樹，而生成樹的代價就是樹中所有邊的權重的和。最小生成樹就是生成樹中代價最小的。</p><p>樸素的想法就是從圖中選擇最小權重的邊，直到生成一顆樹。看通用的算法之前，同樣要討論一下最小生成樹的性質。</p><p>對於一個連通、無向、有權圖中，一定有最小生成樹。如果圖不包含最小生成樹的任意一條邊，那麼圖就是不連通的了，這與已知連通圖不符，所以圖必包含最小生成樹。</p><p>假設，A為某個最小生成樹的子集(任意一個頂點都是最小生成樹的子集)。</p><p>那麼，為A一直添加對的邊，A最後就會成為一顆最小生成樹。那麼最小生成樹問題就轉換成為了，一直找到對的邊，直到成為一顆最小生成樹。這個對的邊可以叫做安全邊。</p><p>安全邊如何尋找顯然就成了解決這個問題的關鍵點。</p><p>再假設，圖中所有頂點為V，將所有頂點切割成兩個部分S和V減去S。所有連接這兩個部分的邊，很形象的叫做橫跨切割，這些邊橫跨了兩個部分，成為這兩個部分的橋樑。這裡還有個問題，如何切割？使A不包含橫跨切割。這樣的切割有多種切法，切割後，橫跨切割的最小代價邊就為A的安全邊。將這個作為定理1。</p><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6eb9000c3e470357f78a><p>定理1：存在這樣一個將所有頂點分成兩個部分的切割，且使某個最小生成樹子集A不包含橫跨切割。則橫跨此切割的最小代價邊，就是A的安全邊。</p><p>以下為此定理的證明，這個定理的基礎實際上是連通性。</p><p>命題：橫跨切割的最小代價邊為A的安全邊。</p><p>假設：橫跨切割後的最小代價邊為x，有最小生成樹T包含A，但是不包含x。</p><p>證明：既然T不包含x，那麼T必須包含另一條連接x兩端頂點的路徑，這條路徑上又必須有條邊橫跨切割。假設這條邊為y。T將y減去後，x兩端的頂點就無法互相到達。這時如果再加上x，那麼x兩端的頂點又可以互相到達，並且構造了另一顆生成樹T’。可以看到，x的代價小於或等於y的代價，那麼T‘的代價也小於或等於T的代價，那麼T’也就是一顆最小生成樹。那麼x既不在A中，x又在一顆包含A的最小生成樹中。命題得證。</p><p>可以看到這個證明過程使用的就是經常拿來證明貪心選擇的技巧，也就是說最小生成樹問題符合貪心算法的特徵，也就解釋了為什麼下面將要提到的兩個算法都是貪心算法。</p><p>定理1還可以進行推論，既然切割有多種方法，那可不可以對A和其餘的頂點進行切割，設B為包括A和所有頂點構成的一個森林，C是其中的一個連通分量，那麼C連接其他的連通分量的最小代價邊是A的安全邊。這個推論很好證明，因為A是B中的一個或者多個連通分量，如果按照C去切割圖分成C和B減去C，不可能切割A，即A中必定不包含橫跨切割。那麼，橫跨這個切割的最小代價邊就是安全邊，即C連接其他連通分量的最小代價邊，推論成立。將這個推論作為推論1。</p><p>推論1:某個最小生成樹子集A和其他頂點構成的森林中，任意一個連通分量連接其他連通分量的最小代價邊都為A的安全邊。</p><p>如果從所有不在A中的邊選擇最小代價的邊，這個邊一定連接著某個連通分量，這個推論也就將選安全邊的範圍拓展到任意一條不在A中的邊。這個推論正好可以證明樸素想法的正確性。</p><p>接下來看一下最小生成樹的三個通用的算法Kruskal、Prime、Boruvka。</p><p><strong>Kruskal</strong></p><p>樸素想法和Kruskal已經很接近了。Kruskal算法做的就是一直選擇代價最小的邊，不過，如果選擇這個邊後，無生成最小生成樹，而生成圖了怎麼辦？Kruskal比樸素想法巧的地方就是不選擇會成環的邊。</p><p>Kruskal常用的檢查是否成環的數據結構是UnionFind(並查集)，UnionFind有個操作，一個是Find檢查元素所在集合的編號，Union將兩個元素合併成一個集合。</p><blockquote><p>KRUSKAL(g)</p><p>let edges be all the edges of g</p><p>sort(edges)</p><p>let uf be new UnionFind</p><p>let e = 0</p><p>let i = 0</p><p>let result be new Array</p><p>while e &lt; edges.length</p><p>let edge = edges[i]</p><p>i = i + 1</p><p>if uf.find(edge.src) != uf.find(edge.des)</p><p>result.append(edge)</p><p>e = e + 1</p><p>uf.union(edge.src,edge.des)</p><p>end</p><p>return result</p></blockquote><p>V表示頂點的個數，E表示邊的個數，排序E個邊加上E次UnionFind操作</p><p>時間複雜度:O(Elog2E+Elog2V)</p><p><strong>Prim</strong></p><p>有了推論1，Prim算法的正確性理解起來就很簡單了，一直只對最小生成樹子集進行切割，然後選擇出最小生成樹子集與其他連通分量的最小代價邊就OK了。Prim算法就是一直選擇最小生成樹子集與其他頂點連接的最小代價邊。</p><p>Prim算法維持這樣一個最小堆，存儲最小生成樹子集以外的頂點，與最小生成樹子集臨接的頂點的權重是其臨接邊的值，其餘的最小堆中的頂點權重都是無窮。Prim算法初始將起始頂點在最小堆中的權重置為0，其餘的頂點置為無窮。然後從最小堆中一直取權重最小的頂點，即選擇最小代價邊加入最小生成樹，如果取出的頂點的臨接頂點不在最小生成樹中，且這個臨接頂點在最小堆中的權重比邊大，則更新臨接頂點在最小堆的權重，直到從最小堆中取出所有的頂點，就得到了一顆最小生成樹。</p><blockquote><p>偽代碼：</p><p>PRIM(g,s)</p><p>let heap be new MinHeap</p><p>let result be new Array</p><p>for i from 1 to the number of vertex in g</p><p>let vertex be new Vertex(i)</p><p>vertex.weight = INT_MAX</p><p>heap.insert(vertex)</p><p>end</p><p>heap.decrease(s,0)</p><p>while heap.empty == false</p><p>vertex v = heap.top</p><p>for u equal to every vertex adjacent to v</p><p>if heap.isNotInHeap(u) and v->u &lt; heap.getWeightOfNode(u)</p><p>result[u] = v</p><p>heap.decrease(u,v->u)</p><p>end</p><p>end</p><p>return result</p></blockquote><p>V表示頂點的個數，E表示邊的個數，對V個頂點和E條邊進行decrease操作</p><p>時間複雜度:O(Elog2V+Vlog2V)</p><p><strong>Boruvka</strong></p><p>Kruskal是根據所有邊中最小代價邊的一端的連通分量分割，Prim根據最小生成子樹的子集分割，Boruvka根據所有的連通分量分割，實際上都是基於推論1。Boruvka算法將所有連通分量與其他連通分量的最小代價邊選擇出來，然後將這些邊中未加入最小生成樹子集的加進去，一直到生成最小生成樹。</p><p>Boruvka算法同樣使用了UnionFind去記錄連通分量，用cheapest數組記錄連通分量與其他連通分量連接的最小代價邊的編號。</p><blockquote><p>偽代碼：</p><p>Boruvka(g)</p><p>let uf be new UnionFind</p><p>let cheapest be new Array</p><p>let edges be all the edge of g</p><p>let numTree = the number of vertex in g</p><p>let result be new Array</p><p>for i from 1 to number of vertex in g</p><p>cheapest[i] = -1</p><p>end</p><p>while numTree > 0</p><p>for i from 1 to the number of edge in g</p><p>let set1 = uf.find(edges[i].src)</p><p>let set2 = uf.find(edges[i].des)</p><p>if set1 == set2</p><p>continue</p><p>if cheapest[se1] == -1 or edges[cheapest[set1]].weight > edges[i].weight</p><p>cheapest[set1] = i</p><p>if cheapest[set2] == -1 or edges[cheapest[set2]].weight > edges[i].weight</p><p>cheapest[set2] = i</p><p>end</p><p>for i from 1 to the number of vertex in g</p><p>if cheapest[i] != -1</p><p>let set1 = uf.find(edges[cheapest[i]].src)</p><p>let set2 = uf.find(edges[cheapest[i]].des)</p><p>if set1 == set2</p><p>continue</p><p>result[edges[cheapest[i]].src] = edges[cheapest[i]].des</p><p>uf.union(set1,set2)</p><p>numTree = numTree - 1</p><p>end</p><p>end</p><p>return result</p></blockquote><p>時間複雜度:O(Elog2V)，V表示頂點的個數，E表示邊的個數</p><p><strong>單源最短路徑(Single-Source-Shortest-Paths)</strong></p><p>給出一張連通、有向圖，找出一個頂點s到其他所有頂點的最短路徑。可以看到，如果圖中存在負環，不存在最短路徑。因為存在負環就可以無限循環負環得到更短的路徑。</p><p>看通用的算法之前，同樣要討論一下問題的性質。</p><p>假設，存在一條頂點s到頂點v的最短路徑，i、j為路徑上的兩個頂點。那麼在這條s到v最短路徑上，i到j的路徑是否是i到j的最短路徑？是的，如果存在i到j的更短路徑，就等價於存在一條s到v的更短路徑，這與假設不符。也就是說，如果存在一條從s到v的最短路徑，這條路徑上任意兩個頂點的路徑都是這兩個頂點的最短路徑。那麼，這個問題就具有動態規劃的狀態轉移特徵。</p><p>解決此問題的樸素想法就是求出所有頂點s到頂點v的路徑，然後取最小值。那麼要是實現這個步驟，就要為v點存儲一個估計值d，並設起始為無窮，如果有到達v的路徑小於這個估計值，更新這個估計值，並且記錄v的現階段最小路徑。這步操作叫做鬆弛操作(relax)。假設u為小於估計值路徑上的上個頂點。</p><blockquote><p>RELAX(u,v,result)</p><p>if v.d > u.d + u->v</p><p>v.d = u.d + u->v</p><p>result[v] = u</p></blockquote><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/6ebf00043051c83a60b7><p>那麼，算法要做的就是一直鬆弛到達v頂點的路徑，從無窮直到最小路徑。可以看到，所有的求最短路徑的算法都要基於這個操作去求解，不同的算法只能就是執行這個操作順序不同或者次數不同。那麼鬆弛操作會不會出問題，會不會鬆弛操作做過頭了，將v的估計值鬆弛的比最短路徑還小？不會，在算法運行期間，對於所有頂點，一直對頂點進行鬆弛操作，頂點的預估值不會低於最短路徑。以下用結構證明法證明。</p><p>假設：u代表任意一個連接v的頂點，s->v代表s到v的邊，s~>v代表s到v的最短路徑。</p><p>命題：對到達v的所有路徑鬆弛操作有v.d >= s~>v</p><p>證明：</p><p>對於v=s的情況，v.d=0 s~v即s~s也為0，命題得證</p><p>假設對於頂點u，u.d >= s~>u成立。</p><p>有s~>v &lt;= s~>u + u->v，因為s~>v是一條最短路徑，對於任意一條經過u到達v的路徑，必小於最短路徑。</p><p>s~>v &lt;= u.d + u->v</p><p>因為經過鬆弛操作v.d = u.d + u->v，所以v.d >= s~>v，命題得證。</p><p>鬆弛操作只能同時對一條邊起作用。所以，最短路徑長為n的路徑，只能從最短路徑長為n-1的路徑，轉移過來。這裡就得到了這個問題最重要的性質，單源最短路徑問題是個最短路徑每次遞增一的動態規劃問題。</p><p>單源最短路徑性質：此問題是個最短路徑每次長度遞增一的動態規劃問題。</p><p>在介紹通用算法之前，先介紹一種專對於有向無環圖很巧的算法。</p><p><strong>有向無環圖單源最短路徑(DAG-Shortest-Paths)</strong></p><p>對於有向無環圖，可以先對圖進行拓撲排序，然後按拓撲排序的順序對每個頂點作為出度的邊進行鬆弛操作，就得到了問題的一個解。以下證明算法的正確性。</p><p>假設v為對圖拓撲排序後的某個頂點。當對v作為出度的邊進行鬆弛操作前，所有能到達v的路徑都已經做過了鬆弛操作，此時已經找到了到達v的最短路徑。那麼，當對所有頂點作為出度的邊進行鬆弛操作後，所有頂點的最短路徑就已經被找到。算法的正確性得到證明。</p><blockquote><p>偽代碼：</p><p>DAG-SHORTEST-PATHS(g)</p><p>let sorted = TOPOLOGICAL-SORTING-GREEDY(g)</p><p>let result be new Array</p><p>for u equal to every vertex in sorted</p><p>for v equal to every vertex adjacent to u</p><p>if v.d > u.d + u->v</p><p>RELAX(u,v,result)</p><p>end</p><p>end</p><p>return result</p></blockquote><p>時間複雜度:Θ(V+E)，V表示頂點的個數，E表示邊的個數</p><p>接下來介紹兩種通用的算法Bellman-Ford和Dijkstra。Bellman-Ford和Dijkstra有什麼聯繫呢？Bellman-Ford可以解決有負權重圖的單源最短路徑問題，並且可以偵測出圖中是否存在負環。Dijkstra只能解決沒有負權重邊的圖的單源最短路徑問題。Bellman-Ford是進行必須的最少次數的鬆弛操作。而Dijkstra發現，只要沒有負權重邊，還能進行更少的鬆弛操作解決問題。</p><p><strong>Bellman-Ford</strong></p><p>Bellman-Ford是最通用的解決單源最短路徑算法，初始將所有頂點估計值設為無窮，將源點設為零。然後，對所有邊進行鬆弛操作，這個步驟作為內部循環。再將這個步驟做圖的頂點個數減一次。</p><p>Bellman-Ford的正確性不難證明，可以看到隨著Bellman-Ford算法內部的循環，Bellman-Ford找到的最短路徑的長度也在增加。首先證明內部循環在循環到第n次時，找到了所有最短路徑長為n的路徑。我們用結構證明法。在以下證明中，可以看出Bellman-Ford雖然不是經典的動態規劃算法，但是其原理是基於這個問題的動態規劃性質的。</p><p>證明：</p><p>對於n=0時，最短路徑為0，命題得證。</p><p>假設所有最短路徑為n-1的路徑已經被找到。因為根據單源最短路徑的動態規劃性質，最短路徑長為n的路徑，可以從最短路徑長為n-1的路徑，轉移過來的。因為Bellman-Ford算法會對所有的邊進行鬆弛操作。所以，所有長為n的最短路徑會從相應的長為n-1的最短路徑找到。命題得證。</p><p>只要最短路徑上不存在負環，那麼所有最短路徑就必小於V-1。所以，Bellman-Ford內部循環執行V-1次，能找到最長的最短路徑，也就是能找到所有的最短路徑。Bellman-Ford正確性證畢。</p><p>Bellman-Ford實現也很簡單，這裡添加一個flag位，提前省去不必要的循環。</p><blockquote><p>偽代碼：</p><p>BELLMAN-FORD(g,s)</p><p>let edges be all the edge of g</p><p>let result be new Array</p><p>for i from 1 to the number of vertex of g</p><p>result[i] = INT_MAX</p><p>end</p><p>result[s] = 0</p><p>for i from 1 to the number of vertex of g minus 1</p><p>let flag = false</p><p>for j from 1 to the numnber of edge of g</p><p>let edge = edges[j]</p><p>if result[edge.src] != INT_MAX and edge.src > edge.des + edge.weight</p><p>RELAX(u,v,result)</p><p>flag = true</p><p>end</p><p>if flag == false</p><p>break</p><p>end</p><p>return result</p></blockquote><p>時間複雜度:O(V⋅E)，V表示頂點的個數，E表示邊的個數</p><p>為什麼Bellman-Ford算法可以偵測出有負環？算法完成後再對圖的所有邊進行一次鬆弛操作，如果最短路徑求得的值改變了，就是出現了負環。這個證明看一下鬆弛操作的定義就行了。根據鬆弛操作的性質，頂點的估計在等於最短路徑後不會再改變了，如果改變了就是出現了負環，從而沒有得到最短路徑。</p><p><strong>Dijkstra</strong></p><p>Dijkstra是個貪心算法，樸素的想一下，用貪心算法怎麼解決問題。既然沒有負權邊，選出當前階段最短的路徑，這個路徑就應該是到達這個路徑終點的最短路徑。</p><p>Dijkstra就是這樣一個貪心算法，初始將所有頂點估計值設為無窮，將源點設為零。維護一個集合S代表已經找到的最短路徑頂點，然後從集合S外所有頂點，選擇有最小的估計值的頂點加入到集合中，然後再對這個頂點在S中的臨接頂點做鬆弛操作，一直到所有頂點都在集合S中。</p><p>Dijkstra的貪心選擇使用簡單的反證法就可以證出。</p><p>假設，現階段要選從s到某個頂點u的路徑作為最短路徑加入到集合S中，並且這個選擇是錯誤的。有另一條最短路徑從s到達u，那麼這條路徑和原選擇的路徑肯定不一致，經過不同的頂點，假設這條最短路徑上到達u的前一個頂點為k，既然這是一條從s到達u的最短路徑，那麼從s到k肯定比從s到v小，那麼算法會先選擇從s到k，然後選擇最短路徑，不會選擇假設的路徑，這與假設矛盾，假設不成立，貪心選擇正確性得證。</p><p>以下是算法導論上的證明，嘗試從實際發生了什麼去證明正確性，我認為有點clumsy(笨重)，核心的想法其實和上面簡單的反證法一致。</p><p>命題：選擇有最小估計值的頂點加入集合S，那麼這個估計值必定是這個頂點的最小路徑。</p><p>同樣使用反證法來證，並且關注已經選擇了最小預估值的頂點但還沒加入頂點S時的情形。</p><p>假如選擇了頂點u，這時，將從s到u作為最小條路徑加入到S中，分為兩種情況。情況一，選擇的從s到u的路徑就是最短路徑，那麼命題已經得證。情況二，選擇的從s到u的路徑不是最短路徑，存在u.d>s~>u。這種情況下，可以找到一個頂點x，使得x在集合S中，並在對x進行鬆弛操作後，找到另一個頂點y，使得y不在集合中且y的估計值就等於s到y的最短路徑即s~>y。x可以與s重合，y可以與u重合。</p><p>那麼有y.d = s~>y</p><p>因為從s到y是從s到u的子路徑，有s~>u >= s~>y</p><p>得出s~>u >= y.d</p><p>因為選擇了頂點u，有u.d &lt;= y.d</p><p>得出s~>u >= u.d</p><p>這與假設矛盾，所以假設不成立，命題得證。</p><p>實現和時間複雜度與Prim算法類似，集合S用最小堆實現。</p><blockquote><p>偽代碼：</p><p>DIJKSTRA(g,s)</p><p>let heap be new MinHeap</p><p>let result be new Array</p><p>for i from 1 to the number of vertex in g</p><p>let vertex be new Vertex(i)</p><p>vertex.d = INT_MAX</p><p>heap.insert(vertex)</p><p>end</p><p>heap.decrease(s,0)</p><p>while heap.empty == false</p><p>vertex u = heap.top</p><p>for v equal to every vertex adjacent to u</p><p>if heap.isNotInHeap(v) and u.d v.d > u.d + u->v</p><p>RELAX(u,v,result)</p><p>heap.decrease(v,v.d)</p><p>end</p><p>end</p><p>return result</p></blockquote><p>可以看到，如果運氣好，Bellman-Ford不需要V次循環就可以找到所有最短路徑，但是運氣不好，Bellman-Ford要經過最少V次循環，這就是上文說到的，Bellman-Ford是進行必須的最少次數的鬆弛操作。而如果不存在負權重邊，Dijkstra可以進行更少次的鬆弛操作，至多對每個頂點連接的邊進行一次鬆弛操作就可以了，Bellman-Ford與Dijkstra的聯繫實際上就是動態規劃與貪心算法的聯繫。Bellman-Ford和Dijkstra算法本質都是單源最短路徑性質。</p><p><strong>全對最短路徑(All-Pair-Shortest-Paths)</strong></p><p>全對最短路徑就是將圖中任意兩點之間的最短路徑求出來，輸出一個矩陣，每個元素代表橫座標作為標號的頂點到縱座標作為標號的頂點的最短路徑。當然，可以對所有頂點運行一次Bellman-Ford算法得出結果，不過這樣的複雜度就太高了。嘗試去找到更好的算法解決這個問題。</p><p>既然單源最短路徑是個最短路徑遞增一的動態規劃問題，嘗試對全對最短路徑使用這種性質，然後看看能不能降低複雜度。</p><p>假設有n個頂點，dpij代表從頂點i到頂點j的最短路徑，假設這條最短路徑長為m，且k為任意頂點。那麼，根據這個問題的動態規劃狀態轉移特徵，dpij是由長度為m−1的dpik加上k->j轉移過來的。</p><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6ec2000bc467845a28b8><p>看來即使在單源最短路徑動態規劃的性質上進行求解，複雜度仍然很高。</p><p>嘗試不從最短路徑長度角度考慮動態規劃，從頂點角度去考慮動態規劃，引出一個通用的算法Floyd-Warshall。</p><p><strong>Floyd-Warshall</strong></p><p>好，從頂點的角度去思考動態規劃。從頂點i到頂點j要經過其他頂點，假設經過的頂點為k。然後根據解動態規劃的經驗，猜想dpij與dpik和dpkj怎麼能沾到邊？假設從i到j只需要經過[1,k]集合中的頂點。如果從i到j經過k，那麼dpik就代表從i到k的最短路徑，dpkj就代表從k到j的最短路徑，dpij就等於從dpik和dpkj轉移過去，而dpik和dpkj都不經過k，都只需要經過[1,k-1]集合中的頂點。如果從i到j不經過k，dpij就等於從i到j只需要經過[i,k-1]集合中的頂點時的dpij。</p><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6eb9000c3e4b079360cf><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/6f9c00059234653e165c><blockquote><p>偽代碼：</p><p>FLYOD-WARSHALL(g)</p><p>let dp be new Table</p><p>for i from 1 to the number of vertex in g</p><p>for j from 1 to the number of vertex in g</p><p>dp[i][j] = g[i][j]</p><p>end</p><p>end</p><p>for k from 1 to the number of vertex in g</p><p>for i from 1 to the number of vertex in g</p><p>for j from 1 to the number of vertex in g</p><p>if dp[i][k] + dp[k][j] &lt; dp[i][j]</p><p>dp[i][j] = dp[i][k] + dp[k][j]</p><p>end</p><p>end</p><p>end</p><p>return dp</p></blockquote><p>時間複雜度:Θ(V3)，$V$表示頂點的個數</p><p><strong>Johnson</strong></p><p>對於稀疏圖的話，還有辦法降低算法複雜度。直觀上看，對於稀疏圖，對每個頂點運行Dijkstra算法是快過Floyd-Warshall算法的，但是這樣要求圖中不能有負權邊。那麼，可不可以將有負權邊的圖轉化為沒有負權邊的圖。Johnson就是這樣一個算法，將所有的邊進行重新賦權重(reweight)，然後再對所有頂點運行Dijkstra算法。那怎麼進行重新賦權重呢？樸素想法是找出所有的邊中最小的值，然後所有邊增加這個值。很可惜，這樣不行。考慮這樣一個情況，頂點a到b的最短路徑有3條邊，最短路徑為4。有a到b另一條路徑只經過一條邊，路徑權重為5。如果對所有邊增加1權重，那麼頂點a到頂點b的最短路徑就改變了。重新賦權重改變了最短路徑是明顯有問題的。</p><p>可以看出重新賦權重有兩點要求：</p><p>1.對起點和終點相同的路徑改變同樣的權重，保持原來的最短路徑結果。</p><p>2.所有邊重新賦權以後不存在負權邊。</p><p>Johnson算法先對頂點重新賦值，然後將邊的重新賦值由兩端頂點的重新賦的值得出。假設u和v為相鄰的兩個頂點。</p><img alt=圖論的各種基本算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/6f9a0005d9cbc74dfc0a><p>這樣定義w’函數以後，對路徑重新賦的值影響的只有起點和終點兩個頂點，中間頂點重賦的值都被消掉了。等價於保持原來的最短路徑結果。那麼，怎麼保證第二點？Johnson算法會為圖增加一個頂點s，然後對圖運行一次Bellman-Ford算法。得出新增的頂點s與所有原頂點的最短路徑，這個最短路徑就是h數的值。</p><p>而且在運行Bellman-Ford算法的時候，正好可以偵測出圖中是否有負環。</p><blockquote><p>偽代碼：</p><p>JOHNSON(g)</p><p>let s be new Vertex</p><p>g.insert(s)</p><p>if BELLMAN-FORD(g,s) == flase</p><p>there is a negative cycle in graph</p><p>else</p><p>for v equal to every vertex in g</p><p>h(v) = min(v~>s)</p><p>end</p><p>for (u,v) equal to every edge in graph</p><p>w’(u,v) = w(u,v) + h(u) - h(v)</p><p>end</p><p>let result be new Table</p><p>for u equal to every vertex in g</p><p>DIJSKTRA(g,u)</p><p>for v equal to every vertex in g</p><p>result[u][v] = min(u~>v) + h(v) - h(u)</p><p>end</p><p>end</p><p>return result</p></blockquote><p>時間複雜度:O(V⋅Elog2V+V2log2V+V⋅E)，V表示頂點的個數，E表示邊的個數</p><p>證明了這麼多的算法正確性，可以看到，證明是有技巧的，常用的只有三個方法，反證法、結構歸納法、Cut-And-Paste法。</p><p>經過圖論的探討，便可以理解算法與數學之間緊密的聯繫。解決問題要對問題本身的特徵、屬性進行總結或者提煉。有時要對問題進行相應的轉化。然後根據問題的特徵、性質推導出定理。再將定理拓展，提出推論。最後，算法就在燈火闌珊處了。</p><p>這感覺就像，不是你找到了合適的算法。而是合適的算法找到了你。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>圖論</a></li><li><a>各種</a></li><li><a>算法</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/25a9f8cd.html alt=一起看看啥是圖論算法-第一期：圖的基本表示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1dcb968132c34dcdbb855dac6472e42e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/25a9f8cd.html title=一起看看啥是圖論算法-第一期：圖的基本表示>一起看看啥是圖論算法-第一期：圖的基本表示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html alt=各種門窗知識大全，是我見過最全的了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349013240149cf1ef5531 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html title=各種門窗知識大全，是我見過最全的了>各種門窗知識大全，是我見過最全的了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html alt="技術帖 | 3分鐘搞定各種測試分析技術" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f055e0a4477240088de2abb7cd696cfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html title="技術帖 | 3分鐘搞定各種測試分析技術">技術帖 | 3分鐘搞定各種測試分析技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a2f47a.html alt=識別各種各樣的電纜電線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3e680001e11c782e8928 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a2f47a.html title=識別各種各樣的電纜電線>識別各種各樣的電纜電線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4df1d2c4.html alt=飛行裡的各種“高度”小總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/895f051cf5e2438aa63b08f44bd1cbff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4df1d2c4.html title=飛行裡的各種“高度”小總結>飛行裡的各種“高度”小總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12c5d155.html alt=防控新冠病毒的的各種“新”方法，靠譜不 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/987bbc71-1082-4586-875c-b97870275bbb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12c5d155.html title=防控新冠病毒的的各種“新”方法，靠譜不>防控新冠病毒的的各種“新”方法，靠譜不</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0903fbf9.html alt=常見的調整浪：三角形的各種變形圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/57c439a06ccf4f9f93d01541668817b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0903fbf9.html title=常見的調整浪：三角形的各種變形圖解>常見的調整浪：三角形的各種變形圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9210b27d.html alt=18元四合一手擀麵有7兩面，各種臊子搭配鋪滿，碗大得像個小盆子 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/70ddd39f91a344bbb30981e2d3bb8671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9210b27d.html title=18元四合一手擀麵有7兩面，各種臊子搭配鋪滿，碗大得像個小盆子>18元四合一手擀麵有7兩面，各種臊子搭配鋪滿，碗大得像個小盆子</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c2db1e0.html alt=各種美味麵條的18種做法，麵食控們福利來了，好面不怕香過頭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/061f13052d2c4499aa7fe4c1f95c426c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c2db1e0.html title=各種美味麵條的18種做法，麵食控們福利來了，好面不怕香過頭>各種美味麵條的18種做法，麵食控們福利來了，好面不怕香過頭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f674acb.html alt=你必須掌握各種特殊體型的量體技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fded122d37c4048a34968909add59bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f674acb.html title=你必須掌握各種特殊體型的量體技巧>你必須掌握各種特殊體型的量體技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cbf8e6e.html alt=各種電路圖，太實用了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/b0e0005860fc89c577e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cbf8e6e.html title=各種電路圖，太實用了！>各種電路圖，太實用了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html alt=七大查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html title=七大查找算法>七大查找算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html alt=掌握算法-散列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html title=掌握算法-散列>掌握算法-散列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f6825c6.html alt="各種家電常見功率、電流、耗電量彙總， 希望對裝修中的你有幫助" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1520318671327a3e71c1a8d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f6825c6.html title="各種家電常見功率、電流、耗電量彙總， 希望對裝修中的你有幫助">各種家電常見功率、電流、耗電量彙總， 希望對裝修中的你有幫助</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>