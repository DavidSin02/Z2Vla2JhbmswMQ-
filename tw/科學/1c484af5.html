<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基於Nodejs打造Web架構中間層 | 极客快訊</title><meta property="og:title" content="基於Nodejs打造Web架構中間層 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/81f72e5d40db415d94bc7a8e7a9f82fb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/1c484af5.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/1c484af5.html><meta property="article:published_time" content="2020-11-14T20:57:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:57:17+08:00"><meta name=Keywords content><meta name=description content="基於Nodejs打造Web架構中間層"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/1c484af5.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基於Nodejs打造Web架構中間層</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>前言</strong></h1><p style=text-align:start>Node.js自2009年誕生以來，發展速度相當驚人，目前各種開發框架層出不窮，國內外各大公司都在使用，如國內的阿里的淘寶、天貓、阿里雲、螞蟻金服，騰訊視頻、攜程、百度、網易、蘇寧、京東、愛奇藝、去哪兒、有贊、貝殼找房等等好多企業都在使用，大部分企業把Node.js作為中間層去應用，今天和大家簡單說說關於基於Nodejs打造Web架構中間層的一些知識。</p><h1 class=pgc-h-arrow-right><strong>一、中間層與中間件</strong></h1><h1 class=pgc-h-arrow-right><strong>1、什麼是中間層</strong></h1><p style=text-align:start>中間層（Middle Tier）也稱作應用程序服務器層或應用服務層，是用戶接口或 Web 客戶端與數據庫之間的邏輯層。典型情況下 Web 服務器位於該層，業務對象在此實例化。中間層是生成並操作接收信息的業務規則和函數的集合。它們通過業務規則（可以頻繁更改）完成該任務，並由此被封裝到在物理上與應用程序程序邏輯本身相獨立的組件中。</p><h1 class=pgc-h-arrow-right><strong>1.1 Node作為中間層模式</strong></h1><p style=text-align:start>以Node作為中間層，當客戶端打開一個網站時，先請求到node服務器這一層，通過node服務器轉發請求到後端的服務器，獲取數據，然後返給node的模板引擎，根據視圖模板渲染好模板字符串頁面，再返回給客戶端，直接展示頁面，如圖：</p><div class=pgc-img><img alt=基於Nodejs打造Web架構中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81f72e5d40db415d94bc7a8e7a9f82fb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>1.2 負載均衡器-Nginx</strong></h1><p style=text-align:start>Nginx是一個高性能的WEB服務器和反向代理服務器，最常用的軟件負載均衡器。</p><p style=text-align:start>當訪問量比較大時，頻繁的請求，會給服務帶來很大壓力，通過負載均衡、分流，減輕服務器的壓力；另一方面，網站部署在多臺服務器，當某臺服務器故障的時候，可以馬上切換到其它服務器，還能保證網站能正常訪問，這就是負載均衡的優勢。</p><div class=pgc-img><img alt=基於Nodejs打造Web架構中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7bca338f8f07446bba97166fdf8effb2><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2、什麼是中間件</strong></h1><h1 class=pgc-h-arrow-right><strong>2.1 中間件概念</strong></h1><p style=text-align:start>中間件(MiddleWare)是一種獨立的系統軟件服務程序，分佈式應用軟件藉助這種軟件在不同的技術之間共享資源，中間件位於客戶機服務器的操作系統之上，管理計算資源和網絡通信。從這個意義上可以用一個等式來表示中間件：中間件=平臺+通信，這也就限定了只有用於分佈式系統中才能叫中間件，同時也把它與支撐軟件和實用軟件區分開來。</p><p style=text-align:start>在NodeJS中，中間件主要是指封裝所有Http請求細節處理的方法。一次Http請求通常包含很多工作，如記錄日誌、ip過濾、查詢字符串、請求體解析、Cookie處理、權限驗證、參數驗證、異常處理等，但對於Web應用而言，並不希望接觸到這麼多細節性的處理，因此引入中間件來簡化和隔離這些基礎設施與業務邏輯之間的細節，讓開發者能夠關注在業務的開發上，以達到提升開發效率的目的。中間件可以理解為一個對用戶請求進行過濾和預處理的東西，它一般不會直接對客戶端進行相應，而是將處理之後的結果傳遞下去。簡單來說就是實現某種功能的函數。</p><p style=text-align:start>Express是一個自身功能極簡，完全是路由和中間件構成一個web開發框架：從本質上來說，一個Express應用就是在調用各種中間件，中間件機制如圖所示：</p><div class=pgc-img><img alt=基於Nodejs打造Web架構中間層 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f52e6175e419404e869fc5d1b9dec2f5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2.2 中間件機制核心實現</strong></h1><p style=text-align:start>中間件是從Http請求發起到響應結束過程中的處理方法，通常需要對請求和響應進行處理，因此一個基本的中間件的形式如下：</p><p style=text-align:start>`const middleware = (req, res, next) => {</p><p style=text-align:start>// TODO</p><p style=text-align:start>next()</p><p style=text-align:start>}`</p><h1 class=pgc-h-arrow-right><strong>二、中間層的意義</strong></h1><p style=text-align:start>Node.js是一個Javascript運行環境。Node.js 使用事件驅動， 非阻塞I/O 模型而得以輕量和高效，非常適合在分佈式設備上運行數據密集型的實時應用。Node.js是單進程、單線程運行機制，通過事件輪詢（event loop）來實現併發操作，而且性能很好。</p><p style=text-align:start>Node.js最大的改良架構就是"增加了中間層"，前後端分離，使用Node.js來做‘BBF(backend of frontend)’在傳統後端加入了Node.js這一層，通過此有兩點好處，前端接管了view層，後端渲染也開始全部由前端掌控，另一個就是接口層增加了一層。在前後端分離的天然選擇下，Node.js中間層可以承擔更多的責任。</p><h1 class=pgc-h-arrow-right><strong>1、Node.js中間層可做的工作</strong></h1><ul><li>代理：在開發環境下，我們可以利用代理來，解決最常見的跨域問題；在線上環境下，我們可以利用代理，轉發請求到多個服務端。</li><li>緩存：緩存其實是更靠近前端的需求，用戶的動作觸發數據的更新，Node.js中間層可以直接處理一部分緩存需求。</li><li>限流：Node.js中間層，可以針對接口或者路由做響應的限流。</li><li>日誌：相比其他服務端語言，Node.js中間層的日誌記錄，能更方便快捷的定位問題（是在瀏覽器端還是服務端）。</li><li>監控：擅長高併發的請求處理，做監控也是合適的選項。</li><li>鑑權：有一箇中間層去鑑權，也是一種單一職責的實現。</li><li>路由：前端更需要掌握頁面路由的權限和邏輯。</li><li>服務端渲染：Node.js中間層的解決方案更靈活，比如SSR、模板直出、利用一些JS庫做預渲染等等。</li></ul><h1 class=pgc-h-arrow-right><strong>2、Node.js中間層帶來的好處</strong></h1><ul><li>通過PC Web自己的中間層，可以按照業務定製化接口，擴大前端展現的能力和範圍；</li><li>中間層接口由使用接口的前端工程師開發，對展現和接口的功能更加熟悉，避免了以前的工作模式中接口方跟各方的需求對接、溝通、聯調時間，這樣使得項目的推進更加順利，項目迭代會更快；</li><li>中間層使用NodeJS，開發語言是JavaScript，跟現在前端工程師的工作語言一樣，減少了學習成本；</li><li>中間層接口的開發由前端工程師同時負責開發，既節省了人力成本，同時又提高了前端開發人員的技術能力，使得前端工程師向全棧工程師邁進。</li></ul><h1 class=pgc-h-arrow-right><strong>3、Node.js中間層的優勢</strong></h1><ul><li>功能分離，減輕板塊負擔;</li><li>跨系統、跨終端均可重用頁面數據校驗、邏輯代碼，無需因為新系統、終端的接入而重寫校驗；</li><li>只在中間件中做一次數據校驗，避免了前端做數據校驗的同時後端也要做校驗的重複，在有效保證數據的有效性的同時降低了團隊整體的工作量；</li><li>處理數據邏輯，解放了前端既要做頁面渲染又要寫複雜的邏輯，使得頁面開發人員專注於頁面渲染，不僅使得分工更為明確，項目協作效率更高，更重要的是快速響應頁面使得頁面加載更快，用戶體驗更好，避免了瀏覽器長時間顯示空白頁面的不友好體驗，真正的前後端分離。</li></ul><h1 class=pgc-h-arrow-right><strong>三、中間層的實現</strong></h1><p style=text-align:start>前面寫了很多理論方面的知識，接下來自己手動來簡單實現Node.js基於Koa框架實現的中間層。</p><h1 class=pgc-h-arrow-right><strong>1、後端提供的接口</strong></h1><p style=text-align:start>先了解一下後端提供的一個接口，根據前端頁面輸入不同賬號信息，後端接口會返回不同的值，如圖：</p><div class=pgc-img><img alt=基於Nodejs打造Web架構中間層 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/19fe65b5f7704bf998b43436eafd5cf8><p class=pgc-img-caption></p></div><p>這段PHP代碼是根據前端傳給不同的用戶名和密碼狀態返回不同的狀態碼。</p><h1 class=pgc-h-arrow-right><strong>2、搭建前端頁面</strong></h1><p style=text-align:start>前端頁面用了ejs模板引擎採用服務端渲染方式來進行。前端頁面主要有三個代碼的文件，app.js，admin.js，admin.ejs。</p><h1 class=pgc-h-arrow-right><strong>2.1 項目代碼結構</strong></h1><div class=pgc-img><img alt=基於Nodejs打造Web架構中間層 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aca06c919ca8420397fbce742d449824><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>2.2 項目代碼展示</strong></h1><p style=text-align:start>1、是app.js代碼</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Koa = require('koa');</p><p style=text-align:start>// 路由</p><p style=text-align:start>const Router = require('koa-router');</p><p style=text-align:start>// 模板引擎</p><p style=text-align:start>const ejs = require('koa-ejs');</p><p style=text-align:start>// 數據解析</p><p style=text-align:start>const body = require('koa-bodyparser');</p><p style=text-align:start>// 處理靜態文件</p><p style=text-align:start>const static = require("koa-static");</p><p style=text-align:start>const path = require('path');</p><p style=text-align:start>const app = new Koa();</p><p style=text-align:start>ejs(app,{</p><p>root:path.resolve(__dirname,"template"),</p><p>layout:false,</p><p>viewExt:"ejs",</p><p>cache:false,</p><p>debug:false</p><p style=text-align:start>})</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>app.use(body());</p><p style=text-align:start>router.get("/",ctx => {</p><p>ctx.body = '主頁';</p><p style=text-align:start>})</p><p style=text-align:start>router.use("/admin",require("./router/admin"));</p><p style=text-align:start>app.use(static('./static'));</p><p style=text-align:start>app.use(router.routes());</p><p style=text-align:start>app.listen(3000);`</p></blockquote><p style=text-align:start>2、登錄頁面文件，用ejs模板引擎來處理</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`&lt;!DOCTYPE html></p><p style=text-align:start>&lt;html lang="en"></p><p style=text-align:start>&lt;head></p><p>&lt;meta charset="UTF-8"></p><p>&lt;meta name="viewport" content="width=device-width, initial-scale=1.0"></p><p>&lt;meta http-equiv="X-UA-Compatible" content="ie=edge"></p><p>&lt;title>我是管理頁面&lt;/title></p><p>&lt;script src="../../js/jquery.min.js">&lt;/script></p><p style=text-align:start>&lt;/head></p><p style=text-align:start>&lt;body></p><p>&lt;p>用戶：&lt;input type="text">&lt;/p></p><p>&lt;p>密碼：&lt;input type="password">&lt;/p></p><p>&lt;button>提交&lt;/button></p><p>&lt;script></p><p>$(function(){</p><p>$('button').click(function(){</p><p>var username = $(':text').val();</p><p>var password = $(':password').val();</p><p>$.ajax({</p><p>url:'/admin/login',</p><p>method:'post',</p><p>data:{</p><p>username,</p><p>password</p><p>},</p><p>success(data){</p><p>console.log(data);</p><p>}</p><p>})</p><p>})</p><p>})</p><p>&lt;/script></p><p style=text-align:start>&lt;/body></p><p style=text-align:start>&lt;/html>`</p></blockquote><h1 class=pgc-h-arrow-right><strong>3、代碼逐步實現邏輯</strong></h1><p style=text-align:start>1、使用上面的登錄頁代碼，然後admin.js頁面代碼如下</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Router = require('koa-router');</p><p style=text-align:start>const querystring = require('querystring');</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>router.get('/',async ctx=>{</p><p>await ctx.render('admin/admin')</p><p style=text-align:start>})</p><p style=text-align:start>router.post("/login",async ctx => {</p><p>const { username,password } = ctx.request.body;</p><p>console.log(username,password);</p><p style=text-align:start>})</p><p style=text-align:start>module.exports = router.routes();`</p></blockquote><p style=text-align:start>此時登錄頁面輸入用戶名和密碼點擊提交時會輸出結構如下代碼：</p><blockquote class=pgc-blockquote-abstract><p>``^CedzdeMacBook-Pro-5:0323 edz$ nodemon app.js</p><p>[nodemon] 2.0.2</p><p>[nodemon] to restart at any time, enter rs<br></p><p>[nodemon] watching dir(s): <em>.</em></p><p>[nodemon] watching extensions: js,mjs,json</p><p>[nodemon] starting node app.js<br></p><p>admin 123456 //後端拿到了前端傳給的數據``</p></blockquote><p style=text-align:start>此時傳過的數據後端會拿他與數據庫作比對，進行處理，而Node.js只充當中介作用，不做數據的處理。</p><p style=text-align:start>2、我們接著看，把要的數據傳個服務端，使用axios發送數據到服務端，其中裡面用到了數據格式的轉換：</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Router = require('koa-router');</p><p style=text-align:start>const querystring = require('querystring');</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>router.get('/',async ctx=>{</p><p>await ctx.render('admin/admin')</p><p style=text-align:start>})</p><p style=text-align:start>//此處為中間層，起到中介作用，會把數據發給後端接口</p><p style=text-align:start>router.post("/login",async ctx => {</p><p>const { username,password } = ctx.request.body;</p><p>//console.log(username,password);</p><p>//要數據傳給服務端，使用axios發送數據到服務端</p><p>const {data} = await axios({</p><p>url:'http://localhost/login/check.php',</p><p>method:'post',</p><p>data:{</p><p>username,</p><p>password</p><p>},</p><p>// username=admin&password=123456查詢字符串</p><p>//數據格式轉換，前端是個JSON數據格式，後端拿到的是表單數據</p><p>transformRequest:[</p><p>data =>{</p><p>return querystring.stringify(data)</p><p>}</p><p>]</p><p>})</p><p style=text-align:start>})</p><p style=text-align:start>module.exports = router.routes();`</p></blockquote><p style=text-align:start>此時登錄頁面輸入用戶名和不同的密碼和空密碼時點擊提交時會輸出結構如下代碼：</p><blockquote class=pgc-blockquote-abstract><p>``^CedzdeMacBook-Pro-5:0323 edz$ nodemon app.js</p><p>[nodemon] 2.0.2</p><p>[nodemon] to restart at any time, enter rs<br></p><p>[nodemon] watching dir(s): <em>.</em></p><p>[nodemon] watching extensions: js,mjs,json</p><p>[nodemon] starting node app.js<br></p><p>{ code:1 }</p><p>{ code:0 }</p><p>{ code:3 }``</p></blockquote><p style=text-align:start>3、這時我們把後端傳回的接口數據在進行重新包裝一下，添加如下代碼：</p><p style=text-align:start>`// 重新包裝</p><pre><code>if(data.code !== 1){    // return中斷條件    return ctx.body = {        code:401,        message:'未經授權'    }}// 前端自己定義的提示語 ，後端專注邏輯開發，不用在和前端定義接口ctx.body = {   code:200,   message:'校驗成功'}`</code></pre><p style=text-align:start>這時頁面會返回經過前端包裝的提示語，如圖所示：</p><div class=pgc-img><img alt=基於Nodejs打造Web架構中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7b0f6e683e5141229ebde908717b6d0e><p class=pgc-img-caption></p></div><p style=text-align:start>總的處理路由的admin.js代碼文件如下：</p><blockquote class=pgc-blockquote-abstract><p style=text-align:start>`const Router = require('koa-router');</p><p style=text-align:start>const axios = require('axios');</p><p style=text-align:start>const querystring = require('querystring');</p><p style=text-align:start>const router = new Router();</p><p style=text-align:start>router.get('/',async ctx=>{</p><p>await ctx.render('admin/admin')</p><p style=text-align:start>})</p><p style=text-align:start>//此處為中間層，起到中介作用，會把數據發給後端接口</p><p style=text-align:start>router.post("/login",async ctx => {</p><p>const { username,password } = ctx.request.body;</p><p>//console.log(username,password);</p><p>//要數據傳給服務端，使用axios發送數據到服務端</p><p>const {data} = await axios({</p><p>url:'http://localhost/login/check.php', //後端提供的一個接口文件</p><p>method:'post',</p><p>data:{</p><p>username,</p><p>password</p><p>},</p><p>// username=admin&password=123456查詢字符串</p><p>//數據格式轉換，前端是個JSON數據格式，後端拿到的是表單數據</p><p>transformRequest:[</p><p>data =>{</p><p>return querystring.stringify(data)</p><p>}</p><p>]</p><p>})</p><p>// 重新包裝</p><p>// console.log(data);</p><p>if(data.code !== 1){</p><p>// return中斷條件</p><p>return ctx.body = {</p><p>code:401,</p><p>message:'未經授權'</p><p>}</p><p>}</p><p>// 前端自己定義的提示語 ，後端專注邏輯開發，不用在和前端定義接口</p><p>ctx.body = {</p><p>code:200,</p><p>message:'校驗成功'</p><p>}</p><p style=text-align:start>})</p><p style=text-align:start>module.exports = router.routes();`</p><p style=text-align:start>服務端不要暴露太多給用戶信息，不用提示用戶名正確或者密碼錯誤，防止被別人猜，前端根據後端提供的狀態碼重新定義輸出提示內容，對用戶來說特別的友好，不論後端給前端什麼樣的接口內容，前端都可以包裝接口，所以後端只要返回給前端數據就可以了，接口的定義前端自己可以進行包裝。</p></blockquote><h1 class=pgc-h-arrow-right><strong>四、總結</strong></h1><p style=text-align:start>中間層已經為越來越多的大公司所應用，進入中間層後，前端能做的事情越來越多，將觸角伸向了服務器，除了前後端分離外，還能做redis緩存，負載均衡策略。另一方面，不止是Node.js能做中間層，PHP也可以，因為Node.js是用js寫的，Node.js的生態很成熟，對於前端人員來說，比較容易上手。</p><p style=text-align:start>Web端的開發團隊是需求鏈中的最上游、數據鏈的下游，很多產品功能都受限於業務接口，中間層提供了一種可能，讓我們Web前端開發工作有了自己的接口開發能力可以對接最原始數據，既減少了前端開發中的侷限性，也讓前端團隊在開發過程中有了更多的想象力，能更好的根據業務需要快速開展項目。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Nodejs</a></li><li><a>Web</a></li><li><a>架構</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a2871b0c.html alt="可用於企業的 7 個最佳開源 Web 服務器！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1531874286737ba179830a5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a2871b0c.html title="可用於企業的 7 個最佳開源 Web 服務器！">可用於企業的 7 個最佳開源 Web 服務器！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html alt=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0670cbc9828449c782ac323a238b99e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6237da3d.html title=朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效>朗坤雙模IT架構的智慧電廠，更安全、更經濟、更環保、更高效</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html alt=活動文件櫃的架構是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/104d3629a97947b19d62b03dc3b8d82f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3d4671c.html title=活動文件櫃的架構是什麼>活動文件櫃的架構是什麼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html alt=九年新浪架構師整理PHP架構核心技術教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b3a3c32254344742b6746996f7fab54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b506f512.html title=九年新浪架構師整理PHP架構核心技術教程>九年新浪架構師整理PHP架構核心技術教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html alt=Kafka整體架構圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/05ae540358854cb3ba0aa4577709330d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c984f60.html title=Kafka整體架構圖解>Kafka整體架構圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html alt=MyBatis整體架構分析：基礎支持層、核心處理層和接口層 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d6a0b300b114d07b2f3fe66d7ef7005 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15af9d2.html title=MyBatis整體架構分析：基礎支持層、核心處理層和接口層>MyBatis整體架構分析：基礎支持層、核心處理層和接口層</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html alt=K8S整體架構解析，簡單明瞭 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/37380f3294a54bbf8c6bec1de3e08ba0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5747aeb3.html title=K8S整體架構解析，簡單明瞭>K8S整體架構解析，簡單明瞭</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0f9daff.html alt=Web技術整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15314704812092ac6479d59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0f9daff.html title=Web技術整體架構>Web技術整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html alt=支付系統：整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1d94fa40459462fa825d407a1904c7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f270aa9d.html title=支付系統：整體架構>支付系統：整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html alt=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bd78fffbaaf54bd79c6e463d5b69ed9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c2dbd39.html title=「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？>「系統架構」什麼是鏈路追蹤？分佈式系統如何實現鏈路追蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html alt=微服務分佈式架構中，如何實現日誌鏈路跟蹤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3a2cecaee304124a86a864a75c38b5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b7ca126.html title=微服務分佈式架構中，如何實現日誌鏈路跟蹤？>微服務分佈式架構中，如何實現日誌鏈路跟蹤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48822193.html alt="「前端架構」前端框架(一部): Angular的內幕" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/efd86e8d12f44e7b97726d738e8d6c1d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48822193.html title="「前端架構」前端框架(一部): Angular的內幕">「前端架構」前端框架(一部): Angular的內幕</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9879b4d6.html alt=萬字長文系列：Web前端百度面經（含答案）第二章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3faa5af7bf4f40f7831eb1f3c4270933 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9879b4d6.html title=萬字長文系列：Web前端百度面經（含答案）第二章>萬字長文系列：Web前端百度面經（含答案）第二章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4515b9af.html alt="Uber 架構(1)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/da0e1368146f4614836d85f921a0e4a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4515b9af.html title="Uber 架構(1)">Uber 架構(1)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>