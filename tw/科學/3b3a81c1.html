<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一個決策採樣器 | 极客快訊</title><meta property="og:title" content="一個決策採樣器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/3b3a81c1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/3b3a81c1.html><meta property="article:published_time" content="2020-11-14T20:51:43+08:00"><meta property="article:modified_time" content="2020-11-14T20:51:43+08:00"><meta name=Keywords content><meta name=description content="一個決策採樣器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/3b3a81c1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一個決策採樣器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><p><br></p><h2 class=pgc-h-arrow-right>作者：Jessica B. Hamrick</h2><p>Jess是一個加州大學伯克利分校的博士生。她通過把機器學習的概率模型和認知科學中的行為實驗結合在一塊來研究人類的認知行為。她在閒暇時間還是IPython和Jupyter的核心貢獻者。她之前在麻省理工獲得了計算機科學的本科和碩士學位。</p><hr><h2 class=pgc-h-arrow-right>簡介</h2><p>在計算機科學與工程科學中，我們常常會遇到不能簡單的用一個方程就能解決的問題。這些問題常常涉及到複雜系統，充滿噪聲的輸入，或者兩者並存。以下是幾個真實世界中的問題，他們都沒有一個精確的解析解：</p><ol start=1><li>你在計算機中建立了一架飛機的模型，然後你想知道這個飛機在不同天氣狀況下的表現；</li><li>基於一個地面水擴散的模型，你想評估由一個擬建的化工廠的化學排放會怎樣影響周邊居民的淡水供應；</li><li>你有一個機器人通過他的攝像頭捕捉充滿噪聲的圖片，然後你想恢復出這些圖片中物體的三維結構；</li><li>你想計算你走了某一步棋之後你贏棋的概率。</li></ol><p>雖然這些類型的問題不能被精確的求解，但我們通常能夠用蒙特卡洛採樣的辦法得到一個大概的解。在蒙特卡洛方法中，核心思想就是使用大量的樣本來預估最概然的解1。</p><h2 class=pgc-h-arrow-right>什麼是採樣？</h2><p>採樣是指基於某個概率分佈隨機的產生數值。舉個例子，扔骰子所得到的數值就是採樣的行為。從被洗過的牌堆頂摸的牌也是採樣。飛鏢射中靶上的某一個位置也是採樣。這些採樣中的唯一區別在於他們基於不同的概率分佈。在骰子這個例子中，概率分佈在六個可能的值等權重分佈。在牌的例子中，概率分佈在52個可能的值中等權重分佈。在飛鏢的例子中，概率分佈分佈於一個環形/圓形區域內（雖然這個分佈可能不是均勻的，取決於你玩飛鏢的水平）。</p><p>通常有兩種我們希望使用採樣的方式。第一種是隨機採樣的數值被存儲起來以便之後使用：在一個計算機撲克遊戲裡邊隨機摸到的牌就屬於這種情況。第二種情況中，採樣被用於估算。舉個例子，假設你懷疑你的朋友用的骰子有問題，你就會多擲幾次骰子來看是不是有的數出現的頻率遠遠高於你的預期。在飛機的例子中，也許你僅僅想在一系列的可能性中對飛機進行特性描述。天氣是一個特別混亂的系統，永遠都不可能精確的計算出飛機在某種特定天氣情況下是否能夠倖存。然而你可以多次的模擬飛機在不同天氣狀況下的行為，從而能夠得出飛機在某些特定條件下最容易失事。</p><h2 class=pgc-h-arrow-right>編程實現採樣和概率</h2><p>如同大多數計算機科學中的應用，你在編程實現採樣和概率的時候可以做設計決定，這些決定會對代碼整體的整潔性，相關性和正確性產生影響。在此小節中，我們會展示一個電腦遊戲中如何隨機採樣的小例子。我們尤其會專注於設計決定，這些決定具體關於如何設計採樣和估算概率的函數，與對數打交道，建立可重複性，以及把特定應用和產生採樣過程分別開來的步驟。</p><h3 class=pgc-h-arrow-right>關於記號</h3><p>我們使用p(x)來表示p是x這個隨機數的概率密度函數（PDF）或者概率質量函數。</p><p>在飛鏢的情況裡，概率分佈是連續的PDF，然而骰子的概率分佈是離散的PMF。兩者共同的一點是無論x值如何，p(x)>=0，也就是說概率必須是非負值。</p><p>我們通常用概率分佈來做兩件事情。對給定的一個隨機值x,我們希望能計算這個值在某一PDF/PMF中所對應的概率密度 （或質量）。我們用p(x)這樣的數學符號來表示x的概率密度。</p><p>對於給定的PDF或PMF，我們會希望生成符合該分佈函數的隨機值x(這樣我們在概率較高的x值處更有機會得到一個採樣)。我們用x~p來表示x是根據p分佈採樣的隨機值。</p><h1 class=pgc-h-arrow-right>隨機生成魔法裝備</h1><p>為了展示運用採樣中的一些設計決定，我們用一個角色扮演遊戲來作為例子。我們需要一個生成怪物隨機掉落的魔法裝備附加屬性值的方法。我們可以人為的決定一個裝備可以獲得的總共最大附加值是＋5，而且高附加屬性值出現的概率會小於低附加屬性值的概率。如果B是一個位於0和最大附加值之間的隨機數值。</p><p>我們還可以聲明共有6種屬性（敏捷，體質，力量，智力，智慧，魅力），隨機得到的總附加值將在這六項裡分配。所以一個＋5的裝備可以將分配在不同屬性裡（比如＋2智慧和＋3智力）或者集中在某一項屬性裡（比如＋5魅力）。</p><p>如何能隨機地從這個概率分佈裡採樣？最簡單的方法是先隨機產生總屬性值，然後再隨機將總附加值分配在六項屬性裡。巧合的是，總附加值和屬性分配這兩者所對應的概率質量函數正好都是多項分佈。</p><h1 class=pgc-h-arrow-right>多項分佈</h1><p>多項分佈用於描述有多種可能的結果時，你想要描述各種可能結果發生的概率。最經典用於解釋多項分佈的例子是甕中取球的問題。問題的描述是：有一個甕，甕裡有不同顏色的球（例如，30%紅球，20%藍色和50%綠色）。每次取出一個球，記錄它的顏色，把這個球放回甕中，再多次重複上述過程。在這種情況下，問題可能的結果即是取出的球的顏色（例如，取出的球是藍色的概率是p(blue)=20)。多項分佈被用於描述取出多個球時可能結果的組合（比如，兩綠一藍）。</p><p>以下部分的代碼在multinomial.py文件中。</p><h2 class=pgc-h-arrow-right>MultinomialDistribution類</h2><p>一般來講，有兩種使用一個分佈的情況：第一種，我們希望根據這個分佈進行採樣；第二種，我們希望評估某一個樣本在這個分佈的PMF／PDF下可能出現的概率。雖然實現這兩個目標的函數其實很不一樣，但他們都依賴於一點共同的信息：這個分佈的參數。在多項分佈的情況裡，它的參數時各種可能事件的概率，p(在甕中取球的例子中，這個參數對應在文中在甕中不同顏色的球數目的比例)。</p><p>最簡單的解法是建兩個函數，這兩個函數相互獨立，但都將該多項分佈的參數作為函數的輸入。但是我通常選擇使用一個類來代表一個分佈，這麼做有幾個好處：</p><ol start=1><li>只需要將分佈參數傳入一次（在創建這個類時）；</li><li>我們或許會對一些與這個分佈相關的屬性感興趣：平均值，方差，倒數，等等。如果我們有一系列函數以分佈對象為參數，用同一個分佈的類來封裝這些函數比每次調用一個函數都需要穿入分佈參數方便得多</li><li>檢查參數是否有效通常是個好主意（例如在多項分佈的例子裡，事件概率的矢量p求和應當歸一）。在構造函數裡檢查一次比起每次調用一個函數都要檢查會有效率的多。</li><li>有時候計算PMF和PDF需要根據給定參數計算常量。我們可以在構造函數裡提前計算這些常量，從而避免重複計算。</li></ol><p>這也是實際情況中很多統計包設計的方式，包含SciPy自己的分佈（他們位於scipy.stats模塊中）。出於教學展示的目的，雖然我們使用很多SciPy的函數，但我們沒有使用他們自帶的概率分佈（目前Scipy包中沒有多項分佈）。</p><p>以下是這個類的構造函數的代碼：</p><pre><code>import numpy as npclass MultinomialDistribution(object):    def __init__(self, p, rso=np.random):        &#34;&#34;&#34;Initialize the multinomial random variable.        Parameters        ----------        p: numpy array of length `k`            The event probabilities        rso: numpy RandomState object (default: None)            The random number generator        &#34;&#34;&#34;        # Check that the probabilities sum to 1. If they don&#39;t, then        # something is wrong! We use `np.isclose` rather than checking        # for exact equality because in many cases, we won&#39;t have        # exact equality due to floating-point error.        if not np.isclose(np.sum(p), 1.0):            raise ValueError(&#34;event probabilities do not sum to 1&#34;)        # Store the parameters that were passed in        self.p = p        self.rso = rso        # Precompute log probabilities, for use by the log-PMF, for        # each element of `self.p` (the function `np.log` operates        # elementwise over NumPy arrays, as well as on scalars.)        self.logp = np.log(self.p)</code></pre><p>這個類需要兩個參數，一個是事件概率p,另一個是叫做rso的變量。第一步，構造函數檢查分佈的參數是否有效，也就是說，p的和是否歸一。然後它將傳入的參數存儲在對象內，再用事件概率來計算對數事件概率（我們會解釋為什麼需要用對數）。rso對象是我們用來產生隨機數的引擎（我們之後也會更深入談論這個對象）。</p><p>在介紹這個類的別的部分之前，讓我們先看看關於構造函數的兩點。</p><h3 class=pgc-h-arrow-right>描述性變量名對數學變量名</h3><p>程序員們一般傾向於使用描述性的變量名字：比如，用independent_variable和dependent variable作為變量名通常比用x和y要好。根據經驗來看，一般不推薦使用僅有一個或兩個字符的名字來命名變量。但是，在我們的MultinomialDistribution裡，我們用到了變量命名為p,這直接違反了這一傳統命名法則。</p><p>雖然我同意在大部分情況中應當執行上述的命名法則，但是有一種例外情況：數學。在程序中實現數學方程時，方程裡通暢充滿了單個字符的變量，x, y, alpha, 等等。在程序中直接用這些名字命名相應變量是最便捷的方式。當然，這些名字並沒有包涵很多的信息，但是使用描述性的變量反而會破壞代碼與公式之間的聯繫，使得理解代碼更加困難。</p><p>我認為在寫一個直接實現某公式的程序的時候，變量名應該與公式裡的變量保持一致。這樣使得代碼和公式能夠一一對應起來。然而這麼做的副作用是單獨看某一部分代碼的時候理解更困難了，所以在代碼中插入豐富的評論來解釋當前部分代碼實現的功能非常重要。如果被實現的公式出現在了學術文章裡，評論就應當引用該公式在學術文章裡的編號，以便查找。</p><h3 class=pgc-h-arrow-right>載入NumPy包</h3><p>你可能注意到我們在程序開頭載入了numpy包，並用np代指它。這是數值運算中的標準做法，因為NumPy提供了海量有用的程序。有的文件裡邊常常會使用多個NumPy包裡的函數。在此章節這個簡單的例子中，我們僅僅使用了11個NumPy包裡的函數。在一個項目中，通常這個數目會輕鬆達到40個左右！</p><p>載入Numpy有幾種不同的辦法。我們可以用from numpy import *，但是通常不鼓勵這麼做，因為沒有了命名空間，我們很難區別每一個函數的來源。我們也可以單獨地載入每一個函數，如from numpy import array, log, ...，但是這個方法很快就變得很笨重。我們還可以直接用import numpy,但這樣導致的結果是代碼過長，閱讀起來不方便。下邊兩個例子都不是很方便閱讀，但是用np作為命名空間明顯比用numpy清楚的多。</p><pre><code>&gt;&gt;&gt; numpy.sqrt(numpy.sum(numpy.dot(numpy.array(a), numpy.array(b))))&gt;&gt;&gt; np.sqrt(np.sum(np.dot(np.array(a), np.array(b))))</code></pre><h2 class=pgc-h-arrow-right>從一個多項分佈裡採樣</h2><p>從一個多項分佈裡採樣實際上特別的直接，因為NumPy提供了一個函數實現這樣的功能：np.random.multinomail2</p><p>儘管這個函數已經存在，為了設計多項分佈的類還有幾個決定需要我們來做。</p><h3 class=pgc-h-arrow-right>給隨機數產生器提供種子</h3><p>雖然我們希望得到隨機的採樣，但有時候我們希望最後的結果是可重複的。儘管產生的數值看上去是隨機的，如果我們重新運行一遍程序，我們希望程序能夠使用完全相同的一個“隨機”數值的序列。</p><p>為了能夠生成這種“可重複隨機”數，我們需要能控制採樣函數生成隨機的方式。這樣的功能可以通過使用一個NumPy裡的RandomState對象來實現。這個對象可以作為參數進行傳遞。它擁有與np.random大部分相同的函數；唯一的區別是通過這個對象我們可以控制隨機數是從哪兒來的。創建該對象的方法如下：</p><pre><code>&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; rso = np.random.RandomState(230489)</code></pre><p>在上述代碼中傳遞給RandomsState構造函數的整數就是這個隨機數產生器的種子。只要我們用同一個種子來實例化對象，RandomState對象就會輸出一模一樣的“隨機數”序列，從而保證了可重複性：</p><pre><code>&gt;&gt;&gt; rso.rand()0.5356709186237074&gt;&gt;&gt; rso.rand()0.6190581888276206&gt;&gt;&gt; rso.rand()0.23143573416770336&gt;&gt;&gt; rso.seed(230489)&gt;&gt;&gt; rso.rand()0.5356709186237074&gt;&gt;&gt; rso.rand()0.6190581888276206</code></pre><p>之前在多項分佈類的構造函數中有一個參數為rso. 這個rso變量就是一個已經初始化了的RandomState對象。在這RandomState對象是一個可選的參數：有時候避免強制使用它比較方便，但是我們希望保留使用該對象的可能（如果只用np.random模塊的話，“可重複”是做不到的）。</p><p>所以，如果在調用函數時rso是空缺的，那麼構造函數默認的參數是np.random.multinomial。反之，構造函數會使用RandomState裡的多項分佈採樣函數。3</p><h3 class=pgc-h-arrow-right>用什麼作為參數？</h3><p>一旦我們決定了使用np.random.multinomial或者rso.multinomial，採樣就僅僅是調用相對的函數而已。但是還有另一個需要我們考慮的決定：用什麼作為參數？</p><p>之前我說到事件的可能性，p，是多項分佈的參數。但是有的人認為需要採樣的事件數，n，也可以作為多項分佈的一個參數。所以為什麼在這沒有將n也作為構造函數的參數？</p><p>雖然這個問題僅僅侷限於多項分佈，但其實在處理其它概率分佈的時候也會遇到。這個問題的答案很多時候取決於具體案例。對於一個多項分佈，每次採樣的事件數目總是一樣的麼？如果這個問題答案是肯定的，那麼構造函數最好還是把n作為一個參數。如果答案是否定的，那麼把限定對象一個具體的n會導致每次需要採樣的時候，都需要構建一個新的分佈對象！</p><p>通常代碼不應該被嚴格限制到這個程度，因此我們選擇把n作為採樣函數sample的參數，而不把它傳給分佈的構造函數。另一個替代辦法是把n作為構造函數的參數，但是建立一個方法來改變對象中n的值，從而避免重新建立一個新對象。在我們的情況裡，這種方案過於複雜了，因此我們採用前一種方法：</p><pre><code>def sample(self, n):    &#34;&#34;&#34;Samples draws of `n` events from a multinomial distribution with    outcome probabilities `self.p`.    Parameters    ----------    n: integer        The number of total events    Returns    -------    numpy array of length `k`        The sampled number of occurrences for each outcome    &#34;&#34;&#34;    x = self.rso.multinomial(n, self.p)    return x</code></pre><h2 class=pgc-h-arrow-right>計算多項分佈的PMF</h2><p>雖然我們並不需要顯式的計算隨機生成的魔法物品的概率，但是實現一個能夠計算該分佈的PMF/PDF的函數往往是一個好主意。為什麼？</p><p>一個原因是我們可以把該函數用於測試：假設我們用採樣函數生成了很多樣本，他們的分佈應該大致與初始的PMF／PDF一致。假如眾多樣本的統計分佈與初始PMF／PDF不一致，那麼我們的程序裡多半有bug。</p><p>另一個需要實現這麼一個函數的原因是之後你多半需要這麼一個函數。舉個例子，我們可能需要將生成的魔法物品歸類為普通，罕見和稀有。劃分等級的標準來自於產生樣本的概率。為了得到這個概率，就需要計算樣本對應的PMF。</p><p>最後，在很多情況裡，你自己的使用需求就決定了從一開頭就需要實現計算PMF／PDF的功能。</p><h3 class=pgc-h-arrow-right>多項分佈PMF公式</h3><p>多項分佈的嚴格定義如下：</p><p>一個長度為k的向量，表示每一件事件發生的次數；而是一個表示每件事件發生一次的概率的向量。正如上文提到，時間概率p是這個分佈的參數。</p><p>上邊公式裡的階乘可以用一個特殊函數來表示，稱作gamma函數。在代碼中，寫gamma函數比寫階乘有效率得多。</p><h3 class=pgc-h-arrow-right>概率使用對數值</h3><p>在介紹實現這一公式的程序之前，我想要強調在寫關於概率的代碼中最為重要的一個設計決定：使用對數數值。這意味著程序中與其使用實際的概率p(x),我們應該用概率的對數,log(p(x))。這麼做的原因是概率很容易會變得很小，進入浮點數誤差範圍造成數據下溢。</p><p>為了展示這一點，假設概率必須在0到1之間（包涵1）。NumPy有一個有用的函數，finfo，能夠告訴我們當前系統的浮點數的極限。比如，在一臺64位餓機器上，可以看見最小可用的正數（對應tiny變量）是：</p><pre><code>&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.finfo(float).tiny2.2250738585072014e-308</code></pre><p>雖然這個值看上去非常小，但是我們經常碰到這個數量級上的概率，甚至更小。而且幾個概率相乘是非常常見的操作。假如我們將兩個這個量級的概率相乘，結果將會是下溢：</p><pre><code>&gt;&gt;&gt; tiny = np.finfo(float).tiny&gt;&gt;&gt; # if we multiply numbers that are too small, we lose all precision&gt;&gt;&gt; tiny * tiny0.0</code></pre><p>但是，對概率取對數會緩和這個問題，因為我們在相同的存儲空間內能表達的數字範圍相比不取對數大了很多。對數在概率裡的取值範圍是從負無窮到0。在實際情況中，對數取值範圍從系統最小的負數（對應finfo返回min值）到0。這個min值比tiny的對數小得多（假如我們在對數空間進行操作的話，tiny就是下限）。</p><pre><code>&gt;&gt;&gt; # this is our lower bound normally&gt;&gt;&gt; np.log(tiny)-708.39641853226408&gt;&gt;&gt; # this is our lower bound when using logs&gt;&gt;&gt; np.finfo(float).min-1.7976931348623157e+308</code></pre><p>因此，通過在對數空間工作，我們極大的擴大了可表示的數值範圍。而且在對數空間裡，正常空間的乘法變成了加法，比如log(x.y) = log(x) + log(y)。所以之前因為概率相乘損失精度的問題也不會像以前一樣困擾我們：</p><pre><code>&gt;&gt;&gt; # the result of multiplying small probabilities&gt;&gt;&gt; np.log(tiny * tiny)-inf&gt;&gt;&gt; # the result of adding small log probabilities&gt;&gt;&gt; np.log(tiny) + np.log(tiny)-1416.7928370645282</code></pre><p>但這並不是一個一勞永逸的辦法。假如我們需要將對數的概率變換回正常的概率，還是會有數據下溢的問題：</p><pre><code>&gt;&gt;&gt; tiny*tiny0.0&gt;&gt;&gt; np.exp(np.log(tiny) + np.log(tiny))0.0</code></pre><p>儘管如此，在對數空間進行計算省了很多麻煩。雖然轉換回正常的概率還是會損失精度，但起碼關於概率的一些額外信息得到了保存（比如兩個小概率比較大小的問題）。</p><h3 class=pgc-h-arrow-right>實現PMF的代碼</h3><p>既然我們已經看到了在對數空間工作的重要性，我們首先實現計算log-PMF的程序：</p><pre><code>def log_pmf(self, x):    &#34;&#34;&#34;Evaluates the log-probability mass function (log-PMF) of a    multinomial with outcome probabilities `self.p` for a draw `x`.    Parameters    ----------    x: numpy array of length `k`        The number of occurrences of each outcome    Returns    -------    The evaluated log-PMF for draw `x`    &#34;&#34;&#34;    # Get the total number of events    n = np.sum(x)    # equivalent to log(n!)    log_n_factorial = gammaln(n + 1)    # equivalent to log(x1! * ... * xk!)    sum_log_xi_factorial = np.sum(gammaln(x + 1))    # If one of the values of self.p is 0, then the corresponding    # value of self.logp will be -inf. If the corresponding value    # of x is 0, then multiplying them together will give nan, but    # we want it to just be 0.    log_pi_xi = self.logp * x    log_pi_xi[x == 0] = 0    # equivalent to log(p1^x1 * ... * pk^xk)    sum_log_pi_xi = np.sum(log_pi_xi)    # Put it all together    log_pmf = log_n_factorial - sum_log_xi_factorial + sum_log_pi_xi    return log_pmf</code></pre><p>這個函數是上述計算多項分佈PMF的一個直接實現。其中gammaln函數來自於scipy.special，它計算log-gamma的值。正如上文提到，因為SciPy提供了這麼一個log-gamma函數，所以計算階乘的對數比計算它本身要便捷和高效很多。我們也可以自己計算一個log階乘的值，類似：</p><pre><code>log_n_factorial = np.sum(np.log(np.arange(1, n + 1)))sum_log_xi_factorial = np.sum([np.sum(np.log(np.arange(1, i + 1))) for i in x])</code></pre><p>但是使用SciPy提供的gammaln函數方便也便於理解。</p><p>其中有一個corner case需要我們解決：當某一事件概率為0時，log(pi)=-inf。這本身對程序沒有很大的影響，但是假如這個值乘以0之後就會成為一個問題：</p><pre><code>&gt;&gt;&gt; # it&#39;s fine to multiply infinity by integers...&gt;&gt;&gt; -np.inf * 2.0-inf&gt;&gt;&gt; # ...but things break when we try to multiply by zero&gt;&gt;&gt; -np.inf * 0.0nan</code></pre><p>nan代表“not a number”，它一般會帶來很多頭痛的問題，因為大多數對nan的運算結果是另一個nan。假如我們不處理p_i=0和x_i=0的情況，他們的乘積是一個nan。這個結果與其他的數值相加求和，得到另一個nan，對我們一點用也沒有。所以在程序中，我們檢查是否有x_i=0的情況，如果是認為的把*x_i.log(p_i)*設為0。</p><p>讓我們回到使用對數空間的討論上來。即使我們需要一個正常空間的PMF，通常的做法是先計算log－PMF，再對該數取指數，得到PMF：</p><pre><code>def pmf(self, x):    &#34;&#34;&#34;Evaluates the probability mass function (PMF) of a multinomial    with outcome probabilities `self.p` for a draw `x`.    Parameters    ----------    x: numpy array of length `k`        The number of occurrences of each outcome    Returns    -------    The evaluated PMF for draw `x`    &#34;&#34;&#34;    pmf = np.exp(self.log_pmf(x))    return pmf</code></pre><p>為了強調使用對數的重要性，這裡有一個多項分佈的例子：</p><pre><code>&gt;&gt;&gt; dist = MultinomialDistribution(np.array([0.25, 0.25, 0.25, 0.25]))&gt;&gt;&gt; dist.log_pmf(np.array([1000, 0, 0, 0])-1386.2943611198905&gt;&gt;&gt; dist.log_pmf(np.array([999, 0, 0, 0])-1384.9080667587707</code></pre><p>在這個情況下，我們得到一個極小的概率（比tiny值還小）。這是因為PMF中的分母巨大（1000的階乘因為數據上溢而沒法計算。但是這個階乘的log卻是可以計算的：</p><pre><code>&gt;&gt;&gt; from scipy.special import gamma, gammaln&gt;&gt;&gt; gamma(1000 + 1)inf&gt;&gt;&gt; gammaln(1000 + 1)5912.1281784881639</code></pre><p>如果我們是用gamma來計算PMF，就會出現gamma(1000+1)/gamma(1000+1)的情況。而這個表達式的結果會是nan（而不是1）。但是因為計算在對數空間進行，這對我們來說就不是一個問題！</p><h1 class=pgc-h-arrow-right>回到採樣魔法裝備</h1><p>現在多項分佈的函數已經寫好了，我們現在使用它們來隨機生成魔法裝備。為了這個目標，我們建立了一個叫做MagicItemDistribution的類，位於rpg.py文件裡。</p><pre><code>class MagicItemDistribution(object):    # these are the names (and order) of the stats that all magical    # items will have    stats_names = (&#34;dexterity&#34;, &#34;constitution&#34;, &#34;strength&#34;,                   &#34;intelligence&#34;, &#34;wisdom&#34;, &#34;charisma&#34;)    def __init__(self, bonus_probs, stats_probs, rso=np.random):        &#34;&#34;&#34;Initialize a magic item distribution parameterized by `bonus_probs`        and `stats_probs`.        Parameters        ----------        bonus_probs: numpy array of length m            The probabilities of the overall bonuses. Each index in            the array corresponds to the bonus of that amount (e.g.,            index 0 is +0, index 1 is +1, etc.)        stats_probs: numpy array of length 6            The probabilities of how the overall bonus is distributed            among the different stats. `stats_probs[i]` corresponds to            the probability of giving a bonus point to the ith stat;            i.e., the value at `MagicItemDistribution.stats_names[i]`.        rso: numpy RandomState object (default: np.random)            The random number generator        &#34;&#34;&#34;        # Create the multinomial distributions we&#39;ll be using        self.bonus_dist = MultinomialDistribution(bonus_probs, rso=rso)        self.stats_dist = MultinomialDistribution(stats_probs, rso=rso)</code></pre><p>MagicItemDistribution的構造函數裡需要的參數有：總附加屬性值分佈概率（bonus_probs），各項屬性的分佈概率(stats_probs)，和隨機數生成器。雖然之前我們確定了所需的總附加屬性值分佈，把這個分佈作為一個傳入參數是一個好主意。這樣添加了用該函數對其它分佈進行採樣的可能（例如總附加屬性值會根據玩家的級別變化）。我們把屬性名字作為屬性（stats_names）添加在了類中，其實這個變量也可以作為構造函數的一個參數。</p><p>如上文提到，隨機採樣一個魔法裝備需要兩步：第一步先採樣總附加屬性值，第二步再隨機分配數值到各項屬性中。我們將這兩步分別用不同的函數實現_sample_bonus和_sample_stats：</p><pre><code>def _sample_bonus(self):    &#34;&#34;&#34;Sample a value of the overall bonus.    Returns    -------    integer        The overall bonus    &#34;&#34;&#34;    # The bonus is essentially just a sample from a multinomial    # distribution with n=1; i.e., only one event occurs.    sample = self.bonus_dist.sample(1)    # `sample` is an array of zeros and a single one at the    # location corresponding to the bonus. We want to convert this    # one into the actual value of the bonus.    bonus = np.argmax(sample)    return bonusdef _sample_stats(self):    &#34;&#34;&#34;Sample the overall bonus and how it is distributed across the    different stats.    Returns    -------    numpy array of length 6        The number of bonus points for each stat    &#34;&#34;&#34;    # First we need to sample the overall bonus    bonus = self._sample_bonus()    # Then, we use a different multinomial distribution to sample    # how that bonus is distributed. The bonus corresponds to the    # number of events.    stats = self.stats_dist.sample(bonus)    return stats</code></pre><p>我們可以把這兩個函數合成一步--尤其因為_sample_stats是唯一使用到_sample_bonus的函數。這裡把它們分開來是為了便於理解和便於測試。</p><p>你會注意到這些函數以下劃線開頭，說明它們並不是類的外部接口。我們提供的採樣接口為sample:</p><pre><code>def sample(self):    &#34;&#34;&#34;Sample a random magical item.    Returns    -------    dictionary        The keys are the names of the stats, and the values are        the bonus conferred to the corresponding stat.    &#34;&#34;&#34;    stats = self._sample_stats()    item_stats = dict(zip(self.stats_names, stats))    return item_stats</code></pre><p>sample函數實際上只是調用_sample_stats，另外把隨機採樣的數值和對應屬性名字組成字典輸出。這樣採樣的裝備能有一個清楚易懂的界面（哪項屬性有幾點附加值），但是也保留了多次調用_sample_stats的可能性（如果需要一次得到多個樣本或者追求效率）。</p><p>我們使用同樣的設計來計算得到某一件裝備的概率。同樣，高層的接口方法pmf和log_pmf將接受sample輸出的字典為參數：</p><pre><code>def log_pmf(self, item):    &#34;&#34;&#34;Compute the log probability of the given magical item.    Parameters    ----------    item: dictionary        The keys are the names of the stats, and the values are        the bonuses conferred to the corresponding stat.    Returns    -------    float        The value corresponding to log(p(item))    &#34;&#34;&#34;    # First pull out the bonus points for each stat, in the    # correct order, then pass that to _stats_log_pmf.    stats = np.array([item[stat] for stat in self.stats_names])    log_pmf = self._stats_log_pmf(stats)    return log_pmfdef pmf(self, item):    &#34;&#34;&#34;Compute the probability the given magical item.    Parameters    ----------    item: dictionary        The keys are the names of the stats, and the values are        the bonus conferred to the corresponding stat.    Returns    -------    float        The value corresponding to p(item)    &#34;&#34;&#34;    return np.exp(self.log_pmf(item))</code></pre><p>這些方法調用了一個_stats_log_pmf函數，它計算得到某屬性分佈的概率（接受的參數類型是一個數組）：</p><pre><code>def _stats_log_pmf(self, stats):    &#34;&#34;&#34;Evaluate the log-PMF for the given distribution of bonus points    across the different stats.    Parameters    ----------    stats: numpy array of length 6        The distribution of bonus points across the stats    Returns    -------    float        The value corresponding to log(p(stats))    &#34;&#34;&#34;    # There are never any leftover bonus points, so the sum of the    # stats gives us the total bonus.    total_bonus = np.sum(stats)    # First calculate the probability of the total bonus    logp_bonus = self._bonus_log_pmf(total_bonus)    # Then calculate the probability of the stats    logp_stats = self.stats_dist.log_pmf(stats)    # Then multiply them together (using addition, because we are    # working with logs)    log_pmf = logp_bonus + logp_stats    return log_pmf</code></pre><p>該方法_stats_log_pmf調用_bonus_log_pmf函數,後者計算得到某個總附加屬性值的概率：</p><pre><code>def _bonus_log_pmf(self, bonus):    &#34;&#34;&#34;Evaluate the log-PMF for the given bonus.    Parameters    ----------    bonus: integer        The total bonus.    Returns    -------    float        The value corresponding to log(p(bonus))    &#34;&#34;&#34;    # Make sure the value that is passed in is within the    # appropriate bounds    if bonus &lt; 0 or bonus &gt;= len(self.bonus_dist.p):        return -np.inf    # Convert the scalar bonus value into a vector of event    # occurrences    x = np.zeros(len(self.bonus_dist.p))    x[bonus] = 1    return self.bonus_dist.log_pmf(x)</code></pre><p>我們可以這樣創建自己的分佈：</p><pre><code>&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; from rpg import MagicItemDistribution&gt;&gt;&gt; bonus_probs = np.array([0.0, 0.55, 0.25, 0.12, 0.06, 0.02])&gt;&gt;&gt; stats_probs = np.ones(6) / 6.0&gt;&gt;&gt; rso = np.random.RandomState(234892)&gt;&gt;&gt; item_dist = MagicItemDistribution(bonus_probs, stats_probs, rso=rso)</code></pre><p>分佈一旦建立，我們就可以隨機的產生一些裝備：</p><pre><code>&gt;&gt;&gt; item_dist.sample(){&#39;dexterity&#39;: 0, &#39;strength&#39;: 0, &#39;constitution&#39;: 0,  &#39;intelligence&#39;: 0, &#39;wisdom&#39;: 0, &#39;charisma&#39;: 1}&gt;&gt;&gt; item_dist.sample(){&#39;dexterity&#39;: 0, &#39;strength&#39;: 0, &#39;constitution&#39;: 1,  &#39;intelligence&#39;: 0, &#39;wisdom&#39;: 2, &#39;charisma&#39;: 0}&gt;&gt;&gt; item_dist.sample(){&#39;dexterity&#39;: 1, &#39;strength&#39;: 0, &#39;constitution&#39;: 1,  &#39;intelligence&#39;: 0, &#39;wisdom&#39;: 0, &#39;charisma&#39;: 0}</code></pre><p>我們可以計算得到某一件裝備的概率：</p><pre><code>&gt;&gt;&gt; item = item_dist.sample()&gt;&gt;&gt; item{&#39;dexterity&#39;: 0, &#39;strength&#39;: 0, &#39;constitution&#39;: 0,  &#39;intelligence&#39;: 0, &#39;wisdom&#39;: 2, &#39;charisma&#39;: 0}&gt;&gt;&gt; item_dist.log_pmf(item)-4.9698132995760007&gt;&gt;&gt; item_dist.pmf(item)0.0069444444444444441</code></pre><h1 class=pgc-h-arrow-right>估算攻擊傷害</h1><p>以上已經展示了一個採樣的例子：產生怪物隨機掉落的裝備。之前提到還可以利用採樣計算跟一個分佈整體相關的一些屬性。我們可以用MagicItemDistribution做這件事。例如，我們的RPG遊戲裡攻擊傷害是通過擲一些數目的骰子（D12，12面骰子）來決定的。玩家默認一次擲一個骰子，假如力量屬性加成＋1，就多扔一個骰子。也就是說假如有力量＋2屬性，他們一次可以擲三個骰子。造成的傷害是三個骰子的值之和。</p><p>我們可能會想知道一個玩家在找到某些武器之後能夠造成多少傷害；這能指導我們調整怪物的難度。假設拿到兩件裝備之後，我們希望玩家能在50%的戰鬥中用不多於3次打擊戰勝怪物。那麼怪物的血量應該被設定為多少？</p><p>解答這個問題的一種方式是通過採樣，流程如下：</p><ol start=1><li>隨機生成一個魔法裝備；</li><li>基於裝備的屬性，計算攻擊時需要擲幾個骰子；</li><li>基於骰子的數目，隨機生成3次打擊數造成的傷害總量；</li><li>重複上述過程。最後得到傷害分佈的近似數值解。</li></ol><h2 class=pgc-h-arrow-right>實現傷害分佈</h2><p>DamageDistribution類（也在rpg.py中）展示了該流程的實現：</p><pre><code>class DamageDistribution(object):    def __init__(self, num_items, item_dist,                 num_dice_sides=12, num_hits=1, rso=np.random):        &#34;&#34;&#34;Initialize a distribution over attack damage. This object can        sample possible values for the attack damage dealt over        `num_hits` hits when the player has `num_items` items, and        where attack damage is computed by rolling dice with        `num_dice_sides` sides.        Parameters        ----------        num_items: int            The number of items the player has.        item_dist: MagicItemDistribution object            The distribution over magic items.        num_dice_sides: int (default: 12)            The number of sides on each die.        num_hits: int (default: 1)            The number of hits across which we want to calculate damage.        rso: numpy RandomState object (default: np.random)            The random number generator        &#34;&#34;&#34;        # This is an array of integers corresponding to the sides of a        # single die.        self.dice_sides = np.arange(1, num_dice_sides + 1)        # Create a multinomial distribution corresponding to one of        # these dice.  Each side has equal probabilities.        self.dice_dist = MultinomialDistribution(            np.ones(num_dice_sides) / float(num_dice_sides), rso=rso)        self.num_hits = num_hits        self.num_items = num_items        self.item_dist = item_dist    def sample(self):        &#34;&#34;&#34;Sample the attack damage.        Returns        -------        int            The sampled damage        &#34;&#34;&#34;        # First, we need to randomly generate items (the number of        # which was passed into the constructor).        items = [self.item_dist.sample() for i in xrange(self.num_items)]        # Based on the item stats (in particular, strength), compute        # the number of dice we get to roll.        num_dice = 1 + np.sum([item[&#39;strength&#39;] for item in items])        # Roll the dice and compute the resulting damage.        dice_rolls = self.dice_dist.sample(self.num_hits * num_dice)        damage = np.sum(self.dice_sides * dice_rolls)        return damage</code></pre><p>構造函數接收的參數有：骰子的面數，需要計算的打擊次數，玩家擁有的魔法裝備數目，魔法裝備的分佈（MagicItemDistribution類），一個隨機數產生器。默認的骰子面數num_dice_sides是12。雖然這個量是一個參數，但是它改變的可能較小。類似的，打擊次數的默認數值被設置為1，因為大多數時候我們希望看到打擊一次的傷害分佈。</p><p>接下來實際的採樣邏輯在sample中實現（請注意結構上與MagicItemDistribution類似的地方）。首先，我們生成玩家擁有的一系列魔法裝備。然後我們從裝備上力量屬性的加成計算出需要擲的骰子的個數。最後我們擲骰子（再一次使用我們的多項分佈函數）來計算造成的總傷害。</p><h3 class=pgc-h-arrow-right>計算概率的方法到哪兒去了？</h3><p>你也許注意到在DamageDistribution裡我們並沒有實現類似log_pmf和pmf的方法。這是因為我們不知道實際上的PMF的解析形式！該概率分佈可以用以下的公式表達：</p><p>這個公式給出的解是對於所有可能的m個武器組合，計算出所有可能的傷害概率分佈。用暴力解法是可以照著這個公式求解，但並不漂亮。這是一個完美的案例解釋為什麼我們會用採樣來求出問題的近似解（當得到問題的精確解是不可能的或者很困難的時候）。因此，下一部份我們會介紹如何用採樣來取得一個近似分佈。</p><h2 class=pgc-h-arrow-right>得到近似分佈</h2><p>現在我們有了回答之前問題的工具：假如一個玩家有兩個裝備，我們想讓玩家在50%的戰鬥中能夠用不多於3次的打擊擊敗怪物，那麼怪物的血量應該設置為多少？</p><p>首先，我們創建一個傷害分佈的對象（使用之前創建的item_dist和rso):</p><pre><code>&gt;&gt;&gt; from rpg import DamageDistribution&gt;&gt;&gt; damage_dist = DamageDistribution(2, item_dist, num_hits=3, rso=rso)</code></pre><p>現在進行大量採樣，計算傷害值大於%50的樣本閾值：</p><pre><code>&gt;&gt;&gt; samples = np.array([damage_dist.sample() for i in xrange(100000)])&gt;&gt;&gt; samples.min()3&gt;&gt;&gt; samples.max()154&gt;&gt;&gt; np.percentile(samples, 50)27.0</code></pre><p><br></p><p>可以看到玩家可能輸出的傷害範圍非常的大，而且該分佈有一個長尾：50%樣本里玩家們的傷害是低於27點的。因此如果我們要依據該標準設定怪物的難度，怪物的血量應被設為27點。</p><h1 class=pgc-h-arrow-right>總結</h1><p>在本章節裡，我們看到了如何從非標準的概率分佈裡進行採樣，也看到了如何計算樣本在分佈裡對應概率。在這個過程中，我們也設計了一些一般情況下適用的設計決定：</p><ol start=1><li>用一個類來代表一個概率分佈，在裡邊包括從這個分佈採樣和計算PMF／PDF的函數；</li><li>用對數計算PMF／PDF;</li><li>從同一個隨機數產生器對象生成樣本以保證可重複性；</li><li>實現的外部接口函數做到輸入和輸出清晰易懂（比如用字典作為MagicItemDistribution.sample的輸出）。對於不那麼清晰但更高效的函數（比如MagicItemDistribution._sample_stats），保留從外部訪問這些函數的可能。</li></ol><p>另外，我們看到了採樣在生成單個隨機數值（比如生成怪物隨機掉落裝備）和在計算與一個分佈相關的某些信息（比如計算玩家擁有兩樣裝備之後的傷害分佈）是很有用的。幾乎所有的採樣都會落入這兩種用法之中；唯一的區別在於具體的分佈類型。整體的代碼結構--獨立於分佈的部分--保持不變。</p><p>1 閱讀這篇文章需要一些統計學和概率論的基礎知識。</p><p>2 NumPy包涵了多個從不同類型分佈裡採樣函數。如果需要完整的列表，可以查詢隨機採樣的模塊np.random。</p><p>3 np.random裡這個函數其實依賴於一個我們可以控制的隨機數生成器：NumPy的全局隨機數生成器。全局的隨機數種可以通過np.seed來改變。使用全局生成器和局部RandomState對象是有取捨的。如果使用全局生成器，那麼就不需要傳遞RandomState對象。但是有可能有你不知道的第三方代碼也在使用全局生成器。如果使用一個局部的對象，通常更容易發現結果的隨機性是來自於自己的代碼還是別處。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>一個</a></li><li><a>決策</a></li><li><a>採樣器</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dac697.html alt=用決策樹搭建一個簡單的負荷預測模型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/1540368983536296664970b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dac697.html title=用決策樹搭建一個簡單的負荷預測模型>用決策樹搭建一個簡單的負荷預測模型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html alt=30分鐘教你搭建一個網站（一）：購買和配置服務器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5f26f1582a564e93bde33a7dd9448c3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html title=30分鐘教你搭建一個網站（一）：購買和配置服務器>30分鐘教你搭建一個網站（一）：購買和配置服務器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html alt=不會買服務器？一個辦法讓你輕鬆搭網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84d9c54578de46058796824f1bcb6a9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html title=不會買服務器？一個辦法讓你輕鬆搭網站>不會買服務器？一個辦法讓你輕鬆搭網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html alt=使用服務器搭建一個網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/63a6cc0eb4d146e0890515500c0040ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html title=使用服務器搭建一個網站>使用服務器搭建一個網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html alt=做一個小型網站，服務器需要什麼配置的呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html title=做一個小型網站，服務器需要什麼配置的呢？>做一個小型網站，服務器需要什麼配置的呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html alt=搭建一個網站，租服務器大概多少錢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html title=搭建一個網站，租服務器大概多少錢？>搭建一個網站，租服務器大概多少錢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html alt=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e7b0005767168b2b87d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html title=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！>素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html alt=一個男人每天24小時跟妻子在一起，久而久之會怎樣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8359cc22f03e478a8cdb889dcfea3f99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html title=一個男人每天24小時跟妻子在一起，久而久之會怎樣>一個男人每天24小時跟妻子在一起，久而久之會怎樣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html alt=每天一個好習慣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RKdGgquJFM6gnc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html title=每天一個好習慣>每天一個好習慣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html alt=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/3fd8ec4e-64c1-446a-adfa-38088fb06c01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html title=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點>奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html alt=又一個走上不歸路的搬磚人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf471da0a06441f88bce49b959234257 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html title=又一個走上不歸路的搬磚人>又一個走上不歸路的搬磚人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html alt=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/833949926ebf49b89c5fb4075a9cffdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html title=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏>多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/917424fc.html alt=一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5b430002414bdad7cc1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/917424fc.html title=一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位>一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25157041.html alt=聖胡安（波多黎各）：一個很不美國的美國城市 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d049f3231cda4890ae11c23b2c8f8f70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25157041.html title=聖胡安（波多黎各）：一個很不美國的美國城市>聖胡安（波多黎各）：一個很不美國的美國城市</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2ca7396.html alt=人工智能的下一個春天：情緒和情感計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ReV1j945oIOAmo style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2ca7396.html title=人工智能的下一個春天：情緒和情感計算>人工智能的下一個春天：情緒和情感計算</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>