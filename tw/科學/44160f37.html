<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>老生常談的內存問題你還是再來看看吧 | 极客快訊</title><meta property="og:title" content="老生常談的內存問題你還是再來看看吧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/95b6a9a43785468fb3b24d2617951bf7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/44160f37.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/44160f37.html><meta property="article:published_time" content="2020-11-14T20:53:57+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:57+08:00"><meta name=Keywords content><meta name=description content="老生常談的內存問題你還是再來看看吧"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/44160f37.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>老生常談的內存問題你還是再來看看吧</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div><blockquote><p><strong>私信我或關注微信號：獅範兒，回覆：學習，獲取免費學習資源包。</strong></p></blockquote><p><em>1</em></p><p>我們為什麼要優化內存</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/95b6a9a43785468fb3b24d2617951bf7><p class=pgc-img-caption></p></div><p>在 Android 中我們寫的 .java 文件，最終會編譯成 .class 文件, class 又由類裝載器加載後，在 JVM 中會形成一份描述 class 結構的元信息對象，通過該元信息對象可以知道 class 的結構信息 (構造函數、屬性、方法)等。</p><p>JVM 會把描述類的數據從 class 文件加載到內存，Java 有一個很好的管理內存的機制，垃圾回收機制 GC 。</p><p>為什麼 Java 都給我們提供了垃圾回收機制，程序有時還會導致內存洩漏，內存溢出 OOM，甚至導致程序 Crash 。接下來我們就對實際開發中出現的這些內存問題，來進行優化。</p><p><em>2</em></p><p>Java 虛擬機</p><p class=ql-align-justify><br></p><p>我們先來大概瞭解一下 Java 虛擬機裡面運行時的數據區域有哪些。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/921a50916b5647ddbc213d6c8b54a64b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>線程獨佔區</strong></p><p><strong>程序計數器</strong></p><ul><li class=ql-align-justify>相當於一個執行代碼的指示器，用來確認下一行執行的地址</li><li class=ql-align-justify>每個線程都有一個</li><li class=ql-align-justify>沒有 OOM 的區</li></ul><p><strong>虛擬機棧</strong></p><ul><li class=ql-align-justify>我們平時說的棧就是這塊區域</li><li class=ql-align-justify>java 虛擬機規範中定義了 OutOfMemeory , stackoverflow 異常</li></ul><p><strong>本地方法棧</strong></p><ul><li class=ql-align-justify>java 虛擬機規範中定義了 OutOfMemory ，stackoverflow 異常</li></ul><p><strong>注意</strong></p><ul><li class=ql-align-justify>在 hotspotVM 中把虛擬機棧和本地方法棧合為了一個棧區</li></ul><p><strong>線程共享區</strong></p><p><strong>方法區</strong></p><ul><li class=ql-align-justify>ClassLoader 加載類信息</li><li class=ql-align-justify>常量、靜態變量</li><li class=ql-align-justify>編譯後的代碼</li><li class=ql-align-justify>會出現 OOM</li><li class=ql-align-justify>運行時常量池</li><li class="ql-align-justify ql-indent-1">public static final</li><li class="ql-align-justify ql-indent-1">符號引用類、接口全名、方法名</li></ul><p><strong>java 堆 (本次需要優化的地方)</strong></p><ul><li class=ql-align-justify>虛擬機能管理的最大的一塊內存 GC 主戰場</li><li class=ql-align-justify>會出現 OOM</li><li class=ql-align-justify>對象實例</li><li class=ql-align-justify>數據的內容</li></ul><p><em>3</em></p><p>JAVA GC 如何確定內存回收</p><p class=ql-align-justify><br></p><p>隨著程序的運行，內存中的實例對象、變量等佔據的內存越來越多，如果不及時進行回收，會降低程序運行效率，甚至引發系統異常。</p><p>目前虛擬機基本都是採用可達性分析算法，為什麼不採用引用計數算法呢？下面就說說引用計數法是如果統計所有對象的引用計數的，再對比可達性分析算法是如何解決引用計數算法的不足。下面就來看下這 2 個算法：</p><p><strong>引用計數算法</strong></p><p>每個對象有一個引用計數器，當對象被引用一次則計數器加一，當對象引用一次失效一次則計數器減一，對於計數器為 0 的時候就意味著是垃圾了，可以被 GC 回收。</p><p>下面通過一段代碼來實際看下</p><pre>public class GCTest { private Object instace = null; public static void onGCtest() { //step 1 GCTest gcTest1 = new GCTest(); //step 2 GCTest gcTest2 = new GCTest(); //step 3 gcTest1.instace = gcTest2; //step 4 gcTest2.instace = gcTest1; //step 5 gcTest1 = null; //step 6 gcTest2 = null; } public static void main(String[] arg) { onGCtest(); }}</pre><p>分析代碼</p><pre>//step 1 gcTest1 引用 + 1 = 1//step 2 gcTest2 引用 + 1 = 1//step 3 gcTest1 引用 + 1 = 2//step 4 gcTest2 引用 + 1 = 2//step 5 gcTest1 引用 - 1 = 1//step 6 gcTest2 引用 - 1 = 1</pre><p>很明顯現在 2 個對象都不能用了都為 null 了，但是 GC 確不能回收它們，因為它們本身的引用計數不為 0 。不能滿足被回收的條件，儘管調用 System.gc() 也還是不能得到回收, 這就造成了 內存洩漏 。當然，現在虛擬機基本上都不採用此方式。</p><p><strong>可達性分析算法</strong></p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/49cff1bab43b4b029723f9d52d1f4b6b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>從 GC Roots 作為起點開始搜索，那麼整個連通圖中額對象邊都是活對象，對於 GC Roots 無法到達的對象便成了垃圾回收的對象，隨時可能被 GC 回收。</p><p><strong>可以作為 GC Roots 的對象</strong></p><ul><li class=ql-align-justify>虛擬機棧正在運行使用的引用</li><li class=ql-align-justify>靜態屬性 常量</li><li class=ql-align-justify>JNI 引用的對象</li></ul><p>GC 是需要 2 次掃描才回收對象，所以我們可以使用 finalize 去救活丟失的引用</p><p>@Override</p><p>protected void finalize() throws Throwable {</p><p>super.finalize();</p><p>instace = this;</p><p>}</p><p><strong>到了這裡，相信大家已經能夠弄明白這 2 個算法的區別了吧？反正對於對象之間循環引用的情況，引用計數算法無法回收這 2 個對象，而可達性是從 GC Roots 開始搜索，所以能夠正確的回收。</strong></p><p><strong>不同引用類型的回收狀態</strong></p><p><strong>強引用</strong></p><pre>Object strongReference = new Object()</pre><p>如果一個對象具有強引用，那垃圾回收器絕不會回收它，當內存空間不足， Java 虛擬機寧願拋出 OOM 錯誤，使程序異常 Crash ,也不會靠隨意回收具有強引用的對象來解決內存不足的問題.如果強引用對象不再使用時，需要弱化從而使 GC 能夠回收，需要：</p><pre>strongReference = null; //等 GC 來回收</pre><p>還有一種情況，如果：</p><p>public void onStrongReference(){</p><p>Object strongReference = new Object()</p><p>}</p><p>在 onStrongReference() 內部有一個強引用，這個引用保存在 java 棧 中，而真正的引用內容 （Object）保存在 java 堆中。當這個方法運行完成後，就會退出方法棧，則引用對象的引用數為 0 ，這個對象會被回收。</p><p>但是如果 mStrongReference 引用是全局時，就需要在不用這個對象時賦值為 null ,因為 強引用 不會被 GC 回收。</p><p><strong>軟引用 (SoftReference)</strong></p><p>如果一個對象只具有軟引用，則內存空間足夠，垃圾回收器就不會回收它；如果內存空間不足了，就會回收這些對象的內存，只要垃圾回收器沒有回收它，該對象就可以被程序使用。軟引用可用來實現內存敏感的高速緩存。</p><p>軟引用可以和一個引用隊列（ReferenceQueue）聯合使用，如果軟引用所引用的對象被垃圾回收器回收， java 虛擬機就會把這個軟引用加入到與之關聯的引用隊列中。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/988e68428d6a46db9ec92ebd4dfec843><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>注意: 軟引用對象是在 jvm 內存不夠的時候才會被回收，我們調用 System.gc() 方法只是起通知作用， JVM 什麼時候掃描回收對象是 JVM 自己的狀態決定的。就算掃描到了 str 這個對象也不會回收，只有內存不足才會回收。</p><p><strong>弱引用 (WeakReference)</strong></p><p>弱引用與軟引用的區別在於: 只具有弱引用的對象擁有更短暫的生命週期。在垃圾回收器線程掃描它所管轄的內存區域的過程中，一旦發現了只具有弱引用的對象，不管當前內存空間足夠與否，都會回收它的內存。不過由於垃圾回收器是一個優先級很低的線程，因此不一定會很快發現那些只具有弱引用的對象。</p><p>弱引用可以和一個引用隊列聯合使用，如果弱引用所引用的對象被垃圾回收，Java 虛擬機就會把這個弱引用加入到與之關聯的引用隊列中。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e84492935954e3981607752273b090e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>可見 weakReference 對象的生命週期基本由 GC 決定，一旦 GC 線程發現了弱引用就標記下來，第二次掃描到就直接回收了。</p><p>注意這裡的 referenceQueuee 是裝的被回收的對象。</p><p><strong>虛引用 (PhantomReference)</strong></p><pre> @Test public void onPhantomReference()throws InterruptedException{ String str = new String("123456"); ReferenceQueue queue = new ReferenceQueue(); // 創建虛引用，要求必須與一個引用隊列關聯 PhantomReference pr = new PhantomReference(str, queue); System.out.println("PhantomReference:" + pr.get()); System.out.printf("ReferenceQueue:" + queue.poll()); }</pre><p>虛引用顧名思義，就是形同虛設，與其他幾種引用都不同，虛引用並不會決定對象的生命週期。如果一個對象僅持有虛引用，那麼它就和沒有任何引用一樣，在任何時候都可能被垃圾回收器回收。</p><p>虛引用主要用來跟蹤對象被垃圾回收器回收的活動。虛引用與軟引用和弱引用的一個區別在於: 虛引用必須和引用隊列 (ReferenceQueue) 聯合使用。當垃圾回收器準備回收一個對象時，如果發現它還有虛引用，就會在回收對象的內存之前，把這個虛引用加入到與之關聯的引用隊列中。</p><p><strong>總結</strong></p><p>引用類型調用方式GC是否內存洩漏強引用直接調用不回收是軟引用.get()視內存情況回收否弱引用.get()回收不可能虛引用null任何時候都可能被回收，相當於沒有引用一樣否</p><p><em>4</em></p><p>分析內存常用工具</p><p>工具很多，掌握原理方法，工具隨意挑選使用。</p><ul><li class=ql-align-justify>top/procrank</li><li class=ql-align-justify>meinfo</li><li class=ql-align-justify>Procstats</li><li class=ql-align-justify>DDMS</li><li class=ql-align-justify>MAT</li><li class=ql-align-justify>Finder - Activity</li><li class=ql-align-justify>LeakCanary</li><li class=ql-align-justify>LeakInspector</li></ul><p><em>5</em></p><p>內存洩露</p><p class=ql-align-justify><br></p><p>產生的原因: 一個長生命週期的對象持有一個短生命週期對象的引用，通俗點講就是該回收的對象，因為引用問題沒有被回收，最終會產生 OOM。</p><p><strong>下面我們來利用 Profile 來檢查項目是否有內存洩漏</strong></p><p>怎麼利用 profile 來查看項目中是否有內存洩漏</p><p>1. 在 AS 中項目以 profile 運行</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a926242dca6e4c0cab955ece7eeb6de0><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>2.在 MEMORY 界面中選擇要分析的一段內存，右鍵 export</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f15ed99d32374774baad73b684563959><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>Allocations: 動態分配對象個數</p><p>Deallocation: 解除分配的對象個數</p><p>Total count: 對象的總數</p><p>Shalow Size: 對象本身佔用的內存大小</p><p>Retained Size: GC 回收能收走的內存大小</p><p>3. 轉換 profile 文件格式</p><p>將 export 導出的 dprof 文件轉換為 Mat 的 dprof 文件</p><p>cd /d 進入到 Android sdk/platform-tools/hprof-conv.exe</p><pre>//轉換命令 hprof-conv -z src desD:\Android\AndroidDeveloper-sdk\android-sdk-windows\platform-tools&gt;hprof-conv -z D:\temp_\temp_6.hprof D:\temp_\memory6.hprod</pre><p>4. 下載 Mat 工具</p><p><em>https://www.eclipse.org/mat/downloads.php</em></p><p>5. 打開 MemoryAnalyzer.exe 點擊左上角 File 菜單中的 Open Heap Dump</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eb9faeb0af954249b71c7b8e17227692><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>6. 查看內存洩漏中的 GC Roots 強引用</p><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/28b5ea127fc946e892ea3028eb476c79><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p>這裡我們得知是一個 ilsLoginListener 引用了 LoginView,我們來看下代碼最後怎麼解決的。</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45ec2cd1606f42dca02a6b93ac79a2dc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>代碼中我們找到了 LoginView 這個類，發現是一個單例中的回調引起的內存洩漏，下面怎麼解決勒，請看第七小點。</p><p><strong>2種解決單例中的內存洩漏</strong></p><p>a. 將引用置為 null</p><pre>/** * 銷燬監聽 */public void unRemoveRegisterListener(){ mMessageController.unBindListener();}public void unBindListener(){ if (listener != null){ listener = null; }}</pre><p>b. 使用弱引用</p><pre>//將監聽器放入弱引用中WeakReference&lt;IBinderServiceListener&gt; listenerWeakReference = new WeakReference&lt;&gt;(listener);//從弱引用中取出回調listenerWeakReference.get()；</pre><p>通過第七小點就能完美的解決單例中回調引起的內存洩漏。</p><p><strong>Android 中常見的內存洩漏經典案例及解決方法</strong></p><p><strong>單例</strong></p><p>示例 :</p><pre>public class AppManager { private static AppManager sInstance; private CallBack mCallBack; private Context mContext; private AppManager(Context context) { this.mContext = context; } public static AppManager getInstance(Context context) { if (sInstance == null) { sInstance = new AppManager(context); } return sInstance; } public void addCallBack(CallBack call){ mCallBack = call； }}</pre><p class=ql-align-justify>1. 通過上面的單列，如果 context 傳入的是 Activity , Service 的 this，那麼就會導致內存洩漏。</p><p class=ql-align-justify>以 Activity 為例，當 Activity 調用 getInstance 傳入 this ，那麼 sInstance 就會持有 Activity 的引用，當 Activity 需要關閉的時候需要 回收的時候，發現 sInstance 還持有 沒有用的 Activity 引用，導致 Activity 無法被 GC 回收，就會造成內存洩漏</p><p class=ql-align-justify>2. addCallBack(CallBack call) 這樣寫看起來是沒有毛病的。但是當這樣調用在看一下勒。</p><pre>//在 Activity 中實現單例的回調AppManager.getInstance(getAppcationContext()).addCallBack(new CallBack(){ @Override public void onStart(){ }})；</pre><p class=ql-align-justify>這裡的 new CallBack() 匿名內部類 默認持有外部的引用，造成 CallBack 釋放不了，那麼怎麼解決了，請看下面解決方法。</p><p class=ql-align-justify><strong>解決方法:</strong></p><p class=ql-align-justify>1. getInstance(Context context) context 都傳入 Appcation 級別的 Context,或者實在是需要傳入 Activity 的引用就用 WeakReference 這種形式。</p><p class=ql-align-justify>2. 匿名內部類建議大家單獨寫一個文件或者</p><pre>public void addCallBack(CallBack call){ WeakReference&lt;CallBack&gt; mCallBack= new WeakReference&lt;CallBack&gt;(call)； }</pre><p><strong>Handler</strong></p><p>示例:</p><p>//在 Activity 中實現 Handler</p><p>class MyHandler extends Handler{</p><p>private Activity m;</p><p>public MyHandler(Activity activity){</p><p>m=activity;</p><p>}</p><p>// class.....</p><p>}</p><p>這裡的 MyHandler 持有 activity 的引用，當 Activity 銷燬的時候，導致 GC 不會回收造成 內存洩漏。</p><p>解決方法:</p><p>1.使用靜態內部類 + 弱引用</p><p>2.在 Activity onDestoty() 中處理 removeCallbacksAndMessages()</p><p>@Override</p><p>protected void onDestroy() {</p><p>super.onDestroy();</p><p>if(null != handler){</p><p>handler.removeCallbacksAndMessages(null);</p><p>handler = null;</p><p>}</p><p>}</p><p><strong>靜態變量</strong></p><p>示例:</p><pre>public class MainActivity extends AppCompatActivity { private static Police sPolice; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (sPolice != null) { sPolice = new Police(this); } }}class Police { public Police(Activity activity) { }}</pre><p>這裡 Police 持有 activity 的引用，會造成 activity 得不到釋放，導致內存洩漏。</p><p>解決方法:</p><pre>//1. sPolice 在 onDestory（）中 sPolice = null;//2. 在 Police 構造函數中 將強引用 to 弱引用；</pre><p><strong>非靜態內部類</strong></p><p>參考 第二點 Handler 的處理方式</p><p><strong>匿名內部類</strong></p><p>示例:</p><p>public class MainActivity extends AppCompatActivity {</p><p>@Override</p><p>protected void onCreate(Bundle savedInstanceState) {</p><p>super.onCreate(savedInstanceState);</p><p>setContentView(R.layout.activity_main);</p><p>new Thread(){</p><p>@Override</p><p>public void run() {</p><p>super.run();</p><p>}</p><p>};</p><p>}</p><p>}</p><p>很多初學者都會像上面這樣新建線程和異步任務，殊不知這樣的寫法非常地不友好，這種方式新建的子線程Thread和AsyncTask都是匿名內部類對象，默認就隱式的持有外部Activity的引用，導致Activity內存洩露。</p><p>解決方法:</p><pre>//靜態內部類 + 弱引用//單獨寫一個文件 + onDestory = null;</pre><p><strong>未取消註冊或回調</strong></p><p>示例:</p><pre>public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); registerReceiver(mReceiver, new IntentFilter()); } private BroadcastReceiver mReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { // TODO ------ } };}</pre><p>在註冊觀察則模式的時候，如果不及時取消也會造成內存洩露。比如使用Retrofit + RxJava註冊網絡請求的觀察者回調，同樣作為匿名內部類持有外部引用，所以需要記得在不用或者銷燬的時候取消註冊。</p><p>解決方法:</p><pre>//Activity 中實現 onDestory（）反註冊廣播得到釋放 @Override protected void onDestroy() { super.onDestroy(); this.unregisterReceiver(mReceiver); }</pre><p><strong>定時任務</strong></p><p>示例:</p><pre>public class MainActivity extends AppCompatActivity { /**模擬計數*/ private int mCount = 1; private Timer mTimer; private TimerTask mTimerTask; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); init(); mTimer.schedule(mTimerTask, 1000, 1000); } private void init() { mTimer = new Timer(); mTimerTask = new TimerTask() { @Override public void run() { MainActivity.this.runOnUiThread(new Runnable() { @Override public void run() { addCount(); } }); } }; } private void addCount() { mCount += 1; }}</pre><p>當我們Activity銷燬的時，有可能Timer還在繼續等待執行TimerTask，它持有Activity 的引用不能被 GC 回收，因此當我們 Activity 銷燬的時候要立即cancel掉Timer和TimerTask，以避免發生內存洩漏。</p><p>解決方法:</p><pre>//當 Activity 關閉的時候，停止一切正在進行中的定時任務，避免造成內存洩漏。 private void stopTimer() { if (mTimer != null) { mTimer.cancel(); mTimer = null; } if (mTimerTask != null) { mTimerTask.cancel(); mTimerTask = null; } } @Override protected void onDestroy() { super.onDestroy(); stopTimer(); }</pre><p><strong>資源未關閉</strong></p><p>示例:</p><p>ArrayList,HashMap,IO,File,SqLite,Cursor 等資源用完一定要記得 clear remove 等關閉一系列對資源的操作。</p><p>解決方法:</p><p>用完即刻銷燬</p><p><strong>屬性動畫</strong></p><p>示例:</p><pre>動畫同樣是一個耗時任務，比如在 Activity 中啟動了屬性動畫 (ObjectAnimator) ，但是在銷燬的時候，沒有調用 cancle 方法，雖然我們看不到動畫了，但是這個動畫依然會不斷地播放下去，動畫引用所在的控件，所在的控件引用 Activity ，這就造成 Activity 無法正常釋放。因此同樣要在Activity 銷燬的時候 cancel 掉屬性動畫，避免發生內存洩漏。</pre><p>解決方法:</p><pre>@Overrideprotected void onDestroy() { super.onDestroy(); //當關閉 Activity 的時候記得關閉動畫的操作 mAnimator.cancel();}</pre><p><em>6</em></p><p>內存抖動</p><p class=ql-align-justify><br></p><p><strong>什麼是內存抖動</strong></p><p>內存頻繁的分配與回收,(分配速度大於回收速度時) 最終產生 OOM 。</p><p><strong>也許下面的錄屏更能解釋什麼是內存抖動</strong></p><p class=ql-align-justify><br></p><p class=ql-align-center><br></p><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a830a5b3e6d44fa497a09b720cb8e34f><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><br></p><p>可以看出當我點擊了一下 Button 內存就頻繁的創建並回收（注意看垃圾桶）。</p><p><strong>那麼我們找出代碼中具體那一塊出現問題了勒，請看下面一段錄屏</strong></p><pre>mButton.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { imPrettySureSortingIsFree(); } });/** * 排序後打印二維數組，一行行打印 */ public void imPrettySureSortingIsFree() { int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for (int i = 0; i &lt; lotsOfInts.length; i++) { for (int j = 0; j &lt; lotsOfInts[i].length; j++) { lotsOfInts[i][j] = randomGenerator.nextInt(); } } for (int i = 0; i &lt; lotsOfInts.length; i++) { String rowAsStr = ""; //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) { rowAsStr += sorted[j]; if (j &lt; (lotsOfInts[i].length - 1)) { rowAsStr += ", "; } } Log.i("ricky", "Row " + i + ": " + rowAsStr); } }</pre><div class=pgc-img><img alt=老生常談的內存問題你還是再來看看吧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cb6f0fe696e4ffaa387fa97a7a9a24b><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>最後我們之後是 onClick 中的 imPrettySureSortingIsFree() 函數裡面的 rowAsStr += sorted[j]; 字符串拼接造成的 內存抖動 ，因為每次拼接一個 String 都會申請一塊新的堆內存，那麼怎麼解決這個頻繁開闢內存的問題了。</p><p>其實在 Java 中有 2 個更好的 API 對 String 的操作很友好，相信應該有人猜到了吧。沒錯就是將 此處的 String 換成 StringBuffer 或者 StringBuilder，就能很完美的解決字符串拼接造成的內存抖動問題。</p><p>修改後</p><pre>/** * 打印二維數組，一行行打印 */public void imPrettySureSortingIsFree() { int dimension = 300; int[][] lotsOfInts = new int[dimension][dimension]; Random randomGenerator = new Random(); for(int i = 0; i &lt; lotsOfInts.length; i++) { for (int j = 0; j &lt; lotsOfInts[i].length; j++) { lotsOfInts[i][j] = randomGenerator.nextInt(); } } // 使用StringBuilder完成輸出，我們只需要創建一個字符串即可， 不需要浪費過多的內存 StringBuilder sb = new StringBuilder(); String rowAsStr = ""; for(int i = 0; i &lt; lotsOfInts.length; i++) { // 清除上一行 sb.delete(0, rowAsStr.length()); //排序 int[] sorted = getSorted(lotsOfInts[i]); //拼接打印 for (int j = 0; j &lt; lotsOfInts[i].length; j++) { sb.append(sorted[j]); if(j &lt; (lotsOfInts[i].length - 1)){ sb.append(", "); } } rowAsStr = sb.toString(); Log.i("jason", "Row " + i + ": " + rowAsStr); }}</pre><p>注意: 實際開發中如果在 LogCat 中發現有這些 Log 說明也發生了 內存抖動 (Log 中出現 concurrent copying GC freed ....)</p><p><em>7</em></p><p>總結</p><p class=ql-align-justify><br></p><p>只要養成這樣的習慣，至少可以避免 90 % 以上不會造成內存異常</p><p><strong>1. 數據類型: 不要使用比需求更佔用空間的基本數據類型</strong></p><p><strong>2. 循環儘量用 foreach ,少用 iterator, 自動裝箱也儘量少用</strong></p><p><strong>3. 數據結構與算法的解度處理 (數組，鏈表，棧樹，樹，圖)</strong></p><p>數據量千級以內可以使用 Sparse 數組 (Key為整數)，ArrayMap (Key 為對象) 雖然性能不如 HashMap ，但節約內存。</p><p><strong>4. 枚舉優化</strong></p><p class=ql-align-justify>缺點:</p><p class=ql-align-justify>每一個枚舉值都是一個單例對象,在使用它時會增加額外的內存消耗,所以枚舉相比與 Integer 和 String 會佔用更多的內存.</p><p class=ql-align-justify>較多的使用 Enum 會增加 DEX 文件的大小,會造成運行時更多的 IO 開銷,使我們的應用需要更多的空間</p><p class=ql-align-justify>特別是分 Dex 多的大型 APP，枚舉的初始化很容易導致 ANR.</p><p class=ql-align-justify>優化後的代碼:可以直接限定傳入的參數個數:</p><pre>public class SHAPE { public static final int TYPE_0=0; public static final int TYPE_1=1; public static final int TYPE_2=2; public static final int TYPE_3=3; @IntDef(flag=true,value={TYPE_0,TYPE_1,TYPE_2,TYPE_3}) @Target({ElementType.PARAMETER,ElementType.METHOD,ElementType.FIELD}) @Retention(RetentionPolicy.SOURCE) public @interface Model{ } private @Model int value=TYPE_0; public void setShape(@Model int value){ this.value=value; } @Model public int getShape(){ return this.value; }}</pre><p class=ql-align-justify><br></p><p><strong>5. static , static final 的問題</strong></p><p>基本數據類型的成員，可以全寫成 static final</p><p>static 會由編譯器調用 clinit 方法進行初始化</p><p>static final 不需要進行初始化工作，打包在 dex 文件中可以直接調用，並不會在類初始化申請內存</p><p><strong>6. 字符串的拼接儘量少用 +=</strong></p><p><strong>7. 重複申請內存問題</strong></p><p>同一個方法多次調用，如遞歸函數 ，回調函數中 new 對象</p><p>不要在 onMeause() onLayout() ,onDraw() 中去刷新UI（requestLayout）</p><p><strong>8. 避免 GC 回收將來要重新使用的對象 (內存設計模式對象池 + LRU 算法)</strong></p><p><strong>9. Activity 組件洩漏</strong></p><ul><li class=ql-align-justify>如果開啟的線程需要傳入參數，用弱引接收可解決問題</li><li class=ql-align-justify>handler 記得清除 removeCallbacksAndMessages(null)</li><li class=ql-align-justify>非業務需要不要把 activity 的上下文做參數傳遞，可以傳遞 application 的上下文</li><li class=ql-align-justify>非靜態內部類和匿名內部內會持有 activity 引用（靜態內部類 或者 單獨寫文件）</li><li class=ql-align-justify>單例模式中回調持有 activity 引用（弱引用）</li><li class=ql-align-justify>handler.postDelayed() 問題</li></ul><p><strong>10. Service 耗時操作儘量使用 IntentService,而不是 Service</strong></p><p>來源網絡，侵權聯繫刪除</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>常談</a></li><li><a>內存</a></li><li><a>問題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f87337a.html alt=收不到交警便民通知？可能是這裡出了問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdf88511c83f431c9f75609d9e44d585 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f87337a.html title=收不到交警便民通知？可能是這裡出了問題>收不到交警便民通知？可能是這裡出了問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db1a012.html alt=問題408:在變壓器送電前後怎樣檢測差動保護裝置？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e7912ea051664f678d2616da1c042a37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db1a012.html title=問題408:在變壓器送電前後怎樣檢測差動保護裝置？>問題408:在變壓器送電前後怎樣檢測差動保護裝置？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84e317ac.html alt=檢測虛設問題，應當採取強有力的措施加以解決 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/115bad769be144f19346317e77eed4b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84e317ac.html title=檢測虛設問題，應當採取強有力的措施加以解決>檢測虛設問題，應當採取強有力的措施加以解決</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dfdb3278.html alt=南通中海問題多多？！竟遭市住建局通報批評 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZ6gaqQHcJXxWV style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dfdb3278.html title=南通中海問題多多？！竟遭市住建局通報批評>南通中海問題多多？！竟遭市住建局通報批評</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afc3600.html alt="歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe51a7bcc26445fa95824ca74c172f17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afc3600.html title="歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑">歡居改造家 一篇看懂，砌牆需要注意的問題有哪些，再也不怕被坑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97268c50.html alt=蛋糕製作中的十一個常見問題及原因 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/2658ec69-8ea5-490e-a30a-08c8ed990c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97268c50.html title=蛋糕製作中的十一個常見問題及原因>蛋糕製作中的十一個常見問題及原因</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7245dc43.html alt=別說我沒提醒你！螺栓連接有問題，趕緊測一下扭矩！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/35dce4fcbaa64306ab138cc84d150d4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7245dc43.html title=別說我沒提醒你！螺栓連接有問題，趕緊測一下扭矩！>別說我沒提醒你！螺栓連接有問題，趕緊測一下扭矩！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56faa63d.html alt=航空發動機軸承問題解析：慎重選用軸承遊隙和​防止軸承打滑 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fa005c54189c4c61bf01b5c6f8afe285 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56faa63d.html title=航空發動機軸承問題解析：慎重選用軸承遊隙和​防止軸承打滑>航空發動機軸承問題解析：慎重選用軸承遊隙和​防止軸承打滑</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7deecdbb.html alt=定製文件櫃需要注意哪些問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/931a82db62a14175b712856354243b2e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7deecdbb.html title=定製文件櫃需要注意哪些問題>定製文件櫃需要注意哪些問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25ca0d4f.html alt=有些暗傷，破解與和解，從來都不是問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b5e2b6f988c141fdbd859d5f5e943129 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25ca0d4f.html title=有些暗傷，破解與和解，從來都不是問題>有些暗傷，破解與和解，從來都不是問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae35566a.html alt="分析問題 查找差距 添新舉措——九重二小召開疫情後測試質量分析會" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S09WOUFHmuIHOE style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae35566a.html title="分析問題 查找差距 添新舉措——九重二小召開疫情後測試質量分析會">分析問題 查找差距 添新舉措——九重二小召開疫情後測試質量分析會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8902836.html alt="分析問題尋差距 鼓足幹勁再出發" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8902836.html title="分析問題尋差距 鼓足幹勁再出發">分析問題尋差距 鼓足幹勁再出發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8777ea19.html alt=對同一省份不同單位領取基本養老金差距問題的分析與解讀？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f50b917fab194c1280c4057fc27199e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8777ea19.html title=對同一省份不同單位領取基本養老金差距問題的分析與解讀？>對同一省份不同單位領取基本養老金差距問題的分析與解讀？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/541714b0.html alt=墊鼻基底解決臉上的哪些問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8bd84cfa42df4c9c8f16fd7b7b88edd4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/541714b0.html title=墊鼻基底解決臉上的哪些問題？>墊鼻基底解決臉上的哪些問題？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>