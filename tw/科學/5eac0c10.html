<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據庫系統實現-存儲管理(CheckSum&RAID) | 极客快訊</title><meta property="og:title" content="數據庫系統實現-存儲管理(CheckSum&RAID) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/1209de83d5ae4dd89e187e1a2773b35c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/5eac0c10.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/5eac0c10.html><meta property="article:published_time" content="2020-11-14T20:50:52+08:00"><meta property="article:modified_time" content="2020-11-14T20:50:52+08:00"><meta name=Keywords content><meta name=description content="數據庫系統實現-存儲管理(CheckSum&RAID)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/5eac0c10.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據庫系統實現-存儲管理(CheckSum&RAID)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div><p class=ql-align-justify>磁盤並不是萬無一失的，也可能發生故障和損壞。磁盤發生故障是災難性的，存儲介質的損壞如果在沒備份的情況下，基本是100%丟失數據，比rm -rf 還嚴重，那麼磁盤的故障有那麼些?</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1209de83d5ae4dd89e187e1a2773b35c><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><ol><li>間歇性故障</li><li>介質損壞</li><li>寫故障</li><li>磁盤崩潰</li></ol><p class=ql-align-justify>在這些故障的時候有哪些應對策略和辦法?我們這章來來學習一下。</p><p class=ql-align-justify><strong>間歇性故障</strong></p><p class=ql-align-justify>當我們嘗試從磁盤讀一個塊的時候，可能這個塊的內容未正確的發送到磁盤控制器，這就是一次間歇性的故障，控制器會以一種辦法來判斷這個磁盤塊的好壞，如果讀的數據是壞的，控制器會嘗試再次讀取發起請求，直到讀取的數據正確位置，或者發送N次請求，然後再停止。</p><p class=ql-align-justify>同樣，我們嘗試寫入一個扇區，可能寫入的內容不是原本想要寫入的內容，唯一的辦法就是磁盤把寫入的內容讀取出來跟磁盤控制器的內容再比較一下。然而，跟磁盤控制器比較，其實還可以讀取寫入的扇區，並且查看狀態是否為"好"，如果狀態是"壞"那麼就重寫，這個狀態如何產生的呢?這就引出了是checksum概念。</p><p class=ql-align-justify><strong>校驗和(checksum)</strong></p><p class=ql-align-justify>在說checksum之前，我們來玩個小遊戲：</p><p class=ql-align-justify>桌子上擺放了7個黑白棋子，魔術師蒙著眼睛看不見棋子。魔術師徒弟在看完7個棋子之後在右邊添加個棋子，和其他棋子並排，這個時候有8個棋子，魔術師依舊蒙著眼睛。這個時候觀眾可將其中的一個棋子翻轉，或者不翻轉任何一枚。觀眾和徒弟一言不發，魔術師並不知道觀眾是否翻轉棋子。</p><p class=ql-align-justify>現在魔術師摘下眼罩，觀察8枚棋子，然後可以說出是否翻轉了棋子，識破觀眾的行為。那麼魔術師是如何識破的呢?</p><p class=ql-align-justify>校驗和:在磁盤的每個扇區都有幾個附加位，這個被稱為校驗和。在數據讀取的時候，如果校驗和跟數據位不符合，那麼就判斷讀取錯誤。不過校驗和正確，也有可能數據是錯誤的，這個的可能性跟校驗位的長度成負相關。校驗位越長，判斷錯誤的概率越小。</p><p class=ql-align-justify>校驗和是基於扇區內所有位的奇偶性(parity)，如果二進制的集合中有奇數個1，那麼數據位有奇數奇偶性並增加值為1的奇偶位。同理，如果有偶數個1，那麼數據位有偶數奇偶性並且增加值為0的奇數位。</p><p class=ql-align-justify>假如我們用一個字節(8bits)來判斷奇偶,並且檢測出錯誤的可能性為50%，那麼出錯的概率為,1/2^8,如果用4個字節呢,則出錯率為1/2^32。相對於40億次中只有一次錯誤沒被檢測出來。</p><p class=ql-align-justify>一般的在數據庫中用的是CRC或者是FNV算來進行checksum的，在PostgreSQL中用得上 FNV-1a，我們來看看PG是如何實現的。</p><p class=ql-align-justify><strong>PostgreSQL-CheckSum</strong></p><p class=ql-align-justify>Postgres默認是不開啟checksum的，在初始化數據庫的時候可以通過選項-k開啟。</p><pre>-k, --data-checksums use data page checksums </pre><p class=ql-align-justify>使用的算法是FNV-1a，下面的地址是這個算法的詳細介紹:http://www.isthe.com/chongo/tech/comp/fnv/</p><p class=ql-align-justify>核心代碼在:src/include/storage/checksum_impl.h</p><p class=ql-align-justify>函數入口:pg_checksum_block</p><p class=ql-align-justify>官方描述：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/19fd6ad4199b44f6b5eaf571caeaa4f5><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>PG的實現跟官方的實現有區別，官方的實現為：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6011eb69b784487c9d82cd47a3805296><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>而PG在乘之前，先右移了17位，然後再xor。</p><p class=ql-align-justify>計算出來的結果都存儲在頁頭PageHeaderData->pd_checksum</p><p class=ql-align-justify>數據從shared_buffer刷盤以及從disk讀取block都需要計算checksum。如果只是在內存中變更數據頁，是不需要計算checksum的。</p><p class=ql-align-justify>感興趣的可以gdb跟一下看看。</p><p class=ql-align-justify>再回到上面的小遊戲，魔術師只要跟徒弟在之前協定好，有偶數個白或者黑，問題就解決了，這也是一種奇偶校驗的實現。</p><p class=ql-align-justify><strong>介質損壞</strong></p><p class=ql-align-justify>磁盤也是有使用壽命的，當磁盤損壞後，破壞是物理性的，數據是不可能完全的恢復回來。在上面我們介紹瞭如何來高效的檢測介質的故障或讀寫的故障，但是卻沒說明如何解決這個問題。</p><p class=ql-align-justify>在磁盤的扇區損壞的問題上，可以用2塊或者多塊磁盤來存儲數據。例如我們寫入內容X,通常扇區是成對的，我們把寫入X的扇區稱作為(左拷貝)Xl和(右拷貝)Xr。讀函數可以讀取Xl或者Xr，返回一個結果w，那麼w是X的真實的內容。前提是我們通過CheckSum對Xl和Xr扇區的完整性做了排查。(這段內容有點繞口，其實就是寫2份數據到不同的磁盤扇區，然後可以任意從其中一個讀取到你想要的內容)。</p><p class=ql-align-justify>寫的策略也是一樣的，例如寫入Xl，檢查是否返回狀態為"好"，如果不是，就需要不停的寫，到達若干次後，如果任然未成功，則可表示該扇區是壞的，則可以用Xr來替換損壞Xl。相反對Xr跟Xl是一樣的邏輯，重複Xl的動作即可。</p><p class=ql-align-justify>讀策略是交互的，交替的讀取Xl和Xr，預先設定個很大的數字，若嘗試超過這個數據，則可以確定X是無法讀取的。</p><p class=ql-align-justify><strong>RAID</strong></p><p class=ql-align-justify>上面討論的內容其實就是RAID(Redundant Array of Independent Disk,獨立磁盤冗餘陣列)。磁盤崩潰發生率一般由平均失效時間來衡量，假設磁盤平均失效時間為10年，則每年磁盤中的1/10會發生故障，為了避免這種故障，就採用了這種策略，當一個數據盤或者冗餘盤發生崩潰的時候，其他的磁盤可用於恢復故障磁盤，從而使得沒有任何數據會丟失。RAID分了很多等級，我們下面就看看不同等級的計算和使用。</p><p class=ql-align-justify><strong>RAID-1</strong></p><p class=ql-align-justify>RAID-1方案使用2塊磁盤做扇區的拷貝，一個做數據盤，一個做冗餘盤，或者互換。相當於有2份磁盤空間來存儲數據(空間浪費)，任何一份失效，可以使用未損壞的進行修復，除非2塊盤同時失效。</p><p class=ql-align-justify>看個例子：假設每個磁盤的使用壽命為10年，那麼意味著每年的損壞率為10%。如果磁盤被鏡像，發生故障的時候我們可以利用另外一塊好的替換他。所以造成錯誤的至少要2個磁盤的數據都丟失，才能說是數據無法恢復。假設替換的時間為3個小時，這是一天中的1/8，或者是1年的1/2920，那麼10年的故障率為1/29200,2塊磁盤之一平均5年發生一次故障，那麼丟失數據的概率大概為5*29200=14600年。</p><p class=ql-align-justify><strong>RAID-4(奇偶塊)</strong></p><p class=ql-align-justify>RAID是以磁盤塊為奇偶校驗，假設有N塊數據盤，一個冗餘盤，在冗餘盤中，第i塊由所有的數據盤的第i塊奇偶校驗位組成，也就是說，所有第i塊盤的j位，包括數據盤和冗餘盤，他們中間必須有偶數個1，而我們總是選取冗餘盤的位讓條件為真。</p><p class=ql-align-justify>假設我們有4塊盤，3個數據盤，一個冗餘盤。假設一個塊只有一個字節，8位。</p><p class=ql-align-justify>盤1:11110000</p><p class=ql-align-justify>盤2:10101010</p><p class=ql-align-justify>盤3:00111000</p><p class=ql-align-justify>冗餘盤</p><p class=ql-align-justify>盤4:01100010</p><p class=ql-align-justify>在1，2，4，5，7位有兩個1，在3，4有4個1，在6和8有零個1。</p><p class=ql-align-justify>利用冗餘盤的位讓數據盤的奇偶校驗條件為真。</p><p class=ql-align-justify>讀：</p><p class=ql-align-justify>從任意一個數據盤讀取是沒有任何差別。</p><p class=ql-align-justify>寫</p><p class=ql-align-justify>當我們寫一個數據盤的一個新塊，我們不僅僅需要改變那個數據塊，還需要改變冗餘盤的相應的塊，以保持數據盤的奇偶性。一個樸素的辦法是讀取N個數據盤的相應塊，取他們的摸2和，並重寫冗餘盤，那麼這樣就會是N+1次的磁盤I/O。</p><p class=ql-align-justify>還有個更好的辦法，只關注在被寫盤的i塊的老版本和新版本，操作如下：</p><p class=ql-align-justify>1、讀要要被改變的數據盤的舊值</p><p class=ql-align-justify>2、讀冗餘盤的相應塊</p><p class=ql-align-justify>3、寫新數據盤</p><p class=ql-align-justify>4、重新計算並寫冗餘盤的塊</p><p class=ql-align-justify>這樣就只有4次I/O操作</p><p class=ql-align-justify>摸2代數解釋</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1c750a930e444d47ad6ccebe38f70ca1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>假設有如下三個數據盤，第一個塊如下：</p><p class=ql-align-justify>盤1：11110000</p><p class=ql-align-justify>盤2：10101010</p><p class=ql-align-justify>盤3：00111000</p><p class=ql-align-justify>冗餘盤：01100010</p><p class=ql-align-justify>假設盤2的塊由10101010改變為11001100，我們來求盤2上的舊值和新值的摸2和，得到</p><p class=ql-align-justify>01100110，這個結果告訴我們，必須改變冗餘盤的第一塊的位置，2，3，6，7的值。那麼冗餘盤為：0000100，如下：</p><p class=ql-align-justify>盤1：11110000</p><p class=ql-align-justify>盤2：11001100</p><p class=ql-align-justify>盤3：00111000</p><p class=ql-align-justify>冗餘盤：0000100</p><p class=ql-align-justify>這樣每列依舊有偶數個1</p><p class=ql-align-justify>故障恢復</p><p class=ql-align-justify>如果是冗餘盤壞了，直接換一塊新盤，並且重新計算奇偶。如果是數據盤壞了，也是換一個新盤，不起根據其他盤重新計算它的數據。我們來看個例子：</p><p class=ql-align-justify>盤1：11110000</p><p class=ql-align-justify>盤2：????????</p><p class=ql-align-justify>盤3：00111000</p><p class=ql-align-justify>盤4：01100010</p><p class=ql-align-justify>我們取每一列的模2和，可以推導出盤2為：</p><p class=ql-align-justify>盤1:11110000</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>盤2:00111000</p><p class=ql-align-justify>=:11001000</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>01100010</p><p class=ql-align-justify>=10101010</p><p class=ql-align-justify><strong>RAID-5</strong></p><p class=ql-align-justify>在RAID-4的策略中，除非2塊盤同時損壞，否則還是能有效的保護數據。不過有個缺點，就是無論是讀和寫都需要訪問冗餘盤。從上面故障恢復的例子可以發現，恢復數據盤和冗餘盤是一樣的策略，都是取其它盤的模2和。這樣，我們就不必要把一個盤做冗餘盤，而把其他盤作為數據盤，相反，我們可以把每個磁盤作為某寫塊的冗餘盤來處理，這種改進稱為RAID-5。</p><p class=ql-align-justify>假設我們有4塊盤，0-3。第一個盤編號為0，講作為編號為4，8，12等盤的冗餘，因為當被4除時，餘數為0。編號為1的盤將作為編號為1，5，9等塊的冗餘。盤2是2，6，10塊的冗餘，盤3是3，7，11等塊的冗餘。</p><p class=ql-align-justify>如果每個盤讀寫負荷一樣，如果所有的塊有相同的可能性被寫，那麼對於一次寫，每個盤有1/4的機會，並且還有1/3的機會作為那個塊的冗餘盤。這樣，4個盤的每個涉及寫的機會是1/4+3/4*1/3=1/2</p><p class=ql-align-justify><strong>多個盤的崩潰處理(RAID-6)</strong></p><p class=ql-align-justify>前面講的都是一塊盤的崩潰，如果涉及到多個盤的崩潰，還是無法處理的。多個盤的崩潰有一個糾錯碼原理，允許我們處理多個盤的崩潰，前提的我們有足夠多的冗餘盤。這個 策略導致了最高的RAID級別-RAID-6。這個策略是基於海明碼(Hamming code)進行糾錯的。</p><p class=ql-align-justify>我們來看個例子，一個7個磁盤的系統，磁盤編號為1-7，前面4個是數據盤，5-7是冗餘盤。數據盤和冗餘盤組成的一個3*7的矩陣，如下圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/261b5757b9924840a057ed1f4e200bbf><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>如圖，請注意：</p><p class=ql-align-justify>1、除了全0列之外的，三個0和1的所有可能的列都在這個矩陣中</p><p class=ql-align-justify>2、冗餘盤有單個1</p><p class=ql-align-justify>3、數據盤至少各有兩個1</p><p class=ql-align-justify>通過這個矩陣可以知道：</p><p class=ql-align-justify>1、盤5是盤1、2、3相應位的摸2和</p><p class=ql-align-justify>2、盤6是盤1、2、4相應位的模2和</p><p class=ql-align-justify>3、盤7是盤1、3、4相應位的模2和</p><p class=ql-align-justify>通過這個規則，我們就能從兩個同時發生故障的磁盤崩潰中恢復。</p><p class=ql-align-justify>讀</p><p class=ql-align-justify>我們從任何一個數據盤讀取數據，不用理睬冗餘盤</p><p class=ql-align-justify>寫</p><p class=ql-align-justify>寫的話就需要考慮冗餘盤。為了寫某個塊，需要計算新舊塊的摸2和，這些位以模2和的方式加入到滿足條件的所有冗餘盤相應塊中。</p><p class=ql-align-justify>看個例子：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e22896873d314aa0a95e3cca379cd3df><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>我們把第二個盤修改為00001111，新值和舊值的模2和為：10100101，因為盤5和6在盤行1和行2都有1</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0eb7b022cda049bcbe863fa9ac29138d><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>所以我們需要拿他們的第一個塊跟剛才算出來的值10100101執行摸2和，也就是說我們需要對這2個塊的1，3，6，8位置求反。</p><p class=ql-align-justify>盤5：</p><p class=ql-align-justify>10100101</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>01100010</p><p class=ql-align-justify>=</p><p class=ql-align-justify>11000111</p><p class=ql-align-justify>盤6：</p><p class=ql-align-justify>10100101</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>00011011</p><p class=ql-align-justify>=</p><p class=ql-align-justify>10111110</p><p class=ql-align-justify>所以結果如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/43b5fc3340cc431a8ea7dbe2c78b246a><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify><strong>RAID-6故障恢復</strong></p><p class=ql-align-justify>假設故障盤為a和b，我們可以從下面這個矩陣中能夠把a和b的列不同的某個行r找到，假設a是0，而b是1.</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9d0fe86201674036a3a92c259ae164a9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>然後我們通過取來自b之外所有的行r有1的磁盤相應位模2，我們就能計算出b。計算完b，我們必須用所有其他的盤重新計算a。辦法是取該行帶1的那些其他磁盤的位摸2.</p><p class=ql-align-justify>看個例子，如果盤2和盤5在同一時間損壞，如下圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/143540e804664f02934cccd982f821d3><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>我們發現這2個盤在列2不同，盤2是1盤5是0，那麼我們用盤1，4，6來恢復盤2如下圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1f0d9921663c4a92bf9e728fed670a31><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>盤2通過計算得到:</p><p class=ql-align-justify>盤1:11110000</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>盤4:01000001</p><p class=ql-align-justify>=10110001</p><p class=ql-align-justify>Xor</p><p class=ql-align-justify>盤6:10111110</p><p class=ql-align-justify>=00001111</p><p class=ql-align-justify>盤5可以用盤1，2，3來恢復，如下圖：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c039f48afb5f40e48619c2cbba2578ca><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>盤1:11110000</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>盤2:00001111</p><p class=ql-align-justify>=11111111</p><p class=ql-align-justify>xor</p><p class=ql-align-justify>盤3:00111000</p><p class=ql-align-justify>=11000111</p><p class=ql-align-justify>這樣盤2和盤5都恢復了，結果如下：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=數據庫系統實現-存儲管理(CheckSum&RAID) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/093a0ef0e8104353aec1734224b0c7b9><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-justify>關於RAID-6,磁盤的數量可以是任意次方-1，例如2^k-1,k是冗餘盤，剩下的2^k-k-1是數據盤，所有冗餘盤差不多是數據盤的對數增長的，並且都可以構造成矩陣來表示。</p><p class=ql-align-justify>書中只大概介紹了這幾種RAID,不過現在有跟多的RAID,例如：</p><ul><li>RAID-0:Data Stripping</li><li>RAID-1:磁盤鏡像</li><li>RAID-0+1:RAID-0和RAID-1的結合體</li><li>RAID-2:帶海明嗎校驗</li><li>RAID-3:帶奇偶校驗並行傳送</li><li>RAID-4:帶奇偶校驗獨立磁盤結構</li><li>RAID-5:分佈式奇偶校驗</li><li>RAID-6:帶2種分佈式存儲奇偶校驗</li><li>RAID-7:優化的高速傳輸磁盤結構</li><li>RAID-10:高可靠和高效磁盤結構</li><li>RAID-53:高速數據傳輸磁盤結構</li></ul><p class=ql-align-justify>總結：主要是講磁盤的損壞和恢復方面的內容，包括如何檢測損壞和如何恢復，checksum是個很好的檢測手段，而磁盤的冗餘是在存儲介質損壞的時候提供有力的數據保護，並且分析了幾種冗餘策略。下一章我們來看看數據是如何在磁盤組織的，包括定長&變長數據的存儲，Tuple的修改(插入，刪除，跟新)，跨塊的存儲和列存儲相關內容，並且我們用C語言自己來寫個例子程序。（來源 ：RDBMS原理分析）</p><p><strong>天下數據</strong>是國內屈指可數的擁有多處海外自建機房的新型IDC服務商，被業界公認為“中國IDC行業首選品牌”。</p><p><strong>天下數據</strong>與全球近120多個國家頂級機房直接合作，提供包括香港、美國、韓國、日本、臺灣、新加坡、荷蘭、法國、英國、德國、埃及、南非、巴西、印度、越南等國家和地區的服務器、雲服務器的租用服務，需要的請聯繫<strong>天下數據</strong>客服！</p><p class=ql-align-justify>除提供傳統的IDC產品外，<strong>天下數據</strong>的主要職責是為大中型企業提供更精細、安全、滿足個性需求的定製化服務器解決方案，特別是在直銷、金融、視頻、流媒體、遊戲、電子商務、區塊鏈、快消、物聯網、大數據等諸多行業，為廣大客戶解決服務器租用中遇到的各種問題。</p><p class=ql-align-justify><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>庫系統</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e911ae58.html alt=要實現數據自動校對，這幾個Excel小技巧不可錯過。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f1380ab2c662411395ce974b73d251a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e911ae58.html title=要實現數據自動校對，這幾個Excel小技巧不可錯過。>要實現數據自動校對，這幾個Excel小技巧不可錯過。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/532b19c6.html alt=ElasticSearch實現數據模糊搜索 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b52e3ae9ccd44f12afa1f10ac28ea578 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/532b19c6.html title=ElasticSearch實現數據模糊搜索>ElasticSearch實現數據模糊搜索</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/41e067fa.html alt="Canal 如何實現數據庫庫事務的一致性" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c46cdca193864806be3dd7d81af2ccaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/41e067fa.html title="Canal 如何實現數據庫庫事務的一致性">Canal 如何實現數據庫庫事務的一致性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ba15482.html alt=手把手教你實現共享單車數據分析及需求預測 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aaa5f47b7f11406c95fedc934853bb05 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ba15482.html title=手把手教你實現共享單車數據分析及需求預測>手把手教你實現共享單車數據分析及需求預測</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4567de.html alt=如果用文件做數據存儲，如何實現分頁功能呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/1f892324-9a1b-4eaf-804b-1f38728f52ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4567de.html title=如果用文件做數據存儲，如何實現分頁功能呢>如果用文件做數據存儲，如何實現分頁功能呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65b1aa5.html alt=Excel如何實現行列數據互換？其實除了複製粘貼，還能這樣操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e51b3ead3bf44d5f8524845a187f4675 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65b1aa5.html title=Excel如何實現行列數據互換？其實除了複製粘貼，還能這樣操作>Excel如何實現行列數據互換？其實除了複製粘貼，還能這樣操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html alt="廣西鐵路出海大通道 全面實現電氣化運營" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html title="廣西鐵路出海大通道 全面實現電氣化運營">廣西鐵路出海大通道 全面實現電氣化運營</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/862c99dd.html alt=數據告訴你，為什麼要在上升趨勢買入和下降趨勢賣出 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3e507bb24abc482fb28df1121a7ee097 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/862c99dd.html title=數據告訴你，為什麼要在上升趨勢買入和下降趨勢賣出>數據告訴你，為什麼要在上升趨勢買入和下降趨勢賣出</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>