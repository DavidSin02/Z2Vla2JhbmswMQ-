<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>揭祕Sharding-Proxy——面向DBA的數據庫中間層 | 极客快訊</title><meta property="og:title" content="揭祕Sharding-Proxy——面向DBA的數據庫中間層 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/7136f5b7940242549c7df94a76715b2b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/62779af9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/62779af9.html><meta property="article:published_time" content="2020-11-14T20:57:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:57:17+08:00"><meta name=Keywords content><meta name=description content="揭祕Sharding-Proxy——面向DBA的數據庫中間層"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/62779af9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>揭祕Sharding-Proxy——面向DBA的數據庫中間層</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>講師介紹</h1><p><strong>張永倫</strong>：京東金融運維部高級軟件工程師</p><p>曾在傳統行業工作多年，從事基礎軟件開發工作。後投身互聯網，在京東金融開始了爬蟲生涯，感嘆互聯網數據量之大，但心中仍對偏底層的軟件感興趣。今年有幸加入到Sharding-Sphere，能夠做自己感興趣的事情，希望以後多做些工作，提升自己，回報社區。</p><p>大家好，我今天想跟大家分享的是Sharding-Sphere的第二個產品Sharding-Proxy。</p><p>在上個月亮相的Sharding-Sphere 3.0.0.M1中首次發佈了Sharding-Proxy，希望這次分享能夠通過幾個優化實踐，幫助大家管中窺豹，從幾個關鍵細節想象出Sharding-Proxy的全貌。至於更詳細的MySQL協議、IO模型、Netty等議題，以後有機會再和大家專題分享。</p><h1 class=pgc-h-arrow-right>一、Sharding-Proxy簡介</h1><p></p><p><strong>1. Sharding-Proxy概覽</strong></p><p>Sharding-Proxy定位為透明化的數據庫代理端，提供封裝了數據庫二進制協議的服務端版本，用於完成對異構語言的支持。目前先提供MySQL版本，它可以使用任何兼容MySQL協議的訪問客戶端操作數據（如：MySQLCommandClient、MySQLWorkbench等），對DBA更加友好。</p><p>* 對應用程序完全透明，可直接當做MySQL使用；</p><p></p><p>* 適用於任何兼容MySQL協議的客戶端。</p><p></p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7136f5b7940242549c7df94a76715b2b><p class=pgc-img-caption></p></div><p>與其他兩個產品（Sharding-JDBC、Sharding-Sidecar）的對比：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/27a8bf4b79494d15a55660966143a65f><p class=pgc-img-caption></p></div><p>它們既可以獨立使用，也可以相互配合，以不同的架構模型、不同的切入點，實現相同的功能目標。而其核心功能，如數據分片、讀寫分離、柔性事務等，都是同一套實現代碼。</p><p>舉個例子，對於僅使用Java為開發技術棧的場景，Sharding-JDBC對各種Java的ORM框架支持度非常高，開發人員可以非常便利地將數據分片能力引入到現有的系統中，並將其部署至線上環境運行，而DBA就可以通過部署一個Sharding-Proxy實例，對數據進行查詢和管理。</p><p><strong>2. Sharding-Proxy架構</strong></p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ecd62e2833f84a88b767e332586bde63><p class=pgc-img-caption></p></div><p>整個架構可以分為前端、後端和核心組件三部分來看：</p><p>前端（Frontend）負責與客戶端進行網絡通信，採用的是基於NIO的客戶端/服務器框架，在Windows和Mac操作系統下采用NIO模型，Linux系統自動適配為Epoll模型，在通信的過程中完成對MySQL協議的編解碼；</p><p></p><p>核心組件（Core-module）得到解碼的MySQL命令後，開始調用Sharding-Core對SQL進行解析、改寫、路由、歸併等核心功能；</p><p></p><p>後端（Backend）與真實數據庫的交互暫時藉助基於BIO的Hikari連接池。BIO的方式在數據庫集群規模很大，或者一主多從的情況下，性能會有所下降。所以未來我們還會提供NIO的方式連接真實數據庫。</p><p></p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9594883ba41046768e99d11856cc3471><p class=pgc-img-caption></p></div><p>這種方式下Proxy的吞吐量將得到極大提高，能夠有效應對大規模數據庫集群。</p><h1 class=pgc-h-arrow-right>二、Sharding-Proxy功能細節</h1><p><strong>1. PreparedStatement功能實現</strong></p><p>我在Sharding-Sphere的第一個任務就是實現Proxy的PreparedStatement功能。據說這是一個高大上的功能，能夠預編譯SQL提高查詢速度和防止SQL注入攻擊等。一次服務端預編譯，多次查詢，降低SQL編譯開銷，提升了效率，聽起來沒毛病。然而在做完之後卻發現被坑了，SQL執行效率不但沒有提高，甚至用肉眼都能看出來比原始的Statement還要慢。</p><p>先拋開Proxy不說，我們通過wireshark抓包看看運行PreparedStatement時MySQL協議是如何交互的。</p><p>示例代碼如下：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b853cc154a8a4ebfa47e62261319a036><p class=pgc-img-caption></p></div><p>代碼很容易理解，使用PreparedStatement執行兩次查詢操作，每次都把參數user_id設置為10。分析抓到的包，JDBC和MySQL之間的協議消息交互如下：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/31af9f962c154b5a89935c55fef49ee9><p class=pgc-img-caption></p></div><p>JDBC向MySQL進行了兩次查詢（Query），MySQL返回給JDBC兩次結果（Response），第一條消息不是我們期望的PreparedStatement，SELECT裡面也沒有問號，這就說明prepare沒有生效，至少對MySQL服務來說沒有生效。</p><p>對於這個問題，我想大家心裡都有數，是因為JDBC的url沒有設置參數useServerPrepStmts=true，這個參數的作用是讓MySQL服務進行prepare。沒有這個參數就是讓JDBC進行prepare，MySQL完全感知不到，是沒有什麼意義的。接下來我們在url中加上這個參數：</p><p><br></p><p>jdbc:mysql://127.0.0.1:3306/demo_ds?useServerPrepStmts=true</p><p><br></p><p>交互過程變成了這樣：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2e2e250e6dd9478899a557f6a55b92d0><p class=pgc-img-caption></p></div><p>初看這是一個正確的流程，第1條消息是PreparedStatement，SELECT裡也帶問號了，通知MySQL對SQL進行預編譯；第2條消息MySQL告訴JDBC準備成功；第3條消息JDBC把參數設置為10；第4條消息MySQL返回查詢結果。然而到了第5條，JDBC怎麼又發了一遍PreparedStatement？</p><p>預期應該是以後的每條查詢都只是通過ExecuteStatement傳參數的值，這樣才能達到一次預編譯多次運行的效果。</p><p>如果每次都“預編譯”，那就相當於沒有預編譯，而且相對於普通查詢，還多了兩次消息傳遞的開銷：Response（prepareok）和ExecuteStatement（parameter=10）。看來性能的問題就是出在這裡了。</p><p>像這樣使用PreparedStatement還不如不用，一定是哪裡搞錯了，於是我開始閱讀JDBC源代碼，終於發現了另一個需要設置的參數——cachePrepStmts。我們加上這個參數看看會不會發生奇蹟：</p><p><br></p><p>jdbc:mysql://127.0.0.1:3306/demo_ds?useServerPrepStmts=true&cachePrepStmts=true</p><p><br></p><p>果然得到了我們預期的消息流程，而且經過測試，速度也比普通查詢快了：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8cc74ab657464c75986734764a3bd113><p class=pgc-img-caption></p></div><p>從第5條消息開始，每次查詢只傳參數值就可以了，終於達到了一次編譯多次運行的效果，MySQL的效率得到了提高。而且由於ExecuteStatement只傳了參數的值，消息長度上比完整的SQL短了很多，網絡IO的效率也得到了提升。</p><p>原來cachePrepStmts=true這個參數的意思是告訴JDBC緩存需要prepare的SQL，比如“SELECT*FROMt_orderWHEREuser_id=?”，運行過一次後，下次再運行就跳過PreparedStatement，直接用ExecuteStatement設置參數值。</p><p>明白原理後，就知道該怎麼優化Proxy了。Proxy採用的是Hikari數據庫連接池，在初始化的時候為其設置上面的兩個參數：</p><p><br></p><p>config.addDataSourceProperty("useServerPrepStmts","true");</p><p>config.addDataSourceProperty("cachePrepStmts","true");</p><p><br></p><p>這樣就保證了Proxy和MySQL服務之間的性能。那麼Proxy和Client之間的性能如何保證呢？</p><p>Proxy在收到Client的PreparedStatement的時候，並不會把這條消息轉發給MySQL，因為SQL裡的分片鍵是問號，Proxy不知道該路由到哪個真實數據庫。Proxy收到這條消息後只是緩存了SQL，存儲在一個StatementId到SQL的Map裡面，等收到ExecuteStatement的時候才真正請求數據庫。</p><p>這個邏輯在優化前是沒問題的，因為每一次查詢都是一個新的PreparedStatement流程，ExecuteStatement會把參數類型和參數值告訴客戶端。</p><p>加上兩個參數後，消息內容發生了變化，ExecuteStatement在發送第二次的時候，消息體裡只有參數值而沒有參數類型，Proxy不知道類型就不能正確的取出值。所以Proxy需要做的優化就是在PreparedStatement開始的時候緩存參數類型。</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4da8a611f74f497588bfbbda393e45b3><p class=pgc-img-caption></p></div><p>完成以上優化後，Client-Proxy和Proxy-MySQL兩側的消息交互都變成了最後這張圖的流程，從第9步開始高效查詢。</p><p><strong>2. Hikari連接池配置優化</strong></p><p>Proxy在初始化的時候，會為每一個真實數據庫配置一個Hikari連接池。根據分片規則，SQL被路由到某些真實庫，通過Hikari連接得到執行結果，最後Proxy對結果進行歸併返回給客戶端。那麼，數據庫連接池到底該設置多大？對於這個眾說紛紜的話題，今天該有一個定論了。</p><p>你會驚喜的發現，這個問題不是設置“多大”，反而是應該設置“多小”！如果我說執行一個任務，串行比並行更快，是不是有點反直覺？</p><p>即使是單核CPU的計算機也能“同時”支持數百個線程。但我們都應該知道這只不過是操作系統用“時間片”玩的一個小花招。事實上，一個CPU核心同一時刻只能執行一個線程，然後操作系統切換上下文，CPU執行另一個線程，如此往復。</p><p>一個CPU進行計算的基本規律是，順序執行任務A和任務B永遠比通過時間片“同時”執行A和B要快。一旦線程的數量超過了CPU核心的數量，再增加線程數就只會更慢，而不是更快。一個對Oracle的測試驗證了這個觀點。</p><p>參考鏈接：</p><p>http://www.dailymotion.com/video/x2s8uec</p><p>測試者把連接池的大小從2048逐漸降低到96，TPS從16163上升到20702，平響從110ms下降到3ms。</p><p>當然，也不是那麼簡單地讓連接數等於CPU數就行了，還要考慮網絡IO和磁盤IO的影響。當發生IO時，線程被阻塞，此時操作系統可以將那個空閒的CPU核心用於服務其他線程。所以，由於線程總是在I/O上阻塞，我們可以讓線程（連接）數比CPU核心多一些，這樣能夠在同樣的時間內完成更多的工作。到底應該多多少呢？PostgreSQL進行了一個benchmark測試：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a892b3f64a21487b84221d4f321a4290><p class=pgc-img-caption></p></div><p>TPS的增長速度從50個連接的時候開始變慢。根據這個結果，PostgreSQL給出瞭如下公式：</p><p><br></p><p>connections=((core_count*2)+effective_spindle_count)</p><p><br></p><p>連接數=((核心數\*2)+磁盤數)。即使是32核的機器，60多個連接也就夠用了。所以，小夥伴們在配置Proxy數據源的時候，不要動不動就寫上幾百個連接，不僅浪費資源，還會拖慢速度。</p><p><strong>3. 結果歸併優化</strong></p><p>目前Proxy訪問真實數據庫使用的是JDBC，很快Netty+MySQLProtocol異步訪問方式也會上線，兩者會並存，由用戶選擇用哪種方法訪問。</p><p>在Proxy中使用JDBC的ResultSet會對內存造成非常大的壓力。Proxy前端對應m個client，後端又對應n個真實數據庫，後端把數據傳遞給前端client的過程中，數據都需要經過Proxy的內存。如果數據在Proxy內存中呆的時間長了，那麼內存就可能被打滿，造成服務不可用的後果。所以，ResultSet內存效率可以從兩個方向優化，一個是減少數據在Proxy中的停留時間，另一個是限流。</p><p>我們先看看優化前Proxy的內存表現。使用5個客戶端連接Proxy，每個客戶端查詢出15萬條數據。結果如下圖：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e917f724b3a54b5a975f8b4c3f0f143c><p class=pgc-img-caption></p></div><p>可以看到，Proxy的內存在一直增長，即時GC也回收不掉的。這是因為ResultSet會阻塞住next()，直到查詢回來的所有數據都保存到內存中。這是ResultSet默認提取數據的方式，大量佔用內存。</p><p>那麼，有沒有一種方式，讓ResultSet收到一條數據就可以立即消費呢？在Connector/J文檔中有這樣一句話：</p><p><br></p><p>If you are working with ResultSets that have a large number of rows or large values and cannot allocate heap space in your JVM for the memory required , you can tell the driver to stream the results back one row at a time.</p><p>如果你使用ResultSet遇到查詢結果太多，以致堆內存都裝不下的情況，你可以指示驅動使用流式結果集，一次返回一條數據。</p><p><br></p><p>文檔參考鏈接：</p><p>https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-implementation-notes.html</p><p>激活這個功能只需在創建Statement實例的時候設置一個參數：</p><p><br></p><p>stmt.setFetchSize(Integer.MIN_VALUE);</p><p><br></p><p>這樣就完成了。這樣Proxy就可以在查詢指令後立即通過next()消費數據了，數據也可以在下次GC的時候被清理掉。當然，Proxy在對結果做歸併的時候，也需要優化成即時歸併，而不再是把所有數據都取出來再進行歸併，Sharding-Core提供即時歸併的接口，這裡就不詳細介紹了。下面看看優化後的效果，如下圖：</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d35018bed51f45a3800da0eabab48edb><p class=pgc-img-caption></p></div><p>數據在內存中停留時間縮短，每次GC都回收掉了數據，內存效率大幅提升。看到這裡，好像已經大功告成了，然而水還很深，請大家穿上潛水服繼續跟我探索。圖2是在最理想的情況產生的，即Client從Proxy消費數據的速度，大於等於Proxy從MySQL消費數據的速度。</p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/acd882f820e04dd49cd58a126260f205><p class=pgc-img-caption></p></div><p>如果Client由於某種原因消費變慢了，或者乾脆不消費了，會發生什麼呢？通過測試發現，內存使用量直線拉昇，比圖1更強勁，最後將內存耗盡，Proxy被KO。</p><p>下面我們就先搞清楚為什麼會發生這種現象，然後介紹對ResultSet的第2個優化：限流。</p><p>下圖加上了幾個主要的緩存：</p><p>* SO_RCVBUF/SO_SNDBUF是TCP緩存；</p><p></p><p>* ChannelOutboundBuffer是Netty寫緩存。</p><p></p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b552ec67f3c4dd0b96475bf0e0047b2><p class=pgc-img-caption></p></div><p>當Client阻塞的時候，它的SO_RCVBUF會被瞬間打滿，然後通過滑動窗口機制通知Proxy不要再發送數據了，同時Proxy的SO_SNDBUF也會瞬間被Netty打滿。</p><p>Proxy的SO_SNDBUF滿了之後，Netty的ChannelOutboundBuffer就會像一個無底洞一樣，吞掉所有MySQL發來的數據，因為在默認情況下ChannelOutboundBuffer是無界的。</p><p>由於有用戶（Netty）在消費，所以Proxy的SO_RCVBUF一直有空間，導致MySQL會一直髮送數據，而Netty則不停的把數據存到ChannelOutboundBuffer，直到內存耗盡。</p><p>搞清原理之後就知道，我們的目標就是當Client阻塞的時候，Proxy不再接收MySQL的數據。</p><p>Netty通過水位參數WRITE_BUFFER_WATER_MARK來控制寫緩衝區：</p><p>當Buffer大小超過高水位線，我們就控制Netty不讓再往裡面寫，當Buffer大小低於低水位線的時候，才允許寫入；</p><p></p><p>當ChannelOutboundBuffer滿時，Proxy的SO_RCVBUF被打滿，通知MySQL停止發送數據。</p><p></p><p>所以，在這種情況下，Proxy所消耗的內存只是ChannelOutboundBuffer高水位線的大小。</p><p><strong>4. Proxy的兩種模式</strong></p><p>在即將發佈的Sharding-Sphere3.0.0.M2版本中，Proxy會加入兩種代理模式的配置：</p><p>MEMORY_STRICTLY：Proxy會保持一個數據庫中所有被路由到的表的連接，這種方式的好處是利用流式ResultSet來節省內存。</p><p></p><p>CONNECTION_STRICTLY：代理在取出ResultSet中的所有數據後會釋放連接，同時，內存的消耗將會增加。</p><p></p><p>簡單可以理解為，如果你想消耗更小的內存，就用MEMORY_STRICTLY模式；如果你想消耗更少的連接，就用CONNECTION_STRICTLY模式。</p><p>MEMORY_STRICTLY的原理其實就是我們前面介紹的內容，優點已經說過了。它帶來的一個副作用是，流式ResultSet需要保持對數據庫的連接，必須與所有路由到的真實表成功建立連接後，才能夠進行即時歸併，進而返回結果給客戶端。</p><p>假設數據庫設置max_user_connections=80，而該庫被路由到的表是100個，那麼無論如何也不可能同時建立100個連接，也就無法歸併返回結果。</p><p>CONNECTION_STRICTLY就是為了解決以上問題而存在的。不使用流式ResultSet，內存消耗增加。但該模式不需要保持與數據庫的連接，每次取出ResultSet內的全量數據後即可釋放連接。</p><p>還是剛才的例子max_user_connections=80，而該庫被路由到的表是100個。Proxy會先建立80個連接查詢數據，另外20個連接請求被緩存在連接池隊列中，隨著前面查詢的完成，這20個請求會陸續成功連接數據庫。</p><p>如果你對這個配置還感到迷惑，那麼記住一句話，只有當max_user_connections小於該庫可能被路由到的最大表數量時，才使用CONNECTION_STRICTLY。</p><h1 class=pgc-h-arrow-right>三、小結</h1><p>Sharding-Sphere自2016年開源以來不斷精進和發展，被越來越多企業和個人所使用，同時也為我們提供了重要的成功案例。未來，我們將不斷優化當前的特性，陸續推出大家關注的柔性事務、數據治理等更多新特性。如果大家有什麼想法、意見和建議，也歡迎留言與我們交流，更歡迎加入到Sharding-Sphere的開源項目中：</p><p>https://github.com/sharding-sphere/sharding-sphere/</p><p></p><p>https://gitee.com/sharding-sphere/sharding-sphere/</p><p><br></p><h1 class=pgc-h-arrow-right>Q&A</h1><p>Q1：Sidecar是幹什麼的？</p><p>A1：Sharding-Sidecar是Sharding-Sphere的第三個產品，目前仍在規劃中。定位為Kubernetes或Mesos的雲原生數據庫代理，以DaemonSet的形式代理所有對數據庫的訪問。</p><p></p><p>Q2：“問如果你對這個配置還感到迷惑，那麼記住一句話，只有當max_user_connections小於該庫可能被路由到的最大表數量時，才使用CONNECTION_STRICTLY。”這句話是不是說反了？</p><p>A2：CONNECTION_STRICTLY就是為了省連接的。max_user_connections小，所以用CONNECTION_STRICTLY模式。</p><p></p><p>Q3：stmt.setFetchSize(custom_size)；設置的場景使用類似Mybatis之類的框架查詢大量數據到內存，一般就是放到一個list中，然後處理。內存還是會佔用。</p><p>A3：這種情況佔的是客戶端的內存，不會影響Proxy。</p><p></p><p>Q4：問出現查詢大數據量到內存的場景，是不是隻能使用原生JDBC，查一批處理一批，不放內存？</p><p>A4：Mybatis是在客戶端控制的，不影響Proxy。</p><p></p><h1 class=pgc-h-arrow-right>直播回放鏈接</h1><p>https://m.qlchat.com/topic/details?topicId=2000001395952730&minimal=1</p><p>想了解關於Sharding-Sphere的更多細節？</p><p><strong>不妨來“2018 DAMS中國數據資產管理峰會”</strong></p><p><strong>聽聽京東金融數據研發負責人張亮老師的解析</strong></p><div class=pgc-img><img alt=揭祕Sharding-Proxy——面向DBA的數據庫中間層 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/156ea626e7544657896526ed34c089e7><p class=pgc-img-caption></p></div><p>---</p><p>Sharding-Sphere</p><p>Sharding-Sphere是一套開源的分佈式數據庫中間件解決方案組成的生態圈，它由Sharding-JDBC、Sharding-Proxy和Sharding-Sidecar這3款相互獨立的產品組成。他們均提供標準化的數據分片、讀寫分離、柔性事務和數據治理功能，可適用於如Java同構、異構語言、容器、雲原生等各種多樣化的應用場景。</p><p>亦步亦趨，開源不易，您對我們最大支持，就是在github上留下一個star。</p><p>項目地址：</p><p>https://github.com/sharding-sphere/sharding-sphere/</p><p>https://gitee.com/sharding-sphere/sharding-sphere/</p><p>更多信息請瀏覽官網：</p><p>http://shardingsphere.io/</p><p>或加入Sharding-Sphere官方討論群</p><p>感謝您的支持與關注</p><p>我們將不忘初心，不負眾望！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Sharding</a></li><li><a>Proxy</a></li><li><a>DBA</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5bdb2a5.html alt=大白話解釋SQL注入，DBA大牛裝腔指南！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c702f9ba6eef463892059813cf22a9d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5bdb2a5.html title=大白話解釋SQL注入，DBA大牛裝腔指南！>大白話解釋SQL注入，DBA大牛裝腔指南！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>