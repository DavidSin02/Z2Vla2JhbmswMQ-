<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>快速入門JavaScript性能優化小竅門 | 极客快訊</title><meta property="og:title" content="快速入門JavaScript性能優化小竅門 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f367aea0dc7241b493fc135d5171d0a4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/6bfdf383.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/6bfdf383.html><meta property="article:published_time" content="2020-11-14T20:53:31+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:31+08:00"><meta name=Keywords content><meta name=description content="快速入門JavaScript性能優化小竅門"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/6bfdf383.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>快速入門JavaScript性能優化小竅門</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div><p>在眾多語言中，JavaScript已經佔有重要的一席之地，利用JavaScript我們可以做很多事情 ， 應用廣泛。</p><p>在web應用項目中，需要大量JavaScript的代碼，將來也會越來越多。</p><div class=pgc-img><img alt=快速入門JavaScript性能優化小竅門 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f367aea0dc7241b493fc135d5171d0a4><p class=pgc-img-caption></p></div><p>但是由於JavaScript是一個作為解釋執行的語言，而且它的單線程機制，決定了性能問題是JavaScript的弱點，也是開發者在寫JavaScript的時候需注意的一個問題。</p><p>因為經常會遇到Web 2.0應用性能欠佳的問題，主因就是JavaScript性能不足，導致瀏覽器負荷過重。 Javascript性能優化絕不是一種書面的技能，那麼應該如何正確的加載和執行 JavaScript代碼，從而提高其在瀏覽器中的性能呢?下面就給大家做一些優化小竅門的知識彙總。</p><p>無論當前 JavaScript 代碼是內嵌還是在外鏈文件中，頁面的下載和渲染都必須停下來等待腳本執行完成。JavaScript 執行過程耗時越久，瀏覽器等待響應用戶輸入的時間就越長。</p><p>瀏覽器在下載和執行腳本時出現阻塞的原因在於，腳本可能會改變頁面或JavaScript的命名空間，它們會對後面頁面內容造成影響。一個典型的例子就是在頁面中使用：</p><p>document.write()</p><p>示例：</p><pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;Source Example&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;&lt;script type="text/javascript"&gt;document.write("Today is " + (new Date()).toDateString()); &lt;/script&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p>當瀏覽器遇到&lt;script>標籤時，當前 HTML 頁面無從獲知 JavaScript 是否會向&lt;p> 標籤添加內容，或引入其他元素，或甚至移除該標籤。</p><p>因此，這時瀏覽器會停止處理頁面，先執行 JavaScript代碼，然後再繼續解析和渲染頁面。</p><p>同樣的情況也發生在使用 src 屬性加載 JavaScript的過程中，瀏覽器必須先花時間下載外鏈文件中的代碼，然後解析並執行它。在這個過程中，頁面渲染和用戶交互完全被阻塞了。</p><p><strong>不要使用 with() 語句</strong></p><p>這是因為 with() 語句將會在作用域鏈的開始添加額外的變量。額外的變量意味著，當任何變量需要被訪問的時候，JavaScript引擎都需要先掃描with()語句產生的變量，然後才是局部變量，最後是全局變量。</p><p>因此with()語句同時給局部變量和全局變量的性能帶來負面影響，最終使我們優化JavaScript性能的計劃破產。</p><p>對象屬性和數組元素的速度都比變量慢</p><p>談到JavaScript的數據，一般來說有4種訪問方式：數值、變量、對象屬性和數組元素。在考慮優化時，數值和變量的性能差不多，並且速度顯著優於對象屬性和數組元素。</p><p>因此當你多次引用一個對象屬性或者數組元素的時候，你可以通過定義一個變量來獲得性能提升。(這一條在讀、寫數據時都有效)雖然這條規則在絕大多數情況下是正確的，但是Firefox在優化數組索引上做了一些有意思的工作，能夠讓它的實際性能優於變量。</p><p>但是考慮到數組元素在其他瀏覽器上的性能弊端，還是應該儘量避免數組查找，除非你真的只針對於火狐瀏覽器的性能而進行開發。</p><p><strong>避免全局查找</strong></p><p>在一個函數中會用到全局對象存儲為局部變量來減少全局查找，因為訪問局部變量的速度要比訪問全局變量的速度更快些</p><pre>function search() { //當我要使用當前頁面地址和主機域名alert(window.location.href + window.location.host);} //最好的方式是如下這樣 先用一個簡單變量保存起來function search() { var location = window.location;alert(location.href + location.host);}</pre><p><strong>避免with語句</strong></p><p>和函數類似 ，with語句會創建自己的作用域，因此會增加其中執行的代碼的作用域鏈的長度，由於額外的作用域鏈的查找，在with語句中執行的代碼肯定會比外面執行的代碼要慢，在能不使用with語句的時候儘量不要使用with語句。</p><pre>with (a.b.c.d) {property1 = 1;property2 = 2;} //可以替換為：var obj = a.b.c.d;obj.property1 = 1;obj.property2 = 2;</pre><p><strong>數字轉換成字符串</strong></p><p>一般最好用”" + 1來將數字轉換成字符串，雖然看起來比較醜一點，但事實上這個效率是最高的，性能上來說：</p><p>(“” +) > String() > .toString() > new String()</p><p>通過模板元素clone，替代createElement</p><p>很多人喜歡在JavaScript中使用document.write來給頁面生成內容。事實上這樣的效率較低，如果需要直接插入HTML，可以找一個容器元素，比如指定一個div或者span，並設置他們的innerHTML來將自己的HTML代碼插入到頁面中。</p><p>通常我們可能會使用字符串直接寫HTML來創建節點，其實這樣做，1：無法保證代碼的有效性，2：字符串操作效率低，所以應該是用document.createElement()方法，而如果文檔中存在現成的樣板節點，應該是用cloneNode()方法，因為使用createElement()方法之後，你需要設置多次元素的屬性，使用cloneNode()則可以減少屬性的設置次數——同樣如果需要創建很多元素，應該先準備一個樣板節點。</p><pre>var frag = document.createDocumentFragment(); for (var i = 0; i &lt; 1000; i++) { var el = document.createElement('p');el.innerHTML = i;frag.appendChild(el);} document.body.appendChild(frag); //替換為：var frag = document.createDocumentFragment(); var pEl = document.getElementsByTagName('p')[0]; for (var i = 0; i &lt; 1000; i++) { var el = pEl.cloneNode(false);el.innerHTML = i;frag.appendChild(el);} document.body.appendChild(frag);</pre><p><strong>避免低效率的腳本位置</strong></p><p>HTML 4 規範指出 &lt;script> 標籤可以放在 HTML 文檔的&lt;head>或&lt;body>中，並允許出現多次。Web 開發人員一般習慣在 &lt;head> 中加載外鏈的 JavaScript，接著用 &lt;link> 標籤用來加載外鏈的 CSS 文件或者其他頁面信息。</p><p>低效率腳本位置示例：</p><pre>&lt;html&gt;&lt;head&gt;&lt;title&gt;Source Example&lt;/title&gt;&lt;script type="text/javascript" src="script1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="script2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="script3.js"&gt;&lt;/script&gt;&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello world!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</pre><p>然而這種常規的做法卻隱藏著嚴重的性能問題。</p><p>在清單 2 的示例中，當瀏覽器解析到 &lt;script> 標籤(第 4 行)時，瀏覽器會停止解析其後的內容，而優先下載腳本文件，並執行其中的代碼，這意味著，其後的 styles.css 樣式文件和&lt;body>標籤都無法被加載，由於&lt;body>標籤無法被加載，那麼頁面自然就無法渲染了。</p><p>因此在該 JavaScript 代碼完全執行完之前，頁面都是一片空白。下圖描述了頁面加載過程中腳本和樣式文件的下載過程。</p><div class=pgc-img><img alt=快速入門JavaScript性能優化小竅門 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9fa09bf015e541fdbe16ec2d5215882a><p class=pgc-img-caption></p></div><p>我們可以發現一個有趣的現象：第一個 JavaScript 文件開始下載，與此同時阻塞了頁面其他文件的下載。</p><p>此外，從 script1.js 下載完成到 script2.js 開始下載前存在一個延時，這段時間正好是 script1.js 文件的執行過程。每個文件必須等到前一個文件下載並執行完成才會開始下載。在這些文件逐個下載過程中，用戶看到的是一片空白的頁面。</p><p>從 IE 8、Firefox 3.5、Safari 4 和 Chrome 2 開始都允許並行下載 JavaScript 文件。這是個好消息，因為&lt;script>標籤在下載外部資源時不會阻塞其他&lt;script>標籤。遺憾的是，JavaScript 下載過程仍然會阻塞其他資源的下載，比如樣式文件和圖片。</p><p>儘管腳本的下載過程不會互相影響，但頁面仍然必須等待所有 JavaScript 代碼下載並執行完成才能繼續。因此，儘管最新的瀏覽器通過允許並行下載提高了性能，但問題尚未完全解決，腳本阻塞仍然是一個問題。</p><p>由於腳本會阻塞頁面其他資源的下載，因此推薦將所有&lt;script>標籤儘可能放到&lt;body>標籤的底部，以儘量減少對整個頁面下載的影響。</p><p>推薦的代碼放置位置示例：</p><pre>&lt;head&gt;&lt;title&gt;Source Example&lt;/title&gt;&lt;link rel="stylesheet" type="text/css" href="styles.css"&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello world!&lt;/p&gt;&lt;!-- Example of efficient script positioning --&gt;&lt;script type="text/javascript" src="script1.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="script2.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="script3.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</pre><p>這段代碼展示了在 HTML 文檔中放置&lt;script>標籤的推薦位置。儘管腳本下載會阻塞另一個腳本，但是頁面的大部分內容都已經下載完成並顯示給了用戶，因此頁面下載不會顯得太慢。</p><p>這是優化 JavaScript 的首要規則：將腳本放在底部。</p><p><strong>小心使用閉包</strong></p><p>雖然你可能還不知道“閉包”，但你可能在不經意間經常使用這項技術。閉包基本上被認為是JavaScript中的new，當我們定義一個即時函數的時候，我們就使用了閉包，比如：</p><p>document.getElementById('foo').onclick = function(ev) { };</p><p>閉包的問題在於：根據定義，在它們的作用域鏈中至少有三個對象：閉包變量、局部變量和全局變量。這些額外的對象將會導致其他的性能問題。但是Nicholas並不是要我們因噎廢食，閉包對於提高代碼可讀性等方面還是非常有用的，只是不要濫用它們(尤其在循環中)。</p><p><strong>在循環時將控制條件和控制變量合併起來</strong></p><p>提到性能，在循環中需要避免的工作一直是個熱門話題，因為循環會被重複執行很多次。所以如果有性能優化的需求，先對循環開刀有可能會獲得最明顯的性能提升。</p><p>一種優化循環的方法是在定義循環的時候，將控制條件和控制變量合併起來，下面是一個沒有將他們合併起來的例子：</p><p>for ( var x = 0; x &lt; 10; x++ ) {};</p><p>當我們要添加什麼東西到這個循環之前，我們發現有幾個操作在每次迭代都會出現。JavaScript引擎需要：</p><p>#1：檢查 x 是否存在#2：檢查 x 是否小於 0 &lt;span style="color: #888888;">(這裡可能有筆誤)&lt;/span>#3：使 x 增加 1</p><p>然而如果你只是迭代元素中的一些元素，那麼你可以使用while循環進行輪轉來替代上面這種操作：</p><p>var x = 9;do { } while( x-- );</p><p>使用 XMLHttpRequest(XHR)對象</p><p>此技術首先創建一個 XHR 對象，然後下載 JavaScript 文件，接著用一個動態&lt;script>元素將 JavaScript 代碼注入頁面。</p><p>通過 XHR 對象加載 JavaScript 腳本：</p><pre>var xhr = new XMLHttpRequest();xhr.open("get", "script1.js", true);xhr.onreadystatechange = function(){ if (xhr.readyState == 4){ if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300 || xhr.status == 304){ var script = document.createElement ("script");script.type = "text/javascript";script.text = xhr.responseText; document.body.appendChild(script);}}};xhr.send(null);</pre><p>此代碼向服務器發送一個獲取 script1.js 文件的 GET 請求。onreadystatechange 事件處理函數檢查readyState 是不是 4，然後檢查 HTTP 狀態碼是不是有效(2XX 表示有效的迴應，304 表示一個緩存響應)。</p><p>如果收到了一個有效的響應，那麼就創建一個新的&lt;script>元素，將它的文本屬性設置為從服務器接收到的 responseText 字符串。</p><p>這樣做實際上會創建一個帶有內聯代碼的&lt;script>元素。一旦新&lt;script>元素被添加到文檔，代碼將被執行，並準備使用。</p><p>這種方法的主要優點是，您可以下載不立即執行的 JavaScript 代碼。由於代碼返回在&lt;script>標籤之外(換句話說不受&lt;script>標籤約束)，它下載後不會自動執行，這使得您可以推遲執行，直到一切都準備好了。</p><p>另一個優點是，同樣的代碼在所有現代瀏覽器中都不會引發異常。</p><p>此方法最主要的限制是：JavaScript 文件必須與頁面放置在同一個域內，不能從 CDN 下載(CDN 指”內容投遞網絡(Content Delivery Network)”，所以大型網頁通常不採用 XHR 腳本注入技術。</p><p><strong>注意NodeList</strong></p><p>最小化訪問NodeList的次數可以極大的改進腳本的性能</p><pre>var images = document.getElementsByTagName('img'); for (var i = 0, len = images.length; i &lt; len; i++) {}</pre><p>編寫JavaScript的時候一定要知道何時返回NodeList對象，這樣可以最小化對它們的訪問。</p><p>1、進行了對getElementsByTagName()的調用</p><p>2、獲取了元素的childNodes屬性</p><p>3、獲取了元素的attributes屬性</p><p>4、訪問了特殊的集合，如document.forms、document.images等等</p><p>要了解了當使用NodeList對象時，合理使用會極大的提升代碼執行速度</p><p><strong>避免與null進行比較</strong></p><p>由於JavaScript是弱類型的，所以它不會做任何的自動類型檢查，所以如果看到與null進行比較的代碼，嘗試使用以下技術替換：</p><p>1、如果值應為一個引用類型，使用instanceof操作符檢查其構造函數</p><p>2、如果值應為一個基本類型，作用typeof檢查其類型</p><p>3、如果是希望對象包含某個特定的方法名，則使用typeof操作符確保指定名字的方法存在於對象上。</p><p><strong>尊重對象的所有權</strong></p><p>因為JavaScript可以在任何時候修改任意對象，這樣就可以以不可預計的方式覆寫默認的行為，所以如果你不負責維護某個對象，它的對象或者它的方法，那麼你就不要對它進行修改，具體一點就是說：</p><p>1、不要為實例或原型添加屬性</p><p>2、不要為實例或者原型添加方法</p><p>3、不要重定義已經存在的方法</p><p>4、不要重複定義其它團隊成員已經實現的方法，永遠不要修改不是由你所有的對象，你可以通過以下方式為對象創建新的功能:</p><p>01、創建包含所需功能的新對象，並用它與相關對象進行交互</p><p>02、創建自定義類型，繼承需要進行修改的類型，然後可以為自定義類型添加額外功能</p><p><strong>循環引用</strong></p><p>如果循環引用中包含DOM對象或者ActiveX對象，那麼就會發生內存洩露。</p><p>內存洩露的後果是在瀏覽器關閉前，即使是刷新頁面，這部分內存不會被瀏覽器釋放。</p><p>簡單的循環引用：</p><p>var el = document.getElementById('MyElement'); var func = function () { //…</p><p>}</p><p>el.func = func;</p><p>func.element = el;</p><p>但是通常不會出現這種情況。通常循環引用發生在為dom元素添加閉包作為expendo的時候。</p><p>function init() { var el = document.getElementById('MyElement');</p><p>el.onclick = function () { //……</p><p>}</p><p>}</p><p>init();</p><p>init在執行的時候，當前上下文我們叫做context。這個時候，context引用了el，el引用了function，function引用了context。這時候形成了一個循環引用。</p><p>下面2種方法可以解決循環引用：</p><p>1、置空dom對象</p><pre>function init() { var el = document.getElementById('MyElement');el.onclick = function () { //……}}init(); //可以替換為：function init() { var el = document.getElementById('MyElement');el.onclick = function () { //……}el = null;}init();</pre><p>將el置空，context中不包含對dom對象的引用，從而打斷循環應用。</p><p>如果我們需要將dom對象返回，可以用如下方法：</p><pre>function init() { var el = document.getElementById('MyElement');el.onclick = function () { //……} return el;}init(); //可以替換為：function init() { var el = document.getElementById('MyElement');el.onclick = function () { //……} try { return el;} finally {el = null;}}init();</pre><p>2、構造新的context</p><pre>function init() { var el = document.getElementById('MyElement');el.onclick = function () { //……}}init(); //可以替換為：function elClickHandler() { //……} function init() { var el = document.getElementById('MyElement');el.onclick = elClickHandler;}init();</pre><p>把function抽到新的context中，這樣，function的context就不包含對el的引用，從而打斷循環引用。</p><p>通過javascript創建的dom對象，必須append到頁面中</p><p>IE下，腳本創建的dom對象，如果沒有append到頁面中，刷新頁面，這部分內存是不會回收的!</p><pre>function create() { var gc = document.getElementById('GC'); for (var i = 0; i &lt; 5000; i++) { var el = document.createElement('div');el.innerHTML = "test"; //下面這句可以註釋掉，看看瀏覽器在任務管理器中，點擊按鈕然後刷新後的內存變化gc.appendChild(el);}}</pre><p>字符串連接</p><p>如果要連接多個字符串，應該少使用+=，如</p><p>s+=a;</p><p>s+=b;</p><p>s+=c;</p><p>應該寫成s+=a + b + c;</p><p>而如果是收集字符串，比如多次對同一個字符串進行+=操作的話，最好使用一個緩存，使用JavaScript數組來收集，最後使用join方法連接起來</p><pre>var buf = [];for (var i = 0; i &lt; 100; i++) { buf.push(i.toString());} var all = buf.join("");</pre><p>各種類型轉換</p><pre>var myVar = "3.14159",str = "" + myVar, // to stringi_int = ~ ~myVar, // to integerf_float = 1 * myVar, // to floatb_bool = !!myVar, /* to boolean - any string with lengthand any number except 0 are true */array = [myVar]; // to array</pre><p>如果定義了toString()方法來進行類型轉換的話，推薦顯式調用toString()，因為內部的操作在嘗試所有可能性之後，會嘗試對象的toString()方法嘗試能否轉化為String，所以直接調用這個方法效率會更高。</p><p>多個類型聲明</p><p>在JavaScript中所有變量都可以使用單個var語句來聲明，這樣就是組合在一起的語句，以減少整個腳本的執行時間，就如上面代碼一樣，上面代碼格式也挺規範，讓人一看就明瞭。</p><p>插入迭代器</p><p>如var name=values[i]; i++;前面兩條語句可以寫成var name=values[i++]。</p><p>使用直接量</p><pre>var aTest = new Array(); //替換為var aTest = [];var aTest = new Object; //替換為var aTest = {};var reg = new RegExp(); //替換為var reg = /../;</pre><p>//如果要創建具有一些特性的一般對象，也可以使用字面量，如下：</p><pre>var oFruit = new O;oFruit.color = "red";oFruit.name = "apple";</pre><p>//前面的代碼可用對象字面量來改寫成這樣：</p><p>var oFruit = { color: "red", name: "apple" };</p><p><strong>避免雙重解釋</strong></p><p>如果要提高代碼性能，儘可能避免出現需要按照JavaScript解釋的字符串，也就是</p><p>1、儘量少使用eval函數</p><p>使用eval相當於在運行時再次調用解釋引擎對內容進行運行，需要消耗大量時間，而且使用Eval帶來的安全性問題也是不容忽視的。</p><p>2、不要使用Function構造器</p><p>不要給setTimeout或者setInterval傳遞字符串參數</p><p><strong>縮短否定檢測</strong></p><pre>if (oTest != '#ff0000') {//do something}if (oTest != null) {//do something}if (oTest != false) {//do something}//雖然這些都正確，但用邏輯非操作符來操作也有同樣的效果：if (!oTest) {//do something}</pre><p><strong>釋放JavaScript對象</strong></p><p>在rich應用中，隨著實例化對象數量的增加，內存消耗會越來越大。所以應當及時釋放對對象的引用，讓GC能夠回收這些內存控件。</p><p>對象：obj = null</p><p>對象屬性：delete obj.myproperty</p><p>數組item：使用數組的splice方法釋放數組中不用的item</p><p>性能方面的注意事項</p><p>1、儘量使用原生方法</p><p>2、switch語句相對if較快</p><p>通過將case語句按照最可能到最不可能的順序進行組織。</p><p>3、位運算較快</p><p>當進行數字運算時，位運算操作要比任何布爾運算或者算數運算快。</p><p>4、巧用||和&&布爾運算符</p><pre>function eventHandler(e) {if (!e) e = window.event;}//可以替換為：function eventHandler(e) {e = e || window.event;}if (myobj) {doSomething(myobj);}//可以替換為：myobj &amp;&amp; doSomething(myobj);</pre><p><strong>避免錯誤應注意的地方</strong></p><p>1、每條語句末尾須加分號</p><p>在if語句中，即使條件表達式只有一條語句也要用{}把它括起來，以免後續如果添加了語句之後造成邏輯錯誤。</p><p>2、使用+號時需謹慎</p><p>JavaScript 和其他編程語言不同的是，在 JavaScript 中，’+'除了表示數字值相加，字符串相連接以外，還可以作一元運算符用，把字符串轉換為數字。因而如果使用不當，則可能與自增符’++’混淆而引起計算錯誤。</p><pre>var valueA = 20;var valueB = "10";alert(valueA + valueB); //ouput: 2010alert(valueA + (+valueB)); //output: 30alert(valueA + +valueB); //output:30alert(valueA ++ valueB); //Compile error</pre><p>3、使用return語句需要注意</p><p>一條有返回值的return語句不要用()括號來括住返回值，如果返回表達式，則表達式應與return關鍵字在同一行，以避免壓縮時，壓縮工具自動加分號而造成返回與開發人員不一致的結果。</p><pre>function F1() {var valueA = 1;var valueB = 2;return valueA + valueB;}function F2() {var valueA = 1;var valueB = 2;returnvalueA + valueB;}alert(F1()); //output: 3alert(F2()); //ouput: undefined</pre><p>==和===的區別</p><p>避免在if和while語句的條件部分進行賦值，如if (a = b)，應該寫成if (a == b)，但是在比較是否相等的情況下，最好使用全等運行符，也就是使用===和!==操作符會相對於==和!=會好點。==和!=操作符會進行類型強制轉換。</p><pre>var valueA = "1";var valueB = 1;if (valueA == valueB) {alert("Equal");}else {alert("Not equal");}//output: "Equal"if (valueA === valueB) {alert("Equal");}else {alert("Not equal");}//output: "Not equal"</pre><p><strong>不要使用生偏語法</strong></p><p>不要使用生偏語法，寫讓人迷惑的代碼，雖然計算機能夠正確識別並運行，但是晦澀難懂的代碼不方便以後維護。</p><p><strong>函數返回統一類型</strong></p><p>雖然JavaScript是弱類型的，對於函數來說，前面返回整數型數據，後面返回布爾值在編譯和運行都可以正常通過，但為了規範和以後維護時容易理解，應保證函數應返回統一的數據類型。</p><p>總是檢查數據類型</p><p>要檢查你的方法輸入的所有數據，一方面是為了安全性，另一方面也是為了可用性。用戶隨時隨地都會輸入錯誤的數據。這不是因為他們蠢，而是因為他們很忙，並且思考的方式跟你不同。用typeof方法來檢測你的function接受的輸入是否合法。</p><p><strong>何時用單引號，何時用雙引號</strong></p><p>雖然在JavaScript當中，雙引號和單引號都可以表示字符串, 為了避免混亂，我們建議在HTML中使用雙引號，在JavaScript中使用單引號，但為了兼容各個瀏覽器，也為了解析時不會出錯，定義JSON對象時，最好使用雙引號。</p><p><strong>部署</strong></p><p>1、用JSLint運行JavaScript驗證器來確保沒有語法錯誤或者是代碼沒有潛在的問</p><p>2、部署之前推薦使用壓縮工具將JS文件壓縮</p><p>3、文件編碼統一用UTF-8</p><p>4、JavaScript 程序應該儘量放在 .js 的文件中，需要調用的時候在 HTML 中以 &lt;script src=”filename.js”> 的形式包含進來。</p><p>JavaScript 代碼若不是該 HTML 文件所專用的，則應儘量避免在 HTML 文件中直接編寫 JavaScript 代碼。因為這樣會大大增加 HTML 文件的大小，無益於代碼的壓縮和緩存的使用。另外，&lt;script src=”filename.js”> 標籤應儘量放在文件的後面,最好是放在&lt;/body>標籤前。</p><p>這樣會降低因加載 JavaScript 代碼而影響頁面中其它組件的加載時間。</p><p>永遠不要忽略代碼優化工作，重構是一項從項目開始到結束需要持續的工作，只有不斷的優化代碼才能讓代碼的執行效率越來越好。更多web前端開發資料，可以關注“武漢千鋒”微信公眾號！</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>入門</a></li><li><a>JavaScript</a></li><li><a>優化</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed35c2c.html alt=進化策略入門：最優化問題的另一種視角 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/65c200036baa0b926177 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed35c2c.html title=進化策略入門：最優化問題的另一種視角>進化策略入門：最優化問題的另一種視角</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html alt="深度研究自然梯度優化，從入門到放棄 | Deep Reading" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2cc1b8ef47a5458190c22d26d8bd164c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html title="深度研究自然梯度優化，從入門到放棄 | Deep Reading">深度研究自然梯度優化，從入門到放棄 | Deep Reading</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html alt=EXCEL入門基礎：對行和列選定數據求和 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f03f82096d240dd92410709f3e19eb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html title=EXCEL入門基礎：對行和列選定數據求和>EXCEL入門基礎：對行和列選定數據求和</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html alt=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49834ccb43ed42cb9a54c9827c3ab134 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html title=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！>工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html alt=工程造價：入門知識全套講義，30章600頁，精通造價首選之作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e1b335c343a455f8777dd3144fc1c35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html title=工程造價：入門知識全套講義，30章600頁，精通造價首選之作>工程造價：入門知識全套講義，30章600頁，精通造價首選之作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html alt=“黑客”入門學習之“Windows組策略” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea21244d5f5c420ebef29650f3fafd1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html title=“黑客”入門學習之“Windows組策略”>“黑客”入門學習之“Windows組策略”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html alt=PHP入門教程，5天86節課助力小白變大神！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4366000004d4c98fd587 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html title=PHP入門教程，5天86節課助力小白變大神！>PHP入門教程，5天86節課助力小白變大神！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html alt=Thinkphp6快速入門一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c4331ddc0ffb4c94a4aa80be95178354 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html title=Thinkphp6快速入門一>Thinkphp6快速入門一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html alt="php新手入門教程， 最全最完整的教學視頻課程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/666a38216ab04790a716bb1451c7fe44 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html title="php新手入門教程， 最全最完整的教學視頻課程">php新手入門教程， 最全最完整的教學視頻課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html alt=「素描入門」基礎不紮實，從排線練起 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15252166717297d7af296ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html title=「素描入門」基礎不紮實，從排線練起>「素描入門」基礎不紮實，從排線練起</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html alt=「素描入門」素描排線的繪畫技法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1530098801296ab58189790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html title=「素描入門」素描排線的繪畫技法>「素描入門」素描排線的繪畫技法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a993b442.html alt=素描入門丨你說線條或者排線，容易嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1536648317995f32cedaa40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a993b442.html title=素描入門丨你說線條或者排線，容易嗎？>素描入門丨你說線條或者排線，容易嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0e2c5d2.html alt=零基礎入門要知道的素描知識總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c2c16563-8821-4294-a8c6-9d76e62a2440 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0e2c5d2.html title=零基礎入門要知道的素描知識總結>零基礎入門要知道的素描知識總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html alt=JAVA入門到大神（玩轉正則表達式） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f585f1e.html title=JAVA入門到大神（玩轉正則表達式）>JAVA入門到大神（玩轉正則表達式）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>