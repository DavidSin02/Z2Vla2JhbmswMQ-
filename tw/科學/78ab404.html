<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>力扣1514——概率最大的路徑 | 极客快訊</title><meta property="og:title" content="力扣1514——概率最大的路徑 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/5b3a5789ae2f47f89971a60551cc5128"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/78ab404.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/78ab404.html><meta property="article:published_time" content="2020-10-29T20:56:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:56:28+08:00"><meta name=Keywords content><meta name=description content="力扣1514——概率最大的路徑"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/78ab404.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>力扣1514——概率最大的路徑</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><p>本題主要和圖的遍歷求解最短路徑相關，可以用 Dijkstra 或者 Bellman-Ford 算法進行解決。</p><h1 class=pgc-h-arrow-right>原題</h1><p>給你一個由 n 個節點（下標從 0 開始）組成的無向加權圖，該圖由一個描述邊的列表組成，其中 edges[i] = [a, b] 表示連接節點 a 和 b 的一條無向邊，且該邊遍歷成功的概率為 succProb[i] 。</p><p>指定兩個節點分別作為起點 start 和終點 end ，請你找出從起點到終點成功概率最大的路徑，並返回其成功概率。</p><p>如果不存在從 start 到 end 的路徑，請 返回 0 。只要答案與標準答案的誤差不超過 1e-5 ，就會被視作正確答案。</p><p>示例 1：</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b3a5789ae2f47f89971a60551cc5128><p class=pgc-img-caption></p></div><pre><code>輸入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2輸出：0.25000解釋：從起點到終點有兩條路徑，其中一條的成功概率為 0.2 ，而另一條為 0.5 * 0.5 = 0.25</code></pre><p>示例 2：</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5bd4088dab6743bf9bc34832848b47bf><p class=pgc-img-caption></p></div><pre><code>輸入：n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2輸出：0.30000</code></pre><p>示例 3：</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e808bd20f85b47d391fdf998cc4483ce><p class=pgc-img-caption></p></div><pre><code>輸入：n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2輸出：0.00000解釋：節點 0 和 節點 2 之間不存在路徑</code></pre><p>提示：</p><ul><li>2 &lt;= n &lt;= 10^4</li><li>0 &lt;= start, end &lt; n</li><li>start != end</li><li>0 &lt;= a, b &lt; n</li><li>a != b</li><li>0 &lt;= succProb.length == edges.length &lt;= 2*10^4</li><li>0 &lt;= succProb[i] &lt;= 1</li><li>每兩個節點之間最多有一條邊</li></ul><h1 class=pgc-h-arrow-right>解題</h1><h1 class=pgc-h-arrow-right>首次嘗試</h1><p>原本，我想利用樹的深度優先搜索遍歷，加上一定程度的剪枝（就是排除已經遍歷過的節點），完成這道題目，代碼如下：</p><pre><code>class Solution {    /**     * key為起始點，value為所有相連的點     */    Map&lt;Integer, Set&lt;Integer&gt;&gt; map;    /**     * key為"點A_點B"(A &lt; B)，value為對應的概率     */    Map&lt;String, Double&gt; probMap;    double maxProb = -1;    int end;    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {        map = new HashMap&lt;&gt;(n * 4 / 3 + 1);        probMap = new HashMap&lt;&gt;(succProb.length * 4 / 3 + 1);        this.end = end;        // 構造每個點的相連關係        for (int i = 0; i &lt; edges.length; i++) {            int[] edge = edges[i];            Set&lt;Integer&gt; set = map.computeIfAbsent(edge[0], k -&gt; new HashSet&lt;&gt;());            set.add(edge[1]);            set = map.computeIfAbsent(edge[1], k -&gt; new HashSet&lt;&gt;());            set.add(edge[0]);            String key = edge[0] &lt; edge[1] ? (edge[0] + "_" + edge[1]) : (edge[1] + "_" + edge[0]);            probMap.put(key, succProb[i]);        }        boolean[] visited = new boolean[n];        dp(start, 1, visited);        return maxProb == -1 ? 0 : maxProb;    }    public void dp(int index, double prob, boolean[] visited) {        // 已到終點        if (index == end) {            maxProb = prob &gt; maxProb ? prob : maxProb;            return;        }        // 獲取當前點可以到達的所有點        Set&lt;Integer&gt; set = map.get(index);        // 如果當前點到達不了其餘點        if (set == null) {            return;        }        // 標記當前點已訪問        visited[index] = true;        // 遍歷相鄰的點        for (int next : set) {            if (visited[next]) {                continue;            }            String key = index &lt; next ? (index + "_" + next) : (next + "_" + index);                        // 訪問下一個點            dp(next, prob * probMap.get(key), visited);        }        // 退出，將該點標記為未訪問        visited[index] = false;    }}</code></pre><p>但很可惜，超時了。我想了一下，應該是因為沒有借用之前已經計算出來的結果，因此比較浪費時間。</p><p>其時間複雜度取決於邊的數量，假設邊的數量是 m ，則時間複雜度為O(m^2)。</p><p>而邊 m 與點 n 的關係，m 最小是 0（也就是點之間沒有線），最大是 (n - 1) * n / 2，每個點之間都有連線。</p><p>因此可以預見，這樣的算法效率確實很差。</p><h1 class=pgc-h-arrow-right>Dijkstra 算法</h1><h1 class=pgc-h-arrow-right>定義概覽</h1><p>Dijkstra (迪傑斯特拉)算法是典型的單源最短路徑算法，用於計算一個節點到其他所有節點的最短路徑。主要特點是以起始點為中心向外層層擴展，直到擴展到終點為止。</p><p>注意該算法要求圖中不存在負權邊。</p><h1 class=pgc-h-arrow-right>算法思想</h1><p>設 G=(V,E) 是一個帶權有向圖，把圖中頂點集合 V 分成兩組：</p><p>第一組為已求出最短路徑的頂點集合（用 S 表示，初始時 S 中只有一個源點，以後每求得一條最短路徑 , 就將加入到集合 S 中，直到全部頂點都加入到 S 中，算法就結束了）。</p><p>第二組為其餘未確定最短路徑的頂點集合（用 U 表示），按最短路徑長度的遞增次序依次把第二組的頂點加入 S 中。</p><p>在加入的過程中，總保持從源點 v 到 S 中各頂點的最短路徑長度不大於從源點 v 到 U 中任何頂點的最短路徑長度。</p><p>此外，每個頂點對應一個距離，S 中的頂點的距離就是從 v 到此頂點的最短路徑長度。U 中的頂點的距離，是從 v 到此頂點只包括 S 中的頂點為中間頂點的當前最短路徑長度。</p><h1 class=pgc-h-arrow-right>算法步驟</h1><ol start=1><li>初始時，S 只包含源點，即 S ＝{v}，v 的距離為0。U 包含除 v 外的其他頂點，即: U ={其餘頂點}，若 v 與 U 中頂點 u 有邊，則正常有權值，若u不是v的出邊鄰接點，則權值為∞。</li><li>從U中選取一個距離v最小的頂點k，把k，加入S中（該選定的距離就是v到k的最短路徑長度）。</li><li>以k為新考慮的中間點，修改U中各頂點的距離；若從源點v到頂點u的距離（經過頂點k）比原來距離（不經過頂點k）短，則修改頂點u的距離值，修改後的距離值的頂點k的距離加上邊上的權。</li><li>重複步驟b和c直到所有頂點都包含在S中。</li></ol><p>執行動畫過程如下圖</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee6b41c1e6244534b608e52efb071632><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>本題解法</h1><pre><code>class Solution {    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {        // records[i]代表點i相鄰的所有點，以及其概率        List&lt;List&lt;Record&gt;&gt; allRecords = new ArrayList&lt;&gt;(n + 1);        for (int i = 0; i &lt; n + 1; i++) {            allRecords.add(new LinkedList&lt;&gt;());        }        // 構造每個點的相連關係        for (int i = 0; i &lt; edges.length; i++) {            int[] edge = edges[i];            List&lt;Record&gt; records = allRecords.get(edge[0]);            records.add(new Record(edge[1], succProb[i]));            records = allRecords.get(edge[1]);            records.add(new Record(edge[0], succProb[i]));        }        // 利用廣度優先搜索，進行遍歷        // 借用優先隊列，保證優先遍歷當前概率高的        PriorityQueue&lt;Record&gt; queue = new PriorityQueue&lt;&gt;();        // 記錄從start到每一個點的概率        double[] result = new double[n];        // 從start開始遍歷        queue.offer(new Record(start, 1));        result[start] = 1;        // 開始        while (!queue.isEmpty()) {            // 當前節點            Record record = queue.poll();            int node = record.node;            double prob = record.prob;            // 獲取當前點所能達到的其他節點            List&lt;Record&gt; otherNodes = allRecords.get(node);            // 遍歷其餘節點            for (Record next : otherNodes) {                int nextNode = next.node;                double nextProb = prob * next.prob;                // 如果當前計算出的概率，小於等於之前計算的概率                if (nextProb &lt;= result[nextNode]) {                    // 那麼就沒有必要繼續算了，直接用之前的即可                    continue;                }                // 更新概率                result[nextNode] = nextProb;                // 如果已到結尾或者當前的概率已經比到end的小                if (nextNode == end || nextProb &lt; result[end]) {                    // 那麼也沒有必要繼續了                    continue;                }                // 添加節點                queue.offer(new Record(nextNode, nextProb));            }        }        return result[end];    }    class Record implements Comparable&lt;Record&gt; {        int node;        double prob;        public Record(int node, double prob) {            this.node = node;            this.prob = prob;        }        @Override        public int compareTo(Record other) {            if (other == null) {                return -1;            }            if (this.prob == other.prob) {                return this.node - other.node;            }            return this.prob - other.prob &gt; 0 ? -1 : 1;        }    }}</code></pre><p>提交OK，執行用時超過了69%的 java 提交記錄，看來還有值得優化的地方。</p><p>假設邊的數量為 m ，點的數量為 n ，則時間複雜度為O(n + m + nlogn)。</p><h1 class=pgc-h-arrow-right>Bellman-Ford 算法</h1><p>之前有說到 Dijkstra 算法要求不能有負權邊，而這個 Bellman-Ford 算法是支持的。</p><h1 class=pgc-h-arrow-right>算法步驟</h1><ol start=1><li>創建源頂點 v 到圖中所有頂點的距離的集合 distSet，為圖中的所有頂點指定一個距離值，初始均為 Infinite，源頂點距離為 0；</li><li>計算最短路徑，執行 V - 1 次遍歷；對於圖中的每條邊：如果起點 u 的距離 d 加上邊的權值 w 小於終點 v 的距離 d，則更新終點 v 的距離值 d；</li><li>檢測圖中是否有負權邊形成了環，遍歷圖中的所有邊，計算 u 至 v 的距離，如果對於 v 存在更小的距離，則說明存在環；</li></ol><p>例如，下面的有向圖 G 中包含 5 個頂點和 8 條邊。假設源點 為 A。初始化 distSet 所有距離為 INFI，源點 A 為 0。</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d72280c1217b40a29220771adc0f78cd><p class=pgc-img-caption></p></div><p>由於圖中有 5 個頂點，按照步驟 1 需要遍歷 4 次，第一次遍歷的結果如下。</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dd8dd027e6d946fa9466ee8281ffe3c0><p class=pgc-img-caption></p></div><p>第二次遍歷的結果如下。</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/72bd754e8863432194caba5990e62464><p class=pgc-img-caption></p></div><p>以此類推可以得出完全遍歷的結果。</p><h1 class=pgc-h-arrow-right>本題解法</h1><pre><code>class Solution {  public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {    // 記錄結果    double[] result = new double[n];    // 起點    result[start] = 1;    // 從start點出發，先更新直接與start點相連的點的概率，然後逐步更新，直到不需要更新為止    while (true) {      // 是否有過變動      boolean changed = false;      // 遍歷所有邊      for (int j = 0; j &lt; edges.length; j++) {        int[] edge = edges[j];        // 如果從當前點edge[0]出發，到edge[1]的概率，大於之前記錄的結果        if (result[edge[0]] * succProb[j] &gt; result[edge[1]]) {          // 則更新          result[edge[1]] = result[edges[j][0]] * succProb[j];          changed = true;        }        // 因為是無向圖,所以再反向遍歷        if (result[edge[1]] * succProb[j] &gt; result[edge[0]]) {          result[edge[0]] = result[edge[1]] * succProb[j];          changed = true;        }      }      // 一遍未修改則表示圖已遍歷完成      if (!changed) {        break;      }    }    return result[end];  }}</code></pre><p>提交OK，執行用時超過了95%的 java 提交記錄。</p><p>其時間假設邊的數量為 m ，點的數量為 n ，則時間複雜度為O(mn)。</p><h1 class=pgc-h-arrow-right>總結</h1><p>以上就是這道題目我的解答過程了，不知道大家是否理解了。本題主要和圖的遍歷求解最短路徑相關，可以用 Dijkstra 或者 Bellman-Ford 算法進行解決。</p><p>有興趣的話可以訪問我的博客或者關注我的公眾號、頭條號，說不定會有意外的驚喜。</p><p>https://death00.github.io/</p><p>公眾號：健程之道</p><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03169d2510f2499da433d9b20ea9a3d8><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=力扣1514——概率最大的路徑 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bea144449ad344a7874a2a083341874c><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>力扣</a></li><li><a>1514</a></li><li><a>路徑</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cd5d250.html alt=3個案例讀懂：全鏈路用戶路徑分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RjZyevYGAPnBiN style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cd5d250.html title=3個案例讀懂：全鏈路用戶路徑分析>3個案例讀懂：全鏈路用戶路徑分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d7933e0.html alt=電力電纜路徑圖識讀與繪製 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9b36b3bdd13641c986f2bdc461682e48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d7933e0.html title=電力電纜路徑圖識讀與繪製>電力電纜路徑圖識讀與繪製</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6547119b.html alt=java獲取文件路徑 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6b93ba59ac2444599e9deec6b02414d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6547119b.html title=java獲取文件路徑>java獲取文件路徑</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/aa4dc56e.html alt=何帆：探尋增長路徑，先找準自己的生態位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6hy1ap7yQZV76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/aa4dc56e.html title=何帆：探尋增長路徑，先找準自己的生態位>何帆：探尋增長路徑，先找準自己的生態位</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/26a58476.html alt=製造業高質量發展的思考和路徑選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/26a58476.html title=製造業高質量發展的思考和路徑選擇>製造業高質量發展的思考和路徑選擇</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/f8836ea2.html alt=第五人格：到目前為止，推理路徑走了一千多步，存骰子等下賽季吧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15382940053615ebda3e1a1 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/f8836ea2.html title=第五人格：到目前為止，推理路徑走了一千多步，存骰子等下賽季吧>第五人格：到目前為止，推理路徑走了一千多步，存骰子等下賽季吧</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/43ff3b92.html alt=《戰略與路徑-邁向2049的中國》新書研討會：中共中央黨校國際戰略研究院副院長周天勇的演講 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R7OIkkp4I2OPQT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/43ff3b92.html title=《戰略與路徑-邁向2049的中國》新書研討會：中共中央黨校國際戰略研究院副院長周天勇的演講>《戰略與路徑-邁向2049的中國》新書研討會：中共中央黨校國際戰略研究院副院長周天勇的演講</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/53204a74.html alt=踝關節骨折臨床路徑（2019年版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/26c6b1daa6694b7e9f7cb964fc856001 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/53204a74.html title=踝關節骨折臨床路徑（2019年版）>踝關節骨折臨床路徑（2019年版）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/8528c0c8.html alt=讀書筆記：朝抵抗力最大的路徑走（下） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/725e8391dcd94f8db21ecf094d7215e4 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/8528c0c8.html title=讀書筆記：朝抵抗力最大的路徑走（下）>讀書筆記：朝抵抗力最大的路徑走（下）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c917f97a.html alt=深度學習：技術原理、迭代路徑與侷限 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/65b0001c869e5311b8d6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c917f97a.html title=深度學習：技術原理、迭代路徑與侷限>深度學習：技術原理、迭代路徑與侷限</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b81173b.html alt=中考數學丨最全的動點路徑問題！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/693dfc6cb5c9449abc7596eb4b2f4f76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b81173b.html title=中考數學丨最全的動點路徑問題！>中考數學丨最全的動點路徑問題！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5b44de.html alt=1秒找到電腦上的文件路徑，必裝秒級搜索神器！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/9d681dc3-00ee-4acc-bc67-8a89df178c90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5b44de.html title=1秒找到電腦上的文件路徑，必裝秒級搜索神器！>1秒找到電腦上的文件路徑，必裝秒級搜索神器！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3eb361a.html alt=Python小技巧：3個處理文件路徑的簡單方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RXfpIwbEJgChY1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3eb361a.html title=Python小技巧：3個處理文件路徑的簡單方法>Python小技巧：3個處理文件路徑的簡單方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb03bc7.html alt=excel提取指定路徑下的文件名稱 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be824e681822489ba77a4dda823f5b23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb03bc7.html title=excel提取指定路徑下的文件名稱>excel提取指定路徑下的文件名稱</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3ad1d7.html alt=慢慢的查找文件路徑，很麻煩，有一種快捷方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7e955a74a7954f12bee63b6669ac21f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3ad1d7.html title=慢慢的查找文件路徑，很麻煩，有一種快捷方法>慢慢的查找文件路徑，很麻煩，有一種快捷方法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>