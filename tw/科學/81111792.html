<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構--圖 | 极客快訊</title><meta property="og:title" content="數據結構--圖 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/74fefae0669c41d18bf5ef60310d81e0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/81111792.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/81111792.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/81111792.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/81111792.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/81111792.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/81111792.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/81111792.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/81111792.html><meta property="article:published_time" content="2020-11-14T20:53:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:56+08:00"><meta name=Keywords content><meta name=description content="數據結構--圖"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/81111792.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構--圖</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><p>故事凌 今天</p><h2 class=rich_media_title>基本知識點</h2><p>圖可說是所有數據結構裡面知識點最豐富的一個, 自己笨的知識點如下:</p><ul class=list-paddingleft-2><li>階(oRDER), 度: 出度(out-Degree), 入度(in-Degree)</li><li>樹(Tree), 森林(Forest), 環(Loop)</li><li>有向圖(Directed Graph), 無向圖(Undirected Graph), 完全有向圖, 完全無向圖</li><li>連通圖(Connected Graph), 連通分量(Connnected Component)</li><li>存儲和表達式: 鄰接矩陣(Adjacency Matrix), 鄰接鏈表(Adjacency List)</li></ul><p>圍繞圖的算法也是五花八門</p><ul class=list-paddingleft-2><li>圖的遍歷: 深度優先, 廣度優先</li><li>環的檢測: 有向圖, 無向圖</li><li>拓撲排序</li><li>最短路徑算法: Dijkstra, Bellman-Ford, Floyd Warshall</li><li>連通性相關算法: Kosaraju, Tarjan, 求解孤島的數量, 判斷是否為樹</li><li>圖的著色, 旅行商問題等</li></ul><p>以上的知識點知識圖輪裡的冰山一角, 對於算法面試而言, 完全不需要對每個知識點都一一掌握, 而應該有的放矢的準備</p><h2 class=rich_media_title>必會的知識點</h2><p>以下的知識點必須充分掌握並反覆練習</p><ul class=list-paddingleft-2><li>圖的存儲和表達式: 鄰接矩陣(Adjacency Matrix), 鄰接鏈表(Adjacency List)</li><li>圖的遍歷: 深度優先, 廣度優先</li><li>二部圖的檢測(Bipartite), 數的檢測, 環的檢測, 有向圖, 無向圖</li><li>拓撲排序</li><li>聯合-查找算法(Union-Find)</li><li>最短路徑Dijkstra, BellMan-Ford</li></ul><p>其中, 環的檢測, 二部圖的檢測, 樹的檢測以及拓撲都是基於圖的遍歷, 尤其是深度優先方式的遍歷, 而遍歷可以在鄰接矩陣或者鄰接鏈表上進行, 所以掌握好圖的遍歷是重中之重, 因為它是所有其他圖論算法的基礎</p><p>至於對端路徑算法, 能區分它們的不同特點, 知道在什麼情況下用哪種算法就很好了, 對於有充足時間準備的面試者, 能熟練掌握他們的寫法當然是很好的</p><p>我們來來看看數據結構中的圖到底是什麼</p><h2 class=rich_media_title>1. 圖的定義</h2><p>圖是由一些點(vertex)和這些點之間的連線(edge)所組成的, 其中, 點通常稱為頂點(vertex), 而點到點之間的連線通常稱之為邊或者弧(edge), 通常記為G = (V,E)</p><h2 class=rich_media_title>2. 圖的分類</h2><p>圖通常分為有向圖和無向圖, 而其表示方式分為鄰接矩陣和鄰接鏈表, 具體表示如下圖.</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/74fefae0669c41d18bf5ef60310d81e0><p class=pgc-img-caption></p></div><p>對於無向圖，其所有的邊都不區分方向。G=(V,E)。其中，</p><ol start=1><li>V={1,2,3,4,5}。V表示有”1,2,3,4,5”幾個頂點組成的集合。</li></ol><ol start=2><li>E={(1,2),(1,5),(2,1),(2,5),(2,4),(2,3),(3,2),(3,4),(4,3),(4,2),(4,5),(5,1),(5,2),(5,4)}。E就是表示所有邊組成的集合，如(1,2)表示由頂點1到頂點2連接成的邊。</li></ol><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/857d9440b79346babc088b661e3d73d8><p class=pgc-img-caption></p></div><p>對於有向圖，其所有的邊都是有方向的。G=(V,E)。其中，</p><ol start=1><li>V={1,2,3,4,5}。V表示有”1,2,3,4,5”幾個頂點組成的集合。</li><li>E={&lt;1,2>,&lt;2,5>&lt;5,4>,&lt;4,2>&lt;3,5>,&lt;3,6>,&lt;6,6>}。E就是表示所有邊組成的集合，如&lt;1,2>表示由頂點1到頂點2連接成的邊。注意有向圖邊和無向圖邊表示方法的不同，有向圖的邊是矢量，而無向圖只是普通的括號。</li></ol><ol start=2><li><br></li></ol><p>針對鄰接矩陣和鄰接鏈表兩種不同的表示方式，有如下優缺點：</p><ol start=1><li>鄰接矩陣由於沒有相連的邊也佔據空間，相對於鄰接鏈表，存在空間浪費的問題；</li></ol><ol start=2><li>但是在查找的時候，鄰接鏈表會比較耗時，對於鄰接矩陣來說，它的查找複雜度就是O(1)。</li></ol><p>用鄰接表表示圖的代碼</p><pre><code>#define MAX 100typedef struct ENode   //鄰接表中表對應的鏈表的頂點{   int ivex;          //該邊所指向的頂點的位置   int weight;       //該邊的權值   struct ENode *next_edge;   //指向下一條邊的指針}ENode,*PENode;typedef struct VNode   //鄰接表中表的頂點{   char data;       //頂點的數據   struct VNode *first_edge;  //指向第一條依附該頂點的邊}VNode;typedef struct LGraph  //鄰接表{   int vexnum;    //圖的頂點數   int edgenum;   //圖的邊數   VNode vexs[MAX];}LGraph;</code></pre><h2 class=rich_media_title>3. 度, 權, 連通圖等概念</h2><p>對於無向圖來說，它的頂點的<strong>度</strong>就是指關聯於該頂點的邊的數目；而對於有向圖來說，分為入度和出度，所謂<strong>入度</strong>就是進入該頂點邊的數目，<strong>出度</strong>就是離開這個頂點邊的數目，有向圖的度就是入度加出度。</p><p>圖還被分為有權圖和無權圖，所謂有權圖就是每條邊都具有一定的權重，通常就是邊上的那個數字；而無權圖就是每條邊沒有權重，也可以理解為權重為。如下圖所示即為有權圖，(A,B)的權就是13。</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27f47f03644247cca23c5e2145dec89f><p class=pgc-img-caption></p></div><p>如果一個無向圖中每個頂點到所有其他頂點都是可達的，則稱該圖是連通的；如果一個有向圖中任意兩個頂點互相可達，則該有向圖是強連通的。</p><p>如圖(b)中有3個連通分量：{1,2,5},{3,6},{4}。若一個無向圖只有一個連通分量，則該無向圖連通。</p><p>而圖(a)中有3個強連通分量：{1,2,4,5}，{3}，{6}。{1,2,4,5}中所有頂點對互相可達。而頂點2與6不能相互可達，所以不能構成一個強連通分量。</p><h2 class=rich_media_title>4. 深度優先搜索(Depth First Search DFS)</h2><p>圖的深度優先算法有點類似於樹的前序遍歷，首先圖中的頂點均未被訪問，確定某一頂點，從該頂點出發，依次訪問未被訪問的鄰接點，直到某個鄰接點沒有未被訪問鄰接點時，則回溯父節點（此處我們將先被訪問的節點當做後被訪問節點的父節點，例如對於節點A、B，訪問順序是A ->B，則稱A為B的父節點），找到父節點未被訪問的子節點；如此類推，直到所有的頂點都被訪問到。</p><p>注意，深度優先的存儲方式一般是以棧的方式存儲。</p><ol start=1><li>無向圖的深度優先搜索</li></ol><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a58c1edf7cf34428bac485dc1b95f260><p class=pgc-img-caption></p></div><ol start=2><li>有向圖的深度優先搜索</li></ol><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/68f740f5b3604277b98a5b96464bb21b><p class=pgc-img-caption></p></div><ol start=3><li>深度優先搜索代碼</li></ol><pre><code>static void DFS(LGraph G, int i,int *visited){   Enode *node;E   printf(“%c”,G.vexs[i].data);   node = G.vexs[i].first_edge;   while(node != NULL)  {       if(!visited[node-&gt;ivex])           DFS(G, node-&gt;ivex, visited);  //遞歸調用DFS       node = node-&gt;next_edge;  }}</code></pre><h2 class=rich_media_title>5. 廣度優先搜索</h2><p>從圖中的某個頂點出發，訪問它所有的未被訪問鄰接點，然後分別從這些鄰接點出發訪問它的鄰接點。說白了就是一層一層的訪問，“淺嘗輒止”！</p><p>注意，廣度優先搜索的存儲方式一般是以隊列的方式存儲。</p><ol start=1><li>無向圖的廣度優先搜索</li></ol><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eeff2d1d46af4f98bf4c3a74c71b5f62><p class=pgc-img-caption></p></div><ol start=2><li>有向圖的廣度優先搜索</li></ol><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cb2b5313365f415688ca307ef590cbc1><p class=pgc-img-caption></p></div><ol start=3><li>廣度優先所有代碼</li></ol><pre><code>void BFS(LGraph G){   int head = 0;   int rear = 0;   int queue[MAX];   //輔助隊列   int visited[MAX];   //頂點訪問標記   eNode *node;   for(int i = 0; i &lt; G.vexnum; i++)       visited[i] = 0;  //初始化所有頂點，標記為未訪問   printf(“BFS:”);   for(int i = 0; i &lt; G.vexnum; i++)  {       if(!visited[i])      {           visited[i] = 1;           printf(“%c”,G.vexs[i].data);           queue[rear++] = i;    //入隊      }       while(head != rear)      {           int j = queue[head++];  //出隊           node = G.vexs[j].first_edge;           while(node != NULL)          {               int k = node-&gt;ivex;               if(!visited[k])              {                   visited[k] = 1;                   printf(“%c”,G.vesx[k].data);                   queue[rear++] = k;              }               node = node-&gt;next_edge;          }      }  }   printf(“\n”);}</code></pre><h2 class=rich_media_title>6.拓撲排序</h2><p>拓撲排序（Topological Order）是指講一個有向無環圖（Directed Acyclic Graph,DAG）進行排序而得到一個有序的線性序列。</p><p>舉個例子，例如我們早上起床的穿衣順序，如下圖所示。穿衣的順序也是有個優先級的，有些衣服就必須優先穿上，例如領帶依賴於襯衣，所以領帶最終排在襯衣之後；對圖a中的元素進行合理的排序，就得到了圖b的次序圖。注意，該次序圖不是唯一的。</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7fab3fb6c7374a3abe4334c7ed48932f><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ce4248b799c43c698ee223248f82636><p class=pgc-img-caption></p></div><p><br></p><pre><code>int topological_sort(LGraph G){   int num = G.vexnum;   ENode *node;   int head = 0;     //輔助隊列的頭   int rear = 0;     // 輔助隊列的尾   int *ins = (int *)malloc(num * sizeof(int));       //入度數組   char *tops = (char *)malloc(num * sizeof(char));  //拓撲排序結果數組，記錄每個節點排序後的序號   int *queue = (int *)malloc(num * sizeof(int));     //輔助隊列   assert(ins != NULL &amp;&amp; tops != NULL &amp;&amp; queue != NULL)   memset(ins, 0, num * sizeof(int));   memset(tops, 0, num * sizeof(char));   memset(queue, 0, num * sizeof(int));   for(int i = 0; i &lt; num; i ++)   //統計每個頂點的入度數  {       node = G.vexs[i].first_edge;       while(node != NULL)      {           ins[node-&gt;ivex]++;           node = node-&gt;next_edge;      }  }   for(int i = 0; i &lt; num; i++)   //將所有入度為0的頂點裝入隊列       if(ins[i] == 0)           queue[rear++] = i;   while(head != rear)     //隊列非空  {       int j = queue[head++];           //出隊列，j為頂點的序號       tops[index++] = G.vexs[j].data;    //將該頂點添加到tops中，tops是排序結果       node = G.vexs[j].first_edge;       //獲取以該頂點為起點的出邊隊列       while(node != NULL)      {           ins[node-&gt;ivex]--;    //將節點node關聯的節點的入度減1           if(ins[node-&gt;ivex] == 0)   //若節點的入度為0，則將其添加到隊列中               queue[rear++] = node-&gt;ivex;           node = node-&gt;next_edge;      }  }   if(index != G.vexnum)  {       printf(“Graph has a cycle!\n”);       free(queue);       free(ins);       free(tops);       return 1;  //1表示失敗，該有向圖是有環的  }   printf(“== TopSort: ”);   //打印拓撲排序結果   for(int i = 0; i &lt; num; i++)       printf(“%c”,top[i]);   printf(“\n”);   free(queue);   free(ins);   free(tops);   return 0;}</code></pre><h2 class=rich_media_title>7. 最小生成樹</h2><p>所謂最小生成樹就是將圖中的頂點全部連接起來，此時這個邊的權重最小，並且連接起來的是一個無環的樹。很容易知道，若此時的頂點是n，則邊的數量為n-1。所以在一個圖中找最小生成樹就是找最小權值的邊，讓這些邊連成一棵樹。常用的算法有Prim算法和Kruskal算法。</p><h3 class=rich_media_title>7. 1Prim算法</h3><p>該算法就是每次迭代選擇權值最小的邊對應的點，加入到最小生成樹中。具體實現如下所示。</p><p>第一步：選取頂點A，此時U={A}，V-U={B,C,D,E,F,G}。</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04b18a094db64dcf82422f39586e09cf><p class=pgc-img-caption></p></div><p>第二步：選取與A點連接的權值最小的邊，此時就會選擇到B，U={A,B}，V-U={C,D,E,F,G}。</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9abd4b3c2fe4caba7244dcba53ac28b><p class=pgc-img-caption></p></div><p>以上面的步驟類推，得到如上圖所示的結果，此時U={A,B,C,D,E,F}，V-U={G}。注意到C是此次加入的點，而G沒有加入，此時G點的邊應該如何選擇？</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6dd079c0a6494189928ab6ad4adee6f2><p class=pgc-img-caption></p></div><p>最終，得到如圖所示的最小生成樹，此時U={A,B,C,D,E,F,G}，V-U={}。</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/accd52a2eaed4495b4b98252ff50202d><p class=pgc-img-caption></p></div><p><br></p><pre><code>#define INF (~(0x1&lt;&lt;31))  //最大值(即0X7FFFFFFF)//返回ch在鄰接表中的位置static int get_position(LGraph G, char ch){   for(int i = 0; i &lt; G.vexnum; i++)       if(G.vexnum[i].data == ch)           return i;   return -1;  }   //獲取G中邊&lt;start,end&gt;的權值；若start到end不連通，則返回無窮大   int getWeight(LGraph G, int start, int end)  {       ENode *node;       if(start == end)           return 0;       node = G.vexs[start].first_edge;       while(node != NULL)      {           if(end == node-&gt;ivex)               return node-&gt;weight;       node = node-&gt;next_edge;      }       return INF;  }   void Prim(LGraph G,int start)  //從圖中的第start個元素開始，生成最小樹  {       int index = 0;    //prim最小樹的索引，即prims數組的索引       char prims[MAX];  //prim最小樹的結果數組       int wights[MAX];   //頂點間邊的權重       //prim最小生成樹中第一個數，即圖中的第start個數       prims[index++] = G.vexs[start].data;       for(int i = 0; i &lt; G.vexnum; i++)  //初始化頂點的權值數組           weights[i] = getWeight(G, start, i); //將每個頂點的權值初始化為“第start個頂點”到“該頂點”的權值       for(int i = 0; i &lt; G.vexnum; i++)      {           if(start == i)   //由於從start開始，因此不需要再對第start個頂點進行處理               continue;           int j = 0;           int k = 0;           int min = INF;           //在未被加入到最小生成樹的頂點中，找出權值最小的頂點           while(j &lt; G.vexnum)          {               //若weights[j]=0，則說明該節點已經加入了最小生成樹               if(weights[j] != 0 &amp;&amp; weights[j] &lt; min)              {                   min = weights[j];                   k = j;              }               j++;          }           //經過上面的處理後，在未被加入到最小生成樹的頂點中，權值最小的頂點是第k個頂點。           //將第k個頂點加入最小生成樹的結果數組中           prims[index++] = G.cexs[k].data;           //將第k個頂點的權值標記為0，表示該頂點已經加入了最小生成樹           weights[k] = 0;           //當第k個頂點被加入到最小生成樹的結果數組後，更新其他頂點的權值           for(int j = 0; j &lt; G.vexnum; j++)          {               //獲取第k個頂點到第j個頂點的權值               int temp = getWeight(G, k, j);               //當第j個節點沒有被處理，並且需要更新的時候才會更新               if(weights[j] != 0 &amp;&amp; temp &lt; weights[j])                   weights[j] = temp;          }  }   //計算最小生成樹的權值   int sum = 0;   for(int i = 0; i &lt; index; i++)  {       min = INF;       //獲取prims[i]在G中的位置       int n = get_position(G, prims[i]);       //在vexs[0...i]中，找出到j的權值最小的頂點。       for(int j = 0; j &lt; i; j++)      {          int m = get_position(G,prims[j]);          int temp = getWeight(G, m, n);          if(temp &lt; min)              min = temp;      }       sum += min;  }   //打印最小生成樹   printf(“Prim(%c) = %d : ”, G.vexs[start].data, sum);   for(int i = 0; i &lt; index; i++)       printf(“%c ”,prim[i]);   printf(“\n”);}</code></pre><h3 class=rich_media_title>7.2 Kruskal算法</h3><p>該算法的核心就是對權值進行排序，然後從最小的權值開始，不斷增大權值，如何該權值的所在邊的兩個頂點沒有存在的路徑連在一起，則加入這條邊，否則，則捨棄這條邊，知道所有的點都在這顆樹中。</p><p>如下所示的一個圖，我們從中找出最小生成樹。</p><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/22d610dd8805433d945ab634fb2f0b06><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=數據結構--圖 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/acfe09575aaf4d9fb42aab7a82435f50><p class=pgc-img-caption></p></div><p>對於左邊所示的圖，對各個邊的權值排序之後，我們最先找到權值最小的邊，即AD。然後我們發現還有一個CE，於是CE也會被標記起來。</p><p>對於左邊所示的圖，對各個邊的權值排序之後，我們最先找到權值最小的邊，即AD。然後我們發現還有一個CE，於是CE也會被標記起來。</p><pre><code>typedef struct edata  //邊的結構體{   char start;  //邊的起點   char end;   //邊的終點   int weight;  //邊的權重}EData;EData *get_edges(LGraph G){   int index = 0;   ENode *node;   EData *edges;   edges = (EData *)malloc(G.edgnum * sizeof(EData));   for(int i = 0; i &lt; G.vexnum; i++)  {       node = G.vexs[i].first_edge;       while(node != NULL)      {           if(node-&gt;ivex &gt; i)          {               edges[index].start = G.vexs[i].data;               edges[index].end = G.vexs[node-&gt;ivex].data;               edges[index].weight = node-&gt;weight;               index++;          }           node = node-&gt;next_edge;      }  }   return edges;}void Kruskal(LGraph G){   int index = 0;     //rets數組的索引   int vends[MAX] = {0};    //用於保存“已有最小生成樹”中每個頂點在該最小樹中的終點   EData rets[MAX];    //結果數組，保存kruskal最小生成樹的邊   EData *edges;     //圖對應的所有邊   edges = get_edges(G);   //獲取圖中所有的邊   Sorted_edges(edges, G.edgenum);   //對邊按照權值進行排序   for(int i = 0; i &lt; G.edgenum; i++)  {       int numOfStart = get_position(G, edges[i].start);  //獲取第i條邊的起點的序號       int numOfEnd = get_position(G, edges[i].end);    //獲取第i條邊的終點的序號       int m = get_end(vends, numOfStart);  //獲取numOfStart在“已有的最小生成樹”中的終點       int n = get_end(vends, numOfEnd);    //獲取numOfEnd在“已有的最小生成樹”中的終點       //如果m!=n，表示邊i與已經添加到最小生成樹中的頂點沒有形成環路       if(m != n)      {           vends[m] = n;    //設置m在已有的最小生成樹中的終點為n           rets[index++] = edges[i];   //保存結果      }  }   free(edges);   //統計並打印最小生成樹的信息   int length = 0;   for(int i = 0; i &lt; index; i++)       length += rets[i].weight;   printf(“Kruskal = %d : ”,length);   for(int i = 0; i &lt; index; i++)       printf(“(%c,%c)”, rets[i].start, rets[i].end);   printf(“\n”);}</code></pre><h2 class=rich_media_title>例題分析</h2><p>785. 判斷二分圖</p><p>給定一個無向圖graph，當這個圖為二分圖時返回true。</p><p>如果我們能將一個圖的節點集合分割成兩個獨立的子集A和B，並使圖中的每一條邊的兩個節點一個來自A集合，一個來自B集合，我們就將這個圖稱為二分圖。</p><p>graph將會以鄰接表方式給出，graph[i]表示圖中與節點i相連的所有節點。每個節點都是一個在0到graph.length-1之間的整數。這圖中沒有自環和平行邊：graph[i] 中不存在i，並且graph[i]中沒有重複的值。</p><pre><code>示例 1:輸入: [[1,3], [0,2], [1,3], [0,2]]輸出: true解釋:無向圖如下:0----1|   ||   |3----2我們可以將節點分成兩組: {0, 2} 和 {1, 3}。</code></pre><pre><code>示例 2:輸入: [[1,2,3], [0,2], [0,1,3], [0,2]]輸出: false解釋:無向圖如下:0----1| \ || \ |3----2我們不能將節點分割成兩個獨立的子集。</code></pre><p>好了, 自己研究了半天, 題都沒有研究明白,我決定放棄了, 要是哪個大佬知道, 快來教教我吧, 我們今天把樹是個什麼東西就好了!</p><p><br></p><p>graph 的長度範圍為 [1, 100]。graph[i] 中的元素的範圍為 [0, graph.length - 1]。graph[i] 不會包含 i 或者有重複的值。圖是無向的: 如果j 在 graph[i]裡邊, 那麼 i 也會在 graph[j]裡邊。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>--</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>