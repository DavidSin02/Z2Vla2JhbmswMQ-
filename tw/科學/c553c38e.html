<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 | 极客快訊</title><meta property="og:title" content="算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/153813499336220138bde4e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/c553c38e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/c553c38e.html><meta property="article:published_time" content="2020-11-14T20:53:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:56+08:00"><meta name=Keywords content><meta name=description content="算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/c553c38e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div><p>如下圖（左）所求，有若干個頂點需要全部連通，兩個頂點之間的連通都有一定的權值（邊值），如何連接可以使其邊值求各達到最小？</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153813499336220138bde4e><p class=pgc-img-caption></p></div><p>這其實就是一個構造最小生成樹的問題。</p><h1><strong>1 構造最小生成樹的Kruskal算法</strong></h1><p>設G=（V，E）是無向連通帶權圖，V={1，2，…，n}，表示頂點，E表示邊集；</p><p>設最小生成樹T=（V，TE），該樹的初始狀態為只有n個頂點而無邊的非連通圖T=（V，{}），基中V表示頂點，TE表示最小生成樹的邊集。Kruskal算法將這n個頂點看成是n個孤立的連通分支。它首先將所有的邊按權值從小到大排序，然後只要 T 中選中的邊數不到n−1，就做如下的貪心選擇：</p><p>在邊集E中選取權值最小的邊（i，j），其中i、j表示邊的頂點序號，如果將邊（i，j）加入邊集TE中不產生迴路（圈），則將邊（i，j）加入邊集TE中，即用邊（i，j）將這兩個連通分支合併連接成一個連通分支；否則繼續選擇下一條最短邊。把邊（i，j）從集合E中刪去。繼續上面的貪心選擇，直到T中所有頂點都在同一個連通分支上為止。此時，選取到的n−1條邊恰好構成G的一棵最小生成樹T。</p><p>那麼，怎樣判斷加入某條邊後圖T會不會出現迴路呢？</p><p>該算法對於手工計算十分方便，因為用肉眼可以很容易看到挑選哪些邊能夠避免構成迴路（避圈法），但使用計算機程序來實現時，還需要一種機制來進行判斷。Kruskal算法用了一個非常聰明的方法，就是運用集合避圈：如果所選擇加入的邊的起點和終點都在最小生成樹T的集合中，那麼就可以斷定一定會形成迴路（圈）。其實就是我們前面提到的“避圈法”：邊的兩個結點不能屬於同一集合。</p><p>算法步驟：</p><p>① 初始化。將圖G的邊集E中的所有邊按權值從小到大排序，邊集TE={ }，把每個頂點都初始化為一個孤立的分支，即一個頂點對應一個集合。</p><p>② 在E中尋找權值最小的邊（i，j）。</p><p>③ 如果頂點 i 和 j 位於兩個不同連通分支，則將邊（i，j）加入邊集TE，並執行合併操作，將兩個連通分支進行合併（序號→集合號、讓集合號取相同值）。</p><p>④ 將邊（i，j）從集合E中刪去，即E=E−{（i，j）}。</p><p>⑤ 如果選取邊數小於n−1，轉②；否則，算法結束，生成最小生成樹T。</p><h1><strong>2 完美圖解</strong></h1><p>設G =（V，E）是無向連通帶權圖，如圖98所示。</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153784868605192e1231b7a><p class=pgc-img-caption></p></div><p>（1）初始化</p><p>將圖G的邊集E中的所有邊按權值從小到大排序，如圖2-99所示。</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378487155497ff3daa238><p class=pgc-img-caption></p></div><p>邊集初始化為空集，TE={ }，把每個結點都初始化為一個孤立的分支，即一個頂點對應一個集合，集合號為該結點的序號，如圖2-100所示↑。</p><p>（2）找最小</p><p>在E中尋找權值最小的邊e1（2，7），邊值為1。</p><p>（3）合併</p><p>結點2和結點7的集合號（頂點序號）不同，即屬於兩個不同連通分支，則將邊（2，7）加入邊集TE，執行合併操作（將兩個連通分支所有結點合併為一個集合）；假設把小的集合號賦值給大的集合號，那麼7號結點的集合號也改為2，如圖2-101所示。</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378619935077e379f4057><p class=pgc-img-caption></p></div><p>（4）找最小</p><p>在E中尋找權值最小的邊e2（4，5），邊值為3。</p><p>（5）合併</p><p>結點4和結點5集合號不同，即屬於兩個不同連通分支，則將邊（4，5）加入邊集TE，執行合併操作將兩個連通分支所有結點合併為一個集合；假設我們把小的集合號賦值給大的集合號，那麼5號結點的集合號也改為4，如圖2-102所示↑。</p><p>（6）找最小</p><p>在E中尋找權值最小的邊e3（3，7），邊值為4。</p><p>（7）合併</p><p>結點3和結點7集合號不同，即屬於兩個不同連通分支，則將邊（3，7）加入邊集TE，執行合併操作將兩個連通分支所有結點合併為一個集合；假設我們把小的集合號賦值給大的集合號，那麼3號結點的集合號也改為2，如圖2-103所示。</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1537848892670be1d75de3b><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15378620845318939bef9c1><p class=pgc-img-caption></p></div><p>（8）找最小</p><p>在E中尋找權值最小的邊e4（4，7），邊值為9。</p><p>（9）合併</p><p>結點4和結點7集合號不同，即屬於兩個不同連通分支，則將邊（4，7）加入邊集TE，執行合併操作將兩個連通分支所有結點合併為一個集合；假設我們把小的集合號賦值給大的集合號，那麼4、5號結點的集合號都改為2，如圖2-104所示↑。</p><p>（10）找最小</p><p>在E中尋找權值最小的邊e5（3，4），邊值為15。</p><p>（11）合併</p><p>結點3和結點4集合號相同，屬於同一連通分支，不能選擇，否則會形成迴路。</p><p>（12）找最小</p><p>在E中尋找權值最小的邊e6（5，7），邊值為16。</p><p>（13）合併</p><p>結點5和結點7集合號相同，屬於同一連通分支，不能選擇，否則會形成迴路。</p><p>（14）找最小</p><p>在E中尋找權值最小的邊e7（5，6），邊值為17。</p><p>（15）合併</p><p>結點5和結點6集合號不同，即屬於兩個不同連通分支，則將邊（5，6）加入邊集TE，執行合併操作將兩個連通分支所有結點合併為一個集合；假設我們把小的集合號賦值給大的集合號，那麼6號結點的集合號都改為2，如圖2-105所示。</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378490178792735dfcd91><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15378621230693c1c20dafb><p class=pgc-img-caption></p></div><p>（16）找最小</p><p>在E中尋找權值最小的邊e8（2，3），邊值為20。</p><p>（17）合併</p><p>結點2和結點3集合號相同，屬於同一連通分支，不能選擇，否則會形成迴路。</p><p>（18）找最小</p><p>在E中尋找權值最小的邊e9（1，2），邊值為23。</p><p>（19）合併</p><p>結點1和結點2集合號不同，即屬於兩個不同連通分支，則將邊（1，2）加入邊集TE，執行合併操作將兩個連通分支所有結點合併為一個集合；假設我們把小的集合號賦值給大的集合號，那麼2、3、4、5、6、7號結點的集合號都改為1，如圖2-106所示↑。</p><p>（20）選中的各邊和所有的頂點就是最小生成樹，各邊權值之和就是最小生成樹的代價。</p><p>從上圖可以看到，所有連通的圖都只有一個相同的集合號，以此做為判斷標準，避免構成迴路。</p><h1><strong>3 代碼</strong></h1><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153786399083961960937aa><p class=pgc-img-caption></p></div><pre>輸入結點數n和邊數m：7 12輸入結點序號u、v和邊值w：1 2 231 6 281 7 362 3 202 7 13 4 153 7 44 5 34 7 95 6 175 7 166 7 25</pre><p>輸出</p><pre>輸出排序後的結點序號u、v和邊值w：2 - 7：14 - 5：33 - 7：44 - 7：93 - 4：155 - 7：165 - 6：172 - 3：201 - 2：236 - 7：251 - 6：281 - 7：36選中的各邊的兩個結點序號和其邊值：2 - 7：14 - 5：33 - 7：44 - 7：95 - 6：171 - 2：23點連通成樹後邊值求和後的最小值：57</pre><h1><strong>4 算法複雜度分析</strong></h1><p>（1）時間複雜度：算法中，需要對邊進行排序，若使用快速排序，執行次數為e*loge，算法的時間複雜度為O(e*loge)。而合併集合需要n−1次合併，每次為O(n)，合併集合的時間複雜度為O(n2)。</p><p>（2）空間複雜度：算法所需要的輔助空間包含集合號數組 nodeset[n]，則算法的空間複雜度是O(n)。</p><h1><strong>5 算法優化拓展</strong></h1><p>該算法合併集合的時間複雜度為O(n2)，我們可以用並查集的思想優化，使合併集合的時間複雜度降為O(e*logn)，優化後的程序做如下修改：</p><div class=pgc-img><img alt=算法｜構造最小生成樹（全部點連通邊值求和最小）的Kruskal算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1537865990116b26b0fe12d><p class=pgc-img-caption></p></div><h1><strong>6 Kruskal算法與Prim算法的比較</strong></h1><p>（1）從算法的思想可以看出，如果圖G中的邊數較小時，可以採用Kruskal算法，因為Kruskal算法每次查找最短的邊；邊數較多可以用Prim算法，因為它是每次加一個結點。可見，Kruskal算法適用於稀疏圖，而Prim算法適用於稠密圖。</p><p>（2）從時間上講，Prim算法的時間複雜度為O(n2)，Kruskal算法的時間複雜度為O(eloge)。</p><p>（3）從空間上講，顯然在Prim算法中，只需要很小的空間就可以完成算法，因為每一次都是從V−U集合出發進行掃描的，只掃描與當前結點集到U集合的最小邊。但在Kruskal算法中，需要對所有的邊進行排序，對於大型圖而言，Kruskal算法需要佔用比Prim算法大得多的空間。</p><p>附代碼1</p><pre>#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int N = 100;	// ① 數據結構int nodeset[N];				//集合號（頂點序號）數組int n, m;struct Edge {				//邊的存儲結構(兩個頂點和一個權值)	int u;	int v;	int w;}e[N*N];	// ② 初始化void Init(int n){	for(int i = 1; i &lt;= n; i++)		nodeset[i] = i;		//每個結點賦值一個集合號（頂點序號）}	// ③ 定義優先級，按邊值進行升序排序bool comp(Edge x, Edge y){	return x.w &lt; y.w;		}	// ④ 合併集合int Merge(int a, int b){ int p = nodeset[a];	//p為a結點的集合號（頂點序號） int q = nodeset[b];	//q為b結點的集合號（頂點序號） if(p==q) 		 return 0;			//集合號相同，什麼也不做，返回 for(int i=1;i&lt;=n;i++)	//檢查所有結點，把集合號是q的全部改為p { if(nodeset[i]==q) nodeset[i] = p;	//a的集合號賦值給b集合號 } return 1;}int Kruskal(int n){	int ans = 0;	for(int i=0;i&lt;m;i++)		if(Merge(e[i].u, e[i].v)) //如果執行了合併		{			ans += e[i].w;			n--;			cout&lt;&lt;e[i].u&lt;&lt;" - "&lt;&lt;e[i].v&lt;&lt;"："&lt;&lt;e[i].w&lt;&lt;endl;			if(n==1)				return ans;		}		return 0;}int main(){	cout &lt;&lt;"輸入結點數n和邊數m："&lt;&lt;endl;	cin &gt;&gt; n &gt;&gt; m;	Init(n);	cout &lt;&lt;"輸入結點序號u、v和邊值w："&lt;&lt;endl;	for(int i=0;i&lt;m;i++)		cin &gt;&gt; e[i].u&gt;&gt; e[i].v &gt;&gt;e[i].w;	sort(e, e+m, comp);		//三個參數：待排序數組的首地址、尾地址，排序方式	cout &lt;&lt;"輸出排序後的結點序號u、v和邊值w："&lt;&lt;endl;	for(int j=0;j&lt;m;j++)		cout&lt;&lt;e[j].u&lt;&lt;" - "&lt;&lt;e[j].v&lt;&lt;"："&lt;&lt;e[j].w&lt;&lt;endl;	cout&lt;&lt;"選中的各邊的兩個結點序號和其邊值："&lt;&lt;endl;	int ans = Kruskal(n);	cout &lt;&lt; "點連通成樹後邊值求和後的最小值：" &lt;&lt; ans &lt;&lt; endl;	system("pause");	return 0;}</pre><p>附代碼2</p><pre>int Find(int x)				//找祖宗{	if(x != nodeset[x])		nodeset[x] = Find(nodeset[x]);//把當前結點到其祖宗路徑上的所有結點的集合號改為祖宗集合號	return nodeset[x];		//返回其祖宗的集合號}int Merge(int a, int b)		//兩結點合併集合號{	int p = Find(a);		//找a的集合號	int q = Find(b);		//找b的集合號	if(p==q) return 0;	if(p &gt; q)		nodeset[p] = q;		//小的集合號賦值給大的集合號	else		nodeset[q] = p;	return 1;}</pre><p>－End－</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>算法</a></li><li><a>最小</a></li><li><a>構造</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a06ff55.html alt=區塊鏈上的隨機性：概述與構造 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RJjGCjxAt6MQlC style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a06ff55.html title=區塊鏈上的隨機性：概述與構造>區塊鏈上的隨機性：概述與構造</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51a9663e.html alt=橫滑式單元幕牆防水構造典型誤區分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31a722f1541d41fa9475a525a782a0a7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51a9663e.html title=橫滑式單元幕牆防水構造典型誤區分析>橫滑式單元幕牆防水構造典型誤區分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd2e41b9.html alt=二、地球運行的方式-3(板塊構造) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4785b7af93d249b0972f939f77351e73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd2e41b9.html title=二、地球運行的方式-3(板塊構造)>二、地球運行的方式-3(板塊構造)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/416cd00d.html alt=地球構造板塊開始移動的時間比以前認為的更早 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ff9ade37cba4a7e9239926d89584046 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/416cd00d.html title=地球構造板塊開始移動的時間比以前認為的更早>地球構造板塊開始移動的時間比以前認為的更早</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html alt=七大查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38aea254.html title=七大查找算法>七大查找算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html alt=掌握算法-散列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html title=掌握算法-散列>掌握算法-散列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c2deaa5.html alt=原子熒光光譜儀的構造原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47572eecf684fc79c8ea400d9985f61 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c2deaa5.html title=原子熒光光譜儀的構造原理>原子熒光光譜儀的構造原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a5783a2.html alt=史上最全圖解汽車構造與原理系列（九）活塞連桿組圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/37d7000172f8074b6abc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a5783a2.html title=史上最全圖解汽車構造與原理系列（九）活塞連桿組圖解>史上最全圖解汽車構造與原理系列（九）活塞連桿組圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f6aa19dd.html alt=汽車發動機構造---曲柄連桿機構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c8524852e5654ae1b3e82b4df617e501 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f6aa19dd.html title=汽車發動機構造---曲柄連桿機構>汽車發動機構造---曲柄連桿機構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/70bde363.html alt=圖文解剖剎車構造原理——解讀制動系統剎車的歷史及未來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3d92b7bc5ee44899939efd4f8f9ddf60 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/70bde363.html title=圖文解剖剎車構造原理——解讀制動系統剎車的歷史及未來>圖文解剖剎車構造原理——解讀制動系統剎車的歷史及未來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html alt=C#算法系列（1）——二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html title=C#算法系列（1）——二叉樹>C#算法系列（1）——二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html alt=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9b2026e861ad49e88e1e124dc67edb32 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html title=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）>算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html alt=算法題—完全二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ef7d8ad6eaca4524a71e1e5d1277532b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html title=算法題—完全二叉樹>算法題—完全二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac10be18.html alt=語方的最小單位是詞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/509c0003d0b794c324a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac10be18.html title=語方的最小單位是詞>語方的最小單位是詞</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>