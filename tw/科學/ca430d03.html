<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux高性能服務器編程之高級I/O函數詳解（含實例代碼） | 极客快訊</title><meta property="og:title" content="Linux高性能服務器編程之高級I/O函數詳解（含實例代碼） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/a2cc0f57fdec4d4bae7110590a705e39"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/ca430d03.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ca430d03.html><meta property="article:published_time" content="2020-10-29T21:13:10+08:00"><meta property="article:modified_time" content="2020-10-29T21:13:10+08:00"><meta name=Keywords content><meta name=description content="Linux高性能服務器編程之高級I/O函數詳解（含實例代碼）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/ca430d03.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux高性能服務器編程之高級I/O函數詳解（含實例代碼）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><p><strong>一、重定向dup和dup2函數</strong></p><pre><code>#include &lt;unistd.h&gt;int dup(int file_descriptor);int dup2(int file_descriptor_one, int file_descriptor_two);</code></pre><ul><li>dup創建一個新的文件描述符， 此描述符和原有的file_descriptor指向相同的文件、管道或者網絡連接。</li><li>dup返回的文件描述符總是取系統當前可用的最小整數值。</li></ul><p>dup2函數通過使用參數file_descriptor_two指定新描述符數值，如果file_descriptor_two已經打開，則先關閉。若file_descriptor_one = file_descriptor_two，而不關閉。</p><p>兩者調用失敗均返回-1, 並設置errno。</p><pre><code>//利用dup模擬實現一個基本的CGI服務器#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;netinet/in.h&gt;#include &lt;assert.h&gt; int main(int argc, char **argv){	if (argc ！= 3) {	     fprintf(stderr, "Usage: %s id port\n", basename(argv[0]));	     return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]);		struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr);		int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);		int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1);		ret = listen(sock, 5);	assert(ret != -1);		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);	int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if (connfd &lt; 0) {		printf("error: %s\n", strerror(errno));	}	else {		close(STDOUT_FILENO); //關閉標準輸出		dup(connfd);          //重定向1到connfd，這樣服務器的標準輸出內容會直接發送到客戶端socket，這就是CGI的基本原理				printf("abc. close stdout_fileno test... dup to client\n"); //printf會直接輸出會發送到客戶端				close(connfd);	}		close(sock);		return 0;}</code></pre><p><strong>注：需要C/C++ Linux高級服務器架構師學習資料私信“資料”（資料包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等），免費分享</strong></p><div class=pgc-img><img alt=Linux高性能服務器編程之高級I/O函數詳解（含實例代碼） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a2cc0f57fdec4d4bae7110590a705e39><p class=pgc-img-caption></p></div><p><strong>二、分散讀readv和集中寫writev函數</strong></p><p>readv將數據從文件描述符讀到分散的內存塊中，即分散讀。</p><p>writev將多塊分散的內存一併寫入文件描述符中，即集中寫。</p><pre><code>#include &lt;sys/uio.h&gt;ssize_t readv(int fd, const struct iovec *vector, int count);ssize_t writev(int fd, const struct iovec *vector, int count);</code></pre><p>fd參數是被操作的文件描述符。</p><p>vector參數是iovec結構體：</p><pre><code>#include &lt;sys/uio.h&gt;struct iovec{    void *iov_base;  //指向一個緩衝區，這個緩衝區是存放readv所接收的數據或是writev將要發送的數據    size_t iov_len;  //接收的長度以及實際寫入的長度};</code></pre><p>count參數是vector數組的長度，即有多少塊內存數據需要從fd讀出或寫到fd。</p><p>兩者調用成功是返回讀出/寫入fd的字節數，失敗返回-1,並設置errno。類似於簡化版的recvmsg和sendmsg。</p><p>以下簡陋的模擬WEB服務器，採用集中寫的方式。省略了HTTP請求的接收及解析， 直接將目標文件作為第3個參數傳遞給服務端程序，客戶端telnet到服務端即可獲得該文件。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;unistd.h&gt;#include &lt;assert.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;errno.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;fcntl.h&gt; #define BUFFER_SIZE 1024 //定義兩種HTTP狀態碼和狀態信息static const char *status_line[2] = {"200 OK", "500 Internal server error"};  int main(int argc, char **argv){	if(argc != 4) {		fprintf(stderr, "Usage: %s ip port filename\n", basename(argv[0]));		return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]);	const char *file_name = argv[3];    //將目標文件作為程序的第三個參數傳入		struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr);		int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);	printf("create socket success\n");		int reuse = 1;	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse));		int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1);	fprintf(stderr, "bind address success\n");		ret = listen(sock, 5);	assert(ret != -1);	fprintf(stderr, "listen success\n");		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);		fprintf(stderr, "start accept...\n");		int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if(connfd &lt; 0) {		printf("error: %s\n", strerror(errno));	}	else {		char header_buf[BUFFER_SIZE];             //用於保存HTTP應答的狀態行、頭部字段和一個空的緩衝區		memset(header_buf, '\0', BUFFER_SIZE);				char *file_buf = NULL;                    //用於存放目標文件內容的緩存		struct stat file_stat;                    //用於獲取目標文件的屬性		bool valid = true;                        //目標文件是否有效		int len = 0;                              //記錄header_buf當前已使用的字節空間				if(stat(file_name, &amp;file_stat) &lt; 0) {     //目標文件不存在			valid = false;		}		else {			if(S_ISDIR(file_stat.st_mode)) {  //目標文件是目錄				valid = false;			}			else if (file_stat.st_mode &amp; S_IROTH) {               //當前用戶是否有讀權限，相對於目標文件				int fd = open(file_name, O_RDONLY);				file_buf = new char[file_stat.st_size + 1];				memset(file_buf, '\0', file_stat.st_size + 1);								fprintf(stderr, "reading %s file...", file_name);								if (read(fd, file_buf, file_stat.st_size) &lt; 0) {						valid = false;				}			}			else {				valid = false;			}		}		 		if (valid) {   //目標文件有效				ret = snprintf(header_buf, BUFFER_SIZE-1,								"%s %s\r\n",								"HTTP/1.1", status_line[0]);												len += ret;				ret = snprintf(header_buf+len, BUFFER_SIZE-1-len,								"content-Length: %ld\r\n",								file_stat.st_size);												len += ret;				ret = snprintf(header_buf+len, BUFFER_SIZE-1-len,								"%s", "\r\n");				                                //將header_buf和file_buf的內容一併寫出								struct iovec iv[2];				iv[0].iov_base = header_buf;				iv[0].iov_len = strlen(header_buf);				iv[1].iov_base = file_buf;				iv[1].iov_len = file_stat.st_size;								fprintf(stderr, "read %s success\nsending %s file to client...\n", file_name, file_name);								ret = writev(connfd, iv, 2);   //集中寫						}		else {     //目標文件無效			ret = snprintf(header_buf, BUFFER_SIZE-1,							"%s %s\r\n",							"HTTP/1.1", status_line[1]);						len += ret;			ret = snprintf(header_buf+len, BUFFER_SIZE-1-len,							"%s", "\r\n");						fprintf(stderr, "read %s failed\nsending error message to client...\n", file_name);							send(connfd, header_buf, strlen(header_buf), 0);		}				close(connfd);				if (file_buf != NULL) {			delete[] file_buf;			file_buf = NULL;		}	}		close(sock);			return 0;}</code></pre><p><strong>三、sendfile函數</strong></p><p>sendfile在兩個文件描術符之間直接傳遞數據，完全在內核中操作，從而避免了內核緩衝區到用戶緩衝區的拷貝，因此效率很高，稱為零拷貝。</p><pre><code>#include &lt;sys/sendfile.h&gt;ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count);</code></pre><p>out_fd參數是待寫入內容的文件描述符。</p><p>in_fd參數是待讀出內容的文件描述符。</p><p>offset參數指定從讀入文件流的哪個位置開始讀，如果為空，則從文件流的默認起始位置讀入。</p><p>count參數指定傳輸的字節數。</p><p>調用成功時返回傳輸的字節數，失敗則為-1，並設置errno</p><p>注： man手冊指出，in_fd必須是一個支持類似mmap函數的文件描述符，即它必須指向真實的文件，不能是socket和管道；而out_fd必須是一個socket。可見，sendfile專為網絡傳輸文件而生。</p><pre><code>//用sendfile函數傳輸文件#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/sendfile.h&gt;#include &lt;fcntl.h&gt;  int main(int argc, char **argv){	if (argc &lt;= 3) {		fprintf(stderr, "Usage: %s ip port filename\n", basename(argv[0]));		return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]);	const char *file_name = argv[3];		int filefd = open(file_name, O_RDONLY);	assert(filefd &gt; 0);		struct stat stat_buf;	fstat(filefd, &amp;stat_buf);		struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr);		int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);		int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1);		ret = listen(sock, 5);	assert(ret != -1);		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);		int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if (connfd &lt; 0) {		fprintf(stderr, "errno is: %s\n", strerror(errno));	}	else {		sendfile(connfd, filefd, NULL, stat_buf.st_size);		close(connfd);	}		close(sock);			return 0;}</code></pre><p><strong>splice函數</strong></p><p>splice用於在兩個文件描述符之間移動數據， 也是零拷貝。</p><pre><code>#include &lt;fcntl.h&gt;ssize_t splice(int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len, unsigned int flags);</code></pre><p>fd_in參數是待輸入描述符。如果它是一個管道文件描述符，則off_in必須設置為NULL；否則off_in表示從輸入數據流的何處開始讀取，此時若為NULL，則從輸入數據流的當前偏移位置讀入。</p><p>fd_out/off_out與上述相同，不過是用於輸出。</p><p>len參數指定移動數據的長度。</p><p>flags參數則控制數據如何移動：</p><ul><li>SPLICE_F_NONBLOCK：非阻塞的splice 操作，但實際效果還會受文件描述符本身的阻塞狀態的影響。</li><li>SPLICE_F_MORE：給內核一個提示：後續的 splice 系統調用將會有更多的數據傳。</li><li>SPLICE_F_MOVE：如果合適的話，按整頁內存移動數據。這只是給內核的一個提示。不過，因為它的實現存在BUG，所以自內核2.6.21後，它實際上沒有任何效果。</li></ul><p>注意：使用splice時， fd_in和fd_out中必須至少有一個是管道文件描述符。</p><p>調用成功時返回移動的字節數量；它可能返回0,表示沒有數據需要移動，這通常發生在從管道中讀數據時而該管道沒有被寫入的時候。</p><p>失敗時返回-1，並設置errno。</p><p style=text-align:center>splice函數可能產生的errno及其含義</p><div class=pgc-img><img alt=Linux高性能服務器編程之高級I/O函數詳解（含實例代碼） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5cb636f55ca24d9ebd51fc59329a6fce><p class=pgc-img-caption></p></div><p>下面代碼：通過splice將客戶端的內容讀入到管道中， 再從管道中讀出到客戶端，從而實現高效簡單的回顯服務。整個過程未執行recv/send，因此也未涉及用戶空間到內核空間的數據拷貝。</p><pre><code>//使用splice實現的回顯服務器#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;fcntl.h&gt;  int main(int argc, char **argv){ 	if (argc &lt;= 2) {		printf("usage: %s ip port\n", basename(argv[0]));		return 1;	}		const char *ip = argv[1];	int port = atoi(argv[2]); 	struct sockaddr_in address;	bzero(&amp;address, sizeof(address));	address.sin_family = AF_INET;	address.sin_port = htons(port);	inet_pton(AF_INET, ip, &amp;address.sin_addr); 	int sock = socket(PF_INET, SOCK_STREAM, 0);	assert(sock &gt;= 0);		int reuse = 1;	setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse)); 	int ret = bind(sock, (struct sockaddr*)&amp;address, sizeof(address));	assert(ret != -1); 	ret = listen(sock, 5);	assert(ret != -1);		struct sockaddr_in client;	socklen_t client_addrlength = sizeof(client);		int connfd = accept(sock, (struct sockaddr*)&amp;client, &amp;client_addrlength);	if (connfd &lt; 0) {		printf("errno is: %s\n", strerror(errno));	}	else {		int pipefd[2];						ret = pipe(pipefd);  //創建管道		assert(ret != -1);		                //將connfd上的客戶端數據定向到管道中		ret = splice(connfd, NULL, pipefd[1], NULL,						32768, SPLICE_F_MORE | SPLICE_F_MOVE);		assert(ret != -1);		                //將管道的輸出定向到connfd上		ret = splice(pipefd[0], NULL, connfd, NULL,						32768, SPLICE_F_MORE | SPLICE_F_MOVE);		assert(ret != -1);								close(connfd);	} 		close(sock);    	return 0;}</code></pre><p><strong>tee函數</strong></p><p>tee在兩個管道文件描述之間複製數據，也是零拷貝操作。</p><pre><code>#include &lt;fcntl.h&gt;ssize_t tee(int fd_in, int fd_out, size_t len, unsigned int flags);</code></pre><p>它的參數與splice相同，但fd_in和fd_out都必須是管道文件描述符，調用成功時返回複製的字節數。返回0表示沒有複製任務數據。失敗時返回-1，並設置errno。</p><p>用tee和splice實現從標準輸入到終端和文件的程序：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt;#include &lt;errno.h&gt;#include &lt;fcntl.h&gt;#include &lt;assert.h&gt; int main(int argc, char **argv){	if (argc != 2) {		fprintf(stderr, "Usage: %s &lt;file&gt;\n", argv[0]);		return 1;	}		uid_t uid = getuid();	uid_t euid = geteuid();	printf("userid: %d, effective userid: %d\n", uid, euid);		int filefd = open(argv[1], O_CREAT | O_WRONLY | O_TRUNC, 0666);	assert(filefd &gt; 0);		int pipefd_stdout[2];	int ret = pipe(pipefd_stdout);	assert(ret != -1);		int pipefd_file[2];	ret = pipe(pipefd_file);	assert(ret != -1);	        //將標準輸入的內容輸出到管道	ret = splice(STDOUT_FILENO, NULL, pipefd_stdout[1], NULL,					32768, SPLICE_F_MORE | SPLICE_F_MOVE);	assert(ret != -1);	        //將管道pipefd_stdout的輸出複製到管理pipefd_file的輸入端	ret = tee(pipefd_stdout[0], pipefd_file[1],				32768, SPLICE_F_NONBLOCK);	assert(ret != -1);	        //將管道pipefd_file的輸出定向到文件描述符filefd上，寫入文件	ret = splice(pipefd_file[0], NULL, filefd, NULL,					32768, SPLICE_F_MORE | SPLICE_F_MOVE);	assert(ret != -1);	        //將管道pipefd_stdout的輸出定向到標準出， 其內容和寫入文件的內容一致	ret = splice(pipefd_stdout[0], NULL, STDOUT_FILENO, NULL,					32768, SPLICE_F_MORE | SPLICE_F_MOVE);	assert(ret != -1);		close(filefd);	close(pipefd_file[0]);	close(pipefd_file[1]);	close(pipefd_stdout[0]);	close(pipefd_stdout[1]);		return 0;}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>服務器</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc8535c.html alt=疫情過後，你需要知道的Linux後臺服務器開發知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/9466032c-6500-4fe8-b629-49286a2f54eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc8535c.html title=疫情過後，你需要知道的Linux後臺服務器開發知識點>疫情過後，你需要知道的Linux後臺服務器開發知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/732d199.html alt=嵌入式Linux系統編程——linux大神深度給你講解進程、調度、信號 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/88364fad7d5246c191ed1444d983d186 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/732d199.html title=嵌入式Linux系統編程——linux大神深度給你講解進程、調度、信號>嵌入式Linux系統編程——linux大神深度給你講解進程、調度、信號</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/103109d.html alt=Linux網絡編程——無連接和面向連接協議的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/38755fbc61154d06a243d159fdae398b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/103109d.html title=Linux網絡編程——無連接和面向連接協議的區別>Linux網絡編程——無連接和面向連接協議的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/005f5437.html alt=哪些網站可以使用雲服務器呢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad0017473d694263a74bf6ca9dd5b544 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/005f5437.html title=哪些網站可以使用雲服務器呢>哪些網站可以使用雲服務器呢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24092427.html alt=在自己的電腦上搭建服務器，發佈自己的網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24092427.html title=在自己的電腦上搭建服務器，發佈自己的網站>在自己的電腦上搭建服務器，發佈自己的網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f24146de.html alt=怎麼租用服務器，哪種建站最好？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/52874987-e2c8-4404-99f4-38f53bad4aec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f24146de.html title=怎麼租用服務器，哪種建站最好？>怎麼租用服務器，哪種建站最好？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/614becd5.html alt=服務器安裝網站教程「網站三件套——LNMP」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/4c7b778f1e284e98825354694986f6c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/614becd5.html title=服務器安裝網站教程「網站三件套——LNMP」>服務器安裝網站教程「網站三件套——LNMP」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c37b69f8.html alt=服務器成為了當今網絡時代的寵兒，如何選擇網站適合獨立服務器？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2308cb41360841aa8df684a5bc19c92c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c37b69f8.html title=服務器成為了當今網絡時代的寵兒，如何選擇網站適合獨立服務器？>服務器成為了當今網絡時代的寵兒，如何選擇網站適合獨立服務器？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html alt=服務器架構：十張圖帶你瞭解大型網站架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2af10e2429bc47a5823244277a07bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24a6006e.html title=服務器架構：十張圖帶你瞭解大型網站架構>服務器架構：十張圖帶你瞭解大型網站架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d28cf747.html alt=服務器網站運行環境寶塔面板安裝教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8e911d07ba5b4d8c89535809fed5021b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d28cf747.html title=服務器網站運行環境寶塔面板安裝教程>服務器網站運行環境寶塔面板安裝教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8abf55d.html alt=虛擬主機服務器適用哪些類型網站？其選擇看什麼？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/e73b4b7a-50c7-4687-823c-30a7523d8c4a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8abf55d.html title=虛擬主機服務器適用哪些類型網站？其選擇看什麼？>虛擬主機服務器適用哪些類型網站？其選擇看什麼？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c77e1c3.html alt=跟著一起來基於Apache服務器部署WEB網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/221ad8e63e62434eb3b54b7f20b6154c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c77e1c3.html title=跟著一起來基於Apache服務器部署WEB網站>跟著一起來基於Apache服務器部署WEB網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/041eb04f.html alt=阿里雲服務器快速建網站_安裝BT寶塔面板和wordpress class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f2aaf81828344428b39b2102e2a62c2a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/041eb04f.html title=阿里雲服務器快速建網站_安裝BT寶塔面板和wordpress>阿里雲服務器快速建網站_安裝BT寶塔面板和wordpress</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>