<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>全面的MySQL優化面試解析 | 极客快訊</title><meta property="og:title" content="全面的MySQL優化面試解析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/740419fcb9b74050885f1743c249175b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d02b5a2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d02b5a2.html><meta property="article:published_time" content="2020-10-29T21:03:57+08:00"><meta property="article:modified_time" content="2020-10-29T21:03:57+08:00"><meta name=Keywords content><meta name=description content="全面的MySQL優化面試解析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/d02b5a2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>全面的MySQL優化面試解析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div><h1>本文概要</h1><p class=ql-align-center><br></p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/740419fcb9b74050885f1743c249175b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p class=ql-align-center>文章內圖片有損，需要高清可以在公眾號內回覆“大圖”</p><h1>概述</h1><p>為什麼要優化</p><ul><li class=ql-align-justify>系統的吞吐量瓶頸往往出現在數據庫的訪問速度上</li><li class=ql-align-justify>隨著應用程序的運行，數據庫的中的數據會越來越多，處理時間會相應變慢</li><li class=ql-align-justify>數據是存放在磁盤上的，讀寫速度無法和內存相比</li></ul><p>如何優化</p><ul><li class=ql-align-justify>設計數據庫時：數據庫表、字段的設計，存儲引擎</li><li class=ql-align-justify>利用好MySQL自身提供的功能，如索引等</li><li class=ql-align-justify>橫向擴展：MySQL集群、負載均衡、讀寫分離</li><li class=ql-align-justify>SQL語句的優化（收效甚微）</li></ul><h1>字段設計</h1><blockquote><p>字段類型的選擇，設計規範，範式，常見設計案例</p></blockquote><p>原則：儘量使用整型表示字符串</p><p>存儲IP</p><p>INET_ATON(str)，address to number</p><p>INET_NTOA(number)，number to address</p><p>MySQL內部的枚舉類型（單選）和集合（多選）類型</p><p>但是因為維護成本較高因此不常使用，使用<strong>關聯表</strong>的方式來替代enum</p><p>原則：定長和非定長數據類型的選擇</p><blockquote><p>decimal不會損失精度，存儲空間會隨數據的增大而增大。double佔用固定空間，較大數的存儲會損失精度。非定長的還有varchar、text</p></blockquote><p>金額</p><blockquote><p>對數據的精度要求較高，小數的運算和存儲存在精度問題（不能將所有小數轉換成二進制）</p></blockquote><p>定點數decimal</p><p>price decimal(8,2)有2位小數的定點數，定點數支持很大的數（甚至是超過int,bigint存儲範圍的數）</p><p>小單位大數額避免出現小數</p><p>元->分</p><p>字符串存儲</p><p>定長char，非定長varchar、text（上限65535，其中varchar還會消耗1-3字節記錄長度，而text使用額外空間記錄長度）</p><p>原則：儘可能選擇小的數據類型和指定短的長度</p><p>原則：儘可能使用 not null</p><p>非null字段的處理要比null字段的處理高效些！且不需要判斷是否為null。</p><p>null在MySQL中，不好處理，存儲需要額外空間，運算也需要特殊的運算符。如select null = null和select null &lt;> null（&lt;>為不等號）有著同樣的結果，只能通過is null和is not null來判斷字段是否為null。</p><p>如何存儲？MySQL中每條記錄都需要額外的存儲空間，表示每個字段是否為null。因此通常使用特殊的數據進行佔位，比如int not null default 0、string not null default ‘’</p><p>原則：字段註釋要完整，見名知意</p><p>原則：單表字段不宜過多</p><p>二三十個就極限了</p><p>原則：可以預留字段</p><blockquote><p>在使用以上原則之前首先要滿足業務需求</p></blockquote><h1>關聯表的設計</h1><blockquote><p>外鍵foreign key只能實現一對一或一對多的映射</p></blockquote><p>一對多</p><p>使用外鍵</p><p>多對多</p><p>單獨新建一張表將多對多拆分成兩個一對多</p><p>一對一</p><p>如商品的基本信息（item）和商品的詳細信息（item_intro），通常使用相同的主鍵或者增加一個外鍵字段（item_id）</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/3b350d9f-f95e-4d59-af58-2073c5879c41><p class=pgc-img-caption></p></div><h1>範式 Normal Format</h1><blockquote><p>數據表的設計規範，一套越來越嚴格的規範體系（如果需要滿足N範式，首先要滿足N-1範式）。N</p></blockquote><p>第一範式1NF：字段原子性</p><p>字段原子性，字段不可再分割。</p><blockquote><p>關係型數據庫，默認滿足第一範式</p></blockquote><p>注意比較容易出錯的一點，在一對多的設計中使用逗號分隔多個外鍵，這種方法雖然存儲方便，但不利於維護和索引（比如查找帶標籤java的文章）</p><p>第二範式：消除對主鍵的部分依賴</p><blockquote><p>即在表中加上一個與業務邏輯無關的字段作為主鍵</p></blockquote><p>主鍵：可以唯一標識記錄的字段或者字段集合。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e9b5533f89c7422c9c87e0280f36e16b><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>依賴：A字段可以確定B字段，則B字段依賴A字段。比如知道了下一節課是數學課，就能確定任課老師是誰。於是<strong>周幾</strong>和<strong>下一節課</strong>和就能構成複合主鍵，能夠確定去哪個教室上課，任課老師是誰等。但我們常常增加一個id作為主鍵，而消除對主鍵的部分依賴。</p><p>對主鍵的部分依賴：某個字段依賴複合主鍵中的一部分。</p><p>解決方案：新增一個獨立字段作為主鍵。</p><p>第三範式：消除對主鍵的傳遞依賴</p><p>傳遞依賴：B字段依賴於A，C字段又依賴於B。比如上例中，任課老師是誰取決於是什麼課，是什麼課又取決於主鍵id。因此需要將此表拆分為兩張表日程表和課程表（獨立數據獨立建表）：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b7ba0f0ebde34e2e8a2188663a112ea1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>這樣就減少了數據的冗餘（即使週一至週日每天都有Java課，也只是course_id:3546出現了7次）</p><h1>存儲引擎選擇</h1><blockquote><p>早期問題：如何選擇MyISAM和Innodb？</p><p>現在不存在這個問題了，Innodb不斷完善，從各個方面趕超MyISAM，也是MySQL默認使用的。</p></blockquote><p>存儲引擎Storage engine：MySQL中的數據、索引以及其他對象是如何存儲的，是一套文件系統的實現。</p><p>功能差異</p><p>show engines</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/28c2ac3015e14227a4b4a862bcf29c67><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>存儲差異</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e4cfd983cdfa4d219e7432f6c29d1185><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><blockquote><p>鎖擴展</p><p>表級鎖（table-level lock）：lock tables &lt;table_name1>,&lt;table_name2>... read/write，unlock tables &lt;table_name1>,&lt;table_name2>...。其中read是共享鎖，一旦鎖定任何客戶端都不可讀；write是獨佔/寫鎖，只有加鎖的客戶端可讀可寫，其他客戶端既不可讀也不可寫。鎖定的是一張表或幾張表。</p><p>行級鎖（row-level lock）：鎖定的是一行或幾行記錄。共享鎖：select * from &lt;table_name> where &lt;條件> LOCK IN SHARE MODE;，對查詢的記錄增加共享鎖；select * from &lt;table_name> where &lt;條件> FOR UPDATE;，對查詢的記錄增加排他鎖。</p><p>這裡<strong>值得注意</strong>的是：innodb的行鎖，其實是一個子範圍鎖，依據條件鎖定部分範圍，而不是就映射到具體的行上，因此還有一個學名：間隙鎖。比如select * from stu where id &lt; 20 LOCK IN SHARE MODE會鎖定id在20左右以下的範圍，你可能無法插入id為18或22的一條新紀錄。</p></blockquote><p>選擇依據</p><p>如果沒有特別的需求，使用默認的Innodb即可。</p><p>MyISAM：以讀寫插入為主的應用程序，比如博客系統、新聞門戶網站。</p><p>Innodb：更新（刪除）操作頻率也高，或者要保證數據的完整性；併發量高，支持事務和外鍵保證數據完整性。比如OA自動化辦公系統。</p><h1>索引</h1><blockquote><p>關鍵字與數據的映射關係稱為索引（包含關鍵字和對應的記錄在磁盤中的地址）。關鍵字是從數據當中提取的用於標識、檢索數據的特定內容。</p></blockquote><p>索引檢索為什麼快？</p><ul><li class=ql-align-justify>關鍵字相對於數據本身，數據量小</li><li class=ql-align-justify>關鍵字是有序的，二分查找可快速確定位置</li></ul><p>圖書館為每本書都加了索引號（類別-樓層-書架）、字典為詞語解釋按字母順序編寫目錄等都用到了索引。</p><p>MySQL中索引類型</p><blockquote><p><strong>普通索引</strong>（key），<strong>唯一索引</strong>（unique key），<strong>主鍵索引</strong>（primary key），<strong>全文索引</strong>（fulltext key）</p></blockquote><p>三種索引的索引方式是一樣的，只不過對索引的關鍵字有不同的限制：</p><ul><li class=ql-align-justify>普通索引：對關鍵字沒有限制</li><li class=ql-align-justify>唯一索引：要求記錄提供的關鍵字不能重複</li><li class=ql-align-justify>主鍵索引：要求關鍵字唯一且不為null</li></ul><p>索引管理語法</p><p>查看索引</p><p>show create table 表名：</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a4377c7b299649d38802e95985fe099d><p class=pgc-img-caption></p></div><p>desc 表名</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23a68b72472c461a986a03892eb073f9><p class=pgc-img-caption></p></div><p>創建索引</p><p>創建表之後建立索引</p><ul><li><br></li></ul><pre>create TABLE user_index( id int auto_increment primary key, first_name varchar(16), last_name VARCHAR(16), id_card VARCHAR(18), information text);-- 更改表結構alter table user_index-- 創建一個first_name和last_name的複合索引，並命名為nameadd key name (first_name,last_name),-- 創建一個id_card的唯一索引，默認以字段名作為索引名add UNIQUE KEY (id_card),-- 雞肋，全文索引不支持中文add FULLTEXT KEY (information);</pre><p>show create table user_index：</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a2854947bb04af08cc857331979a43b><p class=pgc-img-caption></p></div><p>創建表時指定索引</p><ul><li><br></li></ul><pre>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card));</pre><p>刪除索引</p><p>根據索引名刪除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p><ul><li><br></li></ul><pre>alter table user_index drop KEY name;alter table user_index drop KEY id_card;alter table user_index drop KEY information;</pre><p>刪除主鍵索引：alter table 表名 drop primary key（因為主鍵只有一個）。這裡值得注意的是，如果主鍵自增長，那麼不能直接執行此操作（自增長依賴於主鍵索引）：</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/14c3f5ef189c42e48a595f33b288082c><p class=pgc-img-caption></p></div><p>需要取消自增長再行刪除：</p><ul><li><br></li></ul><pre>alter table user_index-- 重新定義字段MODIFY id int,drop PRIMARY KEY</pre><p>但通常不會刪除主鍵，因為設計主鍵一定與業務邏輯無關。</p><p>執行計劃explain</p><ul><li><br></li></ul><pre>CREATE TABLE innodb1 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card));insert into innodb1 (first_name,last_name,id_card,information) values ('張','三','1001','華山派');</pre><p>我們可以通過explain selelct來分析SQL語句執行前的執行計劃：</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed740946ce0b483fa23f911957bc6cdd><p class=pgc-img-caption></p></div><p>由上圖可看出此SQL語句是按照主鍵索引來檢索的。</p><p>執行計劃是：當執行SQL語句時，首先會分析、優化，形成執行計劃，在按照執行計劃執行。</p><p>索引使用場景（重點）</p><p>where</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d339edee2365472d881e2f9af6765749><p class=pgc-img-caption></p></div><p>上圖中，根據id查詢記錄，因為id字段僅建立了主鍵索引，因此此SQL執行可選的索引只有主鍵索引，如果有多個，最終會選一個較優的作為檢索的依據。</p><ul><li><br></li></ul><pre>-- 增加一個沒有建立索引的字段alter table innodb1 add sex char(1);-- 按sex檢索時可選的索引為nullEXPLAIN SELECT * from innodb1 where sex='男';</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9caa05b5fd2c4fdcb8d4d77f60e5620b><p class=pgc-img-caption></p></div><blockquote><p>可以嘗試在一個字段未建立索引時，根據該字段查詢的效率，然後對該字段建立索引（alter table 表名 add index(字段名)），同樣的SQL執行的效率，你會發現查詢效率會有明顯的提升（數據量越大越明顯）。</p></blockquote><p>order by</p><p>當我們使用order by將查詢結果按照某個字段排序時，如果該字段沒有建立索引，那麼執行計劃會將查詢出的所有數據使用外部排序（將數據從硬盤分批讀取到內存使用內部排序，最後合併排序結果），這個操作是很影響性能的，因為需要將查詢涉及到的所有數據從磁盤中讀到內存（如果單條數據過大或者數據量過多都會降低效率），更無論讀到內存之後的排序了。</p><p>但是如果我們對該字段建立索引alter table 表名 add index(字段名)，那麼由於索引本身是有序的，因此直接按照索引的順序和映射關係逐條取出數據即可。而且如果分頁的，那麼只用<strong>取出索引表某個範圍內的索引對應的數據</strong>，而不用像上述那<strong>取出所有數據</strong>進行排序再返回某個範圍內的數據。（從磁盤取數據是最影響性能的）</p><p>join</p><blockquote><p>對join語句匹配關係（on）涉及的字段建立索引能夠提高效率</p></blockquote><p>索引覆蓋</p><p>如果要查詢的字段都建立過索引，那麼引擎會直接在索引表中查詢而不會訪問原始數據（否則只要有一個字段沒有建立索引就會做全表掃描），這叫索引覆蓋。因此我們需要儘可能的在select後只寫必要的查詢字段，以增加索引覆蓋的機率。</p><p>這裡值得注意的是不要想著為每個字段建立索引，因為優先使用索引的優勢就在於其體積小。</p><p>語法細節（要點）</p><blockquote><p>在滿足索引使用的場景下（where/order by/join on或索引覆蓋），索引也不一定被使用</p></blockquote><p>字段要獨立出現</p><p>比如下面兩條SQL語句在語義上相同，但是第一條會使用主鍵索引而第二條不會。</p><ul><li><br></li></ul><pre>select * from user where id = 20-1;select * from user where id+1 = 20;</pre><p>`like`查詢，不能以通配符開頭</p><p>比如搜索標題包含mysql的文章：</p><ul><li><br></li></ul><pre>select * from article where title like '%mysql%';</pre><p>這種SQL的執行計劃用不了索引（like語句匹配表達式以通配符開頭），因此只能做全表掃描，效率極低，在實際工程中幾乎不被採用。而一般會使用第三方提供的支持中文的全文索引來做。</p><p>但是 <strong>關鍵字查詢</strong> 熱搜提醒功能還是可以做的，比如鍵入mysql之後提醒mysql 教程、mysql 下載、mysql 安裝步驟等。用到的語句是：</p><ul><li><br></li></ul><pre>select * from article where title like 'mysql%';</pre><p>這種like是可以利用索引的（當然前提是title字段建立過索引）。</p><p>複合索引只對第一個字段有效</p><p>建立複合索引：</p><ul><li><br></li></ul><pre>alter table person add index(first_name,last_name);</pre><p>其原理就是將索引先按照從first_name中提取的關鍵字排序，如果無法確定先後再按照從last_name提取的關鍵字排序，也就是說該索引表只是按照記錄的first_name字段值有序。</p><p>因此select * from person where first_name = ?是可以利用索引的，而select * from person where last_name = ?無法利用索引。</p><blockquote><p>那麼該複合索引的應用場景是什麼？組合查詢</p></blockquote><p>比如對於select * person from first_name = ? and last_name = ?，複合索引就比對first_name和last_name單獨建立索引要高效些。很好理解，複合索引首先二分查找與first_name = ?匹配的記錄，再在這些記錄中二分查找與last_name匹配的記錄，只涉及到一張索引表。</p><p>而分別單獨建立索引則是在first_name索引表中二分找出與first_name = ?匹配的記錄，再在last_name索引表中二分找出與last_name = ?的記錄，兩者取交集。擴展：帶你徹底瞭解數據庫索引</p><p>or，兩邊條件都有索引可用</p><blockquote><p>一但有一邊無索引可用就會導致整個SQL語句的全表掃描</p></blockquote><p>狀態值，不容易使用到索引</p><p>如性別、支付狀態等狀態值字段往往只有極少的幾種取值可能，這種字段即使建立索引，也往往利用不上。這是因為，一個狀態值可能匹配大量的記錄，這種情況MySQL會認為利用索引比全表掃描的效率低，從而棄用索引。</p><p>索引是隨機訪問磁盤，而全表掃描是順序訪問磁盤，這就好比有一棟20層樓的寫字樓，樓底下的索引牌上寫著某個公司對應不相鄰的幾層樓，你去公司找人，與其按照索引牌的提示去其中一層樓沒找到再下來看索引牌再上樓，不如從1樓挨個往上找到頂樓。</p><p>如何創建索引</p><ul><li class=ql-align-justify>建立基礎索引：在where、order by、join字段上建立索引。</li><li class=ql-align-justify>優化，組合索引：基於業務邏輯</li><li class=ql-align-justify>如果條件經常性出現在一起，那麼可以考慮將多字段索引升級為複合索引</li><li class=ql-align-justify>如果通過增加個別字段的索引，就可以出現索引覆蓋，那麼可以考慮為該字段建立索引</li><li class=ql-align-justify>查詢時，不常用到的索引，應該刪除掉</li></ul><p>前綴索引</p><p>語法：index(field(10))，使用字段值的前10個字符建立索引，默認是使用字段的全部內容建立索引。</p><p>前提：前綴的標識度高。比如密碼就適合建立前綴索引，因為密碼幾乎各不相同。</p><p>實操的難度：在於前綴截取的長度。</p><p>我們可以利用select count(*)/count(distinct left(password,prefixLen));，通過從調整prefixLen的值（從1自增）查看不同前綴長度的一個平均匹配度，接近1時就可以了（表示一個密碼的前prefixLen個字符幾乎能確定唯一一條記錄）</p><p>索引的存儲結構</p><p>BTree</p><p>btree（多路平衡查找樹）是一種廣泛應用於磁盤上實現索引功能的一種數據結構，也是大多數數據庫索引表的實現。</p><p>以add index(first_name,last_name)為例：</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1b94c2ae757a413184fb787cbfd855b6><p class=pgc-img-caption></p></div><p>BTree的一個node可以存儲多個關鍵字，node的大小取決於計算機的文件系統，因此我們可以通過減小索引字段的長度使結點存儲更多的關鍵字。如果node中的關鍵字已滿，那麼可以通過每個關鍵字之間的子節點指針來拓展索引表，但是不能破壞結構的有序性，比如按照first_name第一有序、last_name第二有序的規則，新添加的韓香就可以插到韓康之後。白起 &lt; 韓飛 &lt; 韓康 &lt; 李世民 &lt; 趙奢 &lt; 李尋歡 &lt; 王語嫣 &lt; 楊不悔。</p><p>這與二叉搜索樹的思想是一樣的，只不過二叉搜索樹的查找效率是log(2,N)（以2為底N的對數），而BTree的查找效率是log(x,N)（其中x為node的關鍵字數量，可以達到1000以上）。</p><p>從log(1000+,N)可以看出，少量的磁盤讀取即可做到大量數據的遍歷，這也是btree的設計目的。</p><p>B+Tree聚簇結構</p><p>聚簇結構（也是在BTree上升級改造的）中，關鍵字和記錄是存放在一起的。</p><p>在MySQL中，僅僅只有Innodb的主鍵索引為聚簇結構，其它的索引包括Innodb的非主鍵索引都是典型的BTree結構。</p><p>哈希索引</p><p>在索引被載入內存時，使用哈希結構來存儲。</p><h1>查詢緩存</h1><blockquote><p>緩存select語句的查詢結果</p></blockquote><p>在配置文件中開啟緩存</p><p>windows上是my.ini，linux上是my.cnf</p><p>在[mysqld]段中配置query_cache_type：</p><ul><li class=ql-align-justify>0：不開啟</li><li class=ql-align-justify>1：開啟，默認緩存所有，需要在SQL語句中增加select sql-no-cache提示來放棄緩存</li><li class=ql-align-justify>2：開啟，默認都不緩存，需要在SQL語句中增加select sql-cache來主動緩存（常用）</li></ul><p>更改配置後需要重啟以使配置生效，重啟後可通過show variables like ‘query_cache_type’;來查看：</p><ul><li><br></li></ul><pre>show variables like 'query_cache_type';query_cache_type DEMAND</pre><p>在客戶端設置緩存大小</p><p>通過配置項query_cache_size來設置：</p><ul><li><br></li></ul><pre>show variables like 'query_cache_size';query_cache_size 0set global query_cache_size=64*1024*1024;show variables like 'query_cache_size';query_cache_size 67108864</pre><p>將查詢結果緩存</p><p>select sql_cache * from user;</p><p>重置緩存</p><p>reset query cache;</p><p>緩存失效問題（大問題）</p><p>當數據表改動時，基於該數據表的任何緩存都會被刪除。（表層面的管理，不是記錄層面的管理，因此失效率較高）</p><p>注意事項</p><ol><li class=ql-align-justify>應用程序，不應該關心query cache的使用情況。可以嘗試使用，但不能由query cache決定業務邏輯，因為query cache由DBA來管理。</li><li class=ql-align-justify>緩存是以SQL語句為key存儲的，因此即使SQL語句功能相同，但如果多了一個空格或者大小寫有差異都會導致匹配不到緩存。</li></ol><p class=ql-align-justify><br></p><h1>分區</h1><p>一般情況下我們創建的表對應一組存儲文件，使用MyISAM存儲引擎時是一個.MYI和.MYD文件，使用Innodb存儲引擎時是一個.ibd和.frm（表結構）文件。</p><p>當數據量較大時（一般千萬條記錄級別以上），MySQL的性能就會開始下降，這時我們就需要將數據分散到多組存儲文件，保證其單個文件的執行效率。</p><p>最常見的分區方案是按id分區，如下將id的哈希值對10取模將數據均勻分散到10個.ibd存儲文件中：</p><ul><li><br></li></ul><pre>create table article( id int auto_increment PRIMARY KEY, title varchar(64), content text)PARTITION by HASH(id) PARTITIONS 10</pre><p>查看data目錄：</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0e2f89dee0ba4ee985e93341fe375f3e><p class=pgc-img-caption></p></div><blockquote><p>服務端的表分區對於客戶端是透明的，客戶端還是照常插入數據，但服務端會按照分區算法分散存儲數據。</p></blockquote><p>MySQL提供的分區算法</p><blockquote><p>分區依據的字段必須是主鍵的一部分，分區是為了快速定位數據，因此該字段的搜索頻次較高應作為強檢索字段，否則依照該字段分區毫無意義</p></blockquote><p>hash(field)</p><p>相同的輸入得到相同的輸出。輸出的結果跟輸入是否具有規律無關。僅適用於整型字段</p><p>key(field)</p><p>和hash(field)的性質一樣，只不過key是處理字符串的，比hash()多了一步從字符串中計算出一個整型在做取模操作。</p><ul><li><br></li></ul><pre>create table article_key( id int auto_increment, title varchar(64), content text, PRIMARY KEY (id,title) -- 要求分區依據字段必須是主鍵的一部分)PARTITION by KEY(title) PARTITIONS 10</pre><p>range算法</p><p>是一種條件分區算法，按照數據大小範圍分區（將數據使用某種條件，分散到不同的分區中）。</p><p>如下，按文章的發佈時間將數據按照2018年8月、9月、10月分區存放：</p><ul><li><br></li></ul><pre>create table article_range( id int auto_increment, title varchar(64), content text, created_time int, -- 發佈時間到1970-1-1的毫秒數 PRIMARY KEY (id,created_time) -- 要求分區依據字段必須是主鍵的一部分)charset=utf8PARTITION BY RANGE(created_time)( PARTITION p201808 VALUES less than (1535731199), -- select UNIX_TIMESTAMP('2018-8-31 23:59:59') PARTITION p201809 VALUES less than (1538323199), -- 2018-9-30 23:59:59 PARTITION p201810 VALUES less than (1541001599) -- 2018-10-31 23:59:59);</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/539c2d6de02e44158b25e87b91966615><p class=pgc-img-caption></p></div><p>注意：條件運算符只能使用less than，這以為著較小的範圍要放在前面，比如上述p201808,p201819,p201810分區的定義順序依照created_time數值範圍從小到大，不能顛倒。</p><ul><li><br></li></ul><pre>insert into article_range values(null,'MySQL優化','內容示例',1535731180);flush tables; -- 使操作立即刷新到磁盤文件</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29c72530127a438aabd53ffbb6279860><p class=pgc-img-caption></p></div><p>由於插入的文章的發佈時間1535731180小於1535731199（2018-8-31 23:59:59），因此被存儲到p201808分區中，這種算法的存儲到哪個分區取決於數據狀況。</p><p>list算法</p><p>也是一種條件分區，按照列表值分區（in (值列表)）。</p><ul><li><br></li></ul><pre>create table article_list( id int auto_increment, title varchar(64), content text, status TINYINT(1), -- 文章狀態：0-草稿，1-完成但未發佈，2-已發佈 PRIMARY KEY (id,status) -- 要求分區依據字段必須是主鍵的一部分)charset=utf8PARTITION BY list(status)( PARTITION writing values in(0,1), -- 未發佈的放在一個分區  PARTITION published values in (2) -- 已發佈的放在一個分區);insert into article_list values(null,'mysql優化','內容示例',0);flush tables;</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/09c642c6cc55401280b67fce33e0b456><p class=pgc-img-caption></p></div><p>分區管理語法</p><p>range/list</p><p>增加分區</p><p>前文中我們嘗試使用range對文章按照月份歸檔，隨著時間的增加，我們需要增加一個月份：</p><ul><li><br></li></ul><pre>alter table article_range add partition( partition p201811 values less than (1543593599) -- select UNIX_TIMESTAMP('2018-11-30 23:59:59') -- more);</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fa7e393a2de1468c944e289f2f0d826f><p class=pgc-img-caption></p></div><p>刪除分區</p><ul><li><br></li></ul><pre>alter table article_range drop PARTITION p201808</pre><p>注意：刪除分區後，分區中原有的數據也會隨之刪除！</p><p>key/hash</p><p>新增分區</p><ul><li><br></li></ul><pre>alter table article_key add partition partitions 4</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b6ab3810f1f45efb73cd04d534a9744><p class=pgc-img-caption></p></div><p>銷燬分區</p><ul><li><br></li></ul><pre>alter table article_key coalesce partition 6</pre><p>key/hash分區的管理不會刪除數據，但是每一次調整（新增或銷燬分區）都會將所有的數據重寫分配到新的分區上。效率極低，最好在設計階段就考慮好分區策略。</p><p>分區的使用</p><p>當數據表中的數據量很大時，分區帶來的效率提升才會顯現出來。</p><p>只有檢索字段為分區字段時，分區帶來的效率提升才會比較明顯。因此，分區字段的選擇很重要，並且業務邏輯要儘可能地根據分區字段做相應調整（儘量使用分區字段作為查詢條件）。</p><h1>水平分割和垂直分割</h1><blockquote><p>水平分割：通過建立結構相同的幾張表分別存儲數據</p><p>垂直分割：將經常一起使用的字段放在一個單獨的表中，分割後的表記錄之間是一一對應關係。</p></blockquote><p>分表原因</p><ul><li class=ql-align-justify>為數據庫減壓</li><li class=ql-align-justify>分區算法侷限</li><li class=ql-align-justify>數據庫支持不完善（5.1之後mysql才支持分區操作）</li></ul><p>id重複的解決方案</p><ul><li class=ql-align-justify>借用第三方應用如memcache、redis的id自增器</li><li class=ql-align-justify>單獨建一張只包含id一個字段的表，每次自增該字段作為數據記錄的id</li></ul><p class=ql-align-justify><br></p><h1>集群</h1><blockquote><p>橫向擴展：從根本上（單機的硬件處理能力有限）提升數據庫性能 。由此而生的相關技術：讀寫分離、負載均衡</p></blockquote><p>安裝和配置主從複製</p><p>環境</p><ul><li class=ql-align-justify>Red Hat Enterprise Linux Server release 7.0 (Maipo)（虛擬機）</li><li class=ql-align-justify>mysql5.7</li></ul><p>安裝和配置</p><p>解壓到對外提供的服務的目錄（我自己專門創建了一個/export/server來存放）</p><ul><li><br></li></ul><pre>tar xzvf mysql-5.7.23-linux-glibc2.12-x86_64.tar.gz -C /export/servercd /export/servermv mysql-5.7.23-linux-glibc2.12-x86_64 mysql</pre><p class=ql-align-justify>添加mysql目錄的所屬組和所屬者：</p><ul><li><br></li></ul><pre>groupadd mysqluseradd -r -g mysql mysqlcd /export/serverchown -R mysql:mysql mysql/chmod -R 755 mysql/</pre><p class=ql-align-justify>創建mysql數據存放目錄（其中/export/data是我創建專門用來為各種服務存放數據的目錄）</p><ul><li><br></li></ul><pre>mkdir /export/data/mysql</pre><p class=ql-align-justify>初始化mysql服務</p><ul><li><br></li></ul><pre>cd /export/server/mysql./bin/mysqld --basedir=/export/server/mysql --datadir=/export/data/mysql --user=mysql --pid-file=/export/data/mysql/mysql.pid --initialize</pre><blockquote><p>如果成功會顯示mysql的root賬戶的初始密碼，記下來以備後續登錄。如果報錯缺少依賴，則使用yum instally依次安裝即可</p></blockquote><p>配置my.cnf</p><ul><li><br></li></ul><pre>vim /etc/my.cnf[mysqld]basedir=/export/server/mysqldatadir=/export/data/mysqlsocket=/tmp/mysql.sockuser=mysqlserver-id=10 # 服務id，在集群時必須唯一，建議設置為IP的第四段port=3306# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemd[mysqld_safe]log-error=/export/data/mysql/error.logpid-file=/export/data/mysql/mysql.pid## include all files from the config directory#!includedir /etc/my.cnf.d</pre><p class=ql-align-justify>將服務添加到開機自動啟動</p><ul><li><br></li></ul><pre>cp /export/server/mysql/support-files/mysql.server /etc/init.d/mysqld</pre><p class=ql-align-justify>啟動服務</p><ul><li><br></li></ul><pre>service mysqld start</pre><p class=ql-align-justify>配置環境變量，在/etc/profile中添加如下內容</p><ul><li><br></li></ul><pre># mysql envMYSQL_HOME=/export/server/mysqlMYSQL_PATH=$MYSQL_HOME/binPATH=$PATH:$MYSQL_PATHexport PATH</pre><p class=ql-align-justify>使配置即可生效</p><ul><li><br></li></ul><pre>source /etc/profile</pre><p class=ql-align-justify>使用root登錄</p><ul><li><br></li></ul><pre>mysql -uroot -p# 這裡填寫之前初始化服務時提供的密碼</pre><p class=ql-align-justify>登錄上去之後，更改root賬戶密碼（我為了方便將密碼改為root），否則操作數據庫會報錯</p><ul><li><br></li></ul><pre>set password=password('root');flush privileges;</pre><p class=ql-align-justify>設置服務可被所有遠程客戶端訪問</p><ul><li><br></li></ul><pre>use mysql;update user set host='%' where user='root';flush privileges;</pre><blockquote><p>這樣就可以在宿主機使用navicat遠程連接虛擬機linux上的mysql了</p></blockquote><p>配置主從節點</p><p>配置master</p><p>以linux（192.168.10.10）上的mysql為master，宿主機（192.168.10.1）上的mysql為slave配置主從複製。（可以參考：數據庫從主備到主主的高可用方案）</p><p>修改master的my.cnf如下</p><ul><li><br></li></ul><pre>[mysqld]basedir=/export/server/mysqldatadir=/export/data/mysqlsocket=/tmp/mysql.sockuser=mysqlserver-id=10port=3306# Disabling symbolic-links is recommended to prevent assorted security riskssymbolic-links=0# Settings user and group are ignored when systemd is used.# If you need to run mysqld under a different user or group,# customize your systemd unit file for mariadb according to the# instructions in http://fedoraproject.org/wiki/Systemdlog-bin=mysql-bin # 開啟二進制日誌expire-logs-days=7 # 設置日誌過期時間，避免佔滿磁盤binlog-ignore-db=mysql # 不使用主從複製的數據庫binlog-ignore-db=information_schemabinlog-ignore-db=performation_schemabinlog-ignore-db=sysbinlog-do-db=test #使用主從複製的數據庫[mysqld_safe]log-error=/export/data/mysql/error.logpid-file=/export/data/mysql/mysql.pid## include all files from the config directory#!includedir /etc/my.cnf.d</pre><p class=ql-align-justify>重啟master</p><ul><li><br></li></ul><pre>service mysqld restart</pre><p class=ql-align-justify>登錄master查看配置是否生效（ON即為開啟，默認為OFF）：</p><ul><li><br></li></ul><pre>mysql&gt; show variables like 'log_bin';+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin | ON |+---------------+-------+</pre><p class=ql-align-justify>在master的數據庫中建立備份賬號：backup為用戶名，%表示任何遠程地址，用戶back可以使用密碼1234通過任何遠程客戶端連接master</p><ul><li><br></li></ul><pre>grant replication slave on *.* to 'backup'@'%' identified by '1234'</pre><p class=ql-align-justify>查看user表可以看到我們剛創建的用戶：</p><ul><li><br></li></ul><pre>mysql&gt; use mysqlmysql&gt; select user,authentication_string,host from user;+---------------+-------------------------------------------+-----------+| user | authentication_string | host |+---------------+-------------------------------------------+-----------+| root | *81F5E21E35407D884A6CD4A731AEBFB6AF209E1B | % || mysql.session | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | localhost || mysql.sys | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE | localhost || backup | *A4B6157319038724E3560894F7F932C8886EBFCF | % |+---------------+-------------------------------------------+-----------+</pre><p class=ql-align-justify>新建test數據庫，創建一個article表以備後續測試</p><ul><li><br></li></ul><pre>CREATE TABLE `article` ( `id` int(11) NOT NULL AUTO_INCREMENT, `title` varchar(64) DEFAULT NULL, `content` text, PRIMARY KEY (`id`)) CHARSET=utf8;</pre><p class=ql-align-justify>重啟服務並刷新數據庫狀態到存儲文件中（with read lock表示在此過程中，客戶端只能讀數據，以便獲得一個一致性的快照）</p><ul><li><br></li></ul><pre>[root@zhenganwen ~]# service mysqld restartShutting down MySQL.... SUCCESS! Starting MySQL. SUCCESS! [root@zhenganwen mysql]# mysql -uroot -prootmysql&gt; flush tables with read lock;Query OK, 0 rows affected (0.00 sec)</pre><p class=ql-align-justify>查看master上當前的二進制日誌和偏移量（記一下其中的File和Position）</p><ul><li><br></li></ul><pre>mysql&gt; show master status \G*************************** 1. row *************************** File: mysql-bin.000002 Position: 154 Binlog_Do_DB: test Binlog_Ignore_DB: mysql,information_schema,performation_schema,sysExecuted_Gtid_Set: 1 row in set (0.00 sec)</pre><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f88782160d5846288d89a56278d1540c><p class=pgc-img-caption></p></div><p>File表示實現複製功能的日誌，即上圖中的Binary log；Position則表示Binary log日誌文件的偏移量之後的都會同步到slave中，那麼在偏移量之前的則需要我們手動導入。</p><p>主服務器上面的任何修改都會保存在二進制日誌Binary log裡面，從服務器上面啟動一個I/O thread（實際上就是一個主服務器的客戶端進程），連接到主服務器上面請求讀取二進制日誌，然後把讀取到的二進制日誌寫到本地的一個Realy log裡面。從服務器上面開啟一個SQL thread定時檢查Realy log，如果發現有更改立即把更改的內容在本機上面執行一遍。</p><p>如果一主多從的話，這時主庫既要負責寫又要負責為幾個從庫提供二進制日誌。此時可以稍做調整，將二進制日誌只給某一從，這一從再開啟二進制日誌並將自己的二進制日誌再發給其它從。或者是乾脆這個從不記錄只負責將二進制日誌轉發給其它從，這樣架構起來性能可能要好得多，而且數據之間的延時應該也稍微要好一些</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0b92058c07694241aaa52372b5f0dbb9><p class=pgc-img-caption></p></div><p>手動導入，從master中導出數據</p><ul><li><br></li></ul><pre>mysqldump -uroot -proot -hlocalhost test &gt; /export/data/test.sql</pre><p>將test.sql中的內容在slave上執行一遍。</p><p>配置slave</p><p>修改slave的my.ini文件中的[mysqld]部分</p><ul><li><br></li></ul><pre>log-bin=mysqlserver-id=1 #192.168.10.1</pre><p>保存修改後重啟slave，WIN+R->services.msc->MySQL5.7->重新啟動</p><p>登錄slave檢查log_bin是否以被開啟：</p><ul><li><br></li></ul><pre>show VARIABLES like 'log_bin';</pre><p class=ql-align-justify>配置與master的同步複製：</p><ul><li><br></li></ul><pre>stop slave; change master to master_host='192.168.10.10', -- master的IP master_user='backup', -- 之前在master上創建的用戶 master_password='1234', master_log_file='mysql-bin.000002', -- master上 show master status \G 提供的信息 master_log_pos=154;</pre><p class=ql-align-justify>啟用slave節點並查看狀態</p><ul><li><br></li></ul><pre>mysql&gt; start slave;mysql&gt; show slave status \G*************************** 1. row *************************** Slave_IO_State: Waiting for master to send event Master_Host: 192.168.10.10 Master_User: backup Master_Port: 3306 Connect_Retry: 60 Master_Log_File: mysql-bin.000002 Read_Master_Log_Pos: 154 Relay_Log_File: DESKTOP-KUBSPE0-relay-bin.000002 Relay_Log_Pos: 320 Relay_Master_Log_File: mysql-bin.000002 Slave_IO_Running: Yes Slave_SQL_Running: Yes Replicate_Do_DB: Replicate_Ignore_DB: Replicate_Do_Table: Replicate_Ignore_Table: Replicate_Wild_Do_Table: Replicate_Wild_Ignore_Table: Last_Errno: 0 Last_Error: Skip_Counter: 0 Exec_Master_Log_Pos: 154 Relay_Log_Space: 537 Until_Condition: None Until_Log_File: Until_Log_Pos: 0 Master_SSL_Allowed: No Master_SSL_CA_File: Master_SSL_CA_Path: Master_SSL_Cert: Master_SSL_Cipher: Master_SSL_Key: Seconds_Behind_Master: 0Master_SSL_Verify_Server_Cert: No Last_IO_Errno: 0 Last_IO_Error: Last_SQL_Errno: 0 Last_SQL_Error: Replicate_Ignore_Server_Ids: Master_Server_Id: 10 Master_UUID: f68774b7-0b28-11e9-a925-000c290abe05 Master_Info_File: C:\ProgramData\MySQL\MySQL Server 5.7\Data\master.info SQL_Delay: 0 SQL_Remaining_Delay: NULL Slave_SQL_Running_State: Slave has read all relay log; waiting for more updates Master_Retry_Count: 86400 Master_Bind: Last_IO_Error_Timestamp: Last_SQL_Error_Timestamp: Master_SSL_Crl: Master_SSL_Crlpath: Retrieved_Gtid_Set: Executed_Gtid_Set: Auto_Position: 0 Replicate_Rewrite_DB: Channel_Name: Master_TLS_Version:1 row in set (0.00 sec)</pre><blockquote><p>注意查看第4、14、15三行，若與我一致，表示slave配置成功</p></blockquote><p>測試</p><p>關閉master的讀取鎖定</p><ul><li><br></li></ul><pre>mysql&gt; unlock tables;Query OK, 0 rows affected (0.00 sec)</pre><p class=ql-align-justify>向master中插入一條數據</p><ul><li><br></li></ul><pre>mysql&gt; use testmysql&gt; insert into article (title,content) values ('mysql master and slave','record the cluster building succeed!:)');Query OK, 1 row affected (0.00 sec)</pre><p class=ql-align-justify>查看slave是否自動同步了數據</p><ul><li><br></li></ul><pre>mysql&gt; insert into article (title,content) values ('mysql master and slave','record the cluster building succeed!:)');Query OK, 1 row affected (0.00 sec)</pre><p class=ql-align-justify>至此，主從複製的配置成功！：)</p><blockquote>https://blog.csdn.net/xlgen157387/article/details/52452394</blockquote><p>讀寫分離</p><p>讀寫分離是依賴於主從複製，而主從複製又是為讀寫分離服務的。因為主從複製要求slave不能寫只能讀（如果對slave執行寫操作，那麼show slave status將會呈現Slave_SQL_Running=NO，此時你需要按照前面提到的手動同步一下slave）。</p><p>方案一、定義兩種連接</p><p>就像我們在學JDBC時定義的DataBase一樣，我們可以抽取出ReadDataBase,WriteDataBase implements DataBase，但是這種方式無法利用優秀的線程池技術如DruidDataSource幫我們管理連接，也無法利用Spring AOP讓連接對DAO層透明。</p><p>方案二、使用Spring AOP</p><p>如果能夠使用Spring AOP解決數據源切換的問題，那麼就可以和Mybatis、Druid整合到一起了。</p><p>我們在整合Spring1和Mybatis時，我們只需寫DAO接口和對應的SQL語句，那麼DAO實例是由誰創建的呢？實際上就是Spring幫我們創建的，它通過我們注入的數據源，幫我們完成從中獲取數據庫連接、使用連接執行 SQL 語句的過程以及最後歸還連接給數據源的過程。</p><p>如果我們能在調用DAO接口時根據接口方法命名規範（增addXXX/createXXX、刪deleteXX/removeXXX、改updateXXXX、查selectXX/findXXX/getXX/queryXXX）動態地選擇數據源（讀數據源對應連接master而寫數據源對應連接slave），那麼就可以做到讀寫分離了。（可以參考：Spring 動態切換、添加數據源實現以及源碼淺析）</p><p>負載均衡算法</p><ul><li class=ql-align-justify>輪詢</li><li class=ql-align-justify>加權輪詢：按照處理能力來加權</li><li class=ql-align-justify>負載分配：依據當前的空閒狀態（但是測試每個節點的內存使用率、CPU利用率等，再做比較選出最閒的那個，效率太低）</li></ul><p>高可用</p><p>在服務器架構時，為了保證服務器7x24不宕機在線狀態，需要為每臺單點服務器（由一臺服務器提供服務的服務器，如寫服務器、數據庫中間件）提供冗餘機。（推薦：mysql+mycat搭建穩定高可用集群）</p><p>對於寫服務器來說，需要提供一臺同樣的寫-冗餘服務器，當寫服務器健康時（寫-冗餘通過心跳檢測），寫-冗餘作為一個從機的角色複製寫服務器的內容與其做一個同步；當寫服務器宕機時，寫-冗餘服務器便頂上來作為寫服務器繼續提供服務。對外界來說這個處理過程是透明的，即外界僅通過一個IP訪問服務。</p><h1>典型SQL</h1><p>線上DDL</p><p>DDL(Database Definition Language)是指數據庫表結構的定義（create table）和維護（alter table）的語言。在線上執行DDL，在低於MySQL5.6版本時會導致全表被獨佔鎖定，此時表處於維護、不可操作狀態，這會導致該期間對該表的所有訪問無法響應。但是在MySQL5.6之後，支持Online DDL，大大縮短了鎖定時間。</p><p>優化技巧是採用的維護表結構的DDL（比如增加一列，或者增加一個索引），是copy策略。思路：創建一個滿足新結構的新表，將舊錶數據逐條導入（複製）到新表中，以保證一次性鎖定的內容少（鎖定的是正在導入的數據），同時舊錶上可以執行其他任務。導入的過程中，將對舊錶的所有操作以日誌的形式記錄下來，導入完畢後，將更新日誌在新表上再執行一遍（確保一致性）。最後，新表替換舊錶（在應用程序中完成，或者是數據庫的rename，視圖完成）。</p><p>但隨著MySQL的升級，這個問題幾乎淡化了。</p><p>數據庫導入語句</p><p>在恢復數據時，可能會導入大量的數據。此時為了快速導入，需要掌握一些技巧：</p><p>1.導入時先禁用索引和約束：</p><ul><li><br></li></ul><pre>alter table table-name disable keys</pre><p class=ql-align-justify>待數據導入完成之後，再開啟索引和約束，一次性創建索引</p><ul><li><br></li></ul><pre>alter table table-name enable keys</pre><p>2.數據庫如果使用的引擎是Innodb，那麼它默認會給每條寫指令加上事務（這也會消耗一定的時間），因此建議先手動開啟事務，再執行一定量的批量導入，最後手動提交事務。</p><p>3.如果批量導入的SQL指令格式相同只是數據不同，那麼你應該先prepare預編譯一下，這樣也能節省很多重複編譯的時間。</p><p>limit offset,rows</p><p>儘量保證不要出現大的offset，比如limit 10000,10相當於對已查詢出來的行數棄掉前10000行後再取10行，完全可以加一些條件過濾一下（完成篩選），而不應該使用limit跳過已查詢到的數據。這是一個offset做無用功的問題。對應實際工程中，要避免出現大頁碼的情況，儘量引導用戶做條件過濾。</p><p>select * 要少用</p><p>即儘量選擇自己需要的字段select，但這個影響不是很大，因為網絡傳輸多了幾十上百字節也沒多少延時，並且現在流行的ORM框架都是用的select *，只是我們在設計表的時候注意將大數據量的字段分離，比如商品詳情可以單獨抽離出一張商品詳情表，這樣在查看商品簡略頁面時的加載速度就不會有影響了。</p><p>order by rand()不要用</p><p>它的邏輯就是隨機排序（為每條數據生成一個隨機數，然後根據隨機數大小進行排序）。如select * from student order by rand() limit 5的執行效率就很低，因為它為表中的每條數據都生成隨機數並進行排序，而我們只要前5條。</p><p>解決思路：在應用程序中，將隨機的主鍵生成好，去數據庫中利用主鍵檢索。</p><p>單表和多表查詢</p><p>多表查詢：join、子查詢都是涉及到多表的查詢。如果你使用explain分析執行計劃你會發現多表查詢也是一個表一個表的處理，最後合併結果。因此可以說單表查詢將計算壓力放在了應用程序上，而多表查詢將計算壓力放在了數據庫上。</p><p>現在有ORM框架幫我們解決了單表查詢帶來的對象映射問題（查詢單表時，如果發現有外鍵自動再去查詢關聯表，是一個表一個表查的）。</p><p>count(*)</p><p>在MyISAM存儲引擎中，會自動記錄表的行數，因此使用count(*)能夠快速返回。而Innodb內部沒有這樣一個計數器，需要我們手動統計記錄數量，解決思路就是單獨使用一張表：</p><p>limit 1</p><p>如果可以確定僅僅檢索一條，建議加上limit 1，其實ORM框架幫我們做到了這一點（查詢單條的操作都會自動加上limit 1）。</p><h1>慢查詢日誌</h1><blockquote><p>用於記錄執行時間超過某個臨界值的SQL日誌，用於快速定位慢查詢，為我們的優化做參考。</p></blockquote><p>開啟慢查詢日誌</p><p>配置項：slow_query_log</p><p>可以使用show variables like ‘slov_query_log’查看是否開啟，如果狀態值為OFF，可以使用set GLOBAL slow_query_log = on來開啟，它會在datadir下產生一個xxx-slow.log的文件。</p><p>設置臨界時間</p><p>配置項：long_query_time</p><p>查看：show VARIABLES like 'long_query_time'，單位秒</p><p>設置：set long_query_time=0.5</p><p>實操時應該從長時間設置到短的時間，即將最慢的SQL優化掉</p><p>查看日誌</p><p>一旦SQL超過了我們設置的臨界時間就會被記錄到xxx-slow.log中</p><h1>profile信息</h1><p>配置項：profiling</p><p>開啟profile</p><p>set profiling=on</p><p>開啟後，所有的SQL執行的詳細信息都會被自動記錄下來</p><ul><li><br></li></ul><pre>mysql&gt; show variables like 'profiling';+---------------+-------+| Variable_name | Value |+---------------+-------+| profiling | OFF |+---------------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; set profiling=on;Query OK, 0 rows affected, 1 warning (0.00 sec)</pre><p>查看profile信息</p><p>show profiles</p><ul><li><br></li></ul><pre>mysql&gt; show variables like 'profiling';+---------------+-------+| Variable_name | Value |+---------------+-------+| profiling | ON |+---------------+-------+1 row in set, 1 warning (0.00 sec)mysql&gt; insert into article values (null,'test profile',':)');Query OK, 1 row affected (0.15 sec)mysql&gt; show profiles;+----------+------------+-------------------------------------------------------+| Query_ID | Duration | Query |+----------+------------+-------------------------------------------------------+| 1 | 0.00086150 | show variables like 'profiling' || 2 | 0.15027550 | insert into article values (null,'test profile',':)') |+----------+------------+-------------------------------------------------------+</pre><p>通過Query_ID查看某條SQL所有詳細步驟的時間</p><div class=pgc-img><img alt=全面的MySQL優化面試解析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/8d198d2e-0917-457d-98c4-397f8483391d><p class=pgc-img-caption></p></div><p>show profile for query Query_ID</p><p>上面show profiles的結果中，每個SQL有一個Query_ID，可以通過它查看執行該SQL經過了哪些步驟，各消耗了多場時間</p><h1>典型的服務器配置</h1><blockquote><p>以下的配置全都取決於實際的運行環境</p></blockquote><p>max_connections，最大客戶端連接數</p><ul><li><br></li></ul><pre> mysql&gt; show variables like 'max_connections'; +-----------------+-------+ | Variable_name | Value | +-----------------+-------+ | max_connections | 151 | +-----------------+-------+</pre><p class=ql-align-justify>table_open_cache，表文件句柄緩存（表數據是存儲在磁盤上的，緩存磁盤文件的句柄方便打開文件讀取數據）</p><ul><li><br></li></ul><pre> mysql&gt; show variables like 'table_open_cache'; +------------------+-------+ | Variable_name | Value | +------------------+-------+ | table_open_cache | 2000 | +------------------+-------+</pre><p class=ql-align-justify>key_buffer_size，索引緩存大小（將從磁盤上讀取的索引緩存到內存，可以設置大一些，有利於快速檢索）</p><ul><li><br></li></ul><pre> mysql&gt; show variables like 'key_buffer_size'; +-----------------+---------+ | Variable_name | Value | +-----------------+---------+ | key_buffer_size | 8388608 | +-----------------+---------</pre><p class=ql-align-justify>innodb_buffer_pool_size，Innodb存儲引擎緩存池大小（對於Innodb來說最重要的一個配置，如果所有的表用的都是Innodb，那麼甚至建議將該值設置到物理內存的80%，Innodb的很多性能提升如索引都是依靠這個）</p><ul><li><br></li></ul><pre> mysql&gt; show variables like 'innodb_buffer_pool_size'; +-------------------------+---------+ | Variable_name | Value | +-------------------------+---------+ | innodb_buffer_pool_size | 8388608 | +-------------------------+---------+</pre><p>innodb_file_per_table（innodb中，表數據存放在.ibd文件中，如果將該配置項設置為ON，那麼一個表對應一個ibd文件，否則所有innodb共享表空間）</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>MySQL</a></li><li><a>優化</a></li><li><a>面試</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html alt="深度研究自然梯度優化，從入門到放棄 | Deep Reading" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2cc1b8ef47a5458190c22d26d8bd164c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d54fe0b.html title="深度研究自然梯度優化，從入門到放棄 | Deep Reading">深度研究自然梯度優化，從入門到放棄 | Deep Reading</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>