<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>區塊鏈中的密碼學系列之對稱加密算法DES（六） | 极客快訊</title><meta property="og:title" content="區塊鏈中的密碼學系列之對稱加密算法DES（六） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/c49c7b9451f240e0a851fd35325cbc71"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d119f135.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d119f135.html><meta property="article:published_time" content="2020-11-14T20:50:52+08:00"><meta property="article:modified_time" content="2020-11-14T20:50:52+08:00"><meta name=Keywords content><meta name=description content="區塊鏈中的密碼學系列之對稱加密算法DES（六）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/d119f135.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>區塊鏈中的密碼學系列之對稱加密算法DES（六）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div><h1><strong>1. 前言</strong></h1><p>DES是一種數據加密標準（ Data Encryption Standard） , 有30多年曆史，是一種對稱密碼算法，是第一個得到廣泛應用的密碼算法，是一種分組加密算法，輸入的明文為64位，密鑰為64位（實際上只有56位，原因是每隔7個比特設置一個奇偶校驗位），生成的密文分組長度為64位。但是現在已經不再安全。</p><p>課件來自我們老師上課的PPT。</p><h1><strong>2. Feistel網絡</strong></h1><p>我們可以參考這裡，Feistel講解</p><p>下面簡單說下：</p><p>Feistel網絡利用乘積密碼實現關鍵密碼模塊。所謂乘積密碼就是順序或循環地執行兩個或多個基本密碼模塊，提高密碼強度。其思想就是Shannon提出的利用乘積密碼</p><p>實現擴散和混淆。</p><p>Feistel網絡的加密結構：將2w bit明文分成為左右兩半、長為1 w bit的段，以L和R表示。然後進行n輪迭代，其第i輪迭代的輸入為上一輪（第i-1輪）輸出。</p><p>其中Ki是第i輪用的子密鑰， f是密碼設計者選取或設計密碼輪函數。 稱這種分組密碼算法為Feistel網絡（ Feistel Network） ， 它保證加密和解密可採用同一算法實施。</p><p>每次迭代稱為一輪(Round)。 相應函數f 稱作輪函數。</p><p>Feistel網絡的解密結構：Feistel解密過程本質上與加密過程一樣。密文作為輸入，使用子密鑰Ki的次序與加密過程相反， Kn,Kn-1,…,K1。保證了加密與解密過程可採用同一算法。</p><h1><strong>3. DES算法框架</strong></h1><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c49c7b9451f240e0a851fd35325cbc71><p class=pgc-img-caption></p></div><p>輪函數：</p><p>Li=Ri-1；</p><p>Ri=Li-1⊕f(Ri-1, Ki)。</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b287f88b287b4d6d8c7db7f3205c229a><p class=pgc-img-caption></p></div><h1><strong>4. DES加密模塊</strong></h1><p><strong>4.1 初始置換IP</strong></p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4f977ffa68144a23a9f647d4b48a2fe0><p class=pgc-img-caption></p></div><p><strong>4.2 DES的輪結構</strong></p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/120de86c8d634677a308513617732732><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a0c075edc0a408bbd920050053773d1><p class=pgc-img-caption></p></div><p>擴充變換：擴充變換E的作用是將32比特的明文擴充為48比特。設m=m1m2…m31m32; c=c1c2…c47c48。滿足E(m)=c， c1=m32,c2=m1,…,c7=m4,…,c48=m1。</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0ed491e56c834db797ff9498df6c1ae8><p class=pgc-img-caption></p></div><p>8個S盒：</p><p>每個S盒Sj將6比特輸入縮減為4比特輸出。 8個S盒總共將48比特輸入縮減為32比特輸出。</p><p>每個S盒的輸入為6比特串m=m1m2m3m4m5m6，輸出為4比特串c=c1c2c3c4。</p><p>將m1m6, m2m3m4m5, c1c2c3c4都用10進制來表示，則在下表中位於m1m6 (0~3)行 m2m3m4m5 (0~15)列的數就是S盒的輸出 c1c2c3c4(十進制轉化成二進制)。</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a5a94e776c6d43e79cbd86faeb837f1c><p class=pgc-img-caption></p></div><p>例如若S1的輸入為100110，則通過查表(S1)輸出應該是表中的第2(10)行第3(0011)列的數字8，所以二進制輸出為1000。</p><p>置換P:</p><p>置換P將32比特的輸入，改變位置順序：輸出的第1位為輸入的第16位，輸出的第2位為輸入的第7位， …，輸出的第32位為輸入的第25位。</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6eda9595628548bc8b0324ad7b24010d><p class=pgc-img-caption></p></div><p><strong>4.3 子密鑰生成算法</strong></p><p>64位密鑰（8位奇偶校驗位，有效位為56位）經過置換選擇1、循環左移、置換選擇2等變換，產生出16個48位長的子密鑰。</p><p>置換選擇1：</p><p>64位密鑰分為8個字節。每個字節的前7位是真正的密鑰位，第8位是奇偶校驗位。奇偶校驗位可以從前7位密鑰位計算得出，不是隨機的，因而不起密鑰的作用。因此，DES真正的密鑰只有56位。</p><p>置換選擇1的作用有兩個：一是從64位密鑰中去掉8個奇偶校驗位；二是把其餘56位密鑰位打亂重排，且將前28位作為C0，後28位作為D0。</p><p>置換選擇1的矩陣如下：</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/af15af25ccc1499e96ac9896b0641a10><p class=pgc-img-caption></p></div><p>循環左移：</p><p>每一次迭代，將Ci-1和Di-1按照一定的位數循環左移分別得到Ci和Di。</p><p>　　循環左移位數表如下：</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6f48fb90fae483eb050f359feccc984><p class=pgc-img-caption></p></div><p>置換選擇2</p><p>將Ci和Di合併成一個56位的中間數據，置換選擇2從中選擇出一個48位的子密鑰Ki。置換選擇2的矩陣如下：</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2a45c0f0e25d4eff8c93e5d822fedba0><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cea69342f9344c7dbc864bd738ffc4e2><p class=pgc-img-caption></p></div><p>縮減變換PC-1, PC-2 : PC-1將64比特串縮為56比特； PC-2將56比特長的串縮為48比特。兩個變換的輸出比特順序如下：</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c142aaf893764321823834253e7748a8><p class=pgc-img-caption></p></div><h1><strong>5. DES的加解密過程</strong></h1><p>DES的加密過程：</p><ol><li>64位密鑰經子密鑰產生算法產生出16個48位子密鑰：K1,K2,...,K16，分別供第1次，第2次，...，第16次加密迭代使用。</li><li>64位明文首先經過初始置換IP，將數據打亂重新排列並分成左右兩半，左邊32位構成L0，右邊32位構成R0。</li><li>第i次加密迭代：由輪函數f實現子密鑰Ki對Ri-1的加密，結果為32位的數據組f ( Ri-1 , Ki )。f ( Ri-1 , Ki )再與Li-1模2相加，又得到一個32位的數據組Li-1 ⊕ f ( Ri-1 , Ki )。以Li ⊕ f ( Ri-1 , Ki )作為下一次加密迭代的Ri，以Ri-1作為下一次加密迭代的Li ( i = 1,2,...,16)。</li><li>按照上一步的規則進行16次加密迭代。</li><li>第16次加密迭代結束後，以R16為左，L16為右，合併產生一個64位的數據組。再經過逆初始置換IP-1，將數據重新排列，便得到64位密文。</li></ol><p>DES的解密過程：</p><ol><li>64位密鑰經子密鑰產生算法產生出16個48位子密鑰：K1,K2,...,K16，分別供第1次，第2次，...，第16次解密迭代使用。</li><li>64位密文首先經過初始置換IP，將數據打亂重新排列並分成左右兩半，左邊32位構成R16，右邊32位構成L16。</li><li>第17-i次解密迭代：由輪函數f實現子密鑰Ki對Li的解密，結果為32位的數據組f ( Li , Ki )。f ( Li , Ki )再與Ri模2相加，又得到一個32位的數據組Ri ⊕ f ( Li , Ki )。以Ri ⊕ f ( Li , Ki )作為下一次解密迭代的Li-1，以Li作為下一次解密迭代的Li-1 ( i = 16,15,...,1)。</li><li>按照上一步的規則進行16次解密迭代。</li><li>第16次解密迭代結束後，以L0為左，R0為右，合併產生一個64位的數據組。再經過逆初始置換IP-1，將數據重新排列，便得到64位明文。</li></ol><h1><strong>6. DES的安全性</strong></h1><p>DES算法中除了S盒是非線性變換外，其餘變換均為線性變換，所以DES安全的關鍵是S盒（保密 ）。因為算法中使用了16次迭代，從而使得改變輸入明文或密鑰中的1位，密文都會發生大約32位的變化，具有良好的雪崩效應，大大提高了保密性。S盒用來提供混淆，使明文、密鑰、密文之間的關係錯綜複雜，而P置換用來提供擴散，把S盒提供的混淆作用充分擴散開來。這樣，S盒和P置換互相配合，形成了很強的抗差分攻擊和抗線性攻擊能力，其中抗差分攻擊能力更強些。</p><h1><strong>7. DES加密的一個例子</strong></h1><p>取16進制明文X： 0123456789ABCDEF</p><p>密鑰K為： 133457799BBCDFF1</p><p>去掉奇偶校驗位以二進制形式表示的密鑰是</p><p>00010010011010010101101111001001101101111011011111</p><p>111000</p><p>應用IP，我們得到：</p><p>L0=11001100000000001100110011111111</p><p>L1=R0=11110000101010101111000010101010</p><p>然後進行16輪加密。</p><p>最後對L16, R16使用IP-1得到密文： 85E813540F0AB405</p><h1><strong>8. java版的DES算法</strong></h1><p>DES工具類：</p><pre>public class DESUtil { //置換選擇1矩陣 static int[] replace1C = { 57, 49, 41, 33, 25, 17, 9,  1, 58, 50, 42, 34, 26, 18,  10, 2, 59, 51, 43, 35, 27,  19, 11, 3, 60, 52, 44, 36 }; static int[] replace1D = { 63, 55, 47, 39, 31, 23, 15,  7, 62, 54, 46, 38, 30, 22,  14, 6, 61, 53, 45, 37, 29,  21, 13, 5, 28, 20, 12, 4 };​ //循環左移位數表 static int[] moveNum = {1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};​ //置換選擇2矩陣 static int[] replace2 = { 14, 17, 11, 24, 1, 5,  3, 28, 15, 6, 21, 10,  23, 19, 12, 4, 26, 8,  16, 7, 27, 20, 13, 2,  41, 52, 31, 37, 47, 55,  30, 40, 51, 45, 33, 48,  44, 49, 39, 56, 34, 53,  46, 42, 50, 36, 29, 32 };​ //初始置換矩陣 static int[] IP = { 58, 50, 42, 34, 26, 18, 10, 2,  60, 52, 44, 36, 28, 20, 12, 4,  62, 54, 46, 38, 30, 22, 14, 6,  64, 56, 48, 40, 32, 24, 16, 8,  57, 49, 41, 33, 25, 17, 9, 1,  59, 51, 43, 35, 27, 19, 11, 3,  61, 53, 45, 37, 29, 21, 13, 5,  63, 55, 47, 39, 31, 23, 15, 7 };​ //選擇運算矩陣 static int[] E = { 32, 1, 2, 3, 4, 5,  4, 5, 6, 7, 8, 9,  8, 9, 10, 11, 12, 13,  12, 13, 14, 15, 16, 17,  16, 17, 18, 19, 20, 21,  20, 21, 22, 23, 24, 25,  24, 25, 26, 27, 28, 29,  28, 29, 30, 31, 32, 1 };​ //代替函數組 static int[][][] S = { //S1 { {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},  { 0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},  { 4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},  {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13} },  //S2 { {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},  { 3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},  { 0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},  {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9} },  //S3 { {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},  {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},  {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},  { 1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12} },  //S4 { { 7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},  {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},  {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},  { 3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14} },  //S5 { { 2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},  {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},  { 4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},  {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3} },  //S6 { {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},  {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},  { 9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},  { 4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13} },  //S7 { { 4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},  {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},  { 1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},  { 6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12} },  //S8 { {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},  { 1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},  { 7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},  { 2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11} } };​ //置換運算矩陣 static int[] P = { 16, 7, 20, 21,  29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,  2, 8, 24, 14,  32, 27, 3, 9,  19, 13, 30, 6,  22, 11, 4, 25 };​ //逆初始置換矩陣 static int[] rIP = { 40, 8, 48, 16, 56, 24, 64, 32,  39, 7, 47, 15, 55, 23, 63, 31,  38, 6, 46, 14, 54, 22, 62, 30,  37, 5, 45, 13, 53, 21, 61, 29,  36, 4, 44, 12, 52, 20, 60, 28,  35, 3, 43, 11, 51, 19, 59, 27,  34, 2, 42, 10, 50, 18, 58, 26,  33, 1, 41, 9, 49, 17, 57, 25 };​/***************************子密鑰的產生**********************************************************************/ /** * 子密鑰的產生 * @param sKey 64位密鑰 * @return 16個48位子密鑰 */ static byte[][] generateKeys(byte[] sKey) { byte[] C = new byte[28]; byte[] D = new byte[28]; byte[][] keys = new byte[16][48]; //置換選擇1 //一是從64位密鑰中去掉8個奇偶校驗位；二是把其餘56位密鑰位打亂重排 for (int i = 0; i &lt; 28; i++) { C[i] = sKey[replace1C[i] - 1]; D[i] = sKey[replace1D[i] - 1]; }​ for (int i = 0; i &lt; 16; i++) { //循環左移 C = RSHR(C, moveNum[i]); D = RSHR(D, moveNum[i]); //置換選擇2 for (int j = 0; j &lt; 48; j++) { if (replace2[j] &lt;= 28)  keys[i][j] = C[replace2[j] - 1]; else  keys[i][j] = D[replace2[j] - 29]; } } return keys; } /** * 循環左移 * @param b 數組 * @param n 位數 * @return */ static byte[] RSHR(byte[] b, int n) { String s = new String(b); s = (s + s.substring(0, n)).substring(n); return s.getBytes(); }​/**********************初始置換IP**************************************************************************/ /** * 初始置換IP * @param text 64位數據 * @return */ static byte[] IP(byte[] text) { byte[] newtext = new byte[64]; for (int i = 0; i &lt; 64; i++)  newtext[i] = text[IP[i] - 1]; return newtext; }​/**********************輪函數**************************************************************************/ /** * 輪函數 * @param A 32位輸入 * @param K 48位子密鑰 * @return 32位輸出 */ static byte[] f(byte[] A, byte[] K) { byte[] t = new byte[48]; byte[] r = new byte[32]; byte[] result = new byte[32]; //選擇運算E,擴充變換為48bit for (int i = 0; i &lt; 48; i++)  t[i] = A[E[i] - 1]; //模2相加，逐位異或，得到一個48位的結果 for (int i = 0; i &lt; 48; i++)  t[i] = (byte) (t[i] ^ K[i]); //代替函數組S， 8個S盒總共將48比特輸入縮減為32比特輸出。 for (int i = 0, a = 0; i &lt; 48; i += 6, a += 4) { int j = t[i] * 2 + t[i + 5]; //b1b6 int k = t[i + 1] * 8 + t[i + 2] * 4 + t[i + 3] * 2 + t[i + 4]; //b2b3b4b5 byte[] b = Integer.toBinaryString(S[i / 6][j][k] + 16).substring(1).getBytes(); for (int n = 0; n &lt; 4; n++)  r[a + n] = (byte) (b[n] - '0'); } //置換運算P，重新打亂順序輸出 for (int i = 0; i &lt; 32; i++)  result[i] = r[P[i] - 1]; return result; }/**********************逆初始置換IP^-1**************************************************************************/ /** * 逆初始置換IP^-1 * @param text 64位數據 * @return */ static byte[] rIP(byte[] text) { byte[] newtext = new byte[64]; for (int i = 0; i &lt; 64; i++)  newtext[i] = text[rIP[i] - 1]; return newtext; }}</pre><p>DES實現類：</p><pre>public class DES { /** * 加密 * @param plaintext 64位明文 * @param sKey 64位密鑰 * @return 64位密文 */ static byte[] encrypt(byte[] plaintext, byte[] sKey) { byte[][] L = new byte[17][32]; byte[][] R = new byte[17][32]; byte[] ciphertext = new byte[64]; //子密鑰的產生 byte[][] K = DESUtil.generateKeys(sKey); //初始置換IP plaintext = DESUtil.IP(plaintext); //將明文分成左半部分L0和右半部分R0 for (int i = 0; i &lt; 32; i++) { L[0][i] = plaintext[i]; R[0][i] = plaintext[i + 32]; } //加密迭代 for (int i = 1; i &lt;= 16; i++) { L[i] = R[i - 1]; R[i] = xor(L[i - 1], DESUtil.f(R[i - 1], K[i - 1])); } //以R16為左半部分，L16為右半部分合並 for (int i = 0; i &lt; 32; i++) { ciphertext[i] = R[16][i]; ciphertext[i + 32] = L[16][i]; } //逆初始置換IP^-1 ciphertext = DESUtil.rIP(ciphertext); return ciphertext; }​ /** * 解密 * @param ciphertext 64位密文 * @param sKey 64位密鑰 * @return 64位明文 */ static byte[] decrypt(byte[] ciphertext, byte[] sKey) { byte[][] L = new byte[17][32]; byte[][] R = new byte[17][32]; byte[] plaintext = new byte[64]; //子密鑰的產生 byte[][] K = DESUtil.generateKeys(sKey); //初始置換IP ciphertext = DESUtil.IP(ciphertext); //將密文分成左半部分R16和右半部分L16 for (int i = 0; i &lt; 32; i++) { R[16][i] = ciphertext[i]; L[16][i] = ciphertext[i + 32]; } //解密迭代 for (int i = 16; i &gt;= 1; i--) { L[i - 1] = xor(R[i], DESUtil.f(L[i], K[i - 1])); R[i - 1] = L[i]; R[i] = xor(L[i - 1], DESUtil.f(R[i - 1], K[i - 1])); } //以L0為左半部分，R0為右半部分合並 for (int i = 0; i &lt; 32; i++) { plaintext[i] = L[0][i]; plaintext[i + 32] = R[0][i]; } //逆初始置換IP^-1 plaintext = DESUtil.rIP(plaintext); return plaintext; }​ /** * 兩數組異或 * @param a * @param b * @return */ static byte[] xor(byte[] a, byte[] b) { byte[] c = new byte[a.length]; for (int i = 0; i &lt; a.length; i++)  c[i] = (byte) (a[i] ^ b[i]); return c; }}</pre><p>DES測試：</p><pre>​public class TestDES { public static void main(String[] args) { String strKey = "0011000100110010001100110011010000110101001101100011011100111000"; byte[] sKey = strKey.getBytes(); for (int i = 0; i &lt; sKey.length; i++)  sKey[i] -= '0'; System.out.print("密鑰："); printByteArr(sKey); String strPlain = "0011000000110001001100100011001100110100001101010011011000110111"; byte[] plaintext = strPlain.getBytes(); for (int i = 0; i &lt; plaintext.length; i++)  plaintext[i] -= '0'; System.out.print("明文："); printByteArr(plaintext); byte[] ciphertext = DES.encrypt(plaintext, sKey); System.out.print("密文："); printByteArr(ciphertext); byte[] plainText = DES.decrypt(ciphertext, sKey); System.out.print("明文："); printByteArr(plainText); }​ static void printByteArr(byte[] b) { for (int i = 0; i &lt; b.length; i++) { System.out.print(b[i]); if (i % 8 == 7)  System.out.print(" "); } System.out.println(); }}</pre><p>測試結果：</p><div class=pgc-img><img alt=區塊鏈中的密碼學系列之對稱加密算法DES（六） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d651a2f582604a31b04460a2d2b85c4a><p class=pgc-img-caption></p></div><h1><strong>9. 3DES</strong></h1><p>為提高安全性， 並利用實現DES的現有軟硬件， 將DES算法在多密鑰下重複使用。</p><p>三重DES：</p><p>兩個密鑰的三重DES。C=Ek1[Dk2[Ek1[P]]]</p><p>三個密鑰的三重DES。C=Ek3[Dk2[Ek1[P]]]</p><h1><strong>10. 結束語</strong></h1><p>我們學習了DES加密算法。DES作為對稱加密，其實現還是比較複雜的。我們來簡單回顧下，DES的加密過程。首先，我們需要生成16*48位的子密鑰（子密鑰的生成需要三步，即置換選擇1，循環左移和置換選擇2）。然後執行輪函數（分為四步，分別是擴充變換E，與密鑰按位異或，S盒變換，P盒變換）。最後進行逆初始變換即可得到加密後的密文。</p><p>解密與之類似。不再贅述。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>加密算法</a></li><li><a>區塊</a></li><li><a>密碼學</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6eaf5d1.html alt=區塊鏈中的密碼學 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6eaf5d1.html title=區塊鏈中的密碼學>區塊鏈中的密碼學</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a06ff55.html alt=區塊鏈上的隨機性：概述與構造 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RJjGCjxAt6MQlC style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a06ff55.html title=區塊鏈上的隨機性：概述與構造>區塊鏈上的隨機性：概述與構造</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15f60fea.html alt=此地無人生還：區塊鏈隨機數的原罪與救贖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153820081912869d8e48468 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15f60fea.html title=此地無人生還：區塊鏈隨機數的原罪與救贖>此地無人生還：區塊鏈隨機數的原罪與救贖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a382d16d.html alt="區塊鏈入門：為什麼 DApp 經常會遭遇隨機數攻擊？| 火星技術帖" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RivR6n1AU5yy8h style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a382d16d.html title="區塊鏈入門：為什麼 DApp 經常會遭遇隨機數攻擊？| 火星技術帖">區塊鏈入門：為什麼 DApp 經常會遭遇隨機數攻擊？| 火星技術帖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3ef1b57.html alt=清華-泰嶽區塊鏈，公益培訓第10堂內容-區塊鏈整體結構解析1 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bb90db89a11643b7a657bcdb3f60a8bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3ef1b57.html title=清華-泰嶽區塊鏈，公益培訓第10堂內容-區塊鏈整體結構解析1>清華-泰嶽區塊鏈，公益培訓第10堂內容-區塊鏈整體結構解析1</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/81eb1a1d.html alt=區塊鏈研究實驗室｜減少智能合約代碼複雜性並提高可維護性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7087a95e358c43079138036c9e6c423d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81eb1a1d.html title=區塊鏈研究實驗室｜減少智能合約代碼複雜性並提高可維護性>區塊鏈研究實驗室｜減少智能合約代碼複雜性並提高可維護性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bde3f46.html alt=區塊鏈近日資訊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/50a2000353f961507482 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bde3f46.html title=區塊鏈近日資訊>區塊鏈近日資訊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/61368252.html alt=勁爆！區塊鏈最大騙局資金盤崩盤，別再當韭菜傻傻被割了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/da73541c9517466d9532f34f58af6ef0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/61368252.html title=勁爆！區塊鏈最大騙局資金盤崩盤，別再當韭菜傻傻被割了>勁爆！區塊鏈最大騙局資金盤崩盤，別再當韭菜傻傻被割了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1402f6fe.html alt=看不見的區塊鏈，其實它已能在這些領域廣泛應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f92d2171f8274c739fc49f2428a7b61c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1402f6fe.html title=看不見的區塊鏈，其實它已能在這些領域廣泛應用>看不見的區塊鏈，其實它已能在這些領域廣泛應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b9fdd89.html alt=未來科技城核心區塊地下空間正式竣工！良睦路工程也在加速建設 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RuzgnQR9Gc5JYR style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b9fdd89.html title=未來科技城核心區塊地下空間正式竣工！良睦路工程也在加速建設>未來科技城核心區塊地下空間正式竣工！良睦路工程也在加速建設</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32ee6540.html alt=JAVA上加密算法的實現用例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6aa97b7dfebc473ebb4ea11cc67c6614 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32ee6540.html title=JAVA上加密算法的實現用例>JAVA上加密算法的實現用例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6eee2a30.html alt=區塊鏈在保險、銀行及旅遊行業中的有趣用例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4b6a0499fcef4a09ace23006b2802267 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6eee2a30.html title=區塊鏈在保險、銀行及旅遊行業中的有趣用例>區塊鏈在保險、銀行及旅遊行業中的有趣用例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8630a63.html alt="能源區塊鏈研究 | 能源行業區塊鏈用例" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S40LibjAaCDyQv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8630a63.html title="能源區塊鏈研究 | 能源行業區塊鏈用例">能源區塊鏈研究 | 能源行業區塊鏈用例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67f8c5f1.html alt=密碼學與信息安全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15402825355051270036abe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67f8c5f1.html title=密碼學與信息安全>密碼學與信息安全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/08183e2f.html alt=一文看懂主流區塊鏈攻擊底層邏輯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RyIdkeJ1kFauOL style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/08183e2f.html title=一文看懂主流區塊鏈攻擊底層邏輯>一文看懂主流區塊鏈攻擊底層邏輯</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>