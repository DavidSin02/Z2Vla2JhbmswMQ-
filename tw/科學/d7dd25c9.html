<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>基礎渲染系列（一）圖形學的基石——矩陣 | 极客快訊</title><meta property="og:title" content="基礎渲染系列（一）圖形學的基石——矩陣 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/a9bc08327dbf4f0e921768dab663ef7b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/d7dd25c9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/d7dd25c9.html><meta property="article:published_time" content="2020-11-14T20:52:19+08:00"><meta property="article:modified_time" content="2020-11-14T20:52:19+08:00"><meta name=Keywords content><meta name=description content="基礎渲染系列（一）圖形學的基石——矩陣"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/d7dd25c9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>基礎渲染系列（一）圖形學的基石——矩陣</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><p>本文重點內容：</p><p>1、創建一個立方體構建的Grid網格</p><p>2、支持縮放、位移、旋轉</p><p>3、變換矩陣</p><p>4、創建簡單的相機投影</p><blockquote class=js_blockquote_wrap><p>譯註：從原創作者博客轉為公眾號文章非常複雜，我需要先將原文翻譯一遍，然後在公眾號再排版一遍。公眾號編輯十分不方便，尤其是原作者的代碼風格、圖片格式、數學公式、動圖、視頻、引用Tips等等都需要二次導入和格式轉換。加上原作者每篇的內容非常長，編輯起來非常耗時，非常累。</p><p><br></p><p>另外，我對比了一下使用源碼引用和截圖在公眾號的閱讀體驗，覺得截圖的體驗要好於源碼引用。截圖既能保留原作者源碼風格，又能在手機上有良好的閱讀體驗。</p><p><br></p><p>代碼的黃色部分，是指在原有代碼基礎上變化的部分，完整源碼會在後臺通過回覆關鍵字獲取。</p></blockquote><p><br></p><p>這是基礎渲染課程系列的第一部分，主要涵蓋變換矩陣相關的內容。如果你還不清楚Mesh是什麼或者怎麼工作的，可以轉到Mesh Basics 相關的章節去了解（譯註：Mesh Basics系列皆已經翻譯完畢，但與本系列主題關聯不大，講完4個渲染系列之後，再放出來）。這個系列會講，這些Mesh是如何最終變成一個像素呈現在顯示器上的。</p><p><br></p><p>該示例使用Unity5.3.1（譯註：實測2018.4版本沒有問題）。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a9bc08327dbf4f0e921768dab663ef7b><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>1 空間可視化</h1><p>你已經知道什麼是Mesh網格以及如何在場景中對其進行定位了。但是這種定位實際上是如何完成的呢？著色器如何知道在哪裡繪製？當然，我們可以僅依靠Unity的transform組件和著色器來完成所有工作，但是如果你想獲得完全控制權，那麼瞭解實際發生的底層原理則至關重要。</p><p><br></p><p>為了完全理解此過程，最好創建自己的實現。移動，旋轉和縮放網格是通過操縱其頂點的位置來完成的。這屬於空間上的變換，因此要在實際中看到它，我們必須使空間可見。可以通過創建用“點”組成的3D網格來實現。點可以是任何預製件。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9eebc0d1fdc64588bac5c4a9fa0f19e3><p class=pgc-img-caption></p></div><p><br></p><p>創建一個點，實際上就是實例化預製件，確定其座標併為其賦予獨特的顏色。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/23a8199aeef04a36b9127eb3e57e9ab1><p class=pgc-img-caption></p></div><p><br></p><p>網格最明顯的形狀是一個立方體，所以讓我們開始吧。我們將其以原點為中心，因此變換（尤其是旋轉和縮放）相對於網格立方體的中點。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c8fd0f725b249b882961d7230191715><p class=pgc-img-caption></p></div><p>我將使用默認的立方體作為預製對象，將其縮放為一半大小，以便在它們之間留出空間。</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/979144746ebe4ceda8195f10f14ba0ba><p class=pgc-img-caption></p></div><p>（縮小立方體預置）</p><p><br></p><p>創建一個網格對象，添加我們的組件，並連接預製件。進入播放模式時，將會以我們對象的本地原點為中心出現方格。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/640bb8e270e14d7ebc2273399a2fa4ac><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/30d3fa9c4c784a089676cb3446b123f8><p class=pgc-img-caption></p></div><p>（Transformations Grid）</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>2 Transformations</p><p>理想情況下，我們應該能夠對Grid應用任意數量的轉換。 以及各種不同類型的轉換，但為了和Unity的理解一致，將只限制在位置，旋轉和縮放上。</p><p><br></p><p>如果我們為每個Transform創建一個組件類型，就可以按照所需的任何順序和數量將它們添加到Grid對象中。 而且，儘管每個Transform的細節都不同，但它們都需要一種方法將自己應用於空間點。</p><p><br></p><p>讓我們為所有的Transform組件創建一個可以繼承的基類。 它是一個抽象類，這意味著它不能直接使用。 給它一個抽象的Apply方法，具體的轉換組件將使用它來完成其工作。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bb1dd4bda322489e83309d94488cc3cf><p class=pgc-img-caption></p></div><p><br></p><p>將此類組件添加到網格對象後，就必須以某種方式檢索它們，以便將其應用於所有網格點。我們將使用通用List來存儲對這些組件的引用。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bd7587340fb1485293e805f6252ac276><p class=pgc-img-caption></p></div><p>現在我們可以添加一個Update方法來檢索Transform，然後遍歷整個網格並轉換所有點。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/047f1f58911c4b9d8ff4673d9755aa66><p class=pgc-img-caption></p></div><blockquote class=js_blockquote_wrap><p>為什麼要在Update獲取組件？</p><p>這樣就可以在保持播放模式的同時使用Transform組件，並立即看到結果。</p></blockquote><p><br></p><blockquote class=js_blockquote_wrap><p>為什麼使用List而不是數組？</p><p>GetComponents方法的最直接的版本只是返回一個包含請求類型的所有組件的數組。 這意味著每次調用都會創建一個新數組，在本例中是每次Update。 替代版本具有列表參數。 這樣做的好處是它將把組件放到列表中，而不是創建一個新的數組。</p><p>但在我看來，這不是一個關鍵的優化，但是當你需要經常獲取組件時，使用list是個好習慣。</p></blockquote><p><br></p><p>通過獲取原始座標，然後應用每個變換來完成每個點的變換。 但不能依靠每個點的實際位置，因為已經對它們進行了變換，並且我們不想在每個幀上累積變換。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c9bf0ce016f141f3b7edf98b57222def><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>2.1 轉換</p><p>我們的第一個具體組成部分是Transform，這是最簡單的。因此，創建一個擴展了Transformation的新組件，並將其位置用作局部偏移。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ebd1fb185c39454c9d49a361eb547ad5><p class=pgc-img-caption></p></div><p><br></p><p>現在，編譯器將報錯說沒有提供Apply的具體版本，所以我們給它一個吧。只需將所需位置添加到原始點即可。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f98cbad5382e4cafb12305256d2d5456><p class=pgc-img-caption></p></div><p><br></p><p>現在，你可以將位置轉換組件添加到我們的網格對象中。這讓我們可以移動“點”，而無需移動實際的網格對象。我們所有的轉換都發生在對象的局部空間中。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bc1dec8b4ed84942b0d0acf420ffd7ad><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c17d7615a9234e579445e312a4727218><p class=pgc-img-caption></p></div><p>（變換位置）</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>2.2 縮放</p><p>接下來是縮放轉換。它與位置處理方式幾乎相同，只是比例分量被乘而不是被添加到原始點。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/13e7043fc7e845a18ad31e9c1b070cef><p class=pgc-img-caption></p></div><p><br></p><p>也把該組件添加到我們的網格對象中。現在我們也可以縮放網格。請注意，我們僅調整網格點的位置，因此縮放不會更改其可視化效果的大小。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a28d6e08c02f417488422fa181c0312d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3adb34a51cc1471a9e86034a2fb9e710><p class=pgc-img-caption></p></div><p>（調整縮放）</p><p><br></p><p>一次操作中嘗試執行定位和縮放。 你會發現比例尺也會影響位置。 發生這種情況是因為我們首先重新定位空間，然後對其進行縮放。但Unity的transform組件是反過來實現的，所以，我們也應該調整下腳本執行的順序，這可以通過重新排序組件來完成。 通過每個組件右上角齒輪圖標下的彈出菜單移動它們。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fa3d65a11e8447c3b173a5f1a60a398f><p class=pgc-img-caption></p></div><p>（修改組件順序）</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>2.3 旋轉</p><p>第三種變換類型是旋轉。比前兩個要困難一些。我們從一個新組件開始，該組件將返回沒有變化的點。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ed76898e37db4d66a1f7eae422ab5dfb><p class=pgc-img-caption></p></div><p><br></p><p>那麼旋轉該如何實現呢？ 它需要限制自己繞單個軸（Z軸）旋轉。 圍繞該軸旋轉點就像旋轉一個輪子。 由於Unity使用左手座標系，因此在Z軸正方向觀看時，正向旋轉會使車輪逆時針旋轉。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ef8e59caee5f4c9e83e45edbd746b559><p class=pgc-img-caption></p></div><p>（繞著Z軸的2D旋轉）</p><p><br></p><p>一個點旋轉時會發生什麼變化呢？ 最簡單的考慮點位於半徑為一個單位的圓（單位圓）上的點。 最直接的點對應於X和Y軸。 如果將這些點旋轉90°，則總是以0、1或-1結束。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01c53b8287fd4d3cb1044e651db583c4><p class=pgc-img-caption></p></div><p>（將（1,0）和（0,1）分別旋轉90和180度）</p><p><br></p><p>第一步之後，點（1,0）變為（0,1）。 下一步將其設置為（−1,0）。 然後是（0，-1），最後回到（1,0）。</p><p><br></p><p>如果我們從點（0,1）開始，則與之前的序列相比，我們僅領先一步。</p><p><br></p><p>我們從（0,1）到（−1,0）到（0，−1）到（1,0）再返回。 因此，我們的點的座標經歷了循環0、1、0，-1。 他們只是有不同的起點而已。</p><p><br></p><p>如果改為以45°增量旋轉怎麼辦？ 這將產生位於XY平面對角線上的點。 由於到原點的距離沒有變化，因此我們必須以（±√½，±√½）形式的座標結束。 這將我們的週期擴展為0，√½，1，√½，0，-√½，-1，-√½。 如果不斷減小步長，則最終會出現正弦波。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a520931500fa44e9bdfde9f7c7db34a5><p class=pgc-img-caption></p></div><p>（正弦和餘弦）</p><p><br></p><p>在我們例子裡，從（1,0）開始，正弦波與y座標匹配。 餘弦與x座標匹配。 這意味著我們可以將（1,0）重新定義為（cos z，sin z）（cosz，sinz）。 同樣，我們可以將（0,1）替換為（-sin z，cos z）（-sinz，cosz）。</p><p><br></p><p>因此，我們首先計算圍繞Z軸所需旋轉的正弦和餘弦。提供以度為單位的角度，但是正弦和餘弦使用弧度，因此必須進行轉換。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/67127194b3aa4a84a3a6c99adc064b51><p class=pgc-img-caption></p></div><p><br></p><blockquote class=js_blockquote_wrap><p>什麼是弧度？</p><p>像度數一樣，它們可以用作旋轉的量度。 使用單位圓時，弧度與您沿其圓周行進的距離匹配。 由於圓周的長度等於圓半徑的2π倍，因此1個弧度等於π/ 180度。</p><p>在這裡你還可以看到π的定義。 它是圓的周長與其直徑之比。</p></blockquote><p><br></p><p>很高興我們找到了一種旋轉（1,0）和（0,1）的方法，但是旋轉任意點呢？ 好吧，這兩點定義了X和Y軸。 我們可以將任何2D點（x，y）分解為 xX + yY。 沒有任何旋轉，它等於x（1,0）+ y（0,1），實際上的確是（x，y）。 但是當旋轉時，我們現在可以使用x（cos Z，sin Z）+ y（-sin Z，cos Z）並得到正確旋轉的點。 你可以將其視為縮放點，使其落在單位圓上，旋轉然後再縮小。 壓縮成一個座標對，它變成（xcosZ-ysinZ，xsinZ + ycosZ）。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ace2cc6cb1f4705888a53ecb156d214><p class=pgc-img-caption></p></div><p><br></p><p>將旋轉組件添加到網格，並將其作為中間轉換。 這意味著我們首先縮放，然後旋轉，最後重新定位，這也是Unity的Transform組件所做的。 當然，目前僅支持圍繞Z旋轉。 稍後我們將處理其他兩個軸。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b92ace1f904d4957aae241a97aca039e><p class=pgc-img-caption></p></div><p>（所有的三個轉換效果）</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>3 完全體的旋轉</p><p>現在，我們只能繞Z軸旋轉。 為了提供與Unity變換組件相同的旋轉支持，我們還必須啟用圍繞X和Y軸的旋轉。 孤立地繞這些軸旋轉的實現就類似於繞Z旋轉，但同時繞多個軸旋轉則變得更加複雜。 為了解決這個問題，我們可以使用更好的方法來寫下旋轉數學。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.1 矩陣</p><p>從現在開始，我們將垂直而不是水平地寫入點的座標。用</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e4f8c2488ce4c6682180964319eab1d><p class=pgc-img-caption></p></div><p><br></p><p>的寫法代替（x,y）。同樣的使用</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d6ede33addfd44b68c928e7f10770918><p class=pgc-img-caption></p></div><p><br></p><p>代替（xcosZ−ysinZ,xsinZ+ycosZ）。這樣閱讀更加容易一些。請注意，x和y因子最終排列在垂直列中，表示一個2D乘法。 實際上，我們執行的乘法是</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/75cf51c8c6444b328372550338bdf390><p class=pgc-img-caption></p></div><p>，</p><p><br></p><p>這是矩陣乘法。2 x 2矩陣的第一列表示X軸，第二列表示Y軸。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d508c8b01edb49b7ae736c2bd702092f><p class=pgc-img-caption></p></div><p>（用2D的矩陣定義X和Y軸）</p><p><br></p><p>通常，將兩個矩陣相乘時，在第一個矩陣中逐行，在第二個矩陣中逐列。 結果矩陣中的每個項是一行的項總和乘以一列的相應項之和。 這意味著第一矩陣的行和第二矩陣的列必須具有相同數量的元素。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b1e99430eb2d42e38537b24d46c7d48f><p class=pgc-img-caption></p></div><p>（2個2X2的矩陣相乘）</p><p><br></p><p>結果矩陣的第一行包含行1×列1，行1×列2，依此類推。 第二行包含第2行×第1列，第2行×第2列，依此類推。 因此，它具有與第一矩陣相同的行數和與第二矩陣相同的列數。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.2 3D旋轉矩陣</p><p>到目前為止，我們有一個2 x 2矩陣，可用於繞Z軸旋轉2D點。</p><p>但我們實際上使用的是3D點。所以我們嘗試乘法</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57c40d2b84f94bdbb92a87f1e2e17eab><p class=pgc-img-caption></p></div><p>，</p><p>因為矩陣的行和列長度不匹配。所以我們必須把我們的旋轉矩陣增加到3乘3，以包含第三維空間。如果我們用零來填充它會發生什麼？</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/268717ab6b8d4d2dbc0c9812896ce8b3><p class=pgc-img-caption></p></div><p>結果的X和Y分量是正常的，但Z分量始終為零。 那是不對的。 為了保持Z不變，我們必須在旋轉矩陣的右下角插入1。 這麼做才是對的，因為第三列表示Z軸，即</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f97c51a47dc1499b84e1971c5d36e602><p class=pgc-img-caption></p></div><p>。</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7b1fc0892c9d49338666502231dd9e65><p class=pgc-img-caption></p></div><p><br></p><p>如果我們一次對所有三個維度都使用此技巧，那麼最終將得到一個矩陣，其對角線為1，其他任何地方為0。 這被稱為單位矩陣，因為它不會改變與之相乘的關係。 它就像一個過濾器，使所有內容保持不變。</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/945d5ae06d634b4d8c12f208bcd4f1c3><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.3 為X和Y做矩陣旋轉</p><p>使用我們找到的繞Z軸旋轉的相同方式，我們可以得出繞Y軸旋轉的矩陣。首先，X軸從</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37e199bf9c8f415a9e0ef61b8d47f2bb><p class=pgc-img-caption></p></div><p><br></p><p>開始，逆時針旋轉90°後，變為</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a49d55846cb24e839258b4c816e93e17><p class=pgc-img-caption></p></div><p>。</p><p><br></p><p>這意味著旋轉的X軸可以用</p><p><br></p><p>來表示。Z軸在其後方相距90°，因此為</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cb2a381268ae4cb4b79167a21f3ddac6><p class=pgc-img-caption></p></div><p>。</p><p><br></p><p>Y軸保持不變，從而完成了旋轉矩陣。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2c26c0e91750452f8f1866a8116725ab><p class=pgc-img-caption></p></div><p><br></p><p>最後旋轉矩陣使X保持不變，並以類似方式調整Y和Z。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/974effbf722f4aee904d3a69cba690fa><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>3.4 統一旋轉矩陣</p><p>我們的三個旋轉矩陣每個繞單個軸旋轉。 為了將它們結合起來，我們必須一個接一個地應用。 讓我們先繞Z旋轉，然後繞Y旋轉，最後繞X旋轉。但其實我們可以這樣做：首先將Z旋轉應用於我們的點，然後將Y旋轉應用於結果，然後將X旋轉應用於該結果。</p><p><br></p><p>同樣我們也可以將旋轉矩陣彼此相乘。這將產生一個新的旋轉矩陣，該矩陣將立即應用所有三個旋轉。讓我們展示下Y×Z。</p><p><br></p><p>結果矩陣的第一項是</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0c7e0ba2874b428faff10117a0dfbd9a><p class=pgc-img-caption></p></div><p>。</p><p>整個矩陣需要大量的乘法運算，但是許多部分最終都為0，可以丟棄。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48d2ff0b2cc44f00b43f9b23113a971a><p class=pgc-img-caption></p></div><p><br></p><p>現在再來展示X × (Y × Z) ，這會得到我們最終要的矩陣。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/47323a2722494dddb2548820eff916d3><p class=pgc-img-caption></p></div><blockquote class=js_blockquote_wrap><p>乘法順序重要嗎？</p><p>X乘以 X×（Y×Z）=（X×Y）×Z的順序無關緊要。 你最終得到一個不同的中間步驟，但最終結果卻相同。 但是，在此方程式中對矩陣重新排序確實會改變旋轉順序，會產生不同的結果。 因此X×Y×Z≠Z×Y×X 在這方面，矩陣乘法不同於單數乘法。</p><p>Unity的實際輪換順序為ZXY。</p></blockquote><p>現在我們有了這個矩陣，可以看到如何構建旋轉結果的X，Y和Z軸。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71135a1dbc264710bbce07135d74dc4d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e53bf221853e45c9919508830bc9f836><p class=pgc-img-caption></p></div><p><br></p><p>（3個軸任意旋轉）</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>4 矩陣轉換</p><p>如果我們可以能夠將三個旋轉方向組合到一個矩陣中，是否還可以將縮放，旋轉和重新定位也組合到一個矩陣中？如果我們可以將縮放和重新定位表示為矩陣乘法，那麼答案是肯定的。</p><p><br></p><p>縮放矩陣很容易構造。取單位矩陣並縮放其分量。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/aa00ff4a0d334a7e9d53293729d70e74><p class=pgc-img-caption></p></div><p><br></p><p>但是我們如何支持重新定位呢？ 這不是對三個軸的重新定義，而是一個偏移量。 因此，我們無法用現在擁有的3 x 3矩陣表示它。 我們需要另外一列來包含偏移量。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6433fbf674aa4779898dd2c5ea01c18b><p class=pgc-img-caption></p></div><p><br></p><p>但是，這是無效的，因為矩陣的行長已變為4。因此，我們需要在點上添加第四個組件。 當此分量與偏移量相乘時，它應該為1。我們想要保留該1值，因此可以在進一步的矩陣乘法中使用它。 這會導致一個4×4矩陣和一個4D點。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ef148337e95747078ae459defaef7472><p class=pgc-img-caption></p></div><p><br></p><p>因此，我們必須使用4 x 4轉換矩陣。 這意味著縮放和旋轉矩陣會獲得額外的行和列，其中右下角的數字為0，而數字為1。 我們所有的點都得到第四座標，該座標始終為1。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>4.1 齊次座標</p><p>我們可以理解第四個座標嗎？它代表什麼有用的東西呢？我們現在知道給它賦予值1可以實現點的重新定位。如果其值為0，則偏移量將被忽略，但縮放和旋轉仍會發生。</p><p><br></p><p>可以縮放和旋轉但不能移動的東西。那不是點，而是向量，代表一個方向。</p><p>所以</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/12e76e8ec24341b59cd7b704625981b6><p class=pgc-img-caption></p></div><p>代表一個點，而</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c8f293a7f6144924b746a5ec015c9761><p class=pgc-img-caption></p></div><p>表示向量。這概念很有用，因為這意味著我們可以使用相同的矩陣來變換位置，法線和切線。</p><p><br></p><p>如果當第四個座標得到的值不是0或1時會發生什麼呢？ 好吧，不應該有這種情況發生。 或實際上，它沒有區別。 我們現在正在使用齊次座標。 這個想法是，空間中的每個點都可以用無限數量的座標集表示。 最直接的形式使用1作為第四座標。 通過將整個集合乘以任意數字，可以找到所有其他選擇。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/683e54d33d0b488a8c18cdc024501b6b><p class=pgc-img-caption></p></div><p><br></p><p>因此，要獲得歐幾里得點（實際的3D點），請將每個座標除以第四個座標，然後將其丟棄。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2b2f966de81e4388b5aa1a4132ad7b43><p class=pgc-img-caption></p></div><p><br></p><p>當然，當第四個座標為0時，這是行不通的。這些點被定義為無限遠。這就是為什麼它是表現為方向的。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>4.2 使用矩陣</p><p>我們可以使用Unity的Matrix4x4結構執行矩陣乘法。從現在開始，我們將使用它來執行轉換，而不是之前的方法。</p><p><br></p><p>將一個抽象的只讀屬性添加到Transformation中以檢索轉換矩陣。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3a050338b8d44dbbfb4821ea3d48d1c><p class=pgc-img-caption></p></div><p><br></p><p>它的Apply方法不再需要抽象。將僅獲取矩陣並執行乘法。</p><p><br></p><p>請注意，Matrix4x4.MultiplyPoint具有3D矢量參數。 假定缺少的第四座標為1。它還負責從齊次座標轉換回歐幾里得座標的工作。 如果是要乘以一個方向而不是一個點，則可以使用Matrix4x4.MultiplyVector。</p><p><br></p><p>現在，具體的轉換類必須將其Apply方法更改為Matrix屬性。 首先是PositionTransformation。Matrix4x4.SetRow方法提供了一種方便的方式來填充矩陣。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ea424f113de54b56b1a26603ca45424f><p class=pgc-img-caption></p></div><p><br></p><p>接下來是ScaleTransformation。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c5a68d9cfd334cc39e8858dbd736b0cd><p class=pgc-img-caption></p></div><p>對於RotationTransformation，逐列設置矩陣會更方便，因為這與我們現有的代碼匹配。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f48aaed477c2448c9333ef563ce18dd7><p class=pgc-img-caption></p></div><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>4.3 組合矩陣</p><p>現在，讓我們將這些Transform矩陣合併為一個矩陣。將一個Transform矩陣字段添加到TransformationGrid。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c07f0413bdac47fabbe5c69624decfef><p class=pgc-img-caption></p></div><p><br></p><p>我們將在每次Update時更新此轉換矩陣。這需要先獲取第一個矩陣，然後將其與所有其他矩陣相乘。確保它們以正確的順序相乘。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f190540f6d8345208feb73637ec719f0><p class=pgc-img-caption></p></div><p>現在，網格不再調用Apply，而是自己執行矩陣乘法。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c491156c281b4381a8208adf54ac869a><p class=pgc-img-caption></p></div><p><br></p><p>這種新方法效率更高，因為我們曾經分別為每個點創建每個Transform矩陣，然後分別應用它們。 現在，我們一次創建一個統一的轉換矩陣，並將其重新用於每個點。Unity使用相同的技巧把每個對象層次結構簡化為一個Transform矩陣。</p><p><br></p><p>對我們而言，我們可以使其變得更加高效。 所有變換矩陣都具有相同的底行[0 0 0 1]。 知道了這一點，我們就可以忽略該行，而跳過0的計算和最後的轉換除法。Matrix4x4.MultiplyPoint4x3方法就是這麼做的。 但是，我們不會使用該方法，因為有一些有用的轉換會改變底部的行。</p><p><br></p><h1 class=pgc-h-arrow-right><br></h1><p>5 投影矩陣</p><p>到目前為止，我們一直在將點從3D中的一個位置轉換為3D空間中的另一個位置。但是這些點最終如何在2D顯示器上繪製呢？這需要從3D空間轉換為2D空間。我們可以為此創建一個Transform矩陣！</p><p><br></p><p>對相機投影進行新的具體轉換。從單位矩陣開始。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ed4ce337195847be94be9c6a911b0e22><p class=pgc-img-caption></p></div><p>將其添加為最終轉換。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b63c6c2bc0b46dc91da0621d53b7b2b><p class=pgc-img-caption></p></div><p>（相機投影最終結果）</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><p>5.1 正交相機</p><p>從3D到2D的最直接方法是簡單地放棄一個維度。這會將3D空間摺疊成一個平面。該平面就像畫布一樣，用於渲染場景。讓我們放棄Z維度試試，看看會發生什麼。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2d3eecb2b654ed884ce023927cde147><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/36ae7a207e9042c18deb37f8d27f32b4><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cba7887e1de9411c9ee3f32cadb8e504><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/10514af244f7449ea41e357486e01640><p class=pgc-img-caption></p></div><p>（正交投影）</p><p><br></p><p>實際上，網格變為2D了。但你仍然可以縮放，旋轉和重新放置所有內容，之後會將其投影到XY平面上。這是基本的正交攝影機投影。</p><p><br></p><p>我們的原始相機位於原點，並朝正Z方向看。 那我們可以移動它並旋轉它嗎？ 是的，事實上我們已經可以做到了這一點。 移動相機與向相反方向移動世界具有相同的視覺效果。 旋轉和縮放也是如此。 因此，儘管有點尷尬，但我們可以使用現有的轉換來移動相機。Unity使用矩陣求逆來做同樣的事情。</p><p><br></p><h2 class=pgc-h-arrow-right><br></h2><h2 class=pgc-h-arrow-right>5.2 透視攝像機</h2><p>正交攝影機很好，但不能像我們看到的那樣顯示世界。 為此，我們需要一個透視相機。 由於視角的原因，距離較遠的事物對我們來說顯得較小。 我們可以根據點與相機的距離縮放比例來重現此效果。</p><p><br></p><p>將所有內容除以Z座標。 我們可以用矩陣乘法嗎？ 是的，通過將單位矩陣的底部行更改為[0,0,1,0]。 這將使結果的第四個座標等於原始Z座標。 從齊次座標轉換為歐幾里得座標，然後進行所需的劃分。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/43db1c64808e4da9b3ea83d9201eea91><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/887bb71b0ece49b4aaa3e14f26e315d3><p class=pgc-img-caption></p></div><p><br></p><p>正交投影的最大區別是點不會直接向下移動到投影平面。 相反，它們會朝著相機的位置（原點）移動，直到撞到切面。 當然，這僅適用於攝像機前面的點。 相機後面的點會被錯誤地投影。 由於現在我們不會丟棄這些點，因此先通過重新定位確保所有內容都位於相機的前面。 如果不縮放或旋轉網格，則5的距離就足夠了，否則你可能需要更多。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/79b9bfb07e734e8eaa7028d82a7add22><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/556952a087a7405ca7a0bb2245ad6718><p class=pgc-img-caption></p></div><p>（透視投影）</p><p><br></p><p>原點和投影平面之間的距離也會影響投影。 它的作用就像照相機的焦距。 焦距的越大，視野就越小。 現在，我們使用的焦距為1，可產生90°的視野。 讓它可以配置。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1bfc3faf2c034339b51ffd0fd5c8b64d><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b323201faf1d4027aad9ee1a5eed2956><p class=pgc-img-caption></p></div><p>（焦距）</p><p><br></p><p>由於更大的焦距意味著我們正在放大，有效地增加了終點的比例，因此我們可以採用這種方式進行支持。當我們摺疊Z尺寸時，不需要縮放該尺寸。</p><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f97eb1df2c5d4edfac4de87b077d5175><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/51d360537c3b4df3a8204e9e450621ef><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/e5d34a8f89e0401aac75d6d82a6d0ac6><p class=pgc-img-caption></p></div><p><br></p><p>我們現在有一個非常簡單的透視相機。 如果要完全模仿Unity的相機投影，我們還必須處理近距和遠距平面。 這將需要投影到立方體而不是平面中，因此深度信息需要保留下來。 再有就是要關心視圖縱橫比。 另外，Unity的相機朝負Z方向看，還需要取反一些數字。 你可以將所有內容合併到投影矩陣中。 大家可以自己嘗試構建。</p><p><br></p><p>那麼，這一章節的意義何在？ 我們很少需要自己構造矩陣，並且絕對不需要構造投影矩陣。 其實最主要是你已經能瞭解它們的背後發生了什麼。 矩陣並不可怕，它們只是將點和向量從一個空間轉換到另一個空間。 而且你現在也已經知道了，這就很好了，因為一旦我們開始編寫自己的著色器時，你會再次遇到矩陣。</p><p><br></p><p>我們將在第2部分“著色器基礎知識”中進行此操作。</p><p><br></p><p>本系列會在Unity社區、知乎、個人公眾號：<strong>壹種念頭 </strong>進行連載發佈。公眾號會首發，歡迎關注。</p><div class=pgc-img><img alt=基礎渲染系列（一）圖形學的基石——矩陣 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f35f1c9b4fb4703ad8b7a1317e2b5aa><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>基礎</a></li><li><a>圖形學</a></li><li><a>矩陣</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/70e5706e.html alt=人工智能基礎向量、矩陣和數組 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/70e5706e.html title=人工智能基礎向量、矩陣和數組>人工智能基礎向量、矩陣和數組</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/1ebabf70.html alt=ML基礎：協方差矩陣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a8ebdba18ae5461a8e462d5fcce85ee4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/1ebabf70.html title=ML基礎：協方差矩陣>ML基礎：協方差矩陣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html alt=素描五官基礎知識，學素描的同學可參考 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99b7762898d34e2f9a667c431fc7da6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html title=素描五官基礎知識，學素描的同學可參考>素描五官基礎知識，學素描的同學可參考</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c480db6b.html alt=梯度，散度，旋度的重要基礎：對向量場的詮釋 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c8ce2cc3bb0f4a5da0dcbc0a881f9617 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c480db6b.html title=梯度，散度，旋度的重要基礎：對向量場的詮釋>梯度，散度，旋度的重要基礎：對向量場的詮釋</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/40b3969a.html alt=專業音頻基礎概念｜數字音頻是如何工作的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3684bfc4e93447a5bdfd6d573beec22c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/40b3969a.html title=專業音頻基礎概念｜數字音頻是如何工作的？>專業音頻基礎概念｜數字音頻是如何工作的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3faa79.html alt=立體聲系統基礎篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15288739589536026ad6bae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3faa79.html title=立體聲系統基礎篇>立體聲系統基礎篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/18bd39d8.html alt=齒輪基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b8e178319e2c4b88a1865f903306a26b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/18bd39d8.html title=齒輪基礎知識>齒輪基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3555f615.html alt=流體粘度傳感器的基礎知識與應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7f6d9f85a08146e5a84877ef92c212d7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3555f615.html title=流體粘度傳感器的基礎知識與應用>流體粘度傳感器的基礎知識與應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html alt="軟件開發中數據庫必備基礎01 - 圖解事務基礎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4e00ac778db451792b955bde23add02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html title="軟件開發中數據庫必備基礎01 - 圖解事務基礎">軟件開發中數據庫必備基礎01 - 圖解事務基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c4961ebc.html alt=監控攝像頭基礎知識，學會自己也知道如何選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/98be6b1a1ad6410ea61d5fc243b44939 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c4961ebc.html title=監控攝像頭基礎知識，學會自己也知道如何選擇>監控攝像頭基礎知識，學會自己也知道如何選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a12da43e.html alt="金屬材料學 一些基礎知識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac00002279849cb698 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a12da43e.html title="金屬材料學 一些基礎知識">金屬材料學 一些基礎知識</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>