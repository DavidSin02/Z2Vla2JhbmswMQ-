<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>從零開始入門 K8s | 存儲快照與拓撲調度 | 极客快訊</title><meta property="og:title" content="從零開始入門 K8s | 存儲快照與拓撲調度 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/2bb636bde05a4b3f9695d952bfc756db"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/e0e36a0f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/e0e36a0f.html><meta property="article:published_time" content="2020-11-14T20:53:13+08:00"><meta property="article:modified_time" content="2020-11-14T20:53:13+08:00"><meta name=Keywords content><meta name=description content="從零開始入門 K8s | 存儲快照與拓撲調度"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/e0e36a0f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>從零開始入門 K8s | 存儲快照與拓撲調度</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><blockquote class=pgc-blockquote-abstract><p>作者 | 至天 阿里巴巴高級研發工程師</p></blockquote><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2bb636bde05a4b3f9695d952bfc756db><p class=pgc-img-caption></p></div><p style=text-align:center><strong>一、基本知識</strong></p><p style=text-align:justify><br></p><h1 class=pgc-h-arrow-right><strong>存儲快照產生背景</strong></h1><p><br></p><p>在使用存儲時，為了提高數據操作的容錯性，我們通常需要有對線上數據進行 snapshot ，以及能快速 restore 的能力。另外，當需要對線上數據進行快速的複製以及遷移等動作，如進行環境的複製、數據開發等功能時，都可以通過存儲快照來滿足需求，而 K8s 中通過 CSI Snapshotter controller 來實現存儲快照的功能。</p><p style=text-align:justify><br></p><h1 class=pgc-h-arrow-right><strong>存儲快照用戶接口-Snapshot</strong></h1><p><br></p><p>我們知道，K8s 中通過 pvc 以及 pv 的設計體系來簡化用戶對存儲的使用，而存儲快照的設計其實是仿照 pvc & pv 體系的設計思想。</p><p><br></p><p>當用戶需要存儲快照的功能時，可以通過 VolumeSnapshot 對象來聲明，並指定相應的 VolumeSnapshotClass 對象，之後由集群中的相關組件動態生成存儲快照以及存儲快照對應的對象 VolumeSnapshotContent 。</p><p><br></p><p>如下圖所示，動態生成 VolumeSnapshotContent 和動態生成 pv 的流程是非常相似的。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1d884c70c8f3431d890b5f8fcc662d33><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right><strong>存儲快照用戶接口-Restore</strong></h1><p><br></p><p>有了存儲快照之後，如何將快照數據快速恢復過來呢？</p><p></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/577ea629b3e1443788b037bd3801b06f><p class=pgc-img-caption></p></div><p></p><p>如上所示，可以藉助 PVC 對象將 dataSource 字段指定為 VolumeSnapshot 對象。這樣當 PVC 提交之後，會由集群中的相關組件找到 dataSource 所指向的存儲快照數據，然後新創建對應的存儲以及 pv 對象，將存儲快照數據恢復到新的 pv 中，這樣數據就恢復回來了，這就是存儲快照的 restore 用法。</p><p><br></p><h1 class=pgc-h-arrow-right><strong>Topolopy-含義</strong></h1><p style=text-align:justify><br></p><p>首先了解一下拓撲是什麼意思：這裡所說的拓撲是 K8s 集群中為管理的 nodes 劃分的一種“位置”關係，意思為：可以通過在 node 的 labels 信息裡面填寫某一個 node 屬於某一個拓撲。</p><p></p><p>常見的有三種，這三種在使用時經常會遇到：</p><p style=text-align:justify><br></p><ul><li>第一種，在使用雲存儲服務的時候，經常會遇到 <strong>region</strong>，也就是地區的概念，在 K8s 中常通過 label failure-domain.beta.kubernetes.io/region 來標識。這個是為了標識單個 K8s 集群管理的跨 region 的 nodes 到底屬於哪個地區；</li></ul><p style=text-align:justify><br></p><ul><li>第二種，比較常用的是可用區，也就是 available <strong>zone</strong>，在 K8s 中常通過 label failure-domain.beta.kubernetes.io/zone 來標識。這個是為了標識單個 K8s 集群管理的跨 zone 的 nodes 到底屬於哪個可用區；</li></ul><p style=text-align:justify><br></p><ul><li>第三種，是 <strong>hostname，</strong>就是單機維度，是拓撲域為 node 範圍，在 K8s 中常通過 label kubernetes.io/hostname 來標識，這個在文章最後講 local pv 的時候，會詳細描述。</li></ul><p style=text-align:justify><br></p><p>上面講到的三個拓撲是比較常用的，而拓撲其實是可以自己定義的。可以定義一個字符串來表示一個拓撲域，這個 key 所對應的值其實就是拓撲域下不同的拓撲位置。</p><p></p><p>舉個例子：可以用 <strong>rack，</strong>也就是機房中的機架這個緯度來做一個拓撲域。這樣就可以將不同機架 ( rack ) 上面的機器標記為不同的拓撲位置，也就是說可以將不同機架上機器的位置關係通過 rack 這個緯度來標識。</p><p><br></p><p>屬於 rack1 上的機器，node label 中都添加 rack 的標識，它的 value 就標識成 rack1，即 rack=rack1；另外一組機架上的機器可以標識為 rack=rack2，這樣就可以通過機架的緯度就來區分來 K8s 中的 node 所處的位置。</p><p style=text-align:justify><br></p><p>接下來就一起來看看拓撲在 K8s 存儲中的使用。</p><p></p><h1 class=pgc-h-arrow-right><strong>存儲拓撲調度產生背景</strong></h1><p style=text-align:justify><br></p><p>我們知道，K8s 中通過 PV 的 PVC 體系將存儲資源和計算資源分開管理。如果創建出來的 PV 有“訪問位置”的限制，也就是說，它通過 nodeAffinity 來指定哪些 node 可以訪問這個 PV。</p><p><br></p><p>為什麼會有這個訪問位置的限制呢？</p><p></p><p>因為在 K8s 中創建 pod 的流程和創建 PV 的流程，其實可以認為是並行進行的，這樣的話，就沒有辦法來保證 pod 最終運行的 node 是能訪問到有位置限制的 PV 對應的存儲，最終導致 pod 沒法正常運行。</p><p><br></p><p>這裡舉兩個經典的例子：</p><p></p><p>首先來看一下 <strong>Local PV 的例子</strong>。Local PV 是將一個 node 上的本地存儲封裝為 PV，通過使用 PV 的方式來訪問本地存儲。為什麼會有 Local PV 的需求呢？</p><p><br></p><p>簡單來說，剛開始使用 PV 或 PVC 體系的時候，主要是用來針對分佈式存儲的，分佈式存儲依賴於網絡，如果某些業務對 I/O 的性能要求非常高，通過網絡訪問分佈式存儲可能沒法滿足它的性能需求。這個時候需要使用本地存儲，刨除了網絡的 overhead，性能往往會比較高。</p><p><br></p><p>但是用本地存儲也是有壞處的！分佈式存儲可以通過多副本來保證高可用，但本地存儲就需要業務自己用類似 Raft 協議來實現多副本高可用。</p><p style=text-align:justify><br></p><p>接下來看一下 Local PV 場景可能如果沒有對 PV 做“訪問位置”的限制會遇到什麼問題？</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/337728a019bc4b9b81ee31eda6c91542><p class=pgc-img-caption></p></div><p></p><p>當用戶在提交完 PVC 的時候，K8s PV controller 可能綁定的是 node2 上面的 PV。但是，真正使用這個 PV 的 pod，在被調度的時候，有可能調度在 node1 上，最終導致這個 pod 在起來的時候沒辦法使用這塊存儲，因為 pod 真實情況是要使用 node2 上面的存儲。</p><p></p><p>第二個場景(如果不對 PV 做“訪問位置”的限制會出問題的)：</p><p></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1362c94559354e06b9d44a227d8a164c><p class=pgc-img-caption></p></div><p></p><p>如果搭建的 K8s 集群管理的 nodes 分佈在單個區域多個可用區內。在創建動態存儲的時候，創建出來的存儲屬於可用區 2，但之後在提交使用該存儲的 pod，它可能會被調度到可用區 1，那就沒辦法使用這塊存儲。</p><p><br></p><p>因此像阿里雲的雲盤，也就是塊存儲，當前不能跨可用區使用，如果創建的存儲其實屬於可用區 2，但是 pod 運行在可用區 1，就沒辦法使用這塊存儲，這是第二個常見的問題場景。</p><p style=text-align:justify><br></p><p>接下來我們來看看 K8s 中如何通過存儲拓撲調度來解決上面的問題的。</p><p style=text-align:justify><br></p><h1 class=pgc-h-arrow-right><strong>存儲拓撲調度</strong></h1><p style=text-align:justify><br></p><p>首先總結一下之前的兩個問題，它們都是 PV 在給 PVC 綁定或者動態生成 PV 的時候，我並不知道後面將使用它的 pod 將調度在哪些 node 上。</p><p><br></p><p>但 PV 本身的使用，是對 pod 所在的 node 有拓撲位置的限制的，如 Local PV 場景是我要調度在指定的 node 上我才能使用那塊 PV，而對第二個問題場景就是說跨可用區的話，必須要在將使用該 PV 的 pod 調度到同一個可用區的 node 上才能使用阿里云云盤服務，在 K8s 中怎樣去解決這個問題呢？</p><p></p><p>簡單來說，在 K8s 中將 PV 和 PVC 的 binding 操作和動態創建 PV 的操作做了 delay，delay 到 pod 調度結果出來之後，再去做這兩個操作。</p><p><br></p><p>這樣做有以下幾點好處：</p><p style=text-align:justify><br></p><ul><li>首先，如果所要使用的 PV 是預分配的，如 Local PV，使用這塊 PV 的 pod 它對應的 PVC 其實還沒有做綁定，可以通過調度器在調度的過程中，結合 pod 的計算資源需求(如 cpu/mem) 以及 pod 的 PVC 需求，選擇的 node 既要滿足計算資源的需求又要 pod 使用的 pvc 要能 binding 的 pv 的 nodeaffinity 限制；</li></ul><p><br></p><ul><li>其次對動態生成 PV 的場景相當於是如果知道 pod 運行的 node 之後，就可以根據 node 上記錄的拓撲信息來動態的創建這個 PV，也就是保證新創建出來的 PV 的拓撲位置與運行的 node 所在的拓撲位置是一致的，如上面所述的阿里云云盤的例子，既然知道 pod 要運行到可用區 1，那之後創建存儲時指定在可用區 1 創建即可。</li></ul><p></p><p>為了實現上面所說的延遲綁定和延遲創建 PV，需要在 K8s 中的改動涉及到的相關組件有三個：</p><p></p><ul><li>PV Controller 也就是 persistent volume controller，它需要支持延遲 Binding 這個操作；</li></ul><p><br></p><ul><li>另一個是動態生成 PV 的組件，如果 pod 調度結果出來之後，它要根據 pod 的拓撲信息來去動態的創建 PV；</li></ul><p><br></p><ul><li>第三組件，也是最重要的一個改動點就是 kube-scheduler。在為 pod 選擇 node 節點的時候，它不僅要考慮 pod 對 CPU/MEM 的計算資源的需求，它還要考慮這個 pod 對存儲的需求，也就是根據它的 PVC，它要先去看一下當前要選擇的 node，能否滿足能和這個 PVC 能匹配的 PV 的 nodeAffinity；或者是動態生成 PV 的過程，它要根據 StorageClass 中指定的拓撲限制來 check 當前的 node 是不是滿足這個拓撲限制，這樣就能保證調度器最終選擇出來的 node 就能滿足存儲本身對拓撲的限制。</li></ul><p style=text-align:justify><br></p><p>這就是存儲拓撲調度的相關知識。</p><p></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86950b804cd7458c81be2c6e20ca7f39><p class=pgc-img-caption></p></div><p style=text-align:center><strong>二、用例解讀</strong></p><p style=text-align:justify><br></p><p>接下來通過 yaml 用例來解讀一下第一部分的基本知識。</p><p style=text-align:justify><br></p><h1 class=pgc-h-arrow-right><strong>Volume Snapshot/Restore示例</strong></h1><p></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e408ecf96d14cc2af6104c9438ffd24><p class=pgc-img-caption></p></div><p></p><p>下面來看一下存儲快照如何使用：</p><p><br></p><ul><li>首先需要集群管理員，在集群中創建 VolumeSnapshotClass 對象，其中一個重要字段就是 Snapshot，它是指定真正創建存儲快照所使用的卷插件，這個卷插件是需要提前部署的，稍後再說這個卷插件；</li></ul><p><br></p><ul><li>接下來用戶如果要做真正的存儲快照，需要聲明一個 VolumeSnapshotClass,首先要指定的是 VolumeSnapshotClassName，接著它要指定的一個非常重要的字段就是 source，這個 source 其實就是指定快照的數據源是啥。這個地方指定 name 為 disk-pvc，也就是說通過這個 pvc 對象來創建存儲快照。提交這個 VolumeSnapshot 對象之後，集群中的相關組件它會找到這個 PVC 對應的 PV 存儲，對這個 PV 存儲做一次快照。</li></ul><p><br></p><ul><li>有了存儲快照之後，接下來怎麼去用存儲快照恢復數據呢？這個其實也很簡單，通過聲明一個新的 PVC 對象並在它的 spec 下面的 DataSource 中來聲明我的數據源來自於哪個 VolumeSnapshot，這裡指定的是 disk-snapshot 對象，當我這個 PVC 提交之後，集群中的相關組件，它會動態生成新的 PV 存儲，這個新的 PV 存儲中的數據就來源於這個 Snapshot 之前做的存儲快照。</li></ul><p><br></p><h1 class=pgc-h-arrow-right><strong>Local PV 的示例</strong></h1><p style=text-align:justify><br></p><p>如下圖看一下 Local PV 的 yaml 示例：</p><p><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30a7e537ad994794a2ada85e56295fa3><p class=pgc-img-caption></p></div><p></p><p>Local PV 使用時大都是通過靜態創建的方式，也就是要先去聲明 PV 對象，既然 Local PV 只能是本地訪問，就需要在 PV 對象中通過 nodeAffinity 來限制這個 PV 只能在單 node 上訪問，給這個 PV 加上拓撲限制。</p><p><br></p><p>如上圖拓撲的 key 用 kubernetes.io/hostname 來做標記，也就是只能在 node1 訪問。如果想用這個 PV，你的 pod 必須要調度到 node1 上。</p><p></p><p>既然是靜態創建 PV 的方式，這裡為什麼還需要 storageClassname 呢？</p><p><br></p><p>前面提到，在 Local PV 中，如果想讓它正常工作，需要用到延遲綁定特性才行。既然是延遲綁定，當用戶在寫完 PVC 提交之後，即使集群中有相關的 PV 能跟它匹配，它也暫時不能做匹配，也就是說 PV controller 不能馬上去做 binding。</p><p><br></p><p>這個時候你就要通過一種手段來告訴 PV controller，什麼情況下是不能立即做 binding，這裡的 storageClass 就是為了起到這個副作用，我們可以看到 storageClass 裡面的 provisioner 指定的是 <strong>no-provisioner</strong>，其實就是相當於告訴 K8s 它不會去動態創建 PV，它主要用到一個字段叫 WaitForFirstConsumer，可以先簡單地認為它是延遲綁定。</p><p></p><p>當用戶開始提交 PVC 的時候，pv controller 在看到這個 pvc 的時候，它會找到相應的 storageClass，發現這個 BindingMode 是延遲綁定，它就不會做任何事情。</p><p></p><p>之後當真正使用這個 pvc 的 pod，在調度時，當它恰好調度在符合 pv nodeaffinity 的 node 的上面後，這個 pod 裡面所使用的 PVC 才會真正地與 PV 做綁定，這樣就保證 pod 調度到這臺 node 上之後，這個 PVC 才與這個 PV 綁定，最終保證的是創建出來的 pod 能訪問這塊 Local PV，也就是靜態 Provisioning 場景下怎麼去滿足 PV 的拓撲限制。</p><p></p><h1 class=pgc-h-arrow-right><strong>限制 Dynamic Provisioning PV 拓撲示例</strong></h1><p style=text-align:justify><br></p><p>再看一下動態 Provisioning PV 的時候，怎麼去做拓撲限制的？</p><p><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dcbc556949744903b1b16089d7b6f8b9><p class=pgc-img-caption></p></div><p></p><p>動態就是指動態創建 PV 就有拓撲位置的限制，怎麼去指定呢？</p><p style=text-align:justify><br></p><ul><li>首先在 storageclass 中，還是需要指定 BindingMode，就是 WaitForFirstConsumer，也就是延遲綁定；</li></ul><p><br></p><ul><li>其次特別重要的一個字段就是 <strong>allowedTopologies</strong>，限制就在這個地方。上圖中可以看到拓撲限制是可用區的級別，這裡其實有兩層意思：</li></ul><p><br></p><ol start=1><li>第一層意思就是說在動態創建 PV 的時候，創建出來的 PV 必須是在這個可用區可以訪問的；</li><li>第二層含義是因為聲明的是延遲綁定，調度器在發現使用它的 PVC 正好對應的是該 storageclass 的時候，調度 pod 就要選擇位於該可用區的 nodes。</li></ol><p style=text-align:justify><br></p><p>總之，就是要從兩方面保證，一是動態創建出來的存儲時要能被這個可用區訪問的，二是我調度器在選擇 node 的時候，要落在這個可用區內的。</p><p><br></p><p>這樣的話就保證我的存儲和我要使用存儲的這個 pod 它所對應的 node，它們之間的拓撲域是在同一個拓撲域，用戶在寫 PVC 文件的時候，寫法是跟以前的寫法是一樣的，主要是在 storageclass 中要做一些拓撲限制。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86950b804cd7458c81be2c6e20ca7f39><p class=pgc-img-caption></p></div><p style=text-align:center><strong>三、操作演示</strong></p><p style=text-align:justify><br></p><p>下面將在線上環境來演示一下前面講解的內容。</p><p style=text-align:justify><br></p><p>首先來看一下我的阿里雲服務器上搭建的 K8s 服務。總共有 3 個 node 節點：一個 master 節點，兩個 node。其中 master 節點是不能調度 pod 的。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ea5f853930ae4b25ada6be5f25d93d4b><p class=pgc-img-caption></p></div><p><br></p><p>再看一下，我已經提前把需要的插件布好了：一個是 snapshot 插件 ( csi-external-snapshot* ) ，一個是動態雲盤的插件 ( csi-disk* ) 。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9482c477d227487781054e0002d7827f><p class=pgc-img-caption></p></div><p></p><p>現在開始 snapshot 的演示：首先去動態創建雲盤，然後才能做 snapshot。動態創建雲盤需要先創建 storageclass，然後去根據 PVC 動態創建 PV，之後再創建一個使用它的 pod。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/034641055f1a44c39a1c4b394daefd19><p class=pgc-img-caption></p></div><p></p><p>有了以上對象，現在就可以做 snapshot 了。首先看一下做 snapshot 需要的第一個配置文件：snapshotclass.yaml。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5f12e456bf474b3ba2ebb7bc5564a094><p class=pgc-img-caption></p></div><p></p><p>其實裡面就是指定了在做存儲快照時需要使用的插件，這個插件剛才已經部署好了，就是 csi-external-snapshot-0 這個插件。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/45f7e95068fc4d4aa08aa3b0fb9c50d6><p class=pgc-img-caption></p></div><p></p><p>接下來創建 volume-snapshotclass 文件，創建完之後就開始了 snapshot。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/59203df12b1e4bdcb58a66fcfd96d6a8><p class=pgc-img-caption></p></div><p></p><p>然後看 snapshot.yaml，Volumesnapshot 聲明創建存儲快照了，這個地方就指定剛才創建的那個 PVC 來做的數據源來做 snapshot，我們開始創建：</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3226ce3199904e40956b0b773b54454b><p class=pgc-img-caption></p></div><p></p><p>如下圖所示，content 已經在 11 秒之前創建好了。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9fd70426bef40a09d589e82a2b1bf4e><p class=pgc-img-caption></p></div><p></p><p>可以看一下它裡面的內容，主要看 volumesnapshotcontent 記錄的一些信息，這個是我 snapshot 出來之後，它記錄的就是雲存儲廠商那邊返回給我的 snapshot 的 ID。然後是這個 snapshot 數據源，也就是剛才指定的 PVC，可以通過它會找到對應的 PV。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0dd9de9661c421689a5ecbabb84890e><p class=pgc-img-caption></p></div><p></p><p>snapshot 的演示大概就是這樣，把剛才創建的 snapshot 通過 volumesnapshot 來刪掉，然後看一下，動態創建的這個 volumesnapshotcontent 也被刪掉。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9d55f4f17c8c4d7d8c295cd457043c0a><p class=pgc-img-caption></p></div><p></p><p>接下來看一下動態 PV 創建的過程加上一些拓撲限制，首先將 storageclass 創建出來，然後再看一下 storageclass 裡面做 1 的限制。</p><p><br></p><p>storageclass 首先還是指定它的 BindingMode 為 WaitForFirstConsumer，也就是做延遲綁定；然後是對它的拓撲限制，我這裡在 allowedTopologies 字段中配置了一個可用區級別的限制。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/845254db698d433b8b32ea6d6f1d16a6><p class=pgc-img-caption></p></div><p></p><p>來嘗試創建一下 PVC，PVC 創建出來之後，理論上它應該處在 pending 狀態。看一下，現在它要做延遲綁定，由於沒有使用它的 pod，暫時沒辦法去做綁定，也沒辦法去動態創建新的 PV。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b0e085bee07a4e5c9212187c33200a28><p class=pgc-img-caption></p></div><p></p><p>接下來創建使用該 pvc 的 pod 看會有什麼效果，看一下 pod，pod 也處在 pending了。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/837bc434c19449aba6cdef1143be83e1><p class=pgc-img-caption></p></div><p></p><p>pod 為啥處在 pending 狀態呢？可以看到是因為調度失敗了。調度失敗原因：一個 node 由於 taint 不能調度，這個其實是 master，另外兩個 node 也是沒有說是可綁定的 PV。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9c9549108b214e9e974a2dd42d31eef6><p class=pgc-img-caption></p></div><p></p><p>為什麼會有兩個 node 出現沒有可綁定的 pv 的錯誤？不是動態創建嘛？</p><p style=text-align:justify><br></p><p>我們來仔細看看 storageclass 中的拓撲限制，通過上面的講解我們知道，這裡限制使用該 storageclass 創建的 PV 存儲必須在可用區 cn-hangzhou-d 可訪問的，而使用該存儲的 pod 也必須調度到 cn-hangzhou-d 的 node 上。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/26179107170c44ed8b450bbc75be8159><p class=pgc-img-caption></p></div><p></p><p>那就來看一下 node 節點上有沒有這個拓撲信息，如果沒有當然是不行了。</p><p style=text-align:justify><br></p><p>看一下第一個 node 的全量信息，主要找它的 labels 裡面的信息，可以看到 lables 裡的確有個這樣的 key。也就是說有一個這樣的拓撲，但是這裡指定的是 cn-hangzhou-b，剛才 storageclass 裡指定的是 cn-hangzhou-d。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8e8f6e06ef404d8697ed8807c602f23f><p class=pgc-img-caption></p></div><p style=text-align:justify><br></p><p>另外的一個 node 上的拓撲信息寫的也是 hangzhou-b，但我們之前 storageclass 裡限制是 d。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/da7f4784f6e7412facd3ad4b397c6128><p class=pgc-img-caption></p></div><p></p><p>這就導致最終沒辦法將 pod 調度在這兩個 node 上。現在修改一下 storageclass 中的拓撲限制，將 cn-hangzhou-d 改為 cn-hangzhou-b。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b11661b9d591479086898a34e026b284><p class=pgc-img-caption></p></div><p></p><p>改完之後再看一下，其實就是說我動態創建出來的 PV 要能被 hangzhou-b 這個可用區訪問的，使用該存儲的 pod 要調度到該可用區的 node 上。把之前的 pod 刪掉，讓它重新被調度看一下有什麼結果？可以看到，現在這個已經調度成功了，處於啟動容器階段。</p><p style=text-align:justify><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0874d467c7214f788b75c93ce2628091><p class=pgc-img-caption></p></div><p></p><p>說明剛才把 storageclass 裡對可用區的限制從 hangzhou-d 改為 hangzhou-b 之後，集群中就有兩個 node，它的拓撲關係是和 storageclass 裡要求的拓撲關係是相匹配的，這樣它就能保證它的 pod 是有 node 節點可調度的。</p><p><br></p><p>上圖中的最後，Pod 已經 Running 了，說明剛才的拓撲限制改動之後可以 work 了。</p><p><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2bb636bde05a4b3f9695d952bfc756db><p class=pgc-img-caption></p></div><p style=text-align:center><strong>四、處理流程</strong></p><p style=text-align:justify><br></p><h1 class=pgc-h-arrow-right><strong>Kubernetes 對 Volume Snapshot/Restore 處理流程</strong></h1><p style=text-align:justify><br></p><p>接下來看一下 K8s 中對存儲快照與拓撲調度的具體處理流程。如下圖所示：</p><p><br></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/014f139b74754c2a80205009161cfba9><p class=pgc-img-caption></p></div><p><br></p><p>首先來看一下存儲快照的處理流程，這裡來首先解釋一下 csi 部分。K8s 中對存儲的擴展功能都是推薦通過 csi out-of-tree 的方式來實現的。</p><p style=text-align:justify><br></p><p>csi 實現存儲擴展主要包含兩部分：</p><p style=text-align:justify><br></p><ul><li>第一部分是由 K8s 社區推動實現的 csi controller 部分，也就是這裡的 csi-snapshottor controller 以及 csi-provisioner controller，這些主要是通用的 controller 部分；</li></ul><p><br></p><ul><li>另外一部分是由特定的雲存儲廠商用自身 OpenAPI 實現的不同的 csi-plugin 部分，也叫存儲的 driver 部分。</li></ul><p style=text-align:justify><br></p><p>兩部分部件通過 unix domain socket 通信連接到一起。有這兩部分，才能形成一個真正的存儲擴展功能。</p><p style=text-align:justify><br></p><p>如上圖所示，當用戶提交 VolumeSnapshot 對象之後，會被 csi-snapshottor controller watch 到。之後它會通過 GPPC 調用到 csi-plugin，csi-plugin 通過 OpenAPI 來真正實現存儲快照的動作，等存儲快照已經生成之後，會返回到 csi-snapshottor controller 中，csi-snapshottor controller 會將存儲快照生成的相關信息放到 VolumeSnapshotContent 對象中並將用戶提交的 VolumeSnapshot 做 bound。這個 bound 其實就有點類似 PV 和 PVC 的 bound 一樣。</p><p></p><p>有了存儲快照，如何去使用存儲快照恢復之前的數據呢？</p><p><br></p><p>前面也說過，通過聲明一個新的 PVC 對象，並且指定它的 dataSource 為 Snapshot 對象，當提交 PVC 的時候會被 csi-provisioner watch 到，之後會通過 GRPC 去創建存儲。</p><p><br></p><p>這裡創建存儲跟之前講解的 csi-provisioner 有一個不太一樣的地方，就是它裡面還指定了 Snapshot 的 ID，當去雲廠商創建存儲時，需要多做一步操作：將之前的快照數據恢復到新創建的存儲中。</p><p><br></p><p>之後流程返回到 csi-provisioner，它會將新創建的存儲的相關信息寫到一個新的 PV 對象中，新的 PV 對象被 PV controller watch 到它會將用戶提交的 PVC 與 PV 做一個 bound，之後 pod 就可以通過 PVC 來使用 Restore 出來的數據了。</p><p><br></p><p>以上就是是 K8s 中對存儲快照的處理流程。</p><p></p><h1 class=pgc-h-arrow-right><strong>Kubernetes 對 Volume Topology-aware Scheduling 處理流程</strong></h1><p style=text-align:justify><br></p><p>接下來看一下存儲拓撲調度的處理流程：</p><p></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fda1bb0b31674af6854d2880feee979a><p class=pgc-img-caption></p></div><p></p><p><strong>第一個步驟</strong>其實就是要去聲明延遲綁定，這個是通過 StorageClass 來做的，上面已經闡述過，此處不做詳細描述。</p><p style=text-align:justify><br></p><p>接下來看一下調度器，上圖中紅色部分就是調度器新加的存儲拓撲調度邏輯，我們先來看一下非紅色部分，調度器為一個 pod 選擇 node 時，它的大概流程：</p><p style=text-align:justify><br></p><ul><li>首先用戶提交完 pod 之後，會被調度器 watch 到，它就會去首先做預選，預選就是說它會將集群中的所有 node 都來與這個 pod 它需要的資源做匹配；</li></ul><p><br></p><ul><li>如果匹配上，就相當於這個 node 可以使用，當然可能不止一個 node 可以使用，最終會選出來一批 node；</li></ul><p><br></p><ul><li>然後再經過第二個階段優選，優選就相當於我要對這些 node 做一個打分的過程，通過打分找到最匹配的一個 node；</li></ul><p><br></p><ul><li>之後調度器將調度結果寫到 pod 裡面的 spec.nodeName 字段裡面，然後會被相應的 node 上面的 kubelet watch 到，最後就開始創建 pod 的整個流程。</li></ul><p></p><p>現在看一下加上卷相關調度的時候，篩選 node (<strong>第二個步驟</strong>)又是怎麼做的？</p><p></p><ul><li>首先要找到 pod 中使用的所有 PVC，找到已經 bound 的 PVC，以及需要延遲綁定的這些 PVC；</li></ul><p><br></p><ul><li>對於已經 bound 的 PVC，要 check 一下它對應的 PV 裡面的 nodeAffinity 與當前 node 的拓撲是否匹配 。如果不匹配， 就說明這個 node 不能被調度。如果匹配，繼續往下走，就要去看一下需要延遲綁定的 PVC；</li></ul><p><br></p><ul><li>對於需要延遲綁定的 PVC。先去獲取集群中存量的 PV，滿足 PVC 需求的，先把它全部撈出來，然後再將它們一一與當前的 node labels 上的拓撲做匹配。如果它們(存量的 PV)都不匹配，那就說明當前的存量的 PV 不能滿足需求，就要進一步去看一下如果要動態創建 PV 當前 node 是否滿足拓撲限制，也就是還要進一步去 check StorageClass 中的拓撲限制，如果 StorageClass 中聲明的拓撲限制與當前的 node 上面已經有的 labels 裡面的拓撲是相匹配的，那其實這個 node 就可以使用，如果不匹配，說明該 node 就不能被調度。</li></ul><p style=text-align:justify><br></p><p>經過上面的步驟，就找到了所有既滿足 pod 計算資源需求又滿足 pod 存儲資源需求的所有 nodes。</p><p></p><p>當 node 選出來之後，<strong>第三個步驟</strong>就是調度器內部做的一個優化。這裡簡單說一下：就是更新經過預選和優選之後，pod 的 node 信息，以及 PV 和 PVC 在 scheduler 中做的一些 cache 信息。</p><p style=text-align:justify><br></p><p><strong>第四個步驟</strong>也是重要的一步：已經選擇出來 node 的 Pod，不管其使用的 PVC 是要 binding 已經存在的 PV，還是要做動態創建 PV，這時就可以由調度器來觸發，調度器會去更新 PVC 對象和 PV 對象裡面的相關信息，然後去觸發 PV controller 去做 binding 操作，或者是由 csi-provisioner 去做動態創建流程。</p><p></p><div class=pgc-img><img alt="從零開始入門 K8s | 存儲快照與拓撲調度" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2bb636bde05a4b3f9695d952bfc756db><p class=pgc-img-caption></p></div><p style=text-align:center><strong>本文總結</strong></p><p style=text-align:justify><br></p><ol start=1><li>通過對比 PVC & PV 體系講解了存儲快照的相關 K8s 資源對象以及使用方法；</li><li>通過兩個實際場景遇到的問題引出存儲拓撲調度功能必要性，以及 K8s 中如何通過拓撲調度來解決這些問題；</li><li>通過剖析 K8s 中存儲快照和存儲拓撲調度內部運行機制，深入理解該部分功能的工作原理。</li></ol></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>快照</a></li><li><a>零開始</a></li><li><a>入門</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f74c4fe8.html alt=從零開始服務器搭建wordpress網站詳細建站教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/991db5d6ab1c4209bc6bb9fb185a69b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f74c4fe8.html title=從零開始服務器搭建wordpress網站詳細建站教程>從零開始服務器搭建wordpress網站詳細建站教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html alt="web前端（從零開始），每天更新學習筆記 HTML5元素分類" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/46d70004fcd55e1ddad3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97886d06.html title="web前端（從零開始），每天更新學習筆記 HTML5元素分類">web前端（從零開始），每天更新學習筆記 HTML5元素分類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html alt=EXCEL入門基礎：對行和列選定數據求和 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f03f82096d240dd92410709f3e19eb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html title=EXCEL入門基礎：對行和列選定數據求和>EXCEL入門基礎：對行和列選定數據求和</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html alt=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49834ccb43ed42cb9a54c9827c3ab134 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html title=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！>工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html alt=工程造價：入門知識全套講義，30章600頁，精通造價首選之作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e1b335c343a455f8777dd3144fc1c35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html title=工程造價：入門知識全套講義，30章600頁，精通造價首選之作>工程造價：入門知識全套講義，30章600頁，精通造價首選之作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html alt=“黑客”入門學習之“Windows組策略” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea21244d5f5c420ebef29650f3fafd1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html title=“黑客”入門學習之“Windows組策略”>“黑客”入門學習之“Windows組策略”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e5b92f2.html alt=Mini-patch：從零開始的反向傳播（附詳細代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0b58b4457c95428a8f14c71e2da9c021 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e5b92f2.html title=Mini-patch：從零開始的反向傳播（附詳細代碼）>Mini-patch：從零開始的反向傳播（附詳細代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html alt=PHP入門教程，5天86節課助力小白變大神！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4366000004d4c98fd587 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html title=PHP入門教程，5天86節課助力小白變大神！>PHP入門教程，5天86節課助力小白變大神！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html alt=Thinkphp6快速入門一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c4331ddc0ffb4c94a4aa80be95178354 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html title=Thinkphp6快速入門一>Thinkphp6快速入門一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html alt="php新手入門教程， 最全最完整的教學視頻課程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/666a38216ab04790a716bb1451c7fe44 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html title="php新手入門教程， 最全最完整的教學視頻課程">php新手入門教程， 最全最完整的教學視頻課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html alt=「素描入門」基礎不紮實，從排線練起 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15252166717297d7af296ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html title=「素描入門」基礎不紮實，從排線練起>「素描入門」基礎不紮實，從排線練起</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html alt=「素描入門」素描排線的繪畫技法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1530098801296ab58189790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html title=「素描入門」素描排線的繪畫技法>「素描入門」素描排線的繪畫技法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a993b442.html alt=素描入門丨你說線條或者排線，容易嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1536648317995f32cedaa40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a993b442.html title=素描入門丨你說線條或者排線，容易嗎？>素描入門丨你說線條或者排線，容易嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0e2c5d2.html alt=零基礎入門要知道的素描知識總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c2c16563-8821-4294-a8c6-9d76e62a2440 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0e2c5d2.html title=零基礎入門要知道的素描知識總結>零基礎入門要知道的素描知識總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>