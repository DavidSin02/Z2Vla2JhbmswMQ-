<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構與算法——最小生成樹 | 极客快訊</title><meta property="og:title" content="數據結構與算法——最小生成樹 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/36b27200eb7c41258d8210393c3e09bf"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e5%ad%b8/ef6637be.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e5%ad%b8/ef6637be.html><meta property="article:published_time" content="2020-11-14T20:56:36+08:00"><meta property="article:modified_time" content="2020-11-14T20:56:36+08:00"><meta name=Keywords content><meta name=description content="數據結構與算法——最小生成樹"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E5%AD%B8/ef6637be.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構與算法——最小生成樹</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E5%AD%B8.html>科學</a></span></div><div class=post-content><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/36b27200eb7c41258d8210393c3e09bf><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>1 引言</h2><p>在之前的文章中已經詳細介紹了圖的一些基礎操作。而在實際生活中的許多問題都是通過轉化為圖的這類數據結構來求解的，這就涉及到了許多圖的算法研究。</p><p>例如：在 n 個城市之間鋪設光纜，以保證這 n 個城市中的任意兩個城市之間都可以通信。由於鋪設光纜的價格很高，且各個城市之間的距離不同，這就使得在各個城市之間鋪設光纜的價格不同。那麼如何選擇鋪設線路的方案，才能使費用最低呢？</p><p><strong>這就涉及到我們今天要研究的圖的最小生成</strong><strong>樹</strong><strong>問題</strong>。</p><h2 class=pgc-h-arrow-right>2 重要概念</h2><p>在學習最小生成樹之前需要先明確幾個重要概念。  <strong>連通圖：</strong>在無向圖中，若任意兩個頂點與都有路徑相通，則稱該無向圖為連通圖。  <strong>強連通圖：</strong>在有向圖中，若任意兩個頂點與都有路徑相通，則稱該有向圖為強連通圖。  <strong>連通網：</strong>在連通圖中，若圖的邊具有一定的意義，每一條邊都對應著一個數，稱為權；權代表著連接連個頂點的代價，稱這種連通圖叫做連通網。  <strong>生成樹：</strong>一個連通圖的生成樹是指一個連通子圖，它含有圖中全部n個頂點，但只有足以構成一棵樹的n-1條邊。一顆有n個頂點的生成樹有且僅有n-1條邊，如果生成樹中再添加一條邊，則必定成環。  <strong>最小生成樹：</strong>在連通網的所有生成樹中，所有邊的代價和最小的生成樹，稱為最小生成樹。</p><h2 class=pgc-h-arrow-right>3 普里姆算法—Prim算法</h2><p>  <strong>普里姆算法（Prim算法）</strong>是加權連通圖裡生成最小生成樹的一種算法。該算法於1930年由捷克數學家沃伊捷赫·亞爾尼克發現；並在1957年由美國計算機科學家羅伯特·普里姆獨立發現；1959年，艾茲格·迪科斯徹再次發現了該算法。因此，在某些場合，普里姆算法又被稱為DJP算法、亞爾尼克算法或普里姆-亞爾尼克算法。</p><h3 class=pgc-h-arrow-right>3.1 算法流程</h3><p>  （1）對於一個加權連通圖，其頂點集合為V，邊集合為E。從集合V中任選一個頂點作為初始頂點，將該頂點標為已處理；  （2）已處理的所有頂點可以看成是一個集合U，計算所有與集合U中相鄰接的頂點的距離，選擇距離最短的頂點，將其標記為已處理，並記錄最短距離的邊；  （3）不斷計算已處理的頂點集合U和未處理的頂點的距離，每次選出距離最短的頂點標為已處理，同時記錄最短距離的邊，直至所有頂點都處理完。  （4）最終，所有記錄的最短距離的邊構成的樹，即是最小生成樹。</p><h3 class=pgc-h-arrow-right>3.2 算法圖解</h3><p>例如：圖3.2.1所示的帶權無向圖，採用Prim算法構建最小生成樹過程如下。</p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/893e190d3d084106ab784ce827aff243><p class=pgc-img-caption></p></div><p>圖3.2.1</p><p>（1）首先，選取頂點A作為起始點，標記A，並將頂點A添加至集合U中。</p><p>（2）集合U中只有一個頂點A，與A鄰接的頂點有B和C，B、C距A的距離分別為6、3。選擇距離最短的邊（A，C），將C標記，並將C添加至集合U中。</p><p>（3）集合U中頂點為A和C。與頂點A鄰接的有B、C，對應距離為6、3。與C鄰接的頂點有B、F、E，對應的距離為4、7、8。由於頂點A、C均被標記，故不能選擇距離為3的路徑。此時應選擇距離最短邊（C，B）。標記B、並將B添加至集合U中。</p><p>（4）集合U新加入頂點B。與頂點B鄰接頂點有A、C、D、F。A、C已經在集合內，不能再被選取。頂點B到頂點D、F的距離分別為2、3。頂點C到頂點E、F距離分別為7、8。因此選擇距離最短邊（B，D），將D標記，並將D添加至集合U中。</p><p>（5）集合U中頂點有A、B、C、D。頂點A無可選頂點。頂點B可選頂點有F，距離為3。頂點C可選頂點有E、F，對應距離分別為8、7。頂點D可選頂點為F，對應距離為6。因此選取距離最短的邊（B，F），標記F，並將F添加至集合U中。</p><p>（6）集合U中頂點有A、B、C、D、F。頂點A、B、D均無可選頂點。頂點C可選頂點為E，對應距離為8。頂點F可選頂點為E，對應距離為7。選取距離最短的邊（F，E），標記E，將E添加至集合U中。</p><p>（7）集合U中頂點有A、B、C、D、E、F，但是均沒有可選頂點，樹的生成過程結束。</p><h3 class=pgc-h-arrow-right>3.3 性能分析</h3><p>  Prim算法使用鄰接矩陣來保存圖的話，時間複雜度是O(N2)，使用二叉堆優化Prim算法的時間複雜度為O((V + E) log(V)) = O(E log(V))。</p><h2 class=pgc-h-arrow-right>4 克魯斯卡算法——Kruskal算法</h2><h3 class=pgc-h-arrow-right>4.1 算法流程</h3><p>  （1）把圖中的所有邊按代價從小到大排序。  （2）把圖中的n個頂點看成獨立的n棵樹組成的森林。  （3）按權值從小到大選擇邊，所選的邊連接的兩個頂點ui,vi。ui,vi應屬於兩顆不同的樹，則成為最小生成樹的一條邊，並將這兩顆樹合併作為一顆樹。   （4）重複步驟(3),直到所有頂點都在一顆樹內或者有n-1條邊為止。</p><h3 class=pgc-h-arrow-right>4.2 算法圖解</h3><p>例如：圖4.2所示的無向圖，採用Kruskal算法構建最小生成樹過程如下。</p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ff8171177e9841d8aa51beb637b256e3><p class=pgc-img-caption></p></div><p>img</p><p><br>（1）首先將所有的邊按照代價大小進行排序，排序結果為（B，D），（B，F）（A，C），（B，C），（A，B），（D，F），（E，F），（C，E）。</p><p><br></p><p>（2）代價最小邊為（B，D），頂點B、D不在同一棵樹上，將頂點B、D合併到一棵子樹。</p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e6ac4fd40fe438cb952201fd616ce75><p class=pgc-img-caption></p></div><p>img</p><p><br>（3）代價最小邊為（B，F），頂點B、F不在同一棵樹上，將頂點B、F合併到一棵子樹。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/87918c44cec34a5dad09093ed97261a3><p class=pgc-img-caption></p></div><p>img</p><p><br>（4）代價最小邊為（A、C），頂點A、C不在同一棵樹上，將頂點A、C合併到一棵子樹。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7c27c82bcfde49c888958f8e2f5c82dc><p class=pgc-img-caption></p></div><p>img</p><p><br>（5）代價最小邊為（B，C），頂點B、C不在同一棵樹上，將頂點B、C合併到一棵子樹。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/81f45569171d43c4a9ef73e536a40013><p class=pgc-img-caption></p></div><p>img</p><p><br>（6）代價最小邊為（A，B），頂點A、B在同一棵樹上，因此不能選擇此邊。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/464c22596b64492ca0155b7ae1ede6da><p class=pgc-img-caption></p></div><p>img</p><p><br>（7）代價最小邊為（D，F），頂點D、F在同一棵樹上，因此不能選擇此邊。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ace38ef57b2f464e8a1a22aa81b1741c><p class=pgc-img-caption></p></div><p>img</p><p><br>（8）代價最小邊為（E，F），頂點E、F不在同一棵樹上，將頂點E、F合併到一棵子樹。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b3ce0f83b4b74a3a9a0529a357f6d7ca><p class=pgc-img-caption></p></div><p>img</p><p><br>（9）代價最小邊為（C，E），頂點C、E在同一棵樹上，因此不能選擇此邊。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/12a134dc5c164abdbb2bd40f00d040d2><p class=pgc-img-caption></p></div><p>img</p><p><br>（10）所有頂點均在同一棵樹內，生成過程完畢。最小生成樹為：<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e73e039a6713415f9d446e5be7465d06><p class=pgc-img-caption></p></div><p>img</p><h3 class=pgc-h-arrow-right>4.3 性能分析</h3><p>  Kruskal算法為了提高每次貪心選擇時查找最短邊的效率，可以先將圖G中的邊按代價從小到達排序，則這個操作的時間複雜度為O(elge)，其中e為無向連通網中邊的個數。對於兩個頂點是否屬於同一個連通分量，可以用並查集的操作將其時間性能提高到O(n)，所以Kruskal算法的時間性能是O(elge)。</p><h2 class=pgc-h-arrow-right>5 Boruvka算法</h2><p>  Boruvka算法是最小生成樹算法中最為古老的算法。類似於Kruskal算法，Bruvka算法也是逐步添加子樹的方式構建。但是Bruvka算法是分步完成，每一步都增加多條邊。在每一步中，會連接每一棵子樹與另一棵子樹的最短邊，再將所有這樣的邊都增加到最小生成樹中。</p><h3 class=pgc-h-arrow-right>5.1 算法流程</h3><p>  （1）用定點數組記錄每個子樹（一開始是單個定點）的最近鄰接頂點。  （2）對於每一條邊進行處理（類似Kruskal算法）。如果這條邊連成的兩個頂點同屬於一個集合，則不處理，否則檢測這條邊連接的兩個子樹，如果是連接這兩個子樹的最小邊則合併。</p><h3 class=pgc-h-arrow-right>5.2 算法圖解</h3><p>例如：圖5.2所示的無向圖，使用Boruvka算法構建最小生成樹過程如下。</p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5cfef4bf353d4d12ac3f67e0586002c9><p class=pgc-img-caption></p></div><p>img</p><p><br>（1）找到各個頂點的最近鄰接點。A最近為C，B最近為D，C最近為A，D最近為B，E最近為B，F最近為E，標記各個最近鄰接頂點之間的邊，得到2個子樹。因此還需要一條邊將兩個子樹連接起來。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a5e8f5672c44042a67d31d645349058><p class=pgc-img-caption></p></div><p>img</p><p><br>（2）對每一條邊進行處理。（A，C）、（B，D）、（B，F）、（D，F）、（E，F）邊分別屬於同一子樹，因此不處理。在剩餘的邊（A，B）、（B，C）、（C，F）、（C，E）中選取一條邊來連接子樹。選取權值最小的邊（B，C）進行子樹合併。<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2e76c1bfc2f348d5bca89da0f4a06b0a><p class=pgc-img-caption></p></div><p>img</p><p><br>（3）得到最終的最小生成樹如下：<br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4a8e629b131845ebaac537077eafd1fb><p class=pgc-img-caption></p></div><p>img</p><h3 class=pgc-h-arrow-right>5.4 性能分析</h3><p>  每次循環迭代時，每棵樹都會合併成一棵較大的子樹，因此每次循環迭代都會使子樹的數量至少減少一半.所以，循環迭代的總次數為O(logn)。每次循環迭代所需要的計算時間：每次檢查所有邊的時間複雜度為O(m)。所以總的複雜度為O(e*logv)。</p><h2 class=pgc-h-arrow-right>6 基於權矩陣的最小生成樹算法</h2><p>  徐建軍、沙力妮等發表了一篇一種新的最小生成樹算法文章。此算法是從最小生成樹的性質出發，通過構造權矩陣的方式來得到圖的最小生成樹。  設圖G1是圖G的最小生成樹，則G1具有如下性質：  （1）G1中的各條邊權值之和最小。  （2）G1中有n個頂點n-1條邊。  （3）G1必須是連通的且無迴路。</p><h3 class=pgc-h-arrow-right>6.1 算法流程</h3><p>  （1）根據圖的頂點數n以及各邊對應的權值建立權矩陣A。矩陣A的主對角線上元素A[i][i]為0。若頂點i與頂點j不直接相連，A[i][j]=0 。  （2）在權矩陣A中，按行搜索非零最小元。若某行中有幾個非零最小元，則任取其一。記錄各行的非零最小元及其腳標，並將權矩陣中對應的該元素賦值為0，其關於對角線對稱的元素也應為0，得到新的權矩陣B（這樣後面尋找行的次非零最小元就轉換成尋找該行的非零最小元了）。比較找到的所有非零最小元，如果同時存在 A[i][j]、 A[j][i]，則去掉其中一個。統計此時非零最小元的個數k。  （3）比較k與n-1的大小。若k=n-1則由這k個元素對應的k條邊構成的圖即為所求最小生成樹，生成過程結束。若k﹤n-1，說明這k條邊構成的圖沒有連通，轉步驟（4）。  （4）在剩下的邊中尋找權值最小的（n-1-k）條邊使k個非零最小元對應的k條邊構成的圖連通。</p><h3 class=pgc-h-arrow-right>6.2 實例說明</h3><p>例如：圖6.2.1所示的帶權無向圖，使用權矩陣方法建立最小生成樹過程。</p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b5ae746757204d20b059676c5e49367f><p class=pgc-img-caption></p></div><p>圖6.2.1</p><p>  （1）根據圖中的頂點、邊以及權值建立權矩陣A。</p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a10a4763f72f4054be7624693173da9c><p class=pgc-img-caption></p></div><p>img</p><p><br>  （2）在權矩陣A中，按行搜索最小非零元。記錄各行的最小非零元及其腳標。按行找到的非零最小元依次是： A[1][2]， A[2][1]， A[3][2]， A[4][5]， A[5][4]， A[6][1]， A[7][8]，A[8][7]。將 A中這些元素所對應的值全部變為0。在找出的所有非零最小元中同時出現了A[1][2]和A[2][1]；A[7][8]和A[8][7]； A[4][5]和A[5][4]，故可去掉A[2][1]，A[5][4]和A[8][7]。剩下的最小非零元為 A[1][2]，A[3][2]，A[4][5]，A[6][1]，A[7][8]。統計非零最小元素個數k=5。<br>  （3）比較k與n-1的大小，k=5，n-1=7，k&lt;n-1。轉步驟（4）。<br>  （4）尋找權值最小的（n-1-k）條邊使k個最小非零元對應的邊構成的圖連通。n-1-k=8-1-5=2，說明還需要兩條邊才能使已有邊構成的圖連通。第一個最小非零元A[1][2]的腳標12分別與A[3][2]，A[6][1]的腳標32、61有交集，說明這三個元素對應的邊是連通的。將腳標12，32，61 取並集，再判斷此並集與剩餘元素A[4][5]、 A[7][8]的腳標是否有交集。很明顯，並集（1236）與45、78 都沒有交集，且45與78之間也沒有交集。 因此我們知道A[4][5]與A[7][8]所對應的邊互不相連，並且和其他三條邊也沒有連通。<br>  在步驟（2）中已經將A[4][5]和A[5][4]的值變為0了，所以只需在現有權矩陣A的第4行和第5行中分別找出一個非零最小元，二者取較小值，從而得到A[5][6]。在現有權矩陣A的第7行和第8行中分別找出一個非零最小元，二者取較小值。第7行和第8行的非零最小元 A[7][1]= A[8][6]，可任取其一。這裡取A[8][6]。A[5][6]和A[8][6]分別對應的邊就是我們要尋找的兩條邊。這樣，由A[1][2]，A[3][2]，A[4][5]，A[5][6]，A[6][1]，A[7][8]，A[8][6]分別對應的邊構成的圖即為所求的最小生成樹。最終結果如圖6.2.2所示。</p><p><br></p><div class=pgc-img><img alt=數據結構與算法——最小生成樹 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/54cb360ece5b4f4ca0110828bc0734b1><p class=pgc-img-caption></p></div><p>圖6.2.2</p><h2 class=pgc-h-arrow-right>7 結語</h2><p>  圖的最小生成樹算法種類有很多，但是以 Prim 算法和 Kruskal 算法最為經典。希望讀者在讀完本篇文章後，不僅能理解最小生成樹的構造過程，同時也能理解各類算法的解題思想。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>算法</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/5f49cdf4.html alt="算法數據結構 | 圖論基礎算法——拓撲排序" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/08463ba999024f5196ee88aa19271453 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/5f49cdf4.html title="算法數據結構 | 圖論基礎算法——拓撲排序">算法數據結構 | 圖論基礎算法——拓撲排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a4da90.html alt=數據結構與算法系列——棧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0d4a7d6b37a44c58a0ea25dcacf791fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a4da90.html title=數據結構與算法系列——棧>數據結構與算法系列——棧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3e3bf2.html alt=數據結構與算法（5）棧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/64b8a77987c34980862b62b33586c54e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3e3bf2.html title=數據結構與算法（5）棧>數據結構與算法（5）棧</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/cf78e53.html alt=數據結構與算法：算法的時間複雜度 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e6eb9908a8c7481089159ead17c42eae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/cf78e53.html title=數據結構與算法：算法的時間複雜度>數據結構與算法：算法的時間複雜度</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>