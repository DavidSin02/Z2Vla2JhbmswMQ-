<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>WebSocket硬核入門：徒手擼WebSocket服務器 | 极客快訊</title><meta property="og:title" content="WebSocket硬核入門：徒手擼WebSocket服務器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/076eaa5654164ae495c20d74874a4100"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/011549b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/011549b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/011549b.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="WebSocket硬核入門：徒手擼WebSocket服務器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/011549b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>WebSocket硬核入門：徒手擼WebSocket服務器</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文原題“Node.js - 200 多行代碼實現 Websocket 協議”，為了提升內容品質，有較大修訂。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1、引言</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">最近正在研究 WebSocket 相關的知識，想著如何能自己實現 WebSocket 協議。到網上搜羅了一番資料後用 Node.js 實現了一個WebSocket協議服務器，倒也沒有想象中那麼複雜，除去註釋語句和 console 語句後，大約 200 行代碼左右。</span></p><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/076eaa5654164ae495c20d74874a4100><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文分享了自已開發一個WebSocket服務端實現過程中需要的知識儲備，以及具體的代碼實現含義等，非常適合想在短時間內對WebSocket協議從入門到精通的Web端即時通訊開發者閱讀。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如果你想要寫一個WebSocket 服務器，首先需要讀懂對應的網絡協議 RFC6455，不過這對於一般人來說有些 “晦澀”，英文且不說，還得咬文嚼字理解 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">網絡編程</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 含義。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">好在 WebSocket 技術出現比較早，所以早就有人翻譯了完整的 RFC6455中文版，網上也有很多針對該協議的剖析文章，很多文章裡還有現成的實現代碼可以參考，所以說實現一個簡單的 WebSocket 服務並非難事。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文更偏向實戰（in action），會從知識儲備、具體代碼分析以及注意事項角度去講解如何用 Node.js 實現一個簡單的 WebSocket 服務，至於 WebSocket 概念、定義、解釋和用途等基礎知識不會涉及，因為這些知識在本文所列的參考文章中輕鬆找到。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">友情提示：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文對應的源碼，請從文末“11、代碼下載”一節下載</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">之</span><span style="color:#404040;--tt-darkmode-color: #A3A3A3">。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">學習交流：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">- 開源IM框架源碼：https://github.com/JackJiang2011/MobileIMSDK</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（本文同步發佈於：http://www.52im.net/thread-3175-1-1.html）</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2、關於作者</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">作者網名：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">JSCON簡時空</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">作者微博：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">https://weibo.com/271111536</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">博客地址：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">https://segmentfault.com/u/jscon</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Github主頁：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">https://boycgit.github.io/</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3、基本常識</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在學習本文內容之前，我認為很有必要簡單瞭解一下Web端即時通訊技術的“過去”和“現在”，因為新時代的開發者（沒有經歷過短輪詢、長輪詢、Comet技術的這波人），很難理解WebSocket對於Web端的即時通訊技術來說，意味著什麼。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所謂“憶苦思甜”，瞭解了Web端即時通訊技術的過去，方知WebSocket這種技術的珍貴。。。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3.1 舊時代的Web端即時通訊技術</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">自從Web端即時通訊的概念提出後，“實時”性便成為了Web開發者們津津樂道的話題。實時化的Web應用，憑藉其響應迅速、無需刷新、節省網絡流量的特性，不僅讓開發者們眼前一亮，更是為用戶帶來絕佳的網絡體驗。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">但很多開發者可能並不清楚，舊時代的Web端“實時”通信，主要基於 Ajax的拉取和Comet的推送。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">大家都知道Ajax，這是一種藉助瀏覽器端JavaScript實現的異步無刷新請求功能：要客戶端按需向服務器發出請求，並異步獲取來自服務器的響應，然後按照邏輯更新當前頁面的相應內容。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">但是這僅僅是拉取啊，這並不是真正的“實時”：缺少服務器端的自動推送！</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">因此，我們不得不使用另一種略複雜的技術 Comet，只有當這兩者配合起來，這個Web應用才勉強算是個“實時”的Web端應用！</span></p><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/829528f2b3864f0a923a317c3be4bdbe><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">▲ Ajax和Comet技術原理（圖片引用自《Web端即時通訊技術盤點》）</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3.2 WebSocket協議出現</span></h1><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/29df5fb17f7f4642a6f81fc7df2c6877><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">隨著HTML5標準的出現，WebSocket技術橫空出世，隨著HTML5標準的廣泛普及，越來越多的現代瀏覽器開始全面支持WebSocket技術了。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">至於WebSocket，我想大家或多或少都聽說過。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket是一種全新的協議。它將TCP的Socket（套接字）應用在了web page上，從而使通信雙方建立起一個保持在活動狀態連接通道，並且屬於全雙工（雙方同時進行雙向通信）。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">事實是：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket協議是借用HTTP協議的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">101 switch protocol</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 來達到協議轉換的，從HTTP協議切換成WebSocket通信協議。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">再簡單點來說，它就好像將 Ajax 和 Comet 技術的特點結合到了一起，只不過性能要高並且使用起來要方便的多（方便當然是之指在客戶端方面了）。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4、WebSocket知識儲備</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如果要自己寫一個 WebSocket 服務，主要有兩個難點：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">熟練掌握 WebSocket 的協議，這個需要多讀現有的解讀類文章（下面會給出參考文章）；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">操作二進制數據流，在 Node.js 中需要對 Buffer 這個類稍微熟悉些。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">同時還需要具備兩個基礎知識點：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">網絡編程中使用 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">大端</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">字節</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">序 </span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">表示大於一字節的數據，稱之為 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">網絡字節序</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> （不曉得大小端的，推薦閱讀《史上最通俗大小端字節序詳解》）；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">瞭解最高有效位（MSB， Most Significant Bit），不太清楚的，可以參考《LSB最低有效位和MSB最高有效位》。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">具體的做法如下，推薦先閱讀以下幾篇參考文章：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《學習WebSocket協議—從頂層到底層的實現原理（修訂版）》：作者本身就用Node.js實現過一遍，知識點講解挺透徹，適合優先閱讀；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《WebSocket詳解（一）：初步認識WebSocket技術》：是一系列的文章，從淺入深，配有豐富的圖文；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《WebSocket從入門到精通，半小時就夠！》：全文以Q&A形式組織，要點都解讀到了，還涉及了建立連接、交換數據、幀格式及網絡安全等；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">《MDN - Writing WebSocket servers》：MDN 官方教程，讀一遍沒啥壞處。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">然後開始寫代碼。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在實現過程中的大部分代碼可以從下面幾篇文章中找到並借鑑（copy）：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">nodejs 實現：簡化版本的從這兒借鑑過來的；</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">學習WebSocket協議—從頂層到底層的實現原理（修訂版）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">閱讀完上面的文章，你會有發現一個共同點，就是在實現 WebSockets 過程中，最最核心的部分就是 解析 或者 生成 Frame（幀）。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">就是下面這結構：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0cb38d90b384313ae5792447bd57232><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">▲ 截圖來自《rfc6455 - Base Framing Protocol》</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">想要理解 frame 各個字段的含義，可參考《WebSocket詳解（三）：深入WebSocket通信協議細節》，文中作者繪製了一副圖來解釋這個 frame 結構。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而在代碼層面，frame 的解析或生成可以在 RocketEngine - parser 或者 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">_processBuffer</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 中找到。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在完成上面幾個方面的知識儲備之後，而且大多有現成的代碼，所以自己邊抄邊寫一個 Websocket 服務端實現並不算太難。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">對於 WebSocket 初學者，請務必閱讀以上參考文章，對 Websocket 協議有大概的瞭解之後再繼續本文剩下部分的閱讀，否則很有可能會覺得我寫得雲裡霧裡，不知所云。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">5、實戰效果預覽</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本次的實現代碼可以從文末“11、代碼下載”章節下載到：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（請從原文鏈接下載：http://www.52im.net/thread-3175-1-1.html）</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">下載後本地運行即可，執行：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">node index.js</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">運行成功後，將會在 http://127.0.0.1:3000 創建服務。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">運行服務之後，打開控制檯就能看到效果：</span></strong></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">動圖中瀏覽器 console 所執行的 js 代碼步驟如下：</span></strong></p><p style=text-align:start><em><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）先建立連接：</span></strong></em></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var ws = new WebSocket("ws://127.0.0.1:3000");</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.onmessage = function(evt) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">console.log( "Received Message: "+ evt.data);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">};</span></span></p></blockquote><p style=text-align:start><em><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）然後發送消息：</span></strong></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（注意一定要在建立連接之後再執行該語句，否則發不出消息的）</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.send('hello world');</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">從效果可見，我們已經實現 WebSocket 最基本的通訊功能了。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">接下來我們詳細看一下具體實現的細節。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">6、代碼解讀1：調用所寫的 WebSocket 類</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">站在使用者的角度，假設我們已經完成 WebSocket 類了，那麼應該怎麼使用？</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">客戶端通過 HTTP Upgrade 請求，即 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">101 Switching Protocol </span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">到 HTTP 服務器，然後由服務器進行協議轉換。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在 Node.js 中我們通過 http.createServer 獲取 http.server 實例，然後監聽 upgrade 事件，在處理這個事件。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如下面的代碼所示：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// HTTP服務器部分</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var server = http.createServer(function(req, res) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">res.end('websocket test\r\n');</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// Upgrade請求處理</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">server.on('upgrade', function(req, socket, upgradeHead){</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 初始化 ws</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var ws = new WebSocket(req, socket, upgradeHead);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// ... ws 監聽 data、error 的邏輯等</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這裡監聽 upgrade 事件的回調函數中第二個參數 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 是 net.Socket實例，這個類是 TCP 或 UNIX Socket 的抽象，同時一個 net.Socket 也是一個 duplex stream，所以它能被讀或寫，並且它也是一個 EventEmitter。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我們就利用這個 socket 對象上進行 Websocket 類實例的初始化工作；</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">7、代碼解讀2：構造函數</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">所以不難理解 Websocket 的構造函數就是下面這個樣子：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">class WebSocket extends EventEmitter {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">constructor(req, socket, upgradeHead){</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">super(); // 調用 EventEmitter 構造函數</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 1. 構造響應頭 resHeaders 部分</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 2. 監聽 socket 的 data 事件，以及 error 事件</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 3. 初始化成員屬性</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">注意：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我們需要繼承內置的 EventEmitter ，這樣生成的實例才能監聽、綁定事件。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Node.js 採用事件驅動、異步編程，天生就是為了網絡服務而設計的，繼承 EventEmitter 就能享受到非阻塞模式的 IO 處理。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這裡特別講一下其中 響應頭的構造 和 事件監聽 部分。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">7.1 返回響應頭（Response Header）</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根據協議規範，我們能寫出</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">響應</span></strong><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">頭的內容：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）將 Sec-WebSocket-Key 跟 258EAFA5-E914-47DA-95CA-C5AB0DC85B11 拼接；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）通過 SHA1 計算出摘要，並轉成 base64 字符串。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">具體代碼如下：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var resKey = hashWebSocketKey(req.headers['sec-websocket-key']);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 構造響應頭</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var resHeaders = [</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'HTTP/1.1 101 Switching Protocols',</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'Upgrade: websocket',</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'Connection: Upgrade',</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">'Sec-WebSocket-Accept: '+ resKey</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">]</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">.concat('', '')</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">.join('\r\n');</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">socket.write(resHeaders);</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">當執行 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket.write(resHeaders);</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 到後就和客戶端建立起 WebSocket 連接了，剩下去就是數據的處理。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">7.2 監聽事件</span></h1><p style=text-align:start><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 就是 TCP 協議的抽象，直接在上面監聽已有的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">data</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 事件和 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">close</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 事件這兩個事件。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">還有其他事件，比如 error、end 等，詳細參考 net.Socket 文檔。</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">socket.on('data', data => {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.buffer = Buffer.concat([this.buffer, data]);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">while(this._processBuffer()) {} // 循環處理返回的 data 數據</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">socket.on('close', had_error => {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">if(!this.closed) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.emit('close', 1006);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.closed = true;</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">});</span></span></p></blockquote><p style=text-align:start><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">close</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 的事件邏輯比較簡單，比較重要的是 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">data</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 的事件監聽部分。核心就是 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">this._processBuffer()</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 這個方法，用於處理客戶端傳送過來的數據（即 Frame 數據）。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">注意：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">該方法是放在 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">while</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 循環語句裡，處理好邊界情況，防止死循環。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8、代碼解讀3：Frame 幀數據的處理</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket 客戶端、服務端通信的最小單位是幀（frame），由1個或多個幀組成一條完整的消息（message）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這 this._processBuffer() 部分代碼邏輯就是用來解析幀數據的，所以它是實現 WebSocket 代碼的關鍵；（該方法裡面用到了大量的位操作符以及 Buffer 類的操作）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">幀數據結構詳細定義可參考 RFC6455 5.2節（英文不好的話，去下載中文翻譯版《WebSocket標準協議手冊（稀缺中文版+英文原版）》），上面羅列的參考文章都有詳細的解讀，我在這兒也不囉嗦講細節了，直接看代碼比聽我用文字講要好。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這裡就其中兩個細節需要鋪墊一下，方便更好地理解代碼。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8.1 操作碼（Opcode）</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Opcode 即 操作代碼，Opcode 的值決定了應該如何解析後續的數據載荷（data payload）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根據 Opcode 我們可以大致將數據幀分成兩大類：數據幀 和 控制幀。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">數據幀，目前只有 3 種，對應的 opcode 是：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x0：數據延續幀</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x1：utf-8文本</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x2：二進制數據；</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x3 - 0x7：目前保留，用於後續定義的非控制幀。</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">控制幀，除了上述 3 種數據幀之外，剩下的都是控制幀：</span></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x8：表示連接斷開</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0x9：表示 ping 操作</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0xA：表示 pong 操作</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">0xB - 0xF：目前保留，用於後續定義的控制幀</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在代碼裡，我們會先從幀數據中提取操作碼：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var opcode = byte1 & 0x0f; //截取第一個字節的後 4 位，即 opcode 碼</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">然後根據協議獲取到真正的數據載荷（data payload），然後將這兩部分傳給 _handleFrame 方法：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this._handleFrame(opcode, payload); // 處理操作碼</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8.2 分片（Fragment）</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本節代碼對應的標準文檔：5.4 - Fragmentation（英文不好的話，去下載中文翻譯版《WebSocket標準協議手冊（稀缺中文版+英文原版）》）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">一旦 WebSocket 客戶端、服務端建立連接後，後續的操作都是基於數據幀的傳遞。理論上來說，每個幀（Frame）的大小是沒有限制的。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">對於大塊的數據，WebSocket 協議建議對數據進行分片（Fragment）操作。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">分片的意義主要是兩方面：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）主要目的是允許當消息開始但不必緩衝該消息時發送一個未知大小的消息。如果消息不能被分片，那麼端點將不得不緩衝整個消息以便在首字節發生之前統計出它的長度。對於分片，服務器或中間件可以選擇一個合適大小的緩衝，當緩衝滿時，再寫一個片段到網絡；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）另一方面分片傳輸也能更高效地利用多路複用提高帶寬利用率，一個邏輯通道上的一個大消息獨佔輸出通道是不可取的，因此多路複用需要可以分割消息為更小的分段來更好的共享輸出通道。參考文檔《I/O多路複用（multiplexing）是什麼？》。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket 協議提供的分片方法，是將原本一個大的幀拆分成數個小的幀。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">下面是把一個大的Frame分片的圖示：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7073e27315174cf58cbf645cf92fc171><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">由圖可知，第一個分片的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">FIN</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 為 0，Opcode 為非0值（0x1 或 0x2），最後一個分片的FIN為1，Opcode為 0。中間分片的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">FIN</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 和 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">opcode</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 二者均為 0。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根據 FIN 的值來判斷，是否已經收到消息的最後一個數據幀：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）FIN=1 表示當前數據幀為消息的最後一個數據幀，此時接收方已經收到完整的消息，可以對消息進行處理；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）FIN=0，則接收方還需要繼續監聽接收其餘的數據幀。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">opcode在數據交換的場景下，表示的是數據的類型：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）0x01 表示文本，永遠是 utf8 編碼的；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）0x02 表示二進制；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）0x00 比較特殊，表示 延續幀（continuation frame），顧名思義，就是完整消息對應的數據幀還沒接收完。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">代碼裡，我們需要檢測 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">FIN</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 的值，如果為 0 說明有分片，需要記錄第一個 FIN 為 0 時的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">opcode</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 值，緩存到 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">this.frameOpcode</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 屬性中，將載荷緩存到 this.frames 屬性中。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">8.3 發送數據幀</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">上面講的都是接收並解析來自客戶端的數據幀，當我們想給客戶端發送數據幀的時候，也得按協議來。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這部分操作相當於是上述 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">_processBuffer</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 方法的逆向操作，在代碼裡我們使用 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">encodeMessage</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 方法（為了簡單起見，我們發送給客戶端的數據沒有經過掩碼處理）將發送的數據分裝成數據幀的格式，然後調用 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket.write</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 方法發送給客戶端。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">如下所示：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">_doSend(opcode, payload) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 1. 考慮數據分片</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.socket.write(</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">encodeMessage(count > 0 ? OPCODES.CONTINUE : opcode, payload)</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">); //編碼後直接通過socket發送</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">為了考慮分片場景，特意設置 MAX_FRAME_SIZE 來對每次發送的數據長度做截斷做分片：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// ...</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var len = Buffer.byteLength(payload);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 分片的距離邏輯</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var count = 0;</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// 這裡可以針對 payload 的長度做分片</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">while(len > MAX_FRAME_SIZE) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var framePayload = payload.slice(0, MAX_FRAME_SIZE);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">payload = payload.slice(MAX_FRAME_SIZE);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">this.socket.write(</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">encodeMessage(</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">count > 0 ? OPCODES.CONTINUE : opcode,</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">framePayload,</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">false</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">)</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">); //編碼後直接通過socket發送</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">count++;</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">len = Buffer.byteLength(payload);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">}</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">// ...</span></span></p></blockquote><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">至此已經實現 WebSocket 協議的關鍵部分，所組裝起來的代碼就能和客戶端建立 WebSocket 連接並進行數據交互了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9、有關WebSocket的常見疑問</span></h1><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9.1 字符串 “258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 怎麼來的？</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這個標誌性字符串是專門標示 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 協議的 UUID；UUID 是長度為 16-byte（128-bit）的ID，一般以形如</span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">f81d4fae-7dec-11d0-a765-00a0c91e6bf6</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">的字符串作為 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">URN</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（Uniform Resource Name，統一資源名稱）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">UUID 可以移步到《UUID原理》和 RFC 4122 獲取更多知識。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">為啥選擇這個字符串？</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在WebSocket標準協議文檔的第七頁已經有明確的說明了：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/754559c44da14d879029c8d60b4fd59c><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（英文不好的話，見中文翻譯版《WebSocket標準協議手冊（稀缺中文版+英文原版）》）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">之所以選用這個 UUID ，主要該 ID 極大不太可能被其他不瞭解 WebSocket 協議的網絡終端所使用。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我也不曉得該怎麼翻譯。總之，就說這個 ID 就相當於 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 協議的 “身份證號” 了。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9.2 Websocket 和 HTTP 什麼關係？</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">HTTP、WebSocket 等應用層協議，都是基於 TCP 協議來傳輸數據的，我們可以把這些高級協議理解成對 TCP 的封裝。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">既然大家都使用 TCP 協議，那麼大家的連接和斷開，都要遵循 TCP 協議中的三次握手和四次握手 ，只是在連接之後發送的內容不同，或者是斷開的時間不同。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">對於 WebSocket 來說，它必須依賴 HTTP 協議進行一次握手 ，握手成功後，數據就直接從 TCP 通道傳輸，與 HTTP 無關了。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">更詳細的解釋，可以移步：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">《WebSocket詳解（四）：刨根問底HTTP與WebSocket的關係(上篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">《WebSocket詳解（五）：刨根問底HTTP與WebSocket的關係(下篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">《WebSocket詳解（六）：刨根問底WebSocket與Socket的關係》</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">9.3 瀏覽器中 Websocket 會自動分片麼？</span></h1><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">答案是：</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">看具體瀏覽器的實現。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">WebSocket是一個 message based 的協議，它可以自動將數據分片，並且自動將分片的數據組裝。每個 message 可以是一個或多個分片。message 不記錄長度，分片才記錄長度。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">根據協議 websocket 協議中幀長度上限為 2^63 byte（為 8388608 TB），可以認為沒有限制，很明顯按協議的最大上限來傳輸數據是不靠譜的。所以在實際使用中 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">websocket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 消息長度限制取決於具體的實現。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">關於這方面，找了兩篇參考文章：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）《WebSocket需要像TCP Socket那樣進行邏輯數據包的分包與合包嗎?》：WebSocket是一個message-based的協議，它可以自動將數據分片，並且自動將分片的數據組裝；；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）《websocket長文本問題？》：這裡給出了長文本 ws 傳輸實踐總結。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在文章《WebSocket探祕》中，作者就做了一個實驗，作者發送 27378 個字節，結果被迫分包了；如果是大數據量，就會被socket自動分包發送。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而經過我本人試驗，發現 Chrome 瀏覽器（版本 68.0.3440.106 - 64bit）會針對 131072（=2^17）bytes 大小進行自動分包。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">我是通過以下測試代碼驗證：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var ws = new WebSocket("ws://127.0.0.1:3000");</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.onmessage = function(evt) {</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">console.log( "Received Message: "+ evt.data);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">};</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">var myArray = new ArrayBuffer(131072 * 2 + 1);</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">ws.send(myArray);</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">服務端日誌：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">server detect fragment, sizeof payload: 131072</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">server detect fragment, sizeof payload: 131072</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">receive data: 2 262145</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">客戶端日誌：</span></strong></p><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">Received Message: good job</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">截圖如下：</span></strong></p><div class=pgc-img><img alt=WebSocket硬核入門：徒手擼WebSocket服務器 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/abedfb7c3b0c4c55b55695a03449375c><p class=pgc-img-caption></p></div><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而以同樣的方式去測試一些自己機器上的瀏覽器：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）Firefox（62.0，64bit）；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）safari (11.1.2 - 13605.3.8)；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）IE 11。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">這些客戶端上的 WebSocket 幾乎沒有大小的分片（隨著數據量增大，發送會減緩，但並沒有發現分片現象）。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">10、本文小結</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">從剛開始決定閱讀 WebSocket 協議，到自己使用 Node.js 實現一套簡單的 WebSocket 協議，到這篇文章的產出，前後耗費大約 1 個月時間（拖延症。。。）。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">感謝文中所提及的參考文獻所給予的幫助，讓我實現過程中事半功倍。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">之所以能夠使用較少的代碼實現 WebSocket，是因為 Node.js 體系本身了很好的基礎，比如其所提供的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">EventEmitter</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 類自帶事件循環，http 模塊讓你直接使用封裝好的 </span><em><span style="color:#404040;--tt-darkmode-color: #A3A3A3">socket</span></em><span style="color:#404040;--tt-darkmode-color: #A3A3A3"> 對象，我們只要按照 WebSocket 協議實現 Frame（幀）的解析和組裝即可。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">在實現一遍 WebSocket 協議後，就能較為深刻地理解以下知識點（一切都是那麼自然而然）：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）Websocket 是一種應用層協議，是為了提供 Web 應用程序和服務端</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">全雙工通信</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">而專門制定的；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）WebSocket 和 HTTP </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">都是基於 TCP 協議實現的</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）WebSocket和 HTTP 的唯一關聯就是 HTTP 服務器需要發送一個 “</span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">Upgrade</span></strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">” 請求，即 101 Switching Protocol 到 HTTP 服務器，然後由服務器進行協議轉換。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）WebSocket使用 HTTP 來建立連接，但是定義了一系列新的 header 域，這些域在 HTTP 中並不會使用；</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">5）WebSocket 可以和 HTTP Server </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">共享同一 port</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">6）WebSocket 的 </span><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">數據幀有序</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">...</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文僅僅是協議的簡單實現，對於 WebSocket 的其實還有很多事情可以做（比如支持 命名空間、流式 API 等），有興趣的可以參考業界流行的 WebSocket 倉庫，去練習鍛造一個健壯的 WebSocket 工具庫輪子。</span></p><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">比如下面這些：</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">1）socketio/socket.io：43.5k star，不多說，業界權威龍頭老大。（不過這實際上不是一個 WebSocket 庫，而是一個實時 pub/sub 框架。簡單地說，Socket.IO 只是包含 WebSocket 功能的一個框架，如果要使用該庫作為 server 端的服務，則 client 也必須使用該庫，因為它不是標準的 WebSocket 協議，而是基於 WebSocket 再包裝的消息通信協議）</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">2）websockets/ws：9k star，強大易用的 websocket 服務端、客戶端實現，還有提供很多強大的特性</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">3）uNetworking/uWebSockets：9.5k star，小巧高性能的 WebSocket實現，C++ 寫的，想更多瞭解 WebSocket 的底層實現，該庫是不錯的案例。</span></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">4）theturtle32/WebSocket-Node：2.3k star，大部分使用 JavaScript，性能關鍵部分使用 C++ node-gyp 實現的庫。其所列的 測試用例 有挺好的參考價值。</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">11、代碼下載</span></h1><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（因無法上傳源碼附件，如有需要，請從此鏈接下載：http://www.52im.net/thread-3175-1-1.html）</span></p><h1 class=pgc-h-arrow-right><span style="color:#404040;--tt-darkmode-color: #A3A3A3">12、參考資料</span></h1><blockquote><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[1]《新手入門貼：史上最全Web端即時通訊技術原理詳解》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[2]《Web端即時通訊技術盤點：短輪詢、Comet、Websocket、SSE》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[3]《SSE技術詳解：一種全新的HTML5服務器推送事件技術》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[4]《Comet技術詳解：基於HTTP長連接的Web端實時通信技術》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[5]《新手快速入門：WebSocket簡明教程》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[6]《WebSocket詳解（一）：初步認識WebSocket技術》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[7]《WebSocket詳解（二）：技術原理、代碼演示和應用案例》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[8]《WebSocket詳解（三）：深入WebSocket通信協議細節》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[9]《WebSocket詳解（四）：刨根問底HTTP與WebSocket的關係(上篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[10]《WebSocket詳解（五）：刨根問底HTTP與WebSocket的關係(下篇)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[11]《WebSocket詳解（六）：刨根問底WebSocket與Socket的關係》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[12]《Web端即時通訊技術的發展與WebSocket、Socket.io的技術實踐》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[13]《使用WebSocket和SSE技術實現Web端消息推送》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[14]《詳解Web端通信方式的演進：從Ajax、JSONP 到 SSE、Websocket》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[15]《MobileIMSDK-Web的網絡層框架為何使用的是Socket.io而不是Netty？》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[16]《理論聯繫實際：從零理解WebSocket的通信原理、協議格式、安全性》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[17]《微信小程序中如何使用WebSocket實現長連接(含完整源碼)》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[18]《八問WebSocket協議：為你快速解答WebSocket熱門疑問》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[19]《Web端即時通訊實踐乾貨：如何讓你的WebSocket斷網重連更快速？》</span></span></p><p><span style="color:#404040;--tt-darkmode-color: #A6A6A6"><span style="background-color:#fafafa;--tt-darkmode-bgcolor: #171717">[20]《WebSocket從入門到精通，半小時就夠！》</span></span></p></blockquote><p style=text-align:start><strong><span style="color:#404040;--tt-darkmode-color: #A3A3A3">本文已同步發佈在“即時通訊技術圈”公眾號。</span></strong></p><p style=text-align:start><span style="color:#404040;--tt-darkmode-color: #A3A3A3">（同步發佈鏈接：</span>http://www.52im.net/thread-3175-1-1.html<span style="color:#404040;--tt-darkmode-color: #A3A3A3">）</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>WebSocket</a></li><li><a>硬核</a></li><li><a>入門</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc63183.html alt=「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ac7fb5fb22b8449392a90146180d194f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc63183.html title=「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪>「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c476abf.html alt="硬核航空 FAG公司用於航宇軸承的壽命計算方法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/034ea8ed652c4ccfb55292e01084573f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c476abf.html title="硬核航空 FAG公司用於航宇軸承的壽命計算方法">硬核航空 FAG公司用於航宇軸承的壽命計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html alt=EXCEL入門基礎：對行和列選定數據求和 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1f03f82096d240dd92410709f3e19eb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19664ba8.html title=EXCEL入門基礎：對行和列選定數據求和>EXCEL入門基礎：對行和列選定數據求和</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html alt=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49834ccb43ed42cb9a54c9827c3ab134 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5abb53a8.html title=工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！>工程造價從入門到精通：造價員全能圖解+工程算量表，限時分享！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html alt=工程造價：入門知識全套講義，30章600頁，精通造價首選之作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e1b335c343a455f8777dd3144fc1c35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a5f8d5f.html title=工程造價：入門知識全套講義，30章600頁，精通造價首選之作>工程造價：入門知識全套講義，30章600頁，精通造價首選之作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html alt=“黑客”入門學習之“Windows組策略” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea21244d5f5c420ebef29650f3fafd1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html title=“黑客”入門學習之“Windows組策略”>“黑客”入門學習之“Windows組策略”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7be4199.html alt=硬核：激光結構光的原理、設計和類型詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RvXexXME6SXKyZ style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7be4199.html title=硬核：激光結構光的原理、設計和類型詳解>硬核：激光結構光的原理、設計和類型詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html alt=PHP入門教程，5天86節課助力小白變大神！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4366000004d4c98fd587 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d08c7e6.html title=PHP入門教程，5天86節課助力小白變大神！>PHP入門教程，5天86節課助力小白變大神！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html alt=Thinkphp6快速入門一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c4331ddc0ffb4c94a4aa80be95178354 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/923fd40e.html title=Thinkphp6快速入門一>Thinkphp6快速入門一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html alt="php新手入門教程， 最全最完整的教學視頻課程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/666a38216ab04790a716bb1451c7fe44 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d2ce3d6.html title="php新手入門教程， 最全最完整的教學視頻課程">php新手入門教程， 最全最完整的教學視頻課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html alt=「素描入門」基礎不紮實，從排線練起 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15252166717297d7af296ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07454552.html title=「素描入門」基礎不紮實，從排線練起>「素描入門」基礎不紮實，從排線練起</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html alt=「素描入門」素描排線的繪畫技法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1530098801296ab58189790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07c706e2.html title=「素描入門」素描排線的繪畫技法>「素描入門」素描排線的繪畫技法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a993b442.html alt=素描入門丨你說線條或者排線，容易嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1536648317995f32cedaa40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a993b442.html title=素描入門丨你說線條或者排線，容易嗎？>素描入門丨你說線條或者排線，容易嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0e2c5d2.html alt=零基礎入門要知道的素描知識總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/c2c16563-8821-4294-a8c6-9d76e62a2440 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0e2c5d2.html title=零基礎入門要知道的素描知識總結>零基礎入門要知道的素描知識總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>