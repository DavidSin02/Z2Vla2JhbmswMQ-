<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>模板方法模式，看JDK和Spring是如何優雅複用代碼的 | 极客快訊</title><meta property="og:title" content="模板方法模式，看JDK和Spring是如何優雅複用代碼的 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e9326cdf61814b6b96f535ed06981f24"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/02e75145.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/02e75145.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/02e75145.html><meta property="article:published_time" content="2020-11-14T21:00:09+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:09+08:00"><meta name=Keywords content><meta name=description content="模板方法模式，看JDK和Spring是如何優雅複用代碼的"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/02e75145.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>模板方法模式，看JDK和Spring是如何優雅複用代碼的</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e9326cdf61814b6b96f535ed06981f24><p class=pgc-img-caption></p></div><p>Keeper導讀：不管是我們學習併發編程中的 AQS，還是看 Spring 的源碼，肯定都會遇到模板方法模式，它簡直太常見了。</p><h1 class=pgc-h-arrow-right>前言</h1><p>模板，顧名思義，它是一個固定化、標準化的東西。</p><p>模板方法模式是一種行為設計模式， 它在超類中定義了一個算法的框架， 允許子類在不修改結構的情況下重寫算法的特定步驟。</p><h1 class=pgc-h-arrow-right>場景問題</h1><p>程序員不願多扯，上來先幹兩行代碼</p><p>網上模板方法的場景示例特別多，個人感覺還是《Head First 設計模式》中的例子比較好。</p><p>假設我們是一家飲品店的師傅，起碼需要以下兩個手藝</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c20010887dfe44f1abfcc41fb8ef8b54><p class=pgc-img-caption></p></div><p>真簡單哈，這麼看，步驟大同小異，我的第一反應就是寫個業務接口，不同的飲品實現其中的方法就行，像這樣</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9a58aee8b98e46cbb231875c58d2210a><p class=pgc-img-caption></p></div><p>畫完類圖，猛地發現，第一步和第三步沒什麼差別，而且做飲品是個流程式的工作，我希望使用時，直接調用一個方法，就去執行對應的製作步驟。</p><p>靈機一動，不用接口了，用一個抽象父類，把步驟方法放在一個大的流程方法 makingDrinks() 中，且第一步和第三步，完全一樣，沒必要在子類實現，改進如下</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8e5cd9ca95664878b041aa8799749aa2><p class=pgc-img-caption></p></div><p>再看下我們的設計，感覺還不錯，現在用同一個 makingDrinks() 方法來處理咖啡和茶的製作，而且我們不希望子類覆蓋這個方法，所以可以申明為 final，不同的製作步驟，我們希望子類來提供，必須在父類申明為抽象方法，而第一步和第三步我們不希望子類重寫，所以我們聲明為非抽象方法</p><pre><code>public abstract class Drinks {    void boilWater() {        System.out.println("將水煮沸");    }    abstract void brew();    void pourInCup() {        System.out.println("倒入杯子");    }    abstract void addCondiments();        public final void makingDrinks() {        //熱水        boilWater();        //沖泡        brew();        //倒進杯子        pourInCup();        //加料        addCondiments();    }}</code></pre><p>接著，我們分別處理咖啡和茶，這兩個類只需要繼承父類，重寫其中的抽象方法即可（實現各自的沖泡和添加調料）</p><pre><code>public class Tea extends Drinks {    @Override    void brew() {        System.out.println("沖茶葉");    }    @Override    void addCondiments() {        System.out.println("加檸檬片");    }}</code></pre><pre><code>public class Coffee extends Drinks {    @Override    void brew() {        System.out.println("衝咖啡粉");    }    @Override    void addCondiments() {        System.out.println("加奶加糖");    }}</code></pre><p>現在可以上崗了，試著製作下咖啡和茶吧</p><pre><code>public static void main(String[] args) {    Drinks coffee = new Coffee();    coffee.makingDrinks();    System.out.println();    Drinks tea = new Tea();    tea.makingDrinks();}</code></pre><p>好嘞，又學會一個設計模式，這就是模板方法模式，我們的 makingDrinks() 就是模板方法。我們可以看到相同的步驟 boilWater() 和 pourInCup() 只在父類中進行即可，不同的步驟放在子類實現。</p><h1 class=pgc-h-arrow-right>認識模板方法</h1><p>在閻宏博士的《JAVA與模式》一書中開頭是這樣描述模板方法（Template Method）模式的：</p><blockquote><p>模板方法模式是類的行為模式。準備一個抽象類，將部分邏輯以具體方法以及具體構造函數的形式實現，然後聲明一些抽象方法來迫使子類實現剩餘的邏輯。不同的子類可以以不同的方式實現這些抽象方法，從而對剩餘的邏輯有不同的實現。這就是模板方法模式的用意。</p></blockquote><p>寫代碼的一個很重要的思考點就是“變與不變”，程序中哪些功能是可變的，哪些功能是不變的，我們可以把不變的部分抽象出來，進行公共的實現，把變化的部分分離出來，用接口來封裝隔離，或用抽象類約束子類行為。模板方法就很好的體現了這一點。</p><p>模板方法定義了一個算法的步驟，並允許子類為一個或多個步驟提供實現。</p><p>模板方法模式是所有模式中最為常見的幾個模式之一，是基於繼承的代碼複用的基本技術，我們再看下類圖</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7cf50ba0b51b4356887db970fda8120a><p class=pgc-img-caption></p></div><p>模板方法模式就是用來創建一個算法的模板，這個模板就是方法，該方法將算法定義成一組步驟，其中的任意步驟都可能是抽象的，由子類負責實現。這樣可以確保算法的結構保持不變，同時由子類提供部分實現。</p><p>再回顧下我們製作咖啡和茶的例子，有些顧客要不希望咖啡加糖或者不希望茶里加檸檬，我們要改造下模板方法，在加相應的調料之前，問下顧客</p><pre><code>public abstract class Drinks {    void boilWater() {        System.out.println("將水煮沸");    }    abstract void brew();    void pourInCup() {        System.out.println("倒入杯子");    }    abstract void addCondiments();    public final void makingDrinks() {        boilWater();        brew();        pourInCup();        //如果顧客需要，才加料        if (customerLike()) {            addCondiments();        }    }    //定義一個空的缺省方法，只返回 true    boolean customerLike() {        return true;    }}</code></pre><p>如上，我們加了一個邏輯判斷，邏輯判斷的方法時一個只返回 true 的方法，這個方法我們叫做 鉤子方法。</p><blockquote><p>鉤子：在模板方法的父類中，我們可以定義一個方法，它默認不做任何事，子類可以視情況要不要覆蓋它，該方法稱為“鉤子”。</p></blockquote><p>鉤子方法一般是空的或者有默認實現。鉤子的存在，可以讓子類有能力對算法的不同點進行掛鉤。而要不要掛鉤，又由子類去決定。</p><p>是不是很有用呢，我們再看下咖啡的製作</p><pre><code>public class Coffee extends Drinks {    @Override    void brew() {        System.out.println("衝咖啡粉");    }    @Override    void addCondiments() {        System.out.println("加奶加糖");    }  //覆蓋了鉤子，提供了自己的詢問功能，讓用戶輸入是否需要加料    boolean customerLike() {        String answer = getUserInput();        if (answer.toLowerCase().startsWith("y")) {            return true;        } else {            return false;        }    }    //處理用戶的輸入    private String getUserInput() {        String answer = null;        System.out.println("您想要加奶加糖嗎？輸入 YES 或 NO");        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));        try {            answer = reader.readLine();        } catch (IOException e) {            e.printStackTrace();        }        if (answer == null) {            return "no";        }        return answer;    }}</code></pre><p>接著再去測試下代碼，看看結果吧。</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/479362bb34734a7bb74a2e8ac665f52d><p class=pgc-img-caption></p></div><p>我想你應該知道鉤子的好處了吧，它可以作為條件控制，影響抽象類中的算法流程，當然也可以什麼都不做。</p><p>模板方法有很多種實現，有時看起來可能不是我們所謂的“中規中矩”的設計。接下來我們看下 JDK 和 Spring 中是怎麼使用模板方法的。</p><h1 class=pgc-h-arrow-right>JDK 中的模板方法</h1><p>我們寫代碼經常會用到 comparable 比較器來對數組對象進行排序，我們都會實現它的 compareTo() 方法，之後就可以通過 Collections.sort() 或者 Arrays.sort() 方法進行排序了。</p><p>具體的實現類就不寫了(可以去 github：starfish-learning 上看我的代碼)，看下使用</p><pre><code>@Overridepublic int compareTo(Object o) {    Coffee coffee = (Coffee) o;    if(this.price &lt; (coffee.price)){        return -1;    }else if(this.price == coffee.price){        return 0;    }else{        return 1;    }}</code></pre><pre><code>public static void main(String[] args) {  Coffee[] coffees = {new Coffee("星冰樂",38),                      new Coffee("拿鐵",32),                      new Coffee("摩卡",35)};   Arrays.sort(coffees);  for (Coffee coffee1 : coffees) {    System.out.println(coffee1);  }}</code></pre><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d214692222b4bf087da710d78236d2e><p class=pgc-img-caption></p></div><p>你可能會說，這個看著不像我們常規的模板方法，是的。我們看下比較器實現的步驟</p><ol start=1><li>構建對象數組</li><li>通過 Arrays.sort 方法對數組排序，傳參為 Comparable 接口的實例</li><li>比較時候會調用我們的實現類的 compareTo() 方法</li><li>將排好序的數組設置進原數組中，排序完成</li></ol><p>一臉懵逼，這個實現竟然也是模板方法。</p><p>這個模式的重點在於提供了一個固定算法框架，並讓子類實現某些步驟，雖然使用繼承是標準的實現方式，但通過回調來實現，也不能說這就不是模板方法。</p><p>其實併發編程中最常見，也是面試必問的 AQS 就是一個典型的模板方法。</p><h1 class=pgc-h-arrow-right>Spring 中的模板方法</h1><p>Spring 中的設計模式太多了，而且大部分擴展功能都可以看到模板方式模式的影子。</p><p>我們看下 IOC 容器初始化時中的模板方法，不管是 XML 還是註解的方式，對於核心容器啟動流程都是一致的。</p><p>AbstractApplicationContext 的 refresh 方法實現了 IOC 容器啟動的主要邏輯。</p><p>一個 refresh() 方法包含了好多其他步驟方法，像不像我們說的 模板方法，getBeanFactory() 、refreshBeanFactory() 是子類必須實現的抽象方法，postProcessBeanFactory() 是鉤子方法。</p><pre><code>public abstract class AbstractApplicationContext extends DefaultResourceLoader      implements ConfigurableApplicationContext { @Override public void refresh() throws BeansException, IllegalStateException {  synchronized (this.startupShutdownMonitor) {   prepareRefresh();   ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();   prepareBeanFactory(beanFactory);            postProcessBeanFactory(beanFactory);            invokeBeanFactoryPostProcessors(beanFactory);            registerBeanPostProcessors(beanFactory);            initMessageSource();            initApplicationEventMulticaster();            onRefresh();            registerListeners();            finishBeanFactoryInitialization(beanFactory);            finishRefresh();  } }    // 兩個抽象方法    @Override public abstract ConfigurableListableBeanFactory getBeanFactory() throws   IllegalStateException;         protected abstract void refreshBeanFactory() throws BeansException, IllegalStateException;        //鉤子方法    protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) { } }</code></pre><p>打開你的 IDEA，我們會發現常用的 ClassPathXmlApplicationContext 和 AnnotationConfigApplicationContext 啟動入口，都是它的實現類（子類的子類的子類的...）。</p><p>AbstractApplicationContext的一個子類 AbstractRefreshableWebApplicationContext 中有鉤子方法 onRefresh()的實現：</p><pre><code>public abstract class AbstractRefreshableWebApplicationContext extends …… {    /**  * Initialize the theme capability.  */ @Override protected void onRefresh() {  this.themeSource = UiApplicationContextUtils.initThemeSource(this); }}</code></pre><p>看下大概的類圖：</p><div class=pgc-img><img alt=模板方法模式，看JDK和Spring是如何優雅複用代碼的 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/111c2466c16b4a54b89d41f79ca1e5a4><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>小總結</h1><p>優點：1、封裝不變的部分，擴展可變的部分。2、提取公共代碼，便於維護。3、行為由父類控制，子類實現。</p><p>缺點：每一個不同的實現都需要一個子類來實現，導致類的個數增加，使得系統更加龐大。</p><p>使用場景：1、有多個子類共有的方法，且邏輯相同。2、重要的、複雜的方法，可以考慮作為模板方法。</p><p>注意事項：為防止惡意操作，一般模板方法都加上 final 關鍵詞。</p><h1 class=pgc-h-arrow-right>參考：</h1><p>《Head First 設計模式》、《研磨設計模式》</p><p>https://sourcemaking.com/design_patterns/template_method</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JDK</a></li><li><a>Spring</a></li><li><a>優雅</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html alt=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/433259b5-1936-4cee-ab74-70aef36536ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html title=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理>（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b0c3e55.html alt=此花卉漂亮，以“月光”為名，潔白優雅，花香四溢，觀賞性強！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15264532028374c2c6fe4c2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b0c3e55.html title=此花卉漂亮，以“月光”為名，潔白優雅，花香四溢，觀賞性強！>此花卉漂亮，以“月光”為名，潔白優雅，花香四溢，觀賞性強！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html alt="Spring Boot 統一異常這樣處理和剖析，安否？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/95dd8dbd-33ff-4c32-a4b5-fd78e6126995 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html title="Spring Boot 統一異常這樣處理和剖析，安否？">Spring Boot 統一異常這樣處理和剖析，安否？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcf7d4b4.html alt="Spring事務失效的 8 大原因，這次可以吊打面試官了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcf7d4b4.html title="Spring事務失效的 8 大原因，這次可以吊打面試官了">Spring事務失效的 8 大原因，這次可以吊打面試官了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e83df1dd.html alt=Spring切面獲取不到request的參數值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0b6e5064b47940df843a25466066845d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e83df1dd.html title=Spring切面獲取不到request的參數值>Spring切面獲取不到request的參數值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad5a94ae.html alt=「翻新日記」修復一臺優雅非凡的奔馳W211，向逝去的經典致敬 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a447bcb3f38942618b7e79986898283c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad5a94ae.html title=「翻新日記」修復一臺優雅非凡的奔馳W211，向逝去的經典致敬>「翻新日記」修復一臺優雅非凡的奔馳W211，向逝去的經典致敬</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html alt=我是如何閱讀JDK源碼的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25b18fb619994fcbaa58c5e28b7a4e51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html title=我是如何閱讀JDK源碼的？>我是如何閱讀JDK源碼的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63225a40.html alt=【凱悅家居】窗簾｜優雅而不俗的搭配技巧，你Get到了嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c3cb88b19e4146c88b2a787f69cb2366 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63225a40.html title=【凱悅家居】窗簾｜優雅而不俗的搭配技巧，你Get到了嗎？>【凱悅家居】窗簾｜優雅而不俗的搭配技巧，你Get到了嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html alt="Spring Boot中文參考指南（2.1.6）90、熱交換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52221486045249f1a4a361d34e84016e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html title="Spring Boot中文參考指南（2.1.6）90、熱交換">Spring Boot中文參考指南（2.1.6）90、熱交換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49610033.html alt=“瞬息浮生”——時光與優雅的融合 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1531224233920fbe3ae915f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49610033.html title=“瞬息浮生”——時光與優雅的融合>“瞬息浮生”——時光與優雅的融合</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>