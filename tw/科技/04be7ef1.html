<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用 | 极客快訊</title><meta property="og:title" content="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/b0c5d689c0ca42da947c8e3d5c6711ef"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/04be7ef1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/04be7ef1.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/04be7ef1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1 、FAT 文件系統概述</strong></p><p><strong>1.1 FAT 概述</strong></p><p>文件分配表 （FAT）文件系統是由比爾蓋茨與麥克唐納所開發。它是一種格式，某種程度上 也算是軟件，它用於在存儲設備 （比如磁盤驅動或內存）上保存和組織文件。它用於方便文 件與目錄的訪問。</p><p>FAT 文件系統提供一種途徑來記錄文件被創建或更改時的時間標記，並且提供了識別文件大 小的方法。這套系統提供了保存文件其它屬性的一套機制，比如文件是否只讀，是否應在目 錄顯示中隱藏，或者是否應在下一次磁盤備份中歸檔。</p><p>FAT 文件系統特別適合消費電子產品中的移動閃存介質，比如數碼相機、媒體播放器和閃存 盤等。</p><p>FAT 文件系統可以在以下場合中帶來幫助：</p><p>• 由於 FAT 文件系統具備向後兼容性，用戶可以利用記憶棒或軟盤在消費電子設備和採用 過時操作系統的計算機之間傳輸文件。</p><p>• FAT 文件系統讓用戶能夠快速刪除電子設備上的文件，就像在專業廣播媒介中那樣。</p><p>• FAT16 或 FAT32 的文件系統版本均適用於硬盤卷。</p><p>另外，如果用戶想要通過軟盤訪問硬盤捲上的數據 （往往指系統恢復工具）來引導計算機的 話，這些版本也很有用處。</p><p><strong>1.1.1 主引導記錄</strong></p><p>主引導記錄（MBR）位於設備物理起始位置上的一個或多個扇區。MBR 的引導區包含 DOS 引導加載程序代碼，該代碼會在設備格式化後被寫入（否則不會被動態 C FAT 文件系統所使 用）。引導區之後是分區表。分區表中含有四個 16 字節的條目，允許設備劃分多達四個分區。</p><p>分區表條目中含有一些關鍵信息：分區類型 （動態 C FAT 可識別 FAT12 和 FAT16 的分區類</p><p>型）以及分區的起始與結束扇區號。另外還有一個字段指明分區中的扇區總數。如果該數字 為零，則對應的分區是空的可用分區。</p><div class=pgc-img><img alt="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b0c5d689c0ca42da947c8e3d5c6711ef><p class=pgc-img-caption></p></div><p>某些設備經格式化後沒寫入 MBR，因此便也沒有分區表。目前在動態 C FAT 文件系統中並不 支持這種配置</p><p><strong>1.1.2 FAT 分區</strong></p><p>有效 FAT 文件系統分區的第一個扇區中包含 BIOS 參數塊 （BPB） ，之後是文件分配表 （FAT），再之後是根目錄。下圖顯示了具備兩個 FAT 分區的設備。</p><div class=pgc-img><img alt="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f9af60225d6d47ec9ebb6c2703f7e51e><p class=pgc-img-caption></p></div><p>BIOS 參數塊</p><p>BPB 中的字段包含該分區的描述信息：</p><p>• 每個扇區的字節數；</p><p>• 每個簇的扇區數；</p><p>• 該分區的扇區總數；</p><p>• 根目錄下的條目數。</p><p>FAT 分配表</p><p>文件分配表是一種結構，也是 FAT 文件系統的命名由來。 FAT 中保存了關於簇的分配信息。 一個簇既可以分配給一個文件，也可以使用，還可以標記為壞簇。 FAT 分配表的副本會緊跟 著第一個 FAT 分配表存放。</p><p>根目錄</p><p>根目錄具有預定義的位置及大小。根目錄有 512 個條目，每個條目 32 字節。根目錄中的條目 既可以是空條目，也可以包含文件或子目錄名稱（以 8.3 格式）、文件大小、上一次修改的日 期時間以及文件或子目錄的起始簇號。</p><p>數據區</p><p>數據區佔據了分區中的大部分空間。其中包含文件數據與子目錄。請注意，按照慣例，分區 的數據區必須從第 2 簇開始。</p><p>欲瞭解更多信息，請參考 Microsoft® EFI FAT32 文件系統規範。</p><p><strong>2 、FatFs 文件系統</strong></p><p><strong>2.1 FatFs 概述</strong></p><p>FatFs 是適用於小型嵌入式系統的 FAT 文件系統模塊。FatFs 是按照 ANSI C 的標準來指定， 且與磁盤 I/O 層完全分隔開。因此， FatFs 與硬件架構完全無關，具有以下特點：</p><p>• 兼容 Windows 的 FAT 文件系統。</p><p>• 極小的代碼量和工作區</p><p>• 豐富的配置選項：</p><p>– 多卷 （物理驅動與分區）。</p><p>– 多個 ANSI/OEM 代碼頁，包括 DBCS。</p><p>– 以 ANSI/OEM 或 Unicode 支持長文件名。</p><p>– 支持 RTOS。</p><p>– 支持多種扇區大小。</p><p>– 只讀、小化的 API、 I/O 緩衝等等 ......</p><p>– FAT子類型：FAT12、 FAT16 和 FAT32。</p><p>– 打開的文件數量：無限制，取決於可用的內存。</p><p>– 卷的數量：多達 10 個。</p><p>– 文件大小：取決於 FAT 規範。（多達 4G-1 字節）</p><p>– 卷的大小：取決於 FAT 規範。（512 字節 / 扇區情況下，支持多達 2T 字節）</p><p>– 簇的大小：取決於 FAT 規範。（512 字節 / 扇區情況下，支持多達 64K 字節）</p><p>– 扇區的大小：取決於 FAT 規範。（多達 4K 字節）</p><p><strong>2.2 FatFs 架構</strong></p><p>FatFs 模塊是一箇中間件，提供許多用於訪問 FAT 卷的函數，比如 f_open()、 f_close()、 f_read()、 f_write() 等等 （參考 ff.c）。</p><p>該模塊沒有平臺依賴性，只要編譯器符合 ANSI C 即可。</p><p>使用底層磁盤 I/O 模塊來讀取 / 寫入物理驅動。</p><p>採用 RTC 模塊來獲取當前時間。</p><p>底層磁盤 I/O 和 RTC 模塊均與 FatFs 模塊完全分離。它們必須由用戶提供，這是將 FatFs 模 塊與其它平臺相連的主要工作。</p><p><br></p><div class=pgc-img><img alt="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c2028a1af89d434ca488df49305601f1><p class=pgc-img-caption></p></div><p><strong>2.3 FatFs 特性</strong></p><p><strong>2.3.1 複製文件訪問</strong></p><p>FatFs 模塊默認並不支持對複製文件的共享控制。僅當文件的打開方式為只讀模式時，才允許 共享控制。禁止以寫入模式對文件進行復制打開，而且打開的文件不允許被重命名和刪除，否 則會破壞卷的 FAT 結構。</p><p>當將 _FS_LOCK 設為 1 或更大的數值時，也可使用文件共享控制。 該數值設定了同時管理</p><p>的文件數目。在這種情況下，如果嘗試 “ 打開 ”、“ 重命名 ” 或 “ 刪除 ” 等違反上述文件共享規 則的操作，則文件功能失敗，提示 FR_LOCKED。如果打開的文件數量大於 _FS_LOCK，那 麼 f_open() 函數也會執行失敗，提示 FR_TOO_MANY_OPEN_FILES。</p><p><strong>2.3.2 可重入性</strong></p><p>對不同卷的文件操作是可重入的，並且可以同時工作。對同一個卷的文件操作是不可重入的， 但可利用 _FS_REENTRANT option 選項配置為線程安全。在這種情況下，必須將依賴於操 作系統的同步對象控制函數ff_cre_syncobj()、ff_del_syncobj()、ff_req_grant()和ff_rel_grant() 添加到項目中。</p><p>當卷被其它任務使用時，如果文件函數被調用，則這個文件函數會保持掛起，直至該任務結 束。如果等待時間超過 _TIMEOUT 所設定的時間，那麼文件函數會以 FR_TIMEOUT 退出。 某些 RTOS 並不支持這種超時功能。</p><p>f_mount() 和 f_mkfs() 函數是例外。這些函數對於同一個卷並不具備可重入性。當使用這些函 數時，所有其它任務必須關閉該捲上的對應文件，以避免對卷的訪問。</p><p>請注意，這一節描述的是 FatFs 模塊本身的可重入性，但底層磁盤 I/O 層也必須是可重入的。</p><p><strong>2.3.3 長文件名</strong></p><p>FatFs 模塊從版本 0.07 開始便支持長文件名 （LFN）。除了 f_readdir() 函數以外，一個文件 的 SFN 和 LFN 這兩種不同的文件名對於文件函數來說是透明的。如需使能 LFN 功能，請將 _USE_LFN 設為 1、 2 或 3，然後在項目中添加 Unicode 代碼轉換函數 ff_convert() 和 ff_wtoupper()。LFN 功能需要附加一個特定的工作緩衝。緩衝的大小可根據可用內存大小，利 用 _MAX_LFN 來進行配置。長文件名可達 255 個字符，所以 _MAX_LFN 應設為 255，以實 現完全的 LFN 功能。如果工作緩衝的大小不足以存放給定的文件名，則文件函數執行失敗並 提示 FR_INVALID_NAME。當以可重入功能使能 LFN 特性時，_USE_LFN 必須設為 2 或 3。 這種情況下，文件函數會在棧或堆裡分配工作緩衝。工作緩衝會佔據 (_MAX_LFN + 1) * 2 個 字節。</p><p>當使能 LFN 功能時，模塊大小會根據所選擇的代碼頁而有所增大。右表顯示了當以某些代碼 頁使能 LFN 功能時，所增加的字節數。</p><p><strong>2.4、FatFs API</strong></p><p>FatFs 的 API 層用於執行文件系統 API。它採用磁盤 I/O 接口與適當的物理驅動通信。這些 API 可劃分為四組：</p><p>• 操作邏輯卷或分區的 API 分組。</p><p>• 操作目錄的 API 分組。</p><p>• 操作文件的 API 分組。</p><p>• 操作文件和目錄的 API 分組。</p><p>以下列出了 FatFs 訪問 FAT 卷時所能執行的操作：</p><p>• f_mount()：掛載 / 卸載邏輯磁盤</p><p>• f_open()：打開 / 創建文件</p><p>• f_close()：關閉文件</p><p>• f_read()：讀取文件</p><p>• f_write()：寫入文件</p><p>• f_lseek()：移動讀 / 寫指針，擴大文件的大小</p><p>• f_truncate()：截取文件到當前已讀 / 已寫指針位置</p><p>• f_sync()：同步內存中的數據到磁盤</p><p>• f_opendir()：打開一個目錄</p><p>• f_readdir()：讀取目錄條目</p><p>• f_getfree()：獲取空閒的簇的數量</p><p>• f_stat()：檢查對象是否存在，並獲取其狀態</p><p>• f_mkdir()：創建目錄</p><p>• f_unlink()：刪除文件或目錄</p><p>• f_chmod()：更改屬性</p><p>• f_utime()：更改時間戳</p><p>• f_rename()：重命名 / 移動文件或目錄</p><p>• f_chdir()：更改當前目錄</p><p>• f_chdrive()：更改當前驅動</p><p>• f_getcwd()：檢索當前目錄</p><p>• f_getlabel()：獲取卷標籤</p><p>• f_setlabel()：設置卷標籤</p><p>• f_forward()：將文件數據直接轉發至流</p><p>• f_mkfs()：在驅動上創建文件系統</p><p>• f_fdisk()：劃分物理驅動</p><p>• f_gets()：讀取字符串</p><p>• f_putc()：寫入字符</p><p>• f_puts()：寫入字符串</p><p>• f_printf()：寫入格式化的字符串</p><p>• f_tell()：獲取當前的讀 / 寫指針</p><p>• f_eof()：檢驗是否達到文件末尾</p><p>• f_size()：獲取文件大小</p><p>• f_error()：檢驗文件是否出錯</p><p><strong>2.5 FatFs 底層 API</strong></p><p>由於 FatFs 模塊與磁盤 I/O 和 RTC 模塊完全分離，所以需要一些底層功能來操作物理驅動： 讀 / 寫和獲取當前時間。因為底層磁盤 I/O 功能和 RTC 模塊並非 FatFs 模塊的組成部分，所 以必須由用戶提供。</p><p>FatFs 中間件解決方案為某些支持的磁盤驅動（RAMDisk、uSD、USBDisk）提供底層磁盤 I/O 驅動。</p><p>已添加額外接口層 diskio.c，用於為 FatFs 模塊動態添加 / 刪除（鏈接）物理介質，提供如下 所述的底層磁盤 I/O 函數：</p><p>• disk_initialize()：初始化物理磁盤驅動</p><p>• disk_status()：返回所選物理驅動的狀態</p><p>• disk_read()：讀取磁盤中的扇區</p><p>• disk_write()：將扇區寫入磁盤</p><p>• disk_ioctl()：控制設備的專用功能</p><p>• get_fattime()：返回當前時間 應用程序禁止調用這些函數，這些函數僅可由 FatFs 文件系統函數調用，比如 f_mount()、 f_read()、 f_write()...</p><p><strong>2.6 將 FatFs 整合至 STM32CubeF4</strong></p><p>在 STM32CubeF4 解決方案中，已添加額外的接口層，用於動態地添加 / 刪除 FatFs 模塊的 物理介質。如需以底層磁盤 I/O 驅動來連接 FatFs 模塊，用戶可以使用 FATFS_LinkDriver() 和 FATFS_UnLinkDriver() 動態地添加或者刪除磁盤 I/O 驅動；應用程序可能需要知道當前連 接的磁盤 I/O 驅動數量，這一點可通過 FATFS_GetAttachedDriversNbr() API 來實現。</p><p><br></p><div class=pgc-img><img alt="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b82e52b4538145d2a2d928af695968c5><p class=pgc-img-caption></p></div><p>通用的底層驅動 ff_gen_drv.c/h 位於 FatFs 模塊的根目錄下。採用兩個磁盤 I/O 驅動類型定義 結構，協助動態管理 ff_gen_drv.h 文件下所連接的磁盤驅動，如下所述：</p><p><br></p><div class=pgc-img><img alt="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8c1c5d57161f4cd398b4225684379d41><p class=pgc-img-caption></p></div><p>如需將 FatFs 模塊與底層磁盤 I/O 驅動相連接，用戶可以使用以下 API：</p><p>• FATFS_LinkDriver()：用於動態添加磁盤 I/O 驅動。</p><p>• FATFS_UnLinkDriver()：用於動態刪除磁盤 I/O 驅動。</p><p>• FATFS_GetAttachedDriversNbr()：瞭解當前所連接的磁盤 I/O 驅動數量</p><p><strong>2.6.1 FATFS_LinkDriver()</strong></p><p>該函數用於連接兼容的磁盤 I/O 驅動，並增加已激活連接的驅動的數量。如果成功則返回 0， 失敗則返回 1。</p><p>注 :因為 FatFs方 面 的 限 制 ， 所 連 接 的 磁 盤 大 數 目 （ _VOLUMES ）為 10個。</p><p>FATFS_LinkDriver 的實現：</p><pre><code>uint8_t FATFS_LinkDriver(Diskio_drvTypeDef *drv, char *path) {    uint8_t ret = 1;  uint8_t DiskNum = 0;    if(disk.nbr &lt;= _VOLUMES)  {        disk.drv[disk.nbr] = drv;          DiskNum = disk.nbr++;        path[0] = DiskNum + '0';        path[1] = ':';        path[2] = '/';        path[3] = 0;        ret = 0;    }    return ret; }</code></pre><p><strong>2.6.2 FATFS_UnlinkDriver()</strong></p><p>該函數用於解除與磁盤 I/O 驅動的連接，並減少已激活連接的驅動數量。如果成功則返回 0， 失敗則返回 1。</p><p>FATFS_UnLinkDriver 的實現：</p><pre><code>uint8_t FATFS_UnLinkDriver(char *path) {     uint8_t DiskNum = 0;    uint8_t ret = 1;      if(disk.nbr &gt;= 1)    {            DiskNum = path[0] - '0';        if(DiskNum &lt;= disk.nbr)0        {      disk.drv[disk.nbr--] = 0;            ret = 0;        }    }      return ret; }</code></pre><p><strong>2.6.3 FATFS_GetAttachedDriverNbr()</strong></p><p>該函數返回已連接至 FatFs 模塊的驅動數量。</p><p>FATFS_GetAttachedDriversNbr 的實現：</p><pre><code>uint8_t FATFS_GetAttachedDriversNbr(void)                                    {  return disk.nbr; }</code></pre><p><strong>2.7 將自己的磁盤連接至 FatFs</strong></p><p>如果工作存儲控制模塊可用，應通過粘合函數連接至 FatFs，而不是進行修改。用戶可以開發 適當的磁盤 I/O 底層驅動來連接任意的新磁盤（mynewdisk_diskio.c/.h），並將這些驅動文件 保存在：\Middlewares\Third_Party\FatFs\src\drivers。</p><p>值得注意的是，所提供的 FatFs 磁盤 I/O 底層驅動依賴於板級 BSP 驅動。如需移除這種 BSP 依賴性，用戶可以將 “BSP_...” 的 API 調用替換為自己的代碼，以確保實現正確的功能性。</p><p>如需從頭開始開發磁盤 I/O 底層驅動，用戶可以從下述的粘合函數骨架開始，用已定義的 API 將現有的存儲控制模塊添加到 FatFs。</p><p>適用於 FatFs 的底層磁盤 I/O 模塊骨架：</p><pre><code>/*-------------------------------------------------------------------------*/ /* mynewdisk_diskio.c：適用於 FAT 的底層磁盤 I/O 模塊框架 */ /*-------------------------------------------------------------------------*//* 包含的頭文件 -------------------------------------------------------------*/ #include &lt;string.h&gt; #include "ff_gen_drv.h" /* 私有的宏定義 ---------------------------------------------------------*/ #define BLOCK_SIZE 512 /* Block Size in Bytes *//* 私有變量 --------------------------------------- */ static volatile DSTATUS Stat = STA_NOINIT; /* 磁盤狀態 *//* 私有函數原型 --------------------------------------------*/ DSTATUS mynewdisk_initialize (void);DSTATUS mynewdisk_status (void); DRESULT mynewdisk_read (BYTE*, DWORD, BYTE); #if _USE_WRITE == 1    DRESULT mynewdisk_write (const BYTE*, DWORD, BYTE); #endif /* _USE_WRITE == 1 */ #if _USE_IOCTL == 1    DRESULT mynewdisk_ioctl (BYTE, void*); #endif  /* _USE_IOCTL == 1 */  Diskio_drvTypeDef  mynewdisk_Driver = {    mynewdisk_initialize,    mynewdisk_status,    mynewdisk_read, #if  _USE_WRITE == 1    mynewdisk_write, #endif /* _USE_WRITE == 1 *//*------------------------ 初始化驅動 ---------------------------*/ DSTATUS mynewdisk_initialize (void) {    Stat = STA_NOINIT;      // 在此寫入自己的代碼，對驅動進行初始化    Stat &amp;= ~STA_NOINIT;    return Stat; }/*------------------------- 獲取磁盤狀態 -----------------------------*/ DSTATUS mynewdisk_status (void) {    Stat = STA_NOINIT;  // 在此寫入自己的代碼       return Stat;}/*-------------------------- 讀取扇區 -----------------------------*/ DRESULT mynewdisk_read (BYTE *buff, /* 保存讀取數據的數據緩衝 */                                       DWORD sector, /* 扇區地址 （LBA） */                                       BYTE count) /* 讀取的扇區數 （1..128） */ {    DRESULT res = RES_ERROR;  // 在此寫入自己的代碼，讀取驅動中的扇區       return res; }/*--------------------------- 寫入扇區 ---------------------------*/ #if _USE_WRITE == 1 DRESULT mynewdisk_write (const BYTE *buff, /* 需寫入的數據緩存指針 */                         DWORD sector, /* 扇區地址 （LBA） */                                         BYTE count) /* 需寫入的扇區數 （1..128） */{    DRESULT res = RES_ERROR;  // 在此寫入自己的代碼，向驅動寫入扇區       return res; } #endif /* _USE_WRITE == 1 *//*------------------------ 其它函數 ----------------------*/ #if _USE_IOCTL == 1 DRESULT mynewdisk_ioctl (BYTE cmd, /* 控制代碼 */                                         void *buff) /* 用於發送 / 接收控制數據的代碼 */ {    DRESULT res = RES_ERROR;  // 在此寫入自己的代碼，控制驅動專用功能  //   CTRL_SYNC、 GET_SECTOR_SIZE、 GET_SECTOR_COUNT、 GET_BLOCK_SIZE //// 如控制同步，獲取扇區大小，獲取扇區數量，獲取塊大小等  return res; } #endif /* _USE_IOCTL == 1 */</code></pre><p>底層磁盤 I/O 模塊的頭文件：</p><pre><code>/*-------------------------------------------------------------------------*//* mynewdisk_diskio.h：底層磁盤 I/O 模塊的頭文件              */ /*-------------------------------------------------------------------------*//* 避免遞歸包含的定義 ----------------------------------*/ #ifndef __MYNEWDISK_DISKIO_H #define __MYNEWDISK_DISKIO_Hextern Diskio_drvTypeDef  mynewdisk_Driver;#endif /* __MYNEWDISK_DISKIO_H */</code></pre><p><strong>3、FatFs 應用程序</strong></p><p>STM32CubeF4 解決方案中提供了許多基於 FatFs 中間件的應用程序。下表顯示瞭如 何在不同例子中使用 FatFs 中間件組件，這些例子按照複雜度分類，並取決於所使用 的物理驅動接口 （uSD、 RAMDisk、 USBDisk）：</p><p><br></p><div class=pgc-img><img alt="【STM32】SD卡讀寫（七）-在 STM32Cube 上開發 FatFs 相關應用" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8756153cffbf4cb98095d5cb77248e03><p class=pgc-img-caption></p></div><p>STM32CubeF4 解決方案所提供的上述 FatFs 應用程序是一套有兩種模式的固件：</p><p>• 獨立模式</p><p>• RTOS 模式，使用 FreeRTOS 中間件組件 值得注意的是，當使用或者開發基於意法半導體磁盤 I/O 底層驅動的 FatFs 應用程序時，用戶 必須保證合適的堆棧值。</p><p>因此，當使用基於 USB 主機大容量存儲類的 U 盤時，由於對齊的原因，棧的值必須根據大 扇區大小值 _MAX_SS 來增加。</p><p>當在 RTOS 模式中開發任何 FatFs 應用程序時，也必須使用基於 CMSIS-OS 包覆層通用 API 的 FreeRTOS 中間件組件對堆數值進行調整。</p><p><strong>3.1 HAL 驅動配置</strong></p><p>STM32CubeF4解決方案中所提供的FatFs應用程序是一套用於與各種物理磁盤驅動（uSD、 RAM 盤、 USB 盤）相連接的固件。用戶需要某些運行 FatFs 應用程序所必需的 HAL 驅動。 相應的 HAL 驅動可通過 HAL 配置文件 stm32f4xx_hal_conf.h 來使能，解除 HAL 驅動中所使 用的適當模塊的註釋即可。</p><p>HAL 配置文件中，各個支持的磁盤驅動之間的主要差異在於與所使用的磁盤驅動相對應的正 確 HAL 驅動的定義。根據各種驅動，以下宏定義必須可用：</p><p>• FatFs_uSD:</p><p>– #define HAL_SD_MODULE_ENABLED</p><p>• FatFs_RAMDisk:</p><p>– #define HAL_SDRAM_MODULE_ENABLED 或</p><p>– #define HAL_SRAM_MODULE_ENABLED</p><p>• FatFs_USBDisk:</p><p>– #define HAL_HCD_MODULE_ENABLED</p><p><strong>3.2 FatFs 文件系統配置</strong></p><p>FatFs 模塊中包含各種配置選項。在這一層級，我們提供信息幫助用戶根據所連接的物理磁盤 驅動選擇正確的選件，滿足用戶需求，達到高性能。</p><p><strong>3.2.1 可重入性</strong></p><p>可重入性是獨立和 RTOS 模式配置之間的主要差異，這一點可以在 FatFs 配置文件 ffconf.h 中進行設置。 • 獨立模式中禁用可重入性： – #define _FS_REENTRANT 0 • RTOS 模式中使能可重入性： – #define _FS_REENTRANT 1</p><p>一旦使能後，用戶必須提供依賴於 OS 的同步對象 （#define _SYNC_t osSemaphoreId）</p><p>RTOS 模式應用程序的項目需要包含 syscall.c 文件，以提供 OS 依賴函數，可在以下路徑找 到：\Middlewares\Third_Party\FatFs\src\option</p><p><strong>3.2.2 長文件名</strong></p><p>FatFs 模塊支持長文件名 （LFN）以及 8.3 格式文件名 （SFN）。</p><p>請注意，FAT 文件系統上的 LFN 功能是微軟公司的專利。雖然在 FAT32 上不是這樣，但大多 數 FAT32 驅動包含 LFN 功能。 FatFs 可以通過配置選項切換 LFN 功能。當在商業產品上使 能 LFN 功能時，需要根據終目標獲取微軟的許可。當使能 LFN 功能時，可以使用 LFN，這 項功能可以在 FatFs 配置文件 ffconf.h 中設置：FatFs 配置文件 ffconf.h 中 (_USE_LFN > 0)</p><p>• 禁用 LFN 功能：</p><p>– #define _USE_LFN 0</p><p>• 使能 LFN 功能，其中 3 ≥ _USE_LFN > 0：</p><p>一旦在 ffconf.h 配置文件中使能之後，應用程序項目需要包含 syscall.c/unicode.c 文件，以提 供內存管理功能，該文件可在以下路徑中找到：\Middlewares\Third_Party\FatFs\src\option</p><p>用戶在獨立模式應用或 RTOS 模式應用中均可使能 LFN 功能。</p><p><strong>3.3 FatFs 示例應用程序</strong></p><p>如果用戶已經連接了自己的磁盤，開發了適當的磁盤 I/O 底層驅動 (mynewdisk_diskio.c/.h)， 請參考 第 2.8 章節 : 將自己的磁盤連接至 FatFs，可按照以下方式將其驅動連接至 FatFs 模塊 以及使用邏輯磁盤：</p><pre><code>/*-------------------------------------------------------------------------*/ /* main.c：主程序 */ /*-------------------------------------------------------------------------*//* 包括 ---------------------------------------------------------------*/ #include "main.h"/* 私有變量 --------------------------------------- */ FATFS mynewdiskFatFs;  /* 用戶邏輯驅動的文件系統對象 */ FIL MyFile;            /* 文件對象 */ char mynewdiskPath[4]; /* 用戶邏輯驅動路徑 */int main(void) {      uint32_t wbytes; /* 寫入文件的字節計數 */      uint8_t wtext[] = "text to write logical disk"; /* 寫入文件的緩衝 */      if(FATFS_LinkDriver(&amp;mynewdisk_Driver, mynewdiskPath) == 0)      {          if(f_mount(&amp;mynewdiskFatFs, (TCHAR const*)mynewdiskPath, 0) == FR_OK)          {              if(f_open(&amp;MyFile, "STM32.TXT", FA_CREATE_ALWAYS | FA_WRITE) == FR_OK)              {                  if(f_write(&amp;MyFile, wtext, sizeof(wtext), (void *)&amp;wbytes) == FR_OK);                  {                       f_close(&amp;MyFile);                  }              }          }    }    FATFS_UnLinkDriver(mynewdiskPath); }</code></pre><p>用戶必須包含通用驅動頭文件 ff_gen_drv.h 以及磁盤 I/O 模塊頭文件 mynewdisk_diskio.h</p><pre><code>/*-------------------------------------------------------------------------*/ /* main.h：main.c 模塊的頭文件                                     */ /*-------------------------------------------------------------------------*//* 包括 ---------------------------------------------------------------*/ #include "ff_gen_drv.h" #include "mynewdisk_diskio.h"</code></pre><p>詳細應用可參考UM1721手冊</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>STM32</a></li><li><a>SD</a></li><li><a>卡讀</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9b331581.html alt="STM32｜點陣液晶字符型 UI的顯示及其字模軟件工具的使用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152553709307755d9e3ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9b331581.html title="STM32｜點陣液晶字符型 UI的顯示及其字模軟件工具的使用">STM32｜點陣液晶字符型 UI的顯示及其字模軟件工具的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1dbc1857.html alt=USB之STM32基礎（六） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S9PSHJD8KTtdGf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1dbc1857.html title=USB之STM32基礎（六）>USB之STM32基礎（六）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdeaed2.html alt="SD 8.0標準發佈，PCIe 4.0大升級，最高傳輸速度4GB/s" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/76cf0dbbe1644cb3b6c012ac63504ccf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdeaed2.html title="SD 8.0標準發佈，PCIe 4.0大升級，最高傳輸速度4GB/s">SD 8.0標準發佈，PCIe 4.0大升級，最高傳輸速度4GB/s</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd9de01a.html alt="全新SD卡格式 傳輸速度接近 1Gb/s、最大容量 128TB" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153058373404070e114fa97 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd9de01a.html title="全新SD卡格式 傳輸速度接近 1Gb/s、最大容量 128TB">全新SD卡格式 傳輸速度接近 1Gb/s、最大容量 128TB</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a9630809.html alt=全新SD卡格式正式公佈，傳輸速度接近1Gbps class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a9630809.html title=全新SD卡格式正式公佈，傳輸速度接近1Gbps>全新SD卡格式正式公佈，傳輸速度接近1Gbps</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d653715.html alt=「話說定時器系列」之三：STM32定時器的信號觸發與主從模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e23060553863447cb94e1eb8e197748c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d653715.html title=「話說定時器系列」之三：STM32定時器的信號觸發與主從模式>「話說定時器系列」之三：STM32定時器的信號觸發與主從模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a48ddee.html alt=介紹一款基於STM32高性能全數字式正弦波逆變電源的設計方案 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153430263281697d780903a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a48ddee.html title=介紹一款基於STM32高性能全數字式正弦波逆變電源的設計方案>介紹一款基於STM32高性能全數字式正弦波逆變電源的設計方案</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cad790a.html alt=STM32單片機的高精度超聲波測距系統的設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52a09a7f25cd435984c3fe9282bb6f03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cad790a.html title=STM32單片機的高精度超聲波測距系統的設計>STM32單片機的高精度超聲波測距系統的設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9ebb0634.html alt=基於STM32的頻譜測量系統的設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RM5bTXbAhNrnKf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9ebb0634.html title=基於STM32的頻譜測量系統的設計>基於STM32的頻譜測量系統的設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d40f1c0c.html alt="STM32單片機程序之面向'接口'編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e631e7f0750b4b948eed2205040227c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d40f1c0c.html title="STM32單片機程序之面向'接口'編程">STM32單片機程序之面向'接口'編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a42fc46.html alt=STM32入門實戰：工之利器，基礎代碼生成器CubeMX class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ca1ea6cd5cf64f6b94239e65dd85c804 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a42fc46.html title=STM32入門實戰：工之利器，基礎代碼生成器CubeMX>STM32入門實戰：工之利器，基礎代碼生成器CubeMX</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/da672eff.html alt=STM32單片機學習筆記（超詳細整理143個問題，學習必看） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7030374fbd447fbb9cfc7ccab5f44d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/da672eff.html title=STM32單片機學習筆記（超詳細整理143個問題，學習必看）>STM32單片機學習筆記（超詳細整理143個問題，學習必看）</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/14a32c46.html alt=宅客模玩原創：SD戰國傳武者七人眾篇故事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153676701387714dadf7c98 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/14a32c46.html title=宅客模玩原創：SD戰國傳武者七人眾篇故事>宅客模玩原創：SD戰國傳武者七人眾篇故事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/81fc8f25.html alt=工程師實戰：基於STM32的波形發生器設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/40c3f7c511304a6ba43dea12e19901e5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/81fc8f25.html title=工程師實戰：基於STM32的波形發生器設計>工程師實戰：基於STM32的波形發生器設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/99d6681.html alt="政策已定：雲服務、CDN、SD-WAN 跨境數據" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/99d6681.html title="政策已定：雲服務、CDN、SD-WAN 跨境數據">政策已定：雲服務、CDN、SD-WAN 跨境數據</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>