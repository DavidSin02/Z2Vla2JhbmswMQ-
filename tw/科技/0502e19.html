<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用 ZeroMQ 消息庫在 C 和 Python 間共享數據 | Linux 中國 | 极客快訊</title><meta property="og:title" content="使用 ZeroMQ 消息庫在 C 和 Python 間共享數據 | Linux 中國 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e00533e8a53343e3ba562f759fdcebdd"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0502e19.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0502e19.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0502e19.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0502e19.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0502e19.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0502e19.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0502e19.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0502e19.html><meta property="article:published_time" content="2020-10-29T21:04:29+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:29+08:00"><meta name=Keywords content><meta name=description content="使用 ZeroMQ 消息庫在 C 和 Python 間共享數據 | Linux 中國"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0502e19.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用 ZeroMQ 消息庫在 C 和 Python 間共享數據 | Linux 中國</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="使用 ZeroMQ 消息庫在 C 和 Python 間共享數據 | Linux 中國" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e00533e8a53343e3ba562f759fdcebdd><p class=pgc-img-caption></p></div><blockquote><p>ZeroMQ 是一個快速靈活的消息庫，用於數據收集和不同編程語言間的數據共享。</p></blockquote><p style=text-align:start>• 來源：linux.cn • 作者：Cristiano L. Fontana • 譯者：SilentDawn •</p><p style=text-align:start>（本文字數：12873，閱讀時長大約：15 分鐘）</p><p style=text-align:start><br></p><p style=text-align:start>作為軟件工程師，我有多次在要求完成指定任務時感到渾身一冷的經歷。其中有一次，我必須在一些新的硬件基礎設施和雲基礎設施之間寫一個接口，這些硬件需要 C 語言，而云基礎設施主要是用 Python。</p><p style=text-align:start>實現的方式之一是 用 C 寫擴展模塊 ，Python 支持 C 擴展的調用。快速瀏覽文檔後發現，這需要編寫大量的 C 代碼。這樣做的話，在有些情況下效果還不錯，但不是我喜歡的方式。另一種方式就是將兩個任務放在不同的進程中，並使用 ZeroMQ 消息庫 在兩者之間交換消息。</p><p style=text-align:start>在發現 ZeroMQ 之前，遇到這種類型的情況時，我選擇了編寫擴展的方式。這種方式不算太差，但非常費時費力。如今，為了避免那些問題，我將一個系統細分為獨立的進程，通過 通信套接字 發送消息來交換信息。這樣，不同的編程語言可以共存，每個進程也變簡單了，同時也容易調試。</p><p style=text-align:start>ZeroMQ 提供了一個更簡單的過程：</p><ol start=1><li>編寫一小段 C 代碼，從硬件讀取數據，然後把發現的東西作為消息發送出去。</li><li>使用 Python 編寫接口，實現新舊基礎設施之間的對接。</li></ol><p style=text-align:start>Pieter Hintjens 是 ZeroMQ 項目發起者之一，他是個擁有 有趣視角和作品 的非凡人物。</p><h1 class=pgc-h-arrow-right>準備</h1><p style=text-align:start>本教程中，需要：</p><ul><li>一個 C 編譯器（例如 GCC 或 Clang ）</li><li>libzmq 庫</li><li>Python 3</li><li>ZeroMQ 的 Python 封裝</li></ul><p style=text-align:start>Fedora 系統上的安裝方法：</p><pre><code>$ dnf install clang zeromq zeromq-devel python3 python3-zmq</code></pre><p style=text-align:start>Debian 和 Ubuntu 系統上的安裝方法：</p><pre><code>$ apt-get install clang libzmq5 libzmq3-dev python3 python3-zmq</code></pre><p style=text-align:start>如果有問題，參考對應項目的安裝指南（上面附有鏈接）。</p><h1 class=pgc-h-arrow-right>編寫硬件接口庫</h1><p style=text-align:start>因為這裡針對的是個設想的場景，本教程虛構了包含兩個函數的操作庫：</p><ul><li>fancyhw_init() 用來初始化（設想的）硬件</li><li>fancyhw_read_val() 用於返回從硬件讀取的數據</li></ul><p style=text-align:start>將庫的完整代碼保存到文件 libfancyhw.h 中:</p><pre><code>#ifndef LIBFANCYHW_H#define LIBFANCYHW_H#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;// This is the fictitious hardware interfacing libraryvoid fancyhw_init(unsigned int init_param){    srand(init_param);}int16_t fancyhw_read_val(void){    return (int16_t)rand();}#endif</code></pre><p style=text-align:start>這個庫可以模擬你要在不同語言實現的組件間交換的數據，中間有個隨機數發生器。</p><h1 class=pgc-h-arrow-right>設計 C 接口</h1><p style=text-align:start>下面從包含管理數據傳輸的庫開始，逐步實現 C 接口。</p><p><strong>需要的庫</strong></p><p style=text-align:start>開始先加載必要的庫（每個庫的作用見代碼註釋）：</p><pre><code>// For printf()#include &lt;stdio.h&gt;// For EXIT_*#include &lt;stdlib.h&gt;// For memcpy()#include &lt;string.h&gt;// For sleep()#include &lt;unistd.h&gt;#include &lt;zmq.h&gt;#include "libfancyhw.h"</code></pre><p><strong>必要的參數</strong></p><p style=text-align:start>定義 main 函數和後續過程中必要的參數：</p><pre><code>int main(void){    const unsigned int INIT_PARAM = 12345;    const unsigned int REPETITIONS = 10;    const unsigned int PACKET_SIZE = 16;    const char *TOPIC = "fancyhw_data";    ...</code></pre><p><strong>初始化</strong></p><p style=text-align:start>所有的庫都需要初始化。虛構的那個只需要一個參數：</p><pre><code>fancyhw_init(INIT_PARAM);</code></pre><p style=text-align:start>ZeroMQ 庫需要實打實的初始化。首先，定義對象 context，它是用來管理全部的套接字的：</p><pre><code>void *context = zmq_ctx_new();if (!context){    printf("ERROR: ZeroMQ error occurred during zmq_ctx_new(): %s\n", zmq_strerror(errno));    return EXIT_FAILURE;}</code></pre><p style=text-align:start>之後定義用來發送數據的套接字。ZeroMQ 支持若干種套接字，各有其用。使用 publish 套接字（也叫 PUB 套接字），可以複製消息並分發到多個接收端。這使得你可以讓多個接收端接收同一個消息。沒有接收者的消息將被丟棄（即不會入消息隊列）。用法如下：</p><pre><code>void *data_socket = zmq_socket(context, ZMQ_PUB);</code></pre><p style=text-align:start>套接字需要綁定到一個具體的地址，這樣客戶端就知道要連接哪裡了。本例中，使用了 TCP 傳輸層 （當然也有 其它選項 ，但 TCP 是不錯的默認選擇）：</p><pre><code>const int rb = zmq_bind(data_socket, "tcp://*:5555");if (rb != 0){    printf("ERROR: ZeroMQ error occurred during zmq_ctx_new(): %s\n", zmq_strerror(errno));    return EXIT_FAILURE;}</code></pre><p style=text-align:start>下一步, 計算一些後續要用到的值。 注意下面代碼中的 TOPIC，因為 PUB 套接字發送的消息需要綁定一個主題。主題用於供接收者過濾消息：</p><pre><code>const size_t topic_size = strlen(TOPIC);const size_t envelope_size = topic_size + 1 + PACKET_SIZE * sizeof(int16_t);printf("Topic: %s; topic size: %zu; Envelope size: %zu\n", TOPIC, topic_size, envelope_size);</code></pre><p><strong>發送消息</strong></p><p style=text-align:start>啟動一個發送消息的循環，循環 REPETITIONS 次：</p><pre><code>for (unsigned int i = 0; i &lt; REPETITIONS; i++){    ...</code></pre><p style=text-align:start>發送消息前，先填充一個長度為 PACKET_SIZE 的緩衝區。本庫提供的是 16 個位的有符號整數。因為 C 語言中 int 類型佔用空間大小與平臺相關，不是確定的值，所以要使用指定寬度的 int 變量：</p><pre><code>int16_t buffer[PACKET_SIZE];for (unsigned int j = 0; j &lt; PACKET_SIZE; j++){    buffer[j] = fancyhw_read_val();}printf("Read %u data values\n", PACKET_SIZE);</code></pre><p style=text-align:start>消息的準備和發送的第一步是創建 ZeroMQ 消息，為消息分配必要的內存空間。空白的消息是用於封裝要發送的數據的：</p><pre><code>zmq_msg_t envelope;const int rmi = zmq_msg_init_size(&amp;envelope, envelope_size);if (rmi != 0){    printf("ERROR: ZeroMQ error occurred during zmq_msg_init_size(): %s\n", zmq_strerror(errno));    zmq_msg_close(&amp;envelope);    break;}</code></pre><p style=text-align:start>現在內存空間已分配，數據保存在 ZeroMQ 消息 “信封”中。函數 zmq_msg_data() 返回一個指向封裝數據緩存區頂端的指針。第一部分是主題，之後是一個空格，最後是二進制數。主題和二進制數據之間的分隔符采用空格字符。需要遍歷緩存區的話，使用類型轉換和 指針算法 。（感謝 C 語言，讓事情變得直截了當。）做法如下：</p><pre><code>memcpy(zmq_msg_data(&amp;envelope), TOPIC, topic_size);memcpy((void*)((char*)zmq_msg_data(&amp;envelope) + topic_size), " ", 1);memcpy((void*)((char*)zmq_msg_data(&amp;envelope) + 1 + topic_size), buffer, PACKET_SIZE * sizeof(int16_t))</code></pre><p style=text-align:start>通過 data_socket 發送消息：</p><pre><code>const size_t rs = zmq_msg_send(&amp;envelope, data_socket, 0);if (rs != envelope_size){    printf("ERROR: ZeroMQ error occurred during zmq_msg_send(): %s\n", zmq_strerror(errno));    zmq_msg_close(&amp;envelope);    break;}</code></pre><p style=text-align:start>使用數據之前要先解除封裝：</p><pre><code>zmq_msg_close(&amp;envelope);printf("Message sent; i: %u, topic: %s\n", i, TOPIC);</code></pre><p><strong>清理</strong></p><p style=text-align:start>C 語言不提供 垃圾收集 功能，用完之後記得要自己掃尾。發送消息之後結束程序之前，需要運行掃尾代碼，釋放分配的內存:</p><pre><code>const int rc = zmq_close(data_socket);if (rc != 0){    printf("ERROR: ZeroMQ error occurred during zmq_close(): %s\n", zmq_strerror(errno));    return EXIT_FAILURE;}const int rd = zmq_ctx_destroy(context);if (rd != 0){    printf("Error occurred during zmq_ctx_destroy(): %s\n", zmq_strerror(errno));    return EXIT_FAILURE;}return EXIT_SUCCESS;</code></pre><p><strong>完整 C 代碼</strong></p><p style=text-align:start>保存下面完整的接口代碼到本地名為 hw_interface.c 的文件：</p><pre><code>// For printf()#include &lt;stdio.h&gt;// For EXIT_*#include &lt;stdlib.h&gt;// For memcpy()#include &lt;string.h&gt;// For sleep()#include &lt;unistd.h&gt;#include &lt;zmq.h&gt;#include "libfancyhw.h"int main(void){    const unsigned int INIT_PARAM = 12345;    const unsigned int REPETITIONS = 10;    const unsigned int PACKET_SIZE = 16;    const char *TOPIC = "fancyhw_data";    fancyhw_init(INIT_PARAM);    void *context = zmq_ctx_new();    if (!context)    {        printf("ERROR: ZeroMQ error occurred during zmq_ctx_new(): %s\n", zmq_strerror(errno));        return EXIT_FAILURE;    }    void *data_socket = zmq_socket(context, ZMQ_PUB);    const int rb = zmq_bind(data_socket, "tcp://*:5555");    if (rb != 0)    {        printf("ERROR: ZeroMQ error occurred during zmq_ctx_new(): %s\n", zmq_strerror(errno));        return EXIT_FAILURE;    }    const size_t topic_size = strlen(TOPIC);    const size_t envelope_size = topic_size + 1 + PACKET_SIZE * sizeof(int16_t);    printf("Topic: %s; topic size: %zu; Envelope size: %zu\n", TOPIC, topic_size, envelope_size);    for (unsigned int i = 0; i &lt; REPETITIONS; i++)    {        int16_t buffer[PACKET_SIZE];        for (unsigned int j = 0; j &lt; PACKET_SIZE; j++)        {            buffer[j] = fancyhw_read_val();        }        printf("Read %u data values\n", PACKET_SIZE);        zmq_msg_t envelope;           const int rmi = zmq_msg_init_size(&amp;envelope, envelope_size);        if (rmi != 0)        {            printf("ERROR: ZeroMQ error occurred during zmq_msg_init_size(): %s\n", zmq_strerror(errno));               zmq_msg_close(&amp;envelope);               break;        }               memcpy(zmq_msg_data(&amp;envelope), TOPIC, topic_size);        memcpy((void*)((char*)zmq_msg_data(&amp;envelope) + topic_size), " ", 1);        memcpy((void*)((char*)zmq_msg_data(&amp;envelope) + 1 + topic_size), buffer, PACKET_SIZE * sizeof(int16_t));           const size_t rs = zmq_msg_send(&amp;envelope, data_socket, 0);        if (rs != envelope_size)        {            printf("ERROR: ZeroMQ error occurred during zmq_msg_send(): %s\n", zmq_strerror(errno));               zmq_msg_close(&amp;envelope);               break;        }           zmq_msg_close(&amp;envelope);        printf("Message sent; i: %u, topic: %s\n", i, TOPIC);        sleep(1);    }    const int rc = zmq_close(data_socket);    if (rc != 0)    {        printf("ERROR: ZeroMQ error occurred during zmq_close(): %s\n", zmq_strerror(errno));        return EXIT_FAILURE;    }    const int rd = zmq_ctx_destroy(context);    if (rd != 0)    {        printf("Error occurred during zmq_ctx_destroy(): %s\n", zmq_strerror(errno));        return EXIT_FAILURE;    }    return EXIT_SUCCESS;}</code></pre><p style=text-align:start>用如下命令編譯：</p><pre><code>$ clang -std=c99 -I. hw_interface.c -lzmq -o hw_interface</code></pre><p style=text-align:start>如果沒有編譯錯誤，你就可以運行這個接口了。貼心的是，ZeroMQ PUB 套接字可以在沒有任何應用發送或接受數據的狀態下運行，這簡化了使用複雜度，因為這樣不限制進程啟動的次序。</p><p style=text-align:start>運行該接口：</p><pre><code>$ ./hw_interfaceTopic: fancyhw_data; topic size: 12; Envelope size: 45Read 16 data valuesMessage sent; i: 0, topic: fancyhw_dataRead 16 data valuesMessage sent; i: 1, topic: fancyhw_dataRead 16 data values......</code></pre><p style=text-align:start>輸出顯示數據已經通過 ZeroMQ 完成發送，現在要做的是讓一個程序去讀數據。</p><h1 class=pgc-h-arrow-right>編寫 Python 數據處理器</h1><p style=text-align:start>現在已經準備好從 C 程序向 Python 應用傳送數據了。</p><p><strong>庫</strong></p><p style=text-align:start>需要兩個庫幫助實現數據傳輸。首先是 ZeroMQ 的 Python 封裝：</p><pre><code>$ python3 -m pip install zmq</code></pre><p style=text-align:start>另一個就是 struct 庫 ，用於解碼二進制數據。這個庫是 Python 標準庫的一部分，所以不需要使用 pip 命令安裝。</p><p style=text-align:start>Python 程序的第一部分是導入這些庫：</p><pre><code>import zmqimport struct</code></pre><p><strong>重要參數</strong></p><p style=text-align:start>使用 ZeroMQ 時，只能向常量 TOPIC 定義相同的接收端發送消息：</p><pre><code>topic = "fancyhw_data".encode('ascii')print("Reading messages with topic: {}".format(topic))</code></pre><p><strong>初始化</strong></p><p style=text-align:start>下一步，初始化上下文和套接字。使用 subscribe 套接字（也稱為 SUB 套接字），它是 PUB 套接字的天生伴侶。這個套接字發送時也需要匹配主題。</p><pre><code>with zmq.Context() as context:    socket = context.socket(zmq.SUB)    socket.connect("tcp://127.0.0.1:5555")    socket.setsockopt(zmq.SUBSCRIBE, topic)    i = 0    ...</code></pre><p><strong>接收消息</strong></p><p style=text-align:start>啟動一個無限循環，等待接收發送到 SUB 套接字的新消息。這個循環會在你按下 Ctrl+C 組合鍵或者內部發生錯誤時終止：</p><pre><code>    try:        while True:            ... # we will fill this in next    except KeyboardInterrupt:        socket.close()    except Exception as error:        print("ERROR: {}".format(error))        socket.close()</code></pre><p style=text-align:start>這個循環等待 recv() 方法獲取的新消息，然後將接收到的內容從第一個空格字符處分割開，從而得到主題：</p><pre><code>binary_topic, data_buffer = socket.recv().split(b' ', 1)</code></pre><p><strong>解碼消息</strong></p><p style=text-align:start>Python 此時尚不知道主題是個字符串，使用標準 ASCII 編解碼器進行解碼：</p><pre><code>topic = binary_topic.decode(encoding = 'ascii')print("Message {:d}:".format(i))print("\ttopic: '{}'".format(topic))</code></pre><p style=text-align:start>下一步就是使用 struct 庫讀取二進制數據，它可以將二進制數據段轉換為明確的數值。首先，計算數據包中數值的組數。本例中使用的 16 個位的有符號整數對應的是 struct 格式字符 中的 h：</p><pre><code>packet_size = len(data_buffer) // struct.calcsize("h")print("\tpacket size: {:d}".format(packet_size))</code></pre><p style=text-align:start>知道數據包中有多少組數據後，就可以通過構建一個包含數據組數和數據類型的字符串，來定義格式了（比如“16h”）：</p><pre><code>struct_format = "{:d}h".format(packet_size)</code></pre><p style=text-align:start>將二進制數據串轉換為可直接打印的一系列數字：</p><pre><code>data = struct.unpack(struct_format, data_buffer)print("\tdata: {}".format(data))</code></pre><p><strong>完整 Python 代碼</strong></p><p style=text-align:start>下面是 Python 實現的完整的接收端：</p><pre><code>#! /usr/bin/env python3import zmqimport structtopic = "fancyhw_data".encode('ascii')print("Reading messages with topic: {}".format(topic))with zmq.Context() as context:    socket = context.socket(zmq.SUB)    socket.connect("tcp://127.0.0.1:5555")    socket.setsockopt(zmq.SUBSCRIBE, topic)    i = 0    try:        while True:            binary_topic, data_buffer = socket.recv().split(b' ', 1)            topic = binary_topic.decode(encoding = 'ascii')            print("Message {:d}:".format(i))            print("\ttopic: '{}'".format(topic))            packet_size = len(data_buffer) // struct.calcsize("h")            print("\tpacket size: {:d}".format(packet_size))            struct_format = "{:d}h".format(packet_size)            data = struct.unpack(struct_format, data_buffer)            print("\tdata: {}".format(data))            i += 1    except KeyboardInterrupt:        socket.close()    except Exception as error:        print("ERROR: {}".format(error))        socket.close()</code></pre><p style=text-align:start>將上面的內容保存到名為 online_analysis.py 的文件。Python 代碼不需要編譯，你可以直接運行它。</p><p style=text-align:start>運行輸出如下：</p><pre><code>$ ./online_analysis.pyReading messages with topic: b'fancyhw_data'Message 0:        topic: 'fancyhw_data'        packet size: 16        data: (20946, -23616, 9865, 31416, -15911, -10845, -5332, 25662, 10955, -32501, -18717, -24490, -16511, -28861, 24205, 26568)Message 1:        topic: 'fancyhw_data'        packet size: 16        data: (12505, 31355, 14083, -19654, -9141, 14532, -25591, 31203, 10428, -25564, -732, -7979, 9529, -27982, 29610, 30475)......</code></pre><h1 class=pgc-h-arrow-right>小結</h1><p style=text-align:start>本教程介紹了一種新方式，實現從基於 C 的硬件接口收集數據，並分發到基於 Python 的基礎設施的功能。藉此可以獲取數據供後續分析，或者轉送到任意數量的接收端去。它採用了一個消息庫實現數據在發送者和處理者之間的傳送，來取代同樣功能規模龐大的軟件。</p><p style=text-align:start>本教程還引出了我稱之為“軟件粒度”的概念，換言之，就是將軟件細分為更小的部分。這種做法的優點之一就是，使得同時採用不同的編程語言實現最簡接口作為不同部分之間溝通的組件成為可能。</p><p style=text-align:start>實踐中，這種設計使得軟件工程師能以更獨立、合作更高效的方式做事。不同的團隊可以專注於數據分析的不同方面，可以選擇自己中意的實現工具。這種做法的另一個優點是實現了零代價的並行，因為所有的進程都可以並行運行。 ZeroMQ 消息庫 是個令人讚歎的軟件，使用它可以讓工作大大簡化。</p><hr><p style=text-align:start>via: opensource.com</p><p style=text-align:start>作者： Cristiano L. Fontana 選題： lujun9972 譯者： silentdawn-zz 校對： wxy</p><p style=text-align:start>本文由 LCTT 原創編譯， Linux中國 榮譽推出</p><h1 class=pgc-h-arrow-right>點擊“瞭解更多”可訪問文內鏈接</h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>ZeroMQ</a></li><li><a>Python</a></li><li><a>數據</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8895f05b.html alt=Python數據可視化Matplotlib，如何改變柱狀圖中柱體寬度及顏色？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e86000416e5b4683dfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8895f05b.html title=Python數據可視化Matplotlib，如何改變柱狀圖中柱體寬度及顏色？>Python數據可視化Matplotlib，如何改變柱狀圖中柱體寬度及顏色？</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/497456fe.html alt=Python數據結構算法，學習人工智能必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1536842670061d56ecf34d6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/497456fe.html title=Python數據結構算法，學習人工智能必備知識點>Python數據結構算法，學習人工智能必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/051c1ef8.html alt=Python數據結構之隊列的實現與實例分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/051c1ef8.html title=Python數據結構之隊列的實現與實例分析>Python數據結構之隊列的實現與實例分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d5628f8.html alt=​如何在Python中加入多個數據幀？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ac466a2ef0dc4cdca642d9937504b4cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d5628f8.html title=​如何在Python中加入多個數據幀？>​如何在Python中加入多個數據幀？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad0fe12.html alt=Python數據可視化Matplotlib，如何隱藏座標軸刻度線標籤？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66c60001502562989911 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad0fe12.html title=Python數據可視化Matplotlib，如何隱藏座標軸刻度線標籤？>Python數據可視化Matplotlib，如何隱藏座標軸刻度線標籤？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d448bf.html alt=Python數據可視化Matplotlib，如何隱藏座標軸刻度線？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66c60001502562989911 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d448bf.html title=Python數據可視化Matplotlib，如何隱藏座標軸刻度線？>Python數據可視化Matplotlib，如何隱藏座標軸刻度線？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aa0358.html alt=Python數據可視化Matplotlib，座標軸刻度線定位——對數定位法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15216867300432ec0694263 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aa0358.html title=Python數據可視化Matplotlib，座標軸刻度線定位——對數定位法>Python數據可視化Matplotlib，座標軸刻度線定位——對數定位法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d392c1.html alt=Python數據可視化利器Matplotlib，座標軸刻度線及刻度線標籤設置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3b1600029ce67d83c611 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d392c1.html title=Python數據可視化利器Matplotlib，座標軸刻度線及刻度線標籤設置>Python數據可視化利器Matplotlib，座標軸刻度線及刻度線標籤設置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f88d03.html alt=軟妹子帶你玩轉Python數據可視化，座標軸位置自定義 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/320d0002dddbdff5c4c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f88d03.html title=軟妹子帶你玩轉Python數據可視化，座標軸位置自定義>軟妹子帶你玩轉Python數據可視化，座標軸位置自定義</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b41ad4d.html alt=軟妹子帶你玩轉Python數據可視化，座標軸刻度比例尺自定義 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/321200016c64dce4d9ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b41ad4d.html title=軟妹子帶你玩轉Python數據可視化，座標軸刻度比例尺自定義>軟妹子帶你玩轉Python數據可視化，座標軸刻度比例尺自定義</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a411ca8.html alt=軟妹子帶你玩轉Python數據可視化，座標軸方向及範圍設置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/37c40003c719bfd4bde1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a411ca8.html title=軟妹子帶你玩轉Python數據可視化，座標軸方向及範圍設置>軟妹子帶你玩轉Python數據可視化，座標軸方向及範圍設置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/db4c5dc.html alt=Python數據分析，生成隨機數據文件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0c3fac782ff64c95a67d2ab8b8480470 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/db4c5dc.html title=Python數據分析，生成隨機數據文件>Python數據分析，生成隨機數據文件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc8af71.html alt=手把手教你使用Python爬取西刺代理數據（下篇） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/31a9a052021343dc9441b5ec6f2f539a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc8af71.html title=手把手教你使用Python爬取西刺代理數據（下篇）>手把手教你使用Python爬取西刺代理數據（下篇）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ee568a.html alt=Python數據清洗(一)：類型轉換和冗餘數據刪除 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/936eb6071cd947a4b3fedc4277d90815 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ee568a.html title=Python數據清洗(一)：類型轉換和冗餘數據刪除>Python數據清洗(一)：類型轉換和冗餘數據刪除</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>