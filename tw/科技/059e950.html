<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一篇文章搞懂Python面向對象之繼承 | 极客快訊</title><meta property="og:title" content="一篇文章搞懂Python面向對象之繼承 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="http://p1.pstatp.com/large/pgc-image/040363228a6a40b3bef7e33dd6eae446"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/059e950.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/059e950.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/059e950.html><meta property="article:published_time" content="2020-10-29T20:45:52+08:00"><meta property="article:modified_time" content="2020-10-29T20:45:52+08:00"><meta name=Keywords content><meta name=description content="一篇文章搞懂Python面向對象之繼承"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/059e950.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一篇文章搞懂Python面向對象之繼承</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=Editable-styled><strong>繼承</strong></h2><p>　　定義：繼承是一種創建新類的方式，在python中，新建的類可以繼承一個或多個父類，父類又可稱為基類或超類，新建的類稱為派生類或子類</p><p>　　PS：Python中類的繼承分為：單繼承和多繼承</p><pre><code>class ParentClass1: #定義父類    passclass ParentClass2: #定義父類    passclass SubClass1(ParentClass1): #單繼承，基類是ParentClass1，派生類是SubClass    passclass SubClass2(ParentClass1,ParentClass2): #python支持多繼承，用逗號分隔開多個繼承的類    pass</code></pre><p><strong>查看繼承</strong></p><pre><code>&gt;&gt;&gt; SubClass1.__bases__ #__base__只查看從左到右繼承的第一個子類，__bases__則是查看所有繼承的父類(&lt;class '__main__.ParentClass1'&gt;,)&gt;&gt;&gt; SubClass2.__bases__(&lt;class '__main__.ParentClass1'&gt;, &lt;class '__main__.ParentClass2'&gt;)</code></pre><p>提示：如果沒有指定基類，python的類會默認繼承object類，object是所有python類的基類，它提供了一些常見方法（如__str__）的實現。</p><pre><code>&gt;&gt;&gt; ParentClass1.__bases__(&lt;class 'object'&gt;,)&gt;&gt;&gt; ParentClass2.__bases__(&lt;class 'object'&gt;,)</code></pre><p><strong>繼承與抽象</strong></p><ul><li>抽象即抽取類似或者說比較像的部分。</li><li>抽象分成兩個層次：</li><li>將奧巴馬和梅西這倆對象比較像的部分抽取成類；</li><li>將人，豬，狗這三個類比較像的部分抽取成父類。</li></ul><p>抽象最主要的作用是劃分類別（可以隔離關注點，降低複雜度）</p><div class=pgc-img><img alt=一篇文章搞懂Python面向對象之繼承 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/040363228a6a40b3bef7e33dd6eae446><p class=pgc-img-caption></p></div><p><strong>繼承：是基於抽象的結果，通過編程語言去實現它，肯定是先經歷抽象這個過程，才能通過繼承的方式去表達出抽象的結構。</strong></p><p>抽象只是分析和設計的過程中，一個動作或者說一種技巧，通過抽象可以得到類</p><div class=pgc-img><img alt=一篇文章搞懂Python面向對象之繼承 onerror=errorimg.call(this); src=http://p3.pstatp.com/large/pgc-image/8839745dfe974f0bba19154347b0cefa><p class=pgc-img-caption></p></div><p><strong>繼承與重用性</strong></p><p>使用繼承來解決代碼重用的例子</p><pre><code>==========================第一部分例如　　貓可以：喵喵叫、吃、喝、拉、撒　　狗可以：汪汪叫、吃、喝、拉、撒如果我們要分別為貓和狗創建一個類，那麼就需要為 貓 和 狗 實現他們所有的功能，偽代碼如下： #貓和狗有大量相同的內容class 貓：    def 喵喵叫(self):        print '喵喵叫'    def 吃(self):        # do something    def 喝(self):        # do something    def 拉(self):        # do something    def 撒(self):        # do somethingclass 狗：    def 汪汪叫(self):        print '汪汪叫'    def 吃(self):        # do something    def 喝(self):        # do something    def 拉(self):        # do something    def 撒(self):        # do something==========================第二部分上述代碼不難看出，吃、喝、拉、撒是貓和狗都具有的功能，而我們卻分別的貓和狗的類中編寫了兩次。如果使用 繼承 的思想，如下實現：　　動物：吃、喝、拉、撒　　   貓：喵喵叫（貓繼承動物的功能）　　   狗：汪汪叫（狗繼承動物的功能）偽代碼如下：class 動物:    def 吃(self):        # do something    def 喝(self):        # do something    def 拉(self):        # do something    def 撒(self):        # do something# 在類後面括號中寫入另外一個類名，表示當前類繼承另外一個類class 貓(動物)：    def 喵喵叫(self):        print '喵喵叫'        # 在類後面括號中寫入另外一個類名，表示當前類繼承另外一個類class 狗(動物)：    def 汪汪叫(self):        print '汪汪叫'==========================第三部分#繼承的代碼實現class Animal:    def eat(self):        print("%s 吃 " %self.name)    def drink(self):        print ("%s 喝 " %self.name)    def shit(self):        print ("%s 拉 " %self.name)    def pee(self):        print ("%s 撒 " %self.name)class Cat(Animal):    def __init__(self, name):        self.name = name        self.breed = '貓'    def cry(self):        print('喵喵叫')class Dog(Animal):    def __init__(self, name):        self.name = name        self.breed='狗'    def cry(self):        print('汪汪叫')# ######### 執行 #########c1 = Cat('小白家的小黑貓')c1.eat()c2 = Cat('小黑的小白貓')c2.drink()d1 = Dog('胖子家的小瘦狗')d1.eat()使用繼承來重用代碼比較好的例子</code></pre><p><strong>在開發程序的過程中，如果定義了一個類A，然後又想新建立另外一個類B，但是類B的大部分內容與類A的相同時</strong></p><p><strong>我們不可能從頭開始寫一個類B，這就用到了類的繼承的概念。</strong></p><p><strong>通過繼承的方式新建類B，讓B繼承A，B會‘遺傳’A的所有屬性(數據屬性和函數屬性)，實現代碼重用</strong></p><pre><code>class Animal:    '''    人和狗都是動物，所以創造一個Animal基類    '''    def __init__(self, name, aggressivity, life_value):        self.name = name  # 人和狗都有自己的暱稱;        self.aggressivity = aggressivity  # 人和狗都有自己的攻擊力;        self.life_value = life_value  # 人和狗都有自己的生命值;    def eat(self):        print('%s is eating'%self.name)class Dog(Animal):    passclass Person(Animal):    passkum= Person('kum',10,1000)ha2 = Dog('二愣子',50,1000)kum.eat()ha2.eat()</code></pre><p>提示：用已經有的類建立一個新的類，這樣就重用了已經有的軟件中的一部分設置大部分，大大省了編程工作量，這就是常說的軟件重用，不僅可以重用自己的類，也可以繼承別人的，比如標準庫，來定製新的數據類型，這樣就是大大縮短了軟件開發週期，對大型軟件開發來說，意義重大.</p><p><strong>派生</strong></p><p>當然子類也可以添加自己新的屬性或者在自己這裡重新定義這些屬性（不會影響到父類），需要注意的是，一旦重新定義了自己的屬性且與父類重名，那麼調用新增的屬性時，就以自己為準了。</p><pre><code>class Animal:    '''    人和狗都是動物，所以創造一個Animal基類    '''    def __init__(self, name, aggressivity, life_value):        self.name = name  # 人和狗都有自己的暱稱;        self.aggressivity = aggressivity  # 人和狗都有自己的攻擊力;        self.life_value = life_value  # 人和狗都有自己的生命值;    def eat(self):        print('%s is eating'%self.name)class Dog(Animal):    '''    狗類，繼承Animal類    '''    def bite(self, people):        '''        派生：狗有咬人的技能        :param people:        '''        people.life_value -= self.aggressivityclass Person(Animal):    '''    人類，繼承Animal    '''    def attack(self, dog):        '''        派生：人有攻擊的技能        :param dog:        '''        dog.life_value -= self.aggressivitykum= Person('kum',10,1000)ha2 = Dog('二愣子',50,1000)print(ha2.life_value)print(kum.attack(ha2))print(ha2.life_value)</code></pre><p>注意：像ha2.life_value之類的屬性引用，會先從實例中找life_value然後去類中找，然後再去父類中找...直到最頂級的父類。</p><p>　　在子類中，新建的重名的函數屬性，在編輯函數內功能的時候，有可能需要重用父類中重名的那個函數功能，應該是用調用普通函數的方式，即：類名.func()，此時就與調用普通函數無異了，因此即便是self參數也要為其傳值.</p><p>　　在python3中，子類執行父類的方法也可以直接用super方法.</p><p><strong>super</strong></p><pre><code>class A:    def hahaha(self):        print('A')class B(A):    def hahaha(self):        super().hahaha()        #super(B,self).hahaha()        #A.hahaha(self)        print('B')a = A()b = B()b.hahaha()super(B,b).hahaha()</code></pre><p><br></p><pre><code>class Animal:    '''    人和狗都是動物，所以創造一個Animal基類    '''    def __init__(self, name, aggressivity, life_value):        self.name = name  # 人和狗都有自己的暱稱;        self.aggressivity = aggressivity  # 人和狗都有自己的攻擊力;        self.life_value = life_value  # 人和狗都有自己的生命值;    def eat(self):        print('%s is eating'%self.name)class Dog(Animal):    '''    狗類，繼承Animal類    '''    def __init__(self,name,breed,aggressivity,life_value):        super().__init__(name, aggressivity, life_value) #執行父類Animal的init方法        self.breed = breed  #派生出了新的屬性    def bite(self, people):        '''        派生出了新的技能：狗有咬人的技能        :param people:        '''        people.life_value -= self.aggressivity    def eat(self):        # Animal.eat(self)        #super().eat()        print('from Dog')class Person(Animal):    '''    人類，繼承Animal    '''    def __init__(self,name,aggressivity, life_value,money):        #Animal.__init__(self, name, aggressivity, life_value)        #super(Person, self).__init__(name, aggressivity, life_value)        super().__init__(name,aggressivity, life_value)  #執行父類的init方法        self.money = money   #派生出了新的屬性    def attack(self, dog):        '''        派生出了新的技能：人有攻擊的技能        :param dog:        '''        dog.life_value -= self.aggressivity    def eat(self):        #super().eat()        Animal.eat(self)        print('from Person')kum = Person('kum',10,1000,600)ha2 = Dog('二愣子','哈士奇',10,1000)print(kum.name)print(ha2.name)kum.eat()</code></pre><p><strong>通過繼承建立了派生類與基類之間的關係，它是一種'是'的關係，比如白馬是馬，人是動物。</strong></p><p><strong>當類之間有很多相同的功能，提取這些共同的功能做成基類，用繼承比較好，比如教授是老師</strong></p><pre><code>&gt;&gt;&gt; class Teacher:...     def __init__(self,name,gender):...         self.name=name...         self.gender=gender...     def teach(self):...         print('teaching')... &gt;&gt;&gt; &gt;&gt;&gt; class Professor(Teacher):...     pass... &gt;&gt;&gt; p1=Professor('kum','run')&gt;&gt;&gt; p1.teach()teaching</code></pre><h3 class=Editable-styled><strong>抽象類與接口類</strong></h3><h3 class=Editable-styled><strong>接口類</strong></h3><p>　　繼承有兩種用途：</p><p>　　一：繼承基類的方法，並且做出自己的改變或者擴展（代碼重用）</p><p>　　二：聲明某個子類兼容於某基類，定義一個接口類Interface，接口類中定義了一些接口名（就是函數名）且並未實現接口的功能，子類繼承接口類，並且實現接口中的功能</p><pre><code>class Alipay:    '''    支付寶支付    '''    def pay(self,money):        print('支付寶支付了%s元'%money)class Applepay:    '''    apple pay支付    '''    def pay(self,money):        print('apple pay支付了%s元'%money)def pay(payment,money):    '''    支付函數，總體負責支付    對應支付的對象和要支付的金額    '''    payment.pay(money)p = Alipay()pay(p,200)</code></pre><p><strong>開發中容易出現的問題</strong></p><pre><code>class Alipay:    '''    支付寶支付    '''    def pay(self,money):        print('支付寶支付了%s元'%money)class Applepay:    '''    apple pay支付    '''    def pay(self,money):        print('apple pay支付了%s元'%money)class Wechatpay:    def fuqian(self,money):        '''        實現了pay的功能，但是名字不一樣        '''        print('微信支付了%s元'%money)def pay(payment,money):    '''    支付函數，總體負責支付    對應支付的對象和要支付的金額    '''    payment.pay(money)p = Wechatpay()pay(p,200)   #執行會報錯</code></pre><p><strong>接口初成：手動報異常：NotImplementedError來解決開發中遇到的問題</strong></p><pre><code>class Payment:    def pay(self):        raise NotImplementedErrorclass Wechatpay(Payment):    def fuqian(self,money):        print('微信支付了%s元'%money)p = Wechatpay()  #這裡不報錯pay(p,200)      #這裡報錯了</code></pre><p><strong>借用abc模塊來實現接口</strong></p><pre><code>from abc import ABCMeta,abstractmethodclass Payment(metaclass=ABCMeta):    @abstractmethod    def pay(self,money):        passclass Wechatpay(Payment):    def fuqian(self,money):        print('微信支付了%s元'%money)p = Wechatpay() #不調就報錯了</code></pre><p>實踐中，繼承的第一種含義意義並不很大，甚至常常是有害的。因為它使得子類與基類出現強耦合。</p><p>　　繼承的第二種含義非常重要。它又叫“接口繼承”。 　　接口繼承實質上是要求“做出一個良好的抽象，這個抽象規定了一個兼容接口，使得外部調用者無需關心具體細節，可一視同仁的處理實現了特定接口的所有對象”——這在程序設計上，叫做歸一化。</p><p>　　歸一化使得高層的外部使用者可以不加區分的處理所有接口兼容的對象集合——就好象linux的泛文件概念一樣，所有東西都可以當文件處理，不必關心它是內存、磁盤、網絡還是屏幕（當然，對底層設計者，當然也可以區分出“字符設備”和“塊設備”，然後做出針對性的設計：細緻到什麼程度，視需求而定）。</p><p><strong>依賴倒置原則</strong> 高層模塊不應該依賴低層模塊，二者都應該依賴其抽象；抽象不應該應該依賴細節；細節應該依賴抽象。換言之，要針對接口編程，而不是針對實現編程</p><p>為什麼用接口</p><p>接口提取了一群類共同的函數，可以把接口當做一個函數的集合。</p><p>然後讓子類去實現接口中的函數。</p><p>這麼做的意義在於歸一化，什麼叫歸一化，就是只要是基於同一個接口實現的類，那麼所有的這些類產生的對象在使用時，從用法上來說都一樣。</p><p>歸一化，讓使用者無需關心對象的類是什麼，只需要的知道這些對象都具備某些功能就可以了，這極大地降低了使用者的使用難度。</p><p>比如：我們定義一個動物接口，接口裡定義了有跑、吃、呼吸等接口函數，這樣老鼠的類去實現了該接口，松鼠的類也去實現了該接口，由二者分別產生一隻老鼠和一隻松鼠送到你面前，即便是你分別不到底哪隻是什麼鼠你肯定知道他倆都會跑，都會吃，都能呼吸。</p><p>再比如：我們有一個汽車接口，裡面定義了汽車所有的功能，然後由本田汽車的類，奧迪汽車的類，大眾汽車的類，他們都實現了汽車接口，這樣就好辦了，大家只需要學會了怎麼開汽車，那麼無論是本田，還是奧迪，還是大眾我們都會開了，開的時候根本無需關心我開的是哪一類車，操作手法（函數調用）都一樣</p><p><strong>抽象類</strong></p><p><strong>什麼是抽象類</strong></p><p>與java一樣，python也有抽象類的概念但是同樣需要藉助模塊實現，<strong>抽象類是一個特殊的類，它的特殊之處在於只能被繼承，不能被實例化</strong></p><p><strong>為什麼要有抽象類</strong></p><p>如果說<strong>類是從</strong>一堆<strong>對象</strong>中抽取相同的內容而來的，那麼<strong>抽象類</strong>就<strong>是從</strong>一堆<strong>類</strong>中抽取相同的內容而來的，內容包括數據屬性和函數屬性。</p><p>　 比如我們有香蕉的類，有蘋果的類，有桃子的類，從這些類抽取相同的內容就是水果這個抽象的類，你吃水果時，要麼是吃一個具體的香蕉，要麼是吃一個具體的桃子。。。。。。你永遠無法吃到一個叫做水果的東西。</p><p>從設計角度去看，如果類是從現實對象抽象而來的，那麼抽象類就是基於類抽象而來的。</p><p>　 從實現角度來看，抽象類與普通類的不同之處在於：抽象類中有抽象方法，該類不能被實例化，只能被繼承，且子類必須實現抽象方法。這一點與接口有點類似，但其實是不同的，即將揭曉答案</p><p><strong>在python中實現抽象類</strong></p><pre><code>#一切皆文件import abc #利用abc模塊實現抽象類class All_file(metaclass=abc.ABCMeta):    all_type='file'    @abc.abstractmethod #定義抽象方法，無需實現功能    def read(self):        '子類必須定義讀功能'        pass    @abc.abstractmethod #定義抽象方法，無需實現功能    def write(self):        '子類必須定義寫功能'        pass# class Txt(All_file):#     pass## t1=Txt() #報錯,子類沒有定義抽象方法class Txt(All_file): #子類繼承抽象類，但是必須定義read和write方法    def read(self):        print('文本數據的讀取方法')    def write(self):        print('文本數據的讀取方法')class Sata(All_file): #子類繼承抽象類，但是必須定義read和write方法    def read(self):        print('硬盤數據的讀取方法')    def write(self):        print('硬盤數據的讀取方法')class Process(All_file): #子類繼承抽象類，但是必須定義read和write方法    def read(self):        print('進程數據的讀取方法')    def write(self):        print('進程數據的讀取方法')wenbenwenjian=Txt()yingpanwenjian=Sata()jinchengwenjian=Process()#這樣大家都是被歸一化了,也就是一切皆文件的思想wenbenwenjian.read()yingpanwenjian.write()jinchengwenjian.read()print(wenbenwenjian.all_type)print(yingpanwenjian.all_type)print(jinchengwenjian.all_type)</code></pre><h3 class=Editable-styled><strong>抽象類與接口類</strong></h3><p>　　抽象類的本質還是類，指的是一組類的相似性，包括數據屬性（如all_type）和函數屬性（如read、write），而接口只強調函數屬性的相似性。</p><p><strong>　　抽象類是一個介於類和接口直接的一個概念，同時具備類和接口的部分特性，可以用來實現歸一化設計</strong></p><p>python中，並沒有接口類這種東西，即便不通過專門的模塊定義接口，也應該有一些基本的概念。</p><h3 class=Editable-styled><strong>多繼承問題</strong></h3><p>　　在繼承抽象類的過程中，應該儘量避免多繼承； 　　而在繼承接口的時候，反而鼓勵你來多繼承接口</p><p><strong>接口隔離原則</strong> 使用多個專門的接口，而不使用單一的總接口。即客戶端不應該依賴那些不需要的接口。</p><h3 class=Editable-styled><strong>方法的實現</strong></h3><p>　　在抽象類中，我們可以對一些抽象方法做出基礎實現； 　　而在接口類中，任何方法都只是一種規範，具體的功能需要子類實現</p><h2 class=Editable-styled><strong>PS:鑽石繼承</strong></h2><h3 class=Editable-styled><strong>　　繼承順序</strong></h3><div class=pgc-img><img alt=一篇文章搞懂Python面向對象之繼承 onerror=errorimg.call(this); src=http://p1.pstatp.com/large/pgc-image/c2183ac6155847a89de38341f1de10c2><p class=pgc-img-caption></p></div><pre><code>class A(object):    def test(self):        print('from A')class B(A):    def test(self):        print('from B')class C(A):    def test(self):        print('from C')class D(B):    def test(self):        print('from D')class E(C):    def test(self):        print('from E')class F(D,E):    # def test(self):    #     print('from F')    passf1=F()f1.test()print(F.__mro__) #只有新式才有這個屬性可以查看線性列表，經典類沒有這個屬性#新式類繼承順序:F-&gt;D-&gt;B-&gt;E-&gt;C-&gt;A#經典類繼承順序:F-&gt;D-&gt;B-&gt;A-&gt;E-&gt;C#python3中統一都是新式類#pyhon2中才分新式類與經典類</code></pre><h3 class=Editable-styled><strong>繼承原理</strong></h3><p>　　python到底是如何實現繼承的，對於你定義的每一個類，python會計算出一個方法解析順序(MRO)列表，這個MRO列表就是一個簡單的所有基類的線性順序列表，例如</p><pre><code>&gt;&gt;&gt; F.mro() #等同於F.__mro__[&lt;class '__main__.F'&gt;, &lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.E'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]</code></pre><p>為了實現繼承,python會在MRO列表上從左到右開始查找基類,直到找到第一個匹配這個屬性的類為止。</p><p>　　而這個MRO列表的構造是通過一個C3線性化算法來實現的。我們不去深究這個算法的數學原理,它實際上就是合併所有父類的MRO列表並遵循如下三條準則:</p><p>　　1.子類會先於父類被檢查</p><p>　　2.多個父類會根據它們在列表中的順序被檢查</p><p>　　3.如果對下一個類存在兩個合法的選擇,選擇第一個父類</p><p><strong>小結</strong></p><p><strong>繼承作用</strong></p><p>減少代碼的重用 提高代碼可讀性 規範編程模式</p><p><strong>繼承中的名詞</strong></p><p>抽象：抽象即抽取類似或者說比較像的部分。是一個從具體到抽象的過程。 繼承：子類繼承了父類的方法和屬性 派生：子類在父類方法和屬性的基礎上產生了新的方法和屬性</p><p><strong>抽象類與接口類</strong></p><p><strong>1.多繼承問題</strong></p><p><strong>在繼承抽象類的過程中，我們應該儘量避免多繼承；</strong></p><p><strong>而在繼承接口的時候，我們反而鼓勵你來多繼承接口</strong></p><p><strong>2.方法的實現</strong></p><p><strong>在抽象類中，我們可以對一些抽象方法做出基礎實現；</strong></p><p><strong>而在接口類中，任何方法都只是一種規範，具體的功能需要子類實現</strong></p><p><strong>鑽石繼承</strong></p><p>新式類：廣度優先 經典類：深度優先</p><p><a class=tteditor-forum data-concern-id=6213177300943374850 data-id=1610484374233096 data-name=Python data-uid>#Python#</a><a class=tteditor-forum data-concern-id=1644255406355470 data-id=1644255406355470 data-name=Python入門推薦 data-uid>#Python入門推薦#</a><a class=tteditor-forum data-concern-id=6213176896532777473 data-id=1610484249379918 data-name=面向對象程序編程 data-uid>#面向對象程序編程#</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>搞懂</a></li><li><a>Python</a></li><li><a>對象</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html alt=Python面向對象設計和麵向對象編程解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html title=Python面向對象設計和麵向對象編程解析>Python面向對象設計和麵向對象編程解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/7169603.html alt=徹底搞懂Python切片操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/282d4dba4dde4392bfafc09ae58e8231 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/7169603.html title=徹底搞懂Python切片操作>徹底搞懂Python切片操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3127c57.html alt=Python面向對象編程的基本概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/96a3b662b2714c5ca50be3b34b20a3d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3127c57.html title=Python面向對象編程的基本概念>Python面向對象編程的基本概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b55bc18.html alt=一文弄懂Python面向對象的三大特性：繼承、封裝、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/7f707ab1-06fe-43ee-94b3-bd1930a26817 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b55bc18.html title=一文弄懂Python面向對象的三大特性：繼承、封裝、多態>一文弄懂Python面向對象的三大特性：繼承、封裝、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/edb4490.html alt=一篇文章搞定Python面向對象之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c79262a079a9437aa21a41d1fafb326c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/edb4490.html title=一篇文章搞定Python面向對象之多態>一篇文章搞定Python面向對象之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html alt=20個機械設計知識點總結，搞懂也是半個行家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b49977fa.html title=20個機械設計知識點總結，搞懂也是半個行家>20個機械設計知識點總結，搞懂也是半個行家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html alt=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/47783c95e3a34185be9ff00f54b4fe7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/319bc575.html title=電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？>電工最常見的幾個電路圖，全都搞懂的才是老師傅，你搞懂了幾個？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html alt=軸承保持架斷裂原因，終於搞懂了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/926568ad42794eac8db9ccfc13716933 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c45fc11.html title=軸承保持架斷裂原因，終於搞懂了！>軸承保持架斷裂原因，終於搞懂了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html alt=「工程造價」搞懂這41個問題，你就是造價大神 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/61e6d766-6c64-42b0-8adc-44437be425ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/edb28816.html title=「工程造價」搞懂這41個問題，你就是造價大神>「工程造價」搞懂這41個問題，你就是造價大神</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>