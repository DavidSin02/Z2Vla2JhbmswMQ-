<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>怎樣深入理解堆和棧 | 极客快訊</title><meta property="og:title" content="怎樣深入理解堆和棧 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05f1045.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/05f1045.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/05f1045.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="怎樣深入理解堆和棧"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/05f1045.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>怎樣深入理解堆和棧</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1 class=ql-align-justify>來源：微信公眾號【cpp軟件架構獅】</h1><p class=ql-align-justify>文章的標題看起來，確實有一點老生常談的感覺，堆棧的文章多如牛毛。你先別急著關閉頁面，接著往下看，這篇文章會帶各位更加<strong>深入的理解堆和棧。</strong></p><p class=ql-align-justify><strong></strong>對於大多數新手來說， “堆棧” 卻不是一個很清晰的概念。堆棧是同一個東西？是數據結構，還是內存分配方式？</p><p class=ql-align-justify><strong>堆棧：一種數據結構，一個在程序運行時用於存放的地方”，相信這可能是很多初學者共同的認識，這也是大部分教科書對“堆棧”的解釋。</strong></p><p class=ql-align-justify><strong></strong>很顯然，用這麼簡單的概括來解釋“堆棧”是不合適的。要深刻認識堆和棧的概念與區別，還必須從如下兩方面說起：</p><ul><li class=ql-align-justify><strong>數據結構的堆和棧</strong></li><li class=ql-align-justify><strong>內存分配方式的堆和棧</strong></li></ul><p>這是第一步</p><p>第二步再<strong>深入系統實現方式理解堆和棧。</strong></p><p><strong>第一步</strong></p><p><strong>數據結構的堆和棧</strong></p><p class=ql-align-justify>在數據結構中，棧是一種可以實現“先進後出”（或者稱為“後進先出”）的存儲結構。假設給定棧 S=（a<sub>0</sub>，a<sub>1</sub>，…，a<sub>n-1</sub>），則稱 a<sub>0</sub>為棧底，a<sub>n-1</sub> 為棧頂。進棧則按照 a<sub>0</sub>，a<sub>1</sub>，…，a<sub>n-1</sub> 的順序進行進棧；而出棧的順序則需要反過來，按照“後存放的先取，先存放的後取”的原則進行，則 a<sub>n-1</sub> 先退出棧，然後 a<sub>n-2</sub> 才能夠退出，最後再退出 a<sub>0</sub>。</p><p class=ql-align-justify>在實際編程中，可以通過兩種方式來實現：</p><ul><li class=ql-align-justify>使用數組的形式來實現棧，這種棧也稱為靜態棧；</li><li class=ql-align-justify>使用鏈表的形式來實現棧，這種棧也稱為動態棧。</li></ul><p class=ql-align-justify>相對於棧的“先進後出”特性，堆則是一種經過排序的樹形數據結構，常用來實現優先隊列等。假設有一個集合 K={k<sub>0</sub>，k<sub>1</sub>，…，k<sub>n-1</sub>}，把它的所有元素按完全二叉樹的順序存放在一個數組中，並且滿足：</p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>則稱這個集合 K 為最小堆（或者最大堆）。</p><p class=ql-align-justify>由此可見，堆是一種特殊的完全二叉樹。其中，節點是從左到右填滿的，並且最後一層的樹葉都在最左邊（即如果一個節點沒有左兒子，那麼它一定沒有右兒子）；每個節點的值都小於（或者都大於）其子節點的值。</p><p class=ql-align-justify>內存分配中的堆和棧</p><p class=ql-align-justify>在 C 語言中，內存分配方式不外乎有如下三種形式：</p><ol><li class=ql-align-justify>從靜態存儲區域分配：它是由編譯器自動分配和釋放的，即內存在程序編譯的時候就已經分配好，這塊內存在程序的整個運行期間都存在，直到整個程序運行結束時才被釋放，如全局變量與 static 變量。</li><li class=ql-align-justify>在棧上分配：它同樣也是由編譯器自動分配和釋放的，即在執行函數時，函數內局部變量的存儲單元都可以在棧上創建，函數執行結束時這些存儲單元將被自動釋放。需要注意的是，棧內存分配運算內置於處理器的指令集中，它的運行效率一般很高，但是分配的內存容量有限。</li><li class=ql-align-justify>從堆上分配：也被稱為動態內存分配，它是由程序員手動完成申請和釋放的。即程序在運行的時候由程序員使用內存分配函數（如 malloc 函數）來申請任意多少的內存，使用完之後再由程序員自己負責使用內存釋放函數（如 free 函數）來釋放內存。也就是說，動態內存的整個生存期是由程序員自己決定的，使用非常靈活。需要注意的是，如果在堆上分配了內存空間，就必須及時釋放它，否則將會導致運行的程序出現內存洩漏等錯誤。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify>由此可見，內存分配的堆棧與數據結構中所闡述的堆棧有著本質的區別，這一點千萬不要混淆。同樣，在內存分配中的堆和棧也存在著很大的區別，也不要混淆這兩者的概念。</p><p class=ql-align-justify>內存分配中的棧與堆主要存在如下區別。</p><p><strong>1) 分配與釋放方式</strong></p><p class=ql-align-justify>棧內存是由編譯器自動分配與釋放的，它有兩種分配方式：靜態分配和動態分配。</p><ul><li class=ql-align-justify>靜態分配是由編譯器自動完成的，如局部變量的分配（即在一個函數中聲明一個 int 類型的變量i時，編譯器就會自動開闢一塊內存以存放變量 i）。與此同時，其生存週期也只在函數的運行過程中，在運行後就釋放，並不可以再次訪問。</li><li class=ql-align-justify>動態分配由 alloca 函數進行分配，但是棧的動態分配與堆是不同的，它的動態分配是由編譯器進行釋放，無需任何手工實現。值得注意的是，雖然用 alloca 函數可以實現棧內存的動態分配，但 alloca 函數的可移植性很差，而且在沒有傳統堆棧的機器上很難實現。因此，不宜使用於廣泛移植的程序中。當然，完全可以使用 C99 中的變長數組來替代 alloca 函數。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify>而堆內存則不相同，它完全是由程序員手動申請與釋放的，程序在運行的時候由程序員使用內存分配函數（如 malloc 函數）來申請任意多少的內存，使用完再由程序員自己負責使用內存釋放函數（如 free 函數）釋放內存，如下面的代碼所示：</p><ul><li><br></li></ul><pre>/*分配堆內存*/char *p1 = (char *)malloc(4);… …/*釋放堆內存*/free(p1);p1=NULL;</pre><p class=ql-align-justify>對棧內存的自動釋放而言，雖然堆上的數據只要程序員不釋放空間就可以一直訪問，但是，如果一旦忘記了釋放堆內存，那麼將會造成內存洩漏，導致程序出現致命的潛在錯誤。</p><p><strong>2) 分配的碎片問題</strong></p><p class=ql-align-justify>對堆來說，頻繁分配和釋放（malloc / free）不同大小的堆空間勢必會造成內存空間的不連續，從而造成大量碎片，導致程序效率降低；而對棧來講，則不會存在這個問題。</p><p><strong>3) 分配的效率</strong></p><p class=ql-align-justify>大家都知道，棧是機器系統提供的數據結構，計算機會在底層對棧提供支持，例如，分配專門的寄存器存放棧的地址，壓棧出棧都有專門的執行指令，這就決定了棧的效率比較高。一般而言，只要棧的剩餘空間大於所申請空間，系統就將為程序提供內存，否則將報異常提示棧溢出。</p><p class=ql-align-justify>而堆則不同，它是由 C/C++ 函數庫提供的，它的機制也相當複雜。例如，為了分配一塊堆內存，首先應該知道操作系統有一個記錄空閒內存地址的鏈表，當系統收到程序的申請時，會遍歷該鏈表，尋找第一個空間大於所申請空間的堆節點，然後將該節點從空閒節點鏈表中刪除，並將該節點的空間分配給程序。而對於大多數系統，會在這塊內存空間的首地址處記錄本次分配的大小，這樣，代碼中的 delete 語句才能正確釋放本內存空間。另外，由於找到的堆節點的大小不一定正好等於申請的大小，系統會自動將多餘的那部分重新放入空閒鏈表中。很顯然，堆的分配效率比棧要低得多。</p><p><strong>4) 申請的大小限制</strong></p><p class=ql-align-justify>由於操作系統是用鏈表來存儲空閒內存地址（內存區域不連續）的，同時鏈表的遍歷方向是由低地址向高地址進行的。因此，堆內存的申請大小受限於計算機系統中有效的虛擬內存。</p><p class=ql-align-justify>而棧則不同，它是一塊連續的內存區域，<strong>其地址的增長方向是向下進行的，向內存地址減小的方向增長</strong>。由此可見，棧頂的地址和棧的最大容量一般都是由系統預先規定好的，如果申請的空間超過棧的剩餘空間時，將會提示溢出錯誤。由此可見，相對於堆，能夠從棧中獲得的空間相對較小。</p><p><strong>5) 存儲的內容</strong></p><p class=ql-align-justify>對棧而言，一般用於存放函數的參數與局部變量等。例如，在函數調用時，第一個進棧的是（主函數中的）調用處的下一條指令（即函數調用語句的下一條可執行語句）的地址，然後是函數的各個參數，<strong>在大多數 C 編譯器中，參數是由右往左入棧的，最後是函數中的局部變量（注意 static 變量是不入棧的）</strong>。</p><p class=ql-align-justify><strong>對堆而言，具體存儲內容由程序員根據需要決定存儲數據。</strong></p><p class=ql-align-justify>最後介紹一下 C 語言中各類型變量的存儲位置和作用域。</p><ul><li class=ql-align-justify>全局變量。從靜態存儲區域分配，其作用域是全局作用域，也就是整個程序的生命週期內都可以使用。與此同時，如果程序是由多個源文件構成的，那麼全局變量只要在一個文件中定義，就可以在其他所有的文件中使用，但必須在其他文件中通過使用extern關鍵字來聲明該全局變量。</li><li class=ql-align-justify>全局靜態變量。從靜態存儲區域分配，其生命週期也是與整個程序同在的，從程序開始到結束一直起作用。但是與全局變量不同的是，全局靜態變量作用域只在定義它的一個源文件內，其他源文件不能使用。</li><li class=ql-align-justify>局部變量。從棧上分配，其作用域只是在局部函數內，在定義該變量的函數內，只要出了該函數，該局部變量就不再起作用，該變量的生命週期也只是和該函數同在。</li><li class=ql-align-justify>局部靜態變量。從靜態存儲區域分配，其在第一次初始化後就一直存在直到程序結束，該變量的特點是其作用域只在定義它的函數內可見，出了該函數就不可見了。</li></ul><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>第二步</strong></p><p class=ql-align-justify>數據結構的堆棧也沒有特別深奧難以理解，所以暫且略過。so最值得去講的是<strong>內存分配方式的堆棧，以x86為例。</strong></p><p class=ql-align-justify>棧寄存器和棧操作</p><ol><li class=ql-align-justify><strong>與棧相關的寄存器有兩個：esp和ebp。</strong></li></ol><ul><li class=ql-align-justify><br></li></ul><pre class=ql-align-justify>esp，棧指針，指向棧頂ebp，基址指針，指向棧底</pre><ol><li class=ql-align-justify><strong>棧操作</strong></li></ol><p class=ql-align-justify><strong>push 進棧</strong></p><p class=ql-align-justify>棧頂指針減少4個字節（棧是由高地址向低地址增長的），例如<strong> pushl %eax</strong>相當於：</p><ul><li><br></li></ul><pre>subl $4, %espmovl %eax, (%esp)</pre><p class=ql-align-justify><strong>pop 出棧</strong></p><p class=ql-align-justify>棧頂地址增加4個字節，例如，popl %eax相當於：</p><ul><li><br></li></ul><pre> movl (%esp), %eax add $4, %esp </pre><p class=ql-align-justify><strong>3.call</strong></p><p class=ql-align-justify>eip，程序計數器，總是指向下一條指令的位置。在進行函數調用時，會執行call指令，將eip中內容指向對應函數的位置。call具體執行過程如下：</p><p class=ql-align-justify>首先將eip的值壓如棧頂，然後將eip執行被調用函數的入口地址。具體指令如下：</p><pre class=ql-align-justify></pre><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre> pushl %eip movl 0x12345, %eip 4.ret</pre><ol><li class=ql-align-justify>彈出原來保存在棧頂的原eip中的值，放入eip。</li></ol><p class=ql-align-justify><br></p><p class=ql-align-justify>函數的棧框架</p><p class=ql-align-justify>每一個函數都會維持一個棧。棧框架會包裹函數執行體。如下圖所示：</p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/17d0414b5d894b6ab6a24f8f2766f219><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>分析demo</strong></p><p class=ql-align-justify><strong>源碼：</strong></p><ul><li><br></li></ul><pre>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void p1(char c){ printf(%c\n",c);}int p2(int x,int y){ return x + y;} int main(){ char c = 'a'; int x,y,z; x = 1; y = 2; p1(c); z = p2(x,y); printf("%d = %d + %d\n",z,x,y);}</pre><p class=ql-align-justify><strong>反彙編後</strong>：</p><ul><li><br></li></ul><pre>.LC0: .string "%c\n" .textp1: pushl %ebp movl %esp, %ebp subl $12, %esp movl 8(%ebp), %eax movb %al, -4(%ebp) movsbl -4(%ebp),%eax movl %eax, 4(%esp) movl $.LC0, (%esp) call printf leave retp2: pushl %ebp movl %esp, %ebp movl 12(%ebp), %eax addl 8(%ebp), %eax popl %ebp ret.LC1: .string "%d = %d + %d\n" .textmain: pushl %ebp movl %esp, %ebp subl $32, %esp movb $97, -13(%ebp) movl $1, -12(%ebp) movl $2, -8(%ebp) movsbl -13(%ebp),%eax movl %eax, (%esp) call p1 movl -8(%ebp), %eax movl %eax, 4(%esp) movl -12(%ebp), %eax movl %eax, (%esp) call p2 movl %eax, -4(%ebp) movl -8(%ebp), %eax movl %eax, 12(%esp) movl -12(%ebp), %eax movl %eax, 8(%esp) movl -4(%ebp), %eax movl %eax, 4(%esp) movl $.LC1, (%esp) call printf leave ret</pre><p class=ql-align-justify><strong>接下來我們分析下棧的過程</strong></p><ul><li><br></li></ul><pre>pushl %ebpmovl %esp, %ebp</pre><p class=ql-align-justify>以上兩條指令屬於函數調用框架，作用就是為main函數建議一個新的空的棧。</p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c74906e6a80494ea841600f69688bb9><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>subl $32, %espmovb $97, -13(%ebp)movl $1, -12(%ebp)movl $2, -8(%ebp)</pre><p class=ql-align-justify>第一條指令的目的是在棧中開闢32字節的空間，存儲局部變量。編譯器會事先掃描函數中局部變量個數和大小，預分配給一個空間，供存儲局部變量和參數調用。</p><p class=ql-align-justify>剩下三條指令為將局部變量壓棧。</p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b7846e12ffc74c3190be3d2c6a0994ab><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>movsbl -13(%ebp),%eaxmovl %eax, (%esp)</pre><p class=ql-align-justify>將參數c=‘a’壓棧</p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>call p1</pre><p class=ql-align-justify>相當於：</p><ul><li><br></li></ul><pre> pushl %eip movl p1, %eip</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ebebd9b556af457f8d4d0f963817fd1e><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>pushl %ebpmovl %esp, %ebpsubl $12, %esp</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4be6625a29554c5eb3c8e81d5dd75ab6><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>movl 8(%ebp), %eaxmovb %al, -4(%ebp)movsbl -4(%ebp),%eaxmovl %eax, 4(%esp)movl $.LC0, (%esp)</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/eff2f829a30a4e9c9cf29a1cee71b6a2><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>call printfleaveret</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1f7365bb9a248cab24924f0ba08011d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><ul><li><br></li></ul><pre>movl -8(%ebp), %eaxmovl %eax, 4(%esp)movl -12(%ebp), %eaxmovl %eax, (%esp)</pre><p class=ql-align-justify><br></p><div class=pgc-img><img alt=怎樣深入理解堆和棧 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1437bf4d681c4afdb333291d75c8be94><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>進入p2函數，過程和p1函數調用過程相似。以上就是函數調用棧的過程。</p><p class=ql-align-justify><strong>堆的深入理解</strong></p><p class=ql-align-justify>棧上的數據在函數返回時就會被釋放掉，所以無法將數據傳至函數外部，而全局變量沒有辦法動態地產生，只能在編譯的時候定義，在這種情況下，堆是唯一地選擇。malloc是C語言申請堆空間的函數，但是它是怎麼實現的那？</p><p class=ql-align-justify>其實可以直接讓操作系統的內核來管理進程的內存，但是每次申請內存都要經過系統調用，如果操作頻繁會導致效率很低，程序性能降低。比較好的做法是程序向操作系統申請一塊適當的堆空間，然後由程序的運行庫根據算法管理堆空間的分配，當堆空間不夠的時候再向操作系統申請堆空間。linux下提供兩種堆空間分配方式：<strong>一個是brk（）系統調用，另外一個是mmap（）。</strong></p><ul><li><br></li></ul><pre>int brk (void *end_data_segment)</pre><p class=ql-align-justify>brk()的作用實際上就是設置進程數據段的結束地址，她可以擴大或者縮小數據段。</p><ul><li><br></li></ul><pre>void mmap（void *start, size_t length, int port, int flags, int fd, off_t offset）</pre><p class=ql-align-justify>mmap的前兩個參數分別指定需要申請的空間的起始地址和長度，如果其實地址設為0，那麼操作系統會挑選合適的起始地址。port/flags這兩個參數用於設置申請的空間的權限（可讀，可寫，可執行）以及映射類型（文件類型，匿名空間等），最後兩個參數用於文件映射是指定文件的描述符和文件偏移。用mmap實現的malloc函數：</p><ul><li><br></li></ul><pre>void *malloc(size_t nbytes){ void *ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0 , 0); if (ret == MAP_FAILED) return 0; return ret;}</pre><p class=ql-align-justify><strong>mmap（）的作用是向操作系統申請一段虛擬空間，當這塊虛擬空間可以映射到某個文件（也就是這個系統調用的最初的作用），當他不將地址空間映射到某個文件時，我們又稱這塊空間為匿名空間。</strong></p><p class=ql-align-justify>glibc的malloc 函數是這樣處理用戶的空間請求的：對於小於128KB的請求來說，它會在現有的堆空間裡面，按照堆分配算法為它分配一塊空間返回，對於大於128KB的請求來說，它會使用mmap（）函數為它分配一塊匿名空間，然後再這個匿名空間中為用戶分配空間。（所以問一個很常見的問題，malloc申請的內存，進程結束以後還會不會存在？ 答案是不存在）</p><p><strong>堆分配算法</strong></p><p><strong>1、空閒鏈表法</strong></p><p>空閒鏈表的方法是把堆中各個空閒的快按照鏈表的方式連接起來，當用戶請求一塊空間時，可以遍歷整個列表，直到找到合適大小的快並且將它拆分，當用戶釋放空間時將它合併到空閒鏈表中。</p><p class=ql-align-justify><strong>2、位圖</strong></p><p class=ql-align-justify><strong></strong>核心思想就是將整個堆劃分為大量的塊，每個塊大小相同。當用戶請求內存的時候總是分配整個塊的空間給用戶。第一個塊我們稱為已分配區域的頭，其餘的稱為已分配區域的主體。而我們可以使用一個整數數組來記錄塊的使用情況，由於每個塊只有頭/主體/空閒三種狀態，因此僅僅需要兩位即可表示一個塊，因此稱為位圖。</p><p><strong>優點：速度快，穩定性好，容易管理。</strong></p><p><strong>缺點：容易產生碎片，浪費空間。</strong></p><p class=ql-align-justify><strong>3、對象池</strong></p><p class=ql-align-justify>如果實際上在一些場合，被分配對象的大小是固定的幾個值，我們可以採用對象池的方法。對象池思想就是，如果每一次分配的空間大小都一樣，那麼就可以按照這個每次請求分配的大小作為一個單位，把整個堆空間劃分為大量的小塊，每次請求只要找到一個空閒的小塊就可以了。</p><p class=ql-align-justify><strong>實際上很多應用中，堆的分配算法往往是採取多種算法複合而成的，對於glibc來說，小於64字節的採用對象池的方法，對於大於512字節的採用最佳適配算法，對於64字節和512字節之間的採取最佳折中策略；對於大於128kb的申請，它會直接使用mmap向操作系統申請空間。</strong></p><p class=ql-align-justify><strong>總結</strong></p><p class=ql-align-justify>這篇文章花了我8個小時的時間，真的不容易。從基本到深入，從堆到棧。從數據結構到內存分配方式。要想吃透還得在工作中加以實踐。</p><p class=ql-align-justify><strong>END</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>怎樣</a></li><li><a>深入</a></li><li><a>理解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E5%AD%B8/dcbf547f.html alt=深入理解支持向量機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a4485e2df65444c4a76999521943821c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/dcbf547f.html title=深入理解支持向量機>深入理解支持向量機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72139afe.html alt=怎樣對臍橙樹進行扭枝（彎枝）促花？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe6ea8ad111f421c9673e3f61072fa1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72139afe.html title=怎樣對臍橙樹進行扭枝（彎枝）促花？>怎樣對臍橙樹進行扭枝（彎枝）促花？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/11a109e5.html alt=網站搭建怎樣選擇好的服務器? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/11a109e5.html title=網站搭建怎樣選擇好的服務器?>網站搭建怎樣選擇好的服務器?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/831dd688.html alt=葛洪健康快車：怎樣按壓耳朵調治失眠？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/5e7600044965a1a66955 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/831dd688.html title=葛洪健康快車：怎樣按壓耳朵調治失眠？>葛洪健康快車：怎樣按壓耳朵調治失眠？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d997d2f.html alt=寫作時怎樣去描寫一個場面 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d997d2f.html title=寫作時怎樣去描寫一個場面>寫作時怎樣去描寫一個場面</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc683c38.html alt=怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7559326b0b254462970a98290ef15e9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc683c38.html title=怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分>怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/32a99b12.html alt=怎樣跳纖？【看完就知道了】 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f5acf09fdf9a4abfbdb64f901c2cf353 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32a99b12.html title=怎樣跳纖？【看完就知道了】>怎樣跳纖？【看完就知道了】</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/67fef4c6.html alt=2019年高考，怎樣設置院校梯度才合理？衝、穩、保、墊，很關鍵！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f8d17716-f3b8-4c6d-8eb7-f482334ad491 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/67fef4c6.html title=2019年高考，怎樣設置院校梯度才合理？衝、穩、保、墊，很關鍵！>2019年高考，怎樣設置院校梯度才合理？衝、穩、保、墊，很關鍵！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/087a8932.html alt=如何真正理解梯度的含義 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d4719d4d74574ed1a033aefbd26cee65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/087a8932.html title=如何真正理解梯度的含義>如何真正理解梯度的含義</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c91ca5ec.html alt=怎樣使毛巾變軟方法全解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f6634e91151441ea87c6899cdfa41fa8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c91ca5ec.html title=怎樣使毛巾變軟方法全解>怎樣使毛巾變軟方法全解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcd685fe.html alt=怎樣使毛巾變軟？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/b8d30e5f-7499-4568-98e5-9705c7902745 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcd685fe.html title=怎樣使毛巾變軟？>怎樣使毛巾變軟？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/124667e5.html alt=柿子硬邦邦的不好吃，那要怎樣快速變軟呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/852e738130844657b1e9c470c1e4d8c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/124667e5.html title=柿子硬邦邦的不好吃，那要怎樣快速變軟呢？>柿子硬邦邦的不好吃，那要怎樣快速變軟呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html alt=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/470f515e8fe44c6184b07227fdb51333 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/33348acb.html title=《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）>《深入精通Mysql（三）》深入底層Mysql各種鎖機制（面試必問）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3542a850.html alt=大白鯧魚怎樣做好吃？蒸煎燜炸你一定吃過，鹹水煮吃過嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/2f7dcd00-bb73-4ad4-85b2-de3e2bf49ba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3542a850.html title=大白鯧魚怎樣做好吃？蒸煎燜炸你一定吃過，鹹水煮吃過嗎？>大白鯧魚怎樣做好吃？蒸煎燜炸你一定吃過，鹹水煮吃過嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9f0815a.html alt=汽車知識分享：怎樣讓小白快速瞭解汽車部件（中篇） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7a3677e5c6a9474a829a501f80de2d81 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9f0815a.html title=汽車知識分享：怎樣讓小白快速瞭解汽車部件（中篇）>汽車知識分享：怎樣讓小白快速瞭解汽車部件（中篇）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>