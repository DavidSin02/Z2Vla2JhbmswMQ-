<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SpringMVC4.2.4中文文檔 第一部分 | 极客快訊</title><meta property="og:title" content="SpringMVC4.2.4中文文檔 第一部分 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/509d000374a90e7c97cf"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/06a4222.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/06a4222.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/06a4222.html><meta property="article:published_time" content="2020-10-29T20:54:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:54:48+08:00"><meta name=Keywords content><meta name=description content="SpringMVC4.2.4中文文檔 第一部分"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/06a4222.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SpringMVC4.2.4中文文檔 第一部分</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt="SpringMVC4.2.4中文文檔 第一部分" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/509d000374a90e7c97cf></p><p>1.1</p><p>1.2</p><p>1.3</p><p>2.1</p><p>2.1.1</p><p>2.1.2</p><p>2.2</p><p>2.2.1</p><p>2.2.2</p><p>2.2.3</p><p>2.3</p><p>2.3.1</p><p>2.3.2</p><p>2.3.3</p><p>2.3.4</p><p>2.3.5</p><p>2.4</p><p>2.4.1</p><p>2.5</p><p>2.5.1</p><p>2.5.2</p><p>2.5.3</p><p>2.5.4</p><p>2.6</p><p>Table of Contents</p><p>Part I: 目錄與翻譯註記(Table of contents andNotes)Introduction</p><p>目錄</p><p>翻譯註記</p><p>Part II: 文檔內容(Documentation contents)Spring Web MVC框架簡介</p><p>Spring Web MVC的新特性</p><p>允許其他MVC實現</p><p>DispatcherServlet</p><p>WebApplicationContext中特殊的Bean類型</p><p>默認的DispatcherServlet配置</p><p>DispatcherServlet的處理流程</p><p>控制器的實現</p><p>使用@Controller註解定義一個控制器</p><p>使用@RequestMapping註解映射請求路徑</p><p>定義@RequestMapping註解的處理方法</p><p>異步請求的處理</p><p>對控制器測試</p><p>處理器映射</p><p>使用HandlerInterceptor攔截請求</p><p>視圖解析</p><p>使用ViewResolver接口解析視圖</p><p>視圖鏈</p><p>視圖重定向</p><p>內容協商解析器ContentNegotiatingViewResolver</p><p>使用閃存屬性FlashAttributes</p><p>1</p><p>2.7</p><p>2.7.1</p><p>2.7.2</p><p>2.8</p><p>2.8.1</p><p>2.8.2</p><p>2.8.3</p><p>2.8.4</p><p>2.8.5</p><p>2.9</p><p>2.9.1</p><p>2.9.2</p><p>2.9.3</p><p>2.10</p><p>2.10.1</p><p>2.10.2</p><p>2.10.3</p><p>2.10.4</p><p>2.10.5</p><p>2.11</p><p>2.11.1</p><p>2.11.2</p><p>2.11.3</p><p>2.11.4</p><p>2.11.5</p><p>2.12</p><p>2.13</p><p>2.13.1</p><p>2.13.2</p><p>2.13.3</p><p>2.14</p><p>2.14.1</p><p>2.14.2</p><p>2.14.3</p><p>URI構造</p><p>為控制器和方法指定URI</p><p>在視圖中為控制器和方法指定URI</p><p>地區信息</p><p>獲取時區信息</p><p>Accept請求頭解析器AcceptHeaderLocaleResolver</p><p>Cookie解析器CookieLocaleResolver</p><p>Session解析器SessionLocaleResolver</p><p>地區更改攔截器LocaleChangeInterceptor</p><p>主題 themes</p><p>關於主題：概覽</p><p>定義主題</p><p>主題解析器</p><p>Spring的multipart（文件上傳）支持</p><p>概述</p><p>使用MultipartResolver與Commons FileUpload傳輸文件</p><p>Servlet 3.0下的MultipartResolver</p><p>處理表單中的文件上傳</p><p>處理客戶端發起的文件上傳請求</p><p>異常處理</p><p>處理器異常解析器HandlerExceptionHandler</p><p>@ExceptionHandler註解</p><p>處理一般的Spring MVC異常</p><p>使用@ResponseStatus註解業務異常</p><p>Servlet默認容器錯誤頁面的定製化</p><p>Web安全</p><p>"約定優於配置"的支持</p><p>控制器類名-處理器映射ControllerClassNameHandlerMapping</p><p>模型ModelMap(ModelAndView)</p><p>視圖-請求與視圖名的映射</p><p>HTTP緩存支持</p><p>HTTP請求頭Cache-Control</p><p>對靜態資源的HTTP緩存支持</p><p>在控制器中設置Cache-Control、ETag和Last-Modified響應頭</p><p>2</p><p>2.14.4</p><p>2.15</p><p>2.16</p><p>2.16.1</p><p>2.16.2</p><p>2.16.3</p><p>2.16.4</p><p>2.16.5</p><p>2.16.6</p><p>2.16.7</p><p>2.16.8</p><p>2.16.9</p><p>2.16.10</p><p>2.16.11</p><p>2.16.12</p><p>2.16.13</p><p>2.16.14</p><p>弱ETag</p><p>基於代碼的Servlet容器初始化</p><p>配置Spring MVC</p><p>啟用MVC Java編程配置或MVC命名空間</p><p>默認配置的定製化</p><p>轉換與格式化</p><p>驗證</p><p>攔截器</p><p>內容協商</p><p>視圖控制器</p><p>視圖解析器</p><p>資源的服務</p><p>回到默認的Servlet來進行資源服務</p><p>路徑匹配</p><p>消息轉換器</p><p>使用MVC Java編程進行高級定製</p><p>使用MVC命名空間進行高級定製</p><p>3</p><p>Spring MVC 4.2.4.RELEASE 中文文檔</p><p>本項目翻譯的是Spring MVC官方4.2.4.RELEASE版本的文檔，包含原文檔第21章SpringMVC部分的全部內容。譯文盡力於準確傳達原意，其次兼顧譯文的流暢自然。至於風格和質感，則仍在努力。希望它能為讀者帶來查閱、學習的價值，自己時不時翻之，仍有收穫。</p><p>目前多數章節的翻譯已完成，剩餘部分章節仍在進行。文檔仍在維護狀態，主要還有譯文細</p><p>化、術語定義、翻譯規範、內容、主頁修繕、自動化部署等工作可做，issues這裡有一些有意思的idea。翻譯過程中遇到值得探討的翻譯問題、取捨及最終解決方案，讀者可見翻譯註記。</p><p>本翻譯初始只是自我學習需要，逐漸完善後才有堅持完成的執念。陳丹青在《木心談木心》</p><p>的後記中，講到他猶豫於出版木心先生這本私房話的心境。為本譯文做推廣、宣傳伊始，我</p><p>也開始面對我的讀者，讀之，感覺真摯感動。不敢自比木心，我在我的風中等消息。</p><p>&amp;mdash;&amp;mdash;2016年6月28 交房租日，8月28日 完成自動化部署後補稿</p><p>中文文檔地址</p><p>主站：mvc.linesh.tw（速度和穩定性更好，樣式也與原文檔一致）國外Gitbook原站</p><p>原文地址</p><p>Spring MVC 4.2.4.RELEASE Documentation</p><p>其他相關翻譯項目</p><p>Introduction</p><p>4</p><p>為了對目前Spring MVC部分文檔翻譯現狀有個大致的瞭解，可以"Spring MVC 中文 文檔 翻譯"作為關鍵詞，瀏覽其在google和baidu上前6頁的搜索結果。其中以下項目值得留意，前兩個均或完全或部分地翻譯了Spring MVC部的內容，可供參考；後面三個項目未涉及SpringMVC部分的翻譯。</p><p>項目 作者項目</p><p>Github 描述</p><p>Spring框架參考文檔</p><p>一個團隊 Github</p><p>該項目規模較大、參與人數較多。翻譯內容是Spring 4.1.3.RELEASE版本全部文檔，其中MVC部分的文檔也翻譯了一大半。其項目主頁保留了與原生Spring文檔較一致的樣式，很不錯</p><p>SpringFramework2.5翻譯計</p><p>劃</p><p>滿江紅機構 -感謝dsliu在gitbook上給我提供此版譯本鏈接。譯本是整個MVC 2.5.2版的全部文檔，其中MVC的部分同樣齊全</p><p>SpringFramework4.x參考文</p><p>檔</p><p>waylau Github 翻譯了Spring文檔的簡介、新特性和容器IOC部分</p><p>SpringFramework4.x中文翻</p><p>譯</p><p>sunrh Github 翻譯了Spring文檔的簡介、新特性和容器IOC部分</p><p>Spring 中文文檔3.1 wizardforcel -</p><p>主頁已標記廢棄的項目。樓主BIO是專注單身二十年，言語間竟有一種大學宿友不是說我的宿友的即視感</p><p>友情鏈接</p><p>這個譯本我在國內的多個站點均發表過一篇相同的推廣文章，如OSC/CSDN/Iteye/博客園/掘金/v2ex/segmentfault/Githuber等。除了交付的譯文本身外，還聊瞎扯了一些其他的東西。同時，關於這個翻譯文檔的創始、管理及自動化部署等方面，我也已將其總結成為文章。此二</p><p>篇文章是對這個項目的完整記錄，均發佈在我的博客上，有興趣的讀者可以前往閱讀。後來</p><p>我又做了一些主頁樣式上的遷移、自動化了一些構建前文檔預處理的工作，還有一些代碼的</p><p>重構。這部分未做記錄，但代碼和部署構架方面我十分滿意，其精華在 package.json 和構建</p><p>腳本中。</p><p>Spring MVC官方文檔翻譯稿發佈我是如何進行Spring MVC文檔翻譯項目的環境搭建、項目管理及自動化構建工作的</p><p>聯繫方式</p><p>Introduction</p><p>5</p><p>閱讀過程中的任何想法、建議、吐槽、強迫症不給譯者狂點100個贊就渾身不舒服、覺得贊、覺得不讚，無論關於翻譯、技術、樣式等，對我來說很有意義啊我這文風竟有一種安妮寶貝</p><p>般的性冷淡感！你可以通過以下的方式聯繫作者我：</p><p>來Github點贊 被消費一個 在Gitbook討論裡 給我留言給這個項目提 issue給這個項目提 pull request郵箱：linesh.simpcity@gmail.com</p><p>LicenseMIT License</p><p>貢獻者 Contributor感謝那些讓這個項目變得更好的人們。</p><p>呂立青 Sun SongWang 易梟寒 xcatliu</p><p>Introduction</p><p>6</p><p>目錄</p><p>Spring Web MVC框架簡介Spring Web MVC的新特性允許其他MVC實現</p><p>DispatcherServletWebApplicationContext中特殊的Bean類型默認的DispatcherServlet配置DispatcherServlet的處理流程</p><p>控制器的實現</p><p>使用@Controller註解定義一個控制器使用@RequestMapping註解映射請求路徑定義@RequestMapping註解的處理方法異步請求的處理</p><p>對控制器測試</p><p>處理器映射</p><p>使用HandlerInterceptor攔截請求視圖解析</p><p>使用ViewResolver接口解析視圖視圖鏈</p><p>視圖重定向</p><p>內容協商解析器ContentNegotiatingViewResolver使用閃存屬性FlashAttributesURI構造</p><p>為控制器和方法指定URI在視圖中為控制器和方法指定URI</p><p>地區信息</p><p>獲取時區信息</p><p>Accept請求頭解析器AcceptHeaderLocaleResolverCookie解析器CookieLocaleResolverSession解析器SessionLocaleResolver地區更改攔截器LocaleChangeInterceptor</p><p>主題 themes關於主題：概覽</p><p>定義主題</p><p>主題解析器</p><p>Spring的multipart（文件上傳）支持概述</p><p>目錄</p><p>7</p><p>使用MultipartResolver與Commons FileUpload傳輸文件Servlet 3.0下的MultipartResolver處理表單中的文件上傳</p><p>處理客戶端發起的文件上傳請求</p><p>異常處理</p><p>處理器異常解析器HandlerExceptionHandler@ExceptionHandler註解處理一般的Spring MVC異常使用@ResponseStatus註解業務異常Servlet默認容器錯誤頁面的定製化</p><p>Web安全"約定優於配置"的支持</p><p>控制器類名-處理器映射ControllerClassNameHandlerMapping模型ModelMap(ModelAndView)視圖-請求與視圖名的映射</p><p>HTTP緩存支持HTTP請求頭Cache-Control對靜態資源的HTTP緩存支持在控制器中設置Cache-Control、ETag和Last-Modified響應頭弱ETag</p><p>基於代碼的Servlet容器初始化配置Spring MVC</p><p>啟用MVC Java編程配置或MVC命名空間默認配置的定製化</p><p>轉換與格式化</p><p>驗證</p><p>攔截器</p><p>內容協商</p><p>視圖控制器</p><p>視圖解析器</p><p>資源的服務</p><p>回到默認的Servlet來進行資源服務路徑匹配</p><p>消息轉換器</p><p>使用MVC Java編程進行高級定製使用MVC命名空間進行高級定製</p><p>目錄</p><p>8</p><p>外延豐富/有業務含義的術語翻譯：直譯、保留原文、詞彙表</p><p>一些術語難翻的點可能有以下各個方面，比如：</p><p>具有寬泛的外延/內涵/比喻義/象徵義/指代義（比如request/response，有時指一個HTTP層面的請求，有時指一個應用層級的請求，有時又特指一個請求對象，有時又具體到特</p><p>定類型 HttpServletRequest 請求對象中的內容或請求頭等，又比如mapping，可以動詞映射，也可以是名詞什麼什麼映射，有時它還可以省略映射的目標或源對象)具有相對自治、完整的業務含義（比如scope、action、bean、flashmap、multipart、session/conversation等），而該業務領域在中文技術世界又尚無對應詞彙</p><p>目前大致的處理方式是：</p><p>對於其外延義尚可翻（只是中文語意承載量仍然不足）的單詞，採用 直譯+詞彙表 的翻譯。詞彙表即是鼠標劃過停留時，會顯示額外的提示信息，在提示裡更詳細地解釋這個</p><p>詞在英文中的完整含義）</p><p>對於業務含義較完備，且深刻體現在代碼或命名中實在沒法翻的單詞，採用 保留原文+詞彙表 的方式翻譯</p><p>未決翻譯</p><p>locales：本地化？地區？multipart：多部分（這是中文）？多路？flashmap：我徹底地慌了。不知道怎麼翻好，可能需要查一下TCP/IP這一塊的名詞，看看有沒有什麼專業字詞能夠體現、概括的</p><p>TODOLIST翻譯怎麼樣算好？具體到技術翻譯這個上下文，全部照翻為好？誰都能意識到要適當變</p><p>通，可變通的度是多少？如果要求的是字字都有對應譯，還要符合中文風格，那此種翻</p><p>譯豈非只在尋求一個可能存在的"解"而失去任何可能的發揮？如果要求的是信達的同時可以體現風格，強調內在和諧勝於字句適配，那麼風格的適當與否評價標準又在哪裡？譯</p><p>者和作者的關係是怎樣的？</p><p>翻譯註記</p><p>9</p><p>21.1 Spring Web MVC框架簡介Spring的模型-視圖-控制器（MVC）框架是圍繞一個 DispatcherServlet 來設計的，這個Servlet會把請求分發給各個處理器，並支持可配置的處理器映射、視圖渲染、本地化、時區與主題渲染等，甚至還能支持文件上傳。處理器是你的應用中註解</p><p>了 @Controller 和 @RequestMapping 的類和方法，Spring為處理器方法提供了極其多樣靈活的配置。Spring 3.0以後提供了 @Controller 註解機制、 @PathVariable 註解以及一些其他的特性，你可以使用它們來進行RESTful web站點和應用的開發。</p><p>"對擴展開放"是Spring Web MVC框架一個重要的設計原則，而對於Spring的整個完整框架來說，其設計原則則是"對擴展開放，對修改閉合"。</p><p>Spring Web MVC核心類庫中的一些方法被定義為 final 方法。作為開發人員，你不能覆寫這些方法以定製其行為。當然，不是說絕對不行，但請記住這條原則，絕大多數情</p><p>況下不是好的實踐。</p><p>關於該原則的詳細解釋，你可以參考Seth Ladd等人所著的"深入解析Spring Web MVC與Web Flow"一書。相關信息在第117頁，"設計初探（A Look At Design）"一節。或者，你可以參考：</p><p>Bob Martin所寫的"開閉原則（The Open-Closed Principle）"（PDF）</p><p>你無法增強Spring MVC中的 final 方法，比如 AbstractController.setSynchronizeOnSession() 方法等。請參考10.6.1 理解AOP代理一節，其中解釋了AOP代理的相關知識，論述了為什麼你不能對 final 方法進行增強。</p><p>在Spring Web MVC中，你可以使用任何對象來作為命令對象或表單返回對象，而無須實現一個框架相關的接口或基類。Spring的數據綁定非常靈活：比如，它會把數據類型不匹配當成可由應用自行處理的運行時驗證錯誤，而非系統錯誤。你可能會為了避免非法的類型轉換在表</p><p>單對象中使用字符串來存儲數據，但無類型的字符串無法描述業務數據的真正含義，並且你</p><p>還需要把它們轉換成對應的業務對象類型。有了Spring的驗證機制，意味著你再也不需這麼做了，並且直接將業務對象綁定到表單對象上通常是更好的選擇。</p><p>Spring的視圖解析也是設計得異常靈活。控制器一般負責準備一個 Map 模型、填充數據、返回一個合適的視圖名等，同時它也可以直接將數據寫到響應流中。視圖名的解析高度靈活，</p><p>支持多種配置，包括通過文件擴展名、 Accept 內容頭、bean、配置文件等的配置，甚至你還可以自己實現一個視圖解析器 ViewResolver 。模型（MVC中的M，model）其實是一個 Map 類型的接口，徹底地把數據從視圖技術中抽象分離了出來。你可以與基於模板的渲染</p><p>技術直接整合，如JSP、Velocity和Freemarker等，或者你還可以直接生成XML、JSON、Atom以及其他多種類型的內容。 Map 模型會簡單地被轉換成合適的格式，比如JSP的請求屬性（attribute），一個Velocity模板的模型等。</p><p>Spring Web MVC框架簡介</p><p>10</p><p>Spring Web MVC框架簡介</p><p>11</p><p>21.1.1 Spring Web MVC的新特性Spring Web Flow</p><p>Spring Web Flow (SWF) 意在成為web應用中的頁面流(page flow)管理中最好的解決方案。</p><p>SWF在Servlet環境和Portlet環境下集成了現有的框架，如Spring MVC和JSF等。如果你的業務流程有一個貫穿始終的模型，而非單純分立的請求，那麼SWF可能是適合你的解決方案。</p><p>SWF允許你將邏輯上的頁面流抽取成獨立可複用的模塊，這對於構建一個web應用的多個模塊是有益的。that guide the user through controlled navigations that drive businessprocesses.</p><p>關於SWF的更多信息，請訪問Spring Web Flow的官網。</p><p>Spring的web模塊支持許多web相關的特性：</p><p>清晰的職責分離。每個角色&amp;mdash;&amp;mdash;控制器，驗證器，命令對象，表單對象，模型對象， DispatcherServlet ，處理器映射，視圖解析器，等等許多&amp;mdash;&amp;mdash;的工作，都可以由相應的對象來完成。</p><p>強大、直觀的框架和應用bean的配置。這種配置能力包括能夠從不同的上下文中進行簡單的引用，比如在web控制器中引用業務對象、驗證器等。強大的適配能力、非侵入性和靈活性。Spring MVC支持你定義任意的控制器方法簽名，在特定的場景下你還可以添加適合的註解（比</p><p>如 @RequestParam 、 @RequestHeader 、 @PathVariable 等）</p><p>可複用的業務代碼，使你遠離重複代碼。你可以使用已有的業務對象作為命令對象或表</p><p>單對象，而不需讓它們去繼承一個框架提供的什麼基類。</p><p>可定製的數據綁定和驗證。類型不匹配僅被認為是應用級別的驗證錯誤，錯誤值、本地</p><p>化日期、數字綁定等會被保存。你不需要再在表單對象使用全String字段，然後再手動將它們轉換成業務對象。</p><p>可定製的處理器映射和視圖解析。處理器映射和視圖解析策略從簡單的基於URL配置，到精細專用的解析策略，Spring全都支持。在這一點上，Spring比一些依賴於特定技術的web框架要更加靈活。靈活的模型傳遞。Spring使用一個名稱/值對的Map來做模型，這使得模型很容易集成、傳遞給任何類型的視圖技術。</p><p>可定製的本地化信息、時區和主題解析。支持用/不用Spring標籤庫的JSP技術，支持JSTL，支持無需額外配置的Velocity模板，等等。;一個簡單但功能強大的JSP標籤庫，通常稱為Spring標籤庫，它提供了諸如數據綁定、主題支持等一些特性的支持。這些定製的標籤為標記（markup）你的代碼提供了最大程度</p><p>Spring Web MVC的新特性</p><p>12</p><p>的靈活性。關於標籤庫描述符（descriptor）的更多信息，請參考附錄第42章 Spring JSP標籤庫</p><p>一個Spring 2.0開始引入的JSP表單標籤庫。它讓你在JSP頁面中編寫表單簡單許多。關於標籤庫描述符（descriptor）的更多信息，請參考附錄 第43章 Spring表單的JSP標籤庫新增生命週期僅綁定到當前HTTP請求或HTTP會話的Bean類型。嚴格來說，這不是Spring MVC自身的特性，而是Spring MVC使用的上下文容器 WebApplicationContext 所提供的特性。這些bean的scope在6.5.4 請求、會話及全局會話scope一節有詳細描述。</p><p>Spring Web MVC的新特性</p><p>13</p><p>21.1.2 允許其他MVC實現有些項目可能更傾向於使用非Spring的MVC框架。 許多團隊希望仍然使用現有的技術棧，比如JSF等，這樣他們掌握的技能和工具依然能發揮作用。</p><p>如果你確實不想使用Spring的Web MVC，但又希望能從Spring提供的一些解決方案中受益，那麼將你所使用的框架和Spring進行集成也很容易。只需要在 ContextLoaderListener 中啟動一個Spring的根應用上下文（root application context），然後你就可以在任何action對象中通過其 ServletContext 屬性（或通過Spring對應的helper方法）取得。不需要任何侵入性的插件，因此不需要複雜的集成。從應用層的視角來看，你只是將Spring當成依賴庫使用，並且將它的根應用上下文實例作為應用進入點。</p><p>即使不用Spring的Web MVC框架，你配置的其他Spring的bean和服務也都能很方便地取得。在這種場景下，Spring與其他web框架的使用不衝突。Spring只是在許多問題上提出了其他純web MVC框架未曾提出過的解決方案，比如bean的配置、數據存取、事務處理等，僅此而已。因此，如果你只是想使用Spring的一部分特性來增強你的應用，比如Spring提供的JDBC/Hibernate事務抽象等，那麼你可以將Spring作為一箇中間層和/或數據存取層來使用。</p><p>允許其他MVC實現</p><p>14</p><p>21.2 DispatcherServletSpring MVC框架，與其他很多web的MVC框架一樣：請求驅動；所有設計都圍繞著一箇中央Servlet來展開，它負責把所有請求分發到控制器；同時提供其他web應用開發所需要的功能。不過Spring的中央處理器， DispatcherServlet ，能做的比這更多。它與Spring IoC容器做到了無縫集成，這意味著，Spring提供的任何特性，在Spring MVC中你都可以使用。</p><p>下圖展示了Spring Web MVC的 DispatcherServlet 處理請求的工作流。熟悉設計模式的朋友會發現， DispatcherServlet 應用的其實就是一個"前端控制器"的設計模式（其他很多優秀的web框架也都使用了這個設計模式）。</p><p>DispatcherServlet 其實就是個 Servlet （它繼承自 HttpServlet 基類），同樣也需要在你</p><p>web應用的 web.xml 配置文件下聲明。你需要在 web.xml 文件中把你希望 DispatcherServlet 處理的請求映射到對應的URL上去。這就是標準的Java EE Servlet配置；下面的代碼就展示了對 DispatcherServlet 和路徑映射的聲明：</p><p>DispatcherServlet</p><p>15</p><p>&lt;web-app> &lt;servlet> &lt;servlet-name>example&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet></p><p>&lt;servlet-mapping> &lt;servlet-name>example&lt;/servlet-name> &lt;url-pattern>/example/*&lt;/url-pattern> &lt;/servlet-mapping>&lt;/web-app></p><p>In the preceding example, all requests starting with /example will be handled by the DispatcherServlet instance named example. In a Servlet 3.0+ environment, you alsohave the option of configuring the Servlet container programmatically. Below is the codebased equivalent of the above web.xml example:</p><p>在上面的例子中，所有路徑以 /example 開頭的請求都會被名字</p><p>為 example 的 DispatcherServlet 處理。在Servlet 3.0+的環境下，你還可以用編程的方式配置Servlet容器。下面是一段這種基於代碼配置的例子，它與上面定義的 web.xml 配置文件是等效的。</p><p>public class MyWebApplicationInitializer implements WebApplicationInitializer {</p><p>@Override public void onStartup(ServletContext container) { ServletRegistration.Dynamic registration = container.addServlet("dispatcher", new DispatcherServlet()); registration.setLoadOnStartup(1); registration.addMapping("/example/*"); }</p><p>}</p><p>WebApplicationInitializer 是Spring MVC提供的一個接口，它會查找你所有基於代碼的配置，並應用它們來初始化Servlet 3版本以上的web容器。它有一個抽象的實現 AbstractDispatcherServletInitializer ，用以簡化 DispatcherServlet 的註冊工作：你只需</p><p>要指定其servlet映射（mapping）即可。若想了解更多細節，可以參考基於代碼的Servlet容器初始化一節。</p><p>上面只是配置Spring Web MVC的第一步，接下來你需要配置其他的一些bean（除了 DispatcherServlet 以外的其他bean），它們也會被Spring Web MVC框架使用到。</p><p>DispatcherServlet</p><p>16</p><p>在6.15 應用上下文ApplicationContext的其他作用)一節中我們聊到，Spring中的 ApplicationContext 實例是可以有範圍（scope）的。在Spring MVC中，每個 DispatcherServlet 都持有一個自己的上下文對象 WebApplicationContext ，它又繼承了根</p><p>（root） WebApplicationContext 對象中已經定義的所有bean。這些繼承的bean可以在具體的Servlet實例中被重載，在每個Servlet實例中你也可以定義其scope下的新bean。</p><p>DispatcherServlet 的初始化過程中，Spring MVC會在你web應用的 WEB-INF 目錄下查找一個名為[servlet-name]-servlet.xml的配置文件，並創建其中所定義的bean。如果在全局上下文中存在相同名字的bean，則它們將被新定義的同名bean覆蓋。</p><p>看看下面這個 DispatcherServlet 的Servlet配置（定義於web.xml文件中）：</p><p>DispatcherServlet</p><p>17</p><p>&lt;web-app> &lt;servlet> &lt;servlet-name>golfing&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>golfing&lt;/servlet-name> &lt;url-pattern>/golfing/*&lt;/url-pattern> &lt;/servlet-mapping>&lt;/web-app></p><p>有了以上的Servlet配置文件，你還需要在應用中的 /WEB-INF/ 路徑下創建一個 golfing-servlet.xml 文件，在該文件中定義所有Spring MVC相關的組件（比如bean等）。你可以通過servlet初始化參數為這個配置文件指定其他的路徑（見下面的例子）：</p><p>當你的應用中只需要一個 DispatcherServlet 時，只配置一個根context對象也是可行的。</p><p>要配置一個唯一的根context對象，可以通過在servlet初始化參數中配置一個空的contextConfigLocation來做到，如下所示：</p><p>DispatcherServlet</p><p>18</p><p>&lt;web-app> &lt;context-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>/WEB-INF/root-context.xml&lt;/param-value> &lt;/context-param> &lt;servlet> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;servlet-class>org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class> &lt;init-param> &lt;param-name>contextConfigLocation&lt;/param-name> &lt;param-value>&lt;/param-value> &lt;/init-param> &lt;load-on-startup>1&lt;/load-on-startup> &lt;/servlet> &lt;servlet-mapping> &lt;servlet-name>dispatcher&lt;/servlet-name> &lt;url-pattern>/*&lt;/url-pattern> &lt;/servlet-mapping> &lt;listener> &lt;listener-class>org.springframework.web.context.ContextLoaderListener&lt;/listener-class> &lt;/listener>&lt;/web-app></p><p>WebApplicationContext 繼承自 ApplicationContext ，它提供了一些web應用經常需要用到的特性。它與普通的 ApplicationContext 不同的地方在於，它支持主題的解析（詳見21.9 主題Themes一小節），並且知道它關聯到的是哪個servlet（它持有一個該 ServletContext 的引用）。 WebApplicationContext 被綁定在 ServletContext 中。如果需要獲取它，你可以通</p><p>過 RequestContextUtils 工具類中的靜態方法來拿到這個web應用的上下文 WebApplicationContext 。</p><p>DispatcherServlet</p><p>19</p><p>21.2.1 WebApplicationContext中特殊的bean類型Spring的 DispatcherServlet 使用了特殊的bean來處理請求、渲染視圖等，這些特定的bean是Spring MVC框架的一部分。如果你想指定使用哪個特定的bean，你可以在web應用上下文 WebApplicationContext 中簡單地配置它們。當然這只是可選的，Spring MVC維護了一個默認的bean列表，如果你沒有進行特別的配置，框架將會使用默認的bean。下一小節會介紹更多的細節，這裡，我們將先快速地看一下， DispatcherServlet 都依賴於哪些特殊的bean來進行它的初始化。</p><p>bean的類型 作用</p><p>HandlerMapping</p><p>處理器映射。它會根據某些規則將進入容器的請求映射到具體的處理器以及一系列前處理器和後處理器（即處理器攔截器）上。具體的規則視 HandlerMapping 類的實現不同而有所不同。其最常用的一個實現支持你在控制器上添加註解，配置請求路徑。當然，也存在其他的實現。</p><p>HandlerAdapter</p><p>處理器適配器。拿到請求所對應的處理器後，適配器將負責去調用該處理器，這使得 DispatcherServlet 無需關心具體的調用細節。比方說，要調用的是一個基於註解配置的控制器，那麼調用前還需要從許多註解中解析出一些相應的信息。因此， HandlerAdapter 的主要任務就是對 DispatcherServlet 屏蔽這些具體的細節。</p><p>HandlerExceptionResolver 處理器異常解析器。它負責將捕獲的異常映射到不同的視圖上去，此外還支持更復雜的異常處理代碼。</p><p>ViewResolver 視圖解析器。它負責將一個代表邏輯視圖名的字符串（String）映射到實際的視圖類型 View 上。</p><p>LocaleResolver & LocaleContextResolver</p><p>地區解析器 和 地區上下文解析器。它們負責解析客戶端所在的地區信息甚至時區信息，為國際化的視圖定製提供了支持。</p><p>ThemeResolver 主題解析器。它負責解析你web應用中可用的主題，比如，提供一些個性化定製的佈局等。</p><p>MultipartResolver 解析multi-part的傳輸請求，比如支持通過HTML表單進行的文件上傳等。</p><p>FlashMapManager FlashMap管理器。它能夠存儲並取回兩次請求之間的 FlashMap 對象。後者可用於在請求之間傳遞數據，通常是在請求重定向的情境下使用。</p><p>WebApplicationContext中特殊的Bean類型</p><p>20</p><p>21.2.2 默認的DispatcherServlet配置上一小節講到， DispatcherServlet 維護了一個列表，其中保存了其所依賴的所有bean的默認實現。這個列表保存在包 org.springframework.web.servlet 下</p><p>的 DispatcherServlet.properties 文件中。</p><p>這些特殊的bean都有一些基本的默認行為。或早或晚，你可能需要對它們提供的一些默認配置進行定製。比如說，通常你需要配置 InternalResourceViewResolver 類提供的 prefix 屬</p><p>性，使其指向視圖文件所在的目錄。 這裡需要理解的一個事情是，一旦你在web應用上下文 WebApplicationContext 中配置了某個特殊bean以後（比如 InternalResourceViewResolver ），實際上你也覆寫了該bean的默認實現。比方說，如果你配置了 InternalResourceViewResolver ，那麼框架就不會再使用bean ViewResolver 的默認實現。</p><p>在21.16節 Spring MVC的配置中，我們介紹了其他配置Spring MVC的方式，比如通過Java編程配置或者通過MVC XML命名空間進行配置。它們為配置一個Spring MVC應用提供了簡易的開始方式，也不需要你對框架實現細節有太多瞭解。當然，無論你選用何種方式開始配</p><p>置，本節所介紹的一些概念都是基礎且普適的，它們對你後續的學習都應有所助益。</p><p>默認的DispatcherServlet配置</p><p>21</p><p>21.2.3 DispatcherServlet的處理流程配置好 DispatcherServlet 以後，開始有請求會經過這個 DispatcherServlet 。此</p><p>時， DispatcherServlet 會依照以下的次序對請求進行處理：</p><p>首先，搜索應用的上下文對象 WebApplicationContext 並把它作為一個屬性（attribute）綁定到該請求上，以便控制器和其他組件能夠使用它。屬性的鍵名默認</p><p>為 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE</p><p>將地區（locale）解析器綁定到請求上，以便其他組件在處理請求（渲染視圖、準備數據等）時可以獲取區域相關的信息。如果你的應用不需要解析區域相關的信息，忽略它即</p><p>可</p><p>將主題（theme）解析器綁定到請求上，以便其他組件（比如視圖等）能夠了解要渲染哪個主題文件。同樣，如果你不需要使用主題相關的特性，忽略它即可</p><p>如果你配置了multipart文件處理器，那麼框架將查找該文件是不是multipart（分為多個部分連續上傳）的。若是，則將該請求包裝成一個 MultipartHttpServletRequest 對象，以</p><p>便處理鏈中的其他組件對它做進一步的處理。關於Spring對multipart文件傳輸處理的支持，讀者可以參考21.10 Spring的multipart（文件上傳）支持一小節為該請求查找一個合適的處理器。如果可以找到對應的處理器，則與該處理器關聯的整</p><p>條執行鏈（前處理器、後處理器、控制器等）都會被執行，以完成相應模型的準備或視</p><p>圖的渲染</p><p>如果處理器返回的是一個模型（model），那麼框架將渲染相應的視圖。若沒有返回任何模型（可能是因為前後的處理器出於某些原因攔截了請求等，比如，安全問題），則框</p><p>架不會渲染任何視圖，此時認為對請求的處理可能已經由處理鏈完成了</p><p>如果在處理請求的過程中拋出了異常，那麼上下文 WebApplicationContext 對象中所定義的異</p><p>常處理器將會負責捕獲這些異常。通過配置你自己的異常處理器，你可以定製自己處理異常</p><p>的方式。</p><p>Spring的 DispatcherServlet 也允許處理器返回一個Servlet API規範中定義的 最後修改時間戳（last-modification-date） 值。決定請求最後修改時間的方式很直接： DispatcherServlet 會先查找合適的處理器映射來找到請求對應的處理器，然後檢測它是否實現了 LastModified 接口。若是，則調用接口的 long getLastModified(request) 方法，並將該返回值返回給客戶端。</p><p>你可以定製 DispatcherServlet 的配置，具體的做法，是在 web.xml 文件中，Servlet的聲明元素上添加一些Servlet的初始化參數（通過 init-param 元素）。該元素可選的參數列表如下：</p><p>DispatcherServlet的處理流程</p><p>22</p><p>可選參數 解釋</p><p>contextClass 任意實現了 WebApplicationContext 接口的類。這個類會初始化該servlet所需要用到的上下文對象。默認情況下，框架會使用一個 XmlWebApplicationContext 對象。</p><p>contextConfigLocation</p><p>一個指定了上下文配置文件路徑的字符串，該值會被傳入給 contextClass 所指定的上下文實例對象。該字符串內可以包含多個字符串，字符串之間以逗號分隔，以此支持你進行多個上下文的配置。在多個上下文中重複定義的bean，以最後加載的bean定義為準</p><p>namespace WebApplicationContext 的命名空間。默認是 [servlet-name]-servlet</p><p>DispatcherServlet的處理流程</p><p>23</p><p>21.3 控制器(Controller)的實現...Spring implements a controller in a very abstract way, which enables you to create awide variety of controllers.</p><p>控制器作為應用程序邏輯的處理入口，它會負責去調用你已經實現的一些服務。通常，一個</p><p>控制器會接收並解析用戶的請求，然後把它轉換成一個模型交給視圖，由視圖渲染出頁面最</p><p>終呈現給用戶。Spring對控制器的定義非常寬鬆，這意味著你在實現控制器時非常自由。</p><p>Spring 2.5以後引入了基於註解的編程模型，你可以在你的控制器實現上添加 @RequestMapping 、 @RequestParam 、 @ModelAttribute 等註解。註解特性既支持基於</p><p>Servlet的MVC，也可支持基於Portlet的MVC。通過此種方式實現的控制器既無需繼承某個特定的基類，也無需實現某些特定的接口。而且，它通常也不會直接依賴於Servlet或Portlet的API來進行編程，不過你仍然可以很容易地獲取Servlet或Portlet相關的變量、特性和設施等。</p><p>在Spring項目的官方Github上你可以找到許多項目，它們對本節所述以後的註解支持提供了進一步增強，比如說MvcShowcase，MvcAjax，MvcBasic，PetClinic，PetCare等。</p><p>@Controllerpublic class HelloWorldController {</p><p>@RequestMapping("/helloWorld") public String helloWorld(Model model) { model.addAttribute("message", "Hello World!"); return "helloWorld"; }}</p><p>你可以看到， @Controller 註解和 @RequestMapping 註解支持多樣的方法名和方法簽名。在上</p><p>面這個例子中，方法接受一個 Model 類型的參數並返回一個字符串 String 類型的視圖名。但</p><p>事實上，方法所支持的參數和返回值有非常多的選擇，這個我們在本小節的後面部分會提</p><p>及。 @Controller 和 @RequestMapping 及其他的一些註解，共同構成了Spring MVC框架的基本實現。本節將詳細地介紹這些註解，以及它們在一個Servlet環境下最常被使用到的一些場景。</p><p>控制器的實現</p><p>24</p><p>21.3.1 使用@Controller註解定義一個控制器[Original] The @Controller annotation indicates that a particular class serves the roleof a controller. Spring does not require you to extend any controller base class orreference the Servlet API. However, you can still reference Servlet-specific features ifyou need to.</p><p>@Controller 註解表明了一個類是作為控制器的角色而存在的。Spring不要求你去繼承任何控制器基類，也不要求你去實現Servlet的那套API。當然，如果你需要的話也可以去使用任何與Servlet相關的特性和設施。</p><p>[Original] The @Controller annotation acts as a stereotype for the annotated class,indicating its role. The dispatcher scans such annotated classes for mapped methodsand detects @RequestMapping annotations (see the next section).</p><p>@Controller 註解可以認為是被標註類的原型（stereotype），表明了這個類所承擔的角色。分派器（ DispatcherServlet ）會掃描所有註解了 @Controller 的類，檢測其中通</p><p>過 @RequestMapping 註解配置的方法（詳見下一小節）。</p><p>[Original] You can define annotated controller beans explicitly, using a standard Springbean definition in the dispatcher's context. However, the @Controller stereotype alsoallows for autodetection, aligned with Spring general support for detecting componentclasses in the classpath and auto-registering bean definitions for them.</p><p>當然，你也可以不使用 @Controller 註解而顯式地去定義被註解的bean，這點通過標準的Spring bean的定義方式，在dispather的上下文屬性下配置即可做到。但是 @Controller 原型是可以被框架自動檢測的，Spring支持classpath路徑下組件類的自動檢測，以及對已定義bean的自動註冊。</p><p>[Original] To enable autodetection of such annotated controllers, you add componentscanning to your configuration. Use the spring-context schema as shown in thefollowing XML snippet:</p><p>你需要在配置中加入組件掃描的配置代碼來開啟框架對註解控制器的自動檢測。請使用下面</p><p>XML代碼所示的spring-context schema：</p><p>使用@Controller註解定義一個控制器</p><p>25</p><p>&lt;?xml version="1.0" encoding="UTF-8"?>&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"></p><p>&lt;context:component-scan base-package="org.springframework.samples.petclinic.web"/></p><p>&lt;!-- ... --></p><p>&lt;/beans></p><p>使用@Controller註解定義一個控制器</p><p>26</p><p>21.3.2 使用@RequestMapping註解映射請求路徑</p><p>你可以使用 @RequestMapping 註解來將請求URL，如 /appointments 等，映射到整個類上或某個特定的處理器方法上。一般來說，類級別的註解負責將一個特定（或符合某種模式）的請</p><p>求路徑映射到一個控制器上，同時通過方法級別的註解來細化映射，即根據特定的HTTP請求方法（"GET""POST"方法等）、HTTP請求中是否攜帶特定參數等條件，將請求映射到匹配的方法上。</p><p>下面這段代碼示例來自Petcare，它展示了在Spring MVC中如何在控制器上使用 @RequestMapping 註解：</p><p>使用@RequestMapping註解映射請求路徑</p><p>27</p><p>@Controller@RequestMapping("/appointments")public class AppointmentsController {</p><p>private final AppointmentBook appointmentBook;</p><p>@Autowired public AppointmentsController(AppointmentBook appointmentBook) { this.appointmentBook = appointmentBook; }</p><p>@RequestMapping(method = RequestMethod.GET) public Map&lt;String, Appointment> get() { return appointmentBook.getAppointmentsForToday(); }</p><p>@RequestMapping(path = "/{day}", method = RequestMethod.GET) public Map&lt;String, Appointment> getForDay(@PathVariable @DateTimeFormat(iso=ISO.DATE) Date day, Model model) { return appointmentBook.getAppointmentsForDay(day); }</p><p>@RequestMapping(path = "/new", method = RequestMethod.GET) public AppointmentForm getNewForm() { return new AppointmentForm(); }</p><p>@RequestMapping(method = RequestMethod.POST) public String add(@Valid AppointmentForm appointment, BindingResult result) { if (result.hasErrors()) { return "appointments/new"; } appointmentBook.addAppointment(appointment); return "redirect:/appointments"; }}</p><p>在上面的示例中，許多地方都使用到了 @RequestMapping 註解。第一次使用點是作用於類級別</p><p>的，它指示了所有 /appointments 開頭的路徑都會被映射到控制器下。 get() 方法上</p><p>的 @RequestMapping 註解對請求路徑進行了進一步細化：它僅接受GET方法的請求。這樣，一個請求路徑為 /appointments 、HTTP方法為GET的請求，將會最終進入到這個方法被處理。 add() 方法也做了類似的細化，而 getNewForm() 方法則同時註解了能夠接受的請求的</p><p>HTTP方法和路徑。這種情況下，一個路徑為 appointments/new 、HTTP方法為GET的請求將會被這個方法所處理。</p><p>getForDay() 方法則展示了使用 @RequestMapping 註解的另一個技巧：URI模板。（關於URI模板，請見下小節）</p><p>使用@RequestMapping註解映射請求路徑</p><p>28</p><p>類級別的 @RequestMapping 註解並不是必須的。不配置的話則所有的路徑都是絕對路徑，而非</p><p>相對路徑。以下的代碼示例來自PetClinic，它展示了一個具有多個處理器方法的控制器：</p><p>@Controllerpublic class ClinicController {</p><p>private final Clinic clinic;</p><p>@Autowired public ClinicController(Clinic clinic) { this.clinic = clinic; }</p><p>@RequestMapping("/") public void welcomeHandler() { }</p><p>@RequestMapping("/vets") public ModelMap vetsHandler() { return new ModelMap(this.clinic.getVets()); }}</p><p>以上代碼沒有指定請求必須是GET方法還是PUT/POST或其他方法， @RequestMapping 註解默認會映射所有的HTTP請求方法。如果僅想接收某種請求方法，請在註解中指定之 @RequestMapping(method=GET) 以縮小範圍。</p><p>@Controller和麵向切面（AOP）代理有時，我們希望在運行時使用AOP代理來裝飾控制器，比如當你直接在控制器上使用 @Transactional 註解時。這種情況下，我們推薦使用類級別（在控制器上使用）的代理方</p><p>式。這一般是代理控制器的默認做法。如果控制器必須實現一些接口，而該接口又不支持</p><p>Spring Context的回調（比如 InitializingBean , *Aware 等接口），那要配置類級別的代理就必須手動配置了。比如，原來的配置文件 &lt;tx:annotation-driven/> 需要顯式配置</p><p>為 &lt;tx:annotation-driven proxy-target-class="true"/> 。</p><p>Spring MVC 3.1中新增支持@RequestMapping的一些類</p><p>They are recommended for use and even required to take advantage of new features inSpring MVC 3.1 and going forward.</p><p>使用@RequestMapping註解映射請求路徑</p><p>29</p><p>Spring 3.1中新增了一組類用以增強 @RequestMapping ，分別是 RequestMappingHandlerMapping 和 RequestMappingHandlerAdapter 。我們推薦你用一用。有</p><p>部分Spring MVC 3.1之後新增的特性，這兩個註解甚至是必須的。在MVC命名空間和MVCJava編程配置方式下，這組類及其新特性默認是開啟的。但若你使用其他配置方式，則該特性必須手動配置才能使用。本小節將簡要介紹一下，新類相比之前的一些重要變化。</p><p>在Spring 3.1之前，框架會在兩個不同的階段分別檢查類級別和方法級別的請求映射&amp;mdash;&amp;mdash;首先， DefaultAnnotationHanlderMapping 會先在類級別上選中一個控制器，然後再通</p><p>過 AnnotationMethodHandlerAdapter 定位到具體要調用的方法。</p><p>[Original] With the new support classes in Spring 3.1, the RequestMappingHandlerMapping is the only place where a decision is made about whichmethod should process the request. Think of controller methods as a collection ofunique endpoints with mappings for each method derived from type and method-level @RequestMapping information.</p><p>現在有了Spring 3.1後引入的這組新類， RequestMappingHandlerMapping 成為了這兩個決策實際發生的唯一一個地方。你可以把控制器中的一系列處理方法當成是一系列獨立的服務節</p><p>點，每個從類級別和方法級別的 @RequestMapping 註解中獲取到足夠請求1路徑映射信息。</p><p>[Original] This enables some new possibilities. For once a HandlerInterceptor or a HandlerExceptionResolver can now expect the Object-based handler to be a HandlerMethod , which allows them to examine the exact method, its parameters andassociated annotations. The processing for a URL no longer needs to be split acrossdifferent controllers.</p><p>這種新的處理方式帶來了新的可能性。之前</p><p>的 HandlerInterceptor 或 HandlerExceptionResolver 現在可以確定拿到的這個處理器肯定是一</p><p>個 HandlerMethod 類型，因此它能夠精確地瞭解這個方法的所有信息，包括它的參數、應用於</p><p>其上的註解等。這樣，內部對於一個URL的處理流程再也不需要分隔到不同的控制器裡面去執行了。</p><p>[Original] There are also several things no longer possible: [Original] Select a controllerfirst with a SimpleUrlHandlerMapping or BeanNameUrlHandlerMapping and then narrow themethod based on @RequestMapping annotations. [Original] Rely on method names as afall-back mechanism to disambiguate between two @RequestMapping methods that don'thave an explicit path mapping URL path but otherwise match equally, e.g. by HTTPmethod. In the new support classes @RequestMapping methods have to be mappeduniquely. [Original] * Have a single default method (without an explicit path mapping)with which requests are processed if no other controller method matches moreconcretely. In the new support classes if a matching method is not found a 404 error israised.</p><p>同時，也有其他的一些變化，比如有些事情就沒法這麼玩兒了：</p><p>使用@RequestMapping註解映射請求路徑</p><p>30</p><p>先通過 SimpleUrlHandlerMapping 或 BeanNameUrlHandlerMapping 來拿到負責處理請求的控</p><p>制器，然後通過 @RequestMapping 註解配置的信息來定位到具體的處理方法；</p><p>依靠方法名稱來作為選擇處理方法的標準。比如說，兩個註解了 @RequestMapping 的方法</p><p>除了方法名稱擁有完全相同的URL映射和HTTP請求方法。在新版本下， @RequestMapping 註解的方法必須具有唯一的請求映射；</p><p>定義一個默認方法（即沒有聲明路徑映射），在請求路徑無法被映射到控制器下更精確</p><p>的方法上去時，為該請求提供默認處理。在新版本中，如果無法為一個請求找到合適的</p><p>處理方法，那麼一個404錯誤將被拋出；</p><p>[Original] The above features are still supported with the existing support classes.However to take advantage of new Spring MVC 3.1 features you'll need to use the newsupport classes.</p><p>如果使用原來的類，以上的功能還是可以做到。但是，如果要享受Spring MVC 3.1版本帶來的方便特性，你就需要去使用新的類。</p><p>[Original] ## URI Template Patterns</p><p>URI模板[Original] URI templates can be used for convenient access to selected parts of a URLin a @RequestMapping method.</p><p>URI模板可以為快速訪問 @RequestMapping 中指定的URL的一個特定的部分提供很大的便利。</p><p>[Original] A URI Template is a URI-like string, containing one or more variable names.When you substitute values for these variables, the template becomes a URI. Theproposed RFC for URI Templates defines how a URI is parameterized. For example,the URI Template http://www.example.com/users/{userId} contains the variable userId.Assigning the value fred to the variable yields http://www.example.com/users/fred .</p><p>URI模板是一個類似於URI的字符串，只不過其中包含了一個或多個的變量名。當你使用實際的值去填充這些變量名的時候，模板就退化成了一個URI。在URI模板的RFC提議中定義了一個URI是如何進行參數化的。比如說，一個這個URI模板 http://www.example.com/users/{userId} 就包含了一個變量名userId。將值fred賦給這個變量名後，它就變成了一個URI： http://www.example.com/users/fred 。</p><p>[Original] In Spring MVC you can use the @PathVariable annotation on a methodargument to bind it to the value of a URI template variable:</p><p>在Spring MVC中你可以在方法參數上使用 @PathVariable 註解，將其與URI模板中的參數綁定起來：</p><p>使用@RequestMapping註解映射請求路徑</p><p>31</p><p>@RequestMapping(path="/owners/{ownerId}", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) { Owner owner = ownerService.findOwner(ownerId); model.addAttribute("owner", owner); return "displayOwner";}</p><p>[Original] The URI Template " /owners/{ownerId} " specifies the variable name ownerId . When the controller handles this request, the value of ownerId is set to thevalue found in the appropriate part of the URI. For example, when a request comes infor /owners/fred , the value of ownerId is fred .</p><p>URI模板" /owners/{ownerId} "指定了一個變量，名為 ownerId 。當控制器處理這個請求的時候， ownerId 的值就會被URI模板中對應部分的值所填充。比如說，如果請求的URI是 /owners/fred ，此時變量 ownerId 的值就是 fred . `</p><p>為了處理 @PathVariables 註解，Spring MVC必須通過變量名來找到URI模板中相對應的變量。你可以在註解中直接聲明：</p><p>@RequestMapping(path="/owners/{ownerId}}", method=RequestMethod.GET)public String findOwner(@PathVariable("ownerId") String theOwner, Model model) { // 具體的方法代碼…}</p><p>或者，如果URI模板中的變量名與方法的參數名是相同的，則你可以不必再指定一次。只要你在編譯的時候留下debug信息，Spring MVC就可以自動匹配URL模板中與方法參數名相同的變量名。</p><p>@RequestMapping(path="/owners/{ownerId}", method=RequestMethod.GET)public String findOwner(@PathVariable String ownerId, Model model) { // 具體的方法代碼…}</p><p>[Original] A method can have any number of @PathVariable annotations:</p><p>一個方法可以擁有任意數量的 @PathVariable 註解：</p><p>@RequestMapping(path="/owners/{ownerId}/pets/{petId}", method=RequestMethod.GET)public String findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) { Owner owner = ownerService.findOwner(ownerId); Pet pet = owner.getPet(petId); model.addAttribute("pet", pet); return "displayPet";}</p><p>使用@RequestMapping註解映射請求路徑</p><p>32</p><p>[Original] When a @PathVariable annotation is used on a Map&lt;String, String> argument, the map is populated with all URI template variables.</p><p>當 @PathVariable 註解被應用於 Map&lt;String, String> 類型的參數上時，框架會使用所有URI模板變量來填充這個map。</p><p>[Original] A URI template can be assembled from type and path level@RequestMapping annotations. As a result the findPet() method can be invokedwith a URL such as /owners/42/pets/21 .</p><p>URI模板可以從類級別和方法級別的 @RequestMapping 註解獲取數據。因此，像這樣的 findPet() 方法可以被類似於 /owners/42/pets/21 這樣的URL路由並調用到：</p><p>_@Controller_@RequestMapping("/owners/{ownerId}")public class RelativePathUriTemplateController {</p><p>@RequestMapping("/pets/{petId}") public void findPet(_@PathVariable_ String ownerId, _@PathVariable_ String petId, Model model) { // 方法實現體這裡忽略 }</p><p>}</p><p>[Original] A @PathVariable argument can be of any simple type such as int, long, Date,etc. Spring automatically converts to the appropriate type or throws a TypeMismatchException if it fails to do so. You can also register support for parsingadditional data types. See the section called "Method Parameters And TypeConversion" and the section called "Customizing WebDataBinder initialization".</p><p>@PathVariable 可以被應用於所有 簡單類型 的參數上，比如int、long、Date等類型。Spring會自動地幫你把參數轉化成合適的類型，如果轉換失敗，就拋出一</p><p>個 TypeMismatchException 。如果你需要處理其他數據類型的轉換，也可以註冊自己的類。若</p><p>需要更詳細的信息可以參考"方法參數與類型轉換"一節和"定製WebDataBinder初始化過程"一節</p><p>帶正則表達式的URI模板[Original] Sometimes you need more precision in defining URI template variables.Consider the URL "/spring-web/spring-web-3.0.5.jar" . How do you break it down intomultiple parts?</p><p>使用@RequestMapping註解映射請求路徑</p><p>33</p><p>有時候你可能需要更準確地描述一個URI模板的變量，比如說這個URL： "/spring-web/spring-web-3.0.5.jar 。你要怎麼把它分解成幾個有意義的部分呢？</p><p>[Original] The @RequestMapping annotation supports the use of regular expressions inURI template variables. The syntax is {varName:regex} where the first part defines thevariable name and the second - the regular expression.For example:</p><p>@RequestMapping 註解支持你在URI模板變量中使用正則表達式。語法是 {varName:regex} ，其中第一部分定義了變量名，第二部分就是你所要應用的正則表達式。比如下面的代碼樣</p><p>例：</p><p>@RequestMapping("/spring-web/{symbolicName:[a-z-]+}-{version:\\d\\.\\d\\.\\d}{extension:\\.[a-z]+}") public void handle(@PathVariable String version, @PathVariable String extension) { // 代碼部分省略... }}</p><p>Path Patterns（不好翻，容易掉韻味）[Original] In addition to URI templates, the @RequestMapping annotation also supportsAnt-style path patterns (for example, /myPath/*.do ). A combination of URI templatevariables and Ant-style globs is also supported (e.g. /owners/*/pets/{petId} ).</p><p>除了URI模板外， @RequestMapping 註解還支持Ant風格的路徑模式（如 /myPath/*.do 等）。不僅如此，還可以把URI模板變量和Ant風格的glob組合起來使用（比如 /owners/*/pets/{petId} 這樣的用法等）。</p><p>路徑樣式的匹配(Path Pattern Comparison)[Original] When a URL matches multiple patterns, a sort is used to find the mostspecific match.</p><p>當一個URL同時匹配多個模板（pattern）時，我們將需要一個算法來決定其中最匹配的一個。</p><p>[Original] A pattern with a lower count of URI variables and wild cards is consideredmore specific. For example /hotels/{hotel}/* has 1 URI variable and 1 wild card andis considered more specific than /hotels/{hotel}/** which as 1 URI variable and 2wild cards.</p><p>使用@RequestMapping註解映射請求路徑</p><p>34</p><p>URI模板變量的數目和通配符數量的總和最少的那個路徑模板更準確。舉個例子， /hotels/{hotel}/* 這個路徑擁有一個URI變量和一個通配符，而 /hotels/{hotel}/** 這個路徑則擁有一個URI變量和兩個通配符，因此，我們認為前者是更準確的路徑模板。</p><p>[Original] If two patterns have the same count, the one that is longer is considered morespecific. For example /foo/bar* is longer and considered more specific than /foo/* .</p><p>如果兩個模板的URI模板數量和通配符數量總和一致，則路徑更長的那個模板更準確。舉個例子， /foo/bar* 就被認為比 /foo/* 更準確，因為前者的路徑更長。</p><p>[Original] When two patterns have the same count and length, the pattern with fewerwild cards is considered more specific. For example /hotels/{hotel} is more specificthan /hotels/* .</p><p>如果兩個模板的數量和長度均一致，則那個具有更少通配符的模板是更加準確的。比</p><p>如， /hotels/{hotel} 就比 /hotels/* 更精確。</p><p>[Original] There are also some additional special rules:</p><p>除此之外，還有一些其他的規則：</p><p>[Original] The default mapping pattern `/* is less specific than any other pattern.For example /api/{a}/{b}/{c}` is more specific.</p><p>[Original] A prefix pattern such as `/public/* is less specific than any other patternthat doesn't contain double wildcards. For example /public/path3/{a}/{b}/{c}` is morespecific.</p><p>默認的通配模式 /** 比其他所有的模式都更"不準確"。比方說， /api/{a}/{b}/{c} 就比默認的通配模式 /** 要更準確</p><p>前綴通配（比如 /public/** )被認為比其他任何不包括雙通配符的模式更不準確。比如說， /public/path3/{a}/{b}/{c} 就比 /public/** 更準確</p><p>[Original] For the full details see AntPatternComparator in AntPathMatcher . Note thatthe PathMatcher can be customized (see Section 21.16.11, "Path Matching" in thesection on configuring Spring MVC).</p><p>更多的細節請參考這兩個類： AntPatternComparator 和 AntPathMatcher 。值得一提的是，</p><p>PathMatcher類是可以配置的（見"配置Spring MVC"一節中的21.16.11 路徑的匹配一節)。</p><p>帶佔位符的路徑模式（path patterns）</p><p>使用@RequestMapping註解映射請求路徑</p><p>35</p><p>[Original] Patterns in @RequestMapping annotations support ${…} placeholders againstlocal properties and/or system properties and environment variables. This may beuseful in cases where the path a controller is mapped to may need to be customizedthrough configuration. For more information on placeholders, see the javadocs of the PropertyPlaceholderConfigurer class.</p><p>@RequestMapping 註解支持在路徑中使用佔位符，以取得一些本地配置、系統配置、環境變量</p><p>等。這個特性有時很有用，比如說控制器的映射路徑需要通過配置來定製的場景。如果想了</p><p>解更多關於佔位符的信息，可以參考 PropertyPlaceholderConfigurer 這個類的文檔。</p><p>Suffix Pattern Matching</p><p>後綴模式匹配</p><p>[Original] By default Spring MVC performs ".*" suffix pattern matching so that acontroller mapped to /person is also implicitly mapped to /person.* . This makes iteasy to request different representations of a resource through the URL path (e.g. /person.pdf , /person.xml ).</p><p>Spring MVC默認採用 ".*" 的後綴模式匹配來進行路徑匹配，因此，一個映射到 /person 路徑的控制器也會隱式地被映射到 /person.* 。這使得通過URL來請求同一資源文件的不同格式變得更簡單（比如 /person.pdf ， /person.xml ）。</p><p>[Original] Suffix pattern matching can be turned off or restricted to a set of pathextensions explicitly registered for content negotiation purposes. This is generallyrecommended to minimize ambiguity with common request mappings such as /person/{id} where a dot might not represent a file extension, e.g. /person/joe@email.com vs /person/joe@email.com.json) . Furthermore as explained inthe note below suffix pattern matching as well as content negotiation may be used insome circumstances to attempt malicious attacks and there are good reasons to restrictthem meaningfully.</p><p>你可以關閉默認的後綴模式匹配，或者顯式地將路徑後綴限定到一些特定格式上for contentnegotiation purpose。我們推薦這樣做，這樣可以減少映射請求時可以帶來的一些二義性，比如請求以下路徑 /person/{id} 時，路徑中的點號後面帶的可能不是描述內容格式，比</p><p>如 /person/joe@email.com vs /person/joe@email.com.json 。而且正如下面馬上要提到的，後綴模式通配以及內容協商有時可能會被黑客用來進行攻擊，因此，對後綴通配進行有意義的</p><p>限定是有好處的。</p><p>使用@RequestMapping註解映射請求路徑</p><p>36</p><p>[Original] See Section 21.16.11, "Path Matching" for suffix pattern matchingconfiguration and also Section 21.16.6, "Content Negotiation" for content negotiationconfiguration.</p><p>關於後綴模式匹配的配置問題，可以參考第21.16.11小節 "路徑匹配"；關於內容協商的配置問題，可以參考第21.16.6小節 "內容協商"的內容。</p><p>後綴模式匹配與RFD[Original] Reflected file download (RFD) attack was first described in a paper byTrustwave in 2014. The attack is similar to XSS in that it relies on input (e.g. queryparameter, URI variable) being reflected in the response. However instead of insertingJavaScript into HTML, an RFD attack relies on the browser switching to perform adownload and treating the response as an executable script if double-clicked based onthe file extension (e.g. .bat, .cmd).</p><p>RFD(Reflected file download)攻擊最先是2014年在Trustwave的一篇論文中被提出的。它與XSS攻擊有些相似，因為這種攻擊方式也依賴於某些特徵，即需要你的輸入（比如查詢參數，URI變量等）等也在輸出（response）中以某種形式出現。不同的是，RFD攻擊並不是通過在HTML中寫入JavaScript代碼進行，而是依賴於瀏覽器來跳轉到下載頁面，並把特定格式（比如.bat，.cmd等）的response當成是可執行腳本，雙擊它就會執行。</p><p>[Original] In Spring MVC @ResponseBody and ResponseEntity methods are at riskbecause they can render different content types which clients can request including viaURL path extensions. Note however that neither disabling suffix pattern matching nordisabling the use of path extensions for content negotiation purposes alone areeffective at preventing RFD attacks.</p><p>Spring MVC的 @ResponseBody 和 ResponseEntity 方法是有風險的，因為它們會根據客戶的請求&amp;mdash;&amp;mdash;包括URL的路徑後綴，來渲染不同的內容類型。因此，禁用後綴模式匹配或者禁用僅為內容協商開啟的路徑文件後綴名攜帶，都是防範RFD攻擊的有效方式。</p><p>[Original] For comprehensive protection against RFD, prior to rendering the responsebody Spring MVC adds a Content-Disposition:inline;filename=f.txt header tosuggest a fixed and safe download file filename. This is done only if the URL pathcontains a file extension that is neither whitelisted nor explicitly registered for contentnegotiation purposes. However it may potentially have side effects when URLs aretyped directly into a browser.</p><p>若要開啟對RFD更高級的保護模式，可以在Spring MVC渲染開始請求正文之前，在請求頭中增加一行配置 Content-Disposition:inline;filename=f.txt ，指定固定的下載文件的文件名。</p><p>這僅在URL路徑中包含了一個文件符合以下特徵的拓展名時適用：該擴展名既不在信任列表</p><p>使用@RequestMapping註解映射請求路徑</p><p>37</p><p>（白名單）中，也沒有被顯式地被註冊於內容協商時使用。並且這種做法還可以有一些副作</p><p>用，比如，當URL是通過瀏覽器手動輸入的時候。</p><p>[Original] Many common path extensions are whitelisted by default. Furthermore RESTAPI calls are typically not meant to be used as URLs directly in browsers. Neverthelessapplications that use custom HttpMessageConverter implementations can explicitlyregister file extensions for content negotiation and the Content-Disposition header willnot be added for such extensions. See Section 21.16.6, "Content Negotiation".</p><p>很多常用的路徑文件後綴默認是被信任的。另外，REST的API一般是不應該直接用做URL的。不過，你可以自己定製 HttpMessageConverter 的實現，然後顯式地註冊用於內容協商的文</p><p>件類型，這種情形下Content-Disposition頭將不會被加入到請求頭中。詳見第21.16.6節中"內容協商"的內容。</p><p>[Original] This was originally introduced as part of work for CVE-2015-5211. Below areadditional recommendations from the report:</p><p>Encode rather than escape JSON responses. This is also an OWASP XSSrecommendation. For an example of how to do that with Spring see spring-jackson-owasp.Configure suffix pattern matching to be turned off or restricted to explicitlyregistered suffixes only.Configure content negotiation with the properties "useJaf" and"ignoreUnknownPathExtensions" set to false which would result in a 406 responsefor URLs with unknown extensions. Note however that this may not be an option ifURLs are naturally expected to have a dot towards the end.Add X-Content-Type-Options: nosniff header to responses. Spring Security 4does this by default.</p><p>感覺這節的翻譯質量還有限，需要繼續瞭解XSS攻擊和RFD攻擊的細節再翻。</p><p>矩陣變量</p><p>[Original] The URI specification RFC 3986 defines the possibility of including name-value pairs within path segments. There is no specific term used in the spec. Thegeneral "URI path parameters" could be applied although the more unique "MatrixURIs", originating from an old post by Tim Berners-Lee, is also frequently used andfairly well known. Within Spring MVC these are referred to as matrix variables.</p><p>原來的URI規範RFC 3986中允許在路徑段落中攜帶鍵值對，但規範沒有明確給這樣的鍵值對定義術語。有人叫"URI路徑參數"，也有叫"矩陣URI"的。後者是Tim Berners-Lee首先在其博客中提到的術語，被使用得要更加頻繁一些，知名度也更高些。而在Spring MVC中，我們稱</p><p>使用@RequestMapping註解映射請求路徑</p><p>38</p><p>這樣的鍵值對為矩陣變量。</p><p>[Original] Matrix variables can appear in any path segment, each matrix variableseparated with a ";" (semicolon). For example: "/cars;color=red;year=2012" . Multiplevalues may be either "," (comma) separated "color=red,green,blue" or the variablename may be repeated "color=red;color=green;color=blue" .</p><p>矩陣變量可以在任何路徑段落中出現，每對矩陣變量之間使用一個分號";"隔開。比如這樣的URI： "/cars;color=red;year=2012" 。多個值可以用逗號隔開 "color=red,green,blue" ，或者重複變量名多次 "color=red;color=green;color=blue" 。</p><p>[Original] If a URL is expected to contain matrix variables, the request mapping patternmust represent them with a URI template. This ensures the request can be matchedcorrectly regardless of whether matrix variables are present or not and in what orderthey are provided.</p><p>如果一個URL有可能需要包含矩陣變量，那麼在請求路徑的映射配置上就需要使用URI模板來體現這一點。這樣才能確保請求可以被正確地映射，而不管矩陣變量在URI中是否出現、出現的次序是怎樣等。</p><p>[Original] Below is an example of extracting the matrix variable "q":</p><p>下面是一個例子，展示了我們如何從矩陣變量中獲取到變量"q"的值：</p><p>// GET /pets/42;q=11;r=22</p><p>@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET)public void findPet(@PathVariable String petId, @MatrixVariable int q) {</p><p>// petId == 42 // q == 11</p><p>}</p><p>[Original] Since all path segments may contain matrix variables, in some cases youneed to be more specific to identify where the variable is expected to be:</p><p>由於任意路徑段落中都可以含有矩陣變量，在某些場景下，你需要用更精確的信息來指定一</p><p>個矩陣變量的位置：</p><p>使用@RequestMapping註解映射請求路徑</p><p>39</p><p>// GET /owners/42;q=11/pets/21;q=22</p><p>@RequestMapping(path = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)public void findPet( @MatrixVariable(name="q", pathVar="ownerId") int q1, @MatrixVariable(name="q", pathVar="petId") int q2) {</p><p>// q1 == 11 // q2 == 22</p><p>}</p><p>[Original] A matrix variable may be defined as optional and a default value specified:</p><p>你也可以聲明一個矩陣變量不是必須出現的，並給它賦一個默認值：</p><p>// GET /pets/42</p><p>@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET)public void findPet(@MatrixVariable(required=false, defaultValue="1") int q) {</p><p>// q == 1</p><p>}</p><p>[Original] All matrix variables may be obtained in a Map:</p><p>也可以通過一個Map來存儲所有的矩陣變量：</p><p>// GET /owners/42;q=11;r=12/pets/21;q=22;s=23</p><p>@RequestMapping(path = "/owners/{ownerId}/pets/{petId}", method = RequestMethod.GET)public void findPet( @MatrixVariable Map&lt;String, String> matrixVars, @MatrixVariable(pathVar="petId") Map&lt;String, String> petMatrixVars) {</p><p>// matrixVars: ["q" : [11,22], "r" : 12, "s" : 23] // petMatrixVars: ["q" : 11, "s" : 23]</p><p>}</p><p>[Original] Note that to enable the use of matrix variables, you must set the removeSemicolonContent property of RequestMappingHandlerMapping to false . Bydefault it is set to true .</p><p>如果要允許矩陣變量的使用，你必須把 RequestMappingHandlerMapping 類</p><p>的 removeSemicolonContent 屬性設置為 false 。該值默認是 true 的。</p><p>使用@RequestMapping註解映射請求路徑</p><p>40</p><p>[Original] The MVC Java config and the MVC namespace both provide options forenabling the use of matrix variables.</p><p>MVC的Java編程配置和命名空間配置都提供了啟用矩陣變量的方式。</p><p>[Original] If you are using Java config, The Advanced Customizations with MVC JavaConfig section describes how the RequestMappingHandlerMapping can be customized.</p><p>如果你是使用Java編程的方式，"MVC Java高級定製化配置"一節描述瞭如何對 RequestMappingHandlerMapping 進行定製。</p><p>[Original] In the MVC namespace, the &lt;mvc:annotation-driven> element has an enable-matrix-variables attribute that should be set to true . By default it is set to false .</p><p>而使用MVC的命名空間配置時，你可以把 &lt;mvc:annotation-driven> 元素下的 enable-matrix-variables 屬性設置為 true 。該值默認情況下是配置為 false 的。</p><p>&lt;?xml version="1.0" encoding="UTF-8"?>&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd"></p><p>&lt;mvc:annotation-driven enable-matrix-variables="true"/></p><p>&lt;/beans></p><p>可消費的媒體類型</p><p>[Original] You can narrow the primary mapping by specifying a list of consumable mediatypes. The request will be matched only if the Content-Type request header matchesthe specified media type. For example:</p><p>你可以指定一組可消費的媒體類型，縮小映射的範圍。這樣只有當請求頭中 Content-Type 的值與指定可消費的媒體類型中有相同的時候，請求才會被匹配。比如下面這個例子：</p><p>使用@RequestMapping註解映射請求路徑</p><p>41</p><p>@Controller@RequestMapping(path = "/pets", method = RequestMethod.POST, consumes="application/json")public void addPet(@RequestBody Pet pet, Model model) { // 方法實現省略}</p><p>[Original] Consumable media type expressions can also be negated as in !text/plain tomatch to all requests other than those with Content-Type of text/plain. Also considerusing constants provided in MediaType such as APPLICATION_JSON_VALUE and APPLICATION_JSON_UTF8_VALUE .</p><p>指定可消費媒體類型的表達式中還可以使用否定，比如，可以使用 !text/plain 來匹配所有請求頭 Content-Type 中不含 text/plain 的請求。同時，在 MediaType 類中還定義了一些常量，比如 APPLICATION_JSON_VALUE 、 APPLICATION_JSON_UTF8_VALUE 等，推薦更多地使用它們。</p><p>[Original] The consumes condition is supported on the type and on the method level.Unlike most other conditions, when used at the type level, method-level consumabletypes override rather than extend type-level consumable types.</p><p>consumes 屬性提供的是方法級的類型支持。與其他屬性不同，當在類型級使用時，方法級的消費類型將覆蓋類型級的配置，而非繼承關係。</p><p>可生產的媒體類型</p><p>[Original] You can narrow the primary mapping by specifying a list of producible mediatypes. The request will be matched only if the Accept request header matches one ofthese values. Furthermore, use of the produces condition ensures the actual contenttype used to generate the response respects the media types specified in the producescondition. For example:</p><p>你可以指定一組可生產的媒體類型，縮小映射的範圍。這樣只有當請求頭中 Accept 的值與指定可生產的媒體類型中有相同的時候，請求才會被匹配。而且，使用 produces 條件可以確保用於生成響應（response）的內容與指定的可生產的媒體類型是相同的。舉個例子：</p><p>@Controller@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)@ResponseBodypublic Pet getPet(@PathVariable String petId, Model model) { // 方法實現省略}</p><p>使用@RequestMapping註解映射請求路徑</p><p>42</p><p>[Original] Be aware that the media type specified in the produces condition can alsooptionally specify a character set. For example, in the code snippet above we specifythe same media type than the default one configured in MappingJackson2HttpMessageConverter , including the UTF-8 charset.</p><p>要注意的是，通過 condition 條件指定的媒體類型也可以指定字符集。比如在上面的小段代碼中，我們還是覆寫了 MappingJackson2HttpMessageConverter 類中默認配置的媒體類</p><p>型，同時，還指定了使用 UTF-8 的字符集。</p><p>[Original] Just like with consumes, producible media type expressions can be negatedas in !text/plain to match to all requests other than those with an Accept header value oftext/plain. Also consider using constants provided in MediaType such as APPLICATION_JSON_VALUE and APPLICATION_JSON_UTF8_VALUE .</p><p>與 consumes 條件類似，可生產的媒體類型表達式也可以使用否定。比如，可以使用!text/plain 來匹配所有請求頭 Accept 中不含 text/plain 的請求。同時，在 MediaType 類中還定義了一些常量，比如 APPLICATION_JSON_VALUE 、 APPLICATION_JSON_UTF8_VALUE 等，推薦更多地</p><p>使用它們。</p><p>[Original] The produces condition is supported on the type and on the method level.Unlike most other conditions, when used at the type level, method-level producibletypes override rather than extend type-level producible types.</p><p>produces 屬性提供的是方法級的類型支持。與其他屬性不同，當在類型級使用時，方法級的消費類型將覆蓋類型級的配置，而非繼承關係。</p><p>請求參數與請求頭的值</p><p>[Original] You can narrow request matching through request parameter conditions suchas "myParam" , "!myParam" , or "myParam=myValue" . The first two test for requestparameter presence/absence and the third for a specific parameter value. Here is anexample with a request parameter value condition:</p><p>你可以篩選請求參數的條件來縮小請求匹配範圍，比</p><p>如 "myParam" 、 "!myParam" 及 "myParam=myValue" 等。前兩個條件用於篩選存在/不存在某些請求參數的請求，第三個條件篩選具有特定參數值的請求。下面有個例子，展示瞭如何使用</p><p>請求參數值的篩選條件：</p><p>使用@RequestMapping註解映射請求路徑</p><p>43</p><p>@Controller@RequestMapping("/owners/{ownerId}")public class RelativePathUriTemplateController {</p><p>@RequestMapping(path = "/pets/{petId}", method = RequestMethod.GET, params="myParam=myValue") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) { // 實際實現省略 }</p><p>}</p><p>[Original] The same can be done to test for request header presence/absence or tomatch based on a specific request header value:</p><p>同樣，你可以用相同的條件來篩選請求頭的出現與否，或者篩選出一個具有特定值的請求</p><p>頭：</p><p>@Controller@RequestMapping("/owners/{ownerId}")public class RelativePathUriTemplateController {</p><p>@RequestMapping(path = "/pets", method = RequestMethod.GET, headers="myHeader=myValue") public void findPet(@PathVariable String ownerId, @PathVariable String petId, Model model) { // 方法體實現省略 }</p><p>}</p><p>[Original] Although you can match to Content-Type and Accept header values usingmedia type wild cards (for example "content-type=text/*" will match to "text/plain" and"text/html"), it is recommended to use the consumes and produces conditionsrespectively instead. They are intended specifically for that purpose.</p><p>儘管，你可以使用媒體類型的通配符（比如 "content-type=text/*"）來匹配請求頭Content-Type和 Accept的值，但我們更推薦獨立使用 consumes和 produces條件來篩選各自的請求。因為它們就是專門為區分這兩種不同的場景而生的。</p><p>使用@RequestMapping註解映射請求路徑</p><p>44</p><p>21.3.3 定義@RequestMapping註解的處理方法(handler method)使用 @RequestMapping 註解的處理方法可以擁有非常靈活的方法簽名，它支持的方法參數及返</p><p>回值類型將在接下來的小節講述。大多數參數都可以任意的次序出現，除了唯一的一個例</p><p>外： BindingResult 參數。這在下節也會詳細描述。</p><p>Spring 3.1中新增了一些類，用以增強註解了 @RequestMapping 的處理方法，分別是 RequestMappingHandlerMapping 類和 RequestMappingHandlerAdapter 類。我們鼓勵使用</p><p>這組新的類，如果要使用Spring 3.1及以後版本的新特性，這組類甚至是必須使用的。這些增強類在MVC的命名空間配置和MVC的Java編程方式配置中都是默認開啟的，如果不是使用這兩種方法，那麼就需要顯式地配置。</p><p>支持的方法參數類型</p><p>下面列出所有支持的方法參數類型：</p><p>請求或響應對象（Servlet API）。可以是任何具體的請求或響應類型的對象，比如， ServletRequest 或 HttpServletRequest 對象等。</p><p>HttpSession 類型的會話對象（Servlet API）。使用該類型的參數將要求這樣一個session的存在，因此這樣的參數永不為 null 。</p><p>存取session可能不是線程安全的，特別是在一個Servlet的運行環境中。如果應用可能有多個請求同時併發存取一個session場景，請考慮將RequestMappingHandlerAdapter類中的"synchronizeOnSession"標誌設置為"true"。</p><p>org.springframework.web.context.request.WebRequest 或 org.springframework.web.context</p><p>.request.NativeWebRequest 。允許存取一般的請求參數和請求/會話範圍的屬性（attribute），同時無需綁定使用Servlet/Portlet的API當前請求的地區信息 java.util.Locale ，由已配置的最相關的地區解析器解析得到。在</p><p>MVC的環境下，就是應用中配置的 LocaleResolver 或 LocaleContextResolver 與當前請求綁定的時區信息 java.util.TimeZone （java 6以上的版本）/ java.time.ZoneId （java 8），由 LocaleContextResolver 解析得到用於存取請求正文的 java.io.InputStream 或 java.io.Reader 。該對象與通過Servlet API拿到的輸入流/Reader是一樣的用於生成響應正文的 java.io.OutputStream 或 java.io.Writer 。該對象與通過ServletAPI拿到的輸出流/Writer是一樣的 org.springframework.http.HttpMethod 。可以拿到HTTP請求方法包裝了當前被認證用戶信息的 java.security.Principal</p><p>定義@RequestMapping註解的處理方法</p><p>45</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>SpringMVC4.2</a></li><li><a>文檔</a></li><li><a>中文</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/06970da8.html alt=Word文檔中5個常用的小技巧，你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b12b846f7f7143038ea2c9db335aa509 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/06970da8.html title=Word文檔中5個常用的小技巧，你知道嗎？>Word文檔中5個常用的小技巧，你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8cc5b217.html alt=老闆讓把Word文檔字體調好看點？設置字體快捷鍵，1秒搞定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/42f34d2a-f318-4d34-9927-9453dba5ba5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8cc5b217.html title=老闆讓把Word文檔字體調好看點？設置字體快捷鍵，1秒搞定>老闆讓把Word文檔字體調好看點？設置字體快捷鍵，1秒搞定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8f5cf60.html alt=表格文檔技巧丨快速選取單元格區域的11種方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/568c0001ac51422bdf8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8f5cf60.html title=表格文檔技巧丨快速選取單元格區域的11種方法>表格文檔技巧丨快速選取單元格區域的11種方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25e69eeb.html alt="如何在 Web 服務器文檔根目錄上設置只讀文件權限" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25e69eeb.html title="如何在 Web 服務器文檔根目錄上設置只讀文件權限">如何在 Web 服務器文檔根目錄上設置只讀文件權限</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abf5442e.html alt=Word技巧丨Word文檔顯示或隱藏回車換行符號！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e8dc8a3ae23b4ae4bf25c1e335b13b05 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abf5442e.html title=Word技巧丨Word文檔顯示或隱藏回車換行符號！>Word技巧丨Word文檔顯示或隱藏回車換行符號！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07390049.html alt=1鍵自動生成一萬字文檔，懶人專用技巧，你值得擁有 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f18705eeb44a411bad278ce1930fffc7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07390049.html title=1鍵自動生成一萬字文檔，懶人專用技巧，你值得擁有>1鍵自動生成一萬字文檔，懶人專用技巧，你值得擁有</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46550438.html alt=怎樣給word文檔插入腳註 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539741681146cab4d0a32f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46550438.html title=怎樣給word文檔插入腳註>怎樣給word文檔插入腳註</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e06f745e.html alt=Word文檔如何快速實現段落整體上下移動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ba4ea7f996074e8e82fd00c16c5f9ecc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e06f745e.html title=Word文檔如何快速實現段落整體上下移動>Word文檔如何快速實現段落整體上下移動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/abb778e6.html alt=Word文檔如何快速查看字數？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a3f9c00623104fdda21152d44c98d6a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/abb778e6.html title=Word文檔如何快速查看字數？>Word文檔如何快速查看字數？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/85871d60.html alt=如何在word文檔中查詢某個字的個數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8c6a2597fb2a4239b49cc3e71796355c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85871d60.html title=如何在word文檔中查詢某個字的個數>如何在word文檔中查詢某個字的個數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a89846d8.html alt=就一招，快速查找Word文檔的文字數、段落數、行數！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4af30004c424514a2017 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a89846d8.html title=就一招，快速查找Word文檔的文字數、段落數、行數！>就一招，快速查找Word文檔的文字數、段落數、行數！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/68343d69.html alt=怎樣用文檔網格控制Word文檔的行數和字數？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c2d1333e489d4162aed0f8b258c6cc7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/68343d69.html title=怎樣用文檔網格控制Word文檔的行數和字數？>怎樣用文檔網格控制Word文檔的行數和字數？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f0cadc3.html alt=用Excel函數提取文檔中的漢字字數，太有效率了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152907906269005478e57be style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f0cadc3.html title=用Excel函數提取文檔中的漢字字數，太有效率了>用Excel函數提取文檔中的漢字字數，太有效率了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dea4357.html alt=神啦！Word文檔字數統計全自動！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/111400011feccae4b305 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dea4357.html title=神啦！Word文檔字數統計全自動！>神啦！Word文檔字數統計全自動！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>