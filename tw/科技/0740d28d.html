<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>包教包會！看了這篇你就會手寫RPC框架了 | 极客快訊</title><meta property="og:title" content="包教包會！看了這篇你就會手寫RPC框架了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/55d9c37ea69242bb9e645344cd879609"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0740d28d.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0740d28d.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="包教包會！看了這篇你就會手寫RPC框架了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0740d28d.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>包教包會！看了這篇你就會手寫RPC框架了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>本文作者：東方雨傾<br>本文鏈接：https://www.cnblogs.com/itoak/p/13370031.html</p></blockquote><h1 class=pgc-h-arrow-right><strong>一、學習本文你能學到什麼？</strong></h1><ul><li>RPC的概念及運作流程</li><li>RPC協議及RPC框架的概念</li><li>Netty的基本使用</li><li>Java序列化及反序列化技術</li><li>Zookeeper的基本使用（註冊中心）</li><li>自定義註解實現特殊業務邏輯</li><li>Java的動態代理</li><li>自定義Spring Boot Starter</li></ul><p style=text-align:start>這裡只是列出了你能從RPC框架源碼中能學到的東西，本文並不會每個知識點都點到，主要講述如何手寫一個RPC框架，更多細節需要讀者閱讀源碼，文章的下方會提供源碼鏈接哦。</p><h1 class=pgc-h-arrow-right><strong>二、RPC基礎知識</strong></h1><h1 class=pgc-h-arrow-right><strong>2.1 RPC是什麼？</strong></h1><p style=text-align:start>Remote Procedure Call（RPC）：遠程過程調用。</p><blockquote><p>過程是什麼？過程就是業務處理、計算任務，更直白理解，就是程序。（像調用本地方法一樣調用遠程的過程。）</p></blockquote><p style=text-align:start>RPC採用Client-Server結構，通過Request-Response消息模式實現。</p><h1 class=pgc-h-arrow-right><strong>2.2 RPC的流程</strong></h1><div class=pgc-img><img alt=包教包會！看了這篇你就會手寫RPC框架了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/55d9c37ea69242bb9e645344cd879609><p class=pgc-img-caption></p></div><ul><li>客戶端處理過程中調用Client stub（就像調用本地方法一樣），傳遞參數；</li><li>Client stub將參數編組為消息，然後通過系統調用向服務端發送消息；</li><li>客戶端本地操作系統將消息從客戶端機器發送到服務端機器；</li><li>服務端操作系統將接收到的數據包傳遞給Server stub;</li><li>Server stub解組消息為參數；</li><li>Server stub再調用服務端的過程，過程執行結果以反方向的相同步驟響應給客戶端。</li></ul><h1 class=pgc-h-arrow-right><strong>2.3 RPC流程中需要處理的問題</strong></h1><ul><li>Client stub、Server stub的開發；</li><li>參數如何編組為消息，以及解組消息；</li><li>消息如何發送；</li><li>過程結果如何表示、異常情況如何處理；</li><li>如何實現安全的訪問控制。</li></ul><h1 class=pgc-h-arrow-right><strong>2.4 RPC協議是什麼？</strong></h1><p style=text-align:start>RPC調用過程中需要將參數編組為消息進行發送，接收方需要解組消息為參數，過程處理結果同樣需要經編組、解組。消息由哪些部分構成及消息的表示形式就構成了消息協議。</p><p style=text-align:start><strong>RPC調用過程中採用的消息協議稱為RPC協議</strong></p><blockquote><p>RPC協議規定請求、響應消息的格式</p><p>在TCP（網絡傳輸控制協議）上可選用或自定義消息協議來完成RPC消息交互</p><p>我們可以選用通用的標準協議（如：http、https），也也可根據自身的需要定義自己的消息協議。</p></blockquote><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right><strong>2.5 RPC框架是什麼？</strong></h1><p style=text-align:start>封裝好參數編組、消息解組、底層網絡通信的RPC程序開發框架，帶來的便捷是可以直接在其基礎上只需要專注於過程代碼編寫。</p><p style=text-align:start>Java領域：</p><ul><li>傳統的webservice框架：Apache CXF、Apache Axis2、Java自帶的JAX-WS等。webservice框架大多基於標準的SOAP協議。</li><li>新興的微服務框架：Dubbo、spring cloud、Apache Thrift等。</li></ul><h1 class=pgc-h-arrow-right><strong>三、手寫RPC</strong></h1><h1 class=pgc-h-arrow-right><strong>3.1 目標</strong></h1><p style=text-align:start>我們將會寫一個簡易的RPC框架，暫且叫它leisure-rpc-spring-boot-starter，通過在項目中引入該starter，並簡單的配置一下，項目即擁有提供遠程服務的能力。</p><p style=text-align:start>編寫自定義註解@Service，被它註解的類將會提供遠程服務。</p><p style=text-align:start>編寫自定義註解@InjectService，使用它可注入遠程服務。</p><h1 class=pgc-h-arrow-right><strong>3.2 項目整體結構</strong></h1><div class=pgc-img><img alt=包教包會！看了這篇你就會手寫RPC框架了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/747182abb8da4394b1b197c9d7b7d3e2><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>3.3 客戶端編寫</strong></h1><h1 class=pgc-h-arrow-right><strong>3.3.1 客戶端需要做什麼？</strong></h1><p style=text-align:start>客戶端想要調用遠程服務，必須具備<strong>服務發現</strong>的能力；在知道有哪些服務過後，還必須有<strong>服務代理</strong>來執行服務調用；客戶端想要與服務端通信，必須要有相同的<strong>消息協議</strong>；客戶端想要調用遠程服務，那麼必須具備網絡請求的能力，即<strong>網絡層</strong>功能。</p><p style=text-align:start>當然，這是客戶端所需的最基本的能力，其實還可以擴展的能力，例如負載均衡。</p><h1 class=pgc-h-arrow-right><strong>3.3.2 具體實現</strong></h1><p style=text-align:start>我們先看看客戶端的代碼結構：</p><div class=pgc-img><img alt=包教包會！看了這篇你就會手寫RPC框架了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a4fa227f9f5460aa20360b0aab5b3f0><p class=pgc-img-caption></p></div><p style=text-align:start>基於面向接口編程的理念，不同角色都實現了定義了相應規範的接口。這裡面我們沒有發現消息協議相關內容，那是因為服務端也需要消息協議，因此抽離了出來，放在公共層。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.1 服務發現者</strong></h1><pre><code>/*** 服務發現抽象類，定義服務發現規範** @author 東方雨傾* @since 1.0.0*/public interface ServiceDiscoverer {   List&lt;Service&gt; getServices(String name);}/*** Zookeeper服務發現者，定義以Zookeeper為註冊中心的服務發現細則** @author 東方雨傾* @since 1.0.0*/public class ZookeeperServiceDiscoverer implements ServiceDiscoverer {   private ZkClient zkClient;   public ZookeeperServiceDiscoverer(String zkAddress) {       zkClient = new ZkClient(zkAddress);       zkClient.setZkSerializer(new ZookeeperSerializer());  }   /**    * 使用Zookeeper客戶端，通過服務名獲取服務列表    * 服務名格式：接口全路徑    *    * @param name 服務名    * @return 服務列表    */   @Override   public List&lt;Service&gt; getServices(String name) {       String servicePath = LeisureConstant.ZK_SERVICE_PATH +LeisureConstant.PATH_DELIMITER + name + "/service";       List&lt;String&gt; children = zkClient.getChildren(servicePath);       return Optional.ofNullable(children).orElse(new ArrayList&lt;&gt;()).stream().map(str -&gt; {           String deCh = null;           try {               deCh = URLDecoder.decode(str, LeisureConstant.UTF_8);          } catch (UnsupportedEncodingException e) {               e.printStackTrace();          }           return JSON.parseObject(deCh, Service.class);      }).collect(Collectors.toList());  }}</code></pre><p style=text-align:start>服務發現者使用Zookeeper來實現，通過ZkClient我們很容易發現已經註冊在ZK上的服務。當然我們也可以使用其他組件作為註冊中心，例如Redis。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.2 網絡客戶端</strong></h1><pre><code>/*** 網絡請求客戶端，定義網絡請求規範** @author 東方雨傾* @since 1.0.0*/public interface NetClient {   byte[] sendRequest(byte[] data, Service service) throws InterruptedException;}/*** Netty網絡請求客戶端，定義通過Netty實現網絡請求的細則。** @author 東方雨傾* @since 1.0.0*/public class NettyNetClient implements NetClient {   private static Logger logger = LoggerFactory.getLogger(NettyNetClient.class);   /**    * 發送請求    *    * @param data   請求數據    * @param service 服務信息    * @return 響應數據    * @throws InterruptedException 異常    */   @Override   public byte[] sendRequest(byte[] data, Service service) throwsInterruptedException {       String[] addInfoArray = service.getAddress().split(":");       String serverAddress = addInfoArray[0];       String serverPort = addInfoArray[1];       SendHandler sendHandler = new SendHandler(data);       byte[] respData;       // 配置客戶端       EventLoopGroup group = new NioEventLoopGroup();       try {           Bootstrap b = new Bootstrap();           b.group(group).channel(NioSocketChannel.class).option(ChannelOption.TCP_NODELAY, true)                  .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                       @Override                       public void initChannel(SocketChannel ch) {                           ChannelPipeline p = ch.pipeline();                           p.addLast(sendHandler);                      }                  });           // 啟動客戶端連接           b.connect(serverAddress, Integer.parseInt(serverPort)).sync();           respData = (byte[]) sendHandler.rspData();           logger.info("SendRequest get reply: {}", respData);      } finally {           // 釋放線程組資源           group.shutdownGracefully();      }       return respData;  }}/*** 發送處理類，定義Netty入站處理細則** @author 東方雨傾* @since 1.0.0*/public class SendHandler extends ChannelInboundHandlerAdapter {   private static Logger logger = LoggerFactory.getLogger(SendHandler.class);   private CountDownLatch cdl;   private Object readMsg = null;   private byte[] data;   public SendHandler(byte[] data) {       cdl = new CountDownLatch(1);       this.data = data;  }   /**    * 當連接服務端成功後，發送請求數據    *    * @param ctx 通道上下文    */   @Override   public void channelActive(ChannelHandlerContext ctx) {       logger.info("Successful connection to server：{}", ctx);       ByteBuf reqBuf = Unpooled.buffer(data.length);       reqBuf.writeBytes(data);       logger.info("Client sends message：{}", reqBuf);       ctx.writeAndFlush(reqBuf);  }   /**    * 讀取數據，數據讀取完畢釋放CD鎖    *    * @param ctx 上下文    * @param msg ByteBuf    */   @Override   public void channelRead(ChannelHandlerContext ctx, Object msg) {       logger.info("Client reads message: {}", msg);       ByteBuf msgBuf = (ByteBuf) msg;       byte[] resp = new byte[msgBuf.readableBytes()];       msgBuf.readBytes(resp);       readMsg = resp;       cdl.countDown();  }   /**    * 等待讀取數據完成    *    * @return 響應數據    * @throws InterruptedException 異常    */   public Object rspData() throws InterruptedException {       cdl.await();       return readMsg;  }   @Override   public void channelReadComplete(ChannelHandlerContext ctx) {       ctx.flush();  }   @Override   public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {       // Close the connection when an exception is raised.       cause.printStackTrace();       logger.error("Exception occurred：{}", cause.getMessage());       ctx.close();  }}</code></pre><p style=text-align:start>在這裡我們使用Netty來實現網絡請求客戶端，當然也可以使用Mina。網絡請求客戶端能連接遠程服務端，並將編組好的請求數據發送給服務端，待服務端處理好後，又將服務端的響應數據返回給客戶端。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.3 服務代理</strong></h1><pre><code>/*** 客戶端代理工廠：用於創建遠程服務代理類* 封裝編組請求、請求發送、編組響應等操作。** @author 東方雨傾* @since 1.0.0*/public class ClientProxyFactory {   private ServiceDiscoverer serviceDiscoverer;   private Map&lt;String, MessageProtocol&gt; supportMessageProtocols;   private NetClient netClient;   private Map&lt;Class&lt;?&gt;, Object&gt; objectCache = new HashMap&lt;&gt;();   /**    * 通過Java動態代理獲取服務代理類    *    * @param clazz 被代理類Class    * @param &lt;T&gt;   泛型    * @return 服務代理類    */   @SuppressWarnings("unchecked")   public &lt;T&gt; T getProxy(Class&lt;T&gt; clazz) {       return (T) this.objectCache.computeIfAbsent(clazz,               cls -&gt; newProxyInstance(cls.getClassLoader(), new Class&lt;?&gt;[]{cls}, newClientInvocationHandler(cls)));  }   // getter setter ...   /**    * 客戶端服務代理類invoke函數細節實現    */   private class ClientInvocationHandler implements InvocationHandler {       private Class&lt;?&gt; clazz;       private Random random = new Random();       public ClientInvocationHandler(Class&lt;?&gt; clazz) {           super();           this.clazz = clazz;      }       @Override       public Object invoke(Object proxy, Method method, Object[] args) throwsException {           if (method.getName().equals("toString")) {               return proxy.getClass().toString();          }           if (method.getName().equals("hashCode")) {               return 0;          }           // 1、獲得服務信息           String serviceName = this.clazz.getName();           List&lt;Service&gt; services = serviceDiscoverer.getServices(serviceName);           if (services == null || services.isEmpty()) {               throw new LeisureException("No provider available!");          }           // 隨機選擇一個服務提供者（軟負載均衡）           Service service = services.get(random.nextInt(services.size()));           // 2、構造request對象           LeisureRequest req = new LeisureRequest();           req.setServiceName(service.getName());           req.setMethod(method.getName());           req.setParameterTypes(method.getParameterTypes());           req.setParameters(args);           // 3、協議層編組           // 獲得該方法對應的協議           MessageProtocol protocol =supportMessageProtocols.get(service.getProtocol());           // 編組請求           byte[] data = protocol.marshallingRequest(req);           // 4、調用網絡層發送請求           byte[] repData = netClient.sendRequest(data, service);           // 5解組響應消息           LeisureResponse rsp = protocol.unmarshallingResponse(repData);           // 6、結果處理           if (rsp.getException() != null) {               throw rsp.getException();          }           return rsp.getReturnValue();      }  }}</code></pre><p style=text-align:start>服務代理類由客戶端代理工廠類產生，代理方式是基於Java的動態代理。在處理類ClientInvocationHandler的invoke函數中，定義了一系列的操作，包括獲取服務、選擇服務提供者、構造請求對象、編組請求對象、網絡請求客戶端發送請求、解組響應消息、異常處理等。</p><h1 class=pgc-h-arrow-right><strong>3.3.2.4 消息協議</strong></h1><pre><code>/*** 消息協議，定義編組請求、解組請求、編組響應、解組響應規範** @author 東方雨傾* @since 1.0.0*/public interface MessageProtocol {   /**    * 編組請求    *    * @param req 請求信息    * @return 請求字節數組    * @throws Exception 編組請求異常    */   byte[] marshallingRequest(LeisureRequest req) throws Exception;   /**    * 解組請求    *    * @param data 請求字節數組    * @return 請求信息    * @throws Exception 解組請求異常    */   LeisureRequest unmarshallingRequest(byte[] data) throws Exception;   /**    * 編組響應    *    * @param rsp 響應信息    * @return 響應字節數組    * @throws Exception 編組響應異常    */   byte[] marshallingResponse(LeisureResponse rsp) throws Exception;   /**    * 解組響應    *    * @param data 響應字節數組    * @return 響應信息    * @throws Exception 解組響應異常    */   LeisureResponse unmarshallingResponse(byte[] data) throws Exception;}/*** Java序列化消息協議** @author 東方雨傾* @since 1.0.0*/public class JavaSerializeMessageProtocol implements MessageProtocol {   private byte[] serialize(Object obj) throws Exception {       ByteArrayOutputStream bout = new ByteArrayOutputStream();       ObjectOutputStream out = new ObjectOutputStream(bout);       out.writeObject(obj);       return bout.toByteArray();  }   @Override   public byte[] marshallingRequest(LeisureRequest req) throws Exception {       return this.serialize(req);  }   @Override   public LeisureRequest unmarshallingRequest(byte[] data) throws Exception {       ObjectInputStream in = new ObjectInputStream(newByteArrayInputStream(data));       return (LeisureRequest) in.readObject();  }   @Override   public byte[] marshallingResponse(LeisureResponse rsp) throws Exception {       return this.serialize(rsp);  }   @Override   public LeisureResponse unmarshallingResponse(byte[] data) throws Exception {       ObjectInputStream in = new ObjectInputStream(newByteArrayInputStream(data));       return (LeisureResponse) in.readObject();  }}</code></pre><p style=text-align:start>消息協議主要是定義了客戶端如何<strong>編組請求</strong>、<strong>解組響應</strong>，服務端如何<strong>解組請求</strong>、<strong>編組響應</strong>這四個操作規範。本文提供了Java序列化與反序列化的實現，感興趣的讀者可以基於其他序列化技術實現其他消息協議（偷偷說一句：Java的序列化性能很不理想）。</p><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right><strong>3.4 服務端編寫</strong></h1><h1 class=pgc-h-arrow-right><strong>3.4.1 服務端需要做什麼？</strong></h1><p style=text-align:start>首先，服務端要提供遠程服務，必須具備<strong>服務註冊及暴露</strong>的能力；在這之後，還需要開啟<strong>網絡服務</strong>，供客戶端連接。有些項目可能既是服務提供者，又是服務消費者，那什麼時候開啟服務，什麼時候注入服務呢？這裡我們引入一個<strong>RPC處理者</strong>的概念，由它來幫我們開啟服務，以及注入服務。</p><h1 class=pgc-h-arrow-right><strong>3.4.3 具體實現</strong></h1><p style=text-align:start>先看看服務端的代碼結構：</p><div class=pgc-img><img alt=包教包會！看了這篇你就會手寫RPC框架了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6df64a1fc70b447da611d69af84df99c><p class=pgc-img-caption></p></div><p style=text-align:start>服務端做的事情也很簡單，註冊服務並暴露服務，然後開啟網絡服務；如果服務端也是消費者，則注入遠程服務。</p><p style=text-align:start>服務註冊和服務注入依賴兩個自定義註解來實現：</p><ul><li>@Service：註冊服務</li><li>@InjectService：注入服務</li></ul><p style=text-align:start>下面是他們的實現代碼：</p><pre><code>/*** 被該註解標記的服務可提供遠程RPC訪問的能力** @author 東方雨傾* @since 1.0.0*/@Target({ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Documented@Componentpublic @interface Service {   String value() default "";}/*** 該註解用於注入遠程服務** @author 東方雨傾* @since 1.0.0*/@Target({ElementType.FIELD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface InjectService {}</code></pre><h1 class=pgc-h-arrow-right><strong>3.4.3.1 服務註冊(暴露)</strong></h1><pre><code>/*** 服務註冊器，定義服務註冊規範** @author 東方雨傾* @since 1.0.0*/public interface ServiceRegister {   void register(ServiceObject so) throws Exception;   ServiceObject getServiceObject(String name) throws Exception;}/*** 默認服務註冊器** @author 東方雨傾* @since 1.0.0*/public class DefaultServiceRegister implements ServiceRegister {   private Map&lt;String, ServiceObject&gt; serviceMap = new HashMap&lt;&gt;();   protected String protocol;   protected Integer port;   @Override   public void register(ServiceObject so) throws Exception {       if (so == null) {           throw new IllegalArgumentException("Parameter cannot be empty.");      }       this.serviceMap.put(so.getName(), so);  }   @Override   public ServiceObject getServiceObject(String name) {       return this.serviceMap.get(name);  }}/*** Zookeeper服務註冊器，提供服務註冊、服務暴露的能力** @author 東方雨傾* @since 1.0.0*/public class ZookeeperExportServiceRegister extends DefaultServiceRegisterimplements ServiceRegister {   /**    * Zk客戶端    */   private ZkClient client;   public ZookeeperExportServiceRegister(String zkAddress, Integer port, Stringprotocol) {       client = new ZkClient(zkAddress);       client.setZkSerializer(new ZookeeperSerializer());       this.port = port;       this.protocol = protocol;  }   /**    * 服務註冊    *    * @param so 服務持有者    * @throws Exception 註冊異常    */   @Override   public void register(ServiceObject so) throws Exception {       super.register(so);       Service service = new Service();       String host = InetAddress.getLocalHost().getHostAddress();       String address = host + ":" + port;       service.setAddress(address);       service.setName(so.getClazz().getName());       service.setProtocol(protocol);       this.exportService(service);  }   /**    * 服務暴露    *    * @param serviceResource 需要暴露的服務信息    */   private void exportService(Service serviceResource) {       String serviceName = serviceResource.getName();       String uri = JSON.toJSONString(serviceResource);       try {           uri = URLEncoder.encode(uri, UTF_8);      } catch (UnsupportedEncodingException e) {           e.printStackTrace();      }       String servicePath = ZK_SERVICE_PATH + PATH_DELIMITER + serviceName +"/service";       if (!client.exists(servicePath)) {           client.createPersistent(servicePath, true);      }       String uriPath = servicePath + PATH_DELIMITER + uri;       if (client.exists(uriPath)) {           client.delete(uriPath);      }       client.createEphemeral(uriPath);  }}</code></pre><p style=text-align:start>這個過程其實沒啥好說的，就是將指定ServiceObject對象序列化後保存到ZK上，供客戶端發現。同時會將服務對象緩存起來，在客戶端調用服務時，通過緩存的ServiceObject對象反射指定服務，調用方法。</p><h1 class=pgc-h-arrow-right><strong>3.4.3.2 網絡服務</strong></h1><pre><code>/*** RPC服務端抽象類** @author 東方雨傾* @since 1.0.0*/public abstract class RpcServer {   /**    * 服務端口    */   protected int port;   /**    * 服務協議    */   protected String protocol;   /**    * 請求處理者    */   protected RequestHandler handler;   public RpcServer(int port, String protocol, RequestHandler handler) {       super();       this.port = port;       this.protocol = protocol;       this.handler = handler;  }   /**    * 開啟服務    */   public abstract void start();   /**    * 停止服務    */   public abstract void stop();// getter setter ...}/*** Netty RPC服務端，提供Netty網絡服務開啟、關閉的能力** @author 東方雨傾* @since 1.0.0*/public class NettyRpcServer extends RpcServer {   private static Logger logger = LoggerFactory.getLogger(NettyRpcServer.class);   private Channel channel;   public NettyRpcServer(int port, String protocol, RequestHandler handler) {       super(port, protocol, handler);  }   @Override   public void start() {       // 配置服務器       EventLoopGroup bossGroup = new NioEventLoopGroup(1);       EventLoopGroup workerGroup = new NioEventLoopGroup();       try {           ServerBootstrap b = new ServerBootstrap();           b.group(bossGroup,workerGroup).channel(NioServerSocketChannel.class).option(ChannelOption.SO_BACKLOG, 100)                  .handler(new LoggingHandler(LogLevel.INFO)).childHandler(newChannelInitializer&lt;SocketChannel&gt;() {               @Override               public void initChannel(SocketChannel ch) {                   ChannelPipeline p = ch.pipeline();                   p.addLast(new ChannelRequestHandler());              }          });           // 啟動服務           ChannelFuture f = b.bind(port).sync();           logger.info("Server started successfully.");           channel = f.channel();           // 等待服務通道關閉           f.channel().closeFuture().sync();      } catch (Exception e) {           e.printStackTrace();      } finally {           // 釋放線程組資源           bossGroup.shutdownGracefully();           workerGroup.shutdownGracefully();      }  }   @Override   public void stop() {       this.channel.close();  }   private class ChannelRequestHandler extends ChannelInboundHandlerAdapter {       @Override       public void channelActive(ChannelHandlerContext ctx) {           logger.info("Channel active：{}", ctx);      }       @Override       public void channelRead(ChannelHandlerContext ctx, Object msg) throwsException {           logger.info("The server receives a message: {}", msg);           ByteBuf msgBuf = (ByteBuf) msg;           byte[] req = new byte[msgBuf.readableBytes()];           msgBuf.readBytes(req);           byte[] res = handler.handleRequest(req);           logger.info("Send response：{}", msg);           ByteBuf respBuf = Unpooled.buffer(res.length);           respBuf.writeBytes(res);           ctx.write(respBuf);      }       @Override       public void channelReadComplete(ChannelHandlerContext ctx) {           ctx.flush();      }       @Override       public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {           // Close the connection when an exception is raised.           cause.printStackTrace();           logger.error("Exception occurred：{}", cause.getMessage());           ctx.close();      }  }}/*** 請求處理者，提供解組請求、編組響應等操作** @author 東方雨傾* @since 1.0.0*/public class RequestHandler {   private MessageProtocol protocol;   private ServiceRegister serviceRegister;   public RequestHandler(MessageProtocol protocol, ServiceRegister serviceRegister) {       super();       this.protocol = protocol;       this.serviceRegister = serviceRegister;  }   public byte[] handleRequest(byte[] data) throws Exception {       // 1、解組消息       LeisureRequest req = this.protocol.unmarshallingRequest(data);       // 2、查找服務對象       ServiceObject so = this.serviceRegister.getServiceObject(req.getServiceName());       LeisureResponse rsp = null;       if (so == null) {           rsp = new LeisureResponse(LeisureStatus.NOT_FOUND);      } else {           // 3、反射調用對應的過程方法           try {               Method m = so.getClazz().getMethod(req.getMethod(),req.getParameterTypes());               Object returnValue = m.invoke(so.getObj(), req.getParameters());               rsp = new LeisureResponse(LeisureStatus.SUCCESS);               rsp.setReturnValue(returnValue);          } catch (NoSuchMethodException | SecurityException | IllegalAccessException |IllegalArgumentException                   | InvocationTargetException e) {               rsp = new LeisureResponse(LeisureStatus.ERROR);               rsp.setException(e);          }      }       // 4、編組響應消息       return this.protocol.marshallingResponse(rsp);  }// getter setter ...}</code></pre><p style=text-align:start>網絡服務定義了啟動服務的細則，以及如何處理客戶端發來的請求。</p><h1 class=pgc-h-arrow-right><strong>3.4.3.3 RPC處理者</strong></h1><pre><code>/*** RPC處理者，支持服務啟動暴露、自動注入Service** @author 東方雨傾* @since 1.0.0*/public class DefaultRpcProcessor implementsApplicationListener&lt;ContextRefreshedEvent&gt; {   @Resource   private ClientProxyFactory clientProxyFactory;   @Resource   private ServiceRegister serviceRegister;   @Resource   private RpcServer rpcServer;   @Override   public void onApplicationEvent(ContextRefreshedEvent event) {       if (Objects.isNull(event.getApplicationContext().getParent())) {           ApplicationContext context = event.getApplicationContext();           // 開啟服務           startServer(context);           // 注入Service           injectService(context);      }  }   private void startServer(ApplicationContext context) {       Map&lt;String, Object&gt; beans = context.getBeansWithAnnotation(Service.class);       if (beans.size() != 0) {           boolean startServerFlag = true;           for (Object obj : beans.values()) {               try {                   Class&lt;?&gt; clazz = obj.getClass();                   Class&lt;?&gt;[] interfaces = clazz.getInterfaces();                   ServiceObject so;                   if (interfaces.length != 1) {                       Service service = clazz.getAnnotation(Service.class);                       String value = service.value();                       if (value.equals("")) {                           startServerFlag = false;                           throw new UnsupportedOperationException("The exposed interface is not specific with '" + obj.getClass().getName() + "'");                      }                       so = new ServiceObject(value, Class.forName(value), obj);                  } else {                       Class&lt;?&gt; superClass = interfaces[0];                       so = new ServiceObject(superClass.getName(), superClass, obj);                  }                   serviceRegister.register(so);              } catch (Exception e) {                   e.printStackTrace();              }          }           if (startServerFlag) {               rpcServer.start();          }      }  }   private void injectService(ApplicationContext context) {       String[] names = context.getBeanDefinitionNames();       for (String name : names) {           Class&lt;?&gt; clazz = context.getType(name);           if (Objects.isNull(clazz)) continue;           Field[] fields = clazz.getDeclaredFields();           for (Field field : fields) {               InjectService injectLeisure = field.getAnnotation(InjectService.class);               if (Objects.isNull(injectLeisure)) continue;               Class&lt;?&gt; fieldClass = field.getType();               Object object = context.getBean(name);               field.setAccessible(true);               try {                   field.set(object, clientProxyFactory.getProxy(fieldClass));              } catch (IllegalAccessException e) {                   e.printStackTrace();              }          }      }  }}</code></pre><p style=text-align:start>DefaultRpcProcessor實現了ApplicationListener，並監聽了ContextRefreshedEvent事件，其效果就是在Spring啟動完畢過後會收到一個事件通知，基於這個機制，就可以在這裡開啟服務，以及注入服務。因為一切已經準備就緒了，所需要的資源都是OK的。</p><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right><strong>四、使用RPC框架</strong></h1><p style=text-align:start>框架一個很重要的特性就是要使用簡單，使用該框架只需要一個條件和四個步驟即可。</p><h1 class=pgc-h-arrow-right><strong>4.1 一個條件</strong></h1><p style=text-align:start>需要準備一個Zookeeper作為註冊中心，單節點即可。</p><h1 class=pgc-h-arrow-right><strong>4.2 步驟一</strong></h1><p style=text-align:start>引入Maven依賴：</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;wang.leisure&lt;/groupId&gt;   &lt;artifactId&gt;leisure-rpc-spring-boot-starter&lt;/artifactId&gt;   &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;</code></pre><blockquote><p>不知道如何獲得依賴的讀者，請在源碼下載後，進入項目目錄下（pom.xml文件所在位置），執行 mvn install命令，即可在本地倉庫生成maven依賴。</p></blockquote><h1 class=pgc-h-arrow-right><strong>4.3 步驟二</strong></h1><p style=text-align:start>在你的項目配置文件（application.properties）中配置註冊中心地址，例如：</p><pre><code>leisure.rpc.register-address=192.168.199.241:2181</code></pre><h1 class=pgc-h-arrow-right><strong>4.4 步驟三</strong></h1><p style=text-align:start>將你的遠程服務使用@Service註解，例如：</p><pre><code>import wang.leisure.rpc.annotation.Service;@Servicepublic class UserServiceImpl implements UserService {   @Override   public ApiResult&lt;User&gt; getUser(Long id) {       User user = getFromDbOrCache(id);       return ApiResult.success(user);  }   private User getFromDbOrCache(Long id) {       return new User(id, "東方雨傾", 1, "https://leisure.wang");  }}</code></pre><h1 class=pgc-h-arrow-right><strong>4.5 步驟四</strong></h1><p style=text-align:start>使用註解@InjectService注入遠程服務，例如：</p><pre><code>@RestController@RequestMapping("/index/")public class IndexController {   @InjectService   private UserService userService;   /**    * 獲取用戶信息    * http://localhost:8080/index/getUser?id=1    *    * @param id 用戶id    * @return 用戶信息    */   @GetMapping("getUser")   public ApiResult&lt;User&gt; getUser(Long id) {       return userService.getUser(id);  }}</code></pre><h1 class=pgc-h-arrow-right><strong>五、源碼下載</strong></h1><p style=text-align:start>框架源碼：<u>https://github.com/OakWang/leisure-rpc-spring-boot-starter.git</u></p><p style=text-align:start>示例源碼：<u>https://github.com/OakWang/leisure-rpc-example.git</u></p><h1 class=pgc-h-arrow-right><strong>六、總結</strong></h1><p>希望讀者能夠真正動手去試一試，只有實踐了才能知道里面的運作邏輯。筆者也是花了兩個星期才把代碼跟文章整理好，並不是因為這個東西難，而是因為沒時間，苦逼的程序猿</p><p>如果文章對你有幫助，希望多多支持。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>包教</a></li><li><a>包會</a></li><li><a>這篇</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a8b2e0.html alt=包教包會：砂漿試塊如何取樣、製作、養護、試驗、評定？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1cec45dcf92d4020b7f231b7fe521b23 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a8b2e0.html title=包教包會：砂漿試塊如何取樣、製作、養護、試驗、評定？>包教包會：砂漿試塊如何取樣、製作、養護、試驗、評定？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/647d835d.html alt=真正“零基礎”的水電改造，看完這篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fbeb6fb2-d305-4fd6-a231-0574538df212 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/647d835d.html title=真正“零基礎”的水電改造，看完這篇就夠了>真正“零基礎”的水電改造，看完這篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3136e082.html alt="開學防護看這篇，1 萬份口罩等防護裝備，9.9 元秒" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S71cGv9EsUW6QK style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3136e082.html title="開學防護看這篇，1 萬份口罩等防護裝備，9.9 元秒">開學防護看這篇，1 萬份口罩等防護裝備，9.9 元秒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d028021.html alt=如何更好的使用Java異常，看這篇就對了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d68c79ce68d041fe814db22f4dbe74bc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d028021.html title=如何更好的使用Java異常，看這篇就對了>如何更好的使用Java異常，看這篇就對了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2fa7b83.html alt="看完這篇Exception 和 Error，和面試官扯皮就沒問題了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9bb7006f740478c8f6ce97dce25a688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2fa7b83.html title="看完這篇Exception 和 Error，和面試官扯皮就沒問題了">看完這篇Exception 和 Error，和面試官扯皮就沒問題了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63721d0a.html alt=看完這篇乾貨分享，讓滑坡監測更輕鬆 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25931a2b682d4ad2bf98026edfd1cb64 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63721d0a.html title=看完這篇乾貨分享，讓滑坡監測更輕鬆>看完這篇乾貨分享，讓滑坡監測更輕鬆</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9dab105f.html alt=不同的皺紋護理方法，這篇統統告訴你 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/297e9d41def741dd94c4fa78c39cadaf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9dab105f.html title=不同的皺紋護理方法，這篇統統告訴你>不同的皺紋護理方法，這篇統統告訴你</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c91b9b3.html alt=【攻略分享】搬家9次，良心整理出這篇搬家技巧（內附搬家神器） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f11d3f579b1c4e25ae756fd81c4c7b65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c91b9b3.html title=【攻略分享】搬家9次，良心整理出這篇搬家技巧（內附搬家神器）>【攻略分享】搬家9次，良心整理出這篇搬家技巧（內附搬家神器）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f615acc6.html alt=搬家5次，整理出的這篇良心搬家技巧，你應該收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c7cb17415a4640a19f01cb736489950c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f615acc6.html title=搬家5次，整理出的這篇良心搬家技巧，你應該收藏>搬家5次，整理出的這篇良心搬家技巧，你應該收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3b6526c7.html alt=搬家6次，良心整理出的這篇搬家攻略 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/52a57683-0d8c-4853-954c-5e1d9b62634f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3b6526c7.html title=搬家6次，良心整理出的這篇搬家攻略>搬家6次，良心整理出的這篇搬家攻略</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c436c7e9.html alt=智能門鎖如何選？看完這篇就夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ea74dbcd9a8245d59c662e7c38b2799b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c436c7e9.html title=智能門鎖如何選？看完這篇就夠了>智能門鎖如何選？看完這篇就夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e896d220.html alt=差速器和變速箱，功能一樣嗎？看了這篇不再傻傻分不清 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/863d559592d04f168a6567fd5cd54d3c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e896d220.html title=差速器和變速箱，功能一樣嗎？看了這篇不再傻傻分不清>差速器和變速箱，功能一樣嗎？看了這篇不再傻傻分不清</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2389dc8c.html alt=欄杆的4大款式，5大分類！看完這篇，選材時就有數了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e2bbe70bd5a74b9c8dd318d465aaa6bc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2389dc8c.html title=欄杆的4大款式，5大分類！看完這篇，選材時就有數了>欄杆的4大款式，5大分類！看完這篇，選材時就有數了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6939e5f.html alt=看了這篇就知道如何開發一個優秀的API class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6939e5f.html title=看了這篇就知道如何開發一個優秀的API>看了這篇就知道如何開發一個優秀的API</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/72599eab.html alt=紫外線殺菌你瞭解多少?看完這篇BBC的報道就知道了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/f0747b6e-83b3-4415-83d0-863015470c16 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/72599eab.html title=紫外線殺菌你瞭解多少?看完這篇BBC的報道就知道了>紫外線殺菌你瞭解多少?看完這篇BBC的報道就知道了</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>