<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SynchronousQueue 同步隊列入門使用&源碼詳解 | 极客快訊</title><meta property="og:title" content="SynchronousQueue 同步隊列入門使用&源碼詳解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/07f82832.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/07f82832.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/07f82832.html><meta property="article:published_time" content="2020-11-14T21:06:28+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:28+08:00"><meta name=Keywords content><meta name=description content="SynchronousQueue 同步隊列入門使用&源碼詳解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/07f82832.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SynchronousQueue 同步隊列入門使用&源碼詳解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong><span style="color:#3e3e3e;--tt-darkmode-color: #A3A3A3">SynchronousQueue</span></strong></h1><div class=pgc-img><img alt="SynchronousQueue 同步隊列入門使用&源碼詳解" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f><p class=pgc-img-caption></p></div><p><span style="color:#999;--tt-darkmode-color: #999999">思維導圖</span></p><h1 class=pgc-h-arrow-right><strong>是什麼</strong></h1><p>SynchronousQueue 是這樣一種阻塞隊列，其中每個 put 必須等待一個 take，反之亦然。</p><p>簡而言之：線程安全，阻塞。</p><h1 class=pgc-h-arrow-right><strong>入門案例</strong></h1><p>我們定義兩個線程，一個負責寫入，一個負責讀取。</p><pre><code>import java.util.concurrent.SynchronousQueue;import java.util.concurrent.TimeUnit;/** * @author 老馬嘯西風 * @since 1.0.0 */public class SynchronousQueueDemo {    public static void main(String[] args) {        SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;();        new Writer(queue).start();        new Reader(queue).start();    }    private static class Writer extends Thread {        SynchronousQueue&lt;Integer&gt; queue;        public Writer(SynchronousQueue&lt;Integer&gt; queue) {            this.queue = queue;        }        @Override        public void run() {            for (int i = 0; i &lt; 5; i++) {                System.out.println("開始設置第 " + i + " 個元素");                try {                    TimeUnit.SECONDS.sleep(2);                    queue.put(i);                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }    /**     * 消息讀取者     */    private static class Reader extends Thread {        SynchronousQueue&lt;Integer&gt; queue;        public Reader(SynchronousQueue&lt;Integer&gt; queue) {            this.queue = queue;        }        @Override        public void run() {            while (true) {                try {                    System.out.println("讀取信息: " + queue.take() + "\n");                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        }    }}</code></pre><p>對應的日誌信息如下：</p><pre><code>開始設置第 0 個元素開始設置第 1 個元素讀取信息: 0開始設置第 2 個元素讀取信息: 1開始設置第 3 個元素讀取信息: 2開始設置第 4 個元素讀取信息: 3讀取信息: 4</code></pre><p>可以看到當元素被設置之後，就會被立刻讀取。這個在實際使用過程中還是非常便利的，比輪訓優雅多了。</p><h1 class=pgc-h-arrow-right><strong>源碼分析</strong></h1><h1 class=pgc-h-arrow-right><strong>類定義</strong></h1><pre><code>public class SynchronousQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;    implements BlockingQueue&lt;E&gt;, java.io.Serializable {    // 轉換類實現，也是最核心的一個屬性。    // 後面會詳細講解        private transient volatile Transferer&lt;E&gt; transferer;}</code></pre><p>實現了阻塞隊列接口，繼承自 AbstractQueue 抽象隊列。</p><p>實際上對應的 put/take 方法，經過 transfer 的封裝之後，都變得非常簡單。</p><p>我們本文的核心在於對 Transferer 的解析。</p><h1 class=pgc-h-arrow-right><strong>構造器</strong></h1><p>SynchronousQueue 也是支持是否為公平鎖模式的。</p><p>默認為非公平模式。</p><p>是否公平取決於使用的 Transfer 實現子類。</p><pre><code>public SynchronousQueue() {    this(false);}public SynchronousQueue(boolean fair) {    transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();}</code></pre><h1 class=pgc-h-arrow-right><strong>put 方法</strong></h1><pre><code>/** * Adds the specified element to this queue, waiting if necessary for * another thread to receive it. */public void put(E e) throws InterruptedException {    if (e == null) throw new NullPointerException();    if (transferer.transfer(e, false, 0) == null) {        Thread.interrupted();        throw new InterruptedException();    }}</code></pre><h1 class=pgc-h-arrow-right><strong>take 方法</strong></h1><pre><code>/** * Retrieves and removes the head of this queue, waiting if necessary * for another thread to insert it. */public E take() throws InterruptedException {    E e = transferer.transfer(null, false, 0);    if (e != null)        return e;    Thread.interrupted();    throw new InterruptedException();}</code></pre><h1 class=pgc-h-arrow-right><strong>算法筆記</strong></h1><p>下面是源碼中的一部分算法筆記，不會出現在文檔中。</p><p>此類實現W. N. Scherer III和M. L. Scott所著的“不帶條件同步的併發對象的無阻塞”中描述的雙堆棧和雙隊列算法的擴展。</p><p>第十八屆年度大會 （2004年10月，分佈式計算）（另請參見 http://www.cs.rochester.edu/u/scott/synchronization/pseudocode/dals.html ）。</p><p>（Lifo）堆棧用於非公平模式，（Fifo）隊列用於公平模式。</p><p>兩者的性能通常相似。</p><p><strong>Fifo通常在競爭下支持更高的吞吐量，但是Lifo在常見應用程序中保持更高的線程局部性</strong>。</p><p>雙隊列（和類似的堆棧）是在任何給定時間保存“數據”（由put操作提供的項，或“請求”）的插槽，表示 take 操作，或者為空。</p><p>對 <span style="color:#e96900;--tt-darkmode-color: #E96900"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">fulfill</span></span> 的調用（即，從保存數據的隊列中請求元素的調用，反之亦然）使互補節點出隊。</p><div class=pgc-img><img alt="SynchronousQueue 同步隊列入門使用&源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dfc14e8447194971a091db0b7532f7ae><p class=pgc-img-caption></p></div><p><span style="color:#999;--tt-darkmode-color: #999999">互補節點</span></p><p>這些隊列最有趣的功能是，任何操作都可以弄清楚隊列所處的模式，並且無需鎖就可以採取相應的措施。</p><p>隊列和堆棧都擴展了抽象類Transferer，它們定義了執行放置或取出操作的單個方法。</p><p>將它們統一為一個方法，因為在雙重數據結構中，放置和取出操作是對稱的，因此幾乎所有代碼都可以合併。</p><p>最終的傳輸方法長遠來看，但比分解成幾乎重複的部分要容易得多。</p><p>隊列和堆棧數據結構在概念上有很多相似之處，但具體細節很少。</p><p>為簡單起見，它們保持不同，以便以後可以分別發展。</p><p>此處的算法與上述論文中的版本不同，在於擴展了它們以用於同步隊列以及處理取消。</p><p>主要區別包括：</p><ol start=1><li>原始算法使用帶位標記的指針，但此處的算法使用節點中的模式位，從而導致了許多進一步的調整。</li><li>SynchronousQueues必須阻塞等待實現的線程。</li><li>支持通過超時和中斷進行取消，包括從列表中清除已取消的節點/線程，以避免垃圾保留和內存耗盡。</li></ol><p>阻塞主要使用LockSupport park/unpark 來完成，除了看起來像是首先要實現的下一個要暫存的節點外，它還會旋轉一點（僅在多處理器上）。</p><p>在非常繁忙的同步隊列上，旋轉可以大大提高吞吐量。</p><p>在不那麼忙碌的隊列上，自旋的量很小，不足以引起注意。</p><p>在隊列和堆棧中以不同的方式進行清理。</p><p>對於隊列，我們幾乎總是可以在取消節點後的 O(1) 時間內立即刪除該節點（進行模數重試以進行一致性檢查）。</p><p>但是，如果可能將其固定為當前尾巴，則必須等待直到隨後的一些取消。</p><p>對於堆棧，我們需要潛在的 O(n) 遍歷，以確保可以刪除節點，但這可以與其他訪問堆棧的線程同時運行。</p><p>儘管垃圾回收會處理大多數會使非阻塞算法複雜化的節點回收問題，但還是要小心“忘記”對數據，其他節點和可能被阻塞線程長期保留的線程的引用。</p><p><strong>如果設置為null會與主要算法衝突，則可以通過將節點的鏈接更改為現在指向節點本身來完成。</strong></p><p>ps: 這是一個不錯的技巧。</p><p>對於Stack節點，這不會發生太多（因為阻塞的線程不會掛在舊的頭部指針上），但是必須積極地忘記Queue節點中的引用，以防止自到達以來任何節點都曾引用的所有內容都可以訪問。</p><h1 class=pgc-h-arrow-right><strong>內部變量</strong></h1><p>有幾個關於內核數等的相關變量。</p><pre><code>/** ** 內核數，用於自旋鎖控制。** 單核是不能自旋的。**** @author 老馬嘯西風*/static final int NCPUS = Runtime.getRuntime().availableProcessors();/** * 最大的自旋次數，如果是單核，不進行自旋。 * 如果是多核，最多旋轉 32 次。 */static final int maxTimedSpins = (NCPUS &lt; 2) ? 0 : 32;/** * 在阻塞未定時的等待之前旋轉的次數。 * 此值大於定時值，因為非定時等待旋轉得更快，因為他們不需要每次旋轉都檢查時間。 */static final int maxUntimedSpins = maxTimedSpins * 16;/** * 旋轉秒級比使用定時停泊更快的納秒數。  * 粗略的估計就足夠了。 */static final long spinForTimeoutThreshold = 1000L;</code></pre><h1 class=pgc-h-arrow-right><strong>Transferer</strong></h1><h1 class=pgc-h-arrow-right><strong>接口定義</strong></h1><p>一個非常簡單的方法。</p><pre><code>abstract static class Transferer&lt;E&gt; {    abstract E transfer(E e, boolean timed, long nanos);}</code></pre><p>這裡就像算法筆記中說的，使用了隊列（FIFO） 和 堆棧（FILO）</p><div class=pgc-img><img alt="SynchronousQueue 同步隊列入門使用&源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2983104c9993471ab898265885cb4779><p class=pgc-img-caption></p></div><p><span style="color:#999;--tt-darkmode-color: #999999">阻塞隊列</span></p><h1 class=pgc-h-arrow-right><strong>基於隊列</strong></h1><pre><code>/*** * 這擴展了Scherer-Scott雙隊列算法，其不同之處在於，通過使用節點內的模式而不是標記的指針來實現。** 該算法比堆棧的算法更簡單，因為實現者節點，並且匹配是通過CAS將QNode.item字段從非null轉換為null（用於放置）或反之亦然（用於take）來完成的。* * @author 老馬嘯西風* */static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; {    /** 頭結點 */    transient volatile QNode head;    /** 尾節點 */    transient volatile QNode tail;    /**     * 對已取消節點的引用，該節點可能尚未取消與隊列的鏈接，因為它是取消時最後插入的節點。     */    transient volatile QNode cleanMe;    TransferQueue() {        QNode h = new QNode(null, false); // initialize to dummy node.        head = h;        tail = h;    }    /**     * 嘗試以 cas nh 作為新元素； 如果成功，請取消鏈接舊頭的下一個節點，以免造成垃圾遺留。     */    void advanceHead(QNode h, QNode nh) {        if (h == head &amp;&amp;            UNSAFE.compareAndSwapObject(this, headOffset, h, nh))            h.next = h; // forget old next    }    /**     * T嘗試設置 nt 作為新的尾巴元素     */    void advanceTail(QNode t, QNode nt) {        if (tail == t)            UNSAFE.compareAndSwapObject(this, tailOffset, t, nt);    }    /**     * 嘗試 CAS 設置 cleanMe 元素     */    boolean casCleanMe(QNode cmp, QNode val) {        return cleanMe == cmp &amp;&amp;            UNSAFE.compareAndSwapObject(this, cleanMeOffset, cmp, val);    }    // Unsafe 相關屬性    // 這個很多併發類中都有，基本是固定的。    private static final sun.misc.Unsafe UNSAFE;    private static final long headOffset;    private static final long tailOffset;    private static final long cleanMeOffset;    static {        try {            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; k = TransferQueue.class;            headOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("head"));            tailOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("tail"));            cleanMeOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("cleanMe"));        } catch (Exception e) {            throw new Error(e);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>節點定義</strong></h1><pre><code>/** Node class for TransferQueue. */static final class QNode {    volatile QNode next;          // next node in queue    volatile Object item;         // CAS'ed to or from null    volatile Thread waiter;       // to control park/unpark    final boolean isData;    QNode(Object item, boolean isData) {        this.item = item;        this.isData = isData;    }    // 基於 CAS 的設置方法    boolean casNext(QNode cmp, QNode val) {        return next == cmp &amp;&amp;            UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);    }    boolean casItem(Object cmp, Object val) {        return item == cmp &amp;&amp;            UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);    }    /**     * 嘗試通過 CAS 取消元素的引用     */    void tryCancel(Object cmp) {        UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this);    }    // 判斷是否已經取消    boolean isCancelled() {        return item == this;    }    /**     * 下一個指針指向當前類，說明什麼？     * 說明節點已經不再隊列中     */    boolean isOffList() {        return next == this;    }    // Unsafe 的相關實現    private static final sun.misc.Unsafe UNSAFE;    private static final long itemOffset;    private static final long nextOffset;    static {        try {            UNSAFE = sun.misc.Unsafe.getUnsafe();            Class&lt;?&gt; k = QNode.class;            itemOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("item"));            nextOffset = UNSAFE.objectFieldOffset                (k.getDeclaredField("next"));        } catch (Exception e) {            throw new Error(e);        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>transfer 核心方法</strong></h1><p>基本算法是循環嘗試執行以下兩個操作之一：</p><ol start=1><li>如果隊列明顯為空或持有相同模式的節點，請嘗試將節點添加到等待隊列中，等待被實現（或取消）並返回匹配項。</li><li>如果隊列顯然包含等待項，並且此調用是互補模式，請嘗試通過對等待節點的CAS'ing item字段進行出隊並使其出隊，然後返回匹配項來實現。</li></ol><p>在每種情況下，一路檢查並嘗試幫助其他停滯/緩慢的線程推進頭和尾。</p><p>循環以空檢查開始，以防止看到未初始化的頭或尾值。</p><p>這在當前的 SynchronousQueue 中永遠不會發生，但是如果調用者持有對傳輸者的非易失性/最終引用（non-volatile/final），則可能會發生這種情況。</p><p>無論如何，這裡的檢查是因為將空檢查放在循環的頂部，通常比隱式散佈（implicitly interspersed）檢查要快。</p><pre><code>/** * 放入或者獲取一個元素 * @author 老馬嘯西風 */@SuppressWarnings("unchecked")E transfer(E e, boolean timed, long nanos) {    QNode s = null; // constructed/reused as needed    boolean isData = (e != null);    for (;;) {        QNode t = tail;        QNode h = head;        // 元素未初始化完成，自旋。        if (t == null || h == null)                    continue;                             // 如果為空，或者持有相同模式的節點        if (h == t || t.isData == isData) {             QNode tn = t.next;            // 元素被其他線程修改，重來            if (t != tail)                                 continue;            // 嘗試節點加入到 tail                if (tn != null) {                            advanceTail(t, tn);                continue;            }            // 時間不等人，直接返回 null            if (timed &amp;&amp; nanos &lt;= 0)                    return null;            // 設置新元素失敗，重來            if (s == null)                s = new QNode(e, isData);            if (!t.casNext(null, s))                        continue;            // 添加到尾部等待            advanceTail(t, s);                        // 旋轉/阻塞，直到滿足節點s為止。            Object x = awaitFulfill(s, e, timed, nanos);            // 等待被取消，清空元素，並且返回 null            if (x == s) {                   clean(t, s);                return null;            }            // 元素已經不再隊列中了，            if (!s.isOffList()) {           // not already unlinked                // 設置 s 為新的頭結點                advanceHead(t, s);                    if (x != null)              // and forget fields                    s.item = s;                s.waiter = null;            }            return (x != null) ? (E)x : e;        } else {                   // 互補模式 complementary-mode             // 這裡就是上面說的第二種算法模式                                 QNode m = h.next;                          // 已經被其他線程修改，重來            if (t != tail || m == null || h != head)                continue;                   // inconsistent read            Object x = m.item;            // 元素 CAS 失敗，執行出隊，進行重試。            if (isData == (x != null) ||    // m already fulfilled                x == m ||                   // m cancelled                !m.casItem(x, e)) {         // lost CAS                advanceHead(h, m);          // dequeue and retry                continue;            }            // 成功設置            advanceHead(h, m);              // successfully fulfilled            LockSupport.unpark(m.waiter);            return (x != null) ? (E)x : e;        }    }}</code></pre><h1 class=pgc-h-arrow-right><strong>awaitFulfill 等待直到節點滿足條件</strong></h1><pre><code>/** * 旋轉/阻止，直到滿足節點s為止。 * * @param s the waiting node * @param e the comparison value for checking match * @param timed true if timed wait * @param nanos timeout value * @return matched item, or s if cancelled * @author 老馬嘯西風 */Object awaitFulfill(QNode s, E e, boolean timed, long nanos) {    /* Same idea as TransferStack.awaitFulfill */    // deadline 是第一生產力    // 我們設置一個超時時間，避免一直等待下去。    final long deadline = timed ? System.nanoTime() + nanos : 0L;    // 這 3 目運算符用的人腦袋疼。    Thread w = Thread.currentThread();    int spins = ((head.next == s) ?                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);    for (;;) {        // 如果當前線程被打斷，嘗試取消。        if (w.isInterrupted())            s.tryCancel(e);        Object x = s.item;        // 如果 s.item 與 e 不等，直接返回 x        if (x != e)            return x;        if (timed) {            // 計算超時時間，超時之後嘗試取消。            nanos = deadline - System.nanoTime();            if (nanos &lt;= 0L) {                s.tryCancel(e);                continue;            }        }        // 更新自旋次數        if (spins &gt; 0)            --spins;        // 如果 waiter 為 null,設置為當前線程。            else if (s.waiter == null)            s.waiter = w;        else if (!timed)            // 通過 LockSupport 進行 park，區別只是是否有超時時間。            LockSupport.park(this);        else if (nanos &gt; spinForTimeoutThreshold)            LockSupport.parkNanos(this, nanos);    }}</code></pre><h1 class=pgc-h-arrow-right><strong>clean 清空操作</strong></h1><p>在任何給定時間，列表中的一個節點都不能刪除-最後插入的節點。</p><p>為了解決這個問題，如果我們不能刪除s，我們將其前身保存為 <span style="color:#e96900;--tt-darkmode-color: #E96900"><span style="background-color:#f8f8f8;--tt-darkmode-bgcolor: #191919">cleanMe</span></span>，首先刪除之前保存的版本。</p><p>可以始終刪除節點s或先前保存的節點中的至少一個，因此該操作始終終止。</p><pre><code>/** * 使用原始的前任pred擺脫已取消的節點s。 * @author 老馬嘯西風 */void clean(QNode pred, QNode s) {    // 清空 waiter 信息    s.waiter = null;     while (pred.next == s) { //如果已取消鏈接，請提早返回        QNode h = head;        QNode hn = h.next;           //設置已取消的第一個節點為head        if (hn != null &amp;&amp; hn.isCancelled()) {            advanceHead(h, hn);            continue;        }        // 保證一致性讀        QNode t = tail;      // Ensure consistent read for tail        // 為空，直接返回        if (t == h)            return;        // 不一致，重試            QNode tn = t.next;        if (t != tail)            continue;        // 嘗試設置 tail 信息            if (tn != null) {            advanceTail(t, tn);            continue;        }        // 如果 s 節點不是尾巴節點，嘗試進行 unsplice        if (s != t) {                  QNode sn = s.next;            if (sn == s || pred.casNext(s, sn))                return;        }        QNode dp = cleanMe;        //嘗試取消鏈接先前取消的節點        if (dp != null) {                QNode d = dp.next;            QNode dn;            if (d == null ||               // d is gone or                d == dp ||                 // d is off list or                !d.isCancelled() ||        // d not cancelled or                (d != t &amp;&amp;                 // d not tail and                 (dn = d.next) != null &amp;&amp;  //   has successor                 dn != d &amp;&amp;                //   that is on list                 dp.casNext(d, dn)))       // d unspliced                // 通過 CAS 清空 dp                casCleanMe(dp, null);            // s 已經保存在信息中，直接返回                if (dp == pred)                return;              } else if (casCleanMe(null, pred))            return;          // Postpone cleaning s    }}</code></pre><h1 class=pgc-h-arrow-right><strong>基於堆棧</strong></h1><p>還有基於 stack 的實現。</p><p>不過思想都是類似的，此處為了閱讀體驗不再展開。</p><p>感興趣的小夥伴點擊 {閱讀原文}，獲取完整的閱讀體驗。</p><h1 class=pgc-h-arrow-right><strong>小結</strong></h1><p>阻塞隊列大家族的成員共計 5 位，SynchronousQueue 是其中非常優秀的一份子。</p><p>工作學習中希望可以活學活用，提升工作效率，寫出更加優異的代碼。</p><p>希望本文對你有幫助，如果有其他想法的話，也可以評論區和大家分享哦。</p><p>各位<strong>極客</strong>的點贊收藏轉發，是老馬持續寫作的最大動力！</p><p><br></p><div class=pgc-img><img alt="SynchronousQueue 同步隊列入門使用&源碼詳解" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c55bbaef2e734c6cb952cc9b39ccc7d0><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>SynchronousQueue</a></li><li><a>源碼</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html alt=詳解13項鋼筋安裝質量標準及通病防治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fd3ff534941a487884c7a67361337cfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html title=詳解13項鋼筋安裝質量標準及通病防治>詳解13項鋼筋安裝質量標準及通病防治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html alt=史上最全電路圖詳解！老電工都收藏了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533138404073909636bf43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html title=史上最全電路圖詳解！老電工都收藏了！>史上最全電路圖詳解！老電工都收藏了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html alt=每一滴油力爭做到不浪費，詳解各種燃油噴射方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/3ed00001d75ac552f05c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79cb5594.html title=每一滴油力爭做到不浪費，詳解各種燃油噴射方式>每一滴油力爭做到不浪費，詳解各種燃油噴射方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html alt="Excel萬金油套路詳解 單條件查找返回多行數據" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2633664673fd439a862a2527763e82c7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea3618a.html title="Excel萬金油套路詳解 單條件查找返回多行數據">Excel萬金油套路詳解 單條件查找返回多行數據</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html alt=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7360fe7df5e241e7af4b15f75f6474fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d1e6d96.html title=詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍>詳解如何使用sum+offset+match函數進行動態區域求和，大神祕籍</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>