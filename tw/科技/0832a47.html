<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>輕鬆學會 React 鉤子：以 useEffect() 為例 | 极客快訊</title><meta property="og:title" content="輕鬆學會 React 鉤子：以 useEffect() 為例 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/SAeE5m89B94hKl"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0832a47.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0832a47.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0832a47.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0832a47.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0832a47.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0832a47.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0832a47.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0832a47.html><meta property="article:published_time" content="2020-10-29T20:59:18+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:18+08:00"><meta name=Keywords content><meta name=description content="輕鬆學會 React 鉤子：以 useEffect() 為例"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0832a47.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>輕鬆學會 React 鉤子：以 useEffect() 為例</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>五年多前，我寫過 React 系列教程[1]。不用說，內容已經有些過時了。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAeE5m89B94hKl><p>我本來不想碰它們了，覺得框架一直在升級，教程寫出來就會過時。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAeE5ml2DUn3hy><p>但是，最近我逐漸體會到 React 鉤子（hooks）非常好用，重新認識了 React 這個框架，覺得應該補上關於鉤子的部分。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAeE5n7J5ShF3o><p>下面就來談談，怎樣正確理解鉤子，並且深入剖析最重要的鉤子之一的<code>useEffect</code>。內容會盡量通俗，讓不熟悉 React 的朋友也能看懂。歡迎大家參考我以前寫的《React 框架入門》[2]和《React 最常用的四個鉤子》[3]。</p><blockquote><p>本文得到了 開課吧 的支持，結尾有 React 視頻學習資料。希望通過視頻來系統學習 React 的同學，可以關注。</p></blockquote><p></p><h1 toutiao-origin=h2>一、React 的兩套 API</h1><p>以前，React API 只有一套，現在有兩套：類（class）API 和基於函數的鉤子（hooks） API。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAeE5np58XhVId><p>任何一個組件，可以用類來寫，也可以用鉤子來寫。下面是類的寫法。</p><pre><code>class Welcome extends React.Component {<br>render {<br>return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;<br>}<br>}<br></code></pre><p>再來看鉤子的寫法，也就是函數。</p><pre><code>function Welcome(props) {<br>return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>}<br></code></pre><p>這兩種寫法，作用完全一樣。初學者自然會問：“我應該使用哪一套 API？”</p><p>官方推薦[4]使用鉤子（函數），而不是類。因為鉤子更簡潔，代碼量少，用起來比較“輕”，而類比較“重”。而且，鉤子是函數，更符合 React 函數式的本質。</p><p>下面是類組件（左邊）和函數組件（右邊）代碼量的比較。對於複雜的組件，差的就更多。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/SAeE5oCGscZvrP><p>但是，鉤子的靈活性太大，初學者不太容易理解。很多人一知半解，很容易寫出混亂不堪、無法維護的代碼。那就不如使用類了。因為類有很多強制的語法約束，不容易搞亂。</p><p></p><h1 toutiao-origin=h2>二、類和函數的差異</h1><p>嚴格地說，類組件和函數組件是有差異的。不同的寫法，代表了不同的編程方法論。</p><p>類（class）是數據和邏輯的封裝。 也就是說，組件的狀態和操作方法是封裝在一起的。如果選擇了類的寫法，就應該把相關的數據和操作，都寫在同一個 class 裡面。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAeE6Q4kkf28V><p>函數一般來說，只應該做一件事，就是返回一個值。 如果你有多個操作，每個操作應該寫成一個單獨的函數。而且，數據的狀態應該與操作方法分離。根據這種理念，React 的函數組件只應該做一件事情：返回組件的 HTML 代碼，而沒有其他的功能。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAeE6QX4ji9CfW><p>還是以上面的函數組件為例。</p><pre><code>function Welcome(props) {<br>return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>}<br></code></pre><p>這個函數只做一件事，就是根據輸入的參數，返回組件的 HTML 代碼。這種只進行單純的數據計算（換算）的函數，在函數式編程裡面稱為 “純函數”（pure function）。</p><p></p><h1 toutiao-origin=h2>三、副效應是什麼？</h1><p>看到這裡，你可能會產生一個疑問：如果純函數只能進行數據計算，那些不涉及計算的操作（比如生成日誌、儲存數據、改變應用狀態等等）應該寫在哪裡呢？</p><p>函數式編程將那些跟數據計算無關的操作，都稱為 “副效應” （side effect） 。如果函數內部直接包含產生副效應的操作，就不再是純函數了，我們稱之為不純的函數。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAeE6QwCHzmtYf><p>純函數內部只有通過間接的手段（即通過其他函數調用），才能包含副效應。</p><p></p><h1 toutiao-origin=h2>四、鉤子（hook）的作用</h1><p>說了半天，那麼鉤子到底是什麼？</p><p>一句話，鉤子（hook）就是 React 函數組件的副效應解決方案，用來為函數組件引入副效應。 函數組件的主體只應該用來返回組件的 HTML 代碼，所有的其他操作（副效應）都必須通過鉤子引入。</p><p>由於副效應非常多，所以鉤子有許多種。React 為許多常見的操作（副效應），都提供了專用的鉤子。</p><ul><li><p><code>useState</code>：保存狀態</p></li><li><p><code>useContext</code>：保存上下文</p></li><li><p><code>useRef</code>：保存引用</p></li><li><p>……</p></li></ul><p>上面這些鉤子，都是引入某種特定的副效應，而 <code>useEffect</code>是通用的副效應鉤子。找不到對應的鉤子時，就可以用它。其實，從名字也可以看出來，它跟副效應（side effect）直接相關。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAeE6RVBYuH9Rp><p></p><h1 toutiao-origin=h2>五、useEffect 的用法</h1><p><code>useEffect</code>本身是一個函數，由 React 框架提供，在函數組件內部調用即可。</p><p>舉例來說，我們希望組件加載以後，網頁標題（<code>document.title</code>）會隨之改變。那麼，改變網頁標題這個操作，就是組件的副效應，必須通過<code>useEffect</code>來實現。</p><pre><code>import React, { useEffect } from 'react';<br><br>function Welcome(props) {<br>useEffect( =&gt; {<br>document.title = '加載完成';<br>});<br>return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>}<br></code></pre><p>上面例子中，<code>useEffect</code>的參數是一個函數，它就是所要完成的副效應（改變網頁標題）。組件加載以後，React 就會執行這個函數。（查看運行結果[5]）</p><p><code>useEffect</code>的作用就是指定一個副效應函數，組件每渲染一次，該函數就自動執行一次。組件首次在網頁 DOM 加載後，副效應函數也會執行。</p><p></p><h1 toutiao-origin=h2>六、useEffect 的第二個參數</h1><p>有時候，我們不希望<code>useEffect</code>每次渲染都執行，這時可以使用它的第二個參數，使用一個數組指定副效應函數的依賴項，只有依賴項發生變化，才會重新渲染。</p><pre><code>function Welcome(props) {<br>useEffect( =&gt; {<br>document.title = `Hello, ${props.name}`;<br>}, [props.name]);<br>return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;<br>}<br></code></pre><p>上面例子中，<code>useEffect</code>的第二個參數是一個數組，指定了第一個參數（副效應函數）的依賴項（<code>props.name</code>）。只有該變量發生變化時，副效應函數才會執行。</p><p>如果第二個參數是一個空數組，就表明副效應參數沒有任何依賴項。因此，副效應函數這時只會在組件加載進入 DOM 後執行一次，後面組件重新渲染，就不會再次執行。這很合理，由於副效應不依賴任何變量，所以那些變量無論怎麼變，副效應函數的執行結果都不會改變，所以運行一次就夠了。</p><p></p><h1 toutiao-origin=h2>七、useEffect 的用途</h1><p>只要是副效應，都可以使用<code>useEffect</code>引入。它的常見用途有下面幾種。</p><ul><li><p>獲取數據（data fetching）</p></li><li><p>事件監聽或訂閱（setting up a subscription）</p></li><li><p>改變 DOM（changing the DOM）</p></li><li><p>輸出日誌（logging）</p></li></ul><p>下面是從遠程服務器獲取數據的例子。（查看運行結果[6]）</p><pre><code>import React, { useState, useEffect } from 'react';<br>import axios from 'axios';<br><br>function App {<br>const [data, setData] = useState({ hits: [] });<br><br>useEffect( =&gt; {<br>const fetchData = async  =&gt; {<br>const result = await axios(<br>'https://hn.algolia.com/api/v1/search?query=redux',<br>);<br><br>setData(result.data);<br>};<br><br>fetchData;<br>}, );<br><br>return (<br>&lt;ul&gt;<br>{data.hits.map(item =&gt; (<br>&lt;li key={item.objectID}&gt;<br>&lt;a href={item.url}&gt;{item.title}&lt;/a&gt;<br>&lt;/li&gt;<br>))}<br>&lt;/ul&gt;<br>);<br>}<br><br>export default App;<br></code></pre><p>上面例子中，<code>useState</code>用來生成一個狀態變量（<code>data</code>），保存獲取的數據；<code>useEffect</code>的副效應函數內部有一個 async 函數，用來從服務器異步獲取數據。拿到數據以後，再用<code>setData</code>觸發組件的重新渲染。</p><p>由於獲取數據只需要執行一次，所以上例的<code>useEffect</code>的第二個參數為一個空數組。</p><p></p><h1 toutiao-origin=h2>八、useEffect 的返回值</h1><p>副效應是隨著組件加載而發生的，那麼組件卸載時，可能需要清理這些副效應。</p><p><code>useEffect</code>允許返回一個函數，在組件卸載時，執行該函數，清理副效應。如果不需要清理副效應，<code>useEffect</code>就不用返回任何值。</p><pre><code>useEffect( =&gt; {<br>const subscription = props.source.subscribe;<br>return  =&gt; {<br>subscription.unsubscribe;<br>};<br>}, [props.source]);<br></code></pre><p>上面例子中，<code>useEffect</code>在組件加載時訂閱了一個事件，並且返回一個清理函數，在組件卸載時取消訂閱。</p><p>實際使用中，由於副效應函數默認是每次渲染都會執行，所以清理函數不僅會在組件卸載時執行一次，組件每次重新渲染之前，也會執行一次，用來清理上一次渲染的副效應。</p><p></p><h1 toutiao-origin=h2>九、useEffect 的注意點</h1><p>使用<code>useEffect</code>時，有一點需要注意。如果有多個副效應，應該調用多個<code>useEffect</code>，而不應該合併寫在一起。</p><pre><code>function App {<br>const [varA, setVarA] = useState(0);<br>const [varB, setVarB] = useState(0);<br>useEffect( =&gt; {<br>const timeoutA = setTimeout( =&gt; setVarA(varA + 1), 1000);<br>const timeoutB = setTimeout( =&gt; setVarB(varB + 2), 2000);<br><br>return  =&gt; {<br>clearTimeout(timeoutA);<br>clearTimeout(timeoutB);<br>};<br>}, [varA, varB]);<br><br>return &lt;span&gt;{varA}, {varB}&lt;/span&gt;;<br>}<br></code></pre><p>上面的例子是錯誤的寫法，副效應函數裡面有兩個定時器，它們之間並沒有關係，其實是兩個不相關的副效應，不應該寫在一起。正確的寫法是將它們分開寫成兩個<code>useEffect</code>。</p><pre><code>function App {<br>const [varA, setVarA] = useState(0);<br>const [varB, setVarB] = useState(0);<br><br>useEffect( =&gt; {<br>const timeout = setTimeout( =&gt; setVarA(varA + 1), 1000);<br>return  =&gt; clearTimeout(timeout);<br>}, [varA]);<br><br>useEffect( =&gt; {<br>const timeout = setTimeout( =&gt; setVarB(varB + 2), 2000);<br><br>return  =&gt; clearTimeout(timeout);<br>}, [varB]);<br><br>return &lt;span&gt;{varA}, {varB}&lt;/span&gt;;<br>}<br></code></pre><p></p><h1 toutiao-origin=h2>十、參考鏈接</h1><ul><li><p>React useEffect: 4 Tips Every Developer Should Know[7], Helder Esteves</p></li><li><p>Using the Effect Hook[8], React</p></li><li><p>How to fetch data with React Hooks?[9], Robin Wieruch</p></li></ul><p>（正文完）</p><p></p><h1 toutiao-origin=h2>React 系統視頻</h1><p>對於每個想進大廠的前端開發者來說，React 是繞不過的坎，面試肯定會問到，業務也很可能會用。不懂一點 React 技術棧，大大降低了個人競爭力。</p><p>退一步說，即使你用不到 React，但是它的很多思想已經影響到了整個業界，比如虛擬 DOM、JSX、函數式編程、immutable 的狀態、單向數據流等等。懂了 React，面對其他輪子時，你也能得心應手。</p><p>但是，大家都知道 React 學習曲線比較陡峭，不少人抱怨：苦苦學了1個多月卻進展緩慢怎麼辦？</p><p>彆著急，這裡有一份開課吧的 《React 原理剖析 + 組件化》 系統視頻。不僅講解了原理，還包括了綜合性的實戰項目，裡面用到了 react-router、redux、react-redux、antd 等 React 全家桶。</p><img alt="輕鬆學會 React 鉤子：以 useEffect() 為例" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S9a43BC3ecTjsX><p>（完）</p><p>[1]</p><p>React 系列教程:<em>http://www.ruanyifeng.com/blog/2016/09/react-technology-stack.html</em></p><p>[2]</p><p>《React 框架入門》:<em>http://www.ruanyifeng.com/blog/2015/03/react.html</em></p><p>[3]</p><p>《React 最常用的四個鉤子》:<em>http://www.ruanyifeng.com/blog/2019/09/react-hooks.html</em></p><p>[4]</p><p>推薦:<em>https://reactjs.org/docs/hooks-faq.html#should-i-use-hooks-classes-or-a-mix-of-both</em></p><p>[5]</p><p>查看運行結果:<em>https://codesandbox.io/s/interesting-dubinsky-dx6oq?file=/src/index.js</em></p><p>[6]</p><p>查看運行結果:<em>https://codesandbox.io/s/intelligent-yonath-olihz?file=/src/index.js</em></p><p>[7]</p><p>React useEffect: 4 Tips Every Developer Should Know:<em>https://medium.com/swlh/useeffect-4-tips-every-developer-should-know-54b188b14d9c</em></p><p>[8]</p><p>Using the Effect Hook:<em>https://reactjs.org/docs/hooks-effect.html</em></p><p>[9]</p><p>How to fetch data with React Hooks?:<em>https://www.robinwieruch.de/react-hooks-fetch-data</em></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>React</a></li><li><a>鉤子</a></li><li><a>useEffect</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9913d581.html alt="展望 React 17，回顧 React 往事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/94e62a684e6e4c7b9c239cd889512232 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9913d581.html title="展望 React 17，回顧 React 往事">展望 React 17，回顧 React 往事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cd5c6f.html alt=React的組件動態參數使用Underscore和Context來傳遞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e84000147954a5e76e8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cd5c6f.html title=React的組件動態參數使用Underscore和Context來傳遞>React的組件動態參數使用Underscore和Context來傳遞</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/78f7dde.html alt="Nike Epic React Flyknit 全新灰藍配色" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/5e37000a42e4a2448441 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/78f7dde.html title="Nike Epic React Flyknit 全新灰藍配色">Nike Epic React Flyknit 全新灰藍配色</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>