<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>[Spring] 深入瞭解事務原理 | 极客快訊</title><meta property="og:title" content="[Spring] 深入瞭解事務原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/090306a0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/090306a0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/090306a0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/090306a0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/090306a0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/090306a0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/090306a0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/090306a0.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="[Spring] 深入瞭解事務原理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/090306a0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>[Spring] 深入瞭解事務原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h2 class=pgc-h-arrow-right>Spring事務的基本原理</h2><p>Spring事務的本質其實就是數據庫對事務的支持，沒有數據庫的事務支持，spring是無法提供事務功能的。對於純JDBC操作數據庫，想要用到事務，可以按照以下步驟進行：</p><ol start=1><li>獲取連接 Connection con = DriverManager.getConnection()</li><li>開啟事務con.setAutoCommit(true/false);</li><li>執行CRUD</li><li>提交事務/回滾事務 con.commit() / con.rollback();</li><li>關閉連接 conn.close();</li></ol><p>使用Spring的事務管理功能後，我們可以不再寫步驟 2 和 4 的代碼，而是由Spirng 自動完成。那麼Spring是如何在我們書寫的 CRUD 之前和之後開啟事務和關閉事務的呢？解決這個問題，也就可以從整體上理解Spring的事務管理實現原理了。</p><p>下面簡單地介紹下，註解方式為例子</p><ol start=1><li>配置文件開啟註解驅動，在相關的類和方法上通過註解@Transactional標識。</li><li>spring 在啟動的時候會去解析生成相關的bean，這時候會查看擁有相關注解的類和方法，並且為這些類和方法生成代理，並根據@Transaction的相關參數進行相關配置注入，這樣就在代理中為我們把相關的事務處理掉了（開啟正常提交事務，異常回滾事務）。</li><li>真正的數據庫層的事務提交和回滾是通過binlog或者redo log實現的。</li></ol><h2 class=pgc-h-arrow-right>Spring的事務機制</h2><p>所有的數據訪問技術都有事務處理機制，這些技術提供了API用來開啟事務、提交事務來完成數據操作，或者在發生錯誤的時候回滾數據。</p><p>而Spring的事務機制是用統一的機制來處理不同數據訪問技術的事務處理。Spring的事務機制提供了一個PlatformTransactionManager接口，不同的數據訪問技術的事務使用不同的接口實現，如表所示。</p><p><strong>數據訪問技術及實現</strong></p><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670><p class=pgc-img-caption></p></div><p>在程序中定義事務管理器的代碼如下：</p><p><br></p><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5838f96138df400db53c089512cb2f25><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>聲明式事務</h2><p>Spring支持聲明式事務，即使用註解來選擇需要使用事務的方法，它使用@Transactional註解在方法上表明該方法需要事務支持。這是一個基於AOP的實現操作。</p><p><br></p><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c4e48e2c446f4102a3fa103ee000553a><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>AOP 代理的兩種實現：</h2><ul class=list-paddingleft-2><li>jdk是代理接口，私有方法必然不會存在在接口裡，所以就不會被攔截到；</li><li>cglib是子類，private的方法照樣不會出現在子類裡，也不能被攔截。</li></ul><h2 class=pgc-h-arrow-right>Java 動態代理。</h2><p>具體有如下四步驟：</p><ol start=1><li>通過實現 InvocationHandler 接口創建自己的調用處理器；</li><li>通過為 Proxy 類指定 ClassLoader 對象和一組 interface 來創建動態代理類；</li><li>通過反射機制獲得動態代理類的構造函數，其唯一參數類型是調用處理器接口類型；</li><li>通過構造函數創建動態代理類實例，構造時調用處理器對象作為參數被傳入。</li></ol><h2 class=pgc-h-arrow-right>GCLIB代理</h2><p>cglib（Code Generation Library）是一個強大的,高性能,高質量的Code生成類庫。它可以在運行期擴展Java類與實現Java接口。</p><ul class=list-paddingleft-2><li>cglib封裝了asm，可以在運行期動態生成新的class（子類）。</li><li>cglib用於AOP，jdk中的proxy必須基於接口，cglib卻沒有這個限制。</li></ul><h2 class=pgc-h-arrow-right>原理區別：</h2><p>java動態代理是利用反射機制生成一個實現代理接口的匿名類，在調用具體方法前調用InvokeHandler來處理。而cglib動態代理是利用asm開源包，對代理對象類的class文件加載進來，通過修改其字節碼生成子類來處理。</p><ol start=1><li>如果目標對象實現了接口，默認情況下會採用JDK的動態代理實現AOP</li><li>如果目標對象實現了接口，可以強制使用CGLIB實現AOP</li><li>如果目標對象沒有實現了接口，必須採用CGLIB庫，spring會自動在JDK動態代理和CGLIB之間轉換</li></ol><p><strong>如果是類內部方法直接不是走代理，這個時候可以通過維護一個自身實例的代理。</strong></p><p><br></p><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9021853ff31348be862fc500f05d031e><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>Spring 事務的傳播屬性</h2><p>所謂spring事務的傳播屬性，就是定義在存在多個事務同時存在的時候，spring應該如何處理這些事務的行為。這些屬性在TransactionDefinition中定義，具體常量的解釋見下表：</p><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/38e2b8039ddc473ba619ddb5115bbdf6><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>數據庫隔離級別</h2><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d7eca21d7614f84ac04e3f6eaf6d6e7><p class=pgc-img-caption></p></div><p><strong>髒讀：</strong>一事務對數據進行了增刪改，但未提交，另一事務可以讀取到未提交的數據。如果第一個事務這時候回滾了，那麼第二個事務就讀到了髒數據。</p><p><strong>不可重複讀：</strong>一個事務中發生了兩次讀操作，第一次讀操作和第二次操作之間，另外一個事務對數據進行了修改，這時候兩次讀取的數據是不一致的。</p><p><strong>幻讀：</strong>第一個事務對一定範圍的數據進行批量修改，第二個事務在這個範圍增加一條數據，這時候第一個事務就會丟失對新增數據的修改。</p><p><strong>總結：</strong></p><p>隔離級別越高，越能保證數據的完整性和一致性，但是對併發性能的影響也越大。</p><p>大多數的數據庫默認隔離級別為 Read Commited，比如 SqlServer、Oracle</p><p>少數數據庫默認隔離級別為：Repeatable Read 比如：MySQL InnoDB</p><h2 class=pgc-h-arrow-right>Spring中的隔離級別</h2><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6dfd4f95ca8441f78d50f2d0f3e21f17><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>事務的嵌套</h2><p>通過上面的理論知識的鋪墊，我們大致知道了數據庫事務和spring事務的一些屬性和特點，接下來我們通過分析一些嵌套事務的場景，來深入理解spring事務傳播的機制。</p><p>假設外層事務 Service A 的 Method A() 調用 內層Service B 的 Method B()</p><h3 class=pgc-h-arrow-right>PROPAGATION_REQUIRED(spring 默認)</h3><p>如果ServiceB.methodB() 的事務級別定義為 PROPAGATION_REQUIRED，那麼執行 ServiceA.methodA() 的時候spring已經起了事務，這時調用 ServiceB.methodB()，ServiceB.methodB() 看到自己已經運行在 ServiceA.methodA() 的事務內部，就不再起新的事務。</p><p>假如 ServiceB.methodB() 運行的時候發現自己沒有在事務中，他就會為自己分配一個事務。</p><p>這樣，在 ServiceA.methodA() 或者在 ServiceB.methodB() 內的任何地方出現異常，事務都會被回滾。</p><h3 class=pgc-h-arrow-right>PROPAGATION_REQUIRES_NEW</h3><p>比如我們設計 ServiceA.methodA() 的事務級別為 PROPAGATION_REQUIRED，ServiceB.methodB() 的事務級別為 PROPAGATION_REQUIRES_NEW。</p><p>那麼當執行到 ServiceB.methodB() 的時候，ServiceA.methodA() 所在的事務就會掛起，ServiceB.methodB() 會起一個新的事務，等待 ServiceB.methodB() 的事務完成以後，它才繼續執行。</p><p>他與 PROPAGATION_REQUIRED 的事務區別在於事務的回滾程度了。因為 ServiceB.methodB() 是新起一個事務，那麼就是存在兩個不同的事務。如果 ServiceB.methodB() 已經提交，那麼 ServiceA.methodA() 失敗回滾，ServiceB.methodB() 是不會回滾的。如果 ServiceB.methodB() 失敗回滾，如果他拋出的異常被 ServiceA.methodA() 捕獲，ServiceA.methodA() 事務仍然可能提交(主要看B拋出的異常是不是A會回滾的異常)。</p><h3 class=pgc-h-arrow-right>PROPAGATION_SUPPORTS</h3><p>假設ServiceB.methodB() 的事務級別為 PROPAGATION_SUPPORTS，那麼當執行到ServiceB.methodB()時，如果發現ServiceA.methodA()已經開啟了一個事務，則加入當前的事務，如果發現ServiceA.methodA()沒有開啟事務，則自己也不開啟事務。這種時候，內部方法的事務性完全依賴於最外層的事務。</p><h3 class=pgc-h-arrow-right>PROPAGATION_NESTED</h3><p>現在的情況就變得比較複雜了, ServiceB.methodB() 的事務屬性被配置為 PROPAGATION_NESTED, 此時兩者之間又將如何協作呢? ServiceB#methodB 如果 rollback, 那麼內部事務(即 ServiceB#methodB) 將回滾到它執行前的 SavePoint 而外部事務(即 ServiceA#methodA) 可以有以下兩種處理方式:</p><p><strong>a、捕獲異常，執行異常分支邏輯</strong></p><p><br></p><div class=pgc-img><img alt="[Spring] 深入瞭解事務原理" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ac28cfcebf441348d1af76c2ffa5802><p class=pgc-img-caption></p></div><p>這種方式也是嵌套事務最有價值的地方, 它起到了分支執行的效果, 如果 ServiceB.methodB 失敗, 那麼執行 ServiceC.methodC(), 而 ServiceB.methodB 已經回滾到它執行之前的 SavePoint, 所以不會產生髒數據(相當於此方法從未執行過), 這種特性可以用在某些特殊的業務中, 而 PROPAGATION_REQUIRED 和 PROPAGATION_REQUIRES_NEW 都沒有辦法做到這一點。</p><p><strong>b、 外部事務回滾/提交 代碼不做任何修改</strong>， 那麼如果內部事務(ServiceB#methodB) rollback, 那麼首先 ServiceB.methodB 回滾到它執行之前的 SavePoint(在任何情況下都會如此), 外部事務(即 ServiceA#methodA) 將根據具體的配置決定自己是 commit 還是 rollback</p><p>另外三種事務傳播屬性基本用不到，在此不做分析。</p><h3 class=pgc-h-arrow-right>總結</h3><p>對於項目中需要使用到事務的地方，我建議開發者還是使用spring的TransactionCallback接口來實現事務，不要盲目使用spring事務註解，如果一定要使用註解，那麼一定要對spring事務的傳播機制和隔離級別有個詳細的瞭解，否則很可能發生意想不到的效果。</p><h2 class=pgc-h-arrow-right>Spring Boot 對事務的支持</h2><p>通過org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration類。我們可以看出Spring Boot自動開啟了對註解事務的支持 Spring</p><h2 class=pgc-h-arrow-right>只讀事務（@Transactional(readOnly = true)）的一些概念</h2><h3 class=pgc-h-arrow-right>概念：</h3><p>從這一點設置的時間點開始（時間點a）到這個事務結束的過程中，其他事務所提交的數據，該事務將看不見！（查詢中不會出現別人在時間點a之後提交的數據）。</p><p>@Transcational(readOnly=true) 這個註解一般會寫在業務類上，或者其方法上，用來對其添加事務控制。當括號中添加readOnly=true, 則會告訴底層數據源，這個是一個只讀事務，對於JDBC而言，只讀事務會有一定的速度優化。</p><p>而這樣寫的話，事務控制的其他配置則採用默認值，事務的隔離級別(isolation) 為DEFAULT,也就是跟隨底層數據源的隔離級別，事務的傳播行為(propagation)則是REQUIRED，所以還是會有事務存在，一代在代碼中拋出RuntimeException，依然會導致事務回滾。</p><h3 class=pgc-h-arrow-right>應用場合：</h3><ul class=list-paddingleft-2><li>如果你一次執行單條查詢語句，則沒有必要啟用事務支持，數據庫默認支持SQL執行期間的讀一致性；</li><li>如果你一次執行多條查詢語句，例如統計查詢，報表查詢，在這種場景下，多條查詢SQL必須保證整體的讀一致性，否則，在前條SQL查詢之後，後條SQL查詢之前，數據被其他用戶改變，則該次整體的統計查詢將會出現讀數據不一致的狀態，此時，應該啟用事務支持。</li></ul><p>【注意是一次執行多次查詢來統計某些信息，這時為了保證數據整體的一致性，要用只讀事務】</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>瞭解</a></li><li><a>事務</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html alt=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/433259b5-1936-4cee-ab74-70aef36536ee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1678b1c4.html title=（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理>（收藏）Spring事務專題：事務的基本概念，Mysql事務處理原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcf7d4b4.html alt="Spring事務失效的 8 大原因，這次可以吊打面試官了" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcf7d4b4.html title="Spring事務失效的 8 大原因，這次可以吊打面試官了">Spring事務失效的 8 大原因，這次可以吊打面試官了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3f4eef.html alt="你真的瞭解 Spring 框架中的註解注入嗎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/82e666b274de46dda4913c65ea546a6e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3f4eef.html title="你真的瞭解 Spring 框架中的註解注入嗎">你真的瞭解 Spring 框架中的註解注入嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9fda6a1.html alt=Spring事務的三個坑，你踩過幾個呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/a9ecbb60-4a8e-42b9-98f4-a8925075f9b3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9fda6a1.html title=Spring事務的三個坑，你踩過幾個呢？>Spring事務的三個坑，你踩過幾個呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b748ad6.html alt="使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae11deaa7ce44232a1fa67b224125bb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b748ad6.html title="使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？">使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6e45b3.html alt=瞭解兩階段提交分佈式事務的工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1540307589171a8f0f92c71 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6e45b3.html title=瞭解兩階段提交分佈式事務的工作原理>瞭解兩階段提交分佈式事務的工作原理</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/f711270.html alt=分佈式事務瞭解嗎？你們是如何解決分佈式事務問題的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/7b3fa178c3324e3fb981086305aa9bae style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/f711270.html title=分佈式事務瞭解嗎？你們是如何解決分佈式事務問題的？>分佈式事務瞭解嗎？你們是如何解決分佈式事務問題的？</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/36ff1f1.html alt=有關Spring事務，看這一篇就足夠了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/82ef9adc02ab44258403653c42dda8f4 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/36ff1f1.html title=有關Spring事務，看這一篇就足夠了>有關Spring事務，看這一篇就足夠了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html alt=兩分鐘瞭解低損耗電纜結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9af84f52bbed4ee39f3825e0f43e619b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5010a4b6.html title=兩分鐘瞭解低損耗電纜結構>兩分鐘瞭解低損耗電纜結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html alt=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/decf8edb02a34404b92b86681378575f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cae5a51a.html title=「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>「施工技巧」詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html alt=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcdae811e636496d948cf5a745f470fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47bcd6a6.html title=詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口>詳細瞭解光纜、終端盒、尾纖的接法和光纖各種接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html alt=「瞭解」房屋的層高和淨高怎麼算？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526054178152a496189726 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c90e11f6.html title=「瞭解」房屋的層高和淨高怎麼算？>「瞭解」房屋的層高和淨高怎麼算？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>