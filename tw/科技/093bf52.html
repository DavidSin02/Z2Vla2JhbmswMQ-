<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>c/c++後臺開發必知堆與棧的區別 | 极客快訊</title><meta property="og:title" content="c/c++後臺開發必知堆與棧的區別 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/093bf52.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/093bf52.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/093bf52.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/093bf52.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/093bf52.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/093bf52.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/093bf52.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/093bf52.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="c/c++後臺開發必知堆與棧的區別"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/093bf52.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>c/c++後臺開發必知堆與棧的區別</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（Heap）與棧（Stack）是開發人員必須面對的兩個概念，在理解這兩個概念時，需要放到具體的場景下，因為不同場景下，堆與棧代表不同的含義。一般情況下，有兩層含義：<br>（1）程序內存佈局場景下，堆與棧表示兩種內存管理方式；<br>（2）數據結構場景下，堆與棧表示兩種常用的數據結構。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1.程序內存分區中的堆與棧</span></h1><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1.1 棧簡介</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">棧由操作系統自動分配釋放 ，用於存放函數的參數值、局部變量等，其操作方式類似於數據結構中的棧。參考如下代碼：</span></p><pre><code>int main() {	int b;				//棧	char s[] = "abc"; 	//棧	char *p2;			//棧}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其中函數中定義的局部變量按照先後定義的順序依次壓入棧中，也就是說相鄰變量的地址之間不會存在其它變量。棧的內存地址生長方向與堆相反，由高到底，所以後定義的變量地址低於先定義的變量，比如上面代碼中變量 s 的地址小於變量 b 的地址，p2 地址小於 s 的地址。棧中存儲的數據的生命週期隨著函數的執行完成而結束。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1.2 堆簡介</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆由開發人員分配和釋放， 若開發人員不釋放，程序結束時由 OS 回收，分配方式類似於鏈表。參考如下代碼：</span></p><pre><code>int main() {	// C 中用 malloc() 函數申請	char* p1 = (char *)malloc(10);	cout&lt;&lt;(int*)p1&lt;&lt;endl;		//輸出：00000000003BA0C0		// 用 free() 函數釋放	free(p1);   	// C++ 中用 new 運算符申請	char* p2 = new char[10];	cout &lt;&lt; (int*)p2 &lt;&lt; endl;		//輸出：00000000003BA0C0		// 用 delete 運算符釋放	delete[] p2;}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其中 p1 所指的 10 字節的內存空間與 p2 所指的 10 字節內存空間都是存在於堆。堆的內存地址生長方向與棧相反，由低到高，但需要注意的是，後申請的內存空間並不一定在先申請的內存空間的後面，即 p2 指向的地址並不一定大於 p1 所指向的內存地址，原因是先申請的內存空間一旦被釋放，後申請的內存空間則會利用先前被釋放的內存，從而導致先後分配的內存空間在地址上不存在先後關係。堆中存儲的數據若未釋放，則其生命週期等同於程序的生命週期。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">關於堆上內存空間的分配過程，首先應該知道操作系統有一個記錄空閒內存地址的鏈表，當系統收到程序的申請時，會遍歷該鏈表，尋找第一個空間大於所申請空間的堆節點，然後將該節點從空閒節點鏈表中刪除，並將該節點的空間分配給程序。另外，對於大多數系統，會在這塊內存空間中的首地址處記錄本次分配的大小，這樣，代碼中的delete語句才能正確地釋放本內存空間。由於找到的堆節點的大小不一定正好等於申請的大小，系統會自動地將多餘的那部分重新放入空閒鏈表。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1.3 堆與棧區別</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆與棧實際上是操作系統對進程佔用的內存空間的兩種管理方式，主要有如下幾種區別：<br>（1）管理方式不同。棧由操作系統自動分配釋放，無需我們手動控制；堆的申請和釋放工作由程序員控制，容易產生內存洩漏；</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（2）空間大小不同。每個進程擁有的棧的大小要遠遠小於堆的大小。理論上，程序員可申請的堆大小為虛擬內存的大小，進程棧的大小 64bits 的 Windows 默認 1MB，64bits 的 Linux 默認 10MB；</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（3）生長方向不同。堆的生長方向向上，內存地址由低到高；棧的生長方向向下，內存地址由高到低。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（4）分配方式不同。堆都是動態分配的，沒有靜態分配的堆。棧有2種分配方式：靜態分配和動態分配。靜態分配是由操作系統完成的，比如局部變量的分配。動態分配由alloca函數進行分配，但是棧的動態分配和堆是不同的，</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">他</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的動態分配是由操作系統進行釋放，無需我們手工實現。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（5）分配效率不同。棧由操作系統自動分配，會在硬件層級對棧提供支持：分配專門的寄存器存放棧的地址，壓棧出棧都有專門的指令執行，這就決定了棧的效率比較高。堆則是由C/C++提供的庫函數或運算符來完成申請與管理，實現機制較為複雜，頻繁的內存申請容易產生內存碎片。顯然，堆的效率比棧要低得多。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（6）存放內容不同。棧存放的內容，函數返回地址、相關參數、局部變量和寄存器內容等。當主函數調用另外一個函數的時候，要對當前函數執行斷點進行保存，需要使用棧來實現，首先入棧的是主函數下一條語句的地址，即擴展指針寄存器的內容（EIP），然後是當前棧幀的底部地址，即擴展基址指針寄存器內容（EBP），再然後是被調函數的實參等，一般情況下是按照從右向左的順序入棧，之後是被調函數的局部變量，注意靜態變量是存放在數據段或者BSS段，是不入棧的。出棧的順序正好相反，最終棧頂指向主函數下一條語句的地址，主程序又從該地址開始執行。堆，一般情況堆頂使用一個字節的空間來存放堆的大小，而堆中具體存放內容是由程序員來填充的。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">從以上可以看到，堆和棧相比，由於大量malloc()/free()或new/delete的使用，容易造成大量的內存碎片，並且可能引發用戶態和核心態的切換，效率較低。棧相比於堆，在程序中應用較為廣泛，最常見的是函數的調用過程由棧來實現，函數返回地址、EBP、實參和局部變量都採用棧的方式存放。雖然棧有眾多的好處，但是由於和堆相比不是那麼靈活，有時候分配大量的內存空間，主要還是用堆。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">無論是堆還是棧，在內存使用時都要防止非法越界，越界導致的非法內存訪問可能會摧毀程序的堆、棧數據，輕則導致程序運行處於不確定狀態，獲取不到預期結果，重則導致程序異常崩潰，這些都是我們編程時與內存打交道時應該注意的問題。</span></p><p style=text-align:start><strong>需要C/C++ Linux高級服務器架構師學習資料後臺私信“資料”（包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等）</strong></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/89bc567a63c84695b0fbe8982764bbdb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.數據結構中的堆與棧</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">數據結構中，堆與棧是兩個常見的數據結構，理解二者的定義、用法與區別，能夠利用堆與棧解決很多實際問題。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.1 棧簡介</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">棧是一種運算受限的線性表，其限制是指只僅允許在表的一端進行插入和刪除操作，這一端被稱為棧頂（Top），相對地，把另一端稱為棧底（Bottom）。把新元素放到棧頂元素的上面，使之成為新的棧頂元素稱作進棧、入棧或壓棧（Push）；把棧頂元素刪除，使其相鄰的元素成為新的棧頂元素稱作出棧或退棧（Pop）。這種受限的運算使棧擁有“先進後出”的特性（First In Last Out），簡稱FILO。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">棧分順序棧和鏈式棧兩種。棧是一種線性結構，所以可以使用數組或鏈表（單向鏈表、雙向鏈表或循環鏈表）作為底層數據結構。使用數組實現的棧叫做順序棧，使用鏈表實現的棧叫做鏈式棧，二者的區別是順序棧中的元素地址連續，鏈式棧中的元素地址不連續。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">棧的結構如下圖所示：</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e73acf5d4a67430898156b3c043d2b46><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">棧的基本操作包括初始化、判斷棧是否為空、入棧、出棧以及獲取棧頂元素等。下面以順序棧為例，使用 C++ 給出一個簡單的實現。</span></p><pre><code>#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#define DataType int#define MAXSIZE 1024struct SeqStack {	DataType data[MAXSIZE];	int top;};//棧初始化,成功返回棧對象指針，失敗返回空指針NULLSeqStack* initSeqStack() {	SeqStack* s=(SeqStack*)malloc(sizeof(SeqStack));	if(!s) {		printf("空間不足\n");		return NULL;	} else {		s-&gt;top = -1;		return s;	}}//判斷棧是否為空bool isEmptySeqStack(SeqStack* s) {	if (s-&gt;top == -1)		return true;	else		return false;}//入棧，返回-1失敗，0成功int pushSeqStack(SeqStack* s, DataType x) {	if(s-&gt;top == MAXSIZE-1)	{		return -1;//棧滿不能入棧	} else {		s-&gt;top++;		s-&gt;data[s-&gt;top] = x;		return 0;	}}//出棧，返回-1失敗，0成功int popSeqStack(SeqStack* s, DataType* x) {	if(isEmptySeqStack(s)) {		return -1;//棧空不能出棧	} else {		*x = s-&gt;data[s-&gt;top];		s-&gt;top--;		return 0;	}}//取棧頂元素，返回-1失敗，0成功int topSeqStack(SeqStack* s,DataType* x) {	if (isEmptySeqStack(s))		return -1;	//棧空	else {		*x=s-&gt;data[s-&gt;top];		return 0;	}}//打印棧中元素int printSeqStack(SeqStack* s) {	int i;	printf("當前棧中的元素:\n");	for (i = s-&gt;top; i &gt;= 0; i--)		printf("%4d",s-&gt;data[i]);	printf("\n");	return 0;}//testint main() {	SeqStack* seqStack=initSeqStack();	if(seqStack) {		//將4、5、7分別入棧		pushSeqStack(seqStack,4);		pushSeqStack(seqStack,5);		pushSeqStack(seqStack,7);				//打印棧內所有元素		printSeqStack(seqStack);				//獲取棧頂元素		DataType x=0;		int ret=topSeqStack(seqStack,&amp;x);		if(0==ret) {			printf("top element is %d\n",x);		}				//將棧頂元素出棧		ret=popSeqStack(seqStack,&amp;x);		if(0==ret) {			printf("pop top element is %d\n",x);		}	}	return 0;}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">運行上面的程序，輸出結果：</span></p><pre><code>當前棧中的元素:   7   5   4top element is 7pop top element is 7</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2 堆簡介</span></h1><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2.1 堆的性質</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆是一種常用的樹形結構，是一種特殊的完全二叉樹，當且僅當滿足所有節點的值總是不大於或不小於其父節點的值的完全二叉樹被稱之為堆。堆的這一特性稱之為堆序性。因此，在一個堆中，根節點是最大（或最小）節點。如果根節點最小，稱之為小頂堆（或小根堆），如果根節點最大，稱之為大頂堆（或大根堆）。</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的左右孩子沒有大小的順序。下面是一個小頂堆示例：</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7ed46c6f42e04482874ed005992d833e><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆的存儲一般都用數組來存儲堆，i節點的父節點下標就為( i – 1 ) / 2 (i – 1) / 2(</span><em><span style="color:#4d4d4d;--tt-darkmode-color: #999999">i</span></em><span style="color:#4d4d4d;--tt-darkmode-color: #999999">–1)/2。它的左右子節點下標分別為 2 ∗ i + 1 2 * i + 12∗</span><em><span style="color:#4d4d4d;--tt-darkmode-color: #999999">i</span></em><span style="color:#4d4d4d;--tt-darkmode-color: #999999">+1 和 2 ∗ i + 2 2 * i + 22∗</span><em><span style="color:#4d4d4d;--tt-darkmode-color: #999999">i</span></em><span style="color:#4d4d4d;--tt-darkmode-color: #999999">+2。如第0個節點左右</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">子</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">節點下標分別為1和2。</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2a3439cd7adb4564b7159930e78fab20><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2.2 堆的基本操作</span></h1><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（1）建立<br>以最小堆為例，如果以數組存儲元素時，一個數組具有對應的樹表示形式，但樹並不滿足堆的條件，需要重新排列元素，可以建立“堆化”的樹。</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86adc635a3d448bd85d67e96426d8e55><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（2）插入<br>將一個新元素插入到表尾，即數組末尾時，如果新構成的二叉樹不滿足堆的性質，需要重新排列元素，下圖演示了插入15時，堆的調整。</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f5b13ef98d48466184bdec915c9f3965><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（3）刪除。<br>堆排序中，刪除一個元素總是發生在堆頂，因為堆頂的元素是最小的（小頂堆中）。表中最後一個元素用來填補空缺位置，結果樹被更新以滿足堆條件。</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ab632d8cbcee41eb8213c9a13b26819e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2.3 堆操作實現</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（1）插入代碼實現<br>每次插入都是將新數據放在數組最後。可以發現從這個新數據的父節點到根節點必然為一個有序的數列，現在的任務是將這個新數據插入到這個有序數據中，這就類似於直接插入排序中將一個數據併入到有序區間中，這是節點“上浮”調整。不難寫出插入一個新數據時堆的調整代碼：</span></p><pre><code>//新加入i節點,其父節點為(i-1)/2//參數：a：數組，i：新插入元素在數組中的下標  void minHeapFixUp(int a[], int i) {      int j, temp;      temp = a[i];      j = (i-1)/2;      //父節點      while (j &gt;= 0 &amp;&amp; i != 0) {          if (a[j] &lt;= temp)//如果父節點不大於新插入的元素，停止尋找              break;          a[i]=a[j];    		//把較大的子節點往下移動,替換它的子節點          i = j;          j = (i-1)/2;      }      a[i] = temp;  }  </code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">因此，插入數據到最小堆時：</span></p><pre><code>//在最小堆中加入新的數據data  //a：數組，index：插入的下標，void minHeapAddNumber(int a[], int index, int data) {      a[index] = data;      minHeapFixUp(a, index);  } </code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（2）刪除代碼實現<br>按照堆刪除的說明，堆中每次都只能刪除第0個數據。為了便於重建堆，實際的操作是將數組最後一個數據與根節點交換，然後再從根節點開始進行一次從上向下的調整。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">調整時先在左右兒子節點中找最小的，如果父節點不大於這個最小的子節點說明不需要調整了，反之將最小的子節點換到父節點的位置。此時父節點實際上並不需要換到最小子節點的位置，因為這不是父節點的最終位置。但邏輯上父節點替換了最小的子節點，然後再考慮父節點對後面的節點的影響。堆元素的刪除導致的堆調整，其整個過程就是將根節點進行“下沉”處理。下面給出代碼：</span></p><pre><code>//a為數組，len為節點總數；從index節點開始調整，index從0開始計算index其子節點為 2*index+1, 2*index+2；len/2-1為最後一個非葉子節點 void minHeapFixDown(int a[],int len,int index) {	if(index&gt;(len/2-1))//index為葉子節點不用調整		return;	int tmp=a[index];	lastIndex=index;	while(index&lt;=len/2-1)        //當下沉到葉子節點時，就不用調整了	{ 		// 如果左子節點小於待調整節點		if(a[2*index+1]&lt;tmp) {			lastIndex = 2*index+1;		}		//如果存在右子節點且小於左子節點和待調整節點		if(2*index+2&lt;len &amp;&amp; a[2*index+2]&lt;a[2*index+1]&amp;&amp; a[2*index+2]&lt;tmp) {			lastIndex=2*index+2;		}		//如果左右子節點有一個小於待調整節點，選擇最小子節點進行上浮		if(lastIndex!=index) {			a[index]=a[lastIndex];			index=lastIndex;		} else break;             //否則待調整節點不用下沉調整	}	a[lastIndex]=tmp;           //將待調整節點放到最後的位置}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">根據</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">刪除的下沉思想，可以有不同版本的代碼實現，以上是和孫凜同學一起討論出的一個版本，在這裡感謝他的參與，讀者可另行給出。個人體會，這裡建議大家根據對堆調整過程的理解，寫出自己的代碼，切勿看示例代碼去理解算法，而是理解算法思想寫出代碼，否則很快就會忘記。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（3）建</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999"><br>有了堆的插入和刪除後，再考慮下如何對一個數據進行堆化操作。要一個一個的從數組中取出數據來建立堆吧，不用！先看一個數組，如下圖：</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/098b263c750940d7952ab069b5984149><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">很明顯，對葉子節點來說，可以認為它已經是一個合法的堆了即20，60， 65， 4， 49都分別是一個合法的堆。只要從A[4]=50開始向下調整就可以了。然後再取A[3]=30，A[2] = 17，A[1] = 12，A[0] = 9分別作一次向下調整操作就可以了。下圖展示了這些步驟：</span></p><div class=pgc-img><img alt=c/c++後臺開發必知堆與棧的區別 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f76131c1e5be42d1a2beaaefeb445dd9><p class=pgc-img-caption></p></div><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">寫出堆化數組的代碼：</span></p><pre><code>//建立最小堆//a:數組，n：數組長度void makeMinHeap(int a[], int n) {      for (int i = n/2-1; i &gt;= 0; i--)          minHeapFixDown(a, i, n);  }  </code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2.4 堆的具體應用——堆排序</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">堆排序（Heapsort）是堆的一個經典應用，有了上面對堆的瞭解，不難實現堆排序。由於堆也是用數組來存儲的，故對數組進行堆化後，第一次將A[0]與A[n - 1]交換，再對A[0…n-2]重新恢復堆。第二次將A[0]與A[n – 2]交換，再對A[0…n - 3]重新恢復堆，重複這樣的操作直到A[0]與A[1]交換。由於每次都是將最小的數據併入到後面的有序區間，故操作完成後整個數組就有序了。有點類似於直接選擇排序。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">因此，完成堆排序並沒有用到前面說明的插入操作，只用到了建堆和節點向下調整的操作，堆排序的操作如下：</span></p><pre><code>//array:待排序數組，len：數組長度void heapSort(int array[],int len) {	//建堆	makeMinHeap(array,len); 		//最後一個葉子節點和根節點交換，並進行堆調整，交換次數為len-1次	for(int i=len-1;i&gt;0;--i) {		//最後一個葉子節點交換		array[i]=array[i]+array[0];		array[0]=array[i]-array[0];		array[i]=array[i]-array[0];                //堆調整		minHeapFixDown(array, 0, len-i-1);  	}}  </code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（1）穩定性。堆排序是不穩定排序。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（2）堆排序性能分析。由於每次重新恢復堆的時間複雜度為O(logN)，共N-1次堆調整操作，再加上前面建立堆時N/2次向下調整，每次調整時間複雜度也為O(logN)。兩次操作時間複雜度相加還是O(NlogN)，故堆排序的時間複雜度為O(NlogN)。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最壞情況：如果待排序數組是有序的，仍然需要O(NlogN)複雜度的比較操作，只是少了移動的操作；</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最好情況：如果待排序數組是逆序的，不僅需要O(NlogN)複雜度的比較操作，而且需要O(NlogN)複雜度的交換操作，總的時間複雜度還是O(NlogN)。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">因此，堆排序和快速排序在效率上是差不多的，但是堆排序一般優於快速排序的重要一點是數據的初始分佈情況對堆排序的效率沒有大的影響。</span></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>c++</a></li><li><a>開發</a></li><li><a>必知</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a980c6f3.html alt=教你從頭學前端開發——第一個網頁（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c44113d83f24f5db93c8353aff0c670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a980c6f3.html title=教你從頭學前端開發——第一個網頁（一）>教你從頭學前端開發——第一個網頁（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1f5a66a.html alt=網頁開發網頁的相關概念你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8ca7902bdcb14bc5a25a88be4953edd6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1f5a66a.html title=網頁開發網頁的相關概念你知道嗎？>網頁開發網頁的相關概念你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html alt="軟件開發中數據庫必備基礎01 - 圖解事務基礎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4e00ac778db451792b955bde23add02 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9552c1b8.html title="軟件開發中數據庫必備基礎01 - 圖解事務基礎">軟件開發中數據庫必備基礎01 - 圖解事務基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html alt=python安全開發軍規之四：使用安全的隨機數生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bbda123b84db44148aca9d3e26ddf119 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html title=python安全開發軍規之四：使用安全的隨機數生成器>python安全開發軍規之四：使用安全的隨機數生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb9492f2.html alt=電工必知！常見的基本電子電路圖！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/38e114ed426d4188b0ba2ba02f53bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb9492f2.html title=電工必知！常見的基本電子電路圖！>電工必知！常見的基本電子電路圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8dd83b90.html alt=常用最全正則表達式整理(開發必備) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5127ac984657471b853b307afe52b2fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8dd83b90.html title=常用最全正則表達式整理(開發必備)>常用最全正則表達式整理(開發必備)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html alt=給JAVA開發人員的正則表達式入門課 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5d620d422d0a4855924c5bcbf8ba483a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2ad303f.html title=給JAVA開發人員的正則表達式入門課>給JAVA開發人員的正則表達式入門課</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a278a157.html alt=中國尚未被開發的海島，遊客甚少景色美爆，距江浙滬超近 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6150f65415b047acad00ca52441a93ec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a278a157.html title=中國尚未被開發的海島，遊客甚少景色美爆，距江浙滬超近>中國尚未被開發的海島，遊客甚少景色美爆，距江浙滬超近</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html alt=測試開發專題：spring-boot統一異常捕獲 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/135918e30e2f4a2ea248b539eb383688 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d260a748.html title=測試開發專題：spring-boot統一異常捕獲>測試開發專題：spring-boot統一異常捕獲</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d7062663.html alt="道韻筋骨開發 解讀普及體系中大家所熟悉的“開胯”（撥胯）練法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f09cbcf088974d11b128e0446ea00ccb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d7062663.html title="道韻筋骨開發 解讀普及體系中大家所熟悉的“開胯”（撥胯）練法">道韻筋骨開發 解讀普及體系中大家所熟悉的“開胯”（撥胯）練法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa93bfe3.html alt=服務器開發專題1-程序，進程的區別和併發概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1534549004517ed1429f6ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa93bfe3.html title=服務器開發專題1-程序，進程的區別和併發概念>服務器開發專題1-程序，進程的區別和併發概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63619dc0.html alt=匯川六宗肥地上架，開發商們都不淡定了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5fb5a9d4ae93444e8660c99914c3e7ad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63619dc0.html title=匯川六宗肥地上架，開發商們都不淡定了>匯川六宗肥地上架，開發商們都不淡定了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d068068a.html alt=柬埔寨知名開發公司指定雷邦仕為防水材料合作品牌 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3331dc1b6b1d4754acf196f00164ed8c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d068068a.html title=柬埔寨知名開發公司指定雷邦仕為防水材料合作品牌>柬埔寨知名開發公司指定雷邦仕為防水材料合作品牌</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/826d97dc.html alt=石油開發與開採基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/826d97dc.html title=石油開發與開採基礎知識>石油開發與開採基礎知識</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>