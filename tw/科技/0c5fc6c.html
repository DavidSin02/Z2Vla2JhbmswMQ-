<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Linux中fork，vfork和clone詳解（區別與聯繫） | 极客快訊</title><meta property="og:title" content="Linux中fork，vfork和clone詳解（區別與聯繫） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a85519526d574b46bf248931f9634dd1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0c5fc6c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0c5fc6c.html><meta property="article:published_time" content="2020-10-29T20:59:05+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:05+08:00"><meta name=Keywords content><meta name=description content="Linux中fork，vfork和clone詳解（區別與聯繫）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0c5fc6c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Linux中fork，vfork和clone詳解（區別與聯繫）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>fork，vfork，clone</h1><hr><p>Unix標準的複製進程的系統調用時fork（即分叉），但是Linux，BSD等操作系統並不止實現這一個，確切的說linux實現了三個，fork,vfork,clone（確切說vfork創造出來的是輕量級進程，也叫線程，是共享資源的進程）</p><div class=pgc-img><img alt=Linux中fork，vfork和clone詳解（區別與聯繫） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a85519526d574b46bf248931f9634dd1><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>fork</h1><hr><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void){    int count = 1;    int child;    child = fork( );    if(child &lt; 0)    {        perror("fork error : ");    }    else if(child == 0)     //  fork return 0 in the child process because child can get hid PID by getpid( )    {        printf("This is son, his count is: %d (%p). and his pid is: %d\n", ++count, &amp;count, getpid());    }    else                    //  the PID of the child process is returned in the parent’s thread of execution    {        printf("This is father, his count is: %d (%p), his pid is: %d\n", count, &amp;count, getpid());    }    return EXIT_SUCCESS;}</code></pre><div class=pgc-img><img alt=Linux中fork，vfork和clone詳解（區別與聯繫） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/71c32fe877c44aa6b93819c043650afc><p class=pgc-img-caption></p></div><p>從運行結果裡面可以看出父子兩個進程的pid不同，堆棧和數據資源都是完全的複製</p><p>子進程改變了count的值，而父進程中的count沒有被改變。</p><p>子進程與父進程count的地址（虛擬地址）是相同的（注意他們在內核中被映射的物理地址不同）</p><p>寫時複製</p><p>有人認為這樣大批量的複製會導致執行效率過低。其實在複製過程中，linux採用了寫時複製的策略。</p><p>子進程複製了父進程的task_struct，系統堆棧空間和頁面表，這意味著上面的程序，我們沒有執行count++前，其實子進程和父進程的count指向的是同一塊內存。而當子進程改變了變量時候（即對變量進行了寫操作），會通過copy_on_write的手段為所涉及的頁面建立一個新的副本。</p><p>所以當我們執行++count後，這時候子進程才新建了一個頁面複製原來頁面的內容，基本資源的複製是必須的，而且是高效的。整體看上去就像是父進程的獨立存儲空間也複製了一遍。</p><p>寫入時複製(Copy-on-write)是一個被使用在程式設計領域的最佳化策略。其基礎的觀念是，如果有多個呼叫者(callers)同時要求相同資源，他們會共同取得相同的指標指向相同的資源，直到某個呼叫者(caller)嘗試修改資源時，系統才會真正複製一個副本(private copy)給該呼叫者，以避免被修改的資源被直接察覺到，這過程對其他的呼叫只都是通透的(transparently)。此作法主要的優點是如果呼叫者並沒有修改該資源，就不會有副本(private copy)被建立。</p><p>第一代Unix系統實現了一種傻瓜式的進程創建：當發出fork()系統調用時，內核原樣複製父進程的整個地址空間並把複製的那一份分配給子進程。這種行為是非常耗時的，因為它需要：</p><ul><li>為子進程的頁表分配頁幀</li><li>為子進程的頁分配頁幀</li><li>初始化子進程的頁表</li><li>把父進程的頁複製到子進程相應的頁中</li></ul><p>這種創建地址空間的方法涉及許多內存訪問，消耗許多CPU週期，並且完全破壞了高速緩存中的內容。在大多數情況下，這樣做常常是毫無意義的，因為許多子進程通過裝入一個新的程序開始它們的執行，這樣就完全丟棄了所繼承的地址空間。</p><p>現在的Linux內核採用一種更為有效的方法，稱之為寫時複製（Copy On Write，COW）。這種思想相當簡單：父進程和子進程共享頁幀而不是複製頁幀。然而，只要頁幀被共享，它們就不能被修改，即頁幀被保護。無論父進程還是子進程何時試圖寫一個共享的頁幀，就產生一個異常，這時內核就把這個頁複製到一個新的頁幀中並標記為可寫。原來的頁幀仍然是寫保護的：當其他進程試圖寫入時，內核檢查寫進程是否是這個頁幀的唯一屬主，如果是，就把這個頁幀標記為對這個進程是可寫的。</p><p>當進程A使用系統調用fork創建一個子進程B時,由於子進程B實際上是父進程A的一個拷貝,</p><p>因此會擁有與父進程相同的物理頁面.為了節約內存和加快創建速度的目標,fork()函數會讓子進程B以只讀方式共享父進程A的物理頁面.同時將父進程A對這些物理頁面的訪問權限也設成只讀.</p><p>這樣,當父進程A或子進程B任何一方對這些已共享的物理頁面執行寫操作時,都會產生頁面出錯異常(page_fault int14)中斷,此時CPU會執行系統提供的異常處理函數do_wp_page()來解決這個異常.</p><p>do_wp_page()會對這塊導致寫入異常中斷的物理頁面進行取消共享操作,為寫進程複製一新的物理頁面,使父進程A和子進程B各自擁有一塊內容相同的物理頁面.最後,從異常處理函數中返回時,CPU就會重新執行剛才導致異常的寫入操作指令,使進程繼續執行下去.</p><h1 class=pgc-h-arrow-right>vfork</h1><hr><p>如果fork簡單的vfork()的做法更加火爆，內核連子進程的虛擬地址空間結構也不創建了，直接共享了父進程的虛擬空間，當然了，這種做法就順水推舟的共享了父進程的物理空間</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void){    int count = 1;    int child;   // child = vfork( );    printf("Before create son, the father's count is:%d\n", count);    if((child = vfork())&lt; 0)    {        perror("fork error : ");    }    else if(child == 0)     //  fork return 0 in the child process because child can get hid PID by getpid( )    {        printf("This is son, his count is: %d (%p). and his pid is: %d\n", ++count, &amp;count, getpid());        exit(0);    }    else                    //  the PID of the child process is returned in the parent’s thread of execution    {        printf("After son, This is father, his count is: %d (%p), his pid is: %d\n", ++count, &amp;count, getpid());        exit(0);    }    return EXIT_SUCCESS;}</code></pre><div class=pgc-img><img alt=Linux中fork，vfork和clone詳解（區別與聯繫） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/92cdabdd2b2d437d865454feb38f0e32><p class=pgc-img-caption></p></div><p>從運行結果可以看到vfork創建出的子進程（線程）共享了父進程的count變量，2者的count指向了同一個內存，所以子進程修改了count變量，父進程的 count變量同樣受到了影響。</p><p>由vfork創造出來的子進程還會導致父進程掛起，除非子進程exit或者execve才會喚起父進程</p><p>由vfok創建出來的子進程共享了父進程的所有內存，包括棧地址，直至子進程使用execve啟動新的應用程序為止</p><p>由vfork創建出來得子進程不應該使用return返回調用者，或者使用exit()退出，但是它可以使用_exit()函數來退出</p><p>如果我們使用return來退出，你會發現程序陷入一種邏輯混亂的重複vfork狀態</p><p>參見下面的代碼</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;int main(void){   int count = 1;    int child;   // child = vfork( );    printf("Before create son, the father's count is : %d\n", count);    if((child = vfork())&lt; 0)    {        perror("fork error : ");    }    else if(child == 0)     //  fork return 0 in the child process because child can get hid PID by getpid( )    {        printf("This is son, his count is: %d (%p). and his pid is: %d\n", ++count, &amp;count, getpid());    }    else                    //  the PID of the child process is returned in the parent’s thread of execution    {        printf("After son, This is father, his count is: %d (%p), his pid is: %d\n", count, &amp;count, getpid());        sleep(2);    }    return EXIT_SUCCESS;}</code></pre><p>我們會發現vfork的子進程在使用return後，返回到了調用處，因此父進程又創建出一個新的vfork進程，</p><div class=pgc-img><img alt=Linux中fork，vfork和clone詳解（區別與聯繫） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/23b194d0c7cd4fcfa888d15da8be5f1d><p class=pgc-img-caption></p></div><p>解決這種問題的方法就是不要在進程中使用return，而是使用exit或者_exit來代替</p><h1 class=pgc-h-arrow-right>fork與vfork</h1><hr><p><strong>區別與聯繫</strong></p><p>vfork()用法與fork()相似.但是也有區別,具體區別歸結為以下3點</p><p>fork() 子進程拷貝父進程的數據段，代碼段.</p><p>vfork() 子進程與父進程共享數據段.|</p><p>fork() 父子進程的執行次序不確定.</p><p>vfork():保證子進程先運行，</p><p>vfork()保證子進程先運行，在她調用exec或_exit之後父進程才可能被調度運行。如果在</p><p>調用這兩個函數之前子進程依賴於父進程的進一步動作，則會導致死鎖。</p><p>在調用exec或_exit之前與父進程數據是共享的,在它調用exec或_exit之後父進程才可能被調度運行。如果在調用這兩個函數之前子進程依賴於父進程的進一步動作，則會導致死鎖。當需要改變共享數據段中變量的值，則拷貝父進程</p><p>vfork用於創建一個新進程，而該新進程的目的是exec一個新進程，vfork和fork一樣都創建一個子進程，但是它並不將父進程的地址空間完全複製到子進程中，不會複製頁表。因為子進程會立即調用exec，於是也就不會存放該地址空間。不過在子進程中調用exec或exit之前，他在父進程的空間中運行。</p><p>如果在調用vfork時子進程依賴於父進程的進一步動作，則會導致死鎖。由此可見，這個系統調用是用來啟動一個新的應用程序。其次，子進程在vfork()返回後直接運行在父進程的棧空間，並使用父進程的內存和數據。這意味著子進程可能破壞父進程的數據結構或棧，造成失敗。</p><p>為了避免這些問題，需要確保一旦調用vfork()，子進程就不從當前的棧框架中返回，並且如果子進程改變了父進程的數據結構就不能調用exit函數。</p><p>子進程還必須避免改變全局數據結構或全局變量中的任何信息，因為這些改變都有可能使父進程不能繼續。通常，如果應用程序不是在fork()之後立即調用exec()，就有必要在fork()被替換成vfork()之前做仔細的檢查。</p><p><strong>為什麼會有vfork</strong></p><p>因為以前的fork當它創建一個子進程時，將會創建一個新的地址空間，並且拷貝父進程的資源，而往往在子進程中會執行exec調用，這樣，前面的拷貝工作就是白費力氣了，這種情況下，聰明的人就想出了vfork，它產生的子進程剛開始暫時與父進程共享地址空間（其實就是線程的概念了），因為這時候子進程在父進程的地址空間中運行，所以子進程不能進行寫操作，</p><p>並且在兒子“霸佔”著老子的房子時候，要委屈老子一下了，讓他在外面歇著（阻塞），一旦兒子執行了exec或者exit後，相當於兒子買了自己的房子了，這時候就相當於分家了。此時vfork保證子進程先運行，在她調用exec或exit之後父進程才可能被調度運行。</p><p>因此vfork設計用以子進程創建後立即執行execve系統調用加載新程序的情形。在子進程退出或開始新程序之前，內核保證了父進程處於阻塞狀態</p><p>用vfork函數創建子進程後，子進程往往要調用一種exec函數以執行另一個程序，當進程調用一種exec函數時，該進程完全由新程序代換，而新程序則從其main函數開始執行，因為調用exec並不創建新進程，所以前後的進程id 並未改變，exec只是用另一個新程序替換了當前進程的正文，數據，堆和棧段。</p><h1 class=pgc-h-arrow-right>clone</h1><hr><p>clone函數功能強大，帶了眾多參數，因此由他創建的進程要比前面2種方法要複雜。</p><p>clone可以讓你有選擇性的繼承父進程的資源，你可以選擇想vfork一樣和父進程共享一個虛存空間，從而使創造的是線程，你也可以不和父進程共享，你甚至可以選擇創造出來的進程和父進程不再是父子關係，而是兄弟關係。</p><p>先有必要說下這個函數的結構</p><pre><code>···cint clone(int (fn)(void ), void *child_stack, int flags, void *arg);···</code></pre><p>這裡fn是函數指針，我們知道進程的4要素，這個就是指向程序的指針，就是所謂的“劇本”, child_stack明顯是為子進程分配系統堆棧空間（在linux下系統堆棧空間是2頁面，就是8K的內存，其中在這塊內存中，低地址上放入了值，這個值就是進程控制塊task_struct的值）,flags就是標誌用來描述你需要從父進程繼承那些資源， arg就是傳給子進程的參數）。下面是flags可以取的值</p><div class=pgc-img><img alt=Linux中fork，vfork和clone詳解（區別與聯繫） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7fec66cbcf5b4caca50cae5474e90b5c><p class=pgc-img-caption></p></div><p>下面的例子是創建一個線程（子進程共享了父進程虛存空間，沒有自己獨立的虛存空間不能稱其為進程）。父進程被掛起當子線程釋放虛存資源後再繼續執行。</p><pre><code>#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;sched.h&gt;#include &lt;signal.h&gt;#include &lt;sys/types.h&gt;#include &lt;unistd.h&gt;#define FIBER_STACK 8192int a;void * stack;int do_something(){    printf("This is son, the pid is:%d, the a is: %d\n", getpid(), ++a);    free(stack); //這裡我也不清楚，如果這裡不釋放，不知道子線程死亡後，該內存是否會釋放，知情者可以告訴下,謝謝    exit(1);}int main(){    void * stack;    a = 1;    stack = malloc(FIBER_STACK);//為子進程申請系統堆棧    if(!stack)    {        printf("The stack failed\n");        exit(0);    }    printf("creating son thread!!!\n");    clone(&amp;do_something, (char *)stack + FIBER_STACK, CLONE_VM|CLONE_VFORK, 0);//創建子線程    printf("This is father, my pid is: %d, the a is: %d\n", getpid(), a);    exit(1);}</code></pre><div class=pgc-img><img alt=Linux中fork，vfork和clone詳解（區別與聯繫） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b20d710b37f14a17aea52e50e8daff93><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>clone, fork, vfork區別與聯繫</h1><hr><p><strong>實現方式思路</strong></p><p>系統調用服務例程sys_clone, sys_fork, sys_vfork三者最終都是調用do_fork函數完成.</p><p>do_fork的參數與clone系統調用的參數類似, 不過多了一個regs(內核棧保存的用戶模式寄存器). 實際上其他的參數也都是用regs取的</p><p><strong>具體實現的參數不同</strong></p><p>1、clone:</p><p>clone的API外衣, 把fn, arg壓入用戶棧中, 然後引發系統調用. 返回用戶模式後下一條指令就是fn.</p><p>sysclone: parent_tidptr, child_tidptr都傳到了 do_fork的參數中</p><p>sysclone: 檢查是否有新的棧, 如果沒有就用父進程的棧 (開始地址就是regs.esp)</p><p>2、fork, vfork:</p><p>服務例程就是直接調用do_fork, 不過參數稍加修改</p><p>clone_flags:</p><p>sys_fork: SIGCHLD, 0, 0, NULL, NULL, 0</p><p>sys_vfork: CLONE_VFORK | CLONE_VM | SIGCHLD, 0, 0, NULL, NULL, 0</p><p>用戶棧: 都是父進程的棧.</p><p>parent_tidptr, child_ctidptr都是NULL.</p><p><strong>需要C/C++ Linux服務器架構師學習資料私信“資料”（資料包括C/C++，Linux，golang技術，Nginx，ZeroMQ，MySQL，Redis，fastdfs，MongoDB，ZK，流媒體，CDN，P2P，K8S，Docker，TCP/IP，協程，DPDK，ffmpeg等），免費分享</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Linux</a></li><li><a>fork</a></li><li><a>vfork</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html alt=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67e5890abdc3408c9e6e28c61ce6c847 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/286d1d05.html title=Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)>Linux怎麼樣編譯c程序文件(編譯最新版ffmpeg為例)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html alt=Linux用戶、用戶組與文檔屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54f39d7a23d64846b3fee43d438f13bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e4b1039.html title=Linux用戶、用戶組與文檔屬性>Linux用戶、用戶組與文檔屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html alt=Linux系統——用戶、用戶組、權限和文件屬性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcacd8fd.html title=Linux系統——用戶、用戶組、權限和文件屬性>Linux系統——用戶、用戶組、權限和文件屬性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html alt=Linux併發服務器模型一、多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dad48786.html title=Linux併發服務器模型一、多進程>Linux併發服務器模型一、多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fa5f4d06.html alt="linux fork多進程併發服務器模型之C/C++代碼實戰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5794b6eba487410ebcd6838aac6772fc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fa5f4d06.html title="linux fork多進程併發服務器模型之C/C++代碼實戰">linux fork多進程併發服務器模型之C/C++代碼實戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html alt=搞懂Linux內存管理，僅此一篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ae3e7cee0234c4cb9cdef0039d2c4d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3d9f3d8.html title=搞懂Linux內存管理，僅此一篇>搞懂Linux內存管理，僅此一篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html alt=Linux內核的整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7aaf296a7c14809b8c0ce535a02205d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838d476c.html title=Linux內核的整體架構>Linux內核的整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html alt=什麼Linux，Linux內核及Linux操作系統，整體架構介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af09f220163b49399261735b49fe1790 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7102c077.html title=什麼Linux，Linux內核及Linux操作系統，整體架構介紹>什麼Linux，Linux內核及Linux操作系統，整體架構介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html alt=Linux系統常用命令大全 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b48b90b.html title=Linux系統常用命令大全>Linux系統常用命令大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47743f68.html alt=嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/44355de4180a4af4beeda86cd1696601 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47743f68.html title=嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》>嵌入式Linux開發《C語言專題(二：有趣的基本數據類型)》</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2f8e01a.html alt="Linux C 字符串函數 sprintf()、snprintf() 詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2f8e01a.html title="Linux C 字符串函數 sprintf()、snprintf() 詳解">Linux C 字符串函數 sprintf()、snprintf() 詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html alt=Linux高級網絡編程篇-UDP丟包問題總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7646f9b.html title=Linux高級網絡編程篇-UDP丟包問題總結>Linux高級網絡編程篇-UDP丟包問題總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>