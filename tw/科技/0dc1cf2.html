<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++編程調試祕笈：c++的缺陷來自哪裡？ | 极客快訊</title><meta property="og:title" content="C++編程調試祕笈：c++的缺陷來自哪裡？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/fa76023d1bbb405ab6e8697aa2dcd9fa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0dc1cf2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0dc1cf2.html><meta property="article:published_time" content="2020-10-29T20:59:00+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:00+08:00"><meta name=Keywords content><meta name=description content="C++編程調試祕笈：c++的缺陷來自哪裡？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0dc1cf2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++編程調試祕笈：c++的缺陷來自哪裡？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>C++語言是非常獨特的。雖然實際上所有的編程語言都從其他語言中吸收了一些思路、語法元素和關鍵字C++卻是吸收了另一種完整的語言,即C語言。事實上, C++語言的創建者Bjarne Stroustrup原先把他的新語言命名為"帶類的C"。這意味著如果我們已經使用了一些C代碼,並且由於某種原因(例如科研或貿易)切換到一種面向對象的語言,就不需要在移植代碼方面採取任何措施,只要安裝新的C+編譯器,就可以對舊的C代碼進行編譯了,並且效果和原先的一模一樣。我們甚至會覺得已經完成了從C到C++的轉換。最後這種想法雖然距離真相還很遠,用真正的C++所編寫的代碼與C代碼看上去存在很明顯的區別,但它還是提供了一個逐漸過渡的選項。也就是說,我們可以從現在編譯運行的C代碼出發,逐漸引入用C++所編寫的新代碼段,慢慢與它們混合在一起,最終實現到純C++的切換。因此, C++的層次式設計具有它獨特的市場推動力。</p><p>但是,其中還是存在一些複雜的地方:隨著C的完整語法被新語言完整地吸收,它的設計哲學和存在的問題也同樣被吸收。C語言是在1969年~1973年期間由Dennis Rithie在貝爾實驗室創建的,其出發點是為了編寫Unix操作系統。這項工作的一個伴隨成果是誕生了一種高效的高級編程語言(與需要編寫每條計算機指令的彙編語言相比)。也就是說,它所產生的編譯後的代碼應該具有儘可能快的速度。這種新的C語言的其中-項公開原則是,用戶不應該為他沒有使用到的特性而受到拖累。因此,為了追求高效的編譯代碼,對於程序員沒有提出明確的要求, C就絕對不會加以考慮。C語言是為了速度而不是為了舒適而創建的,這就產生了一些問題。</p><p>首先,程序員可以創建一個某種長度的數組,並用一個超出該數組邊界的索引值訪問一個元素。更容易被濫用的是C的指針運算,程序員可以把指針運算所產生的任何值作為內存地址並對它進行訪問,不管這塊內存是否應該被訪問。(實際上,這兩個問題其實是同一個,只不過使用了不同的語法。)</p><p>程序員還可以在運行時使用calloc()和malloc()函數動態分配內存,並使用free()函數負責動態內存的銷燬。但是,如果忘了銷燬或者不小心銷燬了多次,其結果可能是災難性的。</p><p>我們將在本書的第二部分深入討論這些問題中的每一個。需要重視的是, C++在繼承整個C時,除了傳承它的高效原則,還繼承了它的所有問題。因此, C++代碼中的部分缺陷就來源於C。但是,故事並沒有結束。除了來自於C的問題, C++自身也存在一些問題。例如,大多數人認為友函數和多重繼承並不是良好的編程思路。C++具有自己分配內存的方法,它並不是調用像calloc()或malloc()這樣的函數,而是使用操作符new, new操作符並不僅僅分配內存,它還創建對象,即調用它們的構造函數。與C的精神相同,使用delete操作符刪除動態分配的內存是程序員的責任。現在的情況看起來與C相同:我們分配了一些內存,然後刪除它。但是,複雜之處在於C++具有兩種不同的new操作符:</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fa76023d1bbb405ab6e8697aa2dcd9fa><p class=pgc-img-caption></p></div><p>在第一種情況下, new操作符創建了一個MyClass類型的對象。在第二種情況下,它創建了一個相同類型的對象數組。與之對應的是, C++具有兩種不同的delete操作符:</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c055af5ee2ad4e9b8abb38d2fa5f04da><p class=pgc-img-caption></p></div><p>當然,一旦使用了"帶方括號的new"創建對象,就需要使用"帶方括號的delete"刪除它們。這樣就可能導致一種新的錯誤:混用new和delete ,其中一個帶了方括號而另一個沒有帶方括號。如果出現了這種錯誤,就會對內存堆產生巨大的破壞。因此,我們可以總結如下: C++的缺陷大部分來源於C,但C++t引入了一些自討苦吃的新方法。我們將在本書的第二部分討論這些話題。</p><p><strong>2.1 為什麼編譯器是捕捉缺陷的最好場合</strong></p><p>如果在編譯時捕捉缺陷與在運行時捕捉缺陷之間進行選擇,只要有可能,都應該在編譯時捕捉缺陷。這樣做的理由有很多。首先,如果一個缺陷是被編譯器所檢測到的,我們將看到一條文本信息,準確描述了所發生的錯誤是什麼,它是在哪裡發生的,發生在哪個文件以及發生在哪一行。(作者在這裡可能稍微有點樂觀,因為在有些情況下,尤其是在涉及STL時,編譯器所產生的錯誤信息是相當含糊的,需要花費精力才能推斷出編譯器實際所描述的含義。但是,編譯器總是在不斷地完善中,大多數情況下它們對問題的描述是相當清晰的。)</p><p>另一個理由是完整的編譯(進行了最終鏈接)覆蓋了程序中的所有代碼。如果編譯器沒有返回錯誤或警告就可以百分之百地確信程序中不存在編譯時可以檢測到的錯誤。但對於運行時測試,就不能做出這樣的保證。當代碼相當龐大時,很難保證所有可能的分枝都被測試到,也無法保證每一行代碼都至少執行1次。即使我們能夠保證這一點，仍然不夠。同一段代碼對於一組輸入可能正確地完成任務,但對於另一組輸入可能無法正確地工作。因此,通過運行時測試,我們永遠無法完全保證對所有東西都進行了測試。</p><p>最後還存在時間因素:我們在運行代碼之前執行編譯,因此如果在編譯時捕捉到了錯誤,就可以節省時間。有些運行時錯誤是在程序的後期出現的,因此可能要等幾分鐘甚至幾小時的運行之後才會發現一個錯誤。更糟的是,這種錯誤很可能是無法複製的,它可能以一種看上去隨機的方式,在連續運行時出現並消失。相比之下,在編譯時捕捉錯誤就簡單得多!</p><p><strong>2.2 怎樣用編譯器捕捉缺陷</strong></p><p>現在我們應該已經堅信,只要有可能,就儘量在編譯時捕捉錯誤。但是,怎樣才能實現這個目標呢?讓我們觀察一對例子。</p><p>第一個例子是一個Variant類的故事。曾幾何時,一家軟件公司編寫了一個Excel插件。這是一個文件,被Microsoft Excel打開之後向它添加了一些新功能,可以在Excel單元格中被調用。由於Excel單元格可以包含不同類型的數據,包括整數(例如1 )、浮點數(例如3.1415926535)、日期(例如1/12000)甚至是字符串("This is the house that Jack built") ,因此這家公司開發了一個Variant類,它的行為類似於變色龍,可以包含任意上述數據類型。但是,隨後有人提出了一個思路,就是一個Variant對象可以包含另一個Variant對象,甚至可以包含一個Variant類型的vector (即std:: vector&lt;Variant> )。這些開始被使用的Variant對象並不僅僅與Excel進行通信,還與內部代碼進行通信。因此,當我們觀察函數的簽名時:</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/72f60d32829e4e2b9b3ea4ef42513981><p class=pgc-img-caption></p></div><p>很顯然,完全沒有辦法理解這個函數期望接受什麼類型的數據,以及它將返回什麼類型的數據。因此,如果它期望接受一個日期數據,而我們向它傳遞了一個無法組成日期的字符串,這個錯誤只能在運行時才能被檢測到。正如我們剛才討論的那樣,應該儘量在編譯時發現錯誤。因此,這種方法使我們無法使用編譯器通過類型安全輕鬆地捕捉到錯誤。這個問題的解決方案將在後面討論,不過簡潔的答案就是用不同的C++類表示不同的數據類型。</p><p>上面這個例子是真實的,但有些極端。下面是一個更加典型的情況。假設我們正在處理一些金融數據(例如股票的價格) ,並且為每個值加上對應的時間戳,即這個價格被觀察時的日期和時間。那麼我們應該怎樣對時間進行測量呢?最簡單的解決方案是對過去某個時間(例如1/1/1970)以來的秒數進行計數。</p><p>有人突然意識到實現了這項功能的函數庫所提供的是32位的整數,最大值約為20億左右。如果超過了這個最大值,就會發生溢出而成為負數。在距離時間軸的起點大約68年之後(即2038年)就會發生這種情況。它所導致的問題與著名的"千年蟲”問題相似。為了修正這個問題,可能需要檢查相當數量的文件,找到所有這些變量,並把它們的類型更改為int64,後者的長度是64位,能夠表示的時間長度是32位整數的40億倍左右,對於再小心謹慎的人來說都是足夠的了。</p><p>但是現在又出現了另一個問題。有些程序員使用了int64 num_of_seconds形式,另一些人則使用了int64num_of_millisec形式,還有一些人使用了int64 num_of_microsec形式。編譯器絕對沒有辦法判斷出一個接受毫秒時間的函數實際所傳遞的是表示微秒的時間,反之亦然。當然,我們可以對需要分析的股票價格所處的時間間隔預設一些條件,例如從1990年直到未來的某個時刻(例如3000年) ,然後在運行時增加一項安全檢查,確保傳遞給函數的值必須位於這個時間間隔之內。但是,這將導致許多函數都需要配備這種安全檢查,可能需要花費大量的人力。如果有人在將來決定回過頭來分析20世紀期間的股票價格又會怎麼樣呢?</p><p><strong>2.3處理類型的正確方式</strong></p><p>現在,如果我們創建一個Time類,在內部實現中隱藏了從什麼時間開始,以及用什麼時間單位(秒、毫秒等)進行測量等細節,上面這些雜七雜八的問題就可以輕鬆得以避免。這種方法的一個優點是如果我們錯誤地傳遞了其他日期數據,而不是傳遞了時間(現在用Time類型表示) ,編譯器馬上就能捕捉到這種錯誤。這種方法的另一個優點是,如果Time類當前是用毫秒實現的,並且以後為了提高精度用微秒錶示,我們只需要編輯一個類,修改內部實現的細節,而不會影響其餘的代碼。</p><p>因此,我們怎樣才能在編譯時而不是在運行時捕捉類型錯誤呢?我們首先可以用一個單獨的類表示每種類型的數據。我們用int表示整數,用double表示浮點數,用std::string表示文本,用Date表示日期,用Time表示時間,對於其他類型的數據也都用一個單獨的類表示。但是,只採用這種做法仍然是不夠的。假設我們有兩個類Apple和Orange ,並有一個期望接受一個Orange類型的參數的函數:</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4e817abd02494204b513bec36ff75467><p class=pgc-img-caption></p></div><p>但是，我們可能不小心向它提供了APPle類型的對象：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/29067a80325b4304bd498681e81fac7d><p class=pgc-img-caption></p></div><p>在有些情況下,這樣的代碼可以通過編譯,因為C++編譯器試圖向我們提供幫助。只要可能,它會把Apple平靜地轉換為Orange,這可能通過以下兩種方式發生。</p><p>(1)如果Orange類具有一個只接受一個Apple類型的參數的構造函數。</p><p>(2)如果Apple類具有一個可以把它轉換為Orange的操作符。</p><p>當Orange類具有下面這樣的定義時,就會發生第一種情況:</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/efad95d54a4549c48b8285a80e4a8b1b><p class=pgc-img-caption></p></div><p>它甚至可以像下面這樣：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ee4c8f9f8332437a8822767864760777><p class=pgc-img-caption></p></div><p>即使在最後這個例子中,構造函數看上去像是具有兩個輸入,但它也可以只用一個參數就可以被調用,因此它也可以隱式地把Apple轉換為Orange,這個問題的解決方案是用關鍵字explici聲明這類構造函數。這種做法可以防止編譯器執行自動(隱式)轉換,這樣我們就可以迫使程序員在期望接受Orange的地方必須使用Orange :</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/82272c02ee9f44d988bb6d31eb93c1b2><p class=pgc-img-caption></p></div><p>第二個例子需要對應地修改為：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fdbb0e3754ac49cf864bc6b03a920bb6><p class=pgc-img-caption></p></div><p>另一種讓編譯器知道怎麼把Apple轉換為Orange的方法是提供一個轉換操作符：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2bac23fd103450ba7966773aa3f3ba3><p class=pgc-img-caption></p></div><p>這個操作符在此處的出現是非同尋常的,說明程序員用一種明確的方式向編譯器提供了一種把Apple轉換為Orange的方法,它並不是什麼錯誤。因此,對所有接受一個參數的構造函數用關鍵字explicit進行聲明,這是值得推薦的做法。一般而言,隱式轉換的所有可能性都是不好的思路。因此,如果想按照上面這個例子一樣在Apple類中提供一種把Apple轉換為Orange的方法,下面是一種更好的方法：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7d2e325342fa4e08a699aff29a6591a2><p class=pgc-img-caption></p></div><p>在這個例子中，為了把Apple轉換為Orange，需要採用下面的方式：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04615f5e9a4f497898379f706651a335><p class=pgc-img-caption></p></div><p>另外還有一種方法可以混合不同的數據類型，即使用枚舉（enum）。考慮下面這個例子：假設我們定義了下面這兩個枚舉，分別表示一週中的某天以及月份。</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/333391ba3bb94eb096309c79355e25d1><p class=pgc-img-caption></p></div><p>這些常量實際上都是整數（例如，C內置的int類型）。如果我們有一個期望接受一週中的某天作為參數的函數：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1d5189dfd0c14ef98cc1238d0a3e0041><p class=pgc-img-caption></p></div><p>下面這個調用將會在不產生任何警告的情況下通過編譯：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/93d31bd28f934e90ab49bec56985267b><p class=pgc-img-caption></p></div><p>在運行時，我們能顧採取的措施不多，因為JAN和MON都是與1相等的整數。捕捉這類缺陷的方法是不使用創建整數的“單純功能”枚舉，而是使用創建新類型的枚舉：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67358a68202844d0a9abfb79fb0e301b><p class=pgc-img-caption></p></div><p>在這種情況下，期望接受一週中的某天為參數的函數將被聲明為：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/540a6f848dbc4723aafdab7010f79cb9><p class=pgc-img-caption></p></div><p>像下面這樣試圖用一個Month值調用這個函數：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9b64507a37fd405ebe5c41bea2b6d792><p class=pgc-img-caption></p></div><p>將會產生編譯錯誤：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e4b2ef06c26846ed942dc8807143db01><p class=pgc-img-caption></p></div><p>這正是我們在這個例子中期待產生的效果。</p><p>但是，這種方法具有一個消極因素。在這個例子中，用枚舉創建整型常量時，我們可以編寫如下的代碼：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9f14ef6a2a834727af3ed43719f31455><p class=pgc-img-caption></p></div><p>但是當我們使用枚舉創建新類型時，如下面的寫法：</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a0cd7881d4a64ef7949c0284e67b01fe><p class=pgc-img-caption></p></div><p>就無法通過編譯。因此,如果我們需要迭代枚舉的值,可以像原來一樣使用整數。</p><p>當然,任何規則都有例外,有時候程序員有理由編寫像Variant這樣的類,允許進行隱式類型轉換以滿足特定的需要。但是,絕大多數時候應該完全避免隱式類型轉換,這就允許我們充分利用編譯器檢查不同變量類型的功能,早期(即在編譯時)捕捉潛在的錯誤。</p><p>現在,假設我們已經儘自己所能使用了類型安全。遺憾的是,除了bool和char類型之外,每種類型可能包含的值的數量都是天文數字,通常只有一小部分值是合理的。例如,如果我們使用double類型表示股票的價格,可以很合理地確定股票的價格將在0到10 000之間波動(唯一的例外是Berkshire Hathaway公司的股票,它的主人Warren Buffet顯然並不相信把股票價格保持在合理範圍內是個好主意,因此他從不對股票進行除權,在本書寫作之時這個股票的價格是每股10萬美元)。但即使是Berkshire Hathaway這樣的股票,它的價格仍然只使用了double類型的很小一部分,因為double的範圍高達</p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/98f8384c82d34bb380762113fbe561e3><p class=pgc-img-caption></p></div><p>,並且還包含了完全不適合表示股票價格的負數。由於大多數類型只有一小部分值是合理的,因此總是存在一些只能在運行時才能診斷的錯誤。</p><p>事實上,C語言的大多數問題,例如指定了越界索引,或通過指針運算不恰當地訪問內容,只能在運行時才能得到診斷。由於這個原因,本書的剩餘部分主要專注於討論捕捉運行時錯誤。</p><p>本章所討論的在編譯時診斷錯誤的規則如下。</p><p>1、禁止隱式類型轉換:用關鍵字explicit聲明一個接受1個參數的構造函數,並避免使用轉換操作</p><p>符。</p><p>2、用不同的類表示不同的數據類型。</p><p>3、不要使用枚舉創建整型常量,而是用它們創建新類型。</p><p>本文節選自《C++編程調試祕笈》</p><p></p><div class=pgc-img><img alt=C++編程調試祕笈：c++的缺陷來自哪裡？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/32989292c0584660a41921c618f6e515><p class=pgc-img-caption></p></div><p>本書介紹了C++程序員經常犯的一些編程錯誤，並且給出了可以用來避免這些錯誤的規則。本書基於C++開發者社群的實踐，介紹瞭如何安全地使用C++庫。</p><p><br></p><div class=tt-column-card data-content='{"new_thumb_url": "http://sf6-ttcdn-tos.pstatp.com/img/pgc-image/ff76e1fcba414763b5d25b2c03579625", "title": "C Primer Plus\u5b98\u65b9\u89c6\u9891\u89e3\u8bfb", "url": "", "price": 99, "column_id": "6822821206685647116", "content": "", "author_description": "\u5f02\u6b65\u793e\u533a", "share_price": 7.92, "thumb_url": "http://p10.pstatp.com/large/pgc-image/ff76e1fcba414763b5d25b2c03579625", "sold": 5}'><p class=column-placeholder></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C++</a></li><li><a>編程</a></li><li><a>調試</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fb3d61e.html alt=C++編程自學寶典：如何編寫一個簡單的項目程序？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ec424c077c6a41d9a6de2b6c4c0c4954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fb3d61e.html title=C++編程自學寶典：如何編寫一個簡單的項目程序？>C++編程自學寶典：如何編寫一個簡單的項目程序？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e551fdf0.html alt=C++｜深入理解編程中的字符編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2a9d352f7db7442987c04f2b54daf4f1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e551fdf0.html title=C++｜深入理解編程中的字符編碼>C++｜深入理解編程中的字符編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html alt=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/805329c3d3fc4c7aae35456efd84cd6c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bbf5adcf.html title=C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板>C/C++編程筆記：C++入門知識，深入解析C++函數和函數模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04743eb6.html alt=C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b35fbec7-2043-4f8f-b354-617f095d32cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04743eb6.html title=C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性>C/C++編程筆記：C++模板詳解（一）函數模板的概念和特性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/57af4069.html alt=C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1322941786864783877a7707ec15289f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/57af4069.html title=C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？>C/C++編程筆記：C語言結構體—位域，如何指定成員變量所佔Bit？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d298c6e.html alt=C++模板元編程實戰：順序、分支與循環代碼的編寫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e3ef70b8c9914d08bc50e701b30587a4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d298c6e.html title=C++模板元編程實戰：順序、分支與循環代碼的編寫>C++模板元編程實戰：順序、分支與循環代碼的編寫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a142cb95.html alt=C/C++編程入門基礎項目：C語言控制檯版本，貪吃蛇源代碼示例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/412ec0fbaede42c2aab496366afb8dd3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a142cb95.html title=C/C++編程入門基礎項目：C語言控制檯版本，貪吃蛇源代碼示例>C/C++編程入門基礎項目：C語言控制檯版本，貪吃蛇源代碼示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d208ccdc7f074f67a257d52df74e4f48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html title=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）>C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5727a1aa.html alt=C/C++編程筆記：C語言開發黃金礦工遊戲！項目源碼分享學習 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b4fcdf4fd6ef4d98b5579675bfb07a87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5727a1aa.html title=C/C++編程筆記：C語言開發黃金礦工遊戲！項目源碼分享學習>C/C++編程筆記：C語言開發黃金礦工遊戲！項目源碼分享學習</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35f99da2.html alt="C/C++編程筆記：《C語言》—— 數組知識詳解，學編程建議收藏！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/925551ca-8f79-45eb-91c7-6c36d0ec6953 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35f99da2.html title="C/C++編程筆記：《C語言》—— 數組知識詳解，學編程建議收藏！">C/C++編程筆記：《C語言》—— 數組知識詳解，學編程建議收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6f4f655.html alt=C/C++編程筆記：C語言“井字棋”小遊戲，井字棋走起來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/82ab35a2de17490c96eff21a335413b8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6f4f655.html title=C/C++編程筆記：C語言“井字棋”小遊戲，井字棋走起來>C/C++編程筆記：C語言“井字棋”小遊戲，井字棋走起來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1517c90b.html alt=C/C++編程筆記：C語言開發經典項目《五子棋大戰》，源碼分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/58189ca8d0964e4283fcc9e33b00df22 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1517c90b.html title=C/C++編程筆記：C語言開發經典項目《五子棋大戰》，源碼分享>C/C++編程筆記：C語言開發經典項目《五子棋大戰》，源碼分享</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c983d7a.html alt=C/C++編程筆記：推箱子小遊戲，大一學習C語言練手項目 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2e0e939e0a6945c495eff4c30164d3ae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c983d7a.html title=C/C++編程筆記：推箱子小遊戲，大一學習C語言練手項目>C/C++編程筆記：推箱子小遊戲，大一學習C語言練手項目</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72f2884c.html alt=C/C++編程筆記：流行的數字遊戲2048，C語言400行源代碼分享 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/810e773711f546b1bac33601023ef4e2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72f2884c.html title=C/C++編程筆記：流行的數字遊戲2048，C語言400行源代碼分享>C/C++編程筆記：流行的數字遊戲2048，C語言400行源代碼分享</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>