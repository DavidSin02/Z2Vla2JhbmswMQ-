<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>理解Java的三大特性之多態 | 极客快訊</title><meta property="og:title" content="理解Java的三大特性之多態 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/3e088ff97c2746b7b85df2221a608488"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0f8686a.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0f8686a.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="理解Java的三大特性之多態"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0f8686a.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>理解Java的三大特性之多態</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify>面向對象編程有三大特性：封裝、繼承、多態。</p><p class=ql-align-justify>封裝隱藏了類的內部實現機制，可以在不影響使用的情況下改變類的內部結構，同時也保護了數據。對外界而已它的內部細節是隱藏的，暴露給外界的只是它的訪問方法。</p><p class=ql-align-justify>繼承是為了重用父類代碼。兩個類若存在IS-A的關係就可以使用繼承。，同時繼承也為實現多態做了鋪墊。那麼什麼是多態呢？多態的實現機制又是什麼？請看我一一為你揭開：</p><p class=ql-align-justify>所謂多態就是指程序中定義的引用變量所指向的具體類型和通過該引用變量發出的方法調用在編程時並不確定，而是在程序運行期間才確定，即一個引用變量倒底會指向哪個類的實例對象，該引用變量發出的方法調用到底是哪個類中實現的方法，必須在由程序運行期間才能決定。因為在程序運行時才確定具體的類，這樣，不用修改源程序代碼，就可以讓引用變量綁定到各種不同的類實現上，從而導致該引用調用的具體方法隨之改變，即不修改程序代碼就可以改變程序運行時所綁定的具體代碼，讓程序可以選擇多個運行狀態，這就是多態性。</p><p class=ql-align-justify>比如你是一個酒神，對酒情有獨鍾。某日回家發現桌上有幾個杯子裡面都裝了白酒，從外面看我們是不可能知道這是些什麼酒，只有喝了之後才能夠猜出來是何種酒。你一喝，這是劍南春、再喝這是五糧液、再喝這是酒鬼酒….在這裡我們可以描述成如下：</p><p class=ql-align-justify>酒 a = 劍南春</p><p class=ql-align-justify>酒 b = 五糧液</p><p class=ql-align-justify>酒 c = 酒鬼酒</p><p class=ql-align-justify>…</p><p class=ql-align-justify>這裡所表現的的就是多態。劍南春、五糧液、酒鬼酒都是酒的子類，我們只是通過酒這一個父類就能夠引用不同的子類，這就是多態——我們只有在運行的時候才會知道引用變量所指向的具體實例對象。</p><p class=ql-align-justify>誠然，要理解多態我們就必須要明白什麼是“向上轉型”。在繼承中我們簡單介紹了向上轉型，這裡就在囉嗦下：在上面的喝酒例子中，酒（Win）是父類，劍南春（JNC）、五糧液（WLY）、酒鬼酒（JGJ）是子類。我們定義如下代碼：</p><p class=ql-align-justify>JNC a = new JNC();</p><p class=ql-align-justify>對於這個代碼我們非常容易理解無非就是實例化了一個劍南春的對象嘛！但是這樣呢？</p><p class=ql-align-justify>Wine a = new JNC();</p><p class=ql-align-justify>在這裡我們這樣理解，這裡定義了一個Wine 類型的a，它指向JNC對象實例。由於JNC是繼承與Wine，所以JNC可以自動向上轉型為Wine，所以a是可以指向JNC實例對象的。這樣做存在一個非常大的好處，在繼承中我們知道子類是父類的擴展，它可以提供比父類更加強大的功能，如果我們定義了一個指向子類的父類引用類型，那麼它除了能夠引用父類的共性外，還可以使用子類強大的功能。</p><p class=ql-align-justify>但是向上轉型存在一些缺憾，那就是它必定會導致一些方法和屬性的丟失，而導致我們不能夠獲取它們。所以父類類型的引用可以調用父類中定義的所有屬性和方法，對於只存在與子類中的方法和屬性它就望塵莫及了---1。</p><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3e088ff97c2746b7b85df2221a608488><p class=pgc-img-caption></p></div><p class=ql-align-justify>從程序的運行結果中我們發現，a.fun1()首先是運行父類Wine中的fun1().然後再運行子類JNC中的fun2()。</p><p class=ql-align-justify>分析：在這個程序中子類JNC重載了父類Wine的方法fun1()，重寫fun2()，而且重載後的fun1(String a)與 fun1()不是同一個方法，由於父類中沒有該方法，向上轉型後會丟失該方法，所以執行JNC的Wine類型引用是不能引用fun1(String a)方法。而子類JNC重寫了fun2() ，那麼指向JNC的Wine引用會調用JNC中fun2()方法。</p><p class=ql-align-justify>所以對於多態我們可以總結如下：</p><p class=ql-align-justify>指向子類的父類引用由於向上轉型了，它只能訪問父類中擁有的方法和屬性，而對於子類中存在而父類中不存在的方法，該引用是不能使用的，儘管是重載該方法。若子類重寫了父類中的某些方法，在調用該些方法的時候，必定是使用子類中定義的這些方法（動態連接、動態調用）。</p><p class=ql-align-justify>對於面向對象而已，多態分為編譯時多態和運行時多態。其中編輯時多態是靜態的，主要是指方法的重載，它是根據參數列表的不同來區分不同的函數，通過編輯之後會變成兩個不同的函數，在運行時談不上多態。而運行時多態是動態的，它是通過動態綁定來實現的，也就是我們所說的多態性。</p><h1 class=ql-align-justify>多態的實現</h1><p class=ql-align-justify><br></p><p class=ql-align-justify>.1實現條件</p><p class=ql-align-justify>在剛剛開始就提到了繼承在為多態的實現做了準備。子類Child繼承父類Father，我們可以編寫一個指向子類的父類類型引用，該引用既可以處理父類Father對象，也可以處理子類Child對象，當相同的消息發送給子類或者父類對象時，該對象就會根據自己所屬的引用而執行不同的行為，這就是多態。即多態性就是相同的消息使得不同的類做出不同的響應。</p><p class=ql-align-justify>Java實現多態有三個必要條件：繼承、重寫、向上轉型。</p><p class=ql-align-justify>繼承：在多態中必須存在有繼承關係的子類和父類。</p><p class=ql-align-justify>重寫：子類對父類中某些方法進行重新定義，在調用這些方法時就會調用子類的方法。</p><p class=ql-align-justify>向上轉型：在多態中需要將子類的引用賦給父類對象，只有這樣該引用才能夠具備技能調用父類的方法和子類的方法。</p><p class=ql-align-justify>只有滿足了上述三個條件，我們才能夠在同一個繼承結構中使用統一的邏輯實現代碼處理不同的對象，從而達到執行不同的行為。</p><p class=ql-align-justify>對於Java而言，它多態的實現機制遵循一個原則：當超類對象引用變量引用子類對象時，被引用對象的類型而不是引用變量的類型決定了調用誰的成員方法，但是這個被調用的方法必須是在超類中定義過的，也就是說被子類覆蓋的方法。</p><p class=ql-align-justify>2.2實現形式</p><p class=ql-align-justify>在Java中有兩種形式可以實現多態。繼承和接口。</p><p class=ql-align-justify>2.2.1、基於繼承實現的多態</p><p class=ql-align-justify>基於繼承的實現機制主要表現在父類和繼承該父類的一個或多個子類對某些方法的重寫，多個子類對同一方法的重寫可以表現出不同的行為。</p><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/05153ac0e1184d99995e967e5ff86fd9><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/61e135fec81f4a138e6544af988ddc8d><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6bd073bdac5f47989d749004c3aca628><p class=pgc-img-caption></p></div><p class=ql-align-justify>在上面的代碼中JNC、JGJ繼承Wine，並且重寫了drink()、toString()方法，程序運行結果是調用子類中方法，輸出JNC、JGJ的名稱，這就是多態的表現。不同的對象可以執行相同的行為，但是他們都需要通過自己的實現方式來執行，這就要得益於向上轉型了。</p><p class=ql-align-justify>我們都知道所有的類都繼承自超類Object，toString()方法也是Object中方法，當我們這樣寫時：</p><pre>Object o = new JGJ(); System.out.println(o.toString()); </pre><p class=ql-align-justify>輸出的結果是Wine : JGJ。</p><p class=ql-align-justify>Object、Wine、JGJ三者繼承鏈關係是：JGJ—>Wine—>Object。所以我們可以這樣說：當子類重寫父類的方法被調用時，只有對象繼承鏈中的最末端的方法才會被調用。但是注意如果這樣寫：</p><pre>Object o = new Wine(); System.out.println(o.toString()); </pre><p class=ql-align-justify>輸出的結果應該是Null，因為JGJ並不存在於該對象繼承鏈中。</p><p class=ql-align-justify>所以基於繼承實現的多態可以總結如下：對於引用子類的父類類型，在處理該引用時，它適用於繼承該父類的所有子類，子類對象的不同，對方法的實現也就不同，執行相同動作產生的行為也就不同。</p><p class=ql-align-justify>如果父類是抽象類，那麼子類必須要實現父類中所有的抽象方法，這樣該父類所有的子類一定存在統一的對外接口，但其內部的具體實現可以各異。這樣我們就可以使用頂層類提供的統一接口來處理該層次的方法。</p><p class=ql-align-justify>2.2.2、基於接口實現的多態</p><p class=ql-align-justify>繼承是通過重寫父類的同一方法的幾個不同子類來體現的，那麼就可就是通過實現接口並覆蓋接口中同一方法的幾不同的類體現的。</p><p class=ql-align-justify>在接口的多態中，指向接口的引用必須是指定這實現了該接口的一個類的實例程序，在運行時，根據對象引用的實際類型來執行對應的方法。</p><p class=ql-align-justify>繼承都是單繼承，只能為一組相關的類提供一致的服務接口。但是接口可以是多繼承多實現，它能夠利用一組相關或者不相關的接口進行組合與擴充，能夠對外提供一致的服務接口。所以它相對於繼承來說有更好的靈活性。</p><p class=ql-align-justify>三、經典實例。</p><p class=ql-align-justify>通過上面的講述，可以說是對多態有了一定的瞭解。現在趁熱打鐵，看一個實例。該實例是有關多態的經典例子。</p><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0666d64eca77413696e590f334dc203e><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a65fca2d0bf44999a1acee0cd49a1bd><p class=pgc-img-caption></p></div><p>運行結果：</p><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b888d0e43a564f54b28852c99e3c2c66><p class=pgc-img-caption></p></div><p class=ql-align-justify>在這裡看結果1、2、3還好理解，從4開始就開始糊塗了，對於4來說為什麼輸出不是“B and B”呢？</p><p class=ql-align-justify>首先我們先看一句話：當超類對象引用變量引用子類對象時，被引用對象的類型而不是引用變量的類型決定了調用誰的成員方法，但是這個被調用的方法必須是在超類中定義過的，也就是說被子類覆蓋的方法。這句話對多態進行了一個概括。其實在繼承鏈中對象方法的調用存在一個優先級：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p><p class=ql-align-justify>分析：</p><p class=ql-align-justify>從上面的程序中我們可以看出A、B、C、D存在如下關係。</p><div class=pgc-img><img alt=理解Java的三大特性之多態 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/98c49424ae934f8c884647f00b09663a><p class=pgc-img-caption></p></div><p class=ql-align-justify>首先我們分析5，a2.show(c)，a2是A類型的引用變量，所以this就代表了A，a2.show(c),它在A類中找發現沒有找到，於是到A的超類中找(super)，由於A沒有超類（Object除外），所以跳到第三級，也就是this.show((super)O)，C的超類有B、A，所以(super)O為B、A，this同樣是A，這裡在A中找到了show(A obj)，同時由於a2是B類的一個引用且B類重寫了show(A obj)，因此最終會調用子類B類的show(A obj)方法，結果也就是B and A。</p><p class=ql-align-justify>按照同樣的方法我也可以確認其他的答案。</p><p class=ql-align-justify>方法已經找到了但是我們這裡還是存在一點疑問，我們還是來看這句話：當超類對象引用變量引用子類對象時，被引用對象的類型而不是引用變量的類型決定了調用誰的成員方法，但是這個被調用的方法必須是在超類中定義過的，也就是說被子類覆蓋的方法。這我們用一個例子來說明這句話所代表的含義：a2.show(b)；</p><p class=ql-align-justify>這裡a2是引用變量，為A類型，它引用的是B對象，因此按照上面那句話的意思是說有B來決定調用誰的方法,所以a2.show(b)應該要調用B中的show(B obj)，產生的結果應該是“B and B”，但是為什麼會與前面的運行結果產生差異呢？這裡我們忽略了後面那句話“但是這兒被調用的方法必須是在超類中定義過的”，那麼show(B obj)在A類中存在嗎？根本就不存在！所以這句話在這裡不適用？那麼難道是這句話錯誤了？非也！其實這句話還隱含這這句話：它仍然要按照繼承鏈中調用方法的優先級來確認。所以它才會在A類中找到show(A obj)，同時由於B重寫了該方法所以才會調用B類中的方法，否則就會調用A類中的方法。</p><p class=ql-align-justify>所以多態機制遵循的原則概括為：當超類對象引用變量引用子類對象時，被引用對象的類型而不是引用變量的類型決定了調用誰的成員方法，但是這個被調用的方法必須是在超類中定義過的，也就是說被子類覆蓋的方法，但是它仍然要根據繼承鏈中方法調用的優先級來確認方法，該優先級為：this.show(O)、super.show(O)、this.show((super)O)、super.show((super)O)。</p><blockquote><p>原文出處：https://dwz.cn/h1Fflpl8</p><p>作者：chenssy</p></blockquote></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>三大</a></li><li><a>之多態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/653918ea.html alt=流行的三大Java框架之間的對比，不看後悔 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/55636fc365b342fca66950f9809a0f70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/653918ea.html title=流行的三大Java框架之間的對比，不看後悔>流行的三大Java框架之間的對比，不看後悔</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/132ebe4e.html alt=《新世界》三大女兒結局，柳爺抱憾終生，最慘的是她！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9c5a4af4921f4c3f808a9254e26789ad style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/132ebe4e.html title=《新世界》三大女兒結局，柳爺抱憾終生，最慘的是她！>《新世界》三大女兒結局，柳爺抱憾終生，最慘的是她！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ebe4518e.html alt=明朝衰落的三大原因，每一個都足以置國家於死地，想翻身都難 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7582eedff5d6415891a608f8e7b984dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ebe4518e.html title=明朝衰落的三大原因，每一個都足以置國家於死地，想翻身都難>明朝衰落的三大原因，每一個都足以置國家於死地，想翻身都難</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>