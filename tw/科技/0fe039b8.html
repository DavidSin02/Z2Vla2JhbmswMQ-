<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入分析 Flink SQL 工作機制 | 极客快訊</title><meta property="og:title" content="深入分析 Flink SQL 工作機制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d6fbb1aee0444698aad234b9df699720"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/0fe039b8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/0fe039b8.html><meta property="article:published_time" content="2020-10-29T21:12:20+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:20+08:00"><meta name=Keywords content><meta name=description content="深入分析 Flink SQL 工作機制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/0fe039b8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入分析 Flink SQL 工作機制</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>摘要：本文整理自 Flink Forward 2020 全球在線會議中文精華版，由 Apache Flink PMC 伍翀（雲邪）分享，社區志願者陳婧敏（清樾）整理。旨在幫助大家更好地理解 Flink SQL 引擎的工作原理。文章主要分為以下四部分：</p><p><br></p><ol start=1><li>Flink SQL Architecture</li><li>How Flink SQL Works?</li><li>Flink SQL Optimizations</li><li>Summary and Futures</li></ol><p><br></p><p><strong>Tips：</strong>點擊下方鏈接可查看作者分享的原版視頻～<br>https://ververica.cn/developers/flink-forward-virtual-conference/</p><p><br></p><p>Apache Flink 社區在最近的兩個版本（1.9 & 1.10 ）中為面向未來的統一流批處理在架構層面做了很多優化，其中一個重大改造是引入了 Blink Planner，開始支持 SQL & Table API 使用不同的 SQL Planner 進行編譯（Planner 的插件化）。</p><p><br></p><p>本文首先會介紹推動這些優化背後的思考，展示統一的架構如何更好地處理流式和批式查詢，其次將深入剖析 Flink SQL 的編譯及優化過程，包括：</p><p></p><ol start=1><li>Flink SQL 利用 Apache Calcite 將 SQL 翻譯為關係代數表達式，使用表達式摺疊（Expression Reduce），下推優化（Predicate / Projection Pushdown ）等優化技術生成物理執行計劃（Physical Plan），利用 Codegen 技術生成高效執行代碼。</li><li>Flink SQL 使用高效的二進制數據存儲結構 BinaryRow 加速計算性能；使用 Mini-batch 攢批提高吞吐，降低兩層聚合時由 Retraction 引起的數據抖動；聚合場景下數據傾斜處理和 Top-N 排序的優化原理。</li></ol><p></p><p><strong>Flink SQL 架構 & Blink Planner（1.9+ ）</strong></p><p><br></p><p><strong>1.1 Old Planner 的限制</strong></p><p>要想了解 Flink SQL 在1.9 版本引入新架構的動機，我們首先看下 1.9 版本之前的架構設計。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d6fbb1aee0444698aad234b9df699720><p class=pgc-img-caption></p></div><p><br></p><p>從圖中可以看出，雖然面向用戶的 Table API & SQL 是統一的，但是流式和批式任務在翻譯層分別對應了 DataStreamAPI 和 DataSetAPI，在 Runtime 層面也要根據不同的 API 獲取執行計劃，兩層的設計使得整個架構能夠複用的模塊有限，不易擴展。</p><p></p><p><strong>1.2 統一的 Blink Planner</strong></p><p></p><p>Flink 在設計之初就遵循“批是流的特例”的理念，在架構上做到流批統一是大勢所趨。在社區和阿里巴巴的共同努力下，1.9 版本引入了新的 Blink Planner，將批 SQL 處理作為流 SQL 處理的特例，儘量對通用的處理和優化邏輯進行抽象和複用，通過 Flink 內部的 Stream Transformation API 實現流 & 批的統一處理，替代原 Flink Planner 將流 & 批區分處理的方式。</p><p></p><p>此外，新架構通過靈活的插件化方式兼容老版本 Planner，用戶可自行選擇。不過在 1.11 版本 Blink Planner 會代替 Old Planner 成為默認的 Planner 來支持流 & 批進一步融合統一（ Old Planner 將在之後逐步退出歷史舞臺）。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/7f086d1afa2d4507b81a8eb9e74fd114><p class=pgc-img-caption></p></div><p><strong>Flink SQL 工作流</strong></p><p></p><p>Flink SQL 引擎的工作流總結如圖所示。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f62084e2044c4dfdbf7248c5eb13f77d><p class=pgc-img-caption></p></div><p></p><p>從圖中可以看出，一段查詢 SQL / 使用TableAPI 編寫的程序（以下簡稱 TableAPI 代碼）從輸入到編譯為可執行的 JobGraph 主要經歷如下幾個階段</p><p></p><ol start=1><li>將 SQL文本 / TableAPI 代碼轉化為邏輯執行計劃（Logical Plan）</li><li>Logical Plan 通過優化器優化為物理執行計劃（Physical Plan）</li><li>通過代碼生成技術生成 Transformations 後進一步編譯為可執行的 JobGraph 提交運行</li></ol><p><br></p><p>本節將重點對 Flink SQL 優化器的常用優化方法和 CodeGen 生成 Transformations 進行介紹。</p><p></p><p><strong>2.1 Logical Planning</strong></p><p></p><p>Flink SQL 引擎使用 Apache Calcite SQL Parser 將 SQL 文本解析為詞法樹，SQL Validator 獲取 Catalog 中元數據的信息進行語法分析和驗證，轉化為關係代數表達式（RelNode），再由 Optimizer 將關係代數表達式轉換為初始狀態的邏輯執行計劃。</p><p><br></p><p>備註：TableAPI 代碼使用 TableAPI Validator 對接 Catalog 後生成邏輯執行計劃。</p><p></p><p>E.g.1 考慮如下表達 JOIN 操作的一段 SQL。</p><p></p><ul><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre><code>SELECT   t1.id, 1 + 2 + t1.value AS v FROM t1, t2 WHERE   t1.id = t2.id AND   t2.id &lt; 1000</code></pre><p></p><p>經過上述操作後得到了一個樹狀結構的邏輯執行計劃，根節點對應最上層的 Select 語句，葉子節點對應輸入表 t1 和 t2 的 TableScan 操作，Join 和 Where 條件過濾 分別對應了 Join 和 Filter 節點。</p><p></p><ul><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre><code>LogicalProject(id=[$0], v=[+(+(1, 2), $1)])+- LogicalFilter(condition=[AND(=($0, $3), &lt;($3, 1000))])   +- LogicalJoin(condition=[true], joinType=[inner])      :- LogicalTableScan(table=[[default_catalog, default, t1]])      +- LogicalTableScan(table=[[default_catalog, default, t2]])</code></pre><p><br></p><p>可視化後如圖所示，這是優化器開始工作的初始狀態。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e3ad689122e40f293c140e607b8d87b><p class=pgc-img-caption></p></div><p></p><p>下面開始介紹 Flink SQL 優化器常見的幾種優化方式。</p><p></p><p><strong>■ 2.1.1 Expression Reduce</strong></p><p></p><p>表達式（Expression） 是 SQL 中最常見的語法。比如 t1.id 是一個表達式， 1 + 2 + t1.value 也是一個表達式。優化器在優化過程中會遞歸遍歷樹上節點，儘可能預計算出每個表達式的值，這個過程就稱為表達式摺疊。這種轉換在邏輯上等價，通過優化後，真正執行時不再需要為每一條記錄都計算一遍 1 + 2。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ec6550d8b62f47d59c6f028b4c7530c3><p class=pgc-img-caption></p></div><p></p><p><strong>■ 2.1.2 PushDown Optimization</strong></p><p></p><p>下推優化是指在保持關係代數語義不變的前提下將 SQL 語句中的變換操作儘可能下推到靠近數據源的位置以獲得更優的性能，常見的下推優化有謂詞下推（Predicate Pushdown），投影下推（Projection Pushdown，有時也譯作列裁剪）等。</p><p></p><ul><li>Predicate Pushdown</li></ul><p>回顧 E.g.1，我們發現 WHERE 條件表達式中 t2.id &lt; 1000 這個過濾條件描述的是對錶 t2 的約束，跟表 t1 無關，完全可以下推到 JOIN 操作之前完成。假設表 t2 中有一百萬行數據，但是滿足 id &lt; 1000 的數據只有 1,000 條，則通過謂詞下推優化後到達 JOIN 節點的數據量降低了1,000 倍，極大地節省了 I / O 開銷，提升了 JOIN 性能。</p><p><br></p><p>謂詞下推（Predicate Pushdown）是優化 SQL 查詢的一項基本技術，謂詞一詞來源於數學，指能推導出一個布爾返回值（TRUE / FALSE）的函數或表達式，通過判斷布爾值可以進行數據過濾。謂詞下推是指保持關係代數語義不變的前提下將 Filter 儘可能移至靠近數據源的位置（比如讀取數據的 SCAN 階段）來降低查詢和傳遞的數據量（記錄數）。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f4f3c802cf1e45fc9fa9eadc4c6b6b93><p class=pgc-img-caption></p></div><p><br></p><ul><li>Projection Pushdown</li></ul><p><br></p><p>列裁剪是 Projection Pushdown 更直觀的描述方式，指在優化過程中去掉沒有使用的列來降低 I / O 開銷，提升性能。但與謂詞下推只移動節點位置不同，投影下推可能會增加節點個數。比如最後計算出的投影組合應該放在 TableScan 操作之上，而 TableScan 節點之上沒有 Projection 節點，優化器就會顯式地新增 Projection 節點來完成優化。另外如果輸入表是基於列式存儲的（如 Parquet 或 ORC 等），優化還會繼續下推到 Scan 操作中進行。</p><p><br></p><p>回顧 E.g.1，我們發現整個查詢中只用到了表 t1 的 id 和 value 字段，表 t2 的 id 字段，在 TableScan 節點之上分別增加 Projection 節點去掉多餘字段，極大地節省了 I / O 開銷。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4d6d4ccc758940d99a61a37c61d55e8c><p class=pgc-img-caption></p></div><p><br></p><p>簡要總結一下，謂詞下推和投影下推分別通過避免處理不必要的記錄數和字段數來降低 I / O 開銷提升性能。</p><p></p><p><strong>2.2 Physical Planning on Batch</strong></p><p></p><p>通過上述一系列操作後，我們得到了優化後的邏輯執行計劃。邏輯執行計劃描述了執行步驟和每一步需要完成的操作，但沒有描述操作的具體實現方式。而物理執行計劃會考慮物理實現的特性，生成每一個操作的具體實現方式。比如 Join 是使用 SortMergeJoin、HashJoin 或 BroadcastHashJoin 等。優化器在生成邏輯執行計劃時會計算整棵樹上每一個節點的 Cost，對於有多種實現方式的節點（比如 Join 節點），優化器會展開所有可能的 Join 方式分別計算。最終整條路徑上 Cost 最小的實現方式就被選中成為 Final Physical Plan。</p><p></p><p>回顧 E.g.1，當它以批模式執行，同時我們可以拿到輸入表的 Statistics 信息。在經過前述優化後，表 t2 到達 Join 節點時只有 1,000 條數據，使用 BroadcastJoin 的開銷相對最低，則最終的 Physical Plan 如下圖所示。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8d6dcf08df12417c9f7cdcf1e9a8bc07><p class=pgc-img-caption></p></div><p><strong>2.3 Translation & Code Generation</strong></p><p></p><p>代碼生成（Code Generation） 在計算機領域是一種廣泛使用的技術。在 Physical Plan 到生成 Transformation Tree 過程中就使用了 Code Generation。</p><p></p><p>回顧 E.g.1，以 表 t2 之上的 Calc 節點 t2.id &lt; 1000 表達式為例，通過 Code Generation 後生成了描述 Transformation Operator 的一段 Java 代碼，將接收到的 Row 中 id &lt; 1000 的 Row 發送到下一個 Operator。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a6a8fb9f40c74be0b23661266db133e4><p class=pgc-img-caption></p></div><p><br></p><p>Flink SQL 引擎會將 Physical Plan 通過 Code Generation 翻譯為 Transformations，再進一步編譯為可執行的 JobGraph。</p><p></p><p><strong>2.4 Physical Planning on Stream</strong></p><p></p><p>以上介紹了 Flink SQL 引擎的整體工作流，上述例子是假定以批模式編譯的，下面我們來介紹一下以流模式編譯時，在生成 Physical Plan 過程中的一個重要機制：Retraction Mechanism （aka. Changelog Mechanism）。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0a10e748a76d429abb6e2752e3fdb4be><p class=pgc-img-caption></p></div><p></p><p>■ <strong>2.4.1 Retraction Mechanism</strong></p><p></p><p>Retraction 是流式數據處理中撤回過早下發（Early Firing）數據的一種機制，類似於傳統數據庫的 Update 操作。級聯的聚合等複雜 SQL 中如果沒有 Retraction 機制，就會導致最終的計算結果與批處理不同，這也是目前業界很多流計算引擎的缺陷。</p><p></p><p>E.g.2 考慮如下統計詞頻分佈的 SQL。</p><p></p><ul><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre><code>SELECT cnt, COUNT(cnt) as freqFROM (  SELECT word, COUNT(*) as cnt  FROM words  GROUP BY word)GROUP BY cnt</code></pre><p><br></p><p>假設輸入數據是：</p><p><br></p><p><strong>word</strong>HelloWorldHello</p><p><br></p><p>則經過上面的計算後，預期的輸出結果應該是：</p><p><br></p><p><strong>cnt</strong></p><p><strong>freq</strong></p><p>1</p><p>1</p><p>2</p><p>1</p><p></p><p>但與批處理不同，流處理的數據是一條條到達的，理論上每一條數據都會觸發一次計算，所以在處理了第一個 Hello 和第一個 World 之後，詞頻為 1 的單詞數已經變成了 2，此時再處理第二個 Hello 時，如果不能修正之前的結果，Hello 就會在詞頻等於 1 和詞頻等於 2 這兩個窗口下被同時統計，顯然這個結果是錯誤的，這就是沒有 Retraction 機制帶來的問題。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/00f19071e7cb446696dd8d1d33ab9414><p class=pgc-img-caption></p></div><p><br></p><p>Flink SQL 在流計算領域中的一個重大貢獻就是首次提出了這個機制的具體實現方案。Retraction 機制又名 Changelog 機制，因為某種程度上 Flink 將輸入的流數據看作是數據庫的 Changelog，每條輸入數據都可以看作是對數據庫的一次變更操作，比如 Insert，Delete 或者 Update。以 MySQL 數據庫為例，其Binlog 信息以二進制形式存儲，其中 Update_rows_log_event 會對應 2 條標記 Before Image （BI） 和 After Image （AI），分別表示某一行在更新前後的信息。</p><p></p><p>在 Flink SQL 優化器生成流作業的 Physical Plan 時會判斷當前節點是否是更新操作，如果是則會同時發出 2 條消息 update_before 和 update_after 到下游節點，update_before 表示之前“錯誤”下發的數據，需要被撤回，update_after 表示當前下發的“正確”數據。下游收到後，會在結果上先減去 update_before，再加上 update_after。</p><p></p><p>回顧 E.g.2，下面的動圖演示了加入 Retraction 機制後正確結果的計算過程。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/81a15a732f1741cfafd148082d6e5f50><p class=pgc-img-caption></p></div><p></p><p>update_before 是一條非常關鍵的信息，相當於標記出了導致當前結果不正確的那個“元凶”。不過額外操作會帶來額外的開銷，有些情況下不需要發送 update_before 也可以獲得正確的結果，比如下游節點接的是 UpsertSink（MySQL 或者 HBase的情況下，數據庫可以按主鍵用 update_after 消息覆蓋結果）。是否發送 update_before 由優化器決定，用戶不需要關心。</p><p></p><p>■ <strong>2.4.2 Update_before Decision</strong></p><p></p><p>前面介紹了 Retraction 機制和 update_before，那優化器是怎樣決定是否需要發送update_before 呢？本節將介紹這一部分的工作。</p><p></p><p><strong>Step1：確定每個節點對應的 Changelog 變更類型</strong></p><p></p><p>數據庫中最常見的三種操作類型分別是 Insert （記為 [I]），Delete（記為 [D]），Update（記為 [U]）。優化器首先會自底向上檢查每個節點，判斷它屬於哪（幾）種類型，分別打上對應標記。</p><p></p><p>回顧 E.g.2，第一個 Source 節點由於只產生新數據，所以屬於 Insert，記為 [I]；第二個節點計算內層的聚合，所以會發出更新的消息，記為 [I，U]；第三個節點裁掉 word 字段，屬於簡單計算，傳遞了上游的變更類型，記為 [I，U]；第四個節點是外層的聚合計算，由於它收到了來自上游的 Update 消息，所以額外需要 Delete 操作來保證更新成功，記為 [I，U，D]。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a933a27f80d4151a4a580a5d76074ce><p class=pgc-img-caption></p></div><p><br></p><p><strong>Step2：確定每個節點發送的消息類型</strong></p><p></p><p>在介紹 Step2 之前，我們先介紹下 Flink 中 Update 消息類型的表示形式。在 Flink 中 Update 由兩條 update_before（簡稱 UB）和 update_after （簡稱 UA）來表示，其中 UB 消息在某些情況下可以不發送，從而提高性能。</p><p></p><p>在 Step1 中優化器自底向上推導出了每個節點對應的 Changelog 變更操作，這一步裡會先自頂向下推斷當前節點需要父節點提供的消息類型，直到遇到第一個不需要父節點提供任何消息類型的節點，再往上回推每個節點最終的實現方式和需要的消息類型。</p><p></p><p>回顧 E.g.2，由於最上層節點是 UpsertSink 節點，只需要它的父節點提供 [UA] 即可。到了外層聚合的 Aggregate 節點，由於 Aggregate 節點的輸入有 Update 操作，所以需要父節點需要提供 [UB，UA]，這樣才能正確更新自己的計算狀態。</p><p><br></p><p>再往下到 Calc 節點，它需要傳遞 [UB，UA] 的需求給它的父節點，也就是內層的 Aggregate 節點。而到了內層 Aggregation 節點，它的父節點是 Source 節點，不會產生 Update 操作，所以它不需要 Source 節點額外發送任何 [UB / UA ]。當優化器遍歷到 Source 節點，便開始進行回溯，如果當前節點能滿足子節點的 requirement，則將對應的標籤更新到節點上，否則便無法生成 plan。首先內層的 Aggregate 能產生 UB，所以能滿足子節點的 requirement，所以優化器會給內層的 Aggregate 節點打上 [UB，UA] 的標籤，然後向上傳遞到 Calc 節點，同樣打上 [UB，UA] ，再到外層的 Aggregate 節點，由於它的下游只需要接受更新後的消息，所以打上 [UA] 標籤，表示它只需要向下遊發送 update_after 即可。</p><p></p><p>這些標籤最終會影響算子的物理實現，比如外層的 Aggregate 節點，由於它會接收到來自上游的 [UB]，所以物理實現會使用帶 Retract 的 Count，同時它只會向 Sink 發送 update_after。而內層的 Aggregate 節點，由於上游發送過來的數據沒有 [UB]，所以可以採用不帶 Retract 的 Count 實現，同時由於帶有 [UB] 標籤，所以需要往下游發送 update_before。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1617f51405be4053b5d98ef5715048de><p class=pgc-img-caption></p></div><p><br></p><p><strong>Flink SQL Internal Optimization</strong></p><p></p><p>前面介紹了 Flink SQL 引擎的工作原理，接下來會簡要概括一下 Flink SQL 內部的一些優化，更多資料可以在 Flink Forward Asia 2019 查看。</p><p></p><p><strong>3.1 BinaryRow</strong></p><p></p><p>在 Flink 1.9+ 前， Flink Runtime 層各算子間傳遞的數據結構是 Row，其內部實現是 Object[]。這種數據結構的問題在於不但需要額外開銷存 Object Metadata，計算過程中還涉及到大量序列化 / 反序列 （特別是只需要處理某幾個字段時需要反序列化整個 Row），primitive 類型的拆 / 裝箱等，都會帶來大量額外的性能開銷。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/266c433c1150412485adcb2a0d5e8c0d><p class=pgc-img-caption></p></div><p><br></p><p>Flink 1.9 開始引入了 Blink Planner，使用二進制數據結構的 BinaryRow 來表示 Record。BinaryRow 作用於默認大小為 32K 的 Memory Segment，直接映射到內存。BinaryRow 內部分為 Header，定長區和變長區。Header 用於存儲 Retraction 消息的標識，定長區使用 8 個 bytes 來記錄字段的 Nullable 信息及所有 primitive 和可以在 8 個 bytes 內表示的類型。其它類型會按照基於起始位置的 offset 存放在變長區。</p><p></p><p>BinaryRow 作為 Blink Planner 的基礎數據結構，帶來的好處是顯而易見的：首先存儲上更為緊湊，去掉了額外開銷；其次在序列化和反序列化上帶來的顯著性能提升，可根據 offset 只反序列化需要的字段，在開啟 Object Reuse 後，序列化可以直接通過內存拷貝完成。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d3849ce072664c36966d2e2f95027d3b><p class=pgc-img-caption></p></div><p></p><p><strong>3.2 Mini-batch Processing</strong></p><p></p><p>Flink 是純流式處理框架，在理論上每一條新到的數據都會觸發一次計算。然而在實現層面，這樣做會導致聚合場景下每處理一條數據都需要讀寫 State 及序列化 / 反序列化。如果能夠在內存中 buffer 一定量的數據，預先做一次聚合後再更新 State，則不但會降低操作 State 的開銷，還會有效減少發送到下游的數據量，提升 throughput，降低兩層聚合時由 Retraction 引起的數據抖動, 這就是 Mini-batch 攢批優化的核心思想。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c1af33d8000b4c3db76d8667be032971><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.3 Skew Processing</strong></p><p></p><p>對於數據傾斜的優化，主要分為是否帶 DISTINCT 去重語義的兩種方式。對於普通聚合的數據傾斜，Flink 引入了 Local-Global 兩階段優化，類似於 MapReduce 增加 Local Combiner 的處理模式。而對於帶有去重的聚合，Flink 則會將用戶的 SQL 按原有聚合的 key 組合再加上 DISTINCT key 做 Hash 取模後改寫為兩層聚合來進行打散。</p><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/3007f89bfafc416191132b6cd26d09fe><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.4 Top-N Rewrite</strong></p><p></p><p>全局排序在流式的場景是很難實現的，但如果只需要計算到目前的 Top-N 極值，問題就變得可解。不過傳統數據庫求排序的 SQL 語法是通過 ORDER BY 加 LIMIT 限制條數，背後實現的機制也是通過掃描全表排序後再返回 LIMIT 條數的記錄。另外如果按照某些字段開窗排序，ORDER BY 也無法滿足要求。Flink SQL 借鑑了批場景下開窗求 Top-N 的語法，使用 ROW_NUMBER 語法來做流場景下的 Top-N 排序。</p><p></p><p>E.g.3 下面這段 SQL 計算了每個類目下銷量 Top3 的店鋪</p><p></p><ul><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre><code>SELECT*FROM(  SELECT *, -- you can get like shopId or other information from this    ROW_NUMBER() OVER (PARTITION BY category ORDER BY sales DESC) AS rowNum  FROM shop_sales ) WHERE rowNum &lt;= 3</code></pre><p><br></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/67df9ada63524bc1a488b89613f02988><p class=pgc-img-caption></p></div><p><br></p><p>在生成 Plan 方面，ROW_NUMBER 語義對應 OverAggregate 窗口節點和一個過濾行數的 Calc 節點，而這個窗口節點在實現層面需要為每一個到達的數據重新將 State 中的歷史數據拿出來排序，這顯然不是最優解。</p><p></p><p>我們知道流式場景求解極大 / 小值的最優操作是通過維護一個 size 為 N 的 minHeap / maxHeap。由實現反推出我們需要在優化器上新增一條規則，在遇到 ROW_NUMBER 生成的邏輯節點後，將其優化為一個特殊的 Rank 節點，對應上述的最優實現方式（當然這只是特殊 Rank 對應的其中一種實現）。這便是 Top-N Rewrite 的核心思想。</p><p></p><div class=pgc-img><img alt="深入分析 Flink SQL 工作機制" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1410faf3bc834c4591197e052a55e33e><p class=pgc-img-caption></p></div><p><br></p><p><strong>Summary & Futures</strong></p><p><strong>本文內容回顧</strong></p><p></p><p>1. 簡要介紹 Flink 1.9 + 在 SQL & TableAPI 上引入新架構，統一技術棧，朝著流 & 批一體的方向邁進了一大步。</p><p>2. 深入介紹 Flink SQL 引擎的內部運行機制，以及在對用戶透明的同時，Flink SQL 在優化方面做的許多工作。</p><p></p><p><strong>未來工作計劃</strong></p><p></p><ol start=1><li>在 Flink 1.11+ 後的版本，Blink Planner 將作為默認的 Planner 提供生產級別的支持。</li><li>FLIP-95：重構 TableSource & TableSink 的接口設計，面向流批一體化，在 Source 端支持 changelog 消息流，從而支持 FLIP-105 的 CDC 數據源。</li><li>FLIP-105：Flink TableAPI & SQL 對 CDC 的支持。</li><li>FLIP-115：擴展目前只支持 CSV 的 FileSystem Connector，使其成為流批統一的 Generalized FileSystem Connector。</li><li>FLIP-123：對 Hive DDL 和 DML 的兼容，支持用戶在 Flink 中運行 Hive DDL。</li></ol></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Flink</a></li><li><a>SQL</a></li><li><a>機制</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/125dee29.html alt="SQL Server中的事務與鎖" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/125dee29.html title="SQL Server中的事務與鎖">SQL Server中的事務與鎖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html alt=事務機制和鎖機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html title=事務機制和鎖機制>事務機制和鎖機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html alt=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html title=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位>天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html alt="深入理解 Java 併發核心機制，看完後好爽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/832db421a3364a20a62c93127ea6e862 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8c21d419.html title="深入理解 Java 併發核心機制，看完後好爽">深入理解 Java 併發核心機制，看完後好爽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html alt="SQL 難點解決：記錄的引用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a1b904121564aa389aba6a046772870 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html title="SQL 難點解決：記錄的引用">SQL 難點解決：記錄的引用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html alt=市稅務局創新制度機制爭創“模範機關” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d879650a7d06416c90fb7286175f1f59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/297117d9.html title=市稅務局創新制度機制爭創“模範機關”>市稅務局創新制度機制爭創“模範機關”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html alt="機制砂 | 大家知多少？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/54b1eea319b842bcb8483f4056798bec style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce33eab5.html title="機制砂 | 大家知多少？">機制砂 | 大家知多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html alt=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2b6d9a5dccf246aeaba80b2a1ecb9f0a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/095e0499.html title=機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？>機制砂市價多少錢一噸？一方機制砂折算成噸大概多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html alt=幾種基於可靠性指標的容量支持機制分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZYfwddDNSSyQW style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5dcd6724.html title=幾種基於可靠性指標的容量支持機制分析>幾種基於可靠性指標的容量支持機制分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html alt=java反射機制的講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9ad2c92f100a4d2e8213dcf70d4781c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67e6cfe.html title=java反射機制的講解>java反射機制的講解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>