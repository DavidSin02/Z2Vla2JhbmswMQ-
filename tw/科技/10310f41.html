<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「乾貨」常用排序算法總結，必收藏系列 | 极客快訊</title><meta property="og:title" content="「乾貨」常用排序算法總結，必收藏系列 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/d8acebd059bd4f4bba84851e32fa7ce7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/10310f41.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/10310f41.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/10310f41.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="「乾貨」常用排序算法總結，必收藏系列"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/10310f41.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「乾貨」常用排序算法總結，必收藏系列</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p class=ql-align-justify><br></p><p class=ql-align-justify>我們通常所說的排序算法往往指的是<strong>內部排序算法</strong>，即數據記錄在內存中進行排序。</p><p class=ql-align-justify><strong>排序算法大體可分為兩種：</strong></p><p class=ql-align-justify>一種是<strong>比較排序</strong>，時間複雜度O(nlogn) ~ O(n^2)，主要有：<strong>冒泡排序</strong>，<strong>選擇排序</strong>，<strong>插入排序</strong>，<strong>歸併排序</strong>，<strong>堆排序</strong>，<strong>快速排序</strong>等。</p><p class=ql-align-justify>另一種是<strong>非比較排序</strong>，時間複雜度可以達到O(n)，主要有：<strong>計數排序</strong>，<strong>基數排序</strong>，<strong>桶排序</strong>等。</p><p>這裡我們來探討一下常用的比較排序算法，非比較排序算法將在下一篇文章中介紹。下表給出了常見比較排序算法的性能：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d8acebd059bd4f4bba84851e32fa7ce7><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>有一點我們很容易忽略的是<strong>排序算法的穩定性</strong>(騰訊校招2016筆試題曾考過)。</p><p>排序算法穩定性的簡單形式化定義為：<strong>如果Ai = Aj，排序前Ai在Aj之前，排序後Ai還在Aj之前，則稱這種排序算法是穩定的。</strong></p><p>通俗地講就是保證排序前後兩個相等的數的相對順序不變。</p><p>對於不穩定的排序算法，只要舉出一個實例，即可說明它的不穩定性；而對於穩定的排序算法，必須對算法進行分析從而得到穩定的特性。</p><p>需要注意的是，排序算法是否為穩定的是由具體算法決定的，不穩定的算法在某種條件下可以變為穩定的算法，而穩定的算法在某種條件下也可以變為不穩定的算法。</p><p>例如，對於冒泡排序，原本是穩定的排序算法，如果將記錄交換的條件改成A[i] >= A[i + 1]，則兩個相等的記錄就會交換位置，從而變成不穩定的排序算法。</p><p>其次，說一下排序算法穩定性的好處。<strong>排序算法如果是穩定的，那麼從一個鍵上排序，然後再從另一個鍵上排序，前一個鍵排序的結果可以為後一個鍵排序所用。</strong></p><p>基數排序就是這樣，先按低位排序，逐次按高位排序，低位排序後元素的順序在高位也相同時是不會改變的。</p><p class=ql-align-justify><strong>冒泡排序(Bubble Sort)</strong></p><p>冒泡排序是一種極其簡單的排序算法，也是我所學的第一個排序算法。</p><p>它重複地走訪過要排序的元素，依次比較相鄰兩個元素，如果他們的順序錯誤就把他們調換過來，直到沒有元素再需要交換，排序完成。</p><p>這個算法的名字由來是因為越小(或越大)的元素會經由交換慢慢“浮”到數列的頂端</p><p><strong>冒泡排序算法的運作如下：</strong></p><ol><li class=ql-align-justify>比較相鄰的元素，如果前一個比後一個大，就把它們兩個調換位置。</li><li class=ql-align-justify>對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。</li><li class=ql-align-justify>針對所有的元素重複以上的步驟，除了最後一個。</li><li class=ql-align-justify>持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。</li></ol><p>由於它的簡潔，冒泡排序通常被用來對於程序設計入門的學生介紹算法的概念。</p><p><strong>冒泡排序的代碼如下：</strong></p><p class=ql-align-justify><br></p><blockquote><br>#include &lt;stdio.h>// 分類 -------------- 內部比較排序// 數據結構 ---------- 數組// 最差時間複雜度 ---- O(n^2)// 最優時間複雜度 ---- 如果能在內部循環第一次運行時,使用一個旗標來表示有無需要交換的可能,可以把最優時間複雜度降低到O(n)// 平均時間複雜度 ---- O(n^2)// 所需輔助空間 ------ O(1)// 穩定性 ------------ 穩定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void BubbleSort(int A[], int n){ for (int j = 0; j &lt; n - 1; j++) // 每次最大元素就像氣泡一樣"浮"到數組的最後 { for (int i = 0; i &lt; n - 1 - j; i++) // 依次比較相鄰的兩個元素,使較大的那個向後移 { if (A[i] > A[i + 1]) // 如果條件改成A[i] >= A[i + 1],則變為不穩定的排序算法 { Swap(A, i, i + 1); } } }}int main(){ int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 從小到大冒泡排序 int n = sizeof(A) / sizeof(int); BubbleSort(A, n); printf("冒泡排序結果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p class=ql-align-justify><br></p><p>上述代碼對序列{ 6, 5, 3, 1, 8, 7, 2, 4 }進行冒泡排序的實現過程如下</p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0fdd1e20765f439da20559c592ea5ee0><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>使用冒泡排序為一列數字進行排序的過程如右圖所示：</p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5268d10422d94a8da8c297482636f406><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>儘管冒泡排序是最容易瞭解和實現的排序算法之一，但它對於少數元素之外的數列排序是很沒有效率的。</p><p>冒泡排序的改進：<strong>雞尾酒排序</strong></p><p>雞尾酒排序，也叫<strong>定向冒泡排序</strong>，是冒泡排序的一種改進。</p><p>此算法與冒泡排序的不同處在於<strong>從低到高然後從高到低</strong>，而冒泡排序則僅從低到高去比較序列裡的每個元素。他可以得到比冒泡排序稍微好一點的效能。</p><p>雞尾酒排序的代碼如下：</p><blockquote><br>#include &lt;stdio.h>// 分類 -------------- 內部比較排序// 數據結構 ---------- 數組// 最差時間複雜度 ---- O(n^2)// 最優時間複雜度 ---- 如果序列在一開始已經大部分排序過的話,會接近O(n)// 平均時間複雜度 ---- O(n^2)// 所需輔助空間 ------ O(1)// 穩定性 ------------ 穩定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void CocktailSort(int A[], int n){ int left = 0; // 初始化邊界 int right = n - 1; while (left &lt; right) { for (int i = left; i &lt; right; i++) // 前半輪,將最大元素放到後面 { if (A[i] > A[i + 1]) { Swap(A, i, i + 1); } } right--; for (int i = right; i > left; i--) // 後半輪,將最小元素放到前面 { if (A[i - 1] > A[i]) { Swap(A, i - 1, i); } } left++; }}int main(){ int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 從小到大定向冒泡排序 int n = sizeof(A) / sizeof(int); CocktailSort(A, n); printf("雞尾酒排序結果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p>使用雞尾酒排序為一列數字進行排序的過程如右圖所示：　　</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/93824d00c1ed4761b5a3ec05db744870><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>以序列(2,3,4,5,1)為例，雞尾酒排序只需要訪問一次序列就可以完成排序，但如果使用冒泡排序則需要四次。</p><p>但是在亂數序列的狀態下，雞尾酒排序與冒泡排序的效率都很差勁。</p><p class=ql-align-justify><strong>選擇排序(Selection Sort)</strong></p><p>選擇排序也是一種簡單直觀的排序算法。</p><p>它的工作原理很容易理解：初始時在序列中找到最小（大）元素，放到序列的起始位置作為已排序序列；然後，再從剩餘未排序元素中繼續尋找最小（大）元素，放到已排序序列的末尾。</p><p>以此類推，直到所有元素均排序完畢。</p><p>注意選擇排序與冒泡排序的區別：</p><p>冒泡排序通過依次交換相鄰兩個順序不合法的元素位置，從而將當前最小（大）元素放到合適的位置；</p><p>而選擇排序每遍歷一次都記住了當前最小（大）元素的位置，最後僅需一次交換操作即可將其放到合適的位置。</p><p><strong>選擇排序的代碼如下：</strong></p><blockquote><br>#include &lt;stdio.h>// 分類 -------------- 內部比較排序// 數據結構 ---------- 數組// 最差時間複雜度 ---- O(n^2)// 最優時間複雜度 ---- O(n^2)// 平均時間複雜度 ---- O(n^2)// 所需輔助空間 ------ O(1)// 穩定性 ------------ 不穩定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void SelectionSort(int A[], int n){ for (int i = 0; i &lt; n - 1; i++) // i為已排序序列的末尾 { int min = i; for (int j = i + 1; j &lt; n; j++) // 未排序序列 { if (A[j] &lt; A[min]) // 找出未排序序列中的最小值 { min = j; } } if (min != i) { Swap(A, min, i); // 放到已排序序列的末尾，該操作很有可能把穩定性打亂，所以選擇排序是不穩定的排序算法 } }}int main(){ int A[] = { 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }; // 從小到大選擇排序 int n = sizeof(A) / sizeof(int); SelectionSort(A, n); printf("選擇排序結果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p class=ql-align-justify><br></p><p>上述代碼對序列{ 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 }進行選擇排序的實現過程如右圖：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/41a25e8610d54e97b2098f32f6a7a9c8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>使用選擇排序為一列數字進行排序的宏觀過程：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46c1b40376c04e7d80ccb333dea14850><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>選擇排序是不穩定的排序算法，不穩定發生在最小元素與A[i]交換的時刻。</strong></p><p>比如序列：{ 5, 8, 5, 2, 9 }，一次選擇的最小元素是2，然後把2和第一個5進行交換，從而改變了兩個元素5的相對次序。</p><p class=ql-align-justify><strong>插入排序(Insertion Sort)</strong></p><p>插入排序是一種簡單直觀的排序算法。它的工作原理非常類似於我們抓撲克牌</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c313af7062b540e3a9429eb2ffdae892><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>對於未排序數據(右手抓到的牌)，在已排序序列(左手已經排好序的手牌)中從後向前掃描，找到相應位置並插入。</p><p>插入排序在實現上，通常採用in-place排序（即只需用到O(1)的額外空間的排序），因而在從後向前掃描過程中，需要反覆把已排序元素逐步向後挪位，為最新元素提供插入空間。</p><p><strong>具體算法描述如下：</strong></p><ol><li class=ql-align-justify>從第一個元素開始，該元素可以認為已經被排序</li><li class=ql-align-justify>取出下一個元素，在已經排序的元素序列中從後向前掃描</li><li class=ql-align-justify>如果該元素（已排序）大於新元素，將該元素移到下一位置</li><li class=ql-align-justify>重複步驟3，直到找到已排序的元素小於或者等於新元素的位置</li><li class=ql-align-justify>將新元素插入到該位置後</li><li class=ql-align-justify>重複步驟2~5</li></ol><p class=ql-align-justify><br></p><p><strong>插入排序的代碼如下：</strong></p><p>#include &lt;stdio.h></p><p class=ql-align-justify><br></p><p>// 分類 ------------- 內部比較排序</p><p>// 數據結構 ---------- 數組</p><p>// 最差時間複雜度 ---- 最壞情況為輸入序列是降序排列的,此時時間複雜度O(n^2)</p><p>// 最優時間複雜度 ---- 最好情況為輸入序列是升序排列的,此時時間複雜度O(n)</p><p>// 平均時間複雜度 ---- O(n^2)</p><p>// 所需輔助空間 ------ O(1)</p><p>// 穩定性 ------------ 穩定</p><p class=ql-align-justify><br></p><p>void InsertionSort(int A[], int n)</p><p>{</p><p>for (int i = 1; i &lt; n; i++) // 類似抓撲克牌排序</p><p>{</p><p>int get = A[i]; // 右手抓到一張撲克牌</p><p>int j = i - 1; // 拿在左手上的牌總是排序好的</p><p>while (j >= 0 && A[j] > get) // 將抓到的牌與手牌從右向左進行比較</p><p>{</p><p>A[j + 1] = A[j]; // 如果該手牌比抓到的牌大，就將其右移</p><p>j--;</p><p>}</p><p>A[j + 1] = get; // 直到該手牌比抓到的牌小(或二者相等)，將抓到的牌插入到該手牌右邊(相等元素的相對次序未變，所以插入排序是穩定的)</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>int main()</p><p>{</p><p>int A[] = { 6, 5, 3, 1, 8, 7, 2, 4 };// 從小到大插入排序</p><p>int n = sizeof(A) / sizeof(int);</p><p>InsertionSort(A, n);</p><p>printf("插入排序結果：");</p><p>for (int i = 0; i &lt; n; i++)</p><p>{</p><p>printf("%d ", A[i]);</p><p>}</p><p>printf("\n");</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p>上述代碼對序列{ 6, 5, 3, 1, 8, 7, 2, 4 }進行插入排序的實現過程如下</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/75a32ddb72e34f32b9a95401c40c2d3a><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>使用插入排序為一列數字進行排序的宏觀過程：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e326d515da8c4438a858fce540eb2a2d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>插入排序不適合對於數據量比較大的排序應用。</p><p>但是，如果需要排序的數據量很小，比如量級小於千，那麼插入排序還是一個不錯的選擇。</p><p>插入排序在工業級庫中也有著廣泛的應用，在STL的sort算法和stdlib的qsort算法中，都將插入排序作為快速排序的補充，用於少量元素的排序（通常為8個或以下）。</p><p class=ql-align-justify><strong>插入排序的改進：二分插入排序</strong></p><p>對於插入排序，如果比較操作的代價比交換操作大的話，可以採用<strong>二分查找法</strong>來減少比較操作的次數，我們稱為<strong>二分插入排序</strong>，代碼如下：</p><p>#include &lt;stdio.h></p><p class=ql-align-justify><br></p><p>// 分類 -------------- 內部比較排序</p><p>// 數據結構 ---------- 數組</p><p>// 最差時間複雜度 ---- O(n^2)</p><p>// 最優時間複雜度 ---- O(nlogn)</p><p>// 平均時間複雜度 ---- O(n^2)</p><p>// 所需輔助空間 ------ O(1)</p><p>// 穩定性 ------------ 穩定</p><p class=ql-align-justify><br></p><p>void InsertionSortDichotomy(int A[], int n)</p><p>{</p><p>for (int i = 1; i &lt; n; i++)</p><p>{</p><p>int get = A[i]; // 右手抓到一張撲克牌</p><p>int left = 0; // 拿在左手上的牌總是排序好的，所以可以用二分法</p><p>int right = i - 1; // 手牌左右邊界進行初始化</p><p>while (left &lt;= right) // 採用二分法定位新牌的位置</p><p>{</p><p>int mid = (left + right) / 2;</p><p>if (A[mid] > get)</p><p>right = mid - 1;</p><p>else</p><p>left = mid + 1;</p><p>}</p><p>for (int j = i - 1; j >= left; j--) // 將欲插入新牌位置右邊的牌整體向右移動一個單位</p><p>{</p><p>A[j + 1] = A[j];</p><p>}</p><p>A[left] = get; // 將抓到的牌插入手牌</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>int main()</p><p>{</p><p>int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 從小到大二分插入排序</p><p>int n = sizeof(A) / sizeof(int);</p><p>InsertionSortDichotomy(A, n);</p><p>printf("二分插入排序結果：");</p><p>for (int i = 0; i &lt; n; i++)</p><p>{</p><p>printf("%d ", A[i]);</p><p>}</p><p>printf("\n");</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p>當n較大時，二分插入排序的比較次數比直接插入排序的最差情況好得多，但比直接插入排序的最好情況要差，所當以元素初始序列已經接近升序時，直接插入排序比二分插入排序比較次數少。</p><p>二分插入排序元素移動次數與直接插入排序相同，依賴於元素初始序列。</p><p class=ql-align-justify><strong>插入排序的更高效改進：希爾排序(Shell Sort)</strong></p><p>希爾排序，也叫<strong>遞減增量排序</strong>，是插入排序的一種更高效的改進版本。希爾排序是<strong>不穩定</strong>的排序算法。</p><p>希爾排序是基於插入排序的以下兩點性質而提出改進方法的：</p><ul><li class=ql-align-justify>插入排序在對幾乎已經排好序的數據操作時，效率高，即可以達到線性排序的效率</li><li class=ql-align-justify>但插入排序一般來說是低效的，因為插入排序每次只能將數據移動一位</li></ul><p>希爾排序通過將比較的全部元素分為幾個區域來提升插入排序的性能。這樣可以讓一個元素可以一次性地朝最終位置前進一大步。</p><p>然後算法再取越來越小的步長進行排序，算法的最後一步就是普通的插入排序，但是到了這步，需排序的數據幾乎是已排好的了（此時插入排序較快）。</p><p>假設有一個很小的數據在一個已按升序排好序的數組的末端。如果用複雜度為O(n^2)的排序（冒泡排序或直接插入排序），可能會進行n次的比較和交換才能將該數據移至正確位置。</p><p>而希爾排序會用較大的步長移動數據，所以小數據只需進行少數比較和交換即可到正確位置。</p><p><strong>希爾排序的代碼如下：</strong></p><blockquote><br>#include &lt;stdio.h> // 分類 -------------- 內部比較排序// 數據結構 ---------- 數組// 最差時間複雜度 ---- 根據步長序列的不同而不同。已知最好的為O(n(logn)^2)// 最優時間複雜度 ---- O(n)// 平均時間複雜度 ---- 根據步長序列的不同而不同。// 所需輔助空間 ------ O(1)// 穩定性 ------------ 不穩定void ShellSort(int A[], int n){ int h = 0; while (h &lt;= n) // 生成初始增量 { h = 3 * h + 1; } while (h >= 1) { for (int i = h; i &lt; n; i++) { int j = i - h; int get = A[i]; while (j >= 0 && A[j] > get) { A[j + h] = A[j]; j = j - h; } A[j + h] = get; } h = (h - 1) / 3; // 遞減增量 }}int main(){ int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 };// 從小到大希爾排序 int n = sizeof(A) / sizeof(int); ShellSort(A, n); printf("希爾排序結果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p class=ql-align-justify><br></p><p>以23, 10, 4, 1的步長序列進行希爾排序：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ed4244826984b2ab6089c333d188841><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>希爾排序是不穩定的排序算法，</strong>雖然一次插入排序是穩定的，不會改變相同元素的相對順序，但在不同的插入排序過程中，相同的元素可能在各自的插入排序中移動，最後其穩定性就會被打亂</p><p>比如序列：{ 3, 5, 10, 8, 7, 2, 8, 1, 20, 6 }，h=2時分成兩個子序列 { 3, 10, 7, 8, 20 } 和 { 5, 8, 2, 1, 6 } ，未排序之前第二個子序列中的8在前面，現在對兩個子序列進行插入排序，得到 { 3, 7, 8, 10, 20 } 和 { 1, 2, 5, 6, 8 } ，即 { 3, 1, 7, 2, 8, 5, 10, 6, 20, 8 } ，兩個8的相對次序發生了改變。</p><p class=ql-align-justify><strong>歸併排序(Merge Sort)</strong></p><p>歸併排序是創建在歸併操作上的一種有效的排序算法，效率為O(nlogn)，1945年由馮·諾伊曼首次提出。</p><p>歸併排序的實現分為<strong>遞歸實現</strong>與<strong>非遞歸(迭代)實現</strong>。</p><p>遞歸實現的歸併排序是算法設計中分治策略的典型應用，我們將一個大問題分割成小問題分別解決，然後用所有小問題的答案來解決整個大問題。</p><p>非遞歸(迭代)實現的歸併排序首先進行是兩兩歸併，然後四四歸併，然後是八八歸併，一直下去直到歸併了整個數組。</p><p>歸併排序算法主要依賴歸併(Merge)操作。</p><p>歸併操作指的是將兩個已經排序的序列合併成一個序列的操作。</p><p><strong>歸併操作</strong>步驟如下：</p><ol><li class=ql-align-justify><strong>申請空間</strong>，使其大小為兩個已經排序序列之和，該空間用來存放合併後的序列</li><li class=ql-align-justify>設定兩個指針，最初位置分別為兩個已經排序序列的起始位置</li><li class=ql-align-justify>比較兩個指針所指向的元素，選擇相對小的元素放入到合併空間，並移動指針到下一位置</li><li class=ql-align-justify>重複步驟3直到某一指針到達序列尾</li><li class=ql-align-justify>將另一序列剩下的所有元素直接複製到合併序列尾</li></ol><p><strong>歸併排序的代碼如下：</strong></p><p>#include &lt;stdio.h></p><p>#include &lt;limits.h></p><p class=ql-align-justify><br></p><p>// 分類 -------------- 內部比較排序</p><p>// 數據結構 ---------- 數組</p><p>// 最差時間複雜度 ---- O(nlogn)</p><p>// 最優時間複雜度 ---- O(nlogn)</p><p>// 平均時間複雜度 ---- O(nlogn)</p><p>// 所需輔助空間 ------ O(n)</p><p>// 穩定性 ------------ 穩定</p><p class=ql-align-justify><br></p><p>void Merge(int A[], int left, int mid, int right)// 合併兩個已排好序的數組A[left...mid]和A[mid+1...right]</p><p>{</p><p>int len = right - left + 1;</p><p>int *temp = new int[len]; // 輔助空間O(n)</p><p>int index = 0;</p><p>int i = left; // 前一數組的起始元素</p><p>int j = mid + 1; // 後一數組的起始元素</p><p>while (i &lt;= mid && j &lt;= right)</p><p>{</p><p>temp[index++] = A[i] &lt;= A[j] ? A[i++] : A[j++]; // 帶等號保證歸併排序的穩定性</p><p>}</p><p>while (i &lt;= mid)</p><p>{</p><p>temp[index++] = A[i++];</p><p>}</p><p>while (j &lt;= right)</p><p>{</p><p>temp[index++] = A[j++];</p><p>}</p><p>for (int k = 0; k &lt; len; k++)</p><p>{</p><p>A[left++] = temp[k];</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>void MergeSortRecursion(int A[], int left, int right) // 遞歸實現的歸併排序(自頂向下)</p><p>{</p><p>if (left == right) // 當待排序的序列長度為1時，遞歸開始回溯，進行merge操作</p><p>return;</p><p>int mid = (left + right) / 2;</p><p>MergeSortRecursion(A, left, mid);</p><p>MergeSortRecursion(A, mid + 1, right);</p><p>Merge(A, left, mid, right);</p><p>}</p><p class=ql-align-justify><br></p><p>void MergeSortIteration(int A[], int len) // 非遞歸(迭代)實現的歸併排序(自底向上)</p><p>{</p><p>int left, mid, right;// 子數組索引,前一個為A[left...mid]，後一個子數組為A[mid+1...right]</p><p>for (int i = 1; i &lt; len; i *= 2) // 子數組的大小i初始為1，每輪翻倍</p><p>{</p><p>left = 0;</p><p>while (left + i &lt; len) // 後一個子數組存在(需要歸併)</p><p>{</p><p>mid = left + i - 1;</p><p>right = mid + i &lt; len ? mid + i : len - 1;// 後一個子數組大小可能不夠</p><p>Merge(A, left, mid, right);</p><p>left = right + 1; // 前一個子數組索引向後移動</p><p>}</p><p>}</p><p>}</p><p class=ql-align-justify><br></p><p>int main()</p><p>{</p><p>int A1[] = { 6, 5, 3, 1, 8, 7, 2, 4 }; // 從小到大歸併排序</p><p>int A2[] = { 6, 5, 3, 1, 8, 7, 2, 4 };</p><p>int n1 = sizeof(A1) / sizeof(int);</p><p>int n2 = sizeof(A2) / sizeof(int);</p><p>MergeSortRecursion(A1, 0, n1 - 1); // 遞歸實現</p><p>MergeSortIteration(A2, n2); // 非遞歸實現</p><p>printf("遞歸實現的歸併排序結果：");</p><p>for (int i = 0; i &lt; n1; i++)</p><p>{</p><p>printf("%d ", A1[i]);</p><p>}</p><p>printf("\n");</p><p>printf("非遞歸實現的歸併排序結果：");</p><p>for (int i = 0; i &lt; n2; i++)</p><p>{</p><p>printf("%d ", A2[i]);</p><p>}</p><p>printf("\n");</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p class=ql-align-justify><br></p><p>上述代碼對序列{ 6, 5, 3, 1, 8, 7, 2, 4 }進行歸併排序的實例如下</p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/73af8399de8643e1a70673f9764f66b5><p class=pgc-img-caption></p></div><p>使用歸併排序為一列數字進行排序的宏觀過程：</p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2d57d8004084d46a2718c3408ec5c64><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>歸併排序除了可以對數組進行排序，還可以高效的求出數組小和（即單調和）以及數組中的逆序對。</p><p class=ql-align-justify><strong>堆排序(Heap Sort)</strong></p><p>堆排序是指利用堆這種數據結構所設計的一種選擇排序算法。</p><p>堆是一種近似完全二叉樹的結構（通常堆是通過一維數組來實現的），並滿足性質：以最大堆（也叫大根堆、大頂堆）為例，其中父結點的值總是大於它的孩子節點。</p><p>我們可以很容易的<strong>定義堆排序的過程：</strong></p><ol><li class=ql-align-justify>由輸入的無序數組構造一個最大堆，作為初始的無序區</li><li class=ql-align-justify>把堆頂元素（最大值）和堆尾元素互換</li><li class=ql-align-justify>把堆（無序區）的尺寸縮小1，並調用heapify(A, 0)從新的堆頂元素開始進行堆調整</li><li class=ql-align-justify>重複步驟2，直到堆的尺寸為1</li></ol><p><strong>堆排序的代碼如下：</strong></p><blockquote><br>#include &lt;stdio.h>// 分類 -------------- 內部比較排序// 數據結構 ---------- 數組// 最差時間複雜度 ---- O(nlogn)// 最優時間複雜度 ---- O(nlogn)// 平均時間複雜度 ---- O(nlogn)// 所需輔助空間 ------ O(1)// 穩定性 ------------ 不穩定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}void Heapify(int A[], int i, int size) // 從A[i]向下進行堆調整{ int left_child = 2 * i + 1; // 左孩子索引 int right_child = 2 * i + 2; // 右孩子索引 int max = i; // 選出當前結點與其左右孩子三者之中的最大值 if (left_child &lt; size && A[left_child] > A[max]) max = left_child; if (right_child &lt; size && A[right_child] > A[max]) max = right_child; if (max != i) { Swap(A, i, max); // 把當前結點和它的最大(直接)子節點進行交換 Heapify(A, max, size); // 遞歸調用，繼續從當前結點向下進行堆調整 }}</blockquote><p>堆排序算法的演示：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5efff4a72bec48b08b2f56f7150e0c54><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>動畫中在排序過程之前簡單的表現了創建堆的過程以及堆的邏輯結構。</p><p><strong>堆排序是不穩定的排序算法，不穩定發生在堆頂元素與A[i]交換的時刻。</strong></p><p>比如序列：{ 9, 5, 7, 5 }，堆頂元素是9，堆排序下一步將9和第二個5進行交換，得到序列 { 5, 5, 7, 9 }，再進行堆調整得到{ 7, 5, 5, 9 }，重複之前的操作最後得到{ 5, 5, 7, 9 }從而改變了兩個5的相對次序。</p><p class=ql-align-justify><strong>快速排序(Quick Sort)</strong></p><p>快速排序是由東尼·霍爾所發展的一種排序算法。在平均狀況下，排序n個元素要O(nlogn)次比較。</p><p>在最壞狀況下則需要O(n^2)次比較，但這種狀況並不常見。</p><p>事實上，快速排序通常明顯比其他O(nlogn)算法更快，因為它的內部循環可以在大部分的架構上很有效率地被實現出來。</p><p>快速排序使用分治策略(Divide and Conquer)來把一個序列分為兩個子序列。步驟為：</p><ol><li class=ql-align-justify>從序列中挑出一個元素，作為”基準”(pivot).</li><li class=ql-align-justify>把所有比基準值小的元素放在基準前面，所有比基準值大的元素放在基準的後面（相同的數可以到任一邊），這個稱為分區(partition)操作。</li><li class=ql-align-justify>對每個分區遞歸地進行步驟1~2，遞歸的結束條件是序列的大小是0或1，這時整體已經被排好序了。</li></ol><p><strong>快速排序的代碼如下：</strong></p><blockquote><br>#include &lt;stdio.h>// 分類 ------------ 內部比較排序// 數據結構 --------- 數組// 最差時間複雜度 ---- 每次選取的基準都是最大（或最小）的元素，導致每次只劃分出了一個分區，需要進行n-1次劃分才能結束遞歸，時間複雜度為O(n^2)// 最優時間複雜度 ---- 每次選取的基準都是中位數，這樣每次都均勻的劃分出兩個分區，只需要logn次劃分就能結束遞歸，時間複雜度為O(nlogn)// 平均時間複雜度 ---- O(nlogn)// 所需輔助空間 ------ 主要是遞歸造成的棧空間的使用(用來保存left和right等局部變量)，取決於遞歸樹的深度，一般為O(logn)，最差為O(n) // 穩定性 ---------- 不穩定void Swap(int A[], int i, int j){ int temp = A[i]; A[i] = A[j]; A[j] = temp;}int Partition(int A[], int left, int right) // 劃分函數{ int pivot = A[right]; // 這裡每次都選擇最後一個元素作為基準 int tail = left - 1; // tail為小於基準的子數組最後一個元素的索引 for (int i = left; i &lt; right; i++) // 遍歷基準以外的其他元素 { if (A[i] &lt;= pivot) // 把小於等於基準的元素放到前一個子數組末尾 { Swap(A, ++tail, i); } } Swap(A, tail + 1, right); // 最後把基準放到前一個子數組的後邊，剩下的子數組既是大於基準的子數組 // 該操作很有可能把後面元素的穩定性打亂，所以快速排序是不穩定的排序算法 return tail + 1; // 返回基準的索引}void QuickSort(int A[], int left, int right){ if (left >= right) return; int pivot_index = Partition(A, left, right); // 基準的索引 QuickSort(A, left, pivot_index - 1); QuickSort(A, pivot_index + 1, right);}int main(){ int A[] = { 5, 2, 9, 4, 7, 6, 1, 3, 8 }; // 從小到大快速排序 int n = sizeof(A) / sizeof(int); QuickSort(A, 0, n - 1); printf("快速排序結果："); for (int i = 0; i &lt; n; i++) { printf("%d ", A[i]); } printf("\n"); return 0;}</blockquote><p>使用快速排序法對一列數字進行排序的過程：</p><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「乾貨」常用排序算法總結，必收藏系列 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bbffa9936df9481e921301d5b2edd592><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>快速排序是不穩定的排序算法，不穩定發生在基準元素與A[tail+1]交換的時刻。</strong></p><p>比如序列：{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基準元素是5，一次劃分操作後5要和第一個8進行交換，從而改變了兩個元素8的相對次序。</p><blockquote>Java系統提供的Arrays.sort函數。對於基礎類型，底層使用快速排序。對於非基礎類型，底層使用歸併排序。請問是為什麼？</blockquote><p>答：這是考慮到排序算法的穩定性。</p><p>對於基礎類型，相同值是無差別的，排序前後相同值的相對位置並不重要，所以選擇更為高效的快速排序，儘管它是不穩定的排序算法；</p><p>而對於非基礎類型，排序前後相等實例的相對位置不宜改變，所以選擇穩定的歸併排序。</p><p>需要更多學習筆記乾貨的小夥伴、歡迎關注公眾號<strong>【老九學堂】</strong>（づ￣3￣）づ╭❤～</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>乾貨</a></li><li><a>總結</a></li><li><a>排序</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d481e650.html alt="乾貨 | CAD製圖大神總結的經驗大全-上" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/65c9607007754f5782780ad38f226354 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d481e650.html title="乾貨 | CAD製圖大神總結的經驗大全-上">乾貨 | CAD製圖大神總結的經驗大全-上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5d0a0be.html alt=五種常用且高效的排序算法性能總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534143270780b452d84457 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5d0a0be.html title=五種常用且高效的排序算法性能總結>五種常用且高效的排序算法性能總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a881f62.html alt=乾貨分享——牛人總結模具真空熱處理技術參數、工藝、案例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b0e13139727c4703adb19dbb3b61c14a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a881f62.html title=乾貨分享——牛人總結模具真空熱處理技術參數、工藝、案例>乾貨分享——牛人總結模具真空熱處理技術參數、工藝、案例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8af78e1.html alt="乾貨 | CAD製圖大神總結的經驗大全" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/939000b5e1b04dba9ba313da74cdd89e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8af78e1.html title="乾貨 | CAD製圖大神總結的經驗大全">乾貨 | CAD製圖大神總結的經驗大全</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/35e4f07.html alt="乾貨 | 消防水池設置要求總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/5c8712e0-b34e-40ae-aa60-205bed5821e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/35e4f07.html title="乾貨 | 消防水池設置要求總結">乾貨 | 消防水池設置要求總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html alt=從域名到網站，只需要四步！服務器網站搭建流程總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7c1999b5072844f6ac01ba234e4d4ee0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html title=從域名到網站，只需要四步！服務器網站搭建流程總結>從域名到網站，只需要四步！服務器網站搭建流程總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efdb7210.html alt=乾貨丨光纖跳線類型、尾纖類型（附PPT全文） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cb29513613c245eb85b248ac90e3b149 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efdb7210.html title=乾貨丨光纖跳線類型、尾纖類型（附PPT全文）>乾貨丨光纖跳線類型、尾纖類型（附PPT全文）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b0e60e.html alt=乾貨|西大學長教你玩轉計算機07——圖像導數實戰 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/74830a84f854431294e917cf61f29fb7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b0e60e.html title=乾貨|西大學長教你玩轉計算機07——圖像導數實戰>乾貨|西大學長教你玩轉計算機07——圖像導數實戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02402c9e.html alt=「乾貨」藍牙耳機編碼（SBC、AAC、aptX）都有啥區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/feb0ab00-bb82-4c38-9e77-e3570f56137d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02402c9e.html title=「乾貨」藍牙耳機編碼（SBC、AAC、aptX）都有啥區別？>「乾貨」藍牙耳機編碼（SBC、AAC、aptX）都有啥區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce442e1f.html alt=【購房乾貨】層高和淨高的區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ba8f2c776647469baae689a0da1b401d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce442e1f.html title=【購房乾貨】層高和淨高的區別？>【購房乾貨】層高和淨高的區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html alt=住宅工程各區域的淨高要求，總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/072079da-ec32-43b6-9dff-93cc7beb2bc3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html title=住宅工程各區域的淨高要求，總結>住宅工程各區域的淨高要求，總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html alt=住宅工程各區域的淨高要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/27a44170db2040adab26236e40605b1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html title=住宅工程各區域的淨高要求，總結！>住宅工程各區域的淨高要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d98984a.html alt=重磅乾貨！柯春曉談“世界一流企業的創新生態與知識創新服務業” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2211f4f2f5c349ffa46e9937b47c9f39 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d98984a.html title=重磅乾貨！柯春曉談“世界一流企業的創新生態與知識創新服務業”>重磅乾貨！柯春曉談“世界一流企業的創新生態與知識創新服務業”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac4494ba.html alt=乾貨｜機械行業面試題大整合，興許哪天就用上了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4f9b97c36b5848f4af9c56ac14d665cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac4494ba.html title=乾貨｜機械行業面試題大整合，興許哪天就用上了>乾貨｜機械行業面試題大整合，興許哪天就用上了</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>