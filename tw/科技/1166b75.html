<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>異步代碼的進化之路：回調，Promise，async/await | 极客快訊</title><meta property="og:title" content="異步代碼的進化之路：回調，Promise，async/await - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/470800027f460ef29831"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1166b75.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1166b75.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1166b75.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="異步代碼的進化之路：回調，Promise，async/await"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1166b75.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>異步代碼的進化之路：回調，Promise，async/await</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>書接上篇。我們已經介紹了事件循環和Job Queue的機制，現在分享的是原文的後半部分——異步代碼的發展歷程，並比較三種異步模式的優缺點，希望大家看完能夠收穫新知識～</p><p><img alt=異步代碼的進化之路：回調，Promise，async/await onerror=errorimg.call(this); src=https://p3.pstatp.com/large/470800027f460ef29831></p><p>（圖片來自網絡）</p><p><strong>回調</strong></p><p>你已經知道，回調是目前為止在JavaScript程序中表達和管理異步的最常用的方式。實際上，回調是JavaScript語言中最基本的異步模式。無數的JS程序，甚至是非常複雜的程序，都是基於回調編寫的，除了回調並沒有用到其他的異步基礎。</p><p>不過回調並不完美。許多開發人員都在嘗試尋找更好的異步模式。但是，如果你不理解底層的實際情況，就不可能有效地使用任何抽象。</p><p>在接下來的章節中，我們將深入探討這些抽象概念，以說明為什麼更復雜的異步模式(將在後續文章中討論)是必要的，甚至是推薦的。</p><p>嵌套回調</p><p>看看下面這段代碼</p><blockquote><pre>listen('click', function (e){ setTimeout(function(){ ajax('https://api.example.com/endpoint', function (text){ if (text == "hello") { doSomething(); } else if (text == "world") { doSomethingElse(); } }); }, 500);});</pre></blockquote><p>我們已經將三個函數的嵌套成了一條鏈，每一環都表示異步序列中的一個步驟。</p><p>這種代碼通常被稱為“回調地獄”。但是“回調地獄”實際上與縮進/縮進幾乎沒有任何關係。這是一個更深層次的問題。</p><p>首先，我們在等待“click”事件，然後等待計時器觸發，然後等待Ajax響應返回，此時可能會再次出現。</p><p>乍一看，這段代碼似乎可以自然地將它的異步映射為連續的步驟:</p><blockquote><pre>listen('click', function (e) { // ..});</pre></blockquote><p>然後我們有:</p><blockquote><pre>setTimeout(function(){ // ..}, 500);</pre></blockquote><p>然後我們有:</p><blockquote><pre>ajax('https://api.example.com/endpoint', function (text){ // ..});</pre></blockquote><p>最後：</p><blockquote><pre>if (text == "hello") { doSomething();}else if (text == "world") { doSomethingElse();}</pre></blockquote><p>因此，這樣一種順序的方式來表達您的異步代碼似乎更自然，不是嗎？一定有這樣的方法，對吧？</p><p>Promise</p><p>看看下面這段代碼:</p><blockquote><pre>var x = 1;var y = 2;console.log(x + y);</pre></blockquote><p>這段代碼非常簡單：它對x和y的值進行求和，並將其打印到控制檯。但是，如果x或y的值缺失了，還有待確定呢？比如，我們需要從服務器檢索x和y的值，然後才能在表達式中使用它們。假設我們有一個函數loadX和loadY ，分別從服務器加載x和y的值。然後，想象一下，我們有一個函數sum，一旦它們都被加載了，它就將x和y的值相加。 它可能是這樣的(很難看，不是嗎)</p><blockquote><pre>function sum(getX, getY, callback) { var x, y; getX(function(result) { x = result; if (y !== undefined) { callback(x + y); } }); getY(function(result) { y = result; if (x !== undefined) { callback(x + y); } });}// A sync or async function that retrieves the value of `x`function fetchX() { // ..}// A sync or async function that retrieves the value of `y`function fetchY() { // ..}sum(fetchX, fetchY, function(result) { console.log(result);});</pre></blockquote><p>這裡有一些非常重要的東西——在這個片段中，我們將x和y作為<strong>未來</strong>的值，並表示了一個操作sum(…)(從外部看)，它並不關心x和y當前可不可用。</p><p>當然，這種粗糙的基於調用的方法還有很多值得期待的。這只是邁向理解未來值的好處的第一步，而不用擔心時間的問題。</p><p>Promise 值</p><p>讓我們簡要地看看我們如何用Promise來表達x+y的例子:</p><blockquote><pre>function sum(xPromise, yPromise) { // `Promise.all([ .. ])` takes an array of promises, // and returns a new promise that waits on them // all to finish return Promise.all([xPromise, yPromise]) // when that promise is resolved, let's take the // received `X` and `Y` values and add them together. .then(function(values){ // `values` is an array of the messages from the // previously resolved promises return values[0] + values[1]; } );}// `fetchX()` and `fetchY()` return promises for// their respective values, which may be ready// *now* or *later*.sum(fetchX(), fetchY())// we get a promise back for the sum of those// two numbers.// now we chain-call `then(...)` to wait for the// resolution of that returned promise..then(function(sum){ console.log(sum);});</pre></blockquote><p>在這段代碼中有兩層Promise。</p><p>fetchX()和fetchY()被直接調用，它們返回的值(Promise！)被傳遞給sum(...)。這些Promise所代表的潛在值可能在現在或者將來準備好，但是無論如何，每個Promise都將其行為規範化為相同的。我們以一種獨立於時間的方式來解釋x和y的值。它們在一段時間內，是未來值。</p><p>第二層是sum(...) 創建(通過Promise.all([ ... ]))和返回的promise，我們通過調用 then(...)來等待它完成。當sum(...)操作完成，我們的未來值，即求和結果已經準備好了，我們可以打印出來。我們隱藏了在sum(...) 中等待x和y 未來值的邏輯。</p><p><strong>注意</strong>：在sum(…)內部，Promise.all([ … ])調用創建了一個promise（它等待promiseX和promiseY 完成），鏈式調用.then(...)來創建另一個promise，返回的values[0]+ values[1]會立即決議（返回相加的結果）。因此，我們在sum(...)調用後加上的then(...)——在代碼段的最後——實際上是在第二個promise的返回後執行，而不是第一個創建的Promise.all([ ... ])。還有，雖然我們還沒有在第二個then(...)後面繼續添加then，它也創造了另一個promise，我們可以選擇觀察/使用它。本章後面的內容將在後面詳細解釋。 使用Promise，then(...) 的調用實際上可以有兩個方法，第一個是完成(如上所示)，第二個是拒絕:</p><blockquote><pre>sum(fetchX(), fetchY()).then( // fullfillment handler function(sum) { console.log( sum ); }, // rejection handler function(err) { console.error( err ); // bummer! });</pre></blockquote><p>如果在得到x或y的時候出現了問題，或者在添加的過程中出現了一些失敗，那麼可以sum(…)返回的promise將被拒絕，傳遞給then(...)的第二個回調錯誤處理程序，它將收到來自promise拒絕的值。 因為Promises 封裝了依賴於時間的狀態——等待內在值的實現或拒絕——從外部來看，Promises 本身是時間獨立的，因此可以以可預測的方式組合，而不考慮底層的時間和結果。</p><p>而且，一旦一個Promise得到決議，它就會永遠保持這種狀態——在那個時候它就變成了一個不可改變的值——然後就可以在必要的時候多次被觀察。</p><p>實際上你可以鏈式Promise非常有用：</p><blockquote><pre>function delay(time) { return new Promise(function(resolve, reject){ setTimeout(resolve, time); });}delay(1000).then(function(){ console.log("after 1000ms"); return delay(2000);}).then(function(){ console.log("after another 2000ms");}).then(function(){ console.log("step 4 (next Job)"); return delay(5000);})// ...</pre></blockquote><p>調用delay(2000)創造一個在2000ms完成的Promise，然後我們從第一個then(…)完成回調中返回，導致第二個then(...)的promise再等待2000ms執行。</p><p><strong>注意</strong>： 因為Promise 一旦決議，從外部就不可改變了，所以現在可以安全地將這個值傳遞給任何一方，因為它知道它不能被意外或惡意地修改。對於觀察該promise的多方來說，這一點尤其正確。任意一方不可能影響另一方觀察到的決議結果。不變性可能聽起來像是一個學術話題，但它實際上是Promise 設計最基本和最重要的方面之一，不應該被隨意地忽略。</p><p>如何辨別<strong>Promise</strong>？</p><p>關於Promises的一個重要細節是確定是否某些值是真正的Promise。換句話說，它的值會像一個Promise嗎?</p><p>我們知道Promises是由new Promise(…)語法構造的，你可能會認為 p instanceof Promise 是一個充分的檢查。好吧，不完全是。</p><p>主要是因為你可以從另一個瀏覽器窗口(例如iframe)獲得一個 Promise的值，它有自己獨立的Promise類，不同於當前窗口或框架中的一個，因此該檢查將無法識別Promise實例。</p><p>而且，一個庫或框架可以選擇發佈它自己的Promise，而不是使用ES6原生的Promise實現。事實上，你很可能會在沒有任何Promise的老式瀏覽器中使用第三方的 Promise。</p><p>吞掉異常</p><p>如果在創建Promise的任何時候，或者在對其決議的觀察中，拋出了一個JavaScript異常錯誤，比如“TypeError”或“ReferenceError”，那麼這個異常就會被捕獲，它將迫使這個Promise被拒絕。</p><p>例如:</p><blockquote><pre>var p = new Promise(function(resolve, reject){ foo.bar(); // `foo` is not defined, so error! resolve(374); // never gets here :(});p.then( function fulfilled(){ // never gets here :( }, function rejected(err){ // `err` will be a `TypeError` exception object // from the `foo.bar()` line. });</pre></blockquote><p>但是如果一個Promise完成了，卻在觀察結果時(在 then(…) 註冊回調)發生了JS異常會怎樣呢？即使這個錯誤不會被丟失，你可能會對它們處理的方式感到驚訝。除非你進一步挖掘：</p><blockquote><pre>var p = new Promise( function(resolve,reject){ resolve(374);});p.then(function fulfilled(message){ foo.bar(); console.log(message); // never reached}, function rejected(err){ // never reached });</pre></blockquote><p>它看起來像“foo . bar()”真的是被吞沒了。其實並不是。不過，一些更深層次的問題出現了，我們沒能監聽到。“p.then(…)調用本身會返回另一個promise，而這個promise將會被TypeError異常所拒絕。</p><p><strong>處理未捕獲異常</strong></p><p>還有其他“更好”的方法。 常見的一個建議是應該給Promise增加一個done(…)，用於標誌Promise鏈的結束。done(…)不會創建並返回一個Promise，所以傳遞到done(…)的回調顯然不會把問題報告給一個不存在的鏈式Promise。 在未捕獲錯誤的情況下，會按照你期望的方式處理:在done(..)中的拒絕處理函數中如果有任何異常，該異常將被拋出為一個全局未捕獲的錯誤（通常在開發人員控制檯能看到）：</p><blockquote><pre>var p = Promise.resolve(374);p.then(function fulfilled(msg){ // numbers don't have string functions, // so will throw an error console.log(msg.toLowerCase());}).done(null, function() { // If an exception is caused here, it will be thrown globally});</pre></blockquote><p><strong>在ES8裡 Async/await會發生什麼</strong></p><p>JavaScript ES8引入了async/await，使得Promise更容易使用。我們將簡要介紹async/await提供的可能性，以及如何利用它們來編寫異步代碼。 因此，讓我們看看async/await如何工作。</p><p>使用async函數聲明來定義一個異步函數。這樣的函數返回一個AsyncFunction對象，AsyncFunction對象代表了執行代碼的異步函數，AsyncFunction包含在該函數中。 當調用async函數時，它返回一個Promise 。當async函數返回一個值時，這不是一個Promise 。而是會自動創建一個Promise ，它將使用函數的返回值來決議。當async 函數拋出異常時，Promise 將使用拋出的值來拒絕。 一個async 函數可以包含一個await表達式，該表達式暫停執行該函數，並等待傳遞給它的Promise被決議，然後恢復async函數的執行並返回決議值。 你可以把JavaScript的Promise看作是Java的Future或c#的任務。</p><blockquote><p>async/await 的目的是簡化使用Promise的行為。 讓我們看一下下面的例子:</p></blockquote><blockquote><pre>// Just a standard JavaScript functionfunction getNumber1() { return Promise.resolve('374');}// This function does the same as getNumber1async function getNumber2() { return 374;}</pre></blockquote><p>同樣，拋出異常的函數等價於返回已被拒絕的promise的函數:</p><blockquote><pre>function f1() { return Promise.reject('Some error');}async function f2() { throw 'Some error';}</pre></blockquote><p>await關鍵字只能在async 函數中使用，並允許您同步等待一個Promise。如果我們在async 函數之外使用Promise，我們仍然需要使用then回調：</p><blockquote><pre>async function loadData() { // `rp` is a request-promise function. var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // Currently, both requests are fired, concurrently and // now we'll have to wait for them to finish var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;}// Since, we're not in an `async function` anymore// we have to use `then`.loadData().then(() =&gt; console.log('Done'));</pre></blockquote><p>你還可以使用“async函數表達式”來定義async函數。一個async函數表達式非常類似，它的語法和async函數聲明差不多。async函數表達式和async函數聲明之間的主要區別是函數名，它可以在async函數表達式中省略，以創建匿名函數。一個async函數表達式可以作為一個IIFE(立即執行函數表達式)來使用，當IIFE被定義完就會運行。 它看起來像這樣：</p><blockquote><pre>var loadData = async function() { // `rp` is a request-promise function. var promise1 = rp('https://api.example.com/endpoint1'); var promise2 = rp('https://api.example.com/endpoint2'); // Currently, both requests are fired, concurrently and // now we'll have to wait for them to finish var response1 = await promise1; var response2 = await promise2; return response1 + ' ' + response2;}</pre></blockquote><p>更重要的是，在所有主流瀏覽器中都支持async/await:</p><p>如果這個兼容性不是你想要的，那麼也有幾個JS的轉換器，比如Babel和TypeScript</p><p>在一天結束的時候，重要的是不要盲目地選擇“最新”的方法來編寫異步代碼。理解異步JavaScript的內部原理是很重要的，瞭解它為什麼如此重要，並深入理解您選擇的方法的內部原理。每種方法都有利有弊。</p><p>編寫高度可維護的、健壯的異步代碼的5個技巧</p><p>1. <strong>乾淨的代碼:</strong> 使用async/await允許您編寫更少的代碼。每次使用async/await你能跳過一些不必要的步驟：寫.then，創建一個匿名函數來處理響應，在該回調中命名響應變量，比如：</p><blockquote><pre>// `rp` is a request-promise function.rp(‘https://api.example.com/endpoint1').then(function(data) { // …});</pre></blockquote><p>對比：</p><blockquote><pre>// `rp` is a request-promise function.var response = await rp(‘https://api.example.com/endpoint1');</pre></blockquote><p>2. <strong>錯誤處理:</strong> Async/await 使得可以使用相同的代碼結構來處理同步和異步錯誤—著名的try / catch聲明。讓我們看看用Promise如何實現：</p><blockquote><pre>function loadData() { try { // Catches synchronous errors. getJSON().then(function(response) { var parsed = JSON.parse(response); console.log(parsed); }).catch(function(e) { // Catches asynchronous errors console.log(e); }); } catch(e) { console.log(e); }}</pre></blockquote><p>對比：</p><blockquote><pre>async function loadData() { try { var data = JSON.parse(await getJSON()); console.log(data); } catch(e) { console.log(e); }}</pre></blockquote><p>3. <strong>條件語句：</strong>用async/await編寫條件代碼要簡單得多：</p><blockquote><pre>function loadData() { return getJSON() .then(function(response) { if (response.needsAnotherRequest) { return makeAnotherRequest(response) .then(function(anotherResponse) { console.log(anotherResponse) return anotherResponse }) } else { console.log(response) return response } })}</pre></blockquote><p>對比:</p><blockquote><pre>async function loadData() { var response = await getJSON(); if (response.needsAnotherRequest) { var anotherResponse = await makeAnotherRequest(response); console.log(anotherResponse) return anotherResponse } else { console.log(response); return response; }}</pre></blockquote><p>4. <strong>堆棧幀：</strong>與async/await不同的是，從一個Promise鏈返回的錯誤堆棧沒有給出錯誤發生的位置。如下:</p><blockquote><pre>function loadData() { return callAPromise() .then(callback1) .then(callback2) .then(callback3) .then(() =&gt; { throw new Error("boom"); })}loadData() .catch(function(e) { console.log(err);// Error: boom at callAPromise.then.then.then.then (index.js:8:13)});</pre></blockquote><p>對比:</p><blockquote><pre>async function loadData() { await callAPromise1() await callAPromise2() await callAPromise3() await callAPromise4() await callAPromise5() throw new Error("boom");}loadData() .catch(function(e) { console.log(err); // output // Error: boom at loadData (index.js:7:9)});</pre></blockquote><p>5. <strong>調試：</strong> 如果你使用了Promise，你知道調試它們是一場噩夢。例如，如果在一個.then中設置了斷點。然後，阻塞並使用諸如 “stop-over”之類的調試快捷方式，調試器將不會移動到下一個.then，因為它僅對同步代碼提供該功能。通過async/await，您可以逐步調試await調用，就像它們是正常的同步函數一樣。 不僅對於應用程序本身，對於那些<strong>庫</strong>來說，寫<strong>異步的JavaScript代碼也很重要</strong>。</p><p>例如, SessionStack庫記錄Web應用程序／網站中的所有內容：所有DOM更改、用戶交互、JavaScript異常、堆棧跟蹤、失敗的網絡請求和調試消息。 這一切都必須發生在你的生產環境中，而不影響任何用戶體驗。我們需要對代碼進行大量優化，並儘可能使其異步，這樣我們就可以增加被事件循環處理的事件的數量。 而且不僅是庫！當您在SessionStack中重播一個用戶會話時，我們必須在問題發生時在您的用戶的瀏覽器中呈現所有發生的事情，我們必須重現整個狀態，允許您在會話時間軸上來回跳轉。為了使這成為可能，我們大量使用了JavaScript提供的異步功能。</p><p>有一個免費的計劃可以讓你開始免費使用。</p><p><img alt=異步代碼的進化之路：回調，Promise，async/await onerror=errorimg.call(this); src=https://p3.pstatp.com/large/470800027f4508cb6e3d></p><p>免責聲明：轉載自網絡 不用於商業宣傳 版權歸原作者所有 侵權刪</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>異步</a></li><li><a>代碼</a></li><li><a>進化</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/1a697cad.html alt=視覺享受的進化!顯示技術的分類和演進 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1a697cad.html title=視覺享受的進化!顯示技術的分類和演進>視覺享受的進化!顯示技術的分類和演進</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9ad6a3e.html alt=（1-2我們的第一段PHP代碼）php基礎php學習基礎實例代碼操作教程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b707f4e4acce41bda439262a966603f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9ad6a3e.html title=（1-2我們的第一段PHP代碼）php基礎php學習基礎實例代碼操作教程>（1-2我們的第一段PHP代碼）php基礎php學習基礎實例代碼操作教程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html alt=三相異步電動機絕緣處理的目的及方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c439a15bdf64f1f975914c96a2c66e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9db061d.html title=三相異步電動機絕緣處理的目的及方法>三相異步電動機絕緣處理的目的及方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html alt=異步電機典型結構簡述 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349080656472f5dd62512 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b44410f0.html title=異步電機典型結構簡述>異步電機典型結構簡述</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html alt=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/56930005e593537411b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c2cb8d92.html title=繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹>繞組5大基本名詞解析與三相異步電動機繞組及其聯接方法介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html alt=單相異步電機如何轉起來？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/66c6000099c8d7f13f98 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3e098cc.html title=單相異步電機如何轉起來？>單相異步電機如何轉起來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html alt="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d3d5fd4ef98c4a8e8dc9095eeef052a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/389d4437.html title="Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結">Python常用算法學習(5) 樹二叉樹（原理+代碼）-最全總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4e78a26.html alt=二叉樹的算法代碼，一篇文章全搞定！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4e78a26.html title=二叉樹的算法代碼，一篇文章全搞定！>二叉樹的算法代碼，一篇文章全搞定！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51fefa66.html alt=迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/28ca13300b9f4d55bd5af3f9156f8874 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51fefa66.html title=迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章>迄今為止把同步/異步/阻塞/非阻塞講的這麼清楚的好文章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/873415c9.html alt=錯誤代碼大全2，時刻掌握計算機的故障原因！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/152937668211718b8850640 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/873415c9.html title=錯誤代碼大全2，時刻掌握計算機的故障原因！>錯誤代碼大全2，時刻掌握計算機的故障原因！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45c8b4b0.html alt=關於“神祕代碼”的含義 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c040bb33daee4d30bc48cb70d5bf8ee1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45c8b4b0.html title=關於“神祕代碼”的含義>關於“神祕代碼”的含義</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d4cfc67.html alt=VBA代碼自動讓一個空閒工作薄關閉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49f19f02a01b4aa28fab830611f1ae2d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d4cfc67.html title=VBA代碼自動讓一個空閒工作薄關閉>VBA代碼自動讓一個空閒工作薄關閉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/55fe58a0.html alt=對不起，我的VBA代碼將暫停運行，並於10秒後自動關閉主程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84e4fd546fe349bebfed630910a1b643 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/55fe58a0.html title=對不起，我的VBA代碼將暫停運行，並於10秒後自動關閉主程序>對不起，我的VBA代碼將暫停運行，並於10秒後自動關閉主程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d606318b.html alt=愛回收開啟“進化2.0”：自助回收機鋪到你家樓下便利店 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/905500045498e3e14e3e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d606318b.html title=愛回收開啟“進化2.0”：自助回收機鋪到你家樓下便利店>愛回收開啟“進化2.0”：自助回收機鋪到你家樓下便利店</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/743b42cf.html alt="自助回收+國際佈局 愛回收“進化2.0”" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/905800033283d99c9835 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/743b42cf.html title="自助回收+國際佈局 愛回收“進化2.0”">自助回收+國際佈局 愛回收“進化2.0”</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>