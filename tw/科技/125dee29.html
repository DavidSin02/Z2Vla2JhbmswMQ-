<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>SQL Server中的事務與鎖 | 极客快訊</title><meta property="og:title" content="SQL Server中的事務與鎖 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/125dee29.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/125dee29.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/125dee29.html><meta property="article:published_time" content="2020-11-14T21:08:12+08:00"><meta property="article:modified_time" content="2020-11-14T21:08:12+08:00"><meta name=Keywords content><meta name=description content="SQL Server中的事務與鎖"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/125dee29.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>SQL Server中的事務與鎖</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>瞭解事務和鎖</strong></h1><p>事務：保持邏輯數據一致性與可恢復性，必不可少的利器。</p><p>鎖：多用戶訪問同一數據庫資源時，對訪問的先後次序權限管理的一種機制，沒有他事務或許將會一塌糊塗，不能保證數據的安全正確讀寫。</p><p>死鎖：是數據庫性能的重量級殺手之一，而死鎖卻是不同事務之間搶佔數據資源造成的。</p><p>不懂的聽上去，挺神奇的，懂的感覺我在扯淡，下面帶你好好領略下他們的風采，嗅査下他們的狂騷。。</p><h1><strong>先說事務--概念，分類</strong></h1><p>用華仔無間道中的一句來給你詮釋下：去不了終點，回到原點。</p><p>舉例說明：</p><p>在一個事務中，你寫啦2條sql語句，一條是修改訂單表狀態,一條是修改庫存表庫存-1 。 如果在修改訂單表狀態的時候出錯，事務能夠回滾，數據將恢復到沒修改之前的數據狀態，下面的修改庫存也就不執行，這樣確保你關係邏輯的一致，安全。。</p><p>事務就是這個樣子，倔脾氣，要麼全部執行，要麼全部不執行，回到原數據狀態。</p><p>書面解釋：事務具有原子性，一致性，隔離性，持久性。</p><ul><li>原子性：事務必須是一個自動工作的單元，要麼全部執行，要麼全部不執行。</li><li>一致性：事務結束的時候，所有的內部數據都是正確的。</li><li>隔離性：併發多個事務時，各個事務不干涉內部數據，處理的都是另外一個事務處理之前或之後的數據。</li><li>持久性：事務提交之後，數據是永久性的，不可再回滾。</li></ul><p>然而在SQL Server中事務被分為3類常見的事務：</p><ul><li>自動提交事務：是SQL Server默認的一種事務模式，每條Sql語句都被看成一個事務進行處理，你應該沒有見過，一條Update 修改2個字段的語句，只修該了1個字段而另外一個字段沒有修改。。</li><li>顯式事務：T-sql標明，由Begin Transaction開啟事務開始，由Commit Transaction 提交事務、Rollback Transaction 回滾事務結束。</li><li>隱式事務：使用Set IMPLICIT_TRANSACTIONS ON 將將隱式事務模式打開，不用Begin Transaction開啟事務，當一個事務結束，這個模式會自動啟用下一個事務，只用Commit Transaction 提交事務、Rollback Transaction 回滾事務即可。</li></ul><h1><strong>顯式事務的應用</strong></h1><p>常用語句就四個。</p><ul><li>Begin Transaction：標記事務開始。</li><li>Commit Transaction：事務已經成功執行，數據已經處理妥當。</li><li>Rollback Transaction：數據處理過程中出錯，回滾到沒有處理之前的數據狀態，或回滾到事務內部的保存點。</li><li>Save Transaction：事務內部設置的保存點，就是事務可以不全部回滾，只回滾到這裡，保證事務內部不出錯的前提下。</li></ul><p>上面的都是心法，下面的給你來個招式，要看仔細啦。</p><p>---開啟事務</p><p>begin tran</p><p>--錯誤撲捉機制，看好啦，這裡也有的。並且可以嵌套。</p><p>begin try</p><p>--語句正確</p><p>insert into lives (Eat,Play,Numb) values ('豬肉','足球',1)</p><p>--Numb為int類型，出錯</p><p>insert into lives (Eat,Play,Numb) values ('豬肉','足球','abc')</p><p>--語句正確</p><p>insert into lives (Eat,Play,Numb) values ('狗肉','籃球',2)</p><p>end try</p><p>begin catch</p><p>select Error_number() as ErrorNumber, --錯誤代碼</p><p>Error_severity() as ErrorSeverity, --錯誤嚴重級別，級別小於10 try catch 捕獲不到</p><p>Error_state() as ErrorState , --錯誤狀態碼</p><p>Error_Procedure() as ErrorProcedure , --出現錯誤的存儲過程或觸發器的名稱。</p><p>Error_line() as ErrorLine, --發生錯誤的行號</p><p>Error_message() as ErrorMessage --錯誤的具體信息</p><p>if(@@trancount>0) --全局變量@@trancount，事務開啟此值+1，他用來判斷是有開啟事務</p><p>rollback tran ---由於出錯，這裡回滾到開始，第一條語句也沒有插入成功。</p><p>end catch</p><p>if(@@trancount>0)</p><p>commit tran --如果成功Lives表中，將會有3條數據。</p><p>--表本身為空表，ID ,Numb為int 類型，其它為nvarchar類型</p><p>select * from lives</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1533794121802a9afbb22f9><p class=pgc-img-caption></p></div><p>---開啟事務</p><p>begin tran</p><p>--錯誤撲捉機制，看好啦，這裡也有的。並且可以嵌套。</p><p>begin try</p><p>--語句正確</p><p>insert into lives (Eat,Play,Numb) values ('豬肉','足球',1)</p><p>--加入保存點</p><p>save tran pigOneIn</p><p>--Numb為int類型，出錯</p><p>insert into lives (Eat,Play,Numb) values ('豬肉','足球',2)</p><p>--語句正確</p><p>insert into lives (Eat,Play,Numb) values ('狗肉','籃球',3)</p><p>end try</p><p>begin catch</p><p>select Error_number() as ErrorNumber, --錯誤代碼</p><p>Error_severity() as ErrorSeverity, --錯誤嚴重級別，級別小於10 try catch 捕獲不到</p><p>Error_state() as ErrorState , --錯誤狀態碼</p><p>Error_Procedure() as ErrorProcedure , --出現錯誤的存儲過程或觸發器的名稱。</p><p>Error_line() as ErrorLine, --發生錯誤的行號</p><p>Error_message() as ErrorMessage --錯誤的具體信息</p><p>if(@@trancount>0) --全局變量@@trancount，事務開啟此值+1，他用來判斷是有開啟事務</p><p>rollback tran ---由於出錯，這裡回滾事務到原點，第一條語句也沒有插入成功。</p><p>end catch</p><p>if(@@trancount>0)</p><p>rollback tran pigOneIn --如果成功Lives表中，將會有3條數據。</p><p>--表本身為空表，ID ,Numb為int 類型，其它為nvarchar類型</p><h1>select * from lives</h1><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/153379415948547425472da><p class=pgc-img-caption></p></div><h1><strong>使用set xact_abort</strong></h1><p>設置 xact_abort on/off , 指定是否回滾當前事務，為on時如果當前sql出錯，回滾整個事務，為off時如果sql出錯回滾當前sql語句，其它語句照常運行讀寫數據庫。</p><p>需要注意的時：xact_abort只對運行時出現的錯誤有用，如果sql語句存在編譯時錯誤，那麼他就失靈啦。</p><p>delete lives --清空數據</p><p>set xact_abort off</p><p>begin tran</p><p>--語句正確</p><p>insert into lives (Eat,Play,Numb) values ('豬肉','足球',1)</p><p>--Numb為int類型，出錯,如果1234..那個大數據換成'132dsaf' xact_abort將失效</p><p>insert into lives (Eat,Play,Numb) values ('豬肉','足球',12345646879783213)</p><p>--語句正確</p><p>insert into lives (Eat,Play,Numb) values ('狗肉','籃球',3)</p><p>commit tran</p><p>select * from lives</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1533794202281fbf2d366f7><p class=pgc-img-caption></p></div><p>為on時，結果集為空，因為運行是數據過大溢出出錯，回滾整個事務。</p><h1><strong>事務把死鎖給整出來啦</strong></h1><p>跟著做：打開兩個查詢窗口，把下面的語句，分別放入2個查詢窗口，在5秒內運行2個事務模塊。</p><p>begin tran</p><p>update lives set play='羽毛球'</p><p>waitfor delay '0:0:5'</p><p>update dbo.Earth set Animal='老虎'</p><p>commit tran</p><p>-------------------------------------------</p><p>begin tran</p><p>update Earth set Animal='老虎'</p><p>waitfor delay '0:0:5' --等待5秒執行下面的語句</p><p>update lives set play='羽毛球'</p><p>commit tran</p><p>select * from lives</p><p>select * from Earth</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1533794264181e181aa5bcc><p class=pgc-img-caption></p></div><h1><strong>併發事務成敗皆歸於鎖——鎖定</strong></h1><p>在多用戶都用事務同時訪問同一個數據資源的情況下，就會造成以下幾種數據錯誤。</p><ul><li>更新丟失：多個用戶同時對一個數據資源進行更新，必定會產生被覆蓋的數據，造成數據讀寫異常。</li><li>不可重複讀：如果一個用戶在一個事務中多次讀取一條數據，而另外一個用戶則同時更新啦這條數據，造成第一個用戶多次讀取數據不一致。</li><li>髒讀：第一個事務讀取第二個事務正在更新的數據表，如果第二個事務還沒有更新完成，那麼第一個事務讀取的數據將是一半為更新過的，一半還沒更新過的數據，這樣的數據毫無意義。</li><li>幻讀：第一個事務讀取一個結果集後，第二個事務，對這個結果集經行增刪操作，然而第一個事務中再次對這個結果集進行查詢時，數據發現丟失或新增。</li></ul><p>然而鎖定，就是為解決這些問題所生的，他的存在使得一個事務對他自己的數據塊進行操作的時候，而另外一個事務則不能插足這些數據塊。這就是所謂的鎖定。</p><p>鎖定從數據庫系統的角度大致可以分為6種：</p><ul><li>共享鎖（S）：還可以叫他讀鎖。可以併發讀取數據，但不能修改數據。也就是說當數據資源上存在共享鎖的時候，所有的事務都不能對這個資源進行修改，直到數據讀取完成，共享鎖釋放。</li><li>排它鎖（X）：還可以叫他獨佔鎖、寫鎖。就是如果你對數據資源進行增刪改操作時，不允許其它任何事務操作這塊資源，直到排它鎖被釋放，防止同時對同一資源進行多重操作。</li><li>更新鎖（U）：防止出現死鎖的鎖模式，兩個事務對一個數據資源進行先讀取在修改的情況下，使用共享鎖和排它鎖有時會出現死鎖現象，而使用更新鎖則可以避免死鎖的出現。資源的更新鎖一次只能分配給一個事務，如果需要對資源進行修改，更新鎖會變成排他鎖，否則變為共享鎖。</li><li>意向鎖：SQL Server需要在層次結構中的底層資源上（如行，列）獲取共享鎖，排它鎖，更新鎖。例如表級放置了意向共享鎖，就表示事務要對錶的頁或行上使用共享鎖。在表的某一行上上放置意向鎖，可以防止其它事務獲取其它不兼容的的鎖。意向鎖可以提高性能，因為數據引擎不需要檢測資源的每一列每一行，就能判斷是否可以獲取到該資源的兼容鎖。意向鎖包括三種類型：意向共享鎖（IS），意向排他鎖（IX），意向排他共享鎖（SIX）。</li><li>架構鎖：防止修改表結構時，併發訪問的鎖。</li><li>大容量更新鎖：允許多個線程將大容量數據併發的插入到同一個表中，在加載的同時，不允許其它進程訪問該表。</li></ul><p>這些鎖之間的相互兼容性，也就是，是否可以同時存在。</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533794288687f304432caf><p class=pgc-img-caption></p></div><h1><strong>死鎖</strong></h1><p>什麼是死鎖，為什麼會產生死鎖。我用 “事務把死鎖給整出來啦” 標題下的兩個事務產生的死鎖來解釋應該會更加生動形象點。</p><p>例子是這樣的：</p><p>第一個事務（稱為A）：先更新lives表 --->>停頓5秒---->>更新earth表</p><p>第二個事務（稱為B）：先更新earth表--->>停頓5秒---->>更新lives表</p><p>先執行事務A----5秒之內---執行事務B，出現死鎖現象。</p><p>過程是這樣子的：</p><ol><li>A更新lives表，請求lives的排他鎖，成功。</li><li>B更新earth表，請求earth的排他鎖，成功。</li><li>5秒過後</li><li>A更新earth，請求earth的排它鎖，由於B佔用著earth的排它鎖，等待。</li><li>B更新lives，請求lives的排它鎖，由於A佔用著lives的排它鎖，等待。</li></ol><p>這樣相互等待對方釋放資源，造成資源讀寫擁擠堵塞的情況，就被稱為死鎖現象，也叫做阻塞。而為什麼會產生，上例就列舉出來啦。</p><p>然而數據庫並沒有出現無限等待的情況，是因為數據庫搜索引擎會定期檢測這種狀況，一旦發現有情況，立馬選擇一個事務作為犧牲品。犧牲的事務，將會回滾數據。有點像兩個人在過獨木橋，兩個無腦的人都走在啦獨木橋中間，如果不落水，必定要有一個人給退回來。這種相互等待的過程，是一種耗時耗資源的現象，所以能避則避。</p><p>哪個人會被退回來，作為犧牲品，這個我們是可以控制的。控制語法：</p><p>set deadlock_priority &lt;級別></p><p>死鎖處理的優先級別為 low&lt;normal&lt;high，不指定的情況下默認為normal，犧牲品為隨機。如果指定，犧牲品為級別低的。</p><p>還可以使用數字來處理標識級別：-10到-5為low，-5為normal，-5到10為high。</p><h1><strong>減少死鎖的發生，提高數據庫性能</strong></h1><p>死鎖耗時耗資源，然而在大型數據庫中，高併發帶來的死鎖是不可避免的，所以我們只能讓其變的更少。</p><ol><li>按照同一順序訪問數據庫資源，上述例子就不會發生死鎖啦</li><li>保持是事務的簡短，儘量不要讓一個事務處理過於複雜的讀寫操作。事務過於複雜，佔用資源會增多，處理時間增長，容易與其它事務衝突，提升死鎖概率。</li><li>儘量不要在事務中要求用戶響應，比如修改新增數據之後在完成整個事務的提交，這樣延長事務佔用資源的時間，也會提升死鎖概率。</li><li>儘量減少數據庫的併發量。</li><li>儘可能使用分區表，分區視圖，把數據放置在不同的磁盤和文件組中，分散訪問保存在不同分區的數據，減少因為表中放置鎖而造成的其它事務長時間等待。</li><li>避免佔用時間很長並且關係表複雜的數據操作。</li><li>使用較低的隔離級別，使用較低的隔離級別比使用較高的隔離級別持有共享鎖的時間更短。這樣就減少了鎖爭用。</li></ol><p>可參考：http://msdn.microsoft.com/zh-cn/library/ms191242(v=sql.105).aspx</p><p>查看鎖活動情況：</p><p>--查看鎖活動情況</p><p>select * from sys.dm_tran_locks</p><p>--查看事務活動情況</p><p>dbcc opentran</p><p>可參考：http://msdn.microsoft.com/zh-cn/library/ms190345.aspx</p><h1><strong>為事務設置隔離級別</strong></h1><p>所謂事物隔離級別，就是併發事務對同一資源的讀取深度層次。分為5種。</p><ul><li>read uncommitted：這個隔離級別最低啦，可以讀取到一個事務正在處理的數據，但事務還未提交，這種級別的讀取叫做髒讀。</li><li>read committed：這個級別是默認選項，不能髒讀，不能讀取事務正在處理沒有提交的數據，但能修改。</li><li>repeatable read：不能讀取事務正在處理的數據，也不能修改事務處理數據前的數據。</li><li>snapshot：指定事務在開始的時候，就獲得了已經提交數據的快照，因此當前事務只能看到事務開始之前對數據所做的修改。</li><li>serializable：最高事務隔離級別，只能看到事務處理之前的數據。</li></ul><p>--語法</p><p>set tran isolation level &lt;級別></p><p><strong>read uncommitted隔離級別的例子：</strong></p><p>begin tran</p><p>set deadlock_priority low</p><p>update Earth set Animal='老虎'</p><p>waitfor delay '0:0:5' --等待5秒執行下面的語句</p><p>rollback tran</p><p>開另外一個查詢窗口執行下面語句</p><p>set tran isolation level read uncommitted</p><p>select * from Earth --讀取的數據為正在修改的數據 ，髒讀</p><p>waitfor delay '0:0:5' --5秒之後數據已經回滾</p><p>select * from Earth --回滾之後的數據</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153379431394532ce5b823c><p class=pgc-img-caption></p></div><p><strong>read committed隔離級別的例子：</strong></p><p>begin tran</p><p>update Earth set Animal='老虎'</p><p>waitfor delay '0:0:10' --等待5秒執行下面的語句</p><p>rollback tran</p><p>set tran isolation level read committed</p><p>select * from Earth ---獲取不到老虎，不能髒讀</p><p>update Earth set Animal='猴子1' --可以修改</p><p>waitfor delay '0:0:10' --10秒之後上一個事務已經回滾</p><p>select * from Earth --修改之後的數據，而不是猴子</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533794314350f9650334f4><p class=pgc-img-caption></p></div><p>剩下的幾個級別，不一一列舉啦，自己理解吧。</p><h1><strong>設置鎖超時時間</strong></h1><p>發生死鎖的時候，數據庫引擎會自動檢測死鎖，解決問題，然而這樣子是很被動，只能在發生死鎖後，等待處理。</p><p>然而我們也可以主動出擊，設置鎖超時時間，一旦資源被鎖定阻塞，超過設置的鎖定時間，阻塞語句自動取消，釋放資源，報1222錯誤。</p><p>好東西一般都具有兩面性，調優的同時，也有他的不足之處，那就是一旦超過時間，語句取消，釋放資源，但是當前報錯事務，不會回滾，會造成數據錯誤，你需要在程序中捕獲1222錯誤，用程序處理當前事務的邏輯，使數據正確。</p><p>--查看超時時間,默認為-1</p><p>select <strong>@@lock_timeout</strong></p><p>--設置超時時間</p><p>set lock_timeout <strong>0</strong> --為0時，即為一旦發現資源鎖定，立即報錯，不在等待，當前事務不回滾，設置時間需謹慎處理後事啊，你hold不住的。</p><p>查看與殺死鎖和進程</p><div class=pgc-img><img alt="SQL Server中的事務與鎖" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1533794314016b26bb36b0b><p class=pgc-img-caption></p></div><p>--檢測死鎖</p><p>--如果發生死鎖了，我們怎麼去檢測具體發生死鎖的是哪條SQL語句或存儲過程？</p><p>--這時我們可以使用以下存儲過程來檢測，就可以查出引起死鎖的進程和SQL語句。SQL Server自帶的系統存儲過程sp_who和sp_lock也可以用來查找阻塞和死鎖, 但沒有這裡介紹的方法好用。</p><p>use master</p><p>go</p><p>create procedure sp_who_lock</p><p>as</p><p>begin</p><p>declare @spid int,@bl int,</p><p>@intTransactionCountOnEntry int,</p><p>@intRowcount int,</p><p>@intCountProperties int,</p><p>@intCounter int</p><p>create table #tmp_lock_who (</p><p>id int identity(<strong>1</strong>,<strong>1</strong>),</p><p>spid smallint,</p><p>bl smallint)</p><p>IF <strong>@@ERROR</strong>&lt;><strong>0</strong> RETURN <strong>@@ERROR</strong></p><p>insert into #tmp_lock_who(spid,bl) select <strong>0</strong> ,blocked</p><p>from (select * from sysprocesses where blocked><strong>0</strong> ) a</p><p>where not exists(select * from (select * from sysprocesses where blocked><strong>0</strong> ) b</p><p>where a.blocked=spid)</p><p>union select spid,blocked from sysprocesses where blocked><strong>0</strong></p><p>IF <strong>@@ERROR</strong>&lt;><strong>0</strong> RETURN <strong>@@ERROR</strong></p><p>-- 找到臨時表的記錄數</p><p>select @intCountProperties = Count(*),@intCounter = <strong>1</strong></p><p>from #tmp_lock_who</p><p>IF <strong>@@ERROR</strong>&lt;><strong>0</strong> RETURN <strong>@@ERROR</strong></p><p>if @intCountProperties=<strong>0</strong></p><p>select '現在沒有阻塞和死鎖信息' as message</p><p>-- 循環開始</p><p>while @intCounter &lt;= @intCountProperties</p><p>begin</p><p>-- 取第一條記錄</p><p>select @spid = spid,@bl = bl</p><p>from #tmp_lock_who where Id = @intCounter</p><p>begin</p><p>if @spid =<strong>0</strong></p><p>select '引起數據庫死鎖的是: '+ CAST(@bl AS VARCHAR(<strong>10</strong>)) + '進程號,其執行的SQL語法如下'</p><p>else</p><p>select '進程號SPID：'+ CAST(@spid AS VARCHAR(<strong>10</strong>))+ '被' + '進程號SPID：'+ CAST(@bl AS VARCHAR(<strong>10</strong>)) +'阻塞,其當前進程執行的SQL語法如下'</p><p>DBCC INPUTBUFFER (@bl )</p><p>end</p><p>-- 循環指針下移</p><p>set @intCounter = @intCounter + <strong>1</strong></p><p>end</p><p>drop table #tmp_lock_who</p><p>return <strong>0</strong></p><p>end</p><p>--殺死鎖和進程</p><p>--如何去手動的殺死進程和鎖？最簡單的辦法，重新啟動服務。但是這裡要介紹一個存儲過程，通過顯式的調用，可以殺死進程和鎖。</p><p>use master</p><p>go</p><p>if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[p_killspid]') and OBJECTPROPERTY(id, N'IsProcedure') = <strong>1</strong>)</p><p>drop procedure [dbo].[p_killspid]</p><p>GO</p><p>create proc p_killspid</p><p>@dbname varchar(<strong>200</strong>) --要關閉進程的數據庫名</p><p>as</p><p>declare @sql nvarchar(<strong>500</strong>)</p><p>declare @spid nvarchar(<strong>20</strong>)</p><p>declare #tb cursor for</p><p>select spid=cast(spid as varchar(<strong>20</strong>)) from master..sysprocesses where dbid=db_id(@dbname)</p><p>open #tb</p><p>fetch next from #tb into @spid</p><p>while <strong>@@fetch_status</strong>=<strong>0</strong></p><p>begin</p><p>exec('kill '+@spid)</p><p>fetch next from #tb into @spid</p><p>end</p><p>close #tb</p><p>deallocate #tb</p><p>go</p><p>--用法</p><p>exec p_killspid 'newdbpy'</p><p>--查看鎖信息</p><p>--如何查看系統中所有鎖的詳細信息？在企業管理管理器中，我們可以看到一些進程和鎖的信息，這裡介紹另外一種方法。</p><p>--查看鎖信息</p><p>create table #t(req_spid int,obj_name sysname)</p><p>declare @s nvarchar(<strong>4000</strong>)</p><p>,@rid int,@dbname sysname,@id int,@objname sysname</p><p>declare tb cursor for</p><p>select distinct req_spid,dbname=db_name(rsc_dbid),rsc_objid</p><p>from master..syslockinfo where rsc_type in(<strong>4</strong>,<strong>5</strong>)</p><p>open tb</p><p>fetch next from tb into @rid,@dbname,@id</p><p>while <strong>@@fetch_status</strong>=<strong>0</strong></p><p>begin</p><p>set @s='select @objname=name from ['+@dbname+']..sysobjects where id=@id'</p><p>exec sp_executesql @s,N'@objname sysname out,@id int',@objname out,@id</p><p>insert into #t values(@rid,@objname)</p><p>fetch next from tb into @rid,@dbname,@id</p><p>end</p><p>close tb</p><p>deallocate tb</p><p>select 進程id=a.req_spid</p><p>,數據庫=db_name(rsc_dbid)</p><p>,類型=case rsc_type when <strong>1</strong> then 'NULL 資源（未使用）'</p><p>when <strong>2</strong> then '數據庫'</p><p>when <strong>3</strong> then '文件'</p><p>when <strong>4</strong> then '索引'</p><p>when <strong>5</strong> then '表'</p><p>when <strong>6</strong> then '頁'</p><p>when <strong>7</strong> then '鍵'</p><p>when <strong>8</strong> then '擴展盤區'</p><p>when <strong>9</strong> then 'RID（行 ID)'</p><p>when <strong>10</strong> then '應用程序'</p><p>end</p><p>,對象id=rsc_objid</p><p>,對象名=b.obj_name</p><p>,rsc_indid</p><p>from master..syslockinfo a left join #t b on a.req_spid=b.req_spid</p><p>go</p><p>drop table #t</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>SQL</a></li><li><a>Server</a></li><li><a>事務與鎖</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b59f90b2.html alt="SQL Server——遊標詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/456cfc0b6fb0444c87e68098345fa638 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b59f90b2.html title="SQL Server——遊標詳解">SQL Server——遊標詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html alt=SQL基礎知識——事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/773e21df09dc4e3e8403a0a62994039d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6e14bc6.html title=SQL基礎知識——事務>SQL基礎知識——事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html alt="SQL 難點解決：記錄的引用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a1b904121564aa389aba6a046772870 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ddebd12.html title="SQL 難點解決：記錄的引用">SQL 難點解決：記錄的引用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5773a66.html alt=（二)SQL數據模式、表、索引的建立與刪除 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0f1d1d3b1dac408190a1191154fe642d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5773a66.html title=（二)SQL數據模式、表、索引的建立與刪除>（二)SQL數據模式、表、索引的建立與刪除</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a0630d89.html alt=SQL分類之DQL：查詢表中的記錄 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a0630d89.html title=SQL分類之DQL：查詢表中的記錄>SQL分類之DQL：查詢表中的記錄</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/332cb941.html alt=數據庫SQL最常用語句 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/332cb941.html title=數據庫SQL最常用語句>數據庫SQL最常用語句</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ca809f3.html alt="SQL SERVER數據庫中用select語句複製表結構創建新表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ca809f3.html title="SQL SERVER數據庫中用select語句複製表結構創建新表">SQL SERVER數據庫中用select語句複製表結構創建新表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c388b7.html alt=數據分析師要掌握SQL到什麼程度？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9632c1ad23d948788a9c4d84a167aafc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c388b7.html title=數據分析師要掌握SQL到什麼程度？>數據分析師要掌握SQL到什麼程度？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e06406f1.html alt="Windows Server 2008 R2 主域控制器、文件服務器遷移、升級記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bd7b5492449f49c69fa520a38a0665bc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e06406f1.html title="Windows Server 2008 R2 主域控制器、文件服務器遷移、升級記">Windows Server 2008 R2 主域控制器、文件服務器遷移、升級記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f357ca6.html alt="SQL 2大觸發器類型及應用實例" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a4853ad0f7f84c14a09f3af661787334 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f357ca6.html title="SQL 2大觸發器類型及應用實例">SQL 2大觸發器類型及應用實例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12fe4764.html alt="SQL 中的if判斷語句、while循環語句、和運算符" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/04199ae85d034aba8f5792b86591bb77 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12fe4764.html title="SQL 中的if判斷語句、while循環語句、和運算符">SQL 中的if判斷語句、while循環語句、和運算符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b91c075.html alt="百度語義解析 ( Text-to-SQL ) 技術研究及應用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/780ac2852a114bb8a09aeffaf6b1f45e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b91c075.html title="百度語義解析 ( Text-to-SQL ) 技術研究及應用">百度語義解析 ( Text-to-SQL ) 技術研究及應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6483b67d.html alt=SQL中利用LIKE實現模糊查詢的功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1b76fd0b683147a29004e349ccb0aaaa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6483b67d.html title=SQL中利用LIKE實現模糊查詢的功能>SQL中利用LIKE實現模糊查詢的功能</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>