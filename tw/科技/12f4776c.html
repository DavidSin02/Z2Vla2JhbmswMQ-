<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java HashMap源碼分析 | 极客快訊</title><meta property="og:title" content="Java HashMap源碼分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/12f4776c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/12f4776c.html><meta property="article:published_time" content="2020-10-29T21:09:21+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:21+08:00"><meta name=Keywords content><meta name=description content="Java HashMap源碼分析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/12f4776c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java HashMap源碼分析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>本文從 Hash 方法開始，通過分析源碼，深入介紹了 JDK 不同版本中 HashMap 的實現。HashMap 簡介</strong></p><p>HashMap 主要用來存放鍵值對，它基於哈希表的Map接口實現，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 數組+鏈表 組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的（“拉鍊法”解決衝突）.JDK1.8 以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為 8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><p>底層數據結構分析</p><p>JDK1.8之前</p><p>JDK1.8 之前 HashMap 底層是 <strong>數組和鏈表</strong> 結合在一起使用也就是 <strong>鏈表散列</strong>。<strong>HashMap 通過 key 的 hashCode 經過擾動函數處理過後得到 hash 值，然後通過 (n - 1) & hash 判斷當前元素存放的位置（這裡的 n 指的是數組的長度），如果當前位置存在元素的話，就判斷該元素與要存入的元素的 hash 值以及 key 是否相同，如果相同的話，直接覆蓋，不相同就通過拉鍊法解決衝突。</strong></p><p><strong>所謂擾動函數指的就是 HashMap 的 hash 方法。使用 hash 方法也就是擾動函數是為了防止一些實現比較差的 hashCode() 方法 換句話說使用擾動函數之後可以減少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源碼:</strong></p><p>JDK 1.8 的 hash方法 相比於 JDK 1.7 hash 方法更加簡化，但是原理不變。</p><p><strong>static</strong> <strong>final</strong> <strong>int</strong> hash(<strong>Object</strong> key) {</p><p><strong>int</strong> h;</p><p>// key.hashCode()：返回散列值也就是hashcode</p><p>// ^ ：按位異或</p><p>// >>>:無符號右移，忽略符號位，空位都以0補齊</p><p><strong>return</strong> (key == <strong>null</strong>) ? 0 : (h = key.hashCode()) ^ (h >>> 16);</p><p>}</p><p>對比一下 JDK1.7的 HashMap 的 hash 方法源碼.</p><p><strong>static</strong> int hash(int h) {</p><p>// This function ensures that hashCodes that differ only by</p><p>// constant multiples at each bit position have a bounded</p><p>// number of collisions (approximately 8 at default load factor).</p><p>h ^= (h >>> 20) ^ (h >>> 12);</p><p><strong>return</strong> h ^ (h >>> 7) ^ (h >>> 4);</p><p>}</p><p>相比於 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能會稍差一點點，因為畢竟擾動了 4 次。</p><p>所謂 <strong>“拉鍊法” </strong>就是：將鏈表和數組相結合。也就是說創建一個鏈表數組，數組中每一格就是一個鏈表。若遇到哈希衝突，則將衝突的值加到鏈表中即可。</p><div class=pgc-img><img alt="Java HashMap源碼分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00><p class=pgc-img-caption></p></div><p>JDK1.8之後</p><p>相比於之前的版本，jdk1.8在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><div class=pgc-img><img alt="Java HashMap源碼分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cda0ca04b484266ab08bc7fcf173bb9><p class=pgc-img-caption></p></div><p><strong>類的屬性：</strong></p><p><strong>public</strong> <strong>class</strong> HashMap&lt;K,V> <strong>extends</strong> AbstractMap&lt;K,V> <strong>implements</strong> Map&lt;K,V>, Cloneable, Serializable {</p><p>// 序列號</p><p><strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> serialVersionUID = 362498820763181265L;</p><p>// 默認的初始容量是16</p><p><strong>static</strong> <strong>final</strong> <strong>int</strong> DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</p><p>// 最大容量</p><p><strong>static</strong> <strong>final</strong> <strong>int</strong> MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</p><p>// 默認的填充因子</p><p><strong>static</strong> <strong>final</strong> <strong>float</strong> DEFAULT_LOAD_FACTOR = 0.75f;</p><p>// 當桶(bucket)上的結點數大於這個值時會轉成紅黑樹</p><p><strong>static</strong> <strong>final</strong> <strong>int</strong> TREEIFY_THRESHOLD = 8;</p><p>// 當桶(bucket)上的結點數小於這個值時樹轉鏈表</p><p><strong>static</strong> <strong>final</strong> <strong>int</strong> UNTREEIFY_THRESHOLD = 6;</p><p>// 桶中結構轉化為紅黑樹對應的table的最小大小</p><p><strong>static</strong> <strong>final</strong> <strong>int</strong> MIN_TREEIFY_CAPACITY = 64;</p><p>// 存儲元素的數組，總是2的冪次倍</p><p><strong>transient</strong> Node&lt;k,v>[] table;</p><p>// 存放具體元素的集</p><p><strong>transient</strong> Set&lt;map.entry&lt;k,v>> entrySet;</p><p>// 存放元素的個數，注意這個不等於數組的長度。</p><p><strong>transient</strong> <strong>int</strong> size;</p><p>// 每次擴容和更改map結構的計數器</p><p><strong>transient</strong> <strong>int</strong> modCount;</p><p>// 臨界值 當實際大小(容量*填充因子)超過臨界值時，會進行擴容</p><p><strong>int</strong> threshold;</p><p>// 填充因子</p><p><strong>final</strong> <strong>float</strong> loadFactor;</p><p>}</p><ul><li>loadFactor加載因子</li></ul><p>loadFactor加載因子是控制數組存放數據的疏密程度，loadFactor越趨近於1，那麼 數組中存放的數據(entry)也就越多，也就越密，也就是會讓鏈表的長度增加，load Factor越小，也就是趨近於0，</p><p>loadFactor太大導致查找元素效率低，太小導致數組的利用率低，存放的數據會很分散。loadFactor的默認值為0.75f是官方給出的一個比較好的臨界值。</p><ul><li>threshold</li></ul><p>threshold = capacity * loadFactor，當Size>=threshold的時候，那麼就要考慮對數組的擴增了，也就是說，這個的意思就是 衡量數組是否需要擴增的一個標準。</p><p><strong>Node節點類源碼：</strong></p><p>// 繼承自 Map.Entry&lt;K,V></p><p><strong>static</strong> <strong>class</strong> Node&lt;K,V> <strong>implements</strong> Map.Entry&lt;K,V> {</p><p><strong>final</strong> <strong>int</strong> hash;// 哈希值，存放元素到hashmap中時用來與其他元素hash值比較</p><p><strong>final</strong> K key;//鍵</p><p>V value;//值</p><p>// 指向下一個節點</p><p>Node&lt;K,V> next;</p><p>Node(<strong>int</strong> hash, K key, V value, Node&lt;K,V> next) {</p><p><strong>this</strong>.hash = hash;</p><p><strong>this</strong>.key = key;</p><p><strong>this</strong>.value = value;</p><p><strong>this</strong>.next = next;</p><p>}</p><p><strong>public</strong> <strong>final</strong> K getKey() { <strong>return</strong> key; }</p><p><strong>public</strong> <strong>final</strong> V getValue() { <strong>return</strong> value; }</p><p><strong>public</strong> <strong>final</strong> String toString() { <strong>return</strong> key + "=" + value; }</p><p>// 重寫hashCode()方法</p><p><strong>public</strong> <strong>final</strong> <strong>int</strong> hashCode() {</p><p><strong>return</strong> Objects.hashCode(key) ^ Objects.hashCode(value);</p><p>}</p><p><strong>public</strong> <strong>final</strong> V setValue(V newValue) {</p><p>V oldValue = value;</p><p>value = newValue;</p><p><strong>return</strong> oldValue;</p><p>}</p><p>// 重寫 equals() 方法</p><p><strong>public</strong> <strong>final</strong> <strong>boolean</strong> equals(Object o) {</p><p><strong>if</strong> (o == <strong>this</strong>)</p><p><strong>return</strong> <strong>true</strong>;</p><p><strong>if</strong> (o <strong>instanceof</strong> Map.Entry) {</p><p>Map.Entry&lt;?,?> e = (Map.Entry&lt;?,?>)o;</p><p><strong>if</strong> (Objects.equals(key, e.getKey()) &&</p><p>Objects.equals(value, e.getValue()))</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>}</p><p><strong>樹節點類源碼：</strong></p><p><strong>static</strong> <strong>final</strong> <strong>class</strong> TreeNode&lt;K,V> <strong>extends</strong> LinkedHashMap.Entry&lt;K,V> {</p><p>TreeNode&lt;K,V> parent; // 父</p><p>TreeNode&lt;K,V> left; // 左</p><p>TreeNode&lt;K,V> right; // 右</p><p>TreeNode&lt;K,V> prev; // needed to unlink next upon deletion</p><p><strong>boolean</strong> red; // 判斷顏色</p><p>TreeNode(<strong>int</strong> hash, K key, V val, Node&lt;K,V> next) {</p><p><strong>super</strong>(hash, key, val, next);</p><p>}</p><p>// 返回根節點</p><p><strong>final</strong> TreeNode&lt;K,V> root() {</p><p><strong>for</strong> (TreeNode&lt;K,V> r = <strong>this</strong>, p;;) {</p><p><strong>if</strong> ((p = r.parent) == <strong>null</strong>)</p><p><strong>return</strong> r;</p><p>r = p;</p><p>}</p><p>HashMap源碼分析</p><p>構造方法</p><div class=pgc-img><img alt="Java HashMap源碼分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2aee2ff546640358fe9e360d139b485><p class=pgc-img-caption></p></div><p class=ql-align-right><br></p><p>// 默認構造函數。</p><p><strong>public</strong> More ...HashMap() {</p><p><strong>this</strong>.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</p><p>}</p><p>// 包含另一個“Map”的構造函數</p><p><strong>public</strong> More ...HashMap(Map&lt;? <strong>extends</strong> K, ? <strong>extends</strong> V> m) {</p><p><strong>this</strong>.loadFactor = DEFAULT_LOAD_FACTOR;</p><p>putMapEntries(m, <strong>false</strong>);//下面會分析到這個方法</p><p>}</p><p>// 指定“容量大小”的構造函數</p><p><strong>public</strong> More ...HashMap(<strong>int</strong> initialCapacity) {</p><p><strong>this</strong>(initialCapacity, DEFAULT_LOAD_FACTOR);</p><p>}</p><p>// 指定“容量大小”和“加載因子”的構造函數</p><p><strong>public</strong> More ...HashMap(<strong>int</strong> initialCapacity, <strong>float</strong> loadFactor) {</p><p><strong>if</strong> (initialCapacity &lt; 0)</p><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException("Illegal initial capacity: " + initialCapacity);</p><p><strong>if</strong> (initialCapacity > MAXIMUM_CAPACITY)</p><p>initialCapacity = MAXIMUM_CAPACITY;</p><p><strong>if</strong> (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</p><p><strong>throw</strong> <strong>new</strong> IllegalArgumentException("Illegal load factor: " + loadFactor);</p><p><strong>this</strong>.loadFactor = loadFactor;</p><p><strong>this</strong>.threshold = tableSizeFor(initialCapacity);</p><p>}</p><p><strong>putMapEntries方法：</strong></p><p><strong>final</strong> <strong>void</strong> putMapEntries(Map&lt;? <strong>extends</strong> K, ? <strong>extends</strong> V> m, <strong>boolean</strong> evict) {</p><p><strong>int</strong> s = m.size();</p><p><strong>if</strong> (s > 0) {</p><p>// 判斷table是否已經初始化</p><p><strong>if</strong> (table == <strong>null</strong>) { // pre-size</p><p>// 未初始化，s為m的實際元素個數</p><p><strong>float</strong> ft = ((<strong>float</strong>)s / loadFactor) + 1.0F;</p><p><strong>int</strong> t = ((ft &lt; (<strong>float</strong>)MAXIMUM_CAPACITY) ?</p><p>(<strong>int</strong>)ft : MAXIMUM_CAPACITY);</p><p>// 計算得到的t大於閾值，則初始化閾值</p><p><strong>if</strong> (t > threshold)</p><p>threshold = tableSizeFor(t);</p><p>}</p><p>// 已初始化，並且m元素個數大於閾值，進行擴容處理</p><p><strong>else</strong> <strong>if</strong> (s > threshold)</p><p>resize();</p><p>// 將m中的所有元素添加至HashMap中</p><p><strong>for</strong> (Map.Entry&lt;? <strong>extends</strong> K, ? <strong>extends</strong> V> e : m.entrySet()) {</p><p>K key = e.getKey();</p><p>V value = e.getValue();</p><p>putVal(hash(key), key, value, <strong>false</strong>, evict);</p><p>}</p><p>}</p><p>}</p><p>put方法</p><p>HashMap只提供了put用於添加元素，putVal方法只是給put方法調用的一個方法，並沒有提供給用戶使用。</p><p>對putVal方法添加元素的分析如下：</p><ul><li>①如果定位到的數組位置沒有元素 就直接插入。</li><li>②如果定位到的數組位置有元素就和要插入的 key 比較，如果key相同就直接覆蓋，如果 key 不相同，就判斷 p 是否是一個樹節點，如果是就調用 e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value) 將元素添加進入。如果不是就遍歷鏈表插入。</li></ul><div class=pgc-img><img alt="Java HashMap源碼分析" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/313acf6f1dc84813b42fbd6f165ef79c><p class=pgc-img-caption></p></div><p class=ql-align-right><br></p><p><strong>public</strong> V put(K key, V value) {</p><p><strong>return</strong> putVal(hash(key), key, value, <strong>false</strong>, <strong>true</strong>);</p><p>}</p><p><strong>final</strong> V putVal(<strong>int</strong> hash, K key, V value, <strong>boolean</strong> onlyIfAbsent,</p><p><strong>boolean</strong> evict) {</p><p>Node&lt;K,V>[] tab; Node&lt;K,V> p; <strong>int</strong> n, i;</p><p>// table未初始化或者長度為0，進行擴容</p><p><strong>if</strong> ((tab = table) == <strong>null</strong> || (n = tab.length) == 0)</p><p>n = (tab = resize()).length;</p><p>// (n - 1) & hash 確定元素存放在哪個桶中，桶為空，新生成結點放入桶中(此時，這個結點是放在數組中)</p><p><strong>if</strong> ((p = tab[i = (n - 1) & hash]) == <strong>null</strong>)</p><p>tab[i] = newNode(hash, key, value, <strong>null</strong>);</p><p>// 桶中已經存在元素</p><p><strong>else</strong> {</p><p>Node&lt;K,V> e; K k;</p><p>// 比較桶中第一個元素(數組中的結點)的hash值相等，key相等</p><p><strong>if</strong> (p.hash == hash &&</p><p>((k = p.key) == key || (key != <strong>null</strong> && key.equals(k))))</p><p>// 將第一個元素賦值給e，用e來記錄</p><p>e = p;</p><p>// hash值不相等，即key不相等；為紅黑樹結點</p><p><strong>else</strong> <strong>if</strong> (p <strong>instanceof</strong> TreeNode)</p><p>// 放入樹中</p><p>e = ((TreeNode&lt;K,V>)p).putTreeVal(<strong>this</strong>, tab, hash, key, value);</p><p>// 為鏈表結點</p><p><strong>else</strong> {</p><p>// 在鏈表最末插入結點</p><p><strong>for</strong> (<strong>int</strong> binCount = 0; ; ++binCount) {</p><p>// 到達鏈表的尾部</p><p><strong>if</strong> ((e = p.next) == <strong>null</strong>) {</p><p>// 在尾部插入新結點</p><p>p.next = newNode(hash, key, value, <strong>null</strong>);</p><p>// 結點數量達到閾值，轉化為紅黑樹</p><p><strong>if</strong> (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st</p><p>treeifyBin(tab, hash);</p><p>// 跳出循環</p><p><strong>break</strong>;</p><p>}</p><p>// 判斷鏈表中結點的key值與插入的元素的key值是否相等</p><p><strong>if</strong> (e.hash == hash &&</p><p>((k = e.key) == key || (key != <strong>null</strong> && key.equals(k))))</p><p>// 相等，跳出循環</p><p><strong>break</strong>;</p><p>// 用於遍歷桶中的鏈表，與前面的e = p.next組合，可以遍歷鏈表</p><p>p = e;</p><p>}</p><p>}</p><p>// 表示在桶中找到key值、hash值與插入元素相等的結點</p><p><strong>if</strong> (e != <strong>null</strong>) {</p><p>// 記錄e的value</p><p>V oldValue = e.value;</p><p>// onlyIfAbsent為false或者舊值為null</p><p><strong>if</strong> (!onlyIfAbsent || oldValue == <strong>null</strong>)</p><p>//用新值替換舊值</p><p>e.value = value;</p><p>// 訪問後回調</p><p>afterNodeAccess(e);</p><p>// 返回舊值</p><p><strong>return</strong> oldValue;</p><p>}</p><p>}</p><p>// 結構性修改</p><p>++modCount;</p><p>// 實際大小大於閾值則擴容</p><p><strong>if</strong> (++size > threshold)</p><p>resize();</p><p>// 插入後回調</p><p>afterNodeInsertion(evict);</p><p><strong>return</strong> <strong>null</strong>;</p><p>}</p><p><strong>我們再來對比一下 JDK1.7 put方法的代碼</strong></p><p><strong>對於put方法的分析如下：</strong></p><ul><li>①如果定位到的數組位置沒有元素 就直接插入。</li><li>②如果定位到的數組位置有元素，遍歷以這個元素為頭結點的鏈表，依次和插入的key比較，如果key相同就直接覆蓋，不同就採用頭插法插入元素。</li></ul><p><strong>public</strong> V put(K key, V value)</p><p><strong>if</strong> (table == EMPTY_TABLE) {</p><p>inflateTable(threshold);</p><p>}</p><p><strong>if</strong> (key == <strong>null</strong>)</p><p><strong>return</strong> putForNullKey(value);</p><p><strong>int</strong> hash = hash(key);</p><p><strong>int</strong> i = indexFor(hash, table.length);</p><p><strong>for</strong> (Entry&lt;K,V> e = table[i]; e != <strong>null</strong>; e = e.next) { // 先遍歷</p><p>Object k;</p><p><strong>if</strong> (e.hash == hash && ((k = e.key) == key || key.equals(k))) {</p><p>V oldValue = e.value;</p><p>e.value = value;</p><p>e.recordAccess(<strong>this</strong>);</p><p><strong>return</strong> oldValue;</p><p>}</p><p>}</p><p>modCount++;</p><p>addEntry(hash, key, value, i); // 再插入</p><p><strong>return</strong> <strong>null</strong>;</p><p>}</p><p>get方法</p><p><strong>public</strong> V get(Object key) {</p><p>Node&lt;K,V> e;</p><p><strong>return</strong> (e = getNode(hash(key), key)) == <strong>null</strong> ? <strong>null</strong> : e.value;</p><p>}</p><p><strong>final</strong> Node&lt;K,V> getNode(<strong>int</strong> hash, Object key) {</p><p>Node&lt;K,V>[] tab; Node&lt;K,V> first, e; <strong>int</strong> n; K k;</p><p><strong>if</strong> ((tab = table) != <strong>null</strong> && (n = tab.length) > 0 &&</p><p>(first = tab[(n - 1) & hash]) != <strong>null</strong>) {</p><p>// 數組元素相等</p><p><strong>if</strong> (first.hash == hash && // always check first node</p><p>((k = first.key) == key || (key != <strong>null</strong> && key.equals(k))))</p><p><strong>return</strong> first;</p><p>// 桶中不止一個節點</p><p><strong>if</strong> ((e = first.next) != <strong>null</strong>) {</p><p>// 在樹中get</p><p><strong>if</strong> (first <strong>instanceof</strong> TreeNode)</p><p><strong>return</strong> ((TreeNode&lt;K,V>)first).getTreeNode(hash, key);</p><p>// 在鏈表中get</p><p><strong>do</strong> {</p><p><strong>if</strong> (e.hash == hash &&</p><p>((k = e.key) == key || (key != <strong>null</strong> && key.equals(k))))</p><p><strong>return</strong> e;</p><p>} <strong>while</strong> ((e = e.next) != <strong>null</strong>);</p><p>}</p><p>}</p><p><strong>return</strong> <strong>null</strong>;</p><p>}</p><p>resize方法</p><p>進行擴容，會伴隨著一次重新hash分配，並且會遍歷hash表中所有的元素，是非常耗時的。在編寫程序中，要儘量避免resize。</p><p><strong>final</strong> Node&lt;K,V>[] resize() {</p><p>Node&lt;K,V>[] oldTab = table;</p><p><strong>int</strong> oldCap = (oldTab == <strong>null</strong>) ? 0 : oldTab.length;</p><p><strong>int</strong> oldThr = threshold;</p><p><strong>int</strong> newCap, newThr = 0;</p><p><strong>if</strong> (oldCap > 0) {</p><p>// 超過最大值就不再擴充了，就只好隨你碰撞去吧</p><p><strong>if</strong> (oldCap >= MAXIMUM_CAPACITY) {</p><p>threshold = Integer.MAX_VALUE;</p><p><strong>return</strong> oldTab;</p><p>}</p><p>// 沒超過最大值，就擴充為原來的2倍</p><p><strong>else</strong> <strong>if</strong> ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY && oldCap >= DEFAULT_INITIAL_CAPACITY)</p><p>newThr = oldThr &lt;&lt; 1; // double threshold</p><p>}</p><p><strong>else</strong> <strong>if</strong> (oldThr > 0) // initial capacity was placed in threshold</p><p>newCap = oldThr;</p><p><strong>else</strong> {</p><p>signifies using defaults</p><p>newCap = DEFAULT_INITIAL_CAPACITY;</p><p>newThr = (<strong>int</strong>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</p><p>}</p><p>// 計算新的resize上限</p><p><strong>if</strong> (newThr == 0) {</p><p><strong>float</strong> ft = (<strong>float</strong>)newCap * loadFactor;</p><p>newThr = (newCap &lt; MAXIMUM_CAPACITY && ft &lt; (<strong>float</strong>)MAXIMUM_CAPACITY ? (<strong>int</strong>)ft : Integer.MAX_VALUE);</p><p>}</p><p>threshold = newThr;</p><p>@SuppressWarnings({"rawtypes","unchecked"})</p><p>Node&lt;K,V>[] newTab = (Node&lt;K,V>[])<strong>new</strong> Node[newCap];</p><p>table = newTab;</p><p><strong>if</strong> (oldTab != <strong>null</strong>) {</p><p>// 把每個bucket都移動到新的buckets中</p><p><strong>for</strong> (<strong>int</strong> j = 0; j &lt; oldCap; ++j) {</p><p>Node&lt;K,V> e;</p><p><strong>if</strong> ((e = oldTab[j]) != <strong>null</strong>) {</p><p>oldTab[j] = <strong>null</strong>;</p><p><strong>if</strong> (e.next == <strong>null</strong>)</p><p>newTab[e.hash & (newCap - 1)] = e;</p><p><strong>else</strong> <strong>if</strong> (e <strong>instanceof</strong> TreeNode)</p><p>((TreeNode&lt;K,V>)e).split(<strong>this</strong>, newTab, j, oldCap);</p><p><strong>else</strong> {</p><p>Node&lt;K,V> loHead = <strong>null</strong>, loTail = <strong>null</strong>;</p><p>Node&lt;K,V> hiHead = <strong>null</strong>, hiTail = <strong>null</strong>;</p><p>Node&lt;K,V> next;</p><p><strong>do</strong> {</p><p>next = e.next;</p><p>// 原索引</p><p><strong>if</strong> ((e.hash & oldCap) == 0) {</p><p><strong>if</strong> (loTail == <strong>null</strong>)</p><p>loHead = e;</p><p><strong>else</strong></p><p>loTail.next = e;</p><p>loTail = e;</p><p>}</p><p>// 原索引+oldCap</p><p><strong>else</strong> {</p><p><strong>if</strong> (hiTail == <strong>null</strong>)</p><p>hiHead = e;</p><p><strong>else</strong></p><p>hiTail.next = e;</p><p>hiTail = e;</p><p>}</p><p>} <strong>while</strong> ((e = next) != <strong>null</strong>);</p><p>// 原索引放到bucket裡</p><p><strong>if</strong> (loTail != <strong>null</strong>) {</p><p>loTail.next = <strong>null</strong>;</p><p>newTab[j] = loHead;</p><p>}</p><p>// 原索引+oldCap放到bucket裡</p><p><strong>if</strong> (hiTail != <strong>null</strong>) {</p><p>hiTail.next = <strong>null</strong>;</p><p>newTab[j + oldCap] = hiHead;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p><strong>return</strong> newTab;</p><p>}</p><p>HashMap常用方法測試</p><p><strong>package</strong> map;</p><p><strong>import</strong> java.util.Collection;</p><p><strong>import</strong> java.util.HashMap;</p><p><strong>import</strong> java.util.Set;</p><p><strong>public</strong> <strong>class</strong> HashMapDemo {</p><p><strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</p><p>HashMap&lt;String, String> map = <strong>new</strong> HashMap&lt;String, String>();</p><p>// 鍵不能重複，值可以重複</p><p>map.put("san", "張三");</p><p>map.put("si", "李四");</p><p>map.put("wu", "王五");</p><p>map.put("wang", "老王");</p><p>map.put("wang", "老王2");// 老王被覆蓋</p><p>map.put("lao", "老王");</p><p>System.out.println("-------直接輸出hashmap:-------");</p><p>System.out.println(map);</p><p>/**</p><p>* 遍歷HashMap</p><p>*/</p><p>// 1.獲取Map中的所有鍵</p><p>System.out.println("-------foreach獲取Map中所有的鍵:------");</p><p>Set&lt;String> keys = map.keySet();</p><p><strong>for</strong> (String key : keys) {</p><p>System.out.print(key+" ");</p><p>}</p><p>System.out.println();//換行</p><p>// 2.獲取Map中所有值</p><p>System.out.println("-------foreach獲取Map中所有的值:------");</p><p>Collection&lt;String> values = map.values();</p><p><strong>for</strong> (String value : values) {</p><p>System.out.print(value+" ");</p><p>}</p><p>System.out.println();//換行</p><p>// 3.得到key的值的同時得到key所對應的值</p><p>System.out.println("-------得到key的值的同時得到key所對應的值:-------");</p><p>Set&lt;String> keys2 = map.keySet();</p><p><strong>for</strong> (String key : keys2) {</p><p>System.out.print(key + "：" + map.get(key)+" ");</p><p>}</p><p>/**</p><p>* 另外一種不常用的遍歷方式</p><p>*/</p><p>// 當我調用put(key,value)方法的時候，首先會把key和value封裝到</p><p>// Entry這個靜態內部類對象中，把Entry對象再添加到數組中，所以我們想獲取</p><p>// map中的所有鍵值對，我們只要獲取數組中的所有Entry對象，接下來</p><p>// 調用Entry對象中的getKey()和getValue()方法就能獲取鍵值對了</p><p>Set&lt;java.util.Map.Entry&lt;String, String>> entrys = map.entrySet();</p><p><strong>for</strong> (java.util.Map.Entry&lt;String, String> entry : entrys) {</p><p>System.out.println(entry.getKey() + "--" + entry.getValue());</p><p>}</p><p>/**</p><p>* HashMap其他常用方法</p><p>*/</p><p>System.out.println("after map.size()："+map.size());</p><p>System.out.println("after map.isEmpty()："+map.isEmpty());</p><p>System.out.println(map.remove("san"));</p><p>System.out.println("after map.remove()："+map);</p><p>System.out.println("after map.get(si)："+map.get("si"));</p><p>System.out.println("after map.containsKey(si)："+map.containsKey("si"));</p><p>System.out.println("after containsValue(李四)："+map.containsValue("李四"));</p><p>System.out.println(map.replace("si", "李四2"));</p><p>System.out.println("after map.replace(si, 李四2):"+map);</p><p>}</p><p>}</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>HashMap</a></li><li><a>源碼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html alt=Java——HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8ad8e7317b3047f28717cf8c6fb816bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html title=Java——HashMap源碼分析>Java——HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html alt=Java中HashMap源碼分析，絕對乾貨！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/593f0003cad0b7c22de4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html title=Java中HashMap源碼分析，絕對乾貨！>Java中HashMap源碼分析，絕對乾貨！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html alt=Java容器系列-HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10798fbb789b4217a4b19b4f307422b1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html title=Java容器系列-HashMap源碼分析>Java容器系列-HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html alt=源碼分析：Java集合類的AbstractCollection源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html title=源碼分析：Java集合類的AbstractCollection源碼解析>源碼分析：Java集合類的AbstractCollection源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd535810.html alt="Java源碼分析：關於 HashMap 1.8 的重大更新" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66c40005d5e8c29e8c31 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd535810.html title="Java源碼分析：關於 HashMap 1.8 的重大更新">Java源碼分析：關於 HashMap 1.8 的重大更新</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html alt="Java源碼中>>，>>>的區別是啥？我給你徹底講清" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b12aaaf792c8469c91e2a514a666a8cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html title="Java源碼中>>，>>>的區別是啥？我給你徹底講清">Java源碼中>>，>>>的區別是啥？我給你徹底講清</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>