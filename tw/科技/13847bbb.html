<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C++ 容器及選用總結之函數子、函數子類、函數及其他 | 极客快訊</title><meta property="og:title" content="C++ 容器及選用總結之函數子、函數子類、函數及其他 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/13847bbb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/13847bbb.html><meta property="article:published_time" content="2020-10-29T21:09:16+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:16+08:00"><meta name=Keywords content><meta name=description content="C++ 容器及選用總結之函數子、函數子類、函數及其他"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/13847bbb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C++ 容器及選用總結之函數子、函數子類、函數及其他</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>續上篇</strong></p><h1>第38條：遵循按值傳遞的原則來設計函數子類。</h1><p>在STL中，函數對象在函數之間來回傳遞的時候也是像函數指針那樣按值傳遞的。因此，你的函數對象必須儘可能的小，否則拷貝的開銷會很大；其次，函數對象必須是單態的，也就是說，它們不得使用虛函數。這是因為，如果參數的類型是基類類型，而實參是派生類對象，那麼在傳遞過程中會產生剝離問題（slicing problem）：在對象拷貝過程中，派生部分可能會被去掉，而僅保留了基類部分（見第3條）。</p><p>試圖禁止多態的函數子同樣也是不實際的。所以必須找到一種兩全其美的辦法，既允許函數對象可以很大並且／或保留多態性，又可以與STL所採用的按值傳遞函數子的習慣保持一致。這個辦法就是：將所需要的數據和虛函數從函數子中分離出來，放到一個新的類中，然後在函數子中設一個指針，指向這個新類。</p><h1>第39條：確保判別式是“純函數”。</h1><p>一個判別式（predicate）是一個返回值為bool類型的函數。一個純函數（pure function）是指返回值僅僅依賴於其參數的函數。</p><p>因為接受函數子的STL算法可能會先創建函數子對象的拷貝，然後使用這個拷貝，因此這一特性的直接反映就是判別式函數必須是純函數。</p><p>template&lt;typename FwdIterator,typename Predicata></p><p>FwdIterator remove_if(FwdIterator begin, FwdIterator end, Predicate p)</p><p>{</p><p>begin = find_if(begin, end, p);//可能是p的拷貝</p><p>if(begin == end return begin;</p><p>else{</p><p>FwdIterator next = begin;</p><p>return remove_copy_if(++next, end, begin, p);//可能是p的另一個拷貝</p><p>}</p><p>}</p><h1>第40條：若一個類是函數子，則應使它可配接。</h1><p>4個標準的函數配接器(not1、not2、bind1st和bind2nd）都要求一些特殊的類型定義。提供了這些必要的類型定義（argument_type、first_argument_type、second_argument_type以及result_type）的函數對象被稱為可配接的（adaptable）函數對象，反之，如果函數對象缺少這些類型定義，則稱為不可配接的。可配接的函數對象能夠與其他STL組件更為默契地協同工作。不過不同種類的函數子類所需要提供的類型定義也不盡相同，除非你要編寫自定義的配接器，否則你並不需要知道有關這些類型定義的細節。這是因為，提供這些類型定義最簡便的辦法是讓函數子從特定的基類繼承，或者更準確的說，如果函數子類的operator()只有一個形參，那麼它應該從 std::unary_function模板的一個實例繼承；如果函數子類的operator()有兩個形參，那麼它應該從std:: binary_function繼承。</p><p>對於unary_function，你必須指定函數子類operator()所帶的參數的類型，以及返回類型；對於binary_function，你必須指定三個類型：operator()的第一個和第二個參數的類型，以及operator()的返回類型。以下是兩個例子：</p><p>template&lt;typename T></p><p>class MeetsThreshold: public std::unary_function&lt;Widget, bool> {</p><p>private:</p><p>const T threshold;</p><p>public:</p><p>MeetsThreshold(const T& threshold);</p><p>bool operator()(const Widget&) const;</p><p>...</p><p>};</p><p>struct WidgetNameCompare:</p><p>public std::binary_function&lt;Widget, Widget, bool> {</p><p>bool operator() (const Widget& lhs, const Widget& rhs) const;</p><p>};</p><p>你可能已經注意到MeetsThreshold是一個類，而WidgetNameCompare是一個結構。這是因為MeetsThreshold包含了狀態信息（數據成員threshold），而類是封裝狀態信息的一種邏輯方式；與此相反，WidgetNameCompare並不包含狀態信息，因而不需要任何私有成員。如果一個函數子的所有成員都是公有的，那麼通常會將其聲明為結構而不是類。究竟是選擇結構還是類來定義函數子純屬個人編碼風格，但是如果你正在改進自己的編碼風格，並希望自己的風格更加專業一點的話，你就應該注意到，STL中所有無狀態的函數子類（如less&lt;T>、 plus&lt;T>等）一般都定義成結構。</p><p>我們在看一下WidgetNameCompare：</p><p>struct WidgetNameCompare:</p><p>public std::binary_function&lt;Widget, Widget, bool> {</p><p>bool operator() (const Widget& lhs, const Widget& rhs) const;</p><p>};</p><p>雖然operator()的參數類型都是const Widget&，但我們傳遞給binary_function的類型卻是Widget。一般情況下，傳遞給unary_function或 binary_function的非指針類型需要去掉const和引用（&）部分（不要問其中的原因，如果你有興趣，可以訪問 boost.org，卡可能看他們在調用特性(traits)和函數對象配接器方面的工作）。</p><p>如果operator()帶有指針參數，規則又有不同了。下面是WidgetNameCOmpare函數子的另一個版本，所不同的是，這次以Widget*指針作為參數：</p><p>struct PtrWidgetNameCompare:</p><p>public std::binary_function&lt;const Widget*, const Widget*, bool> {</p><p>bool operator() (const Widget* lhs, const Widget* rhs) const;</p><p>};</p><h1>第41條：理解ptr_fun、mem_fun和mem_fun_ref的來由。</h1><p>如果有一個函數f和一個對象x，現在希望在x上調用f，而我們在x的成員函數之外，那麼為了執行這個調用，C＋＋提供了三種不同的語法：</p><p>f(x); //語法#1：f是一個非成員函數</p><p>x.f(); //語法#2：f是一個成員函數，並且x是一個對象或一個對象引用</p><p>p->f(); //語法#3：f是成員函數，並且p是一個指向對象x的指針</p><p>現在假設有個可用於測試Widget對象的函數：</p><p>void test(Widget& w);</p><p>另有一個存放Widget對象的容器：</p><p>vector&lt;Widget> vw;</p><p>為了測試vw中的每一個Widget對象，自然可以用如下的方式來調用for_each：</p><p>for_each(vw.begin(), vw.end(), test); //調用#1 (可以通過編譯)</p><p>但是，加入test是Widget的成員函數，即Widget支持自測：</p><p>class Widget{</p><p>public:</p><p>...</p><p>void test();</p><p>....</p><p>};</p><p>那麼在理想情況下，應該也可以用for_each在vw中的每個對象上調用Widget::test成員函數：</p><p>for_each(vw.begin(), vw.end(), &Widget::test);//調用#2（不能通過編譯）</p><p>實際上，如果真的很理想的話，那麼對於一個存放Widget* 指針的容器，應該也可以通過for_each來調用Widget::test：</p><p>list&lt;Widget*> lpw;</p><p>for_each(lpw.begin(), lpw.end(), &Widget::test);//調用#3（也不能通過編譯）</p><p>這是因為STL中一種和普遍的慣例：函數或函數對象在被調用的時候，總是使用非成員函數的語法形式（即#1）。</p><p>現在mem_fun和mem_fun_ref之所以必須存在已經很清楚了－－它們被用來調整（一般是#2和#3）成員函數，使之能夠通過語法#1被調用。 mem_fun、mem_fun_ref的做法其實很簡單，只要看一看其中任意一個函數的聲明就清楚了。它們是真正的函數模板，針對它們所配接的成員函數的圓形的不同，有幾種變化形式。我們來看其中一個聲明，以便了解它是如何工作的：</p><p>template&lt;typename R, typename C> //該mem_fun聲明針對不帶參數的非const成員函數，C是類，R是所指向的成員函數的返回類型</p><p>mem_fun_t&lt;R,C></p><p>mem_fun(R(C::*pmf) ());</p><p>mem_fun帶一個指向某個成員函數的指針參數pmf，並且返回一個mem_fun_t類型的對象。mem_fun_t是一個函數子類，它擁有該成員函數的指針，並提供了operator()函數，在operator()中調用了通過參數傳遞進來的對象上的該成員函數。例如，請看下面一段代碼：</p><p>list&lt;Widget*> lpw;</p><p>...</p><p>for_each(lpw.begin(),lpw.end(),mem_fun(&Widget::test));//現在可以通過編譯了</p><p>for_each接受到一個類型為mem_fun_t的對象，該對象中保存了一個指向Widget::test的指針。對於lpw中的每一個 Widget*指針，for_each將會使用語法#1來調用mem_fun_t對象，然後，該對象立即用語法#3調用Widget*指針的 Widget::test()。</p><p>（ptr_fun是多餘的嗎？）mem_fun是針對成員函數的配接器，mem_fun_ref是針對對象容器的配接器。</p><h1>第42條：確保less&lt;T>與operator&lt;具有相同的含義。</h1><p>operator&lt;不僅僅是less的默認實現方式，它也是程序員期望less所做的事情。讓less不調用operator&lt;而去坐別的事情，這會無端地違背程序員的意願，這與“少”帶給人驚奇的原則（the principle of least astonishment）完全背道而馳。這是很不好的，你應該儘量避免這樣做。</p><p>如果你希望以一種特殊的方式來排序對象，那麼最好創建一個特殊的函數子類，它的名字不能是less。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>C++</a></li><li><a>選用</a></li><li><a>總結</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html alt=從域名到網站，只需要四步！服務器網站搭建流程總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7c1999b5072844f6ac01ba234e4d4ee0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html title=從域名到網站，只需要四步！服務器網站搭建流程總結>從域名到網站，只需要四步！服務器網站搭建流程總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9a22b29b.html alt=鋼結構用鋼的種類及如何選用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/491be59f-9e0e-4f58-8570-7f1eaa951bdf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9a22b29b.html title=鋼結構用鋼的種類及如何選用>鋼結構用鋼的種類及如何選用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html alt=住宅工程各區域的淨高要求，總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/072079da-ec32-43b6-9dff-93cc7beb2bc3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html title=住宅工程各區域的淨高要求，總結>住宅工程各區域的淨高要求，總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html alt=住宅工程各區域的淨高要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/27a44170db2040adab26236e40605b1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html title=住宅工程各區域的淨高要求，總結！>住宅工程各區域的淨高要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html alt=初三主要化學方程式按元素歸類總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fcca062886ed4b9db272cb3cb66710e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html title=初三主要化學方程式按元素歸類總結>初三主要化學方程式按元素歸類總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html alt=按照元素分類總結的高中化學方程式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/568b4c62f05c406c86ba3a1a3f1536f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html title=按照元素分類總結的高中化學方程式>按照元素分類總結的高中化學方程式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d1995c0.html alt=丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/164632567d364099b1944122af1964e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d1995c0.html title=丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級>丙烯上下游產業鏈季度總結（2020年第1季度）2季度壓力可能升級</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96e7d436.html alt="這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96e7d436.html title="這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏">這樣總結隧道Tunnel技術工作原理更容易記住 網絡工程師收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02f4a700.html alt=牛人總結的開關電源電路圖，必須收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rw0LHkF478R1Ah style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02f4a700.html title=牛人總結的開關電源電路圖，必須收藏>牛人總結的開關電源電路圖，必須收藏</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>