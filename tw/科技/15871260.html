<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一篇文章搞定Python線程模塊thread與threading | 极客快訊</title><meta property="og:title" content="一篇文章搞定Python線程模塊thread與threading - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/a56af7c26ba74730ad3172c8f89cc824"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15871260.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15871260.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15871260.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15871260.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15871260.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15871260.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15871260.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15871260.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="一篇文章搞定Python線程模塊thread與threading"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/15871260.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一篇文章搞定Python線程模塊thread與threading</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>關於模塊選擇</h1><p>　　Python提供了幾個用於多線程編程的模塊，包括thread、threading和Queue等。thread和threading模塊允許程序員創建和管理線程。thread模塊提供了基本的線程和鎖的支持，threading提供了更高級別、功能更強的線程管理的功能。Queue模塊允許用戶創建一個可以用於多個線程之間共享數據的隊列數據結構。　　避免使用thread模塊，因為更高級別的threading模塊更為先進，對線程的支持更為完善，而且使用thread模塊裡的屬性有可能會與threading出現衝突；其次低級別的thread模塊的同步原語很少(實際上只有一個)，而threading模塊則有很多；再者，thread模塊中當主線程結束時，所有的線程都會被強制結束掉，沒有警告也不會有正常的清除工作，至少threading模塊能確保重要的子線程退出後進程才退出。</p><p>　　thread模塊不支持守護線程，當主線程退出時，所有的子線程不論它們是否還在工作，都會被強行退出。而threading模塊支持守護線程，守護線程一般是一個等待客戶請求的服務器，如果沒有客戶提出請求它就在那等著，如果設定一個線程為守護線程，就表示這個線程是不重要的，在進程退出的時候，不用等待這個線程退出。</p><h1 class=pgc-h-arrow-right>threading模塊</h1><p><strong>多線程啟動</strong></p><pre><code># 多線程啟動import osimport timefrom threading import Threaddef func():    time.sleep(1)    print('hello 線程', os.getpid())t = Thread(target=func)t.start()print(os.getpid())# 結果# 6360# hello 線程 6360</code></pre><p><strong>同步開啟多線程</strong></p><pre><code># 同步開啟多線程import osimport timefrom threading import Threaddef func():    time.sleep(1)    print('hello 線程', os.getpid())thread_l = []for i in range(10):    t = Thread(target=func)    t.start()    thread_l.append(t)for j in thread_l:    j.join()print(os.getpid())</code></pre><p><strong>開啟線程的另一種方法</strong></p><pre><code># 開啟線程的另一種方法import osimport timefrom threading import Threadclass My_thread(Thread):    def run(self):        time.sleep(1)        print('hello 線程', os.getpid())thread_l = []for i in range(10):    t = My_thread()    t.start()    thread_l.append(t)for j in thread_l:    j.join()print(os.getpid())</code></pre><p><strong>以類的方式開啟進程中的注意彙總</strong></p><pre><code># 以類的方式開啟進程中的注意彙總import osimport timefrom threading import Threadclass My_thread(Thread):    count = 0  # 進程中的靜態屬性是共享的  計算調用線程的次數    def __init__(self, arg):  # 傳參方法        super().__init__()  # 繼承父類的init方法        self.arg = arg    def run(self):        My_thread.count += 1        time.sleep(1)        print('%s,%s' % (self.arg, os.getpid()))thread_l = []for i in range(10):    t = My_thread(i, )    t.start()    thread_l.append(t)for j in thread_l:    j.join()print(t.count)</code></pre><p><strong>self.name獲取線程名字</strong></p><pre><code># self.name獲取線程名字import osimport timefrom threading import Threadclass My_thread(Thread):    count = 0  # 進程中的靜態屬性是共享的  計算調用線程的次數    def __init__(self, arg):  # 傳參方法        super().__init__()  # 繼承父類的init方法        self.arg = arg    def run(self):        My_thread.count += 1        time.sleep(1)        print('%s,%s,%s' % (self.arg, self.name, os.getpid()))thread_l = []for i in range(10):    t = My_thread(i, )    t.start()    thread_l.append(t)for j in thread_l:    j.join()print(t.count)# 結果# 4,Thread-5,6284# 3,Thread-4,6284# 2,Thread-3,6284# 1,Thread-2,6284# 0,Thread-1,6284# 9,Thread-10,6284# 8,Thread-9,6284# 6,Thread-7,6284# 7,Thread-8,6284# 5,Thread-6,6284# 10</code></pre><p><strong>線程周邊</strong></p><pre><code># 線程周邊import timeimport threadingdef func(i):    time.sleep(0.5)    print(i, threading.currentThread().name, threading.currentThread().ident)#     ident  線程idfor i in range(10):    t = threading.Thread(target=func, args=(i, ))    t.start()print(threading.enumerate())  # 返回正在運行著的線程列表print(len(threading.enumerate()))  # 打印線程數量print(threading.activeCount())  # 記錄活著的線程數量# 結果# [&lt;_MainThread(MainThread, started 9004)&gt;, &lt;Thread(Thread-1, started 18804)&gt;, &lt;Thread(Thread-2, started 4892)&gt;, &lt;Thread(Thread-3, started 12760)&gt;, &lt;Thread(Thread-4, started 22276)&gt;, &lt;Thread(Thread-5, started 20732)&gt;, &lt;Thread(Thread-6, started 19072)&gt;, &lt;Thread(Thread-7, started 17020)&gt;, &lt;Thread(Thread-8, started 22228)&gt;, &lt;Thread(Thread-9, started 22252)&gt;, &lt;Thread(Thread-10, started 22280)&gt;]# 11# 11# 0 Thread-1 18804# 1 Thread-2 4892# 3 Thread-4 22276# 4 Thread-5 20732# 2 Thread-3 12760# 8 Thread-9 22252# 9 Thread-10 22280# 7 Thread-8 22228# 6 Thread-7 17020# 5 Thread-6 19072</code></pre><p><strong>socket啟動多線程</strong></p><pre><code># socket啟動多線程# client端import socketsk = socket.socket()sk.connect(('127.0.0.1', 8080))ret = sk.recv()print(ret)msg = input('&gt;&gt;&gt;')sk.send(msg.encode('utf-8'))sk.close()# server端import socketfrom threading import Threaddef func(conn):    conn.send(b'hello')    ret = conn.recv(1024)    print(ret)    conn.close()sk = socket.socket()sk.bind(('127.0.0.1', 8080))sk.listen()while True:    conn, addr = sk.accept()    Thread(target=func, args=(conn, )).start()sk.close()</code></pre><h1 class=pgc-h-arrow-right>守護線程</h1><pre><code># 守護進程import timefrom threading import Threaddef func():    print('開始執行子線程')    time.sleep(2)    print('子線程執行結束')t = Thread(target=func)t.setDaemon(True)  # 進程設置守護進程 是屬性 daemon = Truet.start()t2 = Thread(target=func)t2.start()t2.join()  # 等待t2結束  \\  t2執行完畢 主線程結束# 注意# 守護線程 守護進程 都是等待主進程或主線程中的代碼 執行完畢# 結果# 開始執行子線程# 開始執行子線程# 子線程執行結束# 子線程執行結束</code></pre><h1 class=pgc-h-arrow-right>互斥Lock與遞歸鎖RLock</h1><p><strong>鎖的使用</strong></p><pre><code># 鎖import timefrom threading import Threadfrom threading import Lockdef func():    global n    lock.acquire()    temp = n  # 從進程中獲取n    time.sleep(0.01)    n = temp-1  # 得到結果再存儲回進程    lock.release()n = 100lock = Lock()t_lis = []for i in range(100):    t = Thread(target=func)    t.start()    t_lis.append(t)[t.join() for t in t_lis]print(n)</code></pre><p><strong class=highlight-text>PS：GIL 不是鎖數據，而是鎖線程</strong></p><p><strong class=highlight-text>在多線程中，特殊情況，仍要加鎖，對數據加鎖（具體見鎖得使用）</strong></p><p><strong>互斥鎖與join的區別</strong></p><pre><code>#不加鎖:併發執行,速度快,數據不安全from threading import current_thread,Thread,Lockimport os,timedef task():    global n    print('%s is running' %current_thread().getName())    temp=n    time.sleep(0.5)    n=temp-1if __name__ == '__main__':    n=100    lock=Lock()    threads=[]    start_time=time.time()    for i in range(100):        t=Thread(target=task)        threads.append(t)        t.start()    for t in threads:        t.join()    stop_time=time.time()    print('主:%s n:%s' %(stop_time-start_time,n))'''Thread-1 is runningThread-2 is running......Thread-100 is running主:0.5216062068939209 n:99'''#不加鎖:未加鎖部分併發執行,加鎖部分串行執行,速度慢,數據安全from threading import current_thread,Thread,Lockimport os,timedef task():    #未加鎖的代碼併發運行    time.sleep(3)    print('%s start to run' %current_thread().getName())    global n    #加鎖的代碼串行運行    lock.acquire()    temp=n    time.sleep(0.5)    n=temp-1    lock.release()if __name__ == '__main__':    n=100    lock=Lock()    threads=[]    start_time=time.time()    for i in range(100):        t=Thread(target=task)        threads.append(t)        t.start()    for t in threads:        t.join()    stop_time=time.time()    print('主:%s n:%s' %(stop_time-start_time,n))'''Thread-1 is runningThread-2 is running......Thread-100 is running主:53.294203758239746 n:0'''#既然加鎖會讓運行變成串行,那麼我在start之後立即使用join,就不用加鎖了啊,也是串行的效果啊#沒錯:在start之後立刻使用jion,肯定會將100個任務的執行變成串行,毫無疑問,最終n的結果也肯定是0,是安全的,但問題是#start後立即join:任務內的所有代碼都是串行執行的,而加鎖,只是加鎖的部分即修改共享數據的部分是串行的#單從保證數據安全方面,二者都可以實現,但很明顯是加鎖的效率更高.from threading import current_thread,Thread,Lockimport os,timedef task():    time.sleep(3)    print('%s start to run' %current_thread().getName())    global n    temp=n    time.sleep(0.5)    n=temp-1if __name__ == '__main__':    n=100    lock=Lock()    start_time=time.time()    for i in range(100):        t=Thread(target=task)        t.start()        t.join()    stop_time=time.time()    print('主:%s n:%s' %(stop_time-start_time,n))'''Thread-1 start to runThread-2 start to run......Thread-100 start to run主:350.6937336921692 n:0 #耗時是多麼的恐怖'''</code></pre><h1 class=pgc-h-arrow-right>死鎖與遞歸鎖</h1><p>進程也有死鎖與遞歸鎖，在進程那裡忘記說了，放到這裡一切說了額</p><p>　　所謂死鎖： 是指兩個或兩個以上的進程或線程在執行過程中，因爭奪資源而造成的一種互相等待的現象，若無外力作用，它們都將無法推進下去。此時稱系統處於死鎖狀態或系統產生了死鎖，這些永遠在互相等待的進程稱為死鎖進程，如下就是死鎖</p><p><strong>死鎖</strong></p><pre><code>死鎖from threading import Lock as Lockimport timemutexA=Lock()mutexA.acquire()mutexA.acquire()print(123)mutexA.release()mutexA.release()</code></pre><p>　　解決方法，遞歸鎖，在Python中為了支持在同一線程中多次請求同一資源，python提供了可重入鎖RLock。</p><p>　　這個RLock內部維護著一個Lock和一個counter變量，counter記錄了acquire的次數，從而使得資源可以被多次require。直到一個線程所有的acquire都被release，其他的線程才能獲得資源。上面的例子如果使用RLock代替Lock，則不會發生死鎖</p><p><strong>遞歸鎖RLock</strong></p><pre><code>from threading import RLock as Lockimport timemutexA=Lock()mutexA.acquire()mutexA.acquire()print(123)mutexA.release()mutexA.release()</code></pre><p><strong>遞歸鎖解決死鎖問題</strong></p><pre><code>import timefrom threading import Thread,RLockfork_lock = noodle_lock = RLock()def eat1(name):    noodle_lock.acquire()    print('%s 搶到了麵條'%name)    fork_lock.acquire()    print('%s 搶到了叉子'%name)    print('%s 吃麵'%name)    fork_lock.release()    noodle_lock.release()def eat2(name):    fork_lock.acquire()    print('%s 搶到了叉子' % name)    time.sleep(1)    noodle_lock.acquire()    print('%s 搶到了麵條' % name)    print('%s 吃麵' % name)    noodle_lock.release()    fork_lock.release()for name in ['哪吒','egon','yuan']:    t1 = Thread(target=eat1,args=(name,))    t2 = Thread(target=eat2,args=(name,))    t1.start()    t2.start()</code></pre><h1 class=pgc-h-arrow-right>信號量</h1><p>同進程的一樣</p><p>Semaphore管理一個內置的計數器，</p><p>每當調用acquire()時內置計數器-1；</p><p>調用release() 時內置計數器+1；</p><p>計數器不能小於0；當計數器為0時，acquire()將阻塞線程直到其他線程調用release()。</p><p>實例：(同時只有5個線程可以獲得semaphore,即可以限制最大連接數為5)：</p><pre><code>from threading import Thread,Semaphoreimport threadingimport time# def func():#     if sm.acquire():#         print (threading.currentThread().getName() + ' get semaphore')#         time.sleep(2)#         sm.release()def func():    sm.acquire()    print('%s get sm' %threading.current_thread().getName())    time.sleep(3)    sm.release()if __name__ == '__main__':    sm=Semaphore(5)    for i in range(23):        t=Thread(target=func)        t.start()</code></pre><p>與進程池是完全不同的概念，進程池Pool(4)，最大隻能產生4個進程，而且從頭到尾都只是這四個進程，不會產生新的，而信號量是產生一堆線程/進程</p><h1 class=pgc-h-arrow-right>事件</h1><p>　　同進程的一樣</p><p>　　線程的一個關鍵特性是每個線程都是獨立運行且狀態不可預測。如果程序中的其 他線程需要通過判斷某個線程的狀態來確定自己下一步的操作,這時線程同步問題就會變得非常棘手。為了解決這些問題,我們需要使用threading庫中的Event對象。 對象包含一個可由線程設置的信號標誌,它允許線程等待某些事件的發生。在 初始情況下,Event對象中的信號標誌被設置為假。如果有線程等待一個Event對象, 而這個Event對象的標誌為假,那麼這個線程將會被一直阻塞直至該標誌為真。一個線程如果將一個Event對象的信號標誌設置為真,它將喚醒所有等待這個Event對象的線程。如果一個線程等待一個已經被設置為真的Event對象,那麼它將忽略這個事件, 繼續執行</p><pre><code>event.isSet()：返回event的狀態值；event.wait()：如果 event.isSet()==False將阻塞線程；event.set()： 設置event的狀態值為True，所有阻塞池的線程激活進入就緒狀態， 等待操作系統調度；event.clear()：恢復event的狀態值為False。</code></pre><p><br></p><div class=pgc-img><img alt=一篇文章搞定Python線程模塊thread與threading onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a56af7c26ba74730ad3172c8f89cc824><p class=pgc-img-caption></p></div><p><br></p><p>例如，有多個工作線程嘗試連接MySQL，我們想要在連接前確保MySQL服務正常才讓那些工作線程去連接MySQL服務器，如果連接不成功，都會去嘗試重新連接。那麼我們就可以採用threading.Event機制來協調各個工作線程的連接操作</p><pre><code>import threadingimport time,randomfrom threading import Thread,Eventdef conn_mysql():    count=1    while not event.is_set():        if count &gt; 3:            raise TimeoutError('鏈接超時')        print('&lt;%s&gt;第%s次嘗試鏈接' % (threading.current_thread().getName(), count))        event.wait(0.5)        count+=1    print('&lt;%s&gt;鏈接成功' %threading.current_thread().getName())def check_mysql():    print('\033[45m[%s]正在檢查mysql\033[0m' % threading.current_thread().getName())    time.sleep(random.randint(2,4))    event.set()if __name__ == '__main__':    event=Event()    conn1=Thread(target=conn_mysql)    conn2=Thread(target=conn_mysql)    check=Thread(target=check_mysql)    conn1.start()    conn2.start()    check.start()</code></pre><h1 class=pgc-h-arrow-right>條件</h1><p>使得線程等待，只有滿足某條件時，才釋放n個線程</p><p><strong>說明</strong></p><p>Python提供的Condition對象提供了對複雜線程同步問題的支持。Condition被稱為條件變量，除了提供與Lock類似的acquire和release方法外，還提供了wait和notify方法。線程首先acquire一個條件變量，然後判斷一些條件。如果條件不滿足則wait；如果條件滿足，進行一些處理改變條件後，通過notify方法通知其他線程，其他處於wait狀態的線程接到通知後會重新判斷條件。不斷的重複這一過程，從而解決複雜的同步問題。</p><p><strong>實例</strong></p><pre><code>import threadingdef run(n):    con.acquire()    con.wait()    print("run the thread: %s" % n)    con.release()if __name__ == '__main__':    con = threading.Condition()    for i in range(10):        t = threading.Thread(target=run, args=(i,))        t.start()    while True:        inp = input('&gt;&gt;&gt;')        if inp == 'q':            break        con.acquire()        con.notify(int(inp))        con.release()        print('****')</code></pre><h1 class=pgc-h-arrow-right>定時器</h1><p>定時器，指定n秒後執行某個操作</p><pre><code>from threading import Timer def hello():    print("hello, world") t = Timer(1, hello)t.start()  # after 1 seconds, "hello, world" will be printed</code></pre><h1 class=pgc-h-arrow-right>線程隊列</h1><p>queue隊列 ：使用import queue，用法與進程Queue一樣</p><p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p><p><strong>class queue.Queue(maxsize=0) #先進先出</strong></p><pre><code>import queueq=queue.Queue()q.put('first')q.put('second')q.put('third')print(q.get())print(q.get())print(q.get())'''結果(先進先出):firstsecondthird'''</code></pre><p><strong>class queue.LifoQueue(maxsize=0) #後進先出</strong></p><pre><code>import queueq=queue.LifoQueue()q.put('first')q.put('second')q.put('third')print(q.get())print(q.get())print(q.get())'''結果(後進先出):thirdsecondfirst'''</code></pre><p><strong>class queue.PriorityQueue(maxsize=0) #存儲數據時可設置優先級的隊列</strong></p><p><strong>優先級隊列</strong></p><pre><code>import queueq=queue.PriorityQueue()#put進入一個元組,元組的第一個元素是優先級(通常是數字,也可以是非數字之間的比較),數字越小優先級越高q.put((20,'a'))q.put((10,'b'))q.put((30,'c'))print(q.get())print(q.get())print(q.get())'''結果(數字越小優先級越高,優先級高的優先出隊):(10, 'b')(20, 'a')(30, 'c')'''</code></pre><p><strong>更多方法說明</strong></p><pre><code>Constructor for a priority queue. maxsize is an integer that sets the upperbound limit on the number of items that can be placed in the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize is less than or equal to zero, the queue size is infinite.The lowest valued entries are retrieved first (the lowest valued entry is the one returned by sorted(list(entries))[0]). A typical pattern for entries is a tuple in the form: (priority_number, data).exception queue.EmptyException raised when non-blocking get() (or get_nowait()) is called on a Queue object which is empty.exception queue.FullException raised when non-blocking put() (or put_nowait()) is called on a Queue object which is full.Queue.qsize()Queue.empty() #return True if empty  Queue.full() # return True if full Queue.put(item, block=True, timeout=None)Put item into the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case).Queue.put_nowait(item)Equivalent to put(item, False).Queue.get(block=True, timeout=None)Remove and return an item from the queue. If optional args block is true and timeout is None (the default), block if necessary until an item is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. Otherwise (block is false), return an item if one is immediately available, else raise the Empty exception (timeout is ignored in that case).Queue.get_nowait()Equivalent to get(False).Two methods are offered to support tracking whether enqueued tasks have been fully processed by daemon consumer threads.Queue.task_done()Indicate that a formerly enqueued task is complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task is complete.If a join() is currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received for every item that had been put() into the queue).Raises a ValueError if called more times than there were items placed in the queue.Queue.join() block直到queue被消費完畢</code></pre><h1 class=pgc-h-arrow-right>Python標準模塊--concurrent.futures</h1><pre><code>#1 介紹concurrent.futures模塊提供了高度封裝的異步調用接口ThreadPoolExecutor：線程池，提供異步調用ProcessPoolExecutor: 進程池，提供異步調用Both implement the same interface, which is defined by the abstract Executor class.#2 基本方法#submit(fn, *args, **kwargs)異步提交任務#map(func, *iterables, timeout=None, chunksize=1) 取代for循環submit的操作#shutdown(wait=True) 相當於進程池的pool.close()+pool.join()操作wait=True，等待池內所有任務執行完畢回收完資源後才繼續wait=False，立即返回，並不會等待池內的任務執行完畢但不管wait參數為何值，整個程序都會等到所有任務執行完畢submit和map必須在shutdown之前#result(timeout=None)取得結果#add_done_callback(fn)回調函數</code></pre><p><strong>ProcessPoolExecutor</strong></p><pre><code>#介紹The ProcessPoolExecutor class is an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed and returned.class concurrent.futures.ProcessPoolExecutor(max_workers=None, mp_context=None)An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers is None or not given, it will default to the number of processors on the machine. If max_workers is lower or equal to 0, then a ValueError will be raised.#用法from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport os,time,randomdef task(n):    print('%s is runing' %os.getpid())    time.sleep(random.randint(1,3))    return n**2if __name__ == '__main__':    executor=ProcessPoolExecutor(max_workers=3)    futures=[]    for i in range(11):        future=executor.submit(task,i)        futures.append(future)    executor.shutdown(True)    print('+++&gt;')    for future in futures:        print(future.result())</code></pre><p><strong>ThreadPoolExecutor</strong></p><pre><code>#介紹ThreadPoolExecutor is an Executor subclass that uses a pool of threads to execute calls asynchronously.class concurrent.futures.ThreadPoolExecutor(max_workers=None, thread_name_prefix='')An Executor subclass that uses a pool of at most max_workers threads to execute calls asynchronously.Changed in version 3.5: If max_workers is None or not given, it will default to the number of processors on the machine, multiplied by 5, assuming that ThreadPoolExecutor is often used to overlap I/O instead of CPU work and the number of workers should be higher than the number of workers for ProcessPoolExecutor.New in version 3.6: The thread_name_prefix argument was added to allow users to control the threading.Thread names for worker threads created by the pool for easier debugging.#用法與ProcessPoolExecutor相同</code></pre><p><strong>map的用法</strong></p><pre><code>from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorimport os,time,randomdef task(n):    print('%s is runing' %os.getpid())    time.sleep(random.randint(1,3))    return n**2if __name__ == '__main__':    executor=ThreadPoolExecutor(max_workers=3)    # for i in range(11):    #     future=executor.submit(task,i)    executor.map(task,range(1,12)) #map取代了for+submit</code></pre><p><strong>回調函數</strong></p><pre><code>from concurrent.futures import ThreadPoolExecutor,ProcessPoolExecutorfrom multiprocessing import Poolimport requestsimport jsonimport osdef get_page(url):    print('&lt;進程%s&gt; get %s' %(os.getpid(),url))    respone=requests.get(url)    if respone.status_code == 200:        return {'url':url,'text':respone.text}def parse_page(res):    res=res.result()    print('&lt;進程%s&gt; parse %s' %(os.getpid(),res['url']))    parse_res='url:&lt;%s&gt; size:[%s]\n' %(res['url'],len(res['text']))    with open('db.txt','a') as f:        f.write(parse_res)if __name__ == '__main__':    urls=[        'https://www.baidu.com',        'https://www.python.org',        'https://www.openstack.org',        'https://help.github.com/',        'http://www.sina.com.cn/'    ]    # p=Pool(3)    # for url in urls:    #     p.apply_async(get_page,args=(url,),callback=pasrse_page)    # p.close()    # p.join()    p=ProcessPoolExecutor(3)    for url in urls:        p.submit(get_page,url).add_done_callback(parse_page) #parse_page拿到的是一個future對象obj，需要用obj.result()拿到結果</code></pre><p><a class=tteditor-forum data-concern-id=6588565913220418055 data-id=1608536599803912 data-name=計算機 data-uid>#計算機#</a><a class=tteditor-forum data-concern-id=6591605976862820867 data-id=1609278802827335 data-name=python data-uid>#python#</a><a class=tteditor-forum data-concern-id=1642457486431287 data-id=1642457486431287 data-name=Python基礎 data-uid>#Python基礎#</a><a class=tteditor-forum data-concern-id=6213187417604622850 data-id=4457388390 data-name=互聯網 data-uid>#互聯網#</a><a class=tteditor-forum data-concern-id=1662231535517703 data-id=1662231535517703 data-name=科技新星創作營 data-uid>#科技新星創作營#</a></p><div class=pgc-img><img alt=一篇文章搞定Python線程模塊thread與threading onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/958cb032-50b7-4cef-b87d-95cf24c4907f><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=一篇文章搞定Python線程模塊thread與threading onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/2912625f-5572-48c2-8492-6f5c8c3bff04><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=一篇文章搞定Python線程模塊thread與threading onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/96b9639e-21a8-4021-8270-a1098f9c7a00><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Python</a></li><li><a>線程</a></li><li><a>模塊</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html alt="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/25f231d6-c1ce-4cf8-8988-5da509a0c26a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b433c17e.html title="四十、Python模塊random: 偽隨機數據生成與隨機元素抽取">四十、Python模塊random: 偽隨機數據生成與隨機元素抽取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e59d8e0.html alt=Python文件目錄和系統操作，os模塊和os.path模塊 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a1f75661941c426cbff49d38321ac188 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e59d8e0.html title=Python文件目錄和系統操作，os模塊和os.path模塊>Python文件目錄和系統操作，os模塊和os.path模塊</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/46023614.html alt=Python炫技操作：模塊重載的五種方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RqSgmP9HojtMNK style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/46023614.html title=Python炫技操作：模塊重載的五種方法>Python炫技操作：模塊重載的五種方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ddd5b99.html alt=Python模塊進階、標準庫、擴展庫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13e8cacbcb05440c90f4c572f244763d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ddd5b99.html title=Python模塊進階、標準庫、擴展庫>Python模塊進階、標準庫、擴展庫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d5ed9b10.html alt=掌上生活APP：積分模塊設計分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rj5TAZoAjFz5G2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d5ed9b10.html title=掌上生活APP：積分模塊設計分析>掌上生活APP：積分模塊設計分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html alt=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e11e69f643584941aaa2b71ee6ed3d7f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04486eba.html title=Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）>Python爬蟲使用selenium爬取群成員信息（全自動實現自動登陸）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html alt=Python爬蟲教程，利用Python採集QQ群成員信息 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d6cce76ad48405c9dbb960d4617bcef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/86b46e6d.html title=Python爬蟲教程，利用Python採集QQ群成員信息>Python爬蟲教程，利用Python採集QQ群成員信息</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html alt=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5d4a0000046e1bea8b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7739dc7a.html title=Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？>Python數據可視化Matplotlib，如何在一副圖像中顯示多組柱形圖？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html alt="PHP 線程，進程和併發" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7a700a857098411d884a928d6b5f5e01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html title="PHP 線程，進程和併發">PHP 線程，進程和併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html alt=Python中的多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/49dd44b999924b69bd3396709ecacaf4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/05b8f164.html title=Python中的多進程>Python中的多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html alt=一文讀懂什麼是進程、線程、協程（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6ba8b142-925e-418e-b20c-71e8f3c20663 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html title=一文讀懂什麼是進程、線程、協程（建議收藏）>一文讀懂什麼是進程、線程、協程（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html alt=併發最基本要理解的進程、線程、協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f756a3627164d4f93883dd7c0e0bac5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html title=併發最基本要理解的進程、線程、協程>併發最基本要理解的進程、線程、協程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>