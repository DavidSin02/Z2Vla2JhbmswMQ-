<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一定能看懂的RocketMQ事務消息源碼介紹(乾貨) | 极客快訊</title><meta property="og:title" content="一定能看懂的RocketMQ事務消息源碼介紹(乾貨) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9893da5524c1439f8a11cb24322c57a9"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15b0178.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/15b0178.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/15b0178.html><meta property="article:published_time" content="2020-10-29T20:50:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:42+08:00"><meta name=Keywords content><meta name=description content="一定能看懂的RocketMQ事務消息源碼介紹(乾貨)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/15b0178.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一定能看懂的RocketMQ事務消息源碼介紹(乾貨)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>前言</strong></h1><p>得益於MQ削峰填谷，系統解耦，操作異步等功能特性，在互聯網行業，可以說有分佈式服務的地方，MQ都往往不會缺席。由阿里自研的RocketMQ更是經歷了多年的雙十一高併發挑戰，其中4.3.0版本推出了事務消息的新特性，本文對RocketMQ 4.5.0版本事務消息相關的源碼跟蹤介紹，通過閱讀讀者可以知道：</p><ul><li>事務消息解決什麼樣的問題</li><li>事務消息的實現原理及其設計亮點</li></ul><div class=pgc-img><img alt=一定能看懂的RocketMQ事務消息源碼介紹(乾貨) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9893da5524c1439f8a11cb24322c57a9><p class=pgc-img-caption>RocketMQ</p></div><h1><strong>解決什麼問題</strong></h1><p>假設我所在的系統現在有這樣一個場景：</p><p>本地開啟數據庫事務進行扣款操作，成功後發送MQ消息給庫存中心進行發貨。</p><p>有人會想到開啟mybatis事務實現，把本地事務和MQ消息放在一起不就行了嗎？如果MQ發送成功，就提交事務，發送失敗就回滾事務，整套操作一氣呵成。</p><pre>transaction{ 扣款(); boolean success = 發送MQ();	if(success){ commit(); }else{ rollBack(); }}</pre><p>看似沒什麼問題，但是<strong>網絡是不可靠</strong>的。假設MQ返回過來的響應因為網絡原因遲遲沒有收到，所以在面對不確定的MQ返回結果只好進行回滾。但是MQ 服務器又確實是收到了這條消息的，只是給客戶端的響應丟失了，所以導致的結果就是扣款失敗，成功發貨。</p><div class=pgc-img><img alt=一定能看懂的RocketMQ事務消息源碼介紹(乾貨) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9e038ea88e9648df9dbeb07dbf872fdb><p class=pgc-img-caption></p></div><p>既然MQ消息的發送不能和本地事務寫在一起，那如何來保證其整體具有原子性的需求呢？答案就是今天我們介紹的主角：<strong>事務消息</strong>。</p><h1><strong>概覽</strong></h1><div class=pgc-img><img alt=一定能看懂的RocketMQ事務消息源碼介紹(乾貨) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3a59f4ec00334086aa34d4af730812c9><p class=pgc-img-caption></p></div><p>總體而言RocketMQ事務消息分為兩條主線</p><ol><li><strong>定時任務發送流程</strong>：發送half message(半消息)，執行本地事務，發送事務執行結果</li><li><strong>定時任務回查流程</strong>：MQ服務器回查本地事務，發送事務執行結果</li></ol><p>因此本文也通過這兩條主線對源碼進行分析</p><h1><strong>源碼分析</strong></h1><p><strong>半消息發送流程</strong></p><p><strong>本地應用(client)</strong></p><p>在本地應用發送事務消息的核心類是TransactionMQProducer，該類通過繼承DefaultMQProducer來複用大部分發送消息相關的邏輯，這個類的代碼量非常少只有100來行，下面是這個類的sendMessageTransaction方法</p><pre>@Overridepublic TransactionSendResult sendMessageInTransaction(final Message msg, final Object arg) throws MQClientException { if (null == this.transactionListener) { throw new MQClientException("TransactionListener is null", null); } return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);}</pre><p>這個方法做了兩件事，</p><ol><li>檢查transactionListener是否存在</li><li>調用父類執行事務消息發送</li></ol><p>TransactionListener在事務消息流程中起到至關重要的作用，一起看看這個接口</p><pre>public interface TransactionListener { /** * When send transactional prepare(half) message succeed, this method will be invoked to execute local transaction. * * @param msg Half(prepare) message * @param arg Custom business parameter * @return Transaction state */ LocalTransactionState executeLocalTransaction(final Message msg, final Object arg); /** * When no response to prepare(half) message. broker will send check message to check the transaction status, and this * method will be invoked to get local transaction status. * * @param msg Check message * @return Transaction state */ LocalTransactionState checkLocalTransaction(final MessageExt msg);}</pre><p>接口註釋說的很明白，配合上面的概覽圖來看就是，executeLocalTransaction方法對應的就是<strong>執行本地事務</strong>操作，checkLocalTransaction對應的就是<strong>回查本地事務</strong>操作。下面是DefaultMQProducer類的sendMessageInTransaction方法源碼</p><pre>public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter localTransactionExecuter, final Object arg) throws MQClientException { ... SendResult sendResult = null; MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true"); MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup()); 						... sendResult = this.send(msg); 						... switch (sendResult.getSendStatus()) { case SEND_OK: { 		... localTransactionState = transactionListener.executeLocalTransaction(msg, arg); ... break; case FLUSH_DISK_TIMEOUT: case FLUSH_SLAVE_TIMEOUT: case SLAVE_NOT_AVAILABLE: localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE; break; default: break; } 						... this.endTransaction(sendResult, localTransactionState, localException);								...}</pre><p>為了使源碼的邏輯更加直觀，筆者精簡了核心代碼。sendMessageInTransaction方法主要做了以下事情</p><ol><li>給消息打上事務消息相關的標記，用於MQ服務端區分普通消息和事務消息</li><li>發送半消息(half message)</li><li>發送成功則由transactionListener執行本地事務</li><li>執行endTransaction方法，如果<strong>半消息發送失敗</strong>或<strong>本地事務執行失敗</strong>告訴服務端是刪除半消息，<strong>半消息發送成功</strong>且<strong>本地事務執行成功</strong>則告訴服務端生效半消息。</li></ol><p>發送半消息流程，Client端代碼到這裡差不多就結束了，接下來看看RocketMQ Server端是如何處理的</p><p><strong>RocketMQ Server</strong></p><p>Server在接收到消息過後會進行一些領域對象的轉化和是否支持事務消息的權限校驗，對理解事務消息用處不大，此處就省略對旁枝末節的介紹了。下面是TransactionalMessageBridge類處理half message的源碼</p><pre>public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner) { return store.putMessage(parseHalfMessageInner(messageInner));}private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) { MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic()); MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msgInner.getQueueId())); msgInner.setSysFlag( MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE)); msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic()); msgInner.setQueueId(0); msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties())); return msgInner;}</pre><p>這兩個方法主要做了以下事情：</p><pre>public class Message implements Serializable { private static final long serialVersionUID = 8445773977080406428L; private String topic; private int flag; private Map&lt;String, String&gt; properties; private byte[] body; private String transactionId;}</pre><ol><li>將消息的topic，queueId放進消息體自身的map裡進行緩存</li><li>將消息的topic 設置為“RMQ_SYS_TRANS_OP_HALF_TOPIC”，queueId設置為0</li><li>將消息寫入磁盤持久化</li></ol><p>可以看到所有的事務半消息都會被放進同一個topic的同一個queue裡面，通過對topic的區分，從而避免了半消息被consumer給消費到</p><p>Server將半消息持久化後然後會發送結果給我們本地的應用程序。到了這裡Server端對半消息的處理就結束了，緊接著的是定時任務的登場。</p><p><strong>定時任務回查流程</strong></p><p><strong>RocketMQ Server</strong></p><p>定時任務是一個叫TransactionalMessageService類的線程，下面是該類的check方法</p><pre>@Overridepublic void check(long transactionTimeout, int transactionCheckMax, AbstractTransactionalMessageCheckListener listener) { ... if (!putBackHalfMsgQueue(msgExt, i)) { continue; } listener.resolveHalfMsg(msgExt); } 									...}</pre><p>check方法非常長，省略的代碼大致都是對半消息進行過濾(如超過72小時的事務消息，就被算作過期)，只保留符合條件的半消息對其進行回查。</p><p>其中很有意思的是putBackHalfMsgQueue方法，因為每次把半消息從磁盤拉到內存裡進行處理都會對其屬性進行改變(例如TRANSACTION_CHECK_TIMES，這是是否丟棄事務消息的關鍵信息)，所以在發送回查消息之前需要對半消息再次放進磁盤。RocketMQ採取的方法是基於最新的物理偏移量<strong>重新寫入</strong>，而不是對原有的半消息進行<strong>修改</strong>，其中的目的就是RocketMQ的存儲設計採用順序寫，如果去修改消息 ，無法做到高性能。</p><p>下面是resolveHalfMsg方法，主要就是開啟一個線程然後發送check消息。</p><pre>public void resolveHalfMsg(final MessageExt msgExt) { executorService.execute(new Runnable() { @Override public void run() { try { sendCheckMessage(msgExt); } catch (Exception e) { LOGGER.error("Send check message error!", e); } } });}</pre><p><strong>本地應用(client)</strong></p><p>下面是DefaultMQProducerImpl的checkTransactionState方法，是本地應用對回查消息的處理邏輯</p><pre>@Overridepublic void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) { Runnable request = new Runnable() { ... @Override public void run() { ... TransactionListener transactionListener = getCheckListener(); ... localTransactionState = transactionListener.checkLocalTransaction(message); ...  this.processTransactionState( localTransactionState, group, exception);  }  private void processTransactionState( ... DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark, 3000); ... } }; this.checkExecutor.submit(request);}</pre><p>精簡代碼邏輯後可以清晰的看到</p><ul><li>開啟一個線程來執行回查的邏輯</li><li>通過執行transactionListener的checkLocalTransaction方法來獲取本地事務執行的結果</li></ul><p><strong>RocketMQ Server</strong></p><p>RocketMQ 服務器在收到Client發過來的Commit消息後會</p><p>讀出半消息——>恢復topic等原消息體的信息——>和普通消息一樣再次寫入磁盤——>刪除之前的半消息</p><p>如果是Rollback消息則直接刪除之前的半消息</p><p>到此，整條RocketMQ 事務消息的調用鏈就結束了</p><h1><strong>思考</strong></h1><p><strong>1. 分佈式事務等於事務消息嗎？</strong></p><p>兩者並沒有關係，事務消息僅僅保證本地事務和MQ消息發送形成整體的原子性，而投遞到MQ服務器後，消費者是否能一定消費成功是無法保證的。</p><p><strong>2. 源碼設計上有什麼亮點嗎？</strong></p><p>通過對整條鏈路源碼的學習理解發現還是有不少亮點的</p><ul><li>server端回查消息的發送，client端回查消息邏輯的處理，client端commit/rollback消息的提交都是用了異步進行，可以說能異步的地方都用了異步，通過異步+重試的方式保證了在分佈式環境中即使短暫的網絡狀況不良好，也不會影響整體邏輯。</li><li>引入TransactionListener，真正做到了開閉原則以及依賴倒置原則，面向接口編程。整體擴展性做得非常好，使用者只需要編寫自己的Listener就可以做到事務消息的發送，非常方便</li><li>TransactionMQProducer通過繼承DefaultMQProducer極大地複用了關於發送消息相關的邏輯</li></ul><p><strong>3. 源碼設計上有什麼不足嗎？</strong></p><p>RocketMQ作為一款極其成功的消息中間件，要發現不足不是那麼容易了，筆者談幾點看法</p><ul><li>sendMessageIntransaction等事務相關的方法被劃分在了DefaultMQProducer裡面，從內聚的角度來說這是跟事務相關的發送消息方法應該被劃分在TransactionMQProducer。</li><li>所有topic的半消息都會寫在topic為RMQ_SYS_TRANS_OP_HALF_TOPIC的半消息隊列裡，並且每條半消息，在整個鏈路裡會被寫多次，如果併發很大且大部分消息都是事務消息的話，可靠性會存在問題。</li></ul></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>RocketMQ</a></li><li><a>事務</a></li><li><a>源碼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/3ff1309.html alt="基於RocketMQ分佈式事務 - 完整示例" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/388a9665bf45413eb391e47c6d10ca12 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/3ff1309.html title="基於RocketMQ分佈式事務 - 完整示例">基於RocketMQ分佈式事務 - 完整示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html alt=Mysql事務 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ab1dd0d.html title=Mysql事務>Mysql事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html alt="SQL Server中的事務（附有實例）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/21e047bd6e3c41fba0beac7ef3f1ce4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9d6f488.html title="SQL Server中的事務（附有實例）">SQL Server中的事務（附有實例）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html alt=SpringBoot事務詳細簡介 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c014a1.html title=SpringBoot事務詳細簡介>SpringBoot事務詳細簡介</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html alt=SqlServer使用事務注意事項，高級程序員必背 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24b98634.html title=SqlServer使用事務注意事項，高級程序員必背>SqlServer使用事務注意事項，高級程序員必背</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>