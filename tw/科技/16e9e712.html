<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>高併發之API接口，分佈式，防刷限流，如何做？ | 极客快訊</title><meta property="og:title" content="高併發之API接口，分佈式，防刷限流，如何做？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/72ef0f380abf4c6693d26afc863a1782"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/16e9e712.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/16e9e712.html><meta property="article:published_time" content="2020-11-14T21:04:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:37+08:00"><meta name=Keywords content><meta name=description content="高併發之API接口，分佈式，防刷限流，如何做？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/16e9e712.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>高併發之API接口，分佈式，防刷限流，如何做？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>在開發分佈式高併發系統時有三把利器用來保護系統：緩存、降級、限流</p><h3 class=pgc-h-arrow-right>緩存</h3><p>緩存的目的是提升系統訪問速度和增大系統處理容量</p><h3 class=pgc-h-arrow-right>降級</h3><p>降級是當服務出現問題或者影響到核心流程時，需要暫時屏蔽掉，待高峰或者問題解決後再打開</p><h3 class=pgc-h-arrow-right>限流</h3><p>限流的目的是通過對併發訪問/請求進行限速，或者對一個時間窗口內的請求進行限速來保護系統，一旦達到限制速率則可以拒絕服務、排隊或等待、降級等處理</p><h3 class=pgc-h-arrow-right>問題描述</h3><p><strong>1、</strong>某天A君突然發現自己的接口請求量突然漲到之前的10倍，沒多久該接口幾乎不可使用，並引發連鎖反應導致整個系統崩潰。如何應對這種情況呢？生活給了我們答案：比如老式電閘都安裝了保險絲，一旦有人使用超大功率的設備，保險絲就會燒斷以保護各個電器不被強電流給燒壞。同理我們的接口也需要安裝上“保險絲”，以防止非預期的請求對系統壓力過大而引起的系統癱瘓，當流量過大時，可以採取拒絕或者引流等機制。整編：微信公眾號，搜雲庫技術團隊，ID：souyunku</p><p><strong>2、</strong>緩存的目的是提升系統訪問速度和增大系統能處理的容量，可謂是抗高併發流量的銀彈；而降級是當服務出問題或者影響到核心流程的性能則需要暫時屏蔽掉，待高峰或者問題解決後再打開；而有些場景並不能用緩存和降級來解決，比如稀缺資源（秒殺、搶購）、寫服務（如評論、下單）、頻繁的複雜查詢（評論的最後幾頁），因此需有一種手段來限制這些場景的併發/請求量，即限流。</p><p><strong>3、</strong>系統在設計之初就會有一個預估容量，長時間超過系統能承受的TPS/QPS閾值，系統可能會被壓垮，最終導致整個服務不夠用。為了避免這種情況，我們就需要對接口請求進行限流。</p><p><strong>4、</strong>限流的目的是通過對併發訪問請求進行限速或者一個時間窗口內的的請求數量進行限速來保護系統，一旦達到限制速率則可以拒絕服務、排隊或等待。</p><p><strong>5、</strong>一般開發高併發系統常見的限流模式有控制併發和控制速率，一個是限制併發的總數量（比如數據庫連接池、線程池），一個是限制併發訪問的速率（如nginx的limitconn模塊，用來限制瞬時併發連接數），另外還可以限制單位時間窗口內的請求數量（如Guava的RateLimiter、nginx的limitreq模塊，限制每秒的平均速率）。其他還有如限制遠程接口調用速率、限制MQ的消費速率。另外還可以根據網絡連接數、網絡流量、CPU或內存負載等來限流。</p><h2 class=pgc-h-arrow-right>相關概念：</h2><h3 class=pgc-h-arrow-right>PV:</h3><p>page view 頁面總訪問量，每刷新一次記錄一次。</p><h3 class=pgc-h-arrow-right>UV:</h3><p>unique view 客戶端主機訪問，指一天內相同IP的訪問記為1次。</p><h3 class=pgc-h-arrow-right>QPS:</h3><p>query per second,即每秒訪問量。qps很大程度上代表了系統的繁忙度，沒次請求可能存在多次的磁盤io，網絡請求，多個cpu時間片，一旦qps超過了預先設置的閥值，可以考量擴容增加服務器，避免訪問量過大導致的宕機。整編：微信公眾號，搜雲庫技術團隊，ID：souyunku</p><h3 class=pgc-h-arrow-right>RT:</h3><p>response time,每次請求的響應時間,直接決定用戶體驗性。</p><p>本文主要介紹應用級限流方法，分佈式限流、流量入口限流（接入層如NGINX limitconn和limitreq 模塊）。</p><h2 class=pgc-h-arrow-right>應用級限流</h2><h3 class=pgc-h-arrow-right>一、控制併發數量</h3><p>屬於一種較常見的限流手段，在實際應用中可以通過信號量機制（如Java中的Semaphore）來實現。操作系統的信號量是個很重要的概念，Java 併發庫 的Semaphore 可以很輕鬆完成信號量控制，Semaphore可以控制某個資源可被同時訪問的個數，通過 acquire() 獲取一個許可，如果沒有就等待，而 release() 釋放一個許可。</p><p>舉個例子，我們對外提供一個服務接口，允許最大併發數為10，代碼實現如下：</p><pre><code>public class DubboService {    private final Semaphore permit = new Semaphore(10, true);    public void process(){        try{            permit.acquire();            //業務邏輯處理        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            permit.release();        }    }}</code></pre><p>在以上代碼中，雖然有30個線程在執行，但是隻允許10個併發的執行。Semaphore的構造方法Semaphore(int permits) 接受一個整型的數字，表示可用的許可證數量。Semaphore(10)表示允許10個線程獲取許可證，也就是最大併發數是10。Semaphore的用法也很簡單，首先線程使用Semaphore的acquire()獲取一個許可證，使用完之後調用release()歸還許可證，還可以用tryAcquire()方法嘗試獲取許可證，信號量的本質是控制某個資源可被同時訪問的個數，在一定程度上可以控制某資源的訪問頻率，但不能精確控制，控制訪問頻率的模式見下文描述。</p><h3 class=pgc-h-arrow-right>二、控制訪問速率</h3><p>在工程實踐中，常見的是使用令牌桶算法來實現這種模式，常用的限流算法有兩種：漏桶算法和令牌桶算法。</p><h3 class=pgc-h-arrow-right>漏桶算法</h3><p>漏桶算法思路很簡單，水（請求）先進入到漏桶裡，漏桶以一定的速度出水，當水流入速度過大會直接溢出，可以看出漏桶算法能強行限制數據的傳輸速率。</p><div class=pgc-img><img alt=高併發之API接口，分佈式，防刷限流，如何做？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72ef0f380abf4c6693d26afc863a1782><p class=pgc-img-caption></p></div><p>對於很多應用場景來說，除了要求能夠限制數據的平均傳輸速率外，還要求允許某種程度的突發傳輸。這時候漏桶算法可能就不合適了，令牌桶算法更為適合。</p><h3 class=pgc-h-arrow-right>令牌桶算法</h3><p>如圖所示，令牌桶算法的原理是系統會以一個恆定的速度往桶裡放入令牌，而如果請求需要被處理，則需要先從桶裡獲取一個令牌，當桶裡沒有令牌可取時，則拒絕服務，令牌桶算法通過發放令牌，根據令牌的rate頻率做請求頻率限制，容量限制等。整編：微信公眾號，搜雲庫技術團隊，ID：souyunku</p><div class=pgc-img><img alt=高併發之API接口，分佈式，防刷限流，如何做？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/95c698a90b3e44f688b87d29d568efce><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>在Wikipedia上，令牌桶算法是這麼描述的：</h3><p><strong>1、</strong>每過1/r秒桶中增加一個令牌。</p><p><strong>2、</strong>桶中最多存放b個令牌，如果桶滿了，新放入的令牌會被丟棄。</p><p><strong>3、</strong>當一個n字節的數據包到達時，消耗n個令牌，然後發送該數據包。</p><p><strong>4、</strong>如果桶中可用令牌小於n，則該數據包將被緩存或丟棄。</p><p>令牌桶控制的是一個時間窗口內通過的數據量，在API層面我們常說的QPS、TPS，正好是一個時間窗口內的請求量或者事務量，只不過時間窗口限定在1s罷了。以一個恆定的速度往桶裡放入令牌，而如果請求需要被處理，則需要先從桶裡獲取一個令牌，當桶裡沒有令牌可取時，則拒絕服務。令牌桶的另外一個好處是可以方便的改變速度，一旦需要提高速率，則按需提高放入桶中的令牌的速率。</p><p>在我們的工程實踐中，通常使用Google開源工具包Guava提供的限流工具類RateLimiter來實現控制速率，該類基於令牌桶算法來完成限流，非常易於使用，而且非常高效。如我們不希望每秒的任務提交超過1個</p><pre><code>public static void main(String[] args) {    String start = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());    RateLimiter limiter = RateLimiter.create(1.0); // 這裡的1表示每秒允許處理的量為1個    for (int i = 1; i &lt;= 10; i++) {        double waitTime = limiter.acquire(i); // 請求RateLimiter, 超過permits會被阻塞        System.out.println("cutTime=" + System.currentTimeMillis() + " call execute:" + i + " waitTime:" + waitTime);    }    String end = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());    System.out.println("start time:" + start);    System.out.println("end time:" + end);}</code></pre><p>首先通過RateLimiter.create(1.0);創建一個限流器，參數代表每秒生成的令牌數，通過limiter.acquire(i);來以阻塞的方式獲取令牌，令牌桶算法允許一定程度的突發（允許消費未來的令牌），所以可以一次性消費i個令牌；當然也可以通過tryAcquire(int permits, long timeout, TimeUnit unit)來設置等待超時時間的方式獲取令牌，如果超timeout為0，則代表非阻塞，獲取不到立即返回，支持阻塞或可超時的令牌消費。</p><p>從輸出來看，RateLimiter支持預消費，比如在acquire(5)時，等待時間是4秒，是上一個獲取令牌時預消費了3個兩排，固需要等待3*1秒，然後又預消費了5個令牌，以此類推。</p><p><strong>RateLimiter通過限制後面請求的等待時間，來支持一定程度的突發請求(預消費</strong>)，在使用過程中需要注意這一點，Guava有兩種限流模式，一種為穩定模式(SmoothBursty:令牌生成速度恆定，平滑突發限流)，一種為漸進模式(SmoothWarmingUp:令牌生成速度緩慢提升直到維持在一個穩定值，平滑預熱限流) 兩種模式實現思路類似，主要區別在等待時間的計算上。</p><h3 class=pgc-h-arrow-right>SmoothBursty 模式：</h3><p>RateLimiter limiter = RateLimiter.create(5); RateLimiter.create(5)表示桶容量為5且每秒新增5個令牌，即每隔200毫秒新增一個令牌；limiter.acquire()表示消費一個令牌，如果當前桶中有足夠令牌則成功（返回值為0），如果桶中沒有令牌則暫停一段時間，比如發令牌間隔是200毫秒，則等待200毫秒後再去消費令牌，這種實現將突發請求速率平均為了固定請求速率。</p><h3 class=pgc-h-arrow-right>SmoothWarmingUp模式：</h3><p>RateLimiter limiter = RateLimiter.create(5,1000, TimeUnit.MILLISECONDS);</p><h3 class=pgc-h-arrow-right>創建方式：</h3><p><strong>RateLimiter.create(doublepermitsPerSecond, long warmupPeriod, TimeUnit unit)，permitsPerSecond表示每秒新增的令牌數，</strong>warmupPeriod表示在從冷啟動速率過渡到平均速率的時間間隔。速率是梯形上升速率的，也就是說冷啟動時會以一個比較大的速率慢慢到平均速率；然後趨於平均速率（梯形下降到平均速率）。可以通過調節warmupPeriod參數實現一開始就是平滑固定速率。整編：微信公眾號，搜雲庫技術團隊，ID：souyunku</p><h3 class=pgc-h-arrow-right>放在Controller中用Jemter壓測</h3><div class=pgc-img><img alt=高併發之API接口，分佈式，防刷限流，如何做？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/87bc89502ca74351af14886b576b1ae4><p class=pgc-img-caption></p></div><p>注：RateLimiter控制的是速率，Samephore控制的是併發量。RateLimiter的原理就是令牌桶，它主要由許可發出的速率來定義，如果沒有額外的配置，許可證將按每秒許可證規定的固定速度分配，許可將被平滑地分發，若請求超過permitsPerSecond則RateLimiter按照每秒 1/permitsPerSecond 的速率釋放許可。注意:RateLimiter適用於單體應用，且RateLimiter不保證公平性訪問。</p><p>使用上述方式使用RateLimiter的方式不夠優雅，自定義註解+AOP的方式實現(適用於單體應用)，詳細見下面代碼：</p><h3 class=pgc-h-arrow-right>自定義註解：</h3><pre><code>import java.lang.annotation.*;/** * 自定義註解可以不包含屬性，成為一個標識註解 */@Inherited@Documented@Target({ElementType.METHOD, ElementType.FIELD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)public @interface RateLimitAspect {}</code></pre><h3 class=pgc-h-arrow-right>自定義切面類</h3><pre><code>import com.google.common.util.concurrent.RateLimiter;import com.test.cn.springbootdemo.util.ResultUtil;import net.sf.json.JSONObject;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;import javax.servlet.ServletOutputStream;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Component@Scope@Aspectpublic class RateLimitAop {    @Autowired    private HttpServletResponse response;    private RateLimiter rateLimiter = RateLimiter.create(5.0); //比如說，我這裡設置"併發數"為5    @Pointcut("@annotation(com.test.cn.springbootdemo.aspect.RateLimitAspect)")    public void serviceLimit() {    }    @Around("serviceLimit()")    public Object around(ProceedingJoinPoint joinPoint) {        Boolean flag = rateLimiter.tryAcquire();        Object obj = null;        try {            if (flag) {                obj = joinPoint.proceed();            }else{                String result = JSONObject.fromObject(ResultUtil.success1(100, "failure")).toString();                output(response, result);            }        } catch (Throwable e) {            e.printStackTrace();        }        System.out.println("flag=" + flag + ",obj=" + obj);        return obj;    }    public void output(HttpServletResponse response, String msg) throws IOException {        response.setContentType("application/json;charset=UTF-8");        ServletOutputStream outputStream = null;        try {            outputStream = response.getOutputStream();            outputStream.write(msg.getBytes("UTF-8"));        } catch (IOException e) {            e.printStackTrace();        } finally {            outputStream.flush();            outputStream.close();        }    }}</code></pre><h3 class=pgc-h-arrow-right>測試controller</h3><pre><code>import com.test.cn.springbootdemo.aspect.RateLimitAspect;import com.test.cn.springbootdemo.util.ResultUtil;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class TestController {    @ResponseBody    @RateLimitAspect    @RequestMapping("/test")    public String test(){        return ResultUtil.success1(1001, "success").toString();    }</code></pre><h3 class=pgc-h-arrow-right>壓測結果：</h3><div class=pgc-img><img alt=高併發之API接口，分佈式，防刷限流，如何做？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/56355c9bd23f4860aa771a1aaff34dfa><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>三、控制單位時間窗口內請求數</h3><p>某些場景下，我們想限制某個接口或服務 每秒/每分鐘/每天 的請求次數或調用次數。例如限制服務每秒的調用次數為50，實現如下：</p><pre><code>private LoadingCache &lt; Long, AtomicLong &gt; counter = CacheBuilder.newBuilder().expireAfterWrite(2, TimeUnit.SECONDS).build(new CacheLoader &lt; Long, AtomicLong &gt; () {@    Override    public AtomicLong load(Long seconds) throws Exception {        return new AtomicLong(0);    }});public static long permit = 50;public ResponseEntity getData() throws ExecutionException {    //得到當前秒    long currentSeconds = System.currentTimeMillis() / 1000;    if (counter.get(currentSeconds).incrementAndGet() &gt; permit) {        return ResponseEntity.builder().code(404).msg("訪問速率過快").build();    }    //業務處理}</code></pre><p>到此應用級限流的一些方法就介紹完了。假設將應用部署到多臺機器，應用級限流方式只是單應用內的請求限流，不能進行全侷限流。因此我們需要分佈式限流和接入層限流來解決這個問題。</p><h2 class=pgc-h-arrow-right>分佈式限流</h2><p><strong>自定義註解+攔截器+Redis實現限流 (單體和分佈式均適用，全侷限流)</strong></p><h3 class=pgc-h-arrow-right>自定義註解：</h3><pre><code>@Inherited@Documented@Target({ElementType.FIELD,ElementType.TYPE,ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)public @interface AccessLimit {    int limit() default 5;      int sec() default 5;}</code></pre><h3 class=pgc-h-arrow-right>攔截器：</h3><pre><code>public class AccessLimitInterceptor implements HandlerInterceptor {    @Autowired    private RedisTemplate&lt;String, Integer&gt; redisTemplate;  //使用RedisTemplate操作redis    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {        if (handler instanceof HandlerMethod) {            HandlerMethod handlerMethod = (HandlerMethod) handler;            Method method = handlerMethod.getMethod();            if (!method.isAnnotationPresent(AccessLimit.class)) {                return true;            }            AccessLimit accessLimit = method.getAnnotation(AccessLimit.class);            if (accessLimit == null) {                return true;            }            int limit = accessLimit.limit();            int sec = accessLimit.sec();            String key = IPUtil.getIpAddr(request) + request.getRequestURI();            Integer maxLimit = redisTemplate.opsForValue().get(key);            if (maxLimit == null) {                redisTemplate.opsForValue().set(key, 1, sec, TimeUnit.SECONDS);  //set時一定要加過期時間            } else if (maxLimit &lt; limit) {                redisTemplate.opsForValue().set(key, maxLimit + 1, sec, TimeUnit.SECONDS);            } else {                output(response, "請求太頻繁!");                return false;            }        }        return true;    }    public void output(HttpServletResponse response, String msg) throws IOException {        response.setContentType("application/json;charset=UTF-8");        ServletOutputStream outputStream = null;        try {            outputStream = response.getOutputStream();            outputStream.write(msg.getBytes("UTF-8"));        } catch (IOException e) {            e.printStackTrace();        } finally {            outputStream.flush();            outputStream.close();        }    }    @Override    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {    }    @Override    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {    }}</code></pre><h3 class=pgc-h-arrow-right>controller:</h3><pre><code>@Controller@RequestMapping("/activity")public class AopController {    @ResponseBody    @RequestMapping("/seckill")    @AccessLimit(limit = 4,sec = 10)  //加上自定義註解即可    public String test (HttpServletRequest request,@RequestParam(value = "username",required = false) String userName){        //TODO somethings……        return   "hello world !";    }}</code></pre><h3 class=pgc-h-arrow-right>配置文件：</h3><pre><code>/*springmvc的配置文件中加入自定義攔截器*/&lt;mvc:interceptors&gt;   &lt;mvc:interceptor&gt;      &lt;mvc:mapping path="/**"/&gt;      &lt;bean class="com.pptv.activityapi.controller.pointsmall.AccessLimitInterceptor"/&gt;   &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;</code></pre><p>訪問效果如下，10s內訪問接口超過4次以上就過濾請求，原理和計數器算法類似：</p><div class=pgc-img><img alt=高併發之API接口，分佈式，防刷限流，如何做？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30a03c505d154a2b981658d94c6523ed><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>接入層限流</h2><p><strong>主要介紹nginx 限流，採用漏桶算法。</strong></p><p>限制原理:可一句話概括為：“根據客戶端特徵，限制其訪問頻率”，客戶端特徵主要指IP、UserAgent等。使用IP比UserAgent更可靠，因為IP無法造假，UserAgent可隨意偽造。整編：微信公眾號，搜雲庫技術團隊，ID：souyunku</p><p>用limit_req模塊來限制基於IP請求的訪問頻率：</p><p>http://nginx.org/en/docs/http/ngxhttplimitreqmodule.html</p><p>也可以用tengine中的增強版：</p><p>http://tengine.taobao.org/documentcn/httplimitreqcn.html</p><h3 class=pgc-h-arrow-right>1、併發數和連接數控制的配置：</h3><pre><code>nginx http配置：    #請求數量控制，每秒20個    limit_req_zone $binary_remote_addr zone=one:10m rate=20r/s;    #併發限制30個    limit_conn_zone $binary_remote_addr zone=addr:10m;    server塊配置    limit_req zone=one burst=5;    limit_conn addr 30;</code></pre><h3 class=pgc-h-arrow-right>2、ngxhttplimitconnmodule 可以用來限制單個IP的連接數：</h3><p>ngxhttplimitconnmodule模塊可以按照定義的鍵限定每個鍵值的連接數。可以設定單一 IP 來源的連接數。</p><p>並不是所有的連接都會被模塊計數；只有那些正在被處理的請求（這些請求的頭信息已被完全讀入）所在的連接才會被計數。</p><pre><code>http {    limit_conn_zone $binary_remote_addr zone=addr:10m;    ...    server {        ...        location /download/ {            limit_conn addr 1;        }</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>限流</a></li><li><a>API</a></li><li><a>防刷</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3998ae89.html alt=服務治理最佳實踐：如何依據參數值進行服務路由、鑑權、限流？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3f6fb254f0cc4ba390695e1d561d4a5c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3998ae89.html title=服務治理最佳實踐：如何依據參數值進行服務路由、鑑權、限流？>服務治理最佳實踐：如何依據參數值進行服務路由、鑑權、限流？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b2f4f92.html alt="Java - 日期時間API" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b2f4f92.html title="Java - 日期時間API">Java - 日期時間API</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f2b89270.html alt="繼Java API之後谷歌Map API被訴侵權" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/93cccb8ab813488f9355335120e11164 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f2b89270.html title="繼Java API之後谷歌Map API被訴侵權">繼Java API之後谷歌Map API被訴侵權</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4abab263.html alt=詳解高併發，億級併發流量控制，分佈式場景下的系統限流實戰 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2ce419d547834633a15d0be9cd7b4be2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4abab263.html title=詳解高併發，億級併發流量控制，分佈式場景下的系統限流實戰>詳解高併發，億級併發流量控制，分佈式場景下的系統限流實戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/483ff7c0.html alt="使用springcloud gateway搭建網關（分流，限流，熔斷）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5dedf0d033b54111b51594e9169ef331 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/483ff7c0.html title="使用springcloud gateway搭建網關（分流，限流，熔斷）">使用springcloud gateway搭建網關（分流，限流，熔斷）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25895d7e.html alt=5.穩壓二極管的特性及電路應用（限流電阻計算） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/fc5ebf22-a2ec-4faa-93c8-2455b5aa1964 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25895d7e.html title=5.穩壓二極管的特性及電路應用（限流電阻計算）>5.穩壓二極管的特性及電路應用（限流電阻計算）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d5b0bb60.html alt=37、日期/時間常用API——工具/格式化 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/12e3b2aa4de6444fa9c899a90429aaa8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d5b0bb60.html title=37、日期/時間常用API——工具/格式化>37、日期/時間常用API——工具/格式化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17be6b38.html alt="REST API一些必備的安全基礎--瞭解一下" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d96827535e743af9bf55e5af185e5b7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17be6b38.html title="REST API一些必備的安全基礎--瞭解一下">REST API一些必備的安全基礎--瞭解一下</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49435d4e.html alt=必不可少的API管理平臺！IAM瞭解一下 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/061ee5b53073474ca26b4d135ff8704f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49435d4e.html title=必不可少的API管理平臺！IAM瞭解一下>必不可少的API管理平臺！IAM瞭解一下</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e359400.html alt=一文詳細講解API網關核心功能和API管理擴展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dd99cf31064849fa8e0b357249d15cf8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e359400.html title=一文詳細講解API網關核心功能和API管理擴展>一文詳細講解API網關核心功能和API管理擴展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8616d752.html alt=交付成功的API：知道需要什麼呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1ed4479cdd974216a1c10b8858e57dd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8616d752.html title=交付成功的API：知道需要什麼呢？>交付成功的API：知道需要什麼呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/31a309d2.html alt=企業API接口設計(token、timestamp、sign)之具體實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/030192793c5048239b469f5e5db8b18d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/31a309d2.html title=企業API接口設計(token、timestamp、sign)之具體實現>企業API接口設計(token、timestamp、sign)之具體實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/989ea117.html alt=管理API訪問令牌的安全最佳實踐 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/288f721723b1489c81d62de6aa6cfd33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/989ea117.html title=管理API訪問令牌的安全最佳實踐>管理API訪問令牌的安全最佳實踐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7dc97f07.html alt=物聯網開發接口API雲服務器IIS部署及域名解析定向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2149450612d7407fbefcec8e9b5709d9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7dc97f07.html title=物聯網開發接口API雲服務器IIS部署及域名解析定向>物聯網開發接口API雲服務器IIS部署及域名解析定向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16431777.html alt=Java中常用的API——阿里架構師的兩萬字總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a7567f0bc0694fd0ad5ba0987efc07ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16431777.html title=Java中常用的API——阿里架構師的兩萬字總結>Java中常用的API——阿里架構師的兩萬字總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>