<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C語言指針難嗎？紙老虎而已，純乾貨講解 | 极客快訊</title><meta property="og:title" content="C語言指針難嗎？紙老虎而已，純乾貨講解 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/71b50f2a7c1141a2ac44a24efb4a84ff"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/178bc13f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/178bc13f.html><meta property="article:published_time" content="2020-11-14T21:00:48+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:48+08:00"><meta name=Keywords content><meta name=description content="C語言指針難嗎？紙老虎而已，純乾貨講解"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/178bc13f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C語言指針難嗎？紙老虎而已，純乾貨講解</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>指針對於C來說太重要。然而，想要全面理解指針，除了要對C語言有熟練的掌握外，還要有計算機硬件以及操作系統等方方面面的基本知識。所以本文儘可能的通過一篇文章完全講解指針。</p><p><strong>為什麼需要指針？</strong></p><p>指針解決了一些編程中基本的問題。</p><p><strong>第一，</strong>指針的使用使得不同區域的代碼可以輕易的共享內存數據。當然小夥伴們也可以通過數據的複製達到相同的效果，但是這樣往往效率不太好。<br>因為諸如結構體等大型數據，佔用的字節數多，複製很消耗性能。<br>但使用指針就可以很好的避免這個問題，因為任何類型的指針佔用的字節數都是一樣的（根據平臺不同，有4字節或者8字節或者其他可能）。</p><p><strong>第二，</strong>指針使得一些複雜的鏈接性的數據結構的構建成為可能，比如鏈表，鏈式二叉樹等等。</p><p><strong>第三，</strong>有些操作必須使用指針。如操作申請的堆內存。<br>還有：C語言中的一切函數調用中，值傳遞都是“按值傳遞”的。<br>如果我們要在函數中修改被傳遞過來的對象，就必須通過這個對象的指針來完成。</p><p><br><strong>計算機是如何從內存中進行取指的？</strong></p><p>計算機的總線可以分為3種：數據總線，地址總線和控制總線。這裡不對控制總線進行描述。數據總線用於進行數據信息傳送。數據總線的位數一般與CPU的字長一致。一般而言，數據總線的位數跟當前機器int值的長度相等。例如在16位機器上，int的長度是16bit，32位機器則是32bit。這個計算機一條指令最多能夠讀取或者存取的數據長度。大於這個值，計算機將進行多次訪問。這也就是我們說的64位機器進行64位數據運算的效率比32位要高的原因，因為32位機要進行兩次取指和運行，而64位機卻只需要一次！</p><p><br>地址總線專門用於尋址，CPU通過該地址進行數據的訪問，然後把處於該地址處的數據通過數據總線進行傳送，傳送的長度就是數據總線的位數。地址總線的位數決定了CPU可直接尋址的內存空間大小，比如CPU總線長32位，其最大的直接尋址空間長232KB，也就是4G。這也就是我們常說的32位CPU最大支持的內存上限為4G（當然，實際上支持不到這個值，因為一部分尋址空間會被映射到外部的一些IO設備和虛擬內存上。現在通過一些新的技術，可以使32位機支持4G以上內存，但這個不在這裡的討論範圍內）。</p><p>一般而言，計算機的地址總線和數據總線的寬度是一樣的，我們說32位的CPU，數據總線和地址總線的寬度都是32位。</p><p><br><strong>計算機訪問某個數據的時候，首先要通過地址總線傳送數據存儲或者讀取的位置，然後在通過數據總線傳送需要存儲或者讀取的數據。一般地，int整型的位數等於數據總線的寬度，指針的位數等於地址總線的寬度。</strong></p><p></p><p><strong>計算機的基本訪問單元</strong></p><p>學過C語言的人都知道，C語言的基本數據類型中，就屬char的位數最小，是8位。我們可以認為計算機以8位，即1個字節為基本訪問單元。小於一個字節的數據，必須通過位操作來進行訪問。</p><p><strong>內存訪問方式</strong></p><p>如圖1所示，<strong>計算機在進行數據訪問的時候，是以字節為基本單元進行訪問的</strong>，所以可以認為，計算每次都是從第p個字節開始訪問的。訪問的長度將由編譯器根據實際類型進行計算，這在後面將會進行講述。</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71b50f2a7c1141a2ac44a24efb4a84ff><p class=pgc-img-caption></p></div><p>內存訪問方式</p><p>想要了解更多，就去翻閱計算機組成原理和編譯原理吧。</p><p><strong>sizeof關鍵字</strong></p><p><strong>sizeof關鍵字是編譯器用來計算某些類型的數據的長度的，以字節為基本單位。例如：</strong></p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li></ul><pre>sizeof(char)=1; sizeof(int)=4;</pre><p><br><strong>sizeof(Type)的值是在編譯的時候就計算出來了的，可以認為這是一個常量！</strong></p><p><strong>指針是什麼？</strong></p><p>我們知道：C語言中的數組是指一類類型，數組具體區分為 int 類型數組，double類型數組,char數組 等等。<br>同樣指針這個概念也泛指一類數據類型，int指針類型，double指針類型，char指針類型等等。</p><p>通常，我們用int類型保存一些整型的數據，如 int num = 97 ， 我們也會用char來存儲字符：char ch = 'a'。</p><p>我們也必須知道：任何程序數據載入內存後，在內存都有他們的地址，這就是指針。<br>而為了保存一個數據在內存中的地址，我們就需要指針變量。</p><p>因此：指針是程序數據在內存中的地址，而指針變量是用來保存這些地址的變量。</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ed9b2cf6c914598889d355dbdb2bb32><p class=pgc-img-caption></p></div><p><strong>在我個人的理解中，可以將指針理解成int整型，只不過它存放的數據是內存地址，而不是普通數據，我們通過這個地址值進行數據的訪問，假設它的是p，意思就是該數據存放位置為內存的第p個字節。</strong></p><p><br><strong>當然，我們不能像對int類型的數據那樣進行各種加減乘除操作，這是編譯器不允許的，因為這樣錯是非常危險的！</strong></p><p><br>圖2就是對指針的描述，<strong>指針的值是數據存放地址，因此，我們說，指針指向數據的存放位置。</strong></p><p></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/0b19f92aeed745e994f673b4239831f1><p class=pgc-img-caption></p></div><p><strong>指針的長度<br></strong><br>我們使用這樣的方式來定義一個指針：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>Type *p;</pre><p><br>我們說<strong>p是指向type類型的指針</strong>，type可以是任意類型，除了可以是char,short, int, long等基本類型外，還可以是指針類型，例如int *, int **, 或者更多級的指針，也可是是結構體，類或者函數等。於是，我們說：</p><p>int * 是指向int類型的指針；</p><p>int **，也即(int *) *，是指向int *類型的指針，也就是指向指針的指針；</p><p>int ***，也即(int **) *，是指向int**類型的指針，也就是指向指針的指針的指針；</p><p>…我想你應該懂了</p><p>struct xxx *，是指向struct xxx類型的指針；</p><p>其實，說這麼多，只是希望大家在看到指針的時候，不要被int ***這樣的東西嚇到，就像前面說的，指針就是指向某種類型的指針，我們只看最後一個*號，前面的只不過是type類型罷了。</p><p>細心一點的人應該發現了，在“什麼是指針”這一小節當中，已經表明了：<strong>指針的長度跟CPU的位數相等</strong>，大部分的CPU是32位的，因此我們說，<strong>指針的長度是32bit，也就是4個字節！</strong>注意：任意指針的長度都是4個字節，不管是什麼指針！（當然64位機自己去測一下，應該是8個字節吧。。。）</p><p>於是：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>Type *p;</pre><p>izeof(p)的值是4，Type可以是任意類型，char,int, long, struct, class, int **…</p><p><strong>以後大家看到什麼sizeof(char*), sizeof(int *)，sizeof(xxx *)，不要理會，統統寫4，只要是指針，長度就是4個字節，絕對不要被type類型迷惑！</strong></p><p><strong>為什麼程序中的數據會有自己的地址？</strong></p><p>弄清這個問題我們需要從操作系統的角度去認知內存。</p><p>電腦維修師傅眼中的內存是這樣的：內存在物理上是由一組DRAM芯片組成的。</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/518ea251e5954ee8afa909b73a6cb30c><p class=pgc-img-caption></p></div><p>而作為一個程序員，我們不需要了解內存的物理結構，操作系統將RAM等硬件和軟件結合起來，給程序員提供的一種對內存使用的抽象。<br>這種抽象機制使得程序使用的是虛擬存儲器,而不是直接操作和使用真實存在的物理存儲器。<br>所有的虛擬地址形成的集合就是虛擬地址空間。</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b994759f32dc41cbbf915e3ac1cb76b4><p class=pgc-img-caption></p></div><p>在程序員眼中的內存應該是下面這樣的。</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8f0532fef3c4427ebe6e7d01323d575f><p class=pgc-img-caption></p></div><p>也就是說，內存是一個很大的，線性的字節數組（平坦尋址）。每一個字節都是固定的大小，由8個二進制位組成。<br>最關鍵的是，每一個字節都有一個唯一的編號,編號從0開始，一直到最後一個字節。<br>如上圖中，這是一個256M的內存，他一共有256x1024x1024 = 268435456個字節，那麼它的地址範圍就是 0 ~268435455 。</p><p>由於內存中的每一個字節都有一個唯一的編號。<br>因此，在程序中使用的變量，常量，甚至數函數等數據，當他們被載入到內存中後，都有自己唯一的一個編號，這個編號就是這個數據的地址。<br>指針就是這樣形成的。</p><p><strong>下面用代碼說明</strong></p><pre>#include &lt;stdio.h&gt;int main(void){ char ch = 'a'; int num = 97; printf("ch 的地址:%p",&amp;ch); //ch 的地址:0028FF47 printf("num的地址:%p",&amp;num); //num的地址:0028FF40 return 0;}</pre><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5a42bf835dac4b29bec2cf8a9954ea83><p class=pgc-img-caption></p></div><p>指針的值實質是內存單元（即字節）的編號，所以指針單獨從數值上看，也是整數，他們一般用16進製表示。<br>指針的值（虛擬地址值）使用一個機器字的大小來存儲。<br>也就是說,對於一個機器字為w位的電腦而言,它的虛擬地址空間是0~2w － 1 ,程序最多能訪問2w個字節。<br>這就是為什麼xp這種32位系統最大支持4GB內存的原因了。</p><p>我們可以大致畫出變量ch和num在內存模型中的存儲。（假設 char佔1個字節，int佔4字節）</p><p></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a17e2b0d5c474818af3594a0ed7d7d36><p class=pgc-img-caption></p></div><p><strong>變量和內存</strong></p><p>為了簡單起見，這裡就用上面例子中的 int num = 97 這個局部變量來分析變量在內存中的存儲模型。</p><p></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5b25209de6f24c8f8808213e33beeaf8><p class=pgc-img-caption></p></div><p>已知：num的類型是int，佔用了4個字節的內存空間，其值是97，地址是0028FF40。我們從以下幾個方面去分析。</p><p><strong>1、內存的數據</strong></p><p>內存的數據就是變量的值對應的二進制，一切都是二進制。<br>97的二進制是 : 00000000 00000000 00000000 0110000 , 但使用的小端模式存儲時，低位數據存放在低地址，所以圖中畫的時候是倒過來的。</p><p><strong>2、內存數據的類型</strong></p><p>內存的數據類型決定了這個數據佔用的字節數，以及計算機將如何解釋這些字節。<br>num的類型是int，因此將被解釋為 一個整數。</p><p><strong>3、內存數據的名稱</strong></p><p>內存的名稱就是變量名。實質上，內存數據都是以地址來標識的，根本沒有內存的名稱這個說法，這只是高級語言提供的抽象機制 ，方便我們操作內存數據。<br>而且在C語言中，並不是所有的內存數據都有名稱，例如使用malloc申請的堆內存就沒有。</p><p><strong>4、內存數據的地址</strong></p><p>如果一個類型佔用的字節數大於1，則其變量的地址就是地址值最小的那個字節的地址。<br>因此num的地址是 0028FF40。內存的地址用於標識這個內存塊。</p><p><strong>5、內存數據的生命週期</strong></p><p>num是main函數中的局部變量，因此當main函數被啟動時，它被分配於棧內存上，當main執行結束時，消亡。</p><p>如果一個數據一直佔用著他的內存，那麼我們就說他是“活著的”，如果他佔用的內存被回收了，則這個數據就“消亡了”。<br>C語言中的程序數據會按照他們定義的位置，數據的種類，修飾的關鍵字等因素，決定他們的生命週期特性。<br>實質上我們程序使用的內存會被邏輯上劃分為：棧區，堆區，靜態數據區，方法區。<br>不同的區域的數據有不同的生命週期。</p><p><br>無論以後計算機硬件如何發展，內存容量都是有限的，因此清楚理解程序中每一個程序數據的生命週期是非常重要的。</p><p><br><strong>指針運算</strong></p><p>N多的面試會考這種東西了：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li></ul><pre>Type *p; p++;</pre><p>然後問你p的值變化了多少。</p><p>其實，也可以認為這是在考編譯器的基本知識。因此p<strong>的值並不像表面看到的+1那麼簡單，編譯器實際上對p進行的是加sizeof(Type)的操作。</strong></p><p>看一個一段代碼的測試結果：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4b4cbcdda7924d04b0af5dc9e22a5f78><p class=pgc-img-caption></p></div><p>這裡註釋掉char一行的原因是因為cout&lt;&lt;(char*)會被當成字符串輸出，而不是char的地址）</p><p>執行結果：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/adb9dcb5991f4d079bec14487cedfe32><p class=pgc-img-caption></p></div><p>觀察結果，可以看出，他們的增長結果分別是：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>2（sizeof(short)） 4（sizeof(int)） 4（sizeof(long)） 8（sizeof(long long)） 4（sizeof(float)） 8（sizeof(double)） 12（sizeof(long double)）</pre><p><br>喏，增加的值是不是sizeof(Type)呢？別的什麼struct，class之類的，就不驗證你，有興趣的自己去驗證。</p><p>我們再對這樣的一段代碼進行彙編，查看編譯器是如何進行指針的加法操作的：</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/79808f1372ae4080ab8cf9e98d5e4291><p class=pgc-img-caption></p></div><p>彙編結果：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e5212fe881c54afe8f73c8360b0cd727><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/843b4594602b4c17a90462a76545e346><p class=pgc-img-caption></p></div><p>注意看註釋部分的結果，我們看到，piv的值顯示加了4（sizeof(int)），然後又加了16（4*sizeof(int)）。</p><p><br><strong>指針變量和指向關係</strong></p><p>用來保存指針的變量，就是指針變量。<br>如果指針變量p1保存了變量 num的地址，則就說：p1指向了變量num，也可以說p1指向了num所在的內存塊 ，這種指向關係，在圖中一般用 箭頭表示。</p><p></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/347f8fe613dc462cb6b6f2fea7acdb2e><p class=pgc-img-caption></p></div><p>上圖中，指針變量p1指向了num所在的內存塊 ，即從地址0028FF40開始的4個byte 的內存塊。</p><p><strong>定義指針變量</strong></p><p>C語言中，定義變量時，在變量名前寫一個 * 星號，這個變量就變成了對應變量類型的指針變量。必要時要加( ) 來避免優先級的問題。</p><p>引申：C語言中，定義變量時，在定義的最前面寫上typedef ，那麼這個變量名就成了一種類型，即這個類型的同義詞。</p><pre>int a ; //int類型變量 aint *a ; //int* 變量aint arr[3]; //arr是包含3個int元素的數組int (* arr )[3]; //arr是一個指向包含3個int元素的數組的指針變量//-----------------各種類型的指針------------------------------int* p_int; //指向int類型變量的指針 double* p_double; //指向idouble類型變量的指針 struct Student *p_struct; //結構體類型的指針int(*p_func)(int,int); //指向返回類型為int，有2個int形參的函數的指針 int(*p_arr)[3]; //指向含有3個int元素的數組的指針 int** p_pointer; //指向 一個整形變量指針的指針</pre><p><strong>指針的2個重要屬性</strong></p><p>指針也是一種數據，指針變量也是一種變量，因此指針 這種數據也符合前面變量和內存主題中的特性。<br>這裡要強調2個屬性：指針的類型，指針的值。</p><pre>int main(void){ int num = 97; int *p1 = # char* p2 = (char*)(&amp;num); printf("%d",*p1); //輸出 97 putchar(*p2); //輸出 a return 0;}</pre><p>指針的值：很好理解，如上面的num 變量 ，其地址的值就是0028FF40 ，因此 p1的值就是0028FF40。<br>數據的地址用於在內存中定位和標識這個數據，因為任何2個內存不重疊的不同數據的地址都是不同的。</p><p>指針的類型：指針的類型決定了這個指針指向的內存的字節數並如何解釋這些字節信息。<br>一般指針變量的類型要和它指向的數據的類型匹配。</p><p>由於num的地址是0028FF40，因此 p1 和 p2 的值都是0028FF40</p><p>*p1 : 將從地址0028FF40 開始解析，因為p1是int類型指針，int佔4字節，因此向後連續取4個字節，並將這4個字節的二進制數據解析為一個整數 97。</p><p>*p2 : 將從地址0028FF40 開始解析，因為p2是char類型指針，char佔1字節，因此向後連續取1個字節，並將這1個字節的二進制數據解析為一個字符，即'a'。</p><p>同樣的地址，因為指針的類型不同，對它指向的內存的解釋就不同，得到的就是不同的數據。</p><p><strong>取地址</strong></p><p>既然有了指針變量，那就得讓他保存其它變量的地址，使用& 運算符取得一個變量的地址。</p><pre>int add(int a , int b){ return a + b;}int main(void){ int num = 97; float score = 10.00F; int arr[3] = {1,2,3}; //----------------------- int* p_num = # float* p_score = &amp;score; int (*p_arr)[3] = &amp;arr; int (*fp_add)(int ,int ) = add; //p_add是指向函數add的函數指針 return 0;}</pre><p>特殊的情況，他們並不一定需要使用&取地址：</p><ul class=list-paddingleft-2><li>數組名的值就是這個數組的第一個元素的地址。</li><li>函數名的值就是這個函數的地址。</li><li>字符串字面值常量作為右值時，就是這個字符串對應的字符數組的名稱,也就是這個字符串在內存中的地址。</li></ul><pre>int add(int a , int b){ return a + b;}int main(void){ int arr[3] = {1,2,3}; //----------------------- int* p_first = arr; int (*fp_add)(int ,int ) = add; const char* msg = "Hello world"; return 0;}</pre><p><strong>解地址</strong></p><p>我們需要一個數據的指針變量幹什麼？<br>當然使用通過它來操作（讀/寫）它指向的數據啦。<br>對一個指針解地址，就可以取到這個內存數據，解地址的寫法，就是在指針的前面加一個*號。</p><p>解指針的實質是：從指針指向的內存塊中取出這個內存數據。</p><pre>int main(void){ int age = 19; int*p_age = &amp;age; *p_age = 20; //通過指針修改指向的內存數據 printf("age = %d",*p_age); //通過指針讀取指向的內存數據 printf("age = %d",age); return 0;}</pre><p><strong>指針之間的賦值</strong></p><p>指針賦值和int變量賦值一樣，就是將地址的值拷貝給另外一個。<br>指針之間的賦值是一種淺拷貝，是在多個編程單元之間共享內存數據的高效的方法。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>int* p1 = &amp; num;int* p3 = p1;//通過指針 p1 、 p3 都可以對內存數據 num 進行讀寫，如果2個函數分別使用了p1 和p3，那麼這2個函數就共享了數據num。</pre><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fce8cedb9f384a35b812ed10cc3f54f5><p class=pgc-img-caption></p></div><p><strong>空指針（NULL指針）</strong></p><p>NULL是C語言標準定義的一個值，這個值其實就是0，只不過為了使得看起來更加具有意義，才定義了這樣的一個宏，中文的意思是空，表明不指向任何東西。你懂得。不過在此不討論空和零的區別。<br>在C語言中，我們讓指針變量賦值為NULL表示一個空指針，而C語言中，NULL實質是((void*)0)，就像前面說的指針可以理解成特殊的int，它總是有值的，p=NULL，其實就是p的值等於0。對於不多數機器而言，0地址是不能直接訪問的，設置為0，就表示該指針哪裡都沒指向。而在C++中，NULL實質是0。</p><p>換種說法：任何程序數據都不會存儲在地址為0的內存塊中，它是被操作系統預留的內存塊。<br><strong>下面代碼摘自 stdlib.h</strong></p><pre>#ifdef __cplusplus #define NULL 0#else #define NULL ((void *)0)#endif</pre><p>當然，就機器內部而言，NULL指針的實際值可能與此不同，這種情況下，編譯器將負責零值和內部值之間的翻譯轉換。</p><p>NULL指針的概念非常有用，它給了你一種方法，表示某個特定的指針目前並未指向任何東西。例如，一個用於在某個數組中查找某個特定值的函數可能返回一個指向查找到的數組元素的指針。如果沒找到，則返回一個NULL指針。</p><p>在內存的動態分配上，NULL的意義非同凡響，我們使用它來避免內存被多次釋放，造成經常性的段錯誤（segmentation fault）。一般，<strong>在free或者delete掉動態分配的內存後，都應該立即把指針置空，避免出現所以的懸掛指針，致使出現各種內存錯誤！</strong>例如：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4cda94aa607442aa94415e40e34743b4><p class=pgc-img-caption></p></div><p>free函數是不會也不可能把p置空的。像下面這樣的代碼就會出現內存段錯誤：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/880e821635b4479082f58afe589a1afa><p class=pgc-img-caption></p></div><p>因為，第一次free操作之後，p指向的內存已經釋放了，但是p的值還沒有變化，free函數改不了這個值，再free一次的時候，p指向的內存區域已經被釋放了，這個地址已經變成了非法地址，這個操作將導致段錯誤的發生（此時，p指向的區域剛好又被分配出去了，但是這種概率非常低，而且對這樣一塊內存區域進行操作是非常危險的！）<br>但是下面這段代碼就不會出現這樣的問題：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4a17dfa6e57e4e239aa2f50003dbb777><p class=pgc-img-caption></p></div><p>因為p的值編程了NULL，free函數檢測到p為NULL，會直接返回，而不會發生錯誤。</p><p><strong>這裡順便告訴大家一個內存釋放的小竅門，可以有效的避免因為忘記對指針進行置空而出現各種內存問題。這個方法就是自定義一個內存釋放函數，但是傳入的參數不知指針，而是指針的地址，在這個函數裡面置空，如下：<br></strong><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/616563388e7742e09deb7caeb17dd5db><p class=pgc-img-caption></p></div><p>結果：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bd5050c746140a5847198cb292433c0><p class=pgc-img-caption></p></div><p>my_free調用了之後，p的值就變成了0（NULL），調用多少次free都不會報錯了！</p><p><strong>另外一個方式也非常有效，那就是定義FREE宏，在宏裡面對他進行置空。例如<br></strong><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cfb3c4184f1f4d1ebf9e091ca505ae0c><p class=pgc-img-caption></p></div><p>執行結果同上面一樣，不會報段錯誤：</p><p></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf765a15bc4a4a0e85f4751a437b1fca><p class=pgc-img-caption></p></div><p>（關於內存的動態分配，這是個比較複雜的話題，有機會再專門開闢一章給各位講述一下吧，寫個帖子還是很花費時間和精力的，呵呵，寫過的童鞋應該都很清楚，所以順便插一句，轉帖可以，請註明出處，畢竟，大家都是本著共享的精神來討論問題的，寫的好壞都沒有向你所要什麼，請尊重每個人的勞動成果。）</p><p>指向空，或者說不指向任何東西。<br><strong>壞指針</strong></p><p>指針變量的值是NULL，或者未知的地址值，或者是當前應用程序不可訪問的地址值，這樣的指針就是壞指針。<br>不能對他們做解指針操作，否則程序會出現運行時錯誤，導致程序意外終止。</p><p>任何一個指針變量在做解地址操作前，都必須保證它指向的是有效的，可用的內存塊，否則就會出錯。<br>壞指針是造成C語言Bug的最頻繁的原因之一。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>下面的代碼就是錯誤的示例。void opp(){ int*p = NULL; *p = 10; //Oops! 不能對NULL解地址}void foo(){ int*p; *p = 10; //Oops! 不能對一個未知的地址解地址}void bar(){ int*p = (int*)1000; *p =10; //Oops! 不能對一個可能不屬於本程序的內存的地址的指針解地址}</pre><p><br><strong>void*類型指針</strong></p><p>由於void是空類型，因此void*類型的指針只保存了指針的值，而丟失了類型信息，我們不知道他指向的數據是什麼類型的，只指定這個數據在內存中的起始地址。<br>如果想要完整的提取指向的數據，程序員就必須對這個指針做出正確的類型轉換，然後再解指針。因為，編譯器不允許直接對void*類型的指針做解指針操作。</p><p><br>雖然從字面上看，void的意思是空，但是void指針的意思，可不是空指針的意思，空指針指的是上面所說的NULL指針。</p><p><br><strong>void指針實際上的意思是指向任意類型的指針</strong>。任意類型的指針都可以直接賦給void指針，而不需要進行強制轉換。</p><p>例如：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>Type a, *p=&amp;a;（Type等於char, int, struct, int *…）void *pv;pv=p;</pre><p><br>就像前面說的，void指針的好處，就在於，任意的指針都可以直接賦值給它，這在某些場合非常有用，因此有些操作對於任意指針都是相同的。void指針最常用於內存管理。最典型的，也是大家最熟知的，就是標準庫的free函數。它的原型如下：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre> void free(void*ptr);</pre><p><br>free函數的參數可以是任意指針，沒有誰見過free參數裡面的指針需要強壯為void*的吧？</p><p>malloc, calloc,realloc這些函數的返回值也是void指針，因為內存分配，實際上只需要知道分配的大小，然後返回新分配內存的地址就可以了，指針的值就是地址，返回的不管是何種指針，其實結果都是一樣的，因為所有的指針長度其實都是32位的（32位機器），它的值就是內存的地址，指針類型只是給編譯器看的，目的是讓編譯器在編譯的時候能夠正確的設置指針的值（參見指針運算章節）。如果malloc函數設置成下面這樣的原型，完全沒有問題。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>char*malloc(size_t sz);</pre><p><br>實際上設置成</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre>Type*malloc(size_t sz);</pre><p><br>也是完全正確的，使用void指針的原因，實際上就像前面說的，void指針意思是任意指針，這樣設計更加嚴謹一些，也更符合我們的直觀理解。如果對前面我說的指針概念理解的童鞋，肯定明白這一點。</p><p><strong>結構體和指針</strong></p><p>結構體指針有特殊的語法：-> 符號</p><p>如果p是一個結構體指針，則可以使用 p ->【成員】 的方法訪問結構體的成員</p><pre>typedef struct{ char name[31]; int age; float score;}Student;int main(void){ Student stu = {"Bob" , 19, 98.0}; Student*ps = &amp;stu; ps-&gt;age = 20; ps-&gt;score = 99.0; printf("name:%s age:%d",ps-&gt;name,ps-&gt;age); return 0;}</pre><p><strong>數組和指針</strong></p><p>1、數組名作為右值的時候，就是第一個元素的地址。</p><pre>int main(void){ int arr[3] = {1,2,3}; int*p_first = arr; printf("%d",*p_first); //1 return 0;}</pre><p>2、指向數組元素的指針 支持 遞增 遞減 運算。<br>（實質上所有指針都支持遞增遞減 運算 ，但只有在數組中使用才是有意義的）</p><pre>int main(void){ int arr[3] = {1,2,3}; int*p = arr; for(;p!=arr+3;p++){ printf("%d",*p); } return 0;}</pre><p>3、p= p+1 意思是，讓p指向原來指向的內存塊的下一個相鄰的相同類型的內存塊。</p><p>同一個數組中，元素的指針之間可以做減法運算，此時，指針之差等於下標之差。</p><p>4、p[n] == *(p+n)</p><p>p[n][m] == *( *(p+n)+ m )</p><p>5、當對數組名使用sizeof時，返回的是整個數組佔用的內存字節數。當把數組名賦值給一個指針後，再對指針使用sizeof運算符，返回的是指針的大小。</p><p>這就是為什麼將一個數組傳遞給一個函數時，需要另外用一個參數傳遞數組元素個數的原因了。</p><pre>int main(void){ int arr[3] = {1,2,3}; int*p = arr; printf("sizeof(arr)=%d",sizeof(arr)); //sizeof(arr)=12 printf("sizeof(p)=%d",sizeof(p)); //sizeof(p)=4 return 0;}</pre><p><br><strong>函數和指針</strong></p><p><strong>函數的參數和指針</strong></p><p>C語言中，實參傳遞給形參，是按值傳遞的，也就是說，函數中的形參是實參的拷貝份，形參和實參只是在值上面一樣，而不是同一個內存數據對象。<br>這就意味著：這種數據傳遞是單向的，即從調用者傳遞給被調函數，而被調函數無法修改傳遞的參數達到回傳的效果。</p><pre>void change(int a){ a++; //在函數中改變的只是這個函數的局部變量a，而隨著函數執行結束，a被銷燬。age還是原來的age，紋絲不動。}int main(void){ int age = 19; change(age); printf("age = %d",age); // age = 19 return 0;}</pre><p><br>有時候我們可以使用函數的返回值來回傳數據，在簡單的情況下是可以的。<br>但是如果返回值有其它用途（例如返回函數的執行狀態量），或者要回傳的數據不止一個，返回值就解決不了了。</p><p>傳遞變量的指針可以輕鬆解決上述問題。</p><pre>void change(int* pa){ (*pa)++; //因為傳遞的是age的地址，因此pa指向內存數據age。當在函數中對指針pa解地址時， //會直接去內存中找到age這個數據，然後把它增1。}int main(void){ int age = 19; change(&amp;age); printf("age = %d",age); // age = 20 return 0;}</pre><p>再來一個老生常談的，用函數交換2個變量的值的例子：</p><pre>#include&lt;stdio.h&gt;void swap_bad(int a,int b);void swap_ok(int*pa,int*pb);int main(){ int a = 5; int b = 3; swap_bad(a,b); //Can`t swap; swap_ok(&amp;a,&amp;b); //OK return 0;}//錯誤的寫法void swap_bad(int a,int b){ int t; t=a; a=b; b=t;}//正確的寫法：通過指針void swap_ok(int*pa,int*pb){ int t; t=*pa; *pa=*pb; *pb=t;}</pre><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e8464e2a9194b8bb2a4235e5ab17120><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/19ce4cf5c8dd40f6bb1020d589e9a1fe><p class=pgc-img-caption></p></div><p>有的時候，我們通過指針傳遞數據給函數不是為了在函數中改變他指向的對象。<br>相反，我們防止這個目標數據被改變。傳遞指針只是為了避免拷貝大型數據。</p><p>考慮一個結構體類型Student。我們通過show函數輸出Student變量的數據。</p><pre>typedef struct{ char name[31]; int age; float score;}Student;//打印Student變量信息void show(const Student * ps){ printf("name:%s , age:%d , score:%.2f",ps-&gt;name,ps-&gt;age,ps-&gt;score); }</pre><p><br>我們只是在show函數中取讀Student變量的信息，而不會去修改它，為了防止意外修改，我們使用了常量指針去約束。<br>另外我們為什麼要使用指針而不是直接傳遞Student變量呢？</p><p>從定義的結構看出，Student變量的大小至少是39個字節，那麼通過函數直接傳遞變量，實參賦值數據給形參需要拷貝至少39個字節的數據，極不高效。<br>而傳遞變量的指針卻快很多，因為在同一個平臺下，無論什麼類型的指針大小都是固定的：X86指針4字節，X64指針8字節，遠遠比一個Student結構體變量小。</p><p><strong>函數的指針</strong><br>跟普通的變量一樣，每一個函數都是有其地址的，我們通過跳轉到這個地址執行代碼來進行函數調用，只是，跟取普通數據不同的在於，函數有參數和返回值，在進行函數調用的時候，首先需要將參數壓入棧中，調用完成後又需要將參數壓入棧中。既然函數也是通過地址來進行訪問的，那它也可以使用指針來指向，事實上，每一個函數名都是一個指針，不過它是指針常量和指針常量，它的值是不能改的，指向的值也不能改。</p><p>（關於常量指針和指針常量什麼的，有時間在專門開闢一章來說明const這個東東吧，也是很有講頭的一個東東。。。）</p><p>函數指針一般用來幹什麼呢？<strong>函數指針最常用的場合就是回調函數。</strong>回調函數，顧名思義，就是某個函數會在適當的時候被別人調用。當期望你調用的函數能夠使用你的某些方式去操作的時候，回調函數就很有用，比如，你期望某個排序函數在比較的時候，能夠使用你定義的比較方法去比較。</p><p>有過較深入的C編程經驗的人應該都接觸過。C的標準庫中就有使用，例如在strlib.h頭文件的qsort函數，它的原型為：</p><p>void qsort(void*__base, size_t __nmemb, size_t __size, int(*_compar)(const void *, const void*));</p><p>其中int(*_compar)(const void *, const void *)就是回調函數，這個函數用於qsort函數用於數據的比較。下面，我會舉一個例子，來描述qsort函數的工作原理。</p><p>一般，我們使用下面這樣的方式來定義函數指針：</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li></ul><pre> typedef int(*compare)(const void *x, const void *y);</pre><p><br>這個時候，compare就是參數為const void *, const void *類型，返回值是int類型的函數。例如：</p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d61e04771cb9463dae763649bf2cf96c><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5bbc1191f8224351b033f2dde51e565a><p class=pgc-img-caption></p></div><p>用typedef來定義的好處，就是可以使用一個簡短的名稱來表示一種類型，而不需要總是使用很長的代碼來，這樣不僅使得代碼更加簡潔易讀，更是避免了代碼敲寫容易出錯的問題。<strong>強烈推薦各位在定義結構體，指針（尤其是函數指針）等比較複雜的結構時，使用typedef來定義。</strong></p><p>每一個函數本身也是一種程序數據，一個函數包含了多條執行語句，它被編譯後，實質上是多條機器指令的合集。<br>在程序載入到內存後，函數的機器指令存放在一個特定的邏輯區域：代碼區。<br>既然是存放在內存中，那麼函數也是有自己的指針的。</p><p>C語言中，函數名作為右值時，就是這個函數的指針。</p><pre>void echo(const char *msg){ printf("%s",msg);}int main(void){ void(*p)(const char*) = echo; //函數指針變量指向echo這個函數 p("Hello "); //通過函數的指針p調用函數，等價於echo("Hello ") echo("World"); return 0;}</pre><p><br><strong>const和指針</strong><br>const到底修飾誰？誰才是不變的？</p><p>如果const 後面是一個類型，則跳過最近的原子類型，修飾後面的數據。<br>（原子類型是不可再分割的類型，如int, short , char，以及typedef包裝後的類型）</p><p>如果const後面就是一個數據，則直接修飾這個數據。</p><ul class="code-snippet__line-index code-snippet__js"><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li><li><br></li></ul><pre>int main(){ int a = 1; int const *p1 = &amp;a; //const後面是*p1，實質是數據a，則修飾*p1，通過p1不能修改a的值 const int*p2 = &amp;a; //const後面是int類型，則跳過int ，修飾*p2， 效果同上 int* const p3 = NULL; //const後面是數據p3。也就是指針p3本身是const . const int* const p4 = &amp;a; // 通過p4不能改變a 的值，同時p4本身也是 const int const* const p5 = &amp;a; //效果同上 return 0;} typedef int* pint_t; //將 int* 類型 包裝為 pint_t,則pint_t 現在是一個完整的原子類型int main(){ int a = 1; const pint_t p1 = &amp;a; //同樣，const跳過類型pint_t，修飾p1，指針p1本身是const pint_t const p2 = &amp;a; //const 直接修飾p，同上 return 0;}</pre><pre></pre><p><strong>深拷貝和淺拷貝</strong></p><p>如果2個程序單元（例如2個函數）是通過拷貝他們所共享的數據的指針來工作的，這就是淺拷貝，因為真正要訪問的數據並沒有被拷貝。<br>如果被訪問的數據被拷貝了，在每個單元中都有自己的一份，對目標數據的操作相互不受影響，則叫做深拷貝。</p><p></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c6f18aa0da264dc8ac0c50f0d2900e10><p class=pgc-img-caption></p></div><p><strong>附加知識</strong></p><p>指針和引用這個2個名詞的區別。他們本質上來說是同樣的東西。<br>指針常用在C語言中，而引用，則用於諸如Java，C#等 在語言層面封裝了對指針的直接操作的編程語言中。</p><p>大端模式和小端模式</p><p>1) Little-Endian就是低位字節排放在內存的低地址端，高位字節排放在內存的高地址端。個人PC常用，Intel X86處理器是小端模式。</p><p>2) B i g-Endian就是高位字節排放在內存的低地址端，低位字節排放在內存的高地址端。</p><p>採用大端方式進行數據存放符合人類的正常思維，而採用小端方式進行數據存放利於計算機處理。<br>有些機器同時支持大端和小端模式,通過配置來設定實際的端模式。</p><p>假如 short類型佔用2個字節，且存儲的地址為0x30。</p><p>short a = 1;</p><p>如下圖：</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0abba064faaf407e9fd0bd9c5f6fbd71><p class=pgc-img-caption></p></div><pre>//測試機器使用的是否為小端模式。是，則返回true，否則返回false//這個方法判別的依據就是：C語言中一個對象的地址就是這個對象佔用的字節中，地址值最小的那個字節的地址。bool isSmallIndain(){ unsigned int val = 'A'; unsigned char* p = (unsigned char*)&amp;val; //C/C++：對於多字節數據，取地址是取的數據對象的第一個字節的地址，也就是數據的低地址 return *p == 'A';}</pre><p><br></p><p>相關推薦</p><p><br></p><div class=pgc-img><img alt=C語言指針難嗎？紙老虎而已，純乾貨講解 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ec4b1eeb81f419a8bd3a3a96ce88005><p class=pgc-img-caption></p></div><p>《C語言深度解剖（第3版）》由作者結合自身多年嵌入式C語言開發經驗和平時講解C語言的心得體會整理而成，其中有很多作者獨特的見解或看法。由於並不是從頭到尾講解C語言的基礎知識，所以該書並不適用於C語言零基礎的讀者，其內容要比一般的C語言圖書深得多、細緻得多，其中有很多問題是各大公司的面試或筆試題。第3版中新增加了部分C語言知識點的內容。</p><p>《C語言深度解剖（第3版）》適合廣大計算機系學生、初級程序員參考學習，也適合計算機系教師、中高級程序員參考使用。</p><p><strong>作者簡介</strong></p><p>陳正衝，湖南沅江人，畢業於中國科學技術大學。具有豐富的嵌入式軟件開發與管理經驗，對於軟件工程方法論和研發管理有深刻理解。每年都多次舉行軟件工程技術和研發管理方面培訓，講課深入、透徹、幽默，深受各方好評。目前主要從事研發管理工作。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>語言</a></li><li><a>指針</a></li><li><a>純乾貨</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/342d7dd9.html alt=C語言指針終極指南！（附詳盡圖示和代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4e7017cb21b9471891cf2f2febf5befe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/342d7dd9.html title=C語言指針終極指南！（附詳盡圖示和代碼）>C語言指針終極指南！（附詳盡圖示和代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a0bb3a1a.html alt=C語言指針運算不理解？深入淺出通俗易懂，一題吃透指針與數組 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f86ddd3196544739bc425c80fd9c9c5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a0bb3a1a.html title=C語言指針運算不理解？深入淺出通俗易懂，一題吃透指針與數組>C語言指針運算不理解？深入淺出通俗易懂，一題吃透指針與數組</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34838dce.html alt=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a0b5a50b90804963b14ab394517ae294 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34838dce.html title=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢>C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c6a3555.html alt=C語言指針怎麼理解？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2245f99437eb40f38a501559e7695694 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c6a3555.html title=C語言指針怎麼理解？>C語言指針怎麼理解？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42ec5444.html alt=C語言的精華指針，沒學指針就是沒學C語言！零基礎瞭解C語言指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3751eb5d53b64a3085de1113ad56d98a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42ec5444.html title=C語言的精華指針，沒學指針就是沒學C語言！零基礎瞭解C語言指針>C語言的精華指針，沒學指針就是沒學C語言！零基礎瞭解C語言指針</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00508d48.html alt=c語言指針有哪些？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1530609445503dc7f276929 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00508d48.html title=c語言指針有哪些？>c語言指針有哪些？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c706fd4.html alt=初識C語言指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/202ea458-f961-4d7f-8442-64dc6ce814c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c706fd4.html title=初識C語言指針>初識C語言指針</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9dc72d59.html alt=指針-C語言的靈魂(五)-指針與數組的微妙關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152125795472869eabef91e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9dc72d59.html title=指針-C語言的靈魂(五)-指針與數組的微妙關係>指針-C語言的靈魂(五)-指針與數組的微妙關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cbb5c65.html alt=指針-C語言的靈魂(四)-指針運算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1521079213682d1229d1654 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cbb5c65.html title=指針-C語言的靈魂(四)-指針運算>指針-C語言的靈魂(四)-指針運算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea6119e.html alt=深入理解C語言的指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4e2601d6d7b04dc2b8107b4555ef6910 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea6119e.html title=深入理解C語言的指針>深入理解C語言的指針</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49b31745.html alt=讓你從根本上理解C語言指針，真正明白C語言指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a8e086b8d7104de098e65d9bd42a348d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49b31745.html title=讓你從根本上理解C語言指針，真正明白C語言指針>讓你從根本上理解C語言指針，真正明白C語言指針</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/299cf68e.html alt="C語言指針詳解（經典 非常詳細 通俗易懂）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/945d85d21fcf45cba3e994a7220e2112 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/299cf68e.html title="C語言指針詳解（經典 非常詳細 通俗易懂）">C語言指針詳解（經典 非常詳細 通俗易懂）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d7e80fb.html alt=C語言每日一練4——利用指針進行數交換 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d7e80fb.html title=C語言每日一練4——利用指針進行數交換>C語言每日一練4——利用指針進行數交換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html alt=什麼是梯度：用形象的語言解讀梯度的本質原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/557c7b377c5449bb885df35b2d354e03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html title=什麼是梯度：用形象的語言解讀梯度的本質原理>什麼是梯度：用形象的語言解讀梯度的本質原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html alt=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S5YRqTH6awaqmG style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html title=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行>我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>