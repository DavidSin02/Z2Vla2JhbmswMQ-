<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入理解微服務架構spring的各個知識點（面試必問知識點） | 极客快訊</title><meta property="og:title" content="深入理解微服務架構spring的各個知識點（面試必問知識點） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/b970816462884435bec0b1a8fc618b0b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/17b21f70.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/17b21f70.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="深入理解微服務架構spring的各個知識點（面試必問知識點）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/17b21f70.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入理解微服務架構spring的各個知識點（面試必問知識點）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言：</h1><p>最近整理Spring相關的知識點(面試必問) ，在我整理的過程中，我發現自己對Spring的理解有點朦朧，因為在平時我們接受的是Spring單個的知識點或者知道但沒有代碼的支持所有有點朦朧，所以我就把Spring知識點從整體然後往局部，到最後一個一個知識點拎出來，我想有很多的朋友或者是初學的朋友和我一樣對Spring有點朦朧，所以我分享出來，寫的不完全和不好的歡迎指出</p><h1 class=pgc-h-arrow-right>什麼是spring</h1><p>spring是一個開源框架，spring為簡化企業級開發而生，使用spring可以使簡單的java bean 實現以前只有EJG才能實現的功能。</p><p>Spring是一個輕量級的控制反轉(IoC)和麵向切面(AOP)的容器框架。</p><h1 class=pgc-h-arrow-right>spring的特點</h1><p>◆ 輕量——從大小與開銷兩方面而言Spring都是輕量的。完整的Spring框架可以在一個大小隻有1MB多的JAR文件裡發佈。並 且Spring所需的處理開銷也是微不足道的。此外，Spring是非侵入式的：典型地，Spring應用中的對象不依賴於Spring的特定類。</p><p>◆ 控制反轉——Spring通過一種稱作控制反轉（IoC）的技術促進了鬆耦 合。當應用了IoC，一個對象依賴的其它對象會通過被動的方式傳遞進來，而不是這個對象自己創建或者查找依賴對象。你可以認為IoC與JNDI相反——不 是對象從容器中查找依賴，而是容器在對象初始化時不等對象請求就主動將依賴傳遞給它。</p><p>◆ 面向切面——Spring提供了面向切面編程的豐富支持，允許通過分離應用的 業務邏輯與系統級服務（例如審計（auditing）和事務（）管理）進行內聚性的開發。應用對象只實現它們應該做的——完成業務邏輯——僅此而已。它們 並不負責（甚至是意識）其它的系統級關注點，例如日誌或事務支持。</p><p>◆ 容器——Spring包含並管理應用對象的配置和生命週期，在這個意義上它是 一種容器，你可以配置你的每個bean如何被創建——基於一個可配置原型（prototype），你的bean可以創建一個單獨的實例或者每次需要時都生 成一個新的實例——以及它們是如何相互關聯的。然而，Spring不應該被混同於傳統的重量級的EJB容器，它們經常是龐大與笨重的，難以使用。</p><p>◆ 框架——Spring可以將簡單的組件配置、組合成為複雜的應用。在Spring中，應用對象被聲明式地組合，典型地是在一個XML文件裡。 Spring也提供了很多基礎功能（事務管理、持久化框架集成等等），將應用邏輯的開發留給了你。</p><h1 class=pgc-h-arrow-right>Spring包括哪些內容</h1><p>核心技術 IoC 和 AOP</p><p>數據訪問 （持久層解決方案）</p><p>Web層解決方案 SpringMVC</p><p>集成 （整合其他開源框架）</p><h1 class=pgc-h-arrow-right><strong>使用Spring有什麼好處</strong></h1><p>◆Spring能有效地組織你的中間層對象,無論你是否選擇使用了EJB。如果你僅僅使用了Struts或其他的包含了J2EE特有APIs的 framework，你會發現Spring關注了遺留下的問題，。</p><p>◆Spring能消除在許多工程上對Singleton的過多使用。根據我的經驗，這是一個主要的問題，它減少了系統的可測試性和麵向對象特性。</p><p>◆Spring能消除使用各種各樣格式的屬性定製文件的需要,在整個應用和工程中，可通過一種 一致的方法來進行配置。曾經感到迷惑，一個特定類要查找迷幻般的屬性關鍵字或系統屬性,為此不得不讀Javadoc乃至源編碼嗎？有了Spring，你可 很簡單地看到類的JavaBean屬性。倒置控制的使用(在下面討論)幫助完成這種簡化。</p><p>◆Spring能通過接口而不是類促進好的編程習慣，減少編程代價到幾乎為零。</p><p>◆Spring被設計為讓使用它創建的應用儘可能少的依賴於他的APIs。在Spring應用中的大多數業務對象沒有依賴於Spring。</p><p>◆使用Spring構建的應用程序易於單元測試。</p><p>◆Spring能使EJB的使用成為一個實現選擇,而不是應用架構的必然選擇。你能選擇用POJOs或local EJBs來實現業務接口，卻不會影響調用代碼。</p><p>◆Spring幫助你解決許多問題而無需使用EJB。Spring能提供一種EJB的替換物，它們適於許多web應用。例如,Spring能使用 AOP提供聲明性事務而不通過使用EJB容器，如果你僅僅需要與單個的數據庫打交道，甚至不需要JTA實現。</p><p>■Spring為數據存取提供了一致的框架,不論是使用JDBC或O/R mapping產品（如Hibernate）。</p><p>Spring確實使你能通過最簡單可行的解決辦法解決你的問題。這些特性是有很大價值的。</p><p>總結起來，Spring有如下優點：</p><p>◆低侵入式設計，代碼汙染極低</p><p>◆ 獨立於各種應用服務器，可以真正實現Write Once,Run Anywhere的承諾</p><p>◆Spring的DI機制降低了業務對象替換的複雜性</p><p>◆Spring並不完全依賴於Spring，開發者可自由選用Spring框架的部分或全部</p><p>在此我向大家推薦一個架構學習交流群。交流學習群號：521353348 裡面會分享一些資深架構師錄製的視頻錄像：有Spring，MyBatis，Netty源碼分析，高併發、高性能、分佈式、微服務架構的原理，JVM性能優化、分佈式架構等這些成為架構師必備的知識體系。還能領取免費的學習資源，目前受益良多</p><p>spring中的核心類有哪些，各有什麼作用</p><p>BeanFactory：產生一個新的實例，可以實現單例模式</p><p>BeanWrapper：提供統一的get及set方法</p><p>ApplicationContext:提供框架的實現，包括BeanFactory的所有功能</p><h1 class=pgc-h-arrow-right>spring常用的類和接口有哪些</h1><p>A：ApplicationContextAware接口</p><p>當一個類需要獲取ApplicationContext實例時，可以讓該類實現ApplicationContextAware接口。</p><p>B：ApplicationEvent抽象類</p><p>當需要創建自定義事件時，可以新建一個繼承自ApplicationEvent抽象類的類。</p><p>C：ApplicationListener接口</p><p>當需要監聽自定義事件時，可以新建一個實現ApplicationListener接口的類，並將該類配置到Spring容器中。</p><p>D：BeanNameAware接口</p><p>當bean需要獲取自身在容器中的id/name時，可以實現BeanNameAware接口。</p><p>E：InitializingBean接口</p><p>當需要在bean的全部屬性設置成功後做些特殊的處理，可以讓該bean實現InitializingBean接口。</p><p>效果等同於bean的init-method屬性的使用或者@PostContsuct註解的使用。</p><p>三種方式的執行順序：先註解，然後執行InitializingBean接口中定義的方法，最後執行init-method屬性指定的方法。</p><p>F：DisposableBean接口</p><p>當需要在bean銷燬之前做些特殊的處理，可以讓該bean實現DisposableBean接口。</p><p>效果等同於bean的destroy-method屬性的使用或者@PreDestory註解的使用。</p><p>三種方式的執行順序：先註解，然後執行DisposableBean接口中定義的方法，最後執行destroy-method屬性指定的方法。</p><p>G：BeanPostProcessor接口</p><p>當需要對受管bean進行預處理時，可以新建一個實現BeanPostProcessor接口的類，並將該類配置到Spring容器中。</p><p>H：BeanFactoryPostProcessor接口</p><p>當需要對Bean工廠進行預處理時，可以新建一個實現BeanFactoryPostProcessor接口的類，並將該類配置到Spring容器中。</p><p>spring事務的原理</p><p>事務管理的方式：編程型和聲明型，spring推薦使用後一種方式</p><p>聲明型事務管理的優勢非常明顯：代碼中無需關於關注事務邏輯，讓Spring聲明式事務管理負責事務邏輯，聲明式事務管理無需與具體的事務邏輯耦 合，可以方便地在不同事務邏輯之間切換。</p><h1 class=pgc-h-arrow-right>什麼是IOC，什麼又是DI，他們有什麼區別</h1><p>依賴注入DI是一個程序設計模式和架構模型， 一些時候也稱作控制反轉，儘管在技術上來講，依賴注入是一個IOC的特殊實現，依賴注入是指一個對象應用另外一個對象來提供一個特殊的能力，例如：把一個 數據庫連接以參數的形式傳到一個對象的結構方法裡面而不是在那個對象內部自行創建一個連接。控制反轉和依賴注入的基本思想就是把類的依賴從類內部轉化到外 部以減少依賴</p><p>應用控制反轉，對象在被創建的時候，由一個調控系統內所有對象的外界實體，將其所依賴的對象的引用，傳遞給它。也可以說，依賴被注入到對象中。所 以，控制反轉是，關於一個對象如何獲取他所依賴的對象的引用，這個責任的反轉。</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b970816462884435bec0b1a8fc618b0b><p class=pgc-img-caption></p></div><p>Bean注入屬性的幾種方式</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c21b6a83009743489aa15f43606b2abc><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>什麼是aop，aop的作用是什麼</h1><p>面向切面編程（AOP）提供另外一種角度來思考程序結構，通過這種方式彌補了面向對象編程（OOP）的不足，除了類（classes）以外，AOP提供了切面。切面對關注點進行模塊化，例如橫切多個類型和對象的事務管理</p><p>Spring的一個關鍵的組件就是AOP框架，可以自由選擇是否使用AOP 提供聲明式企業服務，特別是為了替代EJB聲明式服務。最重要的服務是聲明性事務管理，這個服務建立在Spring的抽象事物管理之上。允許用戶實現自定義切面，用AOP來完善OOP的使用,可以把Spring AOP看作是對Spring的一種增強</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6be92028983e4595941bf3a7e1597eef><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>AOP裡面重要的幾個名詞概念解釋</h1><p>切面（Aspect）： 一個關注點的模塊化，這個關注點可能會橫切多個對象。事務管理是J2EE應用中一個關於橫切關注點的很好的例子。 在Spring AOP中，切面可以使用通用類（基於模式的風格） 或者在普通類中以@Aspect註解（@AspectJ風格）來實現。</p><p>連接點（Joinpoint）： 在程序執行過程中某個特定的點，比如某方法調用的時候或者處理異常的時候。 在Spring AOP中，一個連接點 總是 代表一個方法的執行。 通過聲明一個org.aspectj.lang.JoinPoint類型的參數可以使通知（Advice）的主體部分獲得連接點信息。</p><p>通知（Advice）： 在切面的某個特定的連接點（Joinpoint）上執行的動作。通知有各種類型，其中包括“around”、“before”和“after”等通知。 通知的類型將在後面部分進行討論。許多AOP框架，包括Spring，都是以攔截器做通知模型， 並維護一個以連接點為中心的攔截器鏈。</p><p>切入點（Pointcut）： 匹配連接點（Joinpoint）的斷言。通知和一個切入點表達式關聯，並在滿足這個切入點的連接點上運行（例如，當執行某個特定名稱的方法時）。 切入點表達式如何和連接點匹配是AOP的核心：Spring缺省使用AspectJ切入點語法。</p><p>引入（Introduction）： （也被稱為內部類型聲明（inter-type declaration））。聲明額外的方法或者某個類型的字段。 Spring允許引入新的接口（以及一個對應的實現）到任何被代理的對象。 例如，你可以使用一個引入來使bean實現 IsModified 接口，以便簡化緩存機制。</p><p>目標對象（Target Object）： 被一個或者多個切面（aspect）所通知（advise）的對象。也有人把它叫做 被通知（advised） 對象。 既然Spring AOP是通過運行時代理實現的，這個對象永遠是一個 被代理（proxied） 對象。</p><p>AOP代理（AOP Proxy）： AOP框架創建的對象，用來實現切面契約（aspect contract）（包括通知方法執行等功能）。 在Spring中，AOP代理可以是JDK動態代理或者CGLIB代理。 注意：Spring 2.0最新引入的基於模式（schema-based）風格和@AspectJ註解風格的切面聲明，對於使用這些風格的用戶來說，代理的創建是透明的。</p><p>織入（Weaving）： 把切面（aspect）連接到其它的應用程序類型或者對象上，並創建一個被通知（advised）的對象。 這些可以在編譯時（例如使用AspectJ編譯器），類加載時和運行時完成。 Spring和其他純Java AOP框架一樣，在運行時完成織入。</p><p>通知的類型：</p><p>前置通知（Before advice）： 在某連接點（join point）之前執行的通知，但這個通知不能阻止連接點前的執行（除非它拋出一個異常）。</p><p>返回後通知（After returning advice）： 在某連接點（join point）正常完成後執行的通知：例如，一個方法沒有拋出任何異常，正常返回。</p><p>拋出異常後通知（After throwing advice）： 在方法拋出異常退出時執行的通知。</p><p>後通知（After (finally) advice）： 當某連接點退出的時候執行的通知（不論是正常返回還是異常退出）。</p><p>環繞通知（Around Advice）： 包圍一個連接點（join point）的通知，如方法調用。這是最強大的一種通知類型。 環繞通知可以在方法調用前後完成自定義的行為。它也會選擇是否繼續執行連接點或直接返回它們自己的返回值或拋出異常來結束執行。</p><p>環繞通知是最常用的一種通知類型。大部分基於攔截的AOP框架，例如Nanning和JBoss4，都只提供環繞通知。</p><p>切入點（pointcut）和連接點（join point）匹配的概念是AOP的關鍵，這使得AOP不同於其它僅僅提供攔截功能的舊技術。 切入點使得定位通知（advice）可獨立於OO層次。 例如，一個提供聲明式事務管理的around通知可以被應用到一組橫跨多個對象中的方法上（例如服務層的所有業務操作）。</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a6dda88f624481cbb4d546d458177e0><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>請介紹一下Spring框架中Bean的生命週期和作用域</h1><p><strong>(1) bean定義</strong></p><p>在配置文件裡面用來進行定義。</p><p><strong>(2) bean初始化</strong></p><p>有兩種方式初始化:</p><p>A.在配置文件中通過指定init-method屬性來完成</p><p>B.實現org.springframwork.beans.factory.InitializingBean接口</p><p><strong>(3) bean調用</strong></p><p>有三種方式可以得到bean實例，並進行調用</p><p><strong>(4) bean銷燬</strong></p><p>銷燬有兩種方式</p><p>A.使用配置文件指定的destroy-method屬性</p><p>B.實現org.springframwork.bean.factory.DisposeableBean接口</p><p>##作用域</p><p>singleton</p><p>當一個bean的作用域為singleton, 那麼Spring IoC容器中只會存在一個共享的bean實例，並且所有對bean的請求，只要id與該bean定義相匹配，則只會返回bean的同一實例。</p><p>prototype</p><p>Prototype作用域的bean會導致在每次對該bean請求（將其注入到另一個bean中，或者以程序的方式調用容器的getBean() 方法）時都會創建一個新的bean實例。根據經驗，對所有有狀態的bean應該使用prototype作用域，而對無狀態的bean則應該使用 singleton作用域</p><p>request</p><p>在一次HTTP請求中，一個bean定義對應一個實例；即每次HTTP請求將會有各自的bean實例， 它們依據某個bean定義創建而成。該作用 域僅在基於web的Spring ApplicationContext情形下有效。</p><p>session</p><p>在一個HTTP Session中，一個bean定義對應一個實例。該作用域僅在基於web的Spring</p><p>ApplicationContext情形下有效。</p><p>global session</p><p>在一個全局的HTTP Session中，一個bean定義對應一個實例。典型情況下，僅在使用portlet</p><p>context的時候有效。該作用域僅在基於 web的Spring ApplicationContext情形下有效。</p><p>Bean的初始化方式有哪些</p><p>有兩種方式初始化Bean。</p><p>1、在配置文檔中通過指定init-method 屬性來完成</p><p>在Bean的類中實現一個初始化Bean屬性的方法，如init()，如：</p><pre><code>public class HelloWorld{public String msg=null;public Date date=null;public void init() {msg=”HelloWorld”;date=new Date();}……}</code></pre><p>然後，在配置文件中設置init-mothod屬性：</p><p>2、實現 org.springframwork.beans.factory.InitializingBean接口</p><p>Bean實現InitializingBean接口，並且增加 afterPropertiesSet() 方法：</p><pre><code>public class HelloWorld implement InitializingBean {public String msg=null;public Date date=null;public void afterPropertiesSet() {msg=”向全世界問好！”;date=new Date();}……}</code></pre><p>那麼，當這個Bean的所有屬性被Spring的BeanFactory設置完後，會自動調用afterPropertiesSet()方法對 Bean進行初始化，於是，配置文件就不用指定 init-method屬性了。</p><h1 class=pgc-h-arrow-right>Bean的調用方式有哪些</h1><p>有三種方式可以得到Bean並進行調用：</p><p>1、使用BeanWrapper</p><pre><code>HelloWorld hw=new HelloWorld();BeanWrapper bw=new BeanWrapperImpl(hw);bw.setPropertyvalue(”msg”,”HelloWorld”);system.out.println(bw.getPropertyCalue(”msg”));</code></pre><p>2、使用BeanFactory</p><pre><code>InputStream is=new FileInputStream(”config.xml”);XmlBeanFactory factory=new XmlBeanFactory(is);HelloWorld hw=(HelloWorld) factory.getBean(”HelloWorld”);system.out.println(hw.getMsg());</code></pre><p>3、使用ApplicationConttext</p><pre><code>ApplicationContext actx=new FleSystemXmlApplicationContext(”config.xml”);HelloWorld hw=(HelloWorld) actx.getBean(”HelloWorld”);System.out.println(hw.getMsg());</code></pre><h1 class=pgc-h-arrow-right>Bean的銷燬方式有哪些</h1><p>1、使用配置文件中的 destory-method 屬性</p><p>與初始化屬性 init-methods類似，在Bean的類中實現一個撤銷Bean的方法，然後在配置文件中通過 destory-method指定，那麼當bean銷燬時，Spring將自動調用指定的銷燬方法。</p><p>2、實現 org.springframwork.bean.factory.DisposebleBean接口</p><p>如果實現了DisposebleBean接口，那麼Spring將自動調用bean中的Destory方法進行銷燬，所以，Bean中必須提供 Destory方法。</p><h1 class=pgc-h-arrow-right>介紹一下Spring的事務管理</h1><p>事務就是對一系列的數據庫操作（比如插入多條數據）進行統一的提交或回滾操作，如果插入成功，那麼一起成功，如果中間有一條出現異常，那麼回滾之 前的所有操作。</p><p>這樣可以防止出現髒數據，防止數據庫數據出現問題。</p><p>開發中為了避免這種情況一般都會進行事務管理。Spring中也有自己的事務管理機制，一般是使用TransactionMananger進行管 理，可以通過Spring的注入來完成此功能。</p><p>spring提供了幾個關於事務處理的類：</p><p>TransactionDefinition //事務屬性定義</p><p>TranscationStatus //代表了當前的事務，可以提交，回滾。</p><p>PlatformTransactionManager這個是spring提供的用於管理事務的基礎接口，其下有一個實現的抽象類 AbstractPlatformTransactionManager,我們使用的事務管理類例如 DataSourceTransactionManager等都是這個類的子類。</p><p>一般事務定義步驟：</p><pre><code>TransactionDefinition td = new TransactionDefinition(); TransactionStatus ts = transactionManager.getTransaction(td); try { //do sth transactionManager.commit(ts); } catch(Exception e){transactionManager.rollback(ts);} </code></pre><p>spring提供的事務管理可以分為兩類：編程式的和聲明式的。編程式的，比較靈活，但是代碼量大，存在重複的代碼比較多；聲明式的比編程式的更 靈活。</p><p>編程式主要使用transactionTemplate。省略了部分的提交，回滾，一系列的事務對象定義，需注入事務管理對象.</p><pre><code>void add(){ transactionTemplate.execute( new TransactionCallback(){ pulic Object doInTransaction(TransactionStatus ts) { //do sth} } } 聲明式： 使用TransactionProxyFactoryBean: PROPAGATION_REQUIRED PROPAGATION_REQUIRED PROPAGATION_REQUIRED,readOnly 圍繞Poxy的動態代理 能夠自動的提交和回滾事務 </code></pre><p>org.springframework.transaction.interceptor.TransactionProxyFactoryBean</p><p>PROPAGATION_REQUIRED–支持當前事務，如果當前沒有事務，就新建一個事務。這是最常見的選擇。</p><p>PROPAGATION_SUPPORTS–支持當前事務，如果當前沒有事務，就以非事務方式執行。</p><p>PROPAGATION_MANDATORY–支持當前事務，如果當前沒有事務，就拋出異常。</p><p>PROPAGATION_REQUIRES_NEW–新建事務，如果當前存在事務，把當前事務掛起。</p><p>PROPAGATION_NOT_SUPPORTED–以非事務方式執行操作，如果當前存在事務，就把當前事務掛起。</p><p>PROPAGATION_NEVER–以非事務方式執行，如果當前存在事務，則拋出異常。</p><p>PROPAGATION_NESTED–如果當前存在事務，則在嵌套事務內執行。如果當前沒有事務，則進行與 PROPAGATION_REQUIRED類似的操作。</p><p>為什麼要有事務傳播行為</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dae51b3dfc624aba8a81eebbcdffb45d><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>Spring裡面如何配置數據庫驅動</h1><p>使用”org.springframework.jdbc.datasource.DriverManagerDataSource”數據源來配置數據庫驅動。示例如下：</p><p><br></p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8a1b69d0e0af4bbf9e1a82355aa3a366><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>Spring裡面applicationContext.xml文件能不能改成其他文件名</h1><p>ContextLoaderListener是一個ServletContextListener, 它在你的web應用啟動的時候初始化。缺省情況下， 它會在WEB-INF/applicationContext.xml文件找Spring的配置。 你可以通過定義一個元素名字為”contextConfigLocation”來改變Spring配置文件的 位置。示例如下：</p><p><br></p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1f5a3e1558124dbe86e3796017659e95><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>如何在web應用裡面配置spring</h1><p>在web.xml中加入如下同容,在啟動web服務器時加載/WEB-INF/applicationContext.xml中的內容。</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fe6b4ec5941b41f4975ed55847159b9b><p class=pgc-img-caption></p></div><p>通過如下類得到ApplicationContext實例</p><p>WebApplicationContextUtils.getWebApplicationContext</p><h1 class=pgc-h-arrow-right>Spring裡面如何定義hibernate mapping</h1><p>添加hibernate mapping 文件到web/WEB-INF目錄下的applicationContext.xml文件裡面。示例如下：</p><p><br></p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dce88bbb5ac845c3b91a765ea5db0e59><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>spring中的BeanFactory與ApplicationContext的作用有哪些</h1><p>1. BeanFactory負責讀取bean配置文檔，管理bean的加載，實例化，維護bean之間的依賴關係，負責bean的聲明週期。</p><p>2. ApplicationContext除了提供上述BeanFactory所能提供的功能之外，還提供了更完整的框架功能：</p><p>a. 國際化支持</p><p>b. 資源訪問：Resource rs = ctx. getResource(”classpath:config.properties”), “file:c:/config.properties”</p><p>c. 事件傳遞：通過實現ApplicationContextAware接口</p><p>3. 常用的獲取ApplicationContext的方法：</p><p>FileSystemXmlApplicationContext：從文件系統或者url指定的xml配置文件創建，參數為配置文件名或文件名數 組</p><p>ClassPathXmlApplicationContext：從classpath的xml配置文件創建，可以從jar包中讀取配置文件</p><p>WebApplicationContextUtils：從web應用的根目錄讀取配置文件，需要先在web.xml中配置，可以配置監聽器或者 servlet來實現</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5b4023ca42bf4714b780522812fac812><p class=pgc-img-caption></p></div><p>這兩種方式都默認配置文件為web-inf/applicationContext.xml，也可使用context-param指定配置文件</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1a8bfd8ac86f41879e6269bcfe41d796><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>BeanFactory 接口 和 ApplicationContext 接口區別</h1><p>* ApplicationContext 接口繼承 BeanFactory 接口 ，Spring核心工廠是BeanFactory ,BeanFactory 採取延遲加載，第一次getBean時才會初始化Bean , ApplicationContext 是會在加載配置文件時初始化Bean</p><p>* ApplicationContext是對BeanFactory擴展</p><p>國際化處理</p><p>事件傳遞</p><p>Bean自動裝配</p><p>各種不同應用層的Context實現</p><p>開發中基本都在使用ApplicationContext, web項目使用WebApplicationContext ，很少用到BeanFactory</p><pre><code>BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("applicationContext.xml"));IHelloService helloService = (IHelloService) beanFactory.getBean("helloService");helloService.sayHello();</code></pre><h1 class=pgc-h-arrow-right>如何在web環境中配置applicationContext.xml文件</h1><p><br></p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e6ae6633f4944e579e59e65a75930d7d><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>如何在spring中實現國際化</h1><p>在applicationContext.xml加載一個bean</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1b3c66360c524ed5b20470571504da48><p class=pgc-img-caption></p></div><p>? 在src目錄下建多個properties文件</p><p>? 對於非英文的要用native2ascii -encoding gb2312 源 目轉化文件相關內容</p><p>? 其命名格式是message_語言_國家。</p><p>? 頁面中的中顯示提示信息，鍵名取鍵值。</p><p>? 當給定國家，系統會自動加載對應的國家的properties信息。</p><p>? 通過applictionContext.getMessage(“鍵名”,”參數”,”區域”)取出相關的信息。</p><h1 class=pgc-h-arrow-right>Spring如何處理線程併發問題</h1><p><strong>Spring使用ThreadLocal解決線程安全問題</strong></p><p>我們知道在一般情況下，只有無狀態的Bean才可以在多線程環境下共享，在Spring中，絕大部分Bean都可以聲明為singleton作用域。就是因為Spring對一些Bean(如RequestContextHolder、TransactionSynchronizationManager、LocaleContextHolder等)中非線程安全狀態採用ThreadLocal進行處理，讓它們也成為線程安全的狀態，因為有狀態的Bean就可以在多線程中共享了。</p><p>ThreadLocal和線程同步機制都是為了解決多線程中相同變量的訪問衝突問題。</p><p>在同步機制中，通過對象的鎖機制保證同一時間只有一個線程訪問變量。這時該變量是多個線程共享的，使用同步機制要求程序慎密地分析什麼時候對變量進行讀寫，什麼時候需要鎖定某個對象，什麼時候釋放對象鎖等繁雜的問題，程序設計和編寫難度相對較大。</p><p>而ThreadLocal則從另一個角度來解決多線程的併發訪問。ThreadLocal會為每一個線程提供一個獨立的變量副本，從而隔離了多個線程對數據的訪問衝突。因為每一個線程都擁有自己的變量副本，從而也就沒有必要對該變量進行同步了。ThreadLocal提供了線程安全的共享對象，在編寫多線程代碼時，可以把不安全的變量封裝進ThreadLocal。</p><p>由於ThreadLocal中可以持有任何類型的對象，低版本JDK所提供的get()返回的是Object對象，需要強制類型轉換。但JDK5.0通過泛型很好的解決了這個問題，在一定程度地簡化ThreadLocal的使用。</p><p>概括起來說，對於多線程資源共享的問題，同步機制採用了“以時間換空間”的方式，而ThreadLocal採用了“以空間換時間”的方式。前者僅提供一份變量，讓不同的線程排隊訪問，而後者為每一個線程都提供了一份變量，因此可以同時訪問而互不影響。</p><h1 class=pgc-h-arrow-right>簡單敘述一下Spring 中BeanFactory與ApplicationContext的差別</h1><p>使用 BeanFactory 從 xml配置文件加載bean:</p><div class=pgc-img><img alt=深入理解微服務架構spring的各個知識點（面試必問知識點） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f8c0038de1e744acb10bfe97b26ca222><p class=pgc-img-caption></p></div><p>簡而言之，BeanFactory 提供了配置框架和基本的功能， 而ApplicationContext 為它增加了更強的功能，這些功能中的一些或許更加接近J2EE 並且圍繞企業級應用。一般來說，ApplicationContext是 BeanFactory 的完全超集， 任何 BeanFactory 功能和行為的描述也同樣被認為適用於ApplicationContext</p><p>相對於 BeanFactory 而言,ApplicationContext 提供了以下擴展功能.</p><p>(a) 國際化支持</p><p>(b) 資源訪問</p><p>(c) 事件傳播</p><p>(d) 多實例加載</p><p></p><p><strong>關注我，私信回覆“馬士兵”獲取更多視頻、源碼、筆記資料</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>知識點</a></li><li><a>務架構</a></li><li><a>spring</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/65a60d8c.html alt=常用機械設計知識點總結01 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65a60d8c.html title=常用機械設計知識點總結01>常用機械設計知識點總結01</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b9d1da16.html alt=知識點——糖類的種類、作用和分類依據 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/01bed2d5-5a86-4c59-ba91-7659769138a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b9d1da16.html title=知識點——糖類的種類、作用和分類依據>知識點——糖類的種類、作用和分類依據</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d79906e0.html alt=知識點｜八種鋼筋分不清楚？進來看看就懂了~ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d79906e0.html title=知識點｜八種鋼筋分不清楚？進來看看就懂了~>知識點｜八種鋼筋分不清楚？進來看看就懂了~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/21cb54e7.html alt=初中地理知識點思維導圖——地球的運動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15392386329391392abaf93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/21cb54e7.html title=初中地理知識點思維導圖——地球的運動>初中地理知識點思維導圖——地球的運動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dce1f09.html alt=高考地理知識點總結―地球的自轉 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0453497a2cd041369b4075543c4d3795 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dce1f09.html title=高考地理知識點總結―地球的自轉>高考地理知識點總結―地球的自轉</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcecf760.html alt=買馬桶，知道這些知識點，不花冤枉錢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/21e259cea41a4420a8bb57f878895926 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcecf760.html title=買馬桶，知道這些知識點，不花冤枉錢>買馬桶，知道這些知識點，不花冤枉錢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4f4308be.html alt=知識點｜“重疊”現象的綜合練習 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/435e33a0973d4647bf16059cf8f6eb85 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4f4308be.html title=知識點｜“重疊”現象的綜合練習>知識點｜“重疊”現象的綜合練習</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b76a9a3.html alt=「知識點」你應該瞭解的鋼材基本常識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e6f56fef-def1-47d4-aa44-572cb98817d4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b76a9a3.html title=「知識點」你應該瞭解的鋼材基本常識>「知識點」你應該瞭解的鋼材基本常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1e12a0f4.html alt=給排水專業知識點彙總—樹上鳥教育 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66c70003746a24d4bc7d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1e12a0f4.html title=給排水專業知識點彙總—樹上鳥教育>給排水專業知識點彙總—樹上鳥教育</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e96854f9.html alt="spring & mybatis參數值注入" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/90d335c5a41b4021a42ac229bb17fec5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e96854f9.html title="spring & mybatis參數值注入">spring & mybatis參數值注入</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/788a41ea.html alt=二級小知識點，確定不看嗎？（二叉樹的儲存方式） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cde1cc7470bc4a7ab3b6260d087ec2da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/788a41ea.html title=二級小知識點，確定不看嗎？（二叉樹的儲存方式）>二級小知識點，確定不看嗎？（二叉樹的儲存方式）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17461e52.html alt=分享一個小知識點，二叉樹的幾種遍歷方法(遞歸實現) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17461e52.html title=分享一個小知識點，二叉樹的幾種遍歷方法(遞歸實現)>分享一個小知識點，二叉樹的幾種遍歷方法(遞歸實現)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d3f791b.html alt=瞭解這些知識點，根據石頭物料選擇破碎設備不再困難Z94 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d3f791b.html title=瞭解這些知識點，根據石頭物料選擇破碎設備不再困難Z94>瞭解這些知識點，根據石頭物料選擇破碎設備不再困難Z94</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/30803c69.html alt=《生產技術》知識點：衝壓（剪）機械安全技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/66bb00028c172db90804 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/30803c69.html title=《生產技術》知識點：衝壓（剪）機械安全技術>《生產技術》知識點：衝壓（剪）機械安全技術</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>