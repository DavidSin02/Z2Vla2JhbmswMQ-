<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>java處理高併發高負載類網站的優化方法 | 极客快訊</title><meta property="og:title" content="java處理高併發高負載類網站的優化方法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/18b3afd6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18b3afd6.html><meta property="article:published_time" content="2020-10-29T21:12:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:37+08:00"><meta name=Keywords content><meta name=description content="java處理高併發高負載類網站的優化方法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/18b3afd6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>java處理高併發高負載類網站的優化方法</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>java處理高併發高負載類網站中數據庫的設計方法（java教程,java處理大量數據，java高負載數據）</p><p><strong>一：高併發高負載類網站關注點之數據庫</strong></p><p>沒錯,首先是數據庫,這是大多數應用所面臨的首個SPOF。尤其是Web2.0的應用，數據庫的響應是首先要解決的。</p><p>一般來說MySQL是最常用的，可能最初是一個mysql主機，當數據增加到100萬以上，那麼，MySQL的效能急劇下降。常用的優化措施是M-S（主-從）方式進行同步複製，將查詢和操作和分別在不同的服務器上進行操作。我推薦的是M-M-Slaves方式，2個主Mysql，多個Slaves，需要注意的是，雖然有2個Master，但是同時只有1個是Active，我們可以在一定時候切換。之所以用2個M，是保證M不會又成為系統的SPOF。</p><p>Slaves可以進一步負載均衡，可以結合LVS,從而將select操作適當的平衡到不同的slaves上。</p><p>以上架構可以抗衡到一定量的負載，但是隨著用戶進一步增加，你的用戶表數據超過1千萬，這時那個M變成了SPOF。你不能任意擴充Slaves，否則複製同步的開銷將直線上升，怎麼辦？我的方法是表分區，從業務層面上進行分區。最簡單的，以用戶數據為例。根據一定的切分方式，比如id，切分到不同的數據庫集群去。</p><p>全局數據庫用於meta數據的查詢。缺點是每次查詢，會增加一次，比如你要查一個用戶nightsailer,你首先要到全局數據庫群找到nightsailer對應的cluster id，然後再到指定的cluster找到nightsailer的實際數據。</p><p>每個cluster可以用m-m方式，或者m-m-slaves方式。這是一個可以擴展的結構，隨著負載的增加，你可以簡單的增加新的mysql cluster進去。</p><p>需要注意的是：</p><p>1、禁用全部auto_increment的字段</p><p>2、id需要採用通用的算法集中分配</p><p>3、要具有比較好的方法來監控mysql主機的負載和服務的運行狀態。如果你有30臺以上的mysql數據庫在跑就明白我的意思了。</p><p>4、不要使用持久性鏈接（不要用pconnect）,相反，使用sqlrelay這種第三方的數據庫鏈接池，或者乾脆自己做，因為php4中mysql的鏈接池經常出問題。</p><p><strong>二：高併發高負載網站的系統架構之HTML靜態化</strong></p><p>其實大家都知道，效率最高、消耗最小的就是純靜態化 http://www.ablanxue.com/shtml/201207/776.shtml的html頁面，所以我們儘可能使我們的網站上的頁面採用靜態頁面來實現，這個最簡單的方法其實也是 最有效的方法。但是對於大量內容並且頻繁更新的網站，我們無法全部手動去挨個實現，於是出現了我們常見的信息發佈系統CMS，像我們常訪問的各個門戶站點 的新聞頻道，甚至他們的其他頻道，都是通過信息發佈系統來管理和實現的，信息發佈系統可以實現最簡單的信息錄入自動生成靜態頁面，還能具備頻道管理、權限 管理、自動抓取等功能，對於一個大型網站來說，擁有一套高效、可管理的CMS是必不可少的。</p><p>除了門戶和信息發佈類型的網站，對於交互性要求很高的社區類型網站來說，儘可能的靜態化也是提高性能的必要手段，將社區內的帖子、文章進行實時的靜態化，有更新的時候再重新靜態化也是大量使用的策略，像Mop的大雜燴就是使用了這樣的策略，網易社區等也是如此。</p><p>同時，html靜態化也是某些緩存策略使用的手段，對於系統中頻繁使用數據庫查詢但是內容更新很小的應用，可以考慮使用html靜態化來實現，比如論壇 中論壇的公用設置信息，這些信息目前的主流論壇都可以進行後臺管理並且存儲再數據庫中，這些信息其實大量被前臺程序調用，但是更新頻率很小，可以考慮將這 部分內容進行後臺更新的時候進行靜態化，這樣避免了大量的數據庫訪問請求高併發。</p><p>網站HTML靜態化解決方案</p><p>當一個Servlet資源請求到達WEB服務器之後我們會填充指定的JSP頁面來響應請求:</p><p>HTTP請求---Web服務器---Servlet--業務邏輯處理--訪問數據--填充JSP--響應請求</p><p>HTML靜態化之後:</p><p>HTTP請求---Web服務器---Servlet--HTML--響應請求</p><p>靜態訪求如下</p><p>Servlet:</p><p>public void doGet(HttpServletRequest request, HttpServletResponse response)</p><p>throws ServletException, IOException {</p><p>if(request.getParameter("chapterId") != null){</p><p>String chapterFileName = "bookChapterRead_"+request.getParameter("chapterId")+".html";</p><p>String chapterFilePath = getServletContext().getRealPath("/") + chapterFileName;</p><p>File chapterFile = new File(chapterFilePath);</p><p>if(chapterFile.exists()){response.sendRedirect(chapterFileName);return;}//如果有這個文件就告訴瀏覽器轉向</p><p>INovelChapterBiz novelChapterBiz = new NovelChapterBizImpl();</p><p>NovelChapter novelChapter = novelChapterBiz.searchNovelChapterById(Integer.parseInt(request.getParameter("chapterId")));//章節信息</p><p>int lastPageId = novelChapterBiz.searchLastCHapterId(novelChapter.getNovelId().getId(), novelChapter.getId());</p><p>int nextPageId = novelChapterBiz.searchNextChapterId(novelChapter.getNovelId().getId(), novelChapter.getId());</p><p>request.setAttribute("novelChapter", novelChapter);</p><p>request.setAttribute("lastPageId", lastPageId);</p><p>request.setAttribute("nextPageId", nextPageId);</p><p>new CreateStaticHTMLPage().createStaticHTMLPage(request, response, getServletContext(),</p><p>chapterFileName, chapterFilePath, "/bookRead.jsp");</p><p>}</p><p>}</p><p>生成HTML靜態頁面的類:</p><p>package com.jb.y2t034.thefifth.web.servlet;</p><p>import java.io.ByteArrayOutputStream;</p><p>import java.io.FileOutputStream;</p><p>import java.io.IOException;</p><p>import java.io.OutputStreamWriter;</p><p>import java.io.PrintWriter;</p><p>import javax.servlet.RequestDispatcher;</p><p>import javax.servlet.ServletContext;</p><p>import javax.servlet.ServletException;</p><p>import javax.servlet.ServletOutputStream;</p><p>import javax.servlet.http.HttpServletRequest;</p><p>import javax.servlet.http.HttpServletResponse;</p><p>import javax.servlet.http.HttpServletResponseWrapper;</p><p>/**</p><p>* 創建HTML靜態頁面</p><p>* 功能：創建HTML靜態頁面</p><p>* 時間：2009年1011日</p><p>* 地點：home</p><p>* @author mavk</p><p>*</p><p>*/</p><p>public class CreateStaticHTMLPage {</p><p>/**</p><p>* 生成靜態HTML頁面的方法</p><p>* @param request 請求對象</p><p>* @param response 響應對象</p><p>* @param servletContext Servlet上下文</p><p>* @param fileName 文件名稱</p><p>* @param fileFullPath 文件完整路徑</p><p>* @param jspPath 需要生成靜態文件的JSP路徑(相對即可)</p><p>* @throws IOException</p><p>* @throws ServletException</p><p>*/</p><p>public void createStaticHTMLPage(HttpServletRequest request, HttpServletResponse response,ServletContext servletContext,String fileName,String fileFullPath,String jspPath) throws ServletException, IOException{</p><p>response.setContentType("text/html;charset=gb2312");//設置HTML結果流編碼(即HTML文件編碼)</p><p>RequestDispatcher rd = servletContext.getRequestDispatcher(jspPath);//得到JSP資源</p><p>final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();//用於從ServletOutputStream中接收資源</p><p>final ServletOutputStream servletOuputStream = new ServletOutputStream(){//用於從HttpServletResponse中接收資源</p><p>public void write(byte[] b, int off,int len){</p><p>byteArrayOutputStream.write(b, off, len);</p><p>}</p><p>public void write(int b){</p><p>byteArrayOutputStream.write(b);</p><p>}</p><p>};</p><p>final PrintWriter printWriter = new PrintWriter(new OutputStreamWriter(byteArrayOutputStream));//把轉換字節流轉換成字符流</p><p>HttpServletResponse httpServletResponse = new HttpServletResponseWrapper(response){//用於從response獲取結果流資源(重寫了兩個方法)</p><p>public ServletOutputStream getOutputStream(){</p><p>return servletOuputStream;</p><p>}</p><p>public PrintWriter getWriter(){</p><p>return printWriter;</p><p>}</p><p>};</p><p>rd.include(request, httpServletResponse);//發送結果流</p><p>printWriter.flush();//刷新緩衝區，把緩衝區的數據輸出</p><p>FileOutputStream fileOutputStream = new FileOutputStream(fileFullPath);</p><p>byteArrayOutputStream.writeTo(fileOutputStream);//把byteArrayOuputStream中的資源全部寫入到fileOuputStream中</p><p>fileOutputStream.close();//關閉輸出流，並釋放相關資源</p><p>response.sendRedirect(fileName);//發送指定文件流到客戶端</p><p>}</p><p>}</p><p><strong>三：高併發高負載類網站關注點之緩存、負載均衡、存儲</strong></p><p>緩存是另一個大問題，我一般用memcached來做緩存集群，一般來說部署10臺左右就差不多（10g內存池）。需要注意一點，千萬不能用使用</p><p>swap，最好關閉linux的swap。</p><p>負載均衡/加速</p><p>可能上面說緩存的時候，有人第一想的是頁面靜態化，所謂的靜態html，我認為這是常識，不屬於要點了。頁面的靜態化隨之帶來的是靜態服務的</p><p>負載均衡和加速。我認為Lighttped+Squid是最好的方式了。</p><p>LVS &lt;------->lighttped====>squid(s) ====lighttpd</p><p>上面是我經常用的。注意，我沒有用apache，除非特定的需求，否則我不部署apache，因為我一般用php-fastcgi配合lighttpd,</p><p>性能比apache+mod_php要強很多。</p><p>squid的使用可以解決文件的同步等等問題，但是需要注意，你要很好的監控緩存的命中率，儘可能的提高的90%以上。</p><p>squid和lighttped也有很多的話題要討論，這裡不贅述。</p><p>存儲</p><p>存儲也是一個大問題，一種是小文件的存儲，比如圖片這類。另一種是大文件的存儲，比如搜索引擎的索引，一般單文件都超過2g以上。</p><p>小文件的存儲最簡單的方法是結合lighttpd來進行分佈。或者乾脆使用Redhat的GFS，優點是應用透明，缺點是費用較高。我是指</p><p>你購買盤陣的問題。我的項目中，存儲量是2-10Tb，我採用了分佈式存儲。這裡要解決文件的複製和冗餘。</p><p>這樣每個文件有不同的冗餘，這方面可以參考google的gfs的論文。</p><p>大文件的存儲，可以參考nutch的方案，現在已經獨立為hadoop子項目。(你可以google it)</p><p>其他：</p><p>此外，passport等也是考慮的，不過都屬於比較簡單的了。</p><p><strong>四：高併發高負載網站的系統架構之圖片服務器分離</strong></p><p>大家知道，對於Web 服務器來說，不管是Apache、IIS還是其他容器，圖片是最消耗資源的，於是我們有必要將圖片與頁面進行分離，這是基本上大型網站都會採用的策略，他 們都有獨立的圖片服務器，甚至很多臺圖片服務器。這樣的架構可以降低提供頁面訪問請求的服務器系統壓力，並且可以保證系統不會因為圖片問題而崩潰，在應用 服務器和圖片服務器上，可以進行不同的配置優化，比如apache在配置ContentType的時候可以儘量少支持，儘可能少的LoadModule， 保證更高的系統消耗和執行效率。</p><p>利用Apache實現圖片服務器的分離</p><p>緣由：</p><p>起步階段的應用，都可能部署在一臺服務器上（費用上的原因）</p><p>第一個優先分離的，肯定是數據庫和應用服務器。</p><p>第二個分離的，會是什麼呢？各有各的考慮，我所在的項目組重點考慮的節約帶寬，服務器性能再好，帶寬再高，併發來了，也容易撐不住。因此，我這篇文章的重點在這裡。這裡重點是介紹實踐，不一定符合所有情況，供看者參考吧，</p><p>環境介紹：</p><p>WEB應用服務器：4CPU雙核2G, 內存4G</p><p>部署：Win2003/Apache Http Server 2.1/Tomcat6</p><p>數據庫服務器：4CPU雙核2G, 內存4G</p><p>部署：Win2003/MSSQL2000</p><p>步驟：</p><p>步驟一：增加2臺配置為：2CPU雙核2G，內存2G普通服務器，做資源服務器</p><p>部署：Tomcat6，跑了一個圖片上傳的簡單應用，（記得指定web.xml的&lt;distributable/>），並指定域名為res1.***.com,res2.***.com，採用ajp協議</p><p>步驟二：修改Apache httpd.conf配置</p><p>原來應用的文件上傳功能網址為：</p><p>1、/fileupload.html</p><p>2、/otherupload.html</p><p>在httpd.conf中增加如下配置</p><p>&lt;VirtualHost *:80></p><p>ServerAdmin webmaster@***.com</p><p>ProxyPass /fileupload.html balancer://rescluster/fileupload lbmethod=byrequests stickysession=JSESSIONID nofailover=Off timeout=5 maxattempts=3</p><p>ProxyPass /otherupload.html balancer://rescluster/otherupload.html lbmethod=byrequests stickysession=JSESSIONID nofailover=Off timeout=5 maxattempts=3</p><p>#&lt;!--負載均衡--></p><p>&lt;Proxy balancer://rescluster/></p><p>BalancerMember ajp://res1.***.com:8009 smax=5 max=500 ttl=120 retry=300 loadfactor=100 route=tomcat1</p><p>BalancerMember ajp://res2.***.com:8009 smax=5 max=500 ttl=120 retry=300 loadfactor=100 route=tomcat2</p><p>&lt;/Proxy></p><p>&lt; /VirtualHost></p><p>步驟三，修改業務邏輯：</p><p>所有上傳文件在數據庫中均採用全url的方式保存，例如產品圖片路徑存成：http://res1.***.com/upload/20090101/product120302005.jpg</p><p>現在，你可以高枕無憂了，帶寬不夠時，增加個幾十臺圖片服務器，只需要稍微修改一下apache的配置文件，即可。</p><p><strong>五：高併發高負載網站的系統架構之數據庫集群和庫表散列</strong></p><p>大型網站都有複雜的應用，這些應用必須使用數據庫，那麼在面對大量訪問的時候，數據庫的瓶頸很快就能顯現出來，這時一臺數據庫將很快無法滿足應用，於是我們需要使用數據庫集群或者庫表散列。</p><p>在數據庫集群方面，很多數據庫都有自己的解決方案，Oracle、Sybase等都有很好的方案，常用的MySQL提供的Master/Slave也是類似的方案，您使用了什麼樣的DB，就參考相應的解決方案來實施即可。</p><p>上面提到的數據庫集群由於在架構、成本、擴張性方面都會受到所採用DB類型的限制，於是我們需要從應用程序的角度來考慮改善系統架構，庫表散列是常用並 且最有效的解決方案。我們在應用程序中安裝業務和應用或者功能模塊將數據庫進行分離，不同的模塊對應不同的數據庫或者表，再按照一定的策略對某個頁面或者 功能進行更小的數據庫散列，比如用戶表，按照用戶ID進行表散列，這樣就能夠低成本的提升系統的性能並且有很好的擴展性。sohu的論壇就是採用了這樣的 架構，將論壇的用戶、設置、帖子等信息進行數據庫分離，然後對帖子、用戶按照板塊和ID進行散列數據庫和表，最終可以在配置文件中進行簡單的配置便能讓系 統隨時增加一臺低成本的數據庫進來補充系統性能。</p><p>集群軟件的分類：</p><p>一般來講，集群軟件根據側重的方向和試圖解決的問題，分為三大類：高性能集群（High performance cluster，HPC）、負載均衡集群（Load balance cluster， LBC），高可用性集群（High availability cluster，HAC）。</p><p>高性能集群（High performance cluster，HPC），它是利用一個集群中的多臺機器共同完成同一件任務，使得完成任務的速度和可靠性都遠遠高於單機運行的效果。彌補了單機性能上的不足。該集群在天氣預報、環境監控等數據量大，計算複雜的環境中應用比較多；</p><p>負載均衡集群（Load balance cluster， LBC），它是利用一個集群中的多臺單機，完成許多並行的小的工作。一般情況下，如果一個應用使用的人多了，那麼用戶請求的響應時間就會增大，機器的性能也會受到影響，如果使用負載均衡集群，那麼集群中任意一臺機器都能響應用戶的請求，這樣集群就會在用戶發出服務請求之後，選擇當時負載最小，能夠提供最好的服務的這臺機器來接受請求並相應，這樣就可用用集群來增加系統的可用性和穩定性。這類集群在網站中使用較多；</p><p>高可用性集群（High availability cluster，HAC），它是利用集群中系統 的冗餘，當系統中某臺機器發生損壞的時候，其他後備的機器可以迅速的接替它來啟動服務，等待故障機的維修和返回。最大限度的保證集群中服務的可用性。這類系統一般在銀行，電信服務這類對系統可靠性有高的要求的領域有著廣泛的應用。</p><p>2 數據庫集群的現狀</p><p>數據庫集群是將計算機集群技術引入到數據庫中來實現的，儘管各廠商宣稱自己的架構如何的完美，但是始終不能改變Oracle當先，大家追逐的事實，在集群的解決方案上Oracle RAC還是領先於包括微軟在內的其它數據庫廠商，它能滿足客戶高可用性、高性能、數據庫負載均衡和方便擴展的需求。</p><p>Oracle’s Real Application Cluster (RAC)</p><p>Microsoft SQL Cluster Server (MSCS)</p><p>IBM’s DB2 UDB High Availability Cluster(UDB)</p><p>Sybase ASE High Availability Cluster (ASE)</p><p>MySQL High Availability Cluster (MySQL CS)</p><p>基於IO的第三方HA(高可用性)集群</p><p>當前主要的數據庫集群技術有以上六大類，有數據庫廠商自己開發的；也有第三方的集群公司開發的；還有數據庫廠商與第三方集群公司合作開發的，各類集群實現的功能及架構也不盡相同。</p><p>RAC（Real Application Cluster，真正應用集群）是Oracle9i數據庫中採用的一項新技術，也是Oracle數據庫支持網格計算環境的核心技術。它的出現解決了傳統數據庫應用中面臨的一個重要問題：高性能、高可伸縮性與低價格之間的矛盾。在很長一段時間裡，甲骨文都以其實時應用集群技術(Real Application Cluster，RAC)統治著集群數據庫市場</p><p><strong>六：高併發高負載網站的系統架構之緩存</strong></p><p>緩存一詞搞技術的都接觸過，很多地方用到緩存。網站架構和網站開發中的緩存也是非常重要。這裡先講述最基本的兩種緩存。高級和分佈式的緩存在後面講述。</p><p>架構方面的緩存，對Apache比較熟悉的人都能知道Apache提供了自己的緩存模塊，也可以使用外加的Squid模塊進行緩存，這兩種方式均可以有效的提高Apache的訪問響應能力。</p><p>網站程序開發方面的緩存，Linux上提供的Memory Cache是常用的緩存接口，可以在web開發中使用，比如用Java開發的時候就可以調用MemoryCache對一些數據進行緩存和通訊共享，一些大 型社區使用了這樣的架構。另外，在使用web語言開發的時候，各種語言基本都有自己的緩存模塊和方法，PHP有Pear的Cache模塊，Java就更多 了，.net不是很熟悉，相信也肯定有。</p><p>Java開源緩存框架</p><p>JBossCache/TreeCache JBossCache是一個複製的事務處理緩存，它允許你緩存企業級應用數據來更好的改善性能。緩存數據被自動複製，讓你輕鬆進行Jboss服務器之間的集群工作。JBossCache能夠通過Jboss應用服務或其他J2EE容器來運行一個Mbean服務，當然，它也能獨立運行。 JBossCache包括兩個模塊：TreeCache和TreeCacheAOP。 TreeCache --是一個樹形結構複製的事務處理緩存。 TreeCacheAOP --是一個“面向對象”緩存，它使用AOP來動態管理POJO</p><p>OSCache OSCache標記庫由OpenSymphony設計，它是一種開創性的JSP定製標記應用，提供了在現有JSP頁面之內實現快速內存緩衝的功能。OSCache是個一個廣泛採用的高性能的J2EE緩存框架，OSCache能用於任何Java應用程序的普通的緩存解決方案。OSCache有以下特點：緩存任何對象，你可以不受限制的緩存部分jsp頁面或HTTP請求，任何java對象都可以緩存。 擁有全面的API--OSCache API給你全面的程序來控制所有的OSCache特性。 永久緩存--緩存能隨意的寫入硬盤，因此允許昂貴的創建（expensive-to-create）數據來保持緩存，甚至能讓應用重啟。 支持集群--集群緩存數據能被單個的進行參數配置，不需要修改代碼。 緩存記錄的過期--你可以有最大限度的控制緩存對象的過期，包括可插入式的刷新策略（如果默認性能不需要時）。</p><p>JCACHE JCACHE是一種即將公佈的標準規範（JSR 107），說明了一種對Java對象臨時在內存中進行緩存的方法，包括對象的創建、共享訪問、假脫機（spooling）、失效、各JVM的一致性等。它可被用於緩存JSP內最經常讀取的數據，如產品目錄和價格列表。利用JCACHE，多數查詢的反應時間會因為有緩存的數據而加快（內部測試表明反應時間大約快15倍）。</p><p>Ehcache Ehcache出自Hibernate，在Hibernate中使用它作為數據緩存的解決方案。</p><p>Java Caching System JCS是Jakarta的項目Turbine的子項目。它是一個複合式的緩衝工具。可以將對象緩衝到內存、硬盤。具有緩衝對象時間過期設定。還可以通過JCS構建具有緩衝的分佈式構架，以實現高性能的應用。 對於一些需要頻繁訪問而每訪問一次都非常消耗資源的對象，可以臨時存放在緩衝區中，這樣可以提高服務的性能。而JCS正是一個很好的緩衝工具。緩衝工具對於讀操作遠遠多於寫操作的應用性能提高非常顯著。</p><p>SwarmCache SwarmCache是一個簡單而功能強大的分佈式緩存機制。它使用IP組播來有效地在緩存的實例之間進行通信。它是快速提高集群式Web應用程序的性能的理想選擇。</p><p>ShiftOne ShiftOne Object Cache這個Java庫提供了基本的對象緩存能力。實現的策略有先進先出（FIFO），最近使用（LRU），最不常使用（LFU）。所有的策略可以最大化元素的大小，最大化其生存時間。</p><p>WhirlyCache Whirlycache是一個快速的、可配置的、存在於內存中的對象的緩存。它能夠通過緩存對象來加快網站或應用程序的速度，否則就必須通過查詢數據庫或其他代價較高的處理程序來建立。</p><p>Jofti Jofti可對在緩存層中(支持EHCache，JBossCache和OSCache)的對象或在支持Map接口的存儲結構中的對象進行索引與搜索。這個框架還為對象在索引中的增刪改提供透明的功能同樣也為搜索提供易於使用的查詢功能。</p><p>cache4j cache4j是一個有簡單API與實現快速的Java對象緩存。它的特性包括：在內存中進行緩存，設計用於多線程環境，兩種實現：同步與阻塞，多種緩存清除策略：LFU, LRU, FIFO，可使用強引用(strong reference)與軟引用(soft reference)存儲對象。</p><p>Open Terracotta 一個JVM級的開源群集框架，提供：HTTP Session複製，分佈式緩存，POJO群集，跨越群集的JVM來實現分佈式應用程序協調(採用代碼注入的方式，所以你不需要修改任何)。</p><p>sccache SHOP.COM使用的對象緩存系統。sccache是一個in-process cache和二級、共享緩存。它將緩存對象存儲到磁盤上。支持關聯Key，任意大小的Key和任意大小的數據。能夠自動進行垃圾收集。</p><p>Shoal Shoal是一個基於Java可擴展的動態集群框架，能夠為構建容錯、可靠和可用的Java應用程序提供了基礎架構支持。這個框架還可以集成到不希望綁定到特定通信協議，但需要集群和分佈式系統支持的任何Java產品中。Shoal是GlassFish和JonAS應用服務器的集群引擎。</p><p>Simple-Spring-Memcached Simple-Spring-Memcached，它封裝了對MemCached的調用，使MemCached的客戶端開發變得超乎尋常的簡單。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>java</a></li><li><a>處理</a></li><li><a>發高</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/16ab9720.html alt=java線程池處理多併發，所有進程執行完後再統一處理結果 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/b0473c60-cc05-42ed-82b1-497bfe51bfcc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16ab9720.html title=java線程池處理多併發，所有進程執行完後再統一處理結果>java線程池處理多併發，所有進程執行完後再統一處理結果</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0aac9c6.html alt=java中的異步處理和Feature接口 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153785294639350e351ec64 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0aac9c6.html title=java中的異步處理和Feature接口>java中的異步處理和Feature接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html alt=MySql併發與事務的處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f13d8a1e-5e60-4b48-90bc-3c26e312a208 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/011d2da0.html title=MySql併發與事務的處理>MySql併發與事務的處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html alt=java相關知識(10)總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/84649e6ba0f8442a8b10584403bf6635 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69818103.html title=java相關知識(10)總結>java相關知識(10)總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html alt=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d3c48fcc.html title=Spring聲明式事務處理的實現原理，來自面試官的窮追拷問>Spring聲明式事務處理的實現原理，來自面試官的窮追拷問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html alt=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d69c7c9d8b85444da9360e334ba6555d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/02729303.html title=java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID>java實戰項目常用類，Date、Calendar、BigDecimal、Math、UUID</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html alt=多態的本質，java動態綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ac000493fbc8532b5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f8b26e0.html title=多態的本質，java動態綁定>多態的本質，java動態綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/160af1cf.html alt=牆面基層處理有哪些基本步驟 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RZdKr6O1pG4jKu style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/160af1cf.html title=牆面基層處理有哪些基本步驟>牆面基層處理有哪些基本步驟</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf790e4b.html alt=地面基層處理是什麼意思？地面基層清理方法及注意事項有哪些 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/339700cdb9c04fdd98fcc3e95cdc166c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf790e4b.html title=地面基層處理是什麼意思？地面基層清理方法及注意事項有哪些>地面基層處理是什麼意思？地面基層清理方法及注意事項有哪些</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44c6d5cb.html alt=豎向鋼筋位移施工加固處理措施 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a7d965c73c1542978ae9091d6bf34aa9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44c6d5cb.html title=豎向鋼筋位移施工加固處理措施>豎向鋼筋位移施工加固處理措施</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6720a0ac.html alt=殷佔堂：再談日本垃圾處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d101ab3a11348a9ad723bf8df3accb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6720a0ac.html title=殷佔堂：再談日本垃圾處理>殷佔堂：再談日本垃圾處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3844d7f0.html alt=幹熄焦事故處理及案例分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4f2463465a6a4c5fb2e8f708400ba596 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3844d7f0.html title=幹熄焦事故處理及案例分析>幹熄焦事故處理及案例分析</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>