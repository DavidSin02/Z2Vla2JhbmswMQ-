<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>編程能力層次模型 | 极客快訊</title><meta property="og:title" content="編程能力層次模型 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/c8de3e70-539e-48ae-a697-2dc58f985804"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/18c3b05.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/18c3b05.html><meta property="article:published_time" content="2020-10-29T21:04:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:55+08:00"><meta name=Keywords content><meta name=description content="編程能力層次模型"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/18c3b05.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>編程能力層次模型</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=編程能力層次模型 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/c8de3e70-539e-48ae-a697-2dc58f985804><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify><strong>前言</strong></p><p class=ql-align-justify>程序員的編程技能隨著經驗的積累，會逐步提高。我認為編程能力可以分為一些層次。</p><p class=ql-align-center><br></p><p class=ql-align-justify>下面通過兩個維度展開編程能力層次模型的討論。</p><p class=ql-align-justify>一個維度是編程技能層次，另一個維度是領域知識層次。</p><p class=ql-align-justify><strong>編程技能層次</strong></p><p class=ql-align-justify>編程技能層次，指的程序員設計和編寫程序的能力。這是程序員的根本。</p><p class=ql-align-justify><strong>0段—非程序員</strong>：</p><p class=ql-align-justify>初學編程者，遇到問題，完全是懵懵懂懂，不知道該怎麼編程解決問題。也就是說，還是門外漢，還不能稱之為“程序員”。計算機在他面前還是一個神祕的黑匣子。</p><p class=ql-align-justify><strong>1段—基礎程序員</strong></p><p class=ql-align-justify>學習過一段時間編程後，接到任務，可以編寫程序完成任務。</p><p class=ql-align-justify>編寫出來的代碼，正常情況下是能夠工作的，但在實際運行中，碰到一些特殊條件就會出現各類BUG。也就是說，具備了開發Demo軟件的能力，但開發的軟件真正交付給客戶使用，恐怕會被客戶罵死。</p><p class=ql-align-justify>程序員程序是寫好了，但到底為什麼它有時能正常工作，有時又不行，程序員自己也不知道。</p><p class=ql-align-justify>運行中遇到了bug，或者需求改變，需要修改代碼或者添加代碼，很快程序就變得結構混亂，代碼膨脹，bug叢生。很快，就連最初的開發者自己也不願意接手維護這個程序了。</p><p class=ql-align-justify><strong>2段—數據結構</strong></p><p class=ql-align-justify>經過一段時間的編程實踐後，程序員會認識到“數據結構+算法=程序”這一古訓的含義。他們會使用算法來解決問題。進而，他們會認識到，算法本質上是依附於數據結構的，好的數據結構一旦設計出來，那麼好的算法也會應運而生。</p><p class=ql-align-justify>設計錯誤的數據結構，不可能生長出好的算法。</p><p class=ql-align-justify>記得某一位外國先賢曾經說過：“給我看你的數據結構！”</p><p class=ql-align-justify><strong>3段—面向對象</strong></p><p class=ql-align-justify>再之後，程序員就會領略面向對象程序設計的強大威力。大多數現代編程語言都是支持面向對象的。但並不是說，你使用面向對象編程語言編程，你用上了類，甚至繼承了類，你就是在寫面向對象的代碼了。</p><p class=ql-align-justify>我曾經見過很多用Java,Python,Ruby寫的面向過程的代碼。</p><p class=ql-align-justify>只有你掌握了接口，掌握了多態，掌握了類和類，對象和對象之間的關係，你才真正掌握了面向對象編程技術。</p><p class=ql-align-justify>就算你用的是傳統的不支持面向對象的編程語言，只要你心中有“對象”，你依然可以開發出面向對象的程序。</p><p class=ql-align-justify>如，我用C語言編程的時候，會有意識的使用面向對象的技巧來編寫和設計程序。用struct來模擬類，把同一類概念的函數放在一起模擬類。如果你懷疑用C語言是否能編寫出面向對象的代碼，你可以看一下Linux內核，它是用C語言編寫的，但你也可以看到它的源代碼字裡行間散發出的濃濃的“對象”的味道。</p><p class=ql-align-justify>真正掌握面向對象編程技術並不容易。</p><p class=ql-align-justify>在我的技術生涯中，有兩個坎讓我最感頭疼。</p><p class=ql-align-justify>一個坎是Dos向Windows開發的變遷過程中，框架的概念，很長一段時間我都理解不了。Dos時代，都是對函數庫的調用，你的程序主動調用函數。Windows時代，則換成了框架。就算是你的main程序，其實也是被框架調用的。UI線程會從操作系統獲取消息，然後發送給你的程序來處理。Java程序員熟悉的Spring框架，也是這樣一個反向調用的框架。</p><p class=ql-align-justify>現在因為“框架”這個術語顯得很高大上，因此很多“類庫”/“函數庫”都自稱為“框架”。在我看來這都是名稱的濫用。</p><p class=ql-align-justify>“類庫”/“函數庫”就是我寫的代碼調用它們。</p><p class=ql-align-justify>“框架”就是我註冊回調函數到框架，框架來調用我寫的函數。</p><p class=ql-align-justify>另一個坎就是面向對象。很長一段時間我都不知道應該怎麼設計類和類之間的關係，不能很好的設計出類層次結構來。</p><p class=ql-align-justify>我記得當時看到一本外國大牛的書，他講了一個很簡單、很實用的面向對象設計技巧：“敘述問題。然後把其中的名詞找出來，用來構建類。把其中的動詞找出來，用來構建類的方法”。雖然這個技巧挺管用的，但也太草根了點，沒有理論依據，也不嚴謹。如果問題敘述的不好，那麼獲得的類系統就會是有問題的。</p><p class=ql-align-justify>掌握面向對象思想的途徑應該有很多種，我是從關係數據庫中獲得了靈感來理解和掌握面向對象設計思想的。</p><p class=ql-align-justify>在我看來，關係數據庫的表，其實就是一個類，每一行記錄就是一個類的實例，也就是對象。表之間的關係，就是類之間的關係。O-Rmapping技術（如Hibernate），用於從面向對象代碼到數據庫表之間的映射，這也說明了類和表確實是邏輯上等價的。</p><p class=ql-align-justify>既然數據庫設計和類設計是等價的，那麼要設計面向對象系統，只需要使用關係數據庫的設計技巧即可。</p><p class=ql-align-justify>關係數據庫表結構設計是很簡單的：</p><p class=ql-align-justify>1，識別表和表之間的關係，也就是類和類之間的關係。是一對一，一對多，多對一，還是多對多。這就是類之間的關係。</p><p class=ql-align-justify>2，識別表的字段。一個對象當然有無數多的屬性（如，人：身高，體重，性別，年齡，姓名，身份證號，駕駛證號，銀行卡號，護照號，港澳通行證號，工號，病史，婚史etc），我們寫程序需要記錄的只是我們關心的屬性。這些關心的屬性，就是表的字段，也就是類的屬性。“弱水三千，我取一瓢飲”！</p><p class=ql-align-justify><strong>4段—設計模式</strong></p><p class=ql-align-justify>曾經在網上看到這樣一句話：“沒有十萬行代碼量，就不要跟我談什麼設計模式”。深以為然。</p><p class=ql-align-justify>記得第一次看Gof的設計模式那本書的時候，發現雖然以前並不知道設計模式，但在實際編程過程中，其實還是自覺使用了一些設計模式。設計模式是編程的客觀規律，不是誰發明的，而是一些早期的資深程序員首先發現的。</p><p class=ql-align-justify>不用設計模式，你也可以寫出滿足需求的程序來。但是，一旦後續需求變化，那麼你的程序沒有足夠的柔韌性，將難以為繼。而真實的程序，交付客戶後，一定會有進一步的需求反饋。而後續版本的開發，也一定會增加需求。這是程序員無法迴避的現實。</p><p class=ql-align-justify>寫UI程序，不論是Web,Desktop,Mobile,Game，一定要使用MVC設計模式。否則你的程序面對後續變化的UI需求，將無以為繼。</p><p class=ql-align-justify>設計模式，最重要的思想就是解耦，通過接口來解耦。這樣，如果將來需求變化，那麼只需要提供一個新的實現類即可。</p><p class=ql-align-justify>主要的設計模式，其實都是面向對象的。因此，可以認為設計模式是面向對象的高級階段。只有掌握了設計模式，才能認為是真正徹底掌握了面向對象設計技巧。</p><p class=ql-align-justify>我學習一門新語言時（包括非面嚮對象語言，如函數式編程語言），總是會在瞭解了其語法後，看一下各類設計模式在這門語言中是如何實現的。這也是學習編程語言的一個竅門。</p><p class=ql-align-justify><strong>5段--語言專家</strong></p><p class=ql-align-justify>經過一段時間的編程實踐，程序員對某一種常用的編程語言已經相當精通了。有些人還成了“語言律師”，擅長向其他程序員講解語言的用法和各種坑。</p><p class=ql-align-justify>這一階段的程序員，常常是自己所用語言的忠實信徒，常在社區和論壇上和其他語言的使用者爭論哪一種語言是最好的編程語言。他們認為自己所用的語言是世界上最好的編程語言，沒有之一。他們認為，自己所用的編程語言適用於所有場景。他們眼中，只有錘子，因此會把所有任務都當成是釘子。</p><p class=ql-align-justify><strong>6段--多語言專家</strong></p><p class=ql-align-justify>這一個階段的程序員，因為工作關係，或者純粹是因為對技術的興趣，已經學習和掌握了好幾種編程語言。已經領略了不同編程語言不同的設計思路，對每種語言的長處和短處有了更多的瞭解。</p><p class=ql-align-justify>他們現在認為，編程語言並不是最重要的，編程語言不過是基本功而已。</p><p class=ql-align-justify>他們現在會根據不同的任務需求，或者不同的資源來選擇不同的編程語言來解決問題，不再會因為沒有使用某一種喜愛的編程語言開發而埋怨。</p><p class=ql-align-justify>編程語言有很多種流派和思想，有一些編程語言同時支持多種編程範式。</p><p class=ql-align-justify><strong>靜態類型編程範式</strong></p><p class=ql-align-justify>採用靜態類型編程範式的編程語言，其變量需要明確指定類型。代表語言：C,C++,Pascal,Objective-C,Java,C#,VB.NET,Swif,Golang。</p><p class=ql-align-justify>這樣做的好處是：</p><p class=ql-align-justify>1，編譯器可以在編譯時就能找出類型錯誤。</p><p class=ql-align-justify>2，編譯器編譯時知道類型信息，就可以提高性能。</p><p class=ql-align-justify>這種範式認為，程序員肯定知道變量的類型，你丫要是不知道變量的類型，那你就別混了！編譯時，程序會報錯。</p><p class=ql-align-justify>Swift和Go語言都是靜態類型編程語言，但它們都不需要明確指定類型，而是可以通過推斷由編譯器自動確定其類型。</p><p class=ql-align-justify><strong>動態類型編程範式</strong></p><p class=ql-align-justify>採用靜態類型編程範式的編程語言，其變量不需要明確指定類型。任意變量，可以指向任意類型的對象。代表語言：Python,Ruby,JavaScript。</p><p class=ql-align-justify>動態類型的哲學可以用鴨子類型（英語：ducktyping）這個概念來概括。JamesWhitcombRiley提出的鴨子測試可以這樣表述：“當看到一隻鳥走起來像鴨子、游泳起來像鴨子、叫起來也像鴨子，那麼這隻鳥就可以被稱為鴨子。”</p><p class=ql-align-justify>這種範式認為，程序員肯定知道變量的類型和它支持的方法和屬性，你丫要是不知道變量的類型，那你就別混了！運行時程序會崩潰！程序崩潰怨誰？怨你自己唄，你不是合格的程序員！</p><p class=ql-align-justify>動態類型的好處是：</p><p class=ql-align-justify>不需要明確定義接口和抽象類型。只要一個類型支持需要的方法和屬性，那麼就OK。程序會相當靈活和簡單。C++,Java,C#視之為命脈的接口/基類，在動態語言這裡都視如無物！</p><p class=ql-align-justify>缺點是：</p><p class=ql-align-justify>1，如果類型不對，編譯器也無法找到錯誤，而是運行時程序崩潰。</p><p class=ql-align-justify>2，因為編譯器不知道變量的類型，因此無法優化性能。</p><p class=ql-align-justify><strong>面向對象編程範式</strong></p><p class=ql-align-justify>面向對象編程範式，從上世紀70年代末開始興起。它支持類和類的實例作為封裝代碼的模塊。代表語言：Smalltalk,C++,Objective-C,Java,C#,VB.NET,Swift,Go,Python,Ruby,ActionScritp,OCaml.</p><p class=ql-align-justify>早期編程語言都是面向過程的。就是順序，條件，循環，構成一個個函數。隨著代碼規模的增大，人們發現有必要對代碼進行模塊化。一個概念對應的代碼放在一個文件中，這樣便於併發開發和進行代碼管理。</p><p class=ql-align-justify>人們還發現了“程序=數據結構+算法”的規律。因此，一個概念對應的數據結構和函數應該放在一個文件中。這就是類的概念。</p><p class=ql-align-justify>面向對象編程範式，確實極大地提高了生產效率，因此得到了廣泛的應用，因此在語言層面支持面向對象編程範式的語言是極多的。</p><p class=ql-align-justify>C語言儘管在語言層面上並不支持面向對象編程範式，但現代的C語言開發都會應用面向對象的模塊化思想，把同一類的數據結構和函數放在一個文件中，採用類似的命名方式。</p><p class=ql-align-justify>畢竟C語言沒有在語言層面上支持面向對象，因此就有很多程序員想給C語言添加面向對象支持。其中的代表是C++和Objective-C。</p><p class=ql-align-justify>C++是一種新的語言，但大部分語言元素是和C兼容的。</p><p class=ql-align-justify>Objective-C是完全兼容的C的。Objective-C是給C添加了薄薄的一層語法糖以支持接口（就是其他語言的類）和協議（就是其他語言的接口）。甚至，Objective-C一開始的實現，就是一個C語言的預編譯器。Objective-C坦白講，除了添加的語法不太符合C流外，實際上其面向對象系統設計是相當精妙的。喬布斯早年慧眼識珠，把Objective-C收人囊中，因為封閉於Apple/NextStep系統內，因此少有人知。隨著iOs系統的普及，Objective-C近幾年才名滿天下。</p><p class=ql-align-justify><strong>函數式編程範式</strong></p><p class=ql-align-justify>函數式編程範式，是一些數學家發明的編程語言，他們認為程序就是數學函數嘛。代表語言：Lisp,Erlang,JavaScript,OCaml,Prog。</p><p class=ql-align-justify>有很多大牛極力鼓吹過函數式編程語言，認為其極具革命性。但我認為他們過高估計了函數式編程範式的威力，我並不認為函數式編程範式相對於面向對象編程範式有何高明之處。</p><p class=ql-align-justify>函數式編程語言，核心就是函數，它們沒有Class類的概念。但它的函數又不是傳統面向過程語言的函數，它的函數支持“閉包”的概念。</p><p class=ql-align-justify>在我看來，函數式編程語言的函數，也就是“閉包”，說白了，其實就是“類”。編程語言發展到今天，就是需要模塊化，就是需要把“數據結構”和“算法”結合起來。不論何種語言，不把它們結合起來的編程方式，都是沒有出路的。</p><p class=ql-align-justify>面向對象編程語言，用類把“數據結構”和“算法”結合起來。類的核心是“數據結構”，也就是其“屬性”，而不是“算法”，其“函數”。在類中，是函數依附於屬性。</p><p class=ql-align-justify>而函數式編程語言，用閉包把“數據結構”和“算法”結合起來。是函數能夠抓取外部的字段。是“屬性”依附於“函數”。</p><p class=ql-align-justify>“類”本質上和“閉包”是等價的。現在很多面向對象編程語言都加上了對閉包的支持。觀察其代碼，我們可以發現，它們實際上都是用“類”來實現“閉包”的。</p><p class=ql-align-justify>“類”和“閉包”誰更易用？明顯是“類”。</p><p class=ql-align-justify>而“閉包”更簡潔一些，因此“閉包”在面向對象編程語言中常用來替換匿名類。只有一個函數的類，寫成一個類太麻煩，不如寫成閉包，更加簡潔。</p><p class=ql-align-justify>吐槽一下OCaml語言，其前身Caml語言本身是一種挺好的函數式語言，硬生生添加了一套完整的面向對象機制，同時支持面向對象和函數式編程範式，很容易像C++一樣腦裂的。</p><p class=ql-align-justify>也有很多面嚮對象語言控看著JavaScript嫌煩，總是想把面向對象支持添加到JavaScript上。ActionScript就是其中一種嘗試。我用過，真的是和Java沒多少區別了。</p><p class=ql-align-justify>再吐槽一下ExtJS。當初選型Web前端開發框架時比較了ExtJS和JQuery。</p><p class=ql-align-justify>ExtJS明顯是Java高手開發的，硬生生用JavaScript模擬Swing的設計思想，搞了一套UI庫。</p><p class=ql-align-justify>JQuery開發者明顯是領悟了JavaScript的函數式編程範式，依據JavaScript的動態函數式編程語言的特點打造了一套UI庫，立刻秒殺ExtJS。</p><p class=ql-align-justify>由ExtJS和JQuery的故事，我們可以看到多語言編程能力是多麼的重要。ExtJS的作者精通並喜愛Java，因此他把手術刀JavaScript當做錘子Java使，一通亂敲，費力不討好。</p><p class=ql-align-justify>函數式編程語言，還有尾遞歸等一些小技巧。尾遞歸可以不用棧，防止遞歸調用時棧溢出。</p><p class=ql-align-justify><strong>模板編程範式</strong></p><p class=ql-align-justify>模板編程，就是把類型作為參數，一套函數可以支持任意多種類型。代表語言：C++。</p><p class=ql-align-justify>模板編程的需求，是在C++開發容器庫的時候發明的。因為容器需要保存任意類型的對象，因此就有了泛型的需求。</p><p class=ql-align-justify>C++的模板編程，是在編譯時，根據源碼中的使用情況，創建對應類型的代碼。除了C++這種方式，Java，C#也有類似的機制，叫做“泛型”，但它們的實現方式和C++的模板很不同。它們的編譯器不會生成新的代碼，而是使用強制類型轉換的方式實現。</p><p class=ql-align-justify>在沒有模板/泛型的編程語言中，怎樣在容器中存放對象呢？存取公共基類類型（Java,C#）的對象，或者void*指針（C）即可，取出時自己強制類型轉換為實際類型。動態類型語言，不關心類型，更是無所謂了，隨便什麼對象直接往容器裡扔進去，取出來直接用即可。</p><p class=ql-align-justify>一些C++高手又在模板的基礎上搞出了“模板元編程”。因為模板編程，就是C++的編譯器搞定的嘛，模板元編程就是讓編譯器運算，編譯完結果也就算出來了。我不知道除了研究和炫技，這玩意有啥用？</p><p class=ql-align-justify><strong>小結</strong></p><p class=ql-align-justify>一門語言是否值得學習，我認為有幾個標準：</p><ol><li class=ql-align-justify>是否要用，要用就得學，這麼沒有疑問的。畢竟我們都要吃飯的嘛。</li><li class=ql-align-justify>其語言特性是否給你耳目一新的感覺。如果是，那就值回票價了。如Go語言廢掉了異常，改用返回多值。我深以為然。我其實已經主動不用異常好多年了。因為，我覺得既然C不支持異常也活得很好，為什麼需要異常呢？出錯了，返回錯誤碼。無法挽回的錯誤，直接Abort程序就可以嘛！而且，異常實際上是違反面向過程編程原則的。一個函數應該只有一個入口一個出口。拋出異常就多了出口了。</li><li class=ql-align-justify>是否擅長某一個領域。如果你手裡只有一把錘子，那麼你就只能把所有任務都當做釘子猛錘一通。但如果工具箱裡有多種工具，那面對不同的任務就得心應手多了。</li></ol><p class=ql-align-justify><strong>7段—架構設計</strong></p><p class=ql-align-justify>還需要掌握架構設計的能力，才能設計出優秀的軟件。架構設計有一些技巧：</p><ol><li class=ql-align-justify>分層</li><li class=ql-align-justify>一個軟件通常分為：</li><li class=ql-align-justify>表現層--UI部分</li><li class=ql-align-justify>接口層--後臺服務的通訊接口部分</li><li class=ql-align-justify>服務層--實際服務部分</li><li class=ql-align-justify>存儲層—持久化存儲部分，存儲到文件或者數據庫。</li><li class=ql-align-justify>分層的軟件，可以解耦各個模塊，支持並行開發，易於修改，易於提升性能。</li><li class=ql-align-justify>SOA</li><li class=ql-align-justify>模塊之間通過網絡通訊互相連接，鬆耦合。每一個模塊可以獨立部署，可以增加部署實例從而提高性能。每一個模塊可以使用不同的語言和平臺開發，可以重用之前開發的服務。SOA，常用協議有WebService,REST,JSON-RPC等。</li><li class=ql-align-justify>性能瓶頸</li><li class=ql-align-justify>a.化同步為異步。</li><li class=ql-align-justify>用內存隊列（Redis），工作流引擎（JBpm）等實現。內存隊列容易丟失數據，但是速度快。工作流引擎會把請求保存到數據庫中。</li><li class=ql-align-justify>通過化同步請求為異步請求，基本上99.99%的性能問題都可以解決。</li><li class=ql-align-justify>b.用單機並行硬件處理。</li><li class=ql-align-justify>如，使用GPU，FPGA等硬件來處理，提高性能。</li><li class=ql-align-justify>c.用集群計算機來處理。</li><li class=ql-align-justify>如，Hadoop集群，用多臺計算機來並行處理數據。</li><li class=ql-align-justify>自己的軟件棧中，也可以把一個模塊部署多份，並行處理。</li><li class=ql-align-justify>d.用cache來滿足請求。常用的內容加熱cache後，大量的用戶請求都只是內存讀取數據而已，性能會得到很大的提升。</li><li class=ql-align-justify>cache是上帝算法，記得好像它的性能只比最佳性能低一些，就好像你是上帝，能夠預見未來一樣。現在X86CPU遇到了主頻限制，CPU提升性能的主要途徑就是增加高速Cache了。</li><li class=ql-align-justify>大系統小做</li><li class=ql-align-justify>遇到大型系統不要慌，把它切分成多個模塊，用多個小程序，通過SOA協作來解決。這秉承了Unix的設計思想。Unix上開發了大量單一目的的小程序，它主張用戶通過管道來讓多個小程序協作，解決用戶的需求。當然，管道方式通訊限制太多，不夠靈活。因此，現在我們可以通過URI,通過SOA的方式來讓多個程序協作。Andorid和iOS上的應用程序，現在都是通過URI實現協作的。這也算是Unix設計思想的現代發展吧？！</li><li class=ql-align-justify>Sharding切片</li><li class=ql-align-justify>現在有一個潮流，就是去IOE。I-IBM大型機，O-Oracle數據庫，E-EMC存儲。之前，大型系統常用IOE去架構，在大型機上部署一個Oracle數據庫，Oracle數據庫用EMC存儲保存數據。IOE是當今最強的計算機，數據庫和存儲。但他們面對海量系統也有抗不住的一天。</li><li class=ql-align-justify>Oracle數據庫是Shareeverything的，它可以在一個計算機集群（服務器節點不能超過16個）上運行。計算機集群都共用一個存儲。</li><li class=ql-align-justify>去IOE運動，標誌著ShareEverything模式的破產。必須使用ShareNothing，系統才能無限擴展。</li><li class=ql-align-justify>用MySQL數據庫就可以應付任意規模的數據了。前提是，你會Sharding分片。把大系統切分成若干個小系統，切分到若干臺廉價服務器和存儲上。更Modern一些，就是切分到大量虛擬機上。</li><li class=ql-align-justify>如，鐵道部的12306網站。我們知道火車票都是從屬於某一列列車的。那麼我們把每一個列車作為一個單元來切分，就可以把12306網站切分成幾千個模塊。一臺虛擬機可以承載若干個模塊。當某些列車成為性能瓶頸之後，就可以把它們遷移到獨立的虛擬機上。即使最終有部分列出服務不可用，系統也不會完全不可用。</li><li class=ql-align-justify>12306網站，只有一個全局的部分，就是用戶登錄。這個可以交給第三方負責。如可以讓用戶用微信，微博，qq等賬戶登錄。</li><li class=ql-align-justify>也可以自己實現用戶登錄服務。還是用切片的方式用多臺Redis服務器提供服務。Redis服務器存儲每一個登錄用戶的sessionId和userId，角色，權限等信息。sessionId是隨機生成的，可選擇其部分bit用於標識它在哪一個Redis服務器上。用戶登錄後，把sessionId發給客戶。用戶每次請求時把sessionId發回給服務器。服務器把sessionId發給Redis服務器查詢得到其用戶信息，對用戶請求進行處理。如果在redis服務器上找不到sessionId，則讓用戶去登錄。即使所有註冊用戶同時登陸，也不需要太多的內存。而且，可以在session內存過多時，刪除最早登陸的用戶的session，強制他再次登陸。同時活躍的用戶數不會太多。</li></ol><p class=ql-align-justify><strong>領域知識層次</strong></p><p class=ql-align-justify>前面的所有層次，都是關注編程本身的技能，說白了，就是基本功，本身並不能產生太大的價值。但有太多的程序員浪費太多的時間在那些築基的層次上。</p><p class=ql-align-justify>有些程序員特別喜歡鑽研編程語言，每有一種新的編程語言出來或者舊語言被熱炒，就會投入精力進去研究。我就是其中之一，浪費了很多精力在編程語言上，在奇技淫巧上。</p><p class=ql-align-justify>我覺得C++語言是一個特別大的坑。剛開始是作為面向對象的C被開發的。後來發現了模板編程，就大力鼓吹模板編程和進一步的模板元編程。最近又推出了C++11，C++14等新標準，進一步添加了很多新東西，函數式編程，類型推斷等。C++過分複雜，太多的坑消耗了大量程序員的大量精力。我使用C++時，只使用面向對象部分和模板部分，其他過於精深的特性都不使用。</p><p class=ql-align-justify>計算機科學是一個面相當廣泛的學科，有很多領域知識需要和值得我們深入研究，我們才能寫出有價值的程序來。軟件必須要和行業結合起來，要落地才有價值。僅僅研究編程技巧，不懂領域知識是寫不出有價值的程序的。</p><p class=ql-align-justify>計算機科學領域有很多，列舉一些如下：</p><p class=ql-align-justify>存儲----塊設備，文件系統，集群文件系統，分佈式文件系統，光纖SCSI，iSCSI，RAID等。</p><p class=ql-align-justify>網絡----以太網，光纖網，蜂窩網絡，WIFI，VLAN等。</p><p class=ql-align-justify>計算機體系結構，主要就是CPU指令集。x86,ARM等。</p><p class=ql-align-justify>USB協議。需要知道URB包。</p><p class=ql-align-justify>PCI協議，PCI-E協議。現代計算機的外設都是PCI協議和PCI-E協議的。顯卡現在全是通過 PCI-E協議連接到計算機上的。相對來說減少了很多需要學習的知識。搞虛擬化就需要深入掌握PCI協議。</p><p class=ql-align-justify>圖像處理--圖像壓縮，視頻實時編碼等。</p><p class=ql-align-justify>3D遊戲</p><p class=ql-align-justify>關係數據庫</p><p class=ql-align-justify>NoSQL數據庫</p><p class=ql-align-justify>操作系統</p><p class=ql-align-justify>分佈式操作系統</p><p class=ql-align-justify>編譯原理</p><p class=ql-align-justify>機器學習--現在大數據要用哦！</p><p class=ql-align-justify>瞭解這些領域知識，也包括瞭解該領域現有的商用硬件、商用軟件和開源軟件。很多時候，你要完成的工作，已經有現成的工具了。你只要使用現成的工具就可以完成任務，不需要進行開發。有時候，只需要組合現有的工具，寫一些腳本就可以完成任務。</p><p class=ql-align-justify>如，我一次要實現一個雙向同步任務。找到了一個優秀的開源軟件Unison，編寫一下配置文件就圓滿地完成了任務。不需要編寫任何代碼。</p><p class=ql-align-justify>還有一次，要做高可用，用Python調用了幾個開源軟件就輕鬆實現了。</p><p class=ql-align-justify>編寫安裝程序，定製操作系統，知道了操作系統的領域知識，寫幾行腳本就可以輕鬆搞定。</p><p class=ql-align-justify>不具備領域知識的人，就可能不得不進行大量無謂的開發，甚至開發很久之後才發現，這根本就是一條死路。</p><p class=ql-align-justify>另外，紮實的領域知識，可以大大提高編程調試、查錯的能力。知道編譯器和編程語言運行時工作原理，就能快速根據編譯錯誤和警告信息修改代碼。</p><p class=ql-align-justify>知道操作系統底層運行機制，就能快速找到運行時錯誤的問題根源。如，有一次我編寫一個windows升級服務程序。它是一個windows服務，需要執行dos腳本，這個腳本會替換掉這個windows服務本身。發現有時腳本執行無效，查了一晚上，發現當windows服務安裝後，第一次啟動就執行腳本時就會有權限問題，log都正確，但實際執行這個腳本沒有任何效果。但一旦windows服務程序啟動一次之後就ok。這必然是windows操作系統底層安全機制的問題，因為我對Windows內核瞭解不多，因此花了很長時間才發現這個問題，並對造成這個問題的根源並不清楚。</p><p class=ql-align-justify><strong>0段—領域知識菜鳥</strong></p><p class=ql-align-justify>對領域知識沒有多少認知，通過搜索引擎找到一些該領域的軟件和硬件的介紹性文章，按照文章指示配置和使用軟件。勉強能夠使用現有軟硬件。</p><p class=ql-align-justify>1段—領域知識行家</p><p class=ql-align-justify>瞭解領域內常用硬件，深入掌握領域內常用軟件的配置和使用技巧。能夠使用現有軟硬件熟練搭建解決方案，能夠解決實際工作中遇到的種種問題。</p><p class=ql-align-justify><strong>2段—領域知識專家</strong></p><p class=ql-align-justify>當你不僅僅掌握了該領域的軟件和工具，知道怎麼用，還知道其原理，“知其然，也知其所以然”，就是該領域的知識專家了。</p><p class=ql-align-justify>你知道網絡協議的原理，你才能在網絡出現問題時知道是哪裡可能出現了問題。是mac衝突，ip衝突，還是網絡環路？</p><p class=ql-align-justify>你知道存儲的原理，你才能知道為什麼這種存儲方式不適合虛擬化，那種存儲方式適合虛擬化，另一種方式適合資料備份。</p><p class=ql-align-justify>你知道PCI協議，你才能知道你怎樣才能虛擬化一個硬件設備。</p><p class=ql-align-justify>你知道網卡硬件協議，你才能模擬出一個虛擬機能正常使用的虛擬網卡。</p><p class=ql-align-justify>你知道視頻編碼格式和原理，才能知道什麼視頻格式佔用帶寬最少，什麼視頻格式佔用CPU最少。</p><p class=ql-align-justify>你瞭解IntelVT/Amd V指令集，才能知道虛擬化是怎樣實現的。</p><p class=ql-align-justify>你明白工作流其實就是狀態機，在遇到複雜工作流程時，你才能知道怎樣設計滿足要求的工作流引擎。</p><p class=ql-align-justify><strong>3段—科學家</strong></p><p class=ql-align-justify>你是領域知識專家，但你的知識都是來自於書本，來自於其他人的。</p><p class=ql-align-justify>如果你滿足於當領域知識專家，你只能拾人牙慧，永遠別想超越。別人的研究成果，未必願意告訴你。當別人告訴你的時候，它可能已經發現了更新的理論，並且新一代產品可能馬上就要發佈了。</p><p class=ql-align-justify>科學家是探索未知，勇於創新的人，是推動人類社會進步的人。</p><p class=ql-align-justify>傳說，思科的一位高管曾經半開玩笑地說過：“如果思科停止了新技術的研發，華為就會找不著方向”。這是在嘲笑華為只是處在領域知識專家的水平，只能山寨無法超越。我不知道華為的實際情況，但希望現在的華為已經走到了領跑者的位置。</p><p class=ql-align-justify>歐文·雅各布斯發現了CDMA碼分多址的原理，並發現它在通訊上大有可為，組建了高通公司。高通公司主要以專利授權費為生，它僱傭了大量科學家在通訊領域展開研究。有人說高通是專利流氓。這些人不明白知識的價值。在他們眼裡，Windows的合理價格就應該是5元錢，一張光盤的價格。iPhone就應該是1000多元裸機的價格。高通是專利流氓，那你也流氓一個CDMA，LTE出來給我看看！</p><p class=ql-align-justify>X86芯片在設計上沒有考慮虛擬化。因此會有所謂的“虛擬化漏洞”出現。就是說，一些CPU特權指令執行時，在虛擬機環境下不會拋出異常，因此就無法切換到Host。這樣，X86芯片上就無法運行虛擬機。</p><p class=ql-align-justify>VmWare公司是由美國的幾位科學家在1998年創建的。他們發現可以使用二進制翻譯的技術，在X86計算機上運行虛擬機。</p><p class=ql-align-justify>Xen虛擬化軟件也是幾位科學家發明的。他們發現只要修改虛擬機操作系統和Host操作系統的內核，在需要執行“虛擬化漏洞”指令時直接調用Host的功能，就可以實現虛擬化，而且大大提高了虛擬機的運行性能。</p><p class=ql-align-justify>後來，Intel為自己的芯片添加了IntelVT指令集，Amd為自己的芯片添加了AmdV指令集，彌補了“虛擬化漏洞”。於是就有了KVM虛擬機軟件，它直接用CPU硬件指令實現虛擬化。</p><p class=ql-align-justify>KVM在執行CPU指令時，是直接在物理CPU上運行的，因此效率極高。但是，虛擬機運行虛擬外設時，就必須用軟件模擬，因此虛擬機的IO訪問速度很慢。</p><p class=ql-align-justify>IBM科學家RustyRussell，借鑑了Xen的研發經驗，創建了VirtIO技術。就是在虛擬機中編寫一套PCI虛擬設備和驅動，這套虛擬PCI設備有一塊虛擬設備內存。這個虛擬設備內存Host是可以訪問的，虛擬機通過VirtIO驅動程序也可以訪問。也就是一塊內存在虛擬機和Host中共享，這就解決了虛擬機的IO性能問題。</p><p class=ql-align-justify>再講一個搜索引擎的故事：</p><p class=ql-align-justify>很久以前，我要給一個程序添加搜索功能。剛開始使用sql查詢實現，發現實在太慢了。後來找了開源的Lucene項目。它使用反向索引技術，通過在文件中創建反向索引，大大提高了搜索速度。</p><p class=ql-align-justify>Google的兩位創始人發現了html中link的祕密，他們發現可以通過html頁面的link關係來為每一個html頁面設置權重。也就是PageRank算法。於是，Google的自動搜索引擎擊敗了Yahoo人工分類的搜索引擎。</p><p class=ql-align-justify>OK，利用反向索引技術和PageRank，以及一個簡單的html爬蟲機器人，我們就可以創建一個搜索引擎了。但是，互聯網很大，每天產生大量新網頁，要為整個互聯網建立反向索引是很困難的。</p><p class=ql-align-justify>若干年後Google又公開了三篇論文：Googlefs,Mapreduce,Bigtable。於是Lucene項目的開發者根據Google的Mapreduce論文開發了Hadoop項目。MapReduce就是使用大量計算機存儲數據並計算，最後彙總結果。使用Hadoop+反向索引+PageRank，就可以創建搜索引擎了。Yahoo,Baidu等公司紛紛基於Hadoop開發了自己的搜索引擎。</p><p class=ql-align-justify>但是，其他公司的搜索引擎效果還是沒法和Google相比。這一點我們程序員最清楚。像我，就總是翻牆出去，只為了Google一下。</p><p class=ql-align-justify>Google黑板報上發表了吳軍博士的一些文章，其中介紹了很多機器學習方面的知識。從文中可以知道，Google其實使用機器學習來分析蒐集到的頁面。Google明顯不會把這個公式公開出來。即使有一天Google真的公開了這個公式，那麼可以想見Google肯定又研發出了更加犀利的祕籍，山寨貨的搜索引擎效果還是比不上Google的。</p><p class=ql-align-justify>山寨是通向創新的必由之路。在成為領域的領頭羊和領導者之前，必然要經過學習，模仿的階段。但要成為行業的老大，成為Champion，必須勇於彎道超車，勇敢地走上創新之路，成為真正的科學家，真正的大牛！</p><p class=ql-align-justify><strong>總結</strong></p><p class=ql-align-justify>編程能力可分為兩個維度：一個是編程技能水平，另一個是領域知識水平。</p><p class=ql-align-justify>有些程序員可能把精力都花在提升編程技能上了，領域知識知之甚少，這其實在日常工作中也是極其有害的。有些需求可能早已經有了現成、開源免費的解決方案，或者只需要組合幾個現有軟件就可以快速搞定，而他們卻不得不自己花大量時間去開發。另外，缺少領域知識，在程序出現非預期狀況時，很難快速定位到問題的根源，很難解決bug。</p><p><strong>關注小編,小編會每天為你分享有趣的技術文章哦。偷偷告訴你私信小編“學習”會有意想不到的驚喜喲~~!</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>層次</a></li><li><a>模型</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html alt=「編程基礎」PHP基礎教程（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17685aad04c54d02928724fb99fea026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html title=「編程基礎」PHP基礎教程（二）>「編程基礎」PHP基礎教程（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html alt=「編程基礎」PHP基礎教程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/355d0f0c0f274bdfaeb90747dbd918fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html title=「編程基礎」PHP基礎教程（一）>「編程基礎」PHP基礎教程（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html alt=零基礎如何學PHP編程語言？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html title=零基礎如何學PHP編程語言？>零基礎如何學PHP編程語言？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html alt=遊戲引擎編程需要哪些基本數學知識？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f6ca97249fa468db6982c44a024979d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html title=遊戲引擎編程需要哪些基本數學知識？>遊戲引擎編程需要哪些基本數學知識？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html alt=UG編程獨當一面，如何提高鑽孔精度方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532093430052c29be7656f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html title=UG編程獨當一面，如何提高鑽孔精度方法？>UG編程獨當一面，如何提高鑽孔精度方法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html alt=Java高級編程基礎：如何理解進程、線程與併發編程的關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/426d60ae-7dd7-4ab4-90bd-4dfeb286a68b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html title=Java高級編程基礎：如何理解進程、線程與併發編程的關係>Java高級編程基礎：如何理解進程、線程與併發編程的關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html alt=「Linux」高併發服務器模型（多進程和多線程實例模型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/170e1596c32348f39d6ace1f327e45d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e1360dd4.html title=「Linux」高併發服務器模型（多進程和多線程實例模型）>「Linux」高併發服務器模型（多進程和多線程實例模型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89c23934.html alt=物聯網定位精度的三個層次 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b7dc6df62f3d44fc90cd8da599873d0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89c23934.html title=物聯網定位精度的三個層次>物聯網定位精度的三個層次</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html alt=java流式編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/92118583492140e3b610df69c711fd87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html title=java流式編程思想>java流式編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html alt=盤點那些爭議最大的編程觀點，看看你有什麼見解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/501956d4daa845caa468124f22bb35f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html title=盤點那些爭議最大的編程觀點，看看你有什麼見解>盤點那些爭議最大的編程觀點，看看你有什麼見解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>