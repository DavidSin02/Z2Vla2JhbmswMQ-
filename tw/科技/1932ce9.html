<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>盤一盤 Spring 核心技術之依賴注入 | 原力計劃 | 极客快訊</title><meta property="og:title" content="盤一盤 Spring 核心技術之依賴注入 | 原力計劃 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/Rf2kPw8IkWbqVk"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1932ce9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1932ce9.html><meta property="article:published_time" content="2020-10-29T20:54:42+08:00"><meta property="article:modified_time" content="2020-10-29T20:54:42+08:00"><meta name=Keywords content><meta name=description content="盤一盤 Spring 核心技術之依賴注入 | 原力計劃"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1932ce9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>盤一盤 Spring 核心技術之依賴注入 | 原力計劃</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Rf2kPw8IkWbqVk><p>作者 | 麥洛_</p><p>責編 | 夕顏</p><p>頭圖 | CSDN付費下載自視覺中國</p><p>出品 | CSDN博客</p><p><strong>前言</strong></p><p>在官網中，我們發現它的核心技術之一：Dependency Injection，簡稱：DI ,翻譯過來就是依賴注入。今天我們就來盤一盤它。</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S0eL1K5GzxB7RA><p>在本文中，我們將深入研究 Spring 框架 DI背後的故事，包括 Spring Inversion of Control(控制反轉)、 DI 和 ApplicationContext 接口。基於這些基本概念，我們將研究如何使用基於 java 和基於 XML 的配置來 創建Spring 應用程序。最後，我們將探討在創建 Spring 應用程序時遇到的一些常見問題，包括 bean衝突和循環依賴性。</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT4Gwk56bt5iOJ><p><strong>控制反轉(Inversion of Control)</strong></p><p>在學習DI之前,我們先學習一下 IoC（控制反轉），接下來的一段可能讀起來會讓你感覺比較囉嗦,但是要細細體會每一次改變的意圖,和我們的解決方案，對於理解控制反轉非常重要。</p><p>首先來了解下我們通常實例化一個對象的方式。在 平時，我們使用 new 關鍵字實例化一個對象。例如，如果有一個 Car 類，我們可以使用以下方法實例化一個對象 Car</p><pre><code>Car car = new Car;</code></pre><p>因為汽車有很多零部件組成,我們定義Engine接口來模擬汽車引擎,然後將engine對象作為成員變量放在Car類</p><pre><code>public interface Engine {</code><code> void turnOn;</code><code>}</code><br><br><code>public class Car {</code><br><br><code> private Engine engine;</code><br><code> public Car {}</code><br><code> public void start {</code><br><br><code> engine.turnOn;</code><br><br><code> }</code><br><br><code>}</code></pre><p>現在,我們可以調用start方法嗎?顯然是不行的,一眼可以看出會報PointerException (NPE)，因為我們沒有在Car的構造函數中初始化engine。通常我們採用的方案就是在Car的構造函數中覺得使用Engine接口的哪個實現,並直接將該實現分配給engine字段;</p><p>現在,我們來首先創建Engine接口的實現類：</p><pre><code>public class ElectricEngine implements Engine {</code><code> @Override</code><code> public void turnOn {</code><code> System.out.println("電動引擎啟動");</code><code> }</code><code>}</code><br><br><code>public class CombustionEngine implements Engine {</code><code> @Override</code><code> public void turnOn {</code><code> System.out.println("燃油引擎啟動");</code><code> }</code><code>}</code></pre><p>我們修改Car的構造函數,使用ElectricEngine實現,將我們的engine字段分配給一個實例化的ElectricEngine對象：</p><pre><code>public class Car {</code><br><br><code> private Engine engine;</code><br><br><code> public Car {</code><code> this.engine = new ElectricEngine;</code><code> }</code><br><br><code> public void start {</code><br><br><code> engine.turnOn;</code><br><br><code> }</code><br><br><code> public static void main(String[] args) {</code><code> Car car = new Car;</code><code> car.start;</code><code> }</code><code>}</code></pre><p>現在我們執行start方法,我們會看到如下輸出:</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S0eL1KI2xym8uw><p>大功告成,我們成功解決了 NPE(空指針)問題,但是我們勝利了嗎?哈哈哈,顯然沒有!</p><p>在解決問題的同時,我們又引入了另一個問題。儘管我們通過抽象Engine接口，然後通過不同的Engine實現類來負責不同類型引擎的業務邏輯，的確是很好的設計策略。但是細心的夥伴可能已經發現了，我們Car類的構造函數中將engine聲明為CombustionEngine,這將導致所有車都有一個燃油引擎。假如我們現在要創建不同的汽車對象，它有一個電動引擎，我們將不得不改變我們的設計。比較常見的方法是創建兩個獨立裡的類，各司其職，在他們的構造函數中將engine分配給Engine接口的不同實現；</p><p>例如:</p><pre><code>public class CombustionCar {</code><br><code> private Engine engine;</code><br><code> public CombustionCar {</code><code> this.engine = new CombustionEngine;</code><code> }</code><br><code> public void start {</code><code> engine.turnOn;</code><code> }</code><br><br><code>}</code><br><br><code>public class ElectricCar {</code><code> private Engine engine;</code><br><br><code> public ElectricCar {</code><code> this.engine = new ElectricEngine;</code><code> }</code><br><code> public void start {</code><code> engine.turnOn;</code><code> }</code><br><code>}</code></pre><p>通過上面的一頓騷操作,我們成功的解決了我們引擎的問題。如果是一個日常需求,我們已經可以成功交工了。但是這顯然不是我寫這篇文章的目的。</p><p>從設計的角度來說，目前的代碼是糟糕的，有以下兩點原因：</p><ol><li><p>在兩個不同的類中，存在重複的start方法</p></li><li><p>我們需要為每個新的Engine 實現類創建一個新的類;</p></li></ol><p>尤其後一個問題更加難以解決,因為我們不控制Engine的實現,隨著開發人員不斷的創建自己的實現類,這個問題會更加惡化;</p><p><strong>帶著上面的問題,我們繼續思考…</strong></p><p>我們可以創建一個父類Car,將公共代碼抽取到父類中,可以輕鬆解決第一個問題。由於Engine字段是私有的,我們在父類Car的構造函數中接收Engine對象,並且進行賦值。</p><pre><code>public class Car {</code><br><br><code> private Engine engine;</code><br><br><code> public Car(Engine engine) {</code><code> this.engine = engine;</code><code> }</code><br><br><code> public void start {</code><code> engine.turnOn;</code><code> }</code><code>}</code><br><br><code>public class CombustionCar extends Car{</code><br><br><code> public CombustionCar {</code><code> super(new CombustionEngine);</code><code> }</code><br><br><code>}</code><br><br><code>public class ElectricCar extends Car {</code><br><br><code> public ElectricCar {</code><code> super(new ElectricEngine);</code><code> }</code><br><br><code>}</code></pre><p>通過這種方法,我們成功的解決了代碼重複的問題,我們來測試一下:</p><pre><code>public class Car {</code><br><br><code> private Engine engine;</code><br><br><code> public Car(Engine engine) {</code><code> this.engine = engine;</code><code> }</code><br><br><code> public void start {</code><code> engine.turnOn;</code><code> }</code><br><br><code> public static void main(String[] args) {</code><br><br><code> CombustionCar combustionCar1 = new CombustionCar;</code><code> combustionCar1.start;</code><code> ElectricCar electricCar1 = new ElectricCar;</code><code> electricCar1.start;</code><code> }</code><code>}</code></pre><p><strong>那麼我們該如何解決我們提出的第二個問題呢?</strong></p><p>其實這個問題我們可以換個角度看:為什麼我們要去關注CombustionCar和ElectricCar,我們現在將關注點回到我們的Car,我們現在已經允許客戶端實例化Car對象時候將Engine對象作為構造函數的參數傳入,其實已經消除了為每個Engine對象創建新Car的問題。因為現在Car類依賴於Engine接口,並不知道任何Engine的實現;</p><p>通過帶有Engine參數的構造函數,我們已將要使用哪個Engine實現的決定從Car類本身（最初由CombustionEngine決定）更改為實例化Car類的客戶端。決策過程的這種逆轉稱為IoC原則。現在，由客戶端控制使用哪種實現，而不是由Car類本身控制使用哪種Engine實現。</p><p>有點繞，大家結合下面的示例代碼，細細琢磨：</p><pre><code>public class Car {</code><br><br><code> private Engine engine;</code><br><br><code> public Car(Engine engine) {</code><code> this.engine = engine;</code><code> }</code><br><br><code> public void start {</code><code> engine.turnOn;</code><code> }</code><br><br><code> public static void main(String[] args) {</code><br><br><code> /**</code><code> * 老法子</code><code> * 為每一類型發送機的車創建類，然後實現父類car，然後在構造函數傳入自己的引擎，然後調用start</code><code> */</code><code> CombustionCar combustionCar1 = new CombustionCar;</code><code> combustionCar1.start;</code><code> ElectricCar electricCar1 = new ElectricCar;</code><code> electricCar1.start;</code><br><br><code> /**</code><code> * 控制反轉思想</code><code> * 把自己看作實例化car的客戶端，需要什麼引擎，直接傳入相關對象</code><code> */</code><code> CombustionEngine combustionEngine = new CombustionEngine;</code><code> Car combustionCar = new Car(combustionEngine);</code><code> combustionCar.start;</code><code> ElectricEngine electricEngine = new ElectricEngine;</code><code> Car electricCar = new Car(electricEngine);</code><code> electricCar.start;</code><code> }</code><code>}</code></pre><p>執行上面的代碼,我們發現都可以獲得我們想要的結果:</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S0eL1Kd6gTu1Uf><p>從上面的例子我們可以看到，實例化Car類的客戶端可以控制所使用的Engine實現，並且取決於將哪個Engine實現傳遞給Car構造函數，Car對象的行為發生巨大變化。為什麼這麼說，接著看下面</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RT7S2kzFTfre26><p><strong>依賴注入(Dependency Injection)</strong></p><p>在上面控制反轉的知識點,我們已經解決了由誰決定使用哪種Engine實現的問題,但是不可避免,我們也更改了實例化一個Car對象的步驟;</p><p>最開始,我們實例化Car不需要參數,因為在它的構造函數裡面已經為我們new了Engine對象。使用IoC方法之後，我們要求在實例化一個Car之前,我們需要先創建一個Engine對象,並作為參數傳遞給Car構造對象。換句話說，最初，我們首先實例化Car對象,然後實例化Engine對象。但是，使用IoC之後,我們首先實例化Engine對象,然後實例化Car對象;</p><p>因此,我們在上面的過程中創建了一個依賴關係。不過這種依賴關係不是指編譯時候Car類對Engine接口的依賴關係,相反,我們引入了一個運行時依賴關係。在運行時，實例化Car對象之前,必須首先實例化Engine對象。</p><p><strong>2.1 依賴關係樹</strong></p><p><strong>某一個具體的依賴對象大家可以理解為Spring中的bean,對於兩個有依賴關係的bean,其中被依賴的那個bean,我們把它稱為依賴對象。</strong></p><p>我們用圖形化的方式來看看它們之間的依賴關係，其中圖形的節點代表對象，箭頭代表依賴關係（箭頭指向依賴對象）。對於我們我的Car類,依賴關係樹非常簡單:</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S0eL1MPDsCu99x><p>如果<strong>依賴關係樹</strong>的終端結點還有自己的附加依賴關係，那麼這個依賴關係樹將變得更加複雜。現在再看我們上面的例子，如果CombustionEngine 還有其他依賴對象，我們首先需要創建CombustionEngine的依賴對象,然後才能實例化一個CombustionEngine對象。這樣在創建Car對象時候,才能將CombustionEngine傳遞給Car的構造函數;</p><pre><code>//凸輪軸 </code><code>public class Camshaft {}</code><code>//機軸</code><code>public class Crankshaft {}</code><br><br><code>public class CombustionEngine implements Engine {</code><br><br><code> //凸輪軸</code><code> private Camshaft camshaft;</code><br><br><code> //機軸</code><code> private Crankshaft crankshaft;</code><br><br><code> public CombustionEngine(Camshaft camshaft, Crankshaft crankshaft) {</code><br><br><code> this.camshaft = camshaft;</code><br><br><code> this.crankshaft = crankshaft;</code><code> }</code><br><br><code> @Override</code><br><br><code> public void turnOn {</code><br><br><code> System.out.println("燃油引擎啟動");</code><br><br><code> }</code><br><br><code>}</code></pre><p>經過我們改造,我們現在的依賴關係樹變為下面的樣子：</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S0eL1sVCqsRLm3><p><strong>2.2 依賴注入框架</strong></p><p>隨著我們不斷引入更多的依賴關係,這種複雜性將繼續增長。為了解決這個複雜問題，我們需要基於依賴關係樹抽取對象的創建過程。這就是<strong>依賴注入框架</strong>。</p><p>一般來說，我們可以把這個過程分為三個部分:</p><ol><li><p>聲明需要創建的對象需要哪些依賴對象</p></li><li><p>註冊創建這些依賴對象所需要的類</p></li><li><p>提供一種使用1和2兩點思想創建對象的機制</p></li></ol><p>通過反射，我們可以查看 Car 類的構造函數，並且知道它需要一個 Engine 參數。因此為了創建Car對象,我們必須創建至少一個Engine接口的實現類用作依賴項來使用。在這裡，我們創建一個CombustionEngine 對象(<strong>為了方便,暫時當做只有一個實現類,bean衝突問題待會再說</strong>)來聲明它作為依賴項來使用,就滿足Car對象創建時的需求.</p><p>其實,這個過程是遞歸的,因為CombustionEngine 依賴於其他對象,我們需要不斷重複第一個過程,直到把所有依賴對象聲明完畢,然後註冊創建這些依賴對象所需要的類。</p><p>第三點其實就是將前面兩點思想付諸實施，從而形成一種創建對象的機制</p><p>舉個例子:比如我們需要一個Car對象,我們必須遍歷依賴關係樹並檢查是否存在至少一個符合條件的類來滿足所有依賴關係。例如，聲明CombustionEngine類可滿足Engine節點要求。如果存在這種依賴關係，我們將實例化該依賴關係，然後移至下一個節點。</p><p>如果有一個以上的類滿足所需的依賴關係，那麼我們必須顯式聲明應該選擇哪一種依賴關係。稍後我們將討論 Spring 是如何做到這一點的。</p><p>一旦我們確定所有的依賴關係都準備好了，我們就可以從終端節點開始創建依賴對象。對於 Car 對象，我們首先實例化 Camshaft 和Crankshaftーー因為這些對象沒有依賴關係ーー然後將這些對象傳遞給 CombustionEngine 構造函數，以實例化 CombunstionEngine 對象。最後，我們將 CombunstionEngine 對象傳遞給 Car 構造函數，以實例化所需的 Car 對象。</p><p>瞭解了 DI 的基本原理之後，我們現在可以繼續討論 Spring 如何執行 DI。</p><p><strong>2.3 Spring的依賴注入</strong></p><p>Spring的核心是一個DI框架，它可以將DI配置轉換為Java應用程序。</p><p>在這裡我們要闡述一個問題:那就是<strong>庫和框架的區別</strong>。庫只是類定義的集合。背後的原因僅僅是代碼重用，即獲取其他開發人員已經編寫的代碼。這些類和方法通常在域特定區域中定義特定操作。例如，有一些數學庫可讓開發人員僅調用函數而無需重做算法工作原理的實現。</p><p>框架通常被認為是一個骨架，我們在其中插入代碼以創建應用程序。許多框架保留了特定於應用程序的部分，並要求我們開發人員提供適合框架的代碼。在實踐中，這意味著編寫接口的實現，然後在框架中註冊實現。</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S0eL1svIuO9Tqq><p><strong>2.4 ApplicationContext</strong></p><p>在 Spring 中，框架圍繞 ApplicationContext 接口實現上一節中概述的三個 DI 職責。通常這個接口代表了一個上下文。因此，我們通過基於 java 或基於 xml 的配置向 ApplicationContext 註冊合適的類，並從 ApplicationContext 請求創建 bean 對象。然後 ApplicationContext 構建一個依賴關係樹並遍歷它以創建所需的 bean對象：</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S0eL1vrGE8aa22><p>Applicationcontext 中包含的邏輯通常被稱為 Spring 容器。通常，一個 Spring 應用程序可以有多個 ApplicationContext，每個 ApplicationContext 可以有單獨的配置。例如，一個 ApplicationContext 可能被配置為使用 CombustionEngine 作為其引擎實現，而另一個容器可能被配置為使用 ElectricEngine 作為其實現。</p><p>在本文中，我們將重點討論每個應用程序的單個 ApplicationContext，但是下面描述的概念即使在一個應用程序有多個 ApplicationContext 實例時也適用。</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTJXJ1kBqzfCnu><p><strong>基於 java 的配置</strong></p><p>Spring為我們提供了兩種基於 java 的配置方式</p><ol><li><p>基本配置</p></li><li><p>自動配置</p></li></ol><p><strong>3.1 基於 java 的基本配置</strong></p><p>基於java的基本配置的核心，其實是下面兩個註解:</p><ol><li><p>@Configuration: 定義配置類</p></li><li><p>@Bean: 創建一個bean</p></li></ol><p>例如，給出我們之前定義的 Car, CombustionEngine, Camshaft, 和Crankshaft 類，我們可以創建一個下面 的配置類:</p><pre><code>/**</code><code> * @author milogenius</code><code> * @date 2020/5/17 20:52</code><code> */</code><code>@Configuration</code><code>public class AnnotationConfig {</code><br><code> @Bean</code><code> public Car car(Engine engine) {</code><code> return new Car(engine);</code><code> }</code><br><br><code> @Bean</code><code> public Engine engine(Camshaft camshaft, Crankshaft crankshaft) {</code><code> return new CombustionEngine(camshaft, crankshaft);</code><code> }</code><br><br><code> @Bean</code><code> public Camshaft camshaft {</code><code> return new Camshaft;</code><code> }</code><br><br><code> @Bean</code><code> public Crankshaft crankshaft {</code><code> return new Crankshaft;</code><code> }</code><code>}</code></pre><p>接下來，我們創建一個 ApplicationContext 對象，從 ApplicationContext 對象獲取一個 Car 對象，然後在創建的 Car 對象上調用 start 方法:</p><pre><code>ApplicationContext context = </code><br><br><code> new AnnotationConfigApplicationContext(AnnotationConfig.class);</code><br><br><code>Car car = context.getBean(Car.class);</code><br><br><code>car.start;</code></pre><p>執行結果如下:</p><pre><code>Started combustion engine</code></pre><p>雖然@Configuration 和@Bean 註解的組合為 Spring 提供了足夠的信息來執行依賴注入，但我們仍然需要手動手動定義每個將被注入的 bean，並顯式地聲明它們的依賴關係。為了減少配置 DI 框架所需的開銷，Spring 提供了基於java的自動配置。</p><p><strong>3.2 基於 java 的自動配置</strong></p><p>為了支持基於 java 的自動配置，Spring 提供了額外的註解。雖然我們平時可能加過很多這種類型的註解，但是有三個最基本的註解:</p><pre><code>@Component: 註冊為由 Spring 管理的類</code><code>@Autowired: 指示 Spring 注入一個依賴對象</code><code>@ComponentScan: 指示Spring在何處查找帶有@Component註解的類</code><code>3.2.1 構造函數注入</code><code>@Autowired註解用來指導 Spring ,我們打算在使用註解的位置注入一個依賴對象。例如，在 Car 構造函數中，我們期望注入一個 Engine 對象，因此，我們給 Car 構造函數添加@Autowired註解。通過使用@Component 和@Autowired註解改造我們Car類，如下所示：</code><br><br><code>@Component</code><code>public class Car {</code><br><br><code> private Engine engine;</code><br><br><br><code> @Autowired</code><br><br><code> public Car(Engine engine) {</code><br><br><code> this.engine = engine;</code><code> }</code><br><br><code> public void start {</code><br><br><code> engine.turnOn;</code><br><br><code> }</code><br><br><code>}</code></pre><p>我們可以在其他類中重複這個過程:</p><pre><code>@Component</code><br><br><code>public class Camshaft {}</code><br><br><code>@Component</code><code>public class Crankshaft {}</code><br><br><br><br><code>@Component</code><br><br><code>public class CombustionEngine implements Engine {</code><br><br><br><br><br><code> private Camshaft camshaft;</code><br><br><code> private Crankshaft crankshaft;</code><br><br><br><br><code> @Autowired</code><br><br><code> public CombustionEngine(Camshaft camshaft, Crankshaft crankshaft) {</code><br><br><code> this.camshaft = camshaft;</code><br><br><code> this.crankshaft = crankshaft;</code><br><br><code> }</code><br><br><br><br><code> @Override</code><br><br><code> public void turnOn {</code><br><br><code> System.out.println("Started combustion engine");</code><br><br><code> }</code><br><br><code>}</code></pre><p>改造完成相關類之後，我們需要創建一個@Configuration 類來指導 Spring 如何自動配置我們的應用程序。對於基於 java 的基本配置，我們明確指示 Spring 如何使用@Bean 註解創建每個 bean，但在自動配置中，我們已經通過@Component 和@Autowired 註解提供了足夠的信息，說明如何創建所需的所有 bean。唯一缺少的信息是 Spring 應該在哪裡尋找我們的帶有@Component註解的 類,並把它註冊為對應的bean。</p><p>@ Componentscan 註釋包含一個參數 basePackages，它允許我們將包名稱指定為一個 String，Spring 將通過遞歸搜索來查找@Component 類。在我們的示例中，包是 com.milo.domain，因此，我們得到的配置類是:</p><pre><code>@Configuration</code><code>@ComponentScan(basePackages = "com.milo.domain")</code><code>public class AutomatedAnnotationConfig {}</code></pre><pre><code>ApplicationContext context = </code><br><br><code> new AnnotationConfigApplicationContext(AutomatedAnnotationConfig.class);</code><br><br><code>Car car = context.getBean(Car.class); </code><br><br><code>car.start;</code></pre><p>執行結果:</p><pre><code>Started combustion engine</code></pre><p>通過和基於java的基礎配置比較,我們發現基於 java 的自動配置方法有兩個主要優點:</p><ol><li><p>所需的配置要簡潔得多</p></li><li><p>註解直接應用於類，而不是在配置類</p></li></ol><p><strong>所以無特殊情況,自動配置是首選。</strong></p><p>3.2.2 字段注入</p><p>除了構造函數注入，我們還可以通過字段直接注入。我們可以將@Autowired 註解應用到所需的字段來實現這一點:</p><pre><code>@Component</code><code>public class Car {</code><br><br><br><br><code> @Autowired</code><br><br><code> private Engine engine;</code><br><br><br><br><br><code> public void start {</code><br><br><code> engine.turnOn;</code><br><br><code> }</code><br><br><code>}</code></pre><p>這種方法極大地減少了我們的編碼壓力，但是它也有一個缺點,就是在使用字段之前，我們將無法檢查自動注入的對象是否為空。</p><p>3.2.3 Setter注入</p><p>構造函數注入的最後一種替代方法是 setter 注入，其中@Autowired 註解應用於與字段關聯的 setter。例如，我們可以改變 Car 類，通過 setter 注入獲得 Engine 對象，方法是用@Autowired註解 setEngine 方法:</p><pre><code>@Component</code><code>public class Car {</code><br><br><br><br><code> private Engine engine;</code><br><br><br><br><br><code> public void start {</code><br><br><code> engine.turnOn;</code><br><br><code> }</code><br><br><br><br><code> public Engine getEngine {</code><br><br><code> return engine;</code><br><br><code> }</code><br><br><br><br><code> @Autowired</code><br><br><code> public void setEngine(Engine engine) {</code><br><br><code> this.engine = engine;</code><br><br><code> }</code><br><br><code>}</code></pre><p>Setter 注入類似於字段注入，但它允許我們與 注入對象交互。在有些情況下，setter 注入可能特別有用，例如具有循環依賴關係，但 setter 注入可能是三種注入技術中最不常見的，<strong>儘可能優先使用構造函數注入。</strong></p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7YR5xGDl><p><strong>基於 xml 的配置</strong></p><p>另一種配置方法是基於 xml 的配置。我們在 XML 配置文件中定義 bean 以及它們之間的關係，然後指示 Spring 在哪裡找到我們的配置文件。</p><p>第一步是定義 bean。我們基本遵循與基於 java 的基本配置相同的步驟，但使用 xmlbean 元素代替。在 XML 的情況下，我們還必須顯式地聲明我們打算使用 constructor-arg 元素注入到其他構造函數中的 bean。結合 bean 和 constructor-arg 元素，我們得到以下 XML 配置:</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</code><br><br><code>&lt;beans xmlns="http://www.springframework.org/schema/beans"</code><br><br><code> xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</code><br><br><code> xmlns:util="http://www.springframework.org/schema/util"</code><br><br><code> xsi:schemaLocation="</code><br><br><code> http://www.springframework.org/schema/beans</code><br><br><code> http://www.springframework.org/schema/beans/spring-beans.xsd</code><br><br><code> http://www.springframework.org/schema/util</code><br><br><code> http://www.springframework.org/schema/util/spring-util.xsd"&gt;</code><br><br><br><br><code> &lt;bean id="car" class="com.milo.domain.Car"&gt;</code><br><br><code> &lt;constructor-arg ref="engine" /&gt;</code><br><br><code> &lt;/bean&gt;</code><br><br><br><br><br><code> &lt;bean id="engine" class="com.milo.CombustionEngine"&gt;</code><br><br><code> &lt;constructor-arg ref="camshaft" /&gt;</code><br><br><code> &lt;constructor-arg ref="crankshaft" /&gt;</code><br><br><code> &lt;/bean&gt;</code><br><br><br><br><br><code> &lt;bean id="camshaft" class="com.milo.Camshaft" /&gt;</code><br><br><code> &lt;bean id="crankshaft" class="com.milo.Crankshaft" /&gt;</code><br><br><br><br><code>&lt;/beans&gt;</code></pre><p>在 bean 元素中，我們必須指定兩個屬性:</p><ol><li><p>id : bean 的唯一 ID (相當於帶有@Bean 註解方法名</p></li><li><p>class : 類的全路徑(包括包名)</p></li></ol><p>對於 constructor-arg 元素，我們只需要指定 ref 屬性，它是對現有 bean ID 的引用。例如，元素構造函數 &lt;constructor-arg ref="engine" /> 規定，具有 ID engine(直接定義在 car bean 之下)的 bean 應該被用作注入 car bean 構造函數的 bean。</p><p>構造函數參數的順序由 constructor-arg 元素的順序決定。例如，在定義 engine bean 時，傳遞給 CombustionEngine 構造函數的第一個構造函數參數是 camshaft bean，而第二個參數是 crankshaft bean。</p><p>獲取ApplicationContext對象，我們只需修改 ApplicationContext 實現類型。因為我們將 XML 配置文件放在類路徑上，所以我們使用 ClassPathXmlApplicationContext:</p><pre><code>ApplicationContext context = </code><br><br><code> new ClassPathXmlApplicationContext("basic-config.xml");</code><br><br><code>Car car = context.getBean(Car.class);</code><br><br><code>car.start;</code></pre><p>執行結果:</p><pre><code>Started combustion engine</code></pre><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTJXJ7uHXU5GZc><p><strong>常見問題</strong></p><p>現在，我們已經摸清了Spring框架如何進行DI，並正確地將所有依賴關係注入到我們的應用程序中，但是我們必須處理兩個棘手的問題:</p><ol><li><p>依賴對象衝突</p></li><li><p>依賴對象間存在循環依賴</p></li></ol><p>5.1 具有多個符合條件的依賴對象</p><p>在基於 java 和基於 xml 的方法中，我們已經指示 Spring 只使用 CombustionEngine 作為我們的Engine實現。如果我們將ElectricEngine註冊為符合 di 標準的部件會發生什麼？為了測試結果，我們將修改基於 java 的自動配置示例，並用@Component 註解 ElectricEngine 類:</p><pre><code>@Component</code><code>public class ElectricEngine implements Engine {</code><br><br><br><br><code> @Override</code><br><br><code> public void turnOn {</code><br><br><code> System.out.println("Started electric engine");</code><br><br><code> }</code><br><code>}</code></pre><p>如果我們重新運行基於 java 的自動配置應用程序，我們會看到以下錯誤:</p><pre><code>No qualifying bean of type 'com.dzone.albanoj2.spring.di.domain.Engine' available: expected single matching bean but found 2: combustionEngine,electricEngine</code></pre><p>由於我們已經註釋了用@Component 實現 Engine 接口的兩個類ーー即 CombustionEngine 和ElectricEngine ーー spring 現在無法確定在實例化 Car 對象時應該使用這兩個類中的哪一個來滿足 Engine 依賴性。為了解決這個問題，我們必須明確地指示 Spring 使用這兩個 bean 中的哪一個。</p><p>5.1.1 @ Qualifier 註解</p><p>一種方法是給我們的依賴對象命名,並在應用@Autowired註解的地方使用@Qualifier註解來確定注入哪一個依賴對象。所以,@Qualifier 註解限定了自動注入的 bean，從而將滿足需求的 bean 數量減少到一個。例如，我們可以命名我們的CombustionEngine依賴對象:</p><pre><code>@Component("defaultEngine")</code><code>public class CombustionEngine implements Engine {</code><br><br><br><code> // ...代碼省略,未改變</code><br><br><code>}</code></pre><p>然後我們可以添加@Qualifier 註解,其名稱和我們想要注入的依賴對象的名稱保持一致,這樣,我們Engine 對象在 Car 構造函數中被自動注入</p><pre><code>@Component</code><code>public class Car {</code><br><br><code> @Autowired</code><br><br><code> public Car(@Qualifier("defaultEngine") Engine engine) {</code><br><br><code> this.engine = engine;</code><br><br><code> }</code><br><br><br><code> // ...existing implementation unchanged...</code><br><br><code>}</code></pre><p>如果我們重新運行我們的應用程序，我們不再報以前的錯誤:</p><pre><code>Started combustion engine</code></pre><p>注意，如果沒有顯式申明bean名稱的類都有一個默認名稱，該默認名稱就是類名首字母小寫。例如，我們的 Combusttionengine 類的默認名稱是 combusttionengine</p><p>5.1.2 @ Primary 註解</p><p>如果我們知道默認情況下我們更喜歡一個實現，那麼我們可以放棄@Qualifier 註釋，直接將@Primary 註釋添加到類中。例如，我們可以將我們的 Combusttionengine、 ElectricEngine 和 Car 類更改為:</p><pre><code>@Component</code><code>@Primary</code><br><br><code>public class CombustionEngine implements Engine {</code><br><br><br><br><br><code> // ...existing implementation unchanged...</code><br><br><code>}</code><br><br><code>@Component</code><code>public class ElectricEngine implements Engine {</code><br><br><br><br><br><code> // ...existing implementation unchanged...</code><br><br><code>}</code><br><br><br><br><code>@Component</code><code>public class Car {</code><br><br><br><br><br><code> @Autowired</code><br><br><code> public Car(Engine engine) {</code><br><br><code> this.engine = engine;</code><br><br><code> }</code><br><br><br><br><br><code> // ...existing implementation unchanged...</code><br><br><code>}</code></pre><p>我們重新運行我們的應用程序，我們會得到以下輸出:</p><pre><code>Started combustion engine</code></pre><p>這證明，雖然有兩種可能性滿足 Engine 依賴性，即 CombustionEngine 和 Electricengine，但 Spring 能夠根據@Primary 註釋決定兩種實現中哪一種應該優先使用。</p><p><strong>5.2 循環依賴</strong></p><p>雖然我們已經深入討論了 Spring DI 的基礎知識，但是還有一個主要問題沒有解決: 如果依賴關係樹有一個循環引用會發生什麼？例如，假設我們創建了一個 Foo 類，它的構造函數需要一個 Bar 對象，但是 Bar 構造函數需要一個 Foo 對象。</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/S0eL2M8CVbPtwY><p>我們可以使用代碼實現上面問題:</p><pre><code>@Component</code><code>public class Foo {</code><br><br><br><br><br><br><code> private Bar bar;</code><br><br><br><br><code> @Autowired</code><br><br><code> public Foo(Bar bar) {</code><br><br><code> this.bar = bar;</code><br><br><code> }</code><br><br><code>}</code><br><br><br><br><code>@Component</code><code>public class Bar {</code><br><br><br><br><br><br><code> private Foo foo;</code><br><br><br><br><code> @Autowired</code><br><br><code> public Bar(Foo foo) {</code><br><br><code> this.foo = foo;</code><br><br><code> }</code><br><br><code>}</code></pre><p>然後我們可以定義以下配置:</p><pre><code>@Configuration</code><code>@ComponentScan(basePackageClasses = Foo.class)</code><code>public class Config {}</code></pre><p>最後，我們可以創建我們的 ApplicationContext:</p><pre><code>ApplicationContext context = </code><br><code> new AnnotationConfigApplicationContext(Config.class);</code><br><code>Foo foo = context.getBean(Foo.class);</code></pre><p>當我們執行這個代碼片段時，我們看到以下錯誤:</p><pre><code>Unsatisfied dependency expressed through constructor parameter 0; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'bar': Requested bean is currently in creation: Is there an unresolvable circular reference?</code></pre><p>首先，Spring 嘗試創建 Foo 對象。在這個過程中，Spring 認識到需要一個 Bar 對象。為了構造 Bar 對象，需要一個 Foo 對象。由於 Foo 對象目前正在構建中(這也是創建 Bar 對象的原因) ，spring 認識到可能發生了循環引用。</p><p>這個問題最簡單的解決方案之一是在一個類和注入點上使用@Lazy註解。這指示 Spring 推遲帶註解的 bean 和帶註釋的@Autowired 位置的初始化。這允許成功地初始化其中一個 bean，從而打破循環依賴鏈。理解了這一點，我們可以改變 Foo 和 Bar 類:</p><pre><code>@Component</code><code>public class Foo {</code><br><br><br><br><br><code> private Bar bar;</code><br><br><br><br><code> @Autowired</code><br><br><code> public Foo(@Lazy Bar bar) {</code><br><br><code> this.bar = bar;</code><br><br><code> }</code><br><br><code>}</code><br><br><br><br><code>@Component</code><br><br><code>@Lazy</code><br><br><code>public class Bar {</code><br><br><br><br><code> @Autowired</code><br><br><code> public Bar(Foo foo) {}</code><br><br><code>}</code></pre><p>如果使用@Lazy 註解後重新運行應用程序，沒有發現報告任何錯誤。</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTLSNam5ZxLDlM><p><strong>總結</strong></p><p>在本文中，我們探討了 Spring 的基礎知識，包括 IoC、 DI 和 Spring ApplicationContext。然後，我們介紹了使用基於 java 的配置和基於 xml 的配置創建 Spring 應用程序的基本知識，同時研究了使用 Spring DI 時可能遇到的一些常見問題。雖然這些概念一開始可能晦澀難懂，與 Spring 代碼脫節，但是我們可以從基底層認識Spirng,希望對大家有所幫助,謝謝大家。</p><p>版權聲明：本文為CSDN博主「麥洛_」的原創文章，遵循CC 4.0 BY-SA版權協議，轉載請附上原文出處鏈接及本聲明。</p><p>原文鏈接：https://blog.csdn.net/milogenius/article/details/106255686</p><img alt="盤一盤 Spring 核心技術之依賴注入 | 原力計劃" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/S0GVSUiJIQqlmu><pre><pre><pre><p>☞開源公司 HashiCorp 國內險遭禁，阿里、華為也要做好 B 計劃？</p><p>☞航拍高手、吉他十級，6500+Star 開源項目作者，後浪程序員給力！</p><p>☞面試官：你的 SQL 一般有幾個 join？| 原力計劃</p><p>☞基於深度學習和傳統算法的人體姿態估計，技術細節都講清楚了</p><p>☞面試中遇到這 3 個SQL問題，最容易掉坑裡！</p><p>☞好撲科技結合區塊鏈行業發展趨勢，重磅推出“好撲區塊鏈合夥人”計劃</p></pre></pre></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>盤一盤</a></li><li><a>Spring</a></li><li><a>技術</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html alt="技術帖 | 3分鐘搞定各種測試分析技術" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f055e0a4477240088de2abb7cd696cfa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/93727dba.html title="技術帖 | 3分鐘搞定各種測試分析技術">技術帖 | 3分鐘搞定各種測試分析技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d0ddee5.html alt=建築房屋結構平衡技術要求，你都會知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e7d0001715d878ed66c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d0ddee5.html title=建築房屋結構平衡技術要求，你都會知道嗎？>建築房屋結構平衡技術要求，你都會知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47c8cac0.html alt=新《裝配式混凝土建築技術標準》有哪些改變？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540524372015dc56ec3fb9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47c8cac0.html title=新《裝配式混凝土建築技術標準》有哪些改變？>新《裝配式混凝土建築技術標準》有哪些改變？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6c2fc2b.html alt=鈦合金精密鑄造技術發展現狀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/SCynkUUBbHN8CF style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6c2fc2b.html title=鈦合金精密鑄造技術發展現狀>鈦合金精密鑄造技術發展現狀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2e8af08.html alt=傾斜航攝技術小知識——航線設計篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RS1ucOiDvLRlVt style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2e8af08.html title=傾斜航攝技術小知識——航線設計篇>傾斜航攝技術小知識——航線設計篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d597da51.html alt=黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1528429551298e033646798 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d597da51.html title=黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量>黃河電力技術公司在龍羊峽進行無人機傾斜攝影測量</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdb604f6.html alt=《雷神4：愛與雷》將採用“虛擬製作”技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/83a320a69b0f44e3baf7db07faac3c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdb604f6.html title=《雷神4：愛與雷》將採用“虛擬製作”技術>《雷神4：愛與雷》將採用“虛擬製作”技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cd5b6b6.html alt=虛擬現實技術在智能製造領域具有重要的應用價值 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ed327880d3b4c5384619f21d6c81823 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cd5b6b6.html title=虛擬現實技術在智能製造領域具有重要的應用價值>虛擬現實技術在智能製造領域具有重要的應用價值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a2b0c81.html alt="虛擬製造的基石：數值模擬技術 | 加快實現工業數字化" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2f2c32f4bd734f9face045546d45a665 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a2b0c81.html title="虛擬製造的基石：數值模擬技術 | 加快實現工業數字化">虛擬製造的基石：數值模擬技術 | 加快實現工業數字化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ee69f5ac.html alt=基於機器視覺技術快速準確地確定收穫後幹大豆種子的品質 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/519b968bf69146fda9bf55f89779d373 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ee69f5ac.html title=基於機器視覺技術快速準確地確定收穫後幹大豆種子的品質>基於機器視覺技術快速準確地確定收穫後幹大豆種子的品質</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e203d547.html alt=和你一起的軍訓，下雨也甜蜜｜四川託普信息技術職業學院軍訓記 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4cd61c2a490f48ebb0aa74d30ec8766b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e203d547.html title=和你一起的軍訓，下雨也甜蜜｜四川託普信息技術職業學院軍訓記>和你一起的軍訓，下雨也甜蜜｜四川託普信息技術職業學院軍訓記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/916c8d26.html alt=鍋爐專業技術問答100條 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/916c8d26.html title=鍋爐專業技術問答100條>鍋爐專業技術問答100條</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0efa050d.html alt=「技術」差速器總成結構與性能參數分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa9c698160c045c8a64c08dac6018a30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0efa050d.html title=「技術」差速器總成結構與性能參數分析>「技術」差速器總成結構與性能參數分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4db7ced8.html alt="技術 | 水泥磨主減速機高速軸軸承更換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a1cfa2b9a4e74251a6b1114ba246a08f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4db7ced8.html title="技術 | 水泥磨主減速機高速軸軸承更換">技術 | 水泥磨主減速機高速軸軸承更換</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>