<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>揭開C++移動與複製的神祕面紗 | 极客快訊</title><meta property="og:title" content="揭開C++移動與複製的神祕面紗 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1a9b85ac.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1a9b85ac.html><meta property="article:published_time" content="2020-11-14T21:04:04+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:04+08:00"><meta name=Keywords content><meta name=description content="揭開C++移動與複製的神祕面紗"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1a9b85ac.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>揭開C++移動與複製的神祕面紗</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p>摘要：本次分享主要圍繞C++中的移動與複製問題，講解了移動與複製過程中涉及的一系列概念，具體場景中存在的問題以及解決方案。幫助大家深入學習C++中移動與複製，並解決實際問題。</p></blockquote><p><strong>演講嘉賓簡介</strong>：付哲（花名：行簡），阿里雲高級開發工程師，哈爾濱工業大學微電子學碩士，主攻方向為分佈式存儲與高性能服務器編程，目前就職於阿里雲表格存儲團隊，負責後端開發。</p><p><strong>左值與右值</strong></p><p>左值與右值的概念來自賦值表達式。以x=a+b+c;為例，其中“x”就是左值，而“a+b+c”的結果就是右值。左值就是可以放到等號左邊的值，或者稱“變量”。右值是隻能放在右邊，不能放在左邊的值。那麼，什麼值可以放在左邊呢？C++標準規定，一個可取地址的變量就可以放在左邊。右值是表達式的值，是臨時變量，無法對它取地址，因為當表達式計算結束之後，它的地址就析構了。因此，上面的表達式就不能寫成a+b+c=x;</p><p><strong>右值引用</strong></p><p>· C++98只有左值引用，C++11增加了有值引用。</p><p>· 非const左值引用只能綁定左值，不能綁定右值。</p><p>· const左值引用是既可以綁定左值又可以綁定右值的。</p><p>· 右值引用只能綁定右值，不能綁定左值。</p><p>· 右值引用允許移動。</p><p>在C++98中，雖然編譯器本身是有左值和右值的劃分的，但它沒有將右值本身暴露給用戶使用，因此用到的引用都是左值。而C++11中增加了右值引用，如下面這段代碼，一個右值引用只能綁定到右值上。如果嘗試將其綁定到左值上，那麼編譯就會報錯。注意，右值引用和右值本身也是不一樣的，右值本身是沒有名字的，也是無法取地址的。而右值引用本身有名字有地址，因此右值引用本身是左值，只不過它綁定到了右值上。</p><pre>int x;int&amp;&amp; rref = x; // error!int&amp;&amp; rref = GetTemp(); // ok</pre><p>右值引用有什麼用呢？大家知道右值代表一個臨時變量，在C++98中，我們只能對臨時變量值進行復制，完成後臨時變量會被析構。大家可能會思考一個問題，我們為什麼不能在臨時變量析構之前把變量的值取出來呢？如何判斷一個變量是臨時變量，可以把它的值取走，而不是複製呢？那就要用到右值引用。因為用傳統的左值引用會將值綁定到非臨時變量上，那麼就只能對變量進行復制，而右值引用會綁定到一個臨時變量上，那麼就可以安全地移走它的值。C++11中就將這種操作稱為移動。相應的也增加了移動構造函數和移動賦值函數。</p><p><strong>特殊函數</strong></p><p>現在C++11中大致包含以下這些特殊函數，編譯器會幫助我們生成。默認一個類型至少會有這些函數。後面會講這些函數的特殊之處。</p><p>· 默認構造函數</p><p>· 析構函數</p><p>· 複製構造函數</p><p>· 複製賦值函數</p><p>· 移動構造函數</p><p>· 移動複製函數</p><pre>class Widget {public: Widget(); // 默認構造函數 ~Widget(); // 析構函數 Widget(const Widget&amp; rhs); // 複製構造函數 Widget&amp; operator=(const Widget&amp; rhs); // 複製賦值函數 Widget(Widget&amp;&amp; rhs); // 移動構造函數 Widget&amp; operator=(Widget&amp;&amp; rhs); // 移動賦值函數private: std::string mName; int32_t mCount;};</pre><p><strong>發生構造與賦值的場景</strong></p><p>· 發生複製或移動構造的場景：</p><p>·使用括號或花括號初始化</p><p>·使用等號初始化</p><p>·函數的實參到形參</p><p>· 發生賦值的場景：</p><p>·使用等號賦值</p><pre>// 場景0Widget w1(w0);// 場景1Widget w2 = w0;// 場景2void Func(Widget w);Func(w0);</pre><p>在這個例子中，case0,1,2都會調用構造函數。如果構造函數的參數是Widget，且為左值就會調用複製構造函數，如果參數是Widget的右值，就會調用移動構造函數，移動後右值對應的對象就成為空對象，不持有任何資源。</p><p>賦值函數的規則也一樣，如果參數是Widget左值就調用複製賦值函數，如果參數是Widget右值就調用移動賦值函數。在case3中，在聲明函數時，傳入的參數w稱為形參，而實際調用時傳入的w0稱為實參。在實參到形參的過程中存在構造行為，同樣遵循上述原則。</p><p>如果一個類沒有移動構造函數和移動賦值函數，並且它在進行構造和賦值時，參數是右值，會發生什麼呢。在C++11以前規定，要麼編譯器為類生成這兩個移動函數，要麼編譯器調用複製構造函數或複製賦值函數，來代替移動。這也是之前提過的，兩個賦值函數的參數必須是const引用的原因，只有const引用才能綁定右值，編譯器才能通過兩個複製函數來代替兩個移動函數。</p><p><strong>編譯器生成特殊函數的規則</strong></p><p>剛才介紹的六個特殊函數，編譯器會按照某種規則生成這些函數，生成的函數都是public，內聯，非虛的。一個例外是如果一個類有虛函數那麼編譯器生成的析構函數也是虛函數。其中，默認構造函數與析構函數的默認構造規則已經介紹過了。下面介紹生成複製函數和移動函數的生成規則。</p><p>· 生成複製函數的規則：沒有聲明覆制函數，且代碼中調用了複製函數。</p><p>· 生成移動函數的規則：沒有聲明覆制函數，且沒有聲明析構函數，且沒有聲明移動函數，且代碼中調用了移動函數。</p><p>當一個類沒有自定義的複製構造函數或複製賦值函數，且沒有禁止生成它，且代碼中調用了它，注意，一定要是某行代碼調用了複製構造函數或複製賦值函數，編譯器才會為它生成這兩個函數之一。另外，兩個函數是獨立生成的，互不影響。不會因為自定義了複製構造函數，就不生成對應的複製賦值函數。但這樣其實是存在問題的。複製構造函數、複製賦值函數、析構函數三者應該是有關聯的，如果定義了其中一個，那麼另外兩個也應該自定義。因為這三個函數都與資源管理有關，比如自定義了複製構造函數，如下面這段代碼，默認的賦值函數會把pb指針賦值過去，即淺複製。但這個例子中，需要進行深複製，因此需要定義一個複製構造函數。但只定義這個複製構造函數還不夠，編譯器還為它生成了對應的賦值函數和析構函數。而這兩個函數的行為顯然是錯的。因為賦值函數進行了淺複製，析構函數也沒有將對應的內存釋放。這就是為什麼三個函數要麼都不定義，要麼一起定義。</p><pre>class Widget { ...private: Bitmap* pb;};Widget::Widget(const Widget&amp; rhs) { pb = new Bitmap(*rhs.pb);}</pre><p>在C++98中，沒有將這三個函數實現關聯，大家需要牢記這些規則。而在C++11中明確的提出前面提到的這五個函數都是關聯的（複製構造函數、複製賦值函數、移動構造函數、移動賦值函數、析構函數）。只要用戶定義了一個，編譯器就不會生成其他任意的一個函數。</p><p>以Widget類為例，編譯器自動生成的構造函數會依次構造每個成員，析構函數會逆向依次析構成員，複製函數就是按順序依次進行復制，移動函數會依次進行移動。</p><p><strong>要求編譯器生成特殊函數</strong></p><p>當已經聲明瞭某個特殊函數，比如析構函數，這時會導致編譯器不在生成兩個移動函數，但如果我們還是想要編譯器生成它們，在C++11中，可以將特殊函數聲明為default，以下面這段代碼為例，自定義了構造函數和析構函數。之所以要自定義構造函數是因為，mCount這個變量是int32_t型的，對於這樣的類型，默認的構造函數是不會對它進行初始化的，是不符合需求的。但對於其他幾個函數而言，只需要定義成default，就可以讓編譯器自動為我們生成。</p><pre>class Widget {public: Widget(); // 默認構造函數 ~Widget(); // 析構函數 Widget(const Widget&amp; rhs) = default; Widget&amp; operator=(const Widget&amp; rhs) = default; Widget(Widget&amp;&amp; rhs) = default; Widget&amp; operator=(Widget&amp;&amp; rhs) = default;private: std::string mName; int32_t mCount;};</pre><p><strong>移動與複製函數的寫法</strong></p><p>下面展示了自定義移動與複製函數的例子。</p><pre>Widget::Widget(const Widget&amp; rhs) : mName(rhs.mName) , mCount(rhs.mCount) {}Widget&amp; Widget::operator=(const Widget&amp; rhs) { mName = rhs.mName; mCount = rhs.mCount; return *this;}Widget::Widget(Widget&amp;&amp; rhs) : mName(std::move(rhs.mName)) , mCount(rhs.mCount) {}Widget&amp; Widget::operator=(Widget&amp;&amp; rhs) { mName = std::move(rhs.mName); mCount = rhs.mCount; return *this}</pre><p>這裡需要注意幾點。第一點，為什麼兩個賦值函數都要返回指向自身的引用。這是為了能像內置類型一樣做連續賦值，如x=y=z。第二點，兩個移動函數中調用了C++11中新增的函數std::move，這個函數的功能是將一個左值轉化成右值，這樣才能進行移動。其中rhs是一個右值引用，但為什麼它的成員是左值？因為它有名字，可以取到地址。前面提到過，右值引用本身是左值，它的成員也是左值。通過std::move就可以將它轉化成右值，此時進行移動才是安全的。</p><p>下面這個例子類似智能指針。</p><p><strong>避免無意的移動變複製</strong></p><p>· 通常移動要比複製開銷更低。</p><p>· 如果沒有移動函數，會調用複製函數。</p><p>· 造成性能損失，且難以發現。</p><p>· 建議：將默認生成的特殊函數聲明為default。</p><p>實際上我們推薦大家對每個需要編譯器生成的複製函數和移動函數進行顯式定義並聲明為default。這樣可以避免無意的將移動操作變為複製操作。比如下面展示的代碼中，StringTable本身沒有聲明析構、複製和移動函數，因此編譯器為自動為它生成這些函數。</p><pre>class StringTable {public: StringTable() {} ... // 編譯器生成析構、複製、移動函數private: std::map&lt;int, std::string&gt; values;};</pre><p>一旦用戶為它定義了析構函數，希望在析構時寫入日誌。那麼根據規則，編譯器就不再會為它生成移動函數了。但在實際用到移動函數的時候編譯也不會失敗，編譯器會去調用相應的複製函數，複製函數是不會受到析構函數的影響的。這時，我們以為發生的是移動，即移動指針，開銷很低。但實際上發生了複製，開銷變得很高。</p><pre>class StringTable {public: StringTable() { makeLogEntry("Creating StringTable object"); } ~StringTable() { makeLogEntry("Destroying StringTable object"); }private: std::map&lt;int, std::string&gt; values;};</pre><p><strong>禁止移動或複製</strong></p><p>· 有些類型不希望被移動或複製</p><p>· C++98中通過只聲明private的複製函數來實現。</p><p>· C++11中通過聲明特殊函數為delete來實現。</p><p>但有些類型是不希望被移動或複製的，這時該如何做呢？C++98中，通過下面這段來實現，聲明覆制函數並標記為private。類外無法調用，類內無法鏈接。但這種方式比較隱晦，不直接。</p><pre>class Widget {public: ...private: Widget(const Widget&amp;); Widget&amp; operator=(const Widget&amp;);};</pre><p>C++11中給出了一種更為安全的方法。如下面這段代碼所示，將這些函數聲明稱delete，那麼編譯器就不會生成這些函數了，並且也無法被自定義，徹底禁用了移動和複製。Delete還有一些其他用途，但在這裡就不展開介紹了。</p><pre>class Widget {public: Widget(const Widget&amp;) = delete; Widget&amp; operator=(const Widget&amp;) = delete; Widget(Widget&amp;&amp;) = delete; Widget&amp; operator=(Widget&amp;&amp;) = delete;};</pre><p><strong>移動和複製函數可以是虛函數嗎?</strong></p><p>下面對這些特殊函數進行一些探索，大家知道構造函數不可以是虛函數，而析構函數有時必須為虛函數，那麼兩個賦值函數可以是虛函數嗎？以下面這段代碼為例，將Base類中的賦值函數聲明為虛的，並在Derived子類中改寫它。</p><pre>struct Base { virtual ~Base() {} virtual Base&amp; operator=(const Base&amp; b);};struct Derived: public Base { virtual Derived&amp; operator=(const Derived&amp; d);};</pre><p>從編譯器的角度看，賦值函數也是一種普通函數，當然可以是虛的。但從使用者的角度，虛函數用在多態場景下，也就是用基類的指針或引用，調用賦值操作，實際調用的卻是派生類的賦值函數。那麼可能是這個場景：</p><pre>int main() { Base* p0 = new Derived(); Base* p1 = new Derived(); *p0 = *p1;}</pre><p>在這一例子中通過基類指針完成派生類的賦值。但這裡派生類根本沒有改寫基類的虛函數，因為虛函數的改寫規則是，函數名、參數等要與基類完全相同。因此，編譯器不會認為它們是改寫的關係，而會認為Derived又聲明瞭一個自己的虛函數。</p><pre>struct Derived: public Base { virtual Derived&amp; operator=(const Base&amp;); virtual Derived&amp; operator=(const Derived&amp;);};</pre><p>這才是編譯器看到的Derived類。那麼應該如何實現呢？可以在Base基類中實現Clone接口，來實現多態複製。</p><pre>struct Base { ... Base* Clone() const = 0;};</pre><p>小結：</p><p>· 虛函數要求參數類型完全相同。</p><p>· 無法正確改寫基類的虛的移動和複製函數。</p><p>· 通過虛的Clone函數來實現多態複製。</p><p>· 移動函數不適合多態行為。</p><p><strong>正確的複製與移動基類</strong></p><p>在實現派生類的複製和移動時，通常會比較關注，是否有成員忘記處理。除了派生類本身的成員對象外，還需要處理基類的對象。以下面這段代碼為例，基類Base中有成員x，派生類Derived類中有成員y。在複製的時候只複製了y，因此x的值並沒有發生改變。這就是由於在複製時，沒有複製基類的對象，導致基類的對象被默認構造了，丟失了原對象的x。這種錯誤與之前介紹過的移動與複製問題一樣，很難被發現。</p><pre>struct Base { Base(): x(0) {} Base(const Base&amp; b): x(b.x) {} Base&amp; operator=(const Base&amp; b) { x = b.x; } int x;};struct Derived: public Base { Derived(): y(1) {} Derived(const Derived&amp; d): y(d.y) {} Derived&amp; operator=(const Derived&amp; d) { y = d.y; } int y;};int main() { Derived d0; d0.x = 2; d0.y = 2; Derived d1 = d0; printf("%d %d\n", d1.x, d1.y); //0 2 d1.x = 3; d1 = d0; printf("%d %d\n", d1.x, d1.y); //3 2}</pre><p>為了避免這樣的錯誤，鼓勵大家做到以下兩點：</p><p>· 移動/複製構造函數初始化列表首先處理基類。</p><p>· 移動/複製賦值函數首先調用基類賦值函數。</p><p>正確的寫法如下。</p><pre>Derived::Derived(const Derived&amp; d): Base(d), y(d.y) {}Derived&amp; Derived::operator=(const Derived&amp; d) { Base::operator=(d); y = d.y;}</pre><p><strong>移動與複製前先判斷是否為自身</strong></p><p>在前面介紹的例子中，在移動與複製前都先判斷了參數和this是否指向了同一個對象。因為，如果不判斷是否為自身，可能會導致資源洩露、進程崩潰。</p><p>以下面這段代碼為例。在做複製時先將自身的pb刪除，然後根據目標pb進行深複製，再返回自身引用。在這種情況下，如果自身的pb和目標pb指向同一個值，那麼在刪除自身的同時，目標pb也被刪除了。在移動時同理。</p><pre>class Widget { ...private: Bitmap* pb;};Widget&amp; Widget::operator=(const Widget&amp; rhs) { delete pb; pb = new Bitmap(*rhs.pb); return *this;}</pre><p>正確的做法如下面這段代碼所示。先判斷再進行移動或複製。</p><pre>Widget&amp; Widget::operator=(const Widget&amp; rhs) { if (this != &amp;rhs) { delete pb; pb = new Bitmap(*rhs.pb); } return *this;}</pre><p>但這樣做還是存在問題。假設在進行Bitmap的深複製的時候拋出了異常。被複制的pb對象已經被刪除了，那麼說明這兩個函數不是異常安全的。這種情況該如何處理呢？</p><p><strong>實現異常安全的複製賦值函數</strong></p><p>異常安全是指當異常拋出後：</p><p>· 不洩露資源</p><p>· 不破壞已有數據</p><p>對於前面介紹的場景中，如果調用複製的過程中拋了異常，對構造函數來說，需要把已經構造的成員析構掉。對於賦值函數來說，由於拋異常是在複製操作未完成的時候出現的，要使得已經被賦值的對象不能被修改。如何實現呢？有一種做法是結合移動函數和複製構造函數。對移動函數來說，沒有產生新資源，一般不會出現異常。而前面介紹過，複製構造函數比較容易實現異常安全。具體做法如下面這段代碼所示。</p><pre>class Widget { ...private: Bitmap* pb;};Widget::Widget(Widget&amp;&amp; rhs) { pb = rhs.pb; rhs.pb = nullptr;}Widget&amp; Widget::operator=(Widget&amp;&amp; rhs) { pb = rhs.pb; rhs.pb = nullptr;}Widget::Widget(const Widget&amp; rhs) { pb = new Bitmap(*rhs.pb);}Widget&amp; Widget::operator=(const Widget&amp; rhs) { Widget tmp(rhs); *this = std::move(tmp); return *this;}</pre><p>先通過複製構造函數構造tmp，然後將tmp移動賦值給this。假如在調用複製構造時拋出異常，由於還未調用賦值，對象就不會被修改，而在移動過程中也不會出現異常。那麼這個複製賦值函數就是異常安全的。而在C++98中，沒有move。但可以藉助swap函數實現。</p><p>總結，實現異常安全的複製賦值函數的方法：</p><p>· C++98中使用複製構造+swap</p><p>· C++11中使用複製構造+移動賦值函數</p><p><strong>移動函數不能拋異常</strong></p><p>需要強調的是，在剛才的例子中，對移動函數存在如下假設：</p><p>· 廉價</p><p>· 不分配資源</p><p>· 不拋異常</p><p>在具體實現中，我們應儘量保證這種假設，但如果出現例外情況，調用了可能出現異常的函數。建議不要進行處理，而是將移動函數聲明為noexcept，讓程序奔潰，如下面這段代碼。</p><pre>Widget::Widget(Widget&amp;&amp; rhs) noexcept { pb = rhs.pb; rhs.pb = nullptr;}Widget&amp; Widget::operator=(Widget&amp;&amp; rhs) noexcept { pb = rhs.pb; rhs.pb = nullptr;}</pre><p>理由是絕大多數場景，移動函數拋異常都是遇到很嚴重的問題了，此時再讓程序繼續跑下去也沒什麼意義了，不如早點crash，還能早點恢復。這也是分佈式服務的一個理念，任其崩潰。</p><p>本文由雲棲志願小組馬JY整理，編輯百見。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>揭開</a></li><li><a>C++</a></li><li><a>移動</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5bfa8675.html alt=揭開丙烯瘋狂的面紗 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5bfa8675.html title=揭開丙烯瘋狂的面紗>揭開丙烯瘋狂的面紗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff2ca31a.html alt=歐航局警告：地球磁北極移動速度驚人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff2ca31a.html title=歐航局警告：地球磁北極移動速度驚人>歐航局警告：地球磁北極移動速度驚人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html alt=C++哈希表是如何解決衝突的? class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ac4410086e640ea82846bde1dd72c65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5131775.html title=C++哈希表是如何解決衝突的?>C++哈希表是如何解決衝突的?</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f82b787b.html alt=流式編碼體驗：C++智能成員列表拉取 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d058f34e27f64b069d334ca6aa6cb793 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f82b787b.html title=流式編碼體驗：C++智能成員列表拉取>流式編碼體驗：C++智能成員列表拉取</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62342a91.html alt=物理學家終於揭開β衰變謎題！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9eb5d30c1e3c4b67ae56f7a274e2b4c2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62342a91.html title=物理學家終於揭開β衰變謎題！>物理學家終於揭開β衰變謎題！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2f3d6bb7.html alt=移動電源也玩跨界！紫米出品多功能移動電源，50W快充+HUB class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/7bfad3cf61a0461eb4154246f857de0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2f3d6bb7.html title=移動電源也玩跨界！紫米出品多功能移動電源，50W快充+HUB>移動電源也玩跨界！紫米出品多功能移動電源，50W快充+HUB</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d5f5883.html alt=移動電源新玩法：紫米（ZMI）10000mA多功能移動電源 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7f24cd8f70e24eb8801fb305f245a7e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d5f5883.html title=移動電源新玩法：紫米（ZMI）10000mA多功能移動電源>移動電源新玩法：紫米（ZMI）10000mA多功能移動電源</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2173316a.html alt=小米紫米推出奇葩移動電源，自帶HDMI接口，還能看4K class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/77ba07777c5846f78bc9e725a4c3b984 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2173316a.html title=小米紫米推出奇葩移動電源，自帶HDMI接口，還能看4K>小米紫米推出奇葩移動電源，自帶HDMI接口，還能看4K</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f04d16e.html alt=部分移動用戶遭遇無故停機，客服回覆稱系統故障 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f04d16e.html title=部分移動用戶遭遇無故停機，客服回覆稱系統故障>部分移動用戶遭遇無故停機，客服回覆稱系統故障</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c95fe5b8.html alt="越吃越上癮 德山警方揭開上癮米粉背後的“毒”配方" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rf8ybzZ986l7u2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c95fe5b8.html title="越吃越上癮 德山警方揭開上癮米粉背後的“毒”配方">越吃越上癮 德山警方揭開上癮米粉背後的“毒”配方</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>