<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>帶你搞定多線程，併發編程關鍵字Java多線程之volatile | 极客快訊</title><meta property="og:title" content="帶你搞定多線程，併發編程關鍵字Java多線程之volatile - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/79e01a43526949a3b1ce35f41d4f0d5e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1ad88931.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1ad88931.html><meta property="article:published_time" content="2020-11-14T21:06:28+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:28+08:00"><meta name=Keywords content><meta name=description content="帶你搞定多線程，併發編程關鍵字Java多線程之volatile"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1ad88931.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>帶你搞定多線程，併發編程關鍵字Java多線程之volatile</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><pre><code>認真寫文章，用心做分享。公眾號：Java耕耘者   文章都會在裡面更新，整理的資料也會放在裡面。</code></pre><h2 class=pgc-h-arrow-right>volatile 的應用場景</h2><ul><li>使用 volatile 必須具備的條件 對變量的寫操作不依賴於當前值。 該變量沒有包含在具有其他變量的不變式中。</li><li>只有在狀態真正獨立於程序內其他內容時才能使用 volatile。</li></ul><p>場景： 狀態標誌、一次性安全發佈、獨立觀察、volatile bean 模式、開銷較低的讀－寫鎖策略、 雙重檢查（double-checked）</p><h1 class=pgc-h-arrow-right>目錄:</h1><ol start=1><li>volatile，使用時該注意什麼？</li><li>volatile的實現原理(內存屏障、CPU緩存、MESI協議)</li><li>volatile與synchronized的區別</li></ol><div class=pgc-img><img alt=帶你搞定多線程，併發編程關鍵字Java多線程之volatile onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/79e01a43526949a3b1ce35f41d4f0d5e><p class=pgc-img-caption></p></div><p></p><h1 class=pgc-h-arrow-right>1. 什麼是volatile？</h1><p>volatile中文意為揮發物，不穩定的。在Java中也是一個關鍵字，用於修飾變量。</p><ol start=1><li>在JMM（Java Memory Model，Java內存模型）中，有main memory，每個線程也有自己的memory (例如寄存器)。為了性能，一個線程會在自己的memory中保持要訪問的變量的副本。</li><li>這樣就會出現同一個變量在某個瞬間，在一個線程的memory中的值可能與另外一個線程memory中的值，或者main memory中的值不一致的情況。</li><li><strong>一個變量聲明為volatile，就意味著這個變量是隨時會被其他線程修改，線程在每次使用變量的時候，都會讀取變量修改後的最新值</strong>。</li></ol><h1 class=pgc-h-arrow-right>volatile的使用時注意：</h1><ol start=1><li>volatile無論是修飾<strong>實例變量</strong>還是<strong>靜態變量</strong>，都需要放在數據類型關鍵字之前，即放在String、int等之前。</li><li>volatile和final不能同時修飾一個變量。volatile 是保證變量被寫時其結果其他線程可見，而final已經讓該變量不能被再次寫了。</li></ol><div class=pgc-img><img alt=帶你搞定多線程，併發編程關鍵字Java多線程之volatile onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/05c1c53e768645ffa863e28f548cbcc1><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2.1 volatile可以保證原子性嗎？</h1><p><strong>不能</strong>。</p><ul><li>我們知道，原子性是指一個操作不可再被分隔成多步。一個操作或者多個操作 要麼全部執行且執行的過程不會被任何因素打斷，要麼就都不執行。</li><li>對於volatile來說，如果一個操作本身不是原子性的，那麼使用volatile作用於這個操作上的一個變量，其也是無法保證原子性的。</li></ul><p>例如我們常碰到的i++的問題。</p><pre><code>i = 1; //原子性操作，不用使用volatile也不會出現線程安全問題。</code></pre><pre><code>volatile int i = 0;i++; //非原子性操作</code></pre><p>如果我們開啟200個線程併發執行i++這行代碼，每個線程中只執行一遍。如果volatile可以保證原子性的話，那麼i的最終結果應該是200；而實際上我們發現這個值是會小於200的，原因是什麼呢？</p><pre><code>// i++ 其可以被拆解為1、線程讀取i2、temp = i + 13、i = temp</code></pre><ol start=1><li>例如當 i=5 的時候A,B兩個線程同時讀入了 i 的值</li><li>然後A線程執行了 temp = i + 1的操作， 要注意，此時的 i 的值還沒有變化，然後B線程也執行了temp = i + 1的操作，注意，此時A，B兩個線程保存的 i 的值都是5，temp 的值都是6</li><li>然後A線程執行了 i = temp （6）的操作，此時i的值會立即刷新到主存並通知其他線程保存的 i 值失效， 此時B線程需要重新讀取 i 的值那麼此時B線程保存的 i 就是6</li><li>同時B線程保存的 temp 還仍然是6， 然後B線程執行 i=temp （6），所以導致了計算結果比預期少了1。</li></ol><p>那麼如何保證i++這種操作的線程安全呢？</p><ol start=1><li>使用synchronized關鍵字或者Lock。至於為什麼，可以看下synchronized與原子性</li></ol><pre><code>synchronized(object){    i++;}</code></pre><ol start=2><li>使用支持原子性操作的類，如 java.util.concurrent.atomic.AtomicInteger，它使用的是CAS(compare and swap，比較並替換)算法，效率優於第 1 種。</li></ol><h1 class=pgc-h-arrow-right>2.2 volatile與可見性</h1><p>volatile關鍵字的變量寫操作時，強制緩存和主存同步，其他線程讀時候發現緩存失效，就去讀主存，由此保證了變量的可見性。</p><h1 class=pgc-h-arrow-right>2.3 volatile與有序性</h1><div class=pgc-img><img alt=帶你搞定多線程，併發編程關鍵字Java多線程之volatile onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/452bb2971e8e4f4691230895614a2641><p class=pgc-img-caption></p></div><p>volatile可以禁止指令重排序，所以說其是可以保證有序性的。</p><blockquote><p>什麼是指令重排序（Instruction Reorder）?</p><p>在Java內存模型中，允許編譯器和處理器對指令進行重排序，重排序的結果不會影響到<strong>單線程</strong>的執行，但<strong>不能保證多線程併發執行</strong>時不受影響。</p><p>例如以下代碼在未發生指令重排序時，其執行順序為1->2->3->4。但在真正執行時，將可能變為1->2->4->3或者2->1->3->4或者其他。但其會保證1處於3之前，2處於4之前。所有最終結果都是a=10; b=20。</p><p>int a = 0;//語句1 int b = 1;//語句2 a = 10; //語句3 b = 20; //語句4</p><p>但如果是多線程情況下，另一個線程中有以下程序。當上述的執行順序被重排序為1->2->4->3，當線程1執行到第3步b=20時，切換到線程2執行，其會輸出a此時已經是10了，而此時a的值其實還是為0。</p><p>if(b == 20){ System.out.print("a此時已經是10了"); }</p></blockquote><h1 class=pgc-h-arrow-right>3. volatile的實現原理</h1><h1 class=pgc-h-arrow-right>3.1 內存屏障與指令重排序</h1><ul><li>要知道volatile是如何禁止指令重排序的，首先需要了解一個概念內存屏障。</li></ul><p>內存屏障，也稱內存柵欄，內存柵障，屏障指令等，其是一種CPU指令</p><ul><li>它使得 CPU 或編譯器在對內存進行操作的時候, 嚴格按照一定的順序來執行, 也就是說在memory barrier 之前的指令和memory barrier之後的指令不會由於系統優化等原因而導致亂序。</li></ul><h1 class=pgc-h-arrow-right>3.1.1 JVM中的4中內存屏障</h1><ol start=1><li>LoadLoad屏障：</li></ol><pre><code>//抽象場景：Load1; LoadLoad; Load2</code></pre><p>Load1 和 Load2 代表兩條讀取指令。在Load2要讀取的數據被訪問前，保證Load1要讀取的數據被讀取完畢。</p><ol start=2><li>StoreStore屏障：</li></ol><pre><code>//抽象場景：Store1; StoreStore; Store2</code></pre><p>Store1 和 Store2代表兩條寫入指令。在Store2寫入執行前，保證Store1的寫入操作對其它處理器可見</p><ol start=3><li>LoadStore屏障：</li></ol><pre><code>//抽象場景：Load1; LoadStore; Store2</code></pre><p>在Store2被寫入前，保證Load1要讀取的數據被讀取完畢。</p><ol start=4><li>StoreLoad屏障：</li></ol><pre><code>//抽象場景：Store1; StoreLoad; Load2</code></pre><p>在Load2讀取操作執行前，保證Store1的寫入對所有處理器可見。StoreLoad屏障的開銷是四種屏障中最大的。</p><h1 class=pgc-h-arrow-right>3.1.2 volatile與內存屏障的關係</h1><p>在一個變量被volatile修飾後，JVM會為我們做兩件事：</p><ol start=1><li>在每個volatile寫操作前插入StoreStore屏障，在寫操作後插入StoreLoad屏障。</li><li>在每個volatile讀操作前插入LoadLoad屏障，在讀操作後插入LoadStore屏障。</li></ol><p>還是使用上面的例子：</p><p>這次使用volatile修飾變量b</p><pre><code>int a = 0;//語句1volatile int b = 1;//語句2//在線程1中執行的語句a = 10; //語句3b = 20; //語句4//在線程2中執行的語句if(b == 20){   System.out.print("a此時已經是10了");}</code></pre><p>在編譯之後線程1中的語句將類似於</p><pre><code> a = 10; //語句3 ----------- StoreStore屏障 --------------- b = 20; //語句4 ----------- StoreLoad屏障 ---------------</code></pre><p>由於屏障的存在，語句3和語句4將無法被指令重排序，從而可以保證在b=20時，a已經被賦值為10了。那麼這個程序也就不存在線程安全問題了。</p><h1 class=pgc-h-arrow-right>3.1.3 內存屏障的性能影響</h1><p>內存屏障阻礙了CPU採用優化技術來降低內存操作延遲，必須考慮因此帶來的性能損失。為了達到最佳性能，最好是把要解決的問題模塊化，這樣處理器可以按單元執行任務，然後在任務單元的邊界放上所有需要的內存屏障。採用這個方法可以讓處理器不受限的執行一個任務單元。</p><h1 class=pgc-h-arrow-right>3.2 volatile如何實現可見性？</h1><p>要知道volatile是如何保證可見性的需要先了解下有關CPU緩存的概念。</p><h1 class=pgc-h-arrow-right>3.2.1 CPU緩存</h1><p>我們知道<strong>CPU的運算速度</strong>要比<strong>內存的讀寫速度</strong>快很多，這就造成了內存無法跟上CPU的情況，由此出現了CPU緩存。其是CPU與內存之間的臨時數據交換器，我們常見的CPU會有3級緩存，常稱為L1、L2、L3。</p><p>下圖是Intel Core i7處理器的高速緩存概念模型</p><div class=pgc-img><img alt=帶你搞定多線程，併發編程關鍵字Java多線程之volatile onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/522ee4eff496494faef5cc6b7278372e><p class=pgc-img-caption></p></div><p>當系統運行時，CPU執行計算的過程如下：</p><ol start=1><li>程序以及數據被加載到主內存</li><li>指令和數據被加載到CPU緩存</li><li>CPU執行指令，把結果寫到高速緩存</li><li>高速緩存中的數據寫回主內存</li></ol><p>在上述的緩存模型下，當多核併發執行某項任務時就容易出現問題。eg.</p><ol start=1><li>核0先從內存中讀取了變量a。</li><li>核3也從內存中讀取了變量a。</li><li>核0修改了變量a，並同步到了主內存中。</li><li>核3開始使用變量a，但值仍然是舊的。</li></ol><p>為了解決這類問題，出現了針對CPU的<strong>MESI協議</strong>。</p><h1 class=pgc-h-arrow-right>3.2.2 MESI協議</h1><blockquote><p>在早期的CPU中，是通過在總線加LOCK#鎖的方式實現的（又稱<strong>總線鎖</strong>）。當一個CPU對其緩存中的數據進行操作的時候，往總線中發送一個Lock信號。 這個時候，所有CPU收到這個信號之後就不操作自己緩存中的對應數據了，當操作結束，釋放鎖以後，所有的CPU就去內存中獲取最新數據更新。</p></blockquote><p>但這種方式開銷太大，所以Intel開發了緩存一致性協議，也就是MESI協議。它的方法是<strong>在CPU緩存中保存一個標記位</strong>，這個標記位有四種狀態:</p><ul><li>M: Modify，修改緩存，當前CPU的緩存已經被修改了，即與內存中數據已經不一致了；</li><li>E: Exclusive，獨佔緩存，當前CPU的緩存和內存中數據保持一致，而且其他處理器並沒有可使用的緩存數據；</li><li>S: Share，共享緩存，和內存保持一致的一份拷貝，多組緩存可以同時擁有針對同一內存地址的共享緩存段；</li><li>I: Invalid，無效緩存，這個說明CPU中的緩存已經不能使用了。</li></ul><p>CPU的讀取遵循下面幾點：</p><ul><li>如果緩存狀態是I，那麼就從內存中讀取，否則就從緩存中直接讀取。</li><li>如果緩存處於M或E的CPU讀取到其他CPU有讀操作，就把自己的緩存寫入到內存中，並將自己的狀態設置為S。</li><li>只有緩存狀態是M或E的時候，CPU才可以修改緩存中的數據，修改後，緩存狀態變為M。</li></ul><blockquote><p>舉個常見的例子就是：</p><p>當CPU寫數據時，如果發現操作的變量是共享變量，即在其他CPU中也存在該變量的副本，那麼他會發出信號通知其他CPU將該變量的緩存行設置為無效狀態。當其他CPU使用這個變量時，首先會去嗅探是否有對該變量更改的信號，當發現這個變量的緩存行已經無效時，會從新從內存中讀取這個變量。</p></blockquote><h1 class=pgc-h-arrow-right>3.2.3 volatile的可見性原理</h1><p>瞭解了上面的內容，就可以很容易的理解volatile是如何實現的了。</p><ol start=1><li>首先被volatile關鍵字修飾的共享變量在轉換成彙編語言時，會加上一個以lock為前綴的指令</li><li>當CPU發現這個指令時，立即做兩件事： 將當前內核高速緩存行的數據立刻回寫到內存 通過MESI協議使在其他內核裡緩存了的數據無效，這樣其他線程也必須從內存中重新讀取數據了。</li></ol><h1 class=pgc-h-arrow-right>4. volatile與synchronized的區別</h1><p>volatile到此也介紹的不少了，最後來說下其與synchronized的區別。</p><ol start=1><li>volatile是變量修飾符，而synchronized則作用於一段代碼或方法。</li><li>volatile只是在線程內存和“主”內存間同步某個變量的值；而synchronized通過鎖定和解鎖某個監視器同步所有變量的值。顯然synchronized要比volatile消耗更多資源。</li><li>volatile不能保證原子性，可以保證可見性、有序性（靠內存屏障實現）。synchronized可以保證原子性、可見性、有序性。當你和面試官說到這裡時，你最好清楚裡面的具體細節，例如是從何種角度來看的有序性，以及如何實現的該特性，不然面試官很容易被問住的。</li></ol><h1 class=pgc-h-arrow-right>結語</h1><p>至此關於volatile的內容到這裡就結束了，如果文中有錯誤的地方、或者有其他關於volatile比較重要的內容又沒有介紹到的，歡迎在評論區裡留言，一起交流學習。<br></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>多線程</a></li><li><a>發編程</a></li><li><a>關鍵</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html alt=多線程之ThreadLocal的那些事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html title=多線程之ThreadLocal的那些事>多線程之ThreadLocal的那些事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56c317a5.html alt=科普文：神祕的汙水處理流程，都有哪些關鍵步驟呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7113d7e544d14241957a3996c2bec8b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56c317a5.html title=科普文：神祕的汙水處理流程，都有哪些關鍵步驟呢？>科普文：神祕的汙水處理流程，都有哪些關鍵步驟呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d86b1a6d.html alt=手機顯示屏關鍵材料成本降了，汙染輕了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1531616443789c3e2d32478 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d86b1a6d.html title=手機顯示屏關鍵材料成本降了，汙染輕了>手機顯示屏關鍵材料成本降了，汙染輕了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html alt=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cce9b3fb23ce41b88311823510e419da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html title=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。>PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf248ef5.html alt=2018年收藏和田玉最新關鍵詞——線上交易！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/54000003fda0ced1dd2b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf248ef5.html title=2018年收藏和田玉最新關鍵詞——線上交易！>2018年收藏和田玉最新關鍵詞——線上交易！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/76b97e91.html alt=先聚人再談交易，“社區”是盛世收藏十年來的關鍵詞 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/6778/2898233604 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/76b97e91.html title=先聚人再談交易，“社區”是盛世收藏十年來的關鍵詞>先聚人再談交易，“社區”是盛世收藏十年來的關鍵詞</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c867cb4.html alt=關鍵時刻，脈動有些“不在狀態”，全面升級後能否“脈動回來”？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/821410d754234b3e8af93b2a8d1193b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c867cb4.html title=關鍵時刻，脈動有些“不在狀態”，全面升級後能否“脈動回來”？>關鍵時刻，脈動有些“不在狀態”，全面升級後能否“脈動回來”？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html alt=Java併發編程：進程和線程之由來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/4f658919-1d85-46bc-bbf1-64aac52f4c80 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb1cbd4a.html title=Java併發編程：進程和線程之由來>Java併發編程：進程和線程之由來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ee2728c4.html alt="Java核心知識 多線程併發 進程調度算法 （三十二）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ee53d84c407e492494d103a3f7a9481c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ee2728c4.html title="Java核心知識 多線程併發 進程調度算法 （三十二）">Java核心知識 多線程併發 進程調度算法 （三十二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ff2ba73c.html alt=java併發編程-學習方法、進程和線程的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/96ffe13dbf2b45109664e14541532812 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ff2ba73c.html title=java併發編程-學習方法、進程和線程的區別>java併發編程-學習方法、進程和線程的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b7ce9ac1.html alt=java併發編程之進程狀態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0779ab7cadfe428f8d74d66161aa48b4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b7ce9ac1.html title=java併發編程之進程狀態>java併發編程之進程狀態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d62f6365.html alt=java併發編程之進程與線程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a1b777a6b4c24fc390776034329c92d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d62f6365.html title=java併發編程之進程與線程>java併發編程之進程與線程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d7504b3a.html alt=python併發編程：進程的創建和結束 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d7504b3a.html title=python併發編程：進程的創建和結束>python併發編程：進程的創建和結束</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6221fc43.html alt=python入門技能：併發編程之多進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/876b9b75cb7d413cab99ea1cc2303b75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6221fc43.html title=python入門技能：併發編程之多進程>python入門技能：併發編程之多進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b45d2de0.html alt=併發編程介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/2acffefde3f548f7b03d59fe324fabaa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b45d2de0.html title=併發編程介紹>併發編程介紹</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>