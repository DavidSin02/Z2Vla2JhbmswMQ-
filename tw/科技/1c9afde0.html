<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一起來談談ThreadLocal 原理吧！你需要了解！ | 极客快訊</title><meta property="og:title" content="一起來談談ThreadLocal 原理吧！你需要了解！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/499a403f2b63464db8e3e12298c1a3e5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1c9afde0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1c9afde0.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="一起來談談ThreadLocal 原理吧！你需要了解！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1c9afde0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一起來談談ThreadLocal 原理吧！你需要了解！</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>我們都知道當多線程訪問共享可變數據時，涉及到線程間同步的問題，並不是所有時候，都要用到共享數據，所以就需要線程封閉出場了。</strong></p><p>數據都被封閉在各自的線程之中，就不需要同步，這種通過將數據封閉在線程中而避免使用同步的技術稱為<strong>「線程封閉」</strong>。</p><p>本文主要介紹線程封閉中的其中一種體現：ThreadLocal，將會介紹什麼是 ThreadLocal；從 ThreadLocal 源碼角度分析，最後介紹 ThreadLocal 的應用場景。</p><h2 class=pgc-h-arrow-right>什麼是 ThreadLocal？</h2><p>ThreadLocal 是 Java 裡一種特殊變量，它是一個線程級別變量，每個線程都有一個 ThreadLocal 就是每個線程都擁有了自己獨立的一個變量，競態條件被徹底消除了，在併發模式下是絕對安全的變量。</p><p>可以通過 ThreadLocal value = new ThreadLocal(); 來使用。</p><p>會自動在每一個線程上創建一個 T 的副本，副本之間彼此獨立，互不影響，可以用 ThreadLocal 存儲一些參數，以便在線程中多個方法中使用，用以代替方法傳參的做法。</p><p>下面通過例子來了解下 ThreadLocal：</p><pre><code>public class ThreadLocalDemo {	/**	 * ThreadLocal變量，每個線程都有一個副本，互不干擾	 */	public static final ThreadLocal&lt;String&gt; THREAD_LOCAL = new ThreadLocal&lt;&gt;();	public static void main( String[] args ) throws Exception	{		new ThreadLocalDemo().threadLocalTest();	}	public void threadLocalTest() throws Exception	{		/* 主線程設置值 */		THREAD_LOCAL.set( "wupx" );		String v = THREAD_LOCAL.get();		System.out.println( "Thread-0線程執行之前，" + Thread.currentThread().getName() + "線程取到的值：" + v );		new Thread( new Runnable()			    {				    @Override				    public void run()				    {					    String v = THREAD_LOCAL.get();					    System.out.println( Thread.currentThread().getName() + "線程取到的值：" + v );		                            /* 設置 threadLocal */					    THREAD_LOCAL.set( "huxy" );					    v = THREAD_LOCAL.get();					    System.out.println( "重新設置之後，" + Thread.currentThread().getName() + "線程取到的值為：" + v );					    System.out.println( Thread.currentThread().getName() + "線程執行結束" );				    }			    } ).start();		/* 等待所有線程執行結束 */		Thread.sleep( 3000L );		v = THREAD_LOCAL.get();		System.out.println( "Thread-0線程執行之後，" + Thread.currentThread().getName() + "線程取到的值：" + v );	}}</code></pre><p>首先通過 static final 定義了一個 THREAD_LOCAL 變量，其中 static 是為了確保全局只有一個保存 String 對象的 ThreadLocal 實例；final 確保 ThreadLocal 的實例不可更改，防止被意外改變，導致放入的值和取出來的不一致，另外還能防止 ThreadLocal 的內存洩漏。上面的例子是演示在不同的線程中獲取它會得到不同的結果，運行結果如下：</p><pre><code>Thread-0線程執行之前，main線程取到的值：wupxThread-0線程取到的值：null重新設置之後Thread-0線程取到的值為：huxyThread-0線程執行結束Thread-0線程執行之後，main線程取到的值：wupx</code></pre><p>首先在 Thread-0 線程執行之前，先給 THREAD_LOCAL 設置為 wupx，然後可以取到這個值，然後通過創建一個新的線程以後去取這個值，發現新線程取到的為 null，意外著這個變量在不同線程中取到的值是不同的，不同線程之間對於 ThreadLocal 會有對應的副本，接著在線程 Thread-0 中執行對 THREAD_LOCAL 的修改，將值改為 huxy，可以發現線程 Thread-0 獲取的值變為了 huxy，主線程依然會讀取到屬於它的副本數據 wupx，這就是線程的封閉。</p><p>看到這裡，我相信大家一定會好奇 ThreadLocal 是如何做到多個線程對同一對象 set 操作，但是 get 獲取的值還都是每個線程 set 的值呢，接下來就讓我們進入源碼解析環節：</p><h2 class=pgc-h-arrow-right>ThreadLocal 源碼解析</h2><p>首先看下 ThreadLocal 都有哪些重要屬性：</p><pre><code>// 當前 ThreadLocal 的 hashCode，由 nextHashCode() 計算而來，用於計算當前 ThreadLocal 在 ThreadLocalMap 中的索引位置private final int threadLocalHashCode = nextHashCode();// 哈希魔數，主要與斐波那契散列法以及黃金分割有關private static final int HASH_INCREMENT = 0x61c88647;// 返回計算出的下一個哈希值，其值為 i * HASH_INCREMENT，其中 i 代表調用次數private static int nextHashCode() {    return nextHashCode.getAndAdd(HASH_INCREMENT);}// 保證了在一臺機器中每個 ThreadLocal 的 threadLocalHashCode 是唯一的private static AtomicInteger nextHashCode = new AtomicInteger();</code></pre><p>其中的 HASH_INCREMENT 也不是隨便取的，它轉化為十進制是 1640531527，2654435769 轉換成 int 類型就是 -1640531527，2654435769 等於 (√5-1)/2 乘以 2 的 32 次方。(√5-1)/2 就是黃金分割數，近似為 0.618，也就是說 0x61c88647 理解為一個黃金分割數乘以 2 的 32 次方，它可以保證 nextHashCode 生成的哈希值，均勻的分佈在 2 的冪次方上，且小於 2 的 32 次方。</p><p>下面是 javaspecialists 中一篇文章對它的介紹：</p><blockquote class=article-blockquote><p>❝</p><p>This number represents the golden ratio (sqrt(5)-1) times two to the power of 31 ((sqrt(5)-1) * (2^31)). The result is then a golden number, either 2654435769 or -1640531527.</p><p>❞</p></blockquote><p>下面用例子來證明下：</p><pre><code>private static final int HASH_INCREMENT = 0x61c88647;public static void main(String[] args) throws Exception {    int n = 5;    int max = 2 &lt;&lt; (n - 1);    for (int i = 0; i &lt; max; i++) {        System.out.print(i * HASH_INCREMENT &amp; (max - 1));        System.out.print(" ");    }}</code></pre><p>運行結果為：0 7 14 21 28 3 10 17 24 31 6 13 20 27 2 9 16 23 30 5 12 19 26 1 8 15 22 29 4 11 18 25</p><p>可以發現元素索引值完美的散列在數組當中，並沒有出現衝突。</p><h3 class=pgc-h-arrow-right>ThreadLocalMap</h3><p>除了上述屬性外，還有一個重要的屬性 ThreadLocalMap，ThreadLocalMap 是 ThreadLocal 的靜態內部類，當一個線程有多個 ThreadLocal 時，需要一個容器來管理多個 ThreadLocal，ThreadLocalMap 的作用就是管理線程中多個 ThreadLocal，源碼如下：</p><pre><code>static class ThreadLocalMap {	/**	 * 鍵值對實體的存儲結構	 */	static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {		// 當前線程關聯的 value，這個 value 並沒有用弱引用追蹤		Object value;		/**		 * 構造鍵值對		 *		 * @param k k 作 key,作為 key 的 ThreadLocal 會被包裝為一個弱引用		 * @param v v 作 value		 */		Entry(ThreadLocal&lt;?&gt; k, Object v) {			super(k);			value = v;		}	}	// 初始容量，必須為 2 的冪	private static final int INITIAL_CAPACITY = 16;	// 存儲 ThreadLocal 的鍵值對實體數組，長度必須為 2 的冪	private Entry[] table;	// ThreadLocalMap 元素數量	private int size = 0;	// 擴容的閾值，默認是數組大小的三分之二	private int threshold;}</code></pre><p>從源碼中看到 ThreadLocalMap 其實就是一個簡單的 Map 結構，底層是數組，有初始化大小，也有擴容閾值大小，數組的元素是 Entry，<strong>「Entry 的 key 就是 ThreadLocal 的引用，value 是 ThreadLocal 的值」</strong>。ThreadLocalMap 解決 hash 衝突的方式採用的是<strong>「線性探測法」</strong>，如果發生衝突會繼續尋找下一個空的位置。</p><p>這樣的就有可能會發生內存洩漏的問題，下面讓我們進行分析：</p><h3 class=pgc-h-arrow-right>ThreadLocal 內存洩漏</h3><p>ThreadLocal 在沒有外部強引用時，發生 GC 時會被回收，那麼 ThreadLocalMap 中保存的 key 值就變成了 null，而 Entry 又被 threadLocalMap 對象引用，threadLocalMap 對象又被 Thread 對象所引用，那麼當 Thread 一直不終結的話，value 對象就會一直存在於內存中，也就導致了內存洩漏，直至 Thread 被銷燬後，才會被回收。</p><p>那麼如何避免內存洩漏呢？</p><p>在使用完 ThreadLocal 變量後，需要我們手動 remove 掉，防止 ThreadLocalMap 中 Entry 一直保持對 value 的強引用，導致 value 不能被回收，其中 remove 源碼如下所示：</p><pre><code>/** * 清理當前 ThreadLocal 對象關聯的鍵值對 */public void remove() {	// 返回當前線程持有的 map	ThreadLocalMap m = getMap(Thread.currentThread());	if (m != null) {		// 從 map 中清理當前 ThreadLocal 對象關聯的鍵值對		m.remove(this);	}}</code></pre><p>remove 方法的時序圖如下所示：</p><div class=pgc-img><img alt="一起來談談ThreadLocal 原理吧！你需要了解！" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/499a403f2b63464db8e3e12298c1a3e5><p class=pgc-img-caption></p></div><p>remove 方法是先獲取到當前線程的 ThreadLocalMap，並且調用了它的 remove 方法，從 map 中清理當前 ThreadLocal 對象關聯的鍵值對，這樣 value 就可以被 GC 回收了。</p><p>那麼 ThreadLocal 是如何實現線程隔離的呢？</p><h3 class=pgc-h-arrow-right>ThreadLocal 的 set 方法</h3><p>我們先去看下 ThreadLocal 的 set 方法，源碼如下：</p><pre><code>/** * 為當前 ThreadLocal 對象關聯 value 值 * * @param value 要存儲在此線程的線程副本的值 */public void set(T value) {	// 返回當前ThreadLocal所在的線程	Thread t = Thread.currentThread();	// 返回當前線程持有的map	ThreadLocalMap map = getMap(t);	if (map != null) {		// 如果 ThreadLocalMap 不為空，則直接存儲&lt;ThreadLocal, T&gt;鍵值對		map.set(this, value);	} else {		// 否則，需要為當前線程初始化 ThreadLocalMap，並存儲鍵值對 &lt;this, firstValue&gt;		createMap(t, value);	}}</code></pre><p>set 方法的作用是把我們想要存儲的 value 給保存進去。set 方法的流程主要是：</p><ul><li>先獲取到當前線程的引用</li><li>利用這個引用來獲取到 ThreadLocalMap</li><li>如果 map 為空，則去創建一個 ThreadLocalMap</li><li>如果 map 不為空，就利用 ThreadLocalMap 的 set 方法將 value 添加到 map 中</li></ul><p>set 方法的時序圖如下所示：</p><div class=pgc-img><img alt="一起來談談ThreadLocal 原理吧！你需要了解！" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/db077816974a47b284549ab35e1e4800><p class=pgc-img-caption></p></div><p>其中 map 就是我們上面講到的 ThreadLocalMap，可以看到它是通過當前線程對象獲取到的 ThreadLocalMap，接下來我們看 getMap方法的源代碼：</p><pre><code>/** * 返回當前線程 thread 持有的 ThreadLocalMap * * @param t 當前線程 * @return ThreadLocalMap */ThreadLocalMap getMap(Thread t) {	return t.threadLocals;}</code></pre><p>getMap 方法的作用主要是獲取當前線程內的 ThreadLocalMap 對象，原來這個 ThreadLocalMap 是線程的一個屬性，下面讓我們看看 Thread 中的相關代碼：</p><pre><code>/** * ThreadLocal 的 ThreadLocalMap 是線程的一個屬性，所以在多線程環境下 threadLocals 是線程安全的 */ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre><p>可以看出每個線程都有 ThreadLocalMap 對象，被命名為 threadLocals，默認為 null，所以每個線程的 ThreadLocals 都是隔離獨享的。</p><p>調用 ThreadLocalMap.set() 時，會把當前 threadLocal 對象作為 key，想要保存的對象作為 value，存入 map。</p><p>其中 ThreadLocalMap.set() 的源碼如下：</p><pre><code>/** * 在 map 中存儲鍵值對&lt;key, value&gt; * * @param key   threadLocal * @param value 要設置的 value 值 */private void set(ThreadLocal&lt;?&gt; key, Object value) {	Entry[] tab = table;	int len = tab.length;	// 計算 key 在數組中的下標	int i = key.threadLocalHashCode &amp; (len - 1);	// 遍歷一段連續的元素，以查找匹配的 ThreadLocal 對象	for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) {		// 獲取該哈希值處的ThreadLocal對象		ThreadLocal&lt;?&gt; k = e.get();		// 鍵值ThreadLocal匹配，直接更改map中的value		if (k == key) {			e.value = value;			return;		}		// 若 key 是 null，說明 ThreadLocal 被清理了，直接替換掉		if (k == null) {			replaceStaleEntry(key, value, i);			return;		}	}	// 直到遇見了空槽也沒找到匹配的ThreadLocal對象，那麼在此空槽處安排ThreadLocal對象和緩存的value	tab[i] = new Entry(key, value);	int sz = ++size;	// 如果沒有元素被清理，那麼就要檢查當前元素數量是否超過了容量闕值(數組大小的三分之二)，以便決定是否擴容	if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) {		// 擴容的過程也是對所有的 key 重新哈希的過程		rehash();	}}</code></pre><p>相信到這裡，大家應該對 Thread、ThreadLocal 以及 ThreadLocalMap 的關係有了進一步的理解，下圖為三者之間的關係：</p><div class=pgc-img><img alt="一起來談談ThreadLocal 原理吧！你需要了解！" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4131172641b649859790c628511d2240><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>ThreadLocal 的 get 方法</h3><p>瞭解完 set 方法後，讓我們看下 get 方法，源碼如下：</p><pre><code>/** * 返回當前 ThreadLocal 對象關聯的值 * * @return */public T get() {	// 返回當前 ThreadLocal 所在的線程	Thread t = Thread.currentThread();	// 從線程中拿到 ThreadLocalMap	ThreadLocalMap map = getMap(t);	if (map != null) {		// 從 map 中拿到 entry		ThreadLocalMap.Entry e = map.getEntry(this);		// 如果不為空，讀取當前 ThreadLocal 中保存的值		if (e != null) {			@SuppressWarnings("unchecked")			T result = (T) e.value;			return result;		}	}	// 若 map 為空，則對當前線程的 ThreadLocal 進行初始化，最後返回當前的 ThreadLocal 對象關聯的初值，即 value	return setInitialValue();}</code></pre><p>get 方法的主要流程為：</p><ul><li>先獲取到當前線程的引用</li><li>獲取當前線程內部的 ThreadLocalMap</li><li>如果 map 存在，則獲取當前 ThreadLocal 對應的 value 值</li><li>如果 map 不存在或者找不到 value 值，則調用 setInitialValue() 進行初始化</li></ul><p>get 方法的時序圖如下所示：</p><div class=pgc-img><img alt="一起來談談ThreadLocal 原理吧！你需要了解！" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0106664e046945fea9d8491fedf8b509><p class=pgc-img-caption></p></div><p>其中每個 Thread 的 ThreadLocalMap 以 threadLocal 作為 key，保存自己線程的 value 副本，也就是保存在每個線程中，並沒有保存在 ThreadLocal 對象中。</p><p>其中 ThreadLocalMap.getEntry() 方法的源碼如下：</p><pre><code>/** * 返回 key 關聯的鍵值對實體 * * @param key threadLocal * @return */private Entry getEntry(ThreadLocal&lt;?&gt; key) {	int i = key.threadLocalHashCode &amp; (table.length - 1);	Entry e = table[i];	// 若 e 不為空，並且 e 的 ThreadLocal 的內存地址和 key 相同，直接返回	if (e != null &amp;&amp; e.get() == key) {		return e;	} else {		// 從 i 開始向後遍歷找到鍵值對實體		return getEntryAfterMiss(key, i, e);	}}</code></pre><h3 class=pgc-h-arrow-right>ThreadLocalMap 的 resize 方法</h3><p>當 ThreadLocalMap 中的 ThreadLocal 的個數超過容量閾值時，ThreadLocalMap 就要開始擴容了，我們一起來看下 resize 的源代碼：</p><pre><code>/** * 擴容，重新計算索引，標記垃圾值，方便 GC 回收 */private void resize() {	Entry[] oldTab = table;	int oldLen = oldTab.length;	int newLen = oldLen * 2;	// 新建一個數組，按照2倍長度擴容	Entry[] newTab = new Entry[newLen];	int count = 0;	// 將舊數組的值拷貝到新數組上	for (int j = 0; j &lt; oldLen; ++j) {		Entry e = oldTab[j];		if (e != null) {			ThreadLocal&lt;?&gt; k = e.get();			// 若有垃圾值，則標記清理該元素的引用，以便GC回收			if (k == null) {				e.value = null;			} else {				// 計算 ThreadLocal 在新數組中的位置				int h = k.threadLocalHashCode &amp; (newLen - 1);				// 如果發生衝突，使用線性探測往後尋找合適的位置				while (newTab[h] != null) {					h = nextIndex(h, newLen);				}				newTab[h] = e;				count++;			}		}	}	// 設置新的擴容閾值，為數組長度的三分之二	setThreshold(newLen);	size = count;	table = newTab;}</code></pre><p>resize 方法主要是進行擴容，同時會將垃圾值標記方便 GC 回收，擴容後數組大小是原來數組的兩倍。</p><h2 class=pgc-h-arrow-right>ThreadLocal 應用場景</h2><p>ThreadLocal 的特性也導致了應用場景比較廣泛，主要的應用場景如下：</p><ul><li>線程間數據隔離，各線程的 ThreadLocal 互不影響</li><li>方便同一個線程使用某一對象，避免不必要的參數傳遞</li><li>全鏈路追蹤中的 traceId 或者流程引擎中上下文的傳遞一般採用 ThreadLocal</li><li>Spring 事務管理器採用了 ThreadLocal</li><li>Spring MVC 的 RequestContextHolder 的實現使用了 ThreadLocal</li></ul><h1 class=pgc-h-arrow-right>總結</h1><p>本文主要從源碼的角度解析了 ThreadLocal，並分析了發生內存洩漏的原因，最後對它的應用場景進行了簡單介紹。</p><p>歡迎留言交流討論，原創不易，覺得文章不錯，請在看轉發支持一下。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>談談</a></li><li><a>ThreadLocal</a></li><li><a>原理</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/4adca96d.html alt=不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532917894689e20edadba9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4adca96d.html title=不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹>不鏽鋼旋轉樓梯—不鏽鋼旋轉樓梯的原理和尺寸介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/798c35eb.html alt=鼠標滾輪工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a32f01002df34196a3ca95824a0705c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/798c35eb.html title=鼠標滾輪工作原理>鼠標滾輪工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fe7a863.html alt=土壤採樣器的工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3591b04ce0ef4b24b7f04dcf6d4f0e5a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fe7a863.html title=土壤採樣器的工作原理>土壤採樣器的工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/382d9587.html alt=談談我的對彩票隨機事件小概率的看法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/64e0d9189e2a40128e7577bbadd25154 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/382d9587.html title=談談我的對彩票隨機事件小概率的看法>談談我的對彩票隨機事件小概率的看法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/64d13873.html alt=文科無用論：談談近代以來文科的衰落 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/f1b9f3e9-2ccf-4782-9011-bbcf07d0905b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/64d13873.html title=文科無用論：談談近代以來文科的衰落>文科無用論：談談近代以來文科的衰落</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html alt=多線程之ThreadLocal的那些事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html title=多線程之ThreadLocal的那些事>多線程之ThreadLocal的那些事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4bac2fc4.html alt=這4種ThreadLocal你都知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02621283c0574fd79fbb6ff5ea971384 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4bac2fc4.html title=這4種ThreadLocal你都知道嗎？>這4種ThreadLocal你都知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/203dfed4.html alt=和麵機的原理及運用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1bd01e6484624601ae66ef141b0cdbd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/203dfed4.html title=和麵機的原理及運用>和麵機的原理及運用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2537ec20.html alt=和麵機的工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/01f3205782f045a2a5aec20d70b9efc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2537ec20.html title=和麵機的工作原理>和麵機的工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ac331a0.html alt=功率因素表的工作原理及接線方式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/470a0003e8a9a1d2d829 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ac331a0.html title=功率因素表的工作原理及接線方式>功率因素表的工作原理及接線方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/504d903f.html alt=疊加原理及其應用（第1集） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/504d903f.html title=疊加原理及其應用（第1集）>疊加原理及其應用（第1集）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b9eda782.html alt=製冷原理和製冷循環原理，製冷劑在循環中什麼狀態？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/304eeaadf64047798a7c26b9d06a7987 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b9eda782.html title=製冷原理和製冷循環原理，製冷劑在循環中什麼狀態？>製冷原理和製冷循環原理，製冷劑在循環中什麼狀態？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/894f3dfe.html alt=談談液壓油缸防鏽和控制溫度、速度的重要性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c05777a41984cc29fcc7d8550c1c45e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/894f3dfe.html title=談談液壓油缸防鏽和控制溫度、速度的重要性>談談液壓油缸防鏽和控制溫度、速度的重要性</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>