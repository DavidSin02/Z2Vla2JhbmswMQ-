<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java多態的實現機制是什麼，看完你就知道（值得收藏） | 极客快訊</title><meta property="og:title" content="Java多態的實現機制是什麼，看完你就知道（值得收藏） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/ae124314-674a-47ca-b794-c5b32a309a66"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1d5ee81.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1d5ee81.html><meta property="article:published_time" content="2020-10-29T20:58:48+08:00"><meta property="article:modified_time" content="2020-10-29T20:58:48+08:00"><meta name=Keywords content><meta name=description content="Java多態的實現機制是什麼，看完你就知道（值得收藏）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1d5ee81.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java多態的實現機制是什麼，看完你就知道（值得收藏）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>Java多態的實現機制是父類或接口定義的引用變量可以指向子類或實現類的實例對象，而程序調用的方法在運行期才動態綁定，就是引用變量所指向的具體實現對象的方法，也就是內存里正在運行的那個對象的方法，而不是引用變量的類型中定義的方法。</p><div class=pgc-img><img alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/ae124314-674a-47ca-b794-c5b32a309a66><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>淺談多態機制的意義及實現</strong></p><p>在面向對象編程（Object-Oriented Programming, OOP）中，多態機制無疑是其最具特色的功能，甚至可以說，不運用多態的編程不能稱之為OOP。這也是為什麼有人說，使用面嚮對象語言的編程和麵向對象的編程是兩碼事。</p><p>多態並沒有一個嚴格的定義，維基百科上給它下的定義比較寬鬆：</p><p>Subtype polymorphism, almost universally called just polymorphism in the context of object-oriented programming, is the ability of one type, A, to appear as and be used like another type, B.</p><p class=ql-align-justify><br></p><p><strong>一、子類型和子類</strong></p><p>這裡我想先提一下子類型（Subtype）這個詞和子類（Subclass）的區別，簡單地說，只要是A類運用了extends關鍵字實現了對B類的繼承，那麼我們就可以說Class A是Class B的子類，子類是一個語法層面上的詞，只要滿足繼承的語法，就存在子類關係。</p><p>子類型比子類有更嚴格的要求，它不僅要求有繼承的語法，同時要求如果存在子類對父類方法的改寫（override），那麼改寫的內容必須符合父類原本的語義，其被調用後的作用應該和父類實現的效果方向一致。</p><p class=ql-align-justify>對二者的對比是想強調一點：只有保證子類都是子類型，多態才有意義。Java父類強制轉換子類原則。</p><p><strong>二、多態的機制</strong></p><p>本質上多態分兩種：</p><ol><li class=ql-align-justify>編譯時多態（又稱靜態多態）</li><li class=ql-align-justify>運行時多態（又稱動態多態）</li></ol><p class=ql-align-justify><br></p><p>重載（overload）就是編譯時多態的一個例子，編譯時多態在編譯時就已經確定，運行時運行的時候調用的是確定的方法。</p><p>我們通常所說的多態指的都是運行時多態，也就是編譯時不確定究竟調用哪個具體方法，一直延遲到運行時才能確定。這也是為什麼有時候多態方法又被稱為延遲方法的原因。</p><p>在維基百科中多態的行為被描述為：</p><p>The primary usage of polymorphism in industry (object-oriented programming theory) is the ability of objects belonging to different types to respond to method, field, or property calls of the same name, each one according to an appropriate type-specific behavior.</p><p>下面簡要介紹一下運行時多態（以下簡稱多態）的機制。</p><p><strong>多態通常有兩種實現方法：</strong></p><ol><li class=ql-align-justify>子類繼承父類（extends）</li><li class=ql-align-justify>類實現接口（implements）</li></ol><p>無論是哪種方法，其核心之處就在於對父類方法的改寫或對接口方法的實現，以取得在運行時不同的執行效果。</p><p>要使用多態，在聲明對象時就應該遵循一條法則：聲明的總是父類類型或接口類型，創建的是實際類型。舉例來說，假設我們要創建一個ArrayList對象，聲明就應該採用這樣的語句：</p><pre class=ql-align-justify>List list =　newArrayList();</pre><p>而不是</p><pre class=ql-align-justify>ArrayList list =　newArrayList();</pre><p>在定義方法參數時也通常總是應該優先使用父類類型或接口類型，例如某方法應該寫成：</p><pre class=ql-align-justify>public　void doSomething(List list);</pre><p>而不是</p><pre class=ql-align-justify>public　void doSomething(ArrayList list);</pre><p>這樣聲明最大的好處在於結構的靈活性：假如某一天我認為ArrayList的特性無法滿足我的要求，我希望能夠用LinkedList來代替它，那麼只需要在對象創建的地方把new ArrayList()改為new LinkedList即可，其它代碼一概不用改動。</p><p>The programmer (and the program) does not have to know the exact type of the object in advance, and so the exact behavior is determined at run-time (this is called late binding or dynamic binding).</p><p>虛擬機會在執行程序時動態調用實際類的方法，它會通過一種名為動態綁定（又稱延遲綁定）的機制自動實現，這個過程對程序員來說是透明的。</p><div class=pgc-img><img alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/2e081c61-4b0b-4b0b-950d-1cb01aab2c25><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p><strong>三、多態的用途</strong></p><p>多態最大的用途我認為在於對設計和架構的複用，更進一步來說，《設計模式》中提倡的針對接口編程而不是針對實現編程就是充分利用多態的典型例子。</p><p>定義功能和組件時定義接口，實現可以留到之後的流程中。同時一個接口可以有多個實現，甚至於完全可以在一個設計中同時使用一個接口的多種實現（例如針對ArrayList和LinkedList不同的特性決定究竟採用哪種實現）。</p><p><strong>四、多態的實現</strong></p><p>下面從虛擬機運行時的角度來簡要介紹多態的實現原理，這裡以Java虛擬機（Java Virtual Machine, JVM）規範的實現為例。JVM 與 Linux 的內存關係詳解。</p><p>在JVM執行Java字節碼時，類型信息被存放在方法區中，通常為了優化對象調用方法的速度，方法區的類型信息中增加一個指針，該指針指向一張記錄該類方法入口的表（稱為方法表），表中的每一項都是指向相應方法的指針。</p><p><strong>方法表的構造如下：</strong></p><p>由於Java的單繼承機制，一個類只能繼承一個父類，而所有的類又都繼承自Object類。方法表中最先存放的是Object類的方法，接下來是該類的父類的方法，最後是該類本身的方法。這裡關鍵的地方在於，如果子類改寫了父類的方法，那麼子類和父類的那些同名方法共享一個方法表項，都被認作是父類的方法。</p><div class=pgc-img><img alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/7ec838bc-5987-4d15-9a1f-c9f217ad32db><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>注意這裡只有非私有的實例方法才會出現，並且靜態方法也不會出現在這裡，原因很容易理解：靜態方法跟對象無關，可以將方法地址直接引用，而不像實例方法需要間接引用。</p><p>更深入地講，靜態方法是由虛擬機指令invokestatic調用的，私有方法和構造函數則是由invokespecial指令調用，只有被invokevirtual和invokeinterface指令調用的方法才會在方法表中出現。</p><p>由於以上方法的排列特性（Object——父類——子類），使得方法表的偏移量總是固定的。例如，對於任何類來說，其方法表中equals方法的偏移量總是一個定值，所有繼承某父類的子類的方法表中，其父類所定義的方法的偏移量也總是一個定值。</p><p>前面說過，方法表中的表項都是指向該類對應方法的指針，這裡就開始了多態的實現：</p><p>假設Class A是Class B的子類，並且A改寫了B的方法method()，那麼在B的方法表中，method方法的指針指向的就是B的method方法入口。</p><p>而對於A來說，它的方法表中的method方法則會指向其自身的method方法而非其父類的（這在類加載器載入該類時已經保證，同時JVM會保證總是能從對象引用指向正確的類型信息）。</p><p>結合方法指針偏移量是固定的以及指針總是指向實際類的方法域，我們不難發現多態的機制就在這裡：</p><p>在調用方法時，實際上必須首先完成實例方法的符號引用解析，結果是該符號引用被解析為方法表的偏移量。</p><p>虛擬機通過對象引用得到方法區中類型信息的入口，查詢類的方法表，當將子類對象聲明為父類類型時，形式上調用的是父類方法，此時虛擬機會從實際類的方法表（雖然聲明的是父類，但是實際上這裡的類型信息中存放的是子類的信息）中查找該方法名對應的指針（這裡用“查找”實際上是不合適的，前面提到過，方法的偏移量是固定的，所以只需根據偏移量就能獲得指針），進而就能指向實際類的方法了。</p><p class=ql-align-justify><br></p><p>我們的故事還沒有結束，事實上上面的過程僅僅是利用繼承實現多態的內部機制，多態的另外一種實現方式：實現接口相比而言就更加複雜，原因在於，Java的單繼承保證了類的線性關係，而接口可以同時實現多個，這樣光憑偏移量就很難準確獲得方法的指針。所以在JVM中，多態的實例方法調用實際上有兩種指令：</p><ul><li class=ql-align-justify>invokevirtual指令用於調用聲明為類的方法；</li><li class=ql-align-justify>invokeinterface指令用於調用聲明為接口的方法。</li></ul><p class=ql-align-justify><br></p><p>當使用invokeinterface指令調用方法時，就不能採用固定偏移量的辦法，只能老老實實挨個找了（當然實際實現並不一定如此，JVM規範並沒有規定究竟如何實現這種查找，不同的JVM實現可以有不同的優化算法來提高搜索效率）。</p><p>我們不難看出，在性能上，調用接口引用的方法通常總是比調用類的引用的方法要慢。這也告訴我們，在類和接口之間優先選擇接口作為設計並不總是正確的，當然設計問題不在本文探討的範圍之內，但顯然具體問題具體分析仍然不失為更好的選擇。</p><div class=pgc-img><img alt=Java多態的實現機制是什麼，看完你就知道（值得收藏） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/dfic-imagehandler/02777f8a-d0a7-4a88-9194-3c4f26e5eb15><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p>個人見解：多態機制包括靜態多態（編譯時多態）和動態多態（運行時多態），靜態多態比如說重載，動態多態是在編譯時不能確定調用哪個方法，得在運行時確定。動態多態的實現方法包括子類繼承父類和類實現接口。當多個子類上轉型（不知道這麼說對不）時，對象掉用的是相應子類的方法，這種實現是與JVM有關的。</p><p><strong>end：如果你覺得本文對你有幫助的話，記得點贊轉發，你的支持就是我更新動力。</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>多態</a></li><li><a>實現</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/44cdc077.html alt=Java如何實現自動關閉資源？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9f24b68095db4b80b744910d2b5cced6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/44cdc077.html title=Java如何實現自動關閉資源？>Java如何實現自動關閉資源？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d792b58.html alt=Java實現遠程服務生產與消費(RPC)的4種方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/856837d3a1b446dbbeb16994e9ed19da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d792b58.html title=Java實現遠程服務生產與消費(RPC)的4種方法>Java實現遠程服務生產與消費(RPC)的4種方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a836fe1.html alt=Java編程技巧：如何實現參數的輸入輸出？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b36247aabf154a46aca31b642fc3cd0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a836fe1.html title=Java編程技巧：如何實現參數的輸入輸出？>Java編程技巧：如何實現參數的輸入輸出？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/891a2ed3.html alt=技術點滴：實現Java父類強制轉換子類的原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1539014984935468692050e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/891a2ed3.html title=技術點滴：實現Java父類強制轉換子類的原則>技術點滴：實現Java父類強制轉換子類的原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7771d40.html alt="5分鐘！用Java實現目標檢測 | PyTorch" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bcf4256f45fe4ac29cbc234e7f84961c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7771d40.html title="5分鐘！用Java實現目標檢測 | PyTorch">5分鐘！用Java實現目標檢測 | PyTorch</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea69ab1.html alt=Java可重入讀寫鎖實現：ReentrantReadWriteLock class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/87955ae16a9a4013b7b4ec6a387656f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea69ab1.html title=Java可重入讀寫鎖實現：ReentrantReadWriteLock>Java可重入讀寫鎖實現：ReentrantReadWriteLock</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/325007f.html alt="教你如何用 Java 實現異步調用" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/325007f.html title="教你如何用 Java 實現異步調用">教你如何用 Java 實現異步調用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9e89bbd.html alt=22、Java實現多態的機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6b65bd7dfb1c428c87904b93b9587c07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9e89bbd.html title=22、Java實現多態的機制>22、Java實現多態的機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af4bb85.html alt=Java基礎系列：理解Java多態的實現機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cd7b252f82e04b6da1d594eab4d030b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af4bb85.html title=Java基礎系列：理解Java多態的實現機制>Java基礎系列：理解Java多態的實現機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html alt=Java基礎（多態的理解與應用) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/892ce3a.html title=Java基礎（多態的理解與應用)>Java基礎（多態的理解與應用)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html alt=Java筆記之——多態詳解（重要） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/002a620d6944415d8d650a5636c4ff41 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/880ab84.html title=Java筆記之——多態詳解（重要）>Java筆記之——多態詳解（重要）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4fe5ba4.html alt=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ac43ddbdfc44399b9cef800d4dbdd08 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4fe5ba4.html title=你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？>你真的熟悉Java中的繼承與多態？給你幾分鐘能回答上來？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>