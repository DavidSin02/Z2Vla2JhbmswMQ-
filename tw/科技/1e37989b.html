<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構｜圖的鄰接表與深度、廣度優先搜索 | 极客快訊</title><meta property="og:title" content="數據結構｜圖的鄰接表與深度、廣度優先搜索 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/e93433412f4f4d1baa9d2a433397a8c7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e37989b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e37989b.html><meta property="article:published_time" content="2020-11-14T20:59:14+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:14+08:00"><meta name=Keywords content><meta name=description content="數據結構｜圖的鄰接表與深度、廣度優先搜索"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1e37989b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構｜圖的鄰接表與深度、廣度優先搜索</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>線性存儲元素時，元素的關係也同時確定了。而非線性數據結構就不同了，需要同時考慮存儲數據元素和數據元素的關係。</p><blockquote class=pgc-blockquote-abstract><p>由於圖的結構比較複雜，任意兩個頂點之間都可能存在聯繫，因此無法以數據元素在存儲區中的物理位置來表示元素之間的關係，即圖沒有順序存儲結構，但可以藉助二維表來表示元素之間的關係，一般稱為鄰接矩陣。另一方面，由於圖的任意兩個頂點間都可能存在關係，因此，用鏈式存儲表示圖是很自然的事，其中有代表性的鏈式存儲結構稱為鄰接表（Adjacency List）。</p></blockquote><p>在鄰接表中，對圖中每個頂點vi建立一個單鏈表，把與vi相鄰接的頂點放在這個鏈表中。鄰接表中每個單鏈表的第一個結點存放有關頂點的信息， 把這一結點看成鏈表的表頭，其餘結點存放有關邊的信息。這樣鄰接表便由兩部分組成：表頭結點表和邊表。</p><div class=pgc-img><img alt=數據結構｜圖的鄰接表與深度、廣度優先搜索 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e93433412f4f4d1baa9d2a433397a8c7><p class=pgc-img-caption></p></div><p>如上圖的鄰接表和逆鄰接表：</p><div class=pgc-img><img alt=數據結構｜圖的鄰接表與深度、廣度優先搜索 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f15b8706df644efb92909b64c346f993><p class=pgc-img-caption></p></div><p>需要注意的是，圖的鄰接表表示並不唯一，這是因為在每個頂點對應的單鏈表中，各邊結點的鏈接次序可以是任意的，取決於鄰接表的算法以及邊的輸入次序。</p><p>用鄰接表表示圖一般可以描述為：</p><pre><code>typedef struct ArcNode{			// 單鏈表中的結點的類型	int  adjvex;				// 該邊指向的頂點在順序表中的位置	struct ArcNode  *next;		// 下一條邊  //OtherInfo info;  // 和邊相關的信息，如權值}ArcNode;typedef struct VNode{			// 頂點類型	int  data;					// 頂點中的數據信息	ArcNode  *firstarc;			// 指向單鏈表，即指向第一條邊}VNode;</code></pre><blockquote class=pgc-blockquote-abstract><p>圖的鄰接存儲：頂點表+n個鏈表（頂點元素及鏈接到相鄰頂點的指針、下一個相鄰點及指針……）；</p><p>有向圖存儲全部信息同時還需要一個逆鄰接表；</p><p>帶權圖的鄰接表則需要結點元素多一個權值域；</p></blockquote><p>圖遍歷背後的關鍵思想是在我們第一次訪問每個頂點時對其進行標記（一般使用一個布爾數組），並跟蹤我們尚未完全探索的內容（一般使用一個棧或隊列結構）。儘管麵包屑或解開的線被用來標記童話迷宮中參觀過的地方，但我們將依賴布爾標誌或枚舉類型來進行。</p><p>每個頂點將以三種狀態之一存在：</p><blockquote class=pgc-blockquote-abstract><p>未發現-頂點處於原始狀態。</p><p>已發現-頂點已找到，但尚未檢查其所有入射邊。</p><p>已處理–訪問所有關聯邊後的頂點。</p></blockquote><p>顯然，一個頂點只有在我們發現它之後才能被處理，所以每個頂點的狀態在遍歷過程中從未發現到發現再到處理。</p><p>我們還必須維護一個包含我們已經發現但尚未完全處理的頂點的結構。最初，只有一個起始頂點被認為是被發現的。為了完全探索一個頂點v，我們必須計算每一條離開v的邊。如果一條邊轉到一個未發現的頂點x，我們標記x 為“已發現”並將其添加到要做的工作列表中。我們要忽略處理過的頂點的邊，因為進一步的探索不會告訴我們關於圖的任何新的東西。我們還可以忽略到已發現但未處理的頂點的任何邊，因為目標已位於要處理的頂點列表中。</p><p>BFS(Depth First Search--DFS)和DFS(Breadth First Search--BFS)結果的區別在於它們探索頂點的順序。此順序完全取決於用於存儲已發現但未處理的頂點的容器數據結構。</p><p>Stack–通過將頂點存儲在後進先出（last-in，first-out，LIFO）堆棧中，我們通過沿著路徑一直前行、訪問新鄰居（如果有的話）和僅當我們被以前發現的頂點包圍時才回退來探索新的頂點。因此，我們的探索很快偏離了起點，定義了深度優先搜索。</p><p>一旦發現一個頂點，它就被放置在棧（顯式或隱式棧）中。由於我們按後入先出的順序處理這些頂點，所以最新的頂點將首先展開，這些頂點正是最遠離根的頂點。</p><p>隊列-通過將頂點存儲在先進先出（FIFO）隊列中，我們首先探索最古老的未探索頂點。因此，我們的探索從起始頂點緩慢地向外輻射，定義了廣度優先搜索。</p><p>一旦發現一個頂點，它就被放置在隊列中。由於我們按先入先出的順序處理這些頂點，所以最舊的頂點將首先展開，這些頂點正是最接近根的頂點。</p><p>深度優先搜索有一個簡潔的遞歸實現，它消除了顯式使用堆棧的需要。</p><p>我們需要能夠對每個入口和出口分別採取行動。</p><p>深度優先搜索的另一個重要特性是它將無向圖的邊劃分為兩類：tree edges和back edges。tree edges發現新的頂點，並且是在parent關係中編碼的頂點。back edges是那些其另一個端點是被展開頂點的ancestor的邊，因此它們指向樹中。</p><div class=pgc-img><img alt=數據結構｜圖的鄰接表與深度、廣度優先搜索 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bf52177e066746ce90f4a8b8e531867e><p class=pgc-img-caption></p></div><p><strong>1 深度優先遍歷</strong></p><p>優先向深度探索，一直走到頭才回頭到路徑的上一個相鄰頂點，直到回溯到最開始頂點。</p><p>對於鄰接點，先孩子…後上一輩的兄弟，後進先出（棧隱式或顯式輔助）。</p><div class=pgc-img><img alt=數據結構｜圖的鄰接表與深度、廣度優先搜索 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/536375e243aa402186bbd669033e8981><p class=pgc-img-caption></p></div><p>如上圖的深度優先遍歷的順序：0 1 2 3 4 5 6 8 9 7。</p><p>如果使用遞歸，則相當於使用了一個隱式的棧數據結構（編譯器對函數遞歸調用的壓棧和迴歸的出棧操作）。</p><p>如果使用迭代法，則需要顯式使用一個棧數據結構。</p><p><strong>2 廣度優先遍歷</strong></p><p>廣度優先遍歷，也就是從某一個頂點開始，優先訪問全部的相鄰頂點，按層次輻射，直到全部頂點訪問完。</p><p>對於鄰接點，先兄弟後孩子，先進先出（隊列輔助）。</p><p>如上圖使用廣度優先遍歷的順序：0 1 3 2 4 5 6 7 8 9。</p><p>廣度優先遍歷需顯式使用一個隊列的數據結構。廣度優先搜索是一種分層的搜索過程，不像深度優先遍歷那樣有往回退的情況。因此，廣度優先遍歷不能遞歸實現，可以使用先進先出的隊列來實現。</p><blockquote class=pgc-blockquote-abstract><p>深度搜索與廣度搜索的控制結構和產生系統很相似，唯一的區別在於對擴展節點選取上。由於其保留了所有的前繼節點，所以在產生後繼節點時可以去掉一部分重複的節點，從而提高了搜索效率。這兩種算法每次都擴展一個節點的所有子節點，而不同的是，深度搜索下一次擴展的是本次擴展出來的子節點中的一個，而廣度搜索擴展的則是本次擴展的節點的兄弟節點。也就是說，廣度優先搜索會優先考慮最早被發現的頂點，也就是說離起點越近的頂點優先級越高。深度優先搜索會優先考慮最後被發現的頂點。</p><p>在20世紀50年代，廣度優先搜索最早由Edward F. Moor在研究迷宮路徑問題時發現，深度優先搜索在人工智能方面獲得了廣泛應用。</p><p>需要注意的是，廣度優先搜索是以起始點為中心，一層一層向外層擴展遍歷圖的頂點，因此無法考慮到邊的權值，只適合求邊權值相等的圖的單源最短路徑。</p></blockquote><pre><code>// 圖的鄰接表存儲，以及圖的深度優先遍歷(DST)和廣度優先遍歷（BST）#include "stdio.h"#include "malloc.h"#define MAX_VERTEX_NUM 10     // 表示創建和遍歷的圖的頂點數typedef struct ArcNode{       // 單鏈表中的結點的類型    int  adjvex;              // 該邊指向的頂點在順序表中的位置（下標）    struct ArcNode  *next;    // 下一條邊    //OtherInfo info;         // 和邊相關的信息，如權值}ArcNode;typedef struct VNode{         // 頂點類型    int  data;                // 頂點中的數據信息    ArcNode  *firstarc;       // 指向單鏈表，即指向第一條邊}VNode;typedef struct QNode{    int data;                 // 鏈隊列結點中的數據域    struct QNode *next;       // 鏈隊列結點中的指針域}QNode , *QueuePtr;typedef struct{    QueuePtr front;           // 隊頭指針    QueuePtr rear;            // 隊尾指針}LinkQueue;int visited[MAX_VERTEX_NUM]={0};/* 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   */void CreatGraph(int n, VNode G[]);int  FirstAdj(VNode G[],int v) ;        // 返回下標為v的頂點的第一鄰接點在數組中的下標int  NextAdj(VNode G[],int v, int w);   // 返回下標為v的頂點的鄰接點中下標為w的鄰接點的下標void DFS(VNode G[],int v)    // 從下標為v的頂點開始DFS{    printf("%d ",G[v]);      // 訪問當前頂點,打印出該頂點中的數據信息    visited[v] = 1;          // 將頂點v對應的訪問標記置1    int w = FirstAdj(G,v);   // 找到頂點v的第一個鄰接點，如果無鄰接點，返回-1    while(w != -1){        if(visited[w] == 0)  // 該頂點未被訪問            DFS(G,w);        // 遞歸地進行深度優先搜索        w = NextAdj(G,v,w);  // 找到頂點v的鄰接點為w的下一個鄰接點，如果無鄰接點，返回-1    }}void Travel_DFS(VNode G[], int n)        // 非連能圖各子圖的DFS{    for(int i=0;i&lt;n;i++)        visited[i] = 0;      // 將標記數組初始化為0    for(i=0;i&lt;n;i++)        if(visited[i] == 0)  // 若有頂點未被訪問，從該頂點開始繼續深度優先搜索            DFS(G,i);}void initQueue(LinkQueue *q);void EnQueue(LinkQueue *q, int e);void DeQueue(LinkQueue *q, int *e);int emptyQ(LinkQueue q) ;void BFS(VNode G[],int v){    LinkQueue q;    initQueue(&amp;q);        printf("%d ",G[v]);         // 訪問頂點v    visited[v] = 1;             // 將頂點v對應的訪問標記置1    EnQueue(&amp;q,v);              // 頂點v入隊列    while(!emptyQ(q))    {        DeQueue(&amp;q, &amp;v);        // 出隊列，元素由v返回        int w = FirstAdj(G, v); // 找到頂點v的第一個鄰接點，如果無鄰接點，返回-1        while(w != -1)		    {            if(visited[w] == 0)             {                printf("%d ",G[w]);                EnQueue(&amp;q,w);   // 頂點w入隊列                visited[w] = 1;            }            w = NextAdj(G, v, w);// 找到頂點v的下一個鄰接點，如果無鄰接點，返回-1        }    }}void Travel_BFS(VNode G[], int n){    int i;    for(i=0;i&lt;n;i++)        visited[i] = 0;          // 將標記數組初始化為0    for(i=0;i&lt;n;i++)          // 非連能圖各子圖的BFS        if(visited[i] == 0)      // 若有頂點未被訪問，從該頂點開始繼續廣度優先搜索            BFS(G,i);}void resetVisitedTrace() {    int i;    for (i=0; i&lt;MAX_VERTEX_NUM; i++)     {        visited[i] = 0;    }}int main(){    VNode G[MAX_VERTEX_NUM];    CreatGraph(MAX_VERTEX_NUM,G);    printf("DFS trace is\n");    Travel_DFS(G,MAX_VERTEX_NUM);    resetVisitedTrace();    printf("\nBFS trace is\n");    Travel_BFS(G,MAX_VERTEX_NUM);    getchar();getchar();    return 0;}/* 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   DFS trace is0 1 2 3 4 5 6 8 9 7BFS trace is0 1 3 2 4 5 6 7 8 9data：0 1 2 3 4 5 6 7 8 91 3 -10 2 4 -11 3 4 -10 2 -11 2 -16 7 8 -15 8 9 -15 -15 6 -16 -1*/void CreatGraph(int n, VNode G[]){    int i,e;    ArcNode *p , *q;    printf("Input the information of the vertexes(%d) and edges\n",MAX_VERTEX_NUM);    printf("you can copy below data, then return:\n");    printf("0 1 2 3 4 5 6 7 8 9\n");    printf("1 3 -1 \n");    printf("0 2 4 -1 \n");    printf("1 3 4 -1 \n");    printf("0 2 -1 \n");    printf("1 2 -1 \n");    printf("6 7 8 -1 \n");    printf("5 8 9 -1 \n");    printf("5 -1 \n");    printf("5 6 -1 \n");    printf("6 -1 \n");    for(i=0;i&lt;n;i++)    {        scanf("%d",&amp;G[i]);        G[i].firstarc = NULL;                        // 初始化第一條邊為空    }    printf("創建每個頂點的鄰邊：輸入的值是鄰邊另一個頂點在數組中的下標，\n");    printf("當輸入-1，表示該頂點依附的鄰邊創建完畢！\n");    for(i=0;i&lt;n;i++)    {        printf("Create the edges for the %dth vertex\n",i) ;        scanf("%d",&amp;e);        while(e!=-1){            p = (ArcNode *)malloc(sizeof(ArcNode)); // 創建一條邊            p-&gt;next = NULL;            p-&gt;adjvex = e;            if(G[i].firstarc == NULL)                G[i].firstarc = p;                  // i結點的第一條邊            else                q-&gt;next = p;                        // 下一條邊            q = p;            scanf("%d",&amp;e);        }    }}int  FirstAdj(VNode G[],int v)         // 返回下標為v的頂點的第一鄰接點在數組中的下標{    if(G[v].firstarc != NULL) {        return (G[v].firstarc)-&gt;adjvex;    }    return -1;}int  NextAdj(VNode G[],int v, int w){   // 返回下標為v的頂點的鄰接中下標為w                                        // 的下一個鄰接點在數組中的下標    ArcNode *p = G[v].firstarc;    while( p!= NULL){        if(p-&gt;adjvex == w &amp;&amp; p-&gt;next != NULL) {            return p-&gt;next-&gt;adjvex;        }         p = p-&gt;next;      }    return -1;}void initQueue(LinkQueue *q) // 初始化一個空隊列{    q-&gt;front = q-&gt;rear = (QueuePtr)malloc(sizeof(QNode));                             // 創建一個頭結點，隊頭隊尾指針指向該結點    if(!q-&gt;front) return;    // 創建頭結點失敗    q-&gt;front-&gt;next = NULL;   // 頭結點指針域置NULL}void EnQueue(LinkQueue *q, int e){    QueuePtr p;    p = (QueuePtr)malloc(sizeof(QNode)); // 創建一個隊列元素結點    if(p==NULL)return;                   // 創建元素結點失敗    p-&gt;data = e;             // 將數據e存放到隊列結點的data域中    p-&gt;next = NULL;          // 指針域置NULL    q-&gt;rear -&gt;next = p;      // 從隊尾插入結點    q-&gt;rear = p;             // 修改隊尾指針}void DeQueue(LinkQueue *q, int *e){                            // 如果隊列q不為空，刪除q的隊頭元素，用e返回其值    QueuePtr p;    if(q-&gt;front == q-&gt;rear) return;      // 隊列為空，返回    p = q-&gt;front-&gt;next;                  // p指向隊列的第一個元素    *e = p-&gt;data;                        // 將隊首元素的數據賦值給e返回    q-&gt;front-&gt;next = p-&gt;next;            // 刪除頭結點    if(q-&gt;rear == p) q-&gt;rear = q-&gt;front; // 如果此時隊列為空，則修改隊尾指針    free(p);}int emptyQ(LinkQueue q) {    if (q.rear == q.front) {        return 1;    }    return 0;}</code></pre><p>無論那種搜索，都是通過對一個線性表進行處理，只不過是先處理頭部還是尾部的問題罷了。處理頭部優先的時候，也就是先加入的先探索，就是廣度優先了，因為，頭部的都是兄弟節點；而尾部的則是深度優先，因為放入尾部的都是剛剛生產出來的節點，後加入的先探索——也就是所謂一條路走到死。 同理可以聯想到啟發式搜索。啟發式搜索就是先以你自定義的優先級處理，然後再以廣度為優先級處理。 所以，歸根結底，所謂的搜索，就是一種定義了優先級的枚舉。</p><p>回溯算法一般使用深度優先搜索策略，在包含問題的所有解的解空間樹中，按照深度優先搜索的策略，從根結點出發深度探索解空間樹。當探索到某一結點時，要先判斷該結點是否包含問題的解，如果包含，就從該結點出發繼續探索下去，如果該結點不包含問題的解，則逐層向其祖先結點回溯。</p><p>回溯法以深度優先的方式搜索解空間樹T，而分支限界法則以廣度優先或以最小耗費優先的方式搜索解空間樹T。分支限界法因為不回溯，所以只是找出滿足約束條件的一個解，從當前活結點表中選擇一個最有利的結點作為擴展結點，使搜索朝著解空間樹上有最優解的分支推進。</p><p>附：鄰接表與鄰接矩陣的DFS、BFS比較</p><div class=pgc-img><img alt=數據結構｜圖的鄰接表與深度、廣度優先搜索 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b49cda1eddf64b7db87de5e2c8b1f54f><p class=pgc-img-caption></p></div><p>附DFS、BFS（鄰接矩陣）代碼：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int VertexType;       // 頂點類型應由用戶定義typedef int EdgeType;         // 邊上的權值類型應由用戶定義#define MAXSIZE  15           // 存儲空間初始分配量#define MAXEDGE  15#define MAXVEX   10#define INFINITY 65535/* 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   */int arc[MAXVEX][MAXVEX]={	{0,1,0,1,0,0,0,0,0,0},{1,0,1,0,1,0,0,0,0,0},	{0,1,0,1,1,0,0,0,0,0},{1,0,1,0,0,0,0,0,0,0},	{0,1,1,0,0,0,0,0,0,0},{0,0,0,0,0,0,1,1,1,0},	{0,0,0,0,0,1,0,0,1,1},{0,0,0,0,1,0,0,0,0,0},	{0,0,0,0,0,1,1,0,0,0},{0,0,0,0,0,0,1,0,0,0}};typedef struct{    VertexType vexs[MAXVEX];         // 頂點表    EdgeType arc[MAXVEX][MAXVEX];    // 鄰接矩陣，可看作邊表    int numVertexes, numEdges;       // 圖中當前的頂點數和邊數 }MGraph;typedef struct             // 循環隊列順序存儲結構{    int data[MAXSIZE];    int front;             // 頭指針    int rear;              // 尾指針，若隊列不空，指向隊列尾元素的下一個位置}Queue;void CreateMGraph(MGraph *G){    int i,j;    G-&gt;numEdges=15;    G-&gt;numVertexes=10;	for(i=0; i&lt;G-&gt;numVertexes; i++)        // 建立頂點表		G-&gt;vexs[i] = i;    for (i = 0; i &lt; G-&gt;numVertexes; i++)   // 初始化圖    {        for (int j = 0; j &lt; G-&gt;numVertexes; j++)        {            G-&gt;arc[i][j]=arc[i][j];        }    }} bool visited[MAXVEX];         // 訪問標誌的數組void DFS(MGraph G, int i)     // 鄰接矩陣的深度優先遞歸算法{    visited[i] = true;    printf("%d ", G.vexs[i]); // 打印頂點，也可以其它操作    for(int j=0; j&lt;G.numVertexes; j++)        if(G.arc[i][j] == 1 &amp;&amp; !visited[j])             DFS(G, j);       // i = j不斷壓棧}void DFSTraverse(MGraph G)       // 鄰接矩陣的深度遍歷操作{    for(int i=0; i&lt;G.numVertexes; i++)        visited[i] = false;       // 初始所有頂點狀態都是未訪問過狀態    for(i=0; i&lt;G.numVertexes;i++)         if(!visited[i])          // 對未訪問過的頂點調用DFS，若是連通圖，只會執行一次             DFS(G, i);}bool InitQueue(Queue *Q);         // 初始化一個空隊列Qbool QueueEmpty(Queue Q);         // 入隊bool EnQueue(Queue *Q,int e);     // 出隊bool DeQueue(Queue *Q,int *e);    // 刪除Q中隊頭元素，用e返回其值void BFS(MGraph G,int i) {    Queue Q;    InitQueue(&amp;Q);                      printf("%d ", G.vexs[i]);    visited[i]=true;            EnQueue(&amp;Q,i);             while(!QueueEmpty(Q))        {       DeQueue(&amp;Q,&amp;i);           for(int j=0;j&lt;G.numVertexes;j++)        {           if(G.arc[i][j] == 1                  &amp;&amp; !visited[j])           {              visited[j]=true;                     printf("%d ", G.vexs[j]);              EnQueue(&amp;Q,j);                     }        }    }}void BFSTraverse(MGraph G)        // 鄰接矩陣的廣度遍歷算法{    for(int i=0; i&lt;G.numVertexes; i++)        visited[i] = false;    for(i=0; i&lt;G.numVertexes; i++)      // 對每一個頂點做循環    {        if (!visited[i])                // 若是未訪問過就處理        {           BFS(G,i);        }    }}int main(void){        MGraph G;    CreateMGraph(&amp;G);        printf("\n1.深度優先遍歷：");    DFSTraverse(G);        printf("\n2.廣度優先遍歷：");    BFSTraverse(G);    getchar();getchar();    return 0;}/*1.深度優先遍歷：0 1 2 3 4 5 6 8 9 72.廣度優先遍歷：0 1 3 2 4 5 6 7 8 9 0-----1  |    /|  |   2 | |  / \| | /   4    5---8 |/        / \ /  3        7   6--9   */bool InitQueue(Queue *Q)  // 初始化一個空隊列Q{    Q-&gt;front=0;    Q-&gt;rear=0;    return  true;}bool QueueEmpty(Queue Q){     if(Q.front==Q.rear)    // 隊列空的標誌        return true;    else        return false;}bool EnQueue(Queue *Q,int e){    if ((Q-&gt;rear+1)%MAXSIZE == Q-&gt;front)   // 隊列滿的判斷        return false;    Q-&gt;data[Q-&gt;rear]=e;                    // 將元素e賦值給隊尾    Q-&gt;rear=(Q-&gt;rear+1)%MAXSIZE;           // rear指針向後移一位置，                                           // 若到最後則轉到數組頭部    return  true;}bool DeQueue(Queue *Q,int *e)           // 刪除Q中隊頭元素，用e返回其值{    if (Q-&gt;front == Q-&gt;rear)            // 隊列空的判斷        return false;    *e=Q-&gt;data[Q-&gt;front];               // 將隊頭元素賦值給e    Q-&gt;front=(Q-&gt;front+1)%MAXSIZE;      // front指針向後移一位置，                                        // 若到最後則轉到數組頭部    return  true;}</code></pre><p>-End-</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>接表</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>