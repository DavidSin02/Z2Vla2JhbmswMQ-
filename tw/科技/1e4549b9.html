<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java集合框架綜述 | 极客快訊</title><meta property="og:title" content="Java集合框架綜述 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/fca2a03e52a1473db53da27e12467181"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1e4549b9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1e4549b9.html><meta property="article:published_time" content="2020-11-14T21:05:53+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:53+08:00"><meta name=Keywords content><meta name=description content="Java集合框架綜述"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1e4549b9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java集合框架綜述</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>一、集合框架圖</p><div class=pgc-img><img alt=Java集合框架綜述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fca2a03e52a1473db53da27e12467181></div><p>簡化圖：</p><div class=pgc-img><img alt=Java集合框架綜述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6ae0b40dcd9f46e3ae00ce5091677fc4></div><p><strong>說明：對於以上的框架圖有如下幾點說明</strong></p><ol><li>所有集合類都位於java.util包下。Java的集合類主要由兩個接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，這兩個接口又包含了一些子接口或實現類。</li><li>集合接口：6個接口（短虛線表示），表示不同集合類型，是集合框架的基礎。</li><li>抽象類：5個抽象類（長虛線表示），對集合接口的部分實現。可擴展為自定義集合類。</li><li>實現類：8個實現類（實線表示），對接口的具體實現。</li><li>Collection 接口是一組允許重複的對象。</li><li>Set 接口繼承 Collection，集合元素不重複。</li><li>List 接口繼承 Collection，允許重複，維護元素插入順序。</li><li>Map接口是鍵－值對象，與Collection接口沒有什麼關係。</li><li>Set、List和Map可以看做集合的三大類：</li></ol><ul><li>List集合是有序集合，集合中的元素可以重複，訪問集合中的元素可以根據元素的索引來訪問。</li><li>Set集合是無序集合，集合中的元素不可以重複，訪問集合中的元素只能根據元素本身來訪問（也是集合裡元素不允許重複的原因）。</li><li>Map集合中保存Key-value對形式的元素，訪問時只能根據每項元素的key來訪問其value。</li></ul><hr><p>二、總體分析</p><div class=pgc-img><img alt=Java集合框架綜述 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2af23336bea24995a68db2accbd18e54></div><p><strong>大致說明</strong>：</p><p>看上面的框架圖，先抓住它的主幹，即Collection和Map。</p><ol><li>Collection是一個接口，是高度抽象出來的集合，它包含了集合的基本操作和屬性。Collection包含了List和Set兩大分支。</li></ol><ul><li>List是一個有序的隊列，每一個元素都有它的索引。第一個元素的索引值是0。List的實現類有LinkedList, ArrayList, Vector, Stack。</li><li>Set是一個不允許有重複元素的集合。Set的實現類有HastSet和TreeSet。HashSet依賴於HashMap，它實際上是通過HashMap實現的；TreeSet依賴於TreeMap，它實際上是通過TreeMap實現的。</li></ul><ol><li>Map是一個映射接口，即key-value鍵值對。Map中的每一個元素包含“一個key”和“key對應的value”。AbstractMap是個抽象類，它實現了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是繼承於AbstractMap。Hashtable雖然繼承於Dictionary，但它實現了Map接口。</li><li>接下來，再看Iterator。它是遍歷集合的工具，即我們通常通過Iterator迭代器來遍歷集合。我們說Collection依賴於Iterator，是因為Collection的實現類都要實現iterator()函數，返回一個Iterator對象。ListIterator是專門為遍歷List而存在的。</li><li>再看Enumeration，它是JDK 1.0引入的抽象類。作用和Iterator一樣，也是遍歷集合；但是Enumeration的功能要比Iterator少。在上面的框圖中，Enumeration只能在Hashtable, Vector, Stack中使用。</li><li>最後，看Arrays和Collections。它們是操作數組、集合的兩個工具類。</li></ol><blockquote>有了上面的整體框架之後，我們接下來對每個類分別進行分析。</blockquote><hr><p>三、Collection接口</p><p>Collection接口是處理對象集合的根接口，其中定義了很多對元素進行操作的方法。Collection接口有兩個主要的子接口List和Set，<strong>注意Map不是Collection的子接口，這個要牢記</strong>。</p><p>Collection接口中的方法如下:</p><div class=pgc-img><img alt=Java集合框架綜述 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a8a6261feb1c4752a252f97dfb58aee8></div><p>其中，有幾個比較常用的方法，比如方法add()添加一個元素到集合中，addAll()將指定集合中的所有元素添加到集合中，contains()方法檢測集合中是否包含指定的元素，toArray()方法返回一個表示集合的數組。</p><p>另外，Collection中有一個iterator()函數，它的作用是返回一個Iterator接口。通常，我們通過Iterator迭代器來遍歷集合。ListIterator是List接口所特有的，在List接口中，通過ListIterator()返回一個ListIterator對象。</p><p>Collection接口有兩個常用的子接口，下面詳細介紹。</p><p>1.List接口</p><p><strong>List集合代表一個有序集合，集合中每個元素都有其對應的順序索引。List集合允許使用重複元素，可以通過索引來訪問指定位置的集合元素</strong>。</p><p>List接口繼承於Collection接口，它可以定義一個允許重複的有序集合。因為List中的元素是有序的，所以我們可以通過使用索引（元素在List中的位置，類似於數組下標）來訪問List中的元素，這類似於Java的數組。</p><p>List接口為Collection直接接口。List所代表的是有序的Collection，即它用某種特定的插入順序來維護元素順序。用戶可以對列表中每個元素的插入位置進行精確地控制，同時可以根據元素的整數索引（在列表中的位置）訪問元素，並搜索列表中的元素。實現List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p>（1）ArrayList</p><p>ArrayList是一個動態數組，也是我們最常用的集合。它允許任何符合規則的元素插入甚至包括null。每一個ArrayList都有一個初始容量（10），該容量代表了數組的大小。隨著容器中的元素不斷增加，容器的大小也會隨著增加。在每次向容器中增加元素的同時都會進行容量檢查，當快溢出時，就會進行擴容操作。所以如果我們明確所插入元素的多少，最好指定一個初始容量值，避免過多的進行擴容操作而浪費時間、效率。</p><p>size、isEmpty、get、set、iterator和 listIterator操作都以固定時間運行。add 操作以分攤的固定時間運行，也就是說，添加 n 個元素需要 O(n) 時間（由於要考慮到擴容，所以這不只是添加元素會帶來分攤固定時間開銷那樣簡單）。</p><p>ArrayList擅長於隨機訪問。同時ArrayList是非同步的。</p><p>（2）LinkedList</p><p>同樣實現List接口的LinkedList與ArrayList不同，ArrayList是一個動態數組，而LinkedList是一個雙向鏈表。所以它除了有ArrayList的基本操作方法外還額外提供了get，remove，insert方法在LinkedList的首部或尾部。</p><p>由於實現的方式不同，LinkedList不能隨機訪問，它所有的操作都是要按照雙重鏈表的需要執行。在列表中索引的操作將從開頭或結尾遍歷列表（從靠近指定索引的一端）。這樣做的好處就是可以通過較低的代價在List中進行插入和刪除操作。</p><p>與ArrayList一樣，LinkedList也是非同步的。如果多個線程同時訪問一個List，則必須自己實現訪問同步。一種解決方法是在創建List時構造一個同步的List：</p><p>List list = Collections.synchronizedList(new LinkedList(...));</p><p>（3）Vector</p><p>與ArrayList相似，但是Vector是同步的。所以說Vector是線程安全的動態數組。它的操作與ArrayList幾乎一樣。</p><p>（4）Stack</p><p>Stack繼承自Vector，實現一個後進先出的堆棧。Stack提供5個額外的方法使得Vector得以被當作堆棧使用。基本的push和pop 方法，還有peek方法得到棧頂的元素，empty方法測試堆棧是否為空，search方法檢測一個元素在堆棧中的位置。Stack剛創建後是空棧。</p><div class=pgc-img><img alt=Java集合框架綜述 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fa6f836ea6b44f478f18fc17342a66bb></div><p>2.Set接口</p><p>Set是一種不包括重複元素的Collection。它維持它自己的內部排序，所以隨機訪問沒有任何意義。與List一樣，它同樣允許null的存在但是僅有一個。由於Set接口的特殊性，所有傳入Set集合中的元素都必須不同，同時要注意任何可變對象，如果在對集合中元素進行操作時，導致e1.equals(e2)==true，則必定會產生某些問題。Set接口有三個具體實現類，分別是散列集HashSet、鏈式散列集LinkedHashSet和樹形集TreeSet。</p><p><strong>Set是一種不包含重複的元素的Collection，無序，即任意的兩個元素e1和e2都有e1.equals(e2)=false，Set最多有一個null元素</strong>。</p><p>需要注意的是：雖然Set中元素沒有順序，但是元素在set中的位置是由該元素的HashCode決定的，其具體位置其實是固定的。</p><blockquote>此外需要說明一點，在set接口中的不重複是有特殊要求的。</blockquote><p>舉一個例子：對象A和對象B，本來是不同的兩個對象，正常情況下它們是能夠放入到Set裡面的，但是如果對象A和B的都重寫了hashcode和equals方法，並且重寫後的hashcode和equals方法是相同的話。那麼A和B是不能同時放入到Set集合中去的，也就是Set集合中的去重和hashcode與equals方法直接相關。</p><p>為了更好地理解，請看下面的例子：</p><p>public class Test{</p><p>public static void main(String[] args) {</p><p>Set&lt;String> set=new HashSet&lt;String>();</p><p>set.add("Hello");</p><p>set.add("world");</p><p>set.add("Hello");</p><p>System.out.println("集合的尺寸為:"+set.size());</p><p>System.out.println("集合中的元素為:"+set.toString());</p><p>}</p><p>}</p><p>運行結果：</p><p>集合的尺寸為:2</p><p>集合中的元素為:[world, Hello]</p><p>分析：由於String類中重寫了hashcode和equals方法，用來比較指向的字符串對象所存儲的字符串是否相等。所以這裡的第二個Hello是加不進去的。</p><p>再看一個例子：</p><p>public class TestSet {</p><p>public static void main(String[] args){</p><p>Set&lt;String> books = new HashSet&lt;String>();</p><p>//添加一個字符串對象</p><p>books.add(new String("Struts2權威指南"));</p><p>//再次添加一個字符串對象，</p><p>//因為兩個字符串對象通過equals方法比較相等，所以添加失敗，返回false</p><p>boolean result = books.add(new String("Struts2權威指南"));</p><p>System.out.println(result);</p><p>//下面輸出看到集合只有一個元素</p><p>System.out.println(books);</p><p>}</p><p>}</p><p>運行結果：</p><p>false</p><p>[Struts2權威指南]</p><p>說明：程序中，book集合兩次添加的字符串對象明顯不是一個對象（程序通過new關鍵字來創建字符串對象），當使用==運算符判斷返回false，使用equals方法比較返回true，所以不能添加到Set集合中，最後只能輸出一個元素。</p><p>（1）HashSet</p><p>HashSet 是一個沒有重複元素的集合。它是由HashMap實現的，不保證元素的順序(這裡所說的沒有順序是指：元素插入的順序與輸出的順序不一致)，而且HashSet允許使用null 元素。HashSet是非同步的，如果多個線程同時訪問一個哈希set，而其中至少一個線程修改了該set，那麼它必須保持外部同步。 <strong>HashSet按Hash算法來存儲集合的元素，因此具有很好的存取和查找性能</strong>。</p><p>HashSet的實現方式大致如下，通過一個HashMap存儲元素，元素是存放在HashMap的Key中，而Value統一使用一個Object對象。</p><p><strong>HashSet使用和理解中容易出現的誤區</strong>:</p><ul><li>HashSet中存放null值。HashSet中是允許存入null值的，但是在HashSet中僅僅能夠存入一個null值。</li><li>HashSet中存儲元素的位置是固定的。HashSet中存儲的元素的是無序的，這個沒什麼好說的，但是由於HashSet底層是基於Hash算法實現的，使用了hashcode，所以HashSet中相應的元素的位置是固定的。</li><li>必須小心操作可變對象（Mutable Object）。如果一個Set中的可變元素改變了自身狀態導致Object.equals(Object)=true將導致一些問題。</li></ul><p>（2）LinkedHashSet</p><p>LinkedHashSet繼承自HashSet，其底層是基於LinkedHashMap來實現的，有序，非同步。LinkedHashSet集合同樣是根據元素的hashCode值來決定元素的存儲位置，但是它同時使用鏈表維護元素的次序。這樣使得元素看起來像是以插入順序保存的，也就是說，當遍歷該集合時候，LinkedHashSet將會以元素的添加順序訪問集合的元素。</p><p>（3）TreeSet</p><p>TreeSet是一個有序集合，其底層是基於TreeMap實現的，非線程安全。TreeSet可以確保集合元素處於排序狀態。TreeSet支持兩種排序方式，自然排序和定製排序，其中自然排序為默認的排序方式。當我們構造TreeSet時，若使用不帶參數的構造函數，則TreeSet的使用自然比較器；若用戶需要使用自定義的比較器，則需要使用帶比較器的參數。</p><blockquote>注意：TreeSet集合不是通過hashcode和equals函數來比較元素的.它是通過compare或者comparaeTo函數來判斷元素是否相等.compare函數通過判斷兩個對象的id，相同的id判斷為重複元素，不會被加入到集合中。</blockquote><hr><p>四、Map接口</p><p>Map與List、Set接口不同，它是由一系列鍵值對組成的集合，提供了key到Value的映射。同時它也沒有繼承Collection。在Map中它保證了key與value之間的一一對應關係。也就是說一個key對應一個value，所以它<strong>不能存在相同的key值，當然value值可以相同</strong>。</p><p>1.HashMap</p><p>以哈希表數據結構實現，查找對象時通過哈希函數計算其位置，它是為快速查詢而設計的，其內部定義了一個hash表數組（Entry[] table），元素會通過哈希轉換函數將元素的哈希地址轉換成數組中存放的索引，如果有衝突，則使用散列鏈表的形式將所有相同哈希地址的元素串起來，可能通過查看HashMap.Entry的源碼它是一個單鏈表結構。</p><p>2.LinkedHashMap</p><p>LinkedHashMap是HashMap的一個子類，它保留插入的順序，如果需要輸出的順序和輸入時的相同，那麼就選用LinkedHashMap。</p><p><strong>LinkedHashMap是Map接口的哈希表和鏈接列表實現，具有可預知的迭代順序</strong>。此實現提供所有可選的映射操作，並允許使用null值和null鍵。此類不保證映射的順序，特別是它不保證該順序恆久不變。</p><p>LinkedHashMap實現與HashMap的不同之處在於，後者維護著一個運行於所有條目的雙重鏈接列表。此鏈接列表定義了迭代順序，該迭代順序可以是插入順序或者是訪問順序。</p><p>根據鏈表中元素的順序可以分為：按插入順序的鏈表，和按訪問順序(調用get方法)的鏈表。默認是按插入順序排序，如果指定按訪問順序排序，那麼調用get方法後，會將這次訪問的元素移至鏈表尾部，不斷訪問可以形成按訪問順序排序的鏈表。</p><blockquote>注意，此實現不是同步的。如果多個線程同時訪問鏈接的哈希映射，而其中至少一個線程從結構上修改了該映射，則它必須保持外部同步。由於LinkedHashMap需要維護元素的插入順序，因此性能略低於HashMap的性能，但在迭代訪問Map裡的全部元素時將有很好的性能，因為它以鏈表來維護內部順序。</blockquote><p>3.TreeMap</p><p><strong>TreeMap 是一個有序的key-value集合，非同步，基於紅黑樹（Red-Black tree）實現，每一個key-value節點作為紅黑樹的一個節點</strong>。TreeMap存儲時會進行排序的，會根據key來對key-value鍵值對進行排序，其中排序方式也是分為兩種，一種是自然排序，一種是定製排序，具體取決於使用的構造方法。</p><p><strong>自然排序</strong>：TreeMap中所有的key必須實現Comparable接口，並且所有的key都應該是同一個類的對象，否則會報ClassCastException異常。</p><p><strong>定製排序</strong>：定義TreeMap時，創建一個comparator對象，該對象對所有的treeMap中所有的key值進行排序，採用定製排序的時候不需要TreeMap中所有的key必須實現Comparable接口。</p><p>TreeMap判斷兩個元素相等的標準：兩個key通過compareTo()方法返回0，則認為這兩個key相等。</p><p>如果使用自定義的類來作為TreeMap中的key值，且想讓TreeMap能夠良好的工作，則必須重寫自定義類中的equals()方法，TreeMap中判斷相等的標準是：兩個key通過equals()方法返回為true，並且通過compareTo()方法比較應該返回為0。</p><div class=pgc-img><img alt=Java集合框架綜述 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cccdd1b2bd284a7fb3fbf54b45bf4b0a></div><hr><p>五、Iterator 與 ListIterator詳解</p><p>1.Iterator</p><p>Iterator的定義如下：</p><p>public interface Iterator&lt;E> {}</p><p>Iterator是一個接口，它是集合的迭代器。集合可以通過Iterator去遍歷集合中的元素。</p><ul><li>Iterator提供的API接口如下：</li><li>boolean hasNext()：判斷集合裡是否存在下一個元素。如果有，hasNext()方法返回 true。</li><li>Object next()：返回集合裡下一個元素。</li></ul><p>void remove()：刪除集合裡上一次next方法返回的元素。</p><p>使用示例：</p><p>public class IteratorExample {</p><p>public static void main(String[] args) {</p><p>ArrayList&lt;String> a = new ArrayList&lt;String>();</p><p>a.add("aaa");</p><p>a.add("bbb");</p><p>a.add("ccc");</p><p>System.out.println("Before iterate : " + a);</p><p>Iterator&lt;String> it = a.iterator();</p><p>while (it.hasNext()) {</p><p>String t = it.next();</p><p>if ("bbb".equals(t)) {</p><p>it.remove();</p><p>}</p><p>}</p><p>System.out.println("After iterate : " + a);</p><p>}</p><p>}</p><p>輸出結果如下：</p><p>Before iterate : [aaa, bbb, ccc]</p><p>After iterate : [aaa, ccc]</p><p><strong>注意</strong>：</p><ul><li>Iterator只能單向移動。</li><li>Iterator.remove()是唯一安全的方式來在迭代過程中修改集合；如果在迭代過程中以任何其它的方式修改了基本集合將會產生未知的行為。而且每調用一次next()方法，remove()方法只能被調用一次，如果違反這個規則將拋出一個異常。</li></ul><p>2.ListIterator</p><p><strong>ListIterator是一個功能更加強大的迭代器, 它繼承於Iterator接口</strong>，只能用於各種List類型的訪問。可以通過調用listIterator()方法產生一個指向List開始處的ListIterator, 還可以調用listIterator(n)方法創建一個一開始就指向列表索引為n的元素處的ListIterator。</p><p>ListIterator接口定義如下:</p><p>public interface ListIterator&lt;E> extends Iterator&lt;E> {</p><p>boolean hasNext();</p><p>E next();</p><p>boolean hasPrevious();</p><p>E previous();</p><p>int nextIndex();</p><p>int previousIndex();</p><p>void remove();</p><p>void set(E e);</p><p>void add(E e);</p><p>}</p><p>由以上定義我們可以推出ListIterator可以:</p><ul><li>雙向移動（向前/向後遍歷）.</li><li>產生相對於迭代器在列表中指向的當前位置的前一個和後一個元素的索引.</li><li>可以使用set()方法替換它訪問過的最後一個元素.</li><li>可以使用add()方法在next()方法返回的元素之前或previous()方法返回的元素之後插入一個元素.</li></ul><p>使用示例：</p><p>public class ListIteratorExample {</p><p>public static void main(String[] args) {</p><p>ArrayList&lt;String> a = new ArrayList&lt;String>();</p><p>a.add("aaa");</p><p>a.add("bbb");</p><p>a.add("ccc");</p><p>System.out.println("Before iterate : " + a);</p><p>ListIterator&lt;String> it = a.listIterator();</p><p>while (it.hasNext()) {</p><p>System.out.println(it.next() + ", " + it.previousIndex() + ", " + it.nextIndex());</p><p>}</p><p>while (it.hasPrevious()) {</p><p>System.out.print(it.previous() + " ");</p><p>}</p><p>System.out.println();</p><p>it = a.listIterator(1);</p><p>while (it.hasNext()) {</p><p>String t = it.next();</p><p>System.out.println(t);</p><p>if ("ccc".equals(t)) {</p><p>it.set("nnn");</p><p>} else {</p><p>it.add("kkk");</p><p>}</p><p>}</p><p>System.out.println("After iterate : " + a);</p><p>}</p><p>}</p><p>輸出結果如下：</p><p>Before iterate : [aaa, bbb, ccc]</p><p>aaa, 0, 1</p><p>bbb, 1, 2</p><p>ccc, 2, 3</p><p>ccc bbb aaa</p><p>bbb</p><p>ccc</p><p>After iterate : [aaa, bbb, kkk, nnn]</p><hr><p>六、異同點</p><p>1.ArrayList和LinkedList</p><ul><li>ArrayList是實現了基於動態數組的數據結構，LinkedList基於鏈表的數據結構。</li><li>對於隨機訪問get和set，ArrayList絕對優於LinkedList，因為LinkedList要移動指針。</li><li>對於新增和刪除操作add和remove，LinedList比較佔優勢，因為ArrayList要移動數據。</li></ul><p>這一點要看實際情況的。若只對單條數據插入或刪除，ArrayList的速度反而優於LinkedList。但若是批量隨機的插入刪除數據，LinkedList的速度大大優於ArrayList. 因為ArrayList每插入一條數據，要移動插入點及之後的所有數據。</p><p>2.HashTable與HashMap</p><p><strong>相同點</strong>：</p><ul><li>都實現了Map、Cloneable、java.io.Serializable接口。</li><li>都是存儲"鍵值對(key-value)"的散列表，而且都是採用拉鍊法實現的。</li></ul><p><strong>不同點</strong>：</p><ol><li><strong>歷史原因</strong>：HashTable是基於陳舊的Dictionary類的，HashMap是Java 1.2引進的Map接口的一個實現 。</li><li><strong>同步性</strong>：HashTable是線程安全的，也就是說是同步的，而HashMap是線程序不安全的，不是同步的 。</li><li><strong>對null值的處理</strong>：HashMap的key、value都可為null，HashTable的key、value都不可為null 。</li><li><strong>基類不同</strong>：HashMap繼承於AbstractMap，而Hashtable繼承於Dictionary。</li></ol><ul><li>Dictionary是一個抽象類，它直接繼承於Object類，沒有實現任何接口。Dictionary類是JDK 1.0的引入的。雖然Dictionary也支持“添加key-value鍵值對”、“獲取value”、“獲取大小”等基本操作，但它的API函數比Map少；而且Dictionary一般是通過Enumeration(枚舉類)去遍歷，Map則是通過Iterator(迭代M器)去遍歷。 然而由於Hashtable也實現了Map接口，所以，它即支持Enumeration遍歷，也支持Iterator遍歷。</li><li>AbstractMap是一個抽象類，它實現了Map接口的絕大部分API函數；為Map的具體實現類提供了極大的便利。它是JDK 1.2新增的類。</li></ul><ol><li><strong>支持的遍歷種類不同</strong>：HashMap只支持Iterator(迭代器)遍歷。而Hashtable支持Iterator(迭代器)和Enumeration(枚舉器)兩種方式遍歷。</li></ol><p>3.HashMap、Hashtable、LinkedHashMap和TreeMap比較</p><p>Hashmap 是一個最常用的Map，它根據鍵的HashCode 值存儲數據，根據鍵可以直接獲取它的值，具有很快的訪問速度。遍歷時，取得數據的順序是完全隨機的。<strong>HashMap最多隻允許一條記錄的鍵為Null；允許多條記錄的值為Null；HashMap不支持線程的同步，即任一時刻可以有多個線程同時寫HashMap；可能會導致數據的不一致</strong>。如果需要同步，可以用Collections的synchronizedMap方法使HashMap具有同步的能力。</p><p>Hashtable 與 HashMap類似，不同的是：<strong>它不允許記錄的鍵或者值為空；它支持線程的同步</strong>，即任一時刻只有一個線程能寫Hashtable，因此也導致了Hashtale在寫入時會比較慢。</p><p>LinkedHashMap保存了記錄的插入順序，在用Iterator遍歷LinkedHashMap時，先得到的記錄肯定是先插入的，也可以在構造時用帶參數，按照應用次數排序。在遍歷的時候會比HashMap慢，不過有種情況例外，<strong>當HashMap容量很大，實際數據較少時，遍歷起來可能會比LinkedHashMap慢，因為LinkedHashMap的遍歷速度只和實際數據有關，和容量無關，而HashMap的遍歷速度和他的容量有關</strong>。</p><p>如果需要輸出的順序和輸入的相同，那麼用LinkedHashMap可以實現，它還可以按讀取順序來排列，像連接池中可以應用。LinkedHashMap實現與HashMap的不同之處在於，後者維護著一個運行於所有條目的雙重鏈表。此鏈接列表定義了迭代順序，該迭代順序可以是插入順序或者是訪問順序。對於LinkedHashMap而言，它繼承與HashMap、底層使用哈希表與雙向鏈表來保存所有元素。其基本操作與父類HashMap相似，它通過重寫父類相關的方法，來實現自己的鏈接列表特性。</p><p><strong>TreeMap實現SortMap接口，內部實現是紅黑樹</strong>。能夠把它保存的記錄根據鍵排序，默認是按鍵值的升序排序，也可以指定排序的比較器，當用Iterator 遍歷TreeMap時，得到的記錄是排過序的。TreeMap不允許key的值為null。非同步的。</p><p>一般情況下，我們用的最多的是HashMap，HashMap裡面存入的鍵值對在取出的時候是隨機的，它根據鍵的HashCode值存儲數據，根據鍵可以直接獲取它的值，具有很快的訪問速度。在Map 中插入、刪除和定位元素，HashMap 是最好的選擇。</p><p>TreeMap取出來的是排序後的鍵值對。但如果您要按自然順序或自定義順序遍歷鍵，那麼TreeMap會更好。</p><p>LinkedHashMap 是HashMap的一個子類，如果需要輸出的順序和輸入的相同，那麼用LinkedHashMap可以實現，它還可以按讀取順序來排列，像連接池中可以應用。</p><p>import java.util.HashMap;</p><p>import java.util.Iterator;</p><p>import java.util.LinkedHashMap;</p><p>import java.util.TreeMap;</p><p>public class MapTest {</p><p>public static void main(String[] args) {</p><p>//HashMap</p><p>HashMap&lt;String,String> hashMap = new HashMap();</p><p>hashMap.put("4", "d");</p><p>hashMap.put("3", "c");</p><p>hashMap.put("2", "b");</p><p>hashMap.put("1", "a");</p><p>Iterator&lt;String> iteratorHashMap = hashMap.keySet().iterator();</p><p>System.out.println("HashMap-->");</p><p>while (iteratorHashMap.hasNext()){</p><p>Object key1 = iteratorHashMap.next();</p><p>System.out.println(key1 + "--" + hashMap.get(key1));</p><p>}</p><p>//LinkedHashMap</p><p>LinkedHashMap&lt;String,String> linkedHashMap = new LinkedHashMap();</p><p>linkedHashMap.put("4", "d");</p><p>linkedHashMap.put("3", "c");</p><p>linkedHashMap.put("2", "b");</p><p>linkedHashMap.put("1", "a");</p><p>Iterator&lt;String> iteratorLinkedHashMap = linkedHashMap.keySet().iterator();</p><p>System.out.println("LinkedHashMap-->");</p><p>while (iteratorLinkedHashMap.hasNext()){</p><p>Object key2 = iteratorLinkedHashMap.next();</p><p>System.out.println(key2 + "--" + linkedHashMap.get(key2));</p><p>}</p><p>//TreeMap</p><p>TreeMap&lt;String,String> treeMap = new TreeMap();</p><p>treeMap.put("4", "d");</p><p>treeMap.put("3", "c");</p><p>treeMap.put("2", "b");</p><p>treeMap.put("1", "a");</p><p>Iterator&lt;String> iteratorTreeMap = treeMap.keySet().iterator();</p><p>System.out.println("TreeMap-->");</p><p>while (iteratorTreeMap.hasNext()){</p><p>Object key3 = iteratorTreeMap.next();</p><p>System.out.println(key3 + "--" + treeMap.get(key3));</p><p>}</p><p>}</p><p>}</p><p>輸出結果：</p><p>HashMap--></p><p>3--c</p><p>2--b</p><p>1--a</p><p>4--d</p><p>LinkedHashMap--></p><p>4--d</p><p>3--c</p><p>2--b</p><p>1--a</p><p>TreeMap--></p><p>1--a</p><p>2--b</p><p>3--c</p><p>4--d</p><p>4.HashSet、LinkedHashSet、TreeSet比較</p><p>Set接口</p><p><strong>Set不允許包含相同的元素</strong>，如果試圖把兩個相同元素加入同一個集合中，add方法返回false。</p><p><strong>Set判斷兩個對象相同不是使用==運算符，而是根據equals方法</strong>。也就是說，只要兩個對象用equals方法比較返回true，Set就不會接受這兩個對象。</p><p>HashSet</p><p>HashSet有以下特點：</p><ul><li>不能保證元素的排列順序，順序有可能發生變化。</li><li>不是同步的。</li><li>集合元素可以是null，但只能放入一個null。</li></ul><p>當向HashSet結合中存入一個元素時，HashSet會調用該對象的hashCode()方法來得到該對象的hashCode值，然後根據 hashCode值來決定該對象在HashSet中存儲位置。簡單的說，<strong>HashSet集合判斷兩個元素相等的標準是兩個對象通過equals方法比較相等，並且兩個對象的hashCode()方法返回值也相等</strong>。</p><blockquote>注意，如果要把一個對象放入HashSet中，重寫該對象對應類的equals方法，也應該重寫其hashCode()方法。其規則是如果兩個對象通過equals方法比較返回true時，其hashCode也應該相同。另外，對象中用作equals比較標準的屬性，都應該用來計算 hashCode的值。</blockquote><p>LinkedHashSet</p><p>LinkedHashSet集合同樣是根據元素的hashCode值來決定元素的存儲位置，但是它同時使用鏈表維護元素的次序。這樣使得元素看起來像是以插入順序保存的，也就是說，當遍歷該集合時候，LinkedHashSet將會以元素的添加順序訪問集合的元素。</p><p><strong>LinkedHashSet在迭代訪問Set中的全部元素時，性能比HashSet好，但是插入時性能稍微遜色於HashSet</strong>。</p><p>TreeSet類</p><p>TreeSet是SortedSet接口的唯一實現類，TreeSet可以確保集合元素處於排序狀態。TreeSet支持兩種排序方式，自然排序和定製排序，其中自然排序為默認的排序方式。向TreeSet中加入的應該是同一個類的對象。</p><p><strong>TreeSet判斷兩個對象不相等的方式是兩個對象通過equals方法返回false，或者通過CompareTo方法比較沒有返回0</strong>。</p><p>自然排序</p><p>自然排序使用要排序元素的CompareTo（Object obj）方法來比較元素之間大小關係，然後將元素按照升序排列。</p><blockquote>Java提供了一個Comparable接口，該接口裡定義了一個compareTo(Object obj)方法，該方法返回一個整數值，實現了該接口的對象就可以比較大小。obj1.compareTo(obj2)方法如果返回0，則說明被比較的兩個對象相等，如果返回一個正數，則表明obj1大於obj2，如果是負數，則表明obj1小於obj2。如果我們將兩個對象的equals方法總是返回true，則這兩個對象的compareTo方法返回應該返回0。</blockquote><p>定製排序</p><p>自然排序是根據集合元素的大小，以升序排列，如果要定製排序，應該使用Comparator接口，實現int compare(T o1,T o2)方法。</p><p>package com.test;</p><p>import java.util.HashSet;</p><p>import java.util.LinkedHashSet;</p><p>import java.util.TreeSet;</p><p>/**</p><p>* @description 幾個set的比較</p><p>* HashSet：哈希表是通過使用稱為散列法的機制來存儲信息的，元素並沒有以某種特定順序來存放；</p><p>* LinkedHashSet：以元素插入的順序來維護集合的鏈接表，允許以插入的順序在集合中迭代；</p><p>* TreeSet：提供一個使用樹結構存儲Set接口的實現，對象以升序順序存儲，訪問和遍歷的時間很快。</p><p>* @author Zhou-Jingxian</p><p>*</p><p>*/</p><p>public class SetDemo {</p><p>public static void main(String[] args) {</p><p>HashSet&lt;String> hs = new HashSet&lt;String>();</p><p>hs.add("B");</p><p>hs.add("A");</p><p>hs.add("D");</p><p>hs.add("E");</p><p>hs.add("C");</p><p>hs.add("F");</p><p>System.out.println("HashSet 順序:\n"+hs);</p><p>LinkedHashSet&lt;String> lhs = new LinkedHashSet&lt;String>();</p><p>lhs.add("B");</p><p>lhs.add("A");</p><p>lhs.add("D");</p><p>lhs.add("E");</p><p>lhs.add("C");</p><p>lhs.add("F");</p><p>System.out.println("LinkedHashSet 順序:\n"+lhs);</p><p>TreeSet&lt;String> ts = new TreeSet&lt;String>();</p><p>ts.add("B");</p><p>ts.add("A");</p><p>ts.add("D");</p><p>ts.add("E");</p><p>ts.add("C");</p><p>ts.add("F");</p><p>System.out.println("TreeSet 順序:\n"+ts);</p><p>}</p><p>}</p><p>輸出結果：</p><p>HashSet 順序:[D, E, F, A, B, C]</p><p>LinkedHashSet 順序:[B, A, D, E, C, F]</p><p>TreeSet 順序:[A, B, C, D, E, F]</p><p>5、Iterator和ListIterator區別</p><p>我們在使用List，Set的時候，為了實現對其數據的遍歷，我們經常使用到了Iterator(迭代器)。使用迭代器，你不需要干涉其遍歷的過程，只需要每次取出一個你想要的數據進行處理就可以了。但是在使用的時候也是有不同的。</p><p>List和Set都有iterator()來取得其迭代器。對List來說，你也可以通過listIterator()取得其迭代器，兩種迭代器在有些時候是不能通用的，Iterator和ListIterator主要區別在以下方面：</p><ul><li>ListIterator有add()方法，可以向List中添加對象，而Iterator不能</li><li>ListIterator和Iterator都有hasNext()和next()方法，可以實現順序向後遍歷，但是ListIterator有hasPrevious()和previous()方法，可以實現逆向（順序向前）遍歷。Iterator就不可以。</li><li>ListIterator可以定位當前的索引位置，nextIndex()和previousIndex()可以實現。Iterator沒有此功能。</li><li>都可實現刪除對象，但是ListIterator可以實現對象的修改，set()方法可以實現。Iierator僅能遍歷，不能修改。</li></ul><p>因為ListIterator的這些功能，可以實現對LinkedList等List數據結構的操作。其實，數組對象也可以用迭代器來實現。</p><p>6、Collection 和 Collections區別</p><p><strong>（1）java.util.Collection 是一個集合接口（集合類的一個頂級接口）</strong>。它提供了對集合對象進行基本操作的通用接口方法。Collection接口在Java 類庫中有很多具體的實現。Collection接口的意義是為各種具體的集合提供了最大化的統一操作方式，其直接繼承接口有List與Set。</p><p>Collection</p><p>├List</p><p>│├LinkedList</p><p>│├ArrayList</p><p>│└Vector</p><p>│　└Stack</p><p>└Set</p><p><strong>（2）java.util.Collections 是一個包裝類（工具類/幫助類）</strong>。它包含有各種有關集合操作的靜態多態方法。此類不能實例化，就像一個工具類，用於對集合中元素進行排序、搜索以及線程安全等各種操作，服務於Java的Collection框架。</p><p>代碼示例：</p><p>import java.util.ArrayList;</p><p>import java.util.Collections;</p><p>import java.util.List;</p><p>public class TestCollections {</p><p>public static void main(String args[]) {</p><p>//注意List是實現Collection接口的</p><p>List list = new ArrayList();</p><p>double array[] = { 112, 111, 23, 456, 231 };</p><p>for (int i = 0; i &lt; array.length; i++) {</p><p>list.add(new Double(array[i]));</p><p>}</p><p>Collections.sort(list);</p><p>for (int i = 0; i &lt; array.length; i++) {</p><p>System.out.println(list.get(i));</p><p>}</p><p>// 結果：23.0 111.0 112.0 231.0 456.0</p><p>}</p><p>}</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>綜述</a></li><li><a>集合</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html alt=Java集合-Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/da488e5c.html title=Java集合-Collection>Java集合-Collection</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1ee224b.html alt=Java集合-Queue class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7b956858a7a540d0990d7831eb906983 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1ee224b.html title=Java集合-Queue>Java集合-Queue</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/80dcc482.html alt=最常用的Java集合類，你一定用過 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c67cd5e4de3b459c8010e8be5a995e0d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/80dcc482.html title=最常用的Java集合類，你一定用過>最常用的Java集合類，你一定用過</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcb4e09c.html alt=詳談Java集合框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcb4e09c.html title=詳談Java集合框架>詳談Java集合框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa2e8109.html alt="Java集合Set 集合、List和Collections類" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e1ec4b6968944a9aba6a970e3792728c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa2e8109.html title="Java集合Set 集合、List和Collections類">Java集合Set 集合、List和Collections類</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65ba507a.html alt=Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9e3bf229076045f18e5bb24370a78db0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65ba507a.html title=Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？>Java集合類之Collection接口，集合的“爸爸”接口瞭解一下？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html alt=Java集合詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d86fadc20bed4a69ad6bf811308371d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html title=Java集合詳解>Java集合詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>