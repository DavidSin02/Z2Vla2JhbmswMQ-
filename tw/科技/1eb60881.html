<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>NOIP2018動態規劃複習-樹型動態規劃！ | 极客快訊</title><meta property="og:title" content="NOIP2018動態規劃複習-樹型動態規劃！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/dc30169e-7dfd-4c59-b2b3-7ff96d108dcb"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1eb60881.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1eb60881.html><meta property="article:published_time" content="2020-11-14T21:00:20+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:20+08:00"><meta name=Keywords content><meta name=description content="NOIP2018動態規劃複習-樹型動態規劃！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1eb60881.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>NOIP2018動態規劃複習-樹型動態規劃！</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>NOIP歷年考試中動態規劃都是一個非常重要的考點。清北信息學今天為大家帶來常考的動態規劃題型及知識點介紹。歡迎大家補充討論。</p><div class=pgc-img><img alt=NOIP2018動態規劃複習-樹型動態規劃！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/dc30169e-7dfd-4c59-b2b3-7ff96d108dcb><p class=pgc-img-caption></p></div><ul><li class=ql-align-justify>搜索與動態規劃-搜索的知識點歸納</li><li class=ql-align-justify>搜索與動態規劃-搜索的重難點和例題解讀</li><li class=ql-align-justify>搜索與動態規劃-動態規劃知識點分析</li><li class=ql-align-justify>搜索與動態規劃-動態規劃重難點習題詳解</li><li class=ql-align-justify>搜索與動態規劃-動態規劃重難點習題詳解</li><li class=ql-align-justify>OI省選算法之DP</li><li class=ql-align-justify>探求Floyd算法的動態規劃本質</li><li class=ql-align-justify>經典算法研究總結（5）-動態規劃算法解最長公共子序列LCS問題</li><li class=ql-align-justify>超棒的DP問題詳解之初識動態規劃</li><li class=ql-align-justify>超棒的DP問題詳解之動態規劃的思考角度</li><li class=ql-align-justify>動態規劃習題之最優二叉搜索樹</li><li class=ql-align-justify>超棒的DP問題詳解之動態規劃的優點</li><li class=ql-align-justify>動態規劃之 遞推思想</li><li class=ql-align-justify>動態規劃專題-除了遞推之外需要了解的思想</li><li class=ql-align-justify>動態規劃經典模型-區間模型</li><li class=ql-align-justify>動態規劃經典模型之狀態壓縮模型</li><li class=ql-align-justify>動態規劃經典模型-揹包模型</li><li class=ql-align-justify>動態規劃的常用狀態轉移方程</li><li class=ql-align-justify>座標規則型動態規劃</li></ul><p>除了以上描述以外，在NOIP中經常出現的動態規劃類問題。清北信息學今天介紹下</p><p>樹型動態規劃</p><p>如果同學們有更多關於動態規劃類習題的解題經驗及知識點補充，歡迎在文章底部留言給我們。</p><p>之所以這樣命名樹規，是因為樹規的這一特殊性：沒有環，dfs是不會重複，而且具有明顯而又嚴格的層數關係。利用這一特性，我們可以很清晰地根據題目寫出一個在樹（型結構）上的記憶化搜索的程序。而深搜的特點，就是“不撞南牆不回頭”。這一點在之後的文章中會詳細的介紹。</p><p>首先是掃盲，介紹幾條名詞的專業解釋以顯示我的高端（大部分人可以略過，因為學習到樹規的人一下應該都懂……）：</p><p>動態規劃：</p><p>問題可以分解成若干相互聯繫的階段，在每一個階段都要做出決策，全部過程的決策是一個決策序列。要使整個活動的總體效果達到最優的問題，稱為多階段決策問題。動態規劃就是解決多階段決策最優化問題的一種思想方法。</p><p>階段：</p><p>將所給問題的過程，按時間或空間（樹歸中是空間，即層數）特徵分解成若干相互聯繫的階段，以便按次序去求每階段的解。</p><p>狀態：</p><p>各階段開始時的客觀條件叫做狀態。</p><p>決策：</p><p><strong>當各段的狀態取定以後，就可以做出不同的決定，從而確定下一階段的狀態，這種決定稱為決策。 （即孩子節點和父親節點的關係）</strong></p><p>策略：</p><p>由開始到終點的全過程中，由每段決策組成的決策序列稱為全過程策略，簡稱策略。</p><p>狀態轉移方程：</p><p><strong>前一階段的終點就是後一階段的起點，前一階段的決策選擇導出了後一階段的狀態，這種關係描述了由k階段到k+1階段（在樹中是孩子節點和父親節點）狀態的演變規律，稱為狀態轉移方程。</strong></p><p>目標函數與最優化概念：</p><p>目標函數是衡量多階段決策過程優劣的準則。最優化概念是在一定條件下找到一個途徑，經過按題目具體性質所確定的運算以後，使全過程的總效益達到最優。</p><p>樹的特點與性質：</p><p><strong>1、 有n個點，n-1條邊的無向圖，任意兩頂點間可達</strong></p><p><strong>2、 無向圖中任意兩個點間有且只有一條路</strong></p><p><strong>3、 一個點至多有一個前趨，但可以有多個後繼</strong></p><p><strong>4、 無向圖中沒有環；</strong></p><p>廢話說完了，下面是正文：</p><p>拿到一道樹規題，我們有以下3個步驟需要執行：</p><ol><li><strong>判斷是否是一道樹規題：</strong>即判斷數據結構是否是一棵樹，然後是否符合動態規劃的要求。如果是，那麼執行以下步驟，如果不是，那麼換臺。</li><li><strong>建樹：</strong>通過數據量和題目要求，選擇合適的樹的存儲方式。如果節點數小於5000，那麼我們可以用鄰接矩陣存儲，如果更大可以用鄰接表來存儲(注意邊要開到2*n，因為是雙向的。這是血與淚的教訓)。如果是二叉樹或者是需要多叉轉二叉，那麼我們可以用兩個一維數組brother[]，child[]來存儲（這一點下面會仔細數的）。</li><li><strong>寫出樹規方程：</strong>通過觀察孩子和父親之間的關係建立方程。我們通常認為，樹規的寫法有兩種：</li></ol><p>a.根到葉子: 不過這種動態規劃在實際的問題中運用的不多。本文只有最後一題提到。</p><p>b.葉子到根: 既根的子節點傳遞有用的信息給根，完後根得出最優解的過程。這類的習題比較的多。</p><p>注意：這兩種寫法一般情況下是不能相互轉化的。但是有時可以同時使用具體往後看。</p><p>以下即將分析的題目的目錄及題目特點：</p><p><strong>1、加分二叉樹：</strong>區間動規+樹的遍歷；</p><p><strong>2、二叉蘋果樹：</strong>二叉樹上的動規；</p><p><strong>3、最大利潤：</strong>多叉樹上的動規；</p><p><strong>4、選課：</strong>多叉樹轉二叉；</p><p><strong>5、選課（輸出方案）：</strong>多叉轉二叉+記錄路徑；</p><p><strong>6、軟件安裝：</strong>判斷環+縮點+多叉轉二叉；</p><p>【4、5、6屬於依賴問題的變形】</p><p>基本的知識掌握和步驟了，我們就通過習題來感受一下樹規的魅力，先來看這樣一道題：</p><p><strong>1、加分二叉樹</strong></p><p class=ql-align-justify>【問題描述】</p><p class=ql-align-justify>設一個n個節點的二叉樹tree的中序遍歷為（l,2,3,…,n），其中數字1,2,3,…,n為節點編號。每個節點都有一個分數（均為正整數），記第i個節點的分數為di，tree及它的每個子樹都有一個加分，任一棵子樹subtree（也包含tree本身）的加分計算方法如下：</p><p class=ql-align-justify>subtree的左子樹的加分× subtree的右子樹的加分＋subtree的根的分數</p><p class=ql-align-justify>若某個子樹為空，規定其加分為1，葉子的加分就是葉節點本身的分數。不考慮它的空子樹。</p><p class=ql-align-justify>試求一棵符合中序遍歷為（1,2,3,…,n）且加分最高的二叉樹tree。要求輸出；</p><p class=ql-align-justify>（1）tree的最高加分</p><p class=ql-align-justify>（2）tree的前序遍歷</p><p class=ql-align-justify>【輸入格式】</p><p class=ql-align-justify>第1行：一個整數n（n＜30），為節點個數。</p><p class=ql-align-justify>第2行：n個用空格隔開的整數，為每個節點的分數（分數＜100）。</p><p class=ql-align-justify>【輸出格式】</p><p class=ql-align-justify>第1行：一個整數，為最高加分（結果不會超過4,000,000,000）。</p><p class=ql-align-justify>第2行：n個用空格隔開的整數，為該樹的前序遍歷。</p><p class=ql-align-justify></p><p class=ql-align-justify>【算法&思路】：</p><p class=ql-align-justify>看到這個問題，我們首先應該想到的是這道題是否屬於動態規劃，而這裡我們發現，結合問題，如果整棵樹的權值最大，必然有左子樹的權值最大，右子樹的權值也最大，符合最優性原理。所以是動態規劃。而卻不是一道樹規的題目。因為我們可以用區間動規的模型解決掉：直接定義一個f[i][j]表示從i到j的最大值，則f[i][j]=max(f[i][k-1]*f[k+1][j]+a[k]),枚舉k即可。接下來是如何建樹的問題，只有把樹建好了，才能輸出其前序遍歷。於是，我們看到了兩個關鍵詞：二叉樹，中序遍歷。有了這兩個關鍵詞，加上區間動規，這棵樹就能建起來了。根據二叉樹的特性來建樹（這裡不再具體討論樹的詳細的構造了，中序遍歷和前序遍歷不懂得自己百度）。所以這顆樹的前序遍歷，只需要邊動規邊記錄下root[i][j]=k表示i到j的根為k即可確定樹的構造。</p><p>#include&lt;iostream></p><p>#include&lt;iomanip></p><p>#include&lt;cstring></p><p>#include&lt;cstdio></p><p>#include&lt;cmath></p><p>#include&lt;memory></p><p>#include&lt;algorithm></p><p>#include&lt;string></p><p>#include&lt;climits></p><p>#include&lt;queue></p><p>#include&lt;vector></p><p>#include&lt;cstdlib></p><p>#include&lt;map></p><p>using namespace std;</p><p>const int ee=50,e=-999999999;</p><p>int n;</p><p>int a[ee]={0},f[ee][ee],root[ee][ee]={0};//f(i,j)中序遍歷為i,i+1,…,j的二叉樹的最大加分</p><p>//**若根節點的下表是k，則左端點的是k-1，右端點是k+1；</p><p>void front(int x,int y)</p><p>{</p><p>if(root[x][y]!=0)</p><p>cout&lt;&lt;root[x][y]&lt;&lt;' ';</p><p>if(root[x][root[x][y]-1]!=0) front(x,root[x][y]-1);</p><p>if(root[root[x][y]+1][y]!=0) front(root[x][y]+1,y);</p><p>}</p><p>int main()</p><p>{</p><p>//freopen("in.in","r",stdin);</p><p>//memset 賦初值不能為1 memset(f,1,sizeof(f));</p><p>cin>>n;</p><p>for(int i=0;i&lt;=n;i++)</p><p>{</p><p>for(int j=0;j&lt;=n;j++)</p><p>f[i][j]=1;</p><p>}</p><p>for(int i=1;i&lt;=n;i++)</p><p>{</p><p>cin>>a[i];</p><p>f[i][i]=a[i];</p><p>root[i][i]=i;</p><p>}</p><p>//區間長度</p><p>for(int len=1;len&lt;=n;len++)</p><p>{</p><p>//區間起點</p><p>for(int i=1;i&lt;=n;i++)</p><p>{</p><p>//終點</p><p>int j=i+len;</p><p>if(j&lt;=n)</p><p>{</p><p>int temp=e;</p><p>//因為是中序排列</p><p>for(int k=i;k&lt;=j;k++)</p><p>{</p><p>if(temp &lt; (f[i][k-1]*f[k+1][j]+a[k]))</p><p>{</p><p>temp=f[i][k-1]*f[k+1][j]+a[k];</p><p>root[i][j]=k;</p><p>}</p><p>}</p><p>f[i][j]=temp;</p><p>}</p><p>}</p><p>}</p><p>cout&lt;&lt;f[1][n];</p><p>//前序遍歷</p><p>cout&lt;&lt;endl;</p><p>front(1,n);</p><p>fclose(stdin);fclose(stdout);</p><p>return 0;</p><p>}</p><p class=ql-align-justify><br></p><p class=ql-align-justify>【小結】：拿到一道題目，首先我們要做的是看清題目，判斷這是一道考察什麼算法的題目。只有建立在正確思路基礎下的算法，才是有意義的，正確的算法，也是事半功倍的算法。而此題是批著 樹形 外觀的 非樹形動態規劃題。而真正的樹形動態規劃是在樹上做動態規劃。</p><p class=ql-align-justify></p><p class=ql-align-justify>真正的樹規來了。</p><p><strong>2、二叉蘋果樹</strong></p><p>【題目描述】：</p><p>有一棵蘋果樹，如果樹枝有分叉，一定是分2叉（就是說沒有隻有1個兒子的結點）這棵樹共有N個結點（葉子點或者樹枝分叉點），編號為1-N,樹根編號一定是1。我們用一根樹枝兩端連接的結點的編號來描述一根樹枝的位置。現在這顆樹枝條太多了，需要剪枝。但是一些樹枝上長有蘋果。</p><p>給定需要保留的樹枝數量，求出最多能留住多少蘋果。</p><p>【輸入格式】：</p><p>第1行2個數，N和Q(1&lt;=Q&lt;= N,1&lt;N&lt;=100)。</p><p>N表示樹的結點數，Q表示要保留的樹枝數量。接下來N-1行描述樹枝的信息。</p><p>每行3個整數，前兩個是它連接的結點的編號。第3個數是這根樹枝上蘋果的數量。</p><p>每根樹枝上的蘋果不超過30000個。</p><p>【輸出格式】：</p><p>剩餘蘋果的最大數量。</p><p>input</p><p>5 2</p><p>1 3 1</p><p>1 4 10</p><p>2 3 20</p><p>3 5 20</p><p>output</p><p>21</p><p>【算法&思路】：首先，可以肯定的是，這是一道有關樹規的題目，父節點和子節點存在著相互關聯的階段關係。</p><p>第一步完成。再執行第二步：我們觀察到題目數據量不大,所以有兩種選擇：鄰接矩陣和鄰接表。因為鄰接矩陣的代碼簡單，思路清晰，所以建議能寫鄰接矩陣的時候就不要寫鄰接表了。我們設ma[x][y]為邊的值，因為樹是雙向的，所以要再記錄ma[y][x]。</p><p>設tree[v,1]為節點v的左子樹，tree[v,2]為節點v的右子樹,然後我們再遞歸建樹（因為樹是遞歸定義的，所以很多時候建樹都要考慮遞歸）。</p><p>建樹的問題解決的了，我們就要列狀態轉移方程了。根據求什麼設什麼的原則，我們定義f[i][j]表示以i為節點的根保留k條邊的最大值，那麼f[v][k]=max(f[v][k],(f[tree[v][1]][i]+f[tree[v][2]][k-i-1]+num[v])),我們枚舉i就可以了。正如我開頭提到的。因為樹是遞歸定義的所以我們可以用記憶化搜索的形式（dfs）來具體實現。而樹本身嚴格分層，而且沒有環。所以是不會重複的。</p><p>F[1][Q+1]就是答案。因為題目中給的是邊的權值，而我們在處理時將每條邊的權值全賦給其所連的父節點和子節點中的子節點（將關於邊的問題轉化為關於點的問題），所以最後是Q+1，表示點的數目。</p><p>【代碼】：</p><p>#include&lt;iostream></p><p>#include&lt;iomanip></p><p>#include&lt;cstring></p><p>#include&lt;cstdio></p><p>#include&lt;cmath></p><p>#include&lt;memory></p><p>#include&lt;algorithm></p><p>#include&lt;string></p><p>#include&lt;climits></p><p>#include&lt;queue></p><p>#include&lt;vector></p><p>#include&lt;cstdlib></p><p>#include&lt;map></p><p>using namespace std;</p><p>const int ee=105;</p><p>int n,q;</p><p>int tree[ee][5]={0},ma[ee][ee]={0},num[ee]={0},f[ee][ee]={0};</p><p>void preproccess()</p><p>{</p><p>for(int i=0;i&lt;=n;i++)</p><p>for(int j=0;j&lt;=n;j++)</p><p>{</p><p>ma[i][j]=-1;</p><p>ma[j][i]=-1;</p><p>}</p><p>}</p><p>void maketree(int v);</p><p>void build(int x,int y,int lor)//lor means left or right</p><p>{</p><p>num[y]=ma[x][y];</p><p>tree[x][lor]=y;</p><p>ma[x][y]=-1;ma[y][x]=-1;</p><p>maketree(y);</p><p>}</p><p>void maketree(int v)</p><p>{</p><p>int lr=0;</p><p>for(int i=0;i&lt;=n;i++)</p><p>if(ma[v][i]>=0)//如果分叉了，那麼記錄</p><p>{</p><p>lr++;//1 or 2 表示左支還是右支；</p><p>build(v,i,lr);//存入並遞歸</p><p>if(lr==2) return;</p><p>}</p><p>}</p><p>void dfs(int v,int k)</p><p>{</p><p>if(k==0) f[v][k]=0;</p><p>else if(tree[v][1]==0 && tree[v][2]==0) f[v][k]=num[v];</p><p>else</p><p>{</p><p>f[v][k]=0;</p><p>for(int i=0;i&lt;k;i++)</p><p>{</p><p>if(f[tree[v][1]][i]==0) dfs(tree[v][1],i);</p><p>if(f[tree[v][2]][k-i-1]==0) dfs(tree[v][2],k-i-1);</p><p>f[v][k]=max(f[v][k],(f[tree[v][1]][i]+f[tree[v][2]][k-i-1]+num[v]));</p><p>}</p><p>}</p><p>}</p><p>int main()</p><p>{</p><p>//freopen("in.txt","r",stdin);</p><p>cin>>n>>q;</p><p>preproccess();</p><p>for(int i=0;i&lt;n;i++)</p><p>{</p><p>int x,y,xy;</p><p>scanf("%d%d%d",&x,&y,&xy);</p><p>ma[x][y]=xy;</p><p>ma[y][x]=xy;</p><p>}</p><p>//建樹；</p><p>maketree(1);</p><p>dfs(1,q+1);</p><p>cout&lt;&lt;f[1][q+1];</p><p>fclose(stdin);fclose(stdout);</p><p>return 0;</p><p>}</p><p>【小結】：在樹的存儲結構上，我們一般選的都是二叉樹，因為二叉樹可以用靜態數組來存儲，並且狀態轉移也很好寫（根節點只和左子節點和右子節點有關係）。</p><p>可如果是多叉怎麼辦？ 往下看。</p><p class=ql-align-justify></p><p><strong>3、最大利潤</strong></p><p>【題目描述】</p><p>政府邀請了你在火車站開飯店，但不允許同時在兩個相連接的火車站開。任意兩個火車站有且只有一條路徑，每個火車站最多有50個和它相連接的火車站。</p><p>告訴你每個火車站的利潤，問你可以獲得的最大利潤為多少。</p><p>最佳投資方案是在1，2，5，6這4個火車站開飯店可以獲得利潤為90</p><p>【輸入格式】</p><p>第一行輸入整數N(&lt;=100000)，表示有N個火車站，分別用1，2。。。，N來編號。接下來N行，每行一個整數表示每個站點的利潤，接下來N-1行描述火車站網絡，每行兩個整數，表示相連接的兩個站點。</p><p>【輸出格式】</p><p>輸出一個整數表示可以獲得的最大利潤。</p><p>【樣例輸入】</p><p>6 10</p><p>20</p><p>25</p><p>40</p><p>30</p><p>30</p><p>4 5</p><p>1 3</p><p>3 4</p><p>2 3</p><p>6 4</p><p>【樣例輸出】</p><p>90</p><p>【算法&思路】：</p><p>按照上一題的步驟，我們再來分析一遍：一、是否是動態規劃。這時可能很多人已經吐槽了：閉著眼都知道是動態規劃，不然你粘出來幹什麼？？呵呵，沒錯，確實是。但是為什麼是呢？？首先，這是棵樹，是一棵多叉樹。其次，當我們嘗試著把他向動態規劃上靠時，我們發現當前節點只與其孩子節點的孩子節點（這裡沒打錯，因為隔一個火車站）有關係。所以綜上所述，是動規，還是一個樹規，一個不折不扣的樹規！</p><p>接下來，第二步建樹。看範圍和題目發現，這是一個有著n（&lt;100000）的多叉樹，所以只能用鄰接表存儲了。沒有根，我們一般通常指定1為根。</p><p>第三步：F[i]表示i這條根要，G[i]表示不要（也可以用f[i][1,0]來表示）。然後以此枚舉i的孩子：如果i要了那麼i的孩子就不能要，如果i不要i的孩子就可要可不要（取最大值）即可。最後輸出max（f[1],g[1]）;</p><p>【代碼】：點擊閱讀原文查看</p><p>【小結】：無論是多叉樹還是二叉樹，只要我們把樹以正確的形式建立起來，那麼我們再根據建樹的形式和題目要求，找出孩子和父親之間的關係，那麼狀態轉移方程很容易就求解出來了。多叉其實也不是很難。對麼？呵呵，那麼再看下面一道題：</p><p class=ql-align-justify></p><p><strong>4、選課</strong></p><p>【題目描述】</p><p>學校實行學分制。每門的必修課都有固定的學分，同時還必須獲得相應的選修課程學分。學校開設了N（N&lt;300）門的選修課程，每個學生可選課程的數量M是給定的。學生選修了這M門課並考核通過就能獲得相應的學分。</p><p>在選修課程中，有些課程可以直接選修，有些課程需要一定的基礎知識，必須在選了其它的一些課程的基礎上才能選修。例如《Frontpage》必須在選修了《Windows操作基礎》之後才能選修。我們稱《Windows操作基礎》是《Frontpage》的先修課。每門課的直接先修課最多隻有一門。兩門課也可能存在相同的先修課。每門課都有一個課號，依次為1，2，3，…。</p><p>　你的任務是為自己確定一個選課方案，使得你能得到的學分最多，並且必須滿足先修課優先的原則。假定課程之間不存在時間上的衝突。</p><p>【輸入格式 】Input Format</p><p>輸入文件的第一行包括兩個整數N、M（中間用一個空格隔開），其中1≤N≤300,1≤M≤N。</p><p>以下N行每行代表一門課。課號依次為1，2，…，N。每行有兩個數（用一個空格隔開），第一個數為這門課先修課的課號（若不存在先修課則該項為0），第二個數為這門課的學分。學分是不超過10的正整數。</p><p>【輸出格式】 Output Format</p><p>只有一個數：實際所選課程的學分總數。</p><p>【算法&思路】：</p><p>繼續照著三步的方法判斷：一，題目大致一看，有點像有依賴的揹包問題，於是你扭頭就走，關掉了我的《樹規》，打開了崔神犇的《揹包九講》。然後你哭了，因為有依賴的揹包問題只限定於一個物品只依賴於一個物品，而沒有間接的依賴關係。有依賴的揹包問題的模型，根本解決不了。崔神告訴你，這屬於樹規的問題，不屬於他揹包的範圍了。好了，回過來，我們接著分析。發現這是一棵樹，還是一棵多叉樹，嗯，很好，確定是樹規了。</p><p>然後第二步，建樹，一看數據範圍鄰接矩陣；</p><p>第三步動規方程：f[i][j]表示以i為節點的根的選j門課的最大值，然後有兩種情況： i不修，則i的孩子一定不修，所以為0；i修，則i的孩子們可修可不修（在這裡其實可以將其轉化為將j-1個對i的孩子們進行資源分配的問題，也屬於揹包問題）；答案是f[1][m]。問題圓滿解決，一氣呵成。</p><p>但……</p><p>身為追求完美的苦*程序猿的我們，不可以將它更簡單一點呢？</p><p>多叉轉二叉。</p><p>因為之前我們說過“在樹的存儲結構上，我們一般選的都是二叉樹，因為二叉樹可以用靜態數組來存儲，並且狀態轉移也很好寫（根節點只和左子節點和右子節點有關係）。”所以轉換成二叉樹無疑是一種不錯的選擇。</p><p>我們開兩個一維數組，b[i](brother)&c[i](child)分別表示節點i的孩子和兄弟，以左孩子和右兄弟的二叉樹的形式存儲這樣，根節點之和兩個節點有關係了，狀態轉移的關係少了，代碼自然也就好寫了。</p><p>我們依舊f[i][j]表示以i為節點的根的選j門課的最大值，那麼兩種情況：1.根節點不選修則f[i][j]=f[b[i]][j];2.根節點選修f[i][j]=f[c[i]][k]+f[b[i]][j-k-1]+a[i]（k表示左孩子學了k種課程）;取二者的最大值即可。</p><p>【代碼】：</p><p>【小結】：當題目中的數據結構是多叉樹的時候，我們有兩種選擇：直接在多叉樹上動規，或者轉化為二叉樹後動規。毫無疑問，二叉樹上的動規是簡潔的。但是，並不是說所有的多叉樹都需要轉化，一般情況下，當根節點與孩子節點有著必然的關係時才會轉化。這需要我們多做題目，增加對樹規的感覺才能遊刃有餘。</p><p>我們繼續擴展：如果上一道題目繼續提問，要求輸出所選的方案呢？</p><p><strong>5、選課（輸出方案）</strong></p><p>【題目描述】同上。</p><p>【輸入格式】同上。</p><p>【輸出格式】 Output Format</p><p>第一行只有一個數，即實際所選課程的學分總數。</p><p>以下N行每行有一個數，表示學生所選課程的課號。</p><p>n行學生選課的課號按從小到大的順序輸出。</p><p>【算法&思路】：拿到這道題目，首先我們必然要和上一道題目做一下對比。對比後我們發現，這道題目和上第一道題目完全一樣，除了問題比上一題多一問：輸出方案。所以，我們可以把這道題目分成兩部分：求總數和輸出方案。而求總數的問題我們在上一題中已經很好的解決了，所以這道題目重點是考察的是樹的路徑記錄的問題。</p><p>既然數是遞歸定義的，所以我們依舊使用遞歸的形式來記錄路徑：使用一個bool數組ans來進行遞歸，分兩種情況：取(1)和不取(0)。然後，我們繼續利用已經求得的f[i][j]的值來思考如何找到路徑：首先定義一個path()函數。如果f[i][j]=f[b[i]][j],那麼節點i必然沒有取，讓ans[i]=0;否則，節點i一定取到了。（為什麼呢？其實，這是依照第一問的dfs來思考的，第一問的dfs是這樣定義的，所以我們就這樣考慮了。）然後依照上一問，if(f[x][y]==f[b[x]][k-1]+f[c[x]][y-k]+s[x])，那麼我們在i節點後選的一定是以上的方案，在這時讓ans[i]=1,繼續深搜path()即可。最後從1到n依次輸出取到的點即可。</p><p class=ql-align-justify><br></p><p>【小結】：路徑輸出的問題，在不同的題目中有不同的解法，比如說邊求值邊記錄等等，而在樹規中，利用動規和樹的特點，求解完後再原路返回找一遍，是一種比較容易想到且容易操作的性價比比較高的算法。</p><p><strong>6、軟件安裝</strong></p><p>【題目描述】：</p><p>現在我們的手頭有N個軟件，對於一個軟件i，它要佔用Wi的磁盤空間，它的價值為Vi。我們希望從中選擇一些軟件安裝到一臺磁盤容量為M的計算機上，使得這些軟件的價值儘可能大（即Vi的和最大）。</p><p>但是現在有個問題：軟件之間存在依賴關係，即軟件i只有在安裝了軟件j（包括軟件j的直接或間接依賴）的情況下才能正確工作（軟件i依賴軟件j）。幸運的是，一個軟件最多依賴另外一個軟件。如果一個軟件不能正常工作，那麼他能夠發揮的作用為0。</p><p>我們現在知道了軟件之間的依賴關係：軟件i依賴Di。現在請你設計出一種方案，安裝價值儘量大的軟件。一個軟件只能被安裝一次，如果一個軟件沒有依賴則Di=0，這是隻要這個軟件安裝了，它就能正常工作。</p><p>【輸入格式】：</p><p>第1行：N,M （0&lt;=N&lt;=100,0&lt;=M&lt;=500）</p><p>第2行：W1,W2, … Wi, … ,Wn</p><p>第3行：V1,V2, … Vi, … ,Vn</p><p>第4行：D1,D2, … Di, … ,Dn</p><p>【輸出格式】：</p><p>一個整數，代表最大價值。</p><p>【樣例】</p><p>3 10</p><p>5 5 6</p><p>2 3 4</p><p>0 1 1</p><p>5</p><p>【算法&思路】：同樣，這道題目類似與第4題，是一個依賴的問題，毫無疑問是一道動態規劃，但是它確實是樹規麼？我們來想這樣一組數據，1依賴2，2依賴3,3依賴1。這樣符合題目要求，但有形成了環，所以不是一棵樹了。但是根據題目，這樣特殊的情況，要麼全要，要麼全就不要。所以，事實上我們可以將這個環看成一個點再來動規，即縮點。如何判斷是否是一個環呢，依照數據範圍，我們想到了floyed（弗洛裡德），這是在這種數據範圍內性價比最高的方式。最後樹規。於是一個比較清晰的步驟就出來了：判環，縮點，樹規。</p><p>接下來是細節：首先存樹，毫無疑問，是鄰接矩陣。</p><p>做floyed。如果兩點之間mapp[i][j]中有另一條路徑相連，即mapp[i][k]=1 && mapp[k][j]=1(1表示兩點是通的);那麼mapp[i][j]也是通的且是環。</p><p>縮點。這個是最麻煩的，麻煩在於我們要把縮的點當成一個新點來判斷，而且要判斷某個點是否在某個環裡。我們用染色法來判斷，用所佔的空間w控制顏色的對應，有以下三種情況：1、點i所在的環之前沒有判斷過，是新環。那麼，我們將這個新環放到數組最後，即新加一個點，然後讓這兩個點的空間標記為負值tmpw，且tmpw+tmpn（新點的下標）等於原來的點數，這樣，我們就可以通過某個點的空間迅速找到他所在的新點。像鑰匙一樣一一對應；2、點i所在的環之前已經判斷過了，是舊環（已合成新點），且i是環的一部分。那麼我們就把i也加到這個新點裡面，即體積，價值相加即可；3、點j所在的環是舊環，但是i不是環的一部分（例如1依賴2，2依賴3,3依賴1。4也依賴1，那麼，4所在的是個環，但4不屬於環的一部分）。那麼，把j的父親轉到新點上d[j]= n-w[d[j]]。</p><p>以上縮點的工作做完之後，剩下的就是一棵樹。就可以在這上面動規了：先將其轉換成一棵左孩子右兄弟的二叉樹，之後記憶化。i的孩子不取</p><p>f[b[x]][k]=dfs(b[x],k);還是取：f[c[x]][y-i]=dfs(c[x],y-i); f[b[x]][i]=dfs(b[x],i); f[x][k]=max(f[x][k],v[x]+f[c[x]][y-i]+f[b[x]][i]);</p><p>最後答案是f[c[0]][m]。</p><p>【代碼】：見原文</p><p>【小結】：依賴問題的變化很多，比如基本樹規，記錄路徑，有環等等。但是他們都有一些共同的特點，比如說記憶化的方程差不多。根據題目，我們應該會判斷給的數據是否是圖，是樹，能想出特殊情況。樹畢竟是圖的一種特殊形式，而二叉樹又是樹的一種特殊形式。如果能將一個問題由複雜向簡單轉換，那麼我們不僅思路會清晰很多，代碼量也會少很多。下面一道題目，就是我們所說的很少見的根節點向葉子節點動規的問題。</p><p>【清北信息學總結】：樹規是動態規劃的一種，它將樹和動態規劃很巧妙地結合在了一起。做樹規題目，不僅僅鍛鍊了我們的代碼能力，而且加深了我們對動態規劃的理解。再次強調，樹的遞歸定義使樹規多以記憶化的形式來寫，而由於樹的嚴格分層，使動規的階段自然就清晰了起來，多找一找父節點與子節點的關係，就是很可能是兩個階段之間的聯繫。</p><p><strong>定期推送帳號信息學新聞，競賽自主招生，信息學專業知識，信息學疑難解答，信息學訓練營信息等諸多優質內容的wx公眾平臺noipnoi</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>動態</a></li><li><a>規劃</a></li><li><a>NOIP2018</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5b7f2a6.html alt=動態規劃基礎篇之最長公共子序列問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534911245031e5c09c7696 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5b7f2a6.html title=動態規劃基礎篇之最長公共子序列問題>動態規劃基礎篇之最長公共子序列問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html alt=動態網站和靜態網站有什麼區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6a06f21d115b4b93a7934a7075691503 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e39c08d7.html title=動態網站和靜態網站有什麼區別>動態網站和靜態網站有什麼區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/74d576ca.html alt=動態交聯重組實現了碳納米管在交聯彈性體中的單軸拉伸取向 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8d28c195508f40acbe0e107477931021 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/74d576ca.html title=動態交聯重組實現了碳納米管在交聯彈性體中的單軸拉伸取向>動態交聯重組實現了碳納米管在交聯彈性體中的單軸拉伸取向</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04956a1d.html alt=「公司動態」預應力筋張拉及伸長量計算培訓總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/51a2b4b5f4184c66b6668b1cc17bc1a1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04956a1d.html title=「公司動態」預應力筋張拉及伸長量計算培訓總結>「公司動態」預應力筋張拉及伸長量計算培訓總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d496328.html alt=動態離子交聯在單彈性體中實現高強度和超拉伸性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526724728439d708761d54 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d496328.html title=動態離子交聯在單彈性體中實現高強度和超拉伸性>動態離子交聯在單彈性體中實現高強度和超拉伸性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html alt=C++中的多態（動態多態）究竟是如何實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/30cae7ea5f5647deba7c518ed4e1a91b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb808de3.html title=C++中的多態（動態多態）究竟是如何實現>C++中的多態（動態多態）究竟是如何實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/790fbad0.html alt=多態&動態綁定&方法匹配&方法綁定 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1533542565759f64e623e74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/790fbad0.html title=多態&動態綁定&方法匹配&方法綁定>多態&動態綁定&方法匹配&方法綁定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60ee6ccb.html alt=廣西規劃建設的高鐵，五縱五橫鐵路線裡有經過你的家鄉嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/acab8d5762c84bff8072eb01fe0a880a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60ee6ccb.html title=廣西規劃建設的高鐵，五縱五橫鐵路線裡有經過你的家鄉嗎？>廣西規劃建設的高鐵，五縱五橫鐵路線裡有經過你的家鄉嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e617c02.html alt=廣西規劃至廣東的高鐵，投資172億元，這8城幸運了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/23e77c95a24841cc9acd7375cd29c16b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e617c02.html title=廣西規劃至廣東的高鐵，投資172億元，這8城幸運了>廣西規劃至廣東的高鐵，投資172億元，這8城幸運了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea27a346.html alt=廣西鐵路建設“十三五”規劃（2018修編版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8bb8b979db844da2a12e1559e238b8c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea27a346.html title=廣西鐵路建設“十三五”規劃（2018修編版）>廣西鐵路建設“十三五”規劃（2018修編版）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bfaf8bd4.html alt=渦輪蝸桿的原理動態圖，機械工程師的最愛 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f53baad5340446848291d7f510aa2de5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bfaf8bd4.html title=渦輪蝸桿的原理動態圖，機械工程師的最愛>渦輪蝸桿的原理動態圖，機械工程師的最愛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/58a705d6.html alt=一個多月不更新動態，肖戰仍然是頂流明星，三組數據顯示想糊都難 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d3dc084790a34780b65cd3a4a62c3253 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/58a705d6.html title=一個多月不更新動態，肖戰仍然是頂流明星，三組數據顯示想糊都難>一個多月不更新動態，肖戰仍然是頂流明星，三組數據顯示想糊都難</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a8b411e.html alt=物理技巧，閉合電路動態分析及功率計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e6cb6416170340d7862e56485242c717 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a8b411e.html title=物理技巧，閉合電路動態分析及功率計算>物理技巧，閉合電路動態分析及功率計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd1ae73b.html alt=動態圖為您講解液壓系統，液壓泵和液壓缸工作原理！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/810c6760d8ad490a9e7e074cae715e4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd1ae73b.html title=動態圖為您講解液壓系統，液壓泵和液壓缸工作原理！>動態圖為您講解液壓系統，液壓泵和液壓缸工作原理！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/06f4f762.html alt=豐田C-HR動態測試，靜謐性較差，其它方面表現如何？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153924800228122cba4f520 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/06f4f762.html title=豐田C-HR動態測試，靜謐性較差，其它方面表現如何？>豐田C-HR動態測試，靜謐性較差，其它方面表現如何？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>