<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>​mysql AB 複製技術(主從),曉桂科技分享mysql_04/06 | 极客快訊</title><meta property="og:title" content="​mysql AB 複製技術(主從),曉桂科技分享mysql_04/06 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1f6b6fd4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1f6b6fd4.html><meta property="article:published_time" content="2020-10-29T21:09:57+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:57+08:00"><meta name=Keywords content><meta name=description content="​mysql AB 複製技術(主從),曉桂科技分享mysql_04/06"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1f6b6fd4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>​mysql AB 複製技術(主從),曉桂科技分享mysql_04/06</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>下面繼續分享沒有生氣了數據庫1-6節課，之04</p><p>mysql AB 複製技術(主從)<br></p><p>MySQL支持單向、異步(async)複製，複製過程中一個服務器充當主服務器，而一個或多個其它服務器充當從服務器。</p><p>同步複製需要使用ndbcluster(各集群節點都可讀可寫)或者drbd(網絡raid)這些技術，或者是新版mysql的半同步複製</p><p>mysql主 - - > mysql從</p><p>master slave</p><p>把主上的二進制日誌(bin-log)的內容傳到從上的一個新的日誌叫relay-bin-log</p><p>從上的 IO 線程 負責傳輸</p><p>從上的 SQL 線程 負責從服務器解析日誌</p><p>複製的過程：</p><p>1，slave端的IO線程連上master端，請求</p><p>2，master端返回給slave端，bin log文件名和位置信息</p><p>3，IO線程把master端的bin log內容依次寫到slave端relay bin log裡，並把master端的bin-log文件名和位置記錄到master.info裡。</p><p>4，salve端的sql線程，檢測到relay bin log中內容更新，就會解析relay log裡更新的內容，並執行這些操作；也就是說salve執行和master一樣的操作而達到數據同步的目的；</p><p>客戶</p><p>｜</p><p>｜</p><p>web程序，遊戲程序（c,php,java.......)</p><p>|</p><p>|</p><p>代理層 (mysqlproxy,amoeba)</p><p>|</p><p>|</p><p>mysql主 ----> mysql從</p><p>思考：</p><p>1，主要打開二進制日誌，從要不要開二進制日誌?</p><p>從mysql可開可不開，要看情況</p><p>2，主和從的讀寫情況怎麼做？</p><p>從不能寫，從只能讀；主可讀可寫；</p><p>所以有些時候做主只寫，從只讀，也就是讀寫分離</p><p>3，我做了讀寫分離的一主一從的架構，請問我前端的程序(web,遊戲,業務等)如何來訪問數據庫</p><p>如果裝前端web（假設phpwind)，填寫數據庫的IP為主的IP，那麼這種情況，</p><p>mysql從就完全變成了一個實時備份的服務器，所有的讀寫全在主上</p><p>所以要在前端程序和數據庫之間加入代理層程序，也就是填寫的數據庫IP不是主的也不是從的，</p><p>而是代理的，由代理來負責把寫操作給主，讀操作給從</p><p>4，關於單點故障的問題,如果從掛掉了，怎麼解決？如果主掛掉了，怎麼解決?</p><p>從掛掉了，那麼主就要負責讀和寫的所有操作，由代理層幫你實現操作的轉換。從修好後，直接啟動，然後就自動讀寫分離，還是代理層自動實現操作轉換.</p><p>主掛掉了（假設掛掉一個小時)，那麼寫操作肯定需要有人來做，只能是mysql從服務器來負責讀和寫操作。主修好啟動後，寫操作可以再給回主，但是從在這一小時內寫的操作如何給主?(這裡就比較麻煩，後面講雙主架構再討論)</p><p>關於另幾種架構的探討：</p><p>一主多從</p><p>－－> salve</p><p>master －－> salve</p><p>－－> salve</p><p>寫 讀</p><p>--適合於以讀為主的業務，使用多個salve分擔讀的壓力，但要注意的是這種架構，salve越多，那麼master複製的壓力就越大</p><p>------------------------------------------------</p><p>多主一從 --這種架構不支持</p><p>主A phpwind</p><p>從C</p><p>主B discuz</p><p>------------------------------------------------</p><p>雙主架構 master A &lt;－－> master B</p><p>phpwind discuz</p><p>1，會循環複製嗎？</p><p>他們不會循環複製，因為做複製時會指定ID值，並且不一致</p><p>2，兩邊真的能同時寫相同的數據嗎?</p><p>不可以</p><p>如下表所示：</p><p>時間點 master A master B</p><p>1 a＝1改為a=2</p><p>2 a=1改為a=3</p><p>3 a的改變複製過來,並解析,a會又改為2</p><p>4 b的改變複製過來並解析,a又會改為3</p><p>問題產生，數據不一致</p><p>3，兩邊可以寫不同的數據嗎？</p><p>可以</p><p>可以通過業務程序層，指定一些表的寫操作全在一端，另一些表的寫操作全在另一端，也就是說兩邊不會同時寫相同的表（當然這是理想狀態，因為業務複雜的話會有表的聯結等情況）</p><p>然後通過指定mysql複製的參數，一部分表或庫會從A複製到B，另外一部分表或庫從B複製到A就可以避免上面的問題了</p><p>或者兩個庫，一個庫master A來寫，另一個庫master B來寫</p><p>數據切分</p><p>----------------------------</p><p>前面三個問題也說明了雙主架構的第一種應用（就是兩邊寫不關聯的數據，互相複製)，雙主架構的第二種應用就是解決一主一從架構裡主掛掉了的問題。</p><p>看下面的分析</p><p>mysql主 mysql從</p><p>思考：</p><p>問題1:如果一主一從，主掛了，slave能不能寫，如果能寫，主修好啟起來後，salve寫的數據如何傳回給主?</p><p>答案:主掛了，slave應該要寫，否則論壇不能發貼，只能看貼；</p><p>主修好後（假設一小時)，slave寫了這一小時的數據應該要想辦法傳回主才行。</p><p>方法一：DBA人為的把salve這一小時寫的數據找出來再導入到主(如果很多表，一小時的操作也非常多，可以說幾乎不可能找出這小時改變了啥）</p><p>方法二：使用類似rsync的同步方法,這是通過存儲層來實現數據同步回去，但效果沒有驗證過，無法說明</p><p>方法三:DBA人為的把從這一小時改變的二進制日誌（要確認slave打開二進制日誌)給找出來然後應用到主上去</p><p>問題2:上面的方法無論哪一種都會有一個問題，就是把從寫的一小時數據傳回給主需要一定的時間</p><p>就是假設這一小時slave創建了一個aaa表，主mysql修好啟動後，</p><p>如果主馬上接管從的寫功能，這時前端程序馬上給了一個insert into aaa的插入操作，這樣肯定會出問題，因為創建aaa表的操作還沒有從slave那傳回來,如何解決?</p><p>解決方法一:人為控制主現在不能寫，等slave的數據傳回來後再寫；但這樣的話，等待時間太長了</p><p>解決方法二:就是把一主一從的架構改成雙主的架構（假設master A和master B)</p><p>master A ---> master B (平時主B只讀，不寫，只有到主A掛了，才會寫)</p><p>掛一個小時</p><p>讀寫一個小時</p><p>修復後啟動了</p><p>把讀給A 寫留給B</p><p>問題3:但是改成雙主後，master B在master A掛掉的一小時內幫他寫了數據，A修好啟起來後，B的數據可以自動傳回A；但是如果數據量大的話，這個傳回也可能需要一定時間，如果正好在這個傳回時間內也出現了問題2的情況，又如何解決?</p><p>解決方法一:人為控制主不能寫，這樣的話等待時間很短（因為是自動傳回來，跟手動導回來速度快很多)，影響不大</p><p>解決方法二:就直接把master B 做為新的寫服務器，master A啟動後，也只是做為讀服務器；除非等下一次B掛了，A會重新成為寫服務器（當然這是在兩臺服務器性能相等的情況下)</p><p>總結:上面說明雙主架構的兩種應用</p><p>-------------------------------------------------－－－－－</p><p>master C</p><p>| |</p><p>環型架構 master A －－ master B</p><p>--不可行</p><p>------------------------------------------------------</p><p>－－ salve －－ salve</p><p>級聯架構 master －－ salve －－ salve</p><p>－－ salve －－ salve</p><p>bin-log bin-log ?</p><p>為了解決一主多從的master的複製壓力</p><p>可以把slave做為下一級從機的master</p><p>增加複製的級聯層次，造成的延遲更長</p><p>所以這種架構並不是很推薦，一般會進行分拆集群</p><p>--------------------------------------------------</p><p>雙主和級聯合起來</p><p>master ----salve --slave</p><p>|</p><p>| －－ slave</p><p>master －－ salve －－ slave</p><p>－－ slave</p><p>------------------------------------------------------</p><p>優化原則:分</p><p>大型結構的數據量太大，要用到數據切分(水平，垂直)</p><p>mysqlproxy</p><p>amoeba</p><p>---------------------------------------------------------</p><p>AB複製前準備</p><p>把兩臺mysql啟起來（要求兩臺數據一致)</p><p>/etc/hosts裡都加上主機名和IP對應，</p><p>時間同步好</p><p>防火牆,selinux檢查一下</p><p>yum配置</p><p>mysql AB複製開始搭建</p><p>1,主從數據必須要同步</p><p>2,主：要啟用二進制日誌</p><p>3,主和從都要設置 server-id值，並且兩邊要不一樣</p><p>4,需要建立一個用來複制的用戶，並授於相應權限</p><p>master －－ slave</p><p>2.2.2.128 2.2.2.129</p><p>用rpm版的mysql來做：</p><p>第一步；改配置文件</p><p>master,2.2.2.128 上添加2行</p><p>vim /etc/my.cnf</p><p>［mysqld] --在mysqld參數組下添加2行</p><p>log-bin=mysql-bin --指定二進制日誌的名字</p><p>server-id=2 --指定id，id值任意</p><p>slave,2.2.2.129 上添加1行</p><p>vim /etc/my.cnf</p><p>[mysqld] --在mysqld參數組下添加1行</p><p>server-id=3 --指定id，id值任意，與主不一樣</p><p>然後重啟服務</p><p>master,2.2.2.128 上重啟：</p><p>/etc/init.d/mysqld restart</p><p>slave,2.2.2.129 上重啟：</p><p>/etc/init.d/mysqld restart</p><p>第二步：授權</p><p>在master上做授權,super和replication slave都是複製要用的權限</p><p>mysql> grant super,replication slave on *.* to 'slave1'@'2.2.2.129' identified by '123';</p><p>用戶@從的ip，允許從的ip連接主</p><p>mysql> flush privileges;</p><p>在slave上最好使用剛才授權的用戶是遠程登錄一下主去驗證一下</p><p># mysql -u slave1 -h 2.2.2.128 -p</p><p>第三步：查看master的正在寫的二進制文件名和位置</p><p>mysql> flush tables with read lock; --先加鎖，防止兩邊數據不一致;如果業務還未上線，這個就沒有必要了</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>mysql> show master status; --只有打開二進制日誌，這句命令才有結果，表示當前數據庫的二進制日誌寫到什麼位置</p><p>+------------------+----------+--------------+------------------+</p><p>| File | Position | Binlog_Do_DB | Binlog_Ignore_DB |</p><p>+------------------+----------+--------------+------------------+</p><p>| mysql-bin.000003 | 336 | | |</p><p>+------------------+----------+--------------+------------------+</p><p>二進制文件名 正在寫入的位置</p><p>slave端的配置</p><p>mysql> slave stop; --如果沒有啟過slave，這一步也是非必要的</p><p>Query OK, 0 rows affected, 1 warning (0.00 sec)</p><p>mysql> stop slave; --mysql5.6</p><p>Query OK, 0 rows affected, 1 warning (0.00 sec)</p><p>mysql> show warnings;</p><p>+-------+------+--------------------------------+</p><p>| Level | Code | Message |</p><p>+-------+------+--------------------------------+</p><p>| Note | 1255 | Slave already has been stopped |</p><p>+-------+------+--------------------------------+</p><p>mysql> change master to</p><p>-> master_user='slave1',</p><p>-> master_password='123',</p><p>-> master_host='2.2.2.128', --主的IP</p><p>-> master_port=3306, --端口，如果為3307就要換成3307</p><p>-> master_log_file='mysql-bin.000003', --主上面查到的文件名</p><p>-> master_log_pos=336; --主上面查到的位置號</p><p>mysql > mysql -u slave1 -h 2.2.2.128 -p123</p><p>mysql> change master to master_user='slave1', master_password='123', master_host='2.2.2.128', master_port=3306, master_log_file='mysql-bin.000003', master_log_pos=336;</p><p>mysql> start slave;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>mysql> show slave status\G</p><p>*************************** 1. row ***************************</p><p>Slave_IO_State: Waiting for master to send event</p><p>Master_Host: 2.2.2.128</p><p>Master_User: li</p><p>Master_Port: 3306</p><p>Connect_Retry: 60</p><p>Master_Log_File: mysql-bin.000001</p><p>Read_Master_Log_Pos: 681</p><p>Relay_Log_File: mysql55-relay-bin.000002</p><p>Relay_Log_Pos: 253</p><p>Relay_Master_Log_File: mysql-bin.000001</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: Yes --這裡兩個YES，表示兩個線程OK</p><p>Replicate_Do_DB:</p><p>Replicate_Ignore_DB:</p><p>Replicate_Do_Table:</p><p>Replicate_Ignore_Table:</p><p>Replicate_Wild_Do_Table:</p><p>Replicate_Wild_Ignore_Table:</p><p>Last_Errno: 0</p><p>Last_Error:</p><p>Skip_Counter: 0</p><p>Exec_Master_Log_Pos: 681</p><p>Relay_Log_Space: 411</p><p>Until_Condition: None</p><p>Until_Log_File:</p><p>Until_Log_Pos: 0</p><p>Master_SSL_Allowed: No</p><p>Master_SSL_CA_File:</p><p>Master_SSL_CA_Path:</p><p>Master_SSL_Cert:</p><p>Master_SSL_Cipher:</p><p>Master_SSL_Key:</p><p>Seconds_Behind_Master: 0</p><p>Master_SSL_Verify_Server_Cert: No</p><p>Last_IO_Errno: 0</p><p>Last_IO_Error:</p><p>Last_SQL_Errno: 0</p><p>Last_SQL_Error:</p><p>Replicate_Ignore_Server_Ids:</p><p>Master_Server_Id: 2</p><p>1 row in set (0.00 sec)</p><p>...................................</p><p>回到master端解鎖：</p><p>mysql> unlock tables;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>進行測試：</p><p>1，先比較主，從的數據目錄文件的不同</p><p># ls /var/lib/mysql/ --master</p><p>ibdata1 ib_logfile1 mysql-bin.000001 mysql-bin.000003 mysql.sock</p><p>ib_logfile0 mysql mysql-bin.000002 mysql-bin.index test</p><p># ls /var/lib/mysql/ --slave</p><p>ibdata1 ib_logfile1 mysql mysqld-relay-bin.000002 mysql.sock test</p><p>ib_logfile0 master.info mysqld-relay-bin.000001 mysqld-relay-bin.index relay-log.info</p><p># cat /var/lib/mysql/master.info</p><p># cat /var/lib/mysql/relay-log.info</p><p># mysqlbinlog /var/lib/mysql/mysqld-relay-bin.000002</p><p>驗證2：只有master寫，slave可以看到</p><p>slave寫，master看不到</p><p>如果複製出現問題</p><p>（要模擬問題的話，在從上創建一個庫，然後在主上也創建這個庫，就會衝突，造成複製出現問題），</p><p>重做複製集群只需要重新在從上執行stop slave; change master to ...... ; start slave;</p><p>驗證3：把從重啟後，再上去查看狀態，還是連接的，沒什麼影響</p><p>把主重啟後，再去slave上去查看狀態，發現重試時間為60秒，等60秒後又自動連接OK了</p><p>--如果想要改這個60秒的話，可以把從服務器上的master.info文件裡的60直接改成30(rpm版測試有點問題)</p><p>------------------------------------------------------------</p><p>一主多從的做法</p><p>就是上面的步驟有幾個從就做幾次</p><p>-------------------------------------------------------------------</p><p>雙主架構的做法：</p><p>在上面的slave機也打開二進制日誌，反著做一遍就行，注意做的過程中，保證數據一致</p><p>做好的架構，只要兩邊不同時操作相同的數據，就不會出現複製不一致的問題；</p><p>或者是在業務程序層，將一部分的寫操作定義到master A,另一部分的寫操作定義到master B</p><p>-------------------------------------------------------------</p><p>級聯架構</p><p>master -slave -slave</p><p>把中間的從也要打開二進制日誌。但是它默認不把應用master的操作記錄到自己的二進制日誌。所以需要打開一個參數讓它記錄，才可以傳給第三級的從</p><p># /usr/local/mysql/bin/mysqld --verbo --help |grep log-slave</p><p>--log-slave-updates Tells the slave to log the updates from the slave thread</p><p>--log-slave-updates is used.</p><p>log-slave-updates FALSE</p><p>--默認值為false，所以需要在配置文件里加上log-slave-updates=1，然後重啟服務</p><p>所以打開中間從的配置文件</p><p># vim /usr/local/mysql/etc/my.cnf --加上下面兩句，然後重啟服務</p><p>log-bin=mid-slave</p><p>log-slave-updates=1</p><p>然後在中間從和第三級的從之間再做一次AB複製就可以了</p><p>我的結構圖</p><p>master A slave B slave C</p><p>2.2.2.128 2.2.2.129 2.2.2.130</p><p>sever-id=2 server-id=3 server-id=4</p><p>log-bin=mysql-bin-128 log-bin=mysql-bin-129</p><p>log-slave-updates=1</p><p>bin-log relay-bin-log relay-bin-log</p><p>bin-log ------> relay-bin-log</p><p>打開log-slave-updates=1</p><p>讓第一臺傳過來relay日誌記錄</p><p>到自己的二進制日誌</p><p>bin-log -------> relay-bin-log</p><p>==============================================================</p><p>關於控制複製的庫和表的相關參數討論：</p><p>Replicate_Do_DB: --接受哪個庫的複製</p><p>Replicate_Ignore_DB: --忽略哪個庫的複製</p><p>Replicate_Do_Table: --接受哪個表的複製</p><p>Replicate_Ignore_Table: --忽略哪個表的複製</p><p>Replicate_Wild_Do_Table: --通配符表示複製哪些表</p><p>Replicate_Wild_Ignore_Table: --通配符表示忽略哪些表</p><p>實例說明：</p><p>master A slave B</p><p>1，先把兩臺做成ab複製的架構</p><p>2，在master a上創建aaa庫及其裡面的aaa表，bbb庫及其裡面的bbb表</p><p>那麼slave b裡也會複製產生這兩張測試表</p><p>3，現在的業務需求是：</p><p>我在slave b上要求複製的為aaa庫裡所有表；bbb庫及其所有表不要求複製過去</p><p>4，在slave b的my.cnf配置文件的[mysqld]參數組裡加上</p><p>replicate_do_db=aaa --只接受aaa庫的複製</p><p>replicate_ignore_db=bbb --忽略bbb庫的複製</p><p>5，重啟slave b，然後測試</p><p>測試結果為</p><p>在master a上操作：</p><p>use aaa;</p><p>insert into aaa values ....;</p><p>slave b上可以看到insert的記錄 --OK</p><p>在master a 上操作：</p><p>use bbb;</p><p>insert into bbb values ....;</p><p>slave b上看不到insert的記錄 --OK；但這裡的操作還是會記錄到slave b的relay-bin-log裡</p><p>在master a上操作：</p><p>use bbb;</p><p>insert into aaa.aaa values ....;</p><p>slave b上卻看不到insert的操作 --有問題</p><p>--原因是：它默認只會複製在aaa庫下對它下面的表的操作；而別的庫下對aaa庫下表的操作會忽略</p><p>6，解決方法：</p><p>在slave b上把第4步做的兩個參數換成下面兩個</p><p>replicate_wild_do_table=aaa.%</p><p>replicate_wild_ignore_table=bbb.%</p><p>再把slave b重啟；就不會出現剛才的問題了</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>搭建環境 兩臺虛擬機</p><p>master －－ slave</p><p>先安裝mysql5.5之後的版本，因為這個版本之後才實現的半同步複製</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>MySQL的複製其實是異步操作，而不是同步，也就意味著允許主從之間的數據存在一</p><p>定的延遲，mysql當初這樣設計的目的也是基於可用性的考慮，為了保證master</p><p>不受slave的影響，並且異步複製使得master處於一種性能最優的狀態：</p><p>寫完binlog後即可提交而不需要等待slave的操作完成。這樣存在一個隱患，當你使用slave作為備份時，</p><p>如果master掛掉，那麼會存在部分已提交的事務未能成功傳輸到slave的可能，這就意味著數據丟失！</p><p>所謂的半同步複製就是master每commit一個事務,要slave應用這個事物後回給master信號。這樣master才能把事物成功commit。這樣就保證了master-slave的數據絕對的一致（但是以犧牲master的性能為代價).但等待時間也是可以調整的。</p><p>mysql半同步複製等待時間超時後(默認時間為10秒)，會自動轉換成異步複製</p><p>--下面的步驟用5.6.26版測試是一樣的做法</p><p>（注意5.6.x版本默認以mysql@localhost登錄的，你要-u root來指定以root@localhost登錄就可以了)</p><p>搭建好 mysqlAB異步複製後</p><p>在master上安裝這個插件</p><p>master> install plugin rpl_semi_sync_master soname 'semisync_master.so';</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>--刪除插件的方法 mysql > uninstall plugin rpl_semi_sync_master;</p><p>master> show global variables like 'rpl_semi_sync%'; --安裝OK後，主上會多幾個參數</p><p>+------------------------------------+-------+</p><p>| Variable_name | Value |</p><p>+------------------------------------+-------+</p><p>| rpl_semi_sync_master_enabled | OFF | --是否啟用master的半同步複製</p><p>| rpl_semi_sync_master_timeout | 10000 | --默認主等待從返回信息的超時間時間，10秒。</p><p>| rpl_semi_sync_master_trace_level | 32 | --監控</p><p>| rpl_semi_sync_master_wait_no_slave | ON | --是否允許每個事物的提交都要等待slave的信號.on為每一個事物都等待</p><p>+------------------------------------+-------+</p><p>在slave上安裝插件</p><p>slave> install plugin rpl_semi_sync_slave soname 'semisync_slave.so';</p><p>Query OK, 0 rows affected (0.03 sec)</p><p>slave> show global variables like 'rpl_semi_sync%';</p><p>+---------------------------------+-------+</p><p>| Variable_name | Value |</p><p>+---------------------------------+-------+</p><p>| rpl_semi_sync_slave_enabled | OFF |</p><p>| rpl_semi_sync_slave_trace_level | 32 |</p><p>+---------------------------------+-------+</p><p>master上激活半同步複製</p><p>master> set global rpl_semi_sync_master_enabled =on;</p><p>Query OK, 0 rows affected (0.00 sec)</p><p>slave上激活半同步複製</p><p>slave> set global rpl_semi_sync_slave_enabled=on;</p><p>slave> stop slave IO_THREAD;</p><p>slave> start slave IO_THREAD;</p><p>在master查看狀態</p><p>master > show global status like 'rpl_semi_sync%';</p><p>+--------------------------------------------+-------+</p><p>| Variable_name | Value |</p><p>+--------------------------------------------+-------+</p><p>| Rpl_semi_sync_master_clients | 1 | --有一個從服務器啟用半同步複製</p><p>| Rpl_semi_sync_master_net_avg_wait_time | 0 | --master等待slave回覆的平均等待時間。單位毫秒</p><p>| Rpl_semi_sync_master_net_wait_time | 0 | --master總的等待時間。單位毫秒</p><p>| Rpl_semi_sync_master_net_waits | 0 | --master等待slave回覆的總的等待次數</p><p>| Rpl_semi_sync_master_no_times | 0 | --master關閉半同步複製的次數</p><p>| Rpl_semi_sync_master_no_tx | 0 | --master 等待超時的次數</p><p>| Rpl_semi_sync_master_status | ON | --標記master現在是否是半同步複製狀態</p><p>| Rpl_semi_sync_master_timefunc_failures | 0 | --master調用時間（如gettimeofday())失敗的次數</p><p>| Rpl_semi_sync_master_tx_avg_wait_time | 0 | --master花在每個事務上的平均等待時間</p><p>| Rpl_semi_sync_master_tx_wait_time | 0 | --master花在事物上總的等待時間</p><p>| Rpl_semi_sync_master_tx_waits | 0 | --master事物等待次數</p><p>| Rpl_semi_sync_master_wait_pos_backtraverse | 0 | --後來的先到了，而先來的還沒有到的次數</p><p>| Rpl_semi_sync_master_wait_sessions | 0 | --當前有多少個session因為slave回覆而造成等待</p><p>| Rpl_semi_sync_master_yes_tx | 0 | --標記slave是否在半同步狀態</p><p>+--------------------------------------------+-------+</p><p>在slave上查看狀態就只有下面一條信息</p><p>slave > show global status like 'rpl_semi_sync%';</p><p>+----------------------------+-------+</p><p>| Variable_name | Value |</p><p>+----------------------------+-------+</p><p>| Rpl_semi_sync_slave_status | ON |</p><p>+----------------------------+-------+</p><p>測試：</p><p>master > insert into a values (3);</p><p>Query OK, 1 row affected (0.01 sec)</p><p>master > show global status like 'rpl_semi_sync%_yes_tx';</p><p>+-----------------------------+-------+</p><p>| Variable_name | Value |</p><p>+-----------------------------+-------+</p><p>| Rpl_semi_sync_master_yes_tx | 1 | --表示這次事物成功從slave返回一次確認信號</p><p>+-----------------------------+-------+</p><p>模擬錯誤，把slave上的mysql停掉/etc/init.d/mysql56 stop</p><p>--再回到master上測試</p><p>master> insert into a values (4);</p><p>Query OK, 1 row affected (10.00 sec) --這次插入一個值需要等待10秒（默認的等待時間)</p><p>master> insert into a values (5);</p><p>Query OK, 1 row affected (0.01 sec) --現在自動轉成了原來的異步模式（類似oracle DG裡的最大性能模式)</p><p>再次把slave啟動，看到半同步複製沒啟來，是異步模式</p><p>重新按下面的步驟把同步模式再啟起來就可以了</p><p>slave> set global rpl_semi_sync_slave_enabled=on;</p><p>slave> stop slave IO_THREAD;</p><p>slave> start slave IO_THREAD;</p><p>slave啟起來後，查看錶，發現剛才slave關閉期間的那幾條數據還是會自動複製過來，數據又回到一致</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>mysql的延時複製</p><p>異步或同步複製</p><p>A ----------> B</p><p>|</p><p>|-------> C</p><p>延時1天</p><p>假設在A上誤刪除一條數據，用二進制日誌來恢復不太方便，因為日誌裡記錄的是刪除的操作，並沒有記錄這條數據具體是什麼，所以你要在所有的日誌裡找到當初插入這條數據時的記錄，這是很麻煩的。</p><p>也有別的方法，就是把誤刪除之前的備份在測試庫上恢復，然後把數據找出來，並導回來</p><p>備份 改1 改2 刪除</p><p>0 8 12 16</p><p>delete from emp where ename='zhangsan';</p><p>drop table emp;</p><p>誤刪除1張表,用二進制日誌來恢復,不太好找相關的數據,因為這張表如果使用了好幾年,數據操作太多;有延時複製的話,在C上導出這張表,導回A</p><p>誤刪除最近一段時間相關的數據,用二進制日誌找到那個時間點,從那個時間點恢復到現在</p><p>mysql開源管理工具</p><p>maatkit --perl寫的，老外常用</p><p># ls /share/soft/maatkit/</p><p>maatkit-7410[1].tar.gz maatkit-7540[1].tar.gz</p><p>maatkit-7486[1].tar.gz</p><p>--在mysql AB的slave上安裝（只需要在slave上安裝)</p><p># tar xf /share/soft/maatkit/maatkit-7540\[1\].tar.gz -C /usr/src/</p><p># cd /usr/src/maatkit-7540/</p><p>安裝方法README文件裡有寫</p><p># perl Makefile.PL --如果不成功，需要安裝perl有關的多個包，可以yum install perl*</p><p># make install</p><p>[root@li maatkit-7540]# ls bin/ --這些命令，就是各個管理工具</p><p>mk-archiver mk-purge-logs</p><p>mk-checksum-filter mk-query-advisor</p><p>mk-config-diff mk-query-digest</p><p>mk-deadlock-logger mk-query-profiler</p><p>mk-duplicate-key-checker mk-show-grants</p><p>mk-error-log mk-slave-delay</p><p>mk-fifo-split mk-slave-find</p><p>mk-find mk-slave-move</p><p>mk-heartbeat mk-slave-prefetch</p><p>mk-index-usage mk-slave-restart</p><p>mk-kill mk-table-checksum</p><p>mk-loadavg mk-table-sync</p><p>mk-log-player mk-table-usage</p><p>mk-merge-mqd-results mk-tcp-model</p><p>mk-parallel-dump mk-upgrade</p><p>mk-parallel-restore mk-variable-advisor</p><p>mk-profile-compact mk-visual-explain</p><p>--使用--help查看一個命令的使用方法</p><p># mk-slave-delay --help</p><p>mk-slave-delay starts and stops a slave server as needed to make it lag behind</p><p>the master. The SLAVE-HOST and MASTER-HOST use DSN syntax, and values are</p><p>copied from the SLAVE-HOST to the MASTER-HOST if omitted. For more details,</p><p>please use the --help option, or try 'perldoc /usr/bin/mk-slave-delay' for</p><p>complete documentation.</p><p># perldoc /usr/bin/mk-slave-delay --查看文檔</p><p>或者直接man mk-slave-delay</p><p>--mysql AB(無論同步或異步)正在運行OK的情況下，使用下面的命令在slave上運行;做之間建議把時間同步一下</p><p># mk-slave-delay --defaults-file=/usr/local/mysql56/etc/my.cnf --delay=1m --interval=15s --user=root --password=123 --socket=/var/run/mysqld/mysql56.socket --quiet localhost &</p><p>--表示延時1分鐘，才會應用SQL線程；這裡是測試所以才使用很小的時間，實際情況可以調成1小時或2小時</p><p>測試：</p><p>在master上隨便插入幾條數據</p><p>然後在slave上發現沒有馬上同步過來</p><p>slave > show slave status\G; --查看狀態會發現SQL線程狀態為NO</p><p>Slave_IO_Running: Yes</p><p>Slave_SQL_Running: NO</p><p>大概等1分鐘，就會自動延時同步過來了；</p><p>--注意:日誌已經傳到slave的relay-bin log裡了，但由SQL線程延時去解析</p><p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p><p>原理理解題</p><p>題1</p><p>mysql架構中,一主多從，雙主，級聯（多主一從和環型不支持)這三種的區別和優缺點</p><p>題2</p><p>如果現在一個小公司mysql數據庫已經跑了一年，現在要搭建mysqlAB複製，你檢查了主庫後，發現它這一年都沒有使用二進制日誌，請問如何做複製？</p><p>1,先主庫開二進制日誌</p><p>2,備份主庫，恢復到從庫</p><p>3，做AB複製，指定從備份的position往後複製</p><p>題3</p><p>在實際的大數據量的數據庫中，因為負載太高或者網絡問題，現在造成複製時的數據延時，請問你如何做為DBA應該如何去處理？</p><p>架構擴展性</p><p>題4</p><p>如果一個lamp架構在深圳機房在運行，如何儘量無影響的把這個lamp遷移到惠州的機房</p><p>1，在惠州機房做一個lamp，mysql雙主架構，web做rsync遠程實時同步</p><p>2，把網站域名對應的IP地址A記錄改成惠州的IP</p><p>3，當深圳機房服務器無連接時，就可以關閉深圳機房的服務器了</p><p>題5</p><p>做mysqlAB複製不能同讀同寫，如果有幾個分公司，各分公司都有mysql數據庫，要求，各地mysql數據同步，並且各地都能讀能寫。</p><p>ndbcluster</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>mysql</a></li><li><a>AB</a></li><li><a>主從</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9d7247a8.html alt=AB羅克韋爾自動化Micro810可編程邏輯控制器系統型號及功能介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab296919d6ff4c15bc433cf48e05475a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9d7247a8.html title=AB羅克韋爾自動化Micro810可編程邏輯控制器系統型號及功能介紹>AB羅克韋爾自動化Micro810可編程邏輯控制器系統型號及功能介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0077882a.html alt=AB羅克韋爾自動化Micro820可編程邏輯控制器系統型號及功能介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/bf0bc764e5994cceb9ff4d769d34a161 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0077882a.html title=AB羅克韋爾自動化Micro820可編程邏輯控制器系統型號及功能介紹>AB羅克韋爾自動化Micro820可編程邏輯控制器系統型號及功能介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/27cba6f9.html alt=AB羅克韋爾自動化Micro850可編程邏輯控制器系統型號及功能介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aad9b13bcccc494496c9d6d89cd9ea7a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/27cba6f9.html title=AB羅克韋爾自動化Micro850可編程邏輯控制器系統型號及功能介紹>AB羅克韋爾自動化Micro850可編程邏輯控制器系統型號及功能介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dbba1bd.html alt=AB羅克韋爾自動化Micro870可編程邏輯控制器系統型號及功能介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b3eb4b0c39bb4822b6803ffae3c922d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dbba1bd.html title=AB羅克韋爾自動化Micro870可編程邏輯控制器系統型號及功能介紹>AB羅克韋爾自動化Micro870可編程邏輯控制器系統型號及功能介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/953ca5fa.html alt=AB羅克韋爾自動化MicroLogix1100可編程邏輯控制器系統介紹及功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5a9bfeabc7e7468887928d37e14dc0d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/953ca5fa.html title=AB羅克韋爾自動化MicroLogix1100可編程邏輯控制器系統介紹及功能>AB羅克韋爾自動化MicroLogix1100可編程邏輯控制器系統介紹及功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4115e029.html alt=AB羅克韋爾自動化MicroLogix1400可編程邏輯控制器系統介紹及功能 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/eb15dbef91d24bb4a9a47196245f5960 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4115e029.html title=AB羅克韋爾自動化MicroLogix1400可編程邏輯控制器系統介紹及功能>AB羅克韋爾自動化MicroLogix1400可編程邏輯控制器系統介紹及功能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89184519.html alt="mysql 創建表，查看錶，修改表名字，指定引擎和字符集" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3e173dc6-28ba-4101-8576-c70b1d96b5d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89184519.html title="mysql 創建表，查看錶，修改表名字，指定引擎和字符集">mysql 創建表，查看錶，修改表名字，指定引擎和字符集</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65535165.html alt=mysql教程:MySQL多表查詢大全,18個示例總有你需要的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/43cf07c314554ea0887eaa8fd25c178f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65535165.html title=mysql教程:MySQL多表查詢大全,18個示例總有你需要的>mysql教程:MySQL多表查詢大全,18個示例總有你需要的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/78fdddee.html alt=mysql快速複製表結構的幾種方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/78fdddee.html title=mysql快速複製表結構的幾種方法>mysql快速複製表結構的幾種方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b923e71e.html alt=mysql數據庫主從複製拓撲結構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/6c3e00007aa0307b6043 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b923e71e.html title=mysql數據庫主從複製拓撲結構>mysql數據庫主從複製拓撲結構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/53471e9b.html alt=mysql異步複製與半同步複製的架構原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/4e7b00019c175cf0ab61 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/53471e9b.html title=mysql異步複製與半同步複製的架構原理>mysql異步複製與半同步複製的架構原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a2673f2.html alt="高性能主從模式動態可重構的SPI IP核設計" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/6ec8000fd9fe8b59debd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a2673f2.html title="高性能主從模式動態可重構的SPI IP核設計">高性能主從模式動態可重構的SPI IP核設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5b4a6f12.html alt="mysql explain 詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/43d249c02fa64e4192cc7d6f1aa4a748 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5b4a6f12.html title="mysql explain 詳解">mysql explain 詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/760cb665.html alt="言情小說推薦：男女主從小定下娃娃親系列文 ​​​​" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/23a5d68afd6f4bc39757a79142e14d84 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/760cb665.html title="言情小說推薦：男女主從小定下娃娃親系列文 ​​​​">言情小說推薦：男女主從小定下娃娃親系列文 ​​​​</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>