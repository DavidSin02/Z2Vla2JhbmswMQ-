<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>程序員需要了解的硬核知識之彙編語言(全) | 极客快訊</title><meta property="og:title" content="程序員需要了解的硬核知識之彙編語言(全) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6e145f6a2cb94d31ab615feb9c285fac"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/1fa9007b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/1fa9007b.html><meta property="article:published_time" content="2020-11-14T21:04:31+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:31+08:00"><meta name=Keywords content><meta name=description content="程序員需要了解的硬核知識之彙編語言(全)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/1fa9007b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>程序員需要了解的硬核知識之彙編語言(全)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>之前的系列文章從 CPU 和內存方面簡單介紹了一下彙編語言，但是還沒有系統的瞭解一下彙編語言，彙編語言作為第二代計算機語言，會用一些容易理解和記憶的字母，單詞來代替一個特定的指令，作為高級編程語言的基礎，有必要系統的瞭解一下彙編語言，那麼本篇文章希望大家跟我一起來了解一下彙編語言。</p><p><strong>彙編語言和本地代碼</strong></p><p>我們在之前的文章中探討過，計算機 CPU 只能運行本地代碼(機器語言)程序，用 C 語言等高級語言編寫的代碼，需要經過編譯器編譯後，轉換為本地代碼才能夠被 CPU 解釋執行。</p><p>但是本地代碼的可讀性非常差，所以需要使用一種能夠直接讀懂的語言來替換本地代碼，那就是在各本地代碼中，附帶上表示其功能的英文縮寫，比如在加法運算的本地代碼加上add(addition) 的縮寫、在比較運算符的本地代碼中加上cmp(compare)的縮寫等，這些通過縮寫來表示具體本地代碼指令的標誌稱為 助記符，使用助記符的語言稱為彙編語言。這樣，通過閱讀彙編語言，也能夠了解本地代碼的含義了。</p><p>不過，即使是使用彙編語言編寫的源代碼，最終也必須要轉換為本地代碼才能夠運行，負責做這項工作的程序稱為編譯器，轉換的這個過程稱為彙編。在將源代碼轉換為本地代碼這個功能方面，彙編器和編譯器是同樣的。</p><p>用彙編語言編寫的源代碼和本地代碼是一一對應的。因而，本地代碼也可以反過來轉換成彙編語言編寫的代碼。把本地代碼轉換為彙編代碼的這一過程稱為反彙編，執行反彙編的程序稱為反彙編程序。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e145f6a2cb94d31ab615feb9c285fac><p class=pgc-img-caption></p></div><p>哪怕是 C 語言編寫的源代碼，編譯後也會轉換成特定 CPU 用的本地代碼。而將其反彙編的話，就可以得到彙編語言的源代碼，並對其內容進行調查。不過，<strong>本地代碼變成 C 語言源代碼的反編譯，要比本地代碼轉換成彙編代碼的反彙編要困難</strong>，這是因為，C 語言代碼和本地代碼不是一一對應的關係。</p><p><strong>通過編譯器輸出彙編語言的源代碼</strong></p><p>我們上面提到本地代碼可以經過反彙編轉換成為彙編代碼，但是隻有這一種轉換方式嗎？顯然不是，C 語言編寫的源代碼也能夠通過編譯器編譯稱為彙編代碼，下面就來嘗試一下。</p><p>首先需要先做一些準備，需要先下載 Borland C++ 5.5 編譯器，為了方便，我這邊直接下載好了讀者直接從我的百度網盤提取即可 （鏈接:https://pan.baidu.com/s/19LqVICpn5GcV88thD2AnlA 密碼:hz1u）</p><p>下載完畢，需要進行配置，下面是配置說明 （https://wenku.baidu.com/view/22e2f418650e52ea551898ad.html），教程很完整跟著配置就可以，下面開始我們的編譯過程</p><p>首先用 Windows 記事本等文本編輯器編寫如下代碼</p><pre>// 返回兩個參數值之和的函數int AddNum(int a,int b){ return a + b;}// 調用 AddNum 函數的函數void MyFunc(){ int c; c = AddNum(123,456);}</pre><p>編寫完成後將其文件名保存為 Sample4.c ，C 語言源文件的擴展名，通常用.c 來表示，上面程序是提供兩個輸入參數並返回它們之和。</p><p>在 Windows 操作系統下打開 命令提示符，切換到保存 Sample4.c 的文件夾下，然後在命令提示符中輸入</p><pre>bcc32 -c -S Sample4.c</pre><p>bcc32 是啟動 Borland C++ 的命令，-c 的選項是指僅進行編譯而不進行鏈接，-S 選項被用來指定生成彙編語言的源代碼</p><p>作為編譯的結果，當前目錄下會生成一個名為Sample4.asm 的彙編語言源代碼。彙編語言源文件的擴展名，通常用.asm 來表示，下面就讓我們用編輯器打開看一下 Sample4.asm 中的內容</p><pre> .386p ifdef ??version if ??version GT 500H .mmx endif endif model flat ifndef ??version ?debug macro endm endif ?debug S "Sample4.c" ?debug T "Sample4.c"_TEXT segment dword public use32 'CODE'_TEXT ends_DATA segment dword public use32 'DATA'_DATA ends_BSS segment dword public use32 'BSS'_BSS endsDGROUP group _BSS,_DATA_TEXT segment dword public use32 'CODE'_AddNum proc near?live1@0: ;  ; int AddNum(int a,int b){ ;  push ebp mov ebp,esp ;  ;  ; return a + b; ; @1: mov eax,dword ptr [ebp+8] add eax,dword ptr [ebp+12] ;  ; } ; @3:@2: pop ebp ret _AddNum endp_MyFunc proc near?live1@48: ;  ; void MyFunc(){ ;  push ebp mov ebp,esp ;  ; int c; ; c = AddNum(123,456); ; @4: push 456 push 123 call _AddNum add esp,8 ;  ; } ; @5: pop ebp ret _MyFunc endp_TEXT ends public _AddNum public _MyFunc ?debug D "Sample4.c" 20343 45835 end</pre><p>這樣，編譯器就成功的把 C 語言轉換成為了彙編代碼了。</p><p><strong>不會轉換成本地代碼的偽指令</strong></p><p>第一次看到彙編代碼的讀者可能感覺起來比較難，不過實際上其實比較簡單，而且可能比 C 語言還要簡單，為了便於閱讀彙編代碼的源代碼，需要注意幾個要點</p><p>彙編語言的源代碼，是由轉換成本地代碼的指令（後面講述的操作碼）和針對彙編器的偽指令構成的。偽指令負責把程序的構造以及彙編的方法指示給彙編器（轉換程序）。不過偽指令是無法彙編轉換成為本地代碼的。下面是上面程序截取的偽指令</p><pre>_TEXT segment dword public use32 'CODE'_TEXT ends_DATA segment dword public use32 'DATA'_DATA ends_BSS segment dword public use32 'BSS'_BSS endsDGROUP group _BSS,_DATA_AddNum proc near_AddNum endp_MyFunc proc near_MyFunc endp_TEXT ends end</pre><p>由偽指令 segment 和 ends 圍起來的部分，是給構成程序的命令和數據的集合體上加一個名字而得到的，稱為段定義。段定義的英文表達具有區域的意思，在這個程序中，段定義指的是命令和數據等程序的集合體的意思，一個程序由多個段定義構成。</p><p>上面代碼的開始位置，定義了3個名稱分別為 _TEXT、_DATA、_BSS 的段定義，_TEXT 是指定的段定義，_DATA 是被初始化（有初始值）的數據的段定義，_BSS 是尚未初始化的數據的段定義。這種定義的名稱是由 Borland C++ 定義的，是由 Borland C++ 編譯器自動分配的，所以程序段定義的順序就成為了 _TEXT、_DATA、_BSS ，這樣也確保了內存的連續性</p><pre>_TEXT segment dword public use32 'CODE'_TEXT ends_DATA segment dword public use32 'DATA'_DATA ends_BSS segment dword public use32 'BSS'_BSS ends</pre><blockquote><p>段定義( segment ) 是用來區分或者劃分範圍區域的意思。彙編語言的 segment 偽指令表示段定義的起始，ends 偽指令表示段定義的結束。段定義是一段連續的內存空間</p></blockquote><p>而group 這個偽指令表示的是將 _BSS和_DATA 這兩個段定義彙總名為 DGROUP 的組</p><pre>DGROUP group _BSS,_DATA</pre><p>圍起 _AddNum 和 _MyFun 的 _TEXT segment 和 _TEXT ends ，表示_AddNum 和 _MyFun 是屬於 _TEXT 這一段定義的。</p><pre>_TEXT segment dword public use32 'CODE'_TEXT ends</pre><p>因此，即使在源代碼中指令和數據是混雜編寫的，經過編譯和彙編後，也會轉換成為規整的本地代碼。</p><p>_AddNum proc 和 _AddNum endp 圍起來的部分，以及_MyFunc proc 和 _MyFunc endp 圍起來的部分，分別表示 AddNum 函數和 MyFunc 函數的範圍。</p><pre>_AddNum proc near_AddNum endp_MyFunc proc near_MyFunc endp</pre><p>編譯後在函數名前附帶上下劃線_ ，是 Borland C++ 的規定。在 C 語言中編寫的 AddNum 函數，在內部是以 _AddNum 這個名稱處理的。偽指令 proc 和 endp 圍起來的部分，表示的是 過程(procedure) 的範圍。在彙編語言中，這種相當於 C 語言的函數的形式稱為過程。</p><p>末尾的 end 偽指令，表示的是源代碼的結束。</p><p>## 彙編語言的語法是 操作碼 + 操作數</p><p>在彙編語言中，一行表示一對 CPU 的一個指令。彙編語言指令的語法結構是 <strong>操作碼 + 操作數</strong>，也存在只有操作碼沒有操作數的指令。</p><p>操作碼錶示的是指令動作，操作數表示的是指令對象。操作碼和操作數一起使用就是一個英文指令。比如從英語語法來分析的話，操作碼是動詞，操作數是賓語。比如這個句子 Give me money這個英文指令的話，Give 就是操作碼，me 和 money 就是操作數。彙編語言中存在多個操作數的情況，要用逗號把它們分割，就像是 Give me,money 這樣。</p><p>能夠使用何種形式的操作碼，是由 CPU 的種類決定的，下面對操作碼的功能進行了整理。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b863d58230c04ce3b1f439d1fba71486><p class=pgc-img-caption></p></div><p>本地代碼需要加載到內存後才能運行，內存中存儲著構成本地代碼的指令和數據。程序運行時，CPU會從內存中把數據和指令讀出來，然後放在 CPU 內部的寄存器中進行處理。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f828947d0ff747889f07fa1a03af31a3><p class=pgc-img-caption></p></div><p>如果 CPU 和內存的關係你還不是很瞭解的話，請閱讀作者的另一篇文章 程序員需要了解的硬核知識之CPU 詳細瞭解。</p><p>寄存器是 CPU 中的存儲區域，寄存器除了具有臨時存儲和計算的功能之外，還具有運算功能，x86 系列的主要種類和角色如下圖所示</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6697e16de5034831a27600e8c478e6dd><p class=pgc-img-caption></p></div><p><strong>指令解析</strong></p><p>下面就對 CPU 中的指令進行分析</p><p><strong>最常用的 mov 指令</strong></p><p>指令中最常使用的是對寄存器和內存進行數據存儲的 mov 指令，mov 指令的兩個操作數，分別用來指定數據的存儲地和讀出源。操作數中可以指定寄存器、常數、標籤(附加在地址前)，以及用方括號([]) 圍起來的這些內容。如果指定了沒有用([]) 方括號圍起來的內容，就表示對該值進行處理；如果指定了用方括號圍起來的內容，方括號的值則會被解釋為內存地址，然後就會對該內存地址對應的值進行讀寫操作。讓我們對上面的代碼片段進行說明</p><pre> mov ebp,esp mov eax,dword ptr [ebp+8]</pre><p>mov ebp,esp 中，esp 寄存器中的值被直接存儲在了 ebp 中，也就是說，如果 esp 寄存器的值是100的話那麼 ebp 寄存器的值也是 100。</p><p>而在 mov eax,dword ptr [ebp+8] 這條指令中，ebp 寄存器的值 + 8 後會被解析稱為內存地址。如果 ebp</p><p>寄存器的值是100的話，那麼 eax 寄存器的值就是 100 + 8 的地址的值。dword ptr 也叫做 double word pointer 簡單解釋一下就是從指定的內存地址中讀出4字節的數據</p><p><strong>對棧進行 push 和 pop</strong></p><p>程序運行時，會在內存上申請分配一個稱為棧的數據空間。棧（stack）的特性是後入先出，數據在存儲時是從內存的下層（大的地址編號）逐漸往上層（小的地址編號）累積，讀出時則是按照從上往下進行讀取的。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2244c9c7e1024e07aac8dfab006e2e0b><p class=pgc-img-caption></p></div><p>棧是存儲臨時數據的區域，它的特點是通過 push 指令和 pop 指令進行數據的存儲和讀出。向棧中存儲數據稱為 入棧 ，從棧中讀出數據稱為 出棧，32位 x86 系列的 CPU 中，進行1次 push 或者 pop，即可處理 32 位（4字節）的數據。</p><p><strong>函數的調用機制</strong></p><p>下面我們一起來分析一下函數的調用機制，我們以上面的 C 語言編寫的代碼為例。首先，讓我們從MyFunc 函數調用AddNum 函數的彙編語言部分開始，來對函數的調用機制進行說明。棧在函數的調用中發揮了巨大的作用，下面是經過處理後的 MyFunc 函數的彙編處理內容</p><pre>_MyFunc proc near push ebp ; 將 ebp 寄存器的值存入棧中 (1)  mov ebp,esp ; 將 esp 寄存器的值存入 ebp 寄存器中 (2) push 456 ; 將 456 入棧 (3) push 123 ; 將 123 入棧 (4) call _AddNum ; 調用 AddNum 函數 (5) add esp,8 ; esp 寄存器的值 + 8 (6) pop ebp ; 讀出棧中的數值存入 esp 寄存器中 (7) ret ; 結束 MyFunc 函數，返回到調用源 (8)_MyFunc endp</pre><p>代碼解釋中的(1)、(2)、(7)、(8)的處理適用於 C 語言中的所有函數，我們會在後面展示 AddNum 函數處理內容時進行說明。這裡希望大家先關注(3) - (6) 這一部分，這對了解函數調用機制至關重要。</p><p>(3) 和 (4) 表示的是將傳遞給 AddNum 函數的參數通過 push 入棧。在 C 語言源代碼中，雖然記述為函數 AddNum(123,456)，但入棧時則會先按照 456，123 這樣的順序。也就是位於後面的數值先入棧。這是 C 語言的規定。(5) 表示的 call 指令，會把程序流程跳轉到 AddNum 函數指令的地址處。在彙編語言中，函數名錶示的就是函數所在的內存地址。AddNum 函數處理完畢後，程序流程必須要返回到編號(6) 這一行。call 指令運行後，call 指令的下一行(也就指的是 (6) 這一行)的內存地址(調用函數完畢後要返回的內存地址)會自動的 push 入棧。該值會在 AddNum 函數處理的最後通過 ret 指令 pop 出棧，然後程序會返回到 (6) 這一行。</p><p>(6) 部分會把棧中存儲的兩個參數 (456 和 123) 進行銷燬處理。雖然通過兩次的 pop 指令也可以實現，不過採用 esp 寄存器 + 8 的方式會更有效率(處理 1 次即可)。對棧進行數值的輸入和輸出時，數值的單位是4字節。因此，通過在負責棧地址管理的 esp 寄存器中加上4的2倍8，就可以達到和運行兩次 pop 命令同樣的效果。雖然內存中的數據實際上還殘留著，但只要把 esp 寄存器的值更新為數據存儲地址前面的數據位置，該數據也就相當於銷燬了。</p><p>我在編譯 Sample4.c 文件時，出現了下圖的這條消息</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2c85363f13f544699c3e8746d88bee35><p class=pgc-img-caption></p></div><p>圖中的意思是指 c 的值在 MyFunc 定義了但是一直未被使用，這其實是一項編譯器優化的功能，由於存儲著 AddNum 函數返回值的變量 c 在後面沒有被用到，因此編譯器就認為 <strong>該變量沒有意義</strong>，進而也就<strong>沒有生成與之對應的彙編語言代碼</strong>。</p><p>下圖是調用 AddNum 這一函數前後棧內存的變化</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/876b92c43f2445e6aa0a0e9f56813bba><p class=pgc-img-caption></p></div><p><strong>函數的內部處理</strong></p><p>上面我們用匯編代碼分析了一下 Sample4.c 整個過程的代碼，現在我們著重分析一下 AddNum 函數的源代碼部分，分析一下參數的接收、返回值和返回等機制</p><pre>_AddNum proc near push ebp (1) mov ebp,esp (2) mov eax,dword ptr[ebp+8] (3) add eax,dword ptr[ebp+12] (4) pop ebp (5) ret (6)_AddNum endp</pre><p>ebp 寄存器的值在(1)中入棧，在(5)中出棧，這主要是為了把函數中用到的 ebp 寄存器的內容，恢復到函數調用前的狀態。</p><p>(2) 中把負責管理棧地址的 esp 寄存器的值賦值到了 ebp 寄存器中。這是因為，在 mov 指令中方括號內的參數，是不允許指定 esp 寄存器的。因此，這裡就採用了不直接通過 esp，而是用 ebp 寄存器來讀寫棧內容的方法。</p><p>(3) 使用[ebp + 8] 指定棧中存儲的第1個參數123，並將其讀出到 eax 寄存器中。像這樣，不使用 pop 指令，也可以參照棧的內容。而之所以從多個寄存器中選擇了 eax 寄存器，是因為 eax 是負責運算的累加寄存器。</p><p>通過(4) 的 add 指令，把當前 eax 寄存器的值同第2個參數相加後的結果存儲在 eax 寄存器中。[ebp + 12] 是用來指定第2個參數456的。在 C 語言中，函數的返回值必須通過 eax 寄存器返回，這也是規定。也就是 <strong>函數的參數是通過棧來傳遞，返回值是通過寄存器返回的</strong>。</p><p>(6) 中 ret 指令運行後，函數返回目的地內存地址會自動出棧，據此，程序流程就會跳轉返回到(6) (Call _AddNum) 的下一行。這時，AddNum 函數入口和出口處棧的狀態變化，就如下圖所示</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c80b5e129a464ec79b5857f00304e6c7><p class=pgc-img-caption></p></div><p><strong>全局變量和局部變量</strong></p><p>在熟悉了彙編語言後，接下來我們來了解一下全局變量和局部變量，在函數外部定義的變量稱為全局變量，在函數內部定義的變量稱為局部變量，全局變量可以在任意函數中使用，局部變量只能在函數定義局部變量的內部使用。下面，我們就通過彙編語言來看一下全局變量和局部變量的不同之處。</p><p>下面定義的 C 語言代碼分別定義了局部變量和全局變量，並且給各變量進行了賦值，我們先看一下源代碼部分</p><pre>// 定義被初始化的全局變量int a1 = 1;int a2 = 2;int a3 = 3;int a4 = 4;int a5 = 5;// 定義沒有初始化的全局變量int b1,b2,b3,b4,b5;// 定義函數void MyFunc(){ // 定義局部變量 int c1,c2,c3,c4,c5,c6,c7,c8,c9,c10;  // 給局部變量賦值 c1 = 1; c2 = 2; c3 = 3; c4 = 4; c5 = 5; c6 = 6; c7 = 7; c8 = 8; c9 = 9; c10 = 10;  // 把局部變量賦值給全局變量 a1 = c1; a2 = c2; a3 = c3; a4 = c4; a5 = c5; b1 = c6; b2 = c7; b3 = c8; b4 = c9; b5 = c10;}</pre><p>上面的代碼挺暴力的，不過沒關係，能夠便於我們分析其彙編源碼就好，我們用 Borland C++ 編譯後的彙編代碼如下，編譯完成後的源碼比較長，這裡我們只拿出來一部分作為分析使用（我們改變了一下段定義順序，刪除了部分註釋）</p><pre>_DATA segment dword public use32 'DATA' align 4 _a1 label dword dd 1 align 4 _a2 label dword dd 2 align 4 _a3 label dword dd 3 align 4 _a4 label dword dd 4 align 4 _a5 label dword dd 5_DATA ends_BSS segment dword public use32 'BSS' align 4 _b1 label dword db 4 dup(?) align 4 _b2 label dword db 4 dup(?) align 4 _b3 label dword db 4 dup(?) align 4 _b4 label dword db 4 dup(?) align 4 _b5 label dword db 4 dup(?)_BSS ends_TEXT segment dword public use32 'CODE'_MyFunc proc near push ebp mov ebp,esp add esp,-20 push ebx push esi mov eax,1 mov edx,2 mov ecx,3 mov ebx,4 mov esi,5 mov dword ptr [ebp-4],6 mov dword ptr [ebp-8],7 mov dword ptr [ebp-12],8 mov dword ptr [ebp-16],9 mov dword ptr [ebp-20],10 mov dword ptr [_a1],eax mov dword ptr [_a2],edx mov dword ptr [_a3],ecx mov dword ptr [_a4],ebx mov dword ptr [_a5],esi mov eax,dword ptr [ebp-4] mov dword ptr [_b1],eax mov edx,dword ptr [ebp-8] mov dword ptr [_b2],edx mov ecx,dword ptr [ebp-12] mov dword ptr [_b3],ecx mov eax,dword ptr [ebp-16] mov dword ptr [_b4],eax mov edx,dword ptr [ebp-20] mov dword ptr [_b5],edx pop esi pop ebx mov esp,ebp pop ebp ret _MyFunc endp_TEXT ends</pre><p>編譯後的程序，會被歸類到名為段定義的組。</p><ul><li>初始化的全局變量，會彙總到名為 _DATA 的段定義中</li></ul><pre>_DATA segment dword public use32 'DATA'..._DATA ends</pre><ul><li>沒有初始化的全局變量，會彙總到名為 _BSS 的段定義中</li></ul><pre>_BSS segment dword public use32 'BSS' ..._BSS ends</pre><ul><li>被段定義 _TEXT 圍起來的彙編代碼則是 Borland C++ 的定義</li></ul><pre>_TEXT segment dword public use32 'CODE'_MyFunc proc near..._MyFunc endp_TEXT ends</pre><p>我們在分析上面彙編代碼之前，先來認識一下更多的彙編指令，此表是對上面<strong>部分操作碼及其功能</strong>的接續</p><p>操作碼操作數功能addA,B把A和B的值相加，並把結果賦值給AcallA調用函數AcmpA,B對A和B進行比較，比較結果會自動存入標誌寄存器中incA對A的值 + 1ige標籤名和 cmp 命令組合使用。跳轉到標籤行jl標籤名和 cmp 命令組合使用。跳轉到標籤行jle標籤名和 cmp 命令組合使用。跳轉到標籤行jmp標籤名和 cmp 命令組合使用。跳轉到標籤行movA,B把 B 的值賦給 ApopA從棧中讀取數值並存入ApushA把A的值存入棧中ret無將處理返回到調用源xorA,BA和B的位進行亦或比較，並將結果存入A中</p><p>我們首先來看一下 _DATA 段定義的內容。_a1 label dword 定義了 _a1 這個標籤。標籤表示的是相對於段定義起始位置的位置。由於_a1 在 _DATA 段定義的開頭位置，所以相對位置是0。 _a1 就相當於是全局變量a1。編譯後的函數名和變量名前面會加一個(_)，這也是 Borland C++ 的規定。dd 1 指的是，申請分配了4字節的內存空間，存儲著1這個初始值。 dd指的是 define double word表示有兩個長度為2的字節領域(word)，也就是4字節的意思。</p><p>Borland C++ 中，由於int 類型的長度是4字節，因此彙編器就把 int a1 = 1 變換成了 _a1 label dword 和 dd 1。同樣，這裡也定義了相當於全局變量的 a2 - a5 的標籤 _a2 - _a5，它們各自的初始值 2 - 5 也被存儲在各自的4字節中。</p><p>接下來，我們來說一說 _BSS 段定義的內容。這裡定義了相當於全局變量 b1 - b5 的標籤 _b1 - _b5。其中的db 4dup(?) 表示的是申請分配了4字節的領域，但值尚未確定（這裡用 ? 來表示）的意思。db(define byte) 表示有1個長度是1字節的內存空間。因而，db 4 dup(?) 的情況下，就是4字節的內存空間。</p><blockquote><p>注意：db 4 dup(?) 不要和 dd 4 混淆了，前者表示的是4個長度是1字節的內存空間。而 db 4 表示的則是雙字節( = 4 字節) 的內存空間中存儲的值是 4</p></blockquote><p><strong>臨時確保局部變量使用的內存空間</strong></p><p>我們知道，局部變量是臨時保存在寄存器和棧中的。函數內部利用棧進行局部變量的存儲，函數調用完成後，局部變量值被銷燬，但是寄存器可能用於其他目的。所以，<strong>局部變量只是函數在處理期間臨時存儲在寄存器和棧中的</strong>。</p><p>回想一下上述代碼是不是定義了10個局部變量？這是為了表示存儲局部變量的不僅僅是棧，還有寄存器。為了確保 c1 - c10 所需的域，寄存器空閒的時候就會使用寄存器，寄存器空間不足的時候就會使用棧。</p><p>讓我們繼續來分析上面代碼的內容。_TEXT段定義表示的是 MyFunc 函數的範圍。在 MyFunc 函數中定義的局部變量所需要的內存領域。會被儘可能的分配在寄存器中。大家可能認為使用高性能的寄存器來替代普通的內存是一種資源浪費，但是編譯器不這麼認為，只要寄存器有空間，編譯器就會使用它。由於寄存器的訪問速度遠高於內存，所以直接訪問寄存器能夠高效的處理。局部變量使用寄存器，是 Borland C++ 編譯器最優化的運行結果。</p><p>代碼清單中的如下內容表示的是向寄存器中分配局部變量的部分</p><pre>mov eax,1mov edx,2mov ecx,3mov ebx,4mov esi,5</pre><p>僅僅對局部變量進行定義是不夠的，只有在給局部變量賦值時，才會被分配到寄存器的內存區域。上述代碼相當於就是給5個局部變量 c1 - c5 分別賦值為 1 - 5。<strong>eax、edx、ecx、ebx、esi</strong> 是 x86 系列32位 CPU 寄存器的名稱。至於使用哪個寄存器，是由編譯器來決定的 。</p><p>x86 系列 CPU 擁有的寄存器中，程序可以操作的是十幾，其中空閒的最多會有幾個。因而，局部變量超過寄存器數量的時候，可分配的寄存器就不夠用了，這種情況下，編譯器就會把棧派上用場，用來存儲剩餘的局部變量。</p><p>在上述代碼這一部分，給局部變量c1 - c5 分配完寄存器後，可用的寄存器數量就不足了。於是，剩下的5個局部變量c6 - c10 就被分配給了棧的內存空間。如下面代碼所示</p><pre>mov dword ptr [ebp-4],6mov dword ptr [ebp-8],7mov dword ptr [ebp-12],8mov dword ptr [ebp-16],9mov dword ptr [ebp-20],10</pre><p>函數入口 add esp,-20 指的是，對棧數據存儲位置的 esp 寄存器(棧指針)的值做減20的處理。為了確保內存變量 c6 - c10 在棧中，就需要保留5個 int 類型的局部變量（4字節 * 5 = 20 字節）所需的空間。mov ebp,esp這行指令表示的意思是將 esp 寄存器的值賦值到 ebp 寄存器。之所以需要這麼處理，是為了通過在函數出口處 mov esp ebp 這一處理，把 esp 寄存器的值還原到原始狀態，從而對申請分配的棧空間進行釋放，這時棧中用到的局部變量就消失了。這也是棧的清理處理。在使用寄存器的情況下，局部變量則會在寄存器被用於其他用途時自動消失，如下圖所示。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8b31861cb0824d67935e20ffef4e4821><p class=pgc-img-caption></p></div><pre> mov dword ptr [ebp-4],6 mov dword ptr [ebp-8],7 mov dword ptr [ebp-12],8 mov dword ptr [ebp-16],9 mov dword ptr [ebp-20],10</pre><p>這五行代碼是往棧空間代入數值的部分，由於在向棧申請內存空間前，藉助了 mov ebp, esp 這個處理，esp 寄存器的值被保存到了 esp 寄存器中，因此，通過使用[ebp - 4]、[ebp - 8]、[ebp - 12]、[ebp - 16]、[ebp - 20] 這樣的形式，就可以申請分配20字節的棧內存空間切分成5個長度為4字節的空間來使用。例如，mov dword ptr [ebp-4],6 表示的就是，從申請分配的內存空間的下端(ebp寄存器指示的位置)開始向前4字節的地址([ebp - 4]) 中，存儲著6這一4字節數據。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1e56c53f300b44c5a2c171af1600c032><p class=pgc-img-caption></p></div><p><strong>循環控制語句的處理</strong></p><p>上面說的都是順序流程，那麼現在就讓我們分析一下循環流程的處理，看一下 for 循環以及 if 條件分支等 c 語言程序的 流程控制是如何實現的，我們還是以代碼以及編譯後的結果為例，看一下程序控制流程的處理過程。</p><pre>// 定義MySub 函數void MySub(){ // 不做任何處理 }// 定義MyFunc 函數void Myfunc(){ int i; for(int i = 0;i &lt; 10;i++){ // 重複調用MySub十次 MySub(); }}</pre><p>上述代碼將局部變量 i 作為循環條件，循環調用十次MySub 函數，下面是它主要的彙編代碼</p><pre> xor ebx, ebx ; 將寄存器清0@4 call _MySub ; 調用MySub函數 inc ebx ; ebx寄存器的值 + 1 cmp ebx,10 ; 將ebx寄存器的值和10進行比較 jl short @4 ; 如果小於10就跳轉到 @4</pre><p>C 語言中的 for 語句是通過在括號中指定循環計數器的初始值(i = 0)、循環的繼續條件(i &lt; 10)、循環計數器的更新(i++) 這三種形式來進行循環處理的。與此相對的彙編代碼就是通過比較指令(cmp) 和 跳轉指令(jl)來實現的。</p><p>下面我們來對上述代碼進行說明</p><p>MyFunc 函數中用到的局部變量只有 i ，變量 i 申請分配了 ebx 寄存器的內存空間。for 語句括號中的 i = 0 被轉換為 xor ebx,ebx 這一處理，xor 指令會對左起第一個操作數和右起第二個操作數進行 XOR 運算，然後把結果存儲在第一個操作數中。由於這裡把第一個操作數和第二個操作數都指定為了 ebx，因此就變成了對相同數值的 XOR 運算。也就是說不管當前寄存器的值是什麼，最終的結果都是0。類似的，我們使用 mov ebx,0 也能得到相同的結果，但是 xor 指令的處理速度更快，而且編譯器也會啟動最優化功能。</p><blockquote><p>XOR 指的就是異或操作，它的運算規則是 <strong>如果a、b兩個值不相同，則異或結果為1。如果a、b兩個值相同，異或結果為0</strong>。</p><p>相同數值進行 XOR 運算，運算結果為0。XOR 的運算規則是，值不同時結果為1，值相同時結果為0。例如 01010101 和 01010101 進行運算，就會分別對各個數字位進行 XOR 運算。因為每個數字位都相同，所以運算結果為0。</p></blockquote><p>ebx 寄存器的值初始化後，會通過 call 指定調用 _MySub 函數，從 _MySub 函數返回後，會執行inc ebx 指令，對 ebx 的值進行 + 1 操作，這個操作就相當於 i++ 的意思，++ 表示的就是當前數值 + 1。</p><blockquote><p>這裡需要知道 i++ 和 ++i 的區別</p><p>i++ 是先賦值，複製完成後再對 i執行 + 1 操作</p><p>++i 是先進行 +1 操作，完成後再進行賦值</p></blockquote><p>inc 下一行的 cmp 是用來對第一個操作數和第二個操作數的數值進行比較的指令。 cmp ebx,10 就相當於 C 語言中的 i &lt; 10 這一處理，意思是把 ebx 寄存器的值與10進行比較。彙編語言中比較指令的結果，會存儲在 CPU 的標誌寄存器中。不過，標誌寄存器的值，程序是無法直接參考的。那如何判斷比較結果呢？</p><p>彙編語言中有多個跳轉指令，這些跳轉指令會根據標誌寄存器的值來判斷是否進行跳轉操作，例如最後一行的 jl，它會根據 cmp ebx,10 指令所存儲在標誌寄存器中的值來判斷是否跳轉，jl 這條指令表示的就是 jump on less than(小於的話就跳轉)。發現如果 i 比 10 小，就會跳轉到 @4 所在的指令處繼續執行。</p><p>那麼彙編代碼的意思也可以用 C 語言來改寫一下，加深理解</p><pre> i ^= i;L4: MySub(); i++; if(i &lt; 10) goto L4;</pre><p>代碼第一行 i ^= i 指的就是 i 和 i 進行異或運算，也就是 XOR 運算，MySub() 函數用 L4 標籤來替代，然後進行 i 自增操作，如果i 的值小於 10 的話，就會一直循環 MySub() 函數。</p><p><strong>條件分支的處理方法</strong></p><p>條件分支的處理方式和循環的處理方式很相似，使用的也是 cmp 指令和跳轉指令。下面是用 C 語言編寫的條件分支的代碼</p><pre>// 定義MySub1 函數void MySub1(){ // 不做任何處理}// 定義MySub2 函數void MySub2(){  // 不做任何處理}// 定義MySub3 函數void MySub3(){ // 不做任何處理}// 定義MyFunc 函數void MyFunc(){ int a = 123; // 根據條件調用不同的函數 if(a &gt; 100){ MySub1(); } else if(a &lt; 50){ MySub2(); } else { MySub3(); }}</pre><p>很簡單的一個實現了條件判斷的 C 語言代碼，那麼我們把它用 Borland C++ 編譯之後的結果如下</p><pre>_MyFunc proc near push ebp  mov ebp,esp mov eax,123 ; 把123存入 eax 寄存器中 cmp eax,100 ; 把 eax 寄存器的值同100進行比較 jle short @8 ; 比100小時，跳轉到@8標籤 call _MySub1 ; 調用MySub1函數 jmp short @11 ; 跳轉到@11標籤@8: cmp eax,50 ; 把 eax 寄存器的值同50進行比較 jge short @10 ; 比50大時，跳轉到@10標籤 call _MySub2 ; 調用MySub2函數 jmp short @11 ; 跳轉到@11標籤@10: call _MySub3 ; 調用MySub3函數@11: pop ebp ret _MyFunc endp</pre><p>上面代碼用到了三種跳轉指令，分別是jle(jump on less or equal) 比較結果小時跳轉，jge(jump on greater or equal) 比較結果大時跳轉，還有不管結果怎樣都會進行跳轉的jmp，在這些跳轉指令之前還有用來比較的指令 cmp，構成了上述彙編代碼的主要邏輯形式。</p><p><strong>瞭解程序運行邏輯的必要性</strong></p><p>通過對上述彙編代碼和 C 語言源代碼進行比較，想必大家對程序的運行方式有了新的理解，而且，從彙編源代碼中獲取的知識，也有助於瞭解 Java 等高級語言的特性，比如 Java 中就有 native 關鍵字修飾的變量，那麼這個變量的底層就是使用 C 語言編寫的，還有一些 Java 中的語法糖只有通過彙編代碼才能知道其運行邏輯。在某些情況下，對於查找 bug 的原因也是有幫助的。</p><p>上面我們瞭解到的編程方式都是串行處理的，那麼串行處理有什麼特點呢？</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ee95561ee4e741f3922f9c4b12e424e0><p class=pgc-img-caption></p></div><p>串行處理最大的一個特點就是專心只做一件事情，一件事情做完之後才會去做另外一件事情。</p><p>計算機是支持多線程的，多線程的核心就是 CPU切換，如下圖所示</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/41e11dc73b424053970c29d194bdcbdc><p class=pgc-img-caption></p></div><p>我們還是舉個實際的例子，讓我們來看一段代碼</p><pre>// 定義全局變量int counter = 100;// 定義MyFunc1()void MyFunc(){ counter *= 2;}// 定義MyFunc2()void MyFunc2(){ counter *= 2;}</pre><p>上述代碼是更新 counter 的值的 C 語言程序，MyFunc1() 和 MyFunc2() 的處理內容都是把 counter 的值擴大至原來的二倍，然後再把 counter 的值賦值給 counter 。這裡，我們假設使用多線程處理，同時調用了一次MyFunc1 和 MyFunc2 函數，這時，全局變量 counter 的值，理應編程 100 * 2 * 2 = 400。如果你開啟了多個線程的話，你會發現 counter 的數值有時也是 200，對於為什麼出現這種情況，如果你不瞭解程序的運行方式，是很難找到原因的。</p><p>我們將上面的代碼轉換成彙編語言的代碼如下</p><pre>mov eax,dword ptr[_counter] ; 將 counter 的值讀入 eax 寄存器add eax,eax ; 將 eax 寄存器的值擴大2倍。mov dword ptr[_counter],eax ; 將 eax 寄存器的值存入 counter 中。</pre><p>在多線程程序中，用彙編語言表示的代碼每運行一行，處理都有可能切換到其他線程中。因而，假設 MyFun1 函數在讀出 counter 數值100後，還未來得及將它的二倍值200寫入 counter 時，正巧 MyFun2 函數讀出了 counter 的值100，那麼結果就將變為 200 。</p><div class=pgc-img><img alt=程序員需要了解的硬核知識之彙編語言(全) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/85636596193e4ed4a99dd4d9b8a10c98><p class=pgc-img-caption></p></div><p>為了避免該bug，我們可以採用以函數或 C 語言代碼的行為單位來禁止線程切換的鎖定方法，或者使用某種線程安全的方式來避免該問題的出現。</p><p>現在基本上沒有人用彙編語言來編寫程序了，因為 C、Java等高級語言的效率要比彙編語言快很多。不過，彙編語言的經驗還是很重要的，通過藉助彙編語言，我們可以更好的瞭解計算機運行機制。</p><p>文章參考：</p><p>《程序是怎樣跑起來的》第十章</p><p>作者：cxuan<br>出處：https://www.cnblogs.com/cxuanBlog/<br>本文版權歸作者和博客園共有，歡迎轉載，但未經作者同意必須保留此段聲明，且在文章頁面明顯位置給出原文連接，否則追究法律責任的權利。<br>如果文中有什麼錯誤，歡迎指出。以免更多的人被誤導。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>硬核</a></li><li><a>知識</a></li><li><a>編語</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e945a45.html alt=程序員需要了解的硬核知識之磁盤 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2437e474164c4bd7a3456b38eeff177e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e945a45.html title=程序員需要了解的硬核知識之磁盤>程序員需要了解的硬核知識之磁盤</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa99a158.html alt=彙編語言基礎知識篇章一，預備知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/88c5eb8c-6758-4cf9-ad64-57f0e00e3a5f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa99a158.html title=彙編語言基礎知識篇章一，預備知識>彙編語言基礎知識篇章一，預備知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07fc84e.html alt=硬核知識解答，關於汽車最高車速的疑惑今天一網打盡 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ed0ee7a2f69147dbb4d92f60e6606d68 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07fc84e.html title=硬核知識解答，關於汽車最高車速的疑惑今天一網打盡>硬核知識解答，關於汽車最高車速的疑惑今天一網打盡</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/804ea540.html alt=「行業知識」結構工程師的心結——鋼樑扭轉計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/177f1b37fa4b41698a4e78accf7efbb4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/804ea540.html title=「行業知識」結構工程師的心結——鋼樑扭轉計算>「行業知識」結構工程師的心結——鋼樑扭轉計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc4c942.html alt=「鋼構知識」經典鋼結構設計問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc4c942.html title=「鋼構知識」經典鋼結構設計問答>「鋼構知識」經典鋼結構設計問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f6e1fd9.html alt=「鋼構知識」經典鋼結構設計問答彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/76195b1e9d934c2e952b060dad0951e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f6e1fd9.html title=「鋼構知識」經典鋼結構設計問答彙總>「鋼構知識」經典鋼結構設計問答彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html alt=各種門窗知識大全，是我見過最全的了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15349013240149cf1ef5531 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0fc448f5.html title=各種門窗知識大全，是我見過最全的了>各種門窗知識大全，是我見過最全的了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0ff6432.html alt=鋼結構必備知識38問 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0ff6432.html title=鋼結構必備知識38問>鋼結構必備知識38問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb258a5a.html alt=鋼結構必備知識38問，你的晉級之路！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1535975955779bcac330762 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb258a5a.html title=鋼結構必備知識38問，你的晉級之路！>鋼結構必備知識38問，你的晉級之路！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html alt=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1537941825042b6f495fa56 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8bbd5f8a.html title=長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？>長知識！什麼是榫卯結構？為什麼現代建築當中不常見了？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0a77c203.html alt="（鑄造知識四）----- 真空吸鑄" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/b52f6cfa-2566-4f1d-a4b0-f9921b5d06b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0a77c203.html title="（鑄造知識四）----- 真空吸鑄">（鑄造知識四）----- 真空吸鑄</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html alt=素描五官基礎知識，學素描的同學可參考 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/99b7762898d34e2f9a667c431fc7da6b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/775df7fb.html title=素描五官基礎知識，學素描的同學可參考>素描五官基礎知識，學素描的同學可參考</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/31ba8cf2.html alt=[科普知識]什麼是光纖的冷接？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c9d2cd0e63c0404f9f4cbdaae98d9606 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/31ba8cf2.html title=[科普知識]什麼是光纖的冷接？>[科普知識]什麼是光纖的冷接？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc63183.html alt=「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ac7fb5fb22b8449392a90146180d194f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc63183.html title=「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪>「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ba54c166.html alt=模擬和數字電路基礎知識彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ebd9341d866e4850ba3b8b476352d2e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ba54c166.html title=模擬和數字電路基礎知識彙總>模擬和數字電路基礎知識彙總</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>