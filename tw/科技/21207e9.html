<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>常見的七種加密算法以及實現 | 极客快訊</title><meta property="og:title" content="常見的七種加密算法以及實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/4c8625eceeb7427ba545ea05ae7784fc"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/21207e9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/21207e9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/21207e9.html><meta property="article:published_time" content="2020-10-29T20:52:29+08:00"><meta property="article:modified_time" content="2020-10-29T20:52:29+08:00"><meta name=Keywords content><meta name=description content="常見的七種加密算法以及實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/21207e9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>常見的七種加密算法以及實現</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=heading>前言</h1><p><strong>數字簽名</strong>、<strong>信息加密</strong> 是前後端開發都經常需要使用到的技術，應用場景包括了用戶登入、交易、信息通訊、oauth 等等，不同的應用場景也會需要使用到不同的簽名加密算法，或者需要搭配不一樣的 <strong>簽名加密算法</strong> 來達到業務目標。這裡簡單的給大家介紹幾種常見的簽名加密算法和一些典型場景下的應用。</p><h1 class=heading>正文</h1><h2 class=heading>1. 數字簽名</h2><p><strong>數字簽名</strong>，簡單來說就是通過提供 <strong>可鑑別</strong> 的 <strong>數字信息</strong> 驗證 <strong>自身身份</strong> 的一種方式。一套 <strong>數字簽名</strong> 通常定義兩種 <strong>互補</strong> 的運算，一個用於 <strong>簽名</strong>，另一個用於 <strong>驗證</strong>。分別由 <strong>發送者</strong> 持有能夠 <strong>代表自己身份</strong> 的 <strong>私鑰</strong> (私鑰不可洩露),由 <strong>接受者</strong> 持有與私鑰對應的 <strong>公鑰</strong> ，能夠在 <strong>接受</strong> 到來自發送者信息時用於 <strong>驗證</strong> 其身份。</p><div class=pgc-img><img alt=常見的七種加密算法以及實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4c8625eceeb7427ba545ea05ae7784fc><p class=pgc-img-caption></p></div><blockquote><p><strong>注意</strong>：圖中 <strong>加密過程</strong> 有別於 <strong>公鑰加密</strong>，更多 介紹戳這裡。<strong>簽名</strong> 最根本的用途是要能夠唯一 <strong>證明發送方的身份</strong>，防止 <strong>中間人攻擊</strong>、CSRF <strong>跨域身份偽造</strong>。基於這一點在諸如 <strong>設備認證</strong>、<strong>用戶認證</strong>、<strong>第三方認證</strong> 等認證體系中都會使用到 <strong>簽名算法</strong> (彼此的實現方式可能會有差異)。</p></blockquote><h2 class=heading>2. 加密和解密</h2><h3 class=heading>2.1. 加密</h3><p><strong>數據加密</strong> 的基本過程，就是對原來為 <strong>明文</strong> 的文件或數據按 <strong>某種算法</strong> 進行處理，使其成為 <strong>不可讀</strong> 的一段代碼，通常稱為 <strong>“密文”</strong>。通過這樣的途徑，來達到 <strong>保護數據</strong> 不被 <strong>非法人竊取</strong>、閱讀的目的。</p><h3 class=heading>2.2. 解密</h3><p><strong>加密</strong> 的 <strong>逆過程</strong> 為 <strong>解密</strong>，即將該 <strong>編碼信息</strong> 轉化為其 <strong>原來數據</strong> 的過程。</p><h2 class=heading>3. 對稱加密和非對稱加密</h2><p>加密算法分 <strong>對稱加密</strong> 和 <strong>非對稱加密</strong>，其中對稱加密算法的加密與解密 <strong>密鑰相同</strong>，非對稱加密算法的加密密鑰與解密 <strong>密鑰不同</strong>，此外，還有一類 <strong>不需要密鑰</strong> 的 <strong>散列算法</strong>。</p><blockquote><p>常見的 <strong>對稱加密</strong> 算法主要有 DES、3DES、AES 等，常見的 <strong>非對稱算法</strong> 主要有 RSA、DSA 等，<strong>散列算法</strong> 主要有 SHA-1、MD5 等。</p></blockquote><h3 class=heading>3.1. 對稱加密</h3><p><strong>對稱加密算法</strong> 是應用較早的加密算法，又稱為 <strong>共享密鑰加密算法</strong>。在 <strong>對稱加密算法</strong> 中，使用的密鑰只有一個，<strong>發送</strong> 和 <strong>接收</strong> 雙方都使用這個密鑰對數據進行 <strong>加密</strong> 和 <strong>解密</strong>。這就要求加密和解密方事先都必須知道加密的密鑰。</p><div class=pgc-img><img alt=常見的七種加密算法以及實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30ca907198994721b43f457f42328f4b><p class=pgc-img-caption></p></div><ol start=1><li>數據加密過程：在對稱加密算法中，<strong>數據發送方</strong> 將 <strong>明文</strong> (原始數據) 和 <strong>加密密鑰</strong> 一起經過特殊 <strong>加密處理</strong>，生成複雜的 <strong>加密密文</strong> 進行發送。</li><li>數據解密過程：<strong>數據接收方</strong> 收到密文後，若想讀取原數據，則需要使用 <strong>加密使用的密鑰</strong> 及相同算法的 <strong>逆算法</strong> 對加密的密文進行解密，才能使其恢復成 <strong>可讀明文</strong>。</li></ol><h3 class=heading>3.2. 非對稱加密</h3><p><strong>非對稱加密算法</strong>，又稱為 <strong>公開密鑰加密算法</strong>。它需要兩個密鑰，一個稱為 <strong>公開密鑰</strong> (public key)，即 <strong>公鑰</strong>，另一個稱為 <strong>私有密鑰</strong> (private key)，即 <strong>私鑰</strong>。</p><p>因為 <strong>加密</strong> 和 <strong>解密</strong> 使用的是兩個不同的密鑰，所以這種算法稱為 <strong>非對稱加密算法</strong>。</p><div class=pgc-img><img alt=常見的七種加密算法以及實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a59b76fd28214d379a6500a48c28a09c><p class=pgc-img-caption></p></div><ol start=1><li>如果使用 <strong>公鑰</strong> 對數據 <strong>進行加密</strong>，只有用對應的 <strong>私鑰</strong> 才能 <strong>進行解密</strong>。</li><li>如果使用 <strong>私鑰</strong> 對數據 <strong>進行加密</strong>，只有用對應的 <strong>公鑰</strong> 才能 <strong>進行解密</strong>。</li></ol><blockquote><p><strong>例子</strong>：甲方生成 <strong>一對密鑰</strong> 並將其中的一把作為 <strong>公鑰</strong> 向其它人公開，得到該公鑰的 <strong>乙方</strong> 使用該密鑰對機密信息 <strong>進行加密</strong> 後再發送給甲方，甲方再使用自己保存的另一把 <strong>專用密鑰</strong> (<strong>私鑰</strong>)，對 <strong>加密</strong> 後的信息 <strong>進行解密</strong>。</p></blockquote><h2 class=heading>4. 常見的簽名加密算法</h2><h3 class=heading>4.1. MD5算法</h3><p>MD5 用的是 <strong>哈希函數</strong>，它的典型應用是對一段信息產生 <strong>信息摘要</strong>，以 <strong>防止被篡改</strong>。嚴格來說，MD5 不是一種 <strong>加密算法</strong> 而是 <strong>摘要算法</strong>。無論是多長的輸入，MD5 都會輸出長度為 128bits 的一個串 (通常用 16 <strong>進制</strong> 表示為 32 個字符)。</p><pre><code>public static final byte[] computeMD5(byte[] content) {    try {        MessageDigest md5 = MessageDigest.getInstance("MD5");        return md5.digest(content);    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}</code></pre><h3 class=heading>4.2. SHA1算法</h3><p>SHA1 是和 MD5 一樣流行的 <strong>消息摘要算法</strong>，然而 SHA1 比 MD5 的 <strong>安全性更強</strong>。對於長度小於 2 ^ 64 位的消息，SHA1 會產生一個 160 位的 <strong>消息摘要</strong>。基於 MD5、SHA1 的信息摘要特性以及 <strong>不可逆</strong> (一般而言)，可以被應用在檢查 <strong>文件完整性</strong> 以及 <strong>數字簽名</strong> 等場景。</p><pre><code>public static byte[] computeSHA1(byte[] content) {    try {        MessageDigest sha1 = MessageDigest.getInstance("SHA1");        return sha1.digest(content);    } catch (NoSuchAlgorithmException e) {        throw new RuntimeException(e);    }}</code></pre><h3 class=heading>4.3. HMAC算法</h3><p>HMAC 是密鑰相關的 <strong>哈希運算消息認證碼</strong>（Hash-based Message Authentication Code），HMAC 運算利用 <strong>哈希算法</strong> (MD5、SHA1 等)，以 <strong>一個密鑰</strong> 和 <strong>一個消息</strong> 為輸入，生成一個 <strong>消息摘要</strong> 作為 <strong>輸出</strong>。</p><p>HMAC <strong>發送方</strong> 和 <strong>接收方</strong> 都有的 key 進行計算，而沒有這把 key 的第三方，則是 <strong>無法計算</strong> 出正確的 <strong>散列值</strong>的，這樣就可以 <strong>防止數據被篡改</strong>。</p><pre><code>package net.pocrd.util;import net.pocrd.annotation.NotThreadSafe;import net.pocrd.define.ConstField;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Mac;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.Arrays;@NotThreadSafepublic class HMacHelper {    private static final Logger logger = LoggerFactory.getLogger(HMacHelper.class);    private Mac mac;    /**     * MAC算法可選以下多種算法     * HmacMD5/HmacSHA1/HmacSHA256/HmacSHA384/HmacSHA512     */    private static final String KEY_MAC = "HmacMD5";    public HMacHelper(String key) {        try {            SecretKey secretKey = new SecretKeySpec(key.getBytes(ConstField.UTF8), KEY_MAC);            mac = Mac.getInstance(secretKey.getAlgorithm());            mac.init(secretKey);        } catch (Exception e) {            logger.error("create hmac helper failed.", e);        }    }    public byte[] sign(byte[] content) {        return mac.doFinal(content);    }        public boolean verify(byte[] signature, byte[] content) {        try {            byte[] result = mac.doFinal(content);            return Arrays.equals(signature, result);        } catch (Exception e) {            logger.error("verify sig failed.", e);        }        return false;    }}</code></pre><blockquote><p><strong>測試結論</strong>：HMAC 算法實例在 <strong>多線程環境</strong> 下是 <strong>不安全的</strong>。但是需要在 <strong>多線程訪問</strong> 時，進行同步的輔助類，使用 ThreadLocal 為 <strong>每個線程緩存</strong> 一個實例可以避免進行鎖操作。</p></blockquote><h3 class=heading>4.4. AES/DES/3DES算法</h3><p>AES、DES、3DES 都是 <strong>對稱</strong> 的 <strong>塊加密算法</strong>，<strong>加解密</strong> 的過程是 <strong>可逆的</strong>。常用的有 AES128、AES192、AES256 (默認安裝的 JDK 尚不支持 AES256，需要安裝對應的 jce 補丁進行升級 jce1.7，jce1.8)。</p><h4 class=heading>4.4.1. DES算法</h4><p>DES 加密算法是一種 <strong>分組密碼</strong>，以 64 位為 <strong>分組對數據</strong> 加密，它的 <strong>密鑰長度</strong> 是 56 位，<strong>加密解密</strong> 用 <strong>同一算法</strong>。</p><p>DES 加密算法是對 <strong>密鑰</strong> 進行保密，而 <strong>公開算法</strong>，包括加密和解密算法。這樣，只有掌握了和發送方 <strong>相同密鑰</strong> 的人才能解讀由 DES加密算法加密的密文數據。因此，破譯 DES 加密算法實際上就是 <strong>搜索密鑰的編碼</strong>。對於 56 位長度的 <strong>密鑰</strong> 來說，如果用 <strong>窮舉法</strong> 來進行搜索的話，其運算次數為 2 ^ 56 次。</p><h4 class=heading>4.4.2. 3DES算法</h4><p>是基於 DES 的 <strong>對稱算法</strong>，對 <strong>一塊數據</strong> 用 <strong>三個不同的密鑰</strong> 進行 <strong>三次加密</strong>，<strong>強度更高</strong>。</p><h4 class=heading>4.4.3. AES算法</h4><p>AES 加密算法是密碼學中的 <strong>高級加密標準</strong>，該加密算法採用 <strong>對稱分組密碼體制</strong>，密鑰長度的最少支持為 128 位、 192 位、256 位，分組長度 128 位，算法應易於各種硬件和軟件實現。這種加密算法是美國聯邦政府採用的 <strong>區塊加密標準</strong>。</p><p>AES 本身就是為了取代 DES 的，AES 具有更好的 <strong>安全性</strong>、<strong>效率</strong> 和 <strong>靈活性</strong>。</p><pre><code>import net.pocrd.annotation.NotThreadSafe;import javax.crypto.Cipher;import javax.crypto.KeyGenerator;import javax.crypto.spec.IvParameterSpec;import javax.crypto.spec.SecretKeySpec;import java.security.SecureRandom;@NotThreadSafepublic class AesHelper {    private SecretKeySpec keySpec;    private IvParameterSpec iv;    public AesHelper(byte[] aesKey, byte[] iv) {        if (aesKey == null || aesKey.length &lt; 16 || (iv != null &amp;&amp; iv.length &lt; 16)) {            throw new RuntimeException("錯誤的初始密鑰");        }        if (iv == null) {            iv = Md5Util.compute(aesKey);        }        keySpec = new SecretKeySpec(aesKey, "AES");        this.iv = new IvParameterSpec(iv);    }    public AesHelper(byte[] aesKey) {        if (aesKey == null || aesKey.length &lt; 16) {            throw new RuntimeException("錯誤的初始密鑰");        }        keySpec = new SecretKeySpec(aesKey, "AES");        this.iv = new IvParameterSpec(Md5Util.compute(aesKey));    }    public byte[] encrypt(byte[] data) {        byte[] result = null;        Cipher cipher = null;        try {            cipher = Cipher.getInstance("AES/CFB/NoPadding");            cipher.init(Cipher.ENCRYPT_MODE, keySpec, iv);            result = cipher.doFinal(data);        } catch (Exception e) {            throw new RuntimeException(e);        }        return result;    }    public byte[] decrypt(byte[] secret) {        byte[] result = null;        Cipher cipher = null;        try {            cipher = Cipher.getInstance("AES/CFB/NoPadding");            cipher.init(Cipher.DECRYPT_MODE, keySpec, iv);            result = cipher.doFinal(secret);        } catch (Exception e) {            throw new RuntimeException(e);        }        return result;    }    public static byte[] randomKey(int size) {        byte[] result = null;        try {            KeyGenerator gen = KeyGenerator.getInstance("AES");            gen.init(size, new SecureRandom());            result = gen.generateKey().getEncoded();        } catch (Exception e) {            throw new RuntimeException(e);        }        return result;    }}</code></pre><h3 class=heading>4.5. RSA算法</h3><p>RSA 加密算法是目前最有影響力的 <strong>公鑰加密算法</strong>，並且被普遍認為是目前 <strong>最優秀的公鑰方案</strong> 之一。RSA 是第一個能同時用於 <strong>加密</strong> 和 <strong>數字簽名</strong> 的算法，它能夠 <strong>抵抗</strong> 到目前為止已知的 <strong>所有密碼攻擊</strong>，已被 ISO 推薦為公鑰數據加密標準。</p><blockquote><p>RSA <strong>加密算法</strong> 基於一個十分簡單的數論事實：將兩個大 <strong>素數</strong> 相乘十分容易，但想要對其乘積進行 <strong>因式分解</strong> 卻極其困難，因此可以將 <strong>乘積</strong> 公開作為 <strong>加密密鑰</strong>。</p></blockquote><pre><code>import net.pocrd.annotation.NotThreadSafe;import org.bouncycastle.jce.provider.BouncyCastleProvider;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.KeyFactory;import java.security.Security;import java.security.Signature;import java.security.interfaces.RSAPrivateCrtKey;import java.security.interfaces.RSAPublicKey;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;@NotThreadSafepublic class RsaHelper {    private static final Logger logger = LoggerFactory.getLogger(RsaHelper.class);    private RSAPublicKey publicKey;    private RSAPrivateCrtKey privateKey;    static {        Security.addProvider(new BouncyCastleProvider()); //使用bouncycastle作為加密算法實現    }    public RsaHelper(String publicKey, String privateKey) {        this(Base64Util.decode(publicKey), Base64Util.decode(privateKey));    }    public RsaHelper(byte[] publicKey, byte[] privateKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }            if (privateKey != null &amp;&amp; privateKey.length &gt; 0) {                this.privateKey = (RSAPrivateCrtKey)keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public RsaHelper(String publicKey) {        this(Base64Util.decode(publicKey));    }    public RsaHelper(byte[] publicKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("RSA");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (RSAPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] encrypt(byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        if (content == null) {            return null;        }        try {            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            int size = publicKey.getModulus().bitLength() / 8 - 11;            ByteArrayOutputStream baos = new ByteArrayOutputStream((content.length + size - 1) / size * (size + 11));            int left = 0;            for (int i = 0; i &lt; content.length; ) {                left = content.length - i;                if (left &gt; size) {                    cipher.update(content, i, size);                    i += size;                } else {                    cipher.update(content, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] decrypt(byte[] secret) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        if (secret == null) {            return null;        }        try {            Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");            cipher.init(Cipher.DECRYPT_MODE, privateKey);            int size = privateKey.getModulus().bitLength() / 8;            ByteArrayOutputStream baos = new ByteArrayOutputStream((secret.length + size - 12) / (size - 11) * size);            int left = 0;            for (int i = 0; i &lt; secret.length; ) {                left = secret.length - i;                if (left &gt; size) {                    cipher.update(secret, i, size);                    i += size;                } else {                    cipher.update(secret, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            logger.error("rsa decrypt failed.", e);        }        return null;    }    public byte[] sign(byte[] content) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        if (content == null) {            return null;        }        try {            Signature signature = Signature.getInstance("SHA1WithRSA");            signature.initSign(privateKey);            signature.update(content);            return signature.sign();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public boolean verify(byte[] sign, byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        if (sign == null || content == null) {            return false;        }        try {            Signature signature = Signature.getInstance("SHA1WithRSA");            signature.initVerify(publicKey);            signature.update(content);            return signature.verify(sign);        } catch (Exception e) {            logger.error("rsa verify failed.", e);        }        return false;    }}</code></pre><h3 class=heading>4.6. ECC算法</h3><p>ECC 也是一種 <strong>非對稱加密算法</strong>，主要優勢是在某些情況下，它比其他的方法使用 <strong>更小的密鑰</strong>，比如 RSA <strong>加密算法</strong>，提供 <strong>相當的或更高等級</strong> 的安全級別。不過一個缺點是 <strong>加密和解密操作</strong> 的實現比其他機制 <strong>時間長</strong> (相比 RSA 算法，該算法對 CPU 消耗嚴重)。</p><pre><code>import net.pocrd.annotation.NotThreadSafe;import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPrivateKey;import org.bouncycastle.jcajce.provider.asymmetric.ec.BCECPublicKey;import org.bouncycastle.jce.provider.BouncyCastleProvider;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import javax.crypto.Cipher;import java.io.ByteArrayOutputStream;import java.security.KeyFactory;import java.security.Security;import java.security.Signature;import java.security.spec.PKCS8EncodedKeySpec;import java.security.spec.X509EncodedKeySpec;@NotThreadSafepublic class EccHelper {    private static final Logger logger = LoggerFactory.getLogger(EccHelper.class);    private static final int SIZE = 4096;    private BCECPublicKey  publicKey;    private BCECPrivateKey privateKey;    static {        Security.addProvider(new BouncyCastleProvider());    }    public EccHelper(String publicKey, String privateKey) {        this(Base64Util.decode(publicKey), Base64Util.decode(privateKey));    }    public EccHelper(byte[] publicKey, byte[] privateKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (BCECPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }            if (privateKey != null &amp;&amp; privateKey.length &gt; 0) {                this.privateKey = (BCECPrivateKey)keyFactory.generatePrivate(new PKCS8EncodedKeySpec(privateKey));            }        } catch (ClassCastException e) {            throw new RuntimeException("", e);        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public EccHelper(String publicKey) {        this(Base64Util.decode(publicKey));    }    public EccHelper(byte[] publicKey) {        try {            KeyFactory keyFactory = KeyFactory.getInstance("EC", "BC");            if (publicKey != null &amp;&amp; publicKey.length &gt; 0) {                this.publicKey = (BCECPublicKey)keyFactory.generatePublic(new X509EncodedKeySpec(publicKey));            }        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] encrypt(byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        try {            Cipher cipher = Cipher.getInstance("ECIES", "BC");            cipher.init(Cipher.ENCRYPT_MODE, publicKey);            int size = SIZE;            ByteArrayOutputStream baos = new ByteArrayOutputStream((content.length + size - 1) / size * (size + 45));            int left = 0;            for (int i = 0; i &lt; content.length; ) {                left = content.length - i;                if (left &gt; size) {                    cipher.update(content, i, size);                    i += size;                } else {                    cipher.update(content, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public byte[] decrypt(byte[] secret) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        try {            Cipher cipher = Cipher.getInstance("ECIES", "BC");            cipher.init(Cipher.DECRYPT_MODE, privateKey);            int size = SIZE + 45;            ByteArrayOutputStream baos = new ByteArrayOutputStream((secret.length + size + 44) / (size + 45) * size);            int left = 0;            for (int i = 0; i &lt; secret.length; ) {                left = secret.length - i;                if (left &gt; size) {                    cipher.update(secret, i, size);                    i += size;                } else {                    cipher.update(secret, i, left);                    i += left;                }                baos.write(cipher.doFinal());            }            return baos.toByteArray();        } catch (Exception e) {            logger.error("ecc decrypt failed.", e);        }        return null;    }    public byte[] sign(byte[] content) {        if (privateKey == null) {            throw new RuntimeException("private key is null.");        }        try {            Signature signature = Signature.getInstance("SHA1withECDSA", "BC");            signature.initSign(privateKey);            signature.update(content);            return signature.sign();        } catch (Exception e) {            throw new RuntimeException(e);        }    }    public boolean verify(byte[] sign, byte[] content) {        if (publicKey == null) {            throw new RuntimeException("public key is null.");        }        try {            Signature signature = Signature.getInstance("SHA1withECDSA", "BC");            signature.initVerify(publicKey);            signature.update(content);            return signature.verify(sign);        } catch (Exception e) {            logger.error("ecc verify failed.", e);        }        return false;    }}</code></pre><h2 class=heading>5. 各種加密算法對比</h2><h3 class=heading>5.1. 散列算法比較</h3><p>名稱 安全性 速度 SHA-1 高 慢 MD5 中 快</p><h3 class=heading>5.2. 對稱加密算法比較</h3><p>名稱 密鑰名稱 運行速度 安全性 資源消耗 DES 56位 較快 低 中 3DES 112位或168位 慢 中 高 AES 128、192、256位 快 高 低</p><h3 class=heading>5.3. 非對稱加密算法比較</h3><p>名稱 成熟度 安全性 運算速度 資源消耗 RSA 高 高 中 中 ECC 高 高 慢 高</p><h3 class=heading>5.4. 對稱算法與非對稱加密算法</h3><h4 class=heading>5.4.1. 對稱算法</h4><ol start=1><li><strong>密鑰管理</strong>：比較難，不適合互聯網，一般用於內部系統</li><li><strong>安全性</strong>：中</li><li><strong>加密速度</strong>：快好 <strong>幾個數量級</strong> (軟件加解密速度至少快 100 倍，每秒可以加解密數 M <strong>比特</strong> 數據)，適合大數據量的加解密處理</li></ol><h4 class=heading>5.4.2. 非對稱算法</h4><ol start=1><li><strong>密鑰管理</strong>：密鑰容易管理</li><li><strong>安全性</strong>：高</li><li><strong>加密速度</strong>：比較慢，適合 <strong>小數據量</strong> 加解密或數據簽名</li></ol><h1 class=heading>小結</h1><p>本文介紹了 <strong>數字簽名</strong>，<strong>加密和解密</strong>，<strong>對稱加密和非對稱加密</strong>，然後詳細介紹了 MD5，SHA-1，HMAC，DES/AES，RSA 和 ECC 這幾種加密算法和代碼示例。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>加密算法</a></li><li><a>常見</a></li><li><a>七種</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/63bd996.html alt="七種常見的金屬機械錶面加工方式 你瞭解幾種？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5f0f4595fdf14e308497c19a3b0a0a6d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63bd996.html title="七種常見的金屬機械錶面加工方式 你瞭解幾種？">七種常見的金屬機械錶面加工方式 你瞭解幾種？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62b23d6.html alt=常見的加密算法之RSA加密算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5942000511e75e5c2e58 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62b23d6.html title=常見的加密算法之RSA加密算法>常見的加密算法之RSA加密算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9be666d.html alt=常見的幾種加密算法比較 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3c91db1f310c4b9a9746762abcb8f60f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9be666d.html title=常見的幾種加密算法比較>常見的幾種加密算法比較</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07ed115b.html alt=化工常見實驗儀器及表徵儀器原理動畫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1c6f9ee6148943499d7bc3d62aefe0ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07ed115b.html title=化工常見實驗儀器及表徵儀器原理動畫>化工常見實驗儀器及表徵儀器原理動畫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f7448f2d.html alt=鑄造合金的三種常見偏析現象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f7448f2d.html title=鑄造合金的三種常見偏析現象>鑄造合金的三種常見偏析現象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c99d724e.html alt=給大家介紹幾種常見的齒輪，學機械的收藏了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/b864f3ca-e8bf-47f4-a940-027e7a96e4a5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c99d724e.html title=給大家介紹幾種常見的齒輪，學機械的收藏了>給大家介紹幾種常見的齒輪，學機械的收藏了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0bb1ba.html alt=傳動裝置中的七種減速機簡介（圖文） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b2e9231bd97749a396f88c30af92e75d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0bb1ba.html title=傳動裝置中的七種減速機簡介（圖文）>傳動裝置中的七種減速機簡介（圖文）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d847e5fa.html alt=常見減速器的維護、維修，齒輪減速器、蝸桿減速器、行星減速器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d600b24a94d540acba2144de8da6a433 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d847e5fa.html title=常見減速器的維護、維修，齒輪減速器、蝸桿減速器、行星減速器>常見減速器的維護、維修，齒輪減速器、蝸桿減速器、行星減速器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1045435e.html alt=常見減速機的種類和作用分別是怎麼樣的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/af8efe17f66c4709a806bd545f326f38 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1045435e.html title=常見減速機的種類和作用分別是怎麼樣的？>常見減速機的種類和作用分別是怎麼樣的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a58b6f7f.html alt=常見地下管線探測檢測儀器簡介_西安捷通智創公司 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b1a6b312975941bda85bad943b7a540c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a58b6f7f.html title=常見地下管線探測檢測儀器簡介_西安捷通智創公司>常見地下管線探測檢測儀器簡介_西安捷通智創公司</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7665d66.html alt=常見的焊接缺陷二（外部缺陷） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6c28e8ae7c144646bfcdd40592219e8e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7665d66.html title=常見的焊接缺陷二（外部缺陷）>常見的焊接缺陷二（外部缺陷）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0903fbf9.html alt=常見的調整浪：三角形的各種變形圖解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/57c439a06ccf4f9f93d01541668817b6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0903fbf9.html title=常見的調整浪：三角形的各種變形圖解>常見的調整浪：三角形的各種變形圖解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb9492f2.html alt=電工必知！常見的基本電子電路圖！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/38e114ed426d4188b0ba2ba02f53bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb9492f2.html title=電工必知！常見的基本電子電路圖！>電工必知！常見的基本電子電路圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac390886.html alt=「圖說地理」常見的地質運動模擬動圖 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b9d0c02b364b4b47b6e0d223bdc89090 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac390886.html title=「圖說地理」常見的地質運動模擬動圖>「圖說地理」常見的地質運動模擬動圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html alt="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3c5a0001a9e3fd1b8a13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a7023ee.html title="Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰">Java 常見的49個錯誤及避免方法！翻譯作業：碼農網-小峰</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>