<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java容器系列-HashMap源碼分析 | 极客快訊</title><meta property="og:title" content="Java容器系列-HashMap源碼分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/10798fbb789b4217a4b19b4f307422b1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/22f3351b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/22f3351b.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="Java容器系列-HashMap源碼分析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/22f3351b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java容器系列-HashMap源碼分析</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>HashMap 實現了 Map 接口。HashMap 使用的很廣泛，但不是線程安全的，如果在多線程中使用，必須需要額外提供同步機制（多線程情況下推薦使用 ConCurrentHashMap）。</p><div class=pgc-img><img alt=Java容器系列-HashMap源碼分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/10798fbb789b4217a4b19b4f307422b1><p class=pgc-img-caption></p></div><p>HashMap 的類圖相對簡單，主要就是繼承了 AbstractMap，有一點需要注意，雖然沒有實現 Iterable 接口，但 HashMap 本身還是實現了迭代器的功能。</p><p>本文基於 JDK1.8</p><h2 class=pgc-h-arrow-right>成員變量及常量</h2><p>HashMap 是一個 Node[] 數組，每一個下標稱之為一個 <strong>桶</strong> 。</p><p>每一個鍵值對都是使用 Node 來存儲，這是一個單鏈表的數據結構。每個桶上可以通過鏈表來存儲多個鍵值對。</p><h3 class=pgc-h-arrow-right>常量</h3><p>HashMap 中用到的常量及其意義如下：</p><pre><code>// 初始容量（桶的個數） 2^4 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量（桶的個數） 2^30static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;// 默認的裝載因子(load factor)，除非特殊原因，否則不建議修改static final float DEFAULT_LOAD_FACTOR = 0.75f;// 單個桶上的元素個數大於這個值從鏈表轉成樹（樹化操作）static final int TREEIFY_THRESHOLD = 8;// 單個桶上元素少於這個值從樹轉成鏈表static final int UNTREEIFY_THRESHOLD = 6;// 只有桶的個數大於這個值時，樹化操作才會真正執行static final int MIN_TREEIFY_CAPACITY = 64;</code></pre><h3 class=pgc-h-arrow-right>成員變量</h3><p>HashMap 中用到的成員變量如下：</p><pre><code>// HashMap 中的 table，也就是桶transient Node&lt;K,V&gt;[] table;// 緩存所有的鍵值對 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;// 鍵值對的個數transient int size;// HashMap 被修改的次數，用於 fail-fast 檢查transient int modCount;// 進行 resize 操作的臨界值，threshold = capacity * loadFactorint threshold;// 裝載因子final float loadFactor;</code></pre><p>table 是一個 Node 數組， length 通常是 ，但也可以為 0。</p><h2 class=pgc-h-arrow-right>初始化</h2><p>HashMap 的初始化其實就只幹了兩件事：</p><ul><li>確定 threadhold 的值</li><li>確定 loadFactor 的值</li></ul><p>用戶可以通過傳入初始的容量和裝載因子。HashMap 的容量總是 ，如果傳入的參數不是 ，也會被轉化成 ：</p><pre><code>// HashMap.tableSizeFor()int n = -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</code></pre><p>Integer.numberOfLeadingZeros() 返回一個 int 類型（32位）在二進制表達下最後一個非零數字前面零的個數。比如 2：</p><pre><code>0000 0000 0000 0000 0000 0000 0000 010</code></pre><p>所以 Integer.numberOfLeadingZeros(3) 返回 30。</p><p>-1 在用二進制表示為：</p><pre><code>1111 1111 1111 1111 1111 1111 1111 1111</code></pre><p>>>> 表示無符號右移，-1 右移 30 位則得到:</p><pre><code>0000 0000 0000 0000 0000 0000 0000 011</code></pre><p>得到 3。</p><p>所以經過了 -1 >>> Integer.numberOfLeadingZeros(cap - 1) 返回的值一定是 ，所以最後返回的值一定是 ，感興趣的可以去驗證一下。</p><p>HashMap 在初始化的時候也可以接受一個 Map 對象，然後把傳入的 Map 對象中的元素放入當前的容器中。</p><p>除了傳入 Map 對象的實例化方式，都不會實際去創建桶數組，這是一種延遲初始化的方式，在插入第一個鍵值對的時候，會調用 resize() 方法去初始化桶。</p><p>下面來詳細看看 resize() 操作。</p><h2 class=pgc-h-arrow-right>擴容機制</h2><p>與 ArrayList 不同，HashMap 沒有手動擴容的過程，只會根據容器當前的情況自動擴容。</p><p>擴容操作由 resize() 方法來完成，擴容操作主要幹三件事：</p><ul><li>確定桶的個數</li><li>確定 threshold 的值</li><li>將所有的元素移到新的桶中</li></ul><h4 class=pgc-h-arrow-right>參數說明</h4><ul><li>oldCap: 擴容前桶的個數</li><li>oldThr: 擴容前 threshold 的值</li><li>newCap: 擴容後桶的個數</li><li>newThr: 擴容後 threshold 的值</li></ul><p>擴容流程如下：</p><div class=pgc-img><img alt=Java容器系列-HashMap源碼分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d255570fee2944cf994c17f1a89b7451><p class=pgc-img-caption></p></div><p>擴容時會新建一個 Node（桶）數組，然後把原容器中的鍵值對重新作 hash 操作，然後放到新的桶中。</p><p>HashMap 的容量有上限，為 ，也就是 1073741824，桶的個數不會超過這個數，threshold 的最大值是 2147483647，是最大容量的兩倍少1。</p><p>這樣設置代表這個如果桶的個數達到了最大容量，就不會再進行擴容操作了。</p><h2 class=pgc-h-arrow-right>具體實現</h2><div class=pgc-img><img alt=Java容器系列-HashMap源碼分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/a83245925626450d8a0da8d4aede6910><p class=pgc-img-caption></p></div><p>HashMap 的結構圖如上，每個桶都是一個鏈表的頭結點，對於 hash 值相同（哈希衝突）的 key，會放在同一個桶上。這也是 HashMap 解決哈希衝突的方法稱之為 <strong>拉鍊法</strong> 。在 JDK1.8 以後，在插入鍵值對時，使用的是 <strong>尾插法</strong> ，而不再是頭插法。</p><p>HashMap 與 Hashtable 的功能大致上一致。HashMap 的 key 和 value 都可以為 null。下面是主流 Map 的鍵值對是否可以為 null 的對比：</p><p><strong>Mapkey 是否可以為nullvalue 是否可以為 null</strong>HashMap是是Hashtable否否ConcurrentHashMap否否TreeMap否是</p><p>HashMap 不是線程安全的。在多線程環境中，需要使用額外的同步機制，比如使用 Map m = Collections.synchronizedMap(new HashMap(...)); 。</p><p>HashMap 也支持 fail-fast 機制。</p><h3 class=pgc-h-arrow-right>hash 方法</h3><p>hash 方法對 HashMap 非常重要，直接會影響到性能。鍵值對插入位置由 hash 方法來決定。假設 hash 方法可以讓元素在桶上均勻分佈，基本操作如 get 和 put 操作就是常量操作時間（ ）。</p><p>hash 方法需要有兩個特點：</p><ul><li>計算的結果需要足夠隨機</li><li>計算量不能太大</li></ul><p>HashMap 中具體實現如下：</p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p>>>> 是無符號右移操作，上面已經說到。假設現在有個 key 是 "name"，在我電腦上計算出來的值是：3373707，轉變成二進制就是：</p><pre><code>0000 0000 0011 0011 0111 1010 1000 1011</code></pre><p>右移 16 位後：</p><pre><code>0000 0000 0000 0000 0000 0000 0011 0011</code></pre><p>然後進行 <strong>異或</strong> 運算：</p><pre><code>0000 0000 0011 0011 0111 1010 1011 1000</code></pre><p>最後拿這個值與 HashMap 的長度減 1 進行與操作，因為 n 一定是 ，所以 (n-1) 的二進制全部是由 1 組成，下面這個操作相當於取 hash 值的後幾位：</p><pre><code>index = (n - 1) &amp; hash</code></pre><p>index 就是鍵值對的插入位置。</p><p>hash() 函數其實就是用來使鍵值對的插入位置足夠隨機，稱之為 <strong>擾動函數</strong> ，如果對具體的策略感興趣，可以參考這篇 <strong>文章</strong> 。</p><p>注：Object.hashcode() 是一個本地方法，返回對象的內存地址。Object.equals() 方法默認比較對象的內存地址，如果某個類修改了 equals 方法，那麼 hashcode 方法也需要修改，要讓 equals 和 hascode 的行為是一致的。否在在查找鍵值對的過程中就會出現 equals 結果是 true， hashcode 卻不一樣，這樣就無法找到鍵值對。</p><h3 class=pgc-h-arrow-right>容量和裝載因子</h3><p>使用 HashMap 時，有兩個參數會影響它的性能： <strong>初始容量</strong> 和 <strong>裝載因子</strong> 。</p><p>容量是指 HashMap 中桶的個數，初始容量是在創建實例時候所初始化桶的個數。</p><p>裝載因子用來決定擴容的 <strong>時機</strong> ，進行擴容操作時，會把桶的數量設為原來的 <strong>兩倍</strong> ，容器中所有的元素都會重新分配位置，擴容的代價很大，應該儘可能減少擴容操作。</p><p>裝載因子的默認值是 0.75，這是權衡 <strong>時間性能</strong> 和 <strong>空間開銷</strong> 的一個值。裝載因子設置的越大，那麼空間的開銷就會降低，但查找等操作的性能就會下降，反之亦然。</p><p>在初始化 HashMap 的時候，初始容量和裝載因子的值必須仔細衡量，以便儘可能減少擴容操作，如果沒有特殊的情況，使用默認的參數就可以。</p><p>遍歷 HashMap 所需的時間與容器的容量（桶的個數）及元素的數量成正比。如果迭代的時間性能很重要，就不要把 <strong>初始容量</strong> 設置的太大，也不要把 <strong>裝載因子</strong> 設置的很小。</p><h3 class=pgc-h-arrow-right>樹化操作</h3><p>在講解具體的方法前，需要了解 HashMap 中一個重要的內部操作： <strong>樹化</strong> 。</p><p>HashMap 使用拉鍊法來解決哈希衝突問題。多個鍵值對被分配到同一個桶的時候，是以鏈表的方式連接起來。但這樣會面臨一個問題，如果鏈表過長，那麼 HashMap 的很多操作就無法保持 的操作時間。</p><p>極端情況下，所有的鍵值對在一個桶中。那麼 get、remove 等操作的時間複雜度度就都是 。HashMap 的解決方法是用 <strong>紅黑樹</strong> 來替代鏈表，紅黑樹查詢的時間複雜度穩定在 。</p><p>HashMap 在單個桶的的元素的個數超過 8(TREEIFY_THRESHOLD) 且桶的個數大於 64(MIN_TREEIFY_CAPACITY) 時，會把桶後面的鏈表轉成樹（類似於 TreeMap ），這個操作稱之為樹化操作。</p><p>需要注意的是，當單個桶上的元素超過了8個，但桶的個數少於 64 時，不會進行樹化操作，而是會進行 <strong>擴容</strong> 操作，代碼如下：</p><pre><code>// HashMap.treeifyBin() methodfinal void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)        resize();    // other code...}</code></pre><p>樹化的過程是把鏈表的所有節點都替換成 TreeNode，然後再組成一棵紅黑樹（紅黑樹的具體構建過程可以查看這篇 <strong>文章</strong> ）。而且在鏈表轉成樹的過程中，每個節點之間的相對關係不會變化，通過節點的 next 變量來保持這個關係。</p><p>當樹上的節點樹少於 6(UNTREEIFY_THRESHOLD) 時，樹結構會重新轉化成鏈表。把樹的每一個節點換成鏈表的節點，通過 next 重新組成一個鏈表：</p><pre><code>// HashMap.ubtreeify()final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {    Node&lt;K,V&gt; hd = null, tl = null;    for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {        Node&lt;K,V&gt; p = map.replacementNode(q, null);        if (tl == null)            hd = p;        else            tl.next = p;            tl = p;    }    return hd;}</code></pre><p>即使遇到極端情況（所有的鍵值對在一個桶上），樹化操作也會保證 HashMap 的性能也不會退化太多。</p><h3 class=pgc-h-arrow-right>增刪改查操作</h3><p>get 方法：get 方法的實際操作是使用 getNode 方法來完成的。</p><pre><code>// HashMap.getNode()final Node&lt;K,V&gt; getNode(int hash, Object key) {    // 首先檢查容器是否為 null 以及 key 在容器中是否存在    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        // 找到相應的桶，從第一個節點開始查找，如果第一個節點不是要找的，後續節點就分成鏈表或者紅黑樹進行查找        if (first.hash == hash &amp;&amp;            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            // 如果鏈表已經轉成了紅黑樹，則在紅黑樹中查找            if (first instanceof TreeNode)               return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                // 如果不是樹，則在鏈表中查找                if (e.hash == hash &amp;&amp;                   ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                   return e;            } while ((e = e.next) != null);        }    }}</code></pre><p>put 方法：用於插入或者更新鍵值對，實際使用的是 HashMap.putVal() 方法來實現。如果是第一次插入鍵值對，會觸發 <strong>擴容</strong> 操作。</p><pre><code>// HashMap.putVal() 刪減了部分代碼final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 如果是第一次插入鍵值對，首先會進行擴容操作    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 如果一個桶的還沒有插入鍵值對，則對第一個節點進行初始化    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        // 如果是紅黑樹的結構，則按照紅黑樹的方式插入或者更新節點        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        // 否則按照鏈表的方式插入或者更新節點        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                   // 如果沒有找到鍵值對，則新建一個節點，把鍵值對插入                   p.next = newNode(hash, key, value, null);                   // 如果鏈表的長度大於等於 8，就會嘗試進行樹化操作                   if (binCount &gt;= TREEIFY_THRESHOLD - 1)                        treeifyBin(tab, hash);                        break;                }                // 如果找到了 key，則跳出循環                if (e.hash == hash &amp;&amp;                   ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                   break;                p = e;            }        }        // 如果 key 已經存在，則把 value 更新為新的 value        if (e != null) {            V oldValue = e.value;           if (!onlyIfAbsent || oldValue == null)               e.value = value;            return oldValue;        }    }    // fail-fast 版本號更新    ++modCount;    // 如果容器中元素的數量大於擴容臨界值，則進行擴容    if (++size &gt; threshold)        resize();    return null;}</code></pre><p>remove 方法的實現與 get 方法類似。</p><p>clear 方法會將 map 中所有的桶都置為 null 來清空鍵值對。</p><p>其他的操作都是組合這幾個基本的操作來完成。</p><h3 class=pgc-h-arrow-right>JDK8 的新特性</h3><p>在 JDK8 中，Map 中增加了一些新的方法，HashMap 對這些方法都進行了重寫，加入了對 fail-fast 機制的支持。</p><p>這些方法是用上面的增刪改查方法來實現的。</p><p>getOrDefault 方法，在值不存在的時候，返回一個默認值：</p><pre><code>HashMap map = new HashMap&lt;&gt;();map.put("name", "xiaomi");map.getOrDefault("gender","genderNotExist"); // genderNotExist</code></pre><p>forEach 方法，遍歷 map 中的鍵值對，可以接收 lambda 表達式：</p><pre><code>HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("name", "xiaomi");map.forEach((k, v) -&gt; System.out.println(k +":"+ v));</code></pre><p>putIfAbsent 方法，只有在 key 不存在時才會插入鍵值對：</p><pre><code>HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("name", "xiaomi");map.putIfAbsent("gender", "man");</code></pre><p>computeIfAbsent 方法用來簡化一些操作，下面方法1和方法2功能一樣，都是在 key 不存在的情況下，通過某些處理後然後把鍵值對插入 map：</p><pre><code>HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("name", "xiaomi");// 方法1：Integer age = (Integer)map.get("key");if (age == null) {    age = 18;    map.put("key", age);}// 方法2：map.computeIfAbsent("age",  k -&gt; {return 18;});</code></pre><p>computeIfPresent 方法則是在鍵值對存在的情況下，對鍵值對進行處理，然後再更新 map，下面方法1和方法2功能完全一樣：</p><pre><code>HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("name", "xiaomi");// 方法1：Integer age = (Integer)map.get("key");Integer age = 18 + 4;map.put("key", age);// 方法2：map.computeIfPresent("age", (k,v) -&gt; {return 18 + 4;});</code></pre><p>merge 方法用來對相同的 key 的 value 進行合併，以下方法1和方法2的功能一致：</p><pre><code>HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();map.put("name", "xiaomi");// 方法1：Integer age = (Integer)map.get("key");age += 14;map.put("key", age);// 方法2：map.merge("age", 18, (oldVal, newVal) -&gt; {return (Integer)oldVal + (Integer)newVal;});</code></pre><h3 class=pgc-h-arrow-right>其他功能</h3><p>HashMap 同樣也實現了迭代功能，HashMap 中有三個具體 Iterator 的實現：</p><ul><li>KeyIterator: 遍歷 map 的 key</li><li>ValueIterator: 遍歷 map 的 value</li><li>EntryIterator: 同時遍歷 map 的 key 和 value</li></ul><p>但是這個三個迭代器都不會直接使用，而是通過調用 HashMap 方法來間接獲取。</p><ul><li>KeyIterator 通過 HashMap.keySet() 方法獲取並使用</li><li>ValueIterator 通過 HashMap.vlaues() 方法獲取並使用</li><li>EntryIterator 通過 HashMap.entrySet() 方法獲取並使用</li></ul><p>Spliterator 的實現與迭代器的類似，分別對於 key、value 和 key + value 分別實現了 Spliterator。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>HashMap</a></li><li><a>源碼</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html alt="Java HashMap源碼分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html title="Java HashMap源碼分析">Java HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html alt=Java——HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8ad8e7317b3047f28717cf8c6fb816bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html title=Java——HashMap源碼分析>Java——HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html alt=Java中HashMap源碼分析，絕對乾貨！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/593f0003cad0b7c22de4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html title=Java中HashMap源碼分析，絕對乾貨！>Java中HashMap源碼分析，絕對乾貨！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html alt=源碼分析：Java集合類的AbstractCollection源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html title=源碼分析：Java集合類的AbstractCollection源碼解析>源碼分析：Java集合類的AbstractCollection源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd535810.html alt="Java源碼分析：關於 HashMap 1.8 的重大更新" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/66c40005d5e8c29e8c31 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd535810.html title="Java源碼分析：關於 HashMap 1.8 的重大更新">Java源碼分析：關於 HashMap 1.8 的重大更新</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html alt="Java源碼中>>，>>>的區別是啥？我給你徹底講清" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b12aaaf792c8469c91e2a514a666a8cf style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6eef481.html title="Java源碼中>>，>>>的區別是啥？我給你徹底講清">Java源碼中>>，>>>的區別是啥？我給你徹底講清</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>