<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>python3從零學習-5.3.3、十進制定點和浮點運算decimal | 极客快訊</title><meta property="og:title" content="python3從零學習-5.3.3、十進制定點和浮點運算decimal - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2346a233.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2346a233.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2346a233.html><meta property="article:published_time" content="2020-11-14T21:05:10+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:10+08:00"><meta name=Keywords content><meta name=description content="python3從零學習-5.3.3、十進制定點和浮點運算decimal"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/2346a233.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>python3從零學習-5.3.3、十進制定點和浮點運算decimal</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>源碼：</strong> Lib/decimal.py</p><hr><p>decimal 模塊為快速正確舍入的十進制浮點運算提供支持。 它提供了 float 數據類型以外的幾個優點：</p><ul><li>Decimal 類型的“設計是基於考慮人類習慣的浮點數模型，並且因此具有以下最高指導原則 —— 計算機必須提供與人們在學校所學習的算術相一致的算術。” —— 摘自 decimal 算術規範描述。</li><li>Decimal 數字的表示是精確的。 相比之下，1.1 和 2.2 這樣則是不精確的二進制浮點數表示。 最終用戶通常不希望 1.1 + 2.2 的結果會如採用二進制浮點數時那樣顯示為 3.3000000000000003。</li><li>精確性會延續到算術類操作中。 對於 decimal 浮點數，0.1 + 0.1 + 0.1 - 0.3 會精確地等於零。 而對於二進制浮點數，結果則為 5.5511151231257827e-017 。 雖然接近於零，但其中的誤差將妨礙可靠的相等性檢驗，並且誤差還會不斷累積。 因此，decimal 更適合具有嚴格相等不變性要求的會計類應用。</li><li>decimal 模塊包含了有效位的概念，使得 1.30 + 1.20 是 2.50 。 保留尾隨零以表示有效位。 這是貨幣類應用的習慣表示法。 對於乘法，“教科書”方式使用被乘數中的所有數位。 例如， 1.3 * 1.2 給出 1.56 而 1.30 * 1.20 給出 1.5600 。</li><li>與基於硬件的二進制浮點數不同，decimal 模塊具有用戶可更改的精度（默認為28位），可以與給定問題所需的一樣大：</li></ul><pre><code>&gt;&gt;&gt; from decimal import * &gt;&gt;&gt; getcontext().prec = 6 &gt;&gt;&gt; Decimal(1) / Decimal(7) Decimal(&#39;0.142857&#39;)&gt;&gt;&gt; getcontext().prec = 28 &gt;&gt;&gt; Decimal(1) / Decimal(7) Decimal(&#39;0.1428571428571428571428571429&#39;)</code></pre><ul><li>二進制和 decimal 浮點數都是根據已發佈的標準實現的。 雖然內置浮點類型只公開其功能的一小部分，但 decimal 模塊公開了標準的所有必需部分。 在需要時，程序員可以完全控制舍入和信號處理。 這包括通過使用異常來阻止任何不精確操作來強制執行精確算術的選項。</li><li>decimal 模塊旨在支持“無偏差，精確無舍入的十進制算術（有時稱為定點數算術）和有舍入的浮點數算術”。 —— 摘自 decimal 算術規範說明。</li></ul><p><strong>該模塊的設計以三個概念為中心：decimal 數值，算術上下文和信號。</strong></p><p>decimal 數值是不可變對象。 它由符號，係數和指數位組成。 為了保持有效位，係數位不會截去末尾零。 decimal 數值也包括特殊值例如 Infinity ，-Infinity 和 NaN 。 該標準還區分 -0 和 +0 。</p><p>算術的上下文是指定精度、舍入規則、指數限制、指示操作結果的標誌以及確定符號是否被視為異常的陷阱啟用器的環境。 舍入選項包括 ROUND_CEILING 、 ROUND_DOWN 、 ROUND_FLOOR 、 ROUND_HALF_DOWN, ROUND_HALF_EVEN 、 ROUND_HALF_UP 、 ROUND_UP 以及 ROUND_05UP.</p><p>信號是在計算過程中出現的異常條件組。 根據應用程序的需要，信號可能會被忽略，被視為信息，或被視為異常。 十進制模塊中的信號有：Clamped 、 InvalidOperation 、 DivisionByZero 、 Inexact 、 Rounded 、 Subnormal 、 Overflow 、 Underflow 以及 FloatOperation 。對於每個信號，都有一個標誌和一個陷阱啟動器。 遇到信號時，其標誌設置為 1 ，然後，如果陷阱啟用器設置為 1 ，則引發異常。 標誌是粘性的，因此用戶需要在監控計算之前重置它們。</p><h2 class=pgc-h-arrow-right>快速入門教程</h2><p>通常使用 decimal 的方式是先導入該模塊，通過 getcontext() 查看當前上下文，並在必要時為精度、舍入或啟用的陷阱設置新值:</p><pre><code>&gt;&gt;&gt; from decimal import *&gt;&gt;&gt; getcontext()Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])&gt;&gt;&gt; getcontext().prec = 7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Set a new precision</code></pre><p>可以基於整數、字符串、浮點數或元組構造 Decimal 實例。 基於整數或浮點數構造將執行該整數或浮點值的精確轉換。 Decimal 數字包括特殊值例如 NaN 表示“非數字”，正的和負的 Infinity 和 -0</p><pre><code>&gt;&gt;&gt; getcontext().prec = 28&gt;&gt;&gt; Decimal(10)Decimal(&#39;10&#39;)&gt;&gt;&gt; Decimal(&#39;3.14&#39;)Decimal(&#39;3.14&#39;)&gt;&gt;&gt; Decimal(3.14)Decimal(&#39;3.140000000000000124344978758017532527446746826171875&#39;)&gt;&gt;&gt; Decimal((0, (3, 1, 4), -2))Decimal(&#39;3.14&#39;)&gt;&gt;&gt; Decimal(str(2.0 ** 0.5))Decimal(&#39;1.4142135623730951&#39;)&gt;&gt;&gt; Decimal(2) ** Decimal(&#39;0.5&#39;)Decimal(&#39;1.414213562373095048801688724&#39;)&gt;&gt;&gt; Decimal(&#39;NaN&#39;)Decimal(&#39;NaN&#39;)&gt;&gt;&gt; Decimal(&#39;-Infinity&#39;)Decimal(&#39;-Infinity&#39;)</code></pre><p>如果 FloatOperation 信號被捕獲，構造函數中的小數和浮點數的意外混合或排序比較會引發異常</p><pre><code>&gt;&gt;&gt; c = getcontext()&gt;&gt;&gt; c.traps[FloatOperation] = True&gt;&gt;&gt; Decimal(3.14)Traceback (most recent call last):&nbsp; File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.5&#39;) &lt; 3.7Traceback (most recent call last):&nbsp; File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;decimal.FloatOperation: [&lt;class &#39;decimal.FloatOperation&#39;&gt;]&gt;&gt;&gt; Decimal(&#39;3.5&#39;) == 3.5True</code></pre><p>3.3 新版功能.</p><p>新 Decimal 的重要性僅由輸入的位數決定。 上下文精度和舍入僅在算術運算期間發揮作用。</p><pre><code>&gt;&gt;&gt; getcontext().prec = 6&gt;&gt;&gt; Decimal(&#39;3.0&#39;)Decimal(&#39;3.0&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;)Decimal(&#39;3.1415926535&#39;)&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85987&#39;)&gt;&gt;&gt; getcontext().rounding = ROUND_UP&gt;&gt;&gt; Decimal(&#39;3.1415926535&#39;) + Decimal(&#39;2.7182818285&#39;)Decimal(&#39;5.85988&#39;)</code></pre><p>如果超出了 C 版本的內部限制，則構造一個 decimal 將引發 InvalidOperation</p><pre><code>&gt;&gt;&gt; Decimal(&#34;1e9999999999999999999&#34;)Traceback (most recent call last):&nbsp; File &#34;&lt;stdin&gt;&#34;, line 1, in &lt;module&gt;decimal.InvalidOperation: [&lt;class &#39;decimal.InvalidOperation&#39;&gt;]</code></pre><p>在 3.3 版更改.</p><p>Decimal 數字能很好地與 Python 的其餘部分交互。 以下是一個小小的 decimal 浮點數飛行馬戲團：</p><pre><code>&gt;&gt;&gt; data = list(map(Decimal, &#39;1.34 1.87 3.45 2.35 1.00 0.03 9.25&#39;.split()))&gt;&gt;&gt; max(data)Decimal(&#39;9.25&#39;)&gt;&gt;&gt; min(data)Decimal(&#39;0.03&#39;)&gt;&gt;&gt; sorted(data)[Decimal(&#39;0.03&#39;), Decimal(&#39;1.00&#39;), Decimal(&#39;1.34&#39;), Decimal(&#39;1.87&#39;),Decimal(&#39;2.35&#39;), Decimal(&#39;3.45&#39;), Decimal(&#39;9.25&#39;)]&gt;&gt;&gt; sum(data)Decimal(&#39;19.29&#39;)&gt;&gt;&gt; a,b,c = data[:3]&gt;&gt;&gt; str(a)&#39;1.34&#39;&gt;&gt;&gt; float(a)1.34&gt;&gt;&gt; round(a, 1)Decimal(&#39;1.3&#39;)&gt;&gt;&gt; int(a)1&gt;&gt;&gt; a * 5Decimal(&#39;6.70&#39;)&gt;&gt;&gt; a * bDecimal(&#39;2.5058&#39;)&gt;&gt;&gt; c % aDecimal(&#39;0.77&#39;)</code></pre><p>Decimal 也可以使用一些數學函數：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 28&gt;&gt;&gt; Decimal(2).sqrt()Decimal(&#39;1.414213562373095048801688724&#39;)&gt;&gt;&gt; Decimal(1).exp()Decimal(&#39;2.718281828459045235360287471&#39;)&gt;&gt;&gt; Decimal(&#39;10&#39;).ln()Decimal(&#39;2.302585092994045684017991455&#39;)&gt;&gt;&gt; Decimal(&#39;10&#39;).log10()Decimal(&#39;1&#39;)</code></pre><p>quantize() 方法將數字四捨五入為固定指數。 此方法對於將結果舍入到固定的位置的貨幣應用程序非常有用：</p><pre><code>&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;.01&#39;), rounding=ROUND_DOWN)Decimal(&#39;7.32&#39;)&gt;&gt;&gt; Decimal(&#39;7.325&#39;).quantize(Decimal(&#39;1.&#39;), rounding=ROUND_UP)Decimal(&#39;8&#39;)</code></pre><p>如上所示，getcontext() 函數訪問當前上下文並允許更改設置。 這種方法滿足大多數應用程序的需求。</p><p>對於更高級的工作，使用 Context() 構造函數創建備用上下文可能很有用。 要使用備用活動，請使用 setcontext() 函數。</p><p>根據標準，decimal 模塊提供了兩個現成的標準上下文 BasicContext 和 ExtendedContext 。 前者對調試特別有用，因為許多陷阱都已啟用：</p><pre><code>&gt;&gt;&gt; myothercontext = Context(prec=60, rounding=ROUND_HALF_DOWN)&gt;&gt;&gt; setcontext(myothercontext)&gt;&gt;&gt; Decimal(1) / Decimal(7)Decimal(&#39;0.142857142857142857142857142857142857142857142857142857142857&#39;)&gt;&gt;&gt; ExtendedContextContext(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capitals=1, clamp=0, flags=[], traps=[])&gt;&gt;&gt; setcontext(ExtendedContext)&gt;&gt;&gt; Decimal(1) / Decimal(7)Decimal(&#39;0.142857143&#39;)&gt;&gt;&gt; Decimal(42) / Decimal(0)Decimal(&#39;Infinity&#39;)&gt;&gt;&gt; setcontext(BasicContext)&gt;&gt;&gt; Decimal(42) / Decimal(0)Traceback (most recent call last):&nbsp; File &#34;&lt;pyshell#143&gt;&#34;, line 1, in -toplevel-&nbsp;&nbsp;&nbsp; Decimal(42) / Decimal(0)DivisionByZero: x / 0</code></pre><p>上下文還具有用於監視計算期間遇到的異常情況的信號標誌。 標誌保持設置直到明確清除，因此最好通過使用 clear_flags() 方法清除每組受監控計算之前的標誌。:</p><pre><code>&gt;&gt;&gt; setcontext(ExtendedContext)&gt;&gt;&gt; getcontext().clear_flags()&gt;&gt;&gt; Decimal(355) / Decimal(113)Decimal(&#39;3.14159292&#39;)&gt;&gt;&gt; getcontext()Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[])</code></pre><p>flags 條目顯示對 Pi 的有理逼近被舍入（超出上下文精度的數字被拋棄）並且結果是不精確的（一些丟棄的數字不為零）。</p><p>使用上下文的 traps 字段中的字典設置單個陷阱：</p><pre><code>&gt;&gt;&gt; setcontext(ExtendedContext)&gt;&gt;&gt; Decimal(1) / Decimal(0)Decimal(&#39;Infinity&#39;)&gt;&gt;&gt; getcontext().traps[DivisionByZero] = 1&gt;&gt;&gt; Decimal(1) / Decimal(0)Traceback (most recent call last):&nbsp; File &#34;&lt;pyshell#112&gt;&#34;, line 1, in -toplevel-&nbsp;&nbsp;&nbsp; Decimal(1) / Decimal(0)DivisionByZero: x / 0</code></pre><p>大多數程序僅在程序開始時調整當前上下文一次。 並且，在許多應用程序中，數據在循環內單個強制轉換為 Decimal 。 通過創建上下文集和小數，程序的大部分操作數據與其他 Python 數字類型沒有區別。</p><h2 class=pgc-h-arrow-right>Decimal 對象</h2><p>class decimal.<strong>Decimal</strong>(value="0", context=None)根據 value 構造一個新的 Decimal 對象。value 可以是整數，字符串，元組，float ，或另一個 Decimal 對象。 如果沒有給出 value，則返回 Decimal('0')。 如果 value 是一個字符串，它應該在前導和尾隨空格字符以及下劃線被刪除之後符合十進制數字字符串語法:</p><p>sign ::= '+' | '-'</p><p>digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'</p><p>indicator ::= 'e' | 'E'</p><p>digits ::= digit [digit]...</p><p>decimal-part ::= digits '.' [digits] | ['.']</p><p>digits exponent-part ::= indicator [sign]</p><p>digitsinfinity ::= 'Infinity' | 'Inf'</p><p>nan ::= 'NaN' [digits] | 'sNaN' [digits]</p><p>numeric-value ::= decimal-part [exponent-part] | infinity</p><p>numeric-string ::= [sign] numeric-value | [sign] nan</p><p>當上面出現 digit 時也允許其他十進制數碼。 其中包括來自各種其他語言系統的十進制數碼（例如阿拉伯-印地語和天城文的數碼）以及全寬數碼 '\uff10' 到 '\uff19'。如果 value 是一個 tuple ，它應該有三個組件，一個符號（ 0 表示正數或 1 表示負數），一個數字的 tuple 和整數指數。 例如， Decimal((0, (1, 4, 1, 4), -3)) 返回 Decimal('1.414')。如果 value 是 float ，則二進制浮點值無損地轉換為其精確的十進制等效值。 此轉換通常需要53位或更多位數的精度。 例如， Decimal(float('1.1')) 轉換為``Decimal(‘1.100000000000000088817841970012523233890533447265625’)``。</p><p>context 精度不會影響存儲的位數。 這完全由 value 中的位數決定。 例如，Decimal('3.00000') 記錄所有五個零，即使上下文精度只有三。context 參數的目的是確定 value 是格式錯誤的字符串時該怎麼做。 如果上下文陷阱 InvalidOperation，則引發異常；否則，構造函數返回一個新的 Decimal，其值為 NaN。構造完成後， Decimal 對象是不可變的。在 3.2 版更改: 現在允許構造函數的參數為 float 實例。在 3.3 版更改: float 參數在設置 FloatOperation 陷阱時引發異常。 默認情況下，陷阱已關閉。在 3.6 版更改: 允許下劃線進行分組，就像代碼中的整數和浮點文字一樣。十進制浮點對象與其他內置數值類型共享許多屬性，例如 float 和 int 。 所有常用的數學運算和特殊方法都適用。 同樣，十進制對象可以複製、pickle、打印、用作字典鍵、用作集合元素、比較、排序和強制轉換為另一種類型（例如 float 或 int ）。算術對十進制對象和算術對整數和浮點數有一些小的差別。 當餘數運算符 % 應用於Decimal對象時，結果的符號是 被除數 的符號，而不是除數的符號:<strong>>>></strong> (-7) % 4 1<strong>>>></strong> Decimal(-7) % Decimal(4) Decimal('-3')整數除法運算符 // 的行為類似，返回真商的整數部分（截斷為零）而不是它的向下取整，以便保留通常的標識 x == (x // y) * y + x % y:<strong>>>></strong> -7 // 4 -2<strong>>>></strong> Decimal(-7) // Decimal(4) Decimal('-1')% 和 // 運算符實現了 remainder 和 divide-integer 操作（分別），如規範中所述。十進制對象通常不能與浮點數或 fractions.Fraction 實例在算術運算中結合使用：例如,嘗試將 Decimal 加到 float ，將引發 TypeError。 但是，可以使用 Python 的比較運算符來比較 Decimal 實例 x 和另一個數字 y 。 這樣可以避免在對不同類型的數字進行相等比較時混淆結果。在 3.2 版更改: 現在完全支持 Decimal 實例和其他數字類型之間的混合類型比較。除了標準的數字屬性，十進制浮點對象還有許多專門的方法：</p><p><strong>adjusted</strong>()</p><p>在移出係數最右邊的數字之後返回調整後的指數，直到只剩下前導數字：Decimal('321e+5').adjusted() 返回 7 。 用於確定最高有效位相對於小數點的位置。<strong>as_integer_ratio</strong>()</p><p>返回一對 (n, d) 整數，表示給定的 Decimal 實例作為分數、最簡形式項並帶有正分母:<strong>>>></strong> Decimal('-3.14').as_integer_ratio() (-157, 50)轉換是精確的。 在 Infinity 上引發 OverflowError ，在 NaN 上引起 ValueError 。3.6 新版功能.</p><p><strong>as_tuple</strong>()</p><p>返回一個 named tuple 表示的數字： DecimalTuple(sign, digits, exponent)。</p><p><strong>canonical</strong></p><p>()返回參數的規範編碼。 目前，一個 Decimal 實例的編碼始終是規範的，因此該操作返回其參數不變。<strong>compare</strong>(other, context=None)比較兩個 Decimal 實例的值。 compare() 返回一個 Decimal 實例，如果任一操作數是 NaN ，那麼結果是 NaNa <strong>or</strong> b <strong>is</strong> a NaN ==> Decimal('NaN') a &lt; b ==> Decimal('-1') a == b ==> Decimal('0') a > b ==> Decimal('1') <strong>compare_signal</strong>(other, context=None)</p><p>除了所有 NaN 信號之外，此操作與 compare() 方法相同。 也就是說，如果兩個操作數都不是信令NaN，那麼任何靜默的 NaN 操作數都被視為信令NaN。<strong>compare_total</strong>(other, context=None)使用它們的抽象表示而不是它們的數值來比較兩個操作數。 類似於 compare() 方法，但結果給出了一個總排序 Decimal 實例。 兩個 Decimal 實例具有相同的數值但不同的表示形式在此排序中比較不相等：<strong>>>></strong> Decimal('12.0').compare_total(Decimal('12')) Decimal('-1')靜默和發出信號的 NaN 也包括在總排序中。 這個函數的結果是 Decimal('0') 如果兩個操作數具有相同的表示，或是 Decimal('-1') 如果第一個操作數的總順序低於第二個操作數，或是 Decimal('1') 如果第一個操作數在總順序中高於第二個操作數。 有關總排序的詳細信息，請參閱規範。此操作不受上下文影響且靜默：不更改任何標誌且不執行舍入。 作為例外，如果無法準確轉換第二個操作數，則C版本可能會引發InvalidOperation。<strong>compare_total_mag</strong>(other, context=None)比較兩個操作數使用它們的抽象表示而不是它們的值，如 compare_total()，但忽略每個操作數的符號。 x.compare_total_mag(y) 相當於 x.copy_abs().compare_total(y.copy_abs())。此操作不受上下文影響且靜默：不更改任何標誌且不執行舍入。 作為例外，如果無法準確轉換第二個操作數，則C版本可能會引發InvalidOperation。<strong>conjugate</strong>()只返回self，這種方法只符合 Decimal 規範。<strong>copy_abs</strong>()返回參數的絕對值。 此操作不受上下文影響並且是靜默的：沒有更改標誌且不執行舍入。<strong>copy_negate</strong>()回到參數的否定。 此操作不受上下文影響並且是靜默的：沒有標誌更改且不執行舍入。<strong>copy_sign</strong>(other, context=None)返回第一個操作數的副本，其符號設置為與第二個操作數的符號相同。 例如：<strong>>>></strong> Decimal('2.3').copy_sign(Decimal('-1.5')) Decimal('-2.3')此操作不受上下文影響且靜默：不更改任何標誌且不執行舍入。 作為例外，如果無法準確轉換第二個操作數，則C版本可能會引發InvalidOperation。<strong>exp</strong>(context=None)返回給定數字的（自然）指數函數``e**x``的值。結果使用 ROUND_HALF_EVEN 舍入模式正確舍入。<strong>>>></strong> Decimal(1).exp() Decimal('2.718281828459045235360287471')<strong>>>></strong> Decimal(321).exp() Decimal('2.561702493119680037517373933E+139')<strong>from_float</strong>(f)將浮點數轉換為十進制數的類方法。注意， Decimal.from_float(0.1) 與 Decimal(‘0.1’) 不同。 由於 0.1 在二進制浮點中不能精確表示，因此該值存儲為最接近的可表示值，即 0x1.999999999999ap-4 。 十進制的等效值是`0.1000000000000000055511151231257827021181583404541015625`。<strong>註解</strong>從 Python 3.2 開始，Decimal 實例也可以直接從 float 構造。</p><pre><code>&gt;&gt;&gt; Decimal.from_float(0.1) Decimal(&#39;0.1000000000000000055511151231257827021181583404541015625&#39;)&gt;&gt;&gt; Decimal.from_float(float(&#39;nan&#39;)) Decimal(&#39;NaN&#39;)&gt;&gt;&gt; Decimal.from_float(float(&#39;inf&#39;)) Decimal(&#39;Infinity&#39;)&gt;&gt;&gt; Decimal.from_float(float(&#39;-inf&#39;)) Decimal(&#39;-Infinity&#39;)</code></pre><p>3.1 新版功能.</p><p><strong>fma</strong>(other, third, context=None)混合乘法加法。 返回 self*other+third ，中間乘積 self*other 沒有四捨五入。<strong>>>></strong> Decimal(2).fma(3, 5) Decimal('11')<strong>is_canonical</strong>()如果參數是規範的，則為返回 True，否則為 False 。 目前，Decimal 實例總是規範的，所以這個操作總是返回 True 。<strong>is_finite</strong>()如果參數是一個有限的數，則返回為 True ；如果參數為無窮大或 NaN ，則返回為 False。<strong>is_infinite</strong>()如果參數為正負無窮大，則返回為 True ，否則為 False 。<strong>is_nan</strong>()如果參數為 NaN （無論是否靜默），則返回為 True ，否則為 False 。<strong>is_normal</strong>(context=None)如果參數是一個有限正規數，返回 True，如果參數是0、次正規數、無窮大或是NaN，返回 False。<strong>is_qnan</strong>()如果參數為靜默 NaN，返回 True，否則返回 False。<strong>is_signed</strong>()如果參數帶有負號，則返回為 True，否則返回 False。注意，0 和 NaN 都可帶有符號。<strong>is_snan</strong>()如果參數為顯式 NaN，則返回 True，否則返回 False。<strong>is_subnormal</strong>(context=None)如果參數為次正規數，則返回 True，否則返回 False。<strong>is_zero</strong>()如果參數是0（正負皆可），則返回 True，否則返回 False。<strong>ln</strong>(context=None)返回操作數的自然對數（以 e 為底）。結果是使用 ROUND_HALF_EVEN 舍入模式正確四捨五入的。<strong>log10</strong>(context=None)返回操作數的以十為底的對數。結果是使用 ROUND_HALF_EVEN 舍入模式正確四捨五入的。<strong>logb</strong>(context=None)對於一個非零數，返回其運算數的調整後指數作為一個 Decimal 實例。 如果運算數為零將返回 Decimal('-Infinity') 並且產生 the DivisionByZero 標誌。如果運算數是無限大則返回 Decimal('Infinity') 。<strong>logical_and</strong>(other, context=None)logical_and() 是需要兩個 邏輯運算數 的邏輯運算（參考 邏輯操作數 ）。結果是按位輸出的兩運算數的 “和”。<strong>logical_invert</strong>(context=None)logical_invert() 是一個邏輯運算。 結果是按位的倒轉的運算數。<strong>logical_or</strong>(other, context=None)logical_or() 是需要兩個 logical operands 的邏輯運算（請參閱 邏輯操作數 ）。結果是兩個運算數的按位的 or 。<strong>logical_xor</strong>(other, context=None)logical_xor() 是需要兩個 邏輯運算數 的邏輯運算（參考 邏輯操作數 ）。結果是按位輸出的兩運算數的異或運算。<strong>max</strong>(other, context=None)像 max(self, other) 一樣，除了在返回之前應用上下文舍入規則並且用信號通知或忽略 NaN 值（取決於上下文以及它們是發信號還是安靜）。<strong>max_mag</strong>(other, context=None)與 max() 方法相似，但是操作數使用絕對值進行比較。<strong>min</strong>(other, context=None)像 min(self, other) 一樣，除了在返回之前應用上下文舍入規則並且用信號通知或忽略 NaN 值（取決於上下文以及它們是發信號還是安靜）。<strong>min_mag</strong>(other, context=None)與 min() 方法相似，但是操作數使用絕對值進行比較。<strong>next_minus</strong>(context=None)返回小於給定操作數的上下文中可表示的最大數字（或者當前線程的上下文中的可表示的最大數字如果沒有給定上下文）。<strong>next_plus</strong>(context=None)返回大於給定操作數的上下文中可表示的最小數字（或者當前線程的上下文中的可表示的最小數字如果沒有給定上下文）。<strong>next_toward</strong>(other, context=None)如果兩運算數不相等，返回在第二個操作數的方向上最接近第一個操作數的數。如果兩操作數數值上相等，返回將符號設置為與第二個運算數相同的第一個運算數的拷貝。<strong>normalize</strong>(context=None)通過去除尾隨的零並將所有結果等於 Decimal('0') 的轉化為 Decimal('0e0') 來標準化數字。用於為等效類的屬性生成規範值。比如， Decimal('32.100') 和 Decimal('0.321000e+2') 都被標準化為相同的值 Decimal('32.1')。<strong>number_class</strong>(context=None)返回一個字符串描述運算數的 class 。返回值是以下十個字符串中的一個。</p><ul><li>"-Infinity" ，指示操作數為負無窮大。</li><li>"-Normal" ，指示該操作數是負正常數字。</li><li>"-Subnormal" ，指示該操作數是負的次正規數。</li><li>"-Zero" ，指示該操作數是負零。</li><li>"-Zero" ，指示該操作數是正零。</li><li>"+Subnormal" ，指示該操作數是正的次正規數。</li><li>"+Normal" ，指示該操作數是正的正規數。</li><li>"+Infinity" ，指示該運算數是正無窮。</li><li>"NaN" ，指示該運算數是沉寂的 NaN （非數字）。</li><li>"sNaN" ，指示該運算數是信號 NaN 。</li></ul><p><strong>quantize</strong>(exp, rounding=None, context=None)返回的值等於四捨五入的第一個運算數並且具有第二個操作數的指數。<strong>>>></strong> Decimal('1.41421356').quantize(Decimal('1.000')) Decimal('1.414')</p><p><br></p><p>與其他運算不同，如果量化運算後的係數長度大於精度，那麼會發出一個 InvalidOperation 信號。這保證了除非有一個錯誤情況，量化指數恆等於右手運算數的指數。</p><p>與其他運算不同，量化永不信號下溢，即使結果不正常且不精確。</p><p>如果第二個運算數的指數大於第一個運算數的指數那或許需要四捨五入。在這種情況下，舍入模式由給定 rounding 參數決定，其餘的由給定 context 參數決定；如果參數都未給定，使用當前線程上下文的舍入模式。</p><p>每當結果的指數大於 Emax 或小於 Etiny 就會返回錯誤。</p><p><strong>radix</strong>()返回 Decimal(10)，即 Decimal 類進行所有算術運算所用的數制（基數）。 這是為保持與規範描述的兼容性而加入的。<strong>remainder_near</strong>(other, context=None)返回 self 除以 other 的餘數。 這與 self % other 的區別在於所選擇的餘數要使其絕對值最小化。 更準確地說，返回值為 self - n * other 其中 n 是最接近 self / other 的實際值的整數，並且如果兩個整數與實際值的差相等則會選擇其中的偶數。如果結果為零則其符號將為 self 的符號。</p><pre><code>&gt;&gt;&gt; Decimal(18).remainder_near(Decimal(10)) Decimal(&#39;-2&#39;)&gt;&gt;&gt; Decimal(25).remainder_near(Decimal(10)) Decimal(&#39;5&#39;)&gt;&gt;&gt; Decimal(35).remainder_near(Decimal(10)) Decimal(&#39;-5&#39;)</code></pre><p><strong>rotate</strong>(other, context=None)</p><p>返回對第一個操作數的數碼按第二個操作數所指定的數量進行輪轉的結果。 第二個操作數必須為 -precision 至 precision 精度範圍內的整數。 第二個操作數的絕對值給出要輪轉的位數。 如果第二個操作數為正值則向左輪轉；否則向右輪轉。 如有必要第一個操作數的係數會在左側填充零以達到 precision 所指定的長度。 第一個操作數的符號和指數保持不變。<strong>same_quantum</strong>(other, context=None)檢測自身與 other 是否具有相同的指數或是否均為 NaN。此操作不受上下文影響且靜默：不更改任何標誌且不執行舍入。 作為例外，如果無法準確轉換第二個操作數，則C版本可能會引發InvalidOperation。<strong>scaleb</strong>(other, context=None)返回第一個操作數使用第二個操作數對指數進行調整的結果。 等價於返回第一個操作數乘以 10**other 的結果。 第二個操作數必須為整數。<strong>shift</strong>(other, context=None)返回第一個操作數的數碼按第二個操作數所指定的數量進行移位的結果。 第二個操作數必須為 -precision 至 precision 範圍內的整數。 第二個操作數的絕對值給出要移動的位數。 如果第二個操作數為正值則向左移位；否則向右移位。 移入係數的數碼為零。 第一個操作數的符號和指數保持不變。<strong>sqrt</strong>(context=None)返回參數的平方根精確到完整精度。<strong>to_eng_string</strong>(context=None)轉換為字符串，如果需要指數則會使用工程標註法。工程標註法的指數是 3 的倍數。 這會在十進制位的左邊保留至多 3 個數碼，並可能要求添加一至兩個末尾零。例如，此方法會將 Decimal('123E+1') 轉換為 Decimal('1.23E+3')。<strong>to_integral</strong>(rounding=None, context=None)與 to_integral_value() 方法相同。 保留 to_integral 名稱是為了與舊版本兼容。<strong>to_integral_exact</strong>(rounding=None, context=None)舍入到最接近的整數，發出信號 Inexact 或者如果發生舍入則相應地發出信號 Rounded。 如果給出 rounding 形參則由其確定舍入模式，否則由給定的 context 來確定。 如果沒有給定任何形參則會使用當前上下文的舍入模式。<strong>to_integral_value</strong>(rounding=None, context=None)舍入到最接近的整數而不發出 Inexact 或 Rounded 信號。 如果給出 rounding 則會應用其所指定的舍入模式；否則使用所提供的 context 或當前上下文的舍入方法。</p><h3 class=pgc-h-arrow-right>邏輯操作數</h3><p>logical_and(), logical_invert(), logical_or() 和 logical_xor() 方法期望其參數為 邏輯操作數。 邏輯操作數 是指數位與符號位均為零的 Decimal 實例，並且其數字位均為 0 或 1。</p><h2 class=pgc-h-arrow-right>Context 對象</h2><p>上下文是算術運算所在的環境。 它們管理精度、設置舍入規則、確定將哪些信號視為異常，並限制指數的範圍。</p><p>每個線程都有自己的當前上下文，可使用 getcontext() 和 setcontext() 函數來讀取或修改：</p><p>decimal.<strong>getcontext</strong>()返回活動線程的當前上下文。decimal.<strong>setcontext</strong>(c)將活動線程的當前上下文設為 c。你也可以使用 with 語句和 localcontext() 函數來臨時改變活動上下文。decimal.<strong>localcontext</strong>(ctx=None)返回一個上下文管理器，它將在進入 with 語句時將活動線程的當前上下文設為 ctx 的一個副本並在退出 with 語句時恢復之前的上下文。 如果未指定上下文，則會使用當前上下文的一個副本。例如，以下代碼會將當前 decimal 精度設為 42 位，執行一個運算，然後自動恢復之前的上下文:<strong>from</strong> <strong>decimal</strong> <strong>import</strong> localcontext</p><p><br></p><p><strong>with</strong> localcontext() <strong>as</strong> ctx:</p><p>ctx.prec = 42 # Perform a high precision calculation</p><p>s = calculate_something()</p><p>s = +s # Round the final result back to the default precision</p><p><br></p><p>新的上下文也可使用下述的 Context 構造器來創建。 此外，模塊還提供了三種預設的上下文:</p><p>class decimal.<strong>BasicContext</strong>這是由通用十進制算術規範描述所定義的標準上下文。 精度設為九。 舍入設為 ROUND_HALF_UP。 清除所有旗標。 啟用所有陷阱（視為異常），但 Inexact, Rounded 和 Subnormal 除外。由於啟用了許多陷阱，此上下文適用於進行調試。class decimal.<strong>ExtendedContext</strong>這是由通用十進制算術規範描述所定義的標準上下文。 精度設為九。 舍入設為 ROUND_HALF_EVEN。 清除所有旗標。 不啟用任何陷阱（因此在計算期間不會引發異常）。由於禁用了陷阱，此上下文適用於希望結果值為 NaN 或 Infinity 而不是引發異常的應用。 這允許應用在出現當其他情況下會中止程序的條件時仍能完成運行。class decimal.<strong>DefaultContext</strong>此上下文被 Context 構造器用作新上下文的原型。 改變一個字段（例如精度）的效果將是改變 Context 構造器所創建的新上下文的默認值。此上下文最適用於多線程環境。 在線程開始前改變一個字段具有設置全系統默認值的效果。 不推薦在線程開始後改變字段，因為這會要求線程同步避免競爭條件。在單線程環境中，最好完全不使用此上下文。 而是簡單地電顯式創建上下文，具體如下所述。默認值為 prec=28, rounding=ROUND_HALF_EVEN，併為 Overflow, InvalidOperation 和 DivisionByZero 啟用陷阱。在已提供的三種上下文之外，還可以使用 Context 構造器創建新的上下文。class decimal.<strong>Context</strong>(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None)創建一個新上下文。 如果某個字段未指定或為 None，則從 DefaultContext 拷貝默認值。 如果 flags 字段未指定或為 None，則清空所有旗標。prec 為一個 [1, MAX_PREC] 範圍內的整數，用於設置該上下文中算術運算的精度。rounding 選項應為 Rounding Modes 小節中列出的常量之一。traps 和 flags 字段列出要設置的任何信號。 通常，新上下文應當只設置 traps 而讓 flags 為空。Emin 和 Emax 字段給定指數所允許的外部上限。 Emin 必須在 [MIN_EMIN, 0] 範圍內，Emax 在 [0, MAX_EMAX] 範圍內。capitals 字段為 0 或 1 (默認值)。 如果設為 1，指數將附帶打印大寫的 E；其他情況則將使用小寫的 e: Decimal('6.02e+23')。clamp 字段為 0 (默認值) 或 1。 如果設為 1，則 Decimal 實例的指數 e 的表示範圍在此上下文中將嚴格限制為 Emin - prec + 1 &lt;= e &lt;= Emax - prec + 1。 如果 clamp 為 0 則將適用較弱的條件: Decimal 實例調整後的指數最大值為 Emax。 當 clamp 為 1 時，一個較大的普通數值將在可能的情況下減小其指數併為其系統添加相應數量的零，以便符合指數值限制；這可以保持數字值但會丟失有效末尾零的信息。 例如:>>><strong>>>></strong> Context(prec=6, Emax=999, clamp=1).create_decimal('1.23e999') Decimal('1.23000E+999')</p><p><br></p><p>clamp 值為 1 時即允許與在 IEEE 754 中描述的固定寬度十進制交換格式相兼容。</p><p>Context 類定義了幾種通用方法以及大量直接在給定上下文中進行算術運算的方法。 此外，對於上述的每種 Decimal 方法（不包括 adjusted() 和 as_tuple() 方法）都有一個相應的 Context 方法。 例如，對於一個 Context 的實例 C 和 Decimal 的實例 x，C.exp(x) 就等價於 x.exp(context=C)。 每個 Context 方法都接受一個 Python 整數（即 int 的實例）在任何接受 Decimal 的實例的地方使用。</p><p><strong>clear_flags</strong>()將所有旗標重置為 0。<strong>clear_traps</strong>()將所有陷阱重置為零 0。3.3 新版功能.<strong>copy</strong>()返回上下文的一個副本。<strong>copy_decimal</strong>(num)返回 Decimal 實例 num 的一個副本。<strong>create_decimal</strong>(num)基於 num 創建一個新 Decimal 實例但使用 self 作為上下文。 與 Decimal 構造器不同，該上下文的精度、舍入方法、旗標和陷阱會被應用於轉換過程。此方法很有用處，因為常量往往被給予高於應用所需的精度。 另一個好處在於立即執行舍入可以消除超出當前精度的數位所導致的意外效果。 在下面的示例中，使用未舍入的輸入意味著在總和中添加零會改變結果：<strong>>>></strong> getcontext().prec = 3 <strong>>>></strong> Decimal('3.4445') + Decimal('1.0023') Decimal('4.45')<strong>>>></strong> Decimal('3.4445') + Decimal(0) + Decimal('1.0023') Decimal('4.44')</p><p><br></p><p>此方法實現了 IBM 規格描述中的轉換為數字操作。 如果參數為字符串，則不允許有開頭或末尾的空格或下劃線。</p><p><strong>create_decimal_from_float</strong>(f)基於浮點數 f 創建一個新的 Decimal 實例，但會使用 self 作為上下文來執行舍入。 與 Decimal.from_float() 類方法不同，上下文的精度、舍入方法、旗標和陷阱會應用到轉換中。<strong>>>></strong> context = Context(prec=5, rounding=ROUND_DOWN) <strong>>>></strong> context.create_decimal_from_float(math.pi) Decimal('3.1415')<strong>>>></strong> context = Context(prec=5, traps=[Inexact]) <strong>>>></strong> context.create_decimal_from_float(math.pi) Traceback (most recent call last): ... decimal.Inexact: None3.1 新版功能.<strong>Etiny</strong>()返回一個等於 Emin - prec + 1 的值即次正規化結果中的最小指數值。 當發生向下溢出時，指數會設為 Etiny。<strong>Etop</strong>()返回一個等於 Emax - prec + 1 的值。使用 decimal 的通常方式是創建 Decimal 實例然後對其應用算術運算,這些運算髮生在活動線程的當前上下文中。 一種替代方式則是使用上下文的方法在特定上下文中進行計算。 這些方法類似於 Decimal 類的方法，在此僅簡單地重新列出。<strong>abs</strong>(x)返回 x 的絕對值。<strong>add</strong>(x, y)返回 x 與 y 的和。<strong>canonical</strong>(x)返回相同的 Decimal 對象 x。<strong>compare</strong>(x, y)對 x 與 y 進行數值比較。<strong>compare_signal</strong>(x, y)對兩個操作數進行數值比較。<strong>compare_total</strong>(x, y)對兩個操作數使用其抽象表示進行比較。<strong>compare_total_mag</strong>(x, y)對兩個操作數使用其抽象表示進行比較，忽略符號。<strong>copy_abs</strong>(x)返回 x 的副本，符號設為 0。<strong>copy_negate</strong>(x)返回 x 的副本，符號取反。<strong>copy_sign</strong>(x, y)從 y 拷貝符號至 x。<strong>divide</strong>(x, y)返回 x 除以 y 的結果。<strong>divide_int</strong>(x, y)返回 x 除以 y 的結果，截短為整數。<strong>divmod</strong>(x, y)兩個數字相除並返回結果的整數部分。<strong>exp</strong>(x)返回 e ** x。<strong>fma</strong>(x, y, z)返回 x 乘以 y 再加 z 的結果。<strong>is_canonical</strong>(x)如果 x 是規範的則返回 True；否則返回 False。<strong>is_finite</strong>(x)如果 x 為有限數則返回``True``；否則返回 False。<strong>is_infinite</strong>(x)如果 x 是無限的則返回 True；否則返回 False。<strong>is_nan</strong>(x)如果 x 是 qNaN 或 sNaN 則返回 True；否則返回 False。<strong>is_normal</strong>(x)如果 x 是正規數則返回 True；否則返回 False。<strong>is_qnan</strong>(x)如果 x 是靜默 NaN 則返回 True；否則返回 False。<strong>is_signed</strong>(x)x 是負數則返回 True；否則返回 False。<strong>is_snan</strong>(x)如果 x 是顯式 NaN 則返回 True；否則返回 False。<strong>is_subnormal</strong>(x)如果 x 是次標準數則返回 True；否則返回 False。<strong>is_zero</strong>(x)如果 x 為零則返回 True；否則返回 False。<strong>ln</strong>(x)返回 x 的自然對數（以 e 為底）。<strong>log10</strong>(x)返回 x 的以 10 為底的對數。<strong>logb</strong>(x)返回操作數的 MSD 等級的指數。<strong>logical_and</strong>(x, y)在操作數的每個數碼間應用邏輯運算 and。<strong>logical_invert</strong>(x)反轉 x 中的所有數位。<strong>logical_or</strong>(x, y)在操作數的每個數位間應用邏輯運算 or。<strong>logical_xor</strong>(x, y)在操作數的每個數位間應用邏輯運算 xor。<strong>max</strong>(x, y)對兩個值執行數字比較並返回其中的最大值。<strong>max_mag</strong>(x, y)對兩個值執行忽略正負號的數字比較。<strong>min</strong>(x, y)對兩個值執行數字比較並返回其中的最小值。<strong>min_mag</strong>(x, y)對兩個值執行忽略正負號的數字比較。<strong>minus</strong>(x)對應於 Python 中的單目取負運算符執行取負操作。<strong>multiply</strong>(x, y)返回 x 和 y 的積。<strong>next_minus</strong>(x)返回小於 x 的最大數字表示形式。<strong>next_plus</strong>(x)返回大於 x 的最小數字表示形式。<strong>next_toward</strong>(x, y)返回 x 趨向於 y 的最接近的數字。<strong>normalize</strong>(x)將 x 改寫為最簡形式。<strong>number_class</strong>(x)返回 x 的類的表示。<strong>plus</strong>(x)對應於 Python 中的單目前綴取正運算符執行取正操作。 此操作將應用上下文精度和舍入，因此它 不是 標識運算。<strong>power</strong>(x, y, modulo=None)返回 x 的 y 次方，如果給出了模數 modulo 則取其餘數。如為兩個參數則計算 x**y。 如果 x 為負值則 y 必須為整數。 除非 y 為整數且結果為有限值並可在 ‘precision’ 位內精確表示否則結果將是不精確的。 上下文的舍入模式將被使用。 結果在 Python 版中總是會被正確地舍入。在 3.3 版更改: C 模塊計算 power() 時會使用已正確舍入的 exp() 和 ln() 函數。 結果是經過良好定義的，但僅限於“幾乎總是正確地舍入”。帶有三個參數時，計算 (x**y) % modulo。 對於三個參數的形式，參數將會應用以下限制：</p><blockquote><p>三個參數必須都是整數</p><p>y 必須是非負數</p><p>x 或 y 至少有一個不為零</p><p>modulo 必須不為零且至多有 ‘precision’ 位</p></blockquote><p>來自 Context.power(x, y, modulo) 的結果值等於使用無限精度計算 (x**y) % modulo 所得到的值，但其計算過程更高效。 結果的指數為零，無論 x, y 和 modulo 的指數是多少。 結果值總是完全精確的。</p><p><strong>quantize</strong>(x, y)返回的值等於 x (舍入後)，並且指數為 y。<strong>radix</strong>()恰好返回 10，因為這是 Decimal 對象 :)<strong>remainder</strong>(x, y)返回整除所得到的餘數。結果的符號，如果不為零，則與原始除數的符號相同。<strong>remainder_near</strong>(x, y)返回 x - y * n，其中 n 為最接近 x / y 實際值的整數（如結果為 0 則其符號將與 x 的符號相同）。<strong>rotate</strong>(x, y)返回 x 翻轉 y 次的副本。<strong>same_quantum</strong>(x, y)如果兩個操作數具有相同的指數則返回 True。<strong>scaleb</strong>(x, y)返回第一個操作數對第二個值添加其指數後的結果。<strong>shift</strong>(x, y)返回 x 變換 y 次的副本。<strong>sqrt</strong>(x)非負數基於上下文精度的平方根。<strong>subtract</strong>(x, y)返回 x 和 y 的差。<strong>to_eng_string</strong>(x)轉換為字符串，如果需要指數則會使用工程標註法。工程標註法的指數是 3 的倍數。 這會在十進制位的左邊保留至多 3 個數碼，並可能要求添加一至兩個末尾零。<strong>to_integral_exact</strong>(x)舍入到一個整數。<strong>to_sci_string</strong>(x)使用科學計數法將一個數字轉換為字符串。</p><h2 class=pgc-h-arrow-right>舍入模式</h2><p>decimal.<strong>ROUND_CEILING</strong>舍入方向 Infinity。decimal.<strong>ROUND_DOWN</strong>舍入方向為零。decimal.<strong>ROUND_FLOOR</strong>舍入方向為 -Infinity。decimal.<strong>ROUND_HALF_DOWN</strong>舍入到最接近的數，同樣接近則舍入方向為零。decimal.<strong>ROUND_HALF_EVEN</strong>舍入到最接近的數，同樣接近則舍入到最接近的偶數。decimal.<strong>ROUND_HALF_UP</strong>舍入到最接近的數，同樣接近則舍入到零的反方向。decimal.<strong>ROUND_UP</strong>舍入到零的反方向。decimal.<strong>ROUND_05UP</strong>如果最後一位朝零的方向舍入後為 0 或 5 則舍入到零的反方向；否則舍入方向為零。</p><h2 class=pgc-h-arrow-right>信號</h2><p>信號代表在計算期間引發的條件。 每個信號對應於一個上下文旗標和一個上下文陷阱啟用器。</p><p>上下文旗標將在遇到特定條件時被設定。 在完成計算之後，將為了獲得信息而檢測旗標（例如確定計算是否精確）。 在檢測旗標後，請確保在開始下一次計算之前清除所有旗標。</p><p>如果為信號設定了上下文的陷阱啟用器，則條件會導致特定的 Python 異常被引發。 舉例來說，如果設定了 DivisionByZero 陷阱，則當遇到此條件時就將引發 DivisionByZero 異常。</p><p>class decimal.<strong>Clamped</strong></p><p>修改一個指數以符合表示限制。通常，限位將在一個指數超出上下文的 Emin 和 Emax 限制時發生。 在可能的情況下，會通過給係數添加零來將指數縮減至符合限制。class decimal.<strong>DecimalException</strong>其他信號的基類，並且也是 ArithmeticError 的一個子類。class decimal.<strong>DivisionByZero</strong>非無限數被零除的信號。可在除法、取餘隊法或對一個數求負數次冪時發生。 如果此信號未被陷阱捕獲，則返回 Infinity 或 -Infinity 並且由對計算的輸入來確定正負符號。class decimal.<strong>Inexact</strong>表明發生了舍入且結果是不精確的。有非零數位在舍入期間被丟棄的信號。 舍入結果將被返回。 此信號旗標或陷阱被用於檢測結果不精確的情況。class decimal.<strong>InvalidOperation</strong>執行了一個無效的操作。表明請求了一個無意義的操作。 如未被陷阱捕獲則返回 NaN。 可能的原因包括:Infinity - Infinity 0 * Infinity Infinity / Infinity x % 0 Infinity % x sqrt(-x) <strong>and</strong> x > 0 0 ** 0 x ** (non-integer) x ** Infinity</p><p><br></p><p>class decimal.<strong>Overflow</strong></p><p>數值的溢出。表明在發生舍入之後的指數大於 Emax。 如果未被陷阱捕獲，則結果將取決於舍入模式，或者向下舍入為最大的可表示有限數，或者向上舍入為 Infinity。 無論哪種情況，都將引發 Inexact 和 Rounded 信號。class decimal.<strong>Rounded</strong>發生了舍入，但或許並沒有信息丟失。一旦舍入丟棄了數位就會發出此信號；即使被丟棄的數位是零 (例如將 5.00 舍入為 5.0)。 如果未被陷阱捕獲，則不經修改地返回結果。 此信號用於檢測有效位數的丟棄。</p><p>class decimal.<strong>Subnormal</strong></p><p>在舍入之前指數低於 Emin。當操作結果是次標準數（即指數過小）時就會發出此信號。 如果未被陷阱捕獲，則不經修改過返回結果。</p><p>class decimal.<strong>Underflow</strong></p><p>數字向下溢出導致結果舍入到零。當一個次標準數結果通過舍入轉為零時就會發出此信號。 同時還將引發 Inexact 和 Subnormal 信號。</p><p>class decimal.<strong>FloatOperation</strong></p><p>為 float 和 Decimal 的混合啟用更嚴格的語義。如果信號未被捕獲（默認），則在 Decimal 構造器、create_decimal() 和所有比較運算中允許 float 和 Decimal 的混合。 轉換和比較都是完全精確的。 發生的任何混合運算都將通過在上下文旗標中設置 FloatOperation 來靜默地記錄。 通過 from_float() 或 create_decimal_from_float() 進行顯式轉換則不會設置旗標。在其他情況下（即信號被捕獲），則只靜默執行相等性比較和顯式轉換。 所有其他混合運算都將引發 FloatOperation。以下表格總結了信號的層級結構:</p><pre><code>exceptions.ArithmeticError(exceptions.Exception)    DecimalException        Clamped        DivisionByZero(DecimalException, exceptions.ZeroDivisionError)        Inexact            Overflow(Inexact, Rounded)            Underflow(Inexact, Rounded, Subnormal)        InvalidOperation        Rounded        Subnormal        FloatOperation(DecimalException, exceptions.TypeError)</code></pre><h2 class=pgc-h-arrow-right>浮點數說明</h2><h3 class=pgc-h-arrow-right>通過提升精度來緩解舍入誤差</h3><p>使用十進制浮點數可以消除十進制表示錯誤（即能夠完全精確地表示 0.1 這樣的數）；然而，某些運算在非零數位超出給定的精度時仍然可能導致舍入錯誤。</p><p>舍入錯誤的影響可能因接近相互抵銷的加減運算被放大從而導致損失有效位。 Knuth 提供了兩個指導性示例，其中出現了精度不足的浮點算術舍入，導致加法的交換律和分配律被打破：</p><pre><code># Examples from Seminumerical Algorithms, Section 4.2.2.&gt;&gt;&gt; from decimal import Decimal, getcontext&gt;&gt;&gt; getcontext().prec = 8&gt;&gt;&gt; u, v, w = Decimal(11111113), Decimal(-11111111), Decimal(&#39;7.51111111&#39;)&gt;&gt;&gt; (u + v) + wDecimal(&#39;9.5111111&#39;)&gt;&gt;&gt; u + (v + w)Decimal(&#39;10&#39;)&gt;&gt;&gt; u, v, w = Decimal(20000), Decimal(-6), Decimal(&#39;6.0000003&#39;)&gt;&gt;&gt; (u*v) + (u*w)Decimal(&#39;0.01&#39;)&gt;&gt;&gt; u * (v+w)Decimal(&#39;0.0060000&#39;)</code></pre><p>decimal 模塊則可以通過充分地擴展精度來避免有效位的丟失：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 20&gt;&gt;&gt; u, v, w = Decimal(11111113), Decimal(-11111111), Decimal(&#39;7.51111111&#39;)&gt;&gt;&gt; (u + v) + wDecimal(&#39;9.51111111&#39;)&gt;&gt;&gt; u + (v + w)Decimal(&#39;9.51111111&#39;)&gt;&gt;&gt;&gt;&gt;&gt; u, v, w = Decimal(20000), Decimal(-6), Decimal(&#39;6.0000003&#39;)&gt;&gt;&gt; (u*v) + (u*w)Decimal(&#39;0.0060000&#39;)&gt;&gt;&gt; u * (v+w)Decimal(&#39;0.0060000&#39;)</code></pre><h3 class=pgc-h-arrow-right>特殊的值</h3><p>decimal 模塊的數字系統提供了一些特殊的值，包括 NaN, sNaN, -Infinity, Infinity 以及兩種零值 +0 和 -0。</p><p>無窮大可以使用 Decimal('Infinity') 來構建。 它們也可以在不捕獲 DivisionByZero 信號捕獲時通過除以零來產生。 類似地，當不捕獲 Overflow 信號時，也可以通過舍入到超出最大可表示數字限制的方式產生無窮大的結果。</p><p>無窮大是有符號的（仿射）並可用於算術運算，它們會被當作極其巨大的不確定數字來處理。 例如，無窮大加一個常量結果也將為無窮大。</p><p>某些不存在有效結果的運算將會返回 NaN，或者如果捕獲了 InvalidOperation 信號則會引發一個異常。 例如，0/0 會返回 NaN 表示結果“不是一個數字”。 這樣的 NaN 是靜默產生的，並且在產生之後參與其它計算時總是會得到 NaN 的結果。 這種行為對於偶而缺少輸入的各類計算都很有用處 — 它允許在將特定結果標記為無效的同時讓計算繼續運行。</p><p>另一種變體形式是 sNaN，它在每次運算後會發出信號而不是保持靜默。 當對於無效結果需要中斷計算進行特別處理時，這是一個很有用的返回值。</p><p>Python 中比較運算符的行為在涉及 NaN 時可能會令人有點驚訝。 相等性檢測在操作數中有靜默型或信號型 NaN 時總是會返回 False (即使是執行 Decimal('NaN')==Decimal('NaN'))，而不等性檢測總是會返回 True。 當嘗試使用 &lt;, &lt;=, > 或 >= 運算符中的任何一個來比較兩個 Decimal 值時，如果運算數中有 NaN 則將引發 InvalidOperation 信號，如果此信號未被捕獲則將返回 False。 請注意通用十進制算術規範並未規定直接比較行為；這些涉及 NaN 的比較規則來自於 IEEE 854 標準 (見第 5.7 節表 3)。 要確保嚴格符合標準，請改用 compare() 和 compare-signal() 方法。</p><p>有符號零值可以由向下溢出的運算產生。 它們保留符號是為了讓運算結果能以更高的精度傳遞。 由於它們的大小為零，正零和負零會被視為相等，且它們的符號具有信息。</p><p>在這兩個不相同但卻相等的有符號零之外，還存在幾種零的不同表示形式，它們的精度不同但值也都相等。 這需要一些時間來逐漸適應。 對於習慣了標準浮點表示形式的眼睛來說，以下運算返回等於零的值並不是顯而易見的：</p><pre><code>&gt;&gt;&gt; 1 / Decimal(&#39;Infinity&#39;)Decimal(&#39;0E-1000026&#39;)</code></pre><h2 class=pgc-h-arrow-right>使用線程</h2><p>getcontext() 函數會為每個線程訪問不同的 Context 對象。 具有單獨線程上下文意味著線程可以修改上下文 (例如 getcontext().prec=10) 而不影響其他線程。</p><p>類似的 setcontext() 會為當前上下文的目標自動賦值。</p><p>如果在調用 setcontext() 之前調用了 getcontext()，則 getcontext() 將自動創建一個新的上下文在當前線程中使用。</p><p>新的上下文拷貝自一個名為 DefaultContext 的原型上下文。 要控制默認值以便每個線程在應用運行期間都使用相同的值，可以直接修改 DefaultContext 對象。 這應當在任何線程啟動 之前 完成以使得調用 getcontext() 的線程之間不會產生競爭條件。 例如:</p><pre><code># Set applicationwide defaults for all threads about to be launchedDefaultContext.prec = 12DefaultContext.rounding = ROUND_DOWNDefaultContext.traps = ExtendedContext.traps.copy()DefaultContext.traps[InvalidOperation] = 1setcontext(DefaultContext)# Afterwards, the threads can be startedt1.start()t2.start()t3.start(). . .</code></pre><h2 class=pgc-h-arrow-right>例程</h2><p>以下是一些用作工具函數的例程，它們演示了使用 Decimal 類的各種方式:</p><pre><code>def moneyfmt(value, places=2, curr=&#39;&#39;, sep=&#39;,&#39;, dp=&#39;.&#39;,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pos=&#39;&#39;, neg=&#39;-&#39;, trailneg=&#39;&#39;):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Convert Decimal to a money formatted string.&nbsp;&nbsp;&nbsp; places:&nbsp; required number of places after the decimal point&nbsp;&nbsp;&nbsp; curr:&nbsp;&nbsp;&nbsp; optional currency symbol before the sign (may be blank)&nbsp;&nbsp;&nbsp; sep:&nbsp;&nbsp;&nbsp;&nbsp; optional grouping separator (comma, period, space, or blank)&nbsp;&nbsp;&nbsp; dp:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; decimal point indicator (comma or period)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; only specify as blank when places is zero&nbsp;&nbsp;&nbsp; pos:&nbsp;&nbsp;&nbsp;&nbsp; optional sign for positive numbers: &#39;+&#39;, space or blank&nbsp;&nbsp;&nbsp; neg:&nbsp;&nbsp;&nbsp;&nbsp; optional sign for negative numbers: &#39;-&#39;, &#39;(&#39;, space or blank&nbsp;&nbsp;&nbsp; trailneg:optional trailing minus indicator:&nbsp; &#39;-&#39;, &#39;)&#39;, space or blank&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; d = Decimal(&#39;-1234567.8901&#39;)&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;)&nbsp;&nbsp;&nbsp; &#39;-$1,234,567.89&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(d, places=0, sep=&#39;.&#39;, dp=&#39;&#39;, neg=&#39;&#39;, trailneg=&#39;-&#39;)&nbsp;&nbsp;&nbsp; &#39;1.234.568-&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(d, curr=&#39;$&#39;, neg=&#39;(&#39;, trailneg=&#39;)&#39;)&nbsp;&nbsp;&nbsp; &#39;($1,234,567.89)&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(Decimal(123456789), sep=&#39; &#39;)&nbsp;&nbsp;&nbsp; &#39;123 456 789.00&#39;&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; moneyfmt(Decimal(&#39;-0.02&#39;), neg=&#39;&lt;&#39;, trailneg=&#39;&gt;&#39;)&nbsp;&nbsp;&nbsp; &#39;&lt;0.02&gt;&#39;&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; q = Decimal(10) ** -places&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # 2 places --&gt; &#39;0.01&#39;&nbsp;&nbsp;&nbsp; sign, digits, exp = value.quantize(q).as_tuple()&nbsp;&nbsp;&nbsp; result = []&nbsp;&nbsp;&nbsp; digits = list(map(str, digits))&nbsp;&nbsp;&nbsp; build, next = result.append, digits.pop&nbsp;&nbsp;&nbsp; if sign:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(trailneg)&nbsp;&nbsp;&nbsp; for i in range(places):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(next() if digits else &#39;0&#39;)&nbsp;&nbsp;&nbsp; if places:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(dp)&nbsp;&nbsp;&nbsp; if not digits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(&#39;0&#39;)&nbsp;&nbsp;&nbsp; i = 0&nbsp;&nbsp;&nbsp; while digits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(next())&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if i == 3 and digits:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i = 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; build(sep)&nbsp;&nbsp;&nbsp; build(curr)&nbsp;&nbsp;&nbsp; build(neg if sign else pos)&nbsp;&nbsp;&nbsp; return &#39;&#39;.join(reversed(result))def pi():&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Compute Pi to the current precision.&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(pi())&nbsp;&nbsp;&nbsp; 3.141592653589793238462643383&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp; # extra digits for intermediate steps&nbsp;&nbsp;&nbsp; three = Decimal(3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # substitute &#34;three=3.0&#34; for regular floats&nbsp;&nbsp;&nbsp; lasts, t, s, n, na, d, da = 0, three, 3, 1, 0, 0, 24&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; n, na = n+na, na+8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; d, da = d+da, da+32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; t = (t * n) / d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += t&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # unary plus applies the new precisiondef exp(x):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Return e raised to the power of x.&nbsp; Result type matches input type.&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(Decimal(1)))&nbsp;&nbsp;&nbsp; 2.718281828459045235360287471&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(Decimal(2)))&nbsp;&nbsp;&nbsp; 7.389056098930650227230427461&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(2.0))&nbsp;&nbsp;&nbsp; 7.38905609893&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(exp(2+0j))&nbsp;&nbsp;&nbsp; (7.38905609893+0j)&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp;&nbsp;&nbsp; i, lasts, s, fact, num = 0, 0, 1, 1, 1&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fact *= i&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num *= x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += num / fact&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +sdef cos(x):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Return the cosine of x as measured in radians.&nbsp;&nbsp;&nbsp; The Taylor series approximation works best for a small value of x.&nbsp;&nbsp;&nbsp; For larger values, first compute x = x % (2 * pi).&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(cos(Decimal(&#39;0.5&#39;)))&nbsp;&nbsp;&nbsp; 0.8775825618903727161162815826&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(cos(0.5))&nbsp;&nbsp;&nbsp; 0.87758256189&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(cos(0.5+0j))&nbsp;&nbsp;&nbsp; (0.87758256189+0j)&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp;&nbsp;&nbsp; i, lasts, s, fact, num, sign = 0, 0, 1, 1, 1, 1&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fact *= i * (i-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num *= x * x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sign *= -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += num / fact * sign&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +sdef sin(x):&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;Return the sine of x as measured in radians.&nbsp;&nbsp;&nbsp; The Taylor series approximation works best for a small value of x.&nbsp;&nbsp;&nbsp; For larger values, first compute x = x % (2 * pi).&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(sin(Decimal(&#39;0.5&#39;)))&nbsp;&nbsp;&nbsp; 0.4794255386042030002732879352&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(sin(0.5))&nbsp;&nbsp;&nbsp; 0.479425538604&nbsp;&nbsp;&nbsp; &gt;&gt;&gt; print(sin(0.5+0j))&nbsp;&nbsp;&nbsp; (0.479425538604+0j)&nbsp;&nbsp;&nbsp; &#34;&#34;&#34;&nbsp;&nbsp;&nbsp; getcontext().prec += 2&nbsp;&nbsp;&nbsp; i, lasts, s, fact, num, sign = 1, 0, x, 1, x, 1&nbsp;&nbsp;&nbsp; while s != lasts:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lasts = s&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i += 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fact *= i * (i-1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; num *= x * x&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sign *= -1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; s += num / fact * sign&nbsp;&nbsp;&nbsp; getcontext().prec -= 2&nbsp;&nbsp;&nbsp; return +s</code></pre><h2 class=pgc-h-arrow-right>Decimal FAQ</h2><p>Q. 總是輸入 decimal.Decimal('1234.5') 是否過於笨拙。 在使用交互解釋器時有沒有最小化輸入量的方式？</p><p>A. 有些用戶會將構造器簡寫為一個字母：</p><pre><code>&gt;&gt;&gt; D = decimal.Decimal&gt;&gt;&gt; D(&#39;1.23&#39;) + D(&#39;3.45&#39;)Decimal(&#39;4.68&#39;)</code></pre><p>Q. 在帶有兩個十進制位的定點數應用中，有些輸入值具有許多位，需要被舍入。 另一些數則不應具有多餘位，需要驗證有效性。 這種情況應該用什麼方法？</p><p>A. 用 quantize() 方法舍入到固定數量的十進制位。 如果設置了 Inexact 陷阱，它也適用於驗證有效性：</p><pre><code>&gt;&gt;&gt; TWOPLACES = Decimal(10) ** -2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # same as Decimal(&#39;0.01&#39;)&gt;&gt;&gt; # Round to two places&gt;&gt;&gt; Decimal(&#39;3.214&#39;).quantize(TWOPLACES)Decimal(&#39;3.21&#39;)&gt;&gt;&gt; # Validate that a number does not exceed two places&gt;&gt;&gt; Decimal(&#39;3.21&#39;).quantize(TWOPLACES, context=Context(traps=[Inexact]))Decimal(&#39;3.21&#39;)&gt;&gt;&gt; Decimal(&#39;3.214&#39;).quantize(TWOPLACES, context=Context(traps=[Inexact]))Traceback (most recent call last):&nbsp;&nbsp; ...Inexact: None</code></pre><p>Q. 當我使用兩個有效位的輸入時，我要如何在一個應用中保持有效位不變？</p><p>A. 某些運算例如與整數相加、相減和相乘將會自動保留固定的小數位數。 其他運算，例如相除和非整數相乘則將會改變小數位數，需要再加上 quantize() 處理步驟：</p><pre><code>&gt;&gt;&gt; a = Decimal(&#39;102.72&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Initial fixed-point values&gt;&gt;&gt; b = Decimal(&#39;3.17&#39;)&gt;&gt;&gt; a + b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Addition preserves fixed-pointDecimal(&#39;105.89&#39;)&gt;&gt;&gt; a - bDecimal(&#39;99.55&#39;)&gt;&gt;&gt; a * 42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # So does integer multiplicationDecimal(&#39;4314.24&#39;)&gt;&gt;&gt; (a * b).quantize(TWOPLACES)&nbsp;&nbsp;&nbsp;&nbsp; # Must quantize non-integer multiplicationDecimal(&#39;325.62&#39;)&gt;&gt;&gt; (b / a).quantize(TWOPLACES)&nbsp;&nbsp;&nbsp;&nbsp; # And quantize divisionDecimal(&#39;0.03&#39;)</code></pre><p>在開發定點數應用時，更方便的做法是定義處理 quantize() 步驟的函數：</p><pre><code>&gt;&gt;&gt; def mul(x, y, fp=TWOPLACES):... &nbsp;&nbsp;&nbsp; return (x * y).quantize(fp)&gt;&gt;&gt; def div(x, y, fp=TWOPLACES):... &nbsp;&nbsp;&nbsp; return (x / y).quantize(fp)&gt;&gt;&gt; mul(a, b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Automatically preserve fixed-pointDecimal(&#39;325.62&#39;)&gt;&gt;&gt; div(b, a)Decimal(&#39;0.03&#39;)</code></pre><p>Q. 表示同一個值有許多方式。 數字 200, 200.000, 2E2 和 02E+4 的值都相同但有精度不同。 是否有辦法將它們轉換為一個可識別的規範值？</p><p>A. normalize() 方法可將所有相同的值映射為統一表示形式：</p><pre><code>&gt;&gt;&gt; values = map(Decimal, &#39;200 200.000 2E2 .02E+4&#39;.split())&gt;&gt;&gt; [v.normalize() for v in values][Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;), Decimal(&#39;2E+2&#39;)]</code></pre><p>Q. 有些十進制值總是被打印為指數表示形式。 是否有辦法得到一個非指數表示形式？</p><p>A. 對於某些值來說，指數表示形式是表示係數中有效位的唯一辦法。 例如，將 5.0E+3 表示為 5000 可以讓值保持恆定，但是無法顯示原本的兩位有效數字。</p><p>如果一個應用不必關心追蹤有效位，則可以很容易地移除指數和末尾的零，丟棄有效位但讓值保持不變：</p><pre><code>&gt;&gt;&gt; def remove_exponent(d):... &nbsp;&nbsp;&nbsp; return d.quantize(Decimal(1)) if d == d.to_integral() else d.normalize()&gt;&gt;&gt; remove_exponent(Decimal(&#39;5E+3&#39;))Decimal(&#39;5000&#39;)</code></pre><p>Q. 是否有辦法將一個普通浮點數轉換為 Decimal？</p><p>A. 是的，任何二進制浮點數都可以精確地表示為 Decimal 值，但精確的轉換可能需要比直覺設想更高的精度：</p><pre><code>&gt;&gt;&gt; Decimal(math.pi)Decimal(&#39;3.141592653589793115997963468544185161590576171875&#39;)</code></pre><p>Q. 在一個複雜的計算中，我怎樣才能保證不會得到由精度不足和舍入異常所導致的虛假結果。</p><p>A. 使用 decimal 模塊可以很容易地檢測結果。 最好的做法是使用更高的精度和不同的舍入模式重新進行計算。 明顯不同的結果表明存在精度不足、舍入模式問題、不符合條件的輸入或是結果不穩定的算法。</p><p>Q. 我發現上下文精度的應用只針對運算結果而不針對輸入。在混合使用不同精度的值時有什麼需要注意的嗎？</p><p>A. 是的。 原則上所有值都會被視為精確值，在這些值上進行的算術運算也是如此。 只有結果會被舍入。 對於輸入來說其好處是“所輸入即所得”。 而其缺點則是如果你忘記了輸入沒有被舍入，結果看起來可能會很奇怪：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 3&gt;&gt;&gt; Decimal(&#39;3.104&#39;) + Decimal(&#39;2.104&#39;)Decimal(&#39;5.21&#39;)&gt;&gt;&gt; Decimal(&#39;3.104&#39;) + Decimal(&#39;0.000&#39;) + Decimal(&#39;2.104&#39;)Decimal(&#39;5.20&#39;)</code></pre><p>解決辦法是提高精度或使用單目加法運算對輸入執行強制舍入：</p><pre><code>&gt;&gt;&gt; getcontext().prec = 3&gt;&gt;&gt; +Decimal(&#39;1.23456789&#39;)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # unary plus triggers roundingDecimal(&#39;1.23&#39;)</code></pre><p>此外，還可以使用 Context.create_decimal() 方法在創建輸入時執行舍入：</p><pre><code>&gt;&gt;&gt; Context(prec=5, rounding=ROUND_DOWN).create_decimal(&#39;1.2345678&#39;)Decimal(&#39;1.2345</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>python3</a></li><li><a>零學習</a></li><li><a>5.3</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e0ac5fa.html alt=python3從零學習-5.3.5、生成偽隨機數random class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e0ac5fa.html title=python3從零學習-5.3.5、生成偽隨機數random>python3從零學習-5.3.5、生成偽隨機數random</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/947e2ec.html alt=python3從零學習-6.0、第三方庫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/47573fe93d8f4d09b1d7aac5bd4f9fa9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/947e2ec.html title=python3從零學習-6.0、第三方庫>python3從零學習-6.0、第三方庫</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/00b11299.html alt="5.3 正弦函數的性質" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522222314800d6978c0c59 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/00b11299.html title="5.3 正弦函數的性質">5.3 正弦函數的性質</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/15a0a91f.html alt=距昆明僅50公里的化石遺址已有5.3億年，20世紀最驚人的科學發現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e6a294723f3a408b8426f467916bba7b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/15a0a91f.html title=距昆明僅50公里的化石遺址已有5.3億年，20世紀最驚人的科學發現>距昆明僅50公里的化石遺址已有5.3億年，20世紀最驚人的科學發現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/06cfb55.html alt=Deepin-Linux-python3下matplotlib安裝、中文設置、附圖例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fdcd9d946f944a8ea31299402f283145 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/06cfb55.html title=Deepin-Linux-python3下matplotlib安裝、中文設置、附圖例>Deepin-Linux-python3下matplotlib安裝、中文設置、附圖例</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/bd83d9c.html alt=從零學習大六壬之四 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/bd83d9c.html title=從零學習大六壬之四>從零學習大六壬之四</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>