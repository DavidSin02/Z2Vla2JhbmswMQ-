<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心 | 极客快訊</title><meta property="og:title" content="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/9050c2396d10468ba999f16bd70ce041"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/245fb59.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/245fb59.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/245fb59.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/245fb59.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/245fb59.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/245fb59.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/245fb59.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/245fb59.html><meta property="article:published_time" content="2020-10-29T21:04:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:30+08:00"><meta name=Keywords content><meta name=description content="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/245fb59.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>前言</h1><p>在引入一項技術之前，首先必須清楚的是該技術可以為項目解決什麼問題。個人在瞭解消息隊列(Message Queue)之前，以為消息隊列主是用於發送短信、郵件等消息發送(異步解耦)，但深入理解才發現自己的理解錯了，MQ的作用不止體現在一些用戶接收到的具體消息裡，還可用於其它應用的數據發送、通用的業務處理等。消息隊列從字面上意思解讀就是將消息存放到隊列裡，根據隊列FIFO(先入先出)的特性進行消息消費。在實際開發中，是一種跨進程的通信機制，用於應用間的消息傳遞。</p><hr><h1 class=pgc-h-arrow-right>在引入MQ之前，需要了解的優缺點與應用場景</h1><p>MQ的主要優點為<strong>解耦</strong>、<strong>異步</strong>、<strong>削峰</strong>，以下舉一個簡單的場景來反應這幾個特性。</p><div class=pgc-img><img alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9050c2396d10468ba999f16bd70ce041><p class=pgc-img-caption></p></div><p>在微服務項目中，一般會根據核心業務進行系統的垂直拆分再進行單獨部署。在上圖中，各系統在下單業務裡主要負責的內容如下：</p><ul><li>訂單系統：創建訂單，將下單消息(如訂單id、用戶數據)發送到MQ</li><li>MQ：限制每秒的訂單請求處理數(如每秒接收2000個請求但數據庫只能處理1000個則只處理1000個，處理不過來的先在消息隊列裡堆積)</li><li>物流系統：創建訂單物流信息</li><li>積分系統：用戶購物積分信息更新</li></ul><p>想象下以上場景沒有MQ的的存在時創建訂單流程中存在的問題：</p><ul><li>訂單系統創建完訂單信息後要去調用物流系統、積分系統上的業務接口，系統嚴重的<strong>耦合</strong>在一起(解耦)</li><li>訂單系統若非通過線程去調用其它系統的接口，還需同步等待返回浪費不少時間(異步，避免創建線程調用的麻煩)</li><li>用戶高峰期請求過多數據庫處理不過來進而導致應用崩潰(削峰)</li></ul><p>任何事物都有兩面性，雖然MQ可以給系統解決不少問題，但也會引入一些問題，如：</p><ul><li>系統複雜度提高，需要考慮消息重複消費、消息丟失等問題</li><li>數據一致性問題，如上例中的物流或庫存系統寫庫出現異常如何回滾補償</li></ul><p>瞭解了MQ的一些特性後，再討論下幾個適合使用MQ的場景：</p><ul><li>上游系統不關心下游的執行結果(如用戶註冊成功後用戶系統通過MQ向用戶發送郵件，但發送成不成功用戶系統根本不在意)</li><li>依賴於數據的定時任務(如下單後24小時內不支付則取消訂單，申請退款72小時內商家不處理則自動退款)</li></ul><hr><h1 class=pgc-h-arrow-right>引入MQ後的一些問題解決思路</h1><li><strong>消息重複消費(保證消息的冪等性)</strong></li><p class=pgc-end-literature>冪等性：對於同一操作的請求無論請求多少次結果都是一致的，在MQ中的具體體現為同一條消息無論發送都少次都只會被消費一次。</p><p>由於網絡抖動(延遲)的原因消息重複發送的問題是不可避免的，如果在消費端消費時沒有做好消息的冪等性保證就有可能出現重複消費，導致同一條消息被多次消費、寫庫多次的情況。比較常見的做法是為消息添加一個唯一標識(ID)，在消費時根據ID查詢數據庫是否存在該消息記錄，如果不存在再插入消息，存在則不進行插入消費。<br>當生成與消費時間間隔不長時，可使用Redis提高消息冪等性的效率，如：</p><p>1. 消費者消費前根據ID去查詢redis是否存在該消息</p><p>2. 不存在該消息則消費並寫入redis，存在該消息則不消費返回</p><p><br></p><p>關於消息ID：</p><p>1. RocketMQ的每條消息都會配有全局唯一的ID</p><p>2. 如果消息中間件不會生成ID，可考慮一些ID服務(如雪花算法)生成全局唯一ID</p><p>3. 建議ID不與實際業務關聯</p><p>如目前個人工作中負責的消息中心應用是基於MongoDB+RocketMQ的技術架構，MongoDB負責存儲各個應用發送過來的消息(主要為Sms、Email等)，每次消費前通過RocketMQ的Message ID查詢Mongo保證消息冪等性避免重複消費，消費成功後更新DB中的消息狀態。</p><li><strong>消息丟失(消息的可靠性)</strong></li><p>MQ各組件的消息丟失含義都有所不同，導致與解決方案也不一定相同，以kafka、rocket的消息傳遞模型(Producer->Broker->Consumer)為例：</p><ul><li>Producer：消息未持久化到Broker中，或消費者未能成功消費到消息。Kafka可通過更改ack配置解決，rocketMQ中會返回消息發送狀態碼。</li><li>Broker：消息成功傳到到我這裡了，可我因為某些原因(不同的MQ可能因機制問題有不同原因)弄丟了，如果是硬件原因(如宕機、磁盤損壞)建議你copy(集群部署)幾個我</li><li>Consumer：我拿到了消息，但消費失敗了或中途掛掉了沒告訴Broker。可通過各MQ中間件的ACK機制解決。</li></ul><hr><h1 class=pgc-h-arrow-right>基於RocketMQ的簡單例子技術框架與業務模型</h1><p>以下便以一個基於MongoDB+RocketMQ+Eureka+Spring Cloud Config的技術框架並結合使用MQ中的問題搭建一個簡單的消息中心項目案例，其中各組件在項目中的主要作用如下：</p><ul><li>Spring Cloud Config：消息配置(如topic、ConsumerGroup、ProducerGroup)中心。</li><li>Eureka：應用服務註冊中心，負責項目中各服務的發現與提供調用。</li><li>MongoDB：由於消息的事務關係不強且Mongodb格式文檔自由(json存儲，隨意增刪字段)，所以使用Mongodb存儲各個應用發送過來的消息(主要為Sms、Email等)，每次消費前通過RocketMQ的Message ID查詢Mongo保證消息冪等性避免重複消費，消費成功後保存消息。</li><li>RocketMQ：消息接收、存儲、發送。</li></ul><p>下圖為該項目的應用關係模型：</p><div class=pgc-img><img alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/da8b16e55da34842bf773abf65bddafd><p class=pgc-img-caption></p></div><p>消息中心應用：統一通用消息的業務處理應用，如短信發送、郵件發送、員工服務號推送等消息的處理問卷應用：負責員工調查問卷的分發，在該例子中只是一個簡單的消息發送測試應用common：存放各應用通用類，如短信消息類(SmsMessage)、消息常量類config-server-properties：配置中心的配置存放目錄由於該項目主要用於演示一些MQ的功能與使用中的問題解決方式，所以編碼部分比較簡單。</p><h1 class=pgc-h-arrow-right>應用編碼</h1><p><strong class=highlight-text>通用模塊編碼(common)</strong></p><p>主要存放各應用通用類(如實體、常量、配置、功能等)。</p><p><strong>MessageConstant：維護消息常量。</strong></p><pre><code>public interface MessageConstant {    interface System {        String QUESTION = "QUESTION";    }    interface Topic {        String SMS_TOPIC = "rocketmq.topic.sms";        String SMS_TOPIC_TEMPLATE = "${rocketmq.topic.sms}";        String MAIL_TOPIC = "rocketmq.topic.mail";        String MAIL_TOPIC_TEMPLATE = "${rocketmq.topic.mail}";    }    interface Producer {        String SMS_GROUP_TEMPLATE = "${rocketmq.producer.group.sms}";        String MAIL_GROUP_TEMPLATE = "${rocketmq.producer.group.mail}";    }    interface Consumer {        String SMS_GROUP_TEMPLATE = "${rocketmq.consumer.group.sms}";        String MAIL_GROUP_TEMPLATE = "${rocketmq.consumer.group.mail}";    }}</code></pre><p><strong>BaseMessage：基礎消息類，所用的通用消息都需繼承此類方便統一信息的管理</strong></p><pre><code>@Data@Accessors(chain = true)public abstract class BaseMessage implements Serializable {    /**     * 消息源系統:{@link io.wilson.common.message.constant.MessageConstant.System}     */    private String system;}</code></pre><p><strong>SmsMessage：通用短信消息類，短信內容數據載體</strong></p><pre><code>@EqualsAndHashCode(callSuper = true)@Data@Accessors(chain = true)@ToString(callSuper = true)public class SmsMessage extends BaseMessage {    /**     * 短信創建用戶     */    private String createUserId;    /**     * 接收短信用戶     */    private String toUserId;    /**     * 手機號碼     */    private String mobile;    /**     * 短信內容     */    private String content;}</code></pre><p><strong class=highlight-text>消息中心應用(message-center)</strong></p><p>消息中心在進行編碼之前，需確認消息中心該如何進行消息的處理。該項目所處的業務環境是各應用可能都需要發送一些短信消息、郵件、服務號消息等，相同消息的業務處理是一致的，所以消息中心對消息接收消費的主要流程如下：</p><ul><li>保證消息冪等性(查詢數據庫使用已有消息記錄避免重複消費)</li><li>消息業務處理</li><li>消息日誌入庫</li></ul><p>在該項目中，不同的消息類型存儲在不同的Mongodb collection(同Mysql table概念)，但共用一個消息日誌類MessageLog：</p><pre><code>@Data@Accessors(chain = true)public class MessageLog implements Serializable {    private String msgId;    /**     * 發送方系統名稱 {@link io.wilson.common.message.constant.MessageConstant}     */    private String system;    /**     * 消息對象json字符串     */    private String msgContent;    /**     * 業務執行結果     */    private Boolean success;    private LocalDateTime createTime;    private LocalDateTime updateTime;    /**     * 初始化消息記錄     *     * @param message       消息     * @return     */    public static &lt;T extends BaseMessage&gt; MessageLog convertFromMessage(T message) {        LocalDateTime now = LocalDateTime.now();        return new MessageLog()                .setSystem(message.getSystem())                .setSuccess(false)                .setCreateTime(now)                .setUpdateTime(now);    }}</code></pre><p>在該消費流程設計與開發編碼過程中個人考慮的核心點如下：</p><ol start=1><li>如果使用普通消息類(如SmsMessage)作為db存儲的映射對象，會導致消息類摻雜不必要的屬性(如createTime、updateTime、success)，且作為一個通用的消息數據載體，普通消息類更適於作為一個VO而非DO使用，所以消息的處理結果、消息的創建更新時間這些作為原消息上的附加內容，更適合放到其它數據庫映射對象中維護，所以定義了MessageLog作為消息記錄的實體類</li><li>既然是作為各應用都可使用的通用消息所以肯定都會有一定數據量，雖然映射實體都一樣，但存放到不同的collection可以提高操作的便捷性和獲得更好的性能，系統編碼可以更好地根據系統進行消息篩選</li><li>在消息消費流程中，保證消息冪等性和消息日誌入庫這兩步只有數據庫名是不同的，所以可定義一個父Listener進行消息監聽消費的方法抽象，不同消息的業務處理交給不同的消息Service，同一類消息的消費可能會再細分調用不同的消息業務方法消費(如發送單條短信、批量發送短信)，所以可以對各service抽象出一個consume()方法根據參數調用具體的service業務方法進行消息消費</li></ol><p>為了更好地展示消息中心類之間的關係，描繪以下類圖：</p><div class=pgc-img><img alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2dc778fc70144f458e6ce83310468166><p class=pgc-img-caption></p></div><p>當一條短信消息發送到消息中心時，其消費流程如下：</p><div class=pgc-img><img alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d27f5e23855b4241a65f06448b3ca188><p class=pgc-img-caption></p></div><ul><li><strong>消息業務處理編碼</strong></li></ul><p><strong>BaseMessageService：消息業務消費抽象接口，抽象每個消費者(Listener)調用的業務消費方法</strong></p><pre><code>public interface BaseMessageService&lt;T extends BaseMessage&gt; {    /**     * 消費消息     *     * @param message         消息     * @param consumeFunction 消費方法     */    default boolean consume(T message, Function&lt;T, Boolean&gt; consumeFunction) {        return consumeFunction.apply(message);    }}</code></pre><p><strong>BaseMessageService：短信消息業務抽象接口</strong></p><pre><code>@Servicepublic interface SmsMessageService extends BaseMessageService&lt;SmsMessage&gt; {    /**     * 發送單條短信消息     *     * @param smsMessage     * @return 業務處理結果     */    boolean sendSingle(SmsMessage smsMessage);}</code></pre><p><strong>SmsMessageServiceImpl：短信消息業務實現類</strong></p><pre><code>@Service@Slf4jpublic class SmsMessageServiceImpl implements SmsMessageService {    @Override    public boolean sendSingle(SmsMessage smsMessage) {        // 短信業務操作結果        boolean isSuccess = true;        /*         * 短信業務操作並把操作結果設到isSuccess中         */        if (Objects.equals(smsMessage.getToUserId(), "Wilson")) {            isSuccess = false;            log.info("短信發送失敗,消息內容:{}", smsMessage);        }        return isSuccess;    }}</code></pre><ul><li><strong>消息業務處理編碼</strong></li></ul><p><strong>MessageLogConstant：維護MessageLog的相關常量(如不同消息的collection名)</strong></p><pre><code>public interface MessageLogConstant {    /**     * 各消息日誌Mongo集合名     */    interface CollectionName {        String SMS = "sms_message_log";        String MAIL = "mail_message_log";    }}</code></pre><p><strong>AbstractMQStoreListener：保證消息冪等性、消息日誌入庫操作的抽象Listener類方法中</strong></p><pre><code></code></pre><p><strong>SmsMessageListener:短信消息監聽器(消費者)，如在消費過程中拋出異常，RocketMQ會以一定的時間間隔進行重新投遞消費</strong></p><pre><code>@Slf4j@Service@ConditionalOnProperty(MessageConstant.Topic.SMS_TOPIC)@RocketMQMessageListener(topic = MessageConstant.Topic.SMS_TOPIC_TEMPLATE, consumerGroup = MessageConstant.Consumer.SMS_GROUP_TEMPLATE)public class SmsMessageListener extends AbstractMQStoreListener implements RocketMQListener&lt;MessageExt&gt; {    @Resource    private SmsMessageService smsMessageService;    private static final String EXCEPTION_FORMAT = "短信消息消費失敗，消息內容：%s";    @Override    public void onMessage(MessageExt message) {        String msgId = message.getMsgId();        if (isConsumed(msgId)) {            return;        }        SmsMessage smsMessage = JSONObject.parseObject(message.getBody(), SmsMessage.class);        log.info("接收到短信消息{}：{}", msgId, smsMessage);        /*if (Objects.equals(smsMessage.getToUserId(), "2020")) {            log.error("消息{}消費失敗", message.getMsgId());            // 拋出異常讓RocketMQ重新投遞消息重新消費            throw new MQConsumeException(String.format(EXCEPTION_FORMAT, smsMessage));        }*/        boolean isSuccess = smsMessageService.consume(smsMessage, smsMessageService::sendSingle);        if (!isSuccess) {            log.info("短信消息業務操作失敗,消息id: {}", msgId);        }        // 保存消息消費記錄        store(isSuccess, msgId, smsMessage);    }    @Override    protected String collection() {        return MessageLogConstant.CollectionName.SMS;    }}</code></pre><p><strong>MessageCenterApplication:主程序</strong></p><pre><code>@SpringBootApplication@EnableDiscoveryClientpublic class MessageCenterApplication {    public static void main(String[] args) {        SpringApplication.run(MessageCenterApplication.class, args);    }}</code></pre><p><strong>Spring Cloud配置文件bootstrap.yml</strong></p><pre><code>eureka:  client:    service-url:      defaultZone: http://localhost:8000/eurekaspring:  cloud:    config:      discovery:        enabled: true        service-id: config-center      #     資源文件名      profile: dev      name: rocketmq</code></pre><p><strong>SmsSendTest：單元測試類</strong></p><pre><code></code></pre><ul><li><strong>配置中心(config-server)</strong></li></ul><p>主程序ConfigServerApplication</p><pre><code>@SpringBootApplication@EnableDiscoveryClient@EnableConfigServerpublic class ConfigServerApplication {   public static void main(String[] args) {      SpringApplication.run(ConfigServerApplication.class, args);   }}</code></pre><p>Spring Cloud配置文件bootstrap.yml:</p><pre><code>spring:  cloud:    config:      server:        git:          uri: https://gitee.com/Wilson-He/rocketmq-message-center-demo.git          username: Wilson-He          force-pull: true          password:          # 配置文件在uri下的目錄          search-paths: /config-server-propertieseureka:  client:    service-url:      defaultZone: http://localhost:8000/eureka</code></pre><p>配置文件configs-server-properties/rocketmq-dev.properties:</p><pre><code>rocketmq.name-server=127.0.0.1:9876rocketmq.topic.sms=sms-topicrocketmq.producer.group.sms=sms-grouprocketmq.consumer.group.sms=sms-grouprocketmq.topic.mail=mail-topicrocketmq.producer.group.mail=mail-grouprocketmq.consumer.group.mail=mail-group</code></pre><h1 class=pgc-h-arrow-right>運行流程</h1><ol start=1><li>運行RocketMQ name-server與broker,如mqnamesrv -n 127.0.0.1:9876,mqbroker -n 127.0.0.1:9876</li><li>運行eureka應用</li><li>運行配置中心config-server</li><li>運行消息中心message-center</li><li>運行message-center單元測試類(SmsSendTest)或運行question-app訪問localhost:8080/question/toUser?userId=xxx進行消費測試，消息中心控制檯打印出日誌信息與Mongo sms_message_log成功新增了數據即項目搭建完成</li></ol><div class=pgc-img><img alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/38b7fd8074e54102ac5ce22ef4ca4097><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="聊聊MQ與如何基於Spring Boot RocketMQ搭建一個消息中心" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/147ea557bbc840b780259c110753ac5c><p class=pgc-img-caption></p></div><p><strong>(待)擴展點：</strong></p><ol start=1><li>RocketMQ的發送者應用可在配置文件中設置rocketmq.producer.retry-times-when-send-failed/retry-times-when-send-async-failed屬性配置rocketmq同步/異步發送消息失敗後的重試次數，不設置則默認都為2</li><li>當業務執行操作結果失敗時仍然入庫的原因是有時業務執行過程中可能會包含調用第三方的操作，當第三方報錯時會導致業務操作結果失敗，而第三方的操作是不可控的，所以先把報錯結果保存便於追溯，且有業務需要時也可通過定時任務查庫重新執行業務</li><li>該例子中只用了一個消息配置文件，實際開發中消息配置需根據項目所需配置到對應的項目配置文件，如question-app的消息配置(如topc、producerGroup)應在其項目中的配置文件(如application.yml、apollo的namespace)中配置</li><li>該項目中的NameServer、Broker並沒有集群部署，Broker集群部署後配置同步雙寫避免主機寫入後尚未同步到從機就宕機導致消息丟失的情況(有意向的自行百度：RocketMQ 同步雙寫)</li></ol><h1 class=pgc-h-arrow-right>末</h1><p>該文章通過一個簡單的項目例子演示了使用Spring Boot RocketMQ處理MQ常見問題的一些方式：</p><ul><li>消息重複消費問題可通過數據庫存儲來保證冪等性</li><li>若消息消費業務操作失敗時可通過Listener拋出異常讓RocketMQ重新投遞消息進行消費</li></ul><p>該項目例子可通過個人github/gitee(github|gitee.com/wilson-he/rocketmq-message-center-demo)查看</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>MQ</a></li><li><a>Spring</a></li><li><a>Boot</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html alt="Spring Boot 統一異常這樣處理和剖析，安否？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/95dd8dbd-33ff-4c32-a4b5-fd78e6126995 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e61e6b6d.html title="Spring Boot 統一異常這樣處理和剖析，安否？">Spring Boot 統一異常這樣處理和剖析，安否？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html alt="Spring Boot中文參考指南（2.1.6）90、熱交換" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/52221486045249f1a4a361d34e84016e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52b013de.html title="Spring Boot中文參考指南（2.1.6）90、熱交換">Spring Boot中文參考指南（2.1.6）90、熱交換</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe46907e.html alt="Spring Boot實現xml數據格式傳輸" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0d7162206c2444189f24fc0f5fcd469e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe46907e.html title="Spring Boot實現xml數據格式傳輸">Spring Boot實現xml數據格式傳輸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b61684e.html alt="「Spring Boot專題」CORS跨域" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/49f28dea215a4273af5112e80bd79c03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b61684e.html title="「Spring Boot專題」CORS跨域">「Spring Boot專題」CORS跨域</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4207bf0.html alt="基於Spring Boot搭建應用開發框架——基礎架構" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/afeba6d083bb4e78ada213e1b6cd513c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4207bf0.html title="基於Spring Boot搭建應用開發框架——基礎架構">基於Spring Boot搭建應用開發框架——基礎架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d4bf763b.html alt="基礎篇：Spring Boot入門體驗（圖文教程）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RwsEOXvIHX7bQq style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d4bf763b.html title="基礎篇：Spring Boot入門體驗（圖文教程）">基礎篇：Spring Boot入門體驗（圖文教程）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ad16f9.html alt="Spring Boot 入門系列（二十五）讀取配置文件的三種方式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ad16f9.html title="Spring Boot 入門系列（二十五）讀取配置文件的三種方式">Spring Boot 入門系列（二十五）讀取配置文件的三種方式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3312eb6.html alt="Spring Boot 在啟動時進行配置文件加解密" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/677858a9ea4e455e840b8fb8dc7656b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3312eb6.html title="Spring Boot 在啟動時進行配置文件加解密">Spring Boot 在啟動時進行配置文件加解密</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07c6935.html alt="Spring Boot配置文件yml格式詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c60ba743367141da8cddac4cb8bd7412 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07c6935.html title="Spring Boot配置文件yml格式詳解">Spring Boot配置文件yml格式詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ff10d3.html alt="Spring Boot 異步請求和異步調用，一文搞定" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3c824262b5b0401cbf72463bf246c13b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ff10d3.html title="Spring Boot 異步請求和異步調用，一文搞定">Spring Boot 異步請求和異步調用，一文搞定</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b748ad6.html alt="使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ae11deaa7ce44232a1fa67b224125bb2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b748ad6.html title="使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？">使用Spring Boot的事件和事務，容易被忽視的點，你有踩過嗎？</a></li><hr><li><a href=../../tw/%E9%81%8A%E6%88%B2/cd142eb.html alt="Spring Boot入門系列（十三）如何實現事務，極簡版！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p3.pstatp.com/large/pgc-image/15d70cf19e1c4967afc5d49a10def1ce style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/cd142eb.html title="Spring Boot入門系列（十三）如何實現事務，極簡版！">Spring Boot入門系列（十三）如何實現事務，極簡版！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>