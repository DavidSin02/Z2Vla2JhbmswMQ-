<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用 Node.js 寫一個代碼生成器 | 极客快訊</title><meta property="og:title" content="使用 Node.js 寫一個代碼生成器 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/2cba7942e6784844bac56d6b44752c5c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/247e1389.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/247e1389.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/247e1389.html><meta property="article:published_time" content="2020-11-14T20:55:22+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:22+08:00"><meta name=Keywords content><meta name=description content="使用 Node.js 寫一個代碼生成器"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/247e1389.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用 Node.js 寫一個代碼生成器</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>使用 Node.js 寫一個代碼生成器</p><p>背景</p><p>第一次接觸代碼生成器用的是動軟代碼生成器，數據庫設計好之後，一鍵生成後端 curd代碼。之後也用過 CodeSmith , T4。目前市面上也有很多優秀的代碼生成器，而且大部分都提供可視化界面操作。</p><p>自己寫一個的原因是因為要集成到自己寫的一個小工具中，而且使用 Node.js 這種動態腳本語言進行編寫更加靈活。</p><p>原理</p><p>代碼生成器的原理就是：數據 + 模板 => 文件。</p><p>數據一般為數據庫的表字段結構。</p><p>模板的語法與使用的模板引擎有關。</p><p>使用模板引擎將數據和模板進行編譯，編譯後的內容輸出到文件中就得到了一份代碼文件。</p><p>功能</p><p>因為這個代碼生成器是要集成到一個小工具 lazy-mock 內，這個工具的主要功能是啟動一個 mock server 服務，包含curd功能，並且支持數據的持久化，文件變化的時候自動重啟服務以最新的代碼提供 api mock 服務。</p><p>代碼生成器的功能就是根據配置的數據和模板，編譯後將內容輸出到指定的目錄文件中。因為添加了新的文件，mock server 服務會自動重啟。</p><p>還要支持模板的定製與開發，以及使用 CLI 安裝模板。</p><p>可以開發前端項目的模板，直接將編譯後的內容輸出到前端項目的相關目錄下，webpack 的熱更新功能也會起作用。</p><p>模板引擎</p><p>模板引擎使用的是 nunjucks。</p><p>lazy-mock 使用的構建工具是 gulp，使用 gulp-nodemon 實現 mock-server 服務的自動重啟。所以這裡使用 gulp-nunjucks-render 配合 gulp 的構建流程。</p><p>代碼生成</p><p>編寫一個 gulp task ：</p><p><strong>const</strong> rename = require('gulp-rename') <strong>const</strong> nunjucksRender = require('gulp-nunjucks-render') <strong>const</strong> codeGenerate = require('./templates/generate') <strong>const</strong> ServerFullPath = require('./package.json').ServerFullPath; //mock -server項目的絕對路徑 <strong>const</strong> FrontendFullPath = require('./package.json').FrontendFullPath; //前端項目的絕對路徑 <strong>const</strong> nunjucksRenderConfig = { path: 'templates/server', envOptions: { tags: { blockStart: '&lt;%', blockEnd: '%>', variableStart: '&lt;$', variableEnd: '$>', commentStart: '&lt;#', commentEnd: '#>' }, }, ext: '.js', //以上是 nunjucks 的配置 ServerFullPath, FrontendFullPath } gulp.task('code', <strong>function</strong> () { require('events').EventEmitter.defaultMaxListeners = 0 <strong>return</strong> codeGenerate(gulp, nunjucksRender, rename, nunjucksRenderConfig) });</p><blockquote>代碼具體結構細節可以打開 lazy-mock 進行參照</blockquote><p>為了支持模板的開發，以及更靈活的配置，我將代碼生成的邏輯全都放在模板目錄中。</p><p>templates 是存放模板以及數據配置的目錄。結構如下：</p><div class=pgc-img><img alt="使用 Node.js 寫一個代碼生成器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2cba7942e6784844bac56d6b44752c5c></div><p>只生成 lazy-mock 代碼的模板中 ：</p><p>generate.js的內容如下：</p><p><strong>const</strong> path = require('path') <strong>const</strong> CodeGenerateConfig = require('./config').default; <strong>const</strong> Model = CodeGenerateConfig.model; module.exports = <strong>function</strong> <strong>generate</strong>(gulp, nunjucksRender, rename, nunjucksRenderConfig) { nunjucksRenderConfig.data = { model: CodeGenerateConfig.model, config: CodeGenerateConfig.config } <strong>const</strong> ServerProjectRootPath = nunjucksRenderConfig.ServerFullPath; //server <strong>const</strong> serverTemplatePath = 'templates/server/' gulp.src(`${serverTemplatePath}controller.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ControllerRelativePath)); gulp.src(`${serverTemplatePath}service.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Service.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ServiceRelativePath)); gulp.src(`${serverTemplatePath}model.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Model.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ModelRelativePath)); gulp.src(`${serverTemplatePath}db.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '_db.json')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.DBRelativePath)); <strong>return</strong> gulp.src(`${serverTemplatePath}route.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + 'Route.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.RouteRelativePath)); }</p><p>類似：</p><p>gulp.src(`${serverTemplatePath}controller.njk`) .pipe(nunjucksRender(nunjucksRenderConfig)) .pipe(rename(Model.name + '.js')) .pipe(gulp.dest(ServerProjectRootPath + CodeGenerateConfig.config.ControllerRelativePath));</p><p>表示使用 controller.njk 作為模板，nunjucksRenderConfig作為數據（模板內可以獲取到 nunjucksRenderConfig 屬性 data 上的數據）。編譯後進行文件重命名，並保存到指定目錄下。</p><p>model.js 的內容如下：</p><p><strong>var</strong> shortid = require('shortid') <strong>var</strong> Mock = require('mockjs') <strong>var</strong> Random = Mock.Random //必須包含字段id <strong>export</strong> <strong>default</strong> { name: "book", Name: "Book", properties: [ { key: "id", title: "id" }, { key: "name", title: "書名" }, { key: "author", title: "作者" }, { key: "press", title: "出版社" } ], buildMockData: <strong>function</strong> () {//不需要生成設為false <strong>let</strong> data = [] <strong>for</strong> (<strong>let</strong> i = 0; i &lt; 100; i++) { data.push({ id: shortid.generate(), name: Random.cword(5, 7), author: Random.cname(), press: Random.cword(5, 7) }) } <strong>return</strong> data } }</p><p>模板中使用最多的就是這個數據，也是生成新代碼需要配置的地方，比如這裡配置的是 book ，生成的就是關於 book 的curd 的 mock 服務。要生成別的，修改後執行生成命令即可。</p><p>buildMockData 函數的作用是生成 mock 服務需要的隨機數據，在 db.njk 模板中會使用：</p><p>{ "&lt;$ model.name $>":&lt;% <strong>if</strong> model.buildMockData %>&lt;$ model.buildMockData()|dump|safe $>&lt;% <strong>else</strong> %>[]&lt;% endif %> }</p><blockquote>這也是 nunjucks 如何在模板中執行函數</blockquote><p>config.js 的內容如下：</p><p><strong>export</strong> <strong>default</strong> { //server RouteRelativePath: '/src/routes/', ControllerRelativePath: '/src/controllers/', ServiceRelativePath: '/src/services/', ModelRelativePath: '/src/models/', DBRelativePath: '/src/db/' }</p><p>配置相應的模板編譯後保存的位置。</p><p>config/index.js 的內容如下：</p><p><strong>import</strong> model <strong>from</strong> './model'; <strong>import</strong> config <strong>from</strong> './config'; <strong>export</strong> <strong>default</strong> { model, config }</p><p>針對 lazy-mock 的代碼生成的功能就已經完成了，要實現模板的定製直接修改模板文件即可，比如要修改 mock server 服務 api 的接口定義，直接修改 route.njk 文件：</p><p><strong>import</strong> KoaRouter <strong>from</strong> 'koa-router' <strong>import</strong> controllers <strong>from</strong> '../controllers/index.js' <strong>import</strong> PermissionCheck <strong>from</strong> '../middleware/PermissionCheck' <strong>const</strong> router = <strong>new</strong> KoaRouter() router .get('/&lt;$ model.name $>/paged', controllers.&lt;$model.name $>.get&lt;$ model.Name $>PagedList) .get('/&lt;$ model.name $>/:id', controllers.&lt;$ model.name $>.get&lt;$ model.Name $>) .del('/&lt;$ model.name $>/del', controllers.&lt;$ model.name $>.del&lt;$ model.Name $>) .del('/&lt;$ model.name $>/batchdel', controllers.&lt;$ model.name $>.del&lt;$ model.Name $>s) .post('/&lt;$ model.name $>/save', controllers.&lt;$ model.name $>.save&lt;$ model.Name $>) module.exports = router</p><p>模板開發與安裝</p><p>不同的項目，代碼結構是不一樣的，每次直接修改模板文件會很麻煩。</p><p>需要提供這樣的功能：針對不同的項目開發一套獨立的模板，支持模板的安裝。</p><p>代碼生成的相關邏輯都在模板目錄的文件中，模板開發沒有什麼規則限制，只要保證目錄名為 templates，generate.js中導出generate函數即可。</p><p>模板的安裝原理就是將模板目錄中的文件全部覆蓋掉即可。不過具體的安裝分為本地安裝與在線安裝。</p><p>之前已經說了，這個代碼生成器是集成在 lazy-mock 中的，我的做法是在初始化一個新 lazy-mock 項目的時候，指定使用相應的模板進行初始化，也就是安裝相應的模板。</p><p>使用 Node.js 寫了一個 CLI 工具 lazy-mock-cli，已發到 npm ，其功能包含下載指定的遠程模板來初始化新的 lazy-mock 項目。代碼參考（ copy ）了 vue-cli2。代碼不難，說下某些關鍵點。</p><p>安裝 CLI 工具：</p><p>npm install lazy-mock -g</p><p>使用模板初始化項目：</p><p>lazy-mock init d2-admin-pm my-project</p><blockquote>d2-admin-pm 是我為一個前端項目已經寫好的一個模板。</blockquote><p>init 命令調用的是 lazy-mock-init.js 中的邏輯：</p><p><strong>#!/usr/bin/env node</strong> <strong>const</strong> download = require('download-git-repo') <strong>const</strong> program = require('commander') <strong>const</strong> ora = require('ora') <strong>const</strong> exists = require('fs').existsSync <strong>const</strong> rm = require('rimraf').sync <strong>const</strong> path = require('path') <strong>const</strong> chalk = require('chalk') <strong>const</strong> inquirer = require('inquirer') <strong>const</strong> home = require('user-home') <strong>const</strong> fse = require('fs-extra') <strong>const</strong> tildify = require('tildify') <strong>const</strong> cliSpinners = require('cli-spinners'); <strong>const</strong> logger = require('../lib/logger') <strong>const</strong> localPath = require('../lib/local-path') <strong>const</strong> isLocalPath = localPath.isLocalPath <strong>const</strong> getTemplatePath = localPath.getTemplatePath program.usage('&lt;template-name> [project-name]') .option('-c, --clone', 'use git clone') .option('--offline', 'use cached template') program.on('--help', () => { console.log(' Examples:') console.log() console.log(chalk.gray(' # create a new project with an official template')) console.log(' $ lazy-mock init d2-admin-pm my-project') console.log() console.log(chalk.gray(' # create a new project straight from a github template')) console.log(' $ vue init username/repo my-project') console.log() }) <strong>function</strong> <strong>help</strong>() { program.parse(process.argv) <strong>if</strong> (program.args.length &lt; 1) <strong>return</strong> program.help() } help() //模板 <strong>let</strong> template = program.args[0] //判斷是否使用官方模板 <strong>const</strong> hasSlash = template.indexOf('/') > -1 //項目名稱 <strong>const</strong> rawName = program.args[1] //在當前文件下創建 <strong>const</strong> inPlace = !rawName || rawName === '.' //項目名稱 <strong>const</strong> name = inPlace ? path.relative('../', process.cwd()) : rawName //創建項目完整目標位置 <strong>const</strong> to = path.resolve(rawName || '.') <strong>const</strong> clone = program.clone || false //緩存位置 <strong>const</strong> serverTmp = path.join(home, '.lazy-mock', 'sever') <strong>const</strong> tmp = path.join(home, '.lazy-mock', 'templates', template.replace(/[\/:]/g, '-')) <strong>if</strong> (program.offline) { console.log(`> Use cached template at ${chalk.yellow(tildify(tmp))}`) template = tmp } //判斷是否當前目錄下初始化或者覆蓋已有目錄 <strong>if</strong> (inPlace || exists(to)) { inquirer.prompt([{ type: 'confirm', message: inPlace ? 'Generate project in current directory?' : 'Target directory exists. Continue?', name: 'ok' }]).then(answers => { <strong>if</strong> (answers.ok) { run() } }).catch(logger.fatal) } <strong>else</strong> { run() } <strong>function</strong> <strong>run</strong>() { //使用本地緩存 <strong>if</strong> (isLocalPath(template)) { <strong>const</strong> templatePath = getTemplatePath(template) <strong>if</strong> (exists(templatePath)) { generate(name, templatePath, to, err => { <strong>if</strong> (err) logger.fatal(err) console.log() logger.success('Generated "%s"', name) }) } <strong>else</strong> { logger.fatal('Local template "%s" not found.', template) } } <strong>else</strong> { <strong>if</strong> (!hasSlash) { //使用官方模板 <strong>const</strong> officialTemplate = 'lazy-mock-templates/' + template downloadAndGenerate(officialTemplate) } <strong>else</strong> { downloadAndGenerate(template) } } } <strong>function</strong> <strong>downloadAndGenerate</strong>(template) { downloadServer(() => { downloadTemplate(template) }) } <strong>function</strong> <strong>downloadServer</strong>(done) { <strong>const</strong> spinner = ora('downloading server') spinner.spinner = cliSpinners.bouncingBall spinner.start() <strong>if</strong> (exists(serverTmp)) rm(serverTmp) download('wjkang/lazy-mock', serverTmp, { clone }, err => { spinner.stop() <strong>if</strong> (err) logger.fatal('Failed to download server ' + template + ': ' + err.message.trim()) done() }) } <strong>function</strong> <strong>downloadTemplate</strong>(template) { <strong>const</strong> spinner = ora('downloading template') spinner.spinner = cliSpinners.bouncingBall spinner.start() <strong>if</strong> (exists(tmp)) rm(tmp) download(template, tmp, { clone }, err => { spinner.stop() <strong>if</strong> (err) logger.fatal('Failed to download template ' + template + ': ' + err.message.trim()) generate(name, tmp, to, err => { <strong>if</strong> (err) logger.fatal(err) console.log() logger.success('Generated "%s"', name) }) }) } <strong>function</strong> <strong>generate</strong>(name, src, dest, done) { <strong>try</strong> { fse.removeSync(path.join(serverTmp, 'templates')) <strong>const</strong> packageObj = fse.readJsonSync(path.join(serverTmp, 'package.json')) packageObj.name = name packageObj.author = "" packageObj.description = "" packageObj.ServerFullPath = path.join(dest) packageObj.FrontendFullPath = path.join(dest, "front-page") fse.writeJsonSync(path.join(serverTmp, 'package.json'), packageObj, { spaces: 2 }) fse.copySync(serverTmp, dest) fse.copySync(path.join(src, 'templates'), path.join(dest, 'templates')) } <strong>catch</strong> (err) { done(err) <strong>return</strong> } done() }</p><p>判斷了是使用本地緩存的模板還是拉取最新的模板，拉取線上模板時是從官方倉庫拉取還是從別的倉庫拉取。</p><p>一些小問題</p><p>目前代碼生成的相關數據並不是來源於數據庫，而是在 model.js 中簡單配置的，原因是我認為一個 mock server 不需要數據庫，lazy-mock 確實如此。</p><p>但是如果寫一個正兒八經的代碼生成器，那肯定是需要根據已經設計好的數據庫表來生成代碼的。那麼就需要連接數據庫，讀取數據表的字段信息，比如字段名稱，字段類型，字段描述等。而不同關係型數據庫，讀取表字段信息的 sql 是不一樣的，所以還要寫一堆balabala的判斷。可以使用現成的工具 sequelize-auto , 把它讀取的 model 數據轉成我們需要的格式即可。</p><p>生成前端項目代碼的時候，會遇到這種情況：</p><p>某個目錄結構是這樣的：</p><div class=pgc-img><img alt="使用 Node.js 寫一個代碼生成器" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/27eb06ca18b24f87af5366de534841de></div><p>index.js 的內容：</p><p><strong>import</strong> layoutHeaderAside <strong>from</strong> '@/layout/header-aside' <strong>export</strong> <strong>default</strong> { "layoutHeaderAside": layoutHeaderAside, "menu": () => <strong>import</strong>(/* webpackChunkName: "menu" */'@/pages/sys/menu'), "route": () => <strong>import</strong>(/* webpackChunkName: "route" */'@/pages/sys/route'), "role": () => <strong>import</strong>(/* webpackChunkName: "role" */'@/pages/sys/role'), "user": () => <strong>import</strong>(/* webpackChunkName: "user" */'@/pages/sys/user'), "interface": () => <strong>import</strong>(/* webpackChunkName: "interface" */'@/pages/sys/interface') }</p><p>如果添加一個 book 就需要在這裡加上"book": () => import(/* webpackChunkName: "book" */'@/pages/sys/book')</p><p>這一行內容也是可以通過配置模板來生成的，比如模板內容為：</p><p>"&lt;$ model.name $>": () => import(/* webpackChunkName: "&lt;$ model.name $>" */'@/pages&lt;$ model.module $>&lt;$ model.name $>')</p><p>但是生成的內容怎麼加到index.js中呢？</p><p>第一種方法：複製粘貼</p><p>第二種方法：</p><p>這部分的模板為 routerMapComponent.njk ：</p><p>export default { "&lt;$ model.name $>": () => import(/* webpackChunkName: "&lt;$ model.name $>" */'@/pages&lt;$ model.module $>&lt;$ model.name $>') }</p><p>編譯後文件保存到 routerMapComponents 目錄下，比如 book.js</p><p>修改 index.js :</p><p><strong>const</strong> files = require.context('./', true, /\.js$/); <strong>import</strong> layoutHeaderAside <strong>from</strong> '@/layout/header-aside' <strong>let</strong> componentMaps = { "layoutHeaderAside": layoutHeaderAside, "menu": () => <strong>import</strong>(/* webpackChunkName: "menu" */'@/pages/sys/menu'), "route": () => <strong>import</strong>(/* webpackChunkName: "route" */'@/pages/sys/route'), "role": () => <strong>import</strong>(/* webpackChunkName: "role" */'@/pages/sys/role'), "user": () => <strong>import</strong>(/* webpackChunkName: "user" */'@/pages/sys/user'), "interface": () => <strong>import</strong>(/* webpackChunkName: "interface" */'@/pages/sys/interface'), } files.keys().forEach((key) => { <strong>if</strong> (key === './index.js') <strong>return</strong> Object.assign(componentMaps, files(key).default) }) <strong>export</strong> <strong>default</strong> componentMaps</p><blockquote>使用了 require.context</blockquote><p>我目前也是使用了這種方法</p><p>第三種方法：</p><p>開發模板的時候，做特殊處理，讀取原有 index.js 的內容，按行進行分割，在數組的最後一個元素之前插入新生成的內容，注意逗號的處理，將新數組內容重新寫入 index.js 中，注意換行。</p><p>打個廣告</p><p>如果你想要快速的創建一個 mock-server，同時還支持數據的持久化，又不需要安裝數據庫，還支持代碼生成器的模板開發，歡迎試試 lazy-mock 。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>生成器</a></li><li><a>Node</a></li><li><a>js</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c382d8ba.html alt=Node.js錯誤處理模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/512f67b59dea4ffc888df6a86064c804 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c382d8ba.html title=Node.js錯誤處理模式>Node.js錯誤處理模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/122da5e.html alt="Node.js 實現搶票小工具&短信通知提醒（上）「乾貨」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3e88283f-59ea-4552-ad5a-af642291fdd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/122da5e.html title="Node.js 實現搶票小工具&短信通知提醒（上）「乾貨」">Node.js 實現搶票小工具&短信通知提醒（上）「乾貨」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ece3e8.html alt="Node.js 實現搶票小工具&短信通知提醒（下）「乾貨」" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/793cc204-c1e4-41d7-9b9e-810052752b26 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ece3e8.html title="Node.js 實現搶票小工具&短信通知提醒（下）「乾貨」">Node.js 實現搶票小工具&短信通知提醒（下）「乾貨」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae8fa62.html alt=如何使用Node.js各種異步模式與數據庫交互 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3202000408db3cf640af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae8fa62.html title=如何使用Node.js各種異步模式與數據庫交互>如何使用Node.js各種異步模式與數據庫交互</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2dbb2c8.html alt="Node.js 應用故障排查手冊 —— 冗餘配置傳遞引發的內存溢出" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e49bab5e69304add9032153d21d21229 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2dbb2c8.html title="Node.js 應用故障排查手冊 —— 冗餘配置傳遞引發的內存溢出">Node.js 應用故障排查手冊 —— 冗餘配置傳遞引發的內存溢出</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3f0755b.html alt=技術帖：Node.js各種異步模式是如何實現與數據庫交互？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3202000408db3cf640af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3f0755b.html title=技術帖：Node.js各種異步模式是如何實現與數據庫交互？>技術帖：Node.js各種異步模式是如何實現與數據庫交互？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html alt=python安全開發軍規之四：使用安全的隨機數生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bbda123b84db44148aca9d3e26ddf119 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8c3b92d.html title=python安全開發軍規之四：使用安全的隨機數生成器>python安全開發軍規之四：使用安全的隨機數生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ecc07c69.html alt=密碼學基礎——偽隨機數生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/REjHSN258CdIig style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ecc07c69.html title=密碼學基礎——偽隨機數生成器>密碼學基礎——偽隨機數生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92b3d21e.html alt="Three.js ：一款優秀的3D繪圖引擎" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4f9a6b99cb34430d89edb2b8575d8e44 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92b3d21e.html title="Three.js ：一款優秀的3D繪圖引擎">Three.js ：一款優秀的3D繪圖引擎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f5111a77.html alt="js 如何獲取當前瀏覽器的參數值" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f5111a77.html title="js 如何獲取當前瀏覽器的參數值">js 如何獲取當前瀏覽器的參數值</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e9a913d.html alt=零基礎自學js,數據變量 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15332705123158336f89263 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e9a913d.html title=零基礎自學js,數據變量>零基礎自學js,數據變量</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/846135e5.html alt=「廢材小軟件」能夠生成看似通順的文章——“狗屁不通”文章生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8b8deb94ae2f40e8a29448977544fb3f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/846135e5.html title=「廢材小軟件」能夠生成看似通順的文章——“狗屁不通”文章生成器>「廢材小軟件」能夠生成看似通順的文章——“狗屁不通”文章生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37d22f08.html alt="什麼？這軟件1秒鐘可以生成萬字長文！| 狗屁不通文章生成器" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9c11703f12f141d9aeb37bc8f71caad6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37d22f08.html title="什麼？這軟件1秒鐘可以生成萬字長文！| 狗屁不通文章生成器">什麼？這軟件1秒鐘可以生成萬字長文！| 狗屁不通文章生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ebd12f8.html alt=在線仿真手寫文稿生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/037e6191d7d64ce68d87b59280afc56e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ebd12f8.html title=在線仿真手寫文稿生成器>在線仿真手寫文稿生成器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3dc90d82.html alt=寫作神器-手機端狗屁文章生成器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/474f242b499a4f5dbb93a0e67685c6be style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3dc90d82.html title=寫作神器-手機端狗屁文章生成器>寫作神器-手機端狗屁文章生成器</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>