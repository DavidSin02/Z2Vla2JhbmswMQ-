<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>消息隊列MQ面試專題（rabbitmq） | 极客快訊</title><meta property="og:title" content="消息隊列MQ面試專題（rabbitmq） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/S86eRASG4qdgs4"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26710420.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26710420.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/26710420.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26710420.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26710420.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/26710420.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/26710420.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/26710420.html><meta property="article:published_time" content="2020-11-14T21:01:45+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:45+08:00"><meta name=Keywords content><meta name=description content="消息隊列MQ面試專題（rabbitmq）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/26710420.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>消息隊列MQ面試專題（rabbitmq）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>★★★</strong><strong class=highlight-text toutiao-origin=span>建議</strong><strong>星標</strong><strong class=highlight-text toutiao-origin=span>我們</strong><strong>★★★</strong></p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/S86eRASG4qdgs4><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ryxcguy98OEq9e><p><strong>2020年Java原創面試題庫連載中</strong></p><p>【000期】Java最全面試題庫思維導圖</p><p>【001期】JavaSE面試題（一）：面向對象</p><p>【002期】JavaSE面試題（二）：基本數據類型與訪問修飾符</p><p>【003期】JavaSE面試題（三）：JavaSE語法（1）</p><p>【004期】JavaSE面試題（四）：JavaSE語法（3）</p><p>【005期】JavaSE面試題（五）：String類</p><p>【006期】JavaSE面試題（六）：泛型</p><p>【007期】JavaSE面試題（七）：異常</p><p>【008期】JavaSE面試題（八）：集合之List</p><p>【009期】JavaSE面試題（九）：集合之Set</p><p>【010期】JavaSE面試題（十）：集合之Map</p><p>【011期】JavaSE面試題（十一）：多線程（1）</p><p>【012期】JavaSE面試題（十二）：多線程（2）</p><p>【013期】JavaSE面試題（十三）：多線程（3）</p><p>【014期】JavaSE面試題（十四）：基本IO流</p><p>【015期】JavaSE面試題（十五）：網絡IO流</p><p>【016期】JavaSE面試題（十六）：反射</p><p>【017期】JavaSE面試題（十七）：JVM之內存模型</p><p>【018期】JavaSE面試題（十八）：JVM之垃圾回收</p><p>【020期】JavaSE系列面試題彙總（共18篇）</p><p>【019期】JavaWeb面試題（一）：JDBC</p><p>【021期】JavaWeb面試題（二）：HTTP協議</p><p>【022期】JavaWeb面試題（三）：Cookie和Session</p><p>【023期】JavaWeb面試題（四）：JSP</p><p>【024期】JavaWeb面試題（五）：Filter和Listener</p><p>【025期】Java工具面試題（一）：版本控制工具</p><p>【026期】Java工具面試題（二）：項目管理工具</p><p>【027期】Java設計模式面試題</p><p>【028期】JavaWeb系列面試題彙總（共10篇）</p><p>【029期】JavaEE面試題（一）Web應用服務器</p><p>【030期】JavaEE面試題（二）SpringMVC</p><p>【031期】JavaEE面試題（三）Spring（1）</p><p>【032期】JavaEE面試題（四）Spring（2）</p><p>【033期】JaveEE面試題（五）MyBatis</p><p>【034期】JavaEE面試題（六）Hibernate</p><p>【035期】JavaEE面試題（七）SpringBoot（1）</p><p>更多內容，點擊上面藍字查看</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ryxcguy98OEq9e><p><strong>“</strong>我是小羊同學，一個長期在二線城市工作的程序員<strong>”</strong></p><p><strong>“</strong>市場上流行的MQ有：Kafka、ActiveMQ、RabbitMQ、RocketMQ 本文只針對RocketMQ，其他也有很多大同小異的地方<strong>”</strong></p><p>正文：</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>1、什麼是 rabbitmq</strong></h1><p>採用 AMQP 高級消息隊列協議的一種消息隊列技術,最大的特點就是消費並不需要確保提供方存在,實現了服務之間的高度解耦</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>2、為什麼要使用 rabbitmq</strong></h1><ol><li><p>在分佈式系統下具備異步,削峰,負載均衡等一系列高級功能;</p></li><li><p>擁有持久化的機制，進程消息，隊列中的信息也可以保存下來。</p></li><li><p>實現消費者和生產者之間的解耦。</p></li><li><p>對於高併發場景下，利用消息隊列可以使得同步訪問變為串行訪問達到一定量的限流，利於數據庫的操作。</p></li><li><p>可以使用消息隊列達到異步下單的效果，排隊中，後臺進行邏輯下單。</p></li></ol><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>3、使用 rabbitmq 的場景</strong></h1><ol><li><p>服務間異步通信</p></li><li><p>順序消費</p></li><li><p>定時任務</p></li><li><p>請求削峰</p></li></ol><p><strong toutiao-origin=p>4、如何確保消息正確地發送至 RabbitMQ？如何確保消息接收方消費了消息？</strong></p><p>發送方確認模式</p><p>將信道設置成 conﬁrm 模式（發送方確認模式），則所有在信道上發佈的消息都會被指派一個唯一的 ID。</p><p>一旦消息被投遞到目的隊列後，或者消息被寫入磁盤後（可持久化的消息），信道會發送一個確認給生產者（包含消息唯一 ID）。</p><p>如果 RabbitMQ 發生內部錯誤從而導致消息丟失，會發送一條 nack（notacknowledged，未確認）消息。發送方確認模式是異步的，生產者應用程序在等待確認的同時，可以繼續發送消息。當確認消息到達生產者應用程序，生產者應用程序的回調方法就會被觸發來處理確認消息。</p><p>接收方確認機制</p><p>接收方消息確認機制</p><p>消費者接收每一條消息後都必須進行確認（消息接收和消息確認是兩個不同操作）。只有消費者確認了消息，RabbitMQ 才能安全地把消息從隊列中刪除。這裡並沒有用到超時機制，RabbitMQ 僅通過 Consumer 的連接中斷來確認是否需要重新發送消息。也就是說，只要連接不中斷，RabbitMQ 給了 Consumer 足夠長的時間來處理消息。保證數據的最終一致性；</p><p>下面羅列幾種特殊情況</p><p>如果消費者接收到消息，在確認之前斷開了連接或取消訂閱，RabbitMQ 會認為消息沒有被分發，然後重新分發給下一個訂閱的消費者。</p><p>（可能存在消息重複消費的隱患，需要去重）如果消費者接收到消息卻沒有確認消息，連接也未斷開，則 RabbitMQ 認為該消費者繁忙，將不會給該消費者分發更多的消息。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>5、如何避免消息重複投遞或重複消費？</strong></h1><p>在消息生產時，MQ 內部針對每條生產者發送的消息生成一個 inner-msg-id，作為去重的依據（消息投遞失敗並重傳），避免重複的消息進入隊列；在消息消費時，要求消息體中必須要有一個 bizId（對於同一業務全局唯一，如支付 ID、訂單 ID、帖子 ID 等）作為去重的依據，避免同一條消息被重複消費。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>6、消息基於什麼傳輸？</strong></h1><p>由於 TCP 連接的創建和銷燬開銷較大，且併發數受系統資源限制，會造成性能瓶頸。RabbitMQ 使用信道的方式來傳輸數據。信道是建立在真實的 TCP 連接內的虛擬連接，且每條 TCP 連接上的信道數量沒有限制</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>7、消息如何分發？</strong></h1><p>若該隊列至少有一個消費者訂閱，消息將以循環（round-robin）的方式發送給消費者。每條消息只會分發給一個訂閱的消費者（前提是消費者能夠正常處理消息並進行確認）。通過路由可實現多消費的功能</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>8、消息怎麼路由？</strong></h1><p>消息提供方->路由->一至多個隊列</p><p>消息發佈到交換器時，消息將擁有一個路由鍵（routing key），在消息創建時設定。</p><p>通過隊列路由鍵，可以把隊列綁定到交換器上。</p><p>消息到達交換器後，RabbitMQ 會將消息的路由鍵與隊列的路由鍵進行匹配（針對不同的交換器有不同的路由規則）；</p><p>常用的交換器主要分為一下三種</p><p>fanout：如果交換器收到消息，將會廣播到所有綁定的隊列上</p><p>direct：如果路由鍵完全匹配，消息就被投遞到相應的隊列</p><p>topic：可以使來自不同源頭的消息能夠到達同一個隊列。使用 topic 交換器時，可以使用通配符</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>9、如何確保消息不丟失？</strong></h1><p>消息持久化，當然前提是隊列必須持久化</p><p>RabbitMQ 確保持久性消息能從服務器重啟中恢復的方式是，將它們寫入磁盤上的一個持久化日誌文件，當發佈一條持久性消息到持久交換器上時，Rabbit 會在消息提交到日誌文件後才發送響應。</p><p>一旦消費者從持久隊列中消費了一條持久化消息，RabbitMQ 會在持久化日誌中把這條消息標記為等待垃圾收集。如果持久化消息在被消費之前 RabbitMQ 重啟，那麼 Rabbit 會自動重建交換器和隊列（以及綁定），並重新發布持久化日誌文件中的消息到合適的隊列。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>10、使用 RabbitMQ 有什麼好處？</strong></h1><ol><li><p>服務間高度解耦</p></li><li><p>異步通信性能高</p></li><li><p>流量削峰</p></li></ol><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>11、RabbitMQ 的集群</strong></h1><p>鏡像集群模式</p><p>你創建的 queue，無論元數據還是 queue 裡的消息都會存在於多個實例上，然後每次你寫消息到 queue 的時候，都會自動把消息到多個實例的 queue 裡進行消息同步。</p><p>好處在於，你任何一個機器宕機了，沒事兒，別的機器都可以用。壞處在於，第一，這個性能開銷也太大了吧，消息同步所有機器，導致網絡帶寬壓力和消耗很重！第二，這麼玩兒，就沒有擴展性可言了，如果某個 queue 負載很重，你加機器，新增的機器也包含了這個 queue 的所有數據，並沒有辦法線性擴展你的 queue</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>12、mq 的缺點</strong></h1><p>系統可用性降低</p><p>系統引入的外部依賴越多，越容易掛掉，本來你就是 A 系統調用 BCD 三個系統的接口就好了，人 ABCD 四個系統好好的，沒啥問題，你偏加個 MQ 進來，萬一MQ 掛了咋整？MQ 掛了，整套系統崩潰了，你不就完了麼。</p><p>系統複雜性提高</p><p>硬生生加個 MQ 進來，你怎麼保證消息沒有重複消費？怎麼處理消息丟失的情況？怎麼保證消息傳遞的順序性？頭大頭大，問題一大堆，痛苦不已</p><p>一致性問題 A 系統處理完了直接返回成功了，人都以為你這個請求就成功了；但是問題是，要是 BCD 三個系統那裡，BD 兩個系統寫庫成功了，結果 C 系統寫庫失敗了，咋整？你這數據就不一致了。</p><p>所以消息隊列實際是一種非常複雜的架構，你引入它有很多好處，但是也得針對它帶來的壞處做各種額外的技術方案和架構來規避掉，最好之後，你會發現，媽呀，系統複雜度提升了一個數量級，也許是複雜了 10 倍。但是關鍵時刻，用，還是得用的</p><p><strong toutiao-origin=p>13、Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什麼區別？</strong></p><p>對於吞吐量來說kafka和RocketMQ支撐高吞吐，ActiveMQ和RabbitMQ比他們低一個數量級。對於延遲量來說RabbitMQ是最低的。</p><ol><li><p>從社區活躍度按照目前網絡上的資料，RabbitMQ 、activeM 、ZeroMQ 三者中，綜合來看，RabbitMQ 是首選。</p></li><li><p>持久化消息比較ActiveMq 和RabbitMq 都支持。持久化消息主要是指我們機器在不可抗力因素等情況下掛掉了，消息不會丟失的機制。</p></li><li><p>綜合技術實現</p><p>可靠性、靈活的路由、集群、事務、高可用的隊列、消息排序、問題追蹤、可視化管理工具、插件系統等等。</p><p>RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。當然ZeroMq 也可以做到，不過自己必須手動寫代碼實現，代碼量不小。尤其是可靠性中的：持久性、投遞確認、發佈者證實和高可用性。</p></li><li><p>高併發毋庸置疑，RabbitMQ 最高，原因是它的實現語言是天生具備高併發高可用的erlang 語言。</p></li><li><p>比較關注的比較， RabbitMQ 和 KafkaRabbitMq 比Kafka 成熟，在可用性上，穩定性上，可靠性上， RabbitMq 勝於 Kafka （理論上）。另外，Kafka 的定位主要在日誌等方 面， 因為Kafka 設計的初衷就是處理日誌的，可以看做是一個日誌（消息）系統一個重要組件，針對性很強，所以 如果業務方面還是建議選擇 RabbitMq 。還有就是，Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出來很多</p></li></ol><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>14、如何保證高可用的？</strong></h1><p>RabbitMQ 是比較有代表性的，因為是基於主從（非分佈式）做高可用性的，我們就以 RabbitMQ 為例子講解第一種 MQ 的高可用性怎麼實現。RabbitMQ 有三種模式：單機模式、普通集群模式、鏡像集群模式。</p><p>單機模式，就是 Demo 級別的，一般就是你本地啟動了玩玩兒的?，沒人生產用單機模式普通集群模式，意思就是在多臺機器上啟動多個</p><p>RabbitMQ 實例，每個機器啟動一個。你創建的queue，只會放在一個 RabbitMQ 實例上，但是每個實例都同步 queue 的元數據（元數據可以認為是queue 的一些配置信息，通過元數據，可以找到 queue 所在實例）。你消費的時候，實際上如果連接到了另外一個實例，那麼那個實例會從 queue 所在實例上拉取數據過來。這方案主要是提高吞吐量的，就是說讓集群中多個節點來服務某個 queue 的讀寫操作。</p><p>鏡像集群模式：這種模式，才是所謂的 RabbitMQ 的高可用模式。跟普通集群模式不一樣的是，在鏡像集群模式下，你創建的 queue，無論元數據還是 queue 裡的消息都會存在於多個實例上，就是說，每個 RabbitMQ 節點都有這個 queue 的一個完整鏡像，包含 queue 的全部數據的意思。然後每次你寫消息到 queue 的時候，都會自動把消息同步到多個實例的 queue 上。RabbitMQ 有很好的管理控制檯，就是在後臺新增一個策略，這個策略是鏡像集群模式的策略，指定的時候是可以要求數據同步到所有節點的，也可以要求同步到指定數量的節點，再次創建 queue 的時候，應用這個策略，就會自動將數據同步到其他的節點上去了。這樣的話，好處在於，你任何一個機器宕機了，沒事兒，其它機器（節點）還包含了這個 queue 的完整數據，別的 consumer 都可以到其它節點上去消費數據。壞處在於，第一，這個性能開銷也太大了吧，消息需要同步到所有機器上，導致網絡帶寬壓力和消耗很重！RabbitMQ 一個 queue 的數據都是放在一個節點裡的，鏡像集群下，也是每個節點都放這個 queue 的完整數據</p><p>Kafka 一個最基本的架構認識：由多個 broker 組成，每個 broker 是一個節點；你創建一個 topic，這個 topic 可以劃分為多個 partition， 每個 partition 可以存在於不同的 broker 上，每個 partition 就放一部分數據。這就是天然的分佈式消息隊列，就是說一個 topic 的數據， 是分散放在多個機器上的，每個機器就放一部分數據。Kafka 0.8 以後，提供了 HA 機制，就是 replica（複製品） 副本機制。每個partition 的數據都會同步到其它機器上，形成自己的多個 replica 副本。所有 replica 會選舉一個leader 出來，那麼生產和消費都跟這個 leader 打交道，然後其他 replica 就是 follower。寫的時候，leader 會負責把數據同步到所有 follower 上去，讀的時候就直接讀 leader 上的數據即</p><p>可。只能讀寫leader？很簡單，要是你可以隨意讀寫每個 follower，那麼就要 care 數據一致性的問題，系統複雜度太高，很容易出問題。</p><p>Kafka 會均勻地將一個 partition 的所有 replica 分佈在不同的機器上，這樣才可以提高容錯性。因為如果某個 broker 宕機了，沒事兒，那個 broker上面的 partition 在其他機器上都</p><p>有副本的，如果這上面有某個 partition 的 leader，那麼此時會從 follower 中重新選舉一個新的 leader出來，大家繼續讀寫那個新的leader 即可。這就有所謂的高可用性了。寫數據的時候，生產者就寫leader，然後 leader 將數據落地寫本地磁盤，接著其他 follower 自己主動從 leader 來 pull 數據。一旦所有 follower 同步好數據了，就會發送 ack 給 leader，leader 收到所有 follower 的 ack 之後，就會返回寫成功的消息給生產者。（當然，這只是其中一種模式，還可以適當調整這個行為）消費的時候，只會從 leader 去讀，但是隻有當一個消息已經被所有 follower 都同步成功返回 ack 的時候，這個消息才會被消費者讀到</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>15、如何保證消息的可靠傳輸？如果消息丟了怎麼辦</strong></h1><p>數據的丟失問題，可能出現在生產者、MQ、消費者中</p><p>生產者丟失：生產者將數據發送到 RabbitMQ 的時候，可能數據就在半路給搞丟了，因為網絡問題啥的，都有可能。此時可以選擇用RabbitMQ 提供的事務功能，就是生產者發送數據之前開啟 RabbitMQ事務channel.txSelect，然後發送消息，如果消息沒有成功被RabbitMQ 接收到，那麼生產者會收到異常報錯，此時就可以回滾事務channel.txRollback，然後重試發送消息；如果收到了消息，那麼可以提交事務channel.txCommit。吞吐量會下來，因為太耗性能。所以一般來說，如果你要確保說寫RabbitMQ 的消息別丟，可以開啟conﬁrm模式，在生產者那裡設置開啟conﬁrm模式之後，你每次寫的消息都會分配一個唯一的 id，然後如果寫入了 RabbitMQ 中，</p><p>RabbitMQ 會給你回傳一個ack消息，告訴你說這個消息 ok 了。如果 RabbitMQ 沒能處理這個消息，會回調你一個nack接口，告訴你這個消息接收失敗，你可以重試。而且你可以結合這個機制自己在內存裡維護每個消息 id 的狀態，如果超過一定時間還沒接收到這個消息的回調，那麼你可以重發。事務機制和cnoﬁrm機制最大的不同在於，事務機制是同步的，你提交一個事務之後會阻塞在那兒，但是conﬁrm機 制是異步的，你發送個消息之後就可以發送下一個消息，然後那個消息RabbitMQ 接收了之後會異步回調你一個接口通知你這個消息接收到了。所以一般在生產者這塊避免數據丟失，都是用conﬁrm機制的</p><p>MQ中丟失：就是 RabbitMQ 自己弄丟了數據，這個你必須開啟 RabbitMQ 的持久化，就是消息寫入之後會持久化到磁盤，哪怕是</p><p>RabbitMQ 自己掛了，恢復之後會自動讀取之前存儲的數據，一般數據不會丟。設置持久化有兩個步驟：創建 queue 的時候將其設置為持久化，這樣就可以保證 RabbitMQ 持久化 queue 的元數據，但是不會持久化 queue 裡的數據。第二個是發送消息的時候將消息的deliveryMode 設置為 2，就是將消息設置為持久化的，此時 RabbitMQ 就會將消息持久化到磁盤上去。必須要同時設置這兩個持久化才</p><p>行，RabbitMQ 哪怕是掛了，再次重啟，也會從磁盤上重啟恢復queue，恢復這個 queue 裡的數據。持久化可以跟生產者那邊的conﬁrm機制配合起來，只有消息被持久化到磁盤之後，才會通知生產者ack了，所以哪怕是在持久化到磁盤之前，RabbitMQ 掛了，數據丟了，生產者收不到ack，你也是可以自己重發的。注意，哪怕是你給 RabbitMQ 開啟了持久化機制，也有一種可能，就是這個消息寫到了 RabbitMQ 中，但是還沒來得及持久化到磁盤上，結果不巧，此時RabbitMQ 掛了，就會導致內存裡的一點點數據丟失</p><p>消費端丟失：你消費的時候，剛消費到，還沒處理，結果進程掛了，比如重啟了，那麼就尷尬了，RabbitMQ 認為你都消費了，這數據就丟了。這個時候得用 RabbitMQ 提供的ack機制，簡單來說，就是你關閉 RabbitMQ 的自動ack，可以通過一個 api 來調用就行，然後每次你自己代碼裡確保處理完的時候，再在程序裡ack一把。這樣的話，如果你還沒處理完，不就沒有ack？那 RabbitMQ 就認為你還沒處理完， 這個時候 RabbitMQ 會把這個消費分配給別的 consumer 去處理，消息是不會丟的</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAvzzjP6xe39E8><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>16、如何保證消息的順序性</strong></h1><p>先看看順序會錯亂的場景：RabbitMQ：一個 queue，多個 consumer，這不明顯亂了；</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAvzzjlEzufC5Y><p>解決：</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAw003sHeOyObL><p><strong toutiao-origin=p>17、如何解決消息隊列的延時以及過期失效問題？消息隊列滿了以後該怎麼處理？有幾百萬 消息持續積壓幾小時，說說怎麼解決</strong></p><p>消息積壓處理辦法：臨時緊急擴容：先修復 consumer 的問題，確保其恢復消費速度，然後將現有 cnosumer 都停掉。新建一個 topic，partition 是原來的 10 倍，臨時建立好原先 10 倍的 queue 數量。然後寫一個臨時的分發數據的 consumer 程序，這個程序部署上去消費積壓的數據，消費之後不做耗時的處理，直接均勻輪詢寫入臨時建立好的 10 倍數量的 queue。</p><p>接著臨時徵用 10 倍的機器來部署 consumer，每一批 consumer 消費一個臨時 queue 的數據。這種做法相當於是臨時將 queue 資源和consumer 資源擴大 10 倍，以正常的 10 倍速度來消費數據。等快速消費完積壓數據之後，得恢復原先部署的架構，重新用原先的consumer 機器來消費消息。MQ中消息失效：假設你用的是 RabbitMQ，RabbtiMQ 是可以設置過期時間的，也就是 TTL。如果消息在queue 中積壓超過一定的時間就會被 RabbitMQ 給清理掉，這個數據就沒了。那這就是第二個坑了。這就不是說數據會大量積壓在 mq裡，而是大量的數據會直接搞丟。我們可以採取一個方案，就是批量重導，這個我們之前線上也有類似的場景幹過。就是大量積壓的時候， 我們當時就直接丟棄數據了，然後等過了高峰期以後，比如大家一起喝咖啡熬夜到晚上12點以後，用戶都睡覺了。這個時候我們就開始寫程序，將丟失的那批數據，寫個臨時程序，一點一點的查出來，然後重新灌入 mq 裡面去，把白天丟的數據給他補回來。也只能是這樣了。假設 1 萬個訂單積壓在 mq 裡面，沒有處理，其中 1000個訂單都丟了，你只能手動寫程序把那 1000 個訂單給查出來，手動發到 mq 裡去再補一次</p><p>mq消息隊列塊滿了：如果消息積壓在 mq 裡，你很長時間都沒有處理掉，此時導致 mq 都快寫滿了，咋辦？這個還有別的辦法嗎？沒有， 誰讓你第一個方案執行的太慢了，你臨時寫程序，接入數據來消費，消費一個丟棄一個，都不要了，快速消費掉所有的消息。然後走第二個方案，到了晚上再補數據吧</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>18、設計MQ的思路</strong></h1><p>比如說這個消息隊列系統，我們從以下幾個角度來考慮一下：首先這個 mq 得支持可伸縮性吧，就是需要的時候快速擴容，就可以增加吞吐量和容量，那怎麼搞？設計個分佈式的系統唄，參照一下kafka 的設計理念，broker -> topic -> partition，每個 partition 放一個機器，就存一部分數據。如果現在資源不夠了，簡單啊，給 topic增加 partition，然後做數據遷移，增加機器，不就可以存放更多數據，提供更高的吞吐量了？</p><p>其次你得考慮一下這個 mq 的數據要不要落地磁盤吧？那肯定要了，落磁盤才能保證別進程掛了數據就丟了。那落磁盤的時候怎麼落啊？順序寫，這樣就沒有磁盤隨機讀寫的尋址開銷，磁盤順序讀寫的性能是很高的，這就是 kafka 的思路。其次你考慮一下你的 mq 的可用性啊？這個事兒，具體參考之前可用性那個環節講解的 kafka 的高可用保障機制。多副本 -> leader & follower -> broker 掛了重新選舉 leader 即可對外服務。能不能支持數據 0 丟失啊？可以的，參考我們之前說的那個 kafka 數據零丟失方案</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>19、什麼是Message？</strong></h1><p>消息，消息是不具名的，它由消息頭和消息體組成。消息體是不透明的，而消息頭則由一系列的可選屬性組成，這些屬性包括 routing- key（路由鍵）、 priority（相對於其他消息的優先權）、 delivery-mode（指出該消息可能需要持久性存儲）等。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>20、什麼是Publisher ？</strong></h1><p>消息的生產者，也是一個向交換器發佈消息的客戶端應用程序。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>21、什麼是Exchange（將消息路由給隊列 ）</strong></h1><p>交換器，用來接收生產者發送的消息並將這些消息路由給服務器中的隊列</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>22、什麼是Binding（消息隊列和交換器之間的關聯）</strong></h1><p>綁定，用於消息隊列和交換器之間的關聯。一個綁定就是基於路由鍵將交換器和消息隊列連接起來的路由規則，所以可以將交換器理解成一個由綁定構成的路由表</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>23、什麼是Queue？</strong></h1><p>消息隊列，用來保存消息直到發送給消費者。它是消息的容器，也是消息的終點。一個消息可投入一個或多個隊列。消息一直在隊列裡面，等待消費者連接到這個隊列將其取走</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>24、什麼是Connection ？</strong></h1><p>網絡連接，比如一個 TCP 連接。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>25、什麼是Channel？</strong></h1><p>信道， 多路複用連接中的一條獨立的雙向數據流通道。信道是建立在真實的 TCP 連接內地虛擬連接， AMQP 命令都是通過信道發出去的， 不管是發佈消息、訂閱隊列還是接收消息，這些動作都是通過信道完成。因為對於操作系統來說建立和銷燬 TCP 都是非常昂貴的開銷，所以引入了信道的概念，以複用一條 TCP 連接</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>26、什麼是Consumer ？</strong></h1><p>消息的消費者，表示一個從消息隊列中取得消息的客戶端應用程序</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>27、什麼是Virtual Host ？</strong></h1><p>虛擬主機，表示一批交換器、消息隊列和相關對象。虛擬主機是共享相同的身份認證和加密環境的獨立服務器域。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>28、什麼是Broker？</strong></h1><p>表示消息隊列服務器實體</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>29、Exchange 類型 ？</strong></h1><p>Exchange 分發消息時根據類型的不同分發策略有區別， 目前共四種類型：direct、 fanout、topic、 headers 。headers 匹配 AMQP 消息的 header 而不是路由鍵，此外 headers 交換器和direct 交換器完全一致，但性能差很多，目前幾乎用不到了。</p><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>30、Direct 鍵（routing key）分佈 ？</strong></h1><p>Direct：消息中的路由鍵（routing key）如果和 Binding 中的 binding key 一致，交換器就將消息發到對應的隊列中。它是完全匹配、單播的模式。</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAw004OGaOZ2KN><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>31、Fanout（廣播分發）？</strong></h1><p>Fanout：每個發到 fanout 類型交換器的消息都會分到所有綁定的隊列上去。很像子網廣播，每臺子網內的主機都獲得了一份複製的消息。</p><p>fanout 類型轉發消息是最快的。</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/SAw004o1rx9bBQ><p></p><h1 toutiao-origin=h2><strong toutiao-origin=h1>32、topic 交換器（模式匹配） ？</strong></h1><p>topic 交換器：topic 交換器通過模式匹配分配消息的路由鍵屬性，將路由鍵和某個模式進行匹配，此時隊列需要綁定到一個模式上。它將路由鍵和綁定鍵的字符串切分成單詞，這些單詞之間用點隔開。它同樣也會識別兩個通配符：符號“#” 和符號“” 。#匹配 0 個或多個單詞， 匹配不多不少一個單詞。</p><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/SAw005EIRcWdX7><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/R6Aez96HF10BZ3><pre><div><p><strong class=highlight-text toutiao-origin=span>之前，給大家發過</strong><strong class=highlight-text toutiao-origin=strong>三份Java</strong><strong class=highlight-text toutiao-origin=span>面試寶典，這次新增了一份，目前總共是</strong><strong class=highlight-text toutiao-origin=strong>四份</strong><strong class=highlight-text toutiao-origin=span>面試寶典，相信在跳槽前一個月按照面試寶典準備準備，基本沒大問題。</strong></p><ul><li><p><strong class=highlight-text toutiao-origin=strong>《java面試寶典5.0》</strong><strong class=highlight-text toutiao-origin=span>(初中級)</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《350道Java面試題：整理自100+公司》</strong><strong class=highlight-text toutiao-origin=span>（中高級）</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《資深java面試寶典-視頻版》</strong><strong class=highlight-text toutiao-origin=span>（資深）</strong></p></li><li><p><strong class=highlight-text toutiao-origin=strong>《Java[BAT]面試必備》</strong><strong class=highlight-text toutiao-origin=span>（資深）</strong></p></li></ul><p><strong class=highlight-text toutiao-origin=span>分別適用於</strong><strong class=highlight-text toutiao-origin=span>初中級，中高級</strong><strong class=highlight-text toutiao-origin=span>，</strong><strong class=highlight-text toutiao-origin=span>資深</strong><strong class=highlight-text toutiao-origin=span>級工程師</strong><strong class=highlight-text toutiao-origin=span>的面試複習。</strong></p><p><strong class=highlight-text toutiao-origin=span>內容包含</strong><strong class=highlight-text toutiao-origin=span>java基礎、javaweb、mysql性能優化、JVM、鎖、百萬併發、消息隊列，高性能緩存、反射、Spring全家桶原理、微服務、Zookeeper、數據結構、限流熔斷降級等等。</strong></p><div><div><div><div><div><div><div><img alt=消息隊列MQ面試專題（rabbitmq） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RFppAnaHsaFKbv></div><div><p><strong class=highlight-text toutiao-origin=span>看到這裡，證明有所收穫</strong></p></div></div></div></div></div></div></div></div></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>隊列</a></li><li><a>MQ</a></li><li><a>面試</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a06cd9.html alt=面試中常考的堆、棧和隊列如何理解與應用？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0a8a1934fd404a3e9bfdbe5c49d1aa74 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a06cd9.html title=面試中常考的堆、棧和隊列如何理解與應用？>面試中常考的堆、棧和隊列如何理解與應用？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html alt="不怕面試被問了！二叉樹算法大盤點 | 原力計劃" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RseEOGoFGbwiHH style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2fb2eaa.html title="不怕面試被問了！二叉樹算法大盤點 | 原力計劃">不怕面試被問了！二叉樹算法大盤點 | 原力計劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html alt="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/dcd72bc8778d44e6bffbf74b1e60ca72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f670109.html title="別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~">別再翻了，百度大牛整理的面試二叉樹有這 11 個就夠了~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html title=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>