<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構：線性表，棧，隊列，數組，字符串，樹和二叉樹，哈希表 | 极客快訊</title><meta property="og:title" content="數據結構：線性表，棧，隊列，數組，字符串，樹和二叉樹，哈希表 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/cc9da8e40b8f476c9d495c6760a9bdd1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2685fa1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2685fa1.html><meta property="article:published_time" content="2020-10-29T21:05:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:30+08:00"><meta name=Keywords content><meta name=description content="數據結構：線性表，棧，隊列，數組，字符串，樹和二叉樹，哈希表"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/2685fa1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構：線性表，棧，隊列，數組，字符串，樹和二叉樹，哈希表</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>作者：</strong>張人大</p><hr><h3 class=Editable-styled><strong>代碼效率優化</strong></h3><p><br></p><h3 class=Editable-styled><strong>複雜度 -- 一個關於輸入數據量n的函數</strong></h3><ul><li>時間複雜度 -- 昂貴</li><li>與代碼的結構設計有著緊密關係</li><li>一個順序結構的代碼，時間複雜度是O(1), 即任務與算例個數 n 無關</li><li>空間複雜度 -- 廉價</li><li>與數據結構設計有關</li></ul><p><br></p><h3 class=Editable-styled><strong>數據結構 -- 考慮如何去組織計算機中一定量的數據。</strong></h3><p><br></p><h3 class=Editable-styled><strong>數據結構連接時空，用空間換取時間。</strong></h3><p><br></p><h3 class=Editable-styled><strong>數據處理 -- 瞭解問題，明確數據操作方法，設計出更加高效的數據結構類型</strong></h3><ul><li>找到需要處理的數據，計算結果，再把結果保存下來</li><li>把結果存到新的內存空間中</li><li>把結果存到已使用的內存空間中</li><li>基本操作只有三個：增，刪，查</li><li>增和刪可以細分為數據結構的中間以及最後的增和刪</li><li>查找可以細分為按照位置條件查找和數據數值特徵查找</li><li>所有數據處理都是這些基本操著的組合和疊加</li><li>只有字典類型數據結構能在 O(1) 的時間複雜度內完成查找動作</li><li>迴歸問題本源，明確數據被處理的動作，來解決數據結構的問題</li></ul><p><br></p><blockquote class=Editable-styled><p><strong>想了解更多，歡迎關注我的微信公眾號：Renda_Zhang</strong></p></blockquote><hr><h3 class=Editable-styled><strong>線性表</strong></h3><p><br></p><h3 class=Editable-styled><strong>n 個具有相同特性的元素的有限序列，Linear List</strong></h3><p><br></p><h3 class=Editable-styled><strong>數據元素之間的關係是一對一的關係</strong></h3><ul><li>即除了頭尾元素外，其它數據元素都是首尾相接的</li><li>這句話只適用大部分線性表，而不是全部</li><li>比如，循環鏈表尾的指針指向首位結點</li></ul><p><br></p><h3 class=Editable-styled><strong>實現方式</strong></h3><ul><li>最常用的是鏈式表達，也叫線性鏈表或鏈表</li><li>每個結點包括具體的數據值和指向下一個結點的指針</li><li>單向鏈表，循環鏈表，雙向鏈表，雙向循環鏈表</li><li>新增和刪除為 O(1) 時間複雜度，而查找為 O(n)</li><li>適合數據元素個數不確定，且經常進行新增和刪除</li><li>鏈表的翻轉，快慢指針的方法，是必須掌握的內容</li><li>使用數組實現，也叫順序存儲，順序表</li></ul><p><br></p><h3 class=Editable-styled><strong>類別</strong></h3><ul><li>一般線性表，可以自由的刪除和添加結點</li><li>受限線性表，主要包含棧和隊列</li></ul><p><br></p><h3 class=Editable-styled><strong>棧和隊列是特殊的線性表，本質上他們都可以被看作是一類基本結構</strong></h3><h3 class=Editable-styled><strong>線性表案例</strong></h3><ul><li>鏈表的翻轉</li><li>快慢指針</li><li>查找奇數個數的鏈表的中間位置結點的數值</li><li>判斷鏈表是否有環</li></ul><p><br></p><hr><h3 class=Editable-styled><strong>棧</strong></h3><p><br></p><h3 class=Editable-styled><strong>後進先出的（限制後的）線性表，Last In First Out, Stack.</strong></h3><p><br></p><h3 class=Editable-styled><strong>新增和刪除操作只能在這個線性表的表尾進行，即在線性表基礎上加了限制</strong></h3><ul><li>新增: 壓棧 push, which adds an element to the collection</li><li>刪除: 出棧 pop, which removes the most recently added element</li></ul><h3 class=Editable-styled><strong>功能上，數組或者鏈表可以代替棧，但它們靈活性過高，數據量大時有風險</strong></h3><p><br></p><h3 class=Editable-styled><strong>棧頂和棧底是用來表示這個棧的兩個指針</strong></h3><ul><li>棧頂 (top) 是表尾，用來輸入數據</li><li>棧底 (bottom) 是表頭</li></ul><p><br></p><h3 class=Editable-styled><strong>棧有順序表示和鏈式表示，分別稱作順序棧和鏈棧</strong></h3><ul><li>順序棧</li><li>可以藉助數組來實現</li><li>數組的首元素存在棧底，尾元素放在棧頂</li><li>定義指針 top 來指示棧頂元素在數組的位置</li><li>棧中只有一個元素，則 top = 0</li><li>以 top 是否為 -1 來判定是否為空棧</li><li>棧頂 top 需小於棧的最大容量</li><li>出棧操作，只需要 top - 1 即可</li><li>鏈式棧</li><li>用鏈表的方式實現</li><li>通常把棧頂放在單鏈表的頭部</li><li>top 指針替換了鏈表原來的尾指針，去掉了頭指針</li><li>出棧操作，將 top 指針指向棧頂元素的 next 指針即可</li><li>對比棧和一般線性表</li><li>相同點：</li><li>操作原理相似</li><li>時間複雜度一樣</li><li>都依賴當前位置指針進行數據對象的操作</li><li>區別：棧只能新增和刪除棧頂的數據結點</li></ul><p><br></p><h3 class=Editable-styled><strong>棧的案例</strong></h3><ul><li>判斷括號字符串是否合法</li><li>瀏覽器頁面訪問的後退和前進</li></ul><p><br></p><hr><h3 class=Editable-styled><strong>隊列</strong></h3><p><br></p><h3 class=Editable-styled><strong>先進先出 (限制後的) 線性表, First In First Out, Queue</strong></h3><p><br></p><h3 class=Editable-styled><strong>新增和刪除操作只能分別在隊尾和隊頭進行</strong></h3><ul><li>先進 - 隊列的數據新增操作只能在末端進行, add</li><li>不允許在隊列的中間某個結點後新增數據</li><li>先出 - 隊列的數據刪除操作只能在始端進行, remove</li><li>不允許在隊列的中間某個結點後刪除數據</li></ul><p><br></p><h3 class=Editable-styled><strong>隊列適合面對數據處理順序非常敏感的問題</strong></h3><ul><li>可以確定隊列長度最大值, 建議使用循環隊列</li><li>無法確定隊列長度時, 應考慮使用鏈式隊列</li></ul><h3 class=Editable-styled><strong>front 和 rear 兩個指針</strong></h3><ul><li>隊頭 (front), 用來刪除數據</li><li>隊尾 (rear), 用來增加數據</li></ul><h3 class=Editable-styled><strong>隊列有兩種存儲方式, 即順序隊列和鏈式隊列</strong></h3><ul><li>順序隊列</li><li>依賴數組來實現</li><li>數據在內存中也是順序存儲</li><li>進行新增插入操作時,</li><li>尾指針會向後移動</li><li>時間複雜度為 O(1)</li><li>如果只刪除頭的第一個元素時</li><li>每次刪除都需要把整個數組前移</li><li>時間複雜度為 O(n)</li><li>使用循環隊列</li><li>必須有一個固定的長度</li><li>實現刪除的時間複雜度為 O(1)</li><li>使用 flag 來判斷隊列空或滿</li><li>鏈式隊列</li><li>依賴鏈表來實現</li><li>數據依賴每個結點的指針互聯</li><li>是離散存儲線性結構</li><li>實際上就是尾進頭出的單鏈線性表</li><li>在空間上更為靈活</li><li>通常會增加一個頭結點</li><li>讓 front 指針指向頭結點</li><li>頭結點不存儲數據, 只是輔助標識</li><li>當進行數據刪除時, 實際刪除的是頭結點的後繼結點</li><li>隊列為空時, 頭尾指針都指向頭結點</li><li>對比隊列和一般線性表</li><li>隊列繼承了線性表的優點和不足</li><li>是加了限制的線性表</li></ul><p><br></p><h3 class=Editable-styled><strong>隊列案例</strong></h3><ul><li>約瑟夫環 - Josephus problem</li></ul><p><br></p><hr><h3 class=Editable-styled><strong>數組</strong></h3><p><br></p><h3 class=Editable-styled><strong>數組可以看成是線性表的一種推廣，它屬於另外一種基本的數據結構</strong></h3><p><br></p><h3 class=Editable-styled><strong>數組是數據結構中的最基本結構</strong></h3><ul><li>幾乎所有的程序設計語言都把數組類型設定為固定的基礎變量類型。</li><li>可以把數組理解為一種容器，它可以用來存放若干個相同類型的數據元素。</li><li>例如：</li><li>存放的數據是整數型的數組，稱作整型數組；</li><li>存放的數據是字符型的數組，則稱作字符數組；</li><li>另外還有一類數組比較特殊，它是數組的數組，也可以叫作二維數組。</li><li>可以把普通的數組看成是一個向量，那麼二維數組就是一個矩陣。</li><li>數組在內存中是連續存放的，數組內的數據，可以通過索引值直接取出得到。</li></ul><h3 class=Editable-styled><strong>數組的索引就是對應數組空間</strong></h3><ul><li>在進行新增、刪除、查詢操作的時候，完全可以根據代表數組空間位置的索引值進行。</li><li>只要記錄該數組頭部的第一個數據位置，然後累加空間位置即可。</li></ul><h3 class=Editable-styled><strong>數組的基本操作</strong></h3><p>具有增刪困難、查找容易的特點，可以在任意位置增刪數據，所以數組的增刪操作會更為多樣。</p><ul><li>新增操作</li><li>若插入數據在最後，則時間複雜度為 O(1)</li><li>如果中間某處插入數據，則時間複雜度為 O(n)</li><li>刪除操作</li><li>在數組的最後刪除一個數據元素，則時間複雜度是 O(1)</li><li>在這個數組的中間某個位置刪除一條數據, 時間複雜度為 O(n)</li><li>查找操作</li><li>如果只需根據索引值進行一次查找，時間複雜度是 O(1)</li><li>要在數組中查找一個數值滿足指定條件的數據，則時間複雜度是 O(n)。</li></ul><p><br></p><h3 class=Editable-styled><strong>對比數組和鏈表</strong></h3><ul><li>鏈表的長度是可變的，數組的長度是固定的，在申請數組的長度時就已經在內存中開闢了若干個空間。如果沒有引用 ArrayList 時，數組申請的空間永遠是我們在估計了數據的大小後才執行，所以在後期維護中也相當麻煩。</li><li>鏈表不會根據有序位置存儲，進行插入數據元素時，可以用指針來充分利用內存空間。數組是有序存儲的，如果想充分利用內存的空間就只能選擇順序存儲，而且需要在不取數據、不刪除數據的情況下才能實現。</li></ul><h3 class=Editable-styled><strong>數組的案例</strong></h3><ul><li>基於數組，計算平均值</li></ul><p><br></p><hr><h3 class=Editable-styled><strong>字符串</strong></h3><p><br></p><h3 class=Editable-styled><strong>由 n 個字符組成的一個有序整體（ n >= 0 ）</strong></h3><p><br></p><h3 class=Editable-styled><strong>對比字符串和線性表</strong></h3><ul><li>字符串的邏輯結構和線性表極為相似，區別僅在於串的數據對象約束為字符集。</li><li>字符串的基本操作和線性表有很大差別：</li><li>在線性表的基本操作中，大多以“單個元素”作為操作對象；</li><li>在字符串的基本操作中，通常以“串的整體”作為操作對象；</li><li>字符串的增刪操作和數組很像，複雜度也與之一樣。但字符串的查找操作就複雜多了，它是參加面試、筆試常常被考察的內容。</li></ul><p><br></p><h3 class=Editable-styled><strong>特殊的字符串</strong></h3><ul><li>空串，指含有零個字符的串。例如，s = ""，書面中也可以直接用 Ø 表示。</li><li>空格串，只包含空格的串。它和空串是不一樣的，空格串中是有內容的，只不過包含的是空格，且空格串中可以包含多個空格。例如，s = " "，就是包含了 3 個空格的字符串。</li><li>子串，串中任意連續字符組成的字符串叫作該串的子串。</li><li>原串通常也稱為主串。</li></ul><p><br></p><h3 class=Editable-styled><strong>字符串的存儲結構與線性表相同，也有順序存儲和鏈式存儲兩種</strong></h3><ul><li>字符串的順序存儲結構，是用一組地址連續的存儲單元來存儲串中的字符序列，一般是用定長數組來實現。有些語言會在串值後面加一個不計入串長度的結束標記符，比如 \0 來表示串值的終結。</li><li>字符串的鏈式存儲結構，與線性表是相似的，但由於串結構的特殊性（結構中的每個元素數據都是一個字符），如果也簡單地將每個鏈結點存儲為一個字符，就會造成很大的空間浪費。因此，一個結點可以考慮存放多個字符，如果最後一個結點未被佔滿時，可以使用 "#" 或其他非串值字符補全。</li><li>每個結點設置字符數量的多少，與串的長度、可以佔用的存儲空間以及程序實現的功能相關。</li><li>除了在連接串與串操作時有一定的方便之外，不如順序存儲靈活，在性能方面也不如順序存儲結構好。</li></ul><p><br></p><h3 class=Editable-styled><strong>字符串的基本操作</strong></h3><ul><li>新增操作</li><li>和數組非常相似，都牽涉對插入字符串之後字符的挪移操作，所以時間複雜度是 O(n)。</li><li>對於特殊的插入操作時間複雜度也可以降低為 O(1)。例如，在 s1 的最後插入 s2，也叫作字符串的連接。</li><li>刪除操作</li><li>和數組同樣非常相似，也可能會牽涉刪除字符串後字符的挪移操作，所以時間複雜度是 O(n)。</li><li>對於特殊的刪除操作時間複雜度也可以降低為 O(1)。例如，在 s1 的最後刪除若干個字符，不牽涉任何字符的挪移。</li><li>查找操作</li><li>子串查找（字符串匹配）</li><li>在字符串 A 中查找字符串 B，則 A 就是主串，B 就是模式串。</li><li>主串的長度記為 n，模式串長度記為 m，則n>m。</li><li>字符串匹配算法的時間複雜度就是 n 和 m 的函數。</li></ul><p><br></p><h3 class=Editable-styled><strong>字符串匹配算法的案例</strong></h3><ul><li>查找出兩個字符串的最大公共字串</li></ul><p><br></p><hr><p><br></p><h3 class=Editable-styled><strong>樹和二叉樹</strong></h3><p><br></p><h3 class=Editable-styled><strong>樹 -- Tree</strong></h3><ul><li>樹結構在存在“一對多”的數據關係中，可被高頻使用，這也是它區別於鏈表系列數據結構的關鍵點。</li><li>樹是由結點和邊組成的，不存在環的一種數據結構。</li><li>樹滿足遞歸定義的特性。如果一個數據結構是樹結構，那麼剔除掉根結點後，得到的若干個子結構也是樹，通常稱作子樹。</li><li>樹的結點的層次從根結點算起，根為第一層，根的“孩子”為第二層，根的“孩子”的“孩子”為第三層，依此類推。</li><li>樹中結點的最大層次數，就是這棵樹的樹深（稱為深度，也稱為高度）。</li></ul><p><br></p><h3 class=Editable-styled><strong>二叉樹 -- Binary Tree</strong></h3><h3 class=Editable-styled><strong>二叉樹每個結點最多有兩個子結點，分別稱作左子結點和右子結點。</strong></h3><h3 class=Editable-styled><strong>二叉樹中兩個特殊的類型</strong></h3><ul><li>滿二叉樹，定義為除了葉子結點外，所有結點都有 2 個子結點。</li><li>完全二叉樹，定義為除了最後一層以外，其他層的結點個數都達到最大，並且最後一層的葉子結點都靠左排列。它方便了順序存儲法的存儲方式。</li></ul><h3 class=Editable-styled><strong>存儲二叉樹的兩種辦法</strong></h3><ul><li>鏈式存儲法，也就是像鏈表一樣，每個結點有三個字段，一個存儲數據，另外兩個分別存放指向左右子結點的指針。</li><li>順序存儲法，就是按照規律把結點存放在數組裡。如圖所示。</li></ul><p><br></p><div class=pgc-img><img alt=數據結構：線性表，棧，隊列，數組，字符串，樹和二叉樹，哈希表 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc9da8e40b8f476c9d495c6760a9bdd1><p class=pgc-img-caption></p></div><p><br></p><h3 class=Editable-styled><strong>樹的基本操作</strong></h3><h3 class=Editable-styled><strong>遍歷</strong></h3><ul><li>前序遍歷，對樹中的任意結點來說，先打印這個結點，然後前序遍歷它的左子樹，最後前序遍歷它的右子樹。 public static void preOrderTraverse(Node node) { if (node == null) return; System.out.print(node.data + " "); preOrderTraverse(node.left); preOrderTraverse(node.right); }</li><li>中序遍歷，對樹中的任意結點來說，先中序遍歷它的左子樹，然後打印這個結點，最後中序遍歷它的右子樹。 public static void inOrderTraverse(Node node) { if (node == null) return; inOrderTraverse(node.left); System.out.print(node.data + " "); inOrderTraverse(node.right); }</li><li>後序遍歷，對樹中的任意結點來說，先後序遍歷它的左子樹，然後後序遍歷它的右子樹，最後打印它本身。 public static void postOrderTraverse(Node node) { if (node == null) return; postOrderTraverse(node.left); postOrderTraverse(node.right); System.out.print(node.data + " "); }</li></ul><h3 class=Editable-styled><strong>二叉樹的增刪查操作很普通，時間複雜度與鏈表並沒有太多差別</strong></h3><p><br></p><h3 class=Editable-styled><strong>二叉查找樹 -- Binary Search Tree, BST</strong></h3><h3 class=Editable-styled><strong>特性</strong></h3><ul><li>在二叉查找樹中的任意一個結點，其左子樹中的每個結點的值，都要小於這個結點的值。</li><li>在二叉查找樹中的任意一個結點，其右子樹中每個結點的值，都要大於這個結點的值。</li><li>在二叉查找樹中，會儘可能規避兩個結點數值相等的情況。</li><li>對二叉查找樹進行中序遍歷，就可以輸出一個從小到大的有序數據隊列。</li></ul><h3 class=Editable-styled><strong>查找操作 -- 利用了“二分查找”，所消耗的時間複雜度為 O(logn)。</strong></h3><ul><li>首先判斷根結點是否等於要查找的數據，如果是就返回。</li><li>如果根結點大於要查找的數據，就在左子樹中遞歸執行查找動作，直到葉子結點。</li><li>如果根結點小於要查找的數據，就在右子樹中遞歸執行查找動作，直到葉子結點。</li></ul><h3 class=Editable-styled><strong>插入操作</strong></h3><ul><li>插入操作很簡單。從根結點開始，如果要插入的數據比根結點的數據大，且根結點的右子結點不為空，則在根結點的右子樹中繼續嘗試執行插入操作。直到找到為空的子結點執行插入動作。</li><li>二叉查找樹插入數據的時間複雜度是 O(logn)。這裡的時間複雜度更多是消耗在了遍歷數據去找到查找位置上，真正執行插入動作的時間複雜度仍然是 O(1)。</li></ul><h3 class=Editable-styled><strong>刪除操作</strong></h3><ul><li>情況一，如果要刪除的結點是某個葉子結點，則直接刪除，將其父結點指針指向 null 即可。</li><li>情況二，如果要刪除的結點只有一個子結點，只需要將其父結點指向的子結點的指針換成其子結點的指針即可。</li><li>情況三，如果要刪除的結點有兩個子結點，則有兩種可行的操作方式：</li><li>第一種，找到這個結點的左子樹中最大的結點，替換要刪除的結點。</li><li>第二種，找到這個結點的右子樹中最小的結點，替換要刪除的結點。</li></ul><p><br></p><h3 class=Editable-styled><strong>樹的案例</strong></h3><h3 class=Editable-styled><strong>字典樹 -- Dictionary Tree</strong></h3><ul><li>第一，根結點不包含字符；</li><li>第二，除根結點外每一個結點都只包含一個字符；</li><li>第三，從根結點到某一葉子結點，路徑上經過的字符連接起來，即為集合中的某個字符串。</li></ul><p><br></p><hr><h3 class=Editable-styled><strong>哈希表</strong></h3><p><br></p><h3 class=Editable-styled><strong>哈希表 -- Hash Table, 也叫作散列表。</strong></h3><p><br></p><h3 class=Editable-styled><strong>哈希表是一種特殊的數據結構，它與數組、鏈表以及樹等我們之前學過的數據結構相比，有很明顯的區別。</strong></h3><ul><li>線性表中的棧和隊列對增刪有嚴格要求，它們會更關注數據的順序。</li><li>數組和字符串需要保持數據類型的統一，並且在基於索引的查找上會更有優勢。</li><li>樹的優勢則體現在數據的層次結構上。</li><li>哈希表優勢體現在，無論有多少數據，查找、插入、刪除只需要接近常量的時間，即 O(1）的時間級。</li></ul><p><br></p><h3 class=Editable-styled><strong>核心思想</strong></h3><p>實現 “地址 = f (關鍵字)” 的映射關係，快速完成基於數據的數值的查找。</p><h3 class=Editable-styled><strong>哈希函數的設計</strong></h3><h3 class=Editable-styled><strong>直接定製法</strong></h3><p>哈希函數為關鍵字到地址的線性函數。如，H (key) = a*key + b。 這裡，a 和 b 是設置好的常數。</p><h3 class=Editable-styled><strong>數字分析法</strong></h3><p>假設關鍵字集合中的每個關鍵字 key 都是由 s 位數字組成（k1,k2,…,Ks），並從中提取分佈均勻的若干位組成哈希地址。</p><h3 class=Editable-styled><strong>平方取中法</strong></h3><p>如果關鍵字的每一位都有某些數字重複出現，並且頻率很高，我們就可以先求關鍵字的平方值，通過平方擴大差異，然後取中間幾位作為最終存儲地址。</p><h3 class=Editable-styled><strong>摺疊法</strong></h3><p>如果關鍵字的位數很多，可以將關鍵字分割為幾個等長的部分，取它們的疊加和的值（捨去進位）作為哈希地址。</p><h3 class=Editable-styled><strong>除留餘數法</strong></h3><p>預先設置一個數 p，然後對關鍵字進行取餘運算。即地址為 key mod p。</p><p><br></p><h3 class=Editable-styled><strong>解決哈希衝突</strong></h3><h3 class=Editable-styled><strong>開放定址法</strong></h3><p>常用的探測方法是線性探測法。比如有一組關鍵字 {34，35，36，45}，採用的哈希函數為 key mod 11。當插入 34，35，36 時可以直接插入，地址分別為 1、2、3。而當插入 45 時，哈希地址為 45 mod 11 = 1。然而，地址 1 已經被佔用，因此沿著地址 1 依次往下探測，直到探測到地址 4，發現為空，則將 45 插入其中。</p><h3 class=Editable-styled><strong>鏈地址法</strong></h3><p>將哈希地址相同的記錄存儲在一張線性鏈表中。如果出現衝突，就在對應的位置上加上鍊表的數據結構。</p><p><br></p><h3 class=Editable-styled><strong>哈希表的基本操作</strong></h3><h3 class=Editable-styled><strong>哈希表中的增加和刪除數據操作，不涉及增刪後對數據的挪移問題</strong></h3><ul><li>如果是採用數組實現就需要考慮數據的挪移問題</li></ul><h3 class=Editable-styled><strong>哈希表查找的細節過程是：對於給定的 key，通過哈希函數計算哈希地址 H (key)。</strong></h3><ul><li>如果哈希地址對應的值為空，則查找不成功。</li><li>反之，則查找成功。</li></ul><p><br></p><h3 class=Editable-styled><strong>哈希表的案例</strong></h3><h3 class=Editable-styled><strong>實時返回用戶的字符串搜索結果</strong></h3><hr></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>線性表</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html alt=數據結構與算法（7）遞歸 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48215327.html title=數據結構與算法（7）遞歸>數據結構與算法（7）遞歸</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>