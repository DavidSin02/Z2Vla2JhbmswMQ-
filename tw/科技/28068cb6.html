<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>手把手教你 Netty 實現自定義協議 | 极客快訊</title><meta property="og:title" content="手把手教你 Netty 實現自定義協議 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/35a65c1e6e4b489d9b87fd6e169e8b66"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/28068cb6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/28068cb6.html><meta property="article:published_time" content="2020-11-14T21:04:17+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:17+08:00"><meta name=Keywords content><meta name=description content="手把手教你 Netty 實現自定義協議"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/28068cb6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>手把手教你 Netty 實現自定義協議</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>點擊上方 "程序員小樂"關注, 星標或置頂一起成長</p><p>每天凌晨00點00分, 第一時間與你相約</p><p><br></p><p>每日英文</p><p>It's so hard to tell someone how you really feel about them when you're too afraid of losing what you already have.</p><p>有時候，要坦白對某個人的感覺真的太難了，因為太害怕連現在這種關係都失去。</p><p><br></p><p>每日掏心話</p><p>我們不要去做一個單純優秀的人，而是要去做一個不可替代的人。</p><p>來自：愛寶貝丶 | 責編：樂樂<br></p><p>鏈接：my.oschina.net/zhangxufeng/blog/3043768</p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt="手把手教你 Netty 實現自定義協議" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/35a65c1e6e4b489d9b87fd6e169e8b66></div></div></p><p>程序員小樂(ID:study_tech)第 829 次推文 圖片來自百度</p><p><br></p><p>往日回顧：“微信遺囑”功能開通，網友體驗後發現...如果突然離世，你的QQ、支付寶等怎麼辦？</p><p><br></p><p>正文</p><p><br><br></p><p>關於協議，使用最為廣泛的是HTTP協議，但是在一些服務交互領域，其使用則相對較少，主要原因有三方面：</p><p><br></p><ul class=list-paddingleft-2><li><p>HTTP協議會攜帶諸如header和cookie等信息，其本身對字節的利用率也較低，這使得HTTP協議比較臃腫，在承載相同信息的情況下，HTTP協議將需要發送更多的數據包；</p></li><li><p>HTTP協議是基於TCP的短連接，其在每次請求和響應的時候都需要進行三次握手和四次揮手，由於服務的交互設計一般都要求能夠承載高併發的請求，因而HTTP協議這種頻繁的握手和揮手動作會極大的影響服務之間交互的效率；</p></li><li><p>服務之間往往有一些根據其自身業務特性所獨有的需求，而HTTP協議無法很好的服務於這些業務需求。</p></li></ul><p><br></p><p>基於上面的原因，一般的服務之間進行交互時都會使用自定義協議，常見的框架，諸如dubbo，kafka，zookeeper都實現了符合其自身業務需求的協議，本文主要講解如何使用Netty實現一款自定義的協議。</p><p><br></p><p>1. 協議規定</p><p>所謂協議，其本質其實就是定義了一個將數據轉換為字節，或者將字節轉換為數據的一個規範。一款自定義協議，其一般包含兩個部分：消息頭和消息體。消息頭的長度一般是固定的，或者說是可確定的，其定義了此次消息的一些公有信息，比如當前服務的版本，消息的sessionId，消息的類型等等；消息體則主要是此次消息所需要發送的內容，一般在消息頭的最後一定的字節中保存了當前消息的消息體的長度。下面是我們為當前自定義協議所做的一些規定：</p><p><div class="pgc-image pgc-card-fixWidth"><div class="pgc-img-wrapper ttcore-relative"><img alt="手把手教你 Netty 實現自定義協議" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7e8c4ecfeb9842d9a4fa960360f7ae3b></div></div></p><p></p><p>上述協議定義中，我們除了定義常用的請求和響應消息類型以外，還定義了Ping和Pong消息。Ping和Pong消息的作用一般是，在服務處於閒置狀態達到一定時長，比如2s時，客戶端服務會向服務端發送一個Ping消息，則會返回一個Pong消息，這樣才表示客戶端與服務端的連接是完好的。如果服務端沒有返回相應的消息，客戶端就會關閉與服務端的連接或者是重新建立與服務端的連接。這樣的優點在於可以防止突然會產生的客戶端與服務端的大量交互。</p><p><br></p><p>2. 協議實現</p><p>通過上面的定義其實我們可以發現，所謂協議，就是定義了一個規範，基於這個規範，我們可以將消息轉換為相應的字節流，然後經由TCP傳輸到目標服務，目標服務則也基於該規範將字節流轉換為相應的消息，這樣就達到了相互交流的目的。這裡面最重要的主要是如何基於該規範將消息轉換為字節流或者將字節流轉換為消息。這一方面，Netty為我們提供了ByteToMessageDecoder和MessageToByteEncoder用於進行消息和字節流的相互轉換。首先我們定義瞭如下消息實體：</p><p>public class Message {<br>private int magicNumber;<br>private byte mainVersion;<br>private byte subVersion;<br>private byte modifyVersion;<br>private String sessionId;<br><br>private MessageTypeEnum messageType;<br>private Map&lt;String, String> attachments = new HashMap&lt;>();<br>private String body;<br><br>public Map&lt;String, String> getAttachments() {<br>return Collections.unmodifiableMap(attachments);<br>}<br><br>public void setAttachments(Map&lt;String, String> attachments) {<br>this.attachments.clear();<br>if (null != attachments) {<br>this.attachments.putAll(attachments);<br>}<br>}<br><br>public void addAttachment(String key, String value) {<br>attachments.put(key, value);<br>}<br><br>// getter and setter...<br>}<br></p><p>上述消息中，我們將協議中所規定的各個字段都進行了定義，並且定義了一個標誌消息類型的枚舉MessageTypeEnum，如下是該枚舉的源碼：</p><p>public enum MessageTypeEnum {<br>REQUEST((byte)1), RESPONSE((byte)2), PING((byte)3), PONG((byte)4), EMPTY((byte)5);<br><br>private byte type;<br><br>MessageTypeEnum(byte type) {<br>this.type = type;<br>}<br><br>public int getType() {<br>return type;<br>}<br><br>public static MessageTypeEnum get(byte type) {<br>for (MessageTypeEnum value : values()) {<br>if (value.type == type) {<br>return value;<br>}<br>}<br><br>throw new RuntimeException("unsupported type: " + type);<br>}<br>}<br></p><p>上述主要是定義了描述自定義協議相關的實體屬性，對於消息的編碼，本質就是依據上述協議方式將消息實體轉換為字節流，如下是轉換字節流的代碼：</p><p>public class MessageEncoder extends MessageToByteEncoder&lt;Message> {<br><br>@Override<br>protected void encode(ChannelHandlerContext ctx, Message message, ByteBuf out) {<br>// 這裡會判斷消息類型是不是EMPTY類型，如果是EMPTY類型，則表示當前消息不需要寫入到管道中<br>if (message.getMessageType() != MessageTypeEnum.EMPTY) {<br>out.writeInt(Constants.MAGIC_NUMBER); // 寫入當前的魔數<br>out.writeByte(Constants.MAIN_VERSION); // 寫入當前的主版本號<br>out.writeByte(Constants.SUB_VERSION); // 寫入當前的次版本號<br>out.writeByte(Constants.MODIFY_VERSION); // 寫入當前的修訂版本號<br>if (!StringUtils.hasText(message.getSessionId())) {<br>// 生成一個sessionId，並將其寫入到字節序列中<br>String sessionId = SessionIdGenerator.generate();<br>message.setSessionId(sessionId);<br>out.writeCharSequence(sessionId, Charset.defaultCharset());<br>}<br><br>out.writeByte(message.getMessageType().getType()); // 寫入當前消息的類型<br>out.writeShort(message.getAttachments().size()); // 寫入當前消息的附加參數數量<br>message.getAttachments().forEach((key, value) -> {<br>Charset charset = Charset.defaultCharset();<br>out.writeInt(key.length()); // 寫入鍵的長度<br>out.writeCharSequence(key, charset); // 寫入鍵數據<br>out.writeInt(value.length()); // 希爾值的長度<br>out.writeCharSequence(value, charset); // 寫入值數據<br>});<br><br>if (null == message.getBody()) {<br>out.writeInt(0); // 如果消息體為空，則寫入0，表示消息體長度為0<br>} else {<br>out.writeInt(message.getBody().length());<br>out.writeCharSequence(message.getBody(), Charset.defaultCharset());<br>}<br>}<br>}<br>}<br></p><p>對於消息的解碼，其過程與上面的消息編碼方式基本一致，主要是基於協議所規定的將字節流數據轉換為消息實體數據。如下是其轉換過程：</p><p>public class MessageDecoder extends ByteToMessageDecoder {<br><br>@Override<br>protected void decode(ChannelHandlerContext ctx, ByteBuf byteBuf, List&lt;Object> out) throws Exception {<br>Message message = new Message();<br>message.setMagicNumber(byteBuf.readInt()); // 讀取魔數<br>message.setMainVersion(byteBuf.readByte()); // 讀取主版本號<br>message.setSubVersion(byteBuf.readByte()); // 讀取次版本號<br>message.setModifyVersion(byteBuf.readByte()); // 讀取修訂版本號<br>CharSequence sessionId = byteBuf.readCharSequence(<br>Constants.SESSION_ID_LENGTH, Charset.defaultCharset()); // 讀取sessionId<br>message.setSessionId((String)sessionId);<br><br>message.setMessageType(MessageTypeEnum.get(byteBuf.readByte())); // 讀取當前的消息類型<br>short attachmentSize = byteBuf.readShort(); // 讀取附件長度<br>for (short i = 0; i &lt; attachmentSize; i++) {<br>int keyLength = byteBuf.readInt(); // 讀取鍵長度和數據<br>CharSequence key = byteBuf.readCharSequence(keyLength, Charset.defaultCharset());<br>int valueLength = byteBuf.readInt(); // 讀取值長度和數據<br>CharSequence value = byteBuf.readCharSequence(valueLength, Charset.defaultCharset());<br>message.addAttachment(key.toString(), value.toString());<br>}<br><br>int bodyLength = byteBuf.readInt(); // 讀取消息體長度和數據<br>CharSequence body = byteBuf.readCharSequence(bodyLength, Charset.defaultCharset());<br>message.setBody(body.toString());<br>out.add(message);<br>}<br>}<br></p><p>如此，我們自定義消息與字節流的相互轉換工作已經完成。對於消息的處理，主要是要根據消息的不同類型，對消息進行相應的處理，比如對於request類型消息，要寫入響應數據，對於ping消息，要寫入pong消息作為迴應。下面我們通過定義Netty handler的方式實現對消息的處理：</p><p>// 服務端消息處理器<br>public class ServerMessageHandler extends SimpleChannelInboundHandler&lt;Message> {<br><br>// 獲取一個消息處理器工廠類實例<br>private MessageResolverFactory resolverFactory = MessageResolverFactory.getInstance();<br><br>@Override<br>protected void channelRead0(ChannelHandlerContext ctx, Message message) throws Exception {<br>Resolver resolver = resolverFactory.getMessageResolver(message); // 獲取消息處理器<br>Message result = resolver.resolve(message); // 對消息進行處理並獲取響應數據<br>ctx.writeAndFlush(result); // 將響應數據寫入到處理器中<br>}<br><br>@Override<br>public void channelRegistered(ChannelHandlerContext ctx) throws Exception {<br>resolverFactory.registerResolver(new RequestMessageResolver()); // 註冊request消息處理器<br>resolverFactory.registerResolver(new ResponseMessageResolver());// 註冊response消息處理器<br>resolverFactory.registerResolver(new PingMessageResolver()); // 註冊ping消息處理器<br>resolverFactory.registerResolver(new PongMessageResolver()); // 註冊pong消息處理器<br>}<br>}<br>// 客戶端消息處理器<br>public class ClientMessageHandler extends ServerMessageHandler {<br><br>// 創建一個線程，模擬用戶發送消息<br>private ExecutorService executor = Executors.newSingleThreadExecutor();<br><br>@Override<br>public void channelActive(ChannelHandlerContext ctx) throws Exception {<br>// 對於客戶端，在建立連接之後，在一個獨立線程中模擬用戶發送數據給服務端<br>executor.execute(new MessageSender(ctx));<br>}<br><br>/**<br>* 這裡userEventTriggered()主要是在一些用戶事件觸發時被調用，這裡我們定義的事件是進行心跳檢測的<br>* ping和pong消息，當前觸發器會在指定的觸發器指定的時間返回內如果客戶端沒有被讀取消息或者沒有寫入<br>* 消息到管道，則會觸發當前方法<br>*/<br>@Override<br>public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {<br>if (evt instanceof IdleStateEvent) {<br>IdleStateEvent event = (IdleStateEvent) evt;<br>if (event.state() == IdleState.READER_IDLE) {<br>// 一定時間內，當前服務沒有發生讀取事件，也即沒有消息發送到當前服務來時，<br>// 其會發送一個Ping消息到服務器，以等待其響應Pong消息<br>Message message = new Message();<br>message.setMessageType(MessageTypeEnum.PING);<br>ctx.writeAndFlush(message);<br>} else if (event.state() == IdleState.WRITER_IDLE) {<br>// 如果當前服務在指定時間內沒有寫入消息到管道，則關閉當前管道<br>ctx.close();<br>}<br>}<br>}<br><br>private static final class MessageSender implements Runnable {<br><br>private static final AtomicLong counter = new AtomicLong(1);<br>private volatile ChannelHandlerContext ctx;<br><br>public MessageSender(ChannelHandlerContext ctx) {<br>this.ctx = ctx;<br>}<br><br>@Override<br>public void run() {<br>try {<br>while (true) {<br>// 模擬隨機發送消息的過程<br>TimeUnit.SECONDS.sleep(new Random().nextInt(3));<br>Message message = new Message();<br>message.setMessageType(MessageTypeEnum.REQUEST);<br>message.setBody("this is my " + counter.getAndIncrement() + " message.");<br>message.addAttachment("name", "xufeng");<br>ctx.writeAndFlush(message);<br>}<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>}<br>}<br>}<br>}<br></p><p>上述代碼中，由於客戶端和服務端需要處理的消息類型是完全一樣的，因而客戶端處理類繼承了服務端處理類。但是對於客戶端而言，其還需要定時向服務端發送心跳消息，用於檢測客戶端與服務器的連接是否健在，因而客戶端還會實現userEventTriggered()方法，在該方法中定時向服務器發送心跳消息。userEventTriggered()方法主要是在客戶端被閒置一定時間後，其會根據其讀取或者寫入消息的限制時長來選擇性的觸發讀取或寫入事件。</p><p>上述實現中，我們看到，對於具體類型消息的處理，我們是通過一個工廠類來獲取對應的消息處理器，然後處理相應的消息，下面我們該工廠類的代碼：</p><p>public final class MessageResolverFactory {<br><br>// 創建一個工廠類實例<br>private static final MessageResolverFactory resolverFactory = new MessageResolverFactory();<br>private static final List&lt;Resolver> resolvers = new CopyOnWriteArrayList&lt;>();<br><br>private MessageResolverFactory() {}<br><br>// 使用單例模式實例化當前工廠類實例<br>public static MessageResolverFactory getInstance() {<br>return resolverFactory;<br>}<br><br>public void registerResolver(Resolver resolver) {<br>resolvers.add(resolver);<br>}<br><br>// 根據解碼後的消息，在工廠類處理器中查找可以處理當前消息的處理器<br>public Resolver getMessageResolver(Message message) {<br>for (Resolver resolver : resolvers) {<br>if (resolver.support(message)) {<br>return resolver;<br>}<br>}<br><br>throw new RuntimeException("cannot find resolver, message type: " + message.getMessageType());<br>}<br><br>}<br></p><p>上述工廠類比較簡單，主要就是通過單例模式獲取一個工廠類實例，然後提供一個根據具體消息來查找其對應的處理器的方法。下面我們來看看各個消息處理器的代碼：</p><p>// request類型的消息<br>public class RequestMessageResolver implements Resolver {<br><br>private static final AtomicInteger counter = new AtomicInteger(1);<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.REQUEST;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到request消息之後，對消息進行處理，這裡主要是將其打印出來<br>int index = counter.getAndIncrement();<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". receive request: " + message.getBody());<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". attachments: " + message.getAttachments());<br><br>// 處理完成後，生成一個響應消息返回<br>Message response = new Message();<br>response.setMessageType(MessageTypeEnum.RESPONSE);<br>response.setBody("nice to meet you too!");<br>response.addAttachment("name", "xufeng");<br>response.addAttachment("hometown", "wuhan");<br>return response;<br>}<br>}<br>// 響應消息處理器<br>public class ResponseMessageResolver implements Resolver {<br><br>private static final AtomicInteger counter = new AtomicInteger(1);<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.RESPONSE;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到對方服務的響應消息之後，對響應消息進行處理，這裡主要是將其打印出來<br>int index = counter.getAndIncrement();<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". receive response: " + message.getBody());<br>System.out.println("[trx: " + message.getSessionId() + "]"<br>+ index + ". attachments: " + message.getAttachments());<br><br>// 響應消息不需要向對方服務再發送響應，因而這裡寫入一個空消息<br>Message empty = new Message();<br>empty.setMessageType(MessageTypeEnum.EMPTY);<br>return empty;<br>}<br>}<br>// ping消息處理器<br>public class PingMessageResolver implements Resolver {<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.PING;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到ping消息後，返回一個pong消息返回<br>System.out.println("receive ping message: " + System.currentTimeMillis());<br>Message pong = new Message();<br>pong.setMessageType(MessageTypeEnum.PONG);<br>return pong;<br>}<br>}<br>// pong消息處理器<br>public class PongMessageResolver implements Resolver {<br><br>@Override<br>public boolean support(Message message) {<br>return message.getMessageType() == MessageTypeEnum.PONG;<br>}<br><br>@Override<br>public Message resolve(Message message) {<br>// 接收到pong消息後，不需要進行處理，直接返回一個空的message<br>System.out.println("receive pong message: " + System.currentTimeMillis());<br>Message empty = new Message();<br>empty.setMessageType(MessageTypeEnum.EMPTY);<br>return empty;<br>}<br>}<br></p><p>如此，對於自定義協議的消息處理過程已經完成，下面則是使用用Netty實現的客戶端與服務端代碼：</p><p>// 服務端<br>public class Server {<br><br>public static void main(String[] args) {<br>EventLoopGroup bossGroup = new NioEventLoopGroup();<br>EventLoopGroup workerGroup = new NioEventLoopGroup();<br>try {<br>ServerBootstrap bootstrap = new ServerBootstrap();<br>bootstrap.group(bossGroup, workerGroup)<br>.channel(NioServerSocketChannel.class)<br>.option(ChannelOption.SO_BACKLOG, 1024)<br>.handler(new LoggingHandler(LogLevel.INFO))<br>.childHandler(new ChannelInitializer&lt;SocketChannel>() {<br>@Override<br>protected void initChannel(SocketChannel ch) throws Exception {<br>ChannelPipeline pipeline = ch.pipeline();<br>// 添加用於處理粘包和拆包問題的處理器<br>pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));<br>pipeline.addLast(new LengthFieldPrepender(4));<br>// 添加自定義協議消息的編碼和解碼處理器<br>pipeline.addLast(new MessageEncoder());<br>pipeline.addLast(new MessageDecoder());<br>// 添加具體的消息處理器<br>pipeline.addLast(new ServerMessageHandler());<br>}<br>});<br><br>ChannelFuture future = bootstrap.bind(8585).sync();<br>future.channel().closeFuture().sync();<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>} finally {<br>bossGroup.shutdownGracefully();<br>workerGroup.shutdownGracefully();<br>}<br>}<br>}<br>public class Client {<br>public static void main(String[] args) {<br>NioEventLoopGroup group = new NioEventLoopGroup();<br>Bootstrap bootstrap = new Bootstrap();<br>try {<br>bootstrap.group(group)<br>.channel(NioSocketChannel.class)<br>.option(ChannelOption.TCP_NODELAY, Boolean.TRUE)<br>.handler(new ChannelInitializer&lt;SocketChannel>() {<br>@Override<br>protected void initChannel(SocketChannel ch) throws Exception {<br>ChannelPipeline pipeline = ch.pipeline();<br>// 添加用於解決粘包和拆包問題的處理器<br>pipeline.addLast(new LengthFieldBasedFrameDecoder(1024, 0, 4, 0, 4));<br>pipeline.addLast(new LengthFieldPrepender(4));<br>// 添加用於進行心跳檢測的處理器<br>pipeline.addLast(new IdleStateHandler(1, 2, 0));<br>// 添加用於根據自定義協議將消息與字節流進行相互轉換的處理器<br>pipeline.addLast(new MessageEncoder());<br>pipeline.addLast(new MessageDecoder());<br>// 添加客戶端消息處理器<br>pipeline.addLast(new ClientMessageHandler());<br>}<br>});<br><br>ChannelFuture future = bootstrap.connect("127.0.0.1", 8585).sync();<br>future.channel().closeFuture().sync();<br>} catch (InterruptedException e) {<br>e.printStackTrace();<br>} finally {<br>group.shutdownGracefully();<br>}<br>}<br>}<br></p><p>運行上述代碼之後，我們可以看到客戶端和服務器分別打印瞭如下數據：</p><p>// 客戶端<br>receive pong message: 1555123429356<br>[trx: d05024d2]1. receive response: nice to meet you too!<br>[trx: d05024d2]1. attachments: {hometown=wuhan, name=xufeng}<br>[trx: 66ee1438]2. receive response: nice to meet you too!<br>// 服務器<br>receive ping message: 1555123432279<br>[trx: f582444f]4. receive request: this is my 4 message.<br>[trx: f582444f]4. attachments: {name=xufeng}<br></p><p><br></p><p>3. 小結</p><p>本文首先將自定義協議與HTTP協議進行了對比，闡述了自定義協議的一些優點。然後定義了一份自定義協議，並且講解了協議中各個字節的含義。最後通過Netty對自定義協議進行了實現，並且實現了基於自定義協議的心跳功能。</p><p><br></p><p>歡迎在留言區留下你的觀點，一起討論提高。如果今天的文章讓你有新的啟發，學習能力的提升上有新的認識，歡迎轉發分享給更多人。</p><p><br></p><p>猜你還想看</p><p><br></p><p>阿里、騰訊、百度、華為、京東最新面試題彙集</p><p>Java之異常處理，看這篇就對了！<br></p><p>一個簡單的例子帶你理解HashMap<br></p><p>【整理】Spring 常用註解！千萬不要錯過！<br><br></p><p>關注訂閱號「程序員小樂」，收看更多精彩內容<br>嘿，你在看嗎？</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Netty</a></li><li><a>實現</a></li><li><a>義協議</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html alt=彩色電子書在廣州率先實現量產 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RkPMb9G6tipobr style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f09ac34c.html title=彩色電子書在廣州率先實現量產>彩色電子書在廣州率先實現量產</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html alt="撫順各項防汛工作實現“六到位” 確保全市安全度汛" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e41fd8de.html title="撫順各項防汛工作實現“六到位” 確保全市安全度汛">撫順各項防汛工作實現“六到位” 確保全市安全度汛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html alt="Redis 設計與實現 : Lua 腳本" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22ee5ad.html title="Redis 設計與實現 : Lua 腳本">Redis 設計與實現 : Lua 腳本</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html alt=這位大叔在隨機的彩票上實現了90%的中獎率 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/50ab0003166decded7e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56e2a065.html title=這位大叔在隨機的彩票上實現了90%的中獎率>這位大叔在隨機的彩票上實現了90%的中獎率</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html alt="廣西鐵路出海大通道 全面實現電氣化運營" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0662f03.html title="廣西鐵路出海大通道 全面實現電氣化運營">廣西鐵路出海大通道 全面實現電氣化運營</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c3d9f70.html alt=新穎的混合材料或有助於實現高效的下一代顯示器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/47050004da4f36dcec1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c3d9f70.html title=新穎的混合材料或有助於實現高效的下一代顯示器>新穎的混合材料或有助於實現高效的下一代顯示器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d93e49d.html alt=教程：採用梯度下降算法實現線性迴歸！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1537162000876f4501fb1c4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d93e49d.html title=教程：採用梯度下降算法實現線性迴歸！>教程：採用梯度下降算法實現線性迴歸！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8e17d90.html alt=重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RtbWBYL9koJMmN style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8e17d90.html title=重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別>重要突破！中國科學家實現基底細胞癌4.1秒人工智能精準識別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b218e68.html alt=圖像拼接算法及實現（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534489824878547eee8fc2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b218e68.html title=圖像拼接算法及實現（一）>圖像拼接算法及實現（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9eb3d63.html alt=PHP實現各種經典算法詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15357595091626cf296dc3e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9eb3d63.html title=PHP實現各種經典算法詳解>PHP實現各種經典算法詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/740f5b7b.html alt=PHP怎麼實現分頁功能？（圖文+視頻教程） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e81c52a014dd4c34adcbfb26482bd690 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/740f5b7b.html title=PHP怎麼實現分頁功能？（圖文+視頻教程）>PHP怎麼實現分頁功能？（圖文+視頻教程）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>