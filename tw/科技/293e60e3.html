<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Rust編程語言初探 | 极客快訊</title><meta property="og:title" content="Rust編程語言初探 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/b47797c4e0b5476e86050d174aea893c"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/293e60e3.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/293e60e3.html><meta property="article:published_time" content="2020-11-14T21:00:35+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:35+08:00"><meta name=Keywords content><meta name=description content="Rust編程語言初探"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/293e60e3.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Rust編程語言初探</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=Rust編程語言初探 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b47797c4e0b5476e86050d174aea893c><p class=pgc-img-caption></p></div><p><br></p><p><strong>靜態、強類型而又不帶垃圾收集</strong>的編程語言領域內，很久沒有新加入者參與競爭了，大概大部分開發者認為傳統的C/C++的思路<strong>已經不太適合新時代的編程需求</strong>，即便有Ken Tompson這樣的大神參與設計的golang也採用了GC的思路來設計其新一代的語言；一方面垃圾收集技術和即使編譯技術一直在發展和完善，另一方面是大量的未經過嚴格計算機科學基礎訓練的開發人員進入市場，似乎讓開發者永遠停留在邏輯層面而不是去直接操縱內存是個更為現代的選擇，Mozilla卻仍然堅信一門靜態而又高效低利用系統資源的“偏底層”的語言也依然會有巨大的生命力；於是站在現代成熟的軟件工程實踐上的Rustlang(以下簡稱Rust)為創造出來，其新版本的發佈不時引起HackNews等極客圈的關注。</p><p>本文試圖通過其官方文檔對該語言（以及其相關的生態系統）做簡單的研習。</p><h2 class=pgc-h-arrow-right>核心語言特性設計目標</h2><p>按照其官方描述，Rust需要滿足其以下幾個核心目標</p><ol start=1><li>適用於系統編程場景 - 這意味著能夠有直接訪問操作系統基礎設施和硬件的能力。</li><li>開源參與和協作 - 畢竟其背後的推動者是創造了第一代瀏覽器的Mozilla，比任何商業公司更懂得依靠<strong>開源社區的力量</strong></li><li>安全而又高效 - 在現代的軟件工程環境中，安全是不可或缺的，而面向系統編程場景的語言必然少不了對<strong>性能的極致要求</strong></li><li>充分利用現代<strong>多核和併發處理</strong>技術的能力 - 這也是傳統的C/C++語言的軟肋所在；同時也是Google的Golang的設計目標之一</li><li>容易學習的語法 - 減少類似於段錯誤或隱式的多線程編程等相對底層的細節應該儘量被隱藏</li></ol><p>根據以上目標可以相對容易的理解一些核心的語言設計策略背後的決策依據。</p><h2 class=pgc-h-arrow-right>基本語法特性</h2><p>作為一門面向系統編程的<strong>偏底層</strong>的程序語言，其基本語法和傳統的C/C++/Java系列語言共享了很多共同之處，這裡僅需要看看其不同之處。</p><h3 class=pgc-h-arrow-right>類型系統</h3><p>靜態語言的基本元素之一是變量和類型；不同的語言會選擇不同的類型定義和內置的開箱可用的基本類型；這些類型及內置類的設計往往反映了編程語言設計者的決策策略和權衡要素。</p><h4 class=pgc-h-arrow-right>類型聲明和自動推斷</h4><p>畢竟要面對的是偏嚴肅的<strong>系統編程</strong>領域，選擇靜態類型可以在編譯階段<strong>儘可能早地發現更多的</strong>程序錯誤是題中之義；同時作為一門比較現代的編程語言，每次讓程序員自己輸入每個變量的類型這類臃腫的做法也被廢棄，<strong>自動類型推斷</strong>必不可少 - 當編譯器可以”聰明地”推導出合適的類型的時候，變量類型指定可以忽略。</p><p>譬如需要聲明一個某種類型的變量，Rust用let x: someType = &lt;some value>來表示；當然對於編譯器可以推導出來類型的情況下，類型是可以省略的這樣可以少寫一些囉嗦的代碼，let x = 2就會定義一個整數類型的變量x;比較新的編程語言基本都是這麼做的，沒有什麼新意。</p><p>作為一門<strong>強類型的語言</strong>，任何變量或者表達式必須有唯一的類型，否則編譯的時候就會報錯。當然Rust支持一種特殊的變量隱藏機制(Shadow),即同一個名字的變量可以重新使用，並設置為一個完全不同的類型；這個時候<strong>原來的變量就不能被訪問</strong>了。如</p><pre><code>let var = "something"; //string literallet var = 1; //changed to int</code></pre><p>這種機制從某種程度上來說，反而會使代碼變得不太容易理解，如果程序員習慣了C/C++的編程方式的話；同時<strong>也會給IDE等工具的解析</strong>帶來一些挑戰；當然這個是仁者見仁智者見智的事情。</p><h4 class=pgc-h-arrow-right>類型可變性約束</h4><p>Rust要求所有定義的變量必須指定是否是<strong>可變</strong>的；並且作為變量的基本特徵強制程序員做合理的選擇。可變的變量用類似let mut varName:Type = value的語法來定義，顧名思義可以在<strong>聲明之後被重新賦值</strong>修改；而不可變的變量少了一個mut關鍵字，其定義的變量在初始化一次後續就不能再修改了。</p><p>Rust裡邊同時支持常量類型，用const來聲明，像是從C++裡借鑑來的。它和可變類型mutable有一些細微的不同: 對於常量類型我們必須使用類型註解，不能聲明可變的常量類型（不允許混合const和mut),而且常量類型只能被賦值為一個常量表達式， 不能用函數調用的結果或者是其他一些運行時計算出來的值來初始化。綜合來看，Rust的常量類型和C++11中新引入的constexpr行為比較接近。</p><h4 class=pgc-h-arrow-right>內置類型</h4><p>內置類型一般用於提供大部分程序員都要用到的基本數據結構。除了一些其他語言都常見的基本類型(Rust稱之為標量類型)，Rust也提供了一些相對比較複雜的類型。</p><p>基本標量類型包含以下這些基本的類型</p><ul><li>整型類型，包括定長的8/16/32/64位的有符號和無符號類型（如u16是無符號16位整型，i32是有符號32位類型）， 還支持平臺相關的有符號/無符號類型，分別用isize和usize表示</li><li>浮點類型，支持單精度(f32)和雙精度(f64)類型，這些在數值計算的時候比較關鍵</li><li>布爾類型，和C++中的比較類似，有true和false兩種可能的取值，當然沒有C/C++中的那些隱式轉換的麻煩</li><li>字符類型，支持Unicode</li></ul><h4 class=pgc-h-arrow-right>複合類型`</h4><p>比較新一點的語言都支持一些複雜一點的基本組合類型。</p><p>tuple和其它語言的比較類似，用括號語法來聲明，基本用法可以看下邊這個簡單的例子</p><pre><code>let tup = (1, 2.2, "something")let (a, b, c) = tuplet secondElem = tup.1</code></pre><p>第一行代碼聲明一個含有三個不同類型的元素的元組；第二行代碼則將元組中的元素逐一取出，和Python的用法比較類似。除了這種提取方式，元組元素<strong>也可以用點語法</strong>來訪問元素，如上邊的第三行代碼則用tup.1則取出第二個元素；比C++11的模板元語法簡單多了。</p><p>數組則用於表示<strong>具有相同類型的元素的集合</strong>，如let arr = [1, 2, 3, 4, 5],如果類型不一致則會有編譯錯誤報出。和C/C++這中的類似，數組元素一般是分配在棧上的，其大小在編譯器應該是預先確定的；如果需要可變長的容器，則需要Vector類型。數組越界的檢查默認也包含在語言中了，如果訪問越界的下標，默認程序就會崩潰；當然Rust的錯誤處理機制也有些特殊，容後探討。</p><h4 class=pgc-h-arrow-right>容器類型</h4><p>Rust支持以下基本的容器類型</p><ul><li>Vector 該類型用於存儲邏輯上的列表類型，其正式名字是Vec,用Vec::new()創建空的向量，因為其是用泛型實現的，我們必須指定類型註解；即使用 let v: Vec&lt;i32> = Vec::new() 來生成一個新的向量v</li><li>String 是<strong>作為一個庫提供</strong>的而不是基本的語言機制；其實現和C++的比較類似，內部也使用一個Vec&lt;u8>來存儲數據的，因此考慮到國際化的原因，其操作可能比其它語言中的要複雜一些；幸運的是，這些細節以及被標準庫所封裝。</li><li>Hashmap 用於表述邏輯上的<strong>哈希關聯容器</strong>；其提供的API和C++/Java的比較類似，功能上比C++的複雜一些但比Java的更精簡一點</li></ul><h3 class=pgc-h-arrow-right>函數</h3><p>作為基本編程要素的函數在Rust中的定義沒有什麼特別特殊的地方，除了其類型聲明是後置風格之外，其返回類型（如果不能被自動推斷）用->來聲明，比如</p><pre><code>//一個返回int類型的函數fn thisIsAFunction(parA: i32, parB: string) -&gt; int {    //some implementation}</code></pre><p>函數的實現體本質上是一個block，由一系列的表達式組成（當然表達式也是用分號分隔的)，同時它<strong>還支持Ruby風格的自動返回最後一個表達式</strong>的寫法， 僅僅需要最後一個表達式省略分號即可；比如這個簡單的函數</p><pre><code>fn five() -&gt; i32 {    5}</code></pre><p>懶惰是偉大程序員的優良品質嘛。由於我們有內置的tuple類型，因此Rust是可以允許有多個返回值的；比較典型的一個場景是用戶錯誤處理的情況，可以返回一個Result，同時攜帶錯誤碼和可能的原因;稍後會仔細看一下異常處理的部分。</p><h4 class=pgc-h-arrow-right>函數和宏</h4><p>Rust本身支持語法層面的宏，並且其標準庫提供了很多各種各樣的宏，譬如最常用的打印函數其實就是一個宏；所有的宏使用!後綴來區分。 println!("The value of x is {}, y is {}", x, y)用於打印出x和y的值；其語法形式非常像一些常見的Java庫所支持的格式，可以用大括號來打印對象。</p><p>宏是在編譯的早期階段被展開的，和C中的宏原理類似，雖然Rust的語法看起來更簡潔一些；但是依然有很多新的語法構造，簡單來說可以認為Rust的宏是用macro_rules和模式匹配來實現的。</p><p>從可維護的角度來說，應該做好這種因為宏代碼往往意味著<strong>更難理解和調試</strong>。很多時候，需要將宏作為最後一種不得已而為之的措施。比C中的宏好一點的是，Rust提供了對宏進行調試的方式，可以在其編譯器的命令行中加入--pretty expand選項來查看展開的代碼。</p><h3 class=pgc-h-arrow-right>錯誤檢查機制</h3><p>現實生活中的軟件總是有各種各樣的錯誤<strong>需要被正確處理但沒有被及早處理</strong>就洩漏到了客戶現場。Rust採用的設計思路是，儘早強迫程序員去顯示處理並以編譯器錯誤的方式提示程序員。</p><p>和Java的關於錯誤分類的思路類似，Rust也<strong>區分可恢復的錯誤和不可恢復的錯誤</strong>，並提供了相應的語言機制上的支持。可恢復的錯誤一般是一些環境的錯誤，譬如文件找不到或者網絡連接失敗等情況，實現上可以用重試等策略來嘗試自動恢復。不可恢復的錯誤往往意味著編程錯誤或低級bug，這種情況下最好的思路是直接讓程序崩潰，並修復代碼。</p><p>和Java不同的是，Rust裡<strong>沒有異常</strong>支持！對於可恢復異常，Rust使用Result&lt;T, E>類型來封裝處理結果，而不可恢復異常則提供panic!未來終止程序繼續執行。</p><h4 class=pgc-h-arrow-right>不可恢復異常的支持</h4><p>遇到不可恢復異常的時候，panic!宏會打印錯誤消息（程序員指定），<strong>展開線程棧幀，打印出實際出錯的源代碼位置</strong>。如果需要打印backtrace信息，則可以在程序運行前設置環境變量RUST_BACKTRACE。如果忘記設置的話，默認的打印輸出會給出溫馨的提示。</p><p>如果不希望展開棧幀而直接暴力終止程序，可以在Cargo.toml中指定</p><pre><code>[profile.release]panic='abort'</code></pre><h4 class=pgc-h-arrow-right>可恢復異常</h4><p>可恢復異常用一個泛型類Result來傳遞結果，其定義是</p><pre><code>enum Result&lt;T, E&gt; {    Ok(T),    Err(E)}</code></pre><p>可以使用枚舉類型的<strong>模式匹配</strong>（見後述) 來優雅的解決，譬如這個操作文件的例子</p><pre><code>use std::fs::File;fn main() {    let f = File::open("hello.txt");    let f = match f {        Ok(file) =&gt; file,        Err(error) =&gt; {            panic!("There was a problem opening the file: {:?}", error)        },    };}</code></pre><p>Rust支持一種<strong>更簡潔的方法</strong>來簡化上述的樣板代碼let f = File::open("hello.txt").unwrap()則返回正常情況下的返回值，如果有異常則直接調用panic!來終止程序。還有一種更”偷懶/簡潔”的做法是，加上額外的描述字符串 - 大部分情況下出錯了我們總想額外打印一些信息,可以用</p><pre><code>let f = File::open("hello.text").expect("Unable to open file...")</code></pre><h4 class=pgc-h-arrow-right>異常的傳遞和擴散</h4><p>這是一個常見的場景，某個API的使用者不想自己去處理異常場景，僅僅想將其傳遞給自己的調用者去處理，或者程序中有個統一的地方處理異常(通常來說可能不是一個好的主意！)。最基本的思路是，直接將異常返回的類型簽名寫出來，顯示讓調用者處理。</p><p>下邊這段代碼實現讀入一個文件，從裡邊讀取某個字符串，如果成功則返回該字符串，期間有任何錯誤，則傳遞給調用者。</p><pre><code>fn read_username_from_file() -&gt; Result&lt;String io::Error&gt; {    let f = File::open("hello.txt");    let mut f = match f {        Ok(file) =&gt; file,        Err(e) =&gt; return Err(e),    };    let mut s = String::new();    match f.read_to_string(&amp;mut s) {        Ok(_) =&gt; Ok(s),        Err(e) =&gt; Err(e),    }}</code></pre><p>Rust提供了一種更<strong>簡潔的方式(慣用法)</strong> - 用"?"操作符來傳遞錯誤，類似的代碼可以重寫為</p><pre><code>fn read_username_from_file() -&gt; Result&lt;String io::Error&gt; {    let mut f = File::open("hello.txt")?;    let mut s = String::new();    f.read_to_string(&amp;mut s)?;    Ok(s)}</code></pre><p>需要注意到上邊的代碼使用了block的寫法省略return關鍵字。</p><p>如果追求更精簡的代碼，我們甚至可以用一行代碼來完成上述的函數體</p><pre><code>let mut s = String::new();File::open("hello.txt")?.read_to_string(&amp;mut s)?;Ok(s)</code></pre><p>是否有種熟悉的函數式編程的鏈式寫法的味道？</p><h2 class=pgc-h-arrow-right>內存訪問模型和併發</h2><p>作為一門面向系統編程的語言，Rust決定了不使用GC，同時基於工程上的原因，讓工程師自己來管理內存又顯得不符合時代潮流。Rust採用的策略是讓程序員提供一定的指示給編譯器，然後由編譯器來確保內存的分配和訪問總是安全的。</p><p>對於Rust程序用而言，<strong>理解堆和棧以及對象的生存期/作用域是必須的</strong>，雖然編譯器在後臺做了很多工作。為了支持其內存安全和高效約束的目標，Rust提供了一些特殊的語言機制，包括其獨特的對象唯一所有權的概念和引用語法，其智能指針的概念也比較有特色。</p><p>從語法的角度來看，Rust取消了->操作符，因此所有的方法調用都是採用obj.doSth()的方式；這點沒什麼驚喜，沒有了C的後向兼容負擔，基本上新的語言都是這麼幹的。在語言層面上，Rust仍然<strong>有引用類型的概念</strong>;由於要藉助編譯器來管理內存，Rust的對象作用域規則有些特殊。</p><h3 class=pgc-h-arrow-right>對象的唯一Ownership</h3><p>默認每個對象都是有唯一的所有權的，這個貫穿在Rust的基本設計規則中</p><ol start=1><li><strong>任何一個值</strong>（基本類型或對象）都唯一關聯一個變量，這個變量被稱為其Owner</li><li>任何一個時間點，同一個值<strong>僅僅有一個Owner</strong></li><li>當其Owner離開作用域的時候（無法被程序再次訪問），值將會被從內存中釋放</li></ol><p>舉個簡單的例子，當我們聲明let s = "hello world"的時候，字面量"hello world"的Owner就是s本身；當s離開作用域的時候,對應的字面量空間就會被釋放。作用域的概念和傳統的C/C++/Java中的很類似，大部分情況下，是通過大括號來限定作用域的。</p><p>比較特殊一點的情況和變量的shadow有關，當一個變量通過shadow的方式重新指向另外一個對象的時候，原來的值因為<strong>失去了Owner也應該被編譯器悄悄釋放</strong>了；當然這裡行為仍然是安全的,因為程序沒有通過其它辦法再訪問原來的值。編譯器也可以選擇在真正碰到作用域結束的時候再釋放，然而這些已經屬於編譯器的實現細節了，應用程序無需關心。非常優雅的<strong>關注點分離</strong>設計!</p><h3 class=pgc-h-arrow-right>函數調用中的所有權轉移</h3><p>和C/C++中不一樣的是，函數調用的時候，<strong>參數傳遞會造成所有權轉移</strong>即調用者失去了對原來參數的所有權！考慮下邊的例子</p><pre><code>fn main() {    let s = String::from("hello");    do_something(s); //s失去對字符串的所有權！    let x = 5;    do_somethingElse(x); //內置類型被拷貝！}fn do_something(par: String) {    //par 擁有外部傳入參數的所有權} //作用域結束的時候，par對應的對象會被釋放fn do_somethingElse(par: i32) {    // play with par}</code></pre><p>上述例子中，當調用了do_something(s)之後，雖然s還可以訪問但已經失去了對應對象的所有權，其行為和C++11/14中的Move很像。第二個例子中x對象卻依然可以訪問，這裡的不同是，Rust對象對<strong>分配在棧上的對象默認採用copy方式</strong>處理， 所以僅分配在內存堆上的對象被Move，棧上的對象（編譯器必須知道大小）默認是被複制過去的。</p><p>對於分配於堆上的（大小運行期才知道）對象，Rust也提供了clone方法來（其實是泛型的annotation）執行深度拷貝。</p><p><strong>函數返回的時候，默認也會轉移所有權</strong>，這點和函數調用的參數傳遞情況類似，只不過是傳遞/接收參數的順序反了過來，不再詳述。</p><h4 class=pgc-h-arrow-right>引用類型</h4><p>如果默認的轉移所有權的方式不符合實際的場景，Rust還提供了引用類型來指示傳遞過程中，<strong>僅僅保留對原來參數的引用</strong>而不轉移所有權；概念上和C的指針很相像，只是有很多額外的措施避免濫用指針可能出現的空指針、懸掛指針等複雜問題。</p><p>引用類型在語法上用&符號來表示，可以用於修飾標誌符，熟悉C/C++的應該不陌生；唯一有點麻煩的是，調用者和函數聲明都必須顯示聲明引用類型， 如下邊的例子</p><pre><code>fn calculate_lenght(s: &amp;String) -&gt; usize {    s.len()}let s1 = String::from("hello");let len = calculate_length(&amp;s);println!("The length of '{}' is {}", s1, len);</code></pre><p>默認的引用類型是隻讀的，因為這個<strong>對象是借來的</strong>，被調用函數沒有所有權；嘗試去修改的話，則會被編譯器報錯攔住。又是一個精妙的設計，多少粗心的錯誤可以被精明的編譯器攔住。</p><h4 class=pgc-h-arrow-right>可修改的引用和安全性</h4><p>如果實在需要在被調用函數中修改傳入的引用參數，那麼也是可以聲明類型為 &mut SomeType的，只是出於數據安全性的考慮（避免可能的運行期錯誤), Rust定義瞭如下規則來<strong>保證對象的訪問總是安全的</strong>；任何可能引起Race Condition的訪問模式都<strong>儘量被編譯器攔截住</strong>，這樣成功編譯的代碼，出現運行期錯誤的可能性被大大降低了。</p><ol start=1><li>引用的對象必須是合法的</li><li>同一個作用域內（對象是可以被程序訪問到的），可以有多個只讀的引用</li><li>同一個作用域內，如果已經有一個可修改引用，那麼不允許存在其它任何引用，<strong>即使是隻讀的也不行</strong></li><li>不同的作用域內，可以有多個可修改的引用；這裡因為對對象的修改是相互隔離的，因此不會有意外情況發生;該規則能保證程序邏輯正確的同時，又儘可能給上層程序更多的自由度</li></ol><p>上述最後一條規則其實意味著我們可以有意利用它，通過大括號來創建不同的作用域，寫出更簡潔的代碼，比如</p><pre><code>let mut aStr = String::from("hello"){    let r1 = &amp;mut s;    //do sth with r1} //r1 離開作用域let r2 = &amp;mut s;//基於r2的修改操作</code></pre><p>另外一種常見的指針錯誤是”懸掛指針”,在傳統的C++程序中，當一個指針指向一個不存在的對象的時候，緊接著所有對指針的操作會<strong>導致未定義的行為</strong>；由於實際出現錯誤的地方和真正“製造出懸掛指針”的地方可能相距萬里，這類運行期的錯誤往往會耗費程序員大量寶貴的時間。考慮下邊的例子</p><pre><code>fn main() {    let reference_to_nothing = dangle();}fn dangle() -&gt; &amp;String {    let s = String::from("hello");    &amp;s}</code></pre><p>如果嘗試編譯上述代碼，rust編譯器會清晰的報告一個<strong>對象生存期</strong>錯誤</p><pre><code>error[E0106]: missing lifetime specifier --&gt; dangle.rs:5:16   | 5 | fn dangle() -&gt; &amp;String {   |                ^^^^^^^   |   = help: this function's return type contains a borrowed value, but there is no     value for it to be borrowed from   = help: consider giving it a 'static lifetimeerror: aborting due to previous error</code></pre><h4 class=pgc-h-arrow-right>對象生存期</h4><p>在Rust的內部實現中，一個隱含的邏輯是，<strong>任何一個引用都關聯著一個對於的生存期</strong>，大部分情況下生存期都可以由編譯器自動推導得到而不需要使用者格外留意。當具體的實現中期望引用的生存期可以根據某些條件呈現不同的行為的時候，程序員必須提供一些輔助措施告訴編譯器這些額外的判斷信息。</p><p>Rust編譯器內部有一個成為BorrowChecker的工具，它在程序編譯的過程中會檢查是否所有的引用是合法的。當它無法判斷引用的生存期的時候，程序員需要在定義的地方傳入一些類似於檢查點的生存期指示幫助編譯器正常檢查。</p><p>考慮一個取2個字符串slice長度最大者並將其返回的一個函數</p><pre><code>fn longest(x: &amp;str, y:&amp;str) -&gt; &amp;str {    if x.len() &gt; y.len() {        x    } else {        y    }}</code></pre><p>編譯這段程序的時候，編譯器就會報錯說，不知道如何決定返回的引用的生存期，因為它要麼是x，要麼是y， 卻是由程序的<strong>運行期的行為來動態決定</strong>的，編譯器沒有辦法在編譯的過程中做決定。修補這個錯誤則需要在函數簽名中加入生存期標記</p><pre><code>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {    if x.len() &gt; y.len() {        x    } else {        y    }}</code></pre><p>這樣編譯器就可以知道其實參數和返回值的生存期是一致的，不會產生意外的非法訪問或者Race Condition。這裡採用的語法是泛型的語法，後邊會詳細考察一下Rust的泛型支持。</p><p>生存期檢查的概念是Rust獨有的，其採用的類泛型的語法學習起來也顯得不是很清晰易懂；這也許是最迷人也最晦澀的特性，從設計的角度來說， <strong>犧牲一定的簡單性來達到安全編程又不損失性能的目標</strong>也許是個不錯的折中; 既想要高層的抽象，又想要極致的性能，還不想有太多意外的錯誤是個<strong>刀劍上跳舞的極致挑戰</strong>，這方面Rust做的很不錯。</p><h3 class=pgc-h-arrow-right>智能指針</h3><p>默認的引用方式支持生存期檢查和對象借用，實質上採用的仍然是所有者唯一的模型；實際應用場景中，程序員可能需要選擇一個可以<strong>被多個所有者共享</strong>的對象生存期模型， 一如C++中很常用的基於自動引用計數的shared_ptr的樣子。</p><p>Rust通過標準庫的方式提供了額外的對象生存期管理模型，包括</p><ul><li>Box&lt;T>類型用於表示一個指向單個堆上分配的對象的指針，該<strong>指針的大小在編譯期間是可知的</strong>從而我們可以用它來定義遞歸的數據結構</li><li>Deref Trait用於表示一個允許通過解引用來訪問其封裝的數據的智能指針</li><li>RefCell&lt;T> 用來支持可以修改某個不可變參數內部隱藏的數據的模式；默認情況下，引用規則不允許這樣的操作。這種情況下會產生不安全的代碼，需要程序員做一些額外的處理</li><li>Rc&lt;T>和RefCell&lt;T>用於支持環形引用而不引入內存洩露，這個在GC的算法中很常見</li></ul><p>細節不一一展開探討，總體上而言智能指針其實是接管了對象的所有權，並且<strong>在智能指針內部做自動的控制</strong>；這一思路現代C++的實踐是英雄所見略同。</p><h3 class=pgc-h-arrow-right>更簡潔的併發支持</h3><p>支持<strong>安全而又高效</strong>的併發編程是Rust另外一個雄心勃勃的目標。同時Rust又力圖做到儘可能的簡潔。從語言實現上來說，Rust採用了和控制內存安全訪問以及對象所有權/生存期以及類型系統完全相同的工具來解決併發的問題， 儘管這些機制看起來和併發安全相差甚遠。</p><p>經由大量的類型系統檢查、對象生存期檢查；大量的併發編程問題都可以在編譯器被捕獲，從而<strong>編譯通過的代碼往往就意味著沒有併發安全性的問題</strong>找上門；程序員可以放心的重構其代碼而不用太擔心重構後的代碼會破壞併發安全性；因此Rust稱之為“無所畏懼的併發”。</p><p>Rust的併發編程支持一些流行的併發編程模型</p><ul><li>基於消息傳遞的CSP模型,這也是Golang所採用的併發方式</li><li>傳統的基於Mutex和對象的所有權來控制共享數據訪問的方式 - Rust的類型系統和所有權控制使得其中的挑戰降低了不少</li></ul><p>從設計上來說，併發支持不是Rust的核心語言的部分，所有的<strong>併發機制都是通過標準庫</strong>來提供的，這也意味著更多擴展的可能;有新的併發訪問方式，那就寫新的庫唄。</p><h2 class=pgc-h-arrow-right>模塊系統</h2><h2 class=pgc-h-arrow-right>編程範式和高級特性</h2><p>從編程範式的角度來看，Rust本身其實支持多種編程範式因為其某種程度上對標的是現代的C++或者Golang這樣的競爭對手。</p><h3 class=pgc-h-arrow-right>過程式編程</h3><p>傳統的過程式編程風格和基本的C模型比較接近；其定義結構體的方式和C比較類似，依然是採用struct來組織數據，所不同的是Rust支持<strong>“方法”和實現分開</strong>定義，通過新的關鍵字impl來添加新的方法實現。</p><p>考慮一個簡答的例子，定義個矩形以及對應的area方法來計算其面積</p><pre><code>struct Rectangle {    length: u32,    width: u32,}impl Rectangle {    fn area(&amp;self) -&gt; u32 {        self.length * self.width    }}</code></pre><p>這裡的area方法綁定於該Rectangle上，第一個參數總是&self這樣編譯器可以自動推導出其類型是所綁定的struct對象；因為這裡的參數仍然是一個引用， 默認是不能修改結構體的參數，當需要修改時候，可以指定&mut self從而獲取一個可修改的引用。這裡引用的生存週期模型仍然是適用的。</p><p>調用的時候，只需要構造一個結構然後，採用structObj.callMethod(...)語法即可;大概是出於簡化語言的考慮，Rust只支持簡單的.語法而丟棄了古老的->操作符； ->的使用僅僅限於指定函數的返回類型上，乾淨清爽了許多。</p><pre><code>let rect = Rectangle { length: 50, width: 30 };println!("The area of rectangle is {}", rect.area())</code></pre><p>Rust也支持類似C++中的靜態函數的概念，對應的機制Rust稱為<strong>關聯函數</strong>，這樣的機制對大型代碼的組織是很有意義的,可以方便地解決名字衝突的問題。當定義在impl塊裡的函數其參數中沒有self的時候，Rust會認為其是一個和某個具體的數據結構無關的函數，它和該結構體類<strong>在同一個命名空間</strong>中。比如我們前邊已經看到的String::from("hello")這樣的調用就是將構造方法放置在String的impl塊裡，但是完全沒有使用self參數。</p><p>只是現代的C++社區因為有更完善的語言層面的命名空間隔離機制，其實已不太推薦這種古老的靜態函數組織方式。</p><h3 class=pgc-h-arrow-right>面向對象和泛型編程</h3><p>從形式上來說，Rust不提供對傳統的面向對象編程的直接支持，但提供了一些更復雜的<strong>面向接口編程的語言級別機制</strong>。這一核心武器就是Rust的Traits。某種程度上說，面向接口編程是面向對象編程最核心的精髓之一；繼承、封裝和多態這些基本的武器都可以用面向接口編程的方式來達到。</p><p>Rust的泛型編程實現上有很明顯的C++的影子，不同的是它通過Traits機制巧妙的將<strong>編譯器多態和運行器多態統一為一體</strong>了。</p><h4 class=pgc-h-arrow-right>Traits</h4><p>Traits從<strong>概念上來說就是接口</strong>，它是Rust支持可擴展程序的基礎；它既可以支持編譯器多態（類似於C++的模板元但是比模板元更為簡單一些），也可以支持基於動態分發技術的運行器多態。從設計的角度來看，Traits機制受<strong>C++的設計哲學</strong>影響比較深,同樣希望達到<strong>零成本的抽象</strong>這一至高目標</p><blockquote><p>C++ implementations obey the zero-overhead principle: What you don’t use, you don’t pay for [Stroustrup, 1994]. And further: What you do use, you couldn’t hand code any better.</p><p>Stroustroup</p></blockquote><p>一個描述Hash函數的Traits定義如下</p><pre><code>trait Hash {    fn hash(&amp;self) -&gt; u64;    //can have more functions}</code></pre><p>兩個實現了該Traits的結構可以定於如下(不一定必須放在同一個源代碼文件中)</p><pre><code>impl Hash for bool {    fn hash(&amp;self) -&gt; u64 {        if *self { 0 } else { 1 }    }}impl Hash for i64 {    fn hash(&amp;self) -&gt; u64 {        self as u64    }}</code></pre><p>和傳統的C++中的抽象類或Java中的接口不同的時候，Traits是半開放的，這意味著我們可以<strong>打開某個定義好的結構</strong>，為其添加新的實現；有點類似Ruby的模塊擴展方式。當然Rust 仍然是靜態語言並且是強類型的。C++的模板元雖然可以達到類似的效果，但只支持編譯器多態，並且其Concept的支持雖然千呼萬喚卻一直沒有進入語言標準。</p><h4 class=pgc-h-arrow-right>基於泛型的編譯器多態</h4><p>考慮一個適用上述Traits的例子</p><pre><code>fn print_hash&lt;T: Hash&gt;(t: &amp;T) {    println!("The hash is {}", t.hash())}print_hash(&amp;true); // calls with T=boolprint_hash(&amp;12_i64); //calls with T=i64</code></pre><p>這裡定義了一個打印Hash的泛型函數print_hash，要求對應的類型必須實現了Hash；實際調用的時候，編譯器可以做類型檢查來判斷對應的實際類型是否滿足Traits約束；和C++的Concept非常相像。</p><p>此外這種類型約束方式還是可以組合的，當期望泛型類滿足多個Traits約束的時候，可以用+將其串起來， 比如 &lt;T: Hash + Eq>則要求泛型類T必須同時實現Hash和Eq才能編譯通過。</p><h4 class=pgc-h-arrow-right>動態分發的運行期多態</h4><p>當多態行為依賴於具體運行期才精確得知的條件的時候，泛型就無能為力了。Rust的解決方式是，採用<strong>額外的中間層</strong>-指針來達到。比如在GUI編程中，我們經常需要處理界面元素的點擊事件，傳統的面向對象思路是定義一個Traits,然後在具體的界面元素上添加一個事件監聽者列表</p><pre><code>trait ClickCallback {    fn on_click(&amp;self, x: i64, y: i64);}struct Button&lt;T: ClickCallback&gt; {    listeners: Vec&lt;Box&lt;ClickCallback&gt;&gt;;}</code></pre><p>由於結構體的大小必須在編譯期確定，因而直接放一個大小不確定的ClickCallback就不能編譯通過了；標準庫中提供了智能指針來幫我們很優雅地解決了這個問題；因為指針的大小總是確定的。具體到實現上，其<strong>原理和C++中的虛函數表</strong>非常類似，一個封裝了Traits的智能指針（這裡是Box）內部結構上類似於一個vtable，其指向一個在運行期動態構造的函數表。在調用的地方，編譯器可以自動查找具體實現了對應Traits的結構的函數表，轉到正確的調用地址。</p><h3 class=pgc-h-arrow-right>函數式編程</h3><p>函數式編程風格具有更高的抽象層次和更豐富的表達能力，更有利於寫出<strong>聲明式風格</strong>的代碼。較新的編程語言無一例外都或多或少對函數式編程風格提供支持。Rust的函數式編程具有明顯的<strong>Haskell痕跡</strong>。</p><h4 class=pgc-h-arrow-right>枚舉類型Enum</h4><p>Rust的枚舉類型和傳統的C++/Java中的枚舉的概念類似，都可以用來表示取值有固定可能性的數據類型；通過與泛型的結合，Enum還擁有和Haskell的抽象數據類型ADT相同的擴展能力。</p><p>最簡單的枚舉類型定義可以是如下的樣子</p><pre><code>enum IpAddrKind {    V4,    V6}</code></pre><p>這裡每個具體的枚舉值都是一個不同的具體值，同時他們的類型是一樣的。更復雜一點的情況是，Enum支持<strong>每個枚舉的值可以有不同的類型構造</strong>，如</p><pre><code>enum IpAddr {    V4(u8, u8, u8, u8),    V6(String),}let home = IpAddr::V4(127, 0, 0, 1)let lo = IpAddr::V6(String::from("::1"))</code></pre><p>更一般地，具體的枚舉值可以用不同的類型來構造出來;從而我們由此將<strong>不同類型的數據聚合在一起形成一個抽象的定義</strong>。</p><pre><code>struct IpAddr4 {    // 細節省略}struct IpAddr6 {    // 細節省略}enum IpAddr {    V4(IpAddr4),    V6(IpAddr6)}</code></pre><h4 class=pgc-h-arrow-right>模式匹配</h4><p>一個Enum中可能封裝了不同的數據，當需要對不同的可能的數據做不同的處理的時候，Rust採用模式匹配的方式來提高代碼的可讀性。模式匹配是一種<strong>特殊的表達式</strong>，採用match關鍵字和一個包含<strong>枚舉了所有可能的取值以及其處理代碼</strong>的代碼塊組成。譬如考慮上面的地址定義，如果需要對不同的地址類型有不同的處理，可以用模式匹配的方式寫為</p><pre><code>fn handle_address(addr : IpAddr) -&gt; i32 {    match addr {        IpAddr::V4 =&gt; 1,        IpAddr::V6 =&gt; 2,    }}</code></pre><p>這裡每一個=>對應,分隔開，其左邊的部分是某個具體的枚舉變量值，右邊是對應的處理表達式。當表達式不止一條語句的時候，可以用大括號隔開。</p><p>模式匹配必須保證<strong>所有的枚舉值</strong>都必須被處理過；並且處理表達式的類型必須是一樣的；否則編譯器會報錯。當枚舉的可能取值有很多個而處理代碼只對其中部分可能值感興趣，可以用_來表示可以匹配所有之前未匹配到的值。</p><p>另外一種特殊的情況是，我們僅僅關心某個枚舉值中的一個的時候，match語法依然顯得比較囉嗦；Rust提供了特殊的語法來簡化代碼，如</p><pre><code>let some_u8_value = Some(0u8);match some_u8_value {    Some(3) =&gt; println!("three!")    _ =&gt; (),}</code></pre><p>可以改寫為</p><pre><code>if let Some(3) = some_u8_value {    println!("three!")}</code></pre><p>類似的我們也可以像常規的處理一樣加上一個else分支來處理其它不匹配的情況。</p><h4 class=pgc-h-arrow-right>Option類型</h4><p>Option是一個封裝類型，其概念和Haskell中的Monad或Java8中的Optional的作用比較類似；都是用於表示一種要麼存在一個值要麼沒有值的容器。它比空指針有優勢的地方在於它是一種應用邏輯層的抽象；是用於替代空指針的一個很好的工具。</p><blockquote><p>I call it my billion-dollar mistake. At that time, I was designing the first comprehensive type system for references in an object-oriented language. My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn’t resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years.</p><p>Tony Honare, the inventor of null</p></blockquote><p>Rust中的Option是一種<strong>構建於泛型技術上的特殊的enum</strong>類型</p><pre><code>pub enum Option&lt;T&gt; {    None,    Some(T),}</code></pre><p>標準庫提供了一些成員函數來實現常見的綁定/鏈式操作範式</p><ul><li>fn is_some(&self) -> bool 判斷是否有值</li><li>fn is_none(&self) -> bool 判斷是否為空</li><li>fn unwrap(self, msg: &str) -> T 用於提取內部存儲的值，如果不存在則用給定的消息panic</li><li>fn unwrap(self) -> T 移動內部存儲的值如果其存在的話；不存在則panic</li><li>fn unwrap_or(self, def: T) -> T 存在的話返回其存儲的值，否則返回提供的默認值</li><li>fn unwrap_or_else&lt;F>(self, f: F) -> T where F: FnOnce() -> T 嘗試提取值，如果不存在調用給定的函數生成一個值</li><li>fn map&lt;U, F>(self, f: F) -> Option&lt;U> where F: FnOnce(T) -> U 經典的map操作，將值通過給定的函數轉換成另外一個值並封裝成新的Option，如果不存在，則也重新封裝成目標類型的空值</li><li>fn map_or&lt;U, F>(self, default: U, f:F) -> U where F: FnOnce(T) -> U 類似於map操作，但返回轉換後的類型；如果空則返回給定的默認值</li><li>fn as_ref(&self) -> Option&lt;&T> 返回引用類型</li><li>fn as_mut(&mut self) -> Option&lt;&mut T>返回可修改的類型</li><li>fn iter(&self) -> Iter&lt;T> 返回迭代器類型，可以遍歷其值，這裡的迭代器總是隻能返回一個值</li><li>fn and&lt;U>(self, optB: Option&lt;U>) -> Option&lt;U> 如果沒有值，則返回空，否則返回給定的新的optB，便於鏈式操作減少邏輯判斷</li><li>…</li></ul><h4 class=pgc-h-arrow-right>閉包Closure</h4><p>閉包是另外一個重要的函數式編程工具；Rust採用的語法是比較類似於Ruby，其內部實現上則採用C++的<strong>匿名函數模型</strong>；即閉包對象其實生成的是匿名的函數對象。一個最簡單的例子</p><pre><code>let calculate = |a, b| {    let mut result = a * 2;    result += b;    result};assert_eq!(7, calculate(2, 3)); // 2 * 2 + 3 == 7assert_eq!(13, calculate(4, 5)); // 4 * 2 + 5 == 13</code></pre><p>閉包的<strong>類型註解約束要比函數定義的要求寬鬆</strong>一些，即不需要指定返回類型也可以;和現代C++的generic lambda特性比較類似；都是為了方便程序員寫出更簡潔、乾淨的代碼。如下的代碼是完全等價的</p><pre><code>fn  add_one_v1   (x: i32) -&gt; i32 { x + 1 }  // a functionlet add_one_v2 = |x: i32| -&gt; i32 { x + 1 }; // the full syntax for a closurelet add_one_v3 = |x|             { x + 1 }; // a closure eliding typeslet add_one_v4 = |x|               x + 1  ; // without braces</code></pre><p>從代碼可讀性和可維護性的角度來看，最好<strong>不用閉包來寫太長/太複雜的代碼塊</strong>， 因為隨著匿名代碼塊中邏輯的增加，上下文邏輯變得更加模糊；這個時候，用一個命名良好的子函數反而更清晰便於維護。</p><h2 class=pgc-h-arrow-right>軟件工程支持 - 工具和方法</h2><p>Rust提供了成熟的軟件工程實踐支持；有相對完善的模塊文檔和官方的gitboook。</p><h3 class=pgc-h-arrow-right>Creates && Cargo系統</h3><p>作為一門站在巨人肩上的語言，Rust吸收了已有的一些成熟的包管理系統的經驗，並提供了類似的機制來支持更好的協作</p><ul><li>Creates和其包分發系統有點Hackage的影子，又有點NPM的味道</li><li>版本依賴管理上，和Ruby Gems的處理方式也有些像，雖然toml的格式沒有Ruby的DSL那麼靈活強大</li></ul><p>Cargo是一個類似於C++中的CMake的系統，同時還提供了一些創建項目模板的快捷方式，幫助程序員快速創建項目骨架，更快專注於具體的實現而不是構建細節。可以用它的子命令來</p><ul><li>檢查依賴，自動升級依賴</li><li>增量編譯代碼並報告錯誤</li><li>根據特定的開關選項執行對應的測試</li><li>生成文檔</li><li>運行項目生成的可執行文件（如果不是編譯一個庫）</li><li>運行benchmark</li><li>安裝編譯好的二進制構建結果</li><li>搜索crates中註冊的模塊</li></ul><p>具體功能可以查看其命令行幫助。</p><h3 class=pgc-h-arrow-right>IDE和編輯器插件支持</h3><p>某些程序員更喜歡IDE，另外一些人則更熟悉命令行的Vim/Emacs或者其它輕量級的編輯器。社區目前提供了比較豐富的支持，包括對Eclipse/IntelliJ/Visual Studio的IDE插件， 以及對Atom/Visual Studio Code/Sublime/Vim/Emacs的插件支持；基本上<strong>比較主流的編程環境的支持都有</strong>了；具體支持程度如何，有待進一步驗證；官方的文檔看起來非常值得一試。</p><h3 class=pgc-h-arrow-right>測試</h3><p>Rust支持在包中提供單元測試和功能測試。默認的工具會搜索源碼目錄中的所有單元測試，並自動組織起來運行，同時也提供了一些高級的測試支持。Rust希望程序員明確的區分這兩種測試，並採用不同的約定</p><ul><li>所有的單元測試都和被測試的源代碼放在一起，並且支持對private方法的測試（當然這個很有爭議，個人建議不要測試private）</li><li>集成測試被放在專門的test文件夾下邊，可以放在多個文件中，Cargo將會為每個文件生成一個crates</li></ul><p>cargo test命令可用來執行所有的測試，並且<strong>默認是併發執行</strong>的;這樣開發的反饋週期會更短；也可以用命令來顯示要求線性執行 - 傳入 --test-threads=1即可。一些更復雜的特性，如指定某個case的執行，跳過某些特定的case，以及按照某個過濾條件來選擇特定的case，忽略case運行過程中的打印輸出等特性也被貼心的支持了。</p><h2 class=pgc-h-arrow-right>總結</h2><p>在注重極致性能又強調工程協作和擴展性的系統編程領域，Rust做了比較大膽的嘗試，在不引入垃圾收集並保持強類型檢查的前提下， 它期望能將<strong>C++的零成本抽象推向一個新的高度</strong>而又能避免陷入傳統C/C++語言指針訪問安全性以及複雜的模板元編程等複雜性的泥潭。</p><p>它的泛型編程支持和強調值對象唯一所有權的概念和對象生存週期的強制檢查使得多線程併發編程變得輕鬆簡單；加上強類型檢查的約束，編譯通過的程序往往運行期錯誤也變得很少，這一來<strong>自於Haskell的設計哲學</strong>深深地影響著Rust。</p><p>從一開始就加入的包管理器機制和對豐富的軟件工程工具支持以及對開源社區的熱情擁抱，使得Rust一開始就汲取了傳統C/C++語言工程化支持不足的一些教訓。中心化的軟件倉庫以及對流行IDE、編輯器環境的支持使得它可以更好地贏得社區的支持。</p><p>與此同時隨著更新節奏的加快，基於ISO標準化的C++語言也在通過更快的迭代速度和更短的更新週期對這些新加入的競爭者予以反擊；期望Rust能在系統編程領域掀起新的波瀾。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Rust</a></li><li><a>編程</a></li><li><a>語言</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f9a0ab8.html alt=P4語言編程詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b0509dc83f844c6e9e133d81e9855e4b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f9a0ab8.html title=P4語言編程詳解>P4語言編程詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ba54309.html alt=C語言編程第19講——斷言的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/92ee4886-fdd7-4a4a-b45a-d647ef966836 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ba54309.html title=C語言編程第19講——斷言的使用>C語言編程第19講——斷言的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd5b00b1.html alt=嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/40851dc497a8409bbff6a6aae1e42e8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd5b00b1.html title=嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？>嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2c14705.html alt=C語言編程知識總結，思維導圖版本，事半功倍！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/721353b3b68a41059d980e19083d03e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2c14705.html title=C語言編程知識總結，思維導圖版本，事半功倍！>C語言編程知識總結，思維導圖版本，事半功倍！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34838dce.html alt=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a0b5a50b90804963b14ab394517ae294 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34838dce.html title=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢>C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8f9d60af.html alt=自然語言與編程語言的不同之處 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2212e09b2dac4c80a8c3e8b80da92bb1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8f9d60af.html title=自然語言與編程語言的不同之處>自然語言與編程語言的不同之處</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d208ccdc7f074f67a257d52df74e4f48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html title=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）>C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1d74ece6.html alt=C語言編程入門必做的76題（加速你的學習效率） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/76e1f716eb894036a029992b044b5036 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1d74ece6.html title=C語言編程入門必做的76題（加速你的學習效率）>C語言編程入門必做的76題（加速你的學習效率）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/de0da135.html alt=C語言編程實例3 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/870917da8c744479b2ec65ee0173974e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/de0da135.html title=C語言編程實例3>C語言編程實例3</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9e4e4f6f.html alt=C語言編程實例4 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/870917da8c744479b2ec65ee0173974e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9e4e4f6f.html title=C語言編程實例4>C語言編程實例4</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/daee4c3b.html alt=C語言編程筆記丨利用C語言寫一個小程序——胖胖的愛心桃 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df26c625ad3d44d4b515522c28f5462c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/daee4c3b.html title=C語言編程筆記丨利用C語言寫一個小程序——胖胖的愛心桃>C語言編程筆記丨利用C語言寫一個小程序——胖胖的愛心桃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7b754ba6.html alt="C語言編程筆記丨編寫第一個C語言程序'hello world'，我教你哇" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/ad42f4fc-8976-4d2d-81e8-c62c3808e213 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7b754ba6.html title="C語言編程筆記丨編寫第一個C語言程序'hello world'，我教你哇">C語言編程筆記丨編寫第一個C語言程序'hello world'，我教你哇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/462f5440.html alt=實用C語言編程（第三版）高清PDF class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/31d1bba3-4fda-47c1-8435-00e90b1c2930 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/462f5440.html title=實用C語言編程（第三版）高清PDF>實用C語言編程（第三版）高清PDF</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0aa68fb2.html alt=那些主流編程語言的知識，C語言 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea2299c59ca0407b8cf1263f5a4c42f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0aa68fb2.html title=那些主流編程語言的知識，C語言>那些主流編程語言的知識，C語言</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b9591576.html alt="C 語言簡單編程速成" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/314ac7c9291d4dd99b90139ea102b5c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b9591576.html title="C 語言簡單編程速成">C 語言簡單編程速成</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>