<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>一口氣看完45個寄存器，CPU核心技術大揭祕 | 极客快訊</title><meta property="og:title" content="一口氣看完45個寄存器，CPU核心技術大揭祕 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/273f10c688ab472b94806e9bba4bd0ee"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2a60afe.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2a60afe.html><meta property="article:published_time" content="2020-10-29T21:05:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:05:37+08:00"><meta name=Keywords content><meta name=description content="一口氣看完45個寄存器，CPU核心技術大揭祕"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/2a60afe.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>一口氣看完45個寄存器，CPU核心技術大揭祕</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>序言</strong></h1><p>前段時間，我連續寫了十來篇CPU底層系列技術故事文章，有不少讀者私信我讓我寫一下CPU的寄存器。</p><p>寄存器這個太多太複雜，不適合寫故事，拖了很久，總算是寫完了，這篇文章就來詳細聊聊<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">x86/x64架構</span></strong>的CPU中那些紛繁複雜的寄存器們。</p><p>長文預警，時速較快，請繫好安全帶～起飛~</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/273f10c688ab472b94806e9bba4bd0ee><p class=pgc-img-caption></p></div><p>自1946年馮·諾伊曼領導下誕生的世界上第一臺通用電子計算機<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">ENIAC</span></strong>至今，計算機技術已經發展了七十多載。</p><p>從當初專用於數學計算的龐然大物，到後來大型機服務器時代，從個人微機技術蓬勃發展，到互聯網浪潮席捲全球，再到移動互聯網、雲計算日新月異的當下，計算機變的形態各異，無處不在。</p><p>這七十多年中，出現了數不清的編程語言，通過這些編程語言，又開發了無數的應用程序。</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e28b73c43dbf437da1068498fc44c67e><p class=pgc-img-caption></p></div><p>可無論什麼樣的應用程序，什麼樣的編程語言，最終的程序邏輯都是要交付給CPU去執行實現的（當然這裡有些不嚴謹，除了CPU，還有協處理器、GPU等等）。所以瞭解和學習CPU的原理都是對計算機基礎知識的夯實大有裨益。</p><p>在七十多年的漫長曆程中，也湧現了不少架構的CPU。</p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">MIPS</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">PowerPC</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">x86/x64</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">IA64</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ARM</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">······</span></p></blockquote><p>這篇文章就以市場應用最為廣泛的x86-x64架構為目標，通過學習瞭解它內部的100個寄存器功能作用，來串聯闡述CPU底層工作原理。</p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929">通過這篇文章，你將瞭解到：</span></strong></p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">CPU指令執行原理</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">內存尋址技術</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">軟件調試技術原理</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">中斷與異常處理</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">系統調用</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">CPU多任務技術</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>什麼是寄存器？</strong></h1><p>寄存器是CPU內部用來存放數據的一些小型存儲區域，用來暫時存放參與運算的數據和運算結果以及一些CPU運行需要的信息。</p><p>x86架構CPU走的是<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">複雜指令集（CISC）</span></strong> 路線，提供了豐富的指令來實現強大的功能，與此同時也提供了大量寄存器來輔助功能實現。這篇文章將覆蓋下面這些寄存器：</p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">通用寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">標誌寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">指令寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">段寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">控制寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">調試寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">描述符寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">任務寄存器</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">MSR寄存器</span></p></blockquote><h1 class=pgc-h-arrow-right><strong>通用寄存器</strong></h1><p>首當其衝的是通用寄存器，這些的寄存器是程序執行代碼最最常用，也最最基礎的寄存器，程序執行過程中，絕大部分時間都是在操作這些寄存器來實現指令功能。</p><p>所謂通用，即這些寄存器CPU沒有特殊的用途，交給應用程序“隨意”使用。注意，這個隨意，我打了引號，對於有些寄存器，CPU有一些潛規則，用的時候要注意。</p><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">eax</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 通常用來執行加法，函數調用的返回值一般也放在這裡面</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ebx</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 數據存取</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ecx</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 通常用來作為計數器，比如for循環</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">edx</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 讀寫I/O端口時，edx用來存放端口號</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">esp</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 棧頂指針，指向棧的頂部</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ebp</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 棧底指針，指向棧的底部，通常用</span><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ebp+偏移量</span></span><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">的形式來定位函數存放在棧中的局部變量</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">esi</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 字符串操作時，用於存放數據源的地址</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">edi</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 字符串操作時，用於存放目的地址的，和esi兩個經常搭配一起使用，執行字符串的複製等操作</span></p></blockquote><p>在x64架構中，上面的通用寄存器都擴展成為64位版本，名字也進行了升級。當然，為了兼容32位模式程序，使用上面的名字仍然是可以訪問的，相當於訪問64位寄存器的低32位。</p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">rax rbx rcx rdx rsp rbp rsi rdi</span></p></blockquote><p>除了擴展原來存在的通用寄存器，x64架構還引入了8個新的通用寄存器：</p><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">r8-r15</span></span></strong></p></blockquote><p>在原來32位時代，函數調用時，那個時候通用寄存器少，參數絕大多數時候是通過線程的棧來進行傳遞（當然也有使用寄存器傳遞的，比如著名的C++ <strong><span style="color:#f83929;--tt-darkmode-color: #F83929">this指針</span></strong>使用ecx寄存器傳遞，不過能用的寄存器畢竟不多）。</p><p>進入x64時代，寄存器資源富裕了，參數傳遞絕大多數都是用寄存器來傳了。<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">寄存器傳參的好處是速度快，減少了對內存的讀寫次數。</span></strong></p><p>當然，具體使用棧還是用寄存器傳參數，這個不是編程語言決定的，而是編譯器在編譯生成CPU指令時決定的，如果編譯器非要在x64架構CPU上使用線程棧來傳參那也不是不行，這個對高級語言是無感知的。</p><h1 class=pgc-h-arrow-right><strong>標誌寄存器</strong></h1><p>標誌寄存器，裡面有眾多標記位，記錄了CPU執行指令過程中的一系列狀態，這些標誌大都由CPU自動設置和修改：</p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">CF 進位標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">PF 奇偶標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ZF 零標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">SF 符號標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">OF 補碼溢出標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">TF 跟蹤標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">IF 中斷標誌</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">······</span></p></blockquote><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/61770fc7c7d64e648f3d6fc270547ac3><p class=pgc-img-caption></p></div><p>在x64架構下，原來的eflags寄存器升級為64位的rflags，不過其高32位並沒有新增什麼功能，保留為將來使用。</p><h1 class=pgc-h-arrow-right><strong>指令寄存器</strong></h1><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">eip</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 指令寄存器可以說是CPU中最最重要的寄存器了，它指向了下一條要執行的指令所存放的地址，CPU的工作其實就是不斷取出它指向的指令，然後執行這條指令，同時指令寄存器繼續指向下面一條指令，如此不斷重複，這就是CPU工作的基本日常。</span></p></blockquote><p>而在漏洞攻擊中，黑客想盡辦法費盡心機都想要修改指令寄存器的地址，從而能夠執行惡意代碼。</p><p>同樣的，在x64架構下，32位的eip升級為64位的<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">rip</span></strong>寄存器。</p><h1 class=pgc-h-arrow-right><strong>段寄存器</strong></h1><p>段寄存器與CPU的內存尋址技術緊密相關。</p><p>早在16位的8086CPU時代，內存資源寶貴，CPU使用分段式內存尋址技術：</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2ba520c77daf4b5fad9de0ddc313b6a4><p class=pgc-img-caption></p></div><p>16位的寄存器能尋址的範圍是64KB，通過引入段的概念，將內存空間劃分為不同的區域：分段，通過段基址+段內偏移段方式來尋址。</p><p>這樣一來，段的基地址保存在哪裡呢？8086CPU專門設置了幾個段寄存器用來保存段的基地址，這就是段寄存器段的由來。</p><p>段寄存器也是16位的。</p><p>段寄存器有下面6個，前面4個是早期16位模式就引入了，到了32位時代，又新增了fs和gs兩個段寄存器。</p><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cs</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 代碼段</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ds</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 數據段</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">ss</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 棧段</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">es</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 擴展段</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">fs</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 數據段</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">gs</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 數據段</span></p></blockquote><p>段寄存器裡面存儲的內容與CPU當前工作的內存尋址模式緊密相關。</p><p>當CPU處於16位實地址模式下時，段寄存器存儲段的基地址，尋址時，將段寄存器內容左移4位（乘以16）得到段基地址+段內偏移得到最終的地址。</p><p>當CPU工作於保護模式下，段寄存器存儲的內容不再是段基址了，此時的段寄存器中存放的是<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">段選擇子</span></strong>，用來指示當前這個段寄存器“指向”的是哪個分段。</p><p>注意我這裡的指向打了引號，段寄存器中存儲的並不是內存段的直接地址，而是段選擇子，它的結構如下：</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a0aad37b798491d9a977e962515fd01><p class=pgc-img-caption></p></div><p>16個bit長度的段寄存器內容劃分了三個字段：</p><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">PRL</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 特權請求級，就是我們常說的ring0-ring3四個特權級。</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">TI</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 0表示用的是全局描述符表GDT，1表示使用的是局部描述符表LDT。</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">Index</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 這是一個表格中表項的索引值，這個表格叫</span><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">內存描述符表</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">，它的每一個表項都描述了一個內存分段。</span></p></blockquote><p>這裡提到了兩個表，全局描述符表GDT和局部描述符表LDT，關於這兩個表的介紹，下面介紹描述符寄存器時再詳述，這裡只需要知道，這是CPU支持分段式內存管理需要的表格，放在內存中，表格中的每一項都是一個描述符，記錄了一個內存分段的信息。</p><p>保護模式下的段寄存器和段描述符到最後的內存分段，通過下圖的方式聯繫在一起：</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/92dea583919b4fff9f0f2d1946a19787><p class=pgc-img-caption></p></div><hr><p>通用寄存器、段寄存器、標誌寄存器、指令寄存器，這四組寄存器共同構成了一個基本的指令執行環境，一個線程的上下文也基本上就是這些寄存器，在執行線程切換的時候，就是修改它們的內容。</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/dddbc8f698594d9abec5d58d6f9fbb44><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>控制寄存器</strong></h1><p>控制寄存器是CPU中一組相當重要的寄存器，我們知道eflags寄存器記錄了當前運行線程的一系列關鍵信息。</p><p>那CPU運行過程中自身的一些關鍵信息保存在哪裡呢？答案是控制寄存器！</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e661f2b4c3684fafbe86bca596b5c253><p class=pgc-img-caption></p></div><p>32位CPU總共有cr0-cr4共5個控制寄存器，64位增加了cr8。他們各自有不同的功能，但都存儲了CPU工作時的重要信息：</p><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cr0</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 存儲了CPU控制標記和工作狀態</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cr1</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 保留未使用</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cr2</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 頁錯誤出現時保存導致出錯的地址</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cr3</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 存儲了當前進程的虛擬地址空間的重要信息——</span><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">頁目錄</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">地址</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cr4</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 也存儲了CPU工作相關以及當前人任務的一些信息</span></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">cr8</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">: 64位新增擴展使用</span></p></blockquote><p>其中，CR0尤其重要，它包含了太多重要的CPU信息，值得單獨關注一下：</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/091a8c48996745de8767960433d16a21><p class=pgc-img-caption></p></div><p>一些重要的標記位含義如下：</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">PG</span>: 是否啟用內存分頁</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">AM</span>: 是否啟用內存對齊自動檢查</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">WP</span>: 是否開啟內存寫保護，若開啟，對只讀頁面嘗試寫入時將觸發異常，這一機制常常被用來實現<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">寫時複製</span></strong>功能</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">PE</span>: 是否開啟保護模式</p><p>除了CR0，另一個值得關注的寄存器是CR3，它保存了當前進程所使用的虛擬地址空間的頁目錄地址，可以說是整個虛擬地址翻譯中的頂級指揮棒，在進程空間切換的時候，CR3也將同步切換。</p><h1 class=pgc-h-arrow-right><strong>調試寄存器</strong></h1><p>在x86/x64CPU內部，還有一組用於支持軟件調試的寄存器。</p><p>調試，對於我們程序員是家常便飯，必備技能。但你想過你的程序能夠被調試背後的原理嗎？</p><p>程序能夠被調試，關鍵在於能夠被中斷執行和恢復執行，被中斷的地方就是我們設置的斷點。那程序是如何能在遇到斷點的時候停下來呢？</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/93f25f131c124ddca11b53f8c1a6f034><p class=pgc-img-caption></p></div><p>對於一些解釋執行（PHP、Python、JavaScript）或虛擬機執行（Java）的高級語言，這很容易辦到，因為它們的執行都在解釋器/虛擬機的掌控之中。</p><p>而對於像C、C++這樣的“底層”編程語言，程序代碼是直接編譯成CPU的機器指令來執行的，這就需要CPU來提供對於調試的支持了。</p><p>對於通常的斷點，也就是程序執行到某個位置下就停下來，這種斷點實現的方式，在x86/x64上，是利用了一條<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">軟中斷</span></strong>指令：<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">int 3</span></strong>來進行實現的。</p><p>注意，這裡的<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">int</span></strong>不是指高級語言裡面的整數，而是表示interrupt中斷的意思，是一條彙編指令，int 3則表示中斷向量號為3的中斷。</p><p>在我們使用調試器下斷點時，調試器將會把對應位置的原來的指令替換為一個int 3指令，機器碼為0xCC。這個動作對我們是透明的，我們在調試器中看到的依然是原來的指令，但實際上內存中已經不是原來的指令了。</p><p>順便提一句，兩個0xCC是漢字【燙】的編碼，在一些編譯器裡，會給線程的棧中填充大量的0xCC，如果程序出錯的時候，我們經常會看到很多<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">燙燙燙</span></strong>出現，就是這個原因。</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f0264a4550b743b589525ff5834314b5><p class=pgc-img-caption></p></div><p>言歸正傳，CPU在執行這條int 3指令時，將自動觸發中斷處理流程（雖然這實際上不是一個真正的中斷），CPU將取出IDTR寄存器指向的中斷描述符表IDT的第3項，執行裡面的中斷處理函數。</p><p>而這個中斷描述符表，早在操作系統啟動之初，就已經提前安排好了，所以執行這條指令後，操作系統的中斷處理函數將介入，來處理這一事件。</p><p>後面的過程就多了，簡單來說，操作系統會把觸發這一事件的進程凍結起來，隨後將這一事件發送到調試器，調試器拿到之後就知道目標進程觸發斷點了。這個時候，咱們程序員就能通過調試器的UI交互界面或者命令行調試接口來調試目標進程，查看堆棧、查看內存、變量都隨你。</p><p>如果我們要繼續運行，調試器將會把之前修改的int 3指令給恢復回去，然後告知操作系統：我處理完了，把目標進程解凍吧！</p><p>上面簡單描述了一下普通斷點的實現原理。現在思考一個場景：我們發現一個bug，某個全局整數型變量的值老是莫名其妙被修改，但你發現有很多線程，很多函數都有可能會去修改這個變量，你想找出到底誰幹的，怎麼辦？</p><p>這個時候上面的普通斷點就沒辦法了，你需要一種新的斷點：<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">硬件斷點</span></strong>。</p><p>這時候就該本小節的主人公調試寄存器登場表演了。</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1cf74a43fd8044c6a2ad3039204114f1><p class=pgc-img-caption></p></div><p>在x86架構CPU內部，提供了8個調試寄存器DR0~DR7。</p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929">DR0~DR3</span></strong>：這是四個用於存儲地址的寄存器</p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929">DR4~DR5</span></strong>：這兩個有點特殊，受前面提到的CR4寄存器中的標誌位DE位控制，如果CR4的DE位是1，則DR4、DR5是不可訪問的，訪問將觸發異常。如果CR4的DE位是0，則DR4和DR5將會變成DR6和DR7的別名，相當於做了一個軟鏈接。這樣做是為了將DR4、DR5保留，以便將來擴展調試功能時使用。</p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929">DR6</span></strong>：這個寄存器中存儲了硬件斷點觸發後的一些狀態信息</p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929">DR7</span></strong>：調試控制寄存器，這裡面記錄了對DR0-DR3這四個寄存器中存儲地址的中斷方式（是對地址的讀，還是寫，還是執行）、數據長度（1/2/4個字節）以及作用範圍等信息</p><p>通過調試器的接口設置硬件斷點後，CPU在執行代碼的過程中，如果滿足條件，將自動中斷下來。</p><p>回答前面提出的問題，想要找出是誰偷偷修改了全局整形變量，只需要通過調試器設置一個硬件寫入斷點即可。</p><h1 class=pgc-h-arrow-right><strong>描述符寄存器</strong></h1><p>所謂<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">描述符</span></strong>，其實就是一個數據結構，用來記錄一些信息，‘描述’一個東西。把很多個描述符排列在一起，組成一個表，就成了描述符表。再使用一個寄存器來指向這個表，這個寄存器就是<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">描述符寄存器</span></strong>。</p><p>在x86/x64系列CPU中，有三個非常重要的描述符寄存器，它們分別存儲了三個地址，指向了三個非常重要的描述符表。</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">gdtr</span>: 全局描述符表寄存器，前面提到，CPU現在使用的是段+分頁結合的內存管理方式，那系統總共有那些分段呢？這就存儲在一個叫全局描述符表（<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">GDT</span></strong>）的表格中，並用gdtr寄存器指向這個表。這個表中的每一項都描述了一個內存段的信息。</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">ldtr</span>: 局部描述符表寄存器，這個寄存器和上面的gdtr一樣，同樣指向的是一個段描述符表（<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">LDT</span></strong>）。不同的是，GDT是全局唯一，LDT是局部使用的，可以創建多個，隨著任務段切換而切換（下文介紹任務寄存器會提到）。</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a29690895a9944139ce31994395f4e2b><p class=pgc-img-caption></p></div><p>GDT和LDT中的表項，就是段描述符，描述了一個內存分段的信息，其結構如下：</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f2b12caa3c224edfb026ea8e3bf17723><p class=pgc-img-caption></p></div><p>一個表項佔據8個字節（32位CPU），裡面存儲了一個內存分段的諸多信息：基地址、大小、權限、類型等信息。</p><p>除了這兩個段描述符寄存器，還有一個非常重要的描述符寄存器：</p><p><span style="color:#ff5d6c;--tt-darkmode-color: #FF5D6C">idtr</span>: 中斷描述符表寄存器，指向了<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">中斷描述符表IDT</span></strong>，這個表的每一項都是一箇中斷處理描述符，當CPU執行過程中發生了硬中斷、異常、軟中斷時，將自動從這個表中定位對應的表項，裡面記錄了發生中斷、異常時該去哪裡執行處理函數。</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6bf9962bb8854f5cbc7028c5afeb58da><p class=pgc-img-caption></p></div><p>IDT中的表項稱為<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">Gate</span></strong>，中文意思為<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">門</span></strong>，因為這是應用程序進入內核的主要入口。雖然表的名字叫中斷描述符表，但表中存儲的不全是中斷描述符，IDT中的表項存在三種類型，對應三種類型的門：</p><blockquote><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">任務門</span></span></strong></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">陷阱門</span></span></strong></p><p><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">中斷門</span></span></strong></p></blockquote><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/44ddf1656b534952884bb907dc713f22><p class=pgc-img-caption></p></div><p>三種描述符中都存儲了處理這個中斷/異常/任務時該去哪裡處理的地址。三種門用途不一，其中中斷門是真正意義上的中斷，而像前面提到的調試指令int 3以及老式的系統調用指令int 2e/int 80都屬於陷阱門。任務門則用的較少，要了解任務門，先了解下任務寄存器。</p><h1 class=pgc-h-arrow-right><strong>任務寄存器</strong></h1><p>現代操作系統，都是支持多任務併發運行的，x86架構CPU為了順應時代潮流，在硬件層面上提供了專門的機制用來支持多任務的切換，這體現在兩個方面：</p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">CPU內部設置了一個專用的寄存器——</span><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">任務寄存器TR</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">，它指向當前運行的任務。</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">定義了描述任務的數據結構</span><strong><span style="color:#f83929;--tt-darkmode-color: #F83929"><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">TSS</span></span></strong><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">，裡面存儲了一個任務的上下文（一系列寄存器的值），下圖是一個32位CPU的TSS結構圖：</span></p></blockquote><p>x86CPU的構想是每一個任務對應一個TSS，然後由TR寄存器指向當前的任務，執行任務切換時，修改TR寄存器的指向即可，這是硬件層面的多任務切換機制。</p><p>這個構想其實還是很不錯的，然而現實卻打了臉，包括Linux和Windows在內的主流操作系統都沒有使用這個機制來進行線程切換，而是自己使用軟件來實現多線程切換。</p><p>所以，絕大多數情況下，TR寄存器都是指向固定的，即便線程切換了，TR寄存器仍然不會變化。</p><p>注意，我這裡說的的是絕大多數情況，而沒有說死。雖然操作系統不依靠TSS來實現多任務切換，但這並不意味著CPU提供的TSS操作系統一點也沒有使用。還是存在一些特殊情況，如一些異常處理會使用到TSS來執行處理。</p><p>下面這張圖，展示了控制寄存器、描述符寄存器、任務寄存器構成的全貌：</p><div class=pgc-img><img alt=一口氣看完45個寄存器，CPU核心技術大揭祕 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c014f5c2090841f996598a6cfd96b3e5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>模型特定寄存器</strong></h1><p>從80486之後的x86架構CPU，內部增加了一組新的寄存器，統稱為<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">MSR寄存器</span></strong>，中文直譯是模型特定寄存器，意思是這些寄存器不像上面列出的寄存器是固定的，這些寄存器可能隨著不同的版本有所變化。這些寄存器主要用來支持一些新的功能。</p><p>隨著x86CPU不斷更新換代，MSR寄存器變的越來越多，但與此同時，有一部分MSR寄存器隨著版本迭代，慢慢固化下來，成為了變化中那部分不變的，這部分MSR寄存器，Intel將其稱為Architected MSR，這部分MSR寄存器，在命名上，統一加上了<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">IA32</span></strong>的前綴。</p><p>這裡選取三個代表性的MSR簡單介紹一下：</p><blockquote><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">IA32_SYSENTER_CS</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">IA32_SYSENTER_ESP</span></p><p><span style="background-color:#fff9f9;--tt-darkmode-bgcolor: #151515">IA32_SYSENTER_EIP</span></p></blockquote><p>這三個MSR寄存器是用來實現<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">快速系統調用</span></strong>。</p><p>在早期的x86架構CPU上，系統調用依賴於軟中斷實現，類似於前面調試用到的int 3指令，在Windows上，系統調用用到的是<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">int 2e</span></strong>，在Linux上，用的是<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">int 80</span></strong>。</p><p>軟中斷畢竟還是比較慢的，因為執行軟中斷就需要內存查表，通過IDTR定位到IDT，再取出函數進行執行。</p><p>系統調用是一個頻繁觸發的動作，如此這般勢必對性能有所影響。在進入奔騰時代後，就加上了上面的三個MSR寄存器，分別存儲了執行系統調用後，內核系統調用入口函數所需要的段寄存器、堆棧棧頂、函數地址，不再需要內存查表。快速系統調用還提供了專門的CPU指令<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">sysenter/sysexit</span></strong>用來發起系統調用和退出系統調用。</p><p>在64位上，這一對指令升級為<strong><span style="color:#f83929;--tt-darkmode-color: #F83929">syscall/sysret</span></strong>。</p><h1 class=pgc-h-arrow-right><strong>總結</strong></h1><p>以上就是全部要介紹的寄存器了，需要說明一下的是，這並不是x86CPU全部所有的寄存器，除了這些，還存在XMM、MMX、FPU浮點數運算等其他寄存器。</p><p>這篇文章以x86/x64架構CPU為目標，通過對CPU內部寄存器的闡述，串講了CPU執行代碼機制、內存尋址技術、中斷與異常處理、多任務管理、系統調用、調試原理等多種計算機底層知識。</p><p>作者：軒轅之風</p><p>來源：編程技術宇宙（ID：xuanyuancoding）</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>氣看</a></li><li><a>45</a></li><li><a>CPU</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9850d5c6.html alt="45天日照時數僅37小時 寧波“跨年連陰雨”何時終結" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RFEYDIbGLkZjYc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9850d5c6.html title="45天日照時數僅37小時 寧波“跨年連陰雨”何時終結">45天日照時數僅37小時 寧波“跨年連陰雨”何時終結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5b2e05.html alt=把地球45億年壓縮成一天24小時，瞬間看懂大陸板塊移動（動圖） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/24d46742304946ed942ed97be5c69f72 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5b2e05.html title=把地球45億年壓縮成一天24小時，瞬間看懂大陸板塊移動（動圖）>把地球45億年壓縮成一天24小時，瞬間看懂大陸板塊移動（動圖）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5d01dc93.html alt=CPU發展簡史：晶圓為什麼是圓的？不是方的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e3287db062784341a61139da5db9701b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5d01dc93.html title=CPU發展簡史：晶圓為什麼是圓的？不是方的？>CPU發展簡史：晶圓為什麼是圓的？不是方的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ada95e57.html alt=施工工藝標準45條！結構、裝修、水電安裝都有了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8b11b30274f34b54879d887930a81605 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ada95e57.html title=施工工藝標準45條！結構、裝修、水電安裝都有了！>施工工藝標準45條！結構、裝修、水電安裝都有了！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f15c3fa3.html alt=CPU顯卡都選好了，電源該怎麼選，教你幾招通俗易懂小竅門 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8ebabee259c7481bb2a3d8e659fbf3a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f15c3fa3.html title=CPU顯卡都選好了，電源該怎麼選，教你幾招通俗易懂小竅門>CPU顯卡都選好了，電源該怎麼選，教你幾招通俗易懂小竅門</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4c7a094.html alt=AMD系列CPU和主板參數對照表20200524 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4e358b60ba0b47538a09117a67bfab03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4c7a094.html title=AMD系列CPU和主板參數對照表20200524>AMD系列CPU和主板參數對照表20200524</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b4568212.html alt="一百多套CPU基本參數及參考價 臺式機新裝先收藏" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/57687a2864914584b2e98ce18dc5f255 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b4568212.html title="一百多套CPU基本參數及參考價 臺式機新裝先收藏">一百多套CPU基本參數及參考價 臺式機新裝先收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34501a8d.html alt=好消息！湖北45人入選第五批國家級非遺代表性項目代表性傳承人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34501a8d.html title=好消息！湖北45人入選第五批國家級非遺代表性項目代表性傳承人>好消息！湖北45人入選第五批國家級非遺代表性項目代表性傳承人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/36fdd331.html alt=胃食管反流病，45個問題超全大彙總 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1524623474597a7c82308e0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/36fdd331.html title=胃食管反流病，45個問題超全大彙總>胃食管反流病，45個問題超全大彙總</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7512a355.html alt=“45度讓路法”有溫度也應看到“實度” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fd70131515544be788cd63ad46abd13a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7512a355.html title=“45度讓路法”有溫度也應看到“實度”>“45度讓路法”有溫度也應看到“實度”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a49d3221.html alt=約45歲精神障礙男子在安徽安慶被救助，口音為懷寧縣人，其他信息無從得知，盼您提供家屬線索 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/2ecc0002153e84d1904d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a49d3221.html title=約45歲精神障礙男子在安徽安慶被救助，口音為懷寧縣人，其他信息無從得知，盼您提供家屬線索>約45歲精神障礙男子在安徽安慶被救助，口音為懷寧縣人，其他信息無從得知，盼您提供家屬線索</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/470d0ef7.html alt=如何充分利用多核CPU，計算很大的List中所有整數的和 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5f031909ec724f89918149df43f7977c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/470d0ef7.html title=如何充分利用多核CPU，計算很大的List中所有整數的和>如何充分利用多核CPU，計算很大的List中所有整數的和</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/980eeb56.html alt=世嘉土星遊戲機翻新修復：雙CPU雙GPU，同期最強架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1e24e8ab164647f5b8714e504a700cd5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/980eeb56.html title=世嘉土星遊戲機翻新修復：雙CPU雙GPU，同期最強架構>世嘉土星遊戲機翻新修復：雙CPU雙GPU，同期最強架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94627f5f.html alt=單CPU測分11萬，雙CPU性能又提高多少呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3f9291661f6747189f726c87e2469670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94627f5f.html title=單CPU測分11萬，雙CPU性能又提高多少呢？>單CPU測分11萬，雙CPU性能又提高多少呢？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>