<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>ASP.NET Core中我們可以使用非常簡單的方式，來使用響應壓縮 | 极客快訊</title><meta property="og:title" content="ASP.NET Core中我們可以使用非常簡單的方式，來使用響應壓縮 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/7b9fcf79-6ed6-4933-8e57-61f4fa936d65"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/2c1045a1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/2c1045a1.html><meta property="article:published_time" content="2020-11-14T21:01:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:37+08:00"><meta name=Keywords content><meta name=description content="ASP.NET Core中我們可以使用非常簡單的方式，來使用響應壓縮"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/2c1045a1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>ASP.NET Core中我們可以使用非常簡單的方式，來使用響應壓縮</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="ASP.NET Core中我們可以使用非常簡單的方式，來使用響應壓縮" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/7b9fcf79-6ed6-4933-8e57-61f4fa936d65><p class=pgc-img-caption></p></div><p>介紹#</p><p>響應壓縮技術是目前Web開發領域中比較常用的技術，在帶寬資源受限的情況下，使用壓縮技術是提升帶寬負載的首選方案。我們熟悉的Web服務器，比如IIS、Tomcat、Nginx、Apache等都可以使用壓縮技術，常用的壓縮類型包括Brotli、Gzip、Deflate，它們對CSS、JavaScript、HTML、XML 和 JSON等類型的效果還是比較明顯的，但是也存在一定的限制對於圖片效果可能沒那麼好，因為圖片本身就是壓縮格式。其次，對於小於大約150-1000 字節的文件（具體取決於文件的內容和壓縮的效率，壓縮小文件的開銷可能會產生比未壓縮文件更大的壓縮文件。在ASP.NET Core中我們可以使用非常簡單的方式來使用響應壓縮。</p><h3 class=pgc-h-arrow-right>使用方式#</h3><p>在ASP.NET Core中使用響應壓縮的方式比較簡單。首先，在ConfigureServices中添加services.AddResponseCompression注入響應壓縮相關的設置，比如使用的壓縮類型、壓縮級別、壓縮目標類型等。其次，在Configure添加app.UseResponseCompression攔截請求判斷是否需要壓縮,大致使用方式如下</p><pre><code>Copypublic class Startup{    public void ConfigureServices(IServiceCollection services)    {        services.AddResponseCompression();    }    public void Configure(IApplicationBuilder app, IHostingEnvironment env)    {        app.UseResponseCompression();    }}</code></pre><p>如果需要自定義一些配置的話還可以手動設置壓縮相關</p><pre><code>Copypublic void ConfigureServices(IServiceCollection services){    services.AddResponseCompression(options =&gt;    {        //可以添加多種壓縮類型，程序會根據級別自動獲取最優方式        options.Providers.Add&lt;BrotliCompressionProvider&gt;();        options.Providers.Add&lt;GzipCompressionProvider&gt;();        //添加自定義壓縮策略        options.Providers.Add&lt;MyCompressionProvider&gt;();        //針對指定的MimeType來使用壓縮策略        options.MimeTypes =             ResponseCompressionDefaults.MimeTypes.Concat(                new[] { "application/json" });    });    //針對不同的壓縮類型，設置對應的壓縮級別    services.Configure&lt;GzipCompressionProviderOptions&gt;(options =&gt;     {        //使用最快的方式進行壓縮，單不一定是壓縮效果最好的方式        options.Level = CompressionLevel.Fastest;        //不進行壓縮操作        //options.Level = CompressionLevel.NoCompression;        //即使需要耗費很長的時間，也要使用壓縮效果最好的方式        //options.Level = CompressionLevel.Optimal;    });}</code></pre><p>關於響應壓縮大致的工作方式就是，當發起Http請求的時候在Request Header中添加Accept-Encoding:gzip或者其他你想要的壓縮類型，可以傳遞多個類型。服務端接收到請求獲取Accept-Encoding判斷是否支持該種類型的壓縮方式，如果支持則壓縮輸出內容相關並且設置Content-Encoding為當前使用的壓縮方式一起返回。客戶端得到響應之後獲取Content-Encoding判斷服務端是否採用了壓縮技術，並根據對應的值判斷使用了哪種壓縮類型，然後使用對應的解壓算法得到原始數據。</p><h3 class=pgc-h-arrow-right>源碼探究#</h3><p>通過上面的介紹，相信大家對ResponseCompression有了一定的瞭解，接下來我們通過查看源碼的方式瞭解一下它大致的工作原理。</p><h4 class=pgc-h-arrow-right>AddResponseCompression#</h4><p>首先我們來查看注入相關的代碼，具體代碼承載在ResponseCompressionServicesExtensions擴展類中[點擊查看源碼]</p><pre><code>Copypublic static class ResponseCompressionServicesExtensions{    public static IServiceCollection AddResponseCompression(this IServiceCollection services)    {        services.TryAddSingleton&lt;IResponseCompressionProvider, ResponseCompressionProvider&gt;();        return services;    }    public static IServiceCollection AddResponseCompression(this IServiceCollection services, Action&lt;ResponseCompressionOptions&gt; configureOptions)    {        services.Configure(configureOptions);        services.TryAddSingleton&lt;IResponseCompressionProvider, ResponseCompressionProvider&gt;();        return services;    }}</code></pre><p>主要就是注入ResponseCompressionProvider和ResponseCompressionOptions,首先我們來看關於ResponseCompressionOptions[點擊查看源碼]</p><pre><code>Copypublic class ResponseCompressionOptions{    // 設置需要壓縮的類型    public IEnumerable&lt;string&gt; MimeTypes { get; set; }    // 設置不需要壓縮的類型    public IEnumerable&lt;string&gt; ExcludedMimeTypes { get; set; }    // 是否開啟https支持    public bool EnableForHttps { get; set; } = false;    // 壓縮類型集合    public CompressionProviderCollection Providers { get; } = new CompressionProviderCollection();}</code></pre><p>關於這個類就不做過多介紹了，比較簡單。ResponseCompressionProvider是我們提供響應壓縮算法的核心類，具體如何自動選用壓縮算法都是由它提供的。這個類中的代碼比較多，我們就不逐個方法講解了，具體源碼可自行查閱[點擊查看源碼]，首先我們先看ResponseCompressionProvider的構造函數</p><pre><code>Copypublic ResponseCompressionProvider(IServiceProvider services, IOptions&lt;ResponseCompressionOptions&gt; options){    var responseCompressionOptions = options.Value;    _providers = responseCompressionOptions.Providers.ToArray();    //如果沒有設置壓縮類型默認採用Br和Gzip壓縮算法    if (_providers.Length == 0)    {        _providers = new ICompressionProvider[]        {            new CompressionProviderFactory(typeof(BrotliCompressionProvider)),            new CompressionProviderFactory(typeof(GzipCompressionProvider)),        };    }    //根據CompressionProviderFactory創建對應的壓縮算法Provider比如GzipCompressionProvider    for (var i = 0; i &lt; _providers.Length; i++)    {        var factory = _providers[i] as CompressionProviderFactory;        if (factory != null)        {            _providers[i] = factory.CreateInstance(services);        }    }    //設置默認的壓縮目標類型默認為text/plain、text/css、text/html、application/javascript、application/xml    //text/xml、application/json、text/json、application/was    var mimeTypes = responseCompressionOptions.MimeTypes;    if (mimeTypes == null || !mimeTypes.Any())    {        mimeTypes = ResponseCompressionDefaults.MimeTypes;    }   //將默認MimeType放入HashSet    _mimeTypes = new HashSet&lt;string&gt;(mimeTypes, StringComparer.OrdinalIgnoreCase);    _excludedMimeTypes = new HashSet&lt;string&gt;(        responseCompressionOptions.ExcludedMimeTypes ?? Enumerable.Empty&lt;string&gt;(),        StringComparer.OrdinalIgnoreCase    );    _enableForHttps = responseCompressionOptions.EnableForHttps;}</code></pre><p>其中BrotliCompressionProvider、GzipCompressionProvider是具體提供壓縮方法的地方，咱們就看比較常用的Gzip的Provider的大致實現[點擊查看源碼]</p><pre><code>Copypublic class GzipCompressionProvider : ICompressionProvider{    public GzipCompressionProvider(IOptions&lt;GzipCompressionProviderOptions&gt; options)    {        Options = options.Value;    }    private GzipCompressionProviderOptions Options { get; }    // 對應的Encoding名稱    public string EncodingName { get; } = "gzip";    public bool SupportsFlush =&gt; true;    // 核心代碼就是這句 將原始的輸出流轉換為壓縮的GZipStream    // 我們設置的Level壓縮級別將決定壓縮的性能和質量    public Stream CreateStream(Stream outputStream)        =&gt; new GZipStream(outputStream, Options.Level, leaveOpen: true);}</code></pre><p>關於ResponseCompressionProvider其他相關的方法咱們在講解UseResponseCompression中間件的時候在具體看用到的方法，因為這個類是響應壓縮的核心類，現在提前說了，到中間件使用的地方可能會忘記了。接下來我們就看UseResponseCompression的大致實現。</p><h4 class=pgc-h-arrow-right>UseResponseCompression#</h4><p>UseResponseCompression具體也就一個無參的擴展方法，也比較簡單，因為配置和工作都由注入的地方完成了，所以我們直接查看中間件裡的實現，找到中間件位置ResponseCompressionMiddleware[點擊查看源碼]</p><pre><code>Copypublic class ResponseCompressionMiddleware{    private readonly RequestDelegate _next;    private readonly IResponseCompressionProvider _provider;    public ResponseCompressionMiddleware(RequestDelegate next, IResponseCompressionProvider provider)    {        _next = next;        _provider = provider;    }    public async Task Invoke(HttpContext context)    {        //判斷是否包含Accept-Encoding頭信息，不包含直接大喊一聲"抬走下一個"        if (!_provider.CheckRequestAcceptsCompression(context))        {            await _next(context);            return;        }        //獲取原始輸出Body        var originalBodyFeature = context.Features.Get&lt;IHttpResponseBodyFeature&gt;();        var originalCompressionFeature = context.Features.Get&lt;IHttpsCompressionFeature&gt;();        //初始化響應壓縮Body        var compressionBody = new ResponseCompressionBody(context, _provider, originalBodyFeature);        //設置成壓縮Body        context.Features.Set&lt;IHttpResponseBodyFeature&gt;(compressionBody);        context.Features.Set&lt;IHttpsCompressionFeature&gt;(compressionBody);        try        {            await _next(context);            await compressionBody.FinishCompressionAsync();        }        finally        {            //恢復原始Body            context.Features.Set(originalBodyFeature);            context.Features.Set(originalCompressionFeature);        }    }}</code></pre><p>這個中間件非常的簡單，就是初始化了ResponseCompressionBody。看到這裡你也許會好奇，並沒有觸發調用壓縮相關的任何代碼，ResponseCompressionBody也只是調用了FinishCompressionAsync都是和釋放相關的，不要著急我們來看ResponseCompressionBody類的結構</p><pre><code>Copyinternal class ResponseCompressionBody : Stream, IHttpResponseBodyFeature, IHttpsCompressionFeature{}</code></pre><p>這個類實現了IHttpResponseBodyFeature，我們使用的Response.Body其實就是獲取的HttpResponseBodyFeature.Stream屬性。我們使用的Response.WriteAsync相關的方法，其實內部都是在調用PipeWriter進行寫操作，而PipeWriter就是來自HttpResponseBodyFeature.Writer屬性。可以大致概括為，輸出相關的操作其核心都是在操作IHttpResponseBodyFeature。有興趣的可以自行查閱HttpResponse相關的源碼可以瞭解相關信息。所以我們的ResponseCompressionBody其實是重寫了輸出操作相關方法。也就是說，只要你調用了Response相關的Write或Body相關的，其實本質都是在操作IHttpResponseBodyFeature，由於我們開啟了響應輸出相關的中間件，所以會調用IHttpResponseBodyFeature的實現類ResponseCompressionBody相關的方法完成輸出。和我們常規理解的還是有偏差的，一般情況下我們認為，其實只要針對輸出的Stream做操作就可以了，但是響應壓縮中間件竟然重寫了輸出相關的操作。 瞭解到這個之後，相信大家就沒有太多疑問了。由於ResponseCompressionBody重寫了輸出相關的操作，代碼相對也比較多，就不逐一粘貼出來了，我們只查看設計到響應壓縮核心相關的代碼，關於ResponseCompressionBody源碼相關的細節有興趣的可以自行查閱[點擊查看源碼]，輸出的本質其實都是在調用Write方法，我們就來查看一下Write方法相關的實現</p><pre><code>Copypublic override void Write(byte[] buffer, int offset, int count){    //這是核心方法有關於壓縮相關的輸出都在這    OnWrite();    //_compressionStream初始化在OnWrite方法裡    if (_compressionStream != null)    {        _compressionStream.Write(buffer, offset, count);        if (_autoFlush)        {            _compressionStream.Flush();        }    }    else    {        _innerStream.Write(buffer, offset, count);    }}</code></pre><p>通過上面的代碼我們看到OnWrite方法是核心操作，我們直接查看OnWrite方法實現</p><pre><code>Copyprivate void OnWrite(){    if (!_compressionChecked)    {        _compressionChecked = true;        //判斷是否滿足執行壓縮相關的邏輯        if (_provider.ShouldCompressResponse(_context))        {            //匹配Vary頭信息對應的值            var varyValues = _context.Response.Headers.GetCommaSeparatedValues(HeaderNames.Vary);            var varyByAcceptEncoding = false;            //判斷Vary的值是否為Accept-Encoding            for (var i = 0; i &lt; varyValues.Length; i++)            {                if (string.Equals(varyValues[i], HeaderNames.AcceptEncoding, StringComparison.OrdinalIgnoreCase))                {                    varyByAcceptEncoding = true;                    break;                }            }            if (!varyByAcceptEncoding)            {                _context.Response.Headers.Append(HeaderNames.Vary, HeaderNames.AcceptEncoding);            }            //獲取最佳的ICompressionProvider即最佳的壓縮方式            var compressionProvider = ResolveCompressionProvider();            if (compressionProvider != null)            {                //設置選定的壓縮算法，放入Content-Encoding頭的值裡                //客戶端可以通過Content-Encoding頭信息判斷服務端採用的哪種壓縮算法                _context.Response.Headers.Append(HeaderNames.ContentEncoding, compressionProvider.EncodingName);                //進行壓縮時，將 Content-MD5 刪除該標頭，因為正文內容已更改且哈希不再有效。                _context.Response.Headers.Remove(HeaderNames.ContentMD5);                 //進行壓縮時，將 Content-Length 刪除該標頭，因為在對響應進行壓縮時，正文內容會發生更改。                _context.Response.Headers.Remove(HeaderNames.ContentLength);                //返回壓縮相關輸出流                _compressionStream = compressionProvider.CreateStream(_innerStream);            }        }    }}private ICompressionProvider ResolveCompressionProvider(){    if (!_providerCreated)    {        _providerCreated = true;       //調用ResponseCompressionProvider的方法返回最合適的壓縮算法        _compressionProvider = _provider.GetCompressionProvider(_context);    }    return _compressionProvider;}</code></pre><p>從上面的邏輯我們可以看到，在執行壓縮相關邏輯之前需要判斷是否滿足執行壓縮相關的方法ShouldCompressResponse，這個方法是ResponseCompressionProvider裡的方法，這裡就不再粘貼代碼了，本來就是判斷邏輯我直接整理出來大致就是一下幾種情況</p><ul><li>如果請求是Https的情況下，是否設置了允許Https情況下壓縮的設置，即ResponseCompressionOptions的EnableForHttps屬性設置</li><li>Response.Head裡不能包含Content-Range頭信息</li><li>Response.Head裡之前不能包含Content-Encoding頭信息</li><li>Response.Head裡之前必須要包含Content-Type頭信息</li><li>返回的MimeType裡不能包含配置的不需要壓縮的類型，即ResponseCompressionOptions的ExcludedMimeTypes</li><li>返回的MimeType裡需要包含配置的需要壓縮的類型，即ResponseCompressionOptions的MimeTypes</li><li>如果不滿足上面的兩種情況，返回的MimeType裡包含*/*也可以執行響應壓縮<br>接下來我們查看ResponseCompressionProvider的GetCompressionProvider方法看它是如何確定返回哪一種壓縮類型的</li></ul><pre><code>Copypublic virtual ICompressionProvider GetCompressionProvider(HttpContext context){    var accept = context.Request.Headers[HeaderNames.AcceptEncoding];    //判斷請求頭是否包含Accept-Encoding信心    if (StringValues.IsNullOrEmpty(accept))    {        Debug.Assert(false, "Duplicate check failed.");        return null;    }    //獲取Accept-Encoding裡的值，判斷是否包含gzip、br、identity等，並返回匹配信息    if (!StringWithQualityHeaderValue.TryParseList(accept, out var encodings) || !encodings.Any())    {        return null;    }    //根據請求信息和設置信息計算匹配優先級    var candidates = new HashSet&lt;ProviderCandidate&gt;();    foreach (var encoding in encodings)    {        var encodingName = encoding.Value;        //Quality涉及到一個非常複雜的算法，有興趣的可以自行查閱        var quality = encoding.Quality.GetValueOrDefault(1);        //quality需大於0        if (quality &lt; double.Epsilon)        {            continue;        }        //匹配請求頭裡encodingName和設置的providers壓縮算法裡EncodingName一致的算法        //從這裡可以看出匹配的優先級和註冊providers裡的順序也有關係        for (int i = 0; i &lt; _providers.Length; i++)        {            var provider = _providers[i];            if (StringSegment.Equals(provider.EncodingName, encodingName, StringComparison.OrdinalIgnoreCase))            {                candidates.Add(new ProviderCandidate(provider.EncodingName, quality, i, provider));            }        }        //如果請求頭裡EncodingName是*的情況則在所有註冊的providers裡進行匹配        if (StringSegment.Equals("*", encodingName, StringComparison.Ordinal))        {            for (int i = 0; i &lt; _providers.Length; i++)            {                var provider = _providers[i];                candidates.Add(new ProviderCandidate(provider.EncodingName, quality, i, provider));            }            break;        }        //如果請求頭裡EncodingName是identity的情況，則不對響應進行編碼        if (StringSegment.Equals("identity", encodingName, StringComparison.OrdinalIgnoreCase))        {            candidates.Add(new ProviderCandidate(encodingName.Value, quality, priority: int.MaxValue, provider: null));        }    }    ICompressionProvider selectedProvider = null;    //如果匹配的只有一個則直接返回    if (candidates.Count &lt;= 1)    {        selectedProvider = candidates.FirstOrDefault().Provider;    }    else    {        //如果匹配到多個則按照Quality倒序和Priority正序的負責匹配第一個        selectedProvider = candidates            .OrderByDescending(x =&gt; x.Quality)            .ThenBy(x =&gt; x.Priority)            .First().Provider;    }    //如果沒有匹配到selectedProvider或是identity的情況直接返回null    if (selectedProvider == null)    {        return null;    }    return selectedProvider;}</code></pre><p>通過以上的介紹我們可以大致瞭解到響應壓縮的大致工作方式，簡單總結一下</p><ul><li>首先設置壓縮相關的算法類型或是壓縮目標的MimeType</li><li>其次我們可以設置壓縮級別，這將決定壓縮的質量和壓縮性能</li><li>通過響應壓縮中間件，我們可以獲取到一個優先級最高的壓縮算法進行壓縮，這種情況主要是針對多種壓縮類型的情況。這個壓縮算法與內部機制和註冊壓縮算法的順序都有一定的關係，最終會選擇權重最大的返回。</li><li>響應壓縮中間件的核心工作類ResponseCompressionBody通過實現IHttpResponseBodyFeature，重寫輸出相關的方法實現對響應的壓縮，不需要我們手動進行調用相關方法，而是替換掉默認的輸出方式。只要設置了響應壓縮，並且請求滿足響應壓縮，那麼有調用輸出的地方默認都是執行ResponseCompressionBody裡壓縮相關的方法，而不是攔截具體的輸出進行統一處理。至於為什麼這麼做，目前我還沒有理解到設計者真正的考慮。</li></ul><h3 class=pgc-h-arrow-right>總結#</h3><p>在查看相關代碼之前，本來以為關於響應壓縮相關的邏輯會非常的簡單，看過了源碼才知道是自己想的太簡單了。其中和自己想法出入最大的莫過於在ResponseCompressionMiddleware中間件裡，本以為是通過統一攔截輸出流來進行壓縮操作，沒想到是對整體輸出操作進行重寫。因為在之前我們使用Asp.Net相關框架的時候是統一寫Filter或者HttpModule進行處理的，所以存在思維定式。可能是Asp.Net Core設計者有更深層次的理解，可能是我理解的還不夠徹底，不能夠體會這樣做的好處究竟是什麼，如果你有更好的理解或者答案歡迎在評論區裡留言解惑。</p><p><strong>最後，咱給小編：</strong></p><p><strong></strong></p><p><strong>1. 點贊+評論</strong></p><p><strong>2. 點頭像關注，轉發給有需要的朋友。</strong></p><p><strong></strong></p><p><strong>謝謝！！</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>ASP</a></li><li><a>NET</a></li><li><a>Core</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf86ceae.html alt="如何在ASP.NET Core中實現面向切面編程(AOP)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/287c0bf906ec4fd88f87bd726019bf06 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf86ceae.html title="如何在ASP.NET Core中實現面向切面編程(AOP)">如何在ASP.NET Core中實現面向切面編程(AOP)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/23b34058.html alt="為ASP.NET Core開發中間件壓縮功能提高系統性能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0e59ba59d6244b84844608d188600738 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/23b34058.html title="為ASP.NET Core開發中間件壓縮功能提高系統性能">為ASP.NET Core開發中間件壓縮功能提高系統性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eafc565.html alt="ASP.NET Core如何使用壓縮中間件提高Web應用程序性能" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2f7e2ee9a1f141b48f2b020e9b49f33a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eafc565.html title="ASP.NET Core如何使用壓縮中間件提高Web應用程序性能">ASP.NET Core如何使用壓縮中間件提高Web應用程序性能</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/04c5f14.html alt="ASP.NET MVC知識盤點：視圖" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ec8b2b454a04366857c2881b3625e4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/04c5f14.html title="ASP.NET MVC知識盤點：視圖">ASP.NET MVC知識盤點：視圖</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fae72201.html alt=".Net Core 3.0 IdentityServer4 快速入門" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f15647f0f33b4702bceef5e2365bb375 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fae72201.html title=".Net Core 3.0 IdentityServer4 快速入門">.Net Core 3.0 IdentityServer4 快速入門</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4baa49fe.html alt="Rasa 入門教程 Core 系列（五）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4a7ff1c942e5461c96528277a1df87d8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4baa49fe.html title="Rasa 入門教程 Core 系列（五）">Rasa 入門教程 Core 系列（五）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f486ab3.html alt="Aspose.Words for .NET使用教程：在Word文檔中使用圖表軸" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/59eb118c690e42838c37ab5babd9c2e4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f486ab3.html title="Aspose.Words for .NET使用教程：在Word文檔中使用圖表軸">Aspose.Words for .NET使用教程：在Word文檔中使用圖表軸</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c24159.html alt="NET core webApi 使用JWT驗證簽名" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/618ba7dd0033415c9d7bda3cf8a0c789 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c24159.html title="NET core webApi 使用JWT驗證簽名">NET core webApi 使用JWT驗證簽名</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a500cdb.html alt=超酷炫.NET數據可視化組件LightningChart-專業圖形視圖應用集錦 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/47320001fe7d32c8932b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a500cdb.html title=超酷炫.NET數據可視化組件LightningChart-專業圖形視圖應用集錦>超酷炫.NET數據可視化組件LightningChart-專業圖形視圖應用集錦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/386528a.html alt="Windows Core OS 最新消息：移植 Win 10 操作中心" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13870807645047099012dc90388a9b5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/386528a.html title="Windows Core OS 最新消息：移植 Win 10 操作中心">Windows Core OS 最新消息：移植 Win 10 操作中心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5ad84a1.html alt="Windows Core OS再遭曝光：可輕鬆移植到Xbox" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/Rp7wxoc3BTb50D style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5ad84a1.html title="Windows Core OS再遭曝光：可輕鬆移植到Xbox">Windows Core OS再遭曝光：可輕鬆移植到Xbox</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>