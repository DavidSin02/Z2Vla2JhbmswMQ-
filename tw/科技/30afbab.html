<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>JAVA進階 深入理解面向對象 | 极客快訊</title><meta property="og:title" content="JAVA進階 深入理解面向對象 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/83f04804597d4a2f8d6c18f54334b5ca"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/30afbab.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/30afbab.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/30afbab.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/30afbab.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/30afbab.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/30afbab.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/30afbab.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/30afbab.html><meta property="article:published_time" content="2020-10-29T21:00:55+08:00"><meta property="article:modified_time" content="2020-10-29T21:00:55+08:00"><meta name=Keywords content><meta name=description content="JAVA進階 深入理解面向對象"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/30afbab.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>JAVA進階 深入理解面向對象</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/83f04804597d4a2f8d6c18f54334b5ca><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>一、結構化程序設計與面向對象</h1><h1 class=pgc-h-arrow-right>1. 概述</h1><p>早期的編程語言如：C、Basic、Pascal等都是結構化編程語言。結構化程序設計的核心思想就是程序的開發採用自上而下的設計（稱為瀑布模式）。對於大型的應用來說，採用函數和庫的方式來對代碼進行管理。<br>而C++、Java、C#、Ruby等都是面向對象的編程語言，將現實世界採用類、對象的概念進行建模。<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8f9f6fc96fdc496095ccf641d2a130bb><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>2. 結構化程序設計簡介</h1><p style=text-align:start>結構化程序設計方法主張按功能來分析系統需求，其主要原則可概括為自頂向下、逐步求精、模塊化等。</p><p style=text-align:start>結構化程序設計首先採用結構化分析（Structured Analysis，SA）方法對系統進行需求分析，然後使用結構化設計（Structured Design，SD）方法對系統進行概要設計、詳細設計、最後採用結構化編程（Structured Program，SP）方法來實現系統。使用這種 SA、SD、SP的方式可以較好的保證軟件系統的開發進度和質量。</p><p style=text-align:start><strong>結構化程序使用三種基本控制結構構造程序，即：</strong></p><ul><li>順序</li><li>選擇</li><li>循環三種基本控制結構構造。</li></ul><p style=text-align:start>結構化程序設計主要強調的是程序的易讀性。</p><p style=text-align:start><strong>詳細描述處理過程常用三種工具：圖形、表格和語言。</strong></p><ul><li>圖形：程序流程圖、N-S圖、PAD圖</li><li>表格：判定表</li><li>語言：過程設計語言（PDL）</li></ul><p style=text-align:start>結構化程序設計曾被稱為軟件發展中的第三個里程碑，要點是：</p><ul><li>主張使用順序、選擇、循環三種基本結構來嵌套連結成複雜層次的結構化程序，嚴格控制GOTO語句的使用<br></li><li>自頂而下、逐步求精</li><li>獨立功能、單出口、單入口，減少模塊的相互聯繫使模塊可作為插件或積木使用，降低程序的複雜性，提高可靠性。</li></ul><h1 class=pgc-h-arrow-right>2. 面向對象程序設計</h1><p>基本思想是使用類、對象、繼承、封裝、消息等基本概念來進行程序設計。最小的程序單元是類，這些類可以生成系統中的多個對象，而這些對象則直接映像成客觀世界的各種事務。採用面向對象方式開發的軟件系統邏輯上的組成結構如：<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cb359936b0d7474795a31a59387d99fe><p class=pgc-img-caption></p></div><p style=text-align:start>面向對象的軟件系統由多個類組成。類還會提供操作這些狀態數據的方法，為這些行為提供相應的實現。</p><h1 class=pgc-h-arrow-right>二、類的定義與修飾符</h1><h1 class=pgc-h-arrow-right>1. 定義類</h1><pre><code>[修飾符] class 類名{    零到多個構造器定義..    零到多個Field…    零到多個方法…}</code></pre><p style=text-align:start>一個實際的例子：</p><pre><code>public class Person{    public String name;    public int age;    public void say(String content){       System.out.println(content);    }}Person p;     //p變量，放在棧內存裡p=new Person();   //Person對象放在堆內存裡</code></pre><p style=text-align:start>類也是一種引用數據類型，因此程序中定義的Person類型的變量實際上是一個引用，它被存放在棧內存裡，指向實際的Person對象，而真正的Person對象則存放在堆(heap)內存中。<br>Java程序不允許直接訪問堆內存中的對象，只能通過該對象的引用操作該對象。不管是數組還是對象，都只能通過引用來訪問它們。</p><p style=text-align:start>堆內存裡的對象可以有多個引用，即多個引用變量指向同一個對象。如接上面的程序：</p><pre><code>Person p2=p;</code></pre><p style=text-align:start>如果堆內存裡的對象沒有任何變量指向該對象，那程序將無法再訪問該對象，這個對象就變成了垃圾，Java的垃圾回收機制將回收該對象，釋放該對象所佔的內存區。<br>因此，如果希望通知垃圾回收機制回收某個對象，只需切斷該對象的所有引用變量和它之間的關係即可，也就是把這些引用變量賦值為null。</p><h1 class=pgc-h-arrow-right>2. 修飾符</h1><ul><li>public 公共類與公共屬性、方法</li><li>protected 保護類與保護屬性、方法</li><li>private 私有類與私有屬性、方法</li><li>static 靜態類與靜態屬性、方法</li><li>final 表示修飾的類、方法、變量不可改</li><li>abstract 虛類<br>abstract和final最多隻能出現其中之一，可以與static組合起來修飾方法</li></ul><h1 class=pgc-h-arrow-right>3. final修飾符</h1><p style=text-align:start>final類似C#裡的sealed關鍵字，用於表示它修飾的類、方法和變量不可改變</p><h1 class=pgc-h-arrow-right>2.3.1 final 成員變量</h1><p style=text-align:start>final修飾的成員變量必須由程序員顯示地指定初始值<br>類 Field：在靜態初始化塊中或聲明該Field時指定初始值<br>實例Field：必須在非靜態初始化塊、聲明Field或構造函數中指定初始值</p><h1 class=pgc-h-arrow-right>2.3.2 final 局部變量</h1><h1 class=pgc-h-arrow-right>2.3.3 final 修飾基本類型變量和引用類型變量的區別</h1><p style=text-align:start>final修飾基本類型變量，變量的值不能改變<br>但修飾引用類型變量，只保證這個引用類型變量所引用的地址不會改變，即一直引用同一個對象，但這個對象可以發生改變。</p><h1 class=pgc-h-arrow-right>2.3.4 可執行“宏替換”的final變量</h1><p style=text-align:start>對一個final變量來說，不管它是類Field、實例Field，還是局部變量，只要該變量滿足3個條件，這個final變量就不再是一個變量，而是相當於一個直接量</p><ul><li>使用final修飾符修飾</li><li>在定義該final變量時指定了初始值</li><li>該初始值可以在編譯時就被確定下來<br>示例：</li></ul><pre><code>public class test{  public static void main(String[] args)  {     final int a=5;     System.out.println(a);  }}</code></pre><p style=text-align:start>上面所示變量a其實不存在，在編譯時就轉換成System.out.println(5);</p><p style=text-align:start>Java使用常量池來管理用過的字符串直接量，如String a=“java”;<br>如果再定義<br>String b=“java”;<br>這時a==b 是true。</p><h1 class=pgc-h-arrow-right>2.3.5 final方法</h1><p style=text-align:start>final修飾的方法不可被重寫。如果不希望子類重寫父類的某個方法，就可以使用final修飾該方法 。<br>Object類的getClass()就是一個final方法。</p><h1 class=pgc-h-arrow-right>2.3.6 final 類</h1><p style=text-align:start>final修飾的類不可以有子類。如：java.lang.Math</p><h1 class=pgc-h-arrow-right>2.3.7 不可變類(immutable)</h1><p style=text-align:start>創建實例後，該實例的Field是不可改變的。Java的8個包裝類和java.lang.String都是不可在。</p><ul><li>使用private final修飾Field</li><li>提供帶參數構造器，用於根據傳入參數來初始化類的Field</li><li>僅為該類的Field提供getter方法，不要為該類的Field提供setter方法</li><li>如果有必要，重寫Object類的hashCode和equals方法。</li></ul><h1 class=pgc-h-arrow-right>2.3.8 緩存實例的不可變類</h1><p style=text-align:start>Java的Integer類，使用了緩存策略。在使用new構造對象時，返回全新的integer對象。<br>如果使用valueOf()創建Integer對象，則在創建該對象的同時，會緩存該方法創建的對象<br>Integer只緩存-128到127之間的Integer對象，超過範圍的對象不會緩存。</p><p style=text-align:start>如果程序經常使用某個不可變類的實例，則可以把該實例保存進緩存，減少系統開銷。</p><h1 class=pgc-h-arrow-right>三、深入理解java的面向對象</h1><h1 class=pgc-h-arrow-right>1. 一切皆對象，包裝類</h1><p style=text-align:start>在Java語言中，除了8個基本數據類型值，一切都是對象。對於8個基本的數據類型，Java也提供了包裝類：</p><p>基本數據類型包裝類byteByteshortShortintIntegerlongLongcharCharacterfloatFloatdoubleDoublebooleanBoolean</p><p style=text-align:start>對象是Java程序的核心，所以Java裡的對象具有唯一性，每個對象都有一個標識來引用它，如果某個對象失去了標識，這個對象將變成垃圾。Java語言不允許直接訪問對象，而是通過對對象的引用來操作對象。</p><p style=text-align:start>使用示例：</p><pre><code>Float f1=new Float("4.56");Booean blObj = new Boolean(b1);</code></pre><ul><li>當包裝類創建失敗時，會引發</li></ul><pre><code>java.lang.NumberFormatException異常。</code></pre><ul><li>獲得包裝類的基本類型變量</li></ul><pre><code>int i = integerObject.intValue();</code></pre><h1 class=pgc-h-arrow-right>2. 類成員</h1><p style=text-align:start>Java類包含5種成員：</p><ul><li>Field</li><li>方法</li><li>構造器</li><li>初始化塊</li><li>內部類（包括接口、枚舉）</li></ul><p style=text-align:start>類Field（static修飾）屬於整個類，當系統第一次準備使用該類時，系統會為該類Field分配內存空間。類Field開始生效，直到該類被卸載，所佔內存才會被垃圾回收機制回收。類Field生存範圍幾乎等同於該類的生存範圍。當類的初始化完成後，類Field也被初始化完成。</p><p style=text-align:start>類Field既可通過類訪問，也可通過類的對象來訪問。通過類的對象來訪問類Field時，實際上訪問的不是該類所擁有的Field。而C#其實不允許通過對象訪問類Field。</p><h1 class=pgc-h-arrow-right>3. 類的結構關係</h1><ul><li>繼承</li><li>整體->部分結構關係，也稱為組裝結構，這是典型的組合關係。Java語言通過在一個類裡保存另一個<br>Java語言是純粹的面向對象的程序設計語言，這主要表現為Java完全支持面向對象的三種基本特徵：繼承、封裝、多態。Java語言完全以對象為中心，Java程序的最小程序單位是類，整個Java程序由一個一個的類組成。<br>Java完全支持使用對象、類、繼承、封裝、消息等基本概念來進行程序設計，允許從現實世界中客觀存在的事物（即對象）出發來構造軟件系統，在系統構造中儘可能運行人類的自然思維方式。面向對象的方式實際上由：</li><li>OOA（面向對象分析）</li><li>OOD（面向對象設計）</li><li>OOP（面向對象編程）</li></ul><p style=text-align:start>三個部分有機組成，其中OOA和OOD的結構需要使用一種方式來描述並記錄，目前業界統一採用UML（統一建模語言）來描述並記錄OOA和OOD的結果。</p><p style=text-align:start>UML的2.0 一共包括13種類型的圖形。使用這13種圖形中的某些就可以很好地描述並記錄軟件分析、設計的摘要。通常而言，我們沒有必要為軟件系統繪製13種UML圖形，常用的UML圖形有用例圖、類圖、組件圖、部署圖、順序圖、活動圖和狀態圖。</p><h1 class=pgc-h-arrow-right>4. 面向對象的基本特徵</h1><h1 class=pgc-h-arrow-right>3.4.1 封裝（Encapsulation）</h1><p style=text-align:start><em>將對象的實現細節隱藏起來，然後通過一些公用方法來暴露該對象的功能</em></p><h1 class=pgc-h-arrow-right>3.4.2 繼承（Inheritance）</h1><p style=text-align:start><em>面向對象實現軟件複用的重要手段，當子類繼承父類後，子類作為一種特殊的父類，將直接獲得父類的屬性和方法</em></p><h1 class=pgc-h-arrow-right>3.4.3 多態（Polymorphism）</h1><p style=text-align:start><em>子類對象可以直接賦給父類變量，但運行時依然表現出子類的行為特徵，這意味著同一個類型的對象在執行同一個方法時，可能表現出多種行為特徵</em></p><h1 class=pgc-h-arrow-right>3.4.4 抽象</h1><p style=text-align:start><em>忽略一個主題中與當前目標無關的那些方法，以便更充分地注意與當前目標有關的方面。抽象並不打算了解全部問題，而只是考慮部分問題。例如，考慮考察Person對象時，我們不可能在程序中把Person的所有細節都定義出來，通常只能定義Person的部分數據、部分行為特徵—而這些數據、行為特徵是軟件系統所關心的部分</em></p><h1 class=pgc-h-arrow-right>3.4.5 其它功能</h1><ul><li>對象是面向對象方法中最基本的概念，它的基本特點有：標識唯一性、分類性、多態性、封裝性、模塊獨立性好</li><li>類是具有相同屬性、共同方法的一類事務。類的封裝性將各種信息細節隱藏起來，並通過公用方法來暴露該類對外所提供的功能，從而提高了類的內聚性，降低了對象之間的耦合性。</li><li>對象間的這種相互合作機制協助進行，這樣的機制稱為“消息”，消息是一個實例與另一個實例之間相互通信的機制。</li><li>在面向對象方法中，類之間共享屬性的機制稱為繼承。繼承具有傳遞性。繼承分為單繼承（一個繼承只允許有一個直接父類，即類等級為樹形結構）與多繼承（一個類允許有多個直接父類）。Java不支持多繼承。</li></ul><h1 class=pgc-h-arrow-right>5. 抽象類</h1><h1 class=pgc-h-arrow-right>3.5.1 抽象類的特性</h1><ul><li>使用abstract修飾，抽象方法不能有方法體。</li><li>抽象類不能被實例化，無法使用new創建實例，只能當作父類被繼承</li><li>抽象類可以有Field、方法、構造函數、初始化塊、內部類、枚舉類</li><li>含有抽象方法的類只能被定義成抽象類</li><li>abstract不能用來修飾局部變量、構造函數</li><li>static 和 abstract不能共同修飾同一個方法</li></ul><h1 class=pgc-h-arrow-right>3.5.2 接口</h1><p style=text-align:start>抽象類是從多個類中抽象出來的模板，如果將這種抽象進行是更徹底，則可以提煉出一種更加特殊的抽象類——接口。接口層不能包含應運，接口裡所有方法都是抽象方法。</p><ol start=1><li>JAVA接口是一些方法特徵的集合，接口中只有方法的特徵沒有方法的實現，因此這些方法可以在不同的地方被實現並且具有完全不同的行為。當然，JAVA還允許在接口中定義常量。</li><li>JAVA接口中的方法只能是abstract和public，接口中不能有構造器，可以有public、static和final屬性。</li><li>接口將方法的特徵和方法的實現分割開來，這種分割體現在接口常常代表一種角色，它封裝與該角色相關的操作和屬性，而實現這個接口的類就是扮演這個角色的演員。</li><li>一個接口可以被多個類實現，一個類可以實現多個接口。</li></ol><h1 class=pgc-h-arrow-right>3.5.3 接口的定義</h1><pre><code>[修飾會] interface 接口中 extends 父接口1,父接口2...{    常量定義;    抽象方法定義;}</code></pre><p style=text-align:start>示例：</p><pre><code>package lee;public interface Output{   int MAC_CACHE_LINE=50;   void out();   void getData(String msg);}</code></pre><h1 class=pgc-h-arrow-right>3.5.4 接口的繼承</h1><p style=text-align:start>接口完全支持多繼承，一個接口可以有多個直接父接口。多個父接口排在extends後，用,隔開。</p><h1 class=pgc-h-arrow-right>3.5.5 使用接口</h1><p style=text-align:start>接口不能用於創建實例，但接口中以用於聲明引用類型爆裂。當使用接口為聲明引用類型變量地，這個引用類型盤龍乃至其實現類的對象。除此之外，接口的主要用途不是被實現類實現。</p><p style=text-align:start>示例：</p><pre><code>interface Product{	int getProduceTime();}public class Printer implements Out , Product{	private String[] printDate=new String[MAX_CACHE_LINE];	private int dataNum=0;	public void out(){		while(dataNum&gt;0){			System.out.println("打印機打印"+printDate());			System.arraycopy(printDate,1,printDate,0,--dataNum);		}	}	public void getData(String msg){		if(dataNum &gt;= MAX_CACHE_LINE){			System.out.println("輸出隊列已滿，添加失敗");		}else		{			printData[dataNum++]=msg;		}	}	public int getProducteTime(){		return 45;	}	public static void main(String[] args){		Output o = new Printer();		o.getData("輕量級Java EE企業應用實戰");		o.getData("瘋狂Java 講義");		o.out();		o.getData("瘋狂Android講義");		o.getData("瘋狂Ajax講義");		o.out();		Product p = new Printer();		System.out.println(p.getProduceTime());		//所有接口類型的引用變量都可直接賦給Object類型的變量		Object obj=p;	}}</code></pre><h1 class=pgc-h-arrow-right>3.5.6 接口和抽象類比較</h1><h1 class=pgc-h-arrow-right>相同點</h1><ul><li>接口和抽象類都不能被實例化</li><li>接口 抽象類都可以包含抽象方法，繼承接口或繼承抽象類的普通子類都必須實現這些抽象方法</li></ul><h1 class=pgc-h-arrow-right>差別</h1><ul><li>接口體現的是一種規範。對接口實現者而言，接口規定了實現者必須對外提供哪些服務（以方法的形式為提供）；對於接口調用者而言，接口規定了調用者可以調用哪些服務，以及如何去調用這些服務。…</li></ul><h1 class=pgc-h-arrow-right>3.5.7 面向接口編程</h1><p style=text-align:start>可以實現簡單工廠模式、命令模式等。</p><h1 class=pgc-h-arrow-right>6. 內部類</h1><h1 class=pgc-h-arrow-right>3.6.1 非靜態內部類</h1><pre><code>public class OuterClass{}</code></pre><h1 class=pgc-h-arrow-right>3.6.2 靜態內部類</h1><pre><code>public class StaticInnerClassTest{	private int prop1=5;	private static int prop2=9;	static class StaticInnerClass{		private static int age;		public void accessOuterProp(){			System.out.println(prop1);			System.out.println(prop2);		}	}}</code></pre><h1 class=pgc-h-arrow-right>3.6.3 局部內部類</h1><p style=text-align:start>定義在代碼中間</p><pre><code>public class LocalInnerClass{	public static void main(String[] args){		class InnerBase{			int a;		}		class InnerSub extends InnerBase{			int b;		}		InnerSub is=new InnerSub();		is.a=5;		is.b=8;		System.out.println(is.a+","+is.b");	}}</code></pre><h1 class=pgc-h-arrow-right>3.6.4 匿名內部類</h1><pre><code>interface Product{	public double getPrice();	public String getName();}public class AnonymousTest{	public void test(Product p){		System.out.println("購買了一個"+p.getName() + ",花掉了"+p.getPrice());		public static void main(String[] args){			AnonymousTest ta = new AnonymousTest();			ta.test(new Product(){				public double getPrice(){					return 567.8;				}				public String getName(){					return "AGP";				}			})		}	}}</code></pre><h1 class=pgc-h-arrow-right>3.6.5 閉包和回調</h1><p style=text-align:start>閉包（Closure）是一種能被調用的對象，它保存創建它的作用域信息。Java7沒有顯式支持閉包，但可以把非靜態內部類當成面向對象領域的閉包。<br>通過這種仿閉包的非靜態內部類，就可以很方便地實現回調功能。</p><pre><code>interface Teachable{	void work();}public class Programmer{	private String name;	public Programmer(){}	public Programmer(String name){		this.name=name;	}	//...getter &amp; setter	public void work(){		System.out.println(name + "doing...");	}}public class TeachableProgrammer extends Programmer implements Teachable{	public void work(){		System.out.println(getName()+"doing ...");	}}</code></pre><h1 class=pgc-h-arrow-right>3.6.6 lambda實現匿名類</h1><p style=text-align:start>java8開始支持lambda表達式，可以看成一種閉包，允許把函數當成參數使用，是面向函數式編程的思想。<br>lambda表達式語法：</p><pre><code>  (paramters) -&gt; expression；</code></pre><p style=text-align:start>或</p><pre><code>(paramters) -&gt; {statements;}      展開如：    (Type1 param1, Type2 param2, Type2 param2, ...) -&gt; {        statement1;        statement2;        statement3;        ...        return statementX;    }</code></pre><p style=text-align:start>實例：</p><pre><code>//匿名內部類寫法        new Thread(new Runnable() {            @Override            public void run() {                System.out.println("內部類寫法");            }        }).start();</code></pre><p style=text-align:start>改用lambda：</p><pre><code>//lambda 寫法new Thread(() -&gt; System.out.println("lambda寫法")).start();    </code></pre><p style=text-align:start><strong>lambda表達式特徵</strong></p><ul><li>可選類型聲明：不需要聲明參數類型，編譯器可以統一識別參數值。</li><li>可選的參數圓括號：一個參數無需定義圓括號，但多個參數需要定義圓括號。</li><li>可選的大括號：如果主體包含了一個語句，就不需要使用大括號。</li><li>可選的返回關鍵字：如果主體只有一個表達式返回值則編譯器會自動返回值，大括號需要指定明表達式返回了一個數值。</li></ul><p style=text-align:start>幾個示例：</p><pre><code>//入參為空        TestDemo no_param = () -&gt; "hi, no param";        TestDemo no_param2 = () -&gt; { return "hi, no param"; };        System.out.println(no_param.hi());        //單個參數        TestDemo2 param = name -&gt; name;        TestDemo2 param2 = name -&gt; { return name;};        System.out.println(param.hei("hei, grils"));        //多個參數        TestDemo3 multiple = (String hello, String name) -&gt; hello + " " + name;        //一條返回語句，可以省略大括號和return        TestDemo3 multiple2 = (hello, name) -&gt; hello + name;        //多條處理語句，需要大括號和return        TestDemo3 multiple3 = (hello, name) -&gt; {            System.out.println("進入內部");            return hello + name;        };        System.out.println(multiple.greet("hello", "lambda"));</code></pre><h1 class=pgc-h-arrow-right>7. 枚舉類</h1><pre><code>public class Season{   private final String name;   private final String desc;   public static final Season SPRING=new Season("春天","");   public static final Season SUMMBER=new Season("夏天","");   public static final Season FALL=new Season("秋天","");   ...   public static Season getSeason(int seasonNum){   switch(seasonNum){      case 1:         return SPRING;      case 2:         return SUMMBER;      ...   }   }   private Season(String name,String desc){      this.name=name;      this.desc=desc;   }   public String getName(){      return this.name;   }   public String getDesc()   {      return this.desc();   }}</code></pre><p style=text-align:start>使用</p><pre><code>public class SeasonTest{   public SeasonTest(Season s)   {      System.out.println(s.getName());   }   public static void main(String[] args)   {      new SeasonTest(Season.FALL);   }}</code></pre><h1 class=pgc-h-arrow-right>3.7.1 使用enum 枚舉類</h1><h1 class=pgc-h-arrow-right>SeasonEnum.java</h1><pre><code>public enum SeasonEnum{   SPRING,SUMMBER,FALL,WINTER;｝</code></pre><h1 class=pgc-h-arrow-right>EnumTest.java</h1><pre><code>public class EnumTest{   public void judge(SeasonEnum s)   {       switch(s)       {             case SPRING:                System.out.println("描述");                break;             ...       }   }   public static void main(String[] args)      {      for(SeasonEnum s:SeasonEnum.values()){         System.out.println(s);      }      new EnumTest().judge(SeasonEnum.SPRING);   }}</code></pre><p style=text-align:start>java.lang.Enum類提供了以下方法：</p><ul><li>int compareTo(E o)</li><li>String name()</li><li>int ordinal()</li><li>String toString()</li><li>public static &lt;T extends Enum> T valueOf(Class enumType,String name)</li></ul><h1 class=pgc-h-arrow-right>3.7.2 枚舉類的Field,方法 和構造函數</h1><p style=text-align:start>枚舉類也可以定義Field、方法。<br>枚舉為的實例只能是枚舉值，不能隨意通過new創建枚舉類對象。</p><p style=text-align:start>在setName裡可以對賦值進行驗證。</p><h1 class=pgc-h-arrow-right>3.7.3 實現接口的枚舉類</h1><p style=text-align:start>枚舉類也可以實現一個或多個接口。與普通類實現一個或多個接口完全一樣，枚舉類實現一個或多個接口時，也需要實現該接口所包含的方法。</p><h1 class=pgc-h-arrow-right>8. 對象的this引用</h1><p style=text-align:start>this關鍵字總是指向調用該方法的對象。根據this出現位置的不同，this作為對象的默認引用有兩種情形：</p><ul><li>構造器中引用該構造器正在初始化的對象</li><li>在方法中引用調用該方法的對象<br>this關鍵字最大的作用就是讓類中一個方法，訪問該類裡的另一個方法或Field。但要注意的是，在static修飾的方法裡不能使用this引用，且靜態成員不能直接訪問非靜態成員。</li></ul><p style=text-align:start>有些時候this可以省略，編譯器會自動在引用內部方法時加上this.classname.方法名。<br>Java允許使用對象來調用static修飾的Field方法，但應避免這樣使用，現代的IDE一般會給出報警。</p><h1 class=pgc-h-arrow-right>9. 對象的方法</h1><h1 class=pgc-h-arrow-right>3.9.1 參數值的傳遞方式</h1><p style=text-align:start>Java的方法參數傳遞只有一種方式：值傳遞，這是因為Java沒有指針的概念。正如前面提到過的，Java的一個對象可以拆為兩部分：</p><ul><li>指向對象的變量名，存在棧中</li><li>對象真正內容，存在堆中</li></ul><p style=text-align:start>當把一個對象作為參數時，傳遞的值是對象的引用地址，即棧裡的變量複製了，但指向的堆仍然沒有變。<br>為了便於理解，往往可以認為Java傳遞複雜參數時（非8種基本類型）採用的是按引用傳值，但要注意面試時不能這樣講。</p><h1 class=pgc-h-arrow-right>3.9.2 形參個數可變的方法</h1><pre><code>public class Varargs{   public static void test(int a,String... books)   {       for(String tmp : books)       {          System.out.println(tmp);       }   }   public static void main(String[] args)   {        test(5,"參數2","參數3");   }}</code></pre><h1 class=pgc-h-arrow-right>11. 繼承</h1><h1 class=pgc-h-arrow-right>3.11.1 super限定</h1><p style=text-align:start>如果需要在子類方法中調用父類被覆蓋的實例方法，則可使用super限定來調用父類被覆蓋的實例方法：</p><pre><code>public void callOverrideMethod(){   super.fly();}</code></pre><h1 class=pgc-h-arrow-right>3.11.2 多態</h1><p style=text-align:start>Java引用變量有兩個類型：一個是編譯時類型，一個是運行時類型。如果編譯與運行時類型不一到處，就可能出現所謂的多態(Polymorphism)</p><h1 class=pgc-h-arrow-right>3.11.3 instanceof運算符</h1><p style=text-align:start>instanceof運算符的前一個操作數通常是一個引用類型變量，後一個操作數通常是一個類（也可以是接口，可以把接口理解成一種特殊的類），它用於判斷前面的對象是否是後面的實例，或者其子類，實現類的實例。</p><h1 class=pgc-h-arrow-right>3.11.4 繼承與組合</h1><p style=text-align:start>初始化塊<br>初始化塊是Java類裡可出現的第4種成員，一個類裡可以有多個初始化塊，相同類型的初始化塊之間有順序：前面定義的初始化塊先執行，後面定義的初始化後執行</p><pre><code>public class Person{    {        ; //先執行   }   {        ; //2   }   public Person()   {       ; //3   }   public static void main(String[] args)   {      new Person();   }}</code></pre><p style=text-align:start>初始化塊只在創建Java對象時隱匿執行，而且在構造函數之前執行。</p><h1 class=pgc-h-arrow-right>12. 靜態初始化塊</h1><p style=text-align:start>在類初始化階段執行靜態初始化塊，因此比普通初始化塊先執行。<br>靜態初始化塊會一直上溯到頂父類靜態初始化類先執行，最後才執行該類的靜態初始化塊。</p><p style=text-align:start>JDK1.5後新增引入靜態成員：</p><pre><code>import static java.lang.Math.*;</code></pre><p style=text-align:start>可以引入所有靜態Field和方法。</p><h1 class=pgc-h-arrow-right>13. 打印對象和toString方法</h1><pre><code>class Person{}Person p=new Person();//下面兩句效果是一樣的System.out.println(p);System.out.println(p.toString());</code></pre><ul><li>所有Java對象都有toString實例方法</li><li>Java對象都可以與字符串進行連接運算</li><li>Object類提供的toString方法總是返回該對象實現類的“類名+@+hashCode”</li><li>toString()可以重寫</li></ul><h1 class=pgc-h-arrow-right>14. == 和 equals</h1><p style=text-align:start>Java程序中測試兩個變量是否相等有兩種方式。</p><ul><li>==判斷兩個變量是否相等時，如果兩個變量是基本類型變量，且都是數值類型（不一定要求數據類型嚴格相同），則只要兩個變量的值相等，即返回true</li><li>對於兩個引用類型的變量，必須指向同一個對象時，==才返回true</li><li>==不可用於比較類型上沒有父子關係的兩個對象</li></ul><h1 class=pgc-h-arrow-right>15. “hello” 和 new String(“hello”)</h1><ul><li>“hello”，JVM將會使用常量池來管理這些字符串</li><li>當使用new String(“hello”)時，JVM會先使用常量池來管理"hello"直接量，再用String類的構造器來創建一個新的String對象，新創建的String對象被保存在堆內存中。new String(“hello”)一共產生兩個對象。</li></ul><p style=text-align:start>常量池（constant pool）專門用於管理在編譯期被確定並被保存在已編譯的.class文件中的一些數據。它包括了關於類、方法、接口中的常量，還包括字符串常量。</p><p style=text-align:start>JVM常量池保證相同的字符串（在編譯期間可運算的值）直接量只有一個，不會產生多個副本。</p><p style=text-align:start>使用new String()創建的字符串對象是運行時創建出來的，它被保存在運行時內存區內（堆內存），不會放入常量池中。</p><p style=text-align:start>要判斷兩個引用變量的值是否相等時，可以使用.equals判斷。equals()方法也可以重寫。</p><h1 class=pgc-h-arrow-right>16. 自動裝箱與自動拆箱(Autoboxing AutoUnboxing)</h1><p style=text-align:start>從JDK1.5之後，提供了自動裝箱(Autoboxing)和自動拆箱(AutoUnboxing)功能。即：</p><pre><code>Integer intObj=5;boolean b = (Boolean)boolObj;</code></pre><ul><li>包裝類的parseXxx(String)靜態方法提供了字符串值轉換為基本類型的值的方法；也可以使用包裝類的構造器實現</li><li>String 類提供了多個重載valueOf()方法，用於將基本類型變量轉換成字符串</li><li>包裝類的實例可與數值類型的值進行比較</li><li>而兩個包裝類的實例進行比較的情況比較複雜，只有兩個包裝類引用指向同一個對象時才會返回true</li><li>自動裝箱的特例</li></ul><pre><code>Integer a=2;Integer b=2;a==b  //trueInteger a=128;Integer b=128;a==b  //false</code></pre><p style=text-align:start>其原因是-128~127之間的整數自動裝箱成一個Integer實例時，會放入一個名為cache的數組中緩存起來。不在這個範圍內的，系統總是重新創建一個Integer實例。</p><ul><li>Java7 增強了包裝類的功能，為所有包裝類提供了一個靜態的compare(xxx var1,xxx val2)方法，以方便進行值比較</li></ul><h1 class=pgc-h-arrow-right>四、類的設計原則</h1><h1 class=pgc-h-arrow-right>一、類的設計原則</h1><h1 class=pgc-h-arrow-right>1.單一職責原則（SRP）</h1><p style=text-align:start><em>每個類只擔任一個職責，每個類應只有一個引起它變化的原因。</em><br>一個類只負責一項職責，應該僅有一個引起它變化的原則</p><h1 class=pgc-h-arrow-right>2.里氏替換原則（LSP）和依賴倒置原則（DIP）</h1><p style=text-align:start><em>子類可以擴展父類的功能，但不能改變父類原有的功能</em></p><ol start=1><li>子類可以實現父類的抽象方法，但不能覆蓋父類的非抽象方法。</li><li>子類中可以增加自己特有的方法。</li><li>當子類的方法重載父類的方法時，方法的前置條件（即方法的形參）要比父類方法的輸入參數更寬鬆。</li><li>當子類的方法實現父類的抽象方法時，方法的後置條件（即方法的返回值）要比父類更嚴格。</li></ol><h1 class=pgc-h-arrow-right>3.依賴倒置原則（DIP）</h1><p style=text-align:start><em>高層模塊不應該依賴低層模塊，二者都應該依賴其抽象；抽象不應該依賴細節；細節應該依賴抽象。即針對接口編程，不要針對實現編程</em><br>依賴倒置原則的中心思想是面向接口編程，傳遞依賴關係有三種方式，以上的說的是是接口傳遞，另外還有兩種傳遞方式：構造方法傳遞和setter方法傳遞。</p><ol start=1><li>低層模塊儘量都要有抽象類或接口，或者兩者都有。</li><li>變量的聲明類型儘量是抽象類或接口。</li><li>使用繼承時遵循里氏替換原則。</li></ol><h1 class=pgc-h-arrow-right>4.接口隔離原則（ISP）</h1><p style=text-align:start><em>建立單一接口，不要建立龐大臃腫的接口，儘量細化接口，接口中的方法儘量少。</em><br>也就是說，我們要為各個類建立專用的接口，而不要試圖去建立一個很龐大的接口供所有依賴它的類去調用。在程序設計中，依賴幾個專用的接口要比依賴一個綜合的接口更靈活。接口是設計時對外部設定的“契約”，通過分散定義多個接口，可以預防外來變更的擴散，提高系統的靈活性和可維護性。</p><h1 class=pgc-h-arrow-right>5.開閉原則（OCP）</h1><p style=text-align:start>開閉原則要求軟件有一個良好的基本結構，確保面對“變化”的時候，僅僅擴展而不是修改現有對象的組織框架就可以隨需而動。<br>抽象化是關鍵，定義抽象類或接口，使其可以有很多的具體實現預見所有的需要，在任何情況下都不再修改上層商業邏輯。</p><p style=text-align:start>抽象類的用法：</p><ol start=1><li>抽象類應當擁有儘可能多的共同代碼</li><li>在一個抽象類到多個具體類的繼承關係中，共同的代碼應當儘量移動到抽象類中，這樣可以提高代碼利用率。當需要修改這些共同的代碼時，設計師只需要修改一個地方。</li><li>抽象類應當擁有儘可能少的數據</li><li>與代碼移動方向相反，數據的移動方向是從抽象類到具體類，一個數據對象無論是否使用都會佔用資源，因此數據應當儘量放到具體類或等級結構的低端。</li></ol><h1 class=pgc-h-arrow-right>五、對象與垃圾回收</h1><p style=text-align:start>垃圾回收只負責回收堆內存中的對象，不會回收任何物理資源<br>程序無法精確控制垃圾回收的運行<br>垃圾回收前，會調用finalize()方法，該方法可能使該對象重新復活，從而導致垃圾回收機制取消回收</p><h1 class=pgc-h-arrow-right>1. 對象在內存中的狀態</h1><ul><li>可達狀態：一個對象被創建後，若有一個以上的引用變量引用它，就處理可達狀態</li><li>可恢復狀態：不再有變量引用，即進入了可恢復狀態</li><li>不可達狀態：已經調用finalize()後依然沒有使該對象變成可達狀態</li></ul><h1 class=pgc-h-arrow-right>2. 強制垃圾回收</h1><ul><li>調用System.gc()靜態方法</li><li>調用Runtime.getRuntime().gc()實例方法</li></ul><p style=text-align:start>測試：</p><pre><code>public class GcTest {	public static void main(String[] args){		for(int i=0;i&lt;4;i++){			new GcTest();		}	}	public void finalize()	{		System.out.println("系統正在清理資源");	}}</code></pre><p style=text-align:start>可以看到finalize()不會被調用。<br>而如果：</p><pre><code>public class GcTest {	public static void main(String[] args){		for(int i=0;i&lt;4;i++){			new GcTest();			Runtime.getRuntime().gc();		}	}	public void finalize()	{		System.out.println("系統正在清理資源");	}}</code></pre><p>則finalize()會被調用。<br>使用java -verbose:gc GcTest查看垃圾回收後的提示信息：<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/38738238f64a46d79ed2ce1f062ca7d5><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>但上面語句只是建議垃圾回收，系統仍有可能不立即進行垃圾回收。</p><h1 class=pgc-h-arrow-right>3. finalize方法</h1><ul><li>不要調動調用對象的finalize()方法</li><li>finalize()方法調用時間有不確定性，不要把它當成一定會被執行的方法</li><li>當JVM執行可恢復對象的finalize()方法時，可能使對象或系統中其它對象重新變成可達狀態</li><li>當JVM執行finalize()方法出現異常時，垃圾回收機制不會報告異常，程序繼續執行。</li></ul><p style=text-align:start>System和Runtime類提供了runFinalization方法，可以強制垃圾回收機制調用系統中可恢復對象的finalize()方法</p><h1 class=pgc-h-arrow-right>4. 對象的軟、弱、虛引用</h1><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right>六、使用JAR文件</h1><p style=text-align:start>常用命令：</p><h1 class=pgc-h-arrow-right>1. 創建JAR文件</h1><pre><code>jar cf test.jar test   //test是目錄</code></pre><h1 class=pgc-h-arrow-right>2. 創建JAR文件並顯示壓縮過程</h1><pre><code>jar cvf test.jar test</code></pre><h1 class=pgc-h-arrow-right>3. 不使用清單文件</h1><pre><code>jar cvfM test.jar test</code></pre><h1 class=pgc-h-arrow-right>4. 自定義清單文件內容</h1><pre><code>jar cvfm test.jar manifest.mf test</code></pre><h1 class=pgc-h-arrow-right>5. 查看jar包內容</h1><pre><code>jar tf test.jar</code></pre><h1 class=pgc-h-arrow-right>6. 查看JAR包詳細內容</h1><pre><code>jar tvf test.jar</code></pre><h1 class=pgc-h-arrow-right>7. 解壓縮</h1><pre><code>jar xf test.jar</code></pre><h1 class=pgc-h-arrow-right>8. 帶提示信息解壓縮</h1><pre><code>jar xvf test.jar</code></pre><h1 class=pgc-h-arrow-right>9. 更新JAR文件</h1><pre><code>jar uf test.jar Hello.class</code></pre><h1 class=pgc-h-arrow-right>10. 更新時顯示詳細信息</h1><pre><code>jar uvf test.jar Hello.class</code></pre><h1 class=pgc-h-arrow-right>11. 創建可執行的jar包</h1><p style=text-align:start>程序發佈的方式：</p><ul><li>使用平臺相關的編譯器，使用第三方編譯器</li><li>為應用編輯一個批處理，如windows</li></ul><pre><code>java package.MainClass</code></pre><p style=text-align:start>或</p><pre><code>start javaw package.MainClass</code></pre><ul><li>將一個應用程序製作成可執行的JAR包，通過JAR包來發布應用程序</li></ul><pre><code>jar cvfe test.jar Test *.class</code></pre><p style=text-align:start>該命令把目錄下的*.class壓縮到test.jar，並指定使用Test類為程序入口。<br>運行的方法：</p><pre><code>java -jar test.jarjavaw test.jar</code></pre><h1 class=pgc-h-arrow-right>七、UML（統一建模語言）介紹</h1><p>面向對象軟件開發需要經過OOA（面向對象分析）、OOD（面向對象設計）和OOP（面向對象編程）三個階段，OOA對目標系統進行分析，建立分析模型，並將之文檔化；OOD用面向對象的思想對OOA的結果進行細化，得出設計模型。OOA和OOD的分析、設計結果需要統一的符號來描述、交流並記錄，UML就是這種用於描述、記錄OOA和OOD結果的符號表示法。<br>面向對象的分析與設計方法在20世紀80年代末至90年代出現了一個高潮，UML是這個高潮的產物。在些期間出現了三種具有代表性的表示方法。Booch是面向對象方法最早的倡導者之一，他提出了面向對象軟件工程的概念。Booch1993表示法比較適合於系統的設計和構造。<br>Rumbaugh等人提出了面向對象的建模技術（OMT）方法，採用面向對象的概念，並引入了各種獨立於語言的表示符。這種方法用對象模型、動態模型、功能模型和用例模型共同完成對整個系統的建模，所定義的概念和符號可用於軟件開發的分析、設計和實現的全過程，軟件開發人員不必在開發過程的不同階段進行概念和符號的轉換。OMT-2特別適用於分析和描述以數據為中心的信息系統。<br>Jacobson於1994年提出了OOSE方法，其最大特點是面向用例（Use-Case），並在用例的描述中引入了外部角色的概念。用例的概念是精確描述需求的重要武器，但用例貫穿於整個開發過程，包括對系統的測試和驗證。OOSE比較適合支持商業工程和需求分析。<br>UML統一了Booch、Rumbaugh和Jacobson的表示方法，而且對其進行了進一步的發展，並最終統一為大眾所接受的標準建模語言。UML是一種定義良好、易於表達、功能強大且普遍適用的建模語言，它的作用域不限於支持面向對象的分析與設計，還支持從需求分析開始的軟件開發全過程。<br>UML的大致發展過程如圖所示：<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/75977f9b2ffa46f6a4d7444067f38e0e><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>UML2.0一共包括13種正式圖形：</p><ul><li>活動圖 activity diagram</li><li>類圖 class diagram</li><li>通信圖 communication diagram</li><li>組件圖 component diagram</li><li>複合結構圖 composite structure diagram</li><li>部署圖 deplyment diagram</li><li>交互概觀圖 interactive overview diagram</li><li>對象圖 object diagram</li><li>包圖 package diagram</li><li>順序圖 sequence diagram</li><li>狀態機圖 state machine diagram</li><li>定時圖 timing diagram</li><li>用例圖 use case diagram<br>很少有一個軟件系統在分析、設計階段對每個細節都使用13種圖形來表現。</li></ul><h1 class=pgc-h-arrow-right>1. 用例圖</h1><p style=text-align:start>用例圖用於描述系統提供的系列功能，而每個用例則代表系統的一個功能模塊。用例圖的主要目的是幫助開發團隊以一種可視化的方式理解系統的需求功能，用例圖對系統的實現不作任何說明，僅僅是系統功能的描述。<br>用例圖包括用例（以一個橢圓表示，用例的名稱放在橢圓的中心或橢圓下面）、角色（Actor，也就是與系統交互的其它實體，以一個人形符號表示）、角色和用例之間的關係（以簡單的線段來表示），以及系統內用例之間的關係。用例圖一般表示出用例的組織關係—要麼是整個系統的全部用例，要麼是完成具體的一組用例。下面是BBS系統的部分用例示意圖。</p><p style=text-align:start><br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6e4201da32f348979382d3d664b512fd><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>用例圖通常用於表達系統或者系統範疇的高級功能。<br>用例圖主要在需求分析階段使用，用於描述系統實現的功能，方便與客戶交流，保證系統需求的無二性，用實例圖表示系統外觀，不要指望用例圖和系統的各個類之間有任何聯繫。不要把用例做得過多，過多的用例將導致難以閱讀，難以理解；儘可能多地使用文字說明。</p><h1 class=pgc-h-arrow-right>2. 類圖</h1><p style=text-align:start>類圖是最古老、功能最豐富、使用最廣泛的UML圖。類圖表示系統中應該包含哪些實體，各實體之間如何關聯；換句話說，它顯示了系統的靜態結構，類圖可用於表示邏輯類，邏輯類通常就是業務人員所談及的事物種類。<br>類在類圖上使用包含三個部分的矩形來描述，最上面的部分顯示類的名稱，中間部分包含類的屬性，最下面的部分包含類的方法。<br>類之間有三種基本關係：</p><ul><li>關聯（包括聚合、組合）</li><li>泛化（與繼承同一個概念）</li><li>依賴</li></ul><h1 class=pgc-h-arrow-right>關聯</h1><p style=text-align:start>關聯具有一定的方向性，如果僅能從一個類單方向地訪問另一個類，則被稱為單向關聯；如果兩個類可以互相訪問對象，則稱為雙向關聯。一個對象能訪問關聯對象的數目被稱為多重性。關聯使用一條實線表示，帶箭頭的實線表示單向關聯。<br>關聯關係包括兩種特例：聚合和組合。它們都有部分和整體的關係，但通常認為組合比聚合更加嚴格。如：</p><ul><li>學生既可以是籃球俱樂部的成員，也可以是書法俱樂部的成員，稱為聚合。使用空心菱形框的實線表示</li><li>當某個實體組合成另一個實體時，該實體則不能同時是一個實體的部分，使用實心菱形框表示：</li></ul><p><br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/28d961cfa1924aa6ac0ae0f1f35a6d90><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>圖中描述Teacher與Student之間的關聯關係：</p><ul><li>它們是雙向關聯關係，而且使用了多重性來表示Teacher和Student之間存在1：N的關聯關係（1…*表示可以是一個到多個），即一個Teacher實體可以有1個或多個關聯的Student實體；Student和BasketBallClud存在聚合關係，即1個或多個Student實體可以聚合成一個BascketBallClud實體；而Arm和Student之間存在組合關係。2個Arm實體組合成一個Student實體。</li></ul><h1 class=pgc-h-arrow-right>泛化</h1><p>泛化與繼承是同一個概念，都是指子類是一種特殊的父類，類與類之間的繼承關係是非常普遍的，繼承關係使用帶空心三角形的實線表示。<br>從下圖可以看出，Student和Person類之間的繼承關係。<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cc57f1d819c8457d84c1632681f905b4><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>依賴</h1><p style=text-align:start>如果一個類的改動會導致另一個類的改動，則稱兩個類之間存在依賴。依賴關係使用帶箭頭的虛線表示，其中箭頭指向被依賴的實體。依賴的常見可能原因如下：</p><ul><li>改動的類將消息發給另一個類</li><li>改動的類以另一個類作為數據部分</li><li>改動的類以另一個類作為操作參數<br>通常而言，依賴是單向的，尤其是當數據表現和數據模型分開設計時，數據表現依賴於數據模型。例如：JDK基礎類庫中的JTable和DefaultTableModel。</li></ul><p><br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/21efe4968c7745fe901d843cdf30ebd6><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>3. 組件圖</h1><p style=text-align:start>對於現代的大型應用程序而言，通常不只是單獨一個類或單獨一組類所能完成的，通常會由一個或多個可部署組件組成。對Java程序而言，可複用的組件通常打包成一個JAR、WAR等文件；對C/C++應用而言，通常是DLL動態鏈接庫文件。<br>組件圖提供系統的物理視圖，它的用途是顯示系統中的軟件對其它軟件組件的依賴關係。組件圖可以在一個非常高的層次上顯示，僅顯示系統中粗粒度的組件，也可以在組件包層次上顯示。<br>組件圖通常包含組件、接口和Port等圖元，UML使用帶插頭符號的矩形來表示組件，使用圓圈代表接口，使用位於組件邊界上的小矩形代表Port。<br>組件的接口表示它能對外提供的服務規範，這個接口通常有兩種表現形式：</p><ul><li>用一條實線連接到組件邏輯的圓圈表示</li><li>使用位於組件內部的圓圈表示<br>組件除了可以對外提供服務接口之外，還可能依賴於某個接口，組件依賴於某個接口使用一條帶半圓的實現來表示。如圖一個簡單的Order組件，對外提供一個Payable接口，該組件需要依賴於一個CustomerLookup接口——通常這個CustomerLookup接口也是系統中已有的接口。<br></li></ul><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fca5eb8d93e142fa97bb7a6d79fae91c><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>4. 部署圖</h1><p style=text-align:start>部署圖用於描述軟件系統如何部署到硬件環境中，它的用途是顯示軟件系統不同的組件將在何處物理運行，以及它們將如何彼此通信。</p><p style=text-align:start><br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f01fa4bf2d9c431fb1518e32a509edda><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>5. 順序圖</h1><p>順序圖顯示具體用例（或者是用例的一部分）的詳細流程，並且顯示流程中不同對象之間的調用關係，同時還可以很詳細地顯示對不同對象的不同調用。順序圖描述了對象之間的交互（順序圖和通信圖都被稱為交互圖），重點在於描述消息及其時間順序。<br>順序圖有兩個維度：垂直維度，以發生的時間順序顯示消息/調用的序列；水平維度，顯示消息被髮送的對象實例。<br>順序圖的頂部每個框表示每個類的實例（對象），框中的類實例名稱和類名稱之間用冒號或空格來分隔，例如myReportGenerator:ReportGenerator。如果某個類實例向另一個類實例發送一條消息，則繪製一條指向接收類實例的帶箭頭的連線，並把消息/方法的名稱放在連線上面。<br>對於某些特別重要的消息，還可以繪製一條帶箭頭的指向發起類實例的虛線，將返回值標註在虛線上，繪製帶返回值的信息可以使得序列圖更易於閱讀。<br>用戶登錄順序圖：<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/1eaef26bcaaf48518ffe01ad5defb52a><p class=pgc-img-caption></p></div><p><br></p><p style=text-align:start>當繪製順序圖時，消息可以向兩個方向擴展，消息穿梭在順序圖中，通常應該把消息發送者與接收者相鄰擺放，儘量避免消息跨越多個對象。對象的激活期不是其存在的時間，而是它佔據CPU的執行時間，繪製順序圖時，激活期要精確。</p><h1 class=pgc-h-arrow-right>6. 活動圖</h1><p>活動圖和狀態機圖都被稱為演化圖。<br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f95abea1cda04fc59b1b8992b6e3c459><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>7. 狀態機圖</h1><p><br></p><div class=pgc-img><img alt="JAVA進階 深入理解面向對象" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/46becf5d300b401a8c4497f51efa4027><p class=pgc-img-caption></p></div><p><br>上圖描繪了Hibernate 實體具有3個狀態：瞬態、持久化和脫管。<br>繪製狀態機圖時應該保證對象只有一個初始狀態，可以有多個終結狀態。狀態要表示對象的關鍵快照，有重要的實際意義，無關緊要的狀態則無須考慮，繪製狀態機時事件和方法要明確。<br>狀態機圖擅長表現單個對象的跨用例行為，對於多個對象的交互行為應該考慮採用順序圖，不要對系統的每個對象都畫狀態機圖，只對真正需要關心各個狀態的對象才繪製狀態機圖。</p><p>本文學習資源來自《瘋狂Java講義》。UML部分摘自一本書忘了名稱，如有侵權請告知，我將立刻予以刪除。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>JAVA</a></li><li><a>進階</a></li><li><a>對象</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html alt=JAVA：面向對象編程的底層邏輯，深度剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f7362955cbfb4eb0bb89b09491c5d9a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html title=JAVA：面向對象編程的底層邏輯，深度剖析>JAVA：面向對象編程的底層邏輯，深度剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34766df.html alt="來談談JAVA面向對象 - 繼續說多態~" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/58d42ac1398d4b5c873487092f8e5d05 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34766df.html title="來談談JAVA面向對象 - 繼續說多態~">來談談JAVA面向對象 - 繼續說多態~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b298260.html alt=JAVA基礎——面向對象三大特性：封裝、繼承、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/403f086d79124a40aab485ad48379757 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b298260.html title=JAVA基礎——面向對象三大特性：封裝、繼承、多態>JAVA基礎——面向對象三大特性：封裝、繼承、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f6d25f.html alt=JAVA面向對象程序設計之創建型設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/13ac656d-76b7-4249-91ea-92b30fb1b48b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f6d25f.html title=JAVA面向對象程序設計之創建型設計模式>JAVA面向對象程序設計之創建型設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/415b5df.html alt=JAVA面向對象程序設計之對象、類和封裝 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/77a25702-72bd-453c-b973-4d2daeb06d21 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/415b5df.html title=JAVA面向對象程序設計之對象、類和封裝>JAVA面向對象程序設計之對象、類和封裝</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aa5c078.html alt=JAVA面向對象程序設計之結構型&行為型設計模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/29896a1aca91464587685c5edc2cf694 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aa5c078.html title=JAVA面向對象程序設計之結構型&行為型設計模式>JAVA面向對象程序設計之結構型&行為型設計模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html alt=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a646cf102cf74b4a953855ebedbc7d29 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html title=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程>PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html alt=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cce9b3fb23ce41b88311823510e419da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html title=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。>PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/637cf111.html alt=PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/bc66832213514f2996f2e48c9e9cc747 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/637cf111.html title=PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西>PHP進階教程-phper需要知道常駐內存中的上下文是什麼東西</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e3b6719c.html alt=PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/423ce7eefc5d433f86a14589b1ba0043 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e3b6719c.html title=PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器>PHP進階教程-一文理解和實現現代PHP框架裡的IOC容器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fe9184d7.html alt=PHP進階教程-實現一個簡單的MySQL連接池 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/aa2df096a4274ba1b5c8540bcb5b5c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fe9184d7.html title=PHP進階教程-實現一個簡單的MySQL連接池>PHP進階教程-實現一個簡單的MySQL連接池</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45c31c17.html alt=PHP進階教程-設計模式之建造者模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ef25f91086df41eca76e35ff3434b003 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45c31c17.html title=PHP進階教程-設計模式之建造者模式>PHP進階教程-設計模式之建造者模式</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>