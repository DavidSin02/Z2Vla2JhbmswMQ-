<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Python面向對象編程的基本概念 | 极客快訊</title><meta property="og:title" content="Python面向對象編程的基本概念 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/96a3b662b2714c5ca50be3b34b20a3d8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3127c57.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3127c57.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3127c57.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3127c57.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3127c57.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3127c57.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3127c57.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3127c57.html><meta property="article:published_time" content="2020-10-29T20:59:51+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:51+08:00"><meta name=Keywords content><meta name=description content="Python面向對象編程的基本概念"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3127c57.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Python面向對象編程的基本概念</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>由九道門商業數據分析學院提供</p><h1 class=pgc-h-arrow-right>介紹</h1><p style=text-align:start>在學習面向對象的編程時。我決定深入瞭解它的歷史，結果令人著迷。術語“面向對象程序設計”（OOP）是艾倫·凱（Alan Kay）在1966年讀研究生時提出的。名為<strong>Simula</strong>的語言是第一種具有面向對象編程功能的編程語言。它是在1967年開發的，用於製作仿真程序，其中最重要的信息稱為對象。</p><p style=text-align:start><br></p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/96a3b662b2714c5ca50be3b34b20a3d8><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>儘管OOP從1960年代初開始進入市場，但在1990年代，由於C ++，OOP開始增長。之後，這種編程技術已被包括Python在內的各種編程語言所採用，如今它的應用幾乎遍及各個領域，例如實時系統，人工智能和專家系統，客戶端服務器系統，面向對象的數據庫以及許多其他領域。更多。</p><p style=text-align:start>因此，在本文中，我將解釋Python中的面向對象編程的基本概念。</p><h1 class=pgc-h-arrow-right>表中的內容</h1><ol start=1><li>什麼是面向對象的編程？</li><li>面向對象程序設計（OOP）與面向過程程序設計（POP）</li><li>OOP的主要概念</li><ol start=1><li>什麼是課程？</li><li>對象和對象實例化</li><li>類方法</li><li>Python類中的繼承</li><li>封裝形式</li><li>多態性</li><li>數據抽象</li></ol></ol><p style=text-align:start><br></p><h1 class=pgc-h-arrow-right>什麼是面向對象的編程？</h1><p style=text-align:start>面向對象編程（OOP）就是創建“對象”。對象是一組相互關聯的變量和函數。這些變量通常稱為對象的屬性，而功能則稱為對象的行為。這些對象為程序提供了更好，更清晰的結構。</p><p style=text-align:start>例如，汽車可以是物體。如果我們將汽車視為一個對象，那麼它的屬性就是–它的顏色，模型，價格，品牌等。它的行為/功能將是加速，減速，換檔。</p><p style=text-align:start>另一個例子-如果我們將狗視為對象，那麼它的屬性將是-他的顏色，他的品種，他的名字，他的體重等。他的行為/功能將是散步，吠叫，嬉戲等。</p><p style=text-align:start>面向對象編程之所以聞名，是因為它在編程中實現了諸如對象，隱藏，繼承等讀取世界的實體。由於它接近真實場景，因此使可視化變得更加容易。</p><h1 class=pgc-h-arrow-right>面向對象程序設計（OOP）與面向過程程序設計（POP）</h1><p style=text-align:start>OOP和過程編程之間的基本區別是-</p><ul><li>例如，思考POP的一種方法就是製作檸檬水。製作檸檬水的過程包括：首先根據需要喝水，然後在水中加糖，然後在混合物中加入檸檬汁，最後將整個溶液混合。並且您的檸檬水準備服務。POP以類似的方式要求一定的步驟程序。程序程序由功能組成。這意味著在POP方法中，程序分為特定於不同任務的功能。這些功能按特定順序排列，並且程序控制順序進行。 而OOP程序由對象組成。面向對象的方法將程序劃分為多個對象。這些對象是捆綁了真實對象的屬性和行為的實體。</li><li>POP僅適用於小型任務。因為隨著程序長度的增加，代碼的複雜度也會增加。最終變成了功能網。而且，它變得難以調試。OOP藉助更清晰，更簡單的結構解決了這個問題。它允許以繼承的形式重用代碼。</li><li>另一個重要的事情是，在面向過程的編程中，所有功能都可以訪問所有數據，這意味著缺乏安全性。假設您要保護憑據或來自世界各地的任何其他關鍵信息。然後，程序方法無法為您提供這種安全性。為此，OOP藉助其驚人的功能之一“ <strong>封裝”</strong>幫助您，該功能使我們可以隱藏數據。不用擔心，我將在本文的後半部分以及其他面向對象編程的概念中對此進行詳細介紹。現在，只需要瞭解OOP就可以實現安全性，而POP則不能。</li><li>諸如C，Pascal和BASIC之類的編程語言都使用過程方法，而Java，Python，JavaScript，PHP，Scala和C ++是提供面向對象方法的主要語言。</li></ul><h1 class=pgc-h-arrow-right>主要的Python OOP概念-</h1><p style=text-align:start>在本節中，我們將深入研究OOP的基本概念。我們將涵蓋以下主題-</p><ol start=1><li>類</li><li>目的</li><li>方法</li><li>遺產</li><li>封裝形式</li><li>多態性</li><li>數據抽象</li></ol><h1 class=pgc-h-arrow-right>1.什麼是班級？</h1><p style=text-align:start>這個問題的直接答案是-類是對象的集合。與原始數據結構不同，類是用戶定義的數據結構。它們使代碼更易於管理。</p><p style=text-align:start>讓我們看看如何在下面定義一個類-</p><pre><code>類class_name：    班級機構</code></pre><p style=text-align:start>我們在class_name和分號後定義一個帶有關鍵字“ class”的類。我們考慮將縮進作為其主體之後在此基礎上編寫的所有內容。為了使它更容易理解，我們來看一個例子。</p><p style=text-align:start>考慮一個汽車展示廳的情況。您要存儲每輛車的詳細信息。首先定義一個類</p><pre><code>車類：    通過</code></pre><p style=text-align:start>而已！</p><p style=text-align:start>注意：我使用pass語句代替它的主體，因為主要目的是顯示如何定義一個類，而不是它應該包含的內容。</p><p style=text-align:start>在詳細介紹之前，首先要了解對象和實例化。</p><h1 class=pgc-h-arrow-right>2.對象和對象實例化</h1><p style=text-align:start>當我們定義一個類時，僅創建對象的描述或藍圖。在創建<strong>對象</strong>之前沒有內存分配。在<strong>反對者</strong> <strong>實例</strong>包含實際數據或信息。</p><p style=text-align:start>實例化不過是創建類的新對象/實例。讓我們創建上面定義的類的對象-</p><pre><code>obj1 = Car（）</code></pre><p style=text-align:start>完成了！<strong>請注意</strong>，您可以根據自己的選擇更改對象名稱。</p><p style=text-align:start>嘗試打印該對象-</p><pre><code>打印（obj1）</code></pre><p style=text-align:start><br></p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/a976e04a48624f2e85bd1ceeec2c26e9><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>由於我們的類為空，因此它返回存儲對象的地址，即0x7fc5e677b6d8</p><p style=text-align:start>在繼續前進之前，您還需要了解班級指揮。</p><h1 class=pgc-h-arrow-right>類構造器</h1><p style=text-align:start>到目前為止，我們有一個空的Car類，是時候用汽車的屬性來填充我們的類了。類構造器的工作是在創建類的對象時將值分配給類的數據成員。</p><p style=text-align:start>汽車可能具有各種屬性，例如其名稱，顏色，型號，品牌名稱，發動機功率，重量，價格等。出於理解目的，我們僅選擇其中一些。</p><pre><code>車類：    def __init __（自身，名稱，顏色）：        self.name =名稱        self.color =顏色</code></pre><p style=text-align:start>因此，汽車或任何其他對象的屬性必須在我們稱為<strong>__init __（）的方法內</strong>。此__init __（）方法也稱為<strong>構造方法</strong>。每當構造類的對象時，我們都調用構造函數方法。</p><p style=text-align:start>現在讓我們談談__init __（）方法的參數。因此，此方法的第一個參數必須是self。然後，剩下的參數只會出現。</p><p style=text-align:start>構造函數方法中的兩個語句是–</p><ol start=1><li><strong>self.name =名稱</strong></li><li><strong>self.color =顏色：</strong></li></ol><p style=text-align:start>這將創建新的屬性，即<strong>名稱</strong>和<strong>顏色</strong>，然後為它們分配相應參數的值。“ self”關鍵字表示該類的實例。通過使用“ self”關鍵字，我們可以訪問類的屬性和方法。它在方法定義和變量初始化中很有用。每當我們定義一個方法時，都會明確使用“自我”。</p><p style=text-align:start>注意：您也可以在此__init __（）方法之外創建屬性。但是這些屬性對於整個類都是通用的，因此您必須為它們分配值。</p><p style=text-align:start>假設陳列室中的所有汽車都是轎車，而不是一遍又一遍地指定，您可以通過在__init __（）外部創建一個屬性來將car_type的值固定為轎車。</p><pre><code>車類：    car_type =“轎車” #class屬性    def __init __（自身，名稱，顏色）：        self.name =名稱#instance屬性           self.color =顏色#instance屬性</code></pre><p style=text-align:start>在這裡，<strong>實例屬性指</strong>的是構造函數方法中的屬性，即self.name和self.color。並且，<strong>Class屬性是指</strong>構造函數方法外部的屬性，即car_type。</p><h1 class=pgc-h-arrow-right>3.類方法</h1><p style=text-align:start>到目前為止，我們已經添加了汽車的屬性。現在是時候添加一些行為了。方法是我們用來描述對象行為的功能。它們也在類內定義。看下面的代碼-</p><pre><code>車類：       car_type =“轎車”     def __init __（個人，姓名，里程）：        self.name =名稱         self.mileage =里程     def說明（自己）：                         return f“ {self.name}汽車的行駛里程為{self.mileage} km / l”    def max_speed（self，speed）：        返回f“ {self.name}以{speed} km / hr的最大速度運行”</code></pre><p style=text-align:start>在類中定義的除構造方法之外的方法稱為<strong>實例</strong>方法。此外，我們有兩個實例方法這裡- <strong>說明</strong>（）和<strong>MAX_SPEED</strong>（）。讓我們逐一談論它們-</p><ul><li><strong>description</strong>（）-此方法返回一個字符串，其中包含汽車的描述，例如名稱和行駛里程。此方法沒有其他參數。此方法使用實例屬性。</li><li><strong>max_speed</strong>（）-此方法有一個附加參數，並返回一個顯示汽車名稱及其速度的字符串。</li></ul><p style=text-align:start>請注意，附加參數速度未使用“ self”關鍵字。由於speed不是實例變量，因此我們不使用self關鍵字作為其前綴。讓我們為上述類創建一個對象。</p><pre><code>obj2 = Car（“ Honda City”，24.1）打印（obj2.description（））打印（obj2.max_speed（150））</code></pre><p style=text-align:start><br></p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b55b9e78f82044579d435361831e248f><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>我們要做的是創建一個car類的對象，並傳遞了必需的參數。為了訪問實例方法，我們使用object_name.method_name（）。</p><p style=text-align:start>方法description（）沒有任何其他參數，因此在調用它時沒有傳遞任何參數。</p><p style=text-align:start>max_speed（）方法有一個附加參數，因此我們在調用它時傳遞了一個參數。</p><p style=text-align:start>注意：要記住的三件重要事情是：</p><ol start=1><li>您可以創建一個類的任意數量的對象。</li><li>如果該方法需要n個參數，而您沒有傳遞相同數量的參數，則將發生錯誤。</li><li>參數的順序很重要。</li></ol><p style=text-align:start>讓我們一一看</p><ol start=1><li>創建一個類的多個對象<br>車類： def __init __（個人，姓名，里程）： self.name =名稱 self.mileage =里程 def max_speed（self，speed）： 返回f“ {self.name}以{speed} km / hr的最大速度運行”<br>本田=汽車（“本田城”，21.4） 打印（Honda.max_speed（150）） 斯柯達=汽車（“斯柯達明銳”，13） 打印（Skoda.max_speed（210））</li></ol><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/508769b1b953498bbc132aa506c00b86><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><ol start=1><li>傳遞了錯誤數量的參數。<br>車類： def __init __（個人，姓名，里程）： self.name =名稱 self.mileage =里程<br>本田=汽車（“本田城”） 印刷（本田）</li></ol><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d5edcf9dc19f4ffdb9755a807ce82f9c><p class=pgc-img-caption></p></div><p style=text-align:start><br>由於我們沒有提供第二個參數，因此出現了此錯誤。</p><ol start=1><li>參數順序<br>車類： def __init __（個人，姓名，里程）： self.name =名稱 self.mileage =里程 def說明（自己）： return f“ {self.name}汽車的行駛里程為{self.mileage} km / l”<br>本田=汽車（24.1，“本田城”） 打印（Honda.description（））</li></ol><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cb885f5c55e241d681cba61a00840a4e><p class=pgc-img-caption></p></div><p style=text-align:start><br>弄亂！注意，我們更改了參數的順序。<br>現在，有四個面向對象編程的基本概念- <strong>繼承</strong>，<strong>封裝</strong>，<strong>多態</strong>和<strong>數據抽象</strong>。瞭解所有這些對於理解OOP非常重要。到目前為止，我們已經涵蓋了OOP的基礎知識，讓我們進一步深入。</p><p style=text-align:start>4. Python類中的繼承</p><p style=text-align:start>繼承是一個類繼承另一個類的屬性和方法的過程。繼承其屬性和方法的類稱為Parent類。從父類繼承屬性的類是Child類。</p><p style=text-align:start>有趣的是，連同繼承的屬性和方法，子類可以具有自己的屬性和方法。</p><p style=text-align:start>如何繼承父類？使用以下語法：</p><pre><code>class parent_class：父類的主體class child_class（parent_class）：兒童班的身體</code></pre><p style=text-align:start>讓我們看一下實現-</p><p style=text-align:start>車級：＃父級 def __init __（個人，姓名，里程）： self.name =名稱 self.mileage =里程 def說明（自己）： return f“ {self.name}汽車的行駛里程為{self.mileage} km / l” 寶馬（汽車）級：＃兒童級 通過 奧迪（汽車）類：＃兒童類 def audi_desc（）： 返回“這是奧迪類的描述方法。”<br>obj1 = BMW（“ BMW 7-series”，39.53） 打印（obj1.description（）） obj2 = Audi（“ Audi A8 L”，14） 打印（obj2.description（）） 打印（obj2.audi_desc（））</p><p style=text-align:start><br></p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/9e5308bfd99546848fe357d67544b018><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>我們創建了兩個子類“ BMW”和“ Audi”，它們繼承了父類“ Car”的方法和屬性。在BMW類中，我們沒有提供其他功能和方法。而在Audi類中的另一種方法。</p><p style=text-align:start>注意子類的對象如何在obj1.description（）和obj2.description（）的幫助下訪問父類的實例方法description（）。而且，也可以使用obj2.audi_desc（）訪問Audi類的單獨方法。</p><h1 class=pgc-h-arrow-right>5.封裝</h1><p style=text-align:start>正如我在本文的第一部分中提到的，封裝是一種確保安全性的方法。基本上，它隱藏了外部人無法訪問的數據。例如，如果組織希望保護對象/信息免受客戶端或任何未授權人員的有害訪問，則封裝是確保這一點的方法。</p><p style=text-align:start>您可以在方法或屬性名稱之前使用單個下劃線（_）聲明受保護的方法或屬性。如-self._name或def _method（）; 這兩行都表明屬性和方法是受保護的，不應在類和子類的訪問權限之外使用，而是可以由類方法和對象訪問。</p><p style=text-align:start>儘管Python只是將_用作編碼約定，但它告訴您應在類範圍內使用這些屬性/方法。但是您仍然可以像往常一樣訪問定義為保護的變量和方法。</p><p style=text-align:start>現在，實際上是為了防止從類範圍之外訪問屬性/方法，可以使用“ <strong>私有成員</strong> ”。為了將屬性/方法聲明為私有成員，請在前綴中使用雙下劃線（__）。如– self .__ name或def __method（）; 這兩行都表明屬性和方法是私有的，並且無法從類外部進行訪問。</p><p style=text-align:start>類車： def __init __（個人，姓名，里程）： self._name =名稱＃受保護的變量 self.mileage =里程 def說明（自己）： return f“ {self._name}汽車的行駛里程為{self.mileage} km / l”<br>obj = car（“寶馬7系列”，39.53） ＃通過類方法訪問受保護的變量 打印（obj.description（）） ＃直接從外部訪問受保護的變量 打印（obj._name） 打印（obj.mileage）</p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/362e916af299417c9f75d4ae532316f7><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>注意我們如何訪問受保護的變量而沒有任何錯誤。顯然，對該變量的訪問仍然是公共的。讓我們看看封裝的工作原理-</p><p style=text-align:start>車類： def __init __（個人，姓名，里程）： self .__ name = name＃私有變量 self.mileage =里程 def說明（自己）： return f“ {self .__ name}汽車的行駛里程為{self.mileage} km / l”<br>obj = Car（“ BMW 7-series”，39.53） ＃通過類方法訪問私有變量 打印（obj.description（）） ＃直接從外部訪問私有變量 打印（obj.mileage） 打印（obj .__ name）</p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/428d0b27b6644d8e8a39fdfdb8643f43><p class=pgc-img-caption></p></div><p style=text-align:start><br>當我們嘗試使用description（）方法訪問私有變量時，沒有遇到任何錯誤。但是，當我們嘗試直接在類外部訪問私有變量時，Python給了我們一個錯誤說明：car對象沒有屬性'__name'。<br>您仍然可以使用其變形的名稱直接訪問此屬性。<strong>名稱修飾 </strong>是我們用於從外部訪問類成員的一種機制。Python解釋器會將帶有“ __var”的任何標識符重寫為“ _ClassName__var”。使用此方法，您還可以從外部訪問該類成員。</p><p style=text-align:start>車類： def __init __（個人，姓名，里程）： self .__ name = name＃私有變量 self.mileage =里程 def說明（自己）： return f“ {self .__ name}汽車的行駛里程為{self.mileage} km / l”</p><p style=text-align:start>obj = Car（“ BMW 7-series”，39.53） ＃通過類方法訪問私有變量 打印（obj.description（）） ＃直接從外部訪問私有變量 打印（obj.mileage） print（obj._car__name）＃被纏住的名字</p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2eba70113d6d47e299f6bda99224c088><p class=pgc-img-caption></p></div><p style=text-align:start><br>請注意，規則修改的設計主要是避免發生意外。但是仍然可以訪問或修改被視為私有的變量。這在特殊情況下（例如在調試器中）甚至很有用。<br>6.多態性<br>這是希臘字。如果我們打破“多態”一詞，就會得到“多”形和“變形”形。因此，多態性意味著具有多種形式。在OOP中，它是指名稱相同但功能不同的功能。<br>奧迪課程： def說明（自己）： print（“這是AUDI類的描述功能。”） 寶馬級： def說明（自己）： print（“這是BMW類的描述功能。”）<br>奧迪=奧迪（） 寶馬=寶馬（） 用於（奧迪，寶馬）中的汽車： car.description（）</p><p style=text-align:start><br></p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/86e4b096547041218d9c77f1355baeb9><p class=pgc-img-caption></p></div><p style=text-align:start><br></p><p style=text-align:start>當使用對象<em>audi</em>調用該函數時，將調用<em>Audi</em>類的函數，而使用對象<em>bmw</em>調用該函數時，將調用<em>BMW</em>類的函數。<br>7.數據抽象<br>我們使用抽象來隱藏函數的內部細節或實現並僅顯示其功能。這類似於您在不知道背景機制的情況下如何駕駛汽車的方式。或者，您知道如何使用開關打開或關閉電燈，但是您不知道插座後面發生了什麼。<br>具有至少一個抽象功能的任何類都是抽象類。為了首先創建一個抽象類，您需要從<u>abc</u>模塊導入ABC類。這使您可以在其中創建抽象方法。ABC代表抽象基類。<br>從abc導入ABC 類abs_class（ABC）： 類的主體<br><strong>重要的是</strong> –您不能使用abstract方法為abstract類創建對象。例如-<br>從abc導入ABC，abstractmethod 轎車（ABC）： def __init __（self，name）： self.name =名稱 @abstractmethod 定義價格（自我，x）： 通過<br>obj =汽車（“本田城”）</p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3d45d2b2053647acb3180bab03523f04><p class=pgc-img-caption></p></div><p style=text-align:start><br>現在的問題是我們如何準確地使用這種抽象。答案是通過使用繼承。<br>從abc導入ABC，abstractmethod 轎車（ABC）： def __init __（self，name）： self.name =名稱 def說明（自己）： print（“這是汽車的描述功能。”） @abstractmethod 定義價格（自我，x）： 通過 新車類（汽車）： 定義價格（自我，x）： print（f“ {self.name}的價格為{x}十萬。”）<br>obj = new（“ Honda City”） obj.description（） obj.price（25）</p><div class=pgc-img><img alt=Python面向對象編程的基本概念 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bfeeae325b424e9f8b0090da650ccd68><p class=pgc-img-caption></p></div><p style=text-align:start><br>Car是從abc模塊的<strong>ABC</strong>類繼承的抽象類。請注意，我在抽象類中有一個抽象方法（price（））和一個具體方法（description（））。這是因為抽象類可以同時包含這兩種功能，而普通類則不能。從該抽象類繼承的另一個類是<em>new（）</em>。此方法為抽象方法（price（））定義，這是我們使用抽象函數的方式。<br>用戶從<em>new（）</em>類創建對象並調用price（）方法後，<em>new（）</em>類內部的price方法的定義就會起作用。這些定義對用戶隱藏。Abstract方法只是提供一個聲明。子類需要提供定義。<br>但是，當為new（）類（即<strong>obj</strong>）的對象調用description（）方法時，將調用Car的description（）方法，因為它不是抽象方法。<br>尾註<br>總而言之，在本文中，我介紹了Python中面向對象編程的基本概念。</p><p style=text-align:start>希望您瞭解這些文章中介紹的概念。如果您有任何疑問，請在下面的評論中告訴我。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Python</a></li><li><a>對象</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8be1535d.html alt=Python編程快速入門：4招方法創建一個程序代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/16be94530bff41f891a458717c4637ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8be1535d.html title=Python編程快速入門：4招方法創建一個程序代碼>Python編程快速入門：4招方法創建一個程序代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/301cd03b.html alt=人工智能編程語言Python基礎概念介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/d39d3c33-e7fa-4bb5-a45d-94a0b402a752 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/301cd03b.html title=人工智能編程語言Python基礎概念介紹>人工智能編程語言Python基礎概念介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/640c3144.html alt=人工智能編程語言Python字符串、輸出與輸入介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/22453e52-eb16-4810-824b-ecdf39701cee style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/640c3144.html title=人工智能編程語言Python字符串、輸出與輸入介紹>人工智能編程語言Python字符串、輸出與輸入介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/415b1e8f.html alt=人工智能編程語言Python遍歷及共有操作介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/71101d0f-a8db-496c-a20f-8d903737e070 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/415b1e8f.html title=人工智能編程語言Python遍歷及共有操作介紹>人工智能編程語言Python遍歷及共有操作介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html alt=JAVA：面向對象編程的底層邏輯，深度剖析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f7362955cbfb4eb0bb89b09491c5d9a0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6ca1e5b.html title=JAVA：面向對象編程的底層邏輯，深度剖析>JAVA：面向對象編程的底層邏輯，深度剖析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html alt=Python面向對象設計和麵向對象編程解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a51dafeb.html title=Python面向對象設計和麵向對象編程解析>Python面向對象設計和麵向對象編程解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html alt=什麼是面向對象的編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/be4dacb2168b48e085eec6c0640bc176 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfe5e1fb.html title=什麼是面向對象的編程思想>什麼是面向對象的編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html alt=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8f2e808d6760462aafc6bfbb0e718954 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab5cd3e8.html title=你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維>你真的知道為什麼要面向對象編程嗎，3步徹底明白麵向對象思維</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/810c487e.html alt="到底什麼是面向對象編程( OOP )？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5462f49b28c446b4b9214dae06156a7c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/810c487e.html title="到底什麼是面向對象編程( OOP )？">到底什麼是面向對象編程( OOP )？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3782027.html alt=漫畫：面向對象編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RSgLiL1LcHkAv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3782027.html title=漫畫：面向對象編程>漫畫：面向對象編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html alt=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532998144998addd88387a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f1896377.html title=都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則>都說面向對象編程，偷偷告訴你面向對象編程的6大設計原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html alt=面向對象編程設計的類與對象 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/86e56bdd947940c4b06129e01f19706a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e7951a6.html title=面向對象編程設計的類與對象>面向對象編程設計的類與對象</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/221392e5.html alt=Python少兒編程系列-第6課-內存變量的輸入輸出和處理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bf5a66456ed642aca8eead3208cb5675 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/221392e5.html title=Python少兒編程系列-第6課-內存變量的輸入輸出和處理>Python少兒編程系列-第6課-內存變量的輸入輸出和處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d385ab.html alt=Python編程快速上手讓繁瑣工作自動化-生成隨機的測驗試卷文件 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/8ec6b5a6-e1c3-44ae-8ccc-0550da636710 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d385ab.html title=Python編程快速上手讓繁瑣工作自動化-生成隨機的測驗試卷文件>Python編程快速上手讓繁瑣工作自動化-生成隨機的測驗試卷文件</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6559e37.html alt=C語言對象編程第三彈：多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f0f7f4ab1c174939a0c0f2dccebfb7e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6559e37.html title=C語言對象編程第三彈：多態>C語言對象編程第三彈：多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>