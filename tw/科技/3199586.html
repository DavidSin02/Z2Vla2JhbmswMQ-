<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>常用的NIO框架-Netty | 极客快訊</title><meta property="og:title" content="常用的NIO框架-Netty - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8121b707a0c043b5a0087400f083f24e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3199586.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3199586.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3199586.html><meta property="article:published_time" content="2020-10-29T20:51:14+08:00"><meta property="article:modified_time" content="2020-10-29T20:51:14+08:00"><meta name=Keywords content><meta name=description content="常用的NIO框架-Netty"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3199586.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>常用的NIO框架-Netty</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><a class=pgc-link data-content=mp data-source=innerLink href=https://www.toutiao.com/item/6883067855705735693/ rel="noopener noreferrer" target=_blank>架構師-網絡文章彙總</a></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1. Netty簡介</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty是一個高性能、異步事件驅動的NIO框架，基於JAVA NIO提供的API實現。它提供了對TCP、UDP和文件傳輸的支持，作為一個異步NIO框架，Netty的所有IO操作都是異步非阻塞的，通過Future-Listener機制，用戶可以方便的主動獲取或者通過通知機制獲得IO操作結果。 作為當前最流行的NIO框架，Netty在互聯網領域、大數據分佈式計算領域、遊戲行業、通信行業等獲得了廣泛的應用，一些業界著名的開源組件也基於Netty的NIO框架構建。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2. Netty線程模型</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在JAVA NIO方面Selector給Reactor模式提供了基礎，Netty結合Selector和Reactor模式設計了高效的線程模型。先來看下Reactor模式：</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.1 Reactor模式</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Wikipedia這麼解釋Reactor模型：“The reactor design pattern is an event handling pattern for handling service requests delivered concurrently by one or more inputs. The service handler then demultiplexes the incoming requests and dispatches them synchronously to associated request handlers.”。首先Reactor模式首先是事件驅動的，有一個或者多個併發輸入源，有一個Server Handler和多個Request Handlers，這個Service Handler會同步的將輸入的請求多路複用的分發給相應的Request Handler。可以如下圖所示：</span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8121b707a0c043b5a0087400f083f24e><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">從結構上有點類似生產者和消費者模型，即一個或多個生產者將事件放入一個Queue中，而一個或者多個消費者主動的從這個隊列中poll事件來處理；而Reactor模式則沒有Queue來做緩衝，每當一個事件輸入到Service Handler之後，該Service Handler會主動根據不同的Evnent類型將其分發給對應的Request Handler來處理。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.2 Reator模式的實現</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">關於Java NIO 構造Reator模式，Doug lea在《Scalable IO in Java》中給了很好的闡述，這裡截取PPT對Reator模式的實現進行說明</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1.第一種實現模型如下：<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/807e41841c9443edb449ac46324a5e6e><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這是最簡單的Reactor單線程模型，由於Reactor模式使用的是異步非阻塞IO，所有的IO操作都不會被阻塞，理論上一個線程可以獨立處理所有的IO操作。這時Reactor線程是個多面手，負責多路分離套接字，Accept新連接，並分發請求到處理鏈中。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對於一些小容量應用場景，可以使用到單線程模型。但對於高負載，大併發的應用卻不合適，主要原因如下：</span></p><ol start=1><li>當一個NIO線程同時處理成百上千的鏈路，性能上無法支撐，即使NIO線程的CPU負荷達到100%，也無法完全處理消息</li><li>當NIO線程負載過重後，處理速度會變慢，會導致大量客戶端連接超時，超時之後往往會重發，更加重了NIO線程的負載。</li><li>可靠性低，一個線程意外死循環，會導致整個通信系統不可用</li></ol><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">為了解決這些問題，出現了Reactor多線程模型。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.Reactor多線程模型：<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37b7fd79de7d4ee7a5ba1edeca6876bc><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">相比上一種模式，該模型在處理鏈部分採用了多線程（線程池）。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在絕大多數場景下，該模型都能滿足性能需求。但是，在一些特殊的應用場景下，如服務器會對客戶端的握手消息進行安全認證。這類場景下，單獨的一個Acceptor線程可能會存在性能不足的問題。為了解決這些問題，產生了第三種Reactor線程模型</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">3.Reactor主從模型<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/48c314ddc1c24f7eabb3a06ff6c055b4><p class=pgc-img-caption></p></div><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">該模型相比第二種模型，是將Reactor分成兩部分，mainReactor負責監聽server socket，accept新連接；並將建立的socket分派給subReactor。subReactor負責多路分離已連接的socket，讀寫網絡數據，對業務處理功能，其扔給worker線程池完成。通常，subReactor個數上可與CPU個數等同。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.3 Netty模型</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.2中說完了Reactor的三種模型，那麼Netty是哪一種呢？其實Netty的線程模型是Reactor模型的變種，那就是去掉線程池的第三種形式的變種，這也是Netty NIO的默認模式。Netty中Reactor模式的參與者主要有下面一些組件：</span></p><ol start=1><li>Selector</li><li>EventLoopGroup/EventLoop</li><li>ChannelPipeline</li></ol><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Selector即為NIO中提供的SelectableChannel多路複用器，充當著demultiplexer的角色，這裡不再贅述；下面對另外兩種功能和其在Netty之Reactor模式中扮演的角色進行介紹。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.EventLoopGroup/EventLoop</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當系統在運行過程中，如果頻繁的進行線程上下文切換，會帶來額外的性能損耗。多線程併發執行某個業務流程，業務開發者還需要時刻對線程安全保持警惕，哪些數據可能會被併發修改，如何保護？這不僅降低了開發效率，也會帶來額外的性能損耗。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">為了解決上述問題，Netty採用了串行化設計理念，從消息的讀取、編碼以及後續Handler的執行，始終都由IO線程EventLoop負責，這就</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">意外著</span><span style="color:#4d4d4d;--tt-darkmode-color: #999999">整個流程不會進行線程上下文的切換，數據也不會面臨被併發修改的風險。這也解釋了為什麼Netty線程模型去掉了Reactor主從模型中線程池。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">EventLoopGroup是一組EventLoop的抽象，EventLoopGroup提供next接口，可以總一組EventLoop裡面按照一定規則獲取其中一個EventLoop來處理任務，對於EventLoopGroup這裡需要了解的是在Netty中，在Netty服務器編程中我們需要BossEventLoopGroup和WorkerEventLoopGroup兩個EventLoopGroup來進行工作。通常一個服務端口即一個ServerSocketChannel對應一個Selector和一個EventLoop線程，也就是說BossEventLoopGroup的線程數參數為1。BossEventLoop負責接收客戶端的連接並將SocketChannel交給WorkerEventLoopGroup來進行IO處理。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">EventLoop的實現充當Reactor模式中的分發（Dispatcher）的角色。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">4.ChannelPipeline</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ChannelPipeline其實是擔任著Reactor模式中的請求處理器這個角色。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ChannelPipeline的默認實現是DefaultChannelPipeline，DefaultChannelPipeline本身維護著一個用戶不可見的tail和head的ChannelHandler，他們分別位於鏈表隊列的頭部和尾部。tail在更上層的部分，而head在靠近網絡層的方向。在Netty中關於ChannelHandler有兩個重要的接口，ChannelInBoundHandler和ChannelOutBoundHandler。inbound可以理解為網絡數據從外部流向系統內部，而outbound可以理解為網絡數據從系統內部流向系統外部。用戶實現的ChannelHandler可以根據需要實現其中一個或多個接口，將其放入Pipeline中的鏈表隊列中，ChannelPipeline會根據不同的IO事件類型來找到相應的Handler來處理，同時鏈表隊列是責任鏈模式的一種變種，自上而下或自下而上所有滿足事件關聯的Handler都會對事件進行處理。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ChannelInBoundHandler對從客戶端發往服務器的報文進行處理，一般用來執行半包/粘包，解碼，讀取數據，業務處理等；ChannelOutBoundHandler對從服務器發往客戶端的報文進行處理，一般用來進行編碼，發送報文到客戶端。</span></p><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">下圖是對ChannelPipeline執行過程的說明：<br></span></p><div class=pgc-img><img alt=常用的NIO框架-Netty onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/489b64c3390341bdb4b1300cf6d1dc6e><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">5.Buffer</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty提供的經過擴展的Buffer相對NIO中的有個許多優勢，作為數據存取非常重要的一塊，我們來看看Netty中的Buffer有什麼特點。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">1.ByteBuf讀寫指針</span></p><ul><li>在ByteBuffer中，讀寫指針都是position，而在ByteBuf中，讀寫指針分別為readerIndex和writerIndex，直觀看上去ByteBuffer僅用了一個指針就實現了兩個指針的功能，節省了變量，但是當對於ByteBuffer的讀寫狀態切換的時候必須要調用flip方法，而當下一次寫之前，必須要將Buffe中的內容讀完，再調用clear方法。每次讀之前調用flip，寫之前調用clear，這樣無疑給開發帶來了繁瑣的步驟，而且內容沒有讀完是不能寫的，這樣非常不靈活。相比之下我們看看ByteBuf，讀的時候僅僅依賴readerIndex指針，寫的時候僅僅依賴writerIndex指針，不需每次讀寫之前調用對應的方法，而且沒有必須一次讀完的限制。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">2.零拷貝</span></p><ul><li>Netty的接收和發送ByteBuffer採用DIRECT BUFFERS，使用堆外直接內存進行Socket讀寫，不需要進行字節緩衝區的二次拷貝。如果使用傳統的堆內存（HEAP BUFFERS）進行Socket讀寫，JVM會將堆內存Buffer拷貝一份到直接內存中，然後才寫入Socket中。相比於堆外直接內存，消息在發送過程中多了一次緩衝區的內存拷貝。</li><li>Netty提供了組合Buffer對象，可以聚合多個ByteBuffer對象，用戶可以像操作一個Buffer那樣方便的對組合Buffer進行操作，避免了傳統通過內存拷貝的方式將幾個小Buffer合併成一個大的Buffer。</li><li>Netty的文件傳輸採用了transferTo方法，它可以直接將文件緩衝區的數據發送到目標Channel，避免了傳統通過循環write方式導致的內存拷貝問題。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">3.引用計數與池化技術</span></p><ul><li>在Netty中，每個被申請的Buffer對於Netty來說都可能是很寶貴的資源，因此為了獲得對於內存的申請與回收更多的控制權，Netty自己根據引用計數法去實現了內存的管理。Netty對於Buffer的使用都是基於直接內存（DirectBuffer）實現的，大大提高I/O操作的效率，然而DirectBuffer和HeapBuffer相比之下除了I/O操作效率高之外還有一個天生的缺點，即對於DirectBuffer的申請相比HeapBuffer效率更低，因此Netty結合引用計數實現了PolledBuffer，即池化的用法，當引用計數等於0的時候，Netty將Buffer回收致池中，在下一次申請Buffer的沒某個時刻會被複用。</li></ul><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">總結</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty其實本質上就是Reactor模式的實現，Selector作為多路複用器，EventLoop作為轉發器，Pipeline作為事件處理器。但是和一般的Reactor不同的是，Netty使用串行化實現，並在Pipeline中使用了責任鏈模式。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">Netty中的buffer相對有NIO中的buffer又做了一些優化，大大提高了性能。</span></p><p><br></p><p>關於Netty的更多介紹，可以參考我前面的Netty系列文章。</p><p><a class=pgc-link data-content=mp data-source=innerLink href=https://www.toutiao.com/item/6876247461719966211/ rel="noopener noreferrer" target=_blank>「Netty核心技術」7-ChannelHandler源碼</a></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>NIO</a></li><li><a>Netty</a></li><li><a>框架</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3acc62b8.html alt=使用框架集裝箱運輸的好處有哪些 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9f740c941b944697af56405220123880 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3acc62b8.html title=使用框架集裝箱運輸的好處有哪些>使用框架集裝箱運輸的好處有哪些</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0c9bd885.html alt=框架柱主筋錯位馬虎不得 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/9612a651f0c0485b8cf657f8b50bb0fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0c9bd885.html title=框架柱主筋錯位馬虎不得>框架柱主筋錯位馬虎不得</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/28068cb6.html alt="手把手教你 Netty 實現自定義協議" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35a65c1e6e4b489d9b87fd6e169e8b66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/28068cb6.html title="手把手教你 Netty 實現自定義協議">手把手教你 Netty 實現自定義協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e66b54d5.html alt=如何建立數據分析的思維框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/79e87046874944bb9de82506f5ff9470 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e66b54d5.html title=如何建立數據分析的思維框架>如何建立數據分析的思維框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/174cec9a.html alt=數學知識框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a66f012f0f4b44d4a43b1e1aff75682f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/174cec9a.html title=數學知識框架>數學知識框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ea40c337.html alt=探索建立更全面的宏觀金融穩定框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ea40c337.html title=探索建立更全面的宏觀金融穩定框架>探索建立更全面的宏觀金融穩定框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/cf8ccd49.html alt=光伏行業研究框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ef29dd4980b48d18c5b69c16a78a76e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/cf8ccd49.html title=光伏行業研究框架>光伏行業研究框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c933652.html alt=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/305b744c-4e26-4f9a-8ab5-bed383199d42 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c933652.html title=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！>阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/169092f2.html alt=JavaEE——框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1528115090260193a3cf46f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/169092f2.html title=JavaEE——框架>JavaEE——框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ca81088.html alt="Java NIO通信框架在電信領域的實踐" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15346469062094e0715f5be style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ca81088.html title="Java NIO通信框架在電信領域的實踐">Java NIO通信框架在電信領域的實踐</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd6d0a71.html alt="Java匹馬行天下之J2EE框架開發——Spring—>Spring框架知多少" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7ece04c16b324742a1167e27adee93ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd6d0a71.html title="Java匹馬行天下之J2EE框架開發——Spring—>Spring框架知多少">Java匹馬行天下之J2EE框架開發——Spring—>Spring框架知多少</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/838fd64a.html alt=java中常用的緩存框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/78a0bebc633247cdab9c2808446d3055 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/838fd64a.html title=java中常用的緩存框架>java中常用的緩存框架</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96f409cb.html alt=盤點Java程序員常用的5大框架，有你用的嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/dd318076ff704dc6b2a6fb37f7c28ce7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96f409cb.html title=盤點Java程序員常用的5大框架，有你用的嗎？>盤點Java程序員常用的5大框架，有你用的嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1695038.html alt=估值方法以及思考框架的解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1695038.html title=估值方法以及思考框架的解析>估值方法以及思考框架的解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8348dc03.html alt=競聘失敗的啟示：我們為什麼需要思考框架？又該怎樣用好思考框架 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3d766f81bf3746eebd2c46e10fc6efc6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8348dc03.html title=競聘失敗的啟示：我們為什麼需要思考框架？又該怎樣用好思考框架>競聘失敗的啟示：我們為什麼需要思考框架？又該怎樣用好思考框架</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>