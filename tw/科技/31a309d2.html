<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>企業API接口設計(token、timestamp、sign)之具體實現 | 极客快訊</title><meta property="og:title" content="企業API接口設計(token、timestamp、sign)之具體實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/030192793c5048239b469f5e5db8b18d"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/31a309d2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31a309d2.html><meta property="article:published_time" content="2020-11-14T21:00:28+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:28+08:00"><meta name=Keywords content><meta name=description content="企業API接口設計(token、timestamp、sign)之具體實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/31a309d2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>企業API接口設計(token、timestamp、sign)之具體實現</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>本號主要用於分享企業中常用的技術，更加側重於實用，歡迎關注、收藏，便於瀏覽其它更多實用的歷史文章。</strong></h1><div class=pgc-img><img alt=企業API接口設計(token、timestamp、sign)之具體實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/030192793c5048239b469f5e5db8b18d><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><strong>一：token 簡介</strong></h1><p>Token：訪問令牌access token, 用於接口中, 用於標識接口調用者的身份、憑證，減少用戶名和密碼的傳輸次數。一般情況下客戶端(接口調用方)需要先向服務器端申請一個接口調用的賬號，服務器會給出一個appId和一個key, key用於參數簽名使用，注意key保存到客戶端，需要做一些安全處理，防止洩露。</p><p>Token的值一般是UUID，服務端生成Token後需要將token做為key，將一些和token關聯的信息作為value保存到緩存服務器中(redis)，當一個請求過來後，服務器就去緩存服務器中查詢這個Token是否存在，存在則調用接口，不存在返回接口錯誤，一般通過攔截器或者過濾器來實現，Token分為兩種：</p><p>API Token(接口令牌): 用於訪問不需要用戶登錄的接口，如登錄、註冊、一些基本數據的獲取等。 獲取接口令牌需要拿appId、timestamp和sign來換，sign=加密(timestamp+key)</p><p>USER Token(用戶令牌): 用於訪問需要用戶登錄之後的接口，如：獲取我的基本信息、保存、修改、刪除等操作。獲取用戶令牌需要拿用戶名和密碼來換</p><p>關於Token的時效性：token可以是一次性的、也可以在一段時間範圍內是有效的，具體使用哪種看業務需要。</p><p>一般情況下接口最好使用https協議，如果使用http協議，Token機制只是一種減少被黑的可能性，其實只能防君子不能防小人。</p><p>一般token、timestamp和sign 三個參數會在接口中會同時作為參數傳遞，每個參數都有各自的用途。</p><h1 class=pgc-h-arrow-right><strong>二：timestamp 簡介</strong></h1><p>timestamp: 時間戳，是客戶端調用接口時對應的當前時間戳，時間戳用於防止DoS攻擊。當黑客劫持了請求的url去DoS攻擊，每次調用接口時接口都會判斷服務器當前系統時間和接口中傳的的timestamp的差值，如果這個差值超過某個設置的時間(假如5分鐘)，那麼這個請求將被攔截掉，如果在設置的超時時間範圍內，是不能阻止DoS攻擊的。 timestamp機制只能減輕DoS攻擊的時間，縮短攻擊時間。如果黑客修改了時間戳的值可通過sign簽名機制來處理。</p><p>DoS</p><p>DoS是Denial of Service的簡稱，即拒絕服務，造成DoS的攻擊行為被稱為DoS攻擊，其目的是使計算機或網絡無法提供正常的服務。最常見的DoS攻擊有計算機網絡帶寬攻擊和連通性攻擊。</p><p>DoS攻擊是指故意的攻擊網絡協議實現的缺陷或直接通過野蠻手段殘忍地耗盡被攻擊對象的資源，目的是讓目標計算機或網絡無法提供正常的服務或資源訪問，使目標系統服務系統停止響應甚至崩潰，而在此攻擊中並不包括侵入目標服務器或目標網絡設備。這些服務資源包括網絡帶寬，文件系統空間容量，開放的進程或者允許的連接。這種攻擊會導致資源的匱乏，無論計算機的處理速度多快、內存容量多大、網絡帶寬的速度多快都無法避免這種攻擊帶來的後果。</p><p>Pingflood: 該攻擊在短時間內向目的主機發送大量ping包，造成網絡堵塞或主機資源耗盡。</p><p>Synflood: 該攻擊以多個隨機的源主機地址向目的主機發送SYN包，而在收到目的主機的SYN ACK後並不迴應，這樣，目的主機就為這些源主機建立了大量的連接隊列，而且由於沒有收到ACK一直維護著這</p><p>些隊列，造成了資源的大量消耗而不能向正常請求提供服務。</p><p>Smurf：該攻擊向一個子網的廣播地址發一個帶有特定請求（如ICMP迴應請求）的包，並且將源地址偽裝成想要攻擊的主機地址。子網上所有主機都回應廣播包請求而向被攻擊主機發包，使該主機受到攻擊。</p><p>Land-based：攻擊者將一個包的源地址和目的地址都設置為目標主機的地址，然後將該包通過IP欺騙的方式發送給被攻擊主機，這種包可以造成被攻擊主機因試圖與自己建立連接而陷入死循環，從而很大程度地降低了系統性能。</p><p>Ping of Death：根據TCP/IP的規範，一個包的長度最大為65536字節。儘管一個包的長度不能超過65536字節，但是一個包分成的多個片段的疊加卻能做到。當一個主機收到了長度大於65536字節的包時，就是受到了Ping of Death攻擊，該攻擊會造成主機的宕機。</p><p>Teardrop：IP數據包在網絡傳遞時，數據包可以分成更小的片段。攻擊者可以通過發送兩段（或者更多）數據包來實現TearDrop攻擊。第一個包的偏移量為0，長度為N，第二個包的偏移量小於N。為了合併這些數據段，TCP/IP堆棧會分配超乎尋常的巨大資源，從而造成系統資源的缺乏甚至機器的重新啟動。</p><p>PingSweep：使用ICMP Echo輪詢多個主機。</p><h1 class=pgc-h-arrow-right><strong>三：sign 簡介</strong></h1><p>nonce：隨機值，是客戶端隨機生成的值，作為參數傳遞過來，隨機值的目的是增加sign簽名的多變性。隨機值一般是數字和字母的組合，6位長度，隨機值的組成和長度沒有固定規則。</p><p>sign: 一般用於參數簽名，防止參數被非法篡改，最常見的是修改金額等重要敏感參數， sign的值一般是將所有非空參數按照升續排序然後+token+key+timestamp+nonce(隨機數)拼接在一起，然後使用某種加密算法進行加密，作為接口中的一個參數sign來傳遞，也可以將sign放到請求頭中。接口在網絡傳輸過程中如果被黑客挾持，並修改其中的參數值，然後再繼續調用接口，雖然參數的值被修改了，但是因為黑客不知道sign是如何計算出來的，不知道sign都有哪些值構成，不知道以怎樣的順序拼接在一起的，最重要的是不知道簽名字符串中的key是什麼，所以黑客可以篡改參數的值，但沒法修改sign的值，當服務器調用接口前會按照sign的規則重新計算出sign的值然後和接口傳遞的sign參數的值做比較，如果相等表示參數值沒有被篡改，如果不等，表示參數被非法篡改了，就不執行接口了。</p><h1 class=pgc-h-arrow-right><strong>四：防止重複提交</strong></h1><p>對於一些重要的操作需要防止客戶端重複提交的(如非冪等性重要操作)，具體辦法是當請求第一次提交時將sign作為key保存到redis，並設置超時時間，超時時間和Timestamp中設置的差值相同。當同一個請求第二次訪問時會先檢測redis是否存在該sign，如果存在則證明重複提交了，接口就不再繼續調用了。如果sign在緩存服務器中因過期時間到了，而被刪除了，此時當這個url再次請求服務器時，因token的過期時間和sign的過期時間一直，sign過期也意味著token過期，那樣同樣的url再訪問服務器會因token錯誤會被攔截掉，這就是為什麼sign和token的過期時間要保持一致的原因。拒絕重複調用機制確保URL被別人截獲了也無法使用（如抓取數據）。</p><p>對於哪些接口需要防止重複提交可以自定義個註解來標記。</p><p>注意：</p><p>所有的安全措施都用上的話有時候難免太過複雜，在實際項目中需要根據自身情況作出裁剪，比如可以只使用簽名機制就可以保證信息不會被篡改，或者定向提供服務的時候只用Token機制就可以了。如何裁剪，全看項目實際情況和對接口安全性的要求。</p><h1 class=pgc-h-arrow-right><strong>五：使用流程</strong></h1><p>接口調用方(客戶端)向接口提供方(服務器)申請接口調用賬號，申請成功後，接口提供方會給接口調用方一個appId和一個key參數</p><p>客戶端攜帶參數appId、timestamp、sign去調用服務器端的API token，其中sign=加密(appId + timestamp + key)</p><p>客戶端拿著api_token 去訪問不需要登錄就能訪問的接口</p><p>當訪問用戶需要登錄的接口時，客戶端跳轉到登錄頁面，通過用戶名和密碼調用登錄接口，登錄接口會返回一個user_token, 客戶端拿著user_token 去訪問需要登錄才能訪問的接口</p><p>sign的作用是防止參數被篡改，客戶端調用服務端時需要傳遞sign參數，服務器響應客戶端時也可以返回一個sign用於客戶度校驗返回的值是否被非法篡改了。客戶端傳的sign和服務器端響應的sign算法可能會不同。</p><p>六：示例代碼</p><p>1. dependency</p><pre><code>&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>2. RedisConfiguration</p><pre><code>@Configurationpublic class RedisConfiguration { @Bean public JedisConnectionFactory jedisConnectionFactory(){ return new JedisConnectionFactory(); } /** * 支持存儲對象 * @return */ @Bean public RedisTemplate&lt;String, String&gt; redisTemplate(){ RedisTemplate&lt;String, String&gt; redisTemplate = new StringRedisTemplate(); redisTemplate.setConnectionFactory(jedisConnectionFactory()); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper objectMapper = new ObjectMapper(); objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(objectMapper); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); return redisTemplate; }}</code></pre><p>3. TokenController</p><pre><code>@Slf4j@RestController@RequestMapping("/api/token")public class TokenController { @Autowired private RedisTemplate redisTemplate; /** * API Token * * @param sign * @return */ @PostMapping("/api_token") public ApiResponse&lt;AccessToken&gt; apiToken(String appId, @RequestHeader("timestamp") String timestamp, @RequestHeader("sign") String sign) { Assert.isTrue(!StringUtils.isEmpty(appId) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), "參數錯誤"); long reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp); Assert.isTrue(reqeustInterval &lt; 5 * 60 * 1000, "請求過期，請重新請求"); // 1. 根據appId查詢數據庫獲取appSecret AppInfo appInfo = new AppInfo("1", "12345678954556"); // 2. 校驗簽名 String signString = timestamp + appId + appInfo.getKey(); String signature = MD5Util.encode(signString); log.info(signature); Assert.isTrue(signature.equals(sign), "簽名錯誤"); // 3. 如果正確生成一個token保存到redis中，如果錯誤返回錯誤信息 AccessToken accessToken = this.saveToken(0, appInfo, null); return ApiResponse.success(accessToken); } @NotRepeatSubmit(5000) @PostMapping("user_token") public ApiResponse&lt;UserInfo&gt; userToken(String username, String password) { // 根據用戶名查詢密碼, 並比較密碼(密碼可以RSA加密一下) UserInfo userInfo = new UserInfo(username, "81255cb0dca1a5f304328a70ac85dcbd", "111111"); String pwd = password + userInfo.getSalt(); String passwordMD5 = MD5Util.encode(pwd); Assert.isTrue(passwordMD5.equals(userInfo.getPassword()), "密碼錯誤"); // 2. 保存Token AppInfo appInfo = new AppInfo("1", "12345678954556"); AccessToken accessToken = this.saveToken(1, appInfo, userInfo); userInfo.setAccessToken(accessToken); return ApiResponse.success(userInfo); } private AccessToken saveToken(int tokenType, AppInfo appInfo, UserInfo userInfo) { String token = UUID.randomUUID().toString(); // token有效期為2小時 Calendar calendar = Calendar.getInstance(); calendar.setTime(new Date()); calendar.add(Calendar.SECOND, 7200); Date expireTime = calendar.getTime(); // 4. 保存token ValueOperations&lt;String, TokenInfo&gt; operations = redisTemplate.opsForValue(); TokenInfo tokenInfo = new TokenInfo(); tokenInfo.setTokenType(tokenType); tokenInfo.setAppInfo(appInfo); if (tokenType == 1) { tokenInfo.setUserInfo(userInfo); } operations.set(token, tokenInfo, 7200, TimeUnit.SECONDS); AccessToken accessToken = new AccessToken(token, expireTime); return accessToken; } public static void main(String[] args) { long timestamp = System.currentTimeMillis(); System.out.println(timestamp); String signString = timestamp + "1" + "12345678954556"; String sign = MD5Util.encode(signString); System.out.println(sign); System.out.println("-------------------"); signString = "password=123456&amp;username=1&amp;12345678954556" + "ff03e64b-427b-45a7-b78b-47d9e8597d3b1529815393153sdfsdfsfs" + timestamp + "A1scr6"; sign = MD5Util.encode(signString); System.out.println(sign); }}</code></pre><p>4. WebMvcConfiguration</p><pre><code>@Configurationpublic class WebMvcConfiguration extends WebMvcConfigurationSupport { private static final String[] excludePathPatterns = {"/api/token/api_token"}; @Autowired private TokenInterceptor tokenInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { super.addInterceptors(registry); registry.addInterceptor(tokenInterceptor) .addPathPatterns("/api/**") .excludePathPatterns(excludePathPatterns); }}</code></pre><p>5. TokenInterceptor</p><pre><code>@Componentpublic class TokenInterceptor extends HandlerInterceptorAdapter { @Autowired private RedisTemplate redisTemplate; /** * * @param request * @param response * @param handler 訪問的目標方法 * @return * @throws Exception */ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String token = request.getHeader("token"); String timestamp = request.getHeader("timestamp"); // 隨機字符串 String nonce = request.getHeader("nonce"); String sign = request.getHeader("sign"); Assert.isTrue(!StringUtils.isEmpty(token) &amp;&amp; !StringUtils.isEmpty(timestamp) &amp;&amp; !StringUtils.isEmpty(sign), "參數錯誤"); // 獲取超時時間 NotRepeatSubmit notRepeatSubmit = ApiUtil.getNotRepeatSubmit(handler); long expireTime = notRepeatSubmit == null ? 5 * 60 * 1000 : notRepeatSubmit.value(); // 2. 請求時間間隔 long reqeustInterval = System.currentTimeMillis() - Long.valueOf(timestamp); Assert.isTrue(reqeustInterval &lt; expireTime, "請求超時，請重新請求"); // 3. 校驗Token是否存在 ValueOperations&lt;String, TokenInfo&gt; tokenRedis = redisTemplate.opsForValue(); TokenInfo tokenInfo = tokenRedis.get(token); Assert.notNull(tokenInfo, "token錯誤"); // 4. 校驗簽名(將所有的參數加進來，防止別人篡改參數) 所有參數看參數名升續排序拼接成url // 請求參數 + token + timestamp + nonce String signString = ApiUtil.concatSignString(request) + tokenInfo.getAppInfo().getKey() + token + timestamp + nonce; String signature = MD5Util.encode(signString); boolean flag = signature.equals(sign); Assert.isTrue(flag, "簽名錯誤"); // 5. 拒絕重複調用(第一次訪問時存儲，過期時間和請求超時時間保持一致), 只有標註不允許重複提交註解的才會校驗 if (notRepeatSubmit != null) { ValueOperations&lt;String, Integer&gt; signRedis = redisTemplate.opsForValue(); boolean exists = redisTemplate.hasKey(sign); Assert.isTrue(!exists, "請勿重複提交"); signRedis.set(sign, 0, expireTime, TimeUnit.MILLISECONDS); } return super.preHandle(request, response, handler); }}</code></pre><p>6. MD5Util</p><pre><code>public class MD5Util { private static final String hexDigits[] = { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f" }; private static String byteArrayToHexString(byte b[]) { StringBuffer resultSb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) resultSb.append(byteToHexString(b[i])); return resultSb.toString(); } private static String byteToHexString(byte b) { int n = b; if (n &lt; 0) n += 256; int d1 = n / 16; int d2 = n % 16; return hexDigits[d1] + hexDigits[d2]; } public static String encode(String origin) { return encode(origin, "UTF-8"); } public static String encode(String origin, String charsetname) { String resultString = null; try { resultString = new String(origin); MessageDigest md = MessageDigest.getInstance("MD5"); if (charsetname == null || "".equals(charsetname)) resultString = byteArrayToHexString(md.digest(resultString .getBytes())); else resultString = byteArrayToHexString(md.digest(resultString .getBytes(charsetname))); } catch (Exception exception) { } return resultString; }}</code></pre><p>7. @NotRepeatSubmit</p><pre><code>/** * 禁止重複提交 */@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface NotRepeatSubmit { /** 過期時間，單位毫秒 **/ long value() default 5000;}</code></pre><p>8. AccessToken</p><pre><code>@Data@AllArgsConstructorpublic class AccessToken { /** token */ private String token; /** 失效時間 */ private Date expireTime;}</code></pre><p>9. AppInfo</p><pre><code>@Data@NoArgsConstructor@AllArgsConstructorpublic class AppInfo { /** App id */ private String appId; /** API 祕鑰 */ private String key;}</code></pre><p>10. TokenInfo</p><pre><code>@Datapublic class TokenInfo { /** token類型: api:0 、user:1 */ private Integer tokenType; /** App 信息 */ private AppInfo appInfo; /** 用戶其他數據 */ private UserInfo userInfo;}</code></pre><p>11. UserInfo</p><pre><code>@Datapublic class UserInfo { /** 用戶名 */ private String username; /** 手機號 */ private String mobile; /** 郵箱 */ private String email; /** 密碼 */ private String password; /** 鹽 */ private String salt; private AccessToken accessToken; public UserInfo(String username, String password, String salt) { this.username = username; this.password = password; this.salt = salt; }}</code></pre><p>12. ApiCodeEnum</p><pre><code>/** * 錯誤碼code可以使用純數字,使用不同區間標識一類錯誤，也可以使用純字符，也可以使用前綴+編號 * * 錯誤碼：ERR + 編號 * * 可以使用日誌級別的前綴作為錯誤類型區分 Info(I) Error(E) Warning(W) * * 或者以業務模塊 + 錯誤號 * * TODO 錯誤碼設計 * * Alipay 用了兩個code，兩個msg(https://docs.open.alipay.com/api_1/alipay.trade.pay) * * @author Mengday Zhang * @version 1.0 * @since 2018/6/22 */public enum ApiCodeEnum { SUCCESS("10000", "success"), UNKNOW_ERROR("ERR0001","未知錯誤"), PARAMETER_ERROR("ERR0002","參數錯誤"), TOKEN_EXPIRE("ERR0003","認證過期"), REQUEST_TIMEOUT("ERR0004","請求超時"), SIGN_ERROR("ERR0005","簽名錯誤"), REPEAT_SUBMIT("ERR0006","請不要頻繁操作"), ; /** 代碼 */ private String code; /** 結果 */ private String msg; ApiCodeEnum(String code, String msg) { this.code = code; this.msg = msg; } public String getCode() { return code; } public String getMsg() { return msg; }}</code></pre><p>13. ApiResult</p><pre><code>@Data@NoArgsConstructor@AllArgsConstructorpublic class ApiResult { /** 代碼 */ private String code; /** 結果 */ private String msg;}</code></pre><p>14. ApiUtil</p><pre><code>public class ApiUtil { /** * 按參數名升續拼接參數 * @param request * @return */ public static String concatSignString(HttpServletRequest request) { Map&lt;String, String&gt; paramterMap = new HashMap&lt;&gt;(); request.getParameterMap().forEach((key, value) -&gt; paramterMap.put(key, value[0])); // 按照key升續排序，然後拼接參數 Set&lt;String&gt; keySet = paramterMap.keySet(); String[] keyArray = keySet.toArray(new String[keySet.size()]); Arrays.sort(keyArray); StringBuilder sb = new StringBuilder(); for (String k : keyArray) { // 或略掉的字段 if (k.equals("sign")) { continue; } if (paramterMap.get(k).trim().length() &gt; 0) { // 參數值為空，則不參與簽名 sb.append(k).append("=").append(paramterMap.get(k).trim()).append("&amp;"); } } return sb.toString(); } public static String concatSignString(Map&lt;String, String&gt; map) { Map&lt;String, String&gt; paramterMap = new HashMap&lt;&gt;(); map.forEach((key, value) -&gt; paramterMap.put(key, value)); // 按照key升續排序，然後拼接參數 Set&lt;String&gt; keySet = paramterMap.keySet(); String[] keyArray = keySet.toArray(new String[keySet.size()]); Arrays.sort(keyArray); StringBuilder sb = new StringBuilder(); for (String k : keyArray) { if (paramterMap.get(k).trim().length() &gt; 0) { // 參數值為空，則不參與簽名 sb.append(k).append("=").append(paramterMap.get(k).trim()).append("&amp;"); } } return sb.toString(); } /** * 獲取方法上的@NotRepeatSubmit註解 * @param handler * @return */ public static NotRepeatSubmit getNotRepeatSubmit(Object handler) { if (handler instanceof HandlerMethod) { HandlerMethod handlerMethod = (HandlerMethod) handler; Method method = handlerMethod.getMethod(); NotRepeatSubmit annotation = method.getAnnotation(NotRepeatSubmit.class); return annotation; } return null; }}</code></pre><p>15. ApiResponse</p><pre><code>@Data@Slf4jpublic class ApiResponse&lt;T&gt; { /** 結果 */ private ApiResult result; /** 數據 */ private T data; /** 簽名 */ private String sign; public static &lt;T&gt; ApiResponse success(T data) { return response(ApiCodeEnum.SUCCESS.getCode(), ApiCodeEnum.SUCCESS.getMsg(), data); } public static ApiResponse error(String code, String msg) { return response(code, msg, null); } public static &lt;T&gt; ApiResponse response(String code, String msg, T data) { ApiResult result = new ApiResult(code, msg); ApiResponse response = new ApiResponse(); response.setResult(result); response.setData(data); String sign = signData(data); response.setSign(sign); return response; } private static &lt;T&gt; String signData(T data) { // TODO 查詢key String key = "12345678954556"; Map&lt;String, String&gt; responseMap = null; try { responseMap = getFields(data); } catch (IllegalAccessException e) { return null; } String urlComponent = ApiUtil.concatSignString(responseMap); String signature = urlComponent + "key=" + key; String sign = MD5Util.encode(signature); return sign; } /** * @param data 反射的對象,獲取對象的字段名和值 * @throws IllegalArgumentException * @throws IllegalAccessException */ public static Map&lt;String, String&gt; getFields(Object data) throws IllegalAccessException, IllegalArgumentException { if (data == null) return null; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); Field[] fields = data.getClass().getDeclaredFields(); for (int i = 0; i &lt; fields.length; i++) { Field field = fields[i]; field.setAccessible(true); String name = field.getName(); Object value = field.get(data); if (field.get(data) != null) { map.put(name, value.toString()); } } return map; }}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>企業</a></li><li><a>API</a></li><li><a>設計</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/005cb496.html alt=工程勘察設計企業三維設計及大數據信息技術應用研討會在滬召開 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b17b03f7f4fe4edb89078798227816c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/005cb496.html title=工程勘察設計企業三維設計及大數據信息技術應用研討會在滬召開>工程勘察設計企業三維設計及大數據信息技術應用研討會在滬召開</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dcea13c.html alt=你在開發API時是如何設計簽名驗證的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dcea13c.html title=你在開發API時是如何設計簽名驗證的？>你在開發API時是如何設計簽名驗證的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/292d3a6.html alt=設計即溝通：企業提升設計力的10個方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/331469c2d197409392b12e27ca42d0a7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/292d3a6.html title=設計即溝通：企業提升設計力的10個方法>設計即溝通：企業提升設計力的10個方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html alt=鋼構人福利——鋼結構設計經典問題解讀 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a72bd60ea48d471b8ce03ebf0ce15869 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9bd6b239.html title=鋼構人福利——鋼結構設計經典問題解讀>鋼構人福利——鋼結構設計經典問題解讀</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html alt=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/153569494612546362474a9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bbe6ec4.html title=鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先>鋼管混凝土結構設計原理及在強震區橋樑結構研究成果達國際領先</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html alt=鋼結構設計基礎知識問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/63b48928-d7cd-4346-b80f-4f77015517c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d006e47.html title=鋼結構設計基礎知識問答>鋼結構設計基礎知識問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html alt=38個鋼結構設計問題，都很常見 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f1181ce8-cf01-4194-b9c2-362f43894ddb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0dc64d99.html title=38個鋼結構設計問題，都很常見>38個鋼結構設計問題，都很常見</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html alt=步步解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d88dd927b4f2474fbe4ea261c2397ba8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6fd930e.html title=步步解析橋樑設計計算，不可錯過的一篇乾貨>步步解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html alt=結構設計、校對、審核三字經，速速收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97b90000.html title=結構設計、校對、審核三字經，速速收藏>結構設計、校對、審核三字經，速速收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html alt=解析橋樑設計計算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa4d0bcf2a204a2fac9b37978b1b0713 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fd0540fa.html title=解析橋樑設計計算>解析橋樑設計計算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html alt=解析橋樑設計計算，不可錯過的一篇乾貨 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/af9ca7f120da4e23b0ca589375e05dd2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/83530974.html title=解析橋樑設計計算，不可錯過的一篇乾貨>解析橋樑設計計算，不可錯過的一篇乾貨</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html alt=設計師解析橋樑設計計算，錯過了就沒有機會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e01645937bda4ae7a7f148666ff89117 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e8b9b44c.html title=設計師解析橋樑設計計算，錯過了就沒有機會>設計師解析橋樑設計計算，錯過了就沒有機會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html alt=經典設計延續至今的烏尼莫克403萬能卡車 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/132ba54553374c7eb2c0a9c155bba041 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/15d8539d.html title=經典設計延續至今的烏尼莫克403萬能卡車>經典設計延續至今的烏尼莫克403萬能卡車</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69536588.html alt=線纜設計初級課程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532759411210988051a0cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69536588.html title=線纜設計初級課程>線纜設計初級課程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/928013b9.html alt=企業網站建設選擇正確的服務器，讓你省錢，網站運行良好 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/f7824718-e78c-40c3-93f8-ba9b88203ea8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/928013b9.html title=企業網站建設選擇正確的服務器，讓你省錢，網站運行良好>企業網站建設選擇正確的服務器，讓你省錢，網站運行良好</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>