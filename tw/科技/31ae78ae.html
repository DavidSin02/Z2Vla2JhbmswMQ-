<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>深入理解Java中異常體系 | 极客快訊</title><meta property="og:title" content="深入理解Java中異常體系 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a9c3c726681446dbae0fb73628403311"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/31ae78ae.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/31ae78ae.html><meta property="article:published_time" content="2020-11-14T21:06:59+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:59+08:00"><meta name=Keywords content><meta name=description content="深入理解Java中異常體系"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/31ae78ae.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>深入理解Java中異常體系</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=title-article><br></h1><p>任何程序都追求正確有效的運行，除了保證我們代碼儘可能的少出錯之外，我們還要考慮如何有效的處理異常，一個良好的異常框架對於系統來說是至關重要的。最近在給公司寫採集框架的時候系統的瞭解一邊，收穫頗多，特此記錄相關的理論。</p><p>1 .異常體系簡介：</p><p>異常是指由於各種不期而至的情況，導致程序中斷運行的一種指令流,如：文件找不到、非法參數、網絡超時等。為了保證正序正常運行，在設計程序時必須考慮到各種異常情況，並正確的對異常進行處理。異常也是一種對象，java當中定義了許多異常類，並且定義了基類java.lang.Throwable作為所有異常的超類。Java語言設計者將異常劃分為兩類：Error和Exception，其體系結構大致如下圖所示：</p><div class=pgc-img><img alt=深入理解Java中異常體系 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a9c3c726681446dbae0fb73628403311><p class=pgc-img-caption></p></div><p></p><p>Throwable：有兩個重要的子類：Exception（異常）和Error（錯誤），兩者都包含了大量的異常處理類。</p><p>1、Error（錯誤）：是程序中無法處理的錯誤，表示運行應用程序中出現了嚴重的錯誤。此類錯誤一般表示代碼運行時JVM出現問題。通常有Virtual MachineError（虛擬機運行錯誤）、NoClassDefFoundError（類定義錯誤）等。比如說當jvm耗完可用內存時，將出現OutOfMemoryError。此類錯誤發生時，JVM將終止線程。</p><p>這些錯誤是不可查的，非代碼性錯誤。因此，當此類錯誤發生時，應用不應該去處理此類錯誤。</p><p>2、Exception（異常）：程序本身可以捕獲並且可以處理的異常。</p><p><br></p><p>Exception這種異常又分為兩類：運行時異常和編譯異常。</p><p>1、運行時異常(不受檢異常)：RuntimeException類極其子類表示JVM在運行期間可能出現的錯誤。比如說試圖使用空值對象的引用（NullPointerException）、數組下標越界（ArrayIndexOutBoundException）。此類異常屬於不可查異常，一般是由程序邏輯錯誤引起的，在程序中可以選擇捕獲處理，也可以不處理。</p><p>2、編譯異常(受檢異常)：Exception中除RuntimeException極其子類之外的異常。如果程序中出現此類異常，比如說IOException，必須對該異常進行處理，否則編譯不通過。在程序中，通常不會自定義該類異常，而是直接使用系統提供的異常類。</p><p><br></p><p>可查異常與不可查異常：java的所有異常可以分為可查異常（checked exception）和不可查異常（unchecked exception）。</p><p>1、可查異常：編譯器要求必須處理的異常。正確的程序在運行過程中，經常容易出現的、符合預期的異常情況。一旦發生此類異常，就必須採用某種方式進行處理。除RuntimeException及其子類外，其他的Exception異常都屬於可查異常。編譯器會檢查此類異常，也就是說當編譯器檢查到應用中的某處可能會此類異常時，將會提示你處理本異常——要麼使用try-catch捕獲，要麼使用throws語句拋出，否則編譯不通過。</p><p>2、不可查異常：編譯器不會進行檢查並且不要求必須處理的異常，也就說當程序中出現此類異常時，即使我們沒有try-catch捕獲它，也沒有使用throws拋出該異常，編譯也會正常通過。該類異常包括運行時異常（RuntimeException極其子類）和錯誤（Error）。</p><p><br></p><p>2.異常處理流程：</p><p></p><p>在java應用中，異常的處理機制分為拋出異常和捕獲異常。</p><p>拋出異常：當一個方法出現錯誤而引發異常時，該方法會將該異常類型以及異常出現時的程序狀態信息封裝為異常對象，並交給本應用。運行時，該應用將尋找處理異常的代碼並執行。任何代碼都可以通過throw關鍵詞拋出異常，比如java源代碼拋出異常、自己編寫的代碼拋出異常等。</p><p>捕獲異常：一旦方法拋出異常，系統自動根據該異常對象尋找合適異常處理器（Exception Handler）來處理該異常。所謂合適類型的異常處理器指的是異常對象類型和異常處理器類型一致。</p><p></p><p>對於不同的異常，java採用不同的異常處理方式：</p><p>1、運行異常將由系統自動拋出，應用本身可以選擇處理或者忽略該異常。</p><p>2、對於方法中產生的Error，該異常一旦發生JVM將自行處理該異常，因此java允許應用不拋出此類異常。</p><p>3、對於所有的可查異常，必須進行捕獲或者拋出該方法之外交給上層處理。也就是當一個方法存在異常時，要麼使用try-catch捕獲，要麼使用該方法使用throws將該異常拋調用該方法的上層調用者。</p><p><br></p><p>2.1捕獲異常</p><p>1、try-catch語句</p><p><strong>try</strong> {</p><p>//可能產生的異常的代碼區，也成為監控區</p><p>}<strong>catch</strong> (ExceptionType1 e) {</p><p>//捕獲並處理try拋出異常類型為ExceptionType1的異常</p><p>}<strong>catch</strong>(ExceptionType2 e) {</p><p>//捕獲並處理try拋出異常類型為ExceptionType2的異常</p><p>}</p><p></p><p>監控區一旦發生異常，則會根據當前運行時的信息創建異常對象，並將該異常對象拋出監控區，同時</p><p>系統根據該異常對象依次匹配catch子句，若匹配成功（拋出的異常對象的類型和catch子句的異常類的類型或者是該異常類的子類的類型一致），則運行其中catch代碼塊中的異常處理代碼，一旦處理結束，那就意味著整個try-catch結束。含有多個catch子句，一旦其中一個catch子句與拋出的異常對象類型一致時，其他catch子句將不再有匹配異常對象的機會。</p><p><br></p><p>2、try-catch-finally</p><p><strong>try {</strong></p><p>//可能產生的異常的代碼區</p><p>}catch (ExceptionType1 e) {</p><p>//捕獲並處理try拋出異常類型為ExceptionType1的異常</p><p>}catch (ExceptionType2 e){</p><p>//捕獲並處理try拋出異常類型為ExceptionType2的異常</p><p>}finally{</p><p>//無論是出現異常，finally塊中的代碼都將被執行</p><p>}</p><p><br></p><p>3、try-catch-finally代碼塊的執行順序：</p><p>A)try沒有捕獲異常時，try代碼塊中的語句依次被執行，跳過catch。如果存在finally則執行finally代碼塊，否則執行後續代碼。</p><p>B）try捕獲到異常時，如果沒有與之匹配的catch子句，則該異常交給JVM處理。如果存在finally，則其中的代碼仍然被執行，但是finally之後的代碼不會被執行。</p><p>C）try捕獲到異常時，如果存在與之匹配的catch，則跳到該catch代碼塊執行處理。如果存在finally則執行finally代碼塊，執行完finally代碼塊之後繼續執行後續代碼；否則直接執行後續代碼。另外注意，try代碼塊出現異常之後的代碼不會被執行。（見下圖：）</p><p></p><div class=pgc-img><img alt=深入理解Java中異常體系 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ca0d8f52970f4e0e970c5c74a7ca2608><p class=pgc-img-caption></p></div><p>4、總結</p><p>try代碼塊：用於捕獲異常。其後可以接零個或者多個catch塊。如果沒有catch塊，後必須跟finally塊，來完成資源釋放等操作，另外建議不要在finally中使用return，不用嘗試通過catch來控制代碼流程。</p><p>catch代碼塊：用於捕獲異常，並在其中處理異常。</p><p>finally代碼塊：無論是否捕獲異常，finally代碼總會被執行。如果try代碼塊或者catch代碼塊中有return語句時，finally代碼塊將在方法返回前被執行。注意以下幾種情況，finally代碼塊不會被執行：</p><p>1、 在前邊的代碼中使用System.exit()退出應用。</p><p>2、 程序所在的線程死亡或者cpu關閉</p><p>3、 如果在finally代碼塊中的操作又產生異常，則該finally代碼塊不能完全執行結束，同時該異常會覆蓋前邊拋出的異常。</p><p><br></p><p>2.2拋出異常</p><p>1、throws拋出異常</p><p>如果一個方法可能拋出異常，但是沒有能力處理該異常或者需要通過該異常向上層彙報處理結果，可以在方法聲明時使用throws來拋出異常。這就相當於計算機硬件發生損壞，但是計算機本身無法處理，就將該異常交給維修人員來處理。</p><p>publicmethodName throws Exception1,Exception2….(params){}</p><p>其中Exception1,Exception2…為異常列表一旦該方法中某行代碼拋出異常，則該異常將由調用該方法的上層方法處理。如果上層方法無法處理，可以繼續將該異常向上層拋。</p><p>2、throw拋出異常</p><p>在方法內，用throw來拋出一個Throwable類型的異常。一旦遇到到throw語句，後面的代碼將不被執行。然後，便是進行異常處理——包含該異常的try-catch最終處理，也可以向上層拋出。注意我們只能拋出Throwable類和其子類的對象。</p><p></p><p>throw newExceptionType;</p><p></p><p>比如我們可以拋出：throw new Exception();</p><p>也有時候我們也需要在catch中拋出異常,這也是允許的，比如說：</p><p></p><p>Try{</p><p>//可能會發生異常的代碼</p><p>}catch(Exceptione){</p><p>throw newException(e);</p><p>}</p><p></p><p>3、異常關係鏈</p><p>在實際開發過程中經常在捕獲一個異常之後拋出另外一個異常，並且我們希望在新的異常對象中保存原始異常對象的信息，實際上就是異常傳遞，即把底層的異常對象傳給上層，一級一級，逐層拋出。當程序捕獲了一個底層的異常，而在catch處理異常的時候選擇將該異常拋給上層…這樣異常的原因就會逐層傳遞，形成一個由低到高的異常鏈。但是異常鏈在實際應用中一般不建議使用，同時異常鏈每次都需要就將原始的異常對象封裝為新的異常對象，消耗大量資源。現在（jdk 1.4之後）所有的Throwable的子類構造中都可以接受一個cause對象，這個cause也就是原始的異常對象。</p><p>下面是一個不錯的例子：</p><pre><code>/*</code></pre><pre><code> *高層異常</code></pre><pre><code> */</code></pre><pre><code>classHighLevelExceptionextends Exception{</code></pre><pre><code>   public HighLevelException(Throwable cause) {</code></pre><pre><code>      super(cause);</code></pre><pre><code>   }</code></pre><pre><code>}</code></pre><pre><code>/*</code></pre><pre><code> *中層異常</code></pre><pre><code> */</code></pre><pre><code>classMiddleLevelExceptionextends Exception{</code></pre><pre><code>   public MiddleLevelException(Throwable cause) {</code></pre><pre><code>      super(cause);</code></pre><pre><code>   }</code></pre><pre><code>}</code></pre><pre><code>/*</code></pre><pre><code> *底層異常</code></pre><pre><code> */</code></pre><pre><code>classLowLevelExceptionextends Exception{</code></pre><pre><code>}</code></pre><pre><code>publicclass TestException {</code></pre><pre><code> </code></pre><pre><code>   publicvoid highLevelAccess()throws HighLevelException{</code></pre><pre><code>      try {</code></pre><pre><code>          middleLevelAccess();</code></pre><pre><code>      }catch (Exception e) {</code></pre><pre><code>          thrownew HighLevelException(e);</code></pre><pre><code>      }</code></pre><pre><code>   }</code></pre><pre><code>   </code></pre><pre><code>   publicvoid middleLevelAccess()throws MiddleLevelException{</code></pre><pre><code>      try {</code></pre><pre><code>          lowLevelAccess();</code></pre><pre><code>      }catch (Exception e) {</code></pre><pre><code>          thrownew MiddleLevelException(e);</code></pre><pre><code>      }</code></pre><pre><code>   }</code></pre><pre><code> </code></pre><pre><code>   publicvoid lowLevelAccess()throws LowLevelException {</code></pre><pre><code>      thrownew LowLevelException();</code></pre><pre><code>   }</code></pre><pre><code> </code></pre><pre><code>   publicstaticvoid main(String[] args) {</code></pre><pre><code>      /*</code></pre><pre><code>       * lowlevelAccess()將異常對象拋給middleLevelAccess()，而</code></pre><pre><code>       * middleLevelAccess()又將異常對象拋給highLevelAccess(),</code></pre><pre><code>       *也就是底層的異常對象一層層傳遞給高層。最終在在高層可以獲得底層的異常對象。</code></pre><pre><code>       */</code></pre><pre><code>      try {</code></pre><pre><code>          new TestException().highLevelAccess();</code></pre><pre><code>      }catch (HighLevelException e) {</code></pre><pre><code>          e.printStackTrace();</code></pre><pre><code>          System.out.println(e.getCause());</code></pre><pre><code>      }</code></pre><pre><code>   }</code></pre><pre><code>}</code></pre><p><br></p><p>4、異常轉譯</p><p>異常轉義就是將一種類型的異常轉成另一種類型的異常，然後再拋出異常。之所以要進行轉譯，是為了更準確的描述異常。就我個人而言，我更喜歡稱之為異常類型轉換。在實際應用中，為了構建自己的日誌系統，經常需要把系統的一些異常信息描述成我們想要的異常信息，就可以使用異常轉譯。異常轉譯針對所有Throwable類的子類而言，其子類型都可以相互轉換。</p><p>通常而言，更為合理的轉換方式是：</p><p>1、 Error——>Exception</p><p>2、 Error——>RuntimeException</p><p>3、 Exception——>RuntimeException,</p><p>在下面的代碼中，我們自定義了MyException異常類，然後我們將IOException類型的異常轉為MyException類型的異常，最後拋出。</p><pre><code>class MyExceptionextends Exception {</code></pre><pre><code>   public MyException(String msg, Throwable e) {</code></pre><pre><code>      super(msg, e);</code></pre><pre><code>   }</code></pre><pre><code>}</code></pre><pre><code> </code></pre><pre><code>publicclass Demo {</code></pre><pre><code>   publicstaticvoid main(String[] args)throws MyException {</code></pre><pre><code>      Filefile =new File("H:/test.txt");</code></pre><pre><code>      if (file.exists())</code></pre><pre><code>          try {</code></pre><pre><code>             file.createNewFile();</code></pre><pre><code>          }catch (IOException e) {</code></pre><pre><code>             thrownew MyException("文件創建失敗！", e);</code></pre><pre><code>          }</code></pre><pre><code>   }</code></pre><pre><code> </code></pre><pre><code>}</code></pre><p>5、Throwable類中常用的方法</p><p>像catch(Exception e)中的Exception就是異常的變量類型，e則是形參。通常在進行異常輸出時有如下幾個方法可用：</p><p>e.getCause():返回拋出異常的原因。</p><p>e.getMessage():返回異常信息。</p><p>e.printStackTrace():發生異常時，跟蹤堆棧信息並輸出。</p><p><br></p><p>6、 常異總結</p><p>此部分可以api文檔中進行查閱，這裡僅做參考。</p><p>常見異常：</p><p>java.lang.IllegalAccessError：違法訪問錯誤。當一個應用試圖訪問、修改某個類的域（Field）或者調用其方法，但是又違反域或方法的可見性聲明，則拋出該異常。</p><p>java.lang.InstantiationError：實例化錯誤。當一個應用試圖通過Java的new操作符構造一個抽象類或者接口時拋出該異常.</p><p>java.lang.OutOfMemoryError：內存不足錯誤。當可用內存不足以讓Java虛擬機分配給一個對象時拋出該錯誤。java.lang.StackOverflowError：堆棧溢出錯誤。當一個應用遞歸調用的層次太深而導致堆棧溢出或者陷入死循環時拋出該錯誤。</p><p>java.lang.ClassCastException：類造型異常。假設有類A和B（A不是B的父類或子類），O是A的實例，那麼當強制將O構造為類B的實例時拋出該異常。該異常經常被稱為強制類型轉換異常。java.lang.ClassNotFoundException：找不到類異常。當應用試圖根據字符串形式的類名構造類，而在遍歷CLASSPAH之後找不到對應名稱的class文件時，拋出該異常。</p><p>java.lang.ArithmeticException：算術條件異常。譬如：整數除零等。java.lang.ArrayIndexOutOfBoundsException：數組索引越界異常。當對數組的索引值為負數或大於等於數組大小時拋出。</p><p>java.lang.IndexOutOfBoundsException：索引越界異常。當訪問某個序列的索引值小於0或大於等於序列大小時，拋出該異常。java.lang.InstantiationException：實例化異常。當試圖通過newInstance()方法創建某個類的實例，而該類是一個抽象類或接口時，拋出該異常。</p><p>java.lang.NoSuchFieldException：屬性不存在異常。當訪問某個類的不存在的屬性時拋出該異常。java.lang.NoSuchMethodException：方法不存在異常。當訪問某個類的不存在的方法時拋出該異常。java.lang.NullPointerException：空指針異常。當應用試圖在要求使用對象的地方使用了null時，拋出該異常。譬如：調用null對象的實例方法、訪問null對象的屬性、計算null對象的長度、使用throw語句拋出null等等。java.lang.NumberFormatException：數字格式異常。當試圖將一個String轉換為指定的數字類型，而該字符串確不滿足數字類型要求的格式時，拋出該異常。</p><p>java.lang.StringIndexOutOfBoundsException：字符串索引越界異常。當使用索引值訪問某個字符串中的字符，而該索引值小於0或大於等於序列大小時，拋出該異常。</p><p>其他異常：java.lang.AbstractMethodError：抽象方法錯誤。當應用試圖調用抽象方法時拋出。java.lang.AssertionError：斷言錯。用來指示一個斷言失敗的情況。java.lang.ClassCircularityError：類循環依賴錯誤。在初始化一個類時，若檢測到類之間循環依賴則拋出該異常。java.lang.ClassFormatError：類格式錯誤。當Java虛擬機試圖從一個文件中讀取Java類，而檢測到該文件的內容不符合類的有效格式時拋出。java.lang.Error：錯誤。是所有錯誤的基類，用於標識嚴重的程序運行問題。這些問題通常描述一些不應被應用程序捕獲的反常情況。java.lang.ExceptionInInitializerError：初始化程序錯誤。當執行一個類的靜態初始化程序的過程中，發生了異常時拋出。靜態初始化程序是指直接包含於類中的static語句段。java.lang.IncompatibleClassChangeError：不兼容的類變化錯誤。當正在執行的方法所依賴的類定義發生了不兼容的改變時，拋出該異常。一般在修改了應用中的某些類的聲明定義而沒有對整個應用重新編譯而直接運行的情況下，容易引發該錯誤。java.lang.InternalError：內部錯誤。用於指示Java虛擬機發生了內部錯誤。java.lang.LinkageError：鏈接錯誤。該錯誤及其所有子類指示某個類依賴於另外一些類，在該類編譯之後，被依賴的類改變了其類定義而沒有重新編譯所有的類，進而引發錯誤的情況。java.lang.NoClassDefFoundError：未找到類定義錯誤。當Java虛擬機或者類裝載器試圖實例化某個類，而找不到該類的定義時拋出該錯誤。java.lang.NoSuchFieldError：域不存在錯誤。當應用試圖訪問或者修改某類的某個域，而該類的定義中沒有該域的定義時拋出該錯誤。java.lang.NoSuchMethodError：方法不存在錯誤。當應用試圖調用某類的某個方法，而該類的定義中沒有該方法的定義時拋出該錯誤。java.lang.ThreadDeath：線程結束。當調用Thread類的stop方法時拋出該錯誤，用於指示線程結束。java.lang.UnknownError：未知錯誤。用於指示Java虛擬機發生了未知嚴重錯誤的情況。java.lang.UnsatisfiedLinkError：未滿足的鏈接錯誤。當Java虛擬機未找到某個類的聲明為native方法的本機語言定義時拋出。java.lang.UnsupportedClassVersionError：不支持的類版本錯誤。當Java虛擬機試圖從讀取某個類文件，但是發現該文件的主、次版本號不被當前Java虛擬機支持的時候，拋出該錯誤。java.lang.VerifyError：驗證錯誤。當驗證器檢測到某個類文件中存在內部不兼容或者安全問題時拋出該錯誤。java.lang.VirtualMachineError：虛擬機錯誤。用於指示虛擬機被破壞或者繼續執行操作所需的資源不足的情況。java.lang.ArrayStoreException：數組存儲異常。當向數組中存放非數組聲明類型對象時拋出。java.lang.CloneNotSupportedException：不支持克隆異常。當沒有實現Cloneable接口或者不支持克隆方法時,調用其clone()方法則拋出該異常。java.lang.EnumConstantNotPresentException：枚舉常量不存在異常。當應用試圖通過名稱和枚舉類型訪問一個枚舉對象，但該枚舉對象並不包含常量時，拋出該異常。java.lang.Exception：根異常。用以描述應用程序希望捕獲的情況。java.lang.IllegalAccessException：違法的訪問異常。當應用試圖通過反射方式創建某個類的實例、訪問該類屬性、調用該類方法，而當時又無法訪問類的、屬性的、方法的或構造方法的定義時拋出該異常。java.lang.IllegalMonitorStateException：違法的監控狀態異常。當某個線程試圖等待一個自己並不擁有的對象（O）的監控器或者通知其他線程等待該對象（O）的監控器時，拋出該異常。java.lang.IllegalStateException：違法的狀態異常。當在Java環境和應用尚未處於某個方法的合法調用狀態，而調用了該方法時，拋出該異常。java.lang.IllegalThreadStateException：違法的線程狀態異常。當縣城尚未處於某個方法的合法調用狀態，而調用了該方法時，拋出異常。java.lang.InterruptedException：被中止異常。當某個線程處於長時間的等待、休眠或其他暫停狀態，而此時其他的線程通過Thread的interrupt方法終止該線程時拋出該異常。java.lang.NegativeArraySizeException：數組大小為負值異常。當使用負數大小值創建數組時拋出該異常。java.lang.SecurityException：安全異常。由安全管理器拋出，用於指示違反安全情況的異常。java.lang.TypeNotPresentException：類型不存在異常。</p><p>點點關注</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>中異常</a></li><li><a>體系</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d723cf84.html alt=環境管理體系程序文件-應急準備和響應控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e835a7cac68e47ebbee5941a3c948385 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d723cf84.html title=環境管理體系程序文件-應急準備和響應控制程序>環境管理體系程序文件-應急準備和響應控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/438a5238.html alt=環境管理體系程序文件-文件控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/aaa460951e4e4b358966a6652c1d361f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/438a5238.html title=環境管理體系程序文件-文件控制程序>環境管理體系程序文件-文件控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb498ffa.html alt=環境管理體系程序文件-法律、法規和其他要求控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb498ffa.html title=環境管理體系程序文件-法律、法規和其他要求控制程序>環境管理體系程序文件-法律、法規和其他要求控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/41573419.html alt=環境管理體系程序文件-環境因素識別、評價和更新控制程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f40c901375e84f77ab169e70fc093f86 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/41573419.html title=環境管理體系程序文件-環境因素識別、評價和更新控制程序>環境管理體系程序文件-環境因素識別、評價和更新控制程序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc318d23.html alt=環境管理體系程序文件-組織環境與相關方要求管理程序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc318d23.html title=環境管理體系程序文件-組織環境與相關方要求管理程序>環境管理體系程序文件-組織環境與相關方要求管理程序</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>