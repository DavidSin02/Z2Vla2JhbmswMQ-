<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Go發起HTTP2.0請求流程分析(中篇)——數據幀&流控制 | 极客快訊</title><meta property="og:title" content="Go發起HTTP2.0請求流程分析(中篇)——數據幀&流控制 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/ca343b56966046c6b646b9debecaf505"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/33bf159.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/33bf159.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/33bf159.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/33bf159.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/33bf159.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/33bf159.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/33bf159.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/33bf159.html><meta property="article:published_time" content="2020-10-29T21:06:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:06:37+08:00"><meta name=Keywords content><meta name=description content="Go發起HTTP2.0請求流程分析(中篇)——數據幀&流控制"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/33bf159.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Go發起HTTP2.0請求流程分析(中篇)——數據幀&流控制</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote class=pgc-blockquote-abstract><p>來自公眾號：新世界雜貨鋪</p></blockquote><h1 class=pgc-h-arrow-right>閱讀建議</h1><p style=text-align:start>這是HTTP2.0系列的第二篇，所以筆者推薦閱讀順序如下:</p><ol start=1><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6882255113369420299/?group_id=6882255113369420299" rel="noopener noreferrer" target=_blank>Go中的HTTP請求之——HTTP1.1請求流程分析</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6875967557174559244/?group_id=6875967557174559244" rel="noopener noreferrer" target=_blank>Go發起HTTP2.0請求流程分析(前篇)</a></li></ol><p style=text-align:start>本篇主要分為三個部分：數據幀，流控制器以及通過分析源碼逐步瞭解流控制。</p><p style=text-align:start>本有意將這三個部分拆成三篇文章，但它們之間又有聯繫，所以最後依舊決定放在一篇文章裡面。由於內容較多，筆者認為分三次分別閱讀三個部分較佳。</p><h1 class=pgc-h-arrow-right>數據幀</h1><p style=text-align:start>HTTP2通信的最小單位是數據幀，每一個幀都包含兩部分：<strong>幀頭</strong>和<strong>Payload</strong>。不同數據流的幀可以交錯發送(同一個數據流的幀必須順序發送)，然後再根據每個幀頭的數據流標識符重新組裝。</p><p style=text-align:start>由於Payload中為有效數據，故僅對幀頭進行分析描述。</p><h1 class=pgc-h-arrow-right>幀頭</h1><p style=text-align:start><strong>幀頭總長度為9個字節</strong>，幷包含四個部分，分別是：</p><ol start=1><li>Payload的長度，佔用三個字節。</li><li>數據幀類型，佔用一個字節。</li><li>數據幀標識符，佔用一個字節。</li><li>數據流ID，佔用四個字節。</li></ol><p style=text-align:start>用圖表示如下：</p><div class=pgc-img><img alt=Go發起HTTP2.0請求流程分析(中篇)——數據幀&流控制 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/ca343b56966046c6b646b9debecaf505><p class=pgc-img-caption></p></div><p style=text-align:start>數據幀的格式和各部分的含義已經清楚了， 那麼我們看看代碼中怎麼讀取一個幀頭：</p><pre><code>func http2readFrameHeader(buf []byte, r io.Reader) (http2FrameHeader, error) {	_, err := io.ReadFull(r, buf[:http2frameHeaderLen])	if err != nil {		return http2FrameHeader{}, err	}	return http2FrameHeader{		Length:   (uint32(buf[0])&lt;&lt;16 | uint32(buf[1])&lt;&lt;8 | uint32(buf[2])),		Type:     http2FrameType(buf[3]),		Flags:    http2Flags(buf[4]),		StreamID: binary.BigEndian.Uint32(buf[5:]) &amp; (1&lt;&lt;31 - 1),		valid:    true,	}, nil}</code></pre><p style=text-align:start>在上面的代碼中http2frameHeaderLen是一個常量，其值為9。</p><p style=text-align:start>從io.Reader中讀取9個字節後，將前三個字節和後四個字節均轉為uint32的類型，從而得到Payload長度和數據流ID。另外需要理解的是幀頭的前三個字節和後四個字節存儲格式為大端（大小端筆者就不在這裡解釋了，請尚不瞭解的讀者自行百度）。</p><h1 class=pgc-h-arrow-right>數據幀類型</h1><p style=text-align:start>根據http://http2.github.io/http2-spec/#rfc.section.11.2描述，數據幀類型總共有10個。在go源碼中均有體現：</p><pre><code>const (	http2FrameData         http2FrameType = 0x0	http2FrameHeaders      http2FrameType = 0x1	http2FramePriority     http2FrameType = 0x2	http2FrameRSTStream    http2FrameType = 0x3	http2FrameSettings     http2FrameType = 0x4	http2FramePushPromise  http2FrameType = 0x5	http2FramePing         http2FrameType = 0x6	http2FrameGoAway       http2FrameType = 0x7	http2FrameWindowUpdate http2FrameType = 0x8	http2FrameContinuation http2FrameType = 0x9)</code></pre><p style=text-align:start>http2FrameData：主要用於發送請求body和接收響應的數據幀。</p><p style=text-align:start>http2FrameHeaders：主要用於發送請求header和接收響應header的數據幀。</p><p style=text-align:start>http2FrameSettings：主要用於client和server交流設置相關的數據幀。</p><p style=text-align:start>http2FrameWindowUpdate：主要用於流控制的數據幀。</p><p style=text-align:start>其他數據幀類型因為本文不涉及，故不做描述。</p><h1 class=pgc-h-arrow-right>數據幀標識符</h1><p style=text-align:start>由於數據幀標識符種類較多，筆者在這裡僅介紹其中部分標識符，先看源碼：</p><pre><code>const (	// Data Frame	http2FlagDataEndStream http2Flags = 0x1    // Headers Frame	http2FlagHeadersEndStream  http2Flags = 0x1    // Settings Frame	http2FlagSettingsAck http2Flags = 0x1	// 此處省略定義其他數據幀標識符的代碼)</code></pre><p style=text-align:start>http2FlagDataEndStream：在前篇中提到，調用(*http2ClientConn).newStream方法會創建一個數據流，那這個數據流什麼時候結束呢，這就是http2FlagDataEndStream的作用。</p><p style=text-align:start>當client收到有響應body的響應時（HEAD請求無響應body，301，302等響應也無響應body），一直讀到http2FrameData數據幀的標識符為http2FlagDataEndStream則意味著本次請求結束可以關閉當前數據流。</p><p style=text-align:start>http2FlagHeadersEndStream：如果讀到的http2FrameHeaders數據幀有此標識符也意味著本次請求結束。</p><p style=text-align:start>http2FlagSettingsAck：該標示符意味著對方確認收到http2FrameSettings數據幀。</p><h1 class=pgc-h-arrow-right>流控制器</h1><p style=text-align:start>流控制是一種阻止發送方向接收方發送大量數據的機制，以免超出後者的需求或處理能力。Go中HTTP2通過http2flow結構體進行流控制：</p><pre><code>type http2flow struct {	// n is the number of DATA bytes we're allowed to send.	// A flow is kept both on a conn and a per-stream.	n int32	// conn points to the shared connection-level flow that is	// shared by all streams on that conn. It is nil for the flow	// that's on the conn directly.	conn *http2flow}</code></pre><p style=text-align:start>字段含義英文註釋已經描述的很清楚了，所以筆者不再翻譯。下面看一下和流控制有關的方法。</p><h1 class=pgc-h-arrow-right>(*http2flow).available</h1><p style=text-align:start>此方法返回當前流控制可發送的最大字節數：</p><pre><code>func (f *http2flow) available() int32 {	n := f.n	if f.conn != nil &amp;&amp; f.conn.n &lt; n {		n = f.conn.n	}	return n}</code></pre><ul><li>如果f.conn為nil則意味著此控制器的控制級別為連接，那麼可發送的最大字節數就是f.n。</li><li>如果f.conn不為nil則意味著此控制器的控制級別為數據流，且當前數據流可發送的最大字節數不能超過當前連接可發送的最大字節數。</li></ul><h1 class=pgc-h-arrow-right>(*http2flow).take</h1><p style=text-align:start>此方法用於消耗當前流控制器的可發送字節數：</p><pre><code>func (f *http2flow) take(n int32) {	if n &gt; f.available() {		panic("internal error: took too much")	}	f.n -= n	if f.conn != nil {		f.conn.n -= n	}}</code></pre><p style=text-align:start>通過實際需要傳遞一個參數，告知當前流控制器想要發送的數據大小。如果發送的大小超過流控制器允許的大小，則panic，如果未超過流控制器允許的大小，則將當前數據流和當前連接的可發送字節數-n。</p><h1 class=pgc-h-arrow-right>(*http2flow).add</h1><p style=text-align:start>有消耗就有新增，此方法用於增加流控制器可發送的最大字節數：</p><pre><code>func (f *http2flow) add(n int32) bool {	sum := f.n + n	if (sum &gt; n) == (f.n &gt; 0) {		f.n = sum		return true	}	return false}</code></pre><p style=text-align:start>上面的代碼唯一需要注意的地方是，當sum超過int32正數最大值(2^31-1)時會返回false。</p><p style=text-align:start><strong>回顧</strong>：在前篇中提到的(*http2Transport).NewClientConn方法和(*http2ClientConn).newStream方法均通過(*http2flow).add初始化可發送數據窗口大小。</p><p style=text-align:start>有了幀和流控制器的基本概念，下面我們結合源碼來分析總結流控制的具體實現。</p><h1 class=pgc-h-arrow-right>(*http2ClientConn).readLoop</h1><p style=text-align:start>前篇分析(*http2Transport).newClientConn時止步於讀循環，那麼今天我們就從(*http2ClientConn).readLoop開始。</p><pre><code>func (cc *http2ClientConn) readLoop() {	rl := &amp;http2clientConnReadLoop{cc: cc}	defer rl.cleanup()	cc.readerErr = rl.run()	if ce, ok := cc.readerErr.(http2ConnectionError); ok {		cc.wmu.Lock()		cc.fr.WriteGoAway(0, http2ErrCode(ce), nil)		cc.wmu.Unlock()	}}</code></pre><p style=text-align:start>由上可知，readLoop的邏輯比較簡單，其核心邏輯在(*http2clientConnReadLoop).run方法裡。</p><pre><code>func (rl *http2clientConnReadLoop) run() error {	cc := rl.cc	rl.closeWhenIdle = cc.t.disableKeepAlives() || cc.singleUse	gotReply := false // ever saw a HEADERS reply	gotSettings := false	for {		f, err := cc.fr.ReadFrame()    // 此處省略代碼		maybeIdle := false // whether frame might transition us to idle		switch f := f.(type) {		case *http2MetaHeadersFrame:			err = rl.processHeaders(f)			maybeIdle = true			gotReply = true		case *http2DataFrame:			err = rl.processData(f)			maybeIdle = true		case *http2GoAwayFrame:			err = rl.processGoAway(f)			maybeIdle = true		case *http2RSTStreamFrame:			err = rl.processResetStream(f)			maybeIdle = true		case *http2SettingsFrame:			err = rl.processSettings(f)		case *http2PushPromiseFrame:			err = rl.processPushPromise(f)		case *http2WindowUpdateFrame:			err = rl.processWindowUpdate(f)		case *http2PingFrame:			err = rl.processPing(f)		default:			cc.logf("Transport: unhandled response frame type %T", f)		}		if err != nil {			if http2VerboseLogs {				cc.vlogf("http2: Transport conn %p received error from processing frame %v: %v", cc, http2summarizeFrame(f), err)			}			return err		}		if rl.closeWhenIdle &amp;&amp; gotReply &amp;&amp; maybeIdle {			cc.closeIfIdle()		}	}}</code></pre><p style=text-align:start>由上可知，(*http2clientConnReadLoop).run的核心邏輯是讀取數據幀然後對不同的數據幀進行不同的處理。</p><p style=text-align:start>cc.fr.ReadFrame()會根據前面介紹的數據幀格式讀出數據幀。</p><p style=text-align:start>前篇中提到使用了一個支持h2協議的圖片進行分析，本篇繼續複用該圖片對(*http2clientConnReadLoop).run方法進行debug。</p><h1 class=pgc-h-arrow-right>收到http2FrameSettings數據幀</h1><p style=text-align:start>讀循環會最先讀到http2FrameSettings數據幀。讀到該數據幀後會調用(*http2clientConnReadLoop).processSettings方法。(*http2clientConnReadLoop).processSettings主要包含3個邏輯。</p><p style=text-align:start>1、判斷是否是http2FrameSettings的ack信息，如果是直接返回，否則繼續後面的步驟。</p><pre><code>if f.IsAck() {  if cc.wantSettingsAck {    cc.wantSettingsAck = false    return nil  }  return http2ConnectionError(http2ErrCodeProtocol)}</code></pre><p style=text-align:start>2、處理不同http2FrameSettings的數據幀，並根據server傳遞的信息，修改maxConcurrentStreams等的值。</p><pre><code>err := f.ForeachSetting(func(s http2Setting) error {  switch s.ID {    case http2SettingMaxFrameSize:    cc.maxFrameSize = s.Val    case http2SettingMaxConcurrentStreams:    cc.maxConcurrentStreams = s.Val    case http2SettingMaxHeaderListSize:    cc.peerMaxHeaderListSize = uint64(s.Val)    case http2SettingInitialWindowSize:    if s.Val &gt; math.MaxInt32 {      return http2ConnectionError(http2ErrCodeFlowControl)    }    delta := int32(s.Val) - int32(cc.initialWindowSize)    for _, cs := range cc.streams {      cs.flow.add(delta)    }    cc.cond.Broadcast()    cc.initialWindowSize = s.Val    default:    // TODO(bradfitz): handle more settings? SETTINGS_HEADER_TABLE_SIZE probably.    cc.vlogf("Unhandled Setting: %v", s)  }  return nil})</code></pre><p style=text-align:start>當收到ID為http2SettingInitialWindowSize的幀時，會調整當前連接中所有數據流的可發送數據窗口大小，並修改當前連接的initialWindowSize（每個新創建的數據流均會使用該值初始化可發送數據窗口大小）為s.Val。</p><p style=text-align:start>3、發送http2FrameSettings的ack信息給server。</p><pre><code>	cc.wmu.Lock()	defer cc.wmu.Unlock()	cc.fr.WriteSettingsAck()	cc.bw.Flush()	return cc.werr</code></pre><h1 class=pgc-h-arrow-right>收到http2WindowUpdateFrame數據幀</h1><p style=text-align:start>在筆者debug的過程中，處理完http2FrameSettings數據幀後，緊接著就收到了http2WindowUpdateFrame數據幀。收到該數據幀後會調用(*http2clientConnReadLoop).processWindowUpdate方法：</p><pre><code>func (rl *http2clientConnReadLoop) processWindowUpdate(f *http2WindowUpdateFrame) error {	cc := rl.cc	cs := cc.streamByID(f.StreamID, false)	if f.StreamID != 0 &amp;&amp; cs == nil {		return nil	}	cc.mu.Lock()	defer cc.mu.Unlock()	fl := &amp;cc.flow	if cs != nil {		fl = &amp;cs.flow	}	if !fl.add(int32(f.Increment)) {		return http2ConnectionError(http2ErrCodeFlowControl)	}	cc.cond.Broadcast()	return nil}</code></pre><p style=text-align:start>上面的邏輯主要用於更新當前連接和數據流的可發送數據窗口大小。如果http2WindowUpdateFrame幀中的StreamID為0，則更新當前連接的可發送數據窗口大小，否則更新對應數據流可發送數據窗口大小。</p><p style=text-align:start><strong>注意</strong>：在debug的過程，收到http2WindowUpdateFrame數據幀後，又收到一次http2FrameSettings，且該數據幀標識符為http2FlagSettingsAck。</p><p style=text-align:start>筆者在這裡特意提醒，這是因為前篇中提到的(*http2Transport).NewClientConn方法，也向server發送了http2FrameSettings數據幀和http2WindowUpdateFrame數據幀。</p><p style=text-align:start>另外，在處理http2FrameSettings和http2WindowUpdateFrame過程中，均出現了cc.cond.Broadcast()調用，該調用主要用於喚醒因為以下兩種情況而Wait的請求：</p><ol start=1><li>因當前連接處理的數據流已經達到maxConcurrentStreams的上限（詳見前篇中(*http2ClientConn).awaitOpenSlotForRequest方法分析）。</li><li>因發送數據流已達可發送數據窗口上限而等待可發送數據窗口更新的請求（後續會介紹）。</li></ol><h1 class=pgc-h-arrow-right>收到http2MetaHeadersFrame數據幀</h1><p style=text-align:start>收到此數據幀意味著某一個請求已經開始接收響應數據。此數據幀對應的處理函數為(*http2clientConnReadLoop).processHeaders：</p><pre><code>func (rl *http2clientConnReadLoop) processHeaders(f *http2MetaHeadersFrame) error {	cc := rl.cc	cs := cc.streamByID(f.StreamID, false)	// 此處省略代碼	res, err := rl.handleResponse(cs, f)	if err != nil {		// 此處省略代碼		cs.resc &lt;- http2resAndError{err: err}		return nil // return nil from process* funcs to keep conn alive	}	if res == nil {		// (nil, nil) special case. See handleResponse docs.		return nil	}	cs.resTrailer = &amp;res.Trailer	cs.resc &lt;- http2resAndError{res: res}	return nil}</code></pre><p style=text-align:start>首先我們先看cs.resc &lt;- http2resAndError{res: res}這一行代碼，向數據流寫入http2resAndError即本次請求的響應。在(*http2ClientConn).roundTrip方法中有這樣一行代碼readLoopResCh := cs.resc。</p><p style=text-align:start><strong>回顧</strong>：前篇(*http2ClientConn).roundTrip方法的第7點和本部分關聯起來就可以形成一個完整的請求鏈。</p><p style=text-align:start>接下來我們對rl.handleResponse方法展開分析。</p><h1 class=pgc-h-arrow-right>(*http2clientConnReadLoop).handleResponse</h1><p style=text-align:start>(*http2clientConnReadLoop).handleResponse的主要作用是構建一個Response變量，下面對該函數的關鍵步驟進行描述。</p><p style=text-align:start>1、構建一個Response變量。</p><pre><code>header := make(Header)res := &amp;Response{  Proto:      "HTTP/2.0",  ProtoMajor: 2,  Header:     header,  StatusCode: statusCode,  Status:     status + " " + StatusText(statusCode),}</code></pre><p style=text-align:start>2、構建header（本篇不對header進行展開分析）。</p><pre><code>for _, hf := range f.RegularFields() {  key := CanonicalHeaderKey(hf.Name)  if key == "Trailer" {    t := res.Trailer    if t == nil {      t = make(Header)      res.Trailer = t    }    http2foreachHeaderElement(hf.Value, func(v string) {      t[CanonicalHeaderKey(v)] = nil    })  } else {    header[key] = append(header[key], hf.Value)  }}</code></pre><p style=text-align:start>3、處理響應body的ContentLength。</p><pre><code>streamEnded := f.StreamEnded()isHead := cs.req.Method == "HEAD"if !streamEnded || isHead {  res.ContentLength = -1  if clens := res.Header["Content-Length"]; len(clens) == 1 {    if clen64, err := strconv.ParseInt(clens[0], 10, 64); err == nil {      res.ContentLength = clen64    } else {      // TODO: care? unlike http/1, it won't mess up our framing, so it's      // more safe smuggling-wise to ignore.    }  } else if len(clens) &gt; 1 {    // TODO: care? unlike http/1, it won't mess up our framing, so it's    // more safe smuggling-wise to ignore.  }}</code></pre><p style=text-align:start>由上可知，當前數據流沒有結束或者是HEAD請求才讀取ContentLength。如果header中的ContentLength不合法則res.ContentLength的值為 <strong>-1</strong>。</p><p style=text-align:start>4、構建res.Body。</p><pre><code>cs.bufPipe = http2pipe{b: &amp;http2dataBuffer{expected: res.ContentLength}}cs.bytesRemain = res.ContentLengthres.Body = http2transportResponseBody{cs}go cs.awaitRequestCancel(cs.req)if cs.requestedGzip &amp;&amp; res.Header.Get("Content-Encoding") == "gzip" {  res.Header.Del("Content-Encoding")  res.Header.Del("Content-Length")  res.ContentLength = -1  res.Body = &amp;http2gzipReader{body: res.Body}  res.Uncompressed = true}</code></pre><p style=text-align:start>根據Content-Encoding的編碼方式，會構建兩種不同的Body：</p><ol start=1><li>非gzip編碼時，構造的res.Body類型為http2transportResponseBody。</li><li>gzip編碼時，構造的res.Body類型為http2gzipReader。</li></ol><h1 class=pgc-h-arrow-right>收到http2DataFrame數據幀</h1><p style=text-align:start>收到此數據幀意味著我們開始接收真實的響應，即平常開發中需要處理的業務數據。此數據幀對應的處理函數為(*http2clientConnReadLoop).processData。</p><p style=text-align:start>因為server無法及時知道數據流在client端的狀態，所以server可能會向client中一個已經不存在的數據流發送數據：</p><pre><code>cc := rl.cccs := cc.streamByID(f.StreamID, f.StreamEnded())data := f.Data()if cs == nil {  cc.mu.Lock()  neverSent := cc.nextStreamID  cc.mu.Unlock() // 此處省略代碼  if f.Length &gt; 0 {    cc.mu.Lock()    cc.inflow.add(int32(f.Length))    cc.mu.Unlock()    cc.wmu.Lock()    cc.fr.WriteWindowUpdate(0, uint32(f.Length))    cc.bw.Flush()    cc.wmu.Unlock()  }  return nil}</code></pre><p style=text-align:start>接收到的數據幀在client沒有對應的數據流處理時，通過流控制器為當前連接可讀窗口大小增加f.Length，並且通過http2FrameWindowUpdate數據幀告知server將當前連接的可寫窗口大小增加f.Length。</p><p style=text-align:start>如果client有對應的數據流且f.Length大於0：</p><p style=text-align:start>1、如果是head請求結束當前數據流並返回。</p><pre><code>if cs.req.Method == "HEAD" &amp;&amp; len(data) &gt; 0 {  cc.logf("protocol error: received DATA on a HEAD request")  rl.endStreamError(cs, http2StreamError{    StreamID: f.StreamID,    Code:     http2ErrCodeProtocol,  })  return nil}</code></pre><p style=text-align:start>2、檢查當前數據流能否處理f.Length長度的數據。</p><pre><code>cc.mu.Lock()if cs.inflow.available() &gt;= int32(f.Length) {  cs.inflow.take(int32(f.Length))} else {  cc.mu.Unlock()  return http2ConnectionError(http2ErrCodeFlowControl)}</code></pre><p style=text-align:start>由上可知當前數據流如果能夠處理該數據，通過流控制器調用cs.inflow.take減小當前數據流可接受窗口大小。</p><p style=text-align:start>3、當前數據流被重置或者被關閉即cs.didReset為true時又或者數據幀有填充數據時需要調整流控制窗口。</p><pre><code>var refund intif pad := int(f.Length) - len(data); pad &gt; 0 {  refund += pad}// Return len(data) now if the stream is already closed,// since data will never be read.didReset := cs.didResetif didReset {  refund += len(data)}if refund &gt; 0 {  cc.inflow.add(int32(refund))  cc.wmu.Lock()  cc.fr.WriteWindowUpdate(0, uint32(refund))  if !didReset {    cs.inflow.add(int32(refund))    cc.fr.WriteWindowUpdate(cs.ID, uint32(refund))  }  cc.bw.Flush()  cc.wmu.Unlock()}cc.mu.Unlock()</code></pre><ul><li>如果數據幀有填充數據則計算需要返還的填充數據長度。</li><li>如果數據流無效該數據幀的長度需要全部返還。</li></ul><p style=text-align:start>最後，根據計算的refund增加當前連接或者當前數據流的可接受窗口大小，並且同時告知server增加當前連接或者當前數據流的可寫窗口大小。</p><p style=text-align:start>4、數據長度大於0且數據流正常則將數據寫入數據流緩衝區。</p><pre><code>if len(data) &gt; 0 &amp;&amp; !didReset {  if _, err := cs.bufPipe.Write(data); err != nil {    rl.endStreamError(cs, err)    return err  }}</code></pre><p style=text-align:start><strong>回顧</strong>：前面的(*http2clientConnReadLoop).handleResponse方法中有這樣一行代碼res.Body = http2transportResponseBody{cs}，所以在業務開發時能夠通過Response讀取到數據流中的緩衝數據。</p><h1 class=pgc-h-arrow-right>(http2transportResponseBody).Read</h1><p style=text-align:start>在前面的內容裡，如果數據流狀態正常且數據幀沒有填充數據則數據流和連接的可接收窗口會一直變小，而這部分內容就是增加數據流的可接受窗口大小。</p><p style=text-align:start>因為篇幅和主旨的問題筆者僅分析描述該方法內和流控制有關的部分。</p><p style=text-align:start>1、讀取響應數據後計算當前連接需要增加的可接受窗口大小。</p><pre><code>cc.mu.Lock()defer cc.mu.Unlock()var connAdd, streamAdd int32// Check the conn-level first, before the stream-level.if v := cc.inflow.available(); v &lt; http2transportDefaultConnFlow/2 {  connAdd = http2transportDefaultConnFlow - v  cc.inflow.add(connAdd)}</code></pre><p style=text-align:start>如果當前連接可接受窗口的大小已經小於http2transportDefaultConnFlow（1G）的一半，則當前連接可接收窗口大小需要增加http2transportDefaultConnFlow - cc.inflow.available()。</p><p style=text-align:start><strong>回顧</strong>：http2transportDefaultConnFlow在前篇(*http2Transport).NewClientConn方法部分有提到，且連接剛建立時會通過http2WindowUpdateFrame數據幀告知server當前連接可發送窗口大小增加http2transportDefaultConnFlow。</p><p style=text-align:start>2、讀取響應數據後計算當前數據流需要增加的可接受窗口大小。</p><pre><code>if err == nil { // No need to refresh if the stream is over or failed.  // Consider any buffered body data (read from the conn but not  // consumed by the client) when computing flow control for this  // stream.  v := int(cs.inflow.available()) + cs.bufPipe.Len()  if v &lt; http2transportDefaultStreamFlow-http2transportDefaultStreamMinRefresh {    streamAdd = int32(http2transportDefaultStreamFlow - v)    cs.inflow.add(streamAdd)  }}</code></pre><p style=text-align:start>如果當前數據流可接受窗口大小加上當前數據流緩衝區剩餘未讀數據的長度小於http2transportDefaultStreamFlow-http2transportDefaultStreamMinRefresh（4M-4KB），則當前數據流可接受窗口大小需要增加http2transportDefaultStreamFlow - v。</p><p style=text-align:start><strong>回顧</strong>：http2transportDefaultStreamFlow在前篇(*http2Transport).NewClientConn方法和(*http2ClientConn).newStream方法中均有提到。</p><p style=text-align:start>連接剛建立時，發送http2FrameSettings數據幀，告知server每個數據流的可發送窗口大小為http2transportDefaultStreamFlow。</p><p style=text-align:start>在newStream時，數據流默認的可接收窗口大小為http2transportDefaultStreamFlow。</p><p style=text-align:start>3、將連接和數據流分別需要增加的窗口大小通過http2WindowUpdateFrame數據幀告知server。</p><pre><code>if connAdd != 0 || streamAdd != 0 {  cc.wmu.Lock()  defer cc.wmu.Unlock()  if connAdd != 0 {    cc.fr.WriteWindowUpdate(0, http2mustUint31(connAdd))  }  if streamAdd != 0 {    cc.fr.WriteWindowUpdate(cs.ID, http2mustUint31(streamAdd))  }  cc.bw.Flush()}</code></pre><p style=text-align:start>以上就是server向client發送數據的流控制邏輯。</p><h1 class=pgc-h-arrow-right>(*http2clientStream).writeRequestBody</h1><p style=text-align:start>前篇中(*http2ClientConn).roundTrip未對(*http2clientStream).writeRequestBody進行分析，下面我們看看該方法的源碼：</p><pre><code>func (cs *http2clientStream) writeRequestBody(body io.Reader, bodyCloser io.Closer) (err error) {	cc := cs.cc	sentEnd := false // whether we sent the final DATA frame w/ END_STREAM  // 此處省略代碼	req := cs.req	hasTrailers := req.Trailer != nil	remainLen := http2actualContentLength(req)	hasContentLen := remainLen != -1	var sawEOF bool	for !sawEOF {		n, err := body.Read(buf[:len(buf)-1])    // 此處省略代碼		remain := buf[:n]		for len(remain) &gt; 0 &amp;&amp; err == nil {			var allowed int32			allowed, err = cs.awaitFlowControl(len(remain))			switch {			case err == http2errStopReqBodyWrite:				return err			case err == http2errStopReqBodyWriteAndCancel:				cc.writeStreamReset(cs.ID, http2ErrCodeCancel, nil)				return err			case err != nil:				return err			}			cc.wmu.Lock()			data := remain[:allowed]			remain = remain[allowed:]			sentEnd = sawEOF &amp;&amp; len(remain) == 0 &amp;&amp; !hasTrailers			err = cc.fr.WriteData(cs.ID, sentEnd, data)			if err == nil {				err = cc.bw.Flush()			}			cc.wmu.Unlock()		}		if err != nil {			return err		}	}  // 此處省略代碼	return err}</code></pre><p style=text-align:start>上面的邏輯可簡單總結為：不停的讀取請求body然後將讀取的內容通過cc.fr.WriteData轉為http2FrameData數據幀發送給server，直到請求body讀完為止。其中和流控制有關的方法是awaitFlowControl，下面我們對該方法進行分析。</p><h1 class=pgc-h-arrow-right>(*http2clientStream).awaitFlowControl</h1><p style=text-align:start>此方法的主要作用是等待當前數據流可寫窗口有容量能夠寫入數據。</p><pre><code>func (cs *http2clientStream) awaitFlowControl(maxBytes int) (taken int32, err error) {	cc := cs.cc	cc.mu.Lock()	defer cc.mu.Unlock()	for {		if cc.closed {			return 0, http2errClientConnClosed		}		if cs.stopReqBody != nil {			return 0, cs.stopReqBody		}		if err := cs.checkResetOrDone(); err != nil {			return 0, err		}		if a := cs.flow.available(); a &gt; 0 {			take := a			if int(take) &gt; maxBytes {				take = int32(maxBytes) // can't truncate int; take is int32			}			if take &gt; int32(cc.maxFrameSize) {				take = int32(cc.maxFrameSize)			}			cs.flow.take(take)			return take, nil		}		cc.cond.Wait()	}}</code></pre><p style=text-align:start>根據源碼可以知道，數據流被關閉或者停止發送請求body，則當前數據流無法寫入數據。當數據流狀態正常時，又分為兩種情況：</p><ol start=1><li>當前數據流可寫窗口剩餘可寫數據大於0，則計算可寫字節數，並將當前數據流可寫窗口大小消耗take。</li><li>當前數據流可寫窗口剩餘可寫數據小於等於0，則會一直等待直到被喚醒並進入下一次檢查。</li></ol><p style=text-align:start>上面的第二種情況在<strong>收到http2WindowUpdateFrame數據幀</strong>這一節中提到過。</p><p style=text-align:start>server讀取當前數據流的數據後會向client對應數據流發送http2WindowUpdateFrame數據幀，client收到該數據幀後會增大對應數據流可寫窗口，並執行cc.cond.Broadcast()喚醒因發送數據已達流控制上限而等待的數據流繼續發送數據。</p><p style=text-align:start>以上就是client向server發送數據的流控制邏輯。</p><h1 class=pgc-h-arrow-right>總結</h1><ol start=1><li>幀頭長度為9個字節，幷包含四個部分：Payload的長度、幀類型、幀標識符和數據流ID。</li><li>流控制可分為兩個步驟：初始時，通過http2FrameSettings數據幀和http2WindowUpdateFrame數據幀告知對方當前連接讀寫窗口大小以及連接中數據流讀寫窗口大小。在讀寫數據過程中，通過發送http2WindowUpdateFrame數據幀控制另一端的寫窗口大小。</li></ol><h1 class=pgc-h-arrow-right>預告</h1><p style=text-align:start>前篇和中篇已經完成，下一期將對<strong>http2.0標頭壓縮</strong>進行分析。</p><p style=text-align:start>最後，衷心希望本文能夠對各位讀者有一定的幫助。</p><blockquote><p><span style="color:#6a737d;--tt-darkmode-color: #6A737D">注：寫本文時， 筆者所用go版本為: go1.14.2</span></p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Go</a></li><li><a>發起</a></li><li><a>HTTP2.0</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/85697d72.html alt="我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/47dfbe87bec844cf988f2e497c78641a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/85697d72.html title="我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的">我用 Go 生成的隨機數為什麼不隨機？隨機數是怎樣產生的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/317308ae.html alt="Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/35e73626e50e4835a1eacdc0f5f74a69 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/317308ae.html title="Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗">Go 之禪：Dave告訴你編寫簡單、可讀、可維護代碼的十個工程經驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e187bc3.html alt=Go語言之父帶你重新認識字符串、字節、rune和字符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/52e46ed353da4c058a36fb1153b3bf17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e187bc3.html title=Go語言之父帶你重新認識字符串、字節、rune和字符>Go語言之父帶你重新認識字符串、字節、rune和字符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/288f86f6.html alt=Go語言實現：常見排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3a6d9a4e785e4fa097b0adf18620d616 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/288f86f6.html title=Go語言實現：常見排序算法>Go語言實現：常見排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/73f8e8da.html alt=Go語言學習基礎-生成進程、替換進程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0006f0b743b040789141c4474d31a24c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/73f8e8da.html title=Go語言學習基礎-生成進程、替換進程>Go語言學習基礎-生成進程、替換進程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1e3e0993.html alt=延崇高速赤城支線向年底完工發起衝刺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1e3e0993.html title=延崇高速赤城支線向年底完工發起衝刺>延崇高速赤城支線向年底完工發起衝刺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c6cd9fd.html alt=二合一結構發起一場水龍頭革命! class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5894928532fc4b38b473fa513ffde661 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c6cd9fd.html title=二合一結構發起一場水龍頭革命!>二合一結構發起一場水龍頭革命!</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cc38087.html alt="Go 如何獲取當前執行文件所在的目錄？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4d316ba5638c47e391011bce4e28f6a8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cc38087.html title="Go 如何獲取當前執行文件所在的目錄？">Go 如何獲取當前執行文件所在的目錄？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/190ae162.html alt="如何在 Go 中寫出高效的單元測試" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ed1aef2573fe45c582af69ef44638521 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/190ae162.html title="如何在 Go 中寫出高效的單元測試">如何在 Go 中寫出高效的單元測試</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2122bafb.html alt="對比著學 Go 語言-基礎：面向對象編程之接口" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2122bafb.html title="對比著學 Go 語言-基礎：面向對象編程之接口">對比著學 Go 語言-基礎：面向對象編程之接口</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/27147bdc.html alt=沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d906b089a5b448f9cc8c13c1031d4c0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/27147bdc.html title=沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要>沒掌握這個知識點，你的Go語言基礎是不紮實的：接口很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/4679c3e8.html alt=孫中山發起的護法運動，失敗的根本原因 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/633b6fbce1a647cfba0632b0166d373b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/4679c3e8.html title=孫中山發起的護法運動，失敗的根本原因>孫中山發起的護法運動，失敗的根本原因</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/ee976482.html alt=雅芳為乳腺癌宣傳月發起TitTok舞蹈活動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31807fe41bbc4c30815075ae18b4fdd6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/ee976482.html title=雅芳為乳腺癌宣傳月發起TitTok舞蹈活動>雅芳為乳腺癌宣傳月發起TitTok舞蹈活動</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/eacf2d8f.html alt=商務部：印度對華鄰苯二甲酸酐發起反傾銷調查 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/eacf2d8f.html title=商務部：印度對華鄰苯二甲酸酐發起反傾銷調查>商務部：印度對華鄰苯二甲酸酐發起反傾銷調查</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/418eefbf.html alt=「發起脫貧攻堅總攻戰」尋甸縣：特色中藥材成為增收好產業 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/418eefbf.html title=「發起脫貧攻堅總攻戰」尋甸縣：特色中藥材成為增收好產業>「發起脫貧攻堅總攻戰」尋甸縣：特色中藥材成為增收好產業</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>