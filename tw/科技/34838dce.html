<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 | 极客快訊</title><meta property="og:title" content="C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/a0b5a50b90804963b14ab394517ae294"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34838dce.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34838dce.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/34838dce.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34838dce.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34838dce.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/34838dce.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/34838dce.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34838dce.html><meta property="article:published_time" content="2020-11-14T21:00:21+08:00"><meta property="article:modified_time" content="2020-11-14T21:00:21+08:00"><meta name=Keywords content><meta name=description content="C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/34838dce.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/a0b5a50b90804963b14ab394517ae294><p class=pgc-img-caption></p></div><p><strong>指針簡介</strong></p><p>　　指針是Ｃ語言中廣泛使用的一種數據類型。 運用指針編程是Ｃ語言最主要的風格之一。利用指針變量可以表示各種數據結構； 能很方便地使用數組和字符串； 並能象彙編語言一樣處理內存地址，從而編出精練而高效的程序。指針極大地豐富了Ｃ語言的功能。 學習指針是學習Ｃ語言中最重要的一環， 能否正確理解和使用指針是我們是否掌握Ｃ語言的一個標誌。同時， 指針也是Ｃ語言中最為困難的一部分，在學習中除了要正確理解基本概念，還必須要多編程，上機調試。只要作到這些，指針也是不難掌握的。</p><p>　　指針的基本概念 在計算機中，所有的數據都是存放在存儲器中的。 一般把存儲器中的一個字節稱為一個內存單元， 不同的數據類型所佔用的內存單元數不等，如整型量佔2個單元，字符量佔1個單元等， 在第二章中已有詳細的介紹。為了正確地訪問這些內存單元， 必須為每個內存單元編上號。 根據一個內存單元的編號即可準確地找到該內存單元。內存單元的編號也叫做地址。 既然根據內存單元的編號或地址就可以找到所需的內存單元，所以通常也把這個地址稱為指針。 內存單元的指針和內存單元的內容是兩個不同的概念。 可以用一個通俗的例子來說明它們之間的關係。我們到銀行去存取款時， 銀行工作人員將根據我們的帳號去找我們的存款單， 找到之後在存單上寫入存款、取款的金額。在這裡，帳號就是存單的指針， 存款數是存單的內容。對於一個內存單元來說，單元的地址即為指針， 其中存放的數據才是該單元的內容。在Ｃ語言中， 允許用一個變量來存放指針，這種變量稱為指針變量。因此， 一個指針變量的值就是某個內存單元的地址或稱為某內存單元的指針。圖中，設有字符變量C，其內容為“K”(ASCII碼為十進制數 75)，C佔用了011A號單元(地址用十六進數表示)。設有指針變量P，內容為011A， 這種情況我們稱為P指向變量C，或說P是指向變量C的指針。 嚴格地說，一個指針是一個地址， 是一個常量。而一個指針變量卻可以被賦予不同的指針值，是變。 但在常把指針變量簡稱為指針。為了避免混淆，我們中約定：“指針”是指地址， 是常量，“指針變量”是指取值為地址的變量。 定義指針的目的是為了通過指針去訪問內存單元。</p><p>　</p><p>　　既然指針變量的值是一個地址， 那麼這個地址不僅可以是變量的地址， 也可以是其它數據結構的地址。在一個指針變量中存放一</p><p>個數組或一個函數的首地址有何意義呢？ 因為數組或函數都是連續存放的。通過訪問指針變量取得了數組或函數的首地址， 也就找到了該數組或函數。這樣一來， 凡是出現數組，函數的地方都可以用一個指針變量來表示， 只要該指針變量中賦予數組或函數的首地址即可。這樣做， 將會使程序的概念十分清楚，程序本身也精練，高效。在Ｃ語言中， 一種數據類型或數據結構往往都佔有一組連續的內存單元。 用“地址”這個概念並不能很好地描述一種數據類型或數據結構， 而“指針”雖然實際上也是一個地址，但它卻是一個數據結構的首地址， 它是“指向”一個數據結構的，因而概念更為清楚，表示更為明確。 這也是引入“指針”概念的一個重要原因。</p><p>指針變量的類型說明</p><p>　　對指針變量的類型說明包括三個內容：</p><p>(1)指針類型說明，即定義變量為一個指針變量；</p><p>(2)指針變量名；</p><p>(3)變量值(指針)所指向的變量的數據類型。</p><p>　　其一般形式為： 類型說明符 *變量名；</p><p>　　其中，*表示這是一個指針變量，變量名即為定義的指針變量名，類型說明符表示本指針變量所指向的變量的數據類型。</p><div class=pgc-img><img alt=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/58a751f1d8384d6fb6d7dc9f7bf5a861><p class=pgc-img-caption></p></div><p>　　例如： int *p1;表示p1是一個指針變量，它的值是某個整型變量的地址。 或者說p1指向一個整型變量。至於p1究竟指向哪一個整型變量， 應由向p1賦予的地址來決定。</p><p>　　再如：</p><p>staic int *p2; /*p2是指向靜態整型變量的指針變量*/</p><p>float *p3; /*p3是指向浮點變量的指針變量*/</p><p>char *p4; /*p4是指向字符變量的指針變量*/ 應該注意的是，一個指針變量只能指向同類型的變量，如P3 只能指向浮點變量，不能時而指向一個浮點變量， 時而又指向一個字符變量。</p><p>指針變量的賦值</p><p>　　指針變量同普通變量一樣，使用之前不僅要定義說明， 而且必須賦予具體的值。未經賦值的指針變量不能使用， 否則將造成系統混亂，甚至死機。指針變量的賦值只能賦予地址， 決不能賦予任何其它數據，否則將引起錯誤。在Ｃ語言中， 變量的地址是由編譯系統分配的，對用戶完全透明，用戶不知道變量的具體地址。 Ｃ語言中提供了地址運算符&來表示變量的地址。其一般形式為： & 變量名； 如&a變示變量a的地址，&b表示變量b的地址。 變量本身必須預先說明。設有指向整型變量的指針變量p，如要把整型變量a 的地址賦予p可以有以下兩種方式：</p><p>(1)指針變量初始化的方法 int a;</p><p>int *p=&a</p><p>(2)賦值語句的方法 int a;</p><p>int *p;</p><p>p=&a</p><p>不允許把一個數賦予指針變量，故下面的賦值是錯誤的： int *p;p=1000; 被賦值的指針變量前不能再加“*”說明符，如寫為*p=&a 也是錯誤的</p><p>指針變量的運算</p><p>　　指針變量可以進行某些運算，但其運算的種類是有限的。 它只能進行賦值運算和部分算術運算及關係運算。</p><p>1.指針運算符</p><p>(1)取地址運算符&</p><p>　　取地址運算符&是單目運算符，其結合性為自右至左，其功能是取變量的地址。在scanf函數及前面介紹指針變量賦值中，我們已經瞭解並使用了&運算符。</p><p>(2)取內容運算符*</p><p>　　取內容運算符*是單目運算符，其結合性為自右至左，用來表示指針變量所指的變量。在*運算符之後跟的變量必須是指針變量。需要注意的是指針運算符*和指針變量說明中的指針說明符* 不是一回事。在指針變量說明中，“*”是類型說明符，表示其後的變量是指針類型。而表達式中出現的“*”則是一個運算符用以表示指針變量所指的變量。</p><p>main(){</p><p>int a=5,*p=&a</p><p>printf ("%d",*p);</p><p>}</p><p>......</p><p>表示指針變量p取得了整型變量a的地址。本語句表示輸出變量a的值。</p><p><br></p><div class=pgc-img><img alt=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5c15079a4bb14d9a8ec9386f1bc0ce22><p class=pgc-img-caption></p></div><p><br></p><p>2.指針變量的運算</p><p>(1)賦值運算</p><p>指針變量的賦值運算有以下幾種形式：</p><p>①指針變量初始化賦值，前面已作介紹。</p><p>②把一個變量的地址賦予指向相同數據類型的指針變量。例如：</p><p>int a,*pa;</p><p>pa=&a /*把整型變量a的地址賦予整型指針變量pa*/</p><p>③把一個指針變量的值賦予指向相同類型變量的另一個指針變量。如：</p><p>int a,*pa=&a,*pb;</p><p>pb=pa; /*把a的地址賦予指針變量pb*/</p><p>由於pa,pb均為指向整型變量的指針變量，因此可以相互賦值。</p><p>④把數組的首地址賦予指向數組的指針變量。</p><p>例如： int a[5],*pa;</p><p>pa=a; (數組名錶示數組的首地址，故可賦予指向數組的指針變量pa)</p><p>也可寫為：</p><p>pa=&a[0]; /*數組第一個元素的地址也是整個數組的首地址，</p><p>也可賦予pa*/</p><p>當然也可採取初始化賦值的方法：</p><p>int a[5],*pa=a;</p><p>⑤把字符串的首地址賦予指向字符類型的指針變量。例如： char *pc;pc="c language";或用初始化賦值的方法寫為： char *pc="C Language"; 這裡應說明的是並不是把整個字符串裝入指針變量， 而是把存放該字符串的字符數組的首地址裝入指針變量。 在後面還將詳細介紹。</p><p>⑥把函數的入口地址賦予指向函數的指針變量。例如： int (*pf)();pf=f; /*f為函數名*/</p><p>(2)加減算術運算</p><p>　　對於指向數組的指針變量，可以加上或減去一個整數n。設pa是指向數組a的指針變量，則pa+n,pa-n,pa++,++pa,pa--,--pa 運算都是合法的。指針變量加或減一個整數n的意義是把指針指向的當前位置(指向某數組元素)向前或向後移動n個位置。應該注意，數組指針變量向前或向後移動一個位置和地址加1或減1 在概念上是不同的。因為數組可以有不同的類型， 各種類型的數組元素所佔的字節長度是不同的。如指針變量加1，即向後移動1 個位置表示指針變量指向下一個數據元素的首地址。而不是在原地址基礎上加1。</p><p>例如：</p><p>int a[5],*pa;</p><p>pa=a; /*pa指向數組a，也是指向a[0]*/</p><p>pa=pa+2; /*pa指向a[2]，即pa的值為&pa[2]*/ 指針變量的加減運算只能對數組指針變量進行， 對指向其它類型變量的指針變量作加減運算是毫無意義的。(3)兩個指針變量之間的運算只有指向同一數組的兩個指針變量之間才能進行運算， 否則運算毫無意義。</p><p>①兩指針變量相減</p><p>兩指針變量相減所得之差是兩個指針所指數組元素之間相差的元素個數。實際上是兩個指針值(地址) 相減之差再除以該數組元素的長度(字節數)。例如pf1和pf2 是指向同一浮點數組的兩個指針變量，設pf1的值為2010H，pf2的值為2000H，而浮點數組每個元素佔4個字節，所以pf1-pf2的結果為(2000H-2010H)/4=4，表示pf1和 pf2之間相差4個元素。兩個指針變量不能進行加法運算。 例如， pf1+pf2是什麼意思呢?毫無實際意義。</p><p>②兩指針變量進行關係運算</p><p>指向同一數組的兩指針變量進行關係運算可表示它們所指數組元素之間的關係。例如：</p><p>pf1==pf2表示pf1和pf2指向同一數組元素</p><p>pf1>pf2表示pf1處於高地址位置</p><p>pf1&lt;pf2表示pf2處於低地址位置</p><p>main(){</p><p>int a=10,b=20,s,t,*pa,*pb;</p><p>pa=&a</p><p>pb=&b</p><p>s=*pa+*pb;</p><p>t=*pa**pb;</p><p>printf("a=%d\nb=%d\na+b=%d\na*b=%d\n",a,b,a+b,a*b);</p><p>printf("s=%d\nt=%d\n",s,t);</p><p>}</p><p>......</p><p>說明pa,pb為整型指針變量</p><p>給指針變量pa賦值，pa指向變量a。</p><p>給指針變量pb賦值，pb指向變量b。</p><p>本行的意義是求a+b之和，(*pa就是a，*pb就是b)。</p><p>本行是求a*b之積。</p><p>輸出結果。</p><p>輸出結果。</p><p>......</p><p>指針變量還可以與0比較。設p為指針變量，則p==0表明p是空指針，它不指向任何變量；p!=0表示p不是空指針。空指針是由對指針變量賦予0值而得到的。例如： #define NULL 0　int *p=NULL; 對指針變量賦0值和不賦值是不同的。指針變量未賦值時，可以是任意值，是不能使用的。否則將造成意外錯誤。而指針變量賦0值後，則可以使用，只是它不指向具體的變量而已。</p><p>main(){</p><p>int a,b,c,*pmax,*pmin;</p><p>printf("input three numbers:\n");</p><p>scanf("%d%d%d",&a,&b,&c);</p><p>if(a>b){</p><p>pmax=&a</p><p>pmin=&b}</p><p>else{</p><p>pmax=&b</p><p>pmin=&a}</p><p>if(c>*pmax) pmax=&c</p><p>if(c&lt;*pmin) pmin=&c</p><p>printf("max=%d\nmin=%d\n",*pmax,*pmin);</p><p>}</p><p>......</p><p>pmax,pmin為整型指針變量。</p><p>輸入提示。</p><p>輸入三個數字。</p><p>如果第一個數字大於第二個數字．．．</p><p>指針變量賦值</p><p>指針變量賦值</p><p>指針變量賦值</p><p>指針變量賦值</p><p>判斷並賦值</p><p>判斷並賦值</p><p>輸出結果</p><p>......</p><p>數組指針變量的說明和使用</p><p>　　指向數組的指針變量稱為數組指針變量。 在討論數組指針變量的說明和使用之前，我們先明確幾個關係。</p><p>一個數組是由連續的一塊內存單元組成的。 數組名就是這塊連續內存單元的首地址。一個數組也是由各個數組元素(下標變量) 組成的。每個數組元素按其類型不同佔有幾個連續的內存單元。 一個數組元素的首地址也是指它所佔有的幾個內存單元的首地址。 一個指針變量既可以指向一個數組，也可以指向一個數組元素， 可把數組名或第一個元素的地址賦予它。如要使指針變量指向第i號元素可以把i元素的首地址賦予它或把數組名加i賦予它。</p><p>　　設有實數組a，指向a的指針變量為pa，從圖6.3中我們可以看出有以下關係：</p><p>pa,a,&a[0]均指向同一單元，它們是數組a的首地址，也是0 號元素a[0]的首地址。pa+1,a+1,&a[1]均指向1號元素a[1]。類推可知a+i,a+i,&a[i]</p><p>指向i號元素a[i]。應該說明的是pa是變量，而a,&a[i]都是常量。在編程時應予以注意。</p><p>main(){</p><p>int a[5],i;</p><p>for(i=0;i&lt;5;i++){</p><p>a[i]=i;</p><p>printf("a[%d]=%d\n",i,a[i]);</p><p>}</p><p>printf("\n");</p><p>}</p><p>主函數</p><p>定義一個整型數組和一個整型變量</p><p>循環語句</p><p>給數組賦值</p><p>打印每一個數組的值</p><p>......</p><p>輸出換行</p><p>......</p><p>數組指針變量說明的一般形式為：</p><p>類型說明符 * 指針變量名</p><p>　　其中類型說明符表示所指數組的類型。 從一般形式可以看出指向數組的指針變量和指向普通變量的指針變量的說明是相同的。</p><p>引入指針變量後，就可以用兩種方法來訪問數組元素了。</p><p>　　第一種方法為下標法，即用a[i]形式訪問數組元素。 在第四章中介紹數組時都是採用這種方法。</p><p>　　第二種方法為指針法，即採用*(pa+i)形式，用間接訪問的方法來訪問數組元素。</p><p>main(){</p><p>int a[5],i,*pa;</p><p>pa=a;</p><p>for(i=0;i&lt;5;i++){</p><p>*pa=i;</p><p>pa++;</p><p>}</p><p>pa=a;</p><p>for(i=0;i&lt;5;i++){</p><p>printf("a[%d]=%d\n",i,*pa);</p><p>pa++;</p><p>}</p><p>}</p><p>主函數</p><p>定義整型數組和指針</p><p>將指針pa指向數組a</p><p>循環</p><p>將變量i的值賦給由指針pa指向的a[]的數組單元</p><p>將指針pa指向a[]的下一個單元</p><p>......</p><p>指針pa重新取得數組a的首地址</p><p>循環</p><p>用數組方式輸出數組a中的所有元素</p><p>將指針pa指向a[]的下一個單元</p><p>......</p><p>......</p><p>下面，另舉一例，該例與上例本意相同，但是實現方式不同。</p><p>main(){</p><p>int a[5],i,*pa=a;</p><p>for(i=0;i&lt;5;){</p><p>*pa=i;</p><p>printf("a[%d]=%d\n",i++,*pa++);</p><p>}</p><p>}</p><p>主函數</p><p>定義整型數組和指針，並使指針指向數組a</p><p>循環</p><p>將變量i的值賦給由指針pa指向的a[]的數組單元</p><p>用指針輸出數組a中的所有元素，同時指針pa指向a[]的下一個單元</p><p>......</p><p>......</p><p>數組名和數組指針變量作函數參數</p><p>　　在第五章中曾經介紹過用數組名作函數的實參和形參的問題。在學習指針變量之後就更容易理解這個問題了。 數組名就是數組的首地址，實參向形參傳送數組名實際上就是傳送數組的地址， 形參得到該地址後也指向同一數組。 這就好象同一件物品有兩個彼此不同的名稱一樣。同樣，指針變量的值也是地址， 數組指針變量的值即為數組的首地址，當然也可作為函數的參數使用。</p><p>float aver(float *pa);</p><p>main(){</p><p>float sco[5],av,*sp;</p><p>int i;</p><p>sp=sco;</p><p>printf("\ninput 5 scores:\n");</p><p>for(i=0;i&lt;5;i++) scanf("%f",&sco[i]);</p><p>av=aver(sp);</p><p>printf("average score is %5.2f",av);</p><p>}</p><p>float aver(float *pa)</p><p>{</p><p>int i;</p><p>float av,s=0;</p><p>for(i=0;i&lt;5;i++) s=s+*pa++;</p><p>av=s/5;</p><p>return av;</p><p>}</p><p>指向多維數組的指針變量</p><p>本小節以二維數組為例介紹多維數組的指針變量。</p><p>一、多維數組地址的表示方法</p><p>設有整型二維數組a[3][4]如下：</p><p>0 1 2 3</p><p>4 5 6 7</p><p>8 9 10 11</p><p>　　設數組a的首地址為1000，各下標變量的首地址及其值如圖所示。在第四章中介紹過， Ｃ語言允許把一個二維數組分解為多個一維數組來處理。因此數組a可分解為三個一維數組，即a[0]，a[1]，a[2]。每一個一維數組又含有四個元素。例如a[0]數組，含有a[0][0]，a[0][1]，a[0][2]，a[0][3]四個元素。 數組及數組元素的地址表示如下：a是二維數組名，也是二維數組0行的首地址，等於1000。a[0]是第一個一維數組的數組名和首地址，因此也為1000。*(a+0)或*a是與a[0]等效的， 它表示一維數組a[0]0 號元素的首地址。 也為1000。&a[0][0]是二維數組a的0行0列元素首地址，同樣是1000。因此，a，a[0]，*(a+0)，*a，&a[0][0]是相等的。同理，a+1是二維數組1行的首地址，等於1008。a[1]是第二個一維數組的數組名和首地址，因此也為1008。 &a[1][0]是二維數組a的1行0列元素地址，也是1008。因此a+1,a[1],*(a+1),&a[1][0]是等同的。 由此可得出：a+i，a[i]，*(a+i)，&a[i][0]是等同的。 此外，&a[i]和a[i]也是等同的。因為在二維數組中不能把&a[i]理解為元素a[i]的地址，不存在元素a[i]。</p><p>　　Ｃ語言規定，它是一種地址計算方法，表示數組a第i行首地址。由此，我們得出：a[i]，&a[i]，*(a+i)和a+i也都是等同的。另外，a[0]也</p><p>可以看成是a[0]+0是一維數組a[0]的0號元素的首地址， 而a[0]+1則是a[0]的1號元素首地址，由此可得出a[i]+j則是一維數組a[i]的j號元素首地址，它等於&a[i][j]。由a[i]=*(a+i)得a[i]+j=*(a+i)+j，由於*(a+i)+j是二維數組a的i行j列元素的首地址。該元素的值等於*(*(a+i)+j)。</p><p>[Explain]#define PF "%d,%d,%d,%d,%d,\n"</p><p>main(){</p><p>static int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};</p><p>printf(PF,a,*a,a[0],&a[0],&a[0][0]);</p><p>printf(PF,a+1,*(a+1),a[1],&a[1],&a[1][0]);</p><p>printf(PF,a+2,*(a+2),a[2],&a[2],&a[2][0]);</p><p>printf("%d,%d\n",a[1]+1,*(a+1)+1);</p><p>printf("%d,%d\n",*(a[1]+1),*(*(a+1)+1));</p><p>}</p><p>二、多維數組的指針變量</p><p>　　把二維數組a 分解為一維數組a[0],a[1],a[2]之後，設p為指向二維數組的指針變量。可定義為： int (*p)[4] 它表示p是一個指針變量，它指向二維數組a 或指向第一個一維數組a[0]，其值等於a,a[0]，或&a[0][0]等。而p+i則指向一維數組a[i]。從前面的分析可得出*(p+i)+j是二維數組i行j 列的元素的地址，而*(*(p+i)+j)則是i行j列元素的值。</p><p>　　二維數組指針變量說明的一般形式為： 類型說明符 (*指針變量名)[長度] 其中“類型說明符”為所指數組的數據類型。“*”表示其後的變量是指針類型。 “長度”表示二維數組分解為多個一維數組時， 一維數組的長度，也就是二維數組的列數。應注意“(*指針變量名)”兩邊的括號不可少，如缺少括號則表示是指針數組(本章後面介紹)，意義就完全不同了。</p><p>[Explain]main(){</p><p>static int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};</p><p>int(*p)[4];</p><p>int i,j;</p><p>p=a;</p><p>for(i=0;i&lt;3;i++)</p><p>for(j=0;j&lt;4;j++) printf("%2d ",*(*(p+i)+j));</p><p>}</p><p>'Expain字符串指針變量的說明和使用字符串指針變量的定義說明與指向字符變量的指針變量說明是相同的。只能按對指針變量的賦值不同來區別。 對指向字符變量的指針變量應賦予該字符變量的地址。如： char c,*p=&c表示p是一個指向字符變量c的指針變量。而： char *s="C Language";則表示s是一個指向字符串的指針變量。把字符串的首地址賦予s。</p><p>請看下面一例。</p><p>main(){</p><p>char *ps;</p><p>ps="C Language";</p><p>printf("%s",ps);</p><p>}</p><p>運行結果為：</p><p>C Language</p><p>上例中，首先定義ps是一個字符指針變量， 然後把字符串的首地址賦予ps(應寫出整個字符串，以便編譯系統把該串裝入連續的一塊內存單元)，並把首地址送入ps。程序中的： char *ps;ps="C Language";等效於： char *ps="C Language";輸出字符串中n個字符後的所有字符。</p><p>main(){</p><p>char *ps="this is a book";</p><p>int n=10;</p><p>ps=ps+n;</p><p>printf("%s\n",ps);</p><p>}</p><p>運行結果為：</p><p>book 在程序中對ps初始化時，即把字符串首地址賦予ps，當ps= ps+10之後，ps指向字符“b”，因此輸出為"book"。</p><p>main(){</p><p>char st[20],*ps;</p><p>int i;</p><p>printf("input a string:\n");</p><p>ps=st;</p><p>scanf("%s",ps);</p><p>for(i=0;ps[i]!='\0';i++)</p><p>if(ps[i]=='k'){</p><p>printf("there is a 'k' in the string\n");</p><p>break;</p><p>}</p><p>if(ps[i]=='\0') printf("There is no 'k' in the string\n");</p><p>}</p><p>　　本例是在輸入的字符串中查找有無‘k’字符。 下面這個例子是將指針變量指向一個格式字符串，用在printf函數中，用於輸出二維數組的各種地址表示的值。但在printf語句中用指針變量PF代替了格式串。 這也是程序中常用的方法。</p><p>main(){</p><p>static int a[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};</p><p>char *PF;</p><p>PF="%d,%d,%d,%d,%d\n";</p><p>printf(PF,a,*a,a[0],&a[0],&a[0][0]);</p><p>printf(PF,a+1,*(a+1),a[1],&a[1],&a[1][0]);</p><p>printf(PF,a+2,*(a+2),a[2],&a[2],&a[2][0]);</p><p>printf("%d,%d\n",a[1]+1,*(a+1)+1);</p><p>printf("%d,%d\n",*(a[1]+1),*(*(a+1)+1));</p><p>}</p><p>　　在下例是講解，把字符串指針作為函數參數的使用。要求把一個字符串的內容複製到另一個字符串中，並且不能使用strcpy函數。函數cprstr的形參為兩個字符指針變量。pss指向源字符串，pds指向目標字符串。表達式：</p><p>(*pds=*pss)!=`\0'</p><p>cpystr(char *pss,char *pds){</p><p>while((*pds=*pss)!='\0'){</p><p>pds++;</p><p>pss++; }</p><p>}</p><p>main(){</p><p>char *pa="CHINA",b[10],*pb;</p><p>pb=b;</p><p>cpystr(pa,pb);</p><p>printf("string a=%s\nstring b=%s\n",pa,pb);</p><p>}</p><p>　　在上例中，程序完成了兩項工作：一是把pss指向的源字符複製到pds所指向的目標字符中，二是判斷所複製的字符是否為`\0'，若是則表明源字符串結束，不再循環。否則，pds和pss都加1，指向下一字符。在主函數中，以指針變量pa,pb為實參，分別取得確定值後調用cprstr函數。由於採用的指針變量pa和pss,pb和pds均指向同一字符串，因此在主函數和cprstr函數中均可使用這些字符串。也可以把cprstr函數簡化為以下形式：</p><p>cprstr(char *pss,char*pds)</p><p>{while ((*pds++=*pss++)!=`\0');}</p><p>　　即把指針的移動和賦值合併在一個語句中。 進一步分析還可發現`\0'的ASCⅡ碼為0，對於while語句只看表達式的值為非0就循環，為0則結束循環，因此也可省去“!=`\0'”這一判斷部分，而寫為以下形式：</p><p>cprstr (char *pss,char *pds)</p><p>{while (*pdss++=*pss++);}</p><p>表達式的意義可解釋為，源字符向目標字符賦值， 移動指針，若所賦值為非0則循環，否則結束循環。這樣使程序更加簡潔。簡化後的程序如下所示。</p><p>cpystr(char *pss,char *pds){</p><p>while(*pds++=*pss++);</p><p>}</p><p>main(){</p><p>char *pa="CHINA",b[10],*pb;</p><p>pb=b;</p><p>cpystr(pa,pb);</p><p>printf("string a=%s\nstring b=%s\n",pa,pb);</p><p>}</p><p>使用字符串指針變量與字符數組的區別</p><p>用字符數組和字符指針變量都可實現字符串的存儲和運算。 但是兩者是有區別的。在使用時應注意以下幾個問題：</p><p>1. 字符串指針變量本身是一個變量，用於存放字符串的首地址。而字符串本身是存放在以該首地址為首的一塊連續的內存空間中並以‘\0’作為串的結束。字符數組是由於若干個數組元素組成的，它可用來存放整個字符串。</p><p>2. 對字符數組作初始化賦值，必須採用外部類型或靜態類型，如： static char st[]={“C Language”};而對字符串指針變量則無此限制，如： char *ps="C Language";</p><p>3. 對字符串指針方式 char *ps="C Language";可以寫為： char *ps;　ps="C Language";而對數組方式：</p><p>static char st[]={"C Language"};</p><p>不能寫為：</p><p>char st[20];st={"C Language"};</p><p>而只能對字符數組的各元素逐個賦值。</p><p>　　從以上幾點可以看出字符串指針變量與字符數組在使用時的區別，同時也可看出使用指針變量更加方便。前面說過，當一個指針變量在未取得確定地址前使用是危險的，容易引起錯誤。但是對指針變量直接賦值是可以的。因為C系統對指針變量賦值時要給以確定的地址。因此，</p><p>char *ps="C Langage";</p><p>或者 char *ps;</p><p>ps="C Language";都是合法的。</p><p>函數指針變量</p><p>　　在Ｃ語言中規定，一個函數總是佔用一段連續的內存區， 而函數名就是該函數所佔內存區的首地址。 我們可以把函數的這個首地址(或稱入口地址)賦予一個指針變量， 使該指針變量指向該函數。然後通過指針變量就可以找到並調用這個函數。 我們把這種指向函數的指針變量稱為“函數指針變量”。</p><p>函數指針變量定義的一般形式為：</p><p>類型說明符 (*指針變量名)();</p><p>其中“類型說明符”表示被指函數的返回值的類型。“(* 指針變量名)”表示“*”後面的變量是定義的指針變量。 最後的空括號表示指針變量所指的是一個函數。</p><p>例如： int (*pf)();</p><p>表示pf是一個指向函數入口的指針變量，該函數的返回值(函數值)是整型。</p><p>下面通過例子來說明用指針形式實現對函數調用的方法。</p><p>int max(int a,int b){</p><p>if(a>b)return a;</p><p>else return b;</p><p>}</p><p>main(){</p><p>int max(int a,int b);</p><p>int(*pmax)();</p><p>int x,y,z;</p><p>pmax=max;</p><p>printf("input two numbers:\n");</p><p>scanf("%d%d",&x,&y);</p><p>z=(*pmax)(x,y);</p><p>printf("maxmum=%d",z);</p><p>}</p><p>　　從上述程序可以看出用，函數指針變量形式調用函數的步驟如下：1. 先定義函數指針變量，如後一程序中第9行 int (*pmax)();定義pmax為函數指針變量。</p><p>2. 把被調函數的入口地址(函數名)賦予該函數指針變量，如程序中第11行 pmax=max;</p><p>3. 用函數指針變量形式調用函數，如程序第14行 z=(*pmax)(x,y);　調用函數的一般形式為： (*指針變量名) (實參表)使用函數指針變量還應注意以下兩點：</p><p>a. 函數指針變量不能進行算術運算，這是與數組指針變量不同的。數組指針變量加減一個整數可使指針移動指向後面或前面的數組元素，而函數指針的移動是毫無意義的。</p><p>b. 函數調用中"(*指針變量名)"的兩邊的括號不可少，其中的*不應該理解為求值運算，在此處它只是一種表示符號。</p><p>指針型函數</p><p>前面我們介紹過，所謂函數類型是指函數返回值的類型。 在Ｃ語言中允許一個函數的返回值是一個指針(即地址)， 這種返回指針值的函數稱為指針型函數。</p><p>定義指針型函數的一般形式為：</p><p>類型說明符 *函數名(形參表)</p><p>{</p><p>…… /*函數體*/</p><p>}</p><p>其中函數名之前加了“*”號表明這是一個指針型函數，即返回值是一個指針。類型說明符表示了返回的指針值所指向的數據類型。</p><p>如：</p><p>int *ap(int x,int y)</p><p>{</p><p>...... /*函數體*/</p><p>}</p><p>　　表示ap是一個返回指針值的指針型函數， 它返回的指針指向一個整型變量。下例中定義了一個指針型函數 day_name，它的返回值指向一個字符串。該函數中定義了一個靜態指針數組name。name 數組初始化賦值為八個字符串，分別表示各個星期名及出錯提示。形參n表示與星期名所對應的整數。在主函數中， 把輸入的整數i作為實參， 在printf語句中調用day_name函數並把i值傳送給形參 n。day_name函數中的return語句包含一個條件表達式， n 值若大於7或小於1則把name[0] 指針返回主函數輸出出錯提示字符串“Illegal day”。否則返回主函數輸出對應的星期名。主函數中的第7行是個條件語句，其語義是，如輸入為負數(i&lt;0)則中止程序運行退出程序。exit是一個庫函數，exit(1)表示發生錯誤後退出程序， exit(0)表示正常退出。</p><p>　　應該特別注意的是函數指針變量和指針型函數這兩者在寫法和意義上的區別。如int(*p)()和int *p()是兩個完全不同的量。int(*p)()是一個變量說明，說明p 是一個指向函數入口的指針變量，該函數的返回值是整型量，(*p)的兩邊的括號不能少。int *p() 則不是變量說明而是函數說明，說明p是一個指針型函數，其返回值是一個指向整型量的指針，*p兩邊沒有括號。作為函數說明， 在括號內最好寫入形式參數，這樣便於與變量說明區別。 對於指針型函數定義，int *p()只是函數頭部分，一般還應該有函數體部分。</p><p>main(){</p><p>int i;</p><p>char *day_name(int n);</p><p>printf("input Day No:\n");</p><p>scanf("%d",&i);</p><p>if(i&lt;0) exit(1);</p><p>printf("Day No:%2d-->%s\n",i,day_name(i));</p><p>}</p><p>char *day_name(int n){</p><p>static char *name[]={ "Illegal day",</p><p>"Monday",</p><p>"Tuesday",</p><p>"Wednesday",</p><p>"Thursday",</p><p>"Friday",</p><p>"Saturday",</p><p>"Sunday"};</p><p>return((n&lt;1||n>7) ? name[0] : name[n]);</p><p>}</p><p>　　本程序是通過指針函數，輸入一個1～7之間的整數， 輸出對應的星期名。指針數組的說明與使用一個數組的元素值為指針則是指針數組。 指針數組是一組有序的指針的集合。 指針數組的所有元素都必須是具有相同存儲類型和指向相同數據類型的指針變量。</p><p>　　指針數組說明的一般形式為： 類型說明符*數組名[數組長度]</p><p>　　其中類型說明符為指針值所指向的變量的類型。例如： int *pa[3] 表示pa是一個指針數組，它有三個數組元素， 每個元素值都是一個指針，指向整型變量。通常可用一個指針數組來指向一個二維數組。 指針數組中的每個元素被賦予二維數組每一行的首地址， 因此也可理解為指向一個一維數組。圖6—6表示了這種關係。</p><p>int a[3][3]={1,2,3,4,5,6,7,8,9};</p><p>int *pa[3]={a[0],a[1],a[2]};</p><p>int *p=a[0];</p><p>main(){</p><p>int i;</p><p>for(i=0;i&lt;3;i++)</p><p>printf("%d,%d,%d\n",a[i][2-i],*a[i],*(*(a+i)+i));</p><p>for(i=0;i&lt;3;i++)</p><p>printf("%d,%d,%d\n",*pa[i],p[i],*(p+i));</p><p>}</p><p>　　本例程序中，pa是一個指針數組，三個元素分別指向二維數組a的各行。然後用循環語句輸出指定的數組元素。其中*a[i]表示i行0列元素值；*(*(a+i)+i)表示i行i列的元素值；*pa[i]表示i行0列元素值；由於p與a[0]相同，故p[i]表示0行i列的值；*(p+i)表示0行i列的值。讀者可仔細領會元素值的各種不同的表示方法。 應該注意指針數組和二維數組指針變量的區別。 這兩者雖然都可用來表示二維數組，但是其表示方法和意義是不同的。</p><p>　　二維數組指針變量是單個的變量，其一般形式中"(*指針變量名)"兩邊的括號不可少。而指針數組類型表示的是多個指針( 一組有序指針)在一般形式中"*指針數組名"兩邊不能有括號。例如： int (*p)[3];表示一個指向二維數組的指針變量。該二維數組的列數為3或分解為一維數組的長度為3。 int *p[3] 表示p是一個指針數組，有三個下標變量p[0]，p[1]，p[2]均為指針變量。</p><p>　　指針數組也常用來表示一組字符串， 這時指針數組的每個元素被賦予一個字符串的首地址。 指向字符串的指針數組的初始化更為簡單。例如在例6.20中即採用指針數組來表示一組字符串。 其初始化賦值為：</p><p>char *name[]={"Illagal day",</p><p>"Monday",</p><p>"Tuesday",</p><p>"Wednesday",</p><p>"Thursday",</p><p>"Friday",</p><p>"Saturday",</p><p>"Sunday"};</p><p>　　完成這個初始化賦值之後，name[0]即指向字符串"Illegal day"，name[1]指?quot;Monday"......。</p><p>　　指針數組也可以用作函數參數。在本例主函數中，定義了一個指針數組name，並對name 作了初始化賦值。其每個元素都指向一個字符串。然後又以name 作為實參調用指針型函數day name，在調用時把數組名 name 賦予形參變量name，輸入的整數i作為第二個實參賦予形參n。在day name函數中定義了兩個指針變量pp1和pp2，pp1被賦予name[0]的值(即*name)，pp2被賦予name[n]的值即*(name+ n)。由條件表達式決定返回pp1或pp2指針給主函數中的指針變量ps。最後輸出i和ps的值。</p><p>指針數組作指針型函數的參數</p><p>main(){</p><p>static char *name[]={ "Illegal day",</p><p>"Monday",</p><p>"Tuesday",</p><p>"Wednesday",</p><p>"Thursday",</p><p>"Friday",</p><p>"Saturday",</p><p>"Sunday"};</p><p>char *ps;</p><p>int i;</p><p>char *day_name(char *name[],int n);</p><p>printf("input Day No:\n");</p><p>scanf("%d",&i);</p><p>if(i&lt;0) exit(1);</p><p>ps=day_name(name,i);</p><p>printf("Day No:%2d-->%s\n",i,ps);</p><p>}</p><p>char *day_name(char *name[],int n)</p><p>{</p><p>char *pp1,*pp2;</p><p>pp1=*name;</p><p>pp2=*(name+n);</p><p>return((n&lt;1||n>7)? pp1:pp2);</p><p>}</p><p>下例要求輸入5個國名並按字母順序排列後輸出。在以前的例子中採用了普通的排序方法， 逐個比較之後交換字符串的位置。交換字符串的物理位置是通過字符串複製函數完成的。 反覆的交換將使程序執行的速度很慢，同時由於各字符串(國名) 的長度不同，又增加了存儲管理的負擔。 用指針數組能很好地解決這些問題。把所有的字符串存放在一個數組中， 把這些字符數組的首地址放在一個指針數組中，當需要交換兩個字符串時， 只須交換指針數組相應兩元素的內容(地址)即可，而不必交換字符串本身。程序中定義了兩個函數，一個名為sort完成排序， 其形參為指</p><p>針數組name，即為待排序的各字符串數組的指針。形參n為字符串的個數。另一個函數名為print，用於排序後字符串的輸出，其形參與sort的形參相同。主函數main中，定義了指針數組name 並作了初始化賦值。然後分別調用sort函數和print函數完成排序和輸出。值得說明的是在sort函數中，對兩個字符串比較，採用了strcmp 函數，strcmp函數允許參與比較的串以指針方式出現。name[k]和name[ j]均為指針，因此是合法的。字符串比較後需要交換時， 只交換指針數組元素的值，而不交換具體的字符串， 這樣將大大減少時間的開銷，提高了運行效率。</p><p>現編程如下：</p><p>#include"string.h"</p><p>main(){</p><p>void sort(char *name[],int n);</p><p>void print(char *name[],int n);</p><p>static char *name[]={ "CHINA","AMERICA","AUSTRALIA",</p><p>"FRANCE","GERMAN"};</p><p>int n=5;</p><p>sort(name,n);</p><p>print(name,n);</p><p>}</p><p>void sort(char *name[],int n){</p><p>char *pt;</p><p>int i,j,k;</p><p>for(i=0;i&lt;n-1;i++){</p><p>k=i;</p><p>for(j=i+1;j&lt;n;j++)</p><p>if(strcmp(name[k],name[j])>0) k=j;</p><p>if(k!=i){</p><p>pt=name[i];</p><p>name[i]=name[k];</p><p>name[k]=pt;</p><p>}</p><p>}</p><p>}</p><p>void print(char *name[],int n){</p><p>int i;</p><p>for (i=0;i&lt;n;i++) printf("%s\n",name[i]);</p><p>}</p><p>ｍａｉｎ函數的參數</p><p>　　前面介紹的main函數都是不帶參數的。因此main 後的括號都是空括號。實際上，main函數可以帶參數，這個參數可以認為是 main函數的形式參數。Ｃ語言規定main函數的參數只能有兩個， 習慣上這兩個參數寫為argc和argv。因此，main函數的函數頭可寫為： main (argc,argv)Ｃ語言還規定argc(第一個形參)必須是整型變量,argv( 第二個形參)必須是指向字符串的指針數組。加上形參說明後，main函數的函數頭應寫為：</p><p>main (argc,argv)</p><p>int argv;</p><p>char *argv[];或寫成：</p><p>main (int argc,char *argv[])</p><p>　　由於main函數不能被其它函數調用， 因此不可能在程序內部取得實際值。那麼，在何處把實參值賦予main函數的形參呢? 實際上,main函數的參數值是從操作系統命令行上獲得的。當我們要運行一個可執行文件時，在DOS提示符下鍵入文件名，再輸入實際參數即可把這些實參傳送到main的形參中去。</p><p>　　DOS提示符下命令行的一般形式為： C:\>可執行文件名 參數 參數……; 但是應該特別注意的是，main 的兩個形參和命令行中的參數在</p><p>位置上不是一一對應的。因為,main的形參只有二個，而命令行中的參數個數原則上未加限制。argc參數表示了命令行中參數的個數(注意：文件名本身也算一個參數)，argc的值是在輸入命令行時由系統按實際參數的個數自動賦予的。例如有命令行為： C:\>E6 24 BASIC dbase FORTRAN由於文件名E6 24本身也算一個參數，所以共有4個參數，因此argc取得的值為4。argv參數是字符串指針數組，其各元素值為命令行中各字符串(參數均按字符串處理)的首地址。 指針數組的長度即為參數個數。數組元素初值由系統自動賦予。其表示如圖6.8所示：</p><p>main(int argc,char *argv){</p><p>while(argc-->1)</p><p>printf("%s\n",*++argv);</p><p>}</p><p>本例是顯示命令行中輸入的參數如果上例的可執行文件名為e24.exe，存放在A驅動器的盤內。</p><p>因此輸入的命令行為： C:\>a:e24 BASIC dBASE FORTRAN</p><p>則運行結果為：</p><p>BASIC</p><p>dBASE</p><p>FORTRAN</p><p>　　該行共有4個參數，執行main時，argc的初值即為4。argv的4個元素分為4個字符串的首地址。執行while語句，每循環一次 argv值減1，當argv等於1時停止循環，共循環三次， 因此共可輸出三個參數。在printf函數中，由於打印項*++argv是先加1再打印， 故第一次打印的是argv[1]所指的字符串BASIC。第二、 三次循環分別打印後二個字符串。而參數e24是文件名，不必輸出。</p><p>　　下例的命令行中有兩個參數，第二個參數20即為輸入的n值。在程序中*++argv的值為字符串“20”，然後用函數"atoi"把它換為整型作為while語句中的循環控制變量，輸出20個偶數。</p><p>#include"stdlib.h"</p><p>main(int argc,char*argv[]){</p><p>int a=0,n;</p><p>n=atoi(*++argv);</p><p>while(n--) printf("%d ",a++*2);</p><p>}</p><p>　　本程序是從0開始輸出n個偶數。指向指針的指針變量如果一個指針變量存放的又是另一個指針變量的地址， 則稱這個指針變量為指向指針的指針變量。</p><p>　　在前面已經介紹過，通過指針訪問變量稱為間接訪問， 簡稱間訪。由於指針變量直接指向變量，所以稱為單級間訪。 而如果通過指向指針的指針變量來訪問變量則構成了二級或多級間訪。在Ｃ語言程序中，對間訪的級數並未明確限制， 但是間訪級數太多時不容易理解解，也容易出錯，因此，一般很少超過二級間訪。 指向指針的指針變量說明的一般形式為：</p><p>類型說明符** 指針變量名；</p><p>例如： int ** pp; 表示pp是一個指針變量，它指向另一個指針變量， 而這個指針變量指向一個整型量。下面舉一個例子來說明這種關係。</p><p>main(){</p><p>int x,*p,**pp;</p><p>x=10;</p><p>p=&x</p><p>pp=&p</p><p>printf("x=%d\n",**pp);</p><p>}</p><p>　　上例程序中p 是一個指針變量，指向整型量x；pp也是一個指針變量， 它指向指針變量p。通過pp變量訪問x的寫法是**pp。程序最後輸出x的值為10。通過上例，讀者可以學習指向指針的指針變量的說明和使用方法。</p><p>　　下述程序中首先定義說明了指針數組ps並作了初始化賦值。 又說明了pps是一個指向指針的指針變量。在5次循環中， pps 分別取得了ps[0]，ps[1]，ps[2]，ps[3]，ps[4]的地址值(如圖6.10所示)。再通過這些地址即可找到該字符串。</p><p>main(){</p><p>static char *ps[]={ "BASIC","DBASE","C","FORTRAN",</p><p>"PASCAL"};</p><p>char **pps;</p><p>int i;</p><p>for(i=0;i&lt;5;i++){</p><p>pps=ps+i;</p><p>printf("%s\n",*pps);</p><p>}</p><p>}</p><p>本程序是用指向指針的指針變量編程，輸出多個字符串。</p><p>本章小結</p><p>1. 指針是Ｃ語言中一個重要的組成部分，使用指針編程有以下優點：</p><p>(1)提高程序的編譯效率和執行速度。</p><p>(2)通過指針可使用主調函數和被調函數之間共享變量或數據結構，便於實現雙向數據通訊。</p><p>(3)可以實現動態的存儲分配。</p><p>(4)便於表示各種數據結構，編寫高質量的程序。</p><p>2. 指針的運算</p><p>(1)取地址運算符&：求變量的地址</p><p>(2)取內容運算符*：表示指針所指的變量</p><p>(3)賦值運算</p><p>·把變量地址賦予指針變量</p><p>·同類型指針變量相互賦值</p><p>·把數組，字符串的首地址賦予指針變量</p><p>·把函數入口地址賦予指針變量</p><p>(4)加減運算</p><p>對指向數組，字符串的指針變量可以進行加減運算，如p+n,p-n,p++,p--等。對指向同一數組的兩個指針變量可以相減。對指向其它類型的指針變量作加減運算是無意義的。</p><p>(5)關係運算</p><p>指向同一數組的兩個指針變量之間可以進行大於、小於、 等於比較運算。指針可與0比較，p==0表示p為空指針。</p><p>3. 與指針有關的各種說明和意義見下表。</p><p>int *p; 　　　 p為指向整型量的指針變量</p><p>int *p[n]; 　　p為指針數組，由n個指向整型量的指針元素組成。</p><p>int (*p)[n]; 　p為指向整型二維數組的指針變量，二維數組的列數為n</p><p>int *p() 　　　p為返回指針值的函數，該指針指向整型量</p><p>int (*p)() 　　p為指向函數的指針，該函數返回整型量</p><p>int **p 　　　 p為一個指向另一指針的指針變量，該指針指向一個整型量。</p><p>4. 有關指針的說明很多是由指針，數組，函數說明組合而成的。</p><p>但並不是可以任意組合，例如數組不能由函數組成，即數組元素不能是一個函數；函數也不能返回一個數組或返回另一個函數。例如</p><p>int a[5]()；就是錯誤的。</p><p>5. 關於括號</p><p>在解釋組合說明符時， 標識符右邊的方括號和圓括號優先於標識符左邊的“*”號，而方括號和圓括號以相同的優先級從左到右結合。但可以用圓括號改變約定的結合順序。</p><p>6. 閱讀組合說明符的規則是“從裡向外”。</p><p>從標識符開始，先看它右邊有無方括號或園括號，如有則先作出解釋，再看左邊有無*號。 如果在任何時候遇到了閉括號，則在繼續之前必須用相同的規則處理括號內的內容。例如：</p><p>int*(*(*a)())[10]</p><p>↑ ↑↑↑↑↑↑</p><p>7 6 4 2 1 3 5</p><p>上面給出了由內向外的閱讀順序，下面來解釋它：</p><p>(1)標識符a被說明為；</p><p>(2)一個指針變量，它指向；</p><p>(3)一個函數，它返回；</p><p>(4)一個指針，該指針指向；</p><p>(5)一個有10個元素的數組，其類型為；</p><p>(6)指針型，它指向；</p><p>(7)int型數據。</p><p>因此a是一個函數指針變量，該函數返回的一個指針值又指向一個指針數組，該指針數組的元素指向整型量。</p><p><br></p><div class=pgc-img><img alt=C精品編程之——指針，C語言的精髓，每個編程初學者的噩夢 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9b566279bad244d6a9b4bd8117d31a9e><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>指針</a></li><li><a>語言</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/9f9a0ab8.html alt=P4語言編程詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b0509dc83f844c6e9e133d81e9855e4b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9f9a0ab8.html title=P4語言編程詳解>P4語言編程詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ba54309.html alt=C語言編程第19講——斷言的使用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/92ee4886-fdd7-4a4a-b45a-d647ef966836 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ba54309.html title=C語言編程第19講——斷言的使用>C語言編程第19講——斷言的使用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/342d7dd9.html alt=C語言指針終極指南！（附詳盡圖示和代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4e7017cb21b9471891cf2f2febf5befe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/342d7dd9.html title=C語言指針終極指南！（附詳盡圖示和代碼）>C語言指針終極指南！（附詳盡圖示和代碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/178bc13f.html alt=C語言指針難嗎？紙老虎而已，純乾貨講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71b50f2a7c1141a2ac44a24efb4a84ff style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/178bc13f.html title=C語言指針難嗎？紙老虎而已，純乾貨講解>C語言指針難嗎？紙老虎而已，純乾貨講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dd5b00b1.html alt=嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/40851dc497a8409bbff6a6aae1e42e8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dd5b00b1.html title=嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？>嵌入式C語言基礎編程—5年程序員給你講函數，你真的懂函數嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e2c14705.html alt=C語言編程知識總結，思維導圖版本，事半功倍！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/721353b3b68a41059d980e19083d03e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e2c14705.html title=C語言編程知識總結，思維導圖版本，事半功倍！>C語言編程知識總結，思維導圖版本，事半功倍！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/293e60e3.html alt=Rust編程語言初探 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/b47797c4e0b5476e86050d174aea893c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/293e60e3.html title=Rust編程語言初探>Rust編程語言初探</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a0bb3a1a.html alt=C語言指針運算不理解？深入淺出通俗易懂，一題吃透指針與數組 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f86ddd3196544739bc425c80fd9c9c5e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a0bb3a1a.html title=C語言指針運算不理解？深入淺出通俗易懂，一題吃透指針與數組>C語言指針運算不理解？深入淺出通俗易懂，一題吃透指針與數組</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c6a3555.html alt=C語言指針怎麼理解？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2245f99437eb40f38a501559e7695694 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c6a3555.html title=C語言指針怎麼理解？>C語言指針怎麼理解？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42ec5444.html alt=C語言的精華指針，沒學指針就是沒學C語言！零基礎瞭解C語言指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3751eb5d53b64a3085de1113ad56d98a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42ec5444.html title=C語言的精華指針，沒學指針就是沒學C語言！零基礎瞭解C語言指針>C語言的精華指針，沒學指針就是沒學C語言！零基礎瞭解C語言指針</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00508d48.html alt=c語言指針有哪些？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1530609445503dc7f276929 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00508d48.html title=c語言指針有哪些？>c語言指針有哪些？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9c706fd4.html alt=初識C語言指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/202ea458-f961-4d7f-8442-64dc6ce814c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9c706fd4.html title=初識C語言指針>初識C語言指針</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9dc72d59.html alt=指針-C語言的靈魂(五)-指針與數組的微妙關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152125795472869eabef91e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9dc72d59.html title=指針-C語言的靈魂(五)-指針與數組的微妙關係>指針-C語言的靈魂(五)-指針與數組的微妙關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1cbb5c65.html alt=指針-C語言的靈魂(四)-指針運算 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1521079213682d1229d1654 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1cbb5c65.html title=指針-C語言的靈魂(四)-指針運算>指針-C語言的靈魂(四)-指針運算</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4ea6119e.html alt=深入理解C語言的指針 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4e2601d6d7b04dc2b8107b4555ef6910 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4ea6119e.html title=深入理解C語言的指針>深入理解C語言的指針</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>