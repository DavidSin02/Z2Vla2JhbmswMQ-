<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 | 极客快訊</title><meta property="og:title" content="HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/faeb3cbe96a24ebf838893b5cf134678"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34a75459.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34a75459.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/34a75459.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34a75459.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34a75459.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/34a75459.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/34a75459.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/34a75459.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/34a75459.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>一、前言</h1><p>得益於Doug Lea老爺子的操刀，讓HashMap成為使用和麵試最頻繁的API，沒辦法設計的太優秀了！</p><p>HashMap 最早出現在 JDK 1.2中，底層基於散列算法實現。HashMap 允許 null 鍵和 null 值，在計算哈鍵的哈希值時，null 鍵哈希值為 0。HashMap 並不保證鍵值對的順序，這意味著在進行某些操作後，鍵值對的順序可能會發生變化。另外，需要注意的是，HashMap 是非線程安全類，在多線程環境下可能會存在問題。</p><p>HashMap 最早在JDK 1.2中就出現了，底層是基於散列算法實現，隨著幾代的優化更新到目前為止它的源碼部分已經比較複雜，涉及的知識點也非常多，在JDK 1.8中包括；1、散列表實現、2、擾動函數、3、初始化容量、4、負載因子、5、擴容元素拆分、6、鏈表樹化、7、紅黑樹、8、插入、9、查找、10、刪除、11、遍歷、12、分段鎖等等，因涉及的知識點較多所以需要分開講解，本章節我們會先把目光放在前五項上，也就是關於數據結構的使用上。</p><p>數據結構相關往往與數學離不開，學習過程中建議下載相應源碼進行實驗驗證，可能這個過程有點燒腦，但學會後不用死記硬背就可以理解這部分知識。</p><h1 class=pgc-h-arrow-right>二、資源下載</h1><p>本章節涉及的源碼和資源在工程，<strong>interview-04</strong>中，包括；</p><ol start=1><li>10萬單詞測試數據，在doc文件夾</li><li>擾動函數excel展現，在dock文件夾</li><li>測試源碼部分在interview-04工程中</li></ol><p>可以通過關注公眾號：bugstack蟲洞棧，回覆下載進行獲取{<em>回覆下載後打開獲得的鏈接，找到編號ID：19</em>}</p><h1 class=pgc-h-arrow-right>三、源碼分析</h1><p><strong>1. 寫一個最簡單的HashMap</strong></p><p>學習HashMap前，最好的方式是先了解這是一種怎麼樣的數據結構來存放數據。而HashMap經過多個版本的迭代後，乍一看代碼還是很複雜的。就像你原來只穿個褲衩，現在還有秋褲和風衣。所以我們先來看看最根本的HashMap是什麼樣，也就是隻穿褲衩是什麼效果，之後再去分析它的源碼。</p><p><strong>問題：</strong> 假設我們有一組7個字符串，需要存放到數組中，但要求在獲取每個元素的時候時間複雜度是O(1)。也就是說你不能通過循環遍歷的方式進行獲取，而是要定位到數組ID直接獲取相應的元素。</p><p><strong>方案：</strong> 如果說我們需要通過ID從數組中獲取元素，那麼就需要把每個字符串都計算出一個在數組中的位置ID。<em>字符串獲取ID你能想到什麼方式？</em> 一個字符串最直接的獲取跟數字相關的信息就是HashCode，可HashCode的取值範圍太大了[-2147483648, 2147483647]，不可能直接使用。那麼就需要使用HashCode與數組長度做與運算，得到一個可以在數組中出現的位置。如果說有兩個元素得到同樣的ID，那麼這個數組ID下就存放兩個字符串。</p><p>以上呢其實就是我們要把字符串散列到數組中的一個基本思路，接下來我們就把這個思路用代碼實現出來。</p><p><strong>1.1 代碼實現</strong></p><pre><code>// 初始化一組字符串List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("jlkk");list.add("lopi");list.add("小傅哥");list.add("e4we");list.add("alpo");list.add("yhjk");list.add("plop");// 定義要存放的數組String[] tab = new String[8];// 循環存放for (String key : list) {    int idx = key.hashCode() &amp; (tab.length - 1);  // 計算索引位置    System.out.println(String.format("key值=%s Idx=%d", key, idx));    if (null == tab[idx]) {        tab[idx] = key;        continue;    }    tab[idx] = tab[idx] + "-&gt;" + key;}// 輸出測試結果System.out.println(JSON.toJSONString(tab));</code></pre><p>這段代碼整體看起來也是非常簡單，並沒有什麼複雜度，主要包括以下內容；</p><ol start=1><li>初始化一組字符串集合，這裡初始化了7個。</li><li>定義一個數組用於存放字符串，注意這裡的長度是8，也就是2的倍數。這樣的數組長度才會出現一個 0111 除高位以外都是1的特徵，也是為了散列。</li><li>接下來就是循環存放數據，計算出每個字符串在數組中的位置。key.hashCode() & (tab.length - 1)。</li><li>在字符串存放到數組的過程，如果遇到相同的元素，進行連接操作模擬鏈表的過程。</li><li>最後輸出存放結果。</li></ol><p><strong>測試結果</strong></p><pre><code>key值=jlkk Idx=2key值=lopi Idx=4key值=小傅哥 Idx=7key值=e4we Idx=5key值=alpo Idx=2key值=yhjk Idx=0key值=plop Idx=5測試結果：["yhjk",null,"jlkk-&gt;alpo",null,"lopi","e4we-&gt;plop",null,"小傅哥"]</code></pre><ul><li>在測試結果首先是計算出每個元素在數組的Idx，也有出現重複的位置。</li><li>最後是測試結果的輸出，1、3、6，位置是空的，2、5，位置有兩個元素被鏈接起來e4we->plop。</li><li>這就達到了我們一個最基本的要求，將串元素散列存放到數組中，最後通過字符串元素的索引ID進行獲取對應字符串。這樣是HashMap的一個最基本原理，有了這個基礎後面就會更容易理解HashMap的源碼實現。</li></ul><p><strong>1.2 Hash散列示意圖</strong></p><p>如果上面的測試結果不能在你的頭腦中很好的建立出一個數據結構，那麼可以看以下這張散列示意圖，方便理解；</p><p><br></p><div class=pgc-img><img alt=HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/faeb3cbe96a24ebf838893b5cf134678><p class=pgc-img-caption></p></div><p><br></p><ul><li>這張圖就是上面代碼實現的全過程，將每一個字符串元素通過Hash計算索引位置，存放到數組中。</li><li>黃色的索引ID是沒有元素存放、綠色的索引ID存放了一個元素、紅色的索引ID存放了兩個元素。</li></ul><p><strong>1.3 這個簡單的HashMap有哪些問題</strong></p><p>以上我們實現了一個簡單的HashMap，或者說還算不上HashMap，只能算做一個散列數據存放的雛形。但這樣的一個數據結構放在實際使用中，會有哪些問題呢？</p><ol start=1><li>這裡所有的元素存放都需要獲取一個索引位置，而如果元素的位置不夠散列碰撞嚴重，那麼就失去了散列表存放的意義，沒有達到預期的性能。</li><li>在獲取索引ID的計算公式中，需要數組長度是2的倍數，那麼怎麼進行初始化這個數組大小。</li><li>數組越小碰撞的越大，數組越大碰撞的越小，時間與空間如何取捨。</li><li>目前存放7個元素，已經有兩個位置都存放了2個字符串，那麼鏈表越來越長怎麼優化。</li><li>隨著元素的不斷添加，數組長度不足擴容時，怎麼把原有的元素，拆分到新的位置上去。</li></ol><p>以上這些問題可以歸納為；擾動函數、初始化容量、負載因子、擴容方法以及鏈表和紅黑樹轉換的使用等。接下來我們會逐個問題進行分析。</p><h1 class=pgc-h-arrow-right>2. 擾動函數</h1><p>在HashMap存放元素時候有這樣一段代碼來處理哈希值，這是java 8的散列值擾動函數，用於優化散列效果；</p><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}</code></pre><p><strong>2.1 為什麼使用擾動函數</strong></p><p>理論上來說字符串的hashCode是一個int類型值，那可以直接作為數組下標了，且不會出現碰撞。但是這個hashCode的取值範圍是[-2147483648, 2147483647]，有將近40億的長度，誰也不能把數組初始化的這麼大，內存也是放不下的。</p><p>我們默認初始化的Map大小是16個長度 DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4，所以獲取的Hash值並不能直接作為下標使用，需要與數組長度進行取模運算得到一個下標值，也就是我們上面做的散列列子。</p><p>那麼，hashMap源碼這裡不只是直接獲取哈希值，還進行了一次擾動計算，(h = key.hashCode()) ^ (h >>> 16)。把哈希值右移16位，也就正好是自己長度的一半，之後與原哈希值做異或運算，這樣就混合了原哈希值中的高位和低位，增大了<strong>隨機性</strong>。計算方式如下圖；</p><p><br></p><div class=pgc-img><img alt=HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/04a94634edd74659986d69d0d5f56c9e><p class=pgc-img-caption></p></div><p><br></p><ul><li>說白了，使用擾動函數就是為了增加隨機性，讓數據元素更加均衡的散列，減少碰撞。</li></ul><p><strong>2.2 實驗驗證擾動函數</strong></p><p>從上面的分析可以看出，擾動函數使用了哈希值的高半區和低半區做異或，混合原始哈希碼的高位和低位，以此來加大低位區的隨機性。</p><p>但看不到實驗數據的話，這終究是一段理論，具體這段哈希值真的被增加了隨機性沒有，並不知道。所以這裡我們要做一個實驗，這個實驗是這樣做；</p><ol start=1><li>選取10萬個單詞詞庫</li><li>定義128位長度的數組格子</li><li>分別計算在擾動和不擾動下，10萬單詞的下標分配到128個格子的數量</li><li>統計各個格子數量，生成波動曲線。如果擾動函數下的波動曲線相對更平穩，那麼證明擾動函數有效果。</li></ol><p><strong>2.2.1 擾動代碼測試</strong></p><p><strong>擾動函數對比方法</strong></p><pre><code>public class Disturb {    public static int disturbHashIdx(String key, int size) {        return (size - 1) &amp; (key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16));    }    public static int hashIdx(String key, int size) {        return (size - 1) &amp; key.hashCode();    }}</code></pre><ul><li>disturbHashIdx 擾動函數下，下標值計算</li><li>hashIdx 非擾動函數下，下標值計算</li></ul><p><strong>單元測試</strong></p><pre><code>// 10萬單詞已經初始化到words中@Testpublic void test_disturb() {    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(16);    for (String word : words) {        // 使用擾動函數        int idx = Disturb.disturbHashIdx(word, 128);        // 不使用擾動函數        // int idx = Disturb.hashIdx(word, 128);        if (map.containsKey(idx)) {            Integer integer = map.get(idx);            map.put(idx, ++integer);        } else {            map.put(idx, 1);        }    }    System.out.println(map.values());}</code></pre><p>以上分別統計兩種函數下的下標值分配，最終將統計結果放到excel中生成圖表。</p><p><strong>2.2.2 擾動函數散列圖表</strong></p><p>以上的兩張圖，分別是沒有使用擾動函數和使用擾動函數的，下標分配。實驗數據；</p><ol start=1><li>10萬個不重複的單詞</li><li>128個格子，相當於128長度的數組</li></ol><p><strong>未使用擾動函數</strong></p><p><br></p><div class=pgc-img><img alt=HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/62d5eb898cb0411785cde88e1b678938><p class=pgc-img-caption></p></div><p><br></p><p><strong>使用擾動函數</strong></p><p><br></p><div class=pgc-img><img alt=HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c3199a2d49314c73a6cac8ef2dc6a584><p class=pgc-img-caption></p></div><p><br></p><ul><li>從這兩種的對比圖可以看出來，在使用了擾動函數後，數據分配的更加均勻了。</li><li>數據分配均勻，也就是散列的效果更好，減少了hash的碰撞，讓數據存放和獲取的效率更佳。</li></ul><h1 class=pgc-h-arrow-right>3. 初始化容量和負載因子</h1><p>接下來我們討論下一個問題，從我們模仿HashMap的例子中以及HashMap默認的初始化大小裡，都可以知道，散列數組需要一個2的倍數的長度，因為只有2的倍數在減1的時候，才會出現01111這樣的值。</p><p>那麼這裡就有一個問題，我們在初始化HashMap的時候，如果傳一個17個的值new HashMap&lt;>(17);，它會怎麼處理呢？</p><p><strong>3.1 尋找2的倍數最小值</strong></p><p>在HashMap的初始化中，有這樣一段方法；</p><pre><code>public HashMap(int initialCapacity, float loadFactor) {    ...    this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}</code></pre><ul><li>閥值threshold，通過方法tableSizeFor進行計算，是根據初始化來計算的。</li><li>這個方法也就是要尋找比初始值大的，最小的那個2進制數值。比如傳了17，我應該找到的是32。</li></ul><p>計算閥值大小的方法；</p><pre><code>static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}</code></pre><ul><li>MAXIMUM_CAPACITY = 1 &lt;&lt; 30，這個是臨界範圍，也就是最大的Map集合。</li><li>乍一看可能有點暈怎麼都在向右移位1、2、4、8、16，這主要是為了把二進制的各個位置都填上1，當二進制的各個位置都是1以後，就是一個標準的2的倍數減1了，最後把結果加1再返回即可。</li></ul><p>那這裡我們把17這樣一個初始化計算閥值的過程，用圖展示出來，方便理解；</p><p><br></p><div class=pgc-img><img alt=HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15c3319075924b42b90d0a9de9568207><p class=pgc-img-caption></p></div><p><br></p><p><strong>3.2 負載因子</strong></p><pre><code>static final float DEFAULT_LOAD_FACTOR = 0.75f;</code></pre><p><strong>負載因子是做什麼的？</strong></p><p>負載因子，可以理解成一輛車可承重重量超過某個閥值時，把貨放到新的車上。</p><p>那麼在HashMap中，負載因子決定了數據量多少了以後進行擴容。<em>這裡要提到上面做的HashMap例子，我們準備了7個元素，但是最後還有3個位置空餘，2個位置存放了2個元素。</em> 所以可能即使你數據比數組容量大時也是不一定能正正好好的把數組佔滿的，而是在某些小標位置出現了大量的碰撞，只能在同一個位置用鏈表存放，那麼這樣就失去了Map數組的性能。</p><p>所以，要選擇一個合理的大小下進行擴容，默認值0.75就是說當閥值容量佔了3/4s時趕緊擴容，減少Hash碰撞。</p><p>同時0.75是一個默認構造值，在創建HashMap也可以調整，比如你希望用更多的空間換取時間，可以把負載因子調的更小一些，減少碰撞。</p><h1 class=pgc-h-arrow-right>4. 擴容元素拆分</h1><p>為什麼擴容，因為數組長度不足了。那擴容最直接的問題，就是需要把元素拆分到新的數組中。拆分元素的過程中，原jdk1.7中會需要重新計算哈希值，但是到jdk1.8中已經進行優化，不再需要重新計算，提升了拆分的性能，設計的還是非常巧妙的。</p><p><strong>4.1 測試數據</strong></p><pre><code>@Testpublic void test_hashMap() {    List&lt;String&gt; list = new ArrayList&lt;&gt;();    list.add("jlkk");    list.add("lopi");    list.add("jmdw");    list.add("e4we");    list.add("io98");    list.add("nmhg");    list.add("vfg6");    list.add("gfrt");    list.add("alpo");    list.add("vfbh");    list.add("bnhj");    list.add("zuio");    list.add("iu8e");    list.add("yhjk");    list.add("plop");    list.add("dd0p");    for (String key : list) {        int hash = key.hashCode() ^ (key.hashCode() &gt;&gt;&gt; 16);        System.out.println("字符串：" + key + " \tIdx(16)：" + ((16 - 1) &amp; hash) + " \tBit值：" + Integer.toBinaryString(hash) + " - " + Integer.toBinaryString(hash &amp; 16) + " \t\tIdx(32)：" + ((        System.out.println(Integer.toBinaryString(key.hashCode()) +" "+ Integer.toBinaryString(hash) + " " + Integer.toBinaryString((32 - 1) &amp; hash));    }}</code></pre><p><strong>測試結果</strong></p><pre><code>字符串：jlkk    Idx(16)：3   Bit值：1100011101001000010011 - 10000         Idx(32)：191100011101001000100010 1100011101001000010011 10011字符串：lopi    Idx(16)：14  Bit值：1100101100011010001110 - 0         Idx(32)：141100101100011010111100 1100101100011010001110 1110字符串：jmdw    Idx(16)：7   Bit值：1100011101010100100111 - 0         Idx(32)：71100011101010100010110 1100011101010100100111 111字符串：e4we    Idx(16)：3   Bit值：1011101011101101010011 - 10000         Idx(32)：191011101011101101111101 1011101011101101010011 10011字符串：io98    Idx(16)：4   Bit值：1100010110001011110100 - 10000         Idx(32)：201100010110001011000101 1100010110001011110100 10100字符串：nmhg    Idx(16)：13  Bit值：1100111010011011001101 - 0         Idx(32)：131100111010011011111110 1100111010011011001101 1101字符串：vfg6    Idx(16)：8   Bit值：1101110010111101101000 - 0         Idx(32)：81101110010111101011111 1101110010111101101000 1000字符串：gfrt    Idx(16)：1   Bit值：1100000101111101010001 - 10000         Idx(32)：171100000101111101100001 1100000101111101010001 10001字符串：alpo    Idx(16)：7   Bit值：1011011011101101000111 - 0         Idx(32)：71011011011101101101010 1011011011101101000111 111字符串：vfbh    Idx(16)：1   Bit值：1101110010111011000001 - 0         Idx(32)：11101110010111011110110 1101110010111011000001 1字符串：bnhj    Idx(16)：0   Bit值：1011100011011001100000 - 0         Idx(32)：01011100011011001001110 1011100011011001100000 0字符串：zuio    Idx(16)：8   Bit值：1110010011100110011000 - 10000         Idx(32)：241110010011100110100001 1110010011100110011000 11000字符串：iu8e    Idx(16)：8   Bit值：1100010111100101101000 - 0         Idx(32)：81100010111100101011001 1100010111100101101000 1000字符串：yhjk    Idx(16)：8   Bit值：1110001001010010101000 - 0         Idx(32)：81110001001010010010000 1110001001010010101000 1000字符串：plop    Idx(16)：9   Bit值：1101001000110011101001 - 0         Idx(32)：91101001000110011011101 1101001000110011101001 1001字符串：dd0p    Idx(16)：14  Bit值：1011101111001011101110 - 0         Idx(32)：141011101111001011000000 1011101111001011101110 1110</code></pre><ul><li>這裡我們隨機使用一些字符串計算他們分別在16位長度和32位長度數組下的索引分配情況，看哪些數據被重新路由到了新的地址。</li><li>同時，這裡還可以觀察出一個非常重要的信息，原哈希值與擴容新增出來的長度16，進行&運算，如果值等於0，則下標位置不變。如果不為0，那麼新的位置則是原來位置上加16。｛這個地方需要好好理解下，並看實驗數據｝</li><li>這樣一來，就不需要再重新計算每一個數組中元素的哈希值了。</li></ul><p><strong>4.2 數據遷移</strong></p><p><br></p><div class=pgc-img><img alt=HashMap這次是真的懂了，擾動函數、負載因子、擴容拆分全搞定 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/ac4c44c7306f4b2282da04f1e48cbce5><p class=pgc-img-caption></p></div><p><br></p><ul><li>這張圖就是原16位長度數組元素，向32位數組長度中轉移的過程。</li><li>其中黃色區域元素zuio因計算結果 hash & oldCap 不為1，則被遷移到下標位置24。</li><li>同時還是用重新計算哈希值的方式驗證了，確實分配到24的位置，因為這是在二進制計算中補1的過程，所以可以通過上面簡化的方式確定哈希值的位置。</li></ul><h1 class=pgc-h-arrow-right>四、總結</h1><ul><li>如果你能堅持看完這部分內容，並按照文中的例子進行相應的實驗驗證，那麼一定可以學會本章節涉及這五項知識點；1、散列表實現、2、擾動函數、3、初始化容量、4、負載因子、5、擴容元素拆分。</li><li>對我個人來說以前也知道這部分知識，但是沒有驗證過，只知道概念如此，正好藉著寫面試手冊專欄，加深學習，用數據驗證理論，讓知識點可以更加深入的理解。</li><li>這一章節完事，下一章節繼續進行HashMap的其他知識點挖掘，看懂了就是真的懂了。好了，寫到這裡了，感謝大家的閱讀。如果某處沒有描述清楚，或者有不理解的點，歡迎與我討論交流。</li></ul><blockquote class=pgc-blockquote-abstract><p>作者：小傅哥</p><p>鏈接：https://juejin.im/post/6859131648898760717</p><p>來源：掘金</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>HashMap</a></li><li><a>這次</a></li><li><a>擾動</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/6f3b5569.html alt=這次會見，迴應欽州多條鐵路規劃 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RGBQPJ4GiYO6C4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6f3b5569.html title=這次會見，迴應欽州多條鐵路規劃>這次會見，迴應欽州多條鐵路規劃</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/333b0fad.html alt="不再是City pop，這次的cero變得曖昧不明" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1526073827918e584e3a15b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/333b0fad.html title="不再是City pop，這次的cero變得曖昧不明">不再是City pop，這次的cero變得曖昧不明</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html alt="為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6cbd09e4427c44c082e15ec40e24b6f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html title="為什麼 HashMap 的加載因子是0.75？">為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a4aa2bd4.html alt=看看差距在哪兒？這次業務數據分析研判會專奔問題來 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f6f32406244e4eb68df0f27278d5b4ed style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a4aa2bd4.html title=看看差距在哪兒？這次業務數據分析研判會專奔問題來>看看差距在哪兒？這次業務數據分析研判會專奔問題來</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ca84829e.html alt=這次實在點，諾基亞9新手機既給概念圖又給配置參數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afb000248106b59879f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ca84829e.html title=這次實在點，諾基亞9新手機既給概念圖又給配置參數>這次實在點，諾基亞9新手機既給概念圖又給配置參數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e6b071b8.html alt=如何做一名合格的工程項目經理？這次算是講透徹了。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/5c858345-fc82-4858-861c-e7aedd9615db style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e6b071b8.html title=如何做一名合格的工程項目經理？這次算是講透徹了。>如何做一名合格的工程項目經理？這次算是講透徹了。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/772f6295.html alt=開掛的印度這次厲害了，開發出一種鐵離子電池，成本低穩定性高 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9a8b243320d745bdbb8ab95ae2a047f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/772f6295.html title=開掛的印度這次厲害了，開發出一種鐵離子電池，成本低穩定性高>開掛的印度這次厲害了，開發出一種鐵離子電池，成本低穩定性高</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3cb4da7.html alt=章子怡二胎生子：這次“酸兒辣女”準了？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dab5e3629234721afcf3f306b385314 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3cb4da7.html title=章子怡二胎生子：這次“酸兒辣女”準了？>章子怡二胎生子：這次“酸兒辣女”準了？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/991282d2.html alt=一文弄懂擋土牆~這次可算搞明白了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4d8a8092903b44ca8e26431ac3cd16f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/991282d2.html title=一文弄懂擋土牆~這次可算搞明白了！>一文弄懂擋土牆~這次可算搞明白了！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>