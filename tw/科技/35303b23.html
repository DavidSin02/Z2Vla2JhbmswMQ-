<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>C語言/C++程序員內存基礎知識 | 极客快訊</title><meta property="og:title" content="C語言/C++程序員內存基礎知識 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/c0f5c3aa694341fba131408a23e133b1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35303b23.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35303b23.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35303b23.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35303b23.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35303b23.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35303b23.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35303b23.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35303b23.html><meta property="article:published_time" content="2020-11-14T20:59:55+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:55+08:00"><meta name=Keywords content><meta name=description content="C語言/C++程序員內存基礎知識"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/35303b23.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>C語言/C++程序員內存基礎知識</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>C語言是面向過程的，而C＋＋是面向對象的</strong></p><p>C和C++的區別：</p><p>C是一個結構化語言，它的重點在於算法和數據結構。C程序的設計首要考慮的是如何通過一個過程，對輸入（或環境條件）進行運算處理得到輸出（或實現過程（事務）控制）。</p><p>C++，首要考慮的是如何構造一個對象模型，讓這個模型能夠契合與之對應的問題域，這樣就可以通過獲取對象的狀態信息得到輸出或實現過程（事務）控制。 所以C與C++的最大區別在於它們的用於解決問題的思想方法不一樣。之所以說C++比C更先進，是因為“ 設計這個概念已經被融入到C++之中 ”。</p><p>C與C++的最大區別：在於它們的用於解決問題的思想方法不一樣。之所以說C++比C更先進，是因為“ 設計這個概念已經被融入到C++之中 ”，而就語言本身而言，在C中更多的是算法的概念。那麼是不是C就不重要了，錯！算法是程序設計的基礎，好的設計如果沒有好的算法，一樣不行。而且，“C加上好的設計”也能寫出非常好的東西。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=C語言/C++程序員內存基礎知識 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c0f5c3aa694341fba131408a23e133b1><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>在C和C++語言開發中，指針、內存一直是學習的重點。因為C語言作為一種偏底層的中低級語言，提供了大量的內存直接操作的方法，這一方面使程序的靈活度最大化，同時也為bug埋下很多隱患。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=C語言/C++程序員內存基礎知識 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/72c3bc8c2cc045558db868ec82b816a8><p class=pgc-img-caption></p></div><p>因此，無論如何，我們都要對內存有一個清晰的理解。</p><p><strong>1、對內存的分配</strong></p><p>32位操作系統支持4GB內存的連續訪問，但通常把內存分為兩個2GB的空間，每個進程在運行時最大可以使用2GB的私有內存（0x00000000—0x7FFFFFFF）。即理論上支持如下的大數組：</p><p>char szBuffer[2*1024*1024*1024];</p><p>當然，由於在實際運行時，程序還有代碼段、臨時變量段、動態內存申請等，實際上是不可能用到上述那麼大的數組的。</p><p>至於高端的2GB內存地址（0x80000000—0xFFFFFFFF），操作系統一般內部保留使用，即供操作系統內核代碼使用。</p><p>在Windows和Linux平臺上，一些動態鏈接庫（Windows的dll，Linux的so）以及ocx控件等，由於是跨進程服務的，因此一般也在高2GB內存空間運行。</p><p>可以看到，每個進程都能看到自己的2GB內存以及系統的2GB內存，但是不同進程之間是無法彼此看到對方的。當然，操作系統在底層做了很多工作，比如磁盤上的虛擬內存交換（請看下以標題），不同的內存塊動態映射等等。</p><p><strong>2、虛擬內存</strong></p><p>虛擬內存的基本思想是：用廉價但緩慢的磁盤來擴充快速卻昂貴的內存。</p><p>在一定時刻，程序實際需要使用的虛擬內存區段的內容就被載入物理內存中。當物理內存中的數據有一段時間未被使用，它們就可能被轉移到硬盤中，節省下來的物理內存空間用於載入需要使用的其他數據。</p><p>在進程執行過程中，操作系統負責具體細節，使每個進程都以為自己擁有整個地址空間的獨家訪問權。這個幻覺是通過“虛擬內存”實現的。</p><p>所有進程共享機器的物理內存，當內存使用完時就用磁盤保存數據。在進程運行時，數據在磁盤和內存之間來回移動。</p><p>內存管理硬件負責把虛擬地址翻譯為物理地址，並讓一個進程始終運行於系統的真正內存中，應用程序員只看到虛擬地址，並不知道自己的進程在磁盤與內存之間來回切換。</p><p>從潛在的可能性上說，與進程有關的所有內存都將被系統所使用，如果該進程可能不會馬上運行（可能它的優先級低，也可能是它處於睡眠狀態），操作系統可以暫時取回所有分配給它的物理內存資源，將該進程的所有相關信息都備份到磁盤上。</p><p>進程只能操作位於物理內存中的頁面。當進程引用一個不在物理內存中的頁面時，MMU就會產生一個頁錯誤。</p><p>內存對此事做出響應，並判斷該引用是否有效。如果無效，內核向進程發出一個“segmentation violation（段違規）”的信號，內核從磁盤取回該頁，換入內存中，一旦頁面進入內存，進程便被解鎖，可以重新運行——進程本身並不知道它曾經因為頁面換入事件等待了一會。</p><p><strong>3、內存的使用</strong></p><p>對於程序員，我們最重要的是能理解不同進程間私有內存空間的含義。C和C++的編譯器把私有內存分為3塊：基棧、浮動棧和堆。</p><p><strong>基棧：</strong>也叫靜態存儲區，這是編譯器在編譯期間就已經固定下來必須要使用的內存，如程序的代碼段、靜態變量、全局變量、const常量等。</p><p><strong>浮動棧：</strong>很多書上稱為“棧”，就是程序開始運行，隨著函數、對象的一段執行，函數內部變量、對象的內部成員變量開始動態佔用內存，浮動棧一般都有生命週期，函數結束或者對象析構，其對應的浮動棧空間的就拆除了，這部分內容總是變來變去，內存佔用也不是固定，因此叫浮動棧。</p><p><strong>堆：</strong>C和C++語言都支持動態內存申請，即程序運行期可以自由申請內存，這部分內存就是在堆空間申請的。堆位於2GB的最頂端，自上向下分配，這是避免和浮動棧混到一起，不好管理。我們用到malloc和new都是從堆空間申請的內存，new比malloc多了對象的支持，可以自動調用構造函數。另外，new創建對象，其成員變量位於堆裡面。</p><p><strong>我們來看一個例子：</strong></p><p>const int n = 100;</p><p>void Func(void)</p><p>{</p><p>char ch = 0;</p><p>char* pBuff = (char*)malloc(10);</p><p>//…</p><p>}</p><p>這個函數如果運行，其中n由於是全局靜態變量，位於基棧，i和pBuff這兩個函數內部變量，i位於浮動棧，而pBuff指向的由malloc分配的內存區，則位於堆棧。</p><p><strong>在內存理解上，最著名的例子就是線程啟動時的參數傳遞。</strong></p><p>函數啟動一個線程，很多時候需要向線程傳參數，但是線程是異步啟動的，即很可能啟動函數已經退出了，而線程函數都還沒有正式開始運行，因此，絕不能用啟動函數的內部變量給線程傳參。</p><p>道理很簡單，函數的內部變量在浮動棧，但函數退出時，浮動棧自動拆除，內存空間已經被釋放了。當線程啟動時，按照給的參數指針去查詢變量，實際上是在讀一塊無效的內存區域，程序會因此而崩潰。</p><p>那怎麼辦呢？我們應該直接用malloc函數給需要傳遞的參數分配一塊內存區域，將指針傳入線程，線程收到後使用，最後線程退出時，free釋放。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=C語言/C++程序員內存基礎知識 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2684d45345894f34bcc8d343404ceeed><p class=pgc-img-caption></p></div><p><strong>我們來看例子：</strong></p><p>//這個結構體就是參數表</p><p>typedef struct _CListen_ListenAcceptTask_Param_</p><p>{</p><p>Linux_Win_SOCKET m_nSocket;</p><p>//其他參量… …</p><p>}SCListenAcceptTaskParam;</p><p>//習慣性寫法，設置結構體後，立即聲明結構體的尺寸，為後續malloc提供方便</p><p>const ULONG SCListenAcceptTaskParamSize=sizeof(SCListenAcceptTaskParam);</p><p>//這裡接收到連接請求，申請參數區域，將關鍵信息帶入參數區域，幫助後續線程工作。</p><p>bool CListen::ListenTaskCallback(void* pCallParam,int& nStatus)</p><p>{</p><p>//正常的函數邏輯… …</p><p>//假定s是accept到的socket，需要傳入後續線程工作</p><p>//在此準備一塊參數區域，從遠堆上申請</p><p>SCListenAcceptTaskParam* pParam=(SCListenAcceptTaskParam*) malloc(SCListenAcceptTaskParamSize);</p><p>//給參數區域賦值</p><p>pParam->m_nSocket=s;</p><p>//此處啟動線程，將pParam傳遞給線程… …</p><p>//正常的函數邏輯… …</p><p>}</p><p>//這是線程函數，負責處理上文accept到的socket</p><p>bool CListen::ListenAcceptTask(void* pCallParam,int& nStatus)</p><p>{</p><p>//第一句話就是強制指針類型轉換，獲得外界傳入的參數區域</p><p>SCListenAcceptTaskParam* pParam= (SCListenAcceptTaskParam*)pCallParam;</p><p>//正常的函數邏輯… …</p><p>//退出前，必須要做的工作，確保資源不被洩露</p><p>close(pParam->m_nSocket); //關閉socket</p><p>free(pCallParam); // free傳入的參數區域</p><p>//… …</p><p>}</p><p><strong>4、 內存bug</strong></p><p>無規則的濫用內存和指針會導致大量的bug，程序員應該對內存的使用保持高度的敏感性和警惕性，謹慎地使用內存資源。</p><p><strong>使用內存時最容易出現的bug是：</strong></p><p><strong>（1）壞指針值錯誤：</strong></p><p>在指針賦值之前就用它來引用內存，或者向庫函數傳送一個壞指針，第三種可能導致壞指針的原因是對指針進行釋放之後再訪問它的內容。</p><p>可以修改free語句，在指針釋放之後再將它置為空值。</p><p>free(p); p = NULL;</p><p>這樣，如果在指針釋放之後繼續使用該指針，至少程序能在終止之前進行信息轉儲。</p><p><strong>（2）改寫（overwrite）錯誤：</strong></p><p>越過數組邊界寫入數據，在動態分配的內存兩端之外寫入數據，或改寫一些堆管理數據結構（在動態分配內存之前的區域寫入數據就很容易發生這種情況）</p><p>p = malloc(256); p[-1] = 0; p[256] = 0;</p><p><strong>（3）指針釋放引起的錯誤：</strong></p><p>釋放同一個內存塊兩次，或釋放一塊未曾使用malloc分配的內存，或釋放仍在使用中的內存，或釋放一個無效的指針。</p><p>一個極為常見的與釋放內存有關的錯誤就是在for(p=start;p=p->next)這樣的循環中迭代一個鏈表，並在循環體內使用free(p)語句。這樣，在下一次循環迭代時，程序就會對已經釋放的指針進行解除引用操作，從而導致不可預料的結果。</p><p><strong>我們可以這樣迭代：</strong></p><p>struct node *p, *tart, *temp;</p><p>for(p = start; p ; p = temp)</p><p>{</p><p>temp = p->next;</p><p>free(p);</p><p>}</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=C語言/C++程序員內存基礎知識 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7a38146e9a80450a8bf7f96354608f2f><p class=pgc-img-caption></p></div><p>這些是C/C++能做的</p><p>服務器開發工程師、人工智能、雲計算工程師、信息安全（黑客反黑客）、大數據 、數據平臺、嵌入式工程師、流媒體服務器、數據控解、圖像處理、音頻視頻開發工程師、遊戲服務器、分佈式系統、遊戲輔助等</p><p>關於程序員的內存知識，就談到這裡。</p><p><strong>獲取方式：</strong></p><p>1.在你手機的右上角有【關注】選項，或點擊我的頭像，點擊關注！（關注我）</p><p>2.關注後，手機客戶端點擊我的主頁面，右上角有私信，請私信發我：<strong>編程</strong></p><p><strong>電腦已經設置好了關鍵詞自動回覆，</strong>自動領取就好了！這幾天上萬個消息，真的回覆不過來，所以回覆的時候請注意關鍵詞！</p><p class=ql-align-justify>其實做為一個開發者，有一個學習的氛圍跟一個交流圈子特別重要這裡請<strong>私信</strong>我“<strong>編程</strong>”不管你是小白還是大牛歡迎入住大家一起交流成長。小編會在裡面不定期分享乾貨源碼，包括我精心整理的一份c++零基礎教程。歡迎各位感興趣的的小夥伴。</p><p>學習思路：</p><div class=pgc-img><img alt=C語言/C++程序員內存基礎知識 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/30bb42820b3c4be98fdc830cf9905d4e><p class=pgc-img-caption></p></div><p>學習資料：</p><div class=pgc-img><img alt=C語言/C++程序員內存基礎知識 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/57ceef05de8c40639d45b46aba953410><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>語言</a></li><li><a>C++</a></li><li><a>員內存</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a5a90058.html alt=C語言C++中assert的用法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/800dbdf4-3783-4992-8b82-525f32e81100 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a5a90058.html title=C語言C++中assert的用法>C語言C++中assert的用法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e7c6ad4.html alt=CC++語言15｜類的繼承和派生實現代碼重用、擴充 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4983def52247451589ab482f2921c1aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e7c6ad4.html title=CC++語言15｜類的繼承和派生實現代碼重用、擴充>CC++語言15｜類的繼承和派生實現代碼重用、擴充</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8b84bf7a.html alt=CC++語言21｜函數模板與類模板 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8b84bf7a.html title=CC++語言21｜函數模板與類模板>CC++語言21｜函數模板與類模板</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html alt=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d208ccdc7f074f67a257d52df74e4f48 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/82646fb0.html title=C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）>C/C++編程筆記：C語言編程知識要點總結！大一C語言知識點（全）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69fc84d9.html alt=一些經典的C/C++語言基礎算法及代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69fc84d9.html title=一些經典的C/C++語言基礎算法及代碼>一些經典的C/C++語言基礎算法及代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a76b6a9f.html alt=年薪百萬的程序員C++/C語言實現了MFC窗口的自動縮放 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/826bd92ea024450a85fa65541d1a3eeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a76b6a9f.html title=年薪百萬的程序員C++/C語言實現了MFC窗口的自動縮放>年薪百萬的程序員C++/C語言實現了MFC窗口的自動縮放</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a2a610.html alt=CC++語言5｜控制檯和文件的輸入、輸出 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/727f098418fe48e99a1a53ebe74aab7e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a2a610.html title=CC++語言5｜控制檯和文件的輸入、輸出>CC++語言5｜控制檯和文件的輸入、輸出</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8709aab.html alt=C語言/C++和程序設計，編程知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/61590001663cc8dc9852 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8709aab.html title=C語言/C++和程序設計，編程知識>C語言/C++和程序設計，編程知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html alt=什麼是梯度：用形象的語言解讀梯度的本質原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/557c7b377c5449bb885df35b2d354e03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html title=什麼是梯度：用形象的語言解讀梯度的本質原理>什麼是梯度：用形象的語言解讀梯度的本質原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html alt=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S5YRqTH6awaqmG style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html title=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行>我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html alt=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/46ea0001172cab9535dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html title=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用>谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html alt=C++｜自定義偽隨機數和標準庫中的隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26327cd2.html title=C++｜自定義偽隨機數和標準庫中的隨機數>C++｜自定義偽隨機數和標準庫中的隨機數</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>