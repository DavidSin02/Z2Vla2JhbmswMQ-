<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試官：問你一個，Spring事務是如何傳播的？ | 极客快訊</title><meta property="og:title" content="面試官：問你一個，Spring事務是如何傳播的？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/6513100097ce4d27b1df49cd347e4d88"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/358ab5f.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/358ab5f.html><meta property="article:published_time" content="2020-10-29T20:50:41+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:41+08:00"><meta name=Keywords content><meta name=description content="面試官：問你一個，Spring事務是如何傳播的？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/358ab5f.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試官：問你一個，Spring事務是如何傳播的？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>推薦學習</h1><ul><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6844768153789006339/?group_id=6844768153789006339" rel="noopener noreferrer" target=_blank>肝了十天半月，獻上純手繪“Spring/Cloud/Boot/MVC”全家桶腦圖</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6876044225012892163/?group_id=6876044225012892163" rel="noopener noreferrer" target=_blank>瘋狂膜拜！阿里出品Spring Security王者晉級文檔</a></li><li><a class=pgc-link data-content=mp data-source=innerLink href="https://www.toutiao.com/i6865671837171319299/?group_id=6865671837171319299" rel="noopener noreferrer" target=_blank>真香警告！Alibaba珍藏版mybatis手寫文檔，刷起來</a></li></ul><div class=pgc-img><img alt=面試官：問你一個，Spring事務是如何傳播的？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6513100097ce4d27b1df49cd347e4d88><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">前言</span></h1><p style=text-align:start>Spring事務是如何傳播的？</p><p style=text-align:start>其實<span style="color:#4d4d4d;--tt-darkmode-color: #999999">之前有分析事務註解的解析過程，本質上是將事務封裝為切面加入到AOP的執行鏈中，因此會調用到MethodInceptor的實現類的invoke方法，而事務切面的Interceptor就是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TransactionInterceptor</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，所以本篇直接從該類開始。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">事務</span><span style="color:#4f4f4f;--tt-darkmode-color: #979797">切面的調用過程</span></h1><pre><code>	public Object invoke(MethodInvocation invocation) throws Throwable {		// Work out the target class: may be {@code null}.		// The TransactionAttributeSource should be passed the target class		// as well as the method, which may be from an interface.		Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);		// Adapt to TransactionAspectSupport's invokeWithinTransaction...		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這個方法本身沒做什麼事，主要是調用了父類的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">invokeWithinTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，注意最後一個參數，傳入的是一個lambda表達式，而這個表達式中的調用的方法應該不陌生，在分析AOP調用鏈時，就是通過這個方法</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">傳遞到下一個切面</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">或是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">調用被代理實例的方法</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，忘記了的可以回去看看。</span></p><pre><code>	protected Object invokeWithinTransaction(Method method, @Nullable Class&lt;?&gt; targetClass,			final InvocationCallback invocation) throws Throwable {		// If the transaction attribute is null, the method is non-transactional.		//獲取事務屬性類 AnnotationTransactionAttributeSource		TransactionAttributeSource tas = getTransactionAttributeSource();		//獲取方法上面有@Transactional註解的屬性		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);		//獲取事務管理器		final PlatformTransactionManager tm = determineTransactionManager(txAttr);		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);			Object retVal = null;			try {				// 調用proceed方法				retVal = invocation.proceedWithInvocation();			}			catch (Throwable ex) {				// target invocation exception				//事務回滾				completeTransactionAfterThrowing(txInfo, ex);				throw ex;			}			finally {				cleanupTransactionInfo(txInfo);			}			//事務提交			commitTransactionAfterReturning(txInfo);			return retVal;		}			// 省略了else	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這個方法邏輯很清晰，一目瞭然，if裡面就是對聲明式事務的處理，先調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法開啟事務，然後通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">invocation.proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">調用下一個切面，如果沒有其它切面了，就是調用被代理類的方法，出現異常就回滾，否則提交事務，這就是Spring事務切面的執行過程。但是，我們主要要搞懂的就是在這些方法中是如何管理事務以及事務在多個方法之間是如何傳播的。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">事務的傳播性概念</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">傳播性是Spring自己搞出來的，數據庫是沒有的，因為涉及到方法間的調用，那麼必然就需要考慮事務在這些方法之間如何流轉，所以Spring提供了7個傳播屬性供選擇，可以將其看成兩大類，即是否支持當前事務：</span></p><ol start=1><li>支持當前事務（在同一個事務中）：</li></ol><blockquote><p><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">PROPAGATION_REQUIRED：支持當前事務，如果不存在，就新建一個事務。PROPAGATION_MANDATORY：支持當前事務，如果不存在，就拋出異常。PROPAGATION_SUPPORTS：支持當前事務，如果不存在，就不使用事務。</span></p></blockquote><ol start=2><li>不支持當前事務（不在同一個事務中）：</li></ol><blockquote><p><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">PROPAGATION_NEVER：以非事務的方式運行，如果有事務，則拋出異常。PROPAGATION_NOT_SUPPORTED：以非事務的方式運行，如果有事務，則掛起當前事務。PROPAGATION_REQUIRES_NEW：新建事務，如果有事務，掛起當前事務（兩個事務相互獨立，父事務回滾不影響子事務）。PROPAGATION_NESTED：如果當前事務存在，則嵌套事務執行（指必須依存父事務，子事務不能單獨提交且父事務回滾則子事務也必須回滾，而子事務若回滾，父事務可以回滾也可以捕獲異常）。如果當前沒有事務，則進行與PROPAGATION_REQUIRED類似的操作。</span></p></blockquote><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">別看屬性這麼多，實際上我們主要用的是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">默認屬性，一些特殊業務下可能會用到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以及</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_NESTED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">。下面我會假設一個場景，並主要分析這三個屬性。</span></p><pre><code>public class A {		@Autowired	private B b;	@Transactional	public void addA() {		b.addB();	}}public class B {	@Transactional	public void addB() {		// doSomething...	}}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">上面我創建了A、B兩個類，每個類中有一個事務方法，使用了聲明式事務並採用的默認傳播屬性，在A中調用了B的方法。<br>當請求來了調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">時，首先調用的是代理對象的方法，因此會進入</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法開啟事務：</span></p><pre><code>	protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {		// If no name specified, apply method identification as transaction name.		if (txAttr != null &amp;&amp; txAttr.getName() == null) {			txAttr = new DelegatingTransactionAttribute(txAttr) {				@Override				public String getName() {					return joinpointIdentification;				}			};		}		TransactionStatus status = null;		if (txAttr != null) {			if (tm != null) {				//開啟事務，這裡重點看				status = tm.getTransaction(txAttr);			}			else {			}		}		//創建事務信息對象，記錄新老事務信息對象		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">實際上開啟事務是通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">AbstractPlatformTransactionManager</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">做的，而這個類是一個抽象類，具體實例化的對象就是我們在項目裡常配置的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionManager</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象。</span></p><pre><code>	public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {		//這裡重點看，.DataSourceTransactionObject拿到對象		Object transaction = doGetTransaction();		// Cache debug flag to avoid repeated checks.		boolean debugEnabled = logger.isDebugEnabled();		if (definition == null) {			// Use defaults if no transaction definition given.			definition = new DefaultTransactionDefinition();		}		//第一次進來connectionHolder為空的，所以不存在事務		if (isExistingTransaction(transaction)) {			// Existing transaction found -&gt; check propagation behavior to find out how to behave.			return handleExistingTransaction(definition, transaction, debugEnabled);		}		// Check definition settings for new transaction.		if (definition.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) {			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());		}		// No existing transaction found -&gt; check propagation behavior to find out how to proceed.		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {			throw new IllegalTransactionStateException(					"No existing transaction found for transaction marked with propagation 'mandatory'");		}		//第一次進來大部分會走這裡		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			//先掛起			SuspendedResourcesHolder suspendedResources = suspend(null);				if (debugEnabled) {					logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);				}				try {					boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);					//創建事務狀態對象，其實就是封裝了事務對象的一些信息，記錄事務狀態的					DefaultTransactionStatus status = newTransactionStatus(							definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);					//開啟事務,重點看看 DataSourceTransactionObject					doBegin(transaction, definition);					//開啟事務後，改變事務狀態					prepareSynchronization(status, definition);					return status;			}			catch (RuntimeException | Error ex) {				resume(null, suspendedResources);				throw ex;			}		}		else {			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這個方法流程比較長，一步步來看，先調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doGetTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法獲取一個</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionObject</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象，這個類是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">JdbcTransactionObjectSupport</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的子類，在父類中持有了一個</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象，見名知意，這個對象保存了當前的連接。</span></p><pre><code>	protected Object doGetTransaction() {		//管理connection對象，創建回滾點，按照回滾點回滾，釋放回滾點		DataSourceTransactionObject txObject = new DataSourceTransactionObject();		//DataSourceTransactionManager默認是允許嵌套事務的		txObject.setSavepointAllowed(isNestedTransactionAllowed());		//obtainDataSource() 獲取數據源對象，其實就是數據庫連接塊對象		ConnectionHolder conHolder =				(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());		txObject.setConnectionHolder(conHolder, false);		return txObject;	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">追溯</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">getResource</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法可以看到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder 是從ThreadLocal</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">裡獲取的，也就是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當前線程</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，key是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSource</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象；但是仔細思考下我們是第一次進來，所以這裡肯定獲取不到的，反之，要從這裡獲取到值，那必然是同一個線程第二次及以後進入到這裡，也就是在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">時，另外需要注意這裡保存</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionObject</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象時是將</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性設置為</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">false</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">了的。<br>繼續往後，創建完</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">transaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象後，會調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">isExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">判斷是否已經存在一個事務，如果存在就會調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">handleExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，這個方法就是處理事務傳播的核心方法，因為我們是第一次進來，肯定不存在事務，所以先跳過。<br>再往後，可以看到就是處理不同的傳播屬性，主要看到下面這個部分：</span></p><pre><code>		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			//先掛起			SuspendedResourcesHolder suspendedResources = suspend(null);				if (debugEnabled) {					logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);				}				try {					boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);					//創建事務狀態對象，其實就是封裝了事務對象的一些信息，記錄事務狀態的					DefaultTransactionStatus status = newTransactionStatus(							definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);					//開啟事務,重點看看 DataSourceTransactionObject					doBegin(transaction, definition);					//開啟事務後，改變事務狀態					prepareSynchronization(status, definition);					return status;			}			catch (RuntimeException | Error ex) {				resume(null, suspendedResources);				throw ex;			}		}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">第一次進來時，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">、</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_NESTED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">都會進入到這裡，首先會調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">suspend</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">掛起當前存在的事務，在這裡沒啥作用。接下來通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">創建了</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DefaultTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象，這個對象主要就是存儲當前事務的一些狀態信息，需要特別注意</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性設置為了</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">true</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，表示是一個新事務。狀態對象創建好之後就是通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doBegin</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">開啟事務，這是一個</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">模板方法</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">：</span></p><pre><code>	protected void doBegin(Object transaction, TransactionDefinition definition) {		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;		Connection con = null;		try {			//如果沒有數據庫連接			if (!txObject.hasConnectionHolder() ||					txObject.getConnectionHolder().isSynchronizedWithTransaction()) {				//從連接池裡面獲取連接				Connection newCon = obtainDataSource().getConnection();				if (logger.isDebugEnabled()) {					logger.debug("Acquired Connection [" + newCon + "] for JDBC transaction");				}				//把連接包裝成ConnectionHolder，然後設置到事務對象中				txObject.setConnectionHolder(new ConnectionHolder(newCon), true);			}			txObject.getConnectionHolder().setSynchronizedWithTransaction(true);			con = txObject.getConnectionHolder().getConnection();			//從數據庫連接中獲取隔離級別			Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);			txObject.setPreviousIsolationLevel(previousIsolationLevel);			// Switch to manual commit if necessary. This is very expensive in some JDBC drivers,			// so we don't want to do it unnecessarily (for example if we've explicitly			// configured the connection pool to set it already).			if (con.getAutoCommit()) {				txObject.setMustRestoreAutoCommit(true);				if (logger.isDebugEnabled()) {					logger.debug("Switching JDBC Connection [" + con + "] to manual commit");				}				//關閉連接的自動提交，其實這步就是開啟了事務				con.setAutoCommit(false);			}			//設置只讀事務 從這一點設置的時間點開始（時間點a）到這個事務結束的過程中，其他事務所提交的數據，該事務將看不見！			//設置只讀事務就是告訴數據庫，我這個事務內沒有新增，修改，刪除操作只有查詢操作，不需要數據庫鎖等操作，減少數據庫壓力			prepareTransactionalConnection(con, definition);			//自動提交關閉了，就說明已經開啟事務了，事務是活動的			txObject.getConnectionHolder().setTransactionActive(true);			int timeout = determineTimeout(definition);			if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {				txObject.getConnectionHolder().setTimeoutInSeconds(timeout);			}			// Bind the connection holder to the thread.			if (txObject.isNewConnectionHolder()) {				//如果是新創建的事務，則建立當前線程和數據庫連接的關係				TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());			}		}		catch (Throwable ex) {			if (txObject.isNewConnectionHolder()) {				DataSourceUtils.releaseConnection(con, obtainDataSource());				txObject.setConnectionHolder(null, false);			}			throw new CannotCreateTransactionException("Could not open JDBC Connection for transaction", ex);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這個方法裡面主要做了六件事：</span></p><ul><li>首先從連接池獲取連接並保存到<strong>DataSourceTransactionObject</strong>對象中。</li><li>關閉數據庫的<strong>自動提交</strong>，也就是開啟事務。</li><li>獲取數據庫的隔離級別。</li><li>根據屬性設置該事務是否為<strong>只讀事務</strong>。</li><li>將該事務標識為<strong>活動事務</strong>（transactionActive=true）。</li><li>將<strong>ConnectionHolder</strong>對象與當前線程綁定。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">完成之後通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">prepareSynchronization</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">將事務的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">狀態</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">設置到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TransactionSynchronizationManager</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象中進行管理。最後返回到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法中創建</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TransactionInfo</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象與當前線程綁定並返回。<br>通過以上的步驟就開啟了事務，接下來就是通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">調用其它切面，這裡我們先假設沒有其它切面了，那麼就是直接調用到A類的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，在這個方法中又調用了B類的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，那麼肯定也是調用到代理類的方法，因此又會進入到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">createTransactionIfNecessary</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法中。但這次進來通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">isExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">判斷是存在事務的，因此會進入到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">handleExistingTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法：</span></p><pre><code>	private TransactionStatus handleExistingTransaction(			TransactionDefinition definition, Object transaction, boolean debugEnabled)			throws TransactionException {		//不允許有事務，直接異常		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {			throw new IllegalTransactionStateException(					"Existing transaction found for transaction marked with propagation 'never'");		}		//以非事務方式執行操作，如果當前存在事務，就把當前事務掛起		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {			if (debugEnabled) {				logger.debug("Suspending current transaction");			}			//掛起當前事務			Object suspendedResources = suspend(transaction);			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);			//修改事務狀態信息，把事務的一些信息存儲到當前線程中，ThreadLocal中			return prepareTransactionStatus(					definition, null, false, newSynchronization, debugEnabled, suspendedResources);		}		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {			if (debugEnabled) {				logger.debug("Suspending current transaction, creating new transaction with name [" +						definition.getName() + "]");			}			//掛起			SuspendedResourcesHolder suspendedResources = suspend(transaction);			try {				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);				DefaultTransactionStatus status = newTransactionStatus(						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);				doBegin(transaction, definition);				prepareSynchronization(status, definition);				return status;			}			catch (RuntimeException | Error beginEx) {				resumeAfterBeginException(transaction, suspendedResources, beginEx);				throw beginEx;			}		}		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			if (!isNestedTransactionAllowed()) {				throw new NestedTransactionNotSupportedException(						"Transaction manager does not allow nested transactions by default - " +						"specify 'nestedTransactionAllowed' property with value 'true'");			}			if (debugEnabled) {				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");			}			//默認是可以嵌套事務的			if (useSavepointForNestedTransaction()) {				// Create savepoint within existing Spring-managed transaction,				// through the SavepointManager API implemented by TransactionStatus.				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.				DefaultTransactionStatus status =						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);				//創建回滾點				status.createAndHoldSavepoint();				return status;			}			else {				// Nested transaction through nested begin and commit/rollback calls.				// Usually only for JTA: Spring synchronization might get activated here				// in case of a pre-existing JTA transaction.				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);				DefaultTransactionStatus status = newTransactionStatus(						definition, transaction, true, newSynchronization, debugEnabled, null);				doBegin(transaction, definition);				prepareSynchronization(status, definition);				return status;			}		}			// 省略				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這裡面也是對每個傳播屬性的判斷，先看</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的處理，因為該屬性要求每次調用都開啟一個新的事務，所以首先會將當前事務掛起，怎麼掛起呢？</span></p><pre><code>	protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {		if (TransactionSynchronizationManager.isSynchronizationActive()) {			List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();			try {				Object suspendedResources = null;				//第一次進來，肯定為null的				if (transaction != null) {					//吧connectionHolder設置為空					suspendedResources = doSuspend(transaction);				}				//做數據還原操作				String name = TransactionSynchronizationManager.getCurrentTransactionName();				TransactionSynchronizationManager.setCurrentTransactionName(null);				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();				TransactionSynchronizationManager.setActualTransactionActive(false);				return new SuspendedResourcesHolder(						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);			}			catch (RuntimeException | Error ex) {				// doSuspend failed - original transaction is still active...				doResumeSynchronization(suspendedSynchronizations);				throw ex;			}		}		else if (transaction != null) {			// Transaction active but no synchronization active.			Object suspendedResources = doSuspend(transaction);			return new SuspendedResourcesHolder(suspendedResources);		}		else {			// Neither transaction nor synchronization active.			return null;		}	}	protected Object doSuspend(Object transaction) {		DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;		txObject.setConnectionHolder(null);		//解除綁定關係，		return TransactionSynchronizationManager.unbindResource(obtainDataSource());	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這裡明顯是進入第一個if並且會調用到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doSuspend</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，整體來說掛起事務很簡單：首先將</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DataSourceTransactionObject</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">設置為空並解除與當前線程的綁定，之後將解除綁定的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">ConnectionHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其它屬性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">（事務名稱、隔離級別、只讀屬性）通通封裝到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">SuspendedResourcesHolder</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象，並將當前事務的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">活動狀態</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">設置為false。掛起事務之後又通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">創建了一個新的事務狀態並調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doBegin</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">開啟事務，這裡不再重複分析。<br>接著來看</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_NESTED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">：</span></p><pre><code>		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {			if (!isNestedTransactionAllowed()) {				throw new NestedTransactionNotSupportedException(						"Transaction manager does not allow nested transactions by default - " +						"specify 'nestedTransactionAllowed' property with value 'true'");			}			if (debugEnabled) {				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");			}			//默認是可以嵌套事務的			if (useSavepointForNestedTransaction()) {				// Create savepoint within existing Spring-managed transaction,				// through the SavepointManager API implemented by TransactionStatus.				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.				DefaultTransactionStatus status =						prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);				//創建回滾點				status.createAndHoldSavepoint();				return status;			}			else {				// Nested transaction through nested begin and commit/rollback calls.				// Usually only for JTA: Spring synchronization might get activated here				// in case of a pre-existing JTA transaction.				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);				DefaultTransactionStatus status = newTransactionStatus(						definition, transaction, true, newSynchronization, debugEnabled, null);				doBegin(transaction, definition);				prepareSynchronization(status, definition);				return status;			}		}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這裡面可以看到如果允許</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">嵌套事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，就會創建一個</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DefaultTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">對象（注意</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">是false，表明不是一個新事務）和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">回滾點</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">；如果不允許</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">嵌套</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，就會創建</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">新事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">並開啟。<br>當上面的判斷都不滿足時，也就是傳播屬性為默認</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">時，則只是創建了一個</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">newTransaction</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">為false的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">DefaultTransactionStatus</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">返回。<br>完成之後又是調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，那麼就是執行B類的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，假如沒有發生異常，那麼就會回到切面調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">commitTransactionAfterReturning</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">提交</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的事務：</span></p><pre><code>	protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {		if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {			txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());		}	}	public final void commit(TransactionStatus status) throws TransactionException {		processCommit(defStatus);	}	private void processCommit(DefaultTransactionStatus status) throws TransactionException {		try {			boolean beforeCompletionInvoked = false;			try {				boolean unexpectedRollback = false;				prepareForCommit(status);				triggerBeforeCommit(status);				triggerBeforeCompletion(status);				beforeCompletionInvoked = true;				if (status.hasSavepoint()) {					if (status.isDebug()) {						logger.debug("Releasing transaction savepoint");					}					// 如果是nested，沒有提交，只是將savepoint清除掉了					unexpectedRollback = status.isGlobalRollbackOnly();					status.releaseHeldSavepoint();				}				//如果都是PROPAGATION_REQUIRED，最外層的才會走進來統一提交，如果是PROPAGATION_REQUIRES_NEW，每一個事務都會進來				else if (status.isNewTransaction()) {					if (status.isDebug()) {						logger.debug("Initiating transaction commit");					}					unexpectedRollback = status.isGlobalRollbackOnly();					doCommit(status);				}				else if (isFailEarlyOnGlobalRollbackOnly()) {					unexpectedRollback = status.isGlobalRollbackOnly();				}			}		}		finally {			cleanupAfterCompletion(status);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">主要邏輯在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">processCommit</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法中。如果存在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">回滾點</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，可以看到並</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">沒有提交事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，只是將</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當前事務的回滾點</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">清除了；而如果是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">新事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，就會調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">doCommit</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">提交事務，也就是隻有</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性下的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最外層事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性下的事務能提交。事務提交完成後會調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">cleanupAfterCompletion</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">清除當前事務的狀態，如果有掛起的事務還會通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">resume</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">恢復掛起的事務（將解綁的連接和當前線程綁定以及將之前保存的事務狀態重新設置回去）。當前事務正常提交後，那麼就會輪到</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法提交，處理邏輯同上，不再贅述。<br>如果調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addB</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">發生異常，就會通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">completeTransactionAfterThrowing</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">進行回滾：</span></p><pre><code>	protected void completeTransactionAfterThrowing(@Nullable TransactionInfo txInfo, Throwable ex) {		if (txInfo != null &amp;&amp; txInfo.getTransactionStatus() != null) {			if (logger.isTraceEnabled()) {				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() +						"] after exception: " + ex);			}			if (txInfo.transactionAttribute != null &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) {				try {					txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());				}			}		}	}	public final void rollback(TransactionStatus status) throws TransactionException {		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;		processRollback(defStatus, false);	}	private void processRollback(DefaultTransactionStatus status, boolean unexpected) {		try {			boolean unexpectedRollback = unexpected;			try {				triggerBeforeCompletion(status);				//按照嵌套事務按照回滾點回滾				if (status.hasSavepoint()) {					if (status.isDebug()) {						logger.debug("Rolling back transaction to savepoint");					}					status.rollbackToHeldSavepoint();				}				//都為PROPAGATION_REQUIRED最外層事務統一回滾				else if (status.isNewTransaction()) {					if (status.isDebug()) {						logger.debug("Initiating transaction rollback");					}					doRollback(status);				}				else {					// Participating in larger transaction					if (status.hasTransaction()) {						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {							if (status.isDebug()) {								logger.debug("Participating transaction failed - marking existing transaction as rollback-only");							}							doSetRollbackOnly(status);						}						else {							if (status.isDebug()) {								logger.debug("Participating transaction failed - letting transaction originator decide on rollback");							}						}					}					else {						logger.debug("Should roll back transaction but cannot - no transaction available");					}					// Unexpected rollback only matters here if we're asked to fail early					if (!isFailEarlyOnGlobalRollbackOnly()) {						unexpectedRollback = false;					}				}			}			catch (RuntimeException | Error ex) {				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);				throw ex;			}			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);			// Raise UnexpectedRollbackException if we had a global rollback-only marker			if (unexpectedRollback) {				throw new UnexpectedRollbackException(						"Transaction rolled back because it has been marked as rollback-only");			}		}		finally {			cleanupAfterCompletion(status);		}	}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">流程和提交是一樣的，先是判斷有沒有回滾點，如果有就回到到回滾點並清除該回滾點；如果沒有則判斷是不是新事務（</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRED</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性下的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">最外層事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">PROPAGATION_REQUIRES_NEW</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">屬性下的事務），滿足則直接回滾當前事務。回滾完成後同樣需要清除掉當前的事務狀態並恢復掛起的連接。另外需要特別注意的是在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">catch</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">裡面調用完回滾邏輯後，還通過</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">throw</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">拋出了異常，這意味著什麼？意味著即使是嵌套事務，內層事務的回滾也會導致外層事務的回滾，也就是</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的事務也會跟著回滾。<br>至此，事務的傳播原理分析完畢，深入看每個方法的實現是很複雜的，但如果僅僅是分析各個傳播屬性對事務的影響，則有一個簡單的方法。我們可以將內層事務切面</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">等效替換</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">掉</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">invocation.proceedWithInvocation</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">方法，比如上面兩個類的調用可以看作是下面這樣：</span></p><pre><code>// addA的事務TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);Object retVal = null;try {	// addB的事務	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	Object retVal = null;	try {		retVal = invocation.proceedWithInvocation();	}	catch (Throwable ex) {		// target invocation exception		//事務回滾		completeTransactionAfterThrowing(txInfo, ex);		throw ex;	}	finally {		cleanupTransactionInfo(txInfo);	}	//事務提交	commitTransactionAfterReturning(txInfo);}catch (Throwable ex) {	//事務回滾	completeTransactionAfterThrowing(txInfo, ex);	throw ex;}//事務提交commitTransactionAfterReturning(txInfo);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">這樣看是不是很容易就能分析出事務之間的影響以及是提交還是回滾了？下面來看幾個實例分析。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">實例分析</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">我再添加一個C類，和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addC</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的方法，然後在</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">addA</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">裡面調用這個方法。</span></p><pre><code>TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);Object retVal = null;try {	// addB的事務	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	Object retVal = null;	try {		b.addB();	}	catch (Throwable ex) {		// target invocation exception		//事務回滾		completeTransactionAfterThrowing(txInfo, ex);		throw ex;	}	//事務提交	commitTransactionAfterReturning(txInfo);	// addC的事務	TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);	Object retVal = null;	try {		c.addC();	}	catch (Throwable ex) {		// target invocation exception		//事務回滾		completeTransactionAfterThrowing(txInfo, ex);		throw ex;	}	//事務提交	commitTransactionAfterReturning(txInfo);}catch (Throwable ex) {	//事務回滾	completeTransactionAfterThrowing(txInfo, ex);	throw ex;}//事務提交commitTransactionAfterReturning(txInfo);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">等效替換後就是上面這個代碼，我們分別來分析。</span></p><ul><li>都是<strong>PROPAGATION_REQUIRED</strong>屬性：通過上面的分析，我們知道三個方法都是同一個連接和事務，那麼任何一個出現異常則都會回滾。</li><li><strong>addB</strong>為<strong>PROPAGATION_REQUIRES_NEW</strong>：如果B中拋出異常，那麼B中肯定會回滾，接著異常向上拋，導致A事務整體回滾；如果C中拋出異常，不難看出C和A都會回滾，但B已經提交了，因此不會受影響。</li><li><strong>addC</strong>為<strong>PROPAGATION_NESTED</strong>，<strong>addB</strong>為<strong>PROPAGATION_REQUIRES_NEW</strong>：如果B中拋出異常，那麼B回滾並拋出異常，A也回滾，C不會執行；如果C中拋出異常，先是回滾到<strong>回滾點</strong>並拋出異常，所以A也回滾，但B此時已經提交，不受影響。</li><li>都是<strong>PROPAGATION_NESTED</strong>：雖然創建了回滾點，但是仍然是同一個連接，任何一個發生異常都會回滾，如果不想影響彼此，可以try-catch生吞子事務的異常實現。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">還有其它很多情況，這裡就不一一列舉了，只要使用上面的分析方法都能夠很輕鬆的分析出來。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">總結</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">本篇詳細分析了事務的傳播原理，另外還有</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">隔離級別</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，這在Spring中沒有體現，需要我們自己結合數據庫的知識進行分析設置。最後我們還需要考慮</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">聲明式事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">編程式事務</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">的優缺點，聲明式事務雖然簡單，但不適合用在長事務中，會佔用大量連接資源，這時就需要考慮利用編程式事務的靈活性了。總而言之，事務的使用並不是一律默認就好，接口的</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">一致性</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">和</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">吞吐量</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">與事務有著直接關係，嚴重情況下可能會導致系統崩潰。</span></p><blockquote><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">作者：</span>夜勿語</p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">原文鏈接：</span>https://blog.csdn.net/l6108003/article/details/106696735</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>問你</a></li><li><a>一個</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/49fd79dd.html alt=面試官問：一個Java字符串中到底能有多少個字符？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/219afb44975f48c09f4d1cf56b9eed17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49fd79dd.html title=面試官問：一個Java字符串中到底能有多少個字符？>面試官問：一個Java字符串中到底能有多少個字符？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html alt=一個HashMap能跟面試官扯上半個小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html title=一個HashMap能跟面試官扯上半個小時>一個HashMap能跟面試官扯上半個小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html alt=30分鐘教你搭建一個網站（一）：購買和配置服務器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5f26f1582a564e93bde33a7dd9448c3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html title=30分鐘教你搭建一個網站（一）：購買和配置服務器>30分鐘教你搭建一個網站（一）：購買和配置服務器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html alt=不會買服務器？一個辦法讓你輕鬆搭網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84d9c54578de46058796824f1bcb6a9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html title=不會買服務器？一個辦法讓你輕鬆搭網站>不會買服務器？一個辦法讓你輕鬆搭網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html alt=使用服務器搭建一個網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/63a6cc0eb4d146e0890515500c0040ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html title=使用服務器搭建一個網站>使用服務器搭建一個網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html alt=做一個小型網站，服務器需要什麼配置的呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html title=做一個小型網站，服務器需要什麼配置的呢？>做一個小型網站，服務器需要什麼配置的呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html alt=搭建一個網站，租服務器大概多少錢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html title=搭建一個網站，租服務器大概多少錢？>搭建一個網站，租服務器大概多少錢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html alt=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e7b0005767168b2b87d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html title=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！>素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html alt=一個男人每天24小時跟妻子在一起，久而久之會怎樣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8359cc22f03e478a8cdb889dcfea3f99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html title=一個男人每天24小時跟妻子在一起，久而久之會怎樣>一個男人每天24小時跟妻子在一起，久而久之會怎樣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html alt=每天一個好習慣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RKdGgquJFM6gnc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html title=每天一個好習慣>每天一個好習慣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html alt=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/3fd8ec4e-64c1-446a-adfa-38088fb06c01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html title=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點>奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html alt=又一個走上不歸路的搬磚人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf471da0a06441f88bce49b959234257 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html title=又一個走上不歸路的搬磚人>又一個走上不歸路的搬磚人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html alt=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/833949926ebf49b89c5fb4075a9cffdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html title=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏>多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/917424fc.html alt=一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5b430002414bdad7cc1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/917424fc.html title=一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位>一個三年級小孩掌握腦王速記法之數字編碼後倒背如流圓周率1萬位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25157041.html alt=聖胡安（波多黎各）：一個很不美國的美國城市 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d049f3231cda4890ae11c23b2c8f8f70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25157041.html title=聖胡安（波多黎各）：一個很不美國的美國城市>聖胡安（波多黎各）：一個很不美國的美國城市</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>