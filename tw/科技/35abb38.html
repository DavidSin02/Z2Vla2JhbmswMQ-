<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試題第4篇：重寫了equals，還要重寫hashCode？ | 极客快訊</title><meta property="og:title" content="面試題第4篇：重寫了equals，還要重寫hashCode？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/9b1f878c17e84c1caa06a5deda2c10f1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35abb38.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/35abb38.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/35abb38.html><meta property="article:published_time" content="2020-10-29T21:01:26+08:00"><meta property="article:modified_time" content="2020-10-29T21:01:26+08:00"><meta name=Keywords content><meta name=description content="面試題第4篇：重寫了equals，還要重寫hashCode？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/35abb38.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試題第4篇：重寫了equals，還要重寫hashCode？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>《Java面試題系列》：一個長知識又很有意思的專欄。深入挖掘、分析源碼、彙總原理、圖文結合，打造公眾號系列文章，面試與否均可提升Level。歡迎持續關注【程序新視界】。本篇為第4篇。</p></blockquote><p style=text-align:start>核心問題：重寫了equals方法，為什麼還要重寫hashCode方法？</p><p style=text-align:start>這不僅僅是一道面試題，而且是關係到我們的代碼是否健壯和正確的問題。在前面兩篇文章涉及到了equals方法的底層講解：《說說==和equals的區別？你的回答可能是錯誤的》和《Integer等號判斷的內幕，你可能不知道？》。</p><p style=text-align:start>本篇文章，帶大家從底層來分析一下hashcode方法重寫的意義以及如何實現。</p><h1 class=pgc-h-arrow-right>回顧equals方法</h1><p style=text-align:start>我們先回顧一下Object的equals方法實現，並簡單彙總一下使用equals方法的規律。</p><pre><code>public boolean equals(Object obj) {    return (this == obj);}</code></pre><p style=text-align:start>通過上面Object的源代碼，可以得出一個結論：如果一個類未重寫equals方法，那麼本質上通過“==”和equals方法比較的效果是一樣的，都是比較兩個對象的的內存地址。</p><p style=text-align:start>前面兩篇文章講到String和Integer在比較時的區別，關鍵點也是它們對equals方法的實現。</p><p style=text-align:start>面試時總結一下就是：默認情況下，從Object類繼承的equals方法與“==”完全等價，比較的都是對象的內存地址。但我們可以重寫equals方法，使其按照需要進行比較，如String類重寫了equals方法，比較的是字符的序列，而不再是內存地址。</p><h1 class=pgc-h-arrow-right>與hashCode方法的關係</h1><p style=text-align:start>那麼equals方法與hashCode方法又有什麼關係呢？我們來看Object上equals方法的一段註釋。</p><blockquote><p>Note that it is generally necessary to override the hashCode method whenever this method is overridden, so as to maintain the general contract for the hashCode method, which states that equal objects must have equal hash codes.</p></blockquote><p style=text-align:start>大致意思是：當重寫equals方法後有必要將hashCode方法也重寫，這樣做才能保證不違背hashCode方法中“相同對象必須有相同哈希值”的約定。</p><p style=text-align:start>此處只是提醒了我們重寫hashCode方法的必要性，那其中提到的hashCode方法設計約定又是什麼呢？相關的內容定義在hashCode方法的註解部分。</p><h1 class=pgc-h-arrow-right>hashCode方法約定</h1><p style=text-align:start>關於hashCode方法的約定原文比較多，大家直接看源碼即可看到，這裡彙總一下，共三條：</p><p style=text-align:start>（1）如果對象在使用equals方法中進行比較的參數沒有修改，那麼多次調用一個對象的hashCode()方法返回的哈希值應該是相同的。</p><p style=text-align:start>（2）如果兩個對象通過equals方法比較是相等的，那麼要求這兩個對象的hashCode方法返回的值也應該是相等的。</p><p style=text-align:start>（3）如果兩個對象通過equals方法比較是不同的，那麼也不要求這兩個對象的hashCode方法返回的值是不相同的。但是我們應該知道對於不同對象產生不同的哈希值對於哈希表(HashMap等)能夠提高性能。</p><p style=text-align:start>其實，看到這裡我們瞭解了hashCode的實現規約，但還是不清楚為什麼實現equals方法需要重寫hashCode方法。但我們可以得出一條規律：hashCode方法實際上必須要完成的一件事情就是，為equals方法認定為相同的對象返回相同的哈希值。</p><p style=text-align:start>其實在上面規約中提到了哈希表，這也正是hashCode方法運用的場景之一，也是我們為什麼要重寫的核心。</p><h1 class=pgc-h-arrow-right>hashCode應用場景</h1><p style=text-align:start>如果瞭解HashMap的數據結構，就會知道它用到“鍵對象”的哈希碼，當我們調用put方法或者get方法對Map容器進行操作時，都是根據鍵對象的哈希碼來計算存儲位置的。如果我們對哈希碼的獲取沒有相關保證，就可能會得不到預期的結果。</p><div class=pgc-img><img alt=面試題第4篇：重寫了equals，還要重寫hashCode？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9b1f878c17e84c1caa06a5deda2c10f1><p class=pgc-img-caption></p></div><p style=text-align:start>而對象的哈希碼的獲取正是通過hashCode方法獲取的。如果自定義的類中沒有實現該方法，則會採用Object中的hashCode()方法。</p><p style=text-align:start>在Object中該方法是一個本地方法，會返回一個int類型的哈希值。可以通過將對象的內部地址轉換為整數來實現的，但是Java中沒有強制要求通過該方式實現。</p><p style=text-align:start>具體實現網絡上有不同的說法，有說通過內置地址轉換得來，也有說“OpenJDK8默認hashCode的計算方法是通過和當前線程有關的一個隨機數+三個確定值，運用Marsaglia's xorshift scheme隨機數算法得到的一個隨機數”獲得。</p><p style=text-align:start>無論默認實現是怎樣的，大多數情況下都無法滿足equals方法相同，同時hashCode結果也相同的條件。比如下面的示例重寫與否差距很大。</p><pre><code>public void test1() {	String s = "ok";	StringBuilder sb = new StringBuilder(s);	System.out.println(s.hashCode() + "  " + sb.hashCode());	String t = new String("ok");	StringBuilder tb = new StringBuilder(s);	System.out.println(t.hashCode() + "  " + tb.hashCode());}</code></pre><p style=text-align:start>上面這段代碼打印的結果為：</p><pre><code>3548  18336389143548  1620303253</code></pre><p style=text-align:start>String實現了hashCode方法，而StringBuilder並沒有實現，這就導致即使值是一樣的，hashCode也不同。</p><p style=text-align:start>上個示例中問題還不太明顯，下面我們以HashMap為例，看看如果沒有實現hashCode方法會導致什麼嚴重的後果。</p><pre><code>@Testpublic void test2() {	String hello = "hello";	Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();	String s1 = new String("key");	String s2 = new String("key");	map1.put(s1, hello);	System.out.println("s1.equals(s2):" + s1.equals(s2));	System.out.println("map1.get(s1):" + map1.get(s1));	System.out.println("map1.get(s2):" + map1.get(s2));	Map&lt;Key, String&gt; map2 = new HashMap&lt;&gt;();	Key k1 = new Key("A");	Key k2 = new Key("A");	map2.put(k1, hello);	System.out.println("k1.equals(k2):" + s1.equals(s2));	System.out.println("map2.get(k1):" + map2.get(k1));	System.out.println("map2.get(k2):" + map2.get(k2));}class Key {	private String k;	public Key(String key) {		this.k = key;	}	@Override	public boolean equals(Object obj) {		if (obj instanceof Key) {			Key key = (Key) obj;			return k.equals(key.k);		}		return false;	}}</code></pre><p style=text-align:start>實例中定義了內部類Key，其中實現了equals方法，但未實現hashCode方法。存放於Map中的value值都是字符串“hello”。</p><p style=text-align:start>代碼分兩段，第一段演示當Map的key通過實現了hashCode的String時是什麼效果；第二段演示了當Map的key通過未實現hashCode方法的Key對象時是什麼效果。</p><p style=text-align:start>執行上述代碼，打印結果如下：</p><pre><code>s1.equals(s2):truemap1.get(s1):hellomap1.get(s2):hellok1.equals(k2):truemap2.get(k1):hellomap2.get(k2):null</code></pre><p style=text-align:start>分析結果可以看出，對於String作為key的s1和s2來說，通過equals比較相等是自然的，獲得的值也是相同的。但k1和k2通過equals比較是相等，但為什麼在Map中獲得的結果卻不一樣？本質上就是因為沒有重寫hashCode方法導致Map在存儲和獲取過程中調用hashCode方法獲得的值不一致。</p><p style=text-align:start>此時在Key類中添加hashCode方法：</p><pre><code>@Overridepublic int hashCode(){	return k.hashCode();}</code></pre><p style=text-align:start>再次執行，便可正常獲得對應的值。</p><pre><code>s1.equals(s2):truemap1.get(s1):hellomap1.get(s2):hellok1.equals(k2):truemap2.get(k1):hellomap2.get(k2):hello</code></pre><p style=text-align:start>通過上面的典型實例演示了不重寫hashCode方法的潛在後果。簡單看一下HashMap中的put方法。</p><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // 通過哈希值來查找底層數組位於該位置的元素p，如果p不為null，則使用新的鍵值對來覆蓋舊的鍵值對    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    else {        Node&lt;K,V&gt; e; K k;        // (二者哈希值相等)且(二者地址值相等或調用equals認定相等)。        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            for (int binCount = 0; ; ++binCount) {                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        // 如果底層數組中存在傳入的Key，那麼使用新傳入的覆蓋掉查到的        if (e != null) { // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p style=text-align:start>在上述方法中，put方法在拿到key的第一步就對key對象調用了hashCode方法。暫且不看後面的代碼，如果沒有重寫hashCode方法，就無法確保key的hash值一致，後續操作就是兩個key的操作了。</p><h1 class=pgc-h-arrow-right>重寫hashCode方法</h1><p style=text-align:start>瞭解了重寫hashCode方法的重要性，也瞭解了對應的規約，那麼下面我們就聊聊如何優雅的重寫hashCode方法。</p><p style=text-align:start>首先，如果使用IDEA的話，那麼直接使用快捷鍵即可。</p><div class=pgc-img><img alt=面試題第4篇：重寫了equals，還要重寫hashCode？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0ff7d86bc96d4a43bb149b499f35d8a1><p class=pgc-img-caption></p></div><p style=text-align:start>生成的效果如下：</p><pre><code>@Overridepublic boolean equals(Object o) {	if (this == o) {		return true;	}	if (o == null || getClass() != o.getClass()) {		return false;	}	Key key = (Key) o;	return Objects.equals(k, key.k);}@Overridepublic int hashCode() {	return Objects.hash(k);}</code></pre><p style=text-align:start>根據需要可對生成的方法內部實現進行修改。在上面的實例中用到了java.util.Objects類，它的hash方法的優點是如果參數為null，就只返回0，否則返回對象參數調用的hashCode的結果。Objects.hash方法源碼如下：</p><pre><code>public static int hash(Object... values) {    return Arrays.hashCode(values);}</code></pre><p style=text-align:start>其中Arrays.hashCode方法源碼如下：</p><pre><code>public static int hashCode(Object a[]) {    if (a == null)        return 0;    int result = 1;    for (Object element : a)        result = 31 * result + (element == null ? 0 : element.hashCode());    return result;}</code></pre><p style=text-align:start>當然此處只有一個參數，也可以直接使用Objects類hashCode方法：</p><pre><code>public static int hashCode(Object o) {    return o != null ? o.hashCode() : 0;}</code></pre><p style=text-align:start>如果是多個屬性都參與hash值的情況建議可使用第一個方法。只不過需要注意，在類結構（成員變量）變動時，同步增減方法裡面的參數值。</p><h1 class=pgc-h-arrow-right>小結</h1><p style=text-align:start>當我們準備面試時，一直在背誦“實現equals方法的同時也要實現hashCode方法”，牢記這些結論並沒有錯。但我們也不能因為匆忙準備面試題，而忘記了這些面試題之所以頻繁出現的原因是什麼。當深入探索之後，會發現在那些枯燥的結論背後還有這麼多不容忽視的知識點，還有這麼多有意思的設計與陷阱。</p><p style=text-align:start>我是覺得越研究越有意思，越研究越發現自己曾經的無知。你呢？關注一下，期待下一篇文章吧。</p><blockquote class=pgc-blockquote-abstract><p>原文首發於公眾號：程序新視界</p></blockquote></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>重寫</a></li><li><a>面試題</a></li><li><a>equals</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ffb4d729.html alt=「每天一道面試題」檢查異常和非檢查異常的區別？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/152112070414787f2e33262 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ffb4d729.html title=「每天一道面試題」檢查異常和非檢查異常的區別？>「每天一道面試題」檢查異常和非檢查異常的區別？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2fbc1300.html alt=「1」進大廠必須掌握的面試題-Java面試-基礎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/341e49df891246c393403d5830f527b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2fbc1300.html title=「1」進大廠必須掌握的面試題-Java面試-基礎>「1」進大廠必須掌握的面試題-Java面試-基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4dc3025b.html alt=通過面試題，讓我們來了解Collection（上） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/550c769d-28b7-4554-917c-dec18597106d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4dc3025b.html title=通過面試題，讓我們來了解Collection（上）>通過面試題，讓我們來了解Collection（上）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/37a264ca.html alt=java基礎面試題之一 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37a264ca.html title=java基礎面試題之一>java基礎面試題之一</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6bee4520.html alt="PHP面試題 2018" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/112dc009366d4f48b0ed309fcee556cb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6bee4520.html title="PHP面試題 2018">PHP面試題 2018</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f81c047e.html alt=php面試題2020 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f977fd78-d8cc-462b-8ee7-9002d9d87cd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f81c047e.html title=php面試題2020>php面試題2020</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6414a970.html alt=PHP面試題大全（值得收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6414a970.html title=PHP面試題大全（值得收藏）>PHP面試題大全（值得收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html alt=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15208700392878e896bf9c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html title=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理>Java面試題：詳細說明一下可重入鎖ReentrantLock的原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c933652.html alt=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/305b744c-4e26-4f9a-8ab5-bed383199d42 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c933652.html title=阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！>阿里巴巴Netty面試有多難？史上最全Netty面試題總結告訴你！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/caebf494.html alt=僅hashmap一道面試題我就搞定了面試官成功入職面試官：我裂開了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bdc28a09cd4b4ed2aa8b9250cf6e1065 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/caebf494.html title=僅hashmap一道面試題我就搞定了面試官成功入職面試官：我裂開了>僅hashmap一道面試題我就搞定了面試官成功入職面試官：我裂開了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38f9fcd1.html alt=2020新版Java集合容器面試題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38f9fcd1.html title=2020新版Java集合容器面試題>2020新版Java集合容器面試題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cefbea7b.html alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa8f670cc244471e91fa0a25af703002 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cefbea7b.html title=「Java面試題精華集」1w字的Java集合框架篇（2020最新版）>「Java面試題精華集」1w字的Java集合框架篇（2020最新版）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63e646bf.html alt=面試題：來，問你幾個關於HashMap的問題？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5f20ae3cdd6e48c48472055c9b03123d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63e646bf.html title=面試題：來，問你幾個關於HashMap的問題？>面試題：來，問你幾個關於HashMap的問題？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c15b9453.html alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c15b9453.html title=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較>大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/03886d2.html alt=面試題-數組、鏈表實現棧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f8949fd55a4149feb3b5ab31b631c77f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/03886d2.html title=面試題-數組、鏈表實現棧>面試題-數組、鏈表實現棧</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>