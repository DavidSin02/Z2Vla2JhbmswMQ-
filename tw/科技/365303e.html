<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>管理 Vue 應用中的異步調用 vue-asyn-manager | 极客快訊</title><meta property="og:title" content="管理 Vue 應用中的異步調用  vue-asyn-manager  - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/7837421e-5bde-40e0-bcc4-4bd94bb40374"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/365303e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/365303e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/365303e.html><meta property="article:published_time" content="2020-10-29T20:59:17+08:00"><meta property="article:modified_time" content="2020-10-29T20:59:17+08:00"><meta name=Keywords content><meta name=description content="管理 Vue 應用中的異步調用  vue-asyn-manager"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/365303e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>管理 Vue 應用中的異步調用 vue-asyn-manager</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>使用 vue-asyn-manager 管理 Vue 應用中的異步調用</strong></h1><div class=pgc-img><img alt="管理 Vue 應用中的異步調用  vue-asyn-manager" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/7837421e-5bde-40e0-bcc4-4bd94bb40374><p class=pgc-img-caption></p></div><p>不知道大家對 React Suspense 是否有過關注，也許 Suspense 讓人比較激動的是在服務端的流式渲染，然而從目前來看，React Suspense 的功能其實就是個 Loadable。當然啦這是我個人的看法，不過這不是今天的重點，今天的重點是介紹如何在 Vue 應用中更好的管理異步調用，那為什麼會扯到 React Suspense 呢？因為 vue-async-manager 的靈感來自於 React Suspense，因此讓我們開始吧。</p><p>vue-async-manager 是一個開源項目：</p><ul><li>https://shuidi-fed.github.io/vue-async-manager/</li></ul><h1>指南</h1><blockquote><p>在 Vue 應用中更輕鬆的管理異步調用</p></blockquote><p>異步調用指的是什麼？</p><p>這裡所說的異步調用，主要指的是兩件事兒：</p><ul><li>異步組件(Async Component)的加載</li><li>發送異步請求從 API 中獲取數據</li></ul><p>等待異步組件的加載</p><p>實際上 Vue 的異步組件已經支持在加載過程中展示 loading 組件的功能，如下代碼取自官網：</p><pre>new Vue({ // ... components: { 'my-component': () =&gt; ({ // 異步組件 component: import('./my-async-component'), // 加載異步組件過程中展示的 loading 組件 loading: LoadingComponent, // loading 組件展示的延遲時間 delay: 200 }) }})複製代碼</pre><p>:::tip delay 用於指定 loading 組件展示的延遲時間，如上代碼中延遲時間為 200ms，如果異步組件的加載在 200ms 之內完成，則 loading 組件就沒有展示的機會。 :::</p><p>但它存在兩個問題：</p><ul><li>1、loading 組件與異步組件緊密關聯，無法將 loading 組件提升，並用於多個異步組件的加載。</li><li>2、如果異步組件自身仍有異步調用，例如請求 API，那麼 loading 組件是不會等待 API 請求完成之後才隱藏的。</li></ul><p>vue-async-manager 提供了 &lt;Suspense> 組件，可以解決如上兩個問題。</p><p>1、使用 lazy 函數創建異步組件</p><p>過去我們創建一個異步組件的方式是：</p><pre>const asyncComponent = () =&gt; import('./my-async.component.vue')複製代碼</pre><p>現在我們使用 vue-async-manager 提供的 lazy 函數來創建異步組件：</p><pre>import { lazy } from 'vue-async-manager' const asyncComponent = lazy(() =&gt; import('./my-async.component.vue'))複製代碼</pre><p>如上代碼所示，僅僅是將原來的異步工廠函數作為參數傳遞給 lazy 函數即可。</p><p>2、使用 &lt;Suspense> 組件包裹異步組件</p><pre>&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 使用 Suspense 組件包裹可能出現異步組件的組件樹 --&gt; &lt;Suspense&gt; &lt;!-- 展示 loading --&gt; &lt;div slot="fallback"&gt;loading&lt;/div&gt; &lt;!-- 異步組件 --&gt; &lt;asyncComponent1/&gt; &lt;asyncComponent2/&gt; &lt;/Suspense&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 創建異步組件const asyncComponent1 = lazy(() =&gt; import('./my-async.component1.vue'))const asyncComponent2 = lazy(() =&gt; import('./my-async.component2.vue')) export default { name: 'App', components: { // 註冊組件 asyncComponent1, asyncComponent2 }}&lt;/script&gt;複製代碼</pre><p>只有當 &lt;asyncComponent1/> 和 &lt;asyncComponent2/> 全部加載完畢後，loading 組件才會消失。</p><div class=pgc-img><img alt="管理 Vue 應用中的異步調用  vue-asyn-manager" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/e0f9f202-5848-411d-a36b-fd7db67d6447><p class=pgc-img-caption></p></div><p>:::tip Live Demo: 等待所有異步組件加載完畢 :::</p><p>配合 vue-router 使用</p><p>我們在開發 Vue 應用時，最常使用異步組件的方式是配合 vue-router 做代碼拆分，例如：</p><pre>const router = new VueRouter({ routes: [ { path: '/', component: () =&gt; import('./my-async-component.vue') } ]})複製代碼</pre><p>為了讓 &lt;Suspense> 組件等待這個異步組件的加載，我們可以使用 lazy 函數包裹這個異步組件工廠函數：</p><pre>const router = new VueRouter({ routes: [ { path: '/', component: lazy(() =&gt; import('./my-async-component.vue')) } ]})複製代碼</pre><p>最後我們只需要用 &lt;Suspense> 組件包裹渲染出口(&lt;router-view>)即可：</p><pre>&lt;Suspense :delay="200"&gt; &lt;div slot="fallback"&gt;loading&lt;/div&gt; &lt;!-- 渲染出口 --&gt; &lt;router-view/&gt;&lt;/Suspense&gt;複製代碼</pre><p>:::tip Live Demo: 配合 vue-router :::</p><p>API請求中如何展示 loading</p><p>過去，大多是手動維護 loading 的展示，例如“開始請求”時展示 loading，“請求結束”後隱藏 loading。而且如果有多個請求併發時，你就得等待所有請求全部完成後再隱藏 loading。總之你需要自己維護 loading 的狀態，無論這個狀態是存儲在組件內，還是 store 中。</p><p>現在來看看 vue-async-manager 是如何解決 API 請求過程中 loading 展示問題的，假設有如下代碼：</p><pre>&lt;Suspense&gt; &lt;div slot="fallback"&gt;loading...&lt;/div&gt; &lt;MyComponent/&gt;&lt;/Suspense&gt;複製代碼</pre><p>在 &lt;Suspense> 組件內渲染了 &lt;MyComponent> 組件，該組件是一個普普通通的組件，在該組件內部，會發送 API 請求，如下代碼所示：</p><pre>&lt;!-- MyComponent.vue --&gt;&lt;template&gt; &lt;!-- 展示請求回來的數據 --&gt; &lt;div&gt;{{ res }}&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import { getAsyncData } from 'api' export default { data: { res: {} }, async created() { // 異步請求數據 this.res = await getAsyncData(id) }}&lt;/script&gt;複製代碼</pre><p>這是我們常見的代碼，通常在 created 或者 mounted 鉤子中發送異步請求獲取數據，然而這樣的代碼對於 &lt;Suspense> 組件來說，它並不知道需要等待異步數據獲取完成後再隱藏 loading。為了解決這個問題，我們可以使用 vue-async-manager 提供的 createResource 函數創建一個<strong>資源管理器</strong>：</p><pre>&lt;template&gt; &lt;!-- 展示請求回來的數據 --&gt; &lt;div&gt;{{ $rm.$result }}&lt;/div&gt;&lt;/template&gt; &lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 創建一個資源管理器 this.$rm = createResource((params) =&gt; getAsyncData(params)) // 讀取數據 this.$rm.read(params) }}&lt;/script&gt;複製代碼</pre><p>為 createResource 函數傳遞一個工廠函數，我們創建了一個<strong>資源管理器</strong> $rm，接著調用資源管理器的 $rm.read() 函數進行讀取數據。大家注意，上面的代碼是以同步的方式來編寫的，並且 &lt;Suspense> 組件能夠知道該組件正在進行異步調用，因此 &lt;Suspense> 組件將等待該異步調用結束之後再隱藏 loading。</p><p>另外我們觀察如上代碼中的模板部分，我們展示的數據是 $rm.$result，實際上異步數據獲取成功之後，得到的數據會保存在<strong>資源管理器</strong>的 $rm.$result 屬性上，需要注意的是，該屬性本身就是響應式的，因此你無需在組件的 data 中事先聲明。</p><hr><p>:::tip Live Demo: Suspense 組件等待資源管理器獲取數據完成 :::</p><p>配合 vuex</p><p>配合 vuex 很簡單，只需要使用 mapActions 將 actions 映射為方法即可：</p><pre>export default { name: "AsyncComponent", methods: { ...mapActions(['increase']) }, created() { this.$rm = createResource(() =&gt; this.increase()) this.$rm.read() }};複製代碼</pre><p>:::tip Live Demo: 配合 vuex :::</p><p>捕獲組件樹中的所有異步調用</p><p>&lt;Suspense> 組件不僅能捕獲異步組件的加載，如果該異步組件自身還有其他的異步調用，例如通過<strong>資源管理器</strong>獲取數據，那麼 &lt;Suspense> 組件也能夠捕獲到這些異步調用，並等待所有異步調用結束之後才隱藏 loading 狀態。</p><p>我們來看一個例子：</p><pre>&lt;Suspense&gt; &lt;div slot="fallback"&gt;loading&lt;/div&gt; &lt;!-- MyLazyComponent 是通過 lazy 函數創建的組件 --&gt; &lt;MyLazyComopnent/&gt;&lt;/Suspense&gt;複製代碼</pre><p>在這段代碼中，&lt;MyLazyComopnent/> 組件是一個通過 lazy 函數創建的組件，因此 &lt;Suspense> 組件可以等待該異步組件的加載，然而異步組件自身又通過<strong>資源管理器</strong>獲取數據：</p><pre>// 異步組件export default { created() { // 創建一個資源管理器 this.$rm = createResource((params) =&gt; getAsyncData(params)) this.$rm.read(params) }}複製代碼</pre><p>這時候，&lt;Suspense> 組件會等待兩個異步調用全部結束之後才隱藏 loading，這兩個異步調用分別是：</p><ul><li>1、異步組件的加載</li><li>2、異步組件內部通過<strong>資源管理器</strong>發出的異步請求</li></ul><p>:::tip 這個 Demo 也展示瞭如上描述的功能：</p><p>Live Demo: Suspense 組件等待資源管理器獲取數據完成 :::</p><p>資源管理器</p><p>前面我們一直在強調一個詞：<strong>資源管理器</strong>，我們把通過 createResource() 函數創建的對象稱為<strong>資源管理器(Resource Manager)</strong>，因此我們約定使用名稱 $rm 來存儲 createResource() 函數的返回值。</p><p>資源管理器的完整形態如下：</p><pre>this.$rm = createResource(() =&gt; getAsyncData())this.$rm = { read(){}, // 一個函數，調用該函數會真正發送異步請求獲取數據 $result, // 初始值為 null，異步數據請求成功後，保存著取得的數據 $error, // 初始值為 null，當異步請求出錯時，其保存著 err 數據 $loading, // 一個boolean值，初始值為 false，代表著是否正在請求中 fork() // 根據已有資源管理器 fork 一個新的資源管理器}複製代碼</pre><p>其中 $rm.read() 函數用來發送異步請求獲取數據，可多次調用，例如點擊按鈕再次調用其獲取數據。$rm.$result 我們也已經見過了，用來存儲異步獲取來的數據。$rm.$loading 是一個布爾值，代表著請求是否正在進行中，通常我們可以像如下這樣自定義 loading 展示：</p><pre>&lt;template&gt; &lt;!-- 控制 loading 的展示 --&gt; &lt;MyButton :loading="$rm.$loading" @click="submit" &gt;提交&lt;/MyButton&gt;&lt;/template&gt; &lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 創建一個資源管理器 this.$rm = createResource((id) =&gt; getAsyncData(id)) }, methods: { submit() { this.$rm.read(id) } }}&lt;/script&gt;複製代碼</pre><p>:::tip 更重要的一點是：<strong>資源管理器可以脫離 &lt;Suspense> 單獨使用。</strong> :::</p><p>如果資源管理器在請求數據的過程中發生了錯誤，則錯誤數據會保存在 $rm.$error 屬性中。$rm.fork() 函數用來根據已有<strong>資源管理器</strong>創建一個一模一樣的資源管理器出來。</p><p>fork 一個資源管理器</p><p>當一個 API 用來獲取數據，並且我們需要併發的獲取兩次數據，那麼只需要調用兩次 $rm.read() 即可：</p><pre>&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 創建一個資源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type))  // 連續獲取兩次數據 this.$rm.read('top') this.$rm.read('bottom') }}&lt;/script&gt;複製代碼</pre><p>但是這麼做會產生一個問題，由於一個<strong>資源管理器</strong>對應一個 $rm.$result，它只維護一份請求回來的數據以及 loading 狀態，因此如上代碼中，$rm.$result 最終只會保存 $rm.read('bottom') 的數據。當然了，有時候這是符合需求的，但如果需要保存兩次調用的數據，那麼就需要 fork 出一個新的資源管理器：</p><pre>&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 創建一個資源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type)) this.$rm2 = this.$rm.fork()  // 連續獲取兩次數據 this.$rm.read('top') this.$rm2.read('bottom') }}&lt;/script&gt;複製代碼</pre><p>這樣，由於 $rm 與 $rm2 是兩個獨立的資源管理器，因此它們互不影響。</p><p>prevent 選項與防止重複提交</p><p>假設我們正在提交表單，如果用戶連續兩次點擊按鈕，就會造成重複提交，如下例子：</p><pre>&lt;template&gt; &lt;button @click="submit"&gt;提交&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 創建一個資源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type)) }, methods: { submit() { this.$rm.read(data) } }}&lt;/script&gt;複製代碼</pre><p>實際上，我們可以在創建資源管理器的時候提供 prevent 選項，這樣創建出來的資源管理器將自動為我們防止重複提交：</p><pre>&lt;template&gt; &lt;button @click="submit"&gt;提交&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import { getAsyncData } from 'api'import { createResource } from 'vue-async-manager' export default { created() { // 創建一個資源管理器 this.$rm = createResource((type) =&gt; getAsyncData(type), { prevent: true }) }, methods: { submit() { this.$rm.read(data) } }}&lt;/script&gt;複製代碼</pre><p>當第一次點擊按鈕時會發送一個請求，在這個請求完成之前，將不會再次發送下一次請求。直到上一次請求完成之後，$rm.read() 函數才會再次發送請求。</p><p>loading 的展示形態</p><p>loading 的展示形態可以分為兩種：一種是隻展示 loading，不展示其他內容；另一種是正常渲染其他內容的同時展示 loading，比如頁面頂部有一個長長的加載條，這個加載條不影響其他內容的正常渲染。</p><p>因此 vue-async-manager 提供了兩種渲染模式：</p><pre>import VueAsyncManager from 'vue-async-manager'Vue.use(VueAsyncManager, { mode: 'visible' // 指定渲染模式，可選值為 'visible' | 'hidden'，默認值為：'visible'})複製代碼</pre><p>默認情況下采用 'visible' 的渲染模式，意味著 loading 的展示可以與其他內容共存，如果你不想要這種渲染模式，你可以指定 mode 為 'hidden'。</p><p>另外以上介紹的內容都是由 &lt;Suspense> 組件來控制 loading 的展示，並且 loading 的內容由 &lt;Suspense> 組件的 fallback 插槽決定。但有的時候我們希望更加靈活，我們經常遇到這樣的場景：點擊按鈕的同時在按鈕上展示一個微小的 loading 狀態，我們的代碼看上去可能是這樣的：</p><pre>&lt;MyButton :loading="isLoading" &gt;提交&lt;/MyButton&gt;複製代碼</pre><p>loading 的形態由 &lt;MyButton> 組件提供，換句話說，我們拋棄了 &lt;Suspense> 的 fallback 插槽作為 loading 來展示。因此，我們需要一個手段來得知當前是否處於正在加載的狀態，在上面我們已經介紹了該問題的解決辦法，我們可以使用資源管理器的 $rm.$loading 屬性：</p><pre>&lt;MyButton :loading="$rm.$loading" &gt;提交&lt;/MyButton&gt;複製代碼</pre><p>錯誤處理</p><p>當 lazy 組件加載失敗會展示 &lt;Suspense> 組件的 error 插槽，你也可以通過監聽 &lt;Suspense> 的 rejected 事件來自定義錯誤處理。</p><p>:::tip Live Demo: 加載失敗展示 error 插槽 :::</p><p>當錯誤發生時除了展示 error 插槽，你還可以通過監聽 &lt;Suspense> 組件的 rejected 事件來自定義處理：</p><pre>&lt;template&gt; &lt;Suspense :delay="200" @rejected="handleError"&gt; &lt;p class="fallback" slot="fallback"&gt;loading&lt;/p&gt; &lt;AsyncComponent/&gt; &lt;/Suspense&gt;&lt;/template&gt;&lt;script&gt;export default { // ...... methods: { handleError() { // Custom behavior } }};&lt;/script&gt;複製代碼</pre><div class=pgc-img><img alt="管理 Vue 應用中的異步調用  vue-asyn-manager" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/989fa71e-f05e-4a87-9e09-b1da24542257><p class=pgc-img-caption></p></div><p>:::tip Live Demo: 通過事件處理 error :::</p><p>關於 LRU 緩存</p><p>React Cache 使用 LRU 算法緩存資源，這要求 API 具有冪等性，然而在我的工作環境中，在給定時間週期內真正冪等的 API 很少，因此暫時沒有提供對緩存資源的能力。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Vue</a></li><li><a>應用</a></li><li><a>異步</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d164290a.html alt=伺服異步電機的應用和工作原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b5daa11b1b7c4a2b9dafafe3807dc14f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d164290a.html title=伺服異步電機的應用和工作原理>伺服異步電機的應用和工作原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c3e2be4.html alt="Vue  created 中的異步請求的影響分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e6f8e8d25f2146e5a36832b2f195ae61 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c3e2be4.html title="Vue  created 中的異步請求的影響分析">Vue created 中的異步請求的影響分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a03e8d8.html alt=Vue異步獲取數據之前，模版語法裡的會報錯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a69348a-1928-4d2c-9361-d422d160ca66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a03e8d8.html title=Vue異步獲取數據之前，模版語法裡的會報錯>Vue異步獲取數據之前，模版語法裡的會報錯</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5e4be374.html alt=鈦及鈦合金鑄件的應用領域​ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/Rca7hqUCttQBq0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5e4be374.html title=鈦及鈦合金鑄件的應用領域​>鈦及鈦合金鑄件的應用領域​</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/958c038a.html alt=鑄造鋁合金應用現狀及未來前景分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8dcaa42ff9a64e2cad814e4e025fc52c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/958c038a.html title=鑄造鋁合金應用現狀及未來前景分析>鑄造鋁合金應用現狀及未來前景分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16133b9e.html alt=深度語義模型以及在淘寶搜索中的應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/48529b82dc7c4f048fc3e45d586717e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16133b9e.html title=深度語義模型以及在淘寶搜索中的應用>深度語義模型以及在淘寶搜索中的應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/657370c9.html alt=從起源講到應用，幾乎所有齒輪知識都在這裡了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6a14e31844e14b5aace5360ee6f8601a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/657370c9.html title=從起源講到應用，幾乎所有齒輪知識都在這裡了>從起源講到應用，幾乎所有齒輪知識都在這裡了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc32dcc9.html alt=牛常用飼料添加劑的種類與應用！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/57c1b1c2-20c8-4927-8161-242643381796 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc32dcc9.html title=牛常用飼料添加劑的種類與應用！>牛常用飼料添加劑的種類與應用！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7fa2c409.html alt=精密三角高程在長距離一等跨河水準測量中的應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/514529e0543f408583046cefc73fac13 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7fa2c409.html title=精密三角高程在長距離一等跨河水準測量中的應用>精密三角高程在長距離一等跨河水準測量中的應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html alt=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15310942260931dda577a75 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a90a489a.html title=JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點>JAVA中多態的概念和應用，通過案例分析成員變量、方法的訪問特點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7f03f742.html alt=正切和差角變形式應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e1f38ef5d20445488e9e180576f12a61 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7f03f742.html title=正切和差角變形式應用>正切和差角變形式應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1c7184b.html alt=高中數學：正、餘二倍角公式的變式及其應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/R6f5aXZEqbpi9N style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1c7184b.html title=高中數學：正、餘二倍角公式的變式及其應用>高中數學：正、餘二倍角公式的變式及其應用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a04345b.html alt=《三極管應用分析精粹》已經交稿，從單管放大到模擬集成電路設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a04345b.html title=《三極管應用分析精粹》已經交稿，從單管放大到模擬集成電路設計>《三極管應用分析精粹》已經交稿，從單管放大到模擬集成電路設計</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5928048c.html alt=大漆歷史文化，區域分佈，應用領域 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/768822cfc3c94c5bb8362d33fe2c6b03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5928048c.html title=大漆歷史文化，區域分佈，應用領域>大漆歷史文化，區域分佈，應用領域</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/49962cec.html alt=軸承計算器的應用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152574329299180c83f9974 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/49962cec.html title=軸承計算器的應用>軸承計算器的應用</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>