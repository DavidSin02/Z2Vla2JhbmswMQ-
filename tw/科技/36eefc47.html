<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面試必問的HashMap，你真的瞭解嗎？ | 极客快訊</title><meta property="og:title" content="面試必問的HashMap，你真的瞭解嗎？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/36eefc47.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/36eefc47.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="面試必問的HashMap，你真的瞭解嗎？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/36eefc47.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面試必問的HashMap，你真的瞭解嗎？</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><strong>前言</strong></p><p>HashMap是Map中最為常用的一種，面試中也經常會被問到相關的問題。由於HashMap數據結構較為複雜，回答相關問題的時候往往不盡人意，尤其是在JDK1.8之後，又引入了紅黑樹結構，其數據結構變的更加複雜，本文就JDK1.8源碼為例，對HashMap進行分析；</p><p><strong>源碼分析</strong></p><p><strong>1. 構造方法</strong></p><pre>public HashMap(int initialCapacity, float loadFactor) { if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); } public HashMap(int initialCapacity) { this(initialCapacity, DEFAULT_LOAD_FACTOR); } public HashMap() { this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted } public HashMap(Map&lt;? extends K, ? extends V&gt; m) { this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); }</pre><p>構造方法一共重載了四個，主要初始化了三個參數：</p><p><strong>- initialCapacity 初始容量（默認16）：</strong>hashMap底層由數組實現+鏈表（或紅黑樹）實現，但是還是從數組開始，所以當儲存的數據越來越多的時候，就必須進行擴容操作，如果在知道需要儲存數據大小的情況下，指定合適的初始容量，可以避免不必要的擴容操作，提升效率</p><p><strong>- threshold 閾值：</strong>hashMap所能容納的最大價值對數量，如果超過則需要擴容，計算方式：threshold=initialCapacity*loadFactor（構造方法中直接通過tableSizeFor(initialCapacity)方法進行了賦值，主要原因是在構造方法中，數組table並沒有初始化，put方法中進行初始化，同時put方法中也會對threshold進行重新賦值，這個會在後面的源碼中進行分析）</p><p><strong>- loadFactor 加載因子（默認0.75）：</strong>當負載因子較大時，去給table數組擴容的可能性就會少，所以相對佔用內存較少（空間上較少），但是每條entry鏈上的元素會相對較多，查詢的時間也會增長（時間上較多）。反之就是，負載因子較少的時候，給table數組擴容的可能性就高，那麼內存空間佔用就多，但是entry鏈上的元素就會相對較少，查出的時間也會減少。所以才有了負載因子是時間和空間上的一種折中的說法。所以設置負載因子的時候要考慮自己追求的是時間還是空間上的少。（一般情況下不需要設置，系統給的默認值已經比較適合了）</p><p>我們最常使用的是無參構造，在這個構造方法裡面僅僅設置了加載因子為默認值，其他兩個參數會在resize方法裡面進行初始化，在這裡知道這個結論就可以了，下面會在源碼裡面進行分析；另外一個帶有兩個參數的構造方法，裡面對初始容量和閾值進行了初始化，對閾值的初始化方法為 tableSizeFor(int cap),看一下源碼：</p><pre>public HashMap(int initialCapacity, float loadFactor) { /** * 找到大於或等於 cap 的最小2的冪 */ static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; }</pre><p>第一次看到這個方法的時候，我當時的心情是：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面試必問的HashMap，你真的瞭解嗎？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19a8d23522b640b4a8d8a927514eca33><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>接下來分析一下這個方法，下面偷一張圖（真的是借別人的圖，google搜索的,不知道是誰的，如果大佬覺得太可恥，私信我我刪了他）以10為例進行分析：</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面試必問的HashMap，你真的瞭解嗎？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cabf4b9f4c6e47eaa2fc6215b9041707><p class=pgc-img-caption></p></div><p class=ql-align-center><br></p><p>另外，需要注意一下的是，第一步 int n = cap - 1; 這個操作，執行這個操作的主要原因是為了防止在cap已經是2的n次冪的情況下，經過運算後得到的結果是cap的二倍的結果，例如如果n為l6，經過一系列運算之後，得到的結果是0001 1111，此時最後一步n+1 執行之後，就會返回32，有興趣的可以自己進行嘗試；</p><p><strong>2. put方法</strong></p><p>在hashMap源碼中，put方法邏輯是最為複雜的，接下來先看一下源碼：</p><pre>public V put(K key, V value) { return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) //如果table尚未初始化，則此處進行初始化數組，並賦值初始容量，重新計算閾值 n = (tab = resize()).length; if ((p = tab[i = (n - 1) &amp; hash]) == null) //通過hash找到下標，如果hash值指定的位置數據為空，則直接將數據存放進去 tab[i] = newNode(hash, key, value, null); else { //如果通過hash找到的位置有數據，發生碰撞 Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //如果需要插入的key和當前hash值指定下標的key一樣，先將e數組中已有的數據 e = p; else if (p instanceof TreeNode) //如果此時桶中數據類型為 treeNode，使用紅黑樹進行插入 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else { //此時桶中數據類型為鏈表 // 進行循環 for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { //如果鏈表中沒有最新插入的節點，將新放入的數據放到鏈表的末尾 p.next = newNode(hash, key, value, null); //如果鏈表過長，達到樹化閾值，將鏈表轉化成紅黑樹 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } //如果鏈表中有新插入的節點位置數據不為空，則此時e 賦值為節點的值，跳出循環 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; } } //經過上面的循環後，如果e不為空，則說明上面插入的值已經存在於當前的hashMap中，那麼更新指定位置的鍵值對 if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; //如果此時hashMap size大於閾值，則進行擴容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; }</pre><p>從代碼看，put方法分為三種情況：</p><ul><li>table尚未初始化，對數據進行初始化</li><li>table已經初始化，且通過hash算法找到下標所在的位置數據為空,直接將數據存放到指定位置</li><li>table已經初始化，且通過hash算法找到下標所在的位置數據不為空，發生hash衝突（碰撞），發生碰撞後，會執行以下操作：</li><li>-- 判斷插入的key如果等於當前位置的key的話，將 e 指向該鍵值對</li><li>-- 如果此時桶中數據類型為 treeNode，使用紅黑樹進行插入</li><li>-- 如果是鏈表，則進行循環判斷， 如果鏈表中包含該節點，跳出循環，如果鏈表中不包含該節點，則把該節點插入到鏈表末尾，同時，如果鏈表長度超過樹化閾值（TREEIFY_THRESHOLD）且table容量超過最小樹化容量（MIN_TREEIFY_CAPACITY），則進行鏈表轉紅黑樹（由於table容量越小，越容易發生hash衝突，因此在table容量&lt;MIN_TREEIFY_CAPACITY 的時候，如果鏈表長度>TREEIFY_THRESHOLD,會優先選擇擴容，否則會進行鏈表轉紅黑樹操作）</li></ul><p>首先分析table尚未初始化的情況：</p><p><strong>table尚未初始化</strong></p><pre>n = (tab = resize()).length;</pre><p>從代碼可以看出，table尚未初始化的時候，會調用resize()方法：</p><pre>final Node&lt;K,V&gt;[] resize() { Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; //1、table已經初始化，且容量 &gt; 0 if (oldCap &gt; 0) { if (oldCap &gt;= MAXIMUM_CAPACITY) { //如果舊的容量已近達到最大值，則不再擴容，閾值直接設置為最大值 threshold = Integer.MAX_VALUE; return oldTab; } else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //如果舊的容量不小於默認的初始容量，則進行擴容，容量擴張為原來的二倍 newThr = oldThr &lt;&lt; 1; // double threshold } //2、閾值大於0 threshold 使用 threshold 變量暫時保存 initialCapacity 參數的值 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //3 threshold 和 table 皆未初始化情況，此處即為首次進行初始化 //也就在此處解釋了構造方法中沒有對threshold 和 初始容量進行賦值的問題 else { // zero initial threshold signifies using defaults //如果閾值為零，表示使用默認的初始化值 //這種情況在調用無參構造的時候會出現，此時使用默認的容量和閾值 newCap = DEFAULT_INITIAL_CAPACITY; //此處閾值即為 threshold=initialCapacity*loadFactor newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); } // newThr 為 0 時，按閾值計算公式進行計算，容量*負載因子 if (newThr == 0) { float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); } //更新閾值 threshold = newThr; //更新數組桶 @SuppressWarnings({"rawtypes","unchecked"}) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; //如果之前的數組桶裡面已經存在數據，由於table容量發生變化，hash值也會發生變化，需要重新計算下標 if (oldTab != null) { for (int j = 0; j &lt; oldCap; ++j) { Node&lt;K,V&gt; e; //如果指定下標下有數據 if ((e = oldTab[j]) != null) { //1、將指定下標數據置空 oldTab[j] = null; //2、指定下標只有一個數據 if (e.next == null) //直接將數據存放到新計算的hash值下標下 newTab[e.hash &amp; (newCap - 1)] = e; //3、如果是TreeNode數據結構 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //4、對於鏈表，數據結構 else { // preserve order //如果是鏈表，重新計算hash值，根據新的下標重新分組 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do { next = e.next; if ((e.hash &amp; oldCap) == 0) { if (loTail == null) loHead = e; else loTail.next = e; loTail = e; } else { if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; } } while ((e = next) != null); if (loTail != null) { loTail.next = null; newTab[j] = loHead; } if (hiTail != null) { hiTail.next = null; newTab[j + oldCap] = hiHead; } } } } } return newTab; }</pre><p>resize方法邏輯比較複雜，需要靜下心來一步步的分析，但是總的下來，分為以下幾步：</p><ul><li>首先先判斷當前table是否進行過初始化，如果沒有進行過初始化，此處就解決了調用無參構造方法時候，threshold和initialCapacity 未初始化的問題，如果已經初始化過了，則進行擴容，容量為原來的二倍</li><li>擴容後創建新的table，並對所有的數據進行遍歷</li><li>-- 如果新計算的位置數據為空，則直接插入</li><li>-- 如果新計算的位置為鏈表，則通過hash算法重新計算下標，對鏈表進行分組</li><li>-- 如果是紅黑樹，則需要進行拆分操作</li></ul><p><strong>3. get方法，查找</strong></p><p>put方法分析完成之後，剩下的就很簡單了，先看一下源碼：</p><pre>public V get(Object key) { Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; } final Node&lt;K,V&gt; getNode(int hash, Object key) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) { //1、根據hash算法找到對應位置的第一個數據，如果是指定的key，則直接返回 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) { //如果該節點為紅黑樹，則通過樹進行查找 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); //如果該節點是鏈表，則遍歷查找到數據 do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; }</pre><p>get方法相對於put來說，邏輯實在是簡單太多了</p><ol><li>根據hash值查找到指定位置的數據</li><li>校驗指定位置第一個節點的數據是key是否為傳入的key，如果是直接返回第一個節點，否則繼續查找第二個節點</li><li>如果數據是TreeNode（紅黑樹結構），直接通過紅黑樹查找節點數據並返回</li><li>如果是鏈表結構，循環查找所有節點，返回數據</li><li>如果沒有找到符合要求的節點，返回null</li></ol><p>在這個方法裡面，需要注意的有兩個地方：hash（key）和hash的取模運算 (n - 1) & hash</p><p><strong>hash（key）的源碼</strong></p><pre> static final int hash(Object key) { int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); }</pre><p>這段代碼叫做擾動函數，也是hashMap中的hash運算，主要分為下面幾步：</p><ul><li>key.hashCode()，獲取key的hashCode值，如果不進行重寫的話返回的是根據內存地址得到的一個int值</li><li>key.hashCode() 獲取到的hashcode無符號右移16位並和元hashCode進行^ ，這樣做的目的是為了讓高位與低進行混合，讓兩者都參與運算，以便讓hash值分佈更加均勻</li></ul><p><strong>取模運算 (n - 1) & hash</strong></p><p>在hashMap的代碼中，在很多地方都會看到類似的代碼：</p><pre>first = tab[(n - 1) &amp; hash])</pre><p>hash算法中，為了使元素分佈的更加均勻，很多都會使用取模運算，在hashMap中並沒有使用（n）%hash這樣進行取模運算，而是使用(n - 1) & hash進行代替，原因是在計算機中，&的效率要遠高於%；需要注意的是，只有容量為2的n次冪的時候，(n - 1) & hash 才能等效（n）%hash，這也是hashMap 初始化初始容量時，無論傳入任何值，都會通過tableSizeFor(int cap) 方法轉化成2的n次冪的原因，這種巧妙的設計真的很令人驚歎</p><p><strong>remove方法，刪除</strong></p><p>瞭解完get方法之後，我們再最後瞭解一下remove方法：</p><pre> public V remove(Object key) { Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value; } final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) { Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //根據key和key的hash值，查找到對應的元素 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) { Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) { if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else { do { if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) { node = e; break; } p = e; } while ((e = e.next) != null); } } //如果查找的了元素node，移除即可 if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) { //如果是TreeNode，通過樹進行移除 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); //如果是第一個節點，移除第一個節點，將index下標的位置指向第二個節點 else if (node == p) tab[index] = node.next; else //如果不是鏈表的第一個節點，則移除該節點 p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; } } return null; }</pre><p>從源碼可以看出來，通過key找到需要移除的元素操作過程和get方法幾乎一致，最後在查找到key對應的節點之後，根據節點的位置和類型，進行相應的移除操作就完成了，過程非常簡單</p><p><strong>其他源碼</strong></p><p>到這裡，hashMap的源碼基本就解析完成了，其餘的方法和源碼邏輯相對非常簡單，大部分還是使用上述代碼來實現的，例如containsKey（jey），就是使用get方法中的getNode（）來判斷的，由於篇幅原因就不一一介紹。</p><p>另外，中間有很部分不影響邏輯理解的代碼被一筆帶過，比如 紅黑樹的轉化，查找，刪除等操作，有興趣的可以自己進行學習，不過還有一些其他的特性需要提醒一下</p><p>最後總結一下：</p><ul><li>HashMap 底層數據結構在JDK1.7之前是由數組+鏈表組成的，1.8之後又加入了紅黑樹；鏈表長度小於8的時候，發生Hash衝突後會增加鏈表的長度，當鏈表長度大於8的時候，會先判讀數組的容量，如果容量小於64會先擴容（原因是數組容量越小，越容易發生碰撞，因此當容量過小的時候，首先要考慮的是擴容），如果容量大於64，則會將鏈表轉化成紅黑樹以提升效率</li><li>hashMap 的容量是2的n次冪，無論在初始化的時候傳入的初始容量是多少，最終都會轉化成2的n次冪，這樣做的原因是為了在取模運算的時候可以使用&運算符，而不是%取餘，可以極大的提上效率，同時也降低hash衝突</li><li>HashMap是非線程安全的，在多線程的操作下會存在異常情況（如形成閉環（1.7），1.8已修復閉環問題，但仍不安全），可以使用HashTable或者ConcurrentHashMap進行代替</li></ul><p><strong>文末送福利啦！！</strong></p><p>同時我經過多年的收藏目前也算收集到了一套完整的學習資料以及高清詳細的Android架構進階學習導圖及筆記免費分享給大家，希望對想成為架構師的朋友有一定的參考和幫助。</p><p>**下面是部分資料截圖，誠意滿滿：特別適合有開發經驗的Android程序員們學習。</p><p class=ql-align-center><br></p><div class=pgc-img><img alt=面試必問的HashMap，你真的瞭解嗎？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/3b66812ad48148669372a844f8df82aa><p class=pgc-img-caption></p></div><p class=ql-align-center><strong>資料免費領取方式：關注我後臺私信關鍵詞【資料】獲取！</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>面試</a></li><li><a>必問</a></li><li><a>HashMap</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html alt=面試必問，進程和線程概念詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/31f152f300834172b846a27e904440e1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8db576a1.html title=面試必問，進程和線程概念詳解>面試必問，進程和線程概念詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html alt=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f47e6a7038d9408dbc02ccb0517ff715 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/be7d76b3.html title=大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？>大無語！每次面試必問的二叉樹的設計與編碼，你還敢不當回事？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html alt=HashMap面試專題：常問六題深入解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/75bf5de0-37fd-469c-b6b3-8067c551568a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/253ce164.html title=HashMap面試專題：常問六題深入解析>HashMap面試專題：常問六題深入解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html alt=一個HashMap能跟面試官扯上半個小時 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3c09bf1ad1b54adaab3db4be30c10c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dabba596.html title=一個HashMap能跟面試官扯上半個小時>一個HashMap能跟面試官扯上半個小時</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html alt=面試必備：HashMap源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/03f9864cd43d4878900fc2a9784d702e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c538446f.html title=面試必備：HashMap源碼解析>面試必備：HashMap源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html alt=HashMap？面試？我是誰？我在哪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8aa437a2fb3143e7a345a46a36d2c81e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c64cd474.html title=HashMap？面試？我是誰？我在哪>HashMap？面試？我是誰？我在哪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html alt=「最完整系列」JAVA-容器篇-HashMap面試最詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/71d7c60ccb9e4e57acda3ded903a1fd5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a4f8a1a.html title=「最完整系列」JAVA-容器篇-HashMap面試最詳解>「最完整系列」JAVA-容器篇-HashMap面試最詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f192b47.html alt=大廠面試必問的數據結構--棧和隊列基礎知識 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/c7607ef07fe84842957cc74a9be92140 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f192b47.html title=大廠面試必問的數據結構--棧和隊列基礎知識>大廠面試必問的數據結構--棧和隊列基礎知識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9f6e5f.html alt=面試必問：設計模式遵循的面向對象設計原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0ffba50d7eb54d3a9b1b4ead627eeb35 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9f6e5f.html title=面試必問：設計模式遵循的面向對象設計原則>面試必問：設計模式遵循的面向對象設計原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/45389c0.html alt=面試必問：嵌套函數、閉包與裝飾器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c892cd4d30114fbea6fb40a071aa43c6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/45389c0.html title=面試必問：嵌套函數、閉包與裝飾器>面試必問：嵌套函數、閉包與裝飾器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>