<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>七大查找算法 | 极客快訊</title><meta property="og:title" content="七大查找算法 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38aea254.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38aea254.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/38aea254.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38aea254.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38aea254.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/38aea254.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/38aea254.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38aea254.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="七大查找算法"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/38aea254.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>七大查找算法</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>　查找是在大量的信息中尋找一個特定的信息元素，在計算機應用中，查找是常用的基本運算，例如編譯程序中符號表的查找。本文簡單概括性的介紹了常見的七種查找算法，說是七種，其實二分查找、插值查找以及斐波那契查找都可以歸為一類——插值查找。插值查找和斐波那契查找是在二分查找的基礎上的優化查找算法。樹表查找和哈希查找會在後續的博文中進行詳細介紹。</p><p><strong>查找定義：</strong>根據給定的某個值，在查找表中確定一個其關鍵字等於給定值的數據元素（或記錄）。</p><p><strong>查找算法分類：</strong></p><p><strong></strong>1）靜態查找和動態查找；</p><p>注：靜態或者動態都是針對查找表而言的。動態表指查找表中有刪除和插入操作的表。</p><p>2）無序查找和有序查找。</p><p>無序查找：被查找數列有序無序均可；</p><p>有序查找：被查找數列必須為有序數列。</p><p><strong>平均查找長度（Average Search Length，ASL）：</strong>需和指定key進行比較的關鍵字的個數的期望值，稱為查找算法在查找成功時的平均查找長度。</p><p>對於含有n個數據元素的查找表，查找成功的平均查找長度為：ASL = P<sub>i</sub>*C<sub>i</sub>的和。</p><p>P<sub>i</sub>：查找表中第i個數據元素的概率。</p><p>C<sub>i</sub>：找到第i個數據元素時已經比較過的次數。</p><p class=ql-align-right><br></p><p><strong>1. 順序查找</strong></p><p><strong>說明：順序查找適合於存儲結構為順序存儲或鏈接存儲的線性表。</strong></p><p><strong>基本思想：</strong>順序查找也稱為線形查找，屬於無序查找算法。從數據結構線形表的一端開始，順序掃描，依次將掃描到的結點關鍵字與給定值k相比較，若相等則表示查找成功；若掃描結束仍沒有找到關鍵字等於k的結點，表示查找失敗。</p><p><strong>複雜度分析：</strong>　</p><p>查找成功時的平均查找長度為：（假設每個數據元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;</p><p>當查找不成功時，需要n+1次比較，時間複雜度為O(n);</p><p>所以，<strong>順序查找的時間複雜度為O(n)。</strong></p><p><strong>C++實現源碼：</strong></p><pre>//順序查找int SequenceSearch(int a[], int value, int n){ int i; for(i=0; i&lt;n; i++) if(a[i]==value) return i; return -1;}</pre><p><strong>2. 二分查找</strong></p><p><strong>說明：元素必須是有序的，如果是無序的則要先進行排序操作。</strong></p><p><strong>基本思想：</strong>也稱為是折半查找，屬於有序查找算法。用給定值k先與中間結點的關鍵字比較，中間結點把線形表分成兩個子表，若相等則查找成功；若不相等，再根據k與該中間結點關鍵字的比較結果確定下一步查找哪個子表，這樣遞歸進行，直到查找到或查找結束髮現表中沒有這樣的結點。</p><p><strong>複雜度分析：</strong>最壞情況下，關鍵詞比較次數為log<sub>2</sub>(n+1)，且<strong>期望時間複雜度為O(log</strong><sub><strong>2</strong></sub><strong>n)</strong>；</p><p>注：<strong>折半查找的前提條件是需要有序表順序存儲，對於靜態查找表，一次排序後不再變化，折半查找能得到不錯的效率。但對於需要頻繁執行插入或刪除操作的數據集來說，維護有序的排序會帶來不小的工作量，那就不建議使用。——《大話數據結構》</strong></p><p><strong>C++實現源碼：</strong></p><pre>//二分查找（折半查找），版本1int BinarySearch1(int a[], int value, int n){ int low, high, mid; low = 0; high = n-1; while(low&lt;=high) { mid = (low+high)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) high = mid-1; if(a[mid]&lt;value) low = mid+1; } return -1;}//二分查找，遞歸版本int BinarySearch2(int a[], int value, int low, int high){ int mid = low+(high-low)/2; if(a[mid]==value) return mid; if(a[mid]&gt;value) return BinarySearch2(a, value, low, mid-1); if(a[mid]&lt;value) return BinarySearch2(a, value, mid+1, high);}</pre><p class=ql-align-right><br></p><p><strong>3. 插值查找</strong></p><p>在介紹插值查找之前，首先考慮一個新問題，為什麼上述算法一定要是折半，而不是折四分之一或者折更多呢？</p><p>打個比方，在英文字典裡面查“apple”，你下意識翻開字典是翻前面的書頁還是後面的書頁呢？如果再讓你查“zoo”，你又怎麼查？很顯然，這裡你絕對不會是從中間開始查起，而是有一定目的的往前或往後翻。</p><p>同樣的，比如要在取值範圍1 ~ 10000 之間 100 個元素從小到大均勻分佈的數組中查找5， 我們自然會考慮從數組下標較小的開始查找。</p><p>經過以上分析，折半查找這種查找方式，不是自適應的（也就是說是傻瓜式的）。二分查找中查找點計算如下：</p><p>mid=(low+high)/2, 即mid=low+1/2*(high-low);</p><p>通過類比，我們可以將查找的點改進為如下：</p><p>mid=low+(key-a[low])/(a[high]-a[low])*(high-low)，</p><p>也就是將上述的比例參數1/2改進為自適應的，根據關鍵字在整個有序表中所處的位置，讓mid值的變化更靠近關鍵字key，這樣也就間接地減少了比較次數。</p><p><strong>基本思想：</strong>基於二分查找算法，將查找點的選擇改進為自適應選擇，可以提高查找效率。當然，差值查找也屬於有序查找。</p><p>注：<strong>對於表長較大，而關鍵字分佈又比較均勻的查找表來說，插值查找算法的平均性能比折半查找要好的多。反之，數組中如果分佈非常不均勻，那麼插值查找未必是很合適的選擇。</strong></p><p><strong>複雜度分析：查找成功或者失敗的時間複雜度均為O(log</strong><sub><strong>2</strong></sub><strong>(log</strong><sub><strong>2</strong></sub><strong>n))。</strong></p><p><strong>C++實現源碼：</strong></p><pre>//插值查找int InsertionSearch(int a[], int value, int low, int high){ int mid = low+(value-a[low])/(a[high]-a[low])*(high-low); if(a[mid]==value) return mid; if(a[mid]&gt;value) return InsertionSearch(a, value, low, mid-1); if(a[mid]&lt;value) return InsertionSearch(a, value, mid+1, high);}</pre><p><strong>4. 斐波那契查找</strong></p><p>在介紹斐波那契查找算法之前，我們先介紹一下很它緊密相連並且大家都熟知的一個概念——黃金分割。</p><p>黃金比例又稱黃金分割，是指事物各部分間一定的數學比例關係，即將整體一分為二，較大部分與較小部分之比等於整體與較大部分之比，其比值約為1:0.618或1.618:1。</p><p>0.618被公認為最具有審美意義的比例數字，這個數值的作用不僅僅體現在諸如繪畫、雕塑、音樂、建築等藝術領域，而且在管理、工程設計等方面也有著不可忽視的作用。因此被稱為黃金分割。</p><p>大家記不記得斐波那契數列：1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89…….（從第三個數開始，後邊每一個數都是前兩個數的和）。然後我們會發現，隨著斐波那契數列的遞增，前後兩個數的比值會越來越接近0.618，利用這個特性，我們就可以將黃金比例運用到查找技術中。</p><p><strong>基本思想：</strong>也是二分查找的一種提升算法，通過運用黃金比例的概念在數列中選擇查找點進行查找，提高查找效率。同樣地，斐波那契查找也屬於一種有序查找算法。</p><p>相對於折半查找，一般將待比較的key值與第mid=（low+high）/2位置的元素比較，比較結果分三種情況：</p><p>1）相等，mid位置的元素即為所求</p><p>2）>，low=mid+1;</p><p>3）&lt;，high=mid-1。</p><p>斐波那契查找與折半查找很相似，他是根據斐波那契序列的特點對有序表進行分割的。他要求開始表中記錄的個數為某個斐波那契數小1，及n=F(k)-1;</p><p>開始將k值與第F(k-1)位置的記錄進行比較(及mid=low+F(k-1)-1),比較結果也分為三種</p><p>1）相等，mid位置的元素即為所求</p><p>2）>，low=mid+1,k-=2;</p><p>說明：low=mid+1說明待查找的元素在[mid+1,high]範圍內，k-=2 說明範圍[mid+1,high]內的元素個數為n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1個，所以可以遞歸的應用斐波那契查找。</p><p>3）&lt;，high=mid-1,k-=1。</p><p>說明：low=mid+1說明待查找的元素在[low,mid-1]範圍內，k-=1 說明範圍[low,mid-1]內的元素個數為F(k-1)-1個，所以可以遞歸 的應用斐波那契查找。</p><p><strong>複雜度分析：最壞情況下，時間複雜度為O(log</strong><sub><strong>2</strong></sub><strong>n)，且其期望複雜度也為O(log</strong><sub><strong>2</strong></sub><strong>n)。</strong></p><p><strong>C++實現源碼：</strong></p><pre>// 斐波那契查找.cpp #include "stdafx.h"#include &lt;memory&gt;#include &lt;iostream&gt;using namespace std;const int max_size=20;//斐波那契數組的長度/*構造一個斐波那契數組*/ void Fibonacci(int * F){ F[0]=0; F[1]=1; for(int i=2;i&lt;max_size;++i) F[i]=F[i-1]+F[i-2];}/*定義斐波那契查找法*/ int FibonacciSearch(int *a, int n, int key) //a為要查找的數組,n為要查找的數組長度,key為要查找的關鍵字{ int low=0; int high=n-1;  int F[max_size]; Fibonacci(F);//構造一個斐波那契數組F  int k=0; while(n&gt;F[k]-1)//計算n位於斐波那契數列的位置 ++k; int * temp;//將數組a擴展到F[k]-1的長度 temp=new int [F[k]-1]; memcpy(temp,a,n*sizeof(int)); for(int i=n;i&lt;F[k]-1;++i) temp[i]=a[n-1];  while(low&lt;=high) { int mid=low+F[k-1]-1; if(key&lt;temp[mid]) { high=mid-1; k-=1; } else if(key&gt;temp[mid]) { low=mid+1; k-=2; } else { if(mid&lt;n) return mid; //若相等則說明mid即為查找到的位置 else return n-1; //若mid&gt;=n則說明是擴展的數值,返回n-1 } }  delete [] temp; return -1;}int main(){ int a[] = {0,16,24,35,47,59,62,73,88,99}; int key=100; int index=FibonacciSearch(a,sizeof(a)/sizeof(int),key); cout&lt;&lt;key&lt;&lt;" is located at:"&lt;&lt;index; return 0;}</pre><p><strong>5. 樹表查找</strong></p><p><strong>5.1 最簡單的樹表查找算法——二叉樹查找算法。</strong></p><p><strong>基本思想：</strong>二叉查找樹是先對待查找的數據進行生成樹，確保樹的左分支的值小於右分支的值，然後在就行和每個節點的父節點比較大小，查找最適合的範圍。 這個算法的查找效率很高，但是如果使用這種查找方法要首先創建樹。</p><p><strong>二叉查找樹</strong>（BinarySearch Tree，也叫二叉搜索樹，或稱二叉排序樹Binary Sort Tree）或者是一棵空樹，或者是具有下列性質的二叉樹：</p><p>1）若任意節點的左子樹不空，則左子樹上所有結點的值均小於它的根結點的值；</p><p>2）若任意節點的右子樹不空，則右子樹上所有結點的值均大於它的根結點的值；</p><p>3）任意節點的左、右子樹也分別為二叉查找樹。</p><p><strong>二叉查找樹性質</strong>：<strong>對二叉查找樹進行中序遍歷，即可得到有序的數列。</strong></p><p>不同形態的二叉查找樹如下圖所示：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/15393515221731c57aa8da1><p class=pgc-img-caption></p></div><p>有關二叉查找樹的查找、插入、刪除等操作的詳細講解，請移步淺談算法和數據結構: 七 二叉查找樹。</p><p><strong>複雜度分析：它和二分查找一樣，插入和查找的時間複雜度均為O(logn)，但是在最壞的情況下仍然會有O(n)的時間複雜度。原因在於插入和刪除元素的時候，樹沒有保持平衡（比如，我們查找上圖（b）中的“93”，我們需要進行n次查找操作）。我們追求的是在最壞的情況下仍然有較好的時間複雜度，這就是平衡查找樹設計的初衷。</strong></p><p><strong></strong>下圖為二叉樹查找和順序查找以及二分查找性能的對比圖：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15393512041213a54959f58><p class=pgc-img-caption></p></div><p>基於二叉查找樹進行優化，進而可以得到其他的樹表查找算法，如平衡樹、紅黑樹等高效算法。</p><p><strong>5.2 平衡查找樹之2-3查找樹（2-3 Tree）</strong></p><p><strong>2-3查找樹定義</strong>：和二叉樹不一樣，2-3樹運行每個節點保存1個或者兩個的值。對於普通的2節點(2-node)，他保存1個key和左右兩個自己點。對應3節點(3-node)，保存兩個Key，2-3查找樹的定義如下：</p><p>1）要麼為空，要麼：</p><p>2）對於2節點，該節點保存一個key及對應value，以及兩個指向左右節點的節點，左節點也是一個2-3節點，所有的值都比key要小，右節點也是一個2-3節點，所有的值比key要大。</p><p>3）對於3節點，該節點保存兩個key及對應value，以及三個指向左中右的節點。左節點也是一個2-3節點，所有的值均比兩個key中的最小的key還要小；中間節點也是一個2-3節點，中間節點的key值在兩個跟節點key值之間；右節點也是一個2-3節點，節點的所有key值比兩個key中的最大的key還要大。</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539351203955232e7b2bdd><p class=pgc-img-caption></p></div><p><strong>2-3查找樹的性質：</strong></p><p><strong>1）如果中序遍歷2-3查找樹，就可以得到排好序的序列；</strong></p><p><strong>2）在一個完全平衡的2-3查找樹中，根節點到每一個為空節點的距離都相同。（這也是平衡樹中“平衡”一詞的概念，根節點到葉節點的最長距離對應於查找算法的最壞情況，而平衡樹中根節點到葉節點的距離都一樣，最壞情況也具有對數複雜度。）</strong></p><p>性質2）如下圖所示：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15393512040593c11574ccd><p class=pgc-img-caption></p></div><p><strong>複雜度分析：</strong></p><p>2-3樹的查找效率與樹的高度是息息相關的。</p><ul><li>在最壞的情況下，也就是所有的節點都是2-node節點，查找效率為lgN</li><li>在最好的情況下，所有的節點都是3-node節點，查找效率為log<sub>3</sub>N約等於0.631lgN</li></ul><p>距離來說，對於1百萬個節點的2-3樹，樹的高度為12-20之間，對於10億個節點的2-3樹，樹的高度為18-30之間。</p><p>對於插入來說，只需要常數次操作即可完成，因為他只需要修改與該節點關聯的節點即可，不需要檢查其他節點，所以效率和查找類似。下面是2-3查找樹的效率：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/153935120423908749a6c73><p class=pgc-img-caption></p></div><p><strong>5.3 平衡查找樹之紅黑樹（Red-Black Tree）</strong></p><p>2-3查找樹能保證在插入元素之後能保持樹的平衡狀態，最壞情況下即所有的子節點都是2-node，樹的高度為lgn，從而保證了最壞情況下的時間複雜度。但是2-3樹實現起來比較複雜，於是就有了一種簡單實現2-3樹的數據結構，即紅黑樹（Red-Black Tree）。</p><p><strong>基本思想：</strong>紅黑樹的思想就是對2-3查找樹進行編碼，尤其是對2-3查找樹中的3-nodes節點添加額外的信息。紅黑樹中將節點之間的鏈接分為兩種不同類型，紅色鏈接，他用來鏈接兩個2-nodes節點來表示一個3-nodes節點。黑色鏈接用來鏈接普通的2-3節點。特別的，使用紅色鏈接的兩個2-nodes來表示一個3-nodes節點，並且向左傾斜，即一個2-node是另一個2-node的左子節點。這種做法的好處是查找的時候不用做任何修改，和普通的二叉查找樹相同。</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539351204177bb669ad82f><p class=pgc-img-caption></p></div><p><strong>紅黑樹的定義：</strong></p><p>紅黑樹是一種具有紅色和黑色鏈接的平衡查找樹，同時滿足：</p><ul><li>紅色節點向左傾斜</li><li>一個節點不可能有兩個紅色鏈接</li><li>整個樹完全黑色平衡，即從根節點到所以葉子結點的路徑上，黑色鏈接的個數都相同。</li></ul><p>下圖可以看到紅黑樹其實是2-3樹的另外一種表現形式：如果我們將紅色的連線水平繪製，那麼他鏈接的兩個2-node節點就是2-3樹中的一個3-node節點了。</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/15393512042227cff8d0c70><p class=pgc-img-caption></p></div><p><strong>紅黑樹的性質</strong>：<strong>整個樹完全黑色平衡，即從根節點到所以葉子結點的路徑上，黑色鏈接的個數都相同（2-3樹的第2）性質，從根節點到葉子節點的距離都相等）。</strong></p><p><strong>複雜度分析：最壞的情況就是，紅黑樹中除了最左側路徑全部是由3-node節點組成，即紅黑相間的路徑長度是全黑路徑長度的2倍。</strong></p><p>下圖是一個典型的紅黑樹，從中可以看到最長的路徑(紅黑相間的路徑)是最短路徑的2倍：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15393512043207f195f3dc0><p class=pgc-img-caption></p></div><p><strong>紅黑樹的平均高度大約為logn。</strong></p><p>下圖是紅黑樹在各種情況下的時間複雜度，可以看出紅黑樹是2-3查找樹的一種實現，它能保證最壞情況下仍然具有對數的時間複雜度。</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153935120444292bd5a705d><p class=pgc-img-caption></p></div><p>紅黑樹這種數據結構應用十分廣泛，在多種編程語言中被用作符號表的實現，如：</p><ul><li>Java中的java.util.TreeMap,java.util.TreeSet；</li><li>C++ STL中的：map,multimap,multiset；</li><li>.NET中的：SortedDictionary,SortedSet 等。</li></ul><p><strong>5.4 B樹和B+樹（B Tree/B+ Tree）</strong></p><p>平衡查找樹中的2-3樹以及其實現紅黑樹。2-3樹種，一個節點最多有2個key，而紅黑樹則使用染色的方式來標識這兩個key。</p><p>維基百科對B樹的定義為“在計算機科學中，B樹（B-tree）是一種樹狀數據結構，它能夠存儲數據、對其進行排序並允許以O(log n)的時間複雜度運行進行查找、順序讀取、插入和刪除的數據結構。B樹，概括來說是一個節點可以擁有多於2個子節點的二叉查找樹。與自平衡二叉查找樹不同，B樹為系統最優化<strong>大塊數據的讀和寫操作</strong>。B-tree算法減少定位記錄時所經歷的中間過程，從而加快存取速度。普遍運用在<strong>數據庫</strong>和<strong>文件系統</strong>。</p><p><strong>B樹定義：</strong></p><p><strong>B樹</strong>可以看作是對2-3查找樹的一種擴展，即他允許每個節點有M-1個子節點。</p><ul><li>根節點至少有兩個子節點</li><li>每個節點有M-1個key，並且以升序排列</li><li>位於M-1和M key的子節點的值位於M-1 和M key對應的Value之間</li><li>其它節點至少有M/2個子節點</li></ul><p>下圖是一個M=4 階的B樹:</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539351204774d2a90a8229><p class=pgc-img-caption></p></div><p>可以看到B樹是2-3樹的一種擴展，他允許一個節點有多於2個的元素。B樹的插入及平衡化操作和2-3樹很相似，這裡就不介紹了。下面是往B樹中依次插入</p><p class=ql-align-center><strong>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</strong></p><p>的演示動畫：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/153935155861894c7f530e8><p class=pgc-img-caption></p></div><p><strong>B+樹定義：</strong></p><p><strong>B+</strong>樹是對B樹的一種變形樹，它與B樹的差異在於：</p><ul><li>有k個子結點的結點必然有k個關鍵碼；</li><li>非葉結點僅具有索引作用，跟記錄有關的信息均存放在葉結點中。</li><li>樹的所有葉結點構成一個有序鏈表，可以按照關鍵碼排序的次序遍歷全部記錄。</li></ul><p>如下圖，是一個B+樹:</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539351204566326a832cb9><p class=pgc-img-caption></p></div><p>下圖是B+樹的插入動畫：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/153935137263248ca336b8d><p class=pgc-img-caption></p></div><p><strong>B和B+樹的區別在於，B+樹的非葉子結點只包含導航信息，不包含實際的值，所有的葉子結點和相連的節點使用鏈表相連，便於區間查找和遍歷。</strong></p><p>B+ 樹的優點在於：</p><ul><li>由於B+樹在內部節點上不好含數據信息，因此在內存頁中能夠存放更多的key。 數據存放的更加緊密，具有更好的空間局部性。因此訪問葉子幾點上關聯的數據也具有更好的緩存命中率。</li><li>B+樹的葉子結點都是相鏈的，因此對整棵樹的便利只需要一次線性遍歷葉子結點即可。而且由於數據順序排列並且相連，所以便於區間查找和搜索。而B樹則需要進行每一層的遞歸遍歷。相鄰的元素可能在內存中不相鄰，所以緩存命中性沒有B+樹好。</li></ul><p><strong>但是B樹也有優點，其優點在於，由於B樹的每一個節點都包含key和value，因此經常訪問的元素可能離根節點更近，因此訪問也更迅速。</strong></p><p><strong></strong>下面是B 樹和B+樹的區別圖：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1539351206190328a35774d><p class=pgc-img-caption></p></div><p>B/B+樹常用於文件系統和數據庫系統中，它通過對每個節點存儲個數的擴展，使得對連續的數據能夠進行較快的定位和訪問，能夠有效減少查找時間，提高存儲的空間局部性從而減少IO操作。它廣泛用於文件系統及數據庫中，如：</p><ul><li>Windows：HPFS文件系統；</li><li>Mac：HFS，HFS+文件系統；</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系統；</li><li>數據庫：ORACLE，MYSQL，SQLSERVER等中。</li></ul><p><strong>樹表查找總結：</strong></p><p>二叉查找樹平均查找性能不錯，為O(logn)，但是最壞情況會退化為O(n)。在二叉查找樹的基礎上進行優化，我們可以使用平衡查找樹。平衡查找樹中的2-3查找樹，這種數據結構在插入之後能夠進行自平衡操作，從而保證了樹的高度在一定的範圍內進而能夠保證最壞情況下的時間複雜度。但是2-3查找樹實現起來比較困難，紅黑樹是2-3樹的一種簡單高效的實現，他巧妙地使用顏色標記來替代2-3樹中比較難處理的3-node節點問題。紅黑樹是一種比較高效的平衡查找樹，應用非常廣泛，很多編程語言的內部實現都或多或少的採用了紅黑樹。</p><p>除此之外，2-3查找樹的另一個擴展——B/B+平衡樹，在文件系統和數據庫系統中有著廣泛的應用。</p><p class=ql-align-right><br></p><p><strong>6. 分塊查找</strong></p><p>分塊查找又稱索引順序查找，它是順序查找的一種改進方法。</p><p><strong>算法思想：</strong>將n個數據元素"按塊有序"劃分為m塊（m ≤ n）。每一塊中的結點不必有序，但塊與塊之間必須"按塊有序"；即第1塊中任一元素的關鍵字都必須小於第2塊中任一元素的關鍵字；而第2塊中任一元素又都必須小於第3塊中的任一元素，……</p><p><strong>算法流程：</strong></p><p>step1 先選取各塊中的最大關鍵字構成一個索引表；</p><p>step2 查找分兩個部分：先對索引表進行二分查找或順序查找，以確定待查記錄在哪一塊中；然後，在已確定的塊中用順序法進行查找。</p><p class=ql-align-right><br></p><p><strong>7. 哈希查找</strong></p><p><strong>什麼是哈希表（Hash）？</strong></p><p>我們使用一個下標範圍比較大的數組來存儲元素。可以設計一個函數（哈希函數， 也叫做散列函數），使得每個元素的關鍵字都與一個函數值（即數組下標）相對應，於是用這個數組單元來存儲這個元素；也可以簡單的理解為，按照關鍵字為每一個元素"分類"，然後將這個元素存儲在相應"類"所對應的地方。但是，不能夠保證每個元素的關鍵字與函數值是一一對應的，因此極有可能出現對於不同的元素，卻計算出了相同的函數值，這樣就產生了"衝突"，換句話說，就是把不同的元素分在了相同的"類"之中。後面我們將看到一種解決"衝突"的簡便做法。</p><p><strong>總的來說，"直接定址"與"解決衝突"是哈希表的兩大特點。</strong></p><p><strong>什麼是哈希函數？</strong></p><p>哈希函數的規則是：通過某種轉換關係，使關鍵字適度的分散到指定大小的的順序結構中，越分散，則以後查找的時間複雜度越小，空間複雜度越高。</p><p><strong>算法思想：</strong>哈希的思路很簡單，如果所有的鍵都是整數，那麼就可以使用一個簡單的無序數組來實現：將鍵作為索引，值即為其對應的值，這樣就可以快速訪問任意鍵的值。這是對於簡單的鍵的情況，我們將其擴展到可以處理更加複雜的類型的鍵。</p><p><strong>算法流程：</strong></p><p>1）用給定的哈希函數構造哈希表；</p><p>2）根據選擇的衝突處理方法解決地址衝突；</p><p>常見的解決衝突的方法：拉鍊法和線性探測法。詳細的介紹可以參見：淺談算法和數據結構: 十一 哈希表。</p><p>3）在哈希表的基礎上執行哈希查找。</p><p><strong>哈希表是一個在時間和空間上做出權衡的經典例子。如果沒有內存限制，那麼可以直接將鍵作為數組的索引。那麼所有的查找時間複雜度為O(1)；如果沒有時間限制，那麼我們可以使用無序數組並進行順序查找，這樣只需要很少的內存。哈希表使用了適度的時間和空間來在這兩個極端之間找到了平衡。只需要調整哈希函數算法即可在時間和空間上做出取捨。</strong></p><p><strong>複雜度分析</strong>：</p><p>單純論查找複雜度：對於無衝突的Hash表而言，查找複雜度為O(1)（注意，在查找之前我們需要構建相應的Hash表）。</p><p><strong>使用Hash，我們付出了什麼？</strong></p><p>我們在實際編程中存儲一個大規模的數據，最先想到的存儲結構可能就是map，也就是我們常說的KV pair，經常使用Python的博友可能更有這種體會。使用map的好處就是，我們在後續處理數據處理時，可以根據數據的key快速的查找到對應的value值。map的本質就是Hash表，那我們在獲取了超高查找效率的基礎上，我們付出了什麼？</p><p>Hash是一種典型<strong>以空間換時間</strong>的算法，比如原來一個長度為100的數組，對其查找，只需要遍歷且匹配相應記錄即可，從空間複雜度上來看，假如數組存儲的是byte類型數據，那麼該數組佔用100byte空間。現在我們採用Hash算法，我們前面說的Hash必須有一個規則，約束鍵與存儲位置的關係，那麼就需要一個固定長度的hash表，此時，仍然是100byte的數組，假設我們需要的100byte用來記錄鍵與位置的關係，那麼總的空間為200byte,而且用於記錄規則的表大小會根據規則，大小可能是不定的。</p><p>Hash算法和其他查找算法的性能對比：</p><div class=pgc-img><img alt=七大查找算法 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1539351204783ee44f4bf80><p class=pgc-img-caption></p></div><pre>	作者：	Poll的筆記	 		出處：	http://www.cnblogs.com/maybe2030/	 </pre></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>查找</a></li><li><a>七大</a></li><li><a>算法</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html alt=算法小專欄：散列表（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a831970b0ccf4e4cbe591777ebd3f2a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ed4abe39.html title=算法小專欄：散列表（二）>算法小專欄：散列表（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html alt=掌握算法-散列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7fe8d19cb78241e999d77102bee7e16c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/51e4e55b.html title=掌握算法-散列>掌握算法-散列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3e518a2.html alt=化工氧化鋅七大用途—奧龍鋅業 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/03106e1e58af48dda9024bd402fad1b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3e518a2.html title=化工氧化鋅七大用途—奧龍鋅業>化工氧化鋅七大用途—奧龍鋅業</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html alt=C#算法系列（1）——二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2c8de48.html title=C#算法系列（1）——二叉樹>C#算法系列（1）——二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5059752f.html alt=樹、二叉樹、二叉查找樹（二叉搜索樹） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4e1bc62a78434071ba3b874657e974fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5059752f.html title=樹、二叉樹、二叉查找樹（二叉搜索樹）>樹、二叉樹、二叉查找樹（二叉搜索樹）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html alt=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9b2026e861ad49e88e1e124dc67edb32 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d241e092.html title=算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）>算法--二叉樹（平衡二叉樹、搜索二叉樹、完全二叉樹）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html alt=算法題—完全二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ef7d8ad6eaca4524a71e1e5d1277532b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5399b7.html title=算法題—完全二叉樹>算法題—完全二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1b7b6866.html alt=基於一致性算法的微網分佈式有功均衡控制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/39fa00034e1eb30ffce3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1b7b6866.html title=基於一致性算法的微網分佈式有功均衡控制>基於一致性算法的微網分佈式有功均衡控制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html alt=深入淺出排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c898a3bab26542c2965d2bc5bebf9bd8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a61341cf.html title=深入淺出排序算法>深入淺出排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html alt=程序員那些必須掌握的排序算法(上) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c32d187d725f4bd59225a5d09a38cb37 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8257f1b4.html title=程序員那些必須掌握的排序算法(上)>程序員那些必須掌握的排序算法(上)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html alt="算法 － 七大排序算法詳細介紹" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9275d53c0e5f432294fce6dd4cfef236 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/500d3e1f.html title="算法 － 七大排序算法詳細介紹">算法 － 七大排序算法詳細介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9a28bf0.html alt=算法之旅｜冒泡排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/37e00004d03a88913f18 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9a28bf0.html title=算法之旅｜冒泡排序法>算法之旅｜冒泡排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html alt=算法之旅｜快速排序法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/3b0e0000a716d98c3cba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1ca491e3.html title=算法之旅｜快速排序法>算法之旅｜快速排序法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f03920a.html alt=算法入門篇：簡單的排序算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fbaa6f801434986af5ed9e339fd77f1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f03920a.html title=算法入門篇：簡單的排序算法>算法入門篇：簡單的排序算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb1c4077.html alt=算法設計之分治策略 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15394979629303da8548ffa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb1c4077.html title=算法設計之分治策略>算法設計之分治策略</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>