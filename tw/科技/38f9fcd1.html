<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>2020新版Java集合容器面試題 | 极客快訊</title><meta property="og:title" content="2020新版Java集合容器面試題 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/38f9fcd1.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/38f9fcd1.html><meta property="article:published_time" content="2020-10-29T21:09:19+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:19+08:00"><meta name=Keywords content><meta name=description content="2020新版Java集合容器面試題"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/38f9fcd1.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>2020新版Java集合容器面試題</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>集合容器概述</p><p>什麼是集合</p><p>集合的特點</p><p>集合和數組的區別</p><p>使用集合框架的好處</p><p>常用的集合類有哪些？</p><p>List，Set，Map三者的區別？List、Set、Map 是否繼承自 Collection 接口？List、Map、Set 三個接口存取元素時，各有什麼特點？</p><p>集合框架底層數據結構</p><p>哪些集合類是線程安全的？</p><p>Java集合的快速失敗機制 “fail-fast”？</p><p>怎麼確保一個集合不能被修改？</p><p>Collection接口</p><p>List接口</p><p>迭代器 Iterator 是什麼？</p><p>Iterator 怎麼使用？有什麼特點？</p><p>如何邊遍歷邊移除 Collection 中的元素？</p><p>Iterator 和 ListIterator 有什麼區別？</p><p>遍歷一個 List 有哪些不同的方式？每種方法的實現原理是什麼？Java 中 List 遍歷的最佳實踐是什麼？</p><p>說一下 ArrayList 的優缺點</p><p>如何實現數組和 List 之間的轉換？</p><p>ArrayList 和 LinkedList 的區別是什麼？</p><p>ArrayList 和 Vector 的區別是什麼？</p><p>插入數據時，ArrayList、LinkedList、Vector誰速度較快？闡述 ArrayList、Vector、LinkedList 的存儲性能和特性？</p><p>多線程場景下如何使用 ArrayList？</p><p>為什麼 ArrayList 的 elementData 加上 transient 修飾？</p><p>List 和 Set 的區別</p><p>Set接口</p><p>說一下 HashSet 的實現原理？</p><p>HashSet如何檢查重複？HashSet是如何保證數據不可重複的？</p><p>HashSet與HashMap的區別</p><p>Queue</p><p>BlockingQueue是什麼？</p><p>在 Queue 中 poll()和 remove()有什麼區別？</p><p>Map接口</p><p>說一下 HashMap 的實現原理？</p><p>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底層實現</p><p>JDK1.8之前</p><p>JDK1.8之後</p><p>JDK1.7 VS JDK1.8 比較</p><p>HashMap的put方法的具體流程？</p><p>HashMap的擴容操作是怎麼實現的？</p><p>HashMap是怎麼解決哈希衝突的？</p><p>什麼是哈希？</p><p>什麼是哈希衝突？</p><p>HashMap的數據結構</p><p>hash()函數</p><p>JDK1.8新增紅黑樹</p><p>總結</p><p>能否使用任何類作為 Map 的 key？</p><p>為什麼HashMap中String、Integer這樣的包裝類適合作為K？</p><p>如果使用Object作為HashMap的Key，應該怎麼辦呢？</p><p>HashMap為什麼不直接使用hashCode()處理後的哈希值直接作為table的下標？</p><p>HashMap 的長度為什麼是2的冪次方</p><p>HashMap 與 HashTable 有什麼區別？</p><p>如何決定使用 HashMap 還是 TreeMap？</p><p>HashMap 和 ConcurrentHashMap 的區別</p><p>ConcurrentHashMap 和 Hashtable 的區別？</p><p>ConcurrentHashMap 底層具體實現知道嗎？實現原理是什麼？</p><p>輔助工具類</p><p>Array 和 ArrayList 有何區別？</p><p>如何實現 Array 和 List 之間的轉換？</p><p>comparable 和 comparator的區別？</p><p>Collection 和 Collections 有什麼區別？</p><p>TreeMap 和 TreeSet 在排序時如何比較元素？Collections 工具類中的 sort()方法如何比較元素？</p><p>Java面試總結匯總，整理了包括Java基礎知識，集合容器，併發編程，JVM，常用開源框架Spring，MyBatis，數據庫，中間件等，包含了作為一個Java工程師在面試中需要用到或者可能用到的絕大部分知識。歡迎大家閱讀，本人見識有限，寫的博客難免有錯誤或者疏忽的地方，還望各位大佬指點，在此表示感激不盡。文章持續更新中…</p><p>序號 內容 鏈接地址</p><p>1 Java基礎知識面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390612</p><p>2 Java集合容器面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104588551</p><p>3 Java異常面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390689</p><p>4 併發編程面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104863992</p><p>5 JVM面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390752</p><p>6 Spring面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397516</p><p>7 Spring MVC面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397427</p><p>8 Spring Boot面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397299</p><p>9 Spring Cloud面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397367</p><p>10 MyBatis面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/101292950</p><p>11 Redis面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/103522351</p><p>12 MySQL數據庫面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104778621</p><p>13 消息中間件MQ與RabbitMQ面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104588612</p><p>14 Dubbo面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104390006</p><p>15 Linux面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104588679</p><p>16 Tomcat面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397665</p><p>17 ZooKeeper面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104397719</p><p>18 Netty面試題（2020最新版） https://thinkwon.blog.csdn.net/article/details/104391081</p><p>集合容器概述</p><p>什麼是集合</p><p>集合框架：用於存儲數據的容器。</p><p>集合框架是為表示和操作集合而規定的一種統一的標準的體系結構。</p><p>任何集合框架都包含三大塊內容：對外的接口、接口的實現和對集合運算的算法。</p><p>接口：表示集合的抽象數據類型。接口允許我們操作集合時不必關注具體實現，從而達到“多態”。在面向對象編程語言中，接口通常用來形成規範。</p><p>實現：集合接口的具體實現，是重用性很高的數據結構。</p><p>算法：在一個實現了某個集合框架中的接口的對象身上完成某種有用的計算的方法，例如查找、排序等。這些算法通常是多態的，因為相同的方法可以在同一個接口被多個類實現時有不同的表現。事實上，算法是可複用的函數。</p><p>它減少了程序設計的辛勞。</p><p>集合框架通過提供有用的數據結構和算法使你能集中注意力於你的程序的重要部分上，而不是為了讓程序能正常運轉而將注意力於低層設計上。</p><p>通過這些在無關API之間的簡易的互用性，使你免除了為改編對象或轉換代碼以便聯合這些API而去寫大量的代碼。 它提高了程序速度和質量。</p><p>集合的特點</p><p>集合的特點主要有如下兩點：</p><p>對象封裝數據，對象多了也需要存儲。集合用於存儲對象。</p><p>對象的個數確定可以使用數組，對象的個數不確定的可以用集合。因為集合是可變長度的。</p><p>集合和數組的區別</p><p>數組是固定長度的；集合可變長度的。</p><p>數組可以存儲基本數據類型，也可以存儲引用數據類型；集合只能存儲引用數據類型。</p><p>數組存儲的元素必須是同一個數據類型；集合存儲的對象可以是不同數據類型。</p><p>數據結構：就是容器中存儲數據的方式。</p><p>對於集合容器，有很多種。因為每一個容器的自身特點不同，其實原理在於每個容器的內部數據結構不同。</p><p>集合容器在不斷向上抽取過程中，出現了集合體系。在使用一個體系的原則：參閱頂層內容。建立底層對象。</p><p>使用集合框架的好處</p><p>容量自增長；</p><p>提供了高性能的數據結構和算法，使編碼更輕鬆，提高了程序速度和質量；</p><p>允許不同 API 之間的互操作，API之間可以來回傳遞集合；</p><p>可以方便地擴展或改寫集合，提高代碼複用性和可操作性。</p><p>通過使用JDK自帶的集合類，可以降低代碼維護和學習新API成本。</p><p>常用的集合類有哪些？</p><p>Map接口和Collection接口是所有集合框架的父接口：</p><p>Collection接口的子接口包括：Set接口和List接口</p><p>Map接口的實現類主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</p><p>Set接口的實現類主要有：HashSet、TreeSet、LinkedHashSet等</p><p>List接口的實現類主要有：ArrayList、LinkedList、Stack以及Vector等</p><p>List，Set，Map三者的區別？List、Set、Map 是否繼承自 Collection 接口？List、Map、Set 三個接口存取元素時，各有什麼特點？</p><p>Java 容器分為 Collection 和 Map 兩大類，Collection集合的子接口有Set、List、Queue三種子接口。我們比較常用的是Set、List，Map接口不是collection的子接口。</p><p>Collection集合主要有List和Set兩大接口</p><p>List：一個有序（元素存入集合的順序和取出的順序一致）容器，元素可以重複，可以插入多個null元素，元素都有索引。常用的實現類有 ArrayList、LinkedList 和 Vector。</p><p>Set：一個無序（存入和取出順序有可能不一致）容器，不可以存儲重複元素，只允許存入一個null元素，必須保證元素唯一性。Set 接口常用實現類是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>Map是一個鍵值對集合，存儲鍵、值和之間的映射。 Key無序，唯一；value 不要求有序，允許重複。Map沒有繼承於Collection接口，從Map集合中檢索元素時，只要給出鍵對象，就會返回對應的值對象。</p><p>Map 的常用實現類：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</p><p>集合框架底層數據結構</p><p>Collection</p><p>List</p><p>Arraylist： Object數組</p><p>Vector： Object數組</p><p>LinkedList： 雙向循環鏈表</p><p>Set</p><p>HashSet（無序，唯一）：基於 HashMap 實現的，底層採用 HashMap 來保存元素</p><p>LinkedHashSet： LinkedHashSet 繼承與 HashSet，並且其內部是通過 LinkedHashMap 來實現的。有點類似於我們之前說的LinkedHashMap 其內部是基於 Hashmap 實現一樣，不過還是有一點點區別的。</p><p>TreeSet（有序，唯一）： 紅黑樹(自平衡的排序二叉樹。)</p><p>Map</p><p>HashMap： JDK1.8之前HashMap由數組+鏈表組成的，數組是HashMap的主體，鏈表則是主要為了解決哈希衝突而存在的（“拉鍊法”解決衝突）.JDK1.8以後在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間</p><p>LinkedHashMap：LinkedHashMap 繼承自 HashMap，所以它的底層仍然是基於拉鍊式散列結構即由數組和鏈表或紅黑樹組成。另外，LinkedHashMap 在上面結構的基礎上，增加了一條雙向鏈表，使得上面的結構可以保持鍵值對的插入順序。同時通過對鏈表進行相應的操作，實現了訪問順序相關邏輯。</p><p>HashTable： 數組+鏈表組成的，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的</p><p>TreeMap： 紅黑樹（自平衡的排序二叉樹）</p><p>哪些集合類是線程安全的？</p><p>vector：就比arraylist多了個同步化機制（線程安全），因為效率較低，現在已經不太建議使用。在web應用中，特別是前臺頁面，往往效率（頁面響應速度）是優先考慮的。</p><p>statck：堆棧類，先進後出。</p><p>hashtable：就比hashmap多了個線程安全。</p><p>enumeration：枚舉，相當於迭代器。</p><p>Java集合的快速失敗機制 “fail-fast”？</p><p>是java集合的一種錯誤檢測機制，當多個線程對集合進行結構上的改變的操作時，有可能會產生 fail-fast 機制。</p><p>例如：假設存在兩個線程（線程1、線程2），線程1通過Iterator在遍歷集合A中的元素，在某個時候線程2修改了集合A的結構（是結構上面的修改，而不是簡單的修改集合元素的內容），那麼這個時候程序就會拋出 ConcurrentModificationException 異常，從而產生fail-fast機制。</p><p>原因：迭代器在遍歷時直接訪問集合中的內容，並且在遍歷過程中使用一個 modCount 變量。集合在被遍歷期間如果內容發生變化，就會改變modCount的值。每當迭代器使用hashNext()/next()遍歷下一個元素之前，都會檢測modCount變量是否為expectedmodCount值，是的話就返回遍歷；否則拋出異常，終止遍歷。</p><p>解決辦法：</p><p>在遍歷過程中，所有涉及到改變modCount值得地方全部加上synchronized。</p><p>使用CopyOnWriteArrayList來替換ArrayList</p><p>怎麼確保一個集合不能被修改？</p><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法來創建一個只讀集合，這樣改變集合的任何操作都會拋出 Java. lang. UnsupportedOperationException 異常。</p><p>示例代碼如下：</p><p>List&lt;String> list = new ArrayList&lt;>();</p><p>list. add("x");</p><p>Collection&lt;String> clist = Collections. unmodifiableCollection(list);</p><p>clist. add("y"); // 運行時此行報錯</p><p>System. out. println(list. size());</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>Collection接口</p><p>List接口</p><p>迭代器 Iterator 是什麼？</p><p>Iterator 接口提供遍歷任何 Collection 的接口。我們可以從一個 Collection 中使用迭代器方法來獲取迭代器實例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允許調用者在迭代過程中移除元素。</p><p>Iterator 怎麼使用？有什麼特點？</p><p>Iterator 使用代碼如下：</p><p>List&lt;String> list = new ArrayList&lt;>();</p><p>Iterator&lt;String> it = list. iterator();</p><p>while(it. hasNext()){</p><p>String obj = it. next();</p><p>System. out. println(obj);</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>Iterator 的特點是隻能單向遍歷，但是更加安全，因為它可以確保，在當前遍歷的集合元素被更改的時候，就會拋出 ConcurrentModificationException 異常。</p><p>如何邊遍歷邊移除 Collection 中的元素？</p><p>邊遍歷邊修改 Collection 的唯一正確方式是使用 Iterator.remove() 方法，如下：</p><p>Iterator&lt;Integer> it = list.iterator();</p><p>while(it.hasNext()){</p><p>*// do something*</p><p>it.remove();</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>一種最常見的錯誤代碼如下：</p><p>for(Integer i : list){</p><p>list.remove(i)</p><p>}</p><p>1</p><p>2</p><p>3</p><p>運行以上錯誤代碼會報 ConcurrentModificationException 異常。這是因為當使用 foreach(for(Integer i : list)) 語句時，會自動生成一個iterator 來遍歷該 list，但同時該 list 正在被 Iterator.remove() 修改。Java 一般不允許一個線程在遍歷 Collection 時另一個線程修改它。</p><p>Iterator 和 ListIterator 有什麼區別？</p><p>Iterator 可以遍歷 Set 和 List 集合，而 ListIterator 只能遍歷 List。</p><p>Iterator 只能單向遍歷，而 ListIterator 可以雙向遍歷（向前/後遍歷）。</p><p>ListIterator 實現 Iterator 接口，然後添加了一些額外的功能，比如添加一個元素、替換一個元素、獲取前面或後面元素的索引位置。</p><p>遍歷一個 List 有哪些不同的方式？每種方法的實現原理是什麼？Java 中 List 遍歷的最佳實踐是什麼？</p><p>遍歷方式有以下幾種：</p><p>for 循環遍歷，基於計數器。在集合外部維護一個計數器，然後依次讀取每一個位置的元素，當讀取到最後一個元素後停止。</p><p>迭代器遍歷，Iterator。Iterator 是面向對象的一個設計模式，目的是屏蔽不同數據集合的特點，統一遍歷集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p><p>foreach 循環遍歷。foreach 內部也是採用了 Iterator 的方式實現，使用時不需要顯式聲明 Iterator 或計數器。優點是代碼簡潔，不易出錯；缺點是隻能做簡單的遍歷，不能在遍歷過程中操作數據集合，例如刪除、替換。</p><p>最佳實踐：Java Collections 框架中提供了一個 RandomAccess 接口，用來標記 List 實現是否支持 Random Access。</p><p>如果一個數據集合實現了該接口，就意味著它支持 Random Access，按位置讀取元素的平均時間複雜度為 O(1)，如ArrayList。</p><p>如果沒有實現該接口，表示不支持 Random Access，如LinkedList。</p><p>推薦的做法就是，支持 Random Access 的列表可用 for 循環遍歷，否則建議用 Iterator 或 foreach 遍歷。</p><p>說一下 ArrayList 的優缺點</p><p>ArrayList的優點如下：</p><p>ArrayList 底層以數組實現，是一種隨機訪問模式。ArrayList 實現了 RandomAccess 接口，因此查找的時候非常快。</p><p>ArrayList 在順序添加一個元素的時候非常方便。</p><p>ArrayList 的缺點如下：</p><p>刪除元素的時候，需要做一次元素複製操作。如果要複製的元素很多，那麼就會比較耗費性能。</p><p>插入元素的時候，也需要做一次元素複製操作，缺點同上。</p><p>ArrayList 比較適合順序添加、隨機訪問的場景。</p><p>如何實現數組和 List 之間的轉換？</p><p>數組轉 List：使用 Arrays. asList(array) 進行轉換。</p><p>List 轉數組：使用 List 自帶的 toArray() 方法。</p><p>代碼示例：</p><p>// list to array</p><p>List&lt;String> list = new ArrayList&lt;String>();</p><p>list.add("123");</p><p>list.add("456");</p><p>list.toArray();</p><p>// array to list</p><p>String[] array = new String[]{"123","456"};</p><p>Arrays.asList(array);</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>ArrayList 和 LinkedList 的區別是什麼？</p><p>數據結構實現：ArrayList 是動態數組的數據結構實現，而 LinkedList 是雙向鏈表的數據結構實現。</p><p>隨機訪問效率：ArrayList 比 LinkedList 在隨機訪問的時候效率要高，因為 LinkedList 是線性的數據存儲方式，所以需要移動指針從前往後依次查找。</p><p>增加和刪除效率：在非首尾的增加和刪除操作，LinkedList 要比 ArrayList 效率要高，因為 ArrayList 增刪操作要影響數組內的其他數據的下標。</p><p>內存空間佔用：LinkedList 比 ArrayList 更佔內存，因為 LinkedList 的節點除了存儲數據，還存儲了兩個引用，一個指向前一個元素，一個指向後一個元素。</p><p>線程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保證線程安全；</p><p>綜合來說，在需要頻繁讀取集合中的元素時，更推薦使用 ArrayList，而在插入和刪除操作較多時，更推薦使用 LinkedList。</p><p>補充：數據結構基礎之雙向鏈表</p><p>雙向鏈表也叫雙鏈表，是鏈表的一種，它的每個數據結點中都有兩個指針，分別指向直接後繼和直接前驅。所以，從雙向鏈表中的任意一個結點開始，都可以很方便地訪問它的前驅結點和後繼結點。</p><p>ArrayList 和 Vector 的區別是什麼？</p><p>這兩個類都實現了 List 接口（List 接口繼承了 Collection 接口），他們都是有序集合</p><p>線程安全：Vector 使用了 Synchronized 來實現線程同步，是線程安全的，而 ArrayList 是非線程安全的。</p><p>性能：ArrayList 在性能方面要優於 Vector。</p><p>擴容：ArrayList 和 Vector 都會根據實際的需要動態的調整容量，只不過在 Vector 擴容每次會增加 1 倍，而 ArrayList 只會增加 50%。</p><p>Vector類的所有方法都是同步的。可以由兩個線程安全地訪問一個Vector對象、但是一個線程訪問Vector的話代碼要在同步操作上耗費大量的時間。</p><p>Arraylist不是同步的，所以在不需要保證線程安全時時建議使用Arraylist。</p><p>插入數據時，ArrayList、LinkedList、Vector誰速度較快？闡述 ArrayList、Vector、LinkedList 的存儲性能和特性？</p><p>ArrayList、LinkedList、Vector 底層的實現都是使用數組方式存儲數據。數組元素數大於實際存儲的數據以便增加和插入元素，它們都允許直接按序號索引元素，但是插入元素要涉及數組元素移動等內存操作，所以索引數據快而插入數據慢。</p><p>Vector 中的方法由於加了 synchronized 修飾，因此 Vector 是線程安全容器，但性能上較ArrayList差。</p><p>LinkedList 使用雙向鏈表實現存儲，按序號索引數據需要進行前向或後向遍歷，但插入數據時只需要記錄當前項的前後項即可，所以 LinkedList 插入速度較快。</p><p>多線程場景下如何使用 ArrayList？</p><p>ArrayList 不是線程安全的，如果遇到多線程場景，可以通過 Collections 的 synchronizedList 方法將其轉換成線程安全的容器後再使用。例如像下面這樣：</p><p>List&lt;String> synchronizedList = Collections.synchronizedList(list);</p><p>synchronizedList.add("aaa");</p><p>synchronizedList.add("bbb");</p><p>for (int i = 0; i &lt; synchronizedList.size(); i++) {</p><p>System.out.println(synchronizedList.get(i));</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>為什麼 ArrayList 的 elementData 加上 transient 修飾？</p><p>ArrayList 中的數組定義如下：</p><p>private transient Object[] elementData;</p><p>1</p><p>再看一下 ArrayList 的定義：</p><p>public class ArrayList&lt;E> extends AbstractList&lt;E></p><p>implements List&lt;E>, RandomAccess, Cloneable, java.io.Serializable</p><p>1</p><p>2</p><p>可以看到 ArrayList 實現了 Serializable 接口，這意味著 ArrayList 支持序列化。transient 的作用是說不希望 elementData 數組被序列化，重寫了 writeObject 實現：</p><p>private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{</p><p>*// Write out element count, and any hidden stuff*</p><p>int expectedModCount = modCount;</p><p>s.defaultWriteObject();</p><p>*// Write out array length*</p><p>s.writeInt(elementData.length);</p><p>*// Write out all elements in the proper order.*</p><p>for (int i=0; i&lt;size; i++)</p><p>s.writeObject(elementData[i]);</p><p>if (modCount != expectedModCount) {</p><p>throw new ConcurrentModificationException();</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>每次序列化時，先調用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然後遍歷 elementData，只序列化已存入的元素，這樣既加快了序列化的速度，又減小了序列化之後的文件大小。</p><p>List 和 Set 的區別</p><p>List , Set 都是繼承自Collection 接口</p><p>List 特點：一個有序（元素存入集合的順序和取出的順序一致）容器，元素可以重複，可以插入多個null元素，元素都有索引。常用的實現類有 ArrayList、LinkedList 和 Vector。</p><p>Set 特點：一個無序（存入和取出順序有可能不一致）容器，不可以存儲重複元素，只允許存入一個null元素，必須保證元素唯一性。Set 接口常用實現類是 HashSet、LinkedHashSet 以及 TreeSet。</p><p>另外 List 支持for循環，也就是通過下標來遍歷，也可以用迭代器，但是set只能用迭代，因為他無序，無法用下標來取得想要的值。</p><p>Set和List對比</p><p>Set：檢索元素效率低下，刪除和插入效率高，插入和刪除不會引起元素位置改變。</p><p>List：和數組類似，List可以動態增長，查找元素效率高，插入刪除元素效率低，因為會引起其他元素位置改變</p><p>Set接口</p><p>說一下 HashSet 的實現原理？</p><p>HashSet 是基於 HashMap 實現的，HashSet的值存放於HashMap的key上，HashMap的value統一為PRESENT，因此 HashSet 的實現比較簡單，相關 HashSet 的操作，基本上都是直接調用底層 HashMap 的相關方法來完成，HashSet 不允許重複的值。</p><p>HashSet如何檢查重複？HashSet是如何保證數據不可重複的？</p><p>向HashSet 中add ()元素時，判斷元素是否存在的依據，不僅要比較hash值，同時還要結合equles 方法比較。</p><p>HashSet 中的add ()方法會使用HashMap 的put()方法。</p><p>HashMap 的 key 是唯一的，由源碼可以看出 HashSet 添加進去的值就是作為HashMap 的key，並且在HashMap中如果K/V相同時，會用新的V覆蓋掉舊的V，然後返回舊的V。所以不會重複（ HashMap 比較key是否相等是先比較hashcode 再比較equals ）。</p><p>以下是HashSet 部分源碼：</p><p>private static final Object PRESENT = new Object();</p><p>private transient HashMap&lt;E,Object> map;</p><p>public HashSet() {</p><p>map = new HashMap&lt;>();</p><p>}</p><p>public boolean add(E e) {</p><p>// 調用HashMap的put方法,PRESENT是一個至始至終都相同的虛值</p><p>return map.put(e, PRESENT)==null;</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>hashCode（）與equals（）的相關規定：</p><p>如果兩個對象相等，則hashcode一定也是相同的</p><p>兩個對象相等,對兩個equals方法返回true</p><p>兩個對象有相同的hashcode值，它們也不一定是相等的</p><p>綜上，equals方法被覆蓋過，則hashCode方法也必須被覆蓋</p><p>hashCode()的默認行為是對堆上的對象產生獨特值。如果沒有重寫hashCode()，則該class的兩個對象無論如何都不會相等（即使這兩個對象指向相同的數據）。</p><p>==與equals的區別</p><p>==是判斷兩個變量或實例是不是指向同一個內存空間 equals是判斷兩個變量或實例所指向的內存空間的值是不是相同</p><p>==是指對內存地址進行比較 equals()是對字符串的內容進行比較3.==指引用是否相同 equals()指的是值是否相同</p><p>HashSet與HashMap的區別</p><p>HashMap HashSet</p><p>實現了Map接口 實現Set接口</p><p>存儲鍵值對 僅存儲對象</p><p>調用put（）向map中添加元素 調用add（）方法向Set中添加元素</p><p>HashMap使用鍵（Key）計算Hashcode HashSet使用成員對象來計算hashcode值，對於兩個對象來說hashcode可能相同，所以equals()方法用來判斷對象的相等性，如果兩個對象不同的話，那麼返回false</p><p>HashMap相對於HashSet較快，因為它是使用唯一的鍵獲取對象 HashSet較HashMap來說比較慢</p><p>Queue</p><p>BlockingQueue是什麼？</p><p>Java.util.concurrent.BlockingQueue是一個隊列，在進行檢索或移除一個元素的時候，它會等待隊列變為非空；當在添加一個元素時，它會等待隊列中的可用空間。BlockingQueue接口是Java集合框架的一部分，主要用於實現生產者-消費者模式。我們不需要擔心等待生產者有可用的空間，或消費者有可用的對象，因為它都在BlockingQueue的實現類中被處理了。Java提供了集中BlockingQueue的實現，比如ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue,、SynchronousQueue等。</p><p>在 Queue 中 poll()和 remove()有什麼區別？</p><p>相同點：都是返回第一個元素，並在隊列中刪除返回的對象。</p><p>不同點：如果沒有元素 poll()會返回 null，而 remove()會直接拋出 NoSuchElementException 異常。</p><p>代碼示例：</p><p>Queue&lt;String> queue = new LinkedList&lt;String>();</p><p>queue. offer("string"); // add</p><p>System. out. println(queue. poll());</p><p>System. out. println(queue. remove());</p><p>System. out. println(queue. size());</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>Map接口</p><p>說一下 HashMap 的實現原理？</p><p>HashMap概述： HashMap是基於哈希表的Map接口的非同步實現。此實現提供所有可選的映射操作，並允許使用null值和null鍵。此類不保證映射的順序，特別是它不保證該順序恆久不變。</p><p>HashMap的數據結構： 在Java編程語言中，最基本的結構就是兩種，一個是數組，另外一個是模擬指針（引用），所有的數據結構都可以用這兩個基本結構來構造的，HashMap也不例外。HashMap實際上是一個“鏈表散列”的數據結構，即數組和鏈表的結合體。</p><p>HashMap 基於 Hash 算法實現的</p><p>當我們往Hashmap中put元素時，利用key的hashCode重新hash計算出當前對象的元素在數組中的下標</p><p>存儲時，如果出現hash值相同的key，此時有兩種情況。(1)如果key相同，則覆蓋原始值；(2)如果key不同（出現衝突），則將當前的key-value放入鏈表中</p><p>獲取時，直接找到hash值對應的下標，在進一步判斷key是否相同，從而找到對應值。</p><p>理解了以上過程就不難明白HashMap是如何解決hash衝突的問題，核心就是使用了數組的存儲方式，然後將衝突的key的對象放入鏈表中，一旦發現衝突就在鏈表中做進一步的對比。</p><p>需要注意Jdk 1.8中對HashMap的實現做了優化，當鏈表中的節點數據超過八個之後，該鏈表會轉為紅黑樹來提高查詢效率，從原來的O(n)到O(logn)</p><p>HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底層實現</p><p>在Java中，保存數據有兩種比較簡單的數據結構：數組和鏈表。數組的特點是：尋址容易，插入和刪除困難；鏈表的特點是：尋址困難，但插入和刪除容易；所以我們將數組和鏈表結合在一起，發揮兩者各自的優勢，使用一種叫做拉鍊法的方式可以解決哈希衝突。</p><p>JDK1.8之前</p><p>JDK1.8之前採用的是拉鍊法。拉鍊法：將鏈表和數組相結合。也就是說創建一個鏈表數組，數組中每一格就是一個鏈表。若遇到哈希衝突，則將衝突的值加到鏈表中即可。</p><p>JDK1.8之後</p><p>相比於之前的版本，jdk1.8在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。</p><p>JDK1.7 VS JDK1.8 比較</p><p>JDK1.8主要解決或優化了一下問題：</p><p>resize 擴容優化</p><p>引入了紅黑樹，目的是避免單條鏈表過長而影響查詢效率，紅黑樹算法請參考</p><p>解決了多線程死循環問題，但仍是非線程安全的，多線程時可能會造成數據丟失問題。</p><p>不同 JDK 1.7 JDK 1.8</p><p>存儲結構 數組 + 鏈表 數組 + 鏈表 + 紅黑樹</p><p>初始化方式 單獨函數：inflateTable() 直接集成到了擴容函數resize()中</p><p>hash值計算方式 擾動處理 = 9次擾動 = 4次位運算 + 5次異或運算 擾動處理 = 2次擾動 = 1次位運算 + 1次異或運算</p><p>存放數據的規則 無衝突時，存放數組；衝突時，存放鏈表 無衝突時，存放數組；衝突 & 鏈表長度 &lt; 8：存放單鏈表；衝突 & 鏈表長度 &gt; 8：樹化並存放紅黑樹</p><p>插入數據方式 頭插法（先講原位置的數據移到後1位，再插入數據到該位置） 尾插法（直接插入到鏈表尾部/紅黑樹）</p><p>擴容後存儲位置的計算方式 全部按照原來方法進行計算（即hashCode ->> 擾動函數 ->> (h&length-1)）	按照擴容後的規律計算（即擴容後的位置=原位置 or 原位置 + 舊容量）</p><p>HashMap的put方法的具體流程？</p><p>當我們put的時候，首先計算 key的hash值，這裡調用了 hash方法，hash方法實際是讓key.hashCode()與key.hashCode()>>>16進行異或操作，高16bit補0，一個數和0異或不變，所以 hash 函數大概的作用就是：高16bit不變，低16bit和高16bit做了一個異或，目的是減少碰撞。按照函數註釋，因為bucket數組大小是2的冪，計算下標index = (table.length - 1) & hash，如果不做 hash 處理，相當於散列生效的只有幾個低 bit 位，為了減少散列的碰撞，設計者綜合考慮了速度、作用、質量之後，使用高16bit和低16bit異或來簡單處理減少碰撞，而且JDK8中用了複雜度 O（logn）的樹結構來提升碰撞下的性能。</p><p>putVal方法執行流程圖</p><p>public V put(K key, V value) {</p><p>return putVal(hash(key), key, value, false, true);</p><p>}</p><p>static final int hash(Object key) {</p><p>int h;</p><p>return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);</p><p>}</p><p>//實現Map.put和相關方法</p><p>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</p><p>boolean evict) {</p><p>Node&lt;K,V>[] tab; Node&lt;K,V> p; int n, i;</p><p>// 步驟①：tab為空則創建</p><p>// table未初始化或者長度為0，進行擴容</p><p>if ((tab = table) == null || (n = tab.length) == 0)</p><p>n = (tab = resize()).length;</p><p>// 步驟②：計算index，並對null做處理</p><p>// (n - 1) & hash 確定元素存放在哪個桶中，桶為空，新生成結點放入桶中(此時，這個結點是放在數組中)</p><p>if ((p = tab[i = (n - 1) & hash]) == null)</p><p>tab[i] = newNode(hash, key, value, null);</p><p>// 桶中已經存在元素</p><p>else {</p><p>Node&lt;K,V> e; K k;</p><p>// 步驟③：節點key存在，直接覆蓋value</p><p>// 比較桶中第一個元素(數組中的結點)的hash值相等，key相等</p><p>if (p.hash == hash &&</p><p>((k = p.key) == key || (key != null && key.equals(k))))</p><p>// 將第一個元素賦值給e，用e來記錄</p><p>e = p;</p><p>// 步驟④：判斷該鏈為紅黑樹</p><p>// hash值不相等，即key不相等；為紅黑樹結點</p><p>// 如果當前元素類型為TreeNode，表示為紅黑樹，putTreeVal返回待存放的node, e可能為null</p><p>else if (p instanceof TreeNode)</p><p>// 放入樹中</p><p>e = ((TreeNode&lt;K,V>)p).putTreeVal(this, tab, hash, key, value);</p><p>// 步驟⑤：該鏈為鏈表</p><p>// 為鏈表結點</p><p>else {</p><p>// 在鏈表最末插入結點</p><p>for (int binCount = 0; ; ++binCount) {</p><p>// 到達鏈表的尾部</p><p></p><p>//判斷該鏈表尾部指針是不是空的</p><p>if ((e = p.next) == null) {</p><p>// 在尾部插入新結點</p><p>p.next = newNode(hash, key, value, null);</p><p>//判斷鏈表的長度是否達到轉化紅黑樹的臨界值，臨界值為8</p><p>if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st</p><p>//鏈表結構轉樹形結構</p><p>treeifyBin(tab, hash);</p><p>// 跳出循環</p><p>break;</p><p>}</p><p>// 判斷鏈表中結點的key值與插入的元素的key值是否相等</p><p>if (e.hash == hash &&</p><p>((k = e.key) == key || (key != null && key.equals(k))))</p><p>// 相等，跳出循環</p><p>break;</p><p>// 用於遍歷桶中的鏈表，與前面的e = p.next組合，可以遍歷鏈表</p><p>p = e;</p><p>}</p><p>}</p><p>//判斷當前的key已經存在的情況下，再來一個相同的hash值、key值時，返回新來的value這個值</p><p>if (e != null) {</p><p>// 記錄e的value</p><p>V oldValue = e.value;</p><p>// onlyIfAbsent為false或者舊值為null</p><p>if (!onlyIfAbsent || oldValue == null)</p><p>//用新值替換舊值</p><p>e.value = value;</p><p>// 訪問後回調</p><p>afterNodeAccess(e);</p><p>// 返回舊值</p><p>return oldValue;</p><p>}</p><p>}</p><p>// 結構性修改</p><p>++modCount;</p><p>// 步驟⑥：超過最大容量就擴容</p><p>// 實際大小大於閾值則擴容</p><p>if (++size > threshold)</p><p>resize();</p><p>// 插入後回調</p><p>afterNodeInsertion(evict);</p><p>return null;</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p><p>85</p><p>86</p><p>87</p><p>①.判斷鍵值對數組table[i]是否為空或為null，否則執行resize()進行擴容；</p><p>②.根據鍵值key計算hash值得到插入的數組索引i，如果table[i]==null，直接新建節點添加，轉向⑥，如果table[i]不為空，轉向③；</p><p>③.判斷table[i]的首個元素是否和key一樣，如果相同直接覆蓋value，否則轉向④，這裡的相同指的是hashCode以及equals；</p><p>④.判斷table[i] 是否為treeNode，即table[i] 是否是紅黑樹，如果是紅黑樹，則直接在樹中插入鍵值對，否則轉向⑤；</p><p>⑤.遍歷table[i]，判斷鏈表長度是否大於8，大於8的話把鏈表轉換為紅黑樹，在紅黑樹中執行插入操作，否則進行鏈表的插入操作；遍歷過程中若發現key已經存在直接覆蓋value即可；</p><p>⑥.插入成功後，判斷實際存在的鍵值對數量size是否超多了最大容量threshold，如果超過，進行擴容。</p><p>HashMap的擴容操作是怎麼實現的？</p><p>①.在jdk1.8中，resize方法是在hashmap中的鍵值對大於閥值時或者初始化時，就調用resize方法進行擴容；</p><p>②.每次擴展的時候，都是擴展2倍；</p><p>③.擴展後Node對象的位置要麼在原位置，要麼移動到原偏移量兩倍的位置。</p><p>在putVal()中，我們看到在這個函數裡面使用到了2次resize()方法，resize()方法表示的在進行第一次初始化時會對其進行擴容，或者當該數組的實際大小大於其臨界值值(第一次為12),這個時候在擴容的同時也會伴隨的桶上面的元素進行重新分發，這也是JDK1.8版本的一個優化的地方，在1.7中，擴容之後需要重新去計算其Hash值，根據Hash值對其進行分發，但在1.8版本中，則是根據在同一個桶的位置中進行判斷(e.hash & oldCap)是否為0，重新進行hash分配後，該元素的位置要麼停留在原始位置，要麼移動到原始位置+增加的數組大小這個位置上</p><p>final Node&lt;K,V>[] resize() {</p><p>Node&lt;K,V>[] oldTab = table;//oldTab指向hash桶數組</p><p>int oldCap = (oldTab == null) ? 0 : oldTab.length;</p><p>int oldThr = threshold;</p><p>int newCap, newThr = 0;</p><p>if (oldCap > 0) {//如果oldCap不為空的話，就是hash桶數組不為空</p><p>if (oldCap >= MAXIMUM_CAPACITY) {//如果大於最大容量了，就賦值為整數最大的閥值</p><p>threshold = Integer.MAX_VALUE;</p><p>return oldTab;//返回</p><p>}//如果當前hash桶數組的長度在擴容後仍然小於最大容量 並且oldCap大於默認值16</p><p>else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &&</p><p>oldCap >= DEFAULT_INITIAL_CAPACITY)</p><p>newThr = oldThr &lt;&lt; 1; // double threshold 雙倍擴容閥值threshold</p><p>}</p><p>// 舊的容量為0，但threshold大於零，代表有參構造有cap傳入，threshold已經被初始化成最小2的n次冪</p><p>// 直接將該值賦給新的容量</p><p>else if (oldThr > 0) // initial capacity was placed in threshold</p><p>newCap = oldThr;</p><p>// 無參構造創建的map，給出默認容量和threshold 16, 16*0.75</p><p>else { // zero initial threshold signifies using defaults</p><p>newCap = DEFAULT_INITIAL_CAPACITY;</p><p>newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</p><p>}</p><p>// 新的threshold = 新的cap * 0.75</p><p>if (newThr == 0) {</p><p>float ft = (float)newCap * loadFactor;</p><p>newThr = (newCap &lt; MAXIMUM_CAPACITY && ft &lt; (float)MAXIMUM_CAPACITY ?</p><p>(int)ft : Integer.MAX_VALUE);</p><p>}</p><p>threshold = newThr;</p><p>// 計算出新的數組長度後賦給當前成員變量table</p><p>@SuppressWarnings({"rawtypes","unchecked"})</p><p>Node&lt;K,V>[] newTab = (Node&lt;K,V>[])new Node[newCap];//新建hash桶數組</p><p>table = newTab;//將新數組的值複製給舊的hash桶數組</p><p>// 如果原先的數組沒有初始化，那麼resize的初始化工作到此結束，否則進入擴容元素重排邏輯，使其均勻的分散</p><p>if (oldTab != null) {</p><p>// 遍歷新數組的所有桶下標</p><p>for (int j = 0; j &lt; oldCap; ++j) {</p><p>Node&lt;K,V> e;</p><p>if ((e = oldTab[j]) != null) {</p><p>// 舊數組的桶下標賦給臨時變量e，並且解除舊數組中的引用，否則就數組無法被GC回收</p><p>oldTab[j] = null;</p><p>// 如果e.next==null，代表桶中就一個元素，不存在鏈表或者紅黑樹</p><p>if (e.next == null)</p><p>// 用同樣的hash映射算法把該元素加入新的數組</p><p>newTab[e.hash & (newCap - 1)] = e;</p><p>// 如果e是TreeNode並且e.next!=null，那麼處理樹中元素的重排</p><p>else if (e instanceof TreeNode)</p><p>((TreeNode&lt;K,V>)e).split(this, newTab, j, oldCap);</p><p>// e是鏈表的頭並且e.next!=null，那麼處理鏈表中元素重排</p><p>else { // preserve order</p><p>// loHead,loTail 代表擴容後不用變換下標，見注1</p><p>Node&lt;K,V> loHead = null, loTail = null;</p><p>// hiHead,hiTail 代表擴容後變換下標，見注1</p><p>Node&lt;K,V> hiHead = null, hiTail = null;</p><p>Node&lt;K,V> next;</p><p>// 遍歷鏈表</p><p>do {</p><p>next = e.next;</p><p>if ((e.hash & oldCap) == 0) {</p><p>if (loTail == null)</p><p>// 初始化head指向鏈表當前元素e，e不一定是鏈表的第一個元素，初始化後loHead</p><p>// 代表下標保持不變的鏈表的頭元素</p><p>loHead = e;</p><p>else</p><p>// loTail.next指向當前e</p><p>loTail.next = e;</p><p>// loTail指向當前的元素e</p><p>// 初始化後，loTail和loHead指向相同的內存，所以當loTail.next指向下一個元素時，</p><p>// 底層數組中的元素的next引用也相應發生變化，造成lowHead.next.next.....</p><p>// 跟隨loTail同步，使得lowHead可以鏈接到所有屬於該鏈表的元素。</p><p>loTail = e;</p><p>}</p><p>else {</p><p>if (hiTail == null)</p><p>// 初始化head指向鏈表當前元素e, 初始化後hiHead代表下標更改的鏈表頭元素</p><p>hiHead = e;</p><p>else</p><p>hiTail.next = e;</p><p>hiTail = e;</p><p>}</p><p>} while ((e = next) != null);</p><p>// 遍歷結束, 將tail指向null，並把鏈表頭放入新數組的相應下標，形成新的映射。</p><p>if (loTail != null) {</p><p>loTail.next = null;</p><p>newTab[j] = loHead;</p><p>}</p><p>if (hiTail != null) {</p><p>hiTail.next = null;</p><p>newTab[j + oldCap] = hiHead;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>}</p><p>return newTab;</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>33</p><p>34</p><p>35</p><p>36</p><p>37</p><p>38</p><p>39</p><p>40</p><p>41</p><p>42</p><p>43</p><p>44</p><p>45</p><p>46</p><p>47</p><p>48</p><p>49</p><p>50</p><p>51</p><p>52</p><p>53</p><p>54</p><p>55</p><p>56</p><p>57</p><p>58</p><p>59</p><p>60</p><p>61</p><p>62</p><p>63</p><p>64</p><p>65</p><p>66</p><p>67</p><p>68</p><p>69</p><p>70</p><p>71</p><p>72</p><p>73</p><p>74</p><p>75</p><p>76</p><p>77</p><p>78</p><p>79</p><p>80</p><p>81</p><p>82</p><p>83</p><p>84</p><p>85</p><p>86</p><p>87</p><p>88</p><p>89</p><p>90</p><p>91</p><p>92</p><p>93</p><p>94</p><p>95</p><p>96</p><p>97</p><p>HashMap是怎麼解決哈希衝突的？</p><p>答：在解決這個問題之前，我們首先需要知道什麼是哈希衝突，而在瞭解哈希衝突之前我們還要知道什麼是哈希才行；</p><p>什麼是哈希？</p><p>Hash，一般翻譯為“散列”，也有直接音譯為“哈希”的，這就是把任意長度的輸入通過散列算法，變換成固定長度的輸出，該輸出就是散列值（哈希值）；這種轉換是一種壓縮映射，也就是，散列值的空間通常遠小於輸入的空間，不同的輸入可能會散列成相同的輸出，所以不可能從散列值來唯一的確定輸入值。簡單的說就是一種將任意長度的消息壓縮到某一固定長度的消息摘要的函數。</p><p>所有散列函數都有如下一個基本特性**：根據同一散列函數計算出的散列值如果不同，那麼輸入值肯定也不同。但是，根據同一散列函數計算出的散列值如果相同，輸入值不一定相同**。</p><p>什麼是哈希衝突？</p><p>當兩個不同的輸入值，根據同一散列函數計算出相同的散列值的現象，我們就把它叫做碰撞（哈希碰撞）。</p><p>HashMap的數據結構</p><p>在Java中，保存數據有兩種比較簡單的數據結構：數組和鏈表。數組的特點是：尋址容易，插入和刪除困難；鏈表的特點是：尋址困難，但插入和刪除容易；所以我們將數組和鏈表結合在一起，發揮兩者各自的優勢，使用一種叫做鏈地址法的方式可以解決哈希衝突：</p><p>這樣我們就可以將擁有相同哈希值的對象組織成一個鏈表放在hash值所對應的bucket下，但相比於hashCode返回的int類型，我們HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4（即2的四次方16）要遠小於int類型的範圍，所以我們如果只是單純的用hashCode取餘來獲取對應的bucket這將會大大增加哈希碰撞的概率，並且最壞情況下還會將HashMap變成一個單鏈表，所以我們還需要對hashCode作一定的優化</p><p>hash()函數</p><p>上面提到的問題，主要是因為如果使用hashCode取餘，那麼相當於參與運算的只有hashCode的低位，高位是沒有起到任何作用的，所以我們的思路就是讓hashCode取值出的高位也參與運算，進一步降低hash碰撞的概率，使得數據分佈更平均，我們把這樣的操作稱為擾動，在JDK 1.8中的hash()函數如下：</p><p>static final int hash(Object key) {</p><p>int h;</p><p>return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);// 與自己右移16位進行異或運算（高低位異或）</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>這比在JDK 1.7中，更為簡潔，相比在1.7中的4次位運算，5次異或運算（9次擾動），在1.8中，只進行了1次位運算和1次異或運算（2次擾動）；</p><p>JDK1.8新增紅黑樹</p><p>通過上面的鏈地址法（使用散列表）和擾動函數我們成功讓我們的數據分佈更平均，哈希碰撞減少，但是當我們的HashMap中存在大量數據時，加入我們某個bucket下對應的鏈表有n個元素，那麼遍歷時間複雜度就為O(n)，為了針對這個問題，JDK1.8在HashMap中新增了紅黑樹的數據結構，進一步使得遍歷複雜度降低至O(logn)；</p><p>總結</p><p>簡單總結一下HashMap是使用了哪些方法來有效解決哈希衝突的：</p><p>1. 使用鏈地址法（使用散列表）來鏈接擁有相同hash值的數據；</p><p>2. 使用2次擾動函數（hash函數）來降低哈希衝突的概率，使得數據分佈更平均；</p><p>3. 引入紅黑樹進一步降低遍歷的時間複雜度，使得遍歷更快；</p><p>能否使用任何類作為 Map 的 key？</p><p>可以使用任何類作為 Map 的 key，然而在使用之前，需要考慮以下幾點：</p><p>如果類重寫了 equals() 方法，也應該重寫 hashCode() 方法。</p><p>類的所有實例需要遵循與 equals() 和 hashCode() 相關的規則。</p><p>如果一個類沒有使用 equals()，不應該在 hashCode() 中使用它。</p><p>用戶自定義 Key 類最佳實踐是使之為不可變的，這樣 hashCode() 值可以被緩存起來，擁有更好的性能。不可變的類也可以確保 hashCode() 和 equals() 在未來不會改變，這樣就會解決與可變相關的問題了。</p><p>為什麼HashMap中String、Integer這樣的包裝類適合作為K？</p><p>答：String、Integer等包裝類的特性能夠保證Hash值的不可更改性和計算準確性，能夠有效的減少Hash碰撞的機率</p><p>都是final類型，即不可變性，保證key的不可更改性，不會存在獲取hash值不同的情況</p><p>內部已重寫了equals()、hashCode()等方法，遵守了HashMap內部的規範（不清楚可以去上面看看putValue的過程），不容易出現Hash值計算錯誤的情況；</p><p>如果使用Object作為HashMap的Key，應該怎麼辦呢？</p><p>答：重寫hashCode()和equals()方法</p><p>重寫hashCode()是因為需要計算存儲數據的存儲位置，需要注意不要試圖從散列碼計算中排除掉一個對象的關鍵部分來提高性能，這樣雖然能更快但可能會導致更多的Hash碰撞；</p><p>重寫equals()方法，需要遵守自反性、對稱性、傳遞性、一致性以及對於任何非null的引用值x，x.equals(null)必須返回false的這幾個特性，目的是為了保證key在哈希表中的唯一性；</p><p>HashMap為什麼不直接使用hashCode()處理後的哈希值直接作為table的下標？</p><p>答：hashCode()方法返回的是int整數類型，其範圍為-(2 ^ 31)~(2 ^ 31 - 1)，約有40億個映射空間，而HashMap的容量範圍是在16（初始化默認值）~2 ^ 30，HashMap通常情況下是取不到最大值的，並且設備上也難以提供這麼多的存儲空間，從而導致通過hashCode()計算出的哈希值可能不在數組大小範圍內，進而無法匹配存儲位置；</p><p>那怎麼解決呢？</p><p>HashMap自己實現了自己的hash()方法，通過兩次擾動使得它自己的哈希值高低位自行進行異或運算，降低哈希碰撞概率也使得數據分佈更平均；</p><p>在保證數組長度為2的冪次方的時候，使用hash()運算之後的值與運算（&）（數組長度 - 1）來獲取數組下標的方式進行存儲，這樣一來是比取餘操作更加有效率，二來也是因為只有當數組長度為2的冪次方時，h&(length-1)才等價於h%length，三來解決了“哈希值與數組大小範圍不匹配”的問題；</p><p>HashMap 的長度為什麼是2的冪次方</p><p>為了能讓 HashMap 存取高效，儘量較少碰撞，也就是要儘量把數據分配均勻，每個鏈表/紅黑樹長度大致相同。這個實現就是把數據存到哪個鏈表/紅黑樹中的算法。</p><p>這個算法應該如何設計呢？</p><p>我們首先可能會想到採用%取餘的操作來實現。但是，重點來了：“取餘(%)操作中如果除數是2的冪次則等價於與其除數減一的與(&)操作（也就是說 hash%length==hash&(length-1)的前提是 length 是2的 n 次方；）。” 並且 採用二進制位操作 &，相對於%能夠提高運算效率，這就解釋了 HashMap 的長度為什麼是2的冪次方。</p><p>那為什麼是兩次擾動呢？</p><p>答：這樣就是加大哈希值低位的隨機性，使得分佈更均勻，從而提高對應數組存儲下標位置的隨機性&均勻性，最終減少Hash衝突，兩次就夠了，已經達到了高位低位同時參與運算的目的；</p><p>HashMap 與 HashTable 有什麼區別？</p><p>線程安全： HashMap 是非線程安全的，HashTable 是線程安全的；HashTable 內部的方法基本都經過 synchronized 修飾。（如果你要保證線程安全的話就使用 ConcurrentHashMap 吧！）；</p><p>效率： 因為線程安全的問題，HashMap 要比 HashTable 效率高一點。另外，HashTable 基本被淘汰，不要在代碼中使用它；</p><p>對Null key 和Null value的支持： HashMap 中，null 可以作為鍵，這樣的鍵只有一個，可以有一個或多個鍵所對應的值為 null。但是在 HashTable 中 put 進的鍵值只要有一個 null，直接拋NullPointerException。</p><p>**初始容量大小和每次擴充容量大小的不同 **： ①創建時如果不指定容量初始值，Hashtable 默認的初始大小為11，之後每次擴充，容量變為原來的2n+1。HashMap 默認的初始化大小為16。之後每次擴充，容量變為原來的2倍。②創建時如果給定了容量初始值，那麼 Hashtable 會直接使用你給定的大小，而 HashMap 會將其擴充為2的冪次方大小。也就是說 HashMap 總是使用2的冪作為哈希表的大小，後面會介紹到為什麼是2的冪次方。</p><p>底層數據結構： JDK1.8 以後的 HashMap 在解決哈希衝突時有了較大的變化，當鏈表長度大於閾值（默認為8）時，將鏈表轉化為紅黑樹，以減少搜索時間。Hashtable 沒有這樣的機制。</p><p>推薦使用：在 Hashtable 的類註釋可以看到，Hashtable 是保留類不建議使用，推薦在單線程環境下使用 HashMap 替代，如果需要多線程使用則用 ConcurrentHashMap 替代。</p><p>如何決定使用 HashMap 還是 TreeMap？</p><p>對於在Map中插入、刪除和定位元素這類操作，HashMap是最好的選擇。然而，假如你需要對一個有序的key集合進行遍歷，TreeMap是更好的選擇。基於你的collection的大小，也許向HashMap中添加元素會更快，將map換為TreeMap進行有序key的遍歷。</p><p>HashMap 和 ConcurrentHashMap 的區別</p><p>ConcurrentHashMap對整個桶數組進行了分割分段(Segment)，然後在每一個分段上都用lock鎖進行保護，相對於HashTable的synchronized鎖的粒度更精細了一些，併發性能更好，而HashMap沒有鎖機制，不是線程安全的。（JDK1.8之後ConcurrentHashMap啟用了一種全新的方式實現,利用CAS算法。）</p><p>HashMap的鍵值對允許有null，但是ConCurrentHashMap都不允許。</p><p>ConcurrentHashMap 和 Hashtable 的區別？</p><p>ConcurrentHashMap 和 Hashtable 的區別主要體現在實現線程安全的方式上不同。</p><p>底層數據結構： JDK1.7的 ConcurrentHashMap 底層採用 分段的數組+鏈表 實現，JDK1.8 採用的數據結構跟HashMap1.8的結構一樣，數組+鏈表/紅黑二叉樹。Hashtable 和 JDK1.8 之前的 HashMap 的底層數據結構類似都是採用 數組+鏈表 的形式，數組是 HashMap 的主體，鏈表則是主要為了解決哈希衝突而存在的；</p><p>實現線程安全的方式（重要）： ① 在JDK1.7的時候，ConcurrentHashMap（分段鎖） 對整個桶數組進行了分割分段(Segment)，每一把鎖只鎖容器其中一部分數據，多線程訪問容器裡不同數據段的數據，就不會存在鎖競爭，提高併發訪問率。（默認分配16個Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的時候已經摒棄了Segment的概念，而是直接用 Node 數組+鏈表+紅黑樹的數據結構來實現，併發控制使用 synchronized 和 CAS 來操作。（JDK1.6以後 對 synchronized鎖做了很多優化） 整個看起來就像是優化過且線程安全的 HashMap，雖然在JDK1.8中還能看到 Segment 的數據結構，但是已經簡化了屬性，只是為了兼容舊版本；② Hashtable(同一把鎖) :使用 synchronized 來保證線程安全，效率非常低下。當一個線程訪問同步方法時，其他線程也訪問同步方法，可能會進入阻塞或輪詢狀態，如使用 put 添加元素，另一個線程不能使用 put 添加元素，也不能使用 get，競爭會越來越激烈效率越低。</p><p>兩者的對比圖：</p><p>HashTable:</p><p>JDK1.7的ConcurrentHashMap：</p><p>JDK1.8的ConcurrentHashMap（TreeBin: 紅黑二叉樹節點 Node: 鏈表節點）：</p><p>答：ConcurrentHashMap 結合了 HashMap 和 HashTable 二者的優勢。HashMap 沒有考慮同步，HashTable 考慮了同步的問題。但是 HashTable 在每次同步執行時都要鎖住整個結構。 ConcurrentHashMap 鎖的方式是稍微細粒度的。</p><p>ConcurrentHashMap 底層具體實現知道嗎？實現原理是什麼？</p><p>JDK1.7</p><p>首先將數據分為一段一段的存儲，然後給每一段數據配一把鎖，當一個線程佔用鎖訪問其中一個段數據時，其他段的數據也能被其他線程訪問。</p><p>在JDK1.7中，ConcurrentHashMap採用Segment + HashEntry的方式進行實現，結構如下：</p><p>一個 ConcurrentHashMap 裡包含一個 Segment 數組。Segment 的結構和HashMap類似，是一種數組和鏈表結構，一個 Segment 包含一個 HashEntry 數組，每個 HashEntry 是一個鏈表結構的元素，每個 Segment 守護著一個HashEntry數組裡的元素，當對 HashEntry 數組的數據進行修改時，必須首先獲得對應的 Segment的鎖。</p><p>該類包含兩個靜態內部類 HashEntry 和 Segment ；前者用來封裝映射表的鍵值對，後者用來充當鎖的角色；</p><p>Segment 是一種可重入的鎖 ReentrantLock，每個 Segment 守護一個HashEntry 數組裡得元素，當對 HashEntry 數組的數據進行修改時，必須首先獲得對應的 Segment 鎖。</p><p>JDK1.8</p><p>在JDK1.8中，放棄了Segment臃腫的設計，取而代之的是採用Node + CAS + Synchronized來保證併發安全進行實現，synchronized只鎖定當前鏈表或紅黑二叉樹的首節點，這樣只要hash不衝突，就不會產生併發，效率又提升N倍。</p><p>結構如下：</p><p>附加源碼，有需要的可以看看</p><p>插入元素過程（建議去看看源碼）：</p><p>如果相應位置的Node還沒有初始化，則調用CAS插入相應的數據；</p><p>else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {</p><p>if (casTabAt(tab, i, null, new Node&lt;K,V>(hash, key, value, null)))</p><p>break; // no lock when adding to empty bin</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>如果相應位置的Node不為空，且當前該節點不處於移動狀態，則對該節點加synchronized鎖，如果該節點的hash不小於0，則遍歷鏈表更新節點或插入新節點；</p><p>if (fh >= 0) {</p><p>binCount = 1;</p><p>for (Node&lt;K,V> e = f;; ++binCount) {</p><p>K ek;</p><p>if (e.hash == hash &&</p><p>((ek = e.key) == key ||</p><p>(ek != null && key.equals(ek)))) {</p><p>oldVal = e.val;</p><p>if (!onlyIfAbsent)</p><p>e.val = value;</p><p>break;</p><p>}</p><p>Node&lt;K,V> pred = e;</p><p>if ((e = e.next) == null) {</p><p>pred.next = new Node&lt;K,V>(hash, key, value, null);</p><p>break;</p><p>}</p><p>}</p><p>}</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>如果該節點是TreeBin類型的節點，說明是紅黑樹結構，則通過putTreeVal方法往紅黑樹中插入節點；如果binCount不為0，說明put操作對數據產生了影響，如果當前鏈表的個數達到8個，則通過treeifyBin方法轉化為紅黑樹，如果oldVal不為空，說明是一次更新操作，沒有對元素個數產生影響，則直接返回舊值；</p><p>如果插入的是一個新節點，則執行addCount()方法嘗試更新元素個數baseCount；</p><p>輔助工具類</p><p>Array 和 ArrayList 有何區別？</p><p>Array 可以存儲基本數據類型和對象，ArrayList 只能存儲對象。</p><p>Array 是指定固定大小的，而 ArrayList 大小是自動擴展的。</p><p>Array 內置方法沒有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</p><p>對於基本類型數據，集合使用自動裝箱來減少編碼工作量。但是，當處理固定大小的基本數據類型的時候，這種方式相對比較慢。</p><p>如何實現 Array 和 List 之間的轉換？</p><p>Array 轉 List： Arrays. asList(array) ；</p><p>List 轉 Array：List 的 toArray() 方法。</p><p>comparable 和 comparator的區別？</p><p>comparable接口實際上是出自java.lang包，它有一個 compareTo(Object obj)方法用來排序</p><p>comparator接口實際上是出自 java.util 包，它有一個compare(Object obj1, Object obj2)方法用來排序</p><p>一般我們需要對一個集合使用自定義排序時，我們就要重寫compareTo方法或compare方法，當我們需要對某一個集合實現兩種排序方式，比如一個song對象中的歌名和歌手名分別採用一種排序方法的話，我們可以重寫compareTo方法和使用自制的Comparator方法或者以兩個Comparator來實現歌名排序和歌星名排序，第二種代表我們只能使用兩個參數版的Collections.sort().</p><p>Collection 和 Collections 有什麼區別？</p><p>java.util.Collection 是一個集合接口（集合類的一個頂級接口）。它提供了對集合對象進行基本操作的通用接口方法。Collection接口在Java 類庫中有很多具體的實現。Collection接口的意義是為各種具體的集合提供了最大化的統一操作方式，其直接繼承接口有List與Set。</p><p>Collections則是集合類的一個工具類/幫助類，其中提供了一系列靜態方法，用於對集合中元素進行排序、搜索以及線程安全等各種操作。</p><p>TreeMap 和 TreeSet 在排序時如何比較元素？Collections 工具類中的 sort()方法如何比較元素？</p><p>TreeSet 要求存放的對象所屬的類必須實現 Comparable 接口，該接口提供了比較元素的 compareTo()方法，當插入元素時會回調該方法比較元素的大小。TreeMap 要求存放的鍵值對映射的鍵必須實現 Comparable 接口從而根據鍵對元素進 行排 序。</p><p>Collections 工具類的 sort 方法有兩種重載的形式，</p><p>第一種要求傳入的待排序容器中存放的對象比較實現 Comparable 接口以實現元素的比較；</p><p>第二種不強制性的要求容器中的元素必須可比較，但是要求傳入第二個參數，參數是Comparator 接口的子類型（需要重寫 compare 方法實現元素的比較），相當於一個臨時定義的排序規則，其實就是通過接口注入比較元素大小的算法，也是對回調模式的應用（Java 中對函數式編程的支持）。</p><p>————————————————</p><p>作者：ThinkWon</p><p>原文鏈接：https://blog.csdn.net/ThinkWon/java/article/details/104588551</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>2020</a></li><li><a>Java</a></li><li><a>面試題</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/c6fd9493.html alt=2020實習生Java異常面試寶庫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5a151e4b77644d02a99ef893ff41cbfd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c6fd9493.html title=2020實習生Java異常面試寶庫>2020實習生Java異常面試寶庫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f81c047e.html alt=php面試題2020 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/f977fd78-d8cc-462b-8ee7-9002d9d87cd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f81c047e.html title=php面試題2020>php面試題2020</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html alt=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15208700392878e896bf9c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6783330e.html title=Java面試題：詳細說明一下可重入鎖ReentrantLock的原理>Java面試題：詳細說明一下可重入鎖ReentrantLock的原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cefbea7b.html alt=「Java面試題精華集」1w字的Java集合框架篇（2020最新版） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aa8f670cc244471e91fa0a25af703002 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cefbea7b.html title=「Java面試題精華集」1w字的Java集合框架篇（2020最新版）>「Java面試題精華集」1w字的Java集合框架篇（2020最新版）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c15b9453.html alt=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/a0a360ea-5629-4382-b8f0-87c9b83083de style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c15b9453.html title=大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較>大佬分享：京東阿里Java面試題：List和Set比較，各自的子類比較</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdfb1e1.html alt=2020年Java程序員請先把這幾項硬技能熟悉掌握，再想著跳槽拿高薪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4acb45fd2685465d8fad64d41690d296 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdfb1e1.html title=2020年Java程序員請先把這幾項硬技能熟悉掌握，再想著跳槽拿高薪>2020年Java程序員請先把這幾項硬技能熟悉掌握，再想著跳槽拿高薪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4c213e9.html alt="2020款勞斯萊斯庫裡南Black Badge版進店實拍 22英寸鑄造合金輪圈" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d1db0f2d2884c99b22fed2f8726ff26 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4c213e9.html title="2020款勞斯萊斯庫裡南Black Badge版進店實拍 22英寸鑄造合金輪圈">2020款勞斯萊斯庫裡南Black Badge版進店實拍 22英寸鑄造合金輪圈</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2e5827c2.html alt=2020變成“姐姐年”？有一檔新綜藝曝光，名為《不愧是姐姐》 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6090cec007b4477094c4dee77aa55cab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2e5827c2.html title=2020變成“姐姐年”？有一檔新綜藝曝光，名為《不愧是姐姐》>2020變成“姐姐年”？有一檔新綜藝曝光，名為《不愧是姐姐》</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae2d9a0e.html alt=2020年河北省中考物理電學重點實驗-1——探究電流與電阻關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/147a09b4453942c4b8f8f277957352b2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae2d9a0e.html title=2020年河北省中考物理電學重點實驗-1——探究電流與電阻關係>2020年河北省中考物理電學重點實驗-1——探究電流與電阻關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d6c5722.html alt=2020最新網頁設計，入門到精通教程+網頁素材，小白速領 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b1791402c6954e31bde2d2e6686776ce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d6c5722.html title=2020最新網頁設計，入門到精通教程+網頁素材，小白速領>2020最新網頁設計，入門到精通教程+網頁素材，小白速領</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ee5b14e3.html alt=2020年二級建築答案（部分僅供參考） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ee5b14e3.html title=2020年二級建築答案（部分僅供參考）>2020年二級建築答案（部分僅供參考）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/495611a3.html alt="2020 一起感受前沿科學的魅力" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RoKukVcIMipJlM style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/495611a3.html title="2020 一起感受前沿科學的魅力">2020 一起感受前沿科學的魅力</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0437348b.html alt=2020武警/公安部隊院校考試化學--第1課物質分類之元素的基本概念 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3e29dad6969c439eb635b60d7b56ece8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0437348b.html title=2020武警/公安部隊院校考試化學--第1課物質分類之元素的基本概念>2020武警/公安部隊院校考試化學--第1課物質分類之元素的基本概念</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a233d930.html alt="一切以人民利益為中心 ——景德鎮2020年防汛抗洪搶險救災紀實" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4d506eba5ab436ea0c06314cea9156a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a233d930.html title="一切以人民利益為中心 ——景德鎮2020年防汛抗洪搶險救災紀實">一切以人民利益為中心 ——景德鎮2020年防汛抗洪搶險救災紀實</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>