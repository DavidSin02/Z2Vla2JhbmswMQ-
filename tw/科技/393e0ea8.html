<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>spring框架的入門學習：AOP和麵向切面的事務 | 极客快訊</title><meta property="og:title" content="spring框架的入門學習：AOP和麵向切面的事務 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/fb037e70190b458d9f24f56fef7a85d7"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/393e0ea8.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/393e0ea8.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="spring框架的入門學習：AOP和麵向切面的事務"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/393e0ea8.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>spring框架的入門學習：AOP和麵向切面的事務</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>使用註解配置spring，需要以下幾個步驟：</p><p>需要導入一個包：</p><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fb037e70190b458d9f24f56fef7a85d7><p class=pgc-img-caption></p></div><p><br></p><p>步驟1：需要為主配置文件引入新的命名空間（約束），和之前介紹的一樣，導入新的約束：</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4da26c639057465f9a090e469f98e919><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ba06df1c52a74233a21cd14a850183d4><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/5d512a2d066e49e29efcc9f222f09980><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/552e4e21c0ba4702b24bea12acd7e64d><p class=pgc-img-caption></p></div><p>然後在application.xml的Design中右擊beans</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/53e40986bf8146da94fc6a93ec53c48a><p class=pgc-img-caption></p></div><p>然後Add</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/c64f4857747e4b15964bdb1d5d9fde67><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3ae317de62d54bbca1ae15ead89a83b4><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d41ce214201d4562a4994f40b1207d55><p class=pgc-img-caption></p></div><p>這裡面的命名空間使用context，需要指定，這是因為在之前導入Bean命名空間的時候沒有指定，而沒有指定的只能有一個，多個就會出問題，所以以後在導入命名空間都需要指定profix</p><p><strong>2.開啟使用註解代理配置文件</strong></p><p>&lt;context:component-scan base-package="com.huanfeng.bean">&lt;/context:component-scan></p><p>這個配置的就是說spring會去com.huanfeng.bean中掃描所有的註解（包括bean包下面的所有類以及子包下的所有類），那麼我們下面就可以在com.huanfeng.bean下的所有類中使用註解配置文件了</p><p><strong>3.在類中使用註解配置文件</strong></p><p><strong>@Component("user")</strong></p><p><strong>這個配置在類上，表示為類創建一個對象，這個對象的名字是user</strong></p><p><strong>@Service("user")</strong></p><p><strong>@Controller("user")</strong></p><p><strong>@Repository("user")</strong></p><p><strong>以上的三個註解和@Component效果是一樣的，有時候為了將開發者清晰，所以常常使用@Service在service層，使用Controller在web層，使用Repository在dao層</strong></p><p><strong>@Scope(scopeName="singleton")</strong></p><p><strong>這個配置在類上，表示這個類只創建一個對象</strong></p><p><strong>@Value("18")</strong></p><p><strong>private Integer age</strong></p><p><strong>這個是配置直接為屬性賦值，使用了反射的方式，獲取到Field然後賦值</strong></p><p>@Value("huanfeng")</p><p>public void setName(String name){</p><p>this.name=name</p><p>}</p><p>以上是基本類型，如果使用引用類型屬性可以：</p><p>@Autowired</p><p>private Car car</p><p>自動裝配，spring會去尋找car對象賦值給這個屬性，但是當這種類型的對象很多時，將出問題</p><p>@Qualifier("car")</p><p>private Car car</p><p>自動裝配，spring會去尋找名為car的car對象賦值給這個屬性</p><p>@Resource(name="car")</p><p>private Car car</p><p>手動注入，指定注入name為car的對象</p><p>需要注意的是要想注入car，需要在Car類上使用@Component來註明</p><p>這個是配置使用在方法上，這個表示調用setName方法傳遞參數huanfeng，完成為屬性name的賦值工作，這個是和上面的為age屬性賦值是一樣的，不同的是這裡沒有使用反射</p><p>@PostConstruct</p><p>public void init(){...}</p><p>使用這個註解的方法會成為初始化方法，在容器創建對象的時候就會自動調用</p><p>@PreDestroy</p><p>public void destory(){..}</p><p>使用這個註解的方法會成為銷燬方法，在容器銷燬這個對象之前會自動調用</p><pre><code>@Component("user")@Scope(scopeName="singleton")public class User {	@Value("huanfeng")	private String name;	@Value("11")	private Integer age;	@Resource(name="car")	private Car car;		public User(String name,Integer age,Car car) {		System.out.println("執行了構造方法");		this.name=name;		this.age=age;		this.car=car;	}	public Car getCar() {		return car;	}	public void setCar(Car car) {		this.car = car;	}	public User() {		System.out.println("ssas");	}	public String getName() {		return name;	}	public void setName(String name) {		this.name = name;	}	public Integer getAge() {		return age;	}	public void setAge(Integer age) {		this.age = age;	}	@PostConstruct	public void init() {		System.out.println("初始化");	}	@PreDestroy	public void destroy() {		System.out.println("銷燬方法");	}	public String toString() {		return this.age+this.name+this.car.getName();	}	}</code></pre><h1 class=pgc-h-arrow-right>spring中安裝sts插件</h1><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/be15d7c3404c4bef81190169a9ca7baf><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/597a1e2a373e4383b19769a1bd021265><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/cf050de3e47e44459e01090b66b174ad><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fb15981ba94d4800923d1f714f816a1c><p class=pgc-img-caption></p></div><p>之後會等很長的一段時間</p><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/77638b86be354285baa699e554efd0c0><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/02dbb7d1f13942b5a2dfee02ea2377fa><p class=pgc-img-caption></p></div><p>我們無論是使用註解來配置還是使用配置文件來配置，那麼我們都需要測試是否配置成功：</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18e2895cf54247a5bcc1b223e1eb1157><p class=pgc-img-caption></p></div><p><br></p><pre><code>import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.env.SystemEnvironmentPropertySource;import com.huanfeng.bean.Complex;import com.huanfeng.bean.User;public class Demo {	@Test	public void fun1(){		//1 創建容器對象		ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");		//2 向容器"要"user對象		User c = (User) ac.getBean("user");		//3 打印user對象		System.out.println(c);	}}</code></pre><p>這樣的測試方式，每次創建一個測試方法都需要創建一個容器對象，然後獲取到容器中的方法，spring對其進行了整合，使用註解的方式，方便輕鬆</p><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/648a17495ec44e6e98fff674cbbf84d2><p class=pgc-img-caption></p></div><p>如圖所示，我們現需要三個步驟，</p><p>第一步是使用註解讓spring幫助我們創建容器</p><p>第二步是執行創建容器的時候使用哪個配置文件</p><p>第三步是我們想要測試哪個類，我們就寫一個屬性，然後註解這個屬性，那麼spring就會將這個對象賦值給這個屬性，之後我們就可以進行測試了。</p><pre><code>package com.huanfeng.shiyan;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.core.env.SystemEnvironmentPropertySource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.bean.Complex;import com.huanfeng.bean.User;//幫我們創建容器@RunWith(SpringJUnit4ClassRunner.class)//指定創建容器時使用哪個配置文件@ContextConfiguration("classpath:applicationContext.xml")public class Demo {	//將名為user的對象注入到u變量中	@Resource(name="user")	private User u;	@Test	public void fun1(){		System.out.println(u);	}}</code></pre><h1 class=pgc-h-arrow-right>aop</h1><p>aop的核心思想</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6049d0bcbb5a4d1a83bc078a6209f66a><p class=pgc-img-caption></p></div><p>我們可以使用filter來攔截請求，在filter內部使用動態代理來解決request的亂碼問題，這就是aop的思想，spring可以幫助我們生成代理對象，spring有兩種代理方式：</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c49c92cac298465f9296e1eb1f9cba8a><p class=pgc-img-caption></p></div><p>要是使用動態代理需要注意的是被代理對象必須要實現接口才能產生代理對象</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15a4e5dd33b646e2ad0fe1327ad1fa74><p class=pgc-img-caption></p></div><p>在被代理對象中如果沒有實現接口，那麼沒有辦法使用動態代理技術</p><p>cglib代理技術可以對任何類生成代理，代理的原理是對目標對象進行繼承代理，比如我們對A類進行cglib代理，實際上生成的這個代理對象是A類的子類</p><p>spring會優先使用動態代理技術</p><p>我們先來看看手動是如何安排的，下面通過一個具體例子來說明</p><p>具體說是手動的使用動態代理技術來完成對service的增強，也就是說在service中開啟事務</p><p>我們先來建立一個Service的接口：</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5d7b354bd2c949c38f13503db3971c6d><p class=pgc-img-caption></p></div><p>這個service有兩個方法，一個方法是增加方法，另外一個方法是刪除方法，然後創建Service類從而實現這個接口：</p><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/29f8ded1fb234db9ac8a298cb0b5c74c><p class=pgc-img-caption></p></div><p><br></p><pre><code>package com.huanfeng.service;public class UserServiceImpl implements UserService {	@Override	public void add() {		//這裡的工作是增加user		System.out.println("增加");	}	@Override	public void delete() {		//這裡的工作是刪除user		System.out.println("刪除");	}}</code></pre><p>按照之前的時候方法是直接使用Serive就可以了，但是此時的Service並沒有開啟事務，為了解決這個問題，我們可以使用動態代理技術，來對這個Service進行增強</p><p>首先創建一個動態代理類UserServiceProxyFactory</p><pre><code>package com.huanfeng.proxy;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import com.huanfeng.service.UserService;import com.huanfeng.service.UserServiceImpl;public class UserServiceProxyFactory implements InvocationHandler{	private UserService us;	public UserServiceProxyFactory(UserService us){		super();		this.us=us;	}	public UserService getUserServiceProxy() {		UserService userServiceProxy=(UserService) Proxy.newProxyInstance(UserServiceProxyFactory.class.getClassLoader(),UserServiceImpl.class.getInterfaces(),this);		return userServiceProxy;	}	@Override	public Object invoke(Object arg0, Method method, Object[] arg2) throws Throwable {		System.out.println("開啟事務");		Object invoke=method.invoke(us, arg2);		System.out.println("關閉事務");		return invoke;	}}</code></pre><p>首先這個類有一個動態代理UserService的方法，這個getUserServiceProxy方法中使用proxy.newProxyInstance方法，這個方法傳遞三個參數，第一個參數是一個類加載器（隨便一個都行），第二個參數是需要代理類的接口，第三個是InvokeHandler接口，因為我們的這個代理類實現了InvokeHandler接口，所以我們只需要傳遞參數this就好了，然後因為實現了這個接口，所以需要重寫其invoke方法，這個方法的主要參數第二個是增強的方法，第三個是方法的參數，所以我們可以在invoke方法進行內部調用，在調用前後進行方法的增強工作。</p><pre><code>@Test	public void fun3() {		UserService us=new UserServiceImpl();		UserServiceProxyFactory factory=new UserServiceProxyFactory(us);		UserService usProxy=factory.getUserServiceProxy();		usProxy.add();	}</code></pre><p>首先我們創建一個Service，然後創建動態代理類並將這個Service作為參數傳遞。調用getUserServiceProxy方法就可以獲取到這個Service的代理類了，之後只要調用這個方法，其實它都會走代理類的invoke方法，所以我們可以在內部對其進行增強了。</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7a6d58adf7cd4d3ba43406c0d6ecf4c7><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d7f08ee0beeb4e009144b4365f5b0f62><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9dd96c9d14394684980c9d6b7cd063a5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>spring中aop的使用</h1><p>導報：</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b983474fb62e480e9dc5aecf3424b40e><p class=pgc-img-caption></p></div><p>導入aop的約束：</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fd8556412b1349c8ba8c39e977980b5e><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9613735406524b6fae39e7e036d57573><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/06a1e1aebfe3496b82b2566c27eb6177><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/2f62121cadfa4a46991e4b1f8ae219c0><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e10103b08bbc4d4f8b95a18daf892211><p class=pgc-img-caption></p></div><p><strong>第一創建目標對象</strong></p><pre><code>public interface UserService {	public void add();	public void delete();}</code></pre><pre><code>public class UserServiceImpl implements UserService {	@Override	public void add() {		//這裡的工作是增加user		System.out.println("增加");	}	@Override	public void delete() {		//這裡的工作是刪除user		System.out.println("刪除");	}}</code></pre><p><strong>第二:設計通知</strong></p><p><strong>設計一個類，這個類中專門存放需要代理對象的通知，通知總共分為五種：</strong></p><p>前置通知 ：目標方法運行之前調用</p><p>後置通知(如果出現異常不會調用):在目標方法運行之後調用</p><p>環繞通知:在目標方法之前和之後都調用</p><p>異常攔截通知:如果出現異常,就會調用</p><p>後置通知(無論是否出現 異常都會調用):在目標方法運行之後調用</p><pre><code>package com.huang.aop;import org.aspectj.lang.ProceedingJoinPoint;public class MyAdvice {	//前置通知		public void before(){			System.out.println("這是前置通知!!");		}		//後置通知		public void afterReturning(){			System.out.println("這是後置通知(如果出現異常不會調用)!!");		}		//環繞通知		public Object around(ProceedingJoinPoint pjp) throws Throwable {			System.out.println("這是環繞通知之前的部分!!");			Object proceed = pjp.proceed();//調用目標方法			System.out.println("這是環繞通知之後的部分!!");			return proceed;		}		//異常通知		public void afterException(){			System.out.println("出事啦!出現異常了!!");		}		//後置通知		public void after(){			System.out.println("這是後置通知(出現異常也會調用)!!");		}}</code></pre><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7257b18d4ca34246beb74caf922174cf><p class=pgc-img-caption></p></div><p><strong>第三步：織入（使用配置的方式）</strong></p><p><strong>織入分為三步：</strong></p><p><strong>1.配置目標對象</strong></p><p><strong>2.配置通知對象</strong></p><p><strong>3.配置將通知織入目標對象</strong></p><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9a18d717085c47519be9d68c0f0cd5c9><p class=pgc-img-caption></p></div><p><br></p><pre><code>&lt;!-- 1.配置目標對象 --&gt;	&lt;bean name="userService" class="com.huanfeng.service.UserServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置通知對象 --&gt;    &lt;bean name="myAdvice" class="com.huanfeng.aop.MyAdvice"&gt;&lt;/bean&gt;&lt;!-- 3.配置將通知織入目標對象 --&gt;	&lt;aop:config&gt;		&lt;aop:pointcut expression="execution(* com.huanfeng.service.*ServiceImpl.*(..))" id="pc"/&gt;		&lt;aop:aspect ref="myAdvice" &gt;			&lt;!-- 指定名為before方法作為前置通知 --&gt;			&lt;aop:after method="after" pointcut-ref="pc"/&gt;			&lt;aop:before method="before" pointcut-ref="pc" /&gt;			&lt;!-- 後置 --&gt;			&lt;aop:after-returning method="afterReturning" pointcut-ref="pc" /&gt;			&lt;!-- 環繞通知 --&gt;			&lt;aop:around method="around" pointcut-ref="pc" /&gt;			&lt;!-- 異常攔截通知 --&gt;			&lt;aop:after-throwing method="afterException" pointcut-ref="pc"/&gt;			&lt;!-- 後置 --&gt;			&lt;aop:after method="after" pointcut-ref="pc"/&gt;		&lt;/aop:aspect&gt;	&lt;/aop:config&gt;</code></pre><p>這個配置分為三部分：</p><p>第一部分是配置目標對象，使用bean的方式</p><p>第二部分是配置通知對象，使用bean的方式</p><p>第三部分是織入，execution(* com.huanfeng.service.*ServiceImpl.*(..))是固定的第一個*表示返回值任意，然後Service前面的*表示Service前面的任意，然後後面的*表示這個*ServiceImpl下面的所有的方法，(..)表示方法的參數是任意的，我們給這樣的切點起名為pc，然後我們就就可以使用aop:aspect來進行織入了，ref表示增強的方法類，然後在內部對pc進行織入。</p><p>此時&lt;bean name="userService" class="com.huanfeng.service.UserServiceImpl">&lt;/bean>對應的這個類就被增強了</p><p>測試：</p><pre><code>cishipackage com.huanfeng.shiyan;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.bean.User;import com.huanfeng.service.UserService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:applicationContext.xml")public class Demo {	@Resource(name="userService")	private UserService us;		@Test	public void fun1(){		us.add();	}	}</code></pre><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c3de133ae24f476fabf364d1673c5a32><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d07decfdc61b477383b5f3ab83205427><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/7ad0b4e1d24c4704aef69f8e2cbdb1c5><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>spring的註解配置</h1><p>首先使用註解配置需要在xml中完成三步，其中前兩步和前面一樣，後面的一步是開啟註解aop</p><pre><code>&lt;!-- 準備工作: 導入aop(約束)命名空間 --&gt;&lt;!-- 1.配置目標對象 --&gt;	&lt;bean name="userService" class="com.huanfeng.service.UserServiceImpl"&gt;&lt;/bean&gt;&lt;!-- 配置通知對象 --&gt;    &lt;bean name="myAdvice" class="com.huanfeng.annotationaop.MyAdvice"&gt;&lt;/bean&gt;&lt;!-- 開啟使用註解完成織入 --&gt;	&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</code></pre><p>配置好了，之後我們需要在通知對象中進行配置：</p><pre><code>package com.huanfeng.annotationaop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;//@Aspect表示這是一個通知類@Aspectpublic class MyAdvice {	    //前置通知	    @Before("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void before(){			System.out.println("這是前置通知!!");		}		//後置通知	    @AfterReturning("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void afterReturning(){			System.out.println("這是後置通知(如果出現異常不會調用)!!");		}		//環繞通知	    @Around("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public Object around(ProceedingJoinPoint pjp) throws Throwable {			System.out.println("這是環繞通知之前的部分!!");			Object proceed = pjp.proceed();//調用目標方法			System.out.println("這是環繞通知之後的部分!!");			return proceed;		}		//異常通知	    @AfterThrowing("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void afterException(){			System.out.println("出事啦!出現異常了!!");		}		//後置通知	    @After("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void after(){			System.out.println("這是後置通知(出現異常也會調用)!!");		}}</code></pre><p>我們每個通知都寫一個execution太費事了，我們可以統一處理：</p><pre><code>package com.huanfeng.annotationaop;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.After;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.AfterThrowing;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;//@Aspect表示這是一個通知類@Aspectpublic class MyAdvice {	    //前置通知		@Pointcut("execution(* com.huanfeng.service.*ServiceImpl.*(..))")		public void pc(){}	    @Before("MyAdvice.pc()")		public void before(){			System.out.println("這是前置通知!!");		}		//後置通知	    @AfterReturning("MyAdvice.pc()")		public void afterReturning(){			System.out.println("這是後置通知(如果出現異常不會調用)!!");		}		//環繞通知	    @Around("MyAdvice.pc()")		public Object around(ProceedingJoinPoint pjp) throws Throwable {			System.out.println("這是環繞通知之前的部分!!");			Object proceed = pjp.proceed();//調用目標方法			System.out.println("這是環繞通知之後的部分!!");			return proceed;		}		//異常通知	    @AfterThrowing("MyAdvice.pc()")		public void afterException(){			System.out.println("出事啦!出現異常了!!");		}		//後置通知	    @After("MyAdvice.pc()")		public void after(){			System.out.println("這是後置通知(出現異常也會調用)!!");		}}</code></pre><p>之後就可以測試了：</p><pre><code>package com.huanfeng.annotationaop;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.service.UserService;import com.huanfeng.service.UserServiceImpl;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:com/huanfeng/annotationaop/applicationContext.xml")public class Demo {	@Resource(name="userService")	private UserService us;	@Test	public void test1() {		us.add();	}}</code></pre><h1 class=pgc-h-arrow-right>spring整合jdbc模板</h1><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5ca066823dd6442fa12b42bc1983fdb3><p class=pgc-img-caption></p></div><p>JdbcTemplate模板的使用，這個和QueryRunner使用是差不多的，將數據庫連接池連接上就可以進行數據庫操作了</p><pre><code>//創建連接池		ComboPooledDataSource dataSource=new ComboPooledDataSource();		dataSource.setDriverClass("com.mysql.jdbc.Driver");		dataSource.setJdbcUrl("jdbc:mysql:///spring_data");		dataSource.setUser("root");		dataSource.setPassword("root");		//創建JDBC模板對象		JdbcTemplate jt=new JdbcTemplate();		jt.setDataSource(dataSource);		String sql="DELETE FROM shiyan WHERE number='3'";		int i=jt.update(sql);		System.out.println(i);</code></pre><p>上面僅僅介紹瞭如何使用jabcTemplate來完成數據庫的連接工作，對於數據庫的操作而言，需要進行增刪改查的操作，那麼如何使用jdbc進行增刪改查呢</p><pre><code>package com.huanfeng.dao;import java.util.List;import com.huanfeng.dao.User;public interface UserDao {	//增加	void add(User u);	//刪除	void delete(Integer id);	//修改	void update(User u);	//查詢指定id的uesr	User getById(Integer id);	//查詢user總人數	int getTotalCount();	//查詢所有user信息	List&lt;User&gt; getAll();}</code></pre><p>如下所示涵蓋了使用jt處理常見數據庫的增刪改查操作的常用方法，其中除了查詢之外都使用update方法，第一個參數是sql語句，第二個參數是sql語句的？對應的值。</p><p>查詢使用query（獲取list）和queryObject（獲取一個對象或者單個值）都可以使用這種方法，第一個參數是sql，第三個參數是sql中的？（可有可無，這是可變長的參數），第二個是一個RowMapper這個類似於dbutils中的ListHandler,但是這個比較麻煩，需要我們手動的對其進行封裝處理，然後裡面的參數ResultSet表示查詢出來的每一行結果，我們只需要將其封裝成一個user對象就好了，然後它會自動的一次又一次地封裝。</p><p>還有如果查詢出來的結果是一個值，比如查詢count(*)，那麼我們可以使用queryObject，此時的第二個參數就不是RowMapper了，而是這個值對應的類型</p><pre><code>package com.huanfeng.dao;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import com.huanfeng.dao.User;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;public class UserDaoImpl implements UserDao {	private JdbcTemplate jt;	public void setjt(JdbcTemplate jt) {		this.jt=jt;	}	@Override	//這是增加方法	public void add(User u) {		String sql="insert into user values(?,?,null)";		jt.update(sql,u.getName(),u.getAge());	}    //這是刪除方法	@Override	public void delete(Integer id) {		String sql="delete from user where id=?";		jt.update(sql,id);	}	@Override	//這是修改方法	public void update(User u) {		String sql="update user set name=? ,age=? where id=?";		jt.update(sql,u.getName(),u.getAge(),u.getId());	}	@Override	//這是獲取指定id的用戶	public User getById(Integer id) {		String sql="select * from user where id=?";		User u=jt.queryForObject(sql, new RowMapper&lt;User&gt;() {			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setName(rs.getString("name"));				u.setId(rs.getInt("id"));				return u;			}}, id);		return u;	}	@Override	//獲取用戶的數量	public int getTotalCount() {		String sql="select count(*) from user";		Integer c=jt.queryForObject(sql,Integer.class);		return c;	}	@Override	//獲取所有的用戶	public List&lt;User&gt; getAll() {		String sql="select * from user";		List&lt;User&gt; userList=jt.query(sql, new RowMapper&lt;User&gt;(){			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setId(rs.getInt("id"));				u.setName(rs.getString("name"));				return u;			}});		return userList;	}}</code></pre><p>將jdbc整合進spring中，並進行測試：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt;&lt;!-- 1、配置數據庫連接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="jdbc:mysql:///spring_data"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="com.mysql.jbdc.Driver"&gt;&lt;/property&gt;	&lt;property name="user" value="root"&gt;&lt;/property&gt;	&lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 2、配置模板JDBC --&gt;&lt;bean name="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl"&gt;	&lt;property name="jt" ref="jdbcTemplate"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>如上所示要想使用配置JDBC首先需要使用數據庫連接池，然後將jdbc模板配置到userDao中，此時就可以在測試集中直接使用userDao來進行操作了：</p><pre><code>package com.huanfeng.dao;import java.util.List;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.core.env.SystemEnvironmentPropertySource;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:com/huanfeng/dao/applicationContext.xml")public class Demo {	@Resource(name="userDao")	private UserDao ud;	@Test	public void test1() {		User u=new User();		u.setAge(100);		u.setName("xia");		u.setId(3);		ud.add(u);	}	@Test	public void test2() {		ud.delete(1);	}	@Test	public void test3() {		User u=new User();		u.setAge(100);		u.setName("xiaoo");		u.setId(3);		ud.update(u);	}	@Test	public void test4() {		User u=ud.getById(2);		System.out.println(u);	}	@Test	public void test5() {		int c=ud.getTotalCount();		System.out.println(c);	}	@Test	public void test6() {		List&lt;User&gt; l=ud.getAll();		System.out.println(l);	}}</code></pre><p>jdbc的擴展，在之前我們使用了JdbcTemplate的時候使用了UserDaoImpl進行了參數傳遞，是否可以不進行這樣地操作了？可以具體來說首先UserDaoImpl中使用，我們需要繼承：</p><p>JdbcDaoSupport</p><p>這樣就可以通過super.getJdbcTemplate()獲取jdbc模板對象了。</p><p>那麼在xml中就不用配置模板對象了，但是需要將數據庫連接池配置到UserServiceDao中：</p><pre><code>package com.huanfeng.dao;import java.sql.ResultSet;import java.sql.SQLException;import java.util.List;import com.huanfeng.dao.User;import org.springframework.jdbc.core.JdbcTemplate;import org.springframework.jdbc.core.RowMapper;import org.springframework.jdbc.core.support.JdbcDaoSupport;public class UserDaoImpl2 extends JdbcDaoSupport implements UserDao {	@Override	//這是增加方法	public void add(User u) {		String sql="insert into user values(?,?,null)";		super.getJdbcTemplate().update(sql,u.getName(),u.getAge());	}    //這是刪除方法	@Override	public void delete(Integer id) {		String sql="delete from user where id=?";		super.getJdbcTemplate().update(sql,id);	}	@Override	//這是修改方法	public void update(User u) {		String sql="update user set name=?, age=? where id=?";		super.getJdbcTemplate().update(sql,u.getName(),u.getAge(),u.getId());	}	@Override	//這是獲取指定id的用戶	public User getById(Integer id) {		String sql="select * from user where id=?";		User u=super.getJdbcTemplate().queryForObject(sql, new RowMapper&lt;User&gt;() {			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setName(rs.getString("name"));				u.setId(rs.getInt("id"));				return u;			}}, id);		return u;	}	@Override	//獲取用戶的數量	public int getTotalCount() {		String sql="select count(*) from user";		Integer c=super.getJdbcTemplate().queryForObject(sql,Integer.class);		return c;	}	@Override	//獲取所有的用戶	public List&lt;User&gt; getAll() {		String sql="select * from user";		List&lt;User&gt; userList=super.getJdbcTemplate().query(sql, new RowMapper&lt;User&gt;(){			@Override			public User mapRow(ResultSet rs, int arg1) throws SQLException {				User u=new User();				u.setAge(rs.getInt("age"));				u.setId(rs.getInt("id"));				u.setName(rs.getString("name"));				return u;			}});		return userList;	}}</code></pre><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd "&gt;&lt;!-- 1、配置數據庫連接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="jdbc:mysql:///spring_data"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="com.mysql.jbdc.Driver"&gt;&lt;/property&gt;	&lt;property name="user" value="root"&gt;&lt;/property&gt;	&lt;property name="password" value="root"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl2"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>將數據庫連接池的配置到配置文件中：</p><pre><code>jdbc.jdbcUrl=jdbc:mysql:///spring_datajdbc.driverClass=com.mysql.jdbc.Driverjdbc.user=rootjdbc.password=root</code></pre><p>之後在xml中就可以這樣進行配置了</p><pre><code>&lt;context:property-placeholder location="classpath:db.properties"  /&gt;&lt;!-- 1、配置數據庫連接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><h1 class=pgc-h-arrow-right>事務</h1><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/def44838ec284d2aa703a724d3b892dd><p class=pgc-img-caption></p></div><p><strong>事務的傳播行為：</strong></p><blockquote class=pgc-blockquote-abstract><p>PROPAGION_XXX :事務的傳播行為 * 保證同一個事務中 PROPAGATION_REQUIRED 支持當前事務，如果不存在 就新建一個(默認) PROPAGATION_SUPPORTS 支持當前事務，如果不存在，就不使用事務 PROPAGATION_MANDATORY 支持當前事務，如果不存在，拋出異常</p><p><br></p><p>* 保證沒有在同一個事務中 PROPAGATION_REQUIRES_NEW 如果有事務存在，掛起當前事務，創建一個新的事務 PROPAGATION_NOT_SUPPORTED 以非事務方式運行，如果有事務存在，掛起當前事務</p><p><br></p><p>PROPAGATION_NEVER 以非事務方式運行，如果有事務存在，拋出異常</p><p><br></p><p>PROPAGATION_NESTED 如果當前事務存在，則嵌套事務執行</p></blockquote><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/66cfafbc03144d848bc806c01940f174><p class=pgc-img-caption></p></div><p>事務，轉賬</p><p>首先在xml中配置好數據庫連接池，事務，以及service和dao：</p><pre><code>&lt;!-- 事務核心管理器，封裝了所有事務操作 --&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt;	&lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事務模板對象 --&gt;&lt;bean name="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt;	&lt;property name="transactionManager" ref="transactionManager" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 1、配置數據庫連接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="AccountDao" class="com.huanfeng.dao.AccountDaoImpl"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;                           &lt;bean name="AccountService" class="com.huanfeng.service.AccountServiceImpl"&gt;	&lt;property name="ad" ref="AccountDao"&gt;&lt;/property&gt;	&lt;property name="tt" ref="transactionTemplate" &gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>首先配置事務的核心管理器，裡面需要依賴數據庫連接池，然後配置事務模板對象，這個依賴事務的核心管理器。</p><p>之後配置service和dao，dao中由於使用了繼承JdbcDaoSupport，所以這裡需要依賴數據庫連接池，然後Service不僅依賴dao，而且還依賴事務模板對象。</p><pre><code>package com.huanfeng.dao;public interface AccountDao {	void increaseMoney(Integer id,Double money);	void decreaseMoney(Integer id,Double money);}</code></pre><pre><code>package com.huanfeng.dao;import org.springframework.jdbc.core.support.JdbcDaoSupport;public class AccountDaoImpl extends JdbcDaoSupport implements AccountDao {	@Override	public void increaseMoney(Integer id, Double money) {		String sql="update table_count set money=money+? where id=?";		super.getJdbcTemplate().update(sql,money,id);	}	@Override	public void decreaseMoney(Integer id, Double money) {		String sql="update table_count set money=money-? where id=?";		super.getJdbcTemplate().update(sql,money,id);	}}</code></pre><pre><code>package com.huanfeng.service;public interface AccountService {	public void transfer(Integer from,Integer to,Double money);}</code></pre><pre><code>package com.huanfeng.service;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.TransactionCallbackWithoutResult;import org.springframework.transaction.support.TransactionTemplate;import com.huanfeng.dao.AccountDao;public class AccountServiceImpl implements AccountService {	private AccountDao ad;	private TransactionTemplate tt;	public TransactionTemplate getTt() {		return tt;	}	public void setTt(TransactionTemplate tt) {		this.tt = tt;	}	public AccountDao getAd() {		return ad;	}	public void setAd(AccountDao ad) {		this.ad = ad;	}	@Override	public void transfer(Integer from, Integer to, Double money) {				tt.execute(new TransactionCallbackWithoutResult() {			@Override			protected void doInTransactionWithoutResult(TransactionStatus arg0) {				//減錢				ad.decreaseMoney(from, money);				//加錢				ad.increaseMoney(to, money);			}		});	}}</code></pre><p>AccountServiceImpl中需要TransactionTemplate事務模板對象，以便於開啟事務，之後可以測試了：</p><pre><code>package com.huanfeng.transaction;import javax.annotation.Resource;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import com.huanfeng.service.AccountService;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration("classpath:com/huanfeng/dao/applicationContext3.xml")public class Demo1 {	@Resource(name="AccountService")	private AccountService as;	@Test	public void test1() {		as.transfer(1, 2, 500d);	}}</code></pre><h1 class=pgc-h-arrow-right>aop配置事務</h1><p>首先配置約束</p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/37ff33c55009412c852b351d1e7d3ed8><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/72b21a1a1883496ebc4ed65d578a60e1><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4b4ac682a46a4a669f21abb5c2748bd5><p class=pgc-img-caption></p></div><p><br></p><div class=pgc-img><img alt=spring框架的入門學習：AOP和麵向切面的事務 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/104e2d77dbd54ba2978ff1021c27da32><p class=pgc-img-caption></p></div><p>事務本身就需要開啟事務以及關閉事務，所以可以使用面向切面的思想來對service中的方法進行增強，spring已經寫好了通知，所以不需要我們寫通知了，我們可以通過tx:advice來配置事務通知，然後將這個通知織入到service方法中，那麼此時的service都是被事務增強的方法，之後就不需要手動增加事務了。配置如下：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd "&gt;&lt;context:property-placeholder location="classpath:db.properties"  /&gt;&lt;!-- 事務核心管理器，封裝了所有事務操作 --&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt;	&lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事務模板對象 --&gt;&lt;bean name="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt;	&lt;property name="transactionManager" ref="transactionManager" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:advice id="txAdvice" transaction-manager="transactionManager" &gt;	&lt;tx:attributes&gt;		&lt;!-- 以方法為單位,指定方法應用什麼事務屬性			isolation:隔離級別			propagation:傳播行為			read-only:是否只讀		 --&gt;		&lt;tx:method name="save*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="persist*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="update*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="modify*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="delete*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="remove*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;		&lt;tx:method name="get*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt;		&lt;tx:method name="find*" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="true" /&gt;		&lt;tx:method name="transfer" isolation="REPEATABLE_READ" propagation="REQUIRED" read-only="false" /&gt;	&lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!-- 配置織入 --&gt;&lt;aop:config  &gt;	&lt;!-- 配置切點表達式 --&gt;	&lt;aop:pointcut expression="execution(* com.huanfeng.service.*ServiceImpl.*(..))" id="txPc"/&gt;	&lt;!-- 配置切面 : 通知+切點		 	advice-ref:通知的名稱		 	pointcut-ref:切點的名稱	 --&gt;	&lt;aop:advisor advice-ref="txAdvice" pointcut-ref="txPc" /&gt;&lt;/aop:config&gt;&lt;!-- 1、配置數據庫連接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl2"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="AccountDao" class="com.huanfeng.dao.AccountDaoImpl"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;                           &lt;bean name="AccountService" class="com.huanfeng.service.AccountServiceImpl"&gt;	&lt;property name="ad" ref="AccountDao"&gt;&lt;/property&gt;	&lt;property name="tt" ref="transactionTemplate" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>之後再servie中直接調用dao中的方法就可以了：</p><pre><code>public void transfer(Integer from, Integer to, Double money) {				//減錢				ad.decreaseMoney(from, money);				//加錢				ad.increaseMoney(to, money);	}</code></pre><p>下面學習一下註解的配置方式</p><p>我們可以將前面的通知和織入全部刪掉，使用&lt;tx:annotation-driven/>，此時的xml配置為：</p><pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd "&gt;&lt;context:property-placeholder location="classpath:db.properties"  /&gt;&lt;!-- 事務核心管理器，封裝了所有事務操作 --&gt;&lt;bean name="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" &gt;	&lt;property name="dataSource" ref="dataSource" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 事務模板對象 --&gt;&lt;bean name="transactionTemplate" class="org.springframework.transaction.support.TransactionTemplate" &gt;	&lt;property name="transactionManager" ref="transactionManager" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:annotation-driven/&gt;&lt;!-- 1、配置數據庫連接池 --&gt;&lt;bean name="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt;	&lt;property name="jdbcUrl" value="${jdbc.jdbcUrl}"&gt;&lt;/property&gt;	&lt;property name="driverClass" value="${jdbc.driverClass}"&gt;&lt;/property&gt;	&lt;property name="user" value="${jdbc.user}"&gt;&lt;/property&gt;	&lt;property name="password" value="${jdbc.password}"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 3、配置UserDao --&gt;&lt;bean name="userDao" class="com.huanfeng.dao.UserDaoImpl2"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name="AccountDao" class="com.huanfeng.dao.AccountDaoImpl"&gt;	&lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt;                           &lt;bean name="AccountService" class="com.huanfeng.service.AccountServiceImpl"&gt;	&lt;property name="ad" ref="AccountDao"&gt;&lt;/property&gt;	&lt;property name="tt" ref="transactionTemplate" &gt;&lt;/property&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>然後使用的時候可以直接在service中進行配置：</p><pre><code>@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)public void transfer(Integer from, Integer to, Double money) {				ad.decreaseMoney(from, money);				ad.increaseMoney(to, money);	}</code></pre><p>我們可以使用@Transational來直接在方法同配置通知，此時表示這個方法被事務通知增強了，當然如果每個方法都這樣配置感覺麻煩，我們還可以直接配置在類上，這樣表示這個類的所有方法都被增強了，但是第一優先級應該還是方法。</p><pre><code>@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=true)public class AccountServiceImpl implements AccountService {	private AccountDao ad ;	private TransactionTemplate tt;		@Override	@Transactional(isolation=Isolation.REPEATABLE_READ,propagation=Propagation.REQUIRED,readOnly=false)	public void transfer(final Integer from,final Integer to,final Double money) {				//減錢				ad.decreaseMoney(from, money);				int i = 1/0;				//加錢				ad.increaseMoney(to, money);	}}</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>spring</a></li><li><a>入門</a></li><li><a>學習</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html alt=“黑客”入門學習之“Windows組策略” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ea21244d5f5c420ebef29650f3fafd1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d4007c7.html title=“黑客”入門學習之“Windows組策略”>“黑客”入門學習之“Windows組策略”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f71cd4af.html alt=機器學習入門第2章：SVM（支持向量機）—編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/28eb40e101e44cfb8b88aac745d012d6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f71cd4af.html title=機器學習入門第2章：SVM（支持向量機）—編碼>機器學習入門第2章：SVM（支持向量機）—編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c914526c.html alt=新手入門PLC，掌握學習方法是關鍵 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15355275026304e8d787f10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c914526c.html title=新手入門PLC，掌握學習方法是關鍵>新手入門PLC，掌握學習方法是關鍵</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2aaf38ea.html alt=“黑客”入門學習之“信息安全簡述” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ae5313b1231494cb2eec2d2657289ae style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2aaf38ea.html title=“黑客”入門學習之“信息安全簡述”>“黑客”入門學習之“信息安全簡述”</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/7a77e853.html alt=深度學習入門數學基礎之線性代數篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1522048354223acb78307ba style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/7a77e853.html title=深度學習入門數學基礎之線性代數篇>深度學習入門數學基礎之線性代數篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/c75c54fc.html alt=機器學習入門第2章：SVM（支持向量機）—理論 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/db2b59aa64f64e189449ae9773356bed style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/c75c54fc.html title=機器學習入門第2章：SVM（支持向量機）—理論>機器學習入門第2章：SVM（支持向量機）—理論</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9b52b0.html alt=機器學習入門第1章：監督學習和樸素貝葉斯分類-第2部分（編碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a6894d2d1ea64a8eb3bad2b892648639 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9b52b0.html title=機器學習入門第1章：監督學習和樸素貝葉斯分類-第2部分（編碼）>機器學習入門第1章：監督學習和樸素貝葉斯分類-第2部分（編碼）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d29cd6d.html alt=成人鋼琴學習入門指南 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c0168ea4584a445b89b410158f81b7d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d29cd6d.html title=成人鋼琴學習入門指南>成人鋼琴學習入門指南</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d131d60.html alt=韓語入門學習：學唱韓語歌曲、認識韓語四十音 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/afc028cd90fe485c92d9bc41d553c3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d131d60.html title=韓語入門學習：學唱韓語歌曲、認識韓語四十音>韓語入門學習：學唱韓語歌曲、認識韓語四十音</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b5cbda.html alt=機器學習入門：偏差和方差 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e4d7bca8189b4528b0f564ee473d2a68 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b5cbda.html title=機器學習入門：偏差和方差>機器學習入門：偏差和方差</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html alt=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/13adbab9c7f94c7fa81d49a98861b051 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc2af9c9.html title=機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式>機器學習筆記(七)——初識邏輯迴歸、不同方法推導梯度公式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e214e6d7.html alt=深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1540372101455de0fb74774 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e214e6d7.html title=深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開>深度學習/機器學習入門數學知識整理（二）梯度與導數，泰勒展開</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f3767255.html alt=講透機器學習中的梯度下降 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5c80301e53424671bc22755be2e4ee33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f3767255.html title=講透機器學習中的梯度下降>講透機器學習中的梯度下降</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html alt="前端 | HTML入門基礎知識-網頁" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e7a0b61194f445b8b9e5ae330961d2ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6fe27eab.html title="前端 | HTML入門基礎知識-網頁">前端 | HTML入門基礎知識-網頁</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac12f3a1.html alt=直流鍋爐給水控制學習 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/eba10edcc8d14d9f8cde6fd5b212d90e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac12f3a1.html title=直流鍋爐給水控制學習>直流鍋爐給水控制學習</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>