<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>為什麼 TCP 協議有 TIME_WAIT 狀態 | 极客快訊</title><meta property="og:title" content="為什麼 TCP 協議有 TIME_WAIT 狀態 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fd7b2fa0b4564ea7a542dd857e57125a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a3e575.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a3e575.html><meta property="article:published_time" content="2020-10-29T20:50:28+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:28+08:00"><meta name=Keywords content><meta name=description content="為什麼 TCP 協議有 TIME_WAIT 狀態"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3a3e575.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>為什麼 TCP 協議有 TIME_WAIT 狀態</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote><p>為什麼這麼設計（Why’s THE Design）是一系列關於計算機領域中程序設計決策的文章，我們在這個系列的每一篇文章中都會提出一個具體的問題並從不同的角度討論這種設計的優缺點、對具體實現造成的影響。</p></blockquote><p>在這個系列前面的文章中，我們已經多次討論 TCP 協議的設計原理，其中包括 TCP 協議的 三次握手、流量控制和重傳機制、最大數據段 以及 粘包 等問題。本文將繼續分析 TCP 協議的實現細節，今天要分析的問題是為什麼 TCP 協議需要 TIME_WAIT 狀態以及該狀態的作用究竟是什麼。</p><p>TCP 協議中包含 11 種不同的狀態，TCP 連接會根據發送或者接收到的消息轉換狀態，如下圖所示的狀態機展示了所有可能的轉換，其中不僅包含了正常情況下的狀態轉換過程，還包含了異常狀態下的狀態轉換：</p><p><strong>圖 1 - TCP 協議狀態</strong></p><p>使用 TCP 協議通信的雙方會在關閉連接時觸發 TIME_WAIT 狀態，關閉連接的操作其實是告訴通信的另一方<strong>自己沒有需要發送的數據</strong>，但是它仍然<strong>保持了接收對方數據的能力</strong>，一個常見的關閉連接過程如下[^1]：</p><ol start=1><li>當客戶端沒有待發送的數據時，它會向服務端發送 FIN 消息，發送消息後會進入 FIN_WAIT_1 狀態；</li><li>服務端接收到客戶端的 FIN 消息後，會進入 CLOSE_WAIT 狀態並向客戶端發送 ACK 消息，客戶端接收到 ACK 消息時會進入 FIN_WAIT_2 狀態；</li><li>當服務端沒有待發送的數據時，服務端會向客戶端發送 FIN 消息；</li><li>客戶端接收到 FIN 消息後，會進入 TIME_WAIT 狀態並向服務端發送 ACK 消息，服務端收到後會進入 CLOSED 狀態；</li><li>客戶端等待<strong>兩個最大數據段生命週期</strong>（Maximum segment lifetime，MSL）[^2]的時間後也會進入 CLOSED 狀態；</li></ol><div class=pgc-img><img alt="為什麼 TCP 協議有 TIME_WAIT 狀態" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fd7b2fa0b4564ea7a542dd857e57125a><p class=pgc-img-caption></p></div><p><strong>圖 2 - TCP 關閉連接的過程</strong></p><p>從上述過程中，我們會發現 TIME_WAIT 僅在主動斷開連接的一方出現，被動斷開連接的一方會直接進入 CLOSED 狀態，進入 TIME_WAIT 的客戶端需要等待 2 MSL 才可以真正關閉連接。TCP 協議需要 TIME_WAIT 狀態的原因和客戶端需要等待兩個 MSL 不能直接進入 CLOSED 狀態的原因是一樣的[^3]：</p><ul><li>防止延遲的數據段被其他使用相同源地址、源端口、目的地址以及目的端口的 TCP 連接收到；</li><li>保證 TCP 連接的遠程被正確關閉，即等待被動關閉連接的一方收到 FIN 對應的 ACK 消息；</li></ul><p>上述兩個原因都相對比較簡單，我們來展開介紹這兩個原因背後可能存在的一些問題。</p><h2 class=pgc-h-arrow-right>阻止延遲數據段</h2><p>每一個 TCP 數據段都包含唯一的序列號，這個序列號能夠保證 TCP 協議的可靠性和順序性，在不考慮序列號溢出歸零的情況下，序列號唯一是 TCP 協議中的重要約定，一旦違反了這條規則，就可能造成令人困惑的現象和結果。為了保證新 TCP 連接的數據段不會與還在網絡中傳輸的歷史連接的數據段重複，TCP 連接在分配新的序列號之前需要<strong>至少靜默數據段在網絡中能夠存活的最長時間，即 MSL</strong>[^4]：</p><blockquote><p>To be sure that a TCP does not create a segment that carries a sequence number which may be duplicated by an old segment remaining in the network, the TCP must keep quiet for a maximum segment lifetime (MSL) before assigning any sequence numbers upon starting up or recovering from a crash in which memory of sequence numbers in use was lost.</p></blockquote><div class=pgc-img><img alt="為什麼 TCP 協議有 TIME_WAIT 狀態" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5c40c4dd18e54079afd95d903366e238><p class=pgc-img-caption></p></div><p><strong>圖 3 - TIME-WAIT 較短導致的數據段延遲接收</strong></p><p>在如上圖所示的 TCP 連接中，服務端發送的 SEQ = 301 消息由於網絡延遲直到 TCP 連接關閉後也沒有收到；當使用相同端口號的 TCP 連接被重用後，SEQ = 301 的消息才發送到客戶端，然而這個過期的消息卻可能被客戶端正常接收，這就會帶來比較嚴重的問題，所以我們<strong>在調整 TIME_WAIT 策略時要非常謹慎</strong>，必須清楚自己在幹什麼。</p><p>RFC 793 中雖然指出了 TCP 連接需要在 TIME_WAIT 中等待 2 倍的 MSL，但是並沒有解釋清楚這裡的兩倍是從何而來，比較合理的解釋是 — 網絡中可能存在來自發起方的數據段，當這些發起方的數據段被服務端處理後又會向客戶端發送響應，所以一來一回需要等待 2 倍的時間[^5]。</p><p>RFC 793 文檔將 MSL 的時間設置為 120 秒，即兩分鐘，然而這並不是一個經過嚴密推斷的數值，而是工程上的選擇，如果根據服務歷史上的經驗要求我們改變操作系統的設置，也是沒有任何問題的；實際上，較早版本的 Linux 就開始將 TIME_WAIT 的等待時間 TCP_TIMEWAIT_LEN 設置成 60 秒，以便更快地複用 TCP 連接資源：</p><pre><code>#define TCP_TIMEWAIT_LEN (60*HZ) /* how long to wait to destroy TIME-WAIT				  * state, about 60 seconds	*/</code></pre><p>在 Linux 上，客戶端的可以使用端口號 32,768 ~ 61,000，總共 28,232 個端口號與遠程服務器建立連接，應用程序可以在將近 3 萬的端口號中任意選擇一個：</p><pre><code>$ sysctl net.ipv4.ip_local_port_rangenet.ipv4.ip_local_port_range = 32768 61000</code></pre><p>但是如果主機在過去一分鐘時間內創建的 TCP 連接數超過 28,232，那麼再創建新的 TCP 連接就會發生錯誤，也就是說如果我們不調整主機的配置，那麼每秒能夠建立的最大 TCP 連接數為 ~470[^6]。</p><h2 class=pgc-h-arrow-right>保證連接關閉</h2><p>從 RFC 793 對 TIME_WAIT 狀態的定義中，我們可以發現該狀態的另一個重要作用，等待足夠長的時間以確定遠程的 TCP 連接接收到了其發出的終止連接消息 FIN 對應的 ACK：</p><blockquote><p>TIME-WAIT - represents waiting for enough time to pass to be sure the remote TCP received the acknowledgment of its connection termination request.</p></blockquote><p>如果客戶端等待的時間不夠長，當服務端還沒有收到 ACK 消息時，客戶端就重新與服務端建立 TCP 連接就會造成以下問題 — 服務端因為沒有收到 ACK 消息，所以仍然認為當前連接是合法的，客戶端重新發送 SYN 消息請求握手時會收到服務端的 RST 消息，連接建立的過程就會被終止。</p><div class=pgc-img><img alt="為什麼 TCP 協議有 TIME_WAIT 狀態" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/52e4f2cc2b4348d3b970c14f9b25e531><p class=pgc-img-caption></p></div><p><strong>圖 4 - TIME-WAIT 較短導致的握手終止</strong></p><p>在默認情況下，如果客戶端等待足夠長的時間就會遇到以下兩種情況：</p><ol start=1><li>服務端正常收到了 ACK 消息並關閉當前 TCP 連接；</li><li>服務端沒有收到 ACK 消息，重新發送 FIN 關閉連接並等待新的 ACK 消息；</li></ol><p>只要客戶端等待 2 MSL 的時間，客戶端和服務端之間的連接就會正常關閉，新創建的 TCP 連接收到影響的概率也微乎其微，保證了數據傳輸的可靠性。</p><h2 class=pgc-h-arrow-right>總結</h2><p>在某些場景下，60 秒的等待銷燬時間確實是難以接受的，例如：高併發的壓力測試。當我們通過併發請求測試遠程服務的吞吐量和延遲時，本地就可能產生大量處於 TIME_WAIT 狀態的 TCP 連接，在 macOS 上可以使用如下所示的命令查看活躍的連接：</p><pre><code>$ netstat -tanActive Internet connections (including servers)Proto Recv-Q Send-Q  Local Address          Foreign Address        (state)tcp4       0      0  192.168.50.109.51284   47.95.49.174.443       TIME_WAITtcp4       0      0  192.168.50.109.51275   47.95.49.174.443       TIME_WAIT...tcp4       0      0  192.168.50.109.51273   203.107.32.116.443     TIME_WAITtcp4       0      0  192.168.50.109.51293   203.107.32.116.443     TIME_WAITtcp4       0      0  192.168.50.109.51297   203.107.32.116.443     TIME_WAIT...</code></pre><p>當我們在主機上通過幾千個併發來測試服務器的壓力時，這些用於壓力測試的連接會迅速消耗主機上的 TCP 連接資源，幾乎所有的 TCP 都會處於 TIME_WAIT 狀態等待銷燬。如果我們真遇到不得不處理<strong>單機上的</strong> TIME_WAIT 狀態的時候，那麼可以通過以下幾種方法處理：</p><ol start=1><li>使用 SO_LINGER 選項並設置暫存時間 l_linger 為 0，在這時如果我們關閉 TCP 連接，內核就會直接丟棄緩衝區中的全部數據並向服務端發送 RST 消息直接終止當前的連接[^7]；</li><li>使用 net.ipv4.tcp_tw_reuse 選項，通過 TCP 的時間戳選項允許內核重用處於 TIME_WAIT 狀態的 TCP 連接[^8]；</li><li>修改 net.ipv4.ip_local_port_range 選項中的可用端口範圍，增加可同時存在的 TCP 連接數上限；</li></ol><blockquote><p>需要注意的是，另一個常見的 TCP 配置項 net.ipv4.tcp_tw_recycle 已經在 Linux 4.12 中移除[^9]，所以我們不能再通過該配置解決 TIME_WAIT 設計帶來的問題。</p></blockquote><p>TCP 的 TIME_WAIT 狀態有著非常重要的作用，它是保證 TCP 協議可靠性不可缺失的設計，如果能通過加機器解決的話就儘量加機器，如果不能解決的話，我們就需要理解其背後的設計原理並儘可能避免修改默認的配置，就像 Linux 手冊中說的一樣，在修改這些配置時應該諮詢技術專家的建議；在這裡，我們再重新回顧一下 TCP 協議中 TIME_WAIT 狀態存在的原因，如果客戶端等待的時間不夠長，那麼使用相同端口號重新與遠程建立連接時會造成以下問題：</p><ul><li>因為數據段的網絡傳輸時間不確定，所以可能會收到上一次 TCP 連接中未被收到的數據段；</li><li>因為客戶端發出的 ACK 可能還沒有被服務端接收，服務端可能還處於 LAST_ACK 狀態，所以它會回覆 RST 消息終止新連接的建立；</li></ul><p>TIME_WAIT 狀態是 TCP 與不確定的網絡延遲鬥爭的結果，而<strong>不確定性是 TCP 協議在保證可靠這條路的最大阻礙</strong>。到最後，我們還是來看一些比較開放的相關問題，有興趣的讀者可以仔細思考一下下面的問題：</p><ul><li>net.ipv4.tcp_tw_reuse 配置如何通過時間戳保證重用 TCP 連接的相對安全？</li><li>net.ipv4.tcp_tw_recycle 配置為什麼被 Linux 從協議棧中移除？</li></ul><blockquote><p>如果對文章中的內容有疑問或者想要了解更多軟件工程上一些設計決策背後的原因，可以在博客下面留言，作者會及時回覆本文相關的疑問並選擇其中合適的主題作為後續的內容。</p></blockquote><h2 class=pgc-h-arrow-right>相關文章</h2><ul><li>為什麼 TCP 協議有粘包問題</li><li>為什麼 TCP 建立連接需要三次握手</li><li>為什麼 TCP/IP 協議會拆分數據</li></ul><h2 class=pgc-h-arrow-right>參考資料</h2><p>[^1]: "3.5. Closing a Connection · Transmission Control Protocol RFC793" https://tools.ietf.org/html/rfc793#section-3.5</p><p>[^2]: "Wikipedia: Maximum segment lifetime" https://en.wikipedia.org/wiki/Maximum_segment_lifetime</p><p>[^3]: "Can the time a socket spends in TIMED-WAIT state be reduced?" https://knowledgebase.progress.com/articles/Article/Can-the-time-a-socket-spends-in-TIMED-WAIT-state-be-reduced[^4]: "Knowing When to Keep Quiet · Transmission Control Protocol RFC793" https://tools.ietf.org/html/rfc793</p><p>[^5]: "Setting TIME_WAIT TCP" https://stackoverflow.com/questions/337115/setting-time-wait-tcp</p><p>[^6]: "Coping with the TCP TIME-WAIT state on busy Linux servers" https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#connection-table-slot</p><p>[^7]: "SO_LINGER Socket Option · Chapter 7. Socket Options" https://notes.shichao.io/unp/ch7/#so_linger-socket-option</p><p>[^8]: "net.ipv4.tcp_tw_reuse" https://vincent.bernat.ch/en/blog/2014-tcp-time-wait-state-linux#netipv4tcp_tw_reuse</p><p>[^9]: "tcp: remove tcp_tw_recycle" https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=4396e46187ca5070219b81773c4e65088dac50cc</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>什麼</a></li><li><a>TCP</a></li><li><a>協議</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/522b6842.html alt=TCP為什麼建立連接需要三次握手，而斷開連接則需要四次？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c07e68d15eb44728a2a07eed84b29ed5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/522b6842.html title=TCP為什麼建立連接需要三次握手，而斷開連接則需要四次？>TCP為什麼建立連接需要三次握手，而斷開連接則需要四次？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce824d7f.html alt=淺談TCP協議（建立與斷開連接） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4112ca2d63f04cddae0aadca168ea063 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce824d7f.html title=淺談TCP協議（建立與斷開連接）>淺談TCP協議（建立與斷開連接）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/049e5b0.html alt="TCP協議詳解 - TCP狀態轉移" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/11f74803a5c140f48e7d9c1a6aa0ae30 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/049e5b0.html title="TCP協議詳解 - TCP狀態轉移">TCP協議詳解 - TCP狀態轉移</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e566ae8.html alt="TCP 協議快被淘汰了，UDP 協議才是新世代的未來？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/b0c59e7c-978c-4b8e-b40c-52d64954c164 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e566ae8.html title="TCP 協議快被淘汰了，UDP 協議才是新世代的未來？">TCP 協議快被淘汰了，UDP 協議才是新世代的未來？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0981537.html alt="TCP 是什麼？面試時必須知道嗎？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RbiRsmjFrZY4rp style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0981537.html title="TCP 是什麼？面試時必須知道嗎？">TCP 是什麼？面試時必須知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ca6ff7.html alt=TCP協議總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153156590409218ee54748f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ca6ff7.html title=TCP協議總結>TCP協議總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1bd1e17.html alt=一文讀懂TCP/IP協議工作原理和工作流程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ea27784370b9441090baaf9c8cf57977 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1bd1e17.html title=一文讀懂TCP/IP協議工作原理和工作流程>一文讀懂TCP/IP協議工作原理和工作流程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f9bdeaf.html alt=什麼是TCP？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4b59ab99f0c54bce83bf1e7b96b8a3ea style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f9bdeaf.html title=什麼是TCP？>什麼是TCP？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e347b4c.html alt=網絡協議-TCP和UDP最完整的區別介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/4fa7c983-2109-4db9-84ec-5431e01c87ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e347b4c.html title=網絡協議-TCP和UDP最完整的區別介紹>網絡協議-TCP和UDP最完整的區別介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7308701.html alt=網絡協議之TCP和UDP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/50f23be4fe764f69ab2ed27288e88510 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7308701.html title=網絡協議之TCP和UDP>網絡協議之TCP和UDP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8ebfea.html alt="TCP 協議概覽" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/2f900e98cdba494993003fef43aba139 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8ebfea.html title="TCP 協議概覽">TCP 協議概覽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13955a3.html alt="TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8f291e6a61fa4b45a91b81f2589002c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13955a3.html title="TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）">TCP/IP 結構模型/Internet 協議（IP）/傳輸控制協議（TCP）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8da7b9.html alt=TCP/IP協議分為哪四層，具體作用是什麼？http與tcp區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/250b6d508b7a4694baa0371a1f53a17c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8da7b9.html title=TCP/IP協議分為哪四層，具體作用是什麼？http與tcp區別>TCP/IP協議分為哪四層，具體作用是什麼？http與tcp區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3364d34.html alt=TCP/IP協議是網絡協議中的核心協議，含三次握手，四次分手 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fc06324c0dfc4990bb88bbf41769b159 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3364d34.html title=TCP/IP協議是網絡協議中的核心協議，含三次握手，四次分手>TCP/IP協議是網絡協議中的核心協議，含三次握手，四次分手</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7302fb0.html alt=TCP/IP協議：傳輸層協議 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5bccccba9b1243d3afefcee4cc0d04ed style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7302fb0.html title=TCP/IP協議：傳輸層協議>TCP/IP協議：傳輸層協議</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>