<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>HashMap源碼分析 | 极客快訊</title><meta property="og:title" content="HashMap源碼分析 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3a5fae7e.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3a5fae7e.html><meta property="article:published_time" content="2020-11-14T21:07:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:42+08:00"><meta name=Keywords content><meta name=description content="HashMap源碼分析"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3a5fae7e.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>HashMap源碼分析</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>HashMap雖然常用，但是內部隱藏了很多實現細節，有太多值得推敲的東西，這裡儘量去收錄HashMap所有涉及的相關知識點。</p><h1 class=heading>數據結構-散列表</h1><p>先從數據結構說起，HashMap對照的是數據結構中的<strong>散列表</strong>結構。在數據結構中有一種結構叫<strong>字典</strong>。有的書上定義：“以集合為基礎的一些元素的集合，每個元素都有一個對應的key。支持元素的存在判斷，插入和刪除三種運算的的抽象數據類型就叫做字典“。散列表是字典的一個形式。散列表將元素的key使用一個<strong>hash函數</strong>映射到一個表上去（可以理解為一個地址連續的數組）來存儲元素。獲取數據時，只需要將key使用同樣的hash函數映射對應的位置獲取數據就行了。</p><pre><code>Address = Hash(key)複製代碼</code></pre><p>但是key的數量要比計算機地址空間大很多，我們使用的hash函數必須是收斂的（即將一堆數據映射到限定大小範圍內的地址空間中），因此肯定會存在衝突（2個不同的key使用hash method計算出同一個結果，有的地方也叫hash碰撞）。所以實現這樣的一個散列表引出2個問題：</p><ol start=1><li>對於給定的k-v對，找出一個合適的hash函數，能夠使得k計算結果分佈均勻，並且這個函數還不能太複雜。</li><li>hash衝突不可以避免，那在發生衝突時如何解決衝突。</li></ol><h2 class=heading>常用的散列函數</h2><ol start=1><li>除留餘數法</li><li>數字分析法</li><li>平方取中法</li><li>摺疊法</li></ol><p>由於細節內容實在太多啦，所以只把部分知識點截圖出來粗略的介紹，每個小節點裡面都有更細化的內容！</p><p>整理了一份Java核心知識點。覆蓋了JVM、鎖、併發、Java反射、Spring原理、微服務、Zookeeper、數據庫、數據結構等大量知識點。</p><p>如果需要獲取到這個【核心知識點整理】文檔的話幫忙轉發一下然後再關注我私信回覆“架構資料”得到獲取方式吧！</p><p>這裡面只列舉了一些簡單的常見的hash函數，具體使用什麼樣的hash函數取決於你的數據性質。我們應當針對我們的數據選用合適的hash函數。</p><h2 class=heading>常見的衝突解決策略</h2><h3 class=heading>閉散列</h3><p>發生衝突的關鍵碼存儲在表中另一個槽內。具體方法有：</p><ol start=1><li>線性探查法</li><li>二次探查法</li><li>雙散列法</li></ol><h3 class=heading>開散列</h3><p>發生衝突的關鍵碼存儲在散列表主表之外。具體方法有：</p><ol start=1><li>拉鍊法</li><li>桶式散列</li></ol><h1 class=heading>HashMap源碼</h1><p>HashMap在jdk集合中算一個很重要的知識點，面試也老愛問，在閱讀HashMap的源碼中，發現了很多亮點（算法的巧妙運用以及一些思想），但是不是總能久記不忘，這裡寫一篇記錄下所有的分析過程，以及那些亮點。本文主要就JDK1.8做的分析，1.7只是面試可能需要對比做的捎帶，本著對技術偏喜新厭舊的原則，就不分析1.7的了，對比的那些就是網上搜羅的，反正也沒多少，個人覺得看1.8的完全不要再管1.7了。</p><p><strong>HashMap的特性</strong></p><ul><li>key和value可以為null</li><li>線程不安全。如果需要滿足線程安全，可以用 Collections的synchronizedMap方法使HashMap具有線程安全的能力，或者使用ConcurrentHashMap。</li></ul><p><strong>數據結構概覽</strong></p><p>hashmap基本結構是基於散列表這一數據結構。採用的是數組+鏈表的方式存儲元素。jdk8之後，引入了紅黑樹來優化鏈表過長的情況。</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0><p class=pgc-img-caption></p></div><p><br></p><p>如圖所示，我們將1-16這個數組成為哈希表（hash table，不是jdk裡面的HashTable！），數組的每一塊地址空間稱為一個槽（bin）。</p><h2 class=heading>源碼分析（基於1.8）</h2><h3 class=heading>類圖</h3><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b3a3d430e1134f488ebc51f3c32a792b><p class=pgc-img-caption></p></div><p><br></p><h3 class=heading>構造</h3><p>這是使用hashmap的第一步，hashmap有4個構造函數。</p><pre><code>public HashMap(int initialCapacity, float loadFactor);public HashMap(int initialCapacity);public HashMap();public HashMap(Map&lt;? extends K, ? extends V&gt; m);複製代碼</code></pre><p>通過構造函數我們可以看到hashmap的幾個很重要的屬性（也可以稱為參數，更貼切）。這些參數對hashmap的性能有很大的影響。在分析構造函數之前我們有必要先了解這些參數：</p><pre><code>//初始容量 默認16static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16//負載因子 默認0.75static final float DEFAULT_LOAD_FACTOR = 0.75f;//閾值int threshold;複製代碼</code></pre><h4 class=heading>性能因子</h4><h5 class=heading>初始容量initial capacity</h5><ul><li>默認值為 <strong>16</strong>，並且源碼註釋特別指出：<strong><u>該數必須是2的次冪！</u></strong>（原因後面會分析到）</li></ul><p>初始容量就是hashmap中上圖那個哈希表的長度。如果該長度過長，則會浪費空間，如果該長度過短，則會造成大量的hash衝突，降低put和get的效率。</p><h5 class=heading>負載因子loadFactor</h5><ul><li><strong>默認值為0.75。</strong></li></ul><p>描述hashmap被填滿的程度的係數。該負載因子越大，在每次擴容前所能容納的鍵值對個數越多。而越多則可能會導致碰撞越多。但是太小，會導致頻繁的擴容內存操作，性能更差。所以需要一個折中的值。</p><p>負載因子的存在其實是為了讓hashmap的hash表可以更加均勻的存放存入的元素（最理想的結果是一個拉鍊也沒有，每個槽剛好就一個元素）。這樣查詢的時候可以提供最高的性能O(1)級別，時間複雜度是最低的。</p><p><strong><u>至於該值為什麼是0.75?</u></strong> 因為篇幅比較長，我在另一篇《hashmap負載因子為什麼是0.75》做了解答。<strong><u>【#1. 為什麼是0.75】</u></strong></p><h5 class=heading>閾值threshold</h5><ul><li>該值為 <strong>capacity * load factor</strong></li></ul><p>表示當hashmap存入多少元素的時候，就需要該對hash表進行擴容。</p><h4 class=heading>最簡單的構造函數</h4><pre><code>public HashMap() {    this.loadFactor = DEFAULT_LOAD_FACTOR; // DEFAULT_LOAD_FACTOR = 0.75f;}複製代碼</code></pre><p>只設置了一下負載因子，其他的都是使用的默認值。</p><h4 class=heading>帶調優參數的構造函數</h4><pre><code>public HashMap(int initialCapacity, float loadFactor) {    if (initialCapacity &lt; 0)        throw new IllegalArgumentException("Illegal initial capacity: " +                                           initialCapacity);    if (initialCapacity &gt; MAXIMUM_CAPACITY)        initialCapacity = MAXIMUM_CAPACITY;    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))        throw new IllegalArgumentException("Illegal load factor: " +                                           loadFactor);    //主要是這裡                                           this.loadFactor = loadFactor;    this.threshold = tableSizeFor(initialCapacity);}複製代碼</code></pre><p>主要校驗了一下傳來參數：初始容量，負載因子，並設置到hashmap的屬性上。並且在設置閾值的時候，並不是直接賦值的，而是使用通過tableSizeFor方法計算後的值。</p><p>注意一點：我們這裡並沒有設置初始容量直接到內部的屬性上，而是<strong>預先設置到了閾值上</strong>。這是為啥呢？因為我們構造函數的時候是不會申請內存的，申請內存的操作是在put的時候resize裡面進行的，但是我們hashmap中又沒有定義一個屬性來存儲我們設置的值，所以就使用暫存在threshold上。這麼寫估計是作者希望減少一個內置的屬性，畢竟如果去單獨定義這個屬性使用的頻率會比較低，而且在初始化完成後，我們也不需要再通過屬性來獲取，而是直接通過數組的length來獲取。<strong><u>【#2. 為什麼構造函數預先設置到閾值】</u></strong></p><h5 class=heading><strong>tableSizeFor解析</strong></h5><pre><code>static final int tableSizeFor(int cap) {    int n = cap - 1;    n |= n &gt;&gt;&gt; 1;    n |= n &gt;&gt;&gt; 2;    n |= n &gt;&gt;&gt; 4;    n |= n &gt;&gt;&gt; 8;    n |= n &gt;&gt;&gt; 16;    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;}複製代碼</code></pre><p>該函數的作用其實就是依據給定值，返回大於等於該給定值，並距離最近的2的次冪數。（比如給1返2，給3返4，給5返8等）。</p><p>上面具體的計算邏輯使用一個例子可以很清楚的看到這些位運算做了什麼：</p><p>編碼 操作 0100 0000 0000 0000 0000 0000 0000 1000 假設用戶設置了該cap 0**<u>10</u>**0 0000 0000 0000 0000 0000 0000 0111 -1操作，n = cap -1 0**<u>01</u>**0 0000 0000 0000 0000 0000 0000 0011 無符號右移一位，n >>> 1 0**<u>11</u>**0 0000 0000 0000 0000 0000 0000 0111 n |= n>>>1 0**<u>001 1</u>**000 0000 0000 0000 0000 0000 0001 n>>>2 0**<u>111 1</u>**000 0000 0000 0000 0000 0000 0111 n |= n >>> 2 0<strong><u>000 0111 1</u></strong>000 0000 0000 0000 0000 0000 n >>> 4 0**<u>111 1111 1</u>**000 0000 0000 0000 0000 0111 n |= n >>> 4 0**<u>000 0000 0111 1111 1</u>**000 0000 0000 0000 n >>> 8 0**<u>111 1111 1111 1111 1</u>**000 0000 0000 0111 n |= n >>> 8 0**<u>000 0000 0000 0000 0111 1111 1111 1111</u>** n >>> 16 0**<u>111 1111 1111 1111 1111 1111 1111 1111</u>** n |= n >>> 16 1000 0000 0000 0000 0000 0000 0000 0000 n+1</p><p>可以看出來，每一次右移都是為了讓第一個出現1的高位後面都變成1，從1開始變位2個，然後再以這2個的基礎變位4個，4個變8個，直到16則可以<strong>將一個4字節的int數字從它的第一個高位開始後面的位置全部的變成1</strong>。這時候我們再加1就得到了給定值離它最近的那個2的次冪數，其冪就是原來數的最高位的前一位或者自身（如果本書就是2的次冪的話）。</p><p>其中，第一步我們先做了減一的操作，這是為了讓本身就是2的次冪的數，返回的就是自己，比如給值8，如果不減一那麼結果就是16，這顯然不是我們想要的。<strong><u>【#3. 為什麼tableSizeFor的cap要先減一】</u></strong></p><p>最後return的時候，我們會判斷是否大於了hashmap內置的最大容量，如果大於了則就設置為最大容量。</p><p><strong><u>【#4. tableSizeFor做了什麼？】</u></strong></p><h4 class=heading>設置初始容量的構造函數</h4><pre><code>public HashMap(int initialCapacity) {    this(initialCapacity, DEFAULT_LOAD_FACTOR);}複製代碼</code></pre><p>其本質也是調用的是上面那個，只是負載因子使用的是默認的0.75。</p><p>這本應該是hashmap應該最常用的構造函數，阿里巴巴代碼規範裡面有相應的說明：</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c912904f29fd441faa0c0b34580820eb><p class=pgc-img-caption></p></div><p><br></p><p>至於為什麼是那個公式，後面我們也會介紹。這裡可以去看下一個有趣的小實驗。</p><h4 class=heading>map構造新map的構造</h4><pre><code>public HashMap(Map&lt;? extends K, ? extends V&gt; m) {    this.loadFactor = DEFAULT_LOAD_FACTOR;    putMapEntries(m, false);}複製代碼</code></pre><p>這個構造使用頻率相對較低。</p><h4 class=heading>小結</h4><p>通過上面的構造可以發現，HashMap對於內部的hash表示<strong>採用懶加載的</strong>，在沒有開始存入元素前，只是定義了一下內部的一些設置參數。</p><h3 class=heading>put流程</h3><p>put方法如下</p><pre><code>public V put(K key, V value) {    return putVal(hash(key), key, value, false, true);}複製代碼</code></pre><h4 class=heading>HashMap的hash()函數</h4><pre><code>static final int hash(Object key) {    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);}複製代碼</code></pre><p>通過該hash函數主要的目的是將hashcode進一步進行位干擾。hashcode對於Object來說是物理地址轉換來的一個整數，但是考慮到用戶重寫了hashcode方法，但不是很好的情況的話，那麼會嚴重增大key的碰撞率。</p><p>**具體做法：**將key的hashcode值的高16位和低16位進行亦或。</p><p><strong><u>【#5. 為什麼要進行位干擾？】</u></strong></p><p>這首先取決於我們hashmap的取模算法：(len - 1) & hash，即將hashcode值和hash表長度-1做與運算。那麼對於最後取模的結果影響因子永遠都是hashcode值的低位。我們希望我們使用的hashcode值能充分利用好高位和低位的特性，所以將高位16位和低位做了一個亦或。這樣新的hash值低16位也能保有了高位的信息了。</p><p>舉個例子：</p><p>原HashCode 111 0100 1000 0110 1000 1001 1000 0000 無符號右移16位 000 0000 0000 0000 0111 0100 1000 0110 異或運算 111 0100 1000 0110 1111 1101 0000 0110 len-1 000 0000 0000 0000 0000 0000 0000 1111 沒幹繞的運算 000 0000 0000 0000 0000 0000 0000 0000 干擾後的與運算 000 0000 0000 0000 0000 0000 0000 0110</p><p>干擾後高位的信息就影響到了最後的取模結果了。</p><p><strong>總的來說，干擾主要就是能充分利用好hashcode的整體信息，將高位的信息傳播到低位上去（因為hashmap取模算法的限制）。這樣做可以進一步降低碰撞的機率。</strong></p><h4 class=heading>再看看putVal</h4><pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 如果hash表為空，初始化下表    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    // hash值和hash表長度-1 做與運算 計算出來的位置，判斷上面有沒有元素    if ((p = tab[i = (n - 1) &amp; hash]) == null)        //沒有元素，直接插入節點        tab[i] = newNode(hash, key, value, null);    else {        //已經存在元素，則走判斷邏輯。// p 為該table位置上已經存在的元素        Node&lt;K,V&gt; e; K k;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            // 判斷得插入的元素key和當前位置上的元素相同。則讓e引用 原位置上的node            e = p;        else if (p instanceof TreeNode)            // 如果發現table處位置已經是TreeNode了，就按照樹的形式put            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else {            // 如果和hash表元素不一樣，則開始拉鍊以及後面可能的樹化            for (int binCount = 0; ; ++binCount) { // 一個死循環，遍歷當前位置上的拉鍊。當前判斷節點為e                if ((e = p.next) == null) {                    // 如果遍歷到鏈條的末尾了，就創建新node加進去                    p.next = newNode(hash, key, value, null);                    // 此時我們判斷下，遍歷了多少次了，如果大於等於8-1，那麼說明就要轉為紅黑樹                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        treeifyBin(tab, hash);                    //完成                    break;                }                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    // 如果在這中間發現了key重複的，就退出。                    break;                //處理下一個                p = e;            }        }        // 上面處理完了，此時的e指向的是該元素所應該在的位置。        if (e != null) { // existing mapping for key            V oldValue = e.value;            // 如果設置了替換老的值 或者 老的值為null            if (!onlyIfAbsent || oldValue == null)                //將新值替換                e.value = value;            afterNodeAccess(e);            // 返回舊的值            return oldValue;        }    }    //hashmap變化計數器+1    ++modCount;    //這時候檢驗hashmap是否超過閾值了，超過就擴容    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}</code></pre><p>大致流程如下</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/15aca683da73401485f2c823f5c45724><p class=pgc-img-caption></p></div><p><br></p><p>這裡面有下面幾個重點：</p><h5 class=heading><strong>hashmap取模算法</strong></h5><pre><code>p = tab[i = (n - 1) &amp; hash] //n為當前hash表的長度複製代碼</code></pre><p>n-1和hash做與運算可以保證，最後的結果等會散列到0-n的地址空間上。並且位運算的計算效率高。</p><h5 class=heading>resize()擴容&初始化方法</h5><pre><code>final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    //因為要進行初始化/擴容，所以這兩個是原始的初始容量和閾值    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) {        // 如果原始容量大於0 說明這次是擴容操作        if (oldCap &gt;= MAXIMUM_CAPACITY) {            //檢驗下是否達到了最大的容量，達到就不擴容了。            threshold = Integer.MAX_VALUE;            return oldTab;        }        // 檢驗下擴容2倍後是否達到最大容量，如果沒有達到就擴容2倍        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            //擴容2倍            newThr = oldThr &lt;&lt; 1; // double threshold    }    // 如果原來的閾值大於0 就將其設置為新的容量大小（這裡主要來源是構造函數裡面tableSizeFor設置的是該值）    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else {               // zero initial threshold signifies using defaults        //如果該值為0，那麼全部使用默認去構造他，因為他一定使用了無參的默認構造        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        // 如果上面走了一輪了 發現沒有設置新的閾值，那麼就是上面oldThr &gt; 0的情況了，這時候這裡設置下新的閾值。        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    threshold = newThr;    //申請新的內存空間    @SuppressWarnings({"rawtypes","unchecked"})    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) {        // 如果原來有表，那麼久開始遷移表裡面的數據        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    //該位置原來只有一個node，直接重新散列到新位置                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    //如果是樹，就使用樹的散列操作。分成2個樹，而且如果樹裡面node小於6的時候會再轉為鏈表。                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else { // preserve order                    //原來位置上是一個鏈表，就要將該鏈表拆成2份，一份還是在原來位置，一份會在其2倍便宜的高位。                    // l 代表低位                    Node&lt;K,V&gt; loHead = null, loTail = null;                    // h 代表高位                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    //遍歷鏈表                    do {                        next = e.next;                        //這個其實就是判斷該節點是在原位置還是在下一個便宜位置的。                        if ((e.hash &amp; oldCap) == 0) {                            //在原位置                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            //不在原位置，在其偏移位置                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    //拆分後的鏈表放到新的位置上去                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}複製代碼</code></pre><p>這也是一個很關鍵的函數。其主要目的是初始化內部的hash表，或者做2倍擴容。並且設置好初始化或者擴容後的初始容量和閾值的值。</p><p>這裡面有下面幾個關鍵的地方</p><h6 class=heading>設置 threshold和newCap</h6><p>在這裡面我們先計算出我們擴容後這些屬性的值之後才申請數組內存的。在計算過程中，要考慮到邊界問題（是否超過了最大的容量）。</p><p><br></p><h6 class=heading>鏈表的再散列</h6><p>當我們擴容後需要對原來的鏈表再散列。這裡主要說下原來是鏈表的情況（紅黑樹後期會單獨講，其他的很簡單看代碼就明白了）。</p><p>首先明白一點：擴容後，因為我們設計的原因，原來的拉鍊裡面的node會重新散列的位置也只有2處：原來的位置，原來位置2倍的偏移位置。</p><p>為什麼呢？舉個例子：</p><p>擴容前：</p><pre><code>1010 1001 複製代碼</code></pre><p>& 0000 1111 （16-1）</p><p>= 0000 1001</p><p>擴容後：</p><pre><code>101**&lt;font color='red'&gt;0&lt;/font&gt;** 1001 複製代碼</code></pre><p>& 000**1** 1111 （32-1）</p><p>= 0000 1001</p><p>我們可以看到擴容後，其實和數組長度掩碼做運算其實就是多了一個1位（紅色加粗）。這個1位和原來的hash值的&結果，決定了答案只有2種：0000 1001 / 0001 10001。這2個值差的就是一個2倍偏移位置（即原來的位置+擴容擴大的長度）</p><p>所以影響到位置變不變的是原來的hash值中的綠色加粗的那一位（如果這個位置是0，那麼位置就不變，如果那個位置是1，那麼就偏移）。</p><h6 class=heading>什麼時候進行樹化</h6><p>紅黑樹相關的內容我們這裡不多講，但是hashmap什麼時候轉為紅黑樹有需要注意的點。</p><p>先看下樹化的方法</p><pre><code>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {    int n, index; Node&lt;K,V&gt; e;    //1    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) //MIN_TREEIFY_CAPACITY =64        resize();    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {        ...    }}複製代碼</code></pre><p>從上面可以看出，鏈表轉為紅黑樹需要滿足2個條件</p><ul><li>鏈表長度超過8個（這是HashMap內部定義的一個邊界值，至於為什麼是8註釋裡面有介紹，即在0.75的負載因子下，根據泊松分佈公式計算出來一個bin中node超過8個的概率已經很低了（0.00000006），所以設置為8）</li><li>map中存儲的元素總數大於等於64個的時候，如果小於64會優先考慮先去擴容</li></ul><h6 class=heading>什麼時候樹轉為鏈表</h6><p>若桶中鏈表元素個數小於等於6時，樹結構還原成鏈表。</p><pre><code>final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {    ....    // 樹的拆分    if (loHead != null) {        if (lc &lt;= UNTREEIFY_THRESHOLD)            tab[index] = loHead.untreeify(map);        else {            tab[index] = loHead;            if (hiHead != null) // (else is already treeified)                loHead.treeify(tab);        }    }    if (hiHead != null) {        if (hc &lt;= UNTREEIFY_THRESHOLD)            tab[index + bit] = hiHead.untreeify(map);        else {            tab[index + bit] = hiHead;            if (loHead != null)                hiHead.treeify(tab);        }    }}複製代碼</code></pre><p>在樹的拆分中，會判斷拆分後的數是不是小到可以轉為鏈表了。如果可以轉為就轉成鏈表。</p><p>因為紅黑樹的平均查找長度是log(n)，長度為8的時候，平均查找長度為3，如果繼續使用鏈表，平均查找長度為8/2=4，這才有轉換為樹的必要。鏈表長度如果是小於等於6，6/2=3，雖然速度也很快的，但是轉化為樹結構和生成樹的時間並不會太短。</p><p>還有選擇6和8，中間有個差值7可以有效防止鏈表和樹頻繁轉換。假設一下，如果設計成鏈表個數超過8則鏈表轉換成樹結構，鏈表個數小於8則樹結構轉換成鏈表，如果一個HashMap不停的插入、刪除元素，鏈表個數在8左右徘徊，就會頻繁的發生樹轉鏈表、鏈表轉樹，效率會很低。參考</p><h3 class=heading>get流程</h3><p>hashmap有2種常用的get方法：</p><pre><code>public V get(Object key)  //依據key 獲取值public V getOrDefault(Object key, V defaultValue) //依據key獲取值，如果沒有key，返回用戶給定的默認值複製代碼</code></pre><p>get的流程就很簡單了，主要的邏輯都在這裡面：</p><pre><code>final Node&lt;K,V&gt; getNode(int hash, Object key) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) {        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) {            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do {                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            } while ((e = e.next) != null);        }    }    return null;}複製代碼</code></pre><p>主要就是計算key所在的位置，然後看所在位置上是鏈表還是樹。然後使用不同的策略去查詢出對應key的node。</p><h3 class=heading>remove流程</h3><p>remove的主要邏輯在</p><pre><code>final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,                           boolean matchValue, boolean movable) {    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;    // 判斷數組不為空，並且該key的hash值不為散列的位置上bin不為空    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (p = tab[index = (n - 1) &amp; hash]) != null) {        Node&lt;K,V&gt; node = null, e; K k; V v;        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            // 如果第一個位置就相同 就指向第一個            node = p;        else if ((e = p.next) != null) {            // 第一個位置不相同，但是後面有拉鍊            if (p instanceof TreeNode)                //如果是樹，去遍歷樹查看是否有該key                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);            else {                //如果是拉鍊，遍歷他                do {                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key ||                         (key != null &amp;&amp; key.equals(k)))) {                        node = e;                        break;                    }                    p = e;                } while ((e = e.next) != null);            }        }        //上面主要是查找，並node標記位置。下面是開始刪除        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||                             (value != null &amp;&amp; value.equals(v)))) {            if (node instanceof TreeNode)                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);            else if (node == p)                // 如果是第一個就相同就讓該位置指向p的下一個節點                tab[index] = node.next;            else                //p是node的前節點，p的next執行node的下一個，就刪除了node。                p.next = node.next;            ++modCount;            --size;            afterNodeRemoval(node);            return node;        }    }    return null;}複製代碼</code></pre><h2 class=heading>使用</h2><p>先列舉一些經常使用的方法：</p><pre><code>Map&lt;K,V&gt; map = new HashMap&lt;&gt;(16 /*initialCapacity*/); //申明，建議構造指定初始散列表大小map.put(k,v); //存放，k和v都可以為nullmap.get(k); //獲取map.getOrDefault(k,v2); //獲取，沒有值則返回v2map.containsKey(k); //判斷key是否存在map.keySet(); //獲取所有的key，同理還有values()獲取所有的值複製代碼</code></pre><p>這裡強調下，在初始化一個HashMap的時候，最好指定下初始化初始容量。具體的規則（Alibaba代碼規範）：</p><ul><li>如果不確定元素的個數，指定16，也就是內置默認值；</li><li>如果確定：initialCapacity=(需要存儲的元素個數 / 負載因子) + 1； 負載因子默認0.75</li></ul><h2 class=heading>併發存在問題</h2><p>hashmap是線程不安全的，所以put和get的時候本身就存在併發的常見問題，寫未讀，重複寫等，不過有一個特殊的線程不安全的行為是發生在hash表擴容的時候的。</p><p>在jdk1.7的時候，因為擴容後節點的rehash過程會導致，hash表的拉鍊出現一個死環（尾結點指向頭節點）。不過在jdk1.8中已經不存在了，這塊邏輯後面後期整理。(導致的原因主要是jdk1.7的rehash過程)</p><p>此時線程1和線程2此時都走到了rehash這一步。jdk的rehash代碼如下：</p><pre><code>void transfer(Entry[] newTable) {    Entry[] src = table;    int newCapacity = newTable.length;    for (int j = 0; j &lt; src.length; j++) {        Entry&lt;K,V&gt; e = src[j];        if (e != null) {            src[j] = null;          	//就是遍歷鏈表，判斷是否需要移位，如果需要移位就摘出該元素放到新的位置上去。            do {                Entry&lt;K,V&gt; next = e.next; // * 假設此時線程1被掛起                int i = indexFor(e.hash, newCapacity);                e.next = newTable[i];                newTable[i] = e;                e = next;            } while (e != null);        }    }}複製代碼</code></pre><p>假設當前HashMap結構如圖（圖片來自網絡）：</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/38cd6ac7881445318af7233c8a946700><p class=pgc-img-caption></p></div><p><br></p><p>此時老的表長度為2，在1位置上有3，7，5三個節點，現在擴容長度為4，需要將3，5，7節點進行偏移。</p><p>此時【線程1：e->3，next->7】【線程2將鏈表已經完全處理結束：將位置1處的3和7全部移動到了位置3處。】</p><p>這時候我們可以發現此時3和7的順序是顛倒的（線程2上e和next是線程1當前的e和next指向）。這時候線程1開始執行。</p><pre><code>e.next = newTable[i];newTable[i] = e;e = next;複製代碼</code></pre><p>這時候執行到最後一行next=e。此時【線程1：e->7】。繼續下一次循環。此時更新了next【線程1：e->7，next->e.next->3】如下圖：</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/2a74b545842c4dd794c11306c7ae5577><p class=pgc-img-caption></p></div><p><br></p><p>循環繼續：當前e指向了7。table[3]執行了3。這時候我們按照線程1的要求會應該將7摘下放入table[3]位置，然後e和next後移後如圖：</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/19e266e5c36148b9be8899d3763b21b7><p class=pgc-img-caption></p></div><p><br></p><p>之後繼續，線程1將3摘下來放入table[3]位置。</p><p><br></p><div class=pgc-img><img alt=HashMap源碼分析 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9ad4d293c72945e1bc63ee278c646c52><p class=pgc-img-caption></p></div><p><br></p><p>e的next=newTable[i]=7，newTable[i]=e=3，e=next=null遍歷到此結束。此時3頭插入7，7的next是3，3的next再指向了7構成了死環。</p><p>其實主要原因就是1.7中，rehash的時候遍歷列表需要移位的元素是採用<strong>頭部插入</strong>的方式進行插入的，當另外的一個線程將當前線程已經指定了但是還沒有進行偏移的節點給插入新位置了，那麼當前線程原來的e和next的順序是顛倒的，這在當前線程後面的操作中會導致死循環。</p><p><br></p><p>由於細節內容實在太多啦，所以只把部分知識點截圖出來粗略的介紹，每個小節點裡面都有更細化的內容！</p><p>整理了一份Java核心知識點。覆蓋了JVM、鎖、併發、Java反射、Spring原理、微服務、Zookeeper、數據庫、數據結構等大量知識點。</p><p>如果需要獲取到這個【核心知識點整理】文檔的話幫忙轉發一下然後再關注我私信回覆“架構資料”得到獲取方式吧！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>HashMap</a></li><li><a>源碼</a></li><li><a>分析</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html alt="Java HashMap源碼分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/4a86461eb8cc4ddb9ddf740c0aa49b00 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12f4776c.html title="Java HashMap源碼分析">Java HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html alt=Java——HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/8ad8e7317b3047f28717cf8c6fb816bb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d431eb66.html title=Java——HashMap源碼分析>Java——HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html alt=Java中HashMap源碼分析，絕對乾貨！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/593f0003cad0b7c22de4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f30725a.html title=Java中HashMap源碼分析，絕對乾貨！>Java中HashMap源碼分析，絕對乾貨！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html alt=Java容器系列-HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/10798fbb789b4217a4b19b4f307422b1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22f3351b.html title=Java容器系列-HashMap源碼分析>Java容器系列-HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b7037f1.html alt=轉子不對中振動——分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c4733b279b994389b8d95831dbfa98d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b7037f1.html title=轉子不對中振動——分析>轉子不對中振動——分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html alt=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d7714f65761648ee9b73a6bd5cca2fcb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cb59e3c.html title=瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap>瞭解HashMap底層設計思想，教你手寫一個迷你版的HashMap</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html alt=HashMap的底層實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0f9ffe95e10e4ff5804a8fd9cf591cfc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78a6fe2.html title=HashMap的底層實現>HashMap的底層實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html alt="為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6cbd09e4427c44c082e15ec40e24b6f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84501417.html title="為什麼 HashMap 的加載因子是0.75？">為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8e0605f0.html alt="找差距 勤分析 樹信心" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8e0605f0.html title="找差距 勤分析 樹信心">找差距 勤分析 樹信心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7ff5b82e.html alt=保護層分析（LOPA） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/41831aa6cc524ae1ba1f8e8e505ef874 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7ff5b82e.html title=保護層分析（LOPA）>保護層分析（LOPA）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html alt="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ab1d67934084ab6bd585f4c84094c76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html title="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究">thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>