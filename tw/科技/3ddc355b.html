<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java 五大框架之間的對比 | 极客快訊</title><meta property="og:title" content="Java 五大框架之間的對比 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/6694ef89-df10-464c-9400-bfcfe4bf4905"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3ddc355b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3ddc355b.html><meta property="article:published_time" content="2020-10-29T21:12:37+08:00"><meta property="article:modified_time" content="2020-10-29T21:12:37+08:00"><meta name=Keywords content><meta name=description content="Java 五大框架之間的對比"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3ddc355b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java 五大框架之間的對比</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt="Java 五大框架之間的對比" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/6694ef89-df10-464c-9400-bfcfe4bf4905><p class=pgc-img-caption></p></div><h1 class=ql-align-justify><strong>Spring 及其優點</strong></h1><p class=ql-align-justify>大部分項目都少不了spring的身影，為什麼大家對他如此青睞，而且對他的追捧絲毫沒有減退之勢呢</p><p class=ql-align-justify><strong>Spring是什麼：</strong></p><p class=ql-align-justify>Spring是一個輕量級的DI和AOP容器框架。</p><p class=ql-align-justify>說它輕量級有一大部分原因是相對與EJB的（雖然本人從沒有接觸過EJB的應用），重要的是，Spring是非侵入式的，基於spring開發的應用一般不依賴於spring的類。</p><p class=ql-align-justify><strong>DI</strong>：稱作依賴注入(Dependency Injection),和控制反轉一個概念，具體的講，當一個角色需要另外一個角色協助的時候，在傳統的程序設計中，通常有調用者來創建被調用者的實例。但是在spring中創建被調用者將不再有調用者完成，因此叫控制反轉。創建被調用對象有Spring來完成，在容器實例化對象的時候主動的將被調用者（或者說它的依賴對象）注入給調用對象，因此又叫依賴注入。</p><p class=ql-align-justify><strong>AOP</strong>：Spring對面向切面編程提供了強有力的支持，通過它讓我們將業務邏輯從應用服務（如事務管理）中分離出來，實現了高內聚開發，應用對象只關注業務邏輯，不再負責其它系統問題（如日誌、事務等）。Spring支持用戶自定義切面。</p><p class=ql-align-justify>面向切面編程是面向對象編程的有力補充。面向對象編程將程序分成各個層次的對象，面向切面的程序將運行過程分解成各個切面。AOP是從運行程序的角度去考慮程序的結構，提取業務處理過程的切面，OOP是靜態的抽象，AOP是動態的抽象，是對應用執行過程的步驟進行抽象，從而獲得步驟之間的邏輯劃分。</p><p class=ql-align-justify><strong>容器</strong>：Spring是個容器，因為它包含並且管理應用對象的生命週期和配置。如對象的創建、銷燬、回調等。</p><p class=ql-align-justify><strong>框架</strong>：Spring作為一個框架，提供了一些基礎功能，（如事務管理，持久層集成等），使開發人員更專注於開發應用邏輯。</p><p class=ql-align-justify><strong>看完了Spring是什麼，再來看看Spring有哪些優點</strong></p><p class=ql-align-justify>1.使用Spring的IOC容器，將對象之間的依賴關係交給Spring，降低組件之間的耦合性，讓我們更專注於應用邏輯</p><p class=ql-align-justify>2.可以提供眾多服務，事務管理，WS等。</p><p class=ql-align-justify>3.AOP的很好支持，方便麵向切面編程。</p><p class=ql-align-justify>4.對主流的框架提供了很好的集成支持，如hibernate,Struts2,JPA等</p><p class=ql-align-justify>5.Spring DI機制降低了業務對象替換的複雜性。</p><p class=ql-align-justify>6.Spring屬於低侵入，代碼汙染極低。</p><p class=ql-align-justify>7.Spring的高度可開放性，並不強制依賴於Spring，開發者可以自由選擇Spring部分或全部</p><div class=pgc-img><img alt="Java 五大框架之間的對比" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8bcb950b973c424a9aef25e9beefd754><p class=pgc-img-caption></p></div><h1 class=ql-align-justify>Struts2的優點</h1><p class=ql-align-justify>Struts2 是一個相當強大的Java Web開源框架，是一個基於POJO的Action的MVC Web框架。它基於當年的Webwork和XWork框架，繼承其優點，同時做了相當的改進。Struts2現在在Java Web開發界的地位可以說是大紅大紫，從開發人員的角度來分析，Struts2之所以能夠如此的深入開發人員之心，與其優良的設計是分不開的。</p><p class=ql-align-justify>1、Struts2基於MVC架構,框架結構清晰，開發流程一目瞭然，開發人員可以很好的掌控開發的過程。</p><p class=ql-align-justify>我在項目開發過程中，一個具體的功能的開發流程是：拿到一個具體的功能需求文檔和設計好的前臺界面（在開發中我不負責設計頁面），分析需要從前臺傳遞哪些參數，確定參數的變量名稱，在Action中設置相應的變量，這些參數在前臺如何顯示，並將頁面上的一些控件適當使用Struts2提供的服務器端控件來代替，編寫Action對應的方法來完成業務邏輯，最後，做一些與配置文件相關的設置。當然實際的開發比這個過程要複雜，涉及到數據庫，驗證，異常等處理。但是使用Struts2進行開發，你的關注點絕大部分是在如何實現業務邏輯上，開發過程十分清晰明瞭。</p><p class=ql-align-justify>2、使用OGNL進行參數傳遞。</p><p class=ql-align-justify>OGNL提供了在Struts2裡訪問各種作用域中的數據的簡單方式，你可以方便的獲取Request，Attribute，Application，Session，Parameters中的數據。大大簡化了開發人員在獲取這些數據時的代碼量。</p><p class=ql-align-justify>3、強大的攔截器</p><p class=ql-align-justify>Struts2 的攔截器是一個Action級別的AOP，Struts2中的許多特性都是通過攔截器來實現的，例如異常處理，文件上傳，驗證等。攔截器是可配置與重用的，可以將一些通用的功能如：登錄驗證，權限驗證等置於攔截器中以完成一些Java Web項目中比較通用的功能。在我實現的的一Web項目中，就是使用Struts2的攔截器來完成了系統中的權限驗證功能。</p><p class=ql-align-justify>4、易於測試</p><p class=ql-align-justify>Struts2的Action都是簡單的POJO，這樣可以方便的對Struts2的Action編寫測試用例，大大方便了Java Web項目的測試。</p><p class=ql-align-justify>5、易於擴展的插件機制</p><p class=ql-align-justify>在Struts2添加擴展是一件愉快而輕鬆的事情，只需要將所需要的Jar包放到WEB-INF/lib文件夾中，在struts.xml中作一些簡單的設置就可以實現擴展。常用的Struts2的擴展可以通過這個鏈接找到：</p><p class=ql-align-justify>http://cwiki.apache.org/S2PLUGINS/home.html</p><p class=ql-align-justify>6、模塊化</p><p class=ql-align-justify>Struts2已經把模塊化作為了體系架構中的基本思想，可以通過三種方法來將應用程序模塊化：</p><p class=ql-align-justify>將配置信息拆分成多個文件</p><p class=ql-align-justify>把自包含的應用模塊創建為插件</p><p class=ql-align-justify>創建新的框架特性，即將與特定應用無關的新功能組織成插件，以添加到多個應用中去。</p><p class=ql-align-justify>7、全局結果與聲明式異常</p><p class=ql-align-justify>為應用程序添加全局的Result，和在配置文件中對異常進行處理，這樣當處理過程中出現指定異常時，可以跳轉到特定頁面，這一功能十分實用。</p><div class=pgc-img><img alt="Java 五大框架之間的對比" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/620ad648fad14e889021aab336d793c9><p class=pgc-img-caption></p></div><h1 class=ql-align-justify>Spring MVC和Struts2的比較的優點</h1><p class=ql-align-justify>我們用struts2時採用的傳統的配置文件的方式，並沒有使用傳說中的0配置。spring3 mvc可以認為已經100%零配置了（除了配置spring mvc-servlet.xml外）。</p><p class=ql-align-justify><strong>Spring MVC和Struts2的區別：</strong></p><p class=ql-align-justify><strong>機制</strong>：spring mvc的入口是servlet，而struts2是filter（這裡要指出，filter和servlet是不同的。以前認為filter是 servlet的一種特殊），這樣就導致了二者的機制不同，這裡就牽涉到servlet和filter的區別了。</p><p class=ql-align-justify><strong>性能</strong>：spring會稍微比struts快。spring mvc是基於方法的設計，而sturts是基於類，每次發一次請求都會實例一個action，每個action都會被注入屬性，而spring基於方法，粒度更細，但要小心把握像在servlet控制數據一樣。spring3 mvc是方法級別的攔截，攔截到方法後根據參數上的註解，把request數據注入進去，在spring3 mvc中，一個方法對應一個request上下文。而struts2框架是類級別的攔截，每次來了請求就創建一個Action，然後調用setter getter方法把request中的數據注入；struts2實際上是通過setter getter方法與request打交道的；struts2中，一個Action對象對應一個request上下文。</p><p class=ql-align-justify><strong>參數傳遞</strong>：struts是在接受參數的時候，可以用屬性來接受參數，這就說明參數是讓多個方法共享的。</p><p class=ql-align-justify><strong>設計思想上</strong>：struts更加符合oop的編程思想， spring就比較謹慎，在servlet上擴展。</p><p class=ql-align-justify><strong>intercepter的實現機制</strong>：struts有以自己的interceptor機制，spring mvc用的是獨立的AOP方式。這樣導致struts的配置文件量還是比spring mvc大，雖然struts的配置能繼承，所以我覺得論使用上來講，spring mvc使用更加簡潔，開發效率Spring MVC確實比struts2高。spring mvc是方法級別的攔截，一個方法對應一個request上下文，而方法同時又跟一個url對應，所以說從架構本身上spring3 mvc就容易實現restful url。struts2是類級別的攔截，一個類對應一個request上下文；實現restful url要費勁，因為struts2 action的一個方法可以對應一個url；而其類屬性卻被所有方法共享，這也就無法用註解或其他方式標識其所屬方法了。spring3 mvc的方法之間基本上獨立的，獨享request response數據，請求數據通過參數獲取，處理結果通過ModelMap交回給框架方法之間不共享變量，而struts2搞的就比較亂，雖然方法之間也是獨立的，但其所有Action變量是共享的，這不會影響程序運行，卻給我們編碼，讀程序時帶來麻煩。</p><h1 class=ql-align-justify>struts1與struts2本質區別</h1><p class=ql-align-justify><strong>1 在Action實現類方面的對比</strong>：Struts 1要求Action類繼續一個抽象基類；Struts 1的一個具體問題是使用抽象類編程而不是接口。Struts 2 Action類可以實現一個Action接口，也可以實現其他接口，使可選和定製的服務成為可能。Struts 2提供一個ActionSupport基類去實現常用的接口。即使Action接口不是必須實現的，只有一個包含execute方法的POJO類都可以用 作Struts 2的Action。</p><p class=ql-align-justify><strong>2 線程模式方面的對比</strong>：Struts 1 Action是單例模式並且必須是線程安全的，因為僅有Action的一個實例來處理所有的請求。單例策略限制了Struts 1 Action能做的事，並且要在開發時非凡小心。Action資源必須是線程安全的或同步的；Struts 2 Action對象為每一個請求產生一個實例，因此沒有線程安全問題。</p><p class=ql-align-justify><strong>3 Servlet依靠方面的對比</strong>：Struts 1 Action依靠於Servlet API，因為Struts 1 Action的execute方法中有HttpServletRequest和HttpServletResponse方法。Struts 2 Action不再依靠於Serzvlet API，從而答應Action脫離Web容器運行，從而降低了測試Action的難度。 當然，假如Action需要直接訪問HttpServletRequest和HttpServletResponse參數，Struts 2 Action仍然可以訪問它們。但是，大部分時候，Action都無需直接訪問HttpServetRequest和 HttpServletResponse，從而給開發者更多靈活的選擇。</p><p class=ql-align-justify><strong>4 可測性方面的對比</strong>：測試Struts 1 Action的一個主要問題是execute方法依靠於Servlet API，這使得Action的測試要依靠於Web容器。為了脫離Web容器測試Struts 1的Action，必須藉助於第三方擴展：Struts TestCase，該擴展下包含了系列的Mock對象（模擬了HttpServetRequest和HttpServletResponse對象），從而 可以脫離Web容器測試Struts 1的Action類。Struts 2 Action可以通過初始化、設置屬性、調用方法來測試。</p><p class=ql-align-justify><strong>5 封裝請求參數的對比</strong>：Struts 1使用ActionForm對象封裝用戶的請求參數，所有的ActionForm必須繼續一個基類：ActionForm。普通的JavaBean不能用 作ActionForm，因此，開發者必須創建大量的ActionForm類封裝用戶請求參數。雖然Struts 1提供了動態ActionForm來簡化ActionForm的開發，但依然需要在配置文件中定義ActionForm；Struts 2直接使用Action屬性來封裝用戶請求屬性，避免了開發者需要大量開發ActionForm類的煩瑣，實際上，這些屬性還可以是包含子屬性的Rich 對象類型。假如開發者依然懷念Struts 1 ActionForm的模式，Struts 2提供了ModelDriven模式，可以讓開發者使用單獨的Model對象來封裝用戶請求參數，但該Model對象無需繼續任何Struts 2基類，是一個POJO，從而降低了代碼汙染。</p><p class=ql-align-justify><strong>6 表達式語言方面的對比</strong>：Struts 1整合了JSTL，因此可以使用JSTL表達式語言。這種表達式語言有基本對象圖遍歷，但在對集合和索引屬性的支持上則功能不強；Struts 2可以使用JSTL，但它整合了一種更強大和靈活的表達式語言：OGNL（Object Graph Notation Language），因此，Struts 2下的表達式語言功能更加強大。</p><p class=ql-align-justify><strong>7 綁定值到視圖的對比</strong>：Struts 1使用標準JSP機制把對象綁定到視圖頁面；Struts 2使用“ValueStack”技術，使標籤庫能夠訪問值，而不需要把對象和視圖頁面綁定在一起。</p><p class=ql-align-justify><strong>8 類型轉換的對比</strong>：Struts 1 ActionForm 屬性通常都是String類型。Struts 1使用Commons-Beanutils進行類型轉換，每個類一個轉換器，轉換器是不可配置的；Struts 2使用OGNL進行類型轉換，支持基本數據類型和常用對象之間的轉換。</p><p class=ql-align-justify><strong>9 數據校驗的對比</strong>：Struts 1支持在ActionForm重寫validate方法中手動校驗，或者通過整合Commons alidator框架來完成數據校驗。Struts 2支持通過重寫validate方法進行校驗，也支持整合XWork校驗框架進行校驗。</p><p class=ql-align-justify><strong>10 Action執行控制的對比</strong>：Struts 1支持每一個模塊對應一個請求處理（即生命週期的概念），但是模塊中的所有Action必須共享相同的生命週期。Struts 2支持通過攔截器堆棧（Interceptor Stacks）為每一個Action創建不同的生命週期。開發者可以根據需要創建相應堆棧，從而和不同的Action一起使用。</p><h1 class=ql-align-justify>Hibernate優點</h1><p class=ql-align-justify><strong>(1) 對象/關係數據庫映射(ORM)</strong></p><p class=ql-align-justify>它使用時只需要操縱對象，使開發更對象化，拋棄了數據庫中心的思想，完全的面向對象思想</p><p class=ql-align-justify><strong>(2) 透明持久化(persistent)</strong></p><p class=ql-align-justify>帶有持久化狀態的、具有業務功能的單線程對象，此對象生存期很短。這些對象可能是普通的JavaBeans/POJO，這個對象沒有實現第三方框架 或者接口，唯一特殊的是他們正與（僅僅一個）Session相關聯。一旦這個Session被關閉，這些對象就會脫離持久化狀態，這樣就可被應用程序的任 何層自由使用。（例如，用作跟表示層打交道的數據傳輸對象。）</p><p class=ql-align-justify><strong>(3) 事務Transaction(org.hibernate.Transaction)</strong></p><p class=ql-align-justify>應用程序用來指定原子操作單元範圍的對象，它是單線程的，生命週期很短。它通過抽象將應用從底層具體的JDBC、JTA以及CORBA事務隔離 開。某些情況下，一個Session之內可能包含多個Transaction對象。儘管是否使用該對象是可選的，但無論是使用底層的API還是使用 Transaction對象，事務邊界的開啟與關閉是必不可少的。</p><p class=ql-align-justify><strong>(4) 它沒有侵入性，即所謂的輕量級框架</strong></p><p class=ql-align-justify><strong>(5) 移植性會很好</strong></p><p class=ql-align-justify><strong>(6) 緩存機制，提供一級緩存和二級緩存</strong></p><p class=ql-align-justify><strong>(7) 簡潔的HQL編程</strong></p><h1 class=ql-align-justify>Hibernate缺點</h1><p class=ql-align-justify>(1) Hibernate在批量數據處理時有弱勢</p><p class=ql-align-justify>(2) 針對單一對象簡單的增刪查改，適合於Hibernate,而對於批量的修改，刪除，不適合用Hibernate,這也是OR框架的弱點；要使用數據庫的特定優化機制的時候，不適合用Hibernate</p><p class=ql-align-justify>Hibernate和iBATIS 優缺點比較</p><p class=ql-align-justify>（注意:iBATIS 是MyBATIS的前生，也就是1.0版本）</p><p class=ql-align-justify><strong>Hibernate的特點：</strong></p><p class=ql-align-justify>Hibernate功能強大，數據庫無關性好，O/R映射能力強， Hibernate對數據庫結構提供了較為完整的封裝，Hibernate的O/R Mapping實現了POJO 和數據庫表之間的映射，以及SQL 的自動生成和執行。程序員往往只需定義好了POJO 到數據庫表的映射關係，即可通過Hibernate 提供的方法完成持久層操作。程序員甚至不需要對SQL 的熟練掌握， Hibernate/OJB 會根據制定的存儲邏輯，自動生成對應的SQL 並調用JDBC 接口加以執行。Hibernate的缺點就是學習門檻不低，要精通門檻更高，而且怎麼設計O/R映射，在性能和對象模型之間如何權衡取得平衡，以及怎樣用 好Hibernate方面需要你的經驗和能力都很強才行，但是Hibernate現在已經是主流O/R Mapping框架，從文檔的豐富性，產品的完善性，版本的開發速度都要強於iBATIS。</p><p class=ql-align-justify><strong>iBATIS的特點</strong>：</p><p class=ql-align-justify>iBATIS入門簡單， 即學即用，提供了數據庫查詢的自動對象綁定功能，而且延續了很好的SQL使用經驗，對於沒有那麼高的對象模型要求的項目來說，相當完美。iBATIS的缺 點就是框架還是比較簡陋，功能尚有缺失，雖然簡化了數據綁定代碼，但是整個底層數據庫查詢實際還是要自己寫的，工作量也比較大，而且不太容易適應快速數據 庫修改。當系統屬於二次開發,無法對數據庫結構做到控制和修改,那iBATIS的靈活性將比Hibernate更適合。系統數據處理量巨大，性能要求極為 苛刻，這往往意味著我們必須通過經過高度優化的SQL語句（或存儲過程）才能達到系統性能設計指標。在這種情況下iBATIS會有更好的可控性和表現。</p><p class=ql-align-justify>對於實際的開發進行的比較：</p><p class=ql-align-justify>1． iBATIS需要手寫sql語句，也可以生成一部分，Hibernate則基本上可以自動生成，偶爾會寫一些Hql。同樣的需求,iBATIS的工作量比 Hibernate要大很多。類似的，如果涉及到數據庫字段的修改，Hibernate修改的地方很少，而iBATIS要把那些sql mapping的地方一一修改。</p><p class=ql-align-justify>2. iBatis 可以進行細粒度的優化</p><p class=ql-align-justify>比 如說我有一個表，這個表有幾個或者幾十個字段，我需要更新其中的一個字段，iBatis 很簡單，執行一個sql UPDATE TABLE_A SET column_1=#column_1# WHERE id=#id# 但是用 Hibernate 的話就比較麻煩了,缺省的情況下 hibernate 會更新所有字段。 當然我記得 hibernate 有一個選項可以控制只保存修改過的字段，但是我不太確定這個功能的負面效果。</p><p class=ql-align-justify>例 如：我需要列出一個表的部分內容，用 iBatis 的時候，這裡面的好處是可以少從數據庫讀很多數據，節省流量SELECT ID, NAME FROM TABLE_WITH_A_LOT_OF_COLUMN WHERE …一般情況下Hibernate 會把所有的字段都選出來。比 如說有一個上面表有8個字段，其中有一兩個比較大的字段，varchar(255)/text。上面的場景中我為什麼要把他們也選出來呢？用 hibernate 的話，你又不能把這兩個不需要的字段設置為lazy load，因為還有很多地方需要一次把整個 domain object 加載出來。這個時候就能顯現出ibatis 的好處了。如果我需要更新一條記錄（一個對象），如果使用 hibernate，需要現把對象 select 出來，然後再做 update。這對數據庫來說就是兩條sql。而iBatis只需要一條update的sql就可以了。減少一次與數據庫的交互，對於性能的提升是非常重 要。</p><p class=ql-align-justify>3. 開發方面：</p><p class=ql-align-justify>開發效率上，我覺得兩者應該差不多。可維護性方面，我 覺得 iBatis 更好一些。因為 iBatis 的 sql 都保存到單獨的文件中。而 Hibernate 在有些情況下可能會在 java 代碼中保sql/hql。相對Hibernate“O/R”而言，iBATIS 是一種“Sql Mapping”的ORM實現。（iBatis 是將sql寫在配置文件中的，而hibernate是自己生成的） 而iBATIS 的著力點，則在於POJO 與SQL之間的映射關係。也就是說，iBATIS並不會為程序員在運行期自動生成SQL 執行。具體的SQL 需要程序員編寫，然後通過映射配置文件，將SQL所需的參數，以及返回的結果字段映射到指定POJO。使用iBATIS 提供的ORM機制，對業務邏輯實現人員而言，面對的是純粹的Java對象，這一層與通過Hibernate 實現ORM 而言基本一致，而對於具體的數據操作，Hibernate會自動生成SQL 語句，而iBATIS 則要求開發者編寫具體的SQL 語句。相對Hibernate而言，iBATIS 以SQL開發的工作量和數據庫移植性上的讓步，為系統設計提供了更大的自由空間。</p><p class=ql-align-justify>4. 運行效率</p><p class=ql-align-justify>在不考慮 cache 的情況下，iBatis 應該會比hibernate 快一些或者很多。</p><h1 class=ql-align-justify>Spring 框架的優缺點</h1><p class=ql-align-justify>Spring的優勢不言而喻：</p><p class=ql-align-justify>1. 提供了一種管理對象的方法，可以把中間層對象有效地組織起來。一個完美的框架“黏合劑”。</p><p class=ql-align-justify>2. 採用了分層結構，可以增量引入到項目中。</p><p class=ql-align-justify>3. 有利於面向接口編程習慣的養成。</p><p class=ql-align-justify>4. 目的之一是為了寫出易於測試的代碼。</p><p class=ql-align-justify>5. 非侵入性，應用程序對Spring API的依賴可以減至最小限度。</p><p class=ql-align-justify>6. 一致的數據訪問介面。</p><p class=ql-align-justify>7. 一個輕量級的架構解決方案</p><p class=ql-align-justify><strong>缺點也顯而易見</strong></p><p class=ql-align-justify>1. 中斷了應用程序的邏輯，使代碼變得不完整，不直觀。此時單從Source無法完全把握應用的所有行為。</p><p class=ql-align-justify>2. 將原本應該代碼化的邏輯配置化，增加了出錯的機會以及額外的負擔。</p><p class=ql-align-justify>3. 時光倒退，失去了IDE的支持。在目前IDE功能日益強大的時代，以往代碼重構等讓人頭痛的舉動越來越容易。而且IDE還提供了諸多強大的輔助功能，使得 編程的門檻降低很多。通常來說，維護代碼要比維護配置文件，或者配置文件+代碼的混合體要容易的多。</p><p class=ql-align-justify>4. 調試階段不直觀，後期的bug對應階段，不容易判斷問題所在。</p><h1 class=ql-align-justify>經典架構S（Struts）SH的優缺點</h1><p class=ql-align-justify>Struts、Spring、Hibernate能流行這麼多年經久不衰，自然有它的道理。J2EE最先出現的時候，我們一般是採用 JSP+Servlet+JavaBean+EJB的架構，尤其是1998年～2000年這段時間，互聯網的泡沫從興起到破裂，其波瀾壯闊程度，絲毫不亞 於2008年開始的這次經濟危機，在那個年代，是否掌握EJB開發技術將直接決定你的薪水能否翻一倍或者幾倍。不過，Spring的作者Rod Johnson在2002年根據多年經驗撰寫了《Expert o-ne-on-One J2EE Design and Development》，其後又發表了著名的《Expert o-ne-on-one J2EE Development without EJB》一書，則徹底地改變了傳統的J2EE一統天下的開發架構，基於Struts+Hibernate+Spring的J2EE架構也逐漸得到人們的認 可，甚至在大型的項目架構中也逐漸開始應用。下面我們分別說說Spring、Struts和Hibernate的優缺點。</p><div class=pgc-img><img alt="Java 五大框架之間的對比" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/31f04e6e-4cc8-48bf-bc93-d92e2305f7ab><p class=pgc-img-caption></p></div><p class=ql-align-justify>Spring 是一個開源框架，是為了解決企業應用程序開發複雜性而創建的。框架的主要優勢之一就是其分層架構，使得每個層之間和類與類之間的關係，由原來的強綁定與強 耦合轉變為不綁定和鬆耦合，直接面向接口編程，把設計與實現相分離的原則發揮到極致，對於單元測試也產生了很深遠的影響。在Spring出現之前，如果某 個模塊沒有完成，做單獨模塊的單元測試還是很困難的。Spring同時也是 J2EE 應用程序開發的集成框架，因為J2EE是講究分層理念的，Spring使得J2EE每個層之間的模塊職能更加清晰。</p><p class=ql-align-justify>不過，對於大型項目的開發，Spring使得原來難以維護的類與類之間的強耦合關係，轉變為更加難以維護的XML文件配置，這個工作量也是非常巨大 的，而且更容易出錯。而且，隨著每個應用 模塊的升級，這些模塊之間的版本，也不會是同步更新的，對於同一個公共組件，有的模塊用的可能是1.0版本，而另 外一個功能模塊用的可能是2.0版本，可怕的是1.0版本和2.0版本之間，可能還不兼容，Spring對於這些需求，就無能為力了。所以，有人說 Spring不適合大型項目開發，也是有一定道理的。最近Spring也加入了OSGI標準的實現，也是為了解決不同版本之間同時存在的這些問題。不過， 隨著Spring加入的功能越來越多，Spring也就失去了輕量開源框架的特點，變得越來越笨重。</p><p class=ql-align-justify>雖然Spring現在也支持了所謂的免配置，可以通過@Autowired標籤自行綁定，還可以通過 設置自動綁定加載所有的Hibernate對象，但是如果這些上百個或者數十個中的任何一個Entity對象加載失敗，則整個Spring服務就啟動不起 來了，這與難於部署的EJB有啥區別呢？而且，令人可笑的是，由於使用了@Autowired標籤，相當一部分開發人員不再面向接口編程了，對於 Class A的實例，美其名曰由Spring自行綁定，接口也好，實際實現類也好，就在Spring配置一下就可以了。而Spring最核心的就是面向接口編程和 IOC，沒有了面向接口編程，用一個 A a=new A() 來實例化一個Class，有什麼不可以呢？少寫了一行代碼，引入了一個重量級的Spring，究竟為啥使用Spring呢？</p><p class=ql-align-justify>對於Hibernate的流行，則是由於開發人員和客戶，對於Entity EJB（實體EJB）臃腫的身材及部署的困難，是在極度失望情緒下造成的。既然是輕量級解決方案，那麼分佈式就不是可選項，沒有分佈式，那麼EJB就無用 武之地了。話又說回來了，Rod Johnson前些年就因為強調絕大部分企業應用是不需要分佈式的，從而推出了自己輕量級的Spring解決方案。但是最近一年，隨著雲計算架構的興起， 架構是否支持分佈式，又是必選項了。技術架構的選型，就跟法國巴黎流行時裝一樣，今年流行短袖，明年流行下襬，真是典型的十年河東，十年河西。所以，像 SOA、雲計算、SaaS、物聯網這些大名詞，不僅會給客戶帶來很大的困惑，同樣也會給程序員、系統分析師、系統架構師、技術總監帶來困惑。從肯定到否 定，再到自我否定，真是符合大自然螺旋式上升的發展規律。</p><p class=ql-align-justify>而對於Struts，它一經推出，幾乎打敗了當時的所有競爭對手。Struts的偉大之處，在於它對網頁數據的動態綁定。雖然數據綁定不是一個新名 詞，微軟在1991年推出Visual Basic1.0的時候，就創造性地發明了讓VB程序員又愛又恨的數據綁定，但是對於Web 編程，Struts也還是把數據綁定首次應用到了Web編程上。它能夠讓人們用Set和Get的形式取得網頁數據，而不是單一的黑盒式的 request.getParameter()，從而使得網頁數據取值進入面向對象（OO）化時代。</p><p class=ql-align-justify>Struts、Hibernate以及Spring本身都是製作精良的框架，但是對於自己產品和項目的應用，一經整合在一起，卻不一定很適用。比如 說，對於數據庫相關的MIS（管理信息系統）系統中，增加、修改、刪除、查詢功能是最基本、最常見、必不可少的。對於這些最基本的功能，不同的架構師，則 會做出不同的選擇。有的架構師，選擇了自動生成的理念，做一個代碼自動生成器，設計好數據庫表結構，單擊一個腳本，或者用Eclipse插件的形式，做個 圖形化生成界面，自動生成SSH框架，完成數據庫的增加、修改、刪除、查詢操作。這麼做的好處是數據庫修改了，代碼自動生成就可以了，使得程序員不用再維 護這些無聊的代碼。不過缺陷也是致命的，一是隨著Struts、Hibernate、Spring的升級，這個工具也不得不跟著升級，而做這個工具的程序 員，可能早就離開公司了，後續版本無法維護；二是如果有的業務邏輯跟這些生成的代碼有交叉，數據庫變更後，代碼也無法再次生成了。三是公司的系統架構，則 被嚴重限制在SSH架構基礎上，再也無法改變。有人會問：即使限制在這三種架構上，有何不好嗎？假設有客戶問，你的框架支持雲計算嗎？你總不能說”由於 Struts、Hibernate、Spring 不支持雲計算架構，所以我也不支持”以此取得客戶諒解吧。因此，依賴於第三方架構的產品體系架構，隨著時間的推移，受到的限制會越來越大。</p><p class=ql-align-justify>現在獲得免費分享私信我可以免費獲得Java入門到精通的編程資料，先到先得！！</p><div class=pgc-img><img alt="Java 五大框架之間的對比" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e9b17835c8554dd085359ae3fb0583b5><p class=pgc-img-caption></p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>之間</a></li><li><a>五大</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/653918ea.html alt=流行的三大Java框架之間的對比，不看後悔 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/55636fc365b342fca66950f9809a0f70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/653918ea.html title=流行的三大Java框架之間的對比，不看後悔>流行的三大Java框架之間的對比，不看後悔</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af3332b3.html alt=兩點之間直線最短，為什麼橋樑還要做成曲線呢？不怕成本高嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cc371ad88a14498da31b30a8c8ebf136 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af3332b3.html title=兩點之間直線最短，為什麼橋樑還要做成曲線呢？不怕成本高嗎？>兩點之間直線最短，為什麼橋樑還要做成曲線呢？不怕成本高嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/11c9df59.html alt=兩點之間直線最短，為什麼港珠澳大橋還要做成曲線呢？看你答對沒 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/a651b5eb-8ae1-47d4-9015-34a308916d79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/11c9df59.html title=兩點之間直線最短，為什麼港珠澳大橋還要做成曲線呢？看你答對沒>兩點之間直線最短，為什麼港珠澳大橋還要做成曲線呢？看你答對沒</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/59b78719.html alt=你知道電線和電纜之間到底存在怎樣的區別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b45c3050116f459ab43d4ddadb41a423 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59b78719.html title=你知道電線和電纜之間到底存在怎樣的區別嗎？>你知道電線和電纜之間到底存在怎樣的區別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/452699e7.html alt=波多黎各是美國殖民地嗎？波多黎各與美國之間的殖民和寄生關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/72776d0e96aa4b749912fdbdeb8e5a50 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/452699e7.html title=波多黎各是美國殖民地嗎？波多黎各與美國之間的殖民和寄生關係>波多黎各是美國殖民地嗎？波多黎各與美國之間的殖民和寄生關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>