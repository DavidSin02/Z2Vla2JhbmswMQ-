<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>面向對象設計的七大原則 | 极客快訊</title><meta property="og:title" content="面向對象設計的七大原則 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e00f029.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e00f029.html><meta property="article:published_time" content="2020-11-14T21:01:42+08:00"><meta property="article:modified_time" content="2020-11-14T21:01:42+08:00"><meta name=Keywords content><meta name=description content="面向對象設計的七大原則"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3e00f029.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>面向對象設計的七大原則</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><div class=pgc-img><img alt=面向對象設計的七大原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/fd44e43836e64ae3b2c4d6e9ffa9f033><p class=pgc-img-caption></p></div><p class=ql-align-justify>軟件項目中，需求是不斷變化的，需求也是項目中最難把控的，需求的變更也是無法避免的。我們寫的軟件程序，如何能實現擁抱變化，使我們的軟件達到可維護和可複用，這是一代代軟件工程師不斷追尋的真理。</p><p class=ql-align-justify>導致一個軟件的可維護性較低的原因有四個：</p><p class=ql-align-justify>1、過於僵硬（Rigidity）：比如在系統中新增一個功能，會變得非常複雜，涉及到很多模塊的調整，這就是系統僵硬的體現。</p><p class=ql-align-justify>2、過於脆弱（Fragility）：比如對程序中某一個地方的修改，導致看上去沒有什麼關係的其他地方產生了影響，修改的同時，沒有人能預測改動會給系統帶來什麼風險。</p><p class=ql-align-justify>3、複用率低（Immobility）：比如想使用程序中已有的一段代碼、函數、模塊時，這些已有的代碼總是依賴一大堆其它的東西，很難將它們獨立出來使用。</p><p class=ql-align-justify>4、黏度過高（Viscosity）：如果一個系統設計，不能簡單的複用一個類或者通過接口來實現擴展，想擴展一個系統功能，必須破壞原始架構，就是黏度過高。</p><p class=ql-align-justify>一個好的系統設計應該有如下的性質：</p><p class=ql-align-justify>1、可擴展性（Extensibility）：可以很容易的在系統中加入一個新的功能。</p><p class=ql-align-justify>2.靈活性（Flexibility）：可以很容易的實現對某個代碼的修改，而不擔心對其他模塊產生影響。</p><p class=ql-align-justify>3.可插入性（Pluggability）：可以很容易的將一個類抽出去複用，或者將另一個有同樣功能的接口的類加入到系統裡。</p><p class=ql-align-justify>常用的面向對象設計原則有6個，這6大設計原則都是以可維護性和可複用性為基礎的，這些原則並不是孤立存在的，它們相互依賴相互補充，遵循這些設計原則可以有效地提高系統的複用性，同時提高系統的可維護性。</p><div class=pgc-img><img alt=面向對象設計的七大原則 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/778e865d0419465e9d34e37a37be0c1a><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>1</p><p class=ql-align-justify><strong>開閉原則</strong></p><p class=ql-align-justify><strong>（Open-Closed Principle，OCP）</strong></p><p class=ql-align-justify><strong>1、開閉原則定義</strong></p><p class=ql-align-justify>開閉原則：一個軟件實體如類、模塊應該對擴展開放，對修改關閉。即在不修改軟件實體的基礎上去擴展其功能。</p><p class=ql-align-justify>Open（Open for extension）：軟件實體的行為必須是開放的、支持擴展的，而不是僵化的。</p><p class=ql-align-justify>Closed（Closed for modification）：在對軟件實體的功能進行擴展時，不能修改已有的程序模塊。</p><p class=ql-align-justify>絕大部分的設計模式都符合開閉原則，開閉原則要求開發人員可以在不修改系統中現有的功能代碼的前提下，而實現對應用系統的軟件功能進行擴展。即要求我們應儘量通過擴展軟件實體的行為來實現變化，而不是通過修改已有的代碼來實現變化。它是為了適應未來的變化而對現有開發設計進行約束的一個原則。</p><p class=ql-align-justify><strong>2、開閉原則分析</strong></p><p class=ql-align-justify>開閉原則對擴展開放，對修改關閉，並不意味著我們的代碼不能做任何更改，底層模塊的變更，必然導致高層模塊進行適配調整。</p><p class=ql-align-justify>開閉原則是最基礎的一個原則，抽象化是開閉原則的關鍵。</p><p class=ql-align-justify>1、通過接口或者抽象類對擴展進行約束，不允許出現在接口或者抽象類中不存在的public方法。</p><p class=ql-align-justify>2、參數類型，引用對象儘量使用接口或者抽象類，而不是具體的實現類。</p><p class=ql-align-justify>3、抽象層儘量保持穩定，一旦確定就不允許修改。</p><p class=ql-align-justify>2</p><p class=ql-align-justify><strong>單一職責原則</strong></p><p class=ql-align-justify><strong>（Single Responsibility Principle，SRP）</strong></p><p class=ql-align-justify><strong>1、單一職責原則定義</strong></p><p class=ql-align-justify>單一職責原則的意思是：類的職責要單一，不能將太多的職責放在一個類中。單一職責原則要求一個接口或類只能有一個原因引起變化，也就是一個接口或者類只能由一個職責。</p><p class=ql-align-justify><strong>2、單一職責原則分析</strong></p><p class=ql-align-justify>單一職責原則是高內聚性原則，避免相同的職責（也成為功能）分散到不同的類中實現，避免一個類承擔過多的職責。可以減少類之間的耦合。</p><p class=ql-align-justify>單一職責原則適用於接口，類，同時也適用於方法，即一個方法儘可能只做一件事情。</p><p class=ql-align-justify>一般單一職責原則很難在項目中體現，因為單一職責的標準是用“職責”和“變化原因”來衡量一個接口或者類設計的是否優雅，但是“職責”和“變化原因”是不可度量的，項目或需求不同，會有不同的體現。</p><p class=ql-align-justify>再者，本來一個類可以實現的功能，按照單一職責拆分成多個類，然後再用聚合或者組合的方式耦合起來，這樣增加了系統的複雜性。</p><p class=ql-align-justify>因此，對應單一職責原則，不能一味地追求職責單一化，適可而止就行。</p><p class=ql-align-justify>3</p><p class=ql-align-justify><strong>里氏替換原則</strong></p><p class=ql-align-justify><strong>（Liskov Substitution Principle, LSP）</strong></p><p class=ql-align-justify><strong>1、里氏替換原則定義</strong></p><p class=ql-align-justify>里氏替換原則的意思是：在軟件系統中，一個可以接受基類對象的地方必然可以接受一個子類對象，即凡是父類能出現的地方，子類都可以進行替代。</p><p class=ql-align-justify>把基類替換成它的子類，程序將不會產生任務錯誤和異常，反過來則不成立，如果一個軟件實體使用的是一個子類的話，那麼它不一定能夠使用基類。</p><p class=ql-align-justify>里氏替換原則是實現開閉原則的重要方式之一，由於使用基類對象的地方都可以使用子類對象，因此在程序中儘量使用基類類型來對對象進行定義，而在運行時再確定其子類類型，用子類對象來替換父類對象。</p><p class=ql-align-justify><strong>2、里氏替換原則分析</strong></p><p class=ql-align-justify>里氏替換原則主要是針對繼承的設計原則，它為良好的繼承定義了一個規範。</p><p class=ql-align-justify>1、子類可以實現父類的抽象方法，但不能覆蓋父類的非抽象方法。</p><p class=ql-align-justify>2、子類可以增加自己特有的方法。</p><p class=ql-align-justify>3、當子類的方法重載父類的方法時，方法的前置條件（即方法的形參）可以放大（比父類方法的輸入參數更寬鬆）。</p><p class=ql-align-justify>4、當子類的方法實現父類的抽象方法時，方法的後置條件（即方法的返回值）可以被縮小（比父類更嚴格）。</p><p class=ql-align-justify>如果父類的某些方法在子類中已經不能使用，則建議斷開父子繼承關係，採用依懶，聚合，組合關係代替繼承。</p><p class=ql-align-justify>4</p><p class=ql-align-justify>2</p><p class=ql-align-justify><strong>依懶倒置原則</strong></p><p class=ql-align-justify><strong>（Dependency Inversion Principle, DIP）</strong></p><p class=ql-align-justify><strong>1、依懶倒置原則定義</strong></p><p class=ql-align-justify>依懶倒置原則的意思是：高層模塊不應該依懶底層模塊，它們都應該依懶抽象，抽象不應該依懶於細節，細節應該依懶於抽象。</p><p class=ql-align-justify>另外一種表述為：要針對抽象層編程，而不要針對具體實現類編程。</p><p class=ql-align-justify><strong>2、依懶倒置原則分析</strong></p><p class=ql-align-justify>1、如果說開閉原則是面向對象設計的目標的話，那麼依賴倒轉原則就是面向對象設計的主要手段。</p><p class=ql-align-justify>2、依賴倒置原則的常用實現方式之一是在代碼中使用抽象類，而將具體類放在配置文件中。</p><p class=ql-align-justify><strong>類之間的耦合關係</strong></p><p class=ql-align-justify>1、零耦合關係</p><p class=ql-align-justify>2、具體耦合關係</p><p class=ql-align-justify>3、抽象耦合關係</p><p class=ql-align-justify>依賴倒置原則要求客戶端依賴與抽象耦合，以抽象方式耦合是依賴倒轉原則的關鍵。</p><p class=ql-align-justify>依懶倒置就是編寫程序需要的是對現實世界的事物進行抽象，抽象的結果就是有了抽象類和接口，然後我們用抽象間的依懶代替了實實在在的實現類間的依懶。</p><p class=ql-align-justify><strong>依懶的三種寫法</strong></p><p class=ql-align-justify>1、構造函數傳遞依懶對象，也叫構造函數注入</p><p class=ql-align-justify>2、Setter方法傳遞依懶對象，也叫Setter依懶注入</p><p class=ql-align-justify>3、接口聲明依懶對象，也叫接口注入，就是在接口的方法參數中聲明依懶對象。</p><p class=ql-align-justify>5</p><p class=ql-align-justify><strong>接口隔離原則</strong></p><p class=ql-align-justify><strong>（Interface Segregation Principle, ISP）</strong></p><p class=ql-align-justify><strong>1、接口隔離原則定義</strong></p><p class=ql-align-justify>接口隔離原則的意思是：客戶端不應該依賴那些它不需要的接口，一旦一個接口太大，則需要將它分割成一些更細小的接口，使用該接口的客戶端僅需知道與之相關的方法即可。</p><p class=ql-align-justify>接口隔離原則要求我們不要建立功能豐富的龐大接口，使用多個專門的接口來取代一個統一的接口。每一個接口應該承擔一種相對獨立的角色，不多不少，不幹不該乾的事，該乾的事都要幹。</p><p class=ql-align-justify>接口隔離原則告訴我們：使用多個隔離的接口，比使用單個接口要好，儘量降低類之間的耦合度。</p><p class=ql-align-justify><strong>2、接口隔離原則分析</strong></p><p class=ql-align-justify>1、一個接口就只代表一個角色，每個角色都有它特定的一個接口。</p><p class=ql-align-justify>2、接口僅僅提供客戶端需要的行為，即所需的方法，客戶端不需要的行為則隱藏起來，應當為客戶端提供儘可能小的單獨的接口，而不要提供大的總接口。</p><p class=ql-align-justify>3、使用接口隔離原則拆分接口時，首先必須滿足單一職責原則，將一組相關的操作定義在一個接口中，且在滿足高內聚的前提下，接口中的方法越少越好。</p><p class=ql-align-justify>6</p><p class=ql-align-justify><strong>迪米特法則</strong></p><p class=ql-align-justify><strong>（Law of Demeter, LoD）</strong></p><p class=ql-align-justify><strong>1、迪米特法則的定義</strong></p><p class=ql-align-justify>迪米特法則又稱最少知識原則(Least Knowledge Principle, LKP)，它有多種定義方法，其中幾種典型定義如下：</p><p class=ql-align-justify>1、不要和“陌生人”說話。</p><p class=ql-align-justify>2、只與你的直接朋友通信。</p><p class=ql-align-justify>3、 每一個軟件實體對其他的實體都只有最少的知識，而且侷限於那些與本實體密切相關的軟件實體。</p><p class=ql-align-justify>迪米特法則的意思是：一個軟件實體對其他實體的引用越少越好，或者說如果兩個類不必彼此直接通信，那麼這兩個類就不應當發生直接的相互作用，而是通過引入一個第三者發生間接交互。</p><p class=ql-align-justify><strong>2、迪米特法則的分析</strong></p><p class=ql-align-justify>迪米特法則的核心觀念就是創建鬆耦合的類。簡單地說，迪米特法則就是指一個軟件實體應當儘可能少的與其他實體發生相互作用。這樣，當一個模塊修改時，就會盡量少的影響其他的模塊，擴展會相對容易。</p><p class=ql-align-justify>在迪米特法則中，對於一個對象，其朋友包括以下幾類：</p><p class=ql-align-justify>(1) 當前對象本身(this)；</p><p class=ql-align-justify>(2) 以參數形式傳入到當前對象方法中的對象；</p><p class=ql-align-justify>(3) 當前對象的成員對象；</p><p class=ql-align-justify>(4) 如果當前對象的成員對象是一個集合，那麼集合中的元素也都是朋友；</p><p class=ql-align-justify>(5) 當前對象所創建的對象。</p><p class=ql-align-justify>任何一個對象，如果滿足上面的條件之一，就是當前對象的“朋友”，否則就是“陌生人”。</p><p class=ql-align-justify>7</p><p class=ql-align-justify><strong>合成複用原則</strong></p><p class=ql-align-justify><strong>（Composite Reuse Principle, CRP）</strong></p><p class=ql-align-justify><strong>1、合成複用原則的定義</strong></p><p class=ql-align-justify>合成複用原則又稱為組合/聚合複用原則(Composition/ Aggregate Reuse Principle, CARP)，其定義如下：儘量使用對象組合，而不是繼承來達到複用的目的。</p><p class=ql-align-justify>合成複用原則就是指在一個新的對象裡通過關聯關係（包括組合關係和聚合關係）來使用一些已有的對象，使之成為新對象的一部分；新對象通過委派調用已有對象的方法達到複用其已有功能的目的。簡言之：要儘量使用組合/聚合關係，少用繼承。</p><p class=ql-align-justify><strong>2、合成複用原則的分析</strong></p><p class=ql-align-justify>在面向對象設計中，可以通過繼承或者組合/聚合關係，在不同的環境中複用已有的設計和實現。</p><p class=ql-align-justify>繼承複用：實現簡單，易於擴展。破壞系統的封裝性；從基類繼承而來的實現是靜態的，不可能在運行時發生改變，沒有足夠的靈活性；只能在有限的環境中使用。又叫“白箱”複用。</p><p class=ql-align-justify>組合/聚合複用：耦合度相對較低，選擇性地調用成員對象的操作；可以在運行時動態進行。又叫“黑箱”複用。</p><p class=ql-align-justify>組合/聚合可以使系統更加靈活，類與類之間的耦合度降低，一個類的變化對其他類造成的影響相對較少，因此一般首選使用組合/聚合來實現複用。</p><p class=ql-align-justify>在使用繼承時，需要嚴格遵循里氏代換原則，有效使用繼承會有助於對問題的理解，降低複雜度，而濫用繼承反而會增加系統構建和維護的難度以及系統的複雜度，因此需要慎重使用繼承複用。</p><p class=ql-align-justify>8</p><p class=ql-align-justify>3</p><p class=ql-align-justify>結束語</p><p class=ql-align-justify><strong>軟件設計的根本就是要應對需求的變化，實際項目中需求變化又是不可預料的，面向對象設計給我們總結了6大設計原則來應對未來的變化：</strong></p><p class=ql-align-justify><strong>Single Responsibility Principle：單一職責原則</strong></p><p class=ql-align-justify><strong>Open Closed Principle：開閉原則</strong></p><p class=ql-align-justify><strong>Liskov Substitution Principle：里氏替換原則</strong></p><p class=ql-align-justify><strong>Law of Demeter：迪米特法則</strong></p><p class=ql-align-justify><strong>Interface Segregation Principle：接口隔離原則</strong></p><p class=ql-align-justify><strong>Dependency Inversion Principle：依賴倒轉原則</strong></p><p class=ql-align-justify><strong>把這6個原則的首字母聯合起來就是Solid（穩定的），也就是說把這6個原則結合起來使用就可以建立穩定、靈活、可擴展、可複用的系統</strong></p><hr><p class=ql-align-justify>最後，我自己是一名從事了多年開發的Java老程序員，辭職目前在做自己的Java私人定製課程，今年年初我花了一個月整理了一份最適合2019年學習的Java學習乾貨，可以送給每一位喜歡Java的小夥伴，<strong>想要獲取的可以關注我的頭條號並在後臺私信我：01，即可免費獲取。</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>對象</a></li><li><a>設計</a></li><li><a>原則</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html alt=面向對象設計原則之開閉原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff63803ae3d4638b01095d32682fa70 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2cda0974.html title=面向對象設計原則之開閉原則>面向對象設計原則之開閉原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html alt=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/93686fc2-2a36-4161-8664-03ae59f6e71e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc65221c.html title=面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺>面向對象設計原則：不是編程的門檻，是衡量程序員水平的標尺</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/830b660.html alt=面向對象的程序設計原則之SOLID原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1391fe67dc134aae92fef59ec541c40e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/830b660.html title=面向對象的程序設計原則之SOLID原則>面向對象的程序設計原則之SOLID原則</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eb60e0b.html alt="面向對象的設計原則-'里氏替換原則'" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eb60e0b.html title="面向對象的設計原則-'里氏替換原則'">面向對象的設計原則-'里氏替換原則'</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ff8b90.html alt=不懂對象設計原則，都不好意思自稱php大師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ff8b90.html title=不懂對象設計原則，都不好意思自稱php大師>不懂對象設計原則，都不好意思自稱php大師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f0ef77f.html alt=面向對象設計原則（OOP） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1537670193470d0e7533729 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f0ef77f.html title=面向對象設計原則（OOP）>面向對象設計原則（OOP）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5862f7a.html alt=面向對象設計的原則一二 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f695e811db847a991662fc4eefa151f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5862f7a.html title=面向對象設計的原則一二>面向對象設計的原則一二</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html alt=面向對象程序設計三大重要機制之多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1529987756501ead8b951fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a8984de6.html title=面向對象程序設計三大重要機制之多態>面向對象程序設計三大重要機制之多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb36434b.html alt=可靠性設計原則1000條---菜鳥走向大神必經之路 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb36434b.html title=可靠性設計原則1000條---菜鳥走向大神必經之路>可靠性設計原則1000條---菜鳥走向大神必經之路</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f7121626.html alt=可靠性設計原則1000條（完整版，建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f7121626.html title=可靠性設計原則1000條（完整版，建議收藏）>可靠性設計原則1000條（完整版，建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a11c588.html alt="PCB設計基本流程 & 佈局佈線基本原則和常識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7d8f835b7a3a4991b521f59f78f48d65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a11c588.html title="PCB設計基本流程 & 佈局佈線基本原則和常識">PCB設計基本流程 & 佈局佈線基本原則和常識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a849f9c9.html alt=燃氣管道佈置設計原則、基本要求與補償器的選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/153013884a3441cdaf954d0f1510fc51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a849f9c9.html title=燃氣管道佈置設計原則、基本要求與補償器的選擇>燃氣管道佈置設計原則、基本要求與補償器的選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0d7ca019.html alt=管道佈置設計原則、基本要求與補償器的選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ba20020083df4c82a21b87b502ae0a0e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0d7ca019.html title=管道佈置設計原則、基本要求與補償器的選擇>管道佈置設計原則、基本要求與補償器的選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a540ed0e.html alt=建築立面設計原則+處理手法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5dd8595ef4064bc5b4b0eee602fbaef5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a540ed0e.html title=建築立面設計原則+處理手法>建築立面設計原則+處理手法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html alt=面向對象設計之依賴倒置原則 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3033c43f.html title=面向對象設計之依賴倒置原則>面向對象設計之依賴倒置原則</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>