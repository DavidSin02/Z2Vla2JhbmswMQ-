<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>計算機通信之謎，帶你徹底理解socket網絡編程（一） | 极客快訊</title><meta property="og:title" content="計算機通信之謎，帶你徹底理解socket網絡編程（一） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/c2b2caf6f97d420e9da2d36b5464072b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3e8892b2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3e8892b2.html><meta property="article:published_time" content="2020-10-29T21:10:18+08:00"><meta property="article:modified_time" content="2020-10-29T21:10:18+08:00"><meta name=Keywords content><meta name=description content="計算機通信之謎，帶你徹底理解socket網絡編程（一）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3e8892b2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>計算機通信之謎，帶你徹底理解socket網絡編程（一）</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><span style="color:#4d4d4d;--tt-darkmode-color: #999999">出現一項技術，首先我們弄懂一下，為什麼要出現。那麼為什麼要出現socket這玩意呢？可以很簡單的用一句話來概括：</span></p><blockquote><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">為了實現兩臺計算機的通信</span></span></p></blockquote><div class=pgc-img><img alt=計算機通信之謎，帶你徹底理解socket網絡編程（一） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c2b2caf6f97d420e9da2d36b5464072b><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">1、socket誕生的原因</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">兩臺裝有操作系統的機子要想實現通信，第一要聯網，第二通信雙方一定製定某種規則。我們平時最為常見的http請求也是一種通信協議，只不過它是屬於應用層的。http協議將要發送的數據封裝後，傳到下面一層處理，這下一層就是傳輸層，也是我們今天要說的重點。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">應用層的數據封裝之後要發到下面的傳輸層，那麼傳輸層就需要對外提供接口，讓應用層可以調用傳輸層的數據，這個就是socket。傳輸層就是通過socket來對外提供服務的，</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">毫不誇張的說，socket是計算機通信的基石</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">，任何兩臺計算機要想實現通信，必須要有socket。傳輸層是在操作系統層面，socket的實現細節是操作系統已經封裝好的了。所以聰明的你可能已經知道了，不同的操作系統實現的socket各不相同，對外提供的函數可能也有點不同。我們這裡討論的都是Linux系統。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2、服務端和客戶端的代碼實現</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">其他的先不說，我們先給出服務端和客戶端的代碼，然後通過代碼來分析兩臺主機通信之間的過程。這個代碼已經在Linux上運行過了，完全可以使用，大家需要的話可以直接拿去用。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.1、服務端代碼</span></h1><pre><code>#include &lt;stdio.h&gt;#include &lt;sys/socket.h&gt;#include &lt;netinet/in.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;unistd.h&gt;#include &lt;string.h&gt; #define BUF_SIZE 512#define ERR_EXIT(m)         \	do                      \	{                       \		perror(m);          \		exit(EXIT_FAILURE); \	} while (0) int main(){	//創建套接字	int m_sockfd = socket(AF_INET, SOCK_STREAM, 0);	if (m_sockfd &lt; 0)	{		ERR_EXIT("create socket fail");	} 	//初始化socket元素	struct sockaddr_in server_addr;	int server_len = sizeof(server_addr);	memset(&amp;server_addr, 0, server_len); 	server_addr.sin_family = AF_INET;	//server_addr.sin_addr.s_addr = inet_addr("0.0.0.0"); //用這個寫法也可以	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(39002); 	//綁定文件描述符和服務器的ip和端口號	int m_bindfd = bind(m_sockfd, (struct sockaddr *)&amp;server_addr, server_len);	if (m_bindfd &lt; 0)	{		ERR_EXIT("bind ip and port fail");	} 	//進入監聽狀態，等待用戶發起請求	int m_listenfd = listen(m_sockfd, 20);	if (m_listenfd &lt; 0)	{		ERR_EXIT("listen client fail");	} 	//定義客戶端的套接字，這裡返回一個新的套接字，後面通信時，就用這個m_connfd進行通信	struct sockaddr_in client_addr;	socklen_t client_len = sizeof(client_addr);	int m_connfd = accept(m_sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_len); 	//接收客戶端數據，並相應	char buffer[BUF_SIZE];	recv(m_connfd, buffer, sizeof(buffer), 0);	printf("server recv:%s\n", buffer);	strcat(buffer, "+ACK");	send(m_connfd, buffer, sizeof(buffer), MSG_NOSIGNAL); 	//關閉套接字	close(m_connfd);	close(m_sockfd); 	return 0;}</code></pre><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">2.2、客戶端代碼</span></h1><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;sys/socket.h&gt; #define BUF_SIZE 512#define ERR_EXIT(m)         \	do                      \	{                       \		perror(m);          \		exit(EXIT_FAILURE); \	} while (0) int main(){	//創建套接字	int m_sockfd = socket(AF_INET, SOCK_STREAM, 0);	if (m_sockfd &lt; 0)	{		ERR_EXIT("create socket fail");	} 	//服務器的ip為本地，端口號	struct sockaddr_in server_addr;	memset(&amp;server_addr, 0, sizeof(server_addr));	server_addr.sin_family = AF_INET;	server_addr.sin_addr.s_addr = inet_addr("81.68.140.74");	server_addr.sin_port = htons(39002); 	//向服務器發送連接請求	int m_connectfd = connect(m_sockfd, (struct sockaddr *)&amp;server_addr, sizeof(server_addr));	if (m_connectfd &lt; 0)	{		ERR_EXIT("connect server fail");	}	//發送並接收數據	char buffer[BUF_SIZE];	printf("client send:");	scanf("%s", buffer);	send(m_sockfd, buffer, sizeof(buffer), 0);	recv(m_sockfd, buffer, sizeof(buffer), 0);	printf("client recv:%s\n", buffer); 	//斷開連接	close(m_sockfd); 	return 0;}</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以上就是服務端和客戶端的代碼，</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">這個代碼本身沒問題，但是有點小缺點</span>，最後我們會提到。接著筆者分析一下上面的所有socket相關函數，讓大家可以更加深刻的瞭解socket網絡編程。</p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3、socket的基本操作</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">既然socket是“open—write/read—close”模式的一種實現，那麼socket就提供了這些操作對應的函數接口。下面介紹幾個基本的socket接口函數。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.1、socket()函數</span></h1><pre><code>int socket(int domain, int type, int protocol);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">socket函數對應於普通文件的打開操作，普通文件的打開操作返回一個文件描述字，而</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">socket()</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">用於創建一個socket描述符（socket descriptor），它唯一標識一個socket。這個socket描述字跟文件描述字一樣，後續的操作都有用到它，把它作為參數，通過它來進行一些讀寫操作。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">正如可以給fopen的傳入不同參數值，以打開不同的文件。創建socket的時候，也可以指定不同的參數創建不同的socket描述符，socket函數的三個參數分別為：</span></p><ul><li>domain：即協議域，又稱為協議族（family）。常用的協議族有，AF_INET、AF_INET6、AF_LOCAL（或稱AF_UNIX，Unix與socket）、AF_ROUTE等等。協議族決定了socket的地址類型，在通信中必須採用對應的地址，如AF_INET決定了要用ipv4地址（32位的）與端口號（16位的）的組合、AF_UNIX決定了要用一個絕對路徑名作為地址。</li><li>type：指定socket類型。常用的socket類型有SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET等等。</li><li>protocol：故名思意，就是指定協議。常用的協議有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它們分別對應TCP傳輸協議、UDP傳輸協議、STCP傳輸協議、TIPC傳輸協議<span style="color:#f33b45;--tt-darkmode-color: #F33B45">（後面兩種在網絡編程當中很少見到，大家不需要深究）</span></li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：並不是上面的type和protocol可以隨意組合的，如SOCK_STREAM不可以跟IPPROTO_UDP組合。當protocol為0時，會自動選擇type類型對應的默認協議。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">當我們調用</span><strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">socket</span></strong><span style="color:#4d4d4d;--tt-darkmode-color: #999999">創建一個socket時，返回的socket描述字它存在於協議族（address family，AF_XXX）空間中，但沒有一個具體的地址。如果想要給它複製一個地址，就必須調用bind()函數，否則就當調用connect()、listen()時系統會自動隨機分配一個端口。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.2、bind()函數</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">正如上面所說bind()函數把一個地址族中的特定地址賦給socket。例如對應AF_INET、AF_INET6就是把一個ipv4或ipv6地址和端口號組合賦給socket。</span></p><pre><code>int bind(int sockfd, const struct sockaddr *addr, int addrlen);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">函數的三個參數分別為：</span></p><ul><li>sockfd：即socket描述字，它是通過socket()函數創建了，唯一標識一個socket。bind()函數就是將給這個描述字綁定一個名字。</li><li>addr：一個const struct sockaddr *指針，指向要綁定給sockfd的協議地址。這個地址結構根據地址創建socket時的地址協議族的不同而不同。</li><li>addrlen：對應的是地址的長度。</li></ul><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">下面是一個bind()函數的例子，希望大家可以理解這個用法</span></p><pre><code>    struct sockaddr_in server_addr;	int server_len = sizeof(server_addr);	memset(&amp;server_addr, 0, server_len); 	server_addr.sin_family = AF_INET;	//server_addr.sin_addr.s_addr = inet_addr("0.0.0.0"); //用這個寫法也可以	server_addr.sin_addr.s_addr = INADDR_ANY;	server_addr.sin_port = htons(39002); 	//綁定文件描述符和服務器的ip和端口號	int m_bindfd = bind(m_sockfd, (struct sockaddr *)&amp;server_addr, server_len);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">通常服務器在啟動的時候都會綁定一個眾所周知的地址（如ip地址+端口號），用於提供服務，客戶就可以通過它來接連服務器；而客戶端就不用指定，有系統自動分配一個端口號和自身的ip地址組合。這就是為什麼通常服務器端在listen之前會調用bind()，而客戶端就不會調用，而是在connect()時由系統隨機生成一個。</span></p><blockquote><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">網絡字節序與主機字節序</span></span></p><p><strong><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">主機字節序</span></strong><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">就是我們平常說的大端和小端模式：不同的CPU有不同的字節序類型，這些字節序是指整數在內存中保存的順序，這個叫做主機序。引用標準的Big-Endian和Little-Endian的定義如下：</span></p><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">　　a) Little-Endian就是低位字節排放在內存的低地址端，高位字節排放在內存的高地址端。</span></span></p><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">　　b) Big-Endian就是高位字節排放在內存的低地址端，低位字節排放在內存的高地址端。</span></span></p><p><strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">網絡字節序</span></span></strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">：4個字節的32 bit值以下面的次序傳輸：首先是0～7bit，其次8～15bit，然後16～23bit，最後是24~31bit。這種傳輸次序稱作大端字節序。</span></span><strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">由於TCP/IP首部中所有的二進制整數在網絡中傳輸時都要求以這種次序，因此它又稱作網絡字節序。</span></span></strong><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">字節序，顧名思義字節的順序，就是大於一個字節類型的數據在內存中的存放順序，一個字節的數據沒有順序的問題了。</span></span></p><p><span style="color:#4f4f4f;--tt-darkmode-color: #4F4F4F"><span style="background-color:#eef0f4;--tt-darkmode-bgcolor: #BDBEC1">所以：在將一個地址綁定到socket的時候，請先將主機字節序轉換成為網絡字節序，而不要假定主機字節序跟網絡字節序一樣使用的是Big-Endian。由於這個問題曾引發過血案！公司項目代碼中由於存在這個問題，導致了很多莫名其妙的問題，所以請謹記對主機字節序不要做任何假定，務必將其轉化為網絡字節序再賦給socket。</span></span></p></blockquote><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.3、listen()</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">如果作為一個服務器，在調用socket()、bind()之後就會調用listen()來監聽這個socket。</span></p><pre><code>int listen(int sockfd, int backlog);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">listen函數的第一個參數即為要監聽的socket描述字，</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">就是上面創建的那個socket()函數的返回值。</span>第二個參數為相應socket可以排隊的最大連接個數，<span style="color:#f33b45;--tt-darkmode-color: #F33B45">可以理解為有多少個客戶端連接。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：socket()函數創建的socket默認是一個主動類型的，listen函數將socket變為被動類型的，等待客戶的連接請求。listen()如果返回 –1 ，那麼說明在listen()的執行過程中發生了錯誤。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.4、connect()函數</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">客戶端通過調用connect函數來建立與TCP服務器的連接，connect()函數結構如下</span></p><pre><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">connect函數的第一個參數即為客戶端的socket描述字，就是上面客戶端創建的socket()函數的返回值，一般都是大於0的。第二參數為服務器的socket地址，是一個存儲遠程計算機的IP地址和端口信息的結構，一般為服務器的ip與port。第三個參數為socket地址的長度，這裡addrlen=sizeof(addr)。</span></p><p style=text-align:start><span style="color:#f33b45;--tt-darkmode-color: #F33B45">注意：這裡的遠程服務端的端口一定要設置好，千萬不要設置了被服務器防火牆攔截的端口。之前我就是一直無法連接，後面查詢才知道，我設置的端口被服務器防火牆給攔截了。切記切記！！！</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.4、accept()函數</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">TCP服務器端依次調用socket()、bind()、listen()之後，就會監聽指定的socket地址了。TCP客戶端依次調用socket()、connect()之後就向TCP服務器發送了一個連接請求。TCP服務器監聽到這個請求之後，就會調用accept()函數去接收請求，這樣連接就建立好了。之後就可以開始網絡I/O操作了，即類同於普通文件的讀寫I/O操作。</span></p><pre><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">accept函數的第一個參數為服務器的socket描述字，第二個參數為指向struct sockaddr *的指針，用於返回客戶端的協議地址，第三個參數為協議地址的長度，</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">要注意這個長度的類型是socklen_t，不可寫成int。</span>如果accpet成功，那麼其返回值是由內核自動生成的一個全新的描述字，代表與返回客戶的TCP連接。</p><pre><code>//定義客戶端的套接字，這裡返回一個新的套接字，後面通信時，就用這個m_connfd進行通信	struct sockaddr_in client_addr;	socklen_t client_len = sizeof(client_addr);	int m_connfd = accept(m_sockfd, (struct sockaddr *)&amp;client_addr, &amp;client_len);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：accept的第一個參數為服務器的socket描述字，是服務器開始調用socket()函數生成的，稱為監聽socket描述字；而accept函數返回的是已連接的socket描述字。一個服務器通常通常僅僅只創建一個監聽socket描述字，它在該服務器的生命週期內一直存在。內核為每個由服務器進程接受的客戶連接創建了一個已連接socket描述字，當服務器完成了對某個客戶的服務，相應的已連接socket描述字就被關閉。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.5、read()、write()等函數</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">到了這裡，服務器與客戶已經建立好連接了。建立連接之後，我們就是發送通過客戶端發送數據給服務端，當然也可以服務端發過來。因為TCP連接是全雙工的。用以下函數可以實現了網網絡中不同進程之間的通信！網絡I/O操作有下面幾組：</span></p><pre><code>read()/write()recv()/send()readv()/writev()recvmsg()/sendmsg()recvfrom()/sendto()</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">筆者這裡經常用的是read()/write()和recv()/send這兩組函數，當然其他的也是可以的。具體有啥區別，我也沒有太多的去深究。有興趣的同學可以去了解了解。</span></p><pre><code>#include &lt;unistd.h&gt; ssize_t read(int fd, void *buf, size_t count);ssize_t write(int fd, const void *buf, size_t count); #include &lt;sys/types.h&gt;#include &lt;sys/socket.h&gt; ssize_t send(int sockfd, const void *buf, size_t len, int flags);ssize_t recv(int sockfd, void *buf, size_t len, int flags); ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,			  const struct sockaddr *dest_addr, socklen_t addrlen);ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,				struct sockaddr *src_addr, socklen_t *addrlen); ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">read函數是負責從fd中讀取內容。當讀成功時，read返回實際所讀的字節數，如果返回的值是0表示已經讀到文件的結束了，小於0表示出現了錯誤。如果錯誤為EINTR說明讀是由中斷引起的，如果是ECONNREST表示網絡連接出了問題。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">write函數將buf中的nbytes字節內容寫入文件描述符fd。成功時返回寫的字節數，失敗時返回-1，並設置errno變量。 在網絡程序中，當我們向套接字文件描述符寫時有兩種可能。1)write的返回值大於0，表示寫了部分或者是全部的數據。2)返回的值小於0，此時出現了錯誤。我們要根據錯誤類型來處理。如果錯誤為EINTR表示在寫的時候出現了中斷錯誤。如果為EPIPE表示網絡連接出現了問題(對方已經關閉了連接)。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">3.6、close()函數</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">在服務器與客戶端建立連接之後，會進行一些讀寫操作，完成了讀寫操作就要關閉相應的socket描述字，好比操作完打開的文件要調用fclose關閉打開的文件。</span></p><pre><code>#include &lt;unistd.h&gt;int close(int fd);</code></pre><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">該函數的參數就是上面創建的socket的返回值，該描述字不能再由調用進程使用，也就是說不能再作為read或write的第一個參數。至此，socket就會關閉，連接斷掉，不能再進行通信了。</span><span style="color:#f33b45;--tt-darkmode-color: #F33B45">我們熟知的http協議，每次請求之後都會斷開，就是調用了這個close()函數的原因。</span></p><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">注意：close操作只是使相應socket描述字的引用計數-1，只有當引用計數為0的時候，才會觸發TCP客戶端向服務器發送終止連接請求。</span></p><h1 class=pgc-h-arrow-right><span style="color:#4f4f4f;--tt-darkmode-color: #979797">4、代碼的缺陷</span></h1><p style=text-align:start><span style="color:#4d4d4d;--tt-darkmode-color: #999999">以上服務端和客戶端的代碼是socket通信中最基礎的，就是說要想實現兩臺計算機通信，以上函數都是必須的。但是如果大家有去運行以上代碼的話就會發現，啟動服務端後，在啟動客戶端，這時候只是運行一次，客戶端和服務端就都close()退出了，也就是說長連接斷掉了，這顯然不符合實際的使用情況。我們需要的是源源不斷的可以發送數據，那麼以上代碼如何改呢？大家可以思考思考。</span></p><div class=pgc-img><img alt=計算機通信之謎，帶你徹底理解socket網絡編程（一） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/08bbda53ce134f6caa4e3fb87d2e0a83><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=計算機通信之謎，帶你徹底理解socket網絡編程（一） onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/34f347de8edb48d8ac8c070a54bb15c7><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>計算機</a></li><li><a>徹底</a></li><li><a>socket</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html alt=計算機中數字、文字、圖像、聲音和視頻的表示與編碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/8d1d3ec88f2c4a158c7efe55b21d6ed7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2c3db761.html title=計算機中數字、文字、圖像、聲音和視頻的表示與編碼>計算機中數字、文字、圖像、聲音和視頻的表示與編碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8582e44e.html alt="計算機實驗室之樹莓派：課程 7 屏幕02" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/fa8f776ea6c84f08b0fbfaad451371e0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8582e44e.html title="計算機實驗室之樹莓派：課程 7 屏幕02">計算機實驗室之樹莓派：課程 7 屏幕02</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html alt=C++｜徹底弄清偽隨機數與隨機數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0cdba029.html title=C++｜徹底弄清偽隨機數與隨機數>C++｜徹底弄清偽隨機數與隨機數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2e1ceb0.html alt="縱橫談｜徹底清除基層治理中的'灰色手段'" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2e1ceb0.html title="縱橫談｜徹底清除基層治理中的'灰色手段'">縱橫談｜徹底清除基層治理中的'灰色手段'</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd423c48.html alt=口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明…… class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rw0qyU6Ao0YcN0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd423c48.html title=口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明……>口罩產業鏈徹底亂了！丙烯週末瘋狂上漲，價格兩日翻倍，PP期價暴力拉昇；多廠家發緊急聲明……</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4a687640.html alt=寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4a687640.html title=寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動>寶興縣開展“徹底清理層層加碼、堅決真切為基層減負”專項行動</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d451ce4.html alt=熔斷14次！房多多徹底撕開房產平臺暗傷 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0fa1fe78f52a407186f92787addf5ae3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d451ce4.html title=熔斷14次！房多多徹底撕開房產平臺暗傷>熔斷14次！房多多徹底撕開房產平臺暗傷</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html alt="“頂點”計算機面世 登頂超級計算機榜首" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15287045778959b8cdf2283 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/89929bee.html title="“頂點”計算機面世 登頂超級計算機榜首">“頂點”計算機面世 登頂超級計算機榜首</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html alt=美媒揭祕最新世界最快超級計算機“頂點” class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bf5448aa.html title=美媒揭祕最新世界最快超級計算機“頂點”>美媒揭祕最新世界最快超級計算機“頂點”</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html alt=計算機求解微分方程的六大數值計算方法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5b33cbb521894b5aa7f4cf8e1c795cf2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce639ff8.html title=計算機求解微分方程的六大數值計算方法>計算機求解微分方程的六大數值計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c78b6d52.html alt=8分鐘看完，徹底掌握Java正則表達式的十大問題 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/14ae145d-0620-476a-8a82-7912b192e9b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c78b6d52.html title=8分鐘看完，徹底掌握Java正則表達式的十大問題>8分鐘看完，徹底掌握Java正則表達式的十大問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html alt=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a03090d0e5804e88b4003fdcdfa7a301 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e5dc1653.html title=你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？>你瞭解電子數字計算機的發展嗎？人類是如何應用計算機技術的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html alt=第一臺通用數字電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/396cd265.html title=第一臺通用數字電子計算機>第一臺通用數字電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html alt=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f30831efce324fd8ad5055d5c3312dfe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/087e1a1f.html title=第一臺電子計算機的發明者諾依曼，中外發明家故事之十四>第一臺電子計算機的發明者諾依曼，中外發明家故事之十四</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html alt=計算機發展全歷程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/68bbbb84608c4db28b2cf2687596239a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/50ba828e.html title=計算機發展全歷程>計算機發展全歷程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>