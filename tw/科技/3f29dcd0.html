<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用Spring進行面向切面編程（AOP） | 极客快訊</title><meta property="og:title" content="使用Spring進行面向切面編程（AOP） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/b09bdd90d1394d74a47e1c0363fd950a"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f29dcd0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f29dcd0.html><meta property="article:published_time" content="2020-11-14T20:59:17+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:17+08:00"><meta name=Keywords content><meta name=description content="使用Spring進行面向切面編程（AOP）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3f29dcd0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用Spring進行面向切面編程（AOP）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=使用Spring進行面向切面編程（AOP） onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b09bdd90d1394d74a47e1c0363fd950a><p class=pgc-img-caption></p></div><h1 class=pgc-h-arrow-right>前言</h1><p>面向切面編程（AOP）提供另外一種角度來思考程序結構，通過這種方式彌補了面向對象編程（OOP）的不足。 除了類（classes）以外，AOP提供了 切面。切面對關注點進行模塊化，例如橫切多個類型和對象的事務管理。 （這些關注點術語通常稱作 橫切（crosscutting） 關注點。）</p><p>Spring的一個關鍵的組件就是 AOP框架。 儘管如此，Spring IoC容器並不依賴於AOP，這意味著你可以自由選擇是否使用AOP，AOP提供強大的中間件解決方案，這使得Spring IoC容器更加完善。</p><h1 class=pgc-h-arrow-right>Spring 2.0 AOP</h1><p>Spring 2.0 引入了一種更加簡單並且更強大的方式來自定義切面，用戶可以選擇使用基於模式（schema-based）的方式或者使用@AspectJ註解。 這兩種風格都完全支持通知（Advice）類型和AspectJ的切入點語言，雖然實際上仍然使用Spring AOP進行織入（Weaving）。</p><p>本章主要討論Spring 2.0對基於模式和基於@AspectJ的AOP支持。請查閱"AOP聲明風格的選擇"一節獲取 為你的應用選擇適當的聲明風格的建議。Spring 2.0完全保留了對Spring 1.2的向下兼容性，下一章 將討論 Spring 1.2 API所提供的底層的AOP支持。</p><p>Spring中所使用的AOP：提供聲明式企業服務，特別是為了替代EJB聲明式服務。 最重要的服務是 聲明性事務管理（declarative transaction management） ， 這個服務建立在Spring的抽象事務管理（transaction abstraction）之上。</p><p>允許用戶實現自定義的切面，用AOP來完善OOP的使用。</p><p>這樣你可以把Spring AOP看作是對Spring的一種增強，它使得Spring可以不需要EJB就能提供聲明式事務管理； 或者也可以使用Spring AOP框架的全部功能來實現自定義的切面。</p><p>本章首先 介紹了AOP的概念，無論你打算採用哪種風格的切面聲明，這個部分都值得你一讀。 本章剩下的部分將著重於Spring 2.0對AOP的支持； 下一章 提供了關於Spring 1.2風格的AOP概述，也許你已經在其他書本，文章以及已有的應用程序中碰到過這種AOP風格。 如果你只打算使用通用的聲明式服務或者預先打包的聲明式中間件服務，例如緩衝池（pooling）， 那麼你不必直接使用Spring AOP，而本章的大部分內容也可以直接跳過。</p><p><strong>1. AOP概念</strong></p><p>首先讓我們從定義一些重要的AOP概念開始。這些術語不是Spring特有的。 不幸的是，AOP術語並不是特別的直觀；如果Spring使用自己的術語，將會變得更加令人困惑。 切面（Aspect）： 一個關注點的模塊化，這個關注點可能會橫切多個對象。事務管理是J2EE應用中一個關於橫切關注點的很好的例子。 在Spring AOP中，切面可以使用通用類（基於模式的風格） 或者在普通類中以 @Aspect 註解（@AspectJ風格）來實現。</p><ul><li><strong>連接點（Joinpoint）</strong>： 在程序執行過程中某個特定的點，比如某方法調用的時候或者處理異常的時候。 在Spring AOP中，一個連接點 總是 代表一個方法的執行。 通過聲明一個org.aspectj.lang.JoinPoint類型的參數可以使通知（Advice）的主體部分獲得連接點信息。</li><li><strong>通知（Advice）</strong>： 在切面的某個特定的連接點（Joinpoint）上執行的動作。通知有各種類型，其中包括“around”、“before”和“after”等通知。 通知的類型將在後面部分進行討論。許多AOP框架，包括Spring，都是以攔截器做通知模型， 並維護一個以連接點為中心的攔截器鏈。</li><li><strong>切入點（Pointcut）</strong>： 匹配連接點（Joinpoint）的斷言。通知和一個切入點表達式關聯，並在滿足這個切入點的連接點上運行（例如，當執行某個特定名稱的方法時）。 切入點表達式如何和連接點匹配是AOP的核心：Spring缺省使用AspectJ切入點語法。</li><li><strong>引入（Introduction）</strong>： （也被稱為內部類型聲明（inter-type declaration））。聲明額外的方法或者某個類型的字段。 Spring允許引入新的接口（以及一個對應的實現）到任何被代理的對象。 例如，你可以使用一個引入來使bean實現 IsModified 接口，以便簡化緩存機制。</li><li><strong>目標對象（Target Object）</strong>： 被一個或者多個切面（aspect）所通知（advise）的對象。也有人把它叫做 被通知（advised） 對象。 既然Spring AOP是通過運行時代理實現的，這個對象永遠是一個 被代理（proxied） 對象。</li><li><strong>AOP代理（AOP Proxy）</strong>： AOP框架創建的對象，用來實現切面契約（aspect contract）（包括通知方法執行等功能）。 在Spring中，AOP代理可以是JDK動態代理或者CGLIB代理。 注意：Spring 2.0最新引入的基於模式（schema-based）風格和@AspectJ註解風格的切面聲明，對於使用這些風格的用戶來說，代理的創建是透明的。</li><li><strong>織入（Weaving）</strong>： 把切面（aspect）連接到其它的應用程序類型或者對象上，並創建一個被通知（advised）的對象。 這些可以在編譯時（例如使用AspectJ編譯器），類加載時和運行時完成。 Spring和其他純Java AOP框架一樣，在運行時完成織入。 通知的類型：前置通知（Before advice）： 在某連接點（join point）之前執行的通知，但這個通知不能阻止連接點前的執行（除非它拋出一個異常）。</li><li><strong>返回後通知（After returning advice）</strong>： 在某連接點（join point）正常完成後執行的通知：例如，一個方法沒有拋出任何異常，正常返回。</li><li><strong>拋出異常後通知（After throwing advice）</strong>： 在方法拋出異常退出時執行的通知。</li><li><strong>後通知（After (finally) advice）</strong>： 當某連接點退出的時候執行的通知（不論是正常返回還是異常退出）。</li><li><strong>環繞通知（Around Advice）</strong>： 包圍一個連接點（join point）的通知，如方法調用。這是最強大的一種通知類型。 環繞通知可以在方法調用前後完成自定義的行為。它也會選擇是否繼續執行連接點或直接返回它們自己的返回值或拋出異常來結束執行。</li></ul><p>環繞通知是最常用的一種通知類型。大部分基於攔截的AOP框架，例如Nanning和JBoss4，都只提供環繞通知。</p><p>跟AspectJ一樣，Spring提供所有類型的通知，我們推薦你使用盡量簡單的通知類型來實現需要的功能。 例如，如果你只是需要用一個方法的返回值來更新緩存，雖然使用環繞通知也能完成同樣的事情， 但是你最好使用After returning通知而不是環繞通知。 用最合適的通知類型可以使得編程模型變得簡單，並且能夠避免很多潛在的錯誤。 比如，你不需要調用 JoinPoint（用於Around Advice）的 proceed() 方法，就不會有調用的問題。</p><p>在Spring 2.0中，所有的通知參數都是靜態類型，因此你可以使用合適的類型（例如一個方法執行後的返回值類型）作為通知的參數而不是使用一個對象數組。</p><p>切入點（pointcut）和連接點（join point）匹配的概念是AOP的關鍵，這使得AOP不同於其它僅僅提供攔截功能的舊技術。 切入點使得定位通知（advice）可獨立於OO層次。 例如，一個提供聲明式事務管理的around通知可以被應用到一組橫跨多個對象中的方法上（例如服務層的所有業務操作）。</p><p><strong>2. Spring AOP的功能和目標</strong></p><p>Spring AOP用純Java實現。它不需要專門的編譯過程。Spring AOP不需要控制類裝載器層次，因此它適用於J2EE web容器或應用服務器。</p><p>Spring目前僅支持使用方法調用作為連接點（join point）（在Spring bean上通知方法的執行）。 雖然可以在不影響到Spring AOP核心API的情況下加入對成員變量攔截器支持，但Spring並沒有實現成員變量攔截器。 如果你需要把對成員變量的訪問和更新也作為通知的連接點，可以考慮其它語法的Java語言，例如AspectJ。</p><p>Spring實現AOP的方法跟其他的框架不同。Spring並不是要嘗試提供最完整的AOP實現（儘管Spring AOP有這個能力）， 相反的，它其實側重於提供一種AOP實現和Spring IoC容器的整合，用於幫助解決在企業級開發中的常見問題。</p><p>因此，Spring AOP通常都和Spring IoC容器一起使用。 Aspect使用普通的bean定義語法（儘管Spring提供了強大的“自動代理（autoproxying）”功能）： 與其他AOP實現相比這是一個顯著的區別。有些事使用Spring AOP是無法輕鬆或者高效的完成的，比如說通知一個細粒度的對象。 這種時候，使用AspectJ是最好的選擇。不過經驗告訴我們： 於大多數在J2EE應用中遇到的問題，只要適合AOP來解決的，Spring AOP都沒有問題，Spring AOP提供了一個非常好的解決方案。</p><p>Spring AOP從來沒有打算通過提供一種全面的AOP解決方案來取代AspectJ。 我們相信無論是基於代理（proxy-based ）的框架比如說Spring亦或是full-blown的框架比如說是AspectJ都是很有價值的，他們之間的關係應該是互補而不是競爭的關係。 Spring 2.0可以無縫的整合Spring AOP，IoC 和AspectJ，使得所有的AOP應用完全融入基於Spring的應用體系。 這樣的集成不會影響Spring AOP API或者AOP Alliance API；Spring AOP保留了向下兼容性。接下來的一章會詳細討論Spring AOP API。</p><p><strong>3. Spring的AOP代理</strong></p><p>Spring缺省使用J2SE 動態代理（dynamic proxies）來作為AOP的代理。這樣任何接口都可以被代理。</p><p>Spring也支持使用CGLIB代理. 對於需要代理類而不是代理接口的時候CGLIB代理是很有必要的。 如果一個業務對象並沒有實現一個接口，默認就會使用CGLIB。 作為面向接口編程的最佳實踐，業務對象通常都會實現一個或多個接口。但也有可能會 強制使用CGLIB， 在這種情況（希望不常有）下，你可能需要通知一個沒有在接口中聲明的方法，或者需要傳入一個代理對象給方法作為具體類型在Spring 2.0之後，Spring可能會提供多種其他類型的AOP代理，包括了完整的生成類。這不會影響到編程模型。</p><p><strong>4. @AspectJ支持</strong></p><p>"@AspectJ"使用了Java 5的註解，可以將切面聲明為普通的Java類。 AspectJ 5發佈的 AspectJ project 中引入了這種@AspectJ風格。 Spring 2.0 使用了和AspectJ 5一樣的註解，使用了AspectJ 提供的一個庫來做切點（pointcut）解析和匹配。 但是，AOP在運行時仍舊是純的Spring AOP，並不依賴於AspectJ 的編譯器或者織入器（weaver）。 使用AspectJ的編譯器或者織入器（weaver）的話就可以使用完整的AspectJ 語言，我們將在 Section 6.8, “在Spring應用中使用AspectJ” 中討論這個問題。</p><p><strong>5. 啟用@AspectJ支持</strong></p><p>為了在Spring配置中使用@AspectJ aspects，你必須首先啟用Spring對基於@AspectJ aspects的配置支持，自動代理（autoproxying）基於通知是否來自這些切面。 自動代理是指Spring會判斷一個bean是否使用了一個或多個切面通知，並據此自動生成相應的代理以攔截其方法調用，並且確認通知是否如期進行。</p><p>通過在你的Spring的配置中引入下列元素來啟用Spring對@AspectJ的支持：</p><p>我們假使你正在使用 Appendix A, XML Schema-based configuration 所描述的schema支持。</p><p>如果你正在使用DTD，你仍舊可以通過在你的application context中添加如下定義來啟用@AspectJ支持：</p><p>你需要在你的應用程序的classpath中引入兩個AspectJ庫：aspectjweaver.jar 和 aspectjrt.jar。 這些庫可以在AspectJ的安裝包（1.5.1或者之後的版本）中的 lib 目錄裡找到，或者也可以在Spring依賴庫的 lib/aspectj 目錄下找到。</p><p><strong>6. 聲明一個切面</strong></p><p>在啟用@AspectJ支持的情況下，在application context中定義的任意帶有一個@Aspect切面（擁有@Aspect註解）的bean都將被Spring自動識別並用於配置在Spring AOP。 以下例子展示了為了完成一個不是非常有用的切面所需要的最小定義：</p><p>下面是在application context中的一個常見的bean定義，這個bean指向一個使用了 @Aspect 註解的bean類：</p><p>下面是 NotVeryUsefulAspect 類定義，使用了 org.aspectj.lang.annotation.Aspect 註解。</p><pre><code>package org.xyz;import org.aspectj.lang.annotation.Aspect;@Aspectpublic class NotVeryUsefulAspect {}</code></pre><p>切面（用 @Aspect 註解的類）和其他類一樣有方法和字段定義。他們也可能包括切入點，通知和引入（inter-type）聲明。</p><p><strong>7. 聲明一個切入點（pointcut）</strong></p><p>回想一下，切入點決定了連接點關注的內容，使得我們可以控制通知什麼時候執行。 Spring AOP 只支持 Spring bean 方法執行連接點。所以你可以把切入點看做是匹配 Spring bean 上方法的執行。 一個切入點聲明有兩個部分：一個包含名字和任意參數的簽名，還有一個切入點表達式，該表達式決定了我們關注那個方法的執行。 在 @AspectJ 註解風格的 AOP 中，一個切入點簽名通過一個普通的方法定義來提供，並且切入點表達式使用 @Pointcut 註解來表示（作為切入點簽名的方法必須返回 void 類型）。</p><p>用一個例子會幫助我們區分切入點簽名和切入點表達式之間的差別，下面的例子定義了一個切入點'anyOldTransfer'， 這個切入點將匹配任何名為 "transfer" 的方法的執行：</p><pre><code>@Pointcut("execution(* transfer(..))")// the pointcut expressionprivate void anyOldTransfer() {}// the pointcut signature</code></pre><p>切入點表達式，也就是 @Pointcut 註解的值，是正規的AspectJ 5切入點表達式。 如果你想要更多瞭解AspectJ的 切入點語言，請參見 AspectJ 編程指南（如果要了解基於Java 5的擴展請參閱 AspectJ 5 開發手冊） 或者其他人寫的關於AspectJ的書，例如Colyer et. al.著的《Eclipse AspectJ》或者Ramnivas Laddad著的《AspectJ in Action》。</p><p><strong>8. 切入點指定者的支持</strong></p><p>Spring AOP 支持在切入點表達式中使用如下的AspectJ切入點指定者：</p><p><strong>其他的切入點類型</strong></p><p>完整的AspectJ切入點語言支持額外的切入點指定者，但是Spring不支持這個功能。 他們分別是call, initialization, preinitialization, staticinitialization, get, set, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this 和 @withincode。 在Spring AOP中使用這些指定者將會導致拋出IllegalArgumentException異常。</p><p>Spring AOP支持的切入點指定者可能在將來的版本中得到擴展，不但支持更多的AspectJ 切入點指定者（例如"if"），還會支持某些Spring特有的切入點指定者，比如"bean"（用於匹配bean的名字）。 execution - 匹配方法執行的連接點，這是你將會用到的Spring的最主要的切入點指定者。</p><ul><li><strong>within</strong> - 限定匹配特定類型的連接點（在使用Spring AOP的時候，在匹配的類型中定義的方法的執行）。</li><li><strong>this</strong> - 限定匹配特定的連接點（使用Spring AOP的時候方法的執行），其中bean reference（Spring AOP 代理）是指定類型的實例。</li><li><strong>target</strong> - 限定匹配特定的連接點（使用Spring AOP的時候方法的執行），其中目標對象（被代理的appolication object）是指定類型的實例。</li><li><strong>args</strong> - 限定匹配特定的連接點（使用Spring AOP的時候方法的執行），其中參數是指定類型的實例。</li><li><strong>@target</strong> - 限定匹配特定的連接點（使用Spring AOP的時候方法的執行），其中執行的對象的類已經有指定類型的註解。</li><li><strong>@args</strong> - 限定匹配特定的連接點（使用Spring AOP的時候方法的執行），其中實際傳入參數的運行時類型有指定類型的註解。</li><li><strong>@within</strong> - 限定匹配特定的連接點，其中連接點所在類型已指定註解（在使用Spring AOP的時候，所執行的方法所在類型已指定註解）。</li><li><strong>@annotation</strong> - 限定匹配特定的連接點（使用Spring AOP的時候方法的執行），其中連接點的主題有某種給定的註解。 因為Spring AOP限制了連接點必須是方法執行級別的，pointcut designators的討論也給出了一個定義，這個定義和AspectJ的編程指南中的定義相比顯得更加狹窄。 除此之外，AspectJ它本身有基於類型的語義，在執行的連接點'this'和'target'都是指同一個對象，也就是執行方法的對象。 Spring AOP是一個基於代理的系統，並且嚴格區分代理對象本身（對應於'this'）和背後的目標對象（對應於'target'） 6.2.3.2. 合併切入點表達式</li></ul><p>切入點表達式可以使用using '&', '||' 和 '!'來合併.還可以通過名字來指向切入點表達式。 以下的例子展示了三種切入點表達式： anyPublicOperation（在一個方法執行連接點代表了任意public方法的執行時匹配）； inTrading（在一個代表了在交易模塊中的任意的方法執行時匹配） 和 tradingOperation（在一個代表了在交易模塊中的任意的公共方法執行時匹配）。</p><pre><code>@Pointcut("execution(public * *(..))")    private void anyPublicOperation() {}@Pointcut("within(com.xyz.someapp.trading..*")    private void inTrading() {}@Pointcut("anyPublicOperation() &amp;&amp; inTrading()")    private void tradingOperation() {}</code></pre><p>就上所示的，從更小的命名組件來構建更加複雜的切入點表達式是一種最佳實踐。 當用名字來指定切入點時使用的是常見的Java成員可視性訪問規則。 （比如說，你可以在同一類型中訪問私有的切入點，在繼承關係中訪問受保護的切入點，可以在任意地方訪問公共切入點。 成員可視性訪問規則不影響到切入點的 匹配。</p><p><strong>9. 共享常見的切入點（pointcut）定義</strong></p><p>當開發企業級應用的時候，你通常會想要從幾個切面來參考模塊化的應用和特定操作的集合。 我們推薦定義一個“SystemArchitecture”切面來捕捉常見的切入點表達式。一個典型的切面可能看起來像下面這樣：</p><pre><code>package com.xyz.someapp;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;@Aspectpublic class SystemArchitecture {    /**   * A join point is in the web layer if the method is defined   * in a type in the com.xyz.someapp.web package or any sub-package   * under that.   */    @Pointcut("within(com.xyz.someapp.web..*)")      public void inWebLayer() {    }    /**   * A join point is in the service layer if the method is defined   * in a type in the com.xyz.someapp.service package or any sub-package   * under that.   */    @Pointcut("within(com.xyz.someapp.service..*)")      public void inServiceLayer() {    }    /**   * A join point is in the data access layer if the method is defined   * in a type in the com.xyz.someapp.dao package or any sub-package   * under that.   */    @Pointcut("within(com.xyz.someapp.dao..*)")      public void inDataAccessLayer() {    }    /**   * A business service is the execution of any method defined on a service   * interface. This definition assumes that interfaces are placed in the   * "service" package, and that implementation types are in sub-packages.   *    * If you group service interfaces by functional area (for example,    * in packages com.xyz.someapp.abc.service and com.xyz.def.service) then   * the pointcut expression "execution(* com.xyz.someapp..service.*.*(..))"   * could be used instead.   */    @Pointcut("execution(* com.xyz.someapp.service.*.*(..))")      public void businessService() {    }    /**   * A data access operation is the execution of any method defined on a    * dao interface. This definition assumes that interfaces are placed in the   * "dao" package, and that implementation types are in sub-packages.   */    @Pointcut("execution(* com.xyz.someapp.dao.*.*(..))")      public void dataAccessOperation() {    }}</code></pre><p>示例中的切入點定義了一個你可以在任何需要切入點表達式的地方可引用的切面。</p><p><strong>示例</strong></p><p>Spring AOP 用戶可能會經常使用 execution pointcut designator。執行表達式的格式如下：</p><pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</code></pre><p>除了返回類型模式（上面代碼片斷中的ret-type-pattern），名字模式和參數模式以外，所有的部分都是可選的。 返回類型模式決定了方法的返回類型必須依次匹配一個連接點。 你會使用的最頻繁的返回類型模式是 *，它代表了匹配任意的返回類型。 一個全稱限定的類型名將只會匹配返回給定類型的方法。名字模式匹配的是方法名。 你可以使用*通配符作為所有或者部分命名模式。 參數模式稍微有點複雜：() 匹配了一個不接受任何參數的方法， 而 (..) 匹配了一個接受任意數量參數的方法（零或者更多）。 模式 (*) 匹配了一個接受一個任何類型的參數的方法。 模式 (*,String) 匹配了一個接受兩個參數的方法，第一個可以是任意類型，第二個則必須是String類型。</p><ul><li>下面給出一些常見切入點表達式的例子。任意公共方法的執行：execution(public * *(..))</li><li>任何一個以“set”開始的方法的執行：execution(* set*(..))</li><li>AccountService 接口的任意方法的執行：execution(* com.xyz.service.AccountService.*(..))</li><li>定義在service包裡的任意方法的執行：execution(* com.xyz.service.*.*(..))</li><li>定義在service包或者子包裡的任意方法的執行：execution(* com.xyz.service..*.*(..))</li><li>在service包裡的任意連接點（在Spring AOP中只是方法執行） ：within(com.xyz.service.*)</li><li>在service包或者子包裡的任意連接點（在Spring AOP中只是方法執行） ：within(com.xyz.service..*)</li></ul><p>實現了AccountService接口的代理對象的任意連接點（在Spring AOP中只是方法執行） ：this(com.xyz.service.AccountService)'this'在binding form中用的更多</p><p>實現了AccountService接口的目標對象的任意連接點（在Spring AOP中只是方法執行） ：target(com.xyz.service.AccountService)'target'在binding form中用的更多</p><p>任何一個只接受一個參數，且在運行時傳入的參數實現了Serializable接口的連接點 （在Spring AOP中只是方法執行）args(java.io.Serializable)'args'在binding form中用的更多</p><p>請注意在例子中給出的切入點不同於 execution(* *(java.io.Serializable))： args只有在動態運行時候傳入參數是可序列化的（Serializable）才匹配，而execution 在傳入參數的簽名聲明的類型實現了 Serializable 接口時候匹配。</p><p>有一個 @Transactional 註解的目標對象中的任意連接點（在Spring AOP中只是方法執行） @target(org.springframework.transaction.annotation.Transactional)'@target' 也可以在binding form中使用：請常見以下討論通知的章節中關於如何使得annotation對象可以在通知體內訪問到的部分。</p><p>任何一個目標對象聲明的類型有一個 @Transactional 註解的連接點（在Spring AOP中只是方法執行）@within(org.springframework.transaction.annotation.Transactional)'@within'也可以在binding form中使用：- 請常見以下討論通知的章節中關於如何</p><h1 class=pgc-h-arrow-right>Java程序員福利：金三銀四，我把最近一年經歷過的Java崗位面試，和一些刷過的面試題都做成了PDF，PDF都是可以免費分享給大家的，關注私信我：【101】，免費領取！</h1></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>進行</a></li><li><a>編程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html alt=Spring—面向切面編程（AOP）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html title=Spring—面向切面編程（AOP）詳解>Spring—面向切面編程（AOP）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html alt=Spring面向切面編程的AOP的事務增強完整版的配置 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1946647f.html title=Spring面向切面編程的AOP的事務增強完整版的配置>Spring面向切面編程的AOP的事務增強完整版的配置</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html alt="Spring：AOP 面向切面編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html title="Spring：AOP 面向切面編程">Spring：AOP 面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4cb74cd.html alt="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b9d102263d0f46a0b5b203d7b6cd4a2e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4cb74cd.html title="Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記">Spring異步編程 | 你的@Async就真的異步嗎？異步歷險奇遇記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/72139afe.html alt=怎樣對臍橙樹進行扭枝（彎枝）促花？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fe6ea8ad111f421c9673e3f61072fa1f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/72139afe.html title=怎樣對臍橙樹進行扭枝（彎枝）促花？>怎樣對臍橙樹進行扭枝（彎枝）促花？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0c52137.html alt=作文裡面怎麼進行場面描寫？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/230976bf-ee1d-44c0-8ce9-4a4714b8ad40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0c52137.html title=作文裡面怎麼進行場面描寫？>作文裡面怎麼進行場面描寫？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cc683c38.html alt=怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7559326b0b254462970a98290ef15e9f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cc683c38.html title=怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分>怎樣進行場面描寫？中小學生高分作文技巧，作文快速提分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/862b0119.html alt=庭院景觀進行分類，分析其設計手法及景觀元素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0b2a23998d02489a9f65c5ac190e0ab1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/862b0119.html title=庭院景觀進行分類，分析其設計手法及景觀元素>庭院景觀進行分類，分析其設計手法及景觀元素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html alt="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fb2bc471.html title="「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分">「譯」 Spring 的分佈式事務實現—使用和不使用 XA—第二部分</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>