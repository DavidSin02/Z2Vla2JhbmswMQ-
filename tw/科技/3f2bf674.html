<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>進程、線程、協程的選擇與文件併發操作 | 极客快訊</title><meta property="og:title" content="進程、線程、協程的選擇與文件併發操作 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/622e63700f544942809d9a374757630e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/3f2bf674.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/3f2bf674.html><meta property="article:published_time" content="2020-11-14T21:06:37+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:37+08:00"><meta name=Keywords content><meta name=description content="進程、線程、協程的選擇與文件併發操作"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/3f2bf674.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>進程、線程、協程的選擇與文件併發操作</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><blockquote><p><strong>代碼運行環境</strong></p><p>Centos 4u3</p><p>gcc 482 -std=c++11</p><p>AMD x86指令集</p></blockquote><p><em>計算機系統軟件體系結構中有一個非常著名的觀點“Any problem in computer science can be solved by anther layer of indirection.”</em></p><p>實際上進程、線程、協程也是一個分層設計。在這裡簡單說明一下不同層次的簡要介紹以及適用場景，並結合最近做的一個文件審計系統說明文件併發操作的注意點。 一些Unix實現的細節在這裡不描述，大家可以去看《APUE》。</p><h1>一、進程</h1><p>進程（Process）是計算機中的程序關於某數據集合上的一次運行活動，是系統進行資源分配和調度的基本單位，是操作系統結構的基礎。在早期面向進程設計的計算機結構中，進程是程序的基本執行實體；在當代面向線程設計的計算機結構中，進程是線程的容器。程序是指令、數據及其組織形式的描述，進程是程序的實體。</p><p>每一個進程都有它自己的地址空間，包括文本區域（text region）、數據區域（data region）和堆棧（stack region）。文本區域存儲處理器執行的代碼；數據區域存儲變量和進程執行期間使用的動態分配的內存；堆棧區域存儲著活動過程調用的指令和本地變量。多進程間通信需要藉助管道、信號量、共享內存、RPC、消息隊列等等手段。</p><p>多進程時需要注意fork的使用，fork函數一次調用兩次返回。子進程是父進程的副本，它將獲得父進程數據空間、堆、棧等資源的副本。注意，子進程持有的是上述存儲空間的“副本”，這意味著父子進程間不共享這些存儲空間。UNIX將複製父進程的地址空間內容給子進程，因此，子進程有了獨立的地址空間 。下面的case中顯示，子進程會複製父進程的輸入輸出緩衝區的內容，“test”會被打印兩遍，而如果把printf("test")更換為printf("test\n")，則運行程序時只會打印一遍“test”。這與printf的打印機制有關，當遇到換行符後printf把緩衝區內的內容都輸出給顯示設備。這時再發生fork的話，緩衝區沒有任何內容，所以只打印了一遍。</p><pre>#include &lt;unistd.h&gt; #include &lt;stdio.h&gt; #include &lt;sys/types.h&gt; using namespace std;  int main () { pid_t pid; printf("test"); pid=fork(); if (pid &lt; 0) printf("error in fork!"); else if (pid == 0) printf("i am the child process, my process id is %d\n",getpid()); else printf("i am the parent process, my process id is %d\n",getpid()); return 0; } </pre><h1>二、線程</h1><p>線程（Thread）能夠獨立工作、在多核情況下可以同時工作，而且線程消耗的資源要比進程小，同一個進程下的線程共享進程的地址空間和內存空間。</p><p><strong>2.1臨界區</strong></p><p>相對於進程間通信，線程之間通信就變得非常容易了，但是在通信時仍然需要注意對變量進行保護，關於線程間通信的注意事項我們可以看一下下面的示例case1 ：</p><pre>#include &lt;thread&gt; #include &lt;iostream&gt; #include &lt;chrono&gt;  int testThread = 0; void func(int threadNum) { for (int i = 0; i &lt; 5; i++) { testThread = testThread + 1; printf("Thread %d called. testThread is %d\n", threadNum, testThread); } }  int main() { std::thread t1(func, 1); t1.detach(); std::thread t2(func, 2); t2.detach(); std::this_thread::sleep_for(std::chrono::nanoseconds(1)); printf("print:%d", testThread); std::cout &lt;&lt; testThread &lt;&lt; std::endl; return 0; } </pre><p>運行結果如下：</p><pre>$ ./a.out Thread 1 called. testThread is 1 Thread 1 called. testThread is 3 Thread 1 called. testThread is 4 Thread 1 called. testThread is 5 Thread 1 called. testThread is 6 Thread 2 called. testThread is 2 Thread 2 called. testThread is 7 Thread 2 called. testThread is 8 Thread 2 called. testThread is 9 Thread 2 called. testThread is 10 print:1010  $ ./a.out Thread 2 called. testThread is 2 Thread 2 called. testThread is 3 Thread 2 called. testThread is 4 Thread 2 called. testThread is 5 Thread 1 called. testThread is 1 Thread 1 called. testThread is 7 Thread 1 called. testThread is 8 print:6Thread 1 called. testThread is 9 Thread 1 called. testThread is 10 Thread 2 called. testThread is 6 9 </pre><p>調用這個程序會發現主線程print testThread產生不同的結果，深究一下具體原因是因為主線程去獲取testThread的時間點不一樣，我們可以研究一下彙編代碼。累加操作是從指令寄存器讀出數據到累加寄存器，加1後再放回指令寄存器。而printf的時候是從指令寄存器裡讀出數據到累加寄存器，然後把累加寄存器的值交給printf函數調用。</p><p>通過彙編代碼就可以很好地理解這個程序的輸出結果了，主線程中的printf函數調用獲取到了一個”過時”的全局變量，這段代碼也告訴我們使用多線程的時候一定要注意臨界區的變量，必要時需要加鎖。（也告訴我們C++代碼需要深挖到彙編層次才能看清實際問題，<strong>In C++, simple things are simple and portable, complex things require getting your hands dirty under the hood</strong>，LOL）,彙編代碼如下：</p><pre>// print 段彙編代碼 movl testThread(%rip), %eax movl %eax, %esi movl $.LC1, %edi movl $0, %eax call printf // 線程函數累加段彙編代碼 movl testThread(%rip), %eax addl $1, %eax movl %eax, testThread(%rip) </pre><p>使用單條內嵌彙編操作碼在單處理器系統上可能不會有什麼問題。每個加一操作都將完整地進行，並且多半會得到期望的結果。但是多處理器系統則截然不同。在多 CPU 機器上，兩個單獨的處理器可能會在幾乎同一時刻（或者，就在同一時刻）執行上述賦值語句。不要忘了，這時對內存的修改需要先從 L1 寫入 L2 高速緩存、然後才寫入主存。最終，根本無法搞清在寫入主存的競爭中，哪個 CPU 將會”勝出”。要產生可預測的代碼，應使用互斥對象。互斥對象將插入一道”內存關卡”，由它來確保對主存的寫入按照線程鎖定互斥對象的順序進行。 上面的case其實還是一種比較簡單的情況，沒有考慮SMP機器對主存的競爭關係。所有線程都執行這一句testThread = testThread + 1;操作，都有可能會得到不符預期的值，首先，我們不應該假定上述賦值語句一定會被編譯成一條機器指令，除非親自驗證了機器代碼。即使插入某些內嵌彙編語句以確保加一操作的完整執行，甚至，即使是自己動手寫編譯器！ 但是即使這樣做了，仍然可能有問題。</p><p>更復雜的情況下，考慮一種以 32 位塊為單位更新主存的 SMP 體系結構。如果未使用互斥對象就對一個 64 位整數進行加一操作，整數的最高 4 位字節可能來自一個 CPU，而其它 4 個字節卻來自另一 CPU。糟糕吧！最糟糕的是，使用差勁的技術，您的程序在重要客戶的系統上有可能不是很長時間才崩潰一次。David R. Butenhof 在他的《POSIX 線程編程》一書中，討論了由於未使用互斥對象而將產生的種種情況。</p><p><strong>2.2 條件變量</strong></p><p><strong>2.3 線程池</strong></p><h1>三、協程</h1><p>協程（Coroutine）減少異步回調編程</p><h1>四、文件併發操作</h1><p><strong>4.1 Linux系統文件操作過程</strong></p><p>“一切皆是文件”是 Unix/Linux 的基本哲學之一，最近在做的審計日誌系統正好涉及到了多進程對文件的併發操作，在這裡記錄一下文件併發操作的細節。為了搞清楚併發操作對文件讀寫效果產生的影響，有三點知識需要進行說明 第一點是我們需要清楚操作系統讀寫文件的步驟：</p><ol><li>通過文件名找到對應的操作系統inode</li><li>通過inode獲取文件信息，找到文件block的位置</li><li>對對應block數據進行讀寫</li></ol><div class=pgc-img><img alt=進程、線程、協程的選擇與文件併發操作 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/622e63700f544942809d9a374757630e><p class=pgc-img-caption></p></div><p>第二點是如果IO操作不是直接IO，那麼操作系統為了平滑硬盤讀寫慢的影響，通常在內核有設置緩存區。如果是用C庫進行文件讀寫，那麼為了減少在用戶態和內核態直接的切換次數以及系統調用（read && write）的次數，在用戶態還多了一層緩衝區。 緩存是用來減少高速設備訪問低速設備所需平均時間的組件，文件讀寫涉及到計算機內存和磁盤，內存操作速度遠遠大於磁盤。 當內核收到讀寫的請求時，內核先去緩存區找是否有請求的數據，有就直接返回，如果沒有則通過驅動程序直接操作磁盤。</p><p>第三點是fd和inode的映射關係 這裡是fs_struct在內核中的定義</p><pre>struct fs_struct {//建立進程與文件系統的關係 atomic_t count; /*結構的使用計數*/ rwlock_t lock; /*保護該結構體的鎖*/ int umask； /*默認的文件訪問權限*/ struct dentry * root; /*根目錄的目錄項對象*/ struct dentry * pwd; /*當前工作目錄的目錄項對象*/ struct dentry * altroot； /*可供選擇的根目錄的目錄項對象*/ struct vfsmount * rootmnt; /*根目錄的安裝點對象*/ struct vfsmount * pwdmnt; /*pwd的安裝點對象*/ struct vfsmount * altrootmnt;/*可供選擇的根目錄的安裝點對象*/ };</pre><p>清楚了這些後，我們就知道如何應對文件併發訪問了</p><p><strong>4.2 多進程讀寫文件</strong></p><p><strong>4.3 多線程讀寫文件</strong></p><p><strong>4.4 mmap</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>進程</a></li><li><a>線程</a></li><li><a>協程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html alt=併發最基本要理解的進程、線程、協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f756a3627164d4f93883dd7c0e0bac5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ab6b08d6.html title=併發最基本要理解的進程、線程、協程>併發最基本要理解的進程、線程、協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/399bf08.html alt="線程，進程，協程， 併發，並行，同步，異步概念解析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/41ca5e6e9b914e628478b8262ae96e43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/399bf08.html title="線程，進程，協程， 併發，並行，同步，異步概念解析">線程，進程，協程， 併發，並行，同步，異步概念解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html alt="PHP 線程，進程和併發" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7a700a857098411d884a928d6b5f5e01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/77f5407e.html title="PHP 線程，進程和併發">PHP 線程，進程和併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html alt=一文讀懂什麼是進程、線程、協程（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6ba8b142-925e-418e-b20c-71e8f3c20663 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4c41a9dd.html title=一文讀懂什麼是進程、線程、協程（建議收藏）>一文讀懂什麼是進程、線程、協程（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/79e23cb7.html alt=如何理解：程序、進程、線程、併發、並行、高併發？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/b101e22357854a56abf29c0745b5d9c9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/79e23cb7.html title=如何理解：程序、進程、線程、併發、並行、高併發？>如何理解：程序、進程、線程、併發、並行、高併發？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf2fb099.html alt=看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/12861a08-8f52-48c2-9b25-46df51894677 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf2fb099.html title=看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏）>看一遍就懂進程線程、同步異步、阻塞非阻塞、併發並（建議收藏）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c40a49b9.html alt=線程與進程的區別以及對多線程併發的理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/813488ac38be43b29140e4917ff1e0b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c40a49b9.html title=線程與進程的區別以及對多線程併發的理解>線程與進程的區別以及對多線程併發的理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5fc01cfc.html alt=進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5fc01cfc.html title=進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫>進程、線程的概念、區別和聯繫；併發、並行概念、區別和聯繫</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6b8a6681.html alt=進程與線程的區別和併發編程要素 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6b8a6681.html title=進程與線程的區別和併發編程要素>進程與線程的區別和併發編程要素</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0b69a5b.html alt=高併發和高性能系統中進程、線程、協程、隊列（如何調度的） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f41e7ed497b44b618a1df64c6aaa2295 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0b69a5b.html title=高併發和高性能系統中進程、線程、協程、隊列（如何調度的）>高併發和高性能系統中進程、線程、協程、隊列（如何調度的）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b97e222b.html alt=進程、線程、並行與併發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5e04293de8fb49f19388e78a9812cce4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b97e222b.html title=進程、線程、並行與併發>進程、線程、並行與併發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9911d0f.html alt=程序，進程，線程與併發和並行設計實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/165d54ca-9361-4365-9d4b-12a56bebfc33 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9911d0f.html title=程序，進程，線程與併發和並行設計實現>程序，進程，線程與併發和並行設計實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html alt=世界發展進程中的耀眼篇章 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RCLmM9dF1KnwoT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b3994691.html title=世界發展進程中的耀眼篇章>世界發展進程中的耀眼篇章</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html alt=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a646cf102cf74b4a953855ebedbc7d29 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4e632b6e.html title=PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程>PHP進階教程-PHP的協程怎麼玩？這一篇帶你搞定swoole協程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/09d5d35b.html alt=加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/09d5d35b.html title=加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人>加速年輕化進程，脈動宣佈吳亦凡為品牌全球代言人</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>