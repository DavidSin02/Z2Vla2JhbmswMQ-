<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>每週一個 Python 模塊 | socket | 极客快訊</title><meta property="og:title" content="每週一個 Python 模塊 | socket - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/dfic-imagehandler/5276b6c4-ac34-470d-b72c-8f2e22a6ac3e"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4194d1c.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4194d1c.html><meta property="article:published_time" content="2020-10-29T21:04:30+08:00"><meta property="article:modified_time" content="2020-10-29T21:04:30+08:00"><meta name=Keywords content><meta name=description content="每週一個 Python 模塊 | socket"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4194d1c.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>每週一個 Python 模塊 | socket</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div class=pgc-img><img alt="每週一個 Python 模塊 | socket" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/5276b6c4-ac34-470d-b72c-8f2e22a6ac3e><p class=pgc-img-caption></p></div><p>Socket 提供了標準的 BSD Socket API，以便使用 BSD 套接字接口通過網絡進行通信。它包括用於處理實際數據通道的類，還包括與網絡相關的功能，例如將服務器的名稱轉換為地址以及格式化要通過網絡發送的數據。</p><p>尋址、協議族和套接字類型</p><p>socket 是由程序用來傳遞數據或通過互聯網通信的信道的一個端點。套接字有兩個主要屬性來控制它們發送數據的方式： 地址族控制所使用的 OSI 網絡層協議， 以及套接字類型控制傳輸層協議。</p><p>Python 支持三種地址族。最常見的是 AF_INET，用於 IPv4 網絡尋址。IPv4 地址長度為四個字節，通常表示為四個數字的序列，每八字節一個，用點分隔（例如，10.1.1.5和127.0.0.1）。這些值通常被稱為 IP 地址。</p><p>AF_INET6用於IPv6 網絡尋址。IPv6 是網絡協議的下一代版本，支持 IPv4 下不可用的 128 位地址，流量整型和路由功能。IPv6 的採用率持續增長，特別是隨著雲計算的發展，以及由於物聯網項目而添加到網絡中的額外設備的激增。</p><p>AF_UNIX是 Unix 域套接字（UDS）的地址族，它是 POSIX 兼容系統上可用的進程間通信協議。UDS 的實現允許操作系統將數據直接從一個進程傳遞到另一個進程，而無需通過網絡堆棧。這比使用 AF_INET 更高效，但由於文件系統用作尋址的命名空間，因此 UDS 僅限於同一系統上的進程。使用 UDS 而不是其他 IPC 機制（如命名管道或共享內存）的吸引力在於編程接口與 IP 網絡相同，因此應用程序可以在單個主機上運行時高效通信。</p><p>注意：AF_UNIX常量僅定義在支持 UDS 的系統上。</p><p>套接字類型通常用 SOCK_DGRAM 處理面向消息的數據報傳輸，用 SOCK_STREAM 處理面向字節流的傳輸。數據報套接字通常與 UDP（用戶數據報協議）相關聯 ，它們提供不可靠的單個消息傳遞。面向流的套接字與 TCP（傳輸控制協議）相關聯 。它們在客戶端和服務器之間提供字節流，通過超時管理，重傳和其他功能確保消息傳遞或故障通知。</p><p>大多數提供大量數據的應用程序協議（如 HTTP）都是基於 TCP 構建的，因為它可以在自動處理消息排序和傳遞時更輕鬆地創建複雜的應用程序。UDP 通常用於消息不太重要的協議（例如通過 DNS 查找名稱），或者用於多播（將相同數據發送到多個主機）。UDP 和 TCP 都可以與 IPv4 或 IPv6 尋址一起使用。</p><p>注意：Python 的socket模塊還支持其他套接字類型，但不太常用，因此這裡不做介紹。有關更多詳細信息，請參閱標準庫文檔。</p><p>在網絡上查找主機</p><p>socket 包含與網絡域名服務接口相關的功能，因此程序可以將服務器主機名轉換為其數字網絡地址。雖然程序在使用它們連接服務器之前不需要顯式轉換地址，但在報錯時，包含數字地址以及使用的名稱會很有用。</p><p>要查找當前主機的正式名稱，可以使用 gethostname()。</p><pre>import socketprint(socket.gethostname())	# apu.hellfly.net</pre><p>返回的名稱取決於當前系統的網絡設置，如果位於不同的網絡（例如連接到無線 LAN 的筆記本電腦），則可能會更改。</p><p>使用 gethostbyname() 將服務器名稱轉換為它的數字地址。</p><pre>import socketHOSTS = [ 'apu', 'pymotw.com', 'www.python.org', 'nosuchname',]for host in HOSTS: try: print('{} : {}'.format(host, socket.gethostbyname(host))) except socket.error as msg: print('{} : {}'.format(host, msg)) # output# apu : 10.9.0.10# pymotw.com : 66.33.211.242# www.python.org : 151.101.32.223# nosuchname : [Errno 8] nodename nor servname provided, or not known</pre><p>如果當前系統的 DNS 配置在搜索中包含一個或多個域，則 name 參數不必要是完整的名稱（即，它不需要包括域名以及基本主機名）。如果找不到該名稱，則會引發 socket.error 類型異常。</p><p>要訪問服務器的更多命名信息，請使用 gethostbyname_ex()。它返回服務器的規範主機名，別名以及可用於訪問它的所有可用 IP 地址。</p><pre>import socketHOSTS = [ 'apu', 'pymotw.com', 'www.python.org', 'nosuchname',]for host in HOSTS: print(host) try: name, aliases, addresses = socket.gethostbyname_ex(host) print(' Hostname:', name) print(' Aliases :', aliases) print(' Addresses:', addresses) except socket.error as msg: print('ERROR:', msg) print() # output# apu# Hostname: apu.hellfly.net# Aliases : ['apu']# Addresses: ['10.9.0.10']# # pymotw.com# Hostname: pymotw.com# Aliases : []# Addresses: ['66.33.211.242']# # www.python.org# Hostname: prod.python.map.fastlylb.net# Aliases : ['www.python.org', 'python.map.fastly.net']# Addresses: ['151.101.32.223']# # nosuchname# ERROR: [Errno 8] nodename nor servname provided, or not known</pre><p>擁有服務器的所有已知 IP 地址後，客戶端可以實現自己的負載均衡或故障轉移算法。</p><p>使用getfqdn() 將部分名稱轉換為一個完整的域名。</p><pre>import socketfor host in ['apu', 'pymotw.com']: print('{:&gt;10} : {}'.format(host, socket.getfqdn(host))) # output# apu : apu.hellfly.net# pymotw.com : apache2-echo.catalina.dreamhost.com</pre><p>如果輸入是別名，則返回的名稱不一定與輸入參數匹配，例如此處的 www。</p><p>當服務器地址可用時，使用gethostbyaddr() 對名稱執行“反向”查找。</p><pre>import sockethostname, aliases, addresses = socket.gethostbyaddr('10.9.0.10')print('Hostname :', hostname)	# Hostname : apu.hellfly.netprint('Aliases :', aliases)	# Aliases : ['apu']print('Addresses:', addresses)	# Addresses: ['10.9.0.10']</pre><p>返回值是一個元組，包含完整主機名，別名以及與該名稱關聯的所有 IP 地址。</p><p>查找服務信息</p><p>除 IP 地址外，每個套接字地址還包括一個整數端口號。許多應用程序可以在同一主機上運行，監聽單個 IP 地址，但一次只能有一個套接字可以使用該地址的端口。IP 地址，協議和端口號的組合唯一地標識通信信道，並確保通過套接字發送的消息到達正確的目的地。</p><p>某些端口號是為特定協議預先分配的。例如，使用 SMTP 的電子郵件服務器之間的通信，使用 TCP 在端口號 25 上進行，而 Web 客戶端和服務器使用端口 80 進行 HTTP 通信。可以使用 getservbyname() 查找具有標準化名稱的網絡服務的端口號。</p><pre>import socketfrom urllib.parse import urlparseURLS = [ 'http://www.python.org', 'https://www.mybank.com', 'ftp://prep.ai.mit.edu', 'gopher://gopher.micro.umn.edu', 'smtp://mail.example.com', 'imap://mail.example.com', 'imaps://mail.example.com', 'pop3://pop.example.com', 'pop3s://pop.example.com',]for url in URLS: parsed_url = urlparse(url) port = socket.getservbyname(parsed_url.scheme) print('{:&gt;6} : {}'.format(parsed_url.scheme, port)) # output# http : 80# https : 443# ftp : 21# gopher : 70# smtp : 25# imap : 143# imaps : 993# pop3 : 110# pop3s : 995</pre><p>雖然標準化服務不太可能改變端口，但是在未來添加新服務時，通過系統調用來查找而不是硬編碼會更靈活。</p><p>要反轉服務端口查找，使用getservbyport()。</p><pre>import socketfrom urllib.parse import urlunparsefor port in [80, 443, 21, 70, 25, 143, 993, 110, 995]: url = '{}://example.com/'.format(socket.getservbyport(port)) print(url) # output# http://example.com/# https://example.com/# ftp://example.com/# gopher://example.com/# smtp://example.com/# imap://example.com/# imaps://example.com/# pop3://example.com/# pop3s://example.com/</pre><p>反向查找對於從任意地址構造服務的 URL 非常有用。</p><p>可以使用 getprotobyname() 檢索分配給傳輸協議的編號。</p><pre>import socketdef get_constants(prefix): """Create a dictionary mapping socket module constants to their names. """ return { getattr(socket, n): n for n in dir(socket) if n.startswith(prefix) }protocols = get_constants('IPPROTO_')for name in ['icmp', 'udp', 'tcp']: proto_num = socket.getprotobyname(name) const_name = protocols[proto_num] print('{:&gt;4} -&gt; {:2d} (socket.{:&lt;12} = {:2d})'.format( name, proto_num, const_name, getattr(socket, const_name))) # output# icmp -&gt; 1 (socket.IPPROTO_ICMP = 1)# udp -&gt; 17 (socket.IPPROTO_UDP = 17)# tcp -&gt; 6 (socket.IPPROTO_TCP = 6)</pre><p>協議號的值是標準化的，用前綴 IPPROTO_ 定義為常量。</p><p>查找服務器地址</p><p>getaddrinfo() 將服務的基本地址轉換為元組列表，其中包含建立連接所需的所有信息。每個元組的內容會有所不同，包含不同的網絡地址族或協議。</p><pre>import socketdef get_constants(prefix): """Create a dictionary mapping socket module constants to their names. """ return { getattr(socket, n): n for n in dir(socket) if n.startswith(prefix) }families = get_constants('AF_')types = get_constants('SOCK_')protocols = get_constants('IPPROTO_')for response in socket.getaddrinfo('www.python.org', 'http'): # Unpack the response tuple family, socktype, proto, canonname, sockaddr = response print('Family :', families[family]) print('Type :', types[socktype]) print('Protocol :', protocols[proto]) print('Canonical name:', canonname) print('Socket address:', sockaddr) print() # output# Family : AF_INET# Type : SOCK_DGRAM# Protocol : IPPROTO_UDP# Canonical name:# Socket address: ('151.101.32.223', 80)# # Family : AF_INET# Type : SOCK_STREAM# Protocol : IPPROTO_TCP# Canonical name:# Socket address: ('151.101.32.223', 80)# # Family : AF_INET6# Type : SOCK_DGRAM# Protocol : IPPROTO_UDP# Canonical name:# Socket address: ('2a04:4e42:8::223', 80, 0, 0)# # Family : AF_INET6# Type : SOCK_STREAM# Protocol : IPPROTO_TCP# Canonical name:# Socket address: ('2a04:4e42:8::223', 80, 0, 0)</pre><p>該程序演示瞭如何查找 www.python.org 的連接信息。</p><p>getaddrinfo()採用幾個參數來過濾結果列表。host和port是必傳參數。可選的參數是family， socktype，proto，和flags。可選值應該是0或由 socket 定義的常量之一。</p><pre>import socketdef get_constants(prefix): """Create a dictionary mapping socket module constants to their names. """ return { getattr(socket, n): n for n in dir(socket) if n.startswith(prefix) }families = get_constants('AF_')types = get_constants('SOCK_')protocols = get_constants('IPPROTO_')responses = socket.getaddrinfo( host='www.python.org', port='http', family=socket.AF_INET, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP, flags=socket.AI_CANONNAME,)for response in responses: # Unpack the response tuple family, socktype, proto, canonname, sockaddr = response print('Family :', families[family]) print('Type :', types[socktype]) print('Protocol :', protocols[proto]) print('Canonical name:', canonname) print('Socket address:', sockaddr) print() # output# Family : AF_INET# Type : SOCK_STREAM# Protocol : IPPROTO_TCP# Canonical name: prod.python.map.fastlylb.net# Socket address: ('151.101.32.223', 80)</pre><p>由於flags包含AI_CANONNAME，服務器的規範名稱（可能與主機具有別名時用於查找的值不同）包含在結果中。如果沒有該標誌，則規範名稱將保留為空。</p><p>IP 地址表示</p><p>用 C 編寫的網絡程序使用數據類型將 IP 地址表示為二進制值（而不是通常在 Python 程序中的字符串地址）。要在 Python 表示和 C 表示之間轉換 IPv4 地址，請使用structsockaddr、inet_aton() 和 inet_ntoa()。</p><pre>import binasciiimport socketimport structimport sysfor string_address in ['192.168.1.1', '127.0.0.1']: packed = socket.inet_aton(string_address) print('Original:', string_address) print('Packed :', binascii.hexlify(packed)) print('Unpacked:', socket.inet_ntoa(packed)) print() # output# Original: 192.168.1.1# Packed : b'c0a80101'# Unpacked: 192.168.1.1# # Original: 127.0.0.1# Packed : b'7f000001'# Unpacked: 127.0.0.1</pre><p>打包格式中的四個字節可以傳遞給 C 庫，通過網絡安全傳輸，或者緊湊地保存到數據庫中。</p><p>相關函數 inet_pton() 和 inet_ntop() 支持 IPv4 和 IPv6，根據傳入的地址族參數生成適當的格式。</p><pre>import binasciiimport socketimport structimport sysstring_address = '2002:ac10:10a:1234:21e:52ff:fe74:40e'packed = socket.inet_pton(socket.AF_INET6, string_address)print('Original:', string_address)print('Packed :', binascii.hexlify(packed))print('Unpacked:', socket.inet_ntop(socket.AF_INET6, packed))# output# Original: 2002:ac10:10a:1234:21e:52ff:fe74:40e# Packed : b'2002ac10010a1234021e52fffe74040e'# Unpacked: 2002:ac10:10a:1234:21e:52ff:fe74:40e</pre><p>IPv6 地址已經是十六進制值，因此將打包版本轉換為一系列十六進制數字會生成類似於原始值的字符串。</p><p>TCP/IP 客戶端和服務端</p><p>Sockets 可以作為服務端並監聽傳入消息，或作為客戶端連接其他應用程序。連接 TCP/IP 套接字的兩端後，通信是雙向的。</p><p>服務端</p><p>此示例程序基於標準庫文檔中的示例程序，接收傳入的消息並將它們回送給發送方。它首先創建一個 TCP/IP 套接字，然後用 bind() 將套接字與服務器地址相關聯。地址是localhost指當前服務器，端口號是 10000。</p><pre># socket_echo_server.pyimport socketimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# Bind the socket to the portserver_address = ('localhost', 10000)print('starting up on {} port {}'.format(*server_address))sock.bind(server_address)# Listen for incoming connectionssock.listen(1)while True: # Wait for a connection print('waiting for a connection') connection, client_address = sock.accept() try: print('connection from', client_address) # Receive the data in small chunks and retransmit it while True: data = connection.recv(16) print('received {!r}'.format(data)) if data: print('sending data back to the client') connection.sendall(data) else: print('no data from', client_address) break finally: # Clean up the connection connection.close()</pre><p>調用listen()將套接字置於服務器模式，並用 accept()等待傳入連接。整數參數表示後臺排隊的連接數，當連接數超出時，系統會拒絕。此示例僅期望一次使用一個連接。</p><p>accept()返回服務器和客戶端之間的開放連接以及客戶端的地址。該連接實際上是另一個端口上的不同套接字（由內核分配）。從連接中用 recv() 讀取數據並用 sendall() 傳輸數據。</p><p>與客戶端通信完成後，需要使用 close() 清理連接。此示例使用 try:finally塊來確保close()始終調用，即使出現錯誤也是如此。</p><p>客戶端</p><p>客戶端程序的 socket 設置與服務端的不同。它不是綁定到端口並監聽，而是用於connect()將套接字直接連接到遠程地址。</p><pre># socket_echo_client.pyimport socketimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# Connect the socket to the port where the server is listeningserver_address = ('localhost', 10000)print('connecting to {} port {}'.format(*server_address))sock.connect(server_address)try: # Send data message = b'This is the message. It will be repeated.' print('sending {!r}'.format(message)) sock.sendall(message) # Look for the response amount_received = 0 amount_expected = len(message) while amount_received &lt; amount_expected: data = sock.recv(16) amount_received += len(data) print('received {!r}'.format(data))finally: print('closing socket') sock.close()</pre><p>建立連接後，數據可以通過 sendall() 發送 recv() 接收。發送整個消息並收到同樣的回覆後，關閉套接字以釋放端口。</p><p>運行客戶端和服務端</p><p>客戶端和服務端應該在單獨的終端窗口中運行，以便它們可以相互通信。服務端輸出顯示傳入的連接和數據，以及發送回客戶端的響應。</p><pre>$ python3 socket_echo_server.pystarting up on localhost port 10000waiting for a connectionconnection from ('127.0.0.1', 65141)received b'This is the mess'sending data back to the clientreceived b'age. It will be'sending data back to the clientreceived b' repeated.'sending data back to the clientreceived b''no data from ('127.0.0.1', 65141)waiting for a connection</pre><p>客戶端輸出顯示傳出消息和來自服務端的響應。</p><pre>$ python3 socket_echo_client.pyconnecting to localhost port 10000sending b'This is the message. It will be repeated.'received b'This is the mess'received b'age. It will be'received b' repeated.'closing socket</pre><p>簡易客戶端連接</p><p>通過使用便捷功能create_connection()連接到服務端，TCP/IP 客戶端可以節省一些步驟 。該函數接受一個參數，一個包含服務器地址的雙值元組，並派生出用於連接的最佳地址。</p><pre>import socketimport sysdef get_constants(prefix): """Create a dictionary mapping socket module constants to their names. """ return { getattr(socket, n): n for n in dir(socket) if n.startswith(prefix) }families = get_constants('AF_')types = get_constants('SOCK_')protocols = get_constants('IPPROTO_')# Create a TCP/IP socketsock = socket.create_connection(('localhost', 10000))print('Family :', families[sock.family])print('Type :', types[sock.type])print('Protocol:', protocols[sock.proto])print()try: # Send data message = b'This is the message. It will be repeated.' print('sending {!r}'.format(message)) sock.sendall(message) amount_received = 0 amount_expected = len(message) while amount_received &lt; amount_expected: data = sock.recv(16) amount_received += len(data) print('received {!r}'.format(data))finally: print('closing socket') sock.close() # output# Family : AF_INET# Type : SOCK_STREAM# Protocol: IPPROTO_TCP# # sending b'This is the message. It will be repeated.'# received b'This is the mess'# received b'age. It will be'# received b' repeated.'# closing socket</pre><p>create_connection()用getaddrinfo() 方法獲得可選參數，並socket使用創建成功連接的第一個配置返回已打開的連接參數。family，type和proto屬性可以用來檢查返回的類型是 socket 類型。</p><p>選擇監聽地址</p><p>將服務端綁定到正確的地址非常重要，以便客戶端可以與之通信。前面的示例都用 'localhost' 作為 IP 地址，但這樣有一個限制，只有在同一服務器上運行的客戶端才能連接。使用服務器的公共地址（例如 gethostname() 的返回值）來允許其他主機進行連接。修改上面的例子，讓服務端監聽通過命令行參數指定的地址。</p><pre># socket_echo_server_explicit.pyimport socketimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# Bind the socket to the address given on the command lineserver_name = sys.argv[1]server_address = (server_name, 10000)print('starting up on {} port {}'.format(*server_address))sock.bind(server_address)sock.listen(1)while True: print('waiting for a connection') connection, client_address = sock.accept() try: print('client connected:', client_address) while True: data = connection.recv(16) print('received {!r}'.format(data)) if data: connection.sendall(data) else: break finally: connection.close()</pre><p>對客戶端程序進行類似的修改。</p><pre># socket_echo_client_explicit.pyimport socketimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# Connect the socket to the port on the server# given by the callerserver_address = (sys.argv[1], 10000)print('connecting to {} port {}'.format(*server_address))sock.connect(server_address)try: message = b'This is the message. It will be repeated.' print('sending {!r}'.format(message)) sock.sendall(message) amount_received = 0 amount_expected = len(message) while amount_received &lt; amount_expected: data = sock.recv(16) amount_received += len(data) print('received {!r}'.format(data))finally: sock.close()</pre><p>使用參數 hubert 啟動服務端， netstat命令顯示它正在監聽指定主機的地址。</p><pre>$ host hubert.hellfly.nethubert.hellfly.net has address 10.9.0.6$ netstat -an | grep 10000Active Internet connections (including servers)Proto Recv-Q Send-Q Local Address Foreign Address (state)...tcp4 0 0 10.9.0.6.10000 *.* LISTEN...</pre><p>在另一臺主機上運行客戶端，hubert.hellfly.net 作為參數：</p><pre>$ hostnameapu$ python3 ./socket_echo_client_explicit.py hubert.hellfly.netconnecting to hubert.hellfly.net port 10000sending b'This is the message. It will be repeated.'received b'This is the mess'received b'age. It will be'received b' repeated.'</pre><p>服務端輸出是：</p><pre>$ python3 socket_echo_server_explicit.py hubert.hellfly.netstarting up on hubert.hellfly.net port 10000waiting for a connectionclient connected: ('10.9.0.10', 33139)received b''waiting for a connectionclient connected: ('10.9.0.10', 33140)received b'This is the mess'received b'age. It will be'received b' repeated.'received b''waiting for a connection</pre><p>許多服務端具有多個網絡接口，因此也會有多個 IP 地址連接。為每個 IP 地址運行服務端肯定是不明智的，可以使用特殊地址INADDR_ANY 同時監聽所有地址。儘管 socket 為 INADDR_ANY 定義了一個常量，但它是一個整數，必須先將其轉換為點符號分隔的字符串地址才能傳遞給 bind()。作為更方便的方式，使用“ 0.0.0.0”或空字符串（''）就可以了，而不是進行轉換。</p><pre>import socketimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)# Bind the socket to the address given on the command lineserver_address = ('', 10000)sock.bind(server_address)print('starting up on {} port {}'.format(*sock.getsockname()))sock.listen(1)while True: print('waiting for a connection') connection, client_address = sock.accept() try: print('client connected:', client_address) while True: data = connection.recv(16) print('received {!r}'.format(data)) if data: connection.sendall(data) else: break finally: connection.close()</pre><p>要查看套接字使用的實際地址，可以使用 getsockname() 方法。啟動服務後，再次運行 netstat 會顯示它正在監聽任何地址上的傳入連接。</p><pre>$ netstat -anActive Internet connections (including servers)Proto Recv-Q Send-Q Local Address Foreign Address (state)...tcp4 0 0 *.10000 *.* LISTEN...</pre><p>用戶數據報客戶端和服務端</p><p>用戶數據報協議（UDP）與 TCP/IP 的工作方式不同。TCP 是面向字節流的，所有數據以正確的順序傳輸，UDP 是面向消息的協議。UDP 不需要長連接，因此設置 UDP 套接字更簡單一些。另一方面，UDP 消息必須適合單個數據報（對於 IPv4，這意味著它們只能容納 65,507 個字節，因為 65,535 字節的數據包也包含頭信息）並且不能保證傳送與 TCP 一樣可靠。</p><p>服務端</p><p>由於沒有連接本身，服務器不需要監聽和接收連接。它只需要 bind() 地址和端口，然後等待單個消息。</p><pre># socket_echo_server_dgram.py import socketimport sys# Create a UDP socketsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# Bind the socket to the portserver_address = ('localhost', 10000)print('starting up on {} port {}'.format(*server_address))sock.bind(server_address)while True: print('\nwaiting to receive message') data, address = sock.recvfrom(4096) print('received {} bytes from {}'.format(len(data), address)) print(data) if data: sent = sock.sendto(data, address) print('sent {} bytes back to {}'.format(sent, address))</pre><p>使用 recvfrom() 從套接字讀取消息，然後按照客戶端地址返回數據。</p><p>客戶端</p><p>UDP 客戶端與服務端類似，但不需要 bind()。它用 sendto()將消息直接發送到服務算，並用 recvfrom()接收響應。</p><pre># socket_echo_client_dgram.py import socketimport sys# Create a UDP socketsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)server_address = ('localhost', 10000)message = b'This is the message. It will be repeated.'try: # Send data print('sending {!r}'.format(message)) sent = sock.sendto(message, server_address) # Receive response print('waiting to receive') data, server = sock.recvfrom(4096) print('received {!r}'.format(data))finally: print('closing socket') sock.close()</pre><p>運行客戶端和服務端</p><p>運行服務端會產生：</p><pre>$ python3 socket_echo_server_dgram.pystarting up on localhost port 10000waiting to receive messagereceived 42 bytes from ('127.0.0.1', 57870)b'This is the message. It will be repeated.'sent 42 bytes back to ('127.0.0.1', 57870)waiting to receive message</pre><p>客戶端輸出是：</p><pre>$ python3 socket_echo_client_dgram.pysending b'This is the message. It will be repeated.'waiting to receivereceived b'This is the message. It will be repeated.'closing socket</pre><p>Unix 域套接字</p><p>從程序員的角度來看，使用 Unix 域套接字和 TCP/IP 套接字有兩個本質區別。首先，套接字的地址是文件系統上的路徑，而不是包含服務器名稱和端口的元組。其次，在套接字關閉後，在文件系統中創建的表示套接字的節點仍然存在，並且每次服務端啟動時都需要刪除。通過在設置部分進行一些更改，使之前的服務端程序支持 UDS。</p><p>創建 socket 時使用地址族 AF_UNIX。綁定套接字和管理傳入連接方式與 TCP/IP 套接字相同。</p><pre># socket_echo_server_uds.py import socketimport sysimport osserver_address = './uds_socket'# Make sure the socket does not already existtry: os.unlink(server_address)except OSError: if os.path.exists(server_address): raise# Create a UDS socketsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)# Bind the socket to the addressprint('starting up on {}'.format(server_address))sock.bind(server_address)# Listen for incoming connectionssock.listen(1)while True: # Wait for a connection print('waiting for a connection') connection, client_address = sock.accept() try: print('connection from', client_address) # Receive the data in small chunks and retransmit it while True: data = connection.recv(16) print('received {!r}'.format(data)) if data: print('sending data back to the client') connection.sendall(data) else: print('no data from', client_address) break finally: # Clean up the connection connection.close()</pre><p>還需要修改客戶端設置以使用 UDS。它應該假定套接字的文件系統節點存在，因為服務端通過綁定到該地址來創建它。發送和接收數據在 UDS 客戶端中的工作方式與之前的 TCP/IP 客戶端相同。</p><pre># socket_echo_client_uds.py import socketimport sys# Create a UDS socketsock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)# Connect the socket to the port where the server is listeningserver_address = './uds_socket'print('connecting to {}'.format(server_address))try: sock.connect(server_address)except socket.error as msg: print(msg) sys.exit(1)try: # Send data message = b'This is the message. It will be repeated.' print('sending {!r}'.format(message)) sock.sendall(message) amount_received = 0 amount_expected = len(message) while amount_received &lt; amount_expected: data = sock.recv(16) amount_received += len(data) print('received {!r}'.format(data))finally: print('closing socket') sock.close()</pre><p>程序輸出大致相同，並對地址信息進行適當更新。服務端顯示收到的消息並將其發送回客戶端。</p><pre>$ python3 socket_echo_server_uds.pystarting up on ./uds_socketwaiting for a connectionconnection fromreceived b'This is the mess'sending data back to the clientreceived b'age. It will be'sending data back to the clientreceived b' repeated.'sending data back to the clientreceived b''no data fromwaiting for a connection</pre><p>客戶端一次性發送消息，並以遞增方式接收部分消息。</p><pre>$ python3 socket_echo_client_uds.pyconnecting to ./uds_socketsending b'This is the message. It will be repeated.'received b'This is the mess'received b'age. It will be'received b' repeated.'closing socket</pre><p>權限</p><p>由於 UDS 套接字由文件系統上的節點表示，因此可以使用標準文件系統權限來控制服務端的訪問。</p><pre>$ ls -l ./uds_socketsrwxr-xr-x 1 dhellmann dhellmann 0 Aug 21 11:19 uds_socket$ sudo chown root ./uds_socket$ ls -l ./uds_socketsrwxr-xr-x 1 root dhellmann 0 Aug 21 11:19 uds_socket</pre><p>以非root用戶運行客戶端會導致錯誤，因為該進程無權打開套接字。</p><pre>$ python3 socket_echo_client_uds.pyconnecting to ./uds_socket[Errno 13] Permission denied</pre><p>父子進程之間的通信</p><p>為了在 Unix 下進行進程間通信，通過 socketpair() 函數來設置 UDS 套接字很有用。它創建了一對連接的套接字，當子進程被創建後，在父進程和子進程之間進行通信。</p><pre>import socketimport osparent, child = socket.socketpair()pid = os.fork()if pid: print('in parent, sending message') child.close() parent.sendall(b'ping') response = parent.recv(1024) print('response from child:', response) parent.close()else: print('in child, waiting for message') parent.close() message = child.recv(1024) print('message from parent:', message) child.sendall(b'pong') child.close() # output# in parent, sending message# in child, waiting for message# message from parent: b'ping'# response from child: b'pong'</pre><p>默認情況下，會創建一個 UDS 套接字，但也可以傳遞地址族，套接字類型甚至協議選項來控制套接字的創建方式。</p><p>組播</p><p>點對點連接可以處理大量通信需求，但隨著直接連接數量的增加，同時給多個接收者傳遞相同的信息變得具有挑戰性。分別向每個接收者發送消息會消耗額外的處理時間和帶寬，這對於諸如流式視頻或音頻之類的應用來說可能是個問題。使用組播一次向多個端點傳遞消息可以使效率更高。</p><p>組播消息通過 UDP 發送，因為 TCP 是一對一的通信系統。組播地址（稱為 組播組）是為組播流量保留的常規 IPv4 地址範圍（224.0.0.0到230.255.255.255）的子集。這些地址由網絡路由器和交換機專門處理，因此發送到該組的郵件可以通過 Internet 分發給已加入該組的所有收件人。</p><p>注意：某些託管交換機和路由器默認禁用組播流量。如果在使用示例程序時遇到問題，請檢查網絡硬件設置。</p><p>發送組播消息</p><p>修改上面的客戶端程序使其向組播組發送消息，然後報告它收到的所有響應。由於無法知道預期會有多少響應，因此它會使用套接字的超時值來避免在等待答案時無限期地阻塞。</p><p>套接字還需要配置消息的生存時間值（TTL）。TTL 控制接收數據包的網絡數量。使用IP_MULTICAST_TTL 和 setsockopt() 設置 TTL。默認值1表示路由器不會將數據包轉發到當前網段之外。該值最大可達 255，並且應打包為單個字節。</p><pre># socket_multicast_sender.py import socketimport structimport sysmessage = b'very important data'multicast_group = ('224.3.29.71', 10000)# Create the datagram socketsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# Set a timeout so the socket does not block# indefinitely when trying to receive data.sock.settimeout(0.2)# Set the time-to-live for messages to 1 so they do not# go past the local network segment.ttl = struct.pack('b', 1)sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, ttl)try: # Send data to the multicast group print('sending {!r}'.format(message)) sent = sock.sendto(message, multicast_group) # Look for responses from all recipients while True: print('waiting to receive') try: data, server = sock.recvfrom(16) except socket.timeout: print('timed out, no more responses') break else: print('received {!r} from {}'.format(data, server))finally: print('closing socket') sock.close()</pre><p>發件人的其餘部分看起來像 UDP 客戶端，除了它需要多個響應，因此使用循環調用 recvfrom() 直到超時。</p><p>接收組播消息</p><p>建立組播接收器的第一步是創建 UDP 套接字。創建常規套接字並綁定到端口後，可以使用setsockopt()更改IP_ADD_MEMBERSHIP選項將其添加到組播組。選項值是組播組地址的 8 字節打包表示，後跟服務端監聽流量的網絡接口，由其 IP 地址標識。在這種情況下，接收端使用 INADDR_ANY 所有接口。</p><pre># socket_multicast_receiver.py import socketimport structimport sysmulticast_group = '224.3.29.71'server_address = ('', 10000)# Create the socketsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)# Bind to the server addresssock.bind(server_address)# Tell the operating system to add the socket to# the multicast group on all interfaces.group = socket.inet_aton(multicast_group)mreq = struct.pack('4sL', group, socket.INADDR_ANY)sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)# Receive/respond loopwhile True: print('\nwaiting to receive message') data, address = sock.recvfrom(1024) print('received {} bytes from {}'.format(len(data), address)) print(data) print('sending acknowledgement to', address) sock.sendto(b'ack', address)</pre><p>接收器的主循環就像常規的 UDP 服務端一樣。</p><p>示例輸出</p><p>此示例顯示在兩個不同主機上運行的組播接收器。A地址192.168.1.13和B地址 192.168.1.14。</p><pre>[A]$ python3 socket_multicast_receiver.pywaiting to receive messagereceived 19 bytes from ('192.168.1.14', 62650)b'very important data'sending acknowledgement to ('192.168.1.14', 62650)waiting to receive message[B]$ python3 source/socket/socket_multicast_receiver.pywaiting to receive messagereceived 19 bytes from ('192.168.1.14', 64288)b'very important data'sending acknowledgement to ('192.168.1.14', 64288)waiting to receive message</pre><p>發件人正在主機上運行B。</p><pre>[B]$ python3 socket_multicast_sender.pysending b'very important data'waiting to receivereceived b'ack' from ('192.168.1.14', 10000)waiting to receivereceived b'ack' from ('192.168.1.13', 10000)waiting to receivetimed out, no more responsesclosing socket</pre><p>消息被髮送一次，並且接收到兩個傳出消息的確認，分別來自主機A和B。</p><p>發送二進制數據</p><p>套接字傳輸字節流。這些字節可以包含編碼為字節的文本消息，如前面示例中所示，或者它們也可以是由 struct 打包到緩衝區中的二進制數據。</p><p>此客戶端程序將整數，兩個字符的字符串和浮點值，編碼為可傳遞到套接字以進行傳輸的字節序列。</p><pre># socket_binary_client.py import binasciiimport socketimport structimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_address = ('localhost', 10000)sock.connect(server_address)values = (1, b'ab', 2.7)packer = struct.Struct('I 2s f')packed_data = packer.pack(*values)print('values =', values)try: # Send data print('sending {!r}'.format(binascii.hexlify(packed_data))) sock.sendall(packed_data)finally: print('closing socket') sock.close()</pre><p>在兩個系統之間發送多字節二進制數據時，重要的是要確保連接的兩端都知道字節的順序，以及如何將它們解壓回原來的結構。服務端程序使用相同的 Struct說明符來解壓縮接收的字節，以便按正確的順序還原它們。</p><pre># socket_binary_server.py import binasciiimport socketimport structimport sys# Create a TCP/IP socketsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)server_address = ('localhost', 10000)sock.bind(server_address)sock.listen(1)unpacker = struct.Struct('I 2s f')while True: print('\nwaiting for a connection') connection, client_address = sock.accept() try: data = connection.recv(unpacker.size) print('received {!r}'.format(binascii.hexlify(data))) unpacked_data = unpacker.unpack(data) print('unpacked:', unpacked_data) finally: connection.close()</pre><p>運行客戶端會產生：</p><pre>$ python3 source/socket/socket_binary_client.pyvalues = (1, b'ab', 2.7)sending b'0100000061620000cdcc2c40'closing socket</pre><p>服務端顯示它收到的值：</p><pre>$ python3 socket_binary_server.pywaiting for a connectionreceived b'0100000061620000cdcc2c40'unpacked: (1, b'ab', 2.700000047683716)waiting for a connection</pre><p>浮點值在打包和解包時會丟失一些精度，否則數據會按預期傳輸。要記住的一件事是，取決於整數的值，將其轉換為文本然後傳輸而不使用 struct 可能更高效。整數1在表示為字符串時使用一個字節，但在打包到結構中時使用四個字節。</p><p>非阻塞通信和超時</p><p>默認情況下，配置 socket 來發送和接收數據，當套接字準備就緒時會阻塞程序執行。調用send()等待緩衝區空間可用於傳出數據，調用recv()等待其他程序發送可讀取的數據。這種形式的 I/O 操作很容易理解，但如果兩個程序最終都在等待另一個發送或接收數據，則可能導致程序低效，甚至死鎖。</p><p>有幾種方法可以解決這種情況。一種是使用單獨的線程分別與每個套接字進行通信。但是，這可能會引入其他複雜的問題，即線程之間的通信。另一個選擇是將套接字更改為不阻塞的，如果尚未準備好處理操作，則立即返回。使用setblocking()方法更改套接字的阻止標誌。默認值為1，表示阻止。0表示不阻塞。如果套接字已關閉阻塞並且尚未準備好，則會引發 socket.error 錯誤。</p><p>另一個解決方案是為套接字操作設置超時時間，調用 settimeout() 函數，參數是一個浮點值，表示在確定套接字未準備好之前要阻塞的秒數。超時到期時，引發 timeout 異常。</p><p>相關文檔：</p><p>https://pymotw.com/3/socket/index.html</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>每週</a></li><li><a>一個</a></li><li><a>Python</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E9%81%8A%E6%88%B2/d444313.html alt=每週玩一個，大連這5個特色小鎮夠你文藝整個夏天~ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=http://p1.pstatp.com/large/pgc-image/15317522366386c66354dc0 style=border-radius:25px></a>
<a href=../../tw/%E9%81%8A%E6%88%B2/d444313.html title=每週玩一個，大連這5個特色小鎮夠你文藝整個夏天~>每週玩一個，大連這5個特色小鎮夠你文藝整個夏天~</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html alt=30分鐘教你搭建一個網站（一）：購買和配置服務器 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/5f26f1582a564e93bde33a7dd9448c3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac25d2d0.html title=30分鐘教你搭建一個網站（一）：購買和配置服務器>30分鐘教你搭建一個網站（一）：購買和配置服務器</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html alt=不會買服務器？一個辦法讓你輕鬆搭網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/84d9c54578de46058796824f1bcb6a9b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8be5e94.html title=不會買服務器？一個辦法讓你輕鬆搭網站>不會買服務器？一個辦法讓你輕鬆搭網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html alt=使用服務器搭建一個網站 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/63a6cc0eb4d146e0890515500c0040ca style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c811c5f7.html title=使用服務器搭建一個網站>使用服務器搭建一個網站</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html alt=做一個小型網站，服務器需要什麼配置的呢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b69aa7f.html title=做一個小型網站，服務器需要什麼配置的呢？>做一個小型網站，服務器需要什麼配置的呢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html alt=搭建一個網站，租服務器大概多少錢？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/eee4b8ad.html title=搭建一個網站，租服務器大概多少錢？>搭建一個網站，租服務器大概多少錢？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html alt=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/5e7b0005767168b2b87d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/62d46b38.html title=素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！>素描祕籍｜一個耳朵！9大知識點，360度全方位深度剖析講解示範！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html alt=一個男人每天24小時跟妻子在一起，久而久之會怎樣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8359cc22f03e478a8cdb889dcfea3f99 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/647df9c2.html title=一個男人每天24小時跟妻子在一起，久而久之會怎樣>一個男人每天24小時跟妻子在一起，久而久之會怎樣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html alt=每天一個好習慣 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RKdGgquJFM6gnc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a86d7d9.html title=每天一個好習慣>每天一個好習慣</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html alt=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/3fd8ec4e-64c1-446a-adfa-38088fb06c01 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/756b16fb.html title=奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點>奶粉寄出一個月，家人遲遲收不到，物流信息也查詢不到，事發阜陽某韻達快遞網點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html alt=又一個走上不歸路的搬磚人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf471da0a06441f88bce49b959234257 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b29ee719.html title=又一個走上不歸路的搬磚人>又一個走上不歸路的搬磚人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html alt="只需 45 秒，Python 給故宮畫一組手繪圖！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/df1bd890ffee4a439e9f5142ae42c102 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91eece92.html title="只需 45 秒，Python 給故宮畫一組手繪圖！">只需 45 秒，Python 給故宮畫一組手繪圖！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html alt=Python手繪圖瞭解一下！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/746c9e6e214b48b2a0215fc9e151cdc8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8aab963e.html title=Python手繪圖瞭解一下！>Python手繪圖瞭解一下！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html alt=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/833949926ebf49b89c5fb4075a9cffdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d6d5661.html title=多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏>多收藏一個，就少求一次人—哪些日常必備神級網站，真正值得收藏</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html alt=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/774d2f0a372f48c589ec84dd3a164dd9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cfd854c6.html title=故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）>故宮下雪了！我用Python給它畫了一組手繪圖，僅用45秒（附代碼）</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>