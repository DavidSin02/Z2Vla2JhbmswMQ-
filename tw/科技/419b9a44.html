<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>熬了7天，總結出來了Java中動態規則的實現方式 | 极客快訊</title><meta property="og:title" content="熬了7天，總結出來了Java中動態規則的實現方式 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/419b9a44.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/419b9a44.html><meta property="article:published_time" content="2020-11-14T20:59:54+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:54+08:00"><meta name=Keywords content><meta name=description content="熬了7天，總結出來了Java中動態規則的實現方式"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/419b9a44.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>熬了7天，總結出來了Java中動態規則的實現方式</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>背景</strong></h1><p style=text-align:start>業務系統在應用過程中，有時候要處理“經常變化”的部分，這部分需求可能是“業務規則”，也可能是“不同的數據處理邏輯”，這部分動態規則的問題，往往需要可配置，並對性能和實時性有一定要求。</p><p style=text-align:start>Java不是解決動態層問題的理想語言，在實踐中發現主要有以下幾種方式可以實現：</p><ul><li>表達式語言（expression language）</li><li>動態語言（dynamic/script language language），如Groovy</li><li>規則引擎（rule engine）</li></ul><h1 class=pgc-h-arrow-right><strong>表達式語言</strong></h1><p style=text-align:start>Java Unified Expression Language，簡稱JUEL，是一種特殊用途的編程語言，主要在Java Web應用程序用於將表達式嵌入到web頁面。Java規範制定者和Java Web領域技術專家小組制定了統一的表達式語言。JUEL最初包含在JSP 2.1規範JSR-245中，後來成為Java EE 7的一部分，改在JSR-341中定義。</p><p style=text-align:start>主要的開源實現有：OGNL ，MVEL ，SpEL，JUEL，Java Expression Language (JEXL)，JEval，Jakarta JXPath 等。</p><p style=text-align:start>這裡主要介紹在實踐中使用較多的MVEL、OGNL和SpEL。</p><p style=text-align:start><strong>OGNL(Object Graph Navigation Library)</strong></p><p style=text-align:start>在Struts 2 的標籤庫中都是使用OGNL表達式訪問ApplicationContext中的對象數據，簡單示例：</p><pre><code>Foo foo = new Foo();foo.setName(&#34;test&#34;);Map&lt;String, Object&gt; context = new HashMap&lt;String, Object&gt;();context.put(&#34;foo&#34;,foo);String expression = &#34;foo.name == &#39;test&#39;&#34;;try {    Boolean result = (Boolean) Ognl.getValue(expression,context);    System.out.println(result);} catch (OgnlException e) {    e.printStackTrace();}</code></pre><p style=text-align:start><strong>MVEL</strong></p><p style=text-align:start>MVEL最初作為Mike Brock創建的 Valhalla項目的表達式計算器（expression evaluator），相比最初的OGNL、JEXL和JUEL等項目，而它具有遠超它們的性能、功能和易用性 - 特別是集成方面。它不會嘗試另一種JVM語言，而是著重解決嵌入式腳本的問題。</p><p style=text-align:start>MVEL主要使用在Drools，是Drools規則引擎不可分割的一部分。</p><p style=text-align:start>MVEL語法較為豐富，不僅包含了基本的屬性表達式，布爾表達式，變量複製和方法調用，還支持函數定義，詳情參見MVEL Language Guide 。</p><p style=text-align:start>MVEL在執行語言時主要有解釋模式（Interpreted Mode）和編譯模式（Compiled Mode ）兩種：</p><ul><li>解釋模式（Interpreted Mode）是一個無狀態的，動態解釋執行，不需要負載表達式就可以執行相應的腳本。</li><li>編譯模式（Compiled Mode）需要在緩存中產生一個完全規範化表達式之後再執行。</li></ul><pre><code>//解釋模式Foo foo = new Foo();foo.setName(&#34;test&#34;);Map context = new HashMap();String expression = &#34;foo.name == &#39;test&#39;&#34;;VariableResolverFactory functionFactory = new MapVariableResolverFactory(context);context.put(&#34;foo&#34;,foo);Boolean result = (Boolean) MVEL.eval(expression,functionFactory);System.out.println(result);//編譯模式Foo foo = new Foo();foo.setName(&#34;test&#34;);Map context = new HashMap();String expression = &#34;foo.name == &#39;test&#39;&#34;;VariableResolverFactory functionFactory = new MapVariableResolverFactory(context);context.put(&#34;foo&#34;,foo);Serializable compileExpression = MVEL.compileExpression(expression);Boolean result = (Boolean) MVEL.executeExpression(compileExpression, context, functionFactory);</code></pre><p style=text-align:start><strong>SpEL</strong></p><p style=text-align:start>SpEl(Spring表達式語言）是一個支持查詢和操作運行時對象導航圖功能的強大的表達式語言。 它的語法類似於傳統EL，但提供額外的功能，最出色的就是函數調用和簡單字符串的模板函數。SpEL類似於Struts2x中使用的OGNL表達式語言，能在運行時構建複雜表達式、存取對象圖屬性、對象方法調用等等，並且能與Spring功能完美整合，如能用來配置Bean定義。</p><p style=text-align:start>SpEL主要提供基本表達式、類相關表達式及集合相關表達式等，詳細參見Spring 表達式語言 (SpEL) 。</p><p style=text-align:start>類似與OGNL，SpEL具有expression(表達式)，Parser（解析器），EvaluationContext(上下文）等基本概念；類似於MVEL，SpEl也提供瞭解釋模式和編譯模式兩種運行模式。</p><pre><code>//解釋器模式Foo foo = new Foo();foo.setName(&#34;test&#34;);// Turn on:// - auto null reference initialization// - auto collection growingSpelParserConfiguration config = new SpelParserConfiguration(true,true);ExpressionParser parser = new SpelExpressionParser(config);String expressionStr = &#34;#foo.name == &#39;test&#39;&#34;;StandardEvaluationContext context = new StandardEvaluationContext();context.setVariable(&#34;foo&#34;,foo);Expression expression = parser.parseExpression(expressionStr);Boolean result = expression.getValue(context,Boolean.class);//編譯模式config = new SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, RunSpel.class.getClassLoader());parser = new SpelExpressionParser(config);context = new StandardEvaluationContext();context.setVariable(&#34;foo&#34;,foo);expression = parser.parseExpression(expressionStr);result = expression.getValue(context,Boolean.class);</code></pre><h1 class=pgc-h-arrow-right>規則引擎</h1><p style=text-align:start>一些規則引擎（rule engine）：aviator，easy-rules，drools，esper, siddhi</p><p style=text-align:start><strong>aviator</strong></p><p style=text-align:start>AviatorScript 是一門高性能、輕量級寄宿於 JVM 之上的腳本語言。</p><p style=text-align:start>使用場景包括：</p><ol start=1><li>規則判斷及規則引擎</li><li>公式計算</li><li>動態腳本控制</li><li>集合數據 ELT 等</li></ol><pre><code>public class Test {   public static void main(String[] args) {       String expression = &#34;a+(b-c)&gt;100&#34;;       // 編譯表達式       Expression compiledExp = AviatorEvaluator.compile(expression);       Map&lt;String, Object&gt; env = new HashMap&lt;&gt;();       env.put(&#34;a&#34;, 100.3);       env.put(&#34;b&#34;, 45);       env.put(&#34;c&#34;, -199.100);       // 執行表達式       Boolean result = (Boolean) compiledExp.execute(env);       System.out.println(result);   }}</code></pre><p style=text-align:start><strong>easy-rules</strong></p><p style=text-align:start>Easy Rules is a Java rules engine。</p><p style=text-align:start>使用POJO定義規則：</p><pre><code>@Rule(name = &#34;weather rule&#34;, description = &#34;if it rains then take an umbrella&#34;)public class WeatherRule {    @Condition    public boolean itRains(@Fact(&#34;rain&#34;) boolean rain) {        return rain;    }        @Action    public void takeAnUmbrella() {        System.out.println(&#34;It rains, take an umbrella!&#34;);    }}Rule weatherRule = new RuleBuilder()        .name(&#34;weather rule&#34;)        .description(&#34;if it rains then take an umbrella&#34;)        .when(facts -&gt; facts.get(&#34;rain&#34;).equals(true))        .then(facts -&gt; System.out.println(&#34;It rains, take an umbrella!&#34;))        .build();</code></pre><p style=text-align:start>支持使用表達式語言（MVEL/SpEL）來定義規則：</p><p style=text-align:start>weather-rule.yml example:</p><pre><code>name: &#34;weather rule&#34;description: &#34;if it rains then take an umbrella&#34;condition: &#34;rain == true&#34;actions:  - &#34;System.out.println(\&#34;It rains, take an umbrella!\&#34;);&#34;</code></pre><pre><code>MVELRuleFactory ruleFactory = new MVELRuleFactory(new YamlRuleDefinitionReader());Rule weatherRule = ruleFactory.createRule(new FileReader(&#34;weather-rule.yml&#34;));</code></pre><p style=text-align:start>觸發規則：</p><pre><code>public class Test {    public static void main(String[] args) {        // define facts        Facts facts = new Facts();        facts.put(&#34;rain&#34;, true);        // define rules        Rule weatherRule = ...        Rules rules = new Rules();        rules.register(weatherRule);        // fire rules on known facts        RulesEngine rulesEngine = new DefaultRulesEngine();        rulesEngine.fire(rules, facts);    }}</code></pre><p style=text-align:start><strong>drools</strong></p><p style=text-align:start>An open source rule engine, DMN engine and complex event processing (CEP) engine for Java and the JVM Platform.</p><p style=text-align:start>定義規則：</p><pre><code>import com.lrq.wechatDemo.domain.User   // 導入類dialect  &#34;mvel&#34;rule &#34;age&#34;    // 規則名，唯一    when        $user : User(age&lt;15 || age&gt;60)  //規則的條件部分    then        System.out.println(&#34;年齡不符合要求！&#34;);end</code></pre><p style=text-align:start>參考例子：</p><pre><code>public class TestUser {    private static KieContainer container = null;    private KieSession statefulKieSession = null;    @Test    public void test(){        KieServices kieServices = KieServices.Factory.get();        container = kieServices.getKieClasspathContainer();        statefulKieSession = container.newKieSession(&#34;myAgeSession&#34;);        User user = new User(&#34;duval yang&#34;,12);        statefulKieSession.insert(user);        statefulKieSession.fireAllRules();        statefulKieSession.dispose();    }}</code></pre><p style=text-align:start>drools是比較重的規則引擎，有自己的狀態存儲，詳見其官方文檔。</p><p style=text-align:start><strong>esper</strong></p><p style=text-align:start>Esper is a component for complex event processing (CEP), streaming SQL and event series analysis, available for Java as Esper, and for .NET as NEsper.</p><p style=text-align:start>一個例子：</p><pre><code>public class Test {    public static void main(String[] args) throws InterruptedException {        EPServiceProvider epService = EPServiceProviderManager.getDefaultProvider();         EPAdministrator admin = epService.getEPAdministrator();         String product = Apple.class.getName();        String epl = &#34;select avg(price) from &#34; + product + &#34;.win:length_batch(3)&#34;;         EPStatement state = admin.createEPL(epl);        state.addListener(new AppleListener());         EPRuntime runtime = epService.getEPRuntime();         Apple apple1 = new Apple();        apple1.setId(1);        apple1.setPrice(5);        runtime.sendEvent(apple1);         Apple apple2 = new Apple();        apple2.setId(2);        apple2.setPrice(2);        runtime.sendEvent(apple2);         Apple apple3 = new Apple();        apple3.setId(3);        apple3.setPrice(5);        runtime.sendEvent(apple3);    }}</code></pre><p style=text-align:start><strong>siddhi</strong></p><p style=text-align:start>Siddhi is a cloud native <em>Streaming</em> and <em>Complex Event Processing</em> engine that understands Streaming SQL queries in order to capture events from diverse data sources, process them, detect complex conditions, and publish output to various endpoints in real time.</p><p style=text-align:start>For example:</p><pre><code>package io.siddhi.sample;import io.siddhi.core.SiddhiAppRuntime;import io.siddhi.core.SiddhiManager;import io.siddhi.core.event.Event;import io.siddhi.core.stream.input.InputHandler;import io.siddhi.core.stream.output.StreamCallback;import io.siddhi.core.util.EventPrinter;/** * The sample demonstrate how to use Siddhi within another Java program. * This sample contains a simple filter query. */public class SimpleFilterSample {    public static void main(String[] args) throws InterruptedException {        // Create Siddhi Manager        SiddhiManager siddhiManager = new SiddhiManager();        //Siddhi Application        String siddhiApp = &#34;&#34; +                &#34;define stream StockStream (symbol string, price float, volume long); &#34; +                &#34;&#34; +                &#34;@info(name = &#39;query1&#39;) &#34; +                &#34;from StockStream[volume &lt; 150] &#34; +                &#34;select symbol, price &#34; +                &#34;insert into OutputStream;&#34;;        //Generate runtime        SiddhiAppRuntime siddhiAppRuntime = siddhiManager.createSiddhiAppRuntime(siddhiApp);        //Adding callback to retrieve output events from stream        siddhiAppRuntime.addCallback(&#34;OutputStream&#34;, new StreamCallback() {            @Override            public void receive(Event[] events) {                EventPrinter.print(events);                //To convert and print event as a map                //EventPrinter.print(toMap(events));            }        });        //Get InputHandler to push events into Siddhi        InputHandler inputHandler = siddhiAppRuntime.getInputHandler(&#34;StockStream&#34;);        //Start processing        siddhiAppRuntime.start();        //Sending events to Siddhi        inputHandler.send(new Object[]{&#34;IBM&#34;, 700f, 100L});        inputHandler.send(new Object[]{&#34;WSO2&#34;, 60.5f, 200L});        inputHandler.send(new Object[]{&#34;GOOG&#34;, 50f, 30L});        inputHandler.send(new Object[]{&#34;IBM&#34;, 76.6f, 400L});        inputHandler.send(new Object[]{&#34;WSO2&#34;, 45.6f, 50L});        Thread.sleep(500);        //Shutdown runtime        siddhiAppRuntime.shutdown();        //Shutdown Siddhi Manager        siddhiManager.shutdown();    }}</code></pre><p style=text-align:start>esper和siddhi都是streaming process，支持CEP和SQL，詳見其官方文檔。</p><h1 class=pgc-h-arrow-right><strong>動態JVM語言</strong></h1><p style=text-align:start><strong>Groovy</strong></p><p style=text-align:start>Groovy除了Gradle 上的廣泛應用之外，另一個大範圍的使用應該就是結合Java使用動態代碼了。Groovy的語法與Java非常相似，以至於多數的Java代碼也是正確的Groovy代碼。Groovy代碼動態的被編譯器轉換成Java字節碼。由於其運行在JVM上的特性，Groovy可以使用其他Java語言編寫的庫。</p><p style=text-align:start>Groovy可以看作給Java靜態世界補充動態能力的語言，同時Groovy已經實現了java不具備的語言特性：</p><ul><li>函數字面值；</li><li>對集合的一等支持；</li><li>對正則表達式的一等支持；</li><li>對xml的一等支持；</li></ul><p style=text-align:start>Groovy作為基於JVM的語言，與表達式語言存在語言級的不同，因此在語法上比表達還是語言更靈活。Java在調用Groovy時，都需要將Groovy代碼編譯成Class文件。</p><p style=text-align:start>Groovy 可以採用GroovyClassLoader、GroovyShell、GroovyScriptEngine和JSR223 等方式與Java語言集成。</p><p style=text-align:start>一個使用GroovyClassLoader動態對json對象進行filter的例子：</p><pre><code>public class GroovyFilter implements Filter {    private static String template =  &#34;&#34; +            &#34;package com.alarm.eagle.filter;&#34; +            &#34;import com.fasterxml.jackson.databind.node.ObjectNode;&#34; +            &#34;def match(ObjectNode o){[exp]}&#34;;    private static String method = &#34;match&#34;;    private String filterExp;    private transient GroovyObject filterObj;    public GroovyFilter(String filterExp) throws Exception {        ClassLoader parent = Thread.currentThread().getContextClassLoader();        GroovyClassLoader classLoader = new GroovyClassLoader(parent);        Class clazz = classLoader.parseClass(template.replace(&#34;[exp]&#34;, filterExp));        filterObj = (GroovyObject)clazz.newInstance();    }    public boolean filter(ObjectNode objectNode) {        return (boolean)filterObj.invokeMethod(method, objectNode);    }}</code></pre><p style=text-align:start>Java每次調用Groovy代碼都會將Groovy編譯成Class文件，因此在調用過程中會出現JVM級別的問題。如使用GroovyShell的parse方法導致perm區爆滿的問題，使用GroovyClassLoader加載機制導致頻繁gc問題和CodeCache用滿，導致JIT禁用問題等，相關問題可以參考Groovy與Java集成常見的坑 。</p><hr><p>關注我，私信回覆【<strong>資料</strong>】即可領取視頻中java相關資料以及一份227頁最新的bat大廠面試寶典</p><h1 class=pgc-h-arrow-right>最後</h1><p style=text-align:start>歡迎大家一起交流，喜歡文章記得關注我點個贊喲，感謝支持！</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>總結</a></li><li><a>出來</a></li><li><a>Java</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a1b27915.html alt=Java總結之容器家族--Collection class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88ce4e8325964ee3aac0b015656a3c73 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a1b27915.html title=Java總結之容器家族--Collection>Java總結之容器家族--Collection</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e7b89313.html alt=十年程序員總結：Java之集合Collection總覽 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/ff7018c5f0c247fe9e1065846beba6f0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e7b89313.html title=十年程序員總結：Java之集合Collection總覽>十年程序員總結：Java之集合Collection總覽</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc35e6bd.html alt=一文總結Java中原子類相關實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2dfc593b3b104a499d6d736518072928 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc35e6bd.html title=一文總結Java中原子類相關實現>一文總結Java中原子類相關實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html alt=從域名到網站，只需要四步！服務器網站搭建流程總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7c1999b5072844f6ac01ba234e4d4ee0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3afd140e.html title=從域名到網站，只需要四步！服務器網站搭建流程總結>從域名到網站，只需要四步！服務器網站搭建流程總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html alt=住宅工程各區域的淨高要求，總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/072079da-ec32-43b6-9dff-93cc7beb2bc3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/56464415.html title=住宅工程各區域的淨高要求，總結>住宅工程各區域的淨高要求，總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html alt=住宅工程各區域的淨高要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/27a44170db2040adab26236e40605b1c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e212faff.html title=住宅工程各區域的淨高要求，總結！>住宅工程各區域的淨高要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html alt=住宅工程各類淨高的規範要求，總結！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cff80b0991246f69fb67d91590b1d95 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96a296c9.html title=住宅工程各類淨高的規範要求，總結！>住宅工程各類淨高的規範要求，總結！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html alt=初三主要化學方程式按元素歸類總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fcca062886ed4b9db272cb3cb66710e6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/829c8b89.html title=初三主要化學方程式按元素歸類總結>初三主要化學方程式按元素歸類總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html alt=按照元素分類總結的高中化學方程式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/568b4c62f05c406c86ba3a1a3f1536f3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0df71847.html title=按照元素分類總結的高中化學方程式>按照元素分類總結的高中化學方程式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>