<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>百度和好未來的面試官把我榨乾了 | 极客快訊</title><meta property="og:title" content="百度和好未來的面試官把我榨乾了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/27a2a1dbff764465a2cd291e9de96c07"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42daa8e0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42daa8e0.html><meta property="article:published_time" content="2020-11-14T21:05:38+08:00"><meta property="article:modified_time" content="2020-11-14T21:05:38+08:00"><meta name=Keywords content><meta name=description content="百度和好未來的面試官把我榨乾了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/42daa8e0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>百度和好未來的面試官把我榨乾了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right>百度和好未來的面試官把我榨乾了</h1><blockquote><p>非常榮幸地成為百度的RD。</p></blockquote><blockquote><p>2019年最後一個月，由於當時的東家當時業務成績不是很出色，漲薪變得困難，所以當時決定抽出時間學習然後出去探探風，遂整理簡歷並高效學習，同時在求職APP上有針對性的投遞簡歷，沒想到第一週就有面試電話打了過來，於是請了一週年假，準備開始面試。</p></blockquote><blockquote><p>一週時間一共面試了三家公司，沒想到三家公司全都拿到了offer，除了一家上海的企業漲幅沒有達到預期外，百度和好未來均給了讓我很心動的價格。</p></blockquote><blockquote><p>本文只介紹技術相關的題目，至於前期學習和準備以及非技術問題後續我會後續為大家帶來，敬請關注更新。</p></blockquote><blockquote><p>更多好文章敬請關注全棧道路。</p></blockquote><h1 class=pgc-h-arrow-right>百度面試題目</h1><blockquote><p>百度的面試加上電話面試共進行了六輪(一輪技術電話面試+三輪當場技術面試+兩輪招聘行政面試)</p></blockquote><blockquote><p>百度的面試題目都是基礎型題目，沒有太偏的，但是面試官會抓住一個點往深層次問</p></blockquote><h1 class=pgc-h-arrow-right>電話面試</h1><h1 class=pgc-h-arrow-right>​之前接觸過動畫交互與過渡屬性嗎？用到什麼程度？講一講實際使用場景</h1><blockquote><p>作為一個前端er，切圖和交互自然是基礎中的基礎，信手拈來。</p></blockquote><ul class=list-paddingleft-2><li>經常使用，交互實現在我的開發習慣裡是能用原生css實現就用原生。</li><li>比如一些hover操作需要淡進淡出，就需要用 transation 和 opacity 相結合去實現。</li><li>還有一些窗口的抖動可以通過 animation 去實現，設定 keyframes 關鍵幀。</li><li>加入購物車的動畫可能需要結合 JS 去判斷飛入和飛出的相對位置，利用 transform: translate(x,y) 進行位置的變化，然後通過 transition : transform 0.8s linear 去控制動態飛入的時間和速度曲線，當然這些屬性的出發都需要動態去添加。</li><li>說到這裡面試官打斷了我，可能覺得說的差不多了，無情~</li></ul><h1 class=pgc-h-arrow-right>H5的具體場景部分動畫實現</h1><blockquote><p>這部分面試官問了一些具體場景下動態交互的實現，應該都是百度部分業務用到的。其實核心還是第一個問題中的部分屬性，這裡不再贅述。</p></blockquote><h1 class=pgc-h-arrow-right>製作橫向滑動收起的動畫時有沒有碰到一些問題？</h1><ul class=list-paddingleft-2><li>橫向滑動收起如果使用 display: none; 去控制顯示隱藏的時候會出現動畫的不連貫和抖動，解決方式就是就是通過位置去視覺上的隱藏，利用定位將動畫的 DOM 藏在屏幕之外。</li></ul><h1 class=pgc-h-arrow-right>animation屬性縮寫狀態下值分別代表什麼？第四個呢？</h1><blockquote><p>這裡面試官一開始沒問前幾個，我就把經常用的前三個說了，然後追問的第四個屬性值，好在我還記得。</p></blockquote><ul class=list-paddingleft-2><li>animation: 動畫名稱 持續時間 速度函數 延遲時間</li></ul><h1 class=pgc-h-arrow-right>如何畫 1PX 的線</h1><ul class=list-paddingleft-2><li>因為屏幕的分辨率和瀏覽器的的分辨率存在換算關係，所以1像素的線在屏幕上會佔用2個或者2個以上視覺像素，這點在移動端尤其明顯。</li><li>解決方案：</li></ul><pre><code>// 解決方案有很多種，這裡僅給出我經常使用的使用偽類解決.outer {	position: relative;}.outer:before {	display: block;	content: '';	position: absolute;	left: 0;	top: 0;	width: 200%;	height: 1px;	tansform: scale(0.5);	tansform-origin: 0 0;	background: #f5f5f5;}</code></pre><h1 class=pgc-h-arrow-right>說一下深拷貝和淺拷貝及常用實現方式</h1><ul class=list-paddingleft-2><li>淺拷貝: 以賦值的形式拷貝引用對象，仍指向同一個地址，修改時原對象也會受到影響</li><ul class=list-paddingleft-2><li>賦值表達式 =</li><li>Object.assign</li><li>展開運算符(...)</li></ul><li>深拷貝: 完全拷貝一個新對象，修改時原對象不再受到任何影響</li><ul class=list-paddingleft-2><li>JSON.parse(JSON.stringify(obj))</li><li>遞歸進行逐一賦值</li></ul></ul><h1 class=pgc-h-arrow-right>追問：使用JSON自帶函數進行深拷貝有什麼問題</h1><ul class=list-paddingleft-2><li>具有循環引用的對象時，報錯</li><li>當值為函數或 undefined 時，無法拷貝</li></ul><h1 class=pgc-h-arrow-right>用戶從瀏覽器輸入地址到看到頁面發生了什麼</h1><p>由於是電話面試，當時心想說多了面試官也沒心情聽，只要把關鍵的節點都說出來就好。後來去百度面對面面試的時候面試官又問了一遍這個問題，然後追問了很多。</p><ul class=list-paddingleft-2><li>檢查緩存</li><ul class=list-paddingleft-2><li>DNS 緩存</li><li>頁面緩存</li></ul><li>網絡請求</li><ul class=list-paddingleft-2><li>DNS域名解析</li><li>建立TCP連接(三次握手機制、四次握手機制(HTTPS安全協議下))</li><li>發送HTTP請求</li><li>接收響應</li></ul><li>解析頁面</li><ul class=list-paddingleft-2><li>構建DOM樹</li><li>樣式計算</li><li>生成佈局樹</li></ul><li>渲染過程</li><ul class=list-paddingleft-2><li>建立圖層樹</li><li>生成繪製列表</li><li>生成圖塊、位圖</li><li>顯示內容</li></ul></ul><h1 class=pgc-h-arrow-right>部分特定情況下的性能優化</h1><blockquote><p>性能優化是前端面試中必問的題目，這部分前期寫過三篇專門的文章，分成三個方面講述性能優化問題，可以點擊鏈接查看，這次面試中問到的題目在文章中都有解決方案</p></blockquote><ul class=list-paddingleft-2><li>[前端性能優化]HTML、CSS、JS部分(https://github.com/programmer-zhang/front-end)</li><li>[前端性能優化]頁面加載速度優化(https://github.com/programmer-zhang/front-end)</li><li>[前端性能優化]網絡傳輸層優化(https://github.com/programmer-zhang/front-end)</li></ul><blockquote><p>以上電話面試的內容就結束了，約定了三天後去百度面試。雖然問題不多，但是經歷了近一個小時，想到問了很多關於動態交互和性能優化的題目，猜測部門應該面向用戶，而且量級不小，所以後續在複習中專門鞏固了相關的內容。</p></blockquote><blockquote><p>事實證明自己沒有猜錯，入職之後發現業務全是面向用戶，而且日活上億。</p></blockquote><blockquote><p>這裡給大家一點建議，除了針對招聘信息上的招聘要求針對性複習之外，如果能夠在面試前和面試官有交流，可以問一下具體是什麼業務部門，這樣可以提前猜測一下面試會針對哪些方面。</p></blockquote><blockquote><p>電話面試之後我就傻啦吧唧忘了問了，幸好還能猜測出部分針對性問題。</p></blockquote><h1 class=pgc-h-arrow-right>百度一面</h1><h1 class=pgc-h-arrow-right>自我介紹以及之前工作流程和模式</h1><blockquote><p>這裡面試官估計想了解以前的工作狀態，是否是一個公認的合理的開發和工作模式，從實習到百度，經歷告訴我，不同量級不同類型的公司在這方面差別很大，同時也能反映出之前的公司技術水平和能力，從而面試官判斷對面的人是否能夠和自己愉快的進行合作開發。</p></blockquote><blockquote><p>也可能是我想多了，就是簡單問問，減輕點被面試者的壓力</p></blockquote><h1 class=pgc-h-arrow-right>一個基本的語義化佈局的頁面你想怎麼規劃</h1><blockquote><p>這個問題說實話沒明白想問啥，難不成只是想問語義化？這麼簡單？</p></blockquote><ul class=list-paddingleft-2><li>主體框架(簡單的瀑布流佈局)</li></ul><pre><code>&lt;nav&gt;&lt;/nav&gt;	&lt;header&gt;&lt;/header&gt;	&lt;main&gt;		&lt;section&gt;&lt;/section&gt;		&lt;section&gt;&lt;/section&gt;	&lt;/main&gt;&lt;footer&gt;&lt;/footer&gt;</code></pre><h1 class=pgc-h-arrow-right>CSS上有沒有什麼書寫注意點或者可優化的角度</h1><blockquote><p>說了這個問題我明白了，這是讓我說一說在基礎層面的頁面優化方向，只不過把大問題分化成細節了</p></blockquote><blockquote><p>[前端性能優化]HTML、CSS、JS部分(https://github.com/programmer-zhang/front-end)</p></blockquote><ul class=list-paddingleft-2><li>能用html/css解決的問題就不要用js</li><ul class=list-paddingleft-2><li>比如hover顯示隱藏</li><li>比如導航高亮</li><li>自定義原始樣式</li><li>巧用偽類解決問題</li><li>使用預編譯器</li></ul><li>不濫用高消耗的樣式</li><li>選擇器合併</li><li>0值去單位，小於1的值去掉0</li></ul><h1 class=pgc-h-arrow-right>使用Float進行佈局容易產生什麼問題？解決方式呢？</h1><ul class=list-paddingleft-2><li>子元素在設置 float 後會脫離文檔流，造成父元素高度塌陷</li><li>解決方式：</li><ul class=list-paddingleft-2><li>父元素設置高度</li><li>清除浮動</li></ul></ul><pre><code>// test.html&lt;div class="outter"&gt;	&lt;div class="inner"&gt;&lt;/div&gt;	&lt;div style="clear: both;"&gt;&lt;/div&gt;&lt;/div&gt;// test.css.outter { width:200px; background:#3FF; border:1px solid #000;}.inner { float:left; width:120px; height:80px; background:#FF3; }</code></pre><h1 class=pgc-h-arrow-right>簡單說幾種垂直水平居中的方式</h1><ul class=list-paddingleft-2><li>固定寬高</li></ul><pre><code>// test.html &lt;div class="outer"&gt;	&lt;div class="inner"&gt;		inner-box	&lt;/div&gt;&lt;/div&gt;// test.css.outer {	width: 500px;	height: 300px;}.inner {    width: 100px;    height: 100px;    background-color: red;    color: #fff;}// 1. position absolute + 負margin.outer {	position: relative;}.inner {	position: absolute;	top: 50%;	left: 50%;	margin-top: -50px; // 子元素高度一半	margin-left: -50px; // 子元素寬度一半}// 2. position absolute + calc.outer {	position: relative;}.inner {	position: absolute;	top: calc(50% - 50px);	left: calc(50% - 50px);}// 3. position absolute + margin auto.outer {	position: relative;}.inner {	position: absolute;	top: 0;	left: 0;	right: 0;	bottom: 0;	margin: auto;}</code></pre><ul class=list-paddingleft-2><li>不固定寬高</li></ul><pre><code>// test.html &lt;div class="outer"&gt;	&lt;div class="inner"&gt;		inner-box	&lt;/div&gt;&lt;/div&gt;// test.css// 1. flex佈局.outer {  display: flex;  justify-content: center;  align-items: center;}// 2. position absolute + transform.container {	position: relative;}.box-center {	position: absolute;	top: 50%;	left: 50%;	transform: translate(-50%, -50%);}// 3. css-table.outer {	display: table-cell;	text-align: center;	vertical-align: middle;}.inner {	display: inline-block;}// 4. grid佈局.outer {	display: grid;	justify-items: center;	align-items: center;}.inner {	text-align: center;}</code></pre><h1 class=pgc-h-arrow-right>盒子模型</h1><ul class=list-paddingleft-2><li>box-sizing: content-box（W3C盒子模型）：元素的寬高大小表現為內容的大小。</li><li>box-sizing: border-box（IE盒子模型）：元素的寬高表現為內容 + 內邊距 + 邊框的大小。背景會延伸到邊框的外沿。</li></ul><h1 class=pgc-h-arrow-right>什麼情況下回發生迴流和重繪</h1><ul class=list-paddingleft-2><li>迴流</li><ul class=list-paddingleft-2><li>頁面一開始渲染</li><li>顯示隱藏元素</li><li>瀏覽器窗口變化</li><li>元素位置變化</li><li>元素尺寸變化</li></ul><li>重繪</li><ul class=list-paddingleft-2><li>樣式改變不影響元素的位置時，比如 color、background，當然還有visiability</li></ul></ul><h1 class=pgc-h-arrow-right>追問：迴流和重繪的關係是什麼樣的</h1><ul class=list-paddingleft-2><li>重繪不一定會發生迴流</li><li>迴流一定觸發重繪</li></ul><h1 class=pgc-h-arrow-right>追問：怎麼避免迴流產生</h1><ul class=list-paddingleft-2><li>避免多級嵌套</li><li>避免使用內聯樣式</li><li>避免使用計算樣式</li><li>儘量少的使用JS去操作DOM結構</li><li>使用CSS3屬性以被動啟動GPU加速</li></ul><h1 class=pgc-h-arrow-right>事件委託</h1><ul class=list-paddingleft-2><li>詳細的原理要從DOM的事件機制說起：捕獲事件階段、冒泡事件階段、目標時間階段</li><li>事件委託是利用冒泡機制來實現的，可以減少內存消耗，減少註冊事件。</li></ul><h1 class=pgc-h-arrow-right>平常開發遇到涉及數組遍歷或對象遍歷問題都是用什麼方式</h1><blockquote><p>這裡說的可能不是很全，記得之前閱讀過一篇全面分析各種循環方式的文章，找到後再為大家總結一遍，敬請關注。</p></blockquote><ul class=list-paddingleft-2><li>對象循環</li><ul class=list-paddingleft-2><li>for...in 遍歷</li><li>Object.keys(Object),創建包含對象屬性的數組</li><li>Object.values(Object),創建包含對象值的數組</li><li>Object.getOwnPropertyNames(Object),返回一個數組，包含對象自身的所有屬性（包含不可枚舉屬性）</li><li>Object.entries(Object),創建了一個二維數組，每個內部數組都有兩個元素，第一個元素是屬性名，第二個屬性值</li></ul><li>數組循環</li><ul class=list-paddingleft-2><li>基本的 for</li><li>forEach</li><li>map</li><li>for...of</li><li>使用ES6 filter()，some(), every()進行業務查找和篩選</li></ul></ul><h1 class=pgc-h-arrow-right>追問：map和forEach的共同點和區別</h1><ul class=list-paddingleft-2><li>共同點</li><ul class=list-paddingleft-2><li>都是遍歷數組</li><li>都支持三個參數，item（當前每一項），index（索引值），arr（原數組）</li></ul><li>區別</li><ul class=list-paddingleft-2><li>map()會分配內存空間存儲新數組並返回, forEach()不會返回數據</li><li>forEach()允許callback更改原始數組的元素, map()返回新的數組</li></ul></ul><h1 class=pgc-h-arrow-right>追問：普通for循環和forEach的區別</h1><blockquote><p>這裡一開始沒明白面試官想要問啥，答了forEach更加簡潔一些，普通for循環針對大量級數據性能更好，然後面試官直接說在跳出循環上說一下，才明白要問的，這裡提醒大家，如果沒弄明白想問啥，一定要問清楚</p></blockquote><ul class=list-paddingleft-2><li>for 循環可以通過 break，continue， return 跳出循環</li><li>forEach 不能使用上述跳出方式，可以採用 try...catch 的寫法，扔出一個 Error 跳出循環</li></ul><h1 class=pgc-h-arrow-right>追問：剛才說到 for...in 循環對象，有沒有碰到什麼疑惑或者問題，怎麼解決的</h1><ul class=list-paddingleft-2><li>遍歷的是原型鏈中的數據，需要使用 hasOwnProperty 看是否屬於該對象。</li></ul><h1 class=pgc-h-arrow-right>追問：既然說到原型了，講講你理解的原型和原型鏈吧</h1><blockquote><p>從循環的問題追問到原型，我可太南了</p></blockquote><h1 class=pgc-h-arrow-right>簡單講</h1><ul class=list-paddingleft-2><li>每一個函數都有一個prototype對象屬性，指向另一個對象(原型鏈上面的)</li><li>prototype就是調用構造函數所創建的那個實例對象的原型(proto)</li><li>實例對象與原型之間的連接，叫做原型鏈</li></ul><h1 class=pgc-h-arrow-right>展開講</h1><blockquote><p>在展開講的時候，我邊畫圖邊給面試官講的，作為技術人員嘛，充分利用各種形式展現自己的技術理解，大概就是下邊這張圖</p></blockquote><div class=pgc-img><img alt=百度和好未來的面試官把我榨乾了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/27a2a1dbff764465a2cd291e9de96c07><p class=pgc-img-caption></p></div><ul class=list-paddingleft-2><li>定義了一個函數後，天生自帶 prototype 指向函數的原型對象</li><li>函數經過new調用後，返回一個全新的實例對象，實例對象的 _proto_ 指向構造函數的原型對象</li><li>對象的 hasownproperty() 來檢查自身中是否含有該屬性</li></ul><h1 class=pgc-h-arrow-right>事件機制</h1><ul class=list-paddingleft-2><li>瀏覽器的JS引擎管理著事件代碼的調用和執行，主線程在運行時會產生執行棧，棧中的代碼調用某些異步API時會在任務隊列中添加事件，棧中的代碼執行完畢後，就會讀取任務隊列中的事件，去執行事件對應的回調函數，如此循環往復，形成事件循環機制。</li><li>整體的執行順序：宏任務 -> 微任務 -> 必要的渲染UI -> 下一輪Eventloop</li><li>通俗點的流程</li><ul class=list-paddingleft-2><li>執行一個宏任務（首次執行的主代碼塊或者任務隊列中的回調函數）</li><li>執行過程中如果遇到微任務，就將它添加到微任務的任務隊列中</li><li>宏任務執行完畢後，立即執行當前微任務隊列中的所有任務（依次執行）</li><li>JS引擎線程掛起，GUI線程執行渲染</li><li>GUI線程渲染完畢後掛起，JS引擎線程執行任務隊列中的下一個宏任務</li></ul><li>宏任務：script主代碼、setTimout、setInterval、事件I/O等</li><li>微任務：promise等</li></ul><h1 class=pgc-h-arrow-right>追問筆試題：那道經典的setTimeout題，並問什麼會這樣輸出</h1><ul class=list-paddingleft-2><li>主線程執行同步任務，也就是主循環，setTimeout 為宏任務，同時是異步任務，會被掛起到循環結束</li><li>循環結束執行 setTimeout 的回調,執行時發現 i 的當前作用域不存在，向上查找，在全局作用域中發現了 i ，此時循環已經結束，所以全都輸出同一個數</li></ul><h1 class=pgc-h-arrow-right>追問筆試題：一道結合了各種 setTimout 和 promise 的事件機制輸出題目,共有十一個輸出代碼塊</h1><blockquote><p>題目具體已經不記得了，反正記住執行順序一點一點的輸出，面試時最好帶個筆記本或者電腦，可以隨時記錄下，方便回答</p></blockquote><h1 class=pgc-h-arrow-right>HTTP請求的三次握手機制</h1><blockquote><p>三次握手機制這裡不再大篇幅展開講了，之前寫的關於性能優化的文章中有詳細的回答(https://github.com/programmer-zhang/front-end)</p></blockquote><h1 class=pgc-h-arrow-right>追問：HTTP請求為什麼是三次握手，不是兩次或者四次</h1><ul class=list-paddingleft-2><li>三次握手是確定客戶端和服務端接收和發送能力都正常的最優次數</li><ul class=list-paddingleft-2><li>第一次：客戶端發送能力正常</li><li>第二次：服務端接收能力正常，服務端發送能力正常</li><li>第三次：客戶端接收能力正常</li></ul></ul><h1 class=pgc-h-arrow-right>追問：HTTP、HTTPS的區別</h1><ul class=list-paddingleft-2><li>HTTPS更安全：http 是超文本傳輸協議，信息是明文傳輸，https 則是具有安全性的 ssl 加密傳輸協議</li><li>HTTP更簡單：http 的連接是無狀態的；HTTPS 協議是由 SSL+HTTP 協議構建的可進行加密傳輸、身份認證的網絡協議。</li></ul><h1 class=pgc-h-arrow-right>追問：關於緩存方面講一講</h1><blockquote><p>這個問題之前寫過關於緩存策略的文章，不在展開講，詳細內容請點擊(https://github.com/programmer-zhang/front-end)，讓面試官愛上你</p></blockquote><ul class=list-paddingleft-2><li>強緩存(不走服務器)：</li><ul class=list-paddingleft-2><li>Expires</li><li>Cache-Control</li></ul><li>協商緩存(走服務器):</li><ul class=list-paddingleft-2><li>Last-Modified/If-Modified-Since</li><li>ETag/If-None-Match</li></ul></ul><h1 class=pgc-h-arrow-right>追問：幾種緩存策略的對比簡單說一下</h1><blockquote><p>這個問題也在關於緩存策略的文章裡，詳細內容請點擊原文鏈接，讓面試官愛上你</p></blockquote><h1 class=pgc-h-arrow-right>前端跨域問題如何產生，有什麼方法解決</h1><blockquote><p>這裡之前寫過詳細的文章，不展開細講了，可以點擊原文鏈接查看[前端跨域看這篇就夠了]</p></blockquote><ul class=list-paddingleft-2><li>產生原因：同源策略</li><li>解決方式：</li><ul class=list-paddingleft-2><li>jsonp實現跨域請求</li><li>使用 iframe + form 進行跨域請求</li><li>CORS(跨域資源共享 Cross-origin resource sharing)進行跨域請求</li><li>利用服務器中轉</li></ul></ul><h1 class=pgc-h-arrow-right>追問：JSONP跨域有什麼特點</h1><ul class=list-paddingleft-2><li>只支持 GET 請求</li></ul><h1 class=pgc-h-arrow-right>追問：CORS進行跨域有什麼特點</h1><blockquote><p>這個追問題我回答完之後面試官說是臨時想出來的，但是他沒想到我之前看過相關的文章還整理出來了，這不是巧了麼這不是~ 這個問題的答案也在之前給出的鏈接中前端跨域文章裡</p></blockquote><ul class=list-paddingleft-2><li>CORS請求分為簡單請求和非簡單請求，區分方式是看請求頭和請求方法 (只有 GET、POST、HEAD)</li><li>簡單請求：服務端配置好的前提下，簡單請求直接請求就可以</li><li>非簡單請求：在請求時會發送兩次請求，第一次是預檢測請求，返回的狀態碼為204，第二次請求為預檢測請求通過後才會發送真實請求</li></ul><blockquote><p>問到這裡其實一面已經結束了，不過面試官看來需求不多，告訴我一面已經過了，看我是Vue技術棧，遂通過Vue又續上了，沒有問很深入的問題，都是小細節，當做聊家常了，然後我猜測二面應該會問關於Vue深層次的問題，不過我還是有點信心的，畢竟是看過源碼的人。</p></blockquote><blockquote><p>就在我寫這篇文章的收尾階段，網上發佈了關於尤雨溪和Vue的紀錄片，B站搜索 紀錄Vue.js尤雨溪 - 中英CC字幕 - Honeypot呈現 ，朋友們可以當做茶餘飯後的小片看，這裡建議大家，少看那些場景簡單，人物兩三個人，說著奇奇怪怪語言的視頻！</p></blockquote><h1 class=pgc-h-arrow-right>有沒有遇到深層次對象雙向綁定後子組件未監聽到更新的情況，怎麼解決的</h1><ul class=list-paddingleft-2><li>有</li><li>解決方式：</li><ul class=list-paddingleft-2><li>一：深層監聽 deep: true,但是這樣會帶來性能問題</li><li>二：使用 this.$set() 進行賦值</li></ul></ul><h1 class=pgc-h-arrow-right>Vue的data以Function方式返回的原因</h1><ul class=list-paddingleft-2><li>避免產生變量共享，不以返回值的情況下，所有組件將共享同一個對象，指向相同的內存地址</li></ul><h1 class=pgc-h-arrow-right>Vue的響應式怎麼做的，簡單說</h1><ul class=list-paddingleft-2><li>init 時利用 Object.defineproperty 監聽數據變化</li><li>利用 setter 和 getter 進行觸發</li></ul><blockquote><p>這裡一面算是正式結束了，面試官走的時候說回答的不錯，我去給你找個精通 Vue 的二面來，你們再聊聊。</p></blockquote><blockquote><p>一面面試官說完我瞬間感覺要爆炸，我可太南了！但是事實是二面面試官並沒有很深入的問，而是讓我自己說，他從中問一些細節。後來才知道，百度有個業務組的領導是Vue的核心開發者，大家都很熟悉Vue。</p></blockquote><h1 class=pgc-h-arrow-right>百度二面</h1><h1 class=pgc-h-arrow-right>結合頁面加載流程流程詳細說下過程中的性能優化</h1><blockquote><p>這個問題就比較細節化，可以參考原文鏈接中關於性能優化的文章，基本的優化方案裡邊都有，前端性能優化</p></blockquote><blockquote><p>這個問題回答期間面試官追問了一些具體的小細節問題，這裡就不再給出了，文章中基本都包含了，這裡就不展開篇幅講了</p></blockquote><blockquote><p>這種籠統的大方向問題建議條理化回答，可以按照自己習慣的或者固定的方面去展開講，否則這種大問題東一句西一句的容易讓面試不耐煩，越條理越好，我自己當時是按照HTML、CSS、JS、網絡通信，頁面加載的順序去說的，過程中面試官一直在記錄，估計是看有沒有說到他想要的那些點。</p></blockquote><h1 class=pgc-h-arrow-right>追問：開發過程中碰到過什麼棘手的性能方面的問題麼</h1><blockquote><p>這個問題當時都是回答的之前在開發過程中確實碰到的，感恩自己當時有心做了總結，總結請點擊鏈接查看[記一次慘痛的Vue-cli + VueX + SSR經歷](https://github.com/programmer-zhang/front-end)</p></blockquote><blockquote><p>這期間穿插著問了一點node，webpack的小知識點</p></blockquote><h1 class=pgc-h-arrow-right>繼承的方式有哪些</h1><p>提供個父類進行繼承</p><pre><code>function SuperType(name) {    this.name = name;    this.sexy = ["man", "woman", "unknow"];    this.showName = function() {        console.log(name);    };};SuperType.prototype.age = 18;</code></pre><h1 class=pgc-h-arrow-right>原型繼承</h1><ul class=list-paddingleft-2><li>利用原型讓一個引用類型繼承另外一個引用類型的屬性和方法</li><li>重點：新實例的原型等於父類的實例</li><li>特點：</li><ul class=list-paddingleft-2><li>1.實例可繼承的屬性有：實例的構造函數的屬性，父類構造函數屬性，父類原型的屬性。（新實例不會繼承父類實例的屬性！）</li><li>2.基於原型鏈，既是父類的實例，也是子類的實例</li></ul><li>缺點：</li><ul class=list-paddingleft-2><li>1.無法實現多繼承</li><li>2.所有新實例都會共享父類實例的屬性</li></ul></ul><pre><code>function SubType() {    this.name = 'coder';}SubType.prototype = new SuperType();var subFun = new SubType();console.log(subFun.age) // 18console.log('outer', subFun instanceof SuperType) // true </code></pre><h1 class=pgc-h-arrow-right>構造函數繼承</h1><ul class=list-paddingleft-2><li>重點：用call()和apply()將父類構造函數引入子類函數（在子類函數中做了父類函數的自執行（複製））</li><li>特點：</li><ul class=list-paddingleft-2><li>1、只繼承了父類構造函數的屬性，沒有繼承父類原型的屬性。</li><li>2、解決了原型鏈繼承缺點1、2、3。</li><li>3、可以繼承多個構造函數屬性（call多個）。</li><li>4、在子實例中可向父實例傳參。</li></ul><li>缺點：</li><ul class=list-paddingleft-2><li>1、只能繼承父類構造函數的屬性。</li><li>2、無法實現構造函數的複用。（每次用每次都要重新調用）</li><li>3、每個新實例都有父類構造函數的副本，臃腫。</li></ul></ul><pre><code>function SubType() {    SuperType.call(this);}let instance1 = new SubType();instance1.sexy.push("all");console.log(instance1.sexy); // ["man", "woman", "unknow", "all"]let instance2 = new SubType();console.log(instance2.sexy); // ["man", "woman", "unknow"]</code></pre><h1 class=pgc-h-arrow-right>組合繼承</h1><ul class=list-paddingleft-2><li>特點：利用原型鏈繼承父類的原型屬性和方法，利用構造函數繼承實例屬性和方法</li><li>缺點：調用了兩次父類構造函數，生成了倆實例</li></ul><pre><code>function SubType(name) {    SuperType.call(this, name);}SubType.prototype = new SuperType();var instance3 = new SubType("newCoder");console.log(instance3.name) // newcoder</code></pre><h1 class=pgc-h-arrow-right>使用 ES6 extends 進行繼承</h1><pre><code>class A {    constructor(name, age) {        this.name = name;        this.age = age;    }    getName() {        return this.name;    }}class B extends A {    constructor(name, age) {        super(name, age);        this.job = "IT";    }    getJob() {        return this.job;    }    getNameAndJob() {        return super.getName() + this.job;    }}var b = new B("Tom", 20);console.log(b.name); // Tomconsole.log(b.age); // 20console.log(b.getName()); // Tomconsole.log(b.getJob()); // ITconsole.log(b.getNameAndJob()); // TomIT</code></pre><h1 class=pgc-h-arrow-right>追問：new 的原理</h1><ul class=list-paddingleft-2><li>在調用 new 的過程中會發生以下四件事：</li><ul class=list-paddingleft-2><li>新生成一個對象</li><li>將構造函數的作用域賦值給新對象（即綁定新對象的 this）</li><li>執行構造函數中的代碼（即為這個新對象添加屬性）</li><li>返回新對象</li></ul><li>一個簡版的new</li></ul><pre><code>function _new() {	// 創建一個新對象    let newObj = {};      // 獲取構造函數    let Constructor = Array.prototype.shift.call(arguments);    // 連接新對象原型，新對象可以訪問原型中的屬性    newObj.__proto__ = Constructor.prototype;    // 執行構造函數，即綁定 this，並且為這個新對象添加屬性    Constructor.apply(newObj, arguments);    // 返回該對象    return newObj;}</code></pre><h1 class=pgc-h-arrow-right>追問：ES6 extends 的原理</h1><blockquote><p>這個問題當時回答的不好，很多關鍵點沒有說出來，面試官也是很友好地幫我答疑解惑</p></blockquote><ul class=list-paddingleft-2><li>ES6 中是通過 class 關鍵字去定義類，經過 bable 編碼之後其實還是通過構造函數去實現的，但是為了規範類的使用，ES6中是不允許直接調用 class 創建的類，因為編碼之後會產生一個 _classCallCheck 阻止你直接調用，會拋出錯誤</li><li>繼承過程其實歸根結底也是類似原型繼承，過程請看下圖</li></ul><div class=pgc-img><img alt=百度和好未來的面試官把我榨乾了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5ce8817cfa8144a785e5e156395a111a><p class=pgc-img-caption></p></div><p>首先 subClass.prototype.__proto__ = superClass.prototype 保證了 Child 的實例可以訪問到父類的屬性，包括內部屬性，以及原型屬性。其次，subClass.__proto__ = superClass，保證了Child.height 也能訪問到，也就是靜態方法。</p><h1 class=pgc-h-arrow-right>ES6 和 ES5</h1><blockquote><p>基礎的問題我就不展開說了，面試過程中涉及到的我列出來，很多基本的大家開發中肯定都已經很熟悉了</p></blockquote><ul class=list-paddingleft-2><li>let 和 const</li><li>解構賦值</li><li>箭頭函數</li><li>模板字符串</li><li>for...of 循環</li><li>展開運算符...</li><li>Class 類</li><li>extends繼承</li><li>Modules</li></ul><h1 class=pgc-h-arrow-right>閉包的原理和優劣以及使用</h1><h1 class=pgc-h-arrow-right>閉包產生的原因</h1><ul class=list-paddingleft-2><li>JS中存在全局作用域和函數作用域，當訪問一個變量時，解釋器會首先在當前作用域查找，如果沒有找到，就去父作用域找，直到找到該變量或者不在父作用域中(也是作用域鏈的概念)</li><li>作用域中的每個子函數都會拷貝上級的作用域，形成一個完整的作用域鏈條</li><li>當前作用域中的變量存在著指向父級作用域的引用，便產生了閉包，下面用一段代碼說明</li></ul><pre><code>// JS的變量逐級查找var a = 1;function f1() {	// f1() 的作用域指向全局作用域(window)和它本身	var a = 2	function f2() {		// f2的作用域指向全局作用域(window)、f1的作用域和它本身		var a = 3;		console.log(a);//3	}}// fun會拿到父級作用域中的變量，輸出2。// 因為在當前環境中，含有對f2的引用 ,f2恰恰引用了window、f1和f2的作用域, 因此f2可以訪問到f1的作用域的變量function f1() {	var a = 2	function f2() {		console.log(a); // 2	}	return f2;}var fun = f1();fun();</code></pre><h1 class=pgc-h-arrow-right>閉包的表現形式</h1><ul class=list-paddingleft-2><li>返回一個函數</li><li>作為函數參數傳遞</li><li>在定時器、事件監聽、Ajax請求、跨窗口通信、Web Workers或者任何異步中，只要使用了回調函數，實際上就是在使用閉包</li><li>立即執行函數表達式</li><ul class=list-paddingleft-2><li>保存了全局作用域和當前作用域，實際也是閉包</li></ul></ul><h1 class=pgc-h-arrow-right>閉包的優劣</h1><ul class=list-paddingleft-2><li>優點</li><ul class=list-paddingleft-2><li>可以讀取函數內部的變量</li><li>可以讓這些局部變量保存在內存中，實現變量數據共享。</li></ul><li>缺點</li><ul class=list-paddingleft-2><li>由於閉包會使得函數中的變量都被保存在內存中，內存消耗很大，所以不能濫用閉包，否則會造成網頁的性能問題</li><li>閉包會在父函數外部，改變父函數內部變量的值。</li></ul></ul><h1 class=pgc-h-arrow-right>閉包的使用</h1><ul class=list-paddingleft-2><li>匿名自執行函數，因為外部無法引用其內部的變量，使用完會立即釋放</li><li>進行結果緩存</li><li>進行封裝工廠函數</li><li>實現類的繼承</li><li>函數柯里化</li></ul><h1 class=pgc-h-arrow-right>this 的指向問題</h1><ul class=list-paddingleft-2><li>記住一點：this最終指向調用它的對象</li><ul class=list-paddingleft-2><li>通俗解釋：JS中存在上下文環境window或者函數，當執行的屬於window時，則取的window的上下文環境，如果執行的屬於函數，則取函數的上下文，this是堆棧的指針，堆棧裡有什麼就返回什麼</li></ul><li>具體分析</li><ul class=list-paddingleft-2><li>如果是一般函數,this指向全局對象window</li><li>在嚴格模式下"use strict",為undefined</li><li>對象的方法裡調用,this指向調用該方法的對象</li><li>構造函數裡的this,指向創建出來的實例</li><li>() => console.log(this) 裡面 this 跟外面的 this 的值一模一樣</li><li>事件監聽的時候，this是監聽元素，setTimeout的函數內this是window(非嚴格模式下)</li></ul></ul><pre><code>var app = {  fn1: function () {    console.log(this)  },  fn2: function(){    return function() {      console.log(this)    }  },  fn3: function() {    function fn() {      console.log(this)    }    return fn()  },  fn4: function() {    return {      fn: function () {        console.log(this)      }    }  },  fn5: function() {    setTimeout(function () {      console.log(this)    },10)   },  fn6: function() {    setTimeout( () =&gt; {      console.log(this)    },20)   },  fn7: function() {    setTimeout(function () {      console.log(this)    }.bind(this),30)   },  fn8: () =&gt; {    setTimeout( () =&gt; {      console.log(this)    },40)   }}app.fn1() // appapp.fn2()() // windowapp.fn3() // windowapp.fn4().fn() // fnapp.fn5() // windowapp.fn6() // appapp.fn7() // appapp.fn8() // window</code></pre><h1 class=pgc-h-arrow-right>VUE 的生命週期</h1><p>vue 生命週期流程圖(圖片來自網絡，侵聯刪)</p><p><br></p><div class=pgc-img><img alt=百度和好未來的面試官把我榨乾了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de39cb55fd8f490bb813041473b9833d><p class=pgc-img-caption></p></div><ol start=1><li>創建實例，new Vue() 的過程中，首先執行 init()</li><li>init() 過程首先是執行 beforeCreate ，初始化data、 props、 watch、computed,這些執行都是在 beforeCreate 階段和 create 階段，也是創建響應式數據的階段，這個階段不要去修改數據</li><li>create 階段結束，會去判斷實例中有無 el option 選項，如果沒有會執行 $mount(), 如果有，直接執行下一步</li><li>判斷 template, 若有，會把 template 打成一個個 render function ,其中的傳參h就是vue.createElement， 參數為 標籤，對象(可以是props或事件)，內容</li><li>render函數發生在 beforemounted 和 mounted 之間，所以當 beforeMount 時，$el 還只是HTML上的節點，mounted 時才把渲染的內容掛載到 DOM 上，實際就是執行了 renderfunction</li><li>beforeMount 有了 renderfunction 才執行，執行完執行 mount , mounted 執行完，整個生命週期中主動執行的函數就已經完畢，剩下的比如 beforeUpdata、updata、beforDestory、destory 需要外部觸發</li></ol><h1 class=pgc-h-arrow-right>VUE computed原理</h1><ul class=list-paddingleft-2><li>設置 computed 的 getter ，若執行了 computed 的函數，會去讀取 data 值，就會觸發 data 的 getter ，從而建立data的依賴關係</li><li>首次mounted的值，會執行vm.computed對應的getter，沒有getter的是賦值函數</li><li>若computed的屬性值依賴其他屬性值，會將target暫存在棧中，先進行其他的依賴收集</li></ul><h1 class=pgc-h-arrow-right>VUE watch流程</h1><ol start=1><li>創建實例時會去處理watch，這點在前面生命週期中已經提到</li><li>遍歷數據keys去創建監聽</li><li>給監聽註冊回調(多種處理方式)</li><li>name:{ handle(){} } 傳入為對象去handler字段</li><li>name(){} 傳入為函數直接監聽回調</li><li>name: 'getName' 傳入為字符串就去實例上獲取回調</li><li>調用vm.$watch</li><li>判斷是否立即執行回調</li><li>每個watch配發watcher(監聽的key，callback，options)</li><li>監聽的數據變化時，通知watch-watcher更新，然後使用updata()更新數據</li></ol><h1 class=pgc-h-arrow-right>VUE 響應式數據處理流程</h1><ol start=1><li>init()時，利用object.defineproperty監聽vue實例的響應式數據變化從而實現數據的劫持，其實是利用了數據的setter和getter</li><li>當render function被渲染時，讀取實例中與視圖相關的響應式數據，從而觸發getter進行依賴收集</li><li>正常的渲染和更新</li><li>數據變化時，觸發setter，通知依賴收集中和視圖相關的watcher，告知重新渲染視圖，watcher再次通過updata渲染視圖</li></ol><h1 class=pgc-h-arrow-right>特定狀態下瀏覽器的兼容性</h1><blockquote><p>這個問題想必前端開發中大家都碰到過很多奇奇怪怪的兼容性問題，我也沒有回答地特別細緻，說了幾個日常開發中碰到過的，面試官結合實際情況問了幾個，具體問的已經記不清了，JS的也有，CSS的也有，IE的那些低版本的兼容性問題個人覺得不說也罷，畢竟用戶量少的又少。</p></blockquote><h1 class=pgc-h-arrow-right>百度三面</h1><blockquote><p>三面就基本上就是聊些思想上的東西多一些，有的人可能起來覺得沒營養，但是每個技術leader都想找個能和大家愉快工作的人，所以一定要認真回答。</p></blockquote><h1 class=pgc-h-arrow-right>關於前東家以及離職原因</h1><h1 class=pgc-h-arrow-right>關於讀書期間的規劃和未來的規劃</h1><h1 class=pgc-h-arrow-right>工作後的心態變化及感受</h1><blockquote><p>還有一些技術無關的問題記不住了</p></blockquote><h1 class=pgc-h-arrow-right>nginx相關問題</h1><blockquote><p>沒有問很深入的問題，當做技術點稍微聊了聊，設計到的問題就這些，如果想要了解，請查看原文鏈接中我之前整理的這部分文章[Nginx 相關]</p></blockquote><ul class=list-paddingleft-2><li>nginx 的作用</li><li>nginx 進程的執行過程</li><li>nginx location進行路由轉發的原理</li><li>nginx 重定向參數問題</li></ul><h1 class=pgc-h-arrow-right>小程序相關問題</h1><blockquote><p>這部分問題因為自己曾經開發過很多小程序，簡歷中也有寫，所以面試官問了一些基本的問題</p></blockquote><blockquote><p>筆者也曾經把業務方面大家常用的實踐整理到了github上(上面文章中)，按需自取，微信相關文章</p></blockquote><ul class=list-paddingleft-2><li>小程序生命週期</li><li>小程序設計組件(包含組件傳參問題)</li><li>小程序兼容性問題</li><li>小程序的尺寸單位</li><li>小程序工程化</li></ul><h1 class=pgc-h-arrow-right>weex相關</h1><blockquote><p>筆者之前公司曾經技術發展曾經試水過一段時間weex，還寫了一遍簡單到不能再簡單的基本使用說明，有興趣的可以點擊上面文章中瞭解一下weex 基礎使用指南</p></blockquote><blockquote><p>weex相關的問題面試官是讓我自己看著說的，我基本也是把自己知道的都放在了上面的文章裡。</p></blockquote><p>以上就是百度的面試過程，還有部分問題已經記得不是很清楚了，但是整體面試下來百度的面試官沒有出很偏的問題，還是以基礎為主，然後深入問，所以想進入大廠基礎還是很重要的。</p><h1 class=pgc-h-arrow-right>好未來一、二、三面</h1><blockquote><p>好未來部分我就不再每個問題都寫了，百度問到的我就不寫了，只寫些新的問題。</p></blockquote><blockquote><p>好未來一面的女士很漂亮哦，只可惜沒能成為同事</p></blockquote><h1 class=pgc-h-arrow-right>less & sass</h1><ul class=list-paddingleft-2><li>CSS的預處理器，擴展了css語言，增加了變量、Mixin、函數等特性，使css更容易維護和擴展</li></ul><h1 class=pgc-h-arrow-right>marginTop的基準點</h1><ul class=list-paddingleft-2><li>如果父元素中有內容的時候，子元素的外邊距是相對父元素內容，如果沒有內容則一直向上追溯尋找如果都沒有找到(案例四中可以看到)，最終以瀏覽器視口為參考點</li></ul><h1 class=pgc-h-arrow-right>絕對定位的基準點</h1><ul class=list-paddingleft-2><li>position: absolute; 相對於relative容器的content</li><li>position: absolute; top: 0; left: 0; 相對於border以內，padding的外側</li></ul><h1 class=pgc-h-arrow-right>手寫題：數組的並集和交集</h1><ul class=list-paddingleft-2><li>實現方案</li></ul><pre><code>let a = new Set([1, 2, 3]);let b = new Set([3, 5, 2]); // 並集let unionSet = new Set([...a, ...b]);//[1,2,3,5]// 交集let intersectionSet = new Set([...a].filter(x =&gt; b.has(x)));</code></pre><h1 class=pgc-h-arrow-right>深拷貝和淺拷貝</h1><h1 class=pgc-h-arrow-right>淺拷貝</h1><ul class=list-paddingleft-2><li>淺拷貝: 以賦值的形式拷貝引用對象，仍指向同一個地址，修改時原對象也會受到影響</li><ul class=list-paddingleft-2><li>賦值表達式 =</li><li>Object.assign</li><li>展開運算符(...)</li></ul></ul><h1 class=pgc-h-arrow-right>深拷貝</h1><ul class=list-paddingleft-2><li>深拷貝: 完全拷貝一個新對象，修改時原對象不再受到任何影響</li><li>性能最快：JSON.parse(JSON.stringify(obj))</li><ul class=list-paddingleft-2><li>具有循環引用的對象時，報錯</li><li>當值為函數或undefined時，無法拷貝</li></ul><li>遞歸進行逐一賦值</li></ul><pre><code>deepClone(obj) {    let result;    if (typeof obj == 'object') {        result = isArray(obj) ? [] : {}        for (let i in obj) {            result[i] = isObject(obj[i])||isArray(obj[i])?deepClone(obj[i]):obj[i]        }    } else {        result = obj    }    return result}function isObject(obj) {    return Object.prototype.toString.call(obj) == "[object Object]"}function isArray(obj) {    return Object.prototype.toString.call(obj) == "[object Array]"}</code></pre><h1 class=pgc-h-arrow-right>Vue父子組件傳值</h1><ul class=list-paddingleft-2><li>組件間的父子之間的傳值: v-bind 傳入，props 接收</li><li>組件間的子父之間的傳值：$emit 觸發，v-bind 監聽</li><li>非組件間的組件間的傳值：vuex、EventBus、路由參數、storage</li></ul><h1 class=pgc-h-arrow-right>Vue列表的循環定義key的作用</h1><ul class=list-paddingleft-2><li>為了更高效的渲染虛擬DOM樹</li><li>在沒有定義key的情況下，當我們插入一個元素時，vue的處理方式是這樣的：</li><ul class=list-paddingleft-2><li>逐個按照順序進行更新，插入點之後的元素都會被重新更新一遍</li></ul><li>定義key的情況下，插入元素時，vue的處理方式是：</li><ul class=list-paddingleft-2><li>按照key當做唯一標識符，僅插入該元素，其他元素不做變動</li></ul></ul><p><br></p><div class=pgc-img><img alt=百度和好未來的面試官把我榨乾了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/fe4dae6bbbdd4d1d9e409f0308afdf72><p class=pgc-img-caption></p></div><p><br></p><h1 class=pgc-h-arrow-right>VueX</h1><ul class=list-paddingleft-2><li>核心概念</li><ul class=list-paddingleft-2><li>state ：存放數據，mutation修改數據會動態修改所有的調用此變量的值</li><li>getter：獲取數據</li><li>mutation：直接修改狀態</li><li>action：action類似mutation，是個裝飾器，包裹mutation，使之可以異步，action提交的是mutation而不是直接修改狀態</li><li>moudle(mapAction)：模塊化VueX</li></ul><li>流程：</li><ul class=list-paddingleft-2><li>頁面 -> mapAction -> 提交事件到action -> action通過commit將對應參數同步到mutation -> mutation會修改state中的值 -> 最後歐通過getter將數據傳遞出去 -> computed中通過mapgetter獲取state</li></ul><li>數據傳遞</li></ul><div class=pgc-img><img alt=百度和好未來的面試官把我榨乾了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/367289553a8f4881a348540c59c11ade><p class=pgc-img-caption></p></div><ul class=list-paddingleft-2><li>好處</li><ul class=list-paddingleft-2><li>傳統傳參方法對於多層級的組件非常繁瑣，兄弟組件無能為力，把組件的共享狀態通過單例模式抽離出來，行成‘樹’</li></ul></ul><h1 class=pgc-h-arrow-right>模塊化</h1><blockquote><p>JS模塊化引入是當前比較流行的處理方式，大部分工程師可能會用，但是很多人未必瞭解他的區別，有興趣的可以點擊原文查看我之前寫過的相關文章[JS模塊化編程資源引入方式]</p></blockquote><h1 class=pgc-h-arrow-right>數據可視化</h1><blockquote><p>筆者之前用過ECharts，問的問題也大多是實操相關的，建議大家面試前有時間自己稍微實操研究一下，起碼面試時不會太尷尬</p></blockquote><h1 class=pgc-h-arrow-right>手寫一個promise的ajax請求</h1><pre><code>const getJson = function (url) {  return new Promise((resolve, reject) =&gt; {    const xhr = new XMLHttpRequest();    xhr.open('GET', url, true);    xhr.onreadystatechange = function () {      if (this.readyState === 4) {        if (this.status === 200) {          resolve(this.responseText, this)        } else {          const resJson = { code: this.status, response: this.response};          reject(resJson);        }      }     };    xhr.send();  })};// 使用getJSON('URL').then((res) =&gt; {	console.log(res);}).catch((err)=&gt;{	console.log(err);}) </code></pre><h1 class=pgc-h-arrow-right>寫在最後</h1><ul class=list-paddingleft-2><li>連續的面試讓我總結的話就是：基礎很重要。</li><li>很多面試題其實並不難，都是基礎問題，如何追根溯源才是工程師技術能力的象徵，能把基礎理解透徹再去拓展技術廣度，會更加從容。</li><li>祝願大家都能收穫健康的身體，喜歡的工作，愉悅的心情，完美的愛情</li><li>另外提供百度內推機會，有意向請發送簡歷到公眾號：全棧道路 後臺靜待回覆</li></ul><p><br></p><div class=pgc-img><img alt=百度和好未來的面試官把我榨乾了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/872c3d9e15e14f92bccaa195c8741966><p class=pgc-img-caption></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>未來</a></li><li><a>面試</a></li><li><a>榨乾</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html alt=光纜——未來網絡主導 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e75c1afe12354a93bad8495ad1057693 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html title=光纜——未來網絡主導>光纜——未來網絡主導</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3d7c984b.html alt=齒輪在製造行業的重要作用，以及齒輪的未來的發展 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/5e7a0003f57045f8ec66 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3d7c984b.html title=齒輪在製造行業的重要作用，以及齒輪的未來的發展>齒輪在製造行業的重要作用，以及齒輪的未來的發展</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d393ab.html alt=兩擋減速器是未來趨勢嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RZmDk53Hdz8gCO style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d393ab.html title=兩擋減速器是未來趨勢嗎？>兩擋減速器是未來趨勢嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html alt=面試總結：關於MySQL事務的10個問題常見面試問答 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/1669c986-315c-4339-a5a0-a918a47f2e57 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/677306ff.html title=面試總結：關於MySQL事務的10個問題常見面試問答>面試總結：關於MySQL事務的10個問題常見面試問答</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3be59415.html alt="重慶6月來日照時數較同期偏少七成 未來五天陰雨持續" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/8e3a000931dc497c3b4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3be59415.html title="重慶6月來日照時數較同期偏少七成 未來五天陰雨持續">重慶6月來日照時數較同期偏少七成 未來五天陰雨持續</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html alt=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/68ac43b98fa343f2874d08bacae73ee8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/adc31f83.html title=Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）>Java面試知識點總結⑥——算法與數據結構_一點課堂（多岸學院）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html alt=面試中常被問到的Hash表，你瞭解嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/ba5ea1b5-dee5-4145-8f0d-8eee90a5eba6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cdbf5cb4.html title=面試中常被問到的Hash表，你瞭解嗎>面試中常被問到的Hash表，你瞭解嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html alt=面試總結-Java高級篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/4afe0004abfd4a7bb3c5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1d10456.html title=面試總結-Java高級篇>面試總結-Java高級篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html alt=你不得不知道的HashMap面試連環炮 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/278ed0687f4d436f9cb8389a38b1603e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b10623ce.html title=你不得不知道的HashMap面試連環炮>你不得不知道的HashMap面試連環炮</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html alt="有關 HashMap 面試會問的一切" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25263d0d73a143bab5e44096efdd931d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ae15b401.html title="有關 HashMap 面試會問的一切">有關 HashMap 面試會問的一切</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html alt="面試官：為什麼 HashMap 的加載因子是0.75？" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/15a700f4ff6a4082a566db903915ea1b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3e2c89d5.html title="面試官：為什麼 HashMap 的加載因子是0.75？">面試官：為什麼 HashMap 的加載因子是0.75？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html alt=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5d61204d36a64ca9864df863782072b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/95a57792.html title=面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？>面試官：100萬個成員的數組取第一個和最後一個有性能差距嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c0592cac.html alt=一分鐘瞭解新型顯示的未來…… class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f008035275e146c285db6754e82bda45 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c0592cac.html title=一分鐘瞭解新型顯示的未來……>一分鐘瞭解新型顯示的未來……</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e85fd671.html alt=知識科普：這六種未來顯示技術，你都瞭解嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RWwS2Mb6j4Inrv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e85fd671.html title=知識科普：這六種未來顯示技術，你都瞭解嗎？>知識科普：這六種未來顯示技術，你都瞭解嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>