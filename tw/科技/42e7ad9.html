<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>網絡編程 用戶態協議棧之 TCP/IP 的設計 | 极客快訊</title><meta property="og:title" content="網絡編程 用戶態協議棧之 TCP/IP 的設計 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/f1ee5eb624d94284bf71514f3cc5ea7b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/42e7ad9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/42e7ad9.html><meta property="article:published_time" content="2020-10-29T20:50:33+08:00"><meta property="article:modified_time" content="2020-10-29T20:50:33+08:00"><meta name=Keywords content><meta name=description content="網絡編程 用戶態協議棧之 TCP/IP 的設計"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/42e7ad9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>網絡編程 用戶態協議棧之 TCP/IP 的設計</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>1. Netmap 簡介</strong></p><p>Netmap 是一個高性能收發原始數據包的框架，由 Luigi Rizzo 等人開發完成，其包含了內核</p><p>模塊以及用戶態庫函數。其目標是，不修改現有操作系統軟件以及不需要特殊硬件支持，實</p><p>現用戶態和網卡之間數據包的高性能傳遞。其原理圖如下，數據包不經過操作系統內核進行</p><p>處理，用戶空間程序收發數據包時，直接與網卡進行通信。</p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1ee5eb624d94284bf71514f3cc5ea7b><p class=pgc-img-caption></p></div><p><br></p><p>相關視頻教程</p><p><a class=pgc-link data-content=mp href=https://www.ixigua.com/i6844073817476694531/ rel="noopener noreferrer" target=_blank>Linux服務器開發/網絡編程/TCP/IP協議棧深度解析第一課</a></p><p><a class=pgc-link data-content=mp href=https://www.ixigua.com/i6844074791129842188/ rel="noopener noreferrer" target=_blank>Linux服務器開發/網絡編程/TCP/IP協議棧深度解析第二課</a></p><p><a class=pgc-link data-content=mp href=https://www.ixigua.com/i6847748577859633668/ rel="noopener noreferrer" target=_blank>Linux服務器開發/網絡編程/TCP/IP協議棧深度解析【完結篇】</a></p><p>相關代碼關注後私信回覆：1</p><p><strong>1. 數據結構</strong></p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/055d156edb28447cb4ed1b477fe54c80><p class=pgc-img-caption></p></div><p><strong></strong></p><p>在 Netmap 框架下，內核擁有數據包池，發循環接收環上的數據包不需要動態申請，有數據</p><p>到達網卡時，當有數據到達後，直接從數據包池中取出一個數據包，然後將數據放入此數據</p><p>包中，再將數據包的描述符放入接收環中。內核中的數據包池，通過 mmap 技術映射到用戶</p><p>空間。用戶態程序最終通過 netmap_if 獲取接收發送環 netmap_ring，進行數據包的獲取發</p><p>送。</p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/dfic-imagehandler/afe8be44-68c3-456c-88b5-3b86b7576515><p class=pgc-img-caption></p></div><p><strong>2. 特點總結</strong></p><p><strong>（1）性能高 </strong>：數據包不走傳統協議棧，不需要層層解析，用戶態直接與網卡的接受環和發</p><p>循環交互。性能高的具體原因有以下三個：</p><p>（a） 系統調用以及處理數據包的時間花費少</p><p>（b） 不需要進行數據包的內存分配：採用數據包池，當有數據到達後，直接從數據包</p><p>池中取出一個數據包，然後將數據放入此數據包中，再將數據包的描述符放入接收環中。</p><p>（c） 數據拷貝次數少：內核中的數據包採用 mmap 技術映射到用戶態。所以數據包在</p><p>到達用戶態時，不需要進行數據包的拷貝。</p><p><strong>（2） 穩定性高 </strong>：有關網卡寄存器數據的維護都是在內核模塊進行，用戶不會直接操作寄</p><p>存器。所以在用戶態操作時，不會導致操作系統崩潰</p><p><strong>（3） 親和性 </strong>：可採用了 CPU 親和性，實現 CPU 和網卡綁定，提高性能。</p><p><strong>（4） 易用性好 </strong>：API 操作簡單，用戶態只需要調用 ioctl 函數即可完成數據包收發工作</p><p><strong>（5） 與硬件解耦 </strong>：不依賴硬件，只需要對網卡驅動程序稍微做點修改就可以使用此框架</p><p>（幾十行行），傳統網卡驅動將數據包傳遞給操作系統內核中協議棧，而修改後的數據包直</p><p>接放入 Netmap_ring 供用戶使用。</p><p><strong>2. Netmap API 介紹</strong></p><p><strong>1. 簡要說明</strong></p><p>1.netmap API 主要為兩個頭文件 netmap.h 和 netmap_user.h ，當解壓下載好的 netmap</p><p>程序後，在./netmap/sys/net/目錄下，本文主要對這兩個頭文件進行分析。</p><p>2.我們從 netmap_user.h 頭文件開始看起。</p><p><strong>2. likely()和 unlikely()</strong></p><p>這兩個宏定義是對編譯器做優化的，並不會對變量做什麼改變。後面看到這兩個宏的調</p><p>用自動忽略就好了。</p><pre><code>#ifndef likely#define likely(x) __builtin_expect(!!(x), 1)#define unlikely(x) __builtin_expect(!!(x), 0)#endif /* likely and unlikely */</code></pre><p><strong>3. netmap.h 頭文件</strong></p><p>1.netmap.h 被 netmap_user.h 調用，裡面定義了一些宏和幾個主要的結構體，如</p><p>nmreq{}, netmap_if{}, netmap_ring{}, netmap_slot{}。</p><p>2.一個網卡(或者網絡接口)只有一個 netmap_if{}結構，在使用 mmap()申請的共享內存中，</p><p>通過 netmap_if{}結構可以訪問到任何一個發送/接收環(也就是 netmap_ring{}結構，一個</p><p>netmap_if{}可以對應多發送/接收環,這應該和物理硬件有關 ，我在虛擬機下只有一對環，在</p><p>真實主機上有兩隊環)。</p><p>3.找到 netmap_ring{}的地址後，我們就可以找到環中每一個 buffer 的地址(buffer 裡面存</p><p>儲的是將要發送/接收的數據包)。後面會講解這是如何實現的。</p><p>4.通過一個 nifp 是如何訪問到多個收/發環的，通過一個 ring 如何找到多個不同的 buffer</p><p>地址的，其實都是通過存儲這些結構體相鄰的後面一部分空間實現。</p><p>(申請共享內存的時候，</p><p>這些均已被設計好)</p><p><strong>4. 幾個重要的宏定義</strong></p><p><strong>1._NETMAP_OFFSET</strong></p><pre><code>#define _NETMAP_OFFSET(type, ptr, offset) \ ((type)(void *)((char *)(ptr) + (offset)))</code></pre><p>解釋：該宏定義的作用是將 ptr 指針(將轉成 char *類型)向右偏移 offset 個字節，再將其轉化</p><p>為指定的類型 type。</p><p><strong>2.NETMAP_IF</strong></p><pre><code>#define NETMAP_IF(_base, _ofs) _NETMAP_OFFSET(struct netmap_if *,_base, _ofs)</code></pre><p>解釋：該宏定義將_base 指針向右偏移_ofs 個字節後，將轉為 netmap_if *類型返回。在 nemap</p><p>中通過此宏得到 d->nifp 的地址。</p><p><strong>3.NETMAP_TXRING</strong></p><pre><code>#define NETMAP_TXRING(nifp, index) _NETMAP_OFFSET(struct netmap_ring*, \ nifp, (nifp)-&gt;ring_ofs[index] )</code></pre><p>解釋：1.通過該宏定義，可以找到 nifp 的第 index 個發送環的地址(index 是從 0 開始的)，</p><p>ring_ofs[index]為偏移量，由內核生成。</p><p>2.其中，我們注意到 struct netmap_if{}最後面只定義了 const ssize_t ring_ofs[0]，實際</p><p>上其它的 netmap 環的偏移量都寫在了該結構體後面的內存地址裡面，直接訪問就可以了。</p><p><strong>4.NETMAP_RXRING</strong></p><pre><code>#define NETMAP_RXRING(nifp, index) _NETMAP_OFFSET(struct netmap_ring*, \ nifp, (nifp)-&gt;ring_ofs[index + (nifp)-&gt;ni_tx_rings + 1] )</code></pre><p>解釋：通過該宏定義，可以找到 nifp 的第 index 個接收環的地址，其中(nifp)->ring_ofs[]裡面</p><p>的下標為 index+(nifp)->ni_tx_rings+1，正好與發送環的偏移量區間隔開 1 個。(我想這應該是</p><p>作者特意設計的)</p><p><strong>5.NETMAP_BUF</strong></p><pre><code>#define NETMAP_BUF(ring, index) \ ((char *)(ring) + (ring)-&gt;buf_ofs +((index)*(ring)-&gt;nr_buf_size))</code></pre><p>解釋：1.通過該宏定義，可以找到 ring 這個環的第 index 個 buffer 的地址(buffer 裡面存的酒</p><p>是我們接收/將發送的完整數據包)，每個 buffer 佔的長度是 2048 字節(在(ring)->nr_buf_size</p><p>也給出了)。</p><p>2.其中(ring) ->buf_ofs 是固定的偏移量，不同的環這個值不相同，但所有的(char</p><p>*)(ring)+(ring)->buf_ofs 會指向同一個地址，也就是存放 buffer 的連續內存的開始地址</p><p>(d->buf_start 會指向該地址)。</p><p><strong>6. NETMAP_BUF_IDX</strong></p><pre><code>#define NETMAP_BUF_IDX(ring, buf) \ ( ((char *)(buf) - ((char *)(ring) + (ring)-&gt;buf_ofs) ) / \ (ring)-&gt;nr_buf_size )</code></pre><p>解釋：在講 NETMAP_BUF 的時候我們說(char *)(ring) + (ring)->buf_ofs)總會指向存放 buffer 的</p><p>起始位置(無論是哪一個環)，在這段內存中將第一個 buffer 下標標記為 0 的話，</p><p>NETMAP_BUF_IDX 計算的恰好是指針 buf 所指 buffer 的下標。</p><p>上面幾個宏一時沒弄懂也沒關係，下面調用的時候還會提的。</p><p><strong>5. nm_open 函數</strong></p><p>1.調用 nm_open 函數時，如：nmr = nm_open("netmap:eth0", NULL, 0, NULL); nm_open()會</p><p>對傳遞的 ifname 指針裡面的字符串進行分析，提取出網絡接口名。</p><p>2.nm_open() 會 對 struct nm_desc *d 申 請 內 存 空 見 ， 並 通 過 d->fd =</p><p>open(NETMAP_DEVICE_NAME, O_RDWR);打開一個特殊的設備/dev/netmap 來創建文件描述</p><p>符 d->fd。</p><p>3.通過 ioctl(d->fd, NIOCREGIF, &d->req)語句，將 d->fd 綁定到一個特殊的接口，並對 d->req</p><p>結構體裡面的成員最初始化，包括 <strong>a.</strong>在共享內存區域中 nifp 的偏移，<strong>b.</strong>共享區域的大小</p><p>nr_memsize，<strong>c.</strong>tx/rx 環的大小 nr_tx_slots/nr_rx_slots(大小為 256)，<strong>d.</strong>tx/rx 環的數量 nr_tx_rings、</p><p>nr_rx_rings(視硬件性能而定)等。</p><p>4.接著在 if ((!(new_flags & NM_OPEN_NO_MMAP) || parent) && nm_mmap(d, parent))語句</p><p>中調用 nm_mmap 函數，繼續給 d 指針指向的內存賦值。</p><p><strong>6. nm_mmap 函數</strong></p><p>nm_mmap()源碼：</p><pre><code>static int nm_mmap(struct nm_desc *d, const struct nm_desc *parent){//XXX TODO: check if mmap is already doneif (IS_NETMAP_DESC(parent) &amp;&amp; parent-&gt;mem &amp;&amp; parent-&gt;req.nr_arg2== d-&gt;req.nr_arg2) {/* do not mmap, inherit from parent */ D("do not mmap, inherit from parent"); d-&gt;memsize = parent-&gt;memsize; d-&gt;mem = parent-&gt;mem; } else {/* XXX TODO: 檢查如果想申請的內存太大 (or there is overflow)*/ d-&gt;memsize = d-&gt;req.nr_memsize; /* 將需要申請的內存大小賦值給 d-&gt;memsize */ d-&gt;mem = mmap(0, d-&gt;memsize, PROT_WRITE | PROT_READ,MAP_SHARED, d-&gt;fd, 0); /* 申請共享內存 */if (d-&gt;mem == MAP_FAILED) {goto fail; } d-&gt;done_mmap = 1; } {struct netmap_if *nifp = NETMAP_IF(d-&gt;mem, d-&gt;req.nr_offset);/*通過 d-&gt;req.nr_offset 這個偏移量的到 nifp 的地址，NETMAP_IF 前面說過*/int i;/* *for(i=0; i&lt;=2; i++) * printf("ring_ofs[%d]:0x%x\n",i,nifp-&gt;ring_ofs[i]); //這裡是我自己加的，為了手動計算收/發環的偏移量 */struct netmap_ring *r = NETMAP_RXRING(nifp,); //對 nifp，找接收包的環 r，因為 index 為 0，所以省略了 *(struct netmap_if **) (uintptr_t) &amp;(d-&gt;nifp) = nifp; //對d-&gt;nifp 賦值，雖然 d-&gt;nifp 使用 const 定義的，但對其取地址再強值類型轉換後，依然可以對其指向的空間進行操作 *(struct netmap_ring **) (uintptr_t) &amp;d-&gt;some_ring = r; //桶理，對 d-&gt;some_ring 進行賦值，此處指向了第一個接受(rx)環。 //printf("buf_ofs:0x%x\n", (u_int)r-&gt;buf_ofs); *(void **) (uintptr_t) &amp;d-&gt;buf_start = NETMAP_BUF(r, 0);//計算第一個 buffer 的地址，並存入 d-&gt;buf_start 指針中 *(void **) (uintptr_t) &amp;d-&gt;buf_end = (char *) d-&gt;mem +d-&gt;memsize; //計算共享區間的最後一個地址，賦值給 d-&gt;buf_end }return 0; fail: return EINVAL;}</code></pre><p>其中：</p><p>1.nifp 為申請的共享內存首地址 d->mem 向右偏移 d->req.nr_offset(該值在調用前面的</p><p>ioctl()時得到)得到。並且一個網絡接口(網卡)只對應一個 nifp。(使用宏 NETMAP_IF 計算)</p><p>2.得到的nifp 的地址，nifp 結構體裡最後定義的 ring_ofs[0]以及接下來內存中的 ring_ofs[1]，</p><p>ring_ofs[2]...，這些內存中存儲的是訪問每一個環(tx or rx ring)的偏移量，通過這個偏移量我</p><p>們可以得到每一個環的地址(使用宏 NETMAP_RXRING/NETMAP_TXRING 進行計算)。</p><p>3.得到每個收/發環的地址了，netmap_ring 結構體最後面有一個 struct netmap_slot slot[0];，</p><p>通過 slot[0],後面內存的 slot[1],slot[2],slot[3]...,取出裡面的偏移量就可以得到每一個 buffer(也</p><p>叫數據包槽)的地址了(使用宏 NETMAP_BUF 計算得到)。</p><p>到這裡，netmap 如何訪問到內存</p><p>槽中的每一個 buffer 的，我們都知道了。實際上 netmap 運行的數據結構就和下圖描述的一</p><p>楊：</p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/71252bbce52a4a66b7be3e492f68deda><p class=pgc-img-caption></p></div><p>4.在 struct nm_desc 中，nifp，some_ring，buf_start，buf_end 等指針都定義為 const 的，</p><p>但我們通過對其取地址再強轉指針的方式去往這些指針指向的內存中賦值。</p><p>注:在 nm_mmap()中使用 mmap()申請共享的時候，這些數據結構裡數據的設計是內核模</p><p>塊就已寫好了的，我們在這裡其實是在做驗證。</p><p><strong>7. nm_nextpkt 函數</strong></p><p>1.nm_nextpkt()是用來接收網卡上到來的數據包的函數。</p><p>2.nm_nextpkt()會將所有 rx 環都檢查一遍，當發現有一個 rx 還有需要接收的數據包時，</p><p>得到這個數據包的地址，並返回。所以 nm_nextpkt()每次只能取一個數據包。</p><p>nm_nextpkt()源代碼：</p><pre><code>static u_char *nm_nextpkt(struct nm_desc *d, struct nm_pkthdr *hdr){int ri = d-&gt;cur_rx_ring; //當前的接收環的編號do {/* compute current ring to use */struct netmap_ring *ring = NETMAP_RXRING(d-&gt;nifp, ri); //得到當前 rx 環的地址if (!nm_ring_empty(ring)) //判斷環裡是否有新到的包 { u_int i = ring-&gt;cur; //當前該訪問哪個槽(buffer)了 u_int idx = ring-&gt;slot[i].buf_idx; //得到第 i 個 buffer 的下標 //printf("%d\n", idx); u_char *buf = (u_char *) NETMAP_BUF(ring, idx); //得到存有到來數據包的地址 // __builtin_prefetch(buf); hdr-&gt;ts = ring-&gt;ts; hdr-&gt;len = hdr-&gt;caplen = ring-&gt;slot[i].len; ring-&gt;cur = nm_ring_next(ring, i); //ring-&gt;cur 向後移動一位/* we could postpone advancing head if we want * to hold the buffer. This can be supported in * the future. */ ring-&gt;head = ring-&gt;cur; d-&gt;cur_rx_ring = ri; //將當前環(d-&gt;cur_rx_ring)指向第 ri個(因為可能有多個環)。return buf; //將數據包地址返回 } ri++;if (ri &gt; d-&gt;last_rx_ring) //如果 ri 超過了 rx 環的數量，則再從第一個 rx 還開始檢測是否有包到來。 ri = d-&gt;first_rx_ring; } while (ri != d-&gt;cur_rx_ring);return NULL; /* 什麼也沒發現 */}</code></pre><p><strong>8. nm_inject 函數</strong></p><p>1.nm_inject()是用來往共享內存中寫入待發送的數據包數據的。數據包經共享內存拷貝到</p><p>網卡，然後發送出去。所以 nm_inject()是用來發包的。</p><p>2.nm_inject()也會查找所有的發送環(tx 環)，找到一個可以發送的槽，就將數據包寫入並</p><p>返回，所以每次函數調用也只能發送一個包。</p><p>源代碼：</p><pre><code>static int nm_inject(struct nm_desc *d, const void *buf, size_t size){ u_int c, n = d-&gt;last_tx_ring - d-&gt;first_tx_ring + 1;for (c = 0; c &lt; n; c++) {/* 計算當前的環去使用(compute current ring to use) */struct netmap_ring *ring; uint32_t i, idx; uint32_t ri = d-&gt;cur_tx_ring + c; //該訪問第幾個 tx 環了if (ri &gt; d-&gt;last_tx_ring) //當超過訪問的 tx 環的下標範圍時，從頭開始訪問 ri = d-&gt;first_tx_ring; ring = NETMAP_TXRING(d-&gt;nifp, ri); //得到當前 tx 環的地址if (nm_ring_empty(ring)) //如果當前 tx 環是滿的(ring-&gt;cur=ring-&gt;tail 表示沒地方存數據包了)，就跳過 {continue; } i = ring-&gt;cur; //當前要往哪個槽(槽指向 buffer)中寫入數據 idx = ring-&gt;slot[i].buf_idx; //得到這個槽相對於 buffer 起始地址(d-&gt;buf_start)的下標編號 ring-&gt;slot[i].len = size; //size 為待發送數據包的長度 nm_pkt_copy(buf, NETMAP_BUF(ring, idx), size); //將 buf 裡存的數據包拷貝給 ring 這個環的第 i 個槽 d-&gt;cur_tx_ring = ri; ring-&gt;head = ring-&gt;cur = nm_ring_next(ring, i); //將 head 和cur 指向下一個槽return size; }return 0; /* 失敗 */}</code></pre><p><strong>9. nm_close 函數</strong></p><p>1.nm_close 函數就是回收動態內存，回收共享內存，關閉文件描述符什麼的了。</p><p>源代碼：</p><pre><code>static int nm_close(struct nm_desc *d){/* * ugly trick to avoid unused warnings */static void *__xxzt[] __attribute__ ((unused)) = { (void *) nm_open, (void *) nm_inject, (void *) nm_dispatch,(void *) nm_nextpkt };if (d == NULL || d-&gt;self != d)return EINVAL;if (d-&gt;done_mmap &amp;&amp; d-&gt;mem) munmap(d-&gt;mem, d-&gt;memsize); //釋放申請的共享內存if (d-&gt;fd != -1) { close(d-&gt;fd); //關閉文件描述符 } bzero(d, sizeof(*d)); //將 d 指向的空間全部置 0free(d); //釋放指針 d 指向的空間return 0;}</code></pre><p><strong>3. NtyTCP 安裝</strong></p><p>VMWare 編譯與調試</p><p>1. 添加兩個網絡適配器</p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/5dce24ce401743a99cceaca7ce63ca6c><p class=pgc-img-caption></p></div><p>系統啟動後，</p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/304453e7d91e4db58efb0cb1c01fd4c6><p class=pgc-img-caption></p></div><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/dd239c37aea9419eaf95e7089e5afed2><p class=pgc-img-caption></p></div><p>添加綁定的網卡的 IP 地址，十六進制 IP 地址，網卡相應的 MAC 地址。</p><p>代碼地址</p><p>https://github.com/wangbojing/NtyTcp.git</p><p>環境編譯，下面以 ubuntu server 版本為例。</p><p>先安裝 netmap</p><p>Ubuntu 14.04</p><p>https://github.com/wangbojing/netmap.git</p><p>Ubuntu 16.04</p><p>https://github.com/luigirizzo/netmap.git</p><p># ./configure</p><p># make</p><p># make install</p><p>進入 ntytcp 的目錄</p><p>直接 make</p><div class=pgc-img><img alt="網絡編程 用戶態協議棧之 TCP/IP 的設計" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8db4d48b8e2d4c3ea8416ddc3f391b47><p class=pgc-img-caption></p></div><p><br></p><p><strong>4. C10M 的問題</strong></p><p>截至目前，40gpbs、32-cores、256G RAM 的 X86 服務器在 Newegg 網站上的報價是幾千</p><p>美元。實際上以這樣的硬件配置來看，它完全可以處理 1000 萬個以上的併發連接，如果它</p><p>們不能，那是因為你選擇了錯誤的軟件，而不是底層硬件的問題。</p><p>可以預見在接下來的 10 年裡，因為 IPv6 協議下每個服務器的潛在連接數都是數以百萬</p><p>級的，單機服務器處理數百萬的併發連接（甚至千萬）並非不可能，但我們需要重新審視目</p><p>前主流 OS 針對網絡編程這一塊的具體技術實現。</p><p><strong>1、解決 C10M 問題並非不可能</strong></p><p>很多人會想當然的認為，要實現 C10M（即單機千萬）併發連接和處理能力，是不可能的。</p><p>不過事實並非如此，現在系統已經在用你可能不熟悉甚至激進的方式支持千萬級別的併發連</p><p>接。</p><p>要知道它是如何做到的，我們首先要了解 Errata Security 的 CEO Robert Graham，以及他在</p><p>Shmoocon 2013 大會上的“天方夜談”視頻記錄： C10M Defending The Internet At Scale（此</p><p>為 Yutube 視頻，你懂的）。</p><p>Robert 用一種我以前從未聽說的方式來很巧妙地解釋了這個問題。他首先介紹了一點有關</p><p>Unix 的歷史，Unix 的設計初衷並不是一般的服務器操作系統，而是電話網絡的控制系統。由</p><p>於是實際傳送數據的電話網絡，所以在控制層和數據層之間有明確的界限。問題是我們現在</p><p>根本不應該使用 Unix 服務器作為數據層的一部分。正如設計只運行一個應用程序的服務器</p><p>內核，肯定和設計多用戶的服務器內核是不同的。</p><p><strong>Robert Graham 的結論是：</strong>OS 的內核不是解決 C10M 問題的辦法，恰恰相反 OS 的內核正是</p><p>導致 C10M 問題的關鍵所在。</p><p>這也就意味著：</p><p>不要讓 OS 內核執行所有繁重的任務：將數據包處理、內存管理、處理器調度等任務從內核</p><p>轉移到應用程序高效地完成，讓諸如 Linux 這樣的 OS 只處理控制層，數據層完全交給應用</p><p>程序來處理。</p><p>最終就是要設計這樣一個系統，該系統可以處理千萬級別的併發連接，它在 200 個時鐘週期</p><p>內處理數據包，在 14 萬個時鐘週期內處理應用程序邏輯。由於一次主存儲器訪問就要花費</p><p>300 個時鐘週期，所以這是最大限度的減少代碼和緩存丟失的關鍵。</p><p>面向數據層的系統可以每秒處理 1 千萬個數據包，面向控制層的系統，每秒只能處理 1 百萬</p><p>個數據包。這似乎很極端，請記住一句老話：可擴展性是專業化的，為了做好一些事情，你</p><p>不能把性能問題外包給操作系統來解決，你必須自己做。</p><p><strong>2、回顧一下 C10K 問題</strong></p><p>10 年前，開發人員處理 C10K 可擴展性問題時，儘量避免服務器處理超過 1 萬個的並</p><p>發連接。通過改進操作系統內核以及用事件驅動服務器（典型技術實現如：Nginx 和</p><p>Node）代替線程服務器（典型代表：Apache），使得這個問題已經被解決。人們用十年的</p><p>時間從 Apache 轉移到可擴展服務器，在近幾年，可擴展服務器的採用率增長得更快了。</p><p>以傳統網絡編程模型作為代表的 Apache 為例，我們來看看它在 C10K 問題上的侷限表</p><p>現在哪些方面，並針對性的討論對應的解決方法。Apache 的問題在於服務器的性能會隨著</p><p>連接數的增多而變差，實際上性能和可擴展性並不是一回事。當人們談論規模時，他們往</p><p>往是在談論性能，但是規模和性能是不同的，比如 Apache。持續幾秒的短期連接：比如快</p><p>速事務，如果每秒處理 1000 個事務，只能有約 1000 個併發連接到服務器。如果事務延長</p><p>到 10 秒，要維持每秒 1000 個事務則必須打開 1 萬個併發連接。這種情況下：儘管你不顧</p><p>DoS 攻擊，Apache 也會性能陡降，同時大量的下載操作也會使 Apache 崩潰。</p><p>如果每秒處理的連接從 5 千增加到 1 萬，你會怎麼做？比方說，你升級硬件並且提高</p><p>處理器速度到原來的 2 倍。到底發生了什麼？你得到兩倍的性能，但你沒有得到兩倍的處</p><p>理規模。每秒處理的連接可能只達到了 6000。你繼續提高速度，情況也沒有改善。甚至 16</p><p>倍的性能時，仍然不能處理 1 萬個併發連接。所以說性能和可擴展性是不一樣的。</p><p>問題在於 Apache 會創建一個 CGI 進程，然後關閉，這個步驟並沒有擴展。為什麼呢？</p><p>內核使用的 O(N^2)算法使服務器無法處理 1 萬個併發連接。</p><p><strong>OS 內核中的兩個基本問題：</strong></p><p> 連接數=線程數/進程數：當一個數據包進來，內核會遍歷其所有進程以決定由哪個進程</p><p>來處理這個數據包。</p><p> 連接數=選擇數/輪詢次數（單線程）：同樣的可擴展性問題，每個包都要走一遭列表上</p><p>所有的 socket。</p><p>通過上述針對 Apache 所表現出的問題，實際上徹底解決併發性能問題的解決方法的根</p><p>本就是改進 OS 內核使其在常數時間內查找，使線程切換時間與線程數量無關，使用一個新</p><p>的可擴展 epoll()/IOCompletionPort 常數時間去做 socket 查詢。</p><p>因為線程調度並沒有得到擴展，所以服務器大規模對 socket 使用 epoll 方法，這樣就導</p><p>致需要使用異步編程模式，而這些編程模式正是 Nginx 和 Node 類型服務器具有的。所以當</p><p>從 Apache 遷移到 Nginx 和 Node 類型服務器時，即使在一個配置較低的服務器上增加連接</p><p>數，性能也不會突降。所以在處理 C10K 連接時，一臺筆記本電腦的速度甚至超過了 16 核的</p><p>服務器。這也是前一個 10 年解決 C10K 問題的普遍方法。</p><p><strong>3、實現 C10M 意味著什麼？</strong></p><p><strong>實現 10M（即 1 千萬）的併發連接挑戰意味著什麼：</strong></p><p> <strong>1 千萬的併發連接數</strong>；</p><p> <strong>100 萬個連接/秒：</strong>每個連接以這個速率持續約 10 秒；</p><p> <strong>10GB/秒的連接：</strong>快速連接到互聯網；</p><p> <strong>1 千萬個數據包/秒：</strong>據估計目前的服務器每秒處理 50K 數據包，以後會更多；</p><p> <strong>10 微秒的延遲：</strong>可擴展服務器也許可以處理這個規模（但延遲可能會飆升）；</p><p> <strong>10 微秒的抖動：</strong>限制最大延遲；</p><p> <strong>併發 10 核技術：</strong>軟件應支持更多核的服務器（通常情況下，軟件能輕鬆擴展到四核，</p><p>服務器可以擴展到更多核，因此需要重寫軟件，以支持更多核的服務器）。</p><p><strong>4、為什麼說實現 C10M 的挑戰不在硬件而在軟件？</strong></p><p><strong>1. 理由概述</strong></p><p>硬件不是 10M 問題的性能瓶頸所在處，真正的問題出在軟件上，尤其是*nux 操作系統。</p><p>理由如下面這幾點：</p><p><strong>首先：</strong>最初的設計是讓 Unix 成為一個電話網絡的控制系統，而不是成為一個服務器操</p><p>作系統。對於控制系統而言，針對的主要目標是用戶和任務，而並沒有針對作為協助功能的</p><p>數據處理做特別設計，也就是既沒有所謂的快速路徑、慢速路徑，也沒有各種數據服務處理</p><p>的優先級差別。</p><p><strong>其次：</strong>傳統的 CPU，因為只有一個核，操作系統代碼以多線程或多任務的形式來提升整</p><p>體性能。而現在，4 核、8 核、32 核、64 核和 100 核，都已經是真實存在的 CPU 芯片，如</p><p>何提高多核的性能可擴展性，是一個必須面對的問題。比如讓同一任務分割在多個核心上執</p><p>行，以避免 CPU 的空閒浪費，當然，這裡面要解決的技術點有任務分割、任務同步和異步</p><p>等。</p><p><strong>再次：</strong>核心緩存大小與內存速度是一個關鍵問題。現在，內存已經變得非常的便宜，隨</p><p>便一臺普通的筆記本電腦，內存至少也就是 4G 以上，高端服務器的內存上 24G 那是相當的</p><p>平常。但是，內存的訪問速度仍然很慢，CPU 訪問一次內存需要約 60~100 納秒，相比很久</p><p>以前的內存訪問速度，這基本沒有增長多少。對於在一個帶有 1GHZ 主頻 CPU 的電腦硬件</p><p>裡，如果要實現 10M 性能，那麼平均每一個包只有 100 納秒，如果存在兩次 CPU 訪問內存，</p><p>那麼 10M 性能就達不到了。核心緩存，也就是 CPU L1/L2/LL Cache，雖然訪問速度會快些，</p><p>但大小仍然不夠，我之前接觸到的高端至強，LLC 容量大小貌似也就是 12M。</p><p><strong>2. 解決思路</strong></p><p>解決這些問題的關鍵在於如何將功能邏輯做好恰當的劃分，比如專門負責控制邏輯的控</p><p>制面和專門負責數據邏輯的數據面。數據面專門負責數據的處理，屬於資源消耗的主要因素，</p><p>壓力巨大，而相比如此，控制面只負責一些偶爾才有非業務邏輯，比如與外部用戶的交互、</p><p>信息的統計等等。我之前接觸過幾種網絡數據處理框架，比如 Intel 的 DPDK、6wind、windriver，</p><p>它們都針對 Linux 系統做了特別的補充設計，增加了數據面、快速路徑等等特性，其性能的</p><p>提升自然是相當巨大。</p><p><strong>看一下這些高性能框架的共同特點：</strong></p><p> <strong>數據包直接傳遞到業務邏輯：</strong></p><p>而不是經過 Linux 內核協議棧。這是很明顯的事情，因為我們知道，Linux 協議棧是復</p><p>雜和繁瑣的，數據包經過它無非會導致性能的巨大下降，並且會佔用大量的內存資</p><p>元，之前有同事測試過，Linux 內核要吃掉 2.5KB 內存/socket。我研究過很長一段時間</p><p>的 DPDK 源碼，其提供的 82576 和 82599 網卡驅動就直接運行在應用層，將接管網卡</p><p>收到的數據包直接傳遞到應用層的業務邏輯裡進行處理，而無需經過 Linux 內核協議</p><p>棧。當然，發往本服務器的非業務邏輯數據包還是要經過 Linux 內核協議棧的，比如</p><p>用戶的 SSH 遠程登錄操作連接等。</p><p> <strong>多線程的核間綁定：</strong></p><p>一個具有 8 核心的設備，一般會有 1 個控制面線程和 7 個或 8 個數據面線程，每一個</p><p>線程綁定到一個處理核心（其中可能會存在一個控制面線程和一個數據面線程都綁定</p><p>到同一個處理核心的情況）。這樣做的好處是最大化核心 CACHE 利用、實現無鎖設</p><p>計、避免進程切換消耗等等。</p><p> <strong>內存是另外一個核心要素：</strong></p><p>常見的內存池設計必須在這裡得以切實應用。有幾個考慮點，首先，可以在 Linux 系統</p><p>啟動時把業務所需內存直接預留出來，脫離 Linux 內核的管理。其次，Linux 一般採用 4K</p><p>每頁，而我們可以採用更大內存分頁，比如 2M，這樣能在一定程度上減少地址轉換等</p><p>的性能消耗。</p><p>3. <strong>關於 Intel 的 DPDK 框架</strong>/<strong> Netmap 開源框架</strong></p><p>隨著網絡技術的不斷創新和市場的發展，越來越多的網絡設備基礎架構開始向基於通用處理</p><p>器平臺的架構方向融合，期望用更低的成本和更短的產品開發週期來提供多樣的網絡單元和</p><p>豐富的功能，如應用處理、控制處理、包處理、信號處理等。為了適應這一新的產業趨勢，</p><p>Intel 推出了基於 Intel x86 架構 DPDK (Data Plane Development Kit，數據平面開發套件) 實現</p><p>了高效靈活的包處理解決方案。經過近 6 年的發展，DPDK 已經發展成支持多種高性能網卡</p><p>和多通用處理器平臺的開源軟件工具包。</p><p><strong>5、解決 C10M 問題的思路總結</strong></p><p><strong>綜上所述，解決 C10M 問題的關鍵主要是從下面幾個方面入手：</strong></p><p>網卡問題</p><p><strong>網卡問題：</strong>通過內核工作效率不高</p><p><strong>解決方案：</strong>使用自己的驅動程序並管理它們，使適配器遠離操作系統。</p><p>CPU 問題</p><p><strong>CPU 問題：</strong>使用傳統的內核方法來協調你的應用程序是行不通的。</p><p><strong>解決方案：</strong>Linux 管理前兩個 CPU，你的應用程序管理其餘的 CPU，中斷只發生在你允許的</p><p>CPU 上。</p><p>內存問題</p><p><strong>內存問題：</strong>內存需要特別關注，以求高效。</p><p><strong>解決方案：</strong>在系統啟動時就分配大部分內存給你管理的大內存頁。</p><p>以 Linux 為例，解決的思路就是將控制層交給 Linux，應用程序管理數據。應用程序與內核</p><p>之間沒有交互、沒有線程調度、沒有系統調用、沒有中斷，什麼都沒有。 然而，你有的是</p><p>在 Linux 上運行的代碼，你可以正常調試，這不是某種怪異的硬件系統，需要特定的工程師。</p><p>你需要定製的硬件在數據層提升性能，但是必須是在你熟悉的編程和開發環境上進行。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>網絡</a></li><li><a>編程</a></li><li><a>用戶態</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c500d29b.html alt="高級網絡編程之疑症：TCP 的 Peer 兩端同時斷開連接" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153201394276200d66036c8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c500d29b.html title="高級網絡編程之疑症：TCP 的 Peer 兩端同時斷開連接">高級網絡編程之疑症：TCP 的 Peer 兩端同時斷開連接</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a96a3a1.html alt=嵌入式linux網絡編程—學TCPIP網絡的看過來，終於有人講清楚了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a9f8dacb3f5c4b27becd312c01203d69 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a96a3a1.html title=嵌入式linux網絡編程—學TCPIP網絡的看過來，終於有人講清楚了>嵌入式linux網絡編程—學TCPIP網絡的看過來，終於有人講清楚了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6049529.html alt=嵌入式linux網絡編程——你所不知道的計算機網絡系統，精品講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/23be2c97fd8344c9aef5fb19168425ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6049529.html title=嵌入式linux網絡編程——你所不知道的計算機網絡系統，精品講解>嵌入式linux網絡編程——你所不知道的計算機網絡系統，精品講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/731d1aa.html alt="網絡編程 - TCP/IP協議" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b35dbde7fc6b4b9da051bf33eace2319 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/731d1aa.html title="網絡編程 - TCP/IP協議">網絡編程 - TCP/IP協議</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/103109d.html alt=Linux網絡編程——無連接和面向連接協議的區別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/38755fbc61154d06a243d159fdae398b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/103109d.html title=Linux網絡編程——無連接和面向連接協議的區別>Linux網絡編程——無連接和面向連接協議的區別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html alt=光纜——未來網絡主導 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/e75c1afe12354a93bad8495ad1057693 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ea1bb612.html title=光纜——未來網絡主導>光纜——未來網絡主導</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bdc59733.html alt="網絡詞名場面是什麼意思 名場面是什麼梗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bdc59733.html title="網絡詞名場面是什麼意思 名場面是什麼梗">網絡詞名場面是什麼意思 名場面是什麼梗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a002ca18.html alt=王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/26add5cdc08e4214800b25e21b623eb1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a002ca18.html title=王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯>王一博那句年度網絡流行語「不愧是我」的：正版英文翻譯</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad6f0929.html alt=谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/65c4000bda98898dcdbb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad6f0929.html title=谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼>谷歌大腦發佈神經網絡的「核磁共振」，並公開相關代碼</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8dce33e7.html alt=理解生成對抗網絡，一步一步推理得到GANs（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bee194d6fbec4d6f82e82998def3f7a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8dce33e7.html title=理解生成對抗網絡，一步一步推理得到GANs（一）>理解生成對抗網絡，一步一步推理得到GANs（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html alt=瞭解生成對抗網絡（GAN） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/634604de44ad4d17931ccc0bcf3e46ef style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1fe1c2dd.html title=瞭解生成對抗網絡（GAN）>瞭解生成對抗網絡（GAN）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2a9a3956.html alt="100 個網絡基礎知識普及，看完成半個網絡高手！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/955ea722-be77-4b2d-b87a-64a8a04c8ea8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2a9a3956.html title="100 個網絡基礎知識普及，看完成半個網絡高手！">100 個網絡基礎知識普及，看完成半個網絡高手！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/78c87167.html alt=奧迪A7車載電路與網絡連接之網絡連接 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/d34213e3b03545bd8e87ab074b54ca0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/78c87167.html title=奧迪A7車載電路與網絡連接之網絡連接>奧迪A7車載電路與網絡連接之網絡連接</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>