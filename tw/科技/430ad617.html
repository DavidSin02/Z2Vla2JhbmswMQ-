<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>理解Spring：AOP的原理及手動實現 | 极客快訊</title><meta property="og:title" content="理解Spring：AOP的原理及手動實現 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/8435d8c955b34ce68d6e3765409ff14f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/430ad617.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/430ad617.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/430ad617.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/430ad617.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/430ad617.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/430ad617.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/430ad617.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/430ad617.html><meta property="article:published_time" content="2020-11-14T21:04:29+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:29+08:00"><meta name=Keywords content><meta name=description content="理解Spring：AOP的原理及手動實現"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/430ad617.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>理解Spring：AOP的原理及手動實現</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><blockquote class=pgc-blockquote-abstract><p>作者：寧願</p><p>juejin.im/post/5c1c402b6fb9a049a570df27</p></blockquote><p><br></p><h2 class=pgc-h-arrow-right>引入</h2><p>到目前為止，我們已經完成了簡易的IOC和DI的功能，雖然相比如Spring來說肯定是非常簡陋的，但是畢竟我們是為了理解原理的，也沒必要一定要做一個和Spring一樣的東西。到了現在並不能讓我們鬆一口氣，前面的IOC和DI都還算比較簡單，這裡要介紹的AOP難度就稍微要大一點了。</p><blockquote class=pgc-blockquote-abstract><p>tips<br>本篇內容難度較大，每一步都需要理清思路，可能需要多看幾遍，多畫類圖和手動實現更容易掌握。</p></blockquote><h2 class=pgc-h-arrow-right>AOP</h2><h3 class=pgc-h-arrow-right>什麼是AOP</h3><p>Aspect Oriented Programming：面向切面編程，作用簡單來說就是在不改變原類代碼的前提下，對類中的功能進行增強或者添加新的功能。</p><p>AOP在我們開發過程中使用頻率非常的高，比如我們要在多個地方重用一段代碼的功能，這時我們可以選擇的方式很多，比如直接代碼拷貝，也可以將代碼封裝成類或方法，使用時調用。但是問題是這種方式對代碼來說有著很強的侵入性，對於程序員來說，將重複的東西拷來拷去也是一件麻煩事。</p><p>而AOP可以很好的解決這類問題，在AOP中我們可以指定對一類方法進行指定需要增強的功能。比如我們在系統中記錄數據修改的日誌，每個對數據修改的方法都要記錄，但是其實完全是一樣的方法，使用AOP能大大增加開發效率。</p><h3 class=pgc-h-arrow-right>AOP的一些概念</h3><p><strong>通知(advice)：</strong>通知定義了一個切面在什麼時候需要完成什麼樣的功能，通知和切點組成切面。</p><p><strong>切點(pointCut)：</strong>切點定義了切面需要作用在什麼地方。</p><p><strong>切面(Aspect)：</strong>是通知和切點的組合，表示在指定的時間點內對指定的地方進行一些額外的操作。</p><p><strong>鏈接點(join points)：</strong>連接點表示可以被選擇用來增強的位置，連接點是一組集合，在程序運行中的整個週期中都存在。</p><p><strong>織入(Weaving)：</strong>在不改變原類代碼的前提下，對功能進行增強。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/8435d8c955b34ce68d6e3765409ff14f><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>關於AOP的簡單分析</h2><h3 class=pgc-h-arrow-right>通知(advice)</h3><p>通知定義了一個切面在什麼時候需要完成什麼樣的功能，很明顯advice的實現不是由框架來完成，而是由用戶創建好advice然後註冊到框架中，讓框架在適當的時候使用它。這裡我們需要考慮幾個問題。</p><p><strong>用戶創建好的advice框架怎麼感知？框架如何對用戶註冊的不同的advice進行隔離？</strong></p><p>這個問題很簡單，大多數人都明白，這就類似於Java中的JDBC，Java提供一套公共的接口，各個數據庫廠商實現Java提供的接口來完成對數據庫的操作。我們這裡也提供一套用於AOP的接口，用戶在使用時對接口進行實現即可。</p><p><strong>advice的時機有哪些？需要提供哪些接口？</strong></p><p>這裡直接拿Spring中定義好的增強的時機。</p><ul class=list-paddingleft-2><li>Before：在方法調用之前調用通知</li><li>After：在方法完成之後調用通知，無論方法執行成功與否</li><li>After-returning：在方法執行成功之後調用通知</li><li>After-throwing：在方法拋出異常後進行通知</li><li>Around：通知包裹了被通知的方法，在被通知的方法調用之前和調用之後執行自定義的行為</li></ul><p>好了，我們可以使用一個接口來定義上面的處理方法，在用戶使用的時候實現方法即可，如下：</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/b8ec3fdc6fc640aa9051e41d1db5b66f><p class=pgc-img-caption></p></div><p>貌似差不多了，但是我們需要注意到，用戶在使用advice的使用，不可能說每次都是需要對上述幾種方式同時進行增強，更多可能是只需要一種方式。但是如果只有一個接口的話就要求用戶每次都需要實現所有的方法，這樣顯的十分的不友好。</p><p>我們應該讓這些不同的方法對於用戶來說是可選，需要什麼就實現哪一個。那麼我們需要將每一個方法都對應一個接口嗎？不需要。上面的after(…)和afterSuccess(…)都是在方法執行之後實現，不同在於一個需要成功後的返回值而另一個不需要，這兩個可以作為一個實現由返回值區分。進行異常後的增強處理，這要求對被執行的方法進行包裹住，捕獲異常。這就和環繞差不多了，兩者可以放一起。</p><p>類圖：</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/2d2b20c4375642a495bff396f4ebe773><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>pointcut</h3><p>advice基本就這樣了，下面就是pointcut了。說起切點，用過Spring中的AOP的肯定對切入點表達式比較瞭解了，在Spring中用戶通過切入點表達式來定義我們的增強功能作用在那一類方法上。這個切入點表達式十分的重要。對於我們的手寫AOP來說，也需要提供這樣的功能。當然表達式由用戶來寫，由我們的框架來解析用戶的表達式，然後對應到具體的方法上。</p><p>如何解析用戶定義的表達式？上面說到了，由一串字符來匹配一個或多個不同的目標，我們第一個反應肯定是正則表達式，很明顯這個功能使用正則是可以進行實現的。但實際上這樣的表達式還有很多。比如AspectJ，Ant path等。具體使用什麼就自己決定了，這裡我實現正則匹配這一種。</p><pre><code>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)throws-pattern?)</code></pre><p><strong>1.如何找到我們要增強的方法呢？</strong></p><p>當我們確定好有哪些類的哪些方法需要增強，後面就需要考慮我們如何獲取到這些方法(對方法增強肯定需要獲取到具體的方法)。</p><p><strong>2.有了表達式我們可以確定具體的類和方法，表達式只是定義了相對的路徑，如何根據相對路徑獲取Class文件地址？</strong></p><p>對bean實例的增強是在初始化的時候完成的，初始化的時候判斷如果需要增強，則通過代理生成代理對象，在返回時由該代理對象代替原實例被註冊到容器中。</p><p><strong>3.Class文件有了，怎麼取到類中的方法？</strong></p><p>在前面章節中我們獲取過方法，使用Class對象即可獲取所有的非私有方法。在實際調用被增強方法時，將該方法與所有的advice進行匹配，如果有匹配到advice，則執行相應的增強。當然我們並不需要每一次都需要遍歷獲取，為了效率可以對方法和增強的advice進行緩存。</p><h3 class=pgc-h-arrow-right>Aspect/Advisor</h3><p>我們有了增強功能的實現和確定了需要增強那些方法。到了現在我們就需要將拿到的方法進行增強了。</p><p>在運行過程中對已有的類或方法的功能進行增強同時又不改變原有類的代碼，這妥妥的代理模式嘛。如果不理解代理模式的可以看這個教程:代理模式，代理模式可以在運行期間對方法進行增強，很好的實現我們的需求。</p><p><strong>到現在，用戶要實現AOP需要提供什麼呢？</strong></p><p>用戶如果要實現AOP，首先必須提供一個Advice(通知)來增強功能，一個expression表達式來定義增強哪些方法，實際上還需要指定使用哪一個解析器來解析傳入的表達式(正則，AspectJ…)。如果單獨提供這些東西對用戶來說還是比較麻煩的，而框架的作用是幫用戶簡化開發過程中的流程，儘量的簡單化。所以在這裡我們可以對用戶提供一個新的外觀(門面)，讓用戶更加簡單的使用。這裡其實是使用了外觀模式的思想。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0942dd5cfb9a4f3ca5cf395d473d7423><p class=pgc-img-caption></p></div><p>當我們在註冊bean和調用方法時，對方法的增強會用到Advisor，所以我們還需要提供一個註冊和獲取Advisor的接口。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c8a7d26c5b5845da8263af4b353e9772><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>Weaving</h3><p>現在我們有了切面，用戶也已經能夠比較簡單的來定義如何使用切面，最重要的一步到了，那就是我們應該如何對需要增強的類進行增強呢？什麼時候進行增強？</p><p><strong>上面已經說過了對類和方法進行增強就使用代理模式來增強。那麼我們作為框架該在什麼什麼時候來增強呢？</strong></p><p>這裡有兩種時機。一是在啟動容器初始化bean的時候就進行增強，然後容器中存放的不是bean的實例，而是bean的代理實例。二是在每一次使用bean的時候判斷一次是否需要增強，需要就對其增強，然後返回bean的代理實例。這兩種方法很明顯第一種比較友好，只是讓容器的啟動時間稍微長了一點，而第二種在運行時判斷，會使得用戶的體驗變差。</p><p><strong>在初始化bean的那個過程來增強？會不會存在問題？</strong></p><p>根據之前的介紹，我們的框架初始化bean是在BeanFactory中進行，還包括bean的實例化，參數注入以及將bean放入容器中等。很明顯對bean的增強應該是在bean實例化完成並在還沒有放進容器中的時候。那麼也就是在BeanFactory的doGetBean方法中了。</p><p>這裡有一個小問題在於，doGetBean方法做的事情已經夠多了，繼續往裡加入代碼無疑會使得代碼大爆炸，很難維護也不易擴展。為了解決這個問題這裡我們可以使用觀察者模式來解決這一問題，將doGetBean方法中每一個過程都作為一個觀察者存在，當我們需要添加功能是既可以添加一個觀察者然後注入，這樣不會對已有代碼做出改變。</p><p>定義一個觀察者的接口：</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/fe446624565548749cec8ec04632e519><p class=pgc-img-caption></p></div><p>這裡我們暫時只定義了aop應用的觀察者，其他的比如實例化，參數注入後面慢慢加。</p><p>BeanPostProcessor是在BeanFactory中對bean進行操作時觸發，我們也應該在BeanFactory中加入BeanPostProcessor的列表和註冊BeanPostProcessor的方法。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e1e0808394064b2f84b126bcbfaca0c5><p class=pgc-img-caption></p></div><p>在這裡的觀察者模式的應用中，BeanFactory充當subject角色，BeanPostProcessor則充當observer的角色，BeanFactory監聽BeanPostProcessor，我們可以將功能抽出為一個BeanPostProcessor，將其註冊到BeanFactory中，這樣既不會使得BeanFactory中代碼過多，同時也比較容易做到了功能的解耦，假設我們不需要某一個功能，那麼直接接觸綁定即可而不需要任何其他操作。在這裡我們只實現了Aop功能的註冊。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cd0363e995ce46fcb7228ff32f46b775><p class=pgc-img-caption></p></div><p>假設我們要對其他功能也抽為一個觀察者，那麼直接繼承BeanPostProcessor接口實現自己的功能然後註冊到BeanFactory中。</p><h3 class=pgc-h-arrow-right>功能實現分析</h3><p>現在接口有了，我們現在需要考慮如何來實現功能了。那麼我們現在梳理一下我們需要做什麼。</p><ul class=list-paddingleft-2><li>在進行bean創建的時候，需要判斷該bean是否需要被增強，這個工作是由AopPostProcessor接口來做，判斷是否需要被增強和通過哪種方式來增強(JDK代理還是cglib代理)。如果需要增強則創建代理對象，註冊到容器是則使用該代理對象。</li><li>在1中說到需要創建代理對象，那麼我們也就需要提供代理的實現，目前代理主要是通過JDK代理和cglib代理模式，兩者的主要區別在去JDK代理模式必須要求類實現了接口，而cglib則不需要。</li><li>在實際對實例增強方法調用時，框架需要對該方法的增強方法進行調用，如何進行調用以及存在多個增強方法是如何來調用。</li></ul><p>現在我們對以上的問題分別分析解決。</p><h3 class=pgc-h-arrow-right>代理實現</h3><p>代理的實現就是常規的實現，我們提供對外創建代理實例的方法和執行方法的處理。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/e010afba9ada430bb9d7a7c5ea493709><p class=pgc-img-caption></p></div><p>JDKDynamicProxy和CglibDynamicProxy共同實現了AopProxy接口，除此之外要實現代理JDKDynamicProxy還需實現InvocationHandler接口，CglibDynamicProxy還需實現MethodInterceptor接口。</p><p>可能有朋友注意到了，在創建代理的類中都有一個BeanFactory的變量，之所以會用到這一個類型的變量是因為當方法運行時匹配到advice增強時能從BeanFactory中獲取Advice實例。而Advisor中並沒有存Advice的實例，存儲的是實例名(beanName)。</p><p>但是問題在於這個變量的值我們如何獲取，對於一般的bean我們可以從容器中獲取，而BeanFactory本身就是容器，當然不可能再從容器中獲取。我們首先梳理下獲取變量值的方法：</p><ul class=list-paddingleft-2><li>通過依賴注入從容器中獲取，這裡不合適。</li><li>直接創建一個新的值，這裡需要的是容器中的實例，重新創建新的值肯定沒了，如果再按照原流程走一次創建一模一樣的值無疑是一種愚蠢的做法，這裡也不合適。</li><li>傳參，如果方法的調用流程可以追溯到該變量整個流程，可以通過傳參的方式傳遞</li><li>Spring中的做法，和3差不多，也是我們平時用的比較多的方法。提供一系列接口，接口唯一的作用就是用於傳遞變量的值，並且接口中也只有一個唯一的Set方法。</li></ul><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/bd9f1938c960476788ab0fc86ac6ecf6><p class=pgc-img-caption></p></div><p>提供一個Aware父接口和一系列的子接口，比如BeanFactoryAware ,ApplicationContextAware用於將這些值放到需要的地方。如果那個類需要用到Spring容器的變量值，則直接實現xxxAware接口即可。Spring的做法是在某一個過程中檢測有哪些類實現了Aware接口，然後將值塞進去。</p><p>這裡我們的準備工作都已經差不多了，後面就是開始將定義好的接口中的功能實現了。</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/18169312b4954cfe85277b6a19895186><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>如果存在多個不同類型的增強方法時如何調用</h3><p>由於在增強過程中，對於同一個方法可能有多個增強方法，比如多個環繞增強，多個後置增強等。通常情況下我們是通過一個for循環將所有方法執行，這樣的：</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6d59c9dd21e7416b8c0f4c5567c6c611><p class=pgc-img-caption></p></div><p>但是這裡的問題在於，這中間的任何一個環繞方法都會執行一次原方法(被增強的方法)，比如在環繞增強中的實現是這樣的：</p><pre><code>//before working//invoke 被加強的方法執行//after working </code></pre><p>這樣如果還是一個for循環執行的話就會導致一個方法被多次執行，所以for循環的方法肯定是不行的。我們需要的是一種類似於遞歸調用的方式嵌套執行，這樣的：</p><div class=pgc-img><img alt=理解Spring：AOP的原理及手動實現 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0bdb41a0d0f847f6a9fc8c683d016d19><p class=pgc-img-caption></p></div><p>前面的方法執行一部分進入另一個方法，依次進入然後按照反順序結束方法，這樣只需把我們需要加強的方法放在最深層次來執行就可以保證只執行依次了。而責任鏈模式可以很好的做到這一點。</p><p>調用流程的具體實現：</p><pre><code>public class AopAdviceChain {    private Method nextMethod;    private Method method;    private Object target;    private Object[] args;    private Object proxy;    private List&lt;Advice&gt; advices;    //通知的索引 記錄執行到第多少個advice    private int index = 0;    public AopAdviceChain(Method method, Object target, Object[] args, Object proxy, List&lt;Advice&gt; advices) {        try {            //對nextMethod初始化 確保調用正常進行            nextMethod = AopAdviceChain.class.getMethod("invoke", null);        } catch (NoSuchMethodException | SecurityException e) {            e.printStackTrace();        }        this.method = method;        this.target = target;        this.args = args;        this.proxy = proxy;        this.advices = advices;    }    public Object invoke() throws InvocationTargetException, IllegalAccessException {        if(index &lt; this.advices.size()){            Advice advice = this.advices.get(index++);            if(advice instanceof BeforeAdvice){                //前置增強                ((BeforeAdvice) advice).before(method, args, target);            }else if(advice instanceof AroundAdvice){                //環繞增強                return ((AroundAdvice) advice).around(nextMethod, null, this);            } else if(advice instanceof AfterAdvice){                //後置增強                //如果是後置增強需要先取到返回值                Object res = this.invoke();                ((AfterAdvice) advice).after(method, args, target, res);                //後置增強後返回  否則會多執行一次                return res;            }            return this.invoke();        }else {            return method.invoke(target, args);        }    }}</code></pre><p>在代碼中可以看到，如果是前置增強則直接調用，而如果是環繞或者後置增強，則都不會立刻執行當前的增強方法，而是類似遞歸調用一樣，進行下一個執行。這樣就能保證被增強的方法不會被多次執行，同時對方法增強的順序也不會亂。</p><h2 class=pgc-h-arrow-right>代碼託管</h2><p>在上面基本都只是分析了主要的原理和實現思路，在實際實現過程中涉及的類和藉口會更多，一些涉及到公共方法或者工具類上面都沒有列出，由於代碼較多限於篇幅原因不在文章列出。若需看實現，代碼已經全部託管到GitHub。</p><blockquote class=pgc-blockquote-abstract><p>https://github.com/lliyu/myspring</p></blockquote><h2 class=pgc-h-arrow-right>小結</h2><p>AOP的簡單實現這裡也算是完成了，AOP算是比較難的內容了，主要是涉及到知識點很多。使用的設計模式也很多，包括工廠模式，外觀模式，責任鏈模式等等。並且也和前面的IOC和DI的內容緊密相關。所以大家最好還是理一遍思路後能手動進行實現一次，這樣掌握起來也比較容易。</p><p><br></p><p><strong>我目前是在職Java開發，如果你現在正在瞭解Java技術，想要學好Java，渴望成為一名Java開發工程師，在入門學習Java的過程當中缺乏基礎的入門視頻教程，你可以關注並私信我：01。我這裡有一套最新的Java基礎JavaSE的精講視頻教程，這套視頻教程是我在年初的時候，根據市場技術棧需求錄製的，非常的系統完整。</strong></p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Spring</a></li><li><a>AOP</a></li><li><a>手動</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html alt="Spring AOP簡介與底層實現機制——動態代理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/413780d1-cf47-4038-9471-b686d97aa99b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b91a8349.html title="Spring AOP簡介與底層實現機制——動態代理">Spring AOP簡介與底層實現機制——動態代理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html alt=Spring框架AOP技術 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/760bf32faca443cb8e28ed0b9bc20205 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b5dd97d4.html title=Spring框架AOP技術>Spring框架AOP技術</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html alt=Spring面向切面編程AOP的初步瞭解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6eb76749eacf41f1ac8d6bb660ae18ab style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/60d27d99.html title=Spring面向切面編程AOP的初步瞭解>Spring面向切面編程AOP的初步瞭解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html alt=小實例理解Spring中的AOP----面向切面編程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/35942664cec244f88d6a0f7b1e7067cc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b949fbad.html title=小實例理解Spring中的AOP----面向切面編程>小實例理解Spring中的AOP----面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html alt="Spring AOP 面向切面編程需要知道的事" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/63832e5a-4ec8-451b-87cf-c6295ac2adf5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2798be0b.html title="Spring AOP 面向切面編程需要知道的事">Spring AOP 面向切面編程需要知道的事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html alt="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fcef4925.html title="Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現">Spring AOP：Spring的面向切面，提供AOP（面向切面編程）的實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html alt=Spring—面向切面編程（AOP）詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3ad8b3ec-d7c5-4b89-9b46-e473a4f5d570 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/af398a38.html title=Spring—面向切面編程（AOP）詳解>Spring—面向切面編程（AOP）詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html alt="Spring學習（4）：Spring AOP" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/be8a179a4a8040648c1fb5a0532cc84b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/92488c35.html title="Spring學習（4）：Spring AOP">Spring學習（4）：Spring AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html alt="Spring：AOP 面向切面編程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2e916acf35c540c59694eae279114599 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/90a3b194.html title="Spring：AOP 面向切面編程">Spring：AOP 面向切面編程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html alt=使用註解方式配置Spring中的面向切面編程AOP class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c98c28c3.html title=使用註解方式配置Spring中的面向切面編程AOP>使用註解方式配置Spring中的面向切面編程AOP</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0ef7083e.html alt="溫故知新——Spring AOP（一）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0ef7083e.html title="溫故知新——Spring AOP（一）">溫故知新——Spring AOP（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0013439.html alt="關於Spring AOP的靈魂十問" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/f76928765e9444fd8b608eab1ae51b90 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0013439.html title="關於Spring AOP的靈魂十問">關於Spring AOP的靈魂十問</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html alt="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/daa2cfd29ec34306a4be6f3f257b824b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/000afa08.html title="Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解">Spring Boot 2.x基礎教程：Swagger接口分類與各元素排序問題詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html alt="[Spring] 深入瞭解事務原理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/a8c6dbd7c51741f5a76262e8e2c7a670 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/090306a0.html title="[Spring] 深入瞭解事務原理">[Spring] 深入瞭解事務原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>