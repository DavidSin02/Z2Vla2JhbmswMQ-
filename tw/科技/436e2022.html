<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 | 极客快訊</title><meta property="og:title" content="「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/769d1d2c04b9410aa18cd0add525013f"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/436e2022.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/436e2022.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/436e2022.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/436e2022.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/436e2022.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/436e2022.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/436e2022.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/436e2022.html><meta property="article:published_time" content="2020-11-14T21:04:01+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:01+08:00"><meta name=Keywords content><meta name=description content="「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/436e2022.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>FPGA調試本身就是挺辛苦的一件事情，尤其是在剛開始調試FPGA的時候，無論培訓的時候如何強調一些注意事項，如跨時鐘域問題，如接口問題，以及RAM讀寫衝突問題，但一旦做起項目來，每每還是有同學必須要親自往這些坑裡面跳一次才真正懂得這些BUG的含義。如雙口RAM在功能仿真時沒有出現問題，但上板調試過程中運行很久才偶爾出現一次BUG，這時就需要花費大量的時間去追溯問題的源頭，最後花一週甚至更長的時間才能找到是雙口RAM讀寫衝突的問題，時間早早的就浪費掉了。事實上，上面說跨時鐘域或者雙口RAM讀寫衝突的這些問題是可以通過時序仿真仿真出來的。</p><p>FPGA驗證在芯片設計流程中具有重要的作用，有時候為了找到某些BUG，不得不對FPGA綜合出來的網表進行後仿真。後仿真又叫時序仿真，跟課程前面介紹的對寫出來的Verilog hdl設計代碼和testbench代碼建工程進行的功能仿真不同，時序仿真是把綜合出來電路中的時延信息加入到仿真的過程中，模擬出跟更接近於在FPGA上真實運行的情況。本文以Quartus II軟件為例進行介紹後仿真的步驟和流程。ISE或VIVADO流程類似或關聯ModelSim後更自動化。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/769d1d2c04b9410aa18cd0add525013f><p class=pgc-img-caption></p></div><h1><strong>什麼是功能仿真？什麼是時序仿真</strong></h1><p>仿真過程是正確實現設計的關鍵環節，用來驗證設計者的設計思想是否正確，及在設計實現過程中各種分佈參數引入後，其設計的功能是否依然正確無誤。仿真主要分為功能仿真和時序仿真。功能仿真是在設計輸入後進行； 時序仿真是在邏輯綜合後或佈局佈線後進行。</p><p>1. 功能仿真 ( 前仿真 )</p><p>功能仿真是指在一個設計中， 在設計實現前對所創建的邏輯進行的驗證其功能是否正確的過程。 佈局佈線以前的仿真都稱作功能仿真， 它包括綜合前仿真（ Pre-Synthesis Simulation ）和綜合後仿真（ Post-Synthesis Simulation ）。 綜合前仿真主要針對原理框圖的設計 ; 綜合後仿真既適合原理圖設計 , 也適合基於 HDL 語言的設計。</p><p>2. 時序仿真（後仿真）</p><p>時序仿真使用佈局佈線後器件給出的模塊和連線的延時信息， 在最壞的情況下對電路的行為作出實際地估價。 時序仿真使用的仿真器和功能仿真使用的仿真器是相同的， 所需的流程和激勵也是相同的； 惟一的差別是為時序仿真加載到仿真器的設計包括基於實際佈局佈線設計的最壞情況的佈局佈線延時， 並且在仿真結果波形圖中，時序仿真後的信號加載了時延， 而功能仿真沒有。</p><h1>一、用Quartus II建立工程。</h1><p class=ql-align-justify>具體過程可參考如下鏈接：</p><p class=ql-align-justify>https://jingyan.baidu.com/article/cbcede07ef59cf02f40b4ddb.html。建立工程後的文件如下圖所示。我們以一個簡單的8位計數器為例進行說明。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/680aaa699955467e9bb5f87fac0c6bf8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>建立工程的過程中可以配置好綜合之後要產生用來做後仿真的網表文件，如果沒有提前配置，也可以建好工程後再配置，具體如下圖，點擊右鍵，選擇settings.</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/f85a624c8f31429789e2e9ab1b405d38><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>settings打開後出來如下窗口，在左側選擇Simulation，在右側EDA Netlist Writer settings裡面選擇門級網表產生的語言以及路徑，之後確定即可。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/01a810d6473f4026b892d81a52611a7a><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>如下圖，點擊編譯按鈕，開始進行綜合。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0fe3d2e1d315436697bff5e897e503b8><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>綜合後的界面如下。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/11dfd2af4af340a89fcd3be5a8acd15d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>找到剛設置的網表文件的輸出目錄，在該目錄下要選擇兩個文件，一個是.vo的網表文件，另一個是.sdo的時延信息文件。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/95de252cfb3f4a3db7f64161e40a8c46><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>打開.vo的文件可以看到裡面有如下圖的三行，就是把時延信息文件.sdo反標到網表文件中。沒有這一句或者時延信息反標不成功，是做不成後仿真的。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/ce6935bef0824821975779c9a294753d><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><h1>用ModelSim進行後仿真</h1><p class=ql-align-justify>把上述過程中產生的.vo和.sdo文件拷貝到要做後仿真的工程文件夾下建立仿真工程，除了測試文件採用前仿真的測試文件外，還要添加一些Quartus的庫文件，主要有三個，220model.v，altera_mf.v和cyclone_atoms（這個文件需要根據進行綜合時選擇的FPGA的型號來定）。注意，此工程是不能添加原始設計代碼的，而是用綜合後的網表文件替代。建立工程後的截圖如下。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0d4f8b1a0af443c9badf17ffc72507ba><p class=pgc-img-caption>時序仿真的工程</p></div><p class=ql-align-justify><br></p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/cc863a0a3dc044ab84582aba10e675f9><p class=pgc-img-caption>功能仿真的工程</p></div><p class=ql-align-justify>從上面兩圖可以明顯對比出，功能仿真和時序仿真工程中的代碼僅有count.v（功能仿真）和count.vo（時序仿真）不同，其餘都完全一樣。</p><p class=ql-align-justify>編譯成功後開始仿真。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b7dcf58d44fa4853976394ab91e963a5><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>右鍵點擊下圖中tb_count選擇信號到波形文件的窗口。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e76a18bd8aae4beebdc2ffa9e3e7a9bc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>運行後的結果截圖，可以看出計數器是按照時鐘的上升沿在自加1跳變的。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5a546929d8004495806c934ad1efbbdc><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>選擇局部，計數數據由7跳變到8的時刻進行放大，可以看到，7狀態後不是立即跳變到8的，而是經過了很多箇中間狀態。同時開始跳變的時刻也不是時鐘的上升沿到來後立即跳變的，而是延遲了一段時間才開始的。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/c544b68c7bc74338949e90a3de37e548><p class=pgc-img-caption></p></div><p class=ql-align-justify><br></p><p class=ql-align-justify>再進行放大，可以看到7變為8中間還經歷了11和9兩個中間狀態，同時觀察下面每Bit信號的跳變，可以發現每1位信號的跳變時刻也是不同的，這是因為在FPGA內部，總線型信號佈局佈線後每bit的走的路徑是不同的，連線引入的時延也是不同的，這也進一步證明了後仿真的時延信息是成功的反標到了網表文件中了。同時，這種總線型信號跳變有很多中間狀態的特點，也是區別於前仿真或者叫功能仿真的一種最直接的標記。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5409b27c8fc64da892b6ea752ee9271c><p class=pgc-img-caption></p></div><p class=ql-align-justify>我們回過頭來對比一下功能仿真的波形，如下圖，很明顯的看出來在計數跳變的過程中，沒有任何中間狀態的改變。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/27ac59e5d13e494fa4d97f896d6db1a1><p class=pgc-img-caption></p></div><h1 class=ql-align-justify>動圖介紹ModelSim建工程到仿真</h1><p class=ql-align-justify>使用Modelsim建立仿真環境進行仿真的操作步驟動圖如下：</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6c88dd1fdc11441da0b41ae768e0a0ef><p class=pgc-img-caption></p></div><h1 class=ql-align-justify>補充知識--前仿真和後仿真的概念</h1><p class=ql-align-justify>功能仿真和時序仿真常常又分別被叫做前仿真和後仿真。</p><p class=ql-align-justify>前仿真和後仿真的區別：前仿真就是指綜合前的仿真，也就是行為級的仿真，如你在Modelsim直接寫代碼的仿真。後仿真指的是綜合後的仿真，也就是功能仿真。比如你在Modelsim中用VHDL寫了個計數器，行為級得仿真通過了，你把它加到quartus中或者其他的綜合工具進行綜合，綜合完後生成功能網表，它把行為語言變成寄存器傳送級語言，這時候你把它加到Modelsim中仿真叫後仿真，後仿真成功後，你還要在quartus中進行映射，佈局佈線，完後進行時序分析，生成時序網表，描述器件里門或者佈線的延時，最後把延時網表和功能網表一起加到Modelsim中仿真叫門級仿真。</p><p class=ql-align-justify>門級仿真和時序仿真的區別：門級仿真是quartus生成的網表文件.vo。門級則不考慮互聯延遲，二隻考慮了器件的延遲。時序仿真是選擇具體器件並佈局佈線後進行的包含定時關係的仿真，主要驗證是否滿足時間約束關係、延時、最大工作頻率和消耗的資源等。時序仿真是需添加時延文件.sdo。</p><p class=ql-align-justify>modelsim 是專門進行仿真的軟件，可以分別進行前仿真和後仿真。前仿真也稱為功能仿真，主旨在於驗證電路的功能是否符合設計要求，其特點是不考慮電路門延遲與線延遲，主要是驗證電路與理想情況是否一致。可綜合FPGA代碼是用RTL級代碼語言描述的，其輸入為RTL級代碼與testbench。後仿真也稱為時序仿真或者佈局佈線後仿真，是指電路已經映射到特定的工藝環境以後，綜合考慮電路的路徑延遲與門延遲的影響，驗證電路能否在一定時序條件下滿足設計構想的過程，是否存在時序違規。其輸入文件為從佈局佈線結果抽象出來的門級網表、testbench和擴展為sdo或sdf的標準時延文件。sdo、sdf的標準時延文件不僅包含門延遲，還包括實際佈線延遲，能較好地反映芯片的實際工作情況。一般來說後仿真是必選的，檢查設計時序與實際的FPGA運行情況是否一致，確保設計的可靠性和穩定性。</p><p>在進行網表仿真時，經常會遇到一些不定態問題（紅線的說法稍顯不專業），通常一個模塊中某個寄存器出現X狀態，就會造成整個仿真都出現X狀態，仿真無法進行。這時我們需要找出最先出現X態的邏輯，找出錯誤的原因並消除後才能重新進行仿真。</p><p>a. 首先應該查看是否所有的RAM都進行了初始化操作。雖然很多RAM在實現功能時並不需要初始化，但後仿時沒有初始化的RAM讀出X態，X會蔓延出去，造成整個系統都出現X態。可採用verilog中系統任務readmemh對RAM進行初始化操作。</p><p>b. 異步時鐘域信號賦值很可能會導致後仿出現紅線，但這並不能說明系統錯誤，通常我們讓仿真平臺不去檢查異步時鐘域賦值導致的時序違例，從而消除這部分紅線。</p><p>c. DUT與外部testbench模型接口時序不匹配導致，系統採進來數據錯誤導致紅線。比如以太網的GMII接口，最開始建立ephy模型時是在RTL仿真環境下描述的，在Rx_clk上升沿發出Rxd數據；但在做後仿真時由於時延等的影響，按上升沿進來的數據就會出現時序違例。這時就需要我們修改ephy模型，讓數據Rxd在上升沿後延遲一段時間再送出，使GMII接口滿足時序要求。</p><p>d. 組合邏輯路徑過長導致的時序為例。如下圖所示是讀取RAM的時序波形，讀地址ADR，讀使能ME，時鐘CLK，當時鐘上升沿到來時，應該讀取ADR為0x40地址的數據，但是由於兩個寄存器之間的組合邏輯時延很大，在讀RAM的上升沿到來時RAM地址沒有保持穩定，出現時序為例，導致輸出數據線是X態。如果是在代碼設計時，我們應該儘量避免這種情況的發生，減小組合邏輯的複雜度以減小時延。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/7ff9fbb322e449dd9a011dc01465e4f6><p class=pgc-img-caption>後仿中時序問題</p></div><h1>加快後仿真的方法</h1><p>在做後仿時，跑1ms的數據通常是前仿的幾十倍，甚至幾百倍，所以如果要把前仿的所有測試例都跑完通常幾天幾夜也不一定能走完所有流程，而且仿真過程中還可能經常遇到一些問題，阻止仿真進行下去。如果能夠加快仿真的速度，將會大大提高我們的工作效率。</p><p>a. 通常測試過程中，我們會把互相不影響的測試例分開運行，這樣既可以同時運行多個測試例，又可以在某一個測試例發生錯誤時，減少重新測試需要的時間。</p><p>b. 在運行某一個測試例時，如果這個測試例需要運行的模塊可以完全獨立於其它模塊，那麼我們就可以利用force語句將其它模塊的時鐘強制拉低，這樣其它模塊就不會運行。例如在測試CPU的外設時，並不會對設計模塊部分進行任何操作，如果把設計模塊的時鐘拉低，會大大縮短外設測試的時間。但在做後仿時force語句應慎用，如果把設計模塊裡的時鐘拉低，跟這一模塊相連的時鐘信號也可能被拉低，造成需要測試的部分無法運行，只有把測試部分模塊的時鐘重新釋放（release）掉才能正常運行。</p><p>c. 有些需要CPU初始化的RAM，如流控、隊列門限等RAM，在CPU寫RAM的過程需要大量的時間，如果RAM讀寫測試已經通過，沒有必要再通過CPU寫RAM，可以利用上面RAM初始化文件的方法，把需要配置的值寫進RAM中，可以大大縮短運行時間。</p><p class=ql-align-justify><br></p><h1>應用實戰</h1><p>雙口RAM的讀寫衝突問題在FPGA調試中經常遇到，並且，往往是那種費了好大勁追信號追到吐血後才確認到的問題。在初學FPGA調試中，常常為了所謂的省事，在寫代碼設計仿真階段就忽略了雙口RAM的讀寫衝突問題（讀和寫對同一個地址同時進行操作，功能仿真時可能沒有出現，但因為有時延的原因，在時序仿真時就出現了），導致在FPGA上板調試中浪費大量的時間。在進行FPGA工程上板調試前，如果能夠進行雙口RAM的後仿真，就可以避免後期無窮盡的追信號最後定位到雙口RAM讀寫衝突上了。希望能夠給大家提個醒，內容雖然簡單，但的確是不容忽視的一個隱藏很深的大問題。</p><p>FPGA 內部塊RAM 的讀時序如下圖：</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/87d5d4043fd54a10a4e49fb762db6c67><p class=pgc-img-caption></p></div><p>可知，塊RAM的讀延時為兩個時鐘週期。</p><p>FPGA 內部塊RAM 的寫時序如下圖：</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4db076b8611a419da803c6e126c2399e><p class=pgc-img-caption></p></div><p>可知，塊RAM 的寫延時為0，但是RAM 中的內容是在寫的下一個時鐘改變。</p><p>在進行代碼設計時應該儘量避免對一塊RAM的同一個地址同時進行讀寫操作，防止讀寫衝突時讀出數據是X態。</p><p>對於單端口RAM不能對同一RAM進行讀寫，對於雙端口RAM可以從兩個端口對同一地址進行讀操作，但不能同時進行寫操作也不能同時進行讀寫操作。</p><p>Ø <strong>問題</strong>：</p><p>隊列長度信息RAM a b口讀寫異常，更新出錯。</p><p>Ø <strong>現象：</strong></p><p>端口卡死，某隊列長度達到最大門限，但是發送調度顯示隊列為空，新數據幀入隊申請，不滿足門限要求而丟棄，輸出沒有調度結果，也不能出隊操作；</p><p>Ø <strong>分析定位：</strong></p><p>根據現象中停止發送，對隊列長度信息更新相關信號進行Debug測試，定位出問題的根源位置如圖a所示，該隊裡進行入隊操作後，隊列長度信息被入隊調度通過隊列信息RAM a口更新寫入長度13，此時出隊操作正在執行，在獲取隊列長度信時，在a口剛寫入後的一個clk，讀取得到隊列長度信息為12，再經過1個clk，數據穩定在13；但是異常數據12被出隊操作獲取到並用於出隊號隊列長度的更新，隊列長度更新出錯，若干次操作後，當最後一幀出隊完成後，會將隊列長度更新為負數，如圖b所示，FPGA中不操作負數，即二進制中很大的正數，遠大於隊列最大門限，後面再進行入隊操作時，入隊操作不滿足門限要求，無法入隊操作，同時出隊操作認為隊列為空，不會調度該隊列出隊操作，進入卡死狀態；隊列長度13的二進制表示為1101’b，12的二進制表示為1100’b，說明出現了單bit翻轉錯誤的問題。</p><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1616eb76b41946bc82b6f1530aa8f8bc><p class=pgc-img-caption>圖a 雙口RAM a b口讀寫異常</p></div><div class=pgc-img><img alt=「源碼」用ModelSim做FPGA的時序仿真，看這一篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/d0eb826769ff482a96aa192cbe724107><p class=pgc-img-caption>圖b 隊列長度信息更新出現負數</p></div><p>Ø <strong>解決方法：</strong></p><p>首先考慮對RAM輸出加寄存操作，但是這樣會整體引入操作時延，即使入隊和出隊操作不是同一隊列，每次在RAM讀數據情況下都需要多等一個clk，為了解決該問題，採用的方法是在出隊操作需要讀隊列長度時，如果前一個時刻a口剛更新該隊列，此時a口晚一個clk再用數據，保證第二個clk讀出的數據是a口寫入穩定輸出的，其他情況下不引入時延。</p><h1>源碼</h1><p>1、tb_count.v</p><p>`timescale 1ns/100ps</p><p>module tb_count;</p><p>reg clk;</p><p>reg reset;</p><p>reg d;</p><p>wire [7:0] q;</p><p>initial</p><p>begin</p><p>clk=1'b0;</p><p>reset = 1'b0;</p><p>d = 1'b0;</p><p>#10 reset = 1'b1;</p><p>#1 d = 1'b1;</p><p>#10 reset = 1'b0;</p><p>#34 d = 1'b0;</p><p>#1000 $stop;</p><p>end</p><p>always #10</p><p>clk = ~clk;</p><p>counter u_counter(</p><p>.clk(clk),</p><p>.reset(reset),</p><p>.d(d),</p><p>.q(q)</p><p>);</p><p>endmodule</p><p>2、counter.v</p><p>`timescale 1ns/100ps</p><p>module counter(</p><p>clk,</p><p>reset,</p><p>d,</p><p>q );</p><p>input clk;</p><p>input d;</p><p>input reset;</p><p>output [7:0] q;</p><p>reg [7:0] q;</p><p>reg [7:0] q_ff1;</p><p>reg [7:0] q_ff2;</p><p>reg d_ff1;</p><p>reg d_ff2;</p><p>wire d_pos;</p><p>wire d_neg;</p><p>always @(posedge clk or posedge reset)</p><p>begin</p><p>if(reset == 1'b1)</p><p>d_ff1&lt;= 1'b0;</p><p>else</p><p>d_ff1&lt;=#1 d;</p><p>end</p><p>always @(posedge clk or posedge reset)</p><p>begin</p><p>if(reset == 1'b1)</p><p>d_ff2&lt;= 1'b0;</p><p>else</p><p>d_ff2&lt;=#1 d_ff1;</p><p>end</p><p>assign d_pos = d & (~d_ff1);</p><p>assign d_neg = ~d & d_ff1;</p><p>always @(posedge clk or posedge reset)</p><p>begin</p><p>if(reset == 1'b1)</p><p>q&lt;= 8'b0;</p><p>else</p><p>q&lt;= q + 1'b1;</p><p>end</p><p>always @(posedge clk or posedge reset)</p><p>begin</p><p>if(reset == 1'b1)</p><p>q_ff1&lt;= 8'b0;</p><p>else</p><p>q_ff1&lt;= q ;</p><p>end</p><p>always @(posedge clk or posedge reset)</p><p>begin</p><p>if(reset == 1'b1)</p><p>q_ff2&lt;= 8'b0;</p><p>else</p><p>q_ff2&lt;= q_ff1 ;</p><p>end</p><p>endmodule</p><p>全文完。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>源碼</a></li><li><a>ModelSim</a></li><li><a>FPGA</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html alt=網站源碼，服務器，域名三者是什麼關係？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S1xQDgS3bmZd8q style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c09a7c2.html title=網站源碼，服務器，域名三者是什麼關係？>網站源碼，服務器，域名三者是什麼關係？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html alt=FPGA無線通信課程連載——擾碼的原理及實現 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RzH3OlM2Sr7uEv style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac5c47fd.html title=FPGA無線通信課程連載——擾碼的原理及實現>FPGA無線通信課程連載——擾碼的原理及實現</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html alt=HashMap源碼分析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4852d5083ec340be9f50ded10636e4b0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3a5fae7e.html title=HashMap源碼分析>HashMap源碼分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html alt="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5ab1d67934084ab6bd585f4c84094c76 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e590a5d4.html title="thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究">thinkphp6學習教程與源碼 tp6開源CMS系統源碼研究</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html alt=FPGA管腳調整注意事項及技巧 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/Rt0Fp44Iqh26UT style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bd4ab0f8.html title=FPGA管腳調整注意事項及技巧>FPGA管腳調整注意事項及技巧</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dbf8b0cf.html alt=Tomcat源碼分析之整體架構 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531465870453535efa0b79 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dbf8b0cf.html title=Tomcat源碼分析之整體架構>Tomcat源碼分析之整體架構</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/07f82832.html alt="SynchronousQueue 同步隊列入門使用&源碼詳解" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f76c27ed738844d099b011022d2e054f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/07f82832.html title="SynchronousQueue 同步隊列入門使用&源碼詳解">SynchronousQueue 同步隊列入門使用&源碼詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html alt=我是如何閱讀JDK源碼的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/25b18fb619994fcbaa58c5e28b7a4e51 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2bf9a44d.html title=我是如何閱讀JDK源碼的？>我是如何閱讀JDK源碼的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/59958e85.html alt=深入分析java集合框架Collection（源碼分析） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/43efff37d8ff43bc8553cc71e3b99b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/59958e85.html title=深入分析java集合框架Collection（源碼分析）>深入分析java集合框架Collection（源碼分析）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html alt=源碼分析：Java集合類的AbstractCollection源碼解析 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/a3aefa7e5d8c491cb86dc9c9e4390671 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e275511c.html title=源碼分析：Java集合類的AbstractCollection源碼解析>源碼分析：Java集合類的AbstractCollection源碼解析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html alt=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/acdfbd47.html title=正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示>正點原子開拓者FPGA開發板資料連載第二十三章RGBTFT-LCD字符顯示</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d741bce.html alt=有一說一！SpringAOP+源碼解析，切就完事了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/965c060c22b942c1a3a9f143215f114c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d741bce.html title=有一說一！SpringAOP+源碼解析，切就完事了>有一說一！SpringAOP+源碼解析，切就完事了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html alt="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d1edd66723f4966b44d3cab502c055f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5da0d73c.html title="正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗">正點原子開拓者FPGA開發板資料連載第三十二章 音頻環回實驗</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ea98537.html alt=源碼：太陽能路燈如何接線 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/c5ed2247de6949d89b9052d3fddd4921 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ea98537.html title=源碼：太陽能路燈如何接線>源碼：太陽能路燈如何接線</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html alt=基於FPGA的多通道同步實時高速數據採集系統設計 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/RT9ec7T8clHaQI style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e803abd.html title=基於FPGA的多通道同步實時高速數據採集系統設計>基於FPGA的多通道同步實時高速數據採集系統設計</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>