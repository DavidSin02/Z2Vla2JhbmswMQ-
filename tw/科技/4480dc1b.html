<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>不會正則表達式？看這篇就夠了 | 极客快訊</title><meta property="og:title" content="不會正則表達式？看這篇就夠了 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/061586043d964e5eaa9f75ab5602f1f8"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4480dc1b.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4480dc1b.html><meta property="article:published_time" content="2020-11-14T21:07:14+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:14+08:00"><meta name=Keywords content><meta name=description content="不會正則表達式？看這篇就夠了"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4480dc1b.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>不會正則表達式？看這篇就夠了</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><pre class=ql-align-right>作者：假不理 來源：https://juejin.im/post/5b96a8e2e51d450e6a2de115</pre><p>正則表達式在幾乎所有語言中都可以使用，無論是前端的JavaScript、還是後端的Java、c#。他們都提供相應的接口/函數支持正則表達式。</p><p class=ql-align-justify><br></p><p>很神奇的是：無論你大學選擇哪一門計算機語言，都沒有關於正則表達式的課程給你修，在你學會正則之前，你只能看著那些正則大師們，寫了一串外星文似的字符串，替代了你用一大篇幅的if else代碼來做一些數據校驗。</p><p class=ql-align-justify><br></p><p>既然喜歡，那就動手學唄，可當你百度出一一堆相關資料時，你發現無一不例外的枯燥至極，難以學習。</p><p>本文旨在用最通俗的語言講述最枯燥的基本知識！</p><p class=ql-align-justify><br></p><p><strong># 正則基礎知識點</strong></p><p class=ql-align-justify><br></p><p>1、元字符</p><p class=ql-align-justify><br></p><p>萬物皆有緣，正則也是如此，元字符是構造正則表達式的一種基本元素。</p><p class=ql-align-justify><br></p><p>我們先來記幾個常用的元字符：</p><p class=ql-align-justify><br></p><p>元字符說明.匹配除換行符以外的任意字符w匹配字母或數字或下劃線或漢字s匹配任意的空白符d匹配數字匹配單詞的開始或結束^匹配字符串的開始$匹配字符串的結束</p><p class=ql-align-justify><br></p><p>有了元字符之後，我們就可以利用這些元字符來寫一些簡單的正則表達式了，</p><p class=ql-align-justify><br></p><p>比如：</p><p class=ql-align-justify><br></p><p>匹配有abc開頭的字符串：abc或者^abc</p><p>匹配8位數字的QQ號碼：^dddddddd$</p><p>匹配1開頭11位數字的手機號碼：^1dddddddddd$</p><p class=ql-align-justify><br></p><p>2、重複限定符</p><p class=ql-align-justify><br></p><p>有了元字符就可以寫不少的正則表達式了，但細心的你們可能會發現：別人寫的正則簡潔明瞭，而不理君寫的正則一堆亂七八糟而且重複的元字符組成的。正則沒提供辦法處理這些重複的元字符嗎？</p><p class=ql-align-justify><br></p><p>答案是有的！</p><p class=ql-align-justify><br></p><p>為了處理這些重複問題，正則表達式中一些重複限定符，把重複部分用合適的限定符替代，下面我們來看一些限定符：</p><p class=ql-align-justify><br></p><p>語法說明*重複零次或更多次+重複一次或更多次?重複零次或一次{n}重複n次{n,}重複n次或更多次{n,m}重複n到m次</p><p class=ql-align-justify><br></p><p>有了這些限定符之後，我們就可以對之前的正則表達式進行改造了，比如：</p><p class=ql-align-justify><br></p><p>匹配8位數字的QQ號碼：^d{8}$</p><p>匹配1開頭11位數字的手機號碼：^1d{10}$</p><p>匹配銀行卡號是14~18位的數字：^d{14,18}$</p><p>匹配以a開頭的，0個或多個b結尾的字符串^ab*$</p><p class=ql-align-justify><br></p><p>3、分組</p><p class=ql-align-justify><br></p><p>從上面的例子（4）中看到，限定符是作用在與他左邊最近的一個字符，那麼問題來了，如果我想要ab同時被限定那怎麼辦呢？</p><p class=ql-align-justify><br></p><p>正則表達式中用小括號()來做分組，也就是括號中的內容作為一個整體。</p><p>因此當我們要匹配多個ab時，我們可以這樣。</p><p class=ql-align-justify><br></p><p>如匹配字符串中包含0到多個ab開頭：^(ab)*</p><p class=ql-align-justify><br></p><p>4、轉義</p><p class=ql-align-justify><br></p><p>我們看到正則表達式用小括號來做分組，那麼問題來了：</p><p class=ql-align-justify><br></p><p>如果要匹配的字符串中本身就包含小括號，那是不是衝突？應該怎麼辦？</p><p>針對這種情況，正則提供了轉義的方式，也就是要把這些元字符、限定符或者關鍵字轉義成普通的字符，做法很簡答，就是在要轉義的字符前面加個斜槓，也就是即可。</p><p class=ql-align-justify><br></p><p>如要匹配以(ab)開頭：^((ab))*</p><p class=ql-align-justify><br></p><p>5、條件或</p><p class=ql-align-justify><br></p><p>回到我們剛才的手機號匹配，我們都知道：國內號碼都來自三大網，它們都有屬於自己的號段，比如聯通有130/131/132/155/156/185/186/145/176等號段，假如讓我們匹配一個聯通的號碼，那按照我們目前所學到的正則，應該無從下手的，因為這裡包含了一些並列的條件，也就是“或”，那麼在正則中是如何表示“或”的呢？</p><p class=ql-align-justify><br></p><p>正則用符號 | 來表示或，也叫做分支條件，當滿足正則裡的分支條件的任何一種條件時，都會當成是匹配成功。</p><p class=ql-align-justify><br></p><p>那麼我們就可以用“或”條件來處理這個問題：^(130|131|132|155|156|185|186|145|176)d{8}$</p><p class=ql-align-justify><br></p><p>6、區間</p><p class=ql-align-justify><br></p><p>看到上面的例子，是不是看到有什麼規律？是不是還有一種想要簡化的衝動？</p><p class=ql-align-justify><br></p><p>實際是有的</p><p class=ql-align-justify><br></p><p>正則提供一個元字符中括號 [] 來表示區間條件。</p><ul><li class=ql-align-justify>限定0到9 可以寫成[0-9]</li><li class=ql-align-justify>限定A-Z 寫成[A-Z]</li><li class=ql-align-justify>限定某些數字 [165]</li></ul><p>那上面的正則我們還改成這樣：</p><p class=ql-align-justify>^((13[0-2])|(15[56])|(18[5-6])|145|176)d{8}$</p><p>好了，正則表達式的基本用法就講到這裡了，其實它還有非常多的知識點以及元字符，我們在此只列舉了部分元字符和語法來講，旨在給那些不懂正則或者想學正則但有看不下去文檔的人做一個快速入門級的教程，看完本教程，即使你不能寫出高大上的正則，至少也能寫一些簡單的正則或者看得懂別人寫的正則了。</p><p class=ql-align-justify><br></p><p><strong># 正則進階知識點</strong></p><p>1、零寬斷言</p><p class=ql-align-justify><br></p><p>無論是零寬還是斷言，聽起來都古古怪怪的，</p><p class=ql-align-justify><br></p><p>那先解釋一下這兩個詞。</p><p class=ql-align-justify><br></p><p>斷言：俗話的斷言就是“我斷定什麼什麼”，而正則中的斷言，就是說正則可以指明在指定的內容的前面或後面會出現滿足指定規則的內容，意思正則也可以像人類那樣斷定什麼什麼，比如"ss1aa2bb3",正則可以用斷言找出aa2前面有bb3，也可以找出aa2後面有ss1.</p><p>零寬：就是沒有寬度，在正則中，斷言只是匹配位置，不佔字符，也就是說，匹配結果裡是不會返回斷言本身。</p><p>意思是講明白了，那他有什麼用呢？</p><p class=ql-align-justify><br></p><p>我們來舉個栗子：假設我們要用爬蟲抓取csdn裡的文章閱讀量。通過查看源代碼可以看到文章閱讀量這個內容是這樣的結構</p><p class=ql-align-justify><br></p><p>"&lt;span class="read-count">閱讀數：641&lt;/span>"</p><p>其中也就‘641’這個是變量，也就是說不同文章不同的值，當我們拿到這個字符串時，需要獲得這裡邊的‘641’有很多種辦法，但如果正則應該怎麼匹配呢？</p><p class=ql-align-justify><br></p><p>下面先來講幾種類型的斷言：</p><p class=ql-align-justify><br></p><p>正向先行斷言（正前瞻）</p><p>語法：（?=pattern）</p><p>作用：匹配pattern表達式的前面內容，不返回本身。</p><p>這樣子說，還是一臉懵逼，好吧，迴歸剛才那個栗子，要取到閱讀量，在正則表達式中就意味著要能匹配到‘’前面的數字內容。</p><p class=ql-align-justify><br></p><p>按照上所說的正向先行斷言可以匹配表達式前面的內容，那意思就是:(?=) 就可以匹配到前面的內容了。</p><p class=ql-align-justify><br></p><p>匹配什麼內容呢？如果要所有內容那就是：</p><div class=pgc-img><img alt=不會正則表達式？看這篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/061586043d964e5eaa9f75ab5602f1f8><p class=pgc-img-caption></p></div><p>可是老哥我們要的只是前面的數字呀，那也簡單咯，匹配數字 d,那可以改成：</p><pre>String reg="\d+(?=&lt;/span&gt;)";String test = "&lt;span class="read-count"&gt;閱讀數：641&lt;/span&gt;";Pattern pattern = Pattern.compile(reg);Matcher mc= pattern.matcher(test);while(mc.find()){ System.out.println(mc.group());}//匹配結果：//641</pre><p>大功告成！</p><p class=ql-align-justify><br></p><p>正向後行斷言（正後顧）</p><p>語法：（?&lt;=pattern）</p><p>作用：匹配pattern表達式的後面的內容，不返回本身。</p><p>有先行就有後行，先行是匹配前面的內容，那後行就是匹配後面的內容啦。</p><p class=ql-align-justify><br></p><p>上面的栗子，我們也可以用後行斷言來處理。</p><pre>//(?&lt;=&lt;span class="read-count"&gt;閱讀數：)d+String reg="(?&lt;=&lt;span class="read-count"&gt;閱讀數：)\d+";String test = "&lt;span class="read-count"&gt;閱讀數：641&lt;/span&gt;"; Pattern pattern = Pattern.compile(reg); Matcher mc= pattern.matcher(test); while(mc.find()){ System.out.println(mc.group()); }//匹配結果：//641</pre><p>就這麼簡單。</p><p class=ql-align-justify><br></p><p>負向先行斷言（負前瞻）</p><p>語法：(?!pattern)</p><p>作用：匹配非pattern表達式的前面內容，不返回本身。</p><p>有正向也有負向，負向在這裡其實就是非的意思。</p><p class=ql-align-justify><br></p><p>舉個栗子：比如有一句 “我愛祖國，我是祖國的花朵”</p><p class=ql-align-justify><br></p><p>現在要找到不是'的花朵'前面的祖國</p><p class=ql-align-justify><br></p><p>用正則就可以這樣寫：祖國(?!的花朵)。</p><p>負向後行斷言（負後顧）</p><p>語法：(?&lt;!pattern)</p><p>作用：匹配非pattern表達式的後面內容，不返回本身。</p><p>2、捕獲和非捕獲</p><p class=ql-align-justify><br></p><p>單純說到捕獲，他的意思是匹配表達式，但捕獲通常和分組聯繫在一起，也就是“捕獲組”。</p><p class=ql-align-justify><br></p><p>捕獲組：匹配子表達式的內容，把匹配結果保存到內存中中數字編號或顯示命名的組裡，以深度優先進行編號，之後可以通過序號或名稱來使用這些匹配結果。</p><p>而根據命名方式的不同，又可以分為兩種組。</p><p class=ql-align-justify><br></p><p>數字編號捕獲組</p><p>語法：(exp)</p><p>解釋：從表達式左側開始，每出現一個左括號和它對應的右括號之間的內容為一個分組，在分組中，第0組為整個表達式，第一組開始為分組。</p><p>比如固定電話的：020-85653333</p><p>他的正則表達式為：(0d{2})-(d{8})</p><p>按照左括號的順序，這個表達式有如下分組：</p><p>序號編號分組內容00(0d{2})-(d{8})020-8565333311(0d{2})02022(d{8})85653333</p><p class=ql-align-justify><br></p><p>我們用Java來驗證一下：</p><div class=pgc-img><img alt=不會正則表達式？看這篇就夠了 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/0155275ec42840e3aab6aa1aa4b78090><p class=pgc-img-caption></p></div><p>輸出結果：</p><pre>分組的個數有：2第0個分組為：020-85653333第1個分組為：020第2個分組為：85653333</pre><p>可見，分組個數是2，但是因為第0個為整個表達式本身，因此也一起輸出了。</p><p class=ql-align-justify><br></p><p>命名編號捕獲組</p><p>語法：(?exp)</p><p>解釋：分組的命名由表達式中的name指定</p><p>比如區號也可以這樣寫:(?d{2})-(?d{8})</p><p>按照左括號的順序，這個表達式有如下分組：序號名稱分組內容00(0d{2})-(d{8})020-856533331quhao(0d{2})0202haoma(d{8})85653333</p><p class=ql-align-justify><br></p><p>用代碼來驗證一下：</p><pre>String test = "020-85653333";String reg="(?&lt;quhao&gt;0\d{2})-(?&lt;haoma&gt;\d{8})";Pattern pattern = Pattern.compile(reg);Matcher mc= pattern.matcher(test);if(mc.find()){ System.out.println("分組的個數有："+mc.groupCount()); System.out.println(mc.group("quhao")); System.out.println(mc.group("haoma"));}</pre><p>輸出結果：</p><pre>分組的個數有：2分組名稱為:quhao,匹配內容為：020分組名稱為:haoma,匹配內容為：85653333</pre><p>非捕獲組</p><p>語法：(?:exp)</p><p>解釋：和捕獲組剛好相反，它用來標識那些不需要捕獲的分組，說的通俗一點，就是你可以根據需要去保存你的分組。</p><p>比如上面的正則表達式，程序不需要用到第一個分組，那就可以這樣寫：(?:d{2})-(d{8})</p><p>序號編號分組內容00(0d{2})-(d{8})020-8565333311(d{8})85653333</p><p class=ql-align-justify><br></p><p>驗證一下：</p><pre>String test = "020-85653333";String reg="(?:0\d{2})-(\d{8})";Pattern pattern = Pattern.compile(reg);Matcher mc= pattern.matcher(test);if(mc.find()){ System.out.println("分組的個數有："+mc.groupCount()); for(inti=0;i&lt;=mc.groupCount();i++){ System.out.println("第"+i+"個分組為："+mc.group(i)); }}</pre><p>輸出結果：</p><pre>分組的個數有：1第0個分組為：020-85653333第1個分組為：85653333</pre><p>3、反向引用</p><p class=ql-align-justify><br></p><p>上面講到捕獲，我們知道：捕獲會返回一個捕獲組，這個分組是保存在內存中，不僅可以在正則表達式外部通過程序進行引用，也可以在正則表達式內部進行引用，這種引用方式就是反向引用。</p><p class=ql-align-justify><br></p><p>根據捕獲組的命名規則，反向引用可分為：</p><p class=ql-align-justify><br></p><p>數字編號組反向引用：k或 umber</p><p>命名編號組反向引用：k或者'name'</p><p>好了 講完了，懂嗎？不懂！！！</p><p class=ql-align-justify><br></p><p>可能連前面講的捕獲有什麼用都還不懂吧？</p><p class=ql-align-justify><br></p><p>其實只是看完捕獲不懂不會用是很正常的！</p><p class=ql-align-justify><br></p><p>因為捕獲組通常是和反向引用一起使用的。</p><p class=ql-align-justify><br></p><p>上面說到捕獲組是匹配子表達式的內容按序號或者命名保存起來以便使用。</p><p class=ql-align-justify><br></p><p>注意兩個字眼：“內容” 和 “使用”。</p><p class=ql-align-justify><br></p><p>這裡所說的“內容”，是匹配結果，而不是子表達式本身，強調這個有什麼用？嗯，先記住。</p><p class=ql-align-justify><br></p><p>那這裡所說的“使用”是怎樣使用呢？</p><p class=ql-align-justify><br></p><p>因為它的作用主要是用來查找一些重複的內容或者做替換指定字符。</p><p class=ql-align-justify><br></p><p>還是舉栗子吧。</p><p class=ql-align-justify><br></p><p>比如要查找一串字母"aabbbbgbddesddfiid"裡成對的字母</p><p class=ql-align-justify><br></p><p>如果按照我們之前學到的正則，什麼區間啊限定啊斷言啊可能是辦不到的，</p><p class=ql-align-justify><br></p><p>現在我們先用程序思維理一下思路：</p><p class=ql-align-justify><br></p><p>1）匹配到一個字母</p><p>2）匹配第下一個字母，檢查是否和上一個字母是否一樣</p><p>3）如果一樣，則匹配成功，否則失敗</p><p>這裡的思路2中匹配下一個字母時，需要用到上一個字母，那怎麼記住上一個字母呢？？？</p><p class=ql-align-justify><br></p><p>這下子捕獲就有用處啦，我們可以利用捕獲把上一個匹配成功的內容用來作為本次匹配的條件</p><p class=ql-align-justify><br></p><p>好了，有思路就要實踐</p><p class=ql-align-justify><br></p><p>首先匹配一個字母：w</p><p class=ql-align-justify><br></p><p>我們需要做成分組才能捕獲，因此寫成這樣：(w)</p><p class=ql-align-justify><br></p><p>那這個表達式就有一個捕獲組：（w）</p><p class=ql-align-justify><br></p><p>然後我們要用這個捕獲組作為條件，那就可以：(w)</p><p class=ql-align-justify><br></p><p>這樣就大功告成了</p><p class=ql-align-justify><br></p><p>可能有人不明白了，是什麼意思呢？</p><p class=ql-align-justify><br></p><p>還記得捕獲組有兩種命名方式嗎，一種是是根據捕獲分組順序命名，一種是自定義命名來作為捕獲組的命名</p><p class=ql-align-justify><br></p><p>在默認情況下都是以數字來命名，而且數字命名的順序是從1開始的</p><p class=ql-align-justify><br></p><p>因此要引用第一個捕獲組，根據反向引用的數字命名規則 就需要 k&lt;1>或者</p><p class=ql-align-justify><br></p><p>當然，通常都是是後者。</p><p class=ql-align-justify><br></p><p>我們來測試一下：</p><pre>String test = "aabbbbgbddesddfiid";Pattern pattern = Pattern.compile("(\w)\1");Matcher mc= pattern.matcher(test);while(mc.find()){ System.out.println(mc.group());}</pre><p>輸出結果：</p><pre>aabbbbddddii</pre><p>嗯，這就是我們想要的了。</p><p class=ql-align-justify><br></p><p>在舉個替換的例子，假如想要把字符串中abc換成a。</p><pre>String test = "abcbbabcbcgbddesddfiid";String reg="(a)(b)c";System.out.println(test.replaceAll(reg, "$1"));</pre><p>輸出結果：</p><pre>abbabcgbddesddfiid</pre><p>4、貪婪和非貪婪</p><p class=ql-align-justify><br></p><p>貪婪</p><p class=ql-align-justify><br></p><p>我們都知道，貪婪就是不滿足，儘可能多的要。</p><p class=ql-align-justify><br></p><p>在正則中，貪婪也是差不多的意思:</p><p class=ql-align-justify><br></p><p>貪婪匹配：當正則表達式中包含能接受重複的限定符時，通常的行為是（在使整個表達式能得到匹配的前提下）匹配儘可能多的字符，這匹配方式叫做貪婪匹配。</p><p>特性：一次性讀入整個字符串進行匹配，每當不匹配就捨棄最右邊一個字符，繼續匹配，依次匹配和捨棄（這種匹配-捨棄的方式也叫做回溯），直到匹配成功或者把整個字符串捨棄完為止，因此它是一種最大化的數據返回，能多不會少。</p><p>前面我們講過重複限定符，其實這些限定符就是貪婪量詞，比如表達式：d{3,6}。</p><p>用來匹配3到6位數字，在這種情況下，它是一種貪婪模式的匹配，也就是假如字符串裡有6個個數字可以匹配，那它就是全部匹配到。</p><p class=ql-align-justify><br></p><p>如下面的代碼。</p><pre>String reg="\d{3,6}";String test="61762828 176 2991 871";System.out.println("文本："+test);System.out.println("貪婪模式："+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test);while(m1.find()){ System.out.println("匹配結果："+m1.group(0));}</pre><p class=ql-align-justify>輸出結果：</p><pre>文本：61762828 176 2991 44 871貪婪模式：d{3,6}匹配結果：617628匹配結果：176匹配結果：2991匹配結果：871</pre><p>由結果可見：本來字符串中的“61762828”這一段，其實只需要出現3個（617）就已經匹配成功了的，但是他並不滿足，而是匹配到了最大能匹配的字符，也就是6個。</p><p class=ql-align-justify><br></p><p>一個量詞就如此貪婪了，</p><p class=ql-align-justify><br></p><p>那有人會問，如果多個貪婪量詞湊在一起，那他們是如何支配自己的匹配權的呢？</p><p class=ql-align-justify><br></p><p>是這樣的，多個貪婪在一起時，如果字符串能滿足他們各自最大程度的匹配時，就互不干擾，但如果不能滿足時，會根據深度優先原則，也就是從左到右的每一個貪婪量詞，優先最大數量的滿足，剩餘再分配下一個量詞匹配。</p><pre>String reg="(\d{1,2})(\d{3,4})";String test="61762828 176 2991 87321";System.out.println("文本："+test);System.out.println("貪婪模式："+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test);while(m1.find()){ System.out.println("匹配結果："+m1.group(0));}</pre><p>輸出結果：</p><pre>文本：61762828 176 2991 87321貪婪模式：(d{1,2})(d{3,4})匹配結果：617628匹配結果：2991匹配結果：87321</pre><p class=ql-align-justify>“617628” 是前面的d{1,2}匹配出了61，後面的匹配出了7628</p><p class=ql-align-justify>"2991" 是前面的d{1,2}匹配出了29 ，後面的匹配出了91</p><p class=ql-align-justify>"87321"是前面的d{1,2}匹配出了87，後面的匹配出了321</p><p>懶惰（非貪婪）</p><p class=ql-align-justify><br></p><p>懶惰匹配：當正則表達式中包含能接受重複的限定符時，通常的行為是（在使整個表達式能得到匹配的前提下）匹配儘可能少的字符，這匹配方式叫做懶惰匹配。</p><p>特性：從左到右，從字符串的最左邊開始匹配，每次試圖不讀入字符匹配，匹配成功，則完成匹配，否則讀入一個字符再匹配，依此循環（讀入字符、匹配）直到匹配成功或者把字符串的字符匹配完為止。</p><p>懶惰量詞是在貪婪量詞後面加個“？”</p><p class=ql-align-justify><br></p><p>代碼說明*?重複任意次，但儘可能少重複+?重複1次或更多次，但儘可能少重複??重複0次或1次，但儘可能少重複{n,m}?重複n到m次，但儘可能少重複{n,}?重複n次以上，但儘可能少重複。</p><pre>String reg="(\d{1,2}?)(\d{3,4})";String test="61762828 176 2991 87321";System.out.println("文本："+test);System.out.println("貪婪模式："+reg);Pattern p1 =Pattern.compile(reg);Matcher m1 = p1.matcher(test);while(m1.find()){ System.out.println("匹配結果："+m1.group(0));}</pre><p>輸出結果：</p><pre>文本：61762828 176 2991 87321貪婪模式：(d{1,2}?)(d{3,4})匹配結果：61762匹配結果：2991匹配結果：87321</pre><p>“61762” 是左邊的懶惰匹配出6，右邊的貪婪匹配出1762</p><p>"2991" 是左邊的懶惰匹配出2，右邊的貪婪匹配出991</p><p>"87321" 左邊的懶惰匹配出8，右邊的貪婪匹配出7321</p><p>5、反義</p><p class=ql-align-justify><br></p><p>前面說到元字符的都是要匹配什麼什麼，當然如果你想反著來，不想匹配某些字符，正則也提供了一些常用的反義元字符。</p><p class=ql-align-justify><br></p><p>元字符解釋W匹配任意不是字母，數字，下劃線，漢字的字符S匹配任意不是空白符的字符D匹配任意非數字的字符B匹配不是單詞開頭或結束的位置[x]匹配除了x以外的任意字符[aeiou]匹配除了aeiou這幾個字母以外的任意字符</p><p class=ql-align-justify><br></p><p>正則進階知識就講到這裡，正則是一門博大精深的語言，其實學會它的一些語法和知識點還算不太難，但想要做到真正學以致用能寫出非常6的正則，還有很遠的距離，只有真正對它感興趣的，並且經常研究和使用它，才會漸漸的理解它的博大精深之處，我就帶你們走到這，剩下的，靠自己啦。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>不會</a></li><li><a>正則</a></li><li><a>表達式</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/d2dd7ebf.html alt="Java 正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d2dd7ebf.html title="Java 正則表達式">Java 正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/22c24c31.html alt="Java 正則表達式 StackOverflowError 問題及其優化" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/28110ae7b0fc46f1a5ad2e6bcf0e40c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/22c24c31.html title="Java 正則表達式 StackOverflowError 問題及其優化">Java 正則表達式 StackOverflowError 問題及其優化</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/53f942fa.html alt=Java正則表達式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531051821759d2705acacc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/53f942fa.html title=Java正則表達式>Java正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0c20e1e.html alt=Java正則表達式介紹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0c20e1e.html title=Java正則表達式介紹>Java正則表達式介紹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5c2f2cd7.html alt=Java正則表達式模式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6d9eaa59ae704773aef9e0851d9625fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5c2f2cd7.html title=Java正則表達式模式>Java正則表達式模式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/38a1ca5a.html alt=Java正則表達式組 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cb895437221f4629a7a4f697a8ac9f7a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/38a1ca5a.html title=Java正則表達式組>Java正則表達式組</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html alt="java 常用的正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1540129072390e6c4c05126 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/19cbd4c3.html title="java 常用的正則表達式">java 常用的正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a3910c22.html alt=javascript正則表達式基礎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a3910c22.html title=javascript正則表達式基礎>javascript正則表達式基礎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a81470d4.html alt=java常用正則表達式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c811c3c14e4a4fa4825845b2868ee645 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a81470d4.html title=java常用正則表達式>java常用正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a4031d46.html alt=正則表達式-javaScript class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/71e4c14f52284cf48db00f3e10ea4ad4 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a4031d46.html title=正則表達式-javaScript>正則表達式-javaScript</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8d84c536.html alt=正則表達式基本語法和常用的正則表達式 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/153137431384891e4a04908 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8d84c536.html title=正則表達式基本語法和常用的正則表達式>正則表達式基本語法和常用的正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e0639976.html alt=正則表達式教程：實例速查 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e0639976.html title=正則表達式教程：實例速查>正則表達式教程：實例速查</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/63001fb4.html alt=正則表達式真的很騷，可惜你不會寫！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a9c90ac0178e426b8357329883822384 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/63001fb4.html title=正則表達式真的很騷，可惜你不會寫！>正則表達式真的很騷，可惜你不會寫！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/47bf383c.html alt="JavaScript 正則表達式理論學習和案例分析" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/23450277ff8a4edb976123f0d7b823d0 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/47bf383c.html title="JavaScript 正則表達式理論學習和案例分析">JavaScript 正則表達式理論學習和案例分析</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/de5a6f15.html alt=JavaScript正則表達式詳細總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6cd0893b009045c794771d55a21a19a6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/de5a6f15.html title=JavaScript正則表達式詳細總結>JavaScript正則表達式詳細總結</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>