<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>新手編程導論(十) | 极客快訊</title><meta property="og:title" content="新手編程導論(十) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p9.pstatp.com/large/pgc-image/f9ae9dd10f344864b55d78ae3b54dec5"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/45de4a01.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/45de4a01.html><meta property="article:published_time" content="2020-11-14T20:59:18+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:18+08:00"><meta name=Keywords content><meta name=description content="新手編程導論(十)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/45de4a01.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>新手編程導論(十)</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><strong>第三部分 進階： C,C++代碼閱讀與控制</strong>如果說在本書第二部分裡我力求向你們提出一個思想體系，那麼在這本書的這部分我將要講述的就是代碼控制和實踐能力了,這是程序設計的基礎二部曲。這本書完成之後，你應該具備基礎的編碼實踐能力（或閱讀別人代碼的能力）。<br>這部分主體是,C,C++語法，，及各自標準庫的分析與使用，stdc,stl,glibc,boost,loki,（設計模式，數據結構，業務邏輯），而且更側重使用(因為分析出來的是庫邏輯，是設計抽象密集的)。比如自己開發例子出來（這才是使用密集的）。<br>目錄可以這樣定：輪子分析，再造輪子<br>1．C，C++基礎（語法級的，，數組啊，字串啊，控制結構啊，初級標準庫級的，比如IO，，OO啊，模板啊）。<br>2，數據結構，STL（分析庫不如自寫來得權威，，但是參照別人的src也是最好的方法）<br>3，設計模式上的，LOKI，我在這裡不把BOOST拿來討論，是因為我覺得成為語言標準的只需要數據結構作為數據抽明和設計模式作為代碼抽象就可以了，，而BOOST有太多的對具體事物的抽象，，實際上隨著問題的增多，BOOST會越來越大，，這（對各個事物的抽象解決集）不應該成為一門語言的標準。。而LOKI剛好對應只用模板解決的DP問題。。顯然合理。<br>4，這是放在第二部分最後一節(抽象之領域邏輯)分析的某個庫比如OO的OGRE，我在1月2號決定取消這一部分，，那麼我作了什麼決定呢，我決定寫一個實現比如實化版的yake或者是一個yake類的引擎加一個遊戲實現（直接把其當成寫第六部分的內容，而不再分析並使用別人的遊戲引擎，），可能用到其它的庫(比如net,mysql,boost)，直接產生一個遊戲,,<br>具體如何進行呢，儘量少用輪子，只用OPENGL這樣的必要的輪子。考慮進STL和LOKI，做成一個簡單的引擎，然後寫遊戲實現。儘量在寫的過程中與ogre,yake對比，突出為什麼全的設計是它們，而現在自己在寫的是一個剋意不用其它輪子的輪子（為了教學的目的）。。<br>在第四部分，才是一個系統的解決方案（一箇中型例子，而不再寫庫或分析庫了，，，應該找什麼現成的例子呢還是自寫，，在這裡要分析出設計的細節，大中型軟件如何形成的），提出一箇中型程序，，第四部分 一個例子，結合OO，模板，語言，領域邏輯寫出的大型邏輯的軟件<br>如果說STL是templaate與C的結合，那麼LOKI有些更多靠近OO與template的結合。<br><strong>第9章 語法與初級標準庫</strong>參考書《C++ Primer 第三版》Neckman<br>9.1 C++的基於過程設計<br>9.2 C++的基於對象設計: 模板與設計<br>不幸的是，理解STL深層的原理是需要懂與模板相關的設計的，比如仿函數的本質，迭代器，配接器的本質，模板導致的泛型開發與它提出的這些設計相關的東西可以另外寫成一本書。學習STL首先是學習這些設計手法，再學習其數據結構和算法的實現。<br>泛型有二層意思，第一，基礎泛化，它把泛型參數化，用於動態產生關於不同型別組合的相同邏輯（可以聯繫函數聲明和函數定義來理解），這也就是一般泛化了，第二，它把一切設計中可能出現的因素都類型化(template class化)，即在template class這個字眼中不主要強調template泛化而是class類型化，（只不過它也會用到泛型的第一層基礎泛化作用而已）比如，迭代器，仿函數實際上都是(模板)類,這其實更像是C++的概念而不是泛型的概念。(因為class是c++的而stl及它導致的template手法是另外一個人發明的)<br>為什麼需要把指針，函數封裝為class呢，這是因為在C++中，class幾乎就是一種邏輯粘劑(即將數據成員和函數成員，，當然在模板中也可以是模板成員數據和函數，封裝為ADT)，在這裡並不強調這些Class運行於runtime的那些特徵，比如多態，等，而是強調class封裝邏輯成adt並提供private,public,protect修飾機制的能力（相比之下C++的struct太簡陋因為它只能提供全public,而且不能成為adt,因此沒有adt的諸多好處，比如C++的只對class有效的運算符重載，，而class+oper overloading+template class你呆會會看到，，這在泛型設計中是多麼有用處的東西。），，所以在C++中，相比面向對象來說，這些基於對象的開發範式也需要被重視。。<br>一句話，class化可以獲得語義級的value, 只要給該class一個copy ctor就可以複製並傳統它，給它一個重載的括號就可以成為跟函數動作一樣的東西出現在C++語法相容的東西（雖然語義實際跟標準的對應物不一樣），，，<br>template class是泛型設計中的重頭武器，因為：<br>函數+oper () overloading+template class化 = function objects，這就是stl中的仿函數。<br>pointer+oper * overloading(和->)+template class化 = smartpointer，這就相當stl中的interate.<br>Multiple inhert + template class作為另一個template的參數=policy，即loki中的策略。<br>Struct+template=nested type,,內欠型別。。<br>元編程裡的metafunction<br>重載是多態的簡單形式，，模板特化與實例化是不一樣的，，，其實任何一個模板，都存在二套參數，一套是泛用的，在tempalte關鍵字後面，另一套是特化或偏特化用的，在具體的模板後。特化與實例化的區別在於實例化不需要人去幹預。<br><strong>9.3 面向對象設計</strong><br></p><p><br></p><p><strong>9.4 泛型開發與初級StdC庫<br>第10章 數據邏輯與STL庫</strong><br>參考書：《STL源碼分析》完整版 侯捷<br><strong>10.1 仿函數</strong>仿函數是C++基於對象編程的典型，，，它把對象class化{也可能是template class化}，使之具有copy ctor可被複制，再給它提供一個重載的小括號這樣在語法上就可以跟普通函數一樣寫了，整個過程並不需要面向運行期（面向對象），，，所謂模板加基於對象的基於對象之說只適合發生於編譯期。<br>STL中為什麼需要仿函數呢？它為了成為算法的某種策略，，loki中的仿函數用來實現一種command的設計模式，因為仿函數可以用來封裝一系列請求；<br><strong>10.2 iterater</strong>Stl中，與template相關的一個設計手法就是迭代器，迭代器成為表達各種數據結構以及跟它們有關的各種算法操作的支持概念。當然也是一種泛型手法。Idioms 其實也是一種設計模式，即迭代器模式（traits,adapter泛型設計手法可用於廣泛目的，相比之下iterate好像只用於數據結構的設計手法設計模式），<br>既然是泛型編程，迭代器是在什麼樣的泛化需求下以什麼樣的泛化方式被提出來的呢？<br>我們知道數據結構都是某種區間，把數據結構視為區間這本身就體現了某種泛化（能泛即能提供通用性，可複用性，所以是一種對代碼趨近於人的設計抽象），某種抽象，實際上無論是以何種結構形成的關聯式(key+value=pair對)還是非關聯式數據結構（），，迭代器都將提供一種遊動於元素（一般來說元素只是value的說法）或節點（一般來說node=key,value）之間並能對算法提供迭代支持。只不過迭代器作為泛型的型它也可以有多種iterate associated traits而已，有的是input,有的是單向，有的是雙向，有的是const,有的是mutable而已。<br><strong>10.3 adapter</strong>配接器的說法很形象， 你可以聯繫現實生活中把ps/2鼠標加一個ps/2 2 usb接口，，把它轉為USB接口的這樣一種動作，，這種動作就是改變接口的機制使之由舊接口變成新接口，一種設計策略（改變原有代碼，使之適應某種複用考慮，，所以是人控制代碼的過程，，是設計抽象，，這個動作也稱為重構，即不改變原有系統設計的情況下，利用設計手段修補式地改造原系統，因此跟DP相關），，往往把它歸為專門的一門設計模式。<br>因為客戶(你的電腦ps/2口壞了不能插ps/2鼠標了)只能使用某種接口的東西，所以需要對原有接口（原有代碼）進行接口重新封裝，使之向現呈現客戶能用的接口。這是典型的設計模式應用於給代碼打補丁的情形即複用的情形。（當然設計模式也可一開始用於純設計的地方）<br>那麼stl中的這些配接器都是些什麼呢，又怎麼樣在stl的整個設計中發揮了作用呢？？</p><p><strong>第11章 高級代碼邏輯與LOKI庫</strong>參考書：《C++新思維》中文完整版<br><strong>11.1 typelist</strong>對類型的設計才是設計。<br>為什麼寫代碼需要設計呢，因為代碼是人寫給人看的，所以對代碼邏輯的控制是需要的，而這就是設計，，設計更多指一種人類活動，比如藝術設計，所以它包括測試，重構等諸多過程組成的與編碼相對的過程。設計首先是一種對問題的積極抽象過程，booch甚至說抽象是解決設計問題最有效的方法之一，當然，維護，重構也是，所以說抽象問題只是設計的一部分然而是最重要部分。<br>在C++中，設計首先是對類型進行設計進行抽象（泛型這個字眼本身就表明了對各種類型其功能通用，所以是一種設計抽象），有OO。有template。OO是類型化即面向對象，template是泛型化即主要用C++的基於對象機制來工作。<br>泛型編程中對型進行的抽象，有make types to be a list,有mapping type to sth,有get traits from types，儘量在編譯期間將型別抽象到應用，形成設計，因為靜態語言的編譯期間正好提供強大的類型功能，，，而這裡談到的typelist就是一種。。<br>對類型作了這麼多抽象之後，再提出iterate，等設計手法用於stl，提出policy用於policy based design，，學習範型編程，始終要提醒自己把握這個精神（即一般泛型設計會分成三個層次，第一層是型別抽象，第二層在第一層的基礎上提出鄰域相關的設計手法，第三問題本身，STL和LOKI中都是這樣）。。<br><strong>11.2 traits</strong>Traits是剝離器，是一種設計抽象（往往人們也把它稱為concept,,滿足concept的實現就是它的一個model，即concept是編譯期關於類型的interface），廣泛應用於stl,loki,等設計理念中（剝離器一般只用於泛型設計，因為需要從泛化了的型剝離並獲得它的traits,實際上這個詞更多地強調的是結果），是成就stl，loki等的支撐邏輯。因為類型有“一般type”,作為template class的迭代器，等等，所以也有相應的type traits,iterate traits.即模板的參數可以是什麼，那麼泛型也可泛化什麼，形成相應的泛化意義（比如traits），因此泛型可以將型別泛化，可以將操作泛化，甚至可以將一大類的操作和型別泛化。更甚至，可以將“template template參數”泛化，注意我並沒有多打字，現列舉可能作為template所有參數的情況，並一一加以解釋：<br><strong>11.2 policy</strong>為什麼需要policy呢，，因為我們知道在應用開發中設計往往是做多選題,對應於應用域在解域和語言域中有大量可供選擇的方案，所以可複用組件最好是給用戶小的設計組件，用戶才能藉以組合它們形成更強大的設計方案（具體到每個領域，它的設計都應該如此,比如loki,的智能指針，仿函數等具體領域都是策略based的）。因為設計元素只能分解而後才能複合，而不應該是一開始就複合了。。如果一開始就提出一個do it all全功能型的接口，那麼往往復用性從一開始就固化了（OO就是如此，單根繼承往往涉及大量不必需的東西進入設計，組合才是科學的機制）。這往往很不好。因為它只能向前發展不能向後發展。那麼組合大量小policy形成的對某個瓴域的某套組合polices，給了我們後退的空間，我們可以組合需要的去除不需要的，這才是我們需要的，即設計中可以在此做選擇題的能力和場所。。<br>第四部分 一個例子：遊戲引擎和實現<br>War3這個遊戲引擎我認為是我見過的頗為先進和完善的引擎，不知你有沒看過War3的“銘謝”CS，它提到這個引擎用到了比如ZLIB，TRUETYPE等庫，下面我們來實現一個屬於我們自己的War3吧，這個War3就叫NotWar3了！<br>是使用本書前面三部分這些知識的時候了，在對這個框架的設計中，我將向你呈現大部分出現在本書中的思想或細節，比如對外來庫的使用，三種思想的運用，建立自己的中間邏輯即庫，基於策略的設計(MetaDesignPolicy)等，並給出作者寫這個框架過程中的一些合理或不合理嘗試，模擬一次真正的軟件工程！<br><strong>第12章 設計（需求分析）<br>12.1 第一天：接到一個案子</strong>客戶要求我做一個類WebGame的遊戲，那麼這是一個什麼樣的類WebGame呢?他們用列舉的方法來提出了以下幾點要求<br>1. XML統一格式的方法來打包客戶端文件，，用xdbm客戶端統一打包（他們事先指定用yake和ogre的xml資源,,,model ,,sketeonl,,,scene），<br>2. 綠色客戶端，如果第一條要求是html,,那麼這就相當於C/S中的瀏覽器,, 客戶端升級接口<br>3. 實現類war3的對戰和遊戲內容，類War3的CS過場界面和錄像機制<br>4. 實現腳本機的擴展，，跟War3一樣提供一個“護展編程接口”， 玩家發佈任務，WorldEditor,<br>5. 界面設計：遊戲界面有三大塊，，用一張圖來表示，，，input設計要好<br>6. 利用Jxta(C的Jxta)來構建網絡環境,遊戲客戶端由於集成Game Logic,因此可設置一個UseLocalLogic和UseFarLogic來選對與P2P環境內的玩家對戰或連接上一個C/S遊戲服務器玩RPG遊戲(此時Use Far Game Logic)。<br>7. 登入時自動下載上次存儲在服務端的遊戲輔助設置(Input設置，自定義頭像和模型)<br>8. 為了能讓這個遊戲更好，，任何你能想到的請自由發揮（可斟情增加報酬）<br>這些需要大部分只是細節要求(很少是架構需要)，因為我們是在模擬外行的用戶不分鉅細向我們提出要求（對於遊戲邏輯，都閃閃其詞）,我們需要整理這些需求以用於後來的設計(說實話以上的需求一般現實見不到)<br>設計跟需求分析之間的關係很重要，這要求這些需求在設計時就應該被全面地提出來(為了擴展的需要，設計應該在允許的範圍內做到全面化和合理化，，但是注意，我在對世界邏輯的設計過程中提到的設計涵蓋面是巨大的，這依其說是僅僅面向需求進行分析，，不如說是大而全的通用設計，而一般人則是分析需求，然後依據經驗直接簡約設計，而這裡我是為了純粹教學，所以請千萬明白這裡的問題)，否則在進入設計期時，就只能通過重構(重構是軟工中一個很重要的部分)的手段來添加新功能！<br><strong>12.2 第二天：需求分析</strong>為什麼要提出這麼一個過程呢？這(對需求的分析)可作為設計的參考,這即為設計的參考技術總結（設計最終要體現這些，從現在開始就要考慮設計與計算機實現的結合點，因此可以用來指導多範型設計）<br>在一個需求中，什麼是遊戲的邏輯部分，什麼是遊戲的客戶端部分，什麼是遊戲設計中後來才需考慮的細節部分，什麼是在進行遊戲設計時先考慮到的架構部分，在哪個架構中提供什麼接口，一個接口應被置於哪個架構中，這不是一個有人作過專門研究的課題，然而如果給出一個具體的例子，我們應能很快地判斷並決定它應放置於客戶端邏輯還是遊戲邏輯(這就是設計方法論學應解決的問題,遊戲邏輯就是業務邏輯，而ClientSideGeneric或ServerSideGeneric就是表現邏輯了,我們也應該能確定需求分析中的哪些是架構哪些是細節)，，<br>9. 利用Lua Bind C++的本地庫來進行擴展接口的設計(客戶端和服務端面向Developer的編程擴展接口),可以動態測試，不用重啟服務器(提供Lua導入功能的界面接口),不過War3的遊戲邏輯全部是用腳本寫的，而這裡用C++寫LogicGeneric和DevelopGeneric，然後導出為Lua所用，再在此基礎上進行擴展出一個具體遊戲(事實上僅僅到這裡為止，才進入“遊戲”的設計，前面的GameGeneric實際上稱為VRGeneric更為合適)<br>10. 針對界面部分，，好像中國的遊戲都是策劃主導編程的，，，策劃提出來的想法大部分都是表現(數值設定，遊戲故事，，等等都是外在表現)，，很少是引擎內部架構（我們說原語設計先於多範型設計，那就是說原語設計是對應用內部架構進行設計而不是一開始就設計應用的外部表現），，實際上編程主導策劃才是對的(當然如果僅僅從技術上來說是這樣的)，因為如果在中間邏輯層次提供了足夠好的接口，那麼外在表現（即實現）可以無限和快速地擴展（然而遊戲開發功利的目的使我們往往顛倒了這種關係,這樣做出來的引擎只能是。。。）客戶端設計DllFromInterLogics,Main.DLL，，，<br>11. 客戶端是瘦客戶端，，這往往它的EXE只是一個渲染框架和界面資料(媒體資料)，客戶端資料比如地圖這些大件可以從官方網站或某個下載點直接下到(分文件或一次性全下載)，或者（這裡才是重點難點）在遊戲中進入一個地圖時如果檢查本地沒有此地圖即顯示First Time Enter This Area，並下載地圖，如果取消下載玩家進入一個黑暗區域但是依然會有障礙,故稱這是一個類Web的Game(真正的WebGame就是用網頁呈現的遊戲，通過80端口進行通信，這樣的遊戲有一點迂腐和小兒科)<br>12. 對於xml統一打包（比如地圖和對戰時的P2P文件共享），封裝各種二進制的格式(比如客戶端的各種格式的文件和Lua代碼，Developer的護展發佈---一個地圖文件封裝Lua代碼)，XML也可作為Jxta的消息通用文檔格式,我注意到有些遊戲引擎的實現把模型資源封裝為XML，這在我個人看來並不是一種好的方法，XML作為Wrapper是好的，然而用它去描述內部某個XML節點數據又是不必要的(個人看法，SQL的擁護者認為XML DB已經超出了數據存儲的原語空間，他們認為XMLDB-這裡著重指NavtiveXMLDB是一種過度設計)這裡用xdbm，，把每一個客戶端文件都作為xdbm的二進制格式，，，這樣就保證了二進制載入和打包的雙重需求<br>13. 對於綠色客戶端，，將GameGeneric置為一個單DLL文件,把Yake的所有中間邏輯封裝者即DLLs和LogicGeneric全部編譯進一個DLL文件，稱為GameEngine.DLL(如果直接在YakeBase中和LogicGeneric中刪除DLL加載邏輯這就需要改動源程序尤其是YakeBase中的Logging機制,而且如果刪除，以後DLL就不能動態裝卸了,而且不利於對GameEngine.dll級的擴展,當然如果不刪除，那麼DLL就以一系列中間邏輯的樣子躺在客戶端這樣不免難看)這就需要定義另外一種加載插件的邏輯，同樣可以做到動態屏蔽和啟用(而非裝卸)和以後對GameEngine.dll級的的擴展(繼承這個屏幕和開啟接口就是了)，<br>不要懷疑，我們正是在做軟件工程(的需求分析階段,,雖然只是初步的分析)和麵向接口編程(因為接下來我們也要做庫和架構)<br>以上都是需求分析,描述一下接下來我們的開發路線，當然是先設計後編碼了(在進入真正的範型設計前，我們先進行一個原語設計，，，整理自己對遊戲的認識，，這中間用到外來庫因此還得說說它)<br>設計前工作<br>14. 遊戲原語設計，，表現設計與細節設計(設計界面等細節，實際上這個步驟可以放到最後，因為這是表現邏輯應次於以下的業務邏輯進行，不要被這個主導設計邏輯)<br>15. 瞭解要用到的庫的架構和接口(Yake表現邏輯)<br>設計部分<br>16. 範型設計並實作LogicGeneric(單OO泛型實作設計)<br>17. 為LogicGeneric寫ExtendGeneric<br>編碼部分<br>Demo編碼(這就是實現，其它的實現通過lua去擴展或為三大架構自寫Plugable 的DLL)</p><p><strong>第13章 設計（領域分析與抽象）</strong><br><strong>13.1 原語設計</strong><br>你理想中的遊戲是什麼樣子呢？什麼又是遊戲(你對遊戲的概念直接影響了你對遊戲的設計)，每個人的看法都會不同吧（反問一下，什麼又不是遊戲，連BBS也可以是一種文字遊戲，但是我們不做這種超級泛化,我們只對3D網遊作泛化）？以下就是我對遊戲尤其是網遊的看法，更準確地說它是框架設計(在完成了這個框架和所有中間邏輯之後，最終的實現編碼的過程很簡單),,這裡把遊戲泛化為“可擴展的虛擬現實對戰”，並設計出一套思想級的協議(就如同下面的一張圖表示的)，並用一套具體代碼庫實現它，但是這顯然是一個巨大的工程(就好像根據P2P和一些其它的規範比如XML來實作出Jxta)，。。<br>以下是一個一定程序上反映我的理想的一個框架設計，哈哈<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/f9ae9dd10f344864b55d78ae3b54dec5><p class=pgc-img-caption></p></div><p><br>我想象中的一個遊戲總原語<br>由上述原語設計（尚屬非常初級的設想）演化到多範型設計或UML實現,中間還需要很多設計上的細節，但我們會一步一步來進行,下面我們繼續進行對虛擬現實這塊進行細化<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/b30ccf6acd6a482d86a3e3322812bb33><p class=pgc-img-caption></p></div><p><br>我想象中的一個虛擬現實原語<br>具體介紹一下<br>世界邏輯管理天氣，地理變遷等遊戲世界自然變遷邏輯和遊戲世界社會關係邏輯(可產生一系列遊戲系統GameSystem,用Plugable的DLL來實現), 數據邏輯(虛擬世界與現實的接口) ,這所有的邏輯由一個叫WorldLogic的組件來封裝(上面的描述)，這個組件就是獨立於表現邏輯(Show Generic)的遊戲邏輯(又稱Logic Generic)，<br>遊戲世界就是一個社會，因此WorldGeneric就作為一個單例代表整個世界，這個世界分為SocietyGeneric和自然Generic,<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/6e5ae0e492e04491815d04385abe2c6f><p class=pgc-img-caption></p></div><p><br>圖1-3 我想象中的一個虛擬世界邏輯原語<br>至於表現邏輯就用Yake，注意Yake僅僅是VR的表現引擎，而WorldLogic是遊戲邏輯引擎，而且可從這二個組件定義出一個具體遊戲(這中間還要通過一個下面要談到的Game抽象層次和建立在Game之上的擴展接口ExtendGeneric)，<br>這裡主要任務是深化對世界邏輯的認識，為以後的設計演化服務<br>實際上世界邏輯設計可以無限地大（實際上我最後實作出的設計也會很大，而且現在一般的大中型遊戲中也的確涉及到了大量的世界邏輯），，，所以現在的遊戲引擎一般都是表現引擎，，真正引擎之後的遊戲源碼部分才會出現一點零散的世界邏輯（而且沒有被形成一個架構，因為人們普遍覺得像世界邏輯這樣的東西根本不應被用來架構並單獨封裝，因為這的確是一個無盡的任務，世界邏輯可以無限啊），，，然而，就現在的大中型遊戲中出現的世界邏輯引擎來說的確可以總而歸為一個架構（我們正是要針對這些作架構，，正如你將會在我的設計中的大量細節），所以在設計中找準問題和思路方向是重要的，用什麼範型只是後來的事情<br>如果一個計設中存在大量細節，，難以分清什麼是細節上的，那些是架構上的，，那麼一個方法是多範型設計中提到的“變點與不變點”，，怎麼說呢，，比如一個遊戲邏輯世界，，總有角色和地圖吧（在經過分析得出大量設計細節後而難以得到一個滿意的分析結果時，這個想法相對來說是比較容易想出來的，歷為角色是實際存在的，，這個分析結果就是能提出一個架構，，並串聯上所有的設計細節），，，，，這二個不變點就可以引導所有的你不能確定的“變點”（比如各種遊戲系統）<br>實作GameGeneric就是用UML來設計接口和大架構,先來設計一個多範型設計圖<br>這個庫我準備將其開源發行，其代號為gvwl=Generic World Logic Libary<br>GameGeneric為Generic Virtual Reality Lib gvrl<br>這一個完全與平臺無關的庫（除了它的DLL形式邏輯，它的內部完全是平臺無關的邏輯），<br>好了，找準了問題之後，現在來歸納問題（世界邏輯到底是什麼，有什麼，，）明白這些事實對以後的設計演化非常重要，而在原語設計部分提出的那個邏輯只是非常高層的我們需要在這裡深入並得出一個確切的設計結果(這樣才能依據它得出確切的範型設計)<br>1． Actor type應有PC（）,NPC,道具(又有很多分法)，電腦之分<br>2． Stage就是任務，有世界任務，國家任務，職業任務，組織任務，居民任務，，玩家任務之分，，<br>3． AI有吸怪AI(Agross AI),,,電腦群攻AI<br>4． 時間就是紀元，當一個設定的世界任務stage被完全(世界任務就是隱創的全世界玩家的關卡)，，，玩家進入一個新的紀元，，天器和器候機制，，對資源分佈和技能發揮，，物品掉落，任務細節，等有影響<br>5． 這個世界邏輯引擎就是一個Actor_Stage_Driven_Dymic_World（完全可以脫離玩家運作，，需要提供一個初始狀態集）,,,,有二種干預方式，GM管理方式和gm Player(比如一個國主玩家，，國政系統)二種干預方式（admin adapter）<br>6． 勢力範圍演變（個人勢力，國家勢力，，組織勢力），，世界地圖，，，資源分佈變遷，合成機制<br>7． War3like 多元故事機制，，多職業機制，，，採用War3的多職業，，技能組合=一種職業，，只有種族之分無明顯的職業之分，，但是種族對技能學習有影響，，玩家遺蹟系統（聲望和稱號系統，，匆濫，，聲望和稱號極其難得，，特殊道具難得）<br>8． 裝備機制，，玩家裝備位，，，<br>9． 少怪多人，，，boss為電腦，，怪物<br>10． 元素互克系統，，傷害數值（保證適當量度的耐打，少團滅，秒殺），能力數值機制（攻擊方式，攻擊傷害，，攻頻，，視野能力，，白天黑夜之分，記憶系統），，，技能分職業技能和自學技能機制，，技能連攜機制，<br>11． 拍賣行和叫賣場，，，叫賣類寵物（dual box like），，，野外僱傭兵機制，，<br>12． 打鬥機制，，城建系統，國戰場，，道具升級系統，，陣法系統，，，Macro和自定義UI的物品/技能欄<br>13． Actor都有一個id和一個名字集，，<br>14． 交通機制，，傳送機制，，時空廣闊，有星外，天上之分，裡世界，玩家可轉服<br>15． 此遊戲<br>以上這些細節如果寫開來，，就是一份很詳盡很佔篇幅的策劃書，，，，因此我們採取了簡單列舉的方法，，，，具體的這些設計的細節和對這些設計的範型實現細節在下面一節會講到。。<br>那麼當設計完成進入多範型之後，我們是用一種自上而下（先提出一種架構然後慢慢發展支節邏輯）還是自下而上呢（先獨立考慮各個支節，再在它們上面架構一個大架構，），這裡的多範型設計我們使用自上而下（因為我個人認為這樣設計得比較全面）<br>我對Game的看法是，<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/03ce885ff0f841628bb2bda970738a17><p class=pgc-img-caption></p></div><p><br>圖1-2我想象中的一個Game原語<br>那麼擴展呢？這裡只說腳本機的擴展,Lua擴展並非真正的功能擴展，而是功能的導出，（當然寫Lua之後的代碼的確可進行功能擴展，但這裡是相於Lua之前的中間邏輯來說的），腳本機的作用在於動態調試和發展用戶邏輯(就是類似War3WorldEditor的開關編輯器了)<br>1,作為GameGeneric一部分時<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e57e84f2c4174b0486397e135a3be1ac><p class=pgc-img-caption></p></div><p><br>2,獨立於GameGeneric之上時<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/9b60d4985ab64b20ae5b150db9a36f68><p class=pgc-img-caption></p></div><p><br>什麼是擴展出來的某具體遊戲呢？它可以是單機(比如做類War3的戰役任務以熟悉遊戲,這就要求遊戲邏輯在本機)，或對戰(類War3的對戰地圖遊戲)，或C/S式的RPG(遊戲邏輯也可以在服務端)，這樣的遊戲並不侷限於FPS或RPG或其它類型，這是一種泛RPG遊戲，形象來說就是服務端的為客戶端和服務端共享這個最終的遊戲就是一個Lua寫成的GameGeneric的派生,可動態測試，Lua解釋器就是一個啟動Shell,因為啟動遊戲等表現邏輯都在ShowGeneric內)，這樣的遊戲，通過它的擴展接口，你可以在一張地圖上設置賽道，這樣就是一個賽車遊戲，可以通過擴展接口，改變遊戲視角，提供一些特別的地圖，就可以做成一個FPS遊戲，但它大體上是一個RPG(遊戲在道理上本來就是一個完整的世界)，因此說它是一種泛RPG遊戲(這再一次體現了，通過某些很好的設計，可以整合某些細節或繞過它們，因此說設計是優於編碼的)<br>這面即為NotWar3的原語圖<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/3bed11545354419496b416aaa80383fe><p class=pgc-img-caption></p></div><p><br>我想象中一個具體遊戲原</p><p><strong>13.2 瞭解Yake</strong>以上談完了原語設計部分，這一節講要用到的庫，就是YAKE了，這一節可能要佔很長篇幅，因為Yake本身是一個很大的架構<br>我發現Yake是一個很好的遊戲引擎(它自稱是VR和遊戲引擎，，但是它明顯沒有提供虛擬世界的內部邏輯，而只是提供了VR和Game對於計算機的表現邏輯而已，為什麼選擇Yake呢？就因為它功能全面至於運行效益也要考慮)，它集成了我們以上提到的多數組件（而且DLL形式的組件可以選擇不編譯而且各個DLL之間沒有相互引用關係對於Yake主體來說完全是Plugable的）（但是我們將按需去掉一些組件，將它集成到GameGeneric上去，比如將LuaBind邏輯和Lua提到GameGeneric上去，把YakeBase中的DLL封裝邏輯和Logging機制去除，因為我們將把Yake編譯成一個靜態庫再為GameGeneric所用，把oSceneLoaderLib去除，因為根本不需要這個功能-不需要把場景圖中每個節點都利用XML展現出來，我們只想用XDMB的二進制Wrapper場景文件(場景文件有它自己的非XML形式的加密格式)，而用XDMB去封裝場景調入邏輯），我們應瞭解它的架構先，並理解其存在哪些API，但是並不深入探索它們是如何實現的，因為我們僅僅是想使用它 (這就表明，我們僅僅要做庫的顧客而不是讓它去主導我們自己的架構)<br>對庫的理解要深入到函數API級(只是瞭解一下並不探索其實現因為我們只是顧客只滿足於調用它並在自己的邏輯中封裝它，但是要當高級顧問時卻要了解它與其它API的聯繫，即該API的實現，因為此時我們調用到了該API的低層,這勢必要清楚它與其它API的聯繫)，而不僅僅滿足瞭解其庫的架構(瞭解Yake總體大架構還是基本，如果能完成理解它的主體即引入其它庫的那些邏輯就更好拿來調用了)，對Yake的研究可以讓你學到不少東西<br>我為什麼要強調“我們只是顧客呢”，人們並不真正理解那些從一出生就耳聞目見的字眼的真正意義，我想信如果不是我加括號，很多人也很難理解出括號內這層意義出來(而顯然這是在我們前面反覆講到的)<br>能寫出像Yake之類高抽象的代碼（除了要懂模板和OO這二種範型的各種技術細節之外,還有策略，可以稱為是OO和模板之上的抽象泛型），更重要的是具備我上面提到的那些設計思想以及對遊戲的認識，流行於程序員之間的用卡來表達設計的方法，最初就是思想的活動，提出一些思想字眼（設計用詞），然後再形成具體類文件的名字寫到卡片上，最終形成一個計算機觀點能接受的範型設計。<br>正如Yake所言，它是一個VR引擎，又是一個Game引擎,它的Base部分提供了DLL裝卸機制和Log機制，這就一定意義上對應我們接下來要談到的“可複用”策略(ORDL)，它除了RAF，Client,Server之外的表現部分是VR的表現部分，而Raf,Client,Server這些都是Game Show部分(顯然Yake沒提供VR Logic和Game Logic部分)，它的LuaBind就是腳本級擴展接口，而Base的DLL和Log機制就是程序員級的擴展接口，下面我們來深刻了解一下這個Base Generic並探索它可以被如何完善的地方,首先來看一個概念<br>面向複用的設計庫(Ori Reuse Design Lib),這個庫是一個策略庫(我們把用模板範型和OO範型來表達設計的技術實現統稱為策略，這樣策略就不只表示DP了)，Generic Design Poliy Lib(通用策略設計庫),那麼這是一個什麼樣的庫呢,這個庫基於以下思想<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/25d96bba7f2d412bbba49df621588526><p class=pgc-img-caption></p></div><p><br>這個庫的另一個別名是：GenericInterLogicPolicyLibrary,Compliler Time 實現與Design Devidded Policy Lib,或Complier Time face可複用 Plugable Pocidy Lib（請原諒我用這麼長的描述，但這不是標題，而且如果缺少任何一個字眼都不完整）,如果把Yake的Base Generic進行完善，它就會這麼一個庫<br>這個Policy用了一些語言內的範型，比如OO和模板，還用了語言外的範型，比如Plugable的DLL，這樣的庫為設計服務（注意這句話），它主要達到一種什麼樣的目的呢, 通過在設計期就分開實現和設計，這樣就達到了在設計期就達到充分的可複用(而可複用顯然無論是設計還是實現都最先考慮的問題，OO和麵向構件都是為了可複用而設計，因此這個庫實際上就整合了這二個方面，語言之內是OO，語言之外是構件)，（你可以看到這個庫為VREngine和NotWar3的各個中間抽象層次所用）<br>與設計期有關的東東常稱為元，比如MetaProgramming,強調設計期的作用，還比如MetaData(強調對數據的描述而不是存儲，關係數據庫的擁護者認為存儲才是數據庫真正要考慮的東西,而存儲是具體數據庫的事，這個道理就像我在本書最後一部分提到的Game與VR的關係，到底具體數據庫才是數據庫，還是對數據的描述才是數據存儲？(什麼是遊戲，具體的遊戲是遊戲，還是遊戲這種泛型說法才是遊戲)這是雞生雞蛋生蛋的問題，以我看，雞蛋問題並非不可解，答案就是先是雞後是蛋，因為在問題中，雞字蛋字都是具體的)因此上述庫還可稱為MetaDesignPolicy<br>運行期=計算機實現=泛型實現(RTTI),因此可複用的最大限度是你的泛型實現<br>圖的左邊是“與平臺有關的表現”，稱為表現Generic(需用與計算機平臺有關的多範型表達),右邊是“不與平臺有關的純思想”，這樣就做到了在設計期就充分考慮了實現與邏輯分開（設計與編碼是統一的，設計期就充分考慮了可複用，那麼在編碼時自然會繼承這個優勢，一切編碼和實現級的的不可複用問題和難於複用問題都可在設計期找到答案，設計與實現本來就是統一多於其矛盾的，他們的矛盾之處在於泛型設計與原語設計的矛盾，比如在設計期把遊戲中的一片葉子當成一個對象有時是一種好設計，然而當被用於多泛型實現時，在運行時就會造成效率的低下，這就是不成功的多範型設計，當然，實現與邏輯分開這個說法絕非這麼簡單,因此我們在SHOW和LOGIC內部也需要考慮將其OO化或策略化以增強其內部的實現與邏輯），誠然，OO可以一定程序上做到“實現與邏輯分開”，但是還有策略，然而這是語言內部的，在語言外部是庫(Plugable的DLL形式發揮了重要的作用)，這個技術也可提供設計時的可複用(當然可複用永遠是相對的，在應用上述圖作出的應用架構，在各個Genric外至少是實現與邏輯分開的，當然各個Generic的SHOW或LOGIC部分也要做到可複用)，這樣就是<br>1． 要保證在實現與Logic內部也是實現與邏輯分開的和充分的Plug化<br>2． 要保證Logic部分絕對是思想而沒有與平臺相關的細節<br>3． 在每一個Genric層次，可以無Logic，但不可沒有Show<br>以的圖可對應到NotWar3的原語設計部分,而它們共同的基礎就是這個面向複用的策略庫<br>即<br>1. Extend Generic=Game Generic+Lua Bind Generic(或者Game Generic自成一個Generic，此時就要求Lua Bind不是僅對Game Genric進行Bind,而是對下面各個Genric進行Bind)<br>2. VR Generic=Yake+World Logic Generic<br>3. Game Generic<br>4. 它們的下面是Yake Base<br>即見下面這個總原語圖<br></p><div class=pgc-img><img alt=新手編程導論(十) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/d8adf0b1596c479387e28882ff93916c><p class=pgc-img-caption></p></div><p><br>請注意到，上述圖中很多用詞顯然僅屬於思想過程的中間描述（即僅僅是描述原語的用詞,比如GameGeneric中的Generic這個詞就表示它可能是一種架構邏輯也可能是實現邏輯，這裡就用Generic來整個描述這個層次抽象, 即Generic=”一切中間邏輯”代詞，它並不一定被封裝成一個庫也並不一定要在後來的多範型設計中要求被體現，可能會在源程序中用名字空間來表達,C++中的名字空間表達了一種什麼樣的本質呢？一個名字空間就是一個應用架構中某個子架構，或稱為抽象層次的總稱,而我們這裡提出了四個即1.Design Policy Generic2,VR Generic3,Game Generic4,Extend Generic,其中3,4是特別的，如果3是為4服務，那麼3,4實際上可以合併，如果Game有它自己的架構，那麼3,4是分開的,Generic,Generic就是一種組織所有某個抽層的架構和實現的形式,名字空間也使我們的源程序能夠很好地硬盤上被組織，Java的源程序包中的文件夾形式就是一種表現），因為我們此時在進行原語設計，不必考慮面向代碼將其反映出來,這樣我們考慮問題的範圍會更廣一點（實際進行多範型設計時要反映出來的就是那些能實際作用代碼的用詞,像上面大部分後帶Generic飾詞的中間邏輯集都要被體現,我們在實作部分會給出一個經過修飾的原語圖,從原語設計到多範型設計到UML設計我們稱為設計的演化），但無論如何要明白，一些對設計過程中用到的思想輔助用詞是不必考慮進設計的代碼實現的。原語設計跟多範型設計中間存在比較大的距離(真正的原語設計不是超級原語，雖然它名為原語，但它是在可控範圍內權衡做到的原語，真正的多範型也並不是一團沒有根據的計算機實現，它要也要面向前面的原語設計得出的結論,它們之間的聯繫要優於它們之間的區別被我們考慮)<br>不必拘泥以上的思想模型（任何人構架的邏輯模式和邏輯用詞都可以不一樣這不是嚴格的，但最終的應用反映在代碼上要能工作這卻是嚴格的），你畫出的原語設計圖同樣正確，再簡單也沒關係，也不一定要成檔，因為這只是嚴重參雜了個人看法的東東(只有當後來的多範型設計時才慢慢走入編程的束縛,因為這是參照編程界現成方案的設計，因此大家做出的設計都差不多一樣)<br>這裡再談一下可複用與“邏輯實現”分開之間的聯繫（主要出現在設計期和重構期）<br>我們一直提倡邏輯與實現分開(這是設計的基本準則)，這樣設計有沒有做到呢？，這裡要說一下實現與邏輯分開，然而即便是這個說法本身也有點含糊，說實話這絕對是一個具體問題具體分析的活，(就以上面的設計來說，我至少可以找出幾個邏輯與實現的說法，比如，但是大體上可以分為二類，Generic外部的和內部的，反正我自認為上圖已經體現了足夠好的邏輯與實現分開，如果你不這麼認為，那麼你一定有比我更好的方案,不妨說出來聽聽或指出我的缺點，對於實現與邏輯分開，我曾認真思考過為GameLogicGeneric中的每個個體增加一種聯繫到GameShowGeneric,但是這個設計我後來放棄了，這樣做看起來合理實際上只會增加實現與邏輯的偶合性而且在實現上也是很複雜的,而且壓根就不需要這樣做因為GenericInterLogicPolicyLib已經是一種很好的方案,已經是一種根本的實現與邏輯分開策略，,需要作一層複雜的中間封裝邏輯,這層抽象可能被集成到GameGeneric中)一個遊戲GameGeneric就是LogicGeneric加上ClientSideGeneric的總和(邏輯上下或平等互飾構成邏輯總和,應用於是被建立起來)並由此定義出一個遊戲比如NotWar3(這才是真正的編碼與實現部分，就是幾個Demo中要談到的),或者我們可以把實作出的LogicGeneric置於ClientGeneric的底層(,這正是我們要採取的方式,作為中間邏輯的庫之間應如何架構，它們之間的邏輯應如何,這也是我們要考慮的)。<br>我的一些不成熟的嘗試和不成熟的思想導致的設計缺陷<br>1. 我曾設想Lua部分寫Game.dll,我把總架構做到了擴展邏輯之後作為Lua代碼，因為我認為那是具體遊戲的事而不是GameEngine的事了,因為我還覺得“具體遊戲才是遊戲”，而這裡的GameEngine似乎稱為“用計算機模擬遊戲世界的引擎”(ComputerSimutWorldEngine)更為合適，因此GameEngine.DLL最好的說法是VREngine,但是另一方面，也有另外一種做法那就是把擴展邏輯和VR邏輯中間放置一個Game總架構邏輯，這樣G總架構邏輯就在Lua之前了，會是C++的代碼，這樣也是一種非常好的選擇)遊戲是一個對等或C/S的模型，因此分PeerSideGeneric和ServerSideGeneric,(我一開始設計時GameGeneric曾把這二個設計原語加了進去,說實話這就不是一個好的設計，因為只要在具體遊戲的邏輯中才會出現客戶端和服務端之說，而GameGeneric管理一些更為低層的邏輯，這樣做就犯了設計的大忌，過早把實現混合成架構做進了設計中)<br>2. lua擴展是不是限制了lua級擴展的瓶頸（要深克明白腳本機擴展導出與動態修改的作用區別），因為導出的邏輯有限？當然這個擴展接口並不能導出全部的中間邏輯，實際上也沒有必要（LUA級的擴展不需要導出從一開始到GameGeneric的全部中間邏輯）這裡要深刻理解這個擴展接口(因為多範型設計與細節有關，只要明白各個中間抽象層次應有的細節，才能依據它來進行多範型設計)，擴展接口架構在GameEngine之上（但並不需要導出這個構架），但是擴展邏輯不只是封裝GameEngine這個中間邏輯層的某些接口（即它不是一個純粹架構於GameGeneric之上的中間邏輯,雖然在原語設計圖中它是，然而在範型實現中並不是這樣），而是分別對其它中間邏輯層次有引用(即它必須對OIS有導出邏輯才能在擴展接口集中提供一個屏蔽鼠標的LUA接口，必須對RAF作導出邏輯才能在擴展集中提供啟動一個遊戲的功能，必須對CAMERA作導出才能在LUA級提供一個變換視角的遊戲—而這個功能正是LUA級擴展必要的，，因為玩家寫地圖時總要調用到變換視角的功能，，比如通過LUA擴展出的一個泛RPG的FPS遊戲，LUA護展級應提供什麼功能和接口，可以參照WAR3WORLDEDITOR中的全部開關功能)LUA級的擴展全部是函數級的接口，而不是OO級的架構，，一方面是因為用LUA編程的玩家你不能要求他們有OO範型的思維，另一方面是因為實際的通過LUA擴展的過程只要用面向過程就夠了並不需要形成一個架構，無非就是轉動視角，控制遊戲開啟這些簡單對外的邏輯,對內的擴展只能通過為Game.DLL寫DLL來擴展----(而且LUA本身支持OO也不是很好)當然也存在另外一種做法，這就是把GameGeneric這整個抽象層次作為為Extend Generic服務的基礎，也即它並不指代一個“Game”，並不打算把它設計成一個架構,而只是簡單的對要導出的庫(比如VREngine的方方面面)擴展封裝,這樣GameGeneric實際上就是1,GameGeneric加2,Extend的綜合了</p><p><strong>13.3 GVWL1.0開發</strong>荒世：一個簡單遊戲引擎的實現<br>這一部分的目的就是為了產生一個遊戲引擎可複用庫，向讀者展示的是設計能力。。<br>這裡的設計在不同的情境下有二種意思，1，面向複用的工程設計，2，用語言映射現實問題的解法。。<br>當然，這不是遊戲引擎，，僅僅是個可稱為圖形引擎的東西（當然，限於教育目的，我並不打算把它寫得跟ogre一樣面面具到不提供很多接口過多選擇，比如GL，DX）。然而，通過增加網絡邏輯，等其它方面的邏輯，它就可以形成為一個遊戲引擎(作業：重構裡面有相應的作業)<br>這個遊戲引擎充分利用了stl和loki邏輯。而且還複用了OPENGL，我始終相信stl和loki才是標準庫，為了最大清楚程序地呈現利用C++和這二個語言標準庫來設計應用，，，我沒有引入太多的庫，，我剋意不引進太多的第三方庫，（所以很多小邏輯我都直接發明輪子以避免使用到第三方庫），，因為這是基於前述清楚教育的目的而且我個人能力也有限,,(比如下面我不會的碰撞檢測邏輯所以我剛好省掉它）；，所以這個遊戲引擎也是省略了很多功能的（比如碰撞等瓴域邏輯，本來一般圖形引擎和遊戲引擎是需要ODE的但我省了），。但這個庫作為遊戲引擎，最最基礎的功能它還是都包括的，你完全可以二次開發，加入更多複用邏輯或自己的邏輯，，將其擴展成大全的遊戲引擎。<br>這個產生的庫要求很強的擴展能力(很強的被複用能力，所以要求基於複用的設計元素)，所以我用了LOKI，OO方面的東西用得比較少（因為我相信template 加loki的設計能力和理念作為設計標準庫，就該善用它，而OO更應該用在非設計的實現中，因為用OO設計複用時需要大量的學習成本，不應用OO 的眼光對設計分層級）。<br>當發展具體遊戲也即實現部分時應該遠離設計, 畢竟複用是設計複用，而不是實現複用,，但這個實現也有這個實現意義上的設計(因為二者根子上都是軟件抽象的本質)，設計與實現這二者是在某個範圍相對的，而且只有模糊分界，,面對整個系統時架構師有劃分，而且在程序員某模塊中也有小設計，所以C++的各項語言能力，都可用來設計或編碼，它是應用語言也是設計語言,,只是OO不太適合出現在面向複用的設計中）：不要提供很大的跟OO一樣的logics,,,只有通過設計模式串聯起來的才是大邏輯（這才是銀彈,OO維度太低了），，其它的都是小邏輯，就跟boost裡面的庫一樣。。<br>設計中主要解決的大大小小的瓴域邏輯有如下（因為這些庫邏輯最終要進入實現，所以我只在設計中含有最基礎最原子的那些功能和接口，比如圖形方面的邏輯，動畫啊什麼的，(這是業務領域的輪子，，外來輪子才是另外輪子，源程序樹應該另外輪子各佔一文件夾，主就放在根文件夾內)，更高階部分才發展業務領域邏輯，發展更高階的邏輯，比如場景管理，資源管理，，<br><strong>13.4 範型設計與實作</strong>那麼以上多範型設計圖中，“面向用戶和開發者”的高階接口應提供什麼呢，這並不是一個有標準答案的問題(這不可能是一個形式的活動，只能是一個感性的活動)，根據“設計的方法學”，我們只需做列舉題與選擇題,比如以下：<br>1， 是不是應提供一個“”，我以前想到用Actor封裝，Stage封裝<br>2， 如果要提供播放CS的邏輯中間件，（因為CS可能要獲取網絡）那麼是不是應提供一個類，這個類接受網絡參數，這樣就有引用到Yake 的Net,不，，絕對不能這樣,,，這樣會增加表現與邏輯的聯繫，，這樣做出的類（集）接口就是不好的接口設計，，，想要什麼樣的應用邏輯總是可以用邏輯互飪的方法達到，，而基礎的中間邏輯件部分只應提供屬於它自己職責的獨立邏輯。最好不要與其它邏輯交叉（往往將遠離應用的中間邏輯稱為真正的接口，，，而靠近應用的實現邏輯，，或應用邏輯本身稱為真正的實現，，只要不過早地將實現邏輯做進或混入接口邏輯，，那麼你就做到了實現與邏輯分開，，，也即這裡“真正的接口”主要就是發揮橋接作用的接口邏輯，因為接口邏輯也算是中間邏輯，應在這些抽象層次上提供少量邏輯，，，，後來的大量實現邏輯靠前面的接口邏輯來擴展，，）<br>我們要寫什麼樣的實現呢，注意我們還得為實現構造一個架構(實際上這個還可做到GameGeneric之上，但是這個應該屬於具體遊戲的邏輯了，因此我們還是做到NotWar3的Lua代碼構架中去)<br>純邏輯的庫ODE，也跟LogicGeneric一樣吧，，不需考慮平臺相關，Logic級應提供什麼功能接口，應參照WAR3的JASS的二個基本文件來設計，那裡有大部分遊戲世界邏輯(但JASS用了過程，這裡是C++用OO來實現)，，應考慮到遊戲世界這個相對它的Plugable dll的“高階”中間邏輯層次應提供什麼邏輯跟接口(很明顯，這裡面應有一個能容納Plug邏輯的引入邏輯的架構(但是YAKE的引入庫邏輯是引用現有的庫，而這裡的總架構是先於PLUG的，因此更為靈活和自由，應提供類ADDAFORCE之類的總擴展接口，才能為PLUG留足夠好的對主LOGICL架構的擴展空間)，和一個類YAKE BASEGENERIC的實現集，因為需要用到DLL和LOG機制，)，<br>下面設計出一個UML圖，這步開始，我們就進入設計的編碼實現了，這步過後，設計就完成了</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>編程</a></li><li><a>導論</a></li><li><a>新手</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/8df37fda.html alt=新手編程導論（九） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0bf11efddc9d41d1908a368d1c11824c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8df37fda.html title=新手編程導論（九）>新手編程導論（九）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a86cb2c2.html alt=新手編程導論（七） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3ce280dbe328491f8bc043512295d4d3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a86cb2c2.html title=新手編程導論（七）>新手編程導論（七）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html alt=《JAVA編程思想》5分鐘速成：第8章（多態） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/399a29d93fde48fca4bae44dffbced07 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9cfcdd6f.html title=《JAVA編程思想》5分鐘速成：第8章（多態）>《JAVA編程思想》5分鐘速成：第8章（多態）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html alt=「編程基礎」PHP基礎教程（二） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/17685aad04c54d02928724fb99fea026 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ede16bf9.html title=「編程基礎」PHP基礎教程（二）>「編程基礎」PHP基礎教程（二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html alt=「編程基礎」PHP基礎教程（一） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/355d0f0c0f274bdfaeb90747dbd918fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69e45bf9.html title=「編程基礎」PHP基礎教程（一）>「編程基礎」PHP基礎教程（一）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html alt=零基礎如何學PHP編程語言？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96f9421.html title=零基礎如何學PHP編程語言？>零基礎如何學PHP編程語言？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html alt=編程是什麼——世界第一臺電子計算機 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/aac93e54a8f84d04b0d01165200ce1a2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e6dcd03.html title=編程是什麼——世界第一臺電子計算機>編程是什麼——世界第一臺電子計算機</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html alt=遊戲引擎編程需要哪些基本數學知識？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3f6ca97249fa468db6982c44a024979d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7eb8afcd.html title=遊戲引擎編程需要哪些基本數學知識？>遊戲引擎編程需要哪些基本數學知識？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html alt=UG編程獨當一面，如何提高鑽孔精度方法？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1532093430052c29be7656f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e4bfe813.html title=UG編程獨當一面，如何提高鑽孔精度方法？>UG編程獨當一面，如何提高鑽孔精度方法？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html alt=Java高級編程基礎：如何理解進程、線程與併發編程的關係 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/426d60ae-7dd7-4ab4-90bd-4dfeb286a68b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a6fdce0f.html title=Java高級編程基礎：如何理解進程、線程與併發編程的關係>Java高級編程基礎：如何理解進程、線程與併發編程的關係</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html alt=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6fea5f2744614de3884ab26fa09e5a40 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2806cf4d.html title=嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥>嵌入式Linux編程——程序員小白不懂的進程、信號量、併發、互斥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html alt=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3058ca03-deee-4287-a38c-9163687a0673 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/94aaef2d.html title=C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上>C/C++編程筆記：簡單遍歷二叉樹，遍歷源碼獻上</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html alt=java流式編程思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/92118583492140e3b610df69c711fd87 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f388f45d.html title=java流式編程思想>java流式編程思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html alt=Linux網絡編程——UDP廣播詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a2667182b3d34b2e98e8503a00af90fd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7e66a0e7.html title=Linux網絡編程——UDP廣播詳解>Linux網絡編程——UDP廣播詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html alt=盤點那些爭議最大的編程觀點，看看你有什麼見解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/501956d4daa845caa468124f22bb35f8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/636b1830.html title=盤點那些爭議最大的編程觀點，看看你有什麼見解>盤點那些爭議最大的編程觀點，看看你有什麼見解</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>