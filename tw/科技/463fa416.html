<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>MySQL無鎖化WAL系統那些事兒 | 极客快訊</title><meta property="og:title" content="MySQL無鎖化WAL系統那些事兒 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/827b597cea3c4927a30175adbb9ed922"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/463fa416.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/463fa416.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/463fa416.html><meta property="article:published_time" content="2020-10-29T21:09:58+08:00"><meta property="article:modified_time" content="2020-10-29T21:09:58+08:00"><meta name=Keywords content><meta name=description content="MySQL無鎖化WAL系統那些事兒"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/463fa416.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>MySQL無鎖化WAL系統那些事兒</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><h3 class=pgc-h-arrow-right><br></h3><div class=pgc-img><img alt=MySQL無鎖化WAL系統那些事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/827b597cea3c4927a30175adbb9ed922><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>概述</h3><p>數據庫系統一般採用WAL(write ahead log)技術來實現原子性和持久性，MYSQL也不例外。WAL中記錄事務的更新內容，通過WAL將隨機的髒頁寫入變成順序的日誌刷盤，可極大提升數據庫寫入性能，因此，WAL的寫入能力決定了數據庫整體性能的上限，尤其是在高併發時。</p><p>在MYSQL 8以前，寫日誌被保護在一把大鎖之下，本來並行事務日誌寫入被人為串行化處理。雖簡化了邏輯，但也極大限制了整體的性能表現。8.0很大的一部分工作便是將日誌系統並行化。</p><h3 class=pgc-h-arrow-right>日誌並行化</h3><p>日誌並行化的思路也很簡單：將寫日誌拆分為兩個過程：</p><ol start=1><li>從內存log buffer中為日誌預留空間</li></ol><p>2. 將日誌內容拷貝至1預留的空間</p><p>而在這兩個步驟中，只需要步驟1保證在多併發併發預留空間時的正確性即可，確保併發線程預留的日誌空間不會交叉。一旦預留成功，步驟2各併發線程可互不干擾地執行拷貝至自己的預留空間即可，這天然可併發。</p><p>而在步驟1中也可以使用原子變量來代替代價較高鎖實行預留，在mysql 8實現中，其實就兩行代碼：</p><pre><code>Log_handle log_buffer_reserve(log_t &amp;log, size_t len) {    ...    const sn_t start_sn = log.sn.fetch_add(len);    const sn_t end_sn = start_sn + len;    ...}</code></pre><p>可以看到，只需要一個原子變量log.sn記錄當前分配的位置信息，下次分配時更新該log.sn即可，非常簡潔優雅。</p><p>8.0中引入的並行日誌系統雖然很美好，但是也會帶來一些小麻煩，我們下面會詳細描述其引入的日誌空洞問題並闡述其解決方案。</p><h3 class=pgc-h-arrow-right>Log Buffer空洞問題</h3><p>Mysql 8.0中使用了無鎖預分配的方式可以使MTR並行地將WAL日誌寫入到Log Buffer，提升性能。但這樣勢必會帶來Redo Log Buffer的空洞問題，如下：</p><div class=pgc-img><img alt=MySQL無鎖化WAL系統那些事兒 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/4227f14c46a243759c49e77d338f7d57><p class=pgc-img-caption></p></div><p>上圖中，3個線程分別分配了對應的redo buffer，線程1和3已經完成了wal日誌內容的拷貝，而線程2則還在拷貝中，此時寫入線程最多隻能將thread-1的redo log寫入日誌文件。 為此，MySQL 8.0中引入了 <strong>Link_buf</strong> 。</p><h3 class=pgc-h-arrow-right>Link_buf原理</h3><p>Link_buf用於輔助表示其他數據結構的使用情況，在Link_buf中，如果一個索引位置index處存儲的是非0值n，則表示Link_buf輔助標記的那個數據結構，從index開始後面n個元素已被佔用。</p><pre><code>template &lt;typename Position = uint64_t&gt;class Link_buf { private:  ...  size_t m_capacity;  std::atomic&lt;Distance&gt; *m_links;  alignas(INNOBASE_CACHE_LINE_SIZE) std::atomic&lt;Position&gt; m_tail;};</code></pre><p>Link_buf是一個定長數組，且保證數組的每個元素的更新是原子操作的。以環形的方式複用已經釋放的空間。</p><p>同時Link_buf內部維護了一個變量 m_tail 表示當前最大可達的LSN。</p><p>Innodb日誌系統中為Log Buffer維護了兩個Link_buf類型的變量 recent_written 和 recent_closed 。示意圖如下：</p><div class=pgc-img><img alt=MySQL無鎖化WAL系統那些事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f1b02edfb4b74c96b0a59c375f5ae60c><p class=pgc-img-caption></p></div><p>上圖中，共有兩處日誌空洞，起始的LSN為lsn1與lsn3，均有4個字節。而lsn2處的redo log已經寫入，共3個字節。在 recent_written 中，lsn1開始處的4個atomic均是0，lsn3同樣如此，而lsn2處開始的存儲的則是3，0，0表示從該位置起的3個字節已經成功寫入了redo日誌。</p><p>接下來當lsn1處的空洞被填充後，Link_buf中該處對應的內容就會被設置，如下：</p><div class=pgc-img><img alt=MySQL無鎖化WAL系統那些事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/0cb803821dbb4986b9754a634a3b29e7><p class=pgc-img-caption></p></div><p>同理，當lsn3處的空洞也被填充後，狀態變成下面這樣：</p><div class=pgc-img><img alt=MySQL無鎖化WAL系統那些事兒 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de6b8c77b1e941cd99b0b09b8364ae6c><p class=pgc-img-caption></p></div><h3 class=pgc-h-arrow-right>Link_buf實現</h3><p><strong>初始化</strong></p><pre><code>bool log_sys_init(...){    ...    log_allocate_recent_written(log);    ...}​constexpr ulong INNODB_LOG_RECENT_WRITTEN_SIZE_DEFAULT = 1024 * 1024;ulong srv_log_recent_written_size = INNODB_LOG_RECENT_WRITTEN_SIZE_DEFAULT;​static void log_allocate_recent_written(log_t &amp;log) {  // 默認值為1MB  log.recent_written = Link_buf&lt;lsn_t&gt;{srv_log_recent_written_size};}​// Link_buf構造template &lt;typename Position&gt;Link_buf&lt;Position&gt;::Link_buf(size_t capacity)    : m_capacity(capacity), m_tail(0){  ...  m_links = UT_NEW_ARRAY_NOKEY(std::atomic&lt;Distance&gt;, capacity);  for (size_t i = 0; i &lt; capacity; ++i) {    m_links[i].store(0);  }}</code></pre><p>從構造函數中可以看到，LinkBuf內核心成員是一維數組，數組的成員類型是原子類型的Distance（uint64_t），數組成員個數則由創建者決定，如Innodb中為recent_written創建的LinkBuf的數組成員個數為1MB，而為recent_closed創建的LinkBuf的數組成員個數為2MB。</p><p>同時，創建完成後會將數組的每個成員初始化為0。</p><h3 class=pgc-h-arrow-right>mtr log拷貝完成</h3><p>mtr在commit時會將其運行時產生的所有redo log拷貝至Innodb全局的redo log buffer，這藉助了 mtr_write_log_t 對象來完成，且每次拷貝按照block為單位進行。需要說明的是：一個mtr中可能存在多個block來存儲mtr運行時產生的redo log，每個block拷貝完成後均觸發一次Link_buf的更新。</p><pre><code>struct mtr_write_log_t {  bool operator()(const mtr_buf_t::block_t *block) {    ...    // 拷貝完成後觸發LinkBuf更新    log_buffer_write_completed(*log_sys, m_handle, start_lsn, end_lsn);  }}​void log_buffer_write_completed(log_t &amp;log, const Log_handle &amp;handle,                                lsn_t start_lsn, lsn_t end_lsn) {  ...  // 更新本次寫入的內容範圍對應的LinkBuf內特定的數組項值  log.recent_written.add_link(start_lsn, end_lsn);}​template &lt;typename Position&gt;inline size_t Link_buf&lt;Position&gt;::slot_index(Position position) const {  return position &amp; (m_capacity - 1);}​template &lt;typename Position&gt;inline void Link_buf&lt;Position&gt;::add_link(Position from, Position to) {  // 定位本次寫入的內容範圍所在數組項index  // 算法是將起始lsn(@from)對數組容量取模，即from % capacity  const auto index = slot_index(from);  auto &amp;slot = m_links[index];  slot.store(to - from);}</code></pre><p>在這裡會找到start_lsn對應的slot，並在該slot內設置值為end_lsn - start_lsn，記錄該位置處已寫入的內容數量。</p><p><strong>log_advance_ready_for_write_lsn</strong></p><p>Innodb將redo log buffer內容寫入日誌文件時需要保證不能存在空洞，即在寫入前需要獲得當前最大的無空洞lsn。這同樣依賴LinkBuf。在後臺寫日誌線程 log_writer 的 log_advance_ready_for_write_lsn 函數中完成。</p><pre><code>void log_writer(log_t *log_ptr) {    ...    for (uint64_t step = 0;; ++step) {      (void)log_advance_ready_for_write_lsn(log);    }}​bool log_advance_ready_for_write_lsn(log_t &amp;log) {  const lsn_t write_lsn = log.write_lsn.load();  const auto write_max_size = srv_log_write_max_size;​  auto stop_condition = [&amp;](lsn_t prev_lsn, lsn_t next_lsn) {    return (next_lsn - write_lsn &gt;= write_max_size);  };  const lsn_t previous_lsn = log_buffer_ready_for_write_lsn(log);​  if (log.recent_written.advance_tail_until(stop_condition)) {    const lsn_t previous_lsn = log_buffer_ready_for_write_lsn(log);    return (true);  } else {    return (false);  }}</code></pre><p>這裡的關鍵在於函數 Link_buf::advance_tail_until ，即推進Link_buf::m_tail。</p><pre><code>bool Link_buf&lt;Position&gt;::next_position(Position position, Position &amp;next) {  const auto index = slot_index(position);  auto &amp;slot = m_links[index];  const auto distance = slot.load();  next = position + distance;  return distance == 0;}​bool Link_buf&lt;Position&gt;::advance_tail_until(Stop_condition stop_condition) {  auto position = m_tail.load();  while (true) {    Position next;    bool stop = next_position(position, next);    if (stop || stop_condition(position, next)) {      break;    }    /* 回收slot */    claim_position(position);    position = next;  }  if (position &gt; m_tail.load()) {    m_tail.store(position);    return true;  } else {    return false;  }}</code></pre><p>這裡的原理也比較簡單，可以用下面的圖來表示：</p><div class=pgc-img><img alt=MySQL無鎖化WAL系統那些事兒 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/29eeefb00be2484a8d7d7baec8d214d7><p class=pgc-img-caption></p></div><p>簡單來說，就是從上次尾部位置(m_tail)開始，順序遍歷數組，如果該項不為0，則推進m_tail，否則意味著出現了空洞，就不能再往下推進了。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>MySQL</a></li><li><a>無鎖化</a></li><li><a>WAL</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html alt="MySQL 事務處理" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0be408a4.html title="MySQL 事務處理">MySQL 事務處理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html alt="MySQL 學習筆記" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c9091681.html title="MySQL 學習筆記">MySQL 學習筆記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html alt=MySQL——事務(Transaction)詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/29d4c92c9c2344838eb72ef948cf08fa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8a538d3c.html title=MySQL——事務(Transaction)詳解>MySQL——事務(Transaction)詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html alt=MySQL事務隔離級別 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2d4e804a44534da997212c94ea61e90c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a79ba4c0.html title=MySQL事務隔離級別>MySQL事務隔離級別</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html alt=MySQL數據庫的事務管理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/152203544367254a708f807 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3269d080.html title=MySQL數據庫的事務管理>MySQL數據庫的事務管理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html alt=[玩轉MySQL之九]MySQL實現ACID之原子性 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/bdb044d821f74107a3fd9119fc34c642 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2d12804e.html title=[玩轉MySQL之九]MySQL實現ACID之原子性>[玩轉MySQL之九]MySQL實現ACID之原子性</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html alt="圖解MySQL | 「原理解析」 MySQL組提交(group commit)" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/e5444e9094614d6b88bd3fc8ac0524fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/156d2a92.html title="圖解MySQL | 「原理解析」 MySQL組提交(group commit)">圖解MySQL | 「原理解析」 MySQL組提交(group commit)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html alt=MySQL系列-第14篇：事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a5b520dd476345e2b3aac97a8fcb77d5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7d322f7b.html title=MySQL系列-第14篇：事務詳解>MySQL系列-第14篇：事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html alt=MySQL進階之InnoDB事務原子性實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/e1d208ac-c0ed-4238-bce5-e4b3760228c3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d95e4e3f.html title=MySQL進階之InnoDB事務原子性實現原理>MySQL進階之InnoDB事務原子性實現原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html alt=你知道MySQL的事務處理和隔離級別嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/efc2a519.html title=你知道MySQL的事務處理和隔離級別嗎？>你知道MySQL的事務處理和隔離級別嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html alt="我對 MySQL 鎖、事務、MVCC 的一些認識" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5d6e32482c364fe3b5f9436a30671330 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf061a5c.html title="我對 MySQL 鎖、事務、MVCC 的一些認識">我對 MySQL 鎖、事務、MVCC 的一些認識</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html alt="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4959ed6a.html title="技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務">技術分享 | MySQL 的嵌套事務、自治事務與鏈式事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html alt="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/107897c16ae7461caa62dd375b631afe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad3f3a1e.html title="數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務">數據庫技術：MySQL 基礎和 SQL 入門，單表、約束和事務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html alt=深入學習MySQL事務：ACID特性的實現原理「轉」 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/cdc702d66d6943499997d11e931425eb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/175f9730.html title=深入學習MySQL事務：ACID特性的實現原理「轉」>深入學習MySQL事務：ACID特性的實現原理「轉」</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html alt=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/8f370516-d41a-4803-84ba-2c01e4637c8b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8ff1c7a8.html title=解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理>解讀數據庫：深入分析MySQL中事務以及MVCC的實現原理</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>