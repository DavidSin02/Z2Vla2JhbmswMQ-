<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>牛人講解Java可重入鎖原理 | 极客快訊</title><meta property="og:title" content="牛人講解Java可重入鎖原理 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/1535262549376823724db60"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4672a0fb.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4672a0fb.html><meta property="article:published_time" content="2020-11-14T20:55:06+08:00"><meta property="article:modified_time" content="2020-11-14T20:55:06+08:00"><meta name=Keywords content><meta name=description content="牛人講解Java可重入鎖原理"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4672a0fb.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>牛人講解Java可重入鎖原理</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><br></h1><p><strong>一、 概述</strong></p><p>本文首先介紹Lock接口、ReentrantLock的類層次結構以及鎖功能模板類AbstractQueuedSynchronizer的簡單原理，然後通過分析ReentrantLock的lock方法和unlock方法，來解釋ReentrantLock的內部原理，最後做一個總結。本文不涉及ReentrantLock中的條件變量。</p><p><strong>1.1、Lock接口</strong></p><p>Lock接口，是對控制併發的工具的抽象。它比使用synchronized關鍵詞更靈活，並且能夠支持條件變量。它是一種控制併發的工具，一般來說，它控制對某種共享資源的獨佔。也就是說，同一時間內只有一個線程可以獲取這個鎖並佔用資源。其他線程想要獲取鎖，必須等待這個線程釋放鎖。在Java實現中的ReentrantLock就是這樣的鎖。另外一種鎖，它可以允許多個線程讀取資源，但是隻能允許一個線程寫入資源，ReadWriteLock就是這樣一種特殊的鎖，簡稱讀寫鎖。下面是對Lock接口的幾個方法的總體描述：</p><p>方法名稱描述lock獲取鎖，如果鎖無法獲取，那麼當前的線程就變為不可被調度，直到鎖被獲取到lockInterruptibly獲取鎖，除非當前線程被中斷。如果獲取到了鎖，那麼立即返回，如果獲取不到，那麼當前線程變得不可被調度，一直休眠直到下面兩件事情發生：1、當前線程獲取到了鎖2、其他的線程中斷了當前的線程</p><p>tryLock如果調用的時候能夠獲取鎖，那麼就獲取鎖並且返回true，如果當前的鎖無法獲取到，那麼這個方法會立刻返回falsetryLcok(long time,TimeUnit unit)在指定時間內嘗試獲取鎖如果可以獲取鎖，那麼獲取鎖並且返回true，如果當前的鎖無法獲取，那麼當前的線程變得不可被調度，直到下面三件事之一發生：1、當前線程獲取到了鎖2、當前線程被其他線程中斷</p><p>3、指定的等待時間到了</p><p>unlock釋放當前線程佔用的鎖newCondition返回一個與當前的鎖關聯的條件變量。在使用這個條件變量之前，當前線程必須佔用鎖。調用Condition的await方法，會在等待之前原子地釋放鎖，並在等待被喚醒後原子的獲取鎖</p><p>接下來，我們將圍繞lock和unlock這兩個方法，來介紹整個ReentrantLock是怎麼工作的。在介紹ReentrantLock之前，我們首先來看一下ReentrantLock的類層次結構以及和它密切相關的AbstractQueuedSynchronizer</p><p><strong>1.2、ReentrantLock類層次結構</strong></p><div class=pgc-img><img alt=牛人講解Java可重入鎖原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535262549376823724db60><p class=pgc-img-caption></p></div><p>ReentrantLock實現了Lock接口，內部有三個內部類，Sync、NonfairSync、FairSync，Sync是一個抽象類型，它繼承AbstractQueuedSynchronizer，這個AbstractQueuedSynchronizer是一個模板類，它實現了許多和鎖相關的功能，並提供了鉤子方法供用戶實現，比如tryAcquire，tryRelease等。Sync實現了AbstractQueuedSynchronizer的tryRelease方法。NonfairSync和FairSync兩個類繼承自Sync，實現了lock方法，然後分別公平搶佔和非公平搶佔針對tryAcquire有不同的實現。</p><p><strong>1.3、AbstractQueuedSynchronizer</strong></p><p>首先，AbstractQueuedSynchronizer繼承自AbstractOwnableSynchronizer，AbstractOwnableSynchronizer的實現很簡單，它表示獨佔的同步器，內部使用變量exclusiveOwnerThread表示獨佔的線程。</p><p>其次，AbstractQueuedSynchronizer內部使用CLH鎖隊列來將併發執行變成串行執行。整個隊列是一個雙向鏈表。每個CLH鎖隊列的節點，會保存前一個節點和後一個節點的引用，當前節點對應的線程，以及一個狀態。這個狀態用來表明該線程是否應該block。當節點的前一個節點被釋放的時候，當前節點就被喚醒，成為頭部。新加入的節點會放在隊列尾部。</p><p><strong>二、 非公平鎖的lock方法</strong></p><p><strong>2.1、lock方法流程圖</strong></p><div class=pgc-img><img alt=牛人講解Java可重入鎖原理 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/1535262549148d5cacea56e><p class=pgc-img-caption></p></div><p><strong>2.2、lock方法詳細描述</strong></p><p>1、在初始化ReentrantLock的時候，如果我們不傳參數是否公平，那麼默認使用非公平鎖，也就是NonfairSync。</p><p>2、當我們調用ReentrantLock的lock方法的時候，實際上是調用了NonfairSync的lock方法，這個方法先用CAS操作，去嘗試搶佔該鎖。如果成功，就把當前線程設置在這個鎖上，表示搶佔成功。如果失敗，則調用acquire模板方法，等待搶佔。代碼如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>static final <strong>class</strong> NonfairSync <strong>extends</strong> Sync {</p><p>final <strong>void</strong> lock() {</p><p><strong>if</strong> (compareAndSetState(0, 1))</p><p>setExclusiveOwnerThread(Thread.currentThread());</p><p><strong>else</strong></p><p>acquire(1);</p><p>}</p><p>protected final <strong>boolean</strong> tryAcquire(<strong>int</strong> acquires) {</p><p><strong>return</strong> nonfairTryAcquire(acquires);</p><p>}</p><p>}</p><p>3、調用acquire(1)實際上使用的是AbstractQueuedSynchronizer的acquire方法，它是一套鎖搶佔的模板，總體原理是先去嘗試獲取鎖，如果沒有獲取成功，就在CLH隊列中增加一個當前線程的節點，表示等待搶佔。然後進入CLH隊列的搶佔模式，進入的時候也會去執行一次獲取鎖的操作，如果還是獲取不到，就調用LockSupport.park將當前線程掛起。那麼當前線程什麼時候會被喚醒呢？當持有鎖的那個線程調用unlock的時候，會將CLH隊列的頭節點的下一個節點上的線程喚醒，調用的是LockSupport.unpark方法。acquire代碼比較簡單，具體如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>public final <strong>void</strong> acquire(<strong>int</strong> arg) {</p><p><strong>if</strong> (!tryAcquire(arg) &&</p><p>acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</p><p>selfInterrupt();</p><p>}</p><p>3.1、acquire方法內部先使用tryAcquire這個鉤子方法去嘗試再次獲取鎖，這個方法在NonfairSync這個類中其實就是使用了nonfairTryAcquire，具體實現原理是先比較當前鎖的狀態是否是0，如果是0，則嘗試去原子搶佔這個鎖（設置狀態為1，然後把當前線程設置成獨佔線程），如果當前鎖的狀態不是0，就去比較當前線程和佔用鎖的線程是不是一個線程，如果是，會去增加狀態變量的值，從這裡看出可重入鎖之所以可重入，就是同一個線程可以反覆使用它佔用的鎖。如果以上兩種情況都不通過，則返回失敗false。代碼如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>final <strong>boolean</strong> nonfairTryAcquire(<strong>int</strong> acquires) {</p><p>final Thread current = Thread.currentThread();</p><p><strong>int</strong> c = getState();</p><p><strong>if</strong> (c == 0) {</p><p><strong>if</strong> (compareAndSetState(0, acquires)) {</p><p>setExclusiveOwnerThread(current);</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p>}</p><p><strong>else</strong> <strong>if</strong> (current == getExclusiveOwnerThread()) {</p><p><strong>int</strong> nextc = c + acquires;</p><p><strong>if</strong> (nextc &lt; 0) // overflow</p><p><strong>throw</strong> <strong>new</strong> Error("Maximum lock count exceeded");</p><p>setState(nextc);</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>3.2、tryAcquire一旦返回false，就會則進入acquireQueued流程，也就是基於CLH隊列的搶佔模式：</p><p>3.2.1、首先，在CLH鎖隊列尾部增加一個等待節點，這個節點保存了當前線程，通過調用addWaiter實現，這裡需要考慮初始化的情況，在第一個等待節點進入的時候，需要初始化一個頭節點然後把當前節點加入到尾部，後續則直接在尾部加入節點就行了。</p><p>代碼如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>private Node addWaiter(Node mode) {</p><p>// 初始化一個節點，這個節點保存當前線程</p><p>Node node = <strong>new</strong> Node(Thread.currentThread(), mode);</p><p>// 當CLH隊列不為空的視乎，直接在隊列尾部插入一個節點</p><p>Node pred = tail;</p><p><strong>if</strong> (pred != <strong>null</strong>) {</p><p>node.prev = pred;</p><p><strong>if</strong> (compareAndSetTail(pred, node)) {</p><p>pred.next = node;</p><p><strong>return</strong> node;</p><p>}</p><p>}</p><p>// 當CLH隊列為空的時候，調用enq方法初始化隊列</p><p>enq(node);</p><p><strong>return</strong> node;</p><p>}</p><p>private Node enq(final Node node) {</p><p><strong>for</strong> (;;) {</p><p>Node t = tail;</p><p><strong>if</strong> (t == <strong>null</strong>) { // 初始化節點，頭尾都指向一個空節點</p><p><strong>if</strong> (compareAndSetHead(<strong>new</strong> Node()))</p><p>tail = head;</p><p>} <strong>else</strong> {// 考慮併發初始化</p><p>node.prev = t;</p><p><strong>if</strong> (compareAndSetTail(t, node)) {</p><p>t.next = node;</p><p><strong>return</strong> t;</p><p>}</p><p>}</p><p>}</p><p>}</p><p>3.2.2、將節點增加到CLH隊列後，進入acquireQueued方法。</p><p>首先，外層是一個無限for循環，如果當前節點是頭節點的下個節點，並且通過tryAcquire獲取到了鎖，說明頭節點已經釋放了鎖，當前線程是被頭節點那個線程喚醒的，這時候就可以將當前節點設置成頭節點，並且將failed標記設置成false，然後返回。至於上一個節點，它的next變量被設置為null，在下次GC的時候會清理掉。</p><p>如果本次循環沒有獲取到鎖，就進入線程掛起階段，也就是shouldParkAfterFailedAcquire這個方法。</p><p>代碼如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>final <strong>boolean</strong> acquireQueued(final Node node, <strong>int</strong> arg) {</p><p><strong>boolean</strong> failed = <strong>true</strong>;</p><p><strong>try</strong> {</p><p><strong>boolean</strong> interrupted = <strong>false</strong>;</p><p><strong>for</strong> (;;) {</p><p>final Node p = node.predecessor();</p><p><strong>if</strong> (p == head && tryAcquire(arg)) {</p><p>setHead(node);</p><p>p.next = <strong>null</strong>; // help GC</p><p>failed = <strong>false</strong>;</p><p><strong>return</strong> interrupted;</p><p>}</p><p><strong>if</strong> (shouldParkAfterFailedAcquire(p, node) &&</p><p>parkAndCheckInterrupt())</p><p>interrupted = <strong>true</strong>;</p><p>}</p><p>} <strong>finally</strong> {</p><p><strong>if</strong> (failed)</p><p>cancelAcquire(node);</p><p>}</p><p>}</p><p>3.2.3、如果嘗試獲取鎖失敗，就會進入shouldParkAfterFailedAcquire方法，會判斷當前線程是否掛起，如果前一個節點已經是SIGNAL狀態，則當前線程需要掛起。如果前一個節點是取消狀態，則需要將取消節點從隊列移除。如果前一個節點狀態是其他狀態，則嘗試設置成SIGNAL狀態，並返回不需要掛起，從而進行第二次搶佔。完成上面的事後進入掛起階段。</p><p>代碼如下：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>private static <strong>boolean</strong> shouldParkAfterFailedAcquire(Node pred, Node node) {</p><p><strong>int</strong> ws = pred.waitStatus;</p><p><strong>if</strong> (ws == Node.SIGNAL)</p><p>//</p><p><strong>return</strong> <strong>true</strong>;</p><p><strong>if</strong> (ws > 0) {</p><p>//</p><p><strong>do</strong> {</p><p>node.prev = pred = pred.prev;</p><p>} <strong>while</strong> (pred.waitStatus > 0);</p><p>pred.next = node;</p><p>} <strong>else</strong> {</p><p>//</p><p>compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>3.2.4、當進入掛起階段，會進入parkAndCheckInterrupt方法，則會調用LockSupport.park(this)將當前線程掛起。代碼：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>private final <strong>boolean</strong> parkAndCheckInterrupt() {</p><p>LockSupport.park(<strong>this</strong>);</p><p><strong>return</strong> Thread.interrupted();</p><p>}</p><p><strong>三、 非公平鎖的unlock方法</strong></p><p><strong>3.1、unlock方法的活動圖</strong></p><div class=pgc-img><img alt=牛人講解Java可重入鎖原理 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/1535262549396988e364ba9><p class=pgc-img-caption></p></div><p><strong>3.2、unlock方法詳細描述</strong></p><p>1、調用unlock方法，其實是直接調用AbstractQueuedSynchronizer的release操作。</p><p>2、進入release方法，內部先嚐試tryRelease操作,主要是去除鎖的獨佔線程，然後將狀態減一，這裡減一主要是考慮到可重入鎖可能自身會多次佔用鎖，只有當狀態變成0，才表示完全釋放了鎖。</p><p>3、一旦tryRelease成功，則將CHL隊列的頭節點的狀態設置為0，然後喚醒下一個非取消的節點線程。</p><p>4、一旦下一個節點的線程被喚醒，被喚醒的線程就會進入acquireQueued代碼流程中，去獲取鎖。</p><p>具體代碼如下：</p><p>unlock代碼：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>public <strong>void</strong> unlock() {</p><p>sync.release(1);</p><p>}</p><p>release方法代碼：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>public final <strong>boolean</strong> release(<strong>int</strong> arg) {</p><p><strong>if</strong> (tryRelease(arg)) {</p><p>Node h = head;</p><p><strong>if</strong> (h != <strong>null</strong> && h.waitStatus != 0)</p><p>unparkSuccessor(h);</p><p><strong>return</strong> <strong>true</strong>;</p><p>}</p><p><strong>return</strong> <strong>false</strong>;</p><p>}</p><p>Sync中通用的tryRelease方法代碼：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>protected final <strong>boolean</strong> tryRelease(<strong>int</strong> releases) {</p><p><strong>int</strong> c = getState() - releases;</p><p><strong>if</strong> (Thread.currentThread() != getExclusiveOwnerThread())</p><p><strong>throw</strong> <strong>new</strong> IllegalMonitorStateException();</p><p><strong>boolean</strong> free = <strong>false</strong>;</p><p><strong>if</strong> (c == 0) {</p><p>free = <strong>true</strong>;</p><p>setExclusiveOwnerThread(<strong>null</strong>);</p><p>}</p><p>setState(c);</p><p><strong>return</strong> free;</p><p>}</p><p>unparkSuccessor代碼：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>private <strong>void</strong> unparkSuccessor(Node node) {</p><p><strong>int</strong> ws = node.waitStatus;</p><p><strong>if</strong> (ws &lt; 0)</p><p>compareAndSetWaitStatus(node, ws, 0);</p><p>Node s = node.next;</p><p><strong>if</strong> (s == <strong>null</strong> || s.waitStatus > 0) {</p><p>s = <strong>null</strong>;</p><p><strong>for</strong> (Node t = tail; t != <strong>null</strong> && t != node; t = t.prev)</p><p><strong>if</strong> (t.waitStatus &lt;= 0)</p><p>s = t;</p><p>}</p><p><strong>if</strong> (s != <strong>null</strong>)</p><p>LockSupport.unpark(s.thread);</p><p>}</p><p><strong>四、 公平鎖和非公平鎖的區別</strong></p><p>公平鎖和非公平鎖，在CHL隊列搶佔模式上都是一致的，也就是在進入acquireQueued這個方法之後都一樣，它們的區別在初次搶佔上有區別，也就是tryAcquire上的區別，下面是兩者內部調用關係的簡圖：</p><p>Java</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>NonfairSync</p><p>lock —> compareAndSetState</p><p>| —> setExclusiveOwnerThread</p><p>—> accquire</p><p>| —> tryAcquire</p><p>|—>nonfairTryAcquire</p><p>|—> acquireQueued</p><p>FairSync</p><p>lock —> acquire</p><p>| —> tryAcquire</p><p>|—>!hasQueuePredecessors</p><p>|—>compareAndSetState</p><p>|—>setExclusiveOwnerThread</p><p>|—> acquireQueued</p><p>真正的區別就是公平鎖多了hasQueuePredecessors這個方法，這個方法用於判斷CHL隊列中是否有節點，對於公平鎖，如果CHL隊列有節點，則新進入競爭的線程一定要在CHL上排隊，而非公平鎖則是無視CHL隊列中的節點，直接進行競爭搶佔，這就有可能導致CHL隊列上的節點永遠獲取不到鎖，這就是非公平鎖之所以不公平的原因。</p><p><strong>五、 總結</strong></p><p>線程使用ReentrantLock獲取鎖分為兩個階段，第一個階段是初次競爭，第二個階段是基於CHL隊列的競爭。在初次競爭的時候是否考慮隊列節點直接區分出了公平鎖和非公平鎖。在基於CHL隊列的鎖競爭中，依靠CAS操作保證原子操作，依靠LockSupport來做線程的掛起和喚醒，使用隊列來保證併發執行變成了串行執行，從而消除了併發所帶來的問題。總體來說，ReentrantLock是一個比較輕量級的鎖，而且使用面向對象的思想去實現了鎖的功能，比原來的synchronized關鍵字更加好理解。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>講解</a></li><li><a>Java</a></li><li><a>可重</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/26711ae.html alt=9000字，通俗易懂的講解下Java註解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/392702e759b44da9994c126e8747d23c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/26711ae.html title=9000字，通俗易懂的講解下Java註解>9000字，通俗易懂的講解下Java註解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d8234770.html alt=關於齒輪常識由淺及深講解透徹，推薦收藏！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4e18dad6a34c44ed850916d34339092b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d8234770.html title=關於齒輪常識由淺及深講解透徹，推薦收藏！>關於齒輪常識由淺及深講解透徹，推薦收藏！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/189fa616.html alt=驅動橋設計講解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/eb89bb6bddcb4755b82277febac75960 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/189fa616.html title=驅動橋設計講解>驅動橋設計講解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html alt="Spring 核心知識講解，太簡單啦" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6cfd4e0e.html title="Spring 核心知識講解，太簡單啦">Spring 核心知識講解，太簡單啦</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2aa5a357.html alt=大白話講解php多態應用實例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2aa5a357.html title=大白話講解php多態應用實例>大白話講解php多態應用實例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>