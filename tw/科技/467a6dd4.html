<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>硬核！C語言八大排序算法，附動圖和詳細代碼解釋 | 极客快訊</title><meta property="og:title" content="硬核！C語言八大排序算法，附動圖和詳細代碼解釋 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/RopozPFCIOtLvm"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/467a6dd4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/467a6dd4.html><meta property="article:published_time" content="2020-11-14T20:59:47+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:47+08:00"><meta name=Keywords content><meta name=description content="硬核！C語言八大排序算法，附動圖和詳細代碼解釋"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/467a6dd4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>硬核！C語言八大排序算法，附動圖和詳細代碼解釋</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p></p><h1 toutiao-origin=h2>前言</h1><p>如果說各種編程語言是程序員的招式，那麼數據結構和算法就相當於程序員的內功。</p><p>想寫出精煉、優秀的代碼，不通過不斷的錘鍊，是很難做到的。</p><p></p><h1 toutiao-origin=h2>八大排序算法</h1><p>排序算法作為數據結構的重要部分，系統地學習一下是很有必要的。</p><p></p><h2 toutiao-origin=h3><strong>1、排序的概念</strong></h2><p>排序是計算機內經常進行的一種操作，其目的是將一組“無序”的記錄序列調整為“有序”的記錄序列。</p><p>排序分為內部排序和外部排序。</p><p>若整個排序過程不需要訪問外存便能完成，則稱此類排序問題為內部排序。</p><p>反之，若參加排序的記錄數量很大，整個序列的排序過程不可能在內存中完成，則稱此類排序問題為外部排序。</p><p></p><h2 toutiao-origin=h3><strong>2、排序分類</strong></h2><p>八大排序算法均屬於內部排序。如果按照策略來分類，大致可分為：交換排序、插入排序、選擇排序、歸併排序和基數排序。如下圖所示：</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RopozPFCIOtLvm><p></p><h2 toutiao-origin=h3><strong>3、算法分析</strong></h2>1.插入排序<p>*直接插入排序</p><p>*希爾排序</p><p>2.選擇排序</p><p>*簡單選擇排序</p><p>*堆排序</p><p>3.交換排序</p><p>*冒泡排序</p><p>*快速排序</p><p>4.歸併排序</p><p>5.基數排序</p><p>不穩定排序：簡單選擇排序，快速排序，希爾排序，堆排序</p><p>穩定排序：冒泡排序，直接插入排序，歸併排序，奇數排序</p><p>1、插入排序</p><p>將第一個和第二個元素排好序，然後將第3個元素插入到已經排好序的元素中，依次類推（插入排序最好的情況就是數組已經有序了）</p><p>2、希爾排序</p><p>因為插入排序每次只能操作一個元素，效率低。元素個數N，取奇數k=N/2，將下標差值為k的數分為一組（一組元素個數看總元素個數決定），在組內構成有序序列，再取k=k/2，將下標差值為k的數分為一組，構成有序序列，直到k=1，然後再進行直接插入排序。</p><p>3、簡單選擇排序</p><p>選出最小的數和第一個數交換，再在剩餘的數中又選擇最小的和第二個數交換，依次類推</p><p>4、堆排序</p><p>以升序排序為例，利用小根堆的性質（堆頂元素最小）不斷輸出最小元素，直到堆中沒有元素</p><p>1.構建小根堆</p><p>2.輸出堆頂元素</p><p>3.將堆低元素放一個到堆頂，再重新構造成小根堆，再輸出堆頂元素，以此類推</p><p>5、冒泡排序</p><p>改進1：如果某次冒泡不存在數據交換，則說明已經排序好了，可以直接退出排序</p><p>改進2：頭尾進行冒泡，每次把最大的沉底，最小的浮上去，兩邊往中間靠1</p><p>6、快速排序</p><p>選擇一個基準元素，比基準元素小的放基準元素的前面，比基準元素大的放基準元素的後面，這種動作叫分區，每次分區都把一個數列分成了兩部分，每次分區都使得一個數字有序，然後將基準元素前面部分和後面部分繼續分區，一直分區直到分區的區間中只有一個元素的時候，一個元素的序列肯定是有序的嘛，所以最後一個升序的序列就完成啦。</p><p>7、歸併排序</p><p>將一個無序的數列一直一分為二，直到分到序列中只有一個數的時候，這個序列肯定是有序的，因為只有一個數，然後將兩個只含有一個數字的序列合併為含有兩個數字的有序序列，這樣一直進行下去，最後就變成了一個大的有序數列</p><p>8、基數排序</p><p>找到最大的數，開個比最大的數大一點的數組，遍歷每個元素，某個元素為k，則a[k]++,最好遍歷數組a，a[k]等於多少就輸出多少個k。只能處理整型數</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RC6F82ZBQQOfLo><p></p><h1 toutiao-origin=h2>具體排序講解</h1><p>下面針對不同排序進行一一講解。</p><p><strong>一、直接插入排序（Insertion Sort)</strong></p><p>算法思想：</p><p>直接插入排序的核心思想就是：將數組中的所有元素依次跟前面已經排好的元素相比較，如果選擇的元素比已排序的元素小，則交換，直到全部元素都比較過 因此，從上面的描述中我們可以發現，直接插入排序可以用兩個循環完成：</p><p>第一層循環：遍歷待比較的所有數組元素</p><p>第二層循環：將本輪選擇的元素(selected)與已經排好序的元素(ordered)相比較。如果：selected > ordered，那麼將二者交換。</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RopozQ810jIRnw><p>算法代碼：</p><pre><code>void print(int a[], int n ,int i){</code><code> cout&lt;&lt;i &lt;&lt;":";</code><code> for(int j= 0; j&lt;8; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl;</code><code>} </code><code>void InsertSort(int a[], int n)</code><code>{</code><code> for(int i= 1; i&lt;n; i++){</code><code> if(a[i] &lt; a[i-1]){ //若第i個元素大於i-1元素，直接插入。小於的話，移動有序表後插入</code><code> int j= i-1; </code><code> int x = a[i]; //複製為哨兵，即存儲待排序元素</code><code> a[i] = a[i-1]; //先後移一個元素</code><code> while(x &lt; a[j]){ //查找在有序表的插入位置</code><code> a[j+1] = a[j];</code><code> j--; //元素後移</code><code> }</code><code> a[j+1] = x; //插入到正確位置</code><code> }</code><code> print(a,n,i); //打印每趟排序的結果</code><code> }</code><br><code>}</code><br><code>int main{</code><code> int a[8] = {3,1,5,7,2,4,9,6};</code><code> InsertSort(a,8);</code><code> print(a,8,8);</code><code>}</code></pre><p><strong>二、希爾排序（Shell' s Sort）</strong></p><p>算法思想:</p><p>希爾排序，也稱遞減增量排序算法，是插入排序的一種更高效的改進版本。但希爾排序是非穩定排序算法。</p><p>希爾排序的基本思想是：先將整個待排序的記錄序列分割成為若干子序列分別進行直接插入排序，待整個序列中的記錄“基本有序”時，再對全體記錄進行依次直接插入排序。</p><p>算法步驟：</p><p>1.選擇一個增量序列t1，t2，…，tk，其中ti>tj，tk=1；</p><p>2.按增量序列個數k，對序列進行k 趟排序；</p><p>3.每趟排序，根據對應的增量ti，將待排序列分割成若干長度為m 的子序列，分別對各子表進行直接插入排序。僅增量因子為1 時，整個序列作為一個表來處理，表長度即為整個序列的長度。</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RopozmECtXPa03><p>算法代碼:</p><pre><code>void print(int a[], int n ,int i){</code><code> cout&lt;&lt;i &lt;&lt;":";</code><code> for(int j= 0; j&lt;8; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl;</code><code>}</code><code>/**</code><code> * 直接插入排序的一般形式</code><code> *</code><code> * @param int dk 縮小增量，如果是直接插入排序，dk=1</code><code> *</code><code> */</code><br><code>void ShellInsertSort(int a[], int n, int dk)</code><code>{</code><code> for(int i= dk; i&lt;n; ++i){</code><code> if(a[i] &lt; a[i-dk]){ //若第i個元素大於i-1元素，直接插入。小於的話，移動有序表後插入</code><code> int j = i-dk; </code><code> int x = a[i]; //複製為哨兵，即存儲待排序元素</code><code> a[i] = a[i-dk]; //首先後移一個元素</code><code> while(x &lt; a[j]){ //查找在有序表的插入位置</code><code> a[j+dk] = a[j];</code><code> j -= dk; //元素後移</code><code> }</code><code> a[j+dk] = x; //插入到正確位置</code><code> }</code><code> print(a, n,i );</code><code> }</code><br><code>}</code><br><code> // 先按增量d（n/2,n為要排序數的個數進行希爾排序</code><code>void shellSort(int a[], int n){</code><br><code> int dk = n/2;</code><code> while( dk &gt;= 1 ){</code><code> ShellInsertSort(a, n, dk);</code><code> dk = dk/2;</code><code> }</code><code>}</code><code>int main{</code><code> int a[8] = {3,1,5,7,2,4,9,6};</code><code> //ShellInsertSort(a,8,1); //直接插入排序</code><code> shellSort(a,8); //希爾插入排序</code><code> print(a,8,8);</code><code>}</code></pre><p><strong>三、簡單選擇排序（Selection Sort）</strong></p><p>算法思想：</p><p>簡單選擇排序的實現思想：比較+交換</p><ol><li><p>從待排序序列中，找到關鍵字最小的元素；</p></li><li><p>如果最小元素不是待排序序列的第一個元素，將其和第一個元素互換；</p></li><li><p>從餘下的 N - 1 個元素中，找出關鍵字最小的元素，重複(1)、(2)步，直到排序結束。因此我們可以發現，簡單選擇排序也是通過兩層循環實現。第一層循環：依次遍歷序列當中的每一個元素 第二層循環：將遍歷得到的當前元素依次與餘下的元素進行比較，符合最小元素的條件，則交換。</p></li></ol><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RopozmmIxJJsJ0><p>算法代碼：</p><pre><code>void print(int a[], int n ,int i){</code><code> cout&lt;&lt;"第"&lt;&lt;i+1 &lt;&lt;"趟 : ";</code><code> for(int j= 0; j&lt;8; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl;</code><code>}</code><code>/**</code><code> * 數組的最小值</code><code> *</code><code> * @return int 數組的鍵值</code><code> */</code><code>int SelectMinKey(int a[], int n, int i)</code><code>{</code><code> int k = i;</code><code> for(int j=i+1 ;j&lt; n; ++j) {</code><code> if(a[k] &gt; a[j]) k = j;</code><code> }</code><code> return k;</code><code>}</code><br><code>/**</code><code> * 選擇排序</code><code> *</code><code> */</code><code>void selectSort(int a[], int n){</code><code> int key, tmp;</code><code> for(int i = 0; i&lt; n; ++i) {</code><code> key = SelectMinKey(a, n,i); //選擇最小的元素</code><code> if(key != i){</code><code> tmp = a[i]; a[i] = a[key]; a[key] = tmp; //最小元素與第i位置元素互換</code><code> }</code><code> print(a, n , i);</code><code> }</code><code>}</code><code>int main{</code><code> int a[8] = {3,1,5,7,2,4,9,6};</code><code> cout&lt;&lt;"初始值：";</code><code> for(int j= 0; j&lt;8; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl&lt;&lt;endl;</code><code> selectSort(a, 8);</code><code> print(a,8,8);</code><code>}</code></pre><p><strong>四、堆排序（Heap Sort）</strong></p><p>算法思想：</p><p>堆的概念</p><p>堆：本質是一種數組對象。特別重要的一點性質：任意的葉子節點小於（或大於）它所有的父節點。對此，又分為大頂堆和小頂堆：</p><p>大頂堆要求節點的元素都要大於其孩子。</p><p>小頂堆要求節點元素都小於其左右孩子。</p><p>兩者對左右孩子的大小關係不做任何要求。</p><p>利用堆排序，就是基於大頂堆或者小頂堆的一種排序方法。下面，我們通過大頂堆來實現。</p><p>基本思想：堆排序可以按照以下步驟來完成：</p><p>1.首先將序列構建稱為大頂堆；（這樣滿足了大頂堆那條性質：位於根節點的元素一定是當前序列的最大值）</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RopoznKEDnjHwc><p>2. 取出當前大頂堆的根節點，將其與序列末尾元素進行交換；（此時：序列末尾的元素為已排序的最大值；由於交換了元素，當前位於根節點的堆並不一定滿足大頂堆的性質）</p><p>3. 對交換後的n-1個序列元素進行調整，使其滿足大頂堆的性質；</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RopoznhJ5pSJy6><p>4. 重複2.3步驟，直至堆中只有1個元素為止</p><p>下面是基於大頂堆的堆排序算法代碼：</p><pre><code>void print(int a[], int n){</code><code> for(int j= 0; j&lt;n; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl;</code><code>}</code><code>/**</code><code> * 已知H[s…m]除了H[s] 外均滿足堆的定義</code><code> * 調整H[s],使其成為大頂堆.即將對第s個結點為根的子樹篩選, </code><code> *</code><code> * @param H是待調整的堆數組</code><code> * @param s是待調整的數組元素的位置</code><code> * @param length是數組的長度</code><code> */</code><code>void HeapAdjust(int H[],int s, int length)</code><code>{</code><code> int tmp = H[s];</code><code> int child = 2*s+1; //左孩子結點的位置。(i+1 為當前調整結點的右孩子結點的位置)</code><code> while (child &lt; length) {</code><code> if(child+1 &lt;length &amp;&amp; H[child]&lt;H[child+1]) { // 如果右孩子大於左孩子(找到比當前待調整結點大的孩子結點)</code><code> ++child ;</code><code> }</code><code> if(H[s]&lt;H[child]) { // 如果較大的子結點大於父結點</code><code> H[s] = H[child]; // 那麼把較大的子結點往上移動，替換它的父結點</code><code> s = child; // 重新設置s ,即待調整的下一個結點的位置</code><code> child = 2*s+1;</code><code> } else { // 如果當前待調整結點大於它的左右孩子，則不需要調整，直接退出</code><code> break;</code><code> }</code><code> H[s] = tmp; // 當前待調整的結點放到比其大的孩子結點位置上</code><code> }</code><code> print(H,length);</code><code>}</code><br><code>/**</code><code> * 初始堆進行調整</code><code> * 將H[0..length-1]建成堆</code><code> * 調整完之後第一個元素是序列的最小的元素</code><code> */</code><code>void BuildingHeap(int H[], int length)</code><code>{ </code><code> //最後一個有孩子的節點的位置 i= (length -1) / 2</code><code> for (int i = (length -1) / 2 ; i &gt;= 0; --i)</code><code> HeapAdjust(H,i,length);</code><code>}</code><code>/**</code><code> * 堆排序算法</code><code> */</code><code>void HeapSort(int H[],int length)</code><code>{</code><code> //初始堆</code><code> BuildingHeap(H, length);</code><code> //從最後一個元素開始對序列進行調整</code><code> for (int i = length - 1; i &gt; 0; --i)</code><code> {</code><code> //交換堆頂元素H[0]和堆中最後一個元素</code><code> int temp = H[i]; H[i] = H[0]; H[0] = temp;</code><code> //每次交換堆頂元素和堆中最後一個元素之後，都要對堆進行調整</code><code> HeapAdjust(H,0,i);</code><code> }</code><code>} </code><br><code>int main{</code><code> int H[10] = {3,1,5,7,2,4,9,6,10,8};</code><code> cout&lt;&lt;"初始值：";</code><code> print(H,10);</code><code> HeapSort(H,10);</code><code> //selectSort(a, 8);</code><code> cout&lt;&lt;"結果：";</code><code> print(H,10);</code><br><code>}</code></pre><p><strong>五、冒泡排序（Bubble Sort）</strong></p><p>算法思想：</p><p>冒泡遍歷所有的數據，每次對相鄰元素進行兩兩比較，如果順序和預先規定的順序不一致，則進行位置交換；這樣一次遍歷會將最大或最小的數據上浮到頂端，之後再重複同樣的操作，直到所有的數據有序。這個算法的名字由來是因為越大的元素會經由交換慢慢“浮”到數列的頂端。</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ropozo9G9caNFQ><p>算法代碼：</p><pre><br><br><br><br><br><code>void bubbleSort(int a[], int n){</code><code> for(int i =0 ; i&lt; n-1; ++i) {</code><code> for(int j = 0; j &lt; n-i-1; ++j) {</code><code> if(a[j] &gt; a[j+1])</code><code> {</code><code> int tmp = a[j] ; a[j] = a[j+1] ; a[j+1] = tmp;</code><code> }</code><code> }</code><code> }</code><code>}</code></pre><p><strong>六、快速排序（Quick Sort）</strong></p><p>算法思想：</p><p>快速排序是由東尼·霍爾所發展的一種排序算法。在平均狀況下，排序 n 個項目要Ο(n logn)次比較。在最壞狀況下則需要Ο(n2)次比較，但這種狀況並不常見。事實上，快速排序通常明顯比其他Ο(n log n) 算法更快，因為它的內部循環（inner loop）可以在大部分的架構上很有效率地被實現出來</p><p>快速排序使用分治法（Divide and conquer）策略來把一個串行（list）分為兩個子串行（sub-lists）。</p><p>算法步驟：</p><ol><li><p>從數列中挑出一個元素，稱為 “基準”（pivot）。</p></li><li><p>重新排序數列，所有元素比基準值小的擺放在基準前面，所有元素比基準值大的擺在基準的後面（相同的數可以到任一邊）。在這個分區退出之後，該基準就處於數列的中間位置。這個稱為分區（partition）操作。</p></li><li><p>遞歸地（recursive）把小於基準值元素的子數列和大於基準值元素的子數列排序。</p></li></ol><p>遞歸的最底部情形，是數列的大小是零或一，也就是永遠都已經被排序好了。雖然一直遞歸下去，但是這個算法總會退出，因為在每次的迭代（iteration）中，它至少會把一個元素擺到它最後的位置去。</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/Ropp0Ml7cL0EqS><p>算法代碼：</p><pre><code>void print(int a[], int n){</code><code> for(int j= 0; j&lt;n; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl;</code><code>}</code><br><code>void swap(int *a, int *b)</code><code>{</code><code> int tmp = *a;</code><code> *a = *b;</code><code> *b = tmp;</code><code>}</code><br><code>int partition(int a[], int low, int high)</code><code>{</code><code> int privotKey = a[low]; //基準元素</code><code> while(low &lt; high){ //從表的兩端交替地向中間掃描</code><code> while(low &lt; high &amp;&amp; a[high] &gt;= privotKey) --high; //從high 所指位置向前搜索，至多到low+1 位置。將比基準元素小的交換到低端</code><code> swap(&amp;a[low], &amp;a[high]);</code><code> while(low &lt; high &amp;&amp; a[low] &lt;= privotKey ) ++low;</code><code> swap(&amp;a[low], &amp;a[high]);</code><code> }</code><code> print(a,10);</code><code> return low;</code><code>}</code><br><br><code>void quickSort(int a[], int low, int high){</code><code> if(low &lt; high){</code><code> int privotLoc = partition(a, low, high); //將表一分為二</code><code> quickSort(a, low, privotLoc -1); //遞歸對低子表遞歸排序</code><code> quickSort(a, privotLoc + 1, high); //遞歸對高子表遞歸排序</code><code> }</code><code>}</code><br><code>int main{</code><code> int a[10] = {3,1,5,7,2,4,9,6,10,8};</code><code> cout&lt;&lt;"初始值：";</code><code> print(a,10);</code><code> quickSort(a,0,9);</code><code> cout&lt;&lt;"結果：";</code><code> print(a,10);</code><br><code>}</code></pre><p><strong>七、歸併排序（Merge Sort）</strong></p><p>算法思想：</p><p>歸併排序（Merge sort）是建立在歸併操作上的一種有效的排序算法。該算法是採用分治法（Divide and Conquer）的一個非常典型的應用。</p><p>算法步驟：</p><ol><li><p>申請空間，使其大小為兩個已經排序序列之和，該空間用來存放合併後的序列；</p></li><li><p>設定兩個指針，最初位置分別為兩個已經排序序列的起始位置；</p></li><li><p>比較兩個指針所指向的元素，選擇相對小的元素放入到合併空間，並移動指針到下一位置；</p></li><li><p>重複步驟3直到某一指針達到序列尾；</p></li><li><p>將另一序列剩下的所有元素直接複製到合併序列尾。</p></li></ol><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Ropp0NsA7b6hcg><p>算法代碼：</p><pre><br><code>void print(int a[], int n){</code><code> for(int j= 0; j&lt;n; j++){</code><code> cout&lt;&lt;a[j] &lt;&lt;" ";</code><code> }</code><code> cout&lt;&lt;endl;</code><code>}</code><br><code>//將r[i…m]和r[m +1 …n]歸併到輔助數組rf[i…n]</code><code>void Merge(ElemType *r,ElemType *rf, int i, int m, int n)</code><code>{</code><code> int j,k;</code><code> for(j=m+1,k=i; i&lt;=m &amp;&amp; j &lt;=n ; ++k){</code><code> if(r[j] &lt; r[i]) rf[k] = r[j++];</code><code> else rf[k] = r[i++];</code><code> }</code><code> while(i &lt;= m) rf[k++] = r[i++];</code><code> while(j &lt;= n) rf[k++] = r[j++];</code><code> print(rf,n+1);</code><code>}</code><br><code>void MergeSort(ElemType *r, ElemType *rf, int lenght)</code><code>{ </code><code> int len = 1;</code><code> ElemType *q = r ;</code><code> ElemType *tmp ;</code><code> while(len &lt; lenght) {</code><code> int s = len;</code><code> len = 2 * s ;</code><code> int i = 0;</code><code> while(i+ len &lt;lenght){</code><code> Merge(q, rf, i, i+ s-1, i+ len-1 ); //對等長的兩個子表合併</code><code> i = i+ len;</code><code> }</code><code> if(i + s &lt; lenght){</code><code> Merge(q, rf, i, i+ s -1, lenght -1); //對不等長的兩個子表合併</code><code> }</code><code> tmp = q; q = rf; rf = tmp; //交換q,rf，以保證下一趟歸併時，仍從q 歸併到rf</code><code> }</code><code>}</code><br><br><code>int main{</code><code> int a[10] = {3,1,5,7,2,4,9,6,10,8};</code><code> int b[10];</code><code> MergeSort(a, b, 10);</code><code> print(b,10);</code><code> cout&lt;&lt;"結果：";</code><code> print(a,10);</code><code>}</code><br></pre><p><strong>八、基數排序(Radix Sort)</strong></p><p>算法思想：</p><p>基數排序：通過序列中各個元素的值，對排序的N個元素進行若干趟的“分配”與“收集”來實現排序。</p><p>分配：我們將L[i]中的元素取出，首先確定其個位上的數字，根據該數字分配到與之序號相同的桶中 。</p><p>收集：當序列中所有的元素都分配到對應的桶中，再按照順序依次將桶中的元素收集形成新的一個待排序列L 。</p><p>對新形成的序列L重複執行分配和收集元素中的十位、百位...直到分配完該序列中的最高位，則排序結束。</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/Ropp0ONGGtcqd1><p>算法代碼：</p><pre><code>d RadixSort(Node L[],length,maxradix)</code><code>{</code><code> int m,n,k,lsp;</code><code> k=1;m=1;</code><code> int temp[10][length-1];</code><code> Empty(temp); //清空臨時空間</code><code> while(k&lt;maxradix) //遍歷所有關鍵字</code><code> {</code><code> for(int i=0;i&lt;length;i++) //分配過程</code><code> {</code><code> if(L[i]&lt;m)</code><code> Temp[0][n]=L[i];</code><code> else</code><code> Lsp=(L[i]/m)%10; //確定關鍵字</code><code> Temp[lsp][n]=L[i];</code><code> n++;</code><code> }</code><code> CollectElement(L,Temp); //收集</code><code> n=0;</code><code> m=m*10;</code><code> k++;</code><code> }</code><code>}</code></pre><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/RTy4oyA1ozZTxK><p></p><h1 toutiao-origin=h2>使用Python實現</h1><p><strong>一、冒泡排序</strong></p><p>冒泡排序算法的運作如下：</p><p>● 比較相鄰的元素。如果第一個比第二個大，就交換他們兩個。</p><p>● 對每一對相鄰元素作同樣的工作，從開始第一對到結尾的最後一對。這步做完後，最後的元素會是最大的數。</p><p>● 針對所有的元素重複以上的步驟，除了最後一個。</p><p>● 持續每次對越來越少的元素重複上面的步驟，直到沒有任何一對數字需要比較。</p><p>以上節選自維基百科</p><p>代碼實現：</p><pre><code>def bubble_sort(numberlist):</code><code> length = len(numberlist)</code><code> for i in range(length):</code><code> for j in range(1, length - i):</code><code> if numberlist[j - 1] &gt; numberlist[j]:</code><code> numberlist[j], numberlist[j - 1] = numberlist[j - 1], numberlist[j]</code><code> return numberlist</code></pre><p><strong>二、選擇排序</strong></p><p>選擇排序（Selection sort）是一種簡單直觀的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然後，再從剩餘未排序元素中繼續尋找最小（大）元素，然後放到已排序序列的末尾。以此類推，直到所有元素均排序完畢。</p><p>以上節選自維基百科</p><p>代碼實現：</p><pre><code>def findSmallest(arr): # 用於查找出數組中最小的元素，返回最小元素的索引。</code><code> smallest = arr[0]</code><code> smallest_index = 0</code><code> for i in range(1, len(arr)):</code><code> if smallest &gt; arr[i]:</code><code> smallest = arr[i]</code><code> smallest_index = i</code><code> return smallest_index</code><br><code>def selectSort(arr):</code><code> newArr = </code><code> while arr:</code><code> smallest = findSmallest(arr)</code><code> newArr.append(arr.pop(smallest))</code><code> return newArr</code></pre><p><strong>三、插入排序</strong></p><p>步驟如下:</p><p>● 從第一個元素開始，該元素可以認為已經被排序</p><p>● 取出下一個元素，在已經排序的元素序列中從後向前掃描</p><p>● 如果該元素（已排序）大於新元素，將該元素移到下一位置</p><p>● 重複步驟3，直到找到已排序的元素小於或者等於新元素的位置</p><p>● 將新元素插入到該位置後</p><p>重複步驟2~5</p><p>以上節選自維基百科</p><p>代碼實現:</p><pre><pre><br><br><br><br><br><br><code>def insert_sort(data):</code><code> for k in range(1, len(data)):</code><code> cur = data[k]</code><code> j = k</code><code> while j &gt; 0 and data[j - 1] &gt; cur:</code><code> data[j] = data[j - 1]</code><code> j -= 1</code><code> data[j] = cur</code><code> return data</code></pre><br></pre><p><strong>四、希爾排序</strong></p><p>希爾排序通過將比較的全部元素分為幾個區域來提升插入排序的性能。這樣可以讓一個元素可以一次性地朝最終位置前進一大步。然後算法再取越來越小的步長進行排序，算法的最後一步就是普通的插入排序，但是到了這步，需排序的數據幾乎是已排好的了（此時插入排序較快）。</p><p>以上節選自維基百科</p><p>代碼實現：</p><pre><code>def shell_sort(numberlist):</code><code> length = len(numberlist)</code><code> gap = length // 2</code><code> while gap &gt; 0:</code><code> for i in range(gap, length):</code><code> temp = numberlist[i]</code><code> j = i</code><code> while j &gt;= gap and numberlist[j - gap] &gt; temp:</code><code> numberlist[j] = numberlist[j - gap]</code><code> j -= gap</code><code> numberlist[j] = temp</code><code> gap = gap // 2</code><code> return numberlist</code></pre><p><strong>五、歸併排序</strong></p><p>原理如下（假設序列共有{displaystyle n}個元素）：</p><p>● 將序列每相鄰兩個數字進行歸併操作，形成{displaystyle ceil(n/2)}個序列，排序後每個序列包含兩/一個元素</p><p>● 若此時序列數不是1個則將上述序列再次歸併，形成{displaystyle ceil(n/4)}個序列，每個序列包含四/三個元素</p><p>● 重複步驟2，直到所有元素排序完畢，即序列數為1</p><p>以上節選自維基百科</p><p>代碼如下：</p><pre><code>def merge(left, right):</code><code> result = </code><code> while left and right:</code><code> if left[0] &lt; right[0]:</code><code> result.append(left.pop(0))</code><code> else:</code><code> result.append(right.pop(0))</code><code> if left:</code><code> result += left</code><code> if right:</code><code> result += right</code><code> return result</code><br><br><code>def merge_sort(numberlist):</code><code> if len(numberlist) &lt;= 1:</code><code> return numberlist</code><code> mid = len(numberlist) // 2</code><code> left = numberlist[:mid]</code><code> right = numberlist[mid:]</code><br><code> left = merge_sort(left)</code><code> right = merge_sort(right)</code><code> return merge(left, right)</code></pre><p><strong>六、快速排序</strong>從數列中挑出一個元素，稱為“基準”（pivot），</p><p>● 重新排序數列，所有比基準值小的元素擺放在基準前面，所有比基準值大的元素擺在基準後面（相同的數可以到任何一邊）。在這個分割結束之後，該基準就處於數列的中間位置。這個稱為分割（partition）操作。</p><p>● 遞歸地（recursively）把小於基準值元素的子數列和大於基準值元素的子數列排序。</p><p>● 遞歸到最底部時，數列的大小是零或一，也就是已經排序好了。這個算法一定會結束，因為在每次的迭代（iteration）中，它至少會把一個元素擺到它最後的位置去。</p><p>以上節選自維基百科</p><p>代碼如下：</p><pre><code>def quick_sort(array):</code><code> if len(array) &lt; 2:</code><code> return array</code><code> else:</code><code> pivot = array[0]</code><code> less = [i for i in array[1:] if i &lt;= pivot]</code><code> greater = [i for i in array[1:] if i &gt; pivot]</code><code> return quick_sort(less) + [pivot] + quick_sort(greater)</code></pre><p><strong>七、堆排序</strong></p><p>若以升序排序說明，把數組轉換成最大堆積(Max-Heap Heap)，這是一種滿足最大堆積性質(Max-Heap Property)的二叉樹：對於除了根之外的每個節點i, A[parent(i)] ≥ A[i]。</p><p>重複從最大堆積取出數值最大的結點(把根結點和最後一個結點交換，把交換後的最後一個結點移出堆)，並讓殘餘的堆積維持最大堆積性質。</p><pre><pre><br><br><code>def heap_sort(numberlist):</code><code> length = len(numberlist)</code><code> def sift_down(start, end):</code><code> root = start</code><code> while True:</code><code> child = 2 * root + 1</code><code> if child &gt; end:</code><code> break</code><code> if child + 1 &lt;= end and numberlist[child] &lt; numberlist[child + 1]:</code><code> child += 1</code><code> if numberlist[root] &lt; numberlist[child]:</code><code> numberlist[root], numberlist[child] = numberlist[child], numberlist[root]</code><code> root = child</code><code> else:</code><code> break</code><br><code># 創建最大堆</code><code> for start in range((length - 2) // 2, -1, -1):</code><code> sift_down(start, length - 1)</code><br><code># 堆排序</code><code> for end in range(length - 1, 0, -1):</code><code> numberlist[0], numberlist[end] = numberlist[end], numberlist[0]</code><code> sift_down(0, end - 1)</code><br><code> return numberlist</code></pre><br></pre><p><strong>八、計數排序</strong>以上節選自維基百科</p><p>代碼如下：</p><pre><pre><br><br><code>def counting_sort(numberlist, maxnumber): # maxnumber為數組中的最大值</code><code> length = len(numberlist) # 待排序數組長度</code><code> b = [0 for i in range(length)] # 設置輸出序列，初始化為0</code><code> c = [0 for i in range(maxnumber+ 1)] # 設置技術序列，初始化為0</code><code> for j in numberlist:</code><code> c[j] = c[j] + 1</code><code> for i in range(1, len(c)):</code><code> c[i] = c[i] + c[i - 1]</code><code> for j in numberlist:</code><code> b[c[j] - 1] = j</code><code> c[j] = c[j] - 1</code><code> return b</code></pre><br></pre><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/RTy4oyNDan8UIe><p><strong>總結</strong></p><p>各種排序的穩定性，時間複雜度和空間複雜度總結：</p><p>我們比較時間複雜度函數的情況：</p><img alt=硬核！C語言八大排序算法，附動圖和詳細代碼解釋 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/Ropp0OzBCzrept><p>時間複雜度函數O(n)的增長情況</p><p>所以對n較大的排序記錄。一般的選擇都是時間複雜度為O(nlog2n)的排序方法。</p><p>時間複雜度來說：</p><p>(1)平方階(O(n2))排序</p><p>各類簡單排序:直接插入、直接選擇和冒泡排序；</p><p>(2)線性對數階(O(nlog2n))排序</p><p>快速排序、堆排序和歸併排序；</p><p>(3)O(n1+§))排序,§是介於0和1之間的常數。</p><p>希爾排序</p><p>(4)線性階(O(n))排序</p><p>基數排序，此外還有桶、箱排序。<strong>說明：</strong></p><p>當原表有序或基本有序時，直接插入排序和冒泡排序將大大減少比較次數和移動記錄的次數，時間複雜度可降至O（n）；</p><p>而快速排序則相反，當原表基本有序時，將蛻化為冒泡排序，時間複雜度提高為O（n2）；</p><p>原表是否有序，對簡單選擇排序、堆排序、歸併排序和基數排序的時間複雜度影響不大。</p><p>穩定性：</p><p>排序算法的穩定性:若待排序的序列中，存在多個具有相同關鍵字的記錄，經過排序， 這些記錄的相對次序保持不變，則稱該算法是穩定的；若經排序後，記錄的相對 次序發生了改變，則稱該算法是不穩定的。</p><p>穩定性的好處：排序算法如果是穩定的，那麼從一個鍵上排序，然後再從另一個鍵上排序，第一個鍵排序的結果可以為第二個鍵排序所用。基數排序就是這樣，先按低位排序，逐次按高位排序，低位相同的元素其順序再高位也相同時是不會改變的。另外，如果排序算法穩定，可以避免多餘的比較；</p><p>穩定的排序算法：冒泡排序、插入排序、歸併排序和基數排序</p><p>不是穩定的排序算法：選擇排序、快速排序、希爾排序、堆排序</p><p>選擇排序算法準則：</p><p>每種排序算法都各有優缺點。因此，在實用時需根據不同情況適當選用，甚至可以將多種方法結合起來使用。</p><p>選擇排序算法的依據</p><p>影響排序的因素有很多，平均時間複雜度低的算法並不一定就是最優的。相反，有時平均時間複雜度高的算法可能更適合某些特殊情況。同時，選擇算法時還得考慮它的可讀性，以利於軟件的維護。一般而言，需要考慮的因素有以下四點：</p><p>1．待排序的記錄數目n的大小；</p><p>2．記錄本身數據量的大小，也就是記錄中除關鍵字外的其他信息量的大小；</p><p>3．關鍵字的結構及其分佈情況；</p><p>4．對排序穩定性的要求。</p><p>設待排序元素的個數為n.</p><p>1）當n較大，則應採用時間複雜度為O(nlog2n)的排序方法：快速排序、堆排序或歸併排序序。</p><p>快速排序：是目前基於比較的內部排序中被認為是最好的方法，當待排序的關鍵字是隨機分佈時，快速排序的平均時間最短；</p><p>堆排序 ： 如果內存空間允許且要求穩定性的，</p><p>歸併排序：它有一定數量的數據移動，所以我們可能過與插入排序組合，先獲得一定長度的序列，然後再合併，在效率上將有所提高。</p><p>2） 當n較大，內存空間允許，且要求穩定性 =》歸併排序</p><p>3）當n較小，可採用直接插入或直接選擇排序。</p><p>直接插入排序：當元素分佈有序，直接插入排序將大大減少比較次數和移動記錄的次數。</p><p>直接選擇排序 ：元素分佈有序，如果不要求穩定性，選擇直接選擇排序</p><p>4）一般不使用或不直接使用傳統的冒泡排序。</p><p>5）基數排序</p><p>它是一種穩定的排序算法，但有一定的侷限性：</p><p>1、關鍵字可分解。</p><p>2、記錄的關鍵字位數較少，如果密集更好</p><p>3、如果是數字時，最好是無符號的，否則將增加相應的映射複雜度，可先將其正負分開排序。</p><p><strong>總結</strong></p><p>以上所述是小編給大家介紹的必須知道的C語言 八大排序算法，希望對大家有所幫助，如果大家有任何疑問請給我留言，小編會及時回覆大家的。在此也非常感謝大家對腳本之家網站的支持！</p><p>☞2019女性開發者報告：3成16歲就會編程、JS/Python成女性掌握最多語言</p><p>☞為了讓自己快樂，我在36歲辭職了</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>硬核</a></li><li><a>語言</a></li><li><a>附動圖</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/bcc63183.html alt=「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ac7fb5fb22b8449392a90146180d194f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bcc63183.html title=「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪>「超硬核科普」鼠標的發展歷史，中國人發明的鼠標滾輪</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html alt=什麼是梯度：用形象的語言解讀梯度的本質原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/557c7b377c5449bb885df35b2d354e03 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/65d2605f.html title=什麼是梯度：用形象的語言解讀梯度的本質原理>什麼是梯度：用形象的語言解讀梯度的本質原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html alt=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S5YRqTH6awaqmG style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4b2ac18d.html title=我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行>我國首部較少民族語言工具書《鄂倫春語常用語發音詞典》出版發行</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html alt=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/10c7d8fd.html title=神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列>神州泰嶽：公司在自然語言處理領域的基礎技術研究和應用落地均走在行業前列</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html alt=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/46ea0001172cab9535dc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f4c5c93c.html title=谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用>谷歌推出自然語言框架語義解析器SLING，但沒說有沒有用</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html alt=C語言經典100例004-統計各個年齡階段的人數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/98c4bb54-8d7e-4234-bf07-0d8190ba1a0c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c96865e4.html title=C語言經典100例004-統計各個年齡階段的人數>C語言經典100例004-統計各個年齡階段的人數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html alt=CC++語言16｜通過繼承、虛函數、指針來實現動態多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/00674040.html title=CC++語言16｜通過繼承、虛函數、指針來實現動態多態>CC++語言16｜通過繼承、虛函數、指針來實現動態多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6c476abf.html alt="硬核航空 FAG公司用於航宇軸承的壽命計算方法" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/034ea8ed652c4ccfb55292e01084573f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6c476abf.html title="硬核航空 FAG公司用於航宇軸承的壽命計算方法">硬核航空 FAG公司用於航宇軸承的壽命計算方法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html alt=CC++語言19｜靜態成員（對象共享數據成員及其成員函數） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7267cf45.html title=CC++語言19｜靜態成員（對象共享數據成員及其成員函數）>CC++語言19｜靜態成員（對象共享數據成員及其成員函數）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bc78327d.html alt=零基礎學C語言——運算符 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/fa8bd8c0-66cc-4cf5-a447-dbe6409abebb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bc78327d.html title=零基礎學C語言——運算符>零基礎學C語言——運算符</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a7be4199.html alt=硬核：激光結構光的原理、設計和類型詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RvXexXME6SXKyZ style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a7be4199.html title=硬核：激光結構光的原理、設計和類型詳解>硬核：激光結構光的原理、設計和類型詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3127ea3b.html alt=大廠硬核乾貨！深入分析彈性動效的應用及原理 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9d3fcf924c8e43bf92b4e6820af0176c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3127ea3b.html title=大廠硬核乾貨！深入分析彈性動效的應用及原理>大廠硬核乾貨！深入分析彈性動效的應用及原理</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html alt="Java入門 - 語言基礎 - 18.正則表達式" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ddf3412c71244bcaa3cb911e988fed3b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/52a05f19.html title="Java入門 - 語言基礎 - 18.正則表達式">Java入門 - 語言基礎 - 18.正則表達式</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e572fcc.html alt="Win10專題 | 十分硬核的Windows 10精簡教程（用戶文件篇）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/24d10164-2cf8-4f4e-a53d-18a1e5b1f85d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e572fcc.html title="Win10專題 | 十分硬核的Windows 10精簡教程（用戶文件篇）">Win10專題 | 十分硬核的Windows 10精簡教程（用戶文件篇）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ad41459b.html alt=一座“硬核”煤化工智能工廠 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/9c682fde45fa46a696a2cd4819b73900 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ad41459b.html title=一座“硬核”煤化工智能工廠>一座“硬核”煤化工智能工廠</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>