<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>你真的懂 Java 的內存管理和引用類型嗎？ | 极客快訊</title><meta property="og:title" content="你真的懂 Java 的內存管理和引用類型嗎？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/5b5c00020eae480adb96"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/470675c9.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/470675c9.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/470675c9.html><meta property="article:published_time" content="2020-11-14T20:59:56+08:00"><meta property="article:modified_time" content="2020-11-14T20:59:56+08:00"><meta name=Keywords content><meta name=description content="你真的懂 Java 的內存管理和引用類型嗎？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/470675c9.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>你真的懂 Java 的內存管理和引用類型嗎？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>對於 Java 程序員來說，在 Java 虛擬機自動內存管理機制的幫助下，不再需要為每一個 new 操作去寫對應的 delete/free 代碼，不容易出現內存洩露和內存溢出的問題。不過，也正是因為 Java 程序員把內存控制的權力交給了 Java 虛擬機，一旦出現內存洩露和內存溢出的問題，如果不瞭解虛擬機是怎樣使用內存的，那麼排查錯誤將會非常艱難。</p><p>本文將會對 Java 的內存管理以及四種引用類型，做一個總結。</p><h1><strong>一、Java 內存管理</strong></h1><p>Java 內存管理就是對象的分配和釋放問題。在 Java 中，內存的分配是由「程序」完成的，而內存的釋放是由 Java 垃圾回收器（GC）完成的，這種方式確實簡化了程序員的工作，但也同時加重了 JVM 的工作。這也是 Java 程序運行速度較慢的原因之一。</p><p>為了能夠正確釋放對象，GC 必須監控每一個對象的運行狀態，包括對象的申請、引用、被引用、賦值等，監控對象狀態是為了更加準確地、及時地釋放對象，而釋放對象的根本原則就是該對象不再被引用。</p><p><strong>1、Java 內存分配策略</strong></p><p>Java 程序運行時的內存分配策略有三種，分別是靜態分配、棧式分配和堆式分配，三種方式所使用的內存空間分別是靜態存儲區（方法區）、棧區和堆區。</p><p><strong>靜態存儲區（方法區）：</strong>主要存放靜態變量。這塊「內存」在程序編譯時就已經分配好了，並且在程序整個運行期間都存在。</p><p><strong>棧區：</strong>當方法被執行時，方法體內的局部變量（包括基礎數據類型、對象的引用）都在棧上創建，並在方法執行結束時。這些局部變量所持有的內存將會自動被釋放。因為棧內存分配運算內置於處理器的指令集中，效率很高，但是分配的內存容量有限。</p><p><strong>堆區：</strong>又稱動態內存分配，通常就是指程序運行時直接 new 出來的內存，也就是對象的實例，這部分「內存」在不使用時將會被 Java 垃圾回收器來負責回收。</p><p><strong>下面通過一個例子，來詳細說明一下：</strong></p><p>public class Sample {</p><p>int s1 = 0;</p><p>Sample mSample1 = new Sample();</p><p>public void method() {</p><p>int s2 = 1;</p><p>Sample mSample2 = new Sample();</p><p>}</p><p>}</p><p>Sample mSample3 = new Sample();</p><p>Sample 類的局部變量 s2 和引用變量 mSample2 都是存在於棧中，但 mSample2 指向的對象是存在於堆上的。mSample3 指向的對象實體存放於堆上，包括這個對象的所有成員變量 s1 和 mSample1，但它的引用變量是存在於棧中的。</p><h1><strong>結論：</strong></h1><p>局部變量的基本數據類型和引用存儲於棧中，引用的對象實體存儲在堆中 —— 因為他們屬於方法中的變量，生命週期隨方法而結束</p><p>成員變量全部存儲於堆中（包括基本數據類型，引用和引用的對象實體）—— 因為它們屬於類，類對象終究是要被 new 出來使用的</p><p><img alt="你真的懂 Java 的內存管理和引用類型嗎？" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/5b5c00020eae480adb96></p><h1><strong>2、Java 垃圾回收器</strong></h1><p>在 Java 堆和靜態存儲區（方法區）中，一個接口中的多個實現類需要的內存可能不一樣，一個方法中的多個分支需要的內存也可能不一樣，我們只有在程序處於運行期間時才能知道會創建哪些對象，這部分內存的分配和回收都是動態的，垃圾回收器所關注的便是這部分的內存。</p><p><strong>2.1 判斷對象是否存活的方法</strong></p><p>在堆裡面存放著 Java 世界中幾乎所有的對象實例，垃圾收集器在對堆進行回收前，第一件事就是要確定這些對象之中哪些還「存活」著，哪些已經「死去」。</p><p><strong>引用計數算法</strong></p><p>給對象添加一個引用計數器，每當有一個地方引用它時，計數器就加 1，當引用失效</p><p>時，就減 1。任何時刻計數器為 0 的對象就是不可能再被使用的。</p><p>引用計數算法的實現比較簡單，判定效率也很高，在大部分情況下它都是一個不錯的算法。但是，至少主流的 Java 虛擬機裡面沒有選用引用計數算法來管理內存，其中最主要的原因是它很難解決對象之間相互循環引用的問題。</p><p><strong>可達性分析算法</strong></p><p>在主流的商用程序語言（Java、C#）的主流實現中，都是稱通過可達性分析來判定對象是否存活的。這個算法的基本思想就是通過一系列的稱為「GC Roots」的對象作為起始點，從這些節點開始向下搜索，搜索所走過的路徑稱為引用鏈，當一個對象到 GC Roots 沒有任何引用鏈相連時，則證明此對象是不可用的。</p><p><strong>在 Java 語言中，可作為 GC Roots 的對象包括下面幾種：</strong></p><p>虛擬機棧（棧幀中的本地變量表）中引用的對象</p><p>方法區中類靜態屬性引用的對象</p><p>方法區中常量引用的對象</p><p>本地方法棧中 JNI（即一般說的 Native 方法）引用的對象</p><h1><strong>2.2 垃圾收集算法</strong></h1><p><strong>標記 — 清除算法</strong></p><p>最基礎的收集算法就是「標記 — 清除」（Mark - Sweep）算法，如同它的名字一樣，算法分為「標記」和「清除」兩個階段：</p><p>標記出所有需要回收的對象</p><p>在標記完成後統一回收所有被標記的對象</p><p>之所以說它是最基礎的收集算法，是因為後續的收集算法都是基於這種思路並對其不足進行改進而得到的。它的主要不足主要有兩個：</p><p>效率問題，標記和清除兩個過程的效率都不高</p><p>空間問題，標記清除之後會產生大量不連續的內存碎片</p><p>內存碎片太多，可能會導致以後在程序運行過程中需要分配較大對象時，無法找到足夠的連續內存而不得不提前觸發另一次垃圾收集動作。</p><p><strong>複製算法</strong></p><p>為了解決效率問題，一種稱為「複製」的收集算法出現了，它將可用內存按容量劃分為大小相等的兩塊，每次只使用其中的一塊。當這一塊的內存用完了，就將還存活著的對象複製到另外一塊上面，然後再把已使用過的內存空間一次清理掉。</p><p>這樣使得每次都是對整個半區進行內存回收，內存分配時也就不用考慮內存碎片等複雜情況，只要移動堆頂指針，按順序分配內存即可，實現簡單，運行高效。只是這種算法的代價是將內存縮小為原來的一半。</p><p><strong>標記 — 整理算法</strong></p><p>複製算法在對象存活率較高時就要進行較多的複製操作，效率將會變低。更關鍵的是，如果不想浪費 50 % 的空間，就需要有額外的空間進行擔保，以應對被使用的內存中所有對象都 100% 存活的極端情況，所以在老年代一般不能直接選用這種算法。</p><p>根據老年代的特點，提出了另一種「標記 — 整理」算法，標記過程仍然與「標記 — 清理」算法一樣，但後續步驟不是直接對可回收對象進行清理，而是讓所有存活的對象都向一端移動，然後直接清理掉邊界以外的內存。</p><p><strong>分代收集算法</strong></p><p>當前商業虛擬機的垃圾收集都採用「分代收集」算法，這種算法並沒有什麼新的思想，只是根據對象存活週期的不同將內存劃分為幾塊，一般是把 Java 堆分為新生代和老年代，這樣就可以根據各個年代的特點採用最適當的收集算法。</p><p>在新生代中，每次垃圾收集都發現有大批對象死去，只有少量存活，那就選用複製算法，只需要付出少量存活對象的複製成本就可以完成收集，而老年代中因為對象存活率高、沒有額外空間對它進行擔保，就必須採用「標記 — 清理」或者「標記 — 整理」算法來回收。</p><h1><strong>二、Java 的引用類型</strong></h1><p>在 JDK 1.2 以前，Java 中引用的定義很傳統：如果 reference 類型的數據中存儲的數值代表的是另外一塊內存的起始地址，就稱這塊內存代表著一個引用。一個對象在這種定義下只有被引用或沒有被引用兩種狀態，對於描述一些「食之無味，棄之可惜」的對象就顯得無能為力了。</p><p>我們希望能描述這樣一類對象：當內存空間還足夠時，則能保留在內存之中，如果內存空間在進行垃圾回收後還是非常緊張，則可以拋棄這些對象，很多系統的緩存功能都符合這樣的應用場景。</p><p>在 JDK 1.2 之後，Java 對引用的概念進行了擴充，將引用分為強引用（Strong Reference）、軟引用（Soft Reference）、弱引用（Weak Reference）、虛引用（Phantom Reference）4 中，這四種引用強度一次逐漸減弱</p><p><strong>強引用：</strong>指在程序代碼之中普遍存在的，類似 Object obj = new Object() 這類的引用，只要強引用還存在，垃圾回收器「永遠」不會回收掉被引用的對象</p><p><strong>軟引用：</strong>用來描述一些還有用但並非必需的對象。對於軟引用關聯著的對象，在系統將要發生內存溢出異常之前，將會把這些對象列進回收範圍之中進行第二次回收。如果這次回收還沒有足夠的內存，才會拋出內存溢出異常</p><p><strong>弱引用：</strong>用來描述非必須對象的，但是它的強度比軟引用更弱一些，被弱引用關聯的對象只能生存到下一次垃圾收集之前。當垃圾收集器工作時，無論當前內存是否足夠，都會回收掉只被弱引用關聯的對象</p><p><strong>虛引用：</strong>也被稱為幽靈引用或幻影引用，它是最弱的一種引用關係。一個對象是否有虛引用的存在，完全不會對其生存時間構成影響，也無法通過虛引用來取得一個對象實例。為一個對象設置虛引用關聯的 唯一目的就是能在這個對象被收集器回收時收到一個系統通知。</p><h1><strong>最後，用一張圖總結下它們之間的區別：</strong></h1><p><img alt="你真的懂 Java 的內存管理和引用類型嗎？" onerror=errorimg.call(this); src=https://p9.pstatp.com/large/5b5c00020a993cf15d40></p><p><strong>最後：如果有發現文章內容哪裡寫錯的，歡迎指正、建議。想要了解更多的Java知識的，歡迎關注本頭條號，謝謝。</strong></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>Java</a></li><li><a>內存</a></li><li><a>類型</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/5123a81a.html alt=Java教程-Java整數類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad37c854582744f299c5eeb66b9964cd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5123a81a.html title=Java教程-Java整數類型>Java教程-Java整數類型</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8cd5c40.html alt=Java裡的靜態成員變量是放在了堆內存還是棧內存 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/bf8b9a197d4648968742b4920adcf4f5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8cd5c40.html title=Java裡的靜態成員變量是放在了堆內存還是棧內存>Java裡的靜態成員變量是放在了堆內存還是棧內存</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2b093d18.html alt=光纖跳線類型、尾纖類型一目瞭然，其實你也可以很專業 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/5e730002f30f156d752c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2b093d18.html title=光纖跳線類型、尾纖類型一目瞭然，其實你也可以很專業>光纖跳線類型、尾纖類型一目瞭然，其實你也可以很專業</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5513d652.html alt=HTML元素類型如何分類？如何相互轉化？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5513d652.html title=HTML元素類型如何分類？如何相互轉化？>HTML元素類型如何分類？如何相互轉化？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html alt=深入淺出：Java事務原理和應用兼JDBC事務詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/3c5e0002a8059c1311aa style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/48ba24d7.html title=深入淺出：Java事務原理和應用兼JDBC事務詳解>深入淺出：Java事務原理和應用兼JDBC事務詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html alt=從JVM層面帶你分析Java的Object類源碼第一部分 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/816b04b7.html title=從JVM層面帶你分析Java的Object類源碼第一部分>從JVM層面帶你分析Java的Object類源碼第一部分</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html alt="Java 多態的實現機制，看了都說好" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/9d3b0e55813d46b4982ae7d9b81d1802 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cf633068.html title="Java 多態的實現機制，看了都說好">Java 多態的實現機制，看了都說好</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html alt="Java 編譯時多態和運行時多態" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1531535784468c357213ffe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/12498348.html title="Java 編譯時多態和運行時多態">Java 編譯時多態和運行時多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html alt=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ab338c7287fe4649a96227987579c844 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d60e504d.html title=Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要>Java基礎之多態，動態綁定多態的代碼案例，簡單卻很重要</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html alt=Java特性之一：多態詳解，學java不求人 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39a700034bab2e1401a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb876e43.html title=Java特性之一：多態詳解，學java不求人>Java特性之一：多態詳解，學java不求人</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html alt=Java開發課程（十）——面向對象5、多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/df3621e51e4242fd90731dd013472f12 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/234d55fa.html title=Java開發課程（十）——面向對象5、多態>Java開發課程（十）——面向對象5、多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html alt=「Java三分鐘」Java三大特性——多態理解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/6a9b8965-0a4c-4cb4-9389-6cbbda0e9d93 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/96d2083b.html title=「Java三分鐘」Java三大特性——多態理解>「Java三分鐘」Java三大特性——多態理解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html alt=如何正確認識Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d2896b2f39694d39957b901a62cfe7fb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b96b5bf9.html title=如何正確認識Java多態>如何正確認識Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6ec898b4.html alt=三分鐘讓你分清鋼筋的類型 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/adf123fe955b46c1bdd651a5d691fdf1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6ec898b4.html title=三分鐘讓你分清鋼筋的類型>三分鐘讓你分清鋼筋的類型</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>