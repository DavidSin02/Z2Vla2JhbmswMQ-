<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>詳解JS中的事件機制(帶實例) | 极客快訊</title><meta property="og:title" content="詳解JS中的事件機制(帶實例) - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/dfic-imagehandler/780efda3-0c9d-4ac0-be7b-318d4cfa7db1"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/473b8fa0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/473b8fa0.html><meta property="article:published_time" content="2020-10-29T21:11:54+08:00"><meta property="article:modified_time" content="2020-10-29T21:11:54+08:00"><meta name=Keywords content><meta name=description content="詳解JS中的事件機制(帶實例)"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/473b8fa0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>詳解JS中的事件機制(帶實例)</h1></header><date class="post-meta meta-date">2020-10-29</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p><br></p><div class=pgc-img><img alt=詳解JS中的事件機制(帶實例) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/dfic-imagehandler/780efda3-0c9d-4ac0-be7b-318d4cfa7db1><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>1. 事件冒泡與事件捕獲</h2><p>事件冒泡和事件捕獲分別由微軟和網景公司提出，這兩個概念都是為了解決頁面中事件流（事件發生順序）的問題。考慮下面這段代碼，就不寫html->head,body之類的代碼了，自行腦補</p><pre><code>&lt;div id="outer"&gt;       &lt;p id="inner"&gt;Click me!&lt;/p&gt;&lt;/div&gt;</code></pre><p>上面的代碼當中一個div元素當中有一個p子元素，如果兩個元素都有一個click的處理函數，那麼我們怎麼才能知道哪一個函數會首先被觸發呢？為了解決這個問題微軟和網景提出了兩種幾乎完全相反的概念。</p><h4 class=pgc-h-arrow-right>1.1 事件冒泡</h4><p>微軟提出了名為事件冒泡(event bubbling) 的事件流。事件冒泡可以形象地比喻為把一顆石頭投入水中，泡泡會一直從水底冒出水面。也就是說，事件會從最內層的元素開始發生，一直向上傳播，直到document對象。 因此在事件冒泡的概念下在p元素上發生click事件的順序應該是p -> div -> body -> html -> document</p><h4 class=pgc-h-arrow-right>1.2 事件捕獲</h4><p>網景提出另一種事件流名為事件捕獲(event capturing) 。與事件冒泡相反，事件會從最外層開始發生，直到最具體的元素。</p><p>因此在事件捕獲的概念下在p元素上發生click事件的順序應該是document -> html -> body -> div -> p</p><h4 class=pgc-h-arrow-right>1.3 addEventListener的第三個參數</h4><p>網景 和 微軟 曾經的戰爭還是比較火熱的，當時， 網景主張捕獲方式，微軟主張冒泡方式。後來 w3c 採用折中的方式，平息了戰火，制定了統一的標準——<strong>先捕獲再冒泡</strong>。 addEventListener的第三個參數就是為冒泡和捕獲準備的.addEventListener有三個參數：</p><pre><code>element.addEventListener(event, function, useCapture)</code></pre><p>第一個參數是需要綁定的事件 第二個參數是觸發事件後要執行的函數 第三個參數默認值是false，表示在<strong>事件冒泡階段</strong>調用事件處理函數;如果參數為true，則表示在<strong>事件捕獲階段</strong>調用處理函數。</p><h2 class=pgc-h-arrow-right>2. 實例講解</h2><h4 class=pgc-h-arrow-right>2.1 冒泡的案例</h4><pre><code>&lt;div id="s1"&gt;s1    &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;    s1.addEventListener("click",function(e){    console.log("s1 冒泡事件"); },false);    s2.addEventListener("click",function(e){    console.log("s2 冒泡事件"); },false);&lt;/script&gt;</code></pre><p>當我們點擊s2的時候，執行結果如下：</p><div class=pgc-img><img alt=詳解JS中的事件機制(帶實例) onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/672c42d0aae946ae89c1d213118579ce><p class=pgc-img-caption></p></div><h4 class=pgc-h-arrow-right>2.2 捕獲的案例</h4><pre><code>&lt;div id="s1"&gt;s1 &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt; s1.addEventListener("click",function(e){ console.log("s1 捕獲事件"); },true); s2.addEventListener("click",function(e){ console.log("s2 捕獲事件"); },true);&lt;/script&gt;</code></pre><p>當我們點擊s2的時候，執行結果如下：</p><pre><code>s1 捕獲事件s2 捕獲事件</code></pre><h2 class=pgc-h-arrow-right>3. 事件捕獲vs事件冒泡</h2><p>當事件捕獲和事件冒泡一起存在的情況，事件又是如何觸發呢。這裡記被點擊的DOM節點為target節點</p><ol start=1><li>document 往 target節點，捕獲前進，遇到註冊的捕獲事件立即觸發執行</li><li>到達target節點，觸發事件（對於target節點上，是先捕獲還是先冒泡則捕獲事件和冒泡事件的註冊順序，先註冊先執行）</li><li>target節點 往 document 方向，冒泡前進，遇到註冊的冒泡事件立即觸發</li></ol><h4 class=pgc-h-arrow-right>3.1 總結下就是:</h4><ul><li>對於非target節點則先執行捕獲在執行冒泡</li><li>對於target節點則是先執行先註冊的事件，無論冒泡還是捕獲</li></ul><pre><code>&lt;div id="s1"&gt;s1 &lt;div id="s2"&gt;s2&lt;/div&gt;&lt;/div&gt;&lt;script&gt;s1.addEventListener("click",function(e){       console.log("s1 冒泡事件"); },false);s2.addEventListener("click",function(e){       console.log("s2 冒泡事件");},false);s1.addEventListener("click",function(e){       console.log("s1 捕獲事件");},true);s2.addEventListener("click",function(e){      console.log("s2 捕獲事件");},true);&lt;/script&gt;</code></pre><p>當我們點擊s2的時候,執行結果如下：</p><pre><code>s1 捕獲事件s2 冒泡事件s2 捕獲事件s1 冒泡事件</code></pre><p>這裡大體分析下執行結果 點擊s2，click事件從document->html->body->s1->s2(捕獲前進)這裡在s1上發現了捕獲註冊事件，則輸出<strong>"s1 捕獲事件"</strong> 到達s2，已經到達目的節點， s2上註冊了冒泡和捕獲事件，先註冊的冒泡後註冊的捕獲，則先執行冒泡，輸出<strong>"s2 冒泡事件"</strong> 再在s2上執行後註冊的事件，即捕獲事件，輸出<strong>"s2 捕獲事件"</strong> 下面進入冒泡階段，按照s2->s1->body->html->documen(冒泡前進) 在s1上發現了冒泡事件，則輸出<strong>"s1 冒泡事件"</strong></p><h2 class=pgc-h-arrow-right>4. 事件冒泡與事件捕獲應用:事件代理</h2><h4 class=pgc-h-arrow-right>4.1 案例</h4><p>在實際的開發當中，利用事件流的特性，我們可以使用一種叫做事件代理的方法。</p><pre><code>&lt;ul id="color-list"&gt; &lt;li&gt;red&lt;/li&gt; &lt;li&gt;yellow&lt;/li&gt; &lt;li&gt;blue&lt;/li&gt; &lt;li&gt;green&lt;/li&gt; &lt;li&gt;black&lt;/li&gt; &lt;li&gt;white&lt;/li&gt;&lt;/ul&gt;</code></pre><p>如果點擊頁面中的li元素，然後輸出li當中的顏色，我們通常會這樣寫:</p><pre><code>(function(){ var color_list = document.getElementById('color-list'); var colors = color_list.getElementsByTagName('li'); for(var i=0;i&lt;colors.length;i++){ colors[i].addEventListener('click',showColor,false); }; function showColor(e){ var x = e.target; console.log("The color is " + x.innerHTML); };})();</code></pre><p>利用事件流的特性，我們只綁定一個事件處理函數也可以完成：</p><pre><code>(function(){  var color_list =document.getElementById('color-list');  color_list.addEventListener('click',showColor,false);  function showColor(e){  var x = e.target;  if(x.nodeName.toLowerCase() === 'li'){  console.log('The color is ' + x.innerHTML);  } }})();</code></pre><p>使用事件代理的好處不僅在於將多個事件處理函數減為一個，而且對於不同的元素可以有不同的處理方法。假如上述列表元素當中添加了其他的元素（如：a、span等），我們不必再一次循環給每一個元素綁定事件，直接修改事件代理的事件處理函數即可。</p><h2 class=pgc-h-arrow-right>5. 冒泡還是捕獲？</h2><p>對於事件代理來說，在事件捕獲或者事件冒泡階段處理並沒有明顯的優劣之分，但是由於事件冒泡的事件流模型被所有主流的瀏覽器兼容，從兼容性角度來說還是建議大家使用事件冒泡模型。</p><h4 class=pgc-h-arrow-right>5.1 IE瀏覽器兼容</h4><p>IE瀏覽器對addEventListener兼容性並不算太好，只有IE9以上可以使用。</p><p>要兼容舊版本的IE瀏覽器，可以使用IE的attachEvent函數</p><pre><code>object.attachEvent(event, function)</code></pre><p>兩個參數與addEventListener相似，分別是事件和處理函數，默認是事件冒泡階段調用處理函數，要注意的是，寫事件名時候要加上"on"前綴（"onload"、"onclick"等）。</p><h2 class=pgc-h-arrow-right>6. 事件注意點</h2><ul><li>事件分為三個階段： 事件捕獲 --> 事件目標 --> 事件冒泡</li><li>事件捕獲：事件發生時（onclick,onmouseover……）首先發生在document上，然後依次傳遞給body、……最後到達目的節點（即事件目標）。</li><li>事件冒泡：事件到達事件目標之後不會結束，會逐層向上冒泡，直至document對象，跟事件捕獲相反</li></ul><h4 class=pgc-h-arrow-right>6.1 常用技巧</h4><p>1、onlick -->事件冒泡，重寫onlick會覆蓋之前屬性，沒有兼容性問題</p><pre><code>ele.onclik = null;   //解綁單擊事件，將onlick屬性設為null即可</code></pre><p>2、addEventListener(event.type, handle, boolean); IE8及以下不支持，屬於DOM2級的方法，可添加多個方法不被覆蓋</p><pre><code>//事件類型沒有on，false 表示在事件第三階段（冒泡）觸發，true表示在事件第一階段（捕獲）觸發。 如果handle是同一個方法，只執行一次。ele.addEventListener('click', function(){ }, false);  //解綁事件，參數和綁定一樣ele.removeEventListener(event.type, handle, boolean);</code></pre><p>3、attachEvent(event.type, handle ); IE特有，兼容IE8及以下，可添加多個事件處理程序，只支持冒泡階段</p><pre><code>//如果handle是同一個方法，綁定幾次執行幾次，這點和addEventListener不同,事件類型要加on,例如onclick而不是clickele.attachEvent('onclick', function(){ }); //解綁事件，參數和綁定一樣ele.detachEvent("onclick", function(){ });</code></pre><p>4、默認事件行為：href=""鏈接，submit表單提交等 <strong>阻止默認事件：</strong> （1）return false; 阻止獨享屬性（通過on這種方式）綁定的事件的默認事件</p><pre><code>ele.onclick = function() {    ……                         //你的代碼    return false;              //通過返回false值阻止默認事件行為};</code></pre><p>（2）event.preventDefault( ); 阻止通過 addEventListener( ) 添加的事件的默認事件</p><pre><code>element.addEventListener("click", function(e){    var event = e || window.event;    ……    event.preventDefault( );      //阻止默認事件},false);</code></pre><p>（3）event.returnValue = false; 阻止通過 attachEvent( ) 添加的事件的默認事件</p><pre><code>element.attachEvent("onclick", function(e){    var event = e || window.event;    ……    event.returnValue = false;       //阻止默認事件},false);</code></pre><p>5、接下來我們把事件綁定以及事件解綁封裝成為一個函數，兼容瀏覽器，包括IE6及以上</p><pre><code>// 事件綁定function addEvent(element, eType, handle, bol) {    if(element.addEventListener){           //如果支持addEventListener        element.addEventListener(eType, handle, bol);    }else if(element.attachEvent){          //如果支持attachEvent        element.attachEvent("on"+eType, handle);    }else{                                  //否則使用兼容的onclick綁定        element["on"+eType] = handle;    }}</code></pre><pre><code>// 事件解綁function removeEvent(element, eType, handle, bol) {    if(element.addEventListener){        element.removeEventListener(eType, handle, bol);    }else if(element.attachEvent){        element.detachEvent("on"+eType, handle);    }else{        element["on"+eType] = null;    }}</code></pre><p><strong>A.● 事件冒泡、事件捕獲阻止：</strong></p><pre><code>event.stopPropagation( );                // 阻止事件的進一步傳播，包括（冒泡，捕獲），無參數event.cancelBubble = true;             // true 為阻止冒泡</code></pre><p><strong>B.● 事件委託:</strong> 利用事件冒泡的特性，將裡層的事件委託給外層事件，根據event對象的屬性進行事件委託，改善性能。 使用事件委託能夠避免對特定的每個節點添加事件監聽器；事件監聽器是被添加到它們的父元素上。事件監聽器會分析從子元素冒泡上來的事件，找到是哪個子元素的事件。</p><p>來個例子吧，如果要單獨點擊table裡面的td，普通做法是for循環給每個td綁定事件，td少的話性能什麼差別，td如果多了，就不行了，我們使用事件委託:</p><pre><code> &lt;!-- HTML --&gt;&lt;table id="out" border="1" style="cursor: pointer;"&gt;    &lt;tr&gt;    　　&lt;td&gt;table01&lt;/td&gt;    　　&lt;td&gt;table02&lt;/td&gt;    　　&lt;td&gt;table03&lt;/td&gt;    　　&lt;td&gt;table04&lt;/td&gt;    　　&lt;td&gt;table05&lt;/td&gt;    　　&lt;td&gt;table06&lt;/td&gt;    　　&lt;td&gt;table07&lt;/td&gt;    　　&lt;td&gt;table08&lt;/td&gt;    　　&lt;td&gt;table09&lt;/td&gt;    　　&lt;td&gt;table10&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><pre><code>var out = document.getElementById("out");      if(out.addEventListener){          out.addEventListener("click",function(e){              var e = e||window.event;              //IE沒有e.target，有e.srcElement              var target = e.target||e.srcElement;             //判斷事件目標是否是td，是的話target即為目標節點td            if(target.tagName.toLowerCase()=="td"){                 changeStyle(target);                 console.log(target.innerHTML);             }         },false);     }else{         out.attachEvent("onclick",function(e){             var e = e||window.event;             //IE沒有e.target，有e.srcElement             var target = e.target||e.srcElement;             //判斷事件目標是否是td，是的話target即為目標節點td             if(target.tagName.toLowerCase()=="td"){                 changeStyle(target);                 console.log(target.innerHTML);             }         });     }; }; function changeStyle(ele){     ele.innerHTML = "已點擊"     ele.style.background="#900";     ele.style.color = "#fff"; }</code></pre></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>詳解</a></li><li><a>JS</a></li><li><a>機制</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html alt="SQL 事務機制-transaction" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3231427d97bf4a04b148360fea032241 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bb071e7e.html title="SQL 事務機制-transaction">SQL 事務機制-transaction</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html alt=事務機制和鎖機制 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5a547c8c402142cca7ed81d05fe0e3e3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5f4c6dc1.html title=事務機制和鎖機制>事務機制和鎖機制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html alt="詳解Oracle 數據庫啟動過程" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/1538236609349861be8e044 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/dc1a27dd.html title="詳解Oracle 數據庫啟動過程">詳解Oracle 數據庫啟動過程</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html alt=連mysql鎖的機制都不瞭解，怎麼做架構師 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533476323070887266574f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6e8f3f2e.html title=連mysql鎖的機制都不瞭解，怎麼做架構師>連mysql鎖的機制都不瞭解，怎麼做架構師</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html alt=什麼是多態機制？Java語言是如何實現多態的？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/d61f4356-80bf-4d14-8d12-f4a6fdca887c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ad79c04.html title=什麼是多態機制？Java語言是如何實現多態的？>什麼是多態機制？Java語言是如何實現多態的？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html alt=詳解13項鋼筋安裝質量標準及通病防治 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/fd3ff534941a487884c7a67361337cfb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f44ab8f6.html title=詳解13項鋼筋安裝質量標準及通病防治>詳解13項鋼筋安裝質量標準及通病防治</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html alt=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/34b07b6f.html title=天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位>天津疫情防控落實“戰時機制”各區黨政主要負責同志停止假期狀態，立即到崗就位</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html alt=史上最全電路圖詳解！老電工都收藏了！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533138404073909636bf43 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/464b2d9e.html title=史上最全電路圖詳解！老電工都收藏了！>史上最全電路圖詳解！老電工都收藏了！</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>