<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>數據結構與算法（7）遞歸 | 极客快訊</title><meta property="og:title" content="數據結構與算法（7）遞歸 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48215327.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48215327.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48215327.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48215327.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48215327.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48215327.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48215327.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48215327.html><meta property="article:published_time" content="2020-11-14T21:04:22+08:00"><meta property="article:modified_time" content="2020-11-14T21:04:22+08:00"><meta name=Keywords content><meta name=description content="數據結構與算法（7）遞歸"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/48215327.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>數據結構與算法（7）遞歸</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>頭條的編輯器功能少、代碼簡直沒法看，建議去微信公眾號閱讀，微信公眾號：行知老王</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/6548910d67bb4d6e82fb33f08f496622><p class=pgc-img-caption></p></div><p class=ql-align-justify>遞歸是一種應用非常廣泛的算法（或者編程技巧）。之後我們要講的很多數據結構和算法的編碼實現都要用到遞歸，比如 DFS 深度優先搜索、前中後序二叉樹遍歷等等。所以，搞懂遞歸非常重要，否則，後面複雜一些的數據結構和算法學起來就會比較吃力。</p><p class=ql-align-justify><strong>## 基本概念</strong></p><p class=ql-align-justify>維基百科的定義：遞歸（英語：Recursion），又譯為遞迴，在數學與計算機科學中，是指在函數的定義中使用函數自身的方法。遞歸一詞還較常用於描述以自相似方法重複事物的過程。例如，當兩面鏡子相互之間近似平行時，鏡中嵌套的圖像是以無限遞歸的形式出現的。也可以理解為自我複製的過程。</p><p class=ql-align-justify>百度百科的定義：程序調用自身的編程技巧稱為遞歸（ recursion）。遞歸作為一種算法在程序設計語言中廣泛應用。一個過程或函數在其定義或說明中有直接或間接調用自身的一種方法，它通常把一個大型複雜的問題層層轉化為一個與原問題相似的規模較小的問題來求解，遞歸策略只需少量的程序就可描述出解題過程所需要的多次重複計算，大大地減少了程序的代碼量。遞歸的能力在於用有限的語句來定義對象的無限集合。一般來說，遞歸需要有邊界條件、遞歸前進段和遞歸返回段。當邊界條件不滿足時，遞歸前進；當邊界條件滿足時，遞歸返回。</p><p class=ql-align-justify><strong>## 經典生活場景</strong></p><ul><li class=ql-align-justify>從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？“從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？‘從前有座山，山裡有座廟，廟裡有個老和尚，正在給小和尚講故事呢！故事是什麼呢？……’”</li><li class=ql-align-justify>“你被綁架了！”，“誰呀？”，“你！”，“咋滴啦？”，“你被綁架了！”，“誰呀？”，“你！”，“咋滴啦？”，“你被綁架了！”，“誰呀？”.......</li></ul><p class=ql-align-justify><strong>## 遞歸滿足的條件</strong></p><ol><li class=ql-align-justify>一個問題的解可以分解為幾個子問題的解，子問題就是數據規模更小的問題。</li><li class=ql-align-justify>這個問題與分解後的子問題，除了數據規模不同，求解思路完全一樣。</li><li class=ql-align-justify>存在終止條件，也就是把問題分解為子問題，再把子問題分解為子子問題，一層一層分解下去，不能存在無限循環，需要有終止條件。上面那倆生活場景的例子其實是沒有終止條件的，不算是合規的遞歸。</li></ol><p class=ql-align-justify><strong>## 遞歸三要素</strong></p><p class=ql-align-justify>遞歸其實是兩個過程，去的過程叫遞，回來的過程叫歸。</p><p class=ql-align-justify>由此，遞歸必須要有三要素：</p><ol><li class=ql-align-justify>邊界條件，也就是終止條件。</li><li class=ql-align-justify>遞歸的前進段，也就是遞的過程。</li><li class=ql-align-justify>遞歸的返回段，也就是回來的過程。</li></ol><p class=ql-align-justify>當邊界條件不滿足時，遞歸前進，也就是遞；當邊界條件滿足時，遞歸返回，也就是歸。</p><p class=ql-align-justify><strong>## 如何編寫遞歸代碼</strong></p><p class=ql-align-justify>寫遞歸代碼最關鍵的是寫出遞推公式，找到終止條件。也就是找到如何將大問題分解為小問題的規律，並且基於此寫出遞推公式，然後再找出終止條件，最後將遞推公式和終止條件翻譯成代碼。這期間不用想一層層的調用關係，不要去分解遞歸的每個步驟。</p><p class=ql-align-justify><strong>## 警惕堆棧溢出</strong></p><p class=ql-align-justify>編寫遞歸代碼時，很可能會遇到堆棧溢出的問題，進而導致系統崩潰。</p><ul><li class=ql-align-justify>為什麼遞歸會導致堆棧溢出呢？</li></ul><p class=ql-align-justify>我們先看一下函數調用時內存發生了什麼：</p><ol><li class=ql-align-justify>當一個方法被調用時，它的參數和返回地址被壓入一個棧中；</li><li class=ql-align-justify>這個方法可以通過獲取棧頂元素的值來訪問它的參數；</li><li class=ql-align-justify>當這個方法要返回時，它查看棧以獲得返回地址，然後這個地址以及方法的所有參數退棧，並且銷燬。</li></ol><p class=ql-align-justify>因為函數調用時會用棧來保存臨時變量，每調用一個函數，都會將臨時變量封裝為棧幀壓入內存棧中，當函數執行完成返回時，才出棧。系統棧或者虛擬機棧空間一般都不大，如果遞歸求解的數據規模很大，層次很深，一直往棧中壓入數據，就會有堆棧溢出的風險，對java語言來說，就會拋出：</p><p class=ql-align-justify><strong>java.lang.StackOverflowError</strong>異常。</p><ul><li class=ql-align-justify>如何避免遞歸時出現堆棧溢出呢？</li></ul><p class=ql-align-justify>我們可以通過限制遞歸的最大深度來解決，比如，遞歸調用超過一定深度後，就不再繼續遞歸了，直接返回報錯信息。當然，這也不是最好的解決方案，畢竟我們事先也不知道當前線程剩餘的棧空間是多大，這種對最大深度比較小的遞歸適用。對於數據規模較大的情況，建議用循環來解決。也就是非遞歸的方式。因為遞歸的使用在方法的調用和返回都會有額外的開銷，通常情況下，用遞歸能實現的，用循環都可以實現，而且循環的效率會更高。</p><p class=ql-align-justify><strong># 應用</strong></p><p class=ql-align-justify><strong>## 求一個數的階乘 n!</strong></p><ul><li class=ql-align-justify>階乘公式：<strong>n! = n<em>*(n-1)*</em>(n-2)<em>*......*</em>1，也就是：n! = n*(n-1)！</strong></li><li class=ql-align-justify>同時規定：<strong>0！=1；1！=1；負數沒有階乘</strong></li></ul><pre>/** * for循環求階乘  * 0！=1，1！=1，負數沒有階乘,如果輸入負數返回-1 *  * @param n * @return */public static int getFactorialByFor(int n) { int temp = 1; if (n &gt;= 0) { for (int i = 1; i &lt;= n; i++) { temp = temp * i; } } else { return -1; } return temp;}/** * 遞歸求階乘  * 0！=1，1！=1，負數沒有階乘,如果輸入負數返回-1 *  * @param n * @return */public static int getFactorialByRecursion(int n) { if (n &gt;= 0) { if (n == 0) { System.out.println(n + "!=1"); return 1; } else { System.out.println(n); int temp = n * getFactorialByRecursion(n - 1); System.out.println(n + "!=" + temp); return temp; } } return -1;}</pre><p class=ql-align-justify>上面求階乘的終止條件就是n==0。</p><p class=ql-align-justify><strong>## 二分查找</strong></p><p class=ql-align-justify>之前講數組的時候，我們說過，二分查找的數組一定是有序的。</p><p class=ql-align-justify>在有序數組array[]中，不斷將數組的中間值（mid）和被查找的值比較，如果被查找的值等於array[mid],就返回下標mid; 否則，就將查找範圍縮小一半。如果被查找的值小於array[mid], 就繼續在左半邊查找;如果被查找的值大於array[mid], 就繼續在右半邊查找。直到查找到該值或者查找範圍為空時，查找結束。這不就是遞歸麼，終止條件就是找到該值或者查找範圍為空。</p><p class=ql-align-justify>二分查找的過程如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/76266446d8dc4459a47518a09c9cc56c><p class=pgc-img-caption></p></div><p class=ql-align-justify>對50的非命中查找如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/146d156bcee34cd5b4ddbed3d9ac5d43><p class=pgc-img-caption></p></div><p class=ql-align-justify>普通循環實現二分查找：</p><pre>/** * 普通循環實現二分查找，找到目標值返回數組下標，找不到返回-1 *  * @param array * @param key * @return int */public static int findTwoPoint(int[] array, int key) { int start = 0; int last = array.length - 1; while (start &lt;= last) { int mid = (last - start) / 2 + start;// 防止直接相加造成int範圍溢出 if (key == array[mid]) {// 查找值等於當前值，返回數組下標 return mid; } if (key &gt; array[mid]) {// 查找值比當前值大 start = mid + 1; } if (key &lt; array[mid]) {// 查找值比當前值小 last = mid - 1; } } return -1;}</pre><p class=ql-align-justify>遞歸實現二分查找：</p><pre>/** * 遞歸實現二分查找，邊界條件是找到當前值，或者查找範圍為空。否則每一次查找都將範圍縮小一半。 *  * @param array * @param key * @param low * @param high * @return int */public static int search(int[] array, int key, int low, int high) { int mid = (high - low) / 2 + low; if (key == array[mid]) {// 查找值等於當前值，返回數組下標 return mid; } else if (low &gt; high) {// 找不到查找值，返回-1 return -1; } else { if (key &lt; array[mid]) {// 查找值比當前值小 return search(array, key, low, mid - 1); } if (key &gt; array[mid]) {// 查找值比當前值大 return search(array, key, mid + 1, high); } } return -1;}</pre><p class=ql-align-justify>遞歸的二分查找和非遞歸的二分查找效率都為O(logN)，遞歸的二分查找更加簡潔，便於理解，但是速度會比非遞歸的慢。</p><p class=ql-align-justify><strong>## 漢諾塔問題</strong></p><p class=ql-align-justify>漢諾塔問題是由很多放置在三個塔座上的盤子組成的一個古老的難題。如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/371efa01da214dc3864c6de5af0125bb><p class=pgc-img-caption></p></div><p>所有盤子的直徑是不同的，並且盤子中央都有一個洞使得它們剛好可以放在塔座上。所有的盤子剛開始都放置在A 塔座上。這個難題的目標是將所有的盤子都從塔座A移動到塔座C上，每次只可以移動一個盤子，並且任何一個盤子都不可以放置在比自己小的盤子之上。</p><p>試想一下，如果只有兩個盤子，盤子從小到大我們以數字命名（也可以想象為直徑），兩個盤子上面就是盤子1，下面是盤子2，那麼我們只需要將盤子1先移動到B塔座上，然後將盤子2移動到C塔座，最後將盤子1移動到C塔座上。即完成2個盤子從A到C的移動。</p><p>如果有三個盤子，那麼我們將盤子1放到C塔座，盤子2放到B塔座，在將C塔座的盤子1放到B塔座上，然後將A塔座的盤子3放到C塔座上，然後將B塔座的盤子1放到A塔座，將B塔座的盤子2放到C塔座，最後將A塔座的盤子1放到C塔座上。如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/911908b1c1524ba88a35478dae99a323><p class=pgc-img-caption></p></div><p class=ql-align-justify>動起來：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5365b4a503944b91b1d06d4972dac361><p class=pgc-img-caption></p></div><p>如果有四個，五個，N個盤子，那麼我們應該怎麼去做？這時候遞歸的思想就很好解決這樣的問題了，當只有兩個盤子的時候，我們只需要將B塔座作為中介，將盤子1先放到中介塔座B上，然後將盤子2放到目標塔座C上，最後將中介塔座B上的盤子放到目標塔座C上即可。</p><p>所以無論有多少個盤子，我們都將其看做只有兩個盤子。假設有 N 個盤子在塔座A上，我們將其看為兩個盤子，其中(N-1)~1個盤子看成是一個盤子，最下面第N個盤子看成是一個盤子，那麼解決辦法為：</p><p>①、先將A塔座的第(N-1)~1個盤子看成是一個盤子，放到中介塔座B上，然後將第N個盤子放到目標塔座C上。</p><p>②、然後A塔座為空，看成是中介塔座，B塔座這時候有N-1個盤子，將第(N-2)~1個盤子看成是一個盤子，放到中介塔座A上，然後將B塔座的第(N-1)號盤子放到目標塔座C上。</p><p>③、這時候A塔座上有(N-2)個盤子，B塔座為空，又將B塔座視為中介塔座，重複①，②步驟，直到所有盤子都放到目標塔座C上結束。</p><p>簡單來說，遞歸算法為：</p><p>1. 從初始塔座A上移動包含n-1個盤子到中介塔座B上。</p><p>2. 將初始塔座A上剩餘的一個盤子（最大的一個盤子）放到目標塔座C上。</p><p>3. 將中介塔座B上n-1個盤子移動到目標塔座C上。</p><p>於是我們可以設計一個函數，它的功能是將n個在x柱子上的盤子藉助y柱子移到z柱子上：<strong>hannoi(n,x,y,z)</strong></p><p>於是我們上面的三步可以用程序語言來表達：</p><p>1. hannoi(n-1,A,C,B)</p><p>2. hannoi(1,A,B,C)</p><p>3. hannoi(n-1,B,A,C)</p><p>代碼實現如下：</p><pre>/** * 遞歸實現漢諾塔問題 *  * @param dish * 盤子個數(也表示名稱) * @param from * 初始塔座 * @param temp * 中介塔座 * @param to * 目標塔座 */public static void hannoi(int dish, String from, String temp, String to) { if (dish == 1) { System.out.println("將盤子" + dish + "從塔座" + from + "移動到目標塔座" + to); } else { hannoi(dish - 1, from, to, temp);// A為初始塔座，B為目標塔座，C為中介塔座 System.out.println("將盤子" + dish + "從塔座" + from + "移動到目標塔座" + to); hannoi(dish - 1, temp, from, to);// B為初始塔座，C為目標塔座，A為中介塔座 }}</pre><p class=ql-align-justify><strong># 分治算法</strong></p><p class=ql-align-justify>當我們求解某些問題時，由於這些問題要處理的數據相當多，或求解過程相當複雜，使得直接求解法在時間上相當長，或者根本無法直接求出。對於這類問題，我們往往先把它分解成幾個子問題，找到求出這幾個子問題的解法後，再找到合適的方法，把它們組合成求整個問題的解法。如果這些子問題還較大，難以解決，可以再把它們分成幾個更小的子問題，以此類推，直至可以直接求出解為止。這就是分治策略的基本思想。</p><p class=ql-align-justify>上面講的遞歸的二分查找法和下邊的歸併排序方法就是分治算法的典型例子，分治算法常常是一個方法，在這個方法中含有兩個對自身的遞歸調用，分別對應於問題的兩個部分。</p><p class=ql-align-justify>二分查找中，將查找範圍分成比查找值大的一部分和比查找值小的一部分，每次遞歸調用只會有一個部分執行，然後一次次縮小查找部分的範圍。</p><p class=ql-align-justify><strong>## 歸併排序</strong></p><p class=ql-align-justify>歸併算法的中心是合併兩個已經有序的數組。合併兩個有序數組A和B，就生成了第三個有序數組C，數組C包含數組A和B的所有數據項。</p><p class=ql-align-justify>我們先看看如果不用遞歸，如何合併兩個有序數組：</p><pre>/** * 傳入兩個有序數組a和b，返回一個排好序的合併數組 *  * @param 有序數組 a * @param 有序數組 b * @return */public static int[] sort(int[] a, int[] b) { int[] c = new int[a.length + b.length]; int aNum = 0, bNum = 0, cNum = 0; while (aNum &lt; a.length &amp;&amp; bNum &lt; b.length) { if (a[aNum] &gt;= b[bNum]) {// 比較a數組和b數組的元素，誰更小將誰賦值到c數組 c[cNum++] = b[bNum++]; } else { c[cNum++] = a[aNum++]; } } // 如果a數組全部賦值到c數組了，但是b數組還有元素，則將b數組剩餘元素按順序全部複製到c數組 while (aNum == a.length &amp;&amp; bNum &lt; b.length) { c[cNum++] = b[bNum++]; } // 如果b數組全部賦值到c數組了，但是a數組還有元素，則將a數組剩餘元素按順序全部複製到c數組 while (bNum == b.length &amp;&amp; aNum &lt; a.length) { c[cNum++] = a[aNum++]; } return c;}</pre><p class=ql-align-justify>該方法有三個while循環，第一個while比較數組a和數組b的元素，並將較小的賦值到數組c；第二個while循環當a數組所有元素都已經賦值到c數組之後，而b數組還有元素，那麼直接把b數組剩餘的元素賦值到c數組；第三個while循環則是b數組所有元素都已經賦值到c數組了，而a數組還有剩餘元素，那麼直接把a數組剩餘的元素全部賦值到c數組。</p><p class=ql-align-justify><strong>### 歸併排序的思想：</strong></p><p class=ql-align-justify>1. 將待排序的線性表不斷地切分成若干個子表，直到每個子表只包含一個元素，這時，可以認為只包含一個元素的子表是有序表。</p><p class=ql-align-justify>2. 將子表兩兩合併，每合併一次，就會產生一個新的且更長的有序表，重複這一步驟，直到最後只剩下一個子表，這個子表就是排好序的線性表。</p><p class=ql-align-justify>也就是我們把需要排序的數組分成兩半，排序每一半，然後將排序好的兩半用上面的合併方法進行合併，那分開的兩半怎麼排序呢，那就把每一半都分為四分之一，對每個四分之一進行排序，然後把它們歸併成一個有序的一半。類似的，如何給每個四分之一數組排序呢？把每個四分之一分成八分之一，對每個八分之一進行排序，以此類推，反覆的分割數組，直到得到的子數組是一個數據項，那這就是這個遞歸算法的邊界值，也就是假定一個數據項的元素是有序的。</p><p class=ql-align-justify><strong>### 歸併排序的步驟：</strong></p><p class=ql-align-justify>1. 申請空間，使其大小為兩個已經排序序列之和，該空間用來存放合併後的序列；</p><p class=ql-align-justify>2. 設定兩個指針，最初位置分別為兩個已經排序序列的起始位置；</p><p class=ql-align-justify>3. 比較兩個指針所指向的元素，選擇相對小的元素放入到合併空間，並移動指針到下一位置；</p><p class=ql-align-justify>4. 重複步驟 3 直到某一指針達到序列尾；</p><p class=ql-align-justify>5. 將另一序列剩下的所有元素直接複製到合併序列尾。</p><p class=ql-align-justify><strong>### 實例演示</strong></p><p class=ql-align-justify>我們看下如何用歸併排序對數組[8,4,5,7,1,3,6,2]進行排序：</p><p class=ql-align-justify>1. 將數組拆分成一個個的子數組，可以通過遞歸拆分，一直拆分到無法再拆分為止，這個步驟叫“分”，如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/9ea61999947b4d4da696b32993889fa7><p class=pgc-img-caption></p></div><p>2. 合併相鄰有序子序列，這個階段叫“治”，我們需要將兩個已經有序的子序列合併成一個有序序列，比如上圖中的最後一次合併，要將[4,5,7,8]和[1,2,3,6]兩個已經有序的子序列，合併為最終序列[1,2,3,4,5,6,7,8]，如下圖所示：</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/99dda22b53a34c459f85d683173e4b35><p class=pgc-img-caption></p></div><p>實現代碼如下：</p><pre>import java.util.Arrays;public class MergeSort { public static void main(String[] args) { int[] arr = {2,7,8,3,1,6,9,0,5,4}; sort(arr); System.out.println(Arrays.toString(arr)); } public static void sort(int[] arr) { int[] temp = new int[arr.length];// 在排序前，先建好一個長度等於原數組長度的臨時數組，避免遞歸中頻繁開闢空間 sort(arr, 0, arr.length - 1, temp); } private static void sort(int[] arr, int left, int right, int[] temp) { if (left &lt; right) { int mid = (left + right) / 2; sort(arr, left, mid, temp);// 左邊歸併排序，使得左子序列有序 sort(arr, mid + 1, right, temp);// 右邊歸併排序，使得右子序列有序 merge(arr, left, mid, right, temp);// 將兩個有序子數組合並操作 } } private static void merge(int[] arr, int left, int mid, int right, int[] temp) { int i = left;// 左序列指針 int j = mid + 1;// 右序列指針 int t = 0;// 臨時數組指針 while (i &lt;= mid &amp;&amp; j &lt;= right) { if (arr[i] &lt;= arr[j]) { temp[t++] = arr[i++]; } else { temp[t++] = arr[j++]; } } while (i &lt;= mid) {// 將左邊剩餘元素填充進temp中 temp[t++] = arr[i++]; } while (j &lt;= right) {// 將右序列剩餘元素填充進temp中 temp[t++] = arr[j++]; } t = 0; // 將temp中的元素全部拷貝到原數組中 while (left &lt;= right) { arr[left++] = temp[t++]; } }}</pre><p class=ql-align-justify><strong>## 求一個數的乘方</strong></p><p class=ql-align-justify>一般稍微複雜一點的計算器上面都能求一個數的乘法，通常計算器上面的標誌是 x^y 這樣的按鍵，表示求 x 的 y 次方。一般情況下我們是如何求一個數的乘法的呢？</p><p class=ql-align-justify>比如2^8,我們可以會求表達式2<em>*2*</em>2<em>*2*</em>2<em>*2*</em>2*2 的值，但是如果y的值很大，這個會顯得表達式很冗長。那麼由沒有更快一點方法呢？</p><p class=ql-align-justify>數學公式如下是成立的：<strong>(X^a)^b = X^(a*b)</strong></p><p class=ql-align-justify>如果如果求2的8次方，我們可以先假定2^2=a,於是2^8 = （2^2）^4 ，那麼就是a^4 ；假定 a^2 = b，那麼 a^4 = b^2，而b^2可以寫成(b^2)^1。於是現在2的8次方就轉換成：b*b。</p><p class=ql-align-justify>也就是說我們將乘方的運算轉換為乘法的運算。</p><p class=ql-align-justify>求xy的值，當y是偶數的時候，最後能轉換成兩個數相乘，當時當y是奇數的時候，最後我們必須要在返回值後面額外的乘以一個x。</p><p class=ql-align-justify><strong>x^y= (x^2)^(y/2)，定義a=x^2,b=y/2, 則得到形如：x^y= a^b;</strong></p><pre>/** * 求x的y次方 * @param x 底數 * @param y 指數 * @return * int */public static int pow(int x, int y) { if (x == 0 || x == 1) { return x; } if (y &gt; 1) { int b = y / 2; int a = x * x; if (y % 2 == 1) {// y為奇數 return pow(a, b) * x; } else {// y為偶數 return pow(a, b); } } else if (y == 0) { return 1; } else {// y==1 return x; }}</pre><p class=ql-align-justify><strong>## 揹包問題</strong></p><p class=ql-align-justify>揹包問題也是計算機中的經典問題。在最簡單的形式中，包括試圖將不同重量的數據項放到揹包中，以使得揹包最後達到指定的總重量。</p><p class=ql-align-justify>比如：假設想要讓揹包精確地承重20磅，並且有 5 個可以放入的數據項，它們的重量分別是 11 磅，8 磅，7 磅，6 磅，5 磅。這個問題可能對於人類來說很簡單，我們大概就可以計算出 8 磅+ 7 磅 + 5 磅 = 20 磅。但是如果讓計算機來解決這個問題，就需要給計算機設定詳細的指令了。</p><p class=ql-align-justify>算法如下：</p><p class=ql-align-justify>1. 如果在這個過程的任何時刻，選擇的數據項的總和符合目標重量，那麼工作便完成了。</p><p class=ql-align-justify>2. 從選擇的第一個數據項開始，剩餘的數據項的加和必須符合揹包的目標重量減去第一個數據項的重量，這是一個新的目標重量。</p><p class=ql-align-justify>3. 逐個的試每種剩餘數據項組合的可能性，但是注意不要去試所有的組合，因為只要數據項的和大於目標重量的時候，就停止添加數據。</p><p class=ql-align-justify>4. 如果沒有合適的組合，放棄第一個數據項，並且從第二個數據項開始再重複一遍整個過程。</p><p class=ql-align-justify>5. 繼續從第三個數據項開始，如此下去直到你已經試驗了所有的組合，這時才知道有沒有解決方案。</p><p class=ql-align-justify>具體實現過程：</p><pre>public class Knapsack { private int[] weights; // 可供選擇的重量 private boolean[] selects; // 記錄是否被選擇 public Knapsack(int[] weights) { this.weights = weights; selects = new boolean[weights.length]; } /** * 找出符合承重重量的組合 *  * @param total * 總重量 * @param index * 可供選擇的重量下標 */ public void knapsack(int total, int index) { if (total &lt; 0 || total &gt; 0 &amp;&amp; index &gt;= weights.length) { return;// 沒找到解決辦法，直接返回 } if (total == 0) {// 總重量為0，則找到解決辦法了 for (int i = 0; i &lt; index; i++) { if (selects[i] == true) { System.out.println(weights[i] + " "); } } System.out.println(); return; } selects[index] = true; knapsack(total - weights[index], index + 1); selects[index] = false; knapsack(total, index + 1); } public static void main(String[] args) { int array[] = { 11, 9, 7, 6, 5 }; int total = 20; Knapsack k = new Knapsack(array); k.knapsack(total, 0); }}</pre><p class=ql-align-justify><strong>## 找最終推薦人</strong></p><p class=ql-align-justify>推薦註冊返佣金的這個功能我想你應該不陌生吧？現在很多App都有這個功能。這個功能中，用戶A推薦用戶B來註冊，用戶B又推薦了用戶C來註冊。我們可以說，用戶C的“最終推薦人”為用戶A，用戶B的“最終推薦人”也為用戶A，而用戶A沒有“最終推薦人”。一般來說，我們會通過數據庫來記錄這種推薦關係。在數據庫表中，我們可以記錄兩行數據，其中actor_id表示用戶id，referrer_id， 表示推薦人id。這個結構就是個樹形結構，找“最終推薦人”就是通過樹葉找到樹根。偽代碼如下：</p><pre>long findRootReferrerId(long actorId) { Long referrerId = select referrer_id from [table] where actor_id = actorId; if (referrerId == null) return actorId; return findRootReferrerId(referrerId);}</pre><p class=ql-align-justify>以上的偽代碼在遞歸很深時，有內存溢出的問題，如果有髒數據，比如如果A的推薦人是B，B的推薦人是C，C的推薦人是A，這樣就會發生死循環。遞歸的深度我們可以限制，死循環也可以用遞歸深度限制，但是我們也可以檢測“環”的存在。<strong>檢測環可以構造一個set集合或者散列表。每次獲取到上層推薦人就去散列表裡先查，沒有查到的話就加入，如果存在則表示存在環了。當然，每一次查詢都是一個自己的散列表，不能共用。</strong></p><p class=ql-align-justify><strong>## 斐波那契數列</strong></p><p class=ql-align-justify>斐波那契數列指的是這樣一個數列 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……</p><p class=ql-align-justify>特別指出：</p><ul><li class=ql-align-justify><strong>第0項是0，第1項是第一個1</strong>。</li><li class=ql-align-justify><strong>這個數列從第三項開始，每一項都等於前兩項之和</strong>。</li></ul><p class=ql-align-justify>代碼如下：</p><pre>public static long fibonacci(long number) { if ((number == 0) || (number == 1)) return number; else return fibonacci(number - 1) + fibonacci(number - 2);}public static void main(String[] args) { for (int counter = 0; counter &lt;= 10; counter++) { System.out.printf("Fibonacci of %d is: %d\n", counter, fibonacci(counter)); }}</pre><p><strong># 調試遞歸代碼</strong></p><p>除了打印日誌返回每一次調用的遞值和歸值，必要的時候加斷點進行調試，暫時不知道還有沒有其他更好的方式。</p><div class=pgc-img><img alt=數據結構與算法（7）遞歸 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/61930478b28e4d8693b8b6a0417c8813><p class=pgc-img-caption>微信公眾號：行知老王</p></div></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>數據</a></li><li><a>結構</a></li><li><a>遞歸</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html alt=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/3609570de59a49a9be5667dd9a637f65 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/37396ded.html title=數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心>數據結構系列：哈希表？這涉及的是“加密/區塊鏈”等技術的核心</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html alt=「數據結構」Hash表 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/617a6d43032e4efbac6b996c9bb5ab11 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0e2547f1.html title=「數據結構」Hash表>「數據結構」Hash表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html alt=備戰秋招——算法與數據結構（5） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/ab6859411bd8435bb2616d6fef468556 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b37254e1.html title=備戰秋招——算法與數據結構（5）>備戰秋招——算法與數據結構（5）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html alt=懂了數據結構框架思維，一切算法不過是紙老虎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ad2c8a60d9634e0aa36b5d8a664de355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f605b4b8.html title=懂了數據結構框架思維，一切算法不過是紙老虎>懂了數據結構框架思維，一切算法不過是紙老虎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html alt=數據結構一(哈希表)想進大廠的必備知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/86ad7a2f62cc48f98bbe53b42ca4bf9a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e03941dc.html title=數據結構一(哈希表)想進大廠的必備知識點>數據結構一(哈希表)想進大廠的必備知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html alt="數據結構中的 Hash 表" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/dfic-imagehandler/0e43812c-6f05-4cf6-af7e-18011d0a316a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/385a3c55.html title="數據結構中的 Hash 表">數據結構中的 Hash 表</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html alt=常用數據結構之二叉樹的特性以及適用場景總結 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/d8521175c2eb416e97ccf5747b8a6033 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/629e95d1.html title=常用數據結構之二叉樹的特性以及適用場景總結>常用數據結構之二叉樹的特性以及適用場景總結</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html alt=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c9a031d4534f4363963c1ad02aac937f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/13fb0203.html title=數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？>數據結構23｜二叉樹基礎上：什麼樣的二叉樹適合用數組來存儲？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html alt=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/02b77c3c1c434606997aa740529d8b17 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a85e2fa9.html title=數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎>數據結構系列：面試常問的二叉樹的遍歷和基本應用，不進來看看嗎</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html alt=數據結構：二叉樹及存儲結構，學生時代的難點嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0e88a207beca45d08824aaf262458b25 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/0f931f71.html title=數據結構：二叉樹及存儲結構，學生時代的難點嗎？>數據結構：二叉樹及存儲結構，學生時代的難點嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html alt=「算法與數據結構」二叉樹之美 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/73093d13178e4fa1a45d2babe9d1a54b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f662790b.html title=「算法與數據結構」二叉樹之美>「算法與數據結構」二叉樹之美</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html alt=數據結構和算法之二叉樹 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/e887f7fd870a4d7ea59cbbfdc132450f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b53da776.html title=數據結構和算法之二叉樹>數據結構和算法之二叉樹</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html alt=C語言：數據結構-歸併排序 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/539294f811964720923157c1a6eba72c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/059fc3b0.html title=C語言：數據結構-歸併排序>C語言：數據結構-歸併排序</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html alt=一文看懂編程中的基本數據結構與算法思想 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/44d2fdc7ecf6447a860128c60e5cfe5b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b67e3584.html title=一文看懂編程中的基本數據結構與算法思想>一文看懂編程中的基本數據結構與算法思想</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6d2b71b7.html alt=結構與算法：遞歸機制、排序規則、查找算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b599d6f709aa44d7b77f190a4d81dcdd style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6d2b71b7.html title=結構與算法：遞歸機制、排序規則、查找算法>結構與算法：遞歸機制、排序規則、查找算法</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>