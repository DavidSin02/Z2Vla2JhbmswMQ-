<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>使用springcloud gateway搭建網關（分流，限流，熔斷） | 极客快訊</title><meta property="og:title" content="使用springcloud gateway搭建網關（分流，限流，熔斷） - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/5dedf0d033b54111b51594e9169ef331"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/483ff7c0.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/483ff7c0.html><meta property="article:published_time" content="2020-11-14T21:03:15+08:00"><meta property="article:modified_time" content="2020-11-14T21:03:15+08:00"><meta name=Keywords content><meta name=description content="使用springcloud gateway搭建網關（分流，限流，熔斷）"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/483ff7c0.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>使用springcloud gateway搭建網關（分流，限流，熔斷）</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><h1><strong>Spring Cloud Gateway</strong></h1><p>Spring Cloud Gateway 是 Spring Cloud 的一個全新項目，該項目是基於 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等技術開發的網關，它旨在為微服務架構提供一種簡單有效的統一的 API 路由管理方式。</p><p>Spring Cloud Gateway 作為 Spring Cloud 生態系統中的網關，目標是替代 Netflix Zuul，其不僅提供統一的路由方式，並且基於 Filter 鏈的方式提供了網關基本的功能，例如：安全，監控/指標，和限流。</p><p>如果想學習Java工程化、高性能及分佈式、深入淺出。微服務、Spring，MyBatis，Netty源碼分析的朋友可以加我的Java高級交流：854630135，群裡有阿里大牛直播講解技術，以及Java大型互聯網技術的視頻免費分享給大家。</p><p>相關概念:</p><ul><li>Route（路由）：這是網關的基本構建塊。它由一個 ID，一個目標 URI，一組斷言和一組過濾器定義。如果斷言為真，則路由匹配。</li><li>Predicate（斷言）：這是一個 Java 8 的 Predicate。輸入類型是一個 ServerWebExchange。我們可以使用它來匹配來自 HTTP 請求的任何內容，例如 headers 或參數。</li><li>Filter（過濾器）：這是org.springframework.cloud.gateway.filter.GatewayFilter的實例，我們可以使用它修改請求和響應。</li></ul><p>工作流程：</p><div class=pgc-img><img alt="使用springcloud gateway搭建網關（分流，限流，熔斷）" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5dedf0d033b54111b51594e9169ef331><p class=pgc-img-caption></p></div><p>客戶端向 Spring Cloud Gateway 發出請求。如果 Gateway Handler Mapping 中找到與請求相匹配的路由，將其發送到 Gateway Web Handler。Handler 再通過指定的過濾器鏈來將請求發送到我們實際的服務執行業務邏輯，然後返回。 過濾器之間用虛線分開是因為過濾器可能會在發送代理請求之前（“pre”）或之後（“post”）執行業務邏輯。</p><p>Spring Cloud Gateway 的特徵：</p><p>如果想學習Java工程化、高性能及分佈式、深入淺出。微服務、Spring，MyBatis，Netty源碼分析的朋友可以加我的Java高級交流：854630135，群裡有阿里大牛直播講解技術，以及Java大型互聯網技術的視頻免費分享給大家。</p><ul><li>基於 Spring Framework 5，Project Reactor 和 Spring Boot 2.0</li><li>動態路由</li><li>Predicates 和 Filters 作用於特定路由</li><li>集成 Hystrix 斷路器</li><li>集成 Spring Cloud DiscoveryClient</li><li>易於編寫的 Predicates 和 Filters</li><li>限流</li><li>路徑重寫</li></ul><h1><strong>快速上手</strong></h1><p>引入spring-boot 2.1.1.RELEASE ，springcloud的版本為 Greenwich.M3</p><pre> &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;  &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Greenwich.M3&lt;/spring-cloud.version&gt; &lt;/properties&gt;  &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-cloud.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;</pre><p>添加的依賴包如下</p><pre> &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis-reactive&lt;/artifactId&gt; &lt;/dependency&gt;</pre><p>注意springcloud gateway使用的web框架為webflux，和springMVC不兼容。引入的限流組件是hystrix。redis底層不再使用jedis，而是lettuce。</p><h1><strong>路由斷言</strong></h1><p>接下來就是配置了，可以使用java代碼硬編碼配置路由過濾器，也可以使用yml配置文件配置。下面我們首先介紹配置文件配置方式</p><p>application.yml</p><pre>server.port: 8082spring: application: name: gateway cloud: gateway: routes: - id: path_route uri: http://localhost:8000 order: 0 predicates: - Path=/foo/** filters: - StripPrefix=1</pre><p>上面給出了一個根據請求路徑來匹配目標uri的例子，如果請求的路徑為/foo/bar，則目標uri為 http://localhost:8000/bar。如果上面例子中沒有加一個StripPrefix=1過濾器，則目標uri 為http://localhost:8000/foo/bar，StripPrefix過濾器是去掉一個路徑。</p><p>其他的路由斷言和過濾器使用方法請查看官網</p><p>https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RC2/single/spring-cloud-gateway.html#gateway-how-it-works</p><p>接下來我們來看一下設計一個網關應該需要的一些功能</p><h1><strong>修改接口返回報文</strong></h1><p>因為網關路由的接口返回報文格式各異，並且網關也有有一些限流、認證、熔斷降級的返回報文，為了統一這些報文的返回格式，網關必須要對接口的返回報文進行修改，過濾器代碼如下：</p><pre>package org.gateway.filter.global;import java.nio.charset.Charset;import org.gateway.response.Response;import org.reactivestreams.Publisher;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.Ordered;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.core.io.buffer.DataBufferFactory;import org.springframework.core.io.buffer.DataBufferUtils;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.http.server.reactive.ServerHttpResponseDecorator;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import com.alibaba.fastjson.JSON;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;@Componentpublic class WrapperResponseFilter implements GlobalFilter, Ordered { @Override public int getOrder() { // -1 is response write filter, must be called before that return -2; } @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { ServerHttpResponse originalResponse = exchange.getResponse(); DataBufferFactory bufferFactory = originalResponse.bufferFactory(); ServerHttpResponseDecorator decoratedResponse = new ServerHttpResponseDecorator(originalResponse) { @Override public Mono&lt;Void&gt; writeWith(Publisher&lt;? extends DataBuffer&gt; body) { if (body instanceof Flux) { Flux&lt;? extends DataBuffer&gt; fluxBody = (Flux&lt;? extends DataBuffer&gt;) body; return super.writeWith(fluxBody.map(dataBuffer -&gt; { // probably should reuse buffers byte[] content = new byte[dataBuffer.readableByteCount()]; dataBuffer.read(content); // 釋放掉內存 DataBufferUtils.release(dataBuffer); String rs = new String(content, Charset.forName("UTF-8")); Response response = new Response(); response.setCode("1"); response.setMessage("請求成功"); response.setData(rs);  byte[] newRs = JSON.toJSONString(response).getBytes(Charset.forName("UTF-8")); originalResponse.getHeaders().setContentLength(newRs.length);//如果不重新設置長度則收不到消息。 return bufferFactory.wrap(newRs); })); } // if body is not a flux. never got there. return super.writeWith(body); } }; // replace response with decorator return chain.filter(exchange.mutate().response(decoratedResponse).build()); }}</pre><p>需要注意的是order需要小於-1，需要先於NettyWriteResponseFilter過濾器執行。</p><p>有了一個這樣的過濾器，我們就可以統一返回報文格式了。</p><h1><strong>認證</strong></h1><p>以下提供一個簡單的認證過濾器</p><pre>package org.gateway.filter.global;import java.nio.charset.StandardCharsets;import org.gateway.response.Response;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.http.HttpStatus;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import com.alibaba.fastjson.JSON;import reactor.core.publisher.Mono;@Componentpublic class AuthFilter implements GlobalFilter{ @Override public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) { String token = exchange.getRequest().getHeaders().getFirst("token"); if ("token".equals(token)) { return chain.filter(exchange); } ServerHttpResponse response = exchange.getResponse(); Response data = new Response(); data.setCode("401"); data.setMessage("非法請求"); byte[] datas = JSON.toJSONString(data).getBytes(StandardCharsets.UTF_8); DataBuffer buffer = response.bufferFactory().wrap(datas); response.setStatusCode(HttpStatus.UNAUTHORIZED); response.getHeaders().add("Content-Type", "application/json;charset=UTF-8"); return response.writeWith(Mono.just(buffer)); }}</pre><h1><strong>限流</strong></h1><p>springcloud gateway 為我們提供了限流過濾器RequestRateLimiterGatewayFilterFactory，和限流的實現類RedisRateLimiter使用令牌桶限流。但是官方的不一定滿足我們的需求，所以我們重新寫一個過濾器（基本和官方一致），只是將官方的返回報文改了。</p><pre>package org.gateway.limiter;import java.nio.charset.StandardCharsets;import java.util.Map;import org.gateway.response.Response;import org.springframework.cloud.gateway.filter.GatewayFilter;import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.cloud.gateway.filter.ratelimit.RateLimiter;import org.springframework.cloud.gateway.route.Route;import org.springframework.cloud.gateway.support.ServerWebExchangeUtils;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.http.HttpStatus;import org.springframework.http.server.reactive.ServerHttpResponse;import com.alibaba.fastjson.JSON;import reactor.core.publisher.Mono;/** * User Request Rate Limiter filter. See https://stripe.com/blog/rate-limiters and */public class RateLimiterGatewayFilterFactory extends AbstractGatewayFilterFactory&lt;RateLimiterGatewayFilterFactory.Config&gt; { public static final String KEY_RESOLVER_KEY = "keyResolver"; private final RateLimiter defaultRateLimiter; private final KeyResolver defaultKeyResolver; public RateLimiterGatewayFilterFactory(RateLimiter defaultRateLimiter, KeyResolver defaultKeyResolver) { super(Config.class); this.defaultRateLimiter = defaultRateLimiter; this.defaultKeyResolver = defaultKeyResolver; } public KeyResolver getDefaultKeyResolver() { return defaultKeyResolver; } public RateLimiter getDefaultRateLimiter() { return defaultRateLimiter; } @SuppressWarnings("unchecked") @Override public GatewayFilter apply(Config config) { KeyResolver resolver = (config.keyResolver == null) ? defaultKeyResolver : config.keyResolver; RateLimiter&lt;Object&gt; limiter = (config.rateLimiter == null) ? defaultRateLimiter : config.rateLimiter; return (exchange, chain) -&gt; { Route route = exchange.getAttribute(ServerWebExchangeUtils.GATEWAY_ROUTE_ATTR); return resolver.resolve(exchange).flatMap(key -&gt; // TODO: if key is empty? limiter.isAllowed(route.getId(), key).flatMap(response -&gt; { for (Map.Entry&lt;String, String&gt; header : response.getHeaders().entrySet()) { exchange.getResponse().getHeaders().add(header.getKey(), header.getValue()); } if (response.isAllowed()) { return chain.filter(exchange); } ServerHttpResponse rs = exchange.getResponse(); Response data = new Response(); data.setCode("101"); data.setMessage("訪問過快"); byte[] datas = JSON.toJSONString(data).getBytes(StandardCharsets.UTF_8); DataBuffer buffer = rs.bufferFactory().wrap(datas); rs.setStatusCode(HttpStatus.UNAUTHORIZED); rs.getHeaders().add("Content-Type", "application/json;charset=UTF-8"); return rs.writeWith(Mono.just(buffer)); })); }; } public static class Config { private KeyResolver keyResolver; private RateLimiter rateLimiter; private HttpStatus statusCode = HttpStatus.TOO_MANY_REQUESTS; public KeyResolver getKeyResolver() { return keyResolver; } public Config setKeyResolver(KeyResolver keyResolver) { this.keyResolver = keyResolver; return this; } public RateLimiter getRateLimiter() { return rateLimiter; } public Config setRateLimiter(RateLimiter rateLimiter) { this.rateLimiter = rateLimiter; return this; } public HttpStatus getStatusCode() { return statusCode; } public Config setStatusCode(HttpStatus statusCode) { this.statusCode = statusCode; return this; } }}</pre><p>然後限流必須要有一個key，根據什麼來進行限流，ip，接口，或者用戶來進行限流，所以我們自定義一個KeyResolver</p><pre>package org.gateway.limiter;import org.springframework.cloud.gateway.filter.ratelimit.KeyResolver;import org.springframework.web.server.ServerWebExchange;import com.alibaba.fastjson.JSON;import reactor.core.publisher.Mono;public class CustomKeyResolver implements KeyResolver { public static final String BEAN_NAME = "customKeyResolver"; @Override public Mono&lt;String&gt; resolve(ServerWebExchange exchange) { return Mono.just(getKey(exchange)); } /** *  * @param exchange * @return */ private String getKey(ServerWebExchange exchange) {  LimitKey limitKey = new LimitKey();  limitKey.setApi(exchange.getRequest().getPath().toString()); limitKey.setBiz(exchange.getRequest().getQueryParams().getFirst("biz")); return JSON.toJSONString(limitKey); }}</pre><p>如果想學習Java工程化、高性能及分佈式、深入淺出。微服務、Spring，MyBatis，Netty源碼分析的朋友可以加我的Java高級交流：854630135，群裡有阿里大牛直播講解技術，以及Java大型互聯網技術的視頻免費分享給大家。</p><p>最後RedisRateLimiter我們也需要重寫，因為不支持多級限流，原生的只會判斷一個key。代碼如下：</p><pre> /** * This uses a basic token bucket algorithm and relies on the fact that Redis scripts * execute atomically. No other operations can run between fetching the count and * writing the new count. */ @Override public Mono&lt;Response&gt; isAllowed(String routeId, String id) { if (!this.initialized.get()) { throw new IllegalStateException("RedisRateLimiter is not initialized"); } LimitConfig limitConfig = getLimitConfig(routeId);  if (limitConfig == null || limitConfig.getTokenConfig().size()==0) { return Mono.just(new Response(true,null)); } Map&lt;String, Config&gt; conf = limitConfig.getTokenConfig();  LimitKey limitKey = JSON.parseObject(id, LimitKey.class); //api限流 String api = limitKey.getApi(); Config apiConf = conf.get(api); //業務方限流 String biz = limitKey.getBiz(); Config bizConf = conf.get(biz);  if (apiConf!=null) { return isSingleAllow(api,routeId,apiConf).flatMap(res -&gt; { if (res.isAllowed()) { if(bizConf!=null) { return isSingleAllow(biz, routeId, bizConf); }else { return Mono.just(new Response(true,new HashMap&lt;&gt;())); } }else { return Mono.just(res); } } ); }else { if (bizConf!=null) { return isSingleAllow(biz, routeId, bizConf); }else { return Mono.just(new Response(true,new HashMap&lt;&gt;())); } } } /** * 單級限流 * @param api * @param routeId * @param apiConf * @return  */ private Mono&lt;Response&gt; isSingleAllow(String key, String routeId, Config config) { // How many requests per second do you want a user to be allowed to do? int replenishRate = config.getReplenishRate(); // How much bursting do you want to allow? int burstCapacity = config.getBurstCapacity(); try { List&lt;String&gt; keys = getKeys(routeId+"$"+key); // The arguments to the LUA script. time() returns unixtime in seconds. List&lt;String&gt; scriptArgs = Arrays.asList(replenishRate + "", burstCapacity + "", Instant.now().getEpochSecond() + "", "1"); // allowed, tokens_left = redis.eval(SCRIPT, keys, args) Flux&lt;List&lt;Long&gt;&gt; flux = this.redisTemplate.execute(this.script, keys, scriptArgs); // .log("redisratelimiter", Level.FINER); return flux.onErrorResume(throwable -&gt; Flux.just(Arrays.asList(1L, -1L))) .reduce(new ArrayList&lt;Long&gt;(), (longs, l) -&gt; { longs.addAll(l); return longs; }) .map(results -&gt; { boolean allowed = results.get(0) == 1L; Long tokensLeft = results.get(1); Response response = new Response(allowed, getHeaders(config, tokensLeft)); if (log.isDebugEnabled()) { log.debug("response: " + response); } return response; }); } catch (Exception e) { /* * We don't want a hard dependency on Redis to allow traffic. Make sure to set * an alert so you know if this is happening too much. Stripe's observed * failure rate is 0.01%. */ log.error("Error determining if user allowed from redis", e); } return Mono.just(new Response(true, getHeaders(config, -1L))); } private LimitConfig getLimitConfig(String routeId) { Map&lt;String, LimitConfig&gt; map = new HashMap&lt;&gt;(); LimitConfig limitConfig = new LimitConfig(); limitConfig.setRouteId("rateLimit_route"); Map&lt;String, Config&gt; tokenMap = new HashMap&lt;&gt;(); Config apiConfig = new Config(); apiConfig.setBurstCapacity(5); apiConfig.setReplenishRate(5);  Config bizConfig = new Config(); bizConfig.setBurstCapacity(1); bizConfig.setReplenishRate(1);  tokenMap.put("/hello/rateLimit", apiConfig); tokenMap.put("jieyin", bizConfig); limitConfig.setTokenConfig(tokenMap); map.put("rateLimit_route", limitConfig); return limitConfig; }</pre><p>如上的代碼是寫死的，但是我們可以根據我們的業務需求設計一個自定義key，自定義令牌桶容量和速率的限流規則。</p><p>bean配置和yml配置如下</p><pre> @Bean @Primary public CustomRedisRateLimiter customRedisRateLimiter(ReactiveRedisTemplate&lt;String, String&gt; redisTemplate, @Qualifier(RedisRateLimiter.REDIS_SCRIPT_NAME) RedisScript&lt;List&lt;Long&gt;&gt; redisScript, Validator validator) { return new CustomRedisRateLimiter(redisTemplate, redisScript, validator); }  @Bean public RateLimiterGatewayFilterFactory rateLimiterGatewayFilterFactory(CustomRedisRateLimiter customRedisRateLimiter, CustomKeyResolver customKeyResolver) { return new RateLimiterGatewayFilterFactory(customRedisRateLimiter, customKeyResolver); }</pre><p>如果想學習Java工程化、高性能及分佈式、深入淺出。微服務、Spring，MyBatis，Netty源碼分析的朋友可以加我的Java高級交流：854630135，群裡有阿里大牛直播講解技術，以及Java大型互聯網技術的視頻免費分享給大家。</p><pre>server.port: 8082spring: application: name: gateway redis: host: localhost port: 6379 password: 123456 cloud: gateway: routes: - id: rateLimit_route uri: http://localhost:8000 order: 0 predicates: - Path=/foo/** filters: - StripPrefix=1 - name: RateLimiter</pre><h1><strong>熔斷</strong></h1><p>當下遊接口負載很大，或者接口不通等其他原因導致超時，如果接口不熔斷的話將會影響到下游接口得不到喘息，網關也會因為超時連接一直掛起，很可能因為一個子系統的問題導致整個系統的雪崩。所以我們的網關需要設計熔斷，當因為熔斷器打開時，網關將返回一個降級的應答。</p><p>熔斷配置如下：</p><pre>server.port: 8082spring: application: name: gateway redis: host: localhost port: 6379 password: 123456 cloud: gateway: routes: - id: rateLimit_route uri: http://localhost:8000 order: 0 predicates: - Path=/foo/** filters: - StripPrefix=1 - name: RateLimiter - name: Hystrix args: name: fallbackcmd fallbackUri: forward:/fallback</pre><p>hystrix.command.fallbackcmd.execution.isolation.thread.timeoutInMilliseconds: 5000</p><pre>package org.gateway.controller;import org.gateway.response.Response;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class FallbackController { @GetMapping("/fallback") public Response fallback() { Response response = new Response(); response.setCode("100"); response.setMessage("服務暫時不可用"); return response; }}</pre><p>注意需要設置commandKey的超時時間。其他的hystrix配置請訪問Hystrix wiki.</p><h1><strong>動態配置路由和過濾器</strong></h1><p>最後我們來看一下如何動態配置路由和過濾器。</p><p>定義路由實體</p><pre>/** * Gateway的路由定義模型 */public class GatewayRouteDefinition { /** * 路由的Id */ private String id; /** * 路由斷言集合配置 */ private List&lt;GatewayPredicateDefinition&gt; predicates = new ArrayList&lt;&gt;(); /** * 路由過濾器集合配置 */ private List&lt;GatewayFilterDefinition&gt; filters = new ArrayList&lt;&gt;(); /** * 路由規則轉發的目標uri */ private String uri; /** * 路由執行的順序 */ private int order = 0;}</pre><p>路由斷言實體</p><p>如果想學習Java工程化、高性能及分佈式、深入淺出。微服務、Spring，MyBatis，Netty源碼分析的朋友可以加我的Java高級交流：854630135，群裡有阿里大牛直播講解技術，以及Java大型互聯網技術的視頻免費分享給大家。</p><pre>/** * 路由斷言定義模型 */public class GatewayPredicateDefinition { /** * 斷言對應的Name */ private String name; /** * 配置的斷言規則 */ private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;();}</pre><p>過濾器實體</p><pre>/** * 過濾器定義模型 */public class GatewayFilterDefinition { /** * Filter Name */ private String name; /** * 對應的路由規則 */ private Map&lt;String, String&gt; args = new LinkedHashMap&lt;&gt;();}</pre><p>路由增刪改controller</p><pre>package org.gateway.controller;import java.net.URI;import java.util.ArrayList;import java.util.Arrays;import java.util.HashMap;import java.util.List;import java.util.Map;import org.gateway.model.GatewayFilterDefinition;import org.gateway.model.GatewayPredicateDefinition;import org.gateway.model.GatewayRouteDefinition;import org.gateway.route.DynamicRouteServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.gateway.filter.FilterDefinition;import org.springframework.cloud.gateway.handler.predicate.PredicateDefinition;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.util.CollectionUtils;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.util.UriComponentsBuilder;@RestController@RequestMapping("/route")public class RouteController { @Autowired private DynamicRouteServiceImpl dynamicRouteService; /** * 增加路由 * @param gwdefinition * @return */ @PostMapping("/add") public String add(@RequestBody GatewayRouteDefinition gwdefinition) { try { RouteDefinition definition = assembleRouteDefinition(gwdefinition); return this.dynamicRouteService.add(definition); } catch (Exception e) { e.printStackTrace(); } return "succss"; } @GetMapping("/delete/{id}") public String delete(@PathVariable String id) { return this.dynamicRouteService.delete(id); } @PostMapping("/update") public String update(@RequestBody GatewayRouteDefinition gwdefinition) { RouteDefinition definition = assembleRouteDefinition(gwdefinition); return this.dynamicRouteService.update(definition); } private RouteDefinition assembleRouteDefinition(GatewayRouteDefinition gwdefinition) { RouteDefinition definition = new RouteDefinition(); List&lt;PredicateDefinition&gt; pdList=new ArrayList&lt;&gt;(); definition.setId(gwdefinition.getId()); List&lt;GatewayPredicateDefinition&gt; gatewayPredicateDefinitionList=gwdefinition.getPredicates(); for (GatewayPredicateDefinition gpDefinition: gatewayPredicateDefinitionList) { PredicateDefinition predicate = new PredicateDefinition(); predicate.setArgs(gpDefinition.getArgs()); predicate.setName(gpDefinition.getName()); pdList.add(predicate); }  List&lt;GatewayFilterDefinition&gt; gatewayFilterDefinitions = gwdefinition.getFilters(); List&lt;FilterDefinition&gt; filterList = new ArrayList&lt;&gt;(); if (!CollectionUtils.isEmpty(gatewayFilterDefinitions)) { for (GatewayFilterDefinition gatewayFilterDefinition : gatewayFilterDefinitions) { FilterDefinition filterDefinition = new FilterDefinition(); filterDefinition.setName(gatewayFilterDefinition.getName()); filterDefinition.setArgs(gatewayFilterDefinition.getArgs()); filterList.add(filterDefinition); } } definition.setPredicates(pdList); definition.setFilters(filterList); URI uri = UriComponentsBuilder.fromHttpUrl(gwdefinition.getUri()).build().toUri(); definition.setUri(uri); return definition; }}</pre><p>動態路由service</p><pre>package org.gateway.route;import java.net.URI;import java.util.Arrays;import java.util.HashMap;import java.util.Map;import org.gateway.model.GatewayPredicateDefinition;import org.gateway.model.GatewayRouteDefinition;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.gateway.event.RefreshRoutesEvent;import org.springframework.cloud.gateway.handler.predicate.PredicateDefinition;import org.springframework.cloud.gateway.route.RouteDefinition;import org.springframework.cloud.gateway.route.RouteDefinitionWriter;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.stereotype.Service;import org.springframework.web.util.UriComponentsBuilder;import com.alibaba.fastjson.JSON;import reactor.core.publisher.Mono;@Servicepublic class DynamicRouteServiceImpl implements ApplicationEventPublisherAware { @Autowired private RouteDefinitionWriter routeDefinitionWriter; private ApplicationEventPublisher publisher; /** * 增加路由 * @param definition * @return */ public String add(RouteDefinition definition) { routeDefinitionWriter.save(Mono.just(definition)).subscribe(); this.publisher.publishEvent(new RefreshRoutesEvent(this)); return "success"; } /** * 更新路由 * @param definition * @return */ public String update(RouteDefinition definition) { try { this.routeDefinitionWriter.delete(Mono.just(definition.getId())); } catch (Exception e) { return "update fail,not find route routeId: "+definition.getId(); } try { routeDefinitionWriter.save(Mono.just(definition)).subscribe(); this.publisher.publishEvent(new RefreshRoutesEvent(this)); return "success"; } catch (Exception e) { return "update route fail"; } } /** * 刪除路由 * @param id * @return */ public String delete(String id) { try { this.routeDefinitionWriter.delete(Mono.just(id)); return "delete success"; } catch (Exception e) { e.printStackTrace(); return "delete fail"; } } @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) { this.publisher = applicationEventPublisher; }}</pre><pre> 上面 routeDefinitionWriter的實現默認是InMemoryRouteDefinitionRepository，將路由存在內存中，我們可以自己實現一個將路由存在redis中的repository。this.publisher.publishEvent(new RefreshRoutesEvent(this));則會將CachingRouteLocator中的路由緩存清空。以上只是springcloud gateway支持的一小部分功能。</pre><p>如果想學習Java工程化、高性能及分佈式、深入淺出。微服務、Spring，MyBatis，Netty源碼分析的朋友可以加我的Java高級交流：854630135，群裡有阿里大牛直播講解技術，以及Java大型互聯網技術的視頻免費分享給大家。</p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>限流</a></li><li><a>springcloud</a></li><li><a>gateway</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/3998ae89.html alt=服務治理最佳實踐：如何依據參數值進行服務路由、鑑權、限流？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/3f6fb254f0cc4ba390695e1d561d4a5c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3998ae89.html title=服務治理最佳實踐：如何依據參數值進行服務路由、鑑權、限流？>服務治理最佳實踐：如何依據參數值進行服務路由、鑑權、限流？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4abab263.html alt=詳解高併發，億級併發流量控制，分佈式場景下的系統限流實戰 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/2ce419d547834633a15d0be9cd7b4be2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4abab263.html title=詳解高併發，億級併發流量控制，分佈式場景下的系統限流實戰>詳解高併發，億級併發流量控制，分佈式場景下的系統限流實戰</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/16e9e712.html alt=高併發之API接口，分佈式，防刷限流，如何做？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/72ef0f380abf4c6693d26afc863a1782 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/16e9e712.html title=高併發之API接口，分佈式，防刷限流，如何做？>高併發之API接口，分佈式，防刷限流，如何做？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/e9806fac.html alt="程序員都需要的乾貨之springcloud 高效率本地加Redis雙級緩存" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7cd3e731c0e64105beb94beeaf67f702 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/e9806fac.html title="程序員都需要的乾貨之springcloud 高效率本地加Redis雙級緩存">程序員都需要的乾貨之springcloud 高效率本地加Redis雙級緩存</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/25895d7e.html alt=5.穩壓二極管的特性及電路應用（限流電阻計算） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/dfic-imagehandler/fc5ebf22-a2ec-4faa-93c8-2455b5aa1964 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/25895d7e.html title=5.穩壓二極管的特性及電路應用（限流電阻計算）>5.穩壓二極管的特性及電路應用（限流電阻計算）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/127d2213.html alt=推薦｜女主無限流小說，尋一線生機，拯救世界還是拯救自己？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/6174224cb0a34043afe6ebc4a6745da7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/127d2213.html title=推薦｜女主無限流小說，尋一線生機，拯救世界還是拯救自己？>推薦｜女主無限流小說，尋一線生機，拯救世界還是拯救自己？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/97b90b94.html alt=無限流類小說，女主超颯的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/455108ffa60e49f59188faeb26efb6a3 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/97b90b94.html title=無限流類小說，女主超颯的>無限流類小說，女主超颯的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/84c5ee7.html alt=耽美無限流小說：世界燦爛盛大，歡迎回家 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/83c02a115cb54710a8aebd5de3812af7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/84c5ee7.html title=耽美無限流小說：世界燦爛盛大，歡迎回家>耽美無限流小說：世界燦爛盛大，歡迎回家</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c765e71.html alt=注意！明天早高峰9號線這兩個站計劃限流 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/RwcbkHmCRCAwUn style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c765e71.html title=注意！明天早高峰9號線這兩個站計劃限流>注意！明天早高峰9號線這兩個站計劃限流</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5dd51fa.html alt=「儀表最新專利」一種熱式燃氣表的限流閥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1533627491309c3cd4116ac style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5dd51fa.html title=「儀表最新專利」一種熱式燃氣表的限流閥>「儀表最新專利」一種熱式燃氣表的限流閥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7a2df8b.html alt="北京植物園取消桃花節活動 適時啟動限流管控措施" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7a2df8b.html title="北京植物園取消桃花節活動 適時啟動限流管控措施">北京植物園取消桃花節活動 適時啟動限流管控措施</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3ef2454.html alt=北京植物園實施限流管控，取消今春桃花節活動 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3ef2454.html title=北京植物園實施限流管控，取消今春桃花節活動>北京植物園實施限流管控，取消今春桃花節活動</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/852ed5b.html alt=【純愛】無限流爽文《在靈異遊戲裡生崽崽》，請忽略小說的名字。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8dc1e71bed18419f994960b3406f90c1 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/852ed5b.html title=【純愛】無限流爽文《在靈異遊戲裡生崽崽》，請忽略小說的名字。>【純愛】無限流爽文《在靈異遊戲裡生崽崽》，請忽略小說的名字。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d9a72c3.html alt=穩壓管穩壓電路參數選擇，限流電阻如何選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/5cc827edd0324f43a63c959d45c5136f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d9a72c3.html title=穩壓管穩壓電路參數選擇，限流電阻如何選擇>穩壓管穩壓電路參數選擇，限流電阻如何選擇</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>