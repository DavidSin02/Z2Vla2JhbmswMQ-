<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ | 极客快訊</title><meta property="og:title" content="熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/8e306d12189741e4a3b8a74c64dec558"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48c90bcc.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48c90bcc.html><meta property="article:published_time" content="2020-11-14T21:06:36+08:00"><meta property="article:modified_time" content="2020-11-14T21:06:36+08:00"><meta name=Keywords content><meta name=description content="熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/48c90bcc.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><p>我們知道，在一臺計算機中，我們可以同時打開許多軟件，比如同時瀏覽網頁、聽音樂、打字等等，看似非常正常。但仔細想想，為什麼計算機可以做到這麼多軟件同時運行呢？這就涉及到計算機中的兩個重要概念：多進程和多線程了。（PS：<strong>萬字長文，講得很詳細，建議先收藏再好好看！</strong>）</p><p>同樣，在編寫爬蟲程序的時候，為了提高爬取效率，我們可能想同時運行多個爬蟲任務。這裡同樣需要涉及多進程和多線程的知識。</p><p>本文，我們就先來了解一下多線程的基本原理，以及在 Python 中如何實現多線程。</p><h2 class=pgc-h-arrow-right>1. 全局解釋器鎖</h2><blockquote><p><strong>全局解釋器鎖</strong> （英語：Global Interpreter Lock，縮寫 <strong>GIL</strong>）</p><p>是 <strong>計算機程序設計語言解釋器</strong> 用於 <strong>同步線程</strong> 的一種機制，它使得任何時刻僅有 <strong>一個線程</strong> 在執行，即便在 <strong>多核心處理器</strong> 上，使用 <strong>GIL</strong> 的解釋器也只允許同一時間執行一個線程。常見的使用 <strong>GIL</strong> 的解釋器有 <strong>CPython</strong> 與 <strong>Ruby MRI</strong>。</p></blockquote><p>如果，你對上面的不理解，也沒有問題。通俗的解釋就是：你電腦是 <strong>一核或者多核</strong> ，還是你的代碼寫了了多個線程，但因為 <strong>GIL</strong> 鎖的存在你也就只能運行一個線程，無法同時運行多個線程。</p><p>接下來，我們來用個圖片來解釋一下：</p><div class=pgc-img><img alt=熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8e306d12189741e4a3b8a74c64dec558><p class=pgc-img-caption></p></div><p>比如圖中，假如你開了兩個線程（<strong>Py thread1</strong> 、<strong>Py tread2</strong>），</p><ol start=1><li>當我們線程一（<strong>Py thread1</strong>）開始執行時，這個線程會去我們的解釋器中申請到一個鎖。也就是我們的 <strong>GIL</strong> 鎖；</li><li>然後，解釋器接收到一個請求的時候呢，它就會到我們的 <strong>OS</strong> 裡面，申請我們的系統線程；</li><li>系統統一你的線程執行的時候，就會在你的 <strong>CPU</strong> 上面執行。（假設你現在是四核CPU）；</li><li>而我們的另一個線程二（<strong>py thread2</strong>）也在同步運行。</li><li>而線程二在向這個解釋器申請 <strong>GIL</strong> 的時候線程二會卡在這裡（Python 解釋器），因為它的 <strong>GIL</strong> 鎖已經被線程一給拿走了（也就是說：他要進去執行，必須拿到這把鎖）；</li><li>線程二要運行的話，就必須等我們的線程一運行完成之後（也就是把我們的 <strong>GIL</strong> 釋放之後（圖片中的第5步）線程二才能拿到這把鎖）；</li><li>當線程二拿到這把鎖之後就和線程一的運行過程一樣。</li></ol><pre><code>① Create &gt; ② GIL &gt; ③ 申請原生線程(OS) &gt; ④ CPU 執行（如果有其他線程，都會卡在 Python 解釋器的外邊）</code></pre><h6 class=pgc-h-arrow-right>這個鎖其實是 Python 之父想一勞永逸解決線程的安全問題（也就是禁止多線程同時運行）</h6><h2 class=pgc-h-arrow-right>2. 多線程的含義</h2><p>說起多線程，就不得不先說什麼是線程。然而想要弄明白什麼是線程，又不得不先說什麼是進程。</p><p>進程我們可以理解為是一個可以獨立運行的程序單位。</p><p>比如：</p><ol start=1><li>打開一個瀏覽器，這就開啟了一個瀏覽器進程；</li><li>打開一個文本編輯器，這就開啟了一個文本編輯器進程。</li></ol><p>但一個進程中是可以同時處理很多事情的。</p><p>比如：在瀏覽器中，我們可以在多個選項卡中打開多個頁面。</p><ul><li>有的頁面在播放音樂，</li><li>有的頁面在播放視頻，</li><li>有的網頁在播放動畫，它們可以同時運行，互不干擾。</li></ul><p><strong>為什麼能同時做到同時運行這麼多的任務呢？</strong></p><p>這裡就需要引出線程的概念了，其實這一個個任務，實際上就對應著一個個線程的執行。</p><p><strong>而進程呢？</strong></p><p>它就是線程的集合，進程就是由一個或多個線程構成的，線程是操作系統進行<strong>運算調度的最小單位</strong>，是進程中的一個最小運行單元。</p><p>比如：</p><p>上面所說的瀏覽器進程，其中的播放音樂就是一個線程，播放視頻也是一個線程，當然其中還有很多其他的線程在同時運行，這些線程的<strong>併發或並行</strong>執行最後使得整個瀏覽器可以同時運行這麼多的任務。</p><p>瞭解了線程的概念，多線程就很容易理解了，多線程就是一個進程中同時執行多個線程，前面所說的瀏覽器的情景就是典型的多線程執行。</p><h2 class=pgc-h-arrow-right>3. 併發和並行</h2><p>說到多進程和多線程，這裡就需要再講解兩個概念，那就是併發和並行。我們知道，一個程序在計算機中運行，其底層是處理器通過運行一條條的指令來實現的。</p><h3 class=pgc-h-arrow-right>3.1 併發</h3><p>英文叫作 concurrency。它是指同一時刻只能有一條指令執行，但是多個線程的對應的指令被快速輪換地執行。比如：</p><p>一個處理器，它先執行線程 A 的指令一段時間，再執行線程 B 的指令一段時間，再切回到線程 A 執行一段時間。</p><p>由於處理器執行指令的速度和切換的速度非常非常快，人完全感知不到計算機在這個過程中有多個線程切換上下文執行的操作，這就使得宏觀上看起來多個線程在同時運行。但微觀上只是這個處理器在連續不斷地在多個線程之間切換和執行，每個線程的執行一定會佔用這個處理器一個時間片段，同一時刻，其實只有一個線程在執行。</p><h3 class=pgc-h-arrow-right>3.2 並行</h3><p>英文叫作 parallel。它是指同一時刻，有<strong>多條指令在多個處理器上同時執行</strong>，並行必須要依賴於多個處理器。不論是從宏觀上還是微觀上，多個線程都是在同一時刻一起執行的。</p><p><strong>並行只能在多處理器系統中存在</strong>，如果我們的計算機處理器只有一個核，那就不可能實現並行。</p><p>而併發在單處理器和多處理器系統中都是可以存在的，因為僅靠一個核，就可以實現併發。</p><p><strong>舉個例子</strong></p><p>比如系統處理器需要同時運行多個線程。如果系統處理器只有一個核，那它只能通過併發的方式來運行這些線程。如果系統處理器有多個核，當一個核在執行一個線程時，另一個核可以執行另一個線程，這樣這兩個線程就實現了並行執行，當然其他的線程也可能和另外的線程處在同一個核上執行，它們之間就是併發執行。具體的執行方式，就取決於操作系統的調度了。</p><div class=pgc-img><img alt=熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/bc0967f804a746389880e1ff36125fc6><p class=pgc-img-caption></p></div><h2 class=pgc-h-arrow-right>4. 多線程適用場景</h2><p>在一個程序進程中，有一些操作是比較耗時或者需要等待的，比如等待數據庫的查詢結果的返回，等待網頁結果的響應。如果使用單線程，處理器必須要等到這些操作完成之後才能繼續往下執行其他操作，而這個線程在等待的過程中，處理器明顯是可以來執行其他的操作的。如果使用多線程，處理器就可以在某個線程等待的時候，去執行其他的線程，從而從整體上提高執行效率。</p><p>像上述場景，線程在執行過程中很多情況下是需要等待的。</p><p><strong>比如</strong></p><p>網絡爬蟲就是一個非常典型的例子，爬蟲在向服務器發起請求之後，有一段時間必須要等待服務器的響應返回，這種任務就屬於 IO 密集型任務。對於這種任務，如果我們啟用多線程，處理器就可以在某個線程等待的過程中去處理其他的任務，從而提高整體的爬取效率。</p><p>但並不是所有的任務都是 IO 密集型任務，還有一種任務叫作計算密集型任務，也可以稱之為 CPU 密集型任務。顧名思義，就是任務的運行一直需要處理器的參與。此時如果我們開啟了多線程，一個處理器從一個計算密集型任務切換到切換到另一個計算密集型任務上去，處理器依然不會停下來，始終會忙於計算，這樣並不會節省總體的時間，因為需要處理的任務的計算總量是不變的。如果線程數目過多，反而還會在線程切換的過程中多耗費一些時間，整體效率會變低。</p><p>所以，如果任務不全是計算密集型任務，我們可以使用多線程來提高程序整體的執行效率。尤其對於網絡爬蟲這種 IO 密集型任務來說，使用多線程會大大提高程序整體的爬取效率。</p><h2 class=pgc-h-arrow-right>5. Python 實現多線程</h2><p>在 Python 中，實現多線程的模塊叫作 threading，是 Python 自帶的模塊。下面我們來了解下使用 threading 實現多線程的方法。</p><p>在具體實現之前，我們先來測試一下多線程與當線程裸奔的速度對比，為了更加直觀，我這裡使用把每種線程代碼單獨寫出來並做對比：</p><p><strong>單線程裸奔：（這也是一個主線程（main thread））</strong></p><pre><code>import timedef start():    for i in range(1000000):        i += i    return# 不使用任何線程（裸著來）def main():    start_time = time.time()    for i in range(10):        start()    print(time.time()-start_time)if __name__ == '__main__':    main()</code></pre><p><strong>輸出：</strong></p><pre><code>6.553307056427002</code></pre><p><strong>注意：因為每臺電腦的性能不一樣，所運行的結果也相對不同（請按實際情況分析）</strong></p><hr><p><strong>接下來我們寫一個多線程</strong></p><blockquote><p>我們先創建個字典 <strong>(thread_name_time)</strong> 來存儲我們每個線程的名稱與對應的時間</p></blockquote><pre><code>import threading,timedef start():    for i in range(1000000):        i += i    return# # 不使用任何線程（裸著來）# def main():#     start_time = time.time()#     for i in range(10):#         start()#     print(time.time()-start_time)# if __name__ == '__main__':#     main()def main():    start_time = time.time()    thread_name_time = {}# 我們先創建個字典 (thread_name_time) 用來來存儲我們每個線程的名稱與對應的時間    for i in range(10):        # 也就是說，每個線程順序執行        thread = threading.Thread(target=start)# target=寫你要多線程運行的函數，不需要加括號        thread.start()# 上一行開啟了線程，這一行是開始運行（也就是開啟個 run）        thread_name_time[i] = thread # 添加數據到我們的字典當中，這裡為什麼要用i做key？這是因為這樣方便我們join    for i in range(10):        thread_name_time[i].join()    #     join() 等待線程執行完畢（也就是說卡在這裡，這個線程執行完才會執行下一步）    print(time.time()-start_time)if __name__ == '__main__':    main()</code></pre><p><strong>輸出</strong></p><pre><code>6.2037984102630615</code></pre><pre><code># 6.553307056427002 裸奔# 6.2037984102630615 單線程順序執行# 6.429047107696533 線程併發</code></pre><blockquote><p>我們可以看到，速度上的區別不大。</p><p>多線程併發不如單線程順序執行快</p><p>這是得不償失的</p><p>造成這種情況的原因就是 GIL</p><p>這裡是計算密集型，所以不適用</p></blockquote><p>在我們執行加減乘除或者圖像處理的時候，都是在從 <strong>CPU</strong> 上面執行才可以。Python 因為 GIL 存在，同一時期肯定只有一個線程在執行，這樣這樣就是造成我們開是個線程和一個線程沒有太大區別的原因。</p><p>而我們的網絡爬蟲大多時候是屬於 <strong>IO</strong> 密集與計算機密集</p><div class=pgc-img><img alt=熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/b9017a72bf5643c492b4db4a9fadbdba><p class=pgc-img-caption></p></div><blockquote><p>BIOS：B：Base、I：Input、O：Output、S：System</p></blockquote><p>也就是你電腦一開機的時候就會啟動。</p><p><strong>1. 計算密集型</strong></p><blockquote><p>在上面的時候，我們開啟了兩個線程，如果這兩個線程要同時執行，那同一時期 <strong>CPU</strong> 上只有一個線程在執行。</p><p>那從上圖可知，那這兩個線程就需要頻繁的在上下文切換。</p><p>Ps：我們這個綠色表示我們這個線程正在執行，紅色代表阻塞。</p><p>所以，我們可以明顯的觀察到，線程的上下文切換也是需要消耗資源的（時間-ms）不斷的歸還和拿取 <strong>GIL</strong> 等，切換上下文。明顯造成很大的資源浪費。</p></blockquote><p><strong>2. IO 密集型</strong></p><blockquote><p>我們現在假設，有個服務器程序（<strong>Socket</strong>）也就是我們新開的一個程序（也就是我們網絡爬蟲的最底層）開始爬取目標網頁了，我們那個網頁呢，有兩個線程同時運行，我們線程二已經請求成功開始運行了，也就是上圖的 （<strong>Thread 2</strong>）綠色一條路過去。</p><p>而我們的線程一（<strong>Thread 1</strong>）- <strong>Datagram</strong>（這裡它開啟了一個 <strong>UDP</strong>），然後等待數據建立（也就是等待哪些 <strong>HTML、CSS 等數據返回</strong>）也就是說，在 <strong>Ready to receive（recvfrom）</strong>之間都是準備階段。這樣就是有一段時間一直阻塞，而我們的線程二可以一直無停歇也不用切換上下文就一直在運行。<strong>這樣的 IO 密集型就有很大的好處</strong>。</p></blockquote><h5 class=pgc-h-arrow-right>IO 密集型，這樣就把我們等待的時間計算進去了，節省了大部分時間。</h5><h6 class=pgc-h-arrow-right>這裡我們需要注意的是，我們的多線程是運行在 IO 密集型上的，我們得區分清楚。</h6><p>還有就是，資源等待，比如有時候我們使用瀏覽器發起了一個 <strong>Get</strong> 請求，那瀏覽器圖標上面在<strong>轉圈圈</strong>的時候就是我們請求資源等待的時間，（也就是圖上面的 <strong>Datagram 到 Ready to receive</strong> ）數據建立到數據接收（就是轉圈圈的時間）。我們完全就不需要執行它，就讓它等待就好。<strong>這個時候讓另一個線程去執行就好</strong></p><blockquote><p>換言之就是：第一個線程，我們爬取那個網頁轉圈圈的時候讓另一個線程繼續爬取。這樣就避免了資源浪費。（把時間都利用起來）</p></blockquote><p><strong>注意：</strong> 請求資源是不需要 <strong>CPU</strong> 進行計算的，<strong>CPU</strong> 參與是很少的，而我們第一個例子，計算數字的 <strong>for</strong> 循環中，是需要 <strong>CPU</strong> 進行計算的。</p><hr><h3 class=pgc-h-arrow-right>5.1 Thread 直接創建子線程</h3><h4 class=pgc-h-arrow-right>5.1.1 非守護線程</h4><p>複雜的操作之前需要一個簡單的示例開始：</p><pre><code>import threading, timedef start():    time.sleep(1)    print(threading.current_thread().name) # 當前線程名稱    print(threading.current_thread().is_alive()) # 當前線程狀態    print(threading.current_thread().ident) # 當前線程的編號print('start')# 要使用多線程哪個函數&gt;&gt;&gt;target=函數,name=給這個多線程取個名字# 如果你不起一個名字的話，那那它會自己去起一個名字的（pid）也就是個 ident# 類似聲明thread = threading.Thread(target=start,name='my first thread')# 每個線程寫完你不start()的話，就類似只是聲明thread.start()print('stop')# 輸出startstopmy first threadTrue2968</code></pre><p>如果有參數的話，我們就對多線程參數進行傳參數。代碼示例：</p><pre><code>import threading, timedef start(num):    time.sleep(num)    print(threading.current_thread().name)    print(threading.current_thread().isAlive())    print(threading.current_thread().ident)print('start')thread = threading.Thread(target=start,name='my first thread', args=(1,))thread.start()print('stop')</code></pre><p>解析：</p><p>我認認真看一下我們的運行結果，</p><p><strong>startstopmy first threadTrue2968</strong></p><p>我們會發現並不是按我們正常的邏輯執行這一系列的代碼。</p><p>而是，先執行完 <strong>start 然後就直接 stop</strong> 然後才會執行我們函數的其他三項。</p><p>一個線程它就直接貫穿到底了。也就是先把我們主線程裡面的代碼運行完，然後才會運行它裡面的代碼。</p><p>我們的代碼並不是當代碼執行到 <strong>thread.start()</strong> 等它執行完再執行 <strong>print(‘stop’)</strong> 。而是，我們線程執行到<strong>thread.start()</strong> 繼續向下執行，同時再執行裡面的代碼（也就是<strong>start()</strong>函數裡面的代碼）。(不會卡在 thread.start() 那裡) <strong>也不會隨著主線程結束而結束</strong></p><blockquote><p>因為，程序在執行到 <strong>print(‘stop’)</strong> 之後就是主線程結束，而裡面開的線程是我們自己開的。當我們主線程執行這個 stop 就已經結束了。</p><p>這種不會隨著主線程結束而銷燬的，這種線程它叫做：非守護線程</p></blockquote><ol start=1><li>主線程會跳過創建的線程繼續執行；</li><li>直到創建線程運行完畢；</li><li>程序結束；</li></ol><p>既然，有非守護線程。那就還有守護線程。不要急，我再舉個非守護線程的例子。</p><p>首先，我們可以使用 Thread 類來創建一個線程，創建時需要指定 target 參數為運行的方法名稱，如果被調用的方法需要傳入額外的參數，則可以通過 Thread的 args參數來指定。示例如下：</p><pre><code>import threading, timedef target(second):    print(f'Threading {threading.current_thread().name} is runing')    print(f'Threading {threading.current_thread().name} sleep {second}s')    time.sleep(second)    print(f'Threading {threading.current_thread().name} ended')print(f'Threading {threading.current_thread().name} is runing')for i in [1, 5]:    t = threading.Thread(target=target, args=[i])    # t = threading.Thread(target=target, args=(i,))    t.start()print(f'Threading {threading.current_thread().name} is ended')# 輸出Threading MainThread is runingThreading Thread-1 is runingThreading Thread-1 sleep 1sThreading Thread-2 is runingThreading Thread-2 sleep 5sThreading MainThread is endedThreading Thread-1 endedThreading Thread-2 ended</code></pre><p>在這裡我們首先聲明瞭一個方法，叫作 target，它接收一個參數為 second，通過方法的實現可以發現，這個方法其實就是執行了一個 time.sleep 休眠操作，second參數就是休眠秒數，其前後都 print了一些內容，其中線程的名字我們通過 threading.current_thread().name 來獲取出來，如果是主線程的話，其值就是 MainThread，如果是子線程的話，其值就是 Thread-*。</p><p>然後我們通過 Thead類新建了兩個線程，target參數就是剛才我們所定義的方法名，args以列表的形式傳遞。兩次循環中，這裡 i 分別就是 1 和 5，這樣兩個線程就分別休眠 1 秒和 5 秒，聲明完成之後，我們調用 start 方法即可開始線程的運行。</p><p>觀察結果我們可以發現，這裡一共產生了三個線程，分別是主線程 MainThread和兩個子線程 Thread-1、Thread-2。另外我們觀察到，主線程首先運行結束，緊接著 Thread-1、Thread-2 才接連運行結束，分別間隔了 1 秒和 4 秒。這說明主線程並沒有等待子線程運行完畢才結束運行，而是直接退出了，有點不符合常理。</p><p>如果我們想要主線程等待子線程運行完畢之後才退出，可以讓每個子線程對象都調用下 join方法，實現如下：</p><pre><code>for i in [1, 5]:    t = threading.Thread(target=target, args=[i])    t.start()    t.join()# 輸出Threading MainThread is runingThreading Thread-1 is runingThreading Thread-1 sleep 1sThreading Thread-1 endedThreading Thread-2 is runingThreading Thread-2 sleep 5sThreading Thread-2 endedThreading MainThread is ended</code></pre><p>這樣，主線程必須等待子線程都運行結束，主線程才繼續運行並結束。</p><h3 class=pgc-h-arrow-right>5.2 繼承 Thread 類創建子線程</h3><p>另外，我們也可以通過繼承 Thread 類的方式創建一個線程，該線程需要執行的方法寫在類的 run 方法裡面即可。上面的例子的等價改寫為：</p><pre><code>import threading, timeclass MyThread(threading.Thread):    def __init__(self, second):        threading.Thread.__init__(self)        self.second = second    def run(self):        print(f'Threading {threading.current_thread().name} is runing')        print(f'Threading {threading.current_thread().name} sleep {self.second}s')        time.sleep(self.second)        print(f'Threading {threading.current_thread().name} is ended')print(f'Threading {threading.current_thread().name} is runing')for i in [1, 5]:    t = MyThread(i)    t.start()    t.join()print(f'Threading {threading.current_thread().name} is ended')# 輸出Threading MainThread is runingThreading Thread-1 is runingThreading Thread-1 sleep 1sThreading Thread-1 is endedThreading Thread-2 is runingThreading Thread-2 sleep 5sThreading Thread-2 is endedThreading MainThread is ended</code></pre><p>可以看到，兩種實現方式，其運行效果是相同的。</p><h3 class=pgc-h-arrow-right>5.3 守護線程</h3><p>在線程中有一個叫作守護線程的概念，如果一個線程被設置為守護線程，那麼意味著這個線程是“不重要”的，這意味著，如果主線程結束了而該守護線程還沒有運行完，那麼它將會被強制結束。在 Python 中我們可以通過 setDaemon方法來將某個線程設置為守護線程。</p><p>如果要修改成守護線程，那你就得在 thread.start()前面加一個：</p><p>需要在我們啟動之前設置。</p><p><strong>示例一如下：</strong></p><p>添加之前：</p><pre><code>import threading, timedef start(num):    time.sleep(num)    print(threading.current_thread().name) # 當前線程的名字    print(threading.current_thread().isAlive())    print(threading.current_thread().ident)print('start') # 主線程開始thread = threading.Thread(target=start,name='my first thread', args=(1,))# 可以使用 for 循環來添加多個thread.start()print('stop') # 主線程結束# 運行結果startstopmy first threadTrue15816</code></pre><p>添加之後：</p><pre><code>import threading, timedef start(num):    time.sleep(num)    print(threading.current_thread().name) # 當前線程的名字    print(threading.current_thread().isAlive())    print(threading.current_thread().ident)print('start') # 主線程開始thread = threading.Thread(target=start,name='my first thread', args=(1,))# 可以使用 for 循環來添加多個thread.setDaemon(True) # 在 start 開始之前設置thread.start()print('stop') # 主線程結束# 運行結果startstop</code></pre><p>我們可以看見，程序直接運行：start、stop，執行到 <strong>print(‘stop’) 它就結束了。</strong>也就隨著我們的主線程結束而結束。並不管它裡面還有什麼沒有執行完。（也不會管他裡面的 time.sleep()）我們的主線程一結束，我們的守護線程就會隨著主線程一起銷燬。</p><p><strong>我們日常啟動的是非守護線程，守護線程用的較少。</strong></p><p>守護線程會伴隨主線程一起結束，setDaemon設置為 True 即可。</p><p><strong>示例二如下：</strong></p><p>添加之前：</p><pre><code>import threading, timedef target(second):    print(f'Threading {threading.current_thread().name} is runing')    print(f'Threading {threading.current_thread().name} sleep {second}s')    time.sleep(second)    print(f'Threading {threading.current_thread().name} is ended')print(f'Threading {threading.current_thread().name} is runing')t1 = threading.Thread(target=target, args=[2])t1.start()t2 = threading.Thread(target=target, args=[5])t2.start()print(f'Threading {threading.current_thread().name} is ended')# 運行結果Threading MainThread is runingThreading Thread-1 is runingThreading Thread-1 sleep 2sThreading Thread-2 is runingThreading Thread-2 sleep 5sThreading MainThread is endedThreading Thread-1 is endedThreading Thread-2 is ended</code></pre><p>添加之後：</p><pre><code>import threading, timedef target(second):    print(f'Threading {threading.current_thread().name} is runing')    print(f'Threading {threading.current_thread().name} sleep {second}s')    time.sleep(second)    print(f'Threading {threading.current_thread().name} is ended')print(f'Threading {threading.current_thread().name} is runing')t1 = threading.Thread(target=target, args=[2])t1.start()t2 = threading.Thread(target=target, args=[5])t2.setDaemon(True)t2.start()print(f'Threading {threading.current_thread().name} is ended')# 運行結果Threading MainThread is runingThreading Thread-1 is runingThreading Thread-1 sleep 2sThreading Thread-2 is runingThreading Thread-2 sleep 5sThreading MainThread is endedThreading Thread-1 is ended</code></pre><p>在這裡我們通過 setDaemon方法將 t2設置為了守護線程，這樣主線程在運行完畢時，t2線程會隨著線程的結束而結束。</p><p>運行結果：</p><pre><code>Threading MainThread is runingThreading Thread-1 is runingThreading Thread-1 sleep 2sThreading Thread-2 is runingThreading Thread-2 sleep 5sThreading MainThread is endedThreading Thread-1 is ended</code></pre><p>可以看到，我們沒有看到 Thread-2打印退出的消息，Thread-2 隨著主線程的退出而退出了。</p><p>不過細心的你可能會發現，這裡並沒有調用 join方法，如果我們讓 t1和 t2都調用 join方法，主線程就會仍然等待各個子線程執行完畢再退出，不論其是否是守護線程。</p><h3 class=pgc-h-arrow-right>5.4 互斥鎖</h3><p>接下來是比較難的知識點，還是從簡單的知識點開始。</p><p><strong>比方</strong>說我們現在有兩個線程，一個是求加一千萬次，另一個是減一千萬次。按原本得計劃來說，一個加一千萬一個減一千萬結果應該還是零。可是最終得結果並不是等於零，我們多運行幾次會發現幾次得出來得結果並不相同。多線程代碼如下：</p><pre><code>import threadingimport timenumber = 0def addNumber(i):    time.sleep(i)    global number    for i in range(1000000):        number += 1    print("加",number)def downNumber(i):    time.sleep(i)    global number    for i in range(1000000):        number -= 1    print("減",number)print("start") # 輸出一個開始thread = threading.Thread(target = addNumber, args=(2,)) #開啟一個線程（聲明）thread2 = threading.Thread(target = downNumber, args=(2,)) # 開啟第二個線程（聲明）thread.start() # 開始thread2.start() # 開始thread.join()thread2.join()# join 阻塞在這裡，直到我們得阻塞線程執行完畢才會向下執行print("外", number)print("stop")</code></pre><p>就算單線程也會出現兩個值：1000000 與 -1000000，兩個函數誰先運行就是輸出誰的結果，為什麼呢？因為兩個函數調用的是全局變量 <strong>number</strong> 所以，如果先運行加法函數，加法得到的結果是 1000000 ，那全局下的 number 的值也會變成：1000000 ，那減法的操作亦然就是 0。反過來也是一個意思。代碼如下：</p><pre><code>import threadingimport timenumber = 0def addNumber(i = None):    # time.sleep(i)    global number    for i in range(1000000):        number += 1    print("加",number)def downNumber(i = None):    # time.sleep(i)    global number    for i in range(1000000):        number -= 1    print("減",number)addNumber()downNumber()print(number)# 運行結果加 1000000減 00# 反過來運行downNumber()addNumber()print(number)# 運行結果減 -1000000加 00# 再來一個差不多的例子：import threadingimport timenumber = 0def addNumber():    global number    for i in range(1000000):        number += 1    print("加",number)    return numberdef downNumber():    global number    for i in range(1000000):        number -= 1    print("減",number)    return numbersum_num = downNumber() + addNumber()print("Result", sum_num)# 輸出減 -1000000加 0Result -1000000# 修改以下代碼，其他不變：sum_num = addNumber() + downNumber()# 輸出加 1000000減 0Result 1000000</code></pre><p>由上面的多線程代碼，我可以發現結果：兩個線程操作同一個數字，最後得到的數字是混亂的。為什麼說是混亂的呢？</p><p>我們現在所要做的是一個賦值，number += 1 其實也就是 number = number + 1，的這個操作。而在我們的 Python 當中，我們是先：計算右邊的，然後賦值給左邊的，一共兩步。</p><p>我先來看一下正確的運行流程：</p><pre><code># 我們的 number = 0# 第一步是先運行我們的代碼：a = number + 1 # 等價於 0+1=1 # 也就是先運行右邊的，然後賦值給 anumber = a # 然後，再把 a 的結果賦值個 number# 上面運行完加法之後，我們加下來運行減肥的操作。b = number - 1 # 等價於 1-1 = 0# 然後，賦值個 number# 最後 number 等於 0number = 0</code></pre><p>上面的過成是正確的流程，可在多線程裡面呢？</p><pre><code>number = 0 # 開始初始值 0a = number+1 # 等價於 0+1=1# 這個地方要注意！！！# 在運行完上面一步的時候，還沒來得急把結果賦值給 number# 就開始運行減法操作：b = number-1 # 等價於 0-1=-1# 然後，這兩個運行結束之後就被賦值：number=b # b = -1number=a # a = 1# 最終得結果為：number = 1</code></pre><p>上面就是我們剛才結果錯亂得原因，也就是說：我們計算和賦值是兩部分，但是該多線程它沒有順序執行，這也就是我們所說的線程不安全。</p><p>因為，執行太快了，兩個線程交互交織在一起，最終得到我們這個錯誤結果。以上就是線程不安全的問題。</p><p>這就是需要 <strong>Lock 鎖</strong>，給它上一把鎖，來達到我們 <strong>number</strong> 的效果，這個時候為了避免錯誤，我們要給他上一把鎖了。再給你講解上鎖之前呢，<strong>接下來，我們來講一點複雜的例子：</strong></p><p>在一個進程中的<strong>多個線程是共享資源的</strong></p><p><strong>比如</strong></p><p>在一個進程中，有一個全局變量 count 用來計數，現在我們聲明多個線程，每個線程運行時都給 count加 1，讓我們來看看效果如何，代碼實現如下：</p><pre><code>import threading, timecount = 0class MyThread(threading.Thread):    def __init__(self):        threading.Thread.__init__(self)    def run(self):        global count        temp = count + 1        time.sleep(0.001)        count = tempthreads = []for _ in range(1000):    thread = MyThread()    thread.start()    threads.append(thread)for thread in threads:    thread.join()# print(len(threads))print(f'Final count: {count}')</code></pre><p>在這裡，我們聲明瞭 1000 個線程，每個線程都是現取到當前的全局變量 count 值，然後休眠一小段時間，然後對 count 賦予新的值。</p><p>那這樣，按照常理來說，最終的 count 值應該為 1000。但其實不然，我們來運行一下看看。</p><p>運行結果如下：</p><pre><code>Final count: 69</code></pre><p>最後的結果居然只有 69，而且多次運行或者換個環境運行結果是不同的。</p><p><strong>這是為什麼呢？</strong></p><p>因為 count 這個值是共享的，每個線程都可以在執行 temp = count 這行代碼時拿到當前 count 的值，但是這些線程中的一些線程可能是併發或者並行執行的，這就導致不同的線程拿到的可能是同一個 count 值，最後導致有些線程的 count 的加 1 操作並沒有生效，導致最後的結果偏小。</p><p>所以，如果多個線程同時對某個數據進行讀取或修改，就會出現不可預料的結果。為了避免這種情況，我們需要對多個線程進行同步，要實現同步，我們可以對需要操作的數據進行加鎖保護，這裡就需要用到 threading.Lock了。</p><p><strong>加鎖保護是什麼意思呢？</strong></p><p>就是說，某個線程在對數據進行操作前，需要先加鎖，這樣其他的線程發現被加鎖了之後，就無法繼續向下執行，會一直等待鎖被釋放，只有加鎖的線程把鎖釋放了，其他的線程才能繼續加鎖並對數據做修改，修改完了再釋放鎖。這樣可以確保同一時間只有一個線程操作數據，多個線程不會再同時讀取和修改同一個數據，這樣最後的運行結果就是對的了。</p><p>我們可以將代碼修改為如下內容：</p><p>示例一的修改：</p><pre><code>import threadingimport timelock = threading.Lock() # 創建一個最簡單的 讀寫鎖number = 0def addNumber():    global number    for i in range(1000000):        lock.acquire() # 先獲取        number += 1        # 中間的這個過程讓他強制有這個計算和賦值的過程，也就是讓他執行完這兩個操作，後再切換。        # 這樣就不會完成計算後，還沒來的及賦值就跑到下一個去了。        # 這樣也就防止了線程不安全的情況        lock.release() # 再釋放def downNumber():    global number    for i in range(1000000):        lock.acquire()        number -= 1        lock.release()print("start") # 輸出一個開始thread = threading.Thread(target = addNumber) #開啟一個線程（聲明）thread2 = threading.Thread(target = downNumber) # 開啟第二個線程（聲明）thread.start() # 開始thread2.start() # 開始thread.join()thread2.join()# join 阻塞在這裡，直到我們得阻塞線程執行完畢才會向下執行print("外", number)print("stop")# 輸出start外 0stop</code></pre><p>在代碼：<strong>lock.acquire() 與 lock.release()</strong> 中間的這個過程讓它強制有這個計算和賦值的過程，也就是讓他執行完這兩個操作，後再切換。這樣就不會完成計算後，還沒來的及賦值就跑到下一個去了。這樣也就防止了線程不安全的情況。</p><p>然後，就是我們第一個線程拿到這把鎖的 <strong>lock.acquire()</strong> 了，那另一個線程就會在 <strong>lock.acquire()</strong> 阻塞了，直到我們另一個線程把 <strong>lock.release()</strong> 鎖釋放，然後拿到鎖執行，就這樣不斷地切換拿鎖執行。</p><p><strong>死鎖：</strong>就是前面的線程拿到鎖之後，運行完卻不釋放鎖，下一個線程在等待前一個線程釋放鎖，這種就是死鎖。說的直白一點就是，相互等待。就像照鏡子一樣，你中有我，我中有你。也就是在沒有 release 的這種情況。（你等我表白，我等你表白）</p><p><strong>示例二的加鎖</strong></p><pre><code>import threading, timecount = 0class MyThread(threading.Thread):    def __init__(self):        threading.Thread.__init__(self)    def run(self):        global count        lock.acquire() # 獲取鎖        temp = count + 1        time.sleep(0.001)        count = temp        lock.release() # 釋放鎖lock = threading.Lock()threads = []for _ in range(1000):    thread = MyThread()    thread.start()    threads.append(thread)for thread in threads:    thread.join()print(f'Final count: {count}')</code></pre><p>在這裡我們聲明瞭一個 lock 對象，其實就是 threading.Lock 的一個實例，然後在 run 方法裡面，獲取 count 前先加鎖，修改完 count 之後再釋放鎖，這樣多個線程就不會同時獲取和修改 count 的值了。</p><p>運行結果如下：</p><pre><code>Final count: 1000</code></pre><p>這樣運行結果就正常了。</p><p>關於 Python 多線程的內容，這裡暫且先介紹這些，關於 theading更多的使用方法，如信號量、隊列等，可以參考官方文檔：https://docs.python.org/zh-cn/3.7/library/threading.html#module-threading。</p><h3 class=pgc-h-arrow-right>5.5 遞歸鎖 RLOCK</h3><p>再次複用，一個鎖可以再嵌套一個鎖。向我們上面的普通鎖，一個線程裡面，你只能獲取一次。如果獲取第二次就會報錯。</p><p>遞歸鎖什麼時候用呢？需要更低精度的，力度更小，為了更小的力度。</p><pre><code>import threadingimport timeclass Test:    rlock = threading.RLock()    def __init__(self):        self.number = 0    def execute(self, n):        # 原本是獲取鎖和釋放鎖，那如果有時候你忘記了寫 lock.release() 那就變成了死鎖。        # 而 with 可以解決這個問題。        with Test.rlock:            # with 內部有個資源釋放的機制            self.number += n    def add(self):        with Test.rlock:            self.execute(1)    def down(self):        with Test.rlock:            self.execute(-1)def add(test):    for i in range(1000000):        test.add()def down(test):    for i in range(1000000):        test.down()if __name__ == '__main__':    thread = Test() # 實例化    t1 = threading.Thread(target=add, args=(thread,))    t2 = threading.Thread(target=down, args=(thread,))    t1.start()    t2.start()    t1.join()    t2.join()    print(t.number)</code></pre><p>我們會發現這個遞歸鎖是比較耗費時間的，也就死我們獲取鎖與釋放鎖都是進行上下文切換導致資源消耗的，所以說開啟的鎖越多，所耗費的資源也就越多，程序的運行速度也就越慢。一些大的工程很少上這麼多的鎖，因為這個鎖的速度會拖慢你整個程序的運行速度。所以得思考好，用不用這些東西。</p><h3 class=pgc-h-arrow-right>5.6 Python 多線程的問題</h3><p>由於 Python 中 GIL 的限制，導致不論是在單核還是多核條件下，在同一時刻只能運行一個線程，導致 Python 多線程無法發揮多核並行的優勢。</p><p>GIL 全稱為 Global Interpreter Lock，中文翻譯為全局解釋器鎖，<strong>其最初設計是出於數據安全而考慮的。</strong></p><p>在 Python 多線程下，每個線程的執行方式如下：</p><ul><li>獲取 GIL</li><li>執行對應線程的代碼</li><li>釋放 GIL</li></ul><p>可見，某個線程想要執行，必須先拿到 GIL，我們可以把 GIL 看作是通行證，並且在一個 Python 進程中，GIL 只有一個。拿不到通行證的線程，就不允許執行。這樣就會導致，即使是多核條件下，一個 Python 進程下的多個線程，同一時刻也只能執行一個線程。</p><p>不過對於爬蟲這種 IO 密集型任務來說，這個問題影響並不大。而對於計算密集型任務來說，由於 GIL 的存在，多線程總體的運行效率相比可能反而比單線程更低。</p><h3 class=pgc-h-arrow-right>5.7 避免 GIL</h3><div class=pgc-img><img alt=熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/f7e9c37a93424650b2bad20f3380ac1f><p class=pgc-img-caption></p></div><p>前面開頭已經提到：因為 <strong>GIL</strong> 的存在，所以不管我們開了多少線程，同一時間始終只有一個線程在執行。那我們該如何避免 <strong>GIL</strong> 呢？</p><p>那這樣的話，我們<strong>不開線程</strong>不就行，(它的的存在已經無法避免，那我們選擇不使用它不就相當於不存在嘛）。那這是，你會想：那不開線程我們開啥呢？</p><p>問的好！</p><p>我們來開：<strong>進程</strong>，那怎麼說？別急！請聽我細細道來。</p><p>比方你有 <strong>3 個 CPU</strong>（當然，你可能有更多，這裡就按 <strong>3</strong> 個 <strong>CPU</strong>來為例子），那我們就開 <strong>3 個進程</strong>就好。一個 <strong>CPU</strong> 上運行就好。</p><p><strong>Ps：我們的進程是可以同時運行的。</strong></p><p>我們可以看一下下面的圖片：</p><p><strong>任務管理器</strong></p><div class=pgc-img><img alt=熬了兩個通宵寫的！終於把多線程和多進程徹底講明白了！ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/e8dcaf09eeaa49e6b82608ab5e0ddd3c><p class=pgc-img-caption></p></div><p>我們 <strong>任務管理</strong> 上的每一項都是一個進程。</p><p>多進程比多線程不好的地方是什麼呢？</p><blockquote><p>多進程的創建和銷燬開銷也會更大，成本高。</p><p>你可能線程可以開許多的線程，但你的進程就是看你的 <strong>CPU</strong> 數量。</p><p>進程間無法看到對方數據，需要使用棧或者隊列進行獲取。</p><p>每個進程之間都是獨立的。</p><p>就好像我們上面的谷歌瀏覽器和我們的 Pycharm 是沒有任何關係的，谷歌瀏覽器上面的數據肯定不可能讓 Pycharm 看到。這就是我們所說的進程之間的獨立性。</p><p>如果你想要一個進行抓取數據，一個進行調用數據，那這時是不能直接調用的，需要你自己定義個結構才能使用。>>> 編程複雜度提升。</p></blockquote><hr><blockquote><p>學員問題：任務管理器上面超過五六個進程。都是進程的話，怎麼能開那麼多呢？</p><p>答：我們一個 CPU 不止能執行一個進程，就比如我的一個 CPU 裡面密麻麻有許多進程。（比方我現在開六個進程）併發執行的。只不過計算機執行的速度非常快，這裡我簡單講一下哈。這是計算機原理的課。</p><p>不管是任何操作系統，現在就拿單核操作系統來說：我們假設現在只有一個 CPU ，一個 CPU 裡面六個<strong>進程</strong>，同一時間它只有一個進程在運行。不過我們計算執行速度非常快，這個程序執行完，它就會執行一個<strong>上下文切換</strong>，執行下一個。（因為，它執行的速度非常快，你就會感覺是併發執行一樣。）</p><p>實際上，一個 CPU 同一時間只有一個進程在執行，一個進程裡面它只有一個線程在執行。（當然，這個單核是五六年前了。現在肯定至少有雙核。</p><p>那就說有第二個 CPU 了。</p><p>而第二個和 CPU 上面又有許多個 <strong>進程</strong>，兩個 <strong>CPU</strong> 是互不相干。</p><p>那這時候，第一個 CPU 上面運行一個進程，而我們的第二個 CPU 上面也有一個進程，兩個是互補相干。（就相當於你開了兩臺電腦。）</p><p>但是同一個 CPU 在同一時間只有一個就進程。（不管你（電腦）速度多麼快，實際上本質上（在那一秒）只有一個進程在執行。<strong>如果你是雙核，那就有兩個進程。（四核就有四個進程）</strong></p></blockquote><p>Python 有個不好的地方，剛剛上面講到，如果我們有兩個 CPU 那就有兩個進程在執行（那四個 CPU 就是四個進程在執行），<strong>但是因為 Python 當中存在著 GIL，它即使有四個 CPU 每次也只有一個線程能進去，</strong>也就是說：同一時間當中，一個 CPU 上的一個進程中的一個線程在執行。剩下的都不能運行，我們的 Python 不能利用多核。</p><p>如果，大家用的是 C、Java、Go 這種的就沒有這個說法了。</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>兩個</a></li><li><a>終於</a></li><li><a>多線程</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/2ab3719e.html alt=終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3553afe761fd4eea86e31ba84eb1ffeb style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2ab3719e.html title=終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了>終於有人把梯度下降、線性迴歸、邏輯迴歸講明白了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/42017e2e.html alt=理解了“固定”兩個字，你的健身動作就不會錯！不然還不如搬磚！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/320a0001eeac35281355 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/42017e2e.html title=理解了“固定”兩個字，你的健身動作就不會錯！不然還不如搬磚！>理解了“固定”兩個字，你的健身動作就不會錯！不然還不如搬磚！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/40c1f486.html alt=你知道要從哪兩個方面選擇硬質合金鋸片嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/3383887a-aa0c-44c0-bf5d-d22873fc8107 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/40c1f486.html title=你知道要從哪兩個方面選擇硬質合金鋸片嗎？>你知道要從哪兩個方面選擇硬質合金鋸片嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac20be03.html alt=帶頭大哥!C羅拽著兩個姐姐外甥們在家健身,赤裸半身秀八塊腹肌 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/7923ca9110aa48cda35d14376a598812 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac20be03.html title=帶頭大哥!C羅拽著兩個姐姐外甥們在家健身,赤裸半身秀八塊腹肌>帶頭大哥!C羅拽著兩個姐姐外甥們在家健身,赤裸半身秀八塊腹肌</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d1ac3026.html alt=Excel多行、多列、多條件不能求和？兩個方法任君選擇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cfc5688b1dea4ca483e92f15d39644f7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d1ac3026.html title=Excel多行、多列、多條件不能求和？兩個方法任君選擇>Excel多行、多列、多條件不能求和？兩個方法任君選擇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html alt=多線程之ThreadLocal的那些事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html title=多線程之ThreadLocal的那些事>多線程之ThreadLocal的那些事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c67451a1.html alt=看了這臺美國和麵機，終於知道為什麼外國人每天的早餐都那麼豐盛 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/39ba000437f591377966 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c67451a1.html title=看了這臺美國和麵機，終於知道為什麼外國人每天的早餐都那麼豐盛>看了這臺美國和麵機，終於知道為什麼外國人每天的早餐都那麼豐盛</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html alt=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cce9b3fb23ce41b88311823510e419da style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cd56e2f3.html title=PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。>PHP進階教程-PHP還能玩多線程？看我怎麼用多線程實現CC攻擊器。</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2efaecc3.html alt=連鑄連軋廠加快“兩個結構”再優化側記 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2efaecc3.html title=連鑄連軋廠加快“兩個結構”再優化側記>連鑄連軋廠加快“兩個結構”再優化側記</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/614fd6a0.html alt=中西部地級市中兩個唯一！十堰這份“答卷”獲湖北認可 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/S1652WF4snnWa9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/614fd6a0.html title=中西部地級市中兩個唯一！十堰這份“答卷”獲湖北認可>中西部地級市中兩個唯一！十堰這份“答卷”獲湖北認可</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/69531903.html alt="兩個90後被直升機吊上高壓線  26分鐘完成帶電作業任務" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/0ff11e93fdd840c7960eb120c2f66db8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/69531903.html title="兩個90後被直升機吊上高壓線  26分鐘完成帶電作業任務">兩個90後被直升機吊上高壓線 26分鐘完成帶電作業任務</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/23c87346.html alt=淺析“模型跟蹤控制”-兩個PID控制器組成的控制算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ba2907deef34450ebaf77defe6ca4c71 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/23c87346.html title=淺析“模型跟蹤控制”-兩個PID控制器組成的控制算法>淺析“模型跟蹤控制”-兩個PID控制器組成的控制算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/352029d1.html alt=歷史長長的太平門直街多了兩個小兄弟：一弄和二弄！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/1534980530328e7c31e8408 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/352029d1.html title=歷史長長的太平門直街多了兩個小兄弟：一弄和二弄！>歷史長長的太平門直街多了兩個小兄弟：一弄和二弄！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ee2728c4.html alt="Java核心知識 多線程併發 進程調度算法 （三十二）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/ee53d84c407e492494d103a3f7a9481c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ee2728c4.html title="Java核心知識 多線程併發 進程調度算法 （三十二）">Java核心知識 多線程併發 進程調度算法 （三十二）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d0d960f5.html alt=當我們在說“併發、多線程”，說的是什麼 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d0d960f5.html title=當我們在說“併發、多線程”，說的是什麼>當我們在說“併發、多線程”，說的是什麼</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>