<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>Java工具類教程：詳解正則表達式及應用示例 | 极客快訊</title><meta property="og:title" content="Java工具類教程：詳解正則表達式及應用示例 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/4002000140fde581089b"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/48f7c5e6.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/48f7c5e6.html><meta property="article:published_time" content="2020-11-14T21:07:13+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:13+08:00"><meta name=Keywords content><meta name=description content="Java工具類教程：詳解正則表達式及應用示例"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/48f7c5e6.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>Java工具類教程：詳解正則表達式及應用示例</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/4002000140fde581089b></p><p>Java 提供了功能強大的正則表達式API，在java.util.regex 包下。<br></p><p>本教程介紹如何使用正則表達式API。</p><h1>正則表達式</h1><p>一個正則表達式是一個用於文本搜索的文本模式。換句話說,在文本中搜索出現的模式。例如，你可以用正則表達式搜索網頁中的郵箱地址或超鏈接。</p><p>正則表達式示例</p><p>下面是一個簡單的Java正則表達式的例子，用於在文本中搜索 http://</p><pre>String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";String pattern = ".*http://.*";boolean matches = Pattern.matches(pattern, text);System.out.println("matches = " + matches);</pre><p>示例代碼實際上沒有檢測找到的 http:// 是否是一個合法超鏈接的一部分,如包含域名和後綴(.com,.net 等等)。代碼只是簡單的查找字符串 http:// 是否出現。</p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p9.pstatp.com/large/3f2d0003daaea50a4332></p><h1>Java6 中關於正則表達式的API</h1><p>本教程介紹了Java6 中關於正則表達式的API。</p><p>Pattern (java.util.regex.Pattern)</p><p>類 java.util.regex.Pattern 簡稱 Pattern, 是Java正則表達式API中的主要入口，無論何時,需要使用正則表達式,從Pattern 類開始</p><p>Pattern.matches()</p><p>檢查一個正則表達式的模式是否匹配一段文本的最直接方法是調用靜態方法Pattern.matches(),示例如下:</p><pre>String text = "This is the text to be searched " + "for occurrences of the pattern.";String pattern = ".*is.*";boolean matches = Pattern.matches(pattern, text);System.out.println("matches = " + matches);</pre><p>上面代碼在變量 text 中查找單詞 “is” 是否出現，允許”is” 前後包含 0或多個字符(由 .* 指定)</p><p>Pattern.matches() 方法適用於檢查 一個模式在一個文本中出現一次的情況，或適用於Pattern類的默認設置。</p><p>如果需要匹配多次出現,甚至輸出不同的匹配文本，或者只是需要非默認設置。需要通過Pattern.compile() 方法得到一個Pattern 實例。</p><p>Pattern.compile()</p><p>如果需要匹配一個正則表達式在文本中多次出現，需要通過Pattern.compile() 方法創建一個Pattern對象。示例如下</p><pre>String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";String patternString = ".*http://.*";Pattern pattern = Pattern.compile(patternString);</pre><p>可以在Compile 方法中，指定一個特殊標誌：</p><pre>Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);</pre><p>Pattern 類包含多個標誌(int 類型),這些標誌可以控制Pattern 匹配模式的方式。上面代碼中的標誌使模式匹配是忽略大小寫</p><p>Pattern.matcher()</p><p>一旦獲得了Pattern對象，接著可以獲得Matcher對象。Matcher 示例用於匹配文本中的模式.示例如下</p><pre>Matcher matcher = pattern.matcher(text);</pre><p>Matcher類有一個matches()方法，可以檢查文本是否匹配模式。以下是關於Matcher的一個完整例子</p><pre>String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";String patternString = ".*http://.*";Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);boolean matches = matcher.matches();System.out.println("matches = " + matches);</pre><p>Pattern.split()</p><p>Pattern 類的 split()方法，可以用正則表達式作為分隔符，把文本分割為String類型的數組。示例：</p><pre>String text = "A sep Text sep With sep Many sep Separators";String patternString = "sep";Pattern pattern = Pattern.compile(patternString);String[] split = pattern.split(text);System.out.println("split.length = " + split.length);for(String element : split){ System.out.println("element = " + element);}</pre><p>上例中把text 文本分割為一個包含5個字符串的數組。</p><p>Pattern.pattern()</p><p>Pattern 類的 pattern 返回用於創建Pattern 對象的正則表達式,示例：</p><pre>String patternString = "sep";Pattern pattern = Pattern.compile(patternString);String pattern2 = pattern.pattern();</pre><p>上面代碼中 pattern2 值為sep ，與patternString 變量相同。</p><p>Matcher (java.util.regex.Matcher)</p><p>java.util.regex.Matcher 類用於匹配一段文本中多次出現一個正則表達式，Matcher 也適用於多文本中匹配同一個正則表達式。</p><p>Matcher 有很多有用的方法，詳細請參考官方JavaDoc。這裡只介紹核心方法。</p><p>以下代碼演示如何使用Matcher</p><pre>String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";String patternString = ".*http://.*";Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text);boolean matches = matcher.matches();</pre><p>首先創建一個Pattern，然後得到Matcher ，調用matches() 方法，返回true 表示模式匹配，返回false表示不匹配。</p><p>可以用Matcher 做更多的事。</p><p>創建Matcher</p><p>通過Pattern 的matcher() 方法創建一個Matcher。</p><pre>String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";String patternString = ".*http://.*";Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text);</pre><p>matches()</p><p>Matcher 類的 matches() 方法用於在文本中匹配正則表達式</p><pre>boolean matches = matcher.matches();</pre><p>如果文本匹配正則表達式，matches() 方法返回true。否則返回false。</p><p>matches() 方法不能用於查找正則表達式多次出現。如果需要，請使用find(), start() 和 end() 方法。</p><p>lookingAt()</p><p>lookingAt() 與matches() 方法類似，最大的不同是，lookingAt()方法對文本的開頭匹配正則表達式；而</p><p>matches() 對整個文本匹配正則表達式。換句話說，如果正則表達式匹配文本開頭而不匹配整個文本,lookingAt() 返回true,而matches() 返回false。 示例：</p><pre>String text = "This is the text to be searched " + "for occurrences of the http:// pattern.";String patternString = "This is the";Pattern pattern = Pattern.compile(patternString, Pattern.CASE_INSENSITIVE);Matcher matcher = pattern.matcher(text);System.out.println("lookingAt = " + matcher.lookingAt());System.out.println("matches = " + matcher.matches());</pre><p>上面的例子分別對文本開頭和整個文本匹配正則表達式 “this is the”. 匹配文本開頭的方法(lookingAt()) 返回true。</p><p>對整個文本匹配正則表達式的方法 (matches()) 返回false，因為 整個文本包含多餘的字符,而 正則表達式要求文本精確匹配”this is the”,前後又不能有額外字符。</p><p>find() + start() + end()</p><p>find() 方法用於在文本中查找出現的正則表達式，文本是創建Matcher時，通過 Pattern.matcher(text) 方法傳入的。如果在文本中多次匹配，find() 方法返回第一個，之後每次調用 find() 都會返回下一個。</p><p>start() 和 end() 返回每次匹配的字串在整個文本中的開始和結束位置。實際上, end() 返回的是字符串末尾的後一位，這樣，可以在把 start() 和 end() 的返回值直接用在String.substring() 裡。</p><pre>/*** */String text = "This is the text which is to be searched " + "for occurrences of the word 'is'.";String patternString = "is";Pattern pattern = Pattern.compile(patternString);Matcher matcher = pattern.matcher(text);int count = 0;while(matcher.find()) { count++; System.out.println("found: " + count + " : " + matcher.start() + " - " + matcher.end());}</pre><p>這個例子在文本中找到模式 “is” 4次，輸出如下:</p><pre>found: 1 : 2 - 4found: 2 : 5 - 7found: 3 : 23 - 25found: 4 : 70 - 72</pre><p>reset()</p><p>reset() 方法會重置Matcher 內部的 匹配狀態。當find() 方法開始匹配時,Matcher 內部會記錄截至當前查找的距離。調用 reset() 會重新從文本開頭查找。</p><p>也可以調用 reset(CharSequence) 方法. 這個方法重置Matcher,同時把一個新的字符串作為參數傳入，用於代替創建 Matcher 的原始字符串。</p><p>group()</p><p>假設想在一個文本中查找URL鏈接，並且想把找到的鏈接提取出來。當然可以通過 start()和 end()方法完成。但是用group()方法更容易些。</p><p>分組在正則表達式中用括號表示，例如:</p><p>(John)</p><p>此正則表達式匹配John, 括號不屬於要匹配的文本。括號定義了一個分組。當正則表達式匹配到文本後，可以訪問分組內的部分。</p><p>使用group(int groupNo) 方法訪問一個分組。一個正則表達式可以有多個分組。每個分組由一對括號標記。想要訪問正則表達式中某分組匹配的文本，可以把分組編號傳入 group(int groupNo)方法。</p><p>group(0) 表示整個正則表達式，要獲得一個有括號標記的分組，分組編號應該從1開始計算。</p><pre>String text = "John writes about this, and John writes about that," + " and John writes about everything. " ;String patternString1 = "(John)";Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) { System.out.println("found: " + matcher.group(1));}</pre><p>以上代碼在文本中搜索單詞John.從每個匹配文本中，提取分組1，就是由括號標記的部分。輸出如下</p><pre>found: Johnfound: John found: John</pre><p>多分組</p><p>上面提到，一個正則表達式可以有多個分組，例如：</p><pre>(John) (.+?)</pre><p>這個表達式匹配文本”John” 後跟一個空格,然後跟1個或多個字符，最後跟一個空格。你可能看不到最後的空格。</p><p>這個表達式包括一些字符有特別意義。字符 點 . 表示任意字符。 字符 + 表示出現一個或多個，和. 在一起表示 任何字符,出現一次或多次。字符? 表示 匹配儘可能短的文本。</p><p>完整代碼如下</p><pre>/*** */String text = "John writes about this, and John Doe writes about that," + " and John Wayne writes about everything." ;String patternString1 = "(John) (.+?) ";Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) { System.out.println("found: " + matcher.group(1) + " " + matcher.group(2));}</pre><p>注意代碼中引用分組的方式。代碼輸出如下</p><pre>found: John writes found: John Doe found: John Wayne</pre><p>嵌套分組</p><p>在正則表達式中分組可以嵌套分組，例如</p><pre>((John) (.+?))</pre><p>這是之前的例子，現在放在一個大分組裡.(表達式末尾有一個空格)。</p><p>當遇到嵌套分組時, 分組編號是由左括號的順序確定的。上例中，分組1 是那個大分組。分組2 是包括John的分組，分組3 是包括 .+? 的分組。當需要通過groups(int groupNo) 引用分組時，瞭解這些非常重要。</p><p>以下代碼演示如何使用嵌套分組</p><pre>String text = "John writes about this, and John Doe writes about that," + " and John Wayne writes about everything." ;String patternString1 = "((John) (.+?)) ";Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);while(matcher.find()) { System.out.println("found: ");}</pre><p>輸出如下</p><pre>found:found:found:</pre><p>replaceAll() + replaceFirst()</p><p>replaceAll() 和 replaceFirst() 方法可以用於替換Matcher搜索字符串中的一部分。replaceAll() 方法替換全部匹配的正則表達式，replaceFirst() 只替換第一個匹配的。</p><p>在處理之前，Matcher 會先重置。所以這裡的匹配表達式從文本開頭開始計算。</p><p>示例如下</p><pre>/*** */String text = "John writes about this, and John Doe writes about that," + " and John Wayne writes about everything." ;String patternString1 = "((John) (.+?)) ";Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);String replaceAll = matcher.replaceAll("Joe Blocks ");System.out.println("replaceAll = " + replaceAll);String replaceFirst = matcher.replaceFirst("Joe Blocks ");System.out.println("replaceFirst = " + replaceFirst);</pre><p>輸出如下</p><pre>replaceAll = Joe Blocks about this, and Joe Blocks writes about that,and Joe Blocks writes about everything.replaceFirst = Joe Blocks about this, and John Doe writes about that,and John Wayne writes about everything.</pre><p>輸出中的換行和縮進是為了可讀而增加的。</p><p>注意第1個字符串中所有出現 John 後跟一個單詞 的地方，都被替換為 Joe Blocks 。第2個字符串中，只有第一個出現的被替換。</p><p>appendReplacement() + appendTail()</p><p>appendReplacement() 和 appendTail() 方法用於替換輸入文本中的字符串短語，同時把替換後的字符串附加到一個 StringBuffer 中。</p><p>當find() 方法找到一個匹配項時，可以調用 appendReplacement() 方法，這會導致輸入字符串被增加到StringBuffer 中，而且匹配文本被替換。 從上一個匹配文本結尾處開始，直到本次匹配文本會被拷貝。</p><p>appendReplacement() 會記錄拷貝StringBuffer 中的內容，可以持續調用find(),直到沒有匹配項。</p><p>直到最後一個匹配項目，輸入文本中剩餘一部分沒有拷貝到 StringBuffer. 這部分文本是從最後一個匹配項結尾，到文本末尾部分。通過調用 appendTail() 方法，可以把這部分內容拷貝到 StringBuffer 中.</p><pre>/*** */String text = "John writes about this, and John Doe writes about that," + " and John Wayne writes about everything." ;String patternString1 = "((John) (.+?)) ";Pattern pattern = Pattern.compile(patternString1);Matcher matcher = pattern.matcher(text);StringBuffer stringBuffer = new StringBuffer();while(matcher.find()){ matcher.appendReplacement(stringBuffer, "Joe Blocks "); System.out.println(stringBuffer.toString());}matcher.appendTail(stringBuffer);System.out.println(stringBuffer.toString());</pre><p>注意我們在while循環中調用appendReplacement() 方法。在循環完畢後調用appendTail()。 代碼輸出如下:</p><pre>Joe BlocksJoe Blocks about this, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe BlocksJoe Blocks about this, and Joe Blocks writes about that, and Joe Blockswrites about everything.</pre><h1>Java 正則表達式語法</h1><p>為了更有效的使用正則表達式，需要了解正則表達式語法。正則表達式語法很複雜，可以寫出非常高級的表達式。只有通過大量的練習才能掌握這些語法規則。</p><p>本篇文字，我們將通過例子瞭解正則表達式語法的基礎部分。介紹重點將會放在為了使用正則表達式所需要了解的核心概念，不會涉及過多的細節。詳細解釋，參見 Java DOC 中的 Pattern 類.</p><p>基本語法</p><p>在介紹高級功能前，我們先快速瀏覽下正則表達式的基本語法。</p><p>字符</p><p>是正則表達式中最經常使用的的一個表達式，作用是簡單的匹配一個確定的字符。例如：</p><pre>John</pre><p>這個簡單的表達式將會在一個輸入文本中匹配John文本。</p><p>可以在表達式中使用任意英文字符。也可以使用字符對於的8進制，16進制或unicode編碼表示。例如：</p><pre>10141\u0041</pre><p>以上3個表達式 都表示大寫字符A。第一個是8進制編碼(101),第2個是16進制編碼(41),第3個是unicode編碼(0041).</p><p>字符分類</p><p>字符分類是一種結構，可以針對多個字符匹配而不只是一個字符。換句話說，一個字符分類匹配輸入文本中的一個字符，對應字符分類中多個允許字符。例如，你想匹配字符 a,b 或c，表達式如下：</p><pre>[abc]</pre><p>用一對方括號[] 表示字符分類。方括號本身並不是要匹配的一部分。</p><p>可以用字符分類完成很多事。例如想要匹配單詞John，首字母可以為大寫和小寫J.</p><pre>[Jj]ohn</pre><p>字符分類[Jj] 匹配J或j，剩餘的 ohn 會準確匹配字符ohn.</p><p>預定義字符分類</p><p>正則表達式中有一些預定義的字符分類可以使用。例如, \d 表示任意數字, \s 表示任意空白字符,\w 表示任意單詞字符。</p><p>預定義字符分類不需要括在方括號裡，當然也可以組合使用</p><pre>\d[\d\s]</pre><p>第1個匹配任意數字，第2個匹配任意數字或空白符。</p><p>完整的預定義字符分類列表，在本文最後列出。</p><p>邊界匹配</p><p>正則表達式支持匹配邊界，例如單詞邊界，文本的開頭或末尾。例如，\w 匹配一個單詞，^匹配行首,$ 匹配行尾。</p><pre>^This is a single line$</pre><p>上面的表達式匹配一行文本，只有文本 This is a single line。注意其中的行首和行尾標誌，表示不能有任何文本在文本的前面後後面，只能是行首和行尾。</p><p>完整的匹配邊界列表，在本文最後列出。</p><p>量詞匹配</p><p>量詞可以匹配一個表達式多次出現。例如下列表達式匹配字母A 出現0次或多次。</p><pre>A*</pre><p>量詞 * 表示0次或多次。+ 表示1次或多次。? 表示0次或1次。還有些其他量詞，參見本文後面的列表。</p><p>量詞匹配分為 飢餓模式,貪婪模式,獨佔模式。飢餓模式 匹配儘可能少的文本。貪婪模式匹配儘可能多的文本。獨佔模式匹配儘可能多的文本，甚至導致剩餘表達式匹配失敗。</p><p>以下演示飢餓模式,貪婪模式,獨佔模式區別。假設以下文本：</p><pre>John went for a walk, and John fell down, and John hurt his knee.</pre><p>飢餓模式下 表達式：</p><pre>John.*?</pre><p>這個表達式匹配John 後跟0個或多個字符。 . 表示任意字符。* 表示0或多次。? 跟在 * 後面，表示 * 採用飢餓模式。</p><p>飢餓模式下，量詞只會匹配儘可能少的字符，即0個字符。上例中的表達式將會匹配單詞John,在輸入文本中出現3次。</p><p>如果改為貪婪模式，表達式如下：</p><pre>John.*</pre><p>貪婪模式下，量詞會匹配儘可能多的字符。現在表達式會匹配第一個出現的John，以及在貪婪模式下 匹配剩餘的所有字符。這樣，只有一個匹配項。</p><p>最後，我們改為獨佔模式：</p><pre>John.*+hurt</pre><p>*後跟+ 表示獨佔模式量詞。</p><p>這個表達式在輸入文本中沒有匹配項，儘管文本中包括 John 和 hurt. 為什麼會這樣? 因為 .*+ 是獨佔模式。與貪婪模式下，儘可能多的匹配文本，以使整個表達式匹配不同。獨佔模式會儘可能的多的匹配，但不考慮表達式剩餘部分是否能匹配上。</p><p>.*+ 將會匹配第一個John之後的所有字符，這會導致表達式中剩餘的 hurt 沒有匹配項。如果改為貪婪模式，會有一個匹配項。表達式如下：</p><pre>John.*hurt</pre><p>邏輯操作符</p><p>正則表達式支持少量的邏輯運算(與，或，非)。</p><p>與操作是默認的，表達式 John ,意味著J 與 o與h與n。</p><p>或操作需要顯示指定，用 | 表示。例如表達式 John|hurt 意味著John 或 hurt 。</p><p>字符</p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f2d0003d74243fd27d5></p><p>字符分類</p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/3f2c00044c2a5d7be1e3></p><p>內置字符分類</p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/400400012094fd38f776></p><p>邊界匹配</p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4001000141046800d3af></p><p>量詞</p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p1.pstatp.com/large/400300013628ec1fed94></p><p><img alt=Java工具類教程：詳解正則表達式及應用示例 onerror=errorimg.call(this); src=https://p3.pstatp.com/large/4001000146c2dd468e0d></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>示例</a></li><li><a>Java</a></li><li><a>詳解</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html alt=「Java」隨機數詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b471807e699b44c2b1dedc580ea3f3af style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b8bda645.html title=「Java」隨機數詳解>「Java」隨機數詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/115806c0.html alt=Java正則表達式教程及示例 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/07559bf8adcd496d8267aad619be8a94 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/115806c0.html title=Java正則表達式教程及示例>Java正則表達式教程及示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/971dc36b.html alt="Java集合 - TreeSet詳解和使用示例" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/f01f6ccf89994943be8d054a21c1a3fe style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/971dc36b.html title="Java集合 - TreeSet詳解和使用示例">Java集合 - TreeSet詳解和使用示例</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/91b66dcd.html alt="大道至簡：Java 代碼11個方面的精簡之道（示例品鑑）" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/30747658a7ff4b3a8fc8989c80252571 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/91b66dcd.html title="大道至簡：Java 代碼11個方面的精簡之道（示例品鑑）">大道至簡：Java 代碼11個方面的精簡之道（示例品鑑）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/616d5c2c.html alt=詳解Java輸入輸出數據流模型和Web應用程序開發 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/dfic-imagehandler/64b3228d-a726-45da-aa12-32b204d6fdd7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/616d5c2c.html title=詳解Java輸入輸出數據流模型和Web應用程序開發>詳解Java輸入輸出數據流模型和Web應用程序開發</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4d4188ef.html alt=Java容器詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/73c142f92e9348a9b54add71b20d7039 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4d4188ef.html title=Java容器詳解>Java容器詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html alt=Java集合詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/d86fadc20bed4a69ad6bf811308371d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5442c182.html title=Java集合詳解>Java集合詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/aecb0c7.html alt=反向傳播示例詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/abbdd76c29a34bb78c1e19a28a3b3dd6 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/aecb0c7.html title=反向傳播示例詳解>反向傳播示例詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html alt=詳解Java多態 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/88a6dd8200454e0eb96a868562c38b4e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b6827f2.html title=詳解Java多態>詳解Java多態</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html alt="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/afd28158b4384f5eaa05c44c3104e24f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f8b2a960.html title="思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題">思路方法詳解 高三數學複習難點突破 圓錐曲線中的定點、定值問題</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/6f23d12bac3843e2b09628221846ce0f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/17054f8d.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇>詳解CD編碼格式（16bit/44.1kHz）合理性之量化篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html alt=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/5dc880024dac477f8aed432054712f82 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c84544ec.html title=詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇>詳解CD編碼格式（16bit/44.1kHz）合理性之採樣篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html alt=詳解音頻編解碼的原理、演進和應用選型等 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c0abba2ccef04296b442c6457cc98f49 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/feaa3a52.html title=詳解音頻編解碼的原理、演進和應用選型等>詳解音頻編解碼的原理、演進和應用選型等</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html alt=MySQl事務最全詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/c61163c863114226b14bb3760da19e4d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/8293e598.html title=MySQl事務最全詳解>MySQl事務最全詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html alt=Mysql事務詳解(一文讀懂數據庫事務) class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/cb7ba6cbda8c44438d9d3d7c57bd25b9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cb944fe7.html title=Mysql事務詳解(一文讀懂數據庫事務)>Mysql事務詳解(一文讀懂數據庫事務)</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>