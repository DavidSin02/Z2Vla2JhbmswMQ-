<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>這4種ThreadLocal你都知道嗎？ | 极客快訊</title><meta property="og:title" content="這4種ThreadLocal你都知道嗎？ - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p1.pstatp.com/large/pgc-image/02621283c0574fd79fbb6ff5ea971384"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bac2fc4.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bac2fc4.html><meta property="article:published_time" content="2020-11-14T21:07:43+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:43+08:00"><meta name=Keywords content><meta name=description content="這4種ThreadLocal你都知道嗎？"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4bac2fc4.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>這4種ThreadLocal你都知道嗎？</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><h1 class=pgc-h-arrow-right><strong>什麼是ThreadLocal</strong></h1><p>ThreadLocal 類顧名思義可以理解為線程本地變量。也就是說如果定義了一個 ThreadLocal ， 每個線程往這個 ThreadLocal 中讀寫是線程隔離，互相之間不會影響的。它提供了一種將可變數據通過每個線程有自己的獨立副本從而實現線程封閉的機制。</p><h1 class=pgc-h-arrow-right><strong>實際應用</strong></h1><p>實際開發中我們真正使用 ThreadLocal 的場景還是比較少的，大多數使用都是在框架裡面。最常見的使用場景的話就是用它來解決數據庫連接、 Session 管理等保證每一個線程中使用的數據庫連接是同一個。還有一個用的比較多的場景就是用來解決 SimpleDateFormat 解決線程不安全的問題，不過現在 java8 提供了 DateTimeFormatter 它是線程安全的，感興趣的同學可以去看看。還可以利用它進行優雅的傳遞參數，傳遞參數的時候，如果父線程生成的變量或者參數直接通過 ThreadLocal 傳遞到子線程參數就會丟失，這個後面會介紹一個其他的 ThreadLocal 來專門解決這個問題的。</p><h1 class=pgc-h-arrow-right><strong>ThreadLocal api介紹</strong></h1><p>ThreadLocal的API還是比較少的就幾個api</p><div class=pgc-img><img alt=這4種ThreadLocal你都知道嗎？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/02621283c0574fd79fbb6ff5ea971384><p class=pgc-img-caption></p></div><p>我們看下這幾個 api 的使用，使用起來也超級簡單</p><pre><code>    private static ThreadLocal&lt;String&gt; threadLocal = ThreadLocal.withInitial(()-&gt;"java金融");    public static void main(String[] args) {        System.out.println("獲取初始值："+threadLocal.get());        threadLocal.set("關注：【java金融】");        System.out.println("獲取修改後的值："+threadLocal.get());        threadLocal.remove();    }</code></pre><p>輸出結果：</p><pre><code>獲取初始值：java金融獲取修改後的值：關注：【java金融】</code></pre><p>是不是炒雞簡單，就幾行代碼就把所有 api 都覆蓋了。下面我們就來簡單看看這幾個 api 的源碼吧。</p><p>成員變量</p><pre><code>        /**初始容量，必須為2的冪         * The initial capacity -- MUST be a power of two.         */        private static final int INITIAL_CAPACITY = 16;        /** Entry表，大小必須為2的冪         * The table, resized as necessary.         * table.length MUST always be a power of two.         */        private Entry[] table;        /**         * The number of entries in the table.         */        private int size = 0;        /**         * The next size value at which to resize.         */        private int threshold; // Default to 0</code></pre><p>這裡會有一個面試經常問到的問題:為什麼 entry 數組的大小，以及初始容量都必須是 2 的冪？對於 firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1); 以及很多源碼裡面都是使用 hashCode &（-1） 來代替hashCode%。這種寫法好處如下：</p><ul><li>使用位運算替代取模，提升計算效率。</li><li>為了使不同 hash 值發生碰撞的概率更小，儘可能促使元素在哈希表中均勻地散列。</li></ul><p>set方法</p><pre><code>   public void set(T value) {        Thread t = Thread.currentThread();        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);        else            createMap(t, value);    }</code></pre><p>set 方法還是比較簡單的，我們可以重點看下這個方法裡面的ThreadLocalMap，它既然是個map（注意不要與 java.util.map 混為一談，這裡指的是概念上的 map ），肯定是有自己的key和value組成，我們根據源碼可以看出它的 key 是其實可以把它簡單看成是 ThreadLocal ，但是實際上ThreadLocal中存放的是 ThreadLocal 的弱引用，而它的 value 的話是我們實際 set 的值</p><pre><code>   static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {            /** The value associated with this ThreadLocal. */            Object value; // 實際存放的值            Entry(ThreadLocal&lt;?&gt; k, Object v) {                super(k);                value = v;            }        }</code></pre><p>Entry 就是是 ThreadLocalMap 裡定義的節點，它繼承了 WeakReference 類，定義了一個類型為 Object 的 value ，用於存放塞到 ThreadLocal 裡的值。我們再來看下這個 ThreadLocalMap是位於哪裡的？我們看到 ThreadLocalMap 是位於 Thread 裡面的一個變量，而我們的值又是放在 ThreadLocalMap ，這樣的話我們就實現了每個線程間的隔離。下面兩張圖的基本就把 ThreadLocal 的結構給介紹清楚了。</p><div class=pgc-img><img alt=這4種ThreadLocal你都知道嗎？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/4ec9cdd3dfe249de8bcac91d464c5c03><p class=pgc-img-caption></p></div><div class=pgc-img><img alt=這4種ThreadLocal你都知道嗎？ onerror=errorimg.call(this); src=https://p9.pstatp.com/large/pgc-image/382aed84cf2b4c579a262387595172ec><p class=pgc-img-caption></p></div><p>接下來我們再看下 ThreadLocalMap 裡面的數據結構，我們知道 HaseMap 解決 hash 衝突是由鏈表和紅黑樹（ jdk1.8 ）來解決的，但是這個我們看到 ThreadLocalMap 只有一個數組，它是怎麼來解決 hash 衝突呢？ ThreadLocalMap 採用 <strong>「線性探測」</strong> 的方式，什麼是線性探測呢？就是根「據初始 key 的hashcode值確定元素在 table 數組中的位置，如果發現這個位置上已經有其他 key 值的元素被佔用，則利用固定的算法尋找一定步長的下個位置，依次判斷，直至找到能夠存放的位置」 。 ThreadLocalMap 解決 Hash 衝突的方式就是簡單的步長加 1 或減 1 ，尋找下一個相鄰的位置。</p><pre><code>        /**         * Increment i modulo len.         */        private static int nextIndex(int i, int len) {            return ((i + 1 &lt; len) ? i + 1 : 0);        }        /**         * Decrement i modulo len.         */        private static int prevIndex(int i, int len) {            return ((i - 1 &gt;= 0) ? i - 1 : len - 1);        }</code></pre><p>這種方式的話如果一個線程裡面有大量的 ThreadLocal 就會產生性能問題，因為每次都需要對這個 table 進行遍歷，清空無效的值。所以我們在使用的時候儘可能的使用少的 ThreadLocal，不要在線程裡面創建大量的 ThreadLocal ，如果需要設置不同的參數類型我們可以通過 ThreadLocal 來存放一個 Object 的 Map 這樣的話，可以大大減少創建 ThreadLocal 的數量。偽代碼如下：</p><pre><code>public final class HttpContext {    private HttpContext() {    }    private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; CONTEXT = ThreadLocal.withInitial(() -&gt; new ConcurrentHashMap(64));    public static &lt;T&gt; void add(String key, T value) {        if(StringUtils.isEmpty(key) || Objects.isNull(value)) {            throw new IllegalArgumentException("key or value is null");        }        CONTEXT.get().put(key, value);    }    public static &lt;T&gt; T get(String key) {        return (T) get().get(key);    }    public static Map&lt;String, Object&gt; get() {        return CONTEXT.get();    }    public static void remove() {        CONTEXT.remove();    }}</code></pre><p>這樣的話我們如果需要傳遞不同的參數，可以直接使用一個 ThreadLocal 就可以代替多個 ThreadLocal 了。如果覺得不想這麼玩，我就是要創建多個 ThreadLocal ，我的需求就是這樣，而且性能還得要好，這個能不能實現列？可以使用 netty 的 FastThreadLocal 可以解決這個問題，不過要配合使 FastThreadLocalThread 或者它子類的線程線程效率才會更高，更多關於它的使用可以自行查閱資料哦。</p><p>下面我們先來看下它的這個哈希函數</p><pre><code>    // 生成hash code間隙為這個魔數，可以讓生成出來的值或者說ThreadLocal的ID較為均勻地分佈在2的冪大小的數組中。    private static final int HASH_INCREMENT = 0x61c88647;    /**     * Returns the next hash code.     */    private static int nextHashCode() {        return nextHashCode.getAndAdd(HASH_INCREMENT);    }</code></pre><p>可以看出，它是在上一個被構造出的 ThreadLocal 的 ID/threadLocalHashCode 的基礎上加上一個魔數 0x61c88647 的。這個魔數的選取與斐波那契散列有關， 0x61c88647 對應的十進制為 1640531527 .當我們使用 0x61c88647 這個魔數累加對每個 ThreadLocal 分配各自的 ID 也就是 threadLocalHashCode 再與 2 的冪（數組的長度）取模，得到的結果分佈很均勻。我們可以來也演示下通過這個魔數</p><pre><code>public class MagicHashCode {    private static final int HASH_INCREMENT = 0x61c88647;    public static void main(String[] args) {        hashCode(16); //初始化16        hashCode(32); //後續2倍擴容        hashCode(64);    }    private static void hashCode(Integer length) {        int hashCode = 0;        for (int i = 0; i &lt; length; i++) {            hashCode = i * HASH_INCREMENT + HASH_INCREMENT;//每次遞增HASH_INCREMENT            System.out.print(hashCode &amp; (length - 1));            System.out.print(" ");        }        System.out.println();    }}</code></pre><p>運行結果：</p><p>不得不佩服下這個作者，通過使用了斐波那契散列法，來保證哈希表的離散度，讓結果很均勻。可見 <strong>「代碼要寫的好，數學還是少不了」</strong> 啊。其他的源碼就不分析了，大家感興趣可以自行去查看下。</p><h1 class=pgc-h-arrow-right><strong>ThreadLocal的內存洩露</strong></h1><p>關於 ThreadLocal 是否會引起內存洩漏也是一個比較有爭議性的問題。首先我們需要知道什麼是內存洩露？</p><p>❝</p><p>在Java中，內存洩漏就是存在一些被分配的對象，這些對象有下面兩個特點，首先，這些對象是可達的，即在有向圖中，存在通路可以與其相連；其次，這些對象是無用的，即程序以後不會再使用這些對象。如果對象滿足這兩個條件，這些對象就可以判定為Java中的內存洩漏，這些對象不會被GC所回收，然而它卻佔用內存。</p><p>❞</p><p>ThreadLocal 的內存洩露情況：</p><ul><li>ThreadLocal GC ThreadLocal ThreadLocalMap key null Entry Entry value set、get key null Entry Entry.value Entry ThreadLocalMap Entry[] table Entry.value GC</li></ul><pre><code> public static void main(String[] args) throws InterruptedException {        ThreadLocal&lt;Long []&gt; threadLocal = new ThreadLocal&lt;&gt;();        for (int i = 0; i &lt; 50; i++) {            run(threadLocal);        }        Thread.sleep(50000);        // 去除強引用        threadLocal = null;        System.gc();        System.runFinalization();        System.gc();    }    private static void run(ThreadLocal&lt;Long []&gt; threadLocal) {        new Thread(() -&gt; {            threadLocal.set(new Long[1024 * 1024 *10]);            try {                Thread.sleep(1000000000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }).start();    }</code></pre><p>通過 jdk 自帶的工具 jconsole.exe 會發現即使執行了 gc 內存也不會減少，因為key還被線程強引用著。效果圖如下:</p><div class=pgc-img><img alt=這4種ThreadLocal你都知道嗎？ onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/5eacdd04eb5748b6b03b1762fef9512d><p class=pgc-img-caption></p></div><ul><li>ThreadLocalMap 了set()、get()、remove() cleanSomeSlots()、expungeStaleEntry() key null value ThreadLocal set()，get()，remove() value static ThreadLocal ThreadLocal ThreadLocal ThreadLocal GC Entry key null remove remove key null ThreadLocal remove FastThreadLocal</li><li>在線程池的場景，程序不停止，線程一直在複用的話，基本不會銷燬，其實本質就跟上面例子是一樣的。如果線程不復用，用完就銷燬了就不會存在洩露的情況。因為線程結束的時候會jvm 主動調用 exit 方法清理。</li></ul><pre><code>      /**         * This method is called by the system to give a Thread         * a chance to clean up before it actually exits.         */        private void exit() {            if (group != null) {                group.threadTerminated(this);                group = null;            }            /* Aggressively null out all reference fields: see bug 4006245 */            target = null;            /* Speed the release of some of these resources */            threadLocals = null;            inheritableThreadLocals = null;            inheritedAccessControlContext = null;            blocker = null;            uncaughtExceptionHandler = null;        }</code></pre><h1 class=pgc-h-arrow-right><strong>InheritableThreadLocal</strong></h1><p>文章開頭有提到過父子之間線程的變量傳遞丟失的情況。但是 InheritableThreadLocal 提供了一種父子線程之間的數據共享機制。可以解決這個問題。</p><pre><code> static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;();    static InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;();    public static void main(String[] args) throws InterruptedException {        threadLocal.set("threadLocal主線程的值");        Thread.sleep(100);        new Thread(() -&gt; System.out.println("子線程獲取threadLocal的主線程值：" + threadLocal.get())).start();        Thread.sleep(100);        inheritableThreadLocal.set("inheritableThreadLocal主線程的值");        new Thread(() -&gt; System.out.println("子線程獲取inheritableThreadLocal的主線程值：" + inheritableThreadLocal.get())).start();    }</code></pre><p>輸出結果</p><pre><code>線程獲取threadLocal的主線程值：null子線程獲取inheritableThreadLocal的主線程值：inheritableThreadLocal主線程的值</code></pre><p>但是 InheritableThreadLocal 和線程池使用的時候就會存在問題，因為子線程只有在線程對象創建的時候才會把父線程 inheritableThreadLocals 中的數據複製到自己的 inheritableThreadLocals 中。這樣就實現了父線程和子線程的上下文傳遞。但是線程池的話，線程會複用，所以會存在問題。如果要解決這個問題可以有什麼辦法列？大家可以思考下，或者在下方留言哦。如果實在不想思考的話，可以參考下阿里巴巴的 transmittable-thread-local 哦。</p><ul><li>ThreadLocal ThreadLocal ThreadLocal、InheritableThreadLocal、FastThreadLocal、transmittable-thread-local ThreadLocal</li></ul><ul><li>由於自己才疏學淺，難免會有紕漏，假如你發現了錯誤的地方，還望留言給我指出來,我會對其加以修正。</li><li>如果你覺得文章還不錯，你的轉發、分享、讚賞、點贊、留言就是對我最大的鼓勵。</li><li>感謝您的閱讀,十分歡迎並感謝您的關注。</li></ul><div class=pgc-img><img alt=這4種ThreadLocal你都知道嗎？ onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/79a28d6e8c2444a2b03a751a1fd9f6d3><p class=pgc-img-caption></p></div><pre><code>最近面試BAT，整理一份面試資料《Java面試BATJ通關手冊》，覆蓋了Java核心技術、JVM、Java併發、SSM、微服務、數據庫、數據結構、等等。</code></pre><p style=text-align:start>獲取方式：回覆 <strong>666</strong> 領取，更多內容陸續奉上。</p><p style=text-align:start>文章有幫助的話，在看，轉發吧。</p><p style=text-align:start>謝謝支持喲 (*^__^*）</p></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>ThreadLocal</a></li><li><a>知道</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/32a99b12.html alt=怎樣跳纖？【看完就知道了】 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/f5acf09fdf9a4abfbdb64f901c2cf353 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/32a99b12.html title=怎樣跳纖？【看完就知道了】>怎樣跳纖？【看完就知道了】</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ce0de46b.html alt=6個硬拉錯誤你都知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/509800008698e71077d2 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ce0de46b.html title=6個硬拉錯誤你都知道嗎？>6個硬拉錯誤你都知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1c9afde0.html alt="一起來談談ThreadLocal 原理吧！你需要了解！" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/499a403f2b63464db8e3e12298c1a3e5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1c9afde0.html title="一起來談談ThreadLocal 原理吧！你需要了解！">一起來談談ThreadLocal 原理吧！你需要了解！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html alt=多線程之ThreadLocal的那些事 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/58bb67505b204eef816b6e3b75935246 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/a915e749.html title=多線程之ThreadLocal的那些事>多線程之ThreadLocal的那些事</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html alt=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/67412c6e1bba450b9581452ab0e56e4c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ef5bd4a5.html title=從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？>從源碼角度來剖析ThreadLocal到底有沒有內存洩漏？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html alt=面試再問ThreadLocal，別說你不會 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/3a95ff3cd79a456d9221f66851f8c2f9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/2eecc1b9.html title=面試再問ThreadLocal，別說你不會>面試再問ThreadLocal，別說你不會</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b2548f6a.html alt=【你所不知道的植物祕密】月光花 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/15217027685259cf27c6399 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b2548f6a.html title=【你所不知道的植物祕密】月光花>【你所不知道的植物祕密】月光花</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/1e8c1d8d.html alt=你們知道黃銅的由來嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/27ad7f82fe4b4f8185c896390543953a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/1e8c1d8d.html title=你們知道黃銅的由來嗎？>你們知道黃銅的由來嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/3c5d4d6f.html alt=火車硬臥和軟臥的區別你知道嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/192300035beda45ce663 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/3c5d4d6f.html title=火車硬臥和軟臥的區別你知道嗎？>火車硬臥和軟臥的區別你知道嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/5a2e07e3.html alt=關於窗簾你知道多少？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/7160b4af5e494f4a9e26462d22d87c10 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/5a2e07e3.html title=關於窗簾你知道多少？>關於窗簾你知道多少？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bee4de66.html alt=你可能不知道的開關櫃知識點 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/617100039d1cef0db587 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bee4de66.html title=你可能不知道的開關櫃知識點>你可能不知道的開關櫃知識點</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fbeb88bb.html alt=關於大數據管理，你該知道的 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/a133b809fcef4baf82866346550732b5 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fbeb88bb.html title=關於大數據管理，你該知道的>關於大數據管理，你該知道的</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/f22d6213.html alt=你知道如何選購羊絨製品嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p9.pstatp.com/large/pgc-image/152605410842563d57d4353 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/f22d6213.html title=你知道如何選購羊絨製品嗎？>你知道如何選購羊絨製品嗎？</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/24c40250.html alt=你不知道的綠肥 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/4dc7884a12ba4f96b7ce093b63174338 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/24c40250.html title=你不知道的綠肥>你不知道的綠肥</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/cadb794d.html alt=電腦的Windows鍵有多牛，你知道嗎，你會用嗎？你用對了嗎？ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/5e7a0004e724b9844cce style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/cadb794d.html title=電腦的Windows鍵有多牛，你知道嗎，你會用嗎？你用對了嗎？>電腦的Windows鍵有多牛，你知道嗎，你會用嗎？你用對了嗎？</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>