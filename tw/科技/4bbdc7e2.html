<!doctype html><html lang=tw><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer"><link rel=dns-prefetch href=https://i.geekbank.cf/><title>工程師必知必會select count()你知多少？一文讀懂 | 极客快訊</title><meta property="og:title" content="工程師必知必會select count()你知多少？一文讀懂 - 极客快訊"><meta property="og:type" content="article"><meta property="og:locale" content="tw"><meta property="og:image" content="https://p3.pstatp.com/large/pgc-image/cfac7557a83047469f3de4270e371eaa"><link rel=alternate hreflang=x-default href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-tw href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-cn href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-hk href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-mo href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-my href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=alternate hreflang=zh-sg href=https://geekbank.cf/cn/%e7%a7%91%e6%8a%80/4bbdc7e2.html><link rel=canonical href=https://geekbank.cf/tw/%e7%a7%91%e6%8a%80/4bbdc7e2.html><meta property="article:published_time" content="2020-11-14T21:07:40+08:00"><meta property="article:modified_time" content="2020-11-14T21:07:40+08:00"><meta name=Keywords content><meta name=description content="工程師必知必會select count()你知多少？一文讀懂"><meta name=author content="极客快訊"><meta property="og:url" content="/tw/%E7%A7%91%E6%8A%80/4bbdc7e2.html"><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffc40d"><meta name=theme-color content="#ffffff"><link rel=stylesheet href=https://geekbank.cf/css/normalize.css><link rel=stylesheet href=https://geekbank.cf/css/style.css><script type=text/javascript src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script type=text/javascript src=https://geekbank.cf/js/jqthumb.min.js></script><script data-ad-client=ca-pub-3525055026201463 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><header id=header class=clearfix><div class=container><div class=col-group><div class=site-name><h1><a id=logo href>🤓 极客快訊 Geek Bank</a></h1><p class=description>為你帶來最全的科技知識 🧡</p></div><div><nav id=nav-menu class=clearfix><a class=current href>猜你喜歡</a>
<a href=../../tw/categories/%E7%A7%91%E6%8A%80.html title=科技>科技</a>
<a href=../../tw/categories/%E9%81%8A%E6%88%B2.html title=遊戲>遊戲</a>
<a href=../../tw/categories/%E7%A7%91%E5%AD%B8.html title=科學>科學</a></nav></div></div></div></header><div id=body><div class=container><div class=col-group><div class=col-8 id=main><div class=res-cons><article class=post><header><h1 class=post-title>工程師必知必會select count()你知多少？一文讀懂</h1></header><date class="post-meta meta-date">2020-11-14</date><div class=post-meta><span>|</span>
<span class=meta-category><a href=tw/categories/%E7%A7%91%E6%8A%80.html>科技</a></span></div><div class=post-content><div><p>“SELECT COUNT( * ) FROM T” 是個再常見不過的 SQL 需求了。在 MySQL 的使用規範中，我們一般使用事務引擎 InnoDB 作為(一般業務)表的存儲引擎，在此前提下，COUNT( * )操作的時間複雜度為 O(N)，其中 N 為表的行數。</p><p>而 MyISAM 表中可以快速取到表的行數。這些實踐經驗的背後是怎樣的機制，以及為什麼需要/可以是這樣，就是此文想要探討的。</p><p>先來看一下概況: MySQL COUNT( * ) 在 2 種存儲引擎中的部分問題：</p><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/cfac7557a83047469f3de4270e371eaa><p class=pgc-img-caption></p></div><p>下面就帶著這些問題，以 InnoDB 存儲引擎為主來進行討論。</p><p>一、InnoDB 全表 COUNT( * )</p><p>主要問題:</p><ol><li>執行過程是怎樣的？</li><li>如何計算 count？影響 count 結果的因素有哪些？</li><li>count 值存在哪裡？涉及的數據結構是怎樣的？</li><li>為什麼 InnoDB 只能通過掃表來實現 count( * )？(見本文最後的問題)</li><li>全表COUNT( * )作為 table scan 類型操作的一個 case，有什麼風險？</li><li>COUNT(* )操作是否會像“SELECT * ”一樣可能讀取大字段涉及的溢出頁？</li></ol><p class=ql-align-center>1</p><p><strong>1. 執行框架 – 循環: 讀取 + 計數？</strong></p><p>1.1 基本結論</p><ol><li>全表掃描，一個循環解決問題。</li><li>循環內: 先讀取一行，再決定該行是否計入 count。</li><li>循環內是一行一行進行計數處理的。</li></ol><p>1.2 說明</p><p>簡單 SELELCT-SQL 的執行框架，類比 INSERT INTO … SELECT 是同樣的過程。</p><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p3.pstatp.com/large/pgc-image/52dcaaf2c1ff445f9776538516b4d745><p class=pgc-img-caption></p></div><p>下面會逐步細化如何讀取與計數 ( count++ ) 。</p><p class=ql-align-center>2</p><p><strong>執行過程？</strong></p><p>引述: 執行過程部分，分為 4 個部分:</p><ol><li>COUNT( * ) 前置流程: 從 Client 端發 SQL 語句，到 MySQL-Server 端執行 SELECT 之前，為後面的一些闡述做一鋪墊。</li><li>COUNT( * ) 流程: 簡要給出代碼層面的流程框架及 2 個核心步驟的重點調用棧部分。</li><li>讀取一行: 可見性及 row_search_mvcc 函數，介紹可見性如何影響 COUNT( * ) 結果。</li><li>計數一行: Evaluate_join_record 與列是否為空，介紹計數過程如何影響 COUNT( * ) 結果。</li></ol><p>如果讀者希望直接看如何進行 COUNT( * )，那麼也可以忽略 (1)，而直接跳到 (2) 開始看。</p><p>2.1 COUNT( * ) 前置流程回憶 – 從 Client 端發 SQL 到 sub_select 函數</p><p>為了使看到的調用過程不太突兀，我們還是先回憶一下如何執行到 sub_select 函數這來的：</p><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/c877f728cdb14eae9c3cb06c51315579><p class=pgc-img-caption></p></div><ol><li>MySQL-Client 端發送 SQL 語句，根據 MySQL 通信協議封包發送。</li><li>Mysql-Server 端接收數據包，由協議解析出 command 類型 ( QUERY ) 及 SQL 語句 ( 字符串 ) 。</li><li>SQL 語句經過解析器解析輸出為 JOIN 類的對象，用於結構化地表達該 SQL 語句。</li><li>PS: 這裡的 JOIN 結構，不僅僅是純語法結構，而是已經進行了語義處理，粗略地說，彙總了表的列表 ( table_list )、目標列的列表 ( target_list )、WHERE 條件、子查詢等語法結構。</li><li>在全表 COUNT( * )-case 中，table_list = [表“t”(別名也是“t”)]，target_list = [目標列對象(列名為“COUNT( * )”)]，當然這裡沒有 WHERE 條件、子查詢等結構。</li><li>JOIN 對象有 2 個重要的方法: JOIN::optimize(), JOIN::exec()，分別用於進行查詢語句的優化 和 查詢語句的執行。</li></ol><ul><li class=ql-indent-1>join->optimize()，優化階段 (稍後 myisam 下全表 count( * ) 操作會涉及這裡的一點內容)。</li><li class=ql-indent-1>join->exec()，執行階段 ( 重點 )，包含了 InnoDB 下全表count( * ) 操作的執行流程。</li></ul><ol><li>join->exec() 經過若干調用，將調用到 sub_select 函數來執行簡單 SQL，包括 COUNT( * ) 。</li><li>END of sub_select 。</li></ol><p>2.2 COUNT( * ) 流程 ( 於 sub_select 函數中 )</p><p>上層的流程與代碼是比較簡單的，集中在 sub_select 函數中，其中 2 類函數分別對應於前面”執行框架”部分所述的 2 個步驟 – 讀取、計數。先給出結論如下：</p><ol><li>讀取一行：從相對頂層的 sub_select 函數經過一番調用，最終所有分支將調用到 row_search_mvcc 函數中，該函數就是用於從 InnoDB 存儲引擎所存儲的 B+-tree 結構中讀取一行到內存中的一個 buf (uchar * ) 中，待後續處理使用。</li><li>這裡會涉及行鎖的獲取、MVCC 及行可見性的問題。當然對 於 SELECT COUNT( * ) 這類快照讀而言，只會涉及 MVCC 及其可見性，而不涉及行鎖。詳情可跳至“可見性與 row_search_mvcc 函數”部分。</li><li>計數一行: 代碼層面，將會在 evaluate_join_record 函數中對所讀取的行進行評估，看其是否應當計入 count 中 ( 即是否要 count++ )。</li><li>簡單來說，COUNT(arg) 本身為 MySQL 的函數操作，對於一行來說，若括號內的參數 arg ( 某列或整行 ) 的值若不是 NULL，則 count++，否則對該行不予計數。詳情可跳至“ Evaluate_join_record 與列是否為空”部分。</li></ol><p>這兩個階段對 COUNT( * )結果的影響如下: (兩層過濾)</p><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de3aedf6a7484d1493251470a8b0fa2d><p class=pgc-img-caption></p></div><p>SQL 層流程框架相關代碼摘要如下:</p><p>1210 enum_nested_loop_state</p><p>1211 sub_select(JOIN *join, QEP_TAB *const qep_tab,bool end_of_records)</p><p>1212 {</p><p>1213 DBUG_ENTER("sub_select");</p><p>... ... // 此處省略1000字</p><p>1265 while (rc == NESTED_LOOP_OK && join->return_tab >= qep_tab_idx)</p><p>1266 {</p><p>1267 int error;</p><p>// 第一步，從存儲引擎中獲取一行；</p><p>1268 if (in_first_read)</p><p>1269 {</p><p>1270 in_first_read= false;</p><p>// 第一步，首次讀取，掃描第一個滿足條件的記錄；</p><p>// 初始化cursor，從”頭”掃描到某個位置</p><p>// 類似: SELECT id FROM t LIMIT 1;</p><p>1271 error= (*qep_tab->read_first_record)(qep_tab);</p><p>1272 }</p><p>1273 else</p><p>// 第一步，後續讀取，在前次掃描的位置上繼續遍歷，找到一個滿足條件的記錄；</p><p>// 類似: SELECT id FROM t WHERE id > $last_id LIMIT 1;</p><p>1274 error= info->read_record(info);</p><p>... ... // 此處省略1000字</p><p>// 第二步，處理剛剛取出的一行</p><p>1291 rc= evaluate_join_record(join, qep_tab);</p><p>... ... // 此處省略1000字</p><p>1303 DBUG_RETURN(rc);</p><p>1304 }</p><p><strong>Q：代碼層面，第一步驟(讀取一行)有 2 個分支，為什麼？</strong></p><p><strong>A：</strong>從 InnoDB 接口層面考慮，分為 “讀第一行” 和 “讀下一行”，是 2 個不同的執行過程，讀第一行需要找到一個 ( cursor ) 位置並做一些初始化工作讓後續的過程可遞歸。</p><p>正如我們如果用腳本/程序來進行逐行的掃表操作，實現上就會涉及下面 2 個 SQL：</p><p>// SELECT id FROM t LIMIT 1; OR SELECT MIN(id)-1 FROM t; -> $last_id</p><p>// SELECT id FROM t WHERE id > $last_id LIMIT 1;</p><p>具體涉及到此例的代碼，SQL 層到存儲引擎層的調用關係，讀取階段的調用棧如下：(供參考)</p><p>sub_select 函數中從 SQL 層到 InnoDB 層的函數調用關係：(同顏色、同縮進 表示同一層)</p><p>Ø (*qep_tab->read_first_record) ()</p><p>| -- > join_read_first(tab)</p><p>| -- > tab->read_record.read_record=join_read_next;</p><p>| -- > table->file->ha_index_init()</p><p>| -- > handler::ha_index_init(uint idx, bool sorted)</p><p>| -- > ha_innobase::index_init()</p><p>| -- > table->file->ha_index_first()</p><p>| -- > handler::ha_index_first(uint idx, bool sorted)</p><p>| -- > ha_innobase::index_first()</p><p>| -- > ha_innobase::index_read()</p><p>| -- > row_search_mvcc()</p><p>初始化cursor並將其放到一個有效的初始位置上;</p><p>Ø info->read_record (info)</p><p>| -- > join_read_next(info)</p><p>| -- > info->table->file->ha_index_next(info->record))</p><p>| -- > handler::ha_index_next(uchar * buf)</p><p>| -- > ha_innobase::index_next(uchar * buf)</p><p>| -- > general_fetch(buf, ROW_SEL_NEXT, 0)</p><p>| -- > row_search_mvcc()</p><p>“向前”移動一次cursor;</p><p>我們可以看到，無論是哪一個分支的讀取，最終都殊途同歸於 row_search_mvcc 函數。</p><p>以上是對 LOOP 中的代碼做一些簡要的說明，下面來看 row_search_mvcc 與 evaluate_join_record 如何輸出最終的 count 結果。</p><p>2.3 行可見性及 row_search_mvcc 函數</p><p>這裡我們主要通過一組 case 和幾個問題來看行可見性對 COUNT( * ) 的影響。</p><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/de39ef65737843478ed0e0f494f01a85><p class=pgc-img-caption></p></div><p><strong>Q：對於“SELECT COUNT( * ) FROM t”或者“SELECT MIN(id) FROM t”操作，第一次的讀行操作讀到的是表 t 中 ( B+ 樹最左葉節點 page 內 ) 的最小記錄嗎？( ha_index_first 為何也調用 row_search_mvcc 來獲取最小 key 值？)</strong></p><p><strong>A：</strong>不一定。即使是 MIN ( id ) 也不一定就讀取的是 id 最小的那一行，因為也同樣有行可見性的問題，實際上 index_read 取到的是 當前事務內語句可見的最小 index 記錄。這也反映了前面提到的 join_read_first 與 join_read_next “殊途同歸”到 row_search_mvcc 是理所應當的。</p><p><strong>Q：針對圖中最後一問，如果事務 X 是 RU ( Read-Uncommitted ) 隔離級別，且 C-Insert ( 100 ) 的完成是在 X-count( * ) 執行過程中 ( 僅掃描到 5 或 10 這條記錄 ) 完成的，那麼 X-count( * ) 在事務 C-Insert ( 100 ) 完成後，能否在之後的讀取過程中看到 100 這條記錄呢？</strong></p><p><strong>A：</strong>MySQL 採取”讀到什麼就是什麼”的策略，即 X-count( * ) 在後面可以讀到 100 這條記錄。</p><p>2.4 evaluate_join_record 與列是否為空</p><p><strong>Q：某一行如何計入 count？</strong></p><p><strong>A：</strong>兩種情況會將所讀的行計入 count:</p><ol><li>如果 COUNT 函數中的參數是某列，則會判斷所讀行中該列定義是否 Nullable 以及該列的值是否為 NULL；若兩者均為是，則不會計入 count，否則將計入 count。</li></ol><ul><li class=ql-indent-1>e.g. SELECT COUNT(col_name) FROM t</li><li class=ql-indent-1>col_name 可以是主鍵、唯一鍵、非唯一鍵、非索引字段</li></ul><ol><li>如果 COUNT 中帶有 * ，則會判斷這部分的整行是否為 NULL，如果判斷參數為 NULL，則忽略該行，否則 count++。</li></ol><ul><li>e.g-1. SELECT COUNT(*) FROM t</li><li>e.g-2. SELECT COUNT(B.*) FROM A LEFT JOIN B ON A.id = B.id</li></ul><p><strong>Q：特別地，對於 SELECT COUNT(id) FROM t，其中 id 字段是表 t 的主鍵，則如何？</strong></p><p><strong>A：</strong>效果上等價於 COUNT( * )。因為無論是 COUNT( * )，還是 COUNT ( pk_col ) 都是因為有主鍵從而充分斷定索取數據不為 NULL，這類 COUNT 表達式可以用於獲取當前可見的錶行數。</p><p><strong>Q：用戶層面對 InnoDB COUNT( * ) 的優化操作問題</strong></p><p><strong>A：</strong>這個問題是業界熟悉的一個問題，掃描非空唯一鍵可得到錶行數，但所涉及的字節數可能會少很多(在表的行長與主鍵、唯一鍵的長度相差較多時)，相對的 IO 代價小很多。</p><p>相關調用棧參考如下:</p><p>參考一:</p><p>evaluate_join_record()</p><p>| -- > rc= (*qep_tab->next_select)(join, qep_tab+1, 0);</p><p>| -- > end_send_group(...)</p><p>| -- > init_sum_functions(join->sum_funcs, join->sum_funcs_end[idx+1]))</p><p>| -- > (*func_ptr)->reset_and_add()</p><p>| -- > Item_sum::aggregator_clear()</p><p>| -- > Item_sum::aggregator_add()</p><p>| -- > update_sum_func(Item_sum **func_ptr)</p><p>| -- > (*func_ptr)->add()</p><p>| -- > Item_sum::aggregator_add()</p><p>參考二: (Item_sum::aggregator_add)</p><p>((Item_sum *) (*func_ptr))->aggregator_add()</p><p>| -- > (Item_sum *)this->aggr->add()</p><p>| -- > ((Aggregator_simple *) aggr)->item_sum->add()</p><p>| -- > if (! aggr->arg_is_null(false))</p><p>| ------ > ((Item_sum_count *)aggr->item_sum)->count++;</p><p>二、數據結構:</p><p><strong>Q：count 值存儲在哪個內存變量裡？</strong></p><p>**A：**SQL 解析後，存儲於表達 COUNT( * ) 這一項中，((Item_sum_count*)item_sum)->count</p><p>如下圖所示回顧我們之前“COUNT( * )前置流程”部分提到的 JOIN 結構。</p><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/249ae0ac58a7400fa873cffe3a77f30a><p class=pgc-img-caption></p></div><p>即 SQL 解析器為每個 SQL 語句進行結構化，將其放在一個 JOIN 對象 ( join ) 中來表達。在該對象中創建並填充了一個列表 result_field_list 用於存放結果列，列表中每個元素則是一個結果列的 ( Item_result_field* ) 對象 ( 指針 ) 。</p><p>在 COUNT( * )-case 中，結果列列表只包含一個元素，( Item_sum_count: public Item_result_field ) 類型對象 ( name = “COUNT( * )”)，其中該類所特有的成員變量 count即為所求。</p><p>三、MyISAM 全表 COUNT( * )</p><p>由於 MyISAM 引擎並不常用於實際業務中，僅做簡要描述如下：</p><ol><li>MyISAM-COUNT( * ) 操作是 O(1) 時間複雜度的操作。</li><li>每張 MyISAM 表中存放了一個 meta 信息-count 值，在內存中與文件中各有一份，內存中的 count 變量值通過讀取文件中的 count 值來進行初始化。</li><li>SELECT COUNT( * ) FROM t 會直接讀取內存中的表 t 對應的 count 變量值。</li><li>內存中的 count 值與文件中的 count 值由寫操作來進行更新，其一致性由表級鎖來保證。</li><li>表級鎖保證的寫入串行化使得，同一時刻所有用戶線程的讀操作要麼被鎖，要麼只會看到一種數據狀態。</li></ol><p>四、幾個問題</p><p><strong>Q：MyISAM 與 InnoDB 在 COUNT( * ) 操作的執行過程在哪裡開始分道揚鑣？</strong></p><ul><li>共性：共性存在於 SQL 層，即 SQL 解析之後的數據結構是一致的，count 變量都是存在於作為結果列的 Item_sum_count 類型對象中；返回給客戶端的過程也類似 – 對該 count 變量進行賦值並經由 MySQL 通信協議返回給客戶端。</li><li>區別：InnoDB 的 count 值計算是在 SQL 執行階段進行的；而 MyISAM 表本身在內存中有一份包含了表 row_count 值的 meta 信息，在 SQL 優化階段通過存儲引擎的標記給優化器一個 hint，表明該表所用的存儲引擎保存了精確行數，可以直接獲取到，無需再進入執行器。</li></ul><div class=pgc-img><img alt="工程師必知必會select count(*)你知多少？一文讀懂" onerror=errorimg.call(this); src=https://p1.pstatp.com/large/pgc-image/8a13f81a3ff949c5ae0aadcd446a78ba><p class=pgc-img-caption></p></div><p><strong>Q：InnoDB 中為何無法向 MyISAM 一樣維護住一個 row_count 變量？</strong></p><p><strong>A：</strong>從 MVCC 機制與行可見性問題中可得到原因，每個事務所看到的行可能是不一樣的，其 count( * ) 結果也可能是不同的；反過來看，則是 MySQL-Server 端無法在同一時刻對所有用戶線程提供一個統一的讀視圖，也就無法提供一個統一的 count 值。</p><p>PS: 對於多個訪問 MySQL 的用戶線程 ( COUNT( * ) ) 而言，決定它們各自的結果的因素有幾個:</p><ol><li>一組事務執行前的數據狀態(初始數據狀態)。</li><li>有時間重疊的事務們的執行序列 (操作時序，事務理論表明 併發事務操作的可串行化是正確性的必要條件)。</li><li>事務們各自的隔離級別(每個操作的輸入)。</li></ol><p>其中 1、2 對於 Server 而言都是全局或者說可控的，只有 3 是每個用戶線程中事務所獨有的屬性，這是 Server 端不可控的因素，因此 Server 端也就對每個 COUNT( * ) 結果不可控了。</p><p><strong>Q：InnoDB-COUNT( * ) 屬 table scan 操作，是否會將現有 Buffer Pool 中其它用戶線程所需熱點頁從 LRU-list 中擠佔掉，從而其它用戶線程還需從磁盤 load 一次，突然加重 IO 消耗，可能對現有請求造成阻塞？</strong></p><p><strong>A：</strong>MySQL 有這樣的優化策略，將掃表操作所 load 的 page 放在 LRU-list 的 young/old 的交界處 ( LRU 尾部約 3/8 處 )。這樣用戶線程所需的熱點頁仍然在 LRU-list-young 區域，而掃表操作不斷 load 的頁則會不斷沖刷 old 區域的頁，這部分的頁本身就是被認為非熱點的頁，因此也相對符合邏輯。</p><p>PS: 個人認為還有一種類似的優化思路，是限定掃描操作所使用的 Buffer Pool 的大小為 O(1) 級別，但這樣做需要付出額外的內存管理成本。</p><p><strong>Q：InnoDB-COUNT( * ) 是否會像 SELECT * FROM t 那樣讀取存儲大字段的溢出頁(如果存在)？</strong></p><p><strong>A：</strong>否。因為 InnoDB-COUNT( * ) 只需要數行數，而每一行的主鍵肯定不是 NULL，因此只需要讀主鍵索引頁內的行數據，而無需讀取額外的溢出頁。</p><p class=ql-align-center>———— e n d ————</p><p class=ql-align-center><br></p></div></div><div class="post-meta meta-tags"><ul class=clearfix><li><a>師必知</a></li><li><a>必會</a></li><li><a>select</a></li></ul></div></article></div></div><div id=secondary><section class=widget><form id=search action=//www.google.com/search method=get accept-charset=utf-8 target=_blank _lpchecked=1><input type=text name=q maxlength=20 placeholder=搜索>
<input type=hidden name=sitesearch value=geekbank.cf>
<button type=submit>🔍</button></form></section><section class=widget><h3 class=widget-title>最新文章 ⚡</h3><ul class=widget-list><li><a href=../../tw/%E7%A7%91%E6%8A%80/74a9212.html alt=射頻工程師必知必會——長線效應與分佈參數 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/cf6a2065b1394322998294ddeab09c8d style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/74a9212.html title=射頻工程師必知必會——長線效應與分佈參數>射頻工程師必知必會——長線效應與分佈參數</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c8f329d0.html alt=一個合格的程序員必會Hash詳解 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/0139af5bf4374f9583277f384c9c343c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c8f329d0.html title=一個合格的程序員必會Hash詳解>一個合格的程序員必會Hash詳解</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/9acfbb8b.html alt=EXCEL必會的基本操作 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1a21c3c391e44695a302bc1f3bdcb88e style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/9acfbb8b.html title=EXCEL必會的基本操作>EXCEL必會的基本操作</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7c507f66.html alt="RF工程師必知的 ADC 器件相位校準和控制" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7c507f66.html title="RF工程師必知的 ADC 器件相位校準和控制">RF工程師必知的 ADC 器件相位校準和控制</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/6a82b17b.html alt=辦公室改稿必會必備：修改校對常用符號一表通 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/8b9398e2727f46cfbd24baef9088046f style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/6a82b17b.html title=辦公室改稿必會必備：修改校對常用符號一表通>辦公室改稿必會必備：修改校對常用符號一表通</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/bca6dd56.html alt=程序員必知必會10大基礎算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S0RAqe1BkHUrEc style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/bca6dd56.html title=程序員必知必會10大基礎算法>程序員必知必會10大基礎算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/ac394c0c.html alt=炒股必會波浪理論系列之第2篇 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/81b7d1d731ff429e9f63d1f93ad5d9e9 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/ac394c0c.html title=炒股必會波浪理論系列之第2篇>炒股必會波浪理論系列之第2篇</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/4df67fac.html alt=做自控必會低壓斷路器，手把手教你入門！ class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/15347562306036affecaa3c style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/4df67fac.html title=做自控必會低壓斷路器，手把手教你入門！>做自控必會低壓斷路器，手把手教你入門！</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/691f963e.html alt=程序員練級之路，高薪程序員必會知識，Hash衝突，樹化是什麼意思 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/913668674f0d4e629060e223c434f97b style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/691f963e.html title=程序員練級之路，高薪程序員必會知識，Hash衝突，樹化是什麼意思>程序員練級之路，高薪程序員必會知識，Hash衝突，樹化是什麼意思</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/d5f799be.html alt=程序猿編程必會基礎和指南（上部） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/401e00041a39193864e7 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/d5f799be.html title=程序猿編程必會基礎和指南（上部）>程序猿編程必會基礎和指南（上部）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/7563dd30.html alt=零基礎小白必會的10個經典C語言算法 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/1531794040879ea18a6f1a8 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/7563dd30.html title=零基礎小白必會的10個經典C語言算法>零基礎小白必會的10個經典C語言算法</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/b0aca4ae.html alt="必知必會的 Vim 編輯器基礎命令 | Linux 中國" class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/b2afd30a9130417c885ac44dd6335914 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/b0aca4ae.html title="必知必會的 Vim 編輯器基礎命令 | Linux 中國">必知必會的 Vim 編輯器基礎命令 | Linux 中國</a></li><hr><li><a href=../../tw/%E7%A7%91%E5%AD%B8/6c823316.html alt=初中必會幾何模型（口訣突破）：手拉手模型（或旋轉型） class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p3.pstatp.com/large/pgc-image/af3d6fa7183a47a98414eb4410772850 style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E5%AD%B8/6c823316.html title=初中必會幾何模型（口訣突破）：手拉手模型（或旋轉型）>初中必會幾何模型（口訣突破）：手拉手模型（或旋轉型）</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/fc90f17d.html alt=「大彙總」2017年消防考試必會的計算題，收好了 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/437f0001fd89c525555a style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/fc90f17d.html title=「大彙總」2017年消防考試必會的計算題，收好了>「大彙總」2017年消防考試必會的計算題，收好了</a></li><hr><li><a href=../../tw/%E7%A7%91%E6%8A%80/c126e804.html alt=產品經理必會：項目管理流程 class="image featured" style=display:block;margin-left:auto;margin-right:auto;width:100%><img src=https://p1.pstatp.com/large/pgc-image/S6mYp6b2gXAllh style=border-radius:25px></a>
<a href=../../tw/%E7%A7%91%E6%8A%80/c126e804.html title=產品經理必會：項目管理流程>產品經理必會：項目管理流程</a></li><hr></ul></section><section class=widget><h3 class=widget-title>其他</h3><ul class=widget-list><li><a href=TOS.html>使用條款</a></li><li><a href=CommentPolicy.html>留言政策</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>DMCA</a></li><li><a href=mailto:gdnews@tuta.io rel=nofollow>聯絡我們</a></li></ul></section></div></div></div></div><footer id=footer><div class=container>&copy; 2020 <a href>极客快訊</a></div></footer><script type=text/javascript>window.MathJax={tex2jax:{inlineMath:[['$','$']],processEscapes:true}};</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script><a id=rocket href=#top></a><script type=text/javascript src=https://kknews.cf/js/totop.js async></script><script type=text/javascript src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5e508ed9e4e698bb"></script></body></html>